head	1.139;
access;
symbols
	OPENBSD_6_1:1.136.0.4
	OPENBSD_6_1_BASE:1.136
	OPENBSD_6_0:1.128.0.4
	OPENBSD_6_0_BASE:1.128
	OPENBSD_5_9:1.126.0.2
	OPENBSD_5_9_BASE:1.126
	OPENBSD_5_8:1.120.0.4
	OPENBSD_5_8_BASE:1.120
	OPENBSD_5_7:1.115.0.2
	OPENBSD_5_7_BASE:1.115
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.91.0.4
	OPENBSD_5_5_BASE:1.91
	OPENBSD_5_4:1.81.0.2
	OPENBSD_5_4_BASE:1.81
	OPENBSD_5_3:1.72.0.4
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.72.0.2
	OPENBSD_5_2_BASE:1.72
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.68.0.2
	OPENBSD_5_0_BASE:1.68
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.60.0.4
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.54.0.4
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.52.0.4
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.52.0.2
	OPENBSD_4_4_BASE:1.52
	OPENBSD_4_3:1.51.0.2
	OPENBSD_4_3_BASE:1.51
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.42.0.2
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.37.0.2
	OPENBSD_3_6_BASE:1.37
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.30
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.4
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.14
	OPENBSD_2_6:1.13.0.2
	OPENBSD_2_6_BASE:1.13
	OPENBSD_2_5:1.12.0.4
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.139
date	2017.05.29.14.36.22;	author mpi;	state Exp;
branches;
next	1.138;
commitid	Bm2EDWmoITKmkDvl;

1.138
date	2017.05.16.12.24.01;	author mpi;	state Exp;
branches;
next	1.137;
commitid	SAe3SQ48vKH6r5FL;

1.137
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.136;
commitid	Gef6NNDxonzfVaq2;

1.136
date	2017.03.27.09.38.03;	author rzalamena;	state Exp;
branches;
next	1.135;
commitid	CsvJi79SiZGKVeZQ;

1.135
date	2017.02.16.10.15.12;	author mpi;	state Exp;
branches;
next	1.134;
commitid	NChVcK48FdZeU9j9;

1.134
date	2017.02.07.10.08.21;	author mpi;	state Exp;
branches;
next	1.133;
commitid	gzLIBtF3UIhyOxtA;

1.133
date	2016.12.20.12.35.38;	author bluhm;	state Exp;
branches;
next	1.132;
commitid	aFUPSC4QuRteuHG4;

1.132
date	2016.12.19.11.30.26;	author mpi;	state Exp;
branches;
next	1.131;
commitid	VqX7K2LTAQrnZsxG;

1.131
date	2016.12.19.10.35.12;	author bluhm;	state Exp;
branches;
next	1.130;
commitid	JvarKoTTudqnBONG;

1.130
date	2016.12.05.15.31.43;	author mpi;	state Exp;
branches;
next	1.129;
commitid	AOtklk1hjZFcYx3o;

1.129
date	2016.09.04.10.32.01;	author mpi;	state Exp;
branches;
next	1.128;
commitid	0JNLzz71W0Jm1WWQ;

1.128
date	2016.06.13.10.34.40;	author mpi;	state Exp;
branches;
next	1.127;
commitid	Lm2Xf1RxdPM3vZDo;

1.127
date	2016.04.18.06.43.51;	author mpi;	state Exp;
branches;
next	1.126;
commitid	ebRPaHlX9XKssC0C;

1.126
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.125;
commitid	5qLGnZtXVLeqUvHc;

1.125
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.124;
commitid	nmbu8xP0zmz2PPN0;

1.124
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.123;
commitid	djjKhPvMtRdFfuFJ;

1.123
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.122;
commitid	L7FukNYlBzoQuXvw;

1.122
date	2015.09.09.20.12.36;	author dlg;	state Exp;
branches;
next	1.121;
commitid	epgaIV5OBwnskt79;

1.121
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.120;
commitid	0LcoZC9QTu9wgpyX;

1.120
date	2015.07.08.07.56.51;	author mpi;	state Exp;
branches;
next	1.119;
commitid	2410UDx2ojGksNwU;

1.119
date	2015.07.06.09.01.58;	author mpi;	state Exp;
branches;
next	1.118;
commitid	rwisFfIT0CQePadR;

1.118
date	2015.07.06.08.53.38;	author mpi;	state Exp;
branches;
next	1.117;
commitid	5rRzGBfYtm1gsZbJ;

1.117
date	2015.05.26.12.19.51;	author mpi;	state Exp;
branches;
next	1.116;
commitid	iiHJitHd0U6t7lGT;

1.116
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.115;
commitid	Gl6pqKOqk2n9Lwhq;

1.115
date	2015.01.12.13.51.45;	author mpi;	state Exp;
branches;
next	1.114;
commitid	v60fHRGiGOxDVlm2;

1.114
date	2015.01.05.10.21.58;	author mpi;	state Exp;
branches;
next	1.113;
commitid	WRnKoWTxmgq70FTD;

1.113
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.112;
commitid	zhW8jJrfVCoAthrR;

1.112
date	2014.11.25.15.35.10;	author mpi;	state Exp;
branches;
next	1.111;
commitid	ckGoHy7P4urTJnRb;

1.111
date	2014.11.24.12.43.54;	author mpi;	state Exp;
branches;
next	1.110;
commitid	xHA3kihmdbMHtfu3;

1.110
date	2014.11.20.15.55.04;	author tedu;	state Exp;
branches;
next	1.109;
commitid	dQlDAqnjJpCZ1ssk;

1.109
date	2014.11.20.10.06.54;	author mpi;	state Exp;
branches;
next	1.108;
commitid	cg16TwKNa2E033sY;

1.108
date	2014.11.20.10.05.37;	author mpi;	state Exp;
branches;
next	1.107;
commitid	Bs5q6XzCr95LcvIx;

1.107
date	2014.11.05.14.40.51;	author mpi;	state Exp;
branches;
next	1.106;
commitid	9EwXrcedyuluK899;

1.106
date	2014.10.07.08.47.28;	author mpi;	state Exp;
branches;
next	1.105;
commitid	YwQD6dPTFjvxMtlw;

1.105
date	2014.10.02.12.12.51;	author mpi;	state Exp;
branches;
next	1.104;
commitid	w15vGmjFeohVwdUY;

1.104
date	2014.10.01.16.35.45;	author mpi;	state Exp;
branches;
next	1.103;
commitid	kEnzryikfcEoy2oU;

1.103
date	2014.09.03.08.59.06;	author mpi;	state Exp;
branches;
next	1.102;
commitid	RRSgqYJhDYjWwj0h;

1.102
date	2014.08.23.18.32.55;	author bluhm;	state Exp;
branches;
next	1.101;
commitid	uwkwO1GWRuwgOre4;

1.101
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.100;
commitid	B4dZSbxas1X1IpXI;

1.100
date	2014.07.12.14.26.00;	author mpi;	state Exp;
branches;
next	1.99;
commitid	y5pjyU9NAzEZKp4W;

1.99
date	2014.06.26.13.08.25;	author mpi;	state Exp;
branches;
next	1.98;
commitid	8i8VaO1EEFXK0ftu;

1.98
date	2014.06.16.19.47.21;	author mpi;	state Exp;
branches;
next	1.97;
commitid	deajIXmw3XdMzcAI;

1.97
date	2014.06.11.11.30.03;	author mpi;	state Exp;
branches;
next	1.96;
commitid	u5dv1nnY95B2omrl;

1.96
date	2014.04.25.09.44.38;	author mpi;	state Exp;
branches;
next	1.95;

1.95
date	2014.04.10.13.47.21;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2014.03.21.10.32.17;	author mpi;	state Exp;
branches;
next	1.92;

1.92
date	2014.03.14.12.08.18;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.90;

1.90
date	2013.12.31.03.24.44;	author tedu;	state Exp;
branches;
next	1.89;

1.89
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.88;

1.88
date	2013.10.23.13.39.35;	author mpi;	state Exp;
branches;
next	1.87;

1.87
date	2013.10.18.09.04.02;	author mpi;	state Exp;
branches;
next	1.86;

1.86
date	2013.10.09.09.33.43;	author mpi;	state Exp;
branches;
next	1.85;

1.85
date	2013.09.26.08.53.17;	author mpi;	state Exp;
branches;
next	1.84;

1.84
date	2013.08.28.07.30.55;	author mpi;	state Exp;
branches;
next	1.83;

1.83
date	2013.08.19.08.45.34;	author mpi;	state Exp;
branches;
next	1.82;

1.82
date	2013.08.08.07.39.13;	author mpi;	state Exp;
branches;
next	1.81;

1.81
date	2013.06.23.16.30.46;	author sthen;	state Exp;
branches;
next	1.80;

1.80
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.79;

1.79
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2013.06.17.11.58.16;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.31.19.16.52;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2013.05.13.10.17.13;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2013.04.17.08.25.37;	author mpi;	state Exp;
branches;
next	1.74;

1.74
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.73;

1.73
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.72;

1.72
date	2012.07.10.08.31.51;	author claudio;	state Exp;
branches;
next	1.71;

1.71
date	2012.07.08.16.36.58;	author bluhm;	state Exp;
branches;
next	1.70;

1.70
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.06.01.57.37;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2011.07.03.06.24.13;	author dlg;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.02.04.37.04;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.28.09.56.27;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.28.20.24.33;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2010.11.17.19.25.49;	author henning;	state Exp;
branches;
next	1.62;

1.62
date	2010.11.17.19.21.28;	author henning;	state Exp;
branches;
next	1.61;

1.61
date	2010.11.17.18.48.26;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2010.01.13.10.45.21;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2010.01.13.10.30.31;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2010.01.13.07.05.28;	author henning;	state Exp;
branches;
next	1.57;

1.57
date	2010.01.13.02.13.12;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2010.01.13.01.26.28;	author henning;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2008.06.04.18.11.35;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.01.16.39.30;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.17.09.33.57;	author markus;	state Exp;
branches;
next	1.49;

1.49
date	2007.07.20.19.00.35;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.04.12.15.53;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.27.20.04.25;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.02.11.41.28;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.05.21.48.56;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.21.15.33.59;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2005.06.03.08.14.01;	author pascoe;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.07.10.40.42;	author claudio;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2005.01.15.09.09.27;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.18.23.14.49;	author dhartmei;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.24.20.31.16;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.21.23.48.09;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2004.05.31.10.48.48;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2004.03.28.17.39.12;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.23.08.09.21;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.28.13;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.04.05.23.39;	author henric;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.12.13.31.20;	author art;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.24.00.51.51;	author dhartmei;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.01.02.44.08;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.24.19.29.06;	author deraadt;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.07.27.02.17.54;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.23.14.23.21;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.08.03.53.45;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.16.12.53.35;	author ho;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.06.05.52.00;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.22.03.48.30;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.12.06.46.31;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.04.21.38.56;	author fgsch;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.12.08.06.50.19;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	99.04.20.20.06.11;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	98.04.25.23.38.21;	author d;	state Exp;
branches;
next	1.11;

1.11
date	98.03.27.18.59.56;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	98.03.20.02.45.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.03.19.21.21.44;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	98.02.28.03.39.56;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	98.02.25.23.44.57;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	98.02.25.11.17.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	98.02.25.04.53.09;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	98.02.25.03.45.14;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	96.09.12.06.04.47;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.10;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2000.03.24.09.09.35;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.05.14.22.40.07;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.07.04.10.54.31;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.15.2.7;

1.15.2.7
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	1.15.2.8;

1.15.2.8
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.15.2.9;

1.15.2.9
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	1.15.2.10;

1.15.2.10
date	2004.06.05.23.11.25;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.10.29.00.36.46;	author art;	state Exp;
branches;
next	;

1.40.2.1
date	2005.06.11.03.09.49;	author brad;	state Exp;
branches;
next	;


desc
@@


1.139
log
@Per-interface list of addresses, both multicast and unicast, are
currently protected by the NET_LOCK().

They are not accessed in the hot path, so protecting them with a
mutex could be an option.  However since we're now going to run
with a NET_LOCK() for some time, assert that it is held.

IPsec is not yet ready to run without KERNEL_LOCK(), so assert it
is held, even in the forwarding path.

Tested by sthen@@, ok visa@@, claudio@@, bluhm@@
@
text
@/*	$OpenBSD: in.c,v 1.138 2017/05/16 12:24:01 mpi Exp $	*/
/*	$NetBSD: in.c,v 1.26 1996/02/13 23:41:39 christos Exp $	*/

/*
 * Copyright (C) 2001 WIDE Project.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in.c	8.2 (Berkeley) 11/15/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/igmp_var.h>

#ifdef MROUTING
#include <netinet/ip_mroute.h>
#endif

#include "ether.h"


void in_socktrim(struct sockaddr_in *);
int in_lifaddr_ioctl(u_long, caddr_t, struct ifnet *, int);

void in_purgeaddr(struct ifaddr *);
int in_addhost(struct in_ifaddr *, struct sockaddr_in *);
int in_scrubhost(struct in_ifaddr *, struct sockaddr_in *);
int in_insert_prefix(struct in_ifaddr *);
void in_remove_prefix(struct in_ifaddr *);

/*
 * Determine whether an IP address is in a reserved set of addresses
 * that may not be forwarded, or whether datagrams to that destination
 * may be forwarded.
 */
int
in_canforward(struct in_addr in)
{
	u_int32_t net;

	if (IN_EXPERIMENTAL(in.s_addr) || IN_MULTICAST(in.s_addr))
		return (0);
	if (IN_CLASSA(in.s_addr)) {
		net = in.s_addr & IN_CLASSA_NET;
		if (net == 0 ||
		    net == htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))
			return (0);
	}
	return (1);
}

/*
 * Trim a mask in a sockaddr
 */
void
in_socktrim(struct sockaddr_in *ap)
{
	char *cplim = (char *) &ap->sin_addr;
	char *cp = (char *) (&ap->sin_addr + 1);

	ap->sin_len = 0;
	while (--cp >= cplim)
		if (*cp) {
			(ap)->sin_len = cp - (char *) (ap) + 1;
			break;
		}
}

int
in_mask2len(struct in_addr *mask)
{
	int x, y;
	u_char *p;

	p = (u_char *)mask;
	for (x = 0; x < sizeof(*mask); x++) {
		if (p[x] != 0xff)
			break;
	}
	y = 0;
	if (x < sizeof(*mask)) {
		for (y = 0; y < 8; y++) {
			if ((p[x] & (0x80 >> y)) == 0)
				break;
		}
	}
	return x * 8 + y;
}

void
in_len2mask(struct in_addr *mask, int len)
{
	int i;
	u_char *p;

	p = (u_char *)mask;
	bzero(mask, sizeof(*mask));
	for (i = 0; i < len / 8; i++)
		p[i] = 0xff;
	if (len % 8)
		p[i] = (0xff00 >> (len % 8)) & 0xff;
}

/*
 * Generic internet control operations (ioctl's).
 */
int
in_control(struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp)
{
	int privileged;

	privileged = 0;
	if ((so->so_state & SS_PRIV) != 0)
		privileged++;

	switch (cmd) {
#ifdef MROUTING
	case SIOCGETVIFCNT:
	case SIOCGETSGCNT:
		return (mrt_ioctl(so, cmd, data));
#endif /* MROUTING */
	case SIOCALIFADDR:
	case SIOCDLIFADDR:
		if (!privileged)
			return (EPERM);
		/* FALLTHROUGH */
	case SIOCGLIFADDR:
		if (ifp == NULL)
			return (EINVAL);
		return in_lifaddr_ioctl(cmd, data, ifp, privileged);
	default:
		if (ifp == NULL)
			return (EOPNOTSUPP);
	}

	return (in_ioctl(cmd, data, ifp, privileged));
}

int
in_ioctl(u_long cmd, caddr_t data, struct ifnet *ifp, int privileged)
{
	struct ifreq *ifr = (struct ifreq *)data;
	struct ifaddr *ifa;
	struct in_ifaddr *ia = NULL;
	struct in_aliasreq *ifra = (struct in_aliasreq *)data;
	struct sockaddr_in oldaddr;
	int error;
	int newifaddr;

	NET_ASSERT_LOCKED();

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET) {
			ia = ifatoia(ifa);
			break;
		}
	}

	switch (cmd) {

	case SIOCAIFADDR:
	case SIOCDIFADDR:
		if (ifra->ifra_addr.sin_family == AF_INET) {
			for (; ifa != NULL; ifa = TAILQ_NEXT(ifa, ifa_list)) {
				if ((ifa->ifa_addr->sa_family == AF_INET) &&
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr ==
				    ifra->ifra_addr.sin_addr.s_addr)
					break;
			}
			ia = ifatoia(ifa);
		}
		if (cmd == SIOCDIFADDR && ia == NULL)
			return (EADDRNOTAVAIL);
		/* FALLTHROUGH */
	case SIOCSIFADDR:
		if (!privileged)
			return (EPERM);

		if (ia == NULL) {
			ia = malloc(sizeof *ia, M_IFADDR, M_WAITOK | M_ZERO);
			ia->ia_addr.sin_family = AF_INET;
			ia->ia_addr.sin_len = sizeof(ia->ia_addr);
			ia->ia_ifa.ifa_addr = sintosa(&ia->ia_addr);
			ia->ia_ifa.ifa_dstaddr = sintosa(&ia->ia_dstaddr);
			ia->ia_ifa.ifa_netmask = sintosa(&ia->ia_sockmask);
			ia->ia_sockmask.sin_len = 8;
			if (ifp->if_flags & IFF_BROADCAST) {
				ia->ia_broadaddr.sin_len = sizeof(ia->ia_addr);
				ia->ia_broadaddr.sin_family = AF_INET;
			}
			ia->ia_ifp = ifp;

			newifaddr = 1;
		} else
			newifaddr = 0;
		break;

	case SIOCSIFNETMASK:
	case SIOCSIFDSTADDR:
	case SIOCSIFBRDADDR:
		if (!privileged)
			return (EPERM);
		/* FALLTHROUGH */

	case SIOCGIFADDR:
	case SIOCGIFNETMASK:
	case SIOCGIFDSTADDR:
	case SIOCGIFBRDADDR:
		if (ia && satosin(&ifr->ifr_addr)->sin_addr.s_addr) {
			for (; ifa != NULL; ifa = TAILQ_NEXT(ifa, ifa_list)) {
				if ((ifa->ifa_addr->sa_family == AF_INET) &&
				    ifatoia(ifa)->ia_addr.sin_addr.s_addr ==
				    satosin(&ifr->ifr_addr)->sin_addr.s_addr) {
					ia = ifatoia(ifa);
					break;
				}
			}
		}
		if (ia == NULL)
			return (EADDRNOTAVAIL);
		break;
	}
	switch (cmd) {

	case SIOCGIFADDR:
		*satosin(&ifr->ifr_addr) = ia->ia_addr;
		break;

	case SIOCGIFBRDADDR:
		if ((ifp->if_flags & IFF_BROADCAST) == 0)
			return (EINVAL);
		*satosin(&ifr->ifr_dstaddr) = ia->ia_broadaddr;
		break;

	case SIOCGIFDSTADDR:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return (EINVAL);
		*satosin(&ifr->ifr_dstaddr) = ia->ia_dstaddr;
		break;

	case SIOCGIFNETMASK:
		*satosin(&ifr->ifr_addr) = ia->ia_sockmask;
		break;

	case SIOCSIFDSTADDR:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return (EINVAL);
		oldaddr = ia->ia_dstaddr;
		ia->ia_dstaddr = *satosin(&ifr->ifr_dstaddr);
		if (ifp->if_ioctl && (error = (*ifp->if_ioctl)
					(ifp, SIOCSIFDSTADDR, (caddr_t)ia))) {
			ia->ia_dstaddr = oldaddr;
			return (error);
		}
		in_scrubhost(ia, &oldaddr);
		in_addhost(ia, &ia->ia_dstaddr);
		break;

	case SIOCSIFBRDADDR:
		if ((ifp->if_flags & IFF_BROADCAST) == 0)
			return (EINVAL);
		ifa_update_broadaddr(ifp, &ia->ia_ifa, &ifr->ifr_broadaddr);
		break;

	case SIOCSIFADDR:
		in_ifscrub(ifp, ia);
		error = in_ifinit(ifp, ia, satosin(&ifr->ifr_addr), newifaddr);
		if (!error)
			dohooks(ifp->if_addrhooks, 0);
		return (error);

	case SIOCSIFNETMASK:
		ia->ia_netmask = ia->ia_sockmask.sin_addr.s_addr =
		    ifra->ifra_addr.sin_addr.s_addr;
		break;

	case SIOCAIFADDR: {
		int needinit = 0;

		error = 0;

		if (ia->ia_addr.sin_family == AF_INET) {
			if (ifra->ifra_addr.sin_len == 0)
				ifra->ifra_addr = ia->ia_addr;
			else if (ifra->ifra_addr.sin_addr.s_addr !=
			    ia->ia_addr.sin_addr.s_addr || newifaddr)
				needinit = 1;
		}
		if (ifra->ifra_mask.sin_len) {
			in_ifscrub(ifp, ia);
			ia->ia_sockmask = ifra->ifra_mask;
			ia->ia_netmask = ia->ia_sockmask.sin_addr.s_addr;
			needinit = 1;
		}
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    (ifra->ifra_dstaddr.sin_family == AF_INET)) {
			in_ifscrub(ifp, ia);
			ia->ia_dstaddr = ifra->ifra_dstaddr;
			needinit  = 1;
		}
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    (ifra->ifra_broadaddr.sin_family == AF_INET)) {
			if (newifaddr)
				ia->ia_broadaddr = ifra->ifra_broadaddr;
			else
				ifa_update_broadaddr(ifp, &ia->ia_ifa,
				    sintosa(&ifra->ifra_broadaddr));
		}
		if (ifra->ifra_addr.sin_family == AF_INET && needinit) {
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, newifaddr);
		}
		if (!error)
			dohooks(ifp->if_addrhooks, 0);
		return (error);
		}
	case SIOCDIFADDR:
		/*
		 * Even if the individual steps were safe, shouldn't
		 * these kinds of changes happen atomically?  What 
		 * should happen to a packet that was routed after
		 * the scrub but before the other steps? 
		 */
		in_purgeaddr(&ia->ia_ifa);
		dohooks(ifp->if_addrhooks, 0);
		break;

	default:
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		error = ((*ifp->if_ioctl)(ifp, cmd, data));
		return (error);
	}
	return (0);
}

/*
 * SIOC[GAD]LIFADDR.
 *	SIOCGLIFADDR: get first address. (???)
 *	SIOCGLIFADDR with IFLR_PREFIX:
 *		get first address that matches the specified prefix.
 *	SIOCALIFADDR: add the specified address.
 *	SIOCALIFADDR with IFLR_PREFIX:
 *		EINVAL since we can't deduce hostid part of the address.
 *	SIOCDLIFADDR: delete the specified address.
 *	SIOCDLIFADDR with IFLR_PREFIX:
 *		delete the first address that matches the specified prefix.
 * return values:
 *	EINVAL on invalid parameters
 *	EADDRNOTAVAIL on prefix match failed/specified address not found
 *	other values may be returned from in_ioctl()
 */
int
in_lifaddr_ioctl(u_long cmd, caddr_t data, struct ifnet *ifp, int privileged)
{
	struct if_laddrreq *iflr = (struct if_laddrreq *)data;
	struct ifaddr *ifa;
	struct sockaddr *sa;

	/* sanity checks */
	if (!data || !ifp) {
		panic("invalid argument to in_lifaddr_ioctl");
		/*NOTRECHED*/
	}

	switch (cmd) {
	case SIOCGLIFADDR:
		/* address must be specified on GET with IFLR_PREFIX */
		if ((iflr->flags & IFLR_PREFIX) == 0)
			break;
		/*FALLTHROUGH*/
	case SIOCALIFADDR:
	case SIOCDLIFADDR:
		/* address must be specified on ADD and DELETE */
		sa = sstosa(&iflr->addr);
		if (sa->sa_family != AF_INET)
			return EINVAL;
		if (sa->sa_len != sizeof(struct sockaddr_in))
			return EINVAL;
		/* XXX need improvement */
		sa = sstosa(&iflr->dstaddr);
		if (sa->sa_family
		 && sa->sa_family != AF_INET)
			return EINVAL;
		if (sa->sa_len && sa->sa_len != sizeof(struct sockaddr_in))
			return EINVAL;
		break;
	default: /*shouldn't happen*/
#if 0
		panic("invalid cmd to in_lifaddr_ioctl");
		/*NOTREACHED*/
#else
		return EOPNOTSUPP;
#endif
	}
	if (sizeof(struct in_addr) * 8 < iflr->prefixlen)
		return EINVAL;

	switch (cmd) {
	case SIOCALIFADDR:
	    {
		struct in_aliasreq ifra;

		if (iflr->flags & IFLR_PREFIX)
			return EINVAL;

		/* copy args to in_aliasreq, perform ioctl(SIOCAIFADDR). */
		bzero(&ifra, sizeof(ifra));
		memcpy(ifra.ifra_name, iflr->iflr_name,
		    sizeof(ifra.ifra_name));

		memcpy(&ifra.ifra_addr, &iflr->addr, iflr->addr.ss_len);

		if (iflr->dstaddr.ss_family) {	/*XXX*/
			memcpy(&ifra.ifra_dstaddr, &iflr->dstaddr,
			    iflr->dstaddr.ss_len);
		}

		ifra.ifra_mask.sin_family = AF_INET;
		ifra.ifra_mask.sin_len = sizeof(struct sockaddr_in);
		in_len2mask(&ifra.ifra_mask.sin_addr, iflr->prefixlen);

		return in_ioctl(SIOCAIFADDR, (caddr_t)&ifra, ifp, privileged);
	    }
	case SIOCGLIFADDR:
	case SIOCDLIFADDR:
	    {
		struct in_ifaddr *ia;
		struct in_addr mask, candidate, match;
		struct sockaddr_in *sin;
		int cmp;

		bzero(&mask, sizeof(mask));
		if (iflr->flags & IFLR_PREFIX) {
			/* lookup a prefix rather than address. */
			in_len2mask(&mask, iflr->prefixlen);

			sin = (struct sockaddr_in *)&iflr->addr;
			match.s_addr = sin->sin_addr.s_addr;
			match.s_addr &= mask.s_addr;

			/* if you set extra bits, that's wrong */
			if (match.s_addr != sin->sin_addr.s_addr)
				return EINVAL;

			cmp = 1;
		} else {
			if (cmd == SIOCGLIFADDR) {
				/* on getting an address, take the 1st match */
				cmp = 0;	/*XXX*/
			} else {
				/* on deleting an address, do exact match */
				in_len2mask(&mask, 32);
				sin = (struct sockaddr_in *)&iflr->addr;
				match.s_addr = sin->sin_addr.s_addr;

				cmp = 1;
			}
		}

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;
			if (!cmp)
				break;
			candidate.s_addr = ((struct sockaddr_in *)&ifa->ifa_addr)->sin_addr.s_addr;
			candidate.s_addr &= mask.s_addr;
			if (candidate.s_addr == match.s_addr)
				break;
		}
		if (!ifa)
			return EADDRNOTAVAIL;
		ia = ifatoia(ifa);

		if (cmd == SIOCGLIFADDR) {
			/* fill in the if_laddrreq structure */
			memcpy(&iflr->addr, &ia->ia_addr, ia->ia_addr.sin_len);

			if ((ifp->if_flags & IFF_POINTOPOINT) != 0) {
				memcpy(&iflr->dstaddr, &ia->ia_dstaddr,
				    ia->ia_dstaddr.sin_len);
			} else
				bzero(&iflr->dstaddr, sizeof(iflr->dstaddr));

			iflr->prefixlen =
				in_mask2len(&ia->ia_sockmask.sin_addr);

			iflr->flags = 0;	/*XXX*/

			return 0;
		} else {
			struct in_aliasreq ifra;

			/* fill in_aliasreq and do ioctl(SIOCDIFADDR) */
			bzero(&ifra, sizeof(ifra));
			memcpy(ifra.ifra_name, iflr->iflr_name,
			    sizeof(ifra.ifra_name));

			memcpy(&ifra.ifra_addr, &ia->ia_addr,
			    ia->ia_addr.sin_len);
			if ((ifp->if_flags & IFF_POINTOPOINT) != 0) {
				memcpy(&ifra.ifra_dstaddr, &ia->ia_dstaddr,
				    ia->ia_dstaddr.sin_len);
			}
			memcpy(&ifra.ifra_dstaddr, &ia->ia_sockmask,
			    ia->ia_sockmask.sin_len);

			return in_ioctl(SIOCDIFADDR, (caddr_t)&ifra, ifp,
			    privileged);
		}
	    }
	}

	return EOPNOTSUPP;	/*just for safety*/
}

/*
 * Delete any existing route for an interface.
 */
void
in_ifscrub(struct ifnet *ifp, struct in_ifaddr *ia)
{
	if (ISSET(ifp->if_flags, IFF_POINTOPOINT))
		in_scrubhost(ia, &ia->ia_dstaddr);
	else if (!ISSET(ifp->if_flags, IFF_LOOPBACK))
		in_remove_prefix(ia);
}

/*
 * Initialize an interface's internet address
 * and routing table entry.
 */
int
in_ifinit(struct ifnet *ifp, struct in_ifaddr *ia, struct sockaddr_in *sin,
    int newaddr)
{
	u_int32_t i = sin->sin_addr.s_addr;
	struct sockaddr_in oldaddr;
	int error = 0, rterror;

	NET_ASSERT_LOCKED();

	/*
	 * Always remove the address from the tree to make sure its
	 * position gets updated in case the key changes.
	 */
	if (!newaddr) {
		rt_ifa_dellocal(&ia->ia_ifa);
		ifa_del(ifp, &ia->ia_ifa);
	}
	oldaddr = ia->ia_addr;
	ia->ia_addr = *sin;

	if (ia->ia_netmask == 0) {
		if (IN_CLASSA(i))
			ia->ia_netmask = IN_CLASSA_NET;
		else if (IN_CLASSB(i))
			ia->ia_netmask = IN_CLASSB_NET;
		else
			ia->ia_netmask = IN_CLASSC_NET;
		ia->ia_sockmask.sin_addr.s_addr = ia->ia_netmask;
	}

	/*
	 * Give the interface a chance to initialize
	 * if this is its first address,
	 * and to validate the address if necessary.
	 */
	if (ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
		ia->ia_addr = oldaddr;
	}

	/*
	 * Add the address to the local list and the global tree.  If an
	 * error occured, put back the original address.
	 */
	ifa_add(ifp, &ia->ia_ifa);
	rterror = rt_ifa_addlocal(&ia->ia_ifa);

	if (rterror) {
		if (!newaddr)
			ifa_del(ifp, &ia->ia_ifa);
		if (!error)
			error = rterror;
		goto out;
	}
	if (error)
		goto out;


	ia->ia_net = i & ia->ia_netmask;
	in_socktrim(&ia->ia_sockmask);
	/*
	 * Add route for the network.
	 */
	ia->ia_ifa.ifa_metric = ifp->if_metric;
	if (ISSET(ifp->if_flags, IFF_BROADCAST)) {
		if (IN_RFC3021_SUBNET(ia->ia_netmask))
			ia->ia_broadaddr.sin_addr.s_addr = 0;
		else {
			ia->ia_broadaddr.sin_addr.s_addr =
			    ia->ia_net | ~ia->ia_netmask;
		}
	}

	if (ISSET(ifp->if_flags, IFF_POINTOPOINT)) {
		/* XXX We should not even call in_ifinit() in this case. */
		if (ia->ia_dstaddr.sin_family != AF_INET)
			goto out;
		error = in_addhost(ia, &ia->ia_dstaddr);
	} else if (!ISSET(ifp->if_flags, IFF_LOOPBACK)) {
		error = in_insert_prefix(ia);
	}

	/*
	 * If the interface supports multicast, join the "all hosts"
	 * multicast group on that interface.
	 */
	if ((ifp->if_flags & IFF_MULTICAST) && ia->ia_allhosts == NULL) {
		struct in_addr addr;

		addr.s_addr = INADDR_ALLHOSTS_GROUP;
		ia->ia_allhosts = in_addmulti(&addr, ifp);
	}

out:
	if (error && newaddr)
		in_purgeaddr(&ia->ia_ifa);

	return (error);
}

void
in_purgeaddr(struct ifaddr *ifa)
{
	struct ifnet *ifp = ifa->ifa_ifp;
	struct in_ifaddr *ia = ifatoia(ifa);
	extern int ifatrash;

	NET_ASSERT_LOCKED();

	in_ifscrub(ifp, ia);

	rt_ifa_dellocal(&ia->ia_ifa);
	rt_ifa_purge(&ia->ia_ifa);
	ifa_del(ifp, &ia->ia_ifa);

	if (ia->ia_allhosts != NULL) {
		in_delmulti(ia->ia_allhosts);
		ia->ia_allhosts = NULL;
	}

	ifatrash++;
	ia->ia_ifp = NULL;
	ifafree(&ia->ia_ifa);
}

int
in_addhost(struct in_ifaddr *ia, struct sockaddr_in *dst)
{
	return rt_ifa_add(&ia->ia_ifa, RTF_HOST, sintosa(dst));
}

int
in_scrubhost(struct in_ifaddr *ia, struct sockaddr_in *dst)
{
	return rt_ifa_del(&ia->ia_ifa, RTF_HOST, sintosa(dst));
}

/*
 * Insert the cloning and broadcast routes for this subnet.
 */
int
in_insert_prefix(struct in_ifaddr *ia)
{
	struct ifaddr *ifa = &ia->ia_ifa;
	int error;

	error = rt_ifa_add(ifa, RTF_CLONING | RTF_CONNECTED, ifa->ifa_addr);
	if (error)
		return (error);

	if (ia->ia_broadaddr.sin_addr.s_addr != 0)
		error = rt_ifa_add(ifa, RTF_HOST | RTF_BROADCAST,
		    ifa->ifa_broadaddr);

	return (error);
}

void
in_remove_prefix(struct in_ifaddr *ia)
{
	struct ifaddr *ifa = &ia->ia_ifa;

	rt_ifa_del(ifa, RTF_CLONING | RTF_CONNECTED, ifa->ifa_addr);

	if (ia->ia_broadaddr.sin_addr.s_addr != 0)
		rt_ifa_del(ifa, RTF_HOST | RTF_BROADCAST, ifa->ifa_broadaddr);
}

/*
 * Return 1 if the address is a local broadcast address.
 */
int
in_broadcast(struct in_addr in, u_int rtableid)
{
	struct ifnet *ifn;
	struct ifaddr *ifa;
	u_int rdomain;

	rdomain = rtable_l2(rtableid);

#define ia (ifatoia(ifa))
	TAILQ_FOREACH(ifn, &ifnet, if_list) {
		if (ifn->if_rdomain != rdomain)
			continue;
		if ((ifn->if_flags & IFF_BROADCAST) == 0)
			continue;
		TAILQ_FOREACH(ifa, &ifn->if_addrlist, ifa_list)
			if (ifa->ifa_addr->sa_family == AF_INET &&
			    in.s_addr != ia->ia_addr.sin_addr.s_addr &&
			    in.s_addr == ia->ia_broadaddr.sin_addr.s_addr)
				return 1;
	}
	return (0);
#undef ia
}

/*
 * Add an address to the list of IP multicast addresses for a given interface.
 */
struct in_multi *
in_addmulti(struct in_addr *ap, struct ifnet *ifp)
{
	struct in_multi *inm;
	struct ifreq ifr;

	/*
	 * See if address already in list.
	 */
	IN_LOOKUP_MULTI(*ap, ifp, inm);
	if (inm != NULL) {
		/*
		 * Found it; just increment the reference count.
		 */
		++inm->inm_refcnt;
	} else {
		if (ifp->if_ioctl == NULL)
			return (NULL);

		/*
		 * New address; allocate a new multicast record
		 * and link it into the interface's multicast list.
		 */
		inm = malloc(sizeof(*inm), M_IPMADDR, M_NOWAIT | M_ZERO);
		if (inm == NULL)
			return (NULL);

		inm->inm_sin.sin_len = sizeof(struct sockaddr_in);
		inm->inm_sin.sin_family = AF_INET;
		inm->inm_sin.sin_addr = *ap;
		inm->inm_refcnt = 1;
		inm->inm_ifidx = ifp->if_index;
		inm->inm_ifma.ifma_addr = sintosa(&inm->inm_sin);

		/*
		 * Ask the network driver to update its multicast reception
		 * filter appropriately for the new address.
		 */
		memset(&ifr, 0, sizeof(ifr));
		memcpy(&ifr.ifr_addr, &inm->inm_sin, sizeof(inm->inm_sin));
		if ((*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0) {
			free(inm, M_IPMADDR, sizeof(*inm));
			return (NULL);
		}

		TAILQ_INSERT_HEAD(&ifp->if_maddrlist, &inm->inm_ifma,
		    ifma_list);

		/*
		 * Let IGMP know that we have joined a new IP multicast group.
		 */
		igmp_joingroup(inm);
	}

	return (inm);
}

/*
 * Delete a multicast address record.
 */
void
in_delmulti(struct in_multi *inm)
{
	struct ifreq ifr;
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	if (--inm->inm_refcnt == 0) {
		/*
		 * No remaining claims to this record; let IGMP know that
		 * we are leaving the multicast group.
		 */
		igmp_leavegroup(inm);
		ifp = if_get(inm->inm_ifidx);

		/*
		 * Notify the network driver to update its multicast
		 * reception filter.
		 */
		if (ifp != NULL) {
			memset(&ifr, 0, sizeof(ifr));
			satosin(&ifr.ifr_addr)->sin_len =
			    sizeof(struct sockaddr_in);
			satosin(&ifr.ifr_addr)->sin_family = AF_INET;
			satosin(&ifr.ifr_addr)->sin_addr = inm->inm_addr;
			(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);

			TAILQ_REMOVE(&ifp->if_maddrlist, &inm->inm_ifma,
			    ifma_list);
		}
		if_put(ifp);

		free(inm, M_IPMADDR, sizeof(*inm));
	}
}

/*
 * Return 1 if the multicast group represented by ``ap'' has been
 * joined by interface ``ifp'', 0 otherwise.
 */
int
in_hasmulti(struct in_addr *ap, struct ifnet *ifp)
{
	struct in_multi *inm;
	int joined;

	IN_LOOKUP_MULTI(*ap, ifp, inm);
	joined = (inm != NULL);

	return (joined);
}

void
in_ifdetach(struct ifnet *ifp)
{
	struct ifaddr *ifa, *next;

	/* nuke any of IPv4 addresses we have */
	TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list, next) {
		if (ifa->ifa_addr->sa_family != AF_INET)
			continue;
		in_purgeaddr(ifa);
		dohooks(ifp->if_addrhooks, 0);
	}
}

void
in_prefixlen2mask(struct in_addr *maskp, int plen)
{
	if (plen == 0)
		maskp->s_addr = 0;
	else
		maskp->s_addr = htonl(0xffffffff << (32 - plen));
}
@


1.138
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.137 2017/05/04 15:00:24 bluhm Exp $	*/
a800 2
	NET_ASSERT_LOCKED();

a901 1
	KERNEL_LOCK();
a903 1
	KERNEL_UNLOCK();
@


1.137
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.136 2017/03/27 09:38:03 rzalamena Exp $	*/
d213 1
a213 1
	splsoftassert(IPL_SOFTNET);
d603 1
a603 1
	splsoftassert(IPL_SOFTNET);
d703 1
a703 1
	splsoftassert(IPL_SOFTNET);
d801 1
a801 1
	splsoftassert(IPL_SOFTNET);
d863 1
a863 1
	splsoftassert(IPL_SOFTNET);
@


1.136
log
@Fix the prefixlen sent by RTM_NEWADDR on new addresses without masks:
calculate the prefixlen using the address before sending the RTM_NEWADDR
message.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.135 2017/02/16 10:15:12 mpi Exp $	*/
d437 1
a437 1
		sa = (struct sockaddr *)&iflr->addr;
d443 1
a443 1
		sa = (struct sockaddr *)&iflr->dstaddr;
d474 1
a474 2
		memcpy(&ifra.ifra_addr, &iflr->addr, 
		    ((struct sockaddr *)&iflr->addr)->sa_len);
d476 1
a476 1
		if (((struct sockaddr *)&iflr->dstaddr)->sa_family) {	/*XXX*/
d478 1
a478 1
			    ((struct sockaddr *)&iflr->dstaddr)->sa_len);
@


1.135
log
@Revert "Release the NET_LOCK() before entering per-driver ioctl() routine".

This is most likely to be the cause of the deadlock seen by port builders
since it's the only changed that happened after a2k17.

Instead bring back pirofti@@ original hack to release the NET_LOCK() inside
iwm(4) and iwn(4).

This fixes some splassert reported by bluhm@@

Deadlock reported by naddy@@ and rpe@@ and ajacoutot@@ confirmed the deadlock
has been introduced post a2k17.

Tested by and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.134 2017/02/07 10:08:21 mpi Exp $	*/
d617 10
a653 9
	if (ia->ia_netmask == 0) {
		if (IN_CLASSA(i))
			ia->ia_netmask = IN_CLASSA_NET;
		else if (IN_CLASSB(i))
			ia->ia_netmask = IN_CLASSB_NET;
		else
			ia->ia_netmask = IN_CLASSC_NET;
		ia->ia_sockmask.sin_addr.s_addr = ia->ia_netmask;
	}
@


1.134
log
@Release the NET_LOCK() before entering per-driver ioctl() routine.

This prevents a deadlock with the X server and some wireless drivers.
The real fix is to take unix domain socket code out of the NET_LOCK().

Issue reported by pirofti@@ and ajacoutot@@

ok tb@@, stsp@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.133 2016/12/20 12:35:38 bluhm Exp $	*/
a392 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a393 1
		rw_enter_write(&netlock);
@


1.133
log
@Remove duplicate in_ioctl() prototype, it is in in_var.h now.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.132 2016/12/19 11:30:26 mpi Exp $	*/
d393 5
a397 1
		return ((*ifp->if_ioctl)(ifp, cmd, data));
@


1.132
log
@Remove a recursive splsoftnet() in in_ioctl() that already asserts that
it is called at IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.131 2016/12/19 10:35:12 bluhm Exp $	*/
a86 1
int in_ioctl(u_long, caddr_t, struct ifnet *, int);
@


1.131
log
@If rt_ifa_addlocal() in in_ifinit() fails, the address has been
added to the interface address list, but the local route is missing.
This inconsistency could result in a "ifa == rt->rt_ifa" assertion
panic later.  So in case of a route add error, remove the interface
address to get a consistent state again.
OK stsp@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.130 2016/12/05 15:31:43 mpi Exp $	*/
a212 1
	int s;
a311 1
		s = splsoftnet();
a316 1
			splx(s);
a320 1
		splx(s);
@


1.130
log
@Remove recursive splsoftnet()s in ioctl(2) path.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.129 2016/09/04 10:32:01 mpi Exp $	*/
d606 1
a606 1
	int error = 0;
d636 1
a636 1
	rt_ifa_addlocal(&ia->ia_ifa);
d638 7
@


1.129
log
@Purge routes attached to an address when this address is removed.

This is done to stop using stale ifa attached to routes, which is
the easiest way to make rtisvalid(9) MP-safe.

sthen@@ and henning@@ like it, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.128 2016/06/13 10:34:40 mpi Exp $	*/
d215 2
a333 1
		s = splsoftnet();
a337 1
		splx(s);
a349 1
		s = splsoftnet();
a381 1
		splx(s);
a390 1
		s = splsoftnet();
a392 1
		splx(s);
d797 2
a798 1
	int s;
a838 1
		s = splsoftnet();
a840 1
		splx(s);
d859 2
a860 1
	int s;
a881 1
			s = splsoftnet();
a883 1
			splx(s);
@


1.128
log
@Move the ioctl(2) logic of in{,6}_control() into two new functions
in{,6}_ioctl() that do not deal with sockets.

This will allow to automagically configure interface addresses in
the kernel without too many layer violations.

Required by upcoming umb(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.127 2016/04/18 06:43:51 mpi Exp $	*/
d702 1
d709 1
d717 1
@


1.127
log
@Put a KERNEL_LOCK/UNLOCK dance around sections that still need some
work in the forwarding path.

Tested by Hrvoje Popovski, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.126 2016/01/21 11:23:48 mpi Exp $	*/
d86 2
a87 3
void in_len2mask(struct in_addr *, int);
int in_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *);
d174 5
a178 8
	struct ifreq *ifr = (struct ifreq *)data;
	struct ifaddr *ifa;
	struct in_ifaddr *ia = NULL;
	struct in_aliasreq *ifra = (struct in_aliasreq *)data;
	struct sockaddr_in oldaddr;
	int error;
	int newifaddr;
	int s;
d188 1
a188 1
		if ((so->so_state & SS_PRIV) == 0)
d194 1
a194 1
		return in_lifaddr_ioctl(so, cmd, data, ifp);
d200 15
d239 1
a239 1
		if ((so->so_state & SS_PRIV) == 0)
d264 1
a264 1
		if ((so->so_state & SS_PRIV) == 0)
d424 1
a424 2
in_lifaddr_ioctl(struct socket *so, u_long cmd, caddr_t data,
    struct ifnet *ifp)
d494 1
a494 1
		return in_control(so, SIOCAIFADDR, (caddr_t)&ifra, ifp);
d579 2
a580 1
			return in_control(so, SIOCDIFADDR, (caddr_t)&ifra, ifp);
@


1.126
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.125 2015/12/03 21:57:59 mpi Exp $	*/
d893 1
d896 1
@


1.125
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.124 2015/11/24 13:37:16 mpi Exp $	*/
d883 15
@


1.124
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.123 2015/09/12 20:50:17 mpi Exp $	*/
d896 9
@


1.123
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.122 2015/09/09 20:12:36 dlg Exp $	*/
a72 5

#include "carp.h"
#if NCARP > 0
#include <net/if_types.h>
#endif
@


1.122
log
@gotta if_put after you if_get

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.121 2015/08/24 14:00:29 bluhm Exp $	*/
d716 1
a716 1
	return rt_ifa_add(&ia->ia_ifa, RTF_UP|RTF_HOST, sintosa(dst));
d734 1
a734 2
	error = rt_ifa_add(ifa, RTF_UP | RTF_CLONING | RTF_CONNECTED,
	    ifa->ifa_addr);
d739 1
a739 1
		error = rt_ifa_add(ifa, RTF_UP | RTF_HOST | RTF_BROADCAST,
@


1.121
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.120 2015/07/08 07:56:51 mpi Exp $	*/
d883 1
@


1.120
log
@Use a new RTF_CONNECTED flag for interface (connected) routes.

Recent changes to support multiple interface routes broke the
assumption made by all our userland routing daemons concerning
interface routes.  Historically such routes had a "gateway"
sockaddr of type AF_LINK.  But to be able to support multiple
interface routes as any other multipath routes, they now have
a unique "gateway" sockaddr containing their corresponding IP
address.

This self-describing flag should avoid ambiguity when dealing
with interface routes.

Issue reported by <mxb AT alumni DOT chalmers DOT se> and benno@@

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.119 2015/07/06 09:01:58 mpi Exp $	*/
d812 1
a812 1
		inm = malloc(sizeof(*inm), M_IPMADDR, M_NOWAIT);
d827 1
d871 1
@


1.119
log
@We're now creating a connected route for every configured address so
there's no need to flag every address as IFA_ROUTE.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.118 2015/07/06 08:53:38 mpi Exp $	*/
d734 2
a735 1
	error = rt_ifa_add(ifa, RTF_UP | RTF_CLONING, ifa->ifa_addr);
d751 1
a751 1
	rt_ifa_del(ifa, 0, ifa->ifa_addr);
@


1.118
log
@No longer need to manually pass RTF_MPATH to rt_ifa_add(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.117 2015/05/26 12:19:51 mpi Exp $	*/
d591 1
a591 2
		if (ia->ia_flags & IFA_ROUTE)
			in_remove_prefix(ia);
a741 3
	if (!error)
		ia->ia_flags |= IFA_ROUTE;

a753 2

	ia->ia_flags &= ~IFA_ROUTE;
@


1.117
log
@Store the IP address of the corresponding ifa in the rt_gateway field
of RTF_CLONING and RTF_BROASCAST routes to not create MPATH conflicts
when IP address aliases are used.

This change makes it possible to have multiple RTF_CLONING routes with
the same priority.  Note that any of the existing RTF_CLONING route
might be used by the kernel to create a RTF_CLONED route which should
not be a problem with aliases since they are attached to the same ifp.

This unbreak address aliases since the kernel supports multiple connected
routes for a subnet.

Found the hardway by djm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.116 2015/05/15 12:00:57 claudio Exp $	*/
d717 1
a717 1
	return rt_ifa_add(&ia->ia_ifa, RTF_UP|RTF_HOST|RTF_MPATH, sintosa(dst));
d723 1
a723 1
	return rt_ifa_del(&ia->ia_ifa, RTF_HOST|RTF_MPATH, sintosa(dst));
@


1.116
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.115 2015/01/12 13:51:45 mpi Exp $	*/
d740 2
a741 2
		error = rt_ifa_add(ifa, RTF_UP | RTF_HOST |
		    RTF_LLINFO | RTF_BROADCAST, ifa->ifa_broadaddr);
d757 1
a757 2
		rt_ifa_del(ifa, RTF_HOST | RTF_LLINFO | RTF_BROADCAST,
		    ifa->ifa_broadaddr);
@


1.115
log
@Kill the global list of IPv4 addresses.

ok claudio@@, mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.114 2015/01/05 10:21:58 mpi Exp $	*/
a95 2
int in_addprefix(struct in_ifaddr *);
int in_scrubprefix(struct in_ifaddr *);
d591 2
a592 1
		in_scrubprefix(ia);
d671 1
a671 1
		error = in_addprefix(ia);
a760 119
}

/*
 * add a route to prefix ("connected route" in cisco terminology).
 * does nothing if there's some interface address with the same prefix already.
 */
int
in_addprefix(struct in_ifaddr *ia0)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct in_ifaddr *ia;
	struct in_addr prefix, mask, p, m;

	prefix = ia0->ia_addr.sin_addr;
	mask = ia0->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
			continue;

		if (ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;

			ia = ifatoia(ifa);

			if ((ia->ia_flags & IFA_ROUTE) == 0)
				continue;

			p = ia->ia_addr.sin_addr;
			m = ia->ia_sockmask.sin_addr;
			p.s_addr &= m.s_addr;

			if (prefix.s_addr != p.s_addr ||
			    mask.s_addr != m.s_addr)
				continue;

#if NCARP > 0
			/* move to a real interface instead of carp interface */
			if (ia->ia_ifp->if_type == IFT_CARP &&
			    ia0->ia_ifp->if_type != IFT_CARP) {
				in_remove_prefix(ia);
				break;
			}
#endif
			/*
			 * If we got a matching prefix route inserted by other
			 * interface address, we don't need to bother
			 */
			return (0);
		}
	}

	/*
	 * noone seem to have prefix route.  insert it.
	 */
	return in_insert_prefix(ia0);
}

/*
 * remove a route to prefix ("connected route" in cisco terminology).
 * re-installs the route by using another interface address, if there's one
 * with the same prefix (otherwise we lose the route mistakenly).
 */
int
in_scrubprefix(struct in_ifaddr *ia0)
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct in_ifaddr *ia;
	struct in_addr prefix, mask, p, m;

	if ((ia0->ia_flags & IFA_ROUTE) == 0)
		return 0;

	prefix = ia0->ia_addr.sin_addr;
	mask = ia0->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
			continue;

		if (ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET)
				continue;

			ia = ifatoia(ifa);

			if ((ia->ia_flags & IFA_ROUTE) != 0)
				continue;

			p = ia->ia_addr.sin_addr;
			m = ia->ia_sockmask.sin_addr;
			p.s_addr &= m.s_addr;

			if (prefix.s_addr != p.s_addr ||
			    mask.s_addr != m.s_addr)
				continue;

			/* Move IFA_ROUTE to the matching prefix route. */
			in_remove_prefix(ia0);
			return (in_insert_prefix(ia));
		}
	}

	/*
	 * noone seem to have prefix route.  remove it.
	 */
	in_remove_prefix(ia0);
	return 0;
@


1.114
log
@Explicitly check for a non NULL ifp in in_control().  Only MROUTING
ioctl(2)s are an exception to this rule.  This makes clear that ifa
cannot be used initialized as found by jsg@@ with gcc/clang.

ok krw@@, bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.113 2014/12/19 17:14:40 tedu Exp $	*/
a609 3
	if (newaddr)
		TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);

d629 10
a639 1
	}
a686 12
	/*
	 * Add the address to the local list and the global tree
	 * even if an error occured to make sure the various
	 * global structures are consistent.
	 *
	 * XXX This is necessary because we added the address
	 * to the global list in the first place because of
	 * carp(4).
	 */
	ifa_add(ifp, &ia->ia_ifa);
	rt_ifa_addlocal(&ia->ia_ifa);

a705 1
	TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
d771 2
d780 2
a781 2
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
d784 1
a784 1
		if ((ia->ia_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)))
d787 8
a794 2
		if ((ia->ia_flags & IFA_ROUTE) == 0)
			continue;
d796 3
a798 3
		p = ia->ia_addr.sin_addr;
		m = ia->ia_sockmask.sin_addr;
		p.s_addr &= m.s_addr;
d800 3
a802 2
		if (prefix.s_addr != p.s_addr || mask.s_addr != m.s_addr)
			continue;
d805 12
a816 5
		/* move to a real interface instead of carp interface */
		if (ia->ia_ifp->if_type == IFT_CARP &&
		    ia0->ia_ifp->if_type != IFT_CARP) {
		    	in_remove_prefix(ia);
			break;
a817 6
#endif
		/*
		 * if we got a matching prefix route inserted by other
		 * interface address, we don't need to bother
		 */
		return 0;
d834 2
d846 2
a847 2
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
d850 1
a850 1
		if ((ia->ia_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)))
d853 8
a860 2
		if ((ia->ia_flags & IFA_ROUTE) != 0)
			continue;
d862 3
a864 3
		p = ia->ia_addr.sin_addr;
		m = ia->ia_sockmask.sin_addr;
		p.s_addr &= m.s_addr;
d866 3
a868 2
		if (prefix.s_addr != p.s_addr || mask.s_addr != m.s_addr)
			continue;
d870 4
a873 5
		/*
		 * if we got a matching prefix route, move IFA_ROUTE to him
		 */
		in_remove_prefix(ia0);
		return in_insert_prefix(ia);
@


1.113
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.112 2014/11/25 15:35:10 mpi Exp $	*/
a177 1
 * Ifp is 0 if not an interface-specific ioctl.
a178 1
/* ARGSUSED */
d192 5
d203 2
a204 2
		if (!ifp)
			return EINVAL;
d206 3
d211 6
a216 9
	/*
	 * Find address for this interface, if it exists.
	 */
	if (ifp)
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list)
			if (ifa->ifa_addr->sa_family == AF_INET) {
				ia = ifatoia(ifa);
				break;
			}
a237 2
		if (ifp == 0)
			panic("in_control");
a394 6
#ifdef MROUTING
	case SIOCGETVIFCNT:
	case SIOCGETSGCNT:
		return (mrt_ioctl(so, cmd, data));
#endif /* MROUTING */

d396 1
a396 1
		if (ifp == 0 || ifp->if_ioctl == 0)
@


1.112
log
@Since in_broadcast() is now used to always iterate on all the interfaces
of your system, put it on a diet and kill the superfluous logic.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.111 2014/11/24 12:43:54 mpi Exp $	*/
a88 1
#ifdef INET
a1005 1
#endif
@


1.111
log
@Rename rt_ifa_addloop() into rt_ifa_addlocal() and make it return an
error code on failure (unchecked for the moment).

ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.110 2014/11/20 15:55:04 tedu Exp $	*/
d879 1
a879 1
 * Return 1 if the address might be a local broadcast address.
d882 1
a882 1
in_broadcast(struct in_addr in, struct ifnet *ifp, u_int rtableid)
d884 1
a884 1
	struct ifnet *ifn, *if_first, *if_target;
a889 12
	if (in.s_addr == INADDR_BROADCAST ||
	    in.s_addr == INADDR_ANY)
		return 1;

	if (ifp == NULL) {
	  	if_first = TAILQ_FIRST(&ifnet);
		if_target = 0;
	} else {
		if_first = ifp;
		if_target = TAILQ_NEXT(ifp, if_list);
	}

d891 1
a891 6
	/*
	 * Look through the list of addresses for a match
	 * with a broadcast address.
	 * If ifp is NULL, check against all the interfaces.
	 */
        for (ifn = if_first; ifn != if_target; ifn = TAILQ_NEXT(ifn, if_list)) {
@


1.110
log
@sizes for simple free cases. sizeof(*) and one case where len is clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.109 2014/11/20 10:06:54 mpi Exp $	*/
d624 1
a624 1
		rt_ifa_delloop(&ia->ia_ifa);
d697 1
a697 1
	rt_ifa_addloop(&ia->ia_ifa);
d715 1
a715 1
	rt_ifa_delloop(&ia->ia_ifa);
@


1.109
log
@funky spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.108 2014/11/20 10:05:37 mpi Exp $	*/
d967 1
a967 1
			free(inm, M_IPMADDR, 0);
d1020 1
a1020 1
		free(inm, M_IPMADDR, 0);
@


1.108
log
@Instead of playing hide-and-seek with the route to destination attached
to p2p interfaces always mark them as Multipath.  This way we can have
multiple routes to the same destination as long as the local address is
different.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.107 2014/11/05 14:40:51 mpi Exp $	*/
d186 1
a186 1
	struct ifaddr *ifa;						\
@


1.107
log
@Did you ever wonder why loopback's ifas have a destination address?

It is of course not to make your life more complicated when you are
dealing with ifa_ifwithaddr()!  It was to reuse the point-to-point
code to add a route to 127.0.0.1.  But now we have local routes and
we don't need this hack anymore :)

ok mikeb@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.106 2014/10/07 08:47:28 mpi Exp $	*/
d99 2
a100 2
int in_addhost(struct in_ifaddr *);
int in_scrubhost(struct in_ifaddr *);
d316 2
a317 5
		if (ia->ia_flags & IFA_ROUTE) {
			rt_ifa_del(&ia->ia_ifa, RTF_HOST, sintosa(&oldaddr));
			rt_ifa_add(&ia->ia_ifa, RTF_UP | RTF_HOST,
			    ia->ia_ifa.ifa_dstaddr);
		}
d597 1
a597 1
		in_scrubhost(ia);
d657 1
a657 1
	if (ifp->if_flags & IFF_BROADCAST) {
d664 4
a667 1
	} else if (ifp->if_flags & IFF_POINTOPOINT) {
d670 3
a674 5
	if (ISSET(ifp->if_flags, IFF_POINTOPOINT))
		error = in_addhost(ia);
	else if (!ISSET(ifp->if_flags, IFF_LOOPBACK))
		error = in_addprefix(ia);

d729 1
a729 1
in_addhost(struct in_ifaddr *ia0)
d731 1
a731 29
	struct in_ifaddr *ia;
	struct in_addr dst;
	int error;

	dst = ia0->ia_dstaddr.sin_addr;

	/*
	 * If an interface already have a route to the same
	 * destination don't do anything.
	 */
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
			continue;

		if (dst.s_addr != ia->ia_dstaddr.sin_addr.s_addr)
			continue;

		if ((ia->ia_flags & IFA_ROUTE) == 0)
			continue;

		return (0);
	}

	error = rt_ifa_add(&ia0->ia_ifa, RTF_UP | RTF_HOST,
	    ia0->ia_ifa.ifa_dstaddr);
	if (!error)
		ia0->ia_flags |= IFA_ROUTE;

	return (error);
d735 1
a735 1
in_scrubhost(struct in_ifaddr *ia0)
d737 1
a737 38
	struct in_ifaddr *ia;
	struct in_addr dst;
	int error;

	if ((ia0->ia_flags & IFA_ROUTE) == 0)
		return (0);

	dst = ia0->ia_dstaddr.sin_addr;

	/*
	 * Because we only add one route for a given destination at
	 * a time, here we need to do some magic to move this route
	 * to another interface if it has the same destination.
	 */
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != ia0->ia_ifp->if_rdomain)
			continue;

		if (dst.s_addr != ia->ia_dstaddr.sin_addr.s_addr)
			continue;

		if ((ia->ia_flags & IFA_ROUTE) != 0)
			continue;

		rt_ifa_del(&ia0->ia_ifa, RTF_HOST, ia0->ia_ifa.ifa_dstaddr);
		ia0->ia_flags &= ~IFA_ROUTE;
		error = rt_ifa_add(&ia->ia_ifa, RTF_UP | RTF_HOST,
		    ia->ia_ifa.ifa_dstaddr);
		if (!error)
			ia->ia_flags |= IFA_ROUTE;

		return (error);
	}

	rt_ifa_del(&ia0->ia_ifa, RTF_HOST, ia0->ia_ifa.ifa_dstaddr);
	ia0->ia_flags &= ~IFA_ROUTE;

	return (0);
@


1.106
log
@Do not protect the SIOCSIFADDR call by splnet().  Drivers already
raise it inside their ioctl handler (except for carp(4), what else?).

In general, global structures manipulated in the softnet codepath only
require a splsoftnet() protection when they are modified in process
(ioctl) context.

Also put some IPL_SOFNET asserts in functions accessing global structures.

Previous version diff ok mikeb@@, with inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.105 2014/10/02 12:12:51 mpi Exp $	*/
a666 2
	} else if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_dstaddr = ia->ia_addr;
@


1.105
log
@There is no point in trying to purge the default host route for
loopback interfaces because we no longer add it.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.104 2014/10/01 16:35:45 mpi Exp $	*/
d615 1
a615 1
	int s, error = 0;
a629 1
	s = splnet();
a640 1
		splx(s);
a642 1
	splx(s);
@


1.104
log
@Fix loopback related breakage introduced by the conversion of in_ouraddr()
to use the routing table.

Do not create a host route for loopback addresses apart from the local
ones otherwise these addresses are not considered as part of the machine.

Reported by deraadt@@ and Heiko Zimmermann on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.103 2014/09/03 08:59:06 mpi Exp $	*/
d599 3
a601 1
	if ((ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) == 0)
a602 2
	else
		in_scrubhost(ia);
@


1.103
log
@When a route to prefix (connected route) is added, if its associated
broadcast address is non null, add a broadcast entry flagged with
RTF_BROADCAST.

Re-use the existing logic to switch a route to prefix from an ifa
to another to also move this broadcast entry.

Prior to this change broadcast entries were simple clonned ARP entries,
that would be deleted once their timer expired since they would always
be incomplete.

With this change they are now persistant and identifiable with a new flag

This version of the diff prevent a corruption reported by millert@@

ok mikeb@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.102 2014/08/23 18:32:55 bluhm Exp $	*/
d677 3
a679 1
	if ((ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) == 0)
a680 2
	else
		error = in_addhost(ia);
@


1.102
log
@Move splnet() in in_ifinit() to protect less code that does not
need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.101 2014/07/12 18:44:23 tedu Exp $	*/
d101 2
d813 37
a857 1
	int error;
d884 1
a884 2
			rt_ifa_del(&ia->ia_ifa, 0, ia->ia_ifa.ifa_addr);
			ia->ia_flags &= ~IFA_ROUTE;
d898 1
a898 5
	error = rt_ifa_add(&ia0->ia_ifa, RTF_UP | RTF_CLONING,
	    ia0->ia_ifa.ifa_addr);
	if (!error)
		ia0->ia_flags |= IFA_ROUTE;
	return error;
a910 1
	int error;
d939 2
a940 7
		rt_ifa_del(&ia0->ia_ifa, 0, ia0->ia_ifa.ifa_addr);
		ia0->ia_flags &= ~IFA_ROUTE;
		error = rt_ifa_add(&ia->ia_ifa, RTF_UP | RTF_CLONING,
		    ia->ia_ifa.ifa_addr);
		if (error == 0)
			ia->ia_flags |= IFA_ROUTE;
		return error;
d946 1
a946 2
	rt_ifa_del(&ia0->ia_ifa, 0, ia0->ia_ifa.ifa_addr);
	ia0->ia_flags &= ~IFA_ROUTE;
@


1.101
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.100 2014/07/12 14:26:00 mpi Exp $	*/
d613 3
a615 1
	int s = splnet(), error = 0;
d628 1
a643 8

	/*
	 * How should a packet be routed during
	 * an address change--and is it safe?
	 * Is the "ifp" even in a consistent state?
	 * Be safe for now.
	 */
	splsoftassert(IPL_SOFTNET);
@


1.100
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

This time, make sure the local route is removed during an address change,
since at least pppoe(4) do some funky magics with wildcard addresses that
might corrupt the routing tree, as found by naddy@@

Also do not add a local route if the specified address is 0.0.0.0, to
prevent a tree corruption, as found by guenther@@.

Putting this in now so that it gets tested, claudio@@ agrees.  Please
contact me if you find any route-related regression caused by this
change.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.99 2014/06/26 13:08:25 mpi Exp $	*/
d1018 1
a1018 1
			free(inm, M_IPMADDR);
d1071 1
a1071 1
		free(inm, M_IPMADDR);
@


1.99
log
@Calling in{6,}_purgeaddr() is not enough to remove an address from
an interface.  Two other operations are performed when issuing a
SIOCDIFADDR{_IN6,} ioctl: call the address hook and the per-driver
ioctl function.

Since carp(4) relies on an address hook to recalculate its hash, make
sure to call this hook when IFXF_NOINET6 is set or when the rdomain is
changed.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.98 2014/06/16 19:47:21 mpi Exp $	*/
d622 2
a623 1
	if (!newaddr)
d625 1
d707 1
d725 1
d727 1
@


1.98
log
@Revert "Always create a local route for every configured IPv4 address",
it introduces a regression with default routes & p2p interfaces.

Problem reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.97 2014/06/11 11:30:03 mpi Exp $	*/
d1082 1
@


1.97
log
@Always create a local route for every configured IPv4 address on the
machine and restore the original behavior of RTM_ADD and RTM_DELETE
by always generating one message per locally configured address.

Tested by krw@@, jca@@ and florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.96 2014/04/25 09:44:38 mpi Exp $	*/
a704 1
	rt_ifa_addloop(&ia->ia_ifa);
a720 2

	rt_ifa_delloop(&ia->ia_ifa);
@


1.96
log
@Kill in_localaddr(), one less usage of the global list of IPv4 addresses.

This function is used only once in our tree to optimize the size of the
MSS if the forward address correspond to a host on one of our subnets,
but only if ip.mutdisc is disable, which is not the default!

While here get rid of the "#ifdef RTV_MTU", it is here.

ok henning@@, mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.95 2014/04/10 13:47:21 mpi Exp $	*/
d705 1
d722 2
@


1.95
log
@Retire rtinit() an use rt_ifa_add(9) and rt_ifa_del(9) to manage
connected routes to prefixes/hosts.

Since the introduction of rt_ifa_addloop(9) and rt_ifa_delloop(9),
rtinit() was just a wrapper, so use the underlying functions
directly and document them.

Inputs from and ok mikeb@@, manpage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.94 2014/03/27 10:39:23 mpi Exp $	*/
a100 16

/* Return 1 if an internet address is for a directly connected host */
int
in_localaddr(struct in_addr in, u_int rdomain)
{
	struct in_ifaddr *ia;

	rdomain = rtable_l2(rdomain);
	TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
		if (ia->ia_ifp->if_rdomain != rdomain)
			continue;
		if ((in.s_addr & ia->ia_netmask) == ia->ia_net)
			return (1);
	}
	return (0);
}
@


1.94
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.93 2014/03/21 10:32:17 mpi Exp $	*/
d331 3
a333 4
			ia->ia_ifa.ifa_dstaddr = sintosa(&oldaddr);
			rtinit(&ia->ia_ifa, RTM_DELETE, RTF_UP | RTF_HOST);
			ia->ia_ifa.ifa_dstaddr = sintosa(&ia->ia_dstaddr);
			rtinit(&ia->ia_ifa, RTM_ADD, RTF_UP | RTF_HOST);
d775 2
a776 1
	error = rtinit(&ia0->ia_ifa, RTM_ADD, RTF_UP | RTF_HOST);
d810 1
a810 1
		rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_UP | RTF_HOST);
d812 2
a813 1
		error = rtinit(&ia->ia_ifa, RTM_ADD, RTF_UP | RTF_HOST);
d820 1
a820 1
	rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_UP | RTF_HOST);
d862 1
a862 1
			rtinit(&ia->ia_ifa, RTM_DELETE, RTF_UP | RTF_CLONING);
d877 2
a878 1
	error = rtinit(&ia0->ia_ifa, RTM_ADD, RTF_UP | RTF_CLONING);
d923 1
a923 1
		rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_UP | RTF_CLONING);
d925 2
a926 1
		error = rtinit(&ia->ia_ifa, RTM_ADD, RTF_UP | RTF_CLONING);
d935 1
a935 1
	rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_UP | RTF_CLONING);
@


1.93
log
@Split the magic to add a connected route for every new IPv4 address
added to an interface into two functions: one for route to prefix
and one for route to host.

This magic has been added to work around the behavior of rtinit() and
preserve the connected route to prefix when the first address of a
subnet is removed.  Since this "feature" has been present for point-
to-point interfaces too for more than 10 years, this diff does not
change anything in this regard, even if I'm not sure it makes sense.

Tested by benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.92 2014/03/14 12:08:18 krw Exp $	*/
d332 1
a332 1
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
d334 1
a334 1
			rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_HOST|RTF_UP);
d810 1
a810 1
		rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_HOST);
d819 1
a819 1
	rtinit(&ia0->ia_ifa, RTM_DELETE, RTF_HOST);
d861 1
a861 1
			rtinit(&ia->ia_ifa, RTM_DELETE, 0);
d876 1
a876 1
	error = rtinit(&ia0->ia_ifa, RTM_ADD, RTF_UP);
d921 1
a921 1
		rtinit(&ia0->ia_ifa, RTM_DELETE, 0);
d923 1
a923 1
		error = rtinit(&ia->ia_ifa, RTM_ADD, RTF_UP);
d932 1
a932 1
	rtinit(&ia0->ia_ifa, RTM_DELETE, 0);
@


1.92
log
@Add missing parens so 'if' statement controls both of the statements
it was intended to control. No real-world change say mikeb@@ and mpi@@.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.91 2014/01/21 10:18:26 mpi Exp $	*/
d97 1
a97 1
int in_addprefix(struct in_ifaddr *, int);
d99 2
d614 4
a617 1
	in_scrubprefix(ia);
d630 1
a630 1
	int s = splnet(), flags = RTF_UP, error = 0;
a689 1
		flags |= RTF_HOST;
a692 1
		flags |= RTF_HOST;
d694 5
a698 1
	error = in_addprefix(ia, flags);
d750 74
a823 3
#define rtinitflags(x) \
	((((x)->ia_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) != 0) \
	    ? RTF_HOST : 0)
d830 1
a830 1
in_addprefix(struct in_ifaddr *target, int flags)
d833 1
a833 1
	struct in_addr prefix, mask, p;
d836 3
a838 7
	if ((flags & RTF_HOST) != 0)
		prefix = target->ia_dstaddr.sin_addr;
	else {
		prefix = target->ia_addr.sin_addr;
		mask = target->ia_sockmask.sin_addr;
		prefix.s_addr &= mask.s_addr;
	}
d841 1
a841 1
		if (ia->ia_ifp->if_rdomain != target->ia_ifp->if_rdomain)
d843 4
a846 11
		if (rtinitflags(ia)) {
			p = ia->ia_dstaddr.sin_addr;
			if (prefix.s_addr != p.s_addr)
				continue;
		} else {
			p = ia->ia_addr.sin_addr;
			p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
			if (prefix.s_addr != p.s_addr ||
			    mask.s_addr != ia->ia_sockmask.sin_addr.s_addr)
				continue;
		}
d849 8
d860 2
a861 3
		    target->ia_ifp->if_type != IFT_CARP) {
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE,
			    rtinitflags(ia));
d876 1
a876 1
	error = rtinit(&target->ia_ifa, (int)RTM_ADD, flags);
d878 1
a878 1
		target->ia_flags |= IFA_ROUTE;
d888 1
a888 1
in_scrubprefix(struct in_ifaddr *target)
d894 1
a894 1
	if ((target->ia_flags & IFA_ROUTE) == 0)
d897 3
a899 8
	if (rtinitflags(target)) {
		prefix = target->ia_dstaddr.sin_addr;
		mask.s_addr = INADDR_BROADCAST;
	} else {
		prefix = target->ia_addr.sin_addr;
		mask = target->ia_sockmask.sin_addr;
		prefix.s_addr &= mask.s_addr;
	}
d902 2
a903 8
		if (rtinitflags(ia)) {
			p = ia->ia_dstaddr.sin_addr;
			m.s_addr = INADDR_BROADCAST;
		} else {
			p = ia->ia_addr.sin_addr;
			m = ia->ia_sockmask.sin_addr;
			p.s_addr &= m.s_addr;
		}
d905 1
a905 1
		if (ia->ia_ifp->if_rdomain != target->ia_ifp->if_rdomain)
d907 2
a908 2
		if (prefix.s_addr != p.s_addr ||
		    mask.s_addr != m.s_addr)
d910 8
d921 6
a926 11
		if ((ia->ia_flags & IFA_ROUTE) == 0) {
			rtinit(&(target->ia_ifa), (int)RTM_DELETE,
			    rtinitflags(target));
			target->ia_flags &= ~IFA_ROUTE;

			error = rtinit(&ia->ia_ifa, (int)RTM_ADD,
			    rtinitflags(ia) | RTF_UP);
			if (error == 0)
				ia->ia_flags |= IFA_ROUTE;
			return error;
		}
d932 2
a933 2
	rtinit(&(target->ia_ifa), (int)RTM_DELETE, rtinitflags(target));
	target->ia_flags &= ~IFA_ROUTE;
a935 2

#undef rtinitflags
@


1.91
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.90 2013/12/31 03:24:44 tedu Exp $	*/
d232 1
a232 1
		if (ifra->ifra_addr.sin_family == AF_INET)
d240 1
@


1.90
log
@bcopy -> memcpy. reviewed with one fix from matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.89 2013/11/28 10:16:44 mpi Exp $	*/
d952 1
a952 1
		inm->inm_ifp = ifp;
d995 1
a995 1
		ifp = inm->inm_ifp;
d1001 12
a1012 8
		satosin(&ifr.ifr_addr)->sin_len = sizeof(struct sockaddr_in);
		satosin(&ifr.ifr_addr)->sin_family = AF_INET;
		satosin(&ifr.ifr_addr)->sin_addr = inm->inm_addr;
		(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);

		s = splsoftnet();
		TAILQ_REMOVE(&ifp->if_maddrlist, &inm->inm_ifma, ifma_list);
		splx(s);
a1023 1
	struct ifmaddr *ifma, *mnext;
a1029 8
	}

	TAILQ_FOREACH_SAFE(ifma, &ifp->if_maddrlist, ifma_list, mnext) {
		if (ifma->ifma_addr->sa_family != AF_INET)
			continue;

		ifma->ifma_refcnt = 1;
		in_delmulti(ifmatoinm(ifma));
@


1.89
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.88 2013/10/23 13:39:35 mpi Exp $	*/
d497 2
a498 2
		bcopy(iflr->iflr_name, ifra.ifra_name,
			sizeof(ifra.ifra_name));
d500 2
a501 2
		bcopy(&iflr->addr, &ifra.ifra_addr,
			((struct sockaddr *)&iflr->addr)->sa_len);
d504 2
a505 2
			bcopy(&iflr->dstaddr, &ifra.ifra_dstaddr,
				((struct sockaddr *)&iflr->dstaddr)->sa_len);
d566 1
a566 1
			bcopy(&ia->ia_addr, &iflr->addr, ia->ia_addr.sin_len);
d569 2
a570 2
				bcopy(&ia->ia_dstaddr, &iflr->dstaddr,
					ia->ia_dstaddr.sin_len);
d585 2
a586 2
			bcopy(iflr->iflr_name, ifra.ifra_name,
				sizeof(ifra.ifra_name));
d588 2
a589 2
			bcopy(&ia->ia_addr, &ifra.ifra_addr,
				ia->ia_addr.sin_len);
d591 2
a592 2
				bcopy(&ia->ia_dstaddr, &ifra.ifra_dstaddr,
					ia->ia_dstaddr.sin_len);
d594 2
a595 2
			bcopy(&ia->ia_sockmask, &ifra.ifra_dstaddr,
				ia->ia_sockmask.sin_len);
@


1.88
log
@No need to expose twice in_socktrim(), it is only used in one file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.87 2013/10/18 09:04:02 mpi Exp $	*/
d71 1
a261 1
			LIST_INIT(&ia->ia_multiaddrs);
d925 1
a925 2
	struct in_ifaddr *ia;
	int s = splsoftnet();
d935 1
a935 1
		++inm->inm_refcount;
d937 3
d944 2
a945 4
		inm = (struct in_multi *)malloc(sizeof(*inm),
		    M_IPMADDR, M_NOWAIT);
		if (inm == NULL) {
			splx(s);
d947 8
a954 12
		}
		inm->inm_addr = *ap;
		inm->inm_refcount = 1;
		IFP_TO_IA(ifp, ia);
		if (ia == NULL) {
			free(inm, M_IPMADDR);
			splx(s);
			return (NULL);
		}
		inm->inm_ia = ia;
		ia->ia_ifa.ifa_refcnt++;
		LIST_INSERT_HEAD(&ia->ia_multiaddrs, inm, inm_list);
d959 2
a960 7
		satosin(&ifr.ifr_addr)->sin_len = sizeof(struct sockaddr_in);
		satosin(&ifr.ifr_addr)->sin_family = AF_INET;
		satosin(&ifr.ifr_addr)->sin_addr = *ap;
		if ((ifp->if_ioctl == NULL) ||
		    (*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0) {
			LIST_REMOVE(inm, inm_list);
			ifafree(&inm->inm_ia->ia_ifa);
a961 1
			splx(s);
d964 6
d975 1
a975 1
	splx(s);
d987 1
a987 1
	int s = splsoftnet();
d989 1
a989 1
	if (--inm->inm_refcount == 0) {
d995 2
d998 2
a999 1
		 * Unlink from list.
d1001 8
a1008 3
		LIST_REMOVE(inm, inm_list);
		ifp = inm->inm_ifp;
		ifafree(&inm->inm_ia->ia_ifa);
a1009 9
		if (ifp) {
			/*
			 * Notify the network driver to update its multicast
			 * reception filter.
			 */
			satosin(&ifr.ifr_addr)->sin_family = AF_INET;
			satosin(&ifr.ifr_addr)->sin_addr = inm->inm_addr;
			(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);
		}
a1011 1
	splx(s);
d1020 1
d1027 8
@


1.87
log
@Abstract the fact that IPv4 muticast records are linked to the
interface descriptor throught the first configured address in the
global list, this will help reducing the size of future diffs.

No object change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.86 2013/10/09 09:33:43 mpi Exp $	*/
d90 1
@


1.86
log
@Introduce in_ifdetach() a function to remove all the IPv4 addresses
of an interface, named after its IPv6 equivalent.

Make use of it instead of removing addresses by hand when detaching
or destroying an interface.  As a bonus, multicast records linked
to the just divorced^Wdetached interface are no longer leaked.

No objection from the gang, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.85 2013/09/26 08:53:17 mpi Exp $	*/
d1002 1
a1002 1
		ifp = inm->inm_ia->ia_ifp;
@


1.85
log
@Move the logic for deleting an IPv4 address to its own function.
No functional change.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.84 2013/08/28 07:30:55 mpi Exp $	*/
d1020 13
@


1.84
log
@If have an interface pointer, look for an address on its list rather
than iterating on the global list.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.83 2013/08/19 08:45:34 mpi Exp $	*/
d94 1
a346 4
		else if (newifaddr) {
			splx(s);
			goto cleanup;
		}
d348 1
a348 1
		return error;
a392 4
		else if (newifaddr) {
			splx(s);
			goto cleanup;
		}
d396 1
a396 4
	case SIOCDIFADDR: {

		error = 0;
cleanup:
d404 2
a405 12
		in_ifscrub(ifp, ia);
		ifa_del(ifp, &ia->ia_ifa);
		TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
		if (ia->ia_allhosts != NULL) {
			in_delmulti(ia->ia_allhosts);
			ia->ia_allhosts = NULL;
		}
		/* remove backpointer, since ifp may die before ia */
		ia->ia_ifp = NULL;
		ifafree((&ia->ia_ifa));
		if (!error)
			dohooks(ifp->if_addrhooks, 0);
d407 1
a407 2
		return (error);
		}
d714 3
d718 21
@


1.83
log
@In case something bad happened when configuring an IPv4 address, make
sure we add its descriptor back to the tree and interface list to keep
the various global structures consistent.

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.82 2013/08/08 07:39:13 mpi Exp $	*/
d195 1
d219 3
a221 2
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
			if (ia->ia_ifp == ifp)
d223 1
d230 5
a234 5
			for (; ia != NULL; ia = TAILQ_NEXT(ia, ia_list)) {
				if (ia->ia_ifp == ifp &&
				    ia->ia_addr.sin_addr.s_addr ==
					ifra->ifra_addr.sin_addr.s_addr)
				    break;
d236 1
d278 5
a282 7
			struct in_ifaddr *ia2;

			for (ia2 = ia; ia2 != NULL;
			    ia2 = TAILQ_NEXT(ia2, ia_list)) {
				if (ia2->ia_ifp == ifp &&
				    ia2->ia_addr.sin_addr.s_addr ==
				    satosin(&ifr->ifr_addr)->sin_addr.s_addr)
d284 1
a285 2
			if (ia2 && ia2->ia_ifp == ifp)
				ia = ia2;
@


1.82
log
@Insert new IPv4 addresses in only one place, no functional change.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.81 2013/06/23 16:30:46 sthen Exp $	*/
d414 1
a414 2
		if (!error)
			ifa_del(ifp, &ia->ia_ifa);
d643 1
a643 1
	int s = splnet(), flags = RTF_UP, error;
d666 1
a666 1
		return (error);
d705 2
a706 4
		if (ia->ia_dstaddr.sin_family != AF_INET) {
			ifa_add(ifp, &ia->ia_ifa);
			return (0);
		}
d722 11
a732 2
	if (!error)
		ifa_add(ifp, &ia->ia_ifa);
@


1.81
log
@Revert r1.78 for now, it breaks ipv4 on carp. As found the hard way by
Jeff Ross and later by myself, both on remote systems..
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.77 2013/05/31 19:16:52 mpi Exp $	*/
a243 2
			s = splsoftnet();
			TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);
a255 1
			splx(s);
d646 7
@


1.80
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.79 2013/06/20 09:38:24 mpi Exp $	*/
d245 1
d417 1
a417 1
		if (!error) {
d419 1
a419 2
			TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
		}
d649 1
a649 1
	if (!newaddr) {
a650 2
		TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
	}
d703 2
a704 2
			error = 0;
			goto done;
d721 1
a721 3
done:
	if (!error) {
		TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);
a722 1
	}
@


1.79
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.78 2013/06/17 11:58:16 mpi Exp $	*/
d346 1
a346 1
			dohooks(&ifp->if_addrhooks, 0);
d396 1
a396 1
			dohooks(&ifp->if_addrhooks, 0);
d428 1
a428 1
			dohooks(&ifp->if_addrhooks, 0);
@


1.78
log
@Always add/remove IPv4 addresses consistently from the global list and tree.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.77 2013/05/31 19:16:52 mpi Exp $	*/
d346 1
a346 1
			dohooks(ifp->if_addrhooks, 0);
d396 1
a396 1
			dohooks(ifp->if_addrhooks, 0);
d428 1
a428 1
			dohooks(ifp->if_addrhooks, 0);
@


1.77
log
@Remove the scrub argument from in_ifinit() and simply call in_ifscrub()
unconditionally for SIOCSIFADDR.

ok bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.76 2013/05/13 10:17:13 mpi Exp $	*/
a244 1
			TAILQ_INSERT_TAIL(&in_ifaddr, ia, ia_list);
d416 1
a416 1
		if (!error)
d418 2
a419 1
		TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
d649 1
a649 1
	if (!newaddr)
d651 2
d705 2
a706 2
			ifa_add(ifp, &ia->ia_ifa);
			return (0);
d723 3
a725 1
	if (!error)
d727 1
@


1.76
log
@Make SIOCSIFDSTMASK and SIOCSIFNETMASK fail if there is no previous
address configured on the interface just like SIOCSIFBRDADDR does.

This prevent the global IPv4 address list and the per-interface list
to be out of sync until one of SIOCAIFADDR or SIOCSIFADDR ioctl(2)
is issued.

ok mikeb@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.75 2013/04/17 08:25:37 mpi Exp $	*/
d344 2
a345 2
		error = in_ifinit(ifp, ia, satosin(&ifr->ifr_addr), 1,
		    newifaddr);
d394 1
a394 2
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, 0,
			    newifaddr);
d643 1
a643 1
    int scrub, int newaddr)
a673 6

	if (scrub) {
		ia->ia_ifa.ifa_addr = sintosa(&oldaddr);
		in_ifscrub(ifp, ia);
		ia->ia_ifa.ifa_addr = sintosa(&ia->ia_addr);
	}
@


1.75
log
@Simplify the check to call in_ifinit() by merging two conditional
viariables.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.74 2013/03/22 01:41:12 tedu Exp $	*/
a236 2
	case SIOCSIFNETMASK:
	case SIOCSIFDSTADDR:
d265 2
@


1.74
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.73 2013/03/07 09:03:16 mpi Exp $	*/
d198 1
a198 1
	int error, hostIsNew, maskIsNew;
d360 3
a362 3
	case SIOCAIFADDR:
		maskIsNew = 0;
		hostIsNew = 1;
d364 1
d367 1
a367 1
			if (ifra->ifra_addr.sin_len == 0) {
d369 3
a371 4
				hostIsNew = 0;
			} else if (ifra->ifra_addr.sin_addr.s_addr ==
			    ia->ia_addr.sin_addr.s_addr && !newifaddr)
				hostIsNew = 0;
d377 1
a377 1
			maskIsNew = 1;
d383 1
a383 1
			maskIsNew  = 1; /* We lie; but the effect's the same */
d393 1
a393 2
		if (ifra->ifra_addr.sin_family == AF_INET &&
		    (hostIsNew || maskIsNew)) {
d405 1
a405 1

@


1.73
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.72 2012/07/10 08:31:51 claudio Exp $	*/
d227 1
a227 2
			for (; ia != TAILQ_END(&in_ifaddr);
			    ia = TAILQ_NEXT(ia, ia_list)) {
d279 1
a279 1
			for (ia2 = ia; ia2 != TAILQ_END(&in_ifaddr);
@


1.72
log
@in_scrubprefix needs the same netmask checking as in_addprefix (which was
added in 1.40). This fixes a pathological case where in_scrubprefix would
do the wrong thing. Found and reported by glebius@@FreeBSD
OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.71 2012/07/08 16:36:58 bluhm Exp $	*/
d429 1
a429 1
		IFAFREE((&ia->ia_ifa));
d963 1
a963 1
			IFAFREE(&inm->inm_ia->ia_ifa);
d998 1
a998 1
		IFAFREE(&inm->inm_ia->ia_ifa);
@


1.71
log
@Instead of casting interface address pointers, use the macros NULL
and ifatoia().  No binary diff.
OK blambert@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.70 2012/01/03 23:41:51 bluhm Exp $	*/
d810 1
a810 1
	struct in_addr prefix, mask, p;
d816 1
a816 1
	if (rtinitflags(target))
d818 2
a819 1
	else {
d826 1
a826 1
		if (rtinitflags(ia))
d828 2
a829 1
		else {
d831 2
a832 1
			p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
d837 2
a838 1
		if (prefix.s_addr != p.s_addr)
a839 1

@


1.70
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.69 2011/10/13 18:23:40 claudio Exp $	*/
d195 1
a195 1
	struct in_ifaddr *ia = 0;
d234 1
a234 1
		if (cmd == SIOCDIFADDR && ia == 0)
d245 1
a245 1
		if (ia == (struct in_ifaddr *)0) {
d290 1
a290 1
		if (ia == (struct in_ifaddr *)0)
d588 1
a588 1
		ia = (struct in_ifaddr *)ifa;
@


1.69
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.68 2011/07/06 01:57:37 dlg Exp $	*/
d340 1
a340 2
		ifa_update_broadaddr(ifp, (struct ifaddr *)ia,
		    &ifr->ifr_broadaddr);
d391 1
a391 1
				ifa_update_broadaddr(ifp, (struct ifaddr *)ia,
d421 1
a421 1
			ifa_del(ifp, (struct ifaddr *)ia);
d653 1
a653 1
		ifa_del(ifp, (struct ifaddr *)ia);
d712 1
a712 1
			ifa_add(ifp, (struct ifaddr *)ia);
d731 1
a731 1
		ifa_add(ifp, (struct ifaddr *)ia);
@


1.68
log
@allow /31s on broadcast interfaces (eg ethernet) to work as per rfc3021.
the issue in our kernel was the broadcast address calculated on the /31
caused a ton of checks for use of broadcast addresses to kick in and
prevent one of the two addresses on the /31 from being used.

this diff basically detects if a /31 has been configured and doesnt
configure a broadcast address for it, which makes the ips usable
for normal traffic.

i wrote this so i could interoperate with "carrier" network gear
better, and sthen wants it so he can conserve address space use.

the further special casing of broadcast address handling was from claudio@@

ok claudio@@ markus@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.67 2011/07/03 06:24:13 dlg Exp $	*/
a89 1
int in_mask2len(struct in_addr *);
@


1.67
log
@slight knf (particularly the function decls) so i dont get too distracted
while reading.

ok henning@@ jsing@@ tedu@@ marco@@ bluhm@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.66 2011/07/02 04:37:04 dlg Exp $	*/
d703 6
a708 2
		ia->ia_broadaddr.sin_addr.s_addr =
			ia->ia_net | ~ia->ia_netmask;
@


1.66
log
@gc in_interfaces. doesnt seem to do anything except get incremented.

ok henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.65 2011/04/28 09:56:27 claudio Exp $	*/
d120 1
a120 2
in_canforward(in)
	struct in_addr in;
d128 2
a129 1
		if (net == 0 || net == htonl(IN_LOOPBACKNET << IN_CLASSA_NSHIFT))
d139 1
a139 2
in_socktrim(ap)
	struct sockaddr_in *ap;
d153 1
a153 2
in_mask2len(mask)
	struct in_addr *mask;
d174 1
a174 3
in_len2mask(mask, len)
	struct in_addr *mask;
	int len;
d193 1
a193 5
in_control(so, cmd, data, ifp)
	struct socket *so;
	u_long cmd;
	caddr_t data;
	struct ifnet *ifp;
d469 2
a470 5
in_lifaddr_ioctl(so, cmd, data, ifp)
	struct socket *so;
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
d637 1
a637 3
in_ifscrub(ifp, ia)
	struct ifnet *ifp;
	struct in_ifaddr *ia;
d647 2
a648 6
in_ifinit(ifp, ia, sin, scrub, newaddr)
	struct ifnet *ifp;
	struct in_ifaddr *ia;
	struct sockaddr_in *sin;
	int scrub;
	int newaddr;
d743 1
a743 3
in_addprefix(target, flags)
	struct in_ifaddr *target;
	int flags;
d805 1
a805 2
in_scrubprefix(target)
	struct in_ifaddr *target;
d910 1
a910 3
in_addmulti(ap, ifp)
	struct in_addr *ap;
	struct ifnet *ifp;
d976 1
a976 2
in_delmulti(inm)
	struct in_multi *inm;
@


1.65
log
@Make in_broadcast() rdomain aware. Mostly mechanical change.
This fixes the problem of binding sockets to broadcast IPs in other
rdomains.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.64 2010/11/28 20:24:33 claudio Exp $	*/
a190 2
int	in_interfaces;		/* number of external internet interfaces */

a269 2
			if ((ifp->if_flags & IFF_LOOPBACK) == 0)
				in_interfaces++;
@


1.64
log
@Only call ifa_del() when no error happend previously. Do the same thing
for dohooks() since it makes no sense to call the if_addrhooks when the
address assignment failed. Additionally only call ifa_add() in
in_ifinit() when no error happend. Fixes a carp(4) panic seen by dhill
and dlg.  OK henning@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.63 2010/11/17 19:25:49 henning Exp $	*/
d889 1
a889 3
in_broadcast(in, ifp)
	struct in_addr in;
	struct ifnet *ifp;
d893 3
d916 2
@


1.63
log
@an extra parameter for in_ifinit, indicating wether the ifaddr passed to it
is new or an already existing one. for existing ones, call ifa_del first
tested by many as part of a larger diff, ok claudio dlg krw sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.62 2010/11/17 19:21:28 henning Exp $	*/
d434 2
a435 1
		ifa_del(ifp, (struct ifaddr *)ia);
d444 2
a445 1
		dohooks(ifp->if_addrhooks, 0);
d730 2
a731 1
		if (ia->ia_dstaddr.sin_family != AF_INET)
d733 1
d749 2
a750 1
	ifa_add(ifp, (struct ifaddr *)ia);
@


1.62
log
@use ifa_update_broadaddr and make sure bcast address is set before calling
in_ifinit
tested by many as part of a larger diff, ok claudio dlg krw sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.61 2010/11/17 18:48:26 henning Exp $	*/
d359 2
a360 1
		error = in_ifinit(ifp, ia, satosin(&ifr->ifr_addr), 1);
d385 1
a385 1
					       ia->ia_addr.sin_addr.s_addr)
d410 2
a411 1
			error = in_ifinit(ifp, ia, &ifra->ifra_addr, 0);
d662 1
a662 1
in_ifinit(ifp, ia, sin, scrub)
d667 1
d673 2
d677 1
d733 1
@


1.61
log
@move the ifa_add call to in_ifinit() so it is called AFTER the ifaddr
structure is fully set up
tested by many as part of a larger diff, ok claudio dlg sthen krw
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.60 2010/01/13 10:45:21 henning Exp $	*/
d353 2
a354 1
		ia->ia_broadaddr = *satosin(&ifr->ifr_broadaddr);
d399 8
a410 3
		if ((ifp->if_flags & IFF_BROADCAST) &&
		    (ifra->ifra_broadaddr.sin_family == AF_INET))
			ia->ia_broadaddr = ifra->ifra_broadaddr;
@


1.60
log
@remove subnetsarelocal / SUBNETSARELOCAL. it's been off by default since
1996 with no way to enable but kernel config or code mods and is bound to
classful adressing anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.59 2010/01/13 10:30:31 henning Exp $	*/
a273 1
			ifa_add(ifp, (struct ifaddr *)ia);
d731 3
@


1.59
log
@4.2BSD had the host parts bit of the address all zero as broadcast address.
4.3BSD (anno 1986) supported the host part bits all one for broadcast as
well, since that's what everybody agreed on and RFC919 (anno 1984) proposed.
now, roughly a quarter decade later, we can really stop supporting the all
zero variant. sorry to you guys still running 4.2BSD. ok theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.58 2010/01/13 07:05:28 henning Exp $	*/
d98 1
a98 12
#ifndef SUBNETSARELOCAL
#define	SUBNETSARELOCAL	0
#endif

int subnetsarelocal = SUBNETSARELOCAL;

/*
 * Return 1 if an internet address is for a ``local'' host
 * (one to which we have a connection).  If subnetsarelocal
 * is true, this includes other subnets of the local net.
 * Otherwise, it includes only the directly-connected (sub)nets.
 */
d105 5
a109 14
	if (subnetsarelocal) {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp->if_rdomain != rdomain)
				continue;
			if ((in.s_addr & ia->ia_netmask) == ia->ia_net)
				return (1);
		}
	} else {
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list) {
			if (ia->ia_ifp->if_rdomain != rdomain)
				continue;
			if ((in.s_addr & ia->ia_netmask) == ia->ia_net)
				return (1);
		}
@


1.58
log
@we don't need broadcast for the classful network AND broadcast for the
subnet of the classful network. at least, not since 1992.
ok mpf dlg bob
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.57 2010/01/13 02:13:12 henning Exp $	*/
a101 4
#ifndef HOSTZEROBROADCAST
#define HOSTZEROBROADCAST 1
#endif

a102 1
int hostzeroisbroadcast = HOSTZEROBROADCAST;
d920 1
a920 6
			    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			     (hostzeroisbroadcast &&
			      /*
			       * Check for old-style (host 0) broadcast.
			       */
			      in.s_addr == ia->ia_net)))
@


1.57
log
@instead of fiddling with the per-interface address lists directly in
many places create a proper API (ifa_add / ifa_del) and use it.
ok theo ryan dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.56 2010/01/13 01:26:28 henning Exp $	*/
a737 2
		ia->ia_netbroadcast.s_addr =
			ia->ia_net | ~ia->ia_netmask;
a925 1
			     in.s_addr == ia->ia_netbroadcast.s_addr ||
@


1.56
log
@let's admit it's not 1992 any more. CIDR is around for a long time, even
that router vendor doesn't default to classful routing any more, and there
really is no point in having a classful netmask and a subnetmask to split
it. we still do classful guesses on the netmask if it isn't supplied by
userland, but that's about it.
i decided to keep ia_netmask and kill ia_subnetmask which makes this diff
bigish, the classful ia_netmask wasn't really used all that much. the real
changes are in in.c, the rest is mostly s/ia_subnetmask/ia_netmask.
ok claudio dlg ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.55 2009/11/03 10:59:04 claudio Exp $	*/
a284 2
			TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia,
			    ifa_list);
d299 1
d452 1
a452 1
		TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
@


1.55
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.54 2009/06/05 00:05:22 claudio Exp $	*/
d132 1
a132 1
			if ((in.s_addr & ia->ia_subnetmask) == ia->ia_subnet)
d396 1
a396 1
		ia->ia_subnetmask = ia->ia_sockmask.sin_addr.s_addr =
d416 1
a416 1
			ia->ia_subnetmask = ia->ia_sockmask.sin_addr.s_addr;
d719 11
a729 16
	if (IN_CLASSA(i))
		ia->ia_netmask = IN_CLASSA_NET;
	else if (IN_CLASSB(i))
		ia->ia_netmask = IN_CLASSB_NET;
	else
		ia->ia_netmask = IN_CLASSC_NET;
	/*
	 * The subnet mask usually includes at least the standard network part,
	 * but may may be smaller in the case of supernetting.
	 * If it is set, we believe it.
	 */
	if (ia->ia_subnetmask == 0) {
		ia->ia_subnetmask = ia->ia_netmask;
		ia->ia_sockmask.sin_addr.s_addr = ia->ia_subnetmask;
	} else
		ia->ia_netmask &= ia->ia_subnetmask;
a730 1
	ia->ia_subnet = i & ia->ia_subnetmask;
d738 1
a738 1
			ia->ia_subnet | ~ia->ia_subnetmask;
d934 1
a934 2
			      (in.s_addr == ia->ia_subnet ||
			       in.s_addr == ia->ia_net))))
@


1.54
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.53 2009/03/15 19:40:41 miod Exp $	*/
d120 1
@


1.53
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.52 2008/06/04 18:11:35 miod Exp $	*/
d116 1
a116 2
in_localaddr(in)
	struct in_addr in;
d121 3
a123 1
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
d126 1
d128 3
a130 1
		TAILQ_FOREACH(ia, &in_ifaddr, ia_list)
d133 1
d794 2
d867 2
@


1.52
log
@adderss -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.51 2007/10/01 16:39:30 krw Exp $	*/
d706 1
a706 1
	splassert(IPL_SOFTNET);
@


1.51
log
@Last of the really easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'
where obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.50 2007/09/17 09:33:57 markus Exp $	*/
d814 1
a814 1
		 * interface adderss, we don't need to bother
@


1.50
log
@remove backpointer from ifa to ifp if an address gets delete; fixes
panics in ip_freemoptions(); ok claudio, henning, mpf
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.49 2007/07/20 19:00:35 claudio Exp $	*/
d276 1
a276 3
			ia = (struct in_ifaddr *)
				malloc(sizeof *ia, M_IFADDR, M_WAITOK);
			bzero((caddr_t)ia, sizeof *ia);
@


1.49
log
@Remove inm_ifp from struct in_multi -- caching struct ifnet is dangerous
because interfaces may disappear without notice causing use after free bugs.
Instead use the inm_ia->ia_ifp as a hint, struct in_ifaddr correctly tracks
removals of interfaces and invalidates ia_ifp in such cases.
looks good henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.48 2007/07/04 12:15:53 claudio Exp $	*/
d455 2
@


1.48
log
@Fix a use after free crash in in_delmulti(). If a interface is detached
before it is removed from the multicast group in_delmulti() will try to
access the no longer available ifp.
We invalidate the ifa_ifp back pointer in the ifa in if_detach() now and use
the ifa_ifp in in_delmulti() instead of the internal inm_ifp. By doing it
this way we know if the interface was removed.
This fixes a kernel panic triggered by ospfd and gif(4) tunnels.
looks good henning@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.47 2007/05/27 20:04:25 dlg Exp $	*/
a971 1
		inm->inm_ifp = ifp;
@


1.47
log
@thou shalt not use static in the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.46 2007/02/14 00:53:48 jsg Exp $	*/
d1015 1
d1028 1
d1030 10
a1039 8
		/*
		 * Notify the network driver to update its multicast reception
		 * filter.
		 */
		satosin(&ifr.ifr_addr)->sin_family = AF_INET;
		satosin(&ifr.ifr_addr)->sin_addr = inm->inm_addr;
		(*inm->inm_ifp->if_ioctl)(inm->inm_ifp, SIOCDELMULTI,
							     (caddr_t)&ifr);
@


1.46
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.45 2007/01/02 11:41:28 markus Exp $	*/
d90 3
a92 3
static int in_mask2len(struct in_addr *);
static void in_len2mask(struct in_addr *, int);
static int in_lifaddr_ioctl(struct socket *, u_long, caddr_t,
d95 2
a96 2
static int in_addprefix(struct in_ifaddr *, int);
static int in_scrubprefix(struct in_ifaddr *);
d172 1
a172 1
static int
d194 1
a194 1
static void
d491 1
a491 1
static int
d771 1
a771 1
static int
d833 1
a833 1
static int
@


1.45
log
@move local network route to real interface instead of carp interface; from mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.44 2006/03/05 21:48:56 miod Exp $	*/
d237 1
a237 1
		/*fall through*/
@


1.44
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.43 2006/03/04 22:40:16 brad Exp $	*/
d73 5
a666 1

d800 12
a811 1

d816 1
a816 2
		if (ia->ia_flags & IFA_ROUTE)
			return 0;
@


1.43
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.42 2006/02/21 15:33:59 claudio Exp $	*/
d117 1
a117 1
		for (ia = in_ifaddr.tqh_first; ia != 0; ia = ia->ia_list.tqe_next)
d121 1
a121 1
		for (ia = in_ifaddr.tqh_first; ia != 0; ia = ia->ia_list.tqe_next)
d243 1
a243 1
		for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next)
d252 7
a258 6
		    for (; ia != 0; ia = ia->ia_list.tqe_next) {
			if (ia->ia_ifp == ifp &&
			    ia->ia_addr.sin_addr.s_addr ==
				ifra->ifra_addr.sin_addr.s_addr)
			    break;
		}
d311 2
a312 1
			for (ia2 = ia; ia2; ia2 = ia2->ia_list.tqe_next) {
d599 1
a599 1
		for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next) {
d838 1
a838 1
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
d891 1
a891 1
	  	if_first = ifnet.tqh_first;
d895 1
a895 1
		if_target = ifp->if_list.tqe_next;
d904 1
a904 1
        for (ifn = if_first; ifn != if_target; ifn = ifn->if_list.tqe_next) {
d907 1
a907 2
		for (ifa = ifn->if_addrlist.tqh_first; ifa;
		    ifa = ifa->ifa_list.tqe_next)
@


1.42
log
@Fix a panic reported by D.Snezhkov by issuing an ifconfig command with
-alias and netmask used at the same time. This resulted in a corrupted
routing table and a panic in rn_walktree after the interface was destroyed.
OK krw@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.41 2005/06/03 08:14:01 pascoe Exp $	*/
d677 1
a677 1
	int s = splimp(), flags = RTF_UP, error;
@


1.41
log
@Hold a reference to the relevant struct in_ifaddr while a multicast address
is bound on the interface.

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.40 2005/03/07 10:40:42 claudio Exp $	*/
d278 1
@


1.40
log
@Correctly compare routes in in_addprefix. If a netmask is supplied it needs
to be compared too -- 10/8 and 10/24 are not equal. This fixes a problem
with overlapping networks reported by Simon Slaytor.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.39 2005/01/15 09:09:27 pascoe Exp $	*/
d965 1
d977 1
d1011 1
@


1.40.2.1
log
@MFC:
Fix by pascoe@@

Hold a reference to the relevant struct in_ifaddr while a multicast address
is bound on the interface.

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.40 2005/03/07 10:40:42 claudio Exp $	*/
a964 1
		ia->ia_ifa.ifa_refcnt++;
a975 1
			IFAFREE(&inm->inm_ia->ia_ifa);
a1008 1
		IFAFREE(&inm->inm_ia->ia_ifa);
@


1.39
log
@From NetBSD:
- Keep track of allhost multicast address record we joined into
  each in_ifaddr and delete it when an address is purged.
- Don't simply try to delete a multicast address record listed in the
  ia_multiaddrs.  It results a dangling pointer.  Let whoever holds a
  reference to it to delete it.

mcbride@@ markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.38 2004/11/18 23:14:49 dhartmei Exp $	*/
d781 2
a782 2
	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		if (rtinitflags(ia))
d784 3
a786 1
		else {
d789 3
a792 3

		if (prefix.s_addr != p.s_addr)
			continue;
@


1.38
log
@for loopback, set ia_dstaddr instead of ia_ifa.ifa_dstaddr in in_ifinit()
found by Ruslan Ermilov, ok markus@@
http://marc.theaimsgroup.com/?l=freebsd-net&m=110072900204253
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.37 2004/08/24 20:31:16 brad Exp $	*/
a429 1
		struct in_multi *inm;
d443 4
a446 2
		while ((inm = LIST_FIRST(&ia->ia_multiaddrs)) != NULL)
			in_delmulti(inm);
d747 1
a747 1
	if (ifp->if_flags & IFF_MULTICAST) {
d751 1
a751 1
		in_addmulti(&addr, ifp);
@


1.37
log
@Don't allow SIOCGET{VIF,SG}CNT from sockets other than the multicast router.

From NetBSD
Fixes PR 3825

ok mcbride@@ canacar@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.36 2004/06/21 23:48:09 mcbride Exp $	*/
d734 1
a734 1
		ia->ia_ifa.ifa_dstaddr = ia->ia_ifa.ifa_addr;
@


1.36
log
@When in_ifinit fails and we've created a new address, clean it up before
returning.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.35 2004/05/31 10:48:48 mpf Exp $	*/
d455 1
a455 1
		return (mrt_ioctl(cmd, data));
@


1.35
log
@clean some copy&paste leftovers from KAME code.
ok markus, itojun.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.34 2004/03/28 17:39:12 deraadt Exp $	*/
d277 1
d376 4
d422 4
d432 2
d449 1
a449 1
		break;
@


1.34
log
@memory leak fix; from pat, via tedu, ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.33 2003/12/10 07:22:43 itojun Exp $	*/
d529 1
a529 1
		/* copy args to in_aliasreq, perform ioctl(SIOCAIFADDR_IN6). */
d585 1
a585 1
			if (ifa->ifa_addr->sa_family != AF_INET6)
d617 1
a617 1
			/* fill in_aliasreq and do ioctl(SIOCDIFADDR_IN6) */
@


1.33
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.32 2003/06/23 08:09:21 itojun Exp $	*/
d420 3
a422 1
	case SIOCDIFADDR:
d433 2
d439 1
@


1.32
log
@install host route for p2p interface even if there's connected net route
by broadcast interface.  NetBSD PR 21903.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.31 2003/06/02 23:28:13 millert Exp $	*/
d114 1
a114 1
	register struct in_ifaddr *ia;
d137 1
a137 1
	register u_int32_t net;
d156 2
a157 2
	register char *cplim = (char *) &ap->sin_addr;
	register char *cp = (char *) (&ap->sin_addr + 1);
d217 1
a217 1
	register struct ifnet *ifp;
d219 2
a220 2
	register struct ifreq *ifr = (struct ifreq *)data;
	register struct in_ifaddr *ia = 0;
d639 2
a640 2
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
d652 2
a653 2
	register struct ifnet *ifp;
	register struct in_ifaddr *ia;
d657 1
a657 1
	register u_int32_t i = sin->sin_addr.s_addr;
d862 1
a862 1
	register struct ifaddr *ifa;
d908 2
a909 2
	register struct in_addr *ap;
	register struct ifnet *ifp;
d911 1
a911 1
	register struct in_multi *inm;
d975 1
a975 1
	register struct in_multi *inm;
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.30 2002/10/04 05:23:39 henric Exp $	*/
d758 1
a758 1
	else
d760 3
a762 2
	mask = target->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;
a764 4
		/* easy one first */
		if (mask.s_addr != ia->ia_sockmask.sin_addr.s_addr)
			continue;

d767 1
a767 1
		else
d769 3
a771 1
		p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
d810 1
a810 1
	else
d812 3
a814 2
	mask = target->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;
a816 4
		/* easy one first */
		if (mask.s_addr != ia->ia_sockmask.sin_addr.s_addr)
			continue;

d819 1
a819 1
		else
d821 3
a823 1
		p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
@


1.30
log
@Prevent packet processing while tweaking address and routing tables.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.29 2002/09/11 03:15:36 itojun Exp $	*/
d44 1
a44 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.28 2002/07/12 13:31:20 art Exp $	*/
d229 1
d277 1
d293 1
d350 1
d356 1
d365 1
d375 1
d379 1
d391 1
d421 1
d425 7
d437 1
d679 9
@


1.28
log
@- Add a flags argument to dohooks.
  The flag can be either HOOK_REMOVE or HOOK_REMOVE|HOOK_FREE.
   o HOOK_REMOVE removes the hook from the list before executing it.
   o HOOK_FREE frees the hook after that.

- Let dostartuphooks use HOOK_REMOVE|HOOK_FREE so we can reclaim the memory.

- Let doshutdownhooks use HOOK_REMOVE so that when some shutdown hook
  panics (they do that all the #@@$%! time these days) we don't loop
  for ever. Don't HOOK_FREE, it doesn't matter and I don't want to add
  another possible panic condition for shutdown hooks.

- Actually free the pointer we're throwing away in hook_disestablish (I wonder
  how much memory this has leaked over the years).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.27 2002/06/09 16:26:10 itojun Exp $	*/
d234 1
a234 1
			return(EPERM);
@


1.27
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.26 2002/04/24 00:51:51 dhartmei Exp $	*/
d371 1
a371 1
			dohooks(ifp->if_addrhooks);
d411 1
a411 1
			dohooks(ifp->if_addrhooks);
d419 1
a419 1
		dohooks(ifp->if_addrhooks);
@


1.26
log
@Add hooks to struct ifnet that allow to register callbacks that will be
notified of interface address changes. ok provos@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.25 2002/04/01 02:44:08 itojun Exp $	*/
d6 1
a6 1
 * 
d18 1
a18 1
 * 
@


1.25
log
@cleanup in_broadcast.  don't consider /32 addrs as broadcast.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.24 2002/03/14 01:27:11 millert Exp $	*/
d370 2
d410 2
d419 1
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.23 2001/11/24 19:29:06 deraadt Exp $	*/
d100 5
d106 2
a840 2
	if (ifp && ((ifp->if_flags & IFF_BROADCAST) == 0))
		return 0;
d842 1
a842 2
	if (ifp == NULL)
	{
d845 1
a845 3
	}
	else
	{
d856 17
a872 28
        for (ifn = if_first; ifn != if_target; ifn = ifn->if_list.tqe_next)
	  for (ifa = ifn->if_addrlist.tqh_first; ifa;
	       ifa = ifa->ifa_list.tqe_next)
	      if (!ifp)
	      {
		  if (ifa->ifa_addr->sa_family == AF_INET &&
		      ((ia->ia_subnetmask != 0xffffffff &&
		      (((ifn->if_flags & IFF_BROADCAST) &&
			in.s_addr == ia->ia_broadaddr.sin_addr.s_addr) ||
			 in.s_addr == ia->ia_subnet)) ||
		       /*
			* Check for old-style (host 0) broadcast.
			*/
		       (in.s_addr == ia->ia_netbroadcast.s_addr ||
			in.s_addr == ia->ia_net)))
		              return 1;
	      }
	      else
		  if (ifa->ifa_addr->sa_family == AF_INET &&
		      (((ifn->if_flags & IFF_BROADCAST) &&
		      in.s_addr == ia->ia_broadaddr.sin_addr.s_addr) ||
		       in.s_addr == ia->ia_netbroadcast.s_addr ||
		       /*
			* Check for old-style (host 0) broadcast.
			*/
		       in.s_addr == ia->ia_subnet ||
		       in.s_addr == ia->ia_net))
		              return 1;
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.22 2001/07/27 02:17:54 itojun Exp $	*/
d89 4
a92 4
static int in_mask2len __P((struct in_addr *));
static void in_len2mask __P((struct in_addr *, int));
static int in_lifaddr_ioctl __P((struct socket *, u_long, caddr_t,
	struct ifnet *));
d94 2
a95 2
static int in_addprefix __P((struct in_ifaddr *, int));
static int in_scrubprefix __P((struct in_ifaddr *));
@


1.23.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.23 2001/11/24 19:29:06 deraadt Exp $	*/
d89 4
a92 4
static int in_mask2len(struct in_addr *);
static void in_len2mask(struct in_addr *, int);
static int in_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *);
d94 2
a95 2
static int in_addprefix(struct in_ifaddr *, int);
static int in_scrubprefix(struct in_ifaddr *);
a99 5

#ifndef HOSTZEROBROADCAST
#define HOSTZEROBROADCAST 1
#endif

a100 2
int hostzeroisbroadcast = HOSTZEROBROADCAST;

a362 2
		if (!error)
			dohooks(ifp->if_addrhooks);
a400 2
		if (!error)
			dohooks(ifp->if_addrhooks);
a407 1
		dohooks(ifp->if_addrhooks);
d834 2
d837 2
a838 1
	if (ifp == NULL) {
d841 3
a843 1
	} else {
d854 28
a881 17
        for (ifn = if_first; ifn != if_target; ifn = ifn->if_list.tqe_next) {
		if ((ifn->if_flags & IFF_BROADCAST) == 0)
			continue;
		for (ifa = ifn->if_addrlist.tqh_first; ifa;
		    ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_INET &&
			    in.s_addr != ia->ia_addr.sin_addr.s_addr &&
			    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			     in.s_addr == ia->ia_netbroadcast.s_addr ||
			     (hostzeroisbroadcast &&
			      /*
			       * Check for old-style (host 0) broadcast.
			       */
			      (in.s_addr == ia->ia_subnet ||
			       in.s_addr == ia->ia_net))))
				return 1;
	}
@


1.23.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.23.2.1 2002/06/11 03:31:36 art Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a228 1
	int s;
d234 1
a234 1
			return (EPERM);
a275 1
			s = splsoftnet();
a290 1
			splx(s);
a346 1
		s = splsoftnet();
a351 1
			splx(s);
a359 1
		splx(s);
a368 1
		s = splsoftnet();
d371 1
a371 2
			dohooks(ifp->if_addrhooks, 0);
		splx(s);
a382 1
		s = splsoftnet();
d411 1
a411 2
			dohooks(ifp->if_addrhooks, 0);
		splx(s);
a414 7
		/*
		 * Even if the individual steps were safe, shouldn't
		 * these kinds of changes happen atomically?  What 
		 * should happen to a packet that was routed after
		 * the scrub but before the other steps? 
		 */
		s = splsoftnet();
d419 1
a419 2
		dohooks(ifp->if_addrhooks, 0);
		splx(s);
a660 9

	/*
	 * How should a packet be routed during
	 * an address change--and is it safe?
	 * Is the "ifp" even in a consistent state?
	 * Be safe for now.
	 */
	splassert(IPL_SOFTNET);

@


1.22
log
@do not check in_dstaddr in rtinitflags() macro, otherwise
linklocal address manipulation codepath will choke.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.21 2001/07/23 14:23:21 itojun Exp $	*/
d249 1
a249 1
			if (ia->ia_ifp == ifp  &&
@


1.21
log
@improve IFA_ROUTE handling.  do not lose connected route on primary
interface address removals.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.20 2001/06/08 03:53:45 angelos Exp $	*/
d705 2
a706 2
	(((((x)->ia_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) != 0) && \
	  (x)->ia_dstaddr.sin_family == AF_INET) ? RTF_HOST : 0)
@


1.20
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.19 2001/05/16 12:53:35 ho Exp $	*/
d5 28
d94 3
a362 17
#if 0
		/*
		 * the code chokes if we are to assign multiple addresses with
		 * the same address prefix (rtinit() will return EEXIST, which
		 * is not fatal actually).  we will get memory leak if we
		 * don't do it.
		 * -> we may want to hide EEXIST from rtinit().
		 */
  undo:
		if (error && newifaddr){
			TAILQ_REMOVE(&ifp->if_addrlist, &ia->ia_ifa, ifa_list);
			TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
			FREE(ia, M_IFADDR);
			if ((ifp->if_flags & IFF_LOOPBACK) == 0)
				in_interfaces--;
		}
#endif
a396 4
#if 0
			if (error)
				goto undo;
#endif
d617 1
a617 7
	if ((ia->ia_flags & IFA_ROUTE) == 0)
		return;
	if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
	else
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
	ia->ia_flags &= ~IFA_ROUTE;
d690 1
a690 2
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, flags)) == 0)
		ia->ia_flags |= IFA_ROUTE;
d704 115
@


1.19
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.18 2000/10/06 05:52:00 itojun Exp $	*/
d40 1
a41 1
#include <sys/errno.h>
a44 1
#include <sys/systm.h>
a48 1
#include <netinet/in_systm.h>
a50 1
#include <netinet/if_ether.h>
@


1.18
log
@remove now-obsolete SIOCSIFPHY* handling in in{6,}_control.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.17 2000/03/22 03:48:30 itojun Exp $	*/
a239 2
			if (ia == (struct in_ifaddr *)0)
				return (ENOBUFS);
@


1.17
log
@comment out ifconfig undo code.  they are necessary to avoid memory
leakage, however, was too strict that they disallow multiple address
from same prefix to be assigned (when rtinit returns EEXIST).
we'll need to improve it.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.16 2000/03/12 06:46:31 itojun Exp $	*/
a47 1
#include <net/if_types.h>
a48 4
#include "gif.h"
#if NGIF > 0
#include <net/if_gif.h>
#endif
a193 13

#if NGIF > 0
	if (ifp && ifp->if_type == IFT_GIF) {
		switch (cmd) {
		case SIOCSIFPHYADDR:
			if ((so->so_state & SS_PRIV) == 0)
				return(EPERM);
		case SIOCGIFPSRCADDR:
		case SIOCGIFPDSTADDR:
			return gif_ioctl(ifp, cmd, data);
		}
	}
#endif
@


1.16
log
@undo interface address addition, if in_ifinit fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.15 2000/01/04 21:38:56 fgsch Exp $	*/
d355 8
d371 1
d406 1
d409 1
@


1.15
log
@If SIOCSIFADDR fails, put back the old address before calling splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.14 1999/12/08 06:50:19 itojun Exp $	*/
d198 1
d276 4
a279 1
		}
d354 10
a363 1
		return (in_ifinit(ifp, ia, satosin(&ifr->ifr_addr), 1));
d395 1
a395 1
		    (hostIsNew || maskIsNew))
d397 3
@


1.15.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a197 1
	int newifaddr;
d275 1
a275 4

			newifaddr = 1;
		} else
			newifaddr = 0;
d350 1
a350 19
		error = in_ifinit(ifp, ia, satosin(&ifr->ifr_addr), 1);
#if 0
		/*
		 * the code chokes if we are to assign multiple addresses with
		 * the same address prefix (rtinit() will return EEXIST, which
		 * is not fatal actually).  we will get memory leak if we
		 * don't do it.
		 * -> we may want to hide EEXIST from rtinit().
		 */
  undo:
		if (error && newifaddr){
			TAILQ_REMOVE(&ifp->if_addrlist, &ia->ia_ifa, ifa_list);
			TAILQ_REMOVE(&in_ifaddr, ia, ia_list);
			FREE(ia, M_IFADDR);
			if ((ifp->if_flags & IFF_LOOPBACK) == 0)
				in_interfaces--;
		}
#endif
		return error;
d382 1
a382 1
		    (hostIsNew || maskIsNew)) {
a383 5
#if 0
			if (error)
				goto undo;
#endif
		}
@


1.15.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.18 2000/10/06 05:52:00 itojun Exp $	*/
d48 1
d50 4
d199 13
@


1.15.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.15.2.2 2001/05/14 22:40:07 niklas Exp $	*/
a39 1
#include <sys/systm.h>
d41 1
d45 1
d50 1
d53 1
d240 2
@


1.15.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.15.2.3 2001/07/04 10:54:31 niklas Exp $	*/
a4 28
 * Copyright (C) 2001 WIDE Project.  All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
a65 3
static int in_addprefix __P((struct in_ifaddr *, int));
static int in_scrubprefix __P((struct in_ifaddr *));

d332 17
d383 4
d607 7
a613 1
	in_scrubprefix(ia);
d686 2
a687 1
	error = in_addprefix(ia, flags);
a700 115
#define rtinitflags(x) \
	((((x)->ia_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) != 0) \
	    ? RTF_HOST : 0)

/*
 * add a route to prefix ("connected route" in cisco terminology).
 * does nothing if there's some interface address with the same prefix already.
 */
static int
in_addprefix(target, flags)
	struct in_ifaddr *target;
	int flags;
{
	struct in_ifaddr *ia;
	struct in_addr prefix, mask, p;
	int error;

	if ((flags & RTF_HOST) != 0)
		prefix = target->ia_dstaddr.sin_addr;
	else
		prefix = target->ia_addr.sin_addr;
	mask = target->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;

	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		/* easy one first */
		if (mask.s_addr != ia->ia_sockmask.sin_addr.s_addr)
			continue;

		if (rtinitflags(ia))
			p = ia->ia_dstaddr.sin_addr;
		else
			p = ia->ia_addr.sin_addr;
		p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
		if (prefix.s_addr != p.s_addr)
			continue;

		/*
		 * if we got a matching prefix route inserted by other
		 * interface adderss, we don't need to bother
		 */
		if (ia->ia_flags & IFA_ROUTE)
			return 0;
	}

	/*
	 * noone seem to have prefix route.  insert it.
	 */
	error = rtinit(&target->ia_ifa, (int)RTM_ADD, flags);
	if (!error)
		target->ia_flags |= IFA_ROUTE;
	return error;
}

/*
 * remove a route to prefix ("connected route" in cisco terminology).
 * re-installs the route by using another interface address, if there's one
 * with the same prefix (otherwise we lose the route mistakenly).
 */
static int
in_scrubprefix(target)
	struct in_ifaddr *target;
{
	struct in_ifaddr *ia;
	struct in_addr prefix, mask, p;
	int error;

	if ((target->ia_flags & IFA_ROUTE) == 0)
		return 0;

	if (rtinitflags(target))
		prefix = target->ia_dstaddr.sin_addr;
	else
		prefix = target->ia_addr.sin_addr;
	mask = target->ia_sockmask.sin_addr;
	prefix.s_addr &= mask.s_addr;

	for (ia = in_ifaddr.tqh_first; ia; ia = ia->ia_list.tqe_next) {
		/* easy one first */
		if (mask.s_addr != ia->ia_sockmask.sin_addr.s_addr)
			continue;

		if (rtinitflags(ia))
			p = ia->ia_dstaddr.sin_addr;
		else
			p = ia->ia_addr.sin_addr;
		p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
		if (prefix.s_addr != p.s_addr)
			continue;

		/*
		 * if we got a matching prefix route, move IFA_ROUTE to him
		 */
		if ((ia->ia_flags & IFA_ROUTE) == 0) {
			rtinit(&(target->ia_ifa), (int)RTM_DELETE,
			    rtinitflags(target));
			target->ia_flags &= ~IFA_ROUTE;

			error = rtinit(&ia->ia_ifa, (int)RTM_ADD,
			    rtinitflags(ia) | RTF_UP);
			if (error == 0)
				ia->ia_flags |= IFA_ROUTE;
			return error;
		}
	}

	/*
	 * noone seem to have prefix route.  remove it.
	 */
	rtinit(&(target->ia_ifa), (int)RTM_DELETE, rtinitflags(target));
	target->ia_flags &= ~IFA_ROUTE;
	return 0;
}

#undef rtinitflags
@


1.15.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d249 1
a249 1
			if (ia->ia_ifp == ifp &&
@


1.15.2.6
log
@Merge in -current from roughly a week ago
@
text
@d89 4
a92 4
static int in_mask2len(struct in_addr *);
static void in_len2mask(struct in_addr *, int);
static int in_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *);
d94 2
a95 2
static int in_addprefix(struct in_ifaddr *, int);
static int in_scrubprefix(struct in_ifaddr *);
@


1.15.2.7
log
@Sync the SMP branch with 3.3
@
text
@d6 1
a6 1
 *
d18 1
a18 1
 *
a99 5

#ifndef HOSTZEROBROADCAST
#define HOSTZEROBROADCAST 1
#endif

a100 2
int hostzeroisbroadcast = HOSTZEROBROADCAST;

a221 1
	int s;
d227 1
a227 1
			return (EPERM);
a268 1
			s = splsoftnet();
a283 1
			splx(s);
a339 1
		s = splsoftnet();
a344 1
			splx(s);
a352 1
		splx(s);
a361 1
		s = splsoftnet();
a362 3
		if (!error)
			dohooks(ifp->if_addrhooks, 0);
		splx(s);
a373 1
		s = splsoftnet();
a400 3
		if (!error)
			dohooks(ifp->if_addrhooks, 0);
		splx(s);
a403 7
		/*
		 * Even if the individual steps were safe, shouldn't
		 * these kinds of changes happen atomically?  What 
		 * should happen to a packet that was routed after
		 * the scrub but before the other steps? 
		 */
		s = splsoftnet();
a407 2
		dohooks(ifp->if_addrhooks, 0);
		splx(s);
a648 9

	/*
	 * How should a packet be routed during
	 * an address change--and is it safe?
	 * Is the "ifp" even in a consistent state?
	 * Be safe for now.
	 */
	splassert(IPL_SOFTNET);

d834 2
d837 2
a838 1
	if (ifp == NULL) {
d841 3
a843 1
	} else {
d854 28
a881 17
        for (ifn = if_first; ifn != if_target; ifn = ifn->if_list.tqe_next) {
		if ((ifn->if_flags & IFF_BROADCAST) == 0)
			continue;
		for (ifa = ifn->if_addrlist.tqh_first; ifa;
		    ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_INET &&
			    in.s_addr != ia->ia_addr.sin_addr.s_addr &&
			    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
			     in.s_addr == ia->ia_netbroadcast.s_addr ||
			     (hostzeroisbroadcast &&
			      /*
			       * Check for old-style (host 0) broadcast.
			       */
			      (in.s_addr == ia->ia_subnet ||
			       in.s_addr == ia->ia_net))))
				return 1;
	}
@


1.15.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.15.2.7 2003/03/28 00:06:54 niklas Exp $	*/
d44 5
a48 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d114 1
a114 1
	struct in_ifaddr *ia;
d137 1
a137 1
	u_int32_t net;
d156 2
a157 2
	char *cplim = (char *) &ap->sin_addr;
	char *cp = (char *) (&ap->sin_addr + 1);
d217 1
a217 1
	struct ifnet *ifp;
d219 2
a220 2
	struct ifreq *ifr = (struct ifreq *)data;
	struct in_ifaddr *ia = 0;
d639 2
a640 2
	struct ifnet *ifp;
	struct in_ifaddr *ia;
d652 2
a653 2
	struct ifnet *ifp;
	struct in_ifaddr *ia;
d657 1
a657 1
	u_int32_t i = sin->sin_addr.s_addr;
d758 1
a758 1
	else {
d760 2
a761 3
		mask = target->ia_sockmask.sin_addr;
		prefix.s_addr &= mask.s_addr;
	}
d764 4
d770 1
a770 1
		else {
d772 1
a772 3
			p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
		}

d811 1
a811 1
	else {
d813 2
a814 3
		mask = target->ia_sockmask.sin_addr;
		prefix.s_addr &= mask.s_addr;
	}
d817 4
d823 1
a823 1
		else {
d825 1
a825 3
			p.s_addr &= ia->ia_sockmask.sin_addr.s_addr;
		}

d864 1
a864 1
	struct ifaddr *ifa;
d910 2
a911 2
	struct in_addr *ap;
	struct ifnet *ifp;
d913 1
a913 1
	struct in_multi *inm;
d977 1
a977 1
	struct in_multi *inm;
@


1.15.2.10
log
@Merge with the trunk
@
text
@d420 1
a420 3
	case SIOCDIFADDR: {
		struct in_multi *inm;

a430 2
		while ((inm = LIST_FIRST(&ia->ia_multiaddrs)) != NULL)
			in_delmulti(inm);
a434 1
		}
d524 1
a524 1
		/* copy args to in_aliasreq, perform ioctl(SIOCAIFADDR). */
d580 1
a580 1
			if (ifa->ifa_addr->sa_family != AF_INET)
d612 1
a612 1
			/* fill in_aliasreq and do ioctl(SIOCDIFADDR) */
@


1.14
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.13 1999/04/20 20:06:11 niklas Exp $	*/
d636 1
a637 1
		ia->ia_addr = oldaddr;
@


1.13
log
@Merge MROUTING and IPSEC wrt handling of IP-in-IP tunnelled packets.
Fix a panic case in the MROUTING code too.  Drop M_TUNNEL support, nothing
ever uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.12 1998/04/25 23:38:21 d Exp $	*/
d48 1
d50 4
d69 5
d141 38
d199 25
d408 184
@


1.12
log
@close PR 459
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.11 1998/03/27 18:59:56 angelos Exp $	*/
d54 3
d58 1
a58 1
#include <netinet/igmp_var.h>
@


1.11
log
@Fix bug (I introduced) with aliases and in_broadcast().
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.10 1998/03/20 02:45:06 deraadt Exp $	*/
d479 2
a480 1
			(in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
d491 2
a492 1
		      (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
@


1.10
log
@for SIOCGIF{NETMASK,DSTADDR,BRDADDR} calls match address to if aliases entries
so that correct information is returned (previously information about the
primary address was returned).  If the address cannot be found on the
interface, return information about the primary (for OSIOC* compatibility).
work by angelos and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.9 1998/03/19 21:21:44 angelos Exp $	*/
d470 1
a470 1
	 * If ifp is NULL, check against all the local interfaces.
d475 23
a497 10
		if (ifa->ifa_addr->sa_family == AF_INET &&
		    (((in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
		       in.s_addr == ia->ia_netbroadcast.s_addr) &&
		      (ia->ia_subnetmask != 0xffffffff)) ||
		     /*
		      * Check for old-style (host 0) broadcast.
		      */
		     in.s_addr == ia->ia_subnet ||
		     in.s_addr == ia->ia_net))
			    return 1;
@


1.9
log
@This should fix some problems with the aliases.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.8 1998/02/28 03:39:56 angelos Exp $	*/
d211 12
@


1.8
log
@Another shot at disallowing TCP connections to 255.255.255.255,
0.0.0.0 and any local broadcast addresses. Tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.7 1998/02/25 04:53:09 angelos Exp $	*/
d464 3
a466 2
		    (in.s_addr == ia->ia_broadaddr.sin_addr.s_addr ||
		     in.s_addr == ia->ia_netbroadcast.s_addr ||
@


1.7
log
@patch could not have been tested. panics machine on boot
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.3 1996/09/12 06:04:47 tholo Exp $	*/
d434 1
d440 1
a440 1
	if ((ifp->if_flags & IFF_BROADCAST) == 0)
d442 13
d458 1
d460 3
a462 2
#define ia (ifatoia(ifa))
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
@


1.6
log
@please indent as the file is currently indented
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.5 1998/02/25 04:53:09 angelos Exp $	*/
a433 1
	struct ifnet *ifn, *if_first, *if_target;
d439 1
a439 1
	if (ifp && ((ifp->if_flags & IFF_BROADCAST) == 0))
a440 10

	if (ifp == NULL) {
	  	if_first = ifnet.tqh_first;
		if_target = 0;
	} else {
		if_first = ifp;
		if_target = ifp->if_list.tqe_next;
	}

#define ia (ifatoia(ifa))
a443 1
	 * If ifp is NULL, check against all the local interfaces.
d445 2
a446 3
        for (ifn = if_first; ifn != if_target; ifn = ifn->if_list.tqe_next)
	  for (ifa = ifn->if_addrlist.tqh_first; ifa;
	       ifa = ifa->ifa_list.tqe_next)
@


1.5
log
@Pay attention.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.4 1998/02/25 03:45:14 angelos Exp $	*/
d443 1
a443 2
	if (ifp == NULL)
	{
d446 1
a446 3
	}
	else
	{
@


1.4
log
@Disallow TCP connects to 255.255.255.255 or local broadcast addresses.
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.3 1996/09/12 06:04:47 tholo Exp $	*/
d461 1
a461 1
	  for (ifa = ifp->if_addrlist.tqh_first; ifa;
@


1.3
log
@Don't assume other subnets than our own are local to us; from Luigi Rizzo
by way of Jason Downs & Theo de Raadt.  Can be overridden in the kernel
configuration file by using "option SUBNETSARELOCAL=1"
@
text
@d1 1
a1 1
/*	$OpenBSD: in.c,v 1.2 1996/03/03 22:30:28 niklas Exp $	*/
d434 1
d440 1
a440 1
	if ((ifp->if_flags & IFF_BROADCAST) == 0)
d442 13
d458 1
d460 3
a462 2
#define ia (ifatoia(ifa))
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 1
a62 1
#define	SUBNETSARELOCAL	1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: in.c,v 1.25 1995/08/12 23:59:32 mycroft Exp $	*/
d45 1
d55 1
a143 1
	register struct ifaddr *ifa;
d353 1
a353 1
	int s = splimp(), flags = RTF_UP, error, ether_output();
d530 1
a530 1
int
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

