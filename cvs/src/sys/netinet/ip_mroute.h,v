head	1.28;
access;
symbols
	OPENBSD_6_2:1.28.0.6
	OPENBSD_6_2_BASE:1.28
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.19.0.10
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.6
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.14
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.12
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.10
	OPENBSD_5_0:1.15.0.8
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.6
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.16
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.12
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.10
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.8
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.6
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.4
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.8
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.6
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.4
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.8
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.27;
commitid	UBL7uwpXqTP4EWIu;

1.27
date	2017.01.12.08.22.42;	author rzalamena;	state Exp;
branches;
next	1.26;
commitid	LgZRMC67dCmUKQVm;

1.26
date	2017.01.11.13.17.35;	author rzalamena;	state Exp;
branches;
next	1.25;
commitid	fgHCBRIhwoy5PLRt;

1.25
date	2017.01.06.14.01.19;	author rzalamena;	state Exp;
branches;
next	1.24;
commitid	HqvJlf6KKxwDeViP;

1.24
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.23;
commitid	T2qzeepA7r1EGy1x;

1.23
date	2016.12.20.09.33.13;	author rzalamena;	state Exp;
branches;
next	1.22;
commitid	Kl2kqz5LA3XMNf1c;

1.22
date	2016.12.19.12.52.41;	author rzalamena;	state Exp;
branches;
next	1.21;
commitid	7gIwStnOidAWH0dG;

1.21
date	2016.12.19.09.22.24;	author rzalamena;	state Exp;
branches;
next	1.20;
commitid	5iifwOyfMyS6GiDF;

1.20
date	2016.11.29.15.52.12;	author mpi;	state Exp;
branches;
next	1.19;
commitid	uz4Tr6mhWo8vJLF8;

1.19
date	2015.02.09.12.18.19;	author claudio;	state Exp;
branches;
next	1.18;
commitid	8K5RNpON80OVB59T;

1.18
date	2014.08.14.08.22.38;	author mpi;	state Exp;
branches;
next	1.17;
commitid	vlb8w9hmS6iNy3Wt;

1.17
date	2013.10.27.20.57.39;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.13.19.14.29;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.25.15.49.35;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.30.14.28.28;	author norby;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.14.14.51.28;	author mcbride;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.24.01.25.42;	author mcbride;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.24.20.31.16;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.16.26.10;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.09.07.03.42;	author angelos;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2000.01.21.03.15.05;	author angelos;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.08.08.00.43.00;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	99.04.20.20.06.12;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.22.30.40;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.11;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2001.07.04.10.54.54;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.03.28.00.06.54;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@/*	$OpenBSD: ip_mroute.h,v 1.27 2017/01/12 08:22:42 rzalamena Exp $	*/
/*	$NetBSD: ip_mroute.h,v 1.23 2004/04/21 17:49:46 itojun Exp $	*/

#ifndef _NETINET_IP_MROUTE_H_
#define _NETINET_IP_MROUTE_H_

/*
 * Definitions for IP multicast forwarding.
 *
 * Written by David Waitzman, BBN Labs, August 1988.
 * Modified by Steve Deering, Stanford, February 1989.
 * Modified by Ajit Thyagarajan, PARC, August 1993.
 * Modified by Ajit Thyagarajan, PARC, August 1994.
 * Modified by Ahmed Helmy, SGI, June 1996.
 * Modified by Pavlin Radoslavov, ICSI, October 2002.
 *
 * MROUTING Revision: 1.2
 * advanced API support, bandwidth metering and signaling.
 */

#include <sys/timeout.h>

/*
 * Multicast Routing set/getsockopt commands.
 */
#define	MRT_INIT		100	/* initialize forwarder */
#define	MRT_DONE		101	/* shut down forwarder */
#define	MRT_ADD_VIF		102	/* create virtual interface */
#define	MRT_DEL_VIF		103	/* delete virtual interface */
#define	MRT_ADD_MFC		104	/* insert forwarding cache entry */
#define	MRT_DEL_MFC		105	/* delete forwarding cache entry */
#define	MRT_VERSION		106	/* get kernel version number */
#define	MRT_ASSERT		107	/* enable assert processing */
#define	MRT_API_SUPPORT		109	/* supported MRT API */
#define	MRT_API_CONFIG		110	/* config MRT API */

/*
 * Types and macros for handling bitmaps with one bit per virtual interface.
 */
#define	MAXVIFS 32
typedef u_int32_t vifbitmap_t;
typedef u_int16_t vifi_t;		/* type of a vif index */

#define	VIFM_SET(n, m)			((m) |= (1 << (n)))
#define	VIFM_CLR(n, m)			((m) &= ~(1 << (n)))
#define	VIFM_ISSET(n, m)		((m) & (1 << (n)))
#define	VIFM_CLRALL(m)			((m) = 0x00000000)
#define	VIFM_COPY(mfrom, mto)		((mto) = (mfrom))
#define	VIFM_SAME(m1, m2)		((m1) == (m2))

#define	VIFF_TUNNEL	0x1		/* vif represents a tunnel end-point */
#define	VIFF_SRCRT	0x2		/* tunnel uses IP src routing */

/*
 * Argument structure for MRT_ADD_VIF.
 * (MRT_DEL_VIF takes a single vifi_t argument.)
 */
struct vifctl {
	vifi_t	  vifc_vifi;	    	/* the index of the vif to be added */
	u_int8_t  vifc_flags;     	/* VIFF_ flags defined above */
	u_int8_t  vifc_threshold; 	/* min ttl required to forward on vif */
	u_int32_t vifc_rate_limit;	/* ignored */
	struct	  in_addr vifc_lcl_addr;/* local interface address */
	struct	  in_addr vifc_rmt_addr;/* remote address (tunnels only) */
};

/*
 * Argument structure for MRT_ADD_MFC and MRT_DEL_MFC.
 * XXX if you change this, make sure to change struct mfcctl2 as well.
 */
struct mfcctl {
	struct	 in_addr mfcc_origin;	/* ip origin of mcasts */
	struct	 in_addr mfcc_mcastgrp;	/* multicast group associated */
	vifi_t	 mfcc_parent;		/* incoming vif */
	u_int8_t mfcc_ttls[MAXVIFS];	/* forwarding ttls on vifs */
};

/*
 * The new argument structure for MRT_ADD_MFC and MRT_DEL_MFC overlays
 * and extends the old struct mfcctl.
 */
struct mfcctl2 {
	/* the mfcctl fields */
	struct in_addr	mfcc_origin;		/* ip origin of mcasts	     */
	struct in_addr	mfcc_mcastgrp;		/* multicast group associated*/
	vifi_t		mfcc_parent;		/* incoming vif		     */
	u_int8_t	mfcc_ttls[MAXVIFS]; 	/* forwarding ttls on vifs   */

	/* extension fields */
	u_int8_t	mfcc_flags[MAXVIFS];	/* the MRT_MFC_FLAGS_* flags */
	struct in_addr	mfcc_rp;		/* the RP address            */
};
/*
 * The advanced-API flags.
 *
 * The MRT_MFC_FLAGS_XXX API flags are also used as flags
 * for the mfcc_flags field.
 */
#define	MRT_MFC_FLAGS_DISABLE_WRONGVIF	(1 << 0) /* disable WRONGVIF signals */
#define	MRT_MFC_RP			(1 << 8) /* enable RP address	     */
#define	MRT_MFC_BW_UPCALL		(1 << 9) /* enable bw upcalls	     */
#define	MRT_MFC_FLAGS_ALL		(MRT_MFC_FLAGS_DISABLE_WRONGVIF)
#define	MRT_API_FLAGS_ALL		(MRT_MFC_FLAGS_ALL |		     \
					 MRT_MFC_RP |			     \
					 MRT_MFC_BW_UPCALL)

/* structure used to get all the mfc entries */
struct mfcinfo {
	struct	 in_addr mfc_origin;	/* ip origin of mcasts */
	struct	 in_addr mfc_mcastgrp;	/* multicast group associated */
	vifi_t	 mfc_parent;		/* incoming vif */
	u_long	 mfc_pkt_cnt;		/* pkt count for src-grp */
	u_long	 mfc_byte_cnt;		/* byte count for src-grp */
	u_int8_t mfc_ttls[MAXVIFS];	/* forwarding ttls on vifs */
};

/* structure used to get all the vif entries */
struct vifinfo {
	vifi_t	  v_vifi;	    	/* the index of the vif to be added */
	u_int8_t  v_flags;		/* VIFF_ flags defined above */
	u_int8_t  v_threshold;		/* min ttl required to forward on vif */
	struct	  in_addr v_lcl_addr;	/* local interface address */
	struct	  in_addr v_rmt_addr;	/* remote address (tunnels only) */
	u_long	  v_pkt_in;		/* # pkts in on interface */
	u_long	  v_pkt_out;		/* # pkts out on interface */
	u_long	  v_bytes_in;		/* # bytes in on interface */
	u_long	  v_bytes_out;		/* # bytes out on interface */
};

/*
 * Argument structure used by mrouted to get src-grp pkt counts.
 */
struct sioc_sg_req {
	struct	in_addr src;
	struct	in_addr grp;
	u_long	pktcnt;
	u_long	bytecnt;
	u_long	wrong_if;
};

/*
 * Argument structure used by mrouted to get vif pkt counts.
 */
struct sioc_vif_req {
	vifi_t	vifi;			/* vif number */
	u_long	icount;			/* input packet count on vif */
	u_long	ocount;			/* output packet count on vif */
	u_long	ibytes;			/* input byte count on vif */
	u_long	obytes;			/* output byte count on vif */
};


/*
 * The kernel's multicast routing statistics.
 */
struct mrtstat {
	u_long	mrts_mfc_lookups;	/* # forw. cache hash table hits */
	u_long	mrts_mfc_misses;	/* # forw. cache hash table misses */
	u_long	mrts_upcalls;		/* # calls to mrouted */
	u_long	mrts_no_route;		/* no route for packet's origin */
	u_long	mrts_bad_tunnel;	/* malformed tunnel options */
	u_long	mrts_cant_tunnel;	/* no room for tunnel options */
	u_long	mrts_wrong_if;		/* arrived on wrong interface */
	u_long	mrts_upq_ovflw;		/* upcall Q overflow */
	u_long	mrts_cache_cleanups;	/* # entries with no upcalls */
	u_long	mrts_drop_sel;     	/* pkts dropped selectively */
	u_long	mrts_q_overflow;    	/* pkts dropped - Q overflow */
	u_long	mrts_pkt2large;     	/* pkts dropped - size > BKT SIZE */
	u_long	mrts_upq_sockfull;	/* upcalls dropped - socket full */
};


#ifdef _KERNEL

/* How frequent should we look for expired entries (in seconds). */
#define MCAST_EXPIRE_FREQUENCY		30

/*
 * The kernel's virtual-interface structure.
 */
struct vif {
	vifi_t    v_id;			/* Virtual interface index */
	u_int8_t  v_flags;		/* VIFF_ flags defined above */
	u_int8_t  v_threshold;		/* min ttl required to forward on vif */
	struct	  in_addr v_lcl_addr;	/* local interface address */
	struct	  in_addr v_rmt_addr;	/* remote address (tunnels only) */
	u_long	  v_pkt_in;		/* # pkts in on interface */
	u_long	  v_pkt_out;		/* # pkts out on interface */
	u_long	  v_bytes_in;		/* # bytes in on interface */
	u_long	  v_bytes_out;		/* # bytes out on interface */
};

/*
 * The kernel's multicast forwarding cache entry structure.
 * (A field for the type of service (mfc_tos) is to be added
 * at a future point.)
 */
struct mfc {
	vifi_t	 mfc_parent;			/* incoming vif */
	u_long	 mfc_pkt_cnt;			/* pkt count for src-grp */
	u_long	 mfc_byte_cnt;			/* byte count for src-grp */
	u_long	 mfc_wrong_if;			/* wrong if for src-grp	*/
	uint8_t	 mfc_ttl;			/* route interface ttl */
	uint8_t  mfc_flags;			/* MRT_MFC_FLAGS_* flags */
	struct in_addr	mfc_rp;			/* the RP address	     */
	u_long	 mfc_expire;			/* expire timer */
};

/*
 * Structure used to communicate from kernel to multicast router.
 * (Note the convenient similarity to an IP packet.)
 */
struct igmpmsg {
	u_int32_t unused1;
	u_int32_t unused2;
	u_int8_t  im_msgtype;		/* what type of message */
#define	IGMPMSG_NOCACHE		1	/* no MFC in the kernel		    */
#define	IGMPMSG_WRONGVIF	2	/* packet came from wrong interface */
#define	IGMPMSG_BW_UPCALL	4	/* BW monitoring upcall		    */
	u_int8_t  im_mbz;		/* must be zero */
	u_int8_t  im_vif;		/* vif rec'd on */
	u_int8_t  unused3;
	struct	  in_addr im_src, im_dst;
};

int	ip_mrouter_set(struct socket *, int, struct mbuf *);
int	ip_mrouter_get(struct socket *, int, struct mbuf *);
int	mrt_ioctl(struct socket *, u_long, caddr_t);
int	mrt_sysctl_vif(void *, size_t *);
int	mrt_sysctl_mfc(void *, size_t *);
int	ip_mrouter_done(struct socket *);
void	vif_delete(struct ifnet *);

#endif /* _KERNEL */
#endif /* _NETINET_IP_MROUTE_H_ */
@


1.27
log
@Clean up multicast files from unused definitions and comments.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.26 2017/01/11 13:17:35 rzalamena Exp $	*/
d226 2
a227 2
int	ip_mrouter_set(struct socket *, int, struct mbuf **);
int	ip_mrouter_get(struct socket *, int, struct mbuf **);
@


1.26
log
@Remove mfc hash tables and use the OpenBSD routing table for multicast
routes. Beside the code simplification and removal, we also get to see
the multicast routes now in the route(8) utility.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.25 2017/01/06 14:01:19 rzalamena Exp $	*/
a20 1
#include <sys/queue.h>
a36 1

a46 1
#define	VIFM_SETALL(m)			((m) = 0xffffffff)
a130 57
 * Structure for installing or delivering an upcall if the
 * measured bandwidth is above or below a threshold.
 *
 * User programs (e.g. daemons) may have a need to know when the
 * bandwidth used by some data flow is above or below some threshold.
 * This interface allows the userland to specify the threshold (in
 * bytes and/or packets) and the measurement interval. Flows are
 * all packet with the same source and destination IP address.
 * At the moment the code is only used for multicast destinations
 * but there is nothing that prevents its use for unicast.
 *
 * The measurement interval cannot be shorter than some Tmin (currently, 3s).
 * The threshold is set in packets and/or bytes per_interval.
 *
 * Measurement works as follows:
 *
 * For >= measurements: 
 * The first packet marks the start of a measurement interval.
 * During an interval we count packets and bytes, and when we
 * pass the threshold we deliver an upcall and we are done.
 * The first packet after the end of the interval resets the
 * count and restarts the measurement.
 *
 * For <= measurement:
 * We start a timer to fire at the end of the interval, and
 * then for each incoming packet we count packets and bytes.
 * When the timer fires, we compare the value with the threshold,
 * schedule an upcall if we are below, and restart the measurement
 * (reschedule timer and zero counters).
 */

struct bw_data {
	struct timeval	b_time;
	u_int64_t	b_packets;
	u_int64_t	b_bytes;
};

struct bw_upcall {
	struct in_addr	bu_src;			/* source address            */
	struct in_addr	bu_dst;			/* destination address       */
	u_int32_t	bu_flags;		/* misc flags (see below)    */
#define	BW_UPCALL_UNIT_PACKETS   (1 << 0)	/* threshold (in packets)    */
#define	BW_UPCALL_UNIT_BYTES     (1 << 1)	/* threshold (in bytes)      */
#define	BW_UPCALL_GEQ            (1 << 2)	/* upcall if bw >= threshold */
#define	BW_UPCALL_LEQ            (1 << 3)	/* upcall if bw <= threshold */
#define	BW_UPCALL_DELETE_ALL     (1 << 4)	/* delete all upcalls for s,d*/
	struct bw_data	bu_threshold;		/* the bw threshold	     */
	struct bw_data	bu_measured;		/* the measured bw	     */
};

/* max. number of upcalls to deliver together */
#define	BW_UPCALLS_MAX				128
/* min. threshold time interval for bandwidth measurement */
#define	BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC	3
#define	BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC	0

/*
a224 12

/*
 * Argument structure used for pkt info. while upcall is made.
 */
struct rtdetq {
	struct	mbuf *m;		/* a copy of the packet */
	struct	ifnet *ifp;		/* interface pkt came in on */
	struct	rtdetq *next;
};

#define	MFCTBLSIZ	256
#define	MAX_UPQ		4		/* max. no of pkts in upcall Q */
@


1.25
log
@Remove the global viftable vector that holds the virtual interfaces
configuration and instead use ifnet to store the configuration and
counters. With this we can safely use multicast routing daemons on
multiple domains without vif id colisions.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.24 2016/12/22 11:04:44 rzalamena Exp $	*/
d235 3
a258 3
	LIST_ENTRY(mfc) mfc_hash;
	struct	 in_addr mfc_origin;	 	/* ip origin of mcasts */
	struct	 in_addr mfc_mcastgrp;  	/* multicast group associated */
a259 1
	u_int8_t mfc_ttls[MAXVIFS]; 		/* forwarding ttls on vifs */
d263 2
a264 4
	int	 mfc_expire;			/* time to clean entry up */
	struct	 timeval mfc_last_assert;	/* last time I sent an assert */
	struct	 rtdetq *mfc_stall;		/* pkts waiting for route */
	u_int8_t mfc_flags[MAXVIFS];		/* the MRT_MFC_FLAGS_* flags */
d266 1
@


1.24
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.23 2016/12/20 09:33:13 rzalamena Exp $	*/
d239 1
a243 1
	struct	  ifnet *v_ifp;		/* pointer to interface */
a305 1
void	reset_vif(struct vif *);
@


1.23
log
@Remove unused timeout that was never being set.

ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.22 2016/12/19 12:52:41 rzalamena Exp $	*/
d18 1
a18 2
 * and PIM-SMv2 and PIM-DM support, advanced API support,
 * bandwidth metering and signaling.
a34 1
#define	MRT_PIM			MRT_ASSERT /* enable PIM processing */
a55 1
#define	VIFF_REGISTER	0x4		/* used for PIM Register encap/decap */
a102 1
#define	MRT_MFC_FLAGS_BORDER_VIF	(1 << 1) /* border vif		     */
d105 1
a105 2
#define	MRT_MFC_FLAGS_ALL		(MRT_MFC_FLAGS_DISABLE_WRONGVIF |    \
					 MRT_MFC_FLAGS_BORDER_VIF)
a280 1
#define	IGMPMSG_WHOLEPKT	3	/* PIM pkt for user level encap.    */
@


1.22
log
@Kill unused function.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.21 2016/12/19 09:22:24 rzalamena Exp $	*/
a252 1
	struct	  timeout v_repq_ch;	/* for tbf_reprocess_q() */
@


1.21
log
@Extend the multicast sockets and multicast hash table support to multiple
domains. This is one step towards supporting to run more than one multicast
socket in different domains at the same time.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.20 2016/11/29 15:52:12 mpi Exp $	*/
a312 1
void	ip_mrouter_detach(struct ifnet *);
@


1.20
log
@Kill unused 'struct route'.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.19 2015/02/09 12:18:19 claudio Exp $	*/
d312 1
a312 1
int	ip_mrouter_done(void);
@


1.19
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mfc) and the
virtual interface table (vif). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.18 2014/08/14 08:22:38 mpi Exp $	*/
a252 1
	struct	  route v_route;	/* cached route if this is a tunnel */
@


1.18
log
@Kill MRT_{ADD,DEL}_BW_UPCALL interfaces and the bandwidth monitoring
code that comes with them.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.17 2013/10/27 20:57:39 deraadt Exp $	*/
d115 23
d311 2
@


1.17
log
@delete UPCALL_TIMING debug code from a the dark ages
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.16 2013/05/02 11:54:10 mpi Exp $	*/
a38 2
#define	MRT_ADD_BW_UPCALL	111	/* create bandwidth monitor */
#define	MRT_DEL_BW_UPCALL	112	/* delete bandwidth monitor */
a252 1
	struct bw_meter	*mfc_bw_meter;		/* list of bandwidth meters  */
a283 26

/*
 * Structure for measuring the bandwidth and sending an upcall if the
 * measured bandwidth is above or below a threshold.
 */
struct bw_meter {
	struct bw_meter	*bm_mfc_next;		/* next bw meter (same mfc)  */
	struct bw_meter	*bm_time_next;		/* next bw meter (same time) */
	uint32_t	bm_time_hash;		/* the time hash value       */
	struct mfc	*bm_mfc;		/* the corresponding mfc     */
	uint32_t	bm_flags;		/* misc flags (see below)    */
#define	BW_METER_UNIT_PACKETS	(1 << 0)	/* threshold (in packets)    */
#define	BW_METER_UNIT_BYTES	(1 << 1)	/* threshold (in bytes)      */
#define	BW_METER_GEQ		(1 << 2)	/* upcall if bw >= threshold */
#define	BW_METER_LEQ		(1 << 3)	/* upcall if bw <= threshold */
#define	BW_METER_USER_FLAGS 	(BW_METER_UNIT_PACKETS |		\
				 BW_METER_UNIT_BYTES |			\
				 BW_METER_GEQ |				\
				 BW_METER_LEQ)

#define	BW_METER_UPCALL_DELIVERED (1 << 24)	/* upcall was delivered      */

	struct bw_data	bm_threshold;		/* the upcall threshold	     */
	struct bw_data	bm_measured;		/* the measured bw	     */
	struct timeval	bm_start_time;		/* abs. time		     */
};
@


1.16
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.15 2009/07/13 19:14:29 michele Exp $	*/
a281 3
#ifdef UPCALL_TIMING
	struct	timeval t;		/* timestamp */
#endif /* UPCALL_TIMING */
@


1.15
log
@Get rid of the token bucket filter.
Traffic shaping code should not be inside routing code.
If you want to rate-limit use altq instead.

ok claudio@@ henning@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.14 2006/04/25 15:49:35 claudio Exp $	*/
a233 4
#ifdef RSVP_ISI
	int	  v_rsvp_on;		/* # RSVP listening on this vif */
	struct	  socket *v_rsvpd;	/* # RSVPD daemon */
#endif /* RSVP_ISI */
a323 10
#ifdef RSVP_ISI
int	ip_mforward(struct mbuf *, struct ifnet *, struct ip_moptions *);
int	legal_vif_num(int);
int	ip_rsvp_vif_init(struct socket *, struct mbuf *);
int	ip_rsvp_vif_done(struct socket *, struct mbuf *);
void	ip_rsvp_force_done(struct socket *);
void	rsvp_input(struct mbuf *, int, int);
#else
int	ip_mforward(struct mbuf *, struct ifnet *);
#endif /* RSVP_ISI */
@


1.14
log
@Remove virtual tunnel support from the mrouting code. The virtual tunnel
code breaks multicast on gif(4) interfaces and it is far better to configure
a real gif(4) tunnel instead of a multicast tunnel as the latter is almost
not manageable. OK norby@@, mblamer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.13 2006/03/30 14:28:28 norby Exp $	*/
d70 1
a70 1
	u_int32_t vifc_rate_limit;	/* max rate */
a222 6
	struct	  mbuf *tbf_q, **tbf_t;	/* packet queue */
	struct	  timeval tbf_last_pkt_t; /* arr. time of last pkt */
	u_int32_t tbf_n_tok;		/* no of tokens in bucket */
	u_int32_t tbf_q_len;		/* length of queue at this vif */
	u_int32_t tbf_max_q_len;	/* max. queue length */

a224 1
	u_int32_t v_rate_limit;		/* max rate */
a293 6

/*
 * Token bucket filter code
 */
#define	MAX_BKT_SIZE    10000		/* 10K bytes size */
#define	MAXQSIZE        10		/* max. no of pkts in token queue */
@


1.13
log
@fix a typo

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.12 2005/01/14 14:51:28 mcbride Exp $	*/
a350 2

void	ipip_mroute_input(struct mbuf *, ...);
@


1.12
log
@Add kernel support for Protocol Independant Multicast (PIM)
Information: http://netweb.usc.edu/pim/

From Pavlin Radoslavov <pavlin@@icir.org>

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.11 2004/11/24 01:25:42 mcbride Exp $	*/
d68 1
a68 1
	u_int8_t  vifc_flags;     	/* VIFF_ flags defined below */
@


1.11
log
@Multicast routing cleanup from Pavlin Radoslavov
- sync ip_mroute.c with NetBSD
- import some FreeBSD changes to MFC entry handling
- set im->im_vif correctly when sending IGMPMSG_WRONGVIF
- increment mrtstat.mrts_upcalls correctly
- return error from get_sg_cnt() if there is no matching forwarding entry

ok henning@@ brad@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.10 2004/08/24 20:31:16 brad Exp $	*/
d14 2
d18 2
d36 5
d60 1
d77 1
d87 88
d264 3
d277 4
a280 2
#define IGMPMSG_NOCACHE		1	/* no MFC in the kernel		    */
#define IGMPMSG_WRONGVIF	2	/* packet came from wrong interface */
d307 26
@


1.10
log
@Don't allow SIOCGET{VIF,SG}CNT from sockets other than the multicast router.

From NetBSD
Fixes PR 3825

ok mcbride@@ canacar@@ claudio@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ip_mroute.h,v 1.9 2002/06/09 16:26:10 itojun Exp $	*/
/*	$NetBSD: ip_mroute.h,v 1.10 1996/02/13 23:42:55 christos Exp $	*/
d19 1
d31 1
a31 1
#define	MRT_ASSERT		107	/* enable PIM assert processing */
a66 1
 * (mfcc_tos to be added at a future point)
a120 9
 * Token bucket filter at each vif
 */
struct tbf {
	u_int32_t last_pkt_t;		/* arr. time of last pkt */
	u_int32_t n_tok;		/* no of tokens in bucket */
	u_int32_t q_len;		/* length of queue at this vif */
};

/*
d124 6
a132 1
	struct	  tbf v_tbf;		/* token bucket structure at intf. */
d141 1
d175 2
a176 2
#define IGMPMSG_NOCACHE		1
#define IGMPMSG_WRONGVIF	2
d204 2
a205 11
/*
 * Queue structure at each vif
 */
struct pkt_queue {
	u_int32_t pkt_len;		/* length of packet in queue */
	struct	  mbuf *pkt_m;		/* pointer to packet mbuf */
	struct	  ip *pkt_ip;		/* pointer to ip header */
};

int	ip_mrouter_set(int, struct socket *, struct mbuf **);
int	ip_mrouter_get(int, struct socket *, struct mbuf **);
d208 1
d217 1
a217 1
void rsvp_input(struct mbuf *, int, int);
@


1.9
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.8 2002/03/14 01:27:11 millert Exp $	*/
d218 1
a218 1
int	mrt_ioctl(u_long, caddr_t);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.7 2001/06/09 07:03:42 angelos Exp $	*/
d74 1
a74 1
  
d85 1
a85 1
  
d116 1
a116 1
  
d153 1
a153 1
 * (A field for the type of service (mfc_tos) is to be added 
d200 1
a200 1
  
d202 1
a202 1
 * Token bucket filter code 
d206 1
a206 1
  
d215 1
a215 1
  
@


1.7
log
@Inclusion protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.6 2000/01/21 03:15:05 angelos Exp $	*/
d216 6
a221 6
int	ip_mrouter_set __P((int, struct socket *, struct mbuf **));
int	ip_mrouter_get __P((int, struct socket *, struct mbuf **));
int	mrt_ioctl __P((u_long, caddr_t));
int	ip_mrouter_done __P((void));
void	reset_vif __P((struct vif *));
void	vif_delete __P((struct ifnet *));
d223 6
a228 6
int	ip_mforward __P((struct mbuf *, struct ifnet *, struct ip_moptions *));
int	legal_vif_num __P((int));
int	ip_rsvp_vif_init __P((struct socket *, struct mbuf *));
int	ip_rsvp_vif_done __P((struct socket *, struct mbuf *));
void	ip_rsvp_force_done __P((struct socket *));
void rsvp_input __P((struct mbuf *, int, int));
d230 1
a230 1
int	ip_mforward __P((struct mbuf *, struct ifnet *));
d233 1
a233 1
void	ipip_mroute_input __P((struct mbuf *, ...));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.7 2001/06/09 07:03:42 angelos Exp $	*/
d216 6
a221 6
int	ip_mrouter_set(int, struct socket *, struct mbuf **);
int	ip_mrouter_get(int, struct socket *, struct mbuf **);
int	mrt_ioctl(u_long, caddr_t);
int	ip_mrouter_done(void);
void	reset_vif(struct vif *);
void	vif_delete(struct ifnet *);
d223 6
a228 6
int	ip_mforward(struct mbuf *, struct ifnet *, struct ip_moptions *);
int	legal_vif_num(int);
int	ip_rsvp_vif_init(struct socket *, struct mbuf *);
int	ip_rsvp_vif_done(struct socket *, struct mbuf *);
void	ip_rsvp_force_done(struct socket *);
void rsvp_input(struct mbuf *, int, int);
d230 1
a230 1
int	ip_mforward(struct mbuf *, struct ifnet *);
d233 1
a233 1
void	ipip_mroute_input(struct mbuf *, ...);
@


1.7.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.7.4.1 2002/06/11 03:31:36 art Exp $	*/
d74 1
a74 1

d85 1
a85 1

d116 1
a116 1

d153 1
a153 1
 * (A field for the type of service (mfc_tos) is to be added
d200 1
a200 1

d202 1
a202 1
 * Token bucket filter code
d206 1
a206 1

d215 1
a215 1

@


1.6
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.5 1999/12/08 06:50:20 itojun Exp $	*/
d4 3
a227 3
#if 0
void	rsvp_input __P((struct mbuf *, struct ifnet *));
#else
a228 1
#endif
d231 2
a232 1
#endif
d236 1
@


1.6.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.6 2000/01/21 03:15:05 angelos Exp $	*/
a3 3
#ifndef _NETINET_IP_MROUTE_H_
#define _NETINET_IP_MROUTE_H_

d225 3
d229 1
d232 1
a232 2
#endif /* RSVP_ISI */

a235 1
#endif /* _NETINET_IP_MROUTE_H_ */
@


1.6.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d216 6
a221 6
int	ip_mrouter_set(int, struct socket *, struct mbuf **);
int	ip_mrouter_get(int, struct socket *, struct mbuf **);
int	mrt_ioctl(u_long, caddr_t);
int	ip_mrouter_done(void);
void	reset_vif(struct vif *);
void	vif_delete(struct ifnet *);
d223 6
a228 6
int	ip_mforward(struct mbuf *, struct ifnet *, struct ip_moptions *);
int	legal_vif_num(int);
int	ip_rsvp_vif_init(struct socket *, struct mbuf *);
int	ip_rsvp_vif_done(struct socket *, struct mbuf *);
void	ip_rsvp_force_done(struct socket *);
void rsvp_input(struct mbuf *, int, int);
d230 1
a230 1
int	ip_mforward(struct mbuf *, struct ifnet *);
d233 1
a233 1
void	ipip_mroute_input(struct mbuf *, ...);
@


1.6.2.3
log
@Sync the SMP branch with 3.3
@
text
@d74 1
a74 1

d85 1
a85 1

d116 1
a116 1

d153 1
a153 1
 * (A field for the type of service (mfc_tos) is to be added
d200 1
a200 1

d202 1
a202 1
 * Token bucket filter code
d206 1
a206 1

d215 1
a215 1

@


1.5
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.4 1999/08/08 00:43:00 niklas Exp $	*/
d233 1
a233 1
void	ipip_input __P((struct mbuf *, ...));
@


1.4
log
@Support detaching of network interfaces.  Still work to do in ipf, and
other families than inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.3 1999/04/20 20:06:12 niklas Exp $	*/
d225 1
d227 3
@


1.3
log
@Merge MROUTING and IPSEC wrt handling of IP-in-IP tunnelled packets.
Fix a panic case in the MROUTING code too.  Drop M_TUNNEL support, nothing
ever uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_mroute.h,v 1.2 1996/03/03 22:30:40 niklas Exp $	*/
d213 6
a218 5
int ip_mrouter_set __P((int, struct socket *, struct mbuf **));
int ip_mrouter_get __P((int, struct socket *, struct mbuf **));
int mrt_ioctl __P((u_long, caddr_t));
int ip_mrouter_done __P((void));
void reset_vif __P((struct vif *));
d220 6
a225 6
int ip_mforward __P((struct mbuf *, struct ifnet *, struct ip_moptions *));
int legal_vif_num __P((int));
int ip_rsvp_vif_init __P((struct socket *, struct mbuf *));
int ip_rsvp_vif_done __P((struct socket *, struct mbuf *));
void ip_rsvp_force_done __P((struct socket *));
void rsvp_input __P((struct mbuf *, struct ifnet *));
d227 1
a227 1
int ip_mforward __P((struct mbuf *, struct ifnet *));
d229 1
a229 1
void ipip_input __P((struct mbuf *, ...));
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a211 1
  
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ip_mroute.h,v 1.9 1995/05/31 21:50:43 mycroft Exp $	*/
d214 16
a229 4
int	ip_mforward __P((struct mbuf *, struct ifnet *));
int	ip_mrouter_get __P((int, struct socket *, struct mbuf **));
int	ip_mrouter_set __P((int, struct socket *, struct mbuf **));
int	ip_mrouter_done __P((void));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
