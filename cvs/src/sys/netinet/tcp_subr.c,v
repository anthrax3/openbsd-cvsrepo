head	1.165;
access;
symbols
	OPENBSD_6_2_BASE:1.165
	OPENBSD_6_1:1.160.0.4
	OPENBSD_6_1_BASE:1.160
	OPENBSD_6_0:1.151.0.4
	OPENBSD_6_0_BASE:1.151
	OPENBSD_5_9:1.150.0.2
	OPENBSD_5_9_BASE:1.150
	OPENBSD_5_8:1.144.0.4
	OPENBSD_5_8_BASE:1.144
	OPENBSD_5_7:1.139.0.2
	OPENBSD_5_7_BASE:1.139
	OPENBSD_5_6:1.132.0.4
	OPENBSD_5_6_BASE:1.132
	OPENBSD_5_5:1.125.0.4
	OPENBSD_5_5_BASE:1.125
	OPENBSD_5_4:1.120.0.2
	OPENBSD_5_4_BASE:1.120
	OPENBSD_5_3:1.114.0.2
	OPENBSD_5_3_BASE:1.114
	OPENBSD_5_2:1.113.0.2
	OPENBSD_5_2_BASE:1.113
	OPENBSD_5_1_BASE:1.112
	OPENBSD_5_1:1.112.0.6
	OPENBSD_5_0:1.112.0.4
	OPENBSD_5_0_BASE:1.112
	OPENBSD_4_9:1.112.0.2
	OPENBSD_4_9_BASE:1.112
	OPENBSD_4_8:1.111.0.2
	OPENBSD_4_8_BASE:1.111
	OPENBSD_4_7:1.110.0.2
	OPENBSD_4_7_BASE:1.110
	OPENBSD_4_6:1.106.0.4
	OPENBSD_4_6_BASE:1.106
	OPENBSD_4_5:1.105.0.4
	OPENBSD_4_5_BASE:1.105
	OPENBSD_4_4:1.105.0.2
	OPENBSD_4_4_BASE:1.105
	OPENBSD_4_3:1.103.0.2
	OPENBSD_4_3_BASE:1.103
	OPENBSD_4_2:1.98.0.2
	OPENBSD_4_2_BASE:1.98
	OPENBSD_4_1:1.93.0.4
	OPENBSD_4_1_BASE:1.93
	OPENBSD_4_0:1.93.0.2
	OPENBSD_4_0_BASE:1.93
	OPENBSD_3_9:1.92.0.2
	OPENBSD_3_9_BASE:1.92
	OPENBSD_3_8:1.91.0.2
	OPENBSD_3_8_BASE:1.91
	OPENBSD_3_7:1.88.0.2
	OPENBSD_3_7_BASE:1.88
	OPENBSD_3_6:1.83.0.2
	OPENBSD_3_6_BASE:1.83
	SMP_SYNC_A:1.81
	SMP_SYNC_B:1.81
	OPENBSD_3_5:1.77.0.2
	OPENBSD_3_5_BASE:1.77
	OPENBSD_3_4:1.68.0.2
	OPENBSD_3_4_BASE:1.68
	UBC_SYNC_A:1.66
	OPENBSD_3_3:1.65.0.4
	OPENBSD_3_3_BASE:1.65
	OPENBSD_3_2:1.65.0.2
	OPENBSD_3_2_BASE:1.65
	OPENBSD_3_1:1.61.0.2
	OPENBSD_3_1_BASE:1.61
	UBC_SYNC_B:1.65
	UBC:1.52.0.4
	UBC_BASE:1.52
	OPENBSD_3_0:1.52.0.2
	OPENBSD_3_0_BASE:1.52
	OPENBSD_2_9_BASE:1.41
	OPENBSD_2_9:1.41.0.2
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.25.0.2
	OPENBSD_2_7_BASE:1.25
	SMP:1.23.0.2
	SMP_BASE:1.23
	kame_19991208:1.21
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.4
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.165
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.164;
commitid	gZMpLuRopIsWa0cT;

1.164
date	2017.05.18.11.38.07;	author mpi;	state Exp;
branches;
next	1.163;
commitid	mqqGdyckz9daEuFf;

1.163
date	2017.05.09.11.01.06;	author bluhm;	state Exp;
branches;
next	1.162;
commitid	V1FQLyp4dJYgLV7r;

1.162
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.161;
commitid	Gef6NNDxonzfVaq2;

1.161
date	2017.04.19.15.21.54;	author bluhm;	state Exp;
branches;
next	1.160;
commitid	86fZyVCZMRPZ29Fb;

1.160
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.159;
commitid	Hew5AYIxyEp5lNbI;

1.159
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.158;
commitid	wBlwxPiTlfo8m7xr;

1.158
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.157;
commitid	xP9gcRskiS0BKnO6;

1.157
date	2016.12.20.09.57.10;	author mpi;	state Exp;
branches;
next	1.156;
commitid	jNrk2ar2SD13DBhx;

1.156
date	2016.09.24.14.51.37;	author naddy;	state Exp;
branches;
next	1.155;
commitid	B9MFucENkVbjvRxm;

1.155
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.154;
commitid	RlO92XR575sygHqm;

1.154
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.153;
commitid	UqrCCAsrdk9XuY5o;

1.153
date	2016.09.03.14.34.13;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	fHiu9tHFVSDnxj0u;

1.152
date	2016.08.31.11.05.05;	author mpi;	state Exp;
branches;
next	1.151;
commitid	QNqLEcGCOZiHMKm4;

1.151
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.150;
commitid	Z6e4eqr6FuYFPnlL;

1.150
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.149;
commitid	xFxvBxiFybIsZNMc;

1.149
date	2015.10.02.09.51.54;	author tedu;	state Exp;
branches;
next	1.148;
commitid	JQIRr4uA6g5yunCt;

1.148
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.147;
commitid	Cr0DVA7exR1t2zXg;

1.147
date	2015.09.01.21.24.04;	author bluhm;	state Exp;
branches;
next	1.146;
commitid	RRi5waWu1LaKRicG;

1.146
date	2015.08.27.20.56.16;	author bluhm;	state Exp;
branches;
next	1.145;
commitid	Dj0fqkE649GFzkeR;

1.145
date	2015.08.24.15.37.03;	author bluhm;	state Exp;
branches;
next	1.144;
commitid	iKqcQwl3eIXo4smF;

1.144
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.143;
commitid	STtcOm1B3VSMXz2h;

1.143
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.142;
commitid	h7z8lokZ0dFyuWpg;

1.142
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.141;
commitid	hN5bFCE56DrAjl99;

1.141
date	2015.05.07.09.19.31;	author mikeb;	state Exp;
branches;
next	1.140;
commitid	y8PYDJru8lHW9Hqd;

1.140
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.139;
commitid	p4LJxGKbi0BU2cG6;

1.139
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.138;
commitid	zhW8jJrfVCoAthrR;

1.138
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.137;
commitid	Z1vcFtHO8wRH0yRt;

1.137
date	2014.11.16.17.40.17;	author tedu;	state Exp;
branches;
next	1.136;
commitid	uTRYYdKAFgGuFA8c;

1.136
date	2014.11.06.12.05.32;	author mpi;	state Exp;
branches;
next	1.135;
commitid	Nn2mO6f9tWQWBuNw;

1.135
date	2014.11.06.07.41.32;	author dlg;	state Exp;
branches;
next	1.134;
commitid	tcgzbsznvnTXrLkN;

1.134
date	2014.11.04.15.24.40;	author mpi;	state Exp;
branches;
next	1.133;
commitid	7WMzGcppcCD2uLp0;

1.133
date	2014.10.20.03.43.40;	author tedu;	state Exp;
branches;
next	1.132;
commitid	7lHwfjBb54DG13MD;

1.132
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.131;
commitid	DQakU8LLWV6Iwx84;

1.131
date	2014.07.12.21.06.34;	author yasuoka;	state Exp;
branches;
next	1.130;
commitid	LARYP0a27ik2w0nd;

1.130
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.129;
commitid	B4dZSbxas1X1IpXI;

1.129
date	2014.04.21.12.22.26;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2014.04.18.15.14.25;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2013.10.23.15.12.42;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2013.10.21.08.42.24;	author phessler;	state Exp;
branches;
next	1.122;

1.122
date	2013.10.20.11.03.01;	author phessler;	state Exp;
branches;
next	1.121;

1.121
date	2013.10.19.10.38.55;	author henning;	state Exp;
branches;
next	1.120;

1.120
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.119;

1.119
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.118;

1.118
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.117;

1.117
date	2013.04.02.18.27.47;	author bluhm;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.28.23.10.06;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.114;

1.114
date	2012.12.28.17.52.06;	author gsoares;	state Exp;
branches;
next	1.113;

1.113
date	2012.03.10.12.03.29;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.110;

1.110
date	2010.01.15.18.20.23;	author chl;	state Exp;
branches;
next	1.109;

1.109
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.108;

1.108
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.107;

1.107
date	2009.08.10.10.13.43;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2008.06.09.07.07.17;	author djm;	state Exp;
branches;
next	1.104;

1.104
date	2008.05.06.08.47.36;	author markus;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.20.14.23.31;	author markus;	state Exp;
branches;
next	1.102;

1.102
date	2008.02.20.11.24.03;	author markus;	state Exp;
branches;
next	1.101;

1.101
date	2007.11.27.17.23.23;	author deraadt;	state Exp;
branches;
next	1.100;

1.100
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.99;

1.99
date	2007.09.01.18.49.28;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.25.12.17.43;	author markus;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2007.06.15.18.23.06;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.95;

1.95
date	2007.05.09.14.28.47;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2007.05.08.18.46.56;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches
	1.93.4.1;
next	1.92;

1.92
date	2005.09.28.15.20.12;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2005.08.02.11.05.44;	author markus;	state Exp;
branches;
next	1.90;

1.90
date	2005.06.30.08.51.31;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.24.00.02.37;	author fgont;	state Exp;
branches;
next	1.88;

1.88
date	2005.03.04.13.21.42;	author markus;	state Exp;
branches;
next	1.87;

1.87
date	2005.02.27.13.22.56;	author markus;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.10.23.53.49;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2004.11.25.15.32.08;	author markus;	state Exp;
branches;
next	1.84;

1.84
date	2004.10.28.19.22.52;	author mcbride;	state Exp;
branches;
next	1.83;

1.83
date	2004.08.10.20.04.55;	author markus;	state Exp;
branches
	1.83.2.1;
next	1.82;

1.82
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.08.19.47.24;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2004.05.07.14.42.27;	author millert;	state Exp;
branches;
next	1.79;

1.79
date	2004.05.04.22.50.18;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.26.18.12.25;	author frantzen;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.02.12.51.12;	author markus;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2004.02.27.16.44.45;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.31.19.40.10;	author markus;	state Exp;
branches;
next	1.74;

1.74
date	2004.01.29.11.55.28;	author markus;	state Exp;
branches;
next	1.73;

1.73
date	2004.01.09.12.22.30;	author markus;	state Exp;
branches;
next	1.72;

1.72
date	2004.01.06.17.38.13;	author markus;	state Exp;
branches;
next	1.71;

1.71
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2003.11.04.21.43.16;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2003.06.02.23.28.14;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.12.00.48.52;	author jason;	state Exp;
branches;
next	1.65;

1.65
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches
	1.65.4.1;
next	1.64;

1.64
date	2002.06.09.16.26.11;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.07.16.18.02;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.61;

1.61
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.08.03.49.58;	author provos;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.02.00.44.52;	author provos;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.01.22.29.29;	author provos;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.24.22.42.49;	author provos;	state Exp;
branches;
next	1.56;

1.56
date	2002.01.23.00.39.48;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.15.19.18.01;	author provos;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.15.16.59.08;	author provos;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.14.03.11.55;	author provos;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.21.09.26.06;	author itojun;	state Exp;
branches
	1.52.4.1;
next	1.51;

1.51
date	2001.07.18.00.18.51;	author marc;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.03.04.26.37;	author angelos;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.26.06.56.41;	author aaron;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.25.01.59.29;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.23.19.02.53;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.08.03.53.46;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.05.02.31.36;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.04.18.16.43;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.05.31.20.36.47;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.05.01.18.31.35;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.06.04.42.09;	author csapuntz;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.14.19.21.33;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.16.16.00.54;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.21.00.54.10;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2000.12.13.09.47.08;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.11.08.04.55;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2000.10.13.17.58.36;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.10.15.16.02;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.25.09.41.03;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.20.17.00.23;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.18.22.06.38;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.11.19.18.17;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.11.16.53.22;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.05.22.51.10;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.26.22.45.09;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2000.06.03.13.04.39;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2000.03.21.04.53.13;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.29.05.25.53;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	99.12.29.20.27.55;	author mickey;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	99.12.21.14.09.48;	author provos;	state Exp;
branches;
next	1.21;

1.21
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	99.10.29.02.10.02;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	99.08.27.08.15.50;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.07.06.20.17.53;	author cmetz;	state Exp;
branches;
next	1.17;

1.17
date	99.07.06.18.01.55;	author cmetz;	state Exp;
branches;
next	1.16;

1.16
date	99.07.02.21.22.14;	author cmetz;	state Exp;
branches;
next	1.15;

1.15
date	99.07.02.20.39.08;	author cmetz;	state Exp;
branches;
next	1.14;

1.14
date	99.02.17.00.14.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.01.11.02.01.36;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.11.17.19.23.02;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.10.28.21.34.33;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	98.05.18.21.11.07;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.08.26.20.02.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.02.05.15.48.25;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.29.22.01.50;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.07.29.06.22.14;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.05.15.09.32.01;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.05.15.09.12.11;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.22.30.47;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.50.49;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.12;	author deraadt;	state Exp;
branches;
next	;

1.23.2.1
date	2000.03.02.07.04.43;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2000.03.24.09.09.38;	author niklas;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2001.05.14.22.40.15;	author niklas;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2001.07.04.10.55.08;	author niklas;	state Exp;
branches;
next	1.23.2.5;

1.23.2.5
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.23.2.6;

1.23.2.6
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.23.2.7;

1.23.2.7
date	2002.03.28.14.56.45;	author niklas;	state Exp;
branches;
next	1.23.2.8;

1.23.2.8
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.23.2.9;

1.23.2.9
date	2003.05.13.19.36.17;	author ho;	state Exp;
branches;
next	1.23.2.10;

1.23.2.10
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.23.2.11;

1.23.2.11
date	2004.02.19.10.57.24;	author niklas;	state Exp;
branches;
next	1.23.2.12;

1.23.2.12
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.23.2.13;

1.23.2.13
date	2004.06.08.21.07.29;	author niklas;	state Exp;
branches;
next	;

1.52.4.1
date	2002.01.31.22.55.45;	author niklas;	state Exp;
branches;
next	1.52.4.2;

1.52.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.52.4.3;

1.52.4.3
date	2002.10.29.00.36.47;	author art;	state Exp;
branches;
next	1.52.4.4;

1.52.4.4
date	2003.05.19.22.40.41;	author tedu;	state Exp;
branches;
next	;

1.65.4.1
date	2004.03.03.02.35.59;	author brad;	state Exp;
branches;
next	1.65.4.2;

1.65.4.2
date	2004.03.03.08.40.07;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2004.03.03.02.35.26;	author brad;	state Exp;
branches;
next	1.68.2.2;

1.68.2.2
date	2004.03.03.08.37.05;	author brad;	state Exp;
branches;
next	1.68.2.3;

1.68.2.3
date	2004.08.20.22.40.18;	author brad;	state Exp;
branches;
next	;

1.77.2.1
date	2004.08.20.22.41.33;	author brad;	state Exp;
branches;
next	1.77.2.2;

1.77.2.2
date	2005.03.20.23.44.06;	author brad;	state Exp;
branches;
next	;

1.83.2.1
date	2005.03.20.23.36.10;	author brad;	state Exp;
branches;
next	;

1.93.4.1
date	2008.02.21.17.34.26;	author henning;	state Exp;
branches;
next	;

1.98.2.1
date	2008.02.21.15.53.16;	author henning;	state Exp;
branches;
next	;


desc
@@


1.165
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@/*	$OpenBSD: tcp_subr.c,v 1.164 2017/05/18 11:38:07 mpi Exp $	*/
/*	$NetBSD: tcp_subr.c,v 1.22 1996/02/13 23:44:00 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/timeout.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/pool.h>

#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>

#ifdef INET6
#include <netinet6/ip6protosw.h>
#endif /* INET6 */

#include <crypto/md5.h>
#include <crypto/sha2.h>

/* patchable/settable parameters for tcp */
int	tcp_mssdflt = TCP_MSS;
int	tcp_rttdflt = TCPTV_SRTTDFLT / PR_SLOWHZ;

/* values controllable via sysctl */
int	tcp_do_rfc1323 = 1;
#ifdef TCP_SACK
int	tcp_do_sack = 1;	/* RFC 2018 selective ACKs */
#endif
int	tcp_ack_on_push = 0;	/* set to enable immediate ACK-on-PUSH */
#ifdef TCP_ECN
int	tcp_do_ecn = 0;		/* RFC3168 ECN enabled/disabled? */
#endif
int	tcp_do_rfc3390 = 2;	/* Increase TCP's Initial Window to 10*mss */

u_int32_t	tcp_now = 1;

#ifndef TCB_INITIAL_HASH_SIZE
#define	TCB_INITIAL_HASH_SIZE	128
#endif

int tcp_reass_limit = NMBCLUSTERS / 8; /* hardlimit for tcpqe_pool */
#ifdef TCP_SACK
int tcp_sackhole_limit = 32*1024; /* hardlimit for sackhl_pool */
#endif

struct pool tcpcb_pool;
struct pool tcpqe_pool;
#ifdef TCP_SACK
struct pool sackhl_pool;
#endif

struct cpumem *tcpcounters;		/* tcp statistics */
tcp_seq  tcp_iss;

/*
 * Tcp initialization
 */
void
tcp_init(void)
{
	tcp_iss = 1;		/* wrong */
	pool_init(&tcpcb_pool, sizeof(struct tcpcb), 0, IPL_SOFTNET, 0,
	    "tcpcb", NULL);
	pool_init(&tcpqe_pool, sizeof(struct tcpqent), 0, IPL_SOFTNET, 0,
	    "tcpqe", NULL);
	pool_sethardlimit(&tcpqe_pool, tcp_reass_limit, NULL, 0);
#ifdef TCP_SACK
	pool_init(&sackhl_pool, sizeof(struct sackhole), 0, IPL_SOFTNET, 0,
	    "sackhl", NULL);
	pool_sethardlimit(&sackhl_pool, tcp_sackhole_limit, NULL, 0);
#endif /* TCP_SACK */
	in_pcbinit(&tcbtable, TCB_INITIAL_HASH_SIZE);
	tcpcounters = counters_alloc(tcps_ncounters);

#ifdef INET6
	/*
	 * Since sizeof(struct ip6_hdr) > sizeof(struct ip), we
	 * do max length checks/computations only on the former.
	 */
	if (max_protohdr < (sizeof(struct ip6_hdr) + sizeof(struct tcphdr)))
		max_protohdr = (sizeof(struct ip6_hdr) + sizeof(struct tcphdr));
	if ((max_linkhdr + sizeof(struct ip6_hdr) + sizeof(struct tcphdr)) >
	    MHLEN)
		panic("tcp_init");

	icmp6_mtudisc_callback_register(tcp6_mtudisc_callback);
#endif /* INET6 */

	/* Initialize the compressed state engine. */
	syn_cache_init();

	/* Initialize timer state. */
	tcp_timer_init();
}

/*
 * Create template to be used to send tcp packets on a connection.
 * Call after host entry created, allocates an mbuf and fills
 * in a skeletal tcp/ip header, minimizing the amount of work
 * necessary when the connection is used.
 *
 * To support IPv6 in addition to IPv4 and considering that the sizes of
 * the IPv4 and IPv6 headers are not the same, we now use a separate pointer
 * for the TCP header.  Also, we made the former tcpiphdr header pointer
 * into just an IP overlay pointer, with casting as appropriate for v6. rja
 */
struct mbuf *
tcp_template(struct tcpcb *tp)
{
	struct inpcb *inp = tp->t_inpcb;
	struct mbuf *m;
	struct tcphdr *th;

	if ((m = tp->t_template) == 0) {
		m = m_get(M_DONTWAIT, MT_HEADER);
		if (m == NULL)
			return (0);

		switch (tp->pf) {
		case 0:	/*default to PF_INET*/
		case AF_INET:
			m->m_len = sizeof(struct ip);
			break;
#ifdef INET6
		case AF_INET6:
			m->m_len = sizeof(struct ip6_hdr);
			break;
#endif /* INET6 */
		}
		m->m_len += sizeof (struct tcphdr);

		/*
		 * The link header, network header, TCP header, and TCP options
		 * all must fit in this mbuf. For now, assume the worst case of
		 * TCP options size. Eventually, compute this from tp flags.
		 */
		if (m->m_len + MAX_TCPOPTLEN + max_linkhdr >= MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				return (0);
			}
		}
	}

	switch(tp->pf) {
	case AF_INET:
		{
			struct ipovly *ipovly;

			ipovly = mtod(m, struct ipovly *);

			bzero(ipovly->ih_x1, sizeof ipovly->ih_x1);
			ipovly->ih_pr = IPPROTO_TCP;
			ipovly->ih_len = htons(sizeof (struct tcphdr));
			ipovly->ih_src = inp->inp_laddr;
			ipovly->ih_dst = inp->inp_faddr;

			th = (struct tcphdr *)(mtod(m, caddr_t) +
				sizeof(struct ip));
		}
		break;
#ifdef INET6
	case AF_INET6:
		{
			struct ip6_hdr *ip6;

			ip6 = mtod(m, struct ip6_hdr *);

			ip6->ip6_src = inp->inp_laddr6;
			ip6->ip6_dst = inp->inp_faddr6;
			ip6->ip6_flow = htonl(0x60000000) |
			    (inp->inp_flowinfo & IPV6_FLOWLABEL_MASK);

			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_plen = htons(sizeof(struct tcphdr)); /*XXX*/
			ip6->ip6_hlim = in6_selecthlim(inp);	/*XXX*/

			th = (struct tcphdr *)(mtod(m, caddr_t) +
				sizeof(struct ip6_hdr));
		}
		break;
#endif /* INET6 */
	}

	th->th_sport = inp->inp_lport;
	th->th_dport = inp->inp_fport;
	th->th_seq = 0;
	th->th_ack = 0;
	th->th_x2  = 0;
	th->th_off = 5;
	th->th_flags = 0;
	th->th_win = 0;
	th->th_urp = 0;
	th->th_sum = 0;
	return (m);
}

/*
 * Send a single message to the TCP at address specified by
 * the given TCP/IP header.  If m == 0, then we make a copy
 * of the tcpiphdr at ti and send directly to the addressed host.
 * This is used to force keep alive messages out using the TCP
 * template for a connection tp->t_template.  If flags are given
 * then we send a message back to the TCP which originated the
 * segment ti, and discard the mbuf containing it and any other
 * attached mbufs.
 *
 * In any case the ack and sequence number of the transmitted
 * segment are as specified by the parameters.
 */
void
tcp_respond(struct tcpcb *tp, caddr_t template, struct tcphdr *th0,
    tcp_seq ack, tcp_seq seq, int flags, u_int rtableid)
{
	int tlen;
	int win = 0;
	struct mbuf *m = NULL;
	struct tcphdr *th;
	struct ip *ip;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif
	int af;		/* af on wire */

	if (tp) {
		struct socket *so = tp->t_inpcb->inp_socket;
		win = sbspace(so, &so->so_rcv);
		/*
		 * If this is called with an unconnected
		 * socket/tp/pcb (tp->pf is 0), we lose.
		 */
		af = tp->pf;
	} else
		af = (((struct ip *)template)->ip_v == 6) ? AF_INET6 : AF_INET;

	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return;
	m->m_data += max_linkhdr;
	tlen = 0;

#define xchg(a,b,type) do { type t; t=a; a=b; b=t; } while (0)
	switch (af) {
#ifdef INET6
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		th = (struct tcphdr *)(ip6 + 1);
		tlen = sizeof(*ip6) + sizeof(*th);
		if (th0) {
			bcopy(template, ip6, sizeof(*ip6));
			bcopy(th0, th, sizeof(*th));
			xchg(ip6->ip6_dst, ip6->ip6_src, struct in6_addr);
		} else {
			bcopy(template, ip6, tlen);
		}
		break;
#endif /* INET6 */
	case AF_INET:
		ip = mtod(m, struct ip *);
		th = (struct tcphdr *)(ip + 1);
		tlen = sizeof(*ip) + sizeof(*th);
		if (th0) {
			bcopy(template, ip, sizeof(*ip));
			bcopy(th0, th, sizeof(*th));
			xchg(ip->ip_dst.s_addr, ip->ip_src.s_addr, u_int32_t);
		} else {
			bcopy(template, ip, tlen);
		}
		break;
	}
	if (th0)
		xchg(th->th_dport, th->th_sport, u_int16_t);
	else
		flags = TH_ACK;
#undef xchg

	th->th_seq = htonl(seq);
	th->th_ack = htonl(ack);
	th->th_x2 = 0;
	th->th_off = sizeof (struct tcphdr) >> 2;
	th->th_flags = flags;
	if (tp)
		win >>= tp->rcv_scale;
	if (win > TCP_MAXWIN)
		win = TCP_MAXWIN;
	th->th_win = htons((u_int16_t)win);
	th->th_urp = 0;

	if (tp && (tp->t_flags & (TF_REQ_TSTMP|TF_NOOPT)) == TF_REQ_TSTMP &&
	    (flags & TH_RST) == 0 && (tp->t_flags & TF_RCVD_TSTMP)) {
		u_int32_t *lp = (u_int32_t *)(th + 1);
		/* Form timestamp option as shown in appendix A of RFC 1323. */
		*lp++ = htonl(TCPOPT_TSTAMP_HDR);
		*lp++ = htonl(tcp_now + tp->ts_modulate);
		*lp   = htonl(tp->ts_recent);
		tlen += TCPOLEN_TSTAMP_APPA;
		th->th_off = (sizeof(struct tcphdr) + TCPOLEN_TSTAMP_APPA) >> 2;
	}

	m->m_len = tlen;
	m->m_pkthdr.len = tlen;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;

	/* force routing table */
	if (tp)
		m->m_pkthdr.ph_rtableid = tp->t_inpcb->inp_rtableid;
	else
		m->m_pkthdr.ph_rtableid = rtableid;

	switch (af) {
#ifdef INET6
	case AF_INET6:
		ip6->ip6_flow = htonl(0x60000000);
		ip6->ip6_nxt  = IPPROTO_TCP;
		ip6->ip6_hlim = in6_selecthlim(tp ? tp->t_inpcb : NULL);	/*XXX*/
		ip6->ip6_plen = tlen - sizeof(struct ip6_hdr);
		ip6->ip6_plen = htons(ip6->ip6_plen);
		ip6_output(m, tp ? tp->t_inpcb->inp_outputopts6 : NULL,
		    tp ? &tp->t_inpcb->inp_route6 : NULL,
		    0, NULL,
		    tp ? tp->t_inpcb : NULL);
		break;
#endif /* INET6 */
	case AF_INET:
		ip->ip_len = htons(tlen);
		ip->ip_ttl = ip_defttl;
		ip->ip_tos = 0;
		ip_output(m, NULL,
		    tp ? &tp->t_inpcb->inp_route : NULL,
		    ip_mtudisc ? IP_MTUDISC : 0, NULL,
		    tp ? tp->t_inpcb : NULL, 0);
		break;
	}
}

/*
 * Create a new TCP control block, making an
 * empty reassembly queue and hooking it to the argument
 * protocol control block.
 */
struct tcpcb *
tcp_newtcpcb(struct inpcb *inp)
{
	struct tcpcb *tp;
	int i;

	tp = pool_get(&tcpcb_pool, PR_NOWAIT|PR_ZERO);
	if (tp == NULL)
		return (NULL);
	TAILQ_INIT(&tp->t_segq);
	tp->t_maxseg = tcp_mssdflt;
	tp->t_maxopd = 0;

	TCP_INIT_DELACK(tp);
	for (i = 0; i < TCPT_NTIMERS; i++)
		TCP_TIMER_INIT(tp, i);
	timeout_set(&tp->t_reap_to, tcp_reaper, tp);

#ifdef TCP_SACK
	tp->sack_enable = tcp_do_sack;
#endif
	tp->t_flags = tcp_do_rfc1323 ? (TF_REQ_SCALE|TF_REQ_TSTMP) : 0;
	tp->t_inpcb = inp;
	/*
	 * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
	 * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
	 * reasonable initial retransmit time.
	 */
	tp->t_srtt = TCPTV_SRTTBASE;
	tp->t_rttvar = tcp_rttdflt * PR_SLOWHZ <<
	    (TCP_RTTVAR_SHIFT + TCP_RTT_BASE_SHIFT - 1);
	tp->t_rttmin = TCPTV_MIN;
	TCPT_RANGESET(tp->t_rxtcur, TCP_REXMTVAL(tp),
	    TCPTV_MIN, TCPTV_REXMTMAX);
	tp->snd_cwnd = TCP_MAXWIN << TCP_MAX_WINSHIFT;
	tp->snd_ssthresh = TCP_MAXWIN << TCP_MAX_WINSHIFT;
	
	tp->t_pmtud_mtu_sent = 0;
	tp->t_pmtud_mss_acked = 0;
	
#ifdef INET6
	/* we disallow IPv4 mapped address completely. */
	if ((inp->inp_flags & INP_IPV6) == 0)
		tp->pf = PF_INET;
	else
		tp->pf = PF_INET6;
#else
	tp->pf = PF_INET;
#endif

#ifdef INET6
	if (inp->inp_flags & INP_IPV6)
		inp->inp_ipv6.ip6_hlim = ip6_defhlim;
	else
#endif /* INET6 */
		inp->inp_ip.ip_ttl = ip_defttl;

	inp->inp_ppcb = (caddr_t)tp;
	return (tp);
}

/*
 * Drop a TCP connection, reporting
 * the specified error.  If connection is synchronized,
 * then send a RST to peer.
 */
struct tcpcb *
tcp_drop(struct tcpcb *tp, int errno)
{
	struct socket *so = tp->t_inpcb->inp_socket;

	if (TCPS_HAVERCVDSYN(tp->t_state)) {
		tp->t_state = TCPS_CLOSED;
		(void) tcp_output(tp);
		tcpstat_inc(tcps_drops);
	} else
		tcpstat_inc(tcps_conndrops);
	if (errno == ETIMEDOUT && tp->t_softerror)
		errno = tp->t_softerror;
	so->so_error = errno;
	return (tcp_close(tp));
}

/*
 * Close a TCP control block:
 *	discard all space held by the tcp
 *	discard internet protocol block
 *	wake up any sleepers
 */
struct tcpcb *
tcp_close(struct tcpcb *tp)
{
	struct inpcb *inp = tp->t_inpcb;
	struct socket *so = inp->inp_socket;
#ifdef TCP_SACK
	struct sackhole *p, *q;
#endif

	/* free the reassembly queue, if any */
	tcp_freeq(tp);

	tcp_canceltimers(tp);
	TCP_CLEAR_DELACK(tp);
	syn_cache_cleanup(tp);

#ifdef TCP_SACK
	/* Free SACK holes. */
	q = p = tp->snd_holes;
	while (p != 0) {
		q = p->next;
		pool_put(&sackhl_pool, p);
		p = q;
	}
#endif
	m_free(tp->t_template);

	tp->t_flags |= TF_DEAD;
	timeout_add(&tp->t_reap_to, 0);

	inp->inp_ppcb = 0;
	soisdisconnected(so);
	in_pcbdetach(inp);
	return (NULL);
}

void
tcp_reaper(void *arg)
{
	struct tcpcb *tp = arg;

	pool_put(&tcpcb_pool, tp);
	tcpstat_inc(tcps_closed);
}

int
tcp_freeq(struct tcpcb *tp)
{
	struct tcpqent *qe;
	int rv = 0;

	while ((qe = TAILQ_FIRST(&tp->t_segq)) != NULL) {
		TAILQ_REMOVE(&tp->t_segq, qe, tcpqe_q);
		m_freem(qe->tcpqe_m);
		pool_put(&tcpqe_pool, qe);
		rv = 1;
	}
	return (rv);
}

/*
 * Compute proper scaling value for receiver window from buffer space
 */

void
tcp_rscale(struct tcpcb *tp, u_long hiwat)
{
	tp->request_r_scale = 0;
	while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
	       TCP_MAXWIN << tp->request_r_scale < hiwat)
		tp->request_r_scale++;
}

/*
 * Notify a tcp user of an asynchronous error;
 * store error as soft error, but wake up user
 * (for now, won't do anything until can select for soft error).
 */
void
tcp_notify(struct inpcb *inp, int error)
{
	struct tcpcb *tp = intotcpcb(inp);
	struct socket *so = inp->inp_socket;

	/*
	 * Ignore some errors if we are hooked up.
	 * If connection hasn't completed, has retransmitted several times,
	 * and receives a second error, give up now.  This is better
	 * than waiting a long time to establish a connection that
	 * can never complete.
	 */
	if (tp->t_state == TCPS_ESTABLISHED &&
	     (error == EHOSTUNREACH || error == ENETUNREACH ||
	      error == EHOSTDOWN)) {
		return;
	} else if (TCPS_HAVEESTABLISHED(tp->t_state) == 0 &&
	    tp->t_rxtshift > 3 && tp->t_softerror)
		so->so_error = error;
	else
		tp->t_softerror = error;
	wakeup((caddr_t) &so->so_timeo);
	sorwakeup(so);
	sowwakeup(so);
}

#ifdef INET6
void
tcp6_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *d)
{
	struct tcphdr th;
	struct tcpcb *tp;
	void (*notify)(struct inpcb *, int) = tcp_notify;
	struct ip6_hdr *ip6;
	const struct sockaddr_in6 *sa6_src = NULL;
	struct sockaddr_in6 *sa6 = satosin6(sa);
	struct inpcb *inp;
	struct mbuf *m;
	tcp_seq seq;
	int off;
	struct {
		u_int16_t th_sport;
		u_int16_t th_dport;
		u_int32_t th_seq;
	} *thp;

	CTASSERT(sizeof(*thp) <= sizeof(th));
	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6) ||
	    IN6_IS_ADDR_UNSPECIFIED(&sa6->sin6_addr) ||
	    IN6_IS_ADDR_V4MAPPED(&sa6->sin6_addr))
		return;
	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	else if (cmd == PRC_QUENCH) {
		/* 
		 * Don't honor ICMP Source Quench messages meant for
		 * TCP connections.
		 */
		/* XXX there's no PRC_QUENCH in IPv6 */
		return;
	} else if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_MSGSIZE)
		; /* special code is present, see below */
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
		m = ip6cp->ip6c_m;
		ip6 = ip6cp->ip6c_ip6;
		off = ip6cp->ip6c_off;
		sa6_src = ip6cp->ip6c_src;
	} else {
		m = NULL;
		ip6 = NULL;
		sa6_src = &sa6_any;
	}

	if (ip6) {
		/*
		 * XXX: We assume that when ip6 is non NULL,
		 * M and OFF are valid.
		 */

		/* check if we can safely examine src and dst ports */
		if (m->m_pkthdr.len < off + sizeof(*thp))
			return;

		bzero(&th, sizeof(th));
		m_copydata(m, off, sizeof(*thp), (caddr_t)&th);

		/*
		 * Check to see if we have a valid TCP connection
		 * corresponding to the address in the ICMPv6 message
		 * payload.
		 */
		inp = in6_pcbhashlookup(&tcbtable, &sa6->sin6_addr,
		    th.th_dport, &sa6_src->sin6_addr, th.th_sport, rdomain);
		if (cmd == PRC_MSGSIZE) {
			/*
			 * Depending on the value of "valid" and routing table
			 * size (mtudisc_{hi,lo}wat), we will:
			 * - recalcurate the new MTU and create the
			 *   corresponding routing entry, or
			 * - ignore the MTU change notification.
			 */
			icmp6_mtudisc_update((struct ip6ctlparam *)d, inp != NULL);
			return;
		}
		if (inp) {
			seq = ntohl(th.th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, inet6ctlerrmap[cmd]);
		} else if (inet6ctlerrmap[cmd] == EHOSTUNREACH ||
		    inet6ctlerrmap[cmd] == ENETUNREACH ||
		    inet6ctlerrmap[cmd] == EHOSTDOWN)
			syn_cache_unreach((struct sockaddr *)sa6_src,
			    sa, &th, rdomain);
	} else {
		(void) in6_pcbnotify(&tcbtable, sa6, 0,
		    sa6_src, 0, rdomain, cmd, NULL, notify);
	}
}
#endif

void
tcp_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *v)
{
	struct ip *ip = v;
	struct tcphdr *th;
	struct tcpcb *tp;
	struct inpcb *inp;
	struct in_addr faddr;
	tcp_seq seq;
	u_int mtu;
	void (*notify)(struct inpcb *, int) = tcp_notify;
	int errno;

	if (sa->sa_family != AF_INET)
		return;
	faddr = satosin(sa)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	errno = inetctlerrmap[cmd];
	if (cmd == PRC_QUENCH)
		/* 
		 * Don't honor ICMP Source Quench messages meant for
		 * TCP connections.
		 */
		return;
	else if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, ip = 0;
	else if (cmd == PRC_MSGSIZE && ip_mtudisc && ip) {
		/*
		 * Verify that the packet in the icmp payload refers
		 * to an existing TCP connection.
		 */
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		seq = ntohl(th->th_seq);
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport,
		    rdomain);
		if (inp && (tp = intotcpcb(inp)) &&
		    SEQ_GEQ(seq, tp->snd_una) &&
		    SEQ_LT(seq, tp->snd_max)) {
			struct icmp *icp;
			icp = (struct icmp *)((caddr_t)ip -
					      offsetof(struct icmp, icmp_ip));

			/* 
			 * If the ICMP message advertises a Next-Hop MTU
			 * equal or larger than the maximum packet size we have
			 * ever sent, drop the message.
			 */
			mtu = (u_int)ntohs(icp->icmp_nextmtu);
			if (mtu >= tp->t_pmtud_mtu_sent)
				return;
			if (mtu >= tcp_hdrsz(tp) + tp->t_pmtud_mss_acked) {
				/* 
				 * Calculate new MTU, and create corresponding
				 * route (traditional PMTUD).
				 */
				tp->t_flags &= ~TF_PMTUD_PEND;
				icmp_mtudisc(icp, inp->inp_rtableid);
			} else {
				/*
				 * Record the information got in the ICMP
				 * message; act on it later.
				 * If we had already recorded an ICMP message,
				 * replace the old one only if the new message
				 * refers to an older TCP segment
				 */
				if (tp->t_flags & TF_PMTUD_PEND) {
					if (SEQ_LT(tp->t_pmtud_th_seq, seq))
						return;
				} else
					tp->t_flags |= TF_PMTUD_PEND;
				tp->t_pmtud_th_seq = seq;
				tp->t_pmtud_nextmtu = icp->icmp_nextmtu;
				tp->t_pmtud_ip_len = icp->icmp_ip.ip_len;
				tp->t_pmtud_ip_hl = icp->icmp_ip.ip_hl;
				return;
			}
		} else {
			/* ignore if we don't have a matching connection */
			return;
		}
		notify = tcp_mtudisc, ip = 0;
	} else if (cmd == PRC_MTUINC)
		notify = tcp_mtudisc_increase, ip = 0;
	else if (cmd == PRC_HOSTDEAD)
		ip = 0;
	else if (errno == 0)
		return;

	if (ip) {
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport,
		    rdomain);
		if (inp) {
			seq = ntohl(th->th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, errno);
		} else if (inetctlerrmap[cmd] == EHOSTUNREACH ||
		    inetctlerrmap[cmd] == ENETUNREACH ||
		    inetctlerrmap[cmd] == EHOSTDOWN) {
			struct sockaddr_in sin;

			bzero(&sin, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_port = th->th_sport;
			sin.sin_addr = ip->ip_src;
			syn_cache_unreach(sintosa(&sin), sa, th, rdomain);
		}
	} else
		in_pcbnotifyall(&tcbtable, sa, rdomain, errno, notify);
}


#ifdef INET6
/*
 * Path MTU Discovery handlers.
 */
void
tcp6_mtudisc_callback(struct sockaddr_in6 *sin6, u_int rdomain)
{
	(void) in6_pcbnotify(&tcbtable, sin6, 0,
	    &sa6_any, 0, rdomain, PRC_MSGSIZE, NULL, tcp_mtudisc);
}
#endif /* INET6 */

/*
 * On receipt of path MTU corrections, flush old route and replace it
 * with the new one.  Retransmit all unacknowledged packets, to ensure
 * that all packets will be received.
 */
void
tcp_mtudisc(struct inpcb *inp, int errno)
{
	struct tcpcb *tp = intotcpcb(inp);
	struct rtentry *rt = in_pcbrtentry(inp);
	int change = 0;

	if (tp != 0) {
		int orig_maxseg = tp->t_maxseg;
		if (rt != 0) {
			/*
			 * If this was not a host route, remove and realloc.
			 */
			if ((rt->rt_flags & RTF_HOST) == 0) {
				in_rtchange(inp, errno);
				if ((rt = in_pcbrtentry(inp)) == 0)
					return;
			}
			if (orig_maxseg != tp->t_maxseg ||
			    (rt->rt_locks & RTV_MTU))
				change = 1;
		}
		tcp_mss(tp, -1);

		/*
		 * Resend unacknowledged packets
		 */
		tp->snd_nxt = tp->snd_una;
		if (change || errno > 0)
			tcp_output(tp);
	}
}

void
tcp_mtudisc_increase(struct inpcb *inp, int errno)
{
	struct tcpcb *tp = intotcpcb(inp);
	struct rtentry *rt = in_pcbrtentry(inp);

	if (tp != 0 && rt != 0) {
		/*
		 * If this was a host route, remove and realloc.
		 */
		if (rt->rt_flags & RTF_HOST)
			in_rtchange(inp, errno);

		/* also takes care of congestion window */
		tcp_mss(tp, -1);
	}
}

/*
 * Generate new ISNs with a method based on RFC1948
 */
#define TCP_ISS_CONN_INC 4096
int tcp_secret_init;
u_char tcp_secret[16];
SHA2_CTX tcp_secret_ctx;

void
tcp_set_iss_tsm(struct tcpcb *tp)
{
	SHA2_CTX ctx;
	union {
		uint8_t bytes[SHA512_DIGEST_LENGTH];
		uint32_t words[2];
	} digest;
	u_int rdomain = rtable_l2(tp->t_inpcb->inp_rtableid);

	if (tcp_secret_init == 0) {
		arc4random_buf(tcp_secret, sizeof(tcp_secret));
		SHA512Init(&tcp_secret_ctx);
		SHA512Update(&tcp_secret_ctx, tcp_secret, sizeof(tcp_secret));
		tcp_secret_init = 1;
	}
	ctx = tcp_secret_ctx;
	SHA512Update(&ctx, &rdomain, sizeof(rdomain));
	SHA512Update(&ctx, &tp->t_inpcb->inp_lport, sizeof(u_short));
	SHA512Update(&ctx, &tp->t_inpcb->inp_fport, sizeof(u_short));
	if (tp->pf == AF_INET6) {
		SHA512Update(&ctx, &tp->t_inpcb->inp_laddr6,
		    sizeof(struct in6_addr));
		SHA512Update(&ctx, &tp->t_inpcb->inp_faddr6,
		    sizeof(struct in6_addr));
	} else {
		SHA512Update(&ctx, &tp->t_inpcb->inp_laddr,
		    sizeof(struct in_addr));
		SHA512Update(&ctx, &tp->t_inpcb->inp_faddr,
		    sizeof(struct in_addr));
	}
	SHA512Final(digest.bytes, &ctx);
	tcp_iss += TCP_ISS_CONN_INC;
	tp->iss = digest.words[0] + tcp_iss;
	tp->ts_modulate = digest.words[1];
}

#ifdef TCP_SIGNATURE
int
tcp_signature_tdb_attach(void)
{
	return (0);
}

int
tcp_signature_tdb_init(struct tdb *tdbp, struct xformsw *xsp,
    struct ipsecinit *ii)
{
	if ((ii->ii_authkeylen < 1) || (ii->ii_authkeylen > 80))
		return (EINVAL);

	tdbp->tdb_amxkey = malloc(ii->ii_authkeylen, M_XDATA, M_NOWAIT);
	if (tdbp->tdb_amxkey == NULL)
		return (ENOMEM);
	bcopy(ii->ii_authkey, tdbp->tdb_amxkey, ii->ii_authkeylen);
	tdbp->tdb_amxkeylen = ii->ii_authkeylen;

	return (0);
}

int
tcp_signature_tdb_zeroize(struct tdb *tdbp)
{
	if (tdbp->tdb_amxkey) {
		explicit_bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
		free(tdbp->tdb_amxkey, M_XDATA, 0);
		tdbp->tdb_amxkey = NULL;
	}

	return (0);
}

int
tcp_signature_tdb_input(struct mbuf *m, struct tdb *tdbp, int skip, int protoff)
{
	return (0);
}

int
tcp_signature_tdb_output(struct mbuf *m, struct tdb *tdbp, struct mbuf **mp,
    int skip, int protoff)
{
	return (EINVAL);
}

int
tcp_signature_apply(caddr_t fstate, caddr_t data, unsigned int len)
{
	MD5Update((MD5_CTX *)fstate, (char *)data, len);
	return 0;
}

int
tcp_signature(struct tdb *tdb, int af, struct mbuf *m, struct tcphdr *th,
    int iphlen, int doswap, char *sig)
{
	MD5_CTX ctx;
	int len;
	struct tcphdr th0;

	MD5Init(&ctx);

	switch(af) {
	case 0:
	case AF_INET: {
		struct ippseudo ippseudo;
		struct ip *ip;

		ip = mtod(m, struct ip *);

		ippseudo.ippseudo_src = ip->ip_src;
		ippseudo.ippseudo_dst = ip->ip_dst;
		ippseudo.ippseudo_pad = 0;
		ippseudo.ippseudo_p = IPPROTO_TCP;
		ippseudo.ippseudo_len = htons(m->m_pkthdr.len - iphlen);

		MD5Update(&ctx, (char *)&ippseudo,
		    sizeof(struct ippseudo));
		break;
		}
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr_pseudo ip6pseudo;
		struct ip6_hdr *ip6;

		ip6 = mtod(m, struct ip6_hdr *);
		bzero(&ip6pseudo, sizeof(ip6pseudo));
		ip6pseudo.ip6ph_src = ip6->ip6_src;
		ip6pseudo.ip6ph_dst = ip6->ip6_dst;
		in6_clearscope(&ip6pseudo.ip6ph_src);
		in6_clearscope(&ip6pseudo.ip6ph_dst);
		ip6pseudo.ip6ph_nxt = IPPROTO_TCP;
		ip6pseudo.ip6ph_len = htonl(m->m_pkthdr.len - iphlen);

		MD5Update(&ctx, (char *)&ip6pseudo,
		    sizeof(ip6pseudo));
		break;
		}
#endif
	}

	th0 = *th;
	th0.th_sum = 0;

	if (doswap) {
		th0.th_seq = htonl(th0.th_seq);
		th0.th_ack = htonl(th0.th_ack);
		th0.th_win = htons(th0.th_win);
		th0.th_urp = htons(th0.th_urp);
	}
	MD5Update(&ctx, (char *)&th0, sizeof(th0));

	len = m->m_pkthdr.len - iphlen - th->th_off * sizeof(uint32_t);

	if (len > 0 &&
	    m_apply(m, iphlen + th->th_off * sizeof(uint32_t), len,
	    tcp_signature_apply, (caddr_t)&ctx))
		return (-1); 

	MD5Update(&ctx, tdb->tdb_amxkey, tdb->tdb_amxkeylen);
	MD5Final(sig, &ctx);

	return (0);
}
#endif /* TCP_SIGNATURE */
@


1.164
log
@Merge the content of <netinet/tcpip.h> and <netinet6/tcpipv6.h> in
<netinet/tcp_debug.h>.

The IPv6 variant was always included and the IPv4 version is not
present on all systems.

Most of the offending ports are already fixed, thanks to sthen@@!
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.163 2017/05/09 11:01:06 bluhm Exp $	*/
d308 2
a309 1
		win = sbspace(&tp->t_inpcb->inp_socket->so_rcv);
@


1.163
log
@Convert diagnostic panic to compile time assert in tcp6_ctlinput().
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.162 2017/05/04 15:00:24 bluhm Exp $	*/
a92 1
#include <netinet/tcpip.h>
@


1.162
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.161 2017/04/19 15:21:54 bluhm Exp $	*/
d638 1
a685 4
#ifdef DIAGNOSTIC
		if (sizeof(*thp) > sizeof(th))
			panic("assumption failed in tcp6_ctlinput");
#endif
@


1.161
log
@Use the rt_rmx defines that hide the struct rt_kmetrics indirection.
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.160 2017/02/09 15:19:32 jca Exp $	*/
d697 1
a697 2
		    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
		    th.th_sport, rdomain);
@


1.160
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.159 2017/01/26 13:03:47 bluhm Exp $	*/
d887 1
a887 1
			    (rt->rt_rmx.rmx_locks & RTV_MTU))
@


1.159
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.158 2017/01/10 09:01:18 mpi Exp $	*/
d134 1
a134 1
struct tcpstat tcpstat;		/* tcp statistics */
d155 1
d498 1
a498 1
		tcpstat.tcps_drops++;
d500 1
a500 1
		tcpstat.tcps_conndrops++;
d555 1
a555 1
	tcpstat.tcps_closed++;
@


1.158
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.157 2016/12/20 09:57:10 mpi Exp $	*/
d728 1
a728 1
void *
d742 1
a742 1
		return NULL;
d745 1
a745 1
		return NULL;
d748 1
a748 1
		return NULL;
d755 1
a755 1
		return NULL;
d782 1
a782 1
				return NULL;
d800 1
a800 1
						return NULL;
d807 1
a807 1
				return NULL;
d811 1
a811 1
			return NULL;
d819 1
a819 1
		return NULL;
a846 2

	return NULL;
@


1.157
log
@No need for splsoftnet()/splx() dance around a pool_put() if the pool
has IPL_SOFTNET as ipl.

ok mikeb@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.156 2016/09/24 14:51:37 naddy Exp $	*/
d537 1
a537 2
	if (tp->t_template)
		(void) m_free(tp->t_template);
@


1.156
log
@ANSIfy netinet/; from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.155 2016/09/15 02:00:18 dlg Exp $	*/
a552 1
	int s;
a553 1
	s = splsoftnet();
a554 1
	splx(s);
@


1.155
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.154 2016/09/06 00:04:15 dlg Exp $	*/
d189 1
a189 2
tcp_template(tp)
	struct tcpcb *tp;
d490 1
a490 3
tcp_drop(tp, errno)
	struct tcpcb *tp;
	int errno;
d595 1
a595 3
tcp_notify(inp, error)
	struct inpcb *inp;
	int error;
d861 1
a861 3
tcp6_mtudisc_callback(sin6, rdomain)
	struct sockaddr_in6 *sin6;
	u_int rdomain;
d874 1
a874 3
tcp_mtudisc(inp, errno)
	struct inpcb *inp;
	int errno;
d907 1
a907 3
tcp_mtudisc_increase(inp, errno)
	struct inpcb *inp;
	int errno;
d977 2
a978 4
tcp_signature_tdb_init(tdbp, xsp, ii)
	struct tdb *tdbp;
	struct xformsw *xsp;
	struct ipsecinit *ii;
d993 1
a993 2
tcp_signature_tdb_zeroize(tdbp)
	struct tdb *tdbp;
d1005 1
a1005 4
tcp_signature_tdb_input(m, tdbp, skip, protoff)
	struct mbuf *m;
	struct tdb *tdbp;
	int skip, protoff;
d1011 2
a1012 5
tcp_signature_tdb_output(m, tdbp, mp, skip, protoff)
	struct mbuf *m;
	struct tdb *tdbp;
	struct mbuf **mp;
	int skip, protoff;
d1018 1
a1018 4
tcp_signature_apply(fstate, data, len)
	caddr_t fstate;
	caddr_t data;
	unsigned int len;
@


1.154
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.153 2016/09/03 14:34:13 bluhm Exp $	*/
d144 4
a147 4
	pool_init(&tcpcb_pool, sizeof(struct tcpcb), 0, 0, 0, "tcpcb", NULL);
	pool_setipl(&tcpcb_pool, IPL_SOFTNET);
	pool_init(&tcpqe_pool, sizeof(struct tcpqent), 0, 0, 0, "tcpqe", NULL);
	pool_setipl(&tcpcb_pool, IPL_SOFTNET);
d150 2
a151 3
	pool_init(&sackhl_pool, sizeof(struct sackhole), 0, 0, 0, "sackhl",
	    NULL);
	pool_setipl(&sackhl_pool, IPL_SOFTNET);
@


1.153
log
@Reduce the factor of the limits derived form NMBCLUSTERS.  We want
the additional clusters in the socket buffer and not elsewhere.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.152 2016/08/31 11:05:05 mpi Exp $	*/
d145 1
d147 1
d152 1
@


1.152
log
@Use 'sc_route{4,6}' directly instead of casting them to 'struct route *'.

This is another little step towards deprecating 'struct route{,_in6}'.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.151 2016/03/07 18:44:00 naddy Exp $	*/
d123 1
a123 1
int tcp_reass_limit = NMBCLUSTERS / 2; /* hardlimit for tcpqe_pool */
@


1.151
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.150 2015/10/24 16:08:48 mpi Exp $	*/
a298 1
	struct route *ro = NULL;
a312 6

		/*
		 * The route/route6 distinction is meaningless
		 * unless you're allocating space or passing parameters.
		 */
		ro = &tp->t_inpcb->inp_route;
d400 2
a401 1
		    (struct route_in6 *)ro, 0, NULL,
d409 5
a413 2
		ip_output(m, NULL, ro, ip_mtudisc ? IP_MTUDISC : 0,
		    NULL, tp ? tp->t_inpcb : NULL, 0);
@


1.150
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.149 2015/10/02 09:51:54 tedu Exp $	*/
d141 1
a141 1
tcp_init()
d983 1
a983 1
tcp_signature_tdb_attach()
@


1.149
log
@add a comment above the rfc1948 code that mentions the rfc so it's easy to find
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.148 2015/09/11 08:17:06 claudio Exp $	*/
d257 1
a257 1
			ip6->ip6_hlim = in6_selecthlim(inp, NULL);	/*XXX*/
d403 1
a403 1
		ip6->ip6_hlim = in6_selecthlim(tp ? tp->t_inpcb : NULL, NULL);	/*XXX*/
@


1.148
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.147 2015/09/01 21:24:04 bluhm Exp $	*/
d936 3
@


1.147
log
@Replace sockaddr casts with the proper satosin(), ... calls.
From David Hill; OK mpi@@; tested kspillner@@; tweaks bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.146 2015/08/27 20:56:16 bluhm Exp $	*/
d407 1
a407 1
		    (struct route_in6 *)ro, 0, NULL, NULL,
@


1.146
log
@The syn cache is completely implemented in tcp_input.c.  So all its
global variables should also live there.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.145 2015/08/24 15:37:03 bluhm Exp $	*/
d853 1
a853 2
			syn_cache_unreach((struct sockaddr *)&sin,
			    sa, th, rdomain);
@


1.145
log
@Rename the syn cache counter into tcp_syn_cache_count to have the
same prefix for all variables.  Convert the counter type to int,
the limit is also int.  Before searching the cache, check that it
is not empty.  Do not access the counter outside of the syn cache
from tcp_ctlinput(), let the syn_cache_lookup() function handle it.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.144 2015/07/16 16:12:15 mpi Exp $	*/
a121 8

/* syn hash parameters */
#define	TCP_SYN_HASH_SIZE	293
#define	TCP_SYN_BUCKET_SIZE	35
int	tcp_syn_cache_size = TCP_SYN_HASH_SIZE;
int	tcp_syn_cache_limit = TCP_SYN_HASH_SIZE*TCP_SYN_BUCKET_SIZE;
int	tcp_syn_bucket_limit = 3*TCP_SYN_BUCKET_SIZE;
struct	syn_cache_head tcp_syn_cache[TCP_SYN_HASH_SIZE];
@


1.144
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.143 2015/06/16 11:09:40 mpi Exp $	*/
d734 3
a736 4
		} else if (syn_cache_count &&
		    (inet6ctlerrmap[cmd] == EHOSTUNREACH ||
		     inet6ctlerrmap[cmd] == ENETUNREACH ||
		     inet6ctlerrmap[cmd] == EHOSTDOWN))
d851 3
a853 4
		} else if (syn_cache_count &&
		    (inetctlerrmap[cmd] == EHOSTUNREACH ||
		     inetctlerrmap[cmd] == ENETUNREACH ||
		     inetctlerrmap[cmd] == EHOSTDOWN)) {
@


1.143
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.142 2015/05/13 10:42:46 jsg Exp $	*/
d413 1
a413 1
		HTONS(ip6->ip6_plen);
d1109 4
a1112 4
		HTONL(th0.th_seq);
		HTONL(th0.th_ack);
		HTONS(th0.th_win);
		HTONS(th0.th_urp);
@


1.142
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.141 2015/05/07 09:19:31 mikeb Exp $	*/
d397 1
a397 1
	m->m_pkthdr.rcvif = (struct ifnet *) 0;
@


1.141
log
@Include the timestamp TCP option in keep alive packets as well.

According to RFC 7323 "once TSopt has been successfully negotiated,
... [it] MUST be sent in every non-<RST> segment for the duration
of the connection."  Which means that keep alives which are just
ACK packets must include that too.

Pointed out and tested by Lauri Tirkkonen <lotheac at iki ! fi>, thanks!
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.140 2015/03/14 03:38:52 jsg Exp $	*/
d306 2
a307 2
	struct mbuf *m = 0;
	struct route *ro = 0;
@


1.140
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.139 2014/12/19 17:14:40 tedu Exp $	*/
a299 3
#ifdef INET6
/* This function looks hairy, because it was so IPv4-dependent. */
#endif /* INET6 */
a371 4
	m->m_len = tlen;
	m->m_pkthdr.len = tlen;
	m->m_pkthdr.rcvif = (struct ifnet *) 0;
	m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
d383 16
@


1.139
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.138 2014/11/18 02:37:31 tedu Exp $	*/
a81 1
#include <net/if.h>
@


1.138
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.137 2014/11/16 17:40:17 tedu Exp $	*/
a209 1
#ifdef INET
a212 1
#endif /* INET */
a235 1
#ifdef INET
a251 1
#endif /* INET */
a1059 1
#ifdef INET
a1075 1
#endif
@


1.137
log
@remove now unnecessary casts from hash update calls.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.136 2014/11/06 12:05:32 mpi Exp $	*/
a94 1
#include <dev/rndvar.h>
@


1.136
log
@Let's just call a rdomain a rdomain.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.135 2014/11/06 07:41:32 dlg Exp $	*/
d966 3
a968 3
	SHA512Update(&ctx, (char *)&rdomain, sizeof(rdomain));
	SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_lport, sizeof(u_short));
	SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_fport, sizeof(u_short));
d970 1
a970 1
		SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_laddr6,
d972 1
a972 1
		SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_faddr6,
d975 1
a975 1
		SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_laddr,
d977 1
a977 1
		SHA512Update(&ctx, (char *)&tp->t_inpcb->inp_faddr,
@


1.135
log
@mix the rtable into the hash for tcp sequence number generation.

ok tedu@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.134 2014/11/04 15:24:40 mpi Exp $	*/
d957 1
a957 1
	u_int rtable = rtable_l2(tp->t_inpcb->inp_rtableid);
d966 1
a966 1
	SHA512Update(&ctx, (char *)&rtable, sizeof(rtable));
@


1.134
log
@Remove "pl" suffix on pool names.

ok dlg@@, uebayasi@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.133 2014/10/20 03:43:40 tedu Exp $	*/
d957 1
a957 1

d966 1
@


1.133
log
@use sha512 instead of md5 for tcp isn. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.132 2014/07/22 11:06:10 mpi Exp $	*/
d154 2
a155 4
	pool_init(&tcpcb_pool, sizeof(struct tcpcb), 0, 0, 0, "tcpcbpl",
	    NULL);
	pool_init(&tcpqe_pool, sizeof(struct tcpqent), 0, 0, 0, "tcpqepl",
	    NULL);
d158 1
a158 1
	pool_init(&sackhl_pool, sizeof(struct sackhole), 0, 0, 0, "sackhlpl",
@


1.132
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.131 2014/07/12 21:06:34 yasuoka Exp $	*/
d102 1
d949 1
a949 1
MD5_CTX tcp_secret_ctx;
d954 6
a959 2
	MD5_CTX ctx;
	u_int32_t digest[4];
d963 2
a964 2
		MD5Init(&tcp_secret_ctx);
		MD5Update(&tcp_secret_ctx, tcp_secret, sizeof(tcp_secret));
d968 2
a969 2
	MD5Update(&ctx, (char *)&tp->t_inpcb->inp_lport, sizeof(u_short));
	MD5Update(&ctx, (char *)&tp->t_inpcb->inp_fport, sizeof(u_short));
d971 1
a971 1
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_laddr6,
d973 1
a973 1
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_faddr6,
d976 1
a976 1
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_laddr,
d978 1
a978 1
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_faddr,
d981 1
a981 1
	MD5Final((u_char *)digest, &ctx);
d983 2
a984 2
	tp->iss = digest[0] + tcp_iss;
	tp->ts_modulate = digest[1];
@


1.131
log
@Resize the pcb hashtable automatically.  The table size will be doubled
when the number of the hash entries reaches 75% of the table size.

ok dlg henning, 'commit in' claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.130 2014/07/12 18:44:23 tedu Exp $	*/
a84 1
#include <netinet/in_systm.h>
@


1.130
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.129 2014/04/21 12:22:26 henning Exp $	*/
d121 2
a122 2
#ifndef TCBHASHSIZE
#define	TCBHASHSIZE	128
a123 1
int	tcbhashsize = TCBHASHSIZE;
d164 1
a164 1
	in_pcbinit(&tcbtable, tcbhashsize);
@


1.129
log
@ip_output() using varargs always struck me as bizarre, esp since it's only
ever used to pass on uint32 (for ipsec). stop that madness and just pass
the uint32, 0 in all cases but the two that pass the ipsec flowinfo.
ok deraadt reyk guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.128 2014/04/21 11:10:54 henning Exp $	*/
d1015 1
a1015 1
		free(tdbp->tdb_amxkey, M_XDATA);
@


1.128
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.125 2013/10/24 11:31:43 mpi Exp $	*/
d424 1
a424 1
		    NULL, tp ? tp->t_inpcb : NULL);
@


1.127
log
@tcp_respond: let the stack worry about the cksum instead of doing it
manually, ok naddy (in january)
@
text
@d423 2
a424 2
		ip_output(m, (void *)NULL, ro, ip_mtudisc ? IP_MTUDISC : 0,
			(void *)NULL, tp ? tp->t_inpcb : (void *)NULL);
@


1.126
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@a321 1
	struct ipovly *ih;
d387 1
a412 3
		th->th_sum = 0;
		th->th_sum = in6_cksum(m, IPPROTO_TCP,
		   sizeof(struct ip6_hdr), ip6->ip6_plen);
a419 11
		ih = (struct ipovly *)ip;
		bzero(ih->ih_x1, sizeof ih->ih_x1);
		ih->ih_len = htons((u_short)tlen - sizeof(struct ip));

		/*
		 * There's no point deferring to hardware checksum processing
		 * here, as we only send a minimal TCP packet whose checksum
		 * we need to compute in any case.
		 */
		th->th_sum = 0;
		th->th_sum = in_cksum(m, tlen);
d422 1
@


1.125
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.124 2013/10/23 15:12:42 mpi Exp $	*/
d400 1
a400 1
	/* force routing domain */
d402 1
a402 1
		m->m_pkthdr.rdomain = tp->t_inpcb->inp_rtableid;
d404 1
a404 1
		m->m_pkthdr.rdomain = rtableid;
@


1.124
log
@Remove the number of in_var.h inclusions by moving some functions and
global variables to in.h.

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.123 2013/10/21 08:42:24 phessler Exp $	*/
a98 2
#include <netinet6/in6_var.h>
#include <netinet6/ip6_var.h>
@


1.123
log
@Sprinkle a lot more IPv6 routing domains support in the kernel.

Mostly mechanical, setting and passing the rdomain and rtable correctly.
Not yet enabled.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.122 2013/10/20 11:03:01 phessler Exp $	*/
a86 1
#include <netinet/in_var.h>
@


1.122
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.121 2013/10/19 10:38:55 henning Exp $	*/
d894 3
a896 2
tcp6_mtudisc_callback(faddr)
	struct in6_addr *faddr;
d898 2
a899 8
	struct sockaddr_in6 sin6;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *faddr;
	(void) in6_pcbnotify(&tcbtable, &sin6, 0,
	    &sa6_any, 0, /* XXX rdomain */ 0, PRC_MSGSIZE, NULL, tcp_mtudisc);
@


1.121
log
@make in_proto_cksum_out not rely on the pseudo header checksum to be
already there, just compute it - it's dirt cheap. since that happens
very late in ip_output, the rest of the stack doesn't have to care about
checksums at all any more, if something needs to be checksummed, just
set the flag on the pkthdr mbuf to indicate so.
stop pre-computing the pseudo header checksum and incrementally updating it
in the tcp and udp stacks.
ok lteo florian
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.119 2013/05/31 13:15:53 bluhm Exp $	*/
d731 1
a731 1
		    th.th_sport);
d755 1
a755 1
			    sa, &th, /* XXX */ 0);
d758 1
a758 1
		    sa6_src, 0, cmd, NULL, notify);
d904 1
a904 1
	    &sa6_any, 0, PRC_MSGSIZE, NULL, tcp_mtudisc);
@


1.120
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@a259 3
			th->th_sum = in_cksum_phdr(ipovly->ih_src.s_addr,
			    ipovly->ih_dst.s_addr,
			    htons(sizeof (struct tcphdr) + IPPROTO_TCP));
a280 1
			th->th_sum = 0;
d295 1
@


1.119
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.118 2013/04/10 08:50:59 mpi Exp $	*/
d656 1
a656 4
tcp6_ctlinput(cmd, sa, d)
	int cmd;
	struct sockaddr *sa;
	void *d;
@


1.118
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.117 2013/04/02 18:27:47 bluhm Exp $	*/
d666 1
a666 1
	struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
d763 2
a764 2
		(void) in6_pcbnotify(&tcbtable, sa, 0,
		    (struct sockaddr *)sa6_src, 0, cmd, NULL, notify);
d909 2
a910 2
	(void) in6_pcbnotify(&tcbtable, (struct sockaddr *)&sin6, 0,
	    (struct sockaddr *)&sa6_any, 0, PRC_MSGSIZE, NULL, tcp_mtudisc);
@


1.117
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.116 2013/03/28 23:10:06 tedu Exp $	*/
d87 1
d101 1
a141 4
#ifdef INET6
extern int ip6_defhlim;
#endif /* INET6 */

a778 1
	extern int inetctlerrmap[];
@


1.116
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.115 2013/03/28 16:45:16 tedu Exp $	*/
d462 1
a462 1
		return ((struct tcpcb *)0);
d579 1
a579 1
	return ((struct tcpcb *)0);
d632 1
a632 1
	struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;
@


1.115
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.114 2012/12/28 17:52:06 gsoares Exp $	*/
d76 1
@


1.114
log
@change the malloc(9) flags from M_DONTWAIT to M_NOWAIT; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.113 2012/03/10 12:03:29 claudio Exp $	*/
a72 1
#include <sys/proc.h>
@


1.113
log
@Increase TCP's initial window to 10 * MSS or 14600 bytes as proposed in
draft-ietf-tcpm-initcwnd. net.inet.tcp.rfc3390 defaults to 2 now which
uses the 10*MSS, setting it back to 1 brings back the old default of 4*MSS.
OK sperreault@@, henning@@, sthen@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.112 2011/01/11 15:42:05 deraadt Exp $	*/
d1030 1
a1030 1
	tdbp->tdb_amxkey = malloc(ii->ii_authkeylen, M_XDATA, M_DONTWAIT);
@


1.112
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.111 2010/07/03 04:44:51 guenther Exp $	*/
d118 1
a118 1
int	tcp_do_rfc3390 = 1;	/* RFC3390 Increasing TCP's Initial Window */
@


1.111
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.110 2010/01/15 18:20:23 chl Exp $	*/
d1044 1
a1044 1
		bzero(tdbp->tdb_amxkey, tdbp->tdb_amxkeylen);
@


1.110
log
@Replace pool_get() + bzero() with pool_get(..., PR_ZERO).

With input from oga@@ and krw@@

ok oga@@ krw@@ thib@@ markus@@ mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.109 2009/11/13 20:54:05 claudio Exp $	*/
d321 2
a322 7
tcp_respond(tp, template, th0, ack, seq, flags, rdomain)
	struct tcpcb *tp;
	caddr_t template;
	struct tcphdr *th0;
	tcp_seq ack, seq;
	int flags;
	u_int rdomain;
d410 1
a410 1
		m->m_pkthdr.rdomain = tp->t_inpcb->inp_rdomain;
d412 1
a412 1
		m->m_pkthdr.rdomain = rdomain;
d772 1
a772 5
tcp_ctlinput(cmd, sa, rdomain, v)
	int cmd;
	struct sockaddr *sa;
	u_int rdomain;
	void *v;
d833 1
a833 1
				icmp_mtudisc(icp, inp->inp_rdomain);
@


1.109
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.108 2009/11/03 10:59:04 claudio Exp $	*/
d465 1
a465 1
	tp = pool_get(&tcpcb_pool, PR_NOWAIT);
a467 1
	bzero((char *) tp, sizeof(struct tcpcb));
@


1.108
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.107 2009/08/10 10:13:43 claudio Exp $	*/
d321 1
a321 1
tcp_respond(tp, template, th0, ack, seq, flags)
d327 1
d413 6
d778 1
a778 1
tcp_ctlinput(cmd, sa, v)
d781 1
d821 1
a821 1
		    /* XXX */ 0);
d879 1
a879 1
		    /* XXX */ 0);
d899 1
a899 1
			    sa, th, /* XXX */ 0);
d902 1
a902 1
		in_pcbnotifyall(&tcbtable, sa, errno, notify);
@


1.107
log
@sockets created via a listening socket lose the rdomain and fail to work
therefore. Inherit the rdomain through the syncache.
There are some interactions that need some more work (ctlinput) so this
can be improved but is good enough for now.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.106 2009/06/05 00:05:22 claudio Exp $	*/
d835 1
a835 2
				/* XXX inherit rdomain from PCB */
				icmp_mtudisc(icp, 0);
@


1.106
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.105 2008/06/09 07:07:17 djm Exp $	*/
d762 1
a762 1
			    sa, &th);
d892 1
a892 1
			    sa, th);
@


1.105
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.104 2008/05/06 08:47:36 markus Exp $	*/
d812 2
a813 1
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
d835 2
a836 1
				icmp_mtudisc(icp);    
d871 2
a872 1
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
@


1.104
log
@remove tcp_drain code since it's not longer used; ok henning, feedback thib
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.103 2008/02/20 14:23:31 markus Exp $	*/
d989 1
a989 1
		arc4random_bytes(tcp_secret, sizeof(tcp_secret));
@


1.103
log
@remove old unused TCP isn code; ok henning, dhartmei, mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.102 2008/02/20 11:24:03 markus Exp $	*/
a553 1
	tcp_reass_lock(tp);
a554 1
	tcp_reass_unlock(tp);
a605 19
}

void
tcp_drain()
{
	struct inpcb *inp;

	/* called at splnet() */
	CIRCLEQ_FOREACH(inp, &tcbtable.inpt_queue, inp_queue) {
		struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;

		if (tp != NULL) {
			if (tcp_reass_lock_try(tp) == 0)
				continue;
			if (tcp_freeq(tp))
				tcpstat.tcps_conndrained++;
			tcp_reass_unlock(tp);
		}
	}
@


1.102
log
@when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.101 2007/11/27 17:23:23 deraadt Exp $	*/
a1176 47

#define TCP_RNDISS_ROUNDS	16
#define TCP_RNDISS_OUT	7200
#define TCP_RNDISS_MAX	30000

u_int8_t tcp_rndiss_sbox[128];
u_int16_t tcp_rndiss_msb;
u_int16_t tcp_rndiss_cnt;
long tcp_rndiss_reseed;

u_int16_t
tcp_rndiss_encrypt(val)
	u_int16_t val;
{
	u_int16_t sum = 0, i;

	for (i = 0; i < TCP_RNDISS_ROUNDS; i++) {
		sum += 0x79b9;
		val ^= ((u_int16_t)tcp_rndiss_sbox[(val^sum) & 0x7f]) << 7;
		val = ((val & 0xff) << 7) | (val >> 8);
	}

	return val;
}

void
tcp_rndiss_init()
{
	arc4random_bytes(tcp_rndiss_sbox, sizeof(tcp_rndiss_sbox));

	tcp_rndiss_reseed = time_second + TCP_RNDISS_OUT;
	tcp_rndiss_msb = tcp_rndiss_msb == 0x8000 ? 0 : 0x8000;
	tcp_rndiss_cnt = 0;
}

tcp_seq
tcp_rndiss_next()
{
        if (tcp_rndiss_cnt >= TCP_RNDISS_MAX ||
	    time_second > tcp_rndiss_reseed)
                tcp_rndiss_init();

	/* (arc4random() & 0x7fff) ensures a 32768 byte gap between ISS */
	return ((tcp_rndiss_encrypt(tcp_rndiss_cnt++) | tcp_rndiss_msb) <<16) |
		(arc4random() & 0x7fff);
}

@


1.101
log
@TCP_COMPAT_42 was last used in 1997.  Kill it.
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.100 2007/09/18 22:02:18 djm Exp $	*/
d321 1
a321 1
tcp_respond(tp, template, m, ack, seq, flags)
d324 1
a324 1
	struct mbuf *m;
d330 1
d333 5
a337 1
	struct tcpiphdr *ti = (struct tcpiphdr *)template;
d354 7
a360 19
		af = (((struct ip *)ti)->ip_v == 6) ? AF_INET6 : AF_INET;
	if (m == 0) {
		m = m_gethdr(M_DONTWAIT, MT_HEADER);
		if (m == NULL)
			return;
		tlen = 0;
		m->m_data += max_linkhdr;
		switch (af) {
#ifdef INET6
		case AF_INET6:
			bcopy(ti, mtod(m, caddr_t), sizeof(struct tcphdr) +
			    sizeof(struct ip6_hdr));
			break;
#endif /* INET6 */
		case AF_INET:
			bcopy(ti, mtod(m, caddr_t), sizeof(struct tcphdr) +
			    sizeof(struct ip));
			break;
		}
a361 7
		ti = mtod(m, struct tcpiphdr *);
		flags = TH_ACK;
	} else {
		m_freem(m->m_next);
		m->m_next = 0;
		m->m_data = (caddr_t)ti;
		tlen = 0;
a362 18
		switch (af) {
#ifdef INET6
		case AF_INET6:
			m->m_len = sizeof(struct tcphdr) + sizeof(struct ip6_hdr);
			xchg(((struct ip6_hdr *)ti)->ip6_dst,
			    ((struct ip6_hdr *)ti)->ip6_src, struct in6_addr);
			th = (void *)((caddr_t)ti + sizeof(struct ip6_hdr));
			break;
#endif /* INET6 */
		case AF_INET:
			m->m_len = sizeof (struct tcpiphdr);
			xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_int32_t);
			th = (void *)((caddr_t)ti + sizeof(struct ip));
			break;
		}
		xchg(th->th_dport, th->th_sport, u_int16_t);
#undef xchg
	}
d366 10
a375 2
		tlen += sizeof(struct tcphdr) + sizeof(struct ip6_hdr);
		th = (struct tcphdr *)((caddr_t)ti + sizeof(struct ip6_hdr));
d379 10
a388 3
		ti->ti_len = htons((u_int16_t)(sizeof (struct tcphdr) + tlen));
		tlen += sizeof (struct tcpiphdr);
		th = (struct tcphdr *)((caddr_t)ti + sizeof(struct ip));
d391 5
d415 4
a418 5
		((struct ip6_hdr *)ti)->ip6_flow   = htonl(0x60000000);
		((struct ip6_hdr *)ti)->ip6_nxt  = IPPROTO_TCP;
		((struct ip6_hdr *)ti)->ip6_hlim =
			in6_selecthlim(tp ? tp->t_inpcb : NULL, NULL);	/*XXX*/
		((struct ip6_hdr *)ti)->ip6_plen = tlen - sizeof(struct ip6_hdr);
d421 2
a422 2
		   sizeof(struct ip6_hdr), ((struct ip6_hdr *)ti)->ip6_plen);
		HTONS(((struct ip6_hdr *)ti)->ip6_plen);
d429 3
a431 2
		bzero(ti->ti_x1, sizeof ti->ti_x1);
		ti->ti_len = htons((u_short)tlen - sizeof(struct ip));
d440 2
a441 2
		((struct ip *)ti)->ip_len = htons(tlen);
		((struct ip *)ti)->ip_ttl = ip_defttl;
@


1.100
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.99 2007/09/01 18:49:28 henning Exp $	*/
a353 3
#ifdef TCP_COMPAT_42
		tlen = 1;
#else
a354 1
#endif
@


1.99
log
@since the
MGET* macros were changed to function calls, there wasn't any
need for the pool declarations and the inclusion of pool.h
From: tbert <bret.lambert@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.98 2007/06/25 12:17:43 markus Exp $	*/
d1221 1
a1221 1
	get_random_bytes(tcp_rndiss_sbox, sizeof(tcp_rndiss_sbox));
@


1.98
log
@merge tcp_set_iss() and tcp_set_tsm(); ok mcbride, djm (on earlier version)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.97 2007/06/15 18:23:06 markus Exp $	*/
d79 1
@


1.98.2.1
log
@MFC (markus)
when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.98 2007/06/25 12:17:43 markus Exp $	*/
d320 1
a320 1
tcp_respond(tp, template, th0, ack, seq, flags)
d323 1
a323 1
	struct tcphdr *th0;
a328 1
	struct mbuf *m = 0;
d331 1
a331 5
	struct ip *ip;
	struct ipovly *ih;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif
d348 5
a352 6
		af = (((struct ip *)template)->ip_v == 6) ? AF_INET6 : AF_INET;

	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return;
	m->m_data += max_linkhdr;
d354 1
a354 1
	tlen = 1;
d356 1
a356 1
	tlen = 0;
d358 13
d372 7
d380 18
d401 2
a402 10
		ip6 = mtod(m, struct ip6_hdr *);
		th = (struct tcphdr *)(ip6 + 1);
		tlen = sizeof(*ip6) + sizeof(*th);
		if (th0) {
			bcopy(template, ip6, sizeof(*ip6));
			bcopy(th0, th, sizeof(*th));
			xchg(ip6->ip6_dst, ip6->ip6_src, struct in6_addr);
		} else {
			bcopy(template, ip6, tlen);
		}
d406 5
a410 17
		ip = mtod(m, struct ip *);
		th = (struct tcphdr *)(ip + 1);
		tlen = sizeof(*ip) + sizeof(*th);
		if (th0) {
			bcopy(template, ip, sizeof(*ip));
			bcopy(th0, th, sizeof(*th));
			xchg(ip->ip_dst.s_addr, ip->ip_src.s_addr, u_int32_t);
		} else {
			bcopy(template, ip, tlen);
		}
 		break;
 	}
	if (th0)
		xchg(th->th_dport, th->th_sport, u_int16_t);
	else
		flags = TH_ACK;
#undef xchg
d430 5
a434 4
		ip6->ip6_flow = htonl(0x60000000);
		ip6->ip6_nxt  = IPPROTO_TCP;
		ip6->ip6_hlim = in6_selecthlim(tp ? tp->t_inpcb : NULL, NULL);	/*XXX*/
		ip6->ip6_plen = tlen - sizeof(struct ip6_hdr);
d437 2
a438 2
		   sizeof(struct ip6_hdr), ip6->ip6_plen);
		HTONS(ip6->ip6_plen);
d445 2
a446 3
		ih = (struct ipovly *)ip;
		bzero(ih->ih_x1, sizeof ih->ih_x1);
		ih->ih_len = htons((u_short)tlen - sizeof(struct ip));
d455 2
a456 2
		ip->ip_len = htons(tlen);
		ip->ip_ttl = ip_defttl;
@


1.97
log
@Drop the current random timestamps and the current ISN generation
code and replace both with a RFC1948 based method, so TCP clients
now have monotonic ISN/timestamps.  The server side uses completely
random ISN/timestamps and does time-wait recycling (on port reuse).
ok djm@@, mcbride@@; thanks to lots of testers
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.96 2007/06/01 00:52:38 henning Exp $	*/
d1014 3
a1016 3
int tcp_iss_init;
static u_char tcp_iss_secret[128];
MD5_CTX tcp_iss_ctx;
d1019 1
a1019 1
tcp_set_iss(struct tcpcb *tp)
d1022 1
a1022 1
	tcp_seq digest[4];
d1024 5
a1028 5
	if (tcp_iss_init == 0) {
		arc4random_bytes(tcp_iss_secret, sizeof(tcp_iss_secret));
		MD5Init(&tcp_iss_ctx);
		MD5Update(&tcp_iss_ctx, tcp_iss_secret, sizeof(tcp_iss_secret));
		tcp_iss_init = 1;
d1030 1
a1030 1
	ctx = tcp_iss_ctx;
d1047 1
a1047 34
}

int tcp_tsm_init;
static u_char tcp_tsm_secret[128];
MD5_CTX tcp_tsm_ctx;

void
tcp_set_tsm(struct tcpcb *tp)
{
	MD5_CTX ctx;
	u_int32_t digest[4];

	if (tcp_tsm_init == 0) {
		arc4random_bytes(tcp_tsm_secret, sizeof(tcp_tsm_secret));
		MD5Init(&tcp_tsm_ctx);
		MD5Update(&tcp_tsm_ctx, tcp_tsm_secret, sizeof(tcp_tsm_secret));
		tcp_tsm_init = 1;
	}
	ctx = tcp_tsm_ctx;
	MD5Update(&ctx, (char *)&tp->t_inpcb->inp_lport, sizeof(u_short));
	MD5Update(&ctx, (char *)&tp->t_inpcb->inp_fport, sizeof(u_short));
	if (tp->pf == AF_INET6) {
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_laddr6,
		    sizeof(struct in6_addr));
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_faddr6,
		    sizeof(struct in6_addr));
	} else {
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_laddr,
		    sizeof(struct in_addr));
		MD5Update(&ctx, (char *)&tp->t_inpcb->inp_faddr,
		    sizeof(struct in_addr));
	}
	MD5Final((u_char *)digest, &ctx);
	tp->ts_modulate = digest[0];
@


1.96
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.95 2007/05/09 14:28:47 deraadt Exp $	*/
a101 1
#ifdef TCP_SIGNATURE
a102 1
#endif /* TCP_SIGNATURE */
a149 1
#ifdef TCP_COMPAT_42
a150 1
#endif
a157 1
#ifdef TCP_COMPAT_42
a158 1
#endif /* TCP_COMPAT_42 */
d1011 70
@


1.95
log
@tcp_iss usage is ifdef TCP_COMPAT_42, so the variable decl can be too
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.94 2007/05/08 18:46:56 deraadt Exp $	*/
d446 2
a447 1
		    (struct route_in6 *)ro, 0, NULL, NULL);
@


1.94
log
@variables used by #ifdef code should be inside #ifdef too
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.93 2006/03/04 22:40:16 brad Exp $	*/
d152 1
d154 1
@


1.93
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.92 2005/09/28 15:20:12 brad Exp $	*/
d112 1
d114 1
d116 1
d118 1
@


1.93.4.1
log
@MFC (markus)
when creating a response, use the correct TCP header instead of
relying on the mbuf chain layout; with claudio@@ and krw@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.93 2006/03/04 22:40:16 brad Exp $	*/
d320 1
a320 1
tcp_respond(tp, template, th0, ack, seq, flags)
d323 1
a323 1
	struct tcphdr *th0;
a328 1
	struct mbuf *m = 0;
d331 1
a331 5
	struct ip *ip;
	struct ipovly *ih;
#ifdef INET6
	struct ip6_hdr *ip6;
#endif
d348 5
a352 6
		af = (((struct ip *)template)->ip_v == 6) ? AF_INET6 : AF_INET;

	m = m_gethdr(M_DONTWAIT, MT_HEADER);
	if (m == NULL)
		return;
	m->m_data += max_linkhdr;
d354 1
a354 1
	tlen = 1;
d356 1
a356 1
	tlen = 0;
d358 13
d372 7
d380 18
d401 2
a402 10
		ip6 = mtod(m, struct ip6_hdr *);
		th = (struct tcphdr *)(ip6 + 1);
		tlen = sizeof(*ip6) + sizeof(*th);
		if (th0) {
			bcopy(template, ip6, sizeof(*ip6));
			bcopy(th0, th, sizeof(*th));
			xchg(ip6->ip6_dst, ip6->ip6_src, struct in6_addr);
		} else {
			bcopy(template, ip6, tlen);
		}
d406 5
a410 17
		ip = mtod(m, struct ip *);
		th = (struct tcphdr *)(ip + 1);
		tlen = sizeof(*ip) + sizeof(*th);
		if (th0) {
			bcopy(template, ip, sizeof(*ip));
			bcopy(th0, th, sizeof(*th));
			xchg(ip->ip_dst.s_addr, ip->ip_src.s_addr, u_int32_t);
		} else {
			bcopy(template, ip, tlen);
		}
 		break;
 	}
	if (th0)
		xchg(th->th_dport, th->th_sport, u_int16_t);
	else
		flags = TH_ACK;
#undef xchg
d430 5
a434 4
		ip6->ip6_flow = htonl(0x60000000);
		ip6->ip6_nxt  = IPPROTO_TCP;
		ip6->ip6_hlim = in6_selecthlim(tp ? tp->t_inpcb : NULL, NULL);	/*XXX*/
		ip6->ip6_plen = tlen - sizeof(struct ip6_hdr);
d437 2
a438 2
		   sizeof(struct ip6_hdr), ip6->ip6_plen);
		HTONS(ip6->ip6_plen);
d444 2
a445 3
		ih = (struct ipovly *)ip;
		bzero(ih->ih_x1, sizeof ih->ih_x1);
		ih->ih_len = htons((u_short)tlen - sizeof(struct ip));
d454 2
a455 2
		ip->ip_len = htons(tlen);
		ip->ip_ttl = ip_defttl;
@


1.92
log
@Enable RFC3390 by default and remove a few compile time options which
can be changed via sysctl's.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.91 2005/08/02 11:05:44 markus Exp $	*/
d629 1
a629 1
	/* called at splimp() */
@


1.91
log
@change the TCP reass queue from LIST to TAILQ;
ok henning claudio fgsch krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.90 2005/06/30 08:51:31 markus Exp $	*/
d110 3
a112 22
/*
 * Configure kernel with options "TCP_DO_RFC1323=0" to disable RFC1323 stuff.
 * This is a good idea over slow SLIP/PPP links, because the timestamp
 * pretty well destroys the VJ compression (any packet with a timestamp
 * different from the previous one can't be compressed), as well as adding
 * more overhead.
 * XXX And it should be a settable per route characteristic (with this just
 * used as the default).
 */
#ifndef TCP_DO_RFC1323
#define TCP_DO_RFC1323	1
#endif
int	tcp_do_rfc1323 = TCP_DO_RFC1323;

#ifndef TCP_DO_SACK
#ifdef TCP_SACK
#define TCP_DO_SACK	1
#else
#define TCP_DO_SACK	0
#endif
#endif
int	tcp_do_sack = TCP_DO_SACK;		/* RFC 2018 selective ACKs */
d115 1
a115 1
int	tcp_do_rfc3390 = 0;	/* RFC3390 Increasing TCP's Initial Window */
@


1.90
log
@implement PMTU checks from
        http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html
i.e. don't act on ICMP-need-frag immediately if adhoc checks on the
advertised mtu fail.  the mtu update is delayed until a tcp retransmit
happens.  initial patch by Fernando Gont, tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.89 2005/05/24 00:02:37 fgont Exp $	*/
d180 1
a180 1
	pool_init(&tcpqe_pool, sizeof(struct ipqent), 0, 0, 0, "tcpqepl",
d495 1
a495 1
	LIST_INIT(&tp->segq);
d631 1
a631 1
	struct ipqent *qe;
d634 3
a636 3
	while ((qe = LIST_FIRST(&tp->segq)) != NULL) {
		LIST_REMOVE(qe, ipqe_q);
		m_freem(qe->ipqe_m);
@


1.89
log
@Ignore ICMP Source Quench messages meant for TCP connections. (Details in
http://www.gont.com.ar/drafts/icmp-attacks-against-tcp.html)
ok markus frantzen
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.88 2005/03/04 13:21:42 markus Exp $	*/
d522 4
d836 1
d874 34
a907 2
			/* Calculate new mtu and create corresponding route */
			icmp_mtudisc(icp);
@


1.88
log
@- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX
ok henning, hshoexer, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.87 2005/02/27 13:22:56 markus Exp $	*/
d736 4
d741 1
a741 1
		notify = tcp_quench;
d846 5
a850 1
		notify = tcp_quench;
a913 14
/*
 * When a source quench is received, close congestion window
 * to one segment.  We will gradually open it again as we proceed.
 */
void
tcp_quench(inp, errno)
	struct inpcb *inp;
	int errno;
{
	struct tcpcb *tp = intotcpcb(inp);

	if (tp)
		tp->snd_cwnd = tp->t_maxseg;
}
@


1.87
log
@1. tcp_xmit_timer(): remove extra rtt decrement (t_rtttime is 0-based
   while t_rtt was 1-based), update callers
2. define and use TCP_RTT_BASE_SHIFT instead of the hardcoded 2.
3. add missing shifts when t_srtt/t_rttvar are used.
4. update the comments: t_srtt uses 5 bits of fraction (not 3)
   and t_rttvar uses 4 bits
5. remove obsolete/unused macros TCP_RTT_SCALE and TCP_RTTVAR_SCALE
6. make sure rttmin is not > TCPTV_REXMTMAX
parts from netbsd, ok mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.86 2005/01/10 23:53:49 mcbride Exp $	*/
d152 3
d186 1
@


1.86
log
@Make sure bogus values don't make their way into tcp_xmit_timer() calculations.
- Ignore ts_ecr if it is 0, or the resulting rtt is out of range.
  (use tp->t_rtttime instead)
- Initialise tcp_now to 1, to avoid the 500ms window where a valid ts_ecr
  of 0 could be ignored.
- Convert out-of-range rtt values to valid ones in tcp_xmit_timer().

ok frantzen@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.85 2004/11/25 15:32:08 markus Exp $	*/
d511 2
a512 1
	tp->t_rttvar = tcp_rttdflt * PR_SLOWHZ << (TCP_RTTVAR_SHIFT + 2 - 1);
@


1.85
log
@fix for race between invocation for timer and network input
1) add a reaper for TCP and SYN cache states (cf. netbsd pr 20390)
2) additional check for TCP_TIMER_ISARMED(TCPT_REXMT) in tcp_timer_persist()
with mickey@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.84 2004/10/28 19:22:52 mcbride Exp $	*/
d136 1
a136 1
u_int32_t	tcp_now;
@


1.84
log
@Modulate tcp_now by a random amount on a per-connection basis.

ok markus@@ frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.83 2004/08/10 20:04:55 markus Exp $	*/
d498 1
d597 4
a600 1
	pool_put(&tcpcb_pool, tp);
d604 12
a616 1
	return ((struct tcpcb *)0);
@


1.83
log
@verify th_seq in icmp errors; report Fernando Gont; ok mcbride@@, dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.83 2004/08/10 20:01:18 markus Exp $	*/
a184 1
	tcp_now = arc4random() / 2;
@


1.83.2.1
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.83 2004/08/10 20:04:55 markus Exp $	*/
a151 3
#ifdef TCP_SACK
int tcp_sackhole_limit = 32*1024; /* hardlimit for sackhl_pool */
#endif
a182 1
	pool_sethardlimit(&sackhl_pool, tcp_sackhole_limit, NULL, 0);
@


1.82
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.81 2004/06/08 19:47:24 markus Exp $	*/
d694 1
d699 1
d701 1
d706 1
d710 3
a712 1
	    sa->sa_len != sizeof(struct sockaddr_in6))
d758 8
a766 12
			int valid = 0;

			/*
			 * Check to see if we have a valid TCP connection
			 * corresponding to the address in the ICMPv6 message
			 * payload.
			 */
			if (in6_pcbhashlookup(&tcbtable, &sa6->sin6_addr,
			    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
			    th.th_sport))
				valid++;

d774 1
a774 2
			icmp6_mtudisc_update((struct ip6ctlparam *)d, valid);

d777 8
a784 4

		if (in6_pcbnotify(&tcbtable, sa, th.th_dport,
		    (struct sockaddr *)sa6_src, th.th_sport, cmd, NULL, notify) == 0 &&
		    syn_cache_count &&
d805 4
d815 3
d826 1
a826 2
	else if (cmd == PRC_MSGSIZE && ip_mtudisc) {
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
d831 7
a837 6
		/*
		 * XXX is it possible to get a valid PRC_MSGSIZE error for
		 * a non-established connection?
		 */
		if (in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport)) {
d844 3
d858 10
a867 3
		if (in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
		    th->th_sport, errno, notify) == 0 &&
		    syn_cache_count &&
@


1.81
log
@factor out md5 code; ok+tests henning@@, djm@@, hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.80 2004/05/07 14:42:27 millert Exp $	*/
d1131 1
a1131 1
	tcp_rndiss_reseed = time.tv_sec + TCP_RNDISS_OUT;
d1140 1
a1140 1
	    time.tv_sec > tcp_rndiss_reseed)
@


1.80
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.79 2004/05/04 22:50:18 claudio Exp $	*/
d1024 75
@


1.79
log
@The tcp specific routing metrics are almost never used so reduce the routing
table from these metrics. struct rt_msghdr used by the routing socket is not
affected and so most userland apps don't need to be changed.
some man page polishing by jmc@@
OK henning@@ markus@@ theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.78 2004/04/26 18:12:25 frantzen Exp $	*/
d103 1
a103 1
#include <sys/md5k.h>
@


1.78
log
@- allow the user to force the TCP mss below the fail-safe 216 with a low
interface MTU.
- break a tcp_output() -> tcp_mtudisc() -> tcp_output() infinite recursion
when the TCP mss ends up larger than the interface MTU (when the if_mtu is
smaller than the tcp header).  connections will still stall
feedback from itojun@@, claudio@@ and provos and testing from beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.77 2004/03/02 12:51:12 markus Exp $	*/
a575 110
#ifdef RTV_RTT
	struct rtentry *rt;
#ifdef INET6
	int bound_to_specific = 0;  /* I.e. non-default */

	/*
	 * This code checks the nature of the route for this connection.
	 * Normally this is done by two simple checks in the next
	 * INET/INET6 ifdef block, but because of two possible lower layers,
	 * that check is done here.
	 *
	 * Perhaps should be doing this only for a RTF_HOST route.
	 */
	rt = inp->inp_route.ro_rt;  /* Same for route or route6. */
	if (tp->pf == PF_INET6) {
		if (rt)
			bound_to_specific =
			    !(IN6_IS_ADDR_UNSPECIFIED(&
			    ((struct sockaddr_in6 *)rt_key(rt))->sin6_addr));
	} else {
		if (rt)
			bound_to_specific =
			    (((struct sockaddr_in *)rt_key(rt))->
			    sin_addr.s_addr != INADDR_ANY);
	}
#endif /* INET6 */

	/*
	 * If we sent enough data to get some meaningful characteristics,
	 * save them in the routing entry.  'Enough' is arbitrarily
	 * defined as the sendpipesize (default 4K) * 16.  This would
	 * give us 16 rtt samples assuming we only get one sample per
	 * window (the usual case on a long haul net).  16 samples is
	 * enough for the srtt filter to converge to within 5% of the correct
	 * value; fewer samples and we could save a very bogus rtt.
	 *
	 * Don't update the default route's characteristics and don't
	 * update anything that the user "locked".
	 */
#ifdef INET6
	/*
	 * Note that rt and bound_to_specific are set above.
	 */
	if (SEQ_LT(tp->iss + so->so_snd.sb_hiwat * 16, tp->snd_max) &&
	    rt && bound_to_specific) {
#else /* INET6 */
	if (SEQ_LT(tp->iss + so->so_snd.sb_hiwat * 16, tp->snd_max) &&
	    (rt = inp->inp_route.ro_rt) &&
	    satosin(rt_key(rt))->sin_addr.s_addr != INADDR_ANY) {
#endif /* INET6 */
		u_long i = 0;

		if ((rt->rt_rmx.rmx_locks & RTV_RTT) == 0) {
			i = tp->t_srtt *
			    (RTM_RTTUNIT / (PR_SLOWHZ * TCP_RTT_SCALE));
			if (rt->rt_rmx.rmx_rtt && i)
				/*
				 * filter this update to half the old & half
				 * the new values, converting scale.
				 * See route.h and tcp_var.h for a
				 * description of the scaling constants.
				 */
				rt->rt_rmx.rmx_rtt =
				    (rt->rt_rmx.rmx_rtt + i) / 2;
			else
				rt->rt_rmx.rmx_rtt = i;
		}
		if ((rt->rt_rmx.rmx_locks & RTV_RTTVAR) == 0) {
			i = tp->t_rttvar *
			    (RTM_RTTUNIT / (PR_SLOWHZ * TCP_RTTVAR_SCALE));
			if (rt->rt_rmx.rmx_rttvar && i)
				rt->rt_rmx.rmx_rttvar =
				    (rt->rt_rmx.rmx_rttvar + i) / 2;
			else
				rt->rt_rmx.rmx_rttvar = i;
		}
		/*
		 * update the pipelimit (ssthresh) if it has been updated
		 * already or if a pipesize was specified & the threshhold
		 * got below half the pipesize.  I.e., wait for bad news
		 * before we start updating, then update on both good
		 * and bad news.
		 */
		if (((rt->rt_rmx.rmx_locks & RTV_SSTHRESH) == 0 &&
		    (i = tp->snd_ssthresh) && rt->rt_rmx.rmx_ssthresh) ||
		    i < (rt->rt_rmx.rmx_sendpipe / 2)) {
			/*
			 * convert the limit from user data bytes to
			 * packets then to packet data bytes.
			 */
			i = (i + tp->t_maxseg / 2) / tp->t_maxseg;
			if (i < 2)
				i = 2;
#ifdef INET6
			if (tp->pf == PF_INET6)
				i *= (u_long)(tp->t_maxseg + sizeof (struct tcphdr)
				    + sizeof(struct ip6_hdr));
			else
#endif /* INET6 */
				i *= (u_long)(tp->t_maxseg +
				    sizeof (struct tcpiphdr));

			if (rt->rt_rmx.rmx_ssthresh)
				rt->rt_rmx.rmx_ssthresh =
				    (rt->rt_rmx.rmx_ssthresh + i) / 2;
			else
				rt->rt_rmx.rmx_ssthresh = i;
		}
	}
#endif /* RTV_RTT */
@


1.77
log
@limit total number of queued out-of-order packets to NMBCLUSTERS/2; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.76 2004/02/27 16:44:45 markus Exp $	*/
d1021 1
d1024 1
d1034 3
a1036 5

			if (rt->rt_rmx.rmx_mtu != 0) {
				/* also takes care of congestion window */
				tcp_mss(tp, -1);
			}
d1038 1
d1041 1
a1041 1
		 * Resend unacknowledged packets.
d1044 2
a1045 1
		tcp_output(tp);
@


1.77.2.1
log
@MFC:
Fix by markus@@

verify th_seq in icmp errors; report Fernando Gont

ok deraadt@@ markus@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.77 2004/03/02 12:51:12 markus Exp $	*/
a803 1
	struct tcpcb *tp;
a807 1
	struct inpcb *inp;
a808 1
	tcp_seq seq;
a812 1
		u_int32_t th_seq;
d816 1
a816 3
	    sa->sa_len != sizeof(struct sockaddr_in6) ||
	    IN6_IS_ADDR_UNSPECIFIED(&sa6->sin6_addr) ||
	    IN6_IS_ADDR_V4MAPPED(&sa6->sin6_addr))
a861 8
		/*
		 * Check to see if we have a valid TCP connection
		 * corresponding to the address in the ICMPv6 message
		 * payload.
		 */
		inp = in6_pcbhashlookup(&tcbtable, &sa6->sin6_addr,
		    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
		    th.th_sport);
d863 12
d882 2
a883 1
			icmp6_mtudisc_update((struct ip6ctlparam *)d, inp != NULL);
d886 4
a889 8
		if (inp) {
			seq = ntohl(th.th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, inet6ctlerrmap[cmd]);
		} else if (syn_cache_count &&
a909 4
	struct tcpcb *tp;
	struct inpcb *inp;
	struct in_addr faddr;
	tcp_seq seq;
a915 3
	faddr = satosin(sa)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return NULL;
d924 2
a925 1
	else if (cmd == PRC_MSGSIZE && ip_mtudisc && ip) {
d930 6
a935 7
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		seq = ntohl(th->th_seq);
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
		if (inp && (tp = intotcpcb(inp)) &&
		    SEQ_GEQ(seq, tp->snd_una) &&
		    SEQ_LT(seq, tp->snd_max)) {
a941 3
		} else {
			/* ignore if we don't have a matching connection */
			return NULL;
d953 3
a955 10
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
		if (inp) {
			seq = ntohl(th->th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, errno);
		} else if (syn_cache_count &&
@


1.77.2.2
log
@MFC:
Fix by markus@@

- check th_ack against snd_una/max; from Raja Mukerji via hugh@@
- limit pool to tcp_sackhole_limit entries (sysctl-able)
- stop sack option processing on pool_get errors
- use SEQ_MIN/SEQ_MAX

ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.77.2.1 2004/08/20 22:41:33 brad Exp $	*/
a151 3
#ifdef TCP_SACK
int tcp_sackhole_limit = 32*1024; /* hardlimit for sackhl_pool */
#endif
a182 1
	pool_sethardlimit(&sackhl_pool, tcp_sackhole_limit, NULL, 0);
@


1.76
log
@implement tcp_drain() similar to ip_drain(); ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.75 2004/01/31 19:40:10 markus Exp $	*/
d151 2
d158 1
a162 2
int	tcp_freeq(struct tcpcb *);

d177 3
d724 1
a724 1
		pool_put(&ipqent_pool, qe);
@


1.75
log
@!sack_disable -> sack_enable; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.74 2004/01/29 11:55:28 markus Exp $	*/
d684 1
d686 1
d729 1
d731 12
@


1.74
log
@support for RFC3390 (Increasing TCP's Initial Window); ok deraadt, itojun
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.73 2004/01/09 12:22:30 markus Exp $	*/
d497 1
a497 1
	tp->sack_disable = tcp_do_sack ? 0 : 1;
@


1.73
log
@don't restrict tcp signature keys to ascii; ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.72 2004/01/06 17:38:13 markus Exp $	*/
d134 1
@


1.72
log
@import netbsd's version of David Borman's syncache code
http://www.kohala.com/start/borman.97jun06.txt; ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.71 2003/12/10 07:22:43 itojun Exp $	*/
a1059 5
	char *c;
#define isdigit(c)	  (((c) >= '0') && ((c) <= '9'))
#define isalpha(c)	( (((c) >= 'A') && ((c) <= 'Z')) || \
			  (((c) >= 'a') && ((c) <= 'z')) )

a1060 17
		return (EINVAL);

	c = (char *)ii->ii_authkey;

	while (c < (char *)ii->ii_authkey + ii->ii_authkeylen - 1) {
		if (isdigit(*c)) {
			if (*(c + 1) == ' ')
				return (EINVAL);
		} else {
			if (!isalpha(*c))
				return (EINVAL);
		}

		c++;
	}

	if (!isdigit(*c) && !isalpha(*c))
@


1.71
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.70 2003/11/04 21:43:16 markus Exp $	*/
d142 8
d196 3
d687 1
d867 8
a874 2
		(void) in6_pcbnotify(&tcbtable, sa, th.th_dport,
		    (struct sockaddr *)sa6_src, th.th_sport, cmd, NULL, notify);
d933 16
a948 2
		in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
			     th->th_sport, errno, notify);
@


1.70
log
@add in(6)_pcblookup_listen() and replace all calls to in_pcblookup()
with either in(6)_pcbhashlookup() or in(6)_pcblookup_listen();
in_pcblookup is now only used by bind(2); speeds up pcb lookup for
listening sockets; from Claudio Jeker
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.69 2003/10/01 21:41:05 itojun Exp $	*/
d207 3
a209 3
	register struct inpcb *inp = tp->t_inpcb;
	register struct mbuf *m;
	register struct tcphdr *th;
d323 1
a323 1
	register struct mbuf *m;
d327 1
a327 1
	register int tlen;
d330 2
a331 2
	register struct tcphdr *th;
	register struct tcpiphdr *ti = (struct tcpiphdr *)template;
d529 1
a529 1
	register struct tcpcb *tp;
d561 1
a561 1
	register struct rtentry *rt;
d563 1
a563 1
	register int bound_to_specific = 0;  /* I.e. non-default */
d610 1
a610 1
		register u_long i = 0;
d740 2
a741 2
	register struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;
	register struct socket *so = inp->inp_socket;
d868 1
a868 1
	register void *v;
d870 2
a871 2
	register struct ip *ip = v;
	register struct tcphdr *th;
@


1.69
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.68 2003/07/09 22:03:16 itojun Exp $	*/
a841 4
			else if (in_pcblookup(&tcbtable, &sa6->sin6_addr,
			    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
			    th.th_sport, INPLOOKUP_IPV6))
				valid++;
d892 6
a897 4
		if (in_pcblookup(&tcbtable,
				 &ip->ip_dst, th->th_dport,
				 &ip->ip_src, th->th_sport,
				 INPLOOKUP_WILDCARD)) {
@


1.68
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.67 2003/06/02 23:28:14 millert Exp $	*/
d277 1
a277 1
			    (inp->inp_ipv6.ip6_flow & htonl(0x0fffffff));
@


1.68.2.1
log
@MFC:
Fix by markus@@

implement tcp_drain() similar to ip_drain();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.68 2003/07/09 22:03:16 itojun Exp $	*/
a671 1
	tcp_reass_lock(tp);
a672 1
	tcp_reass_unlock(tp);
d714 1
a714 14
	struct inpcb *inp;
 
	/* called at splimp() */
	CIRCLEQ_FOREACH(inp, &tcbtable.inpt_queue, inp_queue) {
		struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;

		if (tp != NULL) {
			if (tcp_reass_lock_try(tp) == 0)
				continue;
			if (tcp_freeq(tp))
				tcpstat.tcps_conndrained++;
			tcp_reass_unlock(tp);
		}
	}
@


1.68.2.2
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.68.2.1 2004/03/03 02:35:26 brad Exp $	*/
a141 2
int tcp_reass_limit = NMBCLUSTERS / 2; /* hardlimit for tcpqe_pool */

a146 1
struct pool tcpqe_pool;
d151 2
a166 3
	pool_init(&tcpqe_pool, sizeof(struct ipqent), 0, 0, 0, "tcpqepl",
	    NULL);
	pool_sethardlimit(&tcpqe_pool, tcp_reass_limit, NULL, 0);
d707 1
a707 1
		pool_put(&tcpqe_pool, qe);
@


1.68.2.3
log
@MFC:
Fix by markus@@

verify th_seq in icmp errors; report Fernando Gont

ok deraadt@@ markus@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.68.2.2 2004/03/03 08:37:05 brad Exp $	*/
a790 1
	struct tcpcb *tp;
a794 1
	struct inpcb *inp;
a795 1
	tcp_seq seq;
a799 1
		u_int32_t th_seq;
d803 1
a803 3
	    sa->sa_len != sizeof(struct sockaddr_in6) ||
	    IN6_IS_ADDR_UNSPECIFIED(&sa6->sin6_addr) ||
	    IN6_IS_ADDR_V4MAPPED(&sa6->sin6_addr))
a848 8
		/*
		 * Check to see if we have a valid TCP connection
		 * corresponding to the address in the ICMPv6 message
		 * payload.
		 */
		inp = in6_pcbhashlookup(&tcbtable, &sa6->sin6_addr,
		    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
		    th.th_sport);
d850 16
d873 2
a874 1
			icmp6_mtudisc_update((struct ip6ctlparam *)d, inp != NULL);
d877 3
a879 8
		if (inp) {
			seq = ntohl(th.th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, inet6ctlerrmap[cmd]);
		}
a894 4
	struct tcpcb *tp;
	struct inpcb *inp;
	struct in_addr faddr;
	tcp_seq seq;
a900 3
	faddr = satosin(sa)->sin_addr;
	if (faddr.s_addr == INADDR_ANY)
		return NULL;
d909 2
a910 1
	else if (cmd == PRC_MSGSIZE && ip_mtudisc && ip) {
d915 4
a918 7
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		seq = ntohl(th->th_seq);
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
		if (inp && (tp = intotcpcb(inp)) &&
		    SEQ_GEQ(seq, tp->snd_una) &&
		    SEQ_LT(seq, tp->snd_max)) {
a924 3
		} else {
			/* ignore if we don't have a matching connection */
			return NULL;
d936 2
a937 10
		inp = in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport);
		if (inp) {
			seq = ntohl(th->th_seq);
			if (inp->inp_socket &&
			    (tp = intotcpcb(inp)) &&
			    SEQ_GEQ(seq, tp->snd_una) &&
			    SEQ_LT(seq, tp->snd_max))
				notify(inp, errno);
		}
@


1.67
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.66 2003/05/12 00:48:52 jason Exp $	*/
d454 1
a454 1
		((struct ip *)ti)->ip_len = tlen;
@


1.66
log
@Nuke a whole bunch of commons; ok tedu (still more to come *sigh*)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.65 2002/08/28 15:43:03 pefo Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.65
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.64 2002/06/09 16:26:11 itojun Exp $	*/
d139 2
d158 1
@


1.65.4.1
log
@MFC:
Fix by markus@@

implement tcp_drain() similar to ip_drain();

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.65 2002/08/28 15:43:03 pefo Exp $	*/
a672 1
	tcp_reass_lock(tp);
a673 1
	tcp_reass_unlock(tp);
d715 1
a715 14
	struct inpcb *inp;
 
	/* called at splimp() */
	CIRCLEQ_FOREACH(inp, &tcbtable.inpt_queue, inp_queue) {
		struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;

		if (tp != NULL) {
			if (tcp_reass_lock_try(tp) == 0)
				continue;
			if (tcp_freeq(tp))
				tcpstat.tcps_conndrained++;
			tcp_reass_unlock(tp);
		}
	}
@


1.65.4.2
log
@MFC:
Fix by markus@@

limit total number of queued out-of-order packets to NMBCLUSTERS/2;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.65.4.1 2004/03/03 02:35:59 brad Exp $	*/
a143 2
int tcp_reass_limit = NMBCLUSTERS / 2; /* hardlimit for tcpqe_pool */

a148 1
struct pool tcpqe_pool;
d153 2
a167 3
	pool_init(&tcpqe_pool, sizeof(struct ipqent), 0, 0, 0, "tcpqepl",
	    NULL);
	pool_sethardlimit(&tcpqe_pool, tcp_reass_limit, NULL, 0);
d708 1
a708 1
		pool_put(&tcpqe_pool, qe);
@


1.64
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.63 2002/06/07 16:18:02 itojun Exp $	*/
d457 2
a458 3
		ip_output(m, NULL, ro, ip_mtudisc ? IP_MTUDISC : 0, NULL,
		    tp ? tp->t_inpcb : NULL);
		break;
@


1.63
log
@avoid is_ipv6 construct.  a step towards IPv4-less kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.62 2002/05/16 14:10:51 kjc Exp $	*/
d37 1
a37 1
 * 
d41 1
a41 1
 * 
d56 1
a56 1
 * 
d68 1
a68 1
 * 
d201 1
a201 1
 * for the TCP header.  Also, we made the former tcpiphdr header pointer 
d236 1
a236 1
		 */ 
d278 2
a279 2
			    (inp->inp_ipv6.ip6_flow & htonl(0x0fffffff));  
						  
d402 1
a402 1
		tlen += sizeof(struct tcphdr) + sizeof(struct ip6_hdr); 
d514 1
a514 1
	if (inp->inp_flags & INP_IPV6) 
d591 1
a591 1
	 * save them in the routing entry.  'Enough' is arbitrarily 
d720 1
a720 1
 * Compute proper scaling value for receiver window from buffer space 
d759 1
a759 1
	else 
d1013 1
a1013 1
		
d1123 1
a1123 1
  
d1139 1
a1139 1
	tcp_rndiss_msb = tcp_rndiss_msb == 0x8000 ? 0 : 0x8000; 
d1149 1
a1149 1
	
@


1.62
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.61 2002/03/14 01:27:11 millert Exp $	*/
d271 1
a271 1
			struct ip6_hdr *ipv6;
d273 1
a273 1
			ipv6 = mtod(m, struct ip6_hdr *);
d275 3
a277 3
			ipv6->ip6_src = inp->inp_laddr6;
			ipv6->ip6_dst = inp->inp_faddr6;
			ipv6->ip6_flow = htonl(0x60000000) |
d280 3
a282 3
			ipv6->ip6_nxt = IPPROTO_TCP;
			ipv6->ip6_plen = htons(sizeof(struct tcphdr)); /*XXX*/
			ipv6->ip6_hlim = in6_selecthlim(inp, NULL);	/*XXX*/
d333 1
a333 3
#ifdef INET6
	int is_ipv6 = 0;   /* true iff IPv6 */
#endif /* INET6 */
a336 1
#ifdef INET6
d341 1
a341 1
		is_ipv6 = (tp->pf == PF_INET6);
a346 1
#endif /* INET6 */
d348 2
a349 5
	}
#ifdef INET6
	else
		is_ipv6 = (((struct ip *)ti)->ip_v == 6);
#endif /* INET6 */
d360 1
d362 1
a362 1
		if (is_ipv6)
d365 1
a365 1
		else
d367 1
d370 2
d380 2
a381 1
#define xchg(a,b,type) { type t; t=a; a=b; b=t; }
d383 1
a383 1
		if (is_ipv6) {
d385 2
a386 3
			xchg(((struct ip6_hdr *)ti)->ip6_dst,\
			    ((struct ip6_hdr *)ti)->ip6_src,\
			    struct in6_addr);
d388 1
a388 1
		} else
d390 1
a390 1
		{
d394 1
d399 1
d401 1
a401 1
	if (is_ipv6) {
d404 1
a404 1
	} else
d406 1
a406 1
	{
d410 1
d428 1
d430 1
a430 1
	if (is_ipv6) {
d441 2
a442 2
			(struct route_in6 *)ro, 0, NULL, NULL);
	} else
d444 1
a444 1
	{
d458 2
a459 1
			  tp ? tp->t_inpcb : NULL);
@


1.61
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.60 2002/03/08 03:49:58 provos Exp $	*/
d137 1
@


1.60
log
@use timeout(9) to schedule TCP timers.  this avoid traversing all
tcp connections during tcp_slowtimo.  apdapted from thorpej@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.59 2002/03/02 00:44:52 provos Exp $	*/
d152 1
a152 1
int	tcp_freeq __P((struct tcpcb *));
d771 1
a771 1
	void (*notify) __P((struct inpcb *, int)) = tcp_notify;
d876 1
a876 1
	void (*notify) __P((struct inpcb *, int)) = tcp_notify;
@


1.59
log
@disable immediate ack on TH_PUSH.  make behaviour sysctl tuneable.
from netbsd; also fix a bug where setting TF_ACKNOW didn't actually
result in an ack.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.58 2002/03/01 22:29:29 provos Exp $	*/
d673 1
@


1.58
log
@remove tcp_fasttimo and convert delayed acks to the timeout(9) API instead.
adapated from netbsd.  okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.57 2002/01/24 22:42:49 provos Exp $	*/
d126 1
a126 1
int    tcp_do_rfc1323 = TCP_DO_RFC1323;
d135 2
a136 1
int    tcp_do_sack = TCP_DO_SACK;		/* RFC 2018 selective ACKs */
@


1.57
log
@allocate tcp reassembly queue via pool; based on netbsd; okay art@@ angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.56 2002/01/23 00:39:48 art Exp $	*/
d186 3
d478 1
d671 2
@


1.56
log
@Pool deals fairly well with physical memory shortage, but it doesn't deal
well (not at all) with shortages of the vm_map where the pages are mapped
(usually kmem_map).

Try to deal with it:
 - group all information the backend allocator for a pool in a separate
   struct. The pool will only have a pointer to that struct.
 - change the pool_init API to reflect that.
 - link all pools allocating from the same allocator on a linked list.
 - Since an allocator is responsible to wait for physical memory it will
   only fail (waitok) when it runs out of its backing vm_map, carefully
   drain pools using the same allocator so that va space is freed.
   (see comments in code for caveats and details).
 - change pool_reclaim to return if it actually succeeded to free some
   memory, use that information to make draining easier and more efficient.
 - get rid of PR_URGENT, noone uses it.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.55 2002/01/15 19:18:01 provos Exp $	*/
d151 2
d547 1
a547 2
tcp_close(tp)
	register struct tcpcb *tp;
a548 1
	register struct ipqent *qe;
d666 2
a667 19
#ifdef INET6
	/* Reassembling TCP segments in v6 might be sufficiently different
	 * to merit two codepaths to free the reasssembly queue.
	 * If an undecided TCP socket, then the IPv4 codepath will be used 
	 * because it won't matter much anyway.
	 */
	if (tp->pf == AF_INET6) {
		while ((qe = tp->segq.lh_first) != NULL) {
			LIST_REMOVE(qe, ipqe_q);
			m_freem(qe->ipqe_m);
			FREE(qe, M_IPQ);
		}
	} else
#endif /* INET6 */
		while ((qe = tp->segq.lh_first) != NULL) {
			LIST_REMOVE(qe, ipqe_q);
			m_freem(qe->ipqe_m);
			FREE(qe, M_IPQ);
		}
d685 15
@


1.55
log
@allocate sackholes with pool
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.54 2002/01/15 16:59:08 provos Exp $	*/
d163 1
a163 1
	    0, NULL, NULL, M_PCB);
d166 1
a166 1
	    0, NULL, NULL, M_PCB);
@


1.54
log
@change tcpcb allocation to pool
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.53 2002/01/14 03:11:55 provos Exp $	*/
d147 3
d164 4
d690 1
a690 1
		free(p, M_PCB);
@


1.53
log
@use macros to manage tcp timers; based on netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.51 2001/07/18 00:18:51 marc Exp $	*/
d146 2
d159 2
d458 1
a458 1
	tp = malloc(sizeof(*tp), M_PCB, M_NOWAIT);
d689 1
a689 1
	free(tp, M_PCB);
@


1.52
log
@repair IPv6 TCP.  th_sum has to be initialized to 0 on template.
(older code had "th_sum = 0" at the bottom of the function, which was
removed during TCP hardware checksumming change)
@
text
@d449 1
a449 2
tcp_newtcpcb(inp)
	struct inpcb *inp;
d451 2
a452 1
	register struct tcpcb *tp;
d461 4
a464 1
  
@


1.52.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.57 2002/01/24 22:42:49 provos Exp $	*/
a145 7
struct pool tcpcb_pool;
#ifdef TCP_SACK
struct pool sackhl_pool;
#endif

int	tcp_freeq __P((struct tcpcb *));

a156 6
	pool_init(&tcpcb_pool, sizeof(struct tcpcb), 0, 0, 0, "tcpcbpl",
	    NULL);
#ifdef TCP_SACK
	pool_init(&sackhl_pool, sizeof(struct sackhole), 0, 0, 0, "sackhlpl",
	    NULL);
#endif /* TCP_SACK */
d449 2
a450 1
tcp_newtcpcb(struct inpcb *inp)
d452 1
a452 2
	struct tcpcb *tp;
	int i;
d454 1
a454 1
	tp = pool_get(&tcpcb_pool, PR_NOWAIT);
d461 1
a461 4

	for (i = 0; i < TCPT_NTIMERS; i++)
		TCP_TIMER_INIT(tp, i);

d531 2
a532 1
tcp_close(struct tcpcb *tp)
d534 1
d652 19
a670 2
	tcp_freeq(tp);

d676 1
a676 1
		pool_put(&sackhl_pool, p);
d682 1
a682 1
	pool_put(&tcpcb_pool, tp);
a687 15
}

int
tcp_freeq(struct tcpcb *tp)
{
	struct ipqent *qe;
	int rv = 0;

	while ((qe = LIST_FIRST(&tp->segq)) != NULL) {
		LIST_REMOVE(qe, ipqe_q);
		m_freem(qe->ipqe_m);
		pool_put(&ipqent_pool, qe);
		rv = 1;
	}
	return (rv);
@


1.52.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.52.4.1 2002/01/31 22:55:45 niklas Exp $	*/
d126 1
a126 1
int	tcp_do_rfc1323 = TCP_DO_RFC1323;
d135 1
a135 3
int	tcp_do_sack = TCP_DO_SACK;		/* RFC 2018 selective ACKs */
int	tcp_ack_on_push = 0;	/* set to enable immediate ACK-on-PUSH */
int	tcp_do_ecn = 0;		/* RFC3168 ECN enabled/disabled? */
d151 1
a151 1
int	tcp_freeq(struct tcpcb *);
a185 3

	/* Initialize timer state. */
	tcp_timer_init();
d266 1
a266 1
			struct ip6_hdr *ip6;
d268 1
a268 1
			ip6 = mtod(m, struct ip6_hdr *);
d270 3
a272 3
			ip6->ip6_src = inp->inp_laddr6;
			ip6->ip6_dst = inp->inp_faddr6;
			ip6->ip6_flow = htonl(0x60000000) |
d275 3
a277 3
			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_plen = htons(sizeof(struct tcphdr)); /*XXX*/
			ip6->ip6_hlim = in6_selecthlim(inp, NULL);	/*XXX*/
d328 3
a330 1
	int af;		/* af on wire */
d334 1
d339 1
a339 1
		af = tp->pf;
d345 1
d347 5
a351 2
	} else
		af = (((struct ip *)ti)->ip_v == 6) ? AF_INET6 : AF_INET;
a361 1
		switch (af) {
d363 1
a363 1
		case AF_INET6:
d366 1
a366 1
			break;
a367 1
		case AF_INET:
a369 2
			break;
		}
d378 1
a378 2
#define xchg(a,b,type) do { type t; t=a; a=b; b=t; } while (0)
		switch (af) {
d380 1
a380 1
		case AF_INET6:
d382 3
a384 2
			xchg(((struct ip6_hdr *)ti)->ip6_dst,
			    ((struct ip6_hdr *)ti)->ip6_src, struct in6_addr);
d386 1
a386 1
			break;
d388 1
a388 1
		case AF_INET:
a391 1
			break;
a395 1
	switch (af) {
d397 1
a397 1
	case AF_INET6:
d400 1
a400 1
		break;
d402 1
a402 1
	case AF_INET:
a405 1
		break;
a422 1
	switch (af) {
d424 1
a424 1
	case AF_INET6:
d435 2
a436 2
		    (struct route_in6 *)ro, 0, NULL, NULL);
		break;
d438 1
a438 1
	case AF_INET:
d452 1
a452 2
		    tp ? tp->t_inpcb : NULL);
		break;
a474 1
	TCP_INIT_DELACK(tp);
a667 3
	tcp_canceltimers(tp);
	TCP_CLEAR_DELACK(tp);

d763 1
a763 1
	void (*notify)(struct inpcb *, int) = tcp_notify;
d868 1
a868 1
	void (*notify)(struct inpcb *, int) = tcp_notify;
@


1.52.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.52.4.2 2002/06/11 03:31:37 art Exp $	*/
d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
d201 1
a201 1
 * for the TCP header.  Also, we made the former tcpiphdr header pointer
d236 1
a236 1
		 */
d278 2
a279 2
			    (inp->inp_ipv6.ip6_flow & htonl(0x0fffffff));

d402 1
a402 1
		tlen += sizeof(struct tcphdr) + sizeof(struct ip6_hdr);
d457 3
a459 2
		ip_output(m, (void *)NULL, ro, ip_mtudisc ? IP_MTUDISC : 0,
			(void *)NULL, tp ? tp->t_inpcb : (void *)NULL);
d514 1
a514 1
	if (inp->inp_flags & INP_IPV6)
d591 1
a591 1
	 * save them in the routing entry.  'Enough' is arbitrarily
d720 1
a720 1
 * Compute proper scaling value for receiver window from buffer space
d759 1
a759 1
	else
d1013 1
a1013 1

d1123 1
a1123 1

d1139 1
a1139 1
	tcp_rndiss_msb = tcp_rndiss_msb == 0x8000 ? 0 : 0x8000;
d1149 1
a1149 1

@


1.52.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a138 2
u_int32_t	tcp_now;

a155 1
tcp_seq  tcp_iss;
@


1.51
log
@zero tcp checksum field before calculating new value.
Fixes problem with bad checksums on keepalives
OK provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.50 2001/07/03 04:26:37 angelos Exp $	*/
a261 1

d268 1
@


1.50
log
@Pointer arithmetic fixes work better when you get the casting right.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.49 2001/06/26 06:56:41 aaron Exp $	*/
d434 1
@


1.49
log
@Appease gcc by not using void pointers in arithmetic operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.48 2001/06/25 01:59:29 angelos Exp $	*/
d372 1
a372 1
			th = (void *)(ti + sizeof(struct ip6_hdr));
d378 1
a378 1
			th = (void *)(ti + sizeof(struct ip));
@


1.48
log
@Always defer output TCP checksumming until ip_output() (or hardware,
if it exists). Cuts down on code a bit, and we don't need to look at
the routing entry at TCP. Based on NetBSD. UDP case to follow.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.47 2001/06/23 19:02:53 angelos Exp $	*/
d372 1
a372 1
			th = (void *)ti + sizeof(struct ip6_hdr);
d378 1
a378 1
			th = (void *)ti + sizeof(struct ip);
@


1.47
log
@Add comment on why checksum deferral is not useful in tcp_respond()
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.46 2001/06/08 03:53:46 angelos Exp $	*/
d238 1
a238 2
			ipovly->ih_len = htons(sizeof (struct tcpiphdr) -
				sizeof (struct ip));
d244 3
a281 1
	th->th_sum = 0;
@


1.46
log
@Cut down on include files.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.45 2001/06/05 02:31:36 deraadt Exp $	*/
d427 6
@


1.45
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.44 2001/06/04 18:16:43 mickey Exp $	*/
d76 1
a77 2
#include <sys/systm.h>
#include <sys/malloc.h>
a81 2
#include <sys/errno.h>
#include <sys/time.h>
a101 3
#include <netinet6/ip6_var.h>
#include <netinet6/tcpipv6.h>
#include <sys/domain.h>
@


1.44
log
@use faster arc4random() in tcp_rndiss_next; niels ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.43 2001/05/31 20:36:47 angelos Exp $	*/
d36 37
a72 1
 *	@@(#)tcp_subr.c	8.1 (Berkeley) 6/10/93
a73 12

/*
%%% portions-copyright-nrl-95
Portions of this software are Copyright 1995-1998 by Randall Atkinson,
Ronald Lee, Daniel McDonald, Bao Phan, and Chris Winters. All Rights
Reserved. All rights under this copyright have been assigned to the US
Naval Research Laboratory (NRL). The NRL Copyright Notice and License
Agreement Version 1.1 (January 17, 1995) applies to these portions of the
software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
*/
@


1.43
log
@Match IPSEC output prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.42 2001/05/01 18:31:35 fgsch Exp $	*/
a1096 2
	u_int16_t tmp;

d1101 1
a1101 3
	get_random_bytes(&tmp, sizeof(tmp));

	/* (tmp & 0x7fff) ensures a 32768 byte gap between ISS */
d1103 1
a1103 1
		(tmp & 0x7fff);
@


1.42
log
@Fix tcp_signature_tdb_input decl; kernel compiles again if TCP_SIGNATURE
option is used. Note that this does not work.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.41 2001/04/06 04:42:09 csapuntz Exp $	*/
d1040 1
a1040 1
tcp_signature_tdb_output(m, tdbp, mp, skip, protoff, tdb2)
a1044 1
	struct tdb *tdb2;
@


1.41
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.40 2001/03/14 19:21:33 mickey Exp $	*/
d1040 1
a1040 1
tcp_signature_tdb_output(m, tdbp, mp, skip, protoff)
d1045 1
@


1.40
log
@provide a random start for tcp timestamps; niels@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.39 2001/02/16 16:00:54 itojun Exp $	*/
a90 4

#ifndef offsetof
#define offsetof(type, member)	((size_t)(&((type *)0)->member))
#endif
@


1.39
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.38 2000/12/21 00:54:10 itojun Exp $	*/
d144 1
@


1.38
log
@correct ipv6 path mtu discovery.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.37 2000/12/13 09:47:08 provos Exp $	*/
a726 1
	struct tcphdr *thp;
a728 2
	int nmatch;
	struct sockaddr_in6 sa6;
d730 2
d734 4
a737 2
	struct in6_addr finaldst;
	struct in6_addr s;
d762 1
a762 10

		/* translate addresses into internal form */
		bcopy(ip6cp->ip6c_finaldst, &finaldst, sizeof(finaldst));
		if (IN6_IS_ADDR_LINKLOCAL(&finaldst)) {
			finaldst.s6_addr16[1] =
			    htons(m->m_pkthdr.rcvif->if_index);
		}
		bcopy(&ip6->ip6_src, &s, sizeof(s));
		if (IN6_IS_ADDR_LINKLOCAL(&s))
			s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d766 1
a768 5
	/* translate addresses into internal form */
	sa6 = *(struct sockaddr_in6 *)sa;
	if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)
		sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

d776 1
a776 1
		if (m->m_pkthdr.len < off + sizeof(th))
d779 6
a784 9
		if (m->m_len < off + sizeof(th)) {
			/*
			 * this should be rare case,
			 * so we compromise on this copy...
			 */
			m_copydata(m, off, sizeof(th), (caddr_t)&th);
			thp = &th;
		} else
			thp = (struct tcphdr *)(mtod(m, caddr_t) + off);
d794 7
a800 3
			if (in_pcblookup(&tcbtable, &finaldst,
			    thp->th_dport, &s, thp->th_sport,
			    INPLOOKUP_WILDCARD))
d804 5
a808 4
			 * Now that we've validated that we are actually
			 * communicating with the host indicated in the ICMPv6
			 * message, recalculate the new MTU, and create the
			 * corresponding routing entry.
d815 2
a816 2
		nmatch = in6_pcbnotify(&tcbtable, (struct sockaddr *)&sa6,
		    thp->th_dport, &s, thp->th_sport, cmd, notify);
d818 2
a819 2
		(void) in6_pcbnotify(&tcbtable, (struct sockaddr *)&sa6, 0,
		    &zeroin6_addr, 0, cmd, notify);
d874 1
a874 1
		    th->th_sport, errno, notify);
d896 19
a971 19

#ifdef INET6
/*
 * Path MTU Discovery handlers.
 */
void
tcp6_mtudisc_callback(faddr)
	struct in6_addr *faddr;
{
	struct sockaddr_in6 sin6;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *faddr;
	(void) in6_pcbnotify(&tcbtable, (struct sockaddr *)&sin6, 0,
	    &zeroin6_addr, 0, PRC_MSGSIZE, tcp_mtudisc);
}
#endif /* INET6 */
@


1.37
log
@more random tcp sequence numbers. okay deraadt@@, angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.36 2000/12/11 08:04:55 itojun Exp $	*/
d979 1
a979 1
	    &zeroin6_addr, 0, EMSGSIZE, tcp_mtudisc);
@


1.36
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.35 2000/10/13 17:58:36 itojun Exp $	*/
d60 2
d142 1
a142 3
#else /* TCP_COMPAT_42 */
	tcp_iss = arc4random() + 1;
#endif /* !TCP_COMPAT_42 */
d1072 51
@


1.35
log
@validate mbuf chain length on *_ctlinput.  remote node may be able to
transmit a truncated icmp6 packet and panic the system.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.34 2000/10/10 15:16:02 provos Exp $	*/
d155 2
d720 1
a720 1
#if defined(INET6) && !defined(TCP6)
d727 1
a727 1
	register struct tcphdr *thp;
d730 1
d732 1
a733 1
	struct ip6_hdr *ip6;
d735 3
a737 1
	
d741 4
a744 1
	if (cmd == PRC_QUENCH)
d746 2
d749 4
a752 3
		notify = tcp_mtudisc;
	else if (!PRC_IS_REDIRECT(cmd) &&
		 ((unsigned)cmd > PRC_NCMDS || inet6ctlerrmap[cmd] == 0))
d761 10
d780 1
d783 1
a783 1
		 * XXX: We assume that when IPV6 is non NULL,
a785 10
		struct ip6_hdr ip6_tmp;

		/* translate addresses into internal form */
		ip6_tmp = *ip6;
		if (IN6_IS_ADDR_LINKLOCAL(&ip6_tmp.ip6_src))
			ip6_tmp.ip6_src.s6_addr16[1] =
				htons(m->m_pkthdr.rcvif->if_index);
		if (IN6_IS_ADDR_LINKLOCAL(&ip6_tmp.ip6_dst))
			ip6_tmp.ip6_dst.s6_addr16[1] =
				htons(m->m_pkthdr.rcvif->if_index);
d800 27
a826 3
		(void)in6_pcbnotify(&tcbtable, (struct sockaddr *)&sa6,
				    thp->th_dport, &ip6_tmp.ip6_src,
				    thp->th_sport, cmd, notify);
d828 2
a829 2
		(void)in6_pcbnotify(&tcbtable, (struct sockaddr *)&sa6, 0,
				    &zeroin6_addr, 0, cmd, notify);
d884 1
a884 1
			     th->th_sport, errno, notify);
d963 19
@


1.34
log
@verify payload of the icmp need fragment message at the tcp layer. okay itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.33 2000/09/25 09:41:03 provos Exp $	*/
d774 4
@


1.33
log
@on expiry of pmtu route, retry higher mtu. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.32 2000/09/20 17:00:23 provos Exp $	*/
d90 4
d816 17
a832 1
	else if (cmd == PRC_MSGSIZE && ip_mtudisc)
d834 1
a834 1
	else if (cmd == PRC_MTUINC)
@


1.32
log
@correctly calculate mss
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.31 2000/09/18 22:06:38 provos Exp $	*/
d814 2
d875 1
a875 1
	    
d881 20
@


1.31
log
@Path MTU discovery based on NetBSD but with the decision to use the DF
flag delayed to ip_output().  That halves the code and reduces most of
the route lookups. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.30 2000/07/11 19:18:17 provos Exp $	*/
d430 3
a432 2
	tp->t_maxseg = tp->t_maxopd = tcp_mssdflt;

a867 8
			/*
			 * Slow start out of the error condition.  We
			 * use the MTU because we know it's smaller
			 * than the previously transmitted segment.
			 *
			 * Note: This is more conservative than the
			 * suggestion in RFC 2414
			 */
d869 1
a870 1
				tp->snd_cwnd = rt->rt_rmx.rmx_mtu;
@


1.30
log
@forgot to reset rscale
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.29 2000/07/11 16:53:22 provos Exp $	*/
d409 2
a410 1
		ip_output(m, NULL, ro, 0, NULL, tp ? tp->t_inpcb : NULL);
a732 1
#if 0
a734 1
#endif
d811 2
d841 46
@


1.29
log
@compute correct window scale when recvpipe option is set in route; based
on diff from "Pete Kazmier" <pete@@kazmier.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.28 2000/07/05 22:51:10 itojun Exp $	*/
d672 1
@


1.28
log
@more cleanup for IPv4 mapped address support.  there seem to be some
inconsistency in corner cases (from NRL I believe).
todd (fries) and I have seen panic, with the following call chain:
ip6_input -> tcp_input -> tcp_respond -> ip_input -> bang!

more cleanups should be done, to decrease complexity.
for example, INP_IPV6_MAPPED should be nuked.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.27 2000/06/26 22:45:09 art Exp $	*/
d663 12
@


1.27
log
@Make the definition of tcpstat in tcp_var.h extern.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.26 2000/06/03 13:04:39 itojun Exp $	*/
d449 1
a449 7
	/*
	 * If we want to use tp->pf for a quick-n-easy way to determine
	 * the outbound dgram type, we cannot make this decision
	 * until a connection is established!  Bzero() sets pf to zero, and
	 * that's the way we want it, unless, of course, it's an AF_INET
	 * socket...
	 */
d451 3
a453 1
		tp->pf = PF_INET;  /* If AF_INET socket, we can't do v6 from it. */
@


1.26
log
@correctly handle ctlinput messages for IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.25 2000/03/21 04:53:13 angelos Exp $	*/
d125 2
@


1.25
log
@Fix function to comply with prototype. Kind of moot, as tcp signatures
don't work yet anyhow, so there's no point compiling them in.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.24 2000/02/29 05:25:53 itojun Exp $	*/
d82 2
d708 68
a775 1
	(void)tcp_ctlinput(cmd, sa, NULL);	/*XXX*/
d791 3
d806 4
a809 16
#ifdef INET6
	if (sa->sa_family == AF_INET6) {
		if (ip) {
			struct ip6_hdr *ipv6 = (struct ip6_hdr *)ip;

			th = (struct tcphdr *)(ipv6 + 1);
#if 0 /*XXX*/
			in6_pcbnotify(&tcbtable, sa, th->th_dport,
			    &ipv6->ip6_src, th->th_sport, cmd, notify);
#endif
		} else {
#if 0 /*XXX*/
			in6_pcbnotify(&tcbtable, sa, 0,
			    (struct in6_addr *)&in6addr_any, 0, cmd, notify);
#endif
		}
d811 2
a812 9
#endif /* INET6 */
	{
		if (ip) {
			th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
			in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
			    th->th_sport, errno, notify);
		} else
			in_pcbnotifyall(&tcbtable, sa, errno, notify);
	}
@


1.24
log
@ensure tcp window size does not overflow (16bit unsigned after window scale).
FreeBSD PR: 16914
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.23 1999/12/29 20:27:55 mickey Exp $	*/
d838 1
a838 1
struct mbuf *
@


1.23
log
@fix _input/_output proto changes for tcp_signature; angelos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.22 1999/12/21 14:09:48 provos Exp $	*/
d378 4
a381 3
		th->th_win = htons((u_int16_t) (win >> tp->rcv_scale));
	else
		th->th_win = htons((u_int16_t)win);
@


1.23.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d378 3
a380 4
		win >>= tp->rcv_scale;
	if (win > TCP_MAXWIN)
		win = TCP_MAXWIN;
	th->th_win = htons((u_int16_t)win);
@


1.23.2.2
log
@Sync with -current
@
text
@d838 1
a838 1
int
@


1.23.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.41 2001/04/06 04:42:09 csapuntz Exp $	*/
a59 2
#include <sys/time.h>
#include <sys/kernel.h>
a81 2
#include <netinet6/in6_var.h>
#include <netinet6/ip6protosw.h>
a123 2
struct tcpstat tcpstat;		/* tcp statistics */

d132 3
a134 1
#endif /* TCP_COMPAT_42 */
a135 1
	tcp_now = arc4random() / 2;
a146 2

	icmp6_mtudisc_callback_register(tcp6_mtudisc_callback);
d405 1
a405 2
		ip_output(m, NULL, ro, ip_mtudisc ? IP_MTUDISC : 0, NULL,
			  tp ? tp->t_inpcb : NULL);
d425 2
a426 3
	tp->t_maxseg = tcp_mssdflt;
	tp->t_maxopd = 0;
  
d445 7
a451 1
	/* we disallow IPv4 mapped address completely. */
d453 1
a453 3
		tp->pf = PF_INET;
	else
		tp->pf = PF_INET6;
a665 13
 * Compute proper scaling value for receiver window from buffer space 
 */

void
tcp_rscale(struct tcpcb *tp, u_long hiwat)
{
	tp->request_r_scale = 0;
	while (tp->request_r_scale < TCP_MAX_WINSHIFT &&
	       TCP_MAXWIN << tp->request_r_scale < hiwat)
		tp->request_r_scale++;
}

/*
d699 1
a699 1
#ifdef INET6
d706 1
a706 94
	struct tcphdr th;
	void (*notify) __P((struct inpcb *, int)) = tcp_notify;
	struct ip6_hdr *ip6;
	const struct sockaddr_in6 *sa6_src = NULL;
	struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
	struct mbuf *m;
	int off;
	struct {
		u_int16_t th_sport;
		u_int16_t th_dport;
	} *thp;

	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;
	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	else if (cmd == PRC_QUENCH) {
		/* XXX there's no PRC_QUENCH in IPv6 */
		notify = tcp_quench;
	} else if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_MSGSIZE)
		; /* special code is present, see below */
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
		m = ip6cp->ip6c_m;
		ip6 = ip6cp->ip6c_ip6;
		off = ip6cp->ip6c_off;
		sa6_src = ip6cp->ip6c_src;
	} else {
		m = NULL;
		ip6 = NULL;
		sa6_src = &sa6_any;
	}

	if (ip6) {
		/*
		 * XXX: We assume that when ip6 is non NULL,
		 * M and OFF are valid.
		 */

		/* check if we can safely examine src and dst ports */
		if (m->m_pkthdr.len < off + sizeof(*thp))
			return;

		bzero(&th, sizeof(th));
#ifdef DIAGNOSTIC
		if (sizeof(*thp) > sizeof(th))
			panic("assumption failed in tcp6_ctlinput");
#endif
		m_copydata(m, off, sizeof(*thp), (caddr_t)&th);

		if (cmd == PRC_MSGSIZE) {
			int valid = 0;

			/*
			 * Check to see if we have a valid TCP connection
			 * corresponding to the address in the ICMPv6 message
			 * payload.
			 */
			if (in6_pcbhashlookup(&tcbtable, &sa6->sin6_addr,
			    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
			    th.th_sport))
				valid++;
			else if (in_pcblookup(&tcbtable, &sa6->sin6_addr,
			    th.th_dport, (struct in6_addr *)&sa6_src->sin6_addr,
			    th.th_sport, INPLOOKUP_IPV6))
				valid++;

			/*
			 * Depending on the value of "valid" and routing table
			 * size (mtudisc_{hi,lo}wat), we will:
			 * - recalcurate the new MTU and create the
			 *   corresponding routing entry, or
			 * - ignore the MTU change notification.
			 */
			icmp6_mtudisc_update((struct ip6ctlparam *)d, valid);

			return;
		}

		(void) in6_pcbnotify(&tcbtable, sa, th.th_dport,
		    (struct sockaddr *)sa6_src, th.th_sport, cmd, NULL, notify);
	} else {
		(void) in6_pcbnotify(&tcbtable, sa, 0,
		    (struct sockaddr *)sa6_src, 0, cmd, NULL, notify);
	}
a721 3
	if (sa->sa_family != AF_INET)
		return NULL;

a728 20
	else if (cmd == PRC_MSGSIZE && ip_mtudisc) {
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		/*
		 * Verify that the packet in the icmp payload refers
		 * to an existing TCP connection.
		 */
		if (in_pcblookup(&tcbtable,
				 &ip->ip_dst, th->th_dport,
				 &ip->ip_src, th->th_sport,
				 INPLOOKUP_WILDCARD)) {
			struct icmp *icp;
			icp = (struct icmp *)((caddr_t)ip -
					      offsetof(struct icmp, icmp_ip));

			/* Calculate new mtu and create corresponding route */
			icmp_mtudisc(icp);
		}
		notify = tcp_mtudisc, ip = 0;
	} else if (cmd == PRC_MTUINC)
		notify = tcp_mtudisc_increase, ip = 0;
d734 16
a749 4
	if (ip) {
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
			     th->th_sport, errno, notify);
d751 9
a759 2
		in_pcbnotifyall(&tcbtable, sa, errno, notify);

a777 77
#ifdef INET6
/*
 * Path MTU Discovery handlers.
 */
void
tcp6_mtudisc_callback(faddr)
	struct in6_addr *faddr;
{
	struct sockaddr_in6 sin6;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *faddr;
	(void) in6_pcbnotify(&tcbtable, (struct sockaddr *)&sin6, 0,
	    (struct sockaddr *)&sa6_any, 0, PRC_MSGSIZE, NULL, tcp_mtudisc);
}
#endif /* INET6 */

/*
 * On receipt of path MTU corrections, flush old route and replace it
 * with the new one.  Retransmit all unacknowledged packets, to ensure
 * that all packets will be received.
 */
void
tcp_mtudisc(inp, errno)
	struct inpcb *inp;
	int errno;
{
	struct tcpcb *tp = intotcpcb(inp);
	struct rtentry *rt = in_pcbrtentry(inp);

	if (tp != 0) {
		if (rt != 0) {
			/*
			 * If this was not a host route, remove and realloc.
			 */
			if ((rt->rt_flags & RTF_HOST) == 0) {
				in_rtchange(inp, errno);
				if ((rt = in_pcbrtentry(inp)) == 0)
					return;
			}

			if (rt->rt_rmx.rmx_mtu != 0) {
				/* also takes care of congestion window */
				tcp_mss(tp, -1);
			}
		}

		/*
		 * Resend unacknowledged packets.
		 */
		tp->snd_nxt = tp->snd_una;
		tcp_output(tp);
	}
}

void
tcp_mtudisc_increase(inp, errno)
	struct inpcb *inp;
	int errno;
{
	struct tcpcb *tp = intotcpcb(inp);
	struct rtentry *rt = in_pcbrtentry(inp);

	if (tp != 0 && rt != 0) {
		/*
		 * If this was a host route, remove and realloc.
		 */
		if (rt->rt_flags & RTF_HOST)
			in_rtchange(inp, errno);
		
		/* also takes care of congestion window */
		tcp_mss(tp, -1);
	}
}

a866 51

#define TCP_RNDISS_ROUNDS	16
#define TCP_RNDISS_OUT	7200
#define TCP_RNDISS_MAX	30000

u_int8_t tcp_rndiss_sbox[128];
u_int16_t tcp_rndiss_msb;
u_int16_t tcp_rndiss_cnt;
long tcp_rndiss_reseed;

u_int16_t
tcp_rndiss_encrypt(val)
	u_int16_t val;
{
	u_int16_t sum = 0, i;
  
	for (i = 0; i < TCP_RNDISS_ROUNDS; i++) {
		sum += 0x79b9;
		val ^= ((u_int16_t)tcp_rndiss_sbox[(val^sum) & 0x7f]) << 7;
		val = ((val & 0xff) << 7) | (val >> 8);
	}

	return val;
}

void
tcp_rndiss_init()
{
	get_random_bytes(tcp_rndiss_sbox, sizeof(tcp_rndiss_sbox));

	tcp_rndiss_reseed = time.tv_sec + TCP_RNDISS_OUT;
	tcp_rndiss_msb = tcp_rndiss_msb == 0x8000 ? 0 : 0x8000; 
	tcp_rndiss_cnt = 0;
}

tcp_seq
tcp_rndiss_next()
{
	u_int16_t tmp;

        if (tcp_rndiss_cnt >= TCP_RNDISS_MAX ||
	    time.tv_sec > tcp_rndiss_reseed)
                tcp_rndiss_init();
	
	get_random_bytes(&tmp, sizeof(tmp));

	/* (tmp & 0x7fff) ensures a 32768 byte gap between ISS */
	return ((tcp_rndiss_encrypt(tcp_rndiss_cnt++) | tcp_rndiss_msb) <<16) |
		(tmp & 0x7fff);
}

@


1.23.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.23.2.3 2001/05/14 22:40:15 niklas Exp $	*/
d36 1
a36 37
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
d39 12
d52 1
d54 1
a54 1
#include <sys/proc.h>
d59 2
d81 3
d220 2
a221 1
			ipovly->ih_len = htons(sizeof (struct tcphdr));
a226 3
			th->th_sum = in_cksum_phdr(ipovly->ih_src.s_addr,
			    ipovly->ih_dst.s_addr,
			    htons(sizeof (struct tcphdr) + IPPROTO_TCP));
d262 1
d353 1
a353 1
			th = (void *)(ti + sizeof(struct ip6_hdr));
d359 1
a359 1
			th = (void *)(ti + sizeof(struct ip));
a408 6

		/*
		 * There's no point deferring to hardware checksum processing
		 * here, as we only send a minimal TCP packet whose checksum
		 * we need to compute in any case.
		 */
d1097 2
d1103 3
a1105 1
	/* (arc4random() & 0x7fff) ensures a 32768 byte gap between ISS */
d1107 1
a1107 1
		(arc4random() & 0x7fff);
@


1.23.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.23.2.4 2001/07/04 10:55:08 niklas Exp $	*/
d262 1
a268 1
			th->th_sum = 0;
d372 1
a372 1
			th = (void *)((caddr_t)ti + sizeof(struct ip6_hdr));
d378 1
a378 1
			th = (void *)((caddr_t)ti + sizeof(struct ip));
a433 1
		th->th_sum = 0;
@


1.23.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
int	tcp_do_rfc1323 = TCP_DO_RFC1323;
d135 1
a135 2
int	tcp_do_sack = TCP_DO_SACK;		/* RFC 2018 selective ACKs */
int	tcp_ack_on_push = 0;	/* set to enable immediate ACK-on-PUSH */
a145 7
struct pool tcpcb_pool;
#ifdef TCP_SACK
struct pool sackhl_pool;
#endif

int	tcp_freeq __P((struct tcpcb *));

a156 6
	pool_init(&tcpcb_pool, sizeof(struct tcpcb), 0, 0, 0, "tcpcbpl",
	    NULL);
#ifdef TCP_SACK
	pool_init(&sackhl_pool, sizeof(struct sackhole), 0, 0, 0, "sackhlpl",
	    NULL);
#endif /* TCP_SACK */
a172 3

	/* Initialize timer state. */
	tcp_timer_init();
d449 2
a450 1
tcp_newtcpcb(struct inpcb *inp)
d452 1
a452 2
	struct tcpcb *tp;
	int i;
d454 1
a454 1
	tp = pool_get(&tcpcb_pool, PR_NOWAIT);
d461 1
a461 5

	TCP_INIT_DELACK(tp);
	for (i = 0; i < TCPT_NTIMERS; i++)
		TCP_TIMER_INIT(tp, i);

d531 2
a532 1
tcp_close(struct tcpcb *tp)
d534 1
d652 19
a670 4
	tcp_freeq(tp);

	TCP_CLEAR_DELACK(tp);

d676 1
a676 1
		pool_put(&sackhl_pool, p);
d682 1
a682 1
	pool_put(&tcpcb_pool, tp);
a687 15
}

int
tcp_freeq(struct tcpcb *tp)
{
	struct ipqent *qe;
	int rv = 0;

	while ((qe = LIST_FIRST(&tp->segq)) != NULL) {
		LIST_REMOVE(qe, ipqe_q);
		m_freem(qe->ipqe_m);
		pool_put(&ipqent_pool, qe);
		rv = 1;
	}
	return (rv);
@


1.23.2.7
log
@Merge in -current from roughly a week ago
@
text
@d152 1
a152 1
int	tcp_freeq(struct tcpcb *);
a672 1
	tcp_canceltimers(tp);
d770 1
a770 1
	void (*notify)(struct inpcb *, int) = tcp_notify;
d875 1
a875 1
	void (*notify)(struct inpcb *, int) = tcp_notify;
@


1.23.2.8
log
@Sync the SMP branch with 3.3
@
text
@d37 1
a37 1
 *
d41 1
a41 1
 *
d56 1
a56 1
 *
d68 1
a68 1
 *
a136 1
int	tcp_do_ecn = 0;		/* RFC3168 ECN enabled/disabled? */
d200 1
a200 1
 * for the TCP header.  Also, we made the former tcpiphdr header pointer
d235 1
a235 1
		 */
d270 1
a270 1
			struct ip6_hdr *ip6;
d272 1
a272 1
			ip6 = mtod(m, struct ip6_hdr *);
d274 8
a281 8
			ip6->ip6_src = inp->inp_laddr6;
			ip6->ip6_dst = inp->inp_faddr6;
			ip6->ip6_flow = htonl(0x60000000) |
			    (inp->inp_ipv6.ip6_flow & htonl(0x0fffffff));

			ip6->ip6_nxt = IPPROTO_TCP;
			ip6->ip6_plen = htons(sizeof(struct tcphdr)); /*XXX*/
			ip6->ip6_hlim = in6_selecthlim(inp, NULL);	/*XXX*/
d332 3
a334 1
	int af;		/* af on wire */
d338 1
d343 1
a343 1
		af = tp->pf;
d349 1
d351 5
a355 2
	} else
		af = (((struct ip *)ti)->ip_v == 6) ? AF_INET6 : AF_INET;
a365 1
		switch (af) {
d367 1
a367 1
		case AF_INET6:
d370 1
a370 1
			break;
a371 1
		case AF_INET:
a373 2
			break;
		}
d382 1
a382 2
#define xchg(a,b,type) do { type t; t=a; a=b; b=t; } while (0)
		switch (af) {
d384 1
a384 1
		case AF_INET6:
d386 3
a388 2
			xchg(((struct ip6_hdr *)ti)->ip6_dst,
			    ((struct ip6_hdr *)ti)->ip6_src, struct in6_addr);
d390 1
a390 1
			break;
d392 1
a392 1
		case AF_INET:
a395 1
			break;
a399 1
	switch (af) {
d401 2
a402 2
	case AF_INET6:
		tlen += sizeof(struct tcphdr) + sizeof(struct ip6_hdr);
d404 1
a404 1
		break;
d406 1
a406 1
	case AF_INET:
a409 1
		break;
a426 1
	switch (af) {
d428 1
a428 1
	case AF_INET6:
d439 2
a440 2
		    (struct route_in6 *)ro, 0, NULL, NULL);
		break;
d442 1
a442 1
	case AF_INET:
d455 2
a456 2
		ip_output(m, (void *)NULL, ro, ip_mtudisc ? IP_MTUDISC : 0,
			(void *)NULL, tp ? tp->t_inpcb : (void *)NULL);
d511 1
a511 1
	if (inp->inp_flags & INP_IPV6)
d588 1
a588 1
	 * save them in the routing entry.  'Enough' is arbitrarily
d717 1
a717 1
 * Compute proper scaling value for receiver window from buffer space
d756 1
a756 1
	else
d1010 1
a1010 1

d1120 1
a1120 1

d1136 1
a1136 1
	tcp_rndiss_msb = tcp_rndiss_msb == 0x8000 ? 0 : 0x8000;
d1146 1
a1146 1

@


1.23.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.23.2.8 2003/03/28 00:06:55 niklas Exp $	*/
a138 2
u_int32_t	tcp_now;

a155 1
tcp_seq  tcp_iss;
@


1.23.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.23.2.9 2003/05/13 19:36:17 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.23.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a133 1
int	tcp_do_rfc3390 = 0;	/* RFC3390 Increasing TCP's Initial Window */
a141 8
/* syn hash parameters */
#define	TCP_SYN_HASH_SIZE	293
#define	TCP_SYN_BUCKET_SIZE	35
int	tcp_syn_cache_size = TCP_SYN_HASH_SIZE;
int	tcp_syn_cache_limit = TCP_SYN_HASH_SIZE*TCP_SYN_BUCKET_SIZE;
int	tcp_syn_bucket_limit = 3*TCP_SYN_BUCKET_SIZE;
struct	syn_cache_head tcp_syn_cache[TCP_SYN_HASH_SIZE];

a187 3
	/* Initialize the compressed state engine. */
	syn_cache_init();

d207 3
a209 3
	struct inpcb *inp = tp->t_inpcb;
	struct mbuf *m;
	struct tcphdr *th;
d277 1
a277 1
			    (inp->inp_flowinfo & IPV6_FLOWLABEL_MASK);
d323 1
a323 1
	struct mbuf *m;
d327 1
a327 1
	int tlen;
d330 2
a331 2
	struct tcphdr *th;
	struct tcpiphdr *ti = (struct tcpiphdr *)template;
d454 1
a454 1
		((struct ip *)ti)->ip_len = htons(tlen);
d485 1
a485 1
	tp->sack_enable = tcp_do_sack;
d529 1
a529 1
	struct tcpcb *tp;
d561 1
a561 1
	struct rtentry *rt;
d563 1
a563 1
	int bound_to_specific = 0;  /* I.e. non-default */
d610 1
a610 1
		u_long i = 0;
a675 1
	syn_cache_cleanup(tp);
d740 2
a741 2
	struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;
	struct socket *so = inp->inp_socket;
d842 4
d859 2
a860 8
		if (in6_pcbnotify(&tcbtable, sa, th.th_dport,
		    (struct sockaddr *)sa6_src, th.th_sport, cmd, NULL, notify) == 0 &&
		    syn_cache_count &&
		    (inet6ctlerrmap[cmd] == EHOSTUNREACH ||
		     inet6ctlerrmap[cmd] == ENETUNREACH ||
		     inet6ctlerrmap[cmd] == EHOSTDOWN))
			syn_cache_unreach((struct sockaddr *)sa6_src,
			    sa, &th);
d872 1
a872 1
	void *v;
d874 2
a875 2
	struct ip *ip = v;
	struct tcphdr *th;
d896 4
a899 6
		/*
		 * XXX is it possible to get a valid PRC_MSGSIZE error for
		 * a non-established connection?
		 */
		if (in_pcbhashlookup(&tcbtable,
		    ip->ip_dst, th->th_dport, ip->ip_src, th->th_sport)) {
d917 2
a918 16
		if (in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
		    th->th_sport, errno, notify) == 0 &&
		    syn_cache_count &&
		    (inetctlerrmap[cmd] == EHOSTUNREACH ||
		     inetctlerrmap[cmd] == ENETUNREACH ||
		     inetctlerrmap[cmd] == EHOSTDOWN)) {
			struct sockaddr_in sin;

			bzero(&sin, sizeof(sin));
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_port = th->th_sport;
			sin.sin_addr = ip->ip_src;
			syn_cache_unreach((struct sockaddr *)&sin,
			    sa, th);
		}
d1030 5
d1036 17
@


1.23.2.12
log
@Merge with the trunk
@
text
@d103 1
a103 1
#include <crypto/md5.h>
a150 2
int tcp_reass_limit = NMBCLUSTERS / 2; /* hardlimit for tcpqe_pool */

a155 1
struct pool tcpqe_pool;
d160 2
a175 3
	pool_init(&tcpqe_pool, sizeof(struct ipqent), 0, 0, 0, "tcpqepl",
	    NULL);
	pool_sethardlimit(&tcpqe_pool, tcp_reass_limit, NULL, 0);
d572 110
a683 1
	tcp_reass_lock(tp);
a684 1
	tcp_reass_unlock(tp);
d718 1
a718 1
		pool_put(&tcpqe_pool, qe);
a726 1
	struct inpcb *inp;
a727 12
	/* called at splimp() */
	CIRCLEQ_FOREACH(inp, &tcbtable.inpt_queue, inp_queue) {
		struct tcpcb *tp = (struct tcpcb *)inp->inp_ppcb;

		if (tp != NULL) {
			if (tcp_reass_lock_try(tp) == 0)
				continue;
			if (tcp_freeq(tp))
				tcpstat.tcps_conndrained++;
			tcp_reass_unlock(tp);
		}
	}
a1001 1
	int change = 0;
a1003 1
		int orig_maxseg = tp->t_maxseg;
d1013 5
a1017 3
			if (orig_maxseg != tp->t_maxseg ||
			    (rt->rt_rmx.rmx_locks & RTV_MTU))
				change = 1;
a1018 1
		tcp_mss(tp, -1);
d1021 1
a1021 1
		 * Resend unacknowledged packets
d1024 1
a1024 2
		if (change || errno > 0)
			tcp_output(tp);
@


1.23.2.13
log
@sync to head
@
text
@a1024 75

int
tcp_signature(struct tdb *tdb, int af, struct mbuf *m, struct tcphdr *th,
    int iphlen, int doswap, char *sig)
{
	MD5_CTX ctx;
	int len;
	struct tcphdr th0;

	MD5Init(&ctx);

	switch(af) {
	case 0:
#ifdef INET
	case AF_INET: {
		struct ippseudo ippseudo;
		struct ip *ip;

		ip = mtod(m, struct ip *);

		ippseudo.ippseudo_src = ip->ip_src;
		ippseudo.ippseudo_dst = ip->ip_dst;
		ippseudo.ippseudo_pad = 0;
		ippseudo.ippseudo_p = IPPROTO_TCP;
		ippseudo.ippseudo_len = htons(m->m_pkthdr.len - iphlen);

		MD5Update(&ctx, (char *)&ippseudo,
		    sizeof(struct ippseudo));
		break;
		}
#endif
#ifdef INET6
	case AF_INET6: {
		struct ip6_hdr_pseudo ip6pseudo;
		struct ip6_hdr *ip6;

		ip6 = mtod(m, struct ip6_hdr *);
		bzero(&ip6pseudo, sizeof(ip6pseudo));
		ip6pseudo.ip6ph_src = ip6->ip6_src;
		ip6pseudo.ip6ph_dst = ip6->ip6_dst;
		in6_clearscope(&ip6pseudo.ip6ph_src);
		in6_clearscope(&ip6pseudo.ip6ph_dst);
		ip6pseudo.ip6ph_nxt = IPPROTO_TCP;
		ip6pseudo.ip6ph_len = htonl(m->m_pkthdr.len - iphlen);

		MD5Update(&ctx, (char *)&ip6pseudo,
		    sizeof(ip6pseudo));
		break;
		}
#endif
	}

	th0 = *th;
	th0.th_sum = 0;

	if (doswap) {
		HTONL(th0.th_seq);
		HTONL(th0.th_ack);
		HTONS(th0.th_win);
		HTONS(th0.th_urp);
	}
	MD5Update(&ctx, (char *)&th0, sizeof(th0));

	len = m->m_pkthdr.len - iphlen - th->th_off * sizeof(uint32_t);

	if (len > 0 &&
	    m_apply(m, iphlen + th->th_off * sizeof(uint32_t), len,
	    tcp_signature_apply, (caddr_t)&ctx))
		return (-1); 

	MD5Update(&ctx, tdb->tdb_amxkey, tdb->tdb_amxkeylen);
	MD5Final(sig, &ctx);

	return (0);
}
@


1.22
log
@enable SACK again
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.21 1999/12/08 06:50:20 itojun Exp $	*/
d838 1
a838 1
tcp_signature_tdb_input(m, tdbp)
d841 1
d847 1
a847 1
tcp_signature_tdb_output(m, tdbp, mp)
d851 1
@


1.21
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.20 1999/10/29 02:10:02 angelos Exp $	*/
d108 1
a108 1
#define TCP_DO_SACK	0	/* XXX - make this 1 when SACK is fixed */
@


1.20
log
@Get rid of unnecessary third argument in *_output routines of IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.19 1999/08/27 08:15:50 millert Exp $	*/
d79 1
a79 1
#include <netinet6/ipv6_var.h>
d121 1
a121 1
extern int ipv6_defhoplmt;
d139 1
a139 1
	 * Since sizeof(struct ipv6) > sizeof(struct ip), we
d142 3
a144 3
	if (max_protohdr < (sizeof(struct ipv6) + sizeof(struct tcphdr)))
		max_protohdr = (sizeof(struct ipv6) + sizeof(struct tcphdr));
	if ((max_linkhdr + sizeof(struct ipv6) + sizeof(struct tcphdr)) >
a173 1
#if defined(INET) && defined(INET6)
d175 1
a175 4
#else /* defined(INET) && defined(INET6) */
		switch (0) {
#endif /* defined(INET) && defined(INET6) */
		case 0:
d183 1
a183 1
			m->m_len = sizeof(struct ipv6);
a202 1
#if defined(INET) && defined(INET6)
a203 4
#else /* defined(INET) && defined(INET6) */
	switch(0) {
#endif /* defined(INET) && defined(INET6) */
	case 0:
d226 1
a226 1
			struct ipv6 *ipv6;
d228 1
a228 1
			ipv6 = mtod(m, struct ipv6 *);
d230 9
a238 9
			ipv6->ipv6_src = inp->inp_laddr6;
			ipv6->ipv6_dst = inp->inp_faddr6;
			ipv6->ipv6_versfl = htonl(0x60000000) |
				(inp->inp_ipv6.ipv6_versfl &
				htonl(0x0fffffff));  

			ipv6->ipv6_nexthdr = IPPROTO_TCP;
			ipv6->ipv6_length = htons(sizeof(struct tcphdr));
			ipv6->ipv6_hoplimit = inp->inp_ipv6.ipv6_hoplimit;
d241 1
a241 1
				sizeof(struct ipv6));
d326 1
a326 1
			    sizeof(struct ipv6));
d342 3
a344 3
			m->m_len = sizeof(struct tcphdr) + sizeof(struct ipv6);
			xchg(((struct ipv6 *)ti)->ipv6_dst,\
			    ((struct ipv6 *)ti)->ipv6_src,\
d346 1
a346 1
			th = (void *)ti + sizeof(struct ipv6);
d359 2
a360 2
		tlen += sizeof(struct tcphdr) + sizeof(struct ipv6); 
		th = (struct tcphdr *)((caddr_t)ti + sizeof(struct ipv6));
d385 5
a389 4
		((struct ipv6 *)ti)->ipv6_versfl   = htonl(0x60000000);
		((struct ipv6 *)ti)->ipv6_nexthdr  = IPPROTO_TCP;
		((struct ipv6 *)ti)->ipv6_hoplimit = MAXHOPLIMIT;
		((struct ipv6 *)ti)->ipv6_length = tlen - sizeof(struct ipv6);
d392 4
a395 3
		   ((struct ipv6 *)ti)->ipv6_length, sizeof(struct ipv6));
		HTONS(((struct ipv6 *)ti)->ipv6_length);
		ipv6_output(m, (struct route6 *)ro, 0, NULL, NULL, NULL);
d453 3
d457 1
d459 1
a459 1
		inp->inp_ipv6.ipv6_hoplimit = ipv6_defhoplmt;
d604 1
a604 1
				    + sizeof(struct ipv6));
d698 11
d736 1
a736 1
			struct ipv6 *ipv6 = (struct ipv6 *)ip;
d739 1
d741 4
a744 2
			    &ipv6->ipv6_src, th->th_sport, cmd, notify);
		} else
d747 2
@


1.19
log
@Disable SACK for now, it has problems, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.18 1999/07/06 20:17:53 cmetz Exp $	*/
d833 1
a833 1
tcp_signature_tdb_output(m, gw, tdbp, mp)
a834 1
	struct sockaddr_encap *gw;
@


1.18
log
@Added support for TCP MD5 option (RFC 2385).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.17 1999/07/06 18:01:55 cmetz Exp $	*/
d108 1
a108 1
#define TCP_DO_SACK	1
@


1.17
log
@Removed bogus ifdef/define lines that resulted from an over-aggressive M-x.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.16 1999/07/02 21:22:14 cmetz Exp $	*/
d84 4
d763 89
@


1.16
log
@Fixed a #ifdef defined()... typo that turned into a compilation failure.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.15 1999/07/02 20:39:08 cmetz Exp $	*/
a82 4

#if defined(INET) && defined(INET6)
#define defined(INET) && defined(INET6) 1
#endif /* defined(INET) && defined(INET6) */
@


1.15
log
@Significant cleanups in the way TCP is made to handle multiple network
protocols.

"struct tcpiphdr" is now gone from much of the code, as are separate pointers
for ti and ti6. The result is fewer variables, which is generally a good thing.

Simple if(is_ipv6) ... else ... tests are gone in favor of a
switch(protocol family), which allows future new protocols to be added easily.
This also makes it possible for someone so inclined to re-implement TUBA (TCP
over CLNP?) and do it right instead of the kluged way it was done in 4.4.

The TCP header template is now referenced through a mbuf rather than done
through a data pointer and dtom()ed as needed. This is partly because dtom() is
evil and partly because max_linkhdr + IPv6 + TCP + MSS/TS/SACK opts won't fit
inside a packet header mbuf, so we need to grab a cluster for that (which the
code now does, if needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.14 1999/02/17 00:14:26 deraadt Exp $	*/
d174 1
a174 1
#ifdef defined(INET) && defined(INET6)
d207 1
a207 1
#ifdef defined(INET) && defined(INET6)
@


1.14
log
@inet6 indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.13 1999/01/11 02:01:36 deraadt Exp $	*/
d84 4
d161 1
a161 1
struct tcpiphdr *
a166 1
	register struct tcpiphdr *n;
a167 4
#ifdef INET6
	register struct tcpipv6hdr *ti6;
	register struct ipv6 *ipv6;
#endif /* INET6 */
d169 1
a169 1
	if ((n = tp->t_template) == 0) {
d173 16
a188 4
#ifdef INET6
		if (tp->pf == PF_INET6) 
			m->m_len = sizeof (struct tcphdr) + sizeof(struct ipv6);
		else 
d190 15
a204 2
			m->m_len = sizeof (struct tcpiphdr);
		n = mtod(m, struct tcpiphdr *);
d206 26
d233 15
a247 1
	if (tp->pf == PF_INET6) {
d249 4
a252 13
		ti6 = (struct tcpipv6hdr *)n;
		ipv6 = (struct ipv6 *)n;
		th = &ti6->ti6_t;

		ipv6->ipv6_src = inp->inp_laddr6;
		ipv6->ipv6_dst = inp->inp_faddr6;
		ipv6->ipv6_versfl = htonl(0x60000000) |
		    (inp->inp_ipv6.ipv6_versfl & htonl(0x0fffffff));  
						  
		ipv6->ipv6_nexthdr = IPPROTO_TCP;
		ipv6->ipv6_length = htons(sizeof(struct tcphdr)); /*XXX*/
		ipv6->ipv6_hoplimit = inp->inp_ipv6.ipv6_hoplimit;
	} else
a253 7
	{
		th = &n->ti_t;
		bzero(n->ti_x1, sizeof n->ti_x1);
		n->ti_pr = IPPROTO_TCP;
		n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
		n->ti_src = inp->inp_laddr;
		n->ti_dst = inp->inp_faddr;
d266 1
a266 1
	return (n);
d286 1
a286 1
tcp_respond(tp, ti, m, ack, seq, flags)
d288 1
a288 1
	register struct tcpiphdr *ti;
d297 1
d652 1
a652 1
		(void) m_free(dtom(tp->t_template));
@


1.13
log
@netinet merge of NRL stuff. some indent and shrinkage needed; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.12 1998/11/17 19:23:02 provos Exp $	*/
d151 1
a151 3
 */
#ifdef INET6
/*
a156 1
#endif /* INET6 */
@


1.12
log
@NewReno, SACK and FACK support for TCP, adapted from code for BSDI
by Hari Balakrishnan (hari@@lcs.mit.edu), Tom Henderson (tomh@@cs.berkeley.edu)
and Venkat Padmanabhan (padmanab@@cs.berkeley.edu) as part of the
Daedalus research group at the University of California,
(http://daedalus.cs.berkeley.edu). [I was able to do this on time spent
at the Center for Information Technology Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.11 1998/10/28 21:34:33 provos Exp $	*/
d39 12
d78 6
d116 4
d132 10
a141 3
	if (max_protohdr < sizeof(struct tcpiphdr))
		max_protohdr = sizeof(struct tcpiphdr);
	if (max_linkhdr + sizeof(struct tcpiphdr) > MHLEN)
d143 1
d152 8
d167 5
d177 6
a182 1
		m->m_len = sizeof (struct tcpiphdr);
d185 36
a220 15
	bzero(n->ti_x1, sizeof n->ti_x1);
	n->ti_pr = IPPROTO_TCP;
	n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
	n->ti_src = inp->inp_laddr;
	n->ti_dst = inp->inp_faddr;
	n->ti_sport = inp->inp_lport;
	n->ti_dport = inp->inp_fport;
	n->ti_seq = 0;
	n->ti_ack = 0;
	n->ti_x2 = 0;
	n->ti_off = 5;
	n->ti_flags = 0;
	n->ti_win = 0;
	n->ti_sum = 0;
	n->ti_urp = 0;
d237 3
d251 4
d258 12
d272 4
d286 9
a294 1
		*mtod(m, struct tcpiphdr *) = *ti;
a300 1
		m->m_len = sizeof (struct tcpiphdr);
d303 15
a317 2
		xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_int32_t);
		xchg(ti->ti_dport, ti->ti_sport, u_int16_t);
d320 12
a331 2
	ti->ti_len = htons((u_int16_t)(sizeof (struct tcphdr) + tlen));
	tlen += sizeof (struct tcpiphdr);
d335 5
a339 6
	bzero(ti->ti_x1, sizeof ti->ti_x1);
	ti->ti_seq = htonl(seq);
	ti->ti_ack = htonl(ack);
	ti->ti_x2 = 0;
	ti->ti_off = sizeof (struct tcphdr) >> 2;
	ti->ti_flags = flags;
d341 1
a341 1
		ti->ti_win = htons((u_int16_t) (win >> tp->rcv_scale));
d343 24
a366 7
		ti->ti_win = htons((u_int16_t)win);
	ti->ti_urp = 0;
	ti->ti_sum = 0;
	ti->ti_sum = in_cksum(m, tlen);
	((struct ip *)ti)->ip_len = tlen;
	((struct ip *)ti)->ip_ttl = ip_defttl;
	(void) ip_output(m, NULL, ro, 0, NULL, tp ? tp->t_inpcb : NULL);
d404 17
a420 1
	inp->inp_ip.ip_ttl = ip_defttl;
d467 24
d504 7
d514 1
d558 9
a566 1
			i *= (u_long)(tp->t_maxseg + sizeof (struct tcpiphdr));
d575 1
d577 19
a595 5
	while ((qe = tp->segq.lh_first) != NULL) {
		LIST_REMOVE(qe, ipqe_q);
		m_freem(qe->ipqe_m);
		FREE(qe, M_IPQ);
	}
d678 12
a689 4
	if (ip) {
		th = (struct tcphdr *)((caddr_t)ip + (ip->ip_hl << 2));
		in_pcbnotify(&tcbtable, sa, th->th_dport, ip->ip_src,
		    th->th_sport, errno, notify);
d691 9
a699 1
		in_pcbnotifyall(&tcbtable, sa, errno, notify);
@


1.11
log
@- fix three bugs pointed out in Stevens, i.a. updating timestamps correctly
- fix a 4.4bsd-lite2 bug, when tcp options are present the maximum segment
size is not updated correctly, so that fast recovery forces out a segment
which is split in two segments by tcp_output(), the fix is adpated from
FreeBSD, the effective mss is recorded after option negotiation in 3way
handshake.
[I was able to fix this on time spent at Center for Information Technology
Integration (citi.umich.edu)]
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.10 1998/05/18 21:11:07 provos Exp $	*/
d80 1
a80 1
#define TCP_DO_RFC1323 1
d84 9
d249 3
d308 3
d387 9
@


1.10
log
@first step to the setsockopt/getsockopt interface as described in
draft-mcdonald-simple-ipsec-api, kernel notifies (EMT_REQUESTSA) signal
userland key management applications when security services are requested.
this is only for outgoing connections at the moment, incoming packets
are not yet checked against the selected socket policy.
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.9 1997/08/26 20:02:33 deraadt Exp $	*/
d238 1
a238 1
	tp->t_maxseg = tcp_mssdflt;
@


1.9
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.8 1997/02/05 15:48:25 deraadt Exp $	*/
d219 1
a219 1
	(void) ip_output(m, NULL, ro, 0, NULL);
@


1.8
log
@use arc4random()
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.7 1996/07/29 22:01:50 niklas Exp $	*/
d67 2
a68 2
int 	tcp_mssdflt = TCP_MSS;
int 	tcp_rttdflt = TCPTV_SRTTDFLT / PR_SLOWHZ;
@


1.7
log
@Remove random() prototype, as it's not needed.  Besides it was wrong for the alpha :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.6 1996/07/29 06:22:14 tholo Exp $	*/
d64 1
d98 1
a98 1
	tcp_iss = random() + 1;
@


1.6
log
@Make TCP ISS increment by random amounts
@
text
@d1 1
a1 1
/*	$OpenBSD: tcp_subr.c,v 1.5 1996/05/15 09:32:01 mickey Exp $	*/
a96 2
	u_int random __P((void));

@


1.5
log
@remove unnecessary "XXX it should be sysctl()'ed"
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 4
d99 2
a100 1
	tcp_iss = 1;		/* wrong */
@


1.4
log
@fix NetBSD PR#854.
allow to overwrite rfc1323 option in config file.
@
text
@a74 1
 * XXX "tcp_do_rfc1323" should be sysctl() changeable.
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d68 15
a82 1
int	tcp_do_rfc1323 = 1;
@


1.2
log
@from netbsd:
make netinet work on systems where pointers and longs are 64 bits
(like the alpha).  Biggest problem: IP headers were overlayed with
structure which included pointers, and which therefore didn't overlay
properly on 64-bit machines.  Solution: instead of threading pointers
through IP header overlays, add a "queue element" structure to do
the threading, and point it at the ip headers.
@
text
@d1 2
a2 1
/*	$NetBSD: tcp_subr.c,v 1.20 1995/11/21 01:07:41 cgd Exp $	*/
d70 4
a73 1
extern	struct inpcb *tcp_last_inpcb;
d83 1
a83 1
	in_pcbinit(&tcbtable);
a278 1
	register struct mbuf *m;
d297 1
a297 1
		register u_long i;
d330 2
a331 2
		if ((rt->rt_rmx.rmx_locks & RTV_SSTHRESH) == 0 &&
		    (i = tp->snd_ssthresh) && rt->rt_rmx.rmx_ssthresh ||
a359 3
	/* clobber input pcb cache if we're closing the cached connection */
	if (inp == tcp_last_inpcb)
		tcp_last_inpcb = 0;
d405 2
a406 2
void
tcp_ctlinput(cmd, sa, ip)
d409 1
a409 1
	register struct ip *ip;
d411 1
a412 1
	extern struct in_addr zeroin_addr;
d418 1
a418 1
		return;
d427 1
a427 1
		return;
d434 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: tcp_subr.c,v 1.19 1995/06/12 06:48:54 mycroft Exp $	*/
d107 1
a107 2
	n->ti_next = n->ti_prev = 0;
	n->ti_x1 = 0;
d178 1
a178 1
	ti->ti_len = htons((u_short)(sizeof (struct tcphdr) + tlen));
d183 1
a183 2
	ti->ti_next = ti->ti_prev = 0;
	ti->ti_x1 = 0;
d216 1
a216 1
	tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
d272 1
a272 1
	register struct tcpiphdr *t;
d347 4
a350 6
	t = tp->seg_next;
	while (t != (struct tcpiphdr *)tp) {
		t = (struct tcpiphdr *)t->ti_next;
		m = REASS_MBUF((struct tcpiphdr *)t->ti_prev);
		remque(t->ti_prev);
		m_freem(m);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
