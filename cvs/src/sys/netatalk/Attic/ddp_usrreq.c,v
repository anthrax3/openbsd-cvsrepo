head	1.16;
access;
symbols
	OPENBSD_4_9:1.14.0.4
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.2
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.16
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.14
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.12
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.10
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.8
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.6
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.18
	OPENBSD_2_8:1.2.0.16
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.14
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.12
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.10
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.8
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.6
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.4
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2011.07.09.00.47.18;	author henning;	state dead;
branches;
next	1.15;

1.15
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.30.20.37.54;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.23.16.03.03;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2007.12.14.18.33.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.26.12.09.40;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.02.16.57.29;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.06.03.06.28;	author angelos;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.05.26.07.17.11;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.26.07.14.02;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	97.07.24.00.25.23;	author deraadt;	state Exp;
branches
	1.2.12.1;
next	1.1;

1.1
date	97.07.23.03.39.54;	author denny;	state Exp;
branches;
next	;

1.2.12.1
date	2001.07.04.10.54.23;	author niklas;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2001.10.31.03.29.03;	author nate;	state Exp;
branches;
next	1.2.12.3;

1.2.12.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.12.4;

1.2.12.4
date	2004.02.19.10.57.23;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.31.36;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@begone, fucking rotten appletalk shit. ok room
@
text
@/*	$OpenBSD: ddp_usrreq.c,v 1.15 2011/07/06 02:42:28 henning Exp $	*/

/*
 * Copyright (c) 1990,1994 Regents of The University of Michigan.
 * All Rights Reserved.  See COPYRIGHT.
 */

/*
 * The following is the contents of the COPYRIGHT file from the
 * netatalk-1.4a2 distribution, from which this file is derived.
 */
/*
 * Copyright (c) 1990,1996 Regents of The University of Michigan.
 *
 * All Rights Reserved.
 *
 *    Permission to use, copy, modify, and distribute this software and
 *    its documentation for any purpose and without fee is hereby granted,
 *    provided that the above copyright notice appears in all copies and
 *    that both that copyright notice and this permission notice appear
 *    in supporting documentation, and that the name of The University
 *    of Michigan not be used in advertising or publicity pertaining to
 *    distribution of the software without specific, written prior
 *    permission. This software is supplied as is without expressed or
 *    implied warranties of any kind.
 *
 * This product includes software developed by the University of
 * California, Berkeley and its contributors.
 *
 * Solaris code is encumbered by the following:
 *
 *     Copyright (C) 1996 by Sun Microsystems Computer Co.
 *
 *     Permission to use, copy, modify, and distribute this software and
 *     its documentation for any purpose and without fee is hereby
 *     granted, provided that the above copyright notice appear in all
 *     copies and that both that copyright notice and this permission
 *     notice appear in supporting documentation.  This software is
 *     provided "as is" without express or implied warranty.
 *
 * Research Systems Unix Group
 * The University of Michigan
 * c/o Wesley Craig
 * 535 W. William Street
 * Ann Arbor, Michigan
 * +1-313-764-2278
 * netatalk@@umich.edu
 */
/*
 * None of the Solaris code mentioned is included in OpenBSD.
 * This code also relies heavily on previous effort in FreeBSD and NetBSD.
 */

#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/mbuf.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>
#include <sys/protosw.h>
#include <net/if.h>
#include <net/route.h>

#include <machine/endian.h>

#include <netatalk/at.h>
#include <netatalk/at_var.h>
#include <netatalk/ddp_var.h>
#include <netatalk/at_extern.h>

int ddp_usrreq(struct socket *, int, struct mbuf *,
			struct mbuf *, struct mbuf *, struct proc *);
static void at_sockaddr( struct ddpcb *, struct mbuf * );
static int at_pcbsetaddr( struct ddpcb *, struct mbuf *,
			struct proc * );
static int at_pcbconnect( struct ddpcb *, struct mbuf *,
			struct proc *);
static void at_pcbdisconnect( struct ddpcb * );
static int at_pcballoc( struct socket * );
static void at_pcbdetach( struct socket *, struct ddpcb * );
struct ddpcb *ddp_search( struct sockaddr_at *,
			struct sockaddr_at *, struct at_ifaddr * );
void ddp_init(void);

struct at_ifaddr	*at_ifaddr;
struct ifqueue		atintrq1, atintrq2;
int			atdebug;

struct ddpcb		*ddp_ports[ ATPORT_LAST ];
struct ddpstat		ddpstat;

struct ddpcb	*ddpcb = NULL;
u_long		ddp_sendspace = DDP_MAXSZ; /* Max ddp size + 1 (ddp_type) */
u_long		ddp_recvspace = 10 * ( 587 + sizeof( struct sockaddr_at ));

/*ARGSUSED*/
int
ddp_usrreq( so, req, m, addr, rights, p )
    struct socket	*so;
    int			req;
    struct mbuf		*m, *addr, *rights;
    struct proc		*p;
{
    struct ddpcb	*ddp;
    int			error = 0;

    ddp = sotoddpcb( so );

    if ( req == PRU_CONTROL ) {
	return( at_control( (u_long) m, (caddr_t) addr,
		(struct ifnet *) rights, p ));
    }

    if ( rights && rights->m_len ) {
	error = EINVAL;
	goto release;
    }

    if ( ddp == NULL && req != PRU_ATTACH ) {
	error = EINVAL;
	goto release;
    }

    switch ( req ) {
    case PRU_ATTACH :
	if ( ddp != NULL ) {
	    error = EINVAL;
	    break;
	}
	if (( error = at_pcballoc( so )) != 0 ) {
	    break;
	}
	error = soreserve( so, ddp_sendspace, ddp_recvspace );
	break;

    case PRU_DETACH :
	at_pcbdetach( so, ddp );
	break;

    case PRU_BIND :
	error = at_pcbsetaddr( ddp, addr, p );
	break;
    
    case PRU_SOCKADDR :
	at_sockaddr( ddp, addr );
	break;

    case PRU_CONNECT:
	if ( ddp->ddp_fsat.sat_port != ATADDR_ANYPORT ) {
	    error = EISCONN;
	    break;
	}

	error = at_pcbconnect( ddp, addr, p );
	if ( error == 0 )
	    soisconnected( so );
	break;

    case PRU_DISCONNECT:
	if ( ddp->ddp_fsat.sat_addr.s_node == ATADDR_ANYNODE ) {
	    error = ENOTCONN;
	    break;
	}
	at_pcbdisconnect( ddp );
	soisdisconnected( so );
	break;

    case PRU_SHUTDOWN:
	socantsendmore( so );
	break;

    case PRU_SEND: {
	int	s;

	if ( addr ) {
	    if ( ddp->ddp_fsat.sat_port != ATADDR_ANYPORT ) {
		error = EISCONN;
		break;
	    }

	    s = splnet();
	    error = at_pcbconnect( ddp, addr, p );
	    if ( error ) {
		splx( s );
		break;
	    }
	} else {
	    if ( ddp->ddp_fsat.sat_port == ATADDR_ANYPORT ) {
		error = ENOTCONN;
		break;
	    }
	}

	error = ddp_output( m, ddp );
	m = NULL;
	if ( addr ) {
	    at_pcbdisconnect( ddp );
	    splx( s );
	}
	}
	break;

    case PRU_ABORT:
	soisdisconnected( so );
	at_pcbdetach( so, ddp );
	break;

    case PRU_LISTEN:
    case PRU_CONNECT2:
    case PRU_ACCEPT:
    case PRU_SENDOOB:
    case PRU_FASTTIMO:
    case PRU_SLOWTIMO:
    case PRU_PROTORCV:
    case PRU_PROTOSEND:
	error = EOPNOTSUPP;
	break;

    case PRU_RCVD:
    case PRU_RCVOOB:
	/*
	 * Don't mfree. Good architecture...
	 */
	return( EOPNOTSUPP );

    case PRU_SENSE:
	/*
	 * 1. Don't return block size.
	 * 2. Don't mfree.
	 */
	return( 0 );

    default:
	error = EOPNOTSUPP;
    }

release:
    if ( m != NULL ) {
	m_freem( m );
    }
    return( error );
}

static void
at_sockaddr( ddp, addr )
    struct ddpcb	*ddp;
    struct mbuf		*addr;
{
    struct sockaddr_at	*sat;

    addr->m_len = sizeof( struct sockaddr_at );
    sat = mtod( addr, struct sockaddr_at *);
    *sat = ddp->ddp_lsat;
}

static int
at_pcbsetaddr( ddp, addr, p )
    struct ddpcb	*ddp;
    struct mbuf		*addr;
    struct proc		*p;
{
    struct sockaddr_at	lsat, *sat;
    struct at_ifaddr	*aa;
    struct ddpcb	*ddpp;

    if ( ddp->ddp_lsat.sat_port != ATADDR_ANYPORT ) { /* shouldn't be bound */
	return( EINVAL );
    }

    if ( addr != 0 ) {			/* validate passed address */
	sat = mtod( addr, struct sockaddr_at *);
	if ( addr->m_len != sizeof( *sat )) {
	    return( EINVAL );
	}
	if ( sat->sat_family != AF_APPLETALK ) {
	    return( EAFNOSUPPORT );
	}

	if ( sat->sat_addr.s_node != ATADDR_ANYNODE ||
		sat->sat_addr.s_net != ATADDR_ANYNET ) {
	    for ( aa = at_ifaddr; aa; aa = aa->aa_next ) {
		if (( sat->sat_addr.s_net == AA_SAT( aa )->sat_addr.s_net ) &&
		 ( sat->sat_addr.s_node == AA_SAT( aa )->sat_addr.s_node )) {
		    break;
		}
	    }
	    if ( !aa ) {
		return( EADDRNOTAVAIL );
	    }
	}

	if ( sat->sat_port != ATADDR_ANYPORT ) {
	    if ( sat->sat_port < ATPORT_FIRST ||
		    sat->sat_port >= ATPORT_LAST ) {
		return( EINVAL );
	    }
	    if ( sat->sat_port < ATPORT_RESERVED &&
		    suser( p, 0 )) {
		return( EACCES );
	    }
	}
    } else {
	bzero( (caddr_t)&lsat, sizeof( struct sockaddr_at ));
	lsat.sat_family = AF_APPLETALK;
	sat = &lsat;
    }

    if ( sat->sat_addr.s_node == ATADDR_ANYNODE &&
	    sat->sat_addr.s_net == ATADDR_ANYNET ) {
	if ( at_ifaddr == NULL ) {
	    return( EADDRNOTAVAIL );
	}
	sat->sat_addr = AA_SAT( at_ifaddr )->sat_addr;
    }
    ddp->ddp_lsat = *sat;

    /*
     * Choose port.
     */
    if ( sat->sat_port == ATADDR_ANYPORT ) {
	for ( sat->sat_port = ATPORT_RESERVED;
		sat->sat_port < ATPORT_LAST; sat->sat_port++ ) {
	    if ( ddp_ports[ sat->sat_port - 1 ] == 0 ) {
		break;
	    }
	}
	if ( sat->sat_port == ATPORT_LAST ) {
	    return( EADDRNOTAVAIL );
	}
	ddp->ddp_lsat.sat_port = sat->sat_port;
	ddp_ports[ sat->sat_port - 1 ] = ddp;
    } else {
	for ( ddpp = ddp_ports[ sat->sat_port - 1 ]; ddpp;
		ddpp = ddpp->ddp_pnext ) {
	    if ( ddpp->ddp_lsat.sat_addr.s_net == sat->sat_addr.s_net &&
		    ddpp->ddp_lsat.sat_addr.s_node == sat->sat_addr.s_node ) {
		break;
	    }
	}
	if ( ddpp != NULL ) {
	    return( EADDRINUSE );
	}
	ddp->ddp_pnext = ddp_ports[ sat->sat_port - 1 ];
	ddp_ports[ sat->sat_port - 1 ] = ddp;
	if ( ddp->ddp_pnext ) {
	    ddp->ddp_pnext->ddp_pprev = ddp;
	}
    }

    return( 0 );
}

static int
at_pcbconnect( ddp, addr, p )
    struct ddpcb	*ddp;
    struct mbuf		*addr;
    struct proc		*p;
{
    struct sockaddr_at	*sat = mtod( addr, struct sockaddr_at *);
    struct route	*ro;
    struct at_ifaddr	*aa = 0;
    struct ifnet	*ifp;
    u_int16_t		hintnet = 0, net;

    if ( addr->m_len != sizeof( *sat ))
	return( EINVAL );
    if ( sat->sat_family != AF_APPLETALK ) {
	return( EAFNOSUPPORT );
    }

    /*
     * Under phase 2, network 0 means "the network".  We take "the
     * network" to mean the network the control block is bound to.
     * If the control block is not bound, there is an error.
     */
    if ( sat->sat_addr.s_net == 0 && sat->sat_addr.s_node != ATADDR_ANYNODE ) {
	if ( ddp->ddp_lsat.sat_port == ATADDR_ANYPORT ) {
	    return( EADDRNOTAVAIL );
	}
	hintnet = ddp->ddp_lsat.sat_addr.s_net;
    }

    ro = &ddp->ddp_route;
    /*
     * If we've got an old route for this pcb, check that it is valid.
     * If we've changed our address, we may have an old "good looking"
     * route here.  Attempt to detect it.
     */
    if ( ro->ro_rt ) {
	if ( hintnet ) {
	    net = hintnet;
	} else {
	    net = sat->sat_addr.s_net;
	}
	aa = 0;
	if ( (ifp = ro->ro_rt->rt_ifp) != NULL ) {
	    for ( aa = at_ifaddr; aa; aa = aa->aa_next ) {
		if ( aa->aa_ifp == ifp &&
			ntohs( net ) >= ntohs( aa->aa_firstnet ) &&
			ntohs( net ) <= ntohs( aa->aa_lastnet )) {
		    break;
		}
	    }
	}
	if ( aa == NULL || ( satosat( &ro->ro_dst )->sat_addr.s_net !=
		( hintnet ? hintnet : sat->sat_addr.s_net ) ||
		satosat( &ro->ro_dst )->sat_addr.s_node !=
		sat->sat_addr.s_node )) {
	    RTFREE( ro->ro_rt );
	    ro->ro_rt = (struct rtentry *)0;
	}
    }

    /*
     * If we've got no route for this interface, try to find one.
     */
    if ( ro->ro_rt == (struct rtentry *)0 ||
	 ro->ro_rt->rt_ifp == (struct ifnet *)0 ) {
	ro->ro_dst.sa_len = sizeof( struct sockaddr_at );
	ro->ro_dst.sa_family = AF_APPLETALK;
	if ( hintnet != 0 ) {
	    satosat( &ro->ro_dst )->sat_addr.s_net = hintnet;
	} else {
	    satosat( &ro->ro_dst )->sat_addr.s_net = sat->sat_addr.s_net;
	}
	satosat( &ro->ro_dst )->sat_addr.s_node = sat->sat_addr.s_node;
	rtalloc( ro );
    }

    /*
     * Make sure any route that we have has a valid interface.
     */
    aa = 0;
    if ( ro->ro_rt && ( ifp = ro->ro_rt->rt_ifp )) {
	for ( aa = at_ifaddr; aa; aa = aa->aa_next ) {
	    if ( aa->aa_ifp == ifp ) {
		break;
	    }
	}
    }
    if ( aa == 0 ) {
	return( ENETUNREACH );
    }

    ddp->ddp_fsat = *sat;
    if ( ddp->ddp_lsat.sat_port == ATADDR_ANYPORT ) {
	return( at_pcbsetaddr( ddp, (struct mbuf *)0, p ));
    }
    return( 0 );
}

static void
at_pcbdisconnect( ddp )
    struct ddpcb	*ddp;
{
    ddp->ddp_fsat.sat_addr.s_net = ATADDR_ANYNET;
    ddp->ddp_fsat.sat_addr.s_node = ATADDR_ANYNODE;
    ddp->ddp_fsat.sat_port = ATADDR_ANYPORT;
}

static int
at_pcballoc( so )
    struct socket	*so;
{
    struct ddpcb	*ddp;

    ddp = malloc(sizeof(*ddp), M_PCB, M_NOWAIT | M_ZERO);
    if ( ddp == NULL ) {
	return (ENOBUFS);
    }

    ddp->ddp_lsat.sat_port = ATADDR_ANYPORT;

    ddp->ddp_next = ddpcb;
    ddp->ddp_prev = NULL;
    ddp->ddp_pprev = NULL;
    ddp->ddp_pnext = NULL;
    if ( ddpcb ) {
	ddpcb->ddp_prev = ddp;
    }
    ddpcb = ddp;

    ddp->ddp_socket = so;
    so->so_pcb = (caddr_t)ddp;
    return( 0 );
}

static void
at_pcbdetach( so, ddp )
    struct socket	*so;
    struct ddpcb	*ddp;
{
    soisdisconnected( so );
    so->so_pcb = 0;
    sofree( so );

    /* remove ddp from ddp_ports list */
    if ( ddp->ddp_lsat.sat_port != ATADDR_ANYPORT &&
	    ddp_ports[ ddp->ddp_lsat.sat_port - 1 ] != NULL ) {
	if ( ddp->ddp_pprev != NULL ) {
	    ddp->ddp_pprev->ddp_pnext = ddp->ddp_pnext;
	} else {
	    ddp_ports[ ddp->ddp_lsat.sat_port - 1 ] = ddp->ddp_pnext;
	}
	if ( ddp->ddp_pnext != NULL ) {
	    ddp->ddp_pnext->ddp_pprev = ddp->ddp_pprev;
	}
    }

    if ( ddp->ddp_route.ro_rt ) {
	rtfree( ddp->ddp_route.ro_rt );
    }

    if ( ddp->ddp_prev ) {
	ddp->ddp_prev->ddp_next = ddp->ddp_next;
    } else {
	ddpcb = ddp->ddp_next;
    }
    if ( ddp->ddp_next ) {
	ddp->ddp_next->ddp_prev = ddp->ddp_prev;
    }

    free( ddp, M_PCB );
}

/*
 * For the moment, this just find the pcb with the correct local address.
 * In the future, this will actually do some real searching, so we can use
 * the sender's address to do de-multiplexing on a single port to many
 * sockets (pcbs).
 */
struct ddpcb *
ddp_search( from, to, aa )
    struct sockaddr_at	*from, *to;
    struct at_ifaddr	*aa;
{
    struct ddpcb	*ddp;

    /*
     * Check for bad ports.
     */
    if ( to->sat_port < ATPORT_FIRST || to->sat_port >= ATPORT_LAST ) {
	return( NULL );
    }

    /*
     * Make sure the local address matches the sent address.  What about
     * the interface?
     */
    for ( ddp = ddp_ports[ to->sat_port - 1 ]; ddp; ddp = ddp->ddp_pnext ) {
	/* XXX should we handle 0.YY? */

	/* XXXX.YY to socket on destination interface */
	if ( to->sat_addr.s_net == ddp->ddp_lsat.sat_addr.s_net &&
		to->sat_addr.s_node == ddp->ddp_lsat.sat_addr.s_node ) {
	    break;
	}

	/* 0.255 to socket on receiving interface */
	if ( to->sat_addr.s_node == ATADDR_BCAST && ( to->sat_addr.s_net == 0 ||
		to->sat_addr.s_net == ddp->ddp_lsat.sat_addr.s_net ) &&
		ddp->ddp_lsat.sat_addr.s_net == AA_SAT( aa )->sat_addr.s_net ) {
	    break;
	}

	/* XXXX.0 to socket on destination interface */
	if ( to->sat_addr.s_net == aa->aa_firstnet &&
		to->sat_addr.s_node == 0 &&
		ntohs( ddp->ddp_lsat.sat_addr.s_net ) >=
		ntohs( aa->aa_firstnet ) &&
		ntohs( ddp->ddp_lsat.sat_addr.s_net ) <=
		ntohs( aa->aa_lastnet )) {
	    break;
	}
    }
    return( ddp );
}

void
ddp_init()
{
	IFQ_SET_MAXLEN(&atintrq1, IFQ_MAXLEN);
	IFQ_SET_MAXLEN(&atintrq2, IFQ_MAXLEN);
}

/*
 * Sysctl for ddp variables.
 */
int
ddp_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case DDPCTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ddpstat, sizeof(ddpstat)));

	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.15
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.14 2010/06/30 20:37:54 claudio Exp $	*/
@


1.14
log
@This needs sys/sysctl.h to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.13 2010/06/26 23:24:45 guenther Exp $	*/
d586 2
a587 2
    atintrq1.ifq_maxlen = IFQ_MAXLEN;
    atintrq2.ifq_maxlen = IFQ_MAXLEN;
@


1.13
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.12 2008/05/23 16:03:03 thib Exp $	*/
d63 1
@


1.12
log
@Make this compile again, by adding a struct proc * argument
to the usrreq's.

(Both MPLS and NETATALK are disabled in GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.11 2007/12/14 18:33:40 deraadt Exp $	*/
a58 1
#include <sys/user.h>
@


1.11
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.10 2007/10/06 02:18:38 krw Exp $	*/
d76 1
a76 1
			struct mbuf *, struct mbuf * );
d102 1
a102 1
ddp_usrreq( so, req, m, addr, rights )
d106 1
a107 2
    /* XXX Need to pass p into this routine */
    struct proc *p = curproc;
@


1.10
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.9 2007/10/03 10:52:11 krw Exp $	*/
d589 24
@


1.9
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.8 2007/05/26 12:09:40 claudio Exp $	*/
d528 1
a528 1
    FREE( ddp, M_PCB );
@


1.8
log
@De-common a few variables by moving the definition into a .c file.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.7 2003/09/02 16:57:29 tedu Exp $	*/
d472 1
a472 1
    MALLOC( ddp, struct ddpcb *, sizeof( *ddp ), M_PCB, M_NOWAIT );
a475 1
    bzero( ddp, sizeof( *ddp ));
@


1.7
log
@fix suser() calls, pr3430
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.6 2002/03/14 01:27:10 millert Exp $	*/
d88 7
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.5 2001/07/06 03:06:28 angelos Exp $	*/
d296 1
a296 1
		    suser( p->p_ucred, &p->p_acflag )) {
@


1.5
log
@bzero PCB after allocation
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.4 2001/05/26 07:17:11 angelos Exp $	*/
d75 13
a87 13
int ddp_usrreq	__P((struct socket *, int, struct mbuf *,
			struct mbuf *, struct mbuf * ));
static void at_sockaddr	__P(( struct ddpcb *, struct mbuf * ));
static int at_pcbsetaddr	__P(( struct ddpcb *, struct mbuf *,
			struct proc * ));
static int at_pcbconnect	__P(( struct ddpcb *, struct mbuf *,
			struct proc *));
static void at_pcbdisconnect	__P(( struct ddpcb * ));
static int at_pcballoc	__P(( struct socket * ));
static void at_pcbdetach __P(( struct socket *, struct ddpcb * ));
struct ddpcb *ddp_search	__P(( struct sockaddr_at *,
			struct sockaddr_at *, struct at_ifaddr * ));
void ddp_init	__P((void));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.5 2001/07/06 03:06:28 angelos Exp $	*/
d75 13
a87 13
int ddp_usrreq(struct socket *, int, struct mbuf *,
			struct mbuf *, struct mbuf * );
static void at_sockaddr( struct ddpcb *, struct mbuf * );
static int at_pcbsetaddr( struct ddpcb *, struct mbuf *,
			struct proc * );
static int at_pcbconnect( struct ddpcb *, struct mbuf *,
			struct proc *);
static void at_pcbdisconnect( struct ddpcb * );
static int at_pcballoc( struct socket * );
static void at_pcbdetach( struct socket *, struct ddpcb * );
struct ddpcb *ddp_search( struct sockaddr_at *,
			struct sockaddr_at *, struct at_ifaddr * );
void ddp_init(void);
@


1.4
log
@Use MALLOC/FREE to allocate/free PCBs, instead of using MT_PCB
mbuf/clusters. My first commit of this died halfway through, so
although it did make it in, there was no message sent to the list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.3 2001/05/26 07:14:02 angelos Exp $	*/
d465 1
a465 1
    MALLOC( ddp, struct ddpcb *, sizeof(*ddp), M_PCB, M_NOWAIT );
d469 2
@


1.3
log
@No such thing as MT_PCB (anymore?) -- just use MALLOC/free to allocate
and free PCBs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.2 1997/07/24 00:25:23 deraadt Exp $	*/
d465 1
a465 1
    MALLOC(ddp, struct ddpcb *, sizeof(*ddp), M_PCB, M_NOWAIT);
d520 1
a520 1
    free(ddp, M_PCB);
@


1.2
log
@cmd is a u_long
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.1 1997/07/23 03:39:54 denny Exp $	*/
a463 1
    struct mbuf		*m;
d465 4
a468 2
    m = m_getclr( M_WAIT, MT_PCB );
    ddp = mtod( m, struct ddpcb * );
d520 1
a520 1
    (void) m_free( dtom( ddp ));
@


1.2.12.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.2 1997/07/24 00:25:23 deraadt Exp $	*/
d464 1
d466 2
a467 4
    MALLOC( ddp, struct ddpcb *, sizeof(*ddp), M_PCB, M_NOWAIT );
    if ( ddp == NULL ) {
	return (ENOBUFS);
    }
d519 1
a519 1
    FREE( ddp, M_PCB );
@


1.2.12.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ddp_usrreq.c,v 1.2.12.1 2001/07/04 10:54:23 niklas Exp $	*/
d465 1
a465 1
    MALLOC( ddp, struct ddpcb *, sizeof( *ddp ), M_PCB, M_NOWAIT );
a468 2
    bzero( ddp, sizeof( *ddp ));

@


1.2.12.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 13
a87 13
int ddp_usrreq(struct socket *, int, struct mbuf *,
			struct mbuf *, struct mbuf * );
static void at_sockaddr( struct ddpcb *, struct mbuf * );
static int at_pcbsetaddr( struct ddpcb *, struct mbuf *,
			struct proc * );
static int at_pcbconnect( struct ddpcb *, struct mbuf *,
			struct proc *);
static void at_pcbdisconnect( struct ddpcb * );
static int at_pcballoc( struct socket * );
static void at_pcbdetach( struct socket *, struct ddpcb * );
struct ddpcb *ddp_search( struct sockaddr_at *,
			struct sockaddr_at *, struct at_ifaddr * );
void ddp_init(void);
@


1.2.12.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d296 1
a296 1
		    suser( p, 0 )) {
@


1.1
log
@netatalk, based on the 1.4a2 dist from the University of Michigan.
The sys/netatalk files rely heavily on previous work done on FreeBSD, and to a lesser extent NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
	return( at_control( (int) m, (caddr_t) addr,
@
