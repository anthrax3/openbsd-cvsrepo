head	1.10;
access;
symbols
	OPENBSD_6_0:1.10.0.22
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.18
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.20
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.12
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.4
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.10
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.8
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.4
	OPENBSD_2_2_BASE:1.1
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2011.07.07.02.57.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.20.11.14.10;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.20.15.56.45;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.16.23.57.48;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.12.00.26.30;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.03.00.54.57;	author todd;	state Exp;
branches
	1.5.8.1
	1.5.10.1;
next	1.4;

1.4
date	98.09.08.04.07.47;	author millert;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	98.09.08.03.32.04;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.07.15.57.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.02.56.49;	author downsj;	state Exp;
branches;
next	;

1.4.8.1
date	2000.03.24.09.09.28;	author niklas;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.4.8.3;

1.4.8.3
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2002.03.13.15.54.29;	author jason;	state Exp;
branches;
next	;

1.5.10.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Replace the cruddy old sys/net/zlib.[ch].  We now use the sys/lib/libz
code.  Missing chunks of the API are imported from the libc version,
with a few #ifdef's to port it into the kernel environment.

The bootblocks already used the newer code, and should encounter no
surprises since there are so few changes to the existing files. In
the kernel, ipcomp and kernel ppp are changed to the new API.
ipcomp has been tested.

ok tedu the brave
@
text
@/*	$OpenBSD: adler32.c,v 1.6 2005/07/20 15:56:40 millert Exp $	*/
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2004 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#define ZLIB_INTERNAL
#include "zlib.h"

#define BASE 65521UL    /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* use NO_DIVIDE if your processor does not do division in hardware */
#ifdef NO_DIVIDE
#  define MOD(a) \
    do { \
        if (a >= (BASE << 16)) a -= (BASE << 16); \
        if (a >= (BASE << 15)) a -= (BASE << 15); \
        if (a >= (BASE << 14)) a -= (BASE << 14); \
        if (a >= (BASE << 13)) a -= (BASE << 13); \
        if (a >= (BASE << 12)) a -= (BASE << 12); \
        if (a >= (BASE << 11)) a -= (BASE << 11); \
        if (a >= (BASE << 10)) a -= (BASE << 10); \
        if (a >= (BASE << 9)) a -= (BASE << 9); \
        if (a >= (BASE << 8)) a -= (BASE << 8); \
        if (a >= (BASE << 7)) a -= (BASE << 7); \
        if (a >= (BASE << 6)) a -= (BASE << 6); \
        if (a >= (BASE << 5)) a -= (BASE << 5); \
        if (a >= (BASE << 4)) a -= (BASE << 4); \
        if (a >= (BASE << 3)) a -= (BASE << 3); \
        if (a >= (BASE << 2)) a -= (BASE << 2); \
        if (a >= (BASE << 1)) a -= (BASE << 1); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#  define MOD4(a) \
    do { \
        if (a >= (BASE << 4)) a -= (BASE << 4); \
        if (a >= (BASE << 3)) a -= (BASE << 3); \
        if (a >= (BASE << 2)) a -= (BASE << 2); \
        if (a >= (BASE << 1)) a -= (BASE << 1); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
        if (sum2 >= BASE)
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32_combine(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off_t len2;
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    /* the derivation of this formula is left as an exercise for the reader */
    rem = (unsigned)(len2 % BASE);
    sum1 = adler1 & 0xffff;
    sum2 = rem * sum1;
    MOD(sum2);
    sum1 += (adler2 & 0xffff) + BASE - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
    if (sum1 > BASE) sum1 -= BASE;
    if (sum1 > BASE) sum1 -= BASE;
    if (sum2 > (BASE << 1)) sum2 -= (BASE << 1);
    if (sum2 > BASE) sum2 -= BASE;
    return sum1 | (sum2 << 16);
}
@


1.9
log
@adler32_combine() is not used by anything AND requires qdivrem so ifdef it out; millert@@ deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.8 2005/07/20 15:56:45 millert Exp $	*/
a125 1
#ifdef ADLER32_COMBINE
a148 1
#endif /* ADLER32_COMBINE */
@


1.8
log
@Update to zlib 1.2.3; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.7 2003/12/16 23:57:48 millert Exp $	*/
d126 1
d150 1
@


1.7
log
@Update to zlib 1.2.1
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.5 2003/12/16 22:33:02 henning Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2003 Mark Adler
d14 1
a14 1
#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
d20 1
d42 8
d52 1
d61 50
a110 10
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? (int)len : NMAX;
        len -= k;
        while (k >= 16) {
a112 1
            k -= 16;
d114 6
a119 6
        if (k != 0) do {
            s1 += *buf++;
            s2 += s1;
        } while (--k);
        MOD(s1);
        MOD(s2);
d121 27
a147 1
    return (s2 << 16) | s1;
@


1.6
log
@Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.3 2000/03/02 00:29:51 todd Exp $	*/
d3 2
a4 2
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
d7 1
a7 1

d10 1
a10 1
#define BASE 65521L /* largest prime smaller than 65536 */
d20 25
d58 1
a58 1
        k = len < NMAX ? len : NMAX;
d62 1
a62 1
	    buf += 16;
d67 1
a67 1
	    s2 += s1;
d69 2
a70 2
        s1 %= BASE;
        s2 %= BASE;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.4 1998/09/08 04:07:47 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-1998 Mark Adler
@


1.5.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.5 2000/03/03 00:54:57 todd Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Mark Adler
@


1.5.8.1
log
@Pull in patch from current:
Fix (millert):
Update to zlib-1.1.4
@
text
@d1 1
a1 1
/*	$OpenBSD: adler32.c,v 1.6 2002/03/12 00:26:30 millert Exp $	*/
d3 1
a3 1
 * Copyright (C) 1995-2002 Mark Adler
@


1.4
log
@Let's commit the correct files, shall we.  This is the real zlib-1.1.3...
@
text
@d1 1
a6 1
/* @@(#) $Id: adler32.c,v 1.2 1998/08/08 20:57:07 millert Exp $ */
@


1.4.8.1
log
@Sync with -current
@
text
@a0 1
/*	$OpenBSD$	*/
d6 1
@


1.4.8.2
log
@Merge in -current from roughly a week ago
@
text
@d3 1
a3 1
 * Copyright (C) 1995-2002 Mark Adler
@


1.4.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d3 2
a4 2
 * Copyright (C) 1995-2003 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
d7 1
a7 1
#define ZLIB_INTERNAL
d10 1
a10 1
#define BASE 65521UL    /* largest prime smaller than 65536 */
a19 25
#ifdef NO_DIVIDE
#  define MOD(a) \
    do { \
        if (a >= (BASE << 16)) a -= (BASE << 16); \
        if (a >= (BASE << 15)) a -= (BASE << 15); \
        if (a >= (BASE << 14)) a -= (BASE << 14); \
        if (a >= (BASE << 13)) a -= (BASE << 13); \
        if (a >= (BASE << 12)) a -= (BASE << 12); \
        if (a >= (BASE << 11)) a -= (BASE << 11); \
        if (a >= (BASE << 10)) a -= (BASE << 10); \
        if (a >= (BASE << 9)) a -= (BASE << 9); \
        if (a >= (BASE << 8)) a -= (BASE << 8); \
        if (a >= (BASE << 7)) a -= (BASE << 7); \
        if (a >= (BASE << 6)) a -= (BASE << 6); \
        if (a >= (BASE << 5)) a -= (BASE << 5); \
        if (a >= (BASE << 4)) a -= (BASE << 4); \
        if (a >= (BASE << 3)) a -= (BASE << 3); \
        if (a >= (BASE << 2)) a -= (BASE << 2); \
        if (a >= (BASE << 1)) a -= (BASE << 1); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#endif

d33 1
a33 1
        k = len < NMAX ? (int)len : NMAX;
d37 1
a37 1
            buf += 16;
d42 1
a42 1
            s2 += s1;
d44 2
a45 2
        MOD(s1);
        MOD(s2);
@


1.3
log
@Update from zlib-1.1.3.  These should really just be references to ../../../lib/libz/*
@
text
@d2 1
a2 1
 * Copyright (C) 1995-1996 Mark Adler
d6 1
a6 1
/* $Id: adler32.c,v 1.10 1996/05/22 11:52:18 me Exp $ */
d21 1
a21 1
uLong adler32(adler, buf, len)
@


1.2
log
@$OpenBSD$
@
text
@a0 1
/* $OpenBSD: adler32.c,v 1.1 1997/02/06 02:56:49 downsj Exp $ */
d6 1
@


1.1
log
@Add libz and make libsa aware of it.  From NetBSD.
@
text
@d1 1
a6 1
/* $Id: adler32.c,v 1.1 1996/07/27 02:39:42 tholo Exp $ */
@
