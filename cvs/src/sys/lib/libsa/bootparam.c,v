head	1.12;
access;
symbols
	OPENBSD_6_2:1.12.0.16
	OPENBSD_6_2_BASE:1.12
	OPENBSD_6_1:1.12.0.14
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.6
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.46
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.42
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.40
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.38
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.36
	OPENBSD_5_0:1.11.0.34
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.32
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.30
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.26
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.28
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.24
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.22
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.20
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.18
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.16
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.14
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.12
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.18
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.16
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.14
	OPENBSD_2_8:1.8.0.12
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.10
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.8
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.6
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2014.07.13.15.31.20;	author mpi;	state Exp;
branches;
next	1.11;
commitid	7SdCoErqwI9qHMpK;

1.11
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.03.16.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	98.05.31.23.39.16;	author mickey;	state Exp;
branches
	1.8.8.1
	1.8.18.1;
next	1.7;

1.7
date	96.12.08.15.15.47;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.14.18.35;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.15.09.58.32;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.27.07.13.47;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.04.19.16.09.49;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.08.08.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.56;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.56;	author deraadt;	state Exp;
branches;
next	;

1.8.8.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.8.8.2;

1.8.8.2
date	2004.02.19.10.57.18;	author niklas;	state Exp;
branches;
next	;

1.8.18.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Stop using old n_long and n_short types.
@
text
@/*	$OpenBSD: bootparam.c,v 1.11 2003/08/11 06:23:09 deraadt Exp $	*/
/*	$NetBSD: bootparam.c,v 1.10 1996/10/14 21:16:55 thorpej Exp $	*/

/*
 * Copyright (c) 1995 Gordon W. Ross
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 * 4. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Gordon W. Ross
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * RPC/bootparams
 */

#include <sys/param.h>
#include <sys/socket.h>

#include <net/if.h>

#include <netinet/in.h>

#include <nfs/rpcv2.h>

#include "stand.h"
#include "net.h"
#include "netif.h"
#include "rpc.h"
#include "bootparam.h"

#ifdef DEBUG_RPC
#define RPC_PRINTF(a)	printf a
#else
#define RPC_PRINTF(a)	/* printf a */
#endif

struct in_addr	bp_server_addr;	/* net order */
u_int16_t	bp_server_port;	/* net order */

/*
 * RPC definitions for bootparamd
 */
#define	BOOTPARAM_PROG		100026
#define	BOOTPARAM_VERS		1
#define BOOTPARAM_WHOAMI	1
#define BOOTPARAM_GETFILE	2

/*
 * Inet address in RPC messages
 * (Note, really four ints, NOT chars.  Blech.)
 */
struct xdr_inaddr {
	u_int32_t  atype;
	int32_t	addr[4];
};

int xdr_inaddr_encode(char **p, struct in_addr ia);
int xdr_inaddr_decode(char **p, struct in_addr *ia);

int xdr_string_encode(char **p, char *str, int len);
int xdr_string_decode(char **p, char *str, int *len_p);


/*
 * RPC: bootparam/whoami
 * Given client IP address, get:
 *	client name	(hostname)
 *	domain name (domainname)
 *	gateway address
 *
 * The hostname and domainname are set here for convenience.
 *
 * Note - bpsin is initialized to the broadcast address,
 * and will be replaced with the bootparam server address
 * after this call is complete.  Have to use PMAP_PROC_CALL
 * to make sure we get responses only from a servers that
 * know about us (don't want to broadcast a getport call).
 */
int
bp_whoami(int sockfd)
{
	/* RPC structures for PMAPPROC_CALLIT */
	struct args {
		u_int32_t prog;
		u_int32_t vers;
		u_int32_t proc;
		u_int32_t arglen;
		struct xdr_inaddr xina;
	} *args;
	struct repl {
		u_int16_t _pad;
		u_int16_t port;
		u_int32_t encap_len;
		/* encapsulated data here */
		u_int32_t  capsule[64];
	} *repl;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct args d;
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct repl d;
	} rdata;
	char *send_tail, *recv_head;
	struct iodesc *d;
	int len, x;

	RPC_PRINTF(("bp_whoami: myip=%s\n", inet_ntoa(myip)));

	if (!(d = socktodesc(sockfd))) {
		RPC_PRINTF(("bp_whoami: bad socket. %d\n", sockfd));
		return (-1);
	}
	args = &sdata.d;
	repl = &rdata.d;

	/*
	 * Build request args for PMAPPROC_CALLIT.
	 */
	args->prog = htonl(BOOTPARAM_PROG);
	args->vers = htonl(BOOTPARAM_VERS);
	args->proc = htonl(BOOTPARAM_WHOAMI);
	args->arglen = htonl(sizeof(struct xdr_inaddr));
	send_tail = (char *)&args->xina;

	/*
	 * append encapsulated data (client IP address)
	 */
	if (xdr_inaddr_encode(&send_tail, myip))
		return (-1);

	/* RPC: portmap/callit */
	d->myport = htons(--rpc_port);
	d->destip.s_addr = INADDR_BROADCAST;	/* XXX: subnet bcast? */
	/* rpc_call will set d->destport */

	len = rpc_call(d, PMAPPROG, PMAPVERS, PMAPPROC_CALLIT,
	    args, send_tail - (char *)args,
	    repl, sizeof(*repl));
	if (len < 8) {
		printf("bootparamd: 'whoami' call failed\n");
		return (-1);
	}

	/* Save bootparam server address (from IP header). */
	rpc_fromaddr(repl, &bp_server_addr, &bp_server_port);

	/*
	 * Note that bp_server_port is now 111 due to the
	 * indirect call (using PMAPPROC_CALLIT), so get the
	 * actual port number from the reply data.
	 */
	bp_server_port = repl->port;

	RPC_PRINTF(("bp_whoami: server at %s:%d\n",
	    inet_ntoa(bp_server_addr), ntohs(bp_server_port)));

	/* We have just done a portmap call, so cache the portnum. */
	rpc_pmap_putcache(bp_server_addr, BOOTPARAM_PROG, BOOTPARAM_VERS,
	    (int)ntohs(bp_server_port));

	/*
	 * Parse the encapsulated results from bootparam/whoami
	 */
	x = ntohl(repl->encap_len);
	if (len < x) {
		printf("bp_whoami: short reply, %d < %d\n", len, x);
		return (-1);
	}
	recv_head = (char *)repl->capsule;

	/* client name */
	hostnamelen = MAXHOSTNAMELEN-1;
	if (xdr_string_decode(&recv_head, hostname, &hostnamelen)) {
		RPC_PRINTF(("bp_whoami: bad hostname\n"));
		return (-1);
	}

	/* domain name */
	domainnamelen = MAXHOSTNAMELEN-1;
	if (xdr_string_decode(&recv_head, domainname, &domainnamelen)) {
		RPC_PRINTF(("bp_whoami: bad domainname\n"));
		return (-1);
	}

	/* gateway address */
	if (xdr_inaddr_decode(&recv_head, &gateip)) {
		RPC_PRINTF(("bp_whoami: bad gateway\n"));
		return (-1);
	}

	/* success */
	return(0);
}


/*
 * RPC: bootparam/getfile
 * Given client name and file "key", get:
 *	server name
 *	server IP address
 *	server pathname
 */
int
bp_getfile(int sockfd, char *key, struct in_addr *serv_addr, char *pathname)
{
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		u_int32_t  d[64];
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		u_int32_t  d[128];
	} rdata;
	char serv_name[FNAME_SIZE];
	char *send_tail, *recv_head;
	/* misc... */
	struct iodesc *d;
	int sn_len, path_len, rlen;

	if (!(d = socktodesc(sockfd))) {
		RPC_PRINTF(("bp_getfile: bad socket. %d\n", sockfd));
		return (-1);
	}

	send_tail = (char *)sdata.d;
	recv_head = (char *)rdata.d;

	/*
	 * Build request message.
	 */

	/* client name (hostname) */
	if (xdr_string_encode(&send_tail, hostname, hostnamelen)) {
		RPC_PRINTF(("bp_getfile: bad client\n"));
		return (-1);
	}

	/* key name (root or swap) */
	if (xdr_string_encode(&send_tail, key, strlen(key))) {
		RPC_PRINTF(("bp_getfile: bad key\n"));
		return (-1);
	}

	/* RPC: bootparam/getfile */
	d->myport = htons(--rpc_port);
	d->destip   = bp_server_addr;
	/* rpc_call will set d->destport */

	rlen = rpc_call(d,
		BOOTPARAM_PROG, BOOTPARAM_VERS, BOOTPARAM_GETFILE,
		sdata.d, send_tail - (char *)sdata.d,
		rdata.d, sizeof(rdata.d));
	if (rlen < 4) {
		RPC_PRINTF(("bp_getfile: short reply\n"));
		errno = EBADRPC;
		return (-1);
	}
	recv_head = (char *)rdata.d;

	/*
	 * Parse result message.
	 */

	/* server name */
	sn_len = FNAME_SIZE-1;
	if (xdr_string_decode(&recv_head, serv_name, &sn_len)) {
		RPC_PRINTF(("bp_getfile: bad server name\n"));
		return (-1);
	}

	/* server IP address (mountd/NFS) */
	if (xdr_inaddr_decode(&recv_head, serv_addr)) {
		RPC_PRINTF(("bp_getfile: bad server addr\n"));
		return (-1);
	}

	/* server pathname */
	path_len = MAXPATHLEN-1;
	if (xdr_string_decode(&recv_head, pathname, &path_len)) {
		RPC_PRINTF(("bp_getfile: bad server path\n"));
		return (-1);
	}

	/* success */
	return(0);
}


/*
 * eXternal Data Representation routines.
 * (but with non-standard args...)
 */

int
xdr_string_encode(char **pkt, char *str, int len)
{
	u_int32_t *lenp;
	char *datap;
	int padlen = (len + 3) & ~3;	/* padded length */

	/* The data will be int aligned. */
	lenp = (u_int32_t*) *pkt;
	*pkt += sizeof(*lenp);
	*lenp = htonl(len);

	datap = *pkt;
	*pkt += padlen;
	bcopy(str, datap, len);

	return (0);
}

int
xdr_string_decode(char **pkt, char *str, int *len_p)
{
	u_int32_t *lenp;
	char *datap;
	int slen;	/* string length */
	int plen;	/* padded length */

	/* The data will be int aligned. */
	lenp = (u_int32_t*) *pkt;
	*pkt += sizeof(*lenp);
	slen = ntohl(*lenp);
	plen = (slen + 3) & ~3;

	if (slen > *len_p)
		slen = *len_p;
	datap = *pkt;
	*pkt += plen;
	bcopy(datap, str, slen);

	str[slen] = '\0';
	*len_p = slen;

	return (0);
}

int
xdr_inaddr_encode(char **pkt, struct in_addr ia)
{
	struct xdr_inaddr *xi;
	u_char *cp;
	int32_t *ip;
	union {
		u_int32_t l;	/* network order */
		u_char c[4];
	} uia;

	/* The data will be int aligned. */
	xi = (struct xdr_inaddr *) *pkt;
	*pkt += sizeof(*xi);
	xi->atype = htonl(1);
	uia.l = ia.s_addr;
	cp = uia.c;
	ip = xi->addr;
	/*
	 * Note: the htonl() calls below DO NOT
	 * imply that uia.l is in host order.
	 * In fact this needs it in net order.
	 */
	*ip++ = htonl((unsigned int)*cp++);
	*ip++ = htonl((unsigned int)*cp++);
	*ip++ = htonl((unsigned int)*cp++);
	*ip++ = htonl((unsigned int)*cp++);

	return (0);
}

int
xdr_inaddr_decode(char **pkt, struct in_addr *ia)
{
	struct xdr_inaddr *xi;
	u_char *cp;
	int32_t *ip;
	union {
		u_int32_t l;	/* network order */
		u_char c[4];
	} uia;

	/* The data will be int aligned. */
	xi = (struct xdr_inaddr *) *pkt;
	*pkt += sizeof(*xi);
	if (xi->atype != htonl(1)) {
		RPC_PRINTF(("xdr_inaddr_decode: bad addrtype=%d\n",
		    ntohl(xi->atype)));
		return(-1);
	}

	cp = uia.c;
	ip = xi->addr;
	/*
	 * Note: the ntohl() calls below DO NOT
	 * imply that uia.l is in host order.
	 * In fact this needs it in net order.
	 */
	*cp++ = ntohl(*ip++);
	*cp++ = ntohl(*ip++);
	*cp++ = ntohl(*ip++);
	*cp++ = ntohl(*ip++);
	ia->s_addr = uia.l;

	return (0);
}
@


1.11
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.10 2002/03/14 03:16:09 millert Exp $	*/
a43 1
#include <netinet/in_systm.h>
d60 1
a60 1
n_short		bp_server_port;	/* net order */
d117 1
a117 1
		n_long  capsule[64];
d120 1
a120 1
		n_long	h[RPC_HEADER_WORDS];
d124 1
a124 1
		n_long	h[RPC_HEADER_WORDS];
d231 2
a232 2
		n_long	h[RPC_HEADER_WORDS];
		n_long  d[64];
d235 2
a236 2
		n_long	h[RPC_HEADER_WORDS];
		n_long  d[128];
d370 1
a370 1
		n_long l;	/* network order */
d401 1
a401 1
		n_long l;	/* network order */
@


1.10
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.9 2002/03/14 01:27:07 millert Exp $	*/
d103 1
a103 2
bp_whoami(sockfd)
	int sockfd;
d162 2
a163 2
				  args, send_tail - (char *)args,
				  repl, sizeof(*repl));
d183 2
a184 4
	rpc_pmap_putcache(bp_server_addr,
			  BOOTPARAM_PROG,
			  BOOTPARAM_VERS,
			  (int)ntohs(bp_server_port));
d229 1
a229 5
bp_getfile(sockfd, key, serv_addr, pathname)
	int sockfd;
	char *key;
	char *pathname;
	struct in_addr *serv_addr;
a318 1

d320 1
a320 4
xdr_string_encode(pkt, str, len)
	char **pkt;
	char *str;
	int len;
d339 1
a339 4
xdr_string_decode(pkt, str, len_p)
	char **pkt;
	char *str;
	int *len_p;		/* bufsize - 1 */
a363 1

d365 1
a365 3
xdr_inaddr_encode(pkt, ia)
	char **pkt;
	struct in_addr ia;		/* network order */
d396 1
a396 3
xdr_inaddr_decode(pkt, ia)
	char **pkt;
	struct in_addr *ia;		/* network order */
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.8 1998/05/31 23:39:16 mickey Exp $	*/
d149 1
a149 1
	send_tail = (char*) &args->xina;
d163 1
a163 1
				  args, send_tail - (char*)args,
d197 1
a197 1
	recv_head = (char*) repl->capsule;
d257 2
a258 2
	send_tail = (char*) sdata.d;
	recv_head = (char*) rdata.d;
d283 1
a283 1
		sdata.d, send_tail - (char*)sdata.d,
d290 1
a290 1
	recv_head = (char*) rdata.d;
@


1.8
log
@cleanup for  !ANSI compilers, mostly __P usage
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.7 1996/12/08 15:15:47 niklas Exp $	*/
d80 2
a81 2
int xdr_inaddr_encode __P((char **p, struct in_addr ia));
int xdr_inaddr_decode __P((char **p, struct in_addr *ia));
d83 2
a84 2
int xdr_string_encode __P((char **p, char *str, int len));
int xdr_string_decode __P((char **p, char *str, int *len_p));
@


1.8.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.8 1998/05/31 23:39:16 mickey Exp $	*/
d80 2
a81 2
int xdr_inaddr_encode(char **p, struct in_addr ia);
int xdr_inaddr_decode(char **p, struct in_addr *ia);
d83 2
a84 2
int xdr_string_encode(char **p, char *str, int len);
int xdr_string_decode(char **p, char *str, int *len_p);
d149 1
a149 1
	send_tail = (char *)&args->xina;
d163 1
a163 1
				  args, send_tail - (char *)args,
d197 1
a197 1
	recv_head = (char *)repl->capsule;
d257 2
a258 2
	send_tail = (char *)sdata.d;
	recv_head = (char *)rdata.d;
d283 1
a283 1
		sdata.d, send_tail - (char *)sdata.d,
d290 1
a290 1
	recv_head = (char *)rdata.d;
@


1.8.8.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 2
a81 2
int xdr_inaddr_encode(char **p, struct in_addr ia);
int xdr_inaddr_decode(char **p, struct in_addr *ia);
d83 2
a84 2
int xdr_string_encode(char **p, char *str, int len);
int xdr_string_decode(char **p, char *str, int *len_p);
d149 1
a149 1
	send_tail = (char *)&args->xina;
d163 1
a163 1
				  args, send_tail - (char *)args,
d197 1
a197 1
	recv_head = (char *)repl->capsule;
d257 2
a258 2
	send_tail = (char *)sdata.d;
	recv_head = (char *)rdata.d;
d283 1
a283 1
		sdata.d, send_tail - (char *)sdata.d,
d290 1
a290 1
	recv_head = (char *)rdata.d;
@


1.8.8.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d103 2
a104 1
bp_whoami(int sockfd)
d163 2
a164 2
	    args, send_tail - (char *)args,
	    repl, sizeof(*repl));
d184 4
a187 2
	rpc_pmap_putcache(bp_server_addr, BOOTPARAM_PROG, BOOTPARAM_VERS,
	    (int)ntohs(bp_server_port));
d232 5
a236 1
bp_getfile(int sockfd, char *key, struct in_addr *serv_addr, char *pathname)
d326 1
d328 4
a331 1
xdr_string_encode(char **pkt, char *str, int len)
d350 4
a353 1
xdr_string_decode(char **pkt, char *str, int *len_p)
d378 1
d380 3
a382 1
xdr_inaddr_encode(char **pkt, struct in_addr ia)
d413 3
a415 1
xdr_inaddr_decode(char **pkt, struct in_addr *ia)
@


1.7
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.6 1996/10/16 14:18:35 mickey Exp $	*/
d57 1
a57 1
#define RPC_PRINTF(a)
@


1.6
log
@remove unneeded include <string.h>
@
text
@d1 2
a2 2
/*	$OpenBSD: bootparam.c,v 1.5 1996/10/15 09:58:32 mickey Exp $	*/
/*	$NetBSD: bootparam.c,v 1.7 1996/02/26 23:05:14 gwr Exp $	*/
d54 6
d133 1
a133 3
#ifdef	RPC_DEBUG
	printf("bp_whoami: myip=%s\n", inet_ntoa(myip));
#endif
d136 1
a136 3
#ifdef	RPC_DEBUG
		printf("bp_whoami: bad socket. %d\n", sockfd);
#endif
d180 2
a181 4
#ifdef	RPC_DEBUG
	printf("bp_whoami: server at %s:%d\n",
		   inet_ntoa(bp_server_addr), ntohs(bp_server_port));
#endif
d202 1
a202 3
#ifdef	RPC_DEBUG
		printf("bp_whoami: bad hostname\n");
#endif
d209 1
a209 3
#ifdef	RPC_DEBUG
		printf("bp_whoami: bad domainname\n");
#endif
d215 1
a215 3
#ifdef	RPC_DEBUG
		printf("bp_whoami: bad gateway\n");
#endif
d253 1
a253 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad socket. %d\n", sockfd);
#endif
d266 1
a266 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad client\n");
#endif
d272 1
a272 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad key\n");
#endif
d286 1
a286 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: short reply\n");
#endif
d299 1
a299 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad server name\n");
#endif
d305 1
a305 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad server addr\n");
#endif
d312 1
a312 3
#ifdef	RPC_DEBUG
		printf("bp_getfile: bad server path\n");
#endif
d429 2
a430 4
#ifdef	RPC_DEBUG
		printf("xdr_inaddr_decode: bad addrtype=%ld\n",
			   ntohl(xi->atype));
#endif
@


1.5
log
@gcc -Wall happy
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.4 1996/09/27 07:13:47 mickey Exp $	*/
a44 2

#include <string.h>
@


1.4
log
@use nfs/{nfsv2.h,rpcv2.h} instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: bootparam.c,v 1.3 1996/04/19 16:09:49 niklas Exp $	*/
d452 1
a452 1
		printf("xdr_inaddr_decode: bad addrtype=%d\n",
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
#include "rpcv2.h"
@


1.2
log
@from gwr
Correct error which caused truncation of port number on i386 (PR#1823)
@
text
@d1 2
a2 1
/*	$NetBSD: bootparam.c,v 1.6 1995/12/08 04:10:28 gwr Exp $	*/
d46 1
a46 1
#include <nfs/rpcv2.h>
d48 1
a48 1
#include <string.h>
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: bootparam.c,v 1.5 1995/09/23 03:36:07 gwr Exp $	*/
d110 2
a111 1
		u_int32_t port;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
