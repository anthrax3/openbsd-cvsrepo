head	1.7;
access;
symbols
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.10
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.10
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.8
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.6
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.4
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.2
	OPENBSD_2_4_BASE:1.4;
locks; strict;
comment	@ * @;


1.7
date	2003.04.17.13.23.14;	author mickey;	state dead;
branches;
next	1.6;

1.6
date	2002.07.09.01.45.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.30.21.59.30;	author mickey;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	98.08.27.20.38.15;	author mickey;	state Exp;
branches
	1.4.8.1;
next	1.3;

1.3
date	98.07.29.00.37.52;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	98.07.14.14.56.05;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	98.07.14.03.29.08;	author mickey;	state Exp;
branches;
next	;

1.4.8.1
date	2001.05.14.22.32.52;	author niklas;	state Exp;
branches;
next	1.4.8.2;

1.4.8.2
date	2003.03.28.00.41.27;	author niklas;	state Exp;
branches;
next	1.4.8.3;

1.4.8.3
date	2003.05.13.19.21.29;	author ho;	state dead;
branches;
next	;

1.5.8.1
date	2002.10.29.00.36.45;	author art;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2003.05.19.21.53.42;	author tedu;	state dead;
branches;
next	;


desc
@@


1.7
log
@replaced by loadfile now
@
text
@/*	$OpenBSD: exec_elf.c,v 1.6 2002/07/09 01:45:47 mickey Exp $	*/

/*
 * Copyright (c) 1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "libsa.h"
#include <lib/libsa/exec.h>
#include <sys/exec_elf.h>
#include <ddb/db_aout.h>

int
elf_probe(fd, hdr)
	int fd;
	union x_header *hdr;
{
	return IS_ELF(hdr->x_elf);
}

int
elf_load(fd, xp)
	int fd;
	struct x_param *xp;
{
	register Elf32_Ehdr *ehdr = (Elf32_Ehdr *)xp->xp_hdr;
	register Elf32_Phdr *ph;
	Elf32_Phdr phdr[8];	/* XXX hope this is enough */
	size_t phsize;
	register u_int pa;

#ifdef EXEC_DEBUG
	if (debug)
		printf("id=%x.%c%c%c.%x.%x, type=%x, mach=%x, ver=%x, size=%d\n"
		       "\tep=%x, flgs=%x, ph=%x[%dx%d], sh=%x[%dx%d], str=%x\n",
		       ehdr->e_ident[0], ehdr->e_ident[1], ehdr->e_ident[2],
		       ehdr->e_ident[3], ehdr->e_ident[4], ehdr->e_ident[5],
		       ehdr->e_type, ehdr->e_machine, ehdr->e_version,
		       ehdr->e_ehsize, ehdr->e_entry, ehdr->e_flags,
		       ehdr->e_phoff, ehdr->e_phnum, ehdr->e_phentsize,
		       ehdr->e_shoff, ehdr->e_shnum, ehdr->e_shentsize,
		       ehdr->e_shstrndx);
#endif

	xp->xp_entry = ehdr->e_entry;

	if (lseek(fd, ehdr->e_phoff, SEEK_SET) <= 0) {
#ifdef EXEC_DEBUG
		if (debug)
			printf("lseek failed (%d)\n", errno);
#endif
		return -1;
	}
	
	phsize = ehdr->e_phnum * ehdr->e_phentsize;
	if (phsize > sizeof(phdr) || read(fd, phdr, phsize) != phsize) {
#ifdef EXEC_DEBUG
		if (debug)
			printf("phdr read failed (%d)\n", errno);
#endif
		return -1;
	}

	pa = 0;
	for (ph = phdr; ph < &phdr[ehdr->e_phnum]; ph++) {
#ifdef EXEC_DEBUG
		if (debug)
			printf("ph%d: type=%x, off=%d, va=%x, fs=%d, ms=%d, "
			       "flags=%x\n", (ph - phdr), ph->p_type,
			       ph->p_offset, ph->p_vaddr, ph->p_filesz,
			       ph->p_memsz, ph->p_flags);
#endif
		if (ph->p_filesz && ph->p_flags & PF_X) {
			pa = ph->p_vaddr;
			xp->text.addr = ph->p_vaddr;
			xp->text.size = ph->p_filesz;
			xp->text.foff = ph->p_offset;
		} else if (ph->p_filesz && ph->p_flags & PF_W) {
			xp->data.addr = ph->p_vaddr;
			xp->data.size = ph->p_filesz;
			xp->data.foff = ph->p_offset;
			if (ph->p_filesz < ph->p_memsz) {
				xp->bss.addr = ph->p_vaddr + ph->p_filesz;
				xp->bss.size = ph->p_memsz - ph->p_filesz;
				xp->bss.foff = 0;
			}
		} else if (!ph->p_filesz) {
			xp->bss.addr = ph->p_vaddr;
			xp->bss.size = ph->p_memsz;
			xp->bss.foff = 0;
		}
	}

	return 0;
}

int
elf_ldsym(fd, xp)
	int fd;
	struct x_param *xp;
{
	register Elf32_Ehdr *ehdr = (Elf32_Ehdr *)xp->xp_hdr;
	Elf32_Sym elfsym;
	Elf32_Shdr shdr[32];	/* XXX hope this is enough */
	register Elf32_Shdr *sh;
	register struct nlist *nl;
	register u_int ss, shsize;

	if (lseek(fd, ehdr->e_shoff, SEEK_SET) <= 0) {
#ifdef DEBUG
		printf("ehdr lseek: %s\n", strerror(errno));
#endif
		return -1;
	}

	/* calc symbols location, scanning section headers */
	shsize = ehdr->e_shnum * ehdr->e_shentsize;
	sh = shdr;

	if (shsize > sizeof(shdr) || read(fd, shdr, shsize) != shsize) {
#ifdef DEBUG
		printf("shdr read: %s\n", strerror(errno));
#endif
		return -1;
	}

	for (sh = shdr; sh < &shdr[ehdr->e_shnum]; sh++) {
#ifdef EXEC_DEBUG
		if (debug)
			printf ("sh%d: type=%x, flags=%x, addr=%x, "
				"foff=%x, sz=%x, link=%x, info=%x, "
				"allign=%x, esz=%x\n", sh - shdr,
				sh->sh_type, sh->sh_flags, sh->sh_addr,
				sh->sh_offset, sh->sh_size, sh->sh_link,
				sh->sh_info, sh->sh_addralign, sh->sh_entsize);
#endif
		if (sh->sh_type == SHT_SYMTAB) {
			xp->sym.addr = xp->bss.addr + xp->bss.size;
			xp->sym.foff = sh->sh_offset;
			xp->sym.size = sh->sh_size;
			if (sh->sh_link && sh->sh_link < ehdr->e_shnum &&
			    shdr[sh->sh_link].sh_type == SHT_STRTAB) {
				xp->str.foff = shdr[sh->sh_link].sh_offset;
				xp->str.size = shdr[sh->sh_link].sh_size;
			}
		}
	}

	if (!xp->sym.size || !xp->str.size)
		return 0;

	if (lseek(fd, xp->sym.foff, SEEK_SET) <= 0) {
#ifdef DEBUG
		printf("syms lseek: %s\n", strerror(errno));
#endif
		return -1;
	}

	nl = (struct nlist *)((long *)xp->xp_end + 1);
	for (ss = xp->sym.size; ss >= sizeof(elfsym);
	     ss -= sizeof(elfsym), nl++) {

		if (read(fd, &elfsym, sizeof(elfsym)) != sizeof(elfsym)) {
#ifdef DEBUG
			printf ("read elfsym: %s\n", strerror(errno));
#endif
			return -1;
		}
		nl->n_un.n_strx = (long)elfsym.st_name + sizeof(int);
		nl->n_value = elfsym.st_value;
		nl->n_desc = 0;
		nl->n_other = 0;
		switch (ELF32_ST_TYPE(elfsym.st_info)) {
		case STT_FILE:
			nl->n_type = N_FN;
			break;
		case STT_FUNC:
			nl->n_type = N_TEXT;
			break;
		case STT_OBJECT:
			nl->n_type = N_DATA;
			break;
		case STT_NOTYPE:
			if (elfsym.st_shndx == SHN_UNDEF) {
				nl->n_type = N_UNDF;
				break;
			} else if (elfsym.st_shndx == SHN_ABS) {
				nl->n_type = N_ABS;
				break;
			} else if (shdr[elfsym.st_shndx - 1].sh_type ==
				   SHT_NULL) {
				/* XXX this is probably bogus */
				nl->n_type = N_ABS;
				break;
			} else if (shdr[elfsym.st_shndx - 1].sh_type ==
				   SHT_PROGBITS) {
				/* XXX this is probably bogus */
				nl->n_type = N_BSS;
				break;
			}
#ifdef EXEC_DEBUG
			else
				printf ("sec[%d]=0x%x,val=0x%lx\n",
					elfsym.st_shndx,
					shdr[elfsym.st_shndx - 1].sh_type,
					nl->n_value);
#endif
		case STT_LOPROC:
		case STT_HIPROC:
		case STT_SECTION:
			nl--;
			continue;

		default:
#ifdef DEBUG
			printf ("elf_ldsym: unknown type %d\n",
				ELF32_ST_TYPE(elfsym.st_info));
#endif
			nl--;
			continue;
		}
		switch (ELF32_ST_BIND(elfsym.st_info)) {
		case STB_WEAK:
		case STB_GLOBAL:
			nl->n_type |= N_EXT;
			break;
		case STB_LOCAL:
			break;
		default:
#ifdef DEBUG
			printf ("elf_ldsym: unknown bind %d\n",
				ELF32_ST_BIND(elfsym.st_info));
#endif
			break;
		}
	}

	printf (" [%d", (char *)nl - (char *)xp->xp_end);
	*(long *)xp->xp_end = (char *)nl - (char *)xp->xp_end - sizeof(long);

	if (lseek(fd, xp->str.foff, SEEK_SET) <= 0) {
#ifdef DEBUG
		printf("strings lseek: %s\n", strerror(errno));
#endif
		return -1;
	}

	*((int *)nl)++ = xp->str.size + sizeof(int);
	if (read(fd, nl, xp->str.size) != xp->str.size) {
#ifdef DEBUG
		printf ("read strings: %s\n", strerror(errno));
#endif
		return -1;
	}

	printf ("+%d]", xp->str.size);

	xp->xp_end = ((u_int)nl + xp->str.size + 3) & ~3;

	return 0;
}

@


1.6
log
@changing kernel load address does not work that well w/ elf, load it where it was linked
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.5 2000/05/30 21:59:30 mickey Exp $	*/
@


1.5
log
@split symbol loading for a.out into a separate routine (tested on i386)
add symbol loading for elf (tested on hppa)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.4 1998/08/27 20:38:15 mickey Exp $	*/
d100 1
a100 1
			xp->text.addr = 0;
d104 1
a104 1
			xp->data.addr = ph->p_vaddr - pa;
d108 1
a108 1
				xp->bss.addr = ph->p_vaddr + ph->p_filesz - pa;
d113 1
a113 1
			xp->bss.addr = ph->p_vaddr - pa;
@


1.5.8.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.5 2000/05/30 21:59:30 mickey Exp $	*/
d100 1
a100 1
			xp->text.addr = ph->p_vaddr;
d104 1
a104 1
			xp->data.addr = ph->p_vaddr;
d108 1
a108 1
				xp->bss.addr = ph->p_vaddr + ph->p_filesz;
d113 1
a113 1
			xp->bss.addr = ph->p_vaddr;
@


1.5.8.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.5.8.1 2002/10/29 00:36:45 art Exp $	*/
@


1.4
log
@better .bss treatment
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.3 1998/07/29 00:37:52 mickey Exp $	*/
d36 1
a52 1
	register Elf32_Shdr *sh;
d54 1
a54 2
	Elf32_Shdr shdr[32];	/* XXX hope this is enough */
	size_t phsize, shsize;
d93 1
a93 1
			printf("ph%d: type=%x, off==%d, va=%x, fs=%d, ms=%d, "
d119 15
d135 2
a136 3
#ifdef EXEC_DEBUG
		if (debug)
			printf("lseek failed (%d)\n", errno);
d144 1
a144 1
#if notyet
d146 2
a147 3
#ifdef EXEC_DEBUG
		if (debug)
			printf("shdr read failed (%d)\n", errno);
d153 11
a163 2
		switch (sh->sh_type) {
		case SHT_SYMTAB:
d166 5
a170 3
		case SHT_STRTAB:
			xp->str.foff = sh->sh_offset;
			xp->str.size = sh->sh_size;
a171 1
		break;
d173 7
d181 104
@


1.4.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.5 2000/05/30 21:59:30 mickey Exp $	*/
a35 1
#include <ddb/db_aout.h>
d52 1
d54 2
a55 1
	size_t phsize;
d94 1
a94 1
			printf("ph%d: type=%x, off=%d, va=%x, fs=%d, ms=%d, "
a119 15
	return 0;
}

int
elf_ldsym(fd, xp)
	int fd;
	struct x_param *xp;
{
	register Elf32_Ehdr *ehdr = (Elf32_Ehdr *)xp->xp_hdr;
	Elf32_Sym elfsym;
	Elf32_Shdr shdr[32];	/* XXX hope this is enough */
	register Elf32_Shdr *sh;
	register struct nlist *nl;
	register u_int ss, shsize;

d121 3
a123 2
#ifdef DEBUG
		printf("ehdr lseek: %s\n", strerror(errno));
d131 1
a131 1

d133 3
a135 2
#ifdef DEBUG
		printf("shdr read: %s\n", strerror(errno));
d141 2
a142 11
#ifdef EXEC_DEBUG
		if (debug)
			printf ("sh%d: type=%x, flags=%x, addr=%x, "
				"foff=%x, sz=%x, link=%x, info=%x, "
				"allign=%x, esz=%x\n", sh - shdr,
				sh->sh_type, sh->sh_flags, sh->sh_addr,
				sh->sh_offset, sh->sh_size, sh->sh_link,
				sh->sh_info, sh->sh_addralign, sh->sh_entsize);
#endif
		if (sh->sh_type == SHT_SYMTAB) {
			xp->sym.addr = xp->bss.addr + xp->bss.size;
d145 3
a147 5
			if (sh->sh_link && sh->sh_link < ehdr->e_shnum &&
			    shdr[sh->sh_link].sh_type == SHT_STRTAB) {
				xp->str.foff = shdr[sh->sh_link].sh_offset;
				xp->str.size = shdr[sh->sh_link].sh_size;
			}
d149 1
a150 7

	if (!xp->sym.size || !xp->str.size)
		return 0;

	if (lseek(fd, xp->sym.foff, SEEK_SET) <= 0) {
#ifdef DEBUG
		printf("syms lseek: %s\n", strerror(errno));
a151 104
		return -1;
	}

	nl = (struct nlist *)((long *)xp->xp_end + 1);
	for (ss = xp->sym.size; ss >= sizeof(elfsym);
	     ss -= sizeof(elfsym), nl++) {

		if (read(fd, &elfsym, sizeof(elfsym)) != sizeof(elfsym)) {
#ifdef DEBUG
			printf ("read elfsym: %s\n", strerror(errno));
#endif
			return -1;
		}
		nl->n_un.n_strx = (long)elfsym.st_name + sizeof(int);
		nl->n_value = elfsym.st_value;
		nl->n_desc = 0;
		nl->n_other = 0;
		switch (ELF32_ST_TYPE(elfsym.st_info)) {
		case STT_FILE:
			nl->n_type = N_FN;
			break;
		case STT_FUNC:
			nl->n_type = N_TEXT;
			break;
		case STT_OBJECT:
			nl->n_type = N_DATA;
			break;
		case STT_NOTYPE:
			if (elfsym.st_shndx == SHN_UNDEF) {
				nl->n_type = N_UNDF;
				break;
			} else if (elfsym.st_shndx == SHN_ABS) {
				nl->n_type = N_ABS;
				break;
			} else if (shdr[elfsym.st_shndx - 1].sh_type ==
				   SHT_NULL) {
				/* XXX this is probably bogus */
				nl->n_type = N_ABS;
				break;
			} else if (shdr[elfsym.st_shndx - 1].sh_type ==
				   SHT_PROGBITS) {
				/* XXX this is probably bogus */
				nl->n_type = N_BSS;
				break;
			}
#ifdef EXEC_DEBUG
			else
				printf ("sec[%d]=0x%x,val=0x%lx\n",
					elfsym.st_shndx,
					shdr[elfsym.st_shndx - 1].sh_type,
					nl->n_value);
#endif
		case STT_LOPROC:
		case STT_HIPROC:
		case STT_SECTION:
			nl--;
			continue;

		default:
#ifdef DEBUG
			printf ("elf_ldsym: unknown type %d\n",
				ELF32_ST_TYPE(elfsym.st_info));
#endif
			nl--;
			continue;
		}
		switch (ELF32_ST_BIND(elfsym.st_info)) {
		case STB_WEAK:
		case STB_GLOBAL:
			nl->n_type |= N_EXT;
			break;
		case STB_LOCAL:
			break;
		default:
#ifdef DEBUG
			printf ("elf_ldsym: unknown bind %d\n",
				ELF32_ST_BIND(elfsym.st_info));
#endif
			break;
		}
	}

	printf (" [%d", (char *)nl - (char *)xp->xp_end);
	*(long *)xp->xp_end = (char *)nl - (char *)xp->xp_end - sizeof(long);

	if (lseek(fd, xp->str.foff, SEEK_SET) <= 0) {
#ifdef DEBUG
		printf("strings lseek: %s\n", strerror(errno));
#endif
		return -1;
	}

	*((int *)nl)++ = xp->str.size + sizeof(int);
	if (read(fd, nl, xp->str.size) != xp->str.size) {
#ifdef DEBUG
		printf ("read strings: %s\n", strerror(errno));
#endif
		return -1;
	}

	printf ("+%d]", xp->str.size);

	xp->xp_end = ((u_int)nl + xp->str.size + 3) & ~3;

@


1.4.8.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 1
a100 1
			xp->text.addr = ph->p_vaddr;
d104 1
a104 1
			xp->data.addr = ph->p_vaddr;
d108 1
a108 1
				xp->bss.addr = ph->p_vaddr + ph->p_filesz;
d113 1
a113 1
			xp->bss.addr = ph->p_vaddr;
@


1.4.8.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.4.8.2 2003/03/28 00:41:27 niklas Exp $	*/
@


1.3
log
@some debug prints; one lseek fix
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.2 1998/07/14 14:56:05 mickey Exp $	*/
d99 1
a99 1
		if (ntohl(ph->p_filesz) && ntohl(ph->p_flags) & PF_X) {
d104 1
a104 1
		} else if (ntohl(ph->p_filesz) && ntohl(ph->p_flags) & PF_W) {
d108 6
a113 1
		} else if (!ntohl(ph->p_filesz)) {
@


1.2
log
@no need for machine/exec.h
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.c,v 1.1 1998/07/14 03:29:08 mickey Exp $	*/
d51 4
a54 2
	register Elf32_Phdr *phdr, *ph;
	register Elf32_Shdr *shdr, *sh;
d56 14
a69 1
	u_int pa;
d73 5
a77 1
	if (lseek(fd, ehdr->e_phoff, SEEK_SET) <= 0)
d79 1
d82 5
a86 3
	phdr = alloca(phsize);

	if (read(fd, phdr, phsize) != phsize)
d88 1
d92 7
d115 5
a119 1
	if (lseek(fd, ehdr->e_shoff, SEEK_SET))
d121 1
d123 1
d125 7
a131 3
	shdr = (Elf32_Shdr *) alloca(shsize);

	if (read(fd, shdr, shsize) != shsize)
d133 1
d146 1
a146 1

@


1.1
log
@multiformat exec framework
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a33 1
#include <machine/exec.h>
@

