head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.14.0.6
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.2
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.10.0.46
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.42
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.40
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.38
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.36
	OPENBSD_5_0:1.10.0.34
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.32
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.30
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.26
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.28
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.24
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.22
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.20
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.18
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.16
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.30
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.28
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.26
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.8.0.24
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.22
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.20
	OPENBSD_2_8:1.8.0.18
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.16
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.14
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.12
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.10
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.8
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.8.0.6
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2017.05.08.20.13.46;	author patrick;	state Exp;
branches;
next	1.14;
commitid	PrEAKFQhTx5NqZ8q;

1.14
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.13;
commitid	kCz5QgxnxRMKOzNf;

1.13
date	2015.08.15.19.40.59;	author miod;	state Exp;
branches;
next	1.12;
commitid	LJh36eI2WnptgtB9;

1.12
date	2014.11.19.20.28.56;	author miod;	state Exp;
branches;
next	1.11;
commitid	F3EvOaAgKQy5tMAq;

1.11
date	2014.07.13.15.31.20;	author mpi;	state Exp;
branches;
next	1.10;
commitid	7SdCoErqwI9qHMpK;

1.10
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.01.17.00.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.03.25.20.30.43;	author niklas;	state Exp;
branches
	1.8.14.1;
next	1.7;

1.7
date	97.02.16.14.39.39;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.12.08.15.15.52;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.15.09.58.34;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.27.07.13.48;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.00.44;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.09.50;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches;
next	;

1.8.14.1
date	2003.06.07.11.03.42;	author ho;	state Exp;
branches;
next	1.8.14.2;

1.8.14.2
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Guard debug printf with NFS_DEBUG ifdef like the other debug prints.

ok tom@@
@
text
@/*	$OpenBSD: nfs.c,v 1.14 2016/03/14 23:08:06 krw Exp $	*/
/*	$NetBSD: nfs.c,v 1.19 1996/10/13 02:29:04 christos Exp $	*/

/*-
 *  Copyright (c) 1993 John Brezak
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR `AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/stat.h>

#include <netinet/in.h>

#include "rpcv2.h"
#include "nfsv2.h"

#include "stand.h"
#include "saerrno.h"
#include "net.h"
#include "netif.h"
#include "nfs.h"
#include "rpc.h"

/* Define our own NFS attributes without NQNFS stuff. */
struct nfsv2_fattrs {
	u_int32_t	fa_type;
	u_int32_t	fa_mode;
	u_int32_t	fa_nlink;
	u_int32_t	fa_uid;
	u_int32_t	fa_gid;
	u_int32_t	fa_size;
	u_int32_t	fa_blocksize;
	u_int32_t	fa_rdev;
	u_int32_t	fa_blocks;
	u_int32_t	fa_fsid;
	u_int32_t	fa_fileid;
	struct nfsv2_time fa_atime;
	struct nfsv2_time fa_mtime;
	struct nfsv2_time fa_ctime;
};


struct nfs_read_args {
	u_char	fh[NFS_FHSIZE];
	u_int32_t	off;
	u_int32_t	len;
	u_int32_t	xxx;			/* XXX what's this for? */
};

/* Data part of nfs rpc reply (also the largest thing we receive) */
#define NFSREAD_SIZE 1024
struct nfs_read_repl {
	u_int32_t	errno;
	struct	nfsv2_fattrs fa;
	u_int32_t	count;
	u_char	data[NFSREAD_SIZE];
};

struct nfs_readlnk_repl {
	u_int32_t	errno;
	u_int32_t	len;
	char	path[NFS_MAXPATHLEN];
};

struct nfs_iodesc {
	struct	iodesc	*iodesc;
	off_t	off;
	u_char	fh[NFS_FHSIZE];
	struct nfsv2_fattrs fa;	/* all in network order */
};

struct nfs_iodesc nfs_root_node;


/*
 * Fetch the root file handle (call mount daemon)
 * On error, return non-zero and set errno.
 */
static int
nfs_getrootfh(struct iodesc *d, const char *path, u_char *fhp)
{
	int len;
	struct args {
		u_int32_t	len;
		char	path[FNAME_SIZE];
	} *args;
	struct repl {
		u_int32_t	errno;
		u_char	fh[NFS_FHSIZE];
	} *repl;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct args d;
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct repl d;
	} rdata;
	ssize_t cc;

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_getrootfh: %s\n", path);
#endif

	args = &sdata.d;
	repl = &rdata.d;

	bzero(args, sizeof(*args));
	len = strlen(path);
	if (len > sizeof(args->path))
		len = sizeof(args->path);
	args->len = htonl(len);
	bcopy(path, args->path, len);
	len = 4 + roundup(len, 4);

	cc = rpc_call(d, RPCPROG_MNT, RPCMNT_VER1, RPCMNT_MOUNT,
	    args, len, repl, sizeof(*repl));
	if (cc == -1) {
		/* errno was set by rpc_call */
		return (-1);
	}
	if (cc < 4) {
		errno = EBADRPC;
		return (-1);
	}
	if (repl->errno) {
		errno = ntohl(repl->errno);
		return (-1);
	}
	bcopy(repl->fh, fhp, sizeof(repl->fh));
	return (0);
}

/*
 * Lookup a file.  Store handle and attributes.
 * Return zero or error number.
 */
static int
nfs_lookupfh(struct nfs_iodesc *d, char *name, struct nfs_iodesc *newfd)
{
	int len, rlen;
	struct args {
		u_char	fh[NFS_FHSIZE];
		u_int32_t	len;
		char	name[FNAME_SIZE];
	} *args;
	struct repl {
		u_int32_t	errno;
		u_char	fh[NFS_FHSIZE];
		struct	nfsv2_fattrs fa;
	} *repl;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct args d;
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct repl d;
	} rdata;
	ssize_t cc;

#ifdef NFS_DEBUG
	if (debug)
		printf("lookupfh: called\n");
#endif

	args = &sdata.d;
	repl = &rdata.d;

	bzero(args, sizeof(*args));
	bcopy(d->fh, args->fh, sizeof(args->fh));
	len = strlen(name);
	if (len > sizeof(args->name))
		len = sizeof(args->name);
	bcopy(name, args->name, len);
	args->len = htonl(len);
	len = 4 + roundup(len, 4);
	len += NFS_FHSIZE;

	rlen = sizeof(*repl);

	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_LOOKUP,
	    args, len, repl, rlen);
	if (cc == -1)
		return (errno);		/* XXX - from rpc_call */
	if (cc < 4)
		return (EIO);
	if (repl->errno) {
		/* saerrno.h now matches NFS error numbers. */
		return (ntohl(repl->errno));
	}
	bcopy( repl->fh, &newfd->fh, sizeof(newfd->fh));
	bcopy(&repl->fa, &newfd->fa, sizeof(newfd->fa));
	return (0);
}

/*
 * Get the destination of a symbolic link.
 */
static int
nfs_readlink(struct nfs_iodesc *d, char *buf)
{
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		u_char fh[NFS_FHSIZE];
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct nfs_readlnk_repl d;
	} rdata;
	ssize_t cc;

#ifdef NFS_DEBUG
	if (debug)
		printf("readlink: called\n");
#endif

	bcopy(d->fh, sdata.fh, NFS_FHSIZE);
	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_READLINK,
	    sdata.fh, NFS_FHSIZE,
	    &rdata.d, sizeof(rdata.d));
	if (cc == -1)
		return (errno);

	if (cc < 4)
		return (EIO);

	if (rdata.d.errno)
		return (ntohl(rdata.d.errno));

	rdata.d.len = ntohl(rdata.d.len);
	if (rdata.d.len > NFS_MAXPATHLEN)
		return (ENAMETOOLONG);

	bcopy(rdata.d.path, buf, rdata.d.len);
	buf[rdata.d.len] = 0;
	return (0);
}

/*
 * Read data from a file.
 * Return transfer count or -1 (and set errno)
 */
static ssize_t
nfs_readdata(struct nfs_iodesc *d, off_t off, void *addr, size_t len)
{
	struct nfs_read_args *args;
	struct nfs_read_repl *repl;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct nfs_read_args d;
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct nfs_read_repl d;
	} rdata;
	ssize_t cc;
	long x;
	int hlen, rlen;

	args = &sdata.d;
	repl = &rdata.d;

	bcopy(d->fh, args->fh, NFS_FHSIZE);
	args->off = htonl((u_int32_t)off);
	if (len > NFSREAD_SIZE)
		len = NFSREAD_SIZE;
	args->len = htonl((u_int32_t)len);
	args->xxx = htonl((u_int32_t)0);
	hlen = sizeof(*repl) - NFSREAD_SIZE;

	cc = rpc_call(d->iodesc, NFS_PROG, NFS_VER2, NFSPROC_READ,
	    args, sizeof(*args),
	    repl, sizeof(*repl));
	if (cc == -1) {
		/* errno was already set by rpc_call */
		return (-1);
	}
	if (cc < hlen) {
		errno = EBADRPC;
		return (-1);
	}
	if (repl->errno) {
		errno = ntohl(repl->errno);
		return (-1);
	}
	rlen = cc - hlen;
	x = ntohl(repl->count);
	if (rlen < x) {
		printf("nfsread: short packet, %d < %ld\n", rlen, x);
		errno = EBADRPC;
		return(-1);
	}
	bcopy(repl->data, addr, x);
	return (x);
}

/*
 * nfs_mount - mount this nfs filesystem to a host
 * On error, return non-zero and set errno.
 */
int
nfs_mount(int sock, struct in_addr ip, const char *path)
{
	struct iodesc *desc;
	struct nfsv2_fattrs *fa;

	if (!(desc = socktodesc(sock))) {
		errno = EINVAL;
		return(-1);
	}

	/* Bind to a reserved port. */
	desc->myport = htons(--rpc_port);
	desc->destip = ip;
	if (nfs_getrootfh(desc, path, nfs_root_node.fh))
		return (-1);
	nfs_root_node.iodesc = desc;
	/* Fake up attributes for the root dir. */
	fa = &nfs_root_node.fa;
	fa->fa_type  = htonl(NFDIR);
	fa->fa_mode  = htonl(0755);
	fa->fa_nlink = htonl(2);

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_mount: got fh for %s\n", path);
#endif

	return(0);
}

/*
 * Open a file.
 * return zero or error number
 */
int
nfs_open(char *path, struct open_file *f)
{
	struct nfs_iodesc *newfd, *currfd;
	char namebuf[NFS_MAXPATHLEN + 1], *cp, *ncp;
	char linkbuf[NFS_MAXPATHLEN + 1];
	int nlinks = 0, error = 0, c;

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_open: %s\n", path);
#endif
	if (nfs_root_node.iodesc == NULL) {
		printf("nfs_open: must mount first.\n");
		return (ENXIO);
	}

	currfd = &nfs_root_node;
	newfd = 0;

	cp = path;
	while (*cp) {
		/*
		 * Remove extra separators
		 */
		while (*cp == '/')
			cp++;

		if (*cp == '\0')
			break;
		/*
		 * Check that current node is a directory.
		 */
		if (currfd->fa.fa_type != htonl(NFDIR)) {
			error = ENOTDIR;
			goto out;
		}

		/* allocate file system specific data structure */
		newfd = alloc(sizeof(*newfd));
		newfd->iodesc = currfd->iodesc;
		newfd->off = 0;

		/*
		 * Get next component of path name.
		 */
		{
			int len = 0;

			ncp = cp;
			while ((c = *cp) != '\0' && c != '/') {
				if (++len > NFS_MAXNAMLEN) {
					error = ENOENT;
					goto out;
				}
				cp++;
			}
			*cp = '\0';
		}

		/* lookup a file handle */
		error = nfs_lookupfh(currfd, ncp, newfd);
		*cp = c;
		if (error)
			goto out;

		/*
		 * Check for symbolic link
		 */
		if (newfd->fa.fa_type == htonl(NFLNK)) {
			int link_len, len;

			error = nfs_readlink(newfd, linkbuf);
			if (error)
				goto out;

			link_len = strlen(linkbuf);
			len = strlen(cp);

			if (link_len + len > MAXPATHLEN ||
			    ++nlinks > MAXSYMLINKS) {
				error = ENOENT;
				goto out;
			}

			bcopy(cp, &namebuf[link_len], len + 1);
			bcopy(linkbuf, namebuf, link_len);

			/*
			 * If absolute pathname, restart at root.
			 * If relative pathname, restart at parent directory.
			 */
			cp = namebuf;
			if (*cp == '/') {
				if (currfd != &nfs_root_node)
					free(currfd, sizeof(*currfd));
				currfd = &nfs_root_node;
			}

			free(newfd, sizeof(*newfd));
			newfd = 0;

			continue;
		}

		if (currfd != &nfs_root_node)
			free(currfd, sizeof(*currfd));
		currfd = newfd;
		newfd = 0;
	}

	error = 0;

out:
	if (!error) {
		f->f_fsdata = (void *)currfd;
		return (0);
	}

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_open: %s lookupfh failed: %s\n",
		    path, strerror(error));
#endif
	if (currfd != &nfs_root_node)
		free(currfd, sizeof(*currfd));
	if (newfd)
		free(newfd, sizeof(*newfd));

	return (error);
}

int
nfs_close(struct open_file *f)
{
	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_close: fp=%p\n", fp);
#endif

	if (fp)
		free(fp, sizeof(struct nfs_iodesc));
	f->f_fsdata = NULL;

	return (0);
}

/*
 * read a portion of a file
 */
int
nfs_read(struct open_file *f, void *buf, size_t size, size_t *resid)
{
	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
	ssize_t cc;
	char *addr = buf;

#ifdef NFS_DEBUG
	if (debug)
		printf("nfs_read: size=%d off=%d\n", size, (int)fp->off);
#endif
	while ((int)size > 0) {
		twiddle();
		cc = nfs_readdata(fp, fp->off, (void *)addr, size);
		/* XXX maybe should retry on certain errors */
		if (cc == -1) {
#ifdef NFS_DEBUG
			if (debug)
				printf("nfs_read: read: %s", strerror(errno));
#endif
			return (errno);	/* XXX - from nfs_readdata */
		}
		if (cc == 0) {
#ifdef NFS_DEBUG
			if (debug)
				printf("nfs_read: hit EOF unexpectantly");
#endif
			goto ret;
		}
		fp->off += cc;
		addr += cc;
		size -= cc;
	}
ret:
	if (resid)
		*resid = size;

	return (0);
}

/*
 * Not implemented.
 */
int
nfs_write(struct open_file *f, void *buf, size_t size, size_t *resid)
{
	return (EROFS);
}

off_t
nfs_seek(struct open_file *f, off_t offset, int where)
{
	struct nfs_iodesc *d = (struct nfs_iodesc *)f->f_fsdata;
	u_int32_t size = ntohl(d->fa.fa_size);

	switch (where) {
	case SEEK_SET:
		d->off = offset;
		break;
	case SEEK_CUR:
		d->off += offset;
		break;
	case SEEK_END:
		d->off = size - offset;
		break;
	default:
		return (-1);
	}

	return (d->off);
}

/* NFNON=0, NFREG=1, NFDIR=2, NFBLK=3, NFCHR=4, NFLNK=5 */
const int nfs_stat_types[8] = {
	0, S_IFREG, S_IFDIR, S_IFBLK, S_IFCHR, S_IFLNK, 0
};

int
nfs_stat(struct open_file *f, struct stat *sb)
{
	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
	u_int32_t ftype, mode;

	ftype = ntohl(fp->fa.fa_type);
	mode  = ntohl(fp->fa.fa_mode);
	mode |= nfs_stat_types[ftype & 7];

	sb->st_mode  = mode;
	sb->st_nlink = ntohl(fp->fa.fa_nlink);
	sb->st_uid   = ntohl(fp->fa.fa_uid);
	sb->st_gid   = ntohl(fp->fa.fa_gid);
	sb->st_size  = ntohl(fp->fa.fa_size);

	return (0);
}

/*
 * Not implemented.
 */
#ifndef NO_READDIR
int
nfs_readdir(struct open_file *f, char *name)
{
	return (EROFS);
}
#endif
@


1.14
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.13 2015/08/15 19:40:59 miod Exp $	*/
d538 1
d541 1
@


1.13
log
@Use signed variables to store the result of rpc_call().
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.12 2014/11/19 20:28:56 miod Exp $	*/
d507 1
a507 1
	f->f_fsdata = (void *)0;
@


1.12
log
@Sprinkle const whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.11 2014/07/13 15:31:20 mpi Exp $	*/
d124 1
a124 1
	size_t cc;
d283 1
a283 1
	size_t cc;
@


1.11
log
@Stop using old n_long and n_short types.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.10 2003/08/11 06:23:09 deraadt Exp $	*/
d105 1
a105 1
nfs_getrootfh(struct iodesc *d, char *path, u_char *fhp)
d329 1
a329 1
nfs_mount(int sock, struct in_addr ip, char *path)
d586 3
a588 2
int nfs_stat_types[8] = {
	0, S_IFREG, S_IFDIR, S_IFBLK, S_IFCHR, S_IFLNK, 0 };
@


1.10
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.9 2003/06/01 17:00:33 deraadt Exp $	*/
a37 1
#include <netinet/in_systm.h>
d51 11
a61 11
	n_long	fa_type;
	n_long	fa_mode;
	n_long	fa_nlink;
	n_long	fa_uid;
	n_long	fa_gid;
	n_long	fa_size;
	n_long	fa_blocksize;
	n_long	fa_rdev;
	n_long	fa_blocks;
	n_long	fa_fsid;
	n_long	fa_fileid;
d70 3
a72 3
	n_long	off;
	n_long	len;
	n_long	xxx;			/* XXX what's this for? */
d78 1
a78 1
	n_long	errno;
d80 1
a80 1
	n_long	count;
d85 2
a86 2
	n_long	errno;
	n_long	len;
d109 1
a109 1
		n_long	len;
d113 1
a113 1
		n_long	errno;
d117 1
a117 1
		n_long	h[RPC_HEADER_WORDS];
d121 1
a121 1
		n_long	h[RPC_HEADER_WORDS];
d170 1
a170 1
		n_long	len;
d174 1
a174 1
		n_long	errno;
d179 1
a179 1
		n_long	h[RPC_HEADER_WORDS];
d183 1
a183 1
		n_long	h[RPC_HEADER_WORDS];
d230 1
a230 1
		n_long	h[RPC_HEADER_WORDS];
d234 1
a234 1
		n_long	h[RPC_HEADER_WORDS];
d276 1
a276 1
		n_long	h[RPC_HEADER_WORDS];
d280 1
a280 1
		n_long	h[RPC_HEADER_WORDS];
d291 1
a291 1
	args->off = htonl((n_long)off);
d294 2
a295 2
	args->len = htonl((n_long)len);
	args->xxx = htonl((n_long)0);
d566 1
a566 1
	n_long size = ntohl(d->fa.fa_size);
d593 1
a593 1
	n_long ftype, mode;
@


1.9
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.8 1997/03/25 20:30:43 niklas Exp $	*/
d105 2
a106 5
int
nfs_getrootfh(d, path, fhp)
	register struct iodesc *d;
	char *path;
	u_char *fhp;
d108 1
a108 1
	register int len;
d165 2
a166 5
int
nfs_lookupfh(d, name, newfd)
	struct nfs_iodesc *d;
	char *name;
	struct nfs_iodesc *newfd;
d168 1
a168 1
	register int len, rlen;
d227 2
a228 4
int
nfs_readlink(d, buf)
	struct nfs_iodesc *d;
	char *buf;
d247 2
a248 2
		      sdata.fh, NFS_FHSIZE,
		      &rdata.d, sizeof(rdata.d));
d271 2
a272 6
ssize_t
nfs_readdata(d, off, addr, len)
	struct nfs_iodesc *d;
	off_t off;
	void *addr;
	size_t len;
d330 1
a330 4
nfs_mount(sock, ip, path)
	int sock;
	struct in_addr ip;
	char *path;
d365 1
a365 3
nfs_open(path, f)
	char *path;
	struct open_file *f;
d368 1
a368 3
	register char *cp, *ncp;
	register int c;
	char namebuf[NFS_MAXPATHLEN + 1];
d370 1
a370 2
	int nlinks = 0;
	int error = 0;
d411 1
a411 1
			register int len = 0;
d443 2
a444 2
			if (link_len + len > MAXPATHLEN
			    || ++nlinks > MAXSYMLINKS) {
d497 1
a497 2
nfs_close(f)
	struct open_file *f;
d499 1
a499 1
	register struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
d517 5
a521 9
nfs_read(f, buf, size, resid)
	struct open_file *f;
	void *buf;
	size_t size;
	size_t *resid;	/* out */
{
	register struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
	register ssize_t cc;
	register char *addr = buf;
d558 1
a558 5
nfs_write(f, buf, size, resid)
	struct open_file *f;
	void *buf;
	size_t size;
	size_t *resid;	/* out */
d564 1
a564 4
nfs_seek(f, offset, where)
	struct open_file *f;
	off_t offset;
	int where;
d566 1
a566 1
	register struct nfs_iodesc *d = (struct nfs_iodesc *)f->f_fsdata;
d591 1
a591 3
nfs_stat(f, sb)
	struct open_file *f;
	struct stat *sb;
d594 1
a594 1
	register n_long ftype, mode;
d614 1
a614 3
nfs_readdir(f, name)
	struct open_file *f;
	char *name;
@


1.8
log
@Get rid of userland includes
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.7 1997/02/16 14:39:39 mickey Exp $	*/
d7 1
a7 1
 * 
d18 1
a18 1
 * 
d129 1
a129 1
	
d194 1
a194 1
	
d262 1
a262 1
	
d393 2
a394 2
 	if (debug)
 	    printf("nfs_open: %s\n", path);
d403 1
a403 1
	
d421 1
a421 1
		
d426 1
a426 1
	
d432 1
a432 1
			
d443 1
a443 1
		
d449 1
a449 1
		
d455 1
a455 1
			
d471 1
a471 1
			
d485 1
a485 1
			
d488 1
a488 1
		
d502 1
a502 1
		
d530 1
a530 1
	
d547 1
a547 1
	
@


1.8.14.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.8 1997/03/25 20:30:43 niklas Exp $	*/
d7 1
a7 1
 *
d18 1
a18 1
 *
d129 1
a129 1

d194 1
a194 1

d262 1
a262 1

d393 2
a394 2
	if (debug)
		printf("nfs_open: %s\n", path);
d403 1
a403 1

d421 1
a421 1

d426 1
a426 1

d432 1
a432 1

d443 1
a443 1

d449 1
a449 1

d455 1
a455 1

d471 1
a471 1

d485 1
a485 1

d488 1
a488 1

d502 1
a502 1

d530 1
a530 1

d547 1
a547 1

@


1.8.14.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d105 5
a109 2
static int
nfs_getrootfh(struct iodesc *d, char *path, u_char *fhp)
d111 1
a111 1
	int len;
d168 5
a172 2
static int
nfs_lookupfh(struct nfs_iodesc *d, char *name, struct nfs_iodesc *newfd)
d174 1
a174 1
	int len, rlen;
d233 4
a236 2
static int
nfs_readlink(struct nfs_iodesc *d, char *buf)
d255 2
a256 2
	    sdata.fh, NFS_FHSIZE,
	    &rdata.d, sizeof(rdata.d));
d279 6
a284 2
static ssize_t
nfs_readdata(struct nfs_iodesc *d, off_t off, void *addr, size_t len)
d342 4
a345 1
nfs_mount(int sock, struct in_addr ip, char *path)
d380 3
a382 1
nfs_open(char *path, struct open_file *f)
d385 3
a387 1
	char namebuf[NFS_MAXPATHLEN + 1], *cp, *ncp;
d389 2
a390 1
	int nlinks = 0, error = 0, c;
d431 1
a431 1
			int len = 0;
d463 2
a464 2
			if (link_len + len > MAXPATHLEN ||
			    ++nlinks > MAXSYMLINKS) {
d517 2
a518 1
nfs_close(struct open_file *f)
d520 1
a520 1
	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
d538 9
a546 5
nfs_read(struct open_file *f, void *buf, size_t size, size_t *resid)
{
	struct nfs_iodesc *fp = (struct nfs_iodesc *)f->f_fsdata;
	ssize_t cc;
	char *addr = buf;
d583 5
a587 1
nfs_write(struct open_file *f, void *buf, size_t size, size_t *resid)
d593 4
a596 1
nfs_seek(struct open_file *f, off_t offset, int where)
d598 1
a598 1
	struct nfs_iodesc *d = (struct nfs_iodesc *)f->f_fsdata;
d623 3
a625 1
nfs_stat(struct open_file *f, struct stat *sb)
d628 1
a628 1
	n_long ftype, mode;
d648 3
a650 1
nfs_readdir(struct open_file *f, char *name)
@


1.7
log
@opendir, readdir, closedir (define NO_READDIR, if none required)
minor fix in cd9660
only ufs working, all the others are on the list....
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.6 1996/12/08 15:15:52 niklas Exp $	*/
a35 1
#include <string.h>
@


1.6
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.5 1996/10/15 09:58:34 mickey Exp $	*/
d45 1
d643 13
@


1.5
log
@gcc -Wall happy
@
text
@d1 2
a2 2
/*	$OpenBSD: nfs.c,v 1.4 1996/09/27 07:13:48 mickey Exp $	*/
/*	$NetBSD: nfs.c,v 1.15 1996/05/14 10:28:26 leo Exp $	*/
d41 2
a42 2
#include <nfs/rpcv2.h>
#include <nfs/nfsv2.h>
d85 6
d231 45
d384 6
a389 1
	struct nfs_iodesc *newfd;
d401 95
a495 4
	/* allocate file system specific data structure */
	newfd = alloc(sizeof(*newfd));
	newfd->iodesc = nfs_root_node.iodesc;
	newfd->off = 0;
d497 1
a497 2
	/* lookup a file handle */
	error = nfs_lookupfh(&nfs_root_node, path, newfd);
d499 1
a499 1
		f->f_fsdata = (void *)newfd;
d502 1
a502 1

d506 1
a506 1
			path, strerror(error));
d508 5
a512 1
	free(newfd, sizeof(*newfd));
@


1.4
log
@use nfs/{nfsv2.h,rpcv2.h} instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: nfs.c,v 1.3 1996/05/22 12:00:44 deraadt Exp $	*/
d374 1
a374 1
		printf("nfs_close: fp=0x%x\n", fp);
@


1.3
log
@obviously killing gcc warnings is more important than keeping this library small
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 2
a42 2
#include "rpcv2.h"
#include "nfsv2.h"
@


1.2
log
@NetBSD 960317 merge
@
text
@d2 1
a2 1
/*	$NetBSD: nfs.c,v 1.14 1996/02/26 23:05:21 gwr Exp $	*/
d278 1
a278 1
		printf("nfsread: short packet, %d < %d\n", rlen, x);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: nfs.c,v 1.12 1995/09/23 03:36:08 gwr Exp $	*/
d41 2
a42 3
#include <nfs/rpcv2.h>
#include <nfs/nfsv2.h>
#include <nfs/xdr_subs.h>
d253 1
a253 1
	args->off = txdr_unsigned(off);
d256 2
a257 2
	args->len = txdr_unsigned(len);
	args->xxx = txdr_unsigned(0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
