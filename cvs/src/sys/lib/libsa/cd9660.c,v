head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.10
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.12
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.8
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.28
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.26
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.22
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.24
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.20
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.18
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.16
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.14
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.12
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.7.0.24
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.22
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.20
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.7.0.18
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.16
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.14
	OPENBSD_2_8:1.7.0.12
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.10
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.8
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.6
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.4
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2014.11.19.19.58.40;	author miod;	state Exp;
branches;
next	1.14;
commitid	W4VPuoNteFYwsPth;

1.14
date	2013.11.12.19.55.12;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.09.19.20.17;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.22.23.17.10;	author tom;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.01.17.00.32;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.15.18.41.19;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	98.05.30.02.29.56;	author mickey;	state Exp;
branches
	1.7.8.1
	1.7.18.1;
next	1.6;

1.6
date	97.11.09.19.37.20;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.20.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.14.59;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.02.16.14.39.38;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.12.12.08.19.25;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.12.08.15.15.47;	author niklas;	state Exp;
branches;
next	;

1.7.8.1
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.7.8.2;

1.7.8.2
date	2003.06.07.11.03.42;	author ho;	state Exp;
branches;
next	1.7.8.3;

1.7.8.3
date	2004.02.19.10.57.18;	author niklas;	state Exp;
branches;
next	;

1.7.18.1
date	2003.05.19.21.53.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Sprinkle const in static (internal) routines.
@
text
@/*	$OpenBSD: cd9660.c,v 1.14 2013/11/12 19:55:12 deraadt Exp $	*/
/*	$NetBSD: cd9660.c,v 1.1 1996/09/30 16:01:19 ws Exp $	*/

/*
 * Copyright (C) 1996 Wolfgang Solfrank.
 * Copyright (C) 1996 TooLs GmbH.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by TooLs GmbH.
 * 4. The name of TooLs GmbH may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Stand-alone ISO9660 file reading package.
 *
 * Note: This doesn't support Rock Ridge extensions, extended attributes,
 * blocksizes other than 2048 bytes, multi-extent files, etc.
 */
#include <sys/param.h>
#include <sys/stat.h>

#include <lib/libkern/libkern.h>

#include <isofs/cd9660/iso.h>

#include "stand.h"
#include "cd9660.h"

struct file {
	off_t off;			/* Current offset within file */
	daddr32_t bno;			/* Starting block number  */
	off_t size;			/* Size of file */
};

struct ptable_ent {
	char namlen	[ISODCL( 1, 1)];	/* 711 */
	char extlen	[ISODCL( 2, 2)];	/* 711 */
	char block	[ISODCL( 3, 6)];	/* 732 */
	char parent	[ISODCL( 7, 8)];	/* 722 */
	char name	[1];
};
#define	PTFIXSZ		8
#define	PTSIZE(pp)	roundup(PTFIXSZ + isonum_711((pp)->namlen), 2)

#define	cdb2devb(bno)	((bno) * ISO_DEFAULT_BLOCK_SIZE / DEV_BSIZE)

static int
pnmatch(const char *path, struct ptable_ent *pp)
{
	const char *cp;
	int i;

	cp = pp->name;
	for (i = isonum_711(pp->namlen); --i >= 0; path++, cp++) {
		if (toupper(*path) == *cp)
			continue;
		return 0;
	}
	if (*path != '/')
		return 0;
	return 1;
}

static int
dirmatch(const char *path, struct iso_directory_record *dp)
{
	const char *cp;
	int i;

	/* This needs to be a regular file */
	if (dp->flags[0] & 6)
		return 0;

	cp = dp->name;
	for (i = isonum_711(dp->name_len); --i >= 0; path++, cp++) {
		if (!*path)
			break;
		if (toupper(*path) == *cp)
			continue;
		return 0;
	}
	if (*path)
		return 0;
	/*
	 * Allow stripping of trailing dots and the version number.
	 * Note that this will find the first instead of the last version
	 * of a file.
	 */
	if (i >= 0 && (*cp == ';' || *cp == '.')) {
		/* This is to prevent matching of numeric extensions */
		if (*cp == '.' && cp[1] != ';')
			return 0;
		while (--i >= 0)
			if (*++cp != ';' && (*cp < '0' || *cp > '9'))
				return 0;
	}
	return 1;
}

int
cd9660_open(char *path, struct open_file *f)
{
	struct file *fp = 0;
	char *buf;
	struct iso_primary_descriptor *vd;
	size_t buf_size, nread, psize, dsize;
	daddr32_t bno;
	int parent, ent;
	struct ptable_ent *pp;
	struct iso_directory_record *dp;
	int rc;

	/* First find the volume descriptor */
	buf = alloc(buf_size = ISO_DEFAULT_BLOCK_SIZE);
	dp = (struct iso_directory_record *)buf;
	vd = (struct iso_primary_descriptor *)buf;
	for (bno = 16;; bno++) {
		twiddle();
		rc = f->f_dev->dv_strategy(f->f_devdata, F_READ, cdb2devb(bno),
					   ISO_DEFAULT_BLOCK_SIZE, buf, &nread);
		if (rc)
			goto out;
		if (nread != ISO_DEFAULT_BLOCK_SIZE) {
			rc = EIO;
			goto out;
		}
		rc = EINVAL;
		if (bcmp(vd->id, ISO_STANDARD_ID, sizeof vd->id) != 0)
			goto out;
		if (isonum_711(vd->type) == ISO_VD_END)
			goto out;
		if (isonum_711(vd->type) == ISO_VD_PRIMARY)
			break;
	}
	if (isonum_723(vd->logical_block_size) != ISO_DEFAULT_BLOCK_SIZE)
		goto out;

	/* Now get the path table and lookup the directory of the file */
	bno = isonum_732(vd->type_m_path_table);
	psize = isonum_733(vd->path_table_size);

	if (psize > ISO_DEFAULT_BLOCK_SIZE) {
		free(buf, ISO_DEFAULT_BLOCK_SIZE);
		buf = alloc(buf_size = roundup(psize, ISO_DEFAULT_BLOCK_SIZE));
	}

	twiddle();
	rc = f->f_dev->dv_strategy(f->f_devdata, F_READ, cdb2devb(bno),
				   buf_size, buf, &nread);
	if (rc)
		goto out;
	if (nread != buf_size) {
		rc = EIO;
		goto out;
	}

	parent = 1;
	pp = (struct ptable_ent *)buf;
	ent = 1;
	bno = isonum_732(pp->block) + isonum_711(pp->extlen);

	rc = ENOENT;
	/*
	 * Remove extra separators
	 */
	while (*path == '/')
		path++;

	while (*path) {
		if ((char *)pp >= buf + psize)
			break;
		if (isonum_722(pp->parent) != parent)
			break;
		if (!pnmatch(path, pp)) {
			pp = (struct ptable_ent *)((char *)pp + PTSIZE(pp));
			ent++;
			continue;
		}
		path += isonum_711(pp->namlen) + 1;
		parent = ent;
		bno = isonum_732(pp->block) + isonum_711(pp->extlen);
		while ((char *)pp < buf + psize) {
			if (isonum_722(pp->parent) == parent)
				break;
			pp = (struct ptable_ent *)((char *)pp + PTSIZE(pp));
			ent++;
		}
	}

	/* Now bno has the start of the directory that supposedly contains the file */
	bno--;
	dsize = 1;		/* Something stupid, but > 0	XXX */
	for (psize = 0; psize < dsize;) {
		if (!(psize % ISO_DEFAULT_BLOCK_SIZE)) {
			bno++;
			twiddle();
			rc = f->f_dev->dv_strategy(f->f_devdata, F_READ,
						   cdb2devb(bno),
						   ISO_DEFAULT_BLOCK_SIZE,
						   buf, &nread);
			if (rc)
				goto out;
			if (nread != ISO_DEFAULT_BLOCK_SIZE) {
				rc = EIO;
				goto out;
			}
			dp = (struct iso_directory_record *)buf;
		}
		if (!isonum_711(dp->length)) {
			if ((void *)dp == buf)
				psize += ISO_DEFAULT_BLOCK_SIZE;
			else
				psize = roundup(psize, ISO_DEFAULT_BLOCK_SIZE);
			continue;
		}
		if (dsize == 1)
			dsize = isonum_733(dp->size);
		if (dirmatch(path, dp))
			break;
		psize += isonum_711(dp->length);
		dp = (struct iso_directory_record *)((char *)dp +
		    isonum_711(dp->length));
	}

	if (psize >= dsize) {
		rc = ENOENT;
		goto out;
	}

	/* allocate file system specific data structure */
	fp = alloc(sizeof(struct file));
	bzero(fp, sizeof(struct file));
	f->f_fsdata = (void *)fp;

	fp->off = 0;
	fp->bno = isonum_733(dp->extent);
	fp->size = isonum_733(dp->size);
	free(buf, buf_size);

	return 0;

out:
	if (fp)
		free(fp, sizeof(struct file));
	free(buf, buf_size);

	return rc;
}

int
cd9660_close(struct open_file *f)
{
	struct file *fp = (struct file *)f->f_fsdata;

	f->f_fsdata = 0;
	free(fp, sizeof *fp);

	return 0;
}

int
cd9660_read(struct open_file *f, void *start, size_t size, size_t *resid)
{
	struct file *fp = (struct file *)f->f_fsdata;
	int rc = 0;
	daddr32_t bno;
	char buf[ISO_DEFAULT_BLOCK_SIZE];
	char *dp, *st = start;
	size_t nread, off;

	while (size) {
		if (fp->off < 0 || fp->off >= fp->size)
			break;
		bno = (fp->off >> ISO_DEFAULT_BLOCK_SHIFT) + fp->bno;
		if (fp->off & (ISO_DEFAULT_BLOCK_SIZE - 1)
		    || size < ISO_DEFAULT_BLOCK_SIZE)
			dp = buf;
		else
			dp = st;
		twiddle();
		rc = f->f_dev->dv_strategy(f->f_devdata, F_READ, cdb2devb(bno),
					   ISO_DEFAULT_BLOCK_SIZE, dp, &nread);
		if (rc)
			return rc;
		if (nread != ISO_DEFAULT_BLOCK_SIZE)
			return EIO;

		/*
		 * off is either 0 in the dp == st case or
		 * the offset to the interesting data into the buffer of 'buf'
		 */
		off = fp->off & (ISO_DEFAULT_BLOCK_SIZE - 1);
		nread -= off;
		if (nread > size)
			nread = size;

		if (nread > (fp->size - fp->off))
			nread = (fp->size - fp->off);

		if (dp == buf)
			bcopy(buf + off, st, nread);

		st += nread;
		fp->off += nread;
		size -= nread;
	}
	if (resid)
		*resid = size;
	return rc;
}

int
cd9660_write(struct open_file *f, void *start, size_t size, size_t *resid)
{
	return EROFS;
}

off_t
cd9660_seek(struct open_file *f, off_t offset, int where)
{
	struct file *fp = (struct file *)f->f_fsdata;

	switch (where) {
	case SEEK_SET:
		fp->off = offset;
		break;
	case SEEK_CUR:
		fp->off += offset;
		break;
	case SEEK_END:
		fp->off = fp->size - offset;
		break;
	default:
		return -1;
	}
	return fp->off;
}

int
cd9660_stat(struct open_file *f, struct stat *sb)
{
	struct file *fp = (struct file *)f->f_fsdata;

	/* only important stuff */
	sb->st_mode = S_IFREG | S_IRUSR | S_IRGRP | S_IROTH;
	sb->st_uid = sb->st_gid = 0;
	sb->st_size = fp->size;
	return 0;
}

/*
 * Not implemented.
 */
#ifndef NO_READDIR
int
cd9660_readdir(struct open_file *f, char *name)
{
	return (EROFS);
}
#endif
@


1.14
log
@avoid math on void * pointers
(a few years ago, people went far too void * happy, it was like a drug
or something)
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.13 2011/03/13 00:13:53 deraadt Exp $	*/
a45 8
/* THIS IS AN UGLY HACK!!!			XXX */
struct fid;
struct mbuf;
struct nameidata;
struct netexport { int x; };
struct proc;
struct statfs;
struct ucred;
d70 1
a70 1
pnmatch(char *path, struct ptable_ent *pp)
d72 1
a72 1
	char *cp;
d87 1
a87 1
dirmatch(char *path, struct iso_directory_record *dp)
d89 1
a89 1
	char *cp;
@


1.13
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.12 2004/07/09 19:20:17 drahn Exp $	*/
d134 1
a134 1
	void *buf;
d146 1
a146 1
	vd = buf;
d200 1
a200 1
		if ((void *)pp >= buf + psize)
d205 1
a205 1
			pp = (struct ptable_ent *)((void *)pp + PTSIZE(pp));
d212 1
a212 1
		while ((void *)pp < buf + psize) {
d215 1
a215 1
			pp = (struct ptable_ent *)((void *)pp + PTSIZE(pp));
d251 1
a251 1
		dp = (struct iso_directory_record *)((void *)dp +
d298 1
a298 1
	char *dp;
d309 1
a309 1
			dp = start;
d319 1
a319 1
		 * off is either 0 in the dp == start case or
d331 1
a331 1
			bcopy(buf + off, start, nread);
d333 1
a333 1
		start += nread;
@


1.12
log
@Fix buffer writing in cd9660 code, written by Tom and myself, examined by toby
and tested in-tree for a while.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.11 2004/06/22 23:17:10 tom Exp $	*/
d61 1
a61 1
	daddr_t bno;			/* Starting block number  */
d137 1
a137 1
	daddr_t bno;
d296 1
a296 1
	daddr_t bno;
@


1.11
log
@Change of variable name from read to nread, to reduce difference
from NetBSD version.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.10 2003/08/11 06:23:09 deraadt Exp $	*/
d317 14
a330 5
		if (dp == buf) {
			off = fp->off & (ISO_DEFAULT_BLOCK_SIZE - 1);
			if (nread > off + size)
				nread = off + size;
			nread -= off;
d332 4
a335 8
			start += nread;
			fp->off += nread;
			size -= nread;
		} else {
			start += ISO_DEFAULT_BLOCK_SIZE;
			fp->off += ISO_DEFAULT_BLOCK_SIZE;
			size -= ISO_DEFAULT_BLOCK_SIZE;
		}
@


1.10
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.9 2003/06/01 17:00:32 deraadt Exp $	*/
d136 1
a136 1
	size_t buf_size, read, psize, dsize;
d150 1
a150 1
					   ISO_DEFAULT_BLOCK_SIZE, buf, &read);
d153 1
a153 1
		if (read != ISO_DEFAULT_BLOCK_SIZE) {
d179 1
a179 1
				   buf_size, buf, &read);
d182 1
a182 1
	if (read != buf_size) {
d230 1
a230 1
						   buf, &read);
d233 1
a233 1
			if (read != ISO_DEFAULT_BLOCK_SIZE) {
d299 1
a299 1
	size_t read, off;
d312 1
a312 1
					   ISO_DEFAULT_BLOCK_SIZE, dp, &read);
d315 1
a315 1
		if (read != ISO_DEFAULT_BLOCK_SIZE)
d319 7
a325 7
			if (read > off + size)
				read = off + size;
			read -= off;
			bcopy(buf + off, start, read);
			start += read;
			fp->off += read;
			size -= read;
@


1.9
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.8 2003/04/15 18:41:19 mickey Exp $	*/
d78 1
a78 3
pnmatch(path, pp)
	char *path;
	struct ptable_ent *pp;
d95 1
a95 3
dirmatch(path, dp)
	char *path;
	struct iso_directory_record *dp;
d131 1
a131 3
cd9660_open(path, f)
	char *path;
	struct open_file *f;
d251 2
a252 1
		dp = (struct iso_directory_record *)((void *)dp + isonum_711(dp->length));
d281 1
a281 2
cd9660_close(f)
	struct open_file *f;
d292 1
a292 5
cd9660_read(f, start, size, resid)
	struct open_file *f;
	void *start;
	size_t size;
	size_t *resid;
d338 1
a338 5
cd9660_write(f, start, size, resid)
	struct open_file *f;
	void *start;
	size_t size;
	size_t *resid;
d344 1
a344 4
cd9660_seek(f, offset, where)
	struct open_file *f;
	off_t offset;
	int where;
d365 1
a365 3
cd9660_stat(f, sb)
	struct open_file *f;
	struct stat *sb;
d369 1
a369 1
	/* only importatn stuff */
d381 1
a381 3
cd9660_readdir(f, name)
	struct open_file *f;
	char *name;
a385 1

@


1.8
log
@do the same ufs does: collapse extra slashes. this allows loading files from the root of cd9660 in particular; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.8 2003/04/15 18:38:01 mickey Exp $	*/
d84 1
a84 1
	
d148 1
a148 1
	
d173 1
a173 1
	
d177 1
a177 1
	
d192 1
a192 1
	
d197 1
a197 1
	
d264 1
a264 1
	
d274 1
a274 1
	
d276 1
a276 1
	
d281 1
a281 1
	
d290 1
a290 1
	
d293 1
a293 1
	
d310 1
a310 1
	
d320 1
a320 1
		twiddle();	
d364 1
a364 1
	
d387 1
a387 1
	
@


1.7
log
@use shift, save on long div (which is expensive on certain archs)
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.6 1997/11/09 19:37:20 millert Exp $	*/
d199 6
@


1.7.18.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a198 6
	/*
	 * Remove extra separators
	 */
	while (*path == '/')
		path++;

@


1.7.8.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.7 1998/05/30 02:29:56 mickey Exp $	*/
a198 6
	/*
	 * Remove extra separators
	 */
	while (*path == '/')
		path++;

@


1.7.8.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.7.8.1 2003/05/13 19:21:29 ho Exp $	*/
d84 1
a84 1

d148 1
a148 1

d173 1
a173 1

d177 1
a177 1

d192 1
a192 1

d197 1
a197 1

d264 1
a264 1

d274 1
a274 1

d276 1
a276 1

d281 1
a281 1

d290 1
a290 1

d293 1
a293 1

d310 1
a310 1

d320 1
a320 1
		twiddle();
d364 1
a364 1

d387 1
a387 1

@


1.7.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 3
a80 1
pnmatch(char *path, struct ptable_ent *pp)
d97 3
a99 1
dirmatch(char *path, struct iso_directory_record *dp)
d135 3
a137 1
cd9660_open(char *path, struct open_file *f)
d257 1
a257 2
		dp = (struct iso_directory_record *)((void *)dp +
		    isonum_711(dp->length));
d286 2
a287 1
cd9660_close(struct open_file *f)
d298 5
a302 1
cd9660_read(struct open_file *f, void *start, size_t size, size_t *resid)
d348 5
a352 1
cd9660_write(struct open_file *f, void *start, size_t size, size_t *resid)
d358 4
a361 1
cd9660_seek(struct open_file *f, off_t offset, int where)
d382 3
a384 1
cd9660_stat(struct open_file *f, struct stat *sb)
d388 1
a388 1
	/* only important stuff */
d400 3
a402 1
cd9660_readdir(struct open_file *f, char *name)
d407 1
@


1.6
log
@isonum_722 and isonum_732 are now in isofs/cd9660/iso.h
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.5 1997/10/06 20:20:18 deraadt Exp $	*/
d308 1
a308 1
		bno = fp->off / ISO_DEFAULT_BLOCK_SIZE + fp->bno;
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.3 1997/02/16 14:39:38 mickey Exp $	*/
a54 14
/* These once were in iso.h, but got deleted??? */
extern __inline int
isonum_722(p)
	unsigned char *p;
{
	return ((char)*p << 8)|p[1];
}

extern __inline int
isonum_732(p)
	unsigned char *p;
{
	return (*p << 24)|(p[1] << 16)|(p[2] << 8)|p[3];
}
@


1.4
log
@VFS Lite2 Changes
@
text
@a53 2
struct vfsconf;

@


1.3
log
@opendir, readdir, closedir (define NO_READDIR, if none required)
minor fix in cd9660
only ufs working, all the others are on the list....
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660.c,v 1.2 1996/12/12 08:19:25 mickey Exp $	*/
d54 2
@


1.2
log
@<sys/stat.h> missed.
we've got ctype.h macros in stand.h!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d165 1
d236 1
a236 1
	dsize = 1;		/* Something stupid, but > 0			XXX */
d402 14
@


1.1
log
@Merge to NetBSD 961207
@
text
@d1 1
d42 1
a89 7

static int
toupper(c)
	int c;
{
	return c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c;
}
@
