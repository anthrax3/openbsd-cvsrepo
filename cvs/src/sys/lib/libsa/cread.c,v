head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.13.0.32
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.28
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.30
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.22
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.26
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.18
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.16
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.14
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.12
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.16
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.6
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5;
locks; strict;
comment	@ * @;


1.15
date	2016.09.18.15.14.52;	author jsing;	state Exp;
branches;
next	1.14;
commitid	rTGG4IMTzJ8soW9P;

1.14
date	2016.09.16.15.50.11;	author jasper;	state Exp;
branches;
next	1.13;
commitid	8preaPoRrRY7LO26;

1.13
date	2009.01.18.21.46.50;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.04.17.13.22.38;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.10;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	99.02.14.20.07.46;	author mickey;	state Exp;
branches
	1.8.6.1
	1.8.16.1;
next	1.7;

1.7
date	99.01.25.19.28.38;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	98.09.08.03.33.06;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	97.02.15.21.38.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.02.06.22.57.03;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	97.02.06.06.28.52;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.02.06.06.19.58;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.02.06.02.56.45;	author downsj;	state Exp;
branches;
next	;

1.8.6.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2003.05.13.19.21.29;	author ho;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2004.06.05.23.13.04;	author niklas;	state Exp;
branches;
next	;

1.8.16.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	1.8.16.2;

1.8.16.2
date	2003.05.19.21.53.42;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Correctly handle short read()s in the libsa gzip handling lseek(). Also
avoid masking the errno from a failed read().

ok guenther@@ tom@@
@
text
@/*	$OpenBSD: cread.c,v 1.14 2016/09/16 15:50:11 jasper Exp $	*/
/*	$NetBSD: cread.c,v 1.2 1997/02/04 18:38:20 thorpej Exp $	*/

/*
 * Copyright (c) 1996
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* support for compressed bootfiles
 (only read)
 replaces open(), close(), read(), lseek().
 original libsa open(), close(), read(), lseek() are called
 as oopen(), oclose(), oread() resp. olseek().
 compression parts stripped from zlib:gzio.c
 */

/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-1996 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

#include "stand.h"
#include "../libz/zlib.h"

#define EOF (-1) /* needed by compression code */

#define zmemcpy	memcpy

#define Z_BUFSIZE 4096

static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG	0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC	0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD	0x04 /* bit 2 set: extra field present */
#define ORIG_NAME	0x08 /* bit 3 set: original file name present */
#define COMMENT		0x10 /* bit 4 set: file comment present */
#define RESERVED	0xE0 /* bits 5..7: reserved */

static struct sd {
	z_stream	stream;
	int		z_err;	/* error code for last stream operation */
	int		z_eof;	/* set if end of input file */
	int		fd;
	unsigned char	*inbuf;	/* input buffer */
	unsigned long	crc;	/* crc32 of uncompressed data */
	int		transparent; /* 1 if input file is not a .gz file */
} *ss[SOPEN_MAX];

#ifdef DEBUG
int z_verbose = 0;
#endif

/*
 * compression utilities
 */

void	*zcalloc(void *, unsigned int, unsigned int);
void	zcfree(void *, void *);

void *
zcalloc(void *opaque, unsigned int items, unsigned int size)
{
	return(alloc(items * size));
}

void
zcfree(void *opaque, void *ptr)
{
	free(ptr, 0); /* XXX works only with modified allocator */
}

static int
get_byte(struct sd *s)
{
	if (s->z_eof)
		return EOF;
	if (s->stream.avail_in == 0) {
		errno = 0;
		s->stream.avail_in = oread(s->fd, s->inbuf, Z_BUFSIZE);
		if (s->stream.avail_in <= 0) {
			s->z_eof = 1;
			if (errno)
				s->z_err = Z_ERRNO;
			return EOF;
		}
		s->stream.next_in = s->inbuf;
	}
	s->stream.avail_in--;
	return *(s->stream.next_in)++;
}

static unsigned long
getLong(struct sd *s)
{
	unsigned long x = (unsigned long)get_byte(s);
	int c;

	x += ((unsigned long)get_byte(s))<<8;
	x += ((unsigned long)get_byte(s))<<16;
	c = get_byte(s);
	if (c == EOF)
		s->z_err = Z_DATA_ERROR;
	x += ((unsigned long)c)<<24;
	return x;
}

static void
check_header(struct sd *s)
{
	int method; /* method byte */
	int flags;  /* flags byte */
	unsigned int len;
	int c;

	/* Check the gzip magic header */
	for (len = 0; len < 2; len++) {
		c = get_byte(s);
		if (c != gz_magic[len]) {
			if (len != 0) {
				s->stream.avail_in++;
				s->stream.next_in--;
			}
			if (c != EOF) {
				s->stream.avail_in++;
				s->stream.next_in--;
				s->transparent = 1;
			}

			s->z_err = s->stream.avail_in != 0 ? Z_OK :
			    Z_STREAM_END;
			return;
		}
	}
	method = get_byte(s);
	flags = get_byte(s);
	if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
		s->z_err = Z_DATA_ERROR;
		return;
	}

	/* Discard time, xflags and OS code: */
	for (len = 0; len < 6; len++)
		(void)get_byte(s);

	if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
		len  =  (unsigned int)get_byte(s);
		len += ((unsigned int)get_byte(s))<<8;
		/* len is garbage if EOF but the loop below will quit anyway */
		while (len-- != 0 && get_byte(s) != EOF)
			;
	}
	if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
		while ((c = get_byte(s)) != 0 && c != EOF)
			;
	}
	if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
		while ((c = get_byte(s)) != 0 && c != EOF)
			;
	}
	if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
		for (len = 0; len < 2; len++)
			(void)get_byte(s);
	}
	s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

/*
 * new open(), close(), read(), lseek()
 */

int
open(const char *fname, int mode)
{
	int fd;
	struct sd *s = 0;

	if (((fd = oopen(fname, mode)) == -1) ||
	    (mode != 0)) /* compression only for read */
		return(fd);

	ss[fd] = s = alloc(sizeof(struct sd));
	if (!s)
		goto errout;
	bzero(s, sizeof(struct sd));

	if (inflateInit2(&(s->stream), -15) != Z_OK)
		goto errout;

	s->stream.next_in  = s->inbuf = (unsigned char *)alloc(Z_BUFSIZE);
	if (!s->inbuf) {
		inflateEnd(&(s->stream));
		goto errout;
	}

	s->fd = fd;
	check_header(s); /* skip the .gz header */
	return(fd);

errout:
	if (s)
		free(s, sizeof(struct sd));
	oclose(fd);
	return(-1);
}

int
close(int fd)
{
	struct open_file *f;
	struct sd *s;

	if ((unsigned)fd >= SOPEN_MAX) {
		errno = EBADF;
		return (-1);
	}
	f = &files[fd];

	if (!(f->f_flags & F_READ))
		return(oclose(fd));

	s = ss[fd];
	if (s != NULL) {
		inflateEnd(&(s->stream));

		free(s->inbuf, Z_BUFSIZE);
		free(s, sizeof(struct sd));
	}

	return(oclose(fd));
}

ssize_t
read(int fd, void *buf, size_t len)
{
	struct sd *s;
	unsigned char *start = buf; /* starting point for crc computation */

	s = ss[fd];

	if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO)
		return -1;
	if (s->z_err == Z_STREAM_END)
		return 0;  /* EOF */

	s->stream.next_out = buf;
	s->stream.avail_out = len;

	while (s->stream.avail_out != 0) {

		if (s->transparent) {
			/* Copy first the lookahead bytes: */
			unsigned int n = s->stream.avail_in;

			if (n > s->stream.avail_out)
				n = s->stream.avail_out;
			if (n > 0) {
				zmemcpy(s->stream.next_out, s->stream.next_in, n);
				s->stream.next_out += n;
				s->stream.next_in   += n;
				s->stream.avail_out -= n;
				s->stream.avail_in  -= n;
			}
			if (s->stream.avail_out > 0) {
				int n;

				n = oread(fd, s->stream.next_out,
				    s->stream.avail_out);
				if (n <= 0) {
					s->z_eof = 1;
					if (errno) {
						s->z_err = Z_ERRNO;
						break;
					}
				}
				s->stream.avail_out -= n;
			}
			len -= s->stream.avail_out;
			s->stream.total_in  += (unsigned long)len;
			s->stream.total_out += (unsigned long)len;
			if (len == 0)
				s->z_eof = 1;
			return (int)len;
		}

		if (s->stream.avail_in == 0 && !s->z_eof) {
			errno = 0;
			s->stream.avail_in = oread(fd, s->inbuf, Z_BUFSIZE);
			if (s->stream.avail_in <= 0) {
				s->z_eof = 1;
				if (errno) {
					s->z_err = Z_ERRNO;
					break;
				}
			}
			s->stream.next_in = s->inbuf;
		}
		s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

		if (s->z_err == Z_STREAM_END) {
			/* Check CRC and original size */
			s->crc = crc32(s->crc, start,
			    (unsigned int)(s->stream.next_out - start));
			start = s->stream.next_out;

			if (getLong(s) != s->crc) {
				s->z_err = Z_DATA_ERROR;
			} else {
				(void)getLong(s);

				/* The uncompressed length returned by
				 * above getlong() may be different from
				 * s->stream.total_out in case of concatenated
				 * .gz files. Check for such files:
				 */
				check_header(s);
				if (s->z_err == Z_OK) {
					unsigned long total_in = s->stream.total_in;
					unsigned long total_out = s->stream.total_out;

					inflateReset(&(s->stream));
					s->stream.total_in = total_in;
					s->stream.total_out = total_out;
					s->crc = crc32(0L, Z_NULL, 0);
				}
			}
		}
		if (s->z_err != Z_OK || s->z_eof)
			break;
	}
	s->crc = crc32(s->crc, start, (unsigned int)(s->stream.next_out - start));

	return (int)(len - s->stream.avail_out);
}

off_t
lseek(int fd, off_t offset, int where)
{
	struct open_file *f;
	struct sd *s;

	if ((unsigned)fd >= SOPEN_MAX) {
		errno = EBADF;
		return (-1);
	}
	f = &files[fd];

	if (!(f->f_flags & F_READ))
		return(olseek(fd, offset, where));

	s = ss[fd];

	if (s->transparent) {
		off_t res = olseek(fd, offset, where);
		if (res != (off_t)-1) {
			/* make sure the lookahead buffer is invalid */
			s->stream.avail_in = 0;
		}
		return(res);
	}

	switch(where) {
	case SEEK_CUR:
		offset += s->stream.total_out;
	case SEEK_SET:

		/* if seek backwards, simply start from
		 the beginning */
		if (offset < s->stream.total_out) {
			off_t res;
			void *sav_inbuf;

			res = olseek(fd, 0, SEEK_SET);
			if (res == (off_t)-1)
				return(res);
			/* ??? perhaps fallback to close / open */

			inflateEnd(&(s->stream));

			sav_inbuf = s->inbuf; /* don't allocate again */
			bzero(s, sizeof(struct sd)); /* this resets total_out to 0! */

			inflateInit2(&(s->stream), -15);
			s->stream.next_in = s->inbuf = sav_inbuf;

			s->fd = fd;
			check_header(s); /* skip the .gz header */
		}

		/* to seek forwards, throw away data */
		if (offset > s->stream.total_out) {
			off_t toskip = offset - s->stream.total_out;

			while(toskip > 0) {
#define DUMMYBUFSIZE 256
				char dummybuf[DUMMYBUFSIZE];
				size_t len = toskip;
				ssize_t n;

				if (len > DUMMYBUFSIZE)
					len = DUMMYBUFSIZE;
				n = read(fd, dummybuf, len);
				if (n <= 0) {
					if (n == 0)
						errno = EINVAL;
					return((off_t)-1);
				}
				toskip -= n;
			}
		}
#ifdef DEBUG
		if (offset != s->stream.total_out)
			panic("lseek compressed");
#endif
		return(offset);
	case SEEK_END:
		errno = EOFFSET;
		break;
	default:
		errno = EINVAL;
	}
	return((off_t)-1);
}
@


1.14
log
@unifdef SAVE_MEMORY which is no longer set nor used

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.13 2009/01/18 21:46:50 miod Exp $	*/
d419 2
a420 1
				off_t len = toskip;
d424 4
a427 2
				if (read(fd, dummybuf, len) != len) {
					errno = EOFFSET;
d430 1
a430 1
				toskip -= len;
@


1.13
log
@If open() failed because the file does not exist, a struct sd for this file
won't be allocated. Check for this in close() so as not to free() bogus
pointers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.12 2004/04/02 04:39:51 deraadt Exp $	*/
a49 3
#ifdef SAVE_MEMORY
#define Z_BUFSIZE 1024
#else
a50 1
#endif
a208 3
#ifdef SAVE_MEMORY
	if (inflateInit2(&(s->stream), -11) != Z_OK)
#else
a209 1
#endif
@


1.12
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.11 2003/08/11 06:23:09 deraadt Exp $	*/
d253 2
d256 3
a258 4
	inflateEnd(&(s->stream));

	free(s->inbuf, Z_BUFSIZE);
	free(s, sizeof(struct sd));
@


1.11
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.10 2003/04/17 13:22:38 mickey Exp $	*/
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@missing indent
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.9 2002/03/14 03:16:10 millert Exp $	*/
d65 6
a70 6
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */
d73 7
a79 7
  z_stream stream;
  int      z_err;   /* error code for last stream operation */
  int      z_eof;   /* set if end of input file */
  int fd;
  unsigned char     *inbuf;  /* input buffer */
  unsigned long    crc;     /* crc32 of uncompressed data */
  int      transparent; /* 1 if input file is not a .gz file */
d90 5
a94 4
void *zcalloc (opaque, items, size)
void *opaque;
unsigned items;
unsigned size;
d96 1
a96 1
  return(alloc(items * size));
d99 2
a100 3
void  zcfree (opaque, ptr)
void *opaque;
void *ptr;
d102 1
a102 1
  free(ptr, 0); /* XXX works only with modified allocator */
d105 2
a106 2
static int get_byte(s)
    struct sd *s;
d108 15
a122 13
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
	errno = 0;
	s->stream.avail_in = oread(s->fd, s->inbuf, Z_BUFSIZE);
	if (s->stream.avail_in <= 0) {
	    s->z_eof = 1;
	    if (errno) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
d125 2
a126 2
static unsigned long getLong (s)
    struct sd *s;
d128 2
a129 2
    unsigned long x = (unsigned long)get_byte(s);
    int c;
d131 7
a137 6
    x += ((unsigned long)get_byte(s))<<8;
    x += ((unsigned long)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((unsigned long)c)<<24;
    return x;
d140 2
a141 2
static void check_header(s)
    struct sd *s;
d143 18
a160 4
    int method; /* method byte */
    int flags;  /* flags byte */
    unsigned int len;
    int c;
d162 36
a197 39
    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
    }
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
	s->z_err = Z_DATA_ERROR;
	return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
	len  =  (unsigned int)get_byte(s);
	len += ((unsigned int)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
	for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
d205 1
a205 3
open(fname, mode)
	const char *fname;
	int mode;
d207 2
a208 2
	  int fd;
	  struct sd *s = 0;
d210 2
a211 2
	  if(((fd = oopen(fname, mode)) == -1)
	     || (mode != 0)) /* compression only for read */
d214 4
a217 3
	  ss[fd] = s = alloc(sizeof(struct sd));
	  if(!s) goto errout;
	  bzero(s, sizeof(struct sd));
d220 1
a220 1
	  if(inflateInit2(&(s->stream), -11) != Z_OK)
d222 1
a222 1
	  if(inflateInit2(&(s->stream), -15) != Z_OK)
d224 1
a224 1
	      goto errout;
d226 9
a234 9
	  s->stream.next_in  = s->inbuf = (unsigned char *)alloc(Z_BUFSIZE);
	  if(!s->inbuf) {
	      inflateEnd(&(s->stream));
	      goto errout;
	  }

	  s->fd = fd;
	  check_header(s); /* skip the .gz header */
	  return(fd);
d237 4
a240 3
          if(s) free(s, sizeof(struct sd));
          oclose(fd);
	  return(-1);
d244 1
a244 2
close(fd)
	int fd;
d247 1
a247 1
        struct sd *s;
d255 1
a255 1
	if(!(f->f_flags & F_READ))
d269 1
a269 4
read(fd, buf, len)
	int fd;
	void *buf;
	size_t len;
d271 2
a272 2
	  struct sd *s;
	  unsigned char *start = buf; /* starting point for crc computation */
d274 1
a274 1
	  s = ss[fd];
d276 25
a300 2
	  if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
	  if (s->z_err == Z_STREAM_END) return 0;  /* EOF */
d302 17
a318 44
	  s->stream.next_out = buf;
	  s->stream.avail_out = len;

	  while (s->stream.avail_out != 0) {

	    if (s->transparent) {
	      /* Copy first the lookahead bytes: */
	      unsigned int n = s->stream.avail_in;
	      if (n > s->stream.avail_out) n = s->stream.avail_out;
	      if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		s->stream.next_out += n;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	      }
	      if (s->stream.avail_out > 0) {
		int n;
		n = oread(fd, s->stream.next_out, s->stream.avail_out);
		if (n <= 0) {
		  s->z_eof = 1;
		  if (errno) {
		    s->z_err = Z_ERRNO;
		    break;
		  }
	        }
		s->stream.avail_out -= n;
	      }
	      len -= s->stream.avail_out;
	      s->stream.total_in  += (unsigned long)len;
	      s->stream.total_out += (unsigned long)len;
	      if (len == 0) s->z_eof = 1;
	      return (int)len;
	    }

	    if (s->stream.avail_in == 0 && !s->z_eof) {

	      errno = 0;
	      s->stream.avail_in = oread(fd, s->inbuf, Z_BUFSIZE);
	      if (s->stream.avail_in <= 0) {
		s->z_eof = 1;
		if (errno) {
		  s->z_err = Z_ERRNO;
		  break;
a319 9
	      }
	      s->stream.next_in = s->inbuf;
	    }
	    s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

	    if (s->z_err == Z_STREAM_END) {
	      /* Check CRC and original size */
	      s->crc = crc32(s->crc, start, (unsigned int)(s->stream.next_out - start));
	      start = s->stream.next_out;
d321 41
a361 17
	      if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	      } else {
		(void)getLong(s);
		/* The uncompressed length returned by above getlong() may
		 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		  unsigned long total_in = s->stream.total_in;
		  unsigned long total_out = s->stream.total_out;

		  inflateReset(&(s->stream));
		  s->stream.total_in = total_in;
		  s->stream.total_out = total_out;
		  s->crc = crc32(0L, Z_NULL, 0);
d363 4
a366 5
	      }
	    }
	    if (s->z_err != Z_OK || s->z_eof) break;
	  }
	  s->crc = crc32(s->crc, start, (unsigned int)(s->stream.next_out - start));
d368 1
a368 1
	  return (int)(len - s->stream.avail_out);
d372 1
a372 4
lseek(fd, offset, where)
	int fd;
	off_t offset;
	int where;
d374 2
a375 2
	    register struct open_file *f;
	    struct sd *s;
d377 1
a377 1
	    if ((unsigned)fd >= SOPEN_MAX) {
d380 2
a381 2
	    }
	    f = &files[fd];
d383 1
a383 1
	    if(!(f->f_flags & F_READ))
d386 1
a386 1
	    s = ss[fd];
d388 1
a388 1
	    if(s->transparent) {
d390 3
a392 3
		if(res != (off_t)-1) {
		    /* make sure the lookahead buffer is invalid */
		    s->stream.avail_in = 0;
d395 1
a395 1
	    }
d397 8
a404 8
	    switch(where) {
		case SEEK_CUR:
		    offset += s->stream.total_out;
		case SEEK_SET:

		    /* if seek backwards, simply start from
		     the beginning */
		    if(offset < s->stream.total_out) {
d409 2
a410 2
			if(res == (off_t)-1)
			    return(res);
d423 1
a423 1
		    }
d425 2
a426 2
		    /* to seek forwards, throw away data */
		    if(offset > s->stream.total_out) {
d431 10
a440 8
			    char dummybuf[DUMMYBUFSIZE];
			    off_t len = toskip;
			    if(len > DUMMYBUFSIZE) len = DUMMYBUFSIZE;
			    if(read(fd, dummybuf, len) != len) {
				errno = EOFFSET;
				return((off_t)-1);
			    }
			    toskip -= len;
d442 1
a442 1
		    }
d444 1
a444 1
		    if(offset != s->stream.total_out)
d447 8
a454 8
		    return(offset);
		case SEEK_END:
		    errno = EOFFSET;
		    break;
		default:
		    errno = EINVAL;
	    }
	    return((off_t)-1);
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.8 1999/02/14 20:07:46 mickey Exp $	*/
d200 1
a200 1
	  return(fd);
@


1.8
log
@place a bin-patcheable z_verbose here for -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.7 1999/01/25 19:28:38 mickey Exp $	*/
d213 1
a213 1
	  s->stream.next_in  = s->inbuf = (unsigned char*)alloc(Z_BUFSIZE);
@


1.8.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.8 1999/02/14 20:07:46 mickey Exp $	*/
d213 1
a213 1
	  s->stream.next_in  = s->inbuf = (unsigned char *)alloc(Z_BUFSIZE);
@


1.8.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 1
a200 1
		return(fd);
@


1.8.6.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d213 1
a213 1
	  s->stream.next_in  = s->inbuf = (unsigned char *)alloc(Z_BUFSIZE);
@


1.8.6.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.8.6.1 2002/03/28 15:02:00 niklas Exp $	*/
d200 1
a200 1
		return(fd);
@


1.8.6.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 6
a70 6
#define ASCII_FLAG	0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC	0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD	0x04 /* bit 2 set: extra field present */
#define ORIG_NAME	0x08 /* bit 3 set: original file name present */
#define COMMENT		0x10 /* bit 4 set: file comment present */
#define RESERVED	0xE0 /* bits 5..7: reserved */
d73 7
a79 7
	z_stream	stream;
	int		z_err;	/* error code for last stream operation */
	int		z_eof;	/* set if end of input file */
	int		fd;
	unsigned char	*inbuf;	/* input buffer */
	unsigned long	crc;	/* crc32 of uncompressed data */
	int		transparent; /* 1 if input file is not a .gz file */
d90 4
a93 5
void	*zcalloc(void *, unsigned int, unsigned int);
void	zcfree(void *, void *);

void *
zcalloc(void *opaque, unsigned int items, unsigned int size)
d95 1
a95 1
	return(alloc(items * size));
d98 3
a100 2
void
zcfree(void *opaque, void *ptr)
d102 1
a102 1
	free(ptr, 0); /* XXX works only with modified allocator */
d105 2
a106 2
static int
get_byte(struct sd *s)
d108 13
a120 15
	if (s->z_eof)
		return EOF;
	if (s->stream.avail_in == 0) {
		errno = 0;
		s->stream.avail_in = oread(s->fd, s->inbuf, Z_BUFSIZE);
		if (s->stream.avail_in <= 0) {
			s->z_eof = 1;
			if (errno)
				s->z_err = Z_ERRNO;
			return EOF;
		}
		s->stream.next_in = s->inbuf;
	}
	s->stream.avail_in--;
	return *(s->stream.next_in)++;
d123 2
a124 2
static unsigned long
getLong(struct sd *s)
d126 2
a127 2
	unsigned long x = (unsigned long)get_byte(s);
	int c;
d129 6
a134 7
	x += ((unsigned long)get_byte(s))<<8;
	x += ((unsigned long)get_byte(s))<<16;
	c = get_byte(s);
	if (c == EOF)
		s->z_err = Z_DATA_ERROR;
	x += ((unsigned long)c)<<24;
	return x;
d137 2
a138 2
static void
check_header(struct sd *s)
d140 4
a143 18
	int method; /* method byte */
	int flags;  /* flags byte */
	unsigned int len;
	int c;

	/* Check the gzip magic header */
	for (len = 0; len < 2; len++) {
		c = get_byte(s);
		if (c != gz_magic[len]) {
			if (len != 0) {
				s->stream.avail_in++;
				s->stream.next_in--;
			}
			if (c != EOF) {
				s->stream.avail_in++;
				s->stream.next_in--;
				s->transparent = 1;
			}
d145 39
a183 36
			s->z_err = s->stream.avail_in != 0 ? Z_OK :
			    Z_STREAM_END;
			return;
		}
	}
	method = get_byte(s);
	flags = get_byte(s);
	if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
		s->z_err = Z_DATA_ERROR;
		return;
	}

	/* Discard time, xflags and OS code: */
	for (len = 0; len < 6; len++)
		(void)get_byte(s);

	if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
		len  =  (unsigned int)get_byte(s);
		len += ((unsigned int)get_byte(s))<<8;
		/* len is garbage if EOF but the loop below will quit anyway */
		while (len-- != 0 && get_byte(s) != EOF)
			;
	}
	if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
		while ((c = get_byte(s)) != 0 && c != EOF)
			;
	}
	if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
		while ((c = get_byte(s)) != 0 && c != EOF)
			;
	}
	if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
		for (len = 0; len < 2; len++)
			(void)get_byte(s);
	}
	s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
d191 3
a193 1
open(const char *fname, int mode)
d195 2
a196 2
	int fd;
	struct sd *s = 0;
d198 2
a199 2
	if (((fd = oopen(fname, mode)) == -1) ||
	    (mode != 0)) /* compression only for read */
d202 3
a204 4
	ss[fd] = s = alloc(sizeof(struct sd));
	if (!s)
		goto errout;
	bzero(s, sizeof(struct sd));
d207 1
a207 1
	if (inflateInit2(&(s->stream), -11) != Z_OK)
d209 1
a209 1
	if (inflateInit2(&(s->stream), -15) != Z_OK)
d211 1
a211 1
		goto errout;
d213 9
a221 9
	s->stream.next_in  = s->inbuf = (unsigned char *)alloc(Z_BUFSIZE);
	if (!s->inbuf) {
		inflateEnd(&(s->stream));
		goto errout;
	}

	s->fd = fd;
	check_header(s); /* skip the .gz header */
	return(fd);
d224 3
a226 4
	if (s)
		free(s, sizeof(struct sd));
	oclose(fd);
	return(-1);
d230 2
a231 1
close(int fd)
d234 1
a234 1
	struct sd *s;
d242 1
a242 1
	if (!(f->f_flags & F_READ))
d256 4
a259 1
read(int fd, void *buf, size_t len)
d261 2
a262 2
	struct sd *s;
	unsigned char *start = buf; /* starting point for crc computation */
d264 1
a264 1
	s = ss[fd];
d266 2
a267 25
	if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO)
		return -1;
	if (s->z_err == Z_STREAM_END)
		return 0;  /* EOF */

	s->stream.next_out = buf;
	s->stream.avail_out = len;

	while (s->stream.avail_out != 0) {

		if (s->transparent) {
			/* Copy first the lookahead bytes: */
			unsigned int n = s->stream.avail_in;

			if (n > s->stream.avail_out)
				n = s->stream.avail_out;
			if (n > 0) {
				zmemcpy(s->stream.next_out, s->stream.next_in, n);
				s->stream.next_out += n;
				s->stream.next_in   += n;
				s->stream.avail_out -= n;
				s->stream.avail_in  -= n;
			}
			if (s->stream.avail_out > 0) {
				int n;
d269 44
a312 17
				n = oread(fd, s->stream.next_out,
				    s->stream.avail_out);
				if (n <= 0) {
					s->z_eof = 1;
					if (errno) {
						s->z_err = Z_ERRNO;
						break;
					}
				}
				s->stream.avail_out -= n;
			}
			len -= s->stream.avail_out;
			s->stream.total_in  += (unsigned long)len;
			s->stream.total_out += (unsigned long)len;
			if (len == 0)
				s->z_eof = 1;
			return (int)len;
d314 9
d324 17
a340 11
		if (s->stream.avail_in == 0 && !s->z_eof) {
			errno = 0;
			s->stream.avail_in = oread(fd, s->inbuf, Z_BUFSIZE);
			if (s->stream.avail_in <= 0) {
				s->z_eof = 1;
				if (errno) {
					s->z_err = Z_ERRNO;
					break;
				}
			}
			s->stream.next_in = s->inbuf;
d342 5
a346 1
		s->z_err = inflate(&(s->stream), Z_NO_FLUSH);
d348 1
a348 34
		if (s->z_err == Z_STREAM_END) {
			/* Check CRC and original size */
			s->crc = crc32(s->crc, start,
			    (unsigned int)(s->stream.next_out - start));
			start = s->stream.next_out;

			if (getLong(s) != s->crc) {
				s->z_err = Z_DATA_ERROR;
			} else {
				(void)getLong(s);

				/* The uncompressed length returned by
				 * above getlong() may be different from
				 * s->stream.total_out in case of concatenated
				 * .gz files. Check for such files:
				 */
				check_header(s);
				if (s->z_err == Z_OK) {
					unsigned long total_in = s->stream.total_in;
					unsigned long total_out = s->stream.total_out;

					inflateReset(&(s->stream));
					s->stream.total_in = total_in;
					s->stream.total_out = total_out;
					s->crc = crc32(0L, Z_NULL, 0);
				}
			}
		}
		if (s->z_err != Z_OK || s->z_eof)
			break;
	}
	s->crc = crc32(s->crc, start, (unsigned int)(s->stream.next_out - start));

	return (int)(len - s->stream.avail_out);
d352 4
a355 1
lseek(int fd, off_t offset, int where)
d357 2
a358 2
	struct open_file *f;
	struct sd *s;
d360 1
a360 1
	if ((unsigned)fd >= SOPEN_MAX) {
d363 2
a364 2
	}
	f = &files[fd];
d366 1
a366 1
	if (!(f->f_flags & F_READ))
d369 1
a369 1
	s = ss[fd];
d371 1
a371 1
	if (s->transparent) {
d373 3
a375 3
		if (res != (off_t)-1) {
			/* make sure the lookahead buffer is invalid */
			s->stream.avail_in = 0;
d378 1
a378 1
	}
d380 8
a387 8
	switch(where) {
	case SEEK_CUR:
		offset += s->stream.total_out;
	case SEEK_SET:

		/* if seek backwards, simply start from
		 the beginning */
		if (offset < s->stream.total_out) {
d392 2
a393 2
			if (res == (off_t)-1)
				return(res);
d406 1
a406 1
		}
d408 2
a409 2
		/* to seek forwards, throw away data */
		if (offset > s->stream.total_out) {
d414 8
a421 10
				char dummybuf[DUMMYBUFSIZE];
				off_t len = toskip;

				if (len > DUMMYBUFSIZE)
					len = DUMMYBUFSIZE;
				if (read(fd, dummybuf, len) != len) {
					errno = EOFFSET;
					return((off_t)-1);
				}
				toskip -= len;
d423 1
a423 1
		}
d425 1
a425 1
		if (offset != s->stream.total_out)
d428 8
a435 8
		return(offset);
	case SEEK_END:
		errno = EOFFSET;
		break;
	default:
		errno = EINVAL;
	}
	return((off_t)-1);
@


1.8.6.4
log
@Merge with the trunk
@
text
@d16 6
@


1.7
log
@fix a real bad bug, which consists of return value from
read() /* oread() */ not being checked for errors/eof or
not checked for error value (-1), which would result in
bad kernels loaded, i/o errors not reported and such.
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.6 1998/09/08 03:33:06 millert Exp $	*/
d81 4
@


1.6
log
@minor changes from zlib-1.1.3 gzio.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.5 1997/02/15 21:38:26 mickey Exp $	*/
d108 1
a108 1
	if (s->stream.avail_in == 0) {
d282 10
a291 1
		s->stream.avail_out -= oread(fd, s->stream.next_out, s->stream.avail_out);
d304 1
a304 1
	      if (s->stream.avail_in == 0) {
@


1.5
log
@SAVE_MEMORY even more
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.4 1997/02/06 22:57:03 downsj Exp $	*/
d145 5
a149 2
	    s->transparent = 1;
	    if (c != EOF) s->stream.avail_in++, s->stream.next_in--;
d282 1
a282 1
		s->stream.avail_out -= oread(s->fd, s->stream.next_out, s->stream.avail_out);
d284 5
a288 1
	      return (int)(len - s->stream.avail_out);
d311 1
a311 1
	      if (getLong(s) != s->crc || getLong(s) != s->stream.total_out) {
d314 5
a318 1
		/* Check for concatenated .gz files: */
d321 3
d325 2
d351 1
a351 1
	    f = &files[fd];;
@


1.4
log
@* remove reference to non-existant fat.c.
* make cread.c work with libz again.
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.3 1997/02/06 06:28:52 mickey Exp $	*/
d199 3
d203 1
@


1.3
log
@missed test compile );
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.2 1997/02/06 06:19:58 mickey Exp $	*/
d50 1
a50 1
#include "zlib.h"
d94 1
a94 1
void  zfree (opaque, ptr, size)
a96 1
size_t size;
d98 1
a98 1
  free(ptr, size);
@


1.2
log
@make it work w/ old allocator
no need for zmemcpy
better use /sys/net/zlib.c, it's smaller and it's form kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: cread.c,v 1.1 1997/02/06 02:56:45 downsj Exp $	*/
d94 1
a94 1
void  zfree (opaque, ptr)
@


1.1
log
@Add libz and make libsa aware of it.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
#include "../libz/zlib.h"
d54 2
d94 1
a94 1
void  zcfree (opaque, ptr)
d97 1
d99 1
a99 9
  free(ptr, 0); /* XXX works only with modified allocator */
}

void zmemcpy(dest, source, len)
unsigned char *dest;
unsigned char *source;
unsigned int len;
{
  bcopy(source, dest, len);
@
