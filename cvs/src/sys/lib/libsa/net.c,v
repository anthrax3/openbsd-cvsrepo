head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.8
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.4
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.46
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.42
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.40
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.38
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.36
	OPENBSD_5_0:1.13.0.34
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.32
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.30
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.26
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.18
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.16
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.14
	OPENBSD_2_8:1.10.0.12
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.10
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.8
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.4
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.8.0.2
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2015.10.26.14.48.54;	author mmcc;	state Exp;
branches;
next	1.19;
commitid	AARhGCpGYzvUmAjg;

1.19
date	2015.10.26.02.33.07;	author mmcc;	state Exp;
branches;
next	1.18;
commitid	MO0NTWFi67oIosaw;

1.18
date	2015.07.16.16.12.15;	author mpi;	state Exp;
branches;
next	1.17;
commitid	STtcOm1B3VSMXz2h;

1.17
date	2014.11.19.20.28.56;	author miod;	state Exp;
branches;
next	1.16;
commitid	F3EvOaAgKQy5tMAq;

1.16
date	2014.11.19.20.01.33;	author miod;	state Exp;
branches;
next	1.15;
commitid	9VZgPwegRuvi9VC1;

1.15
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.14;
commitid	Qb045HZ5OhQfU69H;

1.14
date	2014.07.13.15.31.20;	author mpi;	state Exp;
branches;
next	1.13;
commitid	7SdCoErqwI9qHMpK;

1.13
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.01.17.00.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.05.31.23.39.15;	author mickey;	state Exp;
branches
	1.10.8.1
	1.10.18.1;
next	1.9;

1.9
date	98.02.23.20.32.27;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.05.05.02.49.49;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.12.08.15.15.51;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.14.24.08;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.10.16.11.04.38;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.23.14.18.57;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.20.14.20.25;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.08.07.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.57;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.57;	author deraadt;	state Exp;
branches;
next	;

1.10.8.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.10.8.2;

1.10.8.2
date	2003.06.07.11.03.42;	author ho;	state Exp;
branches;
next	1.10.8.3;

1.10.8.3
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.10.18.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@(char *)0 -> NULL

ok tedu@@
@
text
@/*	$OpenBSD: net.c,v 1.19 2015/10/26 02:33:07 mmcc Exp $	*/
/*	$NetBSD: net.c,v 1.14 1996/10/13 02:29:02 christos Exp $	*/

/*
 * Copyright (c) 1992 Regents of the University of California.
 * All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @@(#) Header: net.c,v 1.9 93/08/06 19:32:15 leres Exp  (LBL)
 */

#include <sys/param.h>
#include <sys/socket.h>

#include <net/if.h>
#include <netinet/in.h>

#include <netinet/if_ether.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>

#include "stand.h"
#include "net.h"

/*
 * Send a packet and wait for a reply, with exponential backoff.
 *
 * The send routine must return the actual number of bytes written.
 *
 * The receive routine can indicate success by returning the number of
 * bytes read; it can return 0 to indicate EOF; it can return -1 with a
 * non-zero errno to indicate failure; finally, it can return -1 with a
 * zero errno to indicate it isn't done yet.
 */
ssize_t
sendrecv(struct iodesc *d, ssize_t (*sproc)(struct iodesc *, void *, size_t),
    void *sbuf, size_t ssize,
    ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t),
    void *rbuf, size_t rsize)
{
	ssize_t cc;
	time_t t, tmo, tlast;
	long tleft;

#ifdef NET_DEBUG
	if (debug)
		printf("sendrecv: called\n");
#endif

	tmo = MINTMO;
	tlast = tleft = 0;
	t = getsecs();
	for (;;) {
		if (tleft <= 0) {
			if (tmo >= MAXTMO) {
				errno = ETIMEDOUT;
				return -1;
			}
			cc = (*sproc)(d, sbuf, ssize);
			if (cc < 0 || (size_t)cc < ssize)
				panic("sendrecv: short write! (%d < %d)",
				    cc, ssize);

			tleft = tmo;
			tmo <<= 1;
			if (tmo > MAXTMO)
				tmo = MAXTMO;
			tlast = t;
		}

		/* Try to get a packet and process it. */
		cc = (*rproc)(d, rbuf, rsize, tleft);
		/* Return on data, EOF or real error. */
		if (cc != -1 || errno != 0)
			return (cc);

		/* Timed out or didn't get the packet we're waiting for */
		t = getsecs();
		tleft -= t - tlast;
		tlast = t;
	}
}

/*
 * Like inet_addr() in the C library, but we only accept base-10.
 * Return values are in network order.
 */
u_int32_t
inet_addr(const char *cp)
{
	u_long val;
	int n;
	char c;
	u_int parts[4];
	u_int *pp = parts;

	for (;;) {
		/*
		 * Collect number up to ``.''.
		 * Values are specified as for C:
		 * 0x=hex, 0=octal, other=decimal.
		 */
		val = 0;
		while ((c = *cp) != '\0') {
			if (c >= '0' && c <= '9') {
				val = (val * 10) + (c - '0');
				cp++;
				continue;
			}
			break;
		}
		if (*cp == '.') {
			/*
			 * Internet format:
			 *	a.b.c.d
			 *	a.b.c	(with c treated as 16-bits)
			 *	a.b	(with b treated as 24 bits)
			 */
			if (pp >= parts + 3 || val > 0xff)
				goto bad;
			*pp++ = val, cp++;
		} else
			break;
	}
	/*
	 * Check for trailing characters.
	 */
	if (*cp != '\0')
		goto bad;

	/*
	 * Concoct the address according to
	 * the number of parts specified.
	 */
	n = pp - parts + 1;
	switch (n) {

	case 1:				/* a -- 32 bits */
		break;

	case 2:				/* a.b -- 8.24 bits */
		if (val > 0xffffff)
			goto bad;
		val |= parts[0] << 24;
		break;

	case 3:				/* a.b.c -- 8.8.16 bits */
		if (val > 0xffff)
			goto bad;
		val |= (parts[0] << 24) | (parts[1] << 16);
		break;

	case 4:				/* a.b.c.d -- 8.8.8.8 bits */
		if (val > 0xff)
			goto bad;
		val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
		break;
	}

	return (htonl(val));
 bad:
	return (htonl(INADDR_NONE));
}

const char *
inet_ntoa(struct in_addr ia)
{
	return (intoa(ia.s_addr));
}

/* Similar to inet_ntoa() */
const char *
intoa(u_int32_t addr)
{
	char *cp;
	u_int byte;
	int n;
	static char buf[sizeof(".255.255.255.255")];

	addr = ntohl(addr);
	cp = &buf[sizeof buf];
	*--cp = '\0';

	n = 4;
	do {
		byte = addr & 0xff;
		*--cp = byte % 10 + '0';
		byte /= 10;
		if (byte > 0) {
			*--cp = byte % 10 + '0';
			byte /= 10;
			if (byte > 0)
				*--cp = byte + '0';
		}
		*--cp = '.';
		addr >>= 8;
	} while (--n > 0);

	return (cp+1);
}

static const char *
number(const char *s, int *n)
{
	for (*n = 0; isdigit((unsigned char)*s); s++)
		*n = (*n * 10) + *s - '0';
	return s;
}

u_int32_t
ip_convertaddr(const char *p)
{
#define IP_ANYADDR	0
	u_int32_t addr = 0, n;

	if (p == NULL || *p == '\0')
		return IP_ANYADDR;
	p = number(p, &n);
	addr |= (n << 24) & 0xff000000;
	if (*p == '\0' || *p++ != '.')
		return IP_ANYADDR;
	p = number(p, &n);
	addr |= (n << 16) & 0xff0000;
	if (*p == '\0' || *p++ != '.')
		return IP_ANYADDR;
	p = number(p, &n);
	addr |= (n << 8) & 0xff00;
	if (*p == '\0' || *p++ != '.')
		return IP_ANYADDR;
	p = number(p, &n);
	addr |= n & 0xff;
	if (*p != '\0')
		return IP_ANYADDR;

	return htonl(addr);
}
@


1.19
log
@Cast isdigit()'s argument to unsigned char.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.18 2015/07/16 16:12:15 mpi Exp $	*/
d247 1
a247 1
	if (p == (char *)0 || *p == '\0')
@


1.18
log
@Expand ancient NTOHL/NTOHS/HTONS/HTONL macros.

ok guenther@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.17 2014/11/19 20:28:56 miod Exp $	*/
d236 1
a236 1
	for (*n = 0; isdigit(*s); s++)
@


1.17
log
@Sprinkle const whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.16 2014/11/19 20:01:33 miod Exp $	*/
d211 1
a211 1
	NTOHL(addr);
@


1.16
log
@Move {recv,send}udp() out of net.c into their own file; to be used shortly.
Add the new files to the few md libsa builds which require it.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.15 2014/11/18 23:55:01 krw Exp $	*/
d120 1
a120 1
inet_addr(char *cp)
d196 1
a196 1
char *
d203 1
a203 1
char *
d233 2
a234 2
static char *
number(char *s, int *n)
d242 1
a242 1
ip_convertaddr(char *p)
@


1.15
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.14 2014/07/13 15:31:20 mpi Exp $	*/
a51 2
#include <netinet/udp.h>
#include <netinet/udp_var.h>
a54 201

/* Caller must leave room for ethernet, ip and udp headers in front!! */
ssize_t
sendudp(struct iodesc *d, void *pkt, size_t len)
{
	ssize_t cc;
	struct ip *ip;
	struct udpiphdr *ui;
	struct udphdr *uh;
	u_char *ea;
	struct ip tip;

#ifdef NET_DEBUG
	if (debug) {
		printf("sendudp: d=%x called.\n", (u_int)d);
		if (d) {
			printf("saddr: %s:%d",
			    inet_ntoa(d->myip), ntohs(d->myport));
			printf(" daddr: %s:%d\n",
			    inet_ntoa(d->destip), ntohs(d->destport));
		}
	}
#endif

	uh = (struct udphdr *)pkt - 1;
	ip = (struct ip *)uh - 1;
	len += sizeof(*ip) + sizeof(*uh);

	bzero(ip, sizeof(*ip) + sizeof(*uh));

	ip->ip_v = IPVERSION;			/* half-char */
	ip->ip_hl = sizeof(*ip) >> 2;		/* half-char */
	ip->ip_len = htons(len);
	ip->ip_p = IPPROTO_UDP;			/* char */
	ip->ip_ttl = IP_TTL;			/* char */
	ip->ip_src = d->myip;
	ip->ip_dst = d->destip;
	ip->ip_sum = in_cksum(ip, sizeof(*ip));	 /* short, but special */

	uh->uh_sport = d->myport;
	uh->uh_dport = d->destport;
	uh->uh_ulen = htons(len - sizeof(*ip));

	/* Calculate checksum (must save and restore ip header) */
	tip = *ip;
	ui = (struct udpiphdr *)ip;
	bzero(ui->ui_x1, sizeof(ui->ui_x1));
	ui->ui_len = uh->uh_ulen;
	uh->uh_sum = in_cksum(ui, len);
	*ip = tip;

	if (ip->ip_dst.s_addr == INADDR_BROADCAST || ip->ip_src.s_addr == 0 ||
	    netmask == 0 || SAMENET(ip->ip_src, ip->ip_dst, netmask))
		ea = arpwhohas(d, ip->ip_dst);
	else
		ea = arpwhohas(d, gateip);

	cc = sendether(d, ip, len, ea, ETHERTYPE_IP);
	if (cc < 0)
		return (-1);
	if ((size_t)cc != len)
		panic("sendudp: bad write (%d != %d)", cc, len);
	return (cc - (sizeof(*ip) + sizeof(*uh)));
}

/*
 * Receive a UDP packet and validate it is for us.
 * Caller leaves room for the headers (Ether, IP, UDP)
 */
ssize_t
readudp(struct iodesc *d, void *pkt, size_t len, time_t tleft)
{
	ssize_t n;
	size_t hlen;
	struct ip *ip;
	struct udphdr *uh;
	struct udpiphdr *ui;
	struct ip tip;
	u_int16_t etype;	/* host order */

#ifdef NET_DEBUG
	if (debug)
		printf("readudp: called\n");
#endif

	uh = (struct udphdr *)pkt - 1;
	ip = (struct ip *)uh - 1;

	n = readether(d, ip, len + sizeof(*ip) + sizeof(*uh), tleft, &etype);
	if (n < 0 || (size_t)n < sizeof(*ip) + sizeof(*uh))
		return -1;

	/* Ethernet address checks now in readether() */

	/* Need to respond to ARP requests. */
	if (etype == ETHERTYPE_ARP) {
		struct arphdr *ah = (void *)ip;
		if (ah->ar_op == htons(ARPOP_REQUEST)) {
			/* Send ARP reply */
			arp_reply(d, ah);
		}
		return -1;
	}

	if (etype != ETHERTYPE_IP) {
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: not IP. ether_type=%x\n", etype);
#endif
		return -1;
	}

	/* Check ip header */
	if (ip->ip_v != IPVERSION ||
	    ip->ip_p != IPPROTO_UDP) {	/* half char */
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: IP version or not UDP. ip_v=%d ip_p=%d\n", ip->ip_v, ip->ip_p);
#endif
		return -1;
	}

	hlen = ip->ip_hl << 2;
	if (hlen < sizeof(*ip) ||
	    in_cksum(ip, hlen) != 0) {
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: short hdr or bad cksum.\n");
#endif
		return -1;
	}
	NTOHS(ip->ip_len);
	if (n < ip->ip_len) {
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: bad length %d < %d.\n", n, ip->ip_len);
#endif
		return -1;
	}
	if (d->myip.s_addr && ip->ip_dst.s_addr != d->myip.s_addr) {
#ifdef NET_DEBUG
		if (debug) {
			printf("readudp: bad saddr %s != ", inet_ntoa(d->myip));
			printf("%s\n", inet_ntoa(ip->ip_dst));
		}
#endif
		return -1;
	}

	/* If there were ip options, make them go away */
	if (hlen != sizeof(*ip)) {
		bcopy(((u_char *)ip) + hlen, uh, len - hlen);
		ip->ip_len = sizeof(*ip);
		n -= hlen - sizeof(*ip);
	}
	if (uh->uh_dport != d->myport) {
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: bad dport %d != %d\n",
				d->myport, ntohs(uh->uh_dport));
#endif
		return -1;
	}

	if (uh->uh_sum) {
		n = ntohs(uh->uh_ulen) + sizeof(*ip);
		if (n > RECV_SIZE - ETHER_SIZE) {
			printf("readudp: huge packet, udp len %ld\n", (long)n);
			return -1;
		}

		/* Check checksum (must save and restore ip header) */
		tip = *ip;
		ui = (struct udpiphdr *)ip;
		bzero(ui->ui_x1, sizeof(ui->ui_x1));
		ui->ui_len = uh->uh_ulen;
		if (in_cksum(ui, n) != 0) {
#ifdef NET_DEBUG
			if (debug)
				printf("readudp: bad cksum\n");
#endif
			*ip = tip;
			return -1;
		}
		*ip = tip;
	}
	NTOHS(uh->uh_dport);
	NTOHS(uh->uh_sport);
	NTOHS(uh->uh_ulen);
	if (uh->uh_ulen < sizeof(*uh)) {
#ifdef NET_DEBUG
		if (debug)
			printf("readudp: bad udp len %d < %d\n",
				uh->uh_ulen, sizeof(*uh));
#endif
		return -1;
	}

	n -= sizeof(*ip) + sizeof(*uh);
	return (n);
}
@


1.14
log
@Stop using old n_long and n_short types.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.13 2003/08/11 06:23:09 deraadt Exp $	*/
a48 1
#include <netinet/in.h>
@


1.13
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.12 2003/06/01 17:00:33 deraadt Exp $	*/
a50 1
#include <netinet/in_systm.h>
d323 1
a323 1
n_long
d408 1
a408 1
intoa(n_long addr)
d445 1
a445 1
n_long
d449 1
a449 1
	n_long addr = 0, n;
@


1.12
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.11 2002/03/14 01:27:07 millert Exp $	*/
d62 1
a62 4
sendudp(d, pkt, len)
	register struct iodesc *d;
	register void *pkt;
	register size_t len;
d64 5
a68 5
	register ssize_t cc;
	register struct ip *ip;
	register struct udpiphdr *ui;
	register struct udphdr *uh;
	register u_char *ea;
d129 1
a129 5
readudp(d, pkt, len, tleft)
	register struct iodesc *d;
	register void *pkt;
	register size_t len;
	time_t tleft;
d131 5
a135 5
	register ssize_t n;
	register size_t hlen;
	register struct ip *ip;
	register struct udphdr *uh;
	register struct udpiphdr *ui;
d272 4
a275 8
sendrecv(d, sproc, sbuf, ssize, rproc, rbuf, rsize)
	register struct iodesc *d;
	register ssize_t (*sproc)(struct iodesc *, void *, size_t);
	register void *sbuf;
	register size_t ssize;
	register ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t);
	register void *rbuf;
	register size_t rsize;
d277 2
a278 2
	register ssize_t cc;
	register time_t t, tmo, tlast;
d325 1
a325 2
inet_addr(cp)
	char *cp;
d327 3
a329 3
	register u_long val;
	register int n;
	register char c;
d331 1
a331 1
	register u_int *pp = parts;
d402 1
a402 2
inet_ntoa(ia)
	struct in_addr ia;
d409 1
a409 2
intoa(addr)
	register n_long addr;
d411 3
a413 3
	register char *cp;
	register u_int byte;
	register int n;
d439 1
a439 3
number(s, n)
	char *s;
	int *n;
d447 1
a447 2
ip_convertaddr(p)
	char *p;
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.10 1998/05/31 23:39:15 mickey Exp $	*/
d75 1
a75 1
 	if (debug) {
@


1.10
log
@cleanup for  !ANSI compilers, mostly __P usage
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.9 1998/02/23 20:32:27 niklas Exp $	*/
d281 1
a281 1
	register ssize_t (*sproc) __P((struct iodesc *, void *, size_t));
d284 1
a284 1
	register ssize_t (*rproc) __P((struct iodesc *, void *, size_t, time_t));
@


1.10.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.10 1998/05/31 23:39:15 mickey Exp $	*/
d281 1
a281 1
	register ssize_t (*sproc)(struct iodesc *, void *, size_t);
d284 1
a284 1
	register ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t);
@


1.10.8.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d281 1
a281 1
	register ssize_t (*sproc)(struct iodesc *, void *, size_t);
d284 1
a284 1
	register ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t);
@


1.10.8.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.10.8.1 2002/03/28 15:02:00 niklas Exp $	*/
d75 1
a75 1
	if (debug) {
@


1.10.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 4
a65 1
sendudp(struct iodesc *d, void *pkt, size_t len)
d67 5
a71 5
	ssize_t cc;
	struct ip *ip;
	struct udpiphdr *ui;
	struct udphdr *uh;
	u_char *ea;
d132 5
a136 1
readudp(struct iodesc *d, void *pkt, size_t len, time_t tleft)
d138 5
a142 5
	ssize_t n;
	size_t hlen;
	struct ip *ip;
	struct udphdr *uh;
	struct udpiphdr *ui;
d279 8
a286 4
sendrecv(struct iodesc *d, ssize_t (*sproc)(struct iodesc *, void *, size_t),
    void *sbuf, size_t ssize,
    ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t),
    void *rbuf, size_t rsize)
d288 2
a289 2
	ssize_t cc;
	time_t t, tmo, tlast;
d336 2
a337 1
inet_addr(char *cp)
d339 3
a341 3
	u_long val;
	int n;
	char c;
d343 1
a343 1
	u_int *pp = parts;
d414 2
a415 1
inet_ntoa(struct in_addr ia)
d422 2
a423 1
intoa(n_long addr)
d425 3
a427 3
	char *cp;
	u_int byte;
	int n;
d453 3
a455 1
number(char *s, int *n)
d463 2
a464 1
ip_convertaddr(char *p)
@


1.9
log
@strong signedness typing a version of egcs I tried months ago wanted
me to fix.  I am not sure these are necessary for gas 2.8 but I figure I
would commit them anyhow.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.8 1997/05/05 02:49:49 millert Exp $	*/
d281 1
a281 1
	register ssize_t (*sproc)(struct iodesc *, void *, size_t);
d284 1
a284 1
	register ssize_t (*rproc)(struct iodesc *, void *, size_t, time_t);
@


1.8
log
@ssize_t is long on alpha, not int so cast to long in printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.7 1996/12/08 15:15:51 niklas Exp $	*/
d120 1
a120 1
	if (cc == -1)
d122 1
a122 1
	if (cc != len)
d155 1
a155 1
	if (n == -1 || n < sizeof(*ip) + sizeof(*uh))
d307 1
a307 1
			if (cc == -1 || cc < ssize)
@


1.7
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.6 1996/10/16 14:24:08 mickey Exp $	*/
d233 1
a233 1
			printf("readudp: huge packet, udp len %d\n", n);
@


1.6
log
@back up last change, it's wrong.
@
text
@d1 2
a2 2
/*	$OpenBSD: net.c,v 1.5 1996/10/16 11:04:38 mickey Exp $	*/
/*	$NetBSD: net.c,v 1.12 1995/12/13 23:38:10 pk Exp $	*/
d79 1
a79 1
				inet_ntoa(d->myip), ntohs(d->myport));
d81 1
a81 1
				inet_ntoa(d->destip), ntohs(d->destport));
@


1.5
log
@fix debug code, automatize buffer size calculation.
@
text
@d1 1
a1 1
/*	$OpenBSD: net.c,v 1.4 1996/09/23 14:18:57 mickey Exp $	*/
a59 6
#if defined(ARP_DEBUG) || defined(NET_DEBUG) || defined(BOOTP_DEBUG) || \
    defined(ETHER_DEBUG) || defined(NETIF_DEBUG) || defined(NFS_DEBUG) || \
    defined(RPC_DEBUG)
int net_debug = 0;
#endif

d75 1
a75 1
 	if (net_debug) {
d147 1
a147 1
	if (net_debug)
d172 1
a172 1
		if (net_debug)
d182 1
a182 1
		if (net_debug)
d192 1
a192 1
		if (net_debug)
d200 1
a200 1
		if (net_debug)
d207 1
a207 1
		if (net_debug) {
d223 1
a223 1
		if (net_debug)
d244 1
a244 1
			if (net_debug)
d257 1
a257 1
		if (net_debug)
d293 1
a293 1
	if (net_debug)
@


1.4
log
@add OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a45 2
#include <string.h>

d60 6
d81 1
a81 1
 	if (debug) {
d153 1
a153 1
	if (debug)
d178 1
a178 1
		if (debug)
d188 1
a188 1
		if (debug)
d198 1
a198 1
		if (debug)
d206 1
a206 1
		if (debug)
d213 1
a213 1
		if (debug) {
d229 1
a229 1
		if (debug)
d250 1
a250 1
			if (debug)
d263 1
a263 1
		if (debug)
d299 1
a299 1
	if (debug)
d434 1
a434 1
	static char buf[17];	/* strlen(".255.255.255.255") + 1 */
@


1.3
log
@fix makefiles. cleanup, addopt for boot.
@
text
@d1 1
@


1.2
log
@from netbsd:
Make `time difference' a signed quantity explicitly.
bzero entire structures instead of explicitly storing 0's.
@
text
@d48 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: net.c,v 1.9 1995/09/23 17:14:40 thorpej Exp $	*/
d108 1
a108 3
	ui->ui_next = 0;
	ui->ui_prev = 0;
	ui->ui_x1 = 0;
d240 1
a240 3
		ui->ui_next = 0;
		ui->ui_prev = 0;
		ui->ui_x1 = 0;
d289 2
a290 1
	register time_t t, tmo, tlast, tleft;
d302 1
a302 1
			if (tmo == MAXTMO) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
