head	1.63;
access;
symbols
	OPENBSD_6_2:1.63.0.2
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.63.0.4
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.62.0.4
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.55.0.4
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.52.0.4
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.52
	OPENBSD_5_1:1.52.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.46.0.10
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.46.0.12
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.46.0.8
	OPENBSD_4_5_BASE:1.46
	OPENBSD_4_4:1.46.0.6
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.46.0.4
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.45.0.2
	OPENBSD_4_1_BASE:1.45
	OPENBSD_4_0:1.44.0.4
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.43.0.8
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.43.0.6
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.43.0.4
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.43
	SMP_SYNC_B:1.43
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.39
	OPENBSD_3_3:1.39.0.6
	OPENBSD_3_3_BASE:1.39
	OPENBSD_3_2:1.39.0.4
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	UBC_SYNC_B:1.39
	UBC:1.35.0.18
	UBC_BASE:1.35
	OPENBSD_3_0:1.35.0.16
	OPENBSD_3_0_BASE:1.35
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.14
	OPENBSD_2_8:1.35.0.12
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.35.0.10
	OPENBSD_2_7_BASE:1.35
	SMP:1.35.0.8
	SMP_BASE:1.35
	kame_19991208:1.35
	OPENBSD_2_6:1.35.0.6
	OPENBSD_2_6_BASE:1.35
	OPENBSD_2_5:1.35.0.4
	OPENBSD_2_5_BASE:1.35
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.30.0.2
	OPENBSD_2_2_BASE:1.30
	OPENBSD_2_1:1.23.0.2
	OPENBSD_2_1_BASE:1.23
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.63
date	2016.08.27.04.57.30;	author guenther;	state Exp;
branches;
next	1.62;
commitid	sA2S1vSeNUcNpFnH;

1.62
date	2015.11.16.19.33.52;	author miod;	state Exp;
branches;
next	1.61;
commitid	5gnqUR6VheSiU9SF;

1.61
date	2015.09.02.01.52.26;	author yasuoka;	state Exp;
branches;
next	1.60;
commitid	CUwlbzT4LejFC15d;

1.60
date	2015.02.05.12.56.50;	author millert;	state Exp;
branches;
next	1.59;
commitid	gpw9rrPq4I7YVCpc;

1.59
date	2014.11.19.20.28.56;	author miod;	state Exp;
branches;
next	1.58;
commitid	F3EvOaAgKQy5tMAq;

1.58
date	2014.07.13.09.26.08;	author jasper;	state Exp;
branches;
next	1.57;
commitid	Cnjup0HpCIRrcQ6o;

1.57
date	2014.07.12.21.54.58;	author jasper;	state Exp;
branches;
next	1.56;
commitid	3HeD4LaLGiS22I3y;

1.56
date	2013.12.28.02.51.07;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2013.01.07.20.02.11;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.05.23.20.23;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2012.10.09.12.03.51;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2011.09.20.22.26.53;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.06.22.51.46;	author jasper;	state Exp;
branches;
next	1.49;

1.49
date	2010.12.06.22.11.01;	author jasper;	state Exp;
branches;
next	1.48;

1.48
date	2010.12.06.18.44.49;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.09.15.30.28;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.04.21.44.07;	author reyk;	state Exp;
branches;
next	1.45;

1.45
date	2006.09.18.21.12.57;	author mpf;	state Exp;
branches;
next	1.44;

1.44
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.03.14.08.53;	author espie;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.23.28.09;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.01.17.00.33;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.15.18.19.52;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.03.16.10;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2002.03.02.09.31.45;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	98.07.29.00.38.36;	author mickey;	state Exp;
branches
	1.35.8.1
	1.35.18.1;
next	1.34;

1.34
date	98.07.13.04.02.25;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	98.05.31.23.39.14;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	98.05.29.20.44.47;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	98.02.24.22.14.44;	author weingart;	state Exp;
branches;
next	1.30;

1.30
date	97.10.07.07.59.58;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.08.13.14.18.10;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	97.08.12.21.28.39;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.08.04.20.31.21;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.07.17.23.07.22;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.05.30.23.09.10;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.05.30.23.06.28;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.04.26.17.50.08;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.04.21.19.49.30;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.03.31.23.47.04;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.02.16.14.49.05;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.02.07.07.08.12;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.02.06.02.56.47;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	97.01.17.07.28.15;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	96.12.12.08.16.30;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	96.12.08.15.15.57;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.11.27.11.59.43;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	96.10.29.07.59.29;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.10.23.09.02.54;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.17.06.49.58;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.10.16.13.24.07;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.10.16.11.32.08;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.10.15.09.58.40;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.15.09.41.56;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.23.14.19.04;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.09.23.13.28.41;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.09.18.14.40.12;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.01.15.01.07.15;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.07.03.27.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches;
next	;

1.35.8.1
date	2002.03.06.02.13.24;	author niklas;	state Exp;
branches;
next	1.35.8.2;

1.35.8.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.35.8.3;

1.35.8.3
date	2003.06.07.11.03.42;	author ho;	state Exp;
branches;
next	1.35.8.4;

1.35.8.4
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.35.18.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Declare lseek() instead of assuming it'll be provided elsewhere

ok deraadt@@
@
text
@/*	$OpenBSD: stand.h,v 1.62 2015/11/16 19:33:52 miod Exp $	*/
/*	$NetBSD: stand.h,v 1.18 1996/11/30 04:35:51 gwr Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)stand.h	8.1 (Berkeley) 6/11/93
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <sys/stdarg.h>
#include <sys/stdint.h>
#include "saerrno.h"

#ifndef NULL
#define	NULL	0
#endif

struct open_file;

/*
 * Useful macros
 */
/* don't define if libkern included */
#ifndef LIBKERN_INLINE
#define	max(a,b)	(((a)>(b))? (a) : (b))
#define	min(a,b)	(((a)>(b))? (b) : (a))
#endif

/*
 * This structure is used to define file system operations in a file system
 * independent way.
 */
struct fs_ops {
	int	(*open)(char *path, struct open_file *f);
	int	(*close)(struct open_file *f);
	int	(*read)(struct open_file *f, void *buf,
		    size_t size, size_t *resid);
	int	(*write)(struct open_file *f, void *buf,
		    size_t size, size_t *resid);
	off_t	(*seek)(struct open_file *f, off_t offset, int where);
	int	(*stat)(struct open_file *f, struct stat *sb);
	int	(*readdir)(struct open_file *f, char *);
};

extern struct fs_ops file_system[];
extern int nfsys;

/* where values for lseek(2) */
#define	SEEK_SET	0	/* set file offset to offset */
#define	SEEK_CUR	1	/* set file offset to current plus offset */
#define	SEEK_END	2	/* set file offset to EOF plus offset */

/* Device switch */
struct devsw {
	char	*dv_name;
	int	(*dv_strategy)(void *devdata, int rw,
				    daddr32_t blk, size_t size,
				    void *buf, size_t *rsize);
	int	(*dv_open)(struct open_file *f, ...);
	int	(*dv_close)(struct open_file *f);
	int	(*dv_ioctl)(struct open_file *f, u_long cmd, void *data);
};

extern struct devsw devsw[];	/* device array */
extern int ndevs;		/* number of elements in devsw[] */

extern struct consdev *cn_tab;

struct open_file {
	int		f_flags;	/* see F_* below */
	struct devsw	*f_dev;		/* pointer to device operations */
	void		*f_devdata;	/* device specific data */
	struct fs_ops	*f_ops;		/* pointer to file system operations */
	void		*f_fsdata;	/* file system specific data */
	off_t		f_offset;	/* current file offset (F_RAW) */
};

#define	SOPEN_MAX	4
extern struct open_file files[];

/* f_flags values */
#define	F_READ		0x0001	/* file opened for reading */
#define	F_WRITE		0x0002	/* file opened for writing */
#define	F_RAW		0x0004	/* raw device open - no file system */
#define F_NODEV		0x0008	/* network open - no device */

#define isupper(c)	((c) >= 'A' && (c) <= 'Z')
#define islower(c)	((c) >= 'a' && (c) <= 'z')
#define isalpha(c)	(isupper(c)||islower(c))
#define tolower(c)	(isupper(c)?((c) - 'A' + 'a'):(c))
#define toupper(c)	(islower(c)?((c) - 'a' + 'A'):(c))
#define isspace(c)	((c) == ' ' || (c) == '\t')
#define isdigit(c)	((c) >= '0' && (c) <= '9')

#define	btochs(b,c,h,s,nh,ns)			\
	c = (b) / ((nh) * (ns));		\
	h = ((b) % ((nh) * (ns))) / (ns);	\
	s = ((b) % ((nh) * (ns))) % (ns);

void	*alloc(u_int);
void	free(void *, u_int);
struct	disklabel;
char	*getdisklabel(const char *, struct disklabel *);
u_int	dkcksum(const struct disklabel *);

#define BOOTRANDOM	"/etc/random.seed"
#define BOOTRANDOM_MAX	512
extern char rnddata[BOOTRANDOM_MAX];

void	printf(const char *, ...);
int	snprintf(char *, size_t, const char *, ...);
void	vprintf(const char *, __va_list);
void	twiddle(void);
void	getln(char *, size_t);
__dead void	panic(const char *, ...) __attribute__((noreturn));
__dead void	_rtt(void) __attribute__((noreturn));
#define	bzero(s,n)	((void)memset((s),0,(n)))
#define bcmp(s1,s2,n)	(memcmp((s2),(s1),(n)))
#define	bcopy(s1,s2,n)	((void)memcpy((s2),(s1),(n)))
void	explicit_bzero(void *, size_t);
void	*memcpy(void *, const void *, size_t);
int	memcmp(const void *, const void *, size_t);
char	*strncpy(char *, const char *, size_t);
int	strncmp(const char *, const char *, size_t);
int	strcmp(const char *, const char *);
size_t	strlen(const char *);
long	strtol(const char *, char **, int);
long long	strtoll(const char *, char **, int);
char	*strchr(const char *, int);
void	*memset(void *, int, size_t);
void	exit(void);
int	open(const char *, int);
int	close(int);
void	closeall(void);
ssize_t	read(int, void *, size_t);
ssize_t	write(int, void *, size_t);
int	stat(const char *path, struct stat *sb);
int	fstat(int fd, struct stat *sb);
off_t	lseek(int, off_t, int);
int	opendir(const char *);
int	readdir(int, char *);
void	closedir(int);
int	nodev(void);
int	noioctl(struct open_file *, u_long, void *);
void	nullsys(void);

int	null_open(char *path, struct open_file *f);
int	null_close(struct open_file *f);
ssize_t	null_read(struct open_file *f, void *buf, size_t size, size_t *resid);
ssize_t	null_write(struct open_file *f, void *buf, size_t size, size_t *resid);
off_t	null_seek(struct open_file *f, off_t offset, int where);
int	null_stat(struct open_file *f, struct stat *sb);
int	null_readdir(struct open_file *f, char *name);
char	*ttyname(int); /* match userland decl, but ignore !0 */
dev_t	ttydev(char *);
void	cninit(void);
int	cnset(dev_t);
void	cnputc(int);
int	cngetc(void);
int	cnischar(void);
int	cnspeed(dev_t, int);
u_int	sleep(u_int);
void	usleep(u_int);
char	*ctime(const time_t *);

int	ioctl(int, u_long, char *);

void	putchar(int);
int	getchar(void);

#ifdef __INTERNAL_LIBSA_CREAD
int	oopen(const char *, int);
int	oclose(int);
ssize_t	oread(int, void *, size_t);
off_t	olseek(int, off_t, int);
#endif

/* Machine dependent functions */
int	devopen(struct open_file *, const char *, char **);
void	machdep_start(char *, int, char *, char *, char *);
time_t	getsecs(void);
@


1.62
log
@Replace unbounded gets() in libsa with getln() which takes a buffer size,
and convert all gets() users.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.61 2015/09/02 01:52:26 yasuoka Exp $	*/
d166 1
@


1.61
log
@Initial commit of uefi boot loader of OpenBSD.

ok deraadt yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.60 2015/02/05 12:56:50 millert Exp $	*/
d141 1
a141 1
void	gets(char *);
@


1.60
log
@Include sys/stdint.h for SIZE_MAX.  OK deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.59 2014/11/19 20:28:56 miod Exp $	*/
a127 1
void	*alloca(size_t);
@


1.59
log
@Sprinkle const whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.58 2014/07/13 09:26:08 jasper Exp $	*/
d38 1
@


1.58
log
@move putchar() into libsa

"sure" miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.57 2014/07/12 21:54:58 jasper Exp $	*/
d131 1
a131 1
u_int	dkcksum(struct disklabel *);
d166 1
a166 1
int	opendir(char *);
@


1.57
log
@move getchar() into libsa where applicable

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.56 2013/12/28 02:51:07 deraadt Exp $	*/
a187 1
int	getchar(void);
@


1.56
log
@Try to load entropy data from disk:/etc/random.seed, and additionally
use a MD-supplied random function.  Then, insert this into the ELF
openbsd.randomdata of the kernel, so that it has entropy right from
the start.  Some help from jsing for the softraid aspects.
Also tested by phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.55 2013/01/07 20:02:11 miod Exp $	*/
d188 1
@


1.55
log
@Move exec() libsa prototype to hp300 stand, now that it can no longer be
found in libsa.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.54 2012/12/05 23:20:23 deraadt Exp $	*/
d132 4
@


1.54
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.53 2012/10/09 12:03:51 jsing Exp $	*/
a153 1
void	exec(char *, void *, int);
@


1.53
log
@Provide an explicit_bzero for standalone usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.51 2011/03/13 00:13:53 deraadt Exp $	*/
a35 1
#include <sys/cdefs.h>
@


1.52
log
@Oops, forgot to remove that reference to now dead saioctl.h
@
text
@d144 1
d173 2
a174 4
ssize_t	null_read(struct open_file *f, void *buf,
			size_t size, size_t *resid);
ssize_t	null_write(struct open_file *f, void *buf,
			size_t size, size_t *resid);
d188 1
a188 1
char *ctime(const time_t *);
a205 1

@


1.51
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.50 2010/12/06 22:51:46 jasper Exp $	*/
a38 1
#include "saioctl.h"
@


1.50
log
@- properly remove NENTS now after fixing the fallout.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.49 2010/12/06 22:11:01 jasper Exp $	*/
d85 1
a85 1
				    daddr_t blk, size_t size,
@


1.49
log
@- partially revert previous NENTS removal for arches which got busted.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.48 2010/12/06 18:44:49 jasper Exp $	*/
a50 1
#define NENTS(x)	sizeof(x)/sizeof(x[0])
@


1.48
log
@- drop NENTS(), which was yet another copy of nitems().
no binary change


ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.47 2010/05/09 15:30:28 jsg Exp $	*/
d51 1
@


1.47
log
@shuffle an extern around so gcc4 doesn't whinge about incomplete types
as suggested by miod.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.46 2007/05/04 21:44:07 reyk Exp $	*/
a50 1
#define NENTS(x)	sizeof(x)/sizeof(x[0])
@


1.46
log
@remove strcpy and strcat from the kernel; they are dead and unused code.

(OpenBSD does not use strcat/strcpy in the kernel, if people do it in
external modules they should update their code)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.45 2006/09/18 21:12:57 mpf Exp $	*/
a95 1
extern struct consdev constab[];
@


1.45
log
@Import a slightly stripped down strtoll(3) from stdlib
into libsa as it is needed for boot(8) > 4G support.
With help from mickey@@
i386 and amd64 tests by me, alpha test by mickey@@
OK mickey@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.44 2006/01/06 18:53:05 millert Exp $	*/
a149 1
char	*strcpy(char *, const char *);
@


1.44
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.43 2004/01/03 14:08:53 espie Exp $	*/
d155 1
@


1.43
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.42 2003/08/11 06:23:09 deraadt Exp $	*/
d139 1
a139 1
void	vprintf(const char *, _BSD_VA_LIST_);
@


1.42
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.41 2003/06/02 23:28:09 millert Exp $	*/
d38 1
a38 1
#include <machine/stdarg.h>
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.40 2003/06/01 17:00:33 deraadt Exp $	*/
d66 1
a66 1
			     size_t size, size_t *resid);
d68 1
a68 1
			     size_t size, size_t *resid);
d193 2
@


1.40
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.39 2002/03/15 18:19:52 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.39
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.38 2002/03/14 03:16:10 millert Exp $	*/
d142 1
a142 1
void	sprintf(char *, const char *, ...);
d198 1
a198 1
void	putchar(int);    
@


1.38
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.37 2002/03/14 01:27:07 millert Exp $	*/
a41 1
#ifdef __STDC__
a42 3
#else
#include <machine/varargs.h>
#endif
@


1.37
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.36 2002/03/02 09:31:45 miod Exp $	*/
d156 1
a156 1
int	memcmp(const void *, const void*, size_t);
@


1.36
log
@Add a strcmp() prototype, which will be needed shortly.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.35 1998/07/29 00:38:36 mickey Exp $	*/
d71 9
a79 9
	int	(*open) __P((char *path, struct open_file *f));
	int	(*close) __P((struct open_file *f));
	int	(*read) __P((struct open_file *f, void *buf,
			     size_t size, size_t *resid));
	int	(*write) __P((struct open_file *f, void *buf,
			     size_t size, size_t *resid));
	off_t	(*seek) __P((struct open_file *f, off_t offset, int where));
	int	(*stat) __P((struct open_file *f, struct stat *sb));
	int	(*readdir) __P((struct open_file *f, char *));
d93 1
a93 1
	int	(*dv_strategy) __P((void *devdata, int rw,
d95 4
a98 4
				    void *buf, size_t *rsize));
	int	(*dv_open) __P((struct open_file *f, ...));
	int	(*dv_close) __P((struct open_file *f));
	int	(*dv_ioctl) __P((struct open_file *f, u_long cmd, void *data));
d138 3
a140 3
void	*alloc __P((u_int));
void	*alloca __P((size_t));
void	free __P((void *, u_int));
d142 2
a143 2
char	*getdisklabel __P((const char *, struct disklabel *));
u_int	dkcksum __P((struct disklabel *));
d145 7
a151 7
void	printf __P((const char *, ...));
void	sprintf __P((char *, const char *, ...));
void	vprintf __P((const char *, _BSD_VA_LIST_));
void	twiddle __P((void));
void	gets __P((char *));
__dead void	panic __P((const char *, ...)) __attribute__((noreturn));
__dead void	_rtt __P((void)) __attribute__((noreturn));
d155 46
a200 46
void	*memcpy __P((void *, const void *, size_t));
int	memcmp __P((const void *, const void*, size_t));
char	*strncpy __P((char *, const char *, size_t));
char	*strcpy __P((char *, const char *));
int	strncmp __P((const char *, const char *, size_t));
int	strcmp __P((const char *, const char *));
size_t	strlen __P((const char *));
long	strtol __P((const char *, char **, int));
char	*strchr __P((const char *, int));
void	*memset __P((void *, int, size_t));
void	exec __P((char *, void *, int));
void	exit __P((void));
int	open __P((const char *, int));
int	close __P((int));
void	closeall __P((void));
ssize_t	read __P((int, void *, size_t));
ssize_t	write __P((int, void *, size_t));
int	stat __P((const char *path, struct stat *sb));
int	fstat __P((int fd, struct stat *sb));
int	opendir __P((char *));
int	readdir __P((int, char *));
void	closedir __P((int));
int	nodev __P((void));
int	noioctl __P((struct open_file *, u_long, void *));
void	nullsys __P((void));

int	null_open __P((char *path, struct open_file *f));
int	null_close __P((struct open_file *f));
ssize_t	null_read __P((struct open_file *f, void *buf,
			size_t size, size_t *resid));
ssize_t	null_write __P((struct open_file *f, void *buf,
			size_t size, size_t *resid));
off_t	null_seek __P((struct open_file *f, off_t offset, int where));
int	null_stat __P((struct open_file *f, struct stat *sb));
int	null_readdir __P((struct open_file *f, char *name));
char	*ttyname __P((int)); /* match userland decl, but ignore !0 */
dev_t	ttydev __P((char *));
void	cninit __P((void));
int	cnset __P((dev_t));
void	cnputc __P((int));
int	cngetc __P((void));
int	cnischar __P((void));
int	cnspeed __P((dev_t, int));
u_int	sleep __P((u_int));
void	usleep __P((u_int));
char *ctime __P((const time_t *));
d202 2
a203 2
void	putchar __P((int));    
int	getchar __P((void));
d206 4
a209 4
int	oopen __P((const char *, int));
int	oclose __P((int));
ssize_t	oread __P((int, void *, size_t));
off_t	olseek __P((int, off_t, int));
d213 3
a215 3
int	devopen __P((struct open_file *, const char *, char **));
void	machdep_start __P((char *, int, char *, char *, char *));
time_t	getsecs __P((void));
@


1.35
log
@add strchr proto
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.34 1998/07/13 04:02:25 mickey Exp $	*/
d160 1
@


1.35.18.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.35 1998/07/29 00:38:36 mickey Exp $	*/
d42 1
d44 3
d71 9
a79 9
	int	(*open)(char *path, struct open_file *f);
	int	(*close)(struct open_file *f);
	int	(*read)(struct open_file *f, void *buf,
			     size_t size, size_t *resid);
	int	(*write)(struct open_file *f, void *buf,
			     size_t size, size_t *resid);
	off_t	(*seek)(struct open_file *f, off_t offset, int where);
	int	(*stat)(struct open_file *f, struct stat *sb);
	int	(*readdir)(struct open_file *f, char *);
d93 1
a93 1
	int	(*dv_strategy)(void *devdata, int rw,
d95 4
a98 4
				    void *buf, size_t *rsize);
	int	(*dv_open)(struct open_file *f, ...);
	int	(*dv_close)(struct open_file *f);
	int	(*dv_ioctl)(struct open_file *f, u_long cmd, void *data);
d138 3
a140 3
void	*alloc(u_int);
void	*alloca(size_t);
void	free(void *, u_int);
d142 2
a143 2
char	*getdisklabel(const char *, struct disklabel *);
u_int	dkcksum(struct disklabel *);
d145 7
a151 7
void	printf(const char *, ...);
void	sprintf(char *, const char *, ...);
void	vprintf(const char *, _BSD_VA_LIST_);
void	twiddle(void);
void	gets(char *);
__dead void	panic(const char *, ...) __attribute__((noreturn));
__dead void	_rtt(void) __attribute__((noreturn));
d155 45
a199 46
void	*memcpy(void *, const void *, size_t);
int	memcmp(const void *, const void *, size_t);
char	*strncpy(char *, const char *, size_t);
char	*strcpy(char *, const char *);
int	strncmp(const char *, const char *, size_t);
int	strcmp(const char *, const char *);
size_t	strlen(const char *);
long	strtol(const char *, char **, int);
char	*strchr(const char *, int);
void	*memset(void *, int, size_t);
void	exec(char *, void *, int);
void	exit(void);
int	open(const char *, int);
int	close(int);
void	closeall(void);
ssize_t	read(int, void *, size_t);
ssize_t	write(int, void *, size_t);
int	stat(const char *path, struct stat *sb);
int	fstat(int fd, struct stat *sb);
int	opendir(char *);
int	readdir(int, char *);
void	closedir(int);
int	nodev(void);
int	noioctl(struct open_file *, u_long, void *);
void	nullsys(void);

int	null_open(char *path, struct open_file *f);
int	null_close(struct open_file *f);
ssize_t	null_read(struct open_file *f, void *buf,
			size_t size, size_t *resid);
ssize_t	null_write(struct open_file *f, void *buf,
			size_t size, size_t *resid);
off_t	null_seek(struct open_file *f, off_t offset, int where);
int	null_stat(struct open_file *f, struct stat *sb);
int	null_readdir(struct open_file *f, char *name);
char	*ttyname(int); /* match userland decl, but ignore !0 */
dev_t	ttydev(char *);
void	cninit(void);
int	cnset(dev_t);
void	cnputc(int);
int	cngetc(void);
int	cnischar(void);
int	cnspeed(dev_t, int);
u_int	sleep(u_int);
void	usleep(u_int);
char *ctime(const time_t *);
d201 2
a202 2
void	putchar(int);    
int	getchar(void);
d205 4
a208 4
int	oopen(const char *, int);
int	oclose(int);
ssize_t	oread(int, void *, size_t);
off_t	olseek(int, off_t, int);
d212 3
a214 3
int	devopen(struct open_file *, const char *, char **);
void	machdep_start(char *, int, char *, char *, char *);
time_t	getsecs(void);
@


1.35.8.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a159 1
int	strcmp __P((const char *, const char *));
@


1.35.8.2
log
@Merge in -current from roughly a week ago
@
text
@d42 1
d44 3
d71 9
a79 9
	int	(*open)(char *path, struct open_file *f);
	int	(*close)(struct open_file *f);
	int	(*read)(struct open_file *f, void *buf,
			     size_t size, size_t *resid);
	int	(*write)(struct open_file *f, void *buf,
			     size_t size, size_t *resid);
	off_t	(*seek)(struct open_file *f, off_t offset, int where);
	int	(*stat)(struct open_file *f, struct stat *sb);
	int	(*readdir)(struct open_file *f, char *);
d93 1
a93 1
	int	(*dv_strategy)(void *devdata, int rw,
d95 4
a98 4
				    void *buf, size_t *rsize);
	int	(*dv_open)(struct open_file *f, ...);
	int	(*dv_close)(struct open_file *f);
	int	(*dv_ioctl)(struct open_file *f, u_long cmd, void *data);
d138 3
a140 3
void	*alloc(u_int);
void	*alloca(size_t);
void	free(void *, u_int);
d142 2
a143 2
char	*getdisklabel(const char *, struct disklabel *);
u_int	dkcksum(struct disklabel *);
d145 7
a151 7
void	printf(const char *, ...);
void	sprintf(char *, const char *, ...);
void	vprintf(const char *, _BSD_VA_LIST_);
void	twiddle(void);
void	gets(char *);
__dead void	panic(const char *, ...) __attribute__((noreturn));
__dead void	_rtt(void) __attribute__((noreturn));
d155 46
a200 46
void	*memcpy(void *, const void *, size_t);
int	memcmp(const void *, const void *, size_t);
char	*strncpy(char *, const char *, size_t);
char	*strcpy(char *, const char *);
int	strncmp(const char *, const char *, size_t);
int	strcmp(const char *, const char *);
size_t	strlen(const char *);
long	strtol(const char *, char **, int);
char	*strchr(const char *, int);
void	*memset(void *, int, size_t);
void	exec(char *, void *, int);
void	exit(void);
int	open(const char *, int);
int	close(int);
void	closeall(void);
ssize_t	read(int, void *, size_t);
ssize_t	write(int, void *, size_t);
int	stat(const char *path, struct stat *sb);
int	fstat(int fd, struct stat *sb);
int	opendir(char *);
int	readdir(int, char *);
void	closedir(int);
int	nodev(void);
int	noioctl(struct open_file *, u_long, void *);
void	nullsys(void);

int	null_open(char *path, struct open_file *f);
int	null_close(struct open_file *f);
ssize_t	null_read(struct open_file *f, void *buf,
			size_t size, size_t *resid);
ssize_t	null_write(struct open_file *f, void *buf,
			size_t size, size_t *resid);
off_t	null_seek(struct open_file *f, off_t offset, int where);
int	null_stat(struct open_file *f, struct stat *sb);
int	null_readdir(struct open_file *f, char *name);
char	*ttyname(int); /* match userland decl, but ignore !0 */
dev_t	ttydev(char *);
void	cninit(void);
int	cnset(dev_t);
void	cnputc(int);
int	cngetc(void);
int	cnischar(void);
int	cnspeed(dev_t, int);
u_int	sleep(u_int);
void	usleep(u_int);
char *ctime(const time_t *);
d202 2
a203 2
void	putchar(int);    
int	getchar(void);
d206 4
a209 4
int	oopen(const char *, int);
int	oclose(int);
ssize_t	oread(int, void *, size_t);
off_t	olseek(int, off_t, int);
d213 3
a215 3
int	devopen(struct open_file *, const char *, char **);
void	machdep_start(char *, int, char *, char *, char *);
time_t	getsecs(void);
@


1.35.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.35.8.2 2002/03/28 15:02:00 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d142 1
a142 1
int	snprintf(char *, size_t, const char *, ...);
d198 1
a198 1
void	putchar(int);
@


1.35.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 1
#include <sys/stdarg.h>
d66 1
a66 1
		    size_t size, size_t *resid);
d68 1
a68 1
		    size_t size, size_t *resid);
a192 2

int	ioctl(int, u_long, char *);
@


1.34
log
@add alloca, hope none would get hurt, since none but i386 use it
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.33 1998/05/31 23:39:14 mickey Exp $	*/
d162 1
@


1.33
log
@cleanup for  !ANSI compilers, mostly __P usage
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.32 1998/05/29 20:44:47 mickey Exp $	*/
d138 3
a140 2
void	*alloc __P((unsigned int));
void	free __P((void *, unsigned int));
@


1.32
log
@add ctime(3) for certain archs usage
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.31 1998/02/24 22:14:44 weingart Exp $	*/
d42 1
d44 3
@


1.31
log
@Prototype strtol()
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.30 1997/10/07 07:59:58 mickey Exp $	*/
d193 1
@


1.30
log
@let's keep it MI; 10x phil for the MD implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.29 1997/08/13 14:18:10 niklas Exp $	*/
d156 1
@


1.29
log
@Add console switching logic
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.28 1997/08/12 21:28:39 mickey Exp $	*/
d189 1
@


1.28
log
@new, like dev/cninit.c+cons.c
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.27 1997/08/04 20:31:21 mickey Exp $	*/
a181 1
int	cons_probe __P((void));
d183 1
d185 1
@


1.27
log
@do consdev
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.26 1997/07/17 23:07:22 mickey Exp $	*/
d100 2
a101 11
struct consw {
	char	*name;	/* console driver name */
	int	(*cn_probe) __P((void));	/* probe device for presence */
	void	(*cn_putc) __P((int c));	/* print char */
	int	(*cn_getc) __P((void));		/* read char */
	int	(*cn_ischar) __P((void));	/* check input */
};

extern const struct consw consw[];
extern const int ncons;
extern int consdev;
d184 4
a187 3
void	putc __P((int));    
int	getc __P((void));
int	ischar __P((void));
@


1.26
log
@use const where appropriate (;
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.25 1997/05/30 23:09:10 mickey Exp $	*/
d110 1
@


1.25
log
@sleep returns u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.24 1997/05/30 23:06:28 mickey Exp $	*/
d108 2
a109 2
extern struct consw consw[];
extern int ncons;
@


1.24
log
@sleep/usleep prototypes (others may need 'em too, btw
strncmp prototype in stand.h
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.23 1997/04/26 17:50:08 mickey Exp $	*/
d195 1
a195 1
void	sleep __P((u_int));
@


1.23
log
@boot.conf support
ttyname function in cons.c
rdonly var 'tty' to view tty settings
serial console soon
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.22 1997/04/21 19:49:30 mickey Exp $	*/
d162 1
d195 2
@


1.22
log
@exit()
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.21 1997/03/31 23:47:04 mickey Exp $	*/
d190 1
@


1.21
log
@strlen proto
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.20 1997/02/16 14:49:05 mickey Exp $	*/
d165 1
@


1.20
log
@missed prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.19 1997/02/07 07:08:12 mickey Exp $	*/
d162 1
@


1.19
log
@machdep_start, not muchdep_exec
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.18 1997/02/06 02:56:47 downsj Exp $	*/
d171 3
a173 1
int	readdir __P((int fd, char *));
@


1.18
log
@Add libz and make libsa aware of it.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.17 1997/01/17 07:28:15 downsj Exp $	*/
d56 1
a56 1
/* don't define if libker included */
a163 1
void	execz __P((void *, void *, int));
d171 1
a171 2
ssize_t	zread __P((int, void *, size_t));	/* for execz */
    
d185 4
d202 1
a202 1
void	machdep_exec __P((char *, int, char *, char *, char *));
a203 3
void	putc __P((int));    
int	getc __P((void));
int	ischar __P((void));
@


1.17
log
@sys/stat.h gets included here, and STAYS included here, thank you
very much.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.16 1996/12/12 08:16:30 mickey Exp $	*/
d190 7
@


1.16
log
@safe to{lower,upper} macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.15 1996/12/08 15:15:57 niklas Exp $	*/
d41 1
a50 1
struct stat;
@


1.15
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.14 1996/11/27 11:59:43 mickey Exp $	*/
d131 3
a133 3
#define	isalpha(c)	(isupper(c)||islower(c))
#define tolower(c)	((c) - 'A' + 'a')
#define toupper(c)	((c) - 'a' + 'A')
@


1.14
log
@don't define min,max if libkern.h included.
@
text
@d1 2
a2 2
/*	$OpenBSD: stand.h,v 1.13 1996/10/29 07:59:29 mickey Exp $	*/
/*	$NetBSD: stand.h,v 1.13 1996/01/13 22:25:42 leo Exp $	*/
d117 1
d150 1
a150 1
void	vprintf __P((const char *format, va_list ap));
@


1.13
log
@add some prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.12 1996/10/23 09:02:54 mickey Exp $	*/
d56 2
d60 1
d192 1
a192 1
void	machdep_start __P((char *, int, char *, char *, char *));
@


1.12
log
@introduce multiconsoles.
add btochs macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.11 1996/10/17 06:49:58 mickey Exp $	*/
d184 3
a189 2
int	getchar __P((void));
void	putchar __P((int));    
d191 3
@


1.11
log
@prototype stat,fstat
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.10 1996/10/16 13:24:07 mickey Exp $	*/
d97 11
d133 5
a137 1
int	devopen __P((struct open_file *, const char *, char **));
d185 1
@


1.10
log
@unneeded includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.9 1996/10/16 11:32:08 mickey Exp $	*/
d151 2
@


1.9
log
@add functions.
remove functions.
optimize (:
emulate b{copy,cmp,zero} through the mem{cpy,cmp,set}.
add useful macros to stand.h
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.8 1996/10/15 09:58:40 mickey Exp $	*/
a40 1
#include <sys/stat.h>
d50 1
@


1.8
log
@gcc -Wall happy
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.7 1996/10/15 09:41:56 mickey Exp $	*/
d53 7
d72 1
d136 3
a138 1
void	bcopy __P((const void *, void *, size_t));
d140 3
d144 2
a145 1
void	exec __P((char *, char *, int));
d165 1
d171 2
@


1.7
log
@zlib need this
@
text
@d1 1
a1 1
/*	$OpenBSD: stand.h,v 1.6 1996/09/23 14:19:04 mickey Exp $	*/
d42 1
d123 1
@


1.6
log
@add OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d128 1
d135 1
@


1.5
log
@add <ctype.h> style macros.
@
text
@d1 1
@


1.4
log
@correct dkcksum return type.
@
text
@d105 2
d108 1
@


1.3
log
@proto memcpy
@
text
@d114 1
a114 1
int	dkcksum __P((struct disklabel *));
@


1.2
log
@shrink bootblocks by splitting libsa contents into more files. from
waldi@@moacs.indiv.nl.net, netbsd pr#1817
@
text
@d1 1
a1 1
/*	$NetBSD: stand.h,v 1.12 1995/09/18 21:19:47 pk Exp $	*/
d123 1
@


1.1
log
@Initial revision
@
text
@d66 1
a96 1
extern int nfsys;
d114 1
d121 1
a121 1
__dead void _rtt __P((void)) __attribute__((noreturn));
a122 1
int	getchar __P((void));
d126 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

