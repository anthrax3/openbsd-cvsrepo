head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.6
	OPENBSD_6_2_BASE:1.15
	OPENBSD_6_1:1.15.0.8
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.46
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.42
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.40
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.38
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.36
	OPENBSD_5_0:1.13.0.34
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.32
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.30
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.26
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.28
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.24
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.22
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.13.0.20
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.18
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.16
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.14
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.12
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.20
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.18
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.16
	OPENBSD_2_8:1.10.0.14
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.12
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.10
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.8
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.6
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.4
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.10.0.2
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2015.08.15.19.42.56;	author miod;	state Exp;
branches;
next	1.14;
commitid	y0cIQKCk3HrHel1v;

1.14
date	2014.07.13.15.31.20;	author mpi;	state Exp;
branches;
next	1.13;
commitid	7SdCoErqwI9qHMpK;

1.13
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.01.17.00.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	98.02.23.20.32.30;	author niklas;	state Exp;
branches
	1.10.10.1
	1.10.20.1;
next	1.9;

1.9
date	97.02.06.19.35.52;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.08.35.38;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.08.15.15.56;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.27.19.52.25;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.16.14.18.36;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.10.15.09.58.37;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.09.27.07.13.49;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.09.53;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.58;	author deraadt;	state Exp;
branches;
next	;

1.10.10.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.10.10.2;

1.10.10.2
date	2003.06.07.11.03.42;	author ho;	state Exp;
branches;
next	1.10.10.3;

1.10.10.3
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.10.20.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@When sendrecv() returns -1, have rpc_call() return -1 as well. Otherwise, due
to the cast to unsigned, it fails the error test and returns a bogus partial
read to the caller, which is painful to debug.
@
text
@/*	$OpenBSD: rpc.c,v 1.14 2014/07/13 15:31:20 mpi Exp $	*/
/*	$NetBSD: rpc.c,v 1.16 1996/10/13 02:29:06 christos Exp $	*/

/*
 * Copyright (c) 1992 Regents of the University of California.
 * All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * @@(#) Header: rpc.c,v 1.12 93/09/28 08:31:56 leres Exp  (LBL)
 */

/*
 * RPC functions used by NFS and bootparams.
 * Note that bootparams requires the ability to find out the
 * address of the server from which its response has come.
 * This is supported by keeping the IP/UDP headers in the
 * buffer space provided by the caller.  (See rpc_fromaddr)
 */

#include <sys/param.h>
#include <sys/socket.h>

#include <netinet/in.h>

#include <nfs/rpcv2.h>

#include "stand.h"
#include "net.h"
#include "netif.h"
#include "rpc.h"

struct auth_info {
	int32_t		authtype;	/* auth type */
	u_int32_t	authlen;	/* auth length */
};

struct auth_unix {
	int32_t   ua_time;
	int32_t   ua_hostname;	/* null */
	int32_t   ua_uid;
	int32_t   ua_gid;
	int32_t   ua_gidlist;	/* null */
};

struct rpc_call {
	u_int32_t	rp_xid;		/* request transaction id */
	int32_t		rp_direction;	/* call direction (0) */
	u_int32_t	rp_rpcvers;	/* rpc version (2) */
	u_int32_t	rp_prog;	/* program */
	u_int32_t	rp_vers;	/* version */
	u_int32_t	rp_proc;	/* procedure */
};

struct rpc_reply {
	u_int32_t	rp_xid;		/* request transaction id */
	int32_t		rp_direction;	/* call direction (1) */
	int32_t		rp_astatus;	/* accept status (0: accepted) */
	union {
		u_int32_t	rpu_errno;
		struct {
			struct auth_info rok_auth;
			u_int32_t	rok_status;
		} rpu_rok;
	} rp_u;
};

/* Local forwards */
static	ssize_t recvrpc(struct iodesc *, void *, size_t, time_t);
static	int rpc_getport(struct iodesc *, u_int32_t, u_int32_t);

int rpc_xid;
int rpc_port = 0x400;	/* predecrement */

/*
 * Make a rpc call; return length of answer
 * Note: Caller must leave room for headers.
 */
ssize_t
rpc_call(struct iodesc *d, u_int32_t prog, u_int32_t vers, u_int32_t proc, void *sdata,
    size_t slen, void *rdata, size_t rlen)
{
	ssize_t cc;
	struct auth_info *auth;
	struct rpc_call *call;
	struct rpc_reply *reply;
	char *send_head, *send_tail;
	char *recv_head, *recv_tail;
	u_int32_t x;
	int port;	/* host order */

#ifdef RPC_DEBUG
	if (debug)
		printf("rpc_call: prog=0x%x vers=%d proc=%d\n",
		    prog, vers, proc);
#endif

	port = rpc_getport(d, prog, vers);
	if (port == -1)
		return (-1);

	d->destport = htons(port);

	/*
	 * Prepend authorization stuff and headers.
	 * Note, must prepend things in reverse order.
	 */
	send_head = sdata;
	send_tail = (char *)sdata + slen;

	/* Auth verifier is always auth_null */
	send_head -= sizeof(*auth);
	auth = (struct auth_info *)send_head;
	auth->authtype = htonl(RPCAUTH_NULL);
	auth->authlen = 0;

#if 1
	/* Auth credentials: always auth unix (as root) */
	send_head -= sizeof(struct auth_unix);
	bzero(send_head, sizeof(struct auth_unix));
	send_head -= sizeof(*auth);
	auth = (struct auth_info *)send_head;
	auth->authtype = htonl(RPCAUTH_UNIX);
	auth->authlen = htonl(sizeof(struct auth_unix));
#else
	/* Auth credentials: always auth_null (XXX OK?) */
	send_head -= sizeof(*auth);
	auth = send_head;
	auth->authtype = htonl(RPCAUTH_NULL);
	auth->authlen = 0;
#endif

	/* RPC call structure. */
	send_head -= sizeof(*call);
	call = (struct rpc_call *)send_head;
	rpc_xid++;
	call->rp_xid       = htonl(rpc_xid);
	call->rp_direction = htonl(RPC_CALL);
	call->rp_rpcvers   = htonl(RPC_VER2);
	call->rp_prog = htonl(prog);
	call->rp_vers = htonl(vers);
	call->rp_proc = htonl(proc);

	/* Make room for the rpc_reply header. */
	recv_head = rdata;
	recv_tail = (char *)rdata + rlen;
	recv_head -= sizeof(*reply);

	cc = sendrecv(d,
	    sendudp, send_head, send_tail - send_head,
	    recvrpc, recv_head, recv_tail - recv_head);

#ifdef RPC_DEBUG
	if (debug)
		printf("callrpc: cc=%d rlen=%d\n", cc, rlen);
#endif
	if (cc <= -1)
		return (-1);

	if ((size_t)cc <= sizeof(*reply)) {
		errno = EBADRPC;
		return (-1);
	}

	recv_tail = recv_head + cc;

	/*
	 * Check the RPC reply status.
	 * The xid, dir, astatus were already checked.
	 */
	reply = (struct rpc_reply *)recv_head;
	auth = &reply->rp_u.rpu_rok.rok_auth;
	x = ntohl(auth->authlen);
	if (x != 0) {
#ifdef RPC_DEBUG
		if (debug)
			printf("callrpc: reply auth != NULL\n");
#endif
		errno = EBADRPC;
		return(-1);
	}
	x = ntohl(reply->rp_u.rpu_rok.rok_status);
	if (x != 0) {
		printf("callrpc: error = %d\n", x);
		errno = EBADRPC;
		return(-1);
	}
	recv_head += sizeof(*reply);

	return (ssize_t)(recv_tail - recv_head);
}

/*
 * Returns true if packet is the one we're waiting for.
 * This just checks the XID, direction, acceptance.
 * Remaining checks are done by callrpc
 */
static ssize_t
recvrpc(struct iodesc *d, void *pkt, size_t len, time_t tleft)
{
	struct rpc_reply *reply;
	ssize_t	n;
	int	x;

	errno = 0;
#ifdef RPC_DEBUG
	if (debug)
		printf("recvrpc: called len=%d\n", len);
#endif

	n = readudp(d, pkt, len, tleft);
	if (n <= (4 * 4))
		return -1;

	reply = (struct rpc_reply *)pkt;

	x = ntohl(reply->rp_xid);
	if (x != rpc_xid) {
#ifdef RPC_DEBUG
		if (debug)
			printf("recvrpc: rp_xid %d != xid %d\n", x, rpc_xid);
#endif
		return -1;
	}

	x = ntohl(reply->rp_direction);
	if (x != RPC_REPLY) {
#ifdef RPC_DEBUG
		if (debug)
			printf("recvrpc: rp_direction %d != REPLY\n", x);
#endif
		return -1;
	}

	x = ntohl(reply->rp_astatus);
	if (x != RPC_MSGACCEPTED) {
		errno = ntohl(reply->rp_u.rpu_errno);
		printf("recvrpc: reject, astat=%d, errno=%d\n", x, errno);
		return -1;
	}

	/* Return data count (thus indicating success) */
	return (n);
}

/*
 * Given a pointer to a reply just received,
 * dig out the IP address/port from the headers.
 */
void
rpc_fromaddr(void *pkt, struct in_addr *addr, u_short *port)
{
	struct hackhdr {
		/* Tail of IP header: just IP addresses */
		u_int32_t ip_src;
		u_int32_t ip_dst;
		/* UDP header: */
		u_int16_t uh_sport;		/* source port */
		u_int16_t uh_dport;		/* destination port */
		int16_t	  uh_ulen;		/* udp length */
		u_int16_t uh_sum;		/* udp checksum */
		/* RPC reply header: */
		struct rpc_reply rpc;
	} *hhdr;

	hhdr = ((struct hackhdr *)pkt) - 1;
	addr->s_addr = hhdr->ip_src;
	*port = hhdr->uh_sport;
}

/*
 * RPC Portmapper cache
 */
#define PMAP_NUM 8			/* need at most 5 pmap entries */

int rpc_pmap_num;
struct pmap_list {
	struct in_addr	addr;	/* server, net order */
	u_int	prog;		/* host order */
	u_int	vers;		/* host order */
	int	port;		/* host order */
} rpc_pmap_list[PMAP_NUM];

/* return port number in host order, or -1 */
int
rpc_pmap_getcache(struct in_addr addr, u_int prog, u_int vers)
{
	struct pmap_list *pl;

	for (pl = rpc_pmap_list; pl < &rpc_pmap_list[rpc_pmap_num]; pl++) {
		if (pl->addr.s_addr == addr.s_addr &&
		    pl->prog == prog && pl->vers == vers)
			return (pl->port);
	}
	return (-1);
}

void
rpc_pmap_putcache(struct in_addr addr, u_int prog, u_int vers, int port)
{
	struct pmap_list *pl;

	/* Don't overflow cache... */
	if (rpc_pmap_num >= PMAP_NUM) {
		/* ... just re-use the last entry. */
		rpc_pmap_num = PMAP_NUM - 1;
#ifdef	RPC_DEBUG
		printf("rpc_pmap_putcache: cache overflow\n");
#endif
	}

	pl = &rpc_pmap_list[rpc_pmap_num];
	rpc_pmap_num++;

	/* Cache answer */
	pl->addr = addr;
	pl->prog = prog;
	pl->vers = vers;
	pl->port = port;
}


/*
 * Request a port number from the port mapper.
 * Returns the port in host order.
 */
int
rpc_getport(struct iodesc *d, u_int32_t prog, u_int32_t vers)
{
	struct args {
		u_int32_t	prog;		/* call program */
		u_int32_t	vers;		/* call version */
		u_int32_t	proto;		/* call protocol */
		u_int32_t	port;		/* call port (unused) */
	} *args;
	struct res {
		u_int32_t port;
	} *res;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct args d;
	} sdata;
	struct {
		u_int32_t	h[RPC_HEADER_WORDS];
		struct res d;
		u_int32_t  pad;
	} rdata;
	ssize_t cc;
	int port;

#ifdef RPC_DEBUG
	if (debug)
		printf("getport: prog=0x%x vers=%d\n", prog, vers);
#endif

	/* This one is fixed forever. */
	if (prog == PMAPPROG)
		return (PMAPPORT);

	/* Try for cached answer first */
	port = rpc_pmap_getcache(d->destip, prog, vers);
	if (port != -1)
		return (port);

	args = &sdata.d;
	args->prog = htonl(prog);
	args->vers = htonl(vers);
	args->proto = htonl(IPPROTO_UDP);
	args->port = 0;
	res = &rdata.d;

	cc = rpc_call(d, PMAPPROG, PMAPVERS, PMAPPROC_GETPORT,
		args, sizeof(*args), res, sizeof(*res));
	if (cc < 0 || (size_t)cc < sizeof(*res)) {
		printf("getport: %s", strerror(errno));
		errno = EBADRPC;
		return (-1);
	}
	port = (int)ntohl(res->port);

	rpc_pmap_putcache(d->destip, prog, vers, port);

	return (port);
}
@


1.14
log
@Stop using old n_long and n_short types.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.13 2003/08/11 06:23:09 deraadt Exp $	*/
d187 1
a187 1
	if (cc < -1)
@


1.13
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.12 2003/06/01 17:00:33 deraadt Exp $	*/
a54 1
#include <netinet/in_systm.h>
d100 1
a100 1
static	int rpc_getport(struct iodesc *, n_long, n_long);
d110 1
a110 1
rpc_call(struct iodesc *d, n_long prog, n_long vers, n_long proc, void *sdata,
d119 1
a119 1
	n_long x;
d285 2
a286 2
		n_long ip_src;
		n_long ip_dst;
d358 1
a358 1
rpc_getport(struct iodesc *d, n_long prog, n_long vers)
d361 4
a364 4
		n_long	prog;		/* call program */
		n_long	vers;		/* call version */
		n_long	proto;		/* call protocol */
		n_long	port;		/* call port (unused) */
d367 1
a367 1
		n_long port;
d370 1
a370 1
		n_long	h[RPC_HEADER_WORDS];
d374 1
a374 1
		n_long	h[RPC_HEADER_WORDS];
d376 1
a376 1
		n_long  pad;
@


1.12
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.11 2002/03/14 01:27:07 millert Exp $	*/
d111 2
a112 7
rpc_call(d, prog, vers, proc, sdata, slen, rdata, rlen)
	register struct iodesc *d;
	register n_long prog, vers, proc;
	register void *sdata;
	register size_t slen;
	register void *rdata;
	register size_t rlen;
d114 1
a114 1
	register ssize_t cc;
d230 1
a230 5
recvrpc(d, pkt, len, tleft)
	register struct iodesc *d;
	register void *pkt;
	register size_t len;
	time_t tleft;
d232 1
a232 1
	register struct rpc_reply *reply;
d282 1
a282 4
rpc_fromaddr(pkt, addr, port)
	void		*pkt;
	struct in_addr	*addr;
	u_short		*port;
d317 1
a317 4
rpc_pmap_getcache(addr, prog, vers)
	struct in_addr	addr;	/* server, net order */
	u_int		prog;	/* host order */
	u_int		vers;	/* host order */
d323 1
a323 2
			pl->prog == prog && pl->vers == vers )
		{
a324 1
		}
d330 1
a330 5
rpc_pmap_putcache(addr, prog, vers, port)
	struct in_addr	addr;	/* server, net order */
	u_int		prog;	/* host order */
	u_int		vers;	/* host order */
	int		port;	/* host order */
d359 1
a359 4
rpc_getport(d, prog, vers)
	register struct iodesc *d;
	n_long prog;	/* host order */
	n_long vers;	/* host order */
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.10 1998/02/23 20:32:30 niklas Exp $	*/
d65 1
a65 1
	int32_t 	authtype;	/* auth type */
d79 1
a79 1
	int32_t 	rp_direction;	/* call direction (0) */
d88 2
a89 2
	int32_t 	rp_direction;	/* call direction (1) */
	int32_t 	rp_astatus;	/* accept status (0: accepted) */
d324 1
a324 1
	int 	port;		/* host order */
d351 1
a351 1
	int 		port;	/* host order */
@


1.10
log
@strong signedness typing a version of egcs I tried months ago wanted
me to fix.  I am not sure these are necessary for gas 2.8 but I figure I
would commit them anyhow.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.9 1997/02/06 19:35:52 mickey Exp $	*/
d100 2
a101 2
static	ssize_t recvrpc __P((struct iodesc *, void *, size_t, time_t));
static	int rpc_getport __P((struct iodesc *, n_long, n_long));
@


1.10.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.10 1998/02/23 20:32:30 niklas Exp $	*/
d100 2
a101 2
static	ssize_t recvrpc(struct iodesc *, void *, size_t, time_t);
static	int rpc_getport(struct iodesc *, n_long, n_long);
@


1.10.10.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 2
a101 2
static	ssize_t recvrpc(struct iodesc *, void *, size_t, time_t);
static	int rpc_getport(struct iodesc *, n_long, n_long);
@


1.10.10.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.10.10.1 2002/03/28 15:02:00 niklas Exp $	*/
d65 1
a65 1
	int32_t		authtype;	/* auth type */
d79 1
a79 1
	int32_t		rp_direction;	/* call direction (0) */
d88 2
a89 2
	int32_t		rp_direction;	/* call direction (1) */
	int32_t		rp_astatus;	/* accept status (0: accepted) */
d324 1
a324 1
	int	port;		/* host order */
d351 1
a351 1
	int		port;	/* host order */
@


1.10.10.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d111 7
a117 2
rpc_call(struct iodesc *d, n_long prog, n_long vers, n_long proc, void *sdata,
    size_t slen, void *rdata, size_t rlen)
d119 1
a119 1
	ssize_t cc;
d235 5
a239 1
recvrpc(struct iodesc *d, void *pkt, size_t len, time_t tleft)
d241 1
a241 1
	struct rpc_reply *reply;
d291 4
a294 1
rpc_fromaddr(void *pkt, struct in_addr *addr, u_short *port)
d329 4
a332 1
rpc_pmap_getcache(struct in_addr addr, u_int prog, u_int vers)
d338 2
a339 1
		    pl->prog == prog && pl->vers == vers)
d341 1
d347 5
a351 1
rpc_pmap_putcache(struct in_addr addr, u_int prog, u_int vers, int port)
d380 4
a383 1
rpc_getport(struct iodesc *d, n_long prog, n_long vers)
@


1.9
log
@-Wall printf format correction
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.8 1996/12/12 08:35:38 mickey Exp $	*/
d193 1
a193 1
	if (cc == -1)
d196 1
a196 1
	if (cc <= sizeof(*reply)) {
d429 1
a429 1
	if (cc < sizeof(*res)) {
@


1.8
log
@printf format fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.7 1996/12/08 15:15:56 niklas Exp $	*/
d261 1
a261 1
			printf("recvrpc: rp_xid %ld != xid %d\n", x, rpc_xid);
d270 1
a270 1
			printf("recvrpc: rp_direction %ld != REPLY\n", x);
@


1.7
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.6 1996/11/27 19:52:25 niklas Exp $	*/
d278 1
a278 1
		printf("recvrpc: reject, astat=%ld, errno=%d\n", x, errno);
@


1.6
log
@Make typesafe and 64bit cleaner
@
text
@d1 2
a2 2
/*	$OpenBSD: rpc.c,v 1.5 1996/10/16 14:18:36 mickey Exp $	*/
/*	$NetBSD: rpc.c,v 1.12 1996/02/26 23:05:26 gwr Exp $	*/
d131 1
a131 1
			prog, vers, proc);
d243 1
a243 1
	long	x;
d322 2
a323 2
	u_long	prog;		/* host order */
	u_long	vers;		/* host order */
d331 2
a332 2
	u_long		prog;	/* host order */
	u_long		vers;	/* host order */
d349 2
a350 2
	u_long		prog;	/* host order */
	u_long		vers;	/* host order */
@


1.5
log
@remove unneeded include <string.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.4 1996/10/15 09:58:37 mickey Exp $	*/
d186 2
a187 2
	    sendudp, send_head, ((int)send_tail - (int)send_head),
	    recvrpc, recv_head, ((int)recv_tail - (int)recv_head));
d226 1
a226 1
	return (ssize_t)((int)recv_tail - (int)recv_head);
@


1.4
log
@gcc -Wall happy
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.3 1996/09/27 07:13:49 mickey Exp $	*/
a55 2

#include <string.h>
@


1.3
log
@use nfs/{nfsv2.h,rpcv2.h} instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: rpc.c,v 1.2 1996/04/19 16:09:53 niklas Exp $	*/
d263 1
a263 1
			printf("recvrpc: rp_xid %d != xid %d\n", x, rpc_xid);
d272 1
a272 1
			printf("recvrpc: rp_direction %d != REPLY\n", x);
d280 1
a280 1
		printf("recvrpc: reject, astat=%d, errno=%d\n", x, errno);
@


1.2
log
@NetBSD 960317 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 1
a59 1
#include "rpcv2.h"
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: rpc.c,v 1.10 1995/09/23 03:36:11 gwr Exp $	*/
d57 1
a57 3
#include <nfs/rpcv2.h>
#include <nfs/nfsv2.h>
#include <nfs/xdr_subs.h>
d59 1
a59 1
#include <string.h>
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
