head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.22.0.6
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.19.0.14
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.12
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.8
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.16
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.14
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.12
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.10
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.8
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.6
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.20
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.18
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.16
	OPENBSD_2_8:1.12.0.14
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.12
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.10
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.8
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.6
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.4
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.6.0.2
	OPENBSD_2_0_BASE:1.6
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2016.11.25.17.00.33;	author reyk;	state Exp;
branches;
next	1.25;
commitid	r8zN5b31vMHB19eR;

1.25
date	2015.07.17.18.55.00;	author kspillner;	state Exp;
branches;
next	1.24;
commitid	w5UbRGaIHKg21zia;

1.24
date	2014.07.22.18.03.03;	author deraadt;	state Exp;
branches;
next	1.23;
commitid	b7rUZr3iuiATvlN7;

1.23
date	2014.07.22.16.51.00;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	TCXL9b1C3WQ2S2ZV;

1.22
date	2013.05.30.19.19.09;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.28.19.50.52;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2011.03.13.00.13.53;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.06.11.17.18;	author otto;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.16.21.48.59;	author tsi;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.25.23.27.44;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.11.06.23.09;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.10;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.01.17.00.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.07;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.02.23.20.32.31;	author niklas;	state Exp;
branches
	1.12.10.1
	1.12.20.1;
next	1.11;

1.11
date	97.04.02.05.28.30;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.03.25.20.30.44;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	97.02.16.14.39.37;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.12.08.15.15.58;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.16.14.02.55;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.23.14.19.06;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.06.10.07.28.00;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.15.01.06.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.15.08.09.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.07.03.27.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.59;	author deraadt;	state Exp;
branches;
next	;

1.12.10.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.12.10.2;

1.12.10.2
date	2003.06.07.11.03.43;	author ho;	state Exp;
branches;
next	1.12.10.3;

1.12.10.3
date	2004.02.19.10.57.19;	author niklas;	state Exp;
branches;
next	;

1.12.20.1
date	2002.06.11.03.30.09;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Fix signedness warnings with careful casts and replace a re-defined variable.

OK krw@@
@
text
@/*	$OpenBSD: ufs.c,v 1.25 2015/07/17 18:55:00 kspillner Exp $	*/
/*	$NetBSD: ufs.c,v 1.16 1996/09/30 16:01:22 ws Exp $	*/

/*-
 * Copyright (c) 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * The Mach Operating System project at Carnegie-Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *
 * Copyright (c) 1990, 1991 Carnegie Mellon University
 * All Rights Reserved.
 *
 * Author: David Golub
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 *	Stand-alone file reading package.
 */

#include <sys/param.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <ufs/ffs/fs.h>
#include <ufs/ufs/dinode.h>
#include <ufs/ufs/dir.h>
#include <lib/libkern/libkern.h>

#include "stand.h"
#include "ufs.h"

/*
 * In-core open file.
 */
struct file {
	off_t		f_seekp;	/* seek pointer */
	struct fs	*f_fs;		/* pointer to super-block */
	struct ufs1_dinode	f_di;		/* copy of on-disk inode */
	int		f_nindir[NIADDR];
					/* number of blocks mapped by
					   indirect block at level i */
	char		*f_blk[NIADDR];	/* buffer for indirect block at
					   level i */
	size_t		f_blksize[NIADDR];
					/* size of buffer */
	daddr32_t	f_blkno[NIADDR];/* disk address of block in buffer */
	char		*f_buf;		/* buffer for data block */
	size_t		f_buf_size;	/* size of data block */
	daddr32_t	f_buf_blkno;	/* block number of data block */
};

static int	read_inode(ufsino_t, struct open_file *);
static int	block_map(struct open_file *, daddr32_t, daddr32_t *);
static int	buf_read_file(struct open_file *, char **, size_t *);
static int	search_directory(char *, struct open_file *, ufsino_t *);
static int	ufs_close_internal(struct file *);
#ifdef COMPAT_UFS
static void	ffs_oldfscompat(struct fs *);
#endif

/*
 * Read a new inode into a file structure.
 */
static int
read_inode(ufsino_t inumber, struct open_file *f)
{
	struct file *fp = (struct file *)f->f_fsdata;
	struct fs *fs = fp->f_fs;
	char *buf;
	size_t rsize;
	int rc;

	/*
	 * Read inode and save it.
	 */
	buf = alloc(fs->fs_bsize);
	twiddle();
	rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
	    fsbtodb(fs, (daddr32_t)ino_to_fsba(fs, inumber)), fs->fs_bsize,
	    buf, &rsize);
	if (rc)
		goto out;
	if (rsize != (size_t)fs->fs_bsize) {
		rc = EIO;
		goto out;
	}

	{
		struct ufs1_dinode *dp;

		dp = (struct ufs1_dinode *)buf;
		fp->f_di = dp[ino_to_fsbo(fs, inumber)];
	}

	/*
	 * Clear out the old buffers
	 */
	{
		int level;

		for (level = 0; level < NIADDR; level++)
			fp->f_blkno[level] = -1;
		fp->f_buf_blkno = -1;
		fp->f_seekp = 0;
	}
out:
	free(buf, fs->fs_bsize);
	return (rc);
}

/*
 * Given an offset in a file, find the disk block number that
 * contains that block.
 */
static int
block_map(struct open_file *f, daddr32_t file_block, daddr32_t *disk_block_p)
{
	struct file *fp = (struct file *)f->f_fsdata;
	daddr32_t ind_block_num, *ind_p;
	struct fs *fs = fp->f_fs;
	int level, idx, rc;

	/*
	 * Index structure of an inode:
	 *
	 * di_db[0..NDADDR-1]	hold block numbers for blocks
	 *			0..NDADDR-1
	 *
	 * di_ib[0]		index block 0 is the single indirect block
	 *			holds block numbers for blocks
	 *			NDADDR .. NDADDR + NINDIR(fs)-1
	 *
	 * di_ib[1]		index block 1 is the double indirect block
	 *			holds block numbers for INDEX blocks for blocks
	 *			NDADDR + NINDIR(fs) ..
	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 - 1
	 *
	 * di_ib[2]		index block 2 is the triple indirect block
	 *			holds block numbers for double-indirect
	 *			blocks for blocks
	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2 ..
	 *			NDADDR + NINDIR(fs) + NINDIR(fs)**2
	 *				+ NINDIR(fs)**3 - 1
	 */

	if (file_block < NDADDR) {
		/* Direct block. */
		*disk_block_p = fp->f_di.di_db[file_block];
		return (0);
	}

	file_block -= NDADDR;

	/*
	 * nindir[0] = NINDIR
	 * nindir[1] = NINDIR**2
	 * nindir[2] = NINDIR**3
	 *	etc
	 */
	for (level = 0; level < NIADDR; level++) {
		if (file_block < fp->f_nindir[level])
			break;
		file_block -= fp->f_nindir[level];
	}
	if (level == NIADDR) {
		/* Block number too high */
		return (EFBIG);
	}

	ind_block_num = fp->f_di.di_ib[level];

	for (; level >= 0; level--) {
		if (ind_block_num == 0) {
			*disk_block_p = 0;	/* missing */
			return (0);
		}

		if (fp->f_blkno[level] != ind_block_num) {
			if (fp->f_blk[level] == NULL)
				fp->f_blk[level] =
				    alloc(fs->fs_bsize);
			twiddle();
			rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
			    fsbtodb(fp->f_fs, ind_block_num), fs->fs_bsize,
			    fp->f_blk[level], &fp->f_blksize[level]);
			if (rc)
				return (rc);
			if (fp->f_blksize[level] != (size_t)fs->fs_bsize)
				return (EIO);
			fp->f_blkno[level] = ind_block_num;
		}

		ind_p = (daddr32_t *)fp->f_blk[level];

		if (level > 0) {
			idx = file_block / fp->f_nindir[level - 1];
			file_block %= fp->f_nindir[level - 1];
		} else
			idx = file_block;

		ind_block_num = ind_p[idx];
	}

	*disk_block_p = ind_block_num;
	return (0);
}

/*
 * Read a portion of a file into an internal buffer.  Return
 * the location in the buffer and the amount in the buffer.
 */
static int
buf_read_file(struct open_file *f, char **buf_p, size_t *size_p)
{
	struct file *fp = (struct file *)f->f_fsdata;
	struct fs *fs = fp->f_fs;
	daddr32_t file_block, disk_block;
	size_t block_size;
	long off;
	int rc;

	off = blkoff(fs, fp->f_seekp);
	file_block = lblkno(fs, fp->f_seekp);
	block_size = dblksize(fs, &fp->f_di, (u_int64_t)file_block);

	if (file_block != fp->f_buf_blkno) {
		rc = block_map(f, file_block, &disk_block);
		if (rc)
			return (rc);

		if (fp->f_buf == NULL)
			fp->f_buf = alloc(fs->fs_bsize);

		if (disk_block == 0) {
			bzero(fp->f_buf, block_size);
			fp->f_buf_size = block_size;
		} else {
			twiddle();
			rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
			    fsbtodb(fs, disk_block),
			    block_size, fp->f_buf, &fp->f_buf_size);
			if (rc)
				return (rc);
		}

		fp->f_buf_blkno = file_block;
	}

	/*
	 * Return address of byte in buffer corresponding to
	 * offset, and size of remainder of buffer after that
	 * byte.
	 */
	*buf_p = fp->f_buf + off;
	*size_p = block_size - off;

	/*
	 * But truncate buffer at end of file.
	 */
	if (*size_p > fp->f_di.di_size - fp->f_seekp)
		*size_p = fp->f_di.di_size - fp->f_seekp;

	return (0);
}

/*
 * Search a directory for a name and return its
 * i_number.
 */
static int
search_directory(char *name, struct open_file *f, ufsino_t *inumber_p)
{
	struct file *fp = (struct file *)f->f_fsdata;
	int namlen, length, rc;
	struct direct *dp, *edp;
	size_t buf_size;
	char *buf;

	length = strlen(name);

	fp->f_seekp = 0;
	while ((u_int64_t)fp->f_seekp < fp->f_di.di_size) {
		rc = buf_read_file(f, &buf, &buf_size);
		if (rc)
			return (rc);

		dp = (struct direct *)buf;
		edp = (struct direct *)(buf + buf_size);
		while (dp < edp) {
			if (dp->d_ino == 0)
				goto next;
#if BYTE_ORDER == LITTLE_ENDIAN
			if (fp->f_fs->fs_maxsymlinklen <= 0)
				namlen = dp->d_type;
			else
#endif
				namlen = dp->d_namlen;
			if (namlen == length &&
			    !strcmp(name, dp->d_name)) {
				/* found entry */
				*inumber_p = dp->d_ino;
				return (0);
			}
		next:
			dp = (struct direct *)((char *)dp + dp->d_reclen);
		}
		fp->f_seekp += buf_size;
	}
	return (ENOENT);
}

/*
 * Open a file.
 */
int
ufs_open(char *path, struct open_file *f)
{
	char namebuf[MAXPATHLEN+1], *cp, *ncp, *buf = NULL;
	ufsino_t inumber, parent_inumber;
	int rc, c, nlinks = 0;
	struct file *fp;
	size_t buf_size;
	struct fs *fs;

	/* allocate file system specific data structure */
	fp = alloc(sizeof(struct file));
	bzero(fp, sizeof(struct file));
	f->f_fsdata = (void *)fp;

	/* allocate space and read super block */
	fs = alloc(SBSIZE);
	fp->f_fs = fs;
	twiddle();
	rc = (f->f_dev->dv_strategy)(f->f_devdata, F_READ,
	    SBLOCK, SBSIZE, (char *)fs, &buf_size);
	if (rc)
		goto out;

	if (buf_size != SBSIZE || fs->fs_magic != FS_MAGIC ||
	    (size_t)fs->fs_bsize > MAXBSIZE ||
	    (size_t)fs->fs_bsize < sizeof(struct fs)) {
		rc = EINVAL;
		goto out;
	}
#ifdef COMPAT_UFS
	ffs_oldfscompat(fs);
#endif

	/*
	 * Calculate indirect block levels.
	 */
	{
		int mult;
		int level;

		mult = 1;
		for (level = 0; level < NIADDR; level++) {
			mult *= NINDIR(fs);
			fp->f_nindir[level] = mult;
		}
	}

	inumber = ROOTINO;
	if ((rc = read_inode(inumber, f)) != 0)
		goto out;

	cp = path;
	while (*cp) {

		/*
		 * Remove extra separators
		 */
		while (*cp == '/')
			cp++;
		if (*cp == '\0')
			break;

		/*
		 * Check that current node is a directory.
		 */
		if ((fp->f_di.di_mode & IFMT) != IFDIR) {
			rc = ENOTDIR;
			goto out;
		}

		/*
		 * Get next component of path name.
		 */
		{
			int len = 0;

			ncp = cp;
			while ((c = *cp) != '\0' && c != '/') {
				if (++len > MAXNAMLEN) {
					rc = ENOENT;
					goto out;
				}
				cp++;
			}
			*cp = '\0';
		}

		/*
		 * Look up component in current directory.
		 * Save directory inumber in case we find a
		 * symbolic link.
		 */
		parent_inumber = inumber;
		rc = search_directory(ncp, f, &inumber);
		*cp = c;
		if (rc)
			goto out;

		/*
		 * Open next component.
		 */
		if ((rc = read_inode(inumber, f)) != 0)
			goto out;

		/*
		 * Check for symbolic link.
		 */
		if ((fp->f_di.di_mode & IFMT) == IFLNK) {
			u_int64_t link_len = fp->f_di.di_size;
			size_t len;

			len = strlen(cp);

			if (link_len + len > MAXPATHLEN ||
			    ++nlinks > MAXSYMLINKS) {
				rc = ENOENT;
				goto out;
			}

			bcopy(cp, &namebuf[link_len], len + 1);

			if (link_len < (u_int64_t)fs->fs_maxsymlinklen) {
				bcopy(fp->f_di.di_shortlink, namebuf, link_len);
			} else {
				/*
				 * Read file for symbolic link
				 */
				daddr32_t disk_block;
				fs = fp->f_fs;

				if (!buf)
					buf = alloc(fs->fs_bsize);
				rc = block_map(f, (daddr32_t)0, &disk_block);
				if (rc)
					goto out;

				twiddle();
				rc = (f->f_dev->dv_strategy)(f->f_devdata,
				    F_READ, fsbtodb(fs, disk_block),
				    fs->fs_bsize, buf, &buf_size);
				if (rc)
					goto out;

				bcopy(buf, namebuf, link_len);
			}

			/*
			 * If relative pathname, restart at parent directory.
			 * If absolute pathname, restart at root.
			 */
			cp = namebuf;
			if (*cp != '/')
				inumber = parent_inumber;
			else
				inumber = ROOTINO;

			if ((rc = read_inode(inumber, f)) != 0)
				goto out;
		}
	}

	/*
	 * Found terminal component.
	 */
	rc = 0;
out:
	if (buf)
		free(buf, fs->fs_bsize);
	if (rc)
		(void)ufs_close_internal(fp);

	return (rc);
}

int
ufs_close(struct open_file *f)
{
	struct file *fp = (struct file *)f->f_fsdata;

	f->f_fsdata = NULL;
	if (fp == NULL)
		return (0);

	return (ufs_close_internal(fp));
}

static int
ufs_close_internal(struct file *fp)
{
	int level;

	for (level = 0; level < NIADDR; level++) {
		if (fp->f_blk[level])
			free(fp->f_blk[level], fp->f_fs->fs_bsize);
	}
	if (fp->f_buf)
		free(fp->f_buf, fp->f_fs->fs_bsize);
	free(fp->f_fs, SBSIZE);
	free(fp, sizeof(struct file));
	return (0);
}

/*
 * Copy a portion of a file into kernel memory.
 * Cross block boundaries when necessary.
 */
int
ufs_read(struct open_file *f, void *start, size_t size, size_t *resid)
{
	struct file *fp = (struct file *)f->f_fsdata;
	char *buf, *addr = start;
	size_t csize, buf_size;
	int rc = 0;

	while (size != 0) {
		if ((u_int64_t)fp->f_seekp >= fp->f_di.di_size)
			break;

		rc = buf_read_file(f, &buf, &buf_size);
		if (rc)
			break;

		csize = size;
		if (csize > buf_size)
			csize = buf_size;

		bcopy(buf, addr, csize);

		fp->f_seekp += csize;
		addr += csize;
		size -= csize;
	}
	if (resid)
		*resid = size;
	return (rc);
}

/*
 * Not implemented.
 */
int
ufs_write(struct open_file *f, void *start, size_t size, size_t *resid)
{

	return (EROFS);
}

off_t
ufs_seek(struct open_file *f, off_t offset, int where)
{
	struct file *fp = (struct file *)f->f_fsdata;

	switch (where) {
	case SEEK_SET:
		fp->f_seekp = offset;
		break;
	case SEEK_CUR:
		fp->f_seekp += offset;
		break;
	case SEEK_END:
		fp->f_seekp = fp->f_di.di_size - offset;
		break;
	default:
		return (-1);
	}
	return (fp->f_seekp);
}

int
ufs_stat(struct open_file *f, struct stat *sb)
{
	struct file *fp = (struct file *)f->f_fsdata;

	/* only important stuff */
	sb->st_mode = fp->f_di.di_mode;
	sb->st_uid = fp->f_di.di_uid;
	sb->st_gid = fp->f_di.di_gid;
	sb->st_size = fp->f_di.di_size;
	return (0);
}

#ifndef	NO_READDIR
int
ufs_readdir(struct open_file *f, char *name)
{
	struct file *fp = (struct file *)f->f_fsdata;
	struct direct *dp, *edp;
	size_t buf_size;
	int rc, namlen;
	char *buf;

	if (name == NULL)
		fp->f_seekp = 0;
	else {
			/* end of dir */
		if ((u_int64_t)fp->f_seekp >= fp->f_di.di_size) {
			*name = '\0';
			return -1;
		}

		do {
			if ((rc = buf_read_file(f, &buf, &buf_size)) != 0)
				return rc;

			dp = (struct direct *)buf;
			edp = (struct direct *)(buf + buf_size);
			while (dp < edp && dp->d_ino == 0)
				dp = (struct direct *)((char *)dp + dp->d_reclen);
			fp->f_seekp += buf_size -
			    ((u_int8_t *)edp - (u_int8_t *)dp);
		} while (dp >= edp);

#if BYTE_ORDER == LITTLE_ENDIAN
		if (fp->f_fs->fs_maxsymlinklen <= 0)
			namlen = dp->d_type;
		else
#endif
			namlen = dp->d_namlen;
		strncpy(name, dp->d_name, namlen + 1);

		fp->f_seekp += dp->d_reclen;
	}

	return 0;
}
#endif

#ifdef COMPAT_UFS
/*
 * Sanity checks for old file systems.
 *
 * XXX - goes away some day.
 */
static void
ffs_oldfscompat(struct fs *fs)
{
	int i;

	fs->fs_npsect = max(fs->fs_npsect, fs->fs_nsect);	/* XXX */
	fs->fs_interleave = max(fs->fs_interleave, 1);		/* XXX */
	if (fs->fs_postblformat == FS_42POSTBLFMT)		/* XXX */
		fs->fs_nrpos = 8;				/* XXX */
	if (fs->fs_inodefmt < FS_44INODEFMT) {			/* XXX */
		quad_t sizepb = fs->fs_bsize;			/* XXX */
								/* XXX */
		fs->fs_maxfilesize = fs->fs_bsize * NDADDR - 1;	/* XXX */
		for (i = 0; i < NIADDR; i++) {			/* XXX */
			sizepb *= NINDIR(fs);			/* XXX */
			fs->fs_maxfilesize += sizepb;		/* XXX */
		}						/* XXX */
		fs->fs_qbmask = ~fs->fs_bmask;			/* XXX */
		fs->fs_qfmask = ~fs->fs_fmask;			/* XXX */
	}							/* XXX */
}
#endif
@


1.25
log
@Adjust type of link_len to match type of di_size in underlying struct, and
change type of len to size_t to match strlen(3) result.  Drop unneeded
casts.

u_int64_t is overkill because the actual size is still limited to SYMLINK_MAX
but it is probably better to match the filesystem types.

ok miod@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.24 2014/07/22 18:03:03 deraadt Exp $	*/
d269 1
a269 1
	block_size = dblksize(fs, &fp->f_di, file_block);
d327 1
a327 1
	while (fp->f_seekp < fp->f_di.di_size) {
d385 2
a386 1
	    fs->fs_bsize > MAXBSIZE || fs->fs_bsize < sizeof(struct fs)) {
d482 1
a482 1
			if (link_len < fs->fs_maxsymlinklen) {
a487 1
				size_t buf_size;
d489 1
a489 1
				struct fs *fs = fp->f_fs;
d576 1
a576 1
		if (fp->f_seekp >= fp->f_di.di_size)
d656 1
a656 1
		if (fp->f_seekp >= fp->f_di.di_size) {
@


1.24
log
@use NULL instead of (foo *)0; Kent R. Spillner
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.23 2014/07/22 16:51:00 deraadt Exp $	*/
d468 2
a469 2
			int link_len = fp->f_di.di_size;
			int len;
d482 1
a482 2
				bcopy(fp->f_di.di_shortlink, namebuf,
				    (unsigned) link_len);
d504 1
a504 1
				bcopy(buf, namebuf, (unsigned)link_len);
@


1.23
log
@remove unneccessary casts; Kent R. Spillner
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.22 2013/05/30 19:19:09 guenther Exp $	*/
d224 1
a224 1
			if (fp->f_blk[level] == (char *)0)
d276 1
a276 1
		if (fp->f_buf == (char *)0)
d541 2
a542 2
	f->f_fsdata = (void *)0;
	if (fp == (struct file *)0)
@


1.22
log
@UFS does't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

otto wrote the original diff for libsa to keep bootblock from overflowing
ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.21 2011/05/28 19:50:52 miod Exp $	*/
d505 1
a505 1
				bcopy((char *)buf, namebuf, (unsigned)link_len);
@


1.21
log
@Do not leak memory if ufs_open() fails; reported by and ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.20 2011/03/13 00:13:53 deraadt Exp $	*/
d97 1
a97 1
static int	read_inode(ino_t, struct open_file *);
d100 1
a100 1
static int	search_directory(char *, struct open_file *, ino_t *);
d110 1
a110 1
read_inode(ino_t inumber, struct open_file *f)
d316 1
a316 1
search_directory(char *name, struct open_file *f, ino_t *inumber_p)
d335 1
a335 1
			if (dp->d_ino == (ino_t)0)
d364 1
a364 1
	ino_t inumber, parent_inumber;
d516 1
a516 1
				inumber = (ino_t)ROOTINO;
d668 1
a668 1
			while (dp < edp && dp->d_ino == (ino_t)0)
@


1.20
log
@Change daddr_t to daddr32_t.  The bootblocks on our architectures only
do 32-bit block spanning.  If later on we get some that can/should do
64-bit, that can be done now using daddr64_t (but of course, we are taking
this step to finalize the daddr_t 64-bit conversion).
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.19 2008/01/06 11:17:18 otto Exp $	*/
d101 1
d530 3
a532 4
	if (rc) {
		free(fp->f_fs, SBSIZE);
		free(fp, sizeof(struct file));
	}
a539 1
	int level;
d544 8
@


1.19
log
@repair build of boot code where it uses an undefind __ashldi3 on some archs
boot code uses 32-bit blknos anyway
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.18 2007/03/16 21:48:59 tsi Exp $	*/
d91 1
a91 1
	daddr_t		f_blkno[NIADDR];/* disk address of block in buffer */
d94 1
a94 1
	daddr_t		f_buf_blkno;	/* block number of data block */
d98 1
a98 1
static int	block_map(struct open_file *, daddr_t, daddr_t *);
d123 1
a123 1
	    fsbtodb(fs, (daddr_t)ino_to_fsba(fs, inumber)), fs->fs_bsize,
d160 1
a160 1
block_map(struct open_file *f, daddr_t file_block, daddr_t *disk_block_p)
d163 1
a163 1
	daddr_t ind_block_num, *ind_p;
d237 1
a237 1
		ind_p = (daddr_t *)fp->f_blk[level];
d261 1
a261 1
	daddr_t file_block, disk_block;
d488 1
a488 1
				daddr_t	disk_block;
d493 1
a493 1
				rc = block_map(f, (daddr_t)0, &disk_block);
@


1.18
log
@Re-initialise f_seekp to 0 on a successful read_inode() return.
Fixes a problem that prevented the booting of a kernel that, to be
found, needs more than one block per directory iin its path to be read.

ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.17 2003/08/25 23:27:44 tedu Exp $	*/
d123 1
a123 1
	    fsbtodb(fs, ino_to_fsba(fs, inumber)), fs->fs_bsize,
@


1.17
log
@rename struct dinode to ufs1_dinode.  clears the namespace and makes
way for some future work.  no function changes yet.
help testing otto@@ and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.16 2003/08/11 06:23:09 deraadt Exp $	*/
d148 1
@


1.16
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.15 2003/06/02 23:28:10 millert Exp $	*/
d83 1
a83 1
	struct dinode	f_di;		/* copy of on-disk inode */
d133 1
a133 1
		struct dinode *dp;
d135 1
a135 1
		dp = (struct dinode *)buf;
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.14 2003/06/01 17:00:33 deraadt Exp $	*/
d75 1
d109 1
a109 3
read_inode(inumber, f)
	ino_t inumber;
	struct open_file *f;
d111 2
a112 2
	register struct file *fp = (struct file *)f->f_fsdata;
	register struct fs *fs = fp->f_fs;
d133 1
a133 1
		register struct dinode *dp;
d143 1
a143 1
		register int level;
d159 1
a159 4
block_map(f, file_block, disk_block_p)
	struct open_file *f;
	daddr_t file_block;
	daddr_t *disk_block_p;	/* out */
d161 4
a164 7
	register struct file *fp = (struct file *)f->f_fsdata;
	register struct fs *fs = fp->f_fs;
	int level;
	int idx;
	daddr_t ind_block_num;
	daddr_t *ind_p;
	int rc;
a247 1

d256 1
a256 4
buf_read_file(f, buf_p, size_p)
	struct open_file *f;
	char **buf_p;		/* out */
	size_t *size_p;		/* out */
d258 4
a261 2
	register struct file *fp = (struct file *)f->f_fsdata;
	register struct fs *fs = fp->f_fs;
a262 3
	register daddr_t file_block;
	daddr_t	disk_block;
	size_t block_size;
d314 6
a319 8
search_directory(name, f, inumber_p)
	char *name;
	struct open_file *f;
	ino_t *inumber_p;		/* out */
{
	register struct file *fp = (struct file *)f->f_fsdata;
	register struct direct *dp;
	struct direct *edp;
a320 3
	size_t buf_size;
	int namlen, length;
	int rc;
d359 1
a359 3
ufs_open(path, f)
	char *path;
	struct open_file *f;
d361 1
a361 2
	register char *cp, *ncp;
	register int c;
d363 1
d365 1
a366 5
	int rc;
	size_t buf_size;
	int nlinks = 0;
	char namebuf[MAXPATHLEN+1];
	char *buf = NULL;
d395 2
a396 2
		register int mult;
		register int level;
d432 1
a432 1
			register int len = 0;
d488 1
a488 1
				register struct fs *fs = fp->f_fs;
d536 1
a536 2
ufs_close(f)
	struct open_file *f;
d538 1
a538 1
	register struct file *fp = (struct file *)f->f_fsdata;
d561 1
a561 5
ufs_read(f, start, size, resid)
	struct open_file *f;
	void *start;
	size_t size;
	size_t *resid;	/* out */
d563 3
a565 4
	register struct file *fp = (struct file *)f->f_fsdata;
	register size_t csize;
	char *buf;
	size_t buf_size;
a566 1
	register char *addr = start;
d595 1
a595 5
ufs_write(f, start, size, resid)
	struct open_file *f;
	void *start;
	size_t size;
	size_t *resid;	/* out */
d602 1
a602 4
ufs_seek(f, offset, where)
	struct open_file *f;
	off_t offset;
	int where;
d604 1
a604 1
	register struct file *fp = (struct file *)f->f_fsdata;
d623 1
a623 3
ufs_stat(f, sb)
	struct open_file *f;
	struct stat *sb;
d625 1
a625 1
	register struct file *fp = (struct file *)f->f_fsdata;
d637 1
a637 3
ufs_readdir(f, name)
	struct open_file *f;
	char	*name;
d639 2
a640 2
	register struct file *fp = (struct file *)f->f_fsdata;
	char *buf;
a641 1
	register struct direct *dp, *edp;
d643 1
d688 1
a688 2
ffs_oldfscompat(fs)
	struct fs *fs;
@


1.14
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.13 2002/03/14 01:27:07 millert Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.12 1998/02/23 20:32:31 niklas Exp $	*/
d38 1
a38 1
 *  
d44 1
a44 1
 * 
d50 1
a50 1
 * 
d54 1
a54 1
 * 
d56 1
a56 1
 * 
d61 1
a61 1
 * 
d128 2
a129 2
		fsbtodb(fs, ino_to_fsba(fs, inumber)), fs->fs_bsize,
		buf, &rsize);
d156 1
a156 1
	return (rc);	 
d235 1
a235 1
					alloc(fs->fs_bsize);
d238 2
a239 4
				fsbtodb(fp->f_fs, ind_block_num),
				fs->fs_bsize,
				fp->f_blk[level],
				&fp->f_blksize[level]);
d299 2
a300 2
				fsbtodb(fs, disk_block),
				block_size, fp->f_buf, &fp->f_buf_size);
d405 1
a405 1
		SBLOCK, SBSIZE, (char *)fs, &buf_size);
d508 1
a508 1
				      (unsigned) link_len);
d522 1
a522 1
				
d525 2
a526 2
					F_READ, fsbtodb(fs, disk_block),
					fs->fs_bsize, buf, &buf_size);
d708 1
a708 1
				((u_int8_t *)edp - (u_int8_t *)dp);
@


1.12
log
@strong signedness typing a version of egcs I tried months ago wanted
me to fix.  I am not sure these are necessary for gas 2.8 but I figure I
would commit them anyhow.
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.11 1997/04/02 05:28:30 mickey Exp $	*/
d100 4
a103 4
static int	read_inode __P((ino_t, struct open_file *));
static int	block_map __P((struct open_file *, daddr_t, daddr_t *));
static int	buf_read_file __P((struct open_file *, char **, size_t *));
static int	search_directory __P((char *, struct open_file *, ino_t *));
d105 1
a105 1
static void	ffs_oldfscompat __P((struct fs *));
@


1.12.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.12 1998/02/23 20:32:31 niklas Exp $	*/
d100 4
a103 4
static int	read_inode(ino_t, struct open_file *);
static int	block_map(struct open_file *, daddr_t, daddr_t *);
static int	buf_read_file(struct open_file *, char **, size_t *);
static int	search_directory(char *, struct open_file *, ino_t *);
d105 1
a105 1
static void	ffs_oldfscompat(struct fs *);
@


1.12.10.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 4
a103 4
static int	read_inode(ino_t, struct open_file *);
static int	block_map(struct open_file *, daddr_t, daddr_t *);
static int	buf_read_file(struct open_file *, char **, size_t *);
static int	search_directory(char *, struct open_file *, ino_t *);
d105 1
a105 1
static void	ffs_oldfscompat(struct fs *);
@


1.12.10.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.12.10.1 2002/03/28 15:02:00 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
d38 1
a38 1
 *
d44 1
a44 1
 *
d50 1
a50 1
 *
d54 1
a54 1
 *
d56 1
a56 1
 *
d61 1
a61 1
 *
d128 2
a129 2
	    fsbtodb(fs, ino_to_fsba(fs, inumber)), fs->fs_bsize,
	    buf, &rsize);
d156 1
a156 1
	return (rc);
d235 1
a235 1
				    alloc(fs->fs_bsize);
d238 4
a241 2
			    fsbtodb(fp->f_fs, ind_block_num), fs->fs_bsize,
			    fp->f_blk[level], &fp->f_blksize[level]);
d301 2
a302 2
			    fsbtodb(fs, disk_block),
			    block_size, fp->f_buf, &fp->f_buf_size);
d407 1
a407 1
	    SBLOCK, SBSIZE, (char *)fs, &buf_size);
d510 1
a510 1
				    (unsigned) link_len);
d524 1
a524 1

d527 2
a528 2
				    F_READ, fsbtodb(fs, disk_block),
				    fs->fs_bsize, buf, &buf_size);
d710 1
a710 1
			    ((u_int8_t *)edp - (u_int8_t *)dp);
@


1.12.10.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a74 1
#include "ufs.h"
d82 1
a82 1
	struct ufs1_dinode	f_di;		/* copy of on-disk inode */
d108 3
a110 1
read_inode(ino_t inumber, struct open_file *f)
d112 2
a113 2
	struct file *fp = (struct file *)f->f_fsdata;
	struct fs *fs = fp->f_fs;
d134 1
a134 1
		struct ufs1_dinode *dp;
d136 1
a136 1
		dp = (struct ufs1_dinode *)buf;
d144 1
a144 1
		int level;
d160 4
a163 1
block_map(struct open_file *f, daddr_t file_block, daddr_t *disk_block_p)
d165 7
a171 4
	struct file *fp = (struct file *)f->f_fsdata;
	daddr_t ind_block_num, *ind_p;
	struct fs *fs = fp->f_fs;
	int level, idx, rc;
d255 1
d264 4
a267 1
buf_read_file(struct open_file *f, char **buf_p, size_t *size_p)
d269 5
a273 3
	struct file *fp = (struct file *)f->f_fsdata;
	struct fs *fs = fp->f_fs;
	daddr_t file_block, disk_block;
a274 1
	long off;
d326 9
a334 5
search_directory(char *name, struct open_file *f, ino_t *inumber_p)
{
	struct file *fp = (struct file *)f->f_fsdata;
	int namlen, length, rc;
	struct direct *dp, *edp;
d336 2
a337 1
	char *buf;
d376 3
a378 1
ufs_open(char *path, struct open_file *f)
d380 2
a381 1
	char namebuf[MAXPATHLEN+1], *cp, *ncp, *buf = NULL;
a382 1
	int rc, c, nlinks = 0;
d384 2
d387 3
a389 1
	struct fs *fs;
d418 2
a419 2
		int mult;
		int level;
d455 1
a455 1
			int len = 0;
d511 1
a511 1
				struct fs *fs = fp->f_fs;
d559 2
a560 1
ufs_close(struct open_file *f)
d562 1
a562 1
	struct file *fp = (struct file *)f->f_fsdata;
d585 5
a589 1
ufs_read(struct open_file *f, void *start, size_t size, size_t *resid)
d591 4
a594 3
	struct file *fp = (struct file *)f->f_fsdata;
	char *buf, *addr = start;
	size_t csize, buf_size;
d596 1
d625 5
a629 1
ufs_write(struct open_file *f, void *start, size_t size, size_t *resid)
d636 4
a639 1
ufs_seek(struct open_file *f, off_t offset, int where)
d641 1
a641 1
	struct file *fp = (struct file *)f->f_fsdata;
d660 3
a662 1
ufs_stat(struct open_file *f, struct stat *sb)
d664 1
a664 1
	struct file *fp = (struct file *)f->f_fsdata;
d676 3
a678 1
ufs_readdir(struct open_file *f, char *name)
d680 2
a681 2
	struct file *fp = (struct file *)f->f_fsdata;
	struct direct *dp, *edp;
d683 1
a684 1
	char *buf;
d729 2
a730 1
ffs_oldfscompat(struct fs *fs)
@


1.11
log
@fix readdir a little bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.10 1997/03/25 20:30:44 niklas Exp $	*/
d132 1
a132 1
	if (rsize != fs->fs_bsize) {
d244 1
a244 1
			if (fp->f_blksize[level] != fs->fs_bsize)
@


1.10
log
@Get rid of userland includes
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.9 1997/02/16 14:39:37 mickey Exp $	*/
d698 1
a698 1
			return 0;
@


1.9
log
@opendir, readdir, closedir (define NO_READDIR, if none required)
minor fix in cd9660
only ufs working, all the others are on the list....
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.8 1996/12/08 15:15:58 niklas Exp $	*/
a76 2

#include <string.h>
@


1.8
log
@Merge to NetBSD 961207
@
text
@d1 1
a1 1
/*	$OpenBSD: ufs.c,v 1.7 1996/10/16 14:02:55 mickey Exp $	*/
d681 48
@


1.7
log
@include <sys/stat.h>
@
text
@d1 2
a2 2
/*	$OpenBSD: ufs.c,v 1.6 1996/09/23 14:19:06 mickey Exp $	*/
/*	$NetBSD: ufs.c,v 1.14.4.1 1996/06/02 12:08:45 ragge Exp $	*/
d559 2
a560 1
	if (rc)
d562 1
@


1.6
log
@add OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 1
@


1.5
log
@pull string.h at right place
@
text
@d1 1
@


1.4
log
@from netbsd: The read_inode() function now returns the result of the
strategy function instead of success in all cases
@
text
@d1 1
a1 1
/*	$NetBSD: ufs.c,v 1.14 1996/01/13 22:25:44 leo Exp $	*/
a68 1
#include <string.h>
d75 2
@


1.3
log
@from netbsd; 64-bit cleanup
@
text
@d1 1
a1 1
/*	$NetBSD: ufs.c,v 1.13 1995/10/20 00:42:21 cgd Exp $	*/
d155 1
a155 1
	return (0);	 
@


1.2
log
@shrink bootblocks by splitting libsa contents into more files. from
waldi@@moacs.indiv.nl.net, netbsd pr#1817
@
text
@d1 1
a1 1
/*	$NetBSD: ufs.c,v 1.12 1995/09/17 00:49:48 pk Exp $	*/
d91 1
a91 1
	u_long		f_blksize[NIADDR];
d95 1
a95 1
	u_int		f_buf_size;	/* size of data block */
d99 4
d104 1
a104 1
void ffs_oldfscompat __P((struct fs *));
d118 1
a118 1
	u_int rsize;
d127 2
a128 1
		fsbtodb(fs, ino_to_fsba(fs, inumber)), fs->fs_bsize, buf, &rsize);
d155 1
a155 1
	return (rc);	 
d240 1
a240 1
				(u_int *)&fp->f_blksize[level]);
d272 1
a272 1
	u_int *size_p;		/* out */
d279 1
a279 1
	long block_size;
d340 1
a340 1
	u_int buf_size;
d391 1
a391 1
	u_int buf_size;
d514 1
a514 1
				u_int buf_size;
d597 1
a597 1
	u_int buf_size;
d683 1
a683 1
void
@


1.1
log
@Initial revision
@
text
@d150 1
a150 1
	return (0);	 
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
