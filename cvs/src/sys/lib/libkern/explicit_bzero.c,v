head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.14
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.10
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.6
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.8
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.1.0.16
	OPENBSD_5_5_BASE:1.1
	OPENBSD_5_4:1.1.0.12
	OPENBSD_5_4_BASE:1.1
	OPENBSD_5_3:1.1.0.10
	OPENBSD_5_3_BASE:1.1
	OPENBSD_5_2:1.1.0.8
	OPENBSD_5_2_BASE:1.1
	OPENBSD_5_1_BASE:1.1
	OPENBSD_5_1:1.1.0.6
	OPENBSD_5_0:1.1.0.4
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.2
	OPENBSD_4_9_BASE:1.1;
locks; strict;
comment	@ * @;


1.3
date	2014.06.21.02.34.26;	author matthew;	state Exp;
branches;
next	1.2;
commitid	8bSzKuB5PlXjIw16;

1.2
date	2014.06.10.04.16.57;	author deraadt;	state Exp;
branches;
next	1.1;
commitid	cdWt8Fq9cWtmBa8c;

1.1
date	2011.01.10.23.23.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Protect explicit_bzero() from link-time optimization

Modern compiler toolchains are capable of optimizing even across
translation unit boundaries, so simply moving the memory clearing into
a separate function is not guaranteed to clear memory.

To avoid this, we take advantage of ELF weak symbol semantics, and
insert a call to an empty, weakly named function.  The semantics of
calling this function aren't determinable until load time, so the
compiler and linker need to keep the memset() call.

There are still ways a toolchain might defeat this trick (e.g.,
optimistically expecting the weak symbol to not be overloaded, and
only calling memset() if it is; promoting weak symbols to strong
symbols at link-time when emitting a static binary because they won't
be interposed; implementing load-time optimizations).  But at least
for the foreseeable future, these seem unlikely.

ok deraadt
@
text
@/*	$OpenBSD: explicit_bzero.c,v 1.2 2014/06/10 04:16:57 deraadt Exp $ */
/*
 * Public domain.
 * Written by Matthew Dempsky.
 */

#include <lib/libkern/libkern.h>

__attribute__((weak)) void __explicit_bzero_hook(void *, size_t);

__attribute__((weak)) void
__explicit_bzero_hook(void *buf, size_t len)
{
}

void
explicit_bzero(void *buf, size_t len)
{
	memset(buf, 0, len);
	__explicit_bzero_hook(buf, len);
}
@


1.2
log
@mop up #ifdef _KERNEL goo; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: explicit_bzero.c,v 1.1 2011/01/10 23:23:56 tedu Exp $ */
d4 1
a4 1
 * Written by Ted Unangst
d9 7
a15 3
/*
 * explicit_bzero - don't let the compiler optimize away bzero
 */
d17 1
a17 1
explicit_bzero(void *p, size_t n)
d19 2
a20 1
	bzero(p, n);
@


1.1
log
@add a new function, explicit_bzero, to be used for erasing "secret" stuff.
unlike normal bzero, we guarantee that the compiler will not optimize out
calls to this function for otherwise dead variables.
to be adjusted as needed when compilers and linkers get smarter.
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a6 3
#if !defined(_KERNEL) && !defined(_STANDALONE)
#include <string.h>
#else
a7 1
#endif
@

