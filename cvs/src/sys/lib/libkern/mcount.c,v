head	1.13;
access;
symbols
	OPENBSD_6_2:1.13.0.20
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.13.0.18
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.14
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.10
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.12
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.2
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.24
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.20
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.16
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.14
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.12
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.5.0.10
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.8
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.10
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2013.03.12.09.37.16;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2013.02.12.08.06.22;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2013.02.11.17.05.25;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2013.01.16.23.38.14;	author dlg;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.27.23.59.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.07.00.38.32;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.22.16.06.34;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.22.13.46.54;	author art;	state Exp;
branches;
next	1.4;

1.4
date	97.11.07.15.56.45;	author niklas;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	97.01.27.20.34.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.10.10.48;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.49;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.49;	author deraadt;	state Exp;
branches;
next	;

1.4.10.1
date	2000.03.02.07.04.41;	author niklas;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2003.06.07.11.03.41;	author ho;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Fix kernel profiling on MP systems by using per-CPU buffers and teach
kgmon(8) to deal with them, this time without public header changes.

Previously various CPUs were iterating over the same global buffer at
the same time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok deraadt@@, mikeb@@, haesbaert@@
@
text
@/*	$OpenBSD: mcount.c,v 1.12 2013/02/12 08:06:22 mpi Exp $	*/
/*	$NetBSD: mcount.c,v 1.3.6.1 1996/06/12 04:23:01 cgd Exp $	*/

/*-
 * Copyright (c) 1983, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/gmon.h>

/*
 * mcount is called on entry to each function compiled with the profiling
 * switch set.  _mcount(), which is declared in a machine-dependent way
 * with _MCOUNT_DECL, does the actual work and is either inlined into a
 * C routine or called by an assembly stub.  In any case, this magic is
 * taken care of by the MCOUNT definition in <machine/profile.h>.
 *
 * _mcount updates data structures that represent traversals of the
 * program's call graph edges.  frompc and selfpc are the return
 * address and function address that represents the given call graph edge.
 */
_MCOUNT_DECL(u_long frompc, u_long selfpc) __used;
/* _mcount; may be static, inline, etc */
_MCOUNT_DECL(u_long frompc, u_long selfpc)
{
	u_short *frompcindex;
	struct tostruct *top, *prevtop;
	struct gmonparam *p;
	long toindex;
#ifdef _KERNEL
	int s;

	/*
	 * Do not profile execution if memory for the current CPU
	 * desciptor and profiling buffers has not yet been allocated
	 * or if the CPU we are running on has not yet set its trap
	 * handler.
	 */
	if (gmoninit == 0)
		return;

	if ((p = curcpu()->ci_gmon) == NULL)
		return;
#else
	p = &_gmonparam;
#endif
	/*
	 * check that we are profiling
	 * and that we aren't recursively invoked.
	 */
	if (p->state != GMON_PROF_ON)
		return;
#ifdef _KERNEL
	MCOUNT_ENTER;
#else
	p->state = GMON_PROF_BUSY;
#endif
	/*
	 * check that frompcindex is a reasonable pc value.
	 * for example:	signal catchers get called from the stack,
	 *		not from text space.  too bad.
	 */
	frompc -= p->lowpc;
	if (frompc > p->textsize)
		goto done;

#if (HASHFRACTION & (HASHFRACTION - 1)) == 0
	if (p->hashfraction == HASHFRACTION)
		frompcindex =
		    &p->froms[frompc / (HASHFRACTION * sizeof(*p->froms))];
	else
#endif
		frompcindex =
		    &p->froms[frompc / (p->hashfraction * sizeof(*p->froms))];
	toindex = *frompcindex;
	if (toindex == 0) {
		/*
		 *	first time traversing this arc
		 */
		toindex = ++p->tos[0].link;
		if (toindex >= p->tolimit)
			/* halt further profiling */
			goto overflow;

		*frompcindex = toindex;
		top = &p->tos[toindex];
		top->selfpc = selfpc;
		top->count = 1;
		top->link = 0;
		goto done;
	}
	top = &p->tos[toindex];
	if (top->selfpc == selfpc) {
		/*
		 * arc at front of chain; usual case.
		 */
		top->count++;
		goto done;
	}
	/*
	 * have to go looking down chain for it.
	 * top points to what we are looking at,
	 * prevtop points to previous top.
	 * we know it is not at the head of the chain.
	 */
	for (; /* goto done */; ) {
		if (top->link == 0) {
			/*
			 * top is end of the chain and none of the chain
			 * had top->selfpc == selfpc.
			 * so we allocate a new tostruct
			 * and link it to the head of the chain.
			 */
			toindex = ++p->tos[0].link;
			if (toindex >= p->tolimit)
				goto overflow;

			top = &p->tos[toindex];
			top->selfpc = selfpc;
			top->count = 1;
			top->link = *frompcindex;
			*frompcindex = toindex;
			goto done;
		}
		/*
		 * otherwise, check the next arc on the chain.
		 */
		prevtop = top;
		top = &p->tos[top->link];
		if (top->selfpc == selfpc) {
			/*
			 * there it is.
			 * increment its count
			 * move it to the head of the chain.
			 */
			top->count++;
			toindex = prevtop->link;
			prevtop->link = top->link;
			top->link = *frompcindex;
			*frompcindex = toindex;
			goto done;
		}
	}
done:
#ifdef _KERNEL
	MCOUNT_EXIT;
#else
	p->state = GMON_PROF_ON;
#endif
	return;
overflow:
	p->state = GMON_PROF_ERROR;
#ifdef _KERNEL
	MCOUNT_EXIT;
#endif
	return;
}

/*
 * Actual definition of mcount function.  Defined in <machine/profile.h>,
 * which is included by <sys/gmon.h>.
 */
MCOUNT
@


1.12
log
@Back out per-CPU kernel profiling, it shouldn't modify a public header
at this moment.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.11 2013/02/11 17:05:25 mpi Exp $	*/
a45 4
 * 
 * Note: the original BSD code used the same variable (frompcindex) for
 * both frompcindex and frompc.  Any reasonable, modern compiler will
 * perform this optimization.
d48 2
a49 1
_MCOUNT_DECL(u_long frompc, u_long selfpc)	/* _mcount; may be static, inline, etc */
a56 1
#endif
d58 12
d71 1
a167 1
		
@


1.11
log
@Fix kernel profiling on MP systems by using per-CPU buffer. Previously
various CPUs were iterating over the same global buffer at the same
time to modify it and never ended.

This diff includes some ideas submited by Thor Simon to NetBSD via miod@@.

ok mikeb@@, haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.10 2013/01/16 23:38:14 dlg Exp $	*/
d46 4
d52 1
a52 2
/* _mcount; may be static, inline, etc */
_MCOUNT_DECL(u_long frompc, u_long selfpc)
d60 1
a61 12
	/*
	 * Do not profile execution if memory for the current CPU
	 * desciptor and profiling buffers has not yet been allocated
	 * or if the CPU we are running on has not yet set its trap
	 * handler.
	 */
	if (gmoninit == 0)
		return;

	if ((p = curcpu()->ci_gmon) == NULL)
		return;
#else
a62 1
#endif
d159 1
@


1.10
log
@replace __attribute__((unused)) with __used, which will be defined to the
right thing for whichever compiler we use.

found while trying to build a profiled kernel on sparc64. solution found
by guenther and refined by miod and kettenis.

ok guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.9 2009/10/27 23:59:35 deraadt Exp $	*/
a45 4
 * 
 * Note: the original BSD code used the same variable (frompcindex) for
 * both frompcindex and frompc.  Any reasonable, modern compiler will
 * perform this optimization.
d48 2
a49 1
_MCOUNT_DECL(u_long frompc, u_long selfpc)	/* _mcount; may be static, inline, etc */
a56 1
#endif
d58 12
d71 1
a167 1
		
@


1.9
log
@rcsid[] and sccsid[] and copyright[] are essentially unmaintained (and
unmaintainable).  these days, people use source.  these id's do not provide
any benefit, and do hurt the small install media
(the 33,000 line diff is essentially mechanical)
ok with the idea millert, ok dms
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.8 2004/08/07 00:38:32 deraadt Exp $	*/
a49 4
 *
 * XXX - the unused attribute is there because some archs define _mcount
 *       as static and gcc doesn't check for function calls in assembler
 *       stubs.
d51 1
a51 1
_MCOUNT_DECL(u_long frompc, u_long selfpc) __attribute__((unused));
@


1.8
log
@ansi and some missing protos
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.7 2004/07/22 16:06:34 art Exp $	*/
a31 8

#if !defined(lint) && !defined(_KERNEL) && defined(LIBC_SCCS)
#if 0
static char sccsid[] = "@@(#)mcount.c	8.1 (Berkeley) 6/4/93";
#else
static char rcsid[] = "$OpenBSD: mcount.c,v 1.7 2004/07/22 16:06:34 art Exp $";
#endif
#endif
@


1.7
log
@Remove some register keywords to make this compile on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.6 2003/06/02 23:28:08 millert Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.6 2003/06/02 23:28:08 millert Exp $";
d64 1
a64 2
_MCOUNT_DECL(frompc, selfpc)	/* _mcount; may be static, inline, etc */
	register u_long frompc, selfpc;
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.5 2000/02/22 13:46:54 art Exp $	*/
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.5 2000/02/22 13:46:54 art Exp $";
d67 4
a70 4
	register u_short *frompcindex;
	register struct tostruct *top, *prevtop;
	register struct gmonparam *p;
	register long toindex;
d72 1
a72 1
	register int s;
@


1.5
log
@Add an __attribute__((unused))__ to the function declared by _MCOUNT_DECL,
sparc defines that function as static and gcc doesn't understand that it gets
called from an assembler stub.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.4 1997/11/07 15:56:45 niklas Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
d37 1
a37 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.4 1997/11/07 15:56:45 niklas Exp $";
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.3.6.1 1996/06/12 04:23:01 cgd Exp $	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.3.6.1 1996/06/12 04:23:01 cgd Exp $";
d62 4
d67 1
a67 1
_MCOUNT_DECL(u_long frompc, u_long selfpc);
@


1.4.10.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
static char rcsid[] = "$OpenBSD$";
a61 4
 *
 * XXX - the unused attribute is there because some archs define _mcount
 *       as static and gcc doesn't check for function calls in assembler
 *       stubs.
d63 1
a63 1
_MCOUNT_DECL(u_long frompc, u_long selfpc) __attribute__((unused));
@


1.4.10.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mcount.c,v 1.4.10.1 2000/03/02 07:04:41 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d41 1
a41 1
static char rcsid[] = "$OpenBSD: mcount.c,v 1.4.10.1 2000/03/02 07:04:41 niklas Exp $";
@


1.3
log
@prototyping problems, PR#71, felix@@mamba.pond.sub.org
@
text
@d1 1
d41 1
a41 1
static char rcsid[] = "$NetBSD: mcount.c,v 1.3.6.1 1996/06/12 04:23:01 cgd Exp $";
@


1.2
log
@sync to libc
@
text
@d62 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mcount.c,v 1.3 1995/03/28 20:01:02 jtc Exp $	*/
d37 1
d39 3
d94 8
a101 1
	frompcindex = &p->froms[frompc / (p->hashfraction * sizeof(*p->froms))];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
