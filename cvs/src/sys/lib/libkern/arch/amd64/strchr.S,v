head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.12
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.2.0.30
	OPENBSD_5_6_BASE:1.2
	OPENBSD_5_5:1.2.0.28
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.24
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.22
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.20
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.18
	OPENBSD_5_0:1.2.0.16
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.14
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.12
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.10
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.18
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.16
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.14
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.12
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.10
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.8
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.6
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.4
	OPENBSD_3_5_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@# @;


1.3
date	2014.12.09.15.13.57;	author reyk;	state Exp;
branches;
next	1.2;
commitid	JJgbPyzWXRvH0tuk;

1.2
date	2007.11.25.18.25.35;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.28.01.39.40;	author mickey;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2004.02.19.10.57.18;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Like libc, also for the kernel: Import new amd64 assembly versions of
strchr/index, strrchr/rindex, and strlen that provide a significantly
faster performance than our previous .c or .S implementations.  Based
on NetBSD's code.

Tested with different amd64 CPUs.

ok deraadt@@ mikeb@@
@
text
@/*	$OpenBSD$	*/
/*	$NetBSD: strchr.S,v 1.7 2014/03/22 19:16:34 jakllsch Exp $	*/

/*-
 * Copyright (c) 2009 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by David Laight.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/* See comments in strlen.S about checking words for byte values */

#include <machine/asm.h>

STRONG_ALIAS(index, strchr)

/*
 * On entry %rdi is the buffer and the low byte of %rsi (%sil) the
 * character to search for.
 *
 * Registers %rdx, %rcx, %r8-%r11 and %rax are also usable
 */

ENTRY(strchr)
	movabsq	$0x0101010101010101,%r8

	movzbq	%sil,%rdx	/* value to search for (c) */
	/* These imul are 'directpath' on athlons, so are fast */
	imul	$0x80,%r8,%r9	/* 0x8080808080808080 */
	imul	%r8,%rdx	/* (c) copied to all bytes */
	test	$7,%dil
	jnz	20f		/* jump if misaligned */

	_ALIGN_TEXT		/* one byte nop */
1:
	movq	(%rdi),%rax	/* bytes to check (x) */
2:
	addq	$8,%rdi
	mov	%rax,%r10
	mov	%rax,%r11	/* for 'char' check */
	not	%r10		/* invert of data (~x) */

	xorq	%rdx,%r11	/* convert 'char' test to one for NUL */
	subq	%r8,%rax	/* x - 0x10 */
	movq	%r10,%rsi	/* ~x */
	subq	%r8,%r11	/* (x ^ c) - 0x10 */
/*
 * Here we could check ((x - 0x10) | ((x ^ c) - 0x10)) & 0x80
 * and short-circuit the case where no top bits are set, and
 * we continue the loop.
 * However it needs 3 more clocks that are difficult to interleave
 * in the existing dependency chain ...
 */
	andq	%r9,%rax	/* (x - 0x10) & 0x80 */
	xorq	%rdx,%rsi	/* c ^ ~x == ~(c ^ x) */
	andq	%r9,%r11	/* ((x ^ c) - 0x10) & 0x80 */
	andq	%r10,%rax	/* (x - 0x10) & 0x80 & ~x */
	jne	10f		/* jump if string ends */
	andq	%rsi,%r11	/* ((x ^ c) - 0x10) & 0x80 & ~(x ^ c) */
	je	1b		/* jump if no match */

	/* Found char, since LE can use bit scan */
	bsf	%r11,%r11	/* 7, 15, 23 ... 63 */
8:	shr	$3,%r11		/* 0, 1, 2 .. 7 */
	lea	-8(%r11,%rdi),%rax
	ret

/* End of string, check whether char is before NUL */
	_ALIGN_TEXT		/* adds three byte nop */
10:
	bsf	%rax,%rax	/* count to NUL */
	andq	%rsi,%r11	/* check for char in last 8 bytes */
	je	11f
	bsf	%r11,%r11	/* NUL and char - see which was first */
	cmp	%r11,%rax
	jae	8b		/* return 'found' if same - searching for NUL */
11:	xor	%eax,%eax	/* char not found */
	ret

/* Source misaligned: read aligned word and make low bytes invalid */
/* I (dsl) think a _ALIGN_TEXT here will slow things down! */
20:
	xor	%rcx,%rcx
	sub	%dil,%cl	/* Convert low address values 1..7 ... */
	sbb	%rsi,%rsi	/* carry was set, so %rsi now ~0u! */
	and	$7,%cl		/* ... to 7..1 */
	and	$~7,%dil	/* move address to start of word */
	shl	$3,%cl		/* now 56, 48 ... 16, 8 */
	movq	(%rdi),%rax	/* aligned word containing first data */
	xor	%rdx,%rsi	/* invert of search pattern (~c) */
	je	22f		/* searching for 0xff */
21:	shr	%cl,%rsi	/* ~c in low bytes */
	or	%rsi,%rax	/* set some bits making low bytes invalid */
	jmp	2b

/* We are searching for 0xff, so can't use ~pattern for invalid value */
22:
	mov	%r8,%r10	/* 0x01 pattern */
	lea	(%r8,%r8),%rsi	/* 0x02 - bits gets set (above) */
	not	%r10		/* now 0xfe */
	sar	%cl,%r10	/* top bytes 0xff */
	and	%r10,%rax	/* clear lsb from unwanted low bytes */
	jmp	21b
@


1.2
log
@libkern, begone.  Move to a new mechanism where config(8)'s "file"
directive can select between MI and MD versions of these files.  At
the same time, adjust the boot programs to pick exactly what they need,
instead of the 7 or 8 mechanisms previously used.

There will be some fallout from this, but testing it all by myself is a
ridiculously slow process; it will be finished in-tree.

Various developers were very nice and avoided making fun of me when I
was gibbering in the corner..
@
text
@d1 30
a30 4
/*
 * Written by J.T. Conklin <jtc@@netbsd.org>.
 * Public domain.
 * Adapted for NetBSD/x86_64 by Frank van der Linden <fvdl@@wasabisystems.com>
d33 2
d37 9
d47 41
a87 11
	movq	%rdi,%rax
	movb	%sil,%cl
L1:
	movb	(%rax),%dl
	cmpb	%dl,%cl			/* found char? */
	je 	L2
	incq	%rax
	testb	%dl,%dl			/* null terminator? */
	jnz	L1
	xorq	%rax,%rax
L2:
d89 37
@


1.1
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 5
a5 1
/*	$NetBSD: strchr.S,v 1.1 2001/06/19 00:22:47 fvdl Exp $	*/
d7 15
a21 2
#define STRCHR
#include "index.S"
@


1.1.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@@

