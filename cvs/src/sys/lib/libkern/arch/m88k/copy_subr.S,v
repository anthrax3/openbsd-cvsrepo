head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.16
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.14
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.10
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.12
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.4
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.6.0.8
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.4.0.2
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.1.0.12
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.14
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.10
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.8
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.6
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.4
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.2
	OPENBSD_4_1_BASE:1.1;
locks; strict;
comment	@# @;


1.6
date	2013.06.15.18.38.18;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2013.06.13.03.59.03;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.05.11.20.56;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.27.20.42.47;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2010.04.20.20.28.20;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.17.22.32.38;	author miod;	state Exp;
branches;
next	;


desc
@@


1.6
log
@give bcopy() the ovbcopy() semantics
@
text
@/*	$OpenBSD: copy_subr.S,v 1.5 2013/06/13 03:59:03 deraadt Exp $	*/
/*
 * Mach Operating System
 * Copyright (c) 1993-1992 Carnegie Mellon University
 * Copyright (c) 1991 OMRON Corporation
 * Copyright (c) 1996 Nivas Madhur
 * Copyright (c) 1998 Steve Murphree, Jr.
 * All Rights Reserved.
 *
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 *
 * CARNEGIE MELLON AND OMRON ALLOW FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON AND OMRON DISCLAIM ANY LIABILITY OF ANY KIND
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 *
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#include <machine/asm.h>

/*
 * copy count bytes of data from source to destination
 * Don Harper (don@@omron.co.jp), Omron Corporation.
 */

#if defined(MEMCPY) || defined(MEMMOVE)
#define	SRC	%r3
#define	DEST	%r2
#define	SAVE	%r5
#else
#define	SRC	%r2
#define	DEST	%r3
#endif
#define	LEN	%r4

#ifdef MEMCPY
ENTRY(memcpy)
#endif
#ifdef MEMMOVE
ENTRY(memmove)
#endif
#ifdef BCOPY
#define	OVBCOPY
ENTRY(bcopy)
#endif

#if defined(MEMCPY) || defined(MEMMOVE)
	or	SAVE, DEST, %r0
#endif

	bcnd	eq0,LEN,_ASM_LABEL(bcopy_out)	/* nothing to do if == 0 */

/*
 * check position of source and destination data
 */
	cmp 	%r9,SRC,DEST	/* compare source address to destination */
	bb1	eq,%r9,_ASM_LABEL(bcopy_out)	/* nothing to do if equal */
#if defined(MEMMOVE) || defined(OVBCOPY)
	bb1	lo,%r9,_ASM_LABEL(bcopy_reverse)	/* reverse copy if src < dest */
#endif

/*
 * source address is greater than destination address, or we do
 * not have to care about overlapping areas: copy forward
 */
	cmp 	%r9,LEN,16	/* see if we have at least 16 bytes */
	bb1	lt,%r9,_ASM_LABEL(f_byte_copy)	/* copy bytes for small data length */
/*
 * determine copy strategy based on alignment of source and destination
 */
	mask	%r6,SRC,3	/* get 2 low order bits of source address */
	mask	%r7,DEST,3	/* get 2 low order bits of destination addr */
	mak	%r6,%r6,0<4>	/* convert source bits to table offset */
	mak	%r7,%r7,0<2>	/* convert destination bits to table offset */
	or.u	%r12,%r0,%hi16(_ASM_LABEL(f_strat))
	or	%r12,%r12,%lo16(_ASM_LABEL(f_strat))
	addu	%r6,%r6,%r7	/* compute final table offset for strategy */
	ld	%r12,%r12,%r6	/* load the strategy routine */
	jmp	%r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(f_3byte_word_copy)
	ld.bu	%r6,SRC,0	/* load byte from source */
	ld.bu	%r7,SRC,1	/* load byte from source */
	ld.bu	%r8,SRC,2	/* load byte from source */
	st.b	%r6,DEST,0	/* store byte to destination */
	st.b	%r7,DEST,1	/* store byte to destination */
	st.b	%r8,DEST,2	/* store byte to destination */
	addu	SRC,SRC,3	/* increment source pointer */
	addu	DEST,DEST,3	/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	LEN,LEN,3	/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(f_1half_word_copy)
	ld.hu	%r6,SRC,0	/* load half-word from source */
	st.h	%r6,DEST,0	/* store half-word to destination */
	addu	SRC,SRC,2	/* increment source pointer */
	addu	DEST,DEST,2	/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* copy full words */
	 subu	LEN,LEN,2	/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(f_1byte_word_copy)
	ld.bu	%r6,SRC,0	/* load 1 byte from source */
	st.b	%r6,DEST,0	/* store 1 byte to destination */
	addu	SRC,SRC,1	/* increment source pointer */
	addu	DEST,DEST,1	/* increment destination pointer */
	subu	LEN,LEN,1	/* decrement remaining length */
	/* FALLTHROUGH */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(f_word_copy)
	cmp	%r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,%r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld	%r6,SRC,0	/* load first word */
	ld	%r7,SRC,4	/* load second word */
	ld	%r8,SRC,8	/* load third word */
	ld	%r9,SRC,12	/* load fourth word */
	st	%r6,DEST,0	/* store first word */
	st	%r7,DEST,4	/* store second word */
	st 	%r8,DEST,8	/* store third word */
	st 	%r9,DEST,12	/* store fourth word */
	addu	SRC,SRC,16	/* increment source pointer */
	addu	DEST,DEST,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_word_copy)	/* branch to copy another block */
	 subu	LEN,LEN,16	/* decrement remaining length */

ASLOCAL(f_1byte_half_copy)
	ld.bu	%r6,SRC,0	/* load 1 byte from source */
	st.b	%r6,DEST,0	/* store 1 byte to destination */
	addu	SRC,SRC,1	/* increment source pointer */
	addu	DEST,DEST,1	/* increment destination pointer */
	subu	LEN,LEN,1	/* decrement remaining length */
	/* FALLTHROUGH */

ASLOCAL(f_half_copy)
	cmp	%r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,%r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld.hu	%r6,SRC,0	/* load first half-word */
	ld.hu	%r7,SRC,2	/* load second half-word */
	ld.hu	%r8,SRC,4	/* load third half-word */
	ld.hu	%r9,SRC,6	/* load fourth half-word */
	ld.hu	%r10,SRC,8	/* load fifth half-word */
	ld.hu	%r11,SRC,10	/* load sixth half-word */
	ld.hu	%r12,SRC,12	/* load seventh half-word */
	ld.hu	%r13,SRC,14	/* load eighth half-word */
	st.h	%r6,DEST,0	/* store first half-word */
	st.h	%r7,DEST,2	/* store second half-word */
	st.h 	%r8,DEST,4	/* store third half-word */
	st.h 	%r9,DEST,6	/* store fourth half-word */
	st.h	%r10,DEST,8	/* store fifth half-word */
	st.h	%r11,DEST,10	/* store sixth half-word */
	st.h 	%r12,DEST,12	/* store seventh half-word */
	st.h 	%r13,DEST,14	/* store eighth half-word */
	addu	SRC,SRC,16	/* increment source pointer */
	addu	DEST,DEST,16	/* increment destination pointer */
	br.n	_ASM_LABEL(f_half_copy)	/* branch to copy another block */
	 subu	LEN,LEN,16	/* decrement remaining length */

ASLOCAL(f_byte_copy)
	bcnd	eq0,LEN,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	ld.bu	%r6,SRC,0	/* load byte from source */
	st.b	%r6,DEST,0	/* store byte in destination */
	addu	SRC,SRC,1	/* increment source pointer */
	addu	DEST,DEST,1	/* increment destination pointer */
	br.n	_ASM_LABEL(f_byte_copy)	/* branch for next byte */
	 subu	LEN,LEN,1	/* decrement remaining length */

#if defined(MEMMOVE) || defined(OVBCOPY)
/*
 * source address is less than destination address, copy in reverse
 */
ASLOCAL(bcopy_reverse)
/*
 * start copy pointers at end of data
 */
	addu	SRC,SRC,LEN	/* start source at end of data */
	addu	DEST,DEST,LEN	/* start destination at end of data */
/*
 * check for short data
 */
	cmp 	%r9,LEN,16	/* see if we have at least 16 bytes */
	bb1	lt,%r9,_ASM_LABEL(r_byte_copy)	/* copy bytes for small data length */
/*
 *	determine copy strategy based on alignment of source and destination
 */
	mask	%r6,SRC,3	/* get 2 low order bits of source address */
	mask	%r7,DEST,3	/* get 2 low order bits of destination addr */
	mak	%r6,%r6,0<4>	/* convert source bits to table offset */
	mak	%r7,%r7,0<2>	/* convert destination bits to table offset */
	or.u	%r12,%r0,%hi16(_ASM_LABEL(r_strat))
	or	%r12,%r12,%lo16(_ASM_LABEL(r_strat))
	addu	%r6,%r6,%r7	/* compute final table offset for strategy */
	ld	%r12,%r12,%r6	/* load the strategy routine */
	jmp	%r12		/* branch to strategy routine */

/*
 * Copy three bytes from src to destination then copy words
 */
ASLOCAL(r_3byte_word_copy)
	subu	SRC,SRC,3	/* decrement source pointer */
	subu	DEST,DEST,3	/* decrement destination pointer */
	ld.bu	%r6,SRC,0	/* load byte from source */
	ld.bu	%r7,SRC,1	/* load byte from source */
	ld.bu	%r8,SRC,2	/* load byte from source */
	st.b	%r6,DEST,0	/* store byte to destination */
	st.b	%r7,DEST,1	/* store byte to destination */
	st.b	%r8,DEST,2	/* store byte to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	LEN,LEN,3	/* decrement length */

/*
 * Copy 1 halfword from src to destination then copy words
 */
ASLOCAL(r_1half_word_copy)
	subu	SRC,SRC,2	/* decrement source pointer */
	subu	DEST,DEST,2	/* decrement destination pointer */
	ld.hu	%r6,SRC,0	/* load half-word from source */
	st.h	%r6,DEST,0	/* store half-word to destination */
	br.n	_ASM_LABEL(r_word_copy)	/* copy full words */
	 subu	LEN,LEN,2	/* decrement remaining length */

/*
 * Copy 1 byte from src to destination then copy words
 */
ASLOCAL(r_1byte_word_copy)
	subu	SRC,SRC,1	/* decrement source pointer */
	subu	DEST,DEST,1	/* decrement destination pointer */
	ld.bu	%r6,SRC,0	/* load 1 byte from source */
	st.b	%r6,DEST,0	/* store 1 byte to destination */
	subu	LEN,LEN,1	/* decrement remaining length */
	/* FALLTHROUGH */
/*
 * Copy as many full words as possible, 4 words per loop
 */
ASLOCAL(r_word_copy)
	cmp	%r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,%r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	SRC,SRC,16	/* decrement source pointer */
	subu	DEST,DEST,16	/* decrement destination pointer */
	ld	%r6,SRC,0	/* load first word */
	ld	%r7,SRC,4	/* load second word */
	ld	%r8,SRC,8	/* load third word */
	ld	%r9,SRC,12	/* load fourth word */
	st	%r6,DEST,0	/* store first word */
	st	%r7,DEST,4	/* store second word */
	st 	%r8,DEST,8	/* store third word */
	st 	%r9,DEST,12	/* store fourth word */
	br.n	_ASM_LABEL(r_word_copy)	/* branch to copy another block */
	 subu	LEN,LEN,16	/* decrement remaining length */

ASLOCAL(r_1byte_half_copy)
	subu	SRC,SRC,1	/* decrement source pointer */
	subu	DEST,DEST,1	/* decrement destination pointer */
	ld.bu	%r6,SRC,0	/* load 1 byte from source */
	st.b	%r6,DEST,0	/* store 1 byte to destination */
	subu	LEN,LEN,1	/* decrement remaining length */
	/* FALLTHROUGH */

ASLOCAL(r_half_copy)
	cmp	%r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,%r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
	subu	SRC,SRC,16	/* decrement source pointer */
	subu	DEST,DEST,16	/* decrement destination pointer */
	ld.hu	%r6,SRC,0	/* load first half-word */
	ld.hu	%r7,SRC,2	/* load second half-word */
	ld.hu	%r8,SRC,4	/* load third half-word */
	ld.hu	%r9,SRC,6	/* load fourth half-word */
	ld.hu	%r10,SRC,8	/* load fifth half-word */
	ld.hu	%r11,SRC,10	/* load sixth half-word */
	ld.hu	%r12,SRC,12	/* load seventh half-word */
	ld.hu	%r13,SRC,14	/* load eighth half-word */
	st.h	%r6,DEST,0	/* store first half-word */
	st.h	%r7,DEST,2	/* store second half-word */
	st.h 	%r8,DEST,4	/* store third half-word */
	st.h 	%r9,DEST,6	/* store fourth half-word */
	st.h	%r10,DEST,8	/* store fifth half-word */
	st.h	%r11,DEST,10	/* store sixth half-word */
	st.h 	%r12,DEST,12	/* store seventh half-word */
	st.h 	%r13,DEST,14	/* store eighth half-word */
	br.n	_ASM_LABEL(r_half_copy)	/* branch to copy another block */
	 subu	LEN,LEN,16	/* decrement remaining length */

ASLOCAL(r_byte_copy)
	bcnd	eq0,LEN,_ASM_LABEL(bcopy_out)	/* branch if nothing left to copy */
	subu	SRC,SRC,1		/* decrement source pointer */
	subu	DEST,DEST,1		/* decrement destination pointer */
	ld.bu	%r6,SRC,0		/* load byte from source */
	st.b	%r6,DEST,0		/* store byte in destination */
	br.n	_ASM_LABEL(r_byte_copy)	/* branch for next byte */
	 subu	LEN,LEN,1		/* decrement remaining length */
#endif	/* MEMMOVE || OVBCOPY */

ASLOCAL(bcopy_out)
#if defined(MEMCPY) || defined(MEMMOVE)
	jmp.n	%r1		/* all done, return to caller */
	 or	%r2, SAVE, %r0
#else
	jmp	%r1		/* all done, return to caller */
#endif

	.data
	.align	2
ASLOCAL(f_strat)
	.word	_ASM_LABEL(f_word_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_half_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_3byte_word_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_1byte_half_copy)
	.word	_ASM_LABEL(f_half_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_1half_word_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_1byte_half_copy)
	.word	_ASM_LABEL(f_byte_copy)
	.word	_ASM_LABEL(f_1byte_word_copy)

#if defined(MEMMOVE) || defined(OVBCOPY)
ASLOCAL(r_strat)
	.word	_ASM_LABEL(r_word_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_half_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_1byte_word_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_1byte_half_copy)
	.word	_ASM_LABEL(r_half_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_1half_word_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_1byte_half_copy)
	.word	_ASM_LABEL(r_byte_copy)
	.word	_ASM_LABEL(r_3byte_word_copy)
#endif
@


1.5
log
@ovbcopy begone
@
text
@d1 1
a1 1
/*	$OpenBSD: copy_subr.S,v 1.4 2013/01/05 11:20:56 miod Exp $	*/
d55 1
@


1.4
log
@Switch m88k ports to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: copy_subr.S,v 1.3 2011/01/27 20:42:47 miod Exp $	*/
a55 3
#endif
#ifdef OVBCOPY
ENTRY(ovbcopy)
@


1.3
log
@s/DST/DEST/ to avoid warnings when building RAMDISK kernels, which define
TIMEZONE and DST...
@
text
@d1 1
a1 1
/*	$OpenBSD: copy_subr.S,v 1.2 2010/04/20 20:28:20 miod Exp $	*/
d39 3
a41 3
#define	SRC	r3
#define	DEST	r2
#define	SAVE	r5
d43 2
a44 2
#define	SRC	r2
#define	DEST	r3
d46 1
a46 1
#define	LEN	r4
d62 1
a62 1
	or	SAVE, DEST, r0
d70 2
a71 2
	cmp 	r9,SRC,DEST	/* compare source address to destination */
	bb1	eq,r9,_ASM_LABEL(bcopy_out)	/* nothing to do if equal */
d73 1
a73 1
	bb1	lo,r9,_ASM_LABEL(bcopy_reverse)	/* reverse copy if src < dest */
d80 2
a81 2
	cmp 	r9,LEN,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(f_byte_copy)	/* copy bytes for small data length */
d85 9
a93 9
	mask	r6,SRC,3	/* get 2 low order bits of source address */
	mask	r7,DEST,3	/* get 2 low order bits of destination addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(f_strat))
	or	r12,r12,lo16(_ASM_LABEL(f_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */
d99 6
a104 6
	ld.bu	r6,SRC,0	/* load byte from source */
	ld.bu	r7,SRC,1	/* load byte from source */
	ld.bu	r8,SRC,2	/* load byte from source */
	st.b	r6,DEST,0	/* store byte to destination */
	st.b	r7,DEST,1	/* store byte to destination */
	st.b	r8,DEST,2	/* store byte to destination */
d114 2
a115 2
	ld.hu	r6,SRC,0	/* load half-word from source */
	st.h	r6,DEST,0	/* store half-word to destination */
d125 2
a126 2
	ld.bu	r6,SRC,0	/* load 1 byte from source */
	st.b	r6,DEST,0	/* store 1 byte to destination */
d135 10
a144 10
	cmp	r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld	r6,SRC,0	/* load first word */
	ld	r7,SRC,4	/* load second word */
	ld	r8,SRC,8	/* load third word */
	ld	r9,SRC,12	/* load fourth word */
	st	r6,DEST,0	/* store first word */
	st	r7,DEST,4	/* store second word */
	st 	r8,DEST,8	/* store third word */
	st 	r9,DEST,12	/* store fourth word */
d151 2
a152 2
	ld.bu	r6,SRC,0	/* load 1 byte from source */
	st.b	r6,DEST,0	/* store 1 byte to destination */
d159 18
a176 18
	cmp	r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(f_byte_copy)	/* not enough left, copy bytes */
	ld.hu	r6,SRC,0	/* load first half-word */
	ld.hu	r7,SRC,2	/* load second half-word */
	ld.hu	r8,SRC,4	/* load third half-word */
	ld.hu	r9,SRC,6	/* load fourth half-word */
	ld.hu	r10,SRC,8	/* load fifth half-word */
	ld.hu	r11,SRC,10	/* load sixth half-word */
	ld.hu	r12,SRC,12	/* load seventh half-word */
	ld.hu	r13,SRC,14	/* load eighth half-word */
	st.h	r6,DEST,0	/* store first half-word */
	st.h	r7,DEST,2	/* store second half-word */
	st.h 	r8,DEST,4	/* store third half-word */
	st.h 	r9,DEST,6	/* store fourth half-word */
	st.h	r10,DEST,8	/* store fifth half-word */
	st.h	r11,DEST,10	/* store sixth half-word */
	st.h 	r12,DEST,12	/* store seventh half-word */
	st.h 	r13,DEST,14	/* store eighth half-word */
d184 2
a185 2
	ld.bu	r6,SRC,0	/* load byte from source */
	st.b	r6,DEST,0	/* store byte in destination */
d204 2
a205 2
	cmp 	r9,LEN,16	/* see if we have at least 16 bytes */
	bb1	lt,r9,_ASM_LABEL(r_byte_copy)	/* copy bytes for small data length */
d209 9
a217 9
	mask	r6,SRC,3	/* get 2 low order bits of source address */
	mask	r7,DEST,3	/* get 2 low order bits of destination addr */
	mak	r6,r6,0<4>	/* convert source bits to table offset */
	mak	r7,r7,0<2>	/* convert destination bits to table offset */
	or.u	r12,r0,hi16(_ASM_LABEL(r_strat))
	or	r12,r12,lo16(_ASM_LABEL(r_strat))
	addu	r6,r6,r7	/* compute final table offset for strategy */
	ld	r12,r12,r6	/* load the strategy routine */
	jmp	r12		/* branch to strategy routine */
d225 6
a230 6
	ld.bu	r6,SRC,0	/* load byte from source */
	ld.bu	r7,SRC,1	/* load byte from source */
	ld.bu	r8,SRC,2	/* load byte from source */
	st.b	r6,DEST,0	/* store byte to destination */
	st.b	r7,DEST,1	/* store byte to destination */
	st.b	r8,DEST,2	/* store byte to destination */
d240 2
a241 2
	ld.hu	r6,SRC,0	/* load half-word from source */
	st.h	r6,DEST,0	/* store half-word to destination */
d251 2
a252 2
	ld.bu	r6,SRC,0	/* load 1 byte from source */
	st.b	r6,DEST,0	/* store 1 byte to destination */
d259 2
a260 2
	cmp	r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
d263 8
a270 8
	ld	r6,SRC,0	/* load first word */
	ld	r7,SRC,4	/* load second word */
	ld	r8,SRC,8	/* load third word */
	ld	r9,SRC,12	/* load fourth word */
	st	r6,DEST,0	/* store first word */
	st	r7,DEST,4	/* store second word */
	st 	r8,DEST,8	/* store third word */
	st 	r9,DEST,12	/* store fourth word */
d277 2
a278 2
	ld.bu	r6,SRC,0	/* load 1 byte from source */
	st.b	r6,DEST,0	/* store 1 byte to destination */
d283 2
a284 2
	cmp	r10,LEN,16	/* see if we have 16 bytes remaining */
	bb1	lo,r10,_ASM_LABEL(r_byte_copy)	/* not enough left, copy bytes */
d287 16
a302 16
	ld.hu	r6,SRC,0	/* load first half-word */
	ld.hu	r7,SRC,2	/* load second half-word */
	ld.hu	r8,SRC,4	/* load third half-word */
	ld.hu	r9,SRC,6	/* load fourth half-word */
	ld.hu	r10,SRC,8	/* load fifth half-word */
	ld.hu	r11,SRC,10	/* load sixth half-word */
	ld.hu	r12,SRC,12	/* load seventh half-word */
	ld.hu	r13,SRC,14	/* load eighth half-word */
	st.h	r6,DEST,0	/* store first half-word */
	st.h	r7,DEST,2	/* store second half-word */
	st.h 	r8,DEST,4	/* store third half-word */
	st.h 	r9,DEST,6	/* store fourth half-word */
	st.h	r10,DEST,8	/* store fifth half-word */
	st.h	r11,DEST,10	/* store sixth half-word */
	st.h 	r12,DEST,12	/* store seventh half-word */
	st.h 	r13,DEST,14	/* store eighth half-word */
d310 2
a311 2
	ld.bu	r6,SRC,0		/* load byte from source */
	st.b	r6,DEST,0		/* store byte in destination */
d318 2
a319 2
	jmp.n	r1		/* all done, return to caller */
	 or	r2, SAVE, r0
d321 1
a321 1
	jmp	r1		/* all done, return to caller */
d324 2
a325 2
	data
	align	4
d327 16
a342 16
	word	_ASM_LABEL(f_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_3byte_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1half_word_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_half_copy)
	word	_ASM_LABEL(f_byte_copy)
	word	_ASM_LABEL(f_1byte_word_copy)
d346 16
a361 16
	word	_ASM_LABEL(r_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1half_word_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_1byte_half_copy)
	word	_ASM_LABEL(r_byte_copy)
	word	_ASM_LABEL(r_3byte_word_copy)
@


1.2
log
@destintation -> destination
@
text
@d1 1
a1 1
/*	$OpenBSD: copy_subr.S,v 1.1 2006/11/17 22:32:38 miod Exp $	*/
d40 1
a40 1
#define	DST	r2
d44 1
a44 1
#define	DST	r3
d62 1
a62 1
	or	SAVE, DST, r0
d70 1
a70 1
	cmp 	r9,SRC,DST	/* compare source address to destination */
d86 1
a86 1
	mask	r7,DST,3	/* get 2 low order bits of destination addr */
d102 3
a104 3
	st.b	r6,DST,0	/* store byte to destination */
	st.b	r7,DST,1	/* store byte to destination */
	st.b	r8,DST,2	/* store byte to destination */
d106 1
a106 1
	addu	DST,DST,3	/* increment destination pointer */
d115 1
a115 1
	st.h	r6,DST,0	/* store half-word to destination */
d117 1
a117 1
	addu	DST,DST,2	/* increment destination pointer */
d126 1
a126 1
	st.b	r6,DST,0	/* store 1 byte to destination */
d128 1
a128 1
	addu	DST,DST,1	/* increment destination pointer */
d141 4
a144 4
	st	r6,DST,0	/* store first word */
	st	r7,DST,4	/* store second word */
	st 	r8,DST,8	/* store third word */
	st 	r9,DST,12	/* store fourth word */
d146 1
a146 1
	addu	DST,DST,16	/* increment destination pointer */
d152 1
a152 1
	st.b	r6,DST,0	/* store 1 byte to destination */
d154 1
a154 1
	addu	DST,DST,1	/* increment destination pointer */
d169 8
a176 8
	st.h	r6,DST,0	/* store first half-word */
	st.h	r7,DST,2	/* store second half-word */
	st.h 	r8,DST,4	/* store third half-word */
	st.h 	r9,DST,6	/* store fourth half-word */
	st.h	r10,DST,8	/* store fifth half-word */
	st.h	r11,DST,10	/* store sixth half-word */
	st.h 	r12,DST,12	/* store seventh half-word */
	st.h 	r13,DST,14	/* store eighth half-word */
d178 1
a178 1
	addu	DST,DST,16	/* increment destination pointer */
d185 1
a185 1
	st.b	r6,DST,0	/* store byte in destination */
d187 1
a187 1
	addu	DST,DST,1	/* increment destination pointer */
d200 1
a200 1
	addu	DST,DST,LEN	/* start destination at end of data */
d210 1
a210 1
	mask	r7,DST,3	/* get 2 low order bits of destination addr */
d224 1
a224 1
	subu	DST,DST,3	/* decrement destination pointer */
d228 3
a230 3
	st.b	r6,DST,0	/* store byte to destination */
	st.b	r7,DST,1	/* store byte to destination */
	st.b	r8,DST,2	/* store byte to destination */
d239 1
a239 1
	subu	DST,DST,2	/* decrement destination pointer */
d241 1
a241 1
	st.h	r6,DST,0	/* store half-word to destination */
d250 1
a250 1
	subu	DST,DST,1	/* decrement destination pointer */
d252 1
a252 1
	st.b	r6,DST,0	/* store 1 byte to destination */
d262 1
a262 1
	subu	DST,DST,16	/* decrement destination pointer */
d267 4
a270 4
	st	r6,DST,0	/* store first word */
	st	r7,DST,4	/* store second word */
	st 	r8,DST,8	/* store third word */
	st 	r9,DST,12	/* store fourth word */
d276 1
a276 1
	subu	DST,DST,1	/* decrement destination pointer */
d278 1
a278 1
	st.b	r6,DST,0	/* store 1 byte to destination */
d286 1
a286 1
	subu	DST,DST,16	/* decrement destination pointer */
d295 8
a302 8
	st.h	r6,DST,0	/* store first half-word */
	st.h	r7,DST,2	/* store second half-word */
	st.h 	r8,DST,4	/* store third half-word */
	st.h 	r9,DST,6	/* store fourth half-word */
	st.h	r10,DST,8	/* store fifth half-word */
	st.h	r11,DST,10	/* store sixth half-word */
	st.h 	r12,DST,12	/* store seventh half-word */
	st.h 	r13,DST,14	/* store eighth half-word */
d309 1
a309 1
	subu	DST,DST,1		/* decrement destination pointer */
d311 1
a311 1
	st.b	r6,DST,0		/* store byte in destination */
@


1.1
log
@Move m88k memory copy and fill functions to libkern. The copy functions will
no longer share the same code, but will be instead be duplicated from the same
source, so that bcopy() and memcpy() do not need to check for overlap, and
memcpy() and memmove() are shorter.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 1
a86 1
	mask	r7,DST,3	/* get 2 low order bits of destintation addr */
d210 1
a210 1
	mask	r7,DST,3	/* get 2 low order bits of destintation addr */
@

