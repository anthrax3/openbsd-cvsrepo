head	1.3;
access;
symbols
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.3.0.84
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.80
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.82
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.74
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.78
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.76
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.3.0.72
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.70
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.68
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.66
	OPENBSD_5_0:1.3.0.64
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.62
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.60
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.56
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.3.0.58
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.54
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.52
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.50
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.48
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.46
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.44
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.42
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.40
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.38
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.36
	OPENBSD_3_6_BASE:1.3
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.34
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.32
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.30
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.28
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.26
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.24
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.22
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.20
	OPENBSD_2_8:1.3.0.18
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.16
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.14
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.12
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.10
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.8
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.6
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.4
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.2
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@# @;


1.3
date	96.10.31.00.43.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.57.23;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.51;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.51;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Merge NetBSD/Alpha 961020
@
text
@/*	$OpenBSD: divrem.m4,v 1.5 1996/10/17 04:26:25 cgd Exp $	*/
/*	$NetBSD: divrem.m4,v 1.5 1996/10/17 04:26:25 cgd Exp $	*/

/*
 * Copyright (c) 1994, 1995 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Chris G. Demetriou
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 * Division and remainder.
 *
 * The use of m4 is modeled after the sparc code, but the algorithm is
 * simple binary long division.
 *
 * Note that the loops could probably benefit from unrolling.
 */

/*
 * M4 Parameters
 * NAME		name of function to generate
 * OP		OP=div: t10 / t11 -> t12; OP=rem: t10 % t11 -> t12
 * S		S=true: signed; S=false: unsigned
 * WORDSIZE	total number of bits
 */

define(A, `t10')
define(B, `t11')
define(RESULT, `t12')

define(BIT, `t0')
define(I, `t1')
define(CC, `t2')
define(T_0, `t3')
ifelse(S, `true', `define(NEG, `t4')')

#include <machine/asm.h>

LEAF(NAME, 0)					/* XXX */
	lda	sp, -64(sp)
	stq	BIT, 0(sp)
	stq	I, 8(sp)
	stq	CC, 16(sp)
	stq	T_0, 24(sp)
ifelse(S, `true',
`	stq	NEG, 32(sp)')
	stq	A, 40(sp)
	stq	B, 48(sp)
	mov	zero, RESULT			/* Initialize result to zero */

ifelse(S, `true',
`
	/* Compute sign of result.  If either is negative, this is easy.  */
	or	A, B, NEG			/* not the sign, but... */
	srl	NEG, WORDSIZE - 1, NEG		/* rather, or of high bits */
	blbc	NEG, Ldoit			/* neither negative? do it! */

ifelse(OP, `div',
`	xor	A, B, NEG			/* THIS is the sign! */
', `	mov	A, NEG				/* sign follows A. */
')
	srl	NEG, WORDSIZE - 1, NEG		/* make negation the low bit. */

	srl	A, WORDSIZE - 1, I		/* is A negative? */
	blbc	I, LnegB			/* no. */
	/* A is negative; flip it. */
ifelse(WORDSIZE, `32', `
	/* top 32 bits may be random junk */
	zap	A, 0xf0, A
')
	subq	zero, A, A
	srl	B, WORDSIZE - 1, I		/* is B negative? */
	blbc	I, Ldoit			/* no. */
LnegB:
	/* B is definitely negative, no matter how we got here. */
ifelse(WORDSIZE, `32', `
	/* top 32 bits may be random junk */
	zap	B, 0xf0, B
')
	subq	zero, B, B
Ldoit:
')
ifelse(WORDSIZE, `32', `
	/*
	 * Clear the top 32 bits of each operand, as they may
	 * sign extension (if negated above), or random junk.
	 */
	zap	A, 0xf0, A
	zap	B, 0xf0, B
')

	/* kill the special cases. */
	beq	B, Ldotrap			/* division by zero! */

	cmpult	A, B, CC			/* A < B? */
	/* RESULT is already zero, from above.  A is untouched. */
	bne	CC, Lret_result

	cmpeq	A, B, CC			/* A == B? */
	cmovne	CC, 1, RESULT
	cmovne	CC, zero, A
	bne	CC, Lret_result

	/*
	 * Find out how many bits of zeros are at the beginning of the divisor.
	 */
LBbits:
	ldiq	T_0, 1				/* I = 0; BIT = 1<<WORDSIZE-1 */
	mov	zero, I
	sll	T_0, WORDSIZE-1, BIT
LBloop:
	and	B, BIT, CC			/* if bit in B is set, done. */
	bne	CC, LAbits
	addq	I, 1, I				/* increment I, shift bit */
	srl	BIT, 1, BIT
	cmplt	I, WORDSIZE-1, CC		/* if I leaves one bit, done. */
	bne	CC, LBloop

LAbits:
	beq	I, Ldodiv			/* If I = 0, divide now.  */
	ldiq	T_0, 1				/* BIT = 1<<WORDSIZE-1 */
	sll	T_0, WORDSIZE-1, BIT

LAloop:
	and	A, BIT, CC			/* if bit in A is set, done. */
	bne	CC, Ldodiv
	subq	I, 1, I				/* decrement I, shift bit */
	srl     BIT, 1, BIT 
	bne	I, LAloop			/* If I != 0, loop again */

Ldodiv:
	sll	B, I, B				/* B <<= i */
	ldiq	T_0, 1
	sll	T_0, I, BIT

Ldivloop:
	cmpult	A, B, CC
	or	RESULT, BIT, T_0
	cmoveq	CC, T_0, RESULT
	subq	A, B, T_0
	cmoveq	CC, T_0, A
	srl	BIT, 1, BIT	
	srl	B, 1, B
	beq	A, Lret_result
	bne	BIT, Ldivloop

Lret_result:
ifelse(OP, `div',
`', `	mov	A, RESULT
')
ifelse(S, `true',
`
	/* Check to see if we should negate it. */
	subqv	zero, RESULT, T_0
	cmovlbs	NEG, T_0, RESULT
')

	ldq	BIT, 0(sp)
	ldq	I, 8(sp)
	ldq	CC, 16(sp)
	ldq	T_0, 24(sp)
ifelse(S, `true',
`	ldq	NEG, 32(sp)')
	ldq	A, 40(sp)
	ldq	B, 48(sp)
	lda	sp, 64(sp)
	ret	zero, (t9), 1

Ldotrap:
	ldiq	a0, -2			/* This is the signal to SIGFPE! */
	call_pal PAL_gentrap
ifelse(OP, `div',
`', `	mov	zero, A			/* so that zero will be returned */
')
	br	zero, Lret_result

END(NAME)
@


1.2
log
@update from netbsd
@
text
@d1 2
a2 1
/*	$NetBSD: divrem.m4,v 1.3 1995/10/20 00:53:28 cgd Exp $	*/
d58 1
a58 1
#include "DEFS.h"
d116 1
a116 1
1:	cmpult	A, B, CC			/* A < B? */
d129 1
a129 1
	CONST(1, T_0)				/* I = 0; BIT = 1<<WORDSIZE-1 */
d142 1
a142 1
	CONST(1, T_0)				/* BIT = 1<<WORDSIZE-1 */
d154 1
a154 1
	CONST(1, T_0)
d191 1
a191 1
	CONST(-2, a0)			/* This is the signal to SIGFPE! */
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: divrem.m4,v 1.2 1995/03/03 01:14:11 cgd Exp $	*/
d43 1
a43 1
 * S		S=true: signed; S=false: unsigned [XXX NOT YET]
d55 1
a55 1
ifelse(S, `true', `define(SIGN, `t4')')
d60 1
a60 1
	lda	sp, -48(sp)
d66 3
a68 1
`	stq	SIGN, 32(sp)')
d74 3
a76 2
	or	A, B, SIGN			/* not the sign, but... */
	bgt	SIGN, Ldoit			/* neither negative? do it! */
d79 2
a80 2
`	xor	A, B, SIGN			/* THIS is the sign! */
', `	mov	A, SIGN				/* sign follows A. */
d82 4
a85 1
	bge	A, LnegB			/* see if A is negative */
d87 4
d92 2
a93 1
	bge	B, Ldoit			/* see if B is negative */
d96 4
d102 1
a102 1
', `
d105 2
a106 2
	 * Clear the top 32 bits of each operand, as the compiler may
	 * have sign extended them, if the 31st bit was set.
d110 1
a110 1
')' )
d113 1
a113 1
	beq	B, Ldotrap			/* division by zero! XXX */
d175 1
a175 1
	cmovlt	SIGN, T_0, RESULT
d183 4
a186 2
`	ldq	SIGN, 32(sp)')
	lda	sp, 48(sp)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
