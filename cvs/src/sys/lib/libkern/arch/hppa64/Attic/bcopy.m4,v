head	1.13;
access;
symbols
	OPENBSD_5_9:1.12.0.10
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.12
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.9.0.6
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.4
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.2
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.4.0.14
	OPENBSD_4_9_BASE:1.4
	OPENBSD_4_8:1.4.0.12
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.8
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.10
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.6
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.4
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.2
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.2.0.10
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.8
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.6
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.4
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.2
	OPENBSD_3_8_BASE:1.2;
locks; strict;
comment	@# @;


1.13
date	2016.05.11.21.52.51;	author deraadt;	state dead;
branches;
next	1.12;
commitid	VpgRpYXqYSJy4P7J;

1.12
date	2013.06.14.12.45.18;	author kettenis;	state Exp;
branches;
next	1.11;

1.11
date	2013.06.14.12.40.03;	author kettenis;	state Exp;
branches;
next	1.10;

1.10
date	2013.06.11.20.05.53;	author kettenis;	state Exp;
branches;
next	1.9;

1.9
date	2011.11.27.21.02.10;	author kettenis;	state Exp;
branches;
next	1.8;

1.8
date	2011.11.27.12.31.47;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2011.09.19.10.50.10;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2011.04.14.13.52.29;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2011.04.14.13.49.31;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2007.11.24.19.42.01;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.10.13.19.26.57;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2005.08.01.12.10.26;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2005.04.01.10.45.29;	author mickey;	state Exp;
branches;
next	;


desc
@@


1.13
log
@remove hppa64 port, which we never got going beyond broken single users.
hppa reverse-stack gives us a valuable test case, but most developers don't
have a 2nd one to proceed further with this.
ok kettenis
@
text
@define(_rcsid,``$OpenBSD: bcopy.m4,v 1.12 2013/06/14 12:45:18 kettenis Exp $'')dnl
dnl
dnl
dnl  This is the source file for bcopy.S, spcopy.S
dnl
dnl
define(`versionmacro',substr(_rcsid,1,eval(len(_rcsid)-2)))dnl
dnl
/* This is a generated file. DO NOT EDIT. */
/*
 * Generated from:
 *
 *	versionmacro
 */
/*
 * Copyright (c) 1999,2004 Michael Shalayeff
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER IN
 * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
dnl
dnl    macro: L(`%arg1',`%arg2')
dnl synopsis: creates an assembly label based on args resulting in $%arg1.%arg2
dnl
define(`L', `$$1.$2')dnl
dnl
dnl
dnl
define(`STWS',`ifelse($5, `u',dnl
`ifelse($1, `22', `shrpw	$4, %r`$1', %sar, %r31
	stby,B,m %r31, F`'4($2, $3)',
`0', `0', `shrpw	%r`'incr($1), %r`$1', %sar, %r31
	stw,M	%r31, F`'4($2, $3)')',dnl
`0', `0',
`ifelse($1, `22',
`stby,B`'ifelse(B, `b', `,m ', `0', `0', `	')`'%r`$1', F`'4($2, $3)',
`0', `0', `stw,M	%r`$1', F`'4($2, $3)')')')dnl
define(`STWSS', `ifelse(`$3', `22', `dnl',
`0', `0', `STWSS($1, $2, eval($3 + 1), $4, $5)')
	STWS($3, $1, $2, $4, $5)dnl
')dnl
define(`LDWSS', `ifelse(`$3', `22', `dnl',
`0', `0', `LDWSS($1, $2, eval($3 + 1))')
	ldw,M	F`'4($1, $2), %r`'$3`'dnl
')dnl
dnl
dnl copy data in 4-words blocks
dnl
define(`hppa_blcopy',`
	addi	-16, $6, $6
L($1, `loop16'`$7')
	ldw	F 32($2, $3), %r0
ifelse(F, `-', `dnl
	addi	F`'4, $5, $5', `0', `0', `dnl')
LDWSS($2, $3, 19)
STWSS($4, $5, 20, `%ret1', $7)
ifelse($7, `u', `dnl
	STWS(19, $4, $5, `%ret1', $7)', $7, `a', `dnl')
	addib,*>= -16, $6, L($1, `loop16'`$7')
ifelse($7, `a', `dnl
	STWS(19, $4, $5, `%ret1', $7)dnl
', $7, `u', `dnl
	copy	%r19, %ret1')')dnl
dnl
dnl copy in words
dnl
define(`STWL', `addib,*<,n 12, $6, L($1, cleanup)
ifelse($7, `u', `	copy	%ret1, %r22', $7, `a', `dnl')
L($1, word)
	ldw,M	F`'4($2, $3), %r22
	addib,*>= -4, $6, L($1, word)
	stw,M	%r22, F`'4($4, $5)

L($1, cleanup)
	addib,*=,n 4, $6, L($1, done)
	ldw	0($2, $3), %r22
	add	$5, $6, $5
	b	L($1, done)
	stby,E	%r22, 0($4, $5)
')
dnl
dnl
dnl parameters:
dnl  $1	name
dnl  $2	source space
dnl  $3	source address
dnl  $4	destination space
dnl  $5	destination address
dnl  $6	length
dnl  $7	direction
dnl
define(hppa_copy,
`dnl
dnl
dnl	if direction is `-' (backwards copy), adjust src, dst
dnl
ifelse($7,`-', `add	$3, $6, $3
	add	$5, $6, $5
define(`F', `-')dnl
define(`R', `')dnl
define(`M', `mb')dnl
define(`B', `e')dnl
define(`E', `b')dnl
',dnl ifelse
`0',`0',
`define(`F', `')dnl
define(`R', `-')dnl
define(`M', `ma')dnl
define(`B', `b')dnl
define(`E', `e')dnl
')dnl ifelse

ifelse($7,`-', `', `0',`0',
`	cmpib,*>=,n 15, $6, L($1, byte)

	extrd,u	$3, 63, 2, %r20
	extrd,u	$5, 63, 2, %r19
	add	$6, %r19, $6
	cmpb,*<> %r20, %r19, L($1, unaligned)
	depd	%r0, 63, 2, $3
	hppa_blcopy($1, $2, $3, $4, $5, $6, `a')

	STWL($1, $2, $3, $4, $5, $6, `a')dnl

L($1, unaligned)
	sub,*>=	%r19, %r20, %r21
	ldw,ma	F`'4($2, $3), %ret1
	depd,z	%r21, 60, 61, %r22
	mtsar	%r22
	hppa_blcopy($1, $2, $3, $4, $5, $6, `u')

dnl	STWL($1, $2, $3, $4, $5, $6, `u')
	addib,*<,n 12, $6, L($1, cleanup_un)
L($1, word_un)
	ldw,M	F`'4($2, $3), %r22
	shrpw	%ret1, %r22, %sar, %r21
	addib,*< -4, $6, L($1, cleanup1_un)
	stw,M	%r21, F`'4($4, $5)
	ldw,M	F`'4($2, $3), %ret1
	shrpw	%r22, %ret1, %sar, %r21
	addib,*>= -4, $6, L($1, word_un)
	stw,M	%r21, F`'4($4, $5)

L($1, cleanup_un)
	addib,*<=,n 4, $6, L($1, done)
	mfctl	%sar, %r19
	add	$5, $6, $5
	extrd,u	%r19, 60, 2, %r19
	sub,*<=	$6, %r19, %r0
	ldw,M	F`'4($2, $3), %r22
	shrpw	%ret1, %r22, %sar, %r21
	b	L($1, done)
	stby,E	%r21, 0($4, $5)

L($1, cleanup1_un)
	b	L($1, cleanup_un)
	copy	%r22, %ret1
')dnl ifelse

L($1, byte)
	cmpb,*>=,n %r0, $6, L($1, done)
L($1, byte_loop)
	ldbs,M	F`'1($2, $3), %r22
	addib,*<> -1, $6, L($1, byte_loop)
	stbs,M	%r22, F`'1($4, $5)
L($1, done)
')dnl
`
#undef _LOCORE
#define _LOCORE
#include <machine/asm.h>
#include <machine/frame.h>
'
ifelse(NAME, `bcopy',
`
LEAF_ENTRY(bcopy)
	copy	%arg0, %ret0
	copy	%arg1, %arg0
	copy	%ret0, %arg1
ALTENTRY(memmove)
	cmpb,*>,n %arg0, %arg1, L(bcopy, reverse)
ALTENTRY(memcpy)
	copy	%arg0, %ret0
	hppa_copy(bcopy_f, %sr0, %arg1, %sr0, %arg0, %arg2, `+')
	bv	%r0(%rp)
	nop
L(bcopy, reverse)
	copy	%arg0, %ret0
	hppa_copy(bcopy_r, %sr0, %arg1, %sr0, %arg0, %arg2, `-')
	bv	%r0(%rp)
	nop
EXIT(bcopy)
')dnl
dnl
ifelse(NAME, `spcopy',
`
#ifdef _KERNEL
#include <assym.h>

/*
 * int spcopy (pa_space_t ssp, const void *src, pa_space_t dsp, void *dst,
 *              size_t size)
 * do a space to space bcopy.
 *
 * assumes that spaces do not clash, otherwise we lose
 */
	.import	copy_on_fault, code
LEAF_ENTRY(spcopy)
	sub,*<>	%r0, arg4, %r0
	bv	%r0(%rp)
	nop
`
	std	%rp, HPPA_FRAME_RP(%sp)
	ldo	HPPA_FRAME_SIZE(%sp), %sp
	/* setup fault handler */
	mfctl	%cr24, %r1
	ldd	CI_CURPROC(%r1), %r1
	ldil	L%copy_on_fault, %r21
	ldd	P_ADDR(%r1), %r2
	ldo	R%copy_on_fault(%r21), %r21
	ldd	PCB_ONFAULT+U_PCB(%r2), %r1
	std	%r21, PCB_ONFAULT+U_PCB(%r2)
'
	mtsp	%arg0, %sr1
	mtsp	%arg2, %sr2

	copy	arg4, %ret0
	hppa_copy(spcopy, %sr1, %arg1, %sr2, %arg3, %ret0, `+')

	mtsp	%r0, %sr1
	mtsp	%r0, %sr2
	/* reset fault handler */
	std	%r1, PCB_ONFAULT+U_PCB(%r2)
	ldo	-HPPA_FRAME_SIZE(%sp), %sp
	ldd	HPPA_FRAME_RP(%sp), %rp
	bv	%r0(%rp)
	copy	%r0, %ret0
EXIT(spcopy)
#endif
')dnl

	.end
@


1.12
log
@ovbcopy begone
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.11 2013/06/14 12:40:03 kettenis Exp $'')dnl
@


1.11
log
@Fix memcpy/memmove return value.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.10 2013/06/11 20:05:53 kettenis Exp $'')dnl
a186 1
ALTENTRY(ovbcopy)
@


1.10
log
@Optimize memcpy(9) by always doing a forward copy; it should never be used
for overlapping copies.  Attempt to be instruction cache friendly by turning
things around and make memcpy(9) use the forward copy branch of memmove(9),
and implement bcopy(9) by swapping its arguments and dropping into memmove(9).

Same change as the one just made to for hppa.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.9 2011/11/27 21:02:10 kettenis Exp $'')dnl
d194 1
d199 1
@


1.9
log
@Switch to proper PA-RISC 2.0 mnemonics.  Works around a bug in the assembler
getting rid of the (hopefully) last bug in this code.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.8 2011/11/27 12:31:47 kettenis Exp $'')dnl
d186 2
a187 2
LEAF_ENTRY(memcpy)
ALTENTRY(memmove)
d191 4
a194 4
ALTENTRY(ovbcopy)
ALTENTRY(bcopy)
	cmpb,*>,n %arg1, %arg0, L(bcopy, reverse)
	hppa_copy(bcopy_f, %sr0, %arg0, %sr0, %arg1, %arg2, `+')
d198 1
a198 1
	hppa_copy(bcopy_r, %sr0, %arg0, %sr0, %arg1, %arg2, `-')
d201 1
a201 1
EXIT(memcpy)
@


1.8
log
@Replace a few more 32-bit instructions with the proper 64-bit equivalent.
Also fix the return value of memcpy.  With these changes, this seems to
work as advertised now.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.7 2011/09/19 10:50:10 kettenis Exp $'')dnl
d40 4
a43 4
`ifelse($1, `22', `vshd	$4, %r`$1', %r31
	stbys,B,m %r31, F`'4($2, $3)',
`0', `0', `vshd	%r`'incr($1), %r`$1', %r31
	stws,M	%r31, F`'4($2, $3)')',dnl
d46 2
a47 2
`stbys,B`'ifelse(B, `b', `,m ', `0', `0', `	')`'%r`$1', F`'4($2, $3)',
`0', `0', `stws,M	%r`$1', F`'4($2, $3)')')')dnl
d54 1
a54 1
	ldws,M	F`'4($1, $2), %r`'$3`'dnl
d80 1
a80 1
	ldws,M	F`'4($2, $3), %r22
d82 1
a82 1
	stws,M	%r22, F`'4($4, $5)
d86 1
a86 1
	ldws	0($2, $3), %r22
d89 1
a89 1
	stbys,E	%r22, 0($4, $5)
d137 1
a137 1
	ldwm	F`'4($2, $3), %ret1
d145 2
a146 2
	ldws,M	F`'4($2, $3), %r22
	vshd	%ret1, %r22, %r21
d148 3
a150 3
	stws,M	%r21, F`'4($4, $5)
	ldws,M	F`'4($2, $3), %ret1
	vshd	%r22, %ret1, %r21
d152 1
a152 1
	stws,M	%r21, F`'4($4, $5)
d160 2
a161 2
	ldws,M	F`'4($2, $3), %r22
	vshd	%ret1, %r22, %r21
d163 1
a163 1
	stbys,E	%r21, 0($4, $5)
@


1.7
log
@Avoid sign-extension when extracting the low bits of addresses when checking
if the addresses are 4-byte aligned.

ok jsing@@
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.6 2011/04/14 13:52:29 jsing Exp $'')dnl
d69 1
a69 1
	addib,>= -16, $6, L($1, `loop16'`$7')
d77 1
a77 1
define(`STWL', `addib,<,n 12, $6, L($1, cleanup)
d81 1
a81 1
	addib,>= -4, $6, L($1, word)
d85 1
a85 1
	addib,=,n 4, $6, L($1, done)
d124 1
a124 1
`	comib,>=,n 15, $6, L($1, byte)
d129 1
a129 1
	comb,<> %r20, %r19, L($1, unaligned)
d136 1
a136 1
	sub,>=	%r19, %r20, %r21
d138 1
a138 1
	zdep	%r21, 28, 29, %r22
d143 1
a143 1
	addib,<,n 12, $6, L($1, cleanup_un)
d147 1
a147 1
	addib,<	-4, $6, L($1, cleanup1_un)
d151 1
a151 1
	addib,>= -4, $6, L($1, word_un)
d155 1
a155 1
	addib,<=,n 4, $6, L($1, done)
d158 2
a159 2
	extru	%r19, 28, 2, %r19
	sub,<=	$6, %r19, %r0
d171 1
a171 1
	comb,>=,n %r0, $6, L($1, done)
d174 1
a174 1
	addib,<> -1, $6, L($1, byte_loop)
d188 1
a188 1
	copy	%arg0, %r22
d190 1
a190 2
	copy	%r22, %arg1
	copy	%arg0, %ret0
d193 1
a193 1
	comb,>,n %arg1, %arg0, L(bcopy, reverse)
d218 1
a218 1
	sub,<>	%r0, arg4, %r0
@


1.6
log
@Use 64-bit operations for address manipulation.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.3 2007/10/13 19:26:57 kettenis Exp $'')dnl
d126 2
a127 2
	extrd	$3, 63, 2, %r20
	extrd	$5, 63, 2, %r19
@


1.5
log
@Correctly load p_addr and avoid trashing the source address.
@
text
@d126 2
a127 2
	extru	$3, 31, 2, %r20
	extru	$5, 31, 2, %r19
d130 1
a130 1
	dep	%r0, 31, 2, $3
@


1.4
log
@junk SCCS
@
text
@d226 2
a227 2
	mfctl	%cr24, %arg1
	ldd	CI_CURPROC(%arg1), %r1
d229 1
a229 1
	ldd	P_ADDR(%r20), %r2
@


1.3
log
@Make this actually work by using the right register numbers.  In the conversion
from hppa the fact that t1-t4 actually number down from r22-r19 got somehow
lost.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.2 2005/08/01 12:10:26 miod Exp $'')dnl
a185 6
#if defined(LIBC_SCCS)
	.text
	.asciz "versionmacro"
	.align	4
#endif

@


1.2
log
@I'm Positive these are Type-O.
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD: bcopy.m4,v 1.1 2005/04/01 10:45:29 mickey Exp $'')dnl
d40 1
a40 1
`ifelse($1, `1', `vshd	$4, %r`$1', %r31
d42 1
a42 1
`0', `0', `vshd	%r`'decr($1), %r`$1', %r31
d45 1
a45 1
`ifelse($1, `1',
d48 2
a49 2
define(`STWSS', `ifelse(`$3', `19', `dnl',
`0', `0', `STWSS($1, $2, eval($3 - 1), $4, $5)')
d52 2
a53 2
define(`LDWSS', `ifelse(`$3', `19', `dnl',
`0', `0', `LDWSS($1, $2, eval($3 - 1))')
d65 2
a66 2
LDWSS($2, $3, 22)
STWSS($4, $5, 21, `%ret1', $7)
d68 1
a68 1
	STWS(4, $4, $5, `%ret1', $7)', $7, `a', `dnl')
d71 1
a71 1
	STWS(4, $4, $5, `%ret1', $7)dnl
@


1.1
log
@hppa64 bits
@
text
@d1 1
a1 1
define(_rcsid,``$OpenBSD$'')dnl
d221 1
a221 1
 * assumed that spaces do not clash, otherwise we loose
@

