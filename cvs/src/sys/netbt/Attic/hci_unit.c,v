head	1.13;
access;
symbols
	OPENBSD_5_5:1.12.0.14
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.4
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.13
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.12;
commitid	0n9cIGBISFAEt4b1;

1.12
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.22.16.56.39;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.24.21.34.48;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.24.20.55.27;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.06.21.37.08;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.01.20.29.54;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.01.20.03.31;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.01.02.46.11;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.31.23.50.19;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.30.03.42.53;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.13
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: hci_unit.c,v 1.12 2011/07/06 02:42:28 henning Exp $	*/
/*	$NetBSD: hci_unit.c,v 1.12 2008/06/26 14:17:27 plunky Exp $	*/

/*-
 * Copyright (c) 2005 Iain Hibbert.
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/systm.h>

#include <net/netisr.h>

#include <netbt/bluetooth.h>
#include <netbt/hci.h>

struct hci_unit_list hci_unit_list = TAILQ_HEAD_INITIALIZER(hci_unit_list);

/*
 * HCI Input Queue max lengths.
 */
int hci_eventq_max = 20;
int hci_aclrxq_max = 50;
int hci_scorxq_max = 50;
int hci_cmdwait_max = 50;
int hci_scodone_max = 50;

/*
 * This is the default minimum command set supported by older
 * devices. Anything conforming to 1.2 spec or later will get
 * updated during init.
 */
static const uint8_t hci_cmds_v10[HCI_COMMANDS_SIZE] = {
	0xff, 0xff, 0xff, 0x01, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0x7f, 0x32, 0x03, 0xb8, 0xfe,
	0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

/*
 * bluetooth unit functions
 */

struct hci_unit *
hci_attach(const struct hci_if *hci_if, struct device *dev, uint16_t flags)
{
	struct hci_unit *unit;

	KASSERT(dev != NULL);
	KASSERT(hci_if->enable != NULL);
	KASSERT(hci_if->disable != NULL);
	KASSERT(hci_if->output_cmd != NULL);
	KASSERT(hci_if->output_acl != NULL);
	KASSERT(hci_if->output_sco != NULL);
	KASSERT(hci_if->get_stats != NULL);

	unit = malloc(sizeof(struct hci_unit), M_BLUETOOTH, M_ZERO | M_WAITOK);
	KASSERT(unit != NULL);

	unit->hci_dev = dev;
	unit->hci_if = hci_if;
	unit->hci_flags = flags;

	mtx_init(&unit->hci_devlock, hci_if->ipl);
	unit->hci_init = 0;	/* kcondvar_t in NetBSD */

	IFQ_SET_MAXLEN(&unit->hci_eventq, hci_eventq_max);
	IFQ_SET_MAXLEN(&unit->hci_aclrxq, hci_aclrxq_max);
	IFQ_SET_MAXLEN(&unit->hci_scorxq, hci_scorxq_max);
	IFQ_SET_MAXLEN(&unit->hci_cmdwait, hci_cmdwait_max);
	IFQ_SET_MAXLEN(&unit->hci_scodone, hci_scodone_max);

	TAILQ_INIT(&unit->hci_links);
	LIST_INIT(&unit->hci_memos);

	mutex_enter(&bt_lock);
	TAILQ_INSERT_TAIL(&hci_unit_list, unit, hci_next);
	mutex_exit(&bt_lock);

	return unit;
}

void
hci_detach(struct hci_unit *unit)
{

	mutex_enter(&bt_lock);
	hci_disable(unit);

	TAILQ_REMOVE(&hci_unit_list, unit, hci_next);
	mutex_exit(&bt_lock);

	/* mutex_destroy(&unit->hci_devlock) in NetBSD */
	free(unit, M_BLUETOOTH);
}

int
hci_enable(struct hci_unit *unit)
{
	int err;

	/*
	 * Block further attempts to enable the interface until the
	 * previous attempt has completed.
	 */
	if (unit->hci_flags & BTF_INIT)
		return EBUSY;

	/*
	 * Bluetooth spec says that a device can accept one
	 * command on power up until they send a Command Status
	 * or Command Complete event with more information, but
	 * it seems that some devices cant and prefer to send a
	 * No-op Command Status packet when they are ready.
	 */
	unit->hci_num_cmd_pkts = (unit->hci_flags & BTF_POWER_UP_NOOP) ? 0 : 1;
	unit->hci_num_acl_pkts = 0;
	unit->hci_num_sco_pkts = 0;

	/*
	 * only allow the basic packet types until
	 * the features report is in
	 */
	unit->hci_acl_mask = HCI_PKT_DM1 | HCI_PKT_DH1;
	unit->hci_packet_type = unit->hci_acl_mask;

	memcpy(unit->hci_cmds, hci_cmds_v10, HCI_COMMANDS_SIZE);

#ifndef __OpenBSD__
	unit->hci_rxint = softint_establish(SOFTINT_NET, &hci_intr, unit);
	if (unit->hci_rxint == NULL)
		return EIO;
#endif

	err = (*unit->hci_if->enable)(unit->hci_dev);
	if (err)
		goto bad1;

	unit->hci_flags |= BTF_RUNNING;

	/*
	 * Reset the device, this will trigger initialisation
	 * and wake us up.
	 */
	unit->hci_flags |= BTF_INIT;

	err = hci_send_cmd(unit, HCI_CMD_RESET, NULL, 0);
	if (err)
		goto bad2;

	while (unit->hci_flags & BTF_INIT) {
		err = msleep(&unit->hci_init, &bt_lock, PWAIT | PCATCH,
		    __func__, 5 * hz);
		if (err)
			goto bad2;

		/* XXX
		 * "What If", while we were sleeping, the device
		 * was removed and detached? Ho Hum.
		 */
	}

	/*
	 * Attach Bluetooth Device Hub
	 */
	unit->hci_bthub = config_found(unit->hci_dev,
	    &unit->hci_bdaddr, NULL);

	return 0;

bad2:
	(*unit->hci_if->disable)(unit->hci_dev);
	unit->hci_flags &= ~BTF_RUNNING;
bad1:
#ifndef __OpenBSD__
	softint_disestablish(unit->hci_rxint);
	unit->hci_rxint = NULL;
#endif

	return err;
}

void
hci_disable(struct hci_unit *unit)
{
	struct hci_link *link, *next;
	struct hci_memo *memo;
	int acl;

	if (unit->hci_bthub) {
		struct device *hub;

		hub = unit->hci_bthub;
		unit->hci_bthub = NULL;

		mutex_exit(&bt_lock);
		config_detach(hub, DETACH_FORCE);
		mutex_enter(&bt_lock);
	}

#ifndef __OpenBSD__
	if (unit->hci_rxint) {
		softint_disestablish(unit->hci_rxint);
		unit->hci_rxint = NULL;
	}
#endif

	(*unit->hci_if->disable)(unit->hci_dev);
	unit->hci_flags &= ~BTF_RUNNING;

	/*
	 * close down any links, take care to close SCO first since
	 * they may depend on ACL links.
	 */
	for (acl = 0 ; acl < 2 ; acl++) {
		next = TAILQ_FIRST(&unit->hci_links);
		while ((link = next) != NULL) {
			next = TAILQ_NEXT(link, hl_next);
			if (acl || link->hl_type != HCI_LINK_ACL)
				hci_link_free(link, ECONNABORTED);
		}
	}

	while ((memo = LIST_FIRST(&unit->hci_memos)) != NULL)
		hci_memo_free(memo);

	/* (no need to hold hci_devlock, the driver is disabled) */

	IF_PURGE(&unit->hci_eventq);
	unit->hci_eventqlen = 0;

	IF_PURGE(&unit->hci_aclrxq);
	unit->hci_aclrxqlen = 0;

	IF_PURGE(&unit->hci_scorxq);
	unit->hci_scorxqlen = 0;

	IF_PURGE(&unit->hci_cmdwait);
	IF_PURGE(&unit->hci_scodone);
}

struct hci_unit *
hci_unit_lookup(bdaddr_t *addr)
{
	struct hci_unit *unit;

	TAILQ_FOREACH(unit, &hci_unit_list, hci_next) {
		if ((unit->hci_flags & BTF_UP) == 0)
			continue;

		if (bdaddr_same(&unit->hci_bdaddr, addr))
			break;
	}

	return unit;
}

/*
 * construct and queue a HCI command packet
 */
int
hci_send_cmd(struct hci_unit *unit, uint16_t opcode, void *buf, uint8_t len)
{
	struct mbuf *m;
	hci_cmd_hdr_t *p;

	KASSERT(unit != NULL);

	m = m_gethdr(M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return ENOMEM;

	p = mtod(m, hci_cmd_hdr_t *);
	p->type = HCI_CMD_PKT;
	p->opcode = htole16(opcode);
	p->length = len;
	m->m_pkthdr.len = m->m_len = sizeof(hci_cmd_hdr_t);
	M_SETCTX(m, NULL);	/* XXX is this needed? */

	if (len) {
		KASSERT(buf != NULL);

		m_copyback(m, sizeof(hci_cmd_hdr_t), len, buf, M_NOWAIT);
		if (m->m_pkthdr.len != (sizeof(hci_cmd_hdr_t) + len)) {
			m_freem(m);
			return ENOMEM;
		}
	}

	DPRINTFN(2, "(%s) opcode (%3.3x|%4.4x)\n", device_xname(unit->hci_dev),
		HCI_OGF(opcode), HCI_OCF(opcode));

	/* and send it on */
	if (unit->hci_num_cmd_pkts == 0)
		IF_ENQUEUE(&unit->hci_cmdwait, m);
	else
		hci_output_cmd(unit, m);

	return 0;
}

/*
 * Incoming packet processing. Since the code is single threaded
 * in any case (IPL_SOFTNET), we handle it all in one interrupt function
 * picking our way through more important packets first so that hopefully
 * we will never get clogged up with bulk data.
 */
void
hci_intr(void *arg)
{
	struct hci_unit *unit = arg;
	struct mbuf *m;

	mutex_enter(&bt_lock);
another:
	mutex_enter(&unit->hci_devlock);

	if (unit->hci_eventqlen > 0) {
		IF_DEQUEUE(&unit->hci_eventq, m);
		unit->hci_eventqlen--;
		mutex_exit(&unit->hci_devlock);

		KASSERT(m != NULL);

		DPRINTFN(10, "(%s) recv event, len = %d\n",
		    device_xname(unit->hci_dev), m->m_pkthdr.len);

		m->m_flags |= M_LINK0;	/* mark incoming packet */
		hci_mtap(m, unit);
		hci_event(m, unit);

		goto another;
	}

	if (unit->hci_scorxqlen > 0) {
		IF_DEQUEUE(&unit->hci_scorxq, m);
		unit->hci_scorxqlen--;
		mutex_exit(&unit->hci_devlock);

		KASSERT(m != NULL);

		DPRINTFN(10, "(%s) recv SCO, len = %d\n",
		    device_xname(unit->hci_dev), m->m_pkthdr.len);

		m->m_flags |= M_LINK0;	/* mark incoming packet */
		hci_mtap(m, unit);
		hci_sco_recv(m, unit);

		goto another;
	}

	if (unit->hci_aclrxqlen > 0) {
		IF_DEQUEUE(&unit->hci_aclrxq, m);
		unit->hci_aclrxqlen--;
		mutex_exit(&unit->hci_devlock);

		KASSERT(m != NULL);

		DPRINTFN(10, "(%s) recv ACL, len = %d\n",
		    device_xname(unit->hci_dev), m->m_pkthdr.len);

		m->m_flags |= M_LINK0;	/* mark incoming packet */
		hci_mtap(m, unit);
		hci_acl_recv(m, unit);

		goto another;
	}

	IF_DEQUEUE(&unit->hci_scodone, m);
	if (m != NULL) {
		struct hci_link *link;

		mutex_exit(&unit->hci_devlock);

		DPRINTFN(11, "(%s) complete SCO\n",
		    device_xname(unit->hci_dev));

		TAILQ_FOREACH(link, &unit->hci_links, hl_next) {
			if (link == M_GETCTX(m, struct hci_link *)) {
				hci_sco_complete(link, 1);
				break;
			}
		}

		unit->hci_num_sco_pkts++;
		m_freem(m);

		goto another;
	}

	mutex_exit(&unit->hci_devlock);
	mutex_exit(&bt_lock);

	DPRINTFN(10, "done\n");
}

/**********************************************************************
 *
 * IO routines
 *
 * input & complete routines will be called from device drivers,
 * possibly in interrupt context. We return success or failure to
 * enable proper accounting but we own the mbuf.
 */

int
hci_input_event(struct hci_unit *unit, struct mbuf *m)
{
	int rv;

	mutex_enter(&unit->hci_devlock);

	if (unit->hci_eventqlen > hci_eventq_max) {
		DPRINTF("(%s) dropped event packet.\n", device_xname(unit->hci_dev));
		m_freem(m);
		rv = 0;
	} else {
		unit->hci_eventqlen++;
		IF_ENQUEUE(&unit->hci_eventq, m);
		schednetisr(NETISR_BT);
		rv = 1;
	}

	mutex_exit(&unit->hci_devlock);
	return rv;
}

int
hci_input_acl(struct hci_unit *unit, struct mbuf *m)
{
	int rv;

	mutex_enter(&unit->hci_devlock);

	if (unit->hci_aclrxqlen > hci_aclrxq_max) {
		DPRINTF("(%s) dropped ACL packet.\n", device_xname(unit->hci_dev));
		m_freem(m);
		rv = 0;
	} else {
		unit->hci_aclrxqlen++;
		IF_ENQUEUE(&unit->hci_aclrxq, m);
		schednetisr(NETISR_BT);
		rv = 1;
	}

	mutex_exit(&unit->hci_devlock);
	return rv;
}

int
hci_input_sco(struct hci_unit *unit, struct mbuf *m)
{
	int rv;

	mutex_enter(&unit->hci_devlock);

	if (unit->hci_scorxqlen > hci_scorxq_max) {
		DPRINTF("(%s) dropped SCO packet.\n", device_xname(unit->hci_dev));
		m_freem(m);
		rv = 0;
	} else {
		unit->hci_scorxqlen++;
		IF_ENQUEUE(&unit->hci_scorxq, m);
		schednetisr(NETISR_BT);
		rv = 1;
	}

	mutex_exit(&unit->hci_devlock);
	return rv;
}

void
hci_output_cmd(struct hci_unit *unit, struct mbuf *m)
{
	void *arg;

	hci_mtap(m, unit);

	DPRINTFN(10, "(%s) num_cmd_pkts=%d\n",
	    device_xname(unit->hci_dev), unit->hci_num_cmd_pkts);

	unit->hci_num_cmd_pkts--;

	/*
	 * If context is set, this was from a HCI raw socket
	 * and a record needs to be dropped from the sockbuf.
	 */
	arg = M_GETCTX(m, void *);
	if (arg != NULL)
		hci_drop(arg);

	(*unit->hci_if->output_cmd)(unit->hci_dev, m);
}

void
hci_output_acl(struct hci_unit *unit, struct mbuf *m)
{

	hci_mtap(m, unit);

	DPRINTFN(10, "(%s) num_acl_pkts=%d\n",
	    device_xname(unit->hci_dev), unit->hci_num_acl_pkts);

	unit->hci_num_acl_pkts--;
	(*unit->hci_if->output_acl)(unit->hci_dev, m);
}

void
hci_output_sco(struct hci_unit *unit, struct mbuf *m)
{

	hci_mtap(m, unit);

	DPRINTFN(10, "(%s) num_sco_pkts=%d\n",
	    device_xname(unit->hci_dev), unit->hci_num_sco_pkts);

	unit->hci_num_sco_pkts--;
	(*unit->hci_if->output_sco)(unit->hci_dev, m);
}

int
hci_complete_sco(struct hci_unit *unit, struct mbuf *m)
{

#ifndef __OpenBSD__
	if (unit->hci_rxint == NULL) {
		DPRINTFN(10, "(%s) complete SCO!\n", device_xname(unit->hci_dev));
		m_freem(m);
		return 0;
	}
#endif

	mutex_enter(&unit->hci_devlock);

	IF_ENQUEUE(&unit->hci_scodone, m);
	schednetisr(NETISR_BT);

	mutex_exit(&unit->hci_devlock);
	return 1;
}

/*
 * update num_cmd_pkts and push on pending commands queue
 */
void
hci_num_cmds(struct hci_unit *unit, uint8_t num)
{
	struct mbuf *m;

	unit->hci_num_cmd_pkts = num;

	while (unit->hci_num_cmd_pkts > 0 && !IF_IS_EMPTY(&unit->hci_cmdwait)) {
		IF_DEQUEUE(&unit->hci_cmdwait, m);
		hci_output_cmd(unit, m);
	}
}
@


1.12
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.11 2010/07/02 02:40:16 blambert Exp $	*/
@


1.11
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.10 2008/11/22 16:56:39 uwe Exp $	*/
d103 5
a107 5
	unit->hci_eventq.ifq_maxlen = hci_eventq_max;
	unit->hci_aclrxq.ifq_maxlen = hci_aclrxq_max;
	unit->hci_scorxq.ifq_maxlen = hci_scorxq_max;
	unit->hci_cmdwait.ifq_maxlen = hci_cmdwait_max;
	unit->hci_scodone.ifq_maxlen = hci_scodone_max;
@


1.10
log
@Stop a possible race in hci_enable()
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.9 2008/11/22 04:42:58 uwe Exp $	*/
d319 1
a319 1
		m_copyback(m, sizeof(hci_cmd_hdr_t), len, buf);
@


1.9
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.8 2008/02/24 21:34:48 uwe Exp $	*/
d137 7
@


1.8
log
@Sync sys/netbt with NetBSD
ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: hci_unit.c,v 1.7 2007/06/24 20:55:27 uwe Exp $	*/
/*	$NetBSD: hci_unit.c,v 1.9 2007/12/30 18:26:42 plunky Exp $	*/
a83 1
	int s;
d101 1
d112 1
a112 1
	s = splsoftnet();
d114 1
a114 1
	splx(s);
a121 1
	int s;
d123 1
a123 1
	s = splsoftnet();
d127 1
a127 1
	splx(s);
d129 1
d181 2
a182 1
		err = tsleep(unit, PWAIT | PCATCH, __func__, 5 * hz);
d220 3
a222 1
		config_detach(unit->hci_bthub, DETACH_FORCE);
d224 4
d343 1
d345 1
a345 1
	mtx_enter(&unit->hci_devlock);
d350 1
a350 1
		mtx_leave(&unit->hci_devlock);
d367 1
a367 1
		mtx_leave(&unit->hci_devlock);
d384 1
a384 1
		mtx_leave(&unit->hci_devlock);
d402 1
a402 1
		mtx_leave(&unit->hci_devlock);
d420 2
a421 1
	mtx_leave(&unit->hci_devlock);
d440 1
a440 1
	mtx_enter(&unit->hci_devlock);
d453 1
a453 1
	mtx_leave(&unit->hci_devlock);
d462 1
a462 1
	mtx_enter(&unit->hci_devlock);
d475 1
a475 1
	mtx_leave(&unit->hci_devlock);
d484 1
a484 1
	mtx_enter(&unit->hci_devlock);
d497 1
a497 1
	mtx_leave(&unit->hci_devlock);
d562 1
a562 1
	mtx_enter(&unit->hci_devlock);
d567 1
a567 1
	mtx_leave(&unit->hci_devlock);
d569 16
@


1.7
log
@Remove some unused leftover code; original request from jasper@@
@
text
@d1 2
a2 2
/*	$OpenBSD: hci_unit.c,v 1.6 2007/06/06 21:37:08 uwe Exp $	*/
/*	$NetBSD: hci_unit.c,v 1.4 2007/03/30 20:47:03 plunky Exp $	*/
a33 2
#include <sys/cdefs.h>

d57 18
d80 2
a81 2
void
hci_attach(struct hci_unit *unit)
d83 19
a101 7
	KASSERT(unit->hci_softc != NULL);
	KASSERT(unit->hci_devname != NULL);
	KASSERT(unit->hci_enable != NULL);
	KASSERT(unit->hci_disable != NULL);
	KASSERT(unit->hci_start_cmd != NULL);
	KASSERT(unit->hci_start_acl != NULL);
	KASSERT(unit->hci_start_sco != NULL);
d106 2
d112 1
d114 3
d122 3
d128 3
d136 1
a136 1
	int s, err;
d143 1
a143 3
	 * No-op Command Status packet when they are ready, so
	 * we set this here and allow the driver (bt3c) to zero
	 * it.
d145 1
a145 1
	unit->hci_num_cmd_pkts = 1;
d156 9
a164 3
	s = splraiseipl(unit->hci_ipl);
	err = (*unit->hci_enable)(unit);
	splx(s);
d168 2
d194 1
a194 1
	unit->hci_bthub = config_found(unit->hci_softc,
d200 7
a206 3
	s = splraiseipl(unit->hci_ipl);
	(*unit->hci_disable)(unit);
	splx(s);
a207 1
bad1:
d216 1
a216 1
	int s, acl;
d223 9
a231 3
	s = splraiseipl(unit->hci_ipl);
	(*unit->hci_disable)(unit);
	splx(s);
d249 2
a259 1
	IF_PURGE(&unit->hci_cmdq);
a260 2
	IF_PURGE(&unit->hci_acltxq);
	IF_PURGE(&unit->hci_scotxq);
d300 1
a300 1
	M_SETCTX(m, NULL);
d312 1
a312 1
	DPRINTFN(2, "(%s) opcode (%3.3x|%4.4x)\n", unit->hci_devname,
a334 1
	int s;
d337 1
a337 1
	s = splraiseipl(unit->hci_ipl);
d342 2
a344 1
		splx(s);
d347 1
a347 1
				unit->hci_devname, m->m_pkthdr.len);
d359 2
a361 1
		splx(s);
d364 1
a364 1
				unit->hci_devname, m->m_pkthdr.len);
d376 2
a378 1
		splx(s);
d381 1
a381 1
				unit->hci_devname, m->m_pkthdr.len);
d393 2
a394 1
		splx(s);
d397 1
a397 1
				unit->hci_devname);
d412 1
a412 1
	splx(s);
d421 3
a423 2
 * input & complete routines will be called from device driver
 * (at unit->hci_ipl)
d426 1
a426 1
void
d429 4
d434 1
a434 2
		DPRINTF("(%s) dropped event packet.\n", unit->hci_devname);
		unit->hci_stats.err_rx++;
d436 1
d441 1
d443 3
d448 1
a448 1
void
d451 4
d456 1
a456 2
		DPRINTF("(%s) dropped ACL packet.\n", unit->hci_devname);
		unit->hci_stats.err_rx++;
d458 1
d463 1
d465 3
d470 1
a470 1
void
d473 4
d478 1
a478 2
		DPRINTF("(%s) dropped SCO packet.\n", unit->hci_devname);
		unit->hci_stats.err_rx++;
d480 1
d485 1
d487 3
a495 1
	int s;
d499 2
a500 2
	DPRINTFN(10, "(%s) num_cmd_pkts=%d\n", unit->hci_devname,
					       unit->hci_num_cmd_pkts);
d512 1
a512 6
	s = splraiseipl(unit->hci_ipl);
	IF_ENQUEUE(&unit->hci_cmdq, m);
	if ((unit->hci_flags & BTF_XMIT_CMD) == 0)
		(*unit->hci_start_cmd)(unit);

	splx(s);
a517 1
	int s;
d521 2
a522 2
	DPRINTFN(10, "(%s) num_acl_pkts=%d\n", unit->hci_devname,
					       unit->hci_num_acl_pkts);
d525 1
a525 7

	s = splraiseipl(unit->hci_ipl);
	IF_ENQUEUE(&unit->hci_acltxq, m);
	if ((unit->hci_flags & BTF_XMIT_ACL) == 0)
		(*unit->hci_start_acl)(unit);

	splx(s);
a530 1
	int s;
d534 2
a535 2
	DPRINTFN(10, "(%s) num_sco_pkts=%d\n", unit->hci_devname,
					       unit->hci_num_sco_pkts);
d538 1
a538 7

	s = splraiseipl(unit->hci_ipl);
	IF_ENQUEUE(&unit->hci_scotxq, m);
	if ((unit->hci_flags & BTF_XMIT_SCO) == 0)
		(*unit->hci_start_sco)(unit);

	splx(s);
d541 1
a541 1
void
d544 11
d557 3
@


1.6
log
@No need to call hci_enable() when we can do "btconfig <dev> up"; ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.5 2007/06/01 20:29:54 uwe Exp $	*/
a63 3
void hci_enable_task(void *, void *);
void hci_intr(void *);

a90 10
}

void
hci_enable_task(void *arg0, void *arg1)
{
	struct hci_unit *unit = arg0;

	unit->hci_flags |= BTF_UP;
	if (hci_enable(unit) != 0)
		unit->hci_flags &= ~BTF_UP;
@


1.5
log
@Set BTF_UP before hci_enable() to make hci_unit_lookup() work; ok gwk
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.4 2007/06/01 20:03:31 uwe Exp $	*/
a44 1
#include <sys/workq.h>
a66 2
struct workq *hci_workq;

a85 7

	/* XXX enable HCI by default until we have userland tools */
	if (hci_workq == NULL)
		hci_workq = workq_create("hci_enable", 1);
	if (hci_workq != NULL)
		(void)workq_add_task(hci_workq, 0,
		    hci_enable_task, unit, NULL);
@


1.4
log
@workq_add_task() flags argument position changed
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.3 2007/06/01 02:46:11 uwe Exp $	*/
d111 3
a113 2
	if (!(unit->hci_flags & BTF_UP) && hci_enable(unit) == 0)
		unit->hci_flags |= BTF_UP;
@


1.3
log
@complete the sys/netbt import and adopt some more code to our interfaces
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.2 2007/05/31 23:50:19 uwe Exp $	*/
d94 2
a95 2
		(void)workq_add_task(hci_workq, hci_enable_task, unit,
		    NULL, 0);
@


1.2
log
@Enable packet flow between HCI driver and controller
- not all platforms have generic sofintr support, use schednetisr()
- enable HCI driver at attach time (for development, since we have no
  userland tools yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: hci_unit.c,v 1.1 2007/05/30 03:42:53 uwe Exp $	*/
a51 2
#define splraiseipl(ipl) splbio() /* XXX */

d268 1
a364 1
#ifdef notyet			/* XXX */
a368 1
#endif
a434 1
#ifdef notyet
a435 1
#endif
a448 1
#ifdef notyet			/* XXX */
a451 1
#endif
@


1.1
log
@Import parts of the NetBSD bluetooth stack; ok gwk, and grange on removal
of the existing code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 3
d52 2
d67 1
d70 2
a74 1

d91 7
a102 1

d108 9
a141 8
/* XXX */
#ifdef notyet
	unit->hci_rxint = softintr_establish(IPL_SOFTNET, &hci_intr, unit);
	if (unit->hci_rxint == NULL)
		return EIO;
#endif
#define splraiseipl(ipl) splnet()

a182 5
#ifdef notyet			/* XXX */
	softintr_disestablish(unit->hci_rxint);
#endif
	unit->hci_rxint = NULL;

a197 7
	if (unit->hci_rxint) {
#ifdef notyet			/* XXX */
		softintr_disestablish(unit->hci_rxint);
#endif
		unit->hci_rxint = NULL;
	}

d396 1
a396 2

	if (unit->hci_eventqlen > hci_eventq_max || unit->hci_rxint == NULL) {
d403 1
a403 3
#ifdef notyet			/* XXX */
		softintr_schedule(unit->hci_rxint);
#endif
d410 1
a410 2

	if (unit->hci_aclrxqlen > hci_aclrxq_max || unit->hci_rxint == NULL) {
d417 1
a417 3
#ifdef notyet			/* XXX */
		softintr_schedule(unit->hci_rxint);
#endif
d424 1
a424 2

	if (unit->hci_scorxqlen > hci_scorxq_max || unit->hci_rxint == NULL) {
d431 1
a431 3
#ifdef notyet			/* XXX */
		softintr_schedule(unit->hci_rxint);
#endif
d511 2
a512 11

	if (unit->hci_rxint == NULL) {
		DPRINTFN(10, "(%s) complete SCO!\n", unit->hci_devname);
		unit->hci_stats.err_rx++;
		m_freem(m);
	} else {
		IF_ENQUEUE(&unit->hci_scodone, m);
#ifdef notyet			/* XXX */
		softintr_schedule(unit->hci_rxint);
#endif
	}
@

