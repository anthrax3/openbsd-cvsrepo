head	1.9;
access;
symbols
	OPENBSD_5_5:1.8.0.18
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.14
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.12
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.10
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.8
	OPENBSD_5_0:1.8.0.6
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.4
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.2
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.4.0.2
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.3.0.2
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.2.0.2
	OPENBSD_4_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.9
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.8;
commitid	0n9cIGBISFAEt4b1;

1.8
date	2010.07.29.14.40.47;	author blambert;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.29.14.06.26;	author blambert;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.4;

1.4
date	2008.06.08.21.10.28;	author claudio;	state Exp;
branches;
next	1.3;

1.3
date	2008.02.24.21.34.48;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.01.02.46.11;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.30.03.42.53;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.9
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: l2cap_misc.c,v 1.8 2010/07/29 14:40:47 blambert Exp $	*/
/*	$NetBSD: l2cap_misc.c,v 1.6 2008/04/24 11:38:37 ad Exp $	*/

/*-
 * Copyright (c) 2005 Iain Hibbert.
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/systm.h>

#include <netbt/bluetooth.h>
#include <netbt/hci.h>
#include <netbt/l2cap.h>

struct l2cap_channel_list
	l2cap_active_list = LIST_HEAD_INITIALIZER(l2cap_active_list);
struct l2cap_channel_list
	l2cap_listen_list = LIST_HEAD_INITIALIZER(l2cap_listen_list);

struct pool l2cap_req_pool;
struct pool l2cap_pdu_pool;

const l2cap_qos_t l2cap_default_qos = {
	0,			/* flags */
	L2CAP_QOS_BEST_EFFORT,	/* service type */
	0x00000000,		/* token rate */
	0x00000000,		/* token bucket size */
	0x00000000,		/* peak bandwidth */
	0xffffffff,		/* latency */
	0xffffffff		/* delay variation */
};

/*
 * L2CAP request timeouts
 */
int l2cap_response_timeout = 30;		/* seconds */
int l2cap_response_extended_timeout = 180;	/* seconds */

void
l2cap_init(void)
{
	pool_init(&l2cap_req_pool, sizeof(struct l2cap_req), 0, 0, 0,
	    "l2cap_req", NULL);
	pool_init(&l2cap_pdu_pool, sizeof(struct l2cap_pdu), 0, 0, 0,
	    "l2cap_pdu", NULL);
}

/*
 * Set Link Mode on channel
 */
int
l2cap_setmode(struct l2cap_channel *chan)
{

	KASSERT(chan != NULL);
	KASSERT(chan->lc_link != NULL);

	DPRINTF("(%s) CID #%d, auth %s, encrypt %s, secure %s\n",
	    device_xname(chan->lc_link->hl_unit->hci_dev), chan->lc_lcid,
	    (chan->lc_mode & L2CAP_LM_AUTH ? "yes" : "no"),
	    (chan->lc_mode & L2CAP_LM_ENCRYPT ? "yes" : "no"),
	    (chan->lc_mode & L2CAP_LM_SECURE ? "yes" : "no"));

	if (chan->lc_mode & L2CAP_LM_AUTH)
		chan->lc_link->hl_flags |= HCI_LINK_AUTH_REQ;

	if (chan->lc_mode & L2CAP_LM_ENCRYPT)
		chan->lc_link->hl_flags |= HCI_LINK_ENCRYPT_REQ;

	if (chan->lc_mode & L2CAP_LM_SECURE)
		chan->lc_link->hl_flags |= HCI_LINK_SECURE_REQ;

	return hci_acl_setmode(chan->lc_link);
}

/*
 * Allocate a new Request structure & ID and set the timer going
 */
int
l2cap_request_alloc(struct l2cap_channel *chan, uint8_t code)
{
	struct hci_link *link = chan->lc_link;
	struct l2cap_req *req;
	int next_id;

	if (link == NULL)
		return ENETDOWN;

	/* find next ID (0 is not allowed) */
	next_id = link->hl_lastid + 1;
	if (next_id > 0xff)
		next_id = 1;

	/* Ouroboros check */
	req = TAILQ_FIRST(&link->hl_reqs);
	if (req && req->lr_id == next_id)
		return ENFILE;

	req = pool_get(&l2cap_req_pool, PR_NOWAIT);
	if (req == NULL)
		return ENOMEM;

	req->lr_id = link->hl_lastid = next_id;

	req->lr_code = code;
	req->lr_chan = chan;
	req->lr_link = link;

	timeout_set(&req->lr_rtx, l2cap_rtx, req);
	timeout_add_sec(&req->lr_rtx, l2cap_response_timeout);

	TAILQ_INSERT_TAIL(&link->hl_reqs, req, lr_next);

	return 0;
}

/*
 * Find a running request for this link
 */
struct l2cap_req *
l2cap_request_lookup(struct hci_link *link, uint8_t id)
{
	struct l2cap_req *req;

	TAILQ_FOREACH(req, &link->hl_reqs, lr_next) {
		if (req->lr_id == id)
			return req;
	}

	return NULL;
}

/*
 * Halt and free a request
 */
void
l2cap_request_free(struct l2cap_req *req)
{
	struct hci_link *link = req->lr_link;

	if (timeout_triggered(&req->lr_rtx))
		return;
	timeout_del(&req->lr_rtx);

	TAILQ_REMOVE(&link->hl_reqs, req, lr_next);
	pool_put(&l2cap_req_pool, req);
}

/*
 * Response Timeout eXpired
 *
 * No response to our request, so deal with it as best we can.
 *
 * XXX should try again at least with ertx?
 */
void
l2cap_rtx(void *arg)
{
	struct l2cap_req *req = arg;
	struct l2cap_channel *chan;

	mutex_enter(&bt_lock);

	chan = req->lr_chan;
	DPRINTF("cid %d, ident %d\n", (chan ? chan->lc_lcid : 0), req->lr_id);

	l2cap_request_free(req);

	if (chan && chan->lc_state != L2CAP_CLOSED)
		l2cap_close(chan, ETIMEDOUT);

	mutex_exit(&bt_lock);
}

/*
 * Allocate next available CID to channel. We keep a single
 * ordered list of channels, so find the first gap.
 *
 * If this turns out to be not enough (!), could use a
 * list per HCI unit..
 */
int
l2cap_cid_alloc(struct l2cap_channel *chan)
{
	struct l2cap_channel *used, *prev = NULL;
	uint16_t cid = L2CAP_FIRST_CID;

	if (chan->lc_lcid != L2CAP_NULL_CID || chan->lc_state != L2CAP_CLOSED)
		return EISCONN;

	LIST_FOREACH(used, &l2cap_active_list, lc_ncid) {
		if (used->lc_lcid > cid)
			break;	/* found our gap */

		KASSERT(used->lc_lcid == cid);
		cid++;

		if (cid == L2CAP_LAST_CID)
			return ENFILE;

		prev = used;	/* for insert after */
	}

	chan->lc_lcid = cid;

	if (prev)
		LIST_INSERT_AFTER(prev, chan, lc_ncid);
	else
		LIST_INSERT_HEAD(&l2cap_active_list, chan, lc_ncid);

	return 0;
}

/*
 * Find channel with CID
 */
struct l2cap_channel *
l2cap_cid_lookup(uint16_t cid)
{
	struct l2cap_channel *chan;

	LIST_FOREACH(chan, &l2cap_active_list, lc_ncid) {
		if (chan->lc_lcid == cid)
			return chan;

		if (chan->lc_lcid > cid)
			return NULL;
	}

	return NULL;
}
@


1.8
log
@sort pool.h into the list of includes alphabetically

pointed out by kettenis@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: l2cap_misc.c,v 1.7 2010/07/29 14:06:26 blambert Exp $	*/
@


1.7
log
@#include <sys/pool.h> directly, instead of relying on mbuf.h to inlcude it

ok miod@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: l2cap_misc.c,v 1.6 2008/11/22 04:42:58 uwe Exp $	*/
d37 1
a40 1
#include <sys/pool.h>
@


1.6
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: l2cap_misc.c,v 1.5 2008/09/10 14:01:23 blambert Exp $	*/
d40 1
@


1.5
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 2
a2 2
/*	$OpenBSD: l2cap_misc.c,v 1.4 2008/06/08 21:10:28 claudio Exp $	*/
/*	$NetBSD: l2cap_misc.c,v 1.5 2007/11/03 17:20:17 plunky Exp $	*/
a190 1
	int s;
d192 1
a192 1
	s = splsoftnet();
d202 1
a202 1
	splx(s);
@


1.4
log
@timeout_del() removes the triggered flag so check if the timeout triggered
before doing the timeout_del() -- which is actually not needed as triggered
timeouts are already removed. While there fix a obvious use after free issue.
with mk@@ OK canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: l2cap_misc.c,v 1.3 2008/02/24 21:34:48 uwe Exp $	*/
d140 1
a140 1
	timeout_add(&req->lr_rtx, l2cap_response_timeout*hz);
@


1.3
log
@Sync sys/netbt with NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: l2cap_misc.c,v 1.2 2007/06/01 02:46:11 uwe Exp $	*/
a170 1
	timeout_del(&req->lr_rtx);
d173 1
d196 2
a198 2

	DPRINTF("cid %d, ident %d\n", (chan ? chan->lc_lcid : 0), req->lr_id);
@


1.2
log
@complete the sys/netbt import and adopt some more code to our interfaces
@
text
@d1 2
a2 2
/*	$OpenBSD: l2cap_misc.c,v 1.1 2007/05/30 03:42:53 uwe Exp $	*/
/*	$NetBSD: l2cap_misc.c,v 1.3 2007/04/21 06:15:23 plunky Exp $	*/
a33 2
#include <sys/cdefs.h>

d88 5
a92 4
	DPRINTF("CID #%d, auth %s, encrypt %s, secure %s\n", chan->lc_lcid,
		(chan->lc_mode & L2CAP_LM_AUTH ? "yes" : "no"),
		(chan->lc_mode & L2CAP_LM_ENCRYPT ? "yes" : "no"),
		(chan->lc_mode & L2CAP_LM_SECURE ? "yes" : "no"));
@


1.1
log
@Import parts of the NetBSD bluetooth stack; ok gwk, and grange on removal
of the existing code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 6
#ifdef notyet			/* XXX */
POOL_INIT(l2cap_req_pool, sizeof(struct l2cap_req), 0, 0, 0, "l2cap_req", NULL,
    IPL_SOFTNET);
POOL_INIT(l2cap_pdu_pool, sizeof(struct l2cap_pdu), 0, 0, 0, "l2cap_pdu", NULL,
    IPL_SOFTNET);
#endif
d70 9
@

