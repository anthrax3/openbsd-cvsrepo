head	1.14;
access;
symbols
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.3.0.8
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.6
	OPENBSD_4_0_BASE:1.3
	OPENBSD_3_9:1.3.0.4
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.13;
commitid	0n9cIGBISFAEt4b1;

1.13
date	2008.11.25.14.00.12;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.27.19.41.14;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.24.21.34.48;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.22.21.05.00;	author gwk;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.24.20.55.27;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.19.08.12.34;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.01.02.46.11;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.31.23.50.19;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.30.03.42.53;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.15.21.16.40;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.17.18.12.49;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.12.04.02;	author grange;	state Exp;
branches;
next	;


desc
@@


1.14
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: hci.h,v 1.13 2008/11/25 14:00:12 uwe Exp $	*/
/*	$NetBSD: hci.h,v 1.28 2008/09/08 23:36:55 gmcgarry Exp $	*/

/*-
 * Copyright (c) 2005 Iain Hibbert.
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*-
 * Copyright (c) 2001 Maksim Yevmenkin <m_evmenkin@@yahoo.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: hci.h,v 1.13 2008/11/25 14:00:12 uwe Exp $
 * $FreeBSD: src/sys/netgraph/bluetooth/include/ng_hci.h,v 1.6 2005/01/07 01:45:43 imp Exp $
 */

/*
 * This file contains everything that applications need to know from
 * Host Controller Interface (HCI). Information taken from Bluetooth
 * Core Specifications (v1.1, v2.0 and v2.1)
 *
 * This file can be included by both kernel and userland applications.
 *
 * NOTE: Here and after Bluetooth device is called a "unit". Bluetooth
 *       specification refers to both devices and units. They are the
 *       same thing (I think), so to be consistent word "unit" will be
 *       used.
 */

#ifndef _NETBT_HCI_H_
#define _NETBT_HCI_H_

#include <netbt/bluetooth.h>

#include <sys/mutex.h>

/**************************************************************************
 **************************************************************************
 **                   Common defines and types (HCI)
 **************************************************************************
 **************************************************************************/

#define HCI_LAP_SIZE			3   /* unit LAP */
#define HCI_KEY_SIZE			16  /* link key */
#define HCI_PIN_SIZE			16  /* link PIN */
#define HCI_EVENT_MASK_SIZE		8   /* event mask */
#define HCI_CLASS_SIZE			3   /* unit class */
#define HCI_FEATURES_SIZE		8   /* LMP features */
#define HCI_UNIT_NAME_SIZE		248 /* unit name size */
#define HCI_DEVNAME_SIZE		16  /* same as dv_xname */
#define HCI_COMMANDS_SIZE		64  /* supported commands mask */

/* HCI specification */
#define HCI_SPEC_V10			0x00 /* v1.0 */
#define HCI_SPEC_V11			0x01 /* v1.1 */
#define HCI_SPEC_V12			0x02 /* v1.2 */
#define HCI_SPEC_V20			0x03 /* v2.0 */
#define HCI_SPEC_V21			0x04 /* v2.1 */
/* 0x05 - 0xFF - reserved for future use */

/* LMP features (and page 0 of extended features) */
/* ------------------- byte 0 --------------------*/
#define HCI_LMP_3SLOT			0x01
#define HCI_LMP_5SLOT			0x02
#define HCI_LMP_ENCRYPTION		0x04
#define HCI_LMP_SLOT_OFFSET		0x08
#define HCI_LMP_TIMIACCURACY		0x10
#define HCI_LMP_ROLE_SWITCH		0x20
#define HCI_LMP_HOLD_MODE		0x40
#define HCI_LMP_SNIFF_MODE		0x80
/* ------------------- byte 1 --------------------*/
#define HCI_LMP_PARK_MODE		0x01
#define HCI_LMP_RSSI			0x02
#define HCI_LMP_CHANNEL_QUALITY		0x04
#define HCI_LMP_SCO_LINK		0x08
#define HCI_LMP_HV2_PKT			0x10
#define HCI_LMP_HV3_PKT			0x20
#define HCI_LMP_ULAW_LOG		0x40
#define HCI_LMP_ALAW_LOG		0x80
/* ------------------- byte 2 --------------------*/
#define HCI_LMP_CVSD			0x01
#define HCI_LMP_PAGISCHEME		0x02
#define HCI_LMP_POWER_CONTROL		0x04
#define HCI_LMP_TRANSPARENT_SCO		0x08
#define HCI_LMP_FLOW_CONTROL_LAG0	0x10
#define HCI_LMP_FLOW_CONTROL_LAG1	0x20
#define HCI_LMP_FLOW_CONTROL_LAG2	0x40
#define HCI_LMP_BC_ENCRYPTION		0x80
/* ------------------- byte 3 --------------------*/
/* reserved				0x01 */
#define HCI_LMP_EDR_ACL_2MBPS		0x02
#define HCI_LMP_EDR_ACL_3MBPS		0x04
#define HCI_LMP_ENHANCED_ISCAN		0x08
#define HCI_LMP_INTERLACED_ISCAN	0x10
#define HCI_LMP_INTERLACED_PSCAN	0x20
#define HCI_LMP_RSSI_INQUIRY		0x40
#define HCI_LMP_EV3_PKT			0x80
/* ------------------- byte 4 --------------------*/
#define HCI_LMP_EV4_PKT			0x01
#define HCI_LMP_EV5_PKT			0x02
/* reserved				0x04 */
#define HCI_LMP_AFH_CAPABLE_SLAVE	0x08
#define HCI_LMP_AFH_CLASS_SLAVE		0x10
/* reserved				0x20 */
/* reserved				0x40 */
#define HCI_LMP_3SLOT_EDR_ACL		0x80
/* ------------------- byte 5 --------------------*/
#define HCI_LMP_5SLOT_EDR_ACL		0x01
#define HCI_LMP_SNIFF_SUBRATING		0x02
#define HCI_LMP_PAUSE_ENCRYPTION	0x04
#define HCI_LMP_AFH_CAPABLE_MASTER	0x08
#define HCI_LMP_AFH_CLASS_MASTER	0x10
#define HCI_LMP_EDR_eSCO_2MBPS		0x20
#define HCI_LMP_EDR_eSCO_3MBPS		0x40
#define HCI_LMP_3SLOT_EDR_eSCO		0x80
/* ------------------- byte 6 --------------------*/
#define HCI_LMP_EXTENDED_INQUIRY	0x01
/* reserved				0x02 */
/* reserved				0x04 */
#define HCI_LMP_SIMPLE_PAIRING		0x08
#define HCI_LMP_ENCAPSULATED_PDU	0x10
#define HCI_LMP_ERRDATA_REPORTING	0x20
#define HCI_LMP_NOFLUSH_PB_FLAG		0x40
/* reserved				0x80 */
/* ------------------- byte 7 --------------------*/
#define HCI_LMP_LINK_SUPERVISION_TO	0x01
#define HCI_LMP_INQ_RSP_TX_POWER	0x02
#define HCI_LMP_EXTENDED_FEATURES	0x80

/* Link types */
#define HCI_LINK_SCO			0x00 /* Voice */
#define HCI_LINK_ACL			0x01 /* Data */
#define HCI_LINK_eSCO			0x02 /* eSCO */
/* 0x03 - 0xFF - reserved for future use */

/*
 * ACL/SCO packet type bits are set to enable the
 * packet type, except for 2MBPS and 3MBPS when they
 * are unset to enable the packet type.
 */
/* ACL Packet types for "Create Connection" */
#define HCI_PKT_2MBPS_DH1	0x0002
#define HCI_PKT_3MBPS_DH1	0x0004
#define HCI_PKT_DM1		0x0008
#define HCI_PKT_DH1		0x0010
#define HCI_PKT_2MBPS_DH3	0x0100
#define HCI_PKT_3MBPS_DH3	0x0200
#define HCI_PKT_DM3		0x0400
#define HCI_PKT_DH3		0x0800
#define HCI_PKT_2MBPS_DH5	0x1000
#define HCI_PKT_3MBPS_DH5	0x2000
#define HCI_PKT_DM5		0x4000
#define HCI_PKT_DH5		0x8000

/* SCO Packet types for "Setup Synchronous Connection" */
#define HCI_PKT_HV1		0x0001
#define HCI_PKT_HV2		0x0002
#define HCI_PKT_HV3		0x0004
#define HCI_PKT_EV3		0x0008
#define HCI_PKT_EV4		0x0010
#define HCI_PKT_EV5		0x0020
#define HCI_PKT_2MBPS_EV3	0x0040
#define HCI_PKT_3MBPS_EV3	0x0080
#define HCI_PKT_2MBPS_EV5	0x0100
#define HCI_PKT_3MBPS_EV5	0x0200

/*
 * Connection modes/Unit modes
 *
 * This is confusing. It means that one of the units change its mode
 * for the specific connection. For example one connection was put on
 * hold (but i could be wrong :)
 */

/* Page scan modes (are deprecated) */
#define HCI_MANDATORY_PAGE_SCAN_MODE		0x00
#define HCI_OPTIONAL_PAGE_SCAN_MODE1		0x01
#define HCI_OPTIONAL_PAGE_SCAN_MODE2		0x02
#define HCI_OPTIONAL_PAGE_SCAN_MODE3		0x03
/* 0x04 - 0xFF - reserved for future use */

/* Page scan repetition modes */
#define HCI_SCAN_REP_MODE0			0x00
#define HCI_SCAN_REP_MODE1			0x01
#define HCI_SCAN_REP_MODE2			0x02
/* 0x03 - 0xFF - reserved for future use */

/* Page scan period modes */
#define HCI_PAGE_SCAN_PERIOD_MODE0		0x00
#define HCI_PAGE_SCAN_PERIOD_MODE1		0x01
#define HCI_PAGE_SCAN_PERIOD_MODE2		0x02
/* 0x03 - 0xFF - reserved for future use */

/* Scan enable */
#define HCI_NO_SCAN_ENABLE			0x00
#define HCI_INQUIRY_SCAN_ENABLE			0x01
#define HCI_PAGE_SCAN_ENABLE			0x02
/* 0x04 - 0xFF - reserved for future use */

/* Hold mode activities */
#define HCI_HOLD_MODE_NO_CHANGE			0x00
#define HCI_HOLD_MODE_SUSPEND_PAGE_SCAN		0x01
#define HCI_HOLD_MODE_SUSPEND_INQUIRY_SCAN	0x02
#define HCI_HOLD_MODE_SUSPEND_PERIOD_INQUIRY	0x04
/* 0x08 - 0x80 - reserved for future use */

/* Connection roles */
#define HCI_ROLE_MASTER				0x00
#define HCI_ROLE_SLAVE				0x01
/* 0x02 - 0xFF - reserved for future use */

/* Key flags */
#define HCI_USE_SEMI_PERMANENT_LINK_KEYS	0x00
#define HCI_USE_TEMPORARY_LINK_KEY		0x01
/* 0x02 - 0xFF - reserved for future use */

/* Pin types */
#define HCI_PIN_TYPE_VARIABLE			0x00
#define HCI_PIN_TYPE_FIXED			0x01

/* Link key types */
#define HCI_LINK_KEY_TYPE_COMBINATION_KEY	0x00
#define HCI_LINK_KEY_TYPE_LOCAL_UNIT_KEY	0x01
#define HCI_LINK_KEY_TYPE_REMOTE_UNIT_KEY	0x02
/* 0x03 - 0xFF - reserved for future use */

/* Encryption modes */
#define HCI_ENCRYPTION_MODE_NONE		0x00
#define HCI_ENCRYPTION_MODE_P2P			0x01
#define HCI_ENCRYPTION_MODE_ALL			0x02
/* 0x03 - 0xFF - reserved for future use */

/* Quality of service types */
#define HCI_SERVICE_TYPE_NO_TRAFFIC		0x00
#define HCI_SERVICE_TYPE_BEST_EFFORT		0x01
#define HCI_SERVICE_TYPE_GUARANTEED		0x02
/* 0x03 - 0xFF - reserved for future use */

/* Link policy settings */
#define HCI_LINK_POLICY_DISABLE_ALL_LM_MODES	0x0000
#define HCI_LINK_POLICY_ENABLE_ROLE_SWITCH	0x0001 /* Master/Slave switch */
#define HCI_LINK_POLICY_ENABLE_HOLD_MODE	0x0002
#define HCI_LINK_POLICY_ENABLE_SNIFF_MODE	0x0004
#define HCI_LINK_POLICY_ENABLE_PARK_MODE	0x0008
/* 0x0010 - 0x8000 - reserved for future use */

/* Event masks */
#define HCI_EVMSK_ALL				0x00000000ffffffff
#define HCI_EVMSK_NONE				0x0000000000000000
#define HCI_EVMSK_INQUIRY_COMPL			0x0000000000000001
#define HCI_EVMSK_INQUIRY_RESULT		0x0000000000000002
#define HCI_EVMSK_CON_COMPL			0x0000000000000004
#define HCI_EVMSK_CON_REQ			0x0000000000000008
#define HCI_EVMSK_DISCON_COMPL			0x0000000000000010
#define HCI_EVMSK_AUTH_COMPL			0x0000000000000020
#define HCI_EVMSK_REMOTE_NAME_REQ_COMPL		0x0000000000000040
#define HCI_EVMSK_ENCRYPTION_CHANGE		0x0000000000000080
#define HCI_EVMSK_CHANGE_CON_LINK_KEY_COMPL	0x0000000000000100
#define HCI_EVMSK_MASTER_LINK_KEY_COMPL		0x0000000000000200
#define HCI_EVMSK_READ_REMOTE_FEATURES_COMPL	0x0000000000000400
#define HCI_EVMSK_READ_REMOTE_VER_INFO_COMPL	0x0000000000000800
#define HCI_EVMSK_QOS_SETUP_COMPL		0x0000000000001000
#define HCI_EVMSK_COMMAND_COMPL			0x0000000000002000
#define HCI_EVMSK_COMMAND_STATUS		0x0000000000004000
#define HCI_EVMSK_HARDWARE_ERROR		0x0000000000008000
#define HCI_EVMSK_FLUSH_OCCUR			0x0000000000010000
#define HCI_EVMSK_ROLE_CHANGE			0x0000000000020000
#define HCI_EVMSK_NUM_COMPL_PKTS		0x0000000000040000
#define HCI_EVMSK_MODE_CHANGE			0x0000000000080000
#define HCI_EVMSK_RETURN_LINK_KEYS		0x0000000000100000
#define HCI_EVMSK_PIN_CODE_REQ			0x0000000000200000
#define HCI_EVMSK_LINK_KEY_REQ			0x0000000000400000
#define HCI_EVMSK_LINK_KEY_NOTIFICATION		0x0000000000800000
#define HCI_EVMSK_LOOPBACK_COMMAND		0x0000000001000000
#define HCI_EVMSK_DATA_BUFFER_OVERFLOW		0x0000000002000000
#define HCI_EVMSK_MAX_SLOT_CHANGE		0x0000000004000000
#define HCI_EVMSK_READ_CLOCK_OFFSET_COMLETE	0x0000000008000000
#define HCI_EVMSK_CON_PKT_TYPE_CHANGED		0x0000000010000000
#define HCI_EVMSK_QOS_VIOLATION			0x0000000020000000
#define HCI_EVMSK_PAGE_SCAN_MODE_CHANGE		0x0000000040000000
#define HCI_EVMSK_PAGE_SCAN_REP_MODE_CHANGE	0x0000000080000000
/* 0x0000000100000000 - 0x8000000000000000 - reserved for future use */

/* Filter types */
#define HCI_FILTER_TYPE_NONE			0x00
#define HCI_FILTER_TYPE_INQUIRY_RESULT		0x01
#define HCI_FILTER_TYPE_CON_SETUP		0x02
/* 0x03 - 0xFF - reserved for future use */

/* Filter condition types for HCI_FILTER_TYPE_INQUIRY_RESULT */
#define HCI_FILTER_COND_INQUIRY_NEW_UNIT	0x00
#define HCI_FILTER_COND_INQUIRY_UNIT_CLASS	0x01
#define HCI_FILTER_COND_INQUIRY_BDADDR		0x02
/* 0x03 - 0xFF - reserved for future use */

/* Filter condition types for HCI_FILTER_TYPE_CON_SETUP */
#define HCI_FILTER_COND_CON_ANY_UNIT		0x00
#define HCI_FILTER_COND_CON_UNIT_CLASS		0x01
#define HCI_FILTER_COND_CON_BDADDR		0x02
/* 0x03 - 0xFF - reserved for future use */

/* Xmit level types */
#define HCI_XMIT_LEVEL_CURRENT			0x00
#define HCI_XMIT_LEVEL_MAXIMUM			0x01
/* 0x02 - 0xFF - reserved for future use */

/* Host Controller to Host flow control */
#define HCI_HC2H_FLOW_CONTROL_NONE		0x00
#define HCI_HC2H_FLOW_CONTROL_ACL		0x01
#define HCI_HC2H_FLOW_CONTROL_SCO		0x02
#define HCI_HC2H_FLOW_CONTROL_BOTH		0x03
/* 0x04 - 0xFF - reserved future use */

/* Loopback modes */
#define HCI_LOOPBACK_NONE			0x00
#define HCI_LOOPBACK_LOCAL			0x01
#define HCI_LOOPBACK_REMOTE			0x02
/* 0x03 - 0xFF - reserved future use */

/**************************************************************************
 **************************************************************************
 **                 Link level defines, headers and types
 **************************************************************************
 **************************************************************************/

/*
 * Macro(s) to combine OpCode and extract OGF (OpCode Group Field)
 * and OCF (OpCode Command Field) from OpCode.
 */

#define HCI_OPCODE(gf,cf)		((((gf) & 0x3f) << 10) | ((cf) & 0x3ff))
#define HCI_OCF(op)			((op) & 0x3ff)
#define HCI_OGF(op)			(((op) >> 10) & 0x3f)

/*
 * Macro(s) to extract/combine connection handle, BC (Broadcast) and
 * PB (Packet boundary) flags.
 */

#define HCI_CON_HANDLE(h)		((h) & 0x0fff)
#define HCI_PB_FLAG(h)			(((h) & 0x3000) >> 12)
#define HCI_BC_FLAG(h)			(((h) & 0xc000) >> 14)
#define HCI_MK_CON_HANDLE(h, pb, bc) \
	(((h) & 0x0fff) | (((pb) & 3) << 12) | (((bc) & 3) << 14))

/* PB flag values */
					/* 00 - reserved for future use */
#define	HCI_PACKET_FRAGMENT		0x1
#define	HCI_PACKET_START		0x2
					/* 11 - reserved for future use */

/* BC flag values */
#define HCI_POINT2POINT			0x0 /* only Host controller to Host */
#define HCI_BROADCAST_ACTIVE		0x1 /* both directions */
#define HCI_BROADCAST_PICONET		0x2 /* both directions */
					/* 11 - reserved for future use */

/* HCI command packet header */
typedef struct {
	uint8_t		type;	/* MUST be 0x01 */
	uint16_t	opcode; /* OpCode */
	uint8_t		length; /* parameter(s) length in bytes */
} __packed hci_cmd_hdr_t;

#define HCI_CMD_PKT			0x01
#define HCI_CMD_PKT_SIZE		(sizeof(hci_cmd_hdr_t) + 0xff)

/* ACL data packet header */
typedef struct {
	uint8_t		type;	     /* MUST be 0x02 */
	uint16_t	con_handle;  /* connection handle + PB + BC flags */
	uint16_t	length;      /* payload length in bytes */
} __packed hci_acldata_hdr_t;

#define HCI_ACL_DATA_PKT		0x02
#define HCI_ACL_PKT_SIZE		(sizeof(hci_acldata_hdr_t) + 0xffff)

/* SCO data packet header */
typedef struct {
	uint8_t		type;	    /* MUST be 0x03 */
	uint16_t	con_handle; /* connection handle + reserved bits */
	uint8_t		length;     /* payload length in bytes */
} __packed hci_scodata_hdr_t;

#define HCI_SCO_DATA_PKT		0x03
#define HCI_SCO_PKT_SIZE		(sizeof(hci_scodata_hdr_t) + 0xff)

/* HCI event packet header */
typedef struct {
	uint8_t		type;	/* MUST be 0x04 */
	uint8_t		event;  /* event */
	uint8_t		length; /* parameter(s) length in bytes */
} __packed hci_event_hdr_t;

#define HCI_EVENT_PKT			0x04
#define HCI_EVENT_PKT_SIZE		(sizeof(hci_event_hdr_t) + 0xff)

/* HCI status return parameter */
typedef struct {
	uint8_t		status; /* 0x00 - success */
} __packed hci_status_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x01	Link control commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_LINK_CONTROL			0x01

#define HCI_OCF_INQUIRY					0x0001
#define HCI_CMD_INQUIRY					0x0401
typedef struct {
	uint8_t		lap[HCI_LAP_SIZE]; /* LAP */
	uint8_t		inquiry_length;    /* (N x 1.28) sec */
	uint8_t		num_responses;     /* Max. # of responses */
} __packed hci_inquiry_cp;
/* No return parameter(s) */

#define HCI_OCF_INQUIRY_CANCEL				0x0002
#define HCI_CMD_INQUIRY_CANCEL				0x0402
/* No command parameter(s) */
typedef hci_status_rp	hci_inquiry_cancel_rp;

#define HCI_OCF_PERIODIC_INQUIRY			0x0003
#define HCI_CMD_PERIODIC_INQUIRY			0x0403
typedef struct {
	uint16_t	max_period_length; /* Max. and min. amount of time */
	uint16_t	min_period_length; /* between consecutive inquiries */
	uint8_t		lap[HCI_LAP_SIZE]; /* LAP */
	uint8_t		inquiry_length;    /* (inquiry_length * 1.28) sec */
	uint8_t		num_responses;     /* Max. # of responses */
} __packed hci_periodic_inquiry_cp;

typedef hci_status_rp	hci_periodic_inquiry_rp;

#define HCI_OCF_EXIT_PERIODIC_INQUIRY			0x0004
#define HCI_CMD_EXIT_PERIODIC_INQUIRY			0x0404
/* No command parameter(s) */
typedef hci_status_rp	hci_exit_periodic_inquiry_rp;

#define HCI_OCF_CREATE_CON				0x0005
#define HCI_CMD_CREATE_CON				0x0405
typedef struct {
	bdaddr_t	bdaddr;             /* destination address */
	uint16_t	pkt_type;           /* packet type */
	uint8_t		page_scan_rep_mode; /* page scan repetition mode */
	uint8_t		page_scan_mode;     /* reserved - set to 0x00 */
	uint16_t	clock_offset;       /* clock offset */
	uint8_t		accept_role_switch; /* accept role switch? 0x00 == No */
} __packed hci_create_con_cp;
/* No return parameter(s) */

#define HCI_OCF_DISCONNECT				0x0006
#define HCI_CMD_DISCONNECT				0x0406
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint8_t		reason;     /* reason to disconnect */
} __packed hci_discon_cp;
/* No return parameter(s) */

/* Add SCO Connection is deprecated */
#define HCI_OCF_ADD_SCO_CON				0x0007
#define HCI_CMD_ADD_SCO_CON				0x0407
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint16_t	pkt_type;   /* packet type */
} __packed hci_add_sco_con_cp;
/* No return parameter(s) */

#define HCI_OCF_CREATE_CON_CANCEL			0x0008
#define HCI_CMD_CREATE_CON_CANCEL			0x0408
typedef struct {
	bdaddr_t	bdaddr;		/* destination address */
} __packed hci_create_con_cancel_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* destination address */
} __packed hci_create_con_cancel_rp;

#define HCI_OCF_ACCEPT_CON				0x0009
#define HCI_CMD_ACCEPT_CON				0x0409
typedef struct {
	bdaddr_t	bdaddr; /* address of unit to be connected */
	uint8_t		role;   /* connection role */
} __packed hci_accept_con_cp;
/* No return parameter(s) */

#define HCI_OCF_REJECT_CON				0x000a
#define HCI_CMD_REJECT_CON				0x040A
typedef struct {
	bdaddr_t	bdaddr; /* remote address */
	uint8_t		reason; /* reason to reject */
} __packed hci_reject_con_cp;
/* No return parameter(s) */

#define HCI_OCF_LINK_KEY_REP				0x000b
#define HCI_CMD_LINK_KEY_REP				0x040B
typedef struct {
	bdaddr_t	bdaddr;            /* remote address */
	uint8_t		key[HCI_KEY_SIZE]; /* key */
} __packed hci_link_key_rep_cp;

typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* unit address */
} __packed hci_link_key_rep_rp;

#define HCI_OCF_LINK_KEY_NEG_REP			0x000c
#define HCI_CMD_LINK_KEY_NEG_REP			0x040C
typedef struct {
	bdaddr_t	bdaddr; /* remote address */
} __packed hci_link_key_neg_rep_cp;

typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* unit address */
} __packed hci_link_key_neg_rep_rp;

#define HCI_OCF_PIN_CODE_REP				0x000d
#define HCI_CMD_PIN_CODE_REP				0x040D
typedef struct {
	bdaddr_t	bdaddr;               /* remote address */
	uint8_t		pin_size;             /* pin code length (in bytes) */
	uint8_t		pin[HCI_PIN_SIZE];    /* pin code */
} __packed hci_pin_code_rep_cp;

typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* unit address */
} __packed hci_pin_code_rep_rp;

#define HCI_OCF_PIN_CODE_NEG_REP			0x000e
#define HCI_CMD_PIN_CODE_NEG_REP			0x040E
typedef struct {
	bdaddr_t	bdaddr; /* remote address */
} __packed hci_pin_code_neg_rep_cp;

typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* unit address */
} __packed hci_pin_code_neg_rep_rp;

#define HCI_OCF_CHANGE_CON_PACKET_TYPE			0x000f
#define HCI_CMD_CHANGE_CON_PACKET_TYPE			0x040F
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint16_t	pkt_type;   /* packet type */
} __packed hci_change_con_pkt_type_cp;
/* No return parameter(s) */

#define HCI_OCF_AUTH_REQ				0x0011
#define HCI_CMD_AUTH_REQ				0x0411
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_auth_req_cp;
/* No return parameter(s) */

#define HCI_OCF_SET_CON_ENCRYPTION			0x0013
#define HCI_CMD_SET_CON_ENCRYPTION			0x0413
typedef struct {
	uint16_t	con_handle;        /* connection handle */
	uint8_t		encryption_enable; /* 0x00 - disable, 0x01 - enable */
} __packed hci_set_con_encryption_cp;
/* No return parameter(s) */

#define HCI_OCF_CHANGE_CON_LINK_KEY			0x0015
#define HCI_CMD_CHANGE_CON_LINK_KEY			0x0415
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_change_con_link_key_cp;
/* No return parameter(s) */

#define HCI_OCF_MASTER_LINK_KEY				0x0017
#define HCI_CMD_MASTER_LINK_KEY				0x0417
typedef struct {
	uint8_t		key_flag; /* key flag */
} __packed hci_master_link_key_cp;
/* No return parameter(s) */

#define HCI_OCF_REMOTE_NAME_REQ				0x0019
#define HCI_CMD_REMOTE_NAME_REQ				0x0419
typedef struct {
	bdaddr_t	bdaddr;             /* remote address */
	uint8_t		page_scan_rep_mode; /* page scan repetition mode */
	uint8_t		page_scan_mode;     /* page scan mode */
	uint16_t	clock_offset;       /* clock offset */
} __packed hci_remote_name_req_cp;
/* No return parameter(s) */

#define HCI_OCF_REMOTE_NAME_REQ_CANCEL			0x001a
#define HCI_CMD_REMOTE_NAME_REQ_CANCEL			0x041A
typedef struct {
	bdaddr_t	bdaddr;             /* remote address */
} __packed hci_remote_name_req_cancel_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;         /* remote address */
} __packed hci_remote_name_req_cancel_rp;

#define HCI_OCF_READ_REMOTE_FEATURES			0x001b
#define HCI_CMD_READ_REMOTE_FEATURES			0x041B
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_remote_features_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_REMOTE_EXTENDED_FEATURES		0x001c
#define HCI_CMD_READ_REMOTE_EXTENDED_FEATURES		0x041C
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint8_t		page;		/* page number */
} __packed hci_read_remote_extended_features_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_REMOTE_VER_INFO			0x001d
#define HCI_CMD_READ_REMOTE_VER_INFO			0x041D
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_remote_ver_info_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_CLOCK_OFFSET			0x001f
#define HCI_CMD_READ_CLOCK_OFFSET			0x041F
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_clock_offset_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_LMP_HANDLE				0x0020
#define HCI_CMD_READ_LMP_HANDLE				0x0420
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_lmp_handle_cp;

typedef struct {
	uint8_t		status;	    /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		lmp_handle; /* LMP handle */
	uint32_t	reserved;   /* reserved */
} __packed hci_read_lmp_handle_rp;

#define HCI_OCF_SETUP_SCO_CON				0x0028
#define HCI_CMD_SETUP_SCO_CON				0x0428
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint32_t	tx_bandwidth;	/* transmit bandwidth */
	uint32_t	rx_bandwidth;	/* receive bandwidth */
	uint16_t	latency;	/* maximum latency */
	uint16_t	voice;		/* voice setting */
	uint8_t		rt_effort;	/* retransmission effort */
	uint16_t	pkt_type;	/* packet types */
} __packed hci_setup_sco_con_cp;
/* No return parameter(s) */

#define HCI_OCF_ACCEPT_SCO_CON_REQ			0x0029
#define HCI_CMD_ACCEPT_SCO_CON_REQ			0x0429
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint32_t	tx_bandwidth;	/* transmit bandwidth */
	uint32_t	rx_bandwidth;	/* receive bandwidth */
	uint16_t	latency;	/* maximum latency */
	uint16_t	content;	/* voice setting */
	uint8_t		rt_effort;	/* retransmission effort */
	uint16_t	pkt_type;	/* packet types */
} __packed hci_accept_sco_con_req_cp;
/* No return parameter(s) */

#define HCI_OCF_REJECT_SCO_CON_REQ			0x002a
#define HCI_CMD_REJECT_SCO_CON_REQ			0x042a
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint8_t		reason;		/* reject error code */
} __packed hci_reject_sco_con_req_cp;
/* No return parameter(s) */

#define HCI_OCF_IO_CAPABILITY_REP			0x002b
#define HCI_CMD_IO_CAPABILITY_REP			0x042a
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint8_t		io_cap;		/* IO capability */
	uint8_t		oob_data;	/* OOB data present */
	uint8_t		auth_req;	/* auth requirements */
} __packed hci_io_capability_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_io_capability_rep_rp;

#define HCI_OCF_USER_CONFIRM_REP			0x002c
#define HCI_CMD_USER_CONFIRM_REP			0x042c
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_confirm_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_confirm_rep_rp;

#define HCI_OCF_USER_CONFIRM_NEG_REP			0x002d
#define HCI_CMD_USER_CONFIRM_NEG_REP			0x042d
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_confirm_neg_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_confirm_neg_rep_rp;

#define HCI_OCF_USER_PASSKEY_REP			0x002e
#define HCI_CMD_USER_PASSKEY_REP			0x042e
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint32_t	value;		/* 000000 - 999999 */
} __packed hci_user_passkey_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_passkey_rep_rp;

#define HCI_OCF_USER_PASSKEY_NEG_REP			0x002f
#define HCI_CMD_USER_PASSKEY_NEG_REP			0x042f
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_passkey_neg_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_passkey_neg_rep_rp;

#define HCI_OCF_OOB_DATA_REP				0x0030
#define HCI_CMD_OOB_DATA_REP				0x0430
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint8_t		c[16];		/* pairing hash */
	uint8_t		r[16];		/* pairing randomizer */
} __packed hci_user_oob_data_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_oob_data_rep_rp;

#define HCI_OCF_OOB_DATA_NEG_REP			0x0033
#define HCI_CMD_OOB_DATA_NEG_REP			0x0433
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_oob_data_neg_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_user_oob_data_neg_rep_rp;

#define HCI_OCF_IO_CAPABILITY_NEG_REP			0x0034
#define HCI_CMD_IO_CAPABILITY_NEG_REP			0x0434
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint8_t		reason;		/* error code */
} __packed hci_io_capability_neg_rep_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_io_capability_neg_rep_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x02	Link policy commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_LINK_POLICY			0x02

#define HCI_OCF_HOLD_MODE				0x0001
#define HCI_CMD_HOLD_MODE				0x0801
typedef struct {
	uint16_t	con_handle;   /* connection handle */
	uint16_t	max_interval; /* (max_interval * 0.625) msec */
	uint16_t	min_interval; /* (max_interval * 0.625) msec */
} __packed hci_hold_mode_cp;
/* No return parameter(s) */

#define HCI_OCF_SNIFF_MODE				0x0003
#define HCI_CMD_SNIFF_MODE				0x0803
typedef struct {
	uint16_t	con_handle;   /* connection handle */
	uint16_t	max_interval; /* (max_interval * 0.625) msec */
	uint16_t	min_interval; /* (max_interval * 0.625) msec */
	uint16_t	attempt;      /* (2 * attempt - 1) * 0.625 msec */
	uint16_t	timeout;      /* (2 * attempt - 1) * 0.625 msec */
} __packed hci_sniff_mode_cp;
/* No return parameter(s) */

#define HCI_OCF_EXIT_SNIFF_MODE				0x0004
#define HCI_CMD_EXIT_SNIFF_MODE				0x0804
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_exit_sniff_mode_cp;
/* No return parameter(s) */

#define HCI_OCF_PARK_MODE				0x0005
#define HCI_CMD_PARK_MODE				0x0805
typedef struct {
	uint16_t	con_handle;   /* connection handle */
	uint16_t	max_interval; /* (max_interval * 0.625) msec */
	uint16_t	min_interval; /* (max_interval * 0.625) msec */
} __packed hci_park_mode_cp;
/* No return parameter(s) */

#define HCI_OCF_EXIT_PARK_MODE				0x0006
#define HCI_CMD_EXIT_PARK_MODE				0x0806
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_exit_park_mode_cp;
/* No return parameter(s) */

#define HCI_OCF_QOS_SETUP				0x0007
#define HCI_CMD_QOS_SETUP				0x0807
typedef struct {
	uint16_t	con_handle;      /* connection handle */
	uint8_t		flags;           /* reserved for future use */
	uint8_t		service_type;    /* service type */
	uint32_t	token_rate;      /* bytes per second */
	uint32_t	peak_bandwidth;  /* bytes per second */
	uint32_t	latency;         /* microseconds */
	uint32_t	delay_variation; /* microseconds */
} __packed hci_qos_setup_cp;
/* No return parameter(s) */

#define HCI_OCF_ROLE_DISCOVERY				0x0009
#define HCI_CMD_ROLE_DISCOVERY				0x0809
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_role_discovery_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		role;       /* role for the connection handle */
} __packed hci_role_discovery_rp;

#define HCI_OCF_SWITCH_ROLE				0x000b
#define HCI_CMD_SWITCH_ROLE				0x080B
typedef struct {
	bdaddr_t	bdaddr; /* remote address */
	uint8_t		role;   /* new local role */
} __packed hci_switch_role_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_LINK_POLICY_SETTINGS		0x000c
#define HCI_CMD_READ_LINK_POLICY_SETTINGS		0x080C
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_link_policy_settings_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint16_t	settings;   /* link policy settings */
} __packed hci_read_link_policy_settings_rp;

#define HCI_OCF_WRITE_LINK_POLICY_SETTINGS		0x000d
#define HCI_CMD_WRITE_LINK_POLICY_SETTINGS		0x080D
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint16_t	settings;   /* link policy settings */
} __packed hci_write_link_policy_settings_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_write_link_policy_settings_rp;

#define HCI_OCF_READ_DEFAULT_LINK_POLICY_SETTINGS	0x000e
#define HCI_CMD_READ_DEFAULT_LINK_POLICY_SETTINGS	0x080E
/* No command parameter(s) */
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	settings;   /* link policy settings */
} __packed hci_read_default_link_policy_settings_rp;

#define HCI_OCF_WRITE_DEFAULT_LINK_POLICY_SETTINGS	0x000f
#define HCI_CMD_WRITE_DEFAULT_LINK_POLICY_SETTINGS	0x080F
typedef struct {
	uint16_t	settings;   /* link policy settings */
} __packed hci_write_default_link_policy_settings_cp;

typedef hci_status_rp	hci_write_default_link_policy_settings_rp;

#define HCI_OCF_FLOW_SPECIFICATION			0x0010
#define HCI_CMD_FLOW_SPECIFICATION			0x0810
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint8_t		flags;		/* reserved */
	uint8_t		flow_direction;
	uint8_t		service_type;
	uint32_t	token_rate;
	uint32_t	token_bucket;
	uint32_t	peak_bandwidth;
	uint32_t	latency;
} __packed hci_flow_specification_cp;
/* No return parameter(s) */

#define HCI_OCF_SNIFF_SUBRATING				0x0011
#define HCI_CMD_SNIFF_SUBRATING				0x0810
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint16_t	max_latency;
	uint16_t	max_timeout;	/* max remote timeout */
	uint16_t	min_timeout;	/* min local timeout */
} __packed hci_sniff_subrating_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
} __packed hci_sniff_subrating_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x03	Host Controller and Baseband commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_HC_BASEBAND			0x03

#define HCI_OCF_SET_EVENT_MASK				0x0001
#define HCI_CMD_SET_EVENT_MASK				0x0C01
typedef struct {
	uint8_t		event_mask[HCI_EVENT_MASK_SIZE]; /* event_mask */
} __packed hci_set_event_mask_cp;

typedef hci_status_rp	hci_set_event_mask_rp;

#define HCI_OCF_RESET					0x0003
#define HCI_CMD_RESET					0x0C03
/* No command parameter(s) */
typedef hci_status_rp	hci_reset_rp;

#define HCI_OCF_SET_EVENT_FILTER			0x0005
#define HCI_CMD_SET_EVENT_FILTER			0x0C05
typedef struct {
	uint8_t		filter_type;           /* filter type */
	uint8_t		filter_condition_type; /* filter condition type */
/* variable size condition
	uint8_t		condition[]; -- conditions */
} __packed hci_set_event_filter_cp;

typedef hci_status_rp	hci_set_event_filter_rp;

#define HCI_OCF_FLUSH					0x0008
#define HCI_CMD_FLUSH					0x0C08
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_flush_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_flush_rp;

#define HCI_OCF_READ_PIN_TYPE				0x0009
#define HCI_CMD_READ_PIN_TYPE				0x0C09
/* No command parameter(s) */
typedef struct {
	uint8_t		status;   /* 0x00 - success */
	uint8_t		pin_type; /* PIN type */
} __packed hci_read_pin_type_rp;

#define HCI_OCF_WRITE_PIN_TYPE				0x000a
#define HCI_CMD_WRITE_PIN_TYPE				0x0C0A
typedef struct {
	uint8_t		pin_type; /* PIN type */
} __packed hci_write_pin_type_cp;

typedef hci_status_rp	hci_write_pin_type_rp;

#define HCI_OCF_CREATE_NEW_UNIT_KEY			0x000b
#define HCI_CMD_CREATE_NEW_UNIT_KEY			0x0C0B
/* No command parameter(s) */
typedef hci_status_rp	hci_create_new_unit_key_rp;

#define HCI_OCF_READ_STORED_LINK_KEY			0x000d
#define HCI_CMD_READ_STORED_LINK_KEY			0x0C0D
typedef struct {
	bdaddr_t	bdaddr;   /* address */
	uint8_t		read_all; /* read all keys? 0x01 - yes */
} __packed hci_read_stored_link_key_cp;

typedef struct {
	uint8_t		status;        /* 0x00 - success */
	uint16_t	max_num_keys;  /* Max. number of keys */
	uint16_t	num_keys_read; /* Number of stored keys */
} __packed hci_read_stored_link_key_rp;

#define HCI_OCF_WRITE_STORED_LINK_KEY			0x0011
#define HCI_CMD_WRITE_STORED_LINK_KEY			0x0C11
typedef struct {
	uint8_t		num_keys_write; /* # of keys to write */
/* these are repeated "num_keys_write" times
	bdaddr_t	bdaddr;             --- remote address(es)
	uint8_t		key[HCI_KEY_SIZE];  --- key(s) */
} __packed hci_write_stored_link_key_cp;

typedef struct {
	uint8_t		status;           /* 0x00 - success */
	uint8_t		num_keys_written; /* # of keys successfully written */
} __packed hci_write_stored_link_key_rp;

#define HCI_OCF_DELETE_STORED_LINK_KEY			0x0012
#define HCI_CMD_DELETE_STORED_LINK_KEY			0x0C12
typedef struct {
	bdaddr_t	bdaddr;     /* address */
	uint8_t		delete_all; /* delete all keys? 0x01 - yes */
} __packed hci_delete_stored_link_key_cp;

typedef struct {
	uint8_t		status;           /* 0x00 - success */
	uint16_t	num_keys_deleted; /* Number of keys deleted */
} __packed hci_delete_stored_link_key_rp;

#define HCI_OCF_WRITE_LOCAL_NAME			0x0013
#define HCI_CMD_WRITE_LOCAL_NAME			0x0C13
typedef struct {
	char		name[HCI_UNIT_NAME_SIZE]; /* new unit name */
} __packed hci_write_local_name_cp;

typedef hci_status_rp	hci_write_local_name_rp;

#define HCI_OCF_READ_LOCAL_NAME				0x0014
#define HCI_CMD_READ_LOCAL_NAME				0x0C14
/* No command parameter(s) */
typedef struct {
	uint8_t		status;                   /* 0x00 - success */
	char		name[HCI_UNIT_NAME_SIZE]; /* unit name */
} __packed hci_read_local_name_rp;

#define HCI_OCF_READ_CON_ACCEPT_TIMEOUT			0x0015
#define HCI_CMD_READ_CON_ACCEPT_TIMEOUT			0x0C15
/* No command parameter(s) */
typedef struct {
	uint8_t		status;  /* 0x00 - success */
	uint16_t	timeout; /* (timeout * 0.625) msec */
} __packed hci_read_con_accept_timeout_rp;

#define HCI_OCF_WRITE_CON_ACCEPT_TIMEOUT		0x0016
#define HCI_CMD_WRITE_CON_ACCEPT_TIMEOUT		0x0C16
typedef struct {
	uint16_t	timeout; /* (timeout * 0.625) msec */
} __packed hci_write_con_accept_timeout_cp;

typedef hci_status_rp	hci_write_con_accept_timeout_rp;

#define HCI_OCF_READ_PAGE_TIMEOUT			0x0017
#define HCI_CMD_READ_PAGE_TIMEOUT			0x0C17
/* No command parameter(s) */
typedef struct {
	uint8_t		status;  /* 0x00 - success */
	uint16_t	timeout; /* (timeout * 0.625) msec */
} __packed hci_read_page_timeout_rp;

#define HCI_OCF_WRITE_PAGE_TIMEOUT			0x0018
#define HCI_CMD_WRITE_PAGE_TIMEOUT			0x0C18
typedef struct {
	uint16_t	timeout; /* (timeout * 0.625) msec */
} __packed hci_write_page_timeout_cp;

typedef hci_status_rp	hci_write_page_timeout_rp;

#define HCI_OCF_READ_SCAN_ENABLE			0x0019
#define HCI_CMD_READ_SCAN_ENABLE			0x0C19
/* No command parameter(s) */
typedef struct {
	uint8_t		status;      /* 0x00 - success */
	uint8_t		scan_enable; /* Scan enable */
} __packed hci_read_scan_enable_rp;

#define HCI_OCF_WRITE_SCAN_ENABLE			0x001a
#define HCI_CMD_WRITE_SCAN_ENABLE			0x0C1A
typedef struct {
	uint8_t		scan_enable; /* Scan enable */
} __packed hci_write_scan_enable_cp;

typedef hci_status_rp	hci_write_scan_enable_rp;

#define HCI_OCF_READ_PAGE_SCAN_ACTIVITY			0x001b
#define HCI_CMD_READ_PAGE_SCAN_ACTIVITY			0x0C1B
/* No command parameter(s) */
typedef struct {
	uint8_t		status;             /* 0x00 - success */
	uint16_t	page_scan_interval; /* interval * 0.625 msec */
	uint16_t	page_scan_window;   /* window * 0.625 msec */
} __packed hci_read_page_scan_activity_rp;

#define HCI_OCF_WRITE_PAGE_SCAN_ACTIVITY		0x001c
#define HCI_CMD_WRITE_PAGE_SCAN_ACTIVITY		0x0C1C
typedef struct {
	uint16_t	page_scan_interval; /* interval * 0.625 msec */
	uint16_t	page_scan_window;   /* window * 0.625 msec */
} __packed hci_write_page_scan_activity_cp;

typedef hci_status_rp	hci_write_page_scan_activity_rp;

#define HCI_OCF_READ_INQUIRY_SCAN_ACTIVITY		0x001d
#define HCI_CMD_READ_INQUIRY_SCAN_ACTIVITY		0x0C1D
/* No command parameter(s) */
typedef struct {
	uint8_t		status;                /* 0x00 - success */
	uint16_t	inquiry_scan_interval; /* interval * 0.625 msec */
	uint16_t	inquiry_scan_window;   /* window * 0.625 msec */
} __packed hci_read_inquiry_scan_activity_rp;

#define HCI_OCF_WRITE_INQUIRY_SCAN_ACTIVITY		0x001e
#define HCI_CMD_WRITE_INQUIRY_SCAN_ACTIVITY		0x0C1E
typedef struct {
	uint16_t	inquiry_scan_interval; /* interval * 0.625 msec */
	uint16_t	inquiry_scan_window;   /* window * 0.625 msec */
} __packed hci_write_inquiry_scan_activity_cp;

typedef hci_status_rp	hci_write_inquiry_scan_activity_rp;

#define HCI_OCF_READ_AUTH_ENABLE			0x001f
#define HCI_CMD_READ_AUTH_ENABLE			0x0C1F
/* No command parameter(s) */
typedef struct {
	uint8_t		status;      /* 0x00 - success */
	uint8_t		auth_enable; /* 0x01 - enabled */
} __packed hci_read_auth_enable_rp;

#define HCI_OCF_WRITE_AUTH_ENABLE			0x0020
#define HCI_CMD_WRITE_AUTH_ENABLE			0x0C20
typedef struct {
	uint8_t		auth_enable; /* 0x01 - enabled */
} __packed hci_write_auth_enable_cp;

typedef hci_status_rp	hci_write_auth_enable_rp;

/* Read Encryption Mode is deprecated */
#define HCI_OCF_READ_ENCRYPTION_MODE			0x0021
#define HCI_CMD_READ_ENCRYPTION_MODE			0x0C21
/* No command parameter(s) */
typedef struct {
	uint8_t		status;          /* 0x00 - success */
	uint8_t		encryption_mode; /* encryption mode */
} __packed hci_read_encryption_mode_rp;

/* Write Encryption Mode is deprecated */
#define HCI_OCF_WRITE_ENCRYPTION_MODE			0x0022
#define HCI_CMD_WRITE_ENCRYPTION_MODE			0x0C22
typedef struct {
	uint8_t		encryption_mode; /* encryption mode */
} __packed hci_write_encryption_mode_cp;

typedef hci_status_rp	hci_write_encryption_mode_rp;

#define HCI_OCF_READ_UNIT_CLASS				0x0023
#define HCI_CMD_READ_UNIT_CLASS				0x0C23
/* No command parameter(s) */
typedef struct {
	uint8_t		status;                 /* 0x00 - success */
	uint8_t		uclass[HCI_CLASS_SIZE]; /* unit class */
} __packed hci_read_unit_class_rp;

#define HCI_OCF_WRITE_UNIT_CLASS			0x0024
#define HCI_CMD_WRITE_UNIT_CLASS			0x0C24
typedef struct {
	uint8_t		uclass[HCI_CLASS_SIZE]; /* unit class */
} __packed hci_write_unit_class_cp;

typedef hci_status_rp	hci_write_unit_class_rp;

#define HCI_OCF_READ_VOICE_SETTING			0x0025
#define HCI_CMD_READ_VOICE_SETTING			0x0C25
/* No command parameter(s) */
typedef struct {
	uint8_t		status;   /* 0x00 - success */
	uint16_t	settings; /* voice settings */
} __packed hci_read_voice_setting_rp;

#define HCI_OCF_WRITE_VOICE_SETTING			0x0026
#define HCI_CMD_WRITE_VOICE_SETTING			0x0C26
typedef struct {
	uint16_t	settings; /* voice settings */
} __packed hci_write_voice_setting_cp;

typedef hci_status_rp	hci_write_voice_setting_rp;

#define HCI_OCF_READ_AUTO_FLUSH_TIMEOUT			0x0027
#define HCI_CMD_READ_AUTO_FLUSH_TIMEOUT			0x0C27
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_auto_flush_timeout_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint16_t	timeout;    /* 0x00 - no flush, timeout * 0.625 msec */
} __packed hci_read_auto_flush_timeout_rp;

#define HCI_OCF_WRITE_AUTO_FLUSH_TIMEOUT		0x0028
#define HCI_CMD_WRITE_AUTO_FLUSH_TIMEOUT		0x0C28
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint16_t	timeout;    /* 0x00 - no flush, timeout * 0.625 msec */
} __packed hci_write_auto_flush_timeout_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_write_auto_flush_timeout_rp;

#define HCI_OCF_READ_NUM_BROADCAST_RETRANS		0x0029
#define HCI_CMD_READ_NUM_BROADCAST_RETRANS		0x0C29
/* No command parameter(s) */
typedef struct {
	uint8_t		status;  /* 0x00 - success */
	uint8_t		counter; /* number of broadcast retransmissions */
} __packed hci_read_num_broadcast_retrans_rp;

#define HCI_OCF_WRITE_NUM_BROADCAST_RETRANS		0x002a
#define HCI_CMD_WRITE_NUM_BROADCAST_RETRANS		0x0C2A
typedef struct {
	uint8_t		counter; /* number of broadcast retransmissions */
} __packed hci_write_num_broadcast_retrans_cp;

typedef hci_status_rp	hci_write_num_broadcast_retrans_rp;

#define HCI_OCF_READ_HOLD_MODE_ACTIVITY			0x002b
#define HCI_CMD_READ_HOLD_MODE_ACTIVITY			0x0C2B
/* No command parameter(s) */
typedef struct {
	uint8_t		status;             /* 0x00 - success */
	uint8_t		hold_mode_activity; /* Hold mode activities */
} __packed hci_read_hold_mode_activity_rp;

#define HCI_OCF_WRITE_HOLD_MODE_ACTIVITY		0x002c
#define HCI_CMD_WRITE_HOLD_MODE_ACTIVITY		0x0C2C
typedef struct {
	uint8_t		hold_mode_activity; /* Hold mode activities */
} __packed hci_write_hold_mode_activity_cp;

typedef hci_status_rp	hci_write_hold_mode_activity_rp;

#define HCI_OCF_READ_XMIT_LEVEL				0x002d
#define HCI_CMD_READ_XMIT_LEVEL				0x0C2D
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint8_t		type;       /* Xmit level type */
} __packed hci_read_xmit_level_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	char		level;      /* -30 <= level <= 30 dBm */
} __packed hci_read_xmit_level_rp;

#define HCI_OCF_READ_SCO_FLOW_CONTROL			0x002e
#define HCI_CMD_READ_SCO_FLOW_CONTROL			0x0C2E
/* No command parameter(s) */
typedef struct {
	uint8_t		status;       /* 0x00 - success */
	uint8_t		flow_control; /* 0x00 - disabled */
} __packed hci_read_sco_flow_control_rp;

#define HCI_OCF_WRITE_SCO_FLOW_CONTROL			0x002f
#define HCI_CMD_WRITE_SCO_FLOW_CONTROL			0x0C2F
typedef struct {
	uint8_t		flow_control; /* 0x00 - disabled */
} __packed hci_write_sco_flow_control_cp;

typedef hci_status_rp	hci_write_sco_flow_control_rp;

#define HCI_OCF_HC2H_FLOW_CONTROL			0x0031
#define HCI_CMD_HC2H_FLOW_CONTROL			0x0C31
typedef struct {
	uint8_t		hc2h_flow; /* Host Controller to Host flow control */
} __packed hci_hc2h_flow_control_cp;

typedef hci_status_rp	hci_h2hc_flow_control_rp;

#define HCI_OCF_HOST_BUFFER_SIZE			0x0033
#define HCI_CMD_HOST_BUFFER_SIZE			0x0C33
typedef struct {
	uint16_t	max_acl_size; /* Max. size of ACL packet (bytes) */
	uint8_t		max_sco_size; /* Max. size of SCO packet (bytes) */
	uint16_t	num_acl_pkts;  /* Max. number of ACL packets */
	uint16_t	num_sco_pkts;  /* Max. number of SCO packets */
} __packed hci_host_buffer_size_cp;

typedef hci_status_rp	hci_host_buffer_size_rp;

#define HCI_OCF_HOST_NUM_COMPL_PKTS			0x0035
#define HCI_CMD_HOST_NUM_COMPL_PKTS			0x0C35
typedef struct {
	uint8_t		nu_con_handles; /* # of connection handles */
/* these are repeated "num_con_handles" times
	uint16_t	con_handle;    --- connection handle(s)
	uint16_t	compl_pkts;    --- # of completed packets */
} __packed hci_host_num_compl_pkts_cp;
/* No return parameter(s) */

#define HCI_OCF_READ_LINK_SUPERVISION_TIMEOUT		0x0036
#define HCI_CMD_READ_LINK_SUPERVISION_TIMEOUT		0x0C36
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_link_supervision_timeout_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint16_t	timeout;    /* Link supervision timeout * 0.625 msec */
} __packed hci_read_link_supervision_timeout_rp;

#define HCI_OCF_WRITE_LINK_SUPERVISION_TIMEOUT		0x0037
#define HCI_CMD_WRITE_LINK_SUPERVISION_TIMEOUT		0x0C37
typedef struct {
	uint16_t	con_handle; /* connection handle */
	uint16_t	timeout;    /* Link supervision timeout * 0.625 msec */
} __packed hci_write_link_supervision_timeout_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_write_link_supervision_timeout_rp;

#define HCI_OCF_READ_NUM_SUPPORTED_IAC			0x0038
#define HCI_CMD_READ_NUM_SUPPORTED_IAC			0x0C38
/* No command parameter(s) */
typedef struct {
	uint8_t		status;  /* 0x00 - success */
	uint8_t		num_iac; /* # of supported IAC during scan */
} __packed hci_read_num_supported_iac_rp;

#define HCI_OCF_READ_IAC_LAP				0x0039
#define HCI_CMD_READ_IAC_LAP				0x0C39
/* No command parameter(s) */
typedef struct {
	uint8_t		status;  /* 0x00 - success */
	uint8_t		num_iac; /* # of IAC */
/* these are repeated "num_iac" times
	uint8_t		laps[HCI_LAP_SIZE]; --- LAPs */
} __packed hci_read_iac_lap_rp;

#define HCI_OCF_WRITE_IAC_LAP				0x003a
#define HCI_CMD_WRITE_IAC_LAP				0x0C3A
typedef struct {
	uint8_t		num_iac; /* # of IAC */
/* these are repeated "num_iac" times
	uint8_t		laps[HCI_LAP_SIZE]; --- LAPs */
} __packed hci_write_iac_lap_cp;

typedef hci_status_rp	hci_write_iac_lap_rp;

/* Read Page Scan Period Mode is deprecated */
#define HCI_OCF_READ_PAGE_SCAN_PERIOD			0x003b
#define HCI_CMD_READ_PAGE_SCAN_PERIOD			0x0C3B
/* No command parameter(s) */
typedef struct {
	uint8_t		status;                /* 0x00 - success */
	uint8_t		page_scan_period_mode; /* Page scan period mode */
} __packed hci_read_page_scan_period_rp;

/* Write Page Scan Period Mode is deprecated */
#define HCI_OCF_WRITE_PAGE_SCAN_PERIOD			0x003c
#define HCI_CMD_WRITE_PAGE_SCAN_PERIOD			0x0C3C
typedef struct {
	uint8_t		page_scan_period_mode; /* Page scan period mode */
} __packed hci_write_page_scan_period_cp;

typedef hci_status_rp	hci_write_page_scan_period_rp;

/* Read Page Scan Mode is deprecated */
#define HCI_OCF_READ_PAGE_SCAN				0x003d
#define HCI_CMD_READ_PAGE_SCAN				0x0C3D
/* No command parameter(s) */
typedef struct {
	uint8_t		status;         /* 0x00 - success */
	uint8_t		page_scan_mode; /* Page scan mode */
} __packed hci_read_page_scan_rp;

/* Write Page Scan Mode is deprecated */
#define HCI_OCF_WRITE_PAGE_SCAN				0x003e
#define HCI_CMD_WRITE_PAGE_SCAN				0x0C3E
typedef struct {
	uint8_t		page_scan_mode; /* Page scan mode */
} __packed hci_write_page_scan_cp;

typedef hci_status_rp	hci_write_page_scan_rp;

#define HCI_OCF_SET_AFH_CLASSIFICATION			0x003f
#define HCI_CMD_SET_AFH_CLASSIFICATION			0x0C3F
typedef struct {
	uint8_t		classification[10];
} __packed hci_set_afh_classification_cp;

typedef hci_status_rp	hci_set_afh_classification_rp;

#define HCI_OCF_READ_INQUIRY_SCAN_TYPE			0x0042
#define HCI_CMD_READ_INQUIRY_SCAN_TYPE			0x0C42
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		type;		/* inquiry scan type */
} __packed hci_read_inquiry_scan_type_rp;

#define HCI_OCF_WRITE_INQUIRY_SCAN_TYPE			0x0043
#define HCI_CMD_WRITE_INQUIRY_SCAN_TYPE			0x0C43
typedef struct {
	uint8_t		type;		/* inquiry scan type */
} __packed hci_write_inquiry_scan_type_cp;

typedef hci_status_rp	hci_write_inquiry_scan_type_rp;

#define HCI_OCF_READ_INQUIRY_MODE			0x0044
#define HCI_CMD_READ_INQUIRY_MODE			0x0C44
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		mode;		/* inquiry mode */
} __packed hci_read_inquiry_mode_rp;

#define HCI_OCF_WRITE_INQUIRY_MODE			0x0045
#define HCI_CMD_WRITE_INQUIRY_MODE			0x0C45
typedef struct {
	uint8_t		mode;		/* inquiry mode */
} __packed hci_write_inquiry_mode_cp;

typedef hci_status_rp	hci_write_inquiry_mode_rp;

#define HCI_OCF_READ_PAGE_SCAN_TYPE			0x0046
#define HCI_CMD_READ_PAGE_SCAN_TYPE			0x0C46
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		type;		/* page scan type */
} __packed hci_read_page_scan_type_rp;

#define HCI_OCF_WRITE_PAGE_SCAN_TYPE			0x0047
#define HCI_CMD_WRITE_PAGE_SCAN_TYPE			0x0C47
typedef struct {
	uint8_t		type;		/* page scan type */
} __packed hci_write_page_scan_type_cp;

typedef hci_status_rp	hci_write_page_scan_type_rp;

#define HCI_OCF_READ_AFH_ASSESSMENT			0x0048
#define HCI_CMD_READ_AFH_ASSESSMENT			0x0C48
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		mode;		/* assessment mode */
} __packed hci_read_afh_assessment_rp;

#define HCI_OCF_WRITE_AFH_ASSESSMENT			0x0049
#define HCI_CMD_WRITE_AFH_ASSESSMENT			0x0C49
typedef struct {
	uint8_t		mode;		/* assessment mode */
} __packed hci_write_afh_assessment_cp;

typedef hci_status_rp	hci_write_afh_assessment_rp;

#define HCI_OCF_READ_EXTENDED_INQUIRY_RSP		0x0051
#define HCI_CMD_READ_EXTENDED_INQUIRY_RSP		0x0C51
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		fec_required;
	uint8_t		response[240];
} __packed hci_read_extended_inquiry_rsp_rp;

#define HCI_OCF_WRITE_EXTENDED_INQUIRY_RSP		0x0052
#define HCI_CMD_WRITE_EXTENDED_INQUIRY_RSP		0x0C52
typedef struct {
	uint8_t		fec_required;
	uint8_t		response[240];
} __packed hci_write_extended_inquiry_rsp_cp;

typedef hci_status_rp	hci_write_extended_inquiry_rsp_rp;

#define HCI_OCF_REFRESH_ENCRYPTION_KEY			0x0053
#define HCI_CMD_REFRESH_ENCRYPTION_KEY			0x0C53
typedef struct {
	uint16_t	con_handle;	/* connection handle */
} __packed hci_refresh_encryption_key_cp;

typedef hci_status_rp	hci_refresh_encryption_key_rp;

#define HCI_OCF_READ_SIMPLE_PAIRING_MODE		0x0055
#define HCI_CMD_READ_SIMPLE_PAIRING_MODE		0x0C55
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		mode;		/* simple pairing mode */
} __packed hci_read_simple_pairing_mode_rp;

#define HCI_OCF_WRITE_SIMPLE_PAIRING_MODE		0x0056
#define HCI_CMD_WRITE_SIMPLE_PAIRING_MODE		0x0C56
typedef struct {
	uint8_t		mode;		/* simple pairing mode */
} __packed hci_write_simple_pairing_mode_cp;

typedef hci_status_rp	hci_write_simple_pairing_mode_rp;

#define HCI_OCF_READ_LOCAL_OOB_DATA			0x0057
#define HCI_CMD_READ_LOCAL_OOB_DATA			0x0C57
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		c[16];		/* pairing hash */
	uint8_t		r[16];		/* pairing randomizer */
} __packed hci_read_local_oob_data_rp;

#define HCI_OCF_READ_INQUIRY_RSP_XMIT_POWER		0x0058
#define HCI_CMD_READ_INQUIRY_RSP_XMIT_POWER		0x0C58
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	int8_t		power;		/* TX power */
} __packed hci_read_inquiry_rsp_xmit_power_rp;

#define HCI_OCF_WRITE_INQUIRY_RSP_XMIT_POWER		0x0059
#define HCI_CMD_WRITE_INQUIRY_RSP_XMIT_POWER		0x0C59
typedef struct {
	int8_t		power;		/* TX power */
} __packed hci_write_inquiry_rsp_xmit_power_cp;

typedef hci_status_rp	hci_write_inquiry_rsp_xmit_power_rp;

#define HCI_OCF_READ_DEFAULT_ERRDATA_REPORTING		0x005A
#define HCI_CMD_READ_DEFAULT_ERRDATA_REPORTING		0x0C5A
/* No command parameter(s) */

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		reporting;	/* erroneous data reporting */
} __packed hci_read_default_errdata_reporting_rp;

#define HCI_OCF_WRITE_DEFAULT_ERRDATA_REPORTING		0x005B
#define HCI_CMD_WRITE_DEFAULT_ERRDATA_REPORTING		0x0C5B
typedef struct {
	uint8_t		reporting;	/* erroneous data reporting */
} __packed hci_write_default_errdata_reporting_cp;

typedef hci_status_rp	hci_write_default_errdata_reporting_rp;

#define HCI_OCF_ENHANCED_FLUSH				0x005F
#define HCI_CMD_ENHANCED_FLUSH				0x0C5F
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint8_t		packet_type;
} __packed hci_enhanced_flush_cp;

/* No response parameter(s) */

#define HCI_OCF_SEND_KEYPRESS_NOTIFICATION		0x0060
#define HCI_CMD_SEND_KEYPRESS_NOTIFICATION		0x0C60
typedef struct {
	bdaddr_t	bdaddr;		/* remote address */
	uint8_t		type;		/* notification type */
} __packed hci_send_keypress_notification_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote address */
} __packed hci_send_keypress_notification_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x04	Informational commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_INFO				0x04

#define HCI_OCF_READ_LOCAL_VER				0x0001
#define HCI_CMD_READ_LOCAL_VER				0x1001
/* No command parameter(s) */
typedef struct {
	uint8_t		status;         /* 0x00 - success */
	uint8_t		hci_version;    /* HCI version */
	uint16_t	hci_revision;   /* HCI revision */
	uint8_t		lmp_version;    /* LMP version */
	uint16_t	manufacturer;   /* Hardware manufacturer name */
	uint16_t	lmp_subversion; /* LMP sub-version */
} __packed hci_read_local_ver_rp;

#define HCI_OCF_READ_LOCAL_COMMANDS			0x0002
#define HCI_CMD_READ_LOCAL_COMMANDS			0x1002
/* No command parameter(s) */
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		commands[HCI_COMMANDS_SIZE];	/* opcode bitmask */
} __packed hci_read_local_commands_rp;

#define HCI_OCF_READ_LOCAL_FEATURES			0x0003
#define HCI_CMD_READ_LOCAL_FEATURES			0x1003
/* No command parameter(s) */
typedef struct {
	uint8_t		status;                      /* 0x00 - success */
	uint8_t		features[HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __packed hci_read_local_features_rp;

#define HCI_OCF_READ_LOCAL_EXTENDED_FEATURES		0x0004
#define HCI_CMD_READ_LOCAL_EXTENDED_FEATURES		0x1004
typedef struct {
	uint8_t		page;		/* page number */
} __packed hci_read_local_extended_features_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint8_t		page;		/* page number */
	uint8_t		max_page;	/* maximum page number */
	uint8_t		features[HCI_FEATURES_SIZE];	/* LMP features */
} __packed hci_read_local_extended_features_rp;

#define HCI_OCF_READ_BUFFER_SIZE			0x0005
#define HCI_CMD_READ_BUFFER_SIZE			0x1005
/* No command parameter(s) */
typedef struct {
	uint8_t		status;       /* 0x00 - success */
	uint16_t	max_acl_size; /* Max. size of ACL packet (bytes) */
	uint8_t		max_sco_size; /* Max. size of SCO packet (bytes) */
	uint16_t	num_acl_pkts;  /* Max. number of ACL packets */
	uint16_t	num_sco_pkts;  /* Max. number of SCO packets */
} __packed hci_read_buffer_size_rp;

/* Read Country Code is deprecated */
#define HCI_OCF_READ_COUNTRY_CODE			0x0007
#define HCI_CMD_READ_COUNTRY_CODE			0x1007
/* No command parameter(s) */
typedef struct {
	uint8_t		status;       /* 0x00 - success */
	uint8_t		country_code; /* 0x00 - NAM, EUR, JP; 0x01 - France */
} __packed hci_read_country_code_rp;

#define HCI_OCF_READ_BDADDR				0x0009
#define HCI_CMD_READ_BDADDR				0x1009
/* No command parameter(s) */
typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* unit address */
} __packed hci_read_bdaddr_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x05	Status commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_STATUS				0x05

#define HCI_OCF_READ_FAILED_CONTACT_CNTR		0x0001
#define HCI_CMD_READ_FAILED_CONTACT_CNTR		0x1401
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_failed_contact_cntr_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint16_t	counter;    /* number of consecutive failed contacts */
} __packed hci_read_failed_contact_cntr_rp;

#define HCI_OCF_RESET_FAILED_CONTACT_CNTR		0x0002
#define HCI_CMD_RESET_FAILED_CONTACT_CNTR		0x1402
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_reset_failed_contact_cntr_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_reset_failed_contact_cntr_rp;

#define HCI_OCF_READ_LINK_QUALITY			0x0003
#define HCI_CMD_READ_LINK_QUALITY			0x1403
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_link_quality_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		quality;    /* higher value means better quality */
} __packed hci_read_link_quality_rp;

#define HCI_OCF_READ_RSSI				0x0005
#define HCI_CMD_READ_RSSI				0x1405
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_rssi_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	char		rssi;       /* -127 <= rssi <= 127 dB */
} __packed hci_read_rssi_rp;

#define HCI_OCF_READ_AFH_CHANNEL_MAP			0x0006
#define HCI_CMD_READ_AFH_CHANNEL_MAP			0x1406
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_read_afh_channel_map_cp;

typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		mode;       /* AFH mode */
	uint8_t		map[10];    /* AFH Channel Map */
} __packed hci_read_afh_channel_map_rp;

#define HCI_OCF_READ_CLOCK				0x0007
#define HCI_CMD_READ_CLOCK				0x1407
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint8_t		clock;		/* which clock */
} __packed hci_read_clock_cp;

typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	uint32_t	clock;		/* clock value */
	uint16_t	accuracy;	/* clock accuracy */
} __packed hci_read_clock_rp;


/**************************************************************************
 **************************************************************************
 ** OGF 0x06	Testing commands and return parameters
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_TESTING				0x06

#define HCI_OCF_READ_LOOPBACK_MODE			0x0001
#define HCI_CMD_READ_LOOPBACK_MODE			0x1801
/* No command parameter(s) */
typedef struct {
	uint8_t		status; /* 0x00 - success */
	uint8_t		lbmode; /* loopback mode */
} __packed hci_read_loopback_mode_rp;

#define HCI_OCF_WRITE_LOOPBACK_MODE			0x0002
#define HCI_CMD_WRITE_LOOPBACK_MODE			0x1802
typedef struct {
	uint8_t		lbmode; /* loopback mode */
} __packed hci_write_loopback_mode_cp;

typedef hci_status_rp	hci_write_loopback_mode_rp;

#define HCI_OCF_ENABLE_UNIT_UNDER_TEST			0x0003
#define HCI_CMD_ENABLE_UNIT_UNDER_TEST			0x1803
/* No command parameter(s) */
typedef hci_status_rp	hci_enable_unit_under_test_rp;

#define HCI_OCF_WRITE_SIMPLE_PAIRING_DEBUG_MODE		0x0004
#define HCI_CMD_WRITE_SIMPLE_PAIRING_DEBUG_MODE		0x1804
typedef struct {
	uint8_t		mode;	/* simple pairing debug mode */
} __packed hci_write_simple_pairing_debug_mode_cp;

typedef hci_status_rp	hci_write_simple_pairing_debug_mode_rp;

/**************************************************************************
 **************************************************************************
 ** OGF 0x3e	Bluetooth Logo Testing
 ** OGF 0x3f	Vendor Specific
 **************************************************************************
 **************************************************************************/

#define HCI_OGF_BT_LOGO				0x3e
#define HCI_OGF_VENDOR				0x3f

/* Ericsson specific FC */
#define HCI_CMD_ERICSSON_WRITE_PCM_SETTINGS		0xFC07
#define HCI_CMD_ERICSSON_SET_UART_BAUD_RATE		0xFC09
#define HCI_CMD_ERICSSON_SET_SCO_DATA_PATH		0xFC1D

/* Cambridge Silicon Radio specific FC */
#define HCI_CMD_CSR_EXTN				0xFC00


/**************************************************************************
 **************************************************************************
 **                         Events and event parameters
 **************************************************************************
 **************************************************************************/

#define HCI_EVENT_INQUIRY_COMPL			0x01
typedef struct {
	uint8_t		status; /* 0x00 - success */
} __packed hci_inquiry_compl_ep;

#define HCI_EVENT_INQUIRY_RESULT		0x02
typedef struct {
	uint8_t		num_responses;      /* number of responses */
/*	hci_inquiry_response[num_responses]   -- see below */
} __packed hci_inquiry_result_ep;

typedef struct {
	bdaddr_t	bdaddr;                   /* unit address */
	uint8_t		page_scan_rep_mode;       /* page scan rep. mode */
	uint8_t		page_scan_period_mode;    /* page scan period mode */
	uint8_t		page_scan_mode;           /* page scan mode */
	uint8_t		uclass[HCI_CLASS_SIZE];   /* unit class */
	uint16_t	clock_offset;             /* clock offset */
} __packed hci_inquiry_response;

#define HCI_EVENT_CON_COMPL			0x03
typedef struct {
	uint8_t		status;          /* 0x00 - success */
	uint16_t	con_handle;      /* Connection handle */
	bdaddr_t	bdaddr;          /* remote unit address */
	uint8_t		link_type;       /* Link type */
	uint8_t		encryption_mode; /* Encryption mode */
} __packed hci_con_compl_ep;

#define HCI_EVENT_CON_REQ			0x04
typedef struct {
	bdaddr_t	bdaddr;                 /* remote unit address */
	uint8_t		uclass[HCI_CLASS_SIZE]; /* remote unit class */
	uint8_t		link_type;              /* link type */
} __packed hci_con_req_ep;

#define HCI_EVENT_DISCON_COMPL			0x05
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		reason;     /* reason to disconnect */
} __packed hci_discon_compl_ep;

#define HCI_EVENT_AUTH_COMPL			0x06
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
} __packed hci_auth_compl_ep;

#define HCI_EVENT_REMOTE_NAME_REQ_COMPL		0x07
typedef struct {
	uint8_t		status;                   /* 0x00 - success */
	bdaddr_t	bdaddr;                   /* remote unit address */
	char		name[HCI_UNIT_NAME_SIZE]; /* remote unit name */
} __packed hci_remote_name_req_compl_ep;

#define HCI_EVENT_ENCRYPTION_CHANGE		0x08
typedef struct {
	uint8_t		status;            /* 0x00 - success */
	uint16_t	con_handle;        /* Connection handle */
	uint8_t		encryption_enable; /* 0x00 - disable */
} __packed hci_encryption_change_ep;

#define HCI_EVENT_CHANGE_CON_LINK_KEY_COMPL	0x09
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* Connection handle */
} __packed hci_change_con_link_key_compl_ep;

#define HCI_EVENT_MASTER_LINK_KEY_COMPL		0x0a
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* Connection handle */
	uint8_t		key_flag;   /* Key flag */
} __packed hci_master_link_key_compl_ep;

#define HCI_EVENT_READ_REMOTE_FEATURES_COMPL	0x0b
typedef struct {
	uint8_t		status;                      /* 0x00 - success */
	uint16_t	con_handle;                  /* Connection handle */
	uint8_t		features[HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __packed hci_read_remote_features_compl_ep;

#define HCI_EVENT_READ_REMOTE_VER_INFO_COMPL	0x0c
typedef struct {
	uint8_t		status;         /* 0x00 - success */
	uint16_t	con_handle;     /* Connection handle */
	uint8_t		lmp_version;    /* LMP version */
	uint16_t	manufacturer;   /* Hardware manufacturer name */
	uint16_t	lmp_subversion; /* LMP sub-version */
} __packed hci_read_remote_ver_info_compl_ep;

#define HCI_EVENT_QOS_SETUP_COMPL		0x0d
typedef struct {
	uint8_t		status;          /* 0x00 - success */
	uint16_t	con_handle;      /* connection handle */
	uint8_t		flags;           /* reserved for future use */
	uint8_t		service_type;    /* service type */
	uint32_t	token_rate;      /* bytes per second */
	uint32_t	peak_bandwidth;  /* bytes per second */
	uint32_t	latency;         /* microseconds */
	uint32_t	delay_variation; /* microseconds */
} __packed hci_qos_setup_compl_ep;

#define HCI_EVENT_COMMAND_COMPL			0x0e
typedef struct {
	uint8_t		num_cmd_pkts; /* # of HCI command packets */
	uint16_t	opcode;       /* command OpCode */
	/* command return parameters (if any) */
} __packed hci_command_compl_ep;

#define HCI_EVENT_COMMAND_STATUS		0x0f
typedef struct {
	uint8_t		status;       /* 0x00 - pending */
	uint8_t		num_cmd_pkts; /* # of HCI command packets */
	uint16_t	opcode;       /* command OpCode */
} __packed hci_command_status_ep;

#define HCI_EVENT_HARDWARE_ERROR		0x10
typedef struct {
	uint8_t		hardware_code; /* hardware error code */
} __packed hci_hardware_error_ep;

#define HCI_EVENT_FLUSH_OCCUR			0x11
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_flush_occur_ep;

#define HCI_EVENT_ROLE_CHANGE			0x12
typedef struct {
	uint8_t		status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* address of remote unit */
	uint8_t		role;   /* new connection role */
} __packed hci_role_change_ep;

#define HCI_EVENT_NUM_COMPL_PKTS		0x13
typedef struct {
	uint8_t		num_con_handles; /* # of connection handles */
/* these are repeated "num_con_handles" times
	uint16_t	con_handle; --- connection handle(s)
	uint16_t	compl_pkts; --- # of completed packets */
} __packed hci_num_compl_pkts_ep;

#define HCI_EVENT_MODE_CHANGE			0x14
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint8_t		unit_mode;  /* remote unit mode */
	uint16_t	interval;   /* interval * 0.625 msec */
} __packed hci_mode_change_ep;

#define HCI_EVENT_RETURN_LINK_KEYS		0x15
typedef struct {
	uint8_t		num_keys; /* # of keys */
/* these are repeated "num_keys" times
	bdaddr_t	bdaddr;               --- remote address(es)
	uint8_t		key[HCI_KEY_SIZE]; --- key(s) */
} __packed hci_return_link_keys_ep;

#define HCI_EVENT_PIN_CODE_REQ			0x16
typedef struct {
	bdaddr_t	bdaddr; /* remote unit address */
} __packed hci_pin_code_req_ep;

#define HCI_EVENT_LINK_KEY_REQ			0x17
typedef struct {
	bdaddr_t	bdaddr; /* remote unit address */
} __packed hci_link_key_req_ep;

#define HCI_EVENT_LINK_KEY_NOTIFICATION		0x18
typedef struct {
	bdaddr_t	bdaddr;            /* remote unit address */
	uint8_t		key[HCI_KEY_SIZE]; /* link key */
	uint8_t		key_type;          /* type of the key */
} __packed hci_link_key_notification_ep;

#define HCI_EVENT_LOOPBACK_COMMAND		0x19
typedef hci_cmd_hdr_t	hci_loopback_command_ep;

#define HCI_EVENT_DATA_BUFFER_OVERFLOW		0x1a
typedef struct {
	uint8_t		link_type; /* Link type */
} __packed hci_data_buffer_overflow_ep;

#define HCI_EVENT_MAX_SLOT_CHANGE		0x1b
typedef struct {
	uint16_t	con_handle;    /* connection handle */
	uint8_t		lmp_max_slots; /* Max. # of slots allowed */
} __packed hci_max_slot_change_ep;

#define HCI_EVENT_READ_CLOCK_OFFSET_COMPL	0x1c
typedef struct {
	uint8_t		status;       /* 0x00 - success */
	uint16_t	con_handle;   /* Connection handle */
	uint16_t	clock_offset; /* Clock offset */
} __packed hci_read_clock_offset_compl_ep;

#define HCI_EVENT_CON_PKT_TYPE_CHANGED		0x1d
typedef struct {
	uint8_t		status;     /* 0x00 - success */
	uint16_t	con_handle; /* connection handle */
	uint16_t	pkt_type;   /* packet type */
} __packed hci_con_pkt_type_changed_ep;

#define HCI_EVENT_QOS_VIOLATION			0x1e
typedef struct {
	uint16_t	con_handle; /* connection handle */
} __packed hci_qos_violation_ep;

/* Page Scan Mode Change Event is deprecated */
#define HCI_EVENT_PAGE_SCAN_MODE_CHANGE		0x1f
typedef struct {
	bdaddr_t	bdaddr;         /* destination address */
	uint8_t		page_scan_mode; /* page scan mode */
} __packed hci_page_scan_mode_change_ep;

#define HCI_EVENT_PAGE_SCAN_REP_MODE_CHANGE	0x20
typedef struct {
	bdaddr_t	bdaddr;             /* destination address */
	uint8_t		page_scan_rep_mode; /* page scan repetition mode */
} __packed hci_page_scan_rep_mode_change_ep;

#define HCI_EVENT_FLOW_SPECIFICATION_COMPL	0x21
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	uint8_t		flags;		/* reserved */
	uint8_t		direction;	/* flow direction */
	uint8_t		type;		/* service type */
	uint32_t	token_rate;	/* token rate */
	uint32_t	bucket_size;	/* token bucket size */
	uint32_t	peak_bandwidth;	/* peak bandwidth */
	uint32_t	latency;	/* access latency */
} __packed hci_flow_specification_compl_ep;

#define HCI_EVENT_RSSI_RESULT			0x22
typedef struct {
	uint8_t		num_responses;      /* number of responses */
/*	hci_rssi_response[num_responses]   -- see below */
} __packed hci_rssi_result_ep;

typedef struct {
	bdaddr_t	bdaddr;			/* unit address */
	uint8_t		page_scan_rep_mode;	/* page scan rep. mode */
	uint8_t		blank;			/* reserved */
	uint8_t		uclass[HCI_CLASS_SIZE];	/* unit class */
	uint16_t	clock_offset;		/* clock offset */
	int8_t		rssi;			/* rssi */
} __packed hci_rssi_response;

#define HCI_EVENT_READ_REMOTE_EXTENDED_FEATURES	0x23
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	uint8_t		page;		/* page number */
	uint8_t		max;		/* max page number */
	uint8_t		features[HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __packed hci_read_remote_extended_features_ep;

#define HCI_EVENT_SCO_CON_COMPL			0x2c
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	bdaddr_t	bdaddr;		/* unit address */
	uint8_t		link_type;	/* link type */
	uint8_t		interval;	/* transmission interval */
	uint8_t		window;		/* retransmission window */
	uint16_t	rxlen;		/* rx packet length */
	uint16_t	txlen;		/* tx packet length */
	uint8_t		mode;		/* air mode */
} __packed hci_sco_con_compl_ep;

#define HCI_EVENT_SCO_CON_CHANGED		0x2d
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	uint8_t		interval;	/* transmission interval */
	uint8_t		window;		/* retransmission window */
	uint16_t	rxlen;		/* rx packet length */
	uint16_t	txlen;		/* tx packet length */
} __packed hci_sco_con_changed_ep;

#define HCI_EVENT_SNIFF_SUBRATING		0x2e
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
	uint16_t	tx_latency;	/* max transmit latency */
	uint16_t	rx_latency;	/* max receive latency */
	uint16_t	remote_timeout;	/* remote timeout */
	uint16_t	local_timeout;	/* local timeout */
} __packed hci_sniff_subrating_ep;

#define HCI_EVENT_EXTENDED_RESULT		0x2f
typedef struct {
	uint8_t		num_responses;	/* must be 0x01 */
	bdaddr_t	bdaddr;		/* remote device address */
	uint8_t		page_scan_rep_mode;
	uint8_t		reserved;
	uint8_t		uclass[HCI_CLASS_SIZE];
	uint16_t	clock_offset;
	int8_t		rssi;
	uint8_t		response[240];	/* extended inquiry response */
} __packed hci_extended_result_ep;

#define HCI_EVENT_ENCRYPTION_KEY_REFRESH	0x30
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	uint16_t	con_handle;	/* connection handle */
} __packed hci_encryption_key_refresh_ep;

#define HCI_EVENT_IO_CAPABILITY_REQ		0x31
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
} __packed hci_io_capability_req_ep;

#define HCI_EVENT_IO_CAPABILITY_RSP		0x32
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
	uint8_t		io_capability;
	uint8_t		oob_data_present;
	uint8_t		auth_requirement;
} __packed hci_io_capability_rsp_ep;

#define HCI_EVENT_USER_CONFIRM_REQ		0x33
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
	uint32_t	value;		/* 000000 - 999999 */
} __packed hci_user_confirm_req_ep;

#define HCI_EVENT_USER_PASSKEY_REQ		0x34
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
} __packed hci_user_passkey_req_ep;

#define HCI_EVENT_REMOTE_OOB_DATA_REQ		0x35
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
} __packed hci_remote_oob_data_req_ep;

#define HCI_EVENT_SIMPLE_PAIRING_COMPL		0x36
typedef struct {
	uint8_t		status;		/* 0x00 - success */
	bdaddr_t	bdaddr;		/* remote device address */
} __packed hci_simple_pairing_compl_ep;

#define HCI_EVENT_LINK_SUPERVISION_TO_CHANGED	0x38
typedef struct {
	uint16_t	con_handle;	/* connection handle */
	uint16_t	timeout;	/* link supervision timeout */
} __packed hci_link_supervision_to_changed_ep;

#define HCI_EVENT_ENHANCED_FLUSH_COMPL		0x39
typedef struct {
	uint16_t	con_handle;	/* connection handle */
} __packed hci_enhanced_flush_compl_ep;

#define HCI_EVENT_USER_PASSKEY_NOTIFICATION	0x3b
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
	uint32_t	value;		/* 000000 - 999999 */
} __packed hci_user_passkey_notification_ep;

#define HCI_EVENT_KEYPRESS_NOTIFICATION		0x3c
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
	uint8_t		notification_type;
} __packed hci_keypress_notification_ep;

#define HCI_EVENT_REMOTE_FEATURES_NOTIFICATION	0x3d
typedef struct {
	bdaddr_t	bdaddr;		/* remote device address */
	uint8_t		features[HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __packed hci_remote_features_notification_ep;

#define HCI_EVENT_BT_LOGO			0xfe

#define HCI_EVENT_VENDOR			0xff

/**************************************************************************
 **************************************************************************
 **                 HCI Socket Definitions
 **************************************************************************
 **************************************************************************/

/* HCI socket options */
#define SO_HCI_EVT_FILTER		1	/* get/set event filter */
#define SO_HCI_PKT_FILTER		2	/* get/set packet filter */
#define SO_HCI_DIRECTION		3	/* packet direction indicator */

/* Control Messages */
#define SCM_HCI_DIRECTION		SO_HCI_DIRECTION

/*
 * HCI socket filter and get/set routines
 *
 * for ease of use, we filter 256 possible events/packets
 */
struct hci_filter {
	uint32_t	mask[8];	/* 256 bits */
};

static __inline void
hci_filter_set(uint8_t bit, struct hci_filter *filter)
{
	uint8_t off = bit - 1;

	off >>= 5;
	filter->mask[off] |= (1 << ((bit - 1) & 0x1f));
}

static __inline void
hci_filter_clr(uint8_t bit, struct hci_filter *filter)
{
	uint8_t off = bit - 1;

	off >>= 5;
	filter->mask[off] &= ~(1 << ((bit - 1) & 0x1f));
}

static __inline int
hci_filter_test(uint8_t bit, struct hci_filter *filter)
{
	uint8_t off = bit - 1;

	off >>= 5;
	return (filter->mask[off] & (1 << ((bit - 1) & 0x1f)));
}

/*
 * HCI socket ioctl's
 *
 * Apart from GBTINFOA, these are all indexed on the unit name
 */

#define SIOCGBTINFO	_IOWR('b',  5, struct btreq) /* get unit info */
#define SIOCGBTINFOA	_IOWR('b',  6, struct btreq) /* get info by address */
#define SIOCNBTINFO	_IOWR('b',  7, struct btreq) /* next unit info */

#define SIOCSBTFLAGS	_IOWR('b',  8, struct btreq) /* set unit flags */
#define SIOCSBTPOLICY	_IOWR('b',  9, struct btreq) /* set unit link policy */
#define SIOCSBTPTYPE	_IOWR('b', 10, struct btreq) /* set unit packet type */

#define SIOCGBTSTATS	_IOWR('b', 11, struct btreq) /* get unit statistics */
#define SIOCZBTSTATS	_IOWR('b', 12, struct btreq) /* zero unit statistics */

#define SIOCBTDUMP	 _IOW('b', 13, struct btreq) /* print debug info */
#define SIOCSBTSCOMTU	_IOWR('b', 17, struct btreq) /* set sco_mtu value */

struct bt_stats {
	uint32_t	err_tx;
	uint32_t	err_rx;
	uint32_t	cmd_tx;
	uint32_t	evt_rx;
	uint32_t	acl_tx;
	uint32_t	acl_rx;
	uint32_t	sco_tx;
	uint32_t	sco_rx;
	uint32_t	byte_tx;
	uint32_t	byte_rx;
};

struct btreq {
	char	btr_name[HCI_DEVNAME_SIZE];	/* device name */

	union {
	    struct {
		bdaddr_t btri_bdaddr;		/* device bdaddr */
		uint16_t btri_flags;		/* flags */
		uint16_t btri_num_cmd;		/* # of free cmd buffers */
		uint16_t btri_num_acl;		/* # of free ACL buffers */
		uint16_t btri_num_sco;		/* # of free SCO buffers */
		uint16_t btri_acl_mtu;		/* ACL mtu */
		uint16_t btri_sco_mtu;		/* SCO mtu */
		uint16_t btri_link_policy;	/* Link Policy */
		uint16_t btri_packet_type;	/* Packet Type */
	    } btri;
	    struct bt_stats btrs;   /* unit stats */
	} btru;
};

#define btr_flags	btru.btri.btri_flags
#define btr_bdaddr	btru.btri.btri_bdaddr
#define btr_num_cmd	btru.btri.btri_num_cmd
#define btr_num_acl	btru.btri.btri_num_acl
#define btr_num_sco	btru.btri.btri_num_sco
#define btr_acl_mtu	btru.btri.btri_acl_mtu
#define btr_sco_mtu	btru.btri.btri_sco_mtu
#define btr_link_policy btru.btri.btri_link_policy
#define btr_packet_type btru.btri.btri_packet_type
#define btr_stats	btru.btrs

/* hci_unit & btr_flags */
#define BTF_UP			(1<<0)	/* unit is up */
#define BTF_RUNNING		(1<<1)	/* unit is running */
#define BTF_XMIT_CMD		(1<<2)	/* unit is transmitting CMD packets */
#define BTF_XMIT_ACL		(1<<3)	/* unit is transmitting ACL packets */
#define BTF_XMIT_SCO		(1<<4)	/* unit is transmitting SCO packets */
#define BTF_XMIT		(BTF_XMIT_CMD | BTF_XMIT_ACL | BTF_XMIT_SCO)
#define BTF_INIT_BDADDR		(1<<5)	/* waiting for bdaddr */
#define BTF_INIT_BUFFER_SIZE	(1<<6)	/* waiting for buffer size */
#define BTF_INIT_FEATURES	(1<<7)	/* waiting for features */
#define BTF_POWER_UP_NOOP	(1<<8)	/* should wait for No-op on power up */
#define BTF_INIT_COMMANDS	(1<<9)	/* waiting for supported commands */

#define BTF_INIT		(BTF_INIT_BDADDR	\
				| BTF_INIT_BUFFER_SIZE	\
				| BTF_INIT_FEATURES	\
				| BTF_INIT_COMMANDS)

/**************************************************************************
 **************************************************************************
 **                 HCI Kernel Definitions
 **************************************************************************
 **************************************************************************/

#ifdef _KERNEL

#include <sys/device.h>
#include <net/if.h>		/* for struct ifqueue */

struct l2cap_channel;
struct mbuf;
struct sco_pcb;
struct socket;

/* global HCI kernel variables */

/* sysctl variables */
extern int hci_memo_expiry;
extern int hci_acl_expiry;
extern int hci_sendspace, hci_recvspace;
extern int hci_eventq_max, hci_aclrxq_max, hci_scorxq_max;

/*
 * HCI Connection Information
 */
struct hci_link {
	struct hci_unit		*hl_unit;	/* our unit */
	TAILQ_ENTRY(hci_link)	 hl_next;	/* next link on unit */

	/* common info */
	uint16_t		 hl_state;	/* connection state */
	uint16_t		 hl_flags;	/* link flags */
	bdaddr_t		 hl_bdaddr;	/* dest address */
	uint16_t		 hl_handle;	/* connection handle */
	uint8_t			 hl_type;	/* link type */

	/* ACL link info */
	uint8_t			 hl_lastid;	/* last id used */
	uint16_t		 hl_refcnt;	/* reference count */
	uint16_t		 hl_mtu;	/* signalling mtu for link */
	uint16_t		 hl_flush;	/* flush timeout */
	uint16_t		 hl_clock;	/* remote clock offset */

	TAILQ_HEAD(,l2cap_pdu)	 hl_txq;	/* queue of outgoing PDUs */
	int			 hl_txqlen;	/* number of fragments */
	struct mbuf		*hl_rxp;	/* incoming PDU (accumulating)*/
	struct timeout		 hl_expire;	/* connection expiry timer */
	TAILQ_HEAD(,l2cap_req)	 hl_reqs;	/* pending requests */

	/* SCO link info */
	struct hci_link		*hl_link;	/* SCO ACL link */
	struct sco_pcb		*hl_sco;	/* SCO pcb */
	struct ifqueue		 hl_data;	/* SCO outgoing data */
};

/* hci_link state */
#define HCI_LINK_CLOSED		0  /* closed */
#define HCI_LINK_WAIT_CONNECT	1  /* waiting to connect */
#define HCI_LINK_WAIT_AUTH	2  /* waiting for auth */
#define HCI_LINK_WAIT_ENCRYPT	3  /* waiting for encrypt */
#define HCI_LINK_WAIT_SECURE	4  /* waiting for secure */
#define HCI_LINK_OPEN		5  /* ready and willing */
#define HCI_LINK_BLOCK		6  /* open but blocking (see hci_acl_start) */

/* hci_link flags */
#define HCI_LINK_AUTH_REQ	(1<<0)  /* authentication requested */
#define HCI_LINK_ENCRYPT_REQ	(1<<1)  /* encryption requested */
#define HCI_LINK_SECURE_REQ	(1<<2)	/* secure link requested */
#define HCI_LINK_AUTH		(1<<3)	/* link is authenticated */
#define HCI_LINK_ENCRYPT	(1<<4)	/* link is encrypted */
#define HCI_LINK_SECURE		(1<<5)	/* link is secured */
#define HCI_LINK_CREATE_CON	(1<<6)	/* "Create Connection" pending */

/*
 * Bluetooth Memo
 *	cached device information for remote devices that this unit has seen
 */
struct hci_memo {
	struct timeval		time;		/* time of last response */
	bdaddr_t		bdaddr;
	uint8_t			page_scan_rep_mode;
	uint8_t			page_scan_mode;
	uint16_t		clock_offset;
	LIST_ENTRY(hci_memo)	next;
};

/*
 * The Bluetooth HCI interface attachment structure
 */
struct hci_if {
	int	(*enable)(struct device *);
	void	(*disable)(struct device *);
	void	(*output_cmd)(struct device *, struct mbuf *);
	void	(*output_acl)(struct device *, struct mbuf *);
	void	(*output_sco)(struct device *, struct mbuf *);
	void	(*get_stats)(struct device *, struct bt_stats *, int);
	int	ipl;		/* for locking */
};

/*
 * The Bluetooth HCI device unit structure
 */
struct hci_unit {
	struct device	*hci_dev;		/* bthci handle */
	struct device	*hci_bthub;		/* bthub(4) handle */
	const struct hci_if *hci_if;		/* bthci driver interface */

	/* device info */
	bdaddr_t	 hci_bdaddr;		/* device address */
	uint16_t	 hci_flags;		/* see BTF_ above */
	int		 hci_init;		/* sleep on this */

	uint16_t	 hci_packet_type;	/* packet types */
	uint16_t	 hci_acl_mask;		/* ACL packet capabilities */
	uint16_t	 hci_sco_mask;		/* SCO packet capabilities */

	uint16_t	 hci_link_policy;	/* link policy */
	uint16_t	 hci_lmp_mask;		/* link policy capabilities */

	uint8_t		 hci_cmds[HCI_COMMANDS_SIZE]; /* opcode bitmask */

	/* flow control */
	uint16_t	 hci_max_acl_size;	/* ACL payload mtu */
	uint16_t	 hci_num_acl_pkts;	/* free ACL packet buffers */
	uint8_t		 hci_num_cmd_pkts;	/* free CMD packet buffers */
	uint8_t		 hci_max_sco_size;	/* SCO payload mtu */
	uint16_t	 hci_num_sco_pkts;	/* free SCO packet buffers */

	TAILQ_HEAD(,hci_link)	hci_links;	/* list of ACL/SCO links */
	LIST_HEAD(,hci_memo)	hci_memos;	/* cached memo list */

	/* input queues */
#ifndef __OpenBSD__
	void			*hci_rxint;	/* receive interrupt cookie */
#endif
	struct mutex		 hci_devlock;	/* device queue lock */
	struct ifqueue		 hci_eventq;	/* Event queue */
	struct ifqueue		 hci_aclrxq;	/* ACL rx queue */
	struct ifqueue		 hci_scorxq;	/* SCO rx queue */
	uint16_t		 hci_eventqlen;	/* Event queue length */
	uint16_t		 hci_aclrxqlen;	/* ACL rx queue length */
	uint16_t		 hci_scorxqlen;	/* SCO rx queue length */

	/* output queues */
	struct ifqueue		 hci_cmdwait;	/* pending commands */
	struct ifqueue		 hci_scodone;	/* SCO done queue */

	TAILQ_ENTRY(hci_unit) hci_next;
};

extern TAILQ_HEAD(hci_unit_list, hci_unit) hci_unit_list;

/*
 * HCI layer function prototypes
 */

/* hci_event.c */
void hci_event(struct mbuf *, struct hci_unit *);

/* hci_ioctl.c */
int hci_ioctl(unsigned long, void *, struct proc *);

/* hci_link.c */
struct hci_link *hci_acl_open(struct hci_unit *, bdaddr_t *);
struct hci_link *hci_acl_newconn(struct hci_unit *, bdaddr_t *);
void hci_acl_close(struct hci_link *, int);
void hci_acl_timeout(void *);
int hci_acl_setmode(struct hci_link *);
void hci_acl_linkmode(struct hci_link *);
void hci_acl_recv(struct mbuf *, struct hci_unit *);
int hci_acl_send(struct mbuf *, struct hci_link *, struct l2cap_channel *);
void hci_acl_start(struct hci_link *);
void hci_acl_complete(struct hci_link *, int);
struct hci_link *hci_sco_newconn(struct hci_unit *, bdaddr_t *);
void hci_sco_recv(struct mbuf *, struct hci_unit *);
void hci_sco_start(struct hci_link *);
void hci_sco_complete(struct hci_link *, int);
struct hci_link *hci_link_alloc(struct hci_unit *, bdaddr_t *, uint8_t);
void hci_link_free(struct hci_link *, int);
struct hci_link *hci_link_lookup_bdaddr(struct hci_unit *, bdaddr_t *, uint8_t);
struct hci_link *hci_link_lookup_handle(struct hci_unit *, uint16_t);

/* hci_misc.c */
int hci_route_lookup(bdaddr_t *, bdaddr_t *);
struct hci_memo *hci_memo_find(struct hci_unit *, bdaddr_t *);
struct hci_memo *hci_memo_new(struct hci_unit *, bdaddr_t *);
void hci_memo_free(struct hci_memo *);

/* hci_socket.c */
void hci_drop(void *);
int hci_usrreq(struct socket *, int, struct mbuf *, struct mbuf *,
    struct mbuf *, struct proc *);
int hci_ctloutput(int, struct socket *, int, int, struct mbuf **);
void hci_mtap(struct mbuf *, struct hci_unit *);

/* hci_unit.c */
struct hci_unit *hci_attach(const struct hci_if *, struct device *, uint16_t);
void hci_detach(struct hci_unit *);
int hci_enable(struct hci_unit *);
void hci_disable(struct hci_unit *);
struct hci_unit *hci_unit_lookup(bdaddr_t *);
int hci_send_cmd(struct hci_unit *, uint16_t, void *, uint8_t);
void hci_num_cmds(struct hci_unit *, uint8_t);
int hci_input_event(struct hci_unit *, struct mbuf *);
int hci_input_acl(struct hci_unit *, struct mbuf *);
int hci_input_sco(struct hci_unit *, struct mbuf *);
int hci_complete_sco(struct hci_unit *, struct mbuf *);
void hci_output_cmd(struct hci_unit *, struct mbuf *);
void hci_output_acl(struct hci_unit *, struct mbuf *);
void hci_output_sco(struct hci_unit *, struct mbuf *);
void hci_intr(void *);

/* XXX mimic NetBSD for now, although we don't have these interfaces */
#define M_GETCTX(m, t)	((t)(m)->m_pkthdr.rcvif)
#define M_SETCTX(m, c)	((m)->m_pkthdr.rcvif = (void *)(c))
#define splraiseipl(ipl) splbio() /* XXX */
#define ENOLINK ENOENT		/* XXX */
#define EPASSTHROUGH ENOTTY	/* XXX */
#define device_xname(dv)	(dv)->dv_xname

#endif	/* _KERNEL */

#endif /* _NETBT_HCI_H_ */
@


1.13
log
@unbreak build on sgi (thanks jasper)
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.12 2008/11/22 04:42:58 uwe Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.12 2008/11/22 04:42:58 uwe Exp $
@


1.12
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.11 2008/05/27 19:41:14 thib Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.11 2008/05/27 19:41:14 thib Exp $
d2366 1
@


1.11
log
@bring netbt's usrreqs up to speed on the usrreq changes.
allows it too compile again.

pointed out by mk@@ and deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: hci.h,v 1.10 2008/02/24 21:34:48 uwe Exp $	*/
/*	$NetBSD: hci.h,v 1.22 2008/02/10 17:40:54 plunky Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.10 2008/02/24 21:34:48 uwe Exp $
d408 1
a408 1
} __attribute__ ((__packed__)) hci_cmd_hdr_t;
d418 1
a418 1
} __attribute__ ((__packed__)) hci_acldata_hdr_t;
d428 1
a428 1
} __attribute__ ((__packed__)) hci_scodata_hdr_t;
d438 1
a438 1
} __attribute__ ((__packed__)) hci_event_hdr_t;
d446 1
a446 1
} __attribute__ ((__packed__)) hci_status_rp;
d462 1
a462 1
} __attribute__ ((__packed__)) hci_inquiry_cp;
d478 1
a478 1
} __attribute__ ((__packed__)) hci_periodic_inquiry_cp;
d496 1
a496 1
} __attribute__ ((__packed__)) hci_create_con_cp;
d504 1
a504 1
} __attribute__ ((__packed__)) hci_discon_cp;
d513 1
a513 1
} __attribute__ ((__packed__)) hci_add_sco_con_cp;
d520 1
a520 1
} __attribute__ ((__packed__)) hci_create_con_cancel_cp;
d525 1
a525 1
} __attribute__ ((__packed__)) hci_create_con_cancel_rp;
d532 1
a532 1
} __attribute__ ((__packed__)) hci_accept_con_cp;
d540 1
a540 1
} __attribute__ ((__packed__)) hci_reject_con_cp;
d548 1
a548 1
} __attribute__ ((__packed__)) hci_link_key_rep_cp;
d553 1
a553 1
} __attribute__ ((__packed__)) hci_link_key_rep_rp;
d559 1
a559 1
} __attribute__ ((__packed__)) hci_link_key_neg_rep_cp;
d564 1
a564 1
} __attribute__ ((__packed__)) hci_link_key_neg_rep_rp;
d572 1
a572 1
} __attribute__ ((__packed__)) hci_pin_code_rep_cp;
d577 1
a577 1
} __attribute__ ((__packed__)) hci_pin_code_rep_rp;
d583 1
a583 1
} __attribute__ ((__packed__)) hci_pin_code_neg_rep_cp;
d588 1
a588 1
} __attribute__ ((__packed__)) hci_pin_code_neg_rep_rp;
d595 1
a595 1
} __attribute__ ((__packed__)) hci_change_con_pkt_type_cp;
d602 1
a602 1
} __attribute__ ((__packed__)) hci_auth_req_cp;
d610 1
a610 1
} __attribute__ ((__packed__)) hci_set_con_encryption_cp;
d617 1
a617 1
} __attribute__ ((__packed__)) hci_change_con_link_key_cp;
d624 1
a624 1
} __attribute__ ((__packed__)) hci_master_link_key_cp;
d634 1
a634 1
} __attribute__ ((__packed__)) hci_remote_name_req_cp;
d641 1
a641 1
} __attribute__ ((__packed__)) hci_remote_name_req_cancel_cp;
d646 1
a646 1
} __attribute__ ((__packed__)) hci_remote_name_req_cancel_rp;
d652 1
a652 1
} __attribute__ ((__packed__)) hci_read_remote_features_cp;
d660 1
a660 1
} __attribute__ ((__packed__)) hci_read_remote_extended_features_cp;
d667 1
a667 1
} __attribute__ ((__packed__)) hci_read_remote_ver_info_cp;
d674 1
a674 1
} __attribute__ ((__packed__)) hci_read_clock_offset_cp;
d681 1
a681 1
} __attribute__ ((__packed__)) hci_read_lmp_handle_cp;
d688 1
a688 1
} __attribute__ ((__packed__)) hci_read_lmp_handle_rp;
d700 1
a700 1
} __attribute__ ((__packed__)) hci_setup_sco_con_cp;
d713 1
a713 1
} __attribute__ ((__packed__)) hci_accept_sco_con_req_cp;
d721 1
a721 1
} __attribute__ ((__packed__)) hci_reject_sco_con_req_cp;
d731 1
a731 1
} __attribute__ ((__packed__)) hci_io_capability_rep_cp;
d736 1
a736 1
} __attribute__ ((__packed__)) hci_io_capability_rep_rp;
d742 1
a742 1
} __attribute__ ((__packed__)) hci_user_confirm_rep_cp;
d747 1
a747 1
} __attribute__ ((__packed__)) hci_user_confirm_rep_rp;
d753 1
a753 1
} __attribute__ ((__packed__)) hci_user_confirm_neg_rep_cp;
d758 1
a758 1
} __attribute__ ((__packed__)) hci_user_confirm_neg_rep_rp;
d765 1
a765 1
} __attribute__ ((__packed__)) hci_user_passkey_rep_cp;
d770 1
a770 1
} __attribute__ ((__packed__)) hci_user_passkey_rep_rp;
d776 1
a776 1
} __attribute__ ((__packed__)) hci_user_passkey_neg_rep_cp;
d781 1
a781 1
} __attribute__ ((__packed__)) hci_user_passkey_neg_rep_rp;
d789 1
a789 1
} __attribute__ ((__packed__)) hci_user_oob_data_rep_cp;
d794 1
a794 1
} __attribute__ ((__packed__)) hci_user_oob_data_rep_rp;
d800 1
a800 1
} __attribute__ ((__packed__)) hci_user_oob_data_neg_rep_cp;
d805 1
a805 1
} __attribute__ ((__packed__)) hci_user_oob_data_neg_rep_rp;
d812 1
a812 1
} __attribute__ ((__packed__)) hci_io_capability_neg_rep_cp;
d817 1
a817 1
} __attribute__ ((__packed__)) hci_io_capability_neg_rep_rp;
d833 1
a833 1
} __attribute__ ((__packed__)) hci_hold_mode_cp;
d844 1
a844 1
} __attribute__ ((__packed__)) hci_sniff_mode_cp;
d851 1
a851 1
} __attribute__ ((__packed__)) hci_exit_sniff_mode_cp;
d860 1
a860 1
} __attribute__ ((__packed__)) hci_park_mode_cp;
d867 1
a867 1
} __attribute__ ((__packed__)) hci_exit_park_mode_cp;
d880 1
a880 1
} __attribute__ ((__packed__)) hci_qos_setup_cp;
d887 1
a887 1
} __attribute__ ((__packed__)) hci_role_discovery_cp;
d893 1
a893 1
} __attribute__ ((__packed__)) hci_role_discovery_rp;
d900 1
a900 1
} __attribute__ ((__packed__)) hci_switch_role_cp;
d907 1
a907 1
} __attribute__ ((__packed__)) hci_read_link_policy_settings_cp;
d913 1
a913 1
} __attribute__ ((__packed__)) hci_read_link_policy_settings_rp;
d920 1
a920 1
} __attribute__ ((__packed__)) hci_write_link_policy_settings_cp;
d925 1
a925 1
} __attribute__ ((__packed__)) hci_write_link_policy_settings_rp;
d933 1
a933 1
} __attribute__ ((__packed__)) hci_read_default_link_policy_settings_rp;
d939 1
a939 1
} __attribute__ ((__packed__)) hci_write_default_link_policy_settings_cp;
d954 1
a954 1
} __attribute__ ((__packed__)) hci_flow_specification_cp;
d964 1
a964 1
} __attribute__ ((__packed__)) hci_sniff_subrating_cp;
d969 1
a969 1
} __attribute__ ((__packed__)) hci_sniff_subrating_rp;
d983 1
a983 1
} __attribute__ ((__packed__)) hci_set_event_mask_cp;
d999 1
a999 1
} __attribute__ ((__packed__)) hci_set_event_filter_cp;
d1007 1
a1007 1
} __attribute__ ((__packed__)) hci_flush_cp;
d1012 1
a1012 1
} __attribute__ ((__packed__)) hci_flush_rp;
d1020 1
a1020 1
} __attribute__ ((__packed__)) hci_read_pin_type_rp;
d1026 1
a1026 1
} __attribute__ ((__packed__)) hci_write_pin_type_cp;
d1040 1
a1040 1
} __attribute__ ((__packed__)) hci_read_stored_link_key_cp;
d1046 1
a1046 1
} __attribute__ ((__packed__)) hci_read_stored_link_key_rp;
d1055 1
a1055 1
} __attribute__ ((__packed__)) hci_write_stored_link_key_cp;
d1060 1
a1060 1
} __attribute__ ((__packed__)) hci_write_stored_link_key_rp;
d1067 1
a1067 1
} __attribute__ ((__packed__)) hci_delete_stored_link_key_cp;
d1072 1
a1072 1
} __attribute__ ((__packed__)) hci_delete_stored_link_key_rp;
d1078 1
a1078 1
} __attribute__ ((__packed__)) hci_write_local_name_cp;
d1088 1
a1088 1
} __attribute__ ((__packed__)) hci_read_local_name_rp;
d1096 1
a1096 1
} __attribute__ ((__packed__)) hci_read_con_accept_timeout_rp;
d1102 1
a1102 1
} __attribute__ ((__packed__)) hci_write_con_accept_timeout_cp;
d1112 1
a1112 1
} __attribute__ ((__packed__)) hci_read_page_timeout_rp;
d1118 1
a1118 1
} __attribute__ ((__packed__)) hci_write_page_timeout_cp;
d1128 1
a1128 1
} __attribute__ ((__packed__)) hci_read_scan_enable_rp;
d1134 1
a1134 1
} __attribute__ ((__packed__)) hci_write_scan_enable_cp;
d1145 1
a1145 1
} __attribute__ ((__packed__)) hci_read_page_scan_activity_rp;
d1152 1
a1152 1
} __attribute__ ((__packed__)) hci_write_page_scan_activity_cp;
d1163 1
a1163 1
} __attribute__ ((__packed__)) hci_read_inquiry_scan_activity_rp;
d1170 1
a1170 1
} __attribute__ ((__packed__)) hci_write_inquiry_scan_activity_cp;
d1180 1
a1180 1
} __attribute__ ((__packed__)) hci_read_auth_enable_rp;
d1186 1
a1186 1
} __attribute__ ((__packed__)) hci_write_auth_enable_cp;
d1197 1
a1197 1
} __attribute__ ((__packed__)) hci_read_encryption_mode_rp;
d1204 1
a1204 1
} __attribute__ ((__packed__)) hci_write_encryption_mode_cp;
d1214 1
a1214 1
} __attribute__ ((__packed__)) hci_read_unit_class_rp;
d1220 1
a1220 1
} __attribute__ ((__packed__)) hci_write_unit_class_cp;
d1230 1
a1230 1
} __attribute__ ((__packed__)) hci_read_voice_setting_rp;
d1236 1
a1236 1
} __attribute__ ((__packed__)) hci_write_voice_setting_cp;
d1244 1
a1244 1
} __attribute__ ((__packed__)) hci_read_auto_flush_timeout_cp;
d1250 1
a1250 1
} __attribute__ ((__packed__)) hci_read_auto_flush_timeout_rp;
d1257 1
a1257 1
} __attribute__ ((__packed__)) hci_write_auto_flush_timeout_cp;
d1262 1
a1262 1
} __attribute__ ((__packed__)) hci_write_auto_flush_timeout_rp;
d1270 1
a1270 1
} __attribute__ ((__packed__)) hci_read_num_broadcast_retrans_rp;
d1276 1
a1276 1
} __attribute__ ((__packed__)) hci_write_num_broadcast_retrans_cp;
d1286 1
a1286 1
} __attribute__ ((__packed__)) hci_read_hold_mode_activity_rp;
d1292 1
a1292 1
} __attribute__ ((__packed__)) hci_write_hold_mode_activity_cp;
d1301 1
a1301 1
} __attribute__ ((__packed__)) hci_read_xmit_level_cp;
d1307 1
a1307 1
} __attribute__ ((__packed__)) hci_read_xmit_level_rp;
d1315 1
a1315 1
} __attribute__ ((__packed__)) hci_read_sco_flow_control_rp;
d1321 1
a1321 1
} __attribute__ ((__packed__)) hci_write_sco_flow_control_cp;
d1329 1
a1329 1
} __attribute__ ((__packed__)) hci_hc2h_flow_control_cp;
d1340 1
a1340 1
} __attribute__ ((__packed__)) hci_host_buffer_size_cp;
d1351 1
a1351 1
} __attribute__ ((__packed__)) hci_host_num_compl_pkts_cp;
d1358 1
a1358 1
} __attribute__ ((__packed__)) hci_read_link_supervision_timeout_cp;
d1364 1
a1364 1
} __attribute__ ((__packed__)) hci_read_link_supervision_timeout_rp;
d1371 1
a1371 1
} __attribute__ ((__packed__)) hci_write_link_supervision_timeout_cp;
d1376 1
a1376 1
} __attribute__ ((__packed__)) hci_write_link_supervision_timeout_rp;
d1384 1
a1384 1
} __attribute__ ((__packed__)) hci_read_num_supported_iac_rp;
d1394 1
a1394 1
} __attribute__ ((__packed__)) hci_read_iac_lap_rp;
d1402 1
a1402 1
} __attribute__ ((__packed__)) hci_write_iac_lap_cp;
d1413 1
a1413 1
} __attribute__ ((__packed__)) hci_read_page_scan_period_rp;
d1420 1
a1420 1
} __attribute__ ((__packed__)) hci_write_page_scan_period_cp;
d1431 1
a1431 1
} __attribute__ ((__packed__)) hci_read_page_scan_rp;
d1438 1
a1438 1
} __attribute__ ((__packed__)) hci_write_page_scan_cp;
d1446 1
a1446 1
} __attribute__ ((__packed__)) hci_set_afh_classification_cp;
d1457 1
a1457 1
} __attribute__ ((__packed__)) hci_read_inquiry_scan_type_rp;
d1463 1
a1463 1
} __attribute__ ((__packed__)) hci_write_inquiry_scan_type_cp;
d1474 1
a1474 1
} __attribute__ ((__packed__)) hci_read_inquiry_mode_rp;
d1480 1
a1480 1
} __attribute__ ((__packed__)) hci_write_inquiry_mode_cp;
d1491 1
a1491 1
} __attribute__ ((__packed__)) hci_read_page_scan_type_rp;
d1497 1
a1497 1
} __attribute__ ((__packed__)) hci_write_page_scan_type_cp;
d1508 1
a1508 1
} __attribute__ ((__packed__)) hci_read_afh_assessment_rp;
d1514 1
a1514 1
} __attribute__ ((__packed__)) hci_write_afh_assessment_cp;
d1526 1
a1526 1
} __attribute__ ((__packed__)) hci_read_extended_inquiry_rsp_rp;
d1533 1
a1533 1
} __attribute__ ((__packed__)) hci_write_extended_inquiry_rsp_cp;
d1541 1
a1541 1
} __attribute__ ((__packed__)) hci_refresh_encryption_key_cp;
d1552 1
a1552 1
} __attribute__ ((__packed__)) hci_read_simple_pairing_mode_rp;
d1558 1
a1558 1
} __attribute__ ((__packed__)) hci_write_simple_pairing_mode_cp;
d1570 1
a1570 1
} __attribute__ ((__packed__)) hci_read_local_oob_data_rp;
d1579 1
a1579 1
} __attribute__ ((__packed__)) hci_read_inquiry_rsp_xmit_power_rp;
d1585 1
a1585 1
} __attribute__ ((__packed__)) hci_write_inquiry_rsp_xmit_power_cp;
d1596 1
a1596 1
} __attribute__ ((__packed__)) hci_read_default_errdata_reporting_rp;
d1602 1
a1602 1
} __attribute__ ((__packed__)) hci_write_default_errdata_reporting_cp;
d1611 1
a1611 1
} __attribute__ ((__packed__)) hci_enhanced_flush_cp;
d1620 1
a1620 1
} __attribute__ ((__packed__)) hci_send_keypress_notification_cp;
d1625 1
a1625 1
} __attribute__ ((__packed__)) hci_send_keypress_notification_rp;
d1645 1
a1645 1
} __attribute__ ((__packed__)) hci_read_local_ver_rp;
d1653 1
a1653 1
} __attribute__ ((__packed__)) hci_read_local_commands_rp;
d1661 1
a1661 1
} __attribute__ ((__packed__)) hci_read_local_features_rp;
d1667 1
a1667 1
} __attribute__ ((__packed__)) hci_read_local_extended_features_cp;
d1674 1
a1674 1
} __attribute__ ((__packed__)) hci_read_local_extended_features_rp;
d1685 1
a1685 1
} __attribute__ ((__packed__)) hci_read_buffer_size_rp;
d1694 1
a1694 1
} __attribute__ ((__packed__)) hci_read_country_code_rp;
d1702 1
a1702 1
} __attribute__ ((__packed__)) hci_read_bdaddr_rp;
d1716 1
a1716 1
} __attribute__ ((__packed__)) hci_read_failed_contact_cntr_cp;
d1722 1
a1722 1
} __attribute__ ((__packed__)) hci_read_failed_contact_cntr_rp;
d1728 1
a1728 1
} __attribute__ ((__packed__)) hci_reset_failed_contact_cntr_cp;
d1733 1
a1733 1
} __attribute__ ((__packed__)) hci_reset_failed_contact_cntr_rp;
d1739 1
a1739 1
} __attribute__ ((__packed__)) hci_read_link_quality_cp;
d1745 1
a1745 1
} __attribute__ ((__packed__)) hci_read_link_quality_rp;
d1751 1
a1751 1
} __attribute__ ((__packed__)) hci_read_rssi_cp;
d1757 1
a1757 1
} __attribute__ ((__packed__)) hci_read_rssi_rp;
d1763 1
a1763 1
} __attribute__ ((__packed__)) hci_read_afh_channel_map_cp;
d1770 1
a1770 1
} __attribute__ ((__packed__)) hci_read_afh_channel_map_rp;
d1777 1
a1777 1
} __attribute__ ((__packed__)) hci_read_clock_cp;
d1784 1
a1784 1
} __attribute__ ((__packed__)) hci_read_clock_rp;
d1801 1
a1801 1
} __attribute__ ((__packed__)) hci_read_loopback_mode_rp;
d1807 1
a1807 1
} __attribute__ ((__packed__)) hci_write_loopback_mode_cp;
d1820 1
a1820 1
} __attribute__ ((__packed__)) hci_write_simple_pairing_debug_mode_cp;
d1852 1
a1852 1
} __attribute__ ((__packed__)) hci_inquiry_compl_ep;
d1858 1
a1858 1
} __attribute__ ((__packed__)) hci_inquiry_result_ep;
d1867 1
a1867 1
} __attribute__ ((__packed__)) hci_inquiry_response;
d1876 1
a1876 1
} __attribute__ ((__packed__)) hci_con_compl_ep;
d1883 1
a1883 1
} __attribute__ ((__packed__)) hci_con_req_ep;
d1890 1
a1890 1
} __attribute__ ((__packed__)) hci_discon_compl_ep;
d1896 1
a1896 1
} __attribute__ ((__packed__)) hci_auth_compl_ep;
d1903 1
a1903 1
} __attribute__ ((__packed__)) hci_remote_name_req_compl_ep;
d1910 1
a1910 1
} __attribute__ ((__packed__)) hci_encryption_change_ep;
d1916 1
a1916 1
} __attribute__ ((__packed__)) hci_change_con_link_key_compl_ep;
d1923 1
a1923 1
} __attribute__ ((__packed__)) hci_master_link_key_compl_ep;
d1930 1
a1930 1
} __attribute__ ((__packed__)) hci_read_remote_features_compl_ep;
d1939 1
a1939 1
} __attribute__ ((__packed__)) hci_read_remote_ver_info_compl_ep;
d1951 1
a1951 1
} __attribute__ ((__packed__)) hci_qos_setup_compl_ep;
d1958 1
a1958 1
} __attribute__ ((__packed__)) hci_command_compl_ep;
d1965 1
a1965 1
} __attribute__ ((__packed__)) hci_command_status_ep;
d1970 1
a1970 1
} __attribute__ ((__packed__)) hci_hardware_error_ep;
d1975 1
a1975 1
} __attribute__ ((__packed__)) hci_flush_occur_ep;
d1982 1
a1982 1
} __attribute__ ((__packed__)) hci_role_change_ep;
d1990 1
a1990 1
} __attribute__ ((__packed__)) hci_num_compl_pkts_ep;
d1998 1
a1998 1
} __attribute__ ((__packed__)) hci_mode_change_ep;
d2006 1
a2006 1
} __attribute__ ((__packed__)) hci_return_link_keys_ep;
d2011 1
a2011 1
} __attribute__ ((__packed__)) hci_pin_code_req_ep;
d2016 1
a2016 1
} __attribute__ ((__packed__)) hci_link_key_req_ep;
d2023 1
a2023 1
} __attribute__ ((__packed__)) hci_link_key_notification_ep;
d2031 1
a2031 1
} __attribute__ ((__packed__)) hci_data_buffer_overflow_ep;
d2037 1
a2037 1
} __attribute__ ((__packed__)) hci_max_slot_change_ep;
d2044 1
a2044 1
} __attribute__ ((__packed__)) hci_read_clock_offset_compl_ep;
d2051 1
a2051 1
} __attribute__ ((__packed__)) hci_con_pkt_type_changed_ep;
d2056 1
a2056 1
} __attribute__ ((__packed__)) hci_qos_violation_ep;
d2063 1
a2063 1
} __attribute__ ((__packed__)) hci_page_scan_mode_change_ep;
d2069 1
a2069 1
} __attribute__ ((__packed__)) hci_page_scan_rep_mode_change_ep;
d2082 1
a2082 1
} __attribute__ ((__packed__)) hci_flow_specification_compl_ep;
d2088 1
a2088 1
} __attribute__ ((__packed__)) hci_rssi_result_ep;
d2097 1
a2097 1
} __attribute__ ((__packed__)) hci_rssi_response;
d2106 1
a2106 1
} __attribute__ ((__packed__)) hci_read_remote_extended_features_ep;
d2119 1
a2119 1
} __attribute__ ((__packed__)) hci_sco_con_compl_ep;
d2129 1
a2129 1
} __attribute__ ((__packed__)) hci_sco_con_changed_ep;
d2139 1
a2139 1
} __attribute__ ((__packed__)) hci_sniff_subrating_ep;
d2151 1
a2151 1
} __attribute__ ((__packed__)) hci_extended_result_ep;
d2157 1
a2157 1
} __attribute__ ((__packed__)) hci_encryption_key_refresh_ep;
d2162 1
a2162 1
} __attribute__ ((__packed__)) hci_io_capability_req_ep;
d2170 1
a2170 1
} __attribute__ ((__packed__)) hci_io_capability_rsp_ep;
d2176 1
a2176 1
} __attribute__ ((__packed__)) hci_user_confirm_req_ep;
d2181 1
a2181 1
} __attribute__ ((__packed__)) hci_user_passkey_req_ep;
d2186 1
a2186 1
} __attribute__ ((__packed__)) hci_remote_oob_data_req_ep;
d2192 1
a2192 1
} __attribute__ ((__packed__)) hci_simple_pairing_compl_ep;
d2198 1
a2198 1
} __attribute__ ((__packed__)) hci_link_supervision_to_changed_ep;
d2203 1
a2203 1
} __attribute__ ((__packed__)) hci_enhanced_flush_compl_ep;
d2209 1
a2209 1
} __attribute__ ((__packed__)) hci_user_passkey_notification_ep;
d2215 1
a2215 1
} __attribute__ ((__packed__)) hci_keypress_notification_ep;
d2221 1
a2221 1
} __attribute__ ((__packed__)) hci_remote_features_notification_ep;
d2430 1
d2469 1
d2536 1
a2536 1
struct hci_link *hci_link_alloc(struct hci_unit *);
d2538 1
a2538 2
struct hci_link *hci_link_lookup_state(struct hci_unit *, uint16_t, uint16_t);
struct hci_link *hci_link_lookup_bdaddr(struct hci_unit *, bdaddr_t *, uint16_t);
d2561 1
@


1.10
log
@Sync sys/netbt with NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.9 2007/07/22 21:05:00 gwk Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.22 2008/02/10 17:40:54 plunky Exp $
d2548 2
a2549 1
int hci_usrreq(struct socket *, int, struct mbuf *, struct mbuf *, struct mbuf *);
@


1.9
log
@spacing, chop some of the more obscenely long lines.
@
text
@d1 2
a2 2
/*	$OpenBSD: hci.h,v 1.8 2007/06/24 20:55:27 uwe Exp $	*/
/*	$NetBSD: hci.h,v 1.10 2007/04/21 06:15:23 plunky Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.8 2007/06/24 20:55:27 uwe Exp $
d65 1
a65 1
 * Core Specifications (v1.1 and v2.0)
d80 2
d96 1
d103 2
a104 1
/* 0x02 - 0xFF - reserved for future use */
d154 2
a155 2
/* reserved				0x02 */
/* reserved				0x04 */
d162 8
a169 1
/* reserved					  */
d171 2
d490 2
a491 2
	bdaddr_t	bdaddr;		    /* destination address */
	uint16_t	pkt_type;	    /* packet type */
d546 1
a546 1
	bdaddr_t	bdaddr;		   /* remote address */
d569 2
a570 2
	bdaddr_t	bdaddr;		      /* remote address */
	uint8_t		pin_size;	      /* pin code length (in bytes) */
d608 1
a608 1
	uint16_t	con_handle;	   /* connection handle */
d630 1
a630 1
	bdaddr_t	bdaddr;		    /* remote address */
d640 1
a640 1
	bdaddr_t	bdaddr;		/* remote address */
d645 1
a645 1
	bdaddr_t	bdaddr;		/* remote address */
d724 95
d874 1
a874 1
	uint8_t		flags;		 /* reserved for future use */
d878 1
a878 1
	uint32_t	latency;	 /* microseconds */
d957 14
d995 1
a995 1
	uint8_t		filter_type;	       /* filter type */
d1043 1
a1043 1
	uint8_t		status;	       /* 0x00 - success */
d1058 1
a1058 1
	uint8_t		status;		  /* 0x00 - success */
d1070 1
a1070 1
	uint8_t		status;		  /* 0x00 - success */
d1086 1
a1086 1
	uint8_t		status;			  /* 0x00 - success */
d1142 1
a1142 1
	uint8_t		status;		    /* 0x00 - success */
d1160 1
a1160 1
	uint8_t		status;		       /* 0x00 - success */
d1190 1
d1195 1
a1195 1
	uint8_t		status;		 /* 0x00 - success */
d1199 1
d1212 1
a1212 1
	uint8_t		status;		/* 0x00 - success */
d1284 1
a1284 1
	uint8_t		status;		    /* 0x00 - success */
d1406 1
d1411 1
a1411 1
	uint8_t		status;		       /* 0x00 - success */
d1415 1
d1429 1
a1429 1
	uint8_t		status;		/* 0x00 - success */
d1518 109
d1639 1
a1639 1
	uint8_t		status;		/* 0x00 - success */
d1652 1
a1652 1
	uint8_t		commands[64];	/* opcode bitmask */
d1659 1
a1659 1
	uint8_t		status;			     /* 0x00 - success */
d1816 8
d1861 1
a1861 1
	bdaddr_t	bdaddr;			  /* unit address */
d1864 1
a1864 1
	uint8_t		page_scan_mode;		  /* page scan mode */
d1866 1
a1866 1
	uint16_t	clock_offset;		  /* clock offset */
d1871 1
a1871 1
	uint8_t		status;		 /* 0x00 - success */
d1873 1
a1873 1
	bdaddr_t	bdaddr;		 /* remote unit address */
d1880 1
a1880 1
	bdaddr_t	bdaddr;		/* remote unit address */
d1882 1
a1882 1
	uint8_t		link_type;	/* link type */
d1900 2
a1901 2
	uint8_t		status;			  /* 0x00 - success */
	bdaddr_t	bdaddr;			  /* remote unit address */
d1907 3
a1909 3
	uint8_t		status;			  /* 0x00 - success */
	uint16_t	con_handle;		  /* Connection handle */
	uint8_t		encryption_enable;	  /* 0x00 - disable */
d1927 2
a1928 2
	uint8_t		status;			     /* 0x00 - success */
	uint16_t	con_handle;		     /* Connection handle */
d1934 1
a1934 1
	uint8_t		status;		/* 0x00 - success */
d1943 1
a1943 1
	uint8_t		status;		 /* 0x00 - success */
d1945 1
a1945 1
	uint8_t		flags;		 /* reserved for future use */
d1949 1
a1949 1
	uint32_t	latency;	 /* microseconds */
d2020 1
a2020 1
	bdaddr_t	bdaddr;		   /* remote unit address */
d2022 1
a2022 1
	uint8_t		key_type;	   /* type of the key */
d2061 1
a2061 1
	bdaddr_t	bdaddr;		/* destination address */
d2067 1
a2067 1
	bdaddr_t	bdaddr;		    /* destination address */
d2097 1
a2097 1
} __attribute__ ((__packed__)) hci_rssi_response_ep;
d2131 92
a2337 1
#define btr_uclass	btru.btri.btri_uclass
d2350 7
a2356 1
#define BTF_INIT		(BTF_INIT_BDADDR | BTF_INIT_BUFFER_SIZE | BTF_INIT_FEATURES)
d2400 1
d2437 4
a2440 1
	hci_inquiry_response	response;	/* inquiry response */
d2445 13
d2461 1
a2461 1
	struct device	*hci_softc;		/* ptr to device softc */
d2463 1
a2465 1
	char		*hci_devname;		/* device name */
d2476 2
a2487 17
	/*
	 * h/w driver callbacks
	 *
	 * the device driver must supply these.
	 */
	int	(*hci_enable)		/* enable device */
		(struct hci_unit *);
	void	(*hci_disable)		/* disable device */
		(struct hci_unit *);
	void	(*hci_start_cmd)	/* initiate cmd output routine */
		(struct hci_unit *);
	void	(*hci_start_acl)	/* initiate acl output routine */
		(struct hci_unit *);
	void	(*hci_start_sco)	/* initiate sco output routine */
		(struct hci_unit *);
	int hci_ipl;		/* to block queue operations */

d2489 4
a2501 3
	struct ifqueue		 hci_cmdq;	/* Command queue */
	struct ifqueue		 hci_acltxq;	/* ACL tx queue */
	struct ifqueue		 hci_scotxq;	/* SCO tx queue */
a2503 2
	struct bt_stats		 hci_stats;	/* unit statistics */

d2543 1
d2553 1
a2553 1
void hci_attach(struct hci_unit *);
d2559 4
a2562 4
void hci_input_event(struct hci_unit *, struct mbuf *);
void hci_input_acl(struct hci_unit *, struct mbuf *);
void hci_input_sco(struct hci_unit *, struct mbuf *);
void hci_complete_sco(struct hci_unit *, struct mbuf *);
d2574 1
@


1.8
log
@Remove some unused leftover code; original request from jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.7 2007/06/19 08:12:34 uwe Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.7 2007/06/19 08:12:34 uwe Exp $
d477 2
a478 2
	bdaddr_t	bdaddr;             /* destination address */
	uint16_t	pkt_type;           /* packet type */
d533 1
a533 1
	bdaddr_t	bdaddr;            /* remote address */
d556 2
a557 2
	bdaddr_t	bdaddr;               /* remote address */
	uint8_t		pin_size;             /* pin code length (in bytes) */
d595 1
a595 1
	uint16_t	con_handle;        /* connection handle */
d617 1
a617 1
	bdaddr_t	bdaddr;             /* remote address */
d627 1
a627 1
	bdaddr_t	bdaddr;             /* remote address */
d632 1
a632 1
	bdaddr_t	bdaddr;         /* remote address */
d766 1
a766 1
	uint8_t		flags;           /* reserved for future use */
d770 1
a770 1
	uint32_t	latency;         /* microseconds */
d873 1
a873 1
	uint8_t		filter_type;           /* filter type */
d921 1
a921 1
	uint8_t		status;        /* 0x00 - success */
d936 1
a936 1
	uint8_t		status;           /* 0x00 - success */
d948 1
a948 1
	uint8_t		status;           /* 0x00 - success */
d964 1
a964 1
	uint8_t		status;                   /* 0x00 - success */
d1020 1
a1020 1
	uint8_t		status;             /* 0x00 - success */
d1038 1
a1038 1
	uint8_t		status;                /* 0x00 - success */
d1072 1
a1072 1
	uint8_t		status;          /* 0x00 - success */
d1088 1
a1088 1
	uint8_t		status;                 /* 0x00 - success */
d1160 1
a1160 1
	uint8_t		status;             /* 0x00 - success */
d1286 1
a1286 1
	uint8_t		status;                /* 0x00 - success */
d1303 1
a1303 1
	uint8_t		status;         /* 0x00 - success */
d1404 1
a1404 1
	uint8_t		status;         /* 0x00 - success */
d1424 1
a1424 1
	uint8_t		status;                      /* 0x00 - success */
d1618 1
a1618 1
	bdaddr_t	bdaddr;                   /* unit address */
d1621 1
a1621 1
	uint8_t		page_scan_mode;           /* page scan mode */
d1623 1
a1623 1
	uint16_t	clock_offset;             /* clock offset */
d1628 1
a1628 1
	uint8_t		status;          /* 0x00 - success */
d1630 1
a1630 1
	bdaddr_t	bdaddr;          /* remote unit address */
d1637 1
a1637 1
	bdaddr_t	bdaddr;                 /* remote unit address */
d1639 1
a1639 1
	uint8_t		link_type;              /* link type */
d1657 2
a1658 2
	uint8_t		status;                   /* 0x00 - success */
	bdaddr_t	bdaddr;                   /* remote unit address */
d1664 3
a1666 3
	uint8_t		status;            /* 0x00 - success */
	uint16_t	con_handle;        /* Connection handle */
	uint8_t		encryption_enable; /* 0x00 - disable */
d1684 2
a1685 2
	uint8_t		status;                      /* 0x00 - success */
	uint16_t	con_handle;                  /* Connection handle */
d1691 1
a1691 1
	uint8_t		status;         /* 0x00 - success */
d1700 1
a1700 1
	uint8_t		status;          /* 0x00 - success */
d1702 1
a1702 1
	uint8_t		flags;           /* reserved for future use */
d1706 1
a1706 1
	uint32_t	latency;         /* microseconds */
d1777 1
a1777 1
	bdaddr_t	bdaddr;            /* remote unit address */
d1779 1
a1779 1
	uint8_t		key_type;          /* type of the key */
d1818 1
a1818 1
	bdaddr_t	bdaddr;         /* destination address */
d1824 1
a1824 1
	bdaddr_t	bdaddr;             /* destination address */
@


1.7
log
@Abort all pending ACL connections when we get an HCI command parameter
error in response to a HCI_CMD_CREATE_CON command instead of waiting
that the user aborts due to boredom.  Unfortunately, the command status
event does not include a hint to tells us which connection failed.
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.6 2007/06/01 02:46:11 uwe Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.6 2007/06/01 02:46:11 uwe Exp $
d2224 1
@


1.6
log
@complete the sys/netbt import and adopt some more code to our interfaces
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.5 2007/05/31 23:50:19 uwe Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.5 2007/05/31 23:50:19 uwe Exp $
d2195 1
@


1.5
log
@Enable packet flow between HCI driver and controller
- not all platforms have generic sofintr support, use schednetisr()
- enable HCI driver at attach time (for development, since we have no
  userland tools yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.4 2007/05/30 03:42:53 uwe Exp $	*/
d58 1
a58 1
 * $Id: hci.h,v 1.4 2007/05/30 03:42:53 uwe Exp $
d2205 1
a2205 1
int hci_usrreq(struct socket *, int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d2223 7
@


1.4
log
@Import parts of the NetBSD bluetooth stack; ok gwk, and grange on removal
of the existing code
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
 * $Id: hci.h,v 1.10 2007/04/21 06:15:23 plunky Exp $
a2146 1
	void			*hci_rxint;	/* receive interrupt cookie */
@


1.3
log
@From FreeBSD netgraph/bluetooth/include/ng_hci.h rev. 1.5:

Rename 'class' field to 'uclass' in the ng_hci_inquiry_response structure.
class is a reserved word in C++

Submitted by:	Markus Brueffer < markus AT brueffer DOT de >
@
text
@d1 2
a2 1
/*	$OpenBSD: hci.h,v 1.2 2005/01/17 18:12:49 mickey Exp $	*/
d4 16
a19 2
/*
 * ng_hci.h
d21 13
d58 2
a59 1
 * $FreeBSD: src/sys/netgraph/bluetooth/include/ng_hci.h,v 1.4 2004/08/10 00:38:50 emax Exp $
d63 3
a65 3
 * This file contains everything that application needs to know about
 * Host Controller Interface (HCI). All information was obtained from
 * Bluetooth Specification Book v1.1.
d71 1
a71 1
 *       same thing (i think), so to be consistent word "unit" will be
d75 2
a76 2
#ifndef _NETGRAPH_HCI_H_
#define _NETGRAPH_HCI_H_
d78 1
a78 15
/**************************************************************************
 **************************************************************************
 **     Netgraph node hook name, type name and type cookie and commands
 **************************************************************************
 **************************************************************************/

/* Node type name and type cookie */
#define NG_HCI_NODE_TYPE			"hci"
#define NGM_HCI_COOKIE				1000774184

/* Netgraph node hook names */
#define NG_HCI_HOOK_DRV				"drv" /* Driver <-> HCI */
#define NG_HCI_HOOK_ACL				"acl" /* HCI <-> Upper */
#define NG_HCI_HOOK_SCO				"sco" /* HCI <-> Upper */ 
#define NG_HCI_HOOK_RAW				"raw" /* HCI <-> Upper */ 
d86 8
a93 9
/* All sizes are in bytes */
#define NG_HCI_BDADDR_SIZE			6   /* unit address */
#define NG_HCI_LAP_SIZE				3   /* unit LAP */
#define NG_HCI_KEY_SIZE				16  /* link key */
#define NG_HCI_PIN_SIZE				16  /* link PIN */
#define NG_HCI_EVENT_MASK_SIZE			8   /* event mask */
#define NG_HCI_CLASS_SIZE			3   /* unit class */
#define NG_HCI_FEATURES_SIZE			8   /* LMP features */
#define NG_HCI_UNIT_NAME_SIZE			248 /* unit name size */
d96 4
a99 2
#define NG_HCI_SPEC_V10				0x00 /* v1.0 */
#define NG_HCI_SPEC_V11				0x01 /* v1.1 */
d102 1
a102 1
/* LMP features */
d104 8
a111 8
#define NG_HCI_LMP_3SLOT			0x01
#define NG_HCI_LMP_5SLOT			0x02
#define NG_HCI_LMP_ENCRYPTION			0x04
#define NG_HCI_LMP_SLOT_OFFSET			0x08
#define NG_HCI_LMP_TIMING_ACCURACY		0x10
#define NG_HCI_LMP_SWITCH			0x20
#define NG_HCI_LMP_HOLD_MODE			0x40
#define NG_HCI_LMP_SNIFF_MODE			0x80
d113 8
a120 8
#define NG_HCI_LMP_PARK_MODE			0x01
#define NG_HCI_LMP_RSSI				0x02
#define NG_HCI_LMP_CHANNEL_QUALITY		0x04
#define NG_HCI_LMP_SCO_LINK			0x08
#define NG_HCI_LMP_HV2_PKT			0x10
#define NG_HCI_LMP_HV3_PKT			0x20
#define NG_HCI_LMP_ULAW_LOG			0x40
#define NG_HCI_LMP_ALAW_LOG			0x80
d122 39
a160 7
#define NG_HCI_LMP_CVSD				0x01
#define NG_HCI_LMP_PAGING_SCHEME		0x02
#define NG_HCI_LMP_POWER_CONTROL		0x04
#define NG_HCI_LMP_TRANSPARENT_SCO		0x08
#define NG_HCI_LMP_FLOW_CONTROL_LAG0		0x10
#define NG_HCI_LMP_FLOW_CONTROL_LAG1		0x20
#define NG_HCI_LMP_FLOW_CONTROL_LAG2		0x40
d163 4
a166 3
#define NG_HCI_LINK_SCO				0x00 /* Voice */
#define NG_HCI_LINK_ACL				0x01 /* Data */
/* 0x02 - 0xFF - reserved for future use */
d168 30
a197 13
/* Packet types */
				/* 0x0001 - 0x0004 - reserved for future use */
#define NG_HCI_PKT_DM1				0x0008 /* ACL link */
#define NG_HCI_PKT_DH1				0x0010 /* ACL link */
#define NG_HCI_PKT_HV1				0x0020 /* SCO link */
#define NG_HCI_PKT_HV2				0x0040 /* SCO link */
#define NG_HCI_PKT_HV3				0x0080 /* SCO link */
				/* 0x0100 - 0x0200 - reserved for future use */
#define NG_HCI_PKT_DM3				0x0400 /* ACL link */
#define NG_HCI_PKT_DH3				0x0800 /* ACL link */
				/* 0x1000 - 0x2000 - reserved for future use */
#define NG_HCI_PKT_DM5				0x4000 /* ACL link */
#define NG_HCI_PKT_DH5				0x8000 /* ACL link */
d199 1
a199 1
/* 
d203 2
a204 2
 * for the specific connection. For example one connection was put on 
 * hold (but i could be wrong :) 
d207 5
a211 11
#define NG_HCI_UNIT_MODE_ACTIVE			0x00
#define NG_HCI_UNIT_MODE_HOLD			0x01
#define NG_HCI_UNIT_MODE_SNIFF			0x02
#define NG_HCI_UNIT_MODE_PARK			0x03
/* 0x04 - 0xFF - reserved for future use */

/* Page scan modes */
#define NG_HCI_MANDATORY_PAGE_SCAN_MODE		0x00
#define NG_HCI_OPTIONAL_PAGE_SCAN_MODE1		0x01
#define NG_HCI_OPTIONAL_PAGE_SCAN_MODE2		0x02
#define NG_HCI_OPTIONAL_PAGE_SCAN_MODE3		0x03
d215 3
a217 3
#define NG_HCI_SCAN_REP_MODE0			0x00
#define NG_HCI_SCAN_REP_MODE1			0x01
#define NG_HCI_SCAN_REP_MODE2			0x02
d221 3
a223 3
#define NG_HCI_PAGE_SCAN_PERIOD_MODE0		0x00
#define NG_HCI_PAGE_SCAN_PERIOD_MODE1		0x01
#define NG_HCI_PAGE_SCAN_PERIOD_MODE2		0x02
d227 3
a229 4
#define NG_HCI_NO_SCAN_ENABLE			0x00
#define NG_HCI_INQUIRY_ENABLE_PAGE_DISABLE	0x01
#define NG_HCI_INQUIRY_DISABLE_PAGE_ENABLE	0x02
#define NG_HCI_INQUIRY_ENABLE_PAGE_ENABLE	0x03
d233 4
a236 4
#define NG_HCI_HOLD_MODE_NO_CHANGE		0x00
#define NG_HCI_HOLD_MODE_SUSPEND_PAGE_SCAN	0x01
#define NG_HCI_HOLD_MODE_SUSPEND_INQUIRY_SCAN	0x02
#define NG_HCI_HOLD_MODE_SUSPEND_PERIOD_INQUIRY	0x04
d240 2
a241 2
#define NG_HCI_ROLE_MASTER			0x00
#define NG_HCI_ROLE_SLAVE			0x01
d245 2
a246 2
#define NG_HCI_USE_SEMI_PERMANENT_LINK_KEYS	0x00
#define NG_HCI_USE_TEMPORARY_LINK_KEY		0x01
d250 2
a251 2
#define NG_HCI_PIN_TYPE_VARIABLE		0x00
#define NG_HCI_PIN_TYPE_FIXED			0x01
d254 3
a256 3
#define NG_HCI_LINK_KEY_TYPE_COMBINATION_KEY	0x00
#define NG_HCI_LINK_KEY_TYPE_LOCAL_UNIT_KEY	0x01
#define NG_HCI_LINK_KEY_TYPE_REMOTE_UNIT_KEY	0x02
d260 3
a262 3
#define NG_HCI_ENCRYPTION_MODE_NONE		0x00
#define NG_HCI_ENCRYPTION_MODE_P2P		0x01
#define NG_HCI_ENCRYPTION_MODE_ALL		0x02
d266 3
a268 3
#define NG_HCI_SERVICE_TYPE_NO_TRAFFIC		0x00
#define NG_HCI_SERVICE_TYPE_BEST_EFFORT		0x01
#define NG_HCI_SERVICE_TYPE_GUARANTEED		0x02
d272 5
a276 5
#define NG_HCI_LINK_POLICY_DISABLE_ALL_LM_MODES	0x0000
#define NG_HCI_LINK_POLICY_ENABLE_ROLE_SWITCH	0x0001 /* Master/Slave switch */
#define NG_HCI_LINK_POLICY_ENABLE_HOLD_MODE	0x0002
#define NG_HCI_LINK_POLICY_ENABLE_SNIFF_MODE	0x0004
#define NG_HCI_LINK_POLICY_ENABLE_PARK_MODE	0x0008
d280 34
a313 34
#define NG_HCI_EVMSK_ALL			0x00000000ffffffff
#define NG_HCI_EVMSK_NONE			0x0000000000000000
#define NG_HCI_EVMSK_INQUIRY_COMPL		0x0000000000000001
#define NG_HCI_EVMSK_INQUIRY_RESULT		0x0000000000000002
#define NG_HCI_EVMSK_CON_COMPL			0x0000000000000004
#define NG_HCI_EVMSK_CON_REQ			0x0000000000000008
#define NG_HCI_EVMSK_DISCON_COMPL		0x0000000000000010
#define NG_HCI_EVMSK_AUTH_COMPL			0x0000000000000020
#define NG_HCI_EVMSK_REMOTE_NAME_REQ_COMPL	0x0000000000000040
#define NG_HCI_EVMSK_ENCRYPTION_CHANGE		0x0000000000000080
#define NG_HCI_EVMSK_CHANGE_CON_LINK_KEY_COMPL	0x0000000000000100
#define NG_HCI_EVMSK_MASTER_LINK_KEY_COMPL	0x0000000000000200
#define NG_HCI_EVMSK_READ_REMOTE_FEATURES_COMPL	0x0000000000000400
#define NG_HCI_EVMSK_READ_REMOTE_VER_INFO_COMPL	0x0000000000000800
#define NG_HCI_EVMSK_QOS_SETUP_COMPL		0x0000000000001000
#define NG_HCI_EVMSK_COMMAND_COMPL		0x0000000000002000
#define NG_HCI_EVMSK_COMMAND_STATUS		0x0000000000004000
#define NG_HCI_EVMSK_HARDWARE_ERROR		0x0000000000008000
#define NG_HCI_EVMSK_FLUSH_OCCUR		0x0000000000010000
#define NG_HCI_EVMSK_ROLE_CHANGE		0x0000000000020000
#define NG_HCI_EVMSK_NUM_COMPL_PKTS		0x0000000000040000
#define NG_HCI_EVMSK_MODE_CHANGE		0x0000000000080000
#define NG_HCI_EVMSK_RETURN_LINK_KEYS		0x0000000000100000
#define NG_HCI_EVMSK_PIN_CODE_REQ		0x0000000000200000
#define NG_HCI_EVMSK_LINK_KEY_REQ		0x0000000000400000
#define NG_HCI_EVMSK_LINK_KEY_NOTIFICATION	0x0000000000800000
#define NG_HCI_EVMSK_LOOPBACK_COMMAND		0x0000000001000000
#define NG_HCI_EVMSK_DATA_BUFFER_OVERFLOW	0x0000000002000000
#define NG_HCI_EVMSK_MAX_SLOT_CHANGE		0x0000000004000000
#define NG_HCI_EVMSK_READ_CLOCK_OFFSET_COMLETE	0x0000000008000000
#define NG_HCI_EVMSK_CON_PKT_TYPE_CHANGED	0x0000000010000000
#define NG_HCI_EVMSK_QOS_VIOLATION		0x0000000020000000
#define NG_HCI_EVMSK_PAGE_SCAN_MODE_CHANGE	0x0000000040000000
#define NG_HCI_EVMSK_PAGE_SCAN_REP_MODE_CHANGE	0x0000000080000000
d317 3
a319 3
#define NG_HCI_FILTER_TYPE_NONE			0x00
#define NG_HCI_FILTER_TYPE_INQUIRY_RESULT	0x01
#define NG_HCI_FILTER_TYPE_CON_SETUP		0x02
d322 4
a325 4
/* Filter condition types for NG_HCI_FILTER_TYPE_INQUIRY_RESULT */
#define NG_HCI_FILTER_COND_INQUIRY_NEW_UNIT	0x00
#define NG_HCI_FILTER_COND_INQUIRY_UNIT_CLASS	0x01
#define NG_HCI_FILTER_COND_INQUIRY_BDADDR	0x02
d328 4
a331 4
/* Filter condition types for NG_HCI_FILTER_TYPE_CON_SETUP */
#define NG_HCI_FILTER_COND_CON_ANY_UNIT		0x00
#define NG_HCI_FILTER_COND_CON_UNIT_CLASS	0x01
#define NG_HCI_FILTER_COND_CON_BDADDR		0x02
d335 2
a336 2
#define NG_HCI_XMIT_LEVEL_CURRENT		0x00
#define NG_HCI_XMIT_LEVEL_MAXIMUM		0x01
d339 5
a343 5
/* Host to Host Controller flow control */
#define NG_HCI_H2HC_FLOW_CONTROL_NONE		0x00
#define NG_HCI_H2HC_FLOW_CONTROL_ACL		0x01
#define NG_HCI_H2HC_FLOW_CONTROL_SCO		0x02
#define NG_HCI_H2HC_FLOW_CONTROL_BOTH		0x03	/* ACL and SCO */
a345 5
/* Country codes */
#define NG_HCI_COUNTRY_CODE_NAM_EUR_JP		0x00
#define NG_HCI_COUNTRY_CODE_FRANCE		0x01
/* 0x02 - 0xFF - reserved future use */

d347 3
a349 3
#define NG_HCI_LOOPBACK_NONE			0x00
#define NG_HCI_LOOPBACK_LOCAL			0x01
#define NG_HCI_LOOPBACK_REMOTE			0x02
d358 2
a359 2
/* 
 * Macro(s) to combine OpCode and extract OGF (OpCode Group Field) 
d363 3
a365 3
#define NG_HCI_OPCODE(gf,cf)		((((gf) & 0x3f) << 10) | ((cf) & 0x3ff))
#define NG_HCI_OCF(op)			((op) & 0x3ff)
#define NG_HCI_OGF(op)			(((op) >> 10) & 0x3f)
d367 2
a368 2
/* 
 * Marco(s) to extract/combine connection handle, BC (Broadcast) and 
d372 4
a375 4
#define NG_HCI_CON_HANDLE(h)		((h) & 0x0fff)
#define NG_HCI_PB_FLAG(h)		(((h) & 0x3000) >> 12)
#define NG_HCI_BC_FLAG(h)		(((h) & 0xc000) >> 14)
#define NG_HCI_MK_CON_HANDLE(h, pb, bc) \
d380 2
a381 2
#define	NG_HCI_PACKET_FRAGMENT		0x1 
#define	NG_HCI_PACKET_START		0x2
d385 3
a387 3
#define NG_HCI_POINT2POINT		0x0 /* only Host controller to Host */
#define NG_HCI_BROADCAST_ACTIVE		0x1 /* both directions */
#define NG_HCI_BROADCAST_PICONET	0x2 /* both directions */
a390 2
#define NG_HCI_CMD_PKT			0x01
#define NG_HCI_CMD_PKT_SIZE		0xff /* without header */
d392 7
a398 4
	u_int8_t	type;   /* MUST be 0x1 */
	u_int16_t	opcode; /* OpCode */
	u_int8_t	length; /* parameter(s) length in bytes */
} __attribute__ ((packed)) ng_hci_cmd_pkt_t;
a400 2
#define NG_HCI_ACL_DATA_PKT		0x02
#define NG_HCI_ACL_PKT_SIZE		0xffff /* without header */
d402 7
a408 4
	u_int8_t	type;        /* MUST be 0x2 */
	u_int16_t	con_handle;  /* connection handle + PB + BC flags */
	u_int16_t	length;      /* payload length in bytes */
} __attribute__ ((packed)) ng_hci_acldata_pkt_t;
a410 2
#define NG_HCI_SCO_DATA_PKT		0x03
#define NG_HCI_SCO_PKT_SIZE		0xff /* without header */
d412 7
a418 4
	u_int8_t	type;       /* MUST be 0x3 */
	u_int16_t	con_handle; /* connection handle + reserved bits */
	u_int8_t	length;     /* payload length in bytes */
} __attribute__ ((packed)) ng_hci_scodata_pkt_t;
a420 2
#define NG_HCI_EVENT_PKT		0x04
#define NG_HCI_EVENT_PKT_SIZE		0xff /* without header */
d422 4
a425 10
	u_int8_t	type;   /* MUST be 0x4 */
	u_int8_t	event;  /* event */
	u_int8_t	length; /* parameter(s) length in bytes */
} __attribute__ ((packed)) ng_hci_event_pkt_t;

/* Bluetooth unit address */
typedef struct {
	u_int8_t	b[NG_HCI_BDADDR_SIZE];
} __attribute__ ((packed)) bdaddr_t;
typedef bdaddr_t *	bdaddr_p;
d427 2
a428 2
/* Any BD_ADDR. Note: This is actually 7 bytes (count '\0' terminator) */
#define NG_HCI_BDADDR_ANY	((bdaddr_p) "\000\000\000\000\000\000")
d432 2
a433 2
	u_int8_t	status; /* 0x00 - success */
} __attribute__ ((packed)) ng_hci_status_rp;
d437 1
a437 1
 **        Upper layer protocol interface. LP_xxx event parameters
d441 1
a441 70
/* Connection Request Event */
#define NGM_HCI_LP_CON_REQ			1  /* Upper -> HCI */
typedef struct {
	u_int16_t	link_type; /* type of connection */
	bdaddr_t	bdaddr;    /* remote unit address */
} ng_hci_lp_con_req_ep;

/*
 * XXX XXX XXX
 *
 * NOTE: This request is not defined by Bluetooth specification, 
 * but i find it useful :)
 */
#define NGM_HCI_LP_DISCON_REQ			2 /* Upper -> HCI */
typedef struct {
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	reason;	    /* reason to disconnect (only low byte) */
} ng_hci_lp_discon_req_ep;

/* Connection Confirmation Event */
#define NGM_HCI_LP_CON_CFM			3  /* HCI -> Upper */
typedef struct {
	u_int8_t	status;     /* 0x00 - success */
	u_int8_t	link_type;  /* link type */
	u_int16_t	con_handle; /* con_handle */
	bdaddr_t	bdaddr;     /* remote unit address */
} ng_hci_lp_con_cfm_ep;

/* Connection Indication Event */
#define NGM_HCI_LP_CON_IND			4  /* HCI -> Upper */
typedef struct {
	u_int8_t	link_type;                 /* link type */
	u_int8_t	uclass[NG_HCI_CLASS_SIZE]; /* unit class */
	bdaddr_t	bdaddr;                    /* remote unit address */
} ng_hci_lp_con_ind_ep;

/* Connection Response Event */
#define NGM_HCI_LP_CON_RSP			5  /* Upper -> HCI */
typedef struct {
	u_int8_t	status;    /* 0x00 - accept connection */
	u_int8_t	link_type; /* link type */
	bdaddr_t	bdaddr;    /* remote unit address */
} ng_hci_lp_con_rsp_ep;

/* Disconnection Indication Event */
#define NGM_HCI_LP_DISCON_IND			6  /* HCI -> Upper */
typedef struct {
	u_int8_t	reason;     /* reason to disconnect (only low byte) */
	u_int8_t	link_type;  /* link type */
	u_int16_t	con_handle; /* connection handle */
} ng_hci_lp_discon_ind_ep;

/* QoS Setup Request Event */
#define NGM_HCI_LP_QOS_REQ			7  /* Upper -> HCI */
typedef struct {
	u_int16_t	con_handle;      /* connection handle */
	u_int8_t	flags;           /* reserved */
	u_int8_t	service_type;    /* service type */
	u_int32_t	token_rate;      /* bytes/sec */
	u_int32_t	peak_bandwidth;  /* bytes/sec */
	u_int32_t	latency;         /* msec */
	u_int32_t	delay_variation; /* msec */
} ng_hci_lp_qos_req_ep;

/* QoS Conformition Event */
#define NGM_HCI_LP_QOS_CFM			8  /* HCI -> Upper */
typedef struct {
	u_int16_t	status;          /* 0x00 - success  (only low byte) */
	u_int16_t	con_handle;      /* connection handle */
} ng_hci_lp_qos_cfm_ep;
d443 2
a444 2
/* QoS Violation Indication Event */
#define NGM_HCI_LP_QOS_IND			9  /* HCI -> Upper */
d446 4
a449 154
	u_int16_t	con_handle; /* connection handle */
} ng_hci_lp_qos_ind_ep;

/**************************************************************************
 **************************************************************************
 **                    HCI node command/event parameters
 **************************************************************************
 **************************************************************************/

/* Debug levels */
#define NG_HCI_ALERT_LEVEL		1
#define NG_HCI_ERR_LEVEL		2
#define NG_HCI_WARN_LEVEL		3
#define NG_HCI_INFO_LEVEL		4

/* Unit states */
#define NG_HCI_UNIT_CONNECTED		(1 << 0)
#define NG_HCI_UNIT_INITED		(1 << 1)
#define NG_HCI_UNIT_READY	(NG_HCI_UNIT_CONNECTED|NG_HCI_UNIT_INITED)
#define NG_HCI_UNIT_COMMAND_PENDING	(1 << 2)

/* Connection state */
#define NG_HCI_CON_CLOSED		0 /* connection closed */
#define NG_HCI_CON_W4_LP_CON_RSP	1 /* wait for LP_ConnectRsp */
#define NG_HCI_CON_W4_CONN_COMPLETE	2 /* wait for Connection_Complete evt */
#define NG_HCI_CON_OPEN			3 /* connection open */

/* Get HCI node (unit) state (see states above) */
#define NGM_HCI_NODE_GET_STATE			100  /* HCI -> User */
typedef u_int16_t	ng_hci_node_state_ep;

/* Turn on "inited" bit */
#define NGM_HCI_NODE_INIT			101 /* User -> HCI */
/* No parameters */

/* Get/Set node debug level (see debug levels above) */
#define NGM_HCI_NODE_GET_DEBUG			102 /* HCI -> User */
#define NGM_HCI_NODE_SET_DEBUG			103 /* User -> HCI */
typedef u_int16_t	ng_hci_node_debug_ep;

/* Get node buffer info */
#define NGM_HCI_NODE_GET_BUFFER			104 /* HCI -> User */
typedef struct {
	u_int8_t	cmd_free; /* number of free command packets */
	u_int8_t	sco_size; /* max. size of SCO packet */
	u_int16_t	sco_pkts; /* number of SCO packets */
	u_int16_t	sco_free; /* number of free SCO packets */
	u_int16_t	acl_size; /* max. size of ACL packet */
	u_int16_t	acl_pkts; /* number of ACL packets */
	u_int16_t	acl_free; /* number of free ACL packets */
} ng_hci_node_buffer_ep;

/* Get BDADDR */
#define NGM_HCI_NODE_GET_BDADDR			105 /* HCI -> User */
/* bdaddr_t -- BDADDR */

/* Get features */
#define NGM_HCI_NODE_GET_FEATURES		106 /* HCI -> User */
/* features[NG_HCI_FEATURES_SIZE] -- features */

#define NGM_HCI_NODE_GET_STAT			107 /* HCI -> User */
typedef struct {
	u_int32_t	cmd_sent;   /* number of HCI commands sent */
	u_int32_t	evnt_recv;  /* number of HCI events received */
	u_int32_t	acl_recv;   /* number of ACL packets received */
	u_int32_t	acl_sent;   /* number of ACL packets sent */
	u_int32_t	sco_recv;   /* number of SCO packets received */
	u_int32_t	sco_sent;   /* number of SCO packets sent */
	u_int32_t	bytes_recv; /* total number of bytes received */
	u_int32_t	bytes_sent; /* total number of bytes sent */
} ng_hci_node_stat_ep;

#define NGM_HCI_NODE_RESET_STAT			108 /* User -> HCI */
/* No parameters */

#define NGM_HCI_NODE_FLUSH_NEIGHBOR_CACHE	109 /* User -> HCI */

#define NGM_HCI_NODE_GET_NEIGHBOR_CACHE		110 /* HCI -> User */
typedef struct {
	u_int32_t	num_entries;	/* number of entries */
} ng_hci_node_get_neighbor_cache_ep;

typedef struct {
	u_int16_t	page_scan_rep_mode;             /* page rep scan mode */
	u_int16_t	page_scan_mode;                 /* page scan mode */
	u_int16_t	clock_offset;                   /* clock offset */
	bdaddr_t	bdaddr;                         /* bdaddr */
	u_int8_t	features[NG_HCI_FEATURES_SIZE]; /* features */
} ng_hci_node_neighbor_cache_entry_ep;

#define NG_HCI_MAX_NEIGHBOR_NUM \
	((0xffff - sizeof(ng_hci_node_get_neighbor_cache_ep))/sizeof(ng_hci_node_neighbor_cache_entry_ep))

#define NGM_HCI_NODE_GET_CON_LIST		111 /* HCI -> User */
typedef struct {
	u_int32_t	num_connections; /* number of connections */
} ng_hci_node_con_list_ep;

typedef struct {
	u_int8_t	link_type;       /* ACL or SCO */
	u_int8_t	encryption_mode; /* none, p2p, ... */
	u_int8_t	mode;            /* ACTIVE, HOLD ... */
	u_int8_t	role;            /* MASTER/SLAVE */
	u_int16_t	state;           /* connection state */
	u_int16_t	reserved;        /* place holder */
	u_int16_t	pending;         /* number of pending packets */
	u_int16_t	queue_len;       /* number of packets in queue */
	u_int16_t	con_handle;      /* connection handle */
	bdaddr_t	bdaddr;          /* remote bdaddr */
} ng_hci_node_con_ep;

#define NG_HCI_MAX_CON_NUM \
	((0xffff - sizeof(ng_hci_node_con_list_ep))/sizeof(ng_hci_node_con_ep))

#define NGM_HCI_NODE_UP				112 /* HCI -> Upper */
typedef struct {
	u_int16_t	pkt_size; /* max. ACL/SCO packet size (w/out header) */
	u_int16_t	num_pkts; /* ACL/SCO packet queue size */
	u_int16_t	reserved; /* place holder */
	bdaddr_t	bdaddr;	  /* bdaddr */
} ng_hci_node_up_ep;

#define NGM_HCI_SYNC_CON_QUEUE			113 /* HCI -> Upper */
typedef struct {
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	completed;  /* number of completed packets */
} ng_hci_sync_con_queue_ep;

#define NGM_HCI_NODE_GET_LINK_POLICY_SETTINGS_MASK	114 /* HCI -> User */
#define NGM_HCI_NODE_SET_LINK_POLICY_SETTINGS_MASK	115 /* User -> HCI */
typedef u_int16_t	ng_hci_node_link_policy_mask_ep;

#define NGM_HCI_NODE_GET_PACKET_MASK		116 /* HCI -> User */
#define NGM_HCI_NODE_SET_PACKET_MASK		117 /* User -> HCI */
typedef u_int16_t	ng_hci_node_packet_mask_ep;

#define NGM_HCI_NODE_GET_ROLE_SWITCH		118 /* HCI -> User */
#define NGM_HCI_NODE_SET_ROLE_SWITCH		119 /* User -> HCI */
typedef u_int16_t	ng_hci_node_role_switch_ep;

/**************************************************************************
 **************************************************************************
 **             Link control commands and return parameters
 **************************************************************************
 **************************************************************************/

#define NG_HCI_OGF_LINK_CONTROL			0x01 /* OpCode Group Field */

#define NG_HCI_OCF_INQUIRY			0x0001
typedef struct {
	u_int8_t	lap[NG_HCI_LAP_SIZE]; /* LAP */
	u_int8_t	inquiry_length; /* (N x 1.28) sec */
	u_int8_t	num_responses;  /* Max. # of responses before halted */
} __attribute__ ((packed)) ng_hci_inquiry_cp;
d452 2
a453 1
#define NG_HCI_OCF_INQUIRY_CANCEL		0x0002
d455 1
a455 1
typedef ng_hci_status_rp	ng_hci_inquiry_cancel_rp;
d457 2
a458 1
#define NG_HCI_OCF_PERIODIC_INQUIRY		0x0003
d460 8
a467 6
	u_int16_t	max_period_length; /* Max. and min. amount of time */
	u_int16_t	min_period_length; /* between consecutive inquiries */
	u_int8_t	lap[NG_HCI_LAP_SIZE]; /* LAP */
	u_int8_t	inquiry_length;    /* (inquiry_length * 1.28) sec */
	u_int8_t	num_responses;     /* Max. # of responses */
} __attribute__ ((packed)) ng_hci_periodic_inquiry_cp;
d469 2
a470 3
typedef ng_hci_status_rp	ng_hci_periodic_inquiry_rp;
	
#define NG_HCI_OCF_EXIT_PERIODIC_INQUIRY	0x0004
d472 1
a472 1
typedef ng_hci_status_rp	ng_hci_exit_periodic_inquiry_rp;
d474 2
a475 1
#define NG_HCI_OCF_CREATE_CON			0x0005
d478 6
a483 6
	u_int16_t	pkt_type;           /* packet type */
	u_int8_t	page_scan_rep_mode; /* page scan repetition mode */
	u_int8_t	page_scan_mode;     /* page scan mode */
	u_int16_t	clock_offset;       /* clock offset */
	u_int8_t	accept_role_switch; /* accept role switch? 0x00 - no */
} __attribute__ ((packed)) ng_hci_create_con_cp;
d486 2
a487 1
#define NG_HCI_OCF_DISCON			0x0006
d489 3
a491 3
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	reason;     /* reason to disconnect */
} __attribute__ ((packed)) ng_hci_discon_cp;
d494 3
a496 1
#define NG_HCI_OCF_ADD_SCO_CON			0x0007
d498 3
a500 3
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	pkt_type;   /* packet type */
} __attribute__ ((packed)) ng_hci_add_sco_con_cp;
d503 13
a515 1
#define NG_HCI_OCF_ACCEPT_CON			0x0009
d518 2
a519 2
	u_int8_t	role;   /* connection role */
} __attribute__ ((packed)) ng_hci_accept_con_cp;
d522 2
a523 1
#define NG_HCI_OCF_REJECT_CON			0x000a
d526 2
a527 2
	u_int8_t	reason; /* reason to reject */
} __attribute__ ((packed)) ng_hci_reject_con_cp;
d530 2
a531 1
#define NG_HCI_OCF_LINK_KEY_REP			0x000b
d533 3
a535 3
	bdaddr_t	bdaddr;               /* remote address */
	u_int8_t	key[NG_HCI_KEY_SIZE]; /* key */
} __attribute__ ((packed)) ng_hci_link_key_rep_cp;
d538 1
a538 1
	u_int8_t	status; /* 0x00 - success */
d540 1
a540 1
} __attribute__ ((packed)) ng_hci_link_key_rep_rp;
d542 2
a543 1
#define NG_HCI_OCF_LINK_KEY_NEG_REP		0x000c
d546 1
a546 1
} __attribute__ ((packed)) ng_hci_link_key_neg_rep_cp;
d549 1
a549 1
	u_int8_t	status; /* 0x00 - success */
d551 1
a551 1
} __attribute__ ((packed)) ng_hci_link_key_neg_rep_rp;
d553 2
a554 1
#define NG_HCI_OCF_PIN_CODE_REP			0x000d
d557 3
a559 3
	u_int8_t	pin_size;             /* pin code length (in bytes) */
	u_int8_t	pin[NG_HCI_PIN_SIZE]; /* pin code */
} __attribute__ ((packed)) ng_hci_pin_code_rep_cp;
d562 1
a562 1
	u_int8_t	status; /* 0x00 - success */
d564 1
a564 1
} __attribute__ ((packed)) ng_hci_pin_code_rep_rp;
d566 2
a567 1
#define NG_HCI_OCF_PIN_CODE_NEG_REP		0x000e
d569 2
a570 2
	bdaddr_t	bdaddr;  /* remote address */
} __attribute__ ((packed)) ng_hci_pin_code_neg_rep_cp;
d573 1
a573 1
	u_int8_t	status; /* 0x00 - success */
d575 9
a583 1
} __attribute__ ((packed)) ng_hci_pin_code_neg_rep_rp;
d585 2
a586 1
#define NG_HCI_OCF_CHANGE_CON_PKT_TYPE		0x000f
d588 2
a589 3
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	pkt_type;   /* packet type */
} __attribute__ ((packed)) ng_hci_change_con_pkt_type_cp;
d592 2
a593 1
#define NG_HCI_OCF_AUTH_REQ			0x0011
d595 3
a597 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_auth_req_cp;
d600 2
a601 1
#define NG_HCI_OCF_SET_CON_ENCRYPTION		0x0013
d603 2
a604 3
	u_int16_t	con_handle;        /* connection handle */
	u_int8_t	encryption_enable; /* 0x00 - disable, 0x01 - enable */
} __attribute__ ((packed)) ng_hci_set_con_encryption_cp;
d607 2
a608 1
#define NG_HCI_OCF_CHANGE_CON_LINK_KEY		0x0015
d610 2
a611 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_change_con_link_key_cp;
d614 2
a615 1
#define NG_HCI_OCF_MASTER_LINK_KEY		0x0017
d617 5
a621 2
	u_int8_t	key_flag; /* key flag */
} __attribute__ ((packed)) ng_hci_master_link_key_cp;
d624 2
a625 1
#define NG_HCI_OCF_REMOTE_NAME_REQ		0x0019
d628 34
a661 4
	u_int8_t	page_scan_rep_mode; /* page scan repetition mode */
	u_int8_t	page_scan_mode;     /* page scan mode */
	u_int16_t	clock_offset;       /* clock offset */
} __attribute__ ((packed)) ng_hci_remote_name_req_cp;
d664 6
a669 1
#define NG_HCI_OCF_READ_REMOTE_FEATURES		0x001b
d671 17
a687 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_remote_features_cp;
d690 2
a691 1
#define NG_HCI_OCF_READ_REMOTE_VER_INFO		0x001d
d693 8
a700 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_remote_ver_info_cp;
d703 2
a704 1
#define NG_HCI_OCF_READ_CLOCK_OFFSET		 0x001f
d706 3
a708 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_clock_offset_cp;
d713 1
a713 1
 **        Link policy commands and return parameters
d717 1
a717 1
#define NG_HCI_OGF_LINK_POLICY			0x02 /* OpCode Group Field */
d719 2
a720 1
#define NG_HCI_OCF_HOLD_MODE			0x0001
d722 4
a725 4
	u_int16_t	con_handle;   /* connection handle */
	u_int16_t	max_interval; /* (max_interval * 0.625) msec */
	u_int16_t	min_interval; /* (max_interval * 0.625) msec */
} __attribute__ ((packed)) ng_hci_hold_mode_cp;
d728 2
a729 1
#define NG_HCI_OCF_SNIFF_MODE			0x0003
d731 6
a736 6
	u_int16_t	con_handle;   /* connection handle */
	u_int16_t	max_interval; /* (max_interval * 0.625) msec */
	u_int16_t	min_interval; /* (max_interval * 0.625) msec */
	u_int16_t	attempt;      /* (2 * attempt - 1) * 0.625 msec */
	u_int16_t	timeout;      /* (2 * attempt - 1) * 0.625 msec */
} __attribute__ ((packed)) ng_hci_sniff_mode_cp;
d739 2
a740 1
#define NG_HCI_OCF_EXIT_SNIFF_MODE		0x0004
d742 2
a743 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_exit_sniff_mode_cp;
d746 2
a747 1
#define NG_HCI_OCF_PARK_MODE			0x0005
d749 4
a752 4
	u_int16_t	con_handle;   /* connection handle */
	u_int16_t	max_interval; /* (max_interval * 0.625) msec */
	u_int16_t	min_interval; /* (max_interval * 0.625) msec */
} __attribute__ ((packed)) ng_hci_park_mode_cp;
d755 2
a756 1
#define NG_HCI_OCF_EXIT_PARK_MODE		0x0006
d758 2
a759 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_exit_park_mode_cp;
d762 2
a763 1
#define NG_HCI_OCF_QOS_SETUP			0x0007
d765 8
a772 8
	u_int16_t	con_handle;      /* connection handle */
	u_int8_t	flags;           /* reserved for future use */
	u_int8_t	service_type;    /* service type */
	u_int32_t	token_rate;      /* bytes per second */
	u_int32_t	peak_bandwidth;  /* bytes per second */
	u_int32_t	latency;         /* microseconds */
	u_int32_t	delay_variation; /* microseconds */
} __attribute__ ((packed)) ng_hci_qos_setup_cp;
d775 2
a776 1
#define NG_HCI_OCF_ROLE_DISCOVERY		0x0009
d778 2
a779 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_role_discovery_cp;
d782 4
a785 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	role;       /* role for the connection handle */
} __attribute__ ((packed)) ng_hci_role_discovery_rp;
d787 2
a788 1
#define NG_HCI_OCF_SWITCH_ROLE			0x000b
d791 2
a792 2
	u_int8_t	role;   /* new local role */
} __attribute__ ((packed)) ng_hci_switch_role_cp;
d795 14
a808 1
#define NG_HCI_OCF_READ_LINK_POLICY_SETTINGS	0x000c
d810 12
a821 3
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_link_policy_settings_cp;
	
d823 3
a825 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	settings;   /* link policy settings */
} __attribute__ ((packed)) ng_hci_read_link_policy_settings_rp;
d827 2
a828 1
#define NG_HCI_OCF_WRITE_LINK_POLICY_SETTINGS	0x000d
d830 4
a833 3
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	settings;   /* link policy settings */
} __attribute__ ((packed)) ng_hci_write_link_policy_settings_cp;
d835 2
d838 10
a847 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_write_link_policy_settings_rp;
d851 1
a851 1
 **   Host controller and baseband commands and return parameters 
d855 1
a855 1
#define NG_HCI_OGF_HC_BASEBAND			0x03 /* OpCode Group Field */
d857 2
a858 1
#define NG_HCI_OCF_SET_EVENT_MASK		0x0001
d860 2
a861 2
	u_int8_t	event_mask[NG_HCI_EVENT_MASK_SIZE]; /* event_mask */
} __attribute__ ((packed)) ng_hci_set_event_mask_cp;
d863 1
a863 1
typedef ng_hci_status_rp	ng_hci_set_event_mask_rp;
d865 2
a866 1
#define NG_HCI_OCF_RESET			0x0003
d868 1
a868 1
typedef ng_hci_status_rp	ng_hci_reset_rp;
d870 2
a871 1
#define NG_HCI_OCF_SET_EVENT_FILTER		0x0005
d873 5
a877 4
	u_int8_t	filter_type;           /* filter type */
	u_int8_t	filter_condition_type; /* filter condition type */
	u_int8_t	condition[0];          /* conditions - variable size */
} __attribute__ ((packed)) ng_hci_set_event_filter_cp;
d879 1
a879 1
typedef ng_hci_status_rp	ng_hci_set_event_filter_rp;
d881 2
a882 1
#define NG_HCI_OCF_FLUSH			0x0008
d884 2
a885 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_flush_cp;
d888 3
a890 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_flush_rp;
d892 2
a893 1
#define NG_HCI_OCF_READ_PIN_TYPE		0x0009
d896 3
a898 3
	u_int8_t	status;   /* 0x00 - success */
	u_int8_t	pin_type; /* PIN type */
} __attribute__ ((packed)) ng_hci_read_pin_type_rp;
d900 2
a901 1
#define NG_HCI_OCF_WRITE_PIN_TYPE		0x000a
d903 2
a904 2
	u_int8_t	pin_type; /* PIN type */
} __attribute__ ((packed)) ng_hci_write_pin_type_cp;
d906 1
a906 1
typedef ng_hci_status_rp	ng_hci_write_pin_type_rp;
d908 2
a909 1
#define NG_HCI_OCF_CREATE_NEW_UNIT_KEY		0x000b
d911 1
a911 1
typedef ng_hci_status_rp	ng_hci_create_new_unit_key_rp;
d913 2
a914 1
#define NG_HCI_OCF_READ_STORED_LINK_KEY		0x000d
d917 2
a918 2
	u_int8_t	read_all; /* read all keys? 0x01 - yes */
} __attribute__ ((packed)) ng_hci_read_stored_link_key_cp;
d921 4
a924 4
	u_int8_t	status;        /* 0x00 - success */
	u_int16_t	max_num_keys;  /* Max. number of keys */
	u_int16_t	num_keys_read; /* Number of stored keys */
} __attribute__ ((packed)) ng_hci_read_stored_link_key_rp;
d926 2
a927 1
#define NG_HCI_OCF_WRITE_STORED_LINK_KEY	0x0011
d929 5
a933 5
	u_int8_t	num_keys_write; /* # of keys to write */
/* these are repeated "num_keys_write" times 
	bdaddr_t	bdaddr;                --- remote address(es)
	u_int8_t	key[NG_HCI_KEY_SIZE];  --- key(s) */
} __attribute__ ((packed)) ng_hci_write_stored_link_key_cp;
d936 3
a938 3
	u_int8_t	status;           /* 0x00 - success */
	u_int8_t	num_keys_written; /* # of keys successfully written */
} __attribute__ ((packed)) ng_hci_write_stored_link_key_rp;
d940 2
a941 1
#define NG_HCI_OCF_DELETE_STORED_LINK_KEY	0x0012
d944 2
a945 2
	u_int8_t	delete_all; /* delete all keys? 0x01 - yes */
} __attribute__ ((packed)) ng_hci_delete_stored_link_key_cp;
d948 3
a950 3
	u_int8_t	status;           /* 0x00 - success */
	u_int16_t	num_keys_deleted; /* Number of keys deleted */
} __attribute__ ((packed)) ng_hci_delete_stored_link_key_rp;
d952 2
a953 1
#define NG_HCI_OCF_CHANGE_LOCAL_NAME		0x0013
d955 2
a956 2
	char		name[NG_HCI_UNIT_NAME_SIZE]; /* new unit name */
} __attribute__ ((packed)) ng_hci_change_local_name_cp;
d958 1
a958 1
typedef ng_hci_status_rp	ng_hci_change_local_name_rp;
d960 2
a961 1
#define NG_HCI_OCF_READ_LOCAL_NAME		0x0014
d964 3
a966 3
	u_int8_t	status;  /* 0x00 - success */
	char		name[NG_HCI_UNIT_NAME_SIZE]; /* unit name */
} __attribute__ ((packed)) ng_hci_read_local_name_rp;
d968 2
a969 1
#define NG_HCI_OCF_READ_CON_ACCEPT_TIMO		0x0015
d972 3
a974 3
	u_int8_t	status;  /* 0x00 - success */
	u_int16_t	timeout; /* (timeout * 0.625) msec */
} __attribute__ ((packed)) ng_hci_read_con_accept_timo_rp;
d976 2
a977 1
#define NG_HCI_OCF_WRITE_CON_ACCEPT_TIMO	0x0016
d979 2
a980 2
	u_int16_t	timeout; /* (timeout * 0.625) msec */
} __attribute__ ((packed)) ng_hci_write_con_accept_timo_cp;
d982 1
a982 1
typedef ng_hci_status_rp	ng_hci_write_con_accept_timo_rp;
d984 2
a985 1
#define NG_HCI_OCF_READ_PAGE_TIMO		0x0017
d988 3
a990 3
	u_int8_t	status;  /* 0x00 - success */
	u_int16_t	timeout; /* (timeout * 0.625) msec */
} __attribute__ ((packed)) ng_hci_read_page_timo_rp;
d992 2
a993 1
#define NG_HCI_OCF_WRITE_PAGE_TIMO		0x0018
d995 2
a996 2
	u_int16_t	timeout; /* (timeout * 0.625) msec */
} __attribute__ ((packed)) ng_hci_write_page_timo_cp;
d998 1
a998 1
typedef ng_hci_status_rp	ng_hci_write_page_timo_rp;
d1000 2
a1001 1
#define NG_HCI_OCF_READ_SCAN_ENABLE		0x0019
d1004 3
a1006 3
	u_int8_t	status;      /* 0x00 - success */
	u_int8_t	scan_enable; /* Scan enable */
} __attribute__ ((packed)) ng_hci_read_scan_enable_rp;
d1008 2
a1009 1
#define NG_HCI_OCF_WRITE_SCAN_ENABLE		0x001a
d1011 2
a1012 2
	u_int8_t	scan_enable; /* Scan enable */
} __attribute__ ((packed)) ng_hci_write_scan_enable_cp;
d1014 1
a1014 1
typedef ng_hci_status_rp	ng_hci_write_scan_enable_rp;
d1016 2
a1017 1
#define NG_HCI_OCF_READ_PAGE_SCAN_ACTIVITY	0x001b
d1020 4
a1023 4
	u_int8_t	status;             /* 0x00 - success */
	u_int16_t	page_scan_interval; /* interval * 0.625 msec */
	u_int16_t	page_scan_window;   /* window * 0.625 msec */
} __attribute__ ((packed)) ng_hci_read_page_scan_activity_rp;
d1025 2
a1026 1
#define NG_HCI_OCF_WRITE_PAGE_SCAN_ACTIVITY	0x001c
d1028 3
a1030 3
	u_int16_t	page_scan_interval; /* interval * 0.625 msec */
	u_int16_t	page_scan_window;   /* window * 0.625 msec */
} __attribute__ ((packed)) ng_hci_write_page_scan_activity_cp;
d1032 1
a1032 1
typedef ng_hci_status_rp	ng_hci_write_page_scan_activity_rp;
d1034 2
a1035 1
#define NG_HCI_OCF_READ_INQUIRY_SCAN_ACTIVITY	0x001d
d1038 4
a1041 4
	u_int8_t	status;                /* 0x00 - success */
	u_int16_t	inquiry_scan_interval; /* interval * 0.625 msec */
	u_int16_t	inquiry_scan_window;   /* window * 0.625 msec */
} __attribute__ ((packed)) ng_hci_read_inquiry_scan_activity_rp;
d1043 2
a1044 1
#define NG_HCI_OCF_WRITE_INQUIRY_SCAN_ACTIVITY	0x001e
d1046 3
a1048 3
	u_int16_t	inquiry_scan_interval; /* interval * 0.625 msec */
	u_int16_t	inquiry_scan_window;   /* window * 0.625 msec */
} __attribute__ ((packed)) ng_hci_write_inquiry_scan_activity_cp;
d1050 1
a1050 1
typedef ng_hci_status_rp	ng_hci_write_inquiry_scan_activity_rp;
d1052 2
a1053 1
#define NG_HCI_OCF_READ_AUTH_ENABLE		0x001f
d1056 3
a1058 3
	u_int8_t	status;      /* 0x00 - success */
	u_int8_t	auth_enable; /* 0x01 - enabled */
} __attribute__ ((packed)) ng_hci_read_auth_enable_rp;
d1060 2
a1061 1
#define NG_HCI_OCF_WRITE_AUTH_ENABLE		0x0020
d1063 2
a1064 2
	u_int8_t	auth_enable; /* 0x01 - enabled */
} __attribute__ ((packed)) ng_hci_write_auth_enable_cp;
d1066 1
a1066 1
typedef ng_hci_status_rp	ng_hci_write_auth_enable_rp;
d1068 2
a1069 1
#define NG_HCI_OCF_READ_ENCRYPTION_MODE		0x0021
d1072 3
a1074 3
	u_int8_t	status;          /* 0x00 - success */
	u_int8_t	encryption_mode; /* encryption mode */
} __attribute__ ((packed)) ng_hci_read_encryption_mode_rp;
d1076 2
a1077 1
#define NG_HCI_OCF_WRITE_ENCRYPTION_MODE	0x0022
d1079 2
a1080 2
	u_int8_t	encryption_mode; /* encryption mode */
} __attribute__ ((packed)) ng_hci_write_encryption_mode_cp;
d1082 1
a1082 1
typedef ng_hci_status_rp	ng_hci_write_encryption_mode_rp;
d1084 2
a1085 1
#define NG_HCI_OCF_READ_UNIT_CLASS		0x0023
d1088 3
a1090 3
	u_int8_t	status;                    /* 0x00 - success */
	u_int8_t	uclass[NG_HCI_CLASS_SIZE]; /* unit class */
} __attribute__ ((packed)) ng_hci_read_unit_class_rp;
d1092 2
a1093 1
#define NG_HCI_OCF_WRITE_UNIT_CLASS		0x0024
d1095 2
a1096 2
	u_int8_t	uclass[NG_HCI_CLASS_SIZE]; /* unit class */
} __attribute__ ((packed)) ng_hci_write_unit_class_cp;
d1098 1
a1098 1
typedef ng_hci_status_rp	ng_hci_write_unit_class_rp;
d1100 2
a1101 1
#define NG_HCI_OCF_READ_VOICE_SETTINGS		0x0025
d1104 3
a1106 3
	u_int8_t	status;   /* 0x00 - success */
	u_int16_t	settings; /* voice settings */
} __attribute__ ((packed)) ng_hci_read_voice_settings_rp;
d1108 2
a1109 1
#define NG_HCI_OCF_WRITE_VOICE_SETTINGS		0x0026
d1111 2
a1112 2
	u_int16_t	settings; /* voice settings */
} __attribute__ ((packed)) ng_hci_write_voice_settings_cp;
d1114 1
a1114 1
typedef ng_hci_status_rp	ng_hci_write_voice_settings_rp;
d1116 2
a1117 1
#define NG_HCI_OCF_READ_AUTO_FLUSH_TIMO		0x0027
d1119 2
a1120 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_auto_flush_timo_cp;
d1123 7
a1129 6
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	timeout;    /* 0x00 - no flush, timeout * 0.625 msec */
} __attribute__ ((packed)) ng_hci_read_auto_flush_timo_rp;
	
#define NG_HCI_OCF_WRITE_AUTO_FLUSH_TIMO	0x0028
d1131 3
a1133 3
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	timeout;    /* 0x00 - no flush, timeout * 0.625 msec */
} __attribute__ ((packed)) ng_hci_write_auto_flush_timo_cp;
d1136 3
a1138 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_write_auto_flush_timo_rp;
d1140 2
a1141 1
#define NG_HCI_OCF_READ_NUM_BROADCAST_RETRANS	0x0029
d1144 3
a1146 3
	u_int8_t	status;  /* 0x00 - success */
	u_int8_t	counter; /* number of broadcast retransmissions */
} __attribute__ ((packed)) ng_hci_read_num_broadcast_retrans_rp;
d1148 2
a1149 1
#define NG_HCI_OCF_WRITE_NUM_BROADCAST_RETRANS	0x002a
d1151 2
a1152 2
	u_int8_t	counter; /* number of broadcast retransmissions */
} __attribute__ ((packed)) ng_hci_write_num_broadcast_retrans_cp;
d1154 1
a1154 1
typedef ng_hci_status_rp	ng_hci_write_num_broadcast_retrans_rp;
d1156 2
a1157 1
#define NG_HCI_OCF_READ_HOLD_MODE_ACTIVITY	0x002b
d1160 3
a1162 3
	u_int8_t	status;             /* 0x00 - success */
	u_int8_t	hold_mode_activity; /* Hold mode activities */
} __attribute__ ((packed)) ng_hci_read_hold_mode_activity_rp;
d1164 2
a1165 1
#define NG_HCI_OCF_WRITE_HOLD_MODE_ACTIVITY	0x002c
d1167 2
a1168 2
	u_int8_t	hold_mode_activity; /* Hold mode activities */
} __attribute__ ((packed)) ng_hci_write_hold_mode_activity_cp;
d1170 1
a1170 1
typedef ng_hci_status_rp	ng_hci_write_hold_mode_activity_rp;
d1172 2
a1173 1
#define NG_HCI_OCF_READ_XMIT_LEVEL		0x002d
d1175 3
a1177 3
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	type;       /* Xmit level type */
} __attribute__ ((packed)) ng_hci_read_xmit_level_cp;
d1180 2
a1181 2
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
d1183 1
a1183 1
} __attribute__ ((packed)) ng_hci_read_xmit_level_rp;
d1185 2
a1186 1
#define NG_HCI_OCF_READ_SCO_FLOW_CONTROL	0x002e
d1189 3
a1191 3
	u_int8_t	status;       /* 0x00 - success */
	u_int8_t	flow_control; /* 0x00 - disabled */
} __attribute__ ((packed)) ng_hci_read_sco_flow_control_rp;
d1193 2
a1194 1
#define NG_HCI_OCF_WRITE_SCO_FLOW_CONTROL	0x002f
d1196 2
a1197 2
	u_int8_t	flow_control; /* 0x00 - disabled */
} __attribute__ ((packed)) ng_hci_write_sco_flow_control_cp;
d1199 1
a1199 1
typedef ng_hci_status_rp	ng_hci_write_sco_flow_control_rp;
d1201 2
a1202 1
#define NG_HCI_OCF_H2HC_FLOW_CONTROL		0x0031
d1204 2
a1205 2
	u_int8_t	h2hc_flow; /* Host to Host controller flow control */
} __attribute__ ((packed)) ng_hci_h2hc_flow_control_cp;
d1207 1
a1207 1
typedef ng_hci_status_rp	ng_hci_h2hc_flow_control_rp;
d1209 2
a1210 1
#define NG_HCI_OCF_HOST_BUFFER_SIZE		0x0033
d1212 5
a1216 5
	u_int16_t	max_acl_size; /* Max. size of ACL packet (bytes) */
	u_int8_t	max_sco_size; /* Max. size of SCO packet (bytes) */
	u_int16_t	num_acl_pkt;  /* Max. number of ACL packets */
	u_int16_t	num_sco_pkt;  /* Max. number of SCO packets */
} __attribute__ ((packed)) ng_hci_host_buffer_size_cp;
d1218 1
a1218 1
typedef ng_hci_status_rp	ng_hci_host_buffer_size_rp;
d1220 2
a1221 1
#define NG_HCI_OCF_HOST_NUM_COMPL_PKTS		0x0035
d1223 1
a1223 1
	u_int8_t	num_con_handles; /* # of connection handles */
d1225 3
a1227 3
	u_int16_t	con_handle; --- connection handle(s)
	u_int16_t	compl_pkt;  --- # of completed packets */
} __attribute__ ((packed)) ng_hci_host_num_compl_pkts_cp;
d1230 2
a1231 1
#define NG_HCI_OCF_READ_LINK_SUPERVISION_TIMO	0x0036
d1233 2
a1234 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_link_supervision_timo_cp;
d1237 4
a1240 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	timeout;    /* Link supervision timeout * 0.625 msec */
} __attribute__ ((packed)) ng_hci_read_link_supervision_timo_rp;
d1242 2
a1243 1
#define NG_HCI_OCF_WRITE_LINK_SUPERVISION_TIMO	0x0037
d1245 3
a1247 3
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	timeout;    /* Link supervision timeout * 0.625 msec */
} __attribute__ ((packed)) ng_hci_write_link_supervision_timo_cp;
d1250 3
a1252 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_write_link_supervision_timo_rp;
d1254 2
a1255 1
#define NG_HCI_OCF_READ_SUPPORTED_IAC_NUM	0x0038
d1258 3
a1260 3
	u_int8_t	status;  /* 0x00 - success */
	u_int8_t	num_iac; /* # of supported IAC during scan */
} __attribute__ ((packed)) ng_hci_read_supported_iac_num_rp;
d1262 2
a1263 1
#define NG_HCI_OCF_READ_IAC_LAP			0x0039
d1266 5
a1270 5
	u_int8_t	status;  /* 0x00 - success */
	u_int8_t	num_iac; /* # of IAC */
/* these are repeated "num_iac" times 
	u_int8_t	laps[NG_HCI_LAP_SIZE]; --- LAPs */
} __attribute__ ((packed)) ng_hci_read_iac_lap_rp;
d1272 2
a1273 1
#define NG_HCI_OCF_WRITE_IAC_LAP		0x003a
d1275 4
a1278 4
	u_int8_t	num_iac; /* # of IAC */
/* these are repeated "num_iac" times 
	u_int8_t	laps[NG_HCI_LAP_SIZE]; --- LAPs */
} __attribute__ ((packed)) ng_hci_write_iac_lap_cp;
d1280 1
a1280 1
typedef ng_hci_status_rp	ng_hci_write_iac_lap_rp;
d1282 2
a1283 1
#define NG_HCI_OCF_READ_PAGE_SCAN_PERIOD	0x003b
d1286 3
a1288 3
	u_int8_t	status;                /* 0x00 - success */
	u_int8_t	page_scan_period_mode; /* Page scan period mode */
} __attribute__ ((packed)) ng_hci_read_page_scan_period_rp;
d1290 2
a1291 1
#define NG_HCI_OCF_WRITE_PAGE_SCAN_PERIOD	0x003c
d1293 2
a1294 2
	u_int8_t	page_scan_period_mode; /* Page scan period mode */
} __attribute__ ((packed)) ng_hci_write_page_scan_period_cp;
d1296 1
a1296 1
typedef ng_hci_status_rp	ng_hci_write_page_scan_period_rp;
d1298 3
a1300 1
#define NG_HCI_OCF_READ_PAGE_SCAN		0x003d
d1303 10
a1312 3
	u_int8_t	status;         /* 0x00 - success */
	u_int8_t	page_scan_mode; /* Page scan mode */
} __attribute__ ((packed)) ng_hci_read_page_scan_rp;
d1314 4
a1317 1
#define NG_HCI_OCF_WRITE_PAGE_SCAN		0x003e
d1319 8
a1326 2
	u_int8_t	page_scan_mode; /* Page scan mode */
} __attribute__ ((packed)) ng_hci_write_page_scan_cp;
d1328 63
a1390 1
typedef ng_hci_status_rp	ng_hci_write_page_scan_rp;
d1394 1
a1394 2
 **           Informational commands and return parameters 
 **     All commands in this category do not accept any parameters
d1398 29
a1426 1
#define NG_HCI_OGF_INFO				0x04 /* OpCode Group Field */
d1428 2
a1429 1
#define NG_HCI_OCF_READ_LOCAL_VER		0x0001
d1431 2
a1432 7
	u_int8_t	status;         /* 0x00 - success */
	u_int8_t	hci_version;    /* HCI version */
	u_int16_t	hci_revision;   /* HCI revision */
	u_int8_t	lmp_version;    /* LMP version */
	u_int16_t	manufacturer;   /* Hardware manufacturer name */
	u_int16_t	lmp_subversion; /* LMP sub-version */
} __attribute__ ((packed)) ng_hci_read_local_ver_rp;
a1433 1
#define NG_HCI_OCF_READ_LOCAL_FEATURES		0x0003
d1435 5
a1439 3
	u_int8_t	status;                         /* 0x00 - success */
	u_int8_t	features[NG_HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __attribute__ ((packed)) ng_hci_read_local_features_rp;
d1441 3
a1443 1
#define NG_HCI_OCF_READ_BUFFER_SIZE		0x0005
d1445 6
a1450 6
	u_int8_t	status;       /* 0x00 - success */
	u_int16_t	max_acl_size; /* Max. size of ACL packet (bytes) */
	u_int8_t	max_sco_size; /* Max. size of SCO packet (bytes) */
	u_int16_t	num_acl_pkt;  /* Max. number of ACL packets */
	u_int16_t	num_sco_pkt;  /* Max. number of SCO packets */
} __attribute__ ((packed)) ng_hci_read_buffer_size_rp;
d1452 4
a1455 1
#define NG_HCI_OCF_READ_COUNTRY_CODE		0x0007
d1457 3
a1459 3
	u_int8_t	status;       /* 0x00 - success */
	u_int8_t	country_code; /* 0x00 - NAM, EUR, JP; 0x01 - France */
} __attribute__ ((packed)) ng_hci_read_country_code_rp;
d1461 3
a1463 1
#define NG_HCI_OCF_READ_BDADDR			0x0009
d1465 1
a1465 1
	u_int8_t	status; /* 0x00 - success */
d1467 1
a1467 1
} __attribute__ ((packed)) ng_hci_read_bdaddr_rp;
d1471 1
a1471 1
 **            Status commands and return parameters 
d1475 1
a1475 1
#define NG_HCI_OGF_STATUS			0x05 /* OpCode Group Field */
d1477 2
a1478 1
#define NG_HCI_OCF_READ_FAILED_CONTACT_CNTR	0x0001
d1480 2
a1481 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_failed_contact_cntr_cp;
d1484 4
a1487 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	counter;    /* number of consecutive failed contacts */
} __attribute__ ((packed)) ng_hci_read_failed_contact_cntr_rp;
d1489 2
a1490 1
#define NG_HCI_OCF_RESET_FAILED_CONTACT_CNTR	0x0002
d1492 2
a1493 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_reset_failed_contact_cntr_cp;
d1496 3
a1498 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_reset_failed_contact_cntr_rp;
d1500 2
a1501 1
#define NG_HCI_OCF_GET_LINK_QUALITY		0x0003
d1503 2
a1504 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_get_link_quality_cp;
d1507 4
a1510 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	quality;    /* higher value means better quality */
} __attribute__ ((packed)) ng_hci_get_link_quality_rp;
d1512 2
a1513 1
#define NG_HCI_OCF_READ_RSSI			0x0005
d1515 2
a1516 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_read_rssi_cp;
d1519 2
a1520 2
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
d1522 29
a1550 1
} __attribute__ ((packed)) ng_hci_read_rssi_rp;
d1554 1
a1554 1
 **             Testing commands and return parameters 
d1558 1
a1558 1
#define NG_HCI_OGF_TESTING			0x06 /* OpCode Group Field */
d1560 2
a1561 1
#define NG_HCI_OCF_READ_LOOPBACK_MODE		0x0001
d1564 3
a1566 3
	u_int8_t	status; /* 0x00 - success */
	u_int8_t	lbmode; /* loopback mode */
} __attribute__ ((packed)) ng_hci_read_loopback_mode_rp;
d1568 2
a1569 1
#define NG_HCI_OCF_WRITE_LOOPBACK_MODE		0x0002
d1571 2
a1572 2
	u_int8_t	lbmode; /* loopback mode */
} __attribute__ ((packed)) ng_hci_write_loopback_mode_cp;
d1574 1
a1574 1
typedef ng_hci_status_rp	ng_hci_write_loopback_mode_rp;
d1576 2
a1577 1
#define NG_HCI_OCF_ENABLE_UNIT_UNDER_TEST	0x0003
d1579 1
a1579 1
typedef ng_hci_status_rp	ng_hci_enable_unit_under_test_rp;
d1583 2
a1584 1
 **                Special HCI OpCode group field values
d1588 10
a1597 1
#define NG_HCI_OGF_BT_LOGO			0x3e	
a1598 1
#define NG_HCI_OGF_VENDOR			0x3f
d1606 1
a1606 1
#define NG_HCI_EVENT_INQUIRY_COMPL		0x01
d1608 2
a1609 2
	u_int8_t	status; /* 0x00 - success */
} __attribute__ ((packed)) ng_hci_inquiry_compl_ep;
d1611 1
a1611 1
#define NG_HCI_EVENT_INQUIRY_RESULT		0x02
d1613 3
a1615 3
	u_int8_t	num_responses;      /* number of responses */
/*	ng_hci_inquiry_response[num_responses]   -- see below */
} __attribute__ ((packed)) ng_hci_inquiry_result_ep;
d1619 6
a1624 6
	u_int8_t	page_scan_rep_mode;       /* page scan rep. mode */
	u_int8_t	page_scan_period_mode;    /* page scan period mode */
	u_int8_t	page_scan_mode;           /* page scan mode */
	u_int8_t	uclass[NG_HCI_CLASS_SIZE]; /* unit class */
	u_int16_t	clock_offset;             /* clock offset */
} __attribute__ ((packed)) ng_hci_inquiry_response;
d1626 1
a1626 1
#define NG_HCI_EVENT_CON_COMPL			0x03
d1628 2
a1629 2
	u_int8_t	status;          /* 0x00 - success */
	u_int16_t	con_handle;      /* Connection handle */
d1631 3
a1633 3
	u_int8_t	link_type;       /* Link type */
	u_int8_t	encryption_mode; /* Encryption mode */
} __attribute__ ((packed)) ng_hci_con_compl_ep;
d1635 1
a1635 1
#define NG_HCI_EVENT_CON_REQ			0x04
d1637 4
a1640 4
	bdaddr_t	bdaddr;                    /* remote unit address */
	u_int8_t	uclass[NG_HCI_CLASS_SIZE]; /* remote unit class */
	u_int8_t	link_type;                 /* link type */
} __attribute__ ((packed)) ng_hci_con_req_ep;
d1642 1
a1642 1
#define NG_HCI_EVENT_DISCON_COMPL		0x05
d1644 4
a1647 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	reason;     /* reason to disconnect */
} __attribute__ ((packed)) ng_hci_discon_compl_ep;
d1649 1
a1649 1
#define NG_HCI_EVENT_AUTH_COMPL			0x06
d1651 3
a1653 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_auth_compl_ep;
d1655 1
a1655 1
#define NG_HCI_EVENT_REMOTE_NAME_REQ_COMPL	0x7
d1657 4
a1660 4
	u_int8_t	status; /* 0x00 - success */
	bdaddr_t	bdaddr; /* remote unit address */
	char		name[NG_HCI_UNIT_NAME_SIZE]; /* remote unit name */
} __attribute__ ((packed)) ng_hci_remote_name_req_compl_ep;
d1662 1
a1662 1
#define NG_HCI_EVENT_ENCRYPTION_CHANGE		0x08
d1664 4
a1667 4
	u_int8_t	status;            /* 0x00 - success */
	u_int16_t	con_handle;        /* Connection handle */
	u_int8_t	encryption_enable; /* 0x00 - disable */
} __attribute__ ((packed)) ng_hci_encryption_change_ep;
d1669 1
a1669 1
#define NG_HCI_EVENT_CHANGE_CON_LINK_KEY_COMPL	0x09
d1671 3
a1673 3
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* Connection handle */
} __attribute__ ((packed)) ng_hci_change_con_link_key_compl_ep;
d1675 1
a1675 1
#define NG_HCI_EVENT_MASTER_LINK_KEY_COMPL	0x0a
d1677 4
a1680 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* Connection handle */
	u_int8_t	key_flag;   /* Key flag */
} __attribute__ ((packed)) ng_hci_master_link_key_compl_ep;
d1682 1
a1682 1
#define NG_HCI_EVENT_READ_REMOTE_FEATURES_COMPL	0x0b
d1684 4
a1687 4
	u_int8_t	status;                         /* 0x00 - success */
	u_int16_t	con_handle;                     /* Connection handle */
	u_int8_t	features[NG_HCI_FEATURES_SIZE]; /* LMP features bitmsk*/
} __attribute__ ((packed)) ng_hci_read_remote_features_compl_ep;
d1689 1
a1689 1
#define NG_HCI_EVENT_READ_REMOTE_VER_INFO_COMPL	0x0c
d1691 6
a1696 6
	u_int8_t	status;         /* 0x00 - success */
	u_int16_t	con_handle;     /* Connection handle */
	u_int8_t	lmp_version;    /* LMP version */
	u_int16_t	manufacturer;   /* Hardware manufacturer name */
	u_int16_t	lmp_subversion; /* LMP sub-version */
} __attribute__ ((packed)) ng_hci_read_remote_ver_info_compl_ep;
d1698 1
a1698 1
#define NG_HCI_EVENT_QOS_SETUP_COMPL		0x0d
d1700 9
a1708 9
	u_int8_t	status;          /* 0x00 - success */
	u_int16_t	con_handle;      /* connection handle */
	u_int8_t	flags;           /* reserved for future use */
	u_int8_t	service_type;    /* service type */
	u_int32_t	token_rate;      /* bytes per second */
	u_int32_t	peak_bandwidth;  /* bytes per second */
	u_int32_t	latency;         /* microseconds */
	u_int32_t	delay_variation; /* microseconds */
} __attribute__ ((packed)) ng_hci_qos_setup_compl_ep;
d1710 1
a1710 1
#define NG_HCI_EVENT_COMMAND_COMPL		0x0e
d1712 2
a1713 2
	u_int8_t	num_cmd_pkts; /* # of HCI command packets */
	u_int16_t	opcode;       /* command OpCode */
d1715 1
a1715 1
} __attribute__ ((packed)) ng_hci_command_compl_ep;
d1717 1
a1717 1
#define NG_HCI_EVENT_COMMAND_STATUS		0x0f
d1719 4
a1722 4
	u_int8_t	status;       /* 0x00 - pending */
	u_int8_t	num_cmd_pkts; /* # of HCI command packets */
	u_int16_t	opcode;       /* command OpCode */
} __attribute__ ((packed)) ng_hci_command_status_ep;
d1724 1
a1724 1
#define NG_HCI_EVENT_HARDWARE_ERROR		0x10
d1726 2
a1727 2
	u_int8_t	hardware_code; /* hardware error code */
} __attribute__ ((packed)) ng_hci_hardware_error_ep;
d1729 1
a1729 1
#define NG_HCI_EVENT_FLUSH_OCCUR		0x11
d1731 2
a1732 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_flush_occur_ep;
d1734 1
a1734 1
#define NG_HCI_EVENT_ROLE_CHANGE		0x12
d1736 1
a1736 1
	u_int8_t	status; /* 0x00 - success */
d1738 2
a1739 2
	u_int8_t	role;   /* new connection role */
} __attribute__ ((packed)) ng_hci_role_change_ep;
d1741 1
a1741 1
#define NG_HCI_EVENT_NUM_COMPL_PKTS		0x13
d1743 13
a1755 5
	u_int8_t	num_con_handles; /* # of connection handles */
/* these are repeated "num_con_handles" times 
	u_int16_t	con_handle; --- connection handle(s)
	u_int16_t	compl_pkt;  --- # of completed packets */
} __attribute__ ((packed)) ng_hci_num_compl_pkts_ep;
d1757 1
a1757 1
#define NG_HCI_EVENT_MODE_CHANGE		0x14
d1759 2
a1760 10
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int8_t	unit_mode;  /* remote unit mode */
	u_int16_t	interval;   /* interval * 0.625 msec */
} __attribute__ ((packed)) ng_hci_mode_change_ep;

#define NG_HCI_EVENT_RETURN_LINK_KEYS		0x15
typedef struct {
	u_int8_t	num_keys; /* # of keys */
/* these are repeated "num_keys" times 
d1762 2
a1763 2
	u_int8_t	key[NG_HCI_KEY_SIZE]; --- key(s) */
} __attribute__ ((packed)) ng_hci_return_link_keys_ep;
d1765 1
a1765 1
#define NG_HCI_EVENT_PIN_CODE_REQ		0x16
d1768 1
a1768 1
} __attribute__ ((packed)) ng_hci_pin_code_req_ep;
d1770 1
a1770 1
#define NG_HCI_EVENT_LINK_KEY_REQ		0x17
d1773 1
a1773 1
} __attribute__ ((packed)) ng_hci_link_key_req_ep;
d1775 1
a1775 1
#define NG_HCI_EVENT_LINK_KEY_NOTIFICATION	0x18
d1777 4
a1780 4
	bdaddr_t	bdaddr;               /* remote unit address */
	u_int8_t	key[NG_HCI_KEY_SIZE]; /* link key */
	u_int8_t	key_type;             /* type of the key */
} __attribute__ ((packed)) ng_hci_link_key_notification_ep;
d1782 2
a1783 4
#define NG_HCI_EVENT_LOOPBACK_COMMAND		0x19
typedef struct {
	u_int8_t	command[0]; /* Command packet */
} __attribute__ ((packed)) ng_hci_loopback_command_ep;
d1785 1
a1785 1
#define NG_HCI_EVENT_DATA_BUFFER_OVERFLOW	0x1a
d1787 2
a1788 2
	u_int8_t	link_type; /* Link type */
} __attribute__ ((packed)) ng_hci_data_buffer_overflow_ep;
d1790 1
a1790 1
#define NG_HCI_EVENT_MAX_SLOT_CHANGE		0x1b
d1792 3
a1794 3
	u_int16_t	con_handle;    /* connection handle */
	u_int8_t	lmp_max_slots; /* Max. # of slots allowed */
} __attribute__ ((packed)) ng_hci_max_slot_change_ep;
d1796 1
a1796 1
#define NG_HCI_EVENT_READ_CLOCK_OFFSET_COMPL	0x1c
d1798 4
a1801 4
	u_int8_t	status;       /* 0x00 - success */
	u_int16_t	con_handle;   /* Connection handle */
	u_int16_t	clock_offset; /* Clock offset */
} __attribute__ ((packed)) ng_hci_read_clock_offset_compl_ep;
d1803 1
a1803 1
#define NG_HCI_EVENT_CON_PKT_TYPE_CHANGED	0x1d
d1805 4
a1808 4
	u_int8_t	status;     /* 0x00 - success */
	u_int16_t	con_handle; /* connection handle */
	u_int16_t	pkt_type;   /* packet type */
} __attribute__ ((packed)) ng_hci_con_pkt_type_changed_ep;
d1810 1
a1810 1
#define NG_HCI_EVENT_QOS_VIOLATION		0x1e
d1812 2
a1813 2
	u_int16_t	con_handle; /* connection handle */
} __attribute__ ((packed)) ng_hci_qos_violation_ep;
d1815 2
a1816 1
#define NG_HCI_EVENT_PAGE_SCAN_MODE_CHANGE	0x1f
d1819 2
a1820 2
	u_int8_t	page_scan_mode; /* page scan mode */
} __attribute__ ((packed)) ng_hci_page_scan_mode_change_ep;
d1822 1
a1822 1
#define NG_HCI_EVENT_PAGE_SCAN_REP_MODE_CHANGE	0x20
d1825 353
a2177 2
	u_int8_t	page_scan_rep_mode; /* page scan repetition mode */
} __attribute__ ((packed)) ng_hci_page_scan_rep_mode_change_ep;
d2179 45
a2223 1
#define NG_HCI_EVENT_BT_LOGO			0xfe
d2225 1
a2225 1
#define NG_HCI_EVENT_VENDOR			0xff
d2227 1
a2227 1
#endif /* ndef _NETGRAPH_HCI_H_ */
@


1.2
log
@cleanup rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD: hci.h,v 1.1 2005/01/14 12:04:02 grange Exp $	*/
d1448 1
a1448 1
	u_int8_t	class[NG_HCI_CLASS_SIZE]; /* unit class */
@


1.1
log
@First step in Bluetooth protocol stack support.

The code is adopted from the FreeBSD netgraph-based Bluetooth
implementation by Maksim Yevmenkin <m_evmenkin@@yahoo.com> but
all netgraph glue was replaced with usual BSD network stack
hooks. This is a work in progress. Only HCI layer works for now,
L2CAP and RFCOMM are on the way.

Help in testing from many, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a29 1
 * $Id: ng_hci.h,v 1.2 2003/03/18 00:09:37 max Exp $
@

