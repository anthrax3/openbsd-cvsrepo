head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.24
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.20
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.6.0.18
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.16
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.14
	OPENBSD_5_0:1.6.0.12
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.10
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.2
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.3.0.2
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.2.0.8
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.6
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.4
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.2
	OPENBSD_3_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.6;
commitid	0n9cIGBISFAEt4b1;

1.6
date	2008.11.22.04.42.58;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.24.21.34.48;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.30.03.42.53;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.12.01.07.18.34;	author camield;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.17.18.12.49;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.14.12.04.02;	author grange;	state Exp;
branches;
next	;


desc
@@


1.7
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: bluetooth.h,v 1.6 2008/11/22 04:42:58 uwe Exp $	*/
/*	$NetBSD: bluetooth.h,v 1.8 2008/09/08 23:36:55 gmcgarry Exp $	*/

/*-
 * Copyright (c) 2005 Iain Hibbert.
 * Copyright (c) 2006 Itronix Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of Itronix Inc. may not be used to endorse
 *    or promote products derived from this software without specific
 *    prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY ITRONIX INC. ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL ITRONIX INC. BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _NETBT_BLUETOOTH_H_
#define _NETBT_BLUETOOTH_H_

#include <sys/socket.h>
#include <sys/types.h>

/*
 * Bluetooth Address Family Protocol Numbers
 */
#define BTPROTO_HCI	1
#define BTPROTO_L2CAP	2
#define BTPROTO_RFCOMM	3
#define BTPROTO_SCO	4

/* All sizes are in bytes */
#define BLUETOOTH_BDADDR_SIZE	6

/*
 * Bluetooth device address
 */
typedef struct {
	uint8_t	b[BLUETOOTH_BDADDR_SIZE];
} __packed bdaddr_t;

/*
 * bdaddr utility functions
 */
static __inline int
bdaddr_same(const bdaddr_t *a, const bdaddr_t *b)
{

	return (a->b[0] == b->b[0] && a->b[1] == b->b[1]
		&& a->b[2] == b->b[2] && a->b[3] == b->b[3]
		&& a->b[4] == b->b[4] && a->b[5] == b->b[5]);
}

static __inline int
bdaddr_any(const bdaddr_t *a)
{

	return (a->b[0] == 0 && a->b[1] == 0 && a->b[2] == 0
		&& a->b[3] == 0 && a->b[4] == 0 && a->b[5] == 0);
}

static __inline void
bdaddr_copy(bdaddr_t *d, const bdaddr_t *s)
{

	d->b[0] = s->b[0];
	d->b[1] = s->b[1];
	d->b[2] = s->b[2];
	d->b[3] = s->b[3];
	d->b[4] = s->b[4];
	d->b[5] = s->b[5];
}

/*
 * Socket address used by Bluetooth protocols
 */
struct sockaddr_bt {
	uint8_t		bt_len;
	sa_family_t	bt_family;
	bdaddr_t	bt_bdaddr;
	uint16_t	bt_psm;
	uint8_t		bt_channel;
	uint8_t		bt_zero[5];
};

/* Note: this is actually 6 bytes including terminator */
#define BDADDR_ANY	((const bdaddr_t *) "\000\000\000\000\000")

#ifdef _KERNEL

/*
 * Bluetooth Protocol API callback methods
 */
struct mbuf;
struct btproto {
	void (*connecting)(void *);
	void (*connected)(void *);
	void (*disconnected)(void *, int);
	void *(*newconn)(void *, struct sockaddr_bt *, struct sockaddr_bt *);
	void (*complete)(void *, int);
	void (*linkmode)(void *, int);
	void (*input)(void *, struct mbuf *);
};

/*
 * Debugging stuff
 */

#define BLUETOOTH_DEBUG
#ifdef BLUETOOTH_DEBUG
extern int bluetooth_debug;
# define DPRINTF(fmt, args...)	do {			\
	if (bluetooth_debug)				\
		printf("%s: "fmt, __func__ , ##args);	\
} while (/* CONSTCOND */0)

# define DPRINTFN(n, fmt, args...)	do {		\
	if (bluetooth_debug > (n))			\
		printf("%s: "fmt, __func__ , ##args);	\
} while (/* CONSTCOND */0)

# define UNKNOWN(value)			\
		printf("%s: %s = %d unknown!\n", __func__, #value, (value));
#else
# define DPRINTF(...) ((void)0)
# define DPRINTFN(...) ((void)0)
# define UNKNOWN(x) ((void)0)
#endif	/* BLUETOOTH_DEBUG */

extern struct mutex bt_lock;

/* XXX NetBSD compatibility goo, abused for debugging */
#ifdef BLUETOOTH_DEBUG
#define mutex_enter(mtx) do {						\
	DPRINTFN(1, "mtx_enter(" __STRING(mtx) ") in %d\n",		\
	    curproc ? curproc->p_pid : 0);				\
	mtx_enter((mtx));						\
} while (/*CONSTCOND*/0)
#define mutex_exit(mtx) do {						\
	DPRINTFN(1, "mtx_leave(" __STRING(mtx) ") in %d\n",		\
	    curproc ? curproc->p_pid : 0);				\
	mtx_leave((mtx));						\
} while (/*CONSTCOND*/0)
#else
#define mutex_enter		mtx_enter
#define mutex_exit		mtx_leave
#endif

#endif	/* _KERNEL */

#endif	/* _NETBT_BLUETOOTH_H_ */
@


1.6
log
@Sync bluetooth with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: bluetooth.h,v 1.5 2008/02/24 21:34:48 uwe Exp $	*/
@


1.5
log
@Sync sys/netbt with NetBSD
ok deraadt@@
@
text
@d1 2
a2 2
/*	$OpenBSD: bluetooth.h,v 1.4 2007/05/30 03:42:53 uwe Exp $	*/
/*	$NetBSD: bluetooth.h,v 1.6 2007/09/17 01:23:17 rillig Exp $	*/
d56 1
a56 1
} __attribute__ ((packed)) bdaddr_t;
d145 19
@


1.4
log
@Import parts of the NetBSD bluetooth stack; ok gwk, and grange on removal
of the existing code
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: bluetooth.h,v 1.5 2007/04/21 06:15:22 plunky Exp $	*/
d141 3
a143 3
# define DPRINTF(...)
# define DPRINTFN(...)
# define UNKNOWN(x)
@


1.3
log
@spelling: queue, not qeueue
@
text
@d1 2
a2 1
/*	$OpenBSD: bluetooth.h,v 1.2 2005/01/17 18:12:49 mickey Exp $	*/
d4 3
a6 4
/*
 * bluetooth.h
 *
 * Copyright (c) 2001-2002 Maksim Yevmenkin <m_evmenkin@@yahoo.com>
d17 3
d21 11
a31 13
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/netgraph/bluetooth/include/ng_bluetooth.h,v 1.3 2003/11/14 03:45:29 emax Exp $
d34 5
a38 2
#ifndef _NETGRAPH_BLUETOOTH_H_
#define _NETGRAPH_BLUETOOTH_H_
d41 1
a41 2
 * XXX: This file only contains redundant mbuf wrapppers and must be
 * removed later.
d43 7
d52 1
a52 1
 * XXX: dirty temporary hacks.
d54 3
a56 22
#undef KASSERT
#define KASSERT(a, b)
#undef mtx_init
#undef mtx_lock
#undef mtx_unlock
#undef mtx_assert
#undef mtx_destroy
#define mtx_init(a, b, c, d)
#define mtx_lock(a)
#define mtx_unlock(a)
#define mtx_assert(a, b)
#define mtx_destroy(a)
#define ACCEPT_LOCK()
#define SOCK_LOCK(a)

#define NG_FREE_M(m)							\
	do {								\
		if ((m)) {						\
			m_freem((m));					\
			(m) = NULL;					\
		}							\
	} while (0)
d59 1
a59 1
 * Version of the stack
d61 3
d65 4
a68 1
#define NG_BLUETOOTH_VERSION	1
d70 11
a80 4
/*
 * Declare the base of the Bluetooth sysctl hierarchy, 
 * but only if this file cares about sysctl's
 */
d82 7
a88 6
#ifdef SYSCTL_DECL
SYSCTL_DECL(_net_bluetooth);
SYSCTL_DECL(_net_bluetooth_hci);
SYSCTL_DECL(_net_bluetooth_l2cap);
SYSCTL_DECL(_net_bluetooth_rfcomm);
#endif /* SYSCTL_DECL */
d91 1
a91 2
 * Mbuf queue and useful mbufq macros. We do not use ifqueue because we
 * do not need mutex and other locking stuff
d93 8
d102 2
a103 1
struct mbuf;
d105 1
a105 9
struct ng_bt_mbufq {
	struct mbuf	*head;   /* first item in the queue */
	struct mbuf	*tail;   /* last item in the queue */
	u_int32_t	 len;    /* number of items in the queue */
	u_int32_t	 maxlen; /* maximal number of items in the queue */
	u_int32_t	 drops;	 /* number if dropped items */
};
typedef struct ng_bt_mbufq	ng_bt_mbufq_t;
typedef struct ng_bt_mbufq *	ng_bt_mbufq_p;
d107 2
a108 73
#define NG_BT_MBUFQ_INIT(q, _maxlen)			\
	do {						\
		(q)->head = NULL;			\
		(q)->tail = NULL;			\
		(q)->len = 0;				\
		(q)->maxlen = (_maxlen);		\
		(q)->drops = 0;				\
	} while (0)

#define NG_BT_MBUFQ_DESTROY(q)				\
	do {						\
		NG_BT_MBUFQ_DRAIN((q));			\
	} while (0)

#define NG_BT_MBUFQ_FIRST(q)	(q)->head

#define NG_BT_MBUFQ_LEN(q)	(q)->len

#define NG_BT_MBUFQ_FULL(q)	((q)->len >= (q)->maxlen)

#define NG_BT_MBUFQ_DROP(q)	(q)->drops ++

#define NG_BT_MBUFQ_ENQUEUE(q, i)			\
	do {						\
		(i)->m_nextpkt = NULL;			\
							\
		if ((q)->tail == NULL)			\
			(q)->head = (i);		\
		else					\
			(q)->tail->m_nextpkt = (i);	\
							\
		(q)->tail = (i);			\
		(q)->len ++;				\
	} while (0)

#define NG_BT_MBUFQ_DEQUEUE(q, i)			\
	do {						\
		(i) = (q)->head;			\
		if ((i) != NULL) {			\
			(q)->head = (q)->head->m_nextpkt; \
			if ((q)->head == NULL)		\
				(q)->tail = NULL;	\
							\
			(q)->len --;			\
			(i)->m_nextpkt = NULL;		\
		} 					\
	} while (0)

#define NG_BT_MBUFQ_PREPEND(q, i)			\
	do {						\
		(i)->m_nextpkt = (q)->head;		\
		if ((q)->tail == NULL)			\
			(q)->tail = (i);		\
							\
		(q)->head = (i);			\
		(q)->len ++;				\
	} while (0)

#define NG_BT_MBUFQ_DRAIN(q)				\
	do { 						\
        	struct mbuf	*m = NULL;		\
							\
		for (;;) { 				\
			NG_BT_MBUFQ_DEQUEUE((q), m);	\
			if (m == NULL) 			\
				break; 			\
							\
			NG_FREE_M(m);	 		\
		} 					\
	} while (0)

/* 
 * Netgraph item queue and useful itemq macros
d110 9
a118 9

struct ng_item;

struct ng_bt_itemq {
	struct ng_item	*head;   /* first item in the queue */
	struct ng_item	*tail;   /* last item in the queue */
	u_int32_t	 len;    /* number of items in the queue */
	u_int32_t	 maxlen; /* maximal number of items in the queue */
	u_int32_t	 drops;  /* number if dropped items */
a119 66
typedef struct ng_bt_itemq	ng_bt_itemq_t;
typedef struct ng_bt_itemq *	ng_bt_itemq_p;

#define NG_BT_ITEMQ_INIT(q, _maxlen)	NG_BT_MBUFQ_INIT((q), (_maxlen))

#define NG_BT_ITEMQ_DESTROY(q)				\
	do {						\
		NG_BT_ITEMQ_DRAIN((q));			\
	} while (0)

#define NG_BT_ITEMQ_FIRST(q)	NG_BT_MBUFQ_FIRST((q))

#define NG_BT_ITEMQ_LEN(q)	NG_BT_MBUFQ_LEN((q))

#define NG_BT_ITEMQ_FULL(q)	NG_BT_MBUFQ_FULL((q))

#define NG_BT_ITEMQ_DROP(q)	NG_BT_MBUFQ_DROP((q))

#define NG_BT_ITEMQ_ENQUEUE(q, i)			\
	do {						\
		(i)->el_next = NULL;			\
							\
		if ((q)->tail == NULL)			\
			(q)->head = (i);		\
		else					\
			(q)->tail->el_next = (i);	\
							\
		(q)->tail = (i);			\
		(q)->len ++;				\
	} while (0)

#define NG_BT_ITEMQ_DEQUEUE(q, i)			\
	do {						\
		(i) = (q)->head;			\
		if ((i) != NULL) {			\
			(q)->head = (q)->head->el_next;	\
			if ((q)->head == NULL)		\
				(q)->tail = NULL;	\
							\
			(q)->len --;			\
			(i)->el_next = NULL;		\
		} 					\
	} while (0)

#define NG_BT_ITEMQ_PREPEND(q, i)			\
	do {						\
		(i)->el_next = (q)->head;		\
		if ((q)->tail == NULL)			\
			(q)->tail = (i);		\
							\
		(q)->head = (i);			\
		(q)->len ++;				\
	} while (0)

#define NG_BT_ITEMQ_DRAIN(q)				\
	do { 						\
        	struct ng_item	*i = NULL;		\
							\
		for (;;) { 				\
			NG_BT_ITEMQ_DEQUEUE((q), i);	\
			if (i == NULL) 			\
				break; 			\
							\
			NG_FREE_ITEM(i); 		\
		} 					\
	} while (0)
d122 1
a122 1
 * Get Bluetooth stack sysctl globals
d125 22
a146 5
u_int32_t	bluetooth_hci_command_timeout	(void);
u_int32_t	bluetooth_hci_connect_timeout	(void);
u_int32_t	bluetooth_hci_max_neighbor_age	(void);
u_int32_t	bluetooth_l2cap_rtx_timeout	(void);
u_int32_t	bluetooth_l2cap_ertx_timeout	(void);
d148 1
a148 1
#endif /* _NETGRAPH_BLUETOOTH_H_ */
@


1.2
log
@cleanup rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD: bluetooth.h,v 1.1 2005/01/14 12:04:02 grange Exp $	*/
d86 1
a86 1
 * Mbuf qeueue and useful mbufq macros. We do not use ifqueue because we
@


1.1
log
@First step in Bluetooth protocol stack support.

The code is adopted from the FreeBSD netgraph-based Bluetooth
implementation by Maksim Yevmenkin <m_evmenkin@@yahoo.com> but
all netgraph glue was replaced with usual BSD network stack
hooks. This is a work in progress. Only HCI layer works for now,
L2CAP and RFCOMM are on the way.

Help in testing from many, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a29 1
 * $Id: ng_bluetooth.h,v 1.4 2003/04/26 22:32:34 max Exp $
@

