head	1.138;
access;
symbols
	OPENBSD_6_1_BASE:1.138
	OPENBSD_6_0:1.135.0.2
	OPENBSD_6_0_BASE:1.135
	OPENBSD_5_9:1.133.0.2
	OPENBSD_5_9_BASE:1.133
	OPENBSD_5_8:1.132.0.4
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.129.0.2
	OPENBSD_5_7_BASE:1.129
	OPENBSD_5_6:1.124.0.4
	OPENBSD_5_6_BASE:1.124
	OPENBSD_5_5:1.122.0.4
	OPENBSD_5_5_BASE:1.122
	OPENBSD_5_4:1.118.0.2
	OPENBSD_5_4_BASE:1.118
	OPENBSD_5_3:1.113.0.2
	OPENBSD_5_3_BASE:1.113
	OPENBSD_5_2:1.111.0.2
	OPENBSD_5_2_BASE:1.111
	OPENBSD_5_1_BASE:1.110
	OPENBSD_5_1:1.110.0.2
	OPENBSD_5_0:1.109.0.2
	OPENBSD_5_0_BASE:1.109
	OPENBSD_4_9:1.107.0.2
	OPENBSD_4_9_BASE:1.107
	OPENBSD_4_8:1.104.0.4
	OPENBSD_4_8_BASE:1.104
	OPENBSD_4_7:1.104.0.2
	OPENBSD_4_7_BASE:1.104
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.97.0.2
	OPENBSD_4_5_BASE:1.97
	OPENBSD_4_4:1.95.0.2
	OPENBSD_4_4_BASE:1.95
	OPENBSD_4_3:1.90.0.2
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.88.0.2
	OPENBSD_4_2_BASE:1.88
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.71.0.2
	OPENBSD_4_0_BASE:1.71
	OPENBSD_3_9:1.66.0.2
	OPENBSD_3_9_BASE:1.66
	OPENBSD_3_8:1.61.0.2
	OPENBSD_3_8_BASE:1.61
	OPENBSD_3_7:1.59.0.4
	OPENBSD_3_7_BASE:1.59
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	SMP_SYNC_A:1.58
	SMP_SYNC_B:1.58
	OPENBSD_3_5:1.58.0.2
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.56.0.2
	OPENBSD_3_4_BASE:1.56
	UBC_SYNC_A:1.53
	OPENBSD_3_3:1.52.0.2
	OPENBSD_3_3_BASE:1.52
	OPENBSD_3_2:1.51.0.2
	OPENBSD_3_2_BASE:1.51
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.51
	UBC:1.46.0.2
	UBC_BASE:1.46
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.22.0.2
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.8.0.4
	OPENBSD_2_1_BASE:1.8
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.138
date	2016.09.16.03.40.28;	author dlg;	state Exp;
branches;
next	1.137;
commitid	XxtifySQkq5J0jxx;

1.137
date	2016.09.16.03.21.16;	author dlg;	state Exp;
branches;
next	1.136;
commitid	qpxurnuozCzNjzBV;

1.136
date	2016.09.16.02.54.51;	author dlg;	state Exp;
branches;
next	1.135;
commitid	KstuxUpRI6RRN5mJ;

1.135
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.134;
commitid	wckQrShbScIX7TCE;

1.134
date	2016.03.19.12.04.16;	author natano;	state Exp;
branches;
next	1.133;
commitid	gAjwyca5TfuoJAhn;

1.133
date	2015.11.03.06.25.01;	author guenther;	state Exp;
branches;
next	1.132;
commitid	DuH9wyFuZx8EI5GV;

1.132
date	2015.05.07.08.53.33;	author mpi;	state Exp;
branches;
next	1.131;
commitid	c9ymkCbPubGplOgk;

1.131
date	2015.05.01.01.30.58;	author millert;	state Exp;
branches;
next	1.130;
commitid	QXOJtYQx3rj1zO0b;

1.130
date	2015.04.17.04.43.20;	author guenther;	state Exp;
branches;
next	1.129;
commitid	zOwbm07fp3gPB2qr;

1.129
date	2015.01.09.05.01.57;	author tedu;	state Exp;
branches;
next	1.128;
commitid	KWogeIYA2sxG3IjB;

1.128
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.127;
commitid	P6Av4XGqOi3rFasL;

1.127
date	2014.11.19.18.04.54;	author tedu;	state Exp;
branches;
next	1.126;
commitid	DhpzIJGhCsFp0uYg;

1.126
date	2014.11.17.16.49.04;	author tedu;	state Exp;
branches;
next	1.125;
commitid	SZBM03Rb4IX4kQLv;

1.125
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.124;
commitid	QKTb36RFnfteZJPE;

1.124
date	2014.04.08.18.48.41;	author beck;	state Exp;
branches;
next	1.123;

1.123
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2013.11.01.17.17.25;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2013.09.24.09.20.12;	author espie;	state Exp;
branches;
next	1.120;

1.120
date	2013.09.14.02.28.02;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2013.08.13.05.52.27;	author guenther;	state Exp;
branches;
next	1.118;

1.118
date	2013.07.05.21.28.21;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2013.06.03.15.54.48;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2013.04.06.04.38.13;	author tedu;	state Exp;
branches;
next	1.114;

1.114
date	2013.03.28.03.27.46;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2012.10.08.15.43.08;	author jsing;	state Exp;
branches;
next	1.112;

1.112
date	2012.08.23.06.12.49;	author deraadt;	state Exp;
branches;
next	1.111;

1.111
date	2012.07.11.12.39.20;	author guenther;	state Exp;
branches;
next	1.110;

1.110
date	2011.12.09.16.14.54;	author nicm;	state Exp;
branches;
next	1.109;

1.109
date	2011.04.05.14.34.16;	author thib;	state Exp;
branches;
next	1.108;

1.108
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.107;

1.107
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.106;

1.106
date	2010.09.10.16.34.09;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.104;

1.104
date	2009.12.17.16.30.45;	author beck;	state Exp;
branches;
next	1.103;

1.103
date	2009.08.12.16.42.24;	author beck;	state Exp;
branches;
next	1.102;

1.102
date	2009.08.02.16.28.40;	author beck;	state Exp;
branches;
next	1.101;

1.101
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.99;

1.99
date	2009.06.03.14.45.55;	author jj;	state Exp;
branches;
next	1.98;

1.98
date	2009.06.03.04.30.57;	author beck;	state Exp;
branches;
next	1.97;

1.97
date	2008.12.23.21.43.15;	author thib;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.01.20.33.34;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.94;

1.94
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.93;

1.93
date	2008.05.03.14.41.29;	author thib;	state Exp;
branches;
next	1.92;

1.92
date	2008.04.08.14.46.45;	author thib;	state Exp;
branches;
next	1.91;

1.91
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.90;

1.90
date	2007.12.27.13.59.12;	author thib;	state Exp;
branches;
next	1.89;

1.89
date	2007.12.12.16.24.49;	author thib;	state Exp;
branches;
next	1.88;

1.88
date	2007.06.14.20.36.34;	author otto;	state Exp;
branches;
next	1.87;

1.87
date	2007.06.01.17.29.10;	author beck;	state Exp;
branches;
next	1.86;

1.86
date	2007.05.31.18.22.25;	author thib;	state Exp;
branches;
next	1.85;

1.85
date	2007.05.30.04.27.43;	author beck;	state Exp;
branches;
next	1.84;

1.84
date	2007.05.29.16.25.07;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2007.05.29.05.28.54;	author beck;	state Exp;
branches;
next	1.82;

1.82
date	2007.05.28.21.05.20;	author thib;	state Exp;
branches;
next	1.81;

1.81
date	2007.05.26.18.42.21;	author thib;	state Exp;
branches;
next	1.80;

1.80
date	2007.05.17.23.46.28;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2007.05.05.12.03.04;	author art;	state Exp;
branches;
next	1.78;

1.78
date	2007.04.14.23.17.00;	author bluhm;	state Exp;
branches;
next	1.77;

1.77
date	2007.04.13.17.09.22;	author thib;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.21.17.29.32;	author thib;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.26.11.25.23;	author pedro;	state Exp;
branches;
next	1.73;

1.73
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2006.11.20.12.52.54;	author tom;	state Exp;
branches;
next	1.71;

1.71
date	2006.08.02.21.55.27;	author thib;	state Exp;
branches;
next	1.70;

1.70
date	2006.07.11.21.17.58;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.02.20.25.09;	author pedro;	state Exp;
branches;
next	1.68;

1.68
date	2006.05.01.21.08.44;	author pedro;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.08.11.30.16;	author pedro;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.09.12.43.17;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2005.12.04.19.04.13;	author pedro;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.21.18.16.46;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.19.16.50.47;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2005.10.18.21.18.48;	author jaredy;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.60;

1.60
date	2005.03.29.17.24.52;	author pedro;	state Exp;
branches;
next	1.59;

1.59
date	2004.07.13.21.04.29;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2004.01.09.03.01.03;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2004.01.06.04.22.59;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.05.21.27.15;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.20.03.05.42;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.01.21.13.05;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2003.02.24.02.17.22;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.16.16.54.27;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.05.00.24.36;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.15.06.22.30;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.12.17.55.57;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.12.05.18.42;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	2001.08.06.14.03.04;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.05.07.31.52;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.27.04.51.49;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.22.14.11.01;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2001.06.05.20.54.51;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.14.12.11.52;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.26.00.24.38;	author csapuntz;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.26.00.18.32;	author csapuntz;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.24.19.07.07;	author csapuntz;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.23.14.42.37;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.21.23.24.30;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.21.21.49.56;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.17.17.16.05;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.22.13.48.40;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.19.08.34.51;	author csapuntz;	state Exp;
branches;
next	1.22;

1.22
date	99.12.05.07.19.28;	author art;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	99.08.08.00.34.38;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	99.02.26.02.48.36;	author art;	state Exp;
branches;
next	1.19;

1.19
date	98.12.05.16.50.40;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	98.11.15.17.15.01;	author art;	state Exp;
branches;
next	1.17;

1.17
date	98.09.06.01.44.08;	author art;	state Exp;
branches;
next	1.16;

1.16
date	98.08.06.19.35.17;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	98.07.28.00.13.10;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.03.14.19.33.03;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	98.01.10.23.41.17;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	97.11.24.22.42.34;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.59.12;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.20.21.13;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.25.36;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	96.07.14.08.54.05;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.07.05.06.52.31;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.06.24.03.35.00;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.06.11.03.25.15;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.21.41.19;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.29.19.06.46;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.57.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.31;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.31;	author deraadt;	state Exp;
branches;
next	;

1.22.2.1
date	2001.05.14.22.45.05;	author niklas;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2001.07.04.11.00.38;	author niklas;	state Exp;
branches;
next	1.22.2.3;

1.22.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.22.2.4;

1.22.2.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.22.2.5;

1.22.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.22.2.6;

1.22.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.22.2.7;

1.22.2.7
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.22.2.8;

1.22.2.8
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.22.2.9;

1.22.2.9
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.22.2.10;

1.22.2.10
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.22.2.11;

1.22.2.11
date	2004.02.19.11.01.35;	author niklas;	state Exp;
branches;
next	;

1.46.2.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2003.05.20.04.07.34;	author tedu;	state Exp;
branches;
next	1.46.2.5;

1.46.2.5
date	2004.02.21.00.20.22;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.138
log
@move RBT_PROTOTYPE under #ifdef _KERNEL
@
text
@/*	$OpenBSD: vnode.h,v 1.137 2016/09/16 03:21:16 dlg Exp $	*/
/*	$NetBSD: vnode.h,v 1.38 1996/02/29 20:59:05 cgd Exp $	*/

/*
 * Copyright (c) 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vnode.h	8.11 (Berkeley) 11/21/94
 */

#ifndef _SYS_VNODE_H_
#define _SYS_VNODE_H_

#include <sys/buf.h>
#include <sys/types.h>
#include <sys/queue.h>
#include <sys/selinfo.h>
#include <sys/tree.h>

/*
 * The vnode is the focus of all file activity in UNIX.  There is a
 * unique vnode allocated for each active file, each current directory,
 * each mounted-on file, text file, and the root.
 */

/*
 * Vnode types.  VNON means no type.
 */
enum vtype	{ VNON, VREG, VDIR, VBLK, VCHR, VLNK, VSOCK, VFIFO, VBAD };

#define	VTYPE_NAMES \
    "VNON", "VREG", "VDIR", "VBLK", "VCHR", "VLNK", "VSOCK", "VFIFO", "VBAD"

/*
 * Vnode tag types.
 * These are for the benefit of external programs only (e.g., pstat)
 * and should NEVER be inspected by the kernel.
 *
 * Note that v_tag is actually used to tell MFS from FFS, and EXT2FS from
 * the rest, so don't believe the above comment!
 */
enum vtagtype	{
	VT_NON, VT_UFS, VT_NFS, VT_MFS, VT_MSDOSFS,
	VT_PORTAL, VT_PROCFS, VT_AFS, VT_ISOFS, VT_ADOSFS,
	VT_EXT2FS, VT_VFS, VT_NTFS, VT_UDF, VT_FUSEFS, VT_TMPFS,
};

#define	VTAG_NAMES \
    "NON", "UFS", "NFS", "MFS", "MSDOSFS",			\
    "unused", "unused", "unused", "ISOFS", "unused",		\
    "EXT2FS", "VFS", "NTFS", "UDF", "FUSEFS", "TMPFS"

/*
 * Each underlying filesystem allocates its own private area and hangs
 * it from v_data.  If non-null, this area is freed in getnewvnode().
 */
LIST_HEAD(buflists, buf);

RBT_HEAD(buf_rb_bufs, buf);

struct namecache;
RBT_HEAD(namecache_rb_cache, namecache);

struct uvm_vnode;
struct vnode {
	struct uvm_vnode *v_uvm;		/* uvm data */
	struct vops *v_op;			/* vnode operations vector */
	enum	vtype v_type;			/* vnode type */
	enum	vtagtype v_tag;			/* type of underlying data */
	u_int	v_flag;				/* vnode flags (see below) */
	u_int   v_usecount;			/* reference count of users */
	/* reference count of writers */
	u_int   v_writecount;
	/* Flags that can be read/written in interrupts */
	u_int   v_bioflag;
	u_int   v_holdcnt;			/* buffer references */
	u_int   v_id;				/* capability identifier */
	struct	mount *v_mount;			/* ptr to vfs we are in */
	TAILQ_ENTRY(vnode) v_freelist;		/* vnode freelist */
	LIST_ENTRY(vnode) v_mntvnodes;		/* vnodes for mount point */
	struct	buf_rb_bufs v_bufs_tree;	/* lookup of all bufs */
	struct	buflists v_cleanblkhd;		/* clean blocklist head */
	struct	buflists v_dirtyblkhd;		/* dirty blocklist head */
	u_int   v_numoutput;			/* num of writes in progress */
	LIST_ENTRY(vnode) v_synclist;		/* vnode with dirty buffers */
	union {
		struct mount	*vu_mountedhere;/* ptr to mounted vfs (VDIR) */
		struct socket	*vu_socket;	/* unix ipc (VSOCK) */
		struct specinfo	*vu_specinfo;	/* device (VCHR, VBLK) */
		struct fifoinfo	*vu_fifoinfo;	/* fifo (VFIFO) */
	} v_un;

	/* VFS namecache */
	struct namecache_rb_cache v_nc_tree;
	TAILQ_HEAD(, namecache) v_cache_dst;	 /* cache entries to us */

	void	*v_data;			/* private data for fs */
	struct	selinfo v_selectinfo;		/* identity of poller(s) */
};
#define	v_mountedhere	v_un.vu_mountedhere
#define	v_socket	v_un.vu_socket
#define	v_specinfo	v_un.vu_specinfo
#define	v_fifoinfo	v_un.vu_fifoinfo

/*
 * Vnode flags.
 */
#define	VROOT		0x0001	/* root of its file system */
#define	VTEXT		0x0002	/* vnode is a pure text prototype */
#define	VSYSTEM		0x0004	/* vnode being used by kernel */
#define	VISTTY		0x0008	/* vnode represents a tty */
#define	VXLOCK		0x0100	/* vnode is locked to change underlying type */
#define	VXWANT		0x0200	/* process is waiting for vnode */
#define	VCLONED		0x0400	/* vnode was cloned */
#define	VALIASED	0x0800	/* vnode has an alias */
#define	VLARVAL		0x1000	/* vnode data not yet set up by higher level */
#define	VLOCKSWORK	0x4000	/* FS supports locking discipline */
#define	VCLONE		0x8000	/* vnode is a clone */

/*
 * (v_bioflag) Flags that may be manipulated by interrupt handlers
 */
#define	VBIOWAIT	0x0001	/* waiting for output to complete */
#define VBIOONSYNCLIST	0x0002	/* Vnode is on syncer worklist */
#define VBIOONFREELIST  0x0004  /* Vnode is on a free list */

/*
 * Vnode attributes.  A field value of VNOVAL represents a field whose value
 * is unavailable (getattr) or which is not to be changed (setattr).  For
 * the timespec fields, only the tv_nsec member needs to be set to VNOVAL:
 * if tv_nsec != VNOVAL then both tv_sec and tv_nsec are valid.
 */
struct vattr {
	enum vtype	va_type;	/* vnode type (for create) */
	mode_t		va_mode;	/* files access mode and type */
	nlink_t		va_nlink;	/* number of references to file */
	uid_t		va_uid;		/* owner user id */
	gid_t		va_gid;		/* owner group id */
	long		va_fsid;	/* file system id (dev for now) */
	u_quad_t	va_fileid;	/* file id */
	u_quad_t	va_size;	/* file size in bytes */
	long		va_blocksize;	/* blocksize preferred for i/o */
	struct timespec	va_atime;	/* time of last access */
	struct timespec	va_mtime;	/* time of last modification */
	struct timespec	va_ctime;	/* time file changed */
	u_long		va_gen;		/* generation number of file */
	u_long		va_flags;	/* flags defined for file */
	dev_t		va_rdev;	/* device the special file represents */
	u_quad_t	va_bytes;	/* bytes of disk space held by file */
	u_quad_t	va_filerev;	/* file modification number */
	u_int		va_vaflags;	/* operations flags, see below */
	long		va_spare;	/* remain quad aligned */
};

/*
 * Flags for va_vaflags.
 */
#define	VA_UTIMES_NULL		0x01	/* utimes argument was NULL */
#define	VA_EXCLUSIVE		0x02	/* exclusive create request */
#define	VA_UTIMES_CHANGE	0x04	/* ctime should be updated */
/*
 * Flags for ioflag.
 */
#define	IO_UNIT		0x01		/* do I/O as atomic unit */
#define	IO_APPEND	0x02		/* append write to end */
#define	IO_SYNC		0x04		/* do I/O synchronously */
#define	IO_NODELOCKED	0x08		/* underlying node already locked */
#define	IO_NDELAY	0x10		/* FNDELAY flag set in file table */
#define	IO_NOLIMIT	0x20		/* don't enforce limits on i/o */
#define	IO_NOCACHE	0x40		/* don't cache result of this i/o */

/*
 *  Modes.  Some values same as Ixxx entries from inode.h for now.
 */
#define	VSUID	04000		/* set user id on execution */
#define	VSGID	02000		/* set group id on execution */
#define	VSVTX	01000		/* save swapped text even after use */
#define	VREAD	00400		/* read, write, execute permissions */
#define	VWRITE	00200
#define	VEXEC	00100

/*
 * Token indicating no attribute value yet assigned.
 */
#define	VNOVAL	(-1)

#ifdef _KERNEL
RBT_PROTOTYPE(buf_rb_bufs, buf, b_rbbufs, rb_buf_compare);
/*
 * Convert between vnode types and inode formats (since POSIX.1
 * defines mode word of stat structure in terms of inode formats).
 */
extern enum vtype	iftovt_tab[];
extern int		vttoif_tab[];
#define IFTOVT(mode)	(iftovt_tab[((mode) & S_IFMT) >> 12])
#define VTTOIF(indx)	(vttoif_tab[(int)(indx)])
#define MAKEIMODE(indx, mode)	(int)(VTTOIF(indx) | (mode))

/*
 * Flags to various vnode functions.
 */
#define	SKIPSYSTEM	0x0001		/* vflush: skip vnodes marked VSYSTEM */
#define	FORCECLOSE	0x0002		/* vflush: force file closeure */
#define	WRITECLOSE	0x0004		/* vflush: only close writeable files */
#define	DOCLOSE		0x0008		/* vclean: close active files */
#define	V_SAVE		0x0001		/* vinvalbuf: sync file first */
#define	V_SAVEMETA	0x0002		/* vinvalbuf: leave indirect blocks */

#define REVOKEALL	0x0001		/* vop_revoke: revoke all aliases */


TAILQ_HEAD(freelst, vnode);
extern struct freelst vnode_hold_list;	/* free vnodes referencing buffers */
extern struct freelst vnode_free_list;	/* vnode free list */

#define	VATTR_NULL(vap)	vattr_null(vap)
#define	NULLVP	((struct vnode *)NULL)
#define	VN_KNOTE(vp, b)					\
	KNOTE(&vp->v_selectinfo.si_note, (b))

/*
 * Global vnode data.
 */
extern	struct vnode *rootvnode;	/* root (i.e. "/") vnode */
extern	int initialvnodes;		/* XXX number of vnodes to start */
extern	int maxvnodes;			/* XXX number of vnodes to allocate */
extern	int syncdelay;			/* seconds to delay syncing vnodes */
extern	int rushjob;			/* # of slots syncer should run ASAP */
extern void    vhold(struct vnode *);
extern void    vdrop(struct vnode *);

/* vnode operations */
struct vops {
	int	(*vop_lock)(void *);
	int	(*vop_unlock)(void *);
	int	(*vop_islocked)(void *);
	int	(*vop_abortop)(void *);
	int	(*vop_access)(void *);
	int	(*vop_advlock)(void *);
	int	(*vop_bmap)(void *);
	int	(*vop_bwrite)(void *);
	int	(*vop_close)(void *);
	int	(*vop_create)(void *);
	int	(*vop_fsync)(void *);
	int	(*vop_getattr)(void *);
	int	(*vop_inactive)(void *);
	int	(*vop_ioctl)(void *);
	int	(*vop_link)(void *);
	int	(*vop_lookup)(void *);
	int	(*vop_mknod)(void *);
	int	(*vop_open)(void *);
	int	(*vop_pathconf)(void *);
	int	(*vop_poll)(void *);
	int	(*vop_print)(void *);
	int	(*vop_read)(void *);
	int	(*vop_readdir)(void *);
	int	(*vop_readlink)(void *);
	int	(*vop_reclaim)(void *);
	int	(*vop_remove)(void *);
	int	(*vop_rename)(void *);
	int	(*vop_revoke)(void *);
	int	(*vop_mkdir)(void *);
	int	(*vop_rmdir)(void *);
	int	(*vop_setattr)(void *);
	int	(*vop_strategy)(void *);
	int	(*vop_symlink)(void *);
	int	(*vop_write)(void *);
	int	(*vop_kqfilter)(void *);
};

extern struct vops dead_vops;
extern struct vops spec_vops;
 
struct vop_generic_args {
	void		*a_garbage;
	/* Other data probably follows; */
};

struct vop_islocked_args {
	struct vnode *a_vp;
};
int VOP_ISLOCKED(struct vnode *);

struct vop_lookup_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
};
int VOP_LOOKUP(struct vnode *, struct vnode **, struct componentname *);

struct vop_create_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
int VOP_CREATE(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_mknod_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
int VOP_MKNOD(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_open_args {
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_OPEN(struct vnode *, int, struct ucred *, struct proc *);

struct vop_close_args {
	struct vnode *a_vp;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_CLOSE(struct vnode *, int, struct ucred *, struct proc *);

struct vop_access_args {
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_ACCESS(struct vnode *, int, struct ucred *, struct proc *);

struct vop_getattr_args {
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_setattr_args {
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_read_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
int VOP_READ(struct vnode *, struct uio *, int, struct ucred *);

struct vop_write_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);

struct vop_ioctl_args {
	struct vnode *a_vp;
	u_long a_command;
	void *a_data;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_IOCTL(struct vnode *, u_long, void *, int, struct ucred *, 
    struct proc *);

struct vop_poll_args {
	struct vnode *a_vp;
	int a_fflag;
	int a_events;
	struct proc *a_p;
};
int VOP_POLL(struct vnode *, int, int, struct proc *);

struct vop_kqfilter_args {
	struct vnode *a_vp;
	struct knote *a_kn;
};
int VOP_KQFILTER(struct vnode *, struct knote *);

struct vop_revoke_args {
	struct vnode *a_vp;
	int a_flags;
};
int VOP_REVOKE(struct vnode *, int);

struct vop_fsync_args {
	struct vnode *a_vp;
	struct ucred *a_cred;
	int a_waitfor;
	struct proc *a_p;
};
int VOP_FSYNC(struct vnode *, struct ucred *, int, struct proc *);

struct vop_remove_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_REMOVE(struct vnode *, struct vnode *, struct componentname *);

struct vop_link_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_LINK(struct vnode *, struct vnode *, struct componentname *);

struct vop_rename_args {
	struct vnode *a_fdvp;
	struct vnode *a_fvp;
	struct componentname *a_fcnp;
	struct vnode *a_tdvp;
	struct vnode *a_tvp;
	struct componentname *a_tcnp;
};
int VOP_RENAME(struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *);

struct vop_mkdir_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
int VOP_MKDIR(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_rmdir_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_RMDIR(struct vnode *, struct vnode *, struct componentname *);

struct vop_symlink_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
	char *a_target;
};
int VOP_SYMLINK(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *, char *);

struct vop_readdir_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
	int *a_eofflag;
};
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *);

struct vop_readlink_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
};
int VOP_READLINK(struct vnode *, struct uio *, struct ucred *);

struct vop_abortop_args {
	struct vnode *a_dvp;
	struct componentname *a_cnp;
};
int VOP_ABORTOP(struct vnode *, struct componentname *);

struct vop_inactive_args {
	struct vnode *a_vp;
	struct proc *a_p;
};
int VOP_INACTIVE(struct vnode *, struct proc *);

struct vop_reclaim_args {
	struct vnode *a_vp;
	struct proc *a_p;
};
int VOP_RECLAIM(struct vnode *, struct proc *);

struct vop_lock_args {
	struct vnode *a_vp;
	int a_flags;
	struct proc *a_p;
};
int VOP_LOCK(struct vnode *, int, struct proc *);

struct vop_unlock_args {
	struct vnode *a_vp;
	struct proc *a_p;
};
int VOP_UNLOCK(struct vnode *, struct proc *);

struct vop_bmap_args {
	struct vnode *a_vp;
	daddr_t a_bn;
	struct vnode **a_vpp;
	daddr_t *a_bnp;
	int *a_runp;
};
int VOP_BMAP(struct vnode *, daddr_t, struct vnode **, daddr_t *, int *);

struct vop_print_args {
	struct vnode *a_vp;
};
int VOP_PRINT(struct vnode *);

struct vop_pathconf_args {
	struct vnode *a_vp;
	int a_name;
	register_t *a_retval;
};
int VOP_PATHCONF(struct vnode *, int, register_t *);

struct vop_advlock_args {
	struct vnode *a_vp;
	void *a_id;
	int a_op;
	struct flock *a_fl;
	int a_flags;
};
int VOP_ADVLOCK(struct vnode *, void *, int, struct flock *, int);

/* Special cases: */
struct vop_strategy_args {
	struct buf *a_bp;
};
int VOP_STRATEGY(struct buf *);

struct vop_bwrite_args {
	struct buf *a_bp;
};
int VOP_BWRITE(struct buf *);
/* End of special cases. */


/* Public vnode manipulation functions. */
struct file;
struct filedesc;
struct mount;
struct nameidata;
struct proc;
struct stat;
struct statfs;
struct ucred;
struct uio;
struct vattr;
struct vnode;

/* vfs_subr */
int	bdevvp(dev_t, struct vnode **);
int	cdevvp(dev_t, struct vnode **);
struct vnode *checkalias(struct vnode *, dev_t, struct mount *);
int	getnewvnode(enum vtagtype, struct mount *, struct vops *,
	    struct vnode **);
int	vaccess(enum vtype, mode_t, uid_t, gid_t, mode_t, struct ucred *);
void	vattr_null(struct vattr *);
void	vdevgone(int, int, int, enum vtype);
int	vcount(struct vnode *);
int	vfinddev(dev_t, enum vtype, struct vnode **);
void	vflushbuf(struct vnode *, int);
int	vflush(struct mount *, struct vnode *, int);
int	vget(struct vnode *, int, struct proc *);
void	vgone(struct vnode *);
void	vgonel(struct vnode *, struct proc *);
int	vinvalbuf(struct vnode *, int, struct ucred *, struct proc *,
	    int, int);
void	vntblinit(void);
int	vwaitforio(struct vnode *, int, char *, int);
void	vwakeup(struct vnode *);
void	vput(struct vnode *);
int	vrecycle(struct vnode *, struct proc *);
int	vrele(struct vnode *);
void	vref(struct vnode *);
void	vprint(char *, struct vnode *);
void	copy_statfs_info(struct statfs *, const struct mount *);

/* vfs_getcwd.c */
#define GETCWD_CHECK_ACCESS 0x0001
int vfs_getcwd_scandir(struct vnode **, struct vnode **, char **, char *,
    struct proc *);
int vfs_getcwd_common(struct vnode *, struct vnode *, char **, char *, int,
    int, struct proc *);
int vfs_getcwd_getcache(struct vnode **, struct vnode **, char **, char *);

/* vfs_default.c */
int	vop_generic_abortop(void *);
int	vop_generic_bmap(void *);
int	vop_generic_bwrite(void *);
int	vop_generic_islocked(void *);
int	vop_generic_lock(void *);
int	vop_generic_unlock(void *);
int	vop_generic_revoke(void *);
int	vop_generic_kqfilter(void *);
int	vop_generic_lookup(void *);

/* vfs_vnops.c */
int	vn_isunder(struct vnode *, struct vnode *, struct proc *);
int	vn_close(struct vnode *, int, struct ucred *, struct proc *);
int	vn_open(struct nameidata *, int, int);
int	vn_rdwr(enum uio_rw, struct vnode *, caddr_t, int, off_t,
	    enum uio_seg, int, struct ucred *, size_t *, struct proc *);
int	vn_stat(struct vnode *, struct stat *, struct proc *);
int	vn_statfile(struct file *, struct stat *, struct proc *);
int	vn_lock(struct vnode *, int, struct proc *);
int	vn_writechk(struct vnode *);
int	vn_fsizechk(struct vnode *, struct uio *, int, ssize_t *);
int	vn_ioctl(struct file *, u_long, caddr_t, struct proc *);
void	vn_marktext(struct vnode *);

/* vfs_sync.c */
void	sched_sync(struct proc *);
void	vn_initialize_syncerd(void);
void	vn_syncer_add_to_worklist(struct vnode *, int);

/* misc */
int	vn_isdisk(struct vnode *, int *);
int	softdep_fsync(struct vnode *);
int 	getvnode(struct proc *, int, struct file **);

/* uvm */
void	uvm_vnp_setsize(struct vnode *, off_t);
void	uvm_vnp_sync(struct mount *);
void	uvm_vnp_terminate(struct vnode *);
int	uvm_vnp_uncache(struct vnode *);


#endif /* _KERNEL */
#endif /* _SYS_VNODE_H_ */
@


1.137
log
@move the namecache_rb_tree from RB macros to RBT functions.

i had to shuffle the includes a bit. all the knowledge of the RB
tree is now inside vfs_cache.c, and all accesses are via cache_*
functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.136 2016/09/16 02:54:51 dlg Exp $	*/
a83 1
RBT_PROTOTYPE(buf_rb_bufs, buf, b_rbbufs, rb_buf_compare);
d212 1
@


1.136
log
@move buf_rb_bufs from RB macros to RBT functions

i had to shuffle the order of some header bits cos RBT_PROTOTYPE
needs to see what RBT_HEAD produces.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.135 2016/05/23 09:31:28 natano Exp $	*/
d86 2
a87 1
RB_HEAD(namecache_rb_cache, namecache);
@


1.135
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.134 2016/03/19 12:04:16 natano Exp $	*/
d83 3
a85 1
RB_HEAD(buf_rb_bufs, buf);
@


1.134
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.133 2015/11/03 06:25:01 guenther Exp $	*/
a278 1
	int	(*vop_reallocblks)(void *);
a550 6

struct vop_reallocblks_args {
	struct vnode *a_vp;
	struct cluster_save *a_buflist;
};
int VOP_REALLOCBLKS(struct vnode *, struct cluster_save *);
@


1.133
log
@Delete VBITS: it's unused and the definition is actually wrong

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.132 2015/05/07 08:53:33 mpi Exp $	*/
a518 1
	int a_flags;
d521 1
a521 1
int VOP_UNLOCK(struct vnode *, int, struct proc *);
@


1.132
log
@Pass a thread pointer instead of its file descriptor table to getvnode(9).

Input and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.131 2015/05/01 01:30:58 millert Exp $	*/
a140 2
#define	VBITS	"\010\001ROOT\002TEXT\003SYSTEM\004ISTTY\010XLOCK" \
    "\011XWANT\013ALIASED\014LARVAL\016LOCKSWORK\017CLONE"
@


1.131
log
@Pass fflag to VOP_POLL so vfs fifo functions can get at the file
flags to check FREAD/FWRITE if needed.  This will be used by fifo_poll
to avoid checking the write end of the fifo when the fd is read-only.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.130 2015/04/17 04:43:20 guenther Exp $	*/
d657 1
a657 1
int 	getvnode(struct filedesc *, int, struct file **);
@


1.130
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.129 2015/01/09 05:01:57 tedu Exp $	*/
d402 1
d406 1
a406 1
int VOP_POLL(struct vnode *, int, struct proc *);
@


1.129
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.128 2014/12/16 18:30:04 tedu Exp $	*/
d153 3
a155 1
 * is unavailable (getattr) or which is not to be changed (setattr).
d182 3
a184 2
#define	VA_UTIMES_NULL	0x01		/* utimes argument was NULL */
#define VA_EXCLUSIVE    0x02		/* exclusive create request */
@


1.128
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.127 2014/11/19 18:04:54 tedu Exp $	*/
d245 1
a245 1
extern	int desiredvnodes;		/* XXX number of vnodes desired */
@


1.127
log
@delete the KERN_VNODE sysctl. it fails to provide any isolation from the
kernel struct vnode defintion, and the only consumer (pstat) still needs
kvm to read much of the required information. no great loss to always use
kvm until there's a better replacement interface.
ok deraadt millert uebayasi
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.126 2014/11/17 16:49:04 tedu Exp $	*/
a43 3
#include <uvm/uvm_extern.h>
#include <uvm/uvm_vnode.h>

d86 1
d88 1
a88 1
	struct uvm_vnode v_uvm;			/* uvm data */
d654 7
@


1.126
log
@rearrange fields for better packing. reduces size to 256 on amd64.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.125 2014/09/08 01:47:06 guenther Exp $	*/
a208 8

/*
 * Structure returned by the KERN_VNODE sysctl
 */
struct e_vnode {
	struct vnode *vptr;
	struct vnode vnode;
};
@


1.125
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.124 2014/04/08 18:48:41 beck Exp $	*/
d93 1
a120 1
	enum	vtagtype v_tag;			/* type of underlying data */
@


1.124
log
@add IO_NOCACHE flag to vop_write arguments, which in turn sets B_NOCACHE
on the written buffers. Use the flag for writes from the page daemon to
ensure that we free buffers written out by the page daemon rather than
caching them.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.123 2014/03/28 17:57:11 mpi Exp $	*/
d77 1
a77 1
    "PORTAL", "PROCFS", "AFS", "ISOFS", "ADOSFS",		\
@


1.123
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.122 2013/11/01 17:17:25 deraadt Exp $	*/
d193 1
@


1.122
log
@there is no need to expose "struct vops" to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.121 2013/09/24 09:20:12 espie Exp $	*/
d44 1
a44 1
#include <uvm/uvm.h>
@


1.121
log
@a bit more tmpfs scaffolding (still not active, no kernel change)
reduces the actual diff needed, and allows one to build mount_tmpfs
without reinstalling the includes.

(still awaiting review on the uvm bits)

okay krw@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.120 2013/09/14 02:28:02 guenther Exp $	*/
a259 1
#endif /* _KERNEL */
a300 1
#ifdef _KERNEL
@


1.120
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.119 2013/08/13 05:52:27 guenther Exp $	*/
d72 1
a72 1
	VT_EXT2FS, VT_VFS, VT_NTFS, VT_UDF, VT_FUSEFS
d78 1
a78 1
    "EXT2FS", "VFS", "NTFS", "UDF", "FUSEFS"
@


1.119
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.118 2013/07/05 21:28:21 guenther Exp $	*/
d652 1
a652 1
int	vn_fsizechk(struct vnode *, struct uio *, int, int *);
@


1.118
log
@syncdelay is defined as int, not time_t, in kern/vfs_sync.c, and that's
Just Fine
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.117 2013/06/11 16:42:18 deraadt Exp $	*/
d164 1
a164 1
	long		va_fileid;	/* file id */
a490 2
	int *a_ncookies;
	u_long **a_cookies;
d492 1
a492 2
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, int *, 
    u_long **);
@


1.117
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.116 2013/06/03 15:54:48 tedu Exp $	*/
d256 1
a256 1
extern	time_t syncdelay;		/* time to delay syncing vnodes */
@


1.116
log
@changes for isc fuse support. not enabled. ok beck deraadt.
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.115 2013/04/06 04:38:13 tedu Exp $	*/
d538 1
a538 1
	daddr64_t a_bn;
d540 1
a540 1
	daddr64_t *a_bnp;
d543 1
a543 1
int VOP_BMAP(struct vnode *, daddr64_t, struct vnode **, daddr64_t *, int *);
@


1.115
log
@there aren't any locks in here anymore, so we don't need lock.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.114 2013/03/28 03:27:46 tedu Exp $	*/
d72 1
a72 1
	VT_EXT2FS, VT_VFS, VT_NTFS, VT_UDF,
d78 1
a78 1
    "EXT2FS", "VFS", "NTFS", "UDF"
@


1.114
log
@no need for vnode.h to include namei.h unconditionally
ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.113 2012/10/08 15:43:08 jsing Exp $	*/
a40 1
#include <sys/lock.h>
@


1.113
log
@Protect vnode.h from multiple inclusions.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.111 2012/07/11 12:39:20 guenther Exp $	*/
a41 1
#include <sys/namei.h>
@


1.112
log
@kill nnpfs dead
@
text
@d35 3
d672 1
@


1.111
log
@If the current offset is strictly less than the process filesize
rlimit, then a write that would take it over the limit should be
clamped, making it a partial write.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.110 2011/12/09 16:14:54 nicm Exp $	*/
d71 1
a71 1
	VT_EXT2FS, VT_VFS, VT_NNPFS, VT_NTFS, VT_UDF, VT_XFS = VT_NNPFS
d77 1
a77 1
    "EXT2FS", "VFS", "NNPFS", "NTFS", "UDF"
@


1.110
log
@Add new KERN_PROC_CWD sysctl to get the current working directory of a process.

ok guenther deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.109 2011/04/05 14:34:16 thib Exp $	*/
d654 1
@


1.109
log
@remove the a_desc member from the vop_*_args structures
as it's unused and unset.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.108 2011/04/05 14:14:07 thib Exp $	*/
d626 1
@


1.108
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.107 2010/12/21 20:14:43 thib Exp $	*/
a310 1
	struct vnodeop_desc *a_desc;
a315 1
	struct vnodeop_desc *a_desc;
a322 1
	struct vnodeop_desc *a_desc;
a331 1
	struct vnodeop_desc *a_desc;
a340 1
	struct vnodeop_desc *a_desc;
a348 1
	struct vnodeop_desc *a_desc;
a356 1
	struct vnodeop_desc *a_desc;
a364 1
	struct vnodeop_desc *a_desc;
a372 1
	struct vnodeop_desc *a_desc;
a380 1
	struct vnodeop_desc *a_desc;
a388 1
	struct vnodeop_desc *a_desc;
a396 1
	struct vnodeop_desc *a_desc;
a407 1
	struct vnodeop_desc *a_desc;
a414 1
	struct vnodeop_desc *a_desc;
a420 1
	struct vnodeop_desc *a_desc;
a426 1
	struct vnodeop_desc *a_desc;
a434 1
	struct vnodeop_desc *a_desc;
a441 1
	struct vnodeop_desc *a_desc;
a448 1
	struct vnodeop_desc *a_desc;
a459 1
	struct vnodeop_desc *a_desc;
a468 1
	struct vnodeop_desc *a_desc;
a475 1
	struct vnodeop_desc *a_desc;
a485 1
	struct vnodeop_desc *a_desc;
a496 1
	struct vnodeop_desc *a_desc;
a503 1
	struct vnodeop_desc *a_desc;
a509 1
	struct vnodeop_desc *a_desc;
a515 1
	struct vnodeop_desc *a_desc;
a521 1
	struct vnodeop_desc *a_desc;
a528 1
	struct vnodeop_desc *a_desc;
a535 1
	struct vnodeop_desc *a_desc;
a544 1
	struct vnodeop_desc *a_desc;
a549 1
	struct vnodeop_desc *a_desc;
a556 1
	struct vnodeop_desc *a_desc;
a565 1
	struct vnodeop_desc *a_desc;
a572 1
	struct vnodeop_desc *a_desc;
a577 1
	struct vnodeop_desc *a_desc;
@


1.107
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.106 2010/09/10 16:34:09 thib Exp $	*/
a262 1
	int	(*vop_default)(void *);
@


1.106
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.103 2009/08/12 16:42:24 beck Exp $	*/
d90 1
a90 1
	int	(**v_op)(void *);		/* vnode operations vector */
d261 295
a555 3
/*
 * Mods for exensibility.
 */
d557 5
a561 27
/*
 * Flags for vdesc_flags:
 */
#define VDESC_MAX_VPS		16
/* Low order 16 flag bits are reserved for willrele flags for vp arguments. */
#define VDESC_VP0_WILLRELE      0x00000001
#define VDESC_VP1_WILLRELE      0x00000002
#define VDESC_VP2_WILLRELE      0x00000004
#define VDESC_VP3_WILLRELE      0x00000008
#define VDESC_VP0_WILLUNLOCK    0x00000100
#define VDESC_VP1_WILLUNLOCK    0x00000200
#define VDESC_VP2_WILLUNLOCK    0x00000400
#define VDESC_VP3_WILLUNLOCK    0x00000800
#define VDESC_VP0_WILLPUT       0x00000101
#define VDESC_VP1_WILLPUT       0x00000202
#define VDESC_VP2_WILLPUT       0x00000404
#define VDESC_VP3_WILLPUT       0x00000808
#define VDESC_NOMAP_VPP         0x00010000
#define VDESC_VPP_WILLRELE      0x00020000

/*
 * This structure describes the vnode operation taking place.
 */
struct vnodeop_desc {
	int	vdesc_offset;		/* offset in vector--first for speed */
	char	*vdesc_name;		/* a readable name for debugging */
	int	vdesc_flags;		/* VDESC_* flags */
d563 1
d565 9
a573 5
#ifdef _KERNEL
/*
 * A list of all the operation descs.
 */
extern struct vnodeop_desc *vnodeop_descs[];
d575 5
d581 5
a585 6
/*
 * This structure is used to configure the new vnodeops vector.
 */
struct vnodeopv_entry_desc {
	struct vnodeop_desc *opve_op;   /* which operation this is */
	int (*opve_impl)(void *);	/* code implementing this operation */
d587 9
a595 4
struct vnodeopv_desc {
			/* ptr to the ptr to the vector where op should go */
	int (***opv_desc_vector_p)(void *);
	struct vnodeopv_entry_desc *opv_desc_ops;   /* null terminated list */
d597 1
d599 1
a599 5
/*
 * A generic structure.
 * This can be used by bypass routines to identify generic arguments.
 */
struct vop_generic_args {
d601 2
a602 1
	/* other random data follows, presumably */
d604 1
d606 6
a611 6
/*
 * VOCALL calls an op given an ops vector.  We break it out because BSD's
 * vclean changes the ops vector and then wants to call ops with the old
 * vector.
 */
#define VOCALL(OPSV,OFF,AP) (( *((OPSV)[(OFF)])) (AP))
d613 6
a618 6
/*
 * This call works for vnodes in the kernel.
 */
#define VCALL(VP,OFF,AP) VOCALL((VP)->v_op,(OFF),(AP))
#define VDESC(OP) (& __CONCAT(OP,_desc))
#define VOFFSET(OP) (VDESC(OP)->vdesc_offset)
a619 4
/*
 * Finally, include the default set of vnode operations.
 */
#include <sys/vnode_if.h>
d621 1
a621 3
/*
 * Public vnode manipulation functions.
 */
d638 1
a638 1
int	getnewvnode(enum vtagtype, struct mount *, int (**vops)(void *),
@


1.105
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.104 2009/12/17 16:30:45 beck Exp $	*/
d90 1
a90 1
	struct vops *v_op;			/* vnode operations vector */
d261 31
a291 39
/* vnode operations */
struct vops {
	int	(*vop_default)(void *);
	int	(*vop_lock)(void *);
	int	(*vop_unlock)(void *);
	int	(*vop_islocked)(void *);
	int	(*vop_abortop)(void *);
	int	(*vop_access)(void *);
	int	(*vop_advlock)(void *);
	int	(*vop_bmap)(void *);
	int	(*vop_bwrite)(void *);
	int	(*vop_close)(void *);
	int	(*vop_create)(void *);
	int	(*vop_fsync)(void *);
	int	(*vop_getattr)(void *);
	int	(*vop_inactive)(void *);
	int	(*vop_ioctl)(void *);
	int	(*vop_link)(void *);
	int	(*vop_lookup)(void *);
	int	(*vop_mknod)(void *);
	int	(*vop_open)(void *);
	int	(*vop_pathconf)(void *);
	int	(*vop_poll)(void *);
	int	(*vop_print)(void *);
	int	(*vop_read)(void *);
	int	(*vop_readdir)(void *);
	int	(*vop_readlink)(void *);
	int	(*vop_reallocblks)(void *);
	int	(*vop_reclaim)(void *);
	int	(*vop_remove)(void *);
	int	(*vop_rename)(void *);
	int	(*vop_revoke)(void *);
	int	(*vop_mkdir)(void *);
	int	(*vop_rmdir)(void *);
	int	(*vop_setattr)(void *);
	int	(*vop_strategy)(void *);
	int	(*vop_symlink)(void *);
	int	(*vop_write)(void *);
	int	(*vop_kqfilter)(void *);
d295 4
a298 7
extern struct vops dead_vops;
extern struct vops spec_vops;
 
struct vop_generic_args {
	void		*a_garbage;
	/* Other data probably follows; */
};
a299 4
struct vop_islocked_args {
	struct vnode *a_vp;
};
int VOP_ISLOCKED(struct vnode *);
d301 6
a306 4
struct vop_lookup_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
d308 4
a311 7
int VOP_LOOKUP(struct vnode *, struct vnode **, struct componentname *);

struct vop_create_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
a312 2
int VOP_CREATE(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d314 7
a320 5
struct vop_mknod_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
a321 2
int VOP_MKNOD(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d323 6
a328 7
struct vop_open_args {
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_OPEN(struct vnode *, int, struct ucred *, struct proc *);
d330 6
a335 7
struct vop_close_args {
	struct vnode *a_vp;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_CLOSE(struct vnode *, int, struct ucred *, struct proc *);
d337 4
a340 7
struct vop_access_args {
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_ACCESS(struct vnode *, int, struct ucred *, struct proc *);
d342 3
a344 221
struct vop_getattr_args {
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_setattr_args {
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_read_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
int VOP_READ(struct vnode *, struct uio *, int, struct ucred *);

struct vop_write_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);

struct vop_ioctl_args {
	struct vnode *a_vp;
	u_long a_command;
	void *a_data;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
int VOP_IOCTL(struct vnode *, u_long, void *, int, struct ucred *, 
    struct proc *);

struct vop_poll_args {
	struct vnode *a_vp;
	int a_events;
	struct proc *a_p;
};
int VOP_POLL(struct vnode *, int, struct proc *);

struct vop_kqfilter_args {
	struct vnode *a_vp;
	struct knote *a_kn;
};
int VOP_KQFILTER(struct vnode *, struct knote *);

struct vop_revoke_args {
	struct vnode *a_vp;
	int a_flags;
};
int VOP_REVOKE(struct vnode *, int);

struct vop_fsync_args {
	struct vnode *a_vp;
	struct ucred *a_cred;
	int a_waitfor;
	struct proc *a_p;
};
int VOP_FSYNC(struct vnode *, struct ucred *, int, struct proc *);

struct vop_remove_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_REMOVE(struct vnode *, struct vnode *, struct componentname *);

struct vop_link_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_LINK(struct vnode *, struct vnode *, struct componentname *);

struct vop_rename_args {
	struct vnode *a_fdvp;
	struct vnode *a_fvp;
	struct componentname *a_fcnp;
	struct vnode *a_tdvp;
	struct vnode *a_tvp;
	struct componentname *a_tcnp;
};
int VOP_RENAME(struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *);

struct vop_mkdir_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
int VOP_MKDIR(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_rmdir_args {
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
int VOP_RMDIR(struct vnode *, struct vnode *, struct componentname *);

struct vop_symlink_args {
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
	char *a_target;
};
int VOP_SYMLINK(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *, char *);

struct vop_readdir_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
	int *a_eofflag;
	int *a_ncookies;
	u_long **a_cookies;
};
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, int *, 
    u_long **);

struct vop_readlink_args {
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
};
int VOP_READLINK(struct vnode *, struct uio *, struct ucred *);

struct vop_abortop_args {
	struct vnode *a_dvp;
	struct componentname *a_cnp;
};
int VOP_ABORTOP(struct vnode *, struct componentname *);

struct vop_inactive_args {
	struct vnode *a_vp;
	struct proc *a_p;
};
int VOP_INACTIVE(struct vnode *, struct proc *);

struct vop_reclaim_args {
	struct vnode *a_vp;
	struct proc *a_p;
};
int VOP_RECLAIM(struct vnode *, struct proc *);

struct vop_lock_args {
	struct vnode *a_vp;
	int a_flags;
	struct proc *a_p;
};
int VOP_LOCK(struct vnode *, int, struct proc *);

struct vop_unlock_args {
	struct vnode *a_vp;
	int a_flags;
	struct proc *a_p;
};
int VOP_UNLOCK(struct vnode *, int, struct proc *);

struct vop_bmap_args {
	struct vnode *a_vp;
	daddr64_t a_bn;
	struct vnode **a_vpp;
	daddr64_t *a_bnp;
	int *a_runp;
};
int VOP_BMAP(struct vnode *, daddr64_t, struct vnode **, daddr64_t *, int *);

struct vop_print_args {
	struct vnode *a_vp;
};
int VOP_PRINT(struct vnode *);

struct vop_pathconf_args {
	struct vnode *a_vp;
	int a_name;
	register_t *a_retval;
};
int VOP_PATHCONF(struct vnode *, int, register_t *);

struct vop_advlock_args {
	struct vnode *a_vp;
	void *a_id;
	int a_op;
	struct flock *a_fl;
	int a_flags;
};
int VOP_ADVLOCK(struct vnode *, void *, int, struct flock *, int);

struct vop_reallocblks_args {
	struct vnode *a_vp;
	struct cluster_save *a_buflist;
};
int VOP_REALLOCBLKS(struct vnode *, struct cluster_save *);

/* Special cases: */
struct vop_strategy_args {
	struct buf *a_bp;
};
int VOP_STRATEGY(struct buf *);

struct vop_bwrite_args {
	struct buf *a_bp;
};
int VOP_BWRITE(struct buf *);
/* End of special cases. */


/* Public vnode manipulation functions. */
d361 1
a361 1
int	getnewvnode(enum vtagtype, struct mount *, struct vops *,
@


1.104
log
@This fixes a case where we could panic on a null deref with a bad vnode
in nfs_inactive, on a reboot.

The core of the problem was in nfs_nget, when we lose the race to put a new
nfsnode in the tree, we have previously allocated a vnode, which getnewvnode
has done an insmntque into the nfs mp's mntlist. The problem being we then
try again with a new vnode, abandoning this one on the mntlist, leaving
junk there for us to die on when we unmount.

This introduces VLARVAL - so we can indicate in a vnode that the higher
level stuff hiding in v_data is incompletely set up. This flag is then
used by nfs to deal with a halfway set up vnode and release it correctly.

analysis and bogus fix by art@@, correct fix by me after serveral failed
attempts and much painful testing by krw@@, good suggestions by tedu and miod

ok krw@@ oga@@ thib@@ blambert@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.103 2009/08/12 16:42:24 beck Exp $	*/
d90 1
a90 1
	int	(**v_op)(void *);		/* vnode operations vector */
d261 267
a527 3
/*
 * Mods for exensibility.
 */
d529 4
a532 27
/*
 * Flags for vdesc_flags:
 */
#define VDESC_MAX_VPS		16
/* Low order 16 flag bits are reserved for willrele flags for vp arguments. */
#define VDESC_VP0_WILLRELE      0x00000001
#define VDESC_VP1_WILLRELE      0x00000002
#define VDESC_VP2_WILLRELE      0x00000004
#define VDESC_VP3_WILLRELE      0x00000008
#define VDESC_VP0_WILLUNLOCK    0x00000100
#define VDESC_VP1_WILLUNLOCK    0x00000200
#define VDESC_VP2_WILLUNLOCK    0x00000400
#define VDESC_VP3_WILLUNLOCK    0x00000800
#define VDESC_VP0_WILLPUT       0x00000101
#define VDESC_VP1_WILLPUT       0x00000202
#define VDESC_VP2_WILLPUT       0x00000404
#define VDESC_VP3_WILLPUT       0x00000808
#define VDESC_NOMAP_VPP         0x00010000
#define VDESC_VPP_WILLRELE      0x00020000

/*
 * This structure describes the vnode operation taking place.
 */
struct vnodeop_desc {
	int	vdesc_offset;		/* offset in vector--first for speed */
	char	*vdesc_name;		/* a readable name for debugging */
	int	vdesc_flags;		/* VDESC_* flags */
d534 1
d536 8
a543 5
#ifdef _KERNEL
/*
 * A list of all the operation descs.
 */
extern struct vnodeop_desc *vnodeop_descs[];
d545 4
d550 4
a553 6
/*
 * This structure is used to configure the new vnodeops vector.
 */
struct vnodeopv_entry_desc {
	struct vnodeop_desc *opve_op;   /* which operation this is */
	int (*opve_impl)(void *);	/* code implementing this operation */
d555 8
a562 4
struct vnodeopv_desc {
			/* ptr to the ptr to the vector where op should go */
	int (***opv_desc_vector_p)(void *);
	struct vnodeopv_entry_desc *opv_desc_ops;   /* null terminated list */
d564 1
d566 3
a568 7
/*
 * A generic structure.
 * This can be used by bypass routines to identify generic arguments.
 */
struct vop_generic_args {
	struct vnodeop_desc *a_desc;
	/* other random data follows, presumably */
d570 1
d572 5
a576 6
/*
 * VOCALL calls an op given an ops vector.  We break it out because BSD's
 * vclean changes the ops vector and then wants to call ops with the old
 * vector.
 */
#define VOCALL(OPSV,OFF,AP) (( *((OPSV)[(OFF)])) (AP))
d578 5
a582 6
/*
 * This call works for vnodes in the kernel.
 */
#define VCALL(VP,OFF,AP) VOCALL((VP)->v_op,(OFF),(AP))
#define VDESC(OP) (& __CONCAT(OP,_desc))
#define VOFFSET(OP) (VDESC(OP)->vdesc_offset)
a583 4
/*
 * Finally, include the default set of vnode operations.
 */
#include <sys/vnode_if.h>
d585 1
a585 3
/*
 * Public vnode manipulation functions.
 */
d602 1
a602 1
int	getnewvnode(enum vtagtype, struct mount *, int (**vops)(void *),
@


1.103
log
@Namecache revamp.

This eliminates the large single namecache hash table, and implements
the name cache as a global lru of entires, and a redblack tree in each
vnode. It makes cache_purge actually purge the namecache entries associated
with a vnode when a vnode is recycled (very important for later on actually being
able to resize the vnode pool)

This commit does #if 0 out a bunch of procmap code that was
already broken before this change, but needs to be redone completely.

Tested by many, including in thib's nfs test setup.

ok oga@@,art@@,thib@@,miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.102 2009/08/02 16:28:40 beck Exp $	*/
d139 1
d143 1
a143 1
    "\011XWANT\013ALIASED\016LOCKSWORK\017CLONE"
@


1.102
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.101 2009/07/09 22:29:56 thib Exp $	*/
d39 1
d86 1
d115 4
d256 2
a258 1

@


1.101
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.99 2009/06/03 14:45:55 jj Exp $	*/
d35 1
d40 1
d84 2
d101 1
@


1.100
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@a232 1
#define	VREF(vp)	vref(vp)		/* increase reference */
@


1.99
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.98 2009/06/03 04:30:57 beck Exp $	*/
a34 1
#include <sys/buf.h>
a38 1
#include <sys/tree.h>
a81 2
RB_HEAD(buf_rb_bufs, buf);

a96 1
	struct	buf_rb_bufs v_bufs_tree;	/* lookup of all bufs */
@


1.98
log
@Change bufhash from the old grotty hash table to red-black trees hanging
off the vnode.
ok art@@, oga@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.97 2008/12/23 21:43:15 thib Exp $	*/
d70 1
a70 1
	VT_EXT2FS, VT_VFS, VT_XFS, VT_NTFS, VT_UDF
d76 1
a76 1
    "EXT2FS", "VFS", "XFS", "NTFS", "UDF"
@


1.97
log
@Fix up a comment. Flags are for va_vaflags not va_cflags
(that doesnt exist).

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.96 2008/11/01 20:33:34 deraadt Exp $	*/
d35 1
d40 1
d84 2
d101 1
@


1.96
log
@change vrele() to return an int.  if it returns 0, it can gaurantee that
it did not sleep.  this is used to avoid checkdirs() to avoid having
to restart the allproc walk every time through
idea from tedu, ok thib pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.95 2008/06/09 23:38:37 millert Exp $	*/
d167 1
a167 1
 * Flags for va_cflags.
@


1.95
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.94 2008/05/08 17:45:45 thib Exp $	*/
d368 1
a368 1
void	vrele(struct vnode *);
@


1.94
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.93 2008/05/03 14:41:29 thib Exp $	*/
d351 1
a351 1
int	vaccess(mode_t, uid_t, gid_t, mode_t, struct ucred *);
@


1.93
log
@Introduce vop_generic_bmap(); use it where applicable.
one thing of note, fifofs changes in that its bmap now
sets the runp too 0, but that was an oversight in the
old code.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.92 2008/04/08 14:46:45 thib Exp $	*/
a300 5

/*
 * A default routine which just returns an error.
 */
int vn_default_error(void *);
@


1.92
log
@bring cloning up too date; Munge it so it will work with atleast
oga@@'s upcoming DRM changes and too some degree ratchov@@'s audio
work. It still works for bpf's though.

Parts from ratchov@@; fstat(1) parts from Pedro Martelletto;
tested by many, ok'ed by a few;
"get going with cloning" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.91 2008/03/16 19:42:57 otto Exp $	*/
d387 1
@


1.91
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.90 2007/12/27 13:59:12 thib Exp $	*/
d129 1
d131 1
a131 1
    "\011XWANT\013ALIASED\016LOCKSWORK"
@


1.90
log
@fifofs, deadfs and specfs all have the same "trivial lookup routine that
always fails". Introduce vop_generic_lookup(), which is a trivial lookup
routine that always fails and use that instead, zap the redundant copies.

ok toby@@, tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.89 2007/12/12 16:24:49 thib Exp $	*/
d343 1
d375 1
@


1.89
log
@Garbage collect a few members of the vnodeop_desc structure,
they where used to keep "offsets" of arguments too the VOP's
for use by bypass routines, these have been unused now for
quite some time;

Tested on sparc64/amd64 (shaves about 1k of GENERIC).

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.88 2007/06/14 20:36:34 otto Exp $	*/
d390 1
@


1.88
log
@Forgotten hackton diff: bounds check for seek on special devices
with a disklabel.  Original diff from pedro@@; ok pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.87 2007/06/01 17:29:10 beck Exp $	*/
a272 6
 * VDESC_NO_OFFSET is used to identify the end of the offset list
 * and in places where no such field exists.
 */
#define VDESC_NO_OFFSET -1

/*
d277 1
a277 1
	char    *vdesc_name;		/* a readable name for debugging */
a278 18

	/*
	 * These ops are used by bypass routines to map and locate arguments.
	 * Creds and procs are not needed in bypass routines, but sometimes
	 * they are useful to (for example) transport layers.
	 * Nameidata is useful because it has a cred in it.
	 */
	int	*vdesc_vp_offsets;	/* list ended by VDESC_NO_OFFSET */
	int	vdesc_vpp_offset;	/* return vpp location */
	int	vdesc_cred_offset;	/* cred location, if any */
	int	vdesc_proc_offset;	/* proc location, if any */
	int	vdesc_componentname_offset; /* if any */
	/*
	 * Finally, we've got a list of private data (about each operation)
	 * for each transport layer.  (Support to manage this list is not
	 * yet part of BSD.)
	 */
	caddr_t	*vdesc_transports;
a285 15


/*
 * This macro is very helpful in defining those offsets in the vdesc struct.
 *
 * This is stolen from X11R4.  I ingored all the fancy stuff for
 * Crays, so if you decide to port this to such a serious machine,
 * you might want to consult Intrisics.h's XtOffset{,Of,To}.
 */
#define VOPARG_OFFSET(p_type,field) \
	((int) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
#define VOPARG_OFFSETOF(s_type,field) \
	VOPARG_OFFSET(s_type*,field)
#define VOPARG_OFFSETTO(S_TYPE,S_OFFSET,STRUCT_P) \
	((S_TYPE)(((char *)(STRUCT_P))+(S_OFFSET)))
@


1.87
log
@decouple the allocated number of vnodes from the "desiredvnodes" variable
which is used to size a zillion other things that increasing excessively
has been shown to cause problems - so that we may incrementally look at
increasing those other things without making the kernel unusable.

This diff effectivly increases the number of vnodes back to the number
of buffers, as in the earlier dynamic buffer cache commits, without
increasing anything else (namecache, softdeps, etc. etc.)

ok pedro@@ tedu@@ art@@ thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.86 2007/05/31 18:22:25 thib Exp $	*/
d440 1
@


1.86
log
@Zap a bunch of unused VT_* tags.

ok tedu@@,pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.85 2007/05/30 04:27:43 beck Exp $	*/
d241 2
a242 1
extern	int desiredvnodes;		/* number of vnodes desired */
@


1.85
log
@back out vfs change - todd fries has seen afs issues, and I'm suspicious
this can cause other problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.82 2007/05/28 21:05:20 thib Exp $	*/
d66 3
a68 3
	VT_NON, VT_UFS, VT_NFS, VT_MFS, VT_MSDOSFS, VT_LFS, VT_LOFS, VT_FDESC,
	VT_PORTAL, VT_KERNFS, VT_PROCFS, VT_AFS, VT_ISOFS, VT_ADOSFS, VT_EXT2FS,
	VT_NCPFS, VT_VFS, VT_XFS, VT_NTFS, VT_UDF
d72 3
a74 3
    "NON", "UFS", "NFS", "MFS", "MSDOSFS", "LFS", "LOFS", \
    "FDESC", "PORTAL", "KERNFS", "PROCFS", "AFS", "ISOFS", \
    "ADOSFS", "EXT2FS", "NCPFS", "VFS", "XFS", "NTFS", "UDF"
@


1.84
log
@Nuke the predefined vattr, it was only used for !DIAGNOSTIC,
this shrinks the i386 RAMDISK a bit.
(Using the predefined vattr for GENERIC meant a growth of
 416bytes without any measurable perfomance gain).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.83 2007/05/29 05:28:54 beck Exp $	*/
a93 2
	LIST_HEAD(, namecache) v_cache_src;	/* cache entries from us */
	TAILQ_HEAD(, namecache) v_cache_dst;	/* cache entries to us */
a407 2
void	vhold(struct vnode *);
void	vdrop(struct vnode *);
@


1.83
log
@
	Step one of some vnode improvements - change getnewvnode to
actually allocate "desiredvnodes" - add a vdrop to un-hold a vnode held
with vhold, and change the name cache to make use of vhold/vdrop, while
keeping track of which vnodes are referred to by which cache entries to
correctly hold/drop vnodes when the cache uses them.
ok thib@@, tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.82 2007/05/28 21:05:20 thib Exp $	*/
a232 1
#ifdef DIAGNOSTIC
a233 4
#else
#define	VATTR_NULL(vap)	(*(vap) = va_null)	/* initialize a vattr */
#endif /* DIAGNOSTIC */

a245 2
extern	struct vattr va_null;		/* predefined null vattr structure */

@


1.82
log
@de-inline vref();

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.81 2007/05/26 18:42:21 thib Exp $	*/
d94 2
d417 2
@


1.81
log
@Nuke a bunch of simpelocks and associated goo.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.80 2007/05/17 23:46:28 thib Exp $	*/
a232 3

#define	VREF(vp)	vref(vp)
void	vref(struct vnode *);
d235 1
a236 1
static __inline void vref(struct vnode *);
a237 8
static __inline void
vref(vp)
	struct vnode *vp;
{
	vp->v_usecount++;
}
#endif /* DIAGNOSTIC */

d417 1
@


1.80
log
@Collapse struct v_selectinfo in struct vnode, remove the
simplelock and reuse the name for the selinfo member.
Clean-up accordingly.

ok tedu@@,art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.79 2007/05/05 12:03:04 art Exp $	*/
a229 1
extern struct simplelock vnode_free_list_slock;
a327 5

/*
 * Interlock for scanning list of vnodes attached to a mountpoint
 */
extern struct simplelock mntvnode_slock;
@


1.79
log
@vn_access hasn't been used for ages and it's just a wrapper with
locking around VOP_ACCESS. It can go.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.78 2007/04/14 23:17:00 bluhm Exp $	*/
d110 1
a110 4
	struct {
		struct	simplelock vsi_lock;	/* lock to protect below */
		struct	selinfo vsi_selinfo;	/* identity of poller(s) */
	} v_selectinfo;
d252 1
a252 1
	KNOTE(&vp->v_selectinfo.vsi_selinfo.si_note, (b))
@


1.78
log
@Fix typo in comment.  ok grunk
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.77 2007/04/13 17:09:22 thib Exp $	*/
a455 1
int	vn_access(struct vnode *, int);
@


1.77
log
@Move the declaration of VN_KNOTE() into vnode.h instead of having
multiple defines all over;

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.76 2007/04/11 16:08:50 thib Exp $	*/
d227 1
a227 1
#define REVOKEALL	0x0001		/* vop_reovke: revoke all aliases */
@


1.76
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.75 2007/03/21 17:29:32 thib Exp $	*/
d254 2
@


1.75
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.74 2007/02/26 11:25:23 pedro Exp $	*/
d433 1
a433 1
int	vrecycle(struct vnode *, struct simplelock *, struct proc *);
@


1.74
log
@Don't enforce RLIMIT_FSIZE on vnd(4) I/O operations, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.73 2007/01/16 17:52:18 thib Exp $	*/
a81 8
/*
 * Reading or writing any of these items requires holding the appropriate lock.
 * v_freelist is locked by the global vnode_free_list simple lock.
 * v_mntvnodes is locked by the global mntvnodes simple lock.
 * v_flag, v_usecount, v_holdcount and v_writecount are
 *    locked by the v_interlock simple lock.
 */

a107 1
	struct  simplelock v_interlock;		/* lock on usecount and flag */
a248 1
	simple_lock(&vp->v_interlock);
a249 1
	simple_unlock(&vp->v_interlock);
@


1.73
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.72 2006/11/20 12:52:54 tom Exp $	*/
d190 1
@


1.72
log
@vprint() should be defined if DIAGNOSTIC || DEBUG.  Noticed by (and
original diff from) Jake < antipsychic (at) hotmail.com >.  Discussed
with Mickey and Miod.

ok miod@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.71 2006/08/02 21:55:27 thib Exp $	*/
a272 6

/*
 * Macro/function to check for client cache inconsistency w.r.t. leasing.
 */
#define	LEASE_READ	0x1		/* Check lease for readers */
#define	LEASE_WRITE	0x2		/* Check lease for modifiers */
@


1.71
log
@touch of KNF.
reorder prototypes, dont use variable names
in them and zap vn_update()
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.70 2006/07/11 21:17:58 mickey Exp $	*/
a450 1
#ifdef DIAGNOSTIC
a451 1
#endif
@


1.70
log
@add mount/vnode/buf and softdep printing commands; tested on a few archs and will make pedro happy too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.69 2006/06/02 20:25:09 pedro Exp $	*/
d427 10
a436 7
int	bdevvp(dev_t dev, struct vnode **vpp);
int	cdevvp(dev_t dev, struct vnode **vpp);
int	getnewvnode(enum vtagtype tag, struct mount *mp,
	    int (**vops)(void *), struct vnode **vpp);
int	getvnode(struct filedesc *fdp, int fd, struct file **fpp);
void	vattr_null(struct vattr *vap);
int	vcount(struct vnode *vp);
d438 7
a444 2
void	vflushbuf(struct vnode *vp, int sync);
int	vflush(struct mount *mp, struct vnode *vp, int flags);
a445 1
void    vn_initialize_syncerd(void);
d448 3
a450 6
void	vdevgone(int, int, int, enum vtype);
int	vget(struct vnode *vp, int lockflag, struct proc *p);
void	vgone(struct vnode *vp);
void    vgonel(struct vnode *, struct proc *);
int	vinvalbuf(struct vnode *vp, int save, struct ucred *cred,
	    struct proc *p, int slpflag, int slptimeo);
d462 1
a462 14
int	vop_generic_bwrite(void *ap);
int	vn_access(struct vnode *, int);
void	vn_update(void);
int	vn_close(struct vnode *vp,
	    int flags, struct ucred *cred, struct proc *p);
int	vn_open(struct nameidata *ndp, int fmode, int cmode);
int	vrecycle(struct vnode *vp, struct simplelock *inter_lkp,
	    struct proc *p);
int	vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base,
	    int len, off_t offset, enum uio_seg segflg, int ioflg,
	    struct ucred *cred, size_t *aresid, struct proc *p);
int	vn_lock(struct vnode *vp, int flags, struct proc *p);
int	vn_isunder(struct vnode *, struct vnode *, struct proc *);

d464 1
d471 22
a492 17
int	vn_stat(struct vnode *vp, struct stat *sb, struct proc *p);
int	vn_statfile(struct file *fp, struct stat *sb, struct proc *p);
int	vn_writechk(struct vnode *vp);
void	vn_marktext(struct vnode *vp);
void	vn_syncer_add_to_worklist(struct vnode *vp, int delay);
void    sched_sync(struct proc *);

struct vnode *
	checkalias(struct vnode *vp, dev_t nvp_rdev, struct mount *mp);
void	vput(struct vnode *vp);
void	vrele(struct vnode *vp);
int	vaccess(mode_t file_mode, uid_t uid, gid_t gid,
	    mode_t acc_mode, struct ucred *cred);

int	vn_isdisk(struct vnode *vp, int *errp);

int	softdep_fsync(struct vnode *vp);
@


1.69
log
@Add a clonable devices implementation. Hacked along with thib@@, input
from krw@@ and toby@@, subliminal prodding from dlg@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.68 2006/05/01 21:08:44 pedro Exp $	*/
d54 3
d71 5
d140 3
a142 1
#define VLOCKSWORK	0x4000	/* FS supports locking discipline */
@


1.68
log
@Rename functions and move prototypes around
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.67 2006/04/08 11:30:16 pedro Exp $	*/
d130 1
@


1.67
log
@clean up includes, from thib, okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.66 2006/01/09 12:43:17 pedro Exp $	*/
d439 8
d459 1
@


1.66
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.65 2005/12/04 19:04:13 pedro Exp $	*/
d40 2
a41 5
/* XXX: clean up includes later */
#include <uvm/uvm_pglist.h>	/* XXX */
#include <sys/lock.h>		/* XXX */
#include <uvm/uvm.h>		/* XXX */
#include <uvm/uvm_vnode.h>	/* XXX */
@


1.65
log
@Add vn_access(), discussed with and okay uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.64 2005/11/21 18:16:46 millert Exp $	*/
d439 3
a441 1
void	vprint(char *label, struct vnode *vp);
@


1.64
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.63 2005/10/19 16:50:47 pedro Exp $	*/
d441 1
@


1.63
log
@Remove v_vnlock from struct vnode, okay krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.62 2005/10/18 21:18:48 jaredy Exp $	*/
d38 1
a38 1
#include <sys/select.h>
@


1.62
log
@getnewfsid() was renamed and moved to sys/mount.h long ago; ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.61 2005/05/26 00:33:45 pedro Exp $	*/
a111 1
	struct  lock *v_vnlock;			/* used for non-locking fs's */
@


1.61
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.60 2005/03/29 17:24:52 pedro Exp $	*/
a424 1
void	getnewfsid(struct mount *, int);
@


1.60
log
@Bring in UDF support from FreeBSD, disabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.59 2004/07/13 21:04:29 millert Exp $	*/
d67 2
a68 3
	VT_PORTAL, VT_NULL, VT_UMAP, VT_KERNFS, VT_PROCFS, VT_AFS, VT_ISOFS,
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS, VT_NTFS,
	VT_UDF
a111 1
	struct	lock v_lock;
a134 1
#define VLAYER		0x2000	/* vnode is on a layer file system */
@


1.59
log
@Change mode_t and nlink_t from 16bit to 32bit.  This allows us to
use mode_t in syscalls.master and to use mode_t in more places in
the kernel.  It also makes lint much more useful on kernel code.

I've also added a placeholder for st_birthtime to make a UFS2 import
easier at some future date.

Requested by and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.58 2004/01/09 03:01:03 tedu Exp $	*/
d68 2
a69 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS, VT_NTFS
@


1.58
log
@back out vnode parents.  weird breakge found in ports tree
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.57 2004/01/06 04:22:59 tedu Exp $	*/
d152 2
a153 2
	u_short		va_mode;	/* files access mode and type */
	short		va_nlink;	/* number of references to file */
@


1.57
log
@keep track of a vnode's parent dir.  ufs only, and unused atm, but
the fun stuff is coming.  testing by brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.56 2003/08/05 21:27:15 tedu Exp $	*/
a114 1
	struct	vnode *v_parent;		/* parent directory */
@


1.56
log
@whitespace pretties.  sorry, couldn't take it anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.55 2003/06/02 23:28:22 millert Exp $	*/
d115 1
@


1.55
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.54 2003/05/20 03:05:42 tedu Exp $	*/
d92 1
a92 1
	u_int   v_writecount;			
d112 1
a112 1
	struct 	lock v_lock;
d115 1
a115 1
	void 	*v_data;			/* private data for fs */
d207 1
a207 1
};	
d422 3
a424 3
int 	bdevvp(dev_t dev, struct vnode **vpp);
int 	cdevvp(dev_t dev, struct vnode **vpp);
int 	getnewvnode(enum vtagtype tag, struct mount *mp,
d428 2
a429 2
void 	vattr_null(struct vattr *vap);
int 	vcount(struct vnode *vp);
d438 2
a439 2
int 	vget(struct vnode *vp, int lockflag, struct proc *p);
void 	vgone(struct vnode *vp);
d446 1
a446 1
int 	vn_close(struct vnode *vp,
d448 1
a448 1
int 	vn_open(struct nameidata *ndp, int fmode, int cmode);
d451 1
a451 1
int 	vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base,
d472 2
a473 2
void 	vput(struct vnode *vp);
void 	vrele(struct vnode *vp);
@


1.54
log
@support for NTFS.  from NetBSD via Julien Bordet
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.53 2003/05/01 21:13:05 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.53
log
@several related changes:
vfs_subr.c:
	add a missing simple_lock_init for vnode interlock
	try to avoid reclaiming locked or layered vnodes
	initialize vnlock pointer to NULL
	remove old code to free vnlock, never used
	lockinit the new vnode lock
vfs_syscalls.c:
	support for VLAYER flag
vnode_if.sh:
	support for splitting VDESC flags
vnode_if.src:
	split VDESC flags
	WILLPUT is the combination of WILLRELE and WILLUNLOCK
	most uses for WILLRELE become WILLPUT
vnode.h:
	add v_lock to struct vnode
	add VLAYER flag
	update for new VDESC flags
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.52 2003/02/24 02:17:22 deraadt Exp $	*/
d72 1
a72 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS
@


1.52
log
@bye bye tcfs
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.51 2002/07/03 21:19:08 miod Exp $	*/
d116 1
d140 1
d291 14
a304 6
#define VDESC_VP0_WILLRELE	0x0001
#define VDESC_VP1_WILLRELE	0x0002
#define VDESC_VP2_WILLRELE	0x0004
#define VDESC_VP3_WILLRELE	0x0008
#define VDESC_NOMAP_VPP		0x0100
#define VDESC_VPP_WILLRELE	0x0200
@


1.51
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.50 2002/06/16 16:54:27 miod Exp $	*/
d72 1
a72 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS, VT_TCFS
@


1.50
log
@When processing the KERN_VNODE sysctl, the kernel builds a packed structure,
while pstat(8) expects a C structure abiding the regular structure packing
rules. This caused pstat -v to break on powerpc.

Unbreak the confusion by defining the structure in a common header file,
and having the kernel use it.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.49 2002/03/14 03:16:12 millert Exp $	*/
d339 1
a339 1
struct simplelock mntvnode_slock;
@


1.49
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.48 2002/03/14 01:27:14 millert Exp $	*/
d202 8
@


1.48
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.47 2001/12/19 08:58:07 art Exp $	*/
d345 1
a345 1
	((S_TYPE)(((char*)(STRUCT_P))+(S_OFFSET)))
d410 2
a411 2
int 	getnewvnode __P((enum vtagtype tag, struct mount *mp,
			 int (**vops)(void *), struct vnode **vpp));
@


1.47
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.41 2001/11/15 06:22:30 art Exp $	*/
d91 1
a91 1
	int	(**v_op) __P((void *));		/* vnode operations vector */
d236 1
a236 1
void	vref __P((struct vnode *));
d240 1
a240 1
static __inline void vref __P((struct vnode *));
d353 1
a353 1
	int (*opve_impl) __P((void *));	/* code implementing this operation */
d357 1
a357 1
	int (***opv_desc_vector_p) __P((void *));
d364 1
a364 1
int vn_default_error __P((void *));
d408 2
a409 2
int 	bdevvp __P((dev_t dev, struct vnode **vpp));
int 	cdevvp __P((dev_t dev, struct vnode **vpp));
d411 27
a437 27
			 int (**vops) __P((void *)), struct vnode **vpp));
int	getvnode __P((struct filedesc *fdp, int fd, struct file **fpp));
void	getnewfsid __P((struct mount *, int));
void 	vattr_null __P((struct vattr *vap));
int 	vcount __P((struct vnode *vp));
int	vfinddev __P((dev_t, enum vtype, struct vnode **));
void	vflushbuf __P((struct vnode *vp, int sync));
int	vflush __P((struct mount *mp, struct vnode *vp, int flags));
void	vntblinit __P((void));
void    vn_initialize_syncerd __P((void));
int	vwaitforio __P((struct vnode *, int, char *, int));
void	vwakeup __P((struct vnode *));
void	vdevgone __P((int, int, int, enum vtype));
int 	vget __P((struct vnode *vp, int lockflag, struct proc *p));
void 	vgone __P((struct vnode *vp));
void    vgonel __P((struct vnode *, struct proc *));
int	vinvalbuf __P((struct vnode *vp, int save, struct ucred *cred,
	    struct proc *p, int slpflag, int slptimeo));
void	vprint __P((char *label, struct vnode *vp));
int	vop_generic_bwrite __P((void *ap));
void	vn_update __P((void));
int 	vn_close __P((struct vnode *vp,
	    int flags, struct ucred *cred, struct proc *p));
int 	vn_open __P((struct nameidata *ndp, int fmode, int cmode));
int	vrecycle __P((struct vnode *vp, struct simplelock *inter_lkp,
	    struct proc *p));
int 	vn_rdwr __P((enum uio_rw rw, struct vnode *vp, caddr_t base,
d439 2
a440 2
	    struct ucred *cred, size_t *aresid, struct proc *p));
int	vn_lock __P((struct vnode *vp, int flags, struct proc *p));
d442 13
a454 13
int	vop_generic_abortop __P((void *));
int	vop_generic_islocked __P((void *));
int	vop_generic_lock __P((void *));
int	vop_generic_unlock __P((void *));
int	vop_generic_revoke __P((void *));
int	vop_generic_kqfilter __P((void *));

int	vn_stat __P((struct vnode *vp, struct stat *sb, struct proc *p));
int	vn_statfile __P((struct file *fp, struct stat *sb, struct proc *p));
int	vn_writechk __P((struct vnode *vp));
void	vn_marktext __P((struct vnode *vp));
void	vn_syncer_add_to_worklist __P((struct vnode *vp, int delay));
void    sched_sync __P((struct proc *));
d457 5
a461 5
	checkalias __P((struct vnode *vp, dev_t nvp_rdev, struct mount *mp));
void 	vput __P((struct vnode *vp));
void 	vrele __P((struct vnode *vp));
int	vaccess __P((mode_t file_mode, uid_t uid, gid_t gid,
	    mode_t acc_mode, struct ucred *cred));
d463 1
a463 1
int	vn_isdisk __P((struct vnode *vp, int *errp));
d465 1
a465 1
int	softdep_fsync __P((struct vnode *vp));
@


1.46
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.45 2001/12/10 02:19:34 art Exp $	*/
d48 1
d90 1
a90 6
	struct uvm_object v_uobj;		/* the VM object */
#define v_usecount v_uobj.uo_refs
#define v_interlock v_uobj.vmobjlock
	voff_t	v_size;
	int	v_flag;
	int	v_numoutput;
d93 2
d106 1
d115 1
a139 3
#define	VDIRTY		0x8000	/* vnode possibly has dirty pages */

#define VSIZENOTSET	((voff_t)-1)
a251 3
void vhold __P((struct vnode *));
void vholdrele __P((struct vnode *));

a447 1
int	vop_generic_mmap __P((void *));
@


1.46.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.46 2001/12/10 04:45:31 art Exp $	*/
d95 1
a95 1
	int	(**v_op)(void *);		/* vnode operations vector */
d239 1
a239 1
void	vref(struct vnode *);
d243 1
a243 1
static __inline void vref(struct vnode *);
d351 1
a351 1
	((S_TYPE)(((char *)(STRUCT_P))+(S_OFFSET)))
d359 1
a359 1
	int (*opve_impl)(void *);	/* code implementing this operation */
d363 1
a363 1
	int (***opv_desc_vector_p)(void *);
d370 1
a370 1
int vn_default_error(void *);
d414 30
a443 30
int 	bdevvp(dev_t dev, struct vnode **vpp);
int 	cdevvp(dev_t dev, struct vnode **vpp);
int 	getnewvnode(enum vtagtype tag, struct mount *mp,
	    int (**vops)(void *), struct vnode **vpp);
int	getvnode(struct filedesc *fdp, int fd, struct file **fpp);
void	getnewfsid(struct mount *, int);
void 	vattr_null(struct vattr *vap);
int 	vcount(struct vnode *vp);
int	vfinddev(dev_t, enum vtype, struct vnode **);
void	vflushbuf(struct vnode *vp, int sync);
int	vflush(struct mount *mp, struct vnode *vp, int flags);
void	vntblinit(void);
void    vn_initialize_syncerd(void);
int	vwaitforio(struct vnode *, int, char *, int);
void	vwakeup(struct vnode *);
void	vdevgone(int, int, int, enum vtype);
int 	vget(struct vnode *vp, int lockflag, struct proc *p);
void 	vgone(struct vnode *vp);
void    vgonel(struct vnode *, struct proc *);
int	vinvalbuf(struct vnode *vp, int save, struct ucred *cred,
	    struct proc *p, int slpflag, int slptimeo);
void	vprint(char *label, struct vnode *vp);
int	vop_generic_bwrite(void *ap);
void	vn_update(void);
int 	vn_close(struct vnode *vp,
	    int flags, struct ucred *cred, struct proc *p);
int 	vn_open(struct nameidata *ndp, int fmode, int cmode);
int	vrecycle(struct vnode *vp, struct simplelock *inter_lkp,
	    struct proc *p);
int 	vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base,
d445 2
a446 2
	    struct ucred *cred, size_t *aresid, struct proc *p);
int	vn_lock(struct vnode *vp, int flags, struct proc *p);
d448 14
a461 14
int	vop_generic_abortop(void *);
int	vop_generic_islocked(void *);
int	vop_generic_lock(void *);
int	vop_generic_unlock(void *);
int	vop_generic_revoke(void *);
int	vop_generic_kqfilter(void *);
int	vop_generic_mmap(void *);

int	vn_stat(struct vnode *vp, struct stat *sb, struct proc *p);
int	vn_statfile(struct file *fp, struct stat *sb, struct proc *p);
int	vn_writechk(struct vnode *vp);
void	vn_marktext(struct vnode *vp);
void	vn_syncer_add_to_worklist(struct vnode *vp, int delay);
void    sched_sync(struct proc *);
d464 5
a468 5
	checkalias(struct vnode *vp, dev_t nvp_rdev, struct mount *mp);
void 	vput(struct vnode *vp);
void 	vrele(struct vnode *vp);
int	vaccess(mode_t file_mode, uid_t uid, gid_t gid,
	    mode_t acc_mode, struct ucred *cred);
d470 1
a470 1
int	vn_isdisk(struct vnode *vp, int *errp);
d472 1
a472 1
int	softdep_fsync(struct vnode *vp);
@


1.46.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.46.2.1 2002/06/11 03:32:34 art Exp $	*/
a205 8
/*
 * Structure returned by the KERN_VNODE sysctl
 */
struct e_vnode {
	struct vnode *vptr;
	struct vnode vnode;
};	

d337 1
a337 1
extern struct simplelock mntvnode_slock;
@


1.46.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 1
a71 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS
a115 1
	struct 	lock v_lock;
a138 1
#define VLAYER		0x2000	/* vnode is on a layer file system */
d295 6
a300 14
#define VDESC_VP0_WILLRELE      0x00000001
#define VDESC_VP1_WILLRELE      0x00000002
#define VDESC_VP2_WILLRELE      0x00000004
#define VDESC_VP3_WILLRELE      0x00000008
#define VDESC_VP0_WILLUNLOCK    0x00000100
#define VDESC_VP1_WILLUNLOCK    0x00000200
#define VDESC_VP2_WILLUNLOCK    0x00000400
#define VDESC_VP3_WILLUNLOCK    0x00000800
#define VDESC_VP0_WILLPUT       0x00000101
#define VDESC_VP1_WILLPUT       0x00000202
#define VDESC_VP2_WILLPUT       0x00000404
#define VDESC_VP3_WILLPUT       0x00000808
#define VDESC_NOMAP_VPP         0x00010000
#define VDESC_VPP_WILLRELE      0x00020000
@


1.46.2.4
log
@byebye vop_generic_lock
@
text
@d467 3
@


1.46.2.5
log
@add VEXECMAP.  also make sure to modify filepages count only in the not
execpages case in uvm_pageremove().
this actually appears to solve the swap freak out problems.  sitting on it for
a long time, never checked if it worked.  sigh.
@
text
@a136 1
#define	VEXECMAP	0x0010	/* vnode has PROT_EXEC mappings */
d474 1
a474 2
void	vn_markexec(struct vnode *vp);
int	vn_marktext(struct vnode *vp);
@


1.45
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.44 2001/12/05 00:24:36 art Exp $	*/
a116 1
	struct	lock v_glock;			/* getpages lock */
d454 1
a454 6

/* XXXUBC - doesn't really belong here. */
int	genfs_getpages __P((void *));
int	genfs_putpages __P((void *));
int	genfs_size __P((void *));
int	genfs_mmap __P((void *));
@


1.44
log
@Break out the part that lowers v_holdcnt in brelvp into an own function
and make it and vhold into public interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.43 2001/12/04 22:44:32 art Exp $	*/
a47 1
#include <uvm/uvm_vnode.h>	/* XXX */
d89 6
a94 1
	struct uvm_vnode v_uvm;			/* uvm data */
a96 4
#define v_flag v_uvm.u_flags
#define v_usecount v_uvm.u_obj.uo_refs
#define v_interlock v_uvm.u_obj.vmobjlock
#define v_numoutput v_uvm.u_nio
d117 1
a117 1
	struct	lock v_glock;			/* getpage lock */
@


1.43
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.42 2001/11/27 05:27:12 art Exp $	*/
d255 3
@


1.42
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.41 2001/11/15 06:22:30 art Exp $	*/
d457 1
a457 1

@


1.41
log
@New function vn_marktext - mark a vnode as executing a text image.
Use where VTEXT was set in vnode flags before. Doesn't do anything else (yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.40 2001/11/06 19:53:21 miod Exp $	*/
d93 4
a96 2
	u_int	v_flag;				/* vnode flags (see below) */
	u_int   v_usecount;			/* reference count of users */
a107 1
	u_int   v_numoutput;			/* num of writes in progress */
a115 1
	struct  simplelock v_interlock;		/* lock on usecount and flag */
d117 1
d141 3
d452 6
@


1.40
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.39 2001/08/12 17:55:57 mickey Exp $	*/
d452 1
@


1.39
log
@moce pglisth into uvm_pglist.h
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.38 2001/08/12 05:18:42 mickey Exp $	*/
a46 1
#include <vm/vm.h>		/* XXX */
a47 2
#include <uvm/uvm_extern.h>	/* XXX */
#include <uvm/uvm_object.h>	/* XXX */
@


1.38
log
@vm/vm_prot.h no more
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.38 2001/08/12 04:57:19 mickey Exp $	*/
d45 1
a45 1
#include <vm/pglist.h>		/* XXX */
@


1.37
log
@Add a new type voff_t (right now it's typedefed as off_t) used for offsets
into objects.

Gives the possibilty to mmap beyond the size of vaddr_t.

From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.36 2001/07/05 07:31:52 art Exp $	*/
d39 1
d46 1
a46 1
#include <vm/vm_param.h>	/* XXX */
d48 2
a49 1
#include <sys/lock.h>		/* XXX */
@


1.36
log
@v_vmdata is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.35 2001/06/27 04:51:49 art Exp $	*/
d46 1
@


1.35
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.34 2001/06/22 14:11:01 deraadt Exp $	*/
a110 1
		caddr_t		vu_vmdata;	/* private data for vm (VREG) */
a125 1
#define	v_vmdata	v_un.vu_vmdata
@


1.34
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.33 2001/06/05 20:54:51 provos Exp $	*/
d42 2
a43 1
#ifdef UVM			/* XXX: clean up includes later */
a48 1
#endif /* UVM */
a89 1
#ifdef UVM
a90 1
#endif
@


1.33
log
@generic kqfilter that just like select returns ready for read and write.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.32 2001/05/14 12:11:52 art Exp $	*/
d109 1
a109 1
	LIST_ENTRY(vnode) v_synclist;           /* vnode with dirty buffers */
d143 1
a143 1
#define VLOCKSWORK      0x4000  /* FS supports locking discipline */
d182 1
a182 1
#define VA_EXCLUSIVE    0x02            /* exclusive create request */
d228 1
a228 1
#define REVOKEALL       0x0001          /* vop_reovke: revoke all aliases */
d345 1
a345 1
        ((int) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
d425 1
a425 1
int     vwaitforio __P((struct vnode *, int, char *, int));
d446 1
a446 1
int     vop_generic_abortop __P((void *));
d464 1
a464 1
		     mode_t acc_mode, struct ucred *cred));
d466 1
a466 1
int     vn_isdisk __P((struct vnode *vp, int *errp));
d468 1
a468 1
int     softdep_fsync __P((struct vnode *vp));
@


1.32
log
@Implement a wrapper round vn_stat that takes the same arguments
as soo_stat and pipe_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.31 2001/02/26 00:24:38 csapuntz Exp $	*/
d451 1
@


1.31
log
@

u_int32_t -> u_int
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.30 2001/02/26 00:18:32 csapuntz Exp $	*/
d453 1
@


1.30
log
@

Make ref counts 32-bit unsigned ints as opposed to a potpourri of longs and
ints.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.29 2001/02/24 19:07:07 csapuntz Exp $	*/
d93 1
a93 1
	int 	(**v_op) __P((void *));		/* vnode operations vector */
d95 8
a102 8
	u_int32_t v_flag;			/* vnode flags (see below) */
	u_int32_t v_usecount;			/* reference count of users */
	u_int32_t v_writecount;			/* reference count of writers */
	u_int32_t v_bioflag;                    /* flags that can be 
						   read/written
						   at interrupt level */
	u_int32_t v_holdcnt;			/* buffer references */
	u_int32_t v_id;				/* capability identifier */
d108 1
a108 1
	u_int32_t v_numoutput;			/* num of writes in progress */
@


1.29
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.28 2001/02/23 14:42:37 csapuntz Exp $	*/
d93 2
d96 2
a97 2
	int	v_usecount;			/* reference count of users */
	int	v_writecount;			/* reference count of writers */
d101 2
a102 2
	long	v_holdcnt;			/* page & buffer references */
	u_long	v_id;				/* capability identifier */
a103 1
	int 	(**v_op) __P((void *));		/* vnode operations vector */
d108 1
a108 1
	long	v_numoutput;			/* num of writes in progress */
a109 1
	enum	vtype v_type;			/* vnode type */
a119 4
#ifdef UVM
#else
	long	v_spare[3];			/* round to 128 bytes */
#endif
a237 2
void 	vattr_null __P((struct vattr *vap));

d418 1
@


1.28
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.27 2001/02/21 23:24:30 csapuntz Exp $	*/
d93 1
a93 1
	u_long	v_flag;				/* vnode flags (see below) */
d96 3
a116 1
	struct	nqlease *v_lease;		/* Soft reference to lease */
a145 1
#define	VBWAIT		0x0400	/* waiting for output to complete */
a146 2
#define	VDIROP		0x1000	/* LFS: vnode is involved in a directory op */
#define VONFREELIST     0x2000  /* Vnode is on a free list */
d148 7
a154 1
#define VONSYNCLIST	0x8000	/* Vnode is on syncer worklist */
a240 1
#define	HOLDRELE(vp)	holdrele(vp)
d242 3
a244 1
#define	VHOLD(vp)	vhold(vp)
a245 3

void	holdrele __P((struct vnode *));
void	vhold __P((struct vnode *));
a247 1
#define	HOLDRELE(vp)	holdrele(vp); 	/* decrease buf or page ref */
a249 2
static __inline void holdrele __P((struct vnode *));
static __inline void vhold __P((struct vnode *));
a250 34

static __inline void
holdrele(vp)
	struct vnode *vp;
{
	simple_lock(&vp->v_interlock);
	vp->v_holdcnt--;
 	if ((vp->v_flag & VONFREELIST) &&
 	    vp->v_holdcnt == 0 && vp->v_usecount == 0) {
 		simple_lock(&vnode_free_list_slock);
 		TAILQ_REMOVE(&vnode_hold_list, vp, v_freelist);
 		TAILQ_INSERT_TAIL(&vnode_free_list, vp, v_freelist);
 		simple_unlock(&vnode_free_list_slock);
 	}
	simple_unlock(&vp->v_interlock);
}

#define	VHOLD(vp)	vhold(vp)		/* increase buf or page ref */
static __inline void
vhold(vp)
	struct vnode *vp;
{
	simple_lock(&vp->v_interlock);
 	if ((vp->v_flag & VONFREELIST) &&
 	    vp->v_holdcnt == 0 && vp->v_usecount == 0) {
 		simple_lock(&vnode_free_list_slock);
 		TAILQ_REMOVE(&vnode_free_list, vp, v_freelist);
 		TAILQ_INSERT_TAIL(&vnode_hold_list, vp, v_freelist);
 		simple_unlock(&vnode_free_list_slock);
 	}
	vp->v_holdcnt++;
	simple_unlock(&vp->v_interlock);
}

a423 1
void 	vattr_null __P((struct vattr *vap));
a424 1
void	vclean __P((struct vnode *, int, struct proc *));
d430 2
a431 1
void	vwakeup __P((struct buf *));
a435 1
void 	vgoneall __P((struct vnode *vp));
@


1.27
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.26 2000/11/21 21:49:56 provos Exp $	*/
a96 1
	daddr_t	v_lastr;			/* last read (read-ahead) */
d115 1
a115 6
	daddr_t	v_lastw;			/* last write (write cluster) */
	daddr_t	v_cstart;			/* start block of cluster */
	daddr_t	v_lasta;			/* last allocation */
	int	v_clen;				/* length of current cluster */
	int	v_ralen;			/* Read-ahead length */
	daddr_t	v_maxra;			/* last readahead block */
@


1.26
log
@support for kernel events on vnodes, from jlemon@@freebsd.org, okay art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.25 2000/06/17 17:16:05 provos Exp $	*/
d510 5
@


1.25
log
@initial import of tcfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.24 2000/05/22 13:48:40 provos Exp $	*/
d41 1
d130 4
@


1.24
log
@change counts from short to int
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.23 2000/04/19 08:34:51 csapuntz Exp $	*/
d71 1
a71 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS
@


1.23
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.22 1999/12/05 07:19:28 art Exp $	*/
d93 2
a94 2
	short	v_usecount;			/* reference count of users */
	short	v_writecount;			/* reference count of writers */
@


1.22
log
@Add a new vnode flag "VONSYNCLIST" that indicates if the vnode is on the
syncers work list.
From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.21 1999/08/08 00:34:38 niklas Exp $	*/
a479 3
int 	vn_closefile __P((struct file *fp, struct proc *p));
int	vn_ioctl __P((struct file *fp, u_long com, caddr_t data,
	    struct proc *p));
a493 2
int	vn_read __P((struct file *fp, struct uio *uio, struct ucred *cred));
int	vn_select __P((struct file *fp, int which, struct proc *p));
a494 1
int	vn_write __P((struct file *fp, struct uio *uio, struct ucred *cred));
@


1.22.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.31 2001/02/26 00:24:38 csapuntz Exp $	*/
a40 1
#include <sys/select.h>
d71 1
a71 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS, VT_TCFS
d92 6
a97 10
	int	(**v_op) __P((void *));		/* vnode operations vector */
	enum	vtype v_type;			/* vnode type */
	u_int	v_flag;				/* vnode flags (see below) */
	u_int   v_usecount;			/* reference count of users */
	/* reference count of writers */
	u_int   v_writecount;			
	/* Flags that can be read/written in interrupts */
	u_int   v_bioflag;
	u_int   v_holdcnt;			/* buffer references */
	u_int   v_id;				/* capability identifier */
d99 1
d104 1
a104 1
	u_int   v_numoutput;			/* num of writes in progress */
d106 1
d114 7
a120 1

d123 4
a128 4
	struct {
		struct	simplelock vsi_lock;	/* lock to protect below */
		struct	selinfo vsi_selinfo;	/* identity of poller(s) */
	} v_selectinfo;
d145 1
d147 2
d150 1
a150 7

/*
 * (v_bioflag) Flags that may be manipulated by interrupt handlers
 */
#define	VBIOWAIT	0x0001	/* waiting for output to complete */
#define VBIOONSYNCLIST	0x0002	/* Vnode is on syncer worklist */
#define VBIOONFREELIST  0x0004  /* Vnode is on a free list */
d237 1
d239 2
d242 2
a243 1
#define	VREF(vp)	vref(vp)
d246 1
d249 2
d252 34
d461 1
d467 1
a467 2
int     vwaitforio __P((struct vnode *, int, char *, int));
void	vwakeup __P((struct vnode *));
d472 1
d480 3
d497 2
d500 1
a510 5

int     vn_isdisk __P((struct vnode *vp, int *errp));

int     softdep_fsync __P((struct vnode *vp));

@


1.22.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.22.2.1 2001/05/14 22:45:05 niklas Exp $	*/
d42 1
a42 2

/* XXX: clean up includes later */
d48 1
d90 1
d92 1
d109 1
a109 1
	LIST_ENTRY(vnode) v_synclist;		/* vnode with dirty buffers */
d143 1
a143 1
#define VLOCKSWORK	0x4000	/* FS supports locking discipline */
d182 1
a182 1
#define VA_EXCLUSIVE    0x02		/* exclusive create request */
d228 1
a228 1
#define REVOKEALL	0x0001		/* vop_reovke: revoke all aliases */
d345 1
a345 1
	((int) (((char *) (&(((p_type)NULL)->field))) - ((char *) NULL)))
d425 1
a425 1
int	vwaitforio __P((struct vnode *, int, char *, int));
d446 1
a446 1
int	vop_generic_abortop __P((void *));
a450 1
int	vop_generic_kqfilter __P((void *));
a452 1
int	vn_statfile __P((struct file *fp, struct stat *sb, struct proc *p));
d462 1
a462 1
	    mode_t acc_mode, struct ucred *cred));
d464 1
a464 1
int	vn_isdisk __P((struct vnode *vp, int *errp));
d466 1
a466 1
int	softdep_fsync __P((struct vnode *vp));
@


1.22.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.22.2.2 2001/07/04 11:00:38 niklas Exp $	*/
a38 1
#include <sys/types.h>
d44 2
a45 1
#include <uvm/uvm_pglist.h>	/* XXX */
a46 3
#include <vm/vm.h>		/* XXX */
#include <uvm/uvm.h>		/* XXX */
#include <uvm/uvm_extern.h>	/* XXX */
d111 1
d127 1
@


1.22.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 1
d49 2
@


1.22.2.5
log
@Merge in -current
@
text
@d93 2
a94 4
#define v_flag v_uvm.u_flags
#define v_usecount v_uvm.u_obj.uo_refs
#define v_interlock v_uvm.u_obj.vmobjlock
#define v_numoutput v_uvm.u_nio
d106 1
d115 1
a116 1
	struct	lock v_glock;			/* getpage lock */
a139 3
#define	VDIRTY		0x8000	/* vnode possibly has dirty pages */

#define VSIZENOTSET	((voff_t)-1)
a448 6
/* XXXUBC - doesn't really belong here. */
int	genfs_getpages __P((void *));
int	genfs_putpages __P((void *));
int	genfs_size __P((void *));


a451 1
void	vn_marktext __P((struct vnode *vp));
@


1.22.2.6
log
@Merge in trunk
@
text
@d93 4
a96 2
	u_int	v_flag;				/* vnode flags (see below) */
	u_int   v_usecount;			/* reference count of users */
a107 1
	u_int   v_numoutput;			/* num of writes in progress */
a115 1
	struct  simplelock v_interlock;		/* lock on usecount and flag */
d117 1
d141 3
d452 6
@


1.22.2.7
log
@Merge in -current from roughly a week ago
@
text
@d91 1
a91 1
	int	(**v_op)(void *);		/* vnode operations vector */
d236 1
a236 1
void	vref(struct vnode *);
d240 1
a240 1
static __inline void vref(struct vnode *);
d345 1
a345 1
	((S_TYPE)(((char *)(STRUCT_P))+(S_OFFSET)))
d353 1
a353 1
	int (*opve_impl)(void *);	/* code implementing this operation */
d357 1
a357 1
	int (***opv_desc_vector_p)(void *);
d364 1
a364 1
int vn_default_error(void *);
d408 30
a437 30
int 	bdevvp(dev_t dev, struct vnode **vpp);
int 	cdevvp(dev_t dev, struct vnode **vpp);
int 	getnewvnode(enum vtagtype tag, struct mount *mp,
	    int (**vops)(void *), struct vnode **vpp);
int	getvnode(struct filedesc *fdp, int fd, struct file **fpp);
void	getnewfsid(struct mount *, int);
void 	vattr_null(struct vattr *vap);
int 	vcount(struct vnode *vp);
int	vfinddev(dev_t, enum vtype, struct vnode **);
void	vflushbuf(struct vnode *vp, int sync);
int	vflush(struct mount *mp, struct vnode *vp, int flags);
void	vntblinit(void);
void    vn_initialize_syncerd(void);
int	vwaitforio(struct vnode *, int, char *, int);
void	vwakeup(struct vnode *);
void	vdevgone(int, int, int, enum vtype);
int 	vget(struct vnode *vp, int lockflag, struct proc *p);
void 	vgone(struct vnode *vp);
void    vgonel(struct vnode *, struct proc *);
int	vinvalbuf(struct vnode *vp, int save, struct ucred *cred,
	    struct proc *p, int slpflag, int slptimeo);
void	vprint(char *label, struct vnode *vp);
int	vop_generic_bwrite(void *ap);
void	vn_update(void);
int 	vn_close(struct vnode *vp,
	    int flags, struct ucred *cred, struct proc *p);
int 	vn_open(struct nameidata *ndp, int fmode, int cmode);
int	vrecycle(struct vnode *vp, struct simplelock *inter_lkp,
	    struct proc *p);
int 	vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base,
d439 2
a440 2
	    struct ucred *cred, size_t *aresid, struct proc *p);
int	vn_lock(struct vnode *vp, int flags, struct proc *p);
d442 13
a454 13
int	vop_generic_abortop(void *);
int	vop_generic_islocked(void *);
int	vop_generic_lock(void *);
int	vop_generic_unlock(void *);
int	vop_generic_revoke(void *);
int	vop_generic_kqfilter(void *);

int	vn_stat(struct vnode *vp, struct stat *sb, struct proc *p);
int	vn_statfile(struct file *fp, struct stat *sb, struct proc *p);
int	vn_writechk(struct vnode *vp);
void	vn_marktext(struct vnode *vp);
void	vn_syncer_add_to_worklist(struct vnode *vp, int delay);
void    sched_sync(struct proc *);
d457 5
a461 5
	checkalias(struct vnode *vp, dev_t nvp_rdev, struct mount *mp);
void 	vput(struct vnode *vp);
void 	vrele(struct vnode *vp);
int	vaccess(mode_t file_mode, uid_t uid, gid_t gid,
	    mode_t acc_mode, struct ucred *cred);
d463 1
a463 1
int	vn_isdisk(struct vnode *vp, int *errp);
d465 1
a465 1
int	softdep_fsync(struct vnode *vp);
@


1.22.2.8
log
@Sync the SMP branch with 3.3
@
text
@d72 1
a72 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS
a202 8
/*
 * Structure returned by the KERN_VNODE sysctl
 */
struct e_vnode {
	struct vnode *vptr;
	struct vnode vnode;
};	

d331 1
a331 1
extern struct simplelock mntvnode_slock;
@


1.22.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.22.2.8 2003/03/28 00:41:30 niklas Exp $	*/
a115 1
	struct 	lock v_lock;
a138 1
#define VLAYER		0x2000	/* vnode is on a layer file system */
d289 6
a294 14
#define VDESC_VP0_WILLRELE      0x00000001
#define VDESC_VP1_WILLRELE      0x00000002
#define VDESC_VP2_WILLRELE      0x00000004
#define VDESC_VP3_WILLRELE      0x00000008
#define VDESC_VP0_WILLUNLOCK    0x00000100
#define VDESC_VP1_WILLUNLOCK    0x00000200
#define VDESC_VP2_WILLUNLOCK    0x00000400
#define VDESC_VP3_WILLUNLOCK    0x00000800
#define VDESC_VP0_WILLPUT       0x00000101
#define VDESC_VP1_WILLPUT       0x00000202
#define VDESC_VP2_WILLPUT       0x00000404
#define VDESC_VP3_WILLPUT       0x00000808
#define VDESC_NOMAP_VPP         0x00010000
#define VDESC_VPP_WILLRELE      0x00020000
@


1.22.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.22.2.9 2003/05/13 19:36:57 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
d72 1
a72 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS, VT_XFS, VT_NTFS
@


1.22.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 1
a92 1
	u_int   v_writecount;
d112 1
a112 1
	struct	lock v_lock;
d115 1
a115 1
	void	*v_data;			/* private data for fs */
d207 1
a207 1
};
d422 3
a424 3
int	bdevvp(dev_t dev, struct vnode **vpp);
int	cdevvp(dev_t dev, struct vnode **vpp);
int	getnewvnode(enum vtagtype tag, struct mount *mp,
d428 2
a429 2
void	vattr_null(struct vattr *vap);
int	vcount(struct vnode *vp);
d438 2
a439 2
int	vget(struct vnode *vp, int lockflag, struct proc *p);
void	vgone(struct vnode *vp);
d446 1
a446 1
int	vn_close(struct vnode *vp,
d448 1
a448 1
int	vn_open(struct nameidata *ndp, int fmode, int cmode);
d451 1
a451 1
int	vn_rdwr(enum uio_rw rw, struct vnode *vp, caddr_t base,
d472 2
a473 2
void	vput(struct vnode *vp);
void	vrele(struct vnode *vp);
@


1.21
log
@From NetBSD; vdevgone, used for revoking access to device nodes when they
disappear (detach is coming).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.20 1999/02/26 02:48:36 art Exp $	*/
d150 1
@


1.20
log
@add uvm specific parts to struct vnode
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.19 1998/12/05 16:50:40 csapuntz Exp $	*/
d467 1
@


1.19
log
@

Framework for generating automatic test code for locking discipline
in DIAGNOSTIC mode.

Added documentation to vfs_subr.c on locking needs of a couple calls.

Improvements to the vinvalbuf patch. We need to start over after we
let our pants down.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.18 1998/11/15 17:15:01 art Exp $	*/
d41 7
d89 3
d123 2
d126 1
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.17 1998/09/06 01:44:08 art Exp $	*/
d136 1
@


1.17
log
@add a VT_XFS tag for vnodes
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.16 1998/08/06 19:35:17 csapuntz Exp $	*/
d111 2
a112 2
	struct  simplelock v_interlock;        /* lock on usecount and flag */
	struct  lock *v_vnlock;                 /* used for non-locking fs's */
@


1.16
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.15 1998/07/28 00:13:10 millert Exp $	*/
d64 1
a64 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS
@


1.15
log
@Return EINVAL when msg_iovlen or iovcnt <= 0; Make uio_resid unsigned (size_t) and don't return EINVAL if it is < 0 in sys_{read,write}.  Remove check for uio_resid < 0 uiomove() now that uio_resid is unsigned and brack remaining panics with #ifdef DIAGNOSTIC.  vn_rdwr() must now take a size_t * as its 9th argument so change that and clean up uses of vn_rdwr().  Fixes 549 + more
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.14 1998/03/14 19:33:03 millert Exp $	*/
d135 1
a135 1
#define VGONEHACK       0x2000  /* vgone: don't put me on the head of the free list */
d244 1
a244 1
 	if (!(vp->v_flag & VGONEHACK) &&
d260 1
a260 1
 	if (!(vp->v_flag & VGONEHACK) &&
d460 1
a460 1
int	vn_bwrite __P((void *ap));
d474 6
a479 4
int	vop_noislocked __P((void *));
int	vop_nolock __P((void *));
int	vop_nounlock __P((void *));
int	vop_revoke __P((void *));
@


1.14
log
@Changes necesary for new soft updates code.  Doesn't affect old soft updates
or kernels without soft updates...
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.13 1998/01/10 23:41:17 csapuntz Exp $	*/
d472 1
a472 1
	    struct ucred *cred, int *aresid, struct proc *p));
@


1.13
log
@Broke up vfs_subr.c which was getting a bit huge. We now have seperate files
for the syncer daemon as well as default VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.12 1997/11/24 22:42:34 niklas Exp $	*/
d288 1
d290 1
a290 1
extern	int desiredvnodes;		/* number of vnodes desired */
@


1.12
log
@Fix non-DIAGNOSTIC (and non-COMPAT*) compilation
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.11 1997/11/06 05:59:12 csapuntz Exp $	*/
d450 1
@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.10 1997/10/06 20:21:13 deraadt Exp $	*/
a227 1
void	vattr_null __P((struct vattr *));
d234 6
a239 1
static __inline holdrele(vp)
d253 1
d255 2
a256 1
static __inline vhold(vp)
d270 1
d272 2
a273 1
static __inline vref(vp)
a487 1
void 	vref __P((struct vnode *vp));
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.8 1996/07/14 08:54:05 downsj Exp $	*/
d40 1
d64 1
a64 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS
d73 8
d95 1
d111 3
a113 1
	long	v_spare[7];			/* round to 128 bytes */
d135 1
d167 1
a167 1

d213 8
d232 1
a232 1
#define	HOLDRELE(vp)	(vp)->v_holdcnt--	/* decrease buf or page ref */
d234 39
a272 3
#define	VHOLD(vp)	(vp)->v_holdcnt++	/* increase buf or page ref */
#define	VREF(vp)	(vp)->v_usecount++	/* increase reference */
#endif
d280 1
d350 5
d437 1
a437 1
void	vclean __P((struct vnode *, int));
d443 1
a443 1
int 	vget __P((struct vnode *vp, int lockflag));
d445 1
d458 2
d463 6
d474 3
@


1.9
log
@VFS Lite2 Changes
@
text
@a39 1
#include <sys/lock.h>
d63 1
a63 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS, VT_VFS
a71 8
/*
 * Reading or writing any of these items requires holding the appropriate lock.
 * v_freelist is locked by the global vnode_free_list simple lock.
 * v_mntvnodes is locked by the global mntvnodes simple lock.
 * v_flag, v_usecount, v_holdcount and v_writecount are
 *    locked by the v_interlock simple lock.
 */

a85 1
	LIST_ENTRY(vnode) v_synclist;           /* vnode with dirty buffers */
d101 1
a101 3
	struct  simplelock v_interlock;        /* lock on usecount and flag */
	struct  lock *v_vnlock;                 /* used for non-locking fs's */
	long	v_spare[3];			/* round to 128 bytes */
a122 1
#define VGONEHACK       0x2000  /* vgone: don't put me on the head of the free list */
d154 1
a154 1
#define VA_EXCLUSIVE    0x02            /* exclusive create request */
a199 8
#define REVOKEALL       0x0001          /* vop_reovke: revoke all aliases */


TAILQ_HEAD(freelst, vnode);
extern struct freelst vnode_hold_list;	/* free vnodes referencing buffers */
extern struct freelst vnode_free_list;	/* vnode free list */
extern struct simplelock vnode_free_list_slock;

d211 1
a211 1
#define	HOLDRELE(vp)	holdrele(vp); 	/* decrease buf or page ref */
d213 3
a215 39

static __inline holdrele(vp)
	struct vnode *vp;
{
	simple_lock(&vp->v_interlock);
	vp->v_holdcnt--;
 	if (!(vp->v_flag & VGONEHACK) &&
 	    vp->v_holdcnt == 0 && vp->v_usecount == 0) {
 		simple_lock(&vnode_free_list_slock);
 		TAILQ_REMOVE(&vnode_hold_list, vp, v_freelist);
 		TAILQ_INSERT_TAIL(&vnode_free_list, vp, v_freelist);
 		simple_unlock(&vnode_free_list_slock);
 	}
	simple_unlock(&vp->v_interlock);
}
#define	VHOLD(vp)	vhold(vp)		/* increase buf or page ref */
static __inline vhold(vp)
	struct vnode *vp;
{
	simple_lock(&vp->v_interlock);
 	if (!(vp->v_flag & VGONEHACK) &&
 	    vp->v_holdcnt == 0 && vp->v_usecount == 0) {
 		simple_lock(&vnode_free_list_slock);
 		TAILQ_REMOVE(&vnode_free_list, vp, v_freelist);
 		TAILQ_INSERT_TAIL(&vnode_hold_list, vp, v_freelist);
 		simple_unlock(&vnode_free_list_slock);
 	}
	vp->v_holdcnt++;
	simple_unlock(&vp->v_interlock);
}
#define	VREF(vp)	vref(vp)		/* increase reference */
static __inline vref(vp)
	struct vnode *vp;
{
	simple_lock(&vp->v_interlock);
	vp->v_usecount++;
	simple_unlock(&vp->v_interlock);
}
#endif /* DIAGNOSTIC */
a222 1
extern	time_t syncdelay;		/* time to delay syncing vnodes */
a291 5
 * Interlock for scanning list of vnodes attached to a mountpoint
 */
struct simplelock mntvnode_slock;

/*
d374 1
a374 1
void	vclean __P((struct vnode *, int, struct proc *));
d380 1
a380 1
int 	vget __P((struct vnode *vp, int lockflag, struct proc *p));
a381 1
void    vgonel __P((struct vnode *, struct proc *));
a393 2
int	vrecycle __P((struct vnode *vp, struct simplelock *inter_lkp,
	    struct proc *p));
a396 6
int	vn_lock __P((struct vnode *vp, int flags, struct proc *p));
int	vop_noislocked __P((void *));
int	vop_nolock __P((void *));
int	vop_nounlock __P((void *));
int	vop_revoke __P((void *));

a401 3
void	vn_syncer_add_to_worklist __P((struct vnode *vp, int delay));
void    sched_sync __P((struct proc *));

@


1.8
log
@document v_tag correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.7 1996/07/05 06:52:31 mickey Exp $	*/
d40 1
d64 1
a64 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS, VT_NCPFS
d73 8
d95 1
d111 3
a113 1
	long	v_spare[7];			/* round to 128 bytes */
d135 1
d167 1
a167 1

d213 8
d232 1
a232 1
#define	HOLDRELE(vp)	(vp)->v_holdcnt--	/* decrease buf or page ref */
d234 39
a272 3
#define	VHOLD(vp)	(vp)->v_holdcnt++	/* increase buf or page ref */
#define	VREF(vp)	(vp)->v_usecount++	/* increase reference */
#endif
d280 1
d350 5
d437 1
a437 1
void	vclean __P((struct vnode *, int));
d443 1
a443 1
int 	vget __P((struct vnode *vp, int lockflag));
d445 1
d458 2
d463 6
d474 3
@


1.7
log
@Add NCPfs constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.6 1996/06/24 03:35:00 downsj Exp $	*/
d56 3
@


1.6
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.5 1996/06/11 03:25:15 tholo Exp $	*/
d60 1
a60 1
	VT_UNION, VT_ADOSFS, VT_EXT2FS
@


1.5
log
@Kernel-implementation of update(8) my me
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.3 1996/03/29 19:06:46 mickey Exp $	*/
d60 1
a60 1
	VT_UNION, VT_ADOSFS
@


1.4
log
@Merge of NetBSD 960317
@
text
@d384 1
@


1.3
log
@lost change from vnode_if.[hc] evolution.
"vnode_if.h" must be <sys/vnode_if.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: vnode.h,v 1.2 1996/02/29 13:57:32 niklas Exp $	*/
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: vnode.h,v 1.37 1996/02/09 18:25:47 christos Exp $	*/
d347 1
a347 1
#include "vnode_if.h"
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: vnode.h,v 1.32 1995/03/26 20:25:05 jtc Exp $	*/
d77 1
a77 1
	int 	(**v_op)();			/* vnode operations vector */
d308 1
a308 1
	int (*opve_impl)();		/* code implementing this operation */
d312 1
a312 1
	int (***opv_desc_vector_p)();
d319 1
a319 1
int vn_default_error __P((void));
d347 1
a347 1
#include <vnode_if.h>
d353 1
a361 1
struct vop_bwrite_args;
d365 4
a368 2
int 	getnewvnode __P((enum vtagtype tag,
	    struct mount *mp, int (**vops)(), struct vnode **vpp));
d371 2
d374 3
d383 1
a383 1
int	vn_bwrite __P((struct vop_bwrite_args *ap));
d397 1
d404 1
a404 1
	    mode_t acc_mode, struct ucred *cred));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

