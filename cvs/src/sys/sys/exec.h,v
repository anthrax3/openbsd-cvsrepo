head	1.36;
access;
symbols
	OPENBSD_6_1:1.36.0.2
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.34.0.2
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.6
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.2
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.27.0.6
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.26.0.4
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.12
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.8
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.6
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.4
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.24.0.12
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.8
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.6
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.10
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.8
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.6
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.4
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.2
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.2
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.19
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.10
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.8
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.6
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2017.02.08.21.04.44;	author guenther;	state Exp;
branches;
next	1.35;
commitid	dEdzKLuJq1QhgX4y;

1.35
date	2016.11.24.23.57.24;	author patrick;	state Exp;
branches;
next	1.34;
commitid	4dj4L6gXOrt62jaN;

1.34
date	2016.05.30.21.31.27;	author deraadt;	state Exp;
branches;
next	1.33;
commitid	KDWNECRaSEemSTKP;

1.33
date	2016.05.30.21.25.48;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	EKR1QpDNmTXzcvJY;

1.32
date	2016.05.30.21.22.45;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	WldUSxuLRn3bASy2;

1.31
date	2015.09.28.20.32.59;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	frMdHMPeIFVK1Idn;

1.30
date	2015.02.09.11.52.47;	author miod;	state Exp;
branches;
next	1.29;
commitid	3LyovzkL8t513Pbn;

1.29
date	2015.02.06.23.58.12;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	Xlq9pdSoAVoFugi1;

1.28
date	2015.01.26.22.51.37;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	4sRCDm8befLIJUvK;

1.27
date	2013.10.17.08.02.20;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.26.00.36.03;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2007.01.29.11.33.24;	author otto;	state Exp;
branches;
next	1.22;

1.22
date	2004.04.15.00.22.42;	author tedu;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.12.03.21.27.05;	author markus;	state Exp;
branches;
next	1.19;

1.19
date	2002.10.06.22.40.19;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2002.10.06.22.39.25;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.23.01.41.09;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.19.01.06.18;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.04.07.22.02.20;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	2001.04.01.21.30.32;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.22.16.08.01;	author art;	state Exp;
branches;
next	1.8;

1.8
date	99.11.05.01.18.01;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.09.25.10.59.24;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	97.01.12.13.02.07;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.12.23.02.42.39;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.31.09.17.16;	author pefo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.12.11.40;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.00.15;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.11.00.17;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Remove support for forcing the ELF interpreter to a specific address,
last used by COMPAT_SYSV which was removed in 2011.

ok millert@@
@
text
@/*	$OpenBSD: exec.h,v 1.35 2016/11/24 23:57:24 patrick Exp $	*/
/*	$NetBSD: exec.h,v 1.59 1996/02/09 18:25:09 christos Exp $	*/

/*-
 * Copyright (c) 1994 Christopher G. Demetriou
 * Copyright (c) 1993 Theo de Raadt
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)exec.h	8.3 (Berkeley) 1/21/94
 */

#ifndef _SYS_EXEC_H_
#define _SYS_EXEC_H_

/*
 * The following structure is found at the top of the user stack of each
 * user process. The ps program uses it to locate argv and environment
 * strings. Programs that wish ps to display other information may modify
 * it; normally ps_argvstr points to argv[0], and ps_nargvstr is the same
 * as the program's argc. The fields ps_envstr and ps_nenvstr are the
 * equivalent for the environment.
 */
struct ps_strings {
	char	**ps_argvstr;	/* first of 0 or more argument strings */
	int	ps_nargvstr;	/* the number of argument strings */
	char	**ps_envstr;	/* first of 0 or more environment strings */
	int	ps_nenvstr;	/* the number of environment strings */
};

/*
 * Below the PS_STRINGS and sigtramp, we may require a gap on the stack
 * (used to copyin/copyout various emulation data structures).
 */
#define	STACKGAPLEN	(2*1024)	/* plenty enough for now */

/*
 * the following structures allow execve() to put together processes
 * in a more extensible and cleaner way.
 *
 * the exec_package struct defines an executable being execve()'d.
 * it contains the header, the vmspace-building commands, the vnode
 * information, and the arguments associated with the newly-execve'd
 * process.
 *
 * the exec_vmcmd struct defines a command description to be used
 * in creating the new process's vmspace.
 */

struct proc;
struct exec_package;

typedef int (*exec_makecmds_fcn)(struct proc *, struct exec_package *);

struct execsw {
	u_int	es_hdrsz;		/* size of header for this format */
	exec_makecmds_fcn es_check;	/* function to check exec format */
	struct emul *es_emul;		/* emulation */
};

struct exec_vmcmd {
	int	(*ev_proc)(struct proc *p, struct exec_vmcmd *cmd);
				/* procedure to run for region of vmspace */
	u_long	ev_len;		/* length of the segment to map */
	u_long	ev_addr;	/* address in the vmspace to place it at */
	struct	vnode *ev_vp;	/* vnode pointer for the file w/the data */
	u_long	ev_offset;	/* offset in the file for the data */
	u_int	ev_prot;	/* protections for segment */
	int	ev_flags;
#define VMCMD_RELATIVE  0x0001  /* ev_addr is relative to base entry */
#define VMCMD_BASE      0x0002  /* marks a base entry */
};

#define	EXEC_DEFAULT_VMCMD_SETSIZE	8	/* # of cmds in set to start */

/* exec vmspace-creation command set; see below */
struct exec_vmcmd_set {
	u_int	evs_cnt;
	u_int	evs_used;
	struct	exec_vmcmd *evs_cmds;
	struct	exec_vmcmd evs_start[EXEC_DEFAULT_VMCMD_SETSIZE];
};

struct exec_package {
	char	*ep_name;		/* file's name */
	void	*ep_hdr;		/* file's exec header */
	u_int	ep_hdrlen;		/* length of ep_hdr */
	u_int	ep_hdrvalid;		/* bytes of ep_hdr that are valid */
	struct nameidata *ep_ndp;	/* namei data pointer for lookups */
	struct	exec_vmcmd_set ep_vmcmds;  /* vmcmds used to build vmspace */
	struct	vnode *ep_vp;		/* executable's vnode */
	struct	vattr *ep_vap;		/* executable's attributes */
	u_long	ep_taddr;		/* process's text address */
	u_long	ep_tsize;		/* size of process's text */
	u_long	ep_daddr;		/* process's data(+bss) address */
	u_long	ep_dsize;		/* size of process's data(+bss) */
	u_long	ep_maxsaddr;		/* proc's max stack addr ("top") */
	u_long	ep_minsaddr;		/* proc's min stack addr ("bottom") */
	u_long	ep_ssize;		/* size of process's stack */
	u_long	ep_entry;		/* process's entry point */
	u_int	ep_flags;		/* flags; see below. */
	char	**ep_fa;		/* a fake args vector for scripts */
	int	ep_fd;			/* a file descriptor we're holding */
	struct  emul *ep_emul;		/* os emulation */
	void	*ep_emul_arg;		/* emulation argument */
	size_t	ep_emul_argsize;	/* emulation argument size */
	void	*ep_emul_argp;		/* emulation argument pointer */
	char	*ep_interp;		/* name of interpreter if any */
};
#define	EXEC_INDIR	0x0001		/* script handling already done */
#define	EXEC_HASFD	0x0002		/* holding a shell script */
#define	EXEC_HASARGL	0x0004		/* has fake args vector */
#define	EXEC_SKIPARG	0x0008		/* don't copy user-supplied argv[0] */
#define	EXEC_DESTR	0x0010		/* destructive ops performed */
#define	EXEC_WXNEEDED	0x0020		/* executable will violate W^X */

#ifdef _KERNEL
/*
 * functions used either by execve() or the various cpu-dependent execve()
 * hooks.
 */
int	exec_makecmds(struct proc *, struct exec_package *);
int	exec_runcmds(struct proc *, struct exec_package *);
void	vmcmdset_extend(struct exec_vmcmd_set *);
void	kill_vmcmds(struct exec_vmcmd_set *evsp);
int	vmcmd_map_pagedvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_readvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_zero(struct proc *, struct exec_vmcmd *);
int	vmcmd_randomize(struct proc *, struct exec_vmcmd *);
void	*copyargs(struct exec_package *,
				    struct ps_strings *,
				    void *, void *);
void	setregs(struct proc *, struct exec_package *,
				    u_long, register_t *);
int	check_exec(struct proc *, struct exec_package *);
int	exec_setup_stack(struct proc *, struct exec_package *);
int	exec_process_vmcmds(struct proc *, struct exec_package *);

#ifdef DEBUG
void	new_vmcmd(struct exec_vmcmd_set *evsp,
		    int (*proc)(struct proc *p, struct exec_vmcmd *),
		    u_long len, u_long addr, struct vnode *vp, u_long offset,
		    u_int prot, int flags);
#define	NEW_VMCMD(evsp,proc,len,addr,vp,offset,prot) \
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot, 0);
#define NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) \
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot,flags)
#else	/* DEBUG */
#define NEW_VMCMD(evsp,proc,len,addr,vp,offset,prot) \
	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,0)
#define	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) do { \
	struct exec_vmcmd *vcp; \
	if ((evsp)->evs_used >= (evsp)->evs_cnt) \
		vmcmdset_extend(evsp); \
	vcp = &(evsp)->evs_cmds[(evsp)->evs_used++]; \
	vcp->ev_proc = (proc); \
	vcp->ev_len = (len); \
	vcp->ev_addr = (addr); \
	if ((vcp->ev_vp = (vp)) != NULLVP) \
		vref(vp); \
	vcp->ev_offset = (offset); \
	vcp->ev_prot = (prot); \
	vcp->ev_flags = (flags); \
} while (0)

#endif /* DEBUG */

/* Initialize an empty vmcmd set */
#define VMCMDSET_INIT(vmc) do { \
	(vmc)->evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE; \
	(vmc)->evs_cmds = (vmc)->evs_start; \
	(vmc)->evs_used = 0; \
} while (0)	

/*
 * Exec function switch:
 *
 * Note that each makecmds function is responsible for loading the
 * exec package with the necessary functions for any exec-type-specific
 * handling.
 *
 * Functions for specific exec types should be defined in their own
 * header file.
 */
extern struct	execsw execsw[];
extern int	nexecs;
extern int	exec_maxhdrsz;

/*
 * If non-zero, stackgap_random specifies the upper limit of the random gap size
 * added to the fixed stack position. Must be n^2.
 */
extern int	stackgap_random;

/* Limit on total PT_OPENBSD_RANDOMIZE bytes. */
#define ELF_RANDOMIZE_LIMIT 64*1024

#endif /* _KERNEL */

#ifndef N_PAGSIZ
#define	N_PAGSIZ(ex)	(__LDPGSZ)
#endif

/*
 * Legacy a.out structures and defines; start deleting these when
 * external use no longer exist.
 */


/*
 * Header prepended to each a.out file.
 * only manipulate the a_midmag field via the
 * N_SETMAGIC/N_GET{MAGIC,MID,FLAG} macros below.
 */
struct exec {
	u_int32_t	a_midmag;	/* htonl(flags<<26|mid<<16|magic) */
	u_int32_t	a_text;		/* text segment size */
	u_int32_t	a_data;		/* initialized data size */
	u_int32_t	a_bss;		/* uninitialized data size */
	u_int32_t	a_syms;		/* symbol table size */
	u_int32_t	a_entry;	/* entry point */
	u_int32_t	a_trsize;	/* text relocation size */
	u_int32_t	a_drsize;	/* data relocation size */
};

/* a_magic */
#define	OMAGIC		0407	/* old impure format */
#define	NMAGIC		0410	/* read-only text */
#define	ZMAGIC		0413	/* demand load format */
#define	QMAGIC		0314	/* "compact" demand load format; deprecated */

/*
 * a_mid - keep sorted in numerical order for sanity's sake
 * ensure that: 0 < mid < 0x3ff
 */
#define	MID_ZERO	0	/* unknown - implementation dependent */
#define	MID_SUN010	1	/* sun 68010/68020 binary */
#define	MID_SUN020	2	/* sun 68020-only binary */
#define	MID_PC386	100	/* 386 PC binary. (so quoth BFD) */
#define	MID_ROMPAOS	104	/* old IBM RT */
#define	MID_I386	134	/* i386 BSD binary */
#define	MID_M68K	135	/* m68k BSD binary with 8K page sizes */
#define	MID_M68K4K	136	/* DO NOT USE: m68k BSD binary with 4K page sizes */
#define	MID_NS32532	137	/* ns32532 */
#define	MID_SPARC	138	/* sparc */
#define	MID_PMAX	139	/* pmax */
#define	MID_VAX1K	140	/* vax 1k page size */
#define	MID_ALPHA	141	/* Alpha BSD binary */
#define	MID_MIPS	142	/* big-endian MIPS */
#define	MID_ARM6	143	/* ARM6 */
#define	MID_SH3		145	/* SH3 */
#define	MID_POWERPC	149	/* big-endian PowerPC */
#define	MID_VAX		150	/* vax */
#define	MID_SPARC64	151	/* LP64 sparc */
#define MID_MIPS2	152	/* MIPS2 */
#define	MID_M88K	153	/* m88k BSD binary */ 
#define	MID_HPPA	154	/* hppa */
#define	MID_AMD64	157	/* AMD64 */
#define	MID_MIPS64	158	/* big-endian MIPS64 */
#define	MID_ARM64	159	/* ARM64 */
#define	MID_HP200	200	/* hp200 (68010) BSD binary */
#define	MID_HP300	300	/* hp300 (68020+68881) BSD binary */
#define	MID_HPUX	0x20C	/* hp200/300 HP-UX binary */
#define	MID_HPUX800	0x20B	/* hp800 HP-UX binary pa1.0 */
#define	MID_HPPA11	0x210	/* hp700 HP-UX binary pa1.1 */
#define	MID_HPPA20	0x214	/* hp700 HP-UX binary pa2.0 */

/*
 * a_flags
 */
#define EX_DYNAMIC	0x20
#define EX_PIC		0x10
#define EX_DPMASK	0x30
/*
 * Interpretation of the (a_flags & EX_DPMASK) bits:
 *
 *	00		traditional executable or object file
 *	01		object file contains PIC code (set by `as -k')
 *	10		dynamic executable
 *	11		position independent executable image
 * 			(eg. a shared library)
 *
 */

/*
 * The a.out structure's a_midmag field is a network-byteorder encoding
 * of this int
 *	FFFFFFmmmmmmmmmmMMMMMMMMMMMMMMMM
 * Where `F' is 6 bits of flag like EX_DYNAMIC,
 *       `m' is 10 bits of machine-id like MID_I386, and
 *       `M' is 16 bits worth of magic number, ie. ZMAGIC.
 * The macros below will set/get the needed fields.
 */
#define	N_GETMAGIC(ex) \
    ( (((ex).a_midmag)&0xffff0000) ? (ntohl(((ex).a_midmag))&0xffff) : ((ex).a_midmag))
#define	N_GETMAGIC2(ex) \
    ( (((ex).a_midmag)&0xffff0000) ? (ntohl(((ex).a_midmag))&0xffff) : \
    (((ex).a_midmag) | 0x10000) )
#define	N_GETMID(ex) \
    ( (((ex).a_midmag)&0xffff0000) ? ((ntohl(((ex).a_midmag))>>16)&0x03ff) : MID_ZERO )
#define	N_GETFLAG(ex) \
    ( (((ex).a_midmag)&0xffff0000) ? ((ntohl(((ex).a_midmag))>>26)&0x3f) : 0 )
#define	N_SETMAGIC(ex,mag,mid,flag) \
    ( (ex).a_midmag = htonl( (((flag)&0x3f)<<26) | (((mid)&0x03ff)<<16) | \
    (((mag)&0xffff)) ) )

#define	N_ALIGN(ex,x) \
	(N_GETMAGIC(ex) == ZMAGIC || N_GETMAGIC(ex) == QMAGIC ? \
	((x) + __LDPGSZ - 1) & ~(__LDPGSZ - 1) : (x))

/* Valid magic number check. */
#define	N_BADMAG(ex) \
	(N_GETMAGIC(ex) != NMAGIC && N_GETMAGIC(ex) != OMAGIC && \
	N_GETMAGIC(ex) != ZMAGIC && N_GETMAGIC(ex) != QMAGIC)

/* Address of the bottom of the text segment. */
#define	N_TXTADDR(ex)	(N_GETMAGIC2(ex) == (ZMAGIC|0x10000) ? 0 : __LDPGSZ)

/* Address of the bottom of the data segment. */
#define	N_DATADDR(ex) \
	(N_GETMAGIC(ex) == OMAGIC ? N_TXTADDR(ex) + (ex).a_text : \
	(N_TXTADDR(ex) + (ex).a_text + __LDPGSZ - 1) & ~(__LDPGSZ - 1))

/* Address of the bottom of the bss segment. */
#define	N_BSSADDR(ex) \
	(N_DATADDR(ex) + (ex).a_data)

/* Text segment offset. */
#define	N_TXTOFF(ex) \
	( N_GETMAGIC2(ex)==ZMAGIC || N_GETMAGIC2(ex)==(QMAGIC|0x10000) ? \
	0 : (N_GETMAGIC2(ex)==(ZMAGIC|0x10000) ? __LDPGSZ : \
	sizeof(struct exec)) )

/* Data segment offset. */
#define	N_DATOFF(ex) \
	N_ALIGN(ex, N_TXTOFF(ex) + (ex).a_text)

/* Text relocation table offset. */
#define	N_TRELOFF(ex) \
	(N_DATOFF(ex) + (ex).a_data)

/* Data relocation table offset. */
#define	N_DRELOFF(ex) \
	(N_TRELOFF(ex) + (ex).a_trsize)

/* Symbol table offset. */
#define	N_SYMOFF(ex) \
	(N_DRELOFF(ex) + (ex).a_drsize)

/* String table offset. */
#define	N_STROFF(ex) \
	(N_SYMOFF(ex) + (ex).a_syms)

#include <machine/exec.h>

#endif /* !_SYS_EXEC_H_ */
@


1.35
log
@Add MID for arm64.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.34 2016/05/30 21:31:27 deraadt Exp $	*/
a137 1
	u_long	ep_interp_pos;		/* interpreter load position */
@


1.34
log
@Identify W^X labelled binaries at execve() time based upon WX_OPENBSD_WXNEEDED
flag set by ld -zwxneeded.  Such binaries are allowed to run only on wxallowed
mountpoints.  They do not report mmap/mprotect problems.

Rate limit mmap/mprotect reports from other binaries.

These semantics are chosen to encourage progress in the ports ecosystem,
without overwhelming the developers who work in the area.
ok sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.32 2016/05/30 21:22:45 deraadt Exp $	*/
d290 1
@


1.33
log
@backout to insert correct commit message
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.31 2015/09/28 20:32:59 deraadt Exp $	*/
d145 1
@


1.32
log
@*** empty log message ***
@
text
@a144 1
#define	EXEC_WXNEEDED	0x0020		/* executable will violate W^X */
@


1.31
log
@Track size of an opaque allocation to pass to free() later
ok guenther tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.30 2015/02/09 11:52:47 miod Exp $	*/
d145 1
@


1.30
log
@Change the way stackgap_random is applied. Instead of applying it within the
fixed stack area of the exec'd image, and risking hitting process limits,
should we want to increase stackgap_random, the randomness is applied to the
stack region in the process' vmspace.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.29 2015/02/06 23:58:12 deraadt Exp $	*/
d135 1
@


1.29
log
@Raise ELF_RANDOMIZE_LIMIT to 64K, so that programs and libraries can
legitimately use random section variables without execve failures...
Because this section is not demand faulted, yield() every page during
the fill otherwise the costs are charged poorly.
ok tedu matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.28 2015/01/26 22:51:37 kettenis Exp $	*/
d216 6
@


1.28
log
@Move the "stackgap" from the stack into its own page at a random address.
This allows us the unmap the initial part of the stack, such that it can't
be used as a staging area for ROP (or other) attacks.

ok guenther@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.27 2013/10/17 08:02:20 deraadt Exp $	*/
d216 3
@


1.27
log
@Remove support for a.out and ecoff.  We only do elf now.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.26 2012/08/20 23:25:07 matthew Exp $	*/
a60 10
 * Address of ps_strings structure (in user space).
 */
#ifdef MACHINE_STACK_GROWS_UP
#define	PS_STRINGS	((struct ps_strings *)(USRSTACK))
#else
#define	PS_STRINGS \
	((struct ps_strings *)(USRSTACK - sizeof(struct ps_strings)))
#endif

/*
a64 10

#ifdef MACHINE_STACK_GROWS_UP
#define	STACKGAPBASE_UNALIGNED	\
	((caddr_t)PS_STRINGS + sizeof(struct ps_strings))
#else
#define	STACKGAPBASE_UNALIGNED	\
	((caddr_t)PS_STRINGS - STACKGAPLEN)
#endif
#define	STACKGAPBASE		\
	((caddr_t)ALIGN(STACKGAPBASE_UNALIGNED))
@


1.26
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.25 2009/07/09 22:29:56 thib Exp $	*/
d239 153
a391 1
#include <sys/exec_aout.h>
@


1.25
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.23 2007/01/29 11:33:24 otto Exp $	*/
d177 1
@


1.24
log
@More comment typos from Diego Casati. Including winners like funtion, allmost,
oustside, seqencer, toghether, nessissary, etc.
@
text
@d207 1
a207 1
		VREF(vp); \
@


1.23
log
@Bump fixed part of the stackgap to 2k. Allows two full paths to be
stored, needed by systrace. ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.22 2004/04/15 00:22:42 tedu Exp $	*/
d167 1
a167 1
 * funtions used either by execve() or the various cpu-dependent execve()
@


1.22
log
@rework access to emulations slightly in an effort to both merge and
separate exec format from emulation.  consistent naming of freebsd emuls.
not much in the way of functional changes yet.
testing and ok deraadt@@ and others along the way.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.21 2003/06/02 23:28:21 millert Exp $	*/
d74 1
a74 1
#define	STACKGAPLEN	512	/* plenty enough for now */
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.20 2002/12/03 21:27:05 markus Exp $	*/
d107 1
@


1.20
log
@unconditionally define STACKGAPLEN, enables systrace(4) without COMPAT_*;
pr 3012; ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.19 2002/10/06 22:40:19 art Exp $	*/
d23 1
a23 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@unused prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.18 2002/10/06 22:39:25 art Exp $	*/
a77 4
#if defined(COMPAT_SUNOS) || defined(COMPAT_ULTRIX) || \
    defined(COMPAT_IBCS2) || defined(COMPAT_SVR4) || defined(COMPAT_OSF1) || \
    defined(COMPAT_LINUX) || defined(COMPAT_FREEBSD) || \
    defined(COMPAT_HPUX)  || defined(COMPAT_NETBSD) || defined(__sparc64__)
d79 1
a79 3
#else
#define	STACKGAPLEN	0
#endif
@


1.18
log
@Move out the execution of vmcmds into a separate function.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.17 2002/09/23 01:41:09 art Exp $	*/
a178 1
void	kill_vmcmd(struct exec_vmcmd **);
@


1.17
log
@Add support for vmcmds that load sections relative to a base section.
You mark one section with VMCMD_BASE and the rest are marked RELATIVE.
Use that to load ELF interpreter correctly in all cases.

Inspired by NetBSD. Great debugging help from drahn@@
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.16 2002/07/20 19:24:57 art Exp $	*/
d194 1
@


1.16
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.15 2002/07/19 01:06:18 jason Exp $	*/
d127 3
d199 1
a199 1
		    u_int prot);
d201 3
a203 1
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot);
d205 3
a207 1
#define	NEW_VMCMD(evsp,proc,len,addr,vp,offset,prot) { \
d219 3
a221 1
}
@


1.15
log
@give sparc64 the normal STACKGAPLEN (512), this allows systrace(4) to work
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.14 2002/03/14 03:16:12 millert Exp $	*/
d88 1
a88 1
	((caddr_t)PS_STRINGS + sizeof(struct ps_strings) + (u_long)szsigcode)
d91 1
a91 1
	((caddr_t)PS_STRINGS - szsigcode - STACKGAPLEN)
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.13 2002/03/14 01:27:14 millert Exp $	*/
d81 1
a81 1
    defined(COMPAT_HPUX)  || defined(COMPAT_NETBSD)
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.12 2001/06/22 14:11:00 deraadt Exp $	*/
d193 1
a193 1
void	new_vmcmd __P((struct exec_vmcmd_set *evsp,
d196 1
a196 1
		    u_int prot));
@


1.12
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.11 2001/04/07 22:02:20 tholo Exp $	*/
d112 1
a112 1
typedef int (*exec_makecmds_fcn) __P((struct proc *, struct exec_package *));
d120 1
a120 1
	int	(*ev_proc) __P((struct proc *p, struct exec_vmcmd *cmd));
d176 9
a184 9
void	kill_vmcmd		__P((struct exec_vmcmd **));
int	exec_makecmds		__P((struct proc *, struct exec_package *));
int	exec_runcmds		__P((struct proc *, struct exec_package *));
void	vmcmdset_extend		__P((struct exec_vmcmd_set *));
void	kill_vmcmds		__P((struct exec_vmcmd_set *evsp));
int	vmcmd_map_pagedvn	__P((struct proc *, struct exec_vmcmd *));
int	vmcmd_map_readvn	__P((struct proc *, struct exec_vmcmd *));
int	vmcmd_map_zero		__P((struct proc *, struct exec_vmcmd *));
void	*copyargs		__P((struct exec_package *,
d186 5
a190 5
				    void *, void *));
void	setregs			__P((struct proc *, struct exec_package *,
				    u_long, register_t *));
int	check_exec		__P((struct proc *, struct exec_package *));
int	exec_setup_stack	__P((struct proc *, struct exec_package *));
d194 1
a194 1
		    int (*proc) __P((struct proc *p, struct exec_vmcmd *)),
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.12 2001/06/22 14:11:00 deraadt Exp $	*/
d112 1
a112 1
typedef int (*exec_makecmds_fcn)(struct proc *, struct exec_package *);
d120 1
a120 1
	int	(*ev_proc)(struct proc *p, struct exec_vmcmd *cmd);
d176 9
a184 9
void	kill_vmcmd(struct exec_vmcmd **);
int	exec_makecmds(struct proc *, struct exec_package *);
int	exec_runcmds(struct proc *, struct exec_package *);
void	vmcmdset_extend(struct exec_vmcmd_set *);
void	kill_vmcmds(struct exec_vmcmd_set *evsp);
int	vmcmd_map_pagedvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_readvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_zero(struct proc *, struct exec_vmcmd *);
void	*copyargs(struct exec_package *,
d186 5
a190 5
				    void *, void *);
void	setregs(struct proc *, struct exec_package *,
				    u_long, register_t *);
int	check_exec(struct proc *, struct exec_package *);
int	exec_setup_stack(struct proc *, struct exec_package *);
d193 2
a194 2
void	new_vmcmd(struct exec_vmcmd_set *evsp,
		    int (*proc)(struct proc *p, struct exec_vmcmd *),
d196 1
a196 1
		    u_int prot);
@


1.12.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.12.4.1 2002/06/11 03:32:33 art Exp $	*/
d81 1
a81 1
    defined(COMPAT_HPUX)  || defined(COMPAT_NETBSD) || defined(__sparc64__)
d88 1
a88 1
	((caddr_t)PS_STRINGS + sizeof(struct ps_strings))
d91 1
a91 1
	((caddr_t)PS_STRINGS - STACKGAPLEN)
a126 3
	int	ev_flags;
#define VMCMD_RELATIVE  0x0001  /* ev_addr is relative to base entry */
#define VMCMD_BASE      0x0002  /* marks a base entry */
d176 1
a190 1
int	exec_process_vmcmds(struct proc *, struct exec_package *);
d196 1
a196 1
		    u_int prot, int flags);
d198 1
a198 3
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot, 0);
#define NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) \
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot,flags)
d200 1
a200 3
#define NEW_VMCMD(evsp,proc,len,addr,vp,offset,prot) \
	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,0)
#define	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) do { \
d212 1
a212 3
	vcp->ev_flags = (flags); \
} while (0)

@


1.12.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d78 4
d83 3
a85 1

@


1.11
log
@Stack gap no longer fits common structures (like struct statfs), causing
many emulated system calls (SysV, Linux, others) to fail.  Bump from 400
up to 512 bytes; ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.10 2001/04/01 21:30:32 art Exp $	*/
d184 3
a186 2
void	*copyargs		__P((struct exec_package *, struct ps_strings *,
				     void *, void *));
d188 1
a188 1
				     u_long, register_t *));
d209 3
a211 3
                VREF(vp); \
        vcp->ev_offset = (offset); \
        vcp->ev_prot = (prot); \
@


1.10
log
@Add a macro to initialize the contents of a vmcmd set.
Correctly initialize the vmcmds in linux_exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.9 2001/02/22 16:08:01 art Exp $	*/
d82 1
a82 1
#define	STACKGAPLEN	400	/* plenty enough for now */
@


1.9
log
@ELF uses more than 5 vmcmds by default, so grow the default vmcmd set size
to 8.

At the same time it seemed like a good idea to avoid to always malloc a
new vmcmd array, so put the default sized array into struct exec_vmcmd_set.

We might want to make a linked list of vmcmd arrays or exec_vmcmd_sets instead
of reallocating them some time in the future, but right now this seems like a
waste of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.8 1999/11/05 01:18:01 mickey Exp $	*/
d212 8
a219 1
#endif /* EXEC_DEBUG */
@


1.8
log
@more stack direction fixes; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.7 1999/09/25 10:59:24 kstailey Exp $	*/
d119 12
d136 1
a138 2
#define	EXEC_DEFAULT_VMCMD_SETSIZE	5	/* # of cmds in set to start */

a169 10

struct exec_vmcmd {
	int	(*ev_proc) __P((struct proc *p, struct exec_vmcmd *cmd));
				/* procedure to run for region of vmspace */
	u_long	ev_len;		/* length of the segment to map */
	u_long	ev_addr;	/* address in the vmspace to place it at */
	struct	vnode *ev_vp;	/* vnode pointer for the file w/the data */
	u_long	ev_offset;	/* offset in the file for the data */
	u_int	ev_prot;	/* protections for segment */
};
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.11 2001/04/07 22:02:20 tholo Exp $	*/
d82 1
a82 1
#define	STACKGAPLEN	512	/* plenty enough for now */
a118 12
struct exec_vmcmd {
	int	(*ev_proc) __P((struct proc *p, struct exec_vmcmd *cmd));
				/* procedure to run for region of vmspace */
	u_long	ev_len;		/* length of the segment to map */
	u_long	ev_addr;	/* address in the vmspace to place it at */
	struct	vnode *ev_vp;	/* vnode pointer for the file w/the data */
	u_long	ev_offset;	/* offset in the file for the data */
	u_int	ev_prot;	/* protections for segment */
};

#define	EXEC_DEFAULT_VMCMD_SETSIZE	8	/* # of cmds in set to start */

a123 1
	struct	exec_vmcmd evs_start[EXEC_DEFAULT_VMCMD_SETSIZE];
d126 2
d160 10
d211 1
a211 8
#endif /* DEBUG */

/* Initialize an empty vmcmd set */
#define VMCMDSET_INIT(vmc) do { \
	(vmc)->evs_cnt = EXEC_DEFAULT_VMCMD_SETSIZE; \
	(vmc)->evs_cmds = (vmc)->evs_start; \
	(vmc)->evs_used = 0; \
} while (0)	
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.8.2.1 2001/05/14 22:45:01 niklas Exp $	*/
d184 2
a185 3
void	*copyargs		__P((struct exec_package *,
				    struct ps_strings *,
				    void *, void *));
d187 1
a187 1
				    u_long, register_t *));
d208 3
a210 3
		VREF(vp); \
	vcp->ev_offset = (offset); \
	vcp->ev_prot = (prot); \
@


1.8.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
typedef int (*exec_makecmds_fcn)(struct proc *, struct exec_package *);
d120 1
a120 1
	int	(*ev_proc)(struct proc *p, struct exec_vmcmd *cmd);
d176 9
a184 9
void	kill_vmcmd(struct exec_vmcmd **);
int	exec_makecmds(struct proc *, struct exec_package *);
int	exec_runcmds(struct proc *, struct exec_package *);
void	vmcmdset_extend(struct exec_vmcmd_set *);
void	kill_vmcmds(struct exec_vmcmd_set *evsp);
int	vmcmd_map_pagedvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_readvn(struct proc *, struct exec_vmcmd *);
int	vmcmd_map_zero(struct proc *, struct exec_vmcmd *);
void	*copyargs(struct exec_package *,
d186 5
a190 5
				    void *, void *);
void	setregs(struct proc *, struct exec_package *,
				    u_long, register_t *);
int	check_exec(struct proc *, struct exec_package *);
int	exec_setup_stack(struct proc *, struct exec_package *);
d193 2
a194 2
void	new_vmcmd(struct exec_vmcmd_set *evsp,
		    int (*proc)(struct proc *p, struct exec_vmcmd *),
d196 1
a196 1
		    u_int prot);
@


1.8.2.4
log
@Sync the SMP branch with 3.3
@
text
@d78 4
d83 3
a85 1

d88 1
a88 1
	((caddr_t)PS_STRINGS + sizeof(struct ps_strings))
d91 1
a91 1
	((caddr_t)PS_STRINGS - STACKGAPLEN)
a126 3
	int	ev_flags;
#define VMCMD_RELATIVE  0x0001  /* ev_addr is relative to base entry */
#define VMCMD_BASE      0x0002  /* marks a base entry */
d176 1
a190 1
int	exec_process_vmcmds(struct proc *, struct exec_package *);
d196 1
a196 1
		    u_int prot, int flags);
d198 1
a198 3
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot, 0);
#define NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) \
	new_vmcmd(evsp,proc,len,addr,vp,offset,prot,flags)
d200 1
a200 3
#define NEW_VMCMD(evsp,proc,len,addr,vp,offset,prot) \
	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,0)
#define	NEW_VMCMD2(evsp,proc,len,addr,vp,offset,prot,flags) do { \
d212 1
a212 3
	vcp->ev_flags = (flags); \
} while (0)

@


1.8.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.8.2.4 2003/03/28 00:41:30 niklas Exp $	*/
d23 5
a27 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.2.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a106 1
	struct emul *es_emul;		/* emulation */
@


1.7
log
@STACKGAPLEN of 400 for COMPAT_NETBSD too--trampoline preservative
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.6 1997/01/12 13:02:07 downsj Exp $	*/
d67 3
d72 1
d86 4
d92 1
d94 1
a94 1
	((caddr_t)(((unsigned long) STACKGAPBASE_UNALIGNED) & ~ALIGNBYTES))
@


1.6
log
@protect against multiple includes
@
text
@d1 1
a1 1
/*	$OpenBSD: exec.h,v 1.5 1996/12/23 02:42:39 deraadt Exp $	*/
d76 2
a77 1
    defined(COMPAT_LINUX) || defined(COMPAT_FREEBSD) || defined(COMPAT_HPUX)
@


1.5
log
@use _{NLIST,KERN}_DO_{AOUT,ELF,ECOFF} to select binary types
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 3
d221 2
@


1.4
log
@Some more data in package
@
text
@d175 1
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d137 3
@


1.2
log
@from netbsd; hpux also needs a stackgap
@
text
@d1 2
a2 1
/*	$NetBSD: exec.h,v 1.58 1995/11/28 08:16:47 thorpej Exp $	*/
d171 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: exec.h,v 1.57 1995/10/10 01:27:07 mycroft Exp $	*/
d72 1
a72 1
    defined(COMPAT_LINUX) || defined(COMPAT_FREEBSD)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
