head	1.54;
access;
symbols
	OPENBSD_6_1:1.54.0.8
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.50.0.6
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.45.0.4
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.6
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.41.0.4
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.37.0.10
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.6
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.4
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.30.0.2
	OPENBSD_3_9_BASE:1.30
	OPENBSD_3_8:1.29.0.4
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.27.0.6
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.4
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.26
	UBC:1.20.0.4
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.6
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.17.0.4
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.2
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.13.0.4
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.54
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.53;
commitid	fbhqfhfdKxBcsetK;

1.53
date	2015.09.11.20.43.23;	author dlg;	state Exp;
branches;
next	1.52;
commitid	lTmV1RMoNjwk10Nu;

1.52
date	2015.09.11.19.14.51;	author dlg;	state Exp;
branches;
next	1.51;
commitid	tcvJK23Xd1SxOg7k;

1.51
date	2015.09.11.07.13.58;	author miod;	state Exp;
branches;
next	1.50;
commitid	WZlt70060zREibS9;

1.50
date	2014.09.18.18.54.29;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	TX9jsBqgspzyUKq3;

1.49
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.13.03.52.56;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2013.12.06.21.03.01;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.27.00.00.53;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.08.21.47.51;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.01.04.35.22;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	2010.08.31.17.13.48;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.23.14.12.10;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2009.11.22.21.36.06;	author pirofti;	state Exp;
branches;
next	1.39;

1.39
date	2009.11.22.18.40.13;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.24.18.31.05;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.15.01.56.47;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.10.17.59.27;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.04.19.30.55;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.04.03.44.45;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.05.28.03.22.35;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2006.05.27.23.51.27;	author mk;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.21.12.20.53;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.23.19.08.55;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.11.17.14.12.59;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.10.06.23.12.31;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.06.18.12.47;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.27.01.19.52;	author wcobb;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.01.05.48.18;	author jason;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	2001.06.22.14.10.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.09.19.23.18;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	99.08.08.00.37.09;	author niklas;	state Exp;
branches
	1.17.4.1;
next	1.16;

1.16
date	99.08.05.17.41.43;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.07.23.19.45.20;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.04.28.18.01.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.05.11.09.59.37;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.08.07.10.34.48;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.08.07.10.22.51;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.11.23.21.47.13;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.11.21.12.47.17;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.07.02.07.58.39;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.23.19.32.56;	author maja;	state Exp;
branches;
next	1.6;

1.6
date	96.06.16.10.29.55;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.29.14.17.53;	author hvozda;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.31.38;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.21.40.51;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.11.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.17.4.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.17.4.2;

1.17.4.2
date	2001.07.04.11.00.15;	author niklas;	state Exp;
branches;
next	1.17.4.3;

1.17.4.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.17.4.4;

1.17.4.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.17.4.5;

1.17.4.5
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.17.4.6;

1.17.4.6
date	2003.05.18.17.41.16;	author niklas;	state Exp;
branches;
next	1.17.4.7;

1.17.4.7
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.17.4.8;

1.17.4.8
date	2004.06.06.21.57.11;	author deraadt;	state Exp;
branches;
next	;

1.20.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@/*	$OpenBSD: device.h,v 1.53 2015/09/11 20:43:23 dlg Exp $	*/
/*	$NetBSD: device.h,v 1.15 1996/04/09 20:55:24 cgd Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)device.h	8.2 (Berkeley) 2/17/94
 */

#ifndef _SYS_DEVICE_H_
#define	_SYS_DEVICE_H_

#include <sys/queue.h>

/*
 * Minimal device structures.
 * Note that all ``system'' device types are listed here.
 */
enum devclass {
	DV_DULL,		/* generic, no special info */
	DV_CPU,			/* CPU (carries resource utilization) */
	DV_DISK,		/* disk drive (label, etc) */
	DV_IFNET,		/* network interface */
	DV_TAPE,		/* tape device */
	DV_TTY			/* serial line interface (???) */
};

/*
 * Actions for ca_activate.
 */
#define	DVACT_DEACTIVATE	1	/* deactivate the device */
#define	DVACT_QUIESCE		2	/* warn the device about suspend */
#define	DVACT_SUSPEND		3	/* suspend the device */
#define	DVACT_RESUME		4	/* resume the device */
#define	DVACT_WAKEUP		5	/* tell device to recover after resume */
#define	DVACT_POWERDOWN		6	/* power device down */

struct device {
	enum	devclass dv_class;	/* this device's classification */
	TAILQ_ENTRY(device) dv_list;	/* entry on list of all devices */
	struct	cfdata *dv_cfdata;	/* config data that found us */
	int	dv_unit;		/* device unit number */
	char	dv_xname[16];		/* external name (name + unit) */
	struct	device *dv_parent;	/* pointer to parent device */
	int	dv_flags;		/* misc. flags; see below */
	int	dv_ref;			/* ref count */
};

/* dv_flags */
#define	DVF_ACTIVE	0x0001		/* device is activated */

TAILQ_HEAD(devicelist, device);

/*
 * Configuration data (i.e., data placed in ioconf.c).
 */
struct cfdata {
	struct	cfattach *cf_attach;	/* config attachment */
	struct	cfdriver *cf_driver;	/* config driver */
	short	cf_unit;		/* unit number */
	short	cf_fstate;		/* finding state (below) */
	long	*cf_loc;		/* locators (machine dependent) */
	int	cf_flags;		/* flags from config */
	short	*cf_parents;		/* potential parents */
	int	cf_locnames;		/* start of names */
	short	cf_starunit1;		/* 1st usable unit number by STAR */
};
extern struct cfdata cfdata[];
#define FSTATE_NOTFOUND	0	/* has not been found */
#define	FSTATE_FOUND	1	/* has been found */
#define	FSTATE_STAR	2	/* duplicable */
#define FSTATE_DNOTFOUND 3	/* has not been found, and is disabled */
#define FSTATE_DSTAR	4	/* duplicable, and is disabled */

typedef int (*cfmatch_t)(struct device *, void *, void *);
typedef void (*cfscan_t)(struct device *, void *);

/*
 * `configuration' attachment and driver (what the machine-independent
 * autoconf uses).  As devices are found, they are applied against all
 * the potential matches.  The one with the best match is taken, and a
 * device structure (plus any other data desired) is allocated.  Pointers
 * to these are placed into an array of pointers.  The array itself must
 * be dynamic since devices can be found long after the machine is up
 * and running.
 *
 * Devices can have multiple configuration attachments if they attach
 * to different attributes (busses, or whatever), to allow specification
 * of multiple match and attach functions.  There is only one configuration
 * driver per driver, so that things like unit numbers and the device
 * structure array will be shared.
 */
struct cfattach {
	size_t	  ca_devsize;		/* size of dev data (for malloc) */
	cfmatch_t ca_match;		/* returns a match level */
	void	(*ca_attach)(struct device *, struct device *, void *);
	int	(*ca_detach)(struct device *, int);
	int	(*ca_activate)(struct device *, int);
};

/* Flags given to config_detach(), and the ca_detach function. */
#define	DETACH_FORCE	0x01		/* force detachment; hardware gone */
#define	DETACH_QUIET	0x02		/* don't print a notice */

struct cfdriver {
	void	**cd_devs;		/* devices found */
	char	*cd_name;		/* device name */
	enum	devclass cd_class;	/* device classification */
	int	cd_indirect;		/* indirectly configure subdevices */
	int	cd_ndevs;		/* size of cd_devs array */
};

/*
 * Configuration printing functions, and their return codes.  The second
 * argument is NULL if the device was configured; otherwise it is the name
 * of the parent device.  The return value is ignored if the device was
 * configured, so most functions can return UNCONF unconditionally.
 */
typedef int (*cfprint_t)(void *, const char *);
#define	QUIET	0		/* print nothing */
#define	UNCONF	1		/* print " not configured\n" */
#define	UNSUPP	2		/* print " not supported\n" */

/*
 * Pseudo-device attach information (function + number of pseudo-devs).
 */
struct pdevinit {
	void	(*pdev_attach)(int);
	int	pdev_count;
};

#ifdef _KERNEL
extern struct devicelist alldevs;	/* list of all devices */

extern int autoconf_verbose;
extern volatile int config_pending;	/* semaphore for mountroot */

void config_init(void);
void *config_search(cfmatch_t, struct device *, void *);
struct device *config_found_sm(struct device *, void *, cfprint_t,
    cfmatch_t);
struct device *config_rootfound(char *, void *);
void config_scan(cfscan_t, struct device *);
struct device *config_attach(struct device *, void *, void *, cfprint_t);
int config_detach(struct device *, int);
int config_detach_children(struct device *, int);
int config_deactivate(struct device *);
int config_suspend(struct device *, int);
int config_suspend_all(int);
int config_activate_children(struct device *, int);
struct device *config_make_softc(struct device *parent,
    struct cfdata *cf);
void config_defer(struct device *, void (*)(struct device *));
void config_pending_incr(void);
void config_pending_decr(void);
void config_mountroot(struct device *, void (*)(struct device *));
void config_process_deferred_mountroot(void);

struct device *device_mainbus(void);
struct device *device_mpath(void);
struct device *device_lookup(struct cfdriver *, int unit);
void device_ref(struct device *);
void device_unref(struct device *);

struct nam2blk {
	char	*name;
	int	maj;
};

int	findblkmajor(struct device *dv);
char	*findblkname(int);
void	setroot(struct device *, int, int);
struct	device *getdisk(char *str, int len, int defpart, dev_t *devp);
struct	device *parsedisk(char *str, int len, int defpart, dev_t *devp);
void	device_register(struct device *, void *);

int loadfirmware(const char *name, u_char **bufp, size_t *buflen);
#define FIRMWARE_MAX	5*1024*1024

/* compatibility definitions */
#define config_found(d, a, p)	config_found_sm((d), (a), (p), NULL)

#endif /* _KERNEL */

#endif /* !_SYS_DEVICE_H_ */
@


1.53
log
@back out refcnt for dv_ref, there's too many hand crafted devices all
over the tree.

much encouragement from l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.52 2015/09/11 19:14:51 dlg Exp $	*/
a173 1
void *config_rootsearch(cfmatch_t, char *, void *);
d190 2
@


1.52
log
@use refcnts for the device reference counts as an example of how
refcnt(9) can be used.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.51 2015/09/11 07:13:58 miod Exp $	*/
a47 1
#include <sys/refcnt.h>
d80 1
a80 1
	struct	refcnt dv_ref;		/* ref count */
@


1.51
log
@Change device locators type from int to long, for the sake of 64-bit ports
without proper device trees.

Be sure to build and install config(8) and rerun it before attempting to build
a kernel.

ok kettenis@@ deraadt@@ jasper@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.50 2014/09/18 18:54:29 kettenis Exp $	*/
d48 1
d81 1
a81 1
	int	dv_ref;			/* ref count */
@


1.50
log
@Introduce config_suspend_all(9) a function that invokes config_suspend(9)
on all relevant device hierarchies in the appropriate order.  For now this
means mpath(4) and mainbus(4), doing mpath(4) before mainbus(4) when
suspending or powering down and doing mpath(4) after mainbus(4) when
resuming such that mpath(4) can realy on the underlying hardware being
in a functional state.

Fixes problems with unflushed disk caches on machines where mpath(4) takes
control of some of your disks.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.49 2014/03/29 18:09:31 guenther Exp $	*/
d96 1
a96 1
	int	*cf_loc;		/* locators (machine dependent) */
@


1.49
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.48 2014/03/13 03:52:56 dlg Exp $	*/
d184 1
d193 1
@


1.48
log
@get rid of the assumption that the head of the alldevs list is the
"mainbus" device. this breaks when mpath is enabled because it
attaches before mainbus and therefore takes the head position.

have autoconf provide device_mainbus() which looks up mainbus_cd,
and use that instead.

discussed with deraadt who just wants mpath stuff to move forward
despite there being many ways to shine this particular turd.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.47 2013/12/06 21:03:01 deraadt Exp $	*/
d170 1
a170 1
extern __volatile int config_pending;	/* semaphore for mountroot */
@


1.47
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.46 2013/11/27 00:00:53 dlg Exp $	*/
d191 1
@


1.46
log
@get rid of the goop for maintaining multiple cftables since theres
no current code there to add or remove them. such code was put in
17 years ago, disabled 14 years ago, and removed 11 years ago, so
i suspect we dont really need it or the goop to support it.

very ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.45 2012/10/08 21:47:51 deraadt Exp $	*/
d66 5
a70 4
#define	DVACT_SUSPEND		2	/* suspend the device */
#define	DVACT_RESUME		3	/* resume the device */
#define	DVACT_QUIESCE		4	/* warn the device about suspend */
#define	DVACT_POWERDOWN		5	/* power device down */
@


1.45
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.44 2011/07/03 15:47:16 matthew Exp $	*/
a165 6
struct cftable {
	struct cfdata *tab;
	TAILQ_ENTRY(cftable) list;
};
TAILQ_HEAD(cftable_head, cftable);

@


1.44
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.43 2011/06/01 04:35:22 matthew Exp $	*/
d69 1
@


1.43
log
@Kill the nearly-15-years-dead cf_ivstubs field from struct cfdata.

ok miod@@, deraadt@@

N.B.: If you're following -current, you MUST recompile config(8) and
re-config your kernel or else ioconf.c will fail to compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.42 2010/08/31 17:13:48 deraadt Exp $	*/
a64 1
#define	DVACT_ACTIVATE		0	/* activate the device */
a185 1
int config_activate(struct device *);
@


1.42
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.41 2009/11/23 14:12:10 deraadt Exp $	*/
a98 1
	void	(**cf_ivstubs)(void);	/* config-generated vectors, if any */
@


1.41
log
@Make config_activate_children() more useable as a suspend-and-resume
device tree walker, and add config_suspend() as well.
ok mlarkin pirofti, discussion with kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.40 2009/11/22 21:36:06 pirofti Exp $	*/
d69 1
@


1.40
log
@Forgot the declarations in former commit. From martin@@, okay oga@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.39 2009/11/22 18:40:13 pirofti Exp $	*/
a82 1
#define	DVF_SUSPEND	0x0002		/* device is suspended */
d189 1
a189 2
int config_suspend(struct device *);
int config_resume(struct device *);
@


1.39
log
@Add basic suspend/resume autoconf functionality.

Okay deraadt@@, kettenis@@, mlarkin@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.38 2009/10/13 19:33:19 pirofti Exp $	*/
d190 2
@


1.38
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.37 2007/11/24 18:31:05 dlg Exp $	*/
d67 2
d83 1
@


1.37
log
@we dont need ot include sys/lock.h here

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.36 2007/05/15 01:56:47 deraadt Exp $	*/
d65 2
a66 4
enum devact {
	DVACT_ACTIVATE,		/* activate the device */
	DVACT_DEACTIVATE	/* deactivate the device */
};
d129 1
a129 1
	int	(*ca_activate)(struct device *, enum devact);
d187 1
a187 1
int config_activate_children(struct device *, enum devact);
@


1.36
log
@kill __HAVE_DEVICE_REGISTER by requiring all architectures to have a
device_register() function -- even if it does nothing.  reduces the
cpp-based blather different between architectures
idea ok'd by miod; tested on all architectures (except a few miod will
need to cleanup because he has them)
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.35 2007/05/10 17:59:27 deraadt Exp $	*/
a68 2

#include <sys/lock.h>
@


1.35
log
@evcnt & friends were replaced by a proper interrupt counting mechanism 3 years ago; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.34 2007/05/04 19:30:55 deraadt Exp $	*/
d212 1
a212 4

#ifdef __HAVE_DEVICE_REGISTER
void device_register(struct device *, void *);
#endif
@


1.34
log
@make findblkmajor() and findblkname() MI; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.33 2007/05/04 03:44:45 deraadt Exp $	*/
a87 9
/* `event' counters (use zero or more per device instance, as needed) */
struct evcnt {
	TAILQ_ENTRY(evcnt) ev_list;	/* entry on list of all counters */
	struct	device *ev_dev;		/* associated device */
	int	ev_count;		/* how many have occurred */
	char	ev_name[8];		/* what to call them (systat display) */
};
TAILQ_HEAD(evcntlist, evcnt);

a174 1
extern struct evcntlist allevents;	/* list of all event counters */
a194 1
void evcnt_attach(struct device *, const char *, struct evcnt *);
@


1.33
log
@setroot() was a ugly mix of MI and MD code, with different bugs on different
machines.  Instead -- build one solid clean MI version, and thenchange all
the architectures to use it.  ok various people, tested on almost all cases.
(it is a 10094 line diff..)
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.32 2006/05/28 03:22:35 henning Exp $	*/
d212 5
@


1.32
log
@intrducing device type DV_SENSOR turned out to be a bad idea as it
affects way more than just hotplug messages. remove DV_SENSOR and use
DV_DULL for the moment. proper solution coming.
discussed with deraadt mk jason
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.31 2006/05/27 23:51:27 mk Exp $	*/
d212 6
@


1.31
log
@Make sensor add/remove create hotplug events (after much prodding from henning).  Idea from mbalmer.  'in it goes!' deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.30 2006/01/21 12:20:53 miod Exp $	*/
d59 1
a59 2
	DV_TTY,			/* serial line interface (???) */
	DV_SENSOR		/* sensor stuff */
@


1.30
log
@Remove now unused zeroref member in cfattach structures.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.29 2004/11/23 19:08:55 miod Exp $	*/
d59 2
a60 1
	DV_TTY			/* serial line interface (???) */
@


1.29
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.28 2004/11/17 14:12:59 deraadt Exp $	*/
a142 1
	void    (*ca_zeroref)(struct device *);
@


1.28
log
@firmware loading; ok pedro tedu dlg miod
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.27 2003/06/02 23:28:21 millert Exp $	*/
d188 1
d207 2
@


1.27
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.26 2002/10/06 23:12:31 art Exp $	*/
d214 3
@


1.26
log
@Remove some '#if 0' cruft.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.25 2002/09/06 18:12:47 deraadt Exp $	*/
d25 1
a25 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.25
log
@remove last , in enum
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.24 2002/08/27 01:19:52 wcobb Exp $	*/
a220 4
#if 0
extern int attach_loadable(char *, int, struct cftable *);
extern int detach_loadable(struct cftable *);
#endif
@


1.24
log
@config_edit() isn't used anywhere. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.23 2002/03/15 01:20:04 millert Exp $	*/
d71 1
a71 1
	DVACT_DEACTIVATE,	/* deactivate the device */
@


1.23
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.22 2002/03/14 03:16:12 millert Exp $	*/
a193 1
void config_edit(void);
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.21 2002/03/14 01:27:14 millert Exp $	*/
d113 1
a113 1
	void	(**cf_ivstubs)		/* config-generated vectors, if any */(void);
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.20 2001/09/01 05:48:18 jason Exp $	*/
d209 1
a209 1
void config_defer __P((struct device *, void (*)(struct device *)));
@


1.20
log
@Add __HAVE_DEVICE_REGISTER to hp300/alpha (sparc64 already had it) and
clean up the arch specific #ifdef's in subr_autoconf.c; from NetBSD.
(tested by me on alpha/sparc64 and miod on hp300)
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.19 2001/06/22 14:10:59 deraadt Exp $	*/
d113 1
a113 2
	void	(**cf_ivstubs)		/* config-generated vectors, if any */
			__P((void));
d123 2
a124 2
typedef int (*cfmatch_t) __P((struct device *, void *, void *));
typedef void (*cfscan_t) __P((struct device *, void *));
d144 4
a147 4
	void	(*ca_attach) __P((struct device *, struct device *, void *));
	int	(*ca_detach) __P((struct device *, int));
	int	(*ca_activate) __P((struct device *, enum devact));
	void    (*ca_zeroref) __P((struct device *));
d168 1
a168 1
typedef int (*cfprint_t) __P((void *, const char *));
d177 1
a177 1
	void	(*pdev_attach) __P((int));
d193 16
a208 16
void config_init __P((void));
void config_edit __P((void));
void *config_search __P((cfmatch_t, struct device *, void *));
void *config_rootsearch __P((cfmatch_t, char *, void *));
struct device *config_found_sm __P((struct device *, void *, cfprint_t,
    cfmatch_t));
struct device *config_rootfound __P((char *, void *));
void config_scan __P((cfscan_t, struct device *));
struct device *config_attach __P((struct device *, void *, void *, cfprint_t));
int config_detach __P((struct device *, int));
int config_detach_children __P((struct device *, int));
int config_activate __P((struct device *));
int config_deactivate __P((struct device *));
int config_activate_children __P((struct device *, enum devact));
struct device *config_make_softc __P((struct device *parent,
    struct cfdata *cf));
d210 1
a210 1
void evcnt_attach __P((struct device *, const char *, struct evcnt *));
d212 3
a214 3
struct device *device_lookup __P((struct cfdriver *, int unit));
void device_ref __P((struct device *));
void device_unref __P((struct device *));
d223 2
a224 2
extern int attach_loadable __P((char *, int, struct cftable *));
extern int detach_loadable __P((struct cftable *));
@


1.20.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.20 2001/09/01 05:48:18 jason Exp $	*/
d113 2
a114 1
	void	(**cf_ivstubs)(void);	/* config-generated vectors, if any */
d124 2
a125 2
typedef int (*cfmatch_t)(struct device *, void *, void *);
typedef void (*cfscan_t)(struct device *, void *);
d145 4
a148 4
	void	(*ca_attach)(struct device *, struct device *, void *);
	int	(*ca_detach)(struct device *, int);
	int	(*ca_activate)(struct device *, enum devact);
	void    (*ca_zeroref)(struct device *);
d169 1
a169 1
typedef int (*cfprint_t)(void *, const char *);
d178 1
a178 1
	void	(*pdev_attach)(int);
d194 22
a215 22
void config_init(void);
void config_edit(void);
void *config_search(cfmatch_t, struct device *, void *);
void *config_rootsearch(cfmatch_t, char *, void *);
struct device *config_found_sm(struct device *, void *, cfprint_t,
    cfmatch_t);
struct device *config_rootfound(char *, void *);
void config_scan(cfscan_t, struct device *);
struct device *config_attach(struct device *, void *, void *, cfprint_t);
int config_detach(struct device *, int);
int config_detach_children(struct device *, int);
int config_activate(struct device *);
int config_deactivate(struct device *);
int config_activate_children(struct device *, enum devact);
struct device *config_make_softc(struct device *parent,
    struct cfdata *cf);
void config_defer(struct device *, void (*)(struct device *));
void evcnt_attach(struct device *, const char *, struct evcnt *);

struct device *device_lookup(struct cfdriver *, int unit);
void device_ref(struct device *);
void device_unref(struct device *);
d224 2
a225 2
extern int attach_loadable(char *, int, struct cftable *);
extern int detach_loadable(struct cftable *);
@


1.20.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.20.4.1 2002/06/11 03:32:33 art Exp $	*/
d71 1
a71 1
	DVACT_DEACTIVATE	/* deactivate the device */
d194 1
d222 4
@


1.19
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.18 2000/04/09 19:23:18 csapuntz Exp $	*/
d216 4
@


1.18
log
@

Added config_detach_children, config_activate_children.

Added ref counting to devices: device_ref, device_unref and a new method
for devices : ca_zeroref, called when the ref count hits zero.

Note that ca_zeroref may be called from interrupt context.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17 1999/08/08 00:37:09 niklas Exp $	*/
d84 1
a84 1
	int     dv_ref;                 /* ref count */
@


1.17
log
@From NetBSD; new device detaching infrastructure.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.16 1999/08/05 17:41:43 niklas Exp $	*/
d74 2
d84 1
d148 1
d204 1
d207 1
d212 4
@


1.17.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.18 2000/04/09 19:23:18 csapuntz Exp $	*/
a73 2
#include <sys/lock.h>

a81 1
	int     dv_ref;                 /* ref count */
a144 1
	void    (*ca_zeroref) __P((struct device *));
a199 1
int config_detach_children __P((struct device *, int));
a201 1
int config_activate_children __P((struct device *, enum devact));
a205 4

struct device *device_lookup __P((struct cfdriver *, int unit));
void device_ref __P((struct device *));
void device_unref __P((struct device *));
@


1.17.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17.4.1 2001/05/14 22:45:01 niklas Exp $	*/
d84 1
a84 1
	int	dv_ref;			/* ref count */
@


1.17.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17.4.2 2001/07/04 11:00:15 niklas Exp $	*/
a215 4

#ifdef __HAVE_DEVICE_REGISTER
void device_register(struct device *, void *);
#endif
@


1.17.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 2
a114 1
	void	(**cf_ivstubs)(void);	/* config-generated vectors, if any */
d124 2
a125 2
typedef int (*cfmatch_t)(struct device *, void *, void *);
typedef void (*cfscan_t)(struct device *, void *);
d145 4
a148 4
	void	(*ca_attach)(struct device *, struct device *, void *);
	int	(*ca_detach)(struct device *, int);
	int	(*ca_activate)(struct device *, enum devact);
	void    (*ca_zeroref)(struct device *);
d169 1
a169 1
typedef int (*cfprint_t)(void *, const char *);
d178 1
a178 1
	void	(*pdev_attach)(int);
d194 22
a215 22
void config_init(void);
void config_edit(void);
void *config_search(cfmatch_t, struct device *, void *);
void *config_rootsearch(cfmatch_t, char *, void *);
struct device *config_found_sm(struct device *, void *, cfprint_t,
    cfmatch_t);
struct device *config_rootfound(char *, void *);
void config_scan(cfscan_t, struct device *);
struct device *config_attach(struct device *, void *, void *, cfprint_t);
int config_detach(struct device *, int);
int config_detach_children(struct device *, int);
int config_activate(struct device *);
int config_deactivate(struct device *);
int config_activate_children(struct device *, enum devact);
struct device *config_make_softc(struct device *parent,
    struct cfdata *cf);
void config_defer(struct device *, void (*)(struct device *));
void evcnt_attach(struct device *, const char *, struct evcnt *);

struct device *device_lookup(struct cfdriver *, int unit);
void device_ref(struct device *);
void device_unref(struct device *);
d224 2
a225 2
extern int attach_loadable(char *, int, struct cftable *);
extern int detach_loadable(struct cftable *);
@


1.17.4.5
log
@Sync the SMP branch with 3.3
@
text
@d71 1
a71 1
	DVACT_DEACTIVATE	/* deactivate the device */
d194 1
d222 4
@


1.17.4.6
log
@Go back to defining simplelocks as noops, even if MULTIPROCESSOR.  Instead use
a new real simple recursive-lock capable lock implementation for the few
necessary locks (kernel, scheduler, tlb shootdown, printf and ddb MP).
This because we cannot trust the old fine-grained locks spread out all over
our kernel, and not really tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17.4.5 2003/03/28 00:41:30 niklas Exp $	*/
d73 2
@


1.17.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17.4.6 2003/05/18 17:41:16 niklas Exp $	*/
d25 5
a29 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.4.8
log
@removing sys/lock.h from here breaks ... oh, half the device drivers?
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.17.4.7 2003/06/07 11:09:07 ho Exp $	*/
a68 2

#include <sys/lock.h>
@


1.16
log
@From NetBSD; config_defer to defer configuration of a device until after all
other siblings.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.15 1999/07/23 19:45:20 niklas Exp $	*/
d66 8
d81 1
d83 4
d143 2
a144 2
	int	(*ca_detach) __P((struct device*));
	int	(*ca_reprobe) __P((struct device*, struct cfdata*));
d147 4
d199 3
@


1.15
log
@Remove obsolete detach logic in preparation of a newer one
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.14 1999/04/28 18:01:22 deraadt Exp $	*/
d184 1
@


1.14
log
@add autoconfig_verbose toggling command to boot_config
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.13 1998/05/11 09:59:37 niklas Exp $	*/
d188 1
d191 1
a191 5
typedef void (*config_detach_callback_t) __P((struct device *, void *));
extern int config_detach __P((struct cfdata *, config_detach_callback_t,
	    void *));
extern int config_detach_children __P((struct cfdata *,
	    config_detach_callback_t, void *));
@


1.13
log
@Formerly reuse of unit numbers of detached devices was impossible, with
this change starred devices will search from the first allowed unit for
such devices and up for free units when attaching.  This means you have
to rerun config(8) before yopu compile current kernels.  FYI, this is
a necessity when doing PCMCIA flashcard reading, otherwise you soon run
out of unit numbers.

I have also added a way to detach all children of a certain device, used
in a new PCMCIA framework to come, so you detach all functions on a
single PCMCIA card when pulling it out.

A few bugs wrt starred devices fixed in the autoconfig_verbose code too.
Last and least, fixed some panic messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.12 1997/08/07 10:34:48 downsj Exp $	*/
d170 2
@


1.12
log
@Back that out, I'm too tired to be messing with this.
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.10 1996/11/23 21:47:13 kstailey Exp $	*/
d99 1
d190 3
a192 1
			      void *));
@


1.11
log
@Add cf_locnames to struct cfdata.
@
text
@d97 2
a98 3
	void	(**cf_ivstubs)__P((void));
					/* config-generated vectors, if any */
	const char **cf_locnames;	/* locator names (machine dependent) */
@


1.10
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.9 1996/11/21 12:47:17 mickey Exp $	*/
d97 3
a99 2
	void	(**cf_ivstubs)		/* config-generated vectors, if any */
			__P((void));
@


1.9
log
@export struct cfdata cfdata[];
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.8 1996/07/02 07:58:39 deraadt Exp $	*/
d147 1
a147 1
typedef int (*cfprint_t) __P((void *, char *));
@


1.8
log
@provide config_make_softc proto
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.7 1996/06/23 19:32:56 maja Exp $	*/
d100 1
@


1.7
log
@Added support for user modifiable kernel at boot (-c) /maja
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.6 1996/06/16 10:29:55 deraadt Exp $	*/
d178 2
@


1.6
log
@provide locator names to kernel (update your config(8) binary!)
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.5 1996/04/29 14:17:53 hvozda Exp $	*/
d103 2
@


1.5
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.4 1996/04/21 22:31:38 deraadt Exp $	*/
d96 1
d168 1
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: device.h,v 1.3 1996/04/18 21:40:51 niklas Exp $	*/
d125 2
a126 1
	/* XXX should have detach */
d157 5
d178 6
@


1.3
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: device.h,v 1.2 1996/03/03 12:11:30 niklas Exp $	*/
/*	$NetBSD: device.h,v 1.11 1996/03/05 22:14:58 thorpej Exp $	*/
d51 2
d68 1
a68 1
	struct	device *dv_next;	/* next in list of all */
d74 1
d78 1
a78 1
	struct	evcnt *ev_next;		/* linked list */
d83 1
d89 1
d107 21
a127 7
 * `configuration' driver (what the machine-independent autoconf uses).
 * As devices are found, they are applied against all the potential matches.
 * The one with the best match is taken, and a device structure (plus any
 * other data desired) is allocated.  Pointers to these are placed into
 * an array of pointers.  The array itself must be dynamic since devices
 * can be found long after the machine is up and running.
 */
a130 2
	cfmatch_t cd_match;		/* returns a match level */
	void	(*cd_attach) __P((struct device *, struct device *, void *));
a131 1
	size_t	cd_devsize;		/* size of dev data (for malloc) */
a155 2
struct	device *alldevs;	/* head of list of all devices */
struct	evcnt *allevents;	/* head of list of all events */
d157 4
d163 3
a165 2
int config_found_sm __P((struct device *, void *, cfprint_t, cfmatch_t));
int config_rootfound __P((char *, void *));
d167 1
a167 1
void config_attach __P((struct device *, void *, void *, cfprint_t));
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: device.h,v 1.9 1996/02/09 18:25:04 christos Exp $	*/
d139 1
d145 1
a145 1
int config_found __P((struct device *, void *, cfprint_t));
d150 4
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: device.h,v 1.8 1994/11/04 06:40:17 mycroft Exp $	*/
d91 2
a92 1
	void	(**cf_ivstubs)();	/* config-generated vectors, if any */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
