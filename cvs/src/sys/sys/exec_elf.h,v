head	1.73;
access;
symbols
	OPENBSD_6_1:1.73.0.4
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.59.0.2
	OPENBSD_6_0_BASE:1.59
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.6
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.52.0.2
	OPENBSD_5_4_BASE:1.52
	OPENBSD_5_3:1.51.0.2
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.49.0.4
	OPENBSD_5_2_BASE:1.49
	OPENBSD_5_1_BASE:1.49
	OPENBSD_5_1:1.49.0.2
	OPENBSD_5_0:1.48.0.6
	OPENBSD_5_0_BASE:1.48
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.43.0.8
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.43.0.6
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.43.0.4
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.4
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.40.0.4
	OPENBSD_3_8_BASE:1.40
	OPENBSD_3_7:1.40.0.2
	OPENBSD_3_7_BASE:1.40
	OPENBSD_3_6:1.39.0.4
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.34.0.4
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.34
	UBC:1.32.0.4
	UBC_BASE:1.32
	OPENBSD_3_0:1.32.0.2
	OPENBSD_3_0_BASE:1.32
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.20.0.6
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.4
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.02.18.06.42.08;	author jsg;	state Exp;
branches;
next	1.72;
commitid	5S1zANdvQF9Cxyfe;

1.72
date	2017.02.18.06.09.01;	author jsg;	state Exp;
branches;
next	1.71;
commitid	TkmepljP0yntn6B0;

1.71
date	2017.02.08.05.09.25;	author guenther;	state Exp;
branches;
next	1.70;
commitid	V3fgN8BO1mri8xSU;

1.70
date	2017.02.08.05.02.05;	author guenther;	state Exp;
branches;
next	1.69;
commitid	uR8XQWNN9LjTR5UO;

1.69
date	2017.02.08.04.47.23;	author guenther;	state Exp;
branches;
next	1.68;
commitid	1StVREQjzq1gi6QM;

1.68
date	2017.02.08.04.34.29;	author guenther;	state Exp;
branches;
next	1.67;
commitid	v6BJE4JNZ5jMnrCa;

1.67
date	2017.01.30.05.00.31;	author guenther;	state Exp;
branches;
next	1.66;
commitid	bD3NPg0DBP1oKFRZ;

1.66
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.65;
commitid	CHRb0fCqa8XxUAMH;

1.65
date	2016.11.28.21.50.12;	author patrick;	state Exp;
branches;
next	1.64;
commitid	jCQxTUF4VFEY76G9;

1.64
date	2016.09.17.17.39.34;	author jasper;	state Exp;
branches;
next	1.63;
commitid	yiSnvoseCUtTmo9S;

1.63
date	2016.09.07.20.12.42;	author jasper;	state Exp;
branches;
next	1.62;
commitid	PfQEZGHLAgEizXLB;

1.62
date	2016.09.04.11.52.55;	author kettenis;	state Exp;
branches;
next	1.61;
commitid	spZSt5BeSbLhLlJL;

1.61
date	2016.08.30.12.47.19;	author kettenis;	state Exp;
branches;
next	1.60;
commitid	D3G7AWKOOzp9QFfJ;

1.60
date	2016.08.23.06.46.17;	author kettenis;	state Exp;
branches;
next	1.59;
commitid	77WGwq23vMDU6RQE;

1.59
date	2016.07.14.06.03.46;	author guenther;	state Exp;
branches;
next	1.58;
commitid	c04XS4q8HFbuGGLL;

1.58
date	2016.05.29.00.48.05;	author deraadt;	state Exp;
branches;
next	1.57;
commitid	QXbG7Sh6hCZF0d3y;

1.57
date	2016.03.24.06.05.43;	author guenther;	state Exp;
branches;
next	1.56;
commitid	DnTyInOtZzDQp5xp;

1.56
date	2015.10.13.04.29.50;	author guenther;	state Exp;
branches;
next	1.55;
commitid	GrsfZNhvI28WehXc;

1.55
date	2015.08.24.21.09.43;	author jca;	state Exp;
branches;
next	1.54;
commitid	B3QdIt5gzCTzZ3Dc;

1.54
date	2014.11.26.20.06.53;	author stsp;	state Exp;
branches;
next	1.53;
commitid	jELYBgAx2QwBsK5n;

1.53
date	2014.01.03.03.00.39;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.08.20.55.14;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2012.09.11.15.44.18;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2012.08.20.23.25.07;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2011.09.20.16.42.01;	author pirofti;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.07.09.41.16;	author sthen;	state Exp;
branches;
next	1.47;

1.47
date	2010.05.02.00.28.38;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.31.21.37.19;	author otto;	state Exp;
branches;
next	1.45;

1.45
date	2010.01.25.05.18.35;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.14.05.04.58;	author tedu;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.06.20.58.17;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2004.10.10.15.02.18;	author kettenis;	state Exp;
branches;
next	1.39;

1.39
date	2004.02.27.17.36.16;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.29.23.15.53;	author drahn;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.28.01.39.40;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.18.09.58.13;	author jmc;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.13.16.38.34;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.31.03.10.50;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.26.09.15.22;	author art;	state Exp;
branches
	1.32.4.1;
next	1.31;

1.31
date	2001.09.19.13.28.43;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.19.15.20.25;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.06.23.18.46;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.16.04.39.08;	author hugh;	state Exp;
branches;
next	1.27;

1.27
date	2001.01.23.16.58.06;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2001.01.22.23.48.35;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.01.22.14.52.56;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.01.21.17.09.21;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.16.18.04.19;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.16.15.44.36;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.11.00.35.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.09.19.16.16.49;	author kstailey;	state Exp;
branches
	1.20.4.1;
next	1.19;

1.19
date	99.09.18.15.43.33;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	99.09.10.20.47.13;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	99.09.10.20.05.50;	author kstailey;	state Exp;
branches;
next	1.16;

1.16
date	99.09.10.12.24.27;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	99.09.07.21.52.44;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	99.02.10.08.07.20;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.02.01.16.33.01;	author pefo;	state Exp;
branches;
next	1.12;

1.12
date	98.02.22.01.00.26;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.06.29.07.43.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.11.05.55.33;	author imp;	state Exp;
branches;
next	1.9;

1.9
date	96.11.06.18.41.52;	author etheisen;	state Exp;
branches;
next	1.8;

1.8
date	96.10.27.20.08.26;	author etheisen;	state Exp;
branches;
next	1.7;

1.7
date	96.08.31.09.19.14;	author pefo;	state Exp;
branches;
next	1.6;

1.6
date	96.06.12.07.31.37;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.29.03.04.51;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.07.44.29;	author etheisen;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.12.11.42;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.29.07.09.50;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.20.4.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.20.4.2;

1.20.4.2
date	2001.07.04.11.00.19;	author niklas;	state Exp;
branches;
next	1.20.4.3;

1.20.4.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.20.4.4;

1.20.4.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.20.4.5;

1.20.4.5
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.20.4.6;

1.20.4.6
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.20.4.7;

1.20.4.7
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	1.20.4.8;

1.20.4.8
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.32.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.32.4.2;

1.32.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.32.4.3;

1.32.4.3
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Add Elf{32,64}_Nhdr structs with the same member names used by libelf
and glibc.  As noted by guenther@@ this is the same layout as our
Elf{32,64}_Note structs and the handful of uses we have in the tree may
switch From _Note to _Nhdr in future.

Prompted by the development version of Mesa using the Nhdr type.

ok guenther@@
@
text
@/*	$OpenBSD: exec_elf.h,v 1.72 2017/02/18 06:09:01 jsg Exp $	*/
/*
 * Copyright (c) 1995, 1996 Erik Theisen.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is the ELF ABI header file
 * formerly known as "elf_abi.h".
 */

#ifndef _SYS_EXEC_ELF_H_
#define _SYS_EXEC_ELF_H_

#include <sys/types.h>
#include <machine/exec.h>

typedef __uint8_t	Elf_Byte;

typedef __uint32_t	Elf32_Addr;	/* Unsigned program address */
typedef __uint32_t	Elf32_Off;	/* Unsigned file offset */
typedef __int32_t	Elf32_Sword;	/* Signed large integer */
typedef __uint32_t	Elf32_Word;	/* Unsigned large integer */
typedef __uint16_t	Elf32_Half;	/* Unsigned medium integer */

typedef __uint64_t	Elf64_Addr;
typedef __uint64_t	Elf64_Off;
typedef __int32_t	Elf64_Shalf;

#ifdef __alpha__
typedef __int64_t	Elf64_Sword;
typedef __uint64_t	Elf64_Word;
#else
typedef __int32_t	Elf64_Sword;
typedef __uint32_t	Elf64_Word;
#endif

typedef __int64_t	Elf64_Sxword;
typedef __uint64_t	Elf64_Xword;

typedef __uint32_t	Elf64_Half;
typedef __uint16_t	Elf64_Quarter;

/*
 * e_ident[] identification indexes
 * See http://www.sco.com/developers/gabi/latest/ch4.eheader.html
 */
#define EI_MAG0		0		/* file ID */
#define EI_MAG1		1		/* file ID */
#define EI_MAG2		2		/* file ID */
#define EI_MAG3		3		/* file ID */
#define EI_CLASS	4		/* file class */
#define EI_DATA		5		/* data encoding */
#define EI_VERSION	6		/* ELF header version */
#define EI_OSABI	7		/* OS/ABI ID */
#define EI_ABIVERSION	8		/* ABI version */
#define EI_PAD		9		/* start of pad bytes */
#define EI_NIDENT	16		/* Size of e_ident[] */

/* e_ident[] magic number */
#define	ELFMAG0		0x7f		/* e_ident[EI_MAG0] */
#define	ELFMAG1		'E'		/* e_ident[EI_MAG1] */
#define	ELFMAG2		'L'		/* e_ident[EI_MAG2] */
#define	ELFMAG3		'F'		/* e_ident[EI_MAG3] */
#define	ELFMAG		"\177ELF"	/* magic */
#define	SELFMAG		4		/* size of magic */

/* e_ident[] file class */
#define	ELFCLASSNONE	0		/* invalid */
#define	ELFCLASS32	1		/* 32-bit objs */
#define	ELFCLASS64	2		/* 64-bit objs */
#define	ELFCLASSNUM	3		/* number of classes */

/* e_ident[] data encoding */
#define ELFDATANONE	0		/* invalid */
#define ELFDATA2LSB	1		/* Little-Endian */
#define ELFDATA2MSB	2		/* Big-Endian */
#define ELFDATANUM	3		/* number of data encode defines */

/* e_ident[] Operating System/ABI */
#define ELFOSABI_SYSV		0	/* UNIX System V ABI */
#define ELFOSABI_HPUX		1	/* HP-UX operating system */
#define ELFOSABI_NETBSD		2	/* NetBSD */
#define ELFOSABI_LINUX		3	/* GNU/Linux */
#define ELFOSABI_HURD		4	/* GNU/Hurd */
#define ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
#define ELFOSABI_SOLARIS	6	/* Solaris */
#define ELFOSABI_MONTEREY	7	/* Monterey */
#define ELFOSABI_IRIX		8	/* IRIX */
#define ELFOSABI_FREEBSD	9	/* FreeBSD */
#define ELFOSABI_TRU64		10	/* TRU64 UNIX */
#define ELFOSABI_MODESTO	11	/* Novell Modesto */
#define ELFOSABI_OPENBSD	12	/* OpenBSD */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */

/* e_ident */
#define IS_ELF(ehdr) ((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \
                      (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \
                      (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \
                      (ehdr).e_ident[EI_MAG3] == ELFMAG3)

/* ELF Header */
typedef struct elfhdr {
	unsigned char	e_ident[EI_NIDENT]; /* ELF Identification */
	Elf32_Half	e_type;		/* object file type */
	Elf32_Half	e_machine;	/* machine */
	Elf32_Word	e_version;	/* object file version */
	Elf32_Addr	e_entry;	/* virtual entry point */
	Elf32_Off	e_phoff;	/* program header table offset */
	Elf32_Off	e_shoff;	/* section header table offset */
	Elf32_Word	e_flags;	/* processor-specific flags */
	Elf32_Half	e_ehsize;	/* ELF header size */
	Elf32_Half	e_phentsize;	/* program header entry size */
	Elf32_Half	e_phnum;	/* number of program header entries */
	Elf32_Half	e_shentsize;	/* section header entry size */
	Elf32_Half	e_shnum;	/* number of section header entries */
	Elf32_Half	e_shstrndx;	/* section header table's "section
					   header string table" entry offset */
} Elf32_Ehdr;

typedef struct {
	unsigned char	e_ident[EI_NIDENT];	/* Id bytes */
	Elf64_Quarter	e_type;			/* file type */
	Elf64_Quarter	e_machine;		/* machine type */
	Elf64_Half	e_version;		/* version number */
	Elf64_Addr	e_entry;		/* entry point */
	Elf64_Off	e_phoff;		/* Program hdr offset */
	Elf64_Off	e_shoff;		/* Section hdr offset */
	Elf64_Half	e_flags;		/* Processor flags */
	Elf64_Quarter	e_ehsize;		/* sizeof ehdr */
	Elf64_Quarter	e_phentsize;		/* Program header entry size */
	Elf64_Quarter	e_phnum;		/* Number of program headers */
	Elf64_Quarter	e_shentsize;		/* Section header entry size */
	Elf64_Quarter	e_shnum;		/* Number of section headers */
	Elf64_Quarter	e_shstrndx;		/* String table index */
} Elf64_Ehdr;

/* e_type */
#define ET_NONE		0		/* No file type */
#define ET_REL		1		/* relocatable file */
#define ET_EXEC		2		/* executable file */
#define ET_DYN		3		/* shared object file */
#define ET_CORE		4		/* core file */
#define ET_NUM		5		/* number of types */
#define ET_LOPROC	0xff00		/* reserved range for processor */
#define ET_HIPROC	0xffff		/*  specific e_type */

/* e_machine */
#define EM_NONE		0		/* No Machine */
#define EM_M32		1		/* AT&T WE 32100 */
#define EM_SPARC	2		/* SPARC */
#define EM_386		3		/* Intel 80386 */
#define EM_68K		4		/* Motorola 68000 */
#define EM_88K		5		/* Motorola 88000 */
#define EM_486		6		/* Intel 80486 - unused? */
#define EM_860		7		/* Intel 80860 */
#define EM_MIPS		8		/* MIPS R3000 Big-Endian only */
/*
 * Don't know if EM_MIPS_RS4_BE,
 * EM_SPARC64, EM_PARISC,
 * or EM_PPC are ABI compliant
 */
#define EM_MIPS_RS4_BE	10		/* MIPS R4000 Big-Endian */
#define EM_SPARC64	11		/* SPARC v9 64-bit unofficial */
#define EM_PARISC	15		/* HPPA */
#define EM_SPARC32PLUS	18		/* Enhanced instruction set SPARC */
#define EM_PPC		20		/* PowerPC */
#define EM_ARM		40		/* Advanced RISC Machines ARM */
#define EM_ALPHA	41		/* DEC ALPHA */
#define	EM_SH		42		/* Hitachi/Renesas Super-H */
#define EM_SPARCV9	43		/* SPARC version 9 */
#define EM_IA_64	50		/* Intel IA-64 Processor */
#define EM_AMD64	62		/* AMD64 architecture */
#define EM_VAX		75		/* DEC VAX */
#define EM_AARCH64	183		/* ARM 64-bit architecture (AArch64) */

/* Non-standard */
#define EM_ALPHA_EXP	0x9026		/* DEC ALPHA */

#define EM_NUM		22		/* number of machine types */

/* Version */
#define EV_NONE		0		/* Invalid */
#define EV_CURRENT	1		/* Current */
#define EV_NUM		2		/* number of versions */

/* Section Header */
typedef struct {
	Elf32_Word	sh_name;	/* name - index into section header
					   string table section */
	Elf32_Word	sh_type;	/* type */
	Elf32_Word	sh_flags;	/* flags */
	Elf32_Addr	sh_addr;	/* address */
	Elf32_Off	sh_offset;	/* file offset */
	Elf32_Word	sh_size;	/* section size */
	Elf32_Word	sh_link;	/* section header table index link */
	Elf32_Word	sh_info;	/* extra information */
	Elf32_Word	sh_addralign;	/* address alignment */
	Elf32_Word	sh_entsize;	/* section entry size */
} Elf32_Shdr;

typedef struct {
	Elf64_Half	sh_name;	/* section name */
	Elf64_Half	sh_type;	/* section type */
	Elf64_Xword	sh_flags;	/* section flags */
	Elf64_Addr	sh_addr;	/* virtual address */
	Elf64_Off	sh_offset;	/* file offset */
	Elf64_Xword	sh_size;	/* section size */
	Elf64_Half	sh_link;	/* link to another */
	Elf64_Half	sh_info;	/* misc info */
	Elf64_Xword	sh_addralign;	/* memory alignment */
	Elf64_Xword	sh_entsize;	/* table entry size */
} Elf64_Shdr;

/* Special Section Indexes */
#define SHN_UNDEF	0		/* undefined */
#define SHN_LORESERVE	0xff00		/* lower bounds of reserved indexes */
#define SHN_LOPROC	0xff00		/* reserved range for processor */
#define SHN_HIPROC	0xff1f		/*   specific section indexes */
#define SHN_ABS		0xfff1		/* absolute value */
#define SHN_COMMON	0xfff2		/* common symbol */
#define SHN_HIRESERVE	0xffff		/* upper bounds of reserved indexes */

/* sh_type */
#define SHT_NULL	0		/* inactive */
#define SHT_PROGBITS	1		/* program defined information */
#define SHT_SYMTAB	2		/* symbol table section */
#define SHT_STRTAB	3		/* string table section */
#define SHT_RELA	4		/* relocation section with addends*/
#define SHT_HASH	5		/* symbol hash table section */
#define SHT_DYNAMIC	6		/* dynamic section */
#define SHT_NOTE	7		/* note section */
#define SHT_NOBITS	8		/* no space section */
#define SHT_REL		9		/* relation section without addends */
#define SHT_SHLIB	10		/* reserved - purpose unknown */
#define SHT_DYNSYM	11		/* dynamic symbol table section */
#define SHT_NUM		12		/* number of section types */
#define SHT_LOPROC	0x70000000	/* reserved range for processor */
#define SHT_HIPROC	0x7fffffff	/*  specific section header types */
#define SHT_LOUSER	0x80000000	/* reserved range for application */
#define SHT_HIUSER	0xffffffff	/*  specific indexes */

/* Section names */
#define ELF_BSS         ".bss"		/* uninitialized data */
#define ELF_DATA        ".data"		/* initialized data */
#define ELF_CTF		".SUNW_ctf"	/* CTF data */
#define ELF_DEBUG       ".debug"	/* debug */
#define ELF_DYNAMIC     ".dynamic"	/* dynamic linking information */
#define ELF_DYNSTR      ".dynstr"	/* dynamic string table */
#define ELF_DYNSYM      ".dynsym"	/* dynamic symbol table */
#define ELF_FINI        ".fini"		/* termination code */
#define ELF_GOT         ".got"		/* global offset table */
#define ELF_HASH        ".hash"		/* symbol hash table */
#define ELF_INIT        ".init"		/* initialization code */
#define ELF_REL_DATA    ".rel.data"	/* relocation data */
#define ELF_REL_FINI    ".rel.fini"	/* relocation termination code */
#define ELF_REL_INIT    ".rel.init"	/* relocation initialization code */
#define ELF_REL_DYN     ".rel.dyn"	/* relocation dynamic link info */
#define ELF_REL_RODATA  ".rel.rodata"	/* relocation read-only data */
#define ELF_REL_TEXT    ".rel.text"	/* relocation code */
#define ELF_RODATA      ".rodata"	/* read-only data */
#define ELF_SHSTRTAB    ".shstrtab"	/* section header string table */
#define ELF_STRTAB      ".strtab"	/* string table */
#define ELF_SYMTAB      ".symtab"	/* symbol table */
#define ELF_TEXT        ".text"		/* code */


/* Section Attribute Flags - sh_flags */
#define SHF_WRITE	0x1		/* Writable */
#define SHF_ALLOC	0x2		/* occupies memory */
#define SHF_EXECINSTR	0x4		/* executable */
#define SHF_TLS		0x400		/* thread local storage */
#define SHF_MASKPROC	0xf0000000	/* reserved bits for processor */
					/*  specific section attributes */

/* Symbol Table Entry */
typedef struct elf32_sym {
	Elf32_Word	st_name;	/* name - index into string table */
	Elf32_Addr	st_value;	/* symbol value */
	Elf32_Word	st_size;	/* symbol size */
	unsigned char	st_info;	/* type and binding */
	unsigned char	st_other;	/* 0 - no defined meaning */
	Elf32_Half	st_shndx;	/* section header index */
} Elf32_Sym;

typedef struct {
	Elf64_Half	st_name;	/* Symbol name index in str table */
	Elf_Byte	st_info;	/* type / binding attrs */
	Elf_Byte	st_other;	/* unused */
	Elf64_Quarter	st_shndx;	/* section index of symbol */
	Elf64_Xword	st_value;	/* value of symbol */
	Elf64_Xword	st_size;	/* size of symbol */
} Elf64_Sym;

/* Symbol table index */
#define STN_UNDEF	0		/* undefined */

/* Extract symbol info - st_info */
#define ELF32_ST_BIND(x)	((x) >> 4)
#define ELF32_ST_TYPE(x)	(((unsigned int) x) & 0xf)
#define ELF32_ST_INFO(b,t)	(((b) << 4) + ((t) & 0xf))

#define ELF64_ST_BIND(x)	((x) >> 4)
#define ELF64_ST_TYPE(x)	(((unsigned int) x) & 0xf)
#define ELF64_ST_INFO(b,t)	(((b) << 4) + ((t) & 0xf))

/* Symbol Binding - ELF32_ST_BIND - st_info */
#define STB_LOCAL	0		/* Local symbol */
#define STB_GLOBAL	1		/* Global symbol */
#define STB_WEAK	2		/* like global - lower precedence */
#define STB_NUM		3		/* number of symbol bindings */
#define STB_LOPROC	13		/* reserved range for processor */
#define STB_HIPROC	15		/*  specific symbol bindings */

/* Symbol type - ELF32_ST_TYPE - st_info */
#define STT_NOTYPE	0		/* not specified */
#define STT_OBJECT	1		/* data object */
#define STT_FUNC	2		/* function */
#define STT_SECTION	3		/* section */
#define STT_FILE	4		/* file */
#define STT_TLS		6		/* thread local storage */
#define STT_LOPROC	13		/* reserved range for processor */
#define STT_HIPROC	15		/*  specific symbol types */

/* Relocation entry with implicit addend */
typedef struct {
	Elf32_Addr	r_offset;	/* offset of relocation */
	Elf32_Word	r_info;		/* symbol table index and type */
} Elf32_Rel;

/* Relocation entry with explicit addend */
typedef struct {
	Elf32_Addr	r_offset;	/* offset of relocation */
	Elf32_Word	r_info;		/* symbol table index and type */
	Elf32_Sword	r_addend;
} Elf32_Rela;

/* Extract relocation info - r_info */
#define ELF32_R_SYM(i)		((i) >> 8)
#define ELF32_R_TYPE(i)		((unsigned char) (i))
#define ELF32_R_INFO(s,t) 	(((s) << 8) + (unsigned char)(t))

typedef struct {
	Elf64_Xword	r_offset;	/* where to do it */
	Elf64_Xword	r_info;		/* index & type of relocation */
} Elf64_Rel;

typedef struct {
	Elf64_Xword	r_offset;	/* where to do it */
	Elf64_Xword	r_info;		/* index & type of relocation */
	Elf64_Sxword	r_addend;	/* adjustment value */
} Elf64_Rela;

#define	ELF64_R_SYM(info)	((info) >> 32)
#define	ELF64_R_TYPE(info)	((info) & 0xFFFFFFFF)
#define ELF64_R_INFO(s,t) 	(((s) << 32) + (__uint32_t)(t))

#if defined(__mips64__) && defined(__MIPSEL__)
/*
 * The 64-bit MIPS ELF ABI uses a slightly different relocation format
 * than the regular ELF ABI: the r_info field is split into several
 * pieces (see gnu/usr.bin/binutils-2.17/include/elf/mips.h for details).
 */
#undef	ELF64_R_SYM
#undef	ELF64_R_TYPE
#undef	ELF64_R_INFO
#define	ELF64_R_TYPE(info)	((__uint64_t)swap32((info) >> 32))
#define	ELF64_R_SYM(info)	((info) & 0xFFFFFFFF)
#define	ELF64_R_INFO(s,t)	(((__uint64_t)swap32(t) << 32) + (__uint32_t)(s))
#endif	/* __mips64__ && __MIPSEL__ */

/* Program Header */
typedef struct {
	Elf32_Word	p_type;		/* segment type */
	Elf32_Off	p_offset;	/* segment offset */
	Elf32_Addr	p_vaddr;	/* virtual address of segment */
	Elf32_Addr	p_paddr;	/* physical address - ignored? */
	Elf32_Word	p_filesz;	/* number of bytes in file for seg. */
	Elf32_Word	p_memsz;	/* number of bytes in mem. for seg. */
	Elf32_Word	p_flags;	/* flags */
	Elf32_Word	p_align;	/* memory alignment */
} Elf32_Phdr;

typedef struct {
	Elf64_Half	p_type;		/* entry type */
	Elf64_Half	p_flags;	/* flags */
	Elf64_Off	p_offset;	/* offset */
	Elf64_Addr	p_vaddr;	/* virtual address */
	Elf64_Addr	p_paddr;	/* physical address */
	Elf64_Xword	p_filesz;	/* file size */
	Elf64_Xword	p_memsz;	/* memory size */
	Elf64_Xword	p_align;	/* memory & file alignment */
} Elf64_Phdr;

/* Segment types - p_type */
#define PT_NULL		0		/* unused */
#define PT_LOAD		1		/* loadable segment */
#define PT_DYNAMIC	2		/* dynamic linking section */
#define PT_INTERP	3		/* the RTLD */
#define PT_NOTE		4		/* auxiliary information */
#define PT_SHLIB	5		/* reserved - purpose undefined */
#define PT_PHDR		6		/* program header */
#define PT_TLS		7		/* thread local storage */
#define PT_LOOS		0x60000000	/* reserved range for OS */
#define PT_HIOS		0x6fffffff	/*  specific segment types */
#define PT_LOPROC	0x70000000	/* reserved range for processor */
#define PT_HIPROC	0x7fffffff	/*  specific segment types */

#define PT_GNU_EH_FRAME		0x6474e550	/* Exception handling info */
#define PT_GNU_RELRO		0x6474e552	/* Read-only after relocation */

#define PT_OPENBSD_RANDOMIZE	0x65a3dbe6	/* fill with random data */
#define PT_OPENBSD_WXNEEDED	0x65a3dbe7	/* program performs W^X violations */
#define PT_OPENBSD_BOOTDATA	0x65a41be6	/* section for boot arguments */

/* Segment flags - p_flags */
#define PF_X		0x1		/* Executable */
#define PF_W		0x2		/* Writable */
#define PF_R		0x4		/* Readable */
#define PF_MASKPROC	0xf0000000	/* reserved bits for processor */
					/*  specific segment flags */

/* Dynamic structure */
typedef struct {
	Elf32_Sword	d_tag;		/* controls meaning of d_val */
	union {
		Elf32_Word	d_val;	/* Multiple meanings - see d_tag */
		Elf32_Addr	d_ptr;	/* program virtual address */
	} d_un;
} Elf32_Dyn;

typedef struct {
	Elf64_Xword	d_tag;		/* controls meaning of d_val */
	union {
		Elf64_Addr	d_ptr;
		Elf64_Xword	d_val;
	} d_un;
} Elf64_Dyn;

/* Dynamic Array Tags - d_tag */
#define DT_NULL		0		/* marks end of _DYNAMIC array */
#define DT_NEEDED	1		/* string table offset of needed lib */
#define DT_PLTRELSZ	2		/* size of relocation entries in PLT */
#define DT_PLTGOT	3		/* address PLT/GOT */
#define DT_HASH		4		/* address of symbol hash table */
#define DT_STRTAB	5		/* address of string table */
#define DT_SYMTAB	6		/* address of symbol table */
#define DT_RELA		7		/* address of relocation table */
#define DT_RELASZ	8		/* size of relocation table */
#define DT_RELAENT	9		/* size of relocation entry */
#define DT_STRSZ	10		/* size of string table */
#define DT_SYMENT	11		/* size of symbol table entry */
#define DT_INIT		12		/* address of initialization func. */
#define DT_FINI		13		/* address of termination function */
#define DT_SONAME	14		/* string table offset of shared obj */
#define DT_RPATH	15		/* string table offset of library
					   search path */
#define DT_SYMBOLIC	16		/* start sym search in shared obj. */
#define DT_REL		17		/* address of rel. tbl. w addends */
#define DT_RELSZ	18		/* size of DT_REL relocation table */
#define DT_RELENT	19		/* size of DT_REL relocation entry */
#define DT_PLTREL	20		/* PLT referenced relocation entry */
#define DT_DEBUG	21		/* bugger */
#define DT_TEXTREL	22		/* Allow rel. mod. to unwritable seg */
#define DT_JMPREL	23		/* add. of PLT's relocation entries */
#define DT_BIND_NOW	24		/* Bind now regardless of env setting */
#define DT_INIT_ARRAY	25		/* address of array of init func */
#define DT_FINI_ARRAY	26		/* address of array of term func */
#define DT_INIT_ARRAYSZ	27		/* size of array of init func */
#define DT_FINI_ARRAYSZ	28		/* size of array of term func */
#define DT_RUNPATH	29		/* strtab offset of lib search path */
#define DT_FLAGS	30		/* Set of DF_* flags */
#define DT_ENCODING	31		/* further DT_* follow encoding rules */
#define DT_PREINIT_ARRAY	32	/* address of array of preinit func */
#define DT_PREINIT_ARRAYSZ	33	/* size of array of preinit func */
#define DT_LOOS		0x6000000d	/* reserved range for OS */
#define DT_HIOS		0x6ffff000	/*  specific dynamic array tags */
#define DT_LOPROC	0x70000000	/* reserved range for processor */
#define DT_HIPROC	0x7fffffff	/*  specific dynamic array tags */

/* some other useful tags */
#define DT_RELACOUNT	0x6ffffff9	/* if present, number of RELATIVE */
#define DT_RELCOUNT	0x6ffffffa	/* relocs, which must come first */
#define DT_FLAGS_1      0x6ffffffb

/* Dynamic Flags - DT_FLAGS .dynamic entry */
#define DF_ORIGIN       0x00000001
#define DF_SYMBOLIC     0x00000002
#define DF_TEXTREL      0x00000004
#define DF_BIND_NOW     0x00000008
#define DF_STATIC_TLS   0x00000010

/* Dynamic Flags - DT_FLAGS_1 .dynamic entry */
#define DF_1_NOW	0x00000001
#define DF_1_GLOBAL	0x00000002
#define DF_1_GROUP	0x00000004
#define DF_1_NODELETE	0x00000008
#define DF_1_LOADFLTR	0x00000010
#define DF_1_INITFIRST	0x00000020
#define DF_1_NOOPEN	0x00000040
#define DF_1_ORIGIN	0x00000080
#define DF_1_DIRECT	0x00000100
#define DF_1_TRANS	0x00000200
#define DF_1_INTERPOSE	0x00000400
#define DF_1_NODEFLIB	0x00000800
#define DF_1_NODUMP	0x00001000
#define DF_1_CONLFAT	0x00002000

/* Standard ELF hashing function */
unsigned int elf_hash(const unsigned char *name);

/*
 * Note header
 */
typedef struct {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
} Elf32_Nhdr;

typedef struct {
	Elf64_Half n_namesz;
	Elf64_Half n_descsz;
	Elf64_Half n_type;
} Elf64_Nhdr;

/*
 * Note Definitions
 */
typedef struct {
	Elf32_Word namesz;
	Elf32_Word descsz;
	Elf32_Word type;
} Elf32_Note;

typedef struct {
	Elf64_Half namesz;
	Elf64_Half descsz;
	Elf64_Half type;
} Elf64_Note;

/*
 * OpenBSD-specific core file information.
 *
 * OpenBSD ELF core files use notes to provide information about
 * the process's state.  The note name is "OpenBSD" for information
 * that is global to the process, and "OpenBSD@@nn", where "nn" is the
 * thread ID of the thread that the information belongs to (such as
 * register state).
 *
 * We use the following note identifiers:
 *
 *	NT_OPENBSD_PROCINFO
 *		Note is a "elfcore_procinfo" structure.
 *	NT_OPENBSD_AUXV
 *		Note is a a bunch of Auxilliary Vectors, terminated by
 *		an AT_NULL entry.
 *	NT_OPENBSD_REGS
 *		Note is a "reg" structure.
 *	NT_OPENBSD_FPREGS
 *		Note is a "fpreg" structure.
 *
 * Please try to keep the members of the "elfcore_procinfo" structure
 * nicely aligned, and if you add elements, add them to the end and
 * bump the version.
 */

#define NT_OPENBSD_PROCINFO	10
#define NT_OPENBSD_AUXV		11

#define NT_OPENBSD_REGS		20
#define NT_OPENBSD_FPREGS	21
#define NT_OPENBSD_XFPREGS	22
#define NT_OPENBSD_WCOOKIE	23

struct elfcore_procinfo {
	/* Version 1 fields start here. */
	uint32_t	cpi_version;	/* netbsd_elfcore_procinfo version */
#define ELFCORE_PROCINFO_VERSION	1
	uint32_t	cpi_cpisize;	/* sizeof(netbsd_elfcore_procinfo) */
	uint32_t	cpi_signo;	/* killing signal */
	uint32_t	cpi_sigcode;	/* signal code */
	uint32_t	cpi_sigpend;	/* pending signals */
	uint32_t	cpi_sigmask;	/* blocked signals */
	uint32_t	cpi_sigignore;	/* ignored signals */
	uint32_t	cpi_sigcatch;	/* signals being caught by user */
	int32_t		cpi_pid;	/* process ID */
	int32_t		cpi_ppid;	/* parent process ID */
	int32_t		cpi_pgrp;	/* process group ID */
	int32_t		cpi_sid;	/* session ID */
	uint32_t	cpi_ruid;	/* real user ID */
	uint32_t	cpi_euid;	/* effective user ID */
	uint32_t	cpi_svuid;	/* saved user ID */
	uint32_t	cpi_rgid;	/* real group ID */
	uint32_t	cpi_egid;	/* effective group ID */
	uint32_t	cpi_svgid;	/* saved group ID */
	int8_t		cpi_name[32];	/* copy of pr->ps_comm */
};

/*
 * XXX - these _KERNEL items aren't part of the ABI!
 */
#if defined(_KERNEL) || defined(_DYN_LOADER)

#define ELF32_NO_ADDR	((uint32_t) ~0)	/* Indicates addr. not yet filled in */

typedef struct {
	Elf32_Sword	au_id;				/* 32-bit id */
	Elf32_Word	au_v;				/* 32-bit value */
} Aux32Info;

#define ELF64_NO_ADDR	((__uint64_t) ~0)/* Indicates addr. not yet filled in */

typedef struct {
	Elf64_Shalf	au_id;				/* 32-bit id */
	Elf64_Xword	au_v;				/* 64-bit value */
} Aux64Info;

enum AuxID {
	AUX_null = 0,
	AUX_ignore = 1,
	AUX_execfd = 2,
	AUX_phdr = 3,			/* &phdr[0] */
	AUX_phent = 4,			/* sizeof(phdr[0]) */
	AUX_phnum = 5,			/* # phdr entries */
	AUX_pagesz = 6,			/* PAGESIZE */
	AUX_base = 7,			/* ld.so base addr */
	AUX_flags = 8,			/* processor flags */
	AUX_entry = 9,			/* a.out entry */
	AUX_sun_uid = 2000,		/* euid */
	AUX_sun_ruid = 2001,		/* ruid */
	AUX_sun_gid = 2002,		/* egid */
	AUX_sun_rgid = 2003		/* rgid */
};

struct elf_args {
        u_long  arg_entry;		/* program entry point */
        u_long  arg_interp;		/* Interpreter load address */
        u_long  arg_phaddr;		/* program header address */
        u_long  arg_phentsize;		/* Size of program header */
        u_long  arg_phnum;		/* Number of program headers */
};

#endif

#if !defined(ELFSIZE) && defined(ARCH_ELFSIZE)
#define ELFSIZE ARCH_ELFSIZE
#endif

#if defined(ELFSIZE)
#define CONCAT(x,y)	__CONCAT(x,y)
#define ELFNAME(x)	CONCAT(elf,CONCAT(ELFSIZE,CONCAT(_,x)))
#define ELFDEFNNAME(x)	CONCAT(ELF,CONCAT(ELFSIZE,CONCAT(_,x)))
#endif

#if defined(ELFSIZE) && (ELFSIZE == 32)
#define Elf_Ehdr	Elf32_Ehdr
#define Elf_Phdr	Elf32_Phdr
#define Elf_Shdr	Elf32_Shdr
#define Elf_Sym		Elf32_Sym
#define Elf_Rel		Elf32_Rel
#define Elf_RelA	Elf32_Rela
#define Elf_Dyn		Elf32_Dyn
#define Elf_Half	Elf32_Half
#define Elf_Word	Elf32_Word
#define Elf_Sword	Elf32_Sword
#define Elf_Addr	Elf32_Addr
#define Elf_Off		Elf32_Off
#define Elf_Nhdr	Elf32_Nhdr
#define Elf_Note	Elf32_Note

#define ELF_R_SYM	ELF32_R_SYM
#define ELF_R_TYPE	ELF32_R_TYPE
#define ELF_R_INFO	ELF32_R_INFO
#define ELFCLASS	ELFCLASS32

#define ELF_ST_BIND	ELF32_ST_BIND
#define ELF_ST_TYPE	ELF32_ST_TYPE
#define ELF_ST_INFO	ELF32_ST_INFO

#define ELF_NO_ADDR	ELF32_NO_ADDR
#define AuxInfo		Aux32Info
#elif defined(ELFSIZE) && (ELFSIZE == 64)
#define Elf_Ehdr	Elf64_Ehdr
#define Elf_Phdr	Elf64_Phdr
#define Elf_Shdr	Elf64_Shdr
#define Elf_Sym		Elf64_Sym
#define Elf_Rel		Elf64_Rel
#define Elf_RelA	Elf64_Rela
#define Elf_Dyn		Elf64_Dyn
#define Elf_Half	Elf64_Half
#define Elf_Word	Elf64_Word
#define Elf_Sword	Elf64_Sword
#define Elf_Addr	Elf64_Addr
#define Elf_Off		Elf64_Off
#define Elf_Nhdr	Elf64_Nhdr
#define Elf_Note	Elf64_Note

#define ELF_R_SYM	ELF64_R_SYM
#define ELF_R_TYPE	ELF64_R_TYPE
#define ELF_R_INFO	ELF64_R_INFO
#define ELFCLASS	ELFCLASS64

#define ELF_ST_BIND	ELF64_ST_BIND
#define ELF_ST_TYPE	ELF64_ST_TYPE
#define ELF_ST_INFO	ELF64_ST_INFO

#define ELF_NO_ADDR	ELF64_NO_ADDR
#define AuxInfo		Aux64Info
#endif

#ifndef _KERNEL
extern Elf_Dyn		_DYNAMIC[];
#endif

#ifdef	_KERNEL
int	exec_elf_makecmds(struct proc *, struct exec_package *);
#endif /* _KERNEL */

#define ELF_TARG_VER	1	/* The ver for which this code is intended */

#endif /* _SYS_EXEC_ELF_H_ */
@


1.72
log
@Include sys/types.h rather than machine/_types.h.  With this change
link.h can be included without first including sys/types.h matching the
behaviour on other systems.

Suggested by and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.71 2017/02/08 05:09:25 guenther Exp $	*/
d533 15
@


1.71
log
@In exec_elf.c: expand ELFNAME(), ELFNAME2(), and ELFNAMEEND() except
leaving out the size, so that
	ELFNAME2(exec,makecmds)
becomes
	exec_elf_makecmds
instead of
	exec_elf{32,64}_makecmds
and then delete the ELFNAME2() and ELFNAMEEND() macros.

Move the prototypes for functions local to exec_elf.c to there from
exec_elf.h.

Simplify the SMALL_KERNEL conditionals around the ELF coredump code.

Change exec_conf.c to use the size-generic names and macros

Remove exec_elf{32,64}.c and just build exec_elf.c; delete the
_KERN_DO_ELF and _KERN_DO_ELF64 #defines.

ok jca@@, encouragement from deraadt@@ and tom@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.70 2017/02/08 05:02:05 guenther Exp $	*/
d36 1
a36 1
#include <machine/_types.h>
@


1.70
log
@Move ELF_AUX_ENTRIES from exec_elf.h to exec_elf.c; it's totally internal
and not something we guarantee to userspace

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.69 2017/02/08 04:47:23 guenther Exp $	*/
a659 2
#define ELFNAME2(x,y)	CONCAT(x,CONCAT(_elf,CONCAT(ELFSIZE,CONCAT(_,y))))
#define ELFNAMEEND(x)	CONCAT(x,CONCAT(_elf,ELFSIZE))
d724 1
a724 17
#ifdef _KERN_DO_ELF64
int exec_elf64_makecmds(struct proc *, struct exec_package *);
void *elf64_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf64_fixup(struct proc *, struct exec_package *);
int elf64_os_pt_note(struct proc *, struct exec_package *, Elf64_Ehdr *,
	char *, size_t, size_t);
#endif
#ifdef _KERN_DO_ELF
int exec_elf32_makecmds(struct proc *, struct exec_package *);
void *elf32_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf32_fixup(struct proc *, struct exec_package *);
int elf32_os_pt_note(struct proc *, struct exec_package *, Elf32_Ehdr *,
	char *, size_t, size_t);
#endif

@


1.69
log
@elf{32,64}_check_brand() isn't used; delete it

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.68 2017/02/08 04:34:29 guenther Exp $	*/
a612 1
#define ELF_AUX_ENTRIES	8		/* Size of aux array passed to loader */
a619 1
#define ELF64_AUX_ENTRIES	8	/* Size of aux array passed to loader */
@


1.68
log
@Provide size-generic ELF_NO_ADDR in <sys/exec_elf.h> and use that instead
of ELFDEFNNAME(NO_ADDR)

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.67 2017/01/30 05:00:31 guenther Exp $	*/
a732 1
char *elf64_check_brand(Elf64_Ehdr *);
a740 1
char *elf32_check_brand(Elf32_Ehdr *);
@


1.67
log
@Fix ELF64_R_TYPE(reloc->r_info) to have the same type on mips64le
as on other LP64 archs, __uint64_t, so that printf-like functions
don't require extra casting...then eliminate the extra cast in
ld.so/mips64/rtld_machine.c

discussed with miod
ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.66 2017/01/21 05:42:03 guenther Exp $	*/
d692 1
d719 1
@


1.66
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.65 2016/11/28 21:50:12 patrick Exp $	*/
d389 1
a389 1
#define	ELF64_R_TYPE(info)	(swap32((info) >> 32))
@


1.65
log
@Add the ELF machine type for AArch64 as specified in the ELF spec for
the ARM 64-bit Architecture.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.64 2016/09/17 17:39:34 jasper Exp $	*/
d604 1
a604 1
	int8_t		cpi_name[32];	/* copy of p->p_comm */
@


1.64
log
@move the .SUNW_ctf section name definition to exec_elf.h and document it in elf(5)

feedback from guenther@@
ok guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.63 2016/09/07 20:12:42 jasper Exp $	*/
d197 1
@


1.63
log
@- point to binutils 2.17 version of elf/mips.h
- fix trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.62 2016/09/04 11:52:55 kettenis Exp $	*/
d267 1
@


1.62
log
@Add PT_GNU_EH_FRAME.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.61 2016/08/30 12:47:19 kettenis Exp $	*/
d66 1
a66 1
 * e_ident[] identification indexes 
d77 1
a77 1
#define EI_ABIVERSION	8		/* ABI version */ 
d139 1
a139 1
	Elf32_Half	e_shstrndx;	/* section header table's "section 
d180 1
a180 1
/* 
d382 1
a382 1
 * pieces (see gnu/usr.bin/binutils/include/elf/mips.h for details).
@


1.61
log
@Move DT_NUM from <sys/exec_elf.h> to resolv.h in ld.so where it belongs.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.60 2016/08/23 06:46:17 kettenis Exp $	*/
d429 1
@


1.60
log
@Implement support for DT_INIT_ARRAY, DT_FINI_ARRAY and DT_PREINIT_ARRAY.
Don't skip DT_INIT and DT_FINI for the main executable.  This matches what
Linux and Solaris do.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.59 2016/07/14 06:03:46 guenther Exp $	*/
a526 3

/* ld.so: number of low tags that are used saved internally (0 .. DT_NUM-1) */
#define DT_NUM		(DT_PREINIT_ARRAYSZ+1)
@


1.59
log
@Add PT_GNU_RELRO, for ld.so work

ok millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.58 2016/05/29 00:48:05 deraadt Exp $	*/
d529 1
a529 1
#define DT_NUM		(DT_JMPREL+1)
@


1.58
log
@define PT_OPENBSD_WXNEEDED
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.57 2016/03/24 06:05:43 guenther Exp $	*/
d428 2
@


1.57
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.56 2015/10/13 04:29:50 guenther Exp $	*/
d430 1
@


1.56
log
@Add some newer DT_* and DF_* constants

ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.55 2015/08/24 21:09:43 jca Exp $	*/
d622 1
a622 1
	Elf64_Xword	au_v;				/* 64-bit id */
@


1.55
log
@Typos; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.54 2014/11/26 20:06:53 stsp Exp $	*/
d483 9
d501 7
@


1.54
log
@Add a new ELF segment .openbsd.bootdata to the sparc64 kernel.
This can be used to pass boot parameters to the kernel which can't be passed
safely via the Open Firmware interface, such as softraid volume IDs and keys.
The kernel already reads the arguments if available but ofwboot won't provide
them until further changes are committed there.

With support from deraadt, kettenis and matthew.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.53 2014/01/03 03:00:39 guenther Exp $	*/
d533 1
a533 1
 * OpenBSDBSD ELF core files use notes to provide information about
d544 1
a544 1
 *		Note is a a bunch of Auxilliary Vectors, terminted by
@


1.53
log
@Fix spelling in comments
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.52 2013/05/08 20:55:14 guenther Exp $	*/
d430 1
a430 1

@


1.52
log
@Implement symbol caching and RELACOUNT/RELCOUNT optimizations.
Much assistance and testing by miod

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.51 2012/09/11 15:44:18 deraadt Exp $	*/
d186 1
a186 1
#define EM_SPARC64	11		/* SPARC v9 64-bit unoffical */
d278 1
a278 1
#define ELF_REL_DYN     ".rel.dyn"	/* relocaltion dynamic link info */
@


1.51
log
@Remove the 'OLF method' used for the transition from a.out to ELF and
for all the compat layers which are now gone.  Linux compat still works
because it always used another method in any case, and nothing looks at
p_os anymore.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.50 2012/08/20 23:25:07 matthew Exp $	*/
a482 1
#define DT_NUM		25		/* Number used. */
d489 2
d509 2
@


1.50
log
@Add support for .openbsd.randomdata sections and PT_OPENBSD_RANDOMIZE
segments to the kernel, ld (2.15), and ld.so.  Tested on alpha, amd64,
i386, macppc, and sparc64 (thanks naddy, mpi, and okan!).

Idea discussed for some time; committing now for further testing.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.49 2011/09/20 16:42:01 pirofti Exp $	*/
a628 1
        u_long  arg_os;			/* OS tag */
@


1.49
log
@Add new machine entry for Itanium.

While at it clean-up and fix machine types to reflect reality.

Okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.48 2010/06/07 09:41:16 sthen Exp $	*/
d429 3
d484 2
@


1.48
log
@update url in comment; Nikolai Fetissov
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.47 2010/05/02 00:28:38 guenther Exp $	*/
d194 1
a194 1
#define EM_ALPHA_EXP	0x9026		/* DEC ALPHA */
d197 5
a201 1
#define EM_NUM		15		/* number of machine types */
@


1.47
log
@Add defines for thread-local-storage sections/symbols/segments and for
the DT_1_FLAGS .dynamic entry and its known flag values.  Remove the
unused and useless STT_NUM and PT_NUM defines.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.46 2010/01/31 21:37:19 otto Exp $	*/
d67 1
a67 1
 * See http://www.caldera.com/developers/gabi/2000-07-17/ch4.eheader.html
@


1.46
log
@fix ELF64_R_INFO for mips64el to cast to 64 bits before shift; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.45 2010/01/25 05:18:35 miod Exp $	*/
d288 1
d337 1
a337 1
#define STT_NUM		5		/* number of symbol types */
d419 1
a419 1
#define PT_NUM		7		/* Number of segment types */
d479 21
a499 1
	
@


1.45
log
@Provide proper ELF64_R_{SYM,TYPE,INFO} on little endian mips64, since these
do not follow the regular layout. Makes ld.so much happier on loongson.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.44 2009/03/05 19:52:24 kettenis Exp $	*/
d384 1
a384 1
#define	ELF64_R_INFO(s,t)	((swap32(t) << 32) + (__uint32_t)(s))
@


1.44
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.43 2007/05/14 05:04:58 tedu Exp $	*/
d372 14
@


1.43
log
@uint32_t is not spelled u_long.  makes the 32-bit NO_ADDR potentially useful on
64-bit machines, even though it's not used.  ok art deraadt millert tom
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.42 2006/10/06 20:58:17 miod Exp $	*/
d482 58
@


1.42
log
@Early bits for a 32-bit SuperH toolchain, currently for little-endian
systems only; more work is necessary in ld land.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.41 2006/01/06 18:53:05 millert Exp $	*/
d488 1
a488 1
#define ELF32_NO_ADDR	((u_long) ~0)	/* Indicates addr. not yet filled in */
@


1.41
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.40 2004/10/10 15:02:18 kettenis Exp $	*/
d192 1
@


1.40
log
@Add PT_LOOS, PT_HIOS and Elf_Half.
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.39 2004/02/27 17:36:16 deraadt Exp $	*/
d36 1
a36 1
#include <machine/types.h>
d39 1
a39 1
typedef u_int8_t	Elf_Byte;
d41 9
a49 9
typedef u_int32_t	Elf32_Addr;	/* Unsigned program address */
typedef u_int32_t	Elf32_Off;	/* Unsigned file offset */
typedef int32_t		Elf32_Sword;	/* Signed large integer */
typedef u_int32_t	Elf32_Word;	/* Unsigned large integer */
typedef u_int16_t	Elf32_Half;	/* Unsigned medium integer */

typedef u_int64_t	Elf64_Addr;
typedef u_int64_t	Elf64_Off;
typedef int32_t		Elf64_Shalf;
d52 2
a53 2
typedef int64_t		Elf64_Sword;
typedef u_int64_t	Elf64_Word;
d55 2
a56 2
typedef int32_t		Elf64_Sword;
typedef u_int32_t	Elf64_Word;
d59 2
a60 2
typedef int64_t		Elf64_Sxword;
typedef u_int64_t	Elf64_Xword;
d62 2
a63 2
typedef u_int32_t	Elf64_Half;
typedef u_int16_t	Elf64_Quarter;
d370 1
a370 1
#define ELF64_R_INFO(s,t) 	(((s) << 32) + (u_int32_t)(t))
d495 1
a495 1
#define ELF64_NO_ADDR	((u_int64_t) ~0)/* Indicates addr. not yet filled in */
@


1.39
log
@change amd64's MACHINE_ARCH from x86_64 to amd64.  There are many many
reasons for this, quite a few of them technical, and not all of them
in response to Intel's broken ia32e crud.  The gcc toolchain stays at
x86_64 for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.38 2004/01/29 23:15:53 drahn Exp $	*/
d404 2
d551 1
d577 1
@


1.38
log
@recognize arm.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.37 2004/01/28 01:39:40 mickey Exp $	*/
d194 1
a194 1
#define EM_X86_64	62		/* AMD x86-64 architecture */
@


1.37
log
@an amd64 arch support.
hacked by art@@ from netbsd sources and then later debugged
by me into the shape where it can host itself.
no bootloader yet as needs redoing from the
recent advanced i386 sources (anyone? ;)
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.36 2003/09/18 09:58:13 jmc Exp $	*/
d190 1
@


1.36
log
@spacing;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.35 2003/05/13 16:38:34 millert Exp $	*/
d193 1
@


1.35
log
@sync e_ident[] identification indexes w/
http://www.caldera.com/developers/gabi/2000-07-17/ch4.eheader.html
EI_BRAND is gone, we now have EI_OSABI and EI_ABIVERSION

Add ELFOSABI_* defines that correspond to what binutils uses.  Note
that we don't currently set e_ident[EI_OSABI] to ELFOSABI_OPENBSD,
though we probably should.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.34 2002/07/31 03:10:50 art Exp $	*/
d125 1
a125 1
typedef struct elfhdr{
d338 1
a338 2
typedef struct 
{
d344 1
a344 2
typedef struct 
{
@


1.34
log
@Define _DYNAMIC correctly for all architectures.
The alleged alpha problems didn't show up.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.33 2002/03/14 01:27:14 millert Exp $	*/
d65 4
a68 1
/* e_ident[] identification indexes */
d76 3
a78 2
#define EI_PAD		7		/* start of pad bytes */
#define EI_BRAND	8		/* brand */ 
d100 17
@


1.33
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.32 2001/09/26 09:15:22 art Exp $	*/
a401 2
extern Elf32_Dyn	_DYNAMIC[];	/* XXX not 64-bit clean */

d570 4
@


1.32
log
@Elf64_Word is 64-bit only on alpha. Introduce Elf64_Xword and fix stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.31 2001/09/19 13:28:43 art Exp $	*/
d576 7
a582 7
int exec_elf64_makecmds __P((struct proc *, struct exec_package *));
void *elf64_copyargs __P((struct exec_package *, struct ps_strings *,
        void *, void *));
int exec_elf64_fixup __P((struct proc *, struct exec_package *));
char *elf64_check_brand __P((Elf64_Ehdr *));
int elf64_os_pt_note __P((struct proc *, struct exec_package *, Elf64_Ehdr *,
	char *, size_t, size_t));
d585 7
a591 7
int exec_elf32_makecmds __P((struct proc *, struct exec_package *));
void *elf32_copyargs __P((struct exec_package *, struct ps_strings *,
        void *, void *));
int exec_elf32_fixup __P((struct proc *, struct exec_package *));
char *elf32_check_brand __P((Elf32_Ehdr *));
int elf32_os_pt_note __P((struct proc *, struct exec_package *, Elf32_Ehdr *,
	char *, size_t, size_t));
@


1.32.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.32 2001/09/26 09:15:22 art Exp $	*/
d576 7
a582 7
int exec_elf64_makecmds(struct proc *, struct exec_package *);
void *elf64_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf64_fixup(struct proc *, struct exec_package *);
char *elf64_check_brand(Elf64_Ehdr *);
int elf64_os_pt_note(struct proc *, struct exec_package *, Elf64_Ehdr *,
	char *, size_t, size_t);
d585 7
a591 7
int exec_elf32_makecmds(struct proc *, struct exec_package *);
void *elf32_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf32_fixup(struct proc *, struct exec_package *);
char *elf32_check_brand(Elf32_Ehdr *);
int elf32_os_pt_note(struct proc *, struct exec_package *, Elf32_Ehdr *,
	char *, size_t, size_t);
@


1.32.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.32.4.1 2002/06/11 03:32:33 art Exp $	*/
d402 2
a571 4
#endif

#ifndef _KERNEL
extern Elf_Dyn		_DYNAMIC[];
@


1.32.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 4
/*
 * e_ident[] identification indexes 
 * See http://www.caldera.com/developers/gabi/2000-07-17/ch4.eheader.html
 */
d73 2
a74 3
#define EI_OSABI	7		/* OS/ABI ID */
#define EI_ABIVERSION	8		/* ABI version */ 
#define EI_PAD		9		/* start of pad bytes */
a95 17

/* e_ident[] Operating System/ABI */
#define ELFOSABI_SYSV		0	/* UNIX System V ABI */
#define ELFOSABI_HPUX		1	/* HP-UX operating system */
#define ELFOSABI_NETBSD		2	/* NetBSD */
#define ELFOSABI_LINUX		3	/* GNU/Linux */
#define ELFOSABI_HURD		4	/* GNU/Hurd */
#define ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
#define ELFOSABI_SOLARIS	6	/* Solaris */
#define ELFOSABI_MONTEREY	7	/* Monterey */
#define ELFOSABI_IRIX		8	/* IRIX */
#define ELFOSABI_FREEBSD	9	/* FreeBSD */
#define ELFOSABI_TRU64		10	/* TRU64 UNIX */
#define ELFOSABI_MODESTO	11	/* Novell Modesto */
#define ELFOSABI_OPENBSD	12	/* OpenBSD */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
@


1.31
log
@Unify elf32 and elf64 code with macros. This forced a renaming
of a few functions from elf32.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.30 2001/08/19 15:20:25 art Exp $	*/
d49 3
a52 1
typedef int32_t		Elf64_Shalf;
d54 8
d198 1
a198 1
	Elf64_Word	sh_flags;	/* section flags */
d201 1
a201 1
	Elf64_Word	sh_size;	/* section size */
d204 2
a205 2
	Elf64_Word	sh_addralign;	/* memory alignment */
	Elf64_Word	sh_entsize;	/* table entry size */
d282 2
a283 2
	Elf64_Word	st_value;	/* value of symbol */
	Elf64_Word	st_size;	/* size of symbol */
d337 2
a338 2
	Elf64_Word	r_offset;	/* where to do it */
	Elf64_Word	r_info;		/* index & type of relocation */
d342 3
a344 3
	Elf64_Word	r_offset;	/* where to do it */
	Elf64_Word	r_info;		/* index & type of relocation */
	Elf64_Word	r_addend;	/* adjustment value */
d369 3
a371 3
	Elf64_Word	p_filesz;	/* file size */
	Elf64_Word	p_memsz;	/* memory size */
	Elf64_Word	p_align;	/* memory & file alignment */
d405 1
a405 1
	Elf64_Word	d_tag;		/* controls meaning of d_val */
d408 1
a408 1
		Elf64_Word	d_val;
d479 1
a479 1
	Elf64_Word	au_v;				/* 64-bit id */
@


1.30
log
@e_machine identifiers for sparcv8plus and sparcv9
from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.29 2001/06/06 23:18:46 art Exp $	*/
d525 1
d550 1
d575 2
a576 2
int exec_elf_makecmds __P((struct proc *, struct exec_package *));
void *elf_copyargs __P((struct exec_package *, struct ps_strings *,
d578 4
a581 2
int exec_elf_fixup __P((struct proc *, struct exec_package *));
char *elf_check_brand __P((Elf32_Ehdr *));
@


1.29
log
@typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.28 2001/03/16 04:39:08 hugh Exp $	*/
d157 1
d160 1
@


1.28
log
@Add the VAX magic number.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.27 2001/01/23 16:58:06 drahn Exp $	*/
d488 1
a488 1
        u_long  arg_entry;		/* progran entry point */
@


1.27
log
@Add machine/exec.h to allow machine to set ELFSIZE before using
ifdefing code based on if that define exists.
OKed by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.26 2001/01/22 23:48:35 deraadt Exp $	*/
d160 1
@


1.26
log
@Art is a B.....
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.25 2001/01/22 14:52:56 art Exp $	*/
d37 1
@


1.25
log
@If ELFSIZE isn't explicitly defined, define it do ARCH_ELFSIZE
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.24 2001/01/21 17:09:21 art Exp $	*/
d458 1
a458 1
} AuxInfo; /* XXX needs to be Aux32Info */
@


1.24
log
@Some fixes to the size independent macros.
Resolve the confusion about Rela and RelA.
Add ELF_R_INFO.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.23 2001/01/16 18:04:19 art Exp $	*/
d494 4
@


1.23
log
@Don't include machine/elf_machdep.h, not all archs have it yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.22 2001/01/16 15:44:36 art Exp $	*/
d510 1
a510 1
#define Elf_RelA	Elf32_RelA
d520 1
d534 1
a534 1
#define Elf_RelA	Elf64_RelA
d544 1
@


1.22
log
@Allow use of ELFSIZE to get Elf_* types and macros instead of explicit Elf{32,64}_.
From NetBSD

This will probably let us unify a lot of code (exec_elf.c vs. exec_elf64.c).
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.21 2000/08/11 00:35:18 deraadt Exp $	*/
a502 2

#include <machine/elf_machdep.h>
@


1.21
log
@Elf64_RelA -> Elf64_Rela
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.20 1999/09/19 16:16:49 kstailey Exp $	*/
d494 58
@


1.20
log
@improved OS brand PT_NOTE detection
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.19 1999/09/18 15:43:33 kstailey Exp $	*/
d331 1
a331 1
} Elf64_RelA;
@


1.20.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.28 2001/03/16 04:39:08 hugh Exp $	*/
a36 1
#include <machine/exec.h>
a158 1
#define EM_VAX		75		/* DEC VAX */
d331 1
a331 1
} Elf64_Rela;
d458 1
a458 1
} Aux32Info;
a493 62
#endif

#if !defined(ELFSIZE) && defined(ARCH_ELFSIZE)
#define ELFSIZE ARCH_ELFSIZE
#endif

#if defined(ELFSIZE)
#define CONCAT(x,y)	__CONCAT(x,y)
#define ELFNAME(x)	CONCAT(elf,CONCAT(ELFSIZE,CONCAT(_,x)))
#define ELFNAME2(x,y)	CONCAT(x,CONCAT(_elf,CONCAT(ELFSIZE,CONCAT(_,y))))
#define ELFNAMEEND(x)	CONCAT(x,CONCAT(_elf,ELFSIZE))
#define ELFDEFNNAME(x)	CONCAT(ELF,CONCAT(ELFSIZE,CONCAT(_,x)))
#endif

#if defined(ELFSIZE) && (ELFSIZE == 32)
#define Elf_Ehdr	Elf32_Ehdr
#define Elf_Phdr	Elf32_Phdr
#define Elf_Shdr	Elf32_Shdr
#define Elf_Sym		Elf32_Sym
#define Elf_Rel		Elf32_Rel
#define Elf_RelA	Elf32_Rela
#define Elf_Dyn		Elf32_Dyn
#define Elf_Word	Elf32_Word
#define Elf_Sword	Elf32_Sword
#define Elf_Addr	Elf32_Addr
#define Elf_Off		Elf32_Off
#define Elf_Nhdr	Elf32_Nhdr

#define ELF_R_SYM	ELF32_R_SYM
#define ELF_R_TYPE	ELF32_R_TYPE
#define ELF_R_INFO	ELF32_R_INFO
#define ELFCLASS	ELFCLASS32

#define ELF_ST_BIND	ELF32_ST_BIND
#define ELF_ST_TYPE	ELF32_ST_TYPE
#define ELF_ST_INFO	ELF32_ST_INFO

#define AuxInfo		Aux32Info
#elif defined(ELFSIZE) && (ELFSIZE == 64)
#define Elf_Ehdr	Elf64_Ehdr
#define Elf_Phdr	Elf64_Phdr
#define Elf_Shdr	Elf64_Shdr
#define Elf_Sym		Elf64_Sym
#define Elf_Rel		Elf64_Rel
#define Elf_RelA	Elf64_Rela
#define Elf_Dyn		Elf64_Dyn
#define Elf_Word	Elf64_Word
#define Elf_Sword	Elf64_Sword
#define Elf_Addr	Elf64_Addr
#define Elf_Off		Elf64_Off
#define Elf_Nhdr	Elf64_Nhdr

#define ELF_R_SYM	ELF64_R_SYM
#define ELF_R_TYPE	ELF64_R_TYPE
#define ELF_R_INFO	ELF64_R_INFO
#define ELFCLASS	ELFCLASS64

#define ELF_ST_BIND	ELF64_ST_BIND
#define ELF_ST_TYPE	ELF64_ST_TYPE
#define ELF_ST_INFO	ELF64_ST_INFO

#define AuxInfo		Aux64Info
@


1.20.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.20.4.1 2001/05/14 22:45:01 niklas Exp $	*/
d488 1
a488 1
        u_long  arg_entry;		/* program entry point */
@


1.20.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.20.4.2 2001/07/04 11:00:19 niklas Exp $	*/
d49 1
a50 3

#ifdef __alpha__
typedef int64_t		Elf64_Sword;
a51 8
#else
typedef int32_t		Elf64_Sword;
typedef u_int32_t	Elf64_Word;
#endif

typedef int64_t		Elf64_Sxword;
typedef u_int64_t	Elf64_Xword;

a156 1
#define EM_SPARC32PLUS	18		/* Enhanced instruction set SPARC */
a158 1
#define EM_SPARCV9	43		/* SPARC version 9 */
d186 1
a186 1
	Elf64_Xword	sh_flags;	/* section flags */
d189 1
a189 1
	Elf64_Xword	sh_size;	/* section size */
d192 2
a193 2
	Elf64_Xword	sh_addralign;	/* memory alignment */
	Elf64_Xword	sh_entsize;	/* table entry size */
d270 2
a271 2
	Elf64_Xword	st_value;	/* value of symbol */
	Elf64_Xword	st_size;	/* size of symbol */
d325 2
a326 2
	Elf64_Xword	r_offset;	/* where to do it */
	Elf64_Xword	r_info;		/* index & type of relocation */
d330 3
a332 3
	Elf64_Xword	r_offset;	/* where to do it */
	Elf64_Xword	r_info;		/* index & type of relocation */
	Elf64_Sxword	r_addend;	/* adjustment value */
d357 3
a359 3
	Elf64_Xword	p_filesz;	/* file size */
	Elf64_Xword	p_memsz;	/* memory size */
	Elf64_Xword	p_align;	/* memory & file alignment */
d393 1
a393 1
	Elf64_Xword	d_tag;		/* controls meaning of d_val */
d396 1
a396 1
		Elf64_Xword	d_val;
d467 1
a467 1
	Elf64_Xword	au_v;				/* 64-bit id */
a522 1
#define Elf_Note	Elf32_Note
a546 1
#define Elf_Note	Elf64_Note
d571 2
a572 2
int exec_elf32_makecmds __P((struct proc *, struct exec_package *));
void *elf32_copyargs __P((struct exec_package *, struct ps_strings *,
d574 2
a575 4
int exec_elf32_fixup __P((struct proc *, struct exec_package *));
char *elf32_check_brand __P((Elf32_Ehdr *));
int elf32_os_pt_note __P((struct proc *, struct exec_package *, Elf32_Ehdr *,
	char *, size_t, size_t));
@


1.20.4.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d576 7
a582 7
int exec_elf64_makecmds(struct proc *, struct exec_package *);
void *elf64_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf64_fixup(struct proc *, struct exec_package *);
char *elf64_check_brand(Elf64_Ehdr *);
int elf64_os_pt_note(struct proc *, struct exec_package *, Elf64_Ehdr *,
	char *, size_t, size_t);
d585 7
a591 7
int exec_elf32_makecmds(struct proc *, struct exec_package *);
void *elf32_copyargs(struct exec_package *, struct ps_strings *,
        void *, void *);
int exec_elf32_fixup(struct proc *, struct exec_package *);
char *elf32_check_brand(Elf32_Ehdr *);
int elf32_os_pt_note(struct proc *, struct exec_package *, Elf32_Ehdr *,
	char *, size_t, size_t);
@


1.20.4.5
log
@Sync the SMP branch with 3.3
@
text
@d402 2
a571 4
#endif

#ifndef _KERNEL
extern Elf_Dyn		_DYNAMIC[];
@


1.20.4.6
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d65 1
a65 4
/*
 * e_ident[] identification indexes 
 * See http://www.caldera.com/developers/gabi/2000-07-17/ch4.eheader.html
 */
d73 2
a74 3
#define EI_OSABI	7		/* OS/ABI ID */
#define EI_ABIVERSION	8		/* ABI version */ 
#define EI_PAD		9		/* start of pad bytes */
a95 17

/* e_ident[] Operating System/ABI */
#define ELFOSABI_SYSV		0	/* UNIX System V ABI */
#define ELFOSABI_HPUX		1	/* HP-UX operating system */
#define ELFOSABI_NETBSD		2	/* NetBSD */
#define ELFOSABI_LINUX		3	/* GNU/Linux */
#define ELFOSABI_HURD		4	/* GNU/Hurd */
#define ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
#define ELFOSABI_SOLARIS	6	/* Solaris */
#define ELFOSABI_MONTEREY	7	/* Monterey */
#define ELFOSABI_IRIX		8	/* IRIX */
#define ELFOSABI_FREEBSD	9	/* FreeBSD */
#define ELFOSABI_TRU64		10	/* TRU64 UNIX */
#define ELFOSABI_MODESTO	11	/* Novell Modesto */
#define ELFOSABI_OPENBSD	12	/* OpenBSD */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */
@


1.20.4.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d125 1
a125 1
typedef struct elfhdr {
a189 1
#define EM_ARM		40		/* Advanced RISC Machines ARM */
a192 1
#define EM_X86_64	62		/* AMD x86-64 architecture */
d338 2
a339 1
typedef struct {
d345 2
a346 1
typedef struct {
@


1.20.4.8
log
@Merge with the trunk
@
text
@d194 1
a194 1
#define EM_AMD64	62		/* AMD64 architecture */
@


1.19
log
@ELF64_ST_*() macros
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.18 1999/09/10 20:47:13 kstailey Exp $	*/
d433 15
d503 2
@


1.18
log
@undo previous
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.17 1999/09/10 20:05:50 kstailey Exp $	*/
d279 4
@


1.17
log
@temp fix
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.16 1999/09/10 12:24:27 kstailey Exp $	*/
d485 1
a485 1
/* #ifdef _KERN_DO_ELF */
d491 1
a491 1
/* #endif */
@


1.16
log
@ELF64
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.15 1999/09/07 21:52:44 kstailey Exp $	*/
d485 1
a485 1
#ifdef _KERN_DO_ELF
d491 1
a491 1
#endif
@


1.15
log
@ELF64
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.14 1999/02/10 08:07:20 deraadt Exp $	*/
d158 2
a159 1
#define EM_NUM		14		/* number of machine types */
d441 3
d478 8
d491 1
@


1.14
log
@branding support and freebsd elf
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.13 1999/02/01 16:33:01 pefo Exp $	*/
d38 2
a39 5
/*
 * These typedefs need to be handled better -
 *  doesn't work on 64-bit machines.  Note:
 *  there currently isn't a 64-bit ABI.
 */
d46 8
d111 17
d157 2
a158 1
#define EM_NUM		13		/* number of machine types */
d180 13
d262 9
d317 15
d344 11
d375 1
a375 2
typedef struct 
{
d377 1
a377 2
	union 
	{
d383 9
a391 1
extern Elf32_Dyn	_DYNAMIC[];
d436 8
a443 3
	int             au_id;
	unsigned long   au_v;
} AuxInfo;
@


1.13
log
@Define another dynamic tag as well as allow for use by dynld compile
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.12 1998/02/22 01:00:26 niklas Exp $	*/
d58 1
d396 1
@


1.12
log
@Improve fine-grain control over emulated binaries by storing OS tags during
the process' runtime, so that personality checks can be done later
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.11 1997/06/29 07:43:19 deraadt Exp $	*/
d341 2
a342 1
#define DT_NUM		24		/* Number used. */
d352 1
a352 1
#ifdef _KERNEL
d388 3
@


1.11
log
@another nasty long
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.10 1996/12/11 05:55:33 imp Exp $	*/
d384 1
@


1.10
log
@Sync headers to ld.so for gdb/arc support
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.9 1996/11/06 18:41:52 etheisen Exp $	*/
d346 1
a346 1
unsigned long elf_hash(const unsigned char *name);
@


1.9
log
@Fix copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.8 1996/10/27 20:08:26 etheisen Exp $	*/
d341 1
@


1.8
log
@OLF makes .os section and program header hack go away.
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.7 1996/08/31 09:19:14 pefo Exp $	*/
d3 1
a3 2
 * Copyright (c) 1995, 1996 Erik Theisen
 * All rights reserved.
@


1.7
log
@Cleanup exec
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.6 1996/06/12 07:31:37 deraadt Exp $	*/
d179 1
a179 2

#define SHT_NUM		13		/* number of section types */
d292 1
a292 1
#define PT_NUM		8		/* Number of segment types */
a389 31

/*
 * XXX - OpenBSD hack to determine
 * target OS - This is NOT ABI
 * compliant!!!
 */
struct elf_oshdr {
        Elf32_Word      os_name;        /* name string - index into strtab */
        Elf32_Word      os_type;        /* operating system type */
        Elf32_Half      os_major;       /* major version tag */
        Elf32_Half      os_minor;       /* minor version tag */
        Elf32_Half      os_subminor;    /* sub minor version tag */
        Elf32_Half      os_nmisc;       /* number of misc strings */
        Elf32_Word      os_misc;        /* misc string - index into strtab */
} Elf32_Oshdr;

/* Program header type, section header type,
    and section header name */
#define PT_OS		0x7fffffff	/* program header type */
#define SHT_OS		0xffffffff	/* section header type */
#define ELF_OS          ".os"		/* section header name string */

/* Operating system types */
#define OST_NULL        0               /* Invalid */
#define OST_OPENBSD     1               /* OpenBSD */
#define OST_LINUX       2               /* Linux */
#define OST_NUM         3               /* Number of operating system types */

/* Operating system names */
#define ELF_OPENBSD     "openbsd"       /* OpenBSD */
#define ELF_LINUX       "linux"         /* Linux */
@


1.6
log
@/* within comment
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.5 1996/05/29 03:04:51 deraadt Exp $	*/
a387 2
void *elf_copyargs __P((struct exec_package *, struct ps_strings *, void *,
	void *));
d390 1
@


1.5
log
@enable ELF/a.out/ECOFF in machine/exec.h
@
text
@d1 1
a1 1
/*	$OpenBSD: exec_elf.h,v 1.4 1996/05/22 07:44:29 etheisen Exp $	*/
d334 1
a334 1
					/*  search path */
@


1.4
log
@Moved contents of elf_abi.h into exec_elf.h. Modified dependant files to
reflect this.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d425 2
@


1.3
log
@From NetBSD: 960217 merge
@
text
@a1 2
/*	$NetBSD: exec_elf.h,v 1.2 1996/01/16 23:19:43 fvdl Exp $	*/

d3 1
a3 1
 * Copyright (c) 1994 Christos Zoulas
d29 5
d39 66
a104 17
typedef u_int32_t Elf32_Addr;
typedef u_int32_t Elf32_Off;
typedef int32_t   Elf32_Sword;
typedef u_int32_t Elf32_Word;
typedef u_int16_t Elf32_Half;


#define ELF_IDSIZE	16

enum Elf32_e_type {
	Elf32_et_none = 0,
	Elf32_et_rel,
	Elf32_et_exec,
	Elf32_et_dyn,
	Elf32_et_core,
	Elf32_et_num
};
d106 35
a140 12
enum Elf32_e_machine {
	Elf32_em_none = 0,
	Elf32_em_m32,
	Elf32_em_sparc,
	Elf32_em_386,
	Elf32_em_68k,
	Elf32_em_88k,
	Elf32_em_486,
	Elf32_em_860,
	Elf32_em_mips,
	Elf32_em_num
};
d142 1
d144 128
a271 35
	unsigned char	e_ident[ELF_IDSIZE];	/* Id bytes */
	Elf32_Half	e_type;			/* file type */
	Elf32_Half	e_machine;		/* machine type */
	Elf32_Word	e_version;		/* version number */
	Elf32_Addr	e_entry;		/* entry point */
	Elf32_Off	e_phoff;		/* Program hdr offset */
	Elf32_Off	e_shoff;		/* Section hdr offset */
	Elf32_Word	e_flags;		/* Processor flags */
	Elf32_Half      e_ehsize;		/* sizeof ehdr */
	Elf32_Half      e_phentsize;		/* Program header entry size */
	Elf32_Half      e_phnum;		/* Number of program headers */
	Elf32_Half      e_shentsize;		/* Section header entry size */
	Elf32_Half      e_shnum;		/* Number of section headers */
	Elf32_Half      e_shstrndx;		/* String table index */
} Elf32_Ehdr;


enum Elf32_p_pf {
	Elf32_pf_r = 4,
	Elf32_pf_w = 2,
	Elf32_pf_x = 1
};

enum Elf32_p_pt {
	Elf32_pt_nulli = 0,		/* Program header table entry unused */
	Elf32_pt_load = 1,		/* Loadable program segment */
	Elf32_pt_dynamic = 2,		/* Dynamic linking information */
	Elf32_pt_interp = 3,		/* Program interpreter */
	Elf32_pt_note = 4,		/* Auxiliary information */
	Elf32_pt_shlib = 5,		/* Reserved, unspecified semantics */
	Elf32_pt_phdr = 6,		/* Entry for header table itself */
	Elf32_pt_loproc = 0x70000000,	/* Processor-specific */
	Elf32_pt_hiproc = 0x7FFFFFFF	/* Processor-specific */

};
d273 1
d275 6
a280 6
	Elf32_Word	p_type;		/* entry type */
	Elf32_Off	p_offset;	/* offset */
	Elf32_Addr	p_vaddr;	/* virtual address */
	Elf32_Addr	p_paddr;	/* physical address */
	Elf32_Word	p_filesz;	/* file size */
	Elf32_Word	p_memsz;	/* memory size */
d282 1
a282 1
	Elf32_Word	p_align;	/* memory & file alignment */
d285 71
a355 2
#define Elf32_e_ident "\177ELF"
#define Elf32_e_siz (sizeof(Elf32_e_ident) - 1)
d358 2
a359 2
	int		au_id;
	unsigned long	au_v;
d366 11
a376 11
	AUX_phdr = 3,		/* &phdr[0] */
	AUX_phent = 4,		/* sizeof(phdr[0]) */
	AUX_phnum = 5,		/* # phdr entries */
	AUX_pagesz = 6,		/* PAGESIZE */
	AUX_base = 7,		/* ld.so base addr */
	AUX_flags = 8,		/* processor flags */
	AUX_entry = 9,		/* a.out entry */
	AUX_sun_uid = 2000,	/* euid */
	AUX_sun_ruid = 2001,	/* ruid */
	AUX_sun_gid = 2002,	/* egid */
	AUX_sun_rgid = 2003	/* rgid */
a378 8
#define	ELF_HDR_SIZE	(sizeof(Elf32_Ehdr))


#ifdef _KERNEL

#define ELF32_NO_ADDR	((u_long) ~0)	/* Indicates addr. not yet filled in */
#define ELF_AUX_ENTRIES	8		/* Size of aux array passed to loader */

d380 5
a384 5
        u_long  arg_entry;      /* progran entry point */
        u_long  arg_interp;     /* Interpreter load address */
        u_long  arg_phaddr;     /* program header address */
        u_long  arg_phentsize;  /* Size of program header */
        u_long  arg_phnum;      /* Number of program headers */
d393 31
d426 1
a426 1
#endif /* !_SYS_EXEC_ELF_H_ */
@


1.2
log
@from netbsd:
Don't rely on the protection bits of segments anymore to decide whether
it's text or data; use the entry point instead (this solves some trouble
with ELF executables with strange permissions)
Incorporate some fixes from r_friedl@@informatik.uni-kl.de sent to
netbsd-bugs a while ago
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: exec_elf.h,v 1.1 1995/06/22 21:31:03 fvdl Exp $	*/
d144 2
a145 1
#define ELF32_NO_ADDR	((u_long) ~0)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
