head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.6
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.2
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.6.0.4
	OPENBSD_5_6_BASE:1.6
	OPENBSD_5_5:1.5.0.4
	OPENBSD_5_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.11
date	2016.06.07.07.53.33;	author mpi;	state Exp;
branches;
next	1.10;
commitid	P20voeFmD7sc85LW;

1.10
date	2015.12.08.11.55.47;	author dlg;	state Exp;
branches;
next	1.9;
commitid	ULVUyveANgp5GOYq;

1.9
date	2015.12.08.11.40.37;	author dlg;	state Exp;
branches;
next	1.8;
commitid	GJZcm6ZWmJcDJTJ3;

1.8
date	2015.02.09.03.15.41;	author dlg;	state Exp;
branches;
next	1.7;
commitid	jVd0KngVszV2FEfg;

1.7
date	2015.01.27.03.17.37;	author dlg;	state Exp;
branches;
next	1.6;
commitid	MyKPm9Q3dQu92BiX;

1.6
date	2014.06.11.08.47.53;	author blambert;	state Exp;
branches;
next	1.5;
commitid	wAEViZUWYkamiCIp;

1.5
date	2013.12.23.04.20.47;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.10.31.04.33.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2013.10.30.02.11.32;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2013.10.29.04.32.08;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2013.10.29.04.23.16;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Move initialization macro outside of #define _KERNEL to use them in
ART regression tests.

ok dlg@@, jmatthew@@
@
text
@/*	$OpenBSD: task.h,v 1.10 2015/12/08 11:55:47 dlg Exp $ */

/*
 * Copyright (c) 2013 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SYS_TASK_H_
#define _SYS_TASK_H_

#include <sys/queue.h>

struct taskq;

struct task {
	TAILQ_ENTRY(task) t_entry;
	void		(*t_func)(void *);
	void		*t_arg;
	unsigned int	t_flags;
};

TAILQ_HEAD(task_list, task);

#define TASKQ_MPSAFE		(1 << 0)
#define TASKQ_CANTSLEEP		(1 << 1)

#define TASK_INITIALIZER(_f, _a)  {{ NULL, NULL }, (_f), (_a), 0 }

#ifdef _KERNEL
extern struct taskq *const systq;
extern struct taskq *const systqmp;

struct taskq	*taskq_create(const char *, unsigned int, int, unsigned int);
void		 taskq_destroy(struct taskq *);

void		 task_set(struct task *, void (*)(void *), void *);
int		 task_add(struct taskq *, struct task *);
int		 task_del(struct taskq *, struct task *);

#endif /* _KERNEL */

#endif /* _SYS_TASK_H_ */
@


1.10
log
@_SYS_TASKQ_H_ -> _SYS_TASK_H_
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.9 2015/12/08 11:40:37 dlg Exp $ */
d38 2
a49 3

#define TASK_INITIALIZER(_f, _a) \
	{ { NULL, NULL }, (_f), (_a), 0 }
@


1.9
log
@+TAILQ_HEAD(task_list, task);
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.8 2015/02/09 03:15:41 dlg Exp $ */
d19 2
a20 2
#ifndef _SYS_TASKQ_H_
#define _SYS_TASKQ_H_
d54 1
a54 1
#endif /* _SYS_TASKQ_H_ */
@


1.8
log
@we want to defer work traditionally (in openbsd) handled in an
interrupt context to a taskq running in a thread. however, there
is a concern that if we do that then we allow accidental use of
sleeping APIs in this work, which will make it harder to move the
work back to interrupts in the future.

guenther and kettenis came up with the idea of marking a proc with
CANTSLEEP which the sleep paths can check and panic on.

this builds on that so you create taskqs that run with CANTSLEEP
set except when they need to sleep for more tasks to run.

the taskq_create api is changed to take a flags argument so users
can specify CANTSLEEP. MPSAFE is also passed via this flags field
now.  this means archs that defined IPL_MPSAFE to 0 can now create
mpsafe taskqs too.

lots of discussion at s2k15
ok guenther@@ miod@@ mpi@@ tedu@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.7 2015/01/27 03:17:37 dlg Exp $ */
d32 2
@


1.7
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.6 2014/06/11 08:47:53 blambert Exp $ */
d33 3
d40 1
a40 1
struct taskq	*taskq_create(const char *, unsigned int, int);
@


1.6
log
@Create system taskq ("systqmp") which runs without the kernel lock;
currently unused.

ok dlg@@
manpage improvement and ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.5 2013/12/23 04:20:47 dlg Exp $ */
d28 2
a29 3
	void		(*t_func)(void *, void *);
	void		*t_arg1;
	void		*t_arg2;
d40 1
a40 2
void		 task_set(struct task *, void (*)(void *, void *),
		     void *, void *);
d44 2
a45 2
#define TASK_INITIALIZER(_f, _a1, _a2) \
	{ { NULL, NULL }, (_f), (_a1), (_a2), 0 }
@


1.5
log
@provide a TASK_INITIALIZER() macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.4 2013/10/31 04:33:32 deraadt Exp $ */
d36 1
@


1.4
log
@hide kernel protytypes
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.3 2013/10/30 02:11:32 dlg Exp $ */
d44 4
@


1.3
log
@deprecate taskq_systq() and replace it with extern struct taskq
*const systq defined in task.h

this reduces the cost of using the system taskq and looks less ugly.

requested by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.2 2013/10/29 04:32:08 dlg Exp $ */
d34 1
d44 1
@


1.2
log
@use unsigned int instead of u_int to reduce the depend on types.h.

might make jsg a little happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: task.h,v 1.1 2013/10/29 04:23:16 dlg Exp $ */
d34 2
a35 1
struct taskq	*taskq_systq(void);
@


1.1
log
@introduce tasks and taskqs as an alternative to workqs.

tasks are modelled on the timeout api, so users familiar with
timeout_set, timeout_add, and timeout_del will already know what
to expect from task_set, task_add, and task_del.

i wrote this because workq_add_task can fail in the place you
actually need it, and there arent any good ways of recovering at
that point.  workq_queue_task was added to try and help, but required
external state to be stored for users of that api to know whether
something was already queued or not.

workqs also didnt provide a way to cancel or remove work.

this has been percolating with a bunch of people. putting it in as i
wrote it so i can apply their feedback to the code with the history kept
in cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d31 1
a31 1
	u_int		t_flags;
d35 1
a35 1
struct taskq	*taskq_create(const char *, u_int, int);
@

