head	1.28;
access;
symbols
	OPENBSD_6_1:1.28.0.8
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.8
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.4
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.26.0.2
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.19.0.4
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.19.0.2
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.18.0.2
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.6
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.8.0.6
	UBC_BASE:1.8
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.7.0.16
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.14
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.12
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.10
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.8
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2015.05.05.02.13.46;	author guenther;	state Exp;
branches;
next	1.27;
commitid	dNPv28CJI5BxtRGW;

1.27
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2012.12.02.07.03.32;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2011.11.22.23.20.19;	author joshe;	state Exp;
branches;
next	1.23;

1.23
date	2011.11.09.20.57.38;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.19;

1.19
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.27.19.47.45;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.06.18.42.37;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.17.22.33.34;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.29.03.20.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.13.21.49.28;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.06.17.24.12;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.04.02.21.43.12;	author niklas;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	97.08.31.20.42.01;	author deraadt;	state Exp;
branches
	1.7.12.1;
next	1.6;

1.6
date	97.02.01.21.49.36;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.01.27.22.48.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.01.27.01.15.30;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.13.14.58;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches;
next	;

1.7.12.1
date	2001.05.14.22.45.03;	author niklas;	state Exp;
branches;
next	1.7.12.2;

1.7.12.2
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.7.12.3;

1.7.12.3
date	2003.05.15.04.08.03;	author niklas;	state Exp;
branches;
next	1.7.12.4;

1.7.12.4
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.7.12.5;

1.7.12.5
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.8.6.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.28
log
@emul_native is only used for kernel threads which can't dump core, so
delete coredump_trad(), uvm_coredump(), cpu_coredump(), struct md_coredump,
and various #includes that are superfluous.

This leaves compat_linux processes without a coredump callback.  If that
ability is desired, someone should update it to use coredump_elf32() and
verify the results...

ok kettenis@@
@
text
@/*	$OpenBSD: signalvar.h,v 1.27 2014/03/22 06:05:45 guenther Exp $	*/
/*	$NetBSD: signalvar.h,v 1.17 1996/04/22 01:23:31 christos Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)signalvar.h	8.3 (Berkeley) 1/4/94
 */

#ifndef	_SYS_SIGNALVAR_H_		/* tmp for user.h */
#define	_SYS_SIGNALVAR_H_

/*
 * Kernel signal definitions and data structures,
 * not exported to user programs.
 */

/*
 * Process signal actions and state, needed only within the process
 * (not necessarily resident).
 */
struct	sigacts {
	sig_t	ps_sigact[NSIG];	/* disposition of signals */
	sigset_t ps_catchmask[NSIG];	/* signals to be blocked */
	sigset_t ps_sigonstack;		/* signals to take on sigstack */
	sigset_t ps_sigintr;		/* signals that interrupt syscalls */
	sigset_t ps_sigreset;		/* signals that reset when caught */
	sigset_t ps_siginfo;		/* signals that provide siginfo */
	sigset_t ps_sigignore;		/* signals being ignored */
	sigset_t ps_sigcatch;		/* signals being caught by user */
	int	ps_flags;		/* signal flags, below */
	int	ps_refcnt;		/* reference count */
};

/* signal flags */
#define	SAS_NOCLDSTOP	0x01	/* No SIGCHLD when children stop. */
#define	SAS_NOCLDWAIT	0x02	/* No zombies if child dies */

/* additional signal action values, used only temporarily/internally */
#define	SIG_CATCH	(void (*)(int))2
#define	SIG_HOLD	(void (*)(int))3

/*
 * Determine signal that should be delivered to process p, the current
 * process, 0 if none.  If there is a pending stop signal with default
 * action, the process stops in issignal().
 */
#define	CURSIG(p)							\
	(((p)->p_siglist == 0 ||					\
	    (((p)->p_p->ps_flags & PS_TRACED) == 0 &&			\
	    ((p)->p_siglist & ~(p)->p_sigmask) == 0)) ?			\
	    0 : issignal(p))

/*
 * Clear a pending signal from a process.
 */
#define	CLRSIG(p, sig)	atomic_clearbits_int(&(p)->p_siglist, sigmask(sig))

/*
 * Signal properties and actions.
 * The array below categorizes the signals and their default actions
 * according to the following properties:
 */
#define	SA_KILL		0x01		/* terminates process by default */
#define	SA_CORE		0x02		/* ditto and coredumps */
#define	SA_STOP		0x04		/* suspend process */
#define	SA_TTYSTOP	0x08		/* ditto, from tty */
#define	SA_IGNORE	0x10		/* ignore by default */
#define	SA_CONT		0x20		/* continue if suspended */
#define	SA_CANTMASK	0x40		/* non-maskable, catchable */

#ifdef	SIGPROP
int sigprop[NSIG + 1] = {
	0,			/* unused */
	SA_KILL,		/* SIGHUP */
	SA_KILL,		/* SIGINT */
	SA_KILL|SA_CORE,	/* SIGQUIT */
	SA_KILL|SA_CORE,	/* SIGILL */
	SA_KILL|SA_CORE,	/* SIGTRAP */
	SA_KILL|SA_CORE,	/* SIGABRT */
	SA_KILL|SA_CORE,	/* SIGEMT */
	SA_KILL|SA_CORE,	/* SIGFPE */
	SA_KILL,		/* SIGKILL */
	SA_KILL|SA_CORE,	/* SIGBUS */
	SA_KILL|SA_CORE,	/* SIGSEGV */
	SA_KILL|SA_CORE,	/* SIGSYS */
	SA_KILL,		/* SIGPIPE */
	SA_KILL,		/* SIGALRM */
	SA_KILL,		/* SIGTERM */
	SA_IGNORE,		/* SIGURG */
	SA_STOP,		/* SIGSTOP */
	SA_STOP|SA_TTYSTOP,	/* SIGTSTP */
	SA_IGNORE|SA_CONT,	/* SIGCONT */
	SA_IGNORE,		/* SIGCHLD */
	SA_STOP|SA_TTYSTOP,	/* SIGTTIN */
	SA_STOP|SA_TTYSTOP,	/* SIGTTOU */
	SA_IGNORE,		/* SIGIO */
	SA_KILL,		/* SIGXCPU */
	SA_KILL,		/* SIGXFSZ */
	SA_KILL,		/* SIGVTALRM */
	SA_KILL,		/* SIGPROF */
	SA_IGNORE,		/* SIGWINCH  */
	SA_IGNORE,		/* SIGINFO */
	SA_KILL,		/* SIGUSR1 */
	SA_KILL,		/* SIGUSR2 */
	SA_IGNORE,		/* SIGTHR */
};

#define	contsigmask	(sigmask(SIGCONT))
#define	stopsigmask	(sigmask(SIGSTOP) | sigmask(SIGTSTP) | \
			    sigmask(SIGTTIN) | sigmask(SIGTTOU))

#endif /* SIGPROP */

#define	sigcantmask	(sigmask(SIGKILL) | sigmask(SIGSTOP))

#ifdef _KERNEL
enum signal_type { SPROCESS, STHREAD, SPROPAGATED };

/*
 * Machine-independent functions:
 */
int	coredump(struct proc *p);
void	execsigs(struct proc *p);
void	gsignal(int pgid, int sig);
void	csignal(pid_t pgid, int signum, uid_t uid, uid_t euid);
int	issignal(struct proc *p);
void	pgsignal(struct pgrp *pgrp, int sig, int checkctty);
void	postsig(int sig);
void	psignal(struct proc *p, int sig);
void	ptsignal(struct proc *p, int sig, enum signal_type type);
#define prsignal(pr,sig)	ptsignal((pr)->ps_mainproc, (sig), SPROCESS)
void	siginit(struct process *);
void	trapsignal(struct proc *p, int sig, u_long code, int type,
	    union sigval val);
void	sigexit(struct proc *, int);
int	sigonstack(size_t);
void	setsigvec(struct proc *, int, struct sigaction *);
int	killpg1(struct proc *, int, int, int);

void	signal_init(void);

struct sigacts *sigactsinit(struct process *);
struct sigacts *sigactsshare(struct process *);
void	sigstkinit(struct sigaltstack *);
void	sigactsunshare(struct process *);
void	sigactsfree(struct process *);

/*
 * Machine-dependent functions:
 */
void	sendsig(sig_t action, int sig, int returnmask, u_long code,
	    int type, union sigval val);
#endif	/* _KERNEL */
#endif	/* !_SYS_SIGNALVAR_H_ */
@


1.27
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.26 2012/12/02 07:03:32 guenther Exp $	*/
a178 5
struct core;
struct vnode;
struct ucred;
int	cpu_coredump(struct proc *, struct vnode *, struct ucred *,
			  struct core *);
@


1.26
log
@Determine whether we're currently on the alternative signal stack
dynamically, by comparing the stack pointer against the altstack
base and size, so that you get the correct answer if you longjmp
out of the signal handler, as tested by regress/sys/kern/stackjmp/.
Also, fix alt stack handling on vax, where it was completely broken.

Testing and corrections by miod@@, krw@@, tobiasu@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.25 2012/02/20 22:23:39 guenther Exp $	*/
a68 5
 * get signal action for process and signal; currently only for current process
 */
#define SIGACTION(p, sig)	(p->p_sigacts->ps_sigact[(sig)])

/*
d158 1
a158 1
void	siginit(struct proc *p);
d168 2
a169 2
struct sigacts *sigactsinit(struct proc *);
struct sigacts *sigactsshare(struct proc *);
d171 2
a172 2
void	sigactsunshare(struct proc *);
void	sigactsfree(struct proc *);
@


1.25
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.24 2011/11/22 23:20:19 joshe Exp $	*/
d167 1
@


1.24
log
@Move struct proc's sigaltstack struct from the zeroed area into the
copied area, and initialize it properly in the FORK_THREAD case.

This restores the behavior of a forked process inheriting its parent's
signal stack.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.23 2011/11/09 20:57:38 guenther Exp $	*/
d80 1
a80 1
	    (((p)->p_flag & P_TRACED) == 0 &&				\
@


1.23
log
@Change fork1() and kthread_create() to match the rest of the tree
and use curp vs p instead of p1 vs p2.  Add curpr and pr variables
for the respective struct processes.  Make sigactsshare() return
the shared sigacts intead of taking the struct proc to update.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.22 2011/07/05 04:48:02 guenther Exp $	*/
d174 1
@


1.22
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.21 2011/04/18 21:44:56 guenther Exp $	*/
d173 1
a173 1
void	sigactsshare(struct proc *, struct proc *);
@


1.21
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.19 2010/07/26 01:56:27 guenther Exp $	*/
d54 2
a55 1
	sigset_t ps_oldmask;		/* saved mask from before sigpause */
a56 6
	struct	sigaltstack ps_sigstk;	/* sp & on stack state variable */
	int	ps_sig;			/* for core dump/debugger XXX */
	long	ps_code;		/* for core dump/debugger XXX */
	int	ps_type;		/* for core dump/debugger XXX */
	union sigval ps_sigval;		/* for core dump/debugger XXX */
	sigset_t ps_usertramp;		/* SunOS compat; libc sigtramp XXX */
d61 2
a62 2
#define	SAS_OLDMASK	0x01		/* need to restore mask before pause */
#define	SAS_ALTSTACK	0x02		/* have alternate signal stack */
@


1.20
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d54 1
a54 2
	sigset_t ps_sigignore;		/* signals being ignored */
	sigset_t ps_sigcatch;		/* signals being caught by user */
d56 6
d66 2
a67 2
#define	SAS_NOCLDSTOP	0x01	/* No SIGCHLD when children stop. */
#define	SAS_NOCLDWAIT	0x02	/* No zombies if child dies */
@


1.19
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.18 2009/11/27 19:47:45 guenther Exp $	*/
d54 2
a55 1
	sigset_t ps_oldmask;		/* saved mask from before sigpause */
a56 6
	struct	sigaltstack ps_sigstk;	/* sp & on stack state variable */
	int	ps_sig;			/* for core dump/debugger XXX */
	long	ps_code;		/* for core dump/debugger XXX */
	int	ps_type;		/* for core dump/debugger XXX */
	union sigval ps_sigval;		/* for core dump/debugger XXX */
	sigset_t ps_usertramp;		/* SunOS compat; libc sigtramp XXX */
d61 2
a62 2
#define	SAS_OLDMASK	0x01		/* need to restore mask before pause */
#define	SAS_ALTSTACK	0x02		/* have alternate signal stack */
@


1.18
log
@Add a signal for librthread to use for interthread ASTs for cancelation
and suspension.

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.17 2008/12/16 07:57:28 guenther Exp $	*/
d167 1
@


1.17
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.16 2007/02/06 18:42:37 art Exp $	*/
d141 1
@


1.16
log
@Use atomic.h operation for manipulating p_siglist in struct proc. Solves
the problem with lost signals in MP kernels.

miod@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.15 2005/06/17 22:33:34 niklas Exp $	*/
d152 2
d165 1
@


1.15
log
@A second approach at fixing the telnet localhost & problem
(but I tend to call it ssh localhost & now when telnetd is
history).  This is more localized patch, but leaves us with
a recursive lock for protecting scheduling and signal state.
Better care is taken to actually be symmetric over mi_switch.
Also, the dolock cruft in psignal can go with this solution.
Better test runs by more people for longer time has been
carried out compared to the c2k5 patch.

Long term the current mess with interruptible sleep, the
default action on stop signals and wakeup interactions need
to be revisited.  ok deraadt@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.14 2005/05/29 03:20:43 deraadt Exp $	*/
d92 1
a92 1
#define	CLRSIG(p, sig)	{ (p)->p_siglist &= ~sigmask(sig); }
@


1.14
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.12 2004/06/13 21:49:28 niklas Exp $	*/
d162 1
a162 3
void	psignal1(struct proc *p, int sig, int dolock);
#define	psignal(p, sig)		psignal1((p), (sig), 1)
#define	sched_psignal(p, sig)	psignal1((p), (sig), 0)
@


1.13
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d162 3
a164 1
void	psignal(struct proc *p, int sig);
@


1.12
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d162 1
a162 3
void	psignal1(struct proc *p, int sig, int dolock);
#define	psignal(p, sig)		psignal1((p), (sig), 1)
#define	sched_psignal(p, sig)	psignal1((p), (sig), 0)
@


1.11
log
@fix siginfo generation for posted signals and avoid double ktrpsig() call for the same signal; deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.10 2003/06/02 23:28:21 millert Exp $	*/
d162 3
a164 1
void	psignal(struct proc *p, int sig);
@


1.10
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.9 2002/03/14 01:27:14 millert Exp $	*/
d59 2
@


1.9
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.8 2001/04/02 21:43:12 niklas Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.8
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.7 1997/08/31 20:42:01 deraadt Exp $	*/
d72 2
a73 2
#define	SIG_CATCH	(void (*) __P((int)))2
#define	SIG_HOLD	(void (*) __P((int)))3
d157 21
a177 21
int	coredump __P((struct proc *p));
void	execsigs __P((struct proc *p));
void	gsignal __P((int pgid, int sig));
void	csignal __P((pid_t pgid, int signum, uid_t uid, uid_t euid));
int	issignal __P((struct proc *p));
void	pgsignal __P((struct pgrp *pgrp, int sig, int checkctty));
void	postsig __P((int sig));
void	psignal __P((struct proc *p, int sig));
void	siginit __P((struct proc *p));
void	trapsignal __P((struct proc *p, int sig, u_long code, int type,
	    union sigval val));
void	sigexit __P((struct proc *, int));
void	setsigvec __P((struct proc *, int, struct sigaction *));
int	killpg1 __P((struct proc *, int, int, int));

void	signal_init __P((void));

struct sigacts *sigactsinit __P((struct proc *));
void	sigactsshare __P((struct proc *, struct proc *));
void	sigactsunshare __P((struct proc *));
void	sigactsfree __P((struct proc *));
d182 2
a183 2
void	sendsig __P((sig_t action, int sig, int returnmask, u_long code,
	    int type, union sigval val));
d187 2
a188 2
int	cpu_coredump __P((struct proc *, struct vnode *, struct ucred *,
			  struct core *));
@


1.8.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.8 2001/04/02 21:43:12 niklas Exp $	*/
d72 2
a73 2
#define	SIG_CATCH	(void (*)(int))2
#define	SIG_HOLD	(void (*)(int))3
d157 21
a177 21
int	coredump(struct proc *p);
void	execsigs(struct proc *p);
void	gsignal(int pgid, int sig);
void	csignal(pid_t pgid, int signum, uid_t uid, uid_t euid);
int	issignal(struct proc *p);
void	pgsignal(struct pgrp *pgrp, int sig, int checkctty);
void	postsig(int sig);
void	psignal(struct proc *p, int sig);
void	siginit(struct proc *p);
void	trapsignal(struct proc *p, int sig, u_long code, int type,
	    union sigval val);
void	sigexit(struct proc *, int);
void	setsigvec(struct proc *, int, struct sigaction *);
int	killpg1(struct proc *, int, int, int);

void	signal_init(void);

struct sigacts *sigactsinit(struct proc *);
void	sigactsshare(struct proc *, struct proc *);
void	sigactsunshare(struct proc *);
void	sigactsfree(struct proc *);
d182 2
a183 2
void	sendsig(sig_t action, int sig, int returnmask, u_long code,
	    int type, union sigval val);
d187 2
a188 2
int	cpu_coredump(struct proc *, struct vnode *, struct ucred *,
			  struct core *);
@


1.7
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.6 1997/02/01 21:49:36 deraadt Exp $	*/
d64 1
d171 7
@


1.7.12.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.8 2001/04/02 21:43:12 niklas Exp $	*/
a63 1
	int	ps_refcnt;		/* reference count */
a169 7

void	signal_init __P((void));

struct sigacts *sigactsinit __P((struct proc *));
void	sigactsshare __P((struct proc *, struct proc *));
void	sigactsunshare __P((struct proc *));
void	sigactsfree __P((struct proc *));
@


1.7.12.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d72 2
a73 2
#define	SIG_CATCH	(void (*)(int))2
#define	SIG_HOLD	(void (*)(int))3
d157 21
a177 21
int	coredump(struct proc *p);
void	execsigs(struct proc *p);
void	gsignal(int pgid, int sig);
void	csignal(pid_t pgid, int signum, uid_t uid, uid_t euid);
int	issignal(struct proc *p);
void	pgsignal(struct pgrp *pgrp, int sig, int checkctty);
void	postsig(int sig);
void	psignal(struct proc *p, int sig);
void	siginit(struct proc *p);
void	trapsignal(struct proc *p, int sig, u_long code, int type,
	    union sigval val);
void	sigexit(struct proc *, int);
void	setsigvec(struct proc *, int, struct sigaction *);
int	killpg1(struct proc *, int, int, int);

void	signal_init(void);

struct sigacts *sigactsinit(struct proc *);
void	sigactsshare(struct proc *, struct proc *);
void	sigactsunshare(struct proc *);
void	sigactsfree(struct proc *);
d182 2
a183 2
void	sendsig(sig_t action, int sig, int returnmask, u_long code,
	    int type, union sigval val);
d187 2
a188 2
int	cpu_coredump(struct proc *, struct vnode *, struct ucred *,
			  struct core *);
@


1.7.12.3
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.7.12.2 2002/03/28 14:52:02 niklas Exp $	*/
d164 1
a164 3
void	psignal1(struct proc *p, int sig, int dolock);
#define	psignal(p, sig)		psignal1((p), (sig), 1)
#define	sched_psignal(p, sig)	psignal1((p), (sig), 0)
@


1.7.12.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.7.12.3 2003/05/15 04:08:03 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.12.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 2
	int	ps_type;		/* for core dump/debugger XXX */
	union sigval ps_sigval;		/* for core dump/debugger XXX */
@


1.6
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.5 1997/01/27 22:48:42 deraadt Exp $	*/
d159 1
@


1.5
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.4 1997/01/27 01:15:30 deraadt Exp $	*/
d164 2
a165 1
void	trapsignal __P((struct proc *p, int sig, u_long code, caddr_t addr));
d174 1
a174 1
	caddr_t addr));
@


1.4
log
@initial cut at SA_SIGINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.3 1996/05/02 13:14:58 deraadt Exp $	*/
d164 1
a164 1
void	trapsignal __P((struct proc *p, int sig, u_long code));
d172 2
a173 1
void	sendsig __P((sig_t action, int sig, int returnmask, u_long code));
@


1.3
log
@proto more stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: signalvar.h,v 1.2 1996/03/03 12:12:19 niklas Exp $	*/
d57 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: signalvar.h,v 1.16 1996/02/09 18:25:34 christos Exp $	*/
d172 5
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: signalvar.h,v 1.14 1995/08/13 22:48:47 mycroft Exp $	*/
d70 2
a71 2
#define	SIG_CATCH	(void (*)())2
#define	SIG_HOLD	(void (*)())3
d85 2
a86 2
	    ((p)->p_flag & P_TRACED) == 0 &&				\
	    ((p)->p_siglist & ~(p)->p_sigmask) == 0) ?			\
d164 3
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
