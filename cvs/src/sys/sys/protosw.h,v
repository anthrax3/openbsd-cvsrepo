head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.2
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.18.0.14
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.10
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.12
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.4
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.8
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.8
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.6
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.4
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.18
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.16
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.14
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.12
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.10
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.4
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.23;
commitid	ZsxSSZJSFxZH81LL;

1.23
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.22;
commitid	LtQeAWkATeJFPv2t;

1.22
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.21;
commitid	UBL7uwpXqTP4EWIu;

1.21
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	3e3CkrbYekyVOcxy;

1.20
date	2017.01.26.13.03.47;	author bluhm;	state Exp;
branches;
next	1.19;
commitid	wBlwxPiTlfo8m7xr;

1.19
date	2017.01.25.17.34.31;	author bluhm;	state Exp;
branches;
next	1.18;
commitid	pVtptbHA3yk4jSpN;

1.18
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.04.16.02.07;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2011.04.04.12.44.10;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.14;

1.14
date	2010.10.18.04.31.01;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.13.20.54.05;	author claudio;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.25.17.57.13;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.12.18.45.14;	author mk;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.26.19.56.51;	author dugsong;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.05.25.22.08.22;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.25.09.41.02;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.31.54;	author deraadt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	96.03.03.12.12.08;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2001.05.14.22.45.03;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2001.07.04.11.00.28;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: protosw.h,v 1.23 2017/03/03 15:48:02 bluhm Exp $	*/
/*	$NetBSD: protosw.h,v 1.10 1996/04/09 20:55:32 cgd Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)protosw.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Protocol switch table.
 *
 * Each protocol has a handle initializing one of these structures,
 * which is used for protocol-protocol and system-protocol communication.
 *
 * A protocol is called through the pr_init entry before any other.
 * Thereafter it is called every 200ms through the pr_fasttimo entry and
 * every 500ms through the pr_slowtimo for timer based actions.
 * The system will call the pr_drain entry if it is low on space and
 * this should throw away any non-critical data.
 *
 * Protocols pass data between themselves as chains of mbufs using
 * the pr_input and pr_output hooks.  Pr_input passes data up (towards
 * UNIX) and pr_output passes it down (towards the imps); control
 * information passes up and down on pr_ctlinput and pr_ctloutput.
 * The protocol is responsible for the space occupied by any the
 * arguments to these entries and must dispose it.
 *
 * The userreq routine interfaces protocols to the system and is
 * described below.
 */

struct mbuf;
struct sockaddr;
struct socket;
struct domain;
struct proc;

struct protosw {
	short	pr_type;		/* socket type used for */
	struct	domain *pr_domain;	/* domain protocol a member of */
	short	pr_protocol;		/* protocol number */
	short	pr_flags;		/* see below */

/* protocol-protocol hooks */
					/* input to protocol (from below) */
	int	(*pr_input)(struct mbuf **, int *, int);
					/* output to protocol (from above) */
	int	(*pr_output)(struct mbuf *, struct socket *, struct sockaddr *,
		    struct mbuf *);
					/* control input (from below) */
	void	(*pr_ctlinput)(int, struct sockaddr *, u_int, void *);
					/* control output (from above) */
	int	(*pr_ctloutput)(int, struct socket *, int, int, struct mbuf *);

/* user-protocol hook */
					/* user request: see list below */
	int	(*pr_usrreq)(struct socket *, int, struct mbuf *,
		    struct mbuf *, struct mbuf *, struct proc *);

	int	(*pr_attach)(struct socket *, int);

/* utility hooks */
	void	(*pr_init)(void);	/* initialization hook */
	void	(*pr_fasttimo)(void);	/* fast timeout (200ms) */
	void	(*pr_slowtimo)(void);	/* slow timeout (500ms) */
	void	(*pr_drain)(void);	/* flush any excess space possible */
					/* sysctl for protocol */
	int	(*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t);
};

#define	PR_SLOWHZ	2		/* 2 slow timeouts per second */
#define	PR_FASTHZ	5		/* 5 fast timeouts per second */

/*
 * Values for pr_flags.
 * PR_ADDR requires PR_ATOMIC;
 * PR_ADDR and PR_CONNREQUIRED are mutually exclusive.
 */
#define	PR_ATOMIC	0x01		/* exchange atomic messages only */
#define	PR_ADDR		0x02		/* addresses given with messages */
#define	PR_CONNREQUIRED	0x04		/* connection required by protocol */
#define	PR_WANTRCVD	0x08		/* want PRU_RCVD calls */
#define	PR_RIGHTS	0x10		/* passes capabilities */
#define	PR_ABRTACPTDIS	0x20		/* abort on accept(2) to disconnected
					   socket */
#define	PR_SPLICE	0x40		/* socket splicing is possible */

/*
 * The arguments to usrreq are:
 *	(*protosw[].pr_usrreq)(up, req, m, nam, opt);
 * where up is a (struct socket *), req is one of these requests,
 * m is a optional mbuf chain containing a message,
 * nam is an optional mbuf chain containing an address,
 * and opt is a pointer to a socketopt structure or nil.
 * The protocol is responsible for disposal of the mbuf chain m,
 * the caller is responsible for any space held by nam and opt.
 * A non-zero return from usrreq gives an
 * UNIX error number which should be passed to higher level software.
 */
#define	PRU_DETACH		1	/* detach protocol from up */
#define	PRU_BIND		2	/* bind socket to address */
#define	PRU_LISTEN		3	/* listen for connection */
#define	PRU_CONNECT		4	/* establish connection to peer */
#define	PRU_ACCEPT		5	/* accept connection from peer */
#define	PRU_DISCONNECT		6	/* disconnect from peer */
#define	PRU_SHUTDOWN		7	/* won't send any more data */
#define	PRU_RCVD		8	/* have taken data; more room now */
#define	PRU_SEND		9	/* send this data */
#define	PRU_ABORT		10	/* abort (fast DISCONNECT, DETACH) */
#define	PRU_CONTROL		11	/* control operations on protocol */
#define	PRU_SENSE		12	/* return status into m */
#define	PRU_RCVOOB		13	/* retrieve out of band data */
#define	PRU_SENDOOB		14	/* send out of band data */
#define	PRU_SOCKADDR		15	/* fetch socket's address */
#define	PRU_PEERADDR		16	/* fetch peer's address */
#define	PRU_CONNECT2		17	/* connect two sockets */
/* begin for protocols internal use */
#define	PRU_FASTTIMO		18	/* 200ms timeout */
#define	PRU_SLOWTIMO		19	/* 500ms timeout */
#define	PRU_PROTORCV		20	/* receive from below */
#define	PRU_PROTOSEND		21	/* send to below */

#define	PRU_NREQ		22

#ifdef PRUREQUESTS
char *prurequests[] = {
	"",		"DETACH",	"BIND",		"LISTEN",
	"CONNECT",	"ACCEPT",	"DISCONNECT",	"SHUTDOWN",
	"RCVD",		"SEND",		"ABORT",	"CONTROL",
	"SENSE",	"RCVOOB",	"SENDOOB",	"SOCKADDR",
	"PEERADDR",	"CONNECT2",	"FASTTIMO",	"SLOWTIMO",
	"PROTORCV",	"PROTOSEND",
};
#endif

/*
 * The arguments to the ctlinput routine are
 *	(*protosw[].pr_ctlinput)(cmd, sa, arg);
 * where cmd is one of the commands below, sa is a pointer to a sockaddr,
 * and arg is an optional caddr_t argument used within a protocol family.
 */
#define	PRC_IFDOWN		0	/* interface transition */
#define	PRC_ROUTEDEAD		1	/* select new route if possible ??? */
#define	PRC_MTUINC		2	/* increase in mtu to host */
#define	PRC_QUENCH2		3	/* DEC congestion bit says slow down */
#define	PRC_QUENCH		4	/* some one said to slow down */
#define	PRC_MSGSIZE		5	/* message size forced drop */
#define	PRC_HOSTDEAD		6	/* host appears to be down */
#define	PRC_HOSTUNREACH		7	/* deprecated (use PRC_UNREACH_HOST) */
#define	PRC_UNREACH_NET		8	/* no route to network */
#define	PRC_UNREACH_HOST	9	/* no route to host */
#define	PRC_UNREACH_PROTOCOL	10	/* dst says bad protocol */
#define	PRC_UNREACH_PORT	11	/* bad port # */
/* was	PRC_UNREACH_NEEDFRAG	12	   (use PRC_MSGSIZE) */
#define	PRC_UNREACH_SRCFAIL	13	/* source route failed */
#define	PRC_REDIRECT_NET	14	/* net routing redirect */
#define	PRC_REDIRECT_HOST	15	/* host routing redirect */
#define	PRC_REDIRECT_TOSNET	16	/* redirect for type of service & net */
#define	PRC_REDIRECT_TOSHOST	17	/* redirect for tos & host */
#define	PRC_TIMXCEED_INTRANS	18	/* packet lifetime expired in transit */
#define	PRC_TIMXCEED_REASS	19	/* lifetime expired on reass q */
#define	PRC_PARAMPROB		20	/* header incorrect */

#define	PRC_NCMDS		21

#define	PRC_IS_REDIRECT(cmd)	\
	((cmd) >= PRC_REDIRECT_NET && (cmd) <= PRC_REDIRECT_TOSHOST)

#ifdef PRCREQUESTS
char	*prcrequests[] = {
	"IFDOWN", "ROUTEDEAD", "MTUINC", "DEC-BIT-QUENCH2",
	"QUENCH", "MSGSIZE", "HOSTDEAD", "#7",
	"NET-UNREACH", "HOST-UNREACH", "PROTO-UNREACH", "PORT-UNREACH",
	"#12", "SRCFAIL-UNREACH", "NET-REDIRECT", "HOST-REDIRECT",
	"TOSNET-REDIRECT", "TOSHOST-REDIRECT", "TX-INTRANS", "TX-REASS",
	"PARAMPROB"
};
#endif

/*
 * The arguments to ctloutput are:
 *	(*protosw[].pr_ctloutput)(req, so, level, optname, optval);
 * req is one of the actions listed below, so is a (struct socket *),
 * level is an indication of which protocol layer the option is intended.
 * optname is a protocol dependent socket option request,
 * optval is a pointer to a mbuf-chain pointer, for value-return results.
 * The protocol is responsible for disposal of the mbuf chain *optval
 * if supplied,
 * the caller is responsible for any space held by *optval, when returned.
 * A non-zero return from usrreq gives an
 * UNIX error number which should be passed to higher level software.
 */
#define	PRCO_GETOPT	0
#define	PRCO_SETOPT	1

#define	PRCO_NCMDS	2

#ifdef PRCOREQUESTS
char	*prcorequests[] = {
	"GETOPT", "SETOPT",
};
#endif

#ifdef _KERNEL
struct sockaddr;
struct protosw *pffindproto(int, int, int);
struct protosw *pffindtype(int, int);
void pfctlinput(int, struct sockaddr *);

extern u_char ip_protox[];
extern struct protosw inetsw[];
#endif
@


1.23
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.22 2017/02/01 20:59:47 dhill Exp $	*/
d86 2
a125 1
#define	PRU_ATTACH		0	/* attach protocol to up */
d153 1
a153 1
	"ATTACH",	"DETACH",	"BIND",		"LISTEN",
@


1.22
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.21 2017/01/29 19:58:47 bluhm Exp $	*/
d74 2
a75 1
	int	(*pr_output)(struct mbuf *, ...);
@


1.21
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.20 2017/01/26 13:03:47 bluhm Exp $	*/
d78 1
a78 1
	int	(*pr_ctloutput)(int, struct socket *, int, int, struct mbuf **);
@


1.20
log
@Reduce the difference between struct protosw and ip6protosw.  The
IPv4 pr_ctlinput functions did return a void pointer that was always
NULL and never used.  Make all functions void like in the IPv6 case.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.19 2017/01/25 17:34:31 bluhm Exp $	*/
d72 1
a72 1
	void	(*pr_input)(struct mbuf *, int, int);
@


1.19
log
@Since raw_input() and route_input() are gone from pr_input, we can
make the variable parameters of the protocol input functions fixed.
Also add the proto to make it similar to IPv6.
OK mpi@@ guenther@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.18 2013/04/24 10:17:08 mpi Exp $	*/
d76 1
a76 1
	void	*(*pr_ctlinput)(int, struct sockaddr *, u_int, void *);
@


1.18
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.17 2011/07/04 16:02:07 guenther Exp $	*/
d72 1
a72 1
	void	(*pr_input)(struct mbuf *, ...);
@


1.17
log
@Nuke a dangling bit left over from the now gone PRU_PEEREID

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.16 2011/04/04 12:44:10 deraadt Exp $	*/
d233 3
@


1.16
log
@COMPAT_O47 (kernel getpeereid, which was replaced by libc getpeereid)
can go away
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.15 2011/01/07 17:50:42 bluhm Exp $	*/
d156 1
a156 1
	"PROTORCV",	"PROTOSEND",	"PEEREID",
@


1.15
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.14 2010/10/18 04:31:01 guenther Exp $	*/
a145 3
#ifdef COMPAT_O47
#define PRU_PEEREID		22	/* get local peer eid */
#endif /* COMPAT_O47 */
@


1.14
log
@PRU_PEEREID is only used by code under COMPAT_O47, so put it there too
so that we remember to remove it all at the same time in two years.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.13 2009/11/13 20:54:05 claudio Exp $	*/
d109 1
@


1.13
log
@Extend the protosw pr_ctlinput function to include the rdomain. This is
needed so that the route and inp lookups done in TCP and UDP know where
to look. Additionally in_pcbnotifyall() and tcp_respond() got a rdomain
argument as well for similar reasons. With this tcp seems to be now
fully rdomain save and no longer leaks single packets into the main domain.
Looks good markus@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.12 2008/05/25 17:57:13 deraadt Exp $	*/
d145 1
d147 1
@


1.12
log
@need to declare struct proct before using a pointer to it; ok kettenis thib
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.11 2008/05/23 15:51:12 thib Exp $	*/
d76 1
a76 1
	void	*(*pr_ctlinput)(int, struct sockaddr *, void *);
@


1.11
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.10 2007/09/12 18:45:14 mk Exp $	*/
d62 1
@


1.10
log
@There is no such word as `detatch'.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.9 2003/06/02 23:28:21 millert Exp $	*/
d82 1
a82 1
		    struct mbuf *, struct mbuf *);
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.8 2002/03/15 01:20:04 millert Exp $	*/
d131 1
a131 1
#define	PRU_ABORT		10	/* abort (fast DISCONNECT, DETATCH) */
@


1.8
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.7 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.6 2001/06/26 19:56:51 dugsong Exp $	*/
d74 8
a81 4
	void	(*pr_input)		/* input to protocol (from below) */(struct mbuf *, ...);
	int	(*pr_output)		/* output to protocol (from above) */(struct mbuf *, ...);
	void	*(*pr_ctlinput)		/* control input (from below) */(int, struct sockaddr *, void *);
	int	(*pr_ctloutput)		/* control output (from above) */(int, struct socket *, int, int, struct mbuf **);
d84 3
a86 2
	int	(*pr_usrreq)		/* user request: see list below */(struct socket *, int, struct mbuf *,
			     struct mbuf *, struct mbuf *);
d89 6
a94 6
	void	(*pr_init)		/* initialization hook */(void);

	void	(*pr_fasttimo)		/* fast timeout (200ms) */(void);
	void	(*pr_slowtimo)		/* slow timeout (500ms) */(void);
	void	(*pr_drain)		/* flush any excess space possible */(void);
	int	(*pr_sysctl)		/* sysctl for protocol */(int *, u_int, void *, size_t *, void *, size_t);
@


1.6
log
@implement djb's getpeereid(2), to allow local-domain servers to determine client credentials. mostly from superscript.com. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.5 2001/05/25 22:08:22 itojun Exp $	*/
d74 4
a77 8
	void	(*pr_input)		/* input to protocol (from below) */
			__P((struct mbuf *, ...));
	int	(*pr_output)		/* output to protocol (from above) */
			__P((struct mbuf *, ...));
	void	*(*pr_ctlinput)		/* control input (from below) */
			__P((int, struct sockaddr *, void *));
	int	(*pr_ctloutput)		/* control output (from above) */
			__P((int, struct socket *, int, int, struct mbuf **));
d80 2
a81 3
	int	(*pr_usrreq)		/* user request: see list below */
			__P((struct socket *, int, struct mbuf *,
			     struct mbuf *, struct mbuf *));
d84 1
a84 2
	void	(*pr_init)		/* initialization hook */
			__P((void));
d86 4
a89 8
	void	(*pr_fasttimo)		/* fast timeout (200ms) */
			__P((void));
	void	(*pr_slowtimo)		/* slow timeout (500ms) */
			__P((void));
	void	(*pr_drain)		/* flush any excess space possible */
			__P((void));
	int	(*pr_sysctl)		/* sysctl for protocol */
			__P((int *, u_int, void *, size_t *, void *, size_t));
d228 3
a230 3
struct protosw *pffindproto __P((int, int, int));
struct protosw *pffindtype __P((int, int));
void pfctlinput __P((int, struct sockaddr *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.6 2001/06/26 19:56:51 dugsong Exp $	*/
d74 8
a81 8
					/* input to protocol (from below) */
	void	(*pr_input)(struct mbuf *, ...);
					/* output to protocol (from above) */
	int	(*pr_output)(struct mbuf *, ...);
					/* control input (from below) */
	void	*(*pr_ctlinput)(int, struct sockaddr *, void *);
					/* control output (from above) */
	int	(*pr_ctloutput)(int, struct socket *, int, int, struct mbuf **);
d84 3
a86 3
					/* user request: see list below */
	int	(*pr_usrreq)(struct socket *, int, struct mbuf *,
		    struct mbuf *, struct mbuf *);
d89 11
a99 6
	void	(*pr_init)(void);	/* initialization hook */
	void	(*pr_fasttimo)(void);	/* fast timeout (200ms) */
	void	(*pr_slowtimo)(void);	/* slow timeout (500ms) */
	void	(*pr_drain)(void);	/* flush any excess space possible */
					/* sysctl for protocol */
	int	(*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t);
d238 3
a240 3
struct protosw *pffindproto(int, int, int);
struct protosw *pffindtype(int, int);
void pfctlinput(int, struct sockaddr *);
@


1.5
log
@recover old acecept(2) behavior (no ECONNABORTED) for unix domain socket.
it is to be friendly with postfix daemon-to-daemon communication
(not 100% sure if which behavior is correct, specwise).  patch similar to netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.4 2000/09/25 09:41:02 provos Exp $	*/
d153 1
d155 1
a155 1
#define	PRU_NREQ		21
d164 1
a164 1
	"PROTORCV",	"PROTOSEND",
@


1.4
log
@on expiry of pmtu route, retry higher mtu. okay angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.3 1996/04/21 22:31:54 deraadt Exp $	*/
d115 2
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.2 1996/03/03 12:12:08 niklas Exp $	*/
d173 1
d200 1
a200 1
	"IFDOWN", "ROUTEDEAD", "#2", "DEC-BIT-QUENCH2",
@


1.3.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.4 2000/09/25 09:41:02 provos Exp $	*/
a172 1
#define	PRC_MTUINC		2	/* increase in mtu to host */
d199 1
a199 1
	"IFDOWN", "ROUTEDEAD", "MTUINC", "DEC-BIT-QUENCH2",
@


1.3.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.3.16.1 2001/05/14 22:45:03 niklas Exp $	*/
a114 2
#define	PR_ABRTACPTDIS	0x20		/* abort on accept(2) to disconnected
					   socket */
a150 1
#define PRU_PEEREID		22	/* get local peer eid */
d152 1
a152 1
#define	PRU_NREQ		22
d161 1
a161 1
	"PROTORCV",	"PROTOSEND",	"PEEREID",
@


1.3.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 8
a81 8
					/* input to protocol (from below) */
	void	(*pr_input)(struct mbuf *, ...);
					/* output to protocol (from above) */
	int	(*pr_output)(struct mbuf *, ...);
					/* control input (from below) */
	void	*(*pr_ctlinput)(int, struct sockaddr *, void *);
					/* control output (from above) */
	int	(*pr_ctloutput)(int, struct socket *, int, int, struct mbuf **);
d84 3
a86 3
					/* user request: see list below */
	int	(*pr_usrreq)(struct socket *, int, struct mbuf *,
		    struct mbuf *, struct mbuf *);
d89 11
a99 6
	void	(*pr_init)(void);	/* initialization hook */
	void	(*pr_fasttimo)(void);	/* fast timeout (200ms) */
	void	(*pr_slowtimo)(void);	/* slow timeout (500ms) */
	void	(*pr_drain)(void);	/* flush any excess space possible */
					/* sysctl for protocol */
	int	(*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t);
d238 3
a240 3
struct protosw *pffindproto(int, int, int);
struct protosw *pffindtype(int, int);
void pfctlinput(int, struct sockaddr *);
@


1.3.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: protosw.h,v 1.3.16.3 2002/03/28 14:52:01 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: protosw.h,v 1.9 1996/02/13 21:08:55 christos Exp $	*/
d91 1
a91 1
		    
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: protosw.h,v 1.7 1995/03/26 20:24:33 jtc Exp $	*/
d61 6
d72 1
d74 9
a82 4
	void	(*pr_input)();		/* input to protocol (from below) */
	int	(*pr_output)();		/* output to protocol (from above) */
	void	(*pr_ctlinput)();	/* control input (from below) */
	int	(*pr_ctloutput)();	/* control output (from above) */
d84 4
a87 1
	int	(*pr_usrreq)();		/* user request: see list below */
d89 11
a99 5
	void	(*pr_init)();		/* initialization hook */
	void	(*pr_fasttimo)();	/* fast timeout (200ms) */
	void	(*pr_slowtimo)();	/* slow timeout (500ms) */
	void	(*pr_drain)();		/* flush any excess space possible */
	int	(*pr_sysctl)();		/* sysctl for protocol */
d233 4
a236 1
extern	struct protosw *pffindproto(), *pffindtype();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
