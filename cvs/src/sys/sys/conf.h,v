head	1.143;
access;
symbols
	OPENBSD_6_2:1.143.0.6
	OPENBSD_6_2_BASE:1.143
	OPENBSD_6_1:1.143.0.4
	OPENBSD_6_1_BASE:1.143
	OPENBSD_6_0:1.141.0.2
	OPENBSD_6_0_BASE:1.141
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.133.0.4
	OPENBSD_5_8_BASE:1.133
	OPENBSD_5_7:1.131.0.2
	OPENBSD_5_7_BASE:1.131
	OPENBSD_5_6:1.127.0.4
	OPENBSD_5_6_BASE:1.127
	OPENBSD_5_5:1.126.0.4
	OPENBSD_5_5_BASE:1.126
	OPENBSD_5_4:1.124.0.2
	OPENBSD_5_4_BASE:1.124
	OPENBSD_5_3:1.119.0.2
	OPENBSD_5_3_BASE:1.119
	OPENBSD_5_2:1.118.0.4
	OPENBSD_5_2_BASE:1.118
	OPENBSD_5_1_BASE:1.118
	OPENBSD_5_1:1.118.0.2
	OPENBSD_5_0:1.115.0.2
	OPENBSD_5_0_BASE:1.115
	OPENBSD_4_9:1.110.0.2
	OPENBSD_4_9_BASE:1.110
	OPENBSD_4_8:1.106.0.2
	OPENBSD_4_8_BASE:1.106
	OPENBSD_4_7:1.95.0.2
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.94.0.4
	OPENBSD_4_6_BASE:1.94
	OPENBSD_4_5:1.93.0.2
	OPENBSD_4_5_BASE:1.93
	OPENBSD_4_4:1.90.0.2
	OPENBSD_4_4_BASE:1.90
	OPENBSD_4_3:1.85.0.2
	OPENBSD_4_3_BASE:1.85
	OPENBSD_4_2:1.83.0.2
	OPENBSD_4_2_BASE:1.83
	OPENBSD_4_1:1.81.0.2
	OPENBSD_4_1_BASE:1.81
	OPENBSD_4_0:1.80.0.2
	OPENBSD_4_0_BASE:1.80
	OPENBSD_3_9:1.78.0.2
	OPENBSD_3_9_BASE:1.78
	OPENBSD_3_8:1.76.0.2
	OPENBSD_3_8_BASE:1.76
	OPENBSD_3_7:1.75.0.4
	OPENBSD_3_7_BASE:1.75
	OPENBSD_3_6:1.75.0.2
	OPENBSD_3_6_BASE:1.75
	SMP_SYNC_A:1.75
	SMP_SYNC_B:1.75
	OPENBSD_3_5:1.73.0.2
	OPENBSD_3_5_BASE:1.73
	OPENBSD_3_4:1.71.0.2
	OPENBSD_3_4_BASE:1.71
	UBC_SYNC_A:1.68
	OPENBSD_3_3:1.67.0.2
	OPENBSD_3_3_BASE:1.67
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.52.0.2
	OPENBSD_3_1_BASE:1.52
	UBC_SYNC_B:1.66
	UBC:1.50.0.2
	UBC_BASE:1.50
	OPENBSD_3_0:1.49.0.2
	OPENBSD_3_0_BASE:1.49
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.38.0.2
	OPENBSD_2_8_BASE:1.38
	OPENBSD_2_7:1.36.0.2
	OPENBSD_2_7_BASE:1.36
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.34
	OPENBSD_2_6:1.30.0.2
	OPENBSD_2_6_BASE:1.30
	OPENBSD_2_5:1.29.0.2
	OPENBSD_2_5_BASE:1.29
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.4
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.21.0.2
	OPENBSD_2_1_BASE:1.21
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.143
date	2016.09.04.10.51.24;	author naddy;	state Exp;
branches;
next	1.142;
commitid	4OWaAfwqMvhOCLOI;

1.142
date	2016.09.02.17.06.13;	author goda;	state Exp;
branches;
next	1.141;
commitid	J1JzeTsS8K8zyH3c;

1.141
date	2016.04.26.07.08.20;	author deraadt;	state Exp;
branches;
next	1.140;
commitid	aVHdFaiBeEEKlIbW;

1.140
date	2016.04.14.08.27.24;	author natano;	state Exp;
branches;
next	1.139;
commitid	rDUjVAJoqYcTKda5;

1.139
date	2016.02.25.16.48.50;	author uebayasi;	state Exp;
branches;
next	1.138;
commitid	wMzA3EHuermOfTPw;

1.138
date	2016.02.05.06.29.01;	author uebayasi;	state Exp;
branches;
next	1.137;
commitid	3lmLbhQAi8VhAKnD;

1.137
date	2016.01.27.09.04.19;	author reyk;	state Exp;
branches;
next	1.136;
commitid	xjeRSSQ0SXSd3nFz;

1.136
date	2016.01.06.09.09.16;	author kettenis;	state Exp;
branches;
next	1.135;
commitid	nVj87EkrOwcIg67T;

1.135
date	2015.10.23.15.10.52;	author claudio;	state Exp;
branches;
next	1.134;
commitid	g17gxjQh9N9egLbB;

1.134
date	2015.09.10.18.14.52;	author mpi;	state Exp;
branches;
next	1.133;
commitid	yCNTJc2qmad1KZnd;

1.133
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.132;
commitid	EA6IpjJSgQH2WTCf;

1.132
date	2015.05.17.16.55.51;	author deraadt;	state Exp;
branches;
next	1.131;
commitid	mekaSYsX8vVb6Uuj;

1.131
date	2014.12.11.19.44.16;	author tedu;	state Exp;
branches;
next	1.130;
commitid	jUSAZlQ30WF1ESM9;

1.130
date	2014.10.09.04.10.36;	author tedu;	state Exp;
branches;
next	1.129;
commitid	CiKfyRjCo2vMXPDB;

1.129
date	2014.10.09.04.04.27;	author tedu;	state Exp;
branches;
next	1.128;
commitid	29cCQl7KlarTmoPD;

1.128
date	2014.08.20.06.23.03;	author mikeb;	state Exp;
branches;
next	1.127;
commitid	3nalvU8sn6rZiZ1d;

1.127
date	2014.03.14.23.42.41;	author kettenis;	state Exp;
branches;
next	1.126;

1.126
date	2013.11.04.14.07.15;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2013.08.20.14.27.32;	author ajacoutot;	state Exp;
branches;
next	1.124;

1.124
date	2013.06.21.21.30.38;	author syl;	state Exp;
branches;
next	1.123;

1.123
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2013.06.03.15.54.48;	author tedu;	state Exp;
branches;
next	1.121;

1.121
date	2013.04.19.15.02.41;	author florian;	state Exp;
branches;
next	1.120;

1.120
date	2013.03.15.11.35.58;	author ratchov;	state Exp;
branches;
next	1.119;

1.119
date	2012.08.23.06.12.49;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2011.10.06.20.49.28;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2011.10.06.09.14.35;	author mikeb;	state Exp;
branches;
next	1.116;

1.116
date	2011.09.17.08.36.06;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2011.07.06.14.49.30;	author nicm;	state Exp;
branches;
next	1.114;

1.114
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.113;

1.113
date	2011.07.04.16.52.41;	author nicm;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.03.18.11.52;	author nicm;	state Exp;
branches;
next	1.111;

1.111
date	2011.06.27.04.57.36;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.109;

1.109
date	2011.01.08.19.45.09;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.12.31.22.32.19;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.09.22.13.03.48;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.28.21.44.41;	author nicm;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.21.23.40.26;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.21.18.48.01;	author nicm;	state Exp;
branches;
next	1.103;

1.103
date	2010.07.21.18.43.59;	author deraadt;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.18.21.01.06;	author oga;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.15.04.46.33;	author mglocker;	state Exp;
branches;
next	1.100;

1.100
date	2010.07.14.21.24.33;	author jakemsr;	state Exp;
branches;
next	1.99;

1.99
date	2010.07.08.20.15.01;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2010.07.03.03.59.17;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.08.12.46.49;	author jsing;	state Exp;
branches;
next	1.96;

1.96
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.95;

1.95
date	2009.11.01.20.14.12;	author nicm;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.03.14.45.55;	author jj;	state Exp;
branches;
next	1.93;

1.93
date	2009.01.25.17.30.49;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2008.12.03.23.39.32;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2008.11.17.00.40.04;	author oga;	state Exp;
branches;
next	1.90;

1.90
date	2008.06.14.21.31.46;	author mbalmer;	state Exp;
branches;
next	1.89;

1.89
date	2008.06.03.17.21.22;	author oga;	state Exp;
branches;
next	1.88;

1.88
date	2008.05.24.19.37.34;	author mglocker;	state Exp;
branches;
next	1.87;

1.87
date	2008.04.09.19.49.55;	author robert;	state Exp;
branches;
next	1.86;

1.86
date	2008.04.08.14.31.54;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2007.11.28.23.37.34;	author oga;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.25.17.11.12;	author oga;	state Exp;
branches;
next	1.83;

1.83
date	2007.07.23.13.30.21;	author mk;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.06.17.15.14;	author deraadt;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.06.22.39.13;	author dlg;	state Exp;
branches;
next	1.80;

1.80
date	2006.07.12.19.56.18;	author thib;	state Exp;
branches;
next	1.79;

1.79
date	2006.06.02.20.25.09;	author pedro;	state Exp;
branches;
next	1.78;

1.78
date	2005.12.31.21.22.35;	author miod;	state Exp;
branches;
next	1.77;

1.77
date	2005.12.27.18.31.12;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2005.07.31.06.39.07;	author dlg;	state Exp;
branches;
next	1.75;

1.75
date	2004.06.03.18.08.00;	author grange;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.30.08.11.27;	author grange;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.10.01.31.21;	author millert;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.14.23.14.30;	author mickey;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2003.05.14.00.20.38;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2002.11.08.19.00.37;	author mickey;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.10.22.21.30;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2002.07.10.22.08.47;	author mickey;	state Exp;
branches;
next	1.64;

1.64
date	2002.07.10.21.53.26;	author mickey;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.29.02.58.14;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.24.19.00.33;	author mickey;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.19.03.03.28;	author mickey;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.19.02.58.32;	author mickey;	state Exp;
branches;
next	1.59;

1.59
date	2002.06.16.02.35.00;	author mickey;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.16.01.36.22;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2002.06.11.05.15.15;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2002.06.09.22.03.44;	author niklas;	state Exp;
branches;
next	1.55;

1.55
date	2002.06.06.21.34.16;	author provos;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.16.21.11.19;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2002.05.16.16.16.51;	author provos;	state Exp;
branches;
next	1.52;

1.52
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2002.01.23.04.48.02;	author ericj;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.01.12.13.47;	author art;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2001.10.04.21.46.03;	author gluk;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.28.02.53.13;	author mickey;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.06.22.34.44;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.06.20.50.22;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.01.21.18.41;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.05.02.35.34;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.26.03.04.30;	author provos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.24.19.48.59;	author kjell;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.23.03.30.37;	author matthieu;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.13.15.39.26;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.01.20.54.35;	author provos;	state Exp;
branches;
next	1.38;

1.38
date	2000.09.26.14.03.51;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2000.07.03.19.22.37;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.04.09.21.07.46;	author matthieu;	state Exp;
branches;
next	1.35;

1.35
date	2000.02.21.08.14.13;	author mjacob;	state Exp;
branches;
next	1.34;

1.34
date	99.11.22.23.54.55;	author deraadt;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	99.11.22.17.51.25;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	99.11.22.17.50.29;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	99.11.20.11.11.27;	author matthieu;	state Exp;
branches;
next	1.30;

1.30
date	99.08.13.05.38.05;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	99.01.11.14.28.56;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	99.01.02.00.02.56;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	98.08.30.17.11.33;	author art;	state Exp;
branches;
next	1.26;

1.26
date	98.08.24.05.26.49;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.04.26.21.03.18;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	98.04.01.20.14.16;	author matthieu;	state Exp;
branches;
next	1.23;

1.23
date	97.11.23.05.17.58;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.11.23.05.14.14;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.05.14.01.17.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.12.03.05.16.36;	author kstailey;	state Exp;
branches;
next	1.19;

1.19
date	96.12.03.05.09.04;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	96.11.11.18.47.27;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	96.11.06.01.29.03;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.10.19.13.25.59;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	96.10.18.12.30.06;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	96.10.04.17.58.41;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.08.29.09.26.42;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.07.15.10.11.12;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.07.15.07.49.38;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.06.10.19.52.48;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.05.06.11.31.09;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.04.18.51.02;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.31.34;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.21.40.47;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.31.13.16.40;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.29.12.05.56;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.12.11.27;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.21.12.53.54;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.34.2.1
date	2000.02.21.22.29.15;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2001.07.04.11.00.14;	author niklas;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.34.2.9;

1.34.2.9
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.34.2.10;

1.34.2.10
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.34.2.11;

1.34.2.11
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	1.34.2.12;

1.34.2.12
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.50.2.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	1.50.2.2;

1.50.2.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.50.2.3;

1.50.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.50.2.4;

1.50.2.4
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.143
log
@Remove support for tape block devices. Nobody mount(8)s tapes any longer.
ok deraadt@@ guenther@@
@
text
@/*	$OpenBSD: conf.h,v 1.142 2016/09/02 17:06:13 goda Exp $	*/
/*	$NetBSD: conf.h,v 1.33 1996/05/03 20:03:32 christos Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)conf.h	8.3 (Berkeley) 1/21/94
 */


#ifndef _SYS_CONF_H_
#define _SYS_CONF_H_

/*
 * Definitions of device driver entry switches
 */

struct buf;
struct proc;
struct tty;
struct uio;
struct vnode;
struct knote;

/*
 * Types for d_type
 */
#define	D_DISK	1
#define	D_TTY	2

/*
 * Flags for d_flags
 */
#define D_CLONE		0x0001		/* clone upon open */

#ifdef _KERNEL

#define	dev_type_open(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_close(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_strategy(n)	void n(struct buf *)
#define	dev_type_ioctl(n) \
	int n(dev_t, u_long, caddr_t, int, struct proc *)

#define	dev_decl(n,t)	__CONCAT(dev_type_,t)(__CONCAT(n,t))
#define	dev_init(c,n,t) \
	((c) > 0 ? __CONCAT(n,t) : (__CONCAT(dev_type_,t)((*))) enxio)

#endif /* _KERNEL */

/*
 * Block device switch table
 */
struct bdevsw {
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *p);
	void	(*d_strategy)(struct buf *bp);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_dump)(dev_t dev, daddr_t blkno, caddr_t va,
				    size_t size);
	daddr_t (*d_psize)(dev_t dev);
	u_int	d_type;
	/* u_int	d_flags; */
};

#ifdef _KERNEL

extern struct bdevsw bdevsw[];

/* bdevsw-specific types */
#define	dev_type_dump(n)	int n(dev_t, daddr_t, caddr_t, size_t)
#define	dev_type_size(n)	daddr_t n(dev_t)

/* bdevsw-specific initializations */
#define	dev_size_init(c,n)	(c > 0 ? __CONCAT(n,size) : 0)

#define	bdev_decl(n) \
	dev_decl(n,open); dev_decl(n,close); dev_decl(n,strategy); \
	dev_decl(n,ioctl); dev_decl(n,dump); dev_decl(n,size)

#define	bdev_disk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
	dev_init(c,n,dump), dev_size_init(c,n), D_DISK }

#define	bdev_swap_init(c,n) { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	dev_init(c,n,strategy), (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

#define	bdev_notdef() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

#endif

/*
 * Character device switch table
 */
struct cdevsw {
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *);
	int	(*d_read)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_write)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_stop)(struct tty *tp, int rw);
	struct tty *
		(*d_tty)(dev_t dev);
	int	(*d_poll)(dev_t dev, int events, struct proc *p);
	paddr_t	(*d_mmap)(dev_t, off_t, int);
	u_int	d_type;
	u_int	d_flags;
	int	(*d_kqfilter)(dev_t dev, struct knote *kn);
};

#ifdef _KERNEL

extern struct cdevsw cdevsw[];

/* cdevsw-specific types */
#define	dev_type_read(n)	int n(dev_t, struct uio *, int)
#define	dev_type_write(n)	int n(dev_t, struct uio *, int)
#define	dev_type_stop(n)	int n(struct tty *, int)
#define	dev_type_tty(n)		struct tty *n(dev_t)
#define	dev_type_poll(n)	int n(dev_t, int, struct proc *)
#define	dev_type_mmap(n)	paddr_t n(dev_t, off_t, int)
#define dev_type_kqfilter(n)	int n(dev_t, struct knote *)

#define	cdev_decl(n) \
	dev_decl(n,open); dev_decl(n,close); dev_decl(n,read); \
	dev_decl(n,write); dev_decl(n,ioctl); dev_decl(n,stop); \
	dev_decl(n,tty); dev_decl(n,poll); dev_decl(n,mmap); \
	dev_decl(n,kqfilter)

/* open, close, read, write, ioctl */
#define	cdev_disk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, \
	D_DISK, 0, seltrue_kqfilter }

/* open, close, read, write, ioctl */
#define	cdev_tape_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, \
	0, 0, seltrue_kqfilter }

/* open, close, read, write, ioctl, stop, tty */
#define	cdev_tty_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	dev_init(c,n,tty), ttpoll, (dev_type_mmap((*))) enodev, \
	D_TTY, 0, ttkqfilter }

/* open, close, read, ioctl, poll, kqfilter */
#define	cdev_mouse_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev , 0, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, poll, nokqfilter */
#define	cdev_mousewr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev }

#define	cdev_notdef() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
#define	cdev_cn_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	D_TTY, 0, dev_init(c,n,kqfilter) }

/* open, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
#define cdev_ctty_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) nullop, dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	D_TTY, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, mmap */
#define cdev_mm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap), \
	0, 0, seltrue_kqfilter }

/* open, close, read, write, ioctl, tty, poll, kqfilter */
#define cdev_ptc_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
	dev_init(c,n,tty), dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	D_TTY, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, mmap */
#define cdev_ptm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, (dev_type_mmap((*))) enodev }

/* open, close, read, ioctl, poll, kqfilter XXX should be a generic device */
#define cdev_log_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }

/* open */
#define cdev_fd_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, selfalse, (dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
#define cdev_tun_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	0, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
#define cdev_switch_init(c,n) {						\
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read),	\
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev,		\
	0, 0, dev_init(c,n,kqfilter) }

/* open, close, ioctl, poll, kqfilter -- XXX should be generic device */
#define cdev_vscsi_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	0, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
#define cdev_pppx_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	0, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, poll, kqfilter, cloning -- XXX should be generic device */
#define cdev_bpf_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	0, D_CLONE, dev_init(c,n,kqfilter) }

/* open, close, ioctl */
#define	cdev_ch_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define       cdev_uk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl, mmap */
#define	cdev_fb_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	dev_init(c,n,mmap) }

/* open, close, read, write, ioctl, poll, kqfilter */
#define cdev_audio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, poll, kqfilter */
#define cdev_midi_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }

/* open, close, read */
#define cdev_ksyms_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, seltrue, \
	(dev_type_mmap((*))) enodev, 0, 0, seltrue_kqfilter }

/* open, close, read, write, ioctl, stop, tty, poll, mmap, kqfilter */
#define	cdev_wsdisplay_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	dev_init(c,n,tty), dev_init(c,n,poll), dev_init(c,n,mmap), \
	D_TTY, 0, dev_init(c,n,kqfilter) }

/* open, close, read, write, ioctl, poll, kqfilter */
#define	cdev_random_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, \
	0, 0, dev_init(c,n,kqfilter) }

/* open, close, ioctl, poll, nokqfilter */
#define	cdev_usb_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, write */
#define cdev_ulpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, selfalse, (dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define cdev_pf_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, poll, kqfilter */
#define	cdev_usbdev_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, 0, 0, \
	dev_init(c,n,kqfilter) }

/* open, close, init */
#define cdev_pci_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define cdev_radio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl, read, mmap, poll */
#define cdev_video_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	dev_init(c,n,mmap) }

/* open, close, write, ioctl */
#define cdev_spkr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, \
	0, 0, seltrue_kqfilter }

/* open, close, write */
#define cdev_lpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, seltrue, (dev_type_mmap((*))) enodev, \
	0, 0, seltrue_kqfilter }

/* open, close, read, ioctl, mmap */
#define cdev_bktr_init(c, n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap), \
	0, 0, seltrue_kqfilter }

/* open, close, read, ioctl, poll, kqfilter */
#define cdev_hotplug_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }

/* open, close, ioctl */
#define cdev_gpio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define       cdev_bio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, ioctl, poll, mmap, nokqfilter */
#define      cdev_drm_init(c,n)        { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c, n, read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0,  dev_init(c,n,poll), \
	dev_init(c,n,mmap), 0, D_CLONE }

/* open, close, ioctl */
#define cdev_amdmsr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, poll, ioctl */
#define cdev_fuse_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev, 0, D_CLONE, dev_init(c,n,kqfilter) }

#define cdev_pvbus_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	(dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, \
	 dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, poll, ioctl, nokqfilter */
#define cdev_ipmi_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
	(dev_type_mmap((*))) enodev, 0 }

#endif

/*
 * Line discipline switch table
 */
struct linesw {
	int	(*l_open)(dev_t dev, struct tty *tp, struct proc *p);
	int	(*l_close)(struct tty *tp, int flags, struct proc *p);
	int	(*l_read)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_write)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_ioctl)(struct tty *tp, u_long cmd, caddr_t data,
				     int flag, struct proc *p);
	int	(*l_rint)(int c, struct tty *tp);
	int	(*l_start)(struct tty *tp);
	int	(*l_modem)(struct tty *tp, int flag);
};

#ifdef _KERNEL
extern struct linesw linesw[];
#endif

/*
 * Swap device table
 */
struct swdevt {
	dev_t	sw_dev;
	int	sw_flags;
};
#define	SW_FREED	0x01
#define	SW_SEQUENTIAL	0x02
#define	sw_freed	sw_flags	/* XXX compat */

#ifdef _KERNEL
extern struct swdevt swdevt[];
extern int chrtoblktbl[];
extern int nchrtoblktbl;

struct bdevsw *bdevsw_lookup(dev_t);
struct cdevsw *cdevsw_lookup(dev_t);
dev_t	chrtoblk(dev_t);
dev_t	blktochr(dev_t);
int	iskmemdev(dev_t);
int	iszerodev(dev_t);
dev_t	getnulldev(void);

cdev_decl(filedesc);

cdev_decl(log);

#define	ptstty		ptytty
#define	ptsioctl	ptyioctl
cdev_decl(pts);

#define	ptctty		ptytty
#define	ptcioctl	ptyioctl
cdev_decl(ptc);

cdev_decl(ptm);

cdev_decl(ctty);

cdev_decl(audio);
cdev_decl(drm);
cdev_decl(midi);
cdev_decl(radio);
cdev_decl(video);
cdev_decl(cn);

bdev_decl(sw);

bdev_decl(vnd);
cdev_decl(vnd);

cdev_decl(ch);

bdev_decl(sd);
cdev_decl(sd);

cdev_decl(ses);

cdev_decl(st);

bdev_decl(cd);
cdev_decl(cd);

bdev_decl(rd);
cdev_decl(rd);

bdev_decl(uk);
cdev_decl(uk);

cdev_decl(diskmap);

cdev_decl(bpf);

cdev_decl(pf);

cdev_decl(tun);
cdev_decl(tap);
cdev_decl(switch);
cdev_decl(pppx);

cdev_decl(random);

cdev_decl(wsdisplay);
cdev_decl(wskbd);
cdev_decl(wsmouse);
cdev_decl(wsmux);

cdev_decl(ksyms);

cdev_decl(bio);
cdev_decl(vscsi);

cdev_decl(gpr);
cdev_decl(bktr);

cdev_decl(usb);
cdev_decl(ugen);
cdev_decl(uhid);
cdev_decl(ucom);
cdev_decl(ulpt);
cdev_decl(urio);

cdev_decl(hotplug);
cdev_decl(gpio);
cdev_decl(amdmsr);
cdev_decl(fuse);
cdev_decl(pvbus);
cdev_decl(ipmi);

#endif

#endif /* _SYS_CONF_H_ */
@


1.142
log
@Add switch(4) cdev entry

ok deraadt@@ yasuoka@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.141 2016/04/26 07:08:20 deraadt Exp $	*/
d58 2
a59 3
#define	D_TAPE	1
#define	D_DISK	2
#define	D_TTY	3
a117 5
#define	bdev_tape_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
	dev_init(c,n,dump), 0, D_TAPE }

d183 1
a183 1
	D_TAPE, 0, seltrue_kqfilter }
a559 1
bdev_decl(st);
@


1.141
log
@more systrace goes away
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.140 2016/04/14 08:27:24 natano Exp $	*/
d273 7
d586 1
@


1.140
log
@Enable device cloning for bpf. This allows to have just one bpf device
node in /dev, that services all bpf consumers (up to 1024). Also,
disallow the usage of all but the first minor device, so accidental use
of another minor device will attract attention.

Cloning bpf offers some advantages:

- Users with high bpf usage won't have to clutter their /dev with device
  nodes.

- A lot of programs in base use a pattern like this to acces bpf:

	int fd, n = 0;
	do {
		(void)snprintf(device, sizeof device, "/dev/bpf%d", n++);
		fd = open(device, mode);
	} while (fd < 0 && errno == EBUSY);

  Those can now be replaced by a simple open(), without loop.

ok mikeb
"right time in the cycle to try" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.139 2016/02/25 16:48:50 uebayasi Exp $	*/
a238 6
/* open, close, read, write, ioctl */
#define cdev_systrace_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, selfalse, (dev_type_mmap((*))) enodev }

a588 2

cdev_decl(systrace);
@


1.139
log
@Move misplaced cdev_ipmi_init() back into within #ifdef _KERNEL.

Pointed out by natano@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.138 2016/02/05 06:29:01 uebayasi Exp $	*/
d299 1
a299 1
	0, 0, dev_init(c,n,kqfilter) }
@


1.138
log
@Implement FreeBSD-compatible IOCTL to access BMC in ipmi(4)

Initial help & testing by jmatthew@@
Code review & input by mpi@@
Final review & OK by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.137 2016/01/27 09:04:19 reyk Exp $	*/
a475 2
#endif

d482 2
@


1.137
log
@Add a key-value interface to pvbus(4) that allows to get or set values
in the underlying information store of the host from the OpenBSD-VM's
userspace.  OpenBSD did not provide access to these stores before,
mostly because we did not want to add a custom tool and interface for
each hypervisor.  The pvbus(4) interface provides backends for
xen(4)'s XenStore and vmt(4)'s VMware Tools "guestinfo".  These
information stores are fairly different, XenStore is a "filesystem"
while vmt is a RPC, and the key-value abstraction limits them a bit
but provides the most wanted functionality.

Discussed with many
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.136 2016/01/06 09:09:16 kettenis Exp $	*/
d478 7
d616 1
@


1.136
log
@Add pledge "drm", which allows a subset of the drm(4) ioctls.  These are
basically only the ioctls that Linux allows on the so-called "render nodes".
For now, it also allows DRM_IOCTL_GET_MAGIC and DRM_IOCTL_GEM_OPEN, as we
don't implement prime/dma-buf yet in OpenBSD.  That still leaves a big gaping
hole, so they will be removed as soon as we can.

Based on a diff by robert@@, who did all the heavy lifting by studying the
behaviour of the chromium GPU process, with some further suggestions by
deraadt@@.

ok jsg@@, deraadt@@, robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.135 2015/10/23 15:10:52 claudio Exp $	*/
d468 8
d608 1
@


1.135
log
@Allocate a new major for tap(4) also note that pseudo-device tun is for tap
as well. OK dlg@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.134 2015/09/10 18:14:52 mpi Exp $	*/
d532 1
@


1.134
log
@kqueue(2) support for wsmouse(4), wskbd(4) and wsmux(4).

Needed for libinput port.

ok guenther@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.133 2015/06/25 06:43:46 ratchov Exp $	*/
d568 1
@


1.133
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.132 2015/05/17 16:55:51 deraadt Exp $	*/
d198 1
a198 1
/* open, close, read, ioctl, poll, nokqfilter */
d203 1
a203 1
	(dev_type_mmap((*))) enodev }
@


1.132
log
@for decades, wsdisplay has acted in one way like it is not a tty
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.131 2014/12/11 19:44:16 tedu Exp $	*/
d327 1
a327 1
	dev_init(c,n,mmap), 0, 0, dev_init(c,n,kqfilter) }
@


1.131
log
@dragonflybsd has added a urio driver. conservation of urios requires
that we delete ours, which isn't actually useful.
ok mpi sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.130 2014/10/09 04:10:36 tedu Exp $	*/
d348 1
a348 1
	0, 0, dev_init(c,n,kqfilter) }
@


1.130
log
@no need for lkm dummy
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.129 2014/10/09 04:04:27 tedu Exp $	*/
a375 6

/* open, close, read, write, ioctl, poll, nokqfilter */
#define	cdev_urio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev }
@


1.129
log
@remove LKM support
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.128 2014/08/20 06:23:03 mikeb Exp $	*/
a128 5
#define	bdev_lkm_dummy() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

a211 6
#define	cdev_lkm_dummy() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

a299 7

/* open, close, ioctl */
#define	cdev_lkm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }
@


1.128
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.127 2014/03/14 23:42:41 kettenis Exp $	*/
d130 1
a130 1
	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
d218 1
a218 1
	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
a541 8

#ifndef LKM
# define	NLKM	0
# define	lkmenodev	enodev
#else
# define	NLKM	1
#endif
cdev_decl(lkm);
@


1.127
log
@Remove the userland AGP interface.  Now that we have KMS, it is no longer
used by any of the remaining xenocara drivers.  Except perhaps for the
legacy i810 support in the xf86-video-intel driver.  But i810 support has
almost certainly been broken for more than a year now, and any remaining
users are probably better off using the xf86-video-vesa driver ever since
XAA support was removed from the X server.

ok deraadt@@, jsg@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.126 2013/11/04 14:07:15 deraadt Exp $	*/
a249 6
/* open, close, read, write, ioctl, mmap */
#define cdev_crypto_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, selfalse, (dev_type_mmap((*))) enodev }

a609 2

cdev_decl(crypto);
@


1.126
log
@remove iop(4) driver.  it is entirely unmaintained and supports something
which basically doesn't exist at all.
reminded about it by brad
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.125 2013/08/20 14:27:32 ajacoutot Exp $	*/
a475 7

/* open, close, ioctl, mmap */
#define       cdev_agp_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	dev_init(c,n,mmap) }
@


1.125
log
@Remove uscanner(4). It was disabled in GENERIC more than 2.5 years ago.
No regression has been reported since libusb became the prefered
solution to work with USB scanners.

req. by mpi@@
ok ian@@ mpi@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.124 2013/06/21 21:30:38 syl Exp $	*/
a420 7
/* open, close, init */
#define cdev_iop_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

a476 7
/* open, close, ioctl */
#define       cdev_bthub_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, selfalse, \
	(dev_type_mmap((*))) enodev }

a586 5
bdev_decl(raid);
cdev_decl(raid);

cdev_decl(iop);

a629 1
cdev_decl(bthub);
@


1.124
log
@Make fuse device clonable.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.123 2013/06/11 16:42:17 deraadt Exp $	*/
a658 1
cdev_decl(uscanner);
@


1.123
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.122 2013/06/03 15:54:48 tedu Exp $	*/
d517 1
a517 1
	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }
@


1.122
log
@changes for isc fuse support. not enabled. ok beck deraadt.
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.121 2013/04/19 15:02:41 florian Exp $	*/
d92 1
a92 1
	int	(*d_dump)(dev_t dev, daddr64_t blkno, caddr_t va,
d94 1
a94 1
	daddr64_t (*d_psize)(dev_t dev);
d104 2
a105 2
#define	dev_type_dump(n)	int n(dev_t, daddr64_t, caddr_t, size_t)
#define	dev_type_size(n)	daddr64_t n(dev_t)
@


1.121
log
@sw_vp is now in struct nfs_diskless, remove it from struct swdevt.
This needs a change in config(8) to be commited shortly.
input/ok deraadt@@, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.120 2013/03/15 11:35:58 ratchov Exp $	*/
d512 7
d665 1
@


1.120
log
@remove forgotten sequencer function prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.119 2012/08/23 06:12:49 deraadt Exp $	*/
a540 1
	struct	vnode *sw_vp;
@


1.119
log
@kill nnpfs dead
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.118 2011/10/06 20:49:28 deraadt Exp $	*/
a585 1
cdev_decl(sequencer);
@


1.118
log
@ccd goes to the attic
discussed with jsing and millert
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.117 2011/10/06 09:14:35 mikeb Exp $	*/
a358 7

/* open, close, read, write, ioctl, poll, nokqfilter */
#define cdev_nnpfs_init(c, n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev }
@


1.117
log
@Introduce a kqfilter wrapper for the controlling tty device entry
which allows a correct registration of kqueue(2) notifications on
the /dev/tty instead of calling a function via a null pointer in
the ttkqfilter leading to a local DoS.

Surprisingly the same code is present in NetBSD since the kqueue
merge, but didn't make it to the OpenBSD for 10 years.

Thanks to Anton Yabchinskiy <arn-at-bestmx-dot-ru> for a GHCi crash
report and his willingness to test multiple diffs for over a week.

With input from nicm, ok miod, derraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.116 2011/09/17 08:36:06 miod Exp $	*/
a601 3

bdev_decl(ccd);
cdev_decl(ccd);
@


1.116
log
@Don't bother keeping a {u,}lptioctl function which is a duplicate of
enodev().
ok jsing@@ krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.115 2011/07/06 14:49:30 nicm Exp $	*/
d241 1
a241 1
	D_TTY, 0, ttkqfilter }
@


1.115
log
@Add a new kqfilter for random which returns ARC4_MAIN_MAX_BYTES for read
and POOLBYTES for write.

looks right to deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.114 2011/07/04 22:53:53 tedu Exp $	*/
d395 1
a395 1
/* open, close, write, ioctl */
d398 2
a399 2
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, selfalse, (dev_type_mmap((*))) enodev }
d456 1
a456 1
/* open, close, write, ioctl */
d459 2
a460 2
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, \
@


1.114
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.113 2011/07/04 16:52:41 nicm Exp $	*/
d386 1
a386 1
	0, 0, seltrue_kqfilter }
@


1.113
log
@Nuke the useless D_KQFILTER flag and just check that d_kqfilter is
filled in. Move D_CLONE down to 0x0001 as suggested by thib.

ok deraadt thib
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.112 2011/07/03 18:11:52 nicm Exp $	*/
a359 6
#define	cdev_svr4_net_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) nullop, \
	0, selfalse, (dev_type_mmap((*))) enodev }

a644 7

#ifdef COMPAT_SVR4
# define NSVR4_NET	1
#else
# define NSVR4_NET	0
#endif
cdev_decl(svr4_net);
@


1.112
log
@wsdisplay should use wsdisplaypoll not ttpoll.

ok miod deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.111 2011/06/27 04:57:36 matthew Exp $	*/
d65 1
a65 2
#define D_KQFILTER	0x0001		/* has kqfilter entry */
#define D_CLONE		0x0002		/* clone upon open */
d187 1
a187 1
	D_DISK, D_KQFILTER, seltrue_kqfilter }
d194 1
a194 1
	D_TAPE, D_KQFILTER, seltrue_kqfilter }
d201 1
a201 1
	D_TTY, D_KQFILTER, ttkqfilter }
d234 1
a234 1
	D_TTY, D_KQFILTER, dev_init(c,n,kqfilter) }
d241 1
a241 1
	D_TTY, D_KQFILTER, ttkqfilter }
d248 1
a248 1
	0, D_KQFILTER, seltrue_kqfilter }
d267 1
a267 1
	D_TTY, D_KQFILTER, dev_init(c,n,kqfilter) }
d280 1
a280 1
	(dev_type_mmap((*))) enodev, 0, D_KQFILTER, dev_init(c,n,kqfilter) }
d294 1
a294 1
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
d302 1
a302 1
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
d309 1
a309 1
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
d316 1
a316 1
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
d351 1
a351 1
	dev_init(c,n,mmap), 0, D_KQFILTER, dev_init(c,n,kqfilter) }
d358 1
a358 1
	(dev_type_mmap((*))) enodev, 0, D_KQFILTER, dev_init(c,n,kqfilter) }
d378 1
a378 1
	(dev_type_mmap((*))) enodev, 0, D_KQFILTER, seltrue_kqfilter }
d385 1
a385 1
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
d392 1
a392 1
	0, D_KQFILTER, seltrue_kqfilter }
d424 1
a424 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, 0, D_KQFILTER, \
d460 1
a460 1
	0, D_KQFILTER, seltrue_kqfilter }
d467 1
a467 1
	0, D_KQFILTER, seltrue_kqfilter }
d474 1
a474 1
	0, D_KQFILTER, seltrue_kqfilter }
d481 1
a481 1
	(dev_type_mmap((*))) enodev, 0, D_KQFILTER, dev_init(c,n,kqfilter) }
@


1.111
log
@Fix chrtoblk() and blktochr() prototypes to reflect that they return
dev_t, not int.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.110 2011/01/25 20:03:35 jakemsr Exp $	*/
d385 1
a385 1
	dev_init(c,n,tty), ttpoll, dev_init(c,n,mmap), \
@


1.110
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.109 2011/01/08 19:45:09 deraadt Exp $	*/
d568 2
a569 2
int	chrtoblk(dev_t);
int	blktochr(dev_t);
@


1.109
log
@split randomattach into random_init() and random_start(), so that we
can make attempts to load 'entropy' into the RC4.
ok miod ariane
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.108 2010/12/31 22:32:19 deraadt Exp $	*/
d399 1
a399 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
@


1.108
log
@all random nodes have been arc4-based for a while, so none of them ever
block. the kq and poll code should have been replaced with "selltrue"
type code a while ago.
with and ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.107 2010/09/22 13:03:48 claudio Exp $	*/
a393 1
void	randomattach(void);
@


1.107
log
@Add a new interface pppx(4) -- the ppp multiplexer to be used with npppd
and pipex. pppx(4) creates an interface whenever a session is created
so that altq and pf can work on these.
Started by dlg@@ debugged and made usable by myself
OK dlg@@ yasuoka@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.106 2010/07/28 21:44:41 nicm Exp $	*/
d392 2
a393 2
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	0, D_KQFILTER, dev_init(c,n,kqfilter) }
@


1.106
log
@Add a dummy kqueue filter similar to seltrue and use it for anything
using seltrue for poll. Based on code from NetBSD.

Also remove a stray duplicate lpt entry from loongson, from deraadt.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.105 2010/07/21 23:40:26 nicm Exp $	*/
d305 7
d645 1
@


1.105
log
@Some ss(4) bits escaped the purge, eliminate them.

ok todd krw
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.104 2010/07/21 18:48:01 nicm Exp $	*/
d187 2
a188 1
	0, seltrue, (dev_type_mmap((*))) enodev, D_DISK, 0 }
d194 2
a195 1
	0, seltrue, (dev_type_mmap((*))) enodev, D_TAPE }
d248 2
a249 1
	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap) }
d372 1
a372 1
	(dev_type_mmap((*))) enodev, 0 }
d454 2
a455 1
	0, seltrue, (dev_type_mmap((*))) enodev }
d461 2
a462 1
	0, seltrue, (dev_type_mmap((*))) enodev }
d468 2
a469 2
	(dev_type_stop((*))) enodev, 0, seltrue, \
	dev_init(c,n,mmap) }
@


1.104
log
@ptm needs no read/write, just use enodev.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.103 2010/07/21 18:43:59 deraadt Exp $	*/
a607 2

cdev_decl(ss);
@


1.103
log
@No need for read/write functions, just use enodev like all the other
things things do
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.102 2010/07/18 21:01:06 oga Exp $	*/
d269 3
a271 3
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, selfalse, (dev_type_mmap((*))) enodev }
@


1.102
log
@Support from vblank events in drm.

Previously, if userland wanted to wait on a certain vertical blank, it
had to call an ioctl which slept. Now, they can ask for an even on the
drm fd, which is then read off, and can be poll(4)ed on. For dri2 this
fits better into the workflow since the fd gets added to the xserver
main loop, and replies to the dri2 clients happen upon recieving the
events.

This functionality is only used with xserver 1.8 (and for the intel
driver in our tree, this support is currently #if 0ed out due to bugs
with vblanks on 945 that are still being chased)

matthieu@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.101 2010/07/15 04:46:33 mglocker Exp $	*/
d250 2
a251 2
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
d256 2
a257 2
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
@


1.101
log
@* Comment poll support in conf.h
* Comment why we call the video interrupt in the mmap interface now in
uvideo.c
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.100 2010/07/14 21:24:33 jakemsr Exp $	*/
d503 1
a503 1
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
d505 1
a505 1
	(dev_type_stop((*))) enodev, 0, selfalse, \
@


1.100
log
@implement poll() for video(4)
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.99 2010/07/08 20:15:01 deraadt Exp $	*/
d440 1
a440 1
/* open, close, ioctl, read, mmap */
@


1.99
log
@Devices which don't have read or write functionality should not return
enodev to poll, because this returns an errno of 19 in revents.  Oops.
Use seltrue where needed, and use a new selfalse function for those which
don't know if the next op will be non-blocking
Mostly discussed with guenther and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.98 2010/07/03 03:59:17 krw Exp $	*/
d444 1
a444 1
	(dev_type_stop((*))) enodev, 0, selfalse, \
@


1.98
log
@No more ss(4) or usscanner(4). Unused, unloved and unmaintained.
General huzzahs.

"go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.97 2010/06/08 12:46:49 jsing Exp $	*/
d252 1
a252 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d258 1
a258 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d271 1
a271 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d285 1
a285 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d313 1
a313 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d320 1
a320 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d327 1
a327 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d334 1
a334 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d355 1
a355 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d397 1
a397 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d403 1
a403 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d423 1
a423 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d430 1
a430 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d437 1
a437 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d444 1
a444 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d477 1
a477 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d484 1
a484 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d491 1
a491 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d498 1
a498 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d505 1
a505 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d512 1
a512 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
@


1.97
log
@Introduce a diskmap pseudo device which allows userland to open a disk
specified via its disklabel UID. The mapping from the disklabel UID to the
real disk and the opening of the resulting device is performed atomically
using a single ioctl.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.95 2009/11/01 20:14:12 nicm Exp $	*/
a194 7
/* open, close, read, ioctl */
#define cdev_scanner_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) nullop, \
	0, seltrue, (dev_type_mmap((*))) enodev }

a327 7
	(dev_type_mmap((*))) enodev }

/* open, close, read, ioctl */
#define cdev_ss_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, \
@


1.96
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d642 2
@


1.95
log
@kqueue support for midi(4).

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.94 2009/06/03 14:45:55 jj Exp $	*/
d535 2
a536 2
	int	(*l_open)(dev_t dev, struct tty *tp);
	int	(*l_close)(struct tty *tp, int flags);
@


1.94
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.93 2009/01/25 17:30:49 miod Exp $	*/
d358 1
a358 1
/* open, close, read, write, ioctl, poll, nokqfilter */
d363 1
a363 1
	(dev_type_mmap((*))) enodev }
@


1.93
log
@Remove /dev/drum and related code.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.92 2008/12/03 23:39:32 dlg Exp $	*/
d372 1
a372 1
#define cdev_xfs_init(c, n) { \
@


1.92
log
@add vscsi(4), a virtual scsi controller that passes all scsi requests up to
userland for handling. this is to scsi what tun(4) is for networks.

this is going into the tree so i can work on some crazy scsi stuff, but its
not being enabled since it is useless unless you're working on some crazy
scsi stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.91 2008/11/17 00:40:04 oga Exp $	*/
a266 7
/* read, write */
#define cdev_swap_init(c,n) { \
	(dev_type_open((*))) nullop, (dev_type_close((*))) nullop, \
	dev_init(c,n,read), dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
	(dev_type_mmap((*))) enodev }

a608 1
cdev_decl(sw);
@


1.91
log
@drm advertises a read and poll method. this was there to prevent errrors
on rather old xservers. Said old xservers haven't been around in quite a
long time so just remove them.

Since the only function left in drm_fops.c is a small helper function,
just move it to drm_drv.c and nuke the redundant file.

no one objected when I said I was going to do this.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.90 2008/06/14 21:31:46 mbalmer Exp $	*/
d308 8
d677 1
@


1.90
log
@Add amdmsr(4), a driver to access model specific registers on AMD CPUs.
Needed for the upcoming AMD Geode LX graphics processor X11 driver.

discussed with, feedback, and ok matthieu and deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.89 2008/06/03 17:21:22 oga Exp $	*/
d516 1
a516 1
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
d518 1
a518 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
@


1.89
log
@Make *drm(4) use D_CLONE so that the per-open data actually works. Since
i'm modifying this code anyway, prepare for privsep by making it so that
"master" openers must be root, and remove some spurious suser() checks.
For example, every DRM_ROOT_ONLY ioctl is also DRM_MASTER. Without this
change, privsep wouldn't work since the fd is no longer root owned.

With this, X privsep should work as soon as the userland bits are done
(currently unwritten).

Looked over by kettenis@@, ok thib@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.88 2008/05/24 19:37:34 mglocker Exp $	*/
d521 7
d684 1
@


1.88
log
@- Enable userland to read(2) video stream from /dev/video.
- Prepare for mmap(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.87 2008/04/09 19:49:55 robert Exp $	*/
d519 1
a519 1
	dev_init(c,n,mmap), D_TTY }
@


1.87
log
@Initial import for uvideo(4) and video(4):

uvideo(4) is a driver for USB video device class devices including webcams,
camcorders and other cameras.

video(4) is a device-independent layer that implements the V4L2 (Video for Linux Two)
API.

These drivers are *really* work in progress so don't even try to use them just yet,
because the driver still has some issues, even if it can be used to capture simple
MJPEG videos.

ok mglocker@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.86 2008/04/08 14:31:54 claudio Exp $	*/
d453 1
a453 1
/* open, close, ioctl */
d455 1
a455 1
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
d458 1
a458 1
	(dev_type_mmap((*))) enodev }
@


1.86
log
@Split the cdev makro for bpftun into two seperate definitions. tun(4) and
bpf(4) are different enough so that the split makes sense -- this is necessary
to make bpf(4) cloneable.
requested deraadt@@, OK thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.85 2007/11/28 23:37:34 oga Exp $	*/
d453 7
d597 1
@


1.85
log
@Initial import of the DRM (direct rendering manager).

This is the kernel part necessary for DRI support in X. Disabled for now
because it still has a few bugs, but now I can work on it in tree. Also
requires the requisite bits in X, which are currently under discussion
on how to deal with them with privsep. ported from a combination of the
free and netbsd implementations.

Known bugs:
1) only the first occurence of X in any session will have dri, after
that something prevents it working.
2) if the machine does not have a dri capable card, the kernel panics.
Something's up in one of the probe functions. I haven't been able to
find it though.
3) radeon cards need to be forced to use PCI mode otherwise they get
into an infinite loop.

This is known to at least kinda work with SiS, radeons in pci mode and
intel cards.

ok deraadt, kinda ok art, a few other people had a quick look.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.84 2007/11/25 17:11:12 oga Exp $	*/
d302 8
a309 1
#define cdev_bpftun_init(c,n) { \
@


1.84
log
@Make agp attach as a device. This means that many more agp bridges
actually get detected and attached. Also adds a kernel api for
manipulating agp.

Enable this on i386 and amd64.

"I think you should commit it" deraadt@@, ok matthieu. Looked over by
several others.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.83 2007/07/23 13:30:21 mk Exp $	*/
d493 1
d499 7
@


1.83
log
@Add glue for a control device for bthub(4).  Will be used to configure
device inquiry/discovery parameters, pairings, and what else might be
needed.

From discussion with gwk.  MAKEDEV goo follows later.

ok and lots of input from miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.82 2007/06/06 17:15:14 deraadt Exp $	*/
d492 6
@


1.82
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.81 2007/02/06 22:39:13 dlg Exp $	*/
d486 7
d633 1
@


1.81
log
@define the bio(4) cdev stuff in conf.h, rather than having a per machine
definition. switch amd64 and i386 to the conf.h version, and add it to
macppc.

original diff ok gwk@@ tweaks and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.80 2006/07/12 19:56:18 thib Exp $	*/
d93 1
a93 1
	int	(*d_dump)(dev_t dev, daddr_t blkno, caddr_t va,
d95 1
a95 1
	int	(*d_psize)(dev_t dev);
d105 2
a106 2
#define	dev_type_dump(n)	int n(dev_t, daddr_t, caddr_t, size_t)
#define	dev_type_size(n)	int n(dev_t)
@


1.80
log
@zap some unused variables.
the only use was in an #if notyet chunk since '97.

ok miod@@
'no objections' pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.79 2006/06/02 20:25:09 pedro Exp $	*/
d474 7
@


1.79
log
@Add a clonable devices implementation. Hacked along with thib@@, input
from krw@@ and toby@@, subliminal prodding from dlg@@, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.78 2005/12/31 21:22:35 miod Exp $	*/
a477 4

/* symbolic sleep message strings */
extern char devopn[], devio[], devwait[], devin[], devout[];
extern char devioc[], devcls[];
@


1.78
log
@Split the d_type field of cdevsw entries into d_type and d_flags for clarity.
Discussed with and ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.77 2005/12/27 18:31:12 miod Exp $	*/
d66 1
@


1.77
log
@Remove unused sw_nblks field of struct swdevt. Then, remove swapconf()
which duplicates work done by uvm_swap_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.76 2005/07/31 06:39:07 dlg Exp $	*/
d63 1
a63 1
 * Flags for d_type
d65 1
a65 1
#define D_KQFILTER	0x00010000	/* has kqfilter entry */
d95 2
a96 1
	int	d_type;
d159 1
d186 1
a186 1
	0, seltrue, (dev_type_mmap((*))) enodev, D_DISK }
d199 1
a199 1
	0, seltrue, (dev_type_mmap((*))) enodev, 0 }
d206 1
a206 1
	D_TTY | D_KQFILTER, ttkqfilter }
d239 1
a239 1
	D_TTY | D_KQFILTER, dev_init(c,n,kqfilter) }
d246 1
a246 1
	D_TTY | D_KQFILTER, ttkqfilter }
d278 1
a278 1
	D_TTY | D_KQFILTER, dev_init(c,n,kqfilter) }
d291 1
a291 1
	(dev_type_mmap((*))) enodev, D_KQFILTER, dev_init(c,n,kqfilter) }
d305 1
a305 1
	D_KQFILTER, dev_init(c,n,kqfilter) }
d347 1
a347 1
	dev_init(c,n,mmap), D_KQFILTER, dev_init(c,n,kqfilter) }
d381 1
a381 1
	D_KQFILTER, dev_init(c,n,kqfilter) }
d388 1
a388 1
	D_KQFILTER, dev_init(c,n,kqfilter) }
d421 1
a421 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, D_KQFILTER, \
d469 1
a469 1
	(dev_type_mmap((*))) enodev, D_KQFILTER, dev_init(c,n,kqfilter) }
@


1.76
log
@remove the config glue between the /dev entry for ses and its driver

sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.75 2004/06/03 18:08:00 grange Exp $	*/
a508 1
	int	sw_nblks;
@


1.75
log
@A framework for supporting various General Purpose Input/Output (GPIO)
devices. Such devices provide a set of pins that you can use to connect
for example leds to it.
The pins can be accessed either from userland through the /dev/gpio*
device files or from the kernel drivers. The latter is necessary
for implementing timing-sensitive things like i2c or 1-wire master
controller.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.74 2004/05/30 08:11:27 grange Exp $	*/
a320 7
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define       cdev_ses_init(c,n) { \
@


1.74
log
@Devices hot plugging support.
The hotplug pseudo-device passes device attachment and detachment events
to userland.  When a device attaches or detaches, the corresponding event
is queued.  The events can then be obtained from the queue through the
read(2) call on the /dev/hotplug device file. Each event consists of
event type (attach/detach), device class (DV_*) and device name (sd1 e.g.).

We have hotplug pseudo-device on alpha, amd64, i386, macppc and sparc64.
Since it was tested only on i386 other archs has it commented out
in GENERIC until tested.

The idea liked peter@@ tedu@@ drahn@@ millert@@ marco@@ henning@@.
Ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.73 2004/02/10 01:31:21 millert Exp $	*/
d476 7
d641 1
@


1.73
log
@Add the ptm device to pty(4).  By opening /dev/ptm and using the PTMGET
ioctl(2), an unprivileged process may allocate a pty and have its owner
and mode set appropriately.  This means that programs such as xterm and
screen no longer need to be setuid.  Programs using the openpty()
function require zero changes and will "just work".

Designed by beck@@ and deraadt@@; changes by beck@@ with cleanup (and
a rewrite of the vnode bits) by art@@ and tweaks/bugfixes by me.
Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.72 2003/09/23 16:51:13 millert Exp $	*/
d468 8
a475 1
				 
d632 2
@


1.72
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.71 2003/06/27 16:57:14 nate Exp $	*/
d278 7
a284 1
/* open, close, read, ioctl, poll, kqfilter -- XXX should be a generic device */
d541 2
@


1.71
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.70 2003/06/14 23:14:30 mickey Exp $	*/
d155 1
a155 1
	int	(*d_select)(dev_t dev, int which, struct proc *p);
d170 1
a170 1
#define	dev_type_select(n)	int n(dev_t, int, struct proc *)
d177 1
a177 1
	dev_decl(n,tty); dev_decl(n,select); dev_decl(n,mmap); \
d203 1
a203 1
	dev_init(c,n,tty), ttselect, (dev_type_mmap((*))) enodev, \
d206 1
a206 1
/* open, close, read, ioctl, select, nokqfilter */
d210 1
a210 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d213 1
a213 1
/* open, close, read, write, ioctl, select, nokqfilter */
d217 1
a217 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d232 1
a232 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be a tty */
d236 1
a236 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
d239 1
a239 1
/* open, read, write, ioctl, select, kqfilter -- XXX should be a tty */
d243 1
a243 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
d256 1
a256 1
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
d262 1
a262 1
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
d268 1
a268 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d271 1
a271 1
/* open, close, read, write, ioctl, tty, select, kqfilter */
d275 1
a275 1
	dev_init(c,n,tty), dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
d278 1
a278 1
/* open, close, read, ioctl, select, kqfilter -- XXX should be a generic device */
d282 1
a282 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d290 1
a290 1
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
d292 1
a292 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be generic device */
d296 1
a296 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
d303 1
a303 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d310 1
a310 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d317 1
a317 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d324 1
a324 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d338 1
a338 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d341 1
a341 1
/* open, close, read, write, ioctl, select, kqfilter */
d345 1
a345 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d348 1
a348 1
/* open, close, read, write, ioctl, select, nokqfilter */
d352 1
a352 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d359 1
a359 1
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
d361 1
a361 1
/* open, close, read, write, ioctl, select, nokqfilter */
d365 1
a365 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d375 1
a375 1
/* open, close, read, write, ioctl, stop, tty, select, mmap, kqfilter */
d379 1
a379 1
	dev_init(c,n,tty), ttselect, dev_init(c,n,mmap), \
d382 1
a382 1
/* open, close, read, write, ioctl, select, kqfilter */
d386 1
a386 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
d390 1
a390 1
/* open, close, ioctl, select, nokqfilter */
d394 1
a394 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
d401 1
a401 1
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
d407 1
a407 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d410 1
a410 1
/* open, close, read, write, ioctl, select, nokqfilter */
d414 1
a414 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
d416 1
a416 1
/* open, close, read, write, ioctl, select, kqfilter */
d420 1
a420 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_KQFILTER, \
d427 1
a427 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d434 1
a434 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
d441 1
a441 1
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
@


1.70
log
@doing kqueue on the master side of the pty returns events
for the slave size as described in the pr3209.
the regress has been created to verify for the conditions.
from wayne@@epipe.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.69 2003/06/02 23:28:21 millert Exp $	*/
d411 6
d420 2
a421 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
@


1.69
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.68 2003/05/14 00:20:38 tedu Exp $	*/
d276 1
a276 1
	D_TTY | D_KQFILTER, ttkqfilter }
@


1.68
log
@add {b,c}devsw_lookup convenience functions.
move chrtoblk and blktochr into MI code.
tested on several archs and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.67 2002/11/08 19:00:37 mickey Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.67
log
@prepare for bktr on macppc (commented out in generic for now); drahn@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.66 2002/07/10 22:21:30 mickey Exp $	*/
d502 2
d505 2
@


1.66
log
@proper cdev_decl(crypto) and no private protos
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.65 2002/07/10 22:08:47 mickey Exp $	*/
d44 4
d453 7
d601 1
d612 2
@


1.65
log
@proper cdev_decl(ksyms), fix ksyms's broken functions
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.64 2002/07/10 21:53:26 mickey Exp $	*/
d582 2
@


1.64
log
@proper cdev_decl(gpr)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.63 2002/06/29 02:58:14 mickey Exp $	*/
d580 2
@


1.63
log
@kqfilter for the log. niels said i can commit it if it works
and i converted syslog to libevent and it works now (;
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.62 2002/06/24 19:00:33 mickey Exp $	*/
d584 2
@


1.62
log
@move cdev_decl() for usb devices into one place.
usage of cdev_decl() in the driver code is more tricky since i have
kqueue mods here and there and will fix that on that way through.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.61 2002/06/19 03:03:28 mickey Exp $	*/
d278 1
a278 1
/* open, close, read, ioctl, select, nokqfilter -- XXX should be a generic device */
d283 1
a283 1
	(dev_type_mmap((*))) enodev }
@


1.61
log
@add kqfilter for random, regress is coming
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.60 2002/06/19 02:58:32 mickey Exp $	*/
d206 1
a206 1
/* open, close, read, ioctl, select */
d213 1
a213 1
/* open, close, read, write, ioctl, select */
d232 1
a232 1
/* open, close, read, write, ioctl, select -- XXX should be a tty */
d239 1
a239 1
/* open, read, write, ioctl, select -- XXX should be a tty */
d271 1
a271 1
/* open, close, read, write, ioctl, tty, select */
d278 1
a278 1
/* open, close, read, ioctl, select -- XXX should be a generic device */
d292 1
a292 1
/* open, close, read, write, ioctl, select -- XXX should be generic device */
d341 1
a341 1
/* open, close, read, write, ioctl */
d348 1
a348 1
/* open, close, read, write, ioctl, poll */
d361 1
a361 1
/* open, close, read, write, ioctl, select */
d375 1
a375 1
/* open, close, read, write, ioctl, stop, tty, select, mmap */
d382 1
a382 1
/* open, close, read, write, ioctl, select */
d390 1
a390 1
/* open, close, ioctl, select */
d410 1
d417 1
a417 1
#define       cdev_pci_init(c,n) { \
d424 1
a424 1
#define       cdev_iop_init(c,n) { \
d431 1
a431 1
#define       cdev_radio_init(c,n) { \
d584 8
@


1.60
log
@cdev_ugen_init does not need to be, it's just a usbdev, just like any other usb device
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.59 2002/06/16 02:35:00 mickey Exp $	*/
d386 2
a387 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
@


1.59
log
@defining cdev_*_init over other unrelated device's cdev_*_init is very very bad
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.58 2002/06/16 01:36:22 mickey Exp $	*/
a412 1
#define	cdev_ugen_init(c,n)	cdev_usbdev_init(c,n)
@


1.58
log
@implement kqueue for audio; tested on wiggy and niels@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.57 2002/06/11 05:15:15 miod Exp $	*/
d409 5
a413 2
#define	cdev_usbdev_init(c,n)	cdev_random_init(c,n)
#define	cdev_ugen_init(c,n)	cdev_random_init(c,n)
@


1.57
log
@Move cdev_lpt_init() to a common location.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.56 2002/06/09 22:03:44 niklas Exp $	*/
d346 1
a346 1
	dev_init(c,n,mmap) }
@


1.56
log
@bio is a driver that can delegate ioctls to other drivers which
otherwise do not deserve a /dev-node of their own.  Will be used for RAID
mgmt among other things.  Initially only i386 gets the device, but other
platforms will follow in a few hours.  MAKEDEV stuff coming soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.55 2002/06/06 21:34:16 provos Exp $	*/
d435 6
@


1.55
log
@kqueue support for bpf; okay markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.54 2002/05/16 21:11:19 miod Exp $	*/
d572 2
@


1.54
log
@Add systrace support to all the remaining architectures.

Tested by various people on various platforms, I'm willing to fix any
breakage this causes.

ok niels@@ deraadt@@ and mickey@@ (after his comments were applied)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.53 2002/05/16 16:16:51 provos Exp $	*/
d296 2
a297 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
@


1.53
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.52 2002/03/14 01:27:13 millert Exp $	*/
d569 2
@


1.52
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.51 2002/01/23 04:48:02 ericj Exp $	*/
d254 6
@


1.51
log
@
move cdev_spkr_init() to conf.h for use by other arch's
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.50 2001/11/01 12:13:47 art Exp $	*/
d69 3
a71 3
#define	dev_type_open(n)	int n __P((dev_t, int, int, struct proc *))
#define	dev_type_close(n)	int n __P((dev_t, int, int, struct proc *))
#define	dev_type_strategy(n)	void n __P((struct buf *))
d73 1
a73 1
	int n __P((dev_t, u_long, caddr_t, int, struct proc *))
d85 10
a94 10
	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
				     struct proc *p));
	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
				     struct proc *p));
	void	(*d_strategy)	__P((struct buf *bp));
	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p));
	int	(*d_dump)	__P((dev_t dev, daddr_t blkno, caddr_t va,
				    size_t size));
	int	(*d_psize)	__P((dev_t dev));
d103 2
a104 2
#define	dev_type_dump(n)	int n __P((dev_t, daddr_t, caddr_t, size_t))
#define	dev_type_size(n)	int n __P((dev_t))
d144 9
a152 9
	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
				     struct proc *p));
	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
				     struct proc *));
	int	(*d_read)	__P((dev_t dev, struct uio *uio, int ioflag));
	int	(*d_write)	__P((dev_t dev, struct uio *uio, int ioflag));
	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p));
	int	(*d_stop)	__P((struct tty *tp, int rw));
d154 3
a156 3
		(*d_tty)	__P((dev_t dev));
	int	(*d_select)	__P((dev_t dev, int which, struct proc *p));
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));
d158 1
a158 1
	int	(*d_kqfilter)	__P((dev_t dev, struct knote *kn));
d166 7
a172 7
#define	dev_type_read(n)	int n __P((dev_t, struct uio *, int))
#define	dev_type_write(n)	int n __P((dev_t, struct uio *, int))
#define	dev_type_stop(n)	int n __P((struct tty *, int))
#define	dev_type_tty(n)		struct tty *n __P((dev_t))
#define	dev_type_select(n)	int n __P((dev_t, int, struct proc *))
#define	dev_type_mmap(n)	paddr_t n __P((dev_t, off_t, int))
#define dev_type_kqfilter(n)	int n __P((dev_t, struct knote *))
d380 1
a380 1
void	randomattach __P((void));
d442 11
a452 11
	int	(*l_open)	__P((dev_t dev, struct tty *tp));
	int	(*l_close)	__P((struct tty *tp, int flags));
	int	(*l_read)	__P((struct tty *tp, struct uio *uio,
				     int flag));
	int	(*l_write)	__P((struct tty *tp, struct uio *uio,
				     int flag));
	int	(*l_ioctl)	__P((struct tty *tp, u_long cmd, caddr_t data,
				     int flag, struct proc *p));
	int	(*l_rint)	__P((int c, struct tty *tp));
	int	(*l_start)	__P((struct tty *tp));
	int	(*l_modem)	__P((struct tty *tp, int flag));
d475 5
a479 5
int	chrtoblk __P((dev_t));
int	blktochr __P((dev_t));
int	iskmemdev __P((dev_t));
int	iszerodev __P((dev_t));
dev_t	getnulldev __P((void));
@


1.50
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.49 2001/10/04 21:46:03 gluk Exp $	*/
d425 6
@


1.50.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.51 2002/01/23 04:48:02 ericj Exp $	*/
a424 6

/* open, close, write, ioctl */
#define cdev_spkr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }
@


1.50.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.50.2.1 2002/01/31 22:55:48 niklas Exp $	*/
d69 3
a71 3
#define	dev_type_open(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_close(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_strategy(n)	void n(struct buf *)
d73 1
a73 1
	int n(dev_t, u_long, caddr_t, int, struct proc *)
d85 10
a94 10
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *p);
	void	(*d_strategy)(struct buf *bp);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_dump)(dev_t dev, daddr_t blkno, caddr_t va,
				    size_t size);
	int	(*d_psize)(dev_t dev);
d103 2
a104 2
#define	dev_type_dump(n)	int n(dev_t, daddr_t, caddr_t, size_t)
#define	dev_type_size(n)	int n(dev_t)
d144 9
a152 9
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *);
	int	(*d_read)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_write)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_stop)(struct tty *tp, int rw);
d154 3
a156 3
		(*d_tty)(dev_t dev);
	int	(*d_select)(dev_t dev, int which, struct proc *p);
	paddr_t	(*d_mmap)(dev_t, off_t, int);
d158 1
a158 1
	int	(*d_kqfilter)(dev_t dev, struct knote *kn);
d166 7
a172 7
#define	dev_type_read(n)	int n(dev_t, struct uio *, int)
#define	dev_type_write(n)	int n(dev_t, struct uio *, int)
#define	dev_type_stop(n)	int n(struct tty *, int)
#define	dev_type_tty(n)		struct tty *n(dev_t)
#define	dev_type_select(n)	int n(dev_t, int, struct proc *)
#define	dev_type_mmap(n)	paddr_t n(dev_t, off_t, int)
#define dev_type_kqfilter(n)	int n(dev_t, struct knote *)
a257 6
/* open, close, read, write, ioctl */
#define cdev_systrace_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

d290 1
a290 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_KQFILTER, dev_init(c,n,kqfilter) }
d380 1
a380 1
void	randomattach(void);
d442 11
a452 11
	int	(*l_open)(dev_t dev, struct tty *tp);
	int	(*l_close)(struct tty *tp, int flags);
	int	(*l_read)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_write)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_ioctl)(struct tty *tp, u_long cmd, caddr_t data,
				     int flag, struct proc *p);
	int	(*l_rint)(int c, struct tty *tp);
	int	(*l_start)(struct tty *tp);
	int	(*l_modem)(struct tty *tp, int flag);
d475 5
a479 5
int	chrtoblk(dev_t);
int	blktochr(dev_t);
int	iskmemdev(dev_t);
int	iszerodev(dev_t);
dev_t	getnulldev(void);
a562 2

cdev_decl(systrace);
@


1.50.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.50.2.2 2002/06/11 03:32:33 art Exp $	*/
d206 1
a206 1
/* open, close, read, ioctl, select, nokqfilter */
d213 1
a213 1
/* open, close, read, write, ioctl, select, nokqfilter */
d232 1
a232 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be a tty */
d239 1
a239 1
/* open, read, write, ioctl, select, kqfilter -- XXX should be a tty */
d271 1
a271 1
/* open, close, read, write, ioctl, tty, select, kqfilter */
d278 1
a278 1
/* open, close, read, ioctl, select, kqfilter -- XXX should be a generic device */
d283 1
a283 1
	(dev_type_mmap((*))) enodev, D_KQFILTER, dev_init(c,n,kqfilter) }
d292 1
a292 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be generic device */
d341 1
a341 1
/* open, close, read, write, ioctl, select, kqfilter */
d346 1
a346 1
	dev_init(c,n,mmap), D_KQFILTER, dev_init(c,n,kqfilter) }
d348 1
a348 1
/* open, close, read, write, ioctl, select, nokqfilter */
d361 1
a361 1
/* open, close, read, write, ioctl, select, nokqfilter */
d375 1
a375 1
/* open, close, read, write, ioctl, stop, tty, select, mmap, kqfilter */
d382 1
a382 1
/* open, close, read, write, ioctl, select, kqfilter */
d386 1
a386 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_KQFILTER, dev_init(c,n,kqfilter) }
d389 1
a389 1
/* open, close, ioctl, select, nokqfilter */
d409 2
a410 5
/* open, close, read, write, ioctl, select, nokqfilter */
#define	cdev_usbdev_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
d413 1
a413 1
#define cdev_pci_init(c,n) { \
d420 1
a420 1
#define cdev_iop_init(c,n) { \
d427 1
a427 1
#define cdev_radio_init(c,n) { \
a438 6
/* open, close, write, ioctl */
#define cdev_lpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

a570 4
cdev_decl(ksyms);

cdev_decl(crypto);

a571 12

cdev_decl(bio);

cdev_decl(gpr);

cdev_decl(usb);
cdev_decl(ugen);
cdev_decl(uhid);
cdev_decl(ucom);
cdev_decl(ulpt);
cdev_decl(uscanner);
cdev_decl(urio);
@


1.50.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 4

#ifndef _SYS_CONF_H_
#define _SYS_CONF_H_

a448 7
/* open, close, read, ioctl, mmap */
#define cdev_bktr_init(c, n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, \
	dev_init(c,n,mmap) }
				 
a490 2
extern int chrtoblktbl[];
extern int nchrtoblktbl;
a491 2
struct bdevsw *bdevsw_lookup(dev_t);
struct cdevsw *cdevsw_lookup(dev_t);
a589 1
cdev_decl(bktr);
a599 2

#endif /* _SYS_CONF_H_ */
@


1.49
log
@radio hooks
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.48 2001/09/28 02:53:13 mickey Exp $	*/
d156 1
a156 1
	int	(*d_mmap)	__P((dev_t, int, int));
d171 1
a171 1
#define	dev_type_mmap(n)	int n __P((dev_t, int, int))
@


1.48
log
@move cdev_decl(pf) into it's proper place, kill cdev_decl(ipl) at the same time
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.47 2001/08/06 22:34:44 mickey Exp $	*/
d419 7
d500 1
a500 1

@


1.47
log
@remove vm_conf.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.46 2001/08/06 20:50:22 miod Exp $	*/
d533 2
a537 2

cdev_decl(ipl);
@


1.46
log
@Remove legacy __BDEVSW_DUMP_OLD_TYPE code.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.45 2001/08/01 21:18:41 mickey Exp $	*/
d495 3
@


1.45
log
@wsmux should be here too
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.44 2001/07/05 02:35:34 mickey Exp $	*/
a91 1
#ifndef __BDEVSW_DUMP_OLD_TYPE
a93 3
#else /* not __BDEVSW_DUMP_OLD_TYPE */
	int	(*d_dump)	();	/* parameters vary by architecture */
#endif /* __BDEVSW_DUMP_OLD_TYPE */
a102 1
#ifndef __BDEVSW_DUMP_OLD_TYPE
a103 3
#else /* not __BDEVSW_DUMP_OLD_TYPE */
#define	dev_type_dump(n)	int n()	/* parameters vary by architecture */
#endif /* __BDEVSW_DUMP_OLD_TYPE */
@


1.44
log
@move cdev_decl(iop) into sys/conf.h
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.43 2001/06/26 03:04:30 provos Exp $	*/
d547 1
@


1.43
log
@ipf be gone
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.42 2001/06/24 19:48:59 kjell Exp $	*/
d413 1
d420 7
d512 2
@


1.42
log
@Initial import of pf, an all-new ipf-compatable packet filter.
Insane amounts of work done my dhartmei. Great work!
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.41 2001/06/23 03:30:37 matthieu Exp $	*/
a360 7

/* open, close, read, ioctl */
#define	cdev_gen_ipf(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }
@


1.41
log
@PCI bus configuration userland access from FreeBSD.
Will be used by XFree86 on powerpc (works on i386 too, but its not currently
used).
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.40 2001/05/13 15:39:26 deraadt Exp $	*/
d410 7
a419 1
/* open, close, ioctl */
@


1.40
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.39 2001/03/01 20:54:35 provos Exp $	*/
d412 7
@


1.39
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.38 2000/09/26 14:03:51 art Exp $	*/
d259 6
@


1.38
log
@Implement getnulldev that returns the dev_t for "/dev/null".
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.37 2000/07/03 19:22:37 mickey Exp $	*/
d53 1
d62 5
d165 2
a166 1
	int	d_type;
d180 1
d185 2
a186 1
	dev_decl(n,tty); dev_decl(n,select); dev_decl(n,mmap)
d211 2
a212 1
	dev_init(c,n,tty), ttselect, (dev_type_mmap((*))) enodev, D_TTY }
d244 2
a245 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }
d251 2
a252 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }
d272 1
a272 1
	D_TTY }
d381 2
a382 1
	dev_init(c,n,tty), ttselect, dev_init(c,n,mmap) }
@


1.37
log
@wscons-related definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.36 2000/04/09 21:07:46 matthieu Exp $	*/
d441 1
@


1.36
log
@fix ulpt major # allocation
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.35 2000/02/21 08:14:13 mjacob Exp $	*/
d365 6
d507 4
@


1.35
log
@add SES device init/decl macros
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.34 1999/11/22 23:54:55 deraadt Exp $	*/
d378 6
@


1.34
log
@matthieu fixed it
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.31 1999/11/20 11:11:27 matthieu Exp $	*/
d303 7
d473 2
@


1.34.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.35 2000/02/21 08:14:13 mjacob Exp $	*/
a302 7
/* open, close, ioctl */
#define       cdev_ses_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

a465 2

cdev_decl(ses);
@


1.34.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.39 2001/03/01 20:54:35 provos Exp $	*/
a52 1
struct knote;
a60 5
/*
 * Flags for d_type
 */
#define D_KQFILTER	0x00010000	/* has kqfilter entry */

d159 1
a159 2
	u_int	d_type;
	int	(*d_kqfilter)	__P((dev_t dev, struct knote *kn));
a172 1
#define dev_type_kqfilter(n)	int n __P((dev_t, struct knote *))
d177 1
a177 2
	dev_decl(n,tty); dev_decl(n,select); dev_decl(n,mmap); \
	dev_decl(n,kqfilter)
d202 1
a202 2
	dev_init(c,n,tty), ttselect, (dev_type_mmap((*))) enodev, \
	D_TTY | D_KQFILTER, ttkqfilter }
d234 1
a234 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_TTY | D_KQFILTER, dev_init(c,n,kqfilter) }
d240 1
a240 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_TTY | D_KQFILTER, ttkqfilter }
d260 1
a260 1
	D_TTY | D_KQFILTER, ttkqfilter }
a364 7
/* open, close, read, write, ioctl, stop, tty, select, mmap */
#define	cdev_wsdisplay_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	dev_init(c,n,tty), ttselect, dev_init(c,n,mmap), \
	D_KQFILTER, dev_init(c,n,kqfilter) }

a378 6
/* open, close, write, ioctl */
#define cdev_ulpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

a428 1
dev_t	getnulldev __P((void));
a494 4

cdev_decl(wsdisplay);
cdev_decl(wskbd);
cdev_decl(wsmouse);
@


1.34.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.34.2.2 2001/05/14 22:45:00 niklas Exp $	*/
a259 6
/* open, close, read, write, ioctl, mmap */
#define cdev_crypto_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

d356 7
a403 7
/* open, close, ioctl */
#define cdev_pf_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

a405 6

#define       cdev_pci_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }
@


1.34.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.34.2.3 2001/07/04 11:00:14 niklas Exp $	*/
d92 1
d95 3
d107 1
d109 3
a412 1
/* open, close, init */
a418 14
/* open, close, init */
#define       cdev_iop_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define       cdev_radio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

d493 1
a493 1
cdev_decl(radio);
a495 3
bdev_decl(sw);
cdev_decl(sw);

a504 2
cdev_decl(iop);

a527 2
cdev_decl(pf);

d532 2
a536 1
cdev_decl(wsmux);
@


1.34.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d156 1
a156 1
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));
d171 1
a171 1
#define	dev_type_mmap(n)	paddr_t n __P((dev_t, off_t, int))
@


1.34.2.6
log
@Merge in trunk
@
text
@a425 6
/* open, close, write, ioctl */
#define cdev_spkr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

@


1.34.2.7
log
@Merge in -current from roughly a week ago
@
text
@d69 3
a71 3
#define	dev_type_open(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_close(n)	int n(dev_t, int, int, struct proc *)
#define	dev_type_strategy(n)	void n(struct buf *)
d73 1
a73 1
	int n(dev_t, u_long, caddr_t, int, struct proc *)
d85 10
a94 10
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *p);
	void	(*d_strategy)(struct buf *bp);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_dump)(dev_t dev, daddr_t blkno, caddr_t va,
				    size_t size);
	int	(*d_psize)(dev_t dev);
d103 2
a104 2
#define	dev_type_dump(n)	int n(dev_t, daddr_t, caddr_t, size_t)
#define	dev_type_size(n)	int n(dev_t)
d144 9
a152 9
	int	(*d_open)(dev_t dev, int oflags, int devtype,
				     struct proc *p);
	int	(*d_close)(dev_t dev, int fflag, int devtype,
				     struct proc *);
	int	(*d_read)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_write)(dev_t dev, struct uio *uio, int ioflag);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p);
	int	(*d_stop)(struct tty *tp, int rw);
d154 3
a156 3
		(*d_tty)(dev_t dev);
	int	(*d_select)(dev_t dev, int which, struct proc *p);
	paddr_t	(*d_mmap)(dev_t, off_t, int);
d158 1
a158 1
	int	(*d_kqfilter)(dev_t dev, struct knote *kn);
d166 7
a172 7
#define	dev_type_read(n)	int n(dev_t, struct uio *, int)
#define	dev_type_write(n)	int n(dev_t, struct uio *, int)
#define	dev_type_stop(n)	int n(struct tty *, int)
#define	dev_type_tty(n)		struct tty *n(dev_t)
#define	dev_type_select(n)	int n(dev_t, int, struct proc *)
#define	dev_type_mmap(n)	paddr_t n(dev_t, off_t, int)
#define dev_type_kqfilter(n)	int n(dev_t, struct knote *)
d380 1
a380 1
void	randomattach(void);
d442 11
a452 11
	int	(*l_open)(dev_t dev, struct tty *tp);
	int	(*l_close)(struct tty *tp, int flags);
	int	(*l_read)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_write)(struct tty *tp, struct uio *uio,
				     int flag);
	int	(*l_ioctl)(struct tty *tp, u_long cmd, caddr_t data,
				     int flag, struct proc *p);
	int	(*l_rint)(int c, struct tty *tp);
	int	(*l_start)(struct tty *tp);
	int	(*l_modem)(struct tty *tp, int flag);
d475 5
a479 5
int	chrtoblk(dev_t);
int	blktochr(dev_t);
int	iskmemdev(dev_t);
int	iszerodev(dev_t);
dev_t	getnulldev(void);
@


1.34.2.8
log
@Sync the SMP branch with 3.3
@
text
@a43 4

#ifndef _SYS_CONF_H_
#define _SYS_CONF_H_

d206 1
a206 1
/* open, close, read, ioctl, select, nokqfilter */
d213 1
a213 1
/* open, close, read, write, ioctl, select, nokqfilter */
d232 1
a232 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be a tty */
d239 1
a239 1
/* open, read, write, ioctl, select, kqfilter -- XXX should be a tty */
a257 6
/* open, close, read, write, ioctl */
#define cdev_systrace_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

d265 1
a265 1
/* open, close, read, write, ioctl, tty, select, kqfilter */
d272 1
a272 1
/* open, close, read, ioctl, select, kqfilter -- XXX should be a generic device */
d277 1
a277 1
	(dev_type_mmap((*))) enodev, D_KQFILTER, dev_init(c,n,kqfilter) }
d286 1
a286 1
/* open, close, read, write, ioctl, select, kqfilter -- XXX should be generic device */
d290 1
a290 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_KQFILTER, dev_init(c,n,kqfilter) }
d334 1
a334 1
/* open, close, read, write, ioctl, select, kqfilter */
d339 1
a339 1
	dev_init(c,n,mmap), D_KQFILTER, dev_init(c,n,kqfilter) }
d341 1
a341 1
/* open, close, read, write, ioctl, select, nokqfilter */
d354 1
a354 1
/* open, close, read, write, ioctl, select, nokqfilter */
d368 1
a368 1
/* open, close, read, write, ioctl, stop, tty, select, mmap, kqfilter */
d375 1
a375 1
/* open, close, read, write, ioctl, select, kqfilter */
d379 1
a379 2
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_KQFILTER, dev_init(c,n,kqfilter) }
d382 1
a382 1
/* open, close, ioctl, select, nokqfilter */
d402 2
a403 5
/* open, close, read, write, ioctl, select, nokqfilter */
#define	cdev_usbdev_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
d406 1
a406 1
#define cdev_pci_init(c,n) { \
d413 1
a413 1
#define cdev_iop_init(c,n) { \
d420 1
a420 1
#define cdev_radio_init(c,n) { \
a431 13
/* open, close, write, ioctl */
#define cdev_lpt_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

/* open, close, read, ioctl, mmap */
#define cdev_bktr_init(c, n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, \
	dev_init(c,n,mmap) }
				 
a563 19
cdev_decl(ksyms);

cdev_decl(crypto);

cdev_decl(systrace);

cdev_decl(bio);

cdev_decl(gpr);
cdev_decl(bktr);

cdev_decl(usb);
cdev_decl(ugen);
cdev_decl(uhid);
cdev_decl(ucom);
cdev_decl(ulpt);
cdev_decl(uscanner);
cdev_decl(urio);

a564 2

#endif /* _SYS_CONF_H_ */
@


1.34.2.9
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a501 2
extern int chrtoblktbl[];
extern int nchrtoblktbl;
a502 2
struct bdevsw *bdevsw_lookup(dev_t);
struct cdevsw *cdevsw_lookup(dev_t);
@


1.34.2.10
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.34.2.9 2003/05/16 00:29:45 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.34.2.11
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
a155 1
	int	(*d_poll)(dev_t dev, int events, struct proc *p);
d170 1
a170 1
#define	dev_type_poll(n)	int n(dev_t, int, struct proc *)
d177 1
a177 1
	dev_decl(n,tty); dev_decl(n,poll); dev_decl(n,mmap); \
d203 1
a203 1
	dev_init(c,n,tty), ttpoll, (dev_type_mmap((*))) enodev, \
d206 1
a206 1
/* open, close, read, ioctl, poll, nokqfilter */
d210 1
a210 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d213 1
a213 1
/* open, close, read, write, ioctl, poll, nokqfilter */
d217 1
a217 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d232 1
a232 1
/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
d236 1
a236 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
d239 1
a239 1
/* open, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
d243 1
a243 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
d256 1
a256 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d262 1
a262 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d268 1
a268 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d271 1
a271 1
/* open, close, read, write, ioctl, tty, poll, kqfilter */
d275 2
a276 2
	dev_init(c,n,tty), dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
	D_TTY | D_KQFILTER, dev_init(c,n,kqfilter) }
d278 1
a278 1
/* open, close, read, ioctl, poll, kqfilter -- XXX should be a generic device */
d282 1
a282 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d290 1
a290 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d292 1
a292 1
/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
d296 1
a296 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
d303 1
a303 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d310 1
a310 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d317 1
a317 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d324 1
a324 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d338 1
a338 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d341 1
a341 1
/* open, close, read, write, ioctl, poll, kqfilter */
d345 1
a345 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d348 1
a348 1
/* open, close, read, write, ioctl, poll, nokqfilter */
d352 1
a352 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d359 1
a359 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d361 1
a361 1
/* open, close, read, write, ioctl, poll, nokqfilter */
d365 1
a365 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d375 1
a375 1
/* open, close, read, write, ioctl, stop, tty, poll, mmap, kqfilter */
d379 1
a379 1
	dev_init(c,n,tty), ttpoll, dev_init(c,n,mmap), \
d382 1
a382 1
/* open, close, read, write, ioctl, poll, kqfilter */
d386 1
a386 1
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
d390 1
a390 1
/* open, close, ioctl, poll, nokqfilter */
d394 1
a394 1
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
d401 1
a401 1
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }
d407 1
a407 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d410 1
a410 7
/* open, close, read, write, ioctl, poll, nokqfilter */
#define	cdev_urio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, poll, kqfilter */
d414 1
a414 2
	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, D_KQFILTER, \
	dev_init(c,n,kqfilter) }
d420 1
a420 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d427 1
a427 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
d434 1
a434 1
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
@


1.34.2.12
log
@Merge with the trunk
@
text
@d278 1
a278 7
/* open, close, read, write, ioctl, mmap */
#define cdev_ptm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, (dev_type_poll((*))) enodev, (dev_type_mmap((*))) enodev }

/* open, close, read, ioctl, poll, kqfilter XXX should be a generic device */
d462 1
a462 15

/* open, close, read, ioctl, poll, kqfilter */
#define cdev_hotplug_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
	(dev_type_mmap((*))) enodev, D_KQFILTER, dev_init(c,n,kqfilter) }

/* open, close, ioctl */
#define cdev_gpio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_poll((*))) enodev, \
	(dev_type_mmap((*))) enodev }

a535 2
cdev_decl(ptm);

a616 3

cdev_decl(hotplug);
cdev_decl(gpio);
@


1.33
log
@damn it
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.30 1999/08/13 05:38:05 fgsch Exp $	*/
d242 1
a242 1
/* open, close, read, write, mmap */
d245 1
a245 1
	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
@


1.32
log
@do not add stuff that breaks everything except your own machine, matthieu!
@
text
@d1 494
a494 502
Index: conf.h
===================================================================
RCS file: /cvs/src/sys/sys/conf.h,v
retrieving revision 1.30
diff -u -p -r1.30 conf.h
--- conf.h	1999/08/13 05:38:05	1.30
+++ conf.h	1999/11/22 17:49:51
@@@@ -1,494 +0,0 @@@@
-/*	$OpenBSD: conf.h,v 1.30 1999/08/13 05:38:05 fgsch Exp $	*/
-/*	$NetBSD: conf.h,v 1.33 1996/05/03 20:03:32 christos Exp $	*/
-
-/*-
- * Copyright (c) 1990, 1993
- *	The Regents of the University of California.  All rights reserved.
- * (c) UNIX System Laboratories, Inc.
- * All or some portions of this file are derived from material licensed
- * to the University of California by American Telephone and Telegraph
- * Co. or Unix System Laboratories, Inc. and are reproduced herein with
- * the permission of UNIX System Laboratories, Inc.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by the University of
- *	California, Berkeley and its contributors.
- * 4. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- *	@@(#)conf.h	8.3 (Berkeley) 1/21/94
- */
-
-/*
- * Definitions of device driver entry switches
- */
-
-struct buf;
-struct proc;
-struct tty;
-struct uio;
-struct vnode;
-
-/*
- * Types for d_type
- */
-#define	D_TAPE	1
-#define	D_DISK	2
-#define	D_TTY	3
-
-#ifdef _KERNEL
-
-#define	dev_type_open(n)	int n __P((dev_t, int, int, struct proc *))
-#define	dev_type_close(n)	int n __P((dev_t, int, int, struct proc *))
-#define	dev_type_strategy(n)	void n __P((struct buf *))
-#define	dev_type_ioctl(n) \
-	int n __P((dev_t, u_long, caddr_t, int, struct proc *))
-
-#define	dev_decl(n,t)	__CONCAT(dev_type_,t)(__CONCAT(n,t))
-#define	dev_init(c,n,t) \
-	((c) > 0 ? __CONCAT(n,t) : (__CONCAT(dev_type_,t)((*))) enxio)
-
-#endif /* _KERNEL */
-
-/*
- * Block device switch table
- */
-struct bdevsw {
-	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
-				     struct proc *p));
-	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
-				     struct proc *p));
-	void	(*d_strategy)	__P((struct buf *bp));
-	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
-				     int fflag, struct proc *p));
-#ifndef __BDEVSW_DUMP_OLD_TYPE
-	int	(*d_dump)	__P((dev_t dev, daddr_t blkno, caddr_t va,
-				    size_t size));
-#else /* not __BDEVSW_DUMP_OLD_TYPE */
-	int	(*d_dump)	();	/* parameters vary by architecture */
-#endif /* __BDEVSW_DUMP_OLD_TYPE */
-	int	(*d_psize)	__P((dev_t dev));
-	int	d_type;
-};
-
-#ifdef _KERNEL
-
-extern struct bdevsw bdevsw[];
-
-/* bdevsw-specific types */
-#ifndef __BDEVSW_DUMP_OLD_TYPE
-#define	dev_type_dump(n)	int n __P((dev_t, daddr_t, caddr_t, size_t))
-#else /* not __BDEVSW_DUMP_OLD_TYPE */
-#define	dev_type_dump(n)	int n()	/* parameters vary by architecture */
-#endif /* __BDEVSW_DUMP_OLD_TYPE */
-#define	dev_type_size(n)	int n __P((dev_t))
-
-/* bdevsw-specific initializations */
-#define	dev_size_init(c,n)	(c > 0 ? __CONCAT(n,size) : 0)
-
-#define	bdev_decl(n) \
-	dev_decl(n,open); dev_decl(n,close); dev_decl(n,strategy); \
-	dev_decl(n,ioctl); dev_decl(n,dump); dev_decl(n,size)
-
-#define	bdev_disk_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), \
-	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
-	dev_init(c,n,dump), dev_size_init(c,n), D_DISK }
-
-#define	bdev_tape_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), \
-	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
-	dev_init(c,n,dump), 0, D_TAPE }
-
-#define	bdev_swap_init(c,n) { \
-	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
-	dev_init(c,n,strategy), (dev_type_ioctl((*))) enodev, \
-	(dev_type_dump((*))) enodev, 0 }
-
-#define	bdev_lkm_dummy() { \
-	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
-	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
-	(dev_type_dump((*))) enodev, 0 }
-
-#define	bdev_notdef() { \
-	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
-	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
-	(dev_type_dump((*))) enodev, 0 }
-
-#endif
-
-/*
- * Character device switch table
- */
-struct cdevsw {
-	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
-				     struct proc *p));
-	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
-				     struct proc *));
-	int	(*d_read)	__P((dev_t dev, struct uio *uio, int ioflag));
-	int	(*d_write)	__P((dev_t dev, struct uio *uio, int ioflag));
-	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
-				     int fflag, struct proc *p));
-	int	(*d_stop)	__P((struct tty *tp, int rw));
-	struct tty *
-		(*d_tty)	__P((dev_t dev));
-	int	(*d_select)	__P((dev_t dev, int which, struct proc *p));
-	int	(*d_mmap)	__P((dev_t, int, int));
-	int	d_type;
-};
-
-#ifdef _KERNEL
-
-extern struct cdevsw cdevsw[];
-
-/* cdevsw-specific types */
-#define	dev_type_read(n)	int n __P((dev_t, struct uio *, int))
-#define	dev_type_write(n)	int n __P((dev_t, struct uio *, int))
-#define	dev_type_stop(n)	int n __P((struct tty *, int))
-#define	dev_type_tty(n)		struct tty *n __P((dev_t))
-#define	dev_type_select(n)	int n __P((dev_t, int, struct proc *))
-#define	dev_type_mmap(n)	int n __P((dev_t, int, int))
-
-#define	cdev_decl(n) \
-	dev_decl(n,open); dev_decl(n,close); dev_decl(n,read); \
-	dev_decl(n,write); dev_decl(n,ioctl); dev_decl(n,stop); \
-	dev_decl(n,tty); dev_decl(n,select); dev_decl(n,mmap)
-
-/* open, close, read, write, ioctl */
-#define	cdev_disk_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, D_DISK }
-
-/* open, close, read, write, ioctl */
-#define	cdev_tape_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, D_TAPE }
-
-/* open, close, read, ioctl */
-#define cdev_scanner_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) nullop, \
-	0, seltrue, (dev_type_mmap((*))) enodev, 0 }
-
-/* open, close, read, write, ioctl, stop, tty */
-#define	cdev_tty_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
-	dev_init(c,n,tty), ttselect, (dev_type_mmap((*))) enodev, D_TTY }
-
-/* open, close, read, ioctl, select */
-#define	cdev_mouse_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, read, write, ioctl, select */
-#define	cdev_mousewr_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-#define	cdev_lkm_dummy() { \
-	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
-	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
-	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev }
-
-#define	cdev_notdef() { \
-	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
-	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
-	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev }
-
-/* open, close, read, write, ioctl, select -- XXX should be a tty */
-#define	cdev_cn_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
-	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }
-
-/* open, read, write, ioctl, select -- XXX should be a tty */
-#define cdev_ctty_init(c,n) { \
-	dev_init(c,n,open), (dev_type_close((*))) nullop, dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
-	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }
-
-/* open, close, read, write, mmap */
-#define cdev_mm_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap) }
-
-/* read, write */
-#define cdev_swap_init(c,n) { \
-	(dev_type_open((*))) nullop, (dev_type_close((*))) nullop, \
-	dev_init(c,n,read), dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, read, write, ioctl, tty, select */
-#define cdev_ptc_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
-	dev_init(c,n,tty), dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
-	D_TTY }
-
-/* open, close, read, ioctl, select -- XXX should be a generic device */
-#define cdev_log_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-/* open */
-#define cdev_fd_init(c,n) { \
-	dev_init(c,n,open), (dev_type_close((*))) enodev, \
-	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
-	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
-	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
-
-/* open, close, read, write, ioctl, select -- XXX should be generic device */
-#define cdev_bpftun_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
-
-/* open, close, ioctl */
-#define	cdev_lkm_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, ioctl */
-#define	cdev_ch_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, ioctl */
-#define       cdev_uk_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, read, ioctl */
-#define cdev_ss_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, seltrue, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, ioctl, mmap */
-#define	cdev_fb_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	dev_init(c,n,mmap) }
-
-/* open, close, read, write, ioctl */
-#define cdev_audio_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	dev_init(c,n,mmap) }
-
-/* open, close, read, write, ioctl, poll */
-#define cdev_midi_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-#define	cdev_svr4_net_init(c,n) { \
-	dev_init(c,n,open), (dev_type_close((*))) enodev, \
-	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
-	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) nullop, \
-	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }
-
-/* open, close, read, ioctl */
-#define	cdev_gen_ipf(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, read, write, ioctl, select */
-#define cdev_xfs_init(c, n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-/* open, close, read */
-#define cdev_ksyms_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	(dev_type_write((*))) enodev, (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, seltrue, \
-	(dev_type_mmap((*))) enodev, 0 }
-
-/* open, close, read, write, ioctl, select */
-#define	cdev_random_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
-void	randomattach __P((void));
-
-/* open, close, ioctl, select */
-#define	cdev_usb_init(c,n) { \
-	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
-	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
-	(dev_type_mmap((*))) enodev }
-
-#define	cdev_usbdev_init(c,n)	cdev_random_init(c,n)
-#define	cdev_ugen_init(c,n)	cdev_random_init(c,n)
-
-/* symbolic sleep message strings */
-extern char devopn[], devio[], devwait[], devin[], devout[];
-extern char devioc[], devcls[];
-
-#endif
-
-/*
- * Line discipline switch table
- */
-struct linesw {
-	int	(*l_open)	__P((dev_t dev, struct tty *tp));
-	int	(*l_close)	__P((struct tty *tp, int flags));
-	int	(*l_read)	__P((struct tty *tp, struct uio *uio,
-				     int flag));
-	int	(*l_write)	__P((struct tty *tp, struct uio *uio,
-				     int flag));
-	int	(*l_ioctl)	__P((struct tty *tp, u_long cmd, caddr_t data,
-				     int flag, struct proc *p));
-	int	(*l_rint)	__P((int c, struct tty *tp));
-	int	(*l_start)	__P((struct tty *tp));
-	int	(*l_modem)	__P((struct tty *tp, int flag));
-};
-
-#ifdef _KERNEL
-extern struct linesw linesw[];
-#endif
-
-/*
- * Swap device table
- */
-struct swdevt {
-	dev_t	sw_dev;
-	int	sw_flags;
-	int	sw_nblks;
-	struct	vnode *sw_vp;
-};
-#define	SW_FREED	0x01
-#define	SW_SEQUENTIAL	0x02
-#define	sw_freed	sw_flags	/* XXX compat */
-
-#ifdef _KERNEL
-extern struct swdevt swdevt[];
-
-int	chrtoblk __P((dev_t));
-int	blktochr __P((dev_t));
-int	iskmemdev __P((dev_t));
-int	iszerodev __P((dev_t));
-
-cdev_decl(filedesc);
-
-cdev_decl(log);
-
-#ifndef LKM
-# define	NLKM	0
-# define	lkmenodev	enodev
-#else
-# define	NLKM	1
-#endif
-cdev_decl(lkm);
-
-#define	ptstty		ptytty
-#define	ptsioctl	ptyioctl
-cdev_decl(pts);
-
-#define	ptctty		ptytty
-#define	ptcioctl	ptyioctl
-cdev_decl(ptc);
-
-cdev_decl(ctty);
-
-cdev_decl(audio);
-cdev_decl(midi);
-cdev_decl(sequencer);
-
-cdev_decl(cn);
-
-bdev_decl(vnd);
-cdev_decl(vnd);
-
-bdev_decl(ccd);
-cdev_decl(ccd);
-
-bdev_decl(raid);
-cdev_decl(raid);
-
-cdev_decl(ch);
-
-cdev_decl(ss);
-
-bdev_decl(sd);
-cdev_decl(sd);
-
-bdev_decl(st);
-cdev_decl(st);
-
-bdev_decl(cd);
-cdev_decl(cd);
-
-bdev_decl(rd);
-cdev_decl(rd);
-
-bdev_decl(uk);
-cdev_decl(uk);
-
-cdev_decl(bpf);
-
-cdev_decl(tun);
-
-cdev_decl(random);
-
-cdev_decl(ipl);
-
-#ifdef COMPAT_SVR4
-# define NSVR4_NET	1
-#else
-# define NSVR4_NET	0
-#endif
-cdev_decl(svr4_net);
-
-#endif
@


1.31
log
@add MTRR support from FreeBSD
@
text
@d1 502
a502 494
/*	$OpenBSD: conf.h,v 1.30 1999/08/13 05:38:05 fgsch Exp $	*/
/*	$NetBSD: conf.h,v 1.33 1996/05/03 20:03:32 christos Exp $	*/

/*-
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)conf.h	8.3 (Berkeley) 1/21/94
 */

/*
 * Definitions of device driver entry switches
 */

struct buf;
struct proc;
struct tty;
struct uio;
struct vnode;

/*
 * Types for d_type
 */
#define	D_TAPE	1
#define	D_DISK	2
#define	D_TTY	3

#ifdef _KERNEL

#define	dev_type_open(n)	int n __P((dev_t, int, int, struct proc *))
#define	dev_type_close(n)	int n __P((dev_t, int, int, struct proc *))
#define	dev_type_strategy(n)	void n __P((struct buf *))
#define	dev_type_ioctl(n) \
	int n __P((dev_t, u_long, caddr_t, int, struct proc *))

#define	dev_decl(n,t)	__CONCAT(dev_type_,t)(__CONCAT(n,t))
#define	dev_init(c,n,t) \
	((c) > 0 ? __CONCAT(n,t) : (__CONCAT(dev_type_,t)((*))) enxio)

#endif /* _KERNEL */

/*
 * Block device switch table
 */
struct bdevsw {
	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
				     struct proc *p));
	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
				     struct proc *p));
	void	(*d_strategy)	__P((struct buf *bp));
	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p));
#ifndef __BDEVSW_DUMP_OLD_TYPE
	int	(*d_dump)	__P((dev_t dev, daddr_t blkno, caddr_t va,
				    size_t size));
#else /* not __BDEVSW_DUMP_OLD_TYPE */
	int	(*d_dump)	();	/* parameters vary by architecture */
#endif /* __BDEVSW_DUMP_OLD_TYPE */
	int	(*d_psize)	__P((dev_t dev));
	int	d_type;
};

#ifdef _KERNEL

extern struct bdevsw bdevsw[];

/* bdevsw-specific types */
#ifndef __BDEVSW_DUMP_OLD_TYPE
#define	dev_type_dump(n)	int n __P((dev_t, daddr_t, caddr_t, size_t))
#else /* not __BDEVSW_DUMP_OLD_TYPE */
#define	dev_type_dump(n)	int n()	/* parameters vary by architecture */
#endif /* __BDEVSW_DUMP_OLD_TYPE */
#define	dev_type_size(n)	int n __P((dev_t))

/* bdevsw-specific initializations */
#define	dev_size_init(c,n)	(c > 0 ? __CONCAT(n,size) : 0)

#define	bdev_decl(n) \
	dev_decl(n,open); dev_decl(n,close); dev_decl(n,strategy); \
	dev_decl(n,ioctl); dev_decl(n,dump); dev_decl(n,size)

#define	bdev_disk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
	dev_init(c,n,dump), dev_size_init(c,n), D_DISK }

#define	bdev_tape_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), \
	dev_init(c,n,strategy), dev_init(c,n,ioctl), \
	dev_init(c,n,dump), 0, D_TAPE }

#define	bdev_swap_init(c,n) { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	dev_init(c,n,strategy), (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

#define	bdev_lkm_dummy() { \
	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

#define	bdev_notdef() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_strategy((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_dump((*))) enodev, 0 }

#endif

/*
 * Character device switch table
 */
struct cdevsw {
	int	(*d_open)	__P((dev_t dev, int oflags, int devtype,
				     struct proc *p));
	int	(*d_close)	__P((dev_t dev, int fflag, int devtype,
				     struct proc *));
	int	(*d_read)	__P((dev_t dev, struct uio *uio, int ioflag));
	int	(*d_write)	__P((dev_t dev, struct uio *uio, int ioflag));
	int	(*d_ioctl)	__P((dev_t dev, u_long cmd, caddr_t data,
				     int fflag, struct proc *p));
	int	(*d_stop)	__P((struct tty *tp, int rw));
	struct tty *
		(*d_tty)	__P((dev_t dev));
	int	(*d_select)	__P((dev_t dev, int which, struct proc *p));
	int	(*d_mmap)	__P((dev_t, int, int));
	int	d_type;
};

#ifdef _KERNEL

extern struct cdevsw cdevsw[];

/* cdevsw-specific types */
#define	dev_type_read(n)	int n __P((dev_t, struct uio *, int))
#define	dev_type_write(n)	int n __P((dev_t, struct uio *, int))
#define	dev_type_stop(n)	int n __P((struct tty *, int))
#define	dev_type_tty(n)		struct tty *n __P((dev_t))
#define	dev_type_select(n)	int n __P((dev_t, int, struct proc *))
#define	dev_type_mmap(n)	int n __P((dev_t, int, int))

#define	cdev_decl(n) \
	dev_decl(n,open); dev_decl(n,close); dev_decl(n,read); \
	dev_decl(n,write); dev_decl(n,ioctl); dev_decl(n,stop); \
	dev_decl(n,tty); dev_decl(n,select); dev_decl(n,mmap)

/* open, close, read, write, ioctl */
#define	cdev_disk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, D_DISK }

/* open, close, read, write, ioctl */
#define	cdev_tape_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev, D_TAPE }

/* open, close, read, ioctl */
#define cdev_scanner_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) nullop, \
	0, seltrue, (dev_type_mmap((*))) enodev, 0 }

/* open, close, read, write, ioctl, stop, tty */
#define	cdev_tty_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	dev_init(c,n,tty), ttselect, (dev_type_mmap((*))) enodev, D_TTY }

/* open, close, read, ioctl, select */
#define	cdev_mouse_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, select */
#define	cdev_mousewr_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

#define	cdev_lkm_dummy() { \
	(dev_type_open((*))) lkmenodev, (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

#define	cdev_notdef() { \
	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, seltrue, (dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, select -- XXX should be a tty */
#define	cdev_cn_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }

/* open, read, write, ioctl, select -- XXX should be a tty */
#define cdev_ctty_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) nullop, dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev, D_TTY }

/* open, close, read, write, ioctl, mmap */
#define cdev_mm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap) }

/* read, write */
#define cdev_swap_init(c,n) { \
	(dev_type_open((*))) nullop, (dev_type_close((*))) nullop, \
	dev_init(c,n,read), dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, tty, select */
#define cdev_ptc_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
	dev_init(c,n,tty), dev_init(c,n,select), (dev_type_mmap((*))) enodev, \
	D_TTY }

/* open, close, read, ioctl, select -- XXX should be a generic device */
#define cdev_log_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

/* open */
#define cdev_fd_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, select -- XXX should be generic device */
#define cdev_bpftun_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define	cdev_lkm_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define	cdev_ch_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl */
#define       cdev_uk_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, ioctl */
#define cdev_ss_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, seltrue, \
	(dev_type_mmap((*))) enodev }

/* open, close, ioctl, mmap */
#define	cdev_fb_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	dev_init(c,n,mmap) }

/* open, close, read, write, ioctl */
#define cdev_audio_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	dev_init(c,n,mmap) }

/* open, close, read, write, ioctl, poll */
#define cdev_midi_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

#define	cdev_svr4_net_init(c,n) { \
	dev_init(c,n,open), (dev_type_close((*))) enodev, \
	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) nullop, \
	0, (dev_type_select((*))) enodev, (dev_type_mmap((*))) enodev }

/* open, close, read, ioctl */
#define	cdev_gen_ipf(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, (dev_type_select((*))) enodev, \
	(dev_type_mmap((*))) enodev }

/* open, close, read, write, ioctl, select */
#define cdev_xfs_init(c, n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

/* open, close, read */
#define cdev_ksyms_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	(dev_type_write((*))) enodev, (dev_type_ioctl((*))) enodev, \
	(dev_type_stop((*))) enodev, 0, seltrue, \
	(dev_type_mmap((*))) enodev, 0 }

/* open, close, read, write, ioctl, select */
#define	cdev_random_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
void	randomattach __P((void));

/* open, close, ioctl, select */
#define	cdev_usb_init(c,n) { \
	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
	(dev_type_stop((*))) enodev, 0, dev_init(c,n,select), \
	(dev_type_mmap((*))) enodev }

#define	cdev_usbdev_init(c,n)	cdev_random_init(c,n)
#define	cdev_ugen_init(c,n)	cdev_random_init(c,n)

/* symbolic sleep message strings */
extern char devopn[], devio[], devwait[], devin[], devout[];
extern char devioc[], devcls[];

#endif

/*
 * Line discipline switch table
 */
struct linesw {
	int	(*l_open)	__P((dev_t dev, struct tty *tp));
	int	(*l_close)	__P((struct tty *tp, int flags));
	int	(*l_read)	__P((struct tty *tp, struct uio *uio,
				     int flag));
	int	(*l_write)	__P((struct tty *tp, struct uio *uio,
				     int flag));
	int	(*l_ioctl)	__P((struct tty *tp, u_long cmd, caddr_t data,
				     int flag, struct proc *p));
	int	(*l_rint)	__P((int c, struct tty *tp));
	int	(*l_start)	__P((struct tty *tp));
	int	(*l_modem)	__P((struct tty *tp, int flag));
};

#ifdef _KERNEL
extern struct linesw linesw[];
#endif

/*
 * Swap device table
 */
struct swdevt {
	dev_t	sw_dev;
	int	sw_flags;
	int	sw_nblks;
	struct	vnode *sw_vp;
};
#define	SW_FREED	0x01
#define	SW_SEQUENTIAL	0x02
#define	sw_freed	sw_flags	/* XXX compat */

#ifdef _KERNEL
extern struct swdevt swdevt[];

int	chrtoblk __P((dev_t));
int	blktochr __P((dev_t));
int	iskmemdev __P((dev_t));
int	iszerodev __P((dev_t));

cdev_decl(filedesc);

cdev_decl(log);

#ifndef LKM
# define	NLKM	0
# define	lkmenodev	enodev
#else
# define	NLKM	1
#endif
cdev_decl(lkm);

#define	ptstty		ptytty
#define	ptsioctl	ptyioctl
cdev_decl(pts);

#define	ptctty		ptytty
#define	ptcioctl	ptyioctl
cdev_decl(ptc);

cdev_decl(ctty);

cdev_decl(audio);
cdev_decl(midi);
cdev_decl(sequencer);

cdev_decl(cn);

bdev_decl(vnd);
cdev_decl(vnd);

bdev_decl(ccd);
cdev_decl(ccd);

bdev_decl(raid);
cdev_decl(raid);

cdev_decl(ch);

cdev_decl(ss);

bdev_decl(sd);
cdev_decl(sd);

bdev_decl(st);
cdev_decl(st);

bdev_decl(cd);
cdev_decl(cd);

bdev_decl(rd);
cdev_decl(rd);

bdev_decl(uk);
cdev_decl(uk);

cdev_decl(bpf);

cdev_decl(tun);

cdev_decl(random);

cdev_decl(ipl);

#ifdef COMPAT_SVR4
# define NSVR4_NET	1
#else
# define NSVR4_NET	0
#endif
cdev_decl(svr4_net);

#endif
@


1.30
log
@Add USB devices support.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.29 1999/01/11 14:28:56 niklas Exp $	*/
d242 1
a242 1
/* open, close, read, write, mmap */
d245 1
a245 1
	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
@


1.29
log
@Import of CMU's RAIDframe via NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.28 1999/01/02 00:02:56 niklas Exp $	*/
d364 10
@


1.28
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.27 1998/08/30 17:11:33 art Exp $	*/
d446 3
@


1.27
log
@glue for xfs
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.26 1998/08/24 05:26:49 millert Exp $	*/
d320 10
a329 2
	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
	0, dev_init(c,n,select), dev_init(c,n,mmap) }
d436 2
@


1.26
log
@/dev/ksyms; kernel symbols pseudo-device that masquerades as an a.out binary for ports that copy the symbol table to the end of kernel space (all that use DDB do this)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.25 1998/04/26 21:03:18 provos Exp $	*/
d334 7
@


1.25
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.24 1998/04/01 20:14:16 matthieu Exp $	*/
d191 1
d335 7
@


1.24
log
@add read/write mouse driver
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.23 1997/11/23 05:17:58 mickey Exp $	*/
d320 1
a320 1
	0, dev_init(c,n,select), (dev_type_mmap((*))) enodev }
@


1.23
log
@ok. add cdev_decl(ipl)
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.22 1997/11/23 05:14:14 mickey Exp $	*/
d207 7
@


1.22
log
@missing ipf cdev_decl
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.21 1997/05/14 01:17:22 deraadt Exp $	*/
d440 1
a440 1
cdev_decl(ipf);
@


1.21
log
@add rd support
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.20 1996/12/03 05:16:36 kstailey Exp $	*/
d439 2
@


1.20
log
@well it used to.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.19 1996/12/03 05:09:04 kstailey Exp $	*/
d427 3
@


1.19
log
@dev_type_stop() returns void not int
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.18 1996/11/11 18:47:27 kstailey Exp $	*/
d169 1
a169 1
#define	dev_type_stop(n)	void n __P((struct tty *, int))
@


1.18
log
@removed bdev_decl(ss);
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.17 1996/11/06 01:29:03 deraadt Exp $	*/
d169 1
a169 1
#define	dev_type_stop(n)	int n __P((struct tty *, int))
@


1.17
log
@proto blktochr()
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.14 1996/10/04 17:58:41 niklas Exp $	*/
a416 1
bdev_decl(ss);
@


1.16
log
@random device is permanent now.
@
text
@d379 1
@


1.15
log
@add random pseudo-device declaration.
@
text
@d333 1
@


1.14
log
@Fixed prototype errors, reviewed & approved by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.13 1996/08/29 09:26:42 deraadt Exp $	*/
d433 2
@


1.13
log
@rnd -> random
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.12 1996/07/15 10:11:12 mickey Exp $	*/
d426 3
@


1.12
log
@add scanner scsi device.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.11 1996/07/15 07:49:38 mickey Exp $	*/
d329 1
a329 1
#define	cdev_rnd_init(c,n) { \
@


1.11
log
@add uk device macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.10 1996/06/10 19:52:48 niklas Exp $	*/
d293 7
@


1.10
log
@Remove the lkmenodev prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.7 1996/04/21 22:31:34 deraadt Exp $	*/
d283 7
@


1.9
log
@defn cdev_scanner_init()
@
text
@a375 1
int	lkmenodev();
@


1.8
log
@remove #ifndef LKM, since that stuff already in sys/conf.h,
add lkmenodev prototype.
@
text
@d2 1
a2 1
/*	$NetBSD: conf.h,v 1.32 1996/03/30 21:52:04 christos Exp $	*/
d190 6
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.6 1996/04/18 21:40:47 niklas Exp $	*/
d370 1
@


1.6
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.h,v 1.5 1996/03/31 13:16:40 mickey Exp $	*/
/*	$NetBSD: conf.h,v 1.31 1996/03/14 18:59:07 christos Exp $	*/
a43 2
#ifndef _SYS_CONF_H_
#define _SYS_CONF_H_
d360 55
d416 1
d418 1
a418 1
#endif /* _SYS_CONF_ */
@


1.5
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: conf.h,v 1.4 1996/03/29 12:05:56 mickey Exp $	*/
@


1.4
log
@Initial commit of random source driver.
@
text
@d1 2
a2 2
/*	$OpenBSD: conf.h,v 1.3 1996/03/03 12:11:27 niklas Exp $	*/
/*	$NetBSD: conf.h,v 1.30 1996/02/13 21:08:50 christos Exp $	*/
d44 2
d363 2
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d307 6
@


1.2
log
@move cdev_gen_ipf() macro to the <sys/conf.h>, so the lkm
for ipl is possible and also, why it is in <machine/conf.c> while
it (ipl) is in <net/*> ???
@
text
@d1 2
a2 1
/*	$NetBSD: conf.h,v 1.28 1995/08/14 05:05:55 cgd Exp $	*/
d350 4
@


1.1
log
@Initial revision
@
text
@d300 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
