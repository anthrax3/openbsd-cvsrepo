head	1.35;
access;
symbols
	OPENBSD_6_1_BASE:1.35
	OPENBSD_6_0:1.35.0.2
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.34.0.6
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.8
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.33.0.12
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.8
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.33.0.6
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.4
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.2
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.6
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.10
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.8
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.6
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.35
date	2016.05.21.14.00.27;	author jsing;	state Exp;
branches;
next	1.34;
commitid	75VU4m1ZupzmtdjG;

1.34
date	2014.07.01.05.22.38;	author dlg;	state Exp;
branches;
next	1.33;
commitid	HGeiwUTRJDwF1rhE;

1.33
date	2011.12.28.16.02.45;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2011.09.21.21.43.57;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.30.16.28.05;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.19.04.51.06;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.19.04.11.48;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2010.11.17.15.01.05;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.23.13.11.37;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2010.09.22.05.28.59;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.08.15.16.22;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.30.16.53.28;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.05.03.15.27.28;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.17.01.30.32;	author thib;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2007.12.23.01.59.58;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.01.18.26.29;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.05.05.12.43.35;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2007.03.30.00.38.56;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.15.20.20.42;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.15.02.45.46;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.22.14.10.59;	author deraadt;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.06.03.03.22.53;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.14.07.05.00;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.25.03.50.53;	author todd;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.09.19.26.35;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.05.02.13.13.21;	author deraadt;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.03.03.12.11.33;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.12.20.21.36;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2001.07.04.11.00.15;	author niklas;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.4.16.5;

1.4.16.5
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Cleanup some of the DUID code and refactor for readability.

ok krw@@ kettenis@@
@
text
@/*	$OpenBSD: disk.h,v 1.34 2014/07/01 05:22:38 dlg Exp $	*/
/*	$NetBSD: disk.h,v 1.11 1996/04/28 20:22:50 thorpej Exp $	*/

/*
 * Copyright (c) 1995 Jason R. Thorpe.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Header: disk.h,v 1.5 92/11/19 04:33:03 torek Exp  (LBL)
 *
 *	@@(#)disk.h	8.1 (Berkeley) 6/2/93
 */

/*
 * Disk device structures.
 */

#include <sys/device.h>
#include <sys/time.h>
#include <sys/queue.h>
#include <sys/rwlock.h>
#include <sys/mutex.h>

struct buf;
struct disklabel;

#define DS_DISKNAMELEN	16

struct diskstats {
	char		ds_name[DS_DISKNAMELEN];
	int		ds_busy;	/* busy counter */
	u_int64_t	ds_rxfer;	/* total number of read transfers */
	u_int64_t	ds_wxfer;	/* total number of write transfers */
	u_int64_t	ds_seek;	/* total independent seek operations */
	u_int64_t	ds_rbytes;	/* total bytes read */
	u_int64_t	ds_wbytes;	/* total bytes written */
	struct timeval	ds_attachtime;	/* time disk was attached */
	struct timeval	ds_timestamp;	/* time of first busy or any unbusy */
	struct timeval	ds_time;	/* total time spent busy */
};

struct disk {
	TAILQ_ENTRY(disk) dk_link;	/* link in global disklist */
	struct rwlock	dk_lock;	/* disk lock */
	struct mutex	dk_mtx;		/* busy/unbusy mtx */
	char		*dk_name;	/* disk name */
	struct device	*dk_device;	/* disk device structure. */
	dev_t		dk_devno;	/* disk device number. */
	int		dk_flags;	/* disk flags */
#define DKF_CONSTRUCTED	0x0001
#define DKF_OPENED	0x0002
#define DKF_NOLABELREAD	0x0004
#define DKF_LABELVALID	0x0008

	/*
	 * Metrics data; note that some metrics may have no meaning
	 * on certain types of disks.
	 */
	int		dk_busy;	/* busy counter */
	u_int64_t	dk_rxfer;	/* total number of read transfers */
	u_int64_t	dk_wxfer;	/* total number of write transfers */
	u_int64_t	dk_seek;	/* total independent seek operations */
	u_int64_t	dk_rbytes;	/* total bytes read */
	u_int64_t	dk_wbytes;	/* total bytes written */
	struct timeval	dk_attachtime;	/* time disk was attached */
	struct timeval	dk_timestamp;	/* time of first busy or any unbusy */
	struct timeval	dk_time;	/* total time spent busy */

	int		dk_bopenmask;	/* block devices open */
	int		dk_copenmask;	/* character devices open */
	int		dk_openmask;	/* composite (bopen|copen) */
	int		dk_state;	/* label state   ### */
	int		dk_blkshift;	/* shift to convert DEV_BSIZE to blks*/
	int		dk_byteshift;	/* shift to convert bytes to blks */

	/*
	 * Disk label information.  Storage for the in-core disk label
	 * must be dynamically allocated, otherwise the size of this
	 * structure becomes machine-dependent.
	 */
	struct disklabel *dk_label;
};

/* states */
#define	DK_CLOSED	0		/* drive is closed */
#define	DK_WANTOPEN	1		/* drive being opened */
#define	DK_WANTOPENRAW	2		/* drive being opened */
#define	DK_RDLABEL	3		/* label being read */
#define	DK_OPEN		4		/* label read, drive open */
#define	DK_OPENRAW	5		/* open without label */

/* Disk map flags. */
#define	DM_OPENPART	0x1		/* Open raw partition. */
#define	DM_OPENBLCK	0x2		/* Open block device. */

/*
 * disklist_head is defined here so that user-land has access to it.
 */
TAILQ_HEAD(disklist_head, disk);	/* the disklist is a TAILQ */

#ifdef _KERNEL
extern	struct disklist_head disklist;	/* list of disks attached to system */
extern	int disk_count;			/* number of disks in global disklist */
extern	int disk_change;		/* disk attached/detached */

void	disk_init(void);
int	disk_construct(struct disk *);
void	disk_attach(struct device *, struct disk *);
void	disk_detach(struct disk *);
int	disk_openpart(struct disk *, int, int, int);
void	disk_closepart(struct disk *, int, int);
void	disk_gone(int (*)(dev_t, int, int, struct proc *), int);
void	disk_busy(struct disk *);
void	disk_unbusy(struct disk *, long, int);

int	disk_lock(struct disk *);
void	disk_lock_nointr(struct disk *);
void    disk_unlock(struct disk *);
struct device *disk_lookup(struct cfdriver *, int);

char 	*disk_readlabel(struct disklabel *, dev_t, char *, size_t);

int	disk_map(char *, char *, int, int);

int	duid_iszero(u_char *);
const char *duid_format(u_char *);
#endif
@


1.34
log
@there is no disksort, so there are no stats produced to fill in a
disksort_stats structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.33 2011/12/28 16:02:45 jsing Exp $	*/
d157 3
@


1.33
log
@Avoid the use of an invalid disklabel by setting a DK_LABELVALID flag
if we correctly read and validated the disklabel. Always check that this
flag is set before using the DUID from the disklabel.

Discussed with deraadt@@

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.31 2011/06/30 16:28:05 matthew Exp $	*/
a127 15

#ifdef DISKSORT_STATS
/*
 * Stats from disksort().
 */
struct disksort_stats {
	long	ds_newhead;		/* # new queue heads created */
	long	ds_newtail;		/* # new queue tails created */
	long	ds_midfirst;		/* # insertions into sort list */
	long	ds_endfirst;		/* # insertions at end of sort list */
	long	ds_newsecond;		/* # inversions (2nd lists) created */
	long	ds_midsecond;		/* # insertions into 2nd list */
	long	ds_endsecond;		/* # insertions at end of 2nd list */
};
#endif
@


1.32
log
@Move the prototype for disk_readlabel to the .h file so that hibernate
can get at it.
ok jsing
@
text
@d86 1
@


1.31
log
@Refactor some common open/close/detach disk driver code into
subr_disk.c.  For now just the MI disk drivers.

ok deraadt@@, krw@@; jsing@@ liked the approach too
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.30 2011/06/19 04:51:06 matthew Exp $	*/
d167 2
@


1.30
log
@Add disk_lock_nointr() as a way to acquire the disk lock without being
interrupted by signals.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.29 2011/06/19 04:11:48 matthew Exp $	*/
d157 3
@


1.29
log
@Kill the "lockname" argument to disk_construct().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.28 2010/11/17 15:01:05 bluhm Exp $	*/
d161 1
@


1.28
log
@Make the comment for dk_timestamp more accurate.
ok krw@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.27 2010/09/23 13:11:37 jsing Exp $	*/
d154 1
a154 1
int	disk_construct(struct disk *, char *);
@


1.27
log
@Introduce a DKF_NOLABELREAD flag, which is used by a device to prevent
automatic reading of disklabel on attach.

ok deraadt@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.25 2010/09/08 15:16:22 jsing Exp $	*/
d71 1
a71 1
	struct timeval	ds_timestamp;	/* timestamp of last unbusy */
d98 1
a98 1
	struct timeval	dk_timestamp;	/* timestamp of last unbusy */
@


1.26
log
@Garbage collect the field dk_labelsector since there are no uses
in the tree. Update disk.9 to reflect current reality.

ok matthew@@ deraadt@@
@
text
@d83 3
a85 1
#define DKF_CONSTRUCTED  0x0001
@


1.25
log
@Introduce a disk_lookup() function which calls device_lookup(), before
verifying that the resulting device is present on the disklist. This
avoids a race whereby the disk driver can be accessed as soon as the
softc has been allocated, but before the disk has completed
initialisation and has called disk_attach() (up until this point
dk_label is still a null pointer).

Cut cd(4), sd(4) and wd(4) across to disk_lookup(). All callers of
disk_attach() need to be tested and cut over in due course.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.24 2010/09/08 14:47:12 jsing Exp $	*/
d111 1
a111 2
	daddr64_t	dk_labelsector;	/* sector containing label */
	struct disklabel *dk_label;	/* label */
@


1.24
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.21 2010/05/03 15:27:28 jsing Exp $	*/
d161 1
@


1.23
log
@Add a device number to struct disk and populate it on disk attach. Whilst
here also expose disklist for future use.

ok deraadt@@ miod@@
@
text
@d51 1
d80 1
d154 1
a154 1
void	disk_attach(struct disk *);
@


1.22
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d79 1
d109 1
a109 1
	daddr64_t	dk_labelsector;		/* sector containing label */
d146 1
@


1.21
log
@Provide a disk_map() function which attempts to map a disklabel UID to the
actual device. If successful, the real path is returned via mappath. Soon
to be used by several other diffs.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.19 2009/06/03 22:09:30 thib Exp $	*/
a102 2
	struct	dkdriver *dk_driver;	/* pointer to driver */

a109 13
};

struct dkdriver {
	void	(*d_strategy)(struct buf *);
#ifdef notyet
	int	(*d_open)(dev_t dev, int ifmt, int, struct proc *);
	int	(*d_close)(dev_t dev, int, int ifmt, struct proc *);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data, int fflag,
				struct proc *);
	int	(*d_dump)(dev_t);
	void	(*d_start)(struct buf *, daddr64_t);
	int	(*d_mklabel)(struct disk *);
#endif
@


1.20
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d135 4
d172 2
@


1.19
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.17 2007/06/20 18:15:47 deraadt Exp $	*/
a56 1
struct bufq;
a103 1
	struct	bufq	 *dk_bufq;
@


1.18
log
@protect the disk statistics with a mutex.

ok tedu@@ kettenis@@
@
text
@d57 1
d105 1
@


1.17
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.16 2007/06/01 18:26:29 deraadt Exp $	*/
d54 1
d77 1
@


1.16
log
@more completely safe daddr_t -> daddr64_t
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.15 2007/05/05 12:43:35 art Exp $	*/
a56 1
struct cpu_disklabel;
a109 1
	struct cpu_disklabel *dk_cpulabel;
@


1.15
log
@Kill disk_find and disk_resetstat that noone uses. If you ever need
them, they are still in cvs.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.14 2007/03/30 00:38:56 dlg Exp $	*/
d109 1
a109 1
	daddr_t		dk_labelsector;		/* sector containing label */
d122 1
a122 1
	void	(*d_start)(struct buf *, daddr_t);
@


1.14
log
@replace lockmgr locks with rwlocks. these are no longer recursive, but they
weren't used recursively anyway.

tested by hsoexer@@ fkr@@  ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.13 2006/03/15 20:20:42 miod Exp $	*/
a164 2
void	disk_resetstat(struct disk *);
struct	disk *disk_find(char *);
@


1.13
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.12 2004/02/15 02:45:46 tedu Exp $	*/
d53 1
a53 1
#include <sys/lock.h>
d76 1
a76 1
	struct lock	dk_lock;	/* disk lock */
@


1.12
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.11 2003/06/02 23:28:21 millert Exp $	*/
a169 3

struct device;
void	dk_establish(struct disk *, struct device *);
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.10 2002/03/14 01:27:14 millert Exp $	*/
d59 2
d62 1
d64 2
a65 1
	u_int64_t	ds_xfer;	/* total number of transfers */
d67 2
a68 1
	u_int64_t	ds_bytes;	/* total bytes transferred */
d86 2
a87 1
	u_int64_t	dk_xfer;	/* total number of transfers */
d89 2
a90 1
	u_int64_t	dk_bytes;	/* total bytes transferred */
d164 1
a164 1
void	disk_unbusy(struct disk *, long);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.9 2001/06/22 14:10:59 deraadt Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.8 2001/06/03 03:22:53 angelos Exp $	*/
d112 1
a112 1
	void	(*d_strategy) __P((struct buf *));
d114 7
a120 7
	int	(*d_open) __P((dev_t dev, int ifmt, int, struct proc *));
	int	(*d_close) __P((dev_t dev, int, int ifmt, struct proc *));
	int	(*d_ioctl) __P((dev_t dev, u_long cmd, caddr_t data, int fflag,
				struct proc *));
	int	(*d_dump) __P((dev_t));
	void	(*d_start) __P((struct buf *, daddr_t));
	int	(*d_mklabel) __P((struct disk *));
d156 8
a163 8
void	disk_init __P((void));
int	disk_construct __P((struct disk *, char *));
void	disk_attach __P((struct disk *));
void	disk_detach __P((struct disk *));
void	disk_busy __P((struct disk *));
void	disk_unbusy __P((struct disk *, long));
void	disk_resetstat __P((struct disk *));
struct	disk *disk_find __P((char *));
d165 2
a166 2
int	disk_lock __P((struct disk *));
void    disk_unlock __P((struct disk *));
d169 1
a169 1
void	dk_establish __P((struct disk *, struct device *));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.9 2001/06/22 14:10:59 deraadt Exp $	*/
d112 1
a112 1
	void	(*d_strategy)(struct buf *);
d114 7
a120 7
	int	(*d_open)(dev_t dev, int ifmt, int, struct proc *);
	int	(*d_close)(dev_t dev, int, int ifmt, struct proc *);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data, int fflag,
				struct proc *);
	int	(*d_dump)(dev_t);
	void	(*d_start)(struct buf *, daddr_t);
	int	(*d_mklabel)(struct disk *);
d156 8
a163 8
void	disk_init(void);
int	disk_construct(struct disk *, char *);
void	disk_attach(struct disk *);
void	disk_detach(struct disk *);
void	disk_busy(struct disk *);
void	disk_unbusy(struct disk *, long);
void	disk_resetstat(struct disk *);
struct	disk *disk_find(char *);
d165 2
a166 2
int	disk_lock(struct disk *);
void    disk_unlock(struct disk *);
d169 1
a169 1
void	dk_establish(struct disk *, struct device *);
@


1.8
log
@Add struct diskstats, for use by sysctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.7 2001/05/14 07:05:00 angelos Exp $	*/
d75 1
a75 1
	struct lock     dk_lock;        /* disk lock */
d77 1
a77 1
	int             dk_flags;       /* disk flags */
d157 1
a157 1
int     disk_construct __P((struct disk *, char *));
d165 1
a165 1
int     disk_lock __P((struct disk *));
@


1.7
log
@External variable disk_change.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.6 2001/01/25 03:50:53 todd Exp $	*/
d63 10
a78 6
	int		dk_bopenmask;	/* block devices open */
	int		dk_copenmask;	/* character devices open */
	int		dk_openmask;	/* composite (bopen|copen) */
	int		dk_state;	/* label state   ### */
	int		dk_blkshift;	/* shift to convert DEV_BSIZE to blks */
	int		dk_byteshift;	/* shift to convert bytes to blks */
d91 7
@


1.6
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.4 1996/05/02 13:13:21 deraadt Exp $	*/
d143 1
@


1.5
log
@

Move a locking function that was spread throughout disk device drivers into
the disk structure.

The locking was mostly used in disk device drivers to prevent multiple
disklabel operations from going on simultaneously against the device.

Added disk_construct(), a constructor for the disk structure, that
initializes the lock structure in disk. It is called by default in
disk_attach() if it hasn't been called yet.

Added disk_lock and disk_unlock
@
text
@d83 1
a83 1
	u_int64_t	dk_bytes;	/* total bytes transfered */
@


1.4
log
@dk_establish() is actually supposed to be void
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.3 1996/03/03 12:11:33 niklas Exp $	*/
d57 1
d65 1
d67 2
d145 1
d152 3
@


1.4.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.6 2001/01/25 03:50:53 todd Exp $	*/
a56 1
#include <sys/lock.h>
a63 1
	struct lock     dk_lock;        /* disk lock */
a64 2
	int             dk_flags;       /* disk flags */
#define DKF_CONSTRUCTED  0x0001
d79 1
a79 1
	u_int64_t	dk_bytes;	/* total bytes transferred */
a140 1
int     disk_construct __P((struct disk *, char *));
a146 3

int     disk_lock __P((struct disk *));
void    disk_unlock __P((struct disk *));
@


1.4.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.4.16.1 2001/05/14 22:45:01 niklas Exp $	*/
a62 10
struct diskstats {
	int		ds_busy;	/* busy counter */
	u_int64_t	ds_xfer;	/* total number of transfers */
	u_int64_t	ds_seek;	/* total independent seek operations */
	u_int64_t	ds_bytes;	/* total bytes transferred */
	struct timeval	ds_attachtime;	/* time disk was attached */
	struct timeval	ds_timestamp;	/* timestamp of last unbusy */
	struct timeval	ds_time;	/* total time spent busy */
};

d65 1
a65 1
	struct lock	dk_lock;	/* disk lock */
d67 1
a67 1
	int		dk_flags;	/* disk flags */
d69 6
a87 7
	int		dk_bopenmask;	/* block devices open */
	int		dk_copenmask;	/* character devices open */
	int		dk_openmask;	/* composite (bopen|copen) */
	int		dk_state;	/* label state   ### */
	int		dk_blkshift;	/* shift to convert DEV_BSIZE to blks*/
	int		dk_byteshift;	/* shift to convert bytes to blks */

a142 1
extern	int disk_change;		/* disk attached/detached */
d145 1
a145 1
int	disk_construct __P((struct disk *, char *));
d153 1
a153 1
int	disk_lock __P((struct disk *));
@


1.4.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 1
a112 1
	void	(*d_strategy)(struct buf *);
d114 7
a120 7
	int	(*d_open)(dev_t dev, int ifmt, int, struct proc *);
	int	(*d_close)(dev_t dev, int, int ifmt, struct proc *);
	int	(*d_ioctl)(dev_t dev, u_long cmd, caddr_t data, int fflag,
				struct proc *);
	int	(*d_dump)(dev_t);
	void	(*d_start)(struct buf *, daddr_t);
	int	(*d_mklabel)(struct disk *);
d156 8
a163 8
void	disk_init(void);
int	disk_construct(struct disk *, char *);
void	disk_attach(struct disk *);
void	disk_detach(struct disk *);
void	disk_busy(struct disk *);
void	disk_unbusy(struct disk *, long);
void	disk_resetstat(struct disk *);
struct	disk *disk_find(char *);
d165 2
a166 2
int	disk_lock(struct disk *);
void    disk_unlock(struct disk *);
d169 1
a169 1
void	dk_establish(struct disk *, struct device *);
@


1.4.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disk.h,v 1.4.16.3 2002/03/28 14:52:01 niklas Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.16.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a58 2
#define DS_DISKNAMELEN	16

a59 1
	char		ds_name[DS_DISKNAMELEN];
d61 1
a61 2
	u_int64_t	ds_rxfer;	/* total number of read transfers */
	u_int64_t	ds_wxfer;	/* total number of write transfers */
d63 1
a63 2
	u_int64_t	ds_rbytes;	/* total bytes read */
	u_int64_t	ds_wbytes;	/* total bytes written */
d81 1
a81 2
	u_int64_t	dk_rxfer;	/* total number of read transfers */
	u_int64_t	dk_wxfer;	/* total number of write transfers */
d83 1
a83 2
	u_int64_t	dk_rbytes;	/* total bytes read */
	u_int64_t	dk_wbytes;	/* total bytes written */
d157 1
a157 1
void	disk_unbusy(struct disk *, long, int);
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: disk.h,v 1.9 1996/01/07 22:04:07 thorpej Exp $	*/
d147 3
@


1.2
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disk.h,v 1.8 1994/10/30 21:49:49 cgd Exp $	*/
d4 1
a51 3
 *
 * Note that this is only a preliminary outline.  The final disk structures
 * may be somewhat different.
d53 4
d58 24
a82 10
struct dkdevice {
	struct	device dk_dev;		/* base device */
	struct	dkdevice *dk_next;	/* list of disks; not yet used */
	int	dk_bps;			/* xfer rate: bytes per second */
	int	dk_bopenmask;		/* block devices open */
	int	dk_copenmask;		/* character devices open */
	int	dk_openmask;		/* composite (bopen|copen) */
	int	dk_state;		/* label state   ### */
	int	dk_blkshift;		/* shift to convert DEV_BSIZE to blks */
	int	dk_byteshift;		/* shift to convert bytes to blks */
d84 9
a92 3
	daddr_t	dk_labelsector;		/* sector containing label */
	struct	disklabel dk_label;	/* label */
	struct	cpu_disklabel dk_cpulabel;
d104 1
a104 1
	int	(*d_mklabel) __P((struct dkdevice *));
d129 17
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
