head	1.41;
access;
symbols
	OPENBSD_6_1:1.40.0.4
	OPENBSD_6_1_BASE:1.40
	OPENBSD_6_0:1.39.0.8
	OPENBSD_6_0_BASE:1.39
	OPENBSD_5_9:1.39.0.4
	OPENBSD_5_9_BASE:1.39
	OPENBSD_5_8:1.39.0.6
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.2
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.36.0.4
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.2
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.41
date	2017.06.22.15.56.29;	author deraadt;	state Exp;
branches;
next	1.40;
commitid	5gBsdPyz1dyxur4n;

1.40
date	2016.09.27.02.53.49;	author dlg;	state Exp;
branches;
next	1.39;
commitid	IKbDU06cxpmqw0qB;

1.39
date	2015.02.07.01.19.40;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	J7ySI1ZREP62T8hM;

1.38
date	2014.10.09.00.42.05;	author mlarkin;	state Exp;
branches;
next	1.37;
commitid	WIUdGGyVzW22TmR2;

1.37
date	2014.09.26.09.25.38;	author kettenis;	state Exp;
branches;
next	1.36;
commitid	UmzZe6RDH5pRTdO3;

1.36
date	2014.07.20.18.05.21;	author mlarkin;	state Exp;
branches;
next	1.35;
commitid	F1K1yInguabWnn54;

1.35
date	2014.07.16.07.42.51;	author mlarkin;	state Exp;
branches;
next	1.34;
commitid	BhZaVf1oRCQi7Ocn;

1.34
date	2014.07.12.09.02.24;	author kettenis;	state Exp;
branches;
next	1.33;
commitid	PNB6VkI4aO2bcc3c;

1.33
date	2014.07.11.03.06.08;	author mlarkin;	state Exp;
branches;
next	1.32;
commitid	85Nfk4jewp1BRfpK;

1.32
date	2014.07.09.14.10.25;	author mlarkin;	state Exp;
branches;
next	1.31;
commitid	T9vAIJG20qGyXHaR;

1.31
date	2014.07.09.12.43.51;	author mlarkin;	state Exp;
branches;
next	1.30;
commitid	zvLzdPz8mUqSem4o;

1.30
date	2013.11.09.06.54.00;	author mlarkin;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.09.04.38.42;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.06.19.45.45;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.06.17.02.59;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2013.11.06.12.06.56;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.09.29.16.28.35;	author mlarkin;	state Exp;
branches;
next	1.24;

1.24
date	2013.04.09.18.58.03;	author mlarkin;	state Exp;
branches;
next	1.23;

1.23
date	2013.01.17.02.36.45;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.07.08.12.22.26;	author mlarkin;	state Exp;
branches;
next	1.21;

1.21
date	2012.06.21.12.46.30;	author jmatthew;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.26.16.15.42;	author mlarkin;	state Exp;
branches;
next	1.19;

1.19
date	2011.11.29.05.21.10;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2011.11.16.23.52.27;	author mlarkin;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.14.00.25.17;	author mlarkin;	state Exp;
branches;
next	1.16;

1.16
date	2011.11.13.23.13.29;	author mlarkin;	state Exp;
branches;
next	1.15;

1.15
date	2011.11.13.22.36.27;	author mlarkin;	state Exp;
branches;
next	1.14;

1.14
date	2011.09.22.22.12.43;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2011.09.21.02.51.23;	author mlarkin;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.11.03.30.32;	author mlarkin;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.09.03.10.27;	author mlarkin;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.09.01.30.39;	author mlarkin;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.09.00.55.00;	author mlarkin;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.09.00.27.31;	author mlarkin;	state Exp;
branches;
next	1.7;

1.7
date	2011.07.09.00.08.04;	author mlarkin;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.08.21.00.53;	author ariane;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.08.18.34.46;	author ariane;	state Exp;
branches;
next	1.4;

1.4
date	2011.07.08.18.31.16;	author ariane;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.08.18.25.56;	author ariane;	state Exp;
branches;
next	1.2;

1.2
date	2011.07.08.18.20.10;	author ariane;	state Exp;
branches;
next	1.1;

1.1
date	2011.07.08.17.58.16;	author ariane;	state Exp;
branches;
next	;


desc
@@


1.41
log
@calculate a "sum" based upon pointers to functions all over the kernel,
so that an unhibernate kernel can detect if it is running with the
kernel it booted.
ok mlarkin
@
text
@/*	$OpenBSD: hibernate.h,v 1.40 2016/09/27 02:53:49 dlg Exp $	*/

/*
 * Copyright (c) 2011 Ariane van der Steldt <ariane@@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SYS_HIBERNATE_H_
#define _SYS_HIBERNATE_H_

#include <sys/types.h>
#include <sys/tree.h>
#include <lib/libz/zlib.h>
#include <machine/vmparam.h>

#define HIBERNATE_CHUNK_USED 1
#define HIBERNATE_CHUNK_CONFLICT 2
#define HIBERNATE_CHUNK_PLACED 4

/* Magic number used to indicate hibernate signature block */
#define HIBERNATE_MAGIC 0x0B5D0B5D

struct hiballoc_entry;

/*
 * Allocator operates from an arena, that is pre-allocated by the caller.
 */
struct hiballoc_arena {
	RBT_HEAD(hiballoc_addr, hiballoc_entry)	hib_addrs;
};

/*
 * Describes a zlib compression stream and its associated hiballoc area
 */
struct hibernate_zlib_state {
        z_stream hib_stream;
        struct hiballoc_arena hiballoc_arena;
};

/*
 * Describes a range of physical memory on the machine
 */
struct hibernate_memory_range {
	paddr_t		base;
	paddr_t		end;
};

/*
 * Describes a hibernate chunk structure, used when splitting the memory
 * image of the machine into easy-to-manage pieces.
 */
struct hibernate_disk_chunk {
	paddr_t		base;		/* Base of chunk */
	paddr_t		end;		/* End of chunk */		
	daddr_t		offset;		/* Abs. disk block locating chunk */
	size_t		compressed_size; /* Compressed size on disk */
	short		flags;		/* Flags */
};

#define HIB_INIT	-1
#define HIB_DONE	-2
#define HIB_R		0
#define HIB_W		1
typedef	int (*hibio_fn)(dev_t, daddr_t, vaddr_t, size_t, int, void *);

/*
 * Used to store information about the hibernation state of the machine,
 * such as memory range count and extents, disk sector size, and various
 * offsets where things are located on disk.
 */
union hibernate_info {
	struct {
		u_int32_t			magic;	
		size_t				nranges;
		struct hibernate_memory_range	ranges[VM_PHYSSEG_MAX];
		size_t				image_size;
		size_t				chunk_ctr;
		dev_t				dev;
		daddr_t				sig_offset;
		daddr_t				chunktable_offset;
		daddr_t				image_offset;
		paddr_t				piglet_pa;
		vaddr_t				piglet_va;
		char				kernel_version[128];
		u_int32_t			kernel_sum;
		hibio_fn			io_func;
		void				*io_page;
#ifndef NO_PROPOLICE
		long				guard;
#endif /* ! NO_PROPOLICE */
	};

	/* XXX - remove restriction to have this union fit in a single block */
	char pad[512]; /* Pad to 512 bytes */
};

void	*hib_alloc(struct hiballoc_arena*, size_t);
void	 hib_free(struct hiballoc_arena*, void*);
int	 hiballoc_init(struct hiballoc_arena*, void*, size_t len);
void	 uvm_pmr_zero_everything(void);
void	 uvm_pmr_dirty_everything(void);
int	 uvm_pmr_alloc_pig(paddr_t*, psize_t, paddr_t);
int	 uvm_pmr_alloc_piglet(vaddr_t*, paddr_t*, vsize_t, paddr_t);
void	 uvm_pmr_free_piglet(vaddr_t, vsize_t);
int	 uvm_page_rle(paddr_t);
void	 uvmpd_hibernate(void);

hibio_fn get_hibernate_io_function(dev_t);
int	get_hibernate_info(union hibernate_info *, int);

int	hibernate_zlib_reset(union hibernate_info *, int);
void	*hibernate_zlib_alloc(void *, int, int);
void	hibernate_zlib_free(void *, void *);
void	hibernate_inflate_region(union hibernate_info *, paddr_t, paddr_t,
	    size_t);
size_t	hibernate_deflate(union hibernate_info *, paddr_t, size_t *);
void	hibernate_process_chunk(union hibernate_info *,
	    struct hibernate_disk_chunk *, paddr_t);
int	hibernate_inflate_page(int *);

int	hibernate_block_io(union hibernate_info *, daddr_t, size_t, vaddr_t, int);
int	hibernate_write_signature(union hibernate_info *);
int	hibernate_write_chunktable(union hibernate_info *);
int	hibernate_write_chunks(union hibernate_info *);
int	hibernate_clear_signature(void);
int	hibernate_compare_signature(union hibernate_info *,
	    union hibernate_info *);
void	hibernate_resume(void);
int	hibernate_suspend(void);
int	hibernate_read_image(union hibernate_info *);
int	hibernate_read_chunks(union hibernate_info *, paddr_t, paddr_t, size_t,
	    struct hibernate_disk_chunk *);
void	hibernate_unpack_image(union hibernate_info *);
void	hibernate_populate_resume_pt(union hibernate_info *, paddr_t, paddr_t);
int	hibernate_alloc(void);
void	hibernate_free(void);
void	hib_getentropy(char **, size_t *);

void	hibernate_sort_ranges(union hibernate_info *);
void	hibernate_suspend_bufcache(void);
void	hibernate_resume_bufcache(void);

#endif /* _SYS_HIBERNATE_H_ */
@


1.40
log
@move from RB macros to RBT functions
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.39 2015/02/07 01:19:40 deraadt Exp $	*/
d96 1
@


1.39
log
@New framework that allows hibernate to pass in entropy from it's fresh
boot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.38 2014/10/09 00:42:05 mlarkin Exp $	*/
d40 1
a40 1
	RB_HEAD(hiballoc_addr, hiballoc_entry)	hib_addrs;
@


1.38
log
@

remove an unused function and some unused variables in hibernate
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.37 2014/09/26 09:25:38 kettenis Exp $	*/
d147 1
@


1.37
log
@Rework piglet and pig allocation.  Currently the piglet gets allocated
deep down in the suspend path, where it is really hard to recover from
allocation failure.  So allocate the piglet early on in the suspend path.
Also change the piglet and piglet allocation functions to use km_alloc(9)
instead of doing pmemrange magic.  This removes a bunch of code which, in the
case of the piglet allocation, is broken since it results in a NULL pointer
dereference.  Also switch the piglet allocation to not wait.  If we can't
allocate 16MB of phys contig memory on a halfway modern machine we're almost
certainly under a lot of memory pressure and we're better off not trying to
hibernate anyway.

ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.36 2014/07/20 18:05:21 mlarkin Exp $	*/
a147 1
int	hibernate_check_overlap(paddr_t, paddr_t, paddr_t, paddr_t);
@


1.36
log
@
Support hibernating to softraid crypto volumes.

much help and ok from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.35 2014/07/16 07:42:51 mlarkin Exp $	*/
d112 1
a112 1
int	 uvm_pmr_alloc_pig(paddr_t*, psize_t);
d145 1
@


1.35
log
@

Reenable hibernate RLE support and flush+zero all memory after unpack.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.34 2014/07/12 09:02:24 kettenis Exp $	*/
d118 1
a118 1
hibio_fn get_hibernate_io_function(void);
@


1.34
log
@Add a function to drop all clean pages on the page daemon queues and call
it when we hibernate.

ok mlarkin@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.33 2014/07/11 03:06:08 mlarkin Exp $	*/
d129 1
a129 1
int	hibernate_inflate_page(void);
@


1.33
log
@Flush the buffercache to 16MB on hibernate and restore its previous max
size (kern.bufcachepercent) on resume, for better hibernate performance.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.32 2014/07/09 14:10:25 mlarkin Exp $	*/
d116 1
@


1.32
log
@

Cleanup the chunk placement routine by removing the conflict resolver.
Chunks are now sorted by ascending PA and all chunks are bounced before
unpack. This fixes an issue where the trampoline chunks were being placed
at the end of the unpack ordering, causing overwrite during unpack.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.31 2014/07/09 12:43:51 mlarkin Exp $	*/
d148 2
@


1.31
log
@

Use suspending kernel's stack smash guard to avoid panicing during unpack.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.30 2013/11/09 06:54:00 mlarkin Exp $	*/
d147 1
@


1.30
log
@

Remove hibernate_get_next_rle function (unused, and we need to redo it
anyway as we move toward a streamed implmentation)
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.29 2013/11/09 04:38:42 deraadt Exp $	*/
d98 3
@


1.29
log
@unbias the chunks and chunktable writing and reading.  as a result, it
is now possible to move the chunktable right after the chunks, not at
the end of the swap.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.28 2013/11/06 19:45:45 deraadt Exp $	*/
a124 1
int	hibernate_get_next_rle(void);
@


1.28
log
@shorten dev_t in hib_info
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.26 2013/11/06 12:06:56 deraadt Exp $	*/
d91 1
@


1.27
log
@use DEV_BSIZE instead of "secsize"
ok mlarkin
@
text
@d89 1
a89 1
		dev_t				device;
@


1.26
log
@teach the side-effect free drivers about the partition they are dealing
by passing a start/length in the HIB_INIT op.  Then rebase all
hibernate-time block offsets to be relative to the start of that partition.
This simplifies things a lot.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.25 2013/09/29 16:28:35 mlarkin Exp $	*/
a88 1
		u_int32_t			secsize;
@


1.25
log
@

Removed some unused code
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.24 2013/04/09 18:58:03 mlarkin Exp $	*/
a90 1
		daddr_t				swap_offset;
@


1.24
log
@

Add a magic number to the head of the signature block. Check for magic
number match during signature block read during speculative unhibernate on
boot. If the magic number matches but we have otherwise chosen to not
unhibernate (due to kernel/memory mismatch), clear the signature block
early to avoid accidentally trying to unhibernate on subsequent boots. This
prevents accidental unhibernates and endless unhibernate/reboot cycles.

Add a define for HIBERNATE_DEBUG for various debugging printfs (disabled by
default).

Finally, change some KASSERTs to warning printfs (they probably shouldn't
have been KASSERTs in the first place).

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.23 2013/01/17 02:36:45 deraadt Exp $	*/
a25 4

#if 0
#define HIBERNATE_DEBUG
#endif
@


1.23
log
@Add a hibernate HIB_DONE op.  After the memory-side-effect driver finishes
IO to the disk, DVACT_RESUME the controller back to normal operation.  That
allows us to do the full DVACT_POWERDOWN sequence afterwards.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.22 2012/07/08 12:22:26 mlarkin Exp $	*/
d27 4
d35 3
d88 1
@


1.22
log
@

Reorganize some hibernate functions for easier readability.
Fix some incorrect/old comments.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.21 2012/06/21 12:46:30 jmatthew Exp $	*/
d69 1
@


1.21
log
@use regular i/o functions in the hibernate resume path.  ahci(4) hibernate
i/o will not mix with regular i/o so it can only be used in the hibernate
path.

ok deraadt@@ mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.20 2012/03/26 16:15:42 mlarkin Exp $	*/
d116 2
a117 1
void	hibernate_inflate(union hibernate_info *, paddr_t, paddr_t, size_t);
d119 4
@


1.20
log
@

Fix an integer math error when using the result of uvm_page_rle, and
at the same time increase said function's max RLE page count return value.

Add hooks in the right places to call the hibernate suspend and resume
routines, so that we can enable hibernation with a HIBERNATE option
line in GENERIC and appropriate acpi.c goo.

discussed on and off with deraadt@@ over the past few months
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.19 2011/11/29 05:21:10 deraadt Exp $	*/
d119 1
a119 1
int	hibernate_read_block(union hibernate_info *, daddr_t, size_t, vaddr_t);
@


1.19
log
@ready this for big-endian support later on
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.18 2011/11/16 23:52:27 mlarkin Exp $	*/
d108 1
a108 1
u_char	 uvm_page_rle(paddr_t);
@


1.18
log
@

Reduce use of globals in hibernate code.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.17 2011/11/14 00:25:17 mlarkin Exp $	*/
d108 1
a108 1
psize_t	 uvm_page_rle(paddr_t);
@


1.17
log
@

Use a fixed io_page for all hibernate I/O, which is needed for
ahci_hibernate_io, a skeleton of which is also provided in this diff.

This code is from deraadt@@. Tested on a few wd machines to ensure it works
there as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.16 2011/11/13 23:13:29 mlarkin Exp $	*/
d125 1
a125 1
		union hibernate_info *);
d129 2
a130 1
int	hibernate_read_chunks(union hibernate_info *, paddr_t, paddr_t, size_t);
@


1.16
log
@

Add some #defines for the various hibernate I/O modes, some of the
groundwork for *_hibernate_io functions other than wd_hibernate_io

These changes were sent to me by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.15 2011/11/13 22:36:27 mlarkin Exp $	*/
d93 1
@


1.15
log
@

In hibernate resume, free the piglet and other VAs we allocated during
suspend.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.14 2011/09/22 22:12:43 deraadt Exp $	*/
d68 3
@


1.14
log
@KNF of mlarkin's code, requested by him.  Some improvements to the interface
for talking to the disk driver snuck in.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.13 2011/09/21 02:51:23 mlarkin Exp $	*/
d128 1
@


1.13
log
@

Perform most of the remaining refactoring of hibernate code into
MI/MD parts. This also introduces a chunk placement routine that was
originally developed at c2k11 with help from drahn and ariane.

There are still a few more things to do for hibernate, but those can be
worked on in-tree. This code is disabled by default, and not yet called.

ok deraadt@@ (and deraadt@@ said kettenis@@ also ok'ed it :) )
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.12 2011/07/11 03:30:32 mlarkin Exp $	*/
a33 2
 * Hibernate allocator.
 *
d36 2
a37 4
struct hiballoc_arena
{
	RB_HEAD(hiballoc_addr, hiballoc_entry)
				hib_addrs;
a40 2
 * struct hibernate_zlib_state
 *
a48 2
 * struct hibernate_memory_range
 *
a56 2
 * struct hibernate_disk_chunk
 *
d62 1
a62 1
	paddr_t		end; 		/* End of chunk */		
d68 2
d71 1
a71 3
 * union hibernate_info
 *
 * Used to store information about the hibernation state of the machine, 
d77 1
a77 1
		size_t 				nranges;		
d89 1
a89 1
		int (*io_func)(dev_t, daddr_t, vaddr_t, size_t, int, void *);
d106 1
a106 1
void	*get_hibernate_io_function(void);
@


1.12
log
@

Add hibernate_read_block and fix a couple of typos in the previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.11 2011/07/09 03:10:27 mlarkin Exp $	*/
d45 1
a45 1
 * struct hibernate_state
d49 1
a49 1
struct hibernate_state {
d73 1
a73 1
	size_t		offset;		/* Abs. disk block locating chunk */
d87 12
a98 11
		size_t 		nranges;		
		size_t		image_size;
		size_t		chunk_ctr;
		u_int32_t	secsize;
		dev_t		device;
		daddr_t		swap_offset;
		daddr_t		sig_offset;
		daddr_t		image_offset;
		paddr_t		piglet_base;
		struct hibernate_memory_range ranges[VM_PHYSSEG_MAX];
		char		kernel_version[128];
d112 2
a113 1
int	 uvm_pmr_alloc_piglet(paddr_t*, psize_t, paddr_t);
d117 1
a117 1
int	get_hibernate_info(union hibernate_info *);
d119 1
d122 2
a123 2
void	hibernate_inflate(paddr_t, paddr_t, size_t);
size_t	hibernate_deflate(paddr_t, size_t *);
d127 2
d132 6
@


1.11
log
@

Call (temporarily, until we have RLE page encoding) uvm_pmr_zero_everything
on suspend to ensure we get good zlib compression.

Add MI signature block (hibernate_info) comparison routine
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.10 2011/07/09 01:30:39 mlarkin Exp $	*/
d122 1
@


1.10
log
@

Extract hibernate_write_signature and hibernate_clear_signature to the MI
hibernate code, and add chunk range overlap checking.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.9 2011/07/09 00:55:00 mlarkin Exp $	*/
d124 2
@


1.9
log
@

Extract MI pmap function hibernate_enter_resume_mapping, refactor old i386
resume pmap code to match.

Add hibernate deflater and inflater and cache flush routines.

Code is not presently called or automatically built.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.8 2011/07/09 00:27:31 mlarkin Exp $	*/
d121 5
@


1.8
log
@

Add zlib reset, alloc, and free functions for hibernate image compression
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.7 2011/07/09 00:08:04 mlarkin Exp $	*/
d119 2
@


1.7
log
@

Separate some MD and MI bits and a bit of refactoring to make subsequent
commits easier.

Work in progress, hibernate will still not work for you.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.6 2011/07/08 21:00:53 ariane Exp $	*/
d116 3
@


1.6
log
@Ensure all pages in pmemrange can be marked as dirty.
It'd be a very bad idea to hand out dirty pages as zeroed, just because
we came back from hibernate.

No callers at the moment, will be called on hibernate resume path.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.5 2011/07/08 18:34:46 ariane Exp $	*/
d24 6
d44 61
d113 3
@


1.5
log
@Put in RLE logic for hibernate compressor.

These have the potential to compress 1MB of physmem into 1 byte.
This works by noting the page is not in use and therefor skipping it.

Needed by mlarkin@@ for hibernate.  No callers yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.4 2011/07/08 18:31:16 ariane Exp $	*/
d42 1
@


1.4
log
@Change pig allocator to a highest-address selection.
Add piglet allocator, which does a lowest-address selection.

No callers yet, needed by mlarkin@@ for hibernate voodoo.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.3 2011/07/08 18:25:56 ariane Exp $	*/
d44 1
@


1.3
log
@Move uvm_pmr_alloc_pig to kern/subr_hibernate.c

No callers, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.2 2011/07/08 18:20:10 ariane Exp $	*/
d42 2
a43 1
int	 uvm_pmr_alloc_pig(paddr_t*, psize_t*);
@


1.2
log
@Move uvm_pmr_zero_everything() to subr_hibernate.

This function will probably die before ever being called
from the in-tree code, since hibernate will move to RLE encoding.

No functional change, function had no callers.
@
text
@d1 1
a1 1
/*	$OpenBSD: hibernate.h,v 1.1 2011/07/08 17:58:16 ariane Exp $	*/
d42 1
@


1.1
log
@Move hiballoc to hibernate.h, subr_hibernate.c
Next few commits will move other hibernate-specific functionality,
like the pig-allocator, to subr_hibernate.

No functional change, no callers either.
@
text
@d1 1
a1 1
/*	$OpenBSD: hiballoc.h,v 1.4 2011/07/06 19:42:49 ariane Exp $	*/
d41 1
@

