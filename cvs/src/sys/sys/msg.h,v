head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.14
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.12
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.8
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.15.0.4
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.10
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.6
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.13.0.14
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.12
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.10
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.8
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.6
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.6
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.4
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.9
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.14
	OPENBSD_2_8:1.5.0.12
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.10
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.8
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.6
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.4
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.11.23.04.31.42;	author guenther;	state Exp;
branches;
next	1.18;
commitid	xhzcNqQj4xO4dch4;

1.18
date	2012.02.05.18.30.32;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2012.02.05.18.12.10;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2011.01.03.23.08.07;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.09.10.40.17;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.16.12.35.37;	author blambert;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.15.11.24.46;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.14.23.45.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.14.23.40.27;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.12.10.21.30.09;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.28.01.42.54;	author millert;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.08.12.22.50.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	98.06.11.19.21.28;	author deraadt;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	98.06.11.18.32.21;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.05.11.06.22.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.02;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.5.8.1
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.7.4.3;

1.7.4.3
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@We now get <sys/cdefs.h> via <sys/ipc.h>
Only pull <sys/queue.h> into the kernel namespacem

ok deraadt@@
@
text
@/*	$OpenBSD: msg.h,v 1.18 2012/02/05 18:30:32 guenther Exp $	*/
/*	$NetBSD: msg.h,v 1.9 1996/02/09 18:25:18 christos Exp $	*/

/*
 * SVID compatible msg.h file
 *
 * Author:  Daniel Boulet
 *
 * Copyright 1993 Daniel Boulet and RTMX Inc.
 *
 * This system call was implemented by Daniel Boulet under contract from RTMX.
 *
 * Redistribution and use in source forms, with and without modification,
 * are permitted provided that this entire comment appears intact.
 *
 * Redistribution in binary form may occur without any restrictions.
 * Obviously, it would be nice if you gave credit where credit is due
 * but requiring it would be too onerous.
 *
 * This software is provided ``AS IS'' without any warranties of any kind.
 */

#ifndef _SYS_MSG_H_
#define _SYS_MSG_H_

#include <sys/ipc.h>

/*
 * The MSG_NOERROR identifier value, the msqid_ds struct and the msg struct
 * are as defined by the SV API Intel 386 Processor Supplement.
 */

#define MSG_NOERROR	010000		/* don't complain about too long msgs */

struct msqid_ds {
	struct ipc_perm	msg_perm;	/* msg queue permission bits */
	struct msg	*msg_first;	/* first message in the queue */
	struct msg	*msg_last;	/* last message in the queue */
	unsigned long	msg_cbytes;	/* number of bytes in use on the queue */
	unsigned long	msg_qnum;	/* number of msgs in the queue */
	unsigned long	msg_qbytes;	/* max # of bytes on the queue */
	pid_t		msg_lspid;	/* pid of last msgsnd() */
	pid_t		msg_lrpid;	/* pid of last msgrcv() */
	time_t		msg_stime;	/* time of last msgsnd() */
	long		msg_pad1;
	time_t		msg_rtime;	/* time of last msgrcv() */
	long		msg_pad2;
	time_t		msg_ctime;	/* time of last msgctl() */
	long		msg_pad3;
	long		msg_pad4[4];
};

#ifdef _KERNEL
#include <sys/queue.h>

struct msg {
	long		 msg_type;
	size_t		 msg_len;
	struct mbuf	*msg_data;

	TAILQ_ENTRY(msg)	msg_next;
};

struct que {
	struct msqid_ds	msqid_ds;
	int		que_ix;		/* pseudo-index */
	int		que_flags;
	int		que_references;

	TAILQ_ENTRY(que)	que_next;
	TAILQ_HEAD(, msg) que_msgs;
};

/* for que_flags */
#define	MSGQ_READERS	0x01
#define	MSGQ_WRITERS	0x02
#define	MSGQ_DYING	0x04

#define	QREF(q)	(q)->que_references++

#define QRELE(q) do {							\
	if (--(q)->que_references == 0 && (q)->que_flags & MSGQ_DYING)	\
		wakeup_one(&(q)->que_references);			\
} while (0)
#endif

/*
 * Structure describing a message.  The SVID doesn't suggest any
 * particular name for this structure.  There is a reference in the
 * msgop man page that reads "The structure mymsg is an example of what
 * this user defined buffer might look like, and includes the following
 * members:".  This sentence is followed by two lines equivalent
 * to the mtype and mtext field declarations below.  It isn't clear
 * if "mymsg" refers to the name of the structure type or the name of an
 * instance of the structure...
 */
struct mymsg {
	long	mtype;		/* message type (+ve integer) */
	char	mtext[1];	/* message body */
};


#ifdef _KERNEL
/*
 * Based on the configuration parameters described in an SVR2 (yes, two)
 * config(1m) man page.
 *
 * Each message is broken up and stored in segments that are msgssz bytes
 * long.  For efficiency reasons, this should be a power of two.  Also,
 * it doesn't make sense if it is less than 8 or greater than about 256.
 * Consequently, msginit in kern/sysv_msg.c checks that msgssz is a power of
 * two between 8 and 1024 inclusive (and panic's if it isn't).
 */
struct msginfo {
	int	msgmax,		/* max chars in a message */
		msgmni,		/* max message queue identifiers */
		msgmnb,		/* max chars in a queue */
		msgtql,		/* max messages in system */
		msgssz,		/* size of a message segment (see notes above) */
		msgseg;		/* number of message segments */
};
#ifdef SYSVMSG
extern struct msginfo	msginfo;
#endif

int sysctl_sysvmsg(int *, u_int, void *, size_t *);

struct msg_sysctl_info {
	struct msginfo msginfo;
	struct msqid_ds msgids[1];
};

#ifndef MSGSSZ
#define MSGSSZ	8		/* Each segment must be 2^N long */
#endif
#ifndef MSGSEG
#define MSGSEG	2048		/* must be less than 32767 */
#endif
#undef MSGMAX			/* ALWAYS compute MSGMAX! */
#define MSGMAX	(MSGSSZ*MSGSEG)
#ifndef MSGMNB
#define MSGMNB	2048		/* max # of bytes in a queue */
#endif
#ifndef MSGMNI
#define MSGMNI	40
#endif
#ifndef MSGTQL
#define MSGTQL	40
#endif

/*
 * macros to convert between msqid_ds's and msqid's.
 * XXX unused, going away
 */
#define MSQID(ix,ds)	((ix) & 0xffff | (((ds).msg_perm.seq << 16) & 0xffff0000))
#define MSQID_IX(id)	((id) & 0xffff)
#define MSQID_SEQ(id)	(((id) >> 16) & 0xffff)
#endif


#ifndef _KERNEL
__BEGIN_DECLS
int msgctl(int, int, struct msqid_ds *);
int msgget(key_t, int);
int msgsnd(int, const void *, size_t, int);
int msgrcv(int, void *, size_t, long, int);
__END_DECLS
#else
struct proc;

void	msginit(void);
int	msgctl1(struct proc *, int, int, caddr_t,
	    int (*)(const void *, void *, size_t),
	    int (*)(const void *, void *, size_t));
#endif /* !_KERNEL */

#endif /* !_SYS_MSG_H_ */
@


1.18
log
@Remove the extern declarations for the long-gone static msg queue
data structures

ok miod@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.17 2012/02/05 18:12:10 blambert Exp $	*/
a26 1
#include <sys/queue.h>
d54 2
a161 2
#include <sys/cdefs.h>

@


1.17
log
@Fix SysV message queue identifiers.

Found and diagnosed by Alexis Fouilhe hyjial at gmail dot com

input miod@@ guenther@@
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.16 2011/01/03 23:08:07 guenther Exp $	*/
d152 1
a152 1
 * (specific to this implementation)
a158 23
/*
 * The rest of this file is specific to this particular implementation.
 */

#ifdef _KERNEL

/*
 * Stuff allocated in machdep.h
 */
struct msgmap {
	short	next;		/* next segment in buffer */
    				/* -1 -> available */
    				/* 0..(MSGSEG-1) -> index of next segment */
};

extern char *msgpool;		/* MSGMAX byte long msg buffer pool */
extern struct msgmap *msgmaps;	/* MSGSEG msgmap structures */
extern struct msg *msghdrs;	/* MSGTQL msg headers */
extern struct msqid_ds *msqids;	/* MSGMNI msqid_ds struct's */

#define MSG_LOCKED	01000	/* Is this msqid_ds locked? */

#endif
@


1.16
log
@Remove the old COMPAT_23 SysV IPC structures and the never implemented
semconfig() declaration.  Move the COMPAT_35 SysV IPC structures into
the only source files that uses them

ok millert@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.15 2009/08/09 10:40:17 blambert Exp $	*/
d65 1
a65 1
	int		que_id;
@


1.15
log
@Rototill system V message queues.

No longer allocate a static amount of memory for messages in MD
boot path; message queues, message metadata, and message data now
all use dynamic memory, which means that runtime sysctls should now
be trivial to implement.

Since I'm going to be around all week to fix any breakage, this should
probably just go in now.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.14 2007/10/16 12:35:37 blambert Exp $	*/
a54 36
struct msqid_ds23 {
	struct ipc_perm23 msg_perm;	/* msg queue permission bits */
	struct msg	*msg_first;	/* first message in the queue */
	struct msg	*msg_last;	/* last message in the queue */
	unsigned long	msg_cbytes;	/* number of bytes in use on the queue */
	unsigned long	msg_qnum;	/* number of msgs in the queue */
	unsigned long	msg_qbytes;	/* max # of bytes on the queue */
	pid_t		msg_lspid;	/* pid of last msgsnd() */
	pid_t		msg_lrpid;	/* pid of last msgrcv() */
	time_t		msg_stime;	/* time of last msgsnd() */
	long		msg_pad1;
	time_t		msg_rtime;	/* time of last msgrcv() */
	long		msg_pad2;
	time_t		msg_ctime;	/* time of last msgctl() */
	long		msg_pad3;
	long		msg_pad4[4];
};

struct msqid_ds35 {
	struct ipc_perm35 msg_perm;	/* msg queue permission bits */
	struct msg	  *msg_first;	/* first message in the queue */
	struct msg	  *msg_last;	/* last message in the queue */
	unsigned long	  msg_cbytes;	/* number of bytes in use on queue */
	unsigned long	  msg_qnum;	/* number of msgs in the queue */
	unsigned long	  msg_qbytes;	/* max # of bytes on the queue */
	pid_t		  msg_lspid;	/* pid of last msgsnd() */
	pid_t		  msg_lrpid;	/* pid of last msgrcv() */
	time_t		  msg_stime;	/* time of last msgsnd() */
	long		  msg_pad1;
	time_t		  msg_rtime;	/* time of last msgrcv() */
	long		  msg_pad2;
	time_t		  msg_ctime;	/* time of last msgctl() */
	long		  msg_pad3;
	long		  msg_pad4[4];
};

@


1.14
log
@typo (naem -> name)

ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.13 2004/07/15 11:24:46 millert Exp $	*/
d27 1
a89 1
#endif
d92 15
a106 6
	struct msg	*msg_next;	/* next msg in the chain */
	long		msg_type;	/* type of this message */
    					/* >0 -> type of this message */
	    				/* 0 -> free header */
	unsigned short	msg_ts;		/* size of this message */
	short		msg_spot;	/* location of start of msg in buffer */
d109 13
d160 2
@


1.13
log
@Rename structs oipc_perm, omsqid_ds, osemid_ds, oshmid_ds to ipc_perm23,
etc to avoid confusion and for consistency with the *35 ones.
Remove *n2o functions that don't belong outside of compat.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.12 2004/07/14 23:45:11 millert Exp $	*/
d107 1
a107 1
 * if "mymsg" refers to the naem of the structure type or the name of an
@


1.12
log
@Because mode_t is used in struct ipc_perm we need new versions of
the msgctl, semctl, and shmctl system calls.  This moves the old
versions to COMPAT_35 and adds new ones.

WARNING: While this fixes things like shared memory in the X server
for old (pre-mode_t change) binaries, it will break binaries that
use shared memory built between the time of the mode_t change (Jul
13th) and now.  If you rebuild X during that interval you will need
to do it again after updating the rest of userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.11 2004/07/14 23:40:27 millert Exp $	*/
d54 2
a55 2
struct omsqid_ds {
	struct oipc_perm msg_perm;	/* msg queue permission bits */
a207 1
void	msqid_n2o(struct msqid_ds *, struct omsqid_ds *);
@


1.11
log
@Move the guts of the {sem,msg,shm}ctl system calls into a new function
which also takes two function pointers for copyin/copyout.  For the
real syscalls these are just the normal copyin/copyout functions.
For the compat routines, these are funtions that convert between
the new and old foo_ds structs automagically.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.10 2002/12/10 21:30:09 pvalchev Exp $	*/
d70 18
@


1.10
log
@fix a typo in a comment; from Gabriel
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.9 2002/07/03 21:19:08 miod Exp $	*/
d187 7
a193 2
void msginit(void);
void msqid_n2o(struct msqid_ds *, struct omsqid_ds *);
@


1.9
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.8 2002/03/14 01:27:14 millert Exp $	*/
d132 1
a132 1
#undef MSGMAX			/* ALWAYS compute MGSMAX! */
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.7 2001/09/28 01:42:54 millert Exp $	*/
d117 3
a119 1
struct msginfo	msginfo;	/* XXX */
@


1.7
log
@sysctl() support for getting the SYSV *info structs and the associated
SYSV structs.  To be used by ipcs(1).  Based on work by simonb@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.6 2001/08/12 22:50:12 millert Exp $	*/
d179 4
a182 4
int msgctl __P((int, int, struct msqid_ds *));
int msgget __P((key_t, int));
int msgsnd __P((int, const void *, size_t, int));
int msgrcv __P((int, void *, size_t, long, int));
d185 2
a186 2
void msginit __P((void));
void msqid_n2o __P((struct msqid_ds *, struct omsqid_ds *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.7 2001/09/28 01:42:54 millert Exp $	*/
d179 4
a182 4
int msgctl(int, int, struct msqid_ds *);
int msgget(key_t, int);
int msgsnd(int, const void *, size_t, int);
int msgrcv(int, void *, size_t, long, int);
d185 2
a186 2
void msginit(void);
void msqid_n2o(struct msqid_ds *, struct omsqid_ds *);
@


1.7.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.7.4.1 2002/06/11 03:32:33 art Exp $	*/
d117 1
a117 3
#ifdef SYSVMSG
extern struct msginfo	msginfo;
#endif
@


1.7.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
#undef MSGMAX			/* ALWAYS compute MSGMAX! */
@


1.6
log
@Don't allocate globals in include files, use extern declarations.
Move the actual variables into their respective .c files.
As a bonus, remove semmap which is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.5 1998/06/11 19:21:28 deraadt Exp $	*/
d117 6
a122 1
struct msginfo	msginfo;
@


1.5
log
@do not export old structures to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.4 1998/06/11 18:32:21 deraadt Exp $	*/
d161 4
a164 4
char *msgpool;			/* MSGMAX byte long msg buffer pool */
struct msgmap *msgmaps;		/* MSGSEG msgmap structures */
struct msg *msghdrs;		/* MSGTQL msg headers */
struct msqid_ds *msqids;	/* MSGMNI msqid_ds struct's */
@


1.5.8.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.5 1998/06/11 19:21:28 deraadt Exp $	*/
d117 1
a117 6
struct msginfo	msginfo;	/* XXX */

struct msg_sysctl_info {
	struct msginfo msginfo;
	struct msqid_ds msgids[1];
};
d161 4
a164 4
extern char *msgpool;		/* MSGMAX byte long msg buffer pool */
extern struct msgmap *msgmaps;	/* MSGSEG msgmap structures */
extern struct msg *msghdrs;	/* MSGTQL msg headers */
extern struct msqid_ds *msqids;	/* MSGMNI msqid_ds struct's */
@


1.5.8.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d179 4
a182 4
int msgctl(int, int, struct msqid_ds *);
int msgget(key_t, int);
int msgsnd(int, const void *, size_t, int);
int msgrcv(int, void *, size_t, long, int);
d185 2
a186 2
void msginit(void);
void msqid_n2o(struct msqid_ds *, struct omsqid_ds *);
@


1.5.8.3
log
@Sync the SMP branch with 3.3
@
text
@d117 1
a117 3
#ifdef SYSVMSG
extern struct msginfo	msginfo;
#endif
d130 1
a130 1
#undef MSGMAX			/* ALWAYS compute MSGMAX! */
@


1.4
log
@change ipc.h to use uid_t and friends, and then build compat system calls for the old ushort based ipc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.3 1998/05/11 06:22:19 deraadt Exp $	*/
d53 1
d71 1
@


1.3
log
@u_short -> unsigned short; const msgsnd msgp arg
@
text
@d1 1
a1 1
/*	$OpenBSD: msg.h,v 1.2 1996/03/03 12:12:02 niklas Exp $	*/
d53 18
d179 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 15
a50 15
	struct	ipc_perm msg_perm;	/* msg queue permission bits */
	struct	msg *msg_first;	/* first message in the queue */
	struct	msg *msg_last;	/* last message in the queue */
	u_long	msg_cbytes;	/* number of bytes in use on the queue */
	u_long	msg_qnum;	/* number of msgs in the queue */
	u_long	msg_qbytes;	/* max # of bytes on the queue */
	pid_t	msg_lspid;	/* pid of last msgsnd() */
	pid_t	msg_lrpid;	/* pid of last msgrcv() */
	time_t	msg_stime;	/* time of last msgsnd() */
	long	msg_pad1;
	time_t	msg_rtime;	/* time of last msgrcv() */
	long	msg_pad2;
	time_t	msg_ctime;	/* time of last msgctl() */
	long	msg_pad3;
	long	msg_pad4[4];
d54 6
a59 6
	struct	msg *msg_next;	/* next msg in the chain */
	long	msg_type;	/* type of this message */
    				/* >0 -> type of this message */
    				/* 0 -> free header */
	u_short	msg_ts;		/* size of this message */
	short	msg_spot;	/* location of start of msg in buffer */
d156 1
a156 1
int msgsnd __P((int, void *, size_t, int));
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: msg.h,v 1.8 1995/07/11 18:16:20 jtc Exp $	*/
d159 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
