head	1.33;
access;
symbols
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.2
	OPENBSD_5_0:1.11.0.2
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.9.0.20
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.18
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.14
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.16
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.12
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.5.0.4
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2016.10.08.02.16.43;	author guenther;	state Exp;
branches;
next	1.32;
commitid	MFxpqYD0syIKuFdZ;

1.32
date	2016.09.01.08.31.15;	author tom;	state Exp;
branches;
next	1.31;
commitid	znvEsdIzy7nto5hj;

1.31
date	2016.06.18.17.39.44;	author guenther;	state Exp;
branches;
next	1.30;
commitid	fiFJZgAg2MV43NwJ;

1.30
date	2016.06.07.06.12.37;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	3b5aikHetmWeZowP;

1.29
date	2016.03.06.20.25.26;	author guenther;	state Exp;
branches;
next	1.28;
commitid	PPKYgV5KWXY1sNxp;

1.28
date	2015.12.17.16.57.21;	author tedu;	state Exp;
branches;
next	1.27;
commitid	RrVbaJSRZIO3MZ6E;

1.27
date	2015.12.06.17.50.21;	author deraadt;	state Exp;
branches;
next	1.26;
commitid	fXd8HOPcFESXsWp4;

1.26
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.25;
commitid	SIwCBDJKKae61tEi;

1.25
date	2015.10.02.05.07.41;	author guenther;	state Exp;
branches;
next	1.24;
commitid	m4jkpHQAAdeQKWoV;

1.24
date	2015.09.07.15.38.45;	author guenther;	state Exp;
branches;
next	1.23;
commitid	P4QdNgT9HBzXxQ5B;

1.23
date	2015.07.28.05.50.41;	author guenther;	state Exp;
branches;
next	1.22;
commitid	6ofl1o2NCJLJenZf;

1.22
date	2015.07.19.04.45.25;	author guenther;	state Exp;
branches;
next	1.21;
commitid	ZlSuHVkn9uJBlE0T;

1.21
date	2014.10.13.03.46.33;	author guenther;	state Exp;
branches;
next	1.20;
commitid	GfyJFt2AC6kVCsla;

1.20
date	2014.07.08.23.31.22;	author deraadt;	state Exp;
branches;
next	1.19;
commitid	3An6VhB3KqpFYVig;

1.19
date	2014.03.26.05.23.42;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2014.01.24.04.26.51;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.14.02.28.02;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.01.09.49.52;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.09.17.51.08;	author claudio;	state Exp;
branches;
next	1.14;

1.14
date	2012.04.10.20.39.37;	author mikeb;	state Exp;
branches;
next	1.13;

1.13
date	2012.03.19.09.05.39;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2011.07.08.19.28.38;	author otto;	state Exp;
branches;
next	1.10;

1.10
date	2011.06.02.16.19.12;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.17.02.11.25;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.02.22.19.19.31;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.07.04.21.54.27;	author espie;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.11.10.18.15.49;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.20.10.03.41;	author art;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.11.54;	author niklas;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches;
next	;

1.2.16.1
date	2001.05.14.22.45.02;	author niklas;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.2.16.4;

1.2.16.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.2.16.5;

1.2.16.5
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	;

1.5.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Add ktracing of the fds returned by pipe() and socketpair()

ok deraadt@@
@
text
@/*	$OpenBSD: ktrace.h,v 1.32 2016/09/01 08:31:15 tom Exp $	*/
/*	$NetBSD: ktrace.h,v 1.12 1996/02/04 02:12:29 christos Exp $	*/

/*
 * Copyright (c) 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ktrace.h	8.1 (Berkeley) 6/2/93
 */

#include <sys/uio.h>

/*
 * operations to ktrace system call  (KTROP(op))
 */
#define KTROP_SET		0	/* set trace points */
#define KTROP_CLEAR		1	/* clear trace points */
#define KTROP_CLEARFILE		2	/* stop all tracing to file */
#define	KTROP(o)		((o)&3)	/* macro to extract operation */
/*
 * flags (ORed in with operation)
 */
#define KTRFLAG_DESCEND		4	/* perform op on all children too */

/*
 * ktrace record header
 */
struct ktr_header {
	uint	ktr_type;		/* trace record type */
	pid_t	ktr_pid;		/* process id */
	pid_t	ktr_tid;		/* thread id */
	struct	timespec ktr_time;	/* timestamp */
	char	ktr_comm[MAXCOMLEN+1];	/* command name */
	size_t	ktr_len;		/* length of buf */
};

/*
 * ktrace record types
 */

 /*
 * KTR_START - start of trace record, one per ktrace(KTROP_SET) syscall
 */
#define KTR_START	0x4b545200	/* "KTR" */

/*
 * KTR_SYSCALL - system call record
 */
#define KTR_SYSCALL	1
struct ktr_syscall {
	int	ktr_code;		/* syscall number */
	int	ktr_argsize;		/* size of arguments */
	/*
	 * followed by ktr_argsize/sizeof(register_t) "register_t"s
	 */
};

/*
 * KTR_SYSRET - return from system call record
 */
#define KTR_SYSRET	2
struct ktr_sysret {
	int	ktr_code;
	int	ktr_error;
	/*
	 * If ktr_error is zero, then followed by retval: register_t for
	 * all syscalls except lseek(), which uses long long
	 */
};

/*
 * KTR_NAMEI - namei record
 */
#define KTR_NAMEI	3
	/* record contains pathname */

/*
 * KTR_GENIO - trace generic process i/o
 */
#define KTR_GENIO	4
struct ktr_genio {
	int	ktr_fd;
	enum	uio_rw ktr_rw;
	/*
	 * followed by data successfully read/written
	 */
};

/*
 * KTR_PSIG - trace processed signal
 */
#define	KTR_PSIG	5
struct ktr_psig {
	int	signo;
	sig_t	action;
	int	mask;
	int	code;
	siginfo_t si;
};

/*
 * KTR_STRUCT - misc. structs
 */
#define KTR_STRUCT	8
	/*
	 * record contains null-terminated struct name followed by
	 * struct contents
	 */
struct sockaddr;
struct stat;

/*
 * KTR_USER - user record
 */
#define KTR_USER	9
#define KTR_USER_MAXIDLEN	20
#define KTR_USER_MAXLEN		2048	/* maximum length of passed data */
struct ktr_user {
	char    ktr_id[KTR_USER_MAXIDLEN];      /* string id of caller */
	/*
	 * Followed by ktr_len - sizeof(struct ktr_user) of user data.
	 */
};

/*
 * KTR_EXECARGS and KTR_EXECENV - args and evironment records
 */
#define KTR_EXECARGS	10
#define KTR_EXECENV	11


/*
 * KTR_PLEDGE - details of pledge violation
 */
#define	KTR_PLEDGE	12
struct ktr_pledge {
	int	error;
	int	syscall;
	int64_t	code;
};

/*
 * kernel trace points (in p_traceflag)
 */
#define KTRFAC_MASK	0x00ffffff
#define KTRFAC_SYSCALL	(1<<KTR_SYSCALL)
#define KTRFAC_SYSRET	(1<<KTR_SYSRET)
#define KTRFAC_NAMEI	(1<<KTR_NAMEI)
#define KTRFAC_GENIO	(1<<KTR_GENIO)
#define	KTRFAC_PSIG	(1<<KTR_PSIG)
#define KTRFAC_STRUCT   (1<<KTR_STRUCT)
#define KTRFAC_USER	(1<<KTR_USER)
#define KTRFAC_EXECARGS	(1<<KTR_EXECARGS)
#define KTRFAC_EXECENV	(1<<KTR_EXECENV)
#define	KTRFAC_PLEDGE	(1<<KTR_PLEDGE)

/*
 * trace flags (also in p_traceflags)
 */
#define KTRFAC_ROOT	0x80000000	/* root set this trace */
#define KTRFAC_INHERIT	0x40000000	/* pass trace flags to children */

#ifndef	_KERNEL

#include <sys/cdefs.h>

__BEGIN_DECLS
int	ktrace(const char *, int, int, pid_t);
int	utrace(const char *, const void *, size_t);
__END_DECLS

#else

/*
 * Test for kernel trace point
 */
#define KTRPOINT(p, type)	\
	((p)->p_p->ps_traceflag & (1<<(type)) && ((p)->p_flag & P_INKTR) == 0)

void ktrgenio(struct proc *, int, enum uio_rw, struct iovec *, ssize_t);
void ktrnamei(struct proc *, char *);
void ktrpsig(struct proc *, int, sig_t, int, int, siginfo_t *);
void ktrsyscall(struct proc *, register_t, size_t, register_t []);
void ktrsysret(struct proc *, register_t, int, const register_t [2]);
int ktruser(struct proc *, const char *, const void *, size_t);
void ktrexec(struct proc *, int, const char *, ssize_t);
void ktrpledge(struct proc *, int, uint64_t, int);

void ktrcleartrace(struct process *);
void ktrsettrace(struct process *, int, struct vnode *, struct ucred *);

void    ktrstruct(struct proc *, const char *, const void *, size_t);
#define ktrsockaddr(p, s, l) \
	ktrstruct((p), "sockaddr", (s), (l))
#define ktrstat(p, s) \
	ktrstruct((p), "stat", (s), sizeof(struct stat))
#define ktrabstimespec(p, s) \
	ktrstruct((p), "abstimespec", (s), sizeof(struct timespec))
#define ktrreltimespec(p, s) \
	ktrstruct((p), "reltimespec", (s), sizeof(struct timespec))
#define ktrabstimeval(p, s) \
	ktrstruct((p), "abstimeval", (s), sizeof(struct timeval))
#define ktrreltimeval(p, s) \
	ktrstruct((p), "reltimeval", (s), sizeof(struct timeval))
#define ktrsigaction(p, s) \
	ktrstruct((p), "sigaction", (s), sizeof(struct sigaction))
#define ktrrlimit(p, s) \
	ktrstruct((p), "rlimit", (s), sizeof(struct rlimit))
#define ktrrusage(p, s) \
	ktrstruct((p), "rusage", (s), sizeof(struct rusage))
#define ktrfdset(p, s, l) \
	ktrstruct((p), "fdset", (s), l)
#define ktrquota(p, s) \
	ktrstruct((p), "quota", (s), sizeof(struct dqblk))
#define ktrmsghdr(p, s) \
	ktrstruct(p, "msghdr", s, sizeof(struct msghdr))
#define ktriovec(p, s, count) \
	ktrstruct(p, "iovec", s, (count) * sizeof(struct iovec))
#define ktrcmsghdr(p, c, len) \
	ktrstruct(p, "cmsghdr", c, len)
#define ktrevent(p, kev, count) \
	ktrstruct(p, "kevent", kev, (count) * sizeof(struct kevent))
#define ktrpollfd(p, pfd, count) \
	ktrstruct(p, "pollfd", pfd, (count) * sizeof(struct pollfd))
#define ktrfds(p, fds, count) \
	ktrstruct(p, "fds", fds, (count) * sizeof(int))

#endif	/* !_KERNEL */
@


1.32
log
@Remove last mention of nonexistent ktr_kuser()

From Michal Mazurek <akfaew at jasminek dot net>

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.31 2016/06/18 17:39:44 guenther Exp $	*/
d249 2
@


1.31
log
@KTRPOINT() is only useful in the kernel, so move it behind #ifdef _KERNEL

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.30 2016/06/07 06:12:37 deraadt Exp $	*/
a208 1
void ktr_kuser(const char *, void *, size_t);
@


1.30
log
@ktrace support for pollfd[] arrays
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.29 2016/03/06 20:25:26 guenther Exp $	*/
a61 6
 * Test for kernel trace point
 */
#define KTRPOINT(p, type)	\
	((p)->p_p->ps_traceflag & (1<<(type)) && ((p)->p_flag & P_INKTR) == 0)

/*
d197 6
@


1.29
log
@No more compat emulations, so remove ktrace EMUL records and the baggage
for generating and parsing them.

ok mpi@@ naddy@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.28 2015/12/17 16:57:21 tedu Exp $	*/
d248 2
@


1.28
log
@add ktrace to kevent. ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.27 2015/12/06 17:50:21 deraadt Exp $	*/
a131 6
 * KTR_EMUL - emulation change
 */
#define KTR_EMUL	7
	/* record contains emulation name */

/*
a180 1
#define KTRFAC_EMUL	(1<<KTR_EMUL)
a203 1
void ktremul(struct proc *);
@


1.27
log
@Change kernel internal pledge variables to 64bit (to prepare for more
extensions).  This change is exposed in ktrace.out files
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.26 2015/10/25 20:39:54 deraadt Exp $	*/
d254 2
@


1.26
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.25 2015/10/02 05:07:41 guenther Exp $	*/
a173 1
	int	code;
d175 1
d220 1
a220 1
void ktrpledge(struct proc *, int, int, int);
@


1.25
log
@Add ktracing of argv and envp to execve(2), with envp not traced by default

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.24 2015/09/07 15:38:45 guenther Exp $	*/
d169 10
d192 1
d220 1
@


1.24
log
@Delete ktracing of context switches: it's unused, and not particularly useful,
and doing VOP_WRITE() from inside tsleep/msleep makes the locking too
complicated, making it harder to move forward on MP changes.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.23 2015/07/28 05:50:41 guenther Exp $	*/
d162 7
d180 2
d208 1
@


1.23
log
@Add ktracing of structs iovec, msghdr, and cmsghdr for {,p}{read,write}v(),
sendmsg(), and recvmsg().  For cmsghdr, the len, level, and type are always
shown, and for SOL_SOCKET,SCM_RIGHTS the fd numbers being passed are shown.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.22 2015/07/19 04:45:25 guenther Exp $	*/
a131 9
 * KTR_CSW - trace context switches
 */
#define KTR_CSW		6
struct ktr_csw {
	int	out;	/* 1 if switch out, 0 if switch in */
	int	user;	/* 1 if usermode (ivcsw), 0 if kernel (vcsw) */
};

/*
a169 1
#define KTRFAC_CSW	(1<<KTR_CSW)
a190 1
void ktrcsw(struct proc *, int, int);
@


1.22
log
@Make KTR_SYSRET records variables variables sized, leaving out the
retval on error, including a long long retval on successful lseek(),
and including a register_t retval for other successes.  This fixes
lseek reporting on ILP32 archs.

While here, reworking internal kern_ktrace.c bits to be able to pass
two buffers to ktrwriteraw(), so we can avoid mallocing a buffer
in some cases and so that KTR_GENIO logs are split at PAGE_SIZE,
not PAGE_SIZE-sizeof(struct ktrgenio)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.21 2014/10/13 03:46:33 guenther Exp $	*/
d237 6
@


1.21
log
@Add dumping of struct dqblk done by quotactl(2)

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.20 2014/07/08 23:31:22 deraadt Exp $	*/
d93 1
a93 2
	short	ktr_code;
	short	ktr_eosys;
d95 4
a98 1
	register_t ktr_retval;
d207 1
a207 1
void ktrsysret(struct proc *, register_t, int, register_t);
@


1.20
log
@sys/user.h can now be substantially gutted.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.19 2014/03/26 05:23:42 guenther Exp $	*/
d233 2
@


1.19
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.18 2014/01/24 04:26:51 guenther Exp $	*/
d34 2
@


1.18
log
@exit1() needs to do a final aggregation of the thread's [us]ticks
and runtime to the process totals.  Also, add ktracing of struct
rusage in wait4() and getrusage().

problem pointed out by tedu@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.17 2013/09/14 02:28:02 guenther Exp $	*/
d198 1
a198 1
void ktremul(struct proc *, char *);
@


1.17
log
@Correct the handling of I/O of >=2^32 bytes and the ktracing there of
by using size_t/ssize_t instead of int/u_int to handle I/O lengths in
uiomove(), vn_fsizechk(), and ktrgenio().  Eliminate the always-zero
'error' argument to ktrgenio() at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.16 2013/06/01 09:49:52 miod Exp $	*/
d227 2
@


1.16
log
@Add utrace(2), a system call allowing for userland to send its own ktrace
records. From FreeBSD via otto@@, with tweaks suggested by guenther@@.
Commite on behalf of otto@@ who is not around, to ride the libc minor bump.
Causes a librthread minor bump as well (new syscall).
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.15 2012/07/09 17:51:08 claudio Exp $	*/
d199 1
a199 1
void ktrgenio(struct proc *, int, enum uio_rw, struct iovec *, int, int);
@


1.15
log
@Print the fd_set used by select in kdump.
OK guenther@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.14 2012/04/10 20:39:37 mikeb Exp $	*/
d154 13
d178 1
d192 1
d204 2
@


1.14
log
@Add a start record to the ktrace and use a special magic string "KTR"
to identify ktrace files.  kdump(1) will now refuse to operate on
trace data without the start record and as a bonus will print only
PID, unless an -H flag is specified to print PID/TID pairs.  Initial
diff, input from and ok deraadt, guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.13 2012/03/19 09:05:39 guenther Exp $	*/
d210 2
@


1.13
log
@Add tracing and dumping of "pointer to struct" syscall arguments for
structs timespec, timeval, sigaction, and rlimit.

ok otto@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.12 2011/12/14 07:32:16 guenther Exp $	*/
d51 1
a51 1
	size_t	ktr_len;		/* length of buf */
d53 2
d56 1
a56 3
	short	ktr_type;		/* trace record type */
	struct	timeval ktr_time;	/* timestamp */
	caddr_t	ktr_buf;
d68 5
@


1.12
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.11 2011/07/08 19:28:38 otto Exp $	*/
d193 12
a204 1

@


1.11
log
@Support sending struct info to kdump. So far for struct stat and
struct sockaddress; mostly from freebsd. ok deraadt@@ tedu@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.10 2011/06/02 16:19:12 deraadt Exp $	*/
d63 1
a63 1
	(((p)->p_traceflag & ((1<<(type))|KTRFAC_ACTIVE)) == (1<<(type)))
a165 1
#define KTRFAC_ACTIVE	0x20000000	/* ktrace logging in progress, ignore */
d185 2
a186 1
void ktrsettracevnode(struct proc *, struct vnode *);
@


1.10
log
@Change ktr_retval to a register_t so that we can see the full 64-bits
when neccesary.  It is incredible this 64-bit bug has existed for
this long.
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.9 2006/05/17 02:11:25 tedu Exp $	*/
d137 10
d159 2
d187 7
@


1.9
log
@change ktr_len to size_t.  put ktr_type after comm for better alignment
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.8 2003/06/02 23:28:21 millert Exp $	*/
d89 1
a89 1
	int	ktr_retval;
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.7 2002/03/14 01:27:14 millert Exp $	*/
d51 1
a51 2
	int	ktr_len;		/* length of buf */
	short	ktr_type;		/* trace record type */
d54 1
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.6 2002/02/22 19:19:31 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@include a siginfo_t with ktrace PSIG information, so that kdump can print
fault addresses and other information. (a small bug exists: in some signal
delivery cases, two PSIG records may be inserted, because postsig() is
unaware a PSIG record has already been placed.  but this small bug can
stay since the siginfo_t information helps us find and fix other bugs)
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.5 2001/07/04 21:54:27 espie Exp $	*/
d165 1
a165 1
int	ktrace __P((const char *, int, int, pid_t));
d170 7
a176 7
void ktrcsw __P((struct proc *, int, int));
void ktremul __P((struct proc *, char *));
void ktrgenio __P((struct proc *, int, enum uio_rw, struct iovec *, int, int));
void ktrnamei __P((struct proc *, char *));
void ktrpsig __P((struct proc *, int, sig_t, int, int, siginfo_t *));
void ktrsyscall __P((struct proc *, register_t, size_t, register_t []));
void ktrsysret __P((struct proc *, register_t, int, register_t));
d178 1
a178 1
void ktrsettracevnode __P((struct proc *, struct vnode *));
@


1.5
log
@ktrace.h looks better with an EOL at EOF...
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.4 2000/11/10 18:15:49 art Exp $	*/
d123 1
d141 1
d174 1
a174 1
void ktrpsig __P((struct proc *, int, sig_t, int, int));
@


1.5.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.5 2001/07/04 21:54:27 espie Exp $	*/
a122 1
	siginfo_t si;
a139 1

d163 1
a163 1
int	ktrace(const char *, int, int, pid_t);
d168 7
a174 7
void ktrcsw(struct proc *, int, int);
void ktremul(struct proc *, char *);
void ktrgenio(struct proc *, int, enum uio_rw, struct iovec *, int, int);
void ktrnamei(struct proc *, char *);
void ktrpsig(struct proc *, int, sig_t, int, int, siginfo_t *);
void ktrsyscall(struct proc *, register_t, size_t, register_t []);
void ktrsysret(struct proc *, register_t, int, register_t);
d176 1
a176 1
void ktrsettracevnode(struct proc *, struct vnode *);
@


1.4
log
@Change the ktrace interface functions from taking the trace vnode to taking the
traced proc. The vnode is in the proc and all functions need the proc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.3 2000/04/20 10:03:41 art Exp $	*/
d178 1
a178 1
#endif	/* !_KERNEL */@


1.3
log
@Add a function "ktrsettracevnode", that changes the ktrace vnode for a process
in a correct way. Use it in all places where the vnode was changed.
(most of the earlier code was incorrect and had races).
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.2 1996/03/03 12:11:54 niklas Exp $	*/
d168 7
a174 7
void ktrcsw __P((struct vnode *, int, int));
void ktremul __P((struct vnode *, char *));
void ktrgenio __P((struct vnode *, int, enum uio_rw, struct iovec *, int, int));
void ktrnamei __P((struct vnode *, char *));
void ktrpsig __P((struct vnode *, int, sig_t, int, int));
void ktrsyscall __P((struct vnode *, register_t, size_t, register_t []));
void ktrsysret __P((struct vnode *, register_t, int, register_t));
d178 1
a178 1
#endif	/* !_KERNEL */
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 2
@


1.2.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.4 2000/11/10 18:15:49 art Exp $	*/
d168 7
a174 7
void ktrcsw __P((struct proc *, int, int));
void ktremul __P((struct proc *, char *));
void ktrgenio __P((struct proc *, int, enum uio_rw, struct iovec *, int, int));
void ktrnamei __P((struct proc *, char *));
void ktrpsig __P((struct proc *, int, sig_t, int, int));
void ktrsyscall __P((struct proc *, register_t, size_t, register_t []));
void ktrsysret __P((struct proc *, register_t, int, register_t));
d176 1
a176 3
void ktrsettracevnode __P((struct proc *, struct vnode *));

#endif	/* !_KERNEL */@


1.2.16.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.2.16.1 2001/05/14 22:45:02 niklas Exp $	*/
d178 1
a178 1
#endif	/* !_KERNEL */
@


1.2.16.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a122 1
	siginfo_t si;
a139 1

d172 1
a172 1
void ktrpsig __P((struct proc *, int, sig_t, int, int, siginfo_t *));
@


1.2.16.4
log
@Merge in -current from roughly a week ago
@
text
@d165 1
a165 1
int	ktrace(const char *, int, int, pid_t);
d170 7
a176 7
void ktrcsw(struct proc *, int, int);
void ktremul(struct proc *, char *);
void ktrgenio(struct proc *, int, enum uio_rw, struct iovec *, int, int);
void ktrnamei(struct proc *, char *);
void ktrpsig(struct proc *, int, sig_t, int, int, siginfo_t *);
void ktrsyscall(struct proc *, register_t, size_t, register_t []);
void ktrsysret(struct proc *, register_t, int, register_t);
d178 1
a178 1
void ktrsettracevnode(struct proc *, struct vnode *);
@


1.2.16.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ktrace.h,v 1.2.16.4 2002/03/28 14:52:01 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: ktrace.h,v 1.11 1995/07/19 15:27:05 christos Exp $	*/
d165 10
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
