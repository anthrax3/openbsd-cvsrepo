head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.2
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.6
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.4
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.2
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.2
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.12
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.10
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.8
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.6
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.10
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.8
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.18
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2016.08.23.23.28.02;	author tedu;	state Exp;
branches;
next	1.37;
commitid	nIfbjtBCGXU5qzrs;

1.37
date	2016.04.26.09.13.05;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	cl3fDEhVe8vpqLtU;

1.36
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.35;
commitid	AL2KSeDZVXs2nAYI;

1.35
date	2015.08.28.04.38.47;	author guenther;	state Exp;
branches;
next	1.34;
commitid	plAZIJHa0HKzn8y4;

1.34
date	2014.11.18.15.16.35;	author mikeb;	state Exp;
branches;
next	1.33;
commitid	54Id852RoRTD5kuV;

1.33
date	2014.11.18.02.00.29;	author tedu;	state Exp;
branches;
next	1.32;
commitid	ZB9SQWNINYlHBLCN;

1.32
date	2014.07.10.14.33.18;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	54aTzaIC9CSX2Pb4;

1.31
date	2013.06.05.01.26.00;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2012.05.01.03.43.23;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2011.06.28.10.15.38;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.04.00.24.01;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.26.17.47.10;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.06.20.51.35;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2003.08.01.22.54.06;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.18.23.02.58;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.16.16.16.52;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.02.05.16.02.27;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.31.01.36.18;	author art;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.10.26.12.03.28;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.15.09.00.19;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.14.12.38.46;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.20.54.35;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.16.20.02.20;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.24.15.14.59;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.20.06.32.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.19.08.34.50;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.01.04.00.50;	author assar;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	98.03.01.19.33.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.27.14.47.06;	author shawn;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.11.46;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.45.02;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.11.00.20;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2004.02.19.11.01.33;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.38
log
@rename nfiles to numfiles to avoid shadowing and stretch out the name.
ok deraadt
@
text
@/*	$OpenBSD: file.h,v 1.37 2016/04/26 09:13:05 deraadt Exp $	*/
/*	$NetBSD: file.h,v 1.11 1995/03/26 20:24:13 jtc Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)file.h	8.2 (Berkeley) 8/20/94
 */

#include <sys/fcntl.h>

#ifdef _KERNEL
#include <sys/queue.h>

struct proc;
struct uio;
struct knote;
struct stat;
struct file;
struct ucred;

struct	fileops {
	int	(*fo_read)(struct file *, off_t *, struct uio *,
		    struct ucred *);
	int	(*fo_write)(struct file *, off_t *, struct uio *,
		    struct ucred *);
	int	(*fo_ioctl)(struct file *, u_long, caddr_t,
		    struct proc *);
	int	(*fo_poll)(struct file *, int, struct proc *);
	int	(*fo_kqfilter)(struct file *, struct knote *);
	int	(*fo_stat)(struct file *, struct stat *, struct proc *);
	int	(*fo_close)(struct file *, struct proc *);
};

/*
 * Kernel descriptor table.
 * One entry for each open kernel vnode and socket.
 */
struct file {
	LIST_ENTRY(file) f_list;/* list of active files */
	short	f_flag;		/* see fcntl.h */
#define	DTYPE_VNODE	1	/* file */
#define	DTYPE_SOCKET	2	/* communications endpoint */
#define	DTYPE_PIPE	3	/* pipe */
#define	DTYPE_KQUEUE	4	/* event queue */
	short	f_type;		/* descriptor type */
	long	f_count;	/* reference count */
	struct	ucred *f_cred;	/* credentials associated with descriptor */
	struct	fileops *f_ops;
	off_t	f_offset;
	void 	*f_data;	/* private data */
	int	f_iflags;	/* internal flags */
	u_int64_t f_rxfer;	/* total number of read transfers */
	u_int64_t f_wxfer;	/* total number of write transfers */
	u_int64_t f_seek;	/* total independent seek operations */
	u_int64_t f_rbytes;	/* total bytes read */
	u_int64_t f_wbytes;	/* total bytes written */
};

#define FIF_HASLOCK		0x01	/* descriptor holds advisory lock */
#define FIF_LARVAL		0x02	/* not fully constructed, don't use */

#define FILE_IS_USABLE(fp) \
	(((fp)->f_iflags & FIF_LARVAL) == 0)

#define FREF(fp)	do { (fp)->f_count++; } while (0)
#define FRELE(fp,p)	(--(fp)->f_count == 0 ? fdrop(fp, p) : 0)

#define FILE_SET_MATURE(fp,p) do {				\
	(fp)->f_iflags &= ~FIF_LARVAL;				\
	FRELE(fp, p);						\
} while (0)

int	fdrop(struct file *, struct proc *);

LIST_HEAD(filelist, file);
extern struct filelist filehead;	/* head of list of open files */
extern int maxfiles;			/* kernel limit on number of open files */
extern int numfiles;			/* actual number of open files */
extern struct fileops vnops;		/* vnode operations for files */

#endif /* _KERNEL */
@


1.37
log
@No good reason to retain comments about old DTYPE_CRYPTO or DTYPE_SYSTRACE
values.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.36 2016/04/25 20:18:31 tedu Exp $	*/
d104 1
a104 1
extern int nfiles;			/* actual number of open files */
@


1.36
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.35 2015/08/28 04:38:47 guenther Exp $	*/
a70 2
/* was define	DTYPE_CRYPTO	5 */
/* was define	DTYPE_SYSTRACE	6 */
@


1.35
log
@Rework the UNIX domain socket garbage collector, including ideas from
{Free,Net}BSD
 - when a socket is closed with fds in its input, defer closing them to
   a task to avoid recursing.  This eliminates the complicated extra
   reference taking which had a 37 line(!) comment explanation
 - move flags, counts, and links only needed for this from struct file to
   struct unpcb
 - document the flow of the mark/sweep collector

much help from claudio@@ who made me explain the GC to him until we trusted it
ok claudio@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.34 2014/11/18 15:16:35 mikeb Exp $	*/
d72 1
a72 1
#define	DTYPE_SYSTRACE	6	/* system call tracing */
@


1.34
log
@DTYPE_CRYPTO is not used anymore;  ok guenther (a while ago)
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.33 2014/11/18 02:00:29 tedu Exp $	*/
a74 1
	long	f_msgcount;	/* references from message queue */
a88 2
#define FIF_MARK		0x04	/* mark during gc() */
#define FIF_DEFER		0x08	/* defer for next gc() pass */
@


1.33
log
@file.h doesn't need to include unistd.h
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.32 2014/07/10 14:33:18 deraadt Exp $	*/
d71 1
a71 1
#define	DTYPE_CRYPTO	5	/* crypto */
@


1.32
log
@struct ucred; for fstat _KERNEL block
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.31 2013/06/05 01:26:00 guenther Exp $	*/
a35 1
#include <sys/unistd.h>
@


1.31
log
@Move FHASLOCK from f_flag to f_iflags, freeing up a bit for passing
O_* flags and eliminating an XXX comment.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.30 2012/05/01 03:43:23 guenther Exp $	*/
d46 1
@


1.30
log
@Eliminate the f_usecount ref count in struct file; instead of sleeping
at the top of closef() until all in-progress calls finish, just do the
advisory locking bits required of close() by POSIX and let whichever
thread has the last reference do the call to the file's fo_close()
method and the final cleanup.

lots of discussion with deraadt@@ and others; worked out with and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.29 2012/04/22 05:43:14 guenther Exp $	*/
d88 1
@


1.29
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.28 2011/06/28 10:15:38 thib Exp $	*/
a80 1
	int	f_usecount;	/* number of users (temporary references). */
a87 1
#define FIF_WANTCLOSE		0x01	/* a close is waiting for usecount */
d93 1
a93 1
	(((fp)->f_iflags & (FIF_WANTCLOSE|FIF_LARVAL)) == 0)
d95 2
a96 6
#define FREF(fp) do { (fp)->f_usecount++; } while (0)
#define FRELE(fp,p) do {					\
	--(fp)->f_usecount;					\
	if (((fp)->f_iflags & FIF_WANTCLOSE) != 0)		\
		wakeup(&(fp)->f_usecount);			\
} while (0)
d102 2
@


1.28
log
@Rename FMARK to FIF_MARK and FDEFER to FIF_DEFER and
move those flags to f_iflags; This makes rooms in the
flag member of struct file for some goodies matthew@@
as planned.

ok matthew@@, deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.27 2010/07/19 23:00:15 guenther Exp $	*/
d98 1
a98 1
#define FRELE(fp) do {					\
d104 1
a104 1
#define FILE_SET_MATURE(fp) do {				\
d106 1
a106 1
	FRELE(fp);						\
@


1.27
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.26 2010/03/24 23:18:17 tedu Exp $	*/
d91 2
@


1.26
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.25 2009/06/04 00:24:01 blambert Exp $	*/
a108 1
extern struct rwlock fileheadlk;
@


1.25
log
@Put readv/writev changes back in, as they no longer hang ckuethe's ntpd.

Special thanks to ckuethe's ntpd for noticing the problem.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.24 2006/03/26 17:47:10 mickey Exp $	*/
d109 1
@


1.24
log
@do per file io accounting and show that in fstat as well; pedro@@ marco@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.23 2003/09/23 16:51:13 millert Exp $	*/
a111 5

int     dofileread(struct proc *, int, struct file *, void *, size_t,
            off_t *, register_t *);
int     dofilewrite(struct proc *, int, struct file *, const void *,
            size_t, off_t *, register_t *);
@


1.23
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.22 2003/08/06 20:51:35 deraadt Exp $	*/
d82 5
@


1.22
log
@must pre-def struct file before circular structs
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.21 2003/08/01 22:54:06 tedu Exp $	*/
d54 1
a54 1
	int	(*fo_select)(struct file *, int, struct proc *);
@


1.21
log
@move fileops out of file, and make it pretty.  ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.20 2003/07/18 23:02:58 tedu Exp $	*/
d45 1
@


1.20
log
@caddr_t -> void *.  ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.19 2003/06/02 23:28:21 millert Exp $	*/
d46 13
d76 1
a76 17
	struct	fileops {
		int	(*fo_read)(struct file *fp, off_t *, 
					     struct uio *uio,
					     struct ucred *cred);
		int	(*fo_write)(struct file *fp, off_t *,
					     struct uio *uio,
					     struct ucred *cred);
		int	(*fo_ioctl)(struct file *fp, u_long com,
					    caddr_t data, struct proc *p);
		int	(*fo_select)(struct file *fp, int which,
					     struct proc *p);
		int	(*fo_kqfilter)(struct file *fp,
					     struct knote *kn);
		int	(*fo_stat)(struct file *fp, struct stat *sb,
					     struct proc *p);
		int	(*fo_close)(struct file *fp, struct proc *p);
	} *f_ops;
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.18 2002/05/16 16:16:52 provos Exp $	*/
d81 1
a81 1
	caddr_t	f_data;		/* private data */
@


1.18
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.17 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.16 2002/02/08 13:53:28 art Exp $	*/
d62 1
@


1.16
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.15 2002/02/05 16:02:27 art Exp $	*/
d67 1
a67 1
		int	(*fo_read)	__P((struct file *fp, off_t *, 
d69 2
a70 2
					     struct ucred *cred));
		int	(*fo_write)	__P((struct file *fp, off_t *,
d72 10
a81 10
					     struct ucred *cred));
		int	(*fo_ioctl)	__P((struct file *fp, u_long com,
					    caddr_t data, struct proc *p));
		int	(*fo_select)	__P((struct file *fp, int which,
					     struct proc *p));
		int	(*fo_kqfilter)	__P((struct file *fp,
					     struct knote *kn));
		int	(*fo_stat)	__P((struct file *fp, struct stat *sb,
					     struct proc *p));
		int	(*fo_close)	__P((struct file *fp, struct proc *p));
d113 4
a116 4
int     dofileread __P((struct proc *, int, struct file *, void *, size_t,
            off_t *, register_t *));
int     dofilewrite __P((struct proc *, int, struct file *, const void *,
            size_t, off_t *, register_t *));
@


1.15
log
@Add counting of temporary references to a struct file (as opposed to references
from fd tables and other long-lived objects). This is to avoid races between
using a file descriptor and having another process (with shared fd table)
close it. We use a separate refence count so that error values from close(2)
will be correctly returned to the caller of close(2).

The macros for those reference counts are FILE_USE(fp) and FILE_UNUSE(fp).

Make sure that the cases where closef can be called "incorrectly" (most notably
dup2(2)) are handled.

Right now only callers of closef (and {,p}read) use FILE_{,UN}USE correctly,
more fixes incoming soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.13 2001/10/26 12:03:28 art Exp $	*/
d95 5
a99 2
#define FILE_SET_MATURE(fp) do {	\
	(fp)->f_iflags &= ~FIF_LARVAL;	\
d102 3
a104 5
#define FILE_USE(fp) do { (fp)->f_usecount++; } while (0)
#define FILE_UNUSE(fp) do {				\
	--(fp)->f_usecount;				\
	if (((fp)->f_iflags & FIF_WANTCLOSE) != 0)	\
		wakeup(&(fp)->f_usecount);		\
@


1.14
log
@Clarify some struct fields.
@
text
@d86 1
d97 7
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.14 2001/10/31 01:36:18 art Exp $	*/
a61 1
#define	DTYPE_SYSTRACE	6	/* system call tracing */
d67 1
a67 1
		int	(*fo_read)(struct file *fp, off_t *, 
d69 2
a70 2
					     struct ucred *cred);
		int	(*fo_write)(struct file *fp, off_t *,
d72 10
a81 10
					     struct ucred *cred);
		int	(*fo_ioctl)(struct file *fp, u_long com,
					    caddr_t data, struct proc *p);
		int	(*fo_select)(struct file *fp, int which,
					     struct proc *p);
		int	(*fo_kqfilter)(struct file *fp,
					     struct knote *kn);
		int	(*fo_stat)(struct file *fp, struct stat *sb,
					     struct proc *p);
		int	(*fo_close)(struct file *fp, struct proc *p);
a85 1
	int	f_usecount;	/* number of users (temporary references). */
d94 2
a95 10
#define FREF(fp) do { (fp)->f_usecount++; } while (0)
#define FRELE(fp) do {					\
	--(fp)->f_usecount;					\
	if (((fp)->f_iflags & FIF_WANTCLOSE) != 0)		\
		wakeup(&(fp)->f_usecount);			\
} while (0)

#define FILE_SET_MATURE(fp) do {				\
	(fp)->f_iflags &= ~FIF_LARVAL;				\
	FRELE(fp);						\
d104 4
a107 4
int     dofileread(struct proc *, int, struct file *, void *, size_t,
            off_t *, register_t *);
int     dofilewrite(struct proc *, int, struct file *, const void *,
            size_t, off_t *, register_t *);
@


1.13
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.12 2001/05/15 09:00:19 deraadt Exp $	*/
d84 2
a85 2
	caddr_t	f_data;		/* vnode or socket */
	int	f_iflags;
@


1.12
log
@DTYPE_CRYPTO
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.11 2001/05/14 12:38:46 art Exp $	*/
d85 1
d87 10
@


1.11
log
@Add a fo_stat member to struct fileops. Used soon.
Also add a stat function for kqueue from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.10 2001/03/01 20:54:35 provos Exp $	*/
d61 1
@


1.10
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.9 2000/11/16 20:02:20 provos Exp $	*/
d48 1
d75 1
a75 1
					    struct proc *p));
d77 3
a79 1
					    struct knote *kn));
@


1.9
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.8 2000/05/24 15:14:59 deraadt Exp $	*/
d47 1
d75 2
@


1.8
log
@move kernel prototypes using iovec to the right place
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.7 2000/04/20 06:32:00 deraadt Exp $	*/
d58 1
@


1.7
log
@p{read,write}{,v} from csapuntz, partial NetBSD origin I think
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.6 2000/04/19 08:34:50 csapuntz Exp $	*/
a88 5

int     dofilereadv __P((struct proc *, int, struct file *,
            const struct iovec *, int, off_t *, register_t *));
int     dofilewritev __P((struct proc *, int, struct file *,
            const struct iovec *, int, off_t *, register_t *));
@


1.6
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.5 2000/02/01 04:00:50 assar Exp $	*/
d84 10
@


1.5
log
@add declaration of `vnops'
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.4 1998/03/01 19:33:54 deraadt Exp $	*/
d63 6
a68 4
		int	(*fo_read)	__P((struct file *fp, struct uio *uio,
					    struct ucred *cred));
		int	(*fo_write)	__P((struct file *fp, struct uio *uio,
					    struct ucred *cred));
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.10 2001/03/01 20:54:35 provos Exp $	*/
a46 1
struct knote;
a57 1
#define	DTYPE_KQUEUE	4	/* event queue */
d63 4
a66 6
		int	(*fo_read)	__P((struct file *fp, off_t *, 
					     struct uio *uio,
					     struct ucred *cred));
		int	(*fo_write)	__P((struct file *fp, off_t *,
					     struct uio *uio,
					     struct ucred *cred));
a70 2
		int	(*fo_kqfilter)	__P((struct file *fp,
					    struct knote *kn));
a81 5

int     dofileread __P((struct proc *, int, struct file *, void *, size_t,
            off_t *, register_t *));
int     dofilewrite __P((struct proc *, int, struct file *, const void *,
            size_t, off_t *, register_t *));
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.5.2.1 2001/05/14 22:45:02 niklas Exp $	*/
a47 1
struct stat;
a59 1
#define	DTYPE_CRYPTO	5	/* crypto */
d74 1
a74 1
					     struct proc *p));
d76 1
a76 3
					     struct knote *kn));
		int	(*fo_stat)	__P((struct file *fp, struct stat *sb,
					     struct proc *p));
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.5.2.2 2001/07/04 11:00:20 niklas Exp $	*/
a84 1
	int	f_iflags;
a85 10

#define FIF_WANTCLOSE		0x01	/* a close is waiting for usecount */
#define FIF_LARVAL		0x02	/* not fully constructed, don't use */

#define FILE_IS_USABLE(fp) \
	(((fp)->f_iflags & (FIF_WANTCLOSE|FIF_LARVAL)) == 0)

#define FILE_SET_MATURE(fp) do {	\
	(fp)->f_iflags &= ~FIF_LARVAL;	\
} while (0)
@


1.5.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d84 2
a85 2
	caddr_t	f_data;		/* private data */
	int	f_iflags;	/* internal flags */
@


1.5.2.5
log
@Merge in trunk
@
text
@a85 1
	int	f_usecount;	/* number of users (temporary references). */
d94 2
a95 10
#define FREF(fp) do { (fp)->f_usecount++; } while (0)
#define FRELE(fp) do {					\
	--(fp)->f_usecount;					\
	if (((fp)->f_iflags & FIF_WANTCLOSE) != 0)		\
		wakeup(&(fp)->f_usecount);			\
} while (0)

#define FILE_SET_MATURE(fp) do {				\
	(fp)->f_iflags &= ~FIF_LARVAL;				\
	FRELE(fp);						\
@


1.5.2.6
log
@Merge in -current from roughly a week ago
@
text
@d67 1
a67 1
		int	(*fo_read)(struct file *fp, off_t *, 
d69 2
a70 2
					     struct ucred *cred);
		int	(*fo_write)(struct file *fp, off_t *,
d72 10
a81 10
					     struct ucred *cred);
		int	(*fo_ioctl)(struct file *fp, u_long com,
					    caddr_t data, struct proc *p);
		int	(*fo_select)(struct file *fp, int which,
					     struct proc *p);
		int	(*fo_kqfilter)(struct file *fp,
					     struct knote *kn);
		int	(*fo_stat)(struct file *fp, struct stat *sb,
					     struct proc *p);
		int	(*fo_close)(struct file *fp, struct proc *p);
d113 4
a116 4
int     dofileread(struct proc *, int, struct file *, void *, size_t,
            off_t *, register_t *);
int     dofilewrite(struct proc *, int, struct file *, const void *,
            size_t, off_t *, register_t *);
@


1.5.2.7
log
@Sync the SMP branch with 3.3
@
text
@a61 1
#define	DTYPE_SYSTRACE	6	/* system call tracing */
@


1.5.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.5.2.7 2003/03/28 00:41:30 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a44 14
struct file;

struct	fileops {
	int	(*fo_read)(struct file *, off_t *, struct uio *,
		    struct ucred *);
	int	(*fo_write)(struct file *, off_t *, struct uio *,
		    struct ucred *);
	int	(*fo_ioctl)(struct file *, u_long, caddr_t,
		    struct proc *);
	int	(*fo_poll)(struct file *, int, struct proc *);
	int	(*fo_kqfilter)(struct file *, struct knote *);
	int	(*fo_stat)(struct file *, struct stat *, struct proc *);
	int	(*fo_close)(struct file *, struct proc *);
};
d63 17
a79 1
	struct	fileops *f_ops;
d81 1
a81 1
	void 	*f_data;	/* private data */
@


1.4
log
@crank f_count/f_msgcount to long; when incrementing try to leave 2 slots
empty for unp_gc() in case of cross referenced sockets .
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.3 1996/08/27 14:47:06 shawn Exp $	*/
d81 1
@


1.3
log
@New fast pipe(2) from freebsd without fancy vm stuff.

The old pipes can be used with the "OLD_PIPE" config option.
@
text
@d1 1
a1 1
/*	$OpenBSD: file.h,v 1.2 1996/03/03 12:11:46 niklas Exp $	*/
d59 2
a60 2
	short	f_count;	/* reference count */
	short	f_msgcount;	/* references from message queue */
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
