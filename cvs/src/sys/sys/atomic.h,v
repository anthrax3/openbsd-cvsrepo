head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.4
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.3.0.8
	OPENBSD_6_0_BASE:1.3
	OPENBSD_5_9:1.3.0.4
	OPENBSD_5_9_BASE:1.3
	OPENBSD_5_8:1.3.0.6
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.1.0.6
	OPENBSD_5_6_BASE:1.1
	OPENBSD_5_5:1.1.0.4
	OPENBSD_5_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.4
date	2017.01.24.22.22.20;	author dlg;	state Exp;
branches;
next	1.3;
commitid	nTtNwYEG1hHRnTcG;

1.3
date	2015.02.10.11.39.18;	author dlg;	state Exp;
branches;
next	1.2;
commitid	m2pJHmSdzfKt5OIy;

1.2
date	2015.01.23.09.50.45;	author dlg;	state Exp;
branches;
next	1.1;
commitid	lVbpKlAyPUHxr207;

1.1
date	2014.01.30.00.44.20;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.4
log
@add explicit casts for going from volatile void * to void * volatile *.

guenther says void * is less special in c++, and atomic.h now leaks into
c++ ports.

reported by naddy
@
text
@/*	$OpenBSD: atomic.h,v 1.3 2015/02/10 11:39:18 dlg Exp $ */
/*
 * Copyright (c) 2014 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SYS_ATOMIC_H_
#define _SYS_ATOMIC_H_

#include <machine/atomic.h>

/*
 * an arch wanting to provide its own implementations does so by defining
 * macros.
 */

/*
 * atomic_cas_*
 */

#ifndef atomic_cas_uint
static inline unsigned int
atomic_cas_uint(volatile unsigned int *p, unsigned int o, unsigned int n)
{
	return __sync_val_compare_and_swap(p, o, n);
}
#endif

#ifndef atomic_cas_ulong
static inline unsigned long
atomic_cas_ulong(volatile unsigned long *p, unsigned long o, unsigned long n)
{
	return __sync_val_compare_and_swap(p, o, n);
}
#endif

#ifndef atomic_cas_ptr
static inline void *
atomic_cas_ptr(volatile void *pp, void *o, void *n)
{
	void * volatile *p = (void * volatile *)pp;
	return __sync_val_compare_and_swap(p, o, n);
}
#endif

/*
 * atomic_swap_*
 */

#ifndef atomic_swap_uint
static inline unsigned int
atomic_swap_uint(volatile unsigned int *p, unsigned int v)
{
	return __sync_lock_test_and_set(p, v);
}
#endif

#ifndef atomic_swap_ulong
static inline unsigned long
atomic_swap_ulong(volatile unsigned long *p, unsigned long v)
{
	return __sync_lock_test_and_set(p, v);
}
#endif

#ifndef atomic_swap_ptr
static inline void *
atomic_swap_ptr(volatile void *pp, void *v)
{
	void * volatile *p = (void * volatile *)pp;
	return __sync_lock_test_and_set(p, v);
}
#endif

/*
 * atomic_add_*_nv - add and fetch
 */

#ifndef atomic_add_int_nv
static inline unsigned int
atomic_add_int_nv(volatile unsigned int *p, unsigned int v)
{
	return __sync_add_and_fetch(p, v);
}
#endif

#ifndef atomic_add_long_nv
static inline unsigned long
atomic_add_long_nv(volatile unsigned long *p, unsigned long v)
{
	return __sync_add_and_fetch(p, v);
}
#endif

/*
 * atomic_add - add
 */

#ifndef atomic_add_int
#define atomic_add_int(_p, _v) ((void)atomic_add_int_nv((_p), (_v)))
#endif

#ifndef atomic_add_long
#define atomic_add_long(_p, _v) ((void)atomic_add_long_nv((_p), (_v)))
#endif

/*
 * atomic_inc_*_nv - increment and fetch
 */

#ifndef atomic_inc_int_nv
#define atomic_inc_int_nv(_p) atomic_add_int_nv((_p), 1)
#endif

#ifndef atomic_inc_long_nv
#define atomic_inc_long_nv(_p) atomic_add_long_nv((_p), 1)
#endif

/*
 * atomic_inc_* - increment
 */

#ifndef atomic_inc_int
#define atomic_inc_int(_p) ((void)atomic_inc_int_nv(_p))
#endif

#ifndef atomic_inc_long
#define atomic_inc_long(_p) ((void)atomic_inc_long_nv(_p))
#endif

/*
 * atomic_sub_*_nv - sub and fetch
 */

#ifndef atomic_sub_int_nv
static inline unsigned int
atomic_sub_int_nv(volatile unsigned int *p, unsigned int v)
{
	return __sync_sub_and_fetch(p, v);
}
#endif

#ifndef atomic_sub_long_nv
static inline unsigned long
atomic_sub_long_nv(volatile unsigned long *p, unsigned long v)
{
	return __sync_sub_and_fetch(p, v);
}
#endif

/*
 * atomic_sub_* - sub
 */

#ifndef atomic_sub_int
#define atomic_sub_int(_p, _v) ((void)atomic_sub_int_nv((_p), (_v)))
#endif

#ifndef atomic_sub_long
#define atomic_sub_long(_p, _v) ((void)atomic_sub_long_nv((_p), (_v)))
#endif

/*
 * atomic_dec_*_nv - decrement and fetch
 */

#ifndef atomic_dec_int_nv
#define atomic_dec_int_nv(_p) atomic_sub_int_nv((_p), 1)
#endif

#ifndef atomic_dec_long_nv
#define atomic_dec_long_nv(_p) atomic_sub_long_nv((_p), 1)
#endif

/*
 * atomic_dec_* - decrement
 */

#ifndef atomic_dec_int
#define atomic_dec_int(_p) ((void)atomic_dec_int_nv(_p))
#endif

#ifndef atomic_dec_long
#define atomic_dec_long(_p) ((void)atomic_dec_long_nv(_p))
#endif

/*
 * memory barriers
 */

#ifndef membar_enter
#define membar_enter() __sync_synchronize()
#endif

#ifndef membar_exit
#define membar_exit() __sync_synchronize()
#endif

#ifndef membar_producer
#define membar_producer() __sync_synchronize()
#endif

#ifndef membar_consumer
#define membar_consumer() __sync_synchronize()
#endif

#ifndef membar_sync
#define membar_sync() __sync_synchronize()
#endif

#endif /* _SYS_ATOMIC_H_ */
@


1.3
log
@make atomic cas and swap take volatile pointers like theyre documented to.

make the cas and swap ptr implementation take volatile void * and cast
to a void **ish thing inside so they match the defined API and dont
confuse the gcc builtins.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.2 2015/01/23 09:50:45 dlg Exp $ */
d52 1
a52 1
	void * volatile *p = pp;
d81 1
a81 1
	void * volatile *p = pp;
@


1.2
log
@get the args right for the fallback atomic_{cas,swap}_ptr
implementations, and then cast the pointer to the right type for
the gcc builtins.
@
text
@d1 1
a1 1
/*	$OpenBSD: atomic.h,v 1.1 2014/01/30 00:44:20 dlg Exp $ */
d34 1
a34 1
atomic_cas_uint(unsigned int *p, unsigned int o, unsigned int n)
d42 1
a42 1
atomic_cas_ulong(unsigned long *p, unsigned long o, unsigned long n)
d50 1
a50 1
atomic_cas_ptr(void *p, void *o, void *n)
d52 2
a53 1
	return __sync_val_compare_and_swap((void **)p, o, n);
d63 1
a63 1
atomic_swap_uint(unsigned int *p, unsigned int v)
d71 1
a71 1
atomic_swap_ulong(unsigned long *p, unsigned long v)
d79 1
a79 1
atomic_swap_ptr(void *p, void *v)
d81 2
a82 1
	return __sync_lock_test_and_set((void **)p, v);
d100 1
a100 1
atomic_add_long_nv(unsigned long *p, unsigned long v)
@


1.1
log
@add an MI api for atomic ops in the kernel. this api has its origins in
solaris, but we found it via netbsd.

this provides an MI implementation by using gccs atomic builtins. if an
arch wants to provide a better implementation it can simply provide the
specific bit of the api it wants to replace as a macro.

we're being conservative with this API and only providing it in the
kernel, and only for uints, ulongs, and pointers.

discussed at n2k14 and with hackers at length.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d50 1
a50 1
atomic_cas_ptr(void **p, void *o, void *n)
d52 1
a52 1
	return __sync_val_compare_and_swap(p, o, n);
d78 1
a78 1
atomic_swap_ptr(void **p, void *v)
d80 1
a80 1
	return __sync_lock_test_and_set(p, v);
@

