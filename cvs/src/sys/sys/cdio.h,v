head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.42
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.40
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.36
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.38
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.30
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.34
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.32
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.28
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.26
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.24
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.22
	OPENBSD_5_0:1.16.0.20
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.18
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.16
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.12
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.12
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.10
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.8
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.6
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.10.0.8
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.6
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.12
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.8
	OPENBSD_2_8:1.9.0.6
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.4
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.6.0.4
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2006.12.23.17.35.35;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.11.00.32.27;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.27.02.17.21;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.10.01.30.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.10.17.17.11.12;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.17.17.03.33;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.22.14.10.59;	author deraadt;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.12.08.06.32.56;	author angelos;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.11.12.05.56.31;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.07.20.06.21.59;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	98.08.21.22.08.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.16.09.28.54;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.12.11.24;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.05.02.45;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.01.06.16.00.24;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.07.04.11.00.13;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Add the ability to issue GPCMD_REPORT_KEY and GPCMD_SEND_KEY scsi
commands via the DVD_LU_SEND_RPC_STATE and DVD_HOST_SEND_RPC_STATE
ioctls respectively.

Thus allowing any region protected DVDs mistakenly delivered by Santa
to the wrong region to be viewed on recalcitrant DVD drives (with the
aid of an appropriate utility like regionset).

No change to any current functions.

Found in my hackers@@ folder from August.

From netbsd -> Kurt Miller -> jmc@@.
@
text
@/*	$OpenBSD: cdio.h,v 1.15 2006/07/11 00:32:27 pedro Exp $	*/
/*	$NetBSD: cdio.h,v 1.11 1996/02/19 18:29:04 scottr Exp $	*/

#ifndef _SYS_CDIO_H_
#define _SYS_CDIO_H_

#include <sys/types.h>
#include <sys/ioccom.h>

/* Shared between kernel & process */

union msf_lba {
	struct {
		u_char unused;
		u_char minute;
		u_char second;
		u_char frame;
	} msf;
	u_int32_t	lba;
	u_char		addr[4];
};

struct cd_toc_entry {
	u_char	nothing1;
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	control:4;
	u_int	addr_type:4;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	addr_type:4;
	u_int	control:4;
#endif
	u_char	track;
	u_char	nothing2;
	union msf_lba addr;
};

struct cd_sub_channel_header {
	u_char	nothing1;
	u_char	audio_status;
#define CD_AS_AUDIO_INVALID	0x00
#define CD_AS_PLAY_IN_PROGRESS	0x11
#define CD_AS_PLAY_PAUSED	0x12
#define CD_AS_PLAY_COMPLETED	0x13
#define CD_AS_PLAY_ERROR	0x14
#define CD_AS_NO_STATUS		0x15
	u_char	data_len[2];
};

struct cd_sub_channel_q_data {
	u_char	data_format;
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	control:4;
	u_int	addr_type:4;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	addr_type:4;
	u_int	control:4;
#endif
	u_char	track_number;
	u_char	index_number;
	u_char	absaddr[4];
	u_char	reladdr[4];
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	:7;
	u_int	mc_valid:1;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	mc_valid:1;
	u_int	:7;
#endif
	u_char	mc_number[15]; 
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	:7;
	u_int	ti_valid:1;   
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	ti_valid:1;   
	u_int	:7;
#endif
	u_char	ti_number[15]; 
};

struct cd_sub_channel_position_data {
	u_char	data_format;
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	control:4;
	u_int	addr_type:4;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	addr_type:4;
	u_int	control:4;
#endif
	u_char	track_number;
	u_char	index_number;
	union msf_lba absaddr;
	union msf_lba reladdr;
};

struct cd_sub_channel_media_catalog {
	u_char	data_format;
	u_char	nothing1;
	u_char	nothing2;
	u_char	nothing3;
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	:7;
	u_int	mc_valid:1;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	mc_valid:1;
	u_int	:7;
#endif
	u_char	mc_number[15];
};

struct cd_sub_channel_track_info {
	u_char	data_format;
	u_char	nothing1;
	u_char	track_number;
	u_char	nothing2;
#if _BYTE_ORDER == _LITTLE_ENDIAN
	u_int	:7;
	u_int	ti_valid:1;
#endif
#if _BYTE_ORDER == _BIG_ENDIAN
	u_int	ti_valid:1;
	u_int	:7;
#endif
	u_char	ti_number[15];
};

struct cd_sub_channel_info {
	struct cd_sub_channel_header header;
	union {
		struct cd_sub_channel_q_data q_data;
		struct cd_sub_channel_position_data position;
		struct cd_sub_channel_media_catalog media_catalog;
		struct cd_sub_channel_track_info track_info;
	} what;
};

/*
 * Ioctls for the CD drive
 */
struct ioc_play_track {
	u_char	start_track;
	u_char	start_index;
	u_char	end_track;
	u_char	end_index;
};

#define	CDIOCPLAYTRACKS	_IOW('c', 1, struct ioc_play_track)
struct ioc_play_blocks {
	int	blk;
	int	len;
};
#define	CDIOCPLAYBLOCKS	_IOW('c', 2, struct ioc_play_blocks)

struct ioc_read_subchannel {
	u_char	address_format;
#define CD_LBA_FORMAT		1
#define CD_MSF_FORMAT		2
	u_char	data_format;
#define CD_SUBQ_DATA		0
#define CD_CURRENT_POSITION	1
#define CD_MEDIA_CATALOG	2
#define CD_TRACK_INFO		3
	u_char	track;
	int	data_len;
	struct	cd_sub_channel_info *data;
};
#define CDIOCREADSUBCHANNEL _IOWR('c', 3, struct ioc_read_subchannel)

struct ioc_toc_header {
	u_short	len;
	u_char	starting_track;
	u_char	ending_track;
};

#define CDIOREADTOCHEADER _IOR('c', 4, struct ioc_toc_header)

struct ioc_read_toc_entry {
	u_char	address_format;
	u_char	starting_track;
#define CD_TRACK_LEADOUT	0xaa
	u_short	data_len;
	struct	cd_toc_entry *data;
};
#define CDIOREADTOCENTRIES _IOWR('c', 5, struct ioc_read_toc_entry)
#define CDIOREADTOCENTRYS CDIOREADTOCENTRIES

/* read LBA start of a given session; 0=last, others not yet supported */
#define CDIOREADMSADDR _IOWR('c', 6, int)

struct	ioc_patch {
	u_char	patch[4];	/* one for each channel */
};
#define	CDIOCSETPATCH	_IOW('c', 9, struct ioc_patch)

struct	ioc_vol {
	u_char	vol[4];	/* one for each channel */
};
#define	CDIOCGETVOL	_IOR('c', 10, struct ioc_vol)
#define	CDIOCSETVOL	_IOW('c', 11, struct ioc_vol)
#define	CDIOCSETMONO	_IO('c', 12)
#define	CDIOCSETSTEREO	_IO('c', 13)
#define	CDIOCSETMUTE	_IO('c', 14)
#define	CDIOCSETLEFT	_IO('c', 15)
#define	CDIOCSETRIGHT	_IO('c', 16)
#define	CDIOCSETDEBUG	_IO('c', 17)
#define	CDIOCCLRDEBUG	_IO('c', 18)
#define	CDIOCPAUSE	_IO('c', 19)
#define	CDIOCRESUME	_IO('c', 20)
#define	CDIOCRESET	_IO('c', 21)
#define	CDIOCSTART	_IO('c', 22)
#define	CDIOCSTOP	_IO('c', 23)
#define	CDIOCEJECT	_IO('c', 24)
#define	CDIOCALLOW	_IO('c', 25)
#define	CDIOCPREVENT	_IO('c', 26)
#define	CDIOCCLOSE	_IO('c', 27)
#define CDIOCSETCDDA	_IOW('c', 28, int)	/* (re)set CDDA reading mode */

struct ioc_play_msf {
	u_char	start_m;
	u_char	start_s;
	u_char	start_f;
	u_char	end_m;
	u_char	end_s;
	u_char	end_f;
};
#define	CDIOCPLAYMSF	_IOW('c', 25, struct ioc_play_msf)

struct ioc_load_unload {
	u_char options;
#define	CD_LU_ABORT	0x1	/* NOTE: These are the same as the ATAPI */
#define	CD_LU_UNLOAD	0x2	/* op values for the LOAD_UNLOAD command */
#define	CD_LU_LOAD	0x3
	u_char slot;
};
#define		CDIOCLOADUNLOAD	_IOW('c', 26, struct ioc_load_unload)

/* DVD definitions */

/* DVD-ROM Specific ioctls */
#define DVD_READ_STRUCT		_IOWR('d', 0, union dvd_struct)
#define DVD_WRITE_STRUCT	_IOWR('d', 1, union dvd_struct)
#define DVD_AUTH		_IOWR('d', 2, union dvd_authinfo)

#define GPCMD_READ_DVD_STRUCTURE	0xad
#define GPCMD_SEND_DVD_STRUCTURE	0xad
#define GPCMD_REPORT_KEY		0xa4
#define GPCMD_SEND_KEY			0xa3

/* DVD struct types */
#define DVD_STRUCT_PHYSICAL		0x00
#define DVD_STRUCT_COPYRIGHT		0x01
#define DVD_STRUCT_DISCKEY		0x02
#define DVD_STRUCT_BCA			0x03
#define DVD_STRUCT_MANUFACT		0x04

struct dvd_layer {
	u_int8_t book_version;
	u_int8_t book_type;
	u_int8_t min_rate;
	u_int8_t disc_size;
	u_int8_t layer_type;
	u_int8_t track_path;
	u_int8_t nlayers;
	u_int8_t track_density;
	u_int8_t linear_density;
	u_int8_t bca;
	u_int32_t start_sector;
	u_int32_t end_sector;
	u_int32_t end_sector_l0;
};
 
struct dvd_physical {
	u_int8_t type;

	u_int8_t layer_num;
	struct dvd_layer layer[4];
};

struct dvd_copyright {
	u_int8_t type;

	u_int8_t layer_num;
	u_int8_t cpst;
	u_int8_t rmi;
};

struct dvd_disckey {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t value[2048];
};

struct dvd_bca {
	u_int8_t type;

	int len;
	u_int8_t value[188];
};

struct dvd_manufact {
	u_int8_t type;

	u_int8_t layer_num;
	int len;
	u_int8_t value[2048];
};

union dvd_struct {
	u_int8_t type;

	struct dvd_physical	physical;
	struct dvd_copyright	copyright;
	struct dvd_disckey	disckey;
	struct dvd_bca		bca;
        struct dvd_manufact	manufact;
};

/*
 * DVD authentication ioctl
 */

/* Authentication states */
#define DVD_LU_SEND_AGID	0
#define DVD_HOST_SEND_CHALLENGE	1
#define DVD_LU_SEND_KEY1	2
#define DVD_LU_SEND_CHALLENGE	3
#define DVD_HOST_SEND_KEY2	4

/* Termination states */
#define DVD_AUTH_ESTABLISHED	5
#define DVD_AUTH_FAILURE	6

/* Other functions */
#define DVD_LU_SEND_TITLE_KEY	7
#define DVD_LU_SEND_ASF		8
#define DVD_INVALIDATE_AGID	9
#define DVD_LU_SEND_RPC_STATE	10
#define DVD_HOST_SEND_RPC_STATE	11

#if 0
/* State data */
typedef u_int8_t dvd_key[5];		/* 40-bit value, MSB is first elem. */
typedef u_int8_t dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
#endif

#define DVD_KEY_SIZE		5
#define DVD_CHALLENGE_SIZE	10

struct dvd_lu_send_agid {
	u_int8_t type;

	u_int8_t agid;
};

struct dvd_host_send_challenge {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t chal[DVD_CHALLENGE_SIZE];
};

struct dvd_send_key {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t key[DVD_KEY_SIZE];
};

struct dvd_lu_send_challenge {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t chal[DVD_CHALLENGE_SIZE];
};

#define DVD_CPM_NO_COPYRIGHT	0
#define DVD_CPM_COPYRIGHTED	1

#define DVD_CP_SEC_NONE		0
#define DVD_CP_SEC_EXIST	1

#define DVD_CGMS_UNRESTRICTED	0
#define DVD_CGMS_SINGLE		2
#define DVD_CGMS_RESTRICTED	3

struct dvd_lu_send_title_key {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t title_key[DVD_KEY_SIZE];
	int lba;
	u_int8_t cpm;
	u_int8_t cp_sec;
	u_int8_t cgms;
};

struct dvd_lu_send_asf {
	u_int8_t type;

	u_int8_t agid;
	u_int8_t asf;
};

struct dvd_host_send_rpcstate {
	u_int8_t type;
	u_int8_t pdrc;
};

struct dvd_lu_send_rpcstate {
	u_int8_t type;
	u_int8_t vra;
	u_int8_t ucca;
	u_int8_t region_mask;
	u_int8_t rpc_scheme;
      };

union dvd_authinfo {
	u_int8_t type;

	struct dvd_lu_send_agid		lsa;
	struct dvd_host_send_challenge	hsc;
	struct dvd_send_key		lsk;
	struct dvd_lu_send_challenge	lsc;
	struct dvd_send_key		hsk;
	struct dvd_lu_send_title_key	lstk;
	struct dvd_lu_send_asf		lsasf;
	struct dvd_host_send_rpcstate	hrpcs;
	struct dvd_lu_send_rpcstate	lrpcs;
};
#endif /* !_SYS_CDIO_H_ */
@


1.15
log
@Add a definition for CD/DVD lead-out tracks, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.14 2006/04/27 02:17:21 tedu Exp $	*/
d343 2
d410 13
d433 2
@


1.14
log
@use the underscore variants of _BYTE_ORDER which are always defined
even when various "strict" compiler options are used
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.13 2005/12/10 01:30:14 deraadt Exp $	*/
d185 1
@


1.13
log
@in ansi c, bitfields must be done against int, unsigned int, or _Bool.
so we must start to use u_int; ok cloder
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.12 2002/10/17 17:11:12 mickey Exp $	*/
d25 1
a25 1
#if BYTE_ORDER == LITTLE_ENDIAN
d29 1
a29 1
#if BYTE_ORDER == BIG_ENDIAN
d52 1
a52 1
#if BYTE_ORDER == LITTLE_ENDIAN
d56 1
a56 1
#if BYTE_ORDER == BIG_ENDIAN
d64 1
a64 1
#if BYTE_ORDER == LITTLE_ENDIAN
d68 1
a68 1
#if BYTE_ORDER == BIG_ENDIAN
d73 1
a73 1
#if BYTE_ORDER == LITTLE_ENDIAN
d77 1
a77 1
#if BYTE_ORDER == BIG_ENDIAN
d86 1
a86 1
#if BYTE_ORDER == LITTLE_ENDIAN
d90 1
a90 1
#if BYTE_ORDER == BIG_ENDIAN
d105 1
a105 1
#if BYTE_ORDER == LITTLE_ENDIAN
d109 1
a109 1
#if BYTE_ORDER == BIG_ENDIAN
d121 1
a121 1
#if BYTE_ORDER == LITTLE_ENDIAN
d125 1
a125 1
#if BYTE_ORDER == BIG_ENDIAN
@


1.12
log
@define CDIOREADTOCENTRYS CDIOREADTOCENTRIES, not as a duplicate _IOWR(); deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.11 2002/10/17 17:03:33 deraadt Exp $	*/
d26 2
a27 2
	u_char	control:4;
	u_char	addr_type:4;
d30 2
a31 2
	u_char	addr_type:4;
	u_char	control:4;
d53 2
a54 2
	u_char	control:4;
	u_char	addr_type:4;
d57 2
a58 2
	u_char	addr_type:4;
	u_char	control:4;
d65 2
a66 2
	u_char	:7;
	u_char	mc_valid:1;
d69 2
a70 2
	u_char	mc_valid:1;
	u_char	:7;
d74 2
a75 2
	u_char	:7;
	u_char	ti_valid:1;   
d78 2
a79 2
	u_char	ti_valid:1;   
	u_char	:7;
d87 2
a88 2
	u_char	control:4;
	u_char	addr_type:4;
d91 2
a92 2
	u_char	addr_type:4;
	u_char	control:4;
d106 2
a107 2
	u_char	:7;
	u_char	mc_valid:1;
d110 2
a111 2
	u_char	mc_valid:1;
	u_char	:7;
d122 2
a123 2
	u_char	:7;
	u_char	ti_valid:1;
d126 2
a127 2
	u_char	ti_valid:1;
	u_char	:7;
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.10 2001/06/22 14:10:59 deraadt Exp $	*/
d189 1
a189 1
#define CDIOREADTOCENTRYS _IOWR('c', 5, struct ioc_read_toc_entry)
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.9 1999/12/08 06:32:56 angelos Exp $	*/
d172 1
a172 1
#define CDIOCREADSUBCHANNEL _IOWR('c', 3, struct ioc_read_subchannel )
@


1.10.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.10 2001/06/22 14:10:59 deraadt Exp $	*/
d172 1
a172 1
#define CDIOCREADSUBCHANNEL _IOWR('c', 3, struct ioc_read_subchannel)
d189 1
a189 1
#define CDIOREADTOCENTRYS CDIOREADTOCENTRIES
@


1.9
log
@Move the FIBMAP ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.8 1999/11/12 05:56:31 angelos Exp $	*/
d15 1
a15 1
	  	u_char minute;
d19 2
a20 2
	u_int32_t lba;
	u_char	addr[4];
d244 8
a251 8
#define DVD_READ_STRUCT         _IOWR('d', 0, union dvd_struct)
#define DVD_WRITE_STRUCT        _IOWR('d', 1, union dvd_struct)
#define DVD_AUTH                _IOWR('d', 2, union dvd_authinfo)

#define GPCMD_READ_DVD_STRUCTURE            0xad
#define GPCMD_SEND_DVD_STRUCTURE            0xad
#define GPCMD_REPORT_KEY                    0xa4
#define GPCMD_SEND_KEY                      0xa3
d254 5
a258 5
#define DVD_STRUCT_PHYSICAL     0x00
#define DVD_STRUCT_COPYRIGHT    0x01
#define DVD_STRUCT_DISCKEY      0x02
#define DVD_STRUCT_BCA          0x03
#define DVD_STRUCT_MANUFACT     0x04
d261 13
a273 13
        u_int8_t book_version;
        u_int8_t book_type;
        u_int8_t min_rate;
        u_int8_t disc_size;
        u_int8_t layer_type;
        u_int8_t track_path;
        u_int8_t nlayers;
        u_int8_t track_density;
        u_int8_t linear_density;
        u_int8_t bca;
        u_int32_t start_sector;
        u_int32_t end_sector;
        u_int32_t end_sector_l0;
d277 1
a277 1
        u_int8_t type;
d279 2
a280 2
        u_int8_t layer_num;
        struct dvd_layer layer[4];
d284 1
a284 1
        u_int8_t type;
d286 3
a288 3
        u_int8_t layer_num;
        u_int8_t cpst;
        u_int8_t rmi;
d292 1
a292 1
        u_int8_t type;
d294 2
a295 2
        u_int8_t agid;
        u_int8_t value[2048];
d299 1
a299 1
        u_int8_t type;
d301 2
a302 2
        int len;
        u_int8_t value[188];
d306 1
a306 1
        u_int8_t type;
d308 3
a310 3
        u_int8_t layer_num;
        int len;
        u_int8_t value[2048];
d314 1
a314 1
        u_int8_t type;
d316 5
a320 5
        struct dvd_physical     physical;
        struct dvd_copyright    copyright;
        struct dvd_disckey      disckey;
        struct dvd_bca          bca;
        struct dvd_manufact     manufact;
d328 5
a332 5
#define DVD_LU_SEND_AGID        0
#define DVD_HOST_SEND_CHALLENGE 1
#define DVD_LU_SEND_KEY1        2
#define DVD_LU_SEND_CHALLENGE   3
#define DVD_HOST_SEND_KEY2      4
d335 2
a336 2
#define DVD_AUTH_ESTABLISHED    5
#define DVD_AUTH_FAILURE        6
d339 3
a341 3
#define DVD_LU_SEND_TITLE_KEY   7
#define DVD_LU_SEND_ASF         8
#define DVD_INVALIDATE_AGID     9
d345 2
a346 2
typedef u_int8_t dvd_key[5];        /* 40-bit value, MSB is first elem. */
typedef u_int8_t dvd_challenge[10]; /* 80-bit value, MSB is first elem. */
d353 1
a353 1
        u_int8_t type;
d355 1
a355 1
        u_int8_t agid;
d359 1
a359 1
        u_int8_t type;
d361 2
a362 2
        u_int8_t agid;
        u_int8_t chal[DVD_CHALLENGE_SIZE];
d366 1
a366 1
        u_int8_t type;
d368 2
a369 2
        u_int8_t agid;
        u_int8_t key[DVD_KEY_SIZE];
d373 1
a373 1
        u_int8_t type;
d375 2
a376 2
        u_int8_t agid;
        u_int8_t chal[DVD_CHALLENGE_SIZE];
d379 2
a380 2
#define DVD_CPM_NO_COPYRIGHT    0
#define DVD_CPM_COPYRIGHTED     1
d382 2
a383 2
#define DVD_CP_SEC_NONE         0
#define DVD_CP_SEC_EXIST        1
d385 3
a387 3
#define DVD_CGMS_UNRESTRICTED   0
#define DVD_CGMS_SINGLE         2
#define DVD_CGMS_RESTRICTED     3
d390 1
a390 1
        u_int8_t type;
d392 6
a397 6
        u_int8_t agid;
        u_int8_t title_key[DVD_KEY_SIZE];
        int lba;
        u_int8_t cpm;
        u_int8_t cp_sec;
        u_int8_t cgms;
d401 1
a401 1
        u_int8_t type;
d403 2
a404 2
        u_int8_t agid;
        u_int8_t asf;
d408 1
a408 1
        u_int8_t type;
d410 7
a416 7
        struct dvd_lu_send_agid         lsa;
        struct dvd_host_send_challenge  hsc;
        struct dvd_send_key             lsk;
        struct dvd_lu_send_challenge    lsc;
        struct dvd_send_key             hsk;
        struct dvd_lu_send_title_key    lstk;
        struct dvd_lu_send_asf          lsasf;
@


1.9.2.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.9 1999/12/08 06:32:56 angelos Exp $	*/
d15 1
a15 1
		u_char minute;
d19 2
a20 2
	u_int32_t	lba;
	u_char		addr[4];
d244 8
a251 8
#define DVD_READ_STRUCT		_IOWR('d', 0, union dvd_struct)
#define DVD_WRITE_STRUCT	_IOWR('d', 1, union dvd_struct)
#define DVD_AUTH		_IOWR('d', 2, union dvd_authinfo)

#define GPCMD_READ_DVD_STRUCTURE	0xad
#define GPCMD_SEND_DVD_STRUCTURE	0xad
#define GPCMD_REPORT_KEY		0xa4
#define GPCMD_SEND_KEY			0xa3
d254 5
a258 5
#define DVD_STRUCT_PHYSICAL		0x00
#define DVD_STRUCT_COPYRIGHT		0x01
#define DVD_STRUCT_DISCKEY		0x02
#define DVD_STRUCT_BCA			0x03
#define DVD_STRUCT_MANUFACT		0x04
d261 13
a273 13
	u_int8_t book_version;
	u_int8_t book_type;
	u_int8_t min_rate;
	u_int8_t disc_size;
	u_int8_t layer_type;
	u_int8_t track_path;
	u_int8_t nlayers;
	u_int8_t track_density;
	u_int8_t linear_density;
	u_int8_t bca;
	u_int32_t start_sector;
	u_int32_t end_sector;
	u_int32_t end_sector_l0;
d277 1
a277 1
	u_int8_t type;
d279 2
a280 2
	u_int8_t layer_num;
	struct dvd_layer layer[4];
d284 1
a284 1
	u_int8_t type;
d286 3
a288 3
	u_int8_t layer_num;
	u_int8_t cpst;
	u_int8_t rmi;
d292 1
a292 1
	u_int8_t type;
d294 2
a295 2
	u_int8_t agid;
	u_int8_t value[2048];
d299 1
a299 1
	u_int8_t type;
d301 2
a302 2
	int len;
	u_int8_t value[188];
d306 1
a306 1
	u_int8_t type;
d308 3
a310 3
	u_int8_t layer_num;
	int len;
	u_int8_t value[2048];
d314 1
a314 1
	u_int8_t type;
d316 5
a320 5
	struct dvd_physical	physical;
	struct dvd_copyright	copyright;
	struct dvd_disckey	disckey;
	struct dvd_bca		bca;
        struct dvd_manufact	manufact;
d328 5
a332 5
#define DVD_LU_SEND_AGID	0
#define DVD_HOST_SEND_CHALLENGE	1
#define DVD_LU_SEND_KEY1	2
#define DVD_LU_SEND_CHALLENGE	3
#define DVD_HOST_SEND_KEY2	4
d335 2
a336 2
#define DVD_AUTH_ESTABLISHED	5
#define DVD_AUTH_FAILURE	6
d339 3
a341 3
#define DVD_LU_SEND_TITLE_KEY	7
#define DVD_LU_SEND_ASF		8
#define DVD_INVALIDATE_AGID	9
d345 2
a346 2
typedef u_int8_t dvd_key[5];		/* 40-bit value, MSB is first elem. */
typedef u_int8_t dvd_challenge[10];	/* 80-bit value, MSB is first elem. */
d353 1
a353 1
	u_int8_t type;
d355 1
a355 1
	u_int8_t agid;
d359 1
a359 1
	u_int8_t type;
d361 2
a362 2
	u_int8_t agid;
	u_int8_t chal[DVD_CHALLENGE_SIZE];
d366 1
a366 1
	u_int8_t type;
d368 2
a369 2
	u_int8_t agid;
	u_int8_t key[DVD_KEY_SIZE];
d373 1
a373 1
	u_int8_t type;
d375 2
a376 2
	u_int8_t agid;
	u_int8_t chal[DVD_CHALLENGE_SIZE];
d379 2
a380 2
#define DVD_CPM_NO_COPYRIGHT	0
#define DVD_CPM_COPYRIGHTED	1
d382 2
a383 2
#define DVD_CP_SEC_NONE		0
#define DVD_CP_SEC_EXIST	1
d385 3
a387 3
#define DVD_CGMS_UNRESTRICTED	0
#define DVD_CGMS_SINGLE		2
#define DVD_CGMS_RESTRICTED	3
d390 1
a390 1
	u_int8_t type;
d392 6
a397 6
	u_int8_t agid;
	u_int8_t title_key[DVD_KEY_SIZE];
	int lba;
	u_int8_t cpm;
	u_int8_t cp_sec;
	u_int8_t cgms;
d401 1
a401 1
	u_int8_t type;
d403 2
a404 2
	u_int8_t agid;
	u_int8_t asf;
d408 1
a408 1
	u_int8_t type;
d410 7
a416 7
	struct dvd_lu_send_agid		lsa;
	struct dvd_host_send_challenge	hsc;
	struct dvd_send_key		lsk;
	struct dvd_lu_send_challenge	lsc;
	struct dvd_send_key		hsk;
	struct dvd_lu_send_title_key	lstk;
	struct dvd_lu_send_asf		lsasf;
@


1.9.2.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d172 1
a172 1
#define CDIOCREADSUBCHANNEL _IOWR('c', 3, struct ioc_read_subchannel)
d189 1
a189 1
#define CDIOREADTOCENTRYS CDIOREADTOCENTRIES
@


1.8
log
@Merge dvdio.h and cdio.h, don't use typedefs, get rid of bitfields (no
good reason to use them, not packed structures anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.7 1999/07/20 06:21:59 csapuntz Exp $	*/
a417 2

#define FIBMAP          _IOWR('f', 122, daddr_t)
@


1.7
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.6 1998/08/21 22:08:12 deraadt Exp $	*/
d7 3
d241 179
@


1.6
log
@Add struct cd_sub_channel_q_data for CD_SUBQ_DATA; msaitoh
(note: disgusting bitfields)
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.5 1996/05/16 09:28:54 mickey Exp $	*/
d16 1
a16 1
	int	lba;
d132 1
d185 1
d188 3
d216 2
a217 1
#define CDIOCSETCDDA	_IOW('c', 27, int)	/* (re)set CDDA reading mode */
d228 9
@


1.5
log
@from NetBSD PR#812:
allow CDDA disks to be read.
not tested, anyone w/ SCSI CD is ought to.
here is the test program (not tested too ;):


#define CDDA


#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/scsiio.h>
#include <sys/cdio.h>
#include <scsi/scsi_all.h>
#include <scsi/scsi_cd.h>
#include <scsi/scsi_disk.h>


extern int errno;


void
usage()
{
    fprintf(stderr, "usage: cdda -d device -b blkcnt -o offset >output\n");
    exit(1);
}


char databuf[CD_DA_BLKSIZ];


main(int argc, char *argv[])
{
    int ch;
    int fd;
    off_t offset = 0;
    int cnt = 0;
    char *dev = 0;
    struct scsi_rw_big read_cmd;
    struct scsi_mode_sense sense_cmd;
    struct cd_mode_data bdesc;
    scsireq_t req;


    while ((ch = getopt(argc, argv, "d:b:o:")) != -1) {
        switch (ch) {
        case 'd':
            dev = optarg;
            break;
        case 'b':
            cnt = atoi(optarg);
            if (cnt <= 0)
                usage();
            break;
        case 'o':
            offset = atoi(optarg);
            break;
        case '?':
        default:
            usage();
        }
    }
    if (dev == NULL || cnt == 0)
        usage();
    fd = open(dev, O_RDONLY);
    if (fd == -1)
        err(1,"can't open device %s", dev);
#ifdef DEBUG
    ch = SC_DB_FLOW;
    ioctl(fd, SCIOCDEBUG, &ch);
#endif
    ch = 1;
    if (ioctl(fd, CDIOCSETCDDA, &ch) == -1)
        warn("can't set CDDA mode");


    read_cmd.opcode = READ_BIG;         /* READ10 */
    read_cmd.byte2 = 0;                 /* no relative */
    read_cmd.reserved = 0;
    read_cmd.length2 = 0;
    read_cmd.length1 = 1;               /* read one block at a time.
                                           hope it caches! */
    read_cmd.control = 0;               /* LBA mode, leave flag & link zero */


    for (; cnt > 0; cnt--, offset++) {
        read_cmd.addr_3 = (offset >> 24) & 0xff;
        read_cmd.addr_2 = (offset >> 16) & 0xff;
        read_cmd.addr_1 = (offset >> 8) & 0xff;
        read_cmd.addr_0 = offset & 0xff;
        memset(&req, 0, sizeof(req));
        req.flags = SCCMD_READ;
        /* timeout is in milliseconds--not that it's obvious from the
           include files!  */
        req.timeout = 10000;            /* 10 sec */


        bcopy(&read_cmd, req.cmd, sizeof(read_cmd));
        req.cmdlen = sizeof(read_cmd);
        req.databuf = databuf;
        req.datalen = sizeof(databuf);
        req.senselen = sizeof(req.sense); /* XXX */
        if (ioctl(fd, SCIOCCOMMAND, &req) == -1) {
            fprintf(stderr, "bad ioctl: %d\n", errno);
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            exit(1);
        }
        if (req.retsts != 0 || req.error != 0) {
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            errx(1,"return status %d, error %d\n", req.retsts, req.error);
        }
        if (req.datalen_used != sizeof(databuf)) {
            ch = 0;
            ioctl(fd, CDIOCSETCDDA, &ch);
#ifdef DEBUG
            ioctl(fd, SCIOCDEBUG, &ch);
#endif
            errx(1,"didn't get full buffer back (%x)", req.datalen_used);
        }
        write(1, databuf, sizeof(databuf));
    }
    ch = 0;
    if (ioctl(fd, CDIOCSETCDDA, &ch) == -1)
        warn("can't reset CDDA mode");
#ifdef DEBUG
    ioctl(fd, SCIOCDEBUG, &ch);
#endif
    close(fd);
    exit(0);
}
@
text
@d1 1
a1 1
/*	$OpenBSD: cdio.h,v 1.4 1996/03/03 12:11:24 niklas Exp $	*/
d45 34
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
@


1.3
log
@The bitfields are ugly, but as they are basically a published interface,
it will be painful to change them.  (IMO)

Bring in from NetBSD:
Bitfields are usually implemented in natural bit order.  Pointed
out by Masaru Oki <oki@@yk.rim.or.jp> in NetBSD PR#2091.
@
text
@d1 1
@


1.2
log
@from freebsd: rename some fields.
note: the use of unions and structures in here is bad; the use of
bitfields is even worse. the interface defined here desperately
needs a cleanup.
@
text
@d1 1
a1 1
/*	$NetBSD: cdio.h,v 1.10 1994/10/11 22:31:55 deraadt Exp $	*/
d21 1
d24 5
d48 1
d51 5
d67 1
d70 5
d83 1
d86 5
@


1.1
log
@Initial revision
@
text
@d8 11
d25 1
a25 1
	u_char	addr[4];
d46 2
a47 2
	u_char	absaddr[4];
	u_char	reladdr[4];
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
