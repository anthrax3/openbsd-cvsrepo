head	1.29;
access;
symbols
	OPENBSD_6_1:1.25.0.4
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.14.0.6
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.13.0.12
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.13.0.16
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.14
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.10
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.8
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.8
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.6
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.4
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.12
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.10
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.8
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.7.0.6
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	UBC_SYNC_B:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	UBC:1.4.0.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.29
date	2017.07.30.19.27.20;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	ALWXlPigTyUlgmJK;

1.28
date	2017.06.19.03.06.26;	author dlg;	state Exp;
branches;
next	1.27;
commitid	CGcs8bxpQbPTEEeW;

1.27
date	2017.06.08.03.37.25;	author dlg;	state Exp;
branches;
next	1.26;
commitid	EMzl1A3PjYIb5KNQ;

1.26
date	2017.06.08.03.12.53;	author dlg;	state Exp;
branches;
next	1.25;
commitid	TlBMjkAIH73icf17;

1.25
date	2016.09.26.08.08.51;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	myhE90wov2oac2YX;

1.24
date	2016.09.15.06.07.22;	author dlg;	state Exp;
branches;
next	1.23;
commitid	aN30rOLBKbAUVmbb;

1.23
date	2016.09.15.05.21.09;	author dlg;	state Exp;
branches;
next	1.22;
commitid	Osb8bRwvY1dZ2Iv4;

1.22
date	2016.09.15.01.05.15;	author dlg;	state Exp;
branches;
next	1.21;
commitid	asT65ud2hFmyYuyz;

1.21
date	2016.09.09.20.31.46;	author millert;	state Exp;
branches;
next	1.20;
commitid	GAScUkPGHJ6VSSzG;

1.20
date	2016.09.09.04.50.54;	author dlg;	state Exp;
branches;
next	1.19;
commitid	XOpojCCt9TQwM6NG;

1.19
date	2016.09.09.02.00.14;	author dlg;	state Exp;
branches;
next	1.18;
commitid	IQ9HZMDS2pDjqje2;

1.18
date	2016.09.06.06.56.30;	author dlg;	state Exp;
branches;
next	1.17;
commitid	oVjFZvBe6YHf1YP3;

1.17
date	2016.09.05.23.43.13;	author dlg;	state Exp;
branches;
next	1.16;
commitid	Tk3iUpaWaD9k33fc;

1.16
date	2016.09.05.07.24.34;	author dlg;	state Exp;
branches;
next	1.15;
commitid	TvUKfKA851H2irAh;

1.15
date	2016.09.02.11.17.14;	author dlg;	state Exp;
branches;
next	1.14;
commitid	JKwXWZVeiXvx3WRv;

1.14
date	2015.05.25.03.07.49;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	dehh7FrSkXgo6teU;

1.13
date	2011.07.09.00.19.45;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.02.09.42.55;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.11.22.19.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.29.23.49.41;	author djm;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.24.18.10.42;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.24.18.11.46;	author frantzen;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.17.21.51.54;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.11.22.09.52;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2002.06.11.18.59.22;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.26.02.47.28;	author hugh;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2002.03.25.21.23.54;	author frantzen;	state Exp;
branches;
next	1.2;

1.2
date	2002.02.27.17.35.00;	author frantzen;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2002.02.24.19.42.46;	author provos;	state Exp;
branches;
next	;

1.2.2.1
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@mark __inline functions which are not neccessarily used, with __unused.
ok espie florian kettenis
@
text
@/*	$OpenBSD: tree.h,v 1.28 2017/06/19 03:06:26 dlg Exp $	*/
/*
 * Copyright 2002 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef	_SYS_TREE_H_
#define	_SYS_TREE_H_

#include <sys/_null.h>

/*
 * This file defines data structures for different types of trees:
 * splay trees and red-black trees.
 *
 * A splay tree is a self-organizing data structure.  Every operation
 * on the tree causes a splay to happen.  The splay moves the requested
 * node to the root of the tree and partly rebalances it.
 *
 * This has the benefit that request locality causes faster lookups as
 * the requested nodes move to the top of the tree.  On the other hand,
 * every lookup causes memory writes.
 *
 * The Balance Theorem bounds the total access time for m operations
 * and n inserts on an initially empty tree as O((m + n)lg n).  The
 * amortized cost for a sequence of m accesses to a splay tree is O(lg n);
 *
 * A red-black tree is a binary search tree with the node color as an
 * extra attribute.  It fulfills a set of conditions:
 *	- every search path from the root to a leaf consists of the
 *	  same number of black nodes,
 *	- each red node (except for the root) has a black parent,
 *	- each leaf node is black.
 *
 * Every operation on a red-black tree is bounded as O(lg n).
 * The maximum height of a red-black tree is 2lg (n+1).
 */

#define SPLAY_HEAD(name, type)						\
struct name {								\
	struct type *sph_root; /* root of the tree */			\
}

#define SPLAY_INITIALIZER(root)						\
	{ NULL }

#define SPLAY_INIT(root) do {						\
	(root)->sph_root = NULL;					\
} while (0)

#define SPLAY_ENTRY(type)						\
struct {								\
	struct type *spe_left; /* left element */			\
	struct type *spe_right; /* right element */			\
}

#define SPLAY_LEFT(elm, field)		(elm)->field.spe_left
#define SPLAY_RIGHT(elm, field)		(elm)->field.spe_right
#define SPLAY_ROOT(head)		(head)->sph_root
#define SPLAY_EMPTY(head)		(SPLAY_ROOT(head) == NULL)

/* SPLAY_ROTATE_{LEFT,RIGHT} expect that tmp hold SPLAY_{RIGHT,LEFT} */
#define SPLAY_ROTATE_RIGHT(head, tmp, field) do {			\
	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(tmp, field);	\
	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
	(head)->sph_root = tmp;						\
} while (0)

#define SPLAY_ROTATE_LEFT(head, tmp, field) do {			\
	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(tmp, field);	\
	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
	(head)->sph_root = tmp;						\
} while (0)

#define SPLAY_LINKLEFT(head, tmp, field) do {				\
	SPLAY_LEFT(tmp, field) = (head)->sph_root;			\
	tmp = (head)->sph_root;						\
	(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);		\
} while (0)

#define SPLAY_LINKRIGHT(head, tmp, field) do {				\
	SPLAY_RIGHT(tmp, field) = (head)->sph_root;			\
	tmp = (head)->sph_root;						\
	(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);	\
} while (0)

#define SPLAY_ASSEMBLE(head, node, left, right, field) do {		\
	SPLAY_RIGHT(left, field) = SPLAY_LEFT((head)->sph_root, field);	\
	SPLAY_LEFT(right, field) = SPLAY_RIGHT((head)->sph_root, field);\
	SPLAY_LEFT((head)->sph_root, field) = SPLAY_RIGHT(node, field);	\
	SPLAY_RIGHT((head)->sph_root, field) = SPLAY_LEFT(node, field);	\
} while (0)

/* Generates prototypes and inline functions */

#define SPLAY_PROTOTYPE(name, type, field, cmp)				\
void name##_SPLAY(struct name *, struct type *);			\
void name##_SPLAY_MINMAX(struct name *, int);				\
struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
									\
/* Finds the node with the same key as elm */				\
static __unused __inline struct type *					\
name##_SPLAY_FIND(struct name *head, struct type *elm)			\
{									\
	if (SPLAY_EMPTY(head))						\
		return(NULL);						\
	name##_SPLAY(head, elm);					\
	if ((cmp)(elm, (head)->sph_root) == 0)				\
		return (head->sph_root);				\
	return (NULL);							\
}									\
									\
static __unused __inline struct type *					\
name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
{									\
	name##_SPLAY(head, elm);					\
	if (SPLAY_RIGHT(elm, field) != NULL) {				\
		elm = SPLAY_RIGHT(elm, field);				\
		while (SPLAY_LEFT(elm, field) != NULL) {		\
			elm = SPLAY_LEFT(elm, field);			\
		}							\
	} else								\
		elm = NULL;						\
	return (elm);							\
}									\
									\
static __unused __inline struct type *					\
name##_SPLAY_MIN_MAX(struct name *head, int val)			\
{									\
	name##_SPLAY_MINMAX(head, val);					\
        return (SPLAY_ROOT(head));					\
}

/* Main splay operation.
 * Moves node close to the key of elm to top
 */
#define SPLAY_GENERATE(name, type, field, cmp)				\
struct type *								\
name##_SPLAY_INSERT(struct name *head, struct type *elm)		\
{									\
    if (SPLAY_EMPTY(head)) {						\
	    SPLAY_LEFT(elm, field) = SPLAY_RIGHT(elm, field) = NULL;	\
    } else {								\
	    int __comp;							\
	    name##_SPLAY(head, elm);					\
	    __comp = (cmp)(elm, (head)->sph_root);			\
	    if(__comp < 0) {						\
		    SPLAY_LEFT(elm, field) = SPLAY_LEFT((head)->sph_root, field);\
		    SPLAY_RIGHT(elm, field) = (head)->sph_root;		\
		    SPLAY_LEFT((head)->sph_root, field) = NULL;		\
	    } else if (__comp > 0) {					\
		    SPLAY_RIGHT(elm, field) = SPLAY_RIGHT((head)->sph_root, field);\
		    SPLAY_LEFT(elm, field) = (head)->sph_root;		\
		    SPLAY_RIGHT((head)->sph_root, field) = NULL;	\
	    } else							\
		    return ((head)->sph_root);				\
    }									\
    (head)->sph_root = (elm);						\
    return (NULL);							\
}									\
									\
struct type *								\
name##_SPLAY_REMOVE(struct name *head, struct type *elm)		\
{									\
	struct type *__tmp;						\
	if (SPLAY_EMPTY(head))						\
		return (NULL);						\
	name##_SPLAY(head, elm);					\
	if ((cmp)(elm, (head)->sph_root) == 0) {			\
		if (SPLAY_LEFT((head)->sph_root, field) == NULL) {	\
			(head)->sph_root = SPLAY_RIGHT((head)->sph_root, field);\
		} else {						\
			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
			(head)->sph_root = SPLAY_LEFT((head)->sph_root, field);\
			name##_SPLAY(head, elm);			\
			SPLAY_RIGHT((head)->sph_root, field) = __tmp;	\
		}							\
		return (elm);						\
	}								\
	return (NULL);							\
}									\
									\
void									\
name##_SPLAY(struct name *head, struct type *elm)			\
{									\
	struct type __node, *__left, *__right, *__tmp;			\
	int __comp;							\
\
	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
	__left = __right = &__node;					\
\
	while ((__comp = (cmp)(elm, (head)->sph_root))) {		\
		if (__comp < 0) {					\
			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
			if (__tmp == NULL)				\
				break;					\
			if ((cmp)(elm, __tmp) < 0){			\
				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
					break;				\
			}						\
			SPLAY_LINKLEFT(head, __right, field);		\
		} else if (__comp > 0) {				\
			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
			if (__tmp == NULL)				\
				break;					\
			if ((cmp)(elm, __tmp) > 0){			\
				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
					break;				\
			}						\
			SPLAY_LINKRIGHT(head, __left, field);		\
		}							\
	}								\
	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
}									\
									\
/* Splay with either the minimum or the maximum element			\
 * Used to find minimum or maximum element in tree.			\
 */									\
void name##_SPLAY_MINMAX(struct name *head, int __comp) \
{									\
	struct type __node, *__left, *__right, *__tmp;			\
\
	SPLAY_LEFT(&__node, field) = SPLAY_RIGHT(&__node, field) = NULL;\
	__left = __right = &__node;					\
\
	while (1) {							\
		if (__comp < 0) {					\
			__tmp = SPLAY_LEFT((head)->sph_root, field);	\
			if (__tmp == NULL)				\
				break;					\
			if (__comp < 0){				\
				SPLAY_ROTATE_RIGHT(head, __tmp, field);	\
				if (SPLAY_LEFT((head)->sph_root, field) == NULL)\
					break;				\
			}						\
			SPLAY_LINKLEFT(head, __right, field);		\
		} else if (__comp > 0) {				\
			__tmp = SPLAY_RIGHT((head)->sph_root, field);	\
			if (__tmp == NULL)				\
				break;					\
			if (__comp > 0) {				\
				SPLAY_ROTATE_LEFT(head, __tmp, field);	\
				if (SPLAY_RIGHT((head)->sph_root, field) == NULL)\
					break;				\
			}						\
			SPLAY_LINKRIGHT(head, __left, field);		\
		}							\
	}								\
	SPLAY_ASSEMBLE(head, &__node, __left, __right, field);		\
}

#define SPLAY_NEGINF	-1
#define SPLAY_INF	1

#define SPLAY_INSERT(name, x, y)	name##_SPLAY_INSERT(x, y)
#define SPLAY_REMOVE(name, x, y)	name##_SPLAY_REMOVE(x, y)
#define SPLAY_FIND(name, x, y)		name##_SPLAY_FIND(x, y)
#define SPLAY_NEXT(name, x, y)		name##_SPLAY_NEXT(x, y)
#define SPLAY_MIN(name, x)		(SPLAY_EMPTY(x) ? NULL	\
					: name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF))
#define SPLAY_MAX(name, x)		(SPLAY_EMPTY(x) ? NULL	\
					: name##_SPLAY_MIN_MAX(x, SPLAY_INF))

#define SPLAY_FOREACH(x, name, head)					\
	for ((x) = SPLAY_MIN(name, head);				\
	     (x) != NULL;						\
	     (x) = SPLAY_NEXT(name, head, x))

/* Macros that define a red-black tree */
#define RB_HEAD(name, type)						\
struct name {								\
	struct type *rbh_root; /* root of the tree */			\
}

#define RB_INITIALIZER(root)						\
	{ NULL }

#define RB_INIT(root) do {						\
	(root)->rbh_root = NULL;					\
} while (0)

#define RB_BLACK	0
#define RB_RED		1
#define RB_ENTRY(type)							\
struct {								\
	struct type *rbe_left;		/* left element */		\
	struct type *rbe_right;		/* right element */		\
	struct type *rbe_parent;	/* parent element */		\
	int rbe_color;			/* node color */		\
}

#define RB_LEFT(elm, field)		(elm)->field.rbe_left
#define RB_RIGHT(elm, field)		(elm)->field.rbe_right
#define RB_PARENT(elm, field)		(elm)->field.rbe_parent
#define RB_COLOR(elm, field)		(elm)->field.rbe_color
#define RB_ROOT(head)			(head)->rbh_root
#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)

#define RB_SET(elm, parent, field) do {					\
	RB_PARENT(elm, field) = parent;					\
	RB_LEFT(elm, field) = RB_RIGHT(elm, field) = NULL;		\
	RB_COLOR(elm, field) = RB_RED;					\
} while (0)

#define RB_SET_BLACKRED(black, red, field) do {				\
	RB_COLOR(black, field) = RB_BLACK;				\
	RB_COLOR(red, field) = RB_RED;					\
} while (0)

#ifndef RB_AUGMENT
#define RB_AUGMENT(x)	do {} while (0)
#endif

#define RB_ROTATE_LEFT(head, elm, tmp, field) do {			\
	(tmp) = RB_RIGHT(elm, field);					\
	if ((RB_RIGHT(elm, field) = RB_LEFT(tmp, field))) {		\
		RB_PARENT(RB_LEFT(tmp, field), field) = (elm);		\
	}								\
	RB_AUGMENT(elm);						\
	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
		else							\
			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
	} else								\
		(head)->rbh_root = (tmp);				\
	RB_LEFT(tmp, field) = (elm);					\
	RB_PARENT(elm, field) = (tmp);					\
	RB_AUGMENT(tmp);						\
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
} while (0)

#define RB_ROTATE_RIGHT(head, elm, tmp, field) do {			\
	(tmp) = RB_LEFT(elm, field);					\
	if ((RB_LEFT(elm, field) = RB_RIGHT(tmp, field))) {		\
		RB_PARENT(RB_RIGHT(tmp, field), field) = (elm);		\
	}								\
	RB_AUGMENT(elm);						\
	if ((RB_PARENT(tmp, field) = RB_PARENT(elm, field))) {		\
		if ((elm) == RB_LEFT(RB_PARENT(elm, field), field))	\
			RB_LEFT(RB_PARENT(elm, field), field) = (tmp);	\
		else							\
			RB_RIGHT(RB_PARENT(elm, field), field) = (tmp);	\
	} else								\
		(head)->rbh_root = (tmp);				\
	RB_RIGHT(tmp, field) = (elm);					\
	RB_PARENT(elm, field) = (tmp);					\
	RB_AUGMENT(tmp);						\
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
} while (0)

/* Generates prototypes and inline functions */
#define	RB_PROTOTYPE(name, type, field, cmp)				\
	RB_PROTOTYPE_INTERNAL(name, type, field, cmp,)
#define	RB_PROTOTYPE_STATIC(name, type, field, cmp)			\
	RB_PROTOTYPE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
#define RB_PROTOTYPE_INTERNAL(name, type, field, cmp, attr)		\
attr void name##_RB_INSERT_COLOR(struct name *, struct type *);		\
attr void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
attr struct type *name##_RB_REMOVE(struct name *, struct type *);	\
attr struct type *name##_RB_INSERT(struct name *, struct type *);	\
attr struct type *name##_RB_FIND(struct name *, struct type *);		\
attr struct type *name##_RB_NFIND(struct name *, struct type *);	\
attr struct type *name##_RB_NEXT(struct type *);			\
attr struct type *name##_RB_PREV(struct type *);			\
attr struct type *name##_RB_MINMAX(struct name *, int);			\
									\

/* Main rb operation.
 * Moves node close to the key of elm to top
 */
#define	RB_GENERATE(name, type, field, cmp)				\
	RB_GENERATE_INTERNAL(name, type, field, cmp,)
#define	RB_GENERATE_STATIC(name, type, field, cmp)			\
	RB_GENERATE_INTERNAL(name, type, field, cmp, __attribute__((__unused__)) static)
#define RB_GENERATE_INTERNAL(name, type, field, cmp, attr)		\
attr void								\
name##_RB_INSERT_COLOR(struct name *head, struct type *elm)		\
{									\
	struct type *parent, *gparent, *tmp;				\
	while ((parent = RB_PARENT(elm, field)) &&			\
	    RB_COLOR(parent, field) == RB_RED) {			\
		gparent = RB_PARENT(parent, field);			\
		if (parent == RB_LEFT(gparent, field)) {		\
			tmp = RB_RIGHT(gparent, field);			\
			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
				RB_COLOR(tmp, field) = RB_BLACK;	\
				RB_SET_BLACKRED(parent, gparent, field);\
				elm = gparent;				\
				continue;				\
			}						\
			if (RB_RIGHT(parent, field) == elm) {		\
				RB_ROTATE_LEFT(head, parent, tmp, field);\
				tmp = parent;				\
				parent = elm;				\
				elm = tmp;				\
			}						\
			RB_SET_BLACKRED(parent, gparent, field);	\
			RB_ROTATE_RIGHT(head, gparent, tmp, field);	\
		} else {						\
			tmp = RB_LEFT(gparent, field);			\
			if (tmp && RB_COLOR(tmp, field) == RB_RED) {	\
				RB_COLOR(tmp, field) = RB_BLACK;	\
				RB_SET_BLACKRED(parent, gparent, field);\
				elm = gparent;				\
				continue;				\
			}						\
			if (RB_LEFT(parent, field) == elm) {		\
				RB_ROTATE_RIGHT(head, parent, tmp, field);\
				tmp = parent;				\
				parent = elm;				\
				elm = tmp;				\
			}						\
			RB_SET_BLACKRED(parent, gparent, field);	\
			RB_ROTATE_LEFT(head, gparent, tmp, field);	\
		}							\
	}								\
	RB_COLOR(head->rbh_root, field) = RB_BLACK;			\
}									\
									\
attr void								\
name##_RB_REMOVE_COLOR(struct name *head, struct type *parent, struct type *elm) \
{									\
	struct type *tmp;						\
	while ((elm == NULL || RB_COLOR(elm, field) == RB_BLACK) &&	\
	    elm != RB_ROOT(head)) {					\
		if (RB_LEFT(parent, field) == elm) {			\
			tmp = RB_RIGHT(parent, field);			\
			if (RB_COLOR(tmp, field) == RB_RED) {		\
				RB_SET_BLACKRED(tmp, parent, field);	\
				RB_ROTATE_LEFT(head, parent, tmp, field);\
				tmp = RB_RIGHT(parent, field);		\
			}						\
			if ((RB_LEFT(tmp, field) == NULL ||		\
			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
			    (RB_RIGHT(tmp, field) == NULL ||		\
			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
				RB_COLOR(tmp, field) = RB_RED;		\
				elm = parent;				\
				parent = RB_PARENT(elm, field);		\
			} else {					\
				if (RB_RIGHT(tmp, field) == NULL ||	\
				    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK) {\
					struct type *oleft;		\
					if ((oleft = RB_LEFT(tmp, field)))\
						RB_COLOR(oleft, field) = RB_BLACK;\
					RB_COLOR(tmp, field) = RB_RED;	\
					RB_ROTATE_RIGHT(head, tmp, oleft, field);\
					tmp = RB_RIGHT(parent, field);	\
				}					\
				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
				RB_COLOR(parent, field) = RB_BLACK;	\
				if (RB_RIGHT(tmp, field))		\
					RB_COLOR(RB_RIGHT(tmp, field), field) = RB_BLACK;\
				RB_ROTATE_LEFT(head, parent, tmp, field);\
				elm = RB_ROOT(head);			\
				break;					\
			}						\
		} else {						\
			tmp = RB_LEFT(parent, field);			\
			if (RB_COLOR(tmp, field) == RB_RED) {		\
				RB_SET_BLACKRED(tmp, parent, field);	\
				RB_ROTATE_RIGHT(head, parent, tmp, field);\
				tmp = RB_LEFT(parent, field);		\
			}						\
			if ((RB_LEFT(tmp, field) == NULL ||		\
			    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) &&\
			    (RB_RIGHT(tmp, field) == NULL ||		\
			    RB_COLOR(RB_RIGHT(tmp, field), field) == RB_BLACK)) {\
				RB_COLOR(tmp, field) = RB_RED;		\
				elm = parent;				\
				parent = RB_PARENT(elm, field);		\
			} else {					\
				if (RB_LEFT(tmp, field) == NULL ||	\
				    RB_COLOR(RB_LEFT(tmp, field), field) == RB_BLACK) {\
					struct type *oright;		\
					if ((oright = RB_RIGHT(tmp, field)))\
						RB_COLOR(oright, field) = RB_BLACK;\
					RB_COLOR(tmp, field) = RB_RED;	\
					RB_ROTATE_LEFT(head, tmp, oright, field);\
					tmp = RB_LEFT(parent, field);	\
				}					\
				RB_COLOR(tmp, field) = RB_COLOR(parent, field);\
				RB_COLOR(parent, field) = RB_BLACK;	\
				if (RB_LEFT(tmp, field))		\
					RB_COLOR(RB_LEFT(tmp, field), field) = RB_BLACK;\
				RB_ROTATE_RIGHT(head, parent, tmp, field);\
				elm = RB_ROOT(head);			\
				break;					\
			}						\
		}							\
	}								\
	if (elm)							\
		RB_COLOR(elm, field) = RB_BLACK;			\
}									\
									\
attr struct type *							\
name##_RB_REMOVE(struct name *head, struct type *elm)			\
{									\
	struct type *child, *parent, *old = elm;			\
	int color;							\
	if (RB_LEFT(elm, field) == NULL)				\
		child = RB_RIGHT(elm, field);				\
	else if (RB_RIGHT(elm, field) == NULL)				\
		child = RB_LEFT(elm, field);				\
	else {								\
		struct type *left;					\
		elm = RB_RIGHT(elm, field);				\
		while ((left = RB_LEFT(elm, field)))			\
			elm = left;					\
		child = RB_RIGHT(elm, field);				\
		parent = RB_PARENT(elm, field);				\
		color = RB_COLOR(elm, field);				\
		if (child)						\
			RB_PARENT(child, field) = parent;		\
		if (parent) {						\
			if (RB_LEFT(parent, field) == elm)		\
				RB_LEFT(parent, field) = child;		\
			else						\
				RB_RIGHT(parent, field) = child;	\
			RB_AUGMENT(parent);				\
		} else							\
			RB_ROOT(head) = child;				\
		if (RB_PARENT(elm, field) == old)			\
			parent = elm;					\
		(elm)->field = (old)->field;				\
		if (RB_PARENT(old, field)) {				\
			if (RB_LEFT(RB_PARENT(old, field), field) == old)\
				RB_LEFT(RB_PARENT(old, field), field) = elm;\
			else						\
				RB_RIGHT(RB_PARENT(old, field), field) = elm;\
			RB_AUGMENT(RB_PARENT(old, field));		\
		} else							\
			RB_ROOT(head) = elm;				\
		RB_PARENT(RB_LEFT(old, field), field) = elm;		\
		if (RB_RIGHT(old, field))				\
			RB_PARENT(RB_RIGHT(old, field), field) = elm;	\
		if (parent) {						\
			left = parent;					\
			do {						\
				RB_AUGMENT(left);			\
			} while ((left = RB_PARENT(left, field)));	\
		}							\
		goto color;						\
	}								\
	parent = RB_PARENT(elm, field);					\
	color = RB_COLOR(elm, field);					\
	if (child)							\
		RB_PARENT(child, field) = parent;			\
	if (parent) {							\
		if (RB_LEFT(parent, field) == elm)			\
			RB_LEFT(parent, field) = child;			\
		else							\
			RB_RIGHT(parent, field) = child;		\
		RB_AUGMENT(parent);					\
	} else								\
		RB_ROOT(head) = child;					\
color:									\
	if (color == RB_BLACK)						\
		name##_RB_REMOVE_COLOR(head, parent, child);		\
	return (old);							\
}									\
									\
/* Inserts a node into the RB tree */					\
attr struct type *							\
name##_RB_INSERT(struct name *head, struct type *elm)			\
{									\
	struct type *tmp;						\
	struct type *parent = NULL;					\
	int comp = 0;							\
	tmp = RB_ROOT(head);						\
	while (tmp) {							\
		parent = tmp;						\
		comp = (cmp)(elm, parent);				\
		if (comp < 0)						\
			tmp = RB_LEFT(tmp, field);			\
		else if (comp > 0)					\
			tmp = RB_RIGHT(tmp, field);			\
		else							\
			return (tmp);					\
	}								\
	RB_SET(elm, parent, field);					\
	if (parent != NULL) {						\
		if (comp < 0)						\
			RB_LEFT(parent, field) = elm;			\
		else							\
			RB_RIGHT(parent, field) = elm;			\
		RB_AUGMENT(parent);					\
	} else								\
		RB_ROOT(head) = elm;					\
	name##_RB_INSERT_COLOR(head, elm);				\
	return (NULL);							\
}									\
									\
/* Finds the node with the same key as elm */				\
attr struct type *							\
name##_RB_FIND(struct name *head, struct type *elm)			\
{									\
	struct type *tmp = RB_ROOT(head);				\
	int comp;							\
	while (tmp) {							\
		comp = cmp(elm, tmp);					\
		if (comp < 0)						\
			tmp = RB_LEFT(tmp, field);			\
		else if (comp > 0)					\
			tmp = RB_RIGHT(tmp, field);			\
		else							\
			return (tmp);					\
	}								\
	return (NULL);							\
}									\
									\
/* Finds the first node greater than or equal to the search key */	\
attr struct type *							\
name##_RB_NFIND(struct name *head, struct type *elm)			\
{									\
	struct type *tmp = RB_ROOT(head);				\
	struct type *res = NULL;					\
	int comp;							\
	while (tmp) {							\
		comp = cmp(elm, tmp);					\
		if (comp < 0) {						\
			res = tmp;					\
			tmp = RB_LEFT(tmp, field);			\
		}							\
		else if (comp > 0)					\
			tmp = RB_RIGHT(tmp, field);			\
		else							\
			return (tmp);					\
	}								\
	return (res);							\
}									\
									\
/* ARGSUSED */								\
attr struct type *							\
name##_RB_NEXT(struct type *elm)					\
{									\
	if (RB_RIGHT(elm, field)) {					\
		elm = RB_RIGHT(elm, field);				\
		while (RB_LEFT(elm, field))				\
			elm = RB_LEFT(elm, field);			\
	} else {							\
		if (RB_PARENT(elm, field) &&				\
		    (elm == RB_LEFT(RB_PARENT(elm, field), field)))	\
			elm = RB_PARENT(elm, field);			\
		else {							\
			while (RB_PARENT(elm, field) &&			\
			    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))\
				elm = RB_PARENT(elm, field);		\
			elm = RB_PARENT(elm, field);			\
		}							\
	}								\
	return (elm);							\
}									\
									\
/* ARGSUSED */								\
attr struct type *							\
name##_RB_PREV(struct type *elm)					\
{									\
	if (RB_LEFT(elm, field)) {					\
		elm = RB_LEFT(elm, field);				\
		while (RB_RIGHT(elm, field))				\
			elm = RB_RIGHT(elm, field);			\
	} else {							\
		if (RB_PARENT(elm, field) &&				\
		    (elm == RB_RIGHT(RB_PARENT(elm, field), field)))	\
			elm = RB_PARENT(elm, field);			\
		else {							\
			while (RB_PARENT(elm, field) &&			\
			    (elm == RB_LEFT(RB_PARENT(elm, field), field)))\
				elm = RB_PARENT(elm, field);		\
			elm = RB_PARENT(elm, field);			\
		}							\
	}								\
	return (elm);							\
}									\
									\
attr struct type *							\
name##_RB_MINMAX(struct name *head, int val)				\
{									\
	struct type *tmp = RB_ROOT(head);				\
	struct type *parent = NULL;					\
	while (tmp) {							\
		parent = tmp;						\
		if (val < 0)						\
			tmp = RB_LEFT(tmp, field);			\
		else							\
			tmp = RB_RIGHT(tmp, field);			\
	}								\
	return (parent);						\
}

#define RB_NEGINF	-1
#define RB_INF	1

#define RB_INSERT(name, x, y)	name##_RB_INSERT(x, y)
#define RB_REMOVE(name, x, y)	name##_RB_REMOVE(x, y)
#define RB_FIND(name, x, y)	name##_RB_FIND(x, y)
#define RB_NFIND(name, x, y)	name##_RB_NFIND(x, y)
#define RB_NEXT(name, x, y)	name##_RB_NEXT(y)
#define RB_PREV(name, x, y)	name##_RB_PREV(y)
#define RB_MIN(name, x)		name##_RB_MINMAX(x, RB_NEGINF)
#define RB_MAX(name, x)		name##_RB_MINMAX(x, RB_INF)

#define RB_FOREACH(x, name, head)					\
	for ((x) = RB_MIN(name, head);					\
	     (x) != NULL;						\
	     (x) = name##_RB_NEXT(x))

#define RB_FOREACH_SAFE(x, name, head, y)				\
	for ((x) = RB_MIN(name, head);					\
	    ((x) != NULL) && ((y) = name##_RB_NEXT(x), 1);		\
	     (x) = (y))

#define RB_FOREACH_REVERSE(x, name, head)				\
	for ((x) = RB_MAX(name, head);					\
	     (x) != NULL;						\
	     (x) = name##_RB_PREV(x))

#define RB_FOREACH_REVERSE_SAFE(x, name, head, y)			\
	for ((x) = RB_MAX(name, head);					\
	    ((x) != NULL) && ((y) = name##_RB_PREV(x), 1);		\
	     (x) = (y))


/*
 * Copyright (c) 2016 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct rb_type {
	int		(*t_compare)(const void *, const void *);
	void		(*t_augment)(void *);
	unsigned int	  t_offset;	/* offset of rb_entry in type */
};

struct rb_tree {
	struct rb_entry	*rbt_root;
};

struct rb_entry {
	struct rb_entry	 *rbt_parent;
	struct rb_entry	 *rbt_left;
	struct rb_entry	 *rbt_right;
	unsigned int	  rbt_color;
};

#define RBT_HEAD(_name, _type)						\
struct _name {								\
	struct rb_tree rbh_root;					\
}

#define RBT_ENTRY(_type)	struct rb_entry

static inline void
_rb_init(struct rb_tree *rbt)
{
	rbt->rbt_root = NULL;
}

static inline int
_rb_empty(struct rb_tree *rbt)
{
	return (rbt->rbt_root == NULL);
}

void	*_rb_insert(const struct rb_type *, struct rb_tree *, void *);
void	*_rb_remove(const struct rb_type *, struct rb_tree *, void *);
void	*_rb_find(const struct rb_type *, struct rb_tree *, const void *);
void	*_rb_nfind(const struct rb_type *, struct rb_tree *, const void *);
void	*_rb_root(const struct rb_type *, struct rb_tree *);
void	*_rb_min(const struct rb_type *, struct rb_tree *);
void	*_rb_max(const struct rb_type *, struct rb_tree *);
void	*_rb_next(const struct rb_type *, void *);
void	*_rb_prev(const struct rb_type *, void *);
void	*_rb_left(const struct rb_type *, void *);
void	*_rb_right(const struct rb_type *, void *);
void	*_rb_parent(const struct rb_type *, void *);
void	 _rb_set_left(const struct rb_type *, void *, void *);
void	 _rb_set_right(const struct rb_type *, void *, void *);
void	 _rb_set_parent(const struct rb_type *, void *, void *);
void	 _rb_poison(const struct rb_type *, void *, unsigned long);
int	 _rb_check(const struct rb_type *, void *, unsigned long);

#define RBT_INITIALIZER(_head)	{ { NULL } }

#define RBT_PROTOTYPE(_name, _type, _field, _cmp)			\
extern const struct rb_type *const _name##_RBT_TYPE;			\
									\
__unused static inline void						\
_name##_RBT_INIT(struct _name *head)					\
{									\
	_rb_init(&head->rbh_root);					\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_INSERT(struct _name *head, struct _type *elm)		\
{									\
	return _rb_insert(_name##_RBT_TYPE, &head->rbh_root, elm);	\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_REMOVE(struct _name *head, struct _type *elm)		\
{									\
	return _rb_remove(_name##_RBT_TYPE, &head->rbh_root, elm);	\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_FIND(struct _name *head, const struct _type *key)		\
{									\
	return _rb_find(_name##_RBT_TYPE, &head->rbh_root, key);	\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_NFIND(struct _name *head, const struct _type *key)		\
{									\
	return _rb_nfind(_name##_RBT_TYPE, &head->rbh_root, key);	\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_ROOT(struct _name *head)					\
{									\
	return _rb_root(_name##_RBT_TYPE, &head->rbh_root);		\
}									\
									\
__unused static inline int						\
_name##_RBT_EMPTY(struct _name *head)					\
{									\
	return _rb_empty(&head->rbh_root);				\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_MIN(struct _name *head)					\
{									\
	return _rb_min(_name##_RBT_TYPE, &head->rbh_root);		\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_MAX(struct _name *head)					\
{									\
	return _rb_max(_name##_RBT_TYPE, &head->rbh_root);		\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_NEXT(struct _type *elm)					\
{									\
	return _rb_next(_name##_RBT_TYPE, elm);				\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_PREV(struct _type *elm)					\
{									\
	return _rb_prev(_name##_RBT_TYPE, elm);				\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_LEFT(struct _type *elm)					\
{									\
	return _rb_left(_name##_RBT_TYPE, elm);				\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_RIGHT(struct _type *elm)					\
{									\
	return _rb_right(_name##_RBT_TYPE, elm);			\
}									\
									\
__unused static inline struct _type *					\
_name##_RBT_PARENT(struct _type *elm)					\
{									\
	return _rb_parent(_name##_RBT_TYPE, elm);			\
}									\
									\
__unused static inline void						\
_name##_RBT_SET_LEFT(struct _type *elm, struct _type *left)		\
{									\
	return _rb_set_left(_name##_RBT_TYPE, elm, left);		\
}									\
									\
__unused static inline void						\
_name##_RBT_SET_RIGHT(struct _type *elm, struct _type *right)		\
{									\
	return _rb_set_right(_name##_RBT_TYPE, elm, right);		\
}									\
									\
__unused static inline void						\
_name##_RBT_SET_PARENT(struct _type *elm, struct _type *parent)		\
{									\
	return _rb_set_parent(_name##_RBT_TYPE, elm, parent);		\
}									\
									\
__unused static inline void						\
_name##_RBT_POISON(struct _type *elm, unsigned long poison)		\
{									\
	return _rb_poison(_name##_RBT_TYPE, elm, poison);		\
}									\
									\
__unused static inline int						\
_name##_RBT_CHECK(struct _type *elm, unsigned long poison)		\
{									\
	return _rb_check(_name##_RBT_TYPE, elm, poison);		\
}

#define RBT_GENERATE_INTERNAL(_name, _type, _field, _cmp, _aug)		\
static int								\
_name##_RBT_COMPARE(const void *lptr, const void *rptr)			\
{									\
	const struct _type *l = lptr, *r = rptr;			\
	return _cmp(l, r);						\
}									\
static const struct rb_type _name##_RBT_INFO = {			\
	_name##_RBT_COMPARE,						\
	_aug,								\
	offsetof(struct _type, _field),					\
};									\
const struct rb_type *const _name##_RBT_TYPE = &_name##_RBT_INFO

#define RBT_GENERATE_AUGMENT(_name, _type, _field, _cmp, _aug)		\
static void								\
_name##_RBT_AUGMENT(void *ptr)						\
{									\
	struct _type *p = ptr;						\
	return _aug(p);							\
}									\
RBT_GENERATE_INTERNAL(_name, _type, _field, _cmp, _name##_RBT_AUGMENT)

#define RBT_GENERATE(_name, _type, _field, _cmp)			\
    RBT_GENERATE_INTERNAL(_name, _type, _field, _cmp, NULL)

#define RBT_INIT(_name, _head)		_name##_RBT_INIT(_head)
#define RBT_INSERT(_name, _head, _elm)	_name##_RBT_INSERT(_head, _elm)
#define RBT_REMOVE(_name, _head, _elm)	_name##_RBT_REMOVE(_head, _elm)
#define RBT_FIND(_name, _head, _key)	_name##_RBT_FIND(_head, _key)
#define RBT_NFIND(_name, _head, _key)	_name##_RBT_NFIND(_head, _key)
#define RBT_ROOT(_name, _head)		_name##_RBT_ROOT(_head)
#define RBT_EMPTY(_name, _head)		_name##_RBT_EMPTY(_head)
#define RBT_MIN(_name, _head)		_name##_RBT_MIN(_head)
#define RBT_MAX(_name, _head)		_name##_RBT_MAX(_head)
#define RBT_NEXT(_name, _elm)		_name##_RBT_NEXT(_elm)
#define RBT_PREV(_name, _elm)		_name##_RBT_PREV(_elm)
#define RBT_LEFT(_name, _elm)		_name##_RBT_LEFT(_elm)
#define RBT_RIGHT(_name, _elm)		_name##_RBT_RIGHT(_elm)
#define RBT_PARENT(_name, _elm)		_name##_RBT_PARENT(_elm)
#define RBT_SET_LEFT(_name, _elm, _l)	_name##_RBT_SET_LEFT(_elm, _l)
#define RBT_SET_RIGHT(_name, _elm, _r)	_name##_RBT_SET_RIGHT(_elm, _r)
#define RBT_SET_PARENT(_name, _elm, _p)	_name##_RBT_SET_PARENT(_elm, _p)
#define RBT_POISON(_name, _elm, _p)	_name##_RBT_POISON(_elm, _p)
#define RBT_CHECK(_name, _elm, _p)	_name##_RBT_CHECK(_elm, _p)

#define RBT_FOREACH(_e, _name, _head)					\
	for ((_e) = RBT_MIN(_name, (_head));				\
	     (_e) != NULL;						\
	     (_e) = RBT_NEXT(_name, (_e)))

#define RBT_FOREACH_SAFE(_e, _name, _head, _n)				\
	for ((_e) = RBT_MIN(_name, (_head));				\
	     (_e) != NULL && ((_n) = RBT_NEXT(_name, (_e)), 1);	\
	     (_e) = (_n))

#define RBT_FOREACH_REVERSE(_e, _name, _head)				\
	for ((_e) = RBT_MAX(_name, (_head));				\
	     (_e) != NULL;						\
	     (_e) = RBT_PREV(_name, (_e)))

#define RBT_FOREACH_REVERSE_SAFE(_e, _name, _head, _n)			\
	for ((_e) = RBT_MAX(_name, (_head));				\
	     (_e) != NULL && ((_n) = RBT_PREV(_name, (_e)), 1);	\
	     (_e) = (_n))

#endif	/* _SYS_TREE_H_ */
@


1.28
log
@port the RBT code to userland by making it part of libc.

src/lib/libc/gen/tree.c is a copy of src/sys/kern/subr_tree.c, but with
annotations for symbol visibility. changes to one should be reflected
in the other.

the malloc debug code that uses RB code is ported to RBT.

because libc provides the RBT code, procmap doesn't have to reach into
the kernel and build subr_tree.c itself now.

mild enthusiasm from many
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.27 2017/06/08 03:37:25 dlg Exp $	*/
d123 1
a123 1
static __inline struct type *						\
d134 1
a134 1
static __inline struct type *						\
d148 1
a148 1
static __inline struct type *						\
@


1.27
log
@remove the _rb_color prototype in RBT, it's unused/unimplimented
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.26 2017/06/08 03:12:53 dlg Exp $	*/
a790 2
#ifdef _KERNEL

a1004 2

#endif /* _KERNEL */
@


1.26
log
@add RBT_SET_LEFT, RBT_SET_RIGHT, and RBT_SET_PARENT

this are provided so an RBT and it's topology can be copied without
having to reinsert the copied nodes into a new tree.

there are two reasons RBT_LEFT/RIGHT/PARENT macros cant be used like
RB_LEFT/RIGHT/PARENT for this. firstly, RBT_LEFT and co are functions that
return a pointer value, they dont provide access to the pointer
itself for use as an lvalue that you can assign to. secondly, RBT
entries dont store pointers to other nodes, they point to the
RBT_ENTRY structures inside other nodes. this means that RBT_SET_LEFT
and co have to get an offset from the node to the RBT_ENTRY and
store that.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.25 2016/09/26 08:08:51 kettenis Exp $	*/
a819 1
void	*_rb_color(const struct rb_type *, void *);
@


1.25
log
@Mark the static inline functions defined by RBT_PROTOTYPE as __unused.  The
way these functions are generated through a macro makes clang think they're
defined in the .c file.  Since some of these function may be unused, clang
issues a warning.  Marking them as __unused suppresses the macro.

ok visa@@, deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.24 2016/09/15 06:07:22 dlg Exp $	*/
d817 3
d914 18
d983 3
@


1.24
log
@add RBT_POISON and RBT_CHECK so you can poison the pointers in RBT_ENTRYs

this seems like a better way forward than simply removing the
poisoning that uvm does.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.22 2016/09/15 01:05:15 dlg Exp $	*/
d826 1
a826 1
static inline void							\
d832 1
a832 1
static inline struct _type *						\
d838 1
a838 1
static inline struct _type *						\
d844 1
a844 1
static inline struct _type *						\
d850 1
a850 1
static inline struct _type *						\
d856 1
a856 1
static inline struct _type *						\
d862 1
a862 1
static inline int							\
d868 1
a868 1
static inline struct _type *						\
d874 1
a874 1
static inline struct _type *						\
d880 1
a880 1
static inline struct _type *						\
d886 1
a886 1
static inline struct _type *						\
d892 1
a892 1
static inline struct _type *						\
d898 1
a898 1
static inline struct _type *						\
d904 1
a904 1
static inline struct _type *						\
d910 1
a910 1
static inline void							\
d916 1
a916 1
static inline int							\
@


1.23
log
@rename the members of rb_entry so they dont keep working with RB macros
@
text
@d818 2
d908 12
d962 2
@


1.22
log
@enable the subr_tree version of red-black trees again.

the problem with the .h file pulling in sys/param.h for NULL, which
in turn goes and pulls in a ton of MI insanity, has been fixed.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.21 2016/09/09 20:31:46 millert Exp $	*/
d778 4
a781 4
	struct rb_entry	 *rbe_parent;
	struct rb_entry	 *rbe_left;
	struct rb_entry	 *rbe_right;
	unsigned int	  rbe_color;
@


1.21
log
@Include sys/_null.h for the NULL definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.20 2016/09/09 04:50:54 dlg Exp $	*/
a766 2
#if 0

d791 2
d969 1
a969 1
#endif /* 0 */
@


1.20
log
@disable subr_tree code for now
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.19 2016/09/09 02:00:14 dlg Exp $	*/
d30 2
a792 3
#ifdef _LOCORE
#include <sys/param.h> /* for NULL */

a967 2

#endif /* _LOCORE */
@


1.19
log
@quick fix for (more) userland breakage.

netstat includes a bunch of stuff with _KERNEL defined around it, which
i used here to scope the kernel api. the kernel api needs NULL, which
the kernel gets from sys/param.h, which then pulls in a bunch of machine
stuff and then it all goes horribly wrong on sparc64.

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.18 2016/09/06 06:56:30 dlg Exp $	*/
d765 2
d971 2
@


1.18
log
@store the offset of an rb_entry in a struct as an unsigned int.

this means users of the api dont need to know about size_t.

found by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.17 2016/09/05 23:43:13 dlg Exp $	*/
d789 1
a789 1
#ifdef _KERNEL
d968 1
a968 1
#endif /* _KERNEL */
@


1.17
log
@move the types for RBT out from under #ifdef _KERNEL

this lets userland understand kernel structures with RBT bits in them.

tested by a make build on amd64 and sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.16 2016/09/05 07:24:34 dlg Exp $	*/
d768 1
a768 1
	size_t		  t_offset;	/* offset of rb_entry in type */
@


1.16
log
@enable the subr_tree version of red-black trees
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.14 2015/05/25 03:07:49 deraadt Exp $	*/
a747 1
#ifdef _KERNEL
a764 2
#include <sys/param.h> /* for NULL */

d771 4
d782 9
a790 3
struct rb_tree {
	struct rb_entry	*rbt_root;
};
a817 5
#define RBT_HEAD(_name, _type)						\
struct _name {								\
	struct rb_tree rbh_root;					\
}

a818 2

#define RBT_ENTRY(_type)	struct rb_entry
@


1.15
log
@provide an implementation of red black trees using functions

the main goal of this change is to reduce the amount of code that
is generated as a result of using the macro implementation (RB_FOO)
of red black trees. on amd64 we should get a few dozen kilobytes
of code space back, and make red black trees more icache friendly
at the same time.

the new (RBT_FOO) implementation is modelled on the existing one,
but has some minor api variations. generally you can replace RB_
with RBT_ and get most of the way to converting code.

internally the red black tree functions all take an rb_type struct
that describes the layout of the object wired into a tree (ie, the
offset of the RBT_ENTRY inside a node), the comparison function,
and an optional augment function. because the functions are supposed
to be used for all types, they end up taking void * for the node
pointers instead of specific types. the tree is operated on as
pointers between the RBT_ENTRY structs instead of the nodes, which
gave me some type safety when implementing the code (cos casts
to/from void * dont ever fail, and continually calculating the
offset of the rb entry is annoying). RBT_ENTRYs are turned into
node pointers by prepending the offset stored in the rb_type struct
before theyre given to the comparison function or returned to the
caller.

to provide type safety on top of this, RBT_PROTOTYPE generates static
inline function wrappers that only take arguments of the right type,
and implicitly provide the rb_type struct argument to the actual
RBT functions. therefore the actual functions should never be called
directly, all calls should go through the RBT_ wrappers.

RBT_GENERATE is responsible for creating the rb_type struct used
by these wrappers. notably it also generates a wrapper around the
compare function so the user provided one must take the right types
instead of void *.

in terms of speed, this code is comparable to the macro implementation.
eg, insertion is very slightly slower in microbenchmarks, but
deletion appears to be significantly faster. this is possibly because
of the aggressive inlining ive done inside the delete codepaths.

the code is not yet wired into the kernel build.

it also needs to be said that there have been several attempts
before this to provide functions for at least some parts of the
kernels red black trees. that work made this a lot easier.

ok deraadt@@ jung@@ tedu@@
@
text
@d748 1
a748 1
#if 0 && defined(_KERNEL)
@


1.14
log
@a dreaded whitespace; Kyle Milz
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.13 2011/07/09 00:19:45 pirofti Exp $	*/
d747 222
@


1.13
log
@Add FOREACH_SAFE() data structure companions.

Part written by me, part taken from FreeBSD.

Okay guenther@@, oga@@ and probably matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.12 2009/03/02 09:42:55 mikeb Exp $	*/
d86 1
a86 1
	
@


1.12
log
@Fixup empty macro.  Original comment from harti at freebsd.org:

Make the default RB_AUGMENT() produce a 'do {} while (0)' instead
of nothing. This prevents the compiler from complaining about empty
if statements when compiled with higher WARN levels.

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.11 2008/05/11 22:19:09 millert Exp $	*/
d733 5
d742 5
@


1.11
log
@Add RB_PROTOTYPE_STATIC, RB_GENERATE_STATIC, RB_PREV, RB_NFIND,
and RB_FOREACH_REVERSE from FreeBSD.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.10 2007/10/29 23:49:41 djm Exp $	*/
d332 1
a332 1
#define RB_AUGMENT(x)
@


1.10
log
@remove extra backslash at the end of RB_PROTOTYPE, report from
Jan.Pechanec AT Sun.COM; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.9 2004/11/24 18:10:42 tdeval Exp $	*/
d376 15
a390 9
#define RB_PROTOTYPE(name, type, field, cmp)				\
void name##_RB_INSERT_COLOR(struct name *, struct type *);	\
void name##_RB_REMOVE_COLOR(struct name *, struct type *, struct type *);\
struct type *name##_RB_REMOVE(struct name *, struct type *);		\
struct type *name##_RB_INSERT(struct name *, struct type *);		\
struct type *name##_RB_FIND(struct name *, struct type *);		\
struct type *name##_RB_NEXT(struct type *);				\
struct type *name##_RB_MINMAX(struct name *, int);			

d395 6
a400 2
#define RB_GENERATE(name, type, field, cmp)				\
void									\
d444 1
a444 1
void									\
d520 1
a520 1
struct type *								\
d588 1
a588 1
struct type *								\
d619 1
a619 1
struct type *								\
d636 23
a658 1
struct type *								\
d679 23
a701 1
struct type *								\
d722 1
d724 1
d732 5
@


1.9
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.8 2004/04/24 18:11:46 frantzen Exp $	*/
d383 2
a384 2
struct type *name##_RB_MINMAX(struct name *, int);			\
									\
@


1.8
log
@sync to Niels Provos' version.  avoid unused variable warning in RB_NEXT()
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.7 2002/10/17 21:51:54 art Exp $	*/
d290 1
a290 1
/* Macros that define a red-back tree */
@


1.7
log
@When augmenting the nodes in RB_ROTATE_{RIGHT,LEFT} make sure that the
children nodes have reached their final state before augmenting the
parent.  This fixes an obscure inconsistency of the space in the
vm_map tree that gcc 3.2 triggers when compiling isp.o on alpha. (this
only led to some leaked space).

frantzen@@ provos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.6 2002/06/11 22:09:52 provos Exp $	*/
d382 1
a382 1
struct type *name##_RB_NEXT(struct name *, struct type *);		\
d627 1
a627 1
name##_RB_NEXT(struct name *head, struct type *elm)			\
d668 1
a668 1
#define RB_NEXT(name, x, y)	name##_RB_NEXT(x, y)
d675 1
a675 1
	     (x) = name##_RB_NEXT(head, x))
@


1.6
log
@have rb_remove return the right value, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.5 2002/06/11 18:59:22 provos Exp $	*/
a345 1
		RB_AUGMENT(RB_PARENT(elm, field));			\
d351 2
a365 1
		RB_AUGMENT(RB_PARENT(elm, field));			\
d371 2
@


1.5
log
@SPLAY_{INSERT,REMOVE} have return values now that can be used for error
checking
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.4 2002/03/26 02:47:28 hugh Exp $	*/
d377 1
a377 1
void name##_RB_REMOVE(struct name *, struct type *);			\
d508 1
a508 1
void									\
d511 1
a511 1
	struct type *child, *parent;					\
d518 1
a518 1
		struct type *old = elm, *left;				\
d572 1
@


1.4
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d117 2
d120 38
a157 1
static __inline void							\
d175 1
a175 1
		    return;						\
d178 1
d181 1
a181 1
static __inline void							\
d186 1
a186 1
		return;							\
d197 1
a198 11
}									\
									\
/* Finds the node with the same key as elm */				\
static __inline struct type *						\
name##_SPLAY_FIND(struct name *head, struct type *elm)			\
{									\
	if (SPLAY_EMPTY(head))						\
		return(NULL);						\
	name##_SPLAY(head, elm);					\
	if ((cmp)(elm, (head)->sph_root) == 0)				\
		return (head->sph_root);				\
d202 2
a203 26
static __inline struct type *						\
name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
{									\
	name##_SPLAY(head, elm);					\
	if (SPLAY_RIGHT(elm, field) != NULL) {				\
		elm = SPLAY_RIGHT(elm, field);				\
		while (SPLAY_LEFT(elm, field) != NULL) {		\
			elm = SPLAY_LEFT(elm, field);			\
		}							\
	} else								\
		elm = NULL;						\
	return (elm);							\
}									\
									\
static __inline struct type *						\
name##_SPLAY_MIN_MAX(struct name *head, int val)			\
{									\
	name##_SPLAY_MINMAX(head, val);					\
        return (SPLAY_ROOT(head));					\
}

/* Main splay operation.
 * Moves node close to the key of elm to top
 */
#define SPLAY_GENERATE(name, type, field, cmp)				\
void name##_SPLAY(struct name *head, struct type *elm)			\
@


1.4.4.1
log
@Sync UBC branch to -current
@
text
@@


1.4.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tree.h,v 1.4.4.1 2002/06/11 03:32:34 art Exp $	*/
a116 2
struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
d118 1
a118 38
/* Finds the node with the same key as elm */				\
static __inline struct type *						\
name##_SPLAY_FIND(struct name *head, struct type *elm)			\
{									\
	if (SPLAY_EMPTY(head))						\
		return(NULL);						\
	name##_SPLAY(head, elm);					\
	if ((cmp)(elm, (head)->sph_root) == 0)				\
		return (head->sph_root);				\
	return (NULL);							\
}									\
									\
static __inline struct type *						\
name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
{									\
	name##_SPLAY(head, elm);					\
	if (SPLAY_RIGHT(elm, field) != NULL) {				\
		elm = SPLAY_RIGHT(elm, field);				\
		while (SPLAY_LEFT(elm, field) != NULL) {		\
			elm = SPLAY_LEFT(elm, field);			\
		}							\
	} else								\
		elm = NULL;						\
	return (elm);							\
}									\
									\
static __inline struct type *						\
name##_SPLAY_MIN_MAX(struct name *head, int val)			\
{									\
	name##_SPLAY_MINMAX(head, val);					\
        return (SPLAY_ROOT(head));					\
}

/* Main splay operation.
 * Moves node close to the key of elm to top
 */
#define SPLAY_GENERATE(name, type, field, cmp)				\
struct type *								\
d136 1
a136 1
		    return ((head)->sph_root);				\
a138 1
    return (NULL);							\
d141 1
a141 1
struct type *								\
d146 1
a146 1
		return (NULL);						\
a156 1
		return (elm);						\
d158 11
d172 26
a197 2
void									\
name##_SPLAY(struct name *head, struct type *elm)			\
d340 1
a345 2
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
d359 1
a364 2
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
d371 1
a371 1
struct type *name##_RB_REMOVE(struct name *, struct type *);		\
d502 1
a502 1
struct type *								\
d505 1
a505 1
	struct type *child, *parent, *old = elm;			\
d512 1
a512 1
		struct type *left;					\
a565 1
	return (old);							\
@


1.3
log
@add {SPLAY,RB}_INITIALIZER and {SPLAY,RB}_EMPTY() to be more consistent
with queue.h. ok niels@@
@
text
@d1 1
@


1.2
log
@make SPLAY_MIN and SPLAY_MAX (and thus SPLAY_FOREACH) safe on an emptry tree
ok niels@@
@
text
@d61 3
d77 1
d120 1
a120 1
    if ((head)->sph_root == NULL) {					\
d144 1
a144 1
	if ((head)->sph_root == NULL)					\
d163 1
a163 1
	if ((head)->sph_root == NULL)					\
d273 1
a273 1
#define SPLAY_MIN(name, x)		((x)->sph_root == NULL ? NULL	\
d275 1
a275 1
#define SPLAY_MAX(name, x)		((x)->sph_root == NULL ? NULL	\
d289 3
d311 1
@


1.2.2.1
log
@Sync the SMP branch with 3.3
@
text
@a0 1
/*	$OpenBSD$	*/
a60 3
#define SPLAY_INITIALIZER(root)						\
	{ NULL }

a73 1
#define SPLAY_EMPTY(head)		(SPLAY_ROOT(head) == NULL)
a111 28
struct type *name##_SPLAY_INSERT(struct name *, struct type *);		\
struct type *name##_SPLAY_REMOVE(struct name *, struct type *);		\
									\
/* Finds the node with the same key as elm */				\
static __inline struct type *						\
name##_SPLAY_FIND(struct name *head, struct type *elm)			\
{									\
	if (SPLAY_EMPTY(head))						\
		return(NULL);						\
	name##_SPLAY(head, elm);					\
	if ((cmp)(elm, (head)->sph_root) == 0)				\
		return (head->sph_root);				\
	return (NULL);							\
}									\
									\
static __inline struct type *						\
name##_SPLAY_NEXT(struct name *head, struct type *elm)			\
{									\
	name##_SPLAY(head, elm);					\
	if (SPLAY_RIGHT(elm, field) != NULL) {				\
		elm = SPLAY_RIGHT(elm, field);				\
		while (SPLAY_LEFT(elm, field) != NULL) {		\
			elm = SPLAY_LEFT(elm, field);			\
		}							\
	} else								\
		elm = NULL;						\
	return (elm);							\
}									\
d113 1
a113 12
static __inline struct type *						\
name##_SPLAY_MIN_MAX(struct name *head, int val)			\
{									\
	name##_SPLAY_MINMAX(head, val);					\
        return (SPLAY_ROOT(head));					\
}

/* Main splay operation.
 * Moves node close to the key of elm to top
 */
#define SPLAY_GENERATE(name, type, field, cmp)				\
struct type *								\
d116 1
a116 1
    if (SPLAY_EMPTY(head)) {						\
d131 1
a131 1
		    return ((head)->sph_root);				\
a133 1
    return (NULL);							\
d136 1
a136 1
struct type *								\
d140 2
a141 2
	if (SPLAY_EMPTY(head))						\
		return (NULL);						\
a151 1
		return (elm);						\
d153 11
d167 26
a192 2
void									\
name##_SPLAY(struct name *head, struct type *elm)			\
d269 1
a269 1
#define SPLAY_MIN(name, x)		(SPLAY_EMPTY(x) ? NULL	\
d271 1
a271 1
#define SPLAY_MAX(name, x)		(SPLAY_EMPTY(x) ? NULL	\
a284 3
#define RB_INITIALIZER(root)						\
	{ NULL }

a303 1
#define RB_EMPTY(head)			(RB_ROOT(head) == NULL)
d331 1
a336 2
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
d350 1
a355 2
	if ((RB_PARENT(tmp, field)))					\
		RB_AUGMENT(RB_PARENT(tmp, field));			\
d362 1
a362 1
struct type *name##_RB_REMOVE(struct name *, struct type *);		\
d493 1
a493 1
struct type *								\
d496 1
a496 1
	struct type *child, *parent, *old = elm;			\
d503 1
a503 1
		struct type *left;					\
a556 1
	return (old);							\
@


1.2.2.2
log
@Merge with the trunk
@
text
@d382 1
a382 1
struct type *name##_RB_NEXT(struct type *);				\
d627 1
a627 1
name##_RB_NEXT(struct type *elm)					\
d668 1
a668 1
#define RB_NEXT(name, x, y)	name##_RB_NEXT(y)
d675 1
a675 1
	     (x) = name##_RB_NEXT(x))
@


1.1
log
@queue.h like implementation of splay and red-black trees
@
text
@d269 4
a272 2
#define SPLAY_MIN(name, x)		name##_SPLAY_MIN_MAX(x, SPLAY_NEGINF)
#define SPLAY_MAX(name, x)		name##_SPLAY_MIN_MAX(x, SPLAY_INF)
@

