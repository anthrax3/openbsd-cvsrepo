head	1.25;
access;
symbols
	OPENBSD_6_1:1.25.0.10
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.20.0.4
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.20
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.18
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.14
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.16
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.12
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.10
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.8
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.6
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.4
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3;
locks; strict;
comment	@ * @;


1.25
date	2014.12.21.04.49.00;	author guenther;	state Exp;
branches;
next	1.24;
commitid	WQQl4kx6dxIdDFg9;

1.24
date	2014.07.20.21.41.54;	author guenther;	state Exp;
branches;
next	1.23;
commitid	3jboTsTaqgPkE4Z9;

1.23
date	2014.07.12.16.25.08;	author guenther;	state Exp;
branches;
next	1.22;
commitid	r9gXh8PA6rI3P7q2;

1.22
date	2014.07.10.03.16.13;	author dlg;	state Exp;
branches;
next	1.21;
commitid	9BlGNkTpVUnsDaYd;

1.21
date	2014.03.14.10.47.21;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2013.08.20.12.55.02;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.24.22.44.59;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.03.27.07.09.24;	author otto;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.06.18.53.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.14.18.28.40;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.11.19.17.31;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.26.17.06.50;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.21.18.11.26;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.21.10.50.15;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.03.20.49.29;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.01.02.17.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.01.23.50;	author mickey;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.25.21.43.29;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.21.05.58.25;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	97.11.30.18.50.17;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.10.10.29.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	97.11.09.23.04.58;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.07.04.11.00.17;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.4.4.6;

1.4.4.6
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@<sys/endian.h> needs <sys/cdefs.h>

found previously by someone whose email I've lost; rediscovered by miod@@
ok millert@@ deraadt@@
@
text
@/*	$OpenBSD: endian.h,v 1.24 2014/07/20 21:41:54 guenther Exp $	*/

/*-
 * Copyright (c) 1997 Niklas Hallqvist.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Public definitions for little- and big-endian systems.
 * This file should be included as <endian.h> in userspace and as
 * <sys/endian.h> in the kernel.
 *
 * System headers that need endian information but that can't or don't
 * want to export the public names here should include <sys/_endian.h>
 * and use the internal names: _BYTE_ORDER, _*_ENDIAN, etc.
 */

#ifndef _SYS_ENDIAN_H_
#define _SYS_ENDIAN_H_

#include <sys/cdefs.h>
#include <sys/_endian.h>

/* Public names */
#define LITTLE_ENDIAN	_LITTLE_ENDIAN
#define BIG_ENDIAN	_BIG_ENDIAN
#define PDP_ENDIAN	_PDP_ENDIAN
#define BYTE_ORDER	_BYTE_ORDER


/*
 * These are specified to be function-like macros to match the spec
 */
#define htobe16(x)	__htobe16(x)
#define htobe32(x)	__htobe32(x)
#define htobe64(x)	__htobe64(x)
#define htole16(x)	__htole16(x)
#define htole32(x)	__htole32(x)
#define htole64(x)	__htole64(x)

/* POSIX names */
#define be16toh(x)	__htobe16(x)
#define be32toh(x)	__htobe32(x)
#define be64toh(x)	__htobe64(x)
#define le16toh(x)	__htole16(x)
#define le32toh(x)	__htole32(x)
#define le64toh(x)	__htole64(x)


#if __BSD_VISIBLE
#define swap16(x) __swap16(x)
#define swap32(x) __swap32(x)
#define swap64(x) __swap64(x)

#define swap16_multi(v, n) do {						\
	__size_t __swap16_multi_n = (n);				\
	__uint16_t *__swap16_multi_v = (v);				\
									\
	while (__swap16_multi_n) {					\
		*__swap16_multi_v = swap16(*__swap16_multi_v);		\
		__swap16_multi_v++;					\
		__swap16_multi_n--;					\
	}								\
} while (0)

/* original BSD names */
#define betoh16(x)	__htobe16(x)
#define betoh32(x)	__htobe32(x)
#define betoh64(x)	__htobe64(x)
#define letoh16(x)	__htole16(x)
#define letoh32(x)	__htole32(x)
#define letoh64(x)	__htole64(x)

#ifndef htons
/* these were exposed here before */
#define htons(x)	__htobe16(x)
#define htonl(x)	__htobe32(x)
#define ntohs(x)	__htobe16(x)
#define ntohl(x)	__htobe32(x)
#endif

/* ancient stuff */
#define	NTOHL(x) (x) = ntohl((u_int32_t)(x))
#define	NTOHS(x) (x) = ntohs((u_int16_t)(x))
#define	HTONL(x) (x) = htonl((u_int32_t)(x))
#define	HTONS(x) (x) = htons((u_int16_t)(x))
#endif /* __BSD_VISIBLE */

#ifdef _KERNEL
/* to/from memory conversions */
#define bemtoh16	__bemtoh16
#define bemtoh32	__bemtoh32
#define bemtoh64	__bemtoh64
#define htobem16	__htobem16
#define htobem32	__htobem32
#define htobem64	__htobem64
#define lemtoh16	__lemtoh16
#define lemtoh32	__lemtoh32
#define lemtoh64	__lemtoh64
#define htolem16	__htolem16
#define htolem32	__htolem32
#define htolem64	__htolem64
#endif /* _KERNEL */

#endif /* _SYS_ENDIAN_H_ */
@


1.24
log
@Provide correct guidance on which header to use in the comments
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.23 2014/07/12 16:25:08 guenther Exp $	*/
d40 1
@


1.23
log
@Tackle the endian.h mess.  Make it so that:
 * you can #include <sys/endian.h> instead of <machine/endian.h>,
   and ditto <endian.h>  (fixes code that pulls in <sys/endian.h> first)

 * those will always export the symbols that POSIX specified for
   <endian.h>, including the new {be,le}{16,32,64}toh() set.  c.f.
	http://austingroupbugs.net/view.php?id=162

   if __BSD_VISIBLE then you also get the symbols that our <machine/endian.h>
   currently exports (ntohs, NTOHS, dlg's bemtoh*, etc)

 * when doing POSIX compiles (not __BSD_VISIBLE), then <netinet/in.h> and
   <arpa/inet.h> will *stop* exporting the extra symbols like BYTE_ORDER
   and betoh*

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.22 2014/07/10 03:16:13 dlg Exp $	*/
d28 3
a30 2
 * Generic definitions for little- and big-endian systems.  Other endianesses
 * has to be dealt with in the specific machine/endian.h file for that port.
d32 3
a34 3
 * This file is meant to be included from a little- or big-endian port's
 * machine/endian.h after setting _BYTE_ORDER to either 1234 for little endian
 * or 4321 for big..
@


1.22
log
@guenther spotted my bad copy and pasting.

fall back to htobe64 for htobem64 instead of htole64 on LE archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.21 2014/03/14 10:47:21 dlg Exp $	*/
d39 1
a39 2
#include <sys/cdefs.h>
#include <sys/_types.h>
d41 1
a41 5
#define _LITTLE_ENDIAN	1234
#define _BIG_ENDIAN	4321
#define _PDP_ENDIAN	3412

#if __BSD_VISIBLE
a45 1
#endif
a46 53
#ifdef __GNUC__

#define __swap16gen(x) __statement({					\
	__uint16_t __swap16gen_x = (x);					\
									\
	(__uint16_t)((__swap16gen_x & 0xff) << 8 |			\
	    (__swap16gen_x & 0xff00) >> 8);				\
})

#define __swap32gen(x) __statement({					\
	__uint32_t __swap32gen_x = (x);					\
									\
	(__uint32_t)((__swap32gen_x & 0xff) << 24 |			\
	    (__swap32gen_x & 0xff00) << 8 |				\
	    (__swap32gen_x & 0xff0000) >> 8 |				\
	    (__swap32gen_x & 0xff000000) >> 24);			\
})

#define __swap64gen(x) __statement({					\
	__uint64_t __swap64gen_x = (x);					\
									\
	(__uint64_t)((__swap64gen_x & 0xff) << 56 |			\
	    (__swap64gen_x & 0xff00ULL) << 40 |				\
	    (__swap64gen_x & 0xff0000ULL) << 24 |			\
	    (__swap64gen_x & 0xff000000ULL) << 8 |			\
	    (__swap64gen_x & 0xff00000000ULL) >> 8 |			\
	    (__swap64gen_x & 0xff0000000000ULL) >> 24 |			\
	    (__swap64gen_x & 0xff000000000000ULL) >> 40 |		\
	    (__swap64gen_x & 0xff00000000000000ULL) >> 56);		\
})

#else /* __GNUC__ */

/* Note that these macros evaluate their arguments several times.  */
#define __swap16gen(x)							\
    (__uint16_t)(((__uint16_t)(x) & 0xffU) << 8 | ((__uint16_t)(x) & 0xff00U) >> 8)

#define __swap32gen(x)							\
    (__uint32_t)(((__uint32_t)(x) & 0xff) << 24 |			\
    ((__uint32_t)(x) & 0xff00) << 8 | ((__uint32_t)(x) & 0xff0000) >> 8 |\
    ((__uint32_t)(x) & 0xff000000) >> 24)

#define __swap64gen(x)							\
	(__uint64_t)((((__uint64_t)(x) & 0xff) << 56) |			\
	    ((__uint64_t)(x) & 0xff00ULL) << 40 |			\
	    ((__uint64_t)(x) & 0xff0000ULL) << 24 |			\
	    ((__uint64_t)(x) & 0xff000000ULL) << 8 |			\
	    ((__uint64_t)(x) & 0xff00000000ULL) >> 8 |			\
	    ((__uint64_t)(x) & 0xff0000000000ULL) >> 24 |		\
	    ((__uint64_t)(x) & 0xff000000000000ULL) >> 40 |		\
	    ((__uint64_t)(x) & 0xff00000000000000ULL) >> 56)

#endif /* __GNUC__ */
d49 1
a49 4
 * Define MD_SWAP if you provide swap{16,32}md functions/macros that are
 * optimized for your architecture,  These will be used for swap{16,32}
 * unless the argument is a constant and we are using GCC, where we can
 * take advantage of the CSE phase much better by using the generic version.
d51 14
a64 2
#ifdef MD_SWAP
#if __GNUC__
a65 6
#define __swap16(x) __statement({					\
	__uint16_t __swap16_x = (x);					\
									\
	__builtin_constant_p(x) ? __swap16gen(__swap16_x) :		\
	    __swap16md(__swap16_x);					\
})
d67 4
a70 6
#define __swap32(x) __statement({					\
	__uint32_t __swap32_x = (x);					\
									\
	__builtin_constant_p(x) ? __swap32gen(__swap32_x) :		\
	    __swap32md(__swap32_x);					\
})
d72 1
a72 16
#define __swap64(x) __statement({					\
	__uint64_t __swap64_x = (x);					\
									\
	__builtin_constant_p(x) ? __swap64gen(__swap64_x) :		\
	    __swap64md(__swap64_x);					\
})

#endif /* __GNUC__  */

#else /* MD_SWAP */
#define __swap16 __swap16gen
#define __swap32 __swap32gen
#define __swap64 __swap64gen
#endif /* MD_SWAP */

#define __swap16_multi(v, n) do {						\
d83 14
a96 31
#if __BSD_VISIBLE
#define swap16 __swap16
#define swap32 __swap32
#define swap64 __swap64
#define swap16_multi __swap16_multi

__BEGIN_DECLS
__uint64_t	htobe64(__uint64_t);
__uint32_t	htobe32(__uint32_t);
__uint16_t	htobe16(__uint16_t);
__uint64_t	betoh64(__uint64_t);
__uint32_t	betoh32(__uint32_t);
__uint16_t	betoh16(__uint16_t);

__uint64_t	htole64(__uint64_t);
__uint32_t	htole32(__uint32_t);
__uint16_t	htole16(__uint16_t);
__uint64_t	letoh64(__uint64_t);
__uint32_t	letoh32(__uint32_t);
__uint16_t	letoh16(__uint16_t);
__END_DECLS
#endif /* __BSD_VISIBLE */

#if _BYTE_ORDER == _LITTLE_ENDIAN

/* Can be overridden by machine/endian.h before inclusion of this file.  */
#ifndef _QUAD_HIGHWORD
#define _QUAD_HIGHWORD 1
#endif
#ifndef _QUAD_LOWWORD
#define _QUAD_LOWWORD 0
d99 5
a103 81
#if __BSD_VISIBLE
#define htobe16 __swap16
#define htobe32 __swap32
#define htobe64 __swap64
#define betoh16 __swap16
#define betoh32 __swap32
#define betoh64 __swap64

#define htole16(x) ((__uint16_t)(x))
#define htole32(x) ((__uint32_t)(x))
#define htole64(x) ((__uint64_t)(x))
#define letoh16(x) ((__uint16_t)(x))
#define letoh32(x) ((__uint32_t)(x))
#define letoh64(x) ((__uint64_t)(x))
#endif /* __BSD_VISIBLE */

#define htons(x) __swap16(x)
#define htonl(x) __swap32(x)
#define ntohs(x) __swap16(x)
#define ntohl(x) __swap32(x)

#ifdef _KERNEL

#ifdef MD_SWAPIO

#define bemtoh16(_x) __mswap16(_x)
#define bemtoh32(_x) __mswap32(_x)
#define bemtoh64(_x) __mswap64(_x)

#define htobem16(_x, _v) __swapm16((_x), (_v))
#define htobem32(_x, _v) __swapm32((_x), (_v))
#define htobem64(_x, _v) __swapm64((_x), (_v))

#else /* MD_SWAPIO */

#define bemtoh16(_x) htobe16(*(__uint16_t *)(_x))
#define bemtoh32(_x) htobe32(*(__uint32_t *)(_x))
#define bemtoh64(_x) htobe64(*(__uint64_t *)(_x))

#define htobem16(_x, _v) (*(__uint16_t *)(_x) = htobe16(_v))
#define htobem32(_x, _v) (*(__uint32_t *)(_x) = htobe32(_v))
#define htobem64(_x, _v) (*(__uint64_t *)(_x) = htobe64(_v))

#endif /* MD_SWAPIO */

#define lemtoh16(_x) (*(__uint16_t *)(_x))
#define lemtoh32(_x) (*(__uint32_t *)(_x))
#define lemtoh64(_x) (*(__uint64_t *)(_x))

#define htolem16(_x, _v) (*(__uint16_t *)(_x) = (__uint16_t)(_v))
#define htolem32(_x, _v) (*(__uint32_t *)(_x) = (__uint32_t)(_v))
#define htolem64(_x, _v) (*(__uint64_t *)(_x) = (__uint64_t)(_v))

#endif /* _KERNEL */

#endif /* _BYTE_ORDER == _LITTLE_ENDIAN */

#if _BYTE_ORDER == _BIG_ENDIAN

/* Can be overridden by machine/endian.h before inclusion of this file.  */
#ifndef _QUAD_HIGHWORD
#define _QUAD_HIGHWORD 0
#endif
#ifndef _QUAD_LOWWORD
#define _QUAD_LOWWORD 1
#endif

#if __BSD_VISIBLE
#define htole16 __swap16
#define htole32 __swap32
#define htole64 __swap64
#define letoh16 __swap16
#define letoh32 __swap32
#define letoh64 __swap64

#define htobe16(x) ((__uint16_t)(x))
#define htobe32(x) ((__uint32_t)(x))
#define htobe64(x) ((__uint64_t)(x))
#define betoh16(x) ((__uint16_t)(x))
#define betoh32(x) ((__uint32_t)(x))
#define betoh64(x) ((__uint64_t)(x))
a105 5
#define htons(x) ((__uint16_t)(x))
#define htonl(x) ((__uint32_t)(x))
#define ntohs(x) ((__uint16_t)(x))
#define ntohl(x) ((__uint32_t)(x))

d107 13
a119 31

#ifdef MD_SWAPIO

#define lemtoh16(_x) __mswap16(_x)
#define lemtoh32(_x) __mswap32(_x)
#define lemtoh64(_x) __mswap64(_x)

#define htolem16(_x, _v) __swapm16((_x), (_v))
#define htolem32(_x, _v) __swapm32((_x), (_v))
#define htolem64(_x, _v) __swapm64((_x), (_v))

#else /* MD_SWAPIO */

#define lemtoh16(_x) htole16(*(__uint16_t *)(_x))
#define lemtoh32(_x) htole32(*(__uint32_t *)(_x))
#define lemtoh64(_x) htole64(*(__uint64_t *)(_x))

#define htolem16(_x, _v) (*(__uint16_t *)(_x) = htole16(_v))
#define htolem32(_x, _v) (*(__uint32_t *)(_x) = htole32(_v))
#define htolem64(_x, _v) (*(__uint64_t *)(_x) = htole64(_v))

#endif /* MD_SWAPIO */

#define bemtoh16(_x) (*(__uint16_t *)(_x))
#define bemtoh32(_x) (*(__uint32_t *)(_x))
#define bemtoh64(_x) (*(__uint64_t *)(_x))

#define htobem16(_x, _v) (*(__uint16_t *)(_x) = (__uint16_t)(_v))
#define htobem32(_x, _v) (*(__uint32_t *)(_x) = (__uint32_t)(_v))
#define htobem64(_x, _v) (*(__uint64_t *)(_x) = (__uint64_t)(_v))

a120 9

#endif /* _BYTE_ORDER == _BIG_ENDIAN */

#if __BSD_VISIBLE
#define	NTOHL(x) (x) = ntohl((u_int32_t)(x))
#define	NTOHS(x) (x) = ntohs((u_int16_t)(x))
#define	HTONL(x) (x) = htonl((u_int32_t)(x))
#define	HTONS(x) (x) = htons((u_int16_t)(x))
#endif
@


1.21
log
@provide an MI api for doing byteswapping loads and stores. some
archs have instrutions that can do this, and the rest that dont get
to use wrappers around the byteswap(3) api.

this provides MI backends for sparc64 and powerpc which get a big
benefit from this because byteswapping in registers is really hard
for them.

the intended use case is for reading and writing bits of dma memory
handed to and from hardware.

discussed with miod@@ guenther@@ deraadt@@
ok miod@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.20 2013/08/20 12:55:02 kettenis Exp $	*/
d230 1
a230 1
#define htobem64(_x, _v) (*(__uint64_t *)(_x) = htole64(_v))
@


1.20
log
@Include <sys/_types.h> to make this header a little bit more self-contained.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.19 2011/06/24 22:44:59 deraadt Exp $	*/
d210 35
a244 1
#endif /* _BYTE_ORDER */
d277 35
a311 1
#endif /* _BYTE_ORDER */
@


1.19
log
@When converting endian to same-endian, the macros should cast to unsigned
so that signedness of the input is suppressed.
ok matthew miod kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.18 2006/03/27 07:09:24 otto Exp $	*/
d40 1
@


1.18
log
@Kill lint warning by using unsigned right hand arg to >>
Right shifting signed values is undefined. From claudio@@
ok millert@@; comitted by request of deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.17 2006/01/06 18:53:05 millert Exp $	*/
d196 6
a201 6
#define htole16(x) (x)
#define htole32(x) (x)
#define htole64(x) (x)
#define letoh16(x) (x)
#define letoh32(x) (x)
#define letoh64(x) (x)
d229 6
a234 6
#define htobe16(x) (x)
#define htobe32(x) (x)
#define htobe64(x) (x)
#define betoh16(x) (x)
#define betoh32(x) (x)
#define betoh64(x) (x)
d237 4
a240 4
#define htons(x) (x)
#define htonl(x) (x)
#define ntohs(x) (x)
#define ntohl(x) (x)
@


1.17
log
@Adapt things to use __type_t instead of _BSD_TYPE_T_
Add new sys/_types.h header
Include machine/_types.h or sys/_types.h where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.16 2005/12/14 18:28:40 millert Exp $	*/
d87 1
a87 1
    (__uint16_t)(((__uint16_t)(x) & 0xff) << 8 | ((__uint16_t)(x) & 0xff00) >> 8)
@


1.16
log
@Add a __statement macro to use with gcc statement expressions instead
of using __extension__ directly.  This lets us define away the whole
thing when lint is in use.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.15 2005/12/13 00:35:23 millert Exp $	*/
d55 1
a55 1
	u_int16_t __swap16gen_x = (x);					\
d57 1
a57 1
	(u_int16_t)((__swap16gen_x & 0xff) << 8 |			\
d62 1
a62 1
	u_int32_t __swap32gen_x = (x);					\
d64 1
a64 1
	(u_int32_t)((__swap32gen_x & 0xff) << 24 |			\
d71 1
a71 1
	u_int64_t __swap64gen_x = (x);					\
d73 1
a73 1
	(u_int64_t)((__swap64gen_x & 0xff) << 56 |			\
d87 1
a87 1
    (u_int16_t)(((u_int16_t)(x) & 0xff) << 8 | ((u_int16_t)(x) & 0xff00) >> 8)
d90 3
a92 3
    (u_int32_t)(((u_int32_t)(x) & 0xff) << 24 |				\
    ((u_int32_t)(x) & 0xff00) << 8 | ((u_int32_t)(x) & 0xff0000) >> 8 |	\
    ((u_int32_t)(x) & 0xff000000) >> 24)
d95 8
a102 8
	(u_int64_t)((((u_int64_t)(x) & 0xff) << 56) |			\
	    ((u_int64_t)(x) & 0xff00ULL) << 40 |			\
	    ((u_int64_t)(x) & 0xff0000ULL) << 24 |			\
	    ((u_int64_t)(x) & 0xff000000ULL) << 8 |			\
	    ((u_int64_t)(x) & 0xff00000000ULL) >> 8 |			\
	    ((u_int64_t)(x) & 0xff0000000000ULL) >> 24 |		\
	    ((u_int64_t)(x) & 0xff000000000000ULL) >> 40 |		\
	    ((u_int64_t)(x) & 0xff00000000000000ULL) >> 56)
d116 1
a116 1
	u_int16_t __swap16_x = (x);					\
d123 1
a123 1
	u_int32_t __swap32_x = (x);					\
d130 1
a130 1
	u_int64_t __swap64_x = (x);					\
d145 2
a146 2
	size_t __swap16_multi_n = (n);					\
	u_int16_t *__swap16_multi_v = (v);				\
d162 13
a174 13
u_int64_t	htobe64(u_int64_t);
u_int32_t	htobe32(u_int32_t);
u_int16_t	htobe16(u_int16_t);
u_int64_t	betoh64(u_int64_t);
u_int32_t	betoh32(u_int32_t);
u_int16_t	betoh16(u_int16_t);

u_int64_t	htole64(u_int64_t);
u_int32_t	htole32(u_int32_t);
u_int16_t	htole16(u_int16_t);
u_int64_t	letoh64(u_int64_t);
u_int32_t	letoh32(u_int32_t);
u_int16_t	letoh16(u_int16_t);
@


1.15
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.14 2004/01/11 19:17:31 brad Exp $	*/
d54 1
a54 1
#define __swap16gen(x) __extension__({					\
d61 1
a61 1
#define __swap32gen(x) __extension__({					\
d70 1
a70 1
#define __swap64gen(x) __extension__({					\
d115 1
a115 1
#define __swap16(x) __extension__({					\
d122 1
a122 1
#define __swap32(x) __extension__({					\
d129 1
a129 1
#define __swap64(x) __extension__({					\
@


1.14
log
@mark u_int64_t constants with ULL to make gcc3 happy

ok drahn@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.13 2003/09/26 17:06:50 fgsch Exp $	*/
d32 1
a32 1
 * machine/endian.h after setting BYTE_ORDER to either 1234 for little endian
a38 2
#ifndef _POSIX_SOURCE

d41 10
a50 5
#define LITTLE_ENDIAN	1234


#define BIG_ENDIAN	4321
#define PDP_ENDIAN	3412
d115 1
a115 1
#define swap16(x) __extension__({					\
d122 1
a122 1
#define swap32(x) __extension__({					\
d129 1
a129 1
#define swap64(x) __extension__({					\
d139 3
a141 3
#define swap16 __swap16gen
#define swap32 __swap32gen
#define swap64 __swap64gen
d144 1
a144 1
#define swap16_multi(v, n) do {						\
d155 6
d176 1
d178 1
a178 1
#if BYTE_ORDER == LITTLE_ENDIAN
d188 7
a194 6
#define htobe16 swap16
#define htobe32 swap32
#define htobe64 swap64
#define betoh16 swap16
#define betoh32 swap32
#define betoh64 swap64
d202 6
d209 1
a209 1
#endif /* BYTE_ORDER */
d211 1
a211 1
#if BYTE_ORDER == BIG_ENDIAN
d221 7
a227 6
#define htole16 swap16
#define htole32 swap32
#define htole64 swap64
#define letoh16 swap16
#define letoh32 swap32
#define letoh64 swap64
d235 1
d237 4
a240 1
#endif /* BYTE_ORDER */
d242 1
a242 4
#define htons htobe16
#define htonl htobe32
#define ntohs betoh16
#define ntohl betoh32
d244 1
d249 1
a250 1
#endif /* _POSIX_SOURCE */
@


1.13
log
@put 64bit macros/functions documentation back.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.11 2003/09/21 10:50:15 fgsch Exp $	*/
d71 7
a77 7
	    (__swap64gen_x & 0xff00) << 40 |				\
	    (__swap64gen_x & 0xff0000) << 24 |				\
	    (__swap64gen_x & 0xff000000) << 8 |				\
	    (__swap64gen_x & 0xff00000000) >> 8 |			\
	    (__swap64gen_x & 0xff0000000000) >> 24 |			\
	    (__swap64gen_x & 0xff000000000000) >> 40 |			\
	    (__swap64gen_x & 0xff00000000000000) >> 56);		\
d93 7
a99 7
	    ((u_int64_t)(x) & 0xff00) << 40 |				\
	    ((u_int64_t)(x) & 0xff0000) << 24 |				\
	    ((u_int64_t)(x) & 0xff000000) << 8 |			\
	    ((u_int64_t)(x) & 0xff00000000) >> 8 |			\
	    ((u_int64_t)(x) & 0xff0000000000) >> 24 |			\
	    ((u_int64_t)(x) & 0xff000000000000) >> 40 |			\
	    ((u_int64_t)(x) & 0xff00000000000000) >> 56)
@


1.12
log
@revert for now.
@
text
@d153 1
d156 1
d160 1
d163 1
@


1.11
log
@document and declare 64-bit function/macros. ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.9 2003/05/01 02:17:28 millert Exp $	*/
a152 1
u_int64_t	htobe64(u_int64_t);
a154 1
u_int64_t	betoh64(u_int64_t);
a157 1
u_int64_t	htole64(u_int64_t);
a159 1
u_int64_t	letoh64(u_int64_t);
@


1.10
log
@fix various 3/4 licenses according to "terms" file
@
text
@d153 1
d156 1
d160 1
d163 1
@


1.9
log
@Fix unbalanced parens in __swap64gen macro for non-gcc; Hugh C Kennedy
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.8 2002/03/14 01:27:14 millert Exp $	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.7 2001/06/27 01:23:50 mickey Exp $	*/
d97 1
a97 1
	(u_int64_t)(((u_int64_t)(x) & 0xff) << 56) |			\
@


1.7
log
@implement md 64 bit swaps; niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.6 2001/06/22 14:11:00 deraadt Exp $	*/
d158 9
a166 9
u_int32_t	htobe32 __P((u_int32_t));
u_int16_t	htobe16 __P((u_int16_t));
u_int32_t	betoh32 __P((u_int32_t));
u_int16_t	betoh16 __P((u_int16_t));

u_int32_t	htole32 __P((u_int32_t));
u_int16_t	htole16 __P((u_int16_t));
u_int32_t	letoh32 __P((u_int32_t));
u_int16_t	letoh16 __P((u_int16_t));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.7 2001/06/27 01:23:50 mickey Exp $	*/
d158 9
a166 9
u_int32_t	htobe32(u_int32_t);
u_int16_t	htobe16(u_int16_t);
u_int32_t	betoh32(u_int32_t);
u_int16_t	betoh16(u_int16_t);

u_int32_t	htole32(u_int32_t);
u_int16_t	htole16(u_int16_t);
u_int32_t	letoh32(u_int32_t);
u_int16_t	letoh16(u_int16_t);
@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
a97 1
	(u_int64_t)((((u_int64_t)(x) & 0xff) << 56) |			\
@


1.6
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.5 2000/10/25 21:43:29 deraadt Exp $	*/
d72 13
d96 10
d131 7
d143 1
d181 1
d184 1
d188 1
d191 1
d207 1
d210 1
d214 1
d217 1
@


1.5
log
@mark swap16() and swap32() with __extension__; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.4 1999/07/21 05:58:25 csapuntz Exp $	*/
d115 1
a115 1
#define swap16_multi(v, n) do {					        \
@


1.4
log
@

swap16_multi by niklas@@cvs.openbsd.org

Fix cd.c so it compiles on big-endian platforms
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.3 1997/11/30 18:50:17 millert Exp $	*/
d56 1
a56 1
#define __swap16gen(x) ({						\
d63 1
a63 1
#define __swap32gen(x) ({						\
d94 1
a94 1
#define swap16(x) ({							\
d101 1
a101 1
#define swap32(x) ({							\
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.5 2000/10/25 21:43:29 deraadt Exp $	*/
d56 1
a56 1
#define __swap16gen(x) __extension__({					\
d63 1
a63 1
#define __swap32gen(x) __extension__({					\
d94 1
a94 1
#define swap16(x) __extension__({					\
d101 1
a101 1
#define swap32(x) __extension__({					\
@


1.4.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.4.4.1 2001/05/14 22:45:01 niklas Exp $	*/
a71 13
#define __swap64gen(x) __extension__({					\
	u_int64_t __swap64gen_x = (x);					\
									\
	(u_int64_t)((__swap64gen_x & 0xff) << 56 |			\
	    (__swap64gen_x & 0xff00) << 40 |				\
	    (__swap64gen_x & 0xff0000) << 24 |				\
	    (__swap64gen_x & 0xff000000) << 8 |				\
	    (__swap64gen_x & 0xff00000000) >> 8 |			\
	    (__swap64gen_x & 0xff0000000000) >> 24 |			\
	    (__swap64gen_x & 0xff000000000000) >> 40 |			\
	    (__swap64gen_x & 0xff00000000000000) >> 56);		\
})

a82 10
#define __swap64gen(x)							\
	(u_int64_t)(((u_int64_t)(x) & 0xff) << 56) |			\
	    ((u_int64_t)(x) & 0xff00) << 40 |				\
	    ((u_int64_t)(x) & 0xff0000) << 24 |				\
	    ((u_int64_t)(x) & 0xff000000) << 8 |			\
	    ((u_int64_t)(x) & 0xff00000000) >> 8 |			\
	    ((u_int64_t)(x) & 0xff0000000000) >> 24 |			\
	    ((u_int64_t)(x) & 0xff000000000000) >> 40 |			\
	    ((u_int64_t)(x) & 0xff00000000000000) >> 56)

a107 7
#define swap64(x) __extension__({					\
	u_int64_t __swap64_x = (x);					\
									\
	__builtin_constant_p(x) ? __swap64gen(__swap64_x) :		\
	    __swap64md(__swap64_x);					\
})

a112 1
#define swap64 __swap64gen
d115 1
a115 1
#define swap16_multi(v, n) do {						\
a149 1
#define htobe64 swap64
a151 1
#define betoh64 swap64
a154 1
#define htole64(x) (x)
a156 1
#define letoh64(x) (x)
a171 1
#define htole64 swap64
a173 1
#define letoh64 swap64
a176 1
#define htobe64(x) (x)
a178 1
#define betoh64(x) (x)
@


1.4.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 9
a166 9
u_int32_t	htobe32(u_int32_t);
u_int16_t	htobe16(u_int16_t);
u_int32_t	betoh32(u_int32_t);
u_int16_t	betoh16(u_int16_t);

u_int32_t	htole32(u_int32_t);
u_int16_t	htole16(u_int16_t);
u_int32_t	letoh32(u_int32_t);
u_int16_t	letoh16(u_int16_t);
@


1.4.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.4.4.3 2002/03/28 14:52:01 niklas Exp $	*/
d97 1
a97 1
	(u_int64_t)((((u_int64_t)(x) & 0xff) << 56) |			\
@


1.4.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.4.4.4 2003/05/13 19:36:57 ho Exp $	*/
d14 5
@


1.4.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 7
a77 7
	    (__swap64gen_x & 0xff00ULL) << 40 |				\
	    (__swap64gen_x & 0xff0000ULL) << 24 |			\
	    (__swap64gen_x & 0xff000000ULL) << 8 |			\
	    (__swap64gen_x & 0xff00000000ULL) >> 8 |			\
	    (__swap64gen_x & 0xff0000000000ULL) >> 24 |			\
	    (__swap64gen_x & 0xff000000000000ULL) >> 40 |		\
	    (__swap64gen_x & 0xff00000000000000ULL) >> 56);		\
d93 7
a99 7
	    ((u_int64_t)(x) & 0xff00ULL) << 40 |			\
	    ((u_int64_t)(x) & 0xff0000ULL) << 24 |			\
	    ((u_int64_t)(x) & 0xff000000ULL) << 8 |			\
	    ((u_int64_t)(x) & 0xff00000000ULL) >> 8 |			\
	    ((u_int64_t)(x) & 0xff0000000000ULL) >> 24 |		\
	    ((u_int64_t)(x) & 0xff000000000000ULL) >> 40 |		\
	    ((u_int64_t)(x) & 0xff00000000000000ULL) >> 56)
a152 1
u_int64_t	htobe64(u_int64_t);
a154 1
u_int64_t	betoh64(u_int64_t);
a157 1
u_int64_t	htole64(u_int64_t);
a159 1
u_int64_t	letoh64(u_int64_t);
@


1.3
log
@Move in_addr_t and in_port_t to <sys/types.h> and add sa_family_t
and suseconds_t types for XPG4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.2 1997/11/10 10:29:14 niklas Exp $	*/
d114 11
@


1.2
log
@Sign extension paranoia.  Careful about local varnames in macros.
Typo correction.  Overrideable _QUAD_{LOW,HIGH}WORD values.
@
text
@d1 1
a1 1
/*	$OpenBSD: endian.h,v 1.1 1997/11/09 23:04:58 niklas Exp $	*/
a52 3

typedef u_int32_t in_addr_t;
typedef u_int16_t in_port_t;
@


1.1
log
@New endian.h design.  All architectures now use a common file for the bulk
part.  Some ports can optimize the swap operations.  This also means the
general API is extended with swap16, swap32, htobe16, htobe32, betoh16,
betoh32, htole16, htole32, letoh16 and letoh32.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 7
a65 1
#define __swap16gen(x) ({ u_int16_t y = (x); (u_int16_t)(y << 8 | y >> 8); })
d67 1
a67 1
	u_int32_t y = (x);						\
d69 4
a72 2
	(u_int32_t)(y << 24 | (y & 0xff00) << 8 | (y & 0xff0000) >> 8 |	\
	    y >> 24);							\
d77 8
a84 5
/* Note that these macros evaluates their arguments several times.  */
#define __swap16gen(x) (u_int16_t)((u_int16_t)(x) << 8 | (u_int16_t)(x) >> 8)
#define __swap32gen(x) \
    (u_int32_t)((u_int32_t)(x) << 24 | ((u_int32_t)(x) & 0xff00) << 8 | \
    ((u_int32_t)(x) & 0xff0000) >> 8 | (u_int32_t)(x) >> 24)
d98 1
a98 1
	u_int16_t __x = (x);						\
d100 2
a101 1
	__builtin_constant_p(x) ? __swap16gen(__x) : __swap16md(__x);	\
d105 1
a105 1
	u_int32_t __x = (x);						\
d107 2
a108 1
	__builtin_constant_p(x) ? __swap32gen(__x) : __swap32md(__x);	\
d132 2
d135 2
d138 1
d154 2
d157 2
d160 1
@
