head	1.95;
access;
symbols
	OPENBSD_6_2_BASE:1.95
	OPENBSD_6_1:1.93.0.4
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.90.0.4
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.90.0.2
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.87.0.2
	OPENBSD_5_7_BASE:1.87
	OPENBSD_5_6:1.83.0.8
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.83.0.6
	OPENBSD_5_5_BASE:1.83
	OPENBSD_5_4:1.83.0.2
	OPENBSD_5_4_BASE:1.83
	OPENBSD_5_3:1.82.0.2
	OPENBSD_5_3_BASE:1.82
	OPENBSD_5_2:1.81.0.2
	OPENBSD_5_2_BASE:1.81
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.2
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.70.0.2
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.62.0.2
	OPENBSD_4_7_BASE:1.62
	OPENBSD_4_6:1.61.0.4
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.59.0.2
	OPENBSD_4_5_BASE:1.59
	OPENBSD_4_4:1.58.0.2
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.53.0.6
	OPENBSD_4_2_BASE:1.53
	OPENBSD_4_1:1.53.0.4
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.52.0.4
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.52.0.2
	OPENBSD_3_8_BASE:1.52
	OPENBSD_3_7:1.49.0.2
	OPENBSD_3_7_BASE:1.49
	OPENBSD_3_6:1.47.0.4
	OPENBSD_3_6_BASE:1.47
	SMP_SYNC_A:1.47
	SMP_SYNC_B:1.47
	OPENBSD_3_5:1.47.0.2
	OPENBSD_3_5_BASE:1.47
	OPENBSD_3_4:1.46.0.2
	OPENBSD_3_4_BASE:1.46
	UBC_SYNC_A:1.45
	OPENBSD_3_3:1.45.0.2
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.44.0.2
	OPENBSD_3_2_BASE:1.44
	OPENBSD_3_1:1.43.0.2
	OPENBSD_3_1_BASE:1.43
	UBC_SYNC_B:1.44
	UBC:1.39.0.4
	UBC_BASE:1.39
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.35
	OPENBSD_2_9:1.35.0.4
	OPENBSD_2_8:1.35.0.2
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.33.0.2
	OPENBSD_2_7_BASE:1.33
	SMP:1.30.0.2
	SMP_BASE:1.30
	kame_19991208:1.30
	OPENBSD_2_6:1.29.0.2
	OPENBSD_2_6_BASE:1.29
	OPENBSD_2_5:1.28.0.2
	OPENBSD_2_5_BASE:1.28
	OPENBSD_2_4:1.19.0.4
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.17.0.2
	OPENBSD_2_2_BASE:1.17
	OPENBSD_2_1:1.16.0.2
	OPENBSD_2_1_BASE:1.16
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.95
date	2017.05.31.08.55.10;	author markus;	state Exp;
branches;
next	1.94;
commitid	tU58o7vzg3WVm3T4;

1.94
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.93;
commitid	Gef6NNDxonzfVaq2;

1.93
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.92;
commitid	to0Je2i4V2FtpmS1;

1.92
date	2016.09.28.18.50.20;	author jca;	state Exp;
branches;
next	1.91;
commitid	tJPBmDBAGO3HEMtV;

1.91
date	2016.09.12.19.41.20;	author guenther;	state Exp;
branches;
next	1.90;
commitid	rDEbJJHj0O4ilibK;

1.90
date	2015.10.23.10.22.30;	author claudio;	state Exp;
branches;
next	1.89;
commitid	T6PH2wUDdHyRNguI;

1.89
date	2015.10.20.18.04.03;	author deraadt;	state Exp;
branches;
next	1.88;
commitid	cbpu7TMBEmsrNLlG;

1.88
date	2015.07.17.15.23.59;	author guenther;	state Exp;
branches;
next	1.87;
commitid	lV8YltGllqtUkaqL;

1.87
date	2015.01.21.02.23.14;	author guenther;	state Exp;
branches;
next	1.86;
commitid	z0tt692wWLCZ7FbG;

1.86
date	2015.01.18.04.52.03;	author guenther;	state Exp;
branches;
next	1.85;
commitid	mwDFOkcPoNN1Jqzf;

1.85
date	2014.08.31.02.27.37;	author guenther;	state Exp;
branches;
next	1.84;
commitid	1EAloV6n1EfGcrnb;

1.84
date	2014.08.31.01.42.36;	author guenther;	state Exp;
branches;
next	1.83;
commitid	zF5A8BuuSSyqaDyM;

1.83
date	2013.04.02.03.38.24;	author guenther;	state Exp;
branches;
next	1.82;

1.82
date	2012.09.15.00.47.08;	author guenther;	state Exp;
branches;
next	1.81;

1.81
date	2012.04.11.17.10.20;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2012.04.04.18.24.51;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2012.03.17.10.16.41;	author dlg;	state Exp;
branches;
next	1.78;

1.78
date	2011.12.03.12.38.30;	author fgsch;	state Exp;
branches;
next	1.77;

1.77
date	2011.09.08.03.40.32;	author guenther;	state Exp;
branches;
next	1.76;

1.76
date	2011.07.08.20.53.59;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2011.07.08.20.09.38;	author mikeb;	state Exp;
branches;
next	1.74;

1.74
date	2011.07.08.18.38.55;	author yasuoka;	state Exp;
branches;
next	1.73;

1.73
date	2011.07.04.00.33.36;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.71;

1.71
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.70;

1.70
date	2010.07.05.22.20.22;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.68;

1.68
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.67;

1.67
date	2010.07.01.02.13.02;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2010.06.30.20.38.50;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2010.06.30.19.57.05;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.29.20.30.33;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2010.04.21.11.52.46;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2009.06.11.08.11.53;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2008.09.16.15.48.12;	author gollo;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.09.02.52.15;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2008.05.02.06.49.32;	author ckuethe;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.23.10.55.14;	author norby;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.54;

1.54
date	2007.09.24.22.03.02;	author henning;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.31.17.30.39;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2005.05.27.04.55.28;	author mcbride;	state Exp;
branches;
next	1.51;

1.51
date	2005.04.04.22.18.47;	author hshoexer;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.22.12.22.00;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.14.12.04.02;	author grange;	state Exp;
branches;
next	1.48;

1.48
date	2004.11.26.13.07.52;	author markus;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.24.21.43.56;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2002.11.24.15.25.45;	author espie;	state Exp;
branches;
next	1.44;

1.44
date	2002.09.10.20.51.37;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.15.02.11.01;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.08.00.56.34;	author espie;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.10.10.19.39;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2001.09.07.16.45.25;	author itojun;	state Exp;
branches
	1.39.4.1;
next	1.38;

1.38
date	2001.06.26.19.56.51;	author dugsong;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.28.19.51.05;	author dugsong;	state Exp;
branches;
next	1.35;

1.35
date	2000.08.13.03.38.45;	author ericj;	state Exp;
branches;
next	1.34;

1.34
date	2000.07.02.09.47.59;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2000.04.03.06.00.29;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2000.03.04.02.34.23;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2000.02.18.05.21.01;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	99.12.08.06.50.24;	author itojun;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	99.06.06.23.19.08;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	99.02.25.03.31.34;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	99.02.25.01.19.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.02.24.22.22.34;	author angelos;	state Exp;
branches;
next	1.25;

1.25
date	99.02.16.16.54.47;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	99.02.15.19.27.49;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	99.02.15.19.15.38;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.02.15.19.04.15;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	99.02.05.00.40.22;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.01.10.02.44.33;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.11.30.18.50.17;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.11.16.19.57.39;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	97.07.14.03.07.21;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	97.04.24.21.34.50;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	97.03.12.13.30.42;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.02.28.03.10.02;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	97.02.28.02.18.56;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	97.02.28.02.14.58;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	97.02.28.02.03.33;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	97.02.22.07.24.25;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.02.20.01.07.35;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.12.12.13.50.53;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.12.12.13.39.47;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.12.12.13.23.03;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.12.12.13.17.46;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.07.03.02.34.05;	author chuck;	state Exp;
branches;
next	1.3;

1.3
date	96.06.30.21.33.20;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.57.28;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches;
next	;

1.30.2.1
date	2000.02.20.11.57.33;	author niklas;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2000.03.24.09.09.44;	author niklas;	state Exp;
branches;
next	1.30.2.3;

1.30.2.3
date	2001.05.14.22.45.04;	author niklas;	state Exp;
branches;
next	1.30.2.4;

1.30.2.4
date	2001.07.04.11.00.29;	author niklas;	state Exp;
branches;
next	1.30.2.5;

1.30.2.5
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.30.2.6;

1.30.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.30.2.7;

1.30.2.7
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.30.2.8;

1.30.2.8
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.30.2.9;

1.30.2.9
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.30.2.10;

1.30.2.10
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.39.4.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.39.4.2;

1.39.4.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.39.4.3;

1.39.4.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.39.4.4;

1.39.4.4
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.95
log
@new socketoption SO_ZEROIZE: zero out all mbufs sent over socket
ok deraadt bluhm
@
text
@/*	$OpenBSD: socket.h,v 1.93 2016/11/14 10:32:46 mpi Exp $	*/
/*	$NetBSD: socket.h,v 1.14 1996/02/09 18:25:36 christos Exp $	*/

/*
 * Copyright (c) 1982, 1985, 1986, 1988, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)socket.h	8.4 (Berkeley) 2/21/94
 */

#ifndef _SYS_SOCKET_H_
#define	_SYS_SOCKET_H_

/* get the definitions for struct iovec, size_t, ssize_t, and <sys/cdefs.h> */
#include <sys/uio.h>

#if __BSD_VISIBLE
#include <sys/types.h>			/* for off_t, uid_t, and gid_t */
#endif

#ifndef	_SOCKLEN_T_DEFINED_
#define	_SOCKLEN_T_DEFINED_
typedef	__socklen_t	socklen_t;	/* length type for network syscalls */
#endif

#ifndef	_SA_FAMILY_T_DEFINED_
#define	_SA_FAMILY_T_DEFINED_
typedef	__sa_family_t	sa_family_t;	/* sockaddr address family type */
#endif


/*
 * Definitions related to sockets: types, address families, options.
 */

/*
 * Types
 */
#define	SOCK_STREAM	1		/* stream socket */
#define	SOCK_DGRAM	2		/* datagram socket */
#define	SOCK_RAW	3		/* raw-protocol interface */
#define	SOCK_RDM	4		/* reliably-delivered message */
#define	SOCK_SEQPACKET	5		/* sequenced packet stream */
#ifdef _KERNEL
#define	SOCK_TYPE_MASK	0x000F		/* mask that covers the above */
#endif

/*
 * Socket creation flags
 */
#if __BSD_VISIBLE
#define	SOCK_CLOEXEC		0x8000	/* set FD_CLOEXEC */
#define	SOCK_NONBLOCK		0x4000	/* set O_NONBLOCK */
#ifdef _KERNEL
#define	SOCK_NONBLOCK_INHERIT	0x2000	/* inherit O_NONBLOCK from listener */
#endif
#define	SOCK_DNS		0x1000	/* set SS_DNS */
#endif /* __BSD_VISIBLE */

/*
 * Option flags per-socket.
 */
#define	SO_DEBUG	0x0001		/* turn on debugging info recording */
#define	SO_ACCEPTCONN	0x0002		/* socket has had listen() */
#define	SO_REUSEADDR	0x0004		/* allow local address reuse */
#define	SO_KEEPALIVE	0x0008		/* keep connections alive */
#define	SO_DONTROUTE	0x0010		/* just use interface addresses */
#define	SO_BROADCAST	0x0020		/* permit sending of broadcast msgs */
#define	SO_USELOOPBACK	0x0040		/* bypass hardware when possible */
#define	SO_LINGER	0x0080		/* linger on close if data present */
#define	SO_OOBINLINE	0x0100		/* leave received OOB data in line */
#define	SO_REUSEPORT	0x0200		/* allow local address & port reuse */
#define SO_TIMESTAMP	0x0800		/* timestamp received dgram traffic */
#define SO_BINDANY	0x1000		/* allow bind to any address */
#define SO_ZEROIZE	0x2000		/* zero out all mbufs sent over socket */

/*
 * Additional options, not kept in so_options.
 */
#define	SO_SNDBUF	0x1001		/* send buffer size */
#define	SO_RCVBUF	0x1002		/* receive buffer size */
#define	SO_SNDLOWAT	0x1003		/* send low-water mark */
#define	SO_RCVLOWAT	0x1004		/* receive low-water mark */
#define	SO_SNDTIMEO	0x1005		/* send timeout */
#define	SO_RCVTIMEO	0x1006		/* receive timeout */
#define	SO_ERROR	0x1007		/* get error status and clear */
#define	SO_TYPE		0x1008		/* get socket type */
#define	SO_NETPROC	0x1020		/* multiplex; network processing */
#define	SO_RTABLE	0x1021		/* routing table to be used */
#define	SO_PEERCRED	0x1022		/* get connect-time credentials */
#define	SO_SPLICE	0x1023		/* splice data to other socket */

/*
 * Structure used for manipulating linger option.
 */
struct	linger {
	int	l_onoff;		/* option on/off */
	int	l_linger;		/* linger time */
};

#if __BSD_VISIBLE

#ifndef _TIMEVAL_DECLARED
#define _TIMEVAL_DECLARED
struct timeval {
	time_t		tv_sec;		/* seconds */
	suseconds_t	tv_usec;	/* and microseconds */
};
#endif

/*
 * Structure used for manipulating splice option.
 */
struct	splice {
	int	sp_fd;			/* drain socket file descriptor */
	off_t	sp_max;			/* if set, maximum bytes to splice */
	struct	timeval	sp_idle;	/* idle timeout */
};

/*
 * Maximum number of alternate routing tables
 */
#define	RT_TABLEID_MAX		255
#define	RT_TABLEID_BITS		8
#define	RT_TABLEID_MASK		0xff

#endif /* __BSD_VISIBLE */

/*
 * Level number for (get/set)sockopt() to apply to socket itself.
 */
#define	SOL_SOCKET	0xffff		/* options for socket level */

/*
 * Address families.
 */
#define	AF_UNSPEC	0		/* unspecified */
#define	AF_LOCAL	1		/* local to host (pipes, portals) */
#define	AF_UNIX		AF_LOCAL	/* backward compatibility */
#define	AF_INET		2		/* internetwork: UDP, TCP, etc. */
#define	AF_IMPLINK	3		/* arpanet imp addresses */
#define	AF_PUP		4		/* pup protocols: e.g. BSP */
#define	AF_CHAOS	5		/* mit CHAOS protocols */
#define	AF_NS		6		/* XEROX NS protocols */
#define	AF_ISO		7		/* ISO protocols */
#define	AF_OSI		AF_ISO
#define	AF_ECMA		8		/* european computer manufacturers */
#define	AF_DATAKIT	9		/* datakit protocols */
#define	AF_CCITT	10		/* CCITT protocols, X.25 etc */
#define	AF_SNA		11		/* IBM SNA */
#define AF_DECnet	12		/* DECnet */
#define AF_DLI		13		/* DEC Direct data link interface */
#define AF_LAT		14		/* LAT */
#define	AF_HYLINK	15		/* NSC Hyperchannel */
#define	AF_APPLETALK	16		/* Apple Talk */
#define	AF_ROUTE	17		/* Internal Routing Protocol */
#define	AF_LINK		18		/* Link layer interface */
#define	pseudo_AF_XTP	19		/* eXpress Transfer Protocol (no AF) */
#define	AF_COIP		20		/* connection-oriented IP, aka ST II */
#define	AF_CNT		21		/* Computer Network Technology */
#define pseudo_AF_RTIP	22		/* Help Identify RTIP packets */
#define	AF_IPX		23		/* Novell Internet Protocol */
#define	AF_INET6	24		/* IPv6 */
#define pseudo_AF_PIP	25		/* Help Identify PIP packets */
#define AF_ISDN		26		/* Integrated Services Digital Network*/
#define AF_E164		AF_ISDN		/* CCITT E.164 recommendation */
#define AF_NATM		27		/* native ATM access */
#define	AF_ENCAP	28
#define	AF_SIP		29		/* Simple Internet Protocol */
#define AF_KEY		30
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					   in interface output routine */
#define	AF_BLUETOOTH	32		/* Bluetooth */
#define AF_MPLS         33              /* MPLS */
#define pseudo_AF_PFLOW 34		/* pflow */
#define pseudo_AF_PIPEX 35		/* PIPEX */
#define AF_MAX          36

/*
 * Structure used by kernel to store most
 * addresses.
 */
struct sockaddr {
	__uint8_t    sa_len;		/* total length */
	sa_family_t sa_family;		/* address family */
	char	    sa_data[14];	/* actually longer; address value */
};

/*
 * Sockaddr type which can hold any sockaddr type available
 * in the system.
 *
 * Note: __ss_{len,family} is defined in RFC2553.  During RFC2553 discussion
 * the field name went back and forth between ss_len and __ss_len,
 * and RFC2553 specifies it to be __ss_len.  openbsd picked ss_len.
 * For maximum portability, userland programmer would need to
 * (1) make the code never touch ss_len portion (cast it into sockaddr and
 * touch sa_len), or (2) add "-Dss_len=__ss_len" into CFLAGS to unify all
 * occurrences (including header file) to __ss_len.
 */
struct sockaddr_storage {
	__uint8_t	ss_len;		/* total length */
	sa_family_t	ss_family;	/* address family */
	unsigned char	__ss_pad1[6];	/* align to quad */
	__uint64_t	__ss_pad2;	/* force alignment for stupid compilers */
	unsigned char	__ss_pad3[240];	/* pad to a total of 256 bytes */
};

#ifdef _KERNEL
/*
 * Structure used by kernel to pass protocol
 * information in raw sockets.
 */
struct sockproto {
	unsigned short	sp_family;	/* address family */
	unsigned short	sp_protocol;	/* protocol */
};
#endif /* _KERNEL */

/*
 * Protocol families, same as address families for now.
 */
#define	PF_UNSPEC	AF_UNSPEC
#define	PF_LOCAL	AF_LOCAL
#define	PF_UNIX		PF_LOCAL	/* backward compatibility */
#define	PF_INET		AF_INET
#define	PF_IMPLINK	AF_IMPLINK
#define	PF_PUP		AF_PUP
#define	PF_CHAOS	AF_CHAOS
#define	PF_NS		AF_NS
#define	PF_ISO		AF_ISO
#define	PF_OSI		AF_ISO
#define	PF_ECMA		AF_ECMA
#define	PF_DATAKIT	AF_DATAKIT
#define	PF_CCITT	AF_CCITT
#define	PF_SNA		AF_SNA
#define PF_DECnet	AF_DECnet
#define PF_DLI		AF_DLI
#define PF_LAT		AF_LAT
#define	PF_HYLINK	AF_HYLINK
#define	PF_APPLETALK	AF_APPLETALK
#define	PF_ROUTE	AF_ROUTE
#define	PF_LINK		AF_LINK
#define	PF_XTP		pseudo_AF_XTP	/* really just proto family, no AF */
#define	PF_COIP		AF_COIP
#define	PF_CNT		AF_CNT
#define	PF_IPX		AF_IPX		/* same format as AF_NS */
#define PF_INET6	AF_INET6
#define PF_RTIP		pseudo_AF_RTIP	/* same format as AF_INET */
#define PF_PIP		pseudo_AF_PIP
#define PF_ISDN		AF_ISDN
#define PF_NATM		AF_NATM
#define PF_ENCAP	AF_ENCAP
#define	PF_SIP		AF_SIP
#define PF_KEY		AF_KEY
#define PF_BPF		pseudo_AF_HDRCMPLT
#define	PF_BLUETOOTH	AF_BLUETOOTH
#define PF_MPLS		AF_MPLS
#define PF_PFLOW	pseudo_AF_PFLOW
#define PF_PIPEX	pseudo_AF_PIPEX
#define	PF_MAX		AF_MAX

/*
 * These are the valid values for the "how" field used by shutdown(2).
 */
#define	SHUT_RD		0
#define	SHUT_WR		1
#define	SHUT_RDWR	2

#if __BSD_VISIBLE
#define SA_LEN(x) ((x)->sa_len)

/* Read using getsockopt() with SOL_SOCKET, SO_PEERCRED */
struct sockpeercred {
	uid_t		uid;		/* effective user id */
	gid_t		gid;		/* effective group id */
	pid_t		pid;
};

/*
 * Definitions for network related sysctl, CTL_NET.
 *
 * Second level is protocol family.
 * Third level is protocol number.
 *
 * Further levels are defined by the individual families below.
 */
#define NET_MAXID	AF_MAX

#define CTL_NET_NAMES { \
	{ 0, 0 }, \
	{ "unix", CTLTYPE_NODE }, \
	{ "inet", CTLTYPE_NODE }, \
	{ "implink", CTLTYPE_NODE }, \
	{ "pup", CTLTYPE_NODE }, \
	{ "chaos", CTLTYPE_NODE }, \
	{ "xerox_ns", CTLTYPE_NODE }, \
	{ "iso", CTLTYPE_NODE }, \
	{ "emca", CTLTYPE_NODE }, \
	{ "datakit", CTLTYPE_NODE }, \
	{ "ccitt", CTLTYPE_NODE }, \
	{ "ibm_sna", CTLTYPE_NODE }, \
	{ "decnet", CTLTYPE_NODE }, \
	{ "dec_dli", CTLTYPE_NODE }, \
	{ "lat", CTLTYPE_NODE }, \
	{ "hylink", CTLTYPE_NODE }, \
	{ "appletalk", CTLTYPE_NODE }, \
	{ "route", CTLTYPE_NODE }, \
	{ "link_layer", CTLTYPE_NODE }, \
	{ "xtp", CTLTYPE_NODE }, \
	{ "coip", CTLTYPE_NODE }, \
	{ "cnt", CTLTYPE_NODE }, \
	{ "rtip", CTLTYPE_NODE }, \
	{ "ipx", CTLTYPE_NODE }, \
	{ "inet6", CTLTYPE_NODE }, \
	{ "pip", CTLTYPE_NODE }, \
	{ "isdn", CTLTYPE_NODE }, \
	{ "natm", CTLTYPE_NODE }, \
	{ "encap", CTLTYPE_NODE }, \
	{ "sip", CTLTYPE_NODE }, \
	{ "key", CTLTYPE_NODE }, \
	{ "bpf", CTLTYPE_NODE }, \
	{ "bluetooth", CTLTYPE_NODE }, \
	{ "mpls", CTLTYPE_NODE }, \
	{ "pflow", CTLTYPE_NODE }, \
	{ "pipex", CTLTYPE_NODE }, \
}

/*
 * PF_ROUTE - Routing table
 *
 * Four additional levels are defined:
 *	Fourth: address family, 0 is wildcard
 *	Fifth: type of info, defined below
 *	Sixth: flag(s) to mask with for NET_RT_FLAGS
 *	Seventh: routing table to use (facultative, defaults to 0)
 *		 NET_RT_TABLE has the table id as sixth element.
 */
#define NET_RT_DUMP	1		/* dump; may limit to a.f. */
#define NET_RT_FLAGS	2		/* by flags, e.g. RESOLVING */
#define NET_RT_IFLIST	3		/* survey interface list */
#define	NET_RT_STATS	4		/* routing table statistics */
#define	NET_RT_TABLE	5
#define	NET_RT_IFNAMES	6
#define	NET_RT_MAXID	7

#define CTL_NET_RT_NAMES { \
	{ 0, 0 }, \
	{ "dump", CTLTYPE_STRUCT }, \
	{ "flags", CTLTYPE_STRUCT }, \
	{ "iflist", CTLTYPE_STRUCT }, \
	{ "stats", CTLTYPE_STRUCT }, \
	{ "table", CTLTYPE_STRUCT }, \
	{ "ifnames", CTLTYPE_STRUCT }, \
}

/*
 * PF_KEY - Key Management
 */
#define NET_KEY_SADB_DUMP	1	/* return SADB */
#define NET_KEY_SPD_DUMP	2	/* return SPD */
#define NET_KEY_MAXID		3

#define CTL_NET_KEY_NAMES { \
	{ 0, 0 }, \
	{ "sadb_dump", CTLTYPE_STRUCT }, \
	{ "spd_dump", CTLTYPE_STRUCT }, \
}

/*
 * PF_BPF  not really a family, but connected under CTL_NET
 */
#define NET_BPF_BUFSIZE		1		/* default buffer size */
#define NET_BPF_MAXBUFSIZE	2		/* maximum buffer size */
#define NET_BPF_MAXID		3

#define CTL_NET_BPF_NAMES { \
	{ 0, 0 }, \
	{ "bufsize", CTLTYPE_INT }, \
	{ "maxbufsize", CTLTYPE_INT }, \
}

/*
 * PF_PFLOW not really a family, but connected under CTL_NET
 */
#define NET_PFLOW_STATS		1		/* statistics */
#define NET_PFLOW_MAXID		2

#define CTL_NET_PFLOW_NAMES { \
	{ 0, 0 }, \
	{ "stats", CTLTYPE_STRUCT }, \
}
#endif /* __BSD_VISIBLE */

/*
 * Maximum queue length specifiable by listen(2).
 */
#define	SOMAXCONN	128

/*
 * Message header for recvmsg and sendmsg calls.
 * Used value-result for recvmsg, value only for sendmsg.
 */
struct msghdr {
	void		*msg_name;	/* optional address */
	socklen_t	msg_namelen;	/* size of address */
	struct		iovec *msg_iov;	/* scatter/gather array */
	unsigned int	msg_iovlen;	/* # elements in msg_iov */
	void		*msg_control;	/* ancillary data, see below */
	socklen_t	msg_controllen;	/* ancillary data buffer len */
	int		msg_flags;	/* flags on received message */
};

#define	MSG_OOB			0x1	/* process out-of-band data */
#define	MSG_PEEK		0x2	/* peek at incoming message */
#define	MSG_DONTROUTE		0x4	/* send without using routing tables */
#define	MSG_EOR			0x8	/* data completes record */
#define	MSG_TRUNC		0x10	/* data discarded before delivery */
#define	MSG_CTRUNC		0x20	/* control data lost before delivery */
#define	MSG_WAITALL		0x40	/* wait for full request or error */
#define	MSG_DONTWAIT		0x80	/* this message should be nonblocking */
#define	MSG_BCAST		0x100	/* this message rec'd as broadcast */
#define	MSG_MCAST		0x200	/* this message rec'd as multicast */
#define	MSG_NOSIGNAL		0x400	/* do not send SIGPIPE */
#define	MSG_CMSG_CLOEXEC	0x800	/* set FD_CLOEXEC on received fds */

/*
 * Header for ancillary data objects in msg_control buffer.
 * Used for additional information with/about a datagram
 * not expressible by flags.  The format is a sequence
 * of message elements headed by cmsghdr structures.
 */
struct cmsghdr {
	socklen_t	cmsg_len;	/* data byte count, including hdr */
	int		cmsg_level;	/* originating protocol */
	int		cmsg_type;	/* protocol-specific type */
/* followed by	u_char  cmsg_data[]; */
};

/* given pointer to struct cmsghdr, return pointer to data */
#define	CMSG_DATA(cmsg) \
	((unsigned char *)(cmsg) + _ALIGN(sizeof(struct cmsghdr)))

/* given pointer to struct cmsghdr, return pointer to next cmsghdr */
#define	CMSG_NXTHDR(mhdr, cmsg)	\
	(((char *)(cmsg) + _ALIGN((cmsg)->cmsg_len) + \
			    _ALIGN(sizeof(struct cmsghdr)) > \
	    ((char *)(mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
	    (struct cmsghdr *)NULL : \
	    (struct cmsghdr *)((char *)(cmsg) + _ALIGN((cmsg)->cmsg_len)))

/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
#define	CMSG_FIRSTHDR(mhdr) \
	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
	 (struct cmsghdr *)(mhdr)->msg_control : \
	 (struct cmsghdr *)NULL)

/* Round len up to next alignment boundary */
#ifdef _KERNEL
#define CMSG_ALIGN(n)		_ALIGN(n)
#endif

/* Length of the contents of a control message of length len */
#define	CMSG_LEN(len)	(_ALIGN(sizeof(struct cmsghdr)) + (len))

/* Length of the space taken up by a padded control message of length len */
#define	CMSG_SPACE(len)	(_ALIGN(sizeof(struct cmsghdr)) + _ALIGN(len))

/* "Socket"-level control message types: */
#define	SCM_RIGHTS	0x01		/* access rights (array of int) */
#define	SCM_TIMESTAMP	0x04		/* timestamp (struct timeval) */

#ifndef _KERNEL

__BEGIN_DECLS
int	accept(int, struct sockaddr *, socklen_t *);
int	bind(int, const struct sockaddr *, socklen_t);
int	connect(int, const struct sockaddr *, socklen_t);
int	getpeername(int, struct sockaddr *, socklen_t *);
int	getsockname(int, struct sockaddr *, socklen_t *);
int	getsockopt(int, int, int, void *, socklen_t *);
int	listen(int, int);
ssize_t	recv(int, void *, size_t, int);
ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t	recvmsg(int, struct msghdr *, int);
ssize_t	send(int, const void *, size_t, int);
ssize_t	sendto(int, const void *,
	    size_t, int, const struct sockaddr *, socklen_t);
ssize_t	sendmsg(int, const struct msghdr *, int);
int	setsockopt(int, int, int, const void *, socklen_t);
int	shutdown(int, int);
int	sockatmark(int);
int	socket(int, int, int);
int	socketpair(int, int, int, int *);

#if __BSD_VISIBLE
int	accept4(int, struct sockaddr *__restrict, socklen_t *__restrict, int);
#endif

#if __BSD_VISIBLE
int	getpeereid(int, uid_t *, gid_t *);
int	getrtable(void);
int	setrtable(int);
#endif /* __BSD_VISIBLE */

__END_DECLS

#else

void	pfctlinput(int, struct sockaddr *);

static inline struct sockaddr *
sstosa(struct sockaddr_storage *ss)
{
	return ((struct sockaddr *)(ss));
}

#endif /* !_KERNEL */

#endif /* !_SYS_SOCKET_H_ */
@


1.94
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d99 1
@


1.93
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.92 2016/09/28 18:50:20 jca Exp $	*/
d535 1
d537 7
@


1.92
log
@Hide RT_TABLEID_MAX behind __BSD_VISIBLE

Alternate define location suggested by deraadt@@ and kettenis@@, ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.91 2016/09/12 19:41:20 guenther Exp $	*/
d146 3
a148 1
#define	RT_TABLEID_MAX	255
@


1.91
log
@More #include cleanup per POSIX:
 - <sys/types.h>: don't pull in <sys/select.h>
 - <sys/select.h>: don't pull in <sys/time.h>, but rather declare timeval
   and timespec locally
 - <sys/time.h>: *do* always pull in <sys/select.h>
 - <sys/socket.h>: declare timeval if __BSD_VISIBLE for struct splice

Ports testing and fixed by ajacoutot@@
ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.90 2015/10/23 10:22:30 claudio Exp $	*/
a59 3
/* Maximum number of alternate routing tables */
#define	RT_TABLEID_MAX	255

d142 6
@


1.90
log
@Introduce a new sysctl NET_RT_IFNAMES that returns only ifnames to ifindex
mappings. This will be used by if_nameindex(3), if_nametoindex(3) and
if_indextoname(3) soon to fix the issues in pledge because of inet6 link
local addressing.
OK mpi@@ benno@@ deraadt@@
The libc version will follow soon so better start updating your kernels
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.89 2015/10/20 18:04:03 deraadt Exp $	*/
d128 9
@


1.89
log
@At guenther's suggestion replace dnssocket() with a SOCK_DNS flag on
socket().  Without pledge, all other socket behaviours become permitted,
except this one case: connect/send* only works to *:53.  In pledge mode,
a very few are further restricted.  Some backwards compatibility for
the dnssocket/dnsconnect calls will remain in the tree temporarily so
that people can build through the transition.
ok tedu guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.88 2015/07/17 15:23:59 guenther Exp $	*/
d353 2
a354 1
#define	NET_RT_MAXID	6
d363 1
@


1.88
log
@In socketpair(), need to mask the type argument when testing for dgram.

based on jeremy@@'s diff
ok jeremy@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.87 2015/01/21 02:23:14 guenther Exp $	*/
a80 1
#endif
d84 2
@


1.87
log
@Delete option COMPAT_43: support for pre-sa_len binaries has been obsolete
for a couple decades.  Keep the OSIOCGIFCONF ioctl to support COMPAT_LINUX
but move the rest of the Linux-specific ioctl() handling into linux_socket.c
This lets struct osockaddr finally move from sys/socket.h to protocols/talkd.h

ok krw@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.86 2015/01/18 04:52:03 guenther Exp $	*/
d71 3
@


1.86
log
@Per POSIX, <sys/socket.h> needs to expose struct iovec, and may do so
by pulling in <sys/uio.h>, so do so.  Remove some stuff that we can trust
<sys/uio.h> to also provide, like cdefs.h, _types.h, and exposing size_t
and ssize_t

pointed out by naddy@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.85 2014/08/31 02:27:37 guenther Exp $	*/
a477 11

#if __BSD_VISIBLE
/*
 * 4.3 compat sockaddr, move to compat file later
 * XXX Needed by protocols/talkd.h
 */
struct osockaddr {
	unsigned short	sa_family;	/* address family */
	char		sa_data[14];	/* up to 14 bytes of direct address */
};
#endif /* __BSD_VISIBLE */
@


1.85
log
@Add sockatmark()

ok millert@@ manpage feedback jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.84 2014/08/31 01:42:36 guenther Exp $	*/
d38 2
a39 1
#include <sys/cdefs.h>
a42 2
#else
#include <sys/_types.h>
a52 10
#endif

#ifndef	_SIZE_T_DEFINED_
#define	_SIZE_T_DEFINED_
typedef	__size_t	size_t;
#endif

#ifndef	_SSIZE_T_DEFINED_
#define	_SSIZE_T_DEFINED_
typedef	__ssize_t	ssize_t;
@


1.84
log
@Add additional kernel interfaces for setting close-on-exec on fds
when creating them: pipe2(), dup3(), accept4(), MSG_CMSG_CLOEXEC,
SOCK_CLOEXEC.  Includes SOCK_NONBLOCK support.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.83 2013/04/02 03:38:24 guenther Exp $	*/
d520 1
@


1.83
log
@Use internal types instead of the old BSD u_int#_t types in the
standard portion of the header.

Most of the diff from James Turner (james (at) calminferno.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.82 2012/09/15 00:47:08 guenther Exp $	*/
d84 11
d428 12
a439 11
#define	MSG_OOB		0x1		/* process out-of-band data */
#define	MSG_PEEK	0x2		/* peek at incoming message */
#define	MSG_DONTROUTE	0x4		/* send without using routing tables */
#define	MSG_EOR		0x8		/* data completes record */
#define	MSG_TRUNC	0x10		/* data discarded before delivery */
#define	MSG_CTRUNC	0x20		/* control data lost before delivery */
#define	MSG_WAITALL	0x40		/* wait for full request or error */
#define	MSG_DONTWAIT	0x80		/* this message should be nonblocking */
#define	MSG_BCAST	0x100		/* this message rec'd as broadcast */
#define	MSG_MCAST	0x200		/* this message rec'd as multicast */
#define	MSG_NOSIGNAL	0x400		/* do not send SIGPIPE */
d522 4
@


1.82
log
@Improve POSIX/SUS compliance of <netdb.h>, <sys/socket.h>, and <sys/un.h>.

Much ports testing of various versions by naddy@@ and jasper@@
ok matthew@@, miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.81 2012/04/11 17:10:20 deraadt Exp $	*/
d189 1
a189 1
	u_int8_t    sa_len;		/* total length */
d207 1
a207 1
	u_int8_t	ss_len;		/* total length */
d210 1
a210 1
	u_int64_t	__ss_pad2;	/* force alignment for stupid compilers */
d444 1
a444 1
	((u_char *)(cmsg) + _ALIGN(sizeof(struct cmsghdr)))
@


1.81
log
@tedu struct omsghdr
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.80 2012/04/04 18:24:51 deraadt Exp $	*/
d38 5
d44 22
d214 1
d223 1
d276 2
a283 1
#endif /* __BSD_VISIBLE */
d396 1
d448 1
a448 1
	(((caddr_t)(cmsg) + _ALIGN((cmsg)->cmsg_len) + \
d450 1
a450 1
	    ((caddr_t)(mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
d452 1
a452 1
	    (struct cmsghdr *)((caddr_t)(cmsg) + _ALIGN((cmsg)->cmsg_len)))
d478 1
d481 1
d487 1
d489 1
a489 5
#define SA_LEN(x) ((x)->sa_len)

#ifndef	_KERNEL

#include <sys/cdefs.h>
a494 1
int	getpeereid(int, uid_t *, gid_t *);
d510 3
d515 2
@


1.80
log
@SCM_CREDS can go away, since everything uses the newer APIs.
ports tree checked by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.79 2012/03/17 10:16:41 dlg Exp $	*/
a452 12
};

/*
 * 4.3-compat message header (move to compat file later).
 */
struct omsghdr {
	caddr_t	msg_name;		/* optional address */
	int	msg_namelen;		/* size of address */
	struct	iovec *msg_iov;		/* scatter/gather array */
	int	msg_iovlen;		/* # elements in msg_iov */
	caddr_t	msg_accrights;		/* access rights sent/received */
	int	msg_accrightslen;
@


1.79
log
@remove IP_JUMBO, SO_JUMBO, and RTF_JUMBO.

no objection from mcbride@@ krw@@ markus@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.78 2011/12/03 12:38:30 fgsch Exp $	*/
a245 12
/*
 * Socket credentials.
 */
struct sockcred {
	uid_t	sc_uid;			/* real user id */
	uid_t	sc_euid;		/* effective user id */
	gid_t	sc_gid;			/* real group id */
	gid_t	sc_egid;		/* effective group id */
	int	sc_ngroups;		/* number of supplemental groups */
	gid_t	sc_groups[1];		/* variable length */
};

a255 6
 * Compute size of a sockcred structure with groups.
 */
#define SOCKCREDSIZE(ngrps) \
	(sizeof(struct sockcred) + (sizeof(gid_t) * ((ngrps) - 1)))

/*
a444 1
#define SCM_CREDS	0x02		/* credentials (struct sockcred) */
@


1.78
log
@add support for MSG_NOSIGNAL.
linux bits compiled on i386 by sebastia@@, mikeb@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.77 2011/09/08 03:40:32 guenther Exp $	*/
a68 1
#define SO_JUMBO	0x0400		/* try to use jumbograms */
@


1.77
log
@Provide namespace-safe alignment macros in <machine/_types.h>, with
compat names kept in <machine/param.h>.  In <sys/socket.h>, pull
in <sys/_types.h> instead of the namespace polluting <machine/param.h>
and completely eliminate __CMSG_ALIGN, replaced by _ALIGN

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.76 2011/07/08 20:53:59 deraadt Exp $	*/
d415 1
@


1.76
log
@Remove COMPAT_OLDSOCK since no nothing sets MSG_COMPAT anymore.
The song and dance for handling 16-bit af_family on big-endian
machines remains untouched.
ok claudio miod tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.75 2011/07/08 20:09:38 mikeb Exp $	*/
d38 1
a38 4
/*
 * needed for ALIGNBYTES
 */
#include <machine/param.h>
d431 1
a431 1
	((u_char *)(cmsg) + __CMSG_ALIGN(sizeof(struct cmsghdr)))
d435 2
a436 2
	(((caddr_t)(cmsg) + __CMSG_ALIGN((cmsg)->cmsg_len) + \
			    __CMSG_ALIGN(sizeof(struct cmsghdr)) > \
d439 1
a439 1
	    (struct cmsghdr *)((caddr_t)(cmsg) + __CMSG_ALIGN((cmsg)->cmsg_len)))
a450 1
#define	__CMSG_ALIGN(len)	ALIGN(len)
d452 1
a452 1
#define CMSG_ALIGN(n)		__CMSG_ALIGN(n)
d456 1
a456 1
#define	CMSG_LEN(len)	(__CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
d459 1
a459 1
#define	CMSG_SPACE(len)	(__CMSG_ALIGN(sizeof(struct cmsghdr)) + __CMSG_ALIGN(len))
@


1.75
log
@surround splice structure with __BSD_VISIBLE (the right one, noticed by
bluhm, jasper and millert -- an epic fail on my side), style nits from
deraadt, millert, ok guenther, kettenis, millert, ports tests by jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.74 2011/07/08 18:38:55 yasuoka Exp $	*/
d519 1
a520 5
# if defined(COMPAT_43) || defined(COMPAT_LINUX)
#  define COMPAT_OLDSOCK
#  define MSG_COMPAT	0x8000
# endif

@


1.74
log
@this must be included my previous commit.

Include PIPEX in kernel by default.  And add new sysctl variable
`net.pipex.enable' to enable PIPEX.   By default, pipex is disabled
and it will not process packets from wire.  Update man pages and
update HOWTO_PIPEX_NPPPD.txt for testers.

discussed with dlg@@, ok deraadt@@ mcbride@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.73 2011/07/04 00:33:36 mikeb Exp $	*/
d100 1
d109 1
@


1.73
log
@Implement an idle timeout for the socket splicing.  A new `sp_idle'
field of the `splice' structure can be used to specify a period of
inactivity after which splicing will be dissolved.  ETIMEDOUT error
retrieved with a SO_ERROR indicates the idle timeout expiration.
With comments from and OK bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.72 2011/04/05 12:50:15 guenther Exp $	*/
d156 2
a157 1
#define AF_MAX          35
d238 1
d321 1
@


1.72
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.71 2011/01/07 17:50:42 bluhm Exp $	*/
d106 1
@


1.71
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.70 2010/07/05 22:20:22 tedu Exp $	*/
d514 1
a514 2
# if defined(COMPAT_43) || defined(COMPAT_LINUX) || \
     defined(COMPAT_FREEBSD)
@


1.70
log
@remove compat_bsdos support
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.69 2010/07/03 04:44:51 guenther Exp $	*/
d90 1
d98 8
@


1.69
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.68 2010/07/02 19:57:15 tedu Exp $	*/
d506 1
a506 1
     defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
@


1.68
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.67 2010/07/01 02:13:02 deraadt Exp $	*/
d88 1
a88 1
#define	SO_RDOMAIN	0x1021		/* routing domain socket belongs to */
d501 2
a502 2
int	getrdomain(void);
int	setrdomain(int);
@


1.67
log
@Put SO_PEERCRED into the non-flag area
suggested by guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.66 2010/06/30 20:38:50 tedu Exp $	*/
d505 1
a505 1
# if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_LINUX) || \
@


1.66
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.65 2010/06/30 19:57:05 deraadt Exp $	*/
d74 1
a74 2
#define	SO_BINDANY	0x1000		/* allow bind to any address */
#define SO_PEERCRED	0x2000		/* get connect-time credentials */
d89 1
@


1.65
log
@Add getsockopt SOL_SOCKET SO_PEERCRED support. This behaves similar to
getpeereid(2), but also supplies the remote pid.  This is supplied in
a 'struct sockpeercred' (unlike Linux -- they showed how little they
know about real unix by calling theirs 'struct ucred').
ok guenther ajacoutot
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.64 2010/06/29 20:30:33 guenther Exp $	*/
d506 1
a506 1
     defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS) || defined(COMPAT_OSF1)
@


1.64
log
@Remove COMPAT_HPUX.  No one wanted to support it and its fewmets were
blocking other cleanups
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.63 2010/04/21 11:52:46 claudio Exp $	*/
d75 1
d247 9
@


1.63
log
@Implement a way to get information about a rtable. Currently only the rtableid
and rdomainid are returned. This is necessary to know where L2 information
of a table is stored (which will be needed soon by bgpd).
Also while there change the errno for non-existing routing tables to ENOENT.
'Fine' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.62 2009/11/27 20:05:50 guenther Exp $	*/
d496 1
a496 2
     defined(COMPAT_HPUX) || defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS) \
     || defined(COMPAT_OSF1)
@


1.62
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.61 2009/06/11 08:11:53 jsg Exp $	*/
d309 1
d315 2
a316 1
#define	NET_RT_MAXID	5
d324 1
@


1.61
log
@tab indent SO_RDOMAIN, like all the other SO_* defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.60 2009/06/05 00:05:22 claudio Exp $	*/
d488 2
@


1.60
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.59 2008/09/16 15:48:12 gollo Exp $	*/
d88 1
a88 1
#define SO_RDOMAIN	0x1021		/* routing domain socket belongs to */
@


1.59
log
@netstat statistics for pflow(4) via pseudo family

ok cluadio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.58 2008/05/09 02:52:15 markus Exp $	*/
d47 3
d88 1
@


1.58
log
@Add SO_BINDANY socket option from BSD/OS.

The option allows a socket to be bound to addresses which are not
local to the machine.  In order to receive packets for these addresses
SO_BINDANY needs to be combined with matching outgoing pf(4) divert
rules, see pf.conf(5).

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.57 2008/05/02 06:49:32 ckuethe Exp $	*/
d140 2
a141 1
#define AF_MAX          34
d221 1
d294 1
d344 11
@


1.57
log
@Make the SO_TIMESTAMP sockopt work. When set, this allows the user to
get a timestamp of when the datagram was accepted (by udp(4), for
example) rather than having to take a timestamp with gettimeofday(2)
when recv(2) returns - possibly several hundreds of microseconds later.
May be of use to those interested in precision network timing schemes
or QoS for media applications. Tested on alpha, amd64, i386 and sparc64.
manpage suggestions from jmc, ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.56 2008/04/23 10:55:14 norby Exp $	*/
d71 1
@


1.56
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.55 2007/11/27 16:22:14 martynas Exp $	*/
d70 1
d421 1
@


1.55
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.54 2007/09/24 22:03:02 henning Exp $	*/
d137 2
a138 2

#define	AF_MAX		33
d217 1
d288 2
@


1.54
log
@updatecomment and manpage toemtion optional seventh level (rtable id)
From: Pierre Riteau <pierre.riteau@@free.fr>
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.53 2006/03/31 17:30:39 claudio Exp $	*/
d160 1
a160 1
 * occurences (including header file) to __ss_len.
@


1.53
log
@Add sysctl to retrieve the routing table statisitcs. Will be used by netstat
instead of kvm access. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.52 2005/05/27 04:55:28 mcbride Exp $	*/
d292 1
a292 1
 * Three additional levels are defined:
d296 1
@


1.52
log
@Experimental support for opportunitic use of jumbograms where only some hosts
on the local network support them.

This adds a new socket option, SO_JUMBO, and a new route flag,
RTF_JUMBO. If _both_ the socket option is set and the route for the host
has RTF_JUMBO set, ip_output will fragment the packet to the largest
possible size for the link, ignoring the card's MTU.

The semantics of this feature will be evolving rapidly; talk to us
if you intend to use it.

ok deraadt@@ marius@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.51 2005/04/04 22:18:47 hshoexer Exp $	*/
d300 2
a301 1
#define	NET_RT_MAXID	4
d308 1
@


1.51
log
@Add sysctl for dumping the SPD
ok deraadt, ok markus some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.50 2005/03/22 12:22:00 henning Exp $	*/
d69 1
@


1.50
log
@fix a typo, don't #define PF_RTIP to something nonmexistant
nothing in our tree uses it (well, would have been spotted then)
netbsd PR kern/29624 via jmc@@, agreed on by claudio some time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.49 2005/01/14 12:04:02 grange Exp $	*/
d312 2
a313 1
#define NET_KEY_MAXID		2
d318 1
@


1.49
log
@First step in Bluetooth protocol stack support.

The code is adopted from the FreeBSD netgraph-based Bluetooth
implementation by Maksim Yevmenkin <m_evmenkin@@yahoo.com> but
all netgraph glue was replaced with usual BSD network stack
hooks. This is a work in progress. Only HCI layer works for now,
L2CAP and RFCOMM are on the way.

Help in testing from many, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.48 2004/11/26 13:07:52 markus Exp $	*/
d207 1
a207 1
#define PF_RTIP		pseudo_AF_FTIP	/* same format as AF_INET */
@


1.48
log
@add pfkey sysctl subtree; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.47 2004/02/24 21:43:56 tedu Exp $	*/
d135 3
a137 1
#define	AF_MAX		32
d215 1
@


1.47
log
@sysctl knob for bpf tunables.  some tips from canacar@@
ok canacar@@ deraadt@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.46 2003/06/02 23:28:21 millert Exp $	*/
d306 11
a327 1

@


1.46
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.45 2002/11/24 15:25:45 espie Exp $	*/
d212 1
d282 1
d304 14
@


1.45
log
@Explicit unsigned char and unsigned short instead of u_char, u_short.
Make these files usable with -D_POSIX_SOURCE
okay millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.44 2002/09/10 20:51:37 deraadt Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.44
log
@typo; krapht@@secureops.com
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.43 2002/03/15 02:11:01 itojun Exp $	*/
d166 1
a166 1
	u_char		__ss_pad1[6];	/* align to quad */
d168 1
a168 1
	u_char		__ss_pad3[240];	/* pad to a total of 256 bytes */
d176 2
a177 2
	u_short	sp_family;		/* address family */
	u_short	sp_protocol;		/* protocol */
d320 1
a320 1
	u_int		msg_iovlen;	/* # elements in msg_iov */
d391 2
a392 2
	u_short	sa_family;		/* address family */
	char	sa_data[14];		/* up to 14 bytes of direct address */
@


1.43
log
@typecast in CMSG_NXTHDR.  spotted by hugh@@openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.42 2002/03/14 01:27:14 millert Exp $	*/
d385 1
a385 1
#define SCM_CREDS	0x02		/* credientials (struct sockcred) */
@


1.42
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.41 2002/03/08 00:56:34 espie Exp $	*/
d358 1
a358 1
	    (mhdr)->msg_control + (mhdr)->msg_controllen) ? \
@


1.41
log
@Make msghdr fields usable from all languages.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.40 2002/01/10 10:19:39 itojun Exp $	*/
d414 19
a432 19
int	accept __P((int, struct sockaddr *, socklen_t *));
int	bind __P((int, const struct sockaddr *, socklen_t));
int	connect __P((int, const struct sockaddr *, socklen_t));
int	getpeereid __P((int, uid_t *, gid_t *));
int	getpeername __P((int, struct sockaddr *, socklen_t *));
int	getsockname __P((int, struct sockaddr *, socklen_t *));
int	getsockopt __P((int, int, int, void *, socklen_t *));
int	listen __P((int, int));
ssize_t	recv __P((int, void *, size_t, int));
ssize_t	recvfrom __P((int, void *, size_t, int, struct sockaddr *, socklen_t *));
ssize_t	recvmsg __P((int, struct msghdr *, int));
ssize_t	send __P((int, const void *, size_t, int));
ssize_t	sendto __P((int, const void *,
	    size_t, int, const struct sockaddr *, socklen_t));
ssize_t	sendmsg __P((int, const struct msghdr *, int));
int	setsockopt __P((int, int, int, const void *, socklen_t));
int	shutdown __P((int, int));
int	socket __P((int, int, int));
int	socketpair __P((int, int, int, int *));
d442 1
a442 1
void	pfctlinput __P((int, struct sockaddr *));
@


1.40
log
@remove duplicated decl of PF_INET6.  found by kjc
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.39 2001/09/07 16:45:25 itojun Exp $	*/
d317 1
a317 1
	caddr_t		msg_name;	/* optional address */
d321 1
a321 1
	caddr_t		msg_control;	/* ancillary data, see below */
@


1.39
log
@just as RFC2292 suggests, validate cmsg_controllen on CMSG_FIRSTHDR.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.38 2001/06/26 19:56:51 dugsong Exp $	*/
a186 1
#define	PF_INET6	AF_INET6
@


1.39.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.40 2002/01/10 10:19:39 itojun Exp $	*/
d187 1
@


1.39.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.39.4.1 2002/01/31 22:55:49 niklas Exp $	*/
d317 1
a317 1
	void		*msg_name;	/* optional address */
d321 1
a321 1
	void		*msg_control;	/* ancillary data, see below */
d358 1
a358 1
	    ((caddr_t)(mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
d414 19
a432 19
int	accept(int, struct sockaddr *, socklen_t *);
int	bind(int, const struct sockaddr *, socklen_t);
int	connect(int, const struct sockaddr *, socklen_t);
int	getpeereid(int, uid_t *, gid_t *);
int	getpeername(int, struct sockaddr *, socklen_t *);
int	getsockname(int, struct sockaddr *, socklen_t *);
int	getsockopt(int, int, int, void *, socklen_t *);
int	listen(int, int);
ssize_t	recv(int, void *, size_t, int);
ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t	recvmsg(int, struct msghdr *, int);
ssize_t	send(int, const void *, size_t, int);
ssize_t	sendto(int, const void *,
	    size_t, int, const struct sockaddr *, socklen_t);
ssize_t	sendmsg(int, const struct msghdr *, int);
int	setsockopt(int, int, int, const void *, socklen_t);
int	shutdown(int, int);
int	socket(int, int, int);
int	socketpair(int, int, int, int *);
d442 1
a442 1
void	pfctlinput(int, struct sockaddr *);
@


1.39.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.39.4.2 2002/06/11 03:32:33 art Exp $	*/
d385 1
a385 1
#define SCM_CREDS	0x02		/* credentials (struct sockcred) */
@


1.39.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 1
a166 1
	unsigned char	__ss_pad1[6];	/* align to quad */
d168 1
a168 1
	unsigned char	__ss_pad3[240];	/* pad to a total of 256 bytes */
d176 2
a177 2
	unsigned short	sp_family;	/* address family */
	unsigned short	sp_protocol;	/* protocol */
d320 1
a320 1
	unsigned int	msg_iovlen;	/* # elements in msg_iov */
d391 2
a392 2
	unsigned short	sa_family;	/* address family */
	char		sa_data[14];	/* up to 14 bytes of direct address */
@


1.38
log
@implement djb's getpeereid(2), to allow local-domain servers to determine client credentials. mostly from superscript.com. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.37 2001/06/22 14:11:00 deraadt Exp $	*/
d363 8
a370 1
#define	CMSG_FIRSTHDR(mhdr)	((struct cmsghdr *)(mhdr)->msg_control)
@


1.37
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.36 2001/05/28 19:51:05 dugsong Exp $	*/
d411 1
@


1.36
log
@add BIOC[GS]HDRCMPLT ioctl for BPF, to disable overwriting of link level source address in forged frames. from NetBSD. art@@ok
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.35 2000/08/13 03:38:45 ericj Exp $	*/
d164 5
a168 5
	u_int8_t    ss_len;		/* total length */
	sa_family_t ss_family;		/* address family */
	u_char	    __ss_pad1[6];	/* align to quad */
	u_int64_t   __ss_pad2;		/* force alignment for stupid compilers */
	u_char      __ss_pad3[240];	/* pad to a total of 256 bytes */
@


1.35
log
@
if COMPAT_OSF1 is defined, define COMPAT_OLDSOCK
and COMPAT_OLDTTY.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.34 2000/07/02 09:47:59 fgsch Exp $	*/
d137 3
a139 1
#define	AF_MAX		31
@


1.34
log
@MSG_COMPAT is needed for COMPAT_BSDOS too.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.33 2000/04/03 06:00:29 itojun Exp $	*/
d427 2
a428 1
     defined(COMPAT_HPUX) || defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS)
@


1.33
log
@hide CMSG_ALIGN from userland, it is not part of RFC2292/Posix.1g.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.32 2000/03/04 02:34:23 itojun Exp $	*/
d427 1
a427 1
     defined(COMPAT_HPUX) || defined(COMPAT_FREEBSD)
@


1.32
log
@to be Posix.1g compliant, fix ancillary message alignment.  it will now be
aligned to ALIGNBYTES (arch dependent).
NOTE: the change requires you to recompile IPv6 userland, if you are
on arch that is ALIGNBYTES != sizeof(long) - 1 (sparc seems to be it).
sorry for the mess.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.31 2000/02/18 05:21:01 itojun Exp $	*/
d351 1
a351 1
	((u_char *)(cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
d355 2
a356 2
	(((caddr_t)(cmsg) + CMSG_ALIGN((cmsg)->cmsg_len) + \
			    CMSG_ALIGN(sizeof(struct cmsghdr)) > \
d359 1
a359 1
	    (struct cmsghdr *)((caddr_t)(cmsg) + CMSG_ALIGN((cmsg)->cmsg_len)))
d364 4
a367 1
#define	CMSG_ALIGN(len)	ALIGN(len)
d370 1
a370 1
#define	CMSG_LEN(len)	(CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
d373 1
a373 1
#define	CMSG_SPACE(len)	(CMSG_ALIGN(sizeof(struct cmsghdr)) + CMSG_ALIGN(len))
@


1.31
log
@fix alignment problem in ancillary data (alpha).

only ipv6 tools (which touches ancillary data) are affected.

From: =?iso-8859-1?Q?G=F6ran_Bengtson?= <goeran@@cdg.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.30 1999/12/08 06:50:24 itojun Exp $	*/
d43 5
d364 1
a364 1
#define	CMSG_ALIGN(len)	(((len)+sizeof(long)-1) & ~(sizeof(long)-1))
@


1.30
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.29 1999/06/06 23:19:08 deraadt Exp $	*/
d345 2
a346 1
#define	CMSG_DATA(cmsg)		((u_char *)((cmsg) + 1))
d350 2
a351 1
	(((caddr_t)(cmsg) + (cmsg)->cmsg_len + sizeof(struct cmsghdr) > \
@


1.30.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.31 2000/02/18 05:21:01 itojun Exp $	*/
d345 1
a345 2
#define	CMSG_DATA(cmsg) \
	((u_char *)(cmsg) + CMSG_ALIGN(sizeof(struct cmsghdr)))
d349 1
a349 2
	(((caddr_t)(cmsg) + CMSG_ALIGN((cmsg)->cmsg_len) + \
			    CMSG_ALIGN(sizeof(struct cmsghdr)) > \
@


1.30.2.2
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a42 5
 * needed for ALIGNBYTES
 */
#include <machine/param.h>

/*
d359 1
a359 1
#define	CMSG_ALIGN(len)	ALIGN(len)
@


1.30.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.35 2000/08/13 03:38:45 ericj Exp $	*/
d351 1
a351 1
	((u_char *)(cmsg) + __CMSG_ALIGN(sizeof(struct cmsghdr)))
d355 2
a356 2
	(((caddr_t)(cmsg) + __CMSG_ALIGN((cmsg)->cmsg_len) + \
			    __CMSG_ALIGN(sizeof(struct cmsghdr)) > \
d359 1
a359 1
	    (struct cmsghdr *)((caddr_t)(cmsg) + __CMSG_ALIGN((cmsg)->cmsg_len)))
d364 1
a364 4
#define	__CMSG_ALIGN(len)	ALIGN(len)
#ifdef _KERNEL
#define CMSG_ALIGN(n)		__CMSG_ALIGN(n)
#endif
d367 1
a367 1
#define	CMSG_LEN(len)	(__CMSG_ALIGN(sizeof(struct cmsghdr)) + (len))
d370 1
a370 1
#define	CMSG_SPACE(len)	(__CMSG_ALIGN(sizeof(struct cmsghdr)) + __CMSG_ALIGN(len))
d424 1
a424 2
     defined(COMPAT_HPUX) || defined(COMPAT_FREEBSD) || defined(COMPAT_BSDOS) \
     || defined(COMPAT_OSF1)
@


1.30.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.30.2.3 2001/05/14 22:45:04 niklas Exp $	*/
d137 1
a137 3
#define pseudo_AF_HDRCMPLT 31		/* Used by BPF to not rewrite headers
					   in interface output routine */
#define	AF_MAX		32
d162 5
a166 5
	u_int8_t	ss_len;		/* total length */
	sa_family_t	ss_family;	/* address family */
	u_char		__ss_pad1[6];	/* align to quad */
	u_int64_t	__ss_pad2;	/* force alignment for stupid compilers */
	u_char		__ss_pad3[240];	/* pad to a total of 256 bytes */
a408 1
int	getpeereid __P((int, uid_t *, gid_t *));
@


1.30.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.30.2.4 2001/07/04 11:00:29 niklas Exp $	*/
d363 1
a363 8
/*
 * RFC 2292 requires to check msg_controllen, in case that the kernel returns
 * an empty list for some reasons.
 */
#define	CMSG_FIRSTHDR(mhdr) \
	((mhdr)->msg_controllen >= sizeof(struct cmsghdr) ? \
	 (struct cmsghdr *)(mhdr)->msg_control : \
	 (struct cmsghdr *)NULL)
@


1.30.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d187 1
@


1.30.2.7
log
@Merge in -current from roughly a week ago
@
text
@d317 1
a317 1
	void		*msg_name;	/* optional address */
d321 1
a321 1
	void		*msg_control;	/* ancillary data, see below */
d358 1
a358 1
	    ((caddr_t)(mhdr)->msg_control) + (mhdr)->msg_controllen) ? \
d414 19
a432 19
int	accept(int, struct sockaddr *, socklen_t *);
int	bind(int, const struct sockaddr *, socklen_t);
int	connect(int, const struct sockaddr *, socklen_t);
int	getpeereid(int, uid_t *, gid_t *);
int	getpeername(int, struct sockaddr *, socklen_t *);
int	getsockname(int, struct sockaddr *, socklen_t *);
int	getsockopt(int, int, int, void *, socklen_t *);
int	listen(int, int);
ssize_t	recv(int, void *, size_t, int);
ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
ssize_t	recvmsg(int, struct msghdr *, int);
ssize_t	send(int, const void *, size_t, int);
ssize_t	sendto(int, const void *,
	    size_t, int, const struct sockaddr *, socklen_t);
ssize_t	sendmsg(int, const struct msghdr *, int);
int	setsockopt(int, int, int, const void *, socklen_t);
int	shutdown(int, int);
int	socket(int, int, int);
int	socketpair(int, int, int, int *);
d442 1
a442 1
void	pfctlinput(int, struct sockaddr *);
@


1.30.2.8
log
@Sync the SMP branch with 3.3
@
text
@d166 1
a166 1
	unsigned char	__ss_pad1[6];	/* align to quad */
d168 1
a168 1
	unsigned char	__ss_pad3[240];	/* pad to a total of 256 bytes */
d176 2
a177 2
	unsigned short	sp_family;	/* address family */
	unsigned short	sp_protocol;	/* protocol */
d320 1
a320 1
	unsigned int	msg_iovlen;	/* # elements in msg_iov */
d385 1
a385 1
#define SCM_CREDS	0x02		/* credentials (struct sockcred) */
d391 2
a392 2
	unsigned short	sa_family;	/* address family */
	char		sa_data[14];	/* up to 14 bytes of direct address */
@


1.30.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.30.2.8 2003/03/28 00:41:30 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.30.2.10
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a211 1
#define PF_BPF		pseudo_AF_HDRCMPLT
a280 1
	{ "bpf", CTLTYPE_NODE }, \
a301 14

/*
 * PF_BPF  not really a family, but connected under CTL_NET
 */
#define NET_BPF_BUFSIZE		1		/* default buffer size */
#define NET_BPF_MAXBUFSIZE	2		/* maximum buffer size */
#define NET_BPF_MAXID		3

#define CTL_NET_BPF_NAMES { \
	{ 0, 0 }, \
	{ "bufsize", CTLTYPE_INT }, \
	{ "maxbufsize", CTLTYPE_INT }, \
}

@


1.29
log
@sockaddr_storage; per rfc2553
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.28 1999/02/25 03:31:34 deraadt Exp $	*/
d147 8
d180 1
d352 1
a352 1
	    (struct cmsghdr *)((caddr_t)(cmsg) + ALIGN((cmsg)->cmsg_len)))
d421 2
@


1.28
log
@rename sysctl names
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.27 1999/02/25 01:19:07 deraadt Exp $	*/
d142 12
@


1.27
log
@sockaddr_union cannot be declared here, obviously, or in any other file that i know of
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.26 1999/02/24 22:22:34 angelos Exp $	*/
d255 1
a255 1
	{ "ipsec", CTLTYPE_NODE }, \
d257 1
a257 1
	{ "pfkey", CTLTYPE_NODE }, \
@


1.26
log
@Changes to socket.h to include union sockaddr_union, temporarily add osdep.h,
until pfkey files are cleaned up.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.25 1999/02/16 16:54:47 millert Exp $	*/
a365 29
};


/* Stupid C trick: We can define the structures that are members of union
   sockaddr_union as empty and later redefine them as non-empty. We CAN'T,
   however, define them as non-empty and later redefine them as empty. So
   the empty declarations must be wrapped to ensure that we don't do that.
 
   WARNING: gcc < 2.8 generates incorrect debugging information for this;
   the symptom is that gdb thinks that all struct sockaddr_*'s are empty
   structures. gcc >= 2.8 correctly figures out what's going on. - cmetz
*/

#ifndef _NETINET_IN_H_
struct sockaddr_in {};
#endif /* _NETINET_IN_H_ */
#ifndef _NETINET6_IN6_H
struct sockaddr_in6 {};
#endif /* _NETINET6_IN6_H */
#ifndef _SYS_UN_H_
struct sockaddr_un {};
#endif /* _SYS_UN_H_ */

union sockaddr_union {
       struct sockaddr         sa;
       struct sockaddr_in      sin;
       struct sockaddr_in6     sin6;
       struct sockaddr_un      sun;
       char __maxsize[128];            /* should probably be MHLEN on BSD */
@


1.25
log
@sendto(2) takes socklen_t for length param
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.24 1999/02/15 19:27:49 millert Exp $	*/
d367 31
@


1.24
log
@pasto
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.23 1999/02/15 19:15:38 millert Exp $	*/
d385 1
a385 1
	    size_t, int, const struct sockaddr *, int));
@


1.23
log
@more uses of socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.22 1999/02/15 19:04:15 millert Exp $	*/
d291 1
a291 1
	msg_namelen	msg_namelen;	/* size of address */
d295 1
a295 1
	msg_namelen	msg_controllen;	/* ancillary data buffer len */
@


1.22
log
@Use and document socklen_t
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.21 1999/02/05 00:40:22 deraadt Exp $	*/
d290 7
a296 7
	caddr_t	msg_name;		/* optional address */
	u_int	msg_namelen;		/* size of address */
	struct	iovec *msg_iov;		/* scatter/gather array */
	u_int	msg_iovlen;		/* # elements in msg_iov */
	caddr_t	msg_control;		/* ancillary data, see below */
	u_int	msg_controllen;		/* ancillary data buffer len */
	int	msg_flags;		/* flags on received message */
d317 3
a319 3
	u_int	cmsg_len;		/* data byte count, including hdr */
	int	cmsg_level;		/* originating protocol */
	int	cmsg_type;		/* protocol-specific type */
@


1.21
log
@support MSG_BCAST and MSG_MCAST
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.20 1999/01/10 02:44:33 deraadt Exp $	*/
d199 18
d346 1
d373 6
a378 6
int	accept __P((int, struct sockaddr *, int *));
int	bind __P((int, const struct sockaddr *, int));
int	connect __P((int, const struct sockaddr *, int));
int	getpeername __P((int, struct sockaddr *, int *));
int	getsockname __P((int, struct sockaddr *, int *));
int	getsockopt __P((int, int, int, void *, int *));
d381 1
a381 1
ssize_t	recvfrom __P((int, void *, size_t, int, struct sockaddr *, int *));
d387 1
a387 1
int	setsockopt __P((int, int, int, const void *, int));
@


1.20
log
@add SO_NETPROC and CMSG_{FIRSTHDR,ALIGN,LEN,SPACE}; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.19 1997/11/30 18:50:17 millert Exp $	*/
d289 2
@


1.19
log
@Move in_addr_t and in_port_t to <sys/types.h> and add sa_family_t
and suseconds_t types for XPG4.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.18 1997/11/16 19:57:39 deraadt Exp $	*/
d72 6
a77 6
#define SO_SNDBUF	0x1001		/* send buffer size */
#define SO_RCVBUF	0x1002		/* receive buffer size */
#define SO_SNDLOWAT	0x1003		/* send low-water mark */
#define SO_RCVLOWAT	0x1004		/* receive low-water mark */
#define SO_SNDTIMEO	0x1005		/* send timeout */
#define SO_RCVTIMEO	0x1006		/* receive timeout */
d80 1
d314 9
@


1.18
log
@add SHUT_* values as defined by XPG4.2
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.17 1997/07/14 03:07:21 angelos Exp $	*/
d138 3
a140 3
	u_char	sa_len;			/* total length */
	u_char	sa_family;		/* address family */
	char	sa_data[14];		/* actually longer; address value */
@


1.17
log
@Fix the CTLNET order.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.16 1997/04/24 21:34:50 angelos Exp $	*/
d189 7
@


1.16
log
@Added PF_KEY definition.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.15 1997/03/12 13:30:42 downsj Exp $	*/
d225 1
a225 1
	{ "sip", CTLTYPE_NODE }, \
d227 1
d230 1
@


1.15
log
@Move AF_SIP and put AF_INET6 in the same location as BSD/OS.

I couldn't find any use of AF_SIP in the kernel, didn't check user land.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.14 1997/02/28 03:10:02 angelos Exp $	*/
d130 2
a131 1
#define	AF_MAX		30
d187 1
d229 1
@


1.14
log
@Moved everything to netinet/in.h, where they should have been in the
first place.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.13 1997/02/28 02:18:56 angelos Exp $	*/
d123 1
a123 1
#define	AF_SIP		24		/* Simple Internet Protocol */
d129 2
a130 1
#define	AF_MAX		29
a177 1
#define	PF_SIP		AF_SIP
d179 1
d185 1
@


1.13
log
@Per security-level defaults.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.12 1997/02/28 02:14:58 angelos Exp $	*/
a79 27
#define SO_IPSEC_AUTH_LEVEL           0x1009  /* Authentication used */
#define SO_IPSEC_ESP_TRANS_LEVEL      0x100a  /* Transport encryption */
#define SO_IPSEC_ESP_NETWORK_LEVEL    0x100b  /* Full-packet encryption */

/*
 * Just for compatibility with the draft
 */

#define IPSEC_AUTH_LEVEL            SO_IPSEC_AUTH_LEVEL
#define IPSEC_ESP_TRANS_LEVEL       SO_IPSEC_ESP_TRANS_LEVEL
#define IPSEC_ESP_NETWORK_LEVEL     SO_IPSEC_ESP_NETWORK_LEVEL

/*
 * Security levels
 */

#define IPSEC_LEVEL_BYPASS	0x00	/* Bypass policy altogether */
#define IPSEC_LEVEL_NONE	0x00	/* Send clear, accept any */
#define IPSEC_LEVEL_AVAIL	0x01	/* Send secure if SA available */
#define IPSEC_LEVEL_USE		0x02	/* Send secure, accept any */
#define IPSEC_LEVEL_REQUIRE	0x03	/* Require secure inbound, also use */
#define IPSEC_LEVEL_UNIQUE	0x04	/* Use outbound SA that is unique */
#define IPSEC_LEVEL_DEFAULT	IPSEC_LEVEL_NONE

#define IPSEC_AUTH_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
#define IPSEC_ESP_TRANS_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
#define IPSEC_ESP_NETWORK_LEVEL_DEFAULT IPSEC_LEVEL_DEFAULT
@


1.12
log
@Can't make up my mind; i think this is final.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.11 1997/02/28 02:03:33 angelos Exp $	*/
d103 4
@


1.11
log
@IPsec socket API.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.10 1997/02/22 07:24:25 angelos Exp $	*/
a68 4
#define SO_IPSEC_AUTH_LEVEL           0x0400  /* Authentication used */
#define SO_IPSEC_ESP_TRANS_LEVEL      0x0800  /* Transport encryption */
#define SO_IPSEC_ESP_NETWORK_LEVEL    0x1000  /* Full-packet encryption */

d80 11
@


1.10
log
@Preliminaries for IPsec socket API.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.9 1997/02/20 01:07:35 deraadt Exp $	*/
d69 4
a95 8

/*
 * Security categories
 */

#define IP_AUTH_LEVEL		0x00
#define IP_ESP_TRANS_LEVEL	0x01
#define IP_ESP_NETWORK_LEVEL	0x02
@


1.9
log
@IPSEC package by John Ioannidis and Angelos D. Keromytis. Written in
Greece. From ftp.funet.fi:/pub/unix/security/net/ip/BSDipsec.tar.gz
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.8 1996/12/12 13:50:53 mickey Exp $	*/
d80 20
@


1.8
log
@undo last change.
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.7 1996/12/12 13:39:47 deraadt Exp $	*/
d128 2
a129 2

#define	AF_MAX		28
d183 1
a183 1

d224 1
@


1.7
log
@wrong place for bindresvport() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.6 1996/12/12 13:23:03 mickey Exp $	*/
a325 1
struct sockaddr_in;
@


1.6
log
@struct sockaddr_in; prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.5 1996/12/12 13:17:46 mickey Exp $	*/
a329 1
int	bindresvport __P((int sd, struct sockaddr_in *sin));
@


1.5
log
@int    bindresvport __P((int sd, struct sockaddr_in *sin));
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.4 1996/07/03 02:34:05 chuck Exp $	*/
d326 1
@


1.4
log
@renumber AF_NATM to avoid a conflict with freebsd which put ISDN @@ 26.
(i should have checked first)
@
text
@d1 1
a1 1
/*	$OpenBSD: socket.h,v 1.3 1996/06/30 21:33:20 chuck Exp $	*/
d329 1
@


1.3
log
@add native mode atm socket type
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 3
a127 1
#define AF_NATM		26		/* native ATM access */
d129 1
a129 1
#define	AF_MAX		27
d181 1
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d125 1
d127 1
a127 1
#define	AF_MAX		26
d179 1
d220 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: socket.h,v 1.12 1995/03/29 22:10:11 briggs Exp $	*/
d241 1
a241 1
 * Maximum queue length specifiable by listen.
d243 1
a243 1
#define	SOMAXCONN	5
d340 7
a347 1
#endif /* !_KERNEL */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
