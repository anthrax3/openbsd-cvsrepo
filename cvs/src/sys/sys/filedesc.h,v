head	1.34;
access;
symbols
	OPENBSD_6_2:1.34.0.2
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.4
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.30.0.6
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.25.0.10
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.6
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.4
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.2
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.14
	OPENBSD_5_0:1.20.0.12
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.10
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.18
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.16
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.14
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.12
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.10
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.4
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.02.11.19.51.06;	author guenther;	state Exp;
branches;
next	1.33;
commitid	dp1qF9REvzwtzfTw;

1.33
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.32;
commitid	X7Hk1efefaYrWlw3;

1.32
date	2017.01.24.04.09.59;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	zUYmRLEGzx1xH8Zk;

1.31
date	2017.01.23.22.34.10;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	99bh3dETE3sAQhkj;

1.30
date	2015.05.06.08.52.17;	author mpi;	state Exp;
branches;
next	1.29;
commitid	8Nt1erARPXBfs0Oe;

1.29
date	2015.04.30.09.20.51;	author mpi;	state Exp;
branches;
next	1.28;
commitid	ngMdImGL4WWFm6gy;

1.28
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.12.14.18.11;	author espie;	state Exp;
branches;
next	1.26;

1.26
date	2014.03.08.22.54.30;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2012.07.11.23.07.19;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.07.08.10.55.10;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2012.05.14.02.41.13;	author guenther;	state Exp;
branches;
next	1.22;

1.22
date	2012.04.12.11.07.19;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.19.12.24.55;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.22.06.11.10;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.21.12.10.20;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.06.04.18.18;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.08.16.32.27;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.26.12.03.28;	author art;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.10.26.10.39.31;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.07.22.42.07;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.16.12.49.46;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.16.20.02.20;	author provos;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.24.06.26.23;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.28.18.04.09;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.07.13.15.17.52;	author provos;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	96.04.21.22.31.44;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.21.40.55;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.12.11.46;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.01.07.17.38.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches;
next	;

1.6.4.1
date	2000.03.02.07.04.47;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.05.14.22.45.02;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2001.07.04.11.00.21;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.6.4.7;

1.6.4.7
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.6.4.8;

1.6.4.8
date	2004.02.19.11.01.33;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Add a flags argument to falloc() that lets it optionally set the
close-on-exec flag on the newly allocated fd.  Make falloc()'s
return arguments non-optional: assert that they're not NULL.

ok mpi@@ millert@@
@
text
@/*	$OpenBSD: filedesc.h,v 1.33 2017/01/25 06:15:50 mpi Exp $	*/
/*	$NetBSD: filedesc.h,v 1.14 1996/04/09 20:55:28 cgd Exp $	*/

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)filedesc.h	8.1 (Berkeley) 6/2/93
 */

#include <sys/rwlock.h>
/*
 * This structure is used for the management of descriptors.  It may be
 * shared by multiple processes.
 *
 * A process is initially started out with NDFILE descriptors stored within
 * this structure, selected to be enough for typical applications based on
 * the historical limit of 20 open files (and the usage of descriptors by
 * shells).  If these descriptors are exhausted, a larger descriptor table
 * may be allocated, up to a process' resource limit; the internal arrays
 * are then unused.  The initial expansion is set to NDEXTENT; each time
 * it runs out, it is doubled until the resource limit is reached. NDEXTENT
 * should be selected to be the biggest multiple of OFILESIZE (see below)
 * that will fit in a power-of-two sized piece of memory.
 */
#define NDFILE		20
#define NDEXTENT	50		/* 250 bytes in 256-byte alloc. */
#define NDENTRIES	32		/* 32 fds per entry */
#define NDENTRYMASK	(NDENTRIES - 1)
#define NDENTRYSHIFT	5		/* bits per entry */
#define NDREDUCE(x)	(((x) + NDENTRIES - 1) >> NDENTRYSHIFT)
#define NDHISLOTS(x)	(NDREDUCE(NDREDUCE(x)))
#define NDLOSLOTS(x)	(NDHISLOTS(x) << NDENTRYSHIFT)

struct filedesc {
	struct	file **fd_ofiles;	/* file structures for open files */
	char	*fd_ofileflags;		/* per-process open file flags */
	struct	vnode *fd_cdir;		/* current directory */
	struct	vnode *fd_rdir;		/* root directory */
	int	fd_nfiles;		/* number of open files allocated */
	int	fd_openfd;		/* number of files currently open */
	u_int	*fd_himap;		/* each bit points to 32 fds */
	u_int	*fd_lomap;		/* bitmap of free fds */
	int	fd_lastfile;		/* high-water mark of fd_ofiles */
	int	fd_freefile;		/* approx. next free file */
	u_short	fd_cmask;		/* mask for file creation */
	u_short	fd_refcnt;		/* reference count */
	struct rwlock fd_lock;		/* lock for the file descs; must be */
					/* held when writing to fd_ofiles, */
					/* fd_ofileflags, or fd_{hi,lo}map */

	int	fd_knlistsize;		/* size of knlist */
	struct	klist *fd_knlist;	/* list of attached knotes */
	u_long	fd_knhashmask;		/* size of knhash */
	struct	klist *fd_knhash;	/* hash table for attached knotes */

	int fd_flags;			/* flags on the file descriptor table */
};

/*
 * Basic allocation of descriptors:
 * one of the above, plus arrays for NDFILE descriptors.
 */
struct filedesc0 {
	struct	filedesc fd_fd;
	/*
	 * These arrays are used when the number of open files is
	 * <= NDFILE, and are then pointed to by the pointers above.
	 */
	struct	file *fd_dfiles[NDFILE];
	char	fd_dfileflags[NDFILE];
	/*
	 * There arrays are used when the number of open files is
	 * <= 1024, and are then pointed to by the pointers above.
	 */
	u_int   fd_dhimap[NDENTRIES >> NDENTRYSHIFT];
	u_int   fd_dlomap[NDENTRIES];
};

/*
 * Per-process open flags.
 */
#define	UF_EXCLOSE 	0x01		/* auto-close on exec */
#define	UF_PLEDGED 	0x02		/* open after pledge(2) */

/*
 * Flags on the file descriptor table.
 */
#define FD_ADVLOCK	0x01		/* May hold a POSIX adv. lock. */

/*
 * Storage required per open file descriptor.
 */
#define OFILESIZE (sizeof(struct file *) + sizeof(char))

#ifdef _KERNEL
/*
 * Kernel global variables and routines.
 */
void	filedesc_init(void);
int	dupfdopen(struct proc *, int, int);
int	fdalloc(struct proc *p, int want, int *result);
void	fdexpand(struct proc *);
int	falloc(struct proc *_p, int _flags, struct file **_rfp, int *_rfd);
struct	filedesc *fdinit(void);
struct	filedesc *fdshare(struct process *);
struct	filedesc *fdcopy(struct process *);
void	fdfree(struct proc *p);
int	fdrelease(struct proc *p, int);
void	fdremove(struct filedesc *, int);
void	fdcloseexec(struct proc *);
struct file *fd_getfile(struct filedesc *, int);
struct file *fd_getfile_mode(struct filedesc *, int, int);

int	closef(struct file *, struct proc *);
int	getsock(struct proc *, int, struct file **);

#define	fdplock(fdp)	do { NET_ASSERT_UNLOCKED(); rw_enter_write(&(fdp)->fd_lock); } while (0)
#define	fdpunlock(fdp)	rw_exit_write(&(fdp)->fd_lock)
#define	fdpassertlocked(fdp)	rw_assert_wrlock(&(fdp)->fd_lock)
#endif
@


1.33
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.32 2017/01/24 04:09:59 deraadt Exp $	*/
d128 1
a128 1
int	falloc(struct proc *p, struct file **resultfp, int *resultfd);
@


1.32
log
@Track a per-fd flag UF_PLEDGED.  This indicates the initial open was done by a
pledged process. dup(2) and recvmsg(2) retain UF_PLEDGED from the original fd.
In pledge "exec" circumstances, exceve clears UF_PLEDGED on all the process's
fds.

In a pledge'd process, ioctl(2) can use this additional information to grant
access to ioctl's which are more sensitive or dive deeply into the kernel.
Developers will be encouraged to open such sensitive resources before calling
pledge(2), rather than afterwards.  That matches the heading of privsep
development practices.

Future changes will introduce those ioctl(2) changes.

Lots of discussions with semarie guenther and benno.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.31 2017/01/23 22:34:10 deraadt Exp $	*/
d142 1
a142 1
#define	fdplock(fdp)	rw_enter_write(&(fdp)->fd_lock)
@


1.31
log
@Avoid curproc dance in dupfdopen(), by passing a struct proc *
ok guenther mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.30 2015/05/06 08:52:17 mpi Exp $	*/
d108 1
@


1.30
log
@Pass a thread pointer instead of its file descriptor table to getsock(9).

Diff from Vitaliy Makkoveev.

Manpage tweak and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.29 2015/04/30 09:20:51 mpi Exp $	*/
d124 1
a124 1
int	dupfdopen(struct filedesc *, int, int, int);
@


1.29
log
@Indroduce fd_getfile_mode() and use it were fd_getfile() is directly
followed by a mode check.  This will simplify the ref/unref dance as
soon as fd_getfile() will increment fp's reference counter.

Idea from and ok guenther@@, ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.28 2014/05/15 03:52:25 guenther Exp $	*/
d139 1
a139 1
int	getsock(struct filedesc *, int, struct file **);
@


1.28
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.27 2014/04/12 14:18:11 espie Exp $	*/
d135 2
a136 1
struct file *fd_getfile(struct filedesc *, int fd);
@


1.27
log
@revert falloc change, as it causes all new processes to get stuck after a while
(race condition ?)

problem noticed by me, aja, sthen, brynet, rpe.

vanishing after this revert, okay aja@@, sthen@@

tedu, you probably want to look into re-checking the fcreate/fpublish addition
first, then if it's stable, see about tweaking doopenat ?
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.26 2014/03/08 22:54:30 tedu Exp $	*/
d128 3
a130 3
struct	filedesc *fdinit(struct proc *p);
struct	filedesc *fdshare(struct proc *p);
struct	filedesc *fdcopy(struct proc *p);
@


1.26
log
@split falloc into two functions, the allocation and the publication.
the first part is likely to fail, but we can generally prevent the second
part from failing.
use these two functions to drop the fdp lock around vn_open in sys_open,
but still maintain the original semantics of allocate then open.
the goal here is to fix the blocked fifo deadlock in a threaded program.

testing volunteers in short supply, resorting to conscription
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.25 2012/07/11 23:07:19 guenther Exp $	*/
a127 2
int	fcreate(struct proc *p, struct file **resultfp);
int	fpublish(struct proc *p, struct file *fp, int *resultfd);
@


1.25
log
@Revert the blocked FIFO open fix, as there's either a race in the
ref-count handling under handling, or blambert@@ is messing with my head
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.23 2012/05/14 02:41:13 guenther Exp $	*/
d128 2
@


1.24
log
@Don't hold the fd-table lock across vn_open(), as opening a FIFO may block.
Having done that, dupfdopen() has to handle a possible race.

ok matthew@@ krw@@
@
text
@d124 1
a124 1
int	dupfdopen(struct proc *, int, struct file *, int);
@


1.23
log
@Remove the "vn_open() returning ENXIO means dup+close" hook that
was used by the now defunct portalfs.  Zero out fd_ofileflags[fd]
when allocating an fd instead of when releasing it.

ok krw@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.22 2012/04/12 11:07:19 deraadt Exp $	*/
d124 1
a124 1
int	dupfdopen(struct filedesc *, int, int, int);
@


1.22
log
@New system call: getdtablecount(2) returns the number of file
descriptors the process currently has open.
ok guenther miod gilles ...
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.21 2012/02/15 04:26:27 guenther Exp $	*/
d124 1
a124 2
int	dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode,
	    int error);
@


1.21
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.20 2008/09/19 12:24:55 art Exp $	*/
d65 1
@


1.20
log
@Fix a bunch of problems and races with posix file locking.

- file descriptor table becomes the owner of the lock instead of the proc.
- When grabbing the lock, we check if the fd hasn't changed under our
  feet, this is more or less impossible to solve without a hack like
  this. I've banged my head against the wall, I figured out a solution,
  but implementing it correctly would cost me 12 gray hairs. Screw it,
  this is ugly, but it works.
- Wait until usecount drains before releasing the posix lock in closef.
- Add missing FREF/FRELE to sys_flock
- keep the pid in the flock struct instead of abusing the fact that we
  used to use the proc as the lock owner.

Pointed out by and discussed with Al Viro, big thanks.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.19 2004/07/22 06:11:10 tedu Exp $	*/
d71 3
a73 1
	struct rwlock fd_lock;		/* lock for the file descs */
d142 1
@


1.19
log
@remove p arg from fdplock
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.18 2004/07/21 12:10:20 art Exp $	*/
d77 2
d105 5
@


1.18
log
@I was wrong. The assymetry created by the proc argument to rw_enter_write
is horrible and doesn't add anything.

Remove it.
XXX - the fdplock macro will need a separate cleanup.

niklas@@ markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.17 2004/01/06 04:18:18 tedu Exp $	*/
d131 1
a131 2
/* XXX - remove the p param. */
#define	fdplock(fdp, p)	rw_enter_write(&(fdp)->fd_lock)
@


1.17
log
@lock filedesc before manipulating.  avoids some rare races.
testing for quite some time by brad + otto
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.16 2003/06/02 23:28:21 millert Exp $	*/
d131 2
a132 1
#define	fdplock(fdp, p)	rw_enter_write(&(fdp)->fd_lock, p)
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.15 2002/03/14 01:27:14 millert Exp $	*/
d35 1
a35 1
#include <sys/lock.h>
d71 1
a71 1
	struct lock fd_lock;		/* lock for growing the structure */
d130 3
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.14 2002/02/08 16:32:27 art Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@No more need for ffree. Since it's hard to use it safely, remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.13 2001/10/26 12:03:28 art Exp $	*/
d117 14
a130 14
void	filedesc_init __P((void));
int	dupfdopen __P((struct filedesc *fdp, int indx, int dfd, int mode,
	    int error));
int	fdalloc __P((struct proc *p, int want, int *result));
void	fdexpand __P((struct proc *));
int	falloc __P((struct proc *p, struct file **resultfp, int *resultfd));
struct	filedesc *fdinit __P((struct proc *p));
struct	filedesc *fdshare __P((struct proc *p));
struct	filedesc *fdcopy __P((struct proc *p));
void	fdfree __P((struct proc *p));
int	fdrelease __P((struct proc *p, int));
void	fdremove __P((struct filedesc *, int));
void	fdcloseexec __P((struct proc *));
struct file *fd_getfile __P((struct filedesc *, int fd));
d132 2
a133 2
int	closef __P((struct file *, struct proc *));
int	getsock __P((struct filedesc *, int, struct file **));
@


1.13
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.12 2001/10/26 10:39:31 art Exp $	*/
a122 1
void	ffree __P((struct file *));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.13 2001/10/26 12:03:28 art Exp $	*/
d117 15
a131 14
void	filedesc_init(void);
int	dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode,
	    int error);
int	fdalloc(struct proc *p, int want, int *result);
void	fdexpand(struct proc *);
int	falloc(struct proc *p, struct file **resultfp, int *resultfd);
struct	filedesc *fdinit(struct proc *p);
struct	filedesc *fdshare(struct proc *p);
struct	filedesc *fdcopy(struct proc *p);
void	fdfree(struct proc *p);
int	fdrelease(struct proc *p, int);
void	fdremove(struct filedesc *, int);
void	fdcloseexec(struct proc *);
struct file *fd_getfile(struct filedesc *, int fd);
d133 2
a134 2
int	closef(struct file *, struct proc *);
int	getsock(struct filedesc *, int, struct file **);
@


1.12
log
@ - split fdalloc into two functions. fdalloc now returns ENOSPC if it
   would have to grow the table and fdexpand that grows the table. Since
   fdexpand can sleep we have to restart all operations if we have to call
   it.
 - dup2 changed so that finishdup frees the destination descriptor.
 - unp_externalize is a completly rewritten version from NetBSD.

Changes mostly inspired by NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.11 2001/10/07 22:42:07 art Exp $	*/
a121 1
int	fdavail __P((struct proc *p, int n));
d131 1
@


1.11
log
@gc UF_MAPPED.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.10 2001/05/16 12:49:46 art Exp $	*/
d39 1
d75 1
d121 1
@


1.10
log
@Use pool to allocate struct filedesc0 and struct file.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.9 2000/11/16 20:02:20 provos Exp $	*/
a104 1
#define	UF_MAPPED 	0x02		/* mapped from device */
@


1.9
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.8 2000/04/24 06:26:23 provos Exp $	*/
d116 1
@


1.8
log
@fix macros that calculated bitmap size for fdalloc. fries@@ helped debugging.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.7 2000/02/28 18:04:09 provos Exp $	*/
d74 5
@


1.7
log
@Optimized fdalloc as in Banga and Mogul paper:
http://www.usenix.org/publications/library/proceedings/usenix98/banga.html
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.6 1999/07/13 15:17:52 provos Exp $	*/
d58 3
a60 2
#define NDLOSLOTS(x)	(((x) + NDENTRIES - 1) >> NDENTRYSHIFT)
#define NDHISLOTS(x)	((NDLOSLOTS(x) + NDENTRIES - 1) >> NDENTRYSHIFT)
@


1.6
log
@introduce fdremove() to mark a file descriptor as unused. fdremove makes
sure that the fd_freefile hints stay in sync, otherwise free file
descriptors might not be overlooked by fdalloc(); ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.4 1996/04/18 21:40:55 niklas Exp $	*/
d55 5
d67 2
d87 6
@


1.6.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a54 5
#define NDENTRIES	32		/* 32 fds per entry */
#define NDENTRYMASK	(NDENTRIES - 1)
#define NDENTRYSHIFT	5		/* bits per entry */
#define NDLOSLOTS(x)	(((x) + NDENTRIES - 1) >> NDENTRYSHIFT)
#define NDHISLOTS(x)	((NDLOSLOTS(x) + NDENTRIES - 1) >> NDENTRYSHIFT)
a61 2
	u_int	*fd_himap;		/* each bit points to 32 fds */
	u_int	*fd_lomap;		/* bitmap of free fds */
a79 6
	/*
	 * There arrays are used when the number of open files is
	 * <= 1024, and are then pointed to by the pointers above.
	 */
	u_int   fd_dhimap[NDENTRIES >> NDENTRYSHIFT];
	u_int   fd_dlomap[NDENTRIES];
@


1.6.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.9 2000/11/16 20:02:20 provos Exp $	*/
d58 2
a59 3
#define NDREDUCE(x)	(((x) + NDENTRIES - 1) >> NDENTRYSHIFT)
#define NDHISLOTS(x)	(NDREDUCE(NDREDUCE(x)))
#define NDLOSLOTS(x)	(NDHISLOTS(x) << NDENTRYSHIFT)
a72 5

	int	fd_knlistsize;		/* size of knlist */
	struct	klist *fd_knlist;	/* list of attached knotes */
	u_long	fd_knhashmask;		/* size of knhash */
	struct	klist *fd_knhash;	/* hash table for attached knotes */
@


1.6.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.6.4.2 2001/05/14 22:45:02 niklas Exp $	*/
a115 1
void	filedesc_init __P((void));
@


1.6.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.6.4.3 2001/07/04 11:00:21 niklas Exp $	*/
a38 1
#include <sys/lock.h>
a73 1
	struct lock fd_lock;		/* lock for growing the structure */
d105 1
d120 1
a120 1
void	fdexpand __P((struct proc *));
a129 1
struct file *fd_getfile __P((struct filedesc *, int fd));
@


1.6.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d123 1
@


1.6.4.6
log
@Merge in -current from roughly a week ago
@
text
@d117 14
a130 14
void	filedesc_init(void);
int	dupfdopen(struct filedesc *fdp, int indx, int dfd, int mode,
	    int error);
int	fdalloc(struct proc *p, int want, int *result);
void	fdexpand(struct proc *);
int	falloc(struct proc *p, struct file **resultfp, int *resultfd);
struct	filedesc *fdinit(struct proc *p);
struct	filedesc *fdshare(struct proc *p);
struct	filedesc *fdcopy(struct proc *p);
void	fdfree(struct proc *p);
int	fdrelease(struct proc *p, int);
void	fdremove(struct filedesc *, int);
void	fdcloseexec(struct proc *);
struct file *fd_getfile(struct filedesc *, int fd);
d132 2
a133 2
int	closef(struct file *, struct proc *);
int	getsock(struct filedesc *, int, struct file **);
@


1.6.4.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: filedesc.h,v 1.6.4.6 2002/03/28 14:52:01 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d35 1
a35 1
#include <sys/rwlock.h>
d71 1
a71 1
	struct rwlock fd_lock;		/* lock for the file descs */
a129 3

#define	fdplock(fdp, p)	rw_enter_write(&(fdp)->fd_lock, p)
#define	fdpunlock(fdp)	rw_exit_write(&(fdp)->fd_lock)
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d108 1
@


1.4
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: filedesc.h,v 1.3 1996/03/03 12:11:46 niklas Exp $	*/
/*	$NetBSD: filedesc.h,v 1.13 1996/03/14 18:59:09 christos Exp $	*/
d54 1
a54 1
#define NDEXTENT	50		/* 250 bytes in 256-byte alloc. */ 
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: filedesc.h,v 1.12 1996/02/09 18:25:11 christos Exp $	*/
a98 1
int	fdopen __P((dev_t, int, int, struct proc *));
@


1.2
log
@add fdshare() and fdinit() calls for dealing with filedesc structures
@
text
@d1 2
a2 1
/*	$NetBSD: filedesc.h,v 1.11 1995/03/26 20:24:14 jtc Exp $	*/
d99 1
d103 1
d108 5
@


1.1
log
@Initial revision
@
text
@d101 2
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
