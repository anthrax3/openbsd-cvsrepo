head	1.240;
access;
symbols
	OPENBSD_6_2_BASE:1.240
	OPENBSD_6_1:1.236.0.4
	OPENBSD_6_1_BASE:1.236
	OPENBSD_6_0:1.224.0.2
	OPENBSD_6_0_BASE:1.224
	OPENBSD_5_9:1.213.0.2
	OPENBSD_5_9_BASE:1.213
	OPENBSD_5_8:1.203.0.4
	OPENBSD_5_8_BASE:1.203
	OPENBSD_5_7:1.199.0.2
	OPENBSD_5_7_BASE:1.199
	OPENBSD_5_6:1.190.0.4
	OPENBSD_5_6_BASE:1.190
	OPENBSD_5_5:1.177.0.4
	OPENBSD_5_5_BASE:1.177
	OPENBSD_5_4:1.168.0.2
	OPENBSD_5_4_BASE:1.168
	OPENBSD_5_3:1.165.0.2
	OPENBSD_5_3_BASE:1.165
	OPENBSD_5_2:1.161.0.2
	OPENBSD_5_2_BASE:1.161
	OPENBSD_5_1_BASE:1.149
	OPENBSD_5_1:1.149.0.2
	OPENBSD_5_0:1.141.0.2
	OPENBSD_5_0_BASE:1.141
	OPENBSD_4_9:1.132.0.4
	OPENBSD_4_9_BASE:1.132
	OPENBSD_4_8:1.132.0.2
	OPENBSD_4_8_BASE:1.132
	OPENBSD_4_7:1.123.0.2
	OPENBSD_4_7_BASE:1.123
	OPENBSD_4_6:1.119.0.4
	OPENBSD_4_6_BASE:1.119
	OPENBSD_4_5:1.111.0.2
	OPENBSD_4_5_BASE:1.111
	OPENBSD_4_4:1.103.0.2
	OPENBSD_4_4_BASE:1.103
	OPENBSD_4_3:1.102.0.2
	OPENBSD_4_3_BASE:1.102
	OPENBSD_4_2:1.100.0.2
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.90.0.2
	OPENBSD_4_1_BASE:1.90
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.84.0.2
	OPENBSD_3_9_BASE:1.84
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.77.0.2
	OPENBSD_3_7_BASE:1.77
	OPENBSD_3_6:1.75.0.2
	OPENBSD_3_6_BASE:1.75
	SMP_SYNC_A:1.70
	SMP_SYNC_B:1.70
	OPENBSD_3_5:1.68.0.2
	OPENBSD_3_5_BASE:1.68
	OPENBSD_3_4:1.67.0.2
	OPENBSD_3_4_BASE:1.67
	UBC_SYNC_A:1.63
	OPENBSD_3_3:1.62.0.4
	OPENBSD_3_3_BASE:1.62
	OPENBSD_3_2:1.62.0.2
	OPENBSD_3_2_BASE:1.62
	OPENBSD_3_1:1.59.0.2
	OPENBSD_3_1_BASE:1.59
	UBC_SYNC_B:1.62
	UBC:1.51.0.2
	UBC_BASE:1.51
	OPENBSD_3_0:1.48.0.2
	OPENBSD_3_0_BASE:1.48
	OPENBSD_2_9_BASE:1.40
	OPENBSD_2_9:1.40.0.2
	OPENBSD_2_8:1.32.0.2
	OPENBSD_2_8_BASE:1.32
	OPENBSD_2_7:1.30.0.2
	OPENBSD_2_7_BASE:1.30
	SMP:1.28.0.2
	SMP_BASE:1.28
	kame_19991208:1.25
	OPENBSD_2_6:1.25.0.2
	OPENBSD_2_6_BASE:1.25
	OPENBSD_2_5:1.24.0.2
	OPENBSD_2_5_BASE:1.24
	OPENBSD_2_4:1.17.0.4
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.240
date	2017.08.29.02.51.27;	author deraadt;	state Exp;
branches;
next	1.239;
commitid	rqeb3Cn0JHXrssFn;

1.239
date	2017.04.28.13.50.55;	author mpi;	state Exp;
branches;
next	1.238;
commitid	34WECc0W9rocx17W;

1.238
date	2017.04.20.12.59.36;	author visa;	state Exp;
branches;
next	1.237;
commitid	35AK3Wv48Mc7uWnr;

1.237
date	2017.04.13.03.52.25;	author guenther;	state Exp;
branches;
next	1.236;
commitid	ziRFTEFDWOo0M88l;

1.236
date	2017.03.05.06.40.18;	author guenther;	state Exp;
branches;
next	1.235;
commitid	o7MExfu3hLGcFA21;

1.235
date	2017.02.14.10.31.15;	author mpi;	state Exp;
branches;
next	1.234;
commitid	PmGi4EGraGC0Z0ml;

1.234
date	2017.02.12.04.55.08;	author guenther;	state Exp;
branches;
next	1.233;
commitid	1rXx7AiXIWFC9gYa;

1.233
date	2017.02.08.20.58.30;	author guenther;	state Exp;
branches;
next	1.232;
commitid	RODF8jyufTSNUZTf;

1.232
date	2017.01.31.07.44.55;	author visa;	state Exp;
branches;
next	1.231;
commitid	Wpme2tT4CHE0IeiA;

1.231
date	2017.01.24.02.28.17;	author visa;	state Exp;
branches;
next	1.230;
commitid	Co0ej12l7nGroAdw;

1.230
date	2017.01.24.00.58.55;	author mpi;	state Exp;
branches;
next	1.229;
commitid	r0ks7yUPmANG37rA;

1.229
date	2017.01.21.05.42.03;	author guenther;	state Exp;
branches;
next	1.228;
commitid	CHRb0fCqa8XxUAMH;

1.228
date	2016.11.07.02.50.33;	author guenther;	state Exp;
branches;
next	1.227;
commitid	3QdsuYzXBfTJ9cvQ;

1.227
date	2016.11.07.00.26.32;	author guenther;	state Exp;
branches;
next	1.226;
commitid	W7ztnDZwvjCaeQTS;

1.226
date	2016.09.03.08.47.24;	author tedu;	state Exp;
branches;
next	1.225;
commitid	b3PNdQY6RzTJM7JI;

1.225
date	2016.09.02.18.11.28;	author tedu;	state Exp;
branches;
next	1.224;
commitid	rTRs82DQAsJjej88;

1.224
date	2016.06.27.19.55.02;	author jca;	state Exp;
branches;
next	1.223;
commitid	bjXjarVuCgiWznx4;

1.223
date	2016.05.30.21.31.27;	author deraadt;	state Exp;
branches;
next	1.222;
commitid	KDWNECRaSEemSTKP;

1.222
date	2016.05.30.21.25.48;	author deraadt;	state Exp;
branches;
next	1.221;
commitid	EKR1QpDNmTXzcvJY;

1.221
date	2016.05.30.21.22.45;	author deraadt;	state Exp;
branches;
next	1.220;
commitid	WldUSxuLRn3bASy2;

1.220
date	2016.05.10.18.39.53;	author deraadt;	state Exp;
branches;
next	1.219;
commitid	qfOifNidEGDB2jL1;

1.219
date	2016.04.25.20.18.31;	author tedu;	state Exp;
branches;
next	1.218;
commitid	AL2KSeDZVXs2nAYI;

1.218
date	2016.03.29.08.46.08;	author mpi;	state Exp;
branches;
next	1.217;
commitid	Yyb4nhV2PH21mCBk;

1.217
date	2016.03.09.13.38.50;	author mpi;	state Exp;
branches;
next	1.216;
commitid	THpTza9IRRtZUKne;

1.216
date	2016.03.06.05.20.26;	author guenther;	state Exp;
branches;
next	1.215;
commitid	MvBfQoVendDQNACE;

1.215
date	2016.03.06.05.17.23;	author guenther;	state Exp;
branches;
next	1.214;
commitid	gUDsFpwkL8TvzBil;

1.214
date	2016.03.04.14.08.55;	author deraadt;	state Exp;
branches;
next	1.213;
commitid	BrqU9MYFFryc49yZ;

1.213
date	2015.12.06.17.50.21;	author deraadt;	state Exp;
branches;
next	1.212;
commitid	fXd8HOPcFESXsWp4;

1.212
date	2015.11.03.16.14.14;	author deraadt;	state Exp;
branches;
next	1.211;
commitid	0guBDAktsQ8jv0a9;

1.211
date	2015.11.02.16.31.55;	author semarie;	state Exp;
branches;
next	1.210;
commitid	PyvdcQVr9G4daVnG;

1.210
date	2015.10.25.20.39.54;	author deraadt;	state Exp;
branches;
next	1.209;
commitid	SIwCBDJKKae61tEi;

1.209
date	2015.10.20.06.40.01;	author semarie;	state Exp;
branches;
next	1.208;
commitid	cZnfuIvm8DKmhV1I;

1.208
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.207;
commitid	19QhHGSTTsDpRV7q;

1.207
date	2015.10.10.14.46.15;	author deraadt;	state Exp;
branches;
next	1.206;
commitid	lDLsX85yoZrvGrDS;

1.206
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.205;
commitid	av6ZVErLSWkVP5Zz;

1.205
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.204;
commitid	Lqreadw8v5IPAc0L;

1.204
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	6NDuzTPjBp2GqkfQ;

1.203
date	2015.07.27.18.22.37;	author deraadt;	state Exp;
branches;
next	1.202;
commitid	4VS4Pd5BumhjJccK;

1.202
date	2015.07.20.00.56.10;	author guenther;	state Exp;
branches;
next	1.201;
commitid	pi31sn0pO464Xi5e;

1.201
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.200;
commitid	CJwjm9NDWu6nJ6ES;

1.200
date	2015.07.18.00.15.10;	author mpi;	state Exp;
branches;
next	1.199;
commitid	svWHR2riSjL5ppiW;

1.199
date	2015.02.10.05.28.18;	author guenther;	state Exp;
branches;
next	1.198;
commitid	GFzml5gt9M5PfXe6;

1.198
date	2015.02.09.04.27.18;	author dlg;	state Exp;
branches;
next	1.197;
commitid	TKFPZyQFcpTPAaAg;

1.197
date	2015.02.09.04.06.13;	author dlg;	state Exp;
branches;
next	1.196;
commitid	qDlxCHaNQ0eNqaHK;

1.196
date	2015.02.09.03.46.12;	author dlg;	state Exp;
branches;
next	1.195;
commitid	hQdpZkrpeskBpZi1;

1.195
date	2015.02.09.03.15.41;	author dlg;	state Exp;
branches;
next	1.194;
commitid	jVd0KngVszV2FEfg;

1.194
date	2015.01.26.22.51.37;	author kettenis;	state Exp;
branches;
next	1.193;
commitid	4sRCDm8befLIJUvK;

1.193
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.192;
commitid	Fn841MmVYz2JHvBP;

1.192
date	2015.01.15.23.59.09;	author deraadt;	state Exp;
branches;
next	1.191;
commitid	8dqrutlKlF52CKVT;

1.191
date	2014.11.16.05.42.21;	author guenther;	state Exp;
branches;
next	1.190;
commitid	xuyVjwR0omX0ygFF;

1.190
date	2014.07.13.16.41.21;	author claudio;	state Exp;
branches;
next	1.189;
commitid	04aN4E0CXyBXMp3X;

1.189
date	2014.07.12.21.21.19;	author matthew;	state Exp;
branches;
next	1.188;
commitid	hPWqptyZtIqB8x1B;

1.188
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.187;
commitid	zJyOCNTjgsYVGLiw;

1.187
date	2014.07.04.05.58.30;	author guenther;	state Exp;
branches;
next	1.186;
commitid	vhXZZxMGVTWiFaF3;

1.186
date	2014.05.15.03.52.25;	author guenther;	state Exp;
branches;
next	1.185;

1.185
date	2014.05.04.05.03.26;	author guenther;	state Exp;
branches;
next	1.184;

1.184
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.183;

1.183
date	2014.03.31.22.20.15;	author matthew;	state Exp;
branches;
next	1.182;

1.182
date	2014.03.30.21.54.48;	author guenther;	state Exp;
branches;
next	1.181;

1.181
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.180;

1.180
date	2014.03.27.04.12.28;	author guenther;	state Exp;
branches;
next	1.179;

1.179
date	2014.03.26.05.23.41;	author guenther;	state Exp;
branches;
next	1.178;

1.178
date	2014.03.22.06.05.45;	author guenther;	state Exp;
branches;
next	1.177;

1.177
date	2014.02.12.05.47.36;	author guenther;	state Exp;
branches;
next	1.176;

1.176
date	2014.02.09.11.17.19;	author kettenis;	state Exp;
branches;
next	1.175;

1.175
date	2014.02.04.00.33.43;	author tedu;	state Exp;
branches;
next	1.174;

1.174
date	2014.01.20.21.19.27;	author guenther;	state Exp;
branches;
next	1.173;

1.173
date	2014.01.20.03.23.42;	author guenther;	state Exp;
branches;
next	1.172;

1.172
date	2013.10.25.04.42.48;	author guenther;	state Exp;
branches;
next	1.171;

1.171
date	2013.10.08.03.50.06;	author guenther;	state Exp;
branches;
next	1.170;

1.170
date	2013.09.22.17.28.33;	author guenther;	state Exp;
branches;
next	1.169;

1.169
date	2013.08.12.20.43.28;	author bluhm;	state Exp;
branches;
next	1.168;

1.168
date	2013.06.06.13.09.37;	author haesbaert;	state Exp;
branches;
next	1.167;

1.167
date	2013.06.05.00.53.27;	author tedu;	state Exp;
branches;
next	1.166;

1.166
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.165;

1.165
date	2013.02.11.11.11.42;	author mpi;	state Exp;
branches;
next	1.164;

1.164
date	2013.01.15.02.03.38;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2012.09.11.15.44.19;	author deraadt;	state Exp;
branches;
next	1.162;

1.162
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.161;

1.161
date	2012.07.17.21.59.56;	author guenther;	state Exp;
branches;
next	1.160;

1.160
date	2012.07.11.08.45.21;	author guenther;	state Exp;
branches;
next	1.159;

1.159
date	2012.06.13.22.47.40;	author ariane;	state Exp;
branches;
next	1.158;

1.158
date	2012.04.13.16.37.50;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2012.04.12.12.33.03;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2012.04.12.10.11.41;	author mikeb;	state Exp;
branches;
next	1.155;

1.155
date	2012.04.11.15.28.50;	author kettenis;	state Exp;
branches;
next	1.154;

1.154
date	2012.04.10.15.50.52;	author guenther;	state Exp;
branches;
next	1.153;

1.153
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.152;

1.152
date	2012.03.10.05.54.28;	author guenther;	state Exp;
branches;
next	1.151;

1.151
date	2012.02.28.05.36.57;	author guenther;	state Exp;
branches;
next	1.150;

1.150
date	2012.02.20.22.23.39;	author guenther;	state Exp;
branches;
next	1.149;

1.149
date	2012.01.07.05.38.12;	author guenther;	state Exp;
branches;
next	1.148;

1.148
date	2011.12.14.07.32.16;	author guenther;	state Exp;
branches;
next	1.147;

1.147
date	2011.12.11.19.42.28;	author guenther;	state Exp;
branches;
next	1.146;

1.146
date	2011.11.22.23.20.19;	author joshe;	state Exp;
branches;
next	1.145;

1.145
date	2011.10.18.01.06.15;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2011.10.15.23.35.29;	author guenther;	state Exp;
branches;
next	1.143;

1.143
date	2011.09.20.10.07.37;	author deraadt;	state Exp;
branches;
next	1.142;

1.142
date	2011.09.18.23.07.32;	author guenther;	state Exp;
branches;
next	1.141;

1.141
date	2011.07.07.18.00.33;	author guenther;	state Exp;
branches;
next	1.140;

1.140
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.139;

1.139
date	2011.07.05.04.48.02;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2011.04.18.21.44.56;	author guenther;	state Exp;
branches;
next	1.137;

1.137
date	2011.04.15.04.52.40;	author guenther;	state Exp;
branches;
next	1.136;

1.136
date	2011.04.04.13.00.13;	author guenther;	state Exp;
branches;
next	1.135;

1.135
date	2011.04.03.14.56.28;	author guenther;	state Exp;
branches;
next	1.134;

1.134
date	2011.04.02.17.04.35;	author guenther;	state Exp;
branches;
next	1.133;

1.133
date	2011.03.07.07.07.13;	author guenther;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.131;

1.131
date	2010.07.19.23.00.15;	author guenther;	state Exp;
branches;
next	1.130;

1.130
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.129;

1.129
date	2010.06.30.00.40.28;	author guenther;	state Exp;
branches;
next	1.128;

1.128
date	2010.06.29.20.25.57;	author guenther;	state Exp;
branches;
next	1.127;

1.127
date	2010.05.18.22.26.10;	author tedu;	state Exp;
branches;
next	1.126;

1.126
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.125;

1.125
date	2010.04.06.22.26.59;	author tedu;	state Exp;
branches;
next	1.124;

1.124
date	2010.03.24.23.18.17;	author tedu;	state Exp;
branches;
next	1.123;

1.123
date	2010.01.28.19.23.06;	author guenther;	state Exp;
branches;
next	1.122;

1.122
date	2009.12.23.07.40.31;	author guenther;	state Exp;
branches;
next	1.121;

1.121
date	2009.12.20.23.36.04;	author guenther;	state Exp;
branches;
next	1.120;

1.120
date	2009.11.27.20.05.50;	author guenther;	state Exp;
branches;
next	1.119;

1.119
date	2009.06.05.00.30.05;	author guenther;	state Exp;
branches
	1.119.4.1;
next	1.118;

1.118
date	2009.06.02.23.05.31;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2009.04.17.15.17.27;	author blambert;	state Exp;
branches;
next	1.116;

1.116
date	2009.04.14.09.13.25;	author art;	state Exp;
branches;
next	1.115;

1.115
date	2009.04.03.09.29.15;	author art;	state Exp;
branches;
next	1.114;

1.114
date	2009.03.26.17.24.33;	author oga;	state Exp;
branches;
next	1.113;

1.113
date	2009.03.23.13.25.11;	author art;	state Exp;
branches;
next	1.112;

1.112
date	2009.03.05.19.52.24;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2008.12.16.07.57.28;	author guenther;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2008.11.07.02.22.33;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2008.11.01.05.59.20;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2008.10.14.18.27.29;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2008.10.10.14.35.06;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2008.10.09.06.31.53;	author guenther;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.03.04.22.37;	author guenther;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.19.12.24.55;	author art;	state Exp;
branches;
next	1.103;

1.103
date	2008.05.05.15.37.41;	author thib;	state Exp;
branches;
next	1.102;

1.102
date	2007.11.28.20.07.36;	author oga;	state Exp;
branches;
next	1.101;

1.101
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.100;

1.100
date	2007.07.25.23.11.53;	author art;	state Exp;
branches;
next	1.99;

1.99
date	2007.05.31.22.07.53;	author thib;	state Exp;
branches;
next	1.98;

1.98
date	2007.05.16.17.27.30;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2007.05.08.11.16.31;	author art;	state Exp;
branches;
next	1.96;

1.96
date	2007.04.14.11.06.43;	author espie;	state Exp;
branches;
next	1.95;

1.95
date	2007.04.12.22.14.15;	author tedu;	state Exp;
branches;
next	1.94;

1.94
date	2007.04.04.13.53.26;	author pedro;	state Exp;
branches;
next	1.93;

1.93
date	2007.04.03.08.05.43;	author art;	state Exp;
branches;
next	1.92;

1.92
date	2007.03.24.16.01.22;	author art;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.21.09.09.52;	author art;	state Exp;
branches;
next	1.90;

1.90
date	2007.02.06.18.42.37;	author art;	state Exp;
branches;
next	1.89;

1.89
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2006.06.28.14.17.07;	author mickey;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.15.20.08.02;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2006.05.29.20.42.53;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2006.04.28.08.34.31;	author pedro;	state Exp;
branches;
next	1.84;

1.84
date	2005.12.22.06.55.03;	author tedu;	state Exp;
branches;
next	1.83;

1.83
date	2005.12.07.19.04.50;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2005.12.03.18.09.09;	author tedu;	state Exp;
branches;
next	1.81;

1.81
date	2005.11.21.18.16.46;	author millert;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.14.20.55.59;	author kettenis;	state Exp;
branches;
next	1.79;

1.79
date	2005.05.29.03.20.42;	author deraadt;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2005.05.25.23.17.47;	author niklas;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.10.17.26.10;	author tedu;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2004.11.23.19.08.55;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2004.07.22.15.42.11;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2004.06.21.23.12.14;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2004.06.20.08.25.30;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2004.06.20.06.47.31;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2004.06.13.21.49.28;	author niklas;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.09.20.18.28;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.02.19.08.58;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.08.06.11.11;	author nordin;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.21.18.56.07;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2003.08.03.19.25.49;	author millert;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.21.00.42.58;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.12.19.56.03;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.20.19.24.57;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.16.16.16.52;	author provos;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.18.07.48.11;	author hugh;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.56;

1.56
date	2002.02.16.18.06.39;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.31.02.12.18;	author weingart;	state Exp;
branches;
next	1.54;

1.54
date	2002.01.25.15.00.26;	author art;	state Exp;
branches;
next	1.53;

1.53
date	2002.01.23.15.46.48;	author art;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.20.11.27.52;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2001.12.01.23.42.22;	author deraadt;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2001.11.11.22.30.56;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.06.18.41.10;	author art;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.22.10.29.42;	author niklas;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2001.08.07.22.57.15;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.02.11.06.38;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2001.07.05.07.31.03;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.27.04.51.48;	author art;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.22.23.55.22;	author art;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.19.07.54.37;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.18.13.18.36;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2001.04.02.21.43.12;	author niklas;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.03.25.18.09.18;	author csapuntz;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.23.18.42.06;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.03.11.50.56;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.03.11.46.48;	author art;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.27.09.07.54;	author csapuntz;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.16.20.02.20;	author provos;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.08.05.38.47;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2000.07.07.15.57.01;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2000.06.05.11.02.48;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2000.04.19.09.58.19;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2000.03.23.14.43.47;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2000.01.31.19.57.20;	author deraadt;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2000.01.31.01.09.09;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2000.01.28.19.45.03;	author art;	state Exp;
branches;
next	1.25;

1.25
date	99.08.17.10.32.18;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	99.02.26.02.30.33;	author art;	state Exp;
branches;
next	1.23;

1.23
date	99.01.11.21.20.00;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	99.01.10.02.20.19;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	99.01.05.00.43.20;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.01.04.08.09.53;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.12.29.17.05.50;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.12.28.06.28.14;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.02.22.01.00.25;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.09.15.05.46.14;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	97.07.28.09.13.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.06.05.10.15.22;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.02.01.21.49.30;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.01.27.22.48.41;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.11.24.01.39.23;	author kstailey;	state Exp;
branches;
next	1.10;

1.10
date	96.08.31.09.15.12;	author pefo;	state Exp;
branches;
next	1.9;

1.9
date	96.08.25.09.51.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.28.12.16.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.02.13.14.54;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.18.21.41.05;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.03.24.18.07.57;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.03.24.17.40.44;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.03.19.21.10.48;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.07;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.28.2.1
date	2000.03.24.09.09.44;	author niklas;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2001.05.14.22.45.03;	author niklas;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2001.07.04.11.00.27;	author niklas;	state Exp;
branches;
next	1.28.2.4;

1.28.2.4
date	2001.07.14.10.02.47;	author ho;	state Exp;
branches;
next	1.28.2.5;

1.28.2.5
date	2001.10.27.09.47.29;	author niklas;	state Exp;
branches;
next	1.28.2.6;

1.28.2.6
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.28.2.7;

1.28.2.7
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.28.2.8;

1.28.2.8
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.28.2.9;

1.28.2.9
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.28.2.10;

1.28.2.10
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.28.2.11;

1.28.2.11
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.28.2.12;

1.28.2.12
date	2003.05.15.04.08.03;	author niklas;	state Exp;
branches;
next	1.28.2.13;

1.28.2.13
date	2003.05.15.23.36.53;	author niklas;	state Exp;
branches;
next	1.28.2.14;

1.28.2.14
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.28.2.15;

1.28.2.15
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.28.2.16;

1.28.2.16
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	1.28.2.17;

1.28.2.17
date	2004.04.21.09.40.50;	author niklas;	state Exp;
branches;
next	1.28.2.18;

1.28.2.18
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	1.28.2.19;

1.28.2.19
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	1.28.2.20;

1.28.2.20
date	2004.06.06.05.21.59;	author tedu;	state Exp;
branches;
next	1.28.2.21;

1.28.2.21
date	2004.06.06.23.20.30;	author deraadt;	state Exp;
branches;
next	1.28.2.22;

1.28.2.22
date	2004.06.06.23.36.25;	author deraadt;	state Exp;
branches;
next	1.28.2.23;

1.28.2.23
date	2004.06.09.20.15.38;	author deraadt;	state Exp;
branches;
next	1.28.2.24;

1.28.2.24
date	2004.06.10.11.40.35;	author niklas;	state Exp;
branches;
next	1.28.2.25;

1.28.2.25
date	2004.06.10.17.55.12;	author deraadt;	state Exp;
branches;
next	;

1.40.2.1
date	2002.02.20.08.52.38;	author miod;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2002.02.21.00.10.40;	author miod;	state Exp;
branches;
next	;

1.48.2.1
date	2002.01.23.03.10.01;	author jason;	state Exp;
branches;
next	1.48.2.2;

1.48.2.2
date	2002.02.21.04.14.57;	author jason;	state Exp;
branches;
next	;

1.51.2.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;

1.77.2.1
date	2005.12.30.01.28.02;	author brad;	state Exp;
branches;
next	;

1.79.2.1
date	2005.12.22.02.41.54;	author brad;	state Exp;
branches;
next	;

1.111.2.1
date	2010.01.29.21.33.30;	author sthen;	state Exp;
branches;
next	;

1.119.4.1
date	2010.01.29.21.33.13;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.240
log
@Remove old deactivated pledge path code.  A replacement mechanism is
being brewed.
ok beck
@
text
@/*	$OpenBSD: proc.h,v 1.239 2017/04/28 13:50:55 mpi Exp $	*/
/*	$NetBSD: proc.h,v 1.44 1996/04/22 01:23:21 christos Exp $	*/

/*-
 * Copyright (c) 1986, 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)proc.h	8.8 (Berkeley) 1/21/94
 */

#ifndef _SYS_PROC_H_
#define	_SYS_PROC_H_

#include <machine/proc.h>		/* Machine-dependent proc substruct. */
#include <sys/selinfo.h>		/* For struct selinfo */
#include <sys/syslimits.h>		/* For LOGIN_NAME_MAX */
#include <sys/queue.h>
#include <sys/timeout.h>		/* For struct timeout */
#include <sys/event.h>			/* For struct klist */
#include <sys/mutex.h>			/* For struct mutex */
#include <sys/resource.h>		/* For struct rusage */

#ifdef _KERNEL
#include <sys/atomic.h>
#define __need_process
#endif

/*
 * One structure allocated per session.
 */
struct process;
struct	session {
	int	s_count;		/* Ref cnt; pgrps in session. */
	struct	process *s_leader;	/* Session leader. */
	struct	vnode *s_ttyvp;		/* Vnode of controlling terminal. */
	struct	tty *s_ttyp;		/* Controlling terminal. */
	char	s_login[LOGIN_NAME_MAX];	/* Setlogin() name. */
	pid_t	s_verauthppid;
	uid_t	s_verauthuid;
	struct timeout s_verauthto;
};

void zapverauth(/* struct session */ void *);

/*
 * One structure allocated per process group.
 */
struct	pgrp {
	LIST_ENTRY(pgrp) pg_hash;	/* Hash chain. */
	LIST_HEAD(, process) pg_members;/* Pointer to pgrp members. */
	struct	session *pg_session;	/* Pointer to session. */
	pid_t	pg_id;			/* Pgrp id. */
	int	pg_jobc;	/* # procs qualifying pgrp for job control */
};

/*
 * One structure allocated per emulation.
 */
struct exec_package;
struct proc;
struct ps_strings;
struct uvm_object;
union sigval;

struct	emul {
	char	e_name[8];		/* Symbolic name */
	int	*e_errno;		/* Errno array */
					/* Signal sending function */
	void	(*e_sendsig)(void (*)(int), int, int, u_long, int, union sigval);
	int	e_nosys;		/* Offset of the nosys() syscall */
	int	e_nsysent;		/* Number of system call entries */
	struct sysent *e_sysent;	/* System call array */
	char	**e_syscallnames;	/* System call name array */
	int	e_arglen;		/* Extra argument size in words */
					/* Copy arguments on the stack */
	void	*(*e_copyargs)(struct exec_package *, struct ps_strings *,
				    void *, void *);
					/* Set registers before execution */
	void	(*e_setregs)(struct proc *, struct exec_package *,
				  u_long, register_t *);
	int	(*e_fixup)(struct proc *, struct exec_package *);
	int	(*e_coredump)(struct proc *, void *cookie);
	char	*e_sigcode;		/* Start of sigcode */
	char	*e_esigcode;		/* End of sigcode */
	char	*e_esigret;		/* sigaction RET position */
	int	e_flags;		/* Flags, see below */
	struct uvm_object *e_sigobject;	/* shared sigcode object */
};
/* Flags for e_flags */
#define	EMUL_ENABLED	0x0001		/* Allow exec to continue */
#define	EMUL_NATIVE	0x0002		/* Always enabled */

/*
 * time usage: accumulated times in ticks
 * Once a second, each thread's immediate counts (p_[usi]ticks) are
 * accumulated into these.
 */
struct tusage {
	struct	timespec tu_runtime;	/* Realtime. */
	uint64_t	tu_uticks;	/* Statclock hits in user mode. */
	uint64_t	tu_sticks;	/* Statclock hits in system mode. */
	uint64_t	tu_iticks;	/* Statclock hits processing intr. */
};

/*
 * Description of a process.
 *
 * These structures contain the information needed to manage a thread of
 * control, known in UN*X as a process; it has references to substructures
 * containing descriptions of things that the process uses, but may share
 * with related processes.
 *
 * struct process is the higher level process containing information
 * shared by all threads in a process, while struct proc contains the
 * run-time information needed by threads.
 */
#ifdef __need_process
struct process {
	/*
	 * ps_mainproc is the original thread in the process.
	 * It's only still special for the handling of p_xstat and
	 * some signal and ptrace behaviors that need to be fixed.
	 */
	struct	proc *ps_mainproc;
	struct	ucred *ps_ucred;	/* Process owner's identity. */

	LIST_ENTRY(process) ps_list;	/* List of all processes. */
	TAILQ_HEAD(,proc) ps_threads;	/* Threads in this process. */

	LIST_ENTRY(process) ps_pglist;	/* List of processes in pgrp. */
	struct	process *ps_pptr; 	/* Pointer to parent process. */
	LIST_ENTRY(process) ps_sibling;	/* List of sibling processes. */
	LIST_HEAD(, process) ps_children;/* Pointer to list of children. */
	LIST_ENTRY(process) ps_hash;    /* Hash chain. */

	struct	sigacts *ps_sigacts;	/* Signal actions, state */
	struct	vnode *ps_textvp;	/* Vnode of executable. */
	struct	filedesc *ps_fd;	/* Ptr to open files structure */
	struct	vmspace *ps_vmspace;	/* Address space */
	pid_t	ps_pid;			/* Process identifier. */

/* The following fields are all zeroed upon creation in process_new. */
#define	ps_startzero	ps_klist
	struct	klist ps_klist;		/* knotes attached to this process */
	int	ps_flags;		/* PS_* flags. */

	struct	proc *ps_single;	/* Single threading to this thread. */
	int	ps_singlecount;		/* Not yet suspended threads. */

	int	ps_traceflag;		/* Kernel trace points. */
	struct	vnode *ps_tracevp;	/* Trace to vnode. */
	struct	ucred *ps_tracecred;	/* Creds for writing trace */

	pid_t	ps_oppid;	 	/* Save parent pid during ptrace. */
	int	ps_ptmask;		/* Ptrace event mask */
	struct	ptrace_state *ps_ptstat;/* Ptrace state */

	struct	rusage *ps_ru;		/* sum of stats for dead threads. */
	struct	tusage ps_tu;		/* accumulated times. */
	struct	rusage ps_cru;		/* sum of stats for reaped children */
	struct	itimerval ps_timer[3];	/* timers, indexed by ITIMER_* */

	u_int64_t ps_wxcounter;

/* End area that is zeroed on creation. */
#define	ps_endzero	ps_startcopy

/* The following fields are all copied upon creation in process_new. */
#define	ps_startcopy	ps_limit
	struct	plimit *ps_limit;	/* Process limits. */
	struct	pgrp *ps_pgrp;		/* Pointer to process group. */
	struct	emul *ps_emul;		/* Emulation information */

	char	ps_comm[MAXCOMLEN+1];

	vaddr_t	ps_strings;		/* User pointers to argv/env */
	vaddr_t	ps_stackgap;		/* User pointer to the "stackgap" */
	vaddr_t	ps_sigcode;		/* User pointer to the signal code */
	vaddr_t ps_sigcoderet;		/* User pointer to sigreturn retPC */
	u_long	ps_sigcookie;
	u_int	ps_rtableid;		/* Process routing table/domain. */
	char	ps_nice;		/* Process "nice" value. */

	struct uprof {			/* profile arguments */
		caddr_t	pr_base;	/* buffer base */
		size_t  pr_size;	/* buffer size */
		u_long	pr_off;		/* pc offset */
		u_int   pr_scale;	/* pc scaling */
	} ps_prof;

	u_short	ps_acflag;		/* Accounting flags. */

	uint64_t ps_pledge;

	int64_t ps_kbind_cookie;
	u_long  ps_kbind_addr;

/* End area that is copied on creation. */
#define ps_endcopy	ps_refcnt
	int	ps_refcnt;		/* Number of references. */

	struct	timespec ps_start;	/* starting time. */
	struct	timeout ps_realit_to;	/* real-time itimer trampoline. */
};

#define	ps_session	ps_pgrp->pg_session
#define	ps_pgid		ps_pgrp->pg_id

#endif /* __need_process */

/*
 * These flags are kept in ps_flags.
 */
#define	PS_CONTROLT	0x00000001	/* Has a controlling terminal. */
#define	PS_EXEC		0x00000002	/* Process called exec. */
#define	PS_INEXEC	0x00000004	/* Process is doing an exec right now */
#define	PS_EXITING	0x00000008	/* Process is exiting. */
#define	PS_SUGID	0x00000010	/* Had set id privs since last exec. */
#define	PS_SUGIDEXEC	0x00000020	/* last execve() was set[ug]id */
#define	PS_PPWAIT	0x00000040	/* Parent waits for exec/exit. */
#define	PS_ISPWAIT	0x00000080	/* Is parent of PPWAIT child. */
#define	PS_PROFIL	0x00000100	/* Has started profiling. */
#define	PS_TRACED	0x00000200	/* Being ptraced. */
#define	PS_WAITED	0x00000400	/* Stopped proc was waited for. */
#define	PS_COREDUMP	0x00000800	/* Busy coredumping */
#define	PS_SINGLEEXIT	0x00001000	/* Other threads must die. */
#define	PS_SINGLEUNWIND	0x00002000	/* Other threads must unwind. */
#define	PS_NOZOMBIE	0x00004000	/* No signal or zombie at exit. */
#define	PS_STOPPED	0x00008000	/* Just stopped, need sig to parent. */
#define	PS_SYSTEM	0x00010000	/* No sigs, stats or swapping. */
#define	PS_EMBRYO	0x00020000	/* New process, not yet fledged */
#define	PS_ZOMBIE	0x00040000	/* Dead and ready to be waited for */
#define	PS_NOBROADCASTKILL 0x00080000	/* Process excluded from kill -1. */
#define	PS_PLEDGE	0x00100000	/* Has called pledge(2) */
#define	PS_WXNEEDED	0x00200000	/* Process may violate W^X */

#define	PS_BITS \
    ("\20" "\01CONTROLT" "\02EXEC" "\03INEXEC" "\04EXITING" "\05SUGID" \
     "\06SUGIDEXEC" "\07PPWAIT" "\010ISPWAIT" "\011PROFIL" "\012TRACED" \
     "\013WAITED" "\014COREDUMP" "\015SINGLEEXIT" "\016SINGLEUNWIND" \
     "\017NOZOMBIE" "\020STOPPED" "\021SYSTEM" "\022EMBRYO" "\023ZOMBIE" \
     "\024NOBROADCASTKILL" "\025PLEDGE" "\026WXNEEDED")


struct lock_list_entry;

struct proc {
	TAILQ_ENTRY(proc) p_runq;
	LIST_ENTRY(proc) p_list;	/* List of all threads. */

	struct	process *p_p;		/* The process of this thread. */
	TAILQ_ENTRY(proc) p_thr_link;	/* Threads in a process linkage. */

	TAILQ_ENTRY(proc) p_fut_link;	/* Threads in a futex linkage. */
	struct	futex	*p_futex;	/* Current sleeping futex. */

	/* substructures: */
	struct	filedesc *p_fd;		/* copy of p_p->ps_fd */
	struct	vmspace *p_vmspace;	/* copy of p_p->ps_vmspace */
#define	p_rlimit	p_p->ps_limit->pl_rlimit

	int	p_flag;			/* P_* flags. */
	u_char	p_spare;		/* unused */
	char	p_stat;			/* S* process status. */
	char	p_pad1[1];
	u_char	p_descfd;		/* if not 255, fdesc permits this fd */

	pid_t	p_tid;			/* Thread identifier. */
	LIST_ENTRY(proc) p_hash;	/* Hash chain. */

/* The following fields are all zeroed upon creation in fork. */
#define	p_startzero	p_dupfd
	int	p_dupfd;	 /* Sideways return value from filedescopen. XXX */

	long 	p_thrslpid;	/* for thrsleep syscall */

	/* scheduling */
	u_int	p_estcpu;	 /* Time averaged value of p_cpticks. */
	int	p_cpticks;	 /* Ticks of cpu time. */
	const volatile void *p_wchan;/* Sleep address. */
	struct	timeout p_sleep_to;/* timeout for tsleep() */
	const char *p_wmesg;	 /* Reason for sleep. */
	fixpt_t	p_pctcpu;	 /* %cpu for this thread */
	u_int	p_slptime;	 /* Time since last blocked. */
	u_int	p_uticks;		/* Statclock hits in user mode. */
	u_int	p_sticks;		/* Statclock hits in system mode. */
	u_int	p_iticks;		/* Statclock hits processing intr. */
	struct	cpu_info * volatile p_cpu; /* CPU we're running on. */

	struct	rusage p_ru;		/* Statistics */
	struct	tusage p_tu;		/* accumulated times. */
	struct	timespec p_rtime;	/* Real time. */

	int	 p_siglist;		/* Signals arrived but not delivered. */

/* End area that is zeroed on creation. */
#define	p_endzero	p_startcopy

/* The following fields are all copied upon creation in fork. */
#define	p_startcopy	p_sigmask
	sigset_t p_sigmask;	/* Current signal mask. */

	u_char	p_priority;	/* Process priority. */
	u_char	p_usrpri;	/* User-priority based on p_estcpu and ps_nice. */
	int	p_pledge_syscall;	/* Cache of current syscall */

	struct	ucred *p_ucred;		/* cached credentials */
	struct	sigaltstack p_sigstk;	/* sp & on stack state variable */

	u_long	p_prof_addr;	/* tmp storage for profiling addr until AST */
	u_long	p_prof_ticks;	/* tmp storage for profiling ticks until AST */

/* End area that is copied on creation. */
#define	p_endcopy	p_addr
	struct	user *p_addr;	/* Kernel virtual addr of u-area */
	struct	mdproc p_md;	/* Any machine-dependent fields. */

	sigset_t p_oldmask;	/* Saved mask from before sigpause */
	int	p_sisig;	/* For core dump/debugger XXX */
	union sigval p_sigval;	/* For core dump/debugger XXX */
	long	p_sitrapno;	/* For core dump/debugger XXX */
	int	p_sicode;	/* For core dump/debugger XXX */

	u_short	p_xstat;	/* Exit status for wait; also stop signal. */

	struct	lock_list_entry *p_sleeplocks;
};

/* Status values. */
#define	SIDL	1		/* Thread being created by fork. */
#define	SRUN	2		/* Currently runnable. */
#define	SSLEEP	3		/* Sleeping on an address. */
#define	SSTOP	4		/* Debugging or suspension. */
#define	SZOMB	5		/* unused */
#define	SDEAD	6		/* Thread is almost gone */
#define	SONPROC	7		/* Thread is currently on a CPU. */

#define	P_ZOMBIE(p)	((p)->p_stat == SDEAD)
#define	P_HASSIBLING(p)	(TAILQ_FIRST(&(p)->p_p->ps_threads) != (p) || \
			 TAILQ_NEXT((p), p_thr_link) != NULL)

/*
 * These flags are per-thread and kept in p_flag
 */
#define	P_INKTR		0x00000001	/* In a ktrace op, don't recurse */
#define	P_PROFPEND	0x00000002	/* SIGPROF needs to be posted */
#define	P_ALRMPEND	0x00000004	/* SIGVTALRM needs to be posted */
#define	P_SIGSUSPEND	0x00000008	/* Need to restore before-suspend mask*/
#define	P_CANTSLEEP	0x00000010	/* insomniac thread */
#define	P_SELECT	0x00000040	/* Selecting; wakeup/waiting danger. */
#define	P_SINTR		0x00000080	/* Sleep is interruptible. */
#define	P_SYSTEM	0x00000200	/* No sigs, stats or swapping. */
#define	P_TIMEOUT	0x00000400	/* Timing out during sleep. */
#define	P_WEXIT		0x00002000	/* Working on exiting. */
#define	P_OWEUPC	0x00008000	/* Owe proc an addupc() at next ast. */
#define	P_SUSPSINGLE	0x00080000	/* Need to stop for single threading. */
#define P_CONTINUED	0x00800000	/* Proc has continued from a stopped state. */
#define	P_THREAD	0x04000000	/* Only a thread, not a real process */
#define	P_SUSPSIG	0x08000000	/* Stopped from signal. */
#define	P_SOFTDEP	0x10000000	/* Stuck processing softdep worklist */
#define P_CPUPEG	0x40000000	/* Do not move to another cpu. */

#define	P_BITS \
    ("\20" "\01INKTR" "\02PROFPEND" "\03ALRMPEND" "\04SIGSUSPEND" \
     "\05CANTSLEEP" "\07SELECT" "\010SINTR" "\012SYSTEM" "\013TIMEOUT" \
     "\016WEXIT" "\020OWEUPC" "\024SUSPSINGLE" "\027XX" \
     "\030CONTINUED" "\033THREAD" "\034SUSPSIG" "\035SOFTDEP" "\037CPUPEG")

#define	THREAD_PID_OFFSET	100000

#ifdef _KERNEL

struct uidinfo {
	LIST_ENTRY(uidinfo) ui_hash;
	uid_t   ui_uid;
	long    ui_proccnt;	/* proc structs */
	long	ui_lockcnt;	/* lockf structs */
};

struct uidinfo *uid_find(uid_t);

/*
 * We use process IDs <= PID_MAX; PID_MAX + 1 must also fit in a pid_t,
 * as it is used to represent "no process group".
 * We set PID_MAX to 99999 to keep it in 5 columns in ps
 * When exposed to userspace, thread IDs have THREAD_PID_OFFSET
 * added to keep them from overlapping the PID range.  For them,
 * we use a * a (0 .. 2^n] range for cheapness, picking 'n' such
 * that 2^n + THREAD_PID_OFFSET and THREAD_PID_OFFSET have
 * the same number of columns when printed.
 */
#define	PID_MAX			99999
#define	TID_MASK		0x7ffff

#define	NO_PID		(PID_MAX+1)

#define SESS_LEADER(pr)	((pr)->ps_session->s_leader == (pr))
#define	SESSHOLD(s)	((s)->s_count++)
#define	SESSRELE(s) do {						\
	if (--(s)->s_count == 0) {					\
		timeout_del(&(s)->s_verauthto);			\
		pool_put(&session_pool, (s));				\
	}								\
} while (/* CONSTCOND */ 0)

/*
 * Flags to fork1().
 */
#define FORK_FORK	0x00000001
#define FORK_VFORK	0x00000002
#define FORK_IDLE	0x00000004
#define FORK_PPWAIT	0x00000008
#define FORK_SHAREFILES	0x00000010
#define FORK_SYSTEM	0x00000020
#define FORK_NOZOMBIE	0x00000040
#define FORK_SHAREVM	0x00000080
#define FORK_SIGHAND	0x00000200
#define FORK_PTRACE	0x00000400

#define EXIT_NORMAL		0x00000001
#define EXIT_THREAD		0x00000002
#define EXIT_THREAD_NOCHECK	0x00000003

#define	TIDHASH(tid)	(&tidhashtbl[(tid) & tidhash])
extern LIST_HEAD(tidhashhead, proc) *tidhashtbl;
extern u_long tidhash;

#define	PIDHASH(pid)	(&pidhashtbl[(pid) & pidhash])
extern LIST_HEAD(pidhashhead, process) *pidhashtbl;
extern u_long pidhash;

#define	PGRPHASH(pgid)	(&pgrphashtbl[(pgid) & pgrphash])
extern LIST_HEAD(pgrphashhead, pgrp) *pgrphashtbl;
extern u_long pgrphash;

extern struct proc proc0;		/* Process slot for swapper. */
extern struct process process0;		/* Process slot for kernel threads. */
extern int nprocesses, maxprocess;	/* Cur and max number of processes. */
extern int nthreads, maxthread;		/* Cur and max number of threads. */
extern int randompid;			/* fork() should create random pid's */

LIST_HEAD(proclist, proc);
LIST_HEAD(processlist, process);
extern struct processlist allprocess;	/* List of all processes. */
extern struct processlist zombprocess;	/* List of zombie processes. */
extern struct proclist allproc;		/* List of all threads. */

extern struct process *initprocess;	/* Process slot for init. */
extern struct proc *reaperproc;		/* Thread slot for reaper. */
extern struct proc *syncerproc;		/* filesystem syncer daemon */

extern struct pool process_pool;	/* memory pool for processes */
extern struct pool proc_pool;		/* memory pool for procs */
extern struct pool rusage_pool;		/* memory pool for zombies */
extern struct pool ucred_pool;		/* memory pool for ucreds */
extern struct pool session_pool;	/* memory pool for sessions */
extern struct pool pgrp_pool;		/* memory pool for pgrps */

void	freepid(pid_t);

struct process *prfind(pid_t);	/* Find process by id. */
struct process *zombiefind(pid_t); /* Find zombie process by id. */
struct proc *tfind(pid_t);	/* Find thread by id. */
struct pgrp *pgfind(pid_t);	/* Find process group by id. */
void	proc_printit(struct proc *p, const char *modif,
    int (*pr)(const char *, ...));

int	chgproccnt(uid_t uid, int diff);
int	enterpgrp(struct process *, pid_t, struct pgrp *, struct session *);
void	fixjobc(struct process *, struct pgrp *, int);
int	inferior(struct process *, struct process *);
void	leavepgrp(struct process *);
void	preempt(void);
void	pgdelete(struct pgrp *);
void	procinit(void);
void	resetpriority(struct proc *);
void	setrunnable(struct proc *);
void	endtsleep(void *);
void	unsleep(struct proc *);
void	reaper(void);
void	exit1(struct proc *, int, int);
void	exit2(struct proc *);
int	dowait4(struct proc *, pid_t, int *, int, struct rusage *,
	    register_t *);
void	cpu_fork(struct proc *_curp, struct proc *_child, void *_stack,
	    void *_tcb, void (*_func)(void *), void *_arg);
void	cpu_exit(struct proc *);
void	process_initialize(struct process *, struct proc *);
int	fork1(struct proc *_curp, int _flags, void (*_func)(void *),
	    void *_arg, register_t *_retval, struct proc **_newprocp);
int	thread_fork(struct proc *_curp, void *_stack, void *_tcb,
	    pid_t *_tidptr, register_t *_retval);
int	groupmember(gid_t, struct ucred *);
void	dorefreshcreds(struct process *, struct proc *);
void	dosigsuspend(struct proc *, sigset_t);

static inline void
refreshcreds(struct proc *p)
{
	struct process *pr = p->p_p;

	/* this is an unlocked access to ps_ucred, but the result is benign */
	if (pr->ps_ucred != p->p_ucred)
		dorefreshcreds(pr, p);
}

enum single_thread_mode {
	SINGLE_SUSPEND,		/* other threads to stop wherever they are */
	SINGLE_PTRACE,		/* other threads to stop but don't wait */
	SINGLE_UNWIND,		/* other threads to unwind and stop */
	SINGLE_EXIT		/* other threads to unwind and then exit */
};
int	single_thread_set(struct proc *, enum single_thread_mode, int);
void	single_thread_wait(struct process *);
void	single_thread_clear(struct proc *, int);
int	single_thread_check(struct proc *, int);

void	child_return(void *);

int	proc_cansugid(struct proc *);

struct sleep_state {
	int sls_s;
	int sls_catch;
	int sls_do_sleep;
	int sls_sig;
};

#if defined(MULTIPROCESSOR)
void	proc_trampoline_mp(void);	/* XXX */
#endif

/*
 * functions to handle sets of cpus.
 *
 * For now we keep the cpus in ints so that we can use the generic
 * atomic ops.
 */
#define CPUSET_ASIZE(x) (((x) - 1)/32 + 1)
#define CPUSET_SSIZE CPUSET_ASIZE(MAXCPUS)
struct cpuset {
	int cs_set[CPUSET_SSIZE];
};

void cpuset_init_cpu(struct cpu_info *);

void cpuset_clear(struct cpuset *);
void cpuset_add(struct cpuset *, struct cpu_info *);
void cpuset_del(struct cpuset *, struct cpu_info *);
int cpuset_isset(struct cpuset *, struct cpu_info *);
void cpuset_add_all(struct cpuset *);
void cpuset_copy(struct cpuset *, struct cpuset *);
void cpuset_union(struct cpuset *, struct cpuset *, struct cpuset *);
void cpuset_intersection(struct cpuset *t, struct cpuset *, struct cpuset *);
void cpuset_complement(struct cpuset *, struct cpuset *, struct cpuset *);
struct cpu_info *cpuset_first(struct cpuset *);

#endif	/* _KERNEL */
#endif	/* !_SYS_PROC_H_ */

@


1.239
log
@Add futex(2) syscall based on a sane subset of its Linux equivalent.

The syscall is marked NOLOCK and only FUTEX_WAIT grabs the KERNEL_LOCK()
because of PCATCH and the signal nightmare.

Serialization of threads is currently done with a global & exclusive
rwlock.

Note that the current implementation still use copyin(9) which is not
guaranteed to be atomic.  Committing now such that remaining issues can
be addressed in-tree.

With inputs from guenther@@, kettenis@@ and visa@@.

ok deraadt@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.238 2017/04/20 12:59:36 visa Exp $	*/
a91 1
struct whitepaths;
a222 1
	struct whitepaths *ps_pledgepaths;
@


1.238
log
@Add a port of witness(4) lock validation tool from FreeBSD.

Go-ahead from kettenis@@, guenther@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.237 2017/04/13 03:52:25 guenther Exp $	*/
d283 4
a286 1
	TAILQ_ENTRY(proc) p_thr_link;/* Threads in a process linkage. */
@


1.237
log
@Provide mips64 with kernel-facing TCB_{GET,SET} macros that store it
in struct mdproc.  With that, all archs have those and the __HAVE_MD_TCB
macro can be unifdef'ed as always defined.

ok kettenis@@ visa@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.236 2017/03/05 06:40:18 guenther Exp $	*/
d276 2
d353 2
@


1.236
log
@We've fixed PID handling, so update the comment describing ps_mainproc
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.235 2017/02/14 10:31:15 mpi Exp $	*/
a331 6

#ifndef	__HAVE_MD_TCB
	void	*p_tcb;		/* user-space thread-control-block address */
# define TCB_SET(p, addr)	((p)->p_tcb = (addr))
# define TCB_GET(p)		((p)->p_tcb)
#endif
@


1.235
log
@Convert most of the manual checks for CPU hogging to sched_pause().

The distinction between preempt() and yield() stays as it is usueful
to know if a thread decided to yield by itself or if the kernel told
him to go away.

ok tedu@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.234 2017/02/12 04:55:08 guenther Exp $	*/
d150 3
a152 6
	 * ps_mainproc is the main thread in the process.
	 * Ultimately, we shouldn't need that, threads should be able to exit
	 * at will. Unfortunately until the pid is moved into struct process
	 * we'll have to remember the main threads and abuse its pid as the
	 * the pid of the process. This is gross, but considering the horrible
	 * pid semantics we have right now, it's unavoidable.
@


1.234
log
@Split up fork1():
 - FORK_THREAD handling is a totally separate function, thread_fork(),
   that is only used by sys___tfork() and which loses the flags, func,
   arg, and newprocp parameters and gains tcb parameter to guarantee
   the new thread's TCB is set before the creating thread returns
 - fork1() loses its stack and tidptr parameters
Common bits factor out:
 - struct proc allocation and initialization moves to thread_new()
 - maxthread handling moves to fork_check_maxthread()
 - setting the new thread running moves to fork_thread_start()
The MD cpu_fork() function swaps its unused stacksize parameter for
a tcb parameter.

luna88k testing by aoyama@@, alpha testing by dlg@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.233 2017/02/08 20:58:30 guenther Exp $	*/
d506 1
a506 1
void	preempt(struct proc *);
@


1.233
log
@Delete the obsolete fork/exec/exit emulation hooks.

ok mpi@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.232 2017/01/31 07:44:55 visa Exp $	*/
a449 1
#define FORK_TFORK	0x00000100
a451 1
#define FORK_THREAD	0x00000800
d518 2
d522 4
a525 2
int	fork1(struct proc *, int, void *, pid_t *, void (*)(void *),
	    void *, register_t *, struct proc **);
@


1.232
log
@Protect <sys/atomic.h> with #ifdef _KERNEL. This unbreaks userland
build on m88k, where the compiler has no notion of atomic built-ins.

Suggested by miod@@
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.231 2017/01/24 02:28:17 visa Exp $	*/
a117 4
					/* Per-process hooks */
	void	(*e_proc_exec)(struct proc *, struct exec_package *);
	void	(*e_proc_fork)(struct proc *p, struct proc *parent);
	void	(*e_proc_exit)(struct proc *);
a322 2
	void	*p_emuldata;		/* Per-process emulation data, or */
					/* NULL. Malloc type M_EMULDATA */
@


1.231
log
@Use header <sys/atomic.h> rather than <machine/atomic.h> in MI code.

OK mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.230 2017/01/24 00:58:55 mpi Exp $	*/
a43 1
#include <sys/atomic.h>
d53 1
@


1.230
log
@Rename pfind(9) into tfind(9) to reflect that it deals with threads.

While here document prfind(9.

with and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.229 2017/01/21 05:42:03 guenther Exp $	*/
d44 1
a51 1
#include <machine/atomic.h>
@


1.229
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.228 2016/11/07 02:50:33 guenther Exp $	*/
d504 1
a504 1
struct proc *pfind(pid_t);	/* Find thread by id. */
@


1.228
log
@Fix typo in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.227 2016/11/07 00:26:32 guenther Exp $	*/
d210 3
a339 2
	char	p_comm[MAXCOMLEN+1];

@


1.227
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.226 2016/09/03 08:47:24 tedu Exp $	*/
d129 1
a129 1
 * One a second, each thread's immediate counts (p_[usi]ticks) are
@


1.226
log
@add wxneeded to the proc flags print list
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.225 2016/09/02 18:11:28 tedu Exp $	*/
d171 1
d177 1
a240 1
#define	ps_pid		ps_mainproc->p_pid
d298 1
a298 1
	pid_t	p_pid;			/* Process identifier. */
d407 1
a407 1
#define	THREAD_PID_OFFSET	1000000
d424 5
d430 3
a432 1
#define	PID_MAX		99999
d464 4
d469 1
a469 1
extern LIST_HEAD(pidhashhead, proc) *pidhashtbl;
a498 2
int	ispidtaken(pid_t);
pid_t	allocpid(void);
@


1.225
log
@add a concept of 'verified auth' to sessions. When set via ioctl,
the user and parent process are recorded. Later, this info may be tested
and used to bypass authorization requirements.
ie, doas won't ask for your password again.
Great idea from henning.
ok deraadt guenther henning
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.224 2016/06/27 19:55:02 jca Exp $	*/
d276 1
a276 1
     "\024NOBROADCASTKILL" "\025PLEDGE")
@


1.224
log
@Repair kill(2) on zombie processes.

kill(2) is supposed to find zombie processes, this probably got broken
when the process reaper was introduced.  As a temporary(tm) workaround,
walk the list of zombie processes if we can't find the target pid in the
main process list.

Problem with zsh initially reported by Geoff Wozniak on misc@@, analysis
done by naddy@@.  ok kettenis@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.223 2016/05/30 21:31:27 deraadt Exp $	*/
d67 3
d72 2
d430 2
a431 1
	if (--(s)->s_count == 0)					\
d433 1
@


1.223
log
@Identify W^X labelled binaries at execve() time based upon WX_OPENBSD_WXNEEDED
flag set by ld -zwxneeded.  Such binaries are allowed to run only on wxallowed
mountpoints.  They do not report mmap/mprotect problems.

Rate limit mmap/mprotect reports from other binaries.

These semantics are chosen to encourage progress in the ports ecosystem,
without overwhelming the developers who work in the area.
ok sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.221 2016/05/30 21:22:45 deraadt Exp $	*/
d485 1
@


1.222
log
@backout to insert correct commit message
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.220 2016/05/10 18:39:53 deraadt Exp $	*/
d193 2
d264 1
@


1.221
log
@*** empty log message ***
@
text
@a192 2
	u_int64_t ps_wxcounter;

a261 1
#define	PS_WXNEEDED	0x00200000	/* Process may violate W^X */
@


1.220
log
@SROP mitigation.  sendsig() stores a (per-process ^ &sigcontext) cookie
inside the sigcontext.  sigreturn(2) checks syscall entry was from the
exact PC addr in the (per-process ASLR) sigtramp, verifies the cookie,
and clears it to prevent sigcontext reuse.
not yet tested on landisk, sparc, *88k, socppc.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.219 2016/04/25 20:18:31 tedu Exp $	*/
d193 2
d264 1
@


1.219
log
@remove systrace remnants
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.218 2016/03/29 08:46:08 mpi Exp $	*/
d110 1
d204 2
@


1.218
log
@Use a macro to check if a thread has a sibling.

Note that without locking a thread cannot claim that it is part
of a multi-threaded process using this macro.

Suggested by miod@@, ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.217 2016/03/09 13:38:50 mpi Exp $	*/
a311 2
	void	*p_systrace;		/* Back pointer to systrace */

a382 1
#define P_SYSTRACE	0x00400000	/* Process system call tracing active*/
d392 1
a392 1
     "\016WEXIT" "\020OWEUPC" "\024SUSPSINGLE" "\027SYSTRACE" \
@


1.217
log
@Correct some comments and definitions, from Michal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.216 2016/03/06 05:20:26 guenther Exp $	*/
d367 2
@


1.216
log
@Localize some declarations to kern_exit.c: the last good reason to put
them in sys/proc.h has been removed with compat_linux

diff from Michal Mazurek (akfaew (at) jasminek.net)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.215 2016/03/06 05:17:23 guenther Exp $	*/
d326 1
a326 1
	u_char	p_usrpri;	/* User-priority based on p_cpu and ps_nice. */
@


1.215
log
@Increase PID_MAX to 99999: the compats that constrained it to SHRT_MAX-1 are
long gone.

reminded by comment suggestion from Michal Mazurek (akfaew (at) jasminek.net)
ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.214 2016/03/04 14:08:55 deraadt Exp $	*/
a533 3
void	proc_finish_wait(struct proc *, struct proc *);
void	process_zap(struct process *);
void	proc_free(struct proc *);
@


1.214
log
@fix a typo; from Michal Mazurek
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.213 2015/12/06 17:50:21 deraadt Exp $	*/
d412 1
a412 1
 * We set PID_MAX to (SHRT_MAX - 1) so we don't break sys/compat.
d414 1
a414 1
#define	PID_MAX		32766
@


1.213
log
@Change kernel internal pledge variables to 64bit (to prepare for more
extensions).  This change is exposed in ktrace.out files
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.212 2015/11/03 16:14:14 deraadt Exp $	*/
d248 1
a248 1
#define	PS_WAITED	0x00000400	/* Stopped proc has waited for. */
d258 1
a258 1
#define PS_PLEDGE	0x00100000	/* Has called pledge(2) */
@


1.212
log
@pledge_aftersyscall has been reduced to one case, "getpw", to open a
window for chatting to ypserv.  This can be done in pledge_namei, so
improve system call performance by removing the pledge_aftersyscall hook.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.211 2015/11/02 16:31:55 semarie Exp $	*/
d215 1
a215 1
	u_int	ps_pledge;
@


1.211
log
@move the pledgenote annotation from `struct proc' to `struct nameidata'

pledgenote is used for annotate the policy for a namei context. So make it
tracking the nameidata.

It is expected for the caller to explicitly define the policy. It is a kernel
bug to not do so.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.210 2015/10/25 20:39:54 deraadt Exp $	*/
a329 1
	int	p_pledgeafter;	/* Observance during syscall */
@


1.210
log
@Fold "malloc" into "stdio" and -- recognizing that no program so far has
used less than "stdio" -- include all the "self" operations.  Instead of
different defines, use regular PLEDGE_* in the "p_pledgenote" variable
(which indicates the operation subtype a system call is performing).  Many
checks before easier to understand.  p_pledgenote can often be passed
directly to ktrace, so that kdump says:
 15565 test     CALL  pledge(0xa9a3f804c51,0)
 15565 test     STRU  pledge request="stdio"
 15565 test     RET   pledge 0
 15565 test     CALL  open(0xa9a3f804c57,0x2<O_RDWR>)
 15565 test     NAMI  "/tmp/testfile"
 15565 test     PLDG  open, "wpath", errno 1 Operation not permitted
with help from semarie, ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.209 2015/10/20 06:40:01 semarie Exp $	*/
d330 1
a330 2
	int	p_pledgenote;	/* Observance during syscall */
	int	p_pledgeafter;
@


1.209
log
@clear whitelisted-paths view in pledge.

the following diff adds a clear view of whitelisted-paths in pledge.

before, whitelisting "/usr/local/bin" path would make only "/usr/local/bin"
VNODE was present and let "/usr/local", "/usr", and "/" been ENOENT. It was a
somehow odd filesystem hierarchy, and it breaks realpath(3).

with this diff, the directories that are one of the parents of a
whitelisted-directory become visible to stat(2) related syscalls, but only
with restricted permissions: stat(2) will lie a bit, and saying they owned by
root:wheel and mode is --x--x--x. Note that only stat(2) is affected by this
"view", and the owner/mode aren't effectively changed: it is just a "lie".

while here, refactor a bit pledge_namei() in order to avoid multiple for-loop
on whitelisted-path array.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.208 2015/10/18 00:04:43 deraadt Exp $	*/
a330 7
#define TMN_RPATH	0x00000001
#define TMN_WPATH	0x00000002
#define TMN_CPATH	0x00000004
#define TMN_XPATH	0x00000008
#define TMN_FATTR	0x00000010
#define TMN_COREDUMP	0x00000020
#define TMN_STATLIE	0x00000040
a331 1
#define TMA_YPLOCK	0x00000001
@


1.208
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.207 2015/10/10 14:46:15 deraadt Exp $	*/
d337 1
@


1.207
log
@I forgot execve would go through the namei codepath, so a program marked
"stdio rpath" this would fail to execve.  pre-indicate exec actions to the
namei checker to allow them through.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.206 2015/10/09 01:10:27 deraadt Exp $	*/
a338 1
#define TMA_DNSRESOLV	0x00000002
@


1.206
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.206 2015/10/08 19:34:50 deraadt Exp $	*/
d334 3
a336 2
#define TMN_FATTR	0x00000008
#define TMN_COREDUMP	0x00000010
@


1.205
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.204 2015/08/22 20:18:50 deraadt Exp $	*/
d215 2
a216 2
	u_int	ps_tame;
	struct whitepaths *ps_tamepaths;
d258 1
a258 1
#define PS_TAMED	0x00100000	/* Has called tame(2) */
d265 1
a265 1
     "\024NOBROADCASTKILL" "\025TAMED")
d329 2
a330 2
	int	p_tame_syscall;	/* Cache of current syscall */
	int	p_tamenote;	/* Observance during syscall */
d336 1
a336 1
	int	p_tameafter;
@


1.204
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.203 2015/07/27 18:22:37 deraadt Exp $	*/
a49 1
#include <sys/tame.h>
d87 1
@


1.203
log
@Rather than disabling tame to coredump, leave it enabled but flag that
a coredump is happening.  This improves behaviour while threaded.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.202 2015/07/20 00:56:10 guenther Exp $	*/
d50 1
d216 1
d331 5
a335 6
#define TMN_CREAT	0x00000001
#define TMN_WRITE	0x00000002
#define TMN_IMODIFY	0x00000004
#define TMN_YPLOCK	0x00000008
#define TMN_DNSRESOLV	0x00000010
#define TMN_COREDUMP	0x00000020
d337 2
@


1.202
log
@Add kbind, a syscall for ld.so to use to securely and efficiently update
memory for lazy binding

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.201 2015/07/19 02:35:35 deraadt Exp $	*/
d334 1
@


1.201
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.200 2015/07/18 00:15:10 mpi Exp $	*/
d215 3
@


1.200
log
@Kill emul left-over.

From Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.199 2015/02/10 05:28:18 guenther Exp $	*/
d214 2
d253 1
d260 1
a260 1
     "\024NOBROADCASTKILL")
d324 9
d373 16
a388 16
#define	P_INKTR		0x000001	/* In a ktrace op, don't recurse */
#define	P_PROFPEND	0x000002	/* SIGPROF needs to be posted */
#define	P_ALRMPEND	0x000004	/* SIGVTALRM needs to be posted */
#define	P_SIGSUSPEND	0x000008	/* Need to restore before-suspend mask*/
#define	P_CANTSLEEP	0x000010	/* insomniac thread */
#define	P_SELECT	0x000040	/* Selecting; wakeup/waiting danger. */
#define	P_SINTR		0x000080	/* Sleep is interruptible. */
#define	P_SYSTEM	0x000200	/* No sigs, stats or swapping. */
#define	P_TIMEOUT	0x000400	/* Timing out during sleep. */
#define	P_WEXIT		0x002000	/* Working on exiting. */
#define	P_OWEUPC	0x008000	/* Owe proc an addupc() at next ast. */
#define	P_SUSPSINGLE	0x080000	/* Need to stop for single threading. */
#define P_SYSTRACE	0x400000	/* Process system call tracing active*/
#define P_CONTINUED	0x800000	/* Proc has continued from a stopped state. */
#define	P_THREAD	0x4000000	/* Only a thread, not a real process */
#define	P_SUSPSIG	0x8000000	/* Stopped from signal. */
@


1.199
log
@Factor out the common bits of process_new() and main()'s code for
setting up process0, 'cause I'm sick of forgetting to update main()
when touching process_new()

ok blambert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.198 2015/02/09 04:27:18 dlg Exp $	*/
a118 3

extern struct emul *emulsw[];		/* All emuls in system */
extern int nemuls;			/* Number of emuls */
@


1.198
log
@i missed a quote when cutting the fmt strings up.

i found the breakage with my compiler, guenther found the missing
quote with his eyes.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.197 2015/02/09 04:06:13 dlg Exp $	*/
d496 1
@


1.197
log
@make the %b format args easier (for me) to read.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.196 2015/02/09 03:46:12 dlg Exp $	*/
d387 1
a387 1
     "\030CONTINUED" "\033THREAD" "\034SUSPSIG" \035SOFTDEP" "\037CPUPEG")
@


1.196
log
@i added a newline i shouldnt have

queried by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.195 2015/02/09 03:15:41 dlg Exp $	*/
d256 5
a260 4
    ("\20\01CONTROLT\02EXEC\03INEXEC\04EXITING\05SUGID" \
     "\06SUGIDEXEC\07PPWAIT\010ISPWAIT\011PROFIL\012TRACED" \
     "\013WAITED\014COREDUMP\015SINGLEEXIT\016SINGLEUNWIND" \
     "\017NOZOMBIE\020STOPPED\021SYSTEM\022EMBRYO\023ZOMBIE\024NOBROADCASTKILL")
d384 4
a387 5
    ("\20\01INKTR\02PROFPEND\03ALRMPEND\04SIGSUSPEND\05CANTSLEEP\07SELECT" \
     "\010SINTR\012SYSTEM" \
     "\013TIMEOUT\016WEXIT\020OWEUPC\024SUSPSINGLE" \
     "\027SYSTRACE\030CONTINUED\033THREAD" \
     "\034SUSPSIG\035SOFTDEP\037CPUPEG")
@


1.195
log
@we want to defer work traditionally (in openbsd) handled in an
interrupt context to a taskq running in a thread. however, there
is a concern that if we do that then we allow accidental use of
sleeping APIs in this work, which will make it harder to move the
work back to interrupts in the future.

guenther and kettenis came up with the idea of marking a proc with
CANTSLEEP which the sleep paths can check and panic on.

this builds on that so you create taskqs that run with CANTSLEEP
set except when they need to sleep for more tasks to run.

the taskq_create api is changed to take a flags argument so users
can specify CANTSLEEP. MPSAFE is also passed via this flags field
now.  this means archs that defined IPL_MPSAFE to 0 can now create
mpsafe taskqs too.

lots of discussion at s2k15
ok guenther@@ miod@@ mpi@@ tedu@@ pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.194 2015/01/26 22:51:37 kettenis Exp $	*/
a366 1

@


1.194
log
@Move the "stackgap" from the stack into its own page at a random address.
This allows us the unmap the initial part of the stack, such that it can't
be used as a staging area for ROP (or other) attacks.

ok guenther@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.193 2015/01/20 19:43:21 kettenis Exp $	*/
d367 2
d384 1
a384 1
    ("\20\01INKTR\02PROFPEND\03ALRMPEND\04SIGSUSPEND\07SELECT" \
@


1.193
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.192 2015/01/15 23:59:09 deraadt Exp $	*/
d203 1
@


1.192
log
@include <sys/syslimits.h> and switch to use of LOGIN_NAME_MAX, making
this far more standalone.  discussed with guenther
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.191 2014/11/16 05:42:21 guenther Exp $	*/
d202 1
@


1.191
log
@Rework the __thrsigdivert (aka sigwait()) handling: instead of interfering
in ptsignal(), which broke ptrace() in various circumstances, act more like
sigsuspend() by updating the signal mask and picking off waited for signals
when one occurs.  Don't always restart when an unwaited-for-but-handled
signal occurs, as that screws with both timeout calculation and cancellation.

main problem noted by jmatthew@@
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.190 2014/07/13 16:41:21 claudio Exp $	*/
d45 1
d66 1
a66 1
	char	s_login[MAXLOGNAME];	/* Setlogin() name. */
d93 1
a93 1
	void	(*e_sendsig)(sig_t, int, int, u_long, int, union sigval);
@


1.190
log
@Introduce PS_NOBROADCASTKILL a process flag that excludes processes from
receiving broadcast signals (kill -1). The flag can be set via a new
sysctl KERN_PROC_NOBROADCASTKILL. This will be used by iscsid to survive
the mass killing by init(8) when terminating multi-user operations.
With and OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.189 2014/07/12 21:21:19 matthew Exp $	*/
a283 1
	int	p_sigwait;	/* signal handled by sigwait() */
a307 1
	sigset_t p_sigdivert;		/* Signals to be diverted to thread. */
@


1.189
log
@Refactor out dosigsuspend() function

Discussed with guenther and kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.188 2014/07/11 08:18:31 guenther Exp $	*/
d250 1
d256 1
a256 1
     "\017NOZOMBIE\020STOPPED\021SYSTEM\022EMBRYO\023ZOMBIE")
@


1.188
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.187 2014/07/04 05:58:30 guenther Exp $	*/
d497 1
@


1.187
log
@Track whether a process is a zombie or not yet fully built via flags
PS_{ZOMBIE,EMBRYO} on the process instead of peeking into the process's
thread data.  This eliminates the need for the thread-level SDEAD state.

Change kvm_getprocs() (both the sysctl() and kvm backends) to report the
"most active" scheduler state for the process's threads.

tweaks kettenis@@
feedback and ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.186 2014/05/15 03:52:25 guenther Exp $	*/
d454 2
a455 2
extern struct proc *initproc;		/* Process slot for init. */
extern struct proc *reaperproc;		/* Process slot for reaper. */
@


1.186
log
@Move from struct proc to process the reference-count-holding pointers
to the process's vmspace and filedescs.  struct proc continues to
keep copies of the pointers, copying them on fork, clearing them
on exit, and (for vmspace) refreshing on exec.
Also, make uvm_swapout_threads() thread aware, eliminating p_swtime
in kernel.

particular testing by ajacoutot@@ and sebastia@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.185 2014/05/04 05:03:26 guenther Exp $	*/
d248 2
d255 1
a255 1
     "\017NOZOMBIE\020STOPPED\021SYSTEM")
d348 1
a348 1
#define	SIDL	1		/* Process being created by fork. */
d351 4
a354 4
#define	SSTOP	4		/* Process debugging or suspension. */
#define	SZOMB	5		/* Awaiting collection by parent. */
#define SDEAD	6		/* Process is almost a zombie. */
#define	SONPROC	7		/* Process is currently on a CPU. */
d356 1
a356 1
#define P_ZOMBIE(p)	((p)->p_stat == SZOMB || (p)->p_stat == SDEAD)
@


1.185
log
@Add PS_SYSTEM, the process-level mirror of the thread-level P_SYSTEM,
and FORK_SYSTEM as a flag to set them.  This eliminates needing to
peek into other processes threads in various places.  Inspired by NetBSD

ok miod@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.184 2014/04/18 11:51:17 guenther Exp $	*/
d169 2
d264 2
a265 2
	struct	filedesc *p_fd;		/* Ptr to open files structure. */
	struct	vmspace *p_vmspace;	/* Address space. */
d290 1
a290 2
	fixpt_t	p_pctcpu;	 /* %cpu for this thread during p_swtime */
	u_int	p_swtime;	 /* Time swapped in or out. */
@


1.184
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.183 2014/03/31 22:20:15 matthew Exp $	*/
d245 1
d251 1
a251 1
     "\017NOZOMBIE\020STOPPED")
d419 1
@


1.183
log
@Fix octal constant: "\018" -> "\020"

ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.182 2014/03/30 21:54:48 guenther Exp $	*/
a262 1
#define	p_ucred		p_p->ps_ucred
d323 1
d491 11
@


1.182
log
@Eliminates struct pcred by moving the real and saved ugids into
struct ucred; struct process then directly links to the ucred

Based on a discussion at c2k10 or so before noting that FreeBSD and
NetBSD did this too.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.181 2014/03/29 18:09:31 guenther Exp $	*/
d250 1
a250 1
     "\017NOZOMBIE\018STOPPED")
@


1.181
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.180 2014/03/27 04:12:28 guenther Exp $	*/
d157 1
a157 1
	struct	pcred *ps_cred;		/* Process owner's identity. */
d263 1
a263 2
#define	p_cred		p_p->ps_cred
#define	p_ucred		p_cred->pc_ucred
a383 15
/*
 * MOVE TO ucred.h?
 *
 * Shareable process credentials (always resident).  This includes a reference
 * to the current user credentials as well as real and saved ids that may be
 * used to change ids.
 */
struct	pcred {
	struct	ucred *pc_ucred;	/* Current credentials. */
	uid_t	p_ruid;			/* Real user id. */
	uid_t	p_svuid;		/* Saved effective user id. */
	gid_t	p_rgid;			/* Real group id. */
	gid_t	p_svgid;		/* Saved effective group id. */
};

a458 1
extern struct pool pcred_pool;		/* memory pool for pcreds */
@


1.180
log
@Reorder a few struct process members to avoid copying some values
that will be reinitialized anyway.  Delete some blank lines to
prevent the same error being repeated.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.179 2014/03/26 05:23:41 guenther Exp $	*/
d295 1
a295 1
	struct	cpu_info * __volatile p_cpu; /* CPU we're running on. */
@


1.179
log
@Move p_emul and p_sigcode from proc to process.
Tweak the handling of ktrace EMUL when changing ktracing: only
generate one per process (not one per thread) and pass the correct
proc pointer down to the VFS layer.  Permit generating of NAMI and
CSW records inside ktrace(2) itself.

ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.178 2014/03/22 06:05:45 guenther Exp $	*/
a195 1

d214 1
a217 2

	int	ps_refcnt;		/* Number of references. */
a277 1

a312 1

a331 1

@


1.178
log
@Move p_sigacts from struct proc to struct process.

testing help mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.177 2014/02/12 05:47:36 guenther Exp $	*/
d199 2
a328 1
	struct	emul *p_emul;		/* Emulation information */
a329 1
	vaddr_t	p_sigcode;		/* user pointer to the signal code. */
@


1.177
log
@Eliminate the exit sig handling, which was only invokable via the
Linux-compat clone() syscall when *not* using CLONE_THREAD.  pirofti@@
confirms Opera runs in compat without this, so out it goes; one less hair
to choke on in kern_exit.c

ok tedu@@ pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.176 2014/02/09 11:17:19 kettenis Exp $	*/
d167 1
a262 1
	struct	sigacts *p_sigacts;	/* Signal actions, state */
@


1.176
log
@Fix the lock order reversal problem in the code that stops traced
multi-threaded  processes when they receive a signal:

1. Make the parent of the process (the tracer) wait for all threads to be
   stopped (in wait4(2)) instead of the thread that received the signal.
   This prevents us from calling tsleep(9) recursively.

2. Assume that we already hold the kernel lock if the P_SINTR flag is set
   (just like we already assumed we were holding the scheduler lock) and
   don't try to grab it again.

This should fix the panic that many people reported when debugging
multi-threaded programs with gdb(1).

ok & lots of help from guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.175 2014/02/04 00:33:43 tedu Exp $	*/
d242 1
a242 1
#define	PS_NOZOMBIE	0x00004000	/* Pid 1 waits for me instead of dad */
a266 1
	int	p_exitsig;		/* Signal to send to parent on exit. */
a387 4
/* Macro to compute the exit signal to be delivered. */
#define P_EXITSIG(p) \
    (((p)->p_p->ps_flags & PS_TRACED) ? SIGCHLD : (p)->p_exitsig)

d510 1
a510 1
int	fork1(struct proc *, int, int, void *, pid_t *, void (*)(void *),
@


1.175
log
@rearrange a few fields to reduce internal padding in struct proc
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.174 2014/01/20 21:19:27 guenther Exp $	*/
d521 1
d526 1
@


1.174
log
@Threads can't be zombies, only processes, so change zombproc to zombprocess,
make it a list of processes, and change P_NOZOMBIE and P_STOPPED from thread
flags to process flags.  Add allprocess list for the code that just wants
to see processes.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.173 2014/01/20 03:23:42 guenther Exp $	*/
d282 1
a283 1
	int	p_sigwait;	/* signal handled by sigwait() */
a287 1
	fixpt_t	p_pctcpu;	 /* %cpu for this thread during p_swtime */
d291 1
d294 3
a301 3
	u_int	p_uticks;		/* Statclock hits in user mode. */
	u_int	p_sticks;		/* Statclock hits in system mode. */
	u_int	p_iticks;		/* Statclock hits processing intr. */
a304 2
	int	p_siglist;		/* Signals arrived but not delivered. */

d307 1
a307 1

d342 1
d344 1
a344 1
	int	p_sisig;	/* For core dump/debugger XXX */
a345 1
	long	p_sitrapno;	/* For core dump/debugger XXX */
@


1.173
log
@Move p_textvp from struct proc to struct process so that the exit code
can be further simplified.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.172 2013/10/25 04:42:48 guenther Exp $	*/
d159 1
d242 2
d248 2
a249 1
     "\013WAITED\014COREDUMP\015SINGLEEXIT\016SINGLEUNWIND")
d254 1
a254 1
	LIST_ENTRY(proc) p_list;	/* List of all processes. */
a376 1
#define	P_NOZOMBIE	0x100000	/* Pid 1 waits for me instead of dad */
a381 1
#define P_STOPPED	0x20000000	/* Just stopped, need sig to parent. */
d388 2
a389 2
     "\025NOZOMBIE\027SYSTRACE\030CONTINUED\033THREAD" \
     "\034SUSPSIG\035SOFTDEP\036STOPPED\037CPUPEG")
d472 4
a475 2
extern struct proclist allproc;		/* List of all processes. */
extern struct proclist zombproc;	/* List of zombie processes. */
d534 2
a535 1
void	proc_zap(struct proc *);
@


1.172
log
@Move the declarations for dogetrusage(), itimerround(), and dowait4()
to sys/*.h headers so that the compat/linux code can use them.
Change dowait4() to not copyout() the status value, but rather leave
that for its caller, as compat/linux has to translate it, with the
side benefit of simplifying the native code.

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.171 2013/10/08 03:50:06 guenther Exp $	*/
d166 2
a301 2

	struct	vnode *p_textvp;	/* Vnode of executable. */
@


1.171
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.170 2013/09/22 17:28:33 guenther Exp $	*/
d510 2
@


1.170
log
@Stop merging the per-thread and per-process flags when reporting
them via sysctl(KERN_PROC).  In struct kinfo_proc the per-process
flags move to p_psflags, leaving the per-thread flags in p_flags.
Flag descriptions in ps(1) updated to be less obtuse.

discussed with matthew@@ some time ago; ok jca@@, manpage bits ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.169 2013/08/12 20:43:28 bluhm Exp $	*/
a211 2
	struct	timeout ps_virt_to;	/* virtual itimer trampoline. */
	struct	timeout ps_prof_to;	/* prof itimer trampoline. */
d363 2
d383 2
a384 1
    ("\20\01INKTR\04SIGSUSPEND\07SELECT\010SINTR\012SYSTEM" \
@


1.169
log
@The ps flags are split between thread and process.  It is useful
for ddb to show both.  So or them together in the ps overview and
list them explicitly for the specific thread.  Also sync the ddb
bit names with the define names.
OK miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.168 2013/06/06 13:09:37 haesbaert Exp $	*/
d225 1
a225 4
 * These flags are kept in ps_flags, but they used to be in proc's p_flag
 * and were exported to userspace via the KERN_PROC sysctl.  We'll retain
 * compat by using non-overlapping bits for PS_* and P_* flags and just
 * OR them together for export.
d227 20
a246 19
#define	PS_CONTROLT	_P_CONTROLT
#define	PS_PPWAIT	_P_PPWAIT
#define	PS_PROFIL	_P_PROFIL
#define	PS_SUGID	_P_SUGID
#define	PS_SYSTEM	_P_SYSTEM
#define	PS_TRACED	_P_TRACED
#define	PS_WAITED	_P_WAITED
#define	PS_EXEC		_P_EXEC
#define	PS_ISPWAIT	_P_ISPWAIT
#define	PS_SUGIDEXEC	_P_SUGIDEXEC
#define	PS_NOZOMBIE	_P_NOZOMBIE
#define	PS_INEXEC	_P_INEXEC
#define	PS_SYSTRACE	_P_SYSTRACE
#define	PS_CONTINUED	_P_CONTINUED
#define	PS_STOPPED	_P_STOPPED
#define	PS_SINGLEEXIT	_P_SINGLEEXIT
#define	PS_SINGLEUNWIND	_P_SINGLEUNWIND
#define	PS_EXITING	_P_EXITING
#define	PS_COREDUMP	_P_COREDUMP
d362 1
a362 2
 * These flags are kept in p_flag, except those with a leading underbar,
 * which are in process's ps_flags
a364 2
#define	_P_CONTROLT	0x000002	/* Has a controlling terminal. */
#define	P_INMEM		0x000004	/* Loaded into memory. UNUSED */
a365 2
#define	_P_PPWAIT	0x000010	/* Parent waits for exec/exit. */
#define	_P_PROFIL	0x000020	/* Has started profiling. */
a367 1
#define	_P_SUGID	0x000100	/* Had set id privs since last exec. */
a369 2
#define	_P_TRACED	0x000800	/* Debugged process being traced. */
#define	_P_WAITED	0x001000	/* Debugging proc has waited for child. */
a370 3
#define	_P_EXEC		0x004000	/* Process called exec. */

/* Should be moved to machine-dependent areas. */
a371 4

#define	_P_ISPWAIT	0x010000	/* Is parent of PPWAIT child. */
#define	_P_COREDUMP	0x020000	/* busy coredumping */
#define	_P_SUGIDEXEC	0x040000	/* last execve() was set[ug]id */
a373 1
#define _P_INEXEC	0x200000	/* Process is doing an exec right now */
a375 2
#define	_P_SINGLEEXIT	0x1000000	/* Other threads must die. */
#define	_P_SINGLEUNWIND	0x2000000	/* Other threads must unwind. */
a380 12
#define _P_EXITING	0x80000000	/* Process is exiting. */

#ifndef _KERNEL
#define	P_CONTROLT	_P_CONTROLT
#define	P_PPWAIT	_P_PPWAIT
#define	P_PROFIL	_P_PROFIL
#define	P_SUGID		_P_SUGID
#define	P_TRACED	_P_TRACED
#define	P_EXEC		_P_EXEC
#define	P_SUGIDEXEC	_P_SUGIDEXEC
#define	P_INEXEC	_P_INEXEC
#endif
d383 4
a386 8
    ("\20\01INKTR\02CONTROLT\03INMEM\04SIGSUSPEND" \
     "\05PPWAIT\06PROFIL\07SELECT\010SINTR" \
     "\011SUGID\012SYSTEM\013TIMEOUT\014TRACED" \
     "\015WAITED\016WEXIT\017EXEC\020OWEUPC" \
     "\021ISPWAIT\022COREDUMP\023SUGIDEXEC\024SUSPSINGLE" \
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED" \
     "\031SINGLEEXIT\032SINGLEUNWIND\033THREAD\034SUSPSIG" \
     "\035SOFTDEP\036STOPPED\037CPUPEG\040EXITING")
@


1.168
log
@Prevent idle thread from being stolen on startup.

There is a race condition which might trigger a case where two cpus try
to run the same idle thread.

The problem arises when one cpu steals the idle proc of another cpu and
this other cpu ends up running the idle thread via spc->spc_idleproc,
resulting in two cpus trying to cpu_switchto(idleX).

On startup, idle procs are scaterred around different runqueues, the
decision for scheduling is:

1 look at my runqueue.
2 if empty, look at other dudes runqueue.
3 if empty, select idle proc via spc->spc_idleproc.

The problem is that cpu0's idle0 might be running on cpu1 due to step 1
or 2 and cpu0 hits step 3.

So cpu0 will select idle0, while cpu1 is in fact running it already.

The solution is to never place idle on a runqueue, therefore being
only selectable through spc->spc_idleproc.

This race can be more easily triggered on a HT cpu on virtualized
environments, where the guest more often than not doesn't have the cpu
for itself, so timing gets shuffled.

ok tedu@@ guenther@@
go ahead after t2k13 deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.167 2013/06/05 00:53:27 tedu Exp $	*/
d415 5
a419 3
    ("\20\02CONTROLT\03INMEM\04SIGPAUSE\05PPWAIT\06PROFIL\07SELECT" \
     "\010SINTR\011SUGID\012SYSTEM\013TIMEOUT\014TRACED\015WAITED\016WEXIT" \
     "\017EXEC\020PWEUPC\021ISPWAIT\022COREDUMPING\023SUGIDEXEC\024SUSPSINGLE" \
d421 2
a422 2
     "\031SINGLEEXIT\032SINGLEUNWIND" \
     "\033THREAD\034SUSPSIG\035SOFTDEP\036STOPPED\037CPUPEG")
@


1.167
log
@factor out pid allocation to functions. add a small cache of recently
exited pids that won't get recycled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.166 2013/06/03 16:55:22 guenther Exp $	*/
d474 1
@


1.166
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.165 2013/02/11 11:11:42 mpi Exp $	*/
d517 3
a519 1
struct simplelock;
@


1.165
log
@When information about threads are not requested sum the '%cpu' of
all threads in a process instead of returning only the '%cpu' for
the main thread.

This makes top(1) display the correct percentage of CPU usage for
threaded processes when theads are not displayed.

ok sthen@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.164 2013/01/15 02:03:38 deraadt Exp $	*/
d128 1
a128 1
	struct	timeval tu_runtime;	/* Realtime. */
d210 1
a210 1
	struct	timeval ps_start;	/* starting time. */
d296 1
a296 1
	struct	timeval p_rtime;	/* Real time. */
@


1.164
log
@Allow SIGKILL to terminate coredumping processes.  Semantics decided
with kettenis guenther and beck.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.163 2012/09/11 15:44:19 deraadt Exp $	*/
d286 1
a286 1
	fixpt_t	p_pctcpu;	 /* %cpu for this process during p_swtime */
@


1.163
log
@Remove the 'OLF method' used for the transition from a.out to ELF and
for all the compat layers which are now gone.  Linux compat still works
because it always used another method in any case, and nothing looks at
p_os anymore.
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.162 2012/08/02 03:18:48 guenther Exp $	*/
d248 1
d385 1
d387 1
a387 3

/* XXX Not sure what to do with these, yet. */
#define	P_SSTEP		0x020000	/* proc needs single-step fixup ??? */
a388 1

d417 1
a417 1
     "\017EXEC\020PWEUPC\021ISPWAIT\022SSTEP\023SUGIDEXEC\024SUSPSINGLE" \
@


1.162
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.161 2012/07/17 21:59:56 guenther Exp $	*/
d266 1
a266 1
	u_char	p_os;			/* OS tag */
@


1.161
log
@p_prof_ticks accidentally got moved from a 'copy-on-fork' area
(when it was in struct pstats) to an 'uninitialized-on-fork' area
(in struct proc), thus resulting in the counts all being off.  Put
it and p_prof_addr back in a 'copy-on-fork' area.

ok matthew@@ miod@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.160 2012/07/11 08:45:21 guenther Exp $	*/
d371 1
a371 1
#define	P_PROFIL	0x000020	/* Has started profiling. */
d407 1
d497 1
@


1.160
log
@exit1(EXIT_THREAD) needs to call single_thread_check() so that it
can be suspended and/or decrement pr->ps_singlecount if necessary.
With that added, the call the other direction needs to use its own
flag (EXIT_THREAD_NOCHECK) to avoid looping.

problem diagnosed from a hang naddy@@ hit; ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.159 2012/06/13 22:47:40 ariane Exp $	*/
d333 3
a346 3

	u_long	p_prof_addr;	/* temp storage for profiling addr util AST */
	u_long	p_prof_ticks;	/* temp storage for profiling ticks util AST */
@


1.159
log
@Expose reaperproc.

I need this for my diffs.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.158 2012/04/13 16:37:50 kettenis Exp $	*/
d483 3
a485 2
#define EXIT_NORMAL	0x00000001
#define EXIT_THREAD	0x00000002
@


1.158
log
@First stab at making ptrace(2) usable for debugging multi-threaded programs.
It implements a full-stop model where all threads are stopped before handing
over control to the debugger.  Events are reported as before through wait(2);
you will have to call ptrace(PT_GET_PROCESS_STATE, ...) to find out which
thread hit the event.  Since this changes the size of struct ptrace_state,
you will have to recompile gdb.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.157 2012/04/12 12:33:03 deraadt Exp $	*/
d503 2
a504 1
extern struct proc *initproc;		/* Process slots for init, pager. */
@


1.157
log
@remove rfork(); ok guenther miod
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.156 2012/04/12 10:11:41 mikeb Exp $	*/
d548 1
a548 1
void	single_thread_clear(struct proc *);
@


1.156
log
@move accounting flags to struct process; idea and ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.155 2012/04/11 15:28:50 kettenis Exp $	*/
a473 1
#define FORK_RFORK	0x00000004
a475 1
#define FORK_CLEANFILES	0x00000020
@


1.155
log
@Move the P_WAITED flag from struct proc to struct process.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.154 2012/04/10 15:50:52 guenther Exp $	*/
d205 2
a348 1
	u_short	p_acflag;	/* Accounting flags. */
@


1.154
log
@Make the KERN_NPROCS and KERN_MAXPROC sysctl()s and the RLIMIT_NPROC rlimit
count processes instead of threads.  New sysctl()s KERN_NTHREADS and
KERN_MAXTHREAD count and limit threads.  The nprocs and maxproc kernel
variables are replaced by nprocess, maxprocess, nthreads, and maxthread.

ok tedu@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.153 2012/03/23 15:51:26 guenther Exp $	*/
d377 1
a377 1
#define	P_WAITED	0x001000	/* Debugging proc has waited for child. */
@


1.153
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.152 2012/03/10 05:54:28 guenther Exp $	*/
d496 2
a497 1
extern int nprocs, maxproc;		/* Current and max number of procs. */
@


1.152
log
@Add PS_EXITING to better differentiate between the process exiting and
the main thread exiting.  c.f. regress/sys/kern/main-thread-exited/
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.151 2012/02/28 05:36:57 guenther Exp $	*/
d49 1
d123 12
d182 5
d198 7
d208 5
a255 1
	struct	pstats *p_stats;	/* Accounting/statistics */
d291 2
a292 2
	struct	itimerval p_realtimer;	/* Alarm timer. */
	struct	timeout p_realit_to;	/* Alarm timeout. */
d294 3
a296 3
	u_quad_t p_uticks;		/* Statclock hits in user mode. */
	u_quad_t p_sticks;		/* Statclock hits in system mode. */
	u_quad_t p_iticks;		/* Statclock hits processing intr. */
d343 3
a347 1
	struct	rusage *p_ru;	/* Exit information. XXX */
@


1.151
log
@For non-__HAVE_MD_TCB archs, p_tcb should be copied on fork.  Found by miod@@

p_oldmask and the core dump/debugger members don't need to be copied.
Pointed out by matthew@@

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.150 2012/02/20 22:23:39 guenther Exp $	*/
d215 1
a346 1
/* XXX - Should be merged with INEXEC */
d370 1
@


1.150
log
@First steps for making ptrace work with rthreads:
 - move the P_TRACED and P_INEXEC flags, and p_oppid, p_ptmask, and
   p_ptstat member from struct proc to struct process
 - sort the PT_* requests into those that take a PID vs those that
   can also take a TID
 - stub in PT_GET_THREAD_FIRST and PT_GET_THREAD_NEXT

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.149 2012/01/07 05:38:12 guenther Exp $	*/
a249 6
#ifndef	__HAVE_MD_TCB
	void	*p_tcb;		/* user-space thread-control-block address */
# define TCB_SET(p, addr)	((p)->p_tcb = (addr))
# define TCB_GET(p)		((p)->p_tcb)
#endif

d291 6
d304 3
a311 3

	struct	user *p_addr;	/* Kernel virtual addr of u-area */
	struct	mdproc p_md;	/* Any machine-dependent fields. */
@


1.149
log
@Add rtable id and thread id to struct kinfo_proc (and fix process id)
and add an 'rtableid' keyword to ps.

Add rtable id, thread id, and socket splice info to struct kinfo_file2
and make fstat display socket splice information.

Remove old KVM_PROC2 and kinfo_proc2 interfaces; bump libkvm major

Socket splice info and corrections from bluhm@@  "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.148 2011/12/14 07:32:16 guenther Exp $	*/
d165 4
d243 1
a243 1
#define	p_startzero	p_oppid
a244 1
	pid_t	p_oppid;	 /* Save parent pid during ptrace. XXX */
a275 3
	int	p_ptmask;		/* Ptrace event mask */
	struct	ptrace_state *p_ptstat;	/* Ptrace state */

d344 1
a344 1
#define	P_TRACED	0x000800	/* Debugged process being traced. */
d360 1
a360 1
#define P_INEXEC	0x200000	/* Process is doing an exec right now */
d375 1
d378 1
d391 1
a391 1
    (((p)->p_flag & P_TRACED) ? SIGCHLD : (p)->p_exitsig)
@


1.148
log
@Handle rthreads consistently in ktrace by moving the flags and vnode into
struct process; KTRFAC_ACTIVE becomes P_INKTR.  Also, save the credentials
used to open the file in sys_ktrace() and use them for all writes to the
vnode.

much feedback and ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.147 2011/12/11 19:42:28 guenther Exp $	*/
d391 2
a425 1
#define	THREAD_PID_OFFSET	1000000
@


1.147
log
@Suspend other rthreads before dumping core or execing; make them exit
when exec succeeds.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.146 2011/11/22 23:20:19 joshe Exp $	*/
d161 4
a270 3
	int	p_traceflag;		/* Kernel trace points. */
	struct	vnode *p_tracep;	/* Trace to vnode. */

d333 1
@


1.146
log
@Move struct proc's sigaltstack struct from the zeroed area into the
copied area, and initialize it properly in the FORK_THREAD case.

This restores the behavior of a forked process inheriting its parent's
signal stack.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.145 2011/10/18 01:06:15 dlg Exp $	*/
d158 3
d205 2
d356 1
d361 2
d364 1
a364 1
#define	P_IGNEXITRV	0x8000000	/* For thread kills */
d366 1
a366 1
#define P_STOPPED	0x20000000	/* Just stopped. */
d380 1
a380 1
     "\017EXEC\020PWEUPC\021ISPWAIT\022SSTEP\023SUGIDEXEC" \
d382 2
a383 1
     "\033THREAD\034IGNEXITRV\035SOFTDEP\036STOPPED\037CPUPEG")
d504 9
@


1.145
log
@the BIGLOCK flag is gone so remove it from the %b fmt string.

ok oga@@ miod@@ guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.144 2011/10/15 23:35:29 guenther Exp $	*/
a277 1
	struct	sigaltstack p_sigstk;	/* sp & on stack state variable */
d292 2
a293 1
	vaddr_t	p_sigcode;	/* user pointer to the signal code. */
@


1.144
log
@"TLS-lite": add kernel support for a per-thread userspace pointer,
for pointing to the thread-control-block.  Support for mapping this
to the correct hardware register can be added as it's finished;
start with support for amd64, sparc, and sparc64.  Includes syscalls
for getting and setting it (for a portable __errno implementation) as
well as creating a new thread with an initial value for it.

discussed with miod@@, kettenis@@, deraadt@@; committing to get the syscalls
in with the impending libc bump and do further refinements in tree
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.143 2011/09/20 10:07:37 deraadt Exp $	*/
d373 1
a373 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED\032BIGLOCK" \
@


1.143
log
@MD trap() passes a MD "traptype" and siginfo-style "code" up to the MI
layers.  Then things get terribly confusing because the various MI layers
swap variable names for parameters, local variables, and structure fields
numerous times.  Unconfuse all this mess.

Note that exec_elf.c coredump cpi_sigcode used to contain the MD traptype
but will now contain the MI siginfo-style "code" value.
ok miod kettenis pirofti
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.142 2011/09/18 23:07:32 guenther Exp $	*/
d238 5
d433 1
d492 1
a492 1
int	fork1(struct proc *, int, int, void *, size_t, void (*)(void *),
@


1.142
log
@PS_* flags are exposed to userspace via sysctl(KERN_PROC); don't require
such programs to #define __need_process just to get them

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.141 2011/07/07 18:00:33 guenther Exp $	*/
a294 1
	long	p_sicode;	/* For core dump/debugger XXX */
d296 2
a297 1
	int	p_sitype;	/* For core dump/debugger XXX */
@


1.141
log
@Functions used in files other than where they are defined should be
declared in .h files, not in each .c.  Apply that rule to endtsleep(),
scheduler_start(), updatepri(), and realitexpire()

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.140 2011/07/06 21:41:37 art Exp $	*/
d179 2
d183 1
a183 1
 * and were exported to userspace via the KERN_PROC2 sysctl.  We'll retain
a201 2

#endif /* __need_process */
@


1.140
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.139 2011/07/05 04:48:02 guenther Exp $	*/
d480 1
@


1.139
log
@Recommit the reverted sigacts change now that the NFS use-after-free
problem has been tracked down.  This fixes the sharing of the signal
handling state: shared bits go in sigacts, per-rthread bits goes in
struct proc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.138 2011/04/18 21:44:56 guenther Exp $	*/
a349 1
#define P_BIGLOCK	0x2000000	/* Process needs kernel "big lock" to run */
@


1.138
log
@Revert the sigacts diff: NFS can apparently retain pointers to processes
until they're zombies and then send them signals (for intr mounts).  Until
that is untangled, the sigacts change is unsafe.  sthen@@ was the victim
for this one
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.136 2011/04/04 13:00:13 guenther Exp $	*/
a185 1
#define	PS_NOCLDSTOP	_P_NOCLDSTOP
a194 1
#define	PS_NOCLDWAIT	_P_NOCLDWAIT
d273 1
a281 2
	sigset_t p_sigignore;	/* Signals being ignored. */
	sigset_t p_sigcatch;	/* Signals being caught by user. */
d293 6
d324 1
a324 1
#define	P_NOCLDSTOP	0x000008	/* No SIGCHLD when children stop. */
a345 1
#define	P_NOCLDWAIT	0x080000	/* Let pid 1 wait for my children */
d366 1
a366 1
    ("\20\02CONTROLT\03INMEM\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
d368 1
a368 1
     "\017EXEC\020PWEUPC\021ISPWAIT\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
@


1.137
log
@Correct the sharing of the signal handling state: stuff that should
be shared (p_sigignore, p_sigcatch, P_NOCLDSTOP, P_NOCLDWAIT) moves
to struct sigacts, wihle stuff that should be per rthread (ps_oldmask,
SAS_OLDMASK, ps_sigstk) moves to struct proc.  Treat the coredumping
state bits (ps_sig, ps_code, ps_type, ps_sigval) as per-rthread
until our locking around coredumping is better.

Oh, and remove the old SunOS-compat ps_usertramp member.

"I like the sound of this" tedu@@
@
text
@d186 1
d196 1
a274 1
	struct	sigaltstack p_sigstk;	/* sp & on stack state variable */
d283 2
a295 6
	sigset_t p_oldmask;	/* Saved mask from before sigpause */
	union sigval p_sigval;	/* For core dump/debugger XXX */
	long	p_sicode;	/* For core dump/debugger XXX */
	int	p_sisig;	/* For core dump/debugger XXX */
	int	p_sitype;	/* For core dump/debugger XXX */

d321 1
a321 1
#define	P_SIGSUSPEND	0x000008	/* Need to restore before-suspend mask*/
d343 1
d364 1
a364 1
    ("\20\02CONTROLT\03INMEM\04SIGPAUSE\05PPWAIT\06PROFIL\07SELECT" \
d366 1
a366 1
     "\017EXEC\020PWEUPC\021ISPWAIT\022SSTEP\023SUGIDEXEC" \
@


1.136
log
@Move P_EXEC flag from struct proc to process, so that setpgid() will
fail regardless of which rthread calls execve()

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.135 2011/04/03 14:56:28 guenther Exp $	*/
a185 1
#define	PS_NOCLDSTOP	_P_NOCLDSTOP
a194 1
#define	PS_NOCLDWAIT	_P_NOCLDWAIT
d273 1
a281 2
	sigset_t p_sigignore;	/* Signals being ignored. */
	sigset_t p_sigcatch;	/* Signals being caught by user. */
d293 6
d324 1
a324 1
#define	P_NOCLDSTOP	0x000008	/* No SIGCHLD when children stop. */
a345 1
#define	P_NOCLDWAIT	0x080000	/* Let pid 1 wait for my children */
d366 1
a366 1
    ("\20\02CONTROLT\03INMEM\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
d368 1
a368 1
     "\017EXEC\020PWEUPC\021ISPWAIT\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
@


1.135
log
@Move PPWAIT flag from struct proc to process, so that rthreads in
a vforked child behave correctly.  Have the parent in a vfork()
wait on a (different) flag in *its* process instead of the child
to prevent a possible use-after-free.  When ktracing the child
return from a fork, call it rfork if an rthread was created.

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.134 2011/04/02 17:04:35 guenther Exp $	*/
d333 1
a333 1
#define	P_EXEC		0x004000	/* Process called exec. */
d359 1
@


1.134
log
@Move P_SUGID and P_SUGIDEXEC from struct proc to struct process, so
that you can't evade the checks by doing the dirty work in an rthread

ok blambert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.133 2011/03/07 07:07:13 guenther Exp $	*/
d194 1
d322 1
a322 1
#define	P_PPWAIT	0x000010	/* Parent waits for child exec/exit. */
d337 1
d357 1
d365 1
a365 1
     "\017EXEC\020PWEUPC\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
@


1.133
log
@The scheduling 'nice' value is per-process, not per-thread, so move it
into struct process.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.132 2010/07/26 01:56:27 guenther Exp $	*/
d325 1
a325 1
#define	P_SUGID		0x000100	/* Had set id privs since last exec. */
d339 1
a339 1
#define	P_SUGIDEXEC	0x040000	/* last execve() was set[ug]id */
d355 2
@


1.132
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.131 2010/07/19 23:00:15 guenther Exp $	*/
d167 1
d286 1
a286 2
	u_char	p_usrpri;	/* User-priority based on p_cpu and p_nice. */
	char	p_nice;		/* Process "nice" value. */
@


1.131
log
@Rollback the allproclk and fileheadlk addition.  When grabbing an
rwlock, the thread will release biglock if it sleeps, means that
atomicity from before the rw_enter() to after it is not guaranteed.
The change didn't address those, so pulling it until it does.

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.130 2010/07/03 04:44:51 guenther Exp $	*/
d44 1
a44 1
#include <sys/selinfo.h>			/* For struct selinfo. */
d46 1
a46 1
#include <sys/timeout.h>		/* For struct timeout. */
d58 1
d61 1
a61 1
	struct	proc *s_leader;		/* Session leader. */
d72 1
a72 1
	LIST_HEAD(, proc) pg_members;	/* Pointer to pgrp members. */
d82 1
d143 1
a143 1
	struct proc *ps_mainproc;
d148 5
d156 1
d165 1
d173 29
a201 3
#else
struct process;
#endif
a227 4
	LIST_ENTRY(proc) p_pglist;	/* List of processes in pgrp. */
	struct	proc *p_pptr;	 	/* Pointer to parent process. */
	LIST_ENTRY(proc) p_sibling;	/* List of sibling processes. */
	LIST_HEAD(, proc) p_children;	/* Pointer to list of children. */
a289 1
	struct 	pgrp *p_pgrp;	/* Pointer to process group. */
a302 3
#define	p_session	p_pgrp->pg_session
#define	p_pgid		p_pgrp->pg_id

d314 5
a318 2
/* These flags are kept in p_flag. */
#define	P_CONTROLT	0x000002	/* Has a controlling terminal. */
d353 4
d403 1
a403 1
#define SESS_LEADER(p)	((p)->p_session->s_leader == (p))
d457 2
a458 1
struct proc *pfind(pid_t);	/* Find process by id. */
d464 4
a467 5
int	enterpgrp(struct proc *p, pid_t pgid, struct pgrp *newpgrp,
	    struct session *newsess);
void	fixjobc(struct proc *p, struct pgrp *pgrp, int entering);
int	inferior(struct proc *, struct proc *);
int	leavepgrp(struct proc *p);
d469 1
a469 1
void	pgdelete(struct pgrp *pgrp);
@


1.130
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.129 2010/06/30 00:40:28 guenther Exp $	*/
a407 1
extern struct rwlock allproclk;		/* also used for zombie list */
@


1.129
log
@Move the plimit and pcred bits in fork1() into process_new() and make
process_new() handle the new struct process like fork1() does struct proc,
with a range of members zeroed and a range copied from the parent process.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.128 2010/06/29 20:25:57 guenther Exp $	*/
d157 1
a157 1
	u_int	ps_rdomain;		/* Process routing domain. */
@


1.128
log
@We always copy struct pcred when creating a new process, so the reference
count was always one.  That's pointless, so remove the member and the code.
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.127 2010/05/18 22:26:10 tedu Exp $	*/
a142 1
	struct	plimit *ps_limit;	/* Process limits. */
a144 1
	int	ps_refcnt;		/* Number of references. */
d146 11
d158 5
a162 1
	struct	klist ps_klist;		/* knotes attached to this process */
@


1.127
log
@move knote list to struct process.  ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.126 2010/04/20 22:05:44 tedu Exp $	*/
a333 1
	int	p_refcnt;		/* Number of references. */
@


1.126
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.125 2010/04/06 22:26:59 tedu Exp $	*/
d149 1
a226 2
	struct	klist p_klist;		/* knotes attached to this process */
					/* pad to 256, avoid shifting eproc. */
@


1.125
log
@move some of proc.h's greatest hits to systm.h, speeding up compiles.
lots of build testing by deraadt, ok/feedback deraadt guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.124 2010/03/24 23:18:17 tedu Exp $	*/
a50 1
#define curproc curcpu()->ci_curproc
a423 1
void	yield(void);
@


1.124
log
@Add a rwlock around the filehead and allproc lists, mainly to protect
list walkers in sysctl that can block.  As a reward, no more vslock.
With some feedback from art, guenther, phessler.  ok guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.123 2010/01/28 19:23:06 guenther Exp $	*/
a431 3
void    wakeup_n(const volatile void *, int);
void    wakeup(const volatile void *);
#define wakeup_one(c) wakeup_n((c), 1)
a451 12

void	sleep_setup(struct sleep_state *, const volatile void *, int,
	    const char *);
void	sleep_setup_timeout(struct sleep_state *, int);
void	sleep_setup_signal(struct sleep_state *, int);
void	sleep_finish(struct sleep_state *, int);
int	sleep_finish_timeout(struct sleep_state *);
int	sleep_finish_signal(struct sleep_state *);
void	sleep_queue_init(void);

int	tsleep(const volatile void *, int, const char *, int);
int	msleep(const volatile void *, struct mutex *, int,  const char*, int);
@


1.123
log
@Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.122 2009/12/23 07:40:31 guenther Exp $	*/
d398 1
@


1.122
log
@The process's rdomain should be, well, per-process and not per-rthread,
so put it in struct process instead of struct proc.  While at it,
move the p_emul member inside struct proc so that it gets copied
automatically instead of requiring manual assignment.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.121 2009/12/20 23:36:04 guenther Exp $	*/
d422 1
a422 1
int	inferior(struct proc *p);
@


1.121
log
@svr4_sys_waitsys() was seemingly implemented by copying sys_wait4()
and hacking on it.  Since then, some of the details of finishing a
wait have changed (p_exitsig handling), so factor out the common
bit into into proc_finish_wait() and have both sys_wait4() and
svr4_sys_waitsys() call that to kill the divergence.

"looks good" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.120 2009/11/27 20:05:50 guenther Exp $	*/
d148 2
a224 1
	struct	emul *p_emul;		/* Emulation information */
d247 1
a259 2

	u_int	p_rdomain;	/* Process routing domain. */
@


1.120
log
@Add setrdomain() and getrdomain() system calls.  Committing now to
catch the libc major bump per request from deraadt@@

Diff by reyk.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.119 2009/06/05 00:30:05 guenther Exp $	*/
d445 1
@


1.119
log
@The names for p_flags bits had fallen out of date
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.118 2009/06/02 23:05:31 guenther Exp $	*/
d258 2
@


1.119.4.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.119 2009/06/05 00:30:05 guenther Exp $	*/
d420 1
a420 1
int	inferior(struct proc *, struct proc *);
@


1.118
log
@Change the wait-channel type to 'const volatile void *', eliminating
the need for casts when calling tsleep(), msleep(), and wakeup().

"I guess so" oga@@  "it's masturbation" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.117 2009/04/17 15:17:27 blambert Exp $	*/
d311 1
a311 1
    ("\20\01ADVLOCK\02CTTY\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
d315 1
a315 1
     "\033THREAD\034IGNEXITRV\035SOFTDEP\036STOPPED")
@


1.117
log
@Remove unused function proc_isunder()

"go for it" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.116 2009/04/14 09:13:25 art Exp $	*/
d197 1
a197 1
	void	*p_wchan;	 /* Sleep address. */
d429 2
a430 2
void    wakeup_n(void *chan, int);
void    wakeup(void *chan);
d452 2
a453 1
void	sleep_setup(struct sleep_state *, void *, int, const char *);
d461 2
a462 2
int	tsleep(void *, int, const char *, int);
int	msleep(void *, struct mutex *, int,  const char*, int);
@


1.116
log
@Some tweaks to the cpu affinity code.
 - Split up choosing of cpu between fork and "normal" cases. Fork is
   very different and should be treated as such.
 - Instead of implicitly choosing a cpu in setrunqueue, do it outside
   where it actually makes sense.
 - Just because a cpu is marked as idle doesn't mean it will be soon.
   There could be a thundering herd effect if we call wakeup from an
   interrupt handler, so subtract cpus with queued processes when
   deciding which cpu is actually idle.
 - some simplifications allowed by the above.

kettenis@@ ok (except one bugfix that was not in the intial diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.115 2009/04/03 09:29:15 art Exp $	*/
a465 2

int proc_isunder(struct proc *, struct proc *);
@


1.115
log
@sched_peg_curproc_to_cpu() - function to force a proc to stay on a cpu
forever.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.114 2009/03/26 17:24:33 oga Exp $	*/
d488 4
a491 1
void cpuset_copy(struct cpuset *to, struct cpuset *from);
@


1.114
log
@Remove cpu_wait(). It's original use was to be called from the reaper so
MD code would free resources that couldn't be freed until we were no
longer running in that processor. However, it's is unused on all
architectures since mikeb@@'s tss changes on x86 earlier in the year.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.113 2009/03/23 13:25:11 art Exp $	*/
d308 1
@


1.113
log
@Processor affinity for processes.
 - Split up run queues so that every cpu has one.
 - Make setrunqueue choose the cpu where we want to make this process
   runnable (this should be refined and less brutal in the future).
 - When choosing the cpu where we want to run, make some kind of educated
   guess where it will be best to run (very naive right now).
Other:
 - Set operations for sets of cpus.
 - load average calculations per cpu.
 - sched_is_idle() -> curcpu_is_idle()

tested, debugged and prodded by many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.112 2009/03/05 19:52:24 kettenis Exp $	*/
a437 3
#if !defined(cpu_wait)
void	cpu_wait(struct proc *);
#endif
@


1.112
log
@Make ELF platforms generate ELF core dumps.  Somewhat based on code from
NetBSD.

ok kurt@@, drahn@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.111 2008/12/16 07:57:28 guenther Exp $	*/
d470 22
@


1.111
log
@Move the functionality of psignal() to a new function ptsignal()
that takes an additional argument "type" that indicates whether the
signal is for the process, just a particular thread, or propagated
to a thread because it's not caught or blocked.  psignal() becomes
a wrapper that does the first of those.

So that sys_kill() can tell apart signals for the process and signals
for the process's original thread, the tid of the original thread
is defined as its pid + THREAD_PID_OFFSET.

ok tedu@@ art@@ andreas@@ kurt@@   "better early than late" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.110 2008/11/07 02:22:33 deraadt Exp $	*/
d103 1
@


1.111.2.1
log
@Merge from -current:

----
Make sure the process tree is is loop-free by forbidding ptrace()
of a direct ancestor, closing a localhost DoS.  As an exception,
do permit ptrace() of pid 1 and have inferiors() stop climbing if
it hits that.

ok tedu@@  hpux_compat suggestion from miod@@
----

Requested by guenther@@. The hpux_compat change here is more
conservative than committed to -current.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.111 2008/12/16 07:57:28 guenther Exp $	*/
d418 1
a418 1
int	inferior(struct proc *, struct proc *);
@


1.110
log
@wrap do/while construct around the function macro SESSRELE(); ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.109 2008/11/01 05:59:20 deraadt Exp $	*/
d353 1
@


1.109
log
@change all callers of enterpgrp() to pre-allocate a pgrp or session if
it might be needed later -- before calling pfind(), so that enterpgrp()
can operate without sleeping
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.108 2008/10/14 18:27:29 guenther Exp $	*/
d356 1
a356 1
#define	SESSRELE(s) {							\
d358 2
a359 2
		pool_put(&session_pool, s);				\
}
@


1.108
log
@Back-in; problems were apparently elsewhere.
Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.  Use the reference count to update the user process
count correctly when changin real uid.

"please re-commit before something else nasty comes in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.107 2008/10/10 14:35:06 deraadt Exp $	*/
d403 1
d414 2
a415 1
int	enterpgrp(struct proc *p, pid_t pgid, int mksess);
@


1.107
log
@backout; is causing some people difficulty
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.105 2008/10/03 04:22:37 guenther Exp $	*/
d146 1
@


1.106
log
@Put a reference count in struct process to prevent use-after-free
if the main thread reaches the reaper ahead of some other thread
in the process.

ok art@@ tedu@@
@
text
@a145 1
	int	ps_refcnt;		/* Number of references. */
@


1.105
log
@Make sigwait() work correctly.  In particular, it'll work when the
signal is already pending in the calling thread or the main thread
and there's no longer a race condition where the signal could be
diverted but sigwait() would still block.  There were some off-by-one
errors too.

(The checking of the main thread's pending list is just until a
pending list for the process can be added to struct process.  For
now, such signals end up as pending on the main thread.)

oks tedu@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.104 2008/09/19 12:24:55 art Exp $	*/
d146 1
@


1.104
log
@Fix a bunch of problems and races with posix file locking.

- file descriptor table becomes the owner of the lock instead of the proc.
- When grabbing the lock, we check if the fd hasn't changed under our
  feet, this is more or less impossible to solve without a hack like
  this. I've banged my head against the wall, I figured out a solution,
  but implementing it correctly would cost me 12 gray hairs. Screw it,
  this is ugly, but it works.
- Wait until usecount drains before releasing the posix lock in closef.
- Add missing FREF/FRELE to sys_flock
- keep the pid in the flock struct instead of abusing the fact that we
  used to use the proc as the lock owner.

Pointed out by and discussed with Al Viro, big thanks.
miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.103 2008/05/05 15:37:41 thib Exp $	*/
d188 1
@


1.103
log
@retire ltsleep(); The only refrence left too it is in an
ifdef netbsd block in drm code, but oga@@ says he'll remove
it soon...

OK art@@, oga@@;
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.102 2007/11/28 20:07:36 oga Exp $	*/
a271 1
#define	P_ADVLOCK	0x000001	/* Proc may hold a POSIX adv. lock. */
@


1.102
log
@Add msleep. This is identical to tsleep but it takes a mutex as a
parameter. The mutex is unlocked just before sleep and relocked after
unless P_NORELOCK is in flags, in which case it is left unlocked.

ok art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.101 2007/10/10 15:53:53 art Exp $	*/
a458 1
#define ltsleep(c, p, w, t, l) tsleep(c, p, w, t)
@


1.101
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.100 2007/07/25 23:11:53 art Exp $	*/
d48 1
d458 1
@


1.100
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.91 2007/03/21 09:09:52 art Exp $	*/
d151 1
a151 2
	struct	proc *p_forw;		/* Doubly-linked run/sleep queue. */
	struct	proc *p_back;
a402 8
#define	NQS	32			/* 32 run queues. */
extern int whichqs;			/* Bit mask summary of non-empty Q's. */
struct	prochd {
	struct	proc *ph_link;		/* Linked list of running processes. */
	struct	proc *ph_rlink;
};
extern struct prochd qs[NQS];

a416 1
void	mi_switch(void);
a418 3
#if !defined(remrunqueue)
void	remrunqueue(struct proc *);
#endif
a420 3
#if !defined(setrunqueue)
void	setrunqueue(struct proc *);
#endif
d428 1
a430 1
void	rqinit(void);
a431 3
#if !defined(cpu_switch)
void	cpu_switch(struct proc *);
#endif
a434 1
void	cpu_exit(struct proc *);
d454 1
@


1.99
log
@remove p_lock from struct proc; unused debug goo for lockmgr,
wich gets set and never checked etc...

ok art@@,tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.98 2007/05/16 17:27:30 art Exp $	*/
a226 2

	TAILQ_HEAD(,selinfo) p_selects;	/* selinfos we're selecting on */
@


1.98
log
@The world of __HAVEs and __HAVE_NOTs is reducing. All architectures
have cpu_info now, so kill the option.

eyeballed by jsg@@ and grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.97 2007/05/08 11:16:31 art Exp $	*/
a256 1
	int	p_locks;       	/* DEBUG: lockmgr count of held locks */
@


1.97
log
@First step in making the SCHED_LOCK not recursive.
 - Defer the sending of SIGCHLD and waking the parent when a process goes
   to sleep. We set a flag in the process "P_STOPPED" and schedule a
   timeout that checks all processes for this flag and sends SIGCHLD
   and wakes the parent on those processes that have this flag set.
 - Delay the waking of the parent in psignal on SIGCONT until we've
   released the SCHED_LOCK at the end.
 - In issignal, check for P_SINTR as a way to see we were called from
   the tsleep path with SCHED_LOCK locked and don't skip locking
   in that case. (This is slightly ugly, but it works until we have
   some better way).

miod@@ ok (after finding and fixing an MD bug on sgi)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.96 2007/04/14 11:06:43 espie Exp $	*/
a49 1
#ifdef __HAVE_CPUINFO
a50 1
#endif
a198 1
#ifdef __HAVE_CPUINFO
a199 3
#else
	int	p_schedflags;	 /* PSCHED_* flags */
#endif
a320 11
#ifndef __HAVE_CPUINFO
/*
 * These flags are kept in p_schedflags.  p_schedflags may be modified
 * only at splstatclock().
 */
#define PSCHED_SEENRR		0x0001	/* process has been in roundrobin() */
#define PSCHED_SHOULDYIELD	0x0002	/* process should yield */

#define PSCHED_SWITCHCLEAR	(PSCHED_SEENRR|PSCHED_SHOULDYIELD)
#endif

a388 3
#if !defined(__HAVE_CPUINFO) && !defined(curproc)
extern struct proc *curproc;		/* Current running proc. */
#endif
@


1.96
log
@hide struct process from userland, allow kvm_proc to see it.
okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.95 2007/04/12 22:14:15 tedu Exp $	*/
d314 1
d321 1
a321 1
     "\033THREAD\034IGNEXITRV\035SOFTDEP")
@


1.95
log
@move p_limit and p_cred into struct process
leave macros behind for now to keep the commit small
ok art beck miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.94 2007/04/04 13:53:26 pedro Exp $	*/
d53 3
d132 1
d148 3
@


1.94
log
@abouse -> abuse
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.93 2007/04/03 08:05:43 art Exp $	*/
d123 1
a123 4
 * with related processes.  The process structure and the substructures
 * are always addressable except for those marked "(PROC ONLY)" below,
 * which might be addressable only on a processor on which the process
 * is running.
d139 2
a153 1
	struct	pcred *p_cred;		/* Process owner's identity. */
d155 1
a155 2
	struct	pstats *p_stats;	/* Accounting/statistics (PROC ONLY). */
	struct	plimit *p_limit;	/* Process limits. */
d157 2
a158 2
	struct	sigacts *p_sigacts;	/* Signal actions, state (PROC ONLY). */

d160 1
a160 1
#define	p_rlimit	p_limit->pl_rlimit
d250 1
a250 1
	struct	user *p_addr;	/* Kernel virtual addr of u-area (PROC ONLY). */
@


1.93
log
@Start moving state that is shared among threads in a process into
a new struct. Instead of doing a huge rename and deal with the fallout
for weeks, like other projects that need no mention, we will slowly and
carefully move things out of struct proc into a new struct process.

 - Create struct process and the infrastructure to create and remove them.
 - Move threads in a process into struct process.

deraadt@@, tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.92 2007/03/24 16:01:22 art Exp $	*/
d137 1
a137 1
	 * we'll have to remember the main threads and abouse its pid as the
@


1.92
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.91 2007/03/21 09:09:52 art Exp $	*/
d120 1
a120 1
 * This structure contains the information needed to manage a thread of
d127 4
d132 15
a146 1
struct	proc {
d151 3
d185 1
a185 6
	/* threads are processes that sometimes use the parent thread's
	 * info for userland visibility */
	struct	proc *p_thrparent;
	LIST_ENTRY(proc) p_thrsib;
	LIST_HEAD(, proc) p_thrchildren;
	long p_thrslpid;	/* for thrsleep syscall */
d415 1
@


1.91
log
@Split tsleep into pieces. Instead of doing everything in a large "shove
everything into it" function, there are now 6 stages of tsleep with
an on-stack (remember that kernel stacks are not swappable now?)
structure that keeps track of the state.

This way we first setup the sleep, setup the events that might break the
sleep, finish the sleep (actually sleeping) and then take care of the
events that could wake us up.

In the future this will make it easier to implement functionality like:
setup sleep, release lock or check some condition, finish sleep, in a
race-free way and without duplicating or complicating the tsleep function
too much.

miod@@, millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.90 2007/02/06 18:42:37 art Exp $	*/
d213 2
@


1.90
log
@Use atomic.h operation for manipulating p_siglist in struct proc. Solves
the problem with lost signals in MP kernels.

miod@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.89 2006/11/29 12:24:18 miod Exp $	*/
a435 3
int	ltsleep(void *chan, int pri, const char *wmesg, int timo,
	    volatile struct simplelock *);
#define tsleep(chan, pri, wmesg, timo) ltsleep(chan, pri, wmesg, timo, NULL)
d459 17
@


1.89
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.88 2006/06/28 14:17:07 mickey Exp $	*/
d48 1
@


1.88
log
@from freebsd 1.179:
When the softupdates worklist gets too long, threads that attempt to
add more work are forced to process two worklist items first.
However, processing an item may generate additional work, causing the
unlucky thread to recursively process the worklist.  Add a per-thread
flag to detect this situation and avoid the recursion.  This should
fix the stack overflows that could occur while removing large
directory trees.

pedro@@ tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.87 2006/06/15 20:08:02 miod Exp $	*/
a204 1
	int	p_holdcnt;		/* If non-zero, don't swap. */
d260 1
a260 1
#define	P_INMEM		0x000004	/* Loaded into memory. */
a286 1
#define P_SWAPIN	0x1000000	/* Swapping in right now */
d293 1
a293 1
    ("\20\01ADVLOCK\02CTTY\03INMEM\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
d296 1
a296 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED\031SWAPIN\032BIGLOCK" \
a355 6
#define	PHOLD(p) {							\
	if ((p)->p_holdcnt++ == 0 && ((p)->p_flag & P_INMEM) == 0)	\
		uvm_swapin(p);						\
}
#define	PRELE(p)	(--(p)->p_holdcnt)

a434 1
void	uvm_swapin(struct proc *);  /* XXX: uvm_extern.h? */
d470 1
@


1.87
log
@Nothing sets P_FSTRACE anymore, so remove all what's left of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.86 2006/05/29 20:42:53 miod Exp $	*/
d292 1
d299 1
a299 1
     "\033THREAD\034IGNEXITRV")
@


1.86
log
@Sync P_BITS with rthread p_flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.85 2006/04/28 08:34:31 pedro Exp $	*/
a279 1
#define	P_FSTRACE	0x010000	/* tracing via fs (elsewhere?) */
d296 1
a296 1
     "\017EXEC\020PWEUPC\021FSTRACE\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
d302 1
a302 1
    (((p)->p_flag & (P_TRACED | P_FSTRACE)) ? SIGCHLD : (p)->p_exitsig)
@


1.85
log
@Instrumentation for an in-kernel getcwd() implementation.
Not yet activated. Diff by marius@@ long ago, from NetBSD.
Okay miod@@ and krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.84 2005/12/22 06:55:03 tedu Exp $	*/
d298 2
a299 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED\031SWAPIN\032BIGLOCK")
@


1.84
log
@fix memory leak conditions in thrsleep and significantly simplify
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.83 2005/12/07 19:04:50 deraadt Exp $	*/
d473 3
@


1.83
log
@do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname; ok tedu pedro millert
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.82 2005/12/03 18:09:09 tedu Exp $	*/
a115 5
struct	twaitnode {
	long t_ident;
	LIST_ENTRY(twaitnode) t_next;
};

d168 1
a168 1
	LIST_HEAD(, twaitnode) p_sleepers;
@


1.82
log
@kernel support for threaded processes (rthreads).
uses rfork(RFTHREAD) to create threads, which are presently processes
that are a little more tightly bound together.  several new syscalls
added to facilitate a userland thread library.
all conditional on RTHREADS, currently disabled.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.81 2005/11/21 18:16:46 millert Exp $	*/
d152 2
a153 1
	char	p_pad1[2];
@


1.81
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.80 2005/09/14 20:55:59 kettenis Exp $	*/
d116 5
d167 8
d216 1
d295 2
d380 4
d455 1
a455 1
void	exit1(struct proc *, int);
@


1.80
log
@ptrace(2) following fork(2)
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.79 2005/05/29 03:20:42 deraadt Exp $	*/
d44 1
a44 1
#include <sys/select.h>			/* For struct selinfo. */
@


1.79
log
@sched work by niklas and art backed out; causes panics
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.77 2005/03/10 17:26:10 tedu Exp $	*/
d189 3
d363 1
@


1.79.2.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.79 2005/05/29 03:20:42 deraadt Exp $	*/
d147 1
a147 2
	char	p_pad1[1];
	u_char	p_descfd;		/* if not 255, fdesc permits this fd */
@


1.78
log
@This patch is mortly art's work and was done *a year* ago.  Art wants to thank
everyone for the prompt review and ok of this work ;-)  Yeah, that includes me
too, or maybe especially me.  I am sorry.

Change the sched_lock to a mutex. This fixes, among other things, the infamous
"telnet localhost &" problem.  The real bug in that case was that the sched_lock
which is by design a non-recursive lock, was recursively acquired, and not
enough releases made us hold the lock in the idle loop, blocking scheduling
on the other processors.  Some of the other processors would hold the biglock though,
which made it impossible for cpu 0 to enter the kernel...  A nice deadlock.
Let me just say debugging this for days just to realize that it was all fixed
in an old diff noone ever ok'd was somewhat of an anti-climax.

This diff also changes splsched to be correct for all our architectures.
@
text
@d411 1
a411 1
void	mi_switch(int);
a426 2
void	sched_wakeup_n(void *, int);
#define sched_wakeup(c) sched_wakeup_n((c), -1)
@


1.77
log
@split out uidinfo from kern_proc.c private, use it to store lock count,
restrict lock count per uid to a global limit, add sysctl to adjust limit.
this prevents a user from creating too many locks.  problem noticed
by devon o'dell.  ok deraadt miod pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.76 2004/11/23 19:08:55 miod Exp $	*/
d411 1
a411 1
void	mi_switch(void);
d427 2
@


1.77.2.1
log
@MFC:
Fix by deraadt@@

do not allow setugid processes to use /dev/fd/#, unless they are a
setuid-script and are attempting to dup is the specific setuid-script
fd via such a pathname;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.77 2005/03/10 17:26:10 tedu Exp $	*/
d147 1
a147 2
	char	p_pad1[1];
	u_char	p_descfd;		/* if not 255, fdesc permits this fd */
@


1.76
log
@Create the init process earlier, before the root filesystem is mounted,
and have it stall on a semaphore. This allows all kthread creations which
could have been requested during autoconf to be processed before root
is mounted as well.

This causes umass devices attached to any usb with flags 1 (such as on macppc)
to configure properly instead of panicing the kernel at mountroot time.

From NetBSD; tested by various.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.75 2004/07/22 15:42:11 art Exp $	*/
d317 10
@


1.75
log
@SIMPLELOCK -> mutex for the lock around deadproc list.
Also move the whole deadproc infrastructure to kern_exit, it's only used
there.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.74 2004/06/21 23:12:14 art Exp $	*/
d424 1
a424 1
	    void *, register_t *);
@


1.74
log
@Put back the moving of schedstate_percpu into sched.h. This time expose
it to userland so that i386 builds (other architectures didn't show the
problem).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.73 2004/06/20 08:25:30 deraadt Exp $	*/
a368 2

extern struct proclist deadproc;	/* List of dead processes. */
@


1.73
log
@nope, tree breakage in libpthread.  too tough to run a make build?
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.71 2004/06/13 21:49:28 niklas Exp $	*/
a48 31
/*
 * CPU states.
 * XXX Not really scheduler state, but no other good place to put
 * it right now, and it really is per-CPU.
 */
#define CP_USER		0
#define CP_NICE		1
#define CP_SYS		2
#define CP_INTR		3
#define CP_IDLE		4
#define CPUSTATES	5

/*
 * Per-CPU scheduler state.
 */
struct schedstate_percpu {
	struct timeval spc_runtime;	/* time curproc started running */
	__volatile int spc_schedflags;	/* flags; see below */
	u_int spc_schedticks;		/* ticks for schedclock() */
	u_int64_t spc_cp_time[CPUSTATES]; /* CPU state statistics */
	u_char spc_curpriority;		/* usrpri of curproc */
	int spc_rrticks;		/* ticks until roundrobin() */
	int spc_pscnt;			/* prof/stat counter */
	int spc_psdiv;			/* prof/stat divisor */	
};

/* spc_flags */
#define SPCF_SEENRR             0x0001  /* process has seen roundrobin() */
#define SPCF_SHOULDYIELD        0x0002  /* process should yield the CPU */
#define SPCF_SWITCHCLEAR        (SPCF_SEENRR|SPCF_SHOULDYIELD)

a49 8
/*
 * These are the fields we require in struct cpu_info that we get from
 * curcpu():
 *
 * struct proc *ci_curproc;
 * struct schedstate_percpu ci_schedstate;
 * cpuid_t ci_cpuid;
 */
@


1.72
log
@Move schedstate_percpu into sched.h so that we don't have to include
proc.h in cpu.h on __HAVE_CPU_INFO architectures. cpu.h is usually included
in param.h.

This also removes the horrible kludge with ifdef SYS_PROC_H in sched.h
by simply converting the inline functions into macros.

With a few suggestions from nordin@@

deraadt@@ ok
@
text
@d49 31
d81 8
@


1.71
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 31
/*
 * CPU states.
 * XXX Not really scheduler state, but no other good place to put
 * it right now, and it really is per-CPU.
 */
#define CP_USER		0
#define CP_NICE		1
#define CP_SYS		2
#define CP_INTR		3
#define CP_IDLE		4
#define CPUSTATES	5

/*
 * Per-CPU scheduler state.
 */
struct schedstate_percpu {
	struct timeval spc_runtime;	/* time curproc started running */
	__volatile int spc_schedflags;	/* flags; see below */
	u_int spc_schedticks;		/* ticks for schedclock() */
	u_int64_t spc_cp_time[CPUSTATES]; /* CPU state statistics */
	u_char spc_curpriority;		/* usrpri of curproc */
	int spc_rrticks;		/* ticks until roundrobin() */
	int spc_pscnt;			/* prof/stat counter */
	int spc_psdiv;			/* prof/stat divisor */	
};

/* spc_flags */
#define SPCF_SEENRR             0x0001  /* process has seen roundrobin() */
#define SPCF_SHOULDYIELD        0x0002  /* process should yield the CPU */
#define SPCF_SWITCHCLEAR        (SPCF_SEENRR|SPCF_SHOULDYIELD)

a49 8
/*
 * These are the fields we require in struct cpu_info that we get from
 * curcpu():
 *
 * struct proc *ci_curproc;
 * struct schedstate_percpu ci_schedstate;
 * cpuid_t ci_cpuid;
 */
@


1.70
log
@Merge in a piece of the SMP branch into HEAD.

Introduce the cpu_info structure, p_cpu field in struct proc and global
scheduling context and various changed code to deal with this. At the
moment no architecture uses this stuff yet, but it will allow us slow and
controlled migration to the new APIs.

All new code is ifdef:ed out.

ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.69 2004/04/02 19:08:58 tedu Exp $	*/
a48 1
#ifdef __HAVE_CPUINFO
d62 1
a62 1
 * Per-CPU scheduler state. XXX - this should be in sys/sched.h
d69 1
a69 1
	u_char spc_curpriority;         /* usrpri of curproc */
d72 1
a72 1
	int spc_psdiv;			/* prof/stat divisor */ 
d76 3
a78 3
#define SPCF_SEENRR		0x0001	/* process has seen roundrobin() */
#define SPCF_SHOULDYIELD	0x0002	/* process should yield the CPU */
#define SPCF_SWITCHCLEAR	(SPCF_SEENRR|SPCF_SHOULDYIELD)
d80 1
d211 1
a211 1
	struct cpu_info * __volatile p_cpu;
d267 1
d280 1
d316 1
d322 1
a322 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED")
a409 1
extern struct simplelock deadproc_slock;
a452 1
void	sleep(void *chan, int pri);
d480 4
@


1.69
log
@rfork(RFMEM) shares complete vmspace.  much more useful, and in line with
other projects' implementations.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.68 2003/11/08 06:11:11 nordin Exp $	*/
d49 43
d210 3
d214 1
d325 1
d334 1
d395 1
a395 1
#ifndef curproc
@


1.68
log
@Avoid a race condition while swapping in a process.
Tested by mickey@@, henning@@, ericj@@, and beck@@.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.67 2003/08/21 18:56:07 tedu Exp $	*/
a335 1
#define FORK_VMNOSTACK	0x00000100
@


1.67
log
@emulation is now controlled by sysctl.  changes:
add e_flags to struct emul.  this stores on/off and native flags.
check for emul enabled in check_exec().  gather all the emuls into a
emulsw so a sysctl can find them.  create sysctl.  move maxhdrsiz calcualation
into init_main so it cleans up sys_execve codepath.  teach sysctl utility
to grok kern.emul hierarchy.
requested and ok deraadt@@  some comments from mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.66 2003/08/03 19:25:49 millert Exp $	*/
d266 1
@


1.66
log
@Implement the WCONTINUED flag to the wait(2) family of syscalls and the
associated WIFCONTINUED macro as per 1003.1-2001.  Adapted from FreeBSD.
A minor amount of trickiness is involved here.  The value for WCONTINUED
is chosen in such a way that _WSTATUS(_WCONTINUED) == _WSTOPPED and the
WIFSTOPPED macro has been modified such that WIFSTOPPED(_WCONTINUED) !=
_WSTOPPED.  This means we don't need to add an extra check to the
WIFSIGNALED and WIFSTOPPED macros.  deraadt@@ OK.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.65 2003/06/21 00:42:58 tedu Exp $	*/
d98 1
d105 6
@


1.65
log
@add exec/fork/exit hooks per process for compat emulations.
use them to correctly emulate linux brk.
update to TNF copyright in linux_exec.c.

from netbsd, mostly from a diff by Kurt Miller in pr3318.
this should fix java.  no regressions in testing by kurt and sturm@@.
be prepared for "proc size mismatch" -- recompile ps and friends.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.64 2003/06/02 23:28:21 millert Exp $	*/
d258 1
d264 1
a264 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE")
@


1.64
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.63 2003/05/12 19:56:03 mickey Exp $	*/
d99 4
d180 2
a181 1

@


1.63
log
@sho proc [addr] to print some proc's field; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.62 2002/07/20 19:24:57 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.62
log
@Instead of copying out the signal trampoline on top of the stack, create
an uvm aobj, copy out the signal trampoline into it and share that page
among all processes for the same emulation.

This also requires us to actually be able to tell signal code where the
trampoline is located, so introduce a new field in struct proc - p_sigcode
that is a pointer to sigcode. This allows us to remove all the ugly
calculations of the signal trampoline address done in every sendsig
function in the tree (that's why so many files are changed).

Tested by various people. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.61 2002/07/03 21:19:08 miod Exp $	*/
d258 6
d372 2
@


1.61
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.60 2002/05/16 16:16:52 provos Exp $	*/
d80 1
d102 1
d201 1
@


1.60
log
@systrace facility, used to enforce and generate policies for system calls
okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.59 2002/03/18 07:48:11 hugh Exp $	*/
d352 1
a352 1
int	whichqs;			/* Bit mask summary of non-empty Q's. */
d356 2
a357 1
} qs[NQS];
@


1.59
log
@These are macro inlines on vax, so check if they're defined before
trying to prototype them. millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.58 2002/03/14 03:16:12 millert Exp $	*/
d170 2
d253 1
@


1.58
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.57 2002/03/14 01:27:14 millert Exp $	*/
d370 1
d372 1
d375 1
d377 1
d394 1
d396 1
@


1.57
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.56 2002/02/16 18:06:39 millert Exp $	*/
d386 2
a387 2
int	fork1 __P((struct proc *, int, int, void *, size_t, void (*)(void *),
	    void *, register_t *));
@


1.56
log
@Don't prototype functions if they are really just macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.55 2002/01/31 02:12:18 weingart Exp $	*/
d86 1
a86 1
	void	(*e_sendsig) __P((sig_t, int, int, u_long, int, union sigval));
d93 2
a94 2
	void	*(*e_copyargs) __P((struct exec_package *, struct ps_strings *,
				    void *, void *));
d96 3
a98 3
	void	(*e_setregs) __P((struct proc *, struct exec_package *,
				  u_long, register_t *));
	int	(*e_fixup) __P((struct proc *, struct exec_package *));
d357 2
a358 2
struct proc *pfind __P((pid_t));	/* Find process by id. */
struct pgrp *pgfind __P((pid_t));	/* Find process group by id. */
d360 18
a377 18
int	chgproccnt __P((uid_t uid, int diff));
int	enterpgrp __P((struct proc *p, pid_t pgid, int mksess));
void	fixjobc __P((struct proc *p, struct pgrp *pgrp, int entering));
int	inferior __P((struct proc *p));
int	leavepgrp __P((struct proc *p));
void	yield __P((void));
void	preempt __P((struct proc *));
void	mi_switch __P((void));
void	pgdelete __P((struct pgrp *pgrp));
void	procinit __P((void));
void	remrunqueue __P((struct proc *));
void	resetpriority __P((struct proc *));
void	setrunnable __P((struct proc *));
void	setrunqueue __P((struct proc *));
void	sleep __P((void *chan, int pri));
void	uvm_swapin __P((struct proc *));  /* XXX: uvm_extern.h? */
int	ltsleep __P((void *chan, int pri, const char *wmesg, int timo,
	    volatile struct simplelock *));
d379 3
a381 3
void	unsleep __P((struct proc *));
void    wakeup_n __P((void *chan, int));
void    wakeup __P((void *chan));
d383 3
a385 3
void	reaper __P((void));
void	exit1 __P((struct proc *, int));
void	exit2 __P((struct proc *));
d388 3
a390 3
void	rqinit __P((void));
int	groupmember __P((gid_t, struct ucred *));
void	cpu_switch __P((struct proc *));
d392 1
a392 1
void	cpu_wait __P((struct proc *));
d394 1
a394 1
void	cpu_exit __P((struct proc *));
d396 1
a396 1
void	child_return __P((void *));
d398 2
a399 2
int	proc_cansugid __P((struct proc *));
void	proc_zap __P((struct proc *));
@


1.55
log
@Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.54 2002/01/25 15:00:26 art Exp $	*/
d391 1
d393 1
@


1.54
log
@poolify pcreds.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.53 2002/01/23 15:46:48 art Exp $	*/
d236 1
@


1.53
log
@Allocate rusage, pgrp, ucred and session with pool.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.52 2002/01/20 11:27:52 art Exp $	*/
d345 1
@


1.52
log
@When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.51 2001/12/01 23:42:22 deraadt Exp $	*/
d293 1
a293 1
		FREE(s, M_SESSION);					\
d342 3
@


1.51
log
@spelling; krapht@@secureops.com
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.50 2001/11/11 22:30:56 art Exp $	*/
d249 1
@


1.51.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.55 2002/01/31 02:12:18 weingart Exp $	*/
a235 1
/* XXX - Should be merged with INEXEC */
a248 1
#define P_INEXEC	0x200000	/* Process is doing an exec right now */
d292 1
a292 1
		pool_put(&session_pool, s);				\
a340 4
extern struct pool rusage_pool;		/* memory pool for zombies */
extern struct pool ucred_pool;		/* memory pool for ucreds */
extern struct pool session_pool;	/* memory pool for sessions */
extern struct pool pcred_pool;		/* memory pool for pcreds */
@


1.51.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.51.2.1 2002/01/31 22:55:49 niklas Exp $	*/
d86 1
a86 1
	void	(*e_sendsig)(sig_t, int, int, u_long, int, union sigval);
d93 2
a94 2
	void	*(*e_copyargs)(struct exec_package *, struct ps_strings *,
				    void *, void *);
d96 3
a98 3
	void	(*e_setregs)(struct proc *, struct exec_package *,
				  u_long, register_t *);
	int	(*e_fixup)(struct proc *, struct exec_package *);
a169 2
	void	*p_systrace;		/* Back pointer to systrace */

a250 1
#define P_SYSTRACE	0x400000	/* Process system call tracing active*/
d357 2
a358 2
struct proc *pfind(pid_t);	/* Find process by id. */
struct pgrp *pgfind(pid_t);	/* Find process group by id. */
d360 18
a377 22
int	chgproccnt(uid_t uid, int diff);
int	enterpgrp(struct proc *p, pid_t pgid, int mksess);
void	fixjobc(struct proc *p, struct pgrp *pgrp, int entering);
int	inferior(struct proc *p);
int	leavepgrp(struct proc *p);
void	yield(void);
void	preempt(struct proc *);
void	mi_switch(void);
void	pgdelete(struct pgrp *pgrp);
void	procinit(void);
#if !defined(remrunqueue)
void	remrunqueue(struct proc *);
#endif
void	resetpriority(struct proc *);
void	setrunnable(struct proc *);
#if !defined(setrunqueue)
void	setrunqueue(struct proc *);
#endif
void	sleep(void *chan, int pri);
void	uvm_swapin(struct proc *);  /* XXX: uvm_extern.h? */
int	ltsleep(void *chan, int pri, const char *wmesg, int timo,
	    volatile struct simplelock *);
d379 3
a381 3
void	unsleep(struct proc *);
void    wakeup_n(void *chan, int);
void    wakeup(void *chan);
d383 10
a392 14
void	reaper(void);
void	exit1(struct proc *, int);
void	exit2(struct proc *);
int	fork1(struct proc *, int, int, void *, size_t, void (*)(void *),
	    void *, register_t *);
void	rqinit(void);
int	groupmember(gid_t, struct ucred *);
#if !defined(cpu_switch)
void	cpu_switch(struct proc *);
#endif
#if !defined(cpu_wait)
void	cpu_wait(struct proc *);
#endif
void	cpu_exit(struct proc *);
d394 1
a394 1
void	child_return(void *);
d396 2
a397 2
int	proc_cansugid(struct proc *);
void	proc_zap(struct proc *);
@


1.51.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.51.2.2 2002/06/11 03:32:33 art Exp $	*/
a79 1
struct uvm_object;
a100 1
	struct uvm_object *e_sigobject;	/* shared sigcode object */
a198 1
	vaddr_t	p_sigcode;	/* user pointer to the signal code. */
d352 1
a352 1
extern int whichqs;			/* Bit mask summary of non-empty Q's. */
d356 1
a356 2
};
extern struct prochd qs[NQS];
@


1.51.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a257 6
#define	P_BITS \
    ("\20\01ADVLOCK\02CTTY\03INMEM\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
     "\010SINTR\011SUGID\012SYSTEM\013TIMEOUT\014TRACED\015WAITED\016WEXIT" \
     "\017EXEC\020PWEUPC\021FSTRACE\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
     "\025NOZOMBIE\026INEXEC\027SYSTRACE")

a365 2
void	proc_printit(struct proc *p, const char *modif,
    int (*pr)(const char *, ...));
@


1.50
log
@Let ltsleep take a const wmesg.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.49 2001/11/06 18:41:10 art Exp $	*/
d110 2
a111 2
 * are always addressible except for those marked "(PROC ONLY)" below,
 * which might be addressible only on a processor on which the process
@


1.49
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.48 2001/08/22 10:29:42 niklas Exp $	*/
d155 1
a155 1
	char	*p_wmesg;	 /* Reason for sleep. */
d370 1
a370 1
int	ltsleep __P((void *chan, int pri, char *wmesg, int timo,
@


1.48
log
@Consolidate svr4_waitsys with our wait4.  Fixes gdt_get_slot panic, due to a double
cpu_wait invocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.47 2001/08/07 22:57:15 art Exp $	*/
d380 2
a381 1
int	fork1 __P((struct proc *, int, int, void *, size_t, register_t *));
d387 2
@


1.48.2.1
log
@Pull in patch from current:
Errata 012:
A race condition between the ptrace(2) and execve(2) system
calls allows an attacker to modify the memory contents of
suid/sgid processes which could lead to compromise of the
super-user account.
Fix (art):
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.48 2001/08/22 10:29:42 niklas Exp $	*/
a248 1
#define P_INEXEC	0x200000	/* Process is doing an exec right now */
@


1.48.2.2
log
@Pull in patch from current:
Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.48.2.1 2002/01/23 03:10:01 jason Exp $	*/
a235 1
/* XXX - Should be merged with INEXEC */
@


1.47
log
@Change tsleep into ltsleep.
ltsleep takes an additional argument - a simplelock and unlocks it when it's
safe to do so.

tsleep now becomes a wrapper around ltsleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.46 2001/08/02 11:06:38 art Exp $	*/
d388 1
@


1.46
log
@Sysctl for finding out how many pages there are in kmem_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.45 2001/07/05 07:31:03 art Exp $	*/
d349 2
d370 3
a372 1
int	tsleep __P((void *chan, int pri, char *wmesg, int timo));
@


1.45
log
@p_thread is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.44 2001/06/27 04:51:48 art Exp $	*/
a376 1
void	kmeminit __P((void));
@


1.44
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.43 2001/06/22 23:55:22 art Exp $	*/
d199 1
a199 1
#define	p_endcopy	p_thread
a200 1
	void	*p_thread;	/* Id for this "thread"; Mach glue. XXX */
@


1.43
log
@Try again. (this time it's tested).
Add proc_cansugid that checks if a process may raise it's privileges.
Rework exec to remove the old sugid workaround and check proc_cansugid
just before raising privileges.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.41 2001/06/18 13:18:36 art Exp $	*/
a295 1
#if defined(UVM)
a299 6
#else
#define	PHOLD(p) {							\
	if ((p)->p_holdcnt++ == 0 && ((p)->p_flag & P_INMEM) == 0)	\
		swapin(p);						\
}
#endif
a367 1
#if defined(UVM)
a368 3
#else
void	swapin __P((struct proc *));
#endif
@


1.42
log
@no way, you are on drugs.  last commit revoked because it broke setuid majorly
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.40 2001/04/02 21:43:12 niklas Exp $	*/
d395 2
@


1.41
log
@Add proc_cansugid used to check if a process should be allowed
to raise its privileges in exec.
@
text
@a394 2

int	proc_cansugid __P((struct proc *));
@


1.40
log
@On popular demand, the Linux-compatibility clone(2) implementation based
on NetBSD's code, as well as some faked Posix RT extensions by me.  This makes
at least simple linuxthreads tests work.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.39 2001/03/25 18:09:18 csapuntz Exp $	*/
d395 2
@


1.40.2.1
log
@MFC, requested by art@@ some time ago:
When a process is exec:ing mark it with a flag. Check that flag in ptrace
and procfs (and possibly more places in the future) and simply refuse to
fiddle with the execing process. This is an ugly hack, but this far we
haven't been successful in creating a race-free exec.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.40 2001/04/02 21:43:12 niklas Exp $	*/
a249 1
#define P_INEXEC	0x200000	/* Process is doing an exec right now */
@


1.40.2.2
log
@MFC, requested by weingart@@

Ignore signals if/when we are exiting.
Prevents a hang in the NFS code when
dumping core and pressing ^C, etc.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.40.2.1 2002/02/20 08:52:38 miod Exp $	*/
a236 1
/* XXX - Should be merged with INEXEC */
@


1.39
log
@

Reintroduce wakeup call
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.38 2001/03/23 18:42:06 art Exp $	*/
d251 4
d321 1
d388 1
a388 1
int	fork1 __P((struct proc *, int, void *, size_t, register_t *));
@


1.38
log
@Use pool to allocate processes.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.37 2001/03/03 11:50:56 art Exp $	*/
d378 1
a378 1
#define wakeup(c)  wakeup_n((c), -1)
@


1.37
log
@extern initproc.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.36 2001/03/03 11:46:48 art Exp $	*/
d342 2
@


1.36
log
@export the syncerproc variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.35 2001/02/27 09:07:54 csapuntz Exp $	*/
d340 1
a340 1
struct proc *initproc;			/* Process slots for init, pager. */
@


1.35
log
@

Add wakeup_n and wakeup_one. wakeup_n will wakeup up to n sleeping processes
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.34 2000/11/16 20:02:20 provos Exp $	*/
d341 1
@


1.34
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.33 2000/11/08 05:38:47 art Exp $	*/
d374 3
a376 1
void	wakeup __P((void *chan));
@


1.33
log
@If MD code has defined curproc, don't do it here.
This is not a perfect solution.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.32 2000/07/07 15:57:01 art Exp $	*/
d51 1
d177 2
a178 1
	long	p_spare[1];		/* pad to 256, avoid shifting eproc. */
@


1.32
log
@The rfork sharing of vmspace is .. special and was broken with UVM.
Add a new flag to fork1 - FORK_VMNOSTACK that shares all of the vmspace
except the stack and use it for rfork.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.31 2000/06/05 11:02:48 art Exp $	*/
d324 1
d326 1
@


1.31
log
@Changes to exit handling.

cpu_exit no longer frees the vmspace and u-area. This is now handled by a
separate kernel thread "reaper". This is to avoid sleeping locks in the
critical path of cpu_exit where we're not allowed to sleep.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.30 2000/04/19 09:58:19 art Exp $	*/
d314 1
@


1.30
log
@Remove the roundrobin_attempts hack and replace it with per-process scheduling
flags (much nicer for future smp work).
Add two generic functions yield() and preempt(). Use preepmt() in uio when
we are told to yield.
Based on my idea, code written by Jason Thorpe from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.29 2000/03/23 14:43:47 art Exp $	*/
d217 3
d331 4
d370 1
d372 1
@


1.29
log
@Changes to use the new timeout interface.
For tsleep we add a field "p_sleep_to", for ITIMER_REAL we add "p_realit_to".
I also sneak in a change for niklas for linux compat, so that we can
handle all questions about broken "ps", etc. at the same time.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28 2000/01/31 19:57:20 deraadt Exp $	*/
d157 1
d247 9
d345 2
@


1.28
log
@re-add fixed vfork code from art
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.26 2000/01/28 19:45:03 art Exp $	*/
d50 1
d129 1
d153 1
d159 1
@


1.28.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 1
#include <sys/timeout.h>		/* For struct timeout. */
a127 1
	int	p_exitsig;		/* Signal to send to parent on exit. */
a150 1
	struct	timeout p_sleep_to;/* timeout for tsleep() */
a155 1
	struct	timeout p_realit_to;	/* Alarm timeout. */
@


1.28.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.40 2001/04/02 21:43:12 niklas Exp $	*/
a50 1
#include <sys/event.h>			/* For struct klist */
a156 1
	int	p_schedflags;	 /* PSCHED_* flags */
d175 1
a175 2
	struct	klist p_klist;		/* knotes attached to this process */
					/* pad to 256, avoid shifting eproc. */
a215 3
#define SDEAD	6		/* Process is almost a zombie. */

#define P_ZOMBIE(p)	((p)->p_stat == SZOMB || (p)->p_stat == SDEAD)
a244 13
/* Macro to compute the exit signal to be delivered. */
#define P_EXITSIG(p) \
    (((p)->p_flag & (P_TRACED | P_FSTRACE)) ? SIGCHLD : (p)->p_exitsig)

/*
 * These flags are kept in p_schedflags.  p_schedflags may be modified
 * only at splstatclock().
 */
#define PSCHED_SEENRR		0x0001	/* process has been in roundrobin() */
#define PSCHED_SHOULDYIELD	0x0002	/* process should yield */

#define PSCHED_SWITCHCLEAR	(PSCHED_SEENRR|PSCHED_SHOULDYIELD)

a300 2
#define FORK_VMNOSTACK	0x00000100
#define FORK_SIGHAND	0x00000200
a309 1
#ifndef curproc
a310 1
#endif
d318 1
a318 8

extern struct proclist deadproc;	/* List of dead processes. */
extern struct simplelock deadproc_slock;

extern struct proc *initproc;		/* Process slots for init, pager. */
extern struct proc *syncerproc;		/* filesystem syncer daemon */

extern struct pool proc_pool;		/* memory pool for procs */
a334 2
void	yield __P((void));
void	preempt __P((struct proc *));
d350 1
a350 4
void    wakeup_n __P((void *chan, int));
void    wakeup __P((void *chan));
#define wakeup_one(c) wakeup_n((c), 1)
void	reaper __P((void));
d352 1
a352 2
void	exit2 __P((struct proc *));
int	fork1 __P((struct proc *, int, int, void *, size_t, register_t *));
@


1.28.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.2 2001/05/14 22:45:03 niklas Exp $	*/
d296 1
d301 6
d375 1
d377 3
a394 2

int	proc_cansugid __P((struct proc *));
@


1.28.2.4
log
@Initial import of some SMP code from NetBSD.
Not really working here yet, but there is some work in progress.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.3 2001/07/04 11:00:27 niklas Exp $	*/
a207 1
	struct	cpu_info * __volatile p_cpu; /* CPU we're running on. */
@


1.28.2.5
log
@curproc is per-cpu in MULTIPROCESSOR
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a325 3
#if defined(MULTIPROCESSOR)
#define	curproc	curcpu()->ci_curproc	/* Current running proc. */
#else
a326 1
#endif /* MULTIPROCESSOR */
@


1.28.2.6
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.5 2001/10/27 09:47:29 niklas Exp $	*/
d199 1
a199 1
#define	p_endcopy	p_addr
d201 1
a354 2
struct simplelock;

d374 1
a374 3
int	ltsleep __P((void *chan, int pri, char *wmesg, int timo,
	    volatile struct simplelock *));
#define tsleep(chan, pri, wmesg, timo) ltsleep(chan, pri, wmesg, timo, NULL)
d383 1
a390 1
void	proc_zap __P((struct proc *));
@


1.28.2.7
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d155 1
a155 1
	const char *p_wmesg;	 /* Reason for sleep. */
d375 1
a375 1
int	ltsleep __P((void *chan, int pri, const char *wmesg, int timo,
d385 1
a385 2
int	fork1 __P((struct proc *, int, int, void *, size_t, void (*)(void *),
	    void *, register_t *));
a390 2

void	child_return __P((void *));
@


1.28.2.8
log
@Merge in -current
@
text
@d110 2
a111 2
 * are always addressable except for those marked "(PROC ONLY)" below,
 * which might be addressable only on a processor on which the process
@


1.28.2.9
log
@Merge in trunk
@
text
@a236 1
/* XXX - Should be merged with INEXEC */
a249 1
#define P_INEXEC	0x200000	/* Process is doing an exec right now */
d293 1
a293 1
		pool_put(&session_pool, s);				\
a345 4
extern struct pool rusage_pool;		/* memory pool for zombies */
extern struct pool ucred_pool;		/* memory pool for ucreds */
extern struct pool session_pool;	/* memory pool for sessions */
extern struct pool pcred_pool;		/* memory pool for pcreds */
a389 1
#if !defined(cpu_wait)
a390 1
#endif
@


1.28.2.10
log
@Merge in -current from roughly a week ago
@
text
@d86 1
a86 1
	void	(*e_sendsig)(sig_t, int, int, u_long, int, union sigval);
d93 2
a94 2
	void	*(*e_copyargs)(struct exec_package *, struct ps_strings *,
				    void *, void *);
d96 3
a98 3
	void	(*e_setregs)(struct proc *, struct exec_package *,
				  u_long, register_t *);
	int	(*e_fixup)(struct proc *, struct exec_package *);
d362 2
a363 2
struct proc *pfind(pid_t);	/* Find process by id. */
struct pgrp *pgfind(pid_t);	/* Find process group by id. */
d365 18
a382 22
int	chgproccnt(uid_t uid, int diff);
int	enterpgrp(struct proc *p, pid_t pgid, int mksess);
void	fixjobc(struct proc *p, struct pgrp *pgrp, int entering);
int	inferior(struct proc *p);
int	leavepgrp(struct proc *p);
void	yield(void);
void	preempt(struct proc *);
void	mi_switch(void);
void	pgdelete(struct pgrp *pgrp);
void	procinit(void);
#if !defined(remrunqueue)
void	remrunqueue(struct proc *);
#endif
void	resetpriority(struct proc *);
void	setrunnable(struct proc *);
#if !defined(setrunqueue)
void	setrunqueue(struct proc *);
#endif
void	sleep(void *chan, int pri);
void	uvm_swapin(struct proc *);  /* XXX: uvm_extern.h? */
int	ltsleep(void *chan, int pri, const char *wmesg, int timo,
	    volatile struct simplelock *);
d384 3
a386 3
void	unsleep(struct proc *);
void    wakeup_n(void *chan, int);
void    wakeup(void *chan);
d388 8
a395 10
void	reaper(void);
void	exit1(struct proc *, int);
void	exit2(struct proc *);
int	fork1(struct proc *, int, int, void *, size_t, void (*)(void *),
	    void *, register_t *);
void	rqinit(void);
int	groupmember(gid_t, struct ucred *);
#if !defined(cpu_switch)
void	cpu_switch(struct proc *);
#endif
d397 1
a397 1
void	cpu_wait(struct proc *);
d399 1
a399 1
void	cpu_exit(struct proc *);
d401 1
a401 1
void	child_return(void *);
d403 2
a404 2
int	proc_cansugid(struct proc *);
void	proc_zap(struct proc *);
@


1.28.2.11
log
@Sync the SMP branch with 3.3
@
text
@a79 1
struct uvm_object;
a100 1
	struct uvm_object *e_sigobject;	/* shared sigcode object */
a169 2
	void	*p_systrace;		/* Back pointer to systrace */

a196 1
	vaddr_t	p_sigcode;	/* user pointer to the signal code. */
a251 1
#define P_SYSTRACE	0x400000	/* Process system call tracing active*/
d354 1
a354 1
extern int whichqs;			/* Bit mask summary of non-empty Q's. */
d358 1
a358 2
};
extern struct prochd qs[NQS];
@


1.28.2.12
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.11 2003/03/28 00:41:30 niklas Exp $	*/
a224 1
#define	SONPROC	7		/* Process is currently on a CPU. */
a257 1
#define P_BIGLOCK	0x800000	/* Process needs kernel "big lock" to run */
a417 4

#if defined(MULTIPROCESSOR)
void	proc_trampoline_mp(void);	/* XXX */
#endif
@


1.28.2.13
log
@Forgotten lockmgr merge dependent change: a lock counter per process
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.12 2003/05/15 04:08:03 niklas Exp $	*/
a212 1
	int	p_locks;       	/* DEBUG: lockmgr count of held locks */
@


1.28.2.14
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a261 6
#define	P_BITS \
    ("\20\01ADVLOCK\02CTTY\03INMEM\04NOCLDSTOP\05PPWAIT\06PROFIL\07SELECT" \
     "\010SINTR\011SUGID\012SYSTEM\013TIMEOUT\014TRACED\015WAITED\016WEXIT" \
     "\017EXEC\020PWEUPC\021FSTRACE\022SSTEP\023SUGIDEXEC\024NOCLDWAIT" \
     "\025NOZOMBIE\026INEXEC\027SYSTRACE")

a373 2
void	proc_printit(struct proc *p, const char *modif,
    int (*pr)(const char *, ...));
@


1.28.2.15
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.14 2003/05/16 00:29:45 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.28.2.16
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a97 1
	int	e_flags;		/* Flags, see below */
a98 4
					/* Per-process hooks */
	void	(*e_proc_exec)(struct proc *, struct exec_package *);
	void	(*e_proc_fork)(struct proc *p, struct proc *parent);
	void	(*e_proc_exit)(struct proc *);
a99 6
/* Flags for e_flags */
#define	EMUL_ENABLED	0x0001		/* Allow exec to continue */
#define	EMUL_NATIVE	0x0002		/* Always enabled */

extern struct emul *emulsw[];		/* All emuls in system */
extern int nemuls;			/* Number of emuls */
d176 1
a176 2
	void	*p_emuldata;		/* Per-process emulation data, or */
					/* NULL. Malloc type M_EMULDATA */
d256 1
a256 3
#define P_CONTINUED	0x800000	/* Proc has continued from a stopped state. */
#define P_SWAPIN	0x1000000	/* Swapping in right now */
#define P_BIGLOCK	0x2000000	/* Process needs kernel "big lock" to run */
d262 1
a262 1
     "\025NOZOMBIE\026INEXEC\027SYSTRACE\030CONTINUED\031SWAPIN\032BIGLOCK")
@


1.28.2.17
log
@deadproc mgmt is outside biglock, make its lock a real one
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.16 2004/02/19 11:01:34 niklas Exp $	*/
d367 1
a367 7
#ifndef MULTIPROCESSOR
/*
 * XXX SIMPLELOCK not yet defined.  deadproc_slock is defined in mplock.h
 * for MULTIPROCESSOR.
 */
extern struct SIMPLELOCK deadproc_slock;
#endif
d411 1
@


1.28.2.18
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.17 2004/04/21 09:40:50 niklas Exp $	*/
d167 1
a167 1
	int32_t	__p_free1;	 /* Free 4-byte slot */
d281 9
@


1.28.2.19
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d331 1
@


1.28.2.20
log
@p_schedflags is still used in non-smp case
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.19 2004/06/05 23:13:09 niklas Exp $	*/
d167 1
a167 1
	int	p_schedflags;	 /* PSCHED_* flags */
a280 9

/*
 * These flags are kept in p_schedflags.  p_schedflags may be modified
 * only at splstatclock().
 */
#define PSCHED_SEENRR		0x0001	/* process has been in roundrobin() */
#define PSCHED_SHOULDYIELD	0x0002	/* process should yield */

#define PSCHED_SWITCHCLEAR	(PSCHED_SEENRR|PSCHED_SHOULDYIELD)
@


1.28.2.21
log
@remove un-needed chunk
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.20 2004/06/06 05:21:59 tedu Exp $	*/
d366 7
@


1.28.2.22
log
@sched.h and proc.h contain a weird dependency; but sparc64 needs an
actual defn of schedstate_percpu, so put it in proc.h instead
@
text
@a49 26
 * CPU states.
 * XXX Not really scheduler state, but no other good place to put
 * it right now, and it really is per-CPU.
 */
#define CP_USER         0
#define CP_NICE         1
#define CP_SYS          2
#define CP_INTR         3
#define CP_IDLE         4
#define CPUSTATES       5

/*
 * Per-CPU scheduler state.
 */
struct schedstate_percpu {
        struct timeval spc_runtime;     /* time curproc started running */
        __volatile int spc_schedflags;  /* flags; see below */
        u_int spc_schedticks;           /* ticks for schedclock() */
        u_int64_t spc_cp_time[CPUSTATES]; /* CPU state statistics */
        u_char spc_curpriority;         /* usrpri of curproc */
	int spc_rrticks;		/* ticks until roundrobin() */
	int spc_pscnt;			/* prof/stat counter */
	int spc_psdiv;			/* prof/stat divisor */	
};

/*
@


1.28.2.23
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.22 2004/06/06 23:36:25 deraadt Exp $	*/
d54 6
a59 6
#define CP_USER		0
#define CP_NICE		1
#define CP_SYS		2
#define CP_INTR		3
#define CP_IDLE		4
#define CPUSTATES	5
d65 5
a69 5
	struct timeval spc_runtime;	/* time curproc started running */
	__volatile int spc_schedflags;	/* flags; see below */
	u_int spc_schedticks;		/* ticks for schedclock() */
	u_int64_t spc_cp_time[CPUSTATES]; /* CPU state statistics */
	u_char spc_curpriority;		/* usrpri of curproc */
@


1.28.2.24
log
@sync with head, make i386 __HAVE_CPUINFO
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#ifdef __HAVE_CPUINFO
d62 1
a62 1
 * Per-CPU scheduler state. XXX - this should be in sys/sched.h
a74 16
/* spc_flags */
#define SPCF_SEENRR             0x0001  /* process has seen roundrobin() */
#define SPCF_SHOULDYIELD        0x0002  /* process should yield the CPU */
#define SPCF_SWITCHCLEAR        (SPCF_SEENRR|SPCF_SHOULDYIELD)

/*
 * These are the fields we require in struct cpu_info that we get from
 * curcpu():
 *
 * struct proc *ci_curproc;
 * struct schedstate_percpu ci_schedstate;
 * cpuid_t ci_cpuid;
 */
#define curproc curcpu()->ci_curproc
#endif

a192 3
#ifdef __HAVE_CPUINFO
	struct	cpu_info * __volatile p_cpu; /* CPU we're running on. */
#else
a193 1
#endif
d246 1
a307 1
#ifndef __HAVE_CPUINFO
a315 1
#endif
d376 4
a379 1
#if !defined(__HAVE_CPUINFO) && !defined(curproc)
d381 1
@


1.28.2.25
log
@a reminder: sparc64 says you CANNOT DO THIS.  This stuff is needed because
of how something in sparc64 works.  Run anything relating to this via me,
until you grok it.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.28.2.24 2004/06/10 11:40:35 niklas Exp $	*/
d49 1
d63 1
a63 1
 * Per-CPU scheduler state.
a80 1
#ifdef __HAVE_CPUINFO
@


1.27
log
@undo vfork changes, since non-UVM was not considered
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.25 1999/08/17 10:32:18 niklas Exp $	*/
d286 12
d348 1
a348 4
int	fork1 __P((struct proc *, int, int, void *, size_t, register_t *));
#define	ISFORK	0
#define	ISVFORK	1
#define	ISRFORK	2
@


1.26
log
@Change fork1() from taking forktype and rforkflags, into a single flags
argument. Let sys_rfork build the arguments to fork1() and do the
sanity checks itself.
@
text
@a285 12
/*
 * Flags to fork1().
 */
#define FORK_FORK	0x00000001
#define FORK_VFORK	0x00000002
#define FORK_RFORK	0x00000004
#define FORK_PPWAIT	0x00000008
#define FORK_SHAREFILES	0x00000010
#define FORK_CLEANFILES	0x00000020
#define FORK_NOZOMBIE	0x00000040
#define FORK_SHAREVM	0x00000080

d336 4
a339 1
int	fork1 __P((struct proc *, int, void *, size_t, register_t *));
@


1.25
log
@New cpu_fork API to take a stack in which you point the child's stackpointer
to, at the bottom or the top, depending on your architecture's stack growth
direction.  This is in preparation for Linux' clone(2) emulation.
port maintainers, please check that I did the work right.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.24 1999/02/26 02:30:33 art Exp $	*/
d286 12
d348 1
a348 4
int	fork1 __P((struct proc *, int, int, void *, size_t, register_t *));
#define	ISFORK	0
#define	ISVFORK	1
#define	ISRFORK	2
@


1.24
log
@uvm_swapin
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.23 1999/01/11 21:20:00 millert Exp $	*/
d336 1
a336 1
int	fork1 __P((struct proc *, int, int, register_t *));
@


1.23
log
@drop PID_MAX to 32766 (SHRT_MAX - 1) due to ineractions with sys/compat
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.22 1999/01/10 02:20:19 niklas Exp $	*/
d273 6
d283 1
d327 3
d331 1
@


1.22
log
@Make RFNOWAIT work in rfork(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.21 1999/01/05 00:43:20 deraadt Exp $	*/
d261 1
d263 1
a263 1
#define	PID_MAX		65535
@


1.21
log
@make PID_MAX 65535: lots, but avoids problems with compat_*
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.20 1999/01/04 08:09:53 deraadt Exp $	*/
d214 15
a228 15
#define	P_ADVLOCK	0x00001	/* Process may hold a POSIX advisory lock. */
#define	P_CONTROLT	0x00002	/* Has a controlling terminal. */
#define	P_INMEM		0x00004	/* Loaded into memory. */
#define	P_NOCLDSTOP	0x00008	/* No SIGCHLD when children stop. */
#define	P_PPWAIT	0x00010	/* Parent is waiting for child to exec/exit. */
#define	P_PROFIL	0x00020	/* Has started profiling. */
#define	P_SELECT	0x00040	/* Selecting; wakeup/waiting danger. */
#define	P_SINTR		0x00080	/* Sleep is interruptible. */
#define	P_SUGID		0x00100	/* Had set id privileges since last exec. */
#define	P_SYSTEM	0x00200	/* System proc: no sigs, stats or swapping. */
#define	P_TIMEOUT	0x00400	/* Timing out during sleep. */
#define	P_TRACED	0x00800	/* Debugged process being traced. */
#define	P_WAITED	0x01000	/* Debugging process has waited for child. */
#define	P_WEXIT		0x02000	/* Working on exiting. */
#define	P_EXEC		0x04000	/* Process called exec. */
d231 1
a231 1
#define	P_OWEUPC	0x08000	/* Owe process an addupc() call at next ast. */
d234 3
a236 3
#define	P_FSTRACE	0x10000	/* tracing via file system (elsewhere?) */
#define	P_SSTEP		0x20000	/* process needs single-step fixup ??? */
#define	P_SUGIDEXEC	0x40000	/* last execve() was a setuid/setgid execve() */
d238 2
a239 1
#define	P_NOCLDWAIT	0x80000	/* No zombies if child dies (assign to pid 1) */
d325 3
@


1.20
log
@high PID_MAX has side effects on udp, which are still being debugged
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.19 1998/12/29 17:05:50 niklas Exp $	*/
d261 1
a261 1
#define	PID_MAX		30000
@


1.19
log
@Fat PIDs cannot be used with COMPAT_09, reported by ho@@netman.se
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.18 1998/12/28 06:28:14 deraadt Exp $	*/
a260 1
#ifdef COMPAT_09
a261 3
#else
#define	PID_MAX		99999
#endif
@


1.18
log
@crank PID_MAX to 99999
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.17 1998/02/22 01:00:25 niklas Exp $	*/
d261 3
d265 1
@


1.17
log
@Improve fine-grain control over emulated binaries by storing OS tags during
the process' runtime, so that personality checks can be done later
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.16 1997/09/15 05:46:14 millert Exp $	*/
d261 2
a262 2
#define	PID_MAX		30000
#define	NO_PID		30001
@


1.16
log
@From FreeBSD (joerg@@freebsd.org):
    Implement SA_NOCLDWAIT by reparenting kids of processes that have
    the appropriate bit set to PID 1, and let PID 1 handle the zombie.
    This assumes that PID 1 will wait for its kids (which is true of init).
    This also includes some FreeBSD sigaction.2.
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.15 1997/07/28 09:13:15 deraadt Exp $	*/
d129 1
a129 1
	u_char	p_unused;		/* XXX: used to be emulation flag */
@


1.15
log
@two unneeded variables; enami@@ba2.so-net.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.14 1997/06/05 10:15:22 deraadt Exp $	*/
d237 2
@


1.14
log
@random pid generation, heh
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.13 1997/02/01 21:49:30 deraadt Exp $	*/
d291 1
a291 1
struct proc *initproc, *pageproc;	/* Process slots for init, pager. */
@


1.13
log
@add type & union sigval args to sendsig/trapsignal
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.12 1997/01/27 22:48:41 deraadt Exp $	*/
d286 1
@


1.12
log
@add another parameter to trapsignal() and sendsig() -- fault addr to be
delivered with in the siginfo information
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.11 1996/11/24 01:39:23 kstailey Exp $	*/
d78 1
d84 1
a84 1
	void	(*e_sendsig) __P((sig_t, int, int, u_long, caddr_t));
@


1.11
log
@added prototype for remrunqueue()
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.9 1996/08/25 09:51:47 deraadt Exp $	*/
d83 1
a83 1
	void	(*e_sendsig) __P((sig_t, int, int, u_long));
@


1.10
log
@Small addition
@
text
@d309 1
@


1.9
log
@issetugid() system call discovers if a process was started setuid or setgid
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.8 1996/05/28 12:16:27 deraadt Exp $	*/
d95 1
@


1.8
log
@thread changes
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.6 1996/04/18 21:41:05 niklas Exp $	*/
d234 1
@


1.7
log
@proto more stuff
@
text
@a99 13
 * Description of the thread within the process
 */
typedef	struct proc	*proc_t;
typedef	struct thread	*thread_t;
typedef void	*event_t;

struct	thread {

	proc_t	proc;
	event_t	wait_event;
};

/*
d192 1
a192 1
	thread_t p_thread;	/* Id for this "thread"; Mach glue. */
a294 6

#define	current_thread()	(curproc->p_thread)
void	assert_wait __P((event_t, boolean_t));
void	thread_block __P((void));
void	thread_sleep __P((event_t, struct slock *, boolean_t));
void	thread_wakeup __P((event_t));
@


1.6
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: proc.h,v 1.5 1996/03/24 18:07:57 tholo Exp $	*/
/*	$NetBSD: proc.h,v 1.43 1996/03/14 18:59:11 christos Exp $	*/
d339 3
@


1.5
log
@Move thread prototypes back to <sys/proc.h>
Duplicate boolean_t definition in <sys/types.h>, protected by _KERNEL
Only use boolean_t definition in <vm/vm_param.h> when not _KERNEL
Mark latter two with XXX
@
text
@d1 2
a2 2
/*	$OpenBSD: proc.h,v 1.4 1996/03/24 17:40:44 tholo Exp $	*/
/*	$NetBSD: proc.h,v 1.42 1996/02/09 18:25:23 christos Exp $	*/
d155 1
a155 1
	int	p_dupfd;	 /* Sideways return value from fdopen. XXX */
@


1.4
log
@Move thread prototypes to <vm/vm_param.h> for consistency   XXX
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.3 1996/03/19 21:10:48 mickey Exp $	*/
d308 6
@


1.3
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: proc.h,v 1.2 1996/03/03 12:12:07 niklas Exp $	*/
a307 6

#define	current_thread()	(curproc->p_thread)
void	assert_wait __P((event_t, boolean_t));
void	thread_block __P((void));
void	thread_sleep __P((event_t, struct slock *, boolean_t));
void	thread_wakeup __P((event_t));
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d100 13
d205 1
a205 1
	void	*p_thread;	/* Id for this "thread"; Mach glue. XXX */
d308 6
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: proc.h,v 1.41 1995/08/13 09:04:43 mycroft Exp $	*/
d315 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
