head	1.18;
access;
symbols
	OPENBSD_6_1:1.18.0.14
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.18.0.12
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.8
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.10
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.2
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.11.0.10
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.4
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.2
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.10
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2014.01.24.04.26.51;	author guenther;	state Exp;
branches;
next	1.17;

1.17
date	2013.10.08.03.50.07;	author guenther;	state Exp;
branches;
next	1.16;

1.16
date	2013.06.03.16.55.22;	author guenther;	state Exp;
branches;
next	1.15;

1.15
date	2012.03.23.15.51.26;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2011.07.11.15.40.47;	author guenther;	state Exp;
branches;
next	1.13;

1.13
date	2011.07.07.18.11.24;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.29.20.14.46;	author guenther;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.15.10.22.30;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2006.12.24.20.28.44;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.11.19.10.20;	author kurt;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.04.21.49.18;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.07.21.20.02;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.05.08.34.18;	author art;	state Exp;
branches
	1.4.10.1;
next	1.3;

1.3
date	96.03.03.12.12.13;	author niklas;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	95.12.14.04.02.58;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2001.05.14.22.45.03;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.4.10.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@exit1() needs to do a final aggregation of the thread's [us]ticks
and runtime to the process totals.  Also, add ktracing of struct
rusage in wait4() and getrusage().

problem pointed out by tedu@@
ok deraadt@@
@
text
@/*	$OpenBSD: resourcevar.h,v 1.17 2013/10/08 03:50:07 guenther Exp $	*/
/*	$NetBSD: resourcevar.h,v 1.12 1995/11/22 23:01:53 cgd Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)resourcevar.h	8.3 (Berkeley) 2/22/94
 */

#ifndef	_SYS_RESOURCEVAR_H_
#define	_SYS_RESOURCEVAR_H_

#include <sys/timeout.h>

/*
 * Kernel shareable process resource limits.  Because this structure
 * is moderately large but changes infrequently, it is shared
 * copy-on-write after forks.
 */
struct plimit {
	struct	rlimit pl_rlimit[RLIM_NLIMITS];
	int	p_refcnt;		/* number of references */
};

/* add user profiling from AST */
#define	ADDUPROF(p)							\
do {									\
	atomic_clearbits_int(&(p)->p_flag, P_OWEUPC);			\
	addupc_task((p), (p)->p_prof_addr, (p)->p_prof_ticks);		\
	(p)->p_prof_ticks = 0;						\
} while (0)

#ifdef _KERNEL
void	 addupc_intr(struct proc *, u_long);
void	 addupc_task(struct proc *, u_long, u_int);
void	 tuagg_unlocked(struct process *, struct proc *);
void	 tuagg(struct process *, struct proc *);
struct tusage;
void	 calctsru(struct tusage *, struct timespec *, struct timespec *,
	    struct timespec *);
void	 calcru(struct tusage *, struct timeval *, struct timeval *,
	    struct timeval *);
struct plimit *limcopy(struct plimit *);
void	limfree(struct plimit *);

void	 ruadd(struct rusage *, struct rusage *);
#endif
#endif	/* !_SYS_RESOURCEVAR_H_ */
@


1.17
log
@Fix delivery of SIGPROF and SIGVTALRM to threaded processes by having
hardclock() set a flag on the running thread and force AST processing,
and then have the thread signal itself from userret().

idea and flag names from FreeBSD
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.16 2013/06/03 16:55:22 guenther Exp $	*/
d62 1
@


1.16
log
@Convert some internal APIs to use timespecs instead of timevals

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.15 2012/03/23 15:51:26 guenther Exp $	*/
a70 3

void	virttimer_trampoline(void *);
void	proftimer_trampoline(void *);
@


1.15
log
@Make rusage totals, itimers, and profile settings per-process instead
of per-rthread.  Handling of per-thread tick and runtime counters
inspired by how FreeBSD does it.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.14 2011/07/11 15:40:47 guenther Exp $	*/
d59 2
a60 2
void	 addupc_intr(struct proc *p, u_long pc);
void	 addupc_task(struct proc *p, u_long pc, u_int ticks);
d63 5
a67 3
void	 calcru(struct tusage *, struct timeval *up, struct timeval *sp,
	    struct timeval *ip);
struct plimit *limcopy(struct plimit *lim);
d70 1
a70 1
void	 ruadd(struct rusage *ru, struct rusage *ru2);
@


1.14
log
@Revert art@@'s moving around of the KERNEL_LOCK()/KERNEL_UNLOCK() calls,
as it causes hangs in some ports, including libsigsegv's configure script

confirmed by krw@@, landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.12 2010/06/29 20:14:46 guenther Exp $	*/
a40 26
 * Kernel per-process accounting / statistics
 * (not necessarily resident except when running).
 */
struct pstats {
#define	pstat_startzero	p_ru
	struct	rusage p_ru;		/* stats for this proc */
	struct	rusage p_cru;		/* sum of stats for reaped children */
	struct	itimerval p_timer[3];	/* virtual-time timers */
#define	pstat_endzero	pstat_startcopy

#define	pstat_startcopy	p_prof
	struct uprof {			/* profile arguments */
		caddr_t	pr_base;	/* buffer base */
		size_t  pr_size;	/* buffer size */
		u_long	pr_off;		/* pc offset */
		u_int   pr_scale;	/* pc scaling */
		u_long	pr_addr;	/* temp storage for addr until AST */
		u_long	pr_ticks;	/* temp storage for ticks until AST */
	} p_prof;
#define	pstat_endcopy	p_start
	struct	timeval p_start;	/* starting time */
	struct	timeout p_virt_to;	/* virtual itimer trampoline. */
	struct	timeout p_prof_to;	/* prof itimer trampoline. */
};

/*
d54 2
a55 3
	addupc_task((p), (p)->p_stats->p_prof.pr_addr,			\
	    (p)->p_stats->p_prof.pr_ticks);				\
	(p)->p_stats->p_prof.pr_ticks = 0;				\
d61 3
a63 1
void	 calcru(struct proc *p, struct timeval *up, struct timeval *sp,
@


1.13
log
@There is a bunch of places in the kernel entry points where we don't
hold the kernel lock, but still need call one function that needs it.

Instead of grabbing the lock all over the place, move the locks into
the affected functions: trapsignal, scdebug*, ktrsyscall, ktrsysret,
systrace_redirect and ADDUPROF. In the cases we already hold the biglock
we'll just recurse.

kettenis@@, beck@@ ok
@
text
@a78 1
	KERNEL_LOCK();							\
a82 1
	KERNEL_UNLOCK();						\
@


1.12
log
@Eliminate struct plimit's PL_SHAREMOD flag: it was for COMPAT_IRIX
sproc() support, but we don't have COMPAT_IRIX.
ok krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.11 2007/03/15 10:22:30 art Exp $	*/
d79 1
d84 1
@


1.11
log
@Since p_flag is often manipulated in interrupts and without biglock
it's a good idea to use atomic.h operations on it. This mechanic
change updates all bit operations on p_flag to atomic_{set,clear}bits_int.

Only exception is that P_OWEUPC is set by MI code before calling
need_proftick and it's automatically cleared by ADDUPC. There's
no reason for MD handling of that flag since everyone handles it the
same way.

kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.10 2006/12/24 20:28:44 miod Exp $	*/
d68 2
a69 5
 * is moderately large but changes infrequently, it is normally
 * shared copy-on-write after forks.  If a group of processes
 * ("threads") share modifications, the PL_SHAREMOD flag is set,
 * and a copy must be made for the child of a new fork that isn't
 * sharing modifications to the limits.
a72 2
#define	PL_SHAREMOD	0x01		/* modifications are shared */
	int	p_lflags;
@


1.10
log
@Keep a counter for addupc_intr() invocations, and pass its value, instead of 1,
to addupc_task() in ADDUPROF(). From NetBSD via art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.9 2006/07/11 19:10:20 kurt Exp $	*/
d84 1
@


1.9
log
@Ensure virtual and profiling interval timers are reset in child process
after fork() per POSIX (PR: system/5126). Fix from FreeBSD.

okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.8 2004/08/04 21:49:18 art Exp $	*/
d58 1
d82 6
a87 1
#define	ADDUPROF(p) addupc_task((p), (p)->p_stats->p_prof.pr_addr, 1)
@


1.8
log
@hardclock detects if ITIMER_VIRTUAL and ITIMER_PROF have expired and
sends SIGVTALRM and SIGPROF to the process if they had. There is a big
problem with calling psignal from hardclock on MULTIPROCESSOR machines
though. It means we need to protect all signal state in the process
with a lock because hardclock doesn't obtain KERNEL_LOCK. Trying to
track down all the tentacles of this quickly becomes very messy. What
saves us at the moment is that SCHED_LOCK (which is used to protect
parts of the signal state, but not all) happens to be recursive and
forgives small and big errors. That's about to change.

So instead of trying to hunt down all the locking problems here, just
make hardclock not send signals. Instead hardclock schedules a timeout
that will send the signal later. There are many reasons why this works
just as good as the previous code, all explained in a comment written
in big, friendly letters in kern_clock.

miod@@ ok noone else dared to ok this, but noone screamed in agony either.
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.7 2003/06/02 23:28:21 millert Exp $	*/
d48 1
d51 1
a51 3
#define	pstat_startcopy	p_timer
	struct	itimerval p_timer[3];	/* virtual-time timers */

@


1.7
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.6 2002/06/07 21:20:02 art Exp $	*/
d38 2
d62 2
d93 3
@


1.6
log
@Change addupc_intr to not use fuswintr and suswintr to update the profiling
info. Since we only use it to profile processes in user mode and there
is no way to get back user mode without going past the AST that will
write out the profiling info in a context where copyout works.

Sitting in my tree for ages.
Reviewed and with some suggestions from nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.5 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.4 2000/05/05 08:34:18 art Exp $	*/
a60 1
		u_long	pr_ticks;	/* temp storage for ticks until AST */
d82 1
a82 3
#define	ADDUPROF(p)							\
	addupc_task(p,							\
	    (p)->p_stats->p_prof.pr_addr, (p)->p_stats->p_prof.pr_ticks)
d85 1
a85 1
void	 addupc_intr(struct proc *p, u_long pc, u_int ticks);
@


1.4
log
@Add limfree prototype to sys/recosurcevar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.3 1996/03/03 12:12:13 niklas Exp $	*/
d88 6
a93 6
void	 addupc_intr __P((struct proc *p, u_long pc, u_int ticks));
void	 addupc_task __P((struct proc *p, u_long pc, u_int ticks));
void	 calcru __P((struct proc *p, struct timeval *up, struct timeval *sp,
	    struct timeval *ip));
struct plimit *limcopy __P((struct plimit *lim));
void	limfree __P((struct plimit *));
d95 1
a95 1
void	 ruadd __P((struct rusage *ru, struct rusage *ru2));
@


1.4.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.4 2000/05/05 08:34:18 art Exp $	*/
d61 1
d83 3
a85 1
#define	ADDUPROF(p) addupc_task((p), (p)->p_stats->p_prof.pr_addr, 1)
d88 6
a93 6
void	 addupc_intr(struct proc *p, u_long pc);
void	 addupc_task(struct proc *p, u_long pc, u_int ticks);
void	 calcru(struct proc *p, struct timeval *up, struct timeval *sp,
	    struct timeval *ip);
struct plimit *limcopy(struct plimit *lim);
void	limfree(struct plimit *);
d95 1
a95 1
void	 ruadd(struct rusage *ru, struct rusage *ru2);
@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d92 3
a94 2
struct plimit
	*limcopy __P((struct plimit *lim));
@


1.3.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.4 2000/05/05 08:34:18 art Exp $	*/
d92 2
a93 3
struct plimit *limcopy __P((struct plimit *lim));
void	limfree __P((struct plimit *));

@


1.3.16.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d88 6
a93 6
void	 addupc_intr(struct proc *p, u_long pc, u_int ticks);
void	 addupc_task(struct proc *p, u_long pc, u_int ticks);
void	 calcru(struct proc *p, struct timeval *up, struct timeval *sp,
	    struct timeval *ip);
struct plimit *limcopy(struct plimit *lim);
void	limfree(struct plimit *);
d95 1
a95 1
void	 ruadd(struct rusage *ru, struct rusage *ru2);
@


1.3.16.3
log
@Sync the SMP branch with 3.3
@
text
@d61 1
d83 3
a85 1
#define	ADDUPROF(p) addupc_task((p), (p)->p_stats->p_prof.pr_addr, 1)
d88 1
a88 1
void	 addupc_intr(struct proc *p, u_long pc);
@


1.3.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: resourcevar.h,v 1.3.16.3 2003/03/28 00:41:30 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@from netbsd:
represent profiling size, scale more correctly (as size_t, u_int, resp.)
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: resourcevar.h,v 1.11 1995/03/26 20:24:37 jtc Exp $	*/
d56 1
a56 1
		u_long	pr_size;	/* buffer size */
d58 1
a58 1
		u_long	pr_scale;	/* pc scaling */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
