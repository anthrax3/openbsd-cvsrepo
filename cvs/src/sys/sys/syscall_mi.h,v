head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.2.0.8
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.4
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.2
	OPENBSD_5_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2017.02.14.10.31.15;	author mpi;	state Exp;
branches;
next	1.16;
commitid	PmGi4EGraGC0Z0ml;

1.16
date	2016.04.25.20.00.33;	author tedu;	state Exp;
branches;
next	1.15;
commitid	MLNYUlvoOtU8VX0s;

1.15
date	2015.11.03.16.14.14;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	0guBDAktsQ8jv0a9;

1.14
date	2015.11.02.23.17.58;	author tedu;	state Exp;
branches;
next	1.13;
commitid	dwqz4dmMrqbpdeTd;

1.13
date	2015.11.01.19.03.33;	author semarie;	state Exp;
branches;
next	1.12;
commitid	VKRkUfXZQNJ8UQeY;

1.12
date	2015.10.26.07.24.20;	author semarie;	state Exp;
branches;
next	1.11;
commitid	9KmnG31nIVcQPeid;

1.11
date	2015.10.09.01.17.18;	author deraadt;	state Exp;
branches;
next	1.10;
commitid	6ulbDS81ej0XxvnS;

1.10
date	2015.09.12.16.22.46;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	gYCfhACXxHzmhsVo;

1.9
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.8;
commitid	Lqreadw8v5IPAc0L;

1.8
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.7;
commitid	6NDuzTPjBp2GqkfQ;

1.7
date	2015.07.19.04.45.25;	author guenther;	state Exp;
branches;
next	1.6;
commitid	ZlSuHVkn9uJBlE0T;

1.6
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches;
next	1.5;
commitid	CJwjm9NDWu6nJ6ES;

1.5
date	2014.05.11.00.12.44;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2014.05.10.05.33.00;	author guenther;	state Exp;
branches;
next	1.3;

1.3
date	2014.04.18.11.51.17;	author guenther;	state Exp;
branches;
next	1.2;

1.2
date	2012.08.07.23.22.38;	author guenther;	state Exp;
branches;
next	1.1;

1.1
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Convert most of the manual checks for CPU hogging to sched_pause().

The distinction between preempt() and yield() stays as it is usueful
to know if a thread decided to yield by itself or if the kernel told
him to go away.

ok tedu@@, guenther@@
@
text
@/*	$OpenBSD: syscall_mi.h,v 1.16 2016/04/25 20:00:33 tedu Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kern_xxx.c	8.2 (Berkeley) 11/14/93
 */

#include <sys/pledge.h>

#ifdef KTRACE
#include <sys/ktrace.h>
#endif


/*
 * The MD setup for a system call has been done; here's the MI part.
 */
static inline int
mi_syscall(struct proc *p, register_t code, const struct sysent *callp,
    register_t *argp, register_t retval[2])
{
	int lock = !(callp->sy_flags & SY_NOLOCK);
	int error, pledged, tval;

	/* refresh the thread's cache of the process's creds */
	refreshcreds(p);

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_call(p, code, argp);
	KERNEL_UNLOCK();
#endif
#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSCALL)) {
		KERNEL_LOCK();
		ktrsyscall(p, code, callp->sy_argsize, argp);
		KERNEL_UNLOCK();
	}
#endif

	if (lock)
		KERNEL_LOCK();
	pledged = (p->p_p->ps_flags & PS_PLEDGE);
	if (pledged && (error = pledge_syscall(p, code, &tval))) {
		if (!lock)
			KERNEL_LOCK();
		error = pledge_fail(p, error, tval);
		KERNEL_UNLOCK();
		return (error);
	}
	error = (*callp->sy_call)(p, argp, retval);
	if (lock)
		KERNEL_UNLOCK();

	return (error);
}

/*
 * Finish MI stuff on return, after the registers have been set
 */
static inline void
mi_syscall_return(struct proc *p, register_t code, int error,
    const register_t retval[2])
{
#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, error, retval);
	KERNEL_UNLOCK();
#endif

	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, error, retval);
		KERNEL_UNLOCK();
	}
#endif
}

/*
 * Finish MI stuff for a new process/thread to return
 */
static inline void
mi_child_return(struct proc *p)
{
#if defined(SYSCALL_DEBUG) || defined(KTRACE)
	int code = (p->p_flag & P_THREAD) ? SYS___tfork :
	    (p->p_p->ps_flags & PS_PPWAIT) ? SYS_vfork : SYS_fork;
	const register_t child_retval[2] = { 0, 1 };
#endif

#ifdef SYSCALL_DEBUG
	KERNEL_LOCK();
	scdebug_ret(p, code, 0, child_retval);
	KERNEL_UNLOCK();
#endif

	userret(p);

#ifdef KTRACE
	if (KTRPOINT(p, KTR_SYSRET)) {
		KERNEL_LOCK();
		ktrsysret(p, code, 0, child_retval);
		KERNEL_UNLOCK();
	}
#endif
}

/* 
 * Do the specific processing necessary for an AST
 */
static inline void
mi_ast(struct proc *p, int resched)
{
	if (p->p_flag & P_OWEUPC) {
		KERNEL_LOCK();
		ADDUPROF(p);
		KERNEL_UNLOCK();
	}
	if (resched)
		preempt();

	/*
	 * XXX could move call to userret() here, but
	 * hppa calls ast() in syscall return and sh calls
	 * it after userret()
	 */
}
@


1.16
log
@boom goes the dynamite
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.15 2015/11/03 16:14:14 deraadt Exp $	*/
d149 1
a149 1
		preempt(NULL);
@


1.15
log
@pledge_aftersyscall has been reduced to one case, "getpw", to open a
window for chatting to ypserv.  This can be done in pledge_namei, so
improve system call performance by removing the pledge_aftersyscall hook.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.14 2015/11/02 23:17:58 tedu Exp $	*/
a39 5
#include "systrace.h"
#if NSYSTRACE > 0
#include <dev/systrace.h>
#endif

a76 9
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		if (!lock)
			KERNEL_LOCK();
		error = systrace_redirect(code, p, argp, retval);
		lock = 1;
		goto done;
	}
#endif
a77 3
#if NSYSTRACE > 0
done:
#endif
@


1.14
log
@make systrace and pledge play nice again. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.13 2015/11/01 19:03:33 semarie Exp $	*/
a94 2
	if (pledged && p->p_pledgeafter)
		pledge_aftersyscall(p, code, error);
@


1.13
log
@refactor pledge_*_check and pledge_fail functions

- rename _check function without suffix: a "pledge" function called from
  anywhere is a "check" function.

- makes pledge_fail call the responsability to the _check function. remove it
  from caller.

- make proper use of (potential) returned error of _check() functions.

- adds pledge_kill() and pledge_protexec()

with and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.12 2015/10/26 07:24:20 semarie Exp $	*/
d83 1
a83 1
	if (!pledged && ISSET(p->p_flag, P_SYSTRACE)) {
d87 2
a88 2
		KERNEL_UNLOCK();
		return (error);
d92 3
@


1.12
log
@make pledge_check(), used for syscall check with pledge, returns an error and
provide the required pledge request for pledge_fail().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.11 2015/10/09 01:17:18 deraadt Exp $	*/
d75 1
a75 1
	if (pledged && (error = pledge_check(p, code, &tval))) {
@


1.11
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.10 2015/09/12 16:22:46 deraadt Exp $	*/
d75 1
a75 1
	if (pledged && !(tval = pledge_check(p, code))) {
d78 1
a78 1
		error = pledge_fail(p, EPERM, tval);
@


1.10
log
@sys/syscall_mi is only included by MD trap.c files, which have reason to
include param.h/systm.h/proc.h themselves (and already do).
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.9 2015/09/11 08:22:31 guenther Exp $	*/
d34 1
a34 1
#include <sys/tame.h>
d54 1
a54 1
	int error, tamed, tval;
d74 2
a75 2
	tamed = (p->p_p->ps_flags & PS_TAMED);
	if (tamed && !(tval = tame_check(p, code))) {
d78 1
a78 1
		error = tame_fail(p, EPERM, tval);
d83 1
a83 1
	if (!tamed && ISSET(p->p_flag, P_SYSTRACE)) {
d92 2
a93 2
	if (tamed && p->p_tameafter)
		tame_aftersyscall(p, code, error);
@


1.9
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.8 2015/08/22 20:18:50 deraadt Exp $	*/
a33 3
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/proc.h>
@


1.8
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.7 2015/07/19 04:45:25 guenther Exp $	*/
d37 1
@


1.7
log
@Make KTR_SYSRET records variables variables sized, leaving out the
retval on error, including a long long retval on successful lseek(),
and including a register_t retval for other successes.  This fixes
lseek reporting on ILP32 archs.

While here, reworking internal kern_ktrace.c bits to be able to pass
two buffers to ktrwriteraw(), so we can avoid mallocing a buffer
in some cases and so that KTR_GENIO logs are split at PAGE_SIZE,
not PAGE_SIZE-sizeof(struct ktrgenio)

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.6 2015/07/19 02:35:35 deraadt Exp $	*/
a35 1
#include <sys/tame.h>
a73 9
#if NSYSTRACE > 0
	if (ISSET(p->p_flag, P_SYSTRACE)) {
		KERNEL_LOCK();
		error = systrace_redirect(code, p, argp, retval);
		KERNEL_UNLOCK();
		return (error);
	}
#endif

d81 5
d87 4
a90 6
			KERNEL_UNLOCK();
		}
	else {
		error = (*callp->sy_call)(p, argp, retval);
		if (tamed && p->p_tameafter)
			tame_aftersyscall(p, code, error);
d92 4
@


1.6
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.5 2014/05/11 00:12:44 guenther Exp $	*/
d123 1
a123 1
		ktrsysret(p, code, error, retval[0]);
d138 1
a141 2
	const register_t child_retval[2] = { 0, 1 };

d152 1
a152 1
		ktrsysret(p, code, 0, 0);
@


1.5
log
@Move the increment of uvmexp.softs back to the caller of mi_ast():
it needs to be done atomicly on some MP archs and we don't have
atomic_add_int() everywhere yet.  Also, mi_ast() was meant to be inline.

noted by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.4 2014/05/10 05:33:00 guenther Exp $	*/
d36 1
d57 1
a57 1
	int error;
d80 2
a81 1
	} else
d83 6
a88 2
	{
		if (lock)
d90 5
d96 2
a97 2
		if (lock)
			KERNEL_UNLOCK();
d99 2
@


1.4
log
@Factor out the common ast bits into mi_ast()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.3 2014/04/18 11:51:17 guenther Exp $	*/
d149 1
a149 1
static void
a151 2
	uvmexp.softs++;

@


1.3
log
@Have each thread keeps its own (counted!) reference to the process's ucreds
to avoid possible use-after-free references when swapping ids in threaded
processes.  "Do I have the right creds?" checks are always made with the
threads creds.

Inspired by FreeBSD and NetBSD
"right time" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.2 2012/08/07 23:22:38 guenther Exp $	*/
d144 23
@


1.2
log
@Fix compilation when !defined(KTRACE) by hiding the then-unused 'code'
variable

Pointed out by Amit Kulkarni (amitkulz at gmail.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: syscall_mi.h,v 1.1 2012/08/07 05:16:53 guenther Exp $	*/
d57 3
@


1.1
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d119 1
d122 1
@

