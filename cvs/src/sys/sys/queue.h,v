head	1.44;
access;
symbols
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.43.0.4
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.38.0.12
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.38.0.4
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.8
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.6
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.36.0.4
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.2
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.32.0.16
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.14
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.10
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.12
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.8
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.32.0.6
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.31.0.6
	OPENBSD_4_1_BASE:1.31
	OPENBSD_4_0:1.31.0.4
	OPENBSD_4_0_BASE:1.31
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.27.0.4
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.10
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.8
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.6
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.22.0.4
	UBC_BASE:1.22
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.2
	OPENBSD_2_7_BASE:1.15
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2016.09.09.20.31.46;	author millert;	state Exp;
branches;
next	1.43;
commitid	GAScUkPGHJ6VSSzG;

1.43
date	2015.12.28.19.38.40;	author millert;	state Exp;
branches;
next	1.42;
commitid	8gcBp0trSTovIePU;

1.42
date	2015.11.19.21.03.36;	author millert;	state Exp;
branches;
next	1.41;
commitid	Yem4ppx0sxOMrdwl;

1.41
date	2015.11.19.13.38.07;	author millert;	state Exp;
branches;
next	1.40;
commitid	84GDrP6o9VcPHWFD;

1.40
date	2015.10.30.12.20.56;	author jasper;	state Exp;
branches;
next	1.39;
commitid	MxbYWk1gRZpOx8Bp;

1.39
date	2015.10.26.14.12.13;	author bluhm;	state Exp;
branches;
next	1.38;
commitid	IedFNSIrhYu8SrIy;

1.38
date	2013.07.03.15.05.21;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.03.18.24.01;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2012.04.11.13.29.14;	author naddy;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.11.00.06.48;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.09.00.19.45;	author pirofti;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.03.16.08.40;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.30.18.42.34;	author pedro;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.25.08.06.25;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2005.10.25.06.37.47;	author otto;	state Exp;
branches;
next	1.29;

1.29
date	2005.10.24.20.25.14;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.17.20.19.42;	author otto;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.25.13.29.30;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.04.16.59.32;	author grange;	state Exp;
branches;
next	1.25;

1.25
date	2004.04.08.16.08.21;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.16.21.08.20;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.23.04.39.35;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.23.04.23.05;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.23.03.53.22;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.03.49.06;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.03.47.58;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.16.20.02.20;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.07.19.47.59;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.15.00.20.13;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.09.08.08.20.04;	author espie;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.09.05.15.57.45;	author espie;	state Exp;
branches;
next	1.12;

1.12
date	99.01.08.15.29.32;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	98.09.11.06.28.05;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	98.07.15.22.11.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.06.02.06.15.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.11.28.22.50.15;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.10;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.21.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.25.34;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	96.05.22.12.07.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.31.56;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.10;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.05.14.22.45.03;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.07.04.11.00.29;	author niklas;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Include sys/_null.h for the NULL definition.
@
text
@/*	$OpenBSD: queue.h,v 1.43 2015/12/28 19:38:40 millert Exp $	*/
/*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/

/*
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)queue.h	8.5 (Berkeley) 8/20/94
 */

#ifndef	_SYS_QUEUE_H_
#define	_SYS_QUEUE_H_

#include <sys/_null.h>

/*
 * This file defines five types of data structures: singly-linked lists,
 * lists, simple queues, tail queues and XOR simple queues.
 *
 *
 * A singly-linked list is headed by a single forward pointer. The elements
 * are singly linked for minimum space and pointer manipulation overhead at
 * the expense of O(n) removal for arbitrary elements. New elements can be
 * added to the list after an existing element or at the head of the list.
 * Elements being removed from the head of the list should use the explicit
 * macro for this purpose for optimum efficiency. A singly-linked list may
 * only be traversed in the forward direction.  Singly-linked lists are ideal
 * for applications with large datasets and few or no removals or for
 * implementing a LIFO queue.
 *
 * A list is headed by a single forward pointer (or an array of forward
 * pointers for a hash table header). The elements are doubly linked
 * so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before
 * or after an existing element or at the head of the list. A list
 * may only be traversed in the forward direction.
 *
 * A simple queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are singly
 * linked to save space, so elements can only be removed from the
 * head of the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the
 * list. A simple queue may only be traversed in the forward direction.
 *
 * A tail queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or
 * after an existing element, at the head of the list, or at the end of
 * the list. A tail queue may be traversed in either direction.
 *
 * An XOR simple queue is used in the same way as a regular simple queue.
 * The difference is that the head structure also includes a "cookie" that
 * is XOR'd with the queue pointer (first, last or next) to generate the
 * real pointer value.
 *
 * For details on the use of these macros, see the queue(3) manual page.
 */

#if defined(QUEUE_MACRO_DEBUG) || (defined(_KERNEL) && defined(DIAGNOSTIC))
#define _Q_INVALIDATE(a) (a) = ((void *)-1)
#else
#define _Q_INVALIDATE(a)
#endif

/*
 * Singly-linked List definitions.
 */
#define SLIST_HEAD(name, type)						\
struct name {								\
	struct type *slh_first;	/* first element */			\
}

#define	SLIST_HEAD_INITIALIZER(head)					\
	{ NULL }

#define SLIST_ENTRY(type)						\
struct {								\
	struct type *sle_next;	/* next element */			\
}

/*
 * Singly-linked List access methods.
 */
#define	SLIST_FIRST(head)	((head)->slh_first)
#define	SLIST_END(head)		NULL
#define	SLIST_EMPTY(head)	(SLIST_FIRST(head) == SLIST_END(head))
#define	SLIST_NEXT(elm, field)	((elm)->field.sle_next)

#define	SLIST_FOREACH(var, head, field)					\
	for((var) = SLIST_FIRST(head);					\
	    (var) != SLIST_END(head);					\
	    (var) = SLIST_NEXT(var, field))

#define	SLIST_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = SLIST_FIRST(head);				\
	    (var) && ((tvar) = SLIST_NEXT(var, field), 1);		\
	    (var) = (tvar))

/*
 * Singly-linked List functions.
 */
#define	SLIST_INIT(head) {						\
	SLIST_FIRST(head) = SLIST_END(head);				\
}

#define	SLIST_INSERT_AFTER(slistelm, elm, field) do {			\
	(elm)->field.sle_next = (slistelm)->field.sle_next;		\
	(slistelm)->field.sle_next = (elm);				\
} while (0)

#define	SLIST_INSERT_HEAD(head, elm, field) do {			\
	(elm)->field.sle_next = (head)->slh_first;			\
	(head)->slh_first = (elm);					\
} while (0)

#define	SLIST_REMOVE_AFTER(elm, field) do {				\
	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
} while (0)

#define	SLIST_REMOVE_HEAD(head, field) do {				\
	(head)->slh_first = (head)->slh_first->field.sle_next;		\
} while (0)

#define SLIST_REMOVE(head, elm, type, field) do {			\
	if ((head)->slh_first == (elm)) {				\
		SLIST_REMOVE_HEAD((head), field);			\
	} else {							\
		struct type *curelm = (head)->slh_first;		\
									\
		while (curelm->field.sle_next != (elm))			\
			curelm = curelm->field.sle_next;		\
		curelm->field.sle_next =				\
		    curelm->field.sle_next->field.sle_next;		\
	}								\
	_Q_INVALIDATE((elm)->field.sle_next);				\
} while (0)

/*
 * List definitions.
 */
#define LIST_HEAD(name, type)						\
struct name {								\
	struct type *lh_first;	/* first element */			\
}

#define LIST_HEAD_INITIALIZER(head)					\
	{ NULL }

#define LIST_ENTRY(type)						\
struct {								\
	struct type *le_next;	/* next element */			\
	struct type **le_prev;	/* address of previous next element */	\
}

/*
 * List access methods.
 */
#define	LIST_FIRST(head)		((head)->lh_first)
#define	LIST_END(head)			NULL
#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
#define	LIST_NEXT(elm, field)		((elm)->field.le_next)

#define LIST_FOREACH(var, head, field)					\
	for((var) = LIST_FIRST(head);					\
	    (var)!= LIST_END(head);					\
	    (var) = LIST_NEXT(var, field))

#define	LIST_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = LIST_FIRST(head);				\
	    (var) && ((tvar) = LIST_NEXT(var, field), 1);		\
	    (var) = (tvar))

/*
 * List functions.
 */
#define	LIST_INIT(head) do {						\
	LIST_FIRST(head) = LIST_END(head);				\
} while (0)

#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
	if (((elm)->field.le_next = (listelm)->field.le_next) != NULL)	\
		(listelm)->field.le_next->field.le_prev =		\
		    &(elm)->field.le_next;				\
	(listelm)->field.le_next = (elm);				\
	(elm)->field.le_prev = &(listelm)->field.le_next;		\
} while (0)

#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
	(elm)->field.le_prev = (listelm)->field.le_prev;		\
	(elm)->field.le_next = (listelm);				\
	*(listelm)->field.le_prev = (elm);				\
	(listelm)->field.le_prev = &(elm)->field.le_next;		\
} while (0)

#define LIST_INSERT_HEAD(head, elm, field) do {				\
	if (((elm)->field.le_next = (head)->lh_first) != NULL)		\
		(head)->lh_first->field.le_prev = &(elm)->field.le_next;\
	(head)->lh_first = (elm);					\
	(elm)->field.le_prev = &(head)->lh_first;			\
} while (0)

#define LIST_REMOVE(elm, field) do {					\
	if ((elm)->field.le_next != NULL)				\
		(elm)->field.le_next->field.le_prev =			\
		    (elm)->field.le_prev;				\
	*(elm)->field.le_prev = (elm)->field.le_next;			\
	_Q_INVALIDATE((elm)->field.le_prev);				\
	_Q_INVALIDATE((elm)->field.le_next);				\
} while (0)

#define LIST_REPLACE(elm, elm2, field) do {				\
	if (((elm2)->field.le_next = (elm)->field.le_next) != NULL)	\
		(elm2)->field.le_next->field.le_prev =			\
		    &(elm2)->field.le_next;				\
	(elm2)->field.le_prev = (elm)->field.le_prev;			\
	*(elm2)->field.le_prev = (elm2);				\
	_Q_INVALIDATE((elm)->field.le_prev);				\
	_Q_INVALIDATE((elm)->field.le_next);				\
} while (0)

/*
 * Simple queue definitions.
 */
#define SIMPLEQ_HEAD(name, type)					\
struct name {								\
	struct type *sqh_first;	/* first element */			\
	struct type **sqh_last;	/* addr of last next element */		\
}

#define SIMPLEQ_HEAD_INITIALIZER(head)					\
	{ NULL, &(head).sqh_first }

#define SIMPLEQ_ENTRY(type)						\
struct {								\
	struct type *sqe_next;	/* next element */			\
}

/*
 * Simple queue access methods.
 */
#define	SIMPLEQ_FIRST(head)	    ((head)->sqh_first)
#define	SIMPLEQ_END(head)	    NULL
#define	SIMPLEQ_EMPTY(head)	    (SIMPLEQ_FIRST(head) == SIMPLEQ_END(head))
#define	SIMPLEQ_NEXT(elm, field)    ((elm)->field.sqe_next)

#define SIMPLEQ_FOREACH(var, head, field)				\
	for((var) = SIMPLEQ_FIRST(head);				\
	    (var) != SIMPLEQ_END(head);					\
	    (var) = SIMPLEQ_NEXT(var, field))

#define	SIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = SIMPLEQ_FIRST(head);				\
	    (var) && ((tvar) = SIMPLEQ_NEXT(var, field), 1);		\
	    (var) = (tvar))

/*
 * Simple queue functions.
 */
#define	SIMPLEQ_INIT(head) do {						\
	(head)->sqh_first = NULL;					\
	(head)->sqh_last = &(head)->sqh_first;				\
} while (0)

#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.sqe_next = (head)->sqh_first) == NULL)	\
		(head)->sqh_last = &(elm)->field.sqe_next;		\
	(head)->sqh_first = (elm);					\
} while (0)

#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.sqe_next = NULL;					\
	*(head)->sqh_last = (elm);					\
	(head)->sqh_last = &(elm)->field.sqe_next;			\
} while (0)

#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	if (((elm)->field.sqe_next = (listelm)->field.sqe_next) == NULL)\
		(head)->sqh_last = &(elm)->field.sqe_next;		\
	(listelm)->field.sqe_next = (elm);				\
} while (0)

#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
		(head)->sqh_last = &(head)->sqh_first;			\
} while (0)

#define SIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
	if (((elm)->field.sqe_next = (elm)->field.sqe_next->field.sqe_next) \
	    == NULL)							\
		(head)->sqh_last = &(elm)->field.sqe_next;		\
} while (0)

#define SIMPLEQ_CONCAT(head1, head2) do {				\
	if (!SIMPLEQ_EMPTY((head2))) {					\
		*(head1)->sqh_last = (head2)->sqh_first;		\
		(head1)->sqh_last = (head2)->sqh_last;			\
		SIMPLEQ_INIT((head2));					\
	}								\
} while (0)

/*
 * XOR Simple queue definitions.
 */
#define XSIMPLEQ_HEAD(name, type)					\
struct name {								\
	struct type *sqx_first;	/* first element */			\
	struct type **sqx_last;	/* addr of last next element */		\
	unsigned long sqx_cookie;					\
}

#define XSIMPLEQ_ENTRY(type)						\
struct {								\
	struct type *sqx_next;	/* next element */			\
}

/*
 * XOR Simple queue access methods.
 */
#define XSIMPLEQ_XOR(head, ptr)	    ((__typeof(ptr))((head)->sqx_cookie ^ \
					(unsigned long)(ptr)))
#define	XSIMPLEQ_FIRST(head)	    XSIMPLEQ_XOR(head, ((head)->sqx_first))
#define	XSIMPLEQ_END(head)	    NULL
#define	XSIMPLEQ_EMPTY(head)	    (XSIMPLEQ_FIRST(head) == XSIMPLEQ_END(head))
#define	XSIMPLEQ_NEXT(head, elm, field)    XSIMPLEQ_XOR(head, ((elm)->field.sqx_next))


#define XSIMPLEQ_FOREACH(var, head, field)				\
	for ((var) = XSIMPLEQ_FIRST(head);				\
	    (var) != XSIMPLEQ_END(head);				\
	    (var) = XSIMPLEQ_NEXT(head, var, field))

#define	XSIMPLEQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = XSIMPLEQ_FIRST(head);				\
	    (var) && ((tvar) = XSIMPLEQ_NEXT(head, var, field), 1);	\
	    (var) = (tvar))

/*
 * XOR Simple queue functions.
 */
#define	XSIMPLEQ_INIT(head) do {					\
	arc4random_buf(&(head)->sqx_cookie, sizeof((head)->sqx_cookie)); \
	(head)->sqx_first = XSIMPLEQ_XOR(head, NULL);			\
	(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first);	\
} while (0)

#define XSIMPLEQ_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.sqx_next = (head)->sqx_first) ==		\
	    XSIMPLEQ_XOR(head, NULL))					\
		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
	(head)->sqx_first = XSIMPLEQ_XOR(head, (elm));			\
} while (0)

#define XSIMPLEQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.sqx_next = XSIMPLEQ_XOR(head, NULL);		\
	*(XSIMPLEQ_XOR(head, (head)->sqx_last)) = XSIMPLEQ_XOR(head, (elm)); \
	(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);	\
} while (0)

#define XSIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	if (((elm)->field.sqx_next = (listelm)->field.sqx_next) ==	\
	    XSIMPLEQ_XOR(head, NULL))					\
		(head)->sqx_last = XSIMPLEQ_XOR(head, &(elm)->field.sqx_next); \
	(listelm)->field.sqx_next = XSIMPLEQ_XOR(head, (elm));		\
} while (0)

#define XSIMPLEQ_REMOVE_HEAD(head, field) do {				\
	if (((head)->sqx_first = XSIMPLEQ_XOR(head,			\
	    (head)->sqx_first)->field.sqx_next) == XSIMPLEQ_XOR(head, NULL)) \
		(head)->sqx_last = XSIMPLEQ_XOR(head, &(head)->sqx_first); \
} while (0)

#define XSIMPLEQ_REMOVE_AFTER(head, elm, field) do {			\
	if (((elm)->field.sqx_next = XSIMPLEQ_XOR(head,			\
	    (elm)->field.sqx_next)->field.sqx_next)			\
	    == XSIMPLEQ_XOR(head, NULL))				\
		(head)->sqx_last = 					\
		    XSIMPLEQ_XOR(head, &(elm)->field.sqx_next);		\
} while (0)


/*
 * Tail queue definitions.
 */
#define TAILQ_HEAD(name, type)						\
struct name {								\
	struct type *tqh_first;	/* first element */			\
	struct type **tqh_last;	/* addr of last next element */		\
}

#define TAILQ_HEAD_INITIALIZER(head)					\
	{ NULL, &(head).tqh_first }

#define TAILQ_ENTRY(type)						\
struct {								\
	struct type *tqe_next;	/* next element */			\
	struct type **tqe_prev;	/* address of previous next element */	\
}

/*
 * Tail queue access methods.
 */
#define	TAILQ_FIRST(head)		((head)->tqh_first)
#define	TAILQ_END(head)			NULL
#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
#define TAILQ_LAST(head, headname)					\
	(*(((struct headname *)((head)->tqh_last))->tqh_last))
/* XXX */
#define TAILQ_PREV(elm, headname, field)				\
	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))
#define	TAILQ_EMPTY(head)						\
	(TAILQ_FIRST(head) == TAILQ_END(head))

#define TAILQ_FOREACH(var, head, field)					\
	for((var) = TAILQ_FIRST(head);					\
	    (var) != TAILQ_END(head);					\
	    (var) = TAILQ_NEXT(var, field))

#define	TAILQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = TAILQ_FIRST(head);					\
	    (var) != TAILQ_END(head) &&					\
	    ((tvar) = TAILQ_NEXT(var, field), 1);			\
	    (var) = (tvar))


#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
	for((var) = TAILQ_LAST(head, headname);				\
	    (var) != TAILQ_END(head);					\
	    (var) = TAILQ_PREV(var, headname, field))

#define	TAILQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
	for ((var) = TAILQ_LAST(head, headname);			\
	    (var) != TAILQ_END(head) &&					\
	    ((tvar) = TAILQ_PREV(var, headname, field), 1);		\
	    (var) = (tvar))

/*
 * Tail queue functions.
 */
#define	TAILQ_INIT(head) do {						\
	(head)->tqh_first = NULL;					\
	(head)->tqh_last = &(head)->tqh_first;				\
} while (0)

#define TAILQ_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.tqe_next = (head)->tqh_first) != NULL)	\
		(head)->tqh_first->field.tqe_prev =			\
		    &(elm)->field.tqe_next;				\
	else								\
		(head)->tqh_last = &(elm)->field.tqe_next;		\
	(head)->tqh_first = (elm);					\
	(elm)->field.tqe_prev = &(head)->tqh_first;			\
} while (0)

#define TAILQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.tqe_next = NULL;					\
	(elm)->field.tqe_prev = (head)->tqh_last;			\
	*(head)->tqh_last = (elm);					\
	(head)->tqh_last = &(elm)->field.tqe_next;			\
} while (0)

#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	if (((elm)->field.tqe_next = (listelm)->field.tqe_next) != NULL)\
		(elm)->field.tqe_next->field.tqe_prev =			\
		    &(elm)->field.tqe_next;				\
	else								\
		(head)->tqh_last = &(elm)->field.tqe_next;		\
	(listelm)->field.tqe_next = (elm);				\
	(elm)->field.tqe_prev = &(listelm)->field.tqe_next;		\
} while (0)

#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
	(elm)->field.tqe_prev = (listelm)->field.tqe_prev;		\
	(elm)->field.tqe_next = (listelm);				\
	*(listelm)->field.tqe_prev = (elm);				\
	(listelm)->field.tqe_prev = &(elm)->field.tqe_next;		\
} while (0)

#define TAILQ_REMOVE(head, elm, field) do {				\
	if (((elm)->field.tqe_next) != NULL)				\
		(elm)->field.tqe_next->field.tqe_prev =			\
		    (elm)->field.tqe_prev;				\
	else								\
		(head)->tqh_last = (elm)->field.tqe_prev;		\
	*(elm)->field.tqe_prev = (elm)->field.tqe_next;			\
	_Q_INVALIDATE((elm)->field.tqe_prev);				\
	_Q_INVALIDATE((elm)->field.tqe_next);				\
} while (0)

#define TAILQ_REPLACE(head, elm, elm2, field) do {			\
	if (((elm2)->field.tqe_next = (elm)->field.tqe_next) != NULL)	\
		(elm2)->field.tqe_next->field.tqe_prev =		\
		    &(elm2)->field.tqe_next;				\
	else								\
		(head)->tqh_last = &(elm2)->field.tqe_next;		\
	(elm2)->field.tqe_prev = (elm)->field.tqe_prev;			\
	*(elm2)->field.tqe_prev = (elm2);				\
	_Q_INVALIDATE((elm)->field.tqe_prev);				\
	_Q_INVALIDATE((elm)->field.tqe_next);				\
} while (0)

#define TAILQ_CONCAT(head1, head2, field) do {				\
	if (!TAILQ_EMPTY(head2)) {					\
		*(head1)->tqh_last = (head2)->tqh_first;		\
		(head2)->tqh_first->field.tqe_prev = (head1)->tqh_last;	\
		(head1)->tqh_last = (head2)->tqh_last;			\
		TAILQ_INIT((head2));					\
	}								\
} while (0)

#endif	/* !_SYS_QUEUE_H_ */
@


1.43
log
@Remove description of circular queues and add a small blurb about
XOR simple queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.42 2015/11/19 21:03:36 millert Exp $	*/
d37 2
@


1.42
log
@The CIRCLEQ_* macros have been deprecated and removed from queue.3
over a year ago.  It's now time to remove them from queue.h.
OK krw@@ guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.41 2015/11/19 13:38:07 millert Exp $	*/
d40 1
a40 1
 * lists, simple queues, tail queues, and circular queues.
d60 1
a60 1
 * A simple queue is headed by a pair of pointers, one the head of the
d74 4
a77 7
 * A circle queue is headed by a pair of pointers, one to the head of the
 * list and the other to the tail of the list. The elements are doubly
 * linked so that an arbitrary element can be removed without a need to
 * traverse the list. New elements can be added to the list before or after
 * an existing element, at the head of the list, or at the end of the list.
 * A circle queue may be traversed in either direction, but has a more
 * complex end of list detection.
d179 1
a179 1
 * List access methods
d423 1
a423 1
 * tail queue access methods
@


1.41
log
@Add SIMPLEQ_CONCAT and TAILQ_CONCAT for moving one queue onto the end
of another one.  Adapted from FreeBSD.  OK jmc@@ dlg@@ nicm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.40 2015/10/30 12:20:56 jasper Exp $	*/
a533 129
} while (0)

/*
 * Circular queue definitions.
 */
#define CIRCLEQ_HEAD(name, type)					\
struct name {								\
	struct type *cqh_first;		/* first element */		\
	struct type *cqh_last;		/* last element */		\
}

#define CIRCLEQ_HEAD_INITIALIZER(head)					\
	{ CIRCLEQ_END(&head), CIRCLEQ_END(&head) }

#define CIRCLEQ_ENTRY(type)						\
struct {								\
	struct type *cqe_next;		/* next element */		\
	struct type *cqe_prev;		/* previous element */		\
}

/*
 * Circular queue access methods
 */
#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
#define	CIRCLEQ_END(head)		((void *)(head))
#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)
#define	CIRCLEQ_EMPTY(head)						\
	(CIRCLEQ_FIRST(head) == CIRCLEQ_END(head))

#define CIRCLEQ_FOREACH(var, head, field)				\
	for((var) = CIRCLEQ_FIRST(head);				\
	    (var) != CIRCLEQ_END(head);					\
	    (var) = CIRCLEQ_NEXT(var, field))

#define	CIRCLEQ_FOREACH_SAFE(var, head, field, tvar)			\
	for ((var) = CIRCLEQ_FIRST(head);				\
	    (var) != CIRCLEQ_END(head) &&				\
	    ((tvar) = CIRCLEQ_NEXT(var, field), 1);			\
	    (var) = (tvar))

#define CIRCLEQ_FOREACH_REVERSE(var, head, field)			\
	for((var) = CIRCLEQ_LAST(head);					\
	    (var) != CIRCLEQ_END(head);					\
	    (var) = CIRCLEQ_PREV(var, field))

#define	CIRCLEQ_FOREACH_REVERSE_SAFE(var, head, headname, field, tvar)	\
	for ((var) = CIRCLEQ_LAST(head, headname);			\
	    (var) != CIRCLEQ_END(head) && 				\
	    ((tvar) = CIRCLEQ_PREV(var, headname, field), 1);		\
	    (var) = (tvar))

/*
 * Circular queue functions.
 */
#define	CIRCLEQ_INIT(head) do {						\
	(head)->cqh_first = CIRCLEQ_END(head);				\
	(head)->cqh_last = CIRCLEQ_END(head);				\
} while (0)

#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
	(elm)->field.cqe_next = (listelm)->field.cqe_next;		\
	(elm)->field.cqe_prev = (listelm);				\
	if ((listelm)->field.cqe_next == CIRCLEQ_END(head))		\
		(head)->cqh_last = (elm);				\
	else								\
		(listelm)->field.cqe_next->field.cqe_prev = (elm);	\
	(listelm)->field.cqe_next = (elm);				\
} while (0)

#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
	(elm)->field.cqe_next = (listelm);				\
	(elm)->field.cqe_prev = (listelm)->field.cqe_prev;		\
	if ((listelm)->field.cqe_prev == CIRCLEQ_END(head))		\
		(head)->cqh_first = (elm);				\
	else								\
		(listelm)->field.cqe_prev->field.cqe_next = (elm);	\
	(listelm)->field.cqe_prev = (elm);				\
} while (0)

#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {			\
	(elm)->field.cqe_next = (head)->cqh_first;			\
	(elm)->field.cqe_prev = CIRCLEQ_END(head);			\
	if ((head)->cqh_last == CIRCLEQ_END(head))			\
		(head)->cqh_last = (elm);				\
	else								\
		(head)->cqh_first->field.cqe_prev = (elm);		\
	(head)->cqh_first = (elm);					\
} while (0)

#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {			\
	(elm)->field.cqe_next = CIRCLEQ_END(head);			\
	(elm)->field.cqe_prev = (head)->cqh_last;			\
	if ((head)->cqh_first == CIRCLEQ_END(head))			\
		(head)->cqh_first = (elm);				\
	else								\
		(head)->cqh_last->field.cqe_next = (elm);		\
	(head)->cqh_last = (elm);					\
} while (0)

#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
	if ((elm)->field.cqe_next == CIRCLEQ_END(head))			\
		(head)->cqh_last = (elm)->field.cqe_prev;		\
	else								\
		(elm)->field.cqe_next->field.cqe_prev =			\
		    (elm)->field.cqe_prev;				\
	if ((elm)->field.cqe_prev == CIRCLEQ_END(head))			\
		(head)->cqh_first = (elm)->field.cqe_next;		\
	else								\
		(elm)->field.cqe_prev->field.cqe_next =			\
		    (elm)->field.cqe_next;				\
	_Q_INVALIDATE((elm)->field.cqe_prev);				\
	_Q_INVALIDATE((elm)->field.cqe_next);				\
} while (0)

#define CIRCLEQ_REPLACE(head, elm, elm2, field) do {			\
	if (((elm2)->field.cqe_next = (elm)->field.cqe_next) ==		\
	    CIRCLEQ_END(head))						\
		(head)->cqh_last = (elm2);				\
	else								\
		(elm2)->field.cqe_next->field.cqe_prev = (elm2);	\
	if (((elm2)->field.cqe_prev = (elm)->field.cqe_prev) ==		\
	    CIRCLEQ_END(head))						\
		(head)->cqh_first = (elm2);				\
	else								\
		(elm2)->field.cqe_prev->field.cqe_next = (elm2);	\
	_Q_INVALIDATE((elm)->field.cqe_prev);				\
	_Q_INVALIDATE((elm)->field.cqe_next);				\
@


1.40
log
@fix eyesoring trailing whitspace
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.39 2015/10/26 14:12:13 bluhm Exp $	*/
d319 8
d525 9
@


1.39
log
@Let SLIST_REMOVE invalidate the pointer in more cases.
OK jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.38 2013/07/03 15:05:21 fgsch Exp $	*/
d39 1
a39 1
 * This file defines five types of data structures: singly-linked lists, 
d98 1
a98 1
 
d101 1
a101 1
 
d106 1
a106 1
 
d398 1
a398 1
		    
d417 2
a418 2
/* 
 * tail queue access methods 
d538 1
a538 1
 * Circular queue access methods 
@


1.38
log
@Fix CIRCLEQ_REPLACE.  From Michael Piszczek (mpiszczek_at_ddn_dot_com).
guenther@@ otto@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.37 2013/05/03 18:24:01 tedu Exp $	*/
a159 1
		_Q_INVALIDATE((elm)->field.sle_next);			\
d161 1
@


1.37
log
@add an xor cookie variant of simpleq
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.36 2012/04/11 13:29:14 naddy Exp $	*/
d636 1
a636 1
		(head).cqh_last = (elm2);				\
d641 1
a641 1
		(head).cqh_first = (elm2);				\
@


1.36
log
@SLIST_REMOVE_NEXT -> SLIST_REMOVE_AFTER for better consistency and
compatibility with FreeBSD/NetBSD.
Also rename SIMPLEQ_REMOVE_NEXT to SIMPLEQ_REMOVE_AFTER.

ok mikeb@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.35 2012/01/11 00:06:48 bluhm Exp $	*/
d319 80
@


1.35
log
@Remove SLIST_FOREACH_PREVPTR from src tree, it is not used anymore.
ok guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.34 2011/07/09 00:19:45 pirofti Exp $	*/
d142 1
a142 1
#define	SLIST_REMOVE_NEXT(head, elm, field) do {			\
d313 1
a313 1
#define SIMPLEQ_REMOVE_NEXT(head, elm, field) do {			\
@


1.34
log
@Add FOREACH_SAFE() data structure companions.

Part written by me, part taken from FreeBSD.

Okay guenther@@, oga@@ and probably matthew@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.33 2011/07/03 16:08:40 matthew Exp $	*/
a123 5

#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
	for ((varp) = &SLIST_FIRST((head));				\
	    ((var) = *(varp)) != SLIST_END(head);			\
	    (varp) = &SLIST_NEXT((var), field))
@


1.33
log
@Add a SIMPLEQ_REMOVE_NEXT() macro analogous to SLIST_REMOVE_NEXT().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.32 2007/04/30 18:42:34 pedro Exp $	*/
d120 5
d199 5
d282 5
d361 7
d373 6
d478 6
d488 6
@


1.32
log
@Enable QUEUE_MACRO_DEBUG on DIAGNOSTIC kernels.
Input and okays from krw@@, millert@@, otto@@, deraadt@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.31 2005/11/25 08:06:25 otto Exp $	*/
d301 6
@


1.31
log
@Introduce debugging aid for queue macros. Disabled by default; but
developers are encouraged to run with this enabled.
ok krw@@ fgsch@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.30 2005/10/25 06:37:47 otto Exp $	*/
d85 1
a85 1
#ifdef QUEUE_MACRO_DEBUG
@


1.30
log
@Some uvm problem is being exposed with the more strict macros. Revert until
we've found out what's causing the panics.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.27 2005/02/25 13:29:30 deraadt Exp $	*/
d85 6
d160 1
d228 2
d238 2
d394 2
d406 2
d508 2
d523 2
@


1.29
log
@Partly backout. NOLIST, used in LISTs is probably interfering. requested by
deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.28 2005/10/17 20:19:42 otto Exp $	*/
a153 1
		(elm)->field.sle_next = NULL;				\
a228 2
	(elm)->field.le_prev = NULL; 					\
	(elm)->field.le_next = NULL;					\
a382 2
	(elm)->field.tqe_prev = NULL; 					\
	(elm)->field.tqe_next = NULL;					\
a392 2
	(elm)->field.tqe_prev = NULL; 					\
	(elm)->field.tqe_next = NULL;					\
a492 2
	(elm)->field.cqe_next = NULL;					\
	(elm)->field.cqe_prev = NULL;					\
a505 2
	(elm)->field.cqe_next = NULL;					\
	(elm)->field.cqe_prev = NULL;					\
@


1.28
log
@Performing certain operations on queue.h data structurs produced
funny results.  An example is calling  LIST_REMOVE on the same
element twice. This will not fail, but result in a data structure
referencing who knows what. Prevent these accidents by NULLing some
fields on remove and replace. This way, either a panic or segfault
will be produced on the faulty operation.

Tested by many, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.27 2005/02/25 13:29:30 deraadt Exp $	*/
a221 2
	(elm)->field.le_prev = NULL; 					\
	(elm)->field.le_next = NULL;					\
@


1.27
log
@minor white spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.26 2004/05/04 16:59:32 grange Exp $	*/
d154 1
d222 2
d232 2
d388 2
d400 2
d502 2
d517 2
@


1.26
log
@Remove useless ``elm'' argument from the SIMPLEQ_REMOVE_HEAD macro.
This matches our SLIST behaviour and NetBSD's SIMPLEQ as well.

ok millert krw deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.25 2004/04/08 16:08:21 henning Exp $	*/
d147 1
a147 2
	}								\
	else {								\
d149 2
a150 1
		while( curelm->field.sle_next != (elm) )		\
@


1.25
log
@swap the last two parameters to TAILQ_FOREACH_REVERSE. matches what FreeBSD
and NetBSD do.
ok millert@@ mcbride@@ markus@@ ho@@, checked to not affect ports by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.24 2003/12/16 21:08:20 millert Exp $	*/
d287 2
a288 2
#define SIMPLEQ_REMOVE_HEAD(head, elm, field) do {			\
	if (((head)->sqh_first = (elm)->field.sqe_next) == NULL)	\
@


1.24
log
@Add SLIST_FOREACH_PREVPTR and SLIST_REMOVE_NEXT.  SLIST_FOREACH_PREVPTR
is like SLIST_FOREACH but it saves a pointer to the previous element.
SLIST_REMOVE_NEXT will remove the element *after* the one passed in.
SLIST_FOREACH_PREVPTR is from FreeBSD; SLIST_REMOVE_NEXT was suggested
by canacar@@; man page additions by yours truly.  OK deraadt@@ (grudgingly)
and man page changes OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.23 2003/06/02 23:28:21 millert Exp $	*/
d329 1
a329 1
#define TAILQ_FOREACH_REVERSE(var, head, field, headname)		\
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.22 2001/06/23 04:39:35 angelos Exp $	*/
d114 5
d134 4
@


1.22
log
@Having to update queue(3) for DLIST_* is a major PITA; thus, just use
SLIST and be done with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.21 2001/06/23 04:23:05 angelos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@Remove DLIST_INSERT_BEFORE -- unnecessary complication.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.20 2001/06/23 03:53:22 angelos Exp $	*/
a223 64
} while (0)

/*
 * Doubly-linked list with a single head pointer. This is
 * the same as the LIST_* type, except that le_prev of the
 * first element does not point to the list head.
 */
#define DLIST_HEAD(name, type)						\
struct name {								\
	struct type *dh_first;	/* first element */			\
}

#define DLIST_HEAD_INITIALIZER(head)					\
	{ NULL }

#define DLIST_ENTRY(type)						\
struct {								\
	struct type *de_next;	/* next element */	       		\
	struct type **de_prev;	/* address of previous next element */	\
}

/*
 * List access methods
 */
#define	DLIST_FIRST(head)		((head)->dh_first)
#define	DLIST_END(head)			NULL
#define	DLIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
#define	DLIST_NEXT(elm, field)		((elm)->field.de_next)

#define DLIST_FOREACH(var, head, field)					\
	for((var) = DLIST_FIRST(head);					\
	    (var)!= DLIST_END(head);					\
	    (var) = DLIST_NEXT(var, field))

/*
 * List functions.
 */
#define	DLIST_INIT(head) do {						\
	DLIST_FIRST(head) = DLIST_END(head);				\
} while (0)

#define DLIST_INSERT_AFTER(listelm, elm, field) do {			\
	if (((elm)->field.de_next = (listelm)->field.de_next) != NULL)	\
		(listelm)->field.de_next->field.de_prev =		\
		    &(elm)->field.de_next;				\
	(listelm)->field.de_next = (elm);				\
	(elm)->field.de_prev = &(listelm)->field.de_next;		\
} while (0)

#define DLIST_INSERT_HEAD(head, elm, field) do {			\
	if (((elm)->field.de_next = (head)->dh_first) != NULL)		\
		(head)->dh_first->field.de_prev = &(elm)->field.de_next;\
	(head)->dh_first = (elm);					\
	(elm)->field.de_prev = NULL;					\
} while (0)

#define DLIST_REMOVE(head, elm, field) do {				\
	if ((elm)->field.de_next != NULL)				\
		(elm)->field.de_next->field.de_prev =			\
		    (elm)->field.de_prev;				\
	if ((elm)->field.de_prev != NULL)				\
		*(elm)->field.de_prev = (elm)->field.de_next;		\
	else								\
		(head)->dh_first = DLIST_END(head);			\
@


1.20
log
@One of these days, I'll learn to type.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.19 2001/06/23 03:49:06 angelos Exp $	*/
a270 8
} while (0)

#define	DLIST_INSERT_BEFORE(listelm, elm, field) do {			\
	(elm)->field.de_prev = (listelm)->field.de_prev;		\
	(elm)->field.de_next = (listelm);				\
	if ((listelm)->field.de_prev != NULL)				\
		*(listelm)->field.de_prev = (elm);		       	\
	(listelm)->field.de_prev = &(elm)->field.de_next;		\
@


1.19
log
@Typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.18 2001/06/23 03:47:58 angelos Exp $	*/
d284 2
a285 2
	(head)->lh_first = (elm);					\
	(elm)->field.le_prev = NULL;					\
d289 5
a293 5
	if ((elm)->field.le_next != NULL)				\
		(elm)->field.le_next->field.le_prev =			\
		    (elm)->field.le_prev;				\
	if ((elm)->field.le_prev != NULL)				\
		*(elm)->field.le_prev = (elm)->field.le_next;		\
@


1.18
log
@DLIST_* type/operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.17 2000/11/16 20:02:20 provos Exp $	*/
d233 1
a233 1
	struct type dh_first;	/* first element */			\
@


1.17
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.16 2000/09/07 19:47:59 art Exp $	*/
d224 72
@


1.16
log
@Try to unbreak TAILQ_FOREACH_REVERSE.
No tested, but now it should at least build.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.15 2000/04/15 00:20:13 deraadt Exp $	*/
d137 13
@


1.15
log
@fix TAILQ_REPLACE, add TAILQ_FOREACH_REVERSE; alaric@@exoinc.com
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.14 1999/09/08 08:20:04 espie Exp $	*/
d311 2
a312 2
#define TAILQ_FOREACH_REVERSE(var, head, field)				\
	for((var) = TAILQ_LAST(head);					\
d314 1
a314 1
	    (var) = TAILQ_PREV(var, field))
@


1.14
log
@Some new macros:
- import SLIST from FreeBSD
- import *_FOREACH, *_EMPTY... from FreeBSD
- add FOREACH_REVERSE, and various *_REPLACE
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.12 1999/01/08 15:29:32 niklas Exp $	*/
d97 1
a97 1
#define	SLIST_HEAD_INITIALIZER(head) 					\
d114 2
a115 2
	for((var) = SLIST_FIRST(head); 					\
	    (var) != SLIST_END(head); 					\
d161 1
a161 1
#define	LIST_EMPTY(head) 		(LIST_FIRST(head) == LIST_END(head))
d165 2
a166 2
	for((var) = LIST_FIRST(head); 					\
	    (var)!= LIST_END(head); 					\
d200 1
a200 1
		(elm)->field.le_next->field.le_prev = 			\
d239 2
a240 2
	for((var) = SIMPLEQ_FIRST(head); 				\
	    (var) != SIMPLEQ_END(head); 				\
d298 1
a298 1
#define TAILQ_LAST(head, headname) 					\
d301 1
a301 1
#define TAILQ_PREV(elm, headname, field) 				\
d307 2
a308 2
	for((var) = TAILQ_FIRST(head); 					\
	    (var) != TAILQ_END(head); 					\
d311 5
d343 1
a343 1
		(elm)->field.tqe_next->field.tqe_prev = 		\
d360 1
a360 1
		(elm)->field.tqe_next->field.tqe_prev = 		\
d370 1
a370 1
		    &(elm2)->field.le_next;				\
d372 1
a372 1
		(head).tqh_last = &(elm2)->field.tqe_next;		\
d407 2
a408 2
	for((var) = CIRCLEQ_FIRST(head); 				\
	    (var) != CIRCLEQ_END(head); 				\
d412 2
a413 2
	for((var) = CIRCLEQ_LAST(head); 				\
	    (var) != CIRCLEQ_END(head); 				\
@


1.14.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.17 2000/11/16 20:02:20 provos Exp $	*/
d97 1
a97 1
#define	SLIST_HEAD_INITIALIZER(head)					\
d114 2
a115 2
	for((var) = SLIST_FIRST(head);					\
	    (var) != SLIST_END(head);					\
a138 13
#define SLIST_REMOVE(head, elm, type, field) do {			\
	if ((head)->slh_first == (elm)) {				\
		SLIST_REMOVE_HEAD((head), field);			\
	}								\
	else {								\
		struct type *curelm = (head)->slh_first;		\
		while( curelm->field.sle_next != (elm) )		\
			curelm = curelm->field.sle_next;		\
		curelm->field.sle_next =				\
		    curelm->field.sle_next->field.sle_next;		\
	}								\
} while (0)

d161 1
a161 1
#define	LIST_EMPTY(head)		(LIST_FIRST(head) == LIST_END(head))
d165 2
a166 2
	for((var) = LIST_FIRST(head);					\
	    (var)!= LIST_END(head);					\
d200 1
a200 1
		(elm)->field.le_next->field.le_prev =			\
d239 2
a240 2
	for((var) = SIMPLEQ_FIRST(head);				\
	    (var) != SIMPLEQ_END(head);					\
d298 1
a298 1
#define TAILQ_LAST(head, headname)					\
d301 1
a301 1
#define TAILQ_PREV(elm, headname, field)				\
d307 2
a308 2
	for((var) = TAILQ_FIRST(head);					\
	    (var) != TAILQ_END(head);					\
a310 5
#define TAILQ_FOREACH_REVERSE(var, head, field, headname)		\
	for((var) = TAILQ_LAST(head, headname);				\
	    (var) != TAILQ_END(head);					\
	    (var) = TAILQ_PREV(var, headname, field))

d338 1
a338 1
		(elm)->field.tqe_next->field.tqe_prev =			\
d355 1
a355 1
		(elm)->field.tqe_next->field.tqe_prev =			\
d365 1
a365 1
		    &(elm2)->field.tqe_next;				\
d367 1
a367 1
		(head)->tqh_last = &(elm2)->field.tqe_next;		\
d402 2
a403 2
	for((var) = CIRCLEQ_FIRST(head);				\
	    (var) != CIRCLEQ_END(head);					\
d407 2
a408 2
	for((var) = CIRCLEQ_LAST(head);					\
	    (var) != CIRCLEQ_END(head);					\
@


1.14.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.14.4.1 2001/05/14 22:45:03 niklas Exp $	*/
@


1.14.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.14.4.2 2001/07/04 11:00:29 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a113 5
#define	SLIST_FOREACH_PREVPTR(var, varp, head, field)			\
	for ((varp) = &SLIST_FIRST((head));				\
	    ((var) = *(varp)) != SLIST_END(head);			\
	    (varp) = &SLIST_NEXT((var), field))

a128 4
} while (0)

#define	SLIST_REMOVE_NEXT(head, elm, field) do {			\
	(elm)->field.sle_next = (elm)->field.sle_next->field.sle_next;	\
@


1.14.4.5
log
@Merge with the trunk
@
text
@d287 2
a288 2
#define SIMPLEQ_REMOVE_HEAD(head, field) do {			\
	if (((head)->sqh_first = (head)->sqh_first->field.sqe_next) == NULL) \
d329 1
a329 1
#define TAILQ_FOREACH_REVERSE(var, head, headname, field)		\
@


1.13
log
@SIMPLEQ_END for symetry
@
text
@d43 13
a55 2
 * This file defines four types of data structures: lists, simple queues,
 * tail queues, and circular queues.
d66 1
a66 1
 * linked to save space, so only elements can only be removed from the
d90 50
d145 1
a145 1
} 
d156 3
d160 2
d163 5
a167 1
#define	LIST_END(head)			NULL
d173 1
a173 1
	(head)->lh_first = NULL;					\
d205 8
d231 13
a274 9
 * Simple queue access methods.
 */
#define	SIMPLEQ_FIRST(head)		((head)->sqh_first)

#define	SIMPLEQ_NEXT(elm, field)	((elm)->field.sqe_next)

#define	SIMPLEQ_END(head)		NULL

/*
d292 3
a294 1

d296 1
d298 1
a298 2
#define	TAILQ_END(head)			NULL
#define TAILQ_LAST(head, headname) \
d300 2
a301 1
#define TAILQ_PREV(elm, headname, field) \
d303 7
d362 10
d382 1
a382 1
	{ (void *)&head, (void *)&head }
d390 3
d398 12
d415 2
a416 2
	(head)->cqh_first = (void *)(head);				\
	(head)->cqh_last = (void *)(head);				\
d422 1
a422 1
	if ((listelm)->field.cqe_next == (void *)(head))		\
d432 1
a432 1
	if ((listelm)->field.cqe_prev == (void *)(head))		\
d441 2
a442 2
	(elm)->field.cqe_prev = (void *)(head);				\
	if ((head)->cqh_last == (void *)(head))				\
d450 1
a450 1
	(elm)->field.cqe_next = (void *)(head);				\
d452 1
a452 1
	if ((head)->cqh_first == (void *)(head))			\
d460 1
a460 1
	if ((elm)->field.cqe_next == (void *)(head))			\
d465 1
a465 1
	if ((elm)->field.cqe_prev == (void *)(head))			\
d471 14
@


1.12
log
@Initializer macros from Netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.11 1998/09/11 06:28:05 fgsch Exp $	*/
d189 2
@


1.11
log
@Simple queue access methods used in the new pcmcia framework
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.10 1998/07/15 22:11:48 deraadt Exp $	*/
d86 3
d144 3
d199 3
d276 3
@


1.10
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.9 1998/06/02 06:15:45 deraadt Exp $	*/
d176 7
@


1.9
log
@four not three
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.8 1997/11/28 22:50:15 mickey Exp $	*/
d58 1
a58 1
 * list. A simple queue may only be traversed in the forward direection.
@


1.8
log
@one les tab
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.7 1997/11/06 05:59:10 csapuntz Exp $	*/
d43 2
a44 2
 * This file defines three types of data structures: lists, tail queues,
 * and circular queues.
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.6 1997/10/06 20:21:10 deraadt Exp $	*/
d135 1
a135 1
#define SIMPLEQ_HEAD(name, type)						\
d154 1
a154 1
#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {				\
d160 1
a160 1
#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {				\
d172 1
a172 1
#define SIMPLEQ_REMOVE_HEAD(head, elm, field) do {				\
d209 1
a209 1
#define TAILQ_INSERT_HEAD(head, elm, field) do {				\
d219 1
a219 1
#define TAILQ_INSERT_TAIL(head, elm, field) do {				\
d226 1
a226 1
#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {			\
d301 1
a301 1
#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {				\
d311 1
a311 1
#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {				\
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.4 1996/05/22 12:07:15 deraadt Exp $	*/
d65 1
a65 1
 * the list. A tail queue may only be traversed in the forward direction.
d84 1
a84 1
}
d92 4
d99 1
a99 1
#define	LIST_INIT(head) {						\
d101 1
a101 1
}
d103 1
a103 1
#define LIST_INSERT_AFTER(listelm, elm, field) {			\
d109 1
a109 1
}
d111 1
a111 1
#define	LIST_INSERT_BEFORE(listelm, elm, field) {			\
d116 1
a116 1
}
d118 1
a118 1
#define LIST_INSERT_HEAD(head, elm, field) {				\
d123 1
a123 1
}
d125 1
a125 1
#define LIST_REMOVE(elm, field) {					\
d130 1
a130 1
}
d149 1
a149 1
#define	SIMPLEQ_INIT(head) {						\
d152 1
a152 1
}
d154 1
a154 1
#define SIMPLEQ_INSERT_HEAD(head, elm, field) {				\
d158 1
a158 1
}
d160 1
a160 1
#define SIMPLEQ_INSERT_TAIL(head, elm, field) {				\
d164 1
a164 1
}
d166 1
a166 1
#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
d170 1
a170 1
}
d172 1
a172 1
#define SIMPLEQ_REMOVE_HEAD(head, elm, field) {				\
d175 1
a175 1
}
d192 9
d204 1
a204 1
#define	TAILQ_INIT(head) {						\
d207 1
a207 1
}
d209 1
a209 1
#define TAILQ_INSERT_HEAD(head, elm, field) {				\
d217 1
a217 1
}
d219 1
a219 1
#define TAILQ_INSERT_TAIL(head, elm, field) {				\
d224 1
a224 1
}
d226 1
a226 1
#define TAILQ_INSERT_AFTER(head, listelm, elm, field) {			\
d234 1
a234 1
}
d236 1
a236 1
#define	TAILQ_INSERT_BEFORE(listelm, elm, field) {			\
d241 1
a241 1
}
d243 1
a243 1
#define TAILQ_REMOVE(head, elm, field) {				\
d250 1
a250 1
}
d267 6
d276 1
a276 1
#define	CIRCLEQ_INIT(head) {						\
d279 1
a279 1
}
d281 1
a281 1
#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
d289 1
a289 1
}
d291 1
a291 1
#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) {		\
d299 1
a299 1
}
d301 1
a301 1
#define CIRCLEQ_INSERT_HEAD(head, elm, field) {				\
d309 1
a309 1
}
d311 1
a311 1
#define CIRCLEQ_INSERT_TAIL(head, elm, field) {				\
d319 1
a319 1
}
d321 1
a321 1
#define	CIRCLEQ_REMOVE(head, elm, field) {				\
d332 1
a332 1
}
@


1.5
log
@VFS Lite2 Changes
@
text
@d65 1
a65 1
 * the list. A tail queue may be traversed in either direction.
d84 1
a84 1
} 
a91 4
#define	LIST_FIRST(head)		((head)->lh_first)
#define	LIST_NEXT(elm, field)		((elm)->field.le_next)
#define	LIST_END(head)			NULL

d95 1
a95 1
#define	LIST_INIT(head) do {						\
d97 1
a97 1
} while (0)
d99 1
a99 1
#define LIST_INSERT_AFTER(listelm, elm, field) do {			\
d105 1
a105 1
} while (0)
d107 1
a107 1
#define	LIST_INSERT_BEFORE(listelm, elm, field) do {			\
d112 1
a112 1
} while (0)
d114 1
a114 1
#define LIST_INSERT_HEAD(head, elm, field) do {				\
d119 1
a119 1
} while (0)
d121 1
a121 1
#define LIST_REMOVE(elm, field) do {					\
d126 1
a126 1
} while (0)
d145 1
a145 1
#define	SIMPLEQ_INIT(head) do {						\
d148 1
a148 1
} while (0)
d150 1
a150 1
#define SIMPLEQ_INSERT_HEAD(head, elm, field) do {				\
d154 1
a154 1
} while (0)
d156 1
a156 1
#define SIMPLEQ_INSERT_TAIL(head, elm, field) do {				\
d160 1
a160 1
} while (0)
d162 1
a162 1
#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
d166 1
a166 1
} while (0)
d168 1
a168 1
#define SIMPLEQ_REMOVE_HEAD(head, elm, field) do {				\
d171 1
a171 1
} while (0)
a187 9

#define	TAILQ_FIRST(head)		((head)->tqh_first)
#define	TAILQ_NEXT(elm, field)		((elm)->field.tqe_next)
#define	TAILQ_END(head)			NULL
#define TAILQ_LAST(head, headname) \
	(*(((struct headname *)((head)->tqh_last))->tqh_last))
#define TAILQ_PREV(elm, headname, field) \
	(*(((struct headname *)((elm)->field.tqe_prev))->tqh_last))

d191 1
a191 1
#define	TAILQ_INIT(head) do {						\
d194 1
a194 1
} while (0)
d196 1
a196 1
#define TAILQ_INSERT_HEAD(head, elm, field) do {				\
d204 1
a204 1
} while (0)
d206 1
a206 1
#define TAILQ_INSERT_TAIL(head, elm, field) do {				\
d211 1
a211 1
} while (0)
d213 1
a213 1
#define TAILQ_INSERT_AFTER(head, listelm, elm, field) do {			\
d221 1
a221 1
} while (0)
d223 1
a223 1
#define	TAILQ_INSERT_BEFORE(listelm, elm, field) do {			\
d228 1
a228 1
} while (0)
d230 1
a230 1
#define TAILQ_REMOVE(head, elm, field) do {				\
d237 1
a237 1
} while (0)
a253 6
#define	CIRCLEQ_FIRST(head)		((head)->cqh_first)
#define	CIRCLEQ_LAST(head)		((head)->cqh_last)
#define	CIRCLEQ_END(head)		((void *)(head))
#define	CIRCLEQ_NEXT(elm, field)	((elm)->field.cqe_next)
#define	CIRCLEQ_PREV(elm, field)	((elm)->field.cqe_prev)

d257 1
a257 1
#define	CIRCLEQ_INIT(head) do {						\
d260 1
a260 1
} while (0)
d262 1
a262 1
#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) do {		\
d270 1
a270 1
} while (0)
d272 1
a272 1
#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) do {		\
d280 1
a280 1
} while (0)
d282 1
a282 1
#define CIRCLEQ_INSERT_HEAD(head, elm, field) do {				\
d290 1
a290 1
} while (0)
d292 1
a292 1
#define CIRCLEQ_INSERT_TAIL(head, elm, field) do {				\
d300 1
a300 1
} while (0)
d302 1
a302 1
#define	CIRCLEQ_REMOVE(head, elm, field) do {				\
d313 1
a313 1
} while (0)
@


1.4
log
@the linked list argument
@
text
@d1 1
a1 1
/*	$OpenBSD: queue.h,v 1.2 1996/03/03 12:12:10 niklas Exp $	*/
d65 1
a65 1
 * the list. A tail queue may only be traversed in the forward direction.
d84 1
a84 1
}
d92 4
d99 1
a99 1
#define	LIST_INIT(head) {						\
d101 1
a101 1
}
d103 1
a103 1
#define LIST_INSERT_AFTER(listelm, elm, field) {			\
d109 1
a109 1
}
d111 1
a111 1
#define	LIST_INSERT_BEFORE(listelm, elm, field) {			\
d116 1
a116 1
}
d118 1
a118 1
#define LIST_INSERT_HEAD(head, elm, field) {				\
d123 1
a123 1
}
d125 1
a125 1
#define LIST_REMOVE(elm, field) {					\
d130 1
a130 1
}
d149 1
a149 1
#define	SIMPLEQ_INIT(head) {						\
d152 1
a152 1
}
d154 1
a154 1
#define SIMPLEQ_INSERT_HEAD(head, elm, field) {				\
d158 1
a158 1
}
d160 1
a160 1
#define SIMPLEQ_INSERT_TAIL(head, elm, field) {				\
d164 1
a164 1
}
d166 1
a166 1
#define SIMPLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
d170 1
a170 1
}
d172 1
a172 1
#define SIMPLEQ_REMOVE_HEAD(head, elm, field) {				\
d175 1
a175 1
}
d192 9
d204 1
a204 1
#define	TAILQ_INIT(head) {						\
d207 1
a207 1
}
d209 1
a209 1
#define TAILQ_INSERT_HEAD(head, elm, field) {				\
d217 1
a217 1
}
d219 1
a219 1
#define TAILQ_INSERT_TAIL(head, elm, field) {				\
d224 1
a224 1
}
d226 1
a226 1
#define TAILQ_INSERT_AFTER(head, listelm, elm, field) {			\
d234 1
a234 1
}
d236 1
a236 1
#define	TAILQ_INSERT_BEFORE(listelm, elm, field) {			\
d241 1
a241 1
}
d243 1
a243 1
#define TAILQ_REMOVE(head, elm, field) {				\
d250 1
a250 1
}
d267 6
d276 1
a276 1
#define	CIRCLEQ_INIT(head) {						\
d279 1
a279 1
}
d281 1
a281 1
#define CIRCLEQ_INSERT_AFTER(head, listelm, elm, field) {		\
d289 1
a289 1
}
d291 1
a291 1
#define CIRCLEQ_INSERT_BEFORE(head, listelm, elm, field) {		\
d299 1
a299 1
}
d301 1
a301 1
#define CIRCLEQ_INSERT_HEAD(head, elm, field) {				\
d309 1
a309 1
}
d311 1
a311 1
#define CIRCLEQ_INSERT_TAIL(head, elm, field) {				\
d319 1
a319 1
}
d321 1
a321 1
#define	CIRCLEQ_REMOVE(head, elm, field) {				\
d332 1
a332 1
}
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: queue.h,v 1.10 1996/04/09 20:55:34 cgd Exp $	*/
d53 7
d126 45
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: queue.h,v 1.9 1994/12/13 15:04:28 mycroft Exp $	*/
d4 1
a4 1
/* 
@


1.1
log
@Initial revision
@
text
@d1 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
