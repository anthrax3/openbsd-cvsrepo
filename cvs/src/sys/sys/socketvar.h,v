head	1.76;
access;
symbols
	OPENBSD_6_2:1.76.0.2
	OPENBSD_6_2_BASE:1.76
	OPENBSD_6_1:1.69.0.4
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.61.0.2
	OPENBSD_6_0_BASE:1.61
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.58.0.6
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.55.0.10
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.55.0.8
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.55.0.4
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.55.0.2
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.52.0.2
	OPENBSD_5_2_BASE:1.52
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.4
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.48.0.2
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.46.0.4
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.40.0.4
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.40.0.2
	OPENBSD_4_2_BASE:1.40
	OPENBSD_4_1:1.39.0.2
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.38.0.4
	OPENBSD_4_0_BASE:1.38
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.2
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.36.0.2
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.30.0.2
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.30
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.18.0.4
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.17.0.2
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.12.0.4
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2017.09.01.15.05.31;	author mpi;	state Exp;
branches;
next	1.75;
commitid	gLJLYG7mRiAwqMZc;

1.75
date	2017.08.22.09.13.36;	author mpi;	state Exp;
branches;
next	1.74;
commitid	IdpjLkbnfIbzRlk5;

1.74
date	2017.07.12.10.56.47;	author mpi;	state Exp;
branches;
next	1.73;
commitid	iDkel7Q3Vj6zG7lH;

1.73
date	2017.07.08.09.19.02;	author mpi;	state Exp;
branches;
next	1.72;
commitid	5bYsyVcQqSuIdi7J;

1.72
date	2017.07.04.12.58.32;	author mpi;	state Exp;
branches;
next	1.71;
commitid	SVn8rvXqimriZ7Tw;

1.71
date	2017.07.04.12.51.18;	author mpi;	state Exp;
branches;
next	1.70;
commitid	QYpBJWhKtwR5RANd;

1.70
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.69;
commitid	gZMpLuRopIsWa0cT;

1.69
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.68;
commitid	ZsxSSZJSFxZH81LL;

1.68
date	2017.02.14.09.46.21;	author mpi;	state Exp;
branches;
next	1.67;
commitid	4bln7omqWkS0RJo9;

1.67
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.66;
commitid	QqHqT2WhCBWqYgGJ;

1.66
date	2016.11.15.11.57.02;	author bluhm;	state Exp;
branches;
next	1.65;
commitid	TmC8TU5i870QwbIb;

1.65
date	2016.09.04.11.10.19;	author bluhm;	state Exp;
branches;
next	1.64;
commitid	NIGN78QKIIujymRd;

1.64
date	2016.09.03.17.39.50;	author bluhm;	state Exp;
branches;
next	1.63;
commitid	h5Lc3F1YMWLeyax6;

1.63
date	2016.09.03.14.53.17;	author bluhm;	state Exp;
branches;
next	1.62;
commitid	0jB0V6XieElXP75x;

1.62
date	2016.08.25.14.13.19;	author bluhm;	state Exp;
branches;
next	1.61;
commitid	PnBATF8qpqSyZflF;

1.61
date	2016.06.28.14.47.00;	author tedu;	state Exp;
branches;
next	1.60;
commitid	Qxo29L0RKF7XsK5P;

1.60
date	2016.02.25.07.39.09;	author semarie;	state Exp;
branches;
next	1.59;
commitid	TyWXKNME9LGbEn7o;

1.59
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.58;
commitid	19QhHGSTTsDpRV7q;

1.58
date	2015.01.19.19.57.59;	author guenther;	state Exp;
branches;
next	1.57;
commitid	5dezMzwaABWSQArv;

1.57
date	2014.11.03.17.20.46;	author bluhm;	state Exp;
branches;
next	1.56;
commitid	Jo3b0hfgHpuqTRST;

1.56
date	2014.09.09.02.07.17;	author guenther;	state Exp;
branches;
next	1.55;
commitid	8mNtcvWyqXdDfneL;

1.55
date	2013.01.15.11.12.57;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2012.12.31.13.46.49;	author bluhm;	state Exp;
branches;
next	1.53;

1.53
date	2012.09.15.00.47.08;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2012.07.13.10.51.30;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.10.09.40.25;	author claudio;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2011.07.04.00.33.36;	author mikeb;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.24.02.59.46;	author claudio;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.10.16.49.38;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.22.07.47.22;	author otto;	state Exp;
branches;
next	1.44;

1.44
date	2009.01.29.23.59.09;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.07.17.31.24;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.09.16.00.07;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.05.09.04.04;	author dim;	state Exp;
branches;
next	1.39;

1.39
date	2007.02.26.23.53.33;	author kurt;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.21.18.16.46;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.27.17.16.13;	author dhartmei;	state Exp;
branches;
next	1.36;

1.36
date	2004.11.17.13.46.33;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.16.13.11.00;	author markus;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.19.22.38.37;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.04.12.23.58.10;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.10.10.22.27.30;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.08.19.12.33;	author provos;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.11.00.06.33;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.27.22.53.20;	author provos;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.11.27.15.51.36;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.05.08.10.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.05.14.11.04.03;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.01.20.54.35;	author provos;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.16.20.02.20;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.19.08.34.51;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	99.12.08.06.50.24;	author itojun;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	99.02.19.15.06.52;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	99.02.18.22.56.57;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.02.15.19.30.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	99.01.21.03.27.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.02.14.10.55.08;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	97.08.31.20.42.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	97.02.28.04.04.13;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.02.28.02.22.31;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	97.02.28.02.03.33;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	96.08.24.04.56.40;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.08.05.01.00.41;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.07.25.09.46.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.28.18.57.18;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.03.03.12.12.20;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.04.44.04;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.29;	author deraadt;	state Exp;
branches;
next	;

1.17.2.1
date	2001.05.14.22.45.04;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.07.04.11.00.30;	author niklas;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.17.2.7;

1.17.2.7
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.17.2.8;

1.17.2.8
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	1.17.2.9;

1.17.2.9
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Change sosetopt() to no longer free the mbuf it receives and change
all the callers to call m_freem(9).

Support from deraadt@@ and tedu@@, ok visa@@, bluhm@@
@
text
@/*	$OpenBSD: socketvar.h,v 1.75 2017/08/22 09:13:36 mpi Exp $	*/
/*	$NetBSD: socketvar.h,v 1.18 1996/02/09 18:25:38 christos Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)socketvar.h	8.1 (Berkeley) 6/2/93
 */

#include <sys/selinfo.h>			/* for struct selinfo */
#include <sys/queue.h>
#include <sys/task.h>
#include <sys/timeout.h>

#ifndef	_SOCKLEN_T_DEFINED_
#define	_SOCKLEN_T_DEFINED_
typedef	__socklen_t	socklen_t;	/* length type for network syscalls */
#endif

TAILQ_HEAD(soqhead, socket);

/*
 * Kernel structure per socket.
 * Contains send and receive buffer queues,
 * handle on protocol and pointer to protocol
 * private data and error information.
 */
struct socket {
	short	so_type;		/* generic type, see socket.h */
	short	so_options;		/* from socket call, see socket.h */
	short	so_linger;		/* time to linger while closing */
	short	so_state;		/* internal state flags SS_*, below */
	void	*so_pcb;		/* protocol control block */
	struct	protosw *so_proto;	/* protocol handle */
/*
 * Variables for connection queueing.
 * Socket where accepts occur is so_head in all subsidiary sockets.
 * If so_head is 0, socket is not related to an accept.
 * For head socket so_q0 queues partially completed connections,
 * while so_q is a queue of connections ready to be accepted.
 * If a connection is aborted and it has so_head set, then
 * it has to be pulled out of either so_q0 or so_q.
 * We allow connections to queue up based on current queue lengths
 * and limit on number of queued connections for this socket.
 */
	struct	socket	*so_head;	/* back pointer to accept socket */
	struct	soqhead	*so_onq;	/* queue (q or q0) that we're on */
	struct	soqhead	so_q0;		/* queue of partial connections */
	struct	soqhead	so_q;		/* queue of incoming connections */
	TAILQ_ENTRY(socket) so_qe;	/* our queue entry (q or q0) */
	short	so_q0len;		/* partials on so_q0 */
	short	so_qlen;		/* number of connections on so_q */
	short	so_qlimit;		/* max number queued connections */
	short	so_timeo;		/* connection timeout */
	u_short	so_error;		/* error affecting connection */
	pid_t	so_pgid;		/* pgid for signals */
	uid_t	so_siguid;		/* uid of process who set so_pgid */
	uid_t	so_sigeuid;		/* euid of process who set so_pgid */
	u_long	so_oobmark;		/* chars to oob mark */
/*
 * Variables for socket splicing, allocated only when needed.
 */
	struct sosplice {
		struct	socket *ssp_socket;	/* send data to drain socket */
		struct	socket *ssp_soback;	/* back ref to source socket */
		off_t	ssp_len;		/* number of bytes spliced */
		off_t	ssp_max;		/* maximum number of bytes */
		struct	timeval ssp_idletv;	/* idle timeout */
		struct	timeout ssp_idleto;
		struct	task ssp_task;		/* task for somove */
	} *so_sp;
/*
 * Variables for socket buffering.
 */
	struct	sockbuf {
		u_long	sb_cc;		/* actual chars in buffer */
		u_long	sb_datacc;	/* data only chars in buffer */
		u_long	sb_hiwat;	/* max actual char count */
		u_long  sb_wat;		/* default watermark */
		u_long	sb_mbcnt;	/* chars of mbufs used */
		u_long	sb_mbmax;	/* max chars of mbufs to use */
		long	sb_lowat;	/* low water mark */
		struct mbuf *sb_mb;	/* the mbuf chain */
		struct mbuf *sb_mbtail;	/* the last mbuf in the chain */
		struct mbuf *sb_lastrecord;/* first mbuf of last record in
					      socket buffer */
		struct	selinfo sb_sel;	/* process selecting read/write */
		int	sb_flagsintr;	/* flags, changed during interrupt */
		short	sb_flags;	/* flags, see below */
		u_short	sb_timeo;	/* timeout for read/write */
	} so_rcv, so_snd;
#define	SB_MAX		(2*1024*1024)	/* default for max chars in sockbuf */
#define	SB_LOCK		0x01		/* lock on data queue */
#define	SB_WANT		0x02		/* someone is waiting to lock */
#define	SB_WAIT		0x04		/* someone is waiting for data/space */
#define	SB_SEL		0x08		/* someone is selecting */
#define	SB_ASYNC	0x10		/* ASYNC I/O, need signals */
#define	SB_SPLICE	0x20		/* buffer is splice source or drain */
#define	SB_NOINTR	0x40		/* operations not interruptible */
#define	SB_KNOTE	0x80		/* kernel note attached */

	void	(*so_upcall)(struct socket *so, caddr_t arg, int waitf);
	caddr_t	so_upcallarg;		/* Arg for above */
	uid_t	so_euid, so_ruid;	/* who opened the socket */
	gid_t	so_egid, so_rgid;
	pid_t	so_cpid;		/* pid of process that opened socket */
};

/*
 * Socket state bits.
 */
#define	SS_NOFDREF		0x001	/* no file table ref any more */
#define	SS_ISCONNECTED		0x002	/* socket connected to a peer */
#define	SS_ISCONNECTING		0x004	/* in process of connecting to peer */
#define	SS_ISDISCONNECTING	0x008	/* in process of disconnecting */
#define	SS_CANTSENDMORE		0x010	/* can't send more data to peer */
#define	SS_CANTRCVMORE		0x020	/* can't receive more data from peer */
#define	SS_RCVATMARK		0x040	/* at mark on input */
#define	SS_ISDISCONNECTED	0x800	/* socket disconnected from peer */

#define	SS_PRIV			0x080	/* privileged for broadcast, raw... */
#define	SS_NBIO			0x100	/* non-blocking ops */
#define	SS_ASYNC		0x200	/* async i/o notify */
#define	SS_CONNECTOUT		0x1000	/* connect, not accept, at this end */
#define	SS_ISSENDING		0x2000	/* hint for lower layer */
#define	SS_DNS			0x4000	/* created using SOCK_DNS socket(2) */

#ifdef _KERNEL

#include <lib/libkern/libkern.h>

void	soassertlocked(struct socket *);

/*
 * Macros for sockets and socket buffering.
 */

#define isspliced(so)		((so)->so_sp && (so)->so_sp->ssp_socket)
#define issplicedback(so)	((so)->so_sp && (so)->so_sp->ssp_soback)

/*
 * Do we need to notify the other side when I/O is possible?
 */
static inline int
sb_notify(struct socket *so, struct sockbuf *sb)
{
	int flags = (sb->sb_flags | sb->sb_flagsintr);

	KASSERT(sb == &so->so_rcv || sb == &so->so_snd);
	soassertlocked(so);
	return ((flags & (SB_WAIT|SB_SEL|SB_ASYNC|SB_SPLICE|SB_KNOTE)) != 0);
}

/*
 * How much space is there in a socket buffer (so->so_snd or so->so_rcv)?
 * This is problematical if the fields are unsigned, as the space might
 * still be negative (cc > hiwat or mbcnt > mbmax).  Should detect
 * overflow and return 0.
 */
static inline long
sbspace(struct socket *so, struct sockbuf *sb)
{
	KASSERT(sb == &so->so_rcv || sb == &so->so_snd);
#if 0
	/* XXXSMP kqueue_scan() calling filt_sowrite() cannot sleep. */
	soassertlocked(so);
#endif
	return lmin(sb->sb_hiwat - sb->sb_cc, sb->sb_mbmax - sb->sb_mbcnt);
}

/* do we have to send all at once on a socket? */
#define	sosendallatonce(so) \
    ((so)->so_proto->pr_flags & PR_ATOMIC)

/* are we sending on this socket? */
#define	soissending(so) \
    ((so)->so_state & SS_ISSENDING)

/* can we read something from so? */
static inline int
soreadable(struct socket *so)
{
	soassertlocked(so);
	if (isspliced(so))
		return 0;
	return (so->so_state & SS_CANTRCVMORE) || so->so_qlen || so->so_error ||
	    so->so_rcv.sb_cc >= so->so_rcv.sb_lowat;
}

/* can we write something to so? */
#define	sowriteable(so) \
    ((sbspace((so), &(so)->so_snd) >= (so)->so_snd.sb_lowat && \
	(((so)->so_state & SS_ISCONNECTED) || \
	  ((so)->so_proto->pr_flags & PR_CONNREQUIRED)==0)) || \
    ((so)->so_state & SS_CANTSENDMORE) || (so)->so_error)

/* adjust counters in sb reflecting allocation of m */
#define	sballoc(sb, m) do {						\
	(sb)->sb_cc += (m)->m_len;					\
	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME)	\
		(sb)->sb_datacc += (m)->m_len;				\
	(sb)->sb_mbcnt += MSIZE;					\
	if ((m)->m_flags & M_EXT)					\
		(sb)->sb_mbcnt += (m)->m_ext.ext_size;			\
} while (/* CONSTCOND */ 0)

/* adjust counters in sb reflecting freeing of m */
#define	sbfree(sb, m) do {						\
	(sb)->sb_cc -= (m)->m_len;					\
	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME)	\
		(sb)->sb_datacc -= (m)->m_len;				\
	(sb)->sb_mbcnt -= MSIZE;					\
	if ((m)->m_flags & M_EXT)					\
		(sb)->sb_mbcnt -= (m)->m_ext.ext_size;			\
} while (/* CONSTCOND */ 0)

/*
 * Set lock on sockbuf sb; sleep if lock is already held.
 * Unless SB_NOINTR is set on sockbuf, sleep is interruptible.
 * Returns error without lock if sleep is interrupted.
 */
int sblock(struct socket *, struct sockbuf *, int);

/* release lock on sockbuf sb */
void sbunlock(struct sockbuf *);

#define	SB_EMPTY_FIXUP(sb) do {						\
	if ((sb)->sb_mb == NULL) {					\
		(sb)->sb_mbtail = NULL;					\
		(sb)->sb_lastrecord = NULL;				\
	}								\
} while (/*CONSTCOND*/0)

extern u_long sb_max;

extern struct pool	socket_pool;

struct mbuf;
struct sockaddr;
struct proc;
struct msghdr;
struct stat;
struct knote;

/*
 * File operations on sockets.
 */
int	soo_read(struct file *fp, off_t *, struct uio *uio, 
	    struct ucred *cred);
int	soo_write(struct file *fp, off_t *, struct uio *uio,
	    struct ucred *cred);
int	soo_ioctl(struct file *fp, u_long cmd, caddr_t data,
	    struct proc *p);
int	soo_poll(struct file *fp, int events, struct proc *p);
int	soo_kqfilter(struct file *fp, struct knote *kn);
int 	soo_close(struct file *fp, struct proc *p);
int	soo_stat(struct file *, struct stat *, struct proc *);
void	sbappend(struct socket *, struct sockbuf *, struct mbuf *);
void	sbappendstream(struct socket *, struct sockbuf *, struct mbuf *);
int	sbappendaddr(struct socket *, struct sockbuf *, struct sockaddr *,
	    struct mbuf *, struct mbuf *);
int	sbappendcontrol(struct socket *, struct sockbuf *, struct mbuf *,
	    struct mbuf *);
void	sbappendrecord(struct socket *, struct sockbuf *, struct mbuf *);
void	sbcompress(struct sockbuf *sb, struct mbuf *m, struct mbuf *n);
struct mbuf *
	sbcreatecontrol(caddr_t p, int size, int type, int level);
void	sbdrop(struct socket *, struct sockbuf *, int);
void	sbdroprecord(struct sockbuf *sb);
void	sbflush(struct socket *, struct sockbuf *);
void	sbinsertoob(struct sockbuf *sb, struct mbuf *m0);
void	sbrelease(struct socket *, struct sockbuf *);
int	sbcheckreserve(u_long cnt, u_long defcnt);
int	sbchecklowmem(void);
int	sbreserve(struct socket *, struct sockbuf *, u_long);
int	sbwait(struct socket *, struct sockbuf *sb);
int	sb_lock(struct sockbuf *sb);
void	soinit(void);
int	soabort(struct socket *so);
int	soaccept(struct socket *so, struct mbuf *nam);
int	sobind(struct socket *so, struct mbuf *nam, struct proc *p);
void	socantrcvmore(struct socket *so);
void	socantsendmore(struct socket *so);
int	soclose(struct socket *so);
int	soconnect(struct socket *so, struct mbuf *nam);
int	soconnect2(struct socket *so1, struct socket *so2);
int	socreate(int dom, struct socket **aso, int type, int proto);
int	sodisconnect(struct socket *so);
void	sofree(struct socket *so);
int	sogetopt(struct socket *so, int level, int optname, struct mbuf *m);
void	sohasoutofband(struct socket *so);
void	soisconnected(struct socket *so);
void	soisconnecting(struct socket *so);
void	soisdisconnected(struct socket *so);
void	soisdisconnecting(struct socket *so);
int	solisten(struct socket *so, int backlog);
struct socket *sonewconn(struct socket *head, int connstatus);
void	soqinsque(struct socket *head, struct socket *so, int q);
int	soqremque(struct socket *so, int q);
int	soreceive(struct socket *so, struct mbuf **paddr, struct uio *uio,
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp,
	    socklen_t controllen);
int	soreserve(struct socket *so, u_long sndcc, u_long rcvcc);
void	sorflush(struct socket *so);
int	sosend(struct socket *so, struct mbuf *addr, struct uio *uio,
	    struct mbuf *top, struct mbuf *control, int flags);
int	sosetopt(struct socket *so, int level, int optname, struct mbuf *m);
int	soshutdown(struct socket *so, int how);
void	sowakeup(struct socket *so, struct sockbuf *sb);
void	sorwakeup(struct socket *);
void	sowwakeup(struct socket *);
int	sockargs(struct mbuf **, const void *, size_t, int);

int	sosleep(struct socket *, void *, int, const char *, int);
int	solock(struct socket *);
void	sounlock(int);

int	sendit(struct proc *, int, struct msghdr *, int, register_t *);
int	recvit(struct proc *, int, struct msghdr *, caddr_t,
		    register_t *);
int	doaccept(struct proc *, int, struct sockaddr *, socklen_t *, int,
	    register_t *);

#ifdef SOCKBUF_DEBUG
void	sblastrecordchk(struct sockbuf *, const char *);
#define	SBLASTRECORDCHK(sb, where)	sblastrecordchk((sb), (where))

void	sblastmbufchk(struct sockbuf *, const char *);
#define	SBLASTMBUFCHK(sb, where)	sblastmbufchk((sb), (where))
void	sbcheck(struct sockbuf *sb);
#define	SBCHECK(sb)			sbcheck(sb)
#else
#define	SBLASTRECORDCHK(sb, where)	/* nothing */
#define	SBLASTMBUFCHK(sb, where)	/* nothing */
#define	SBCHECK(sb)			/* nothing */
#endif /* SOCKBUF_DEBUG */

#endif /* _KERNEL */
@


1.75
log
@Make sogetopt(9) caller responsible for allocating an MT_SOOPTS mbuf.

Move a blocking memory allocation out of the socket lock and create
a simpler alloc/free pattern to review.  Now both m_get() and m_free()
are in the same place.

Discussed with bluhm@@.

Encouragements from deraadt@@ and tedu@@, ok kettenis@@, florian@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.74 2017/07/12 10:56:47 mpi Exp $	*/
d332 1
a332 2
int	sosetopt(struct socket *so, int level, int optname,
	    struct mbuf *m0);
@


1.74
log
@Kill 'rwlock' forward declaration, this should have been removed with
sbsleep().
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.73 2017/07/08 09:19:02 mpi Exp $	*/
d315 1
a315 2
int	sogetopt(struct socket *so, int level, int optname,
	    struct mbuf **mp);
@


1.73
log
@Revert grabbing the socket lock in kqueue filters.

It is unsafe to sleep while iterating the list of pending events in
kqueue_scan().

Reported by abieber@@ and juanfra@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.72 2017/07/04 12:58:32 mpi Exp $	*/
a240 2

struct rwlock;
@


1.72
log
@Always hold the socket lock when calling sblock().

Implicitely protects `so_state' with the socket lock in sosend().

ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.71 2017/07/04 12:51:18 mpi Exp $	*/
d189 2
d192 1
@


1.71
log
@Assert that the socket lock is held when `so_qlen' is modified.

ok bluhm@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.70 2017/06/26 09:32:32 mpi Exp $	*/
d246 1
a246 1
int sblock(struct sockbuf *, int, struct rwlock *);
@


1.70
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.69 2017/03/13 20:18:21 claudio Exp $	*/
d202 9
a210 5
#define	soreadable(so)	\
    (!isspliced(so) && \
    ((so)->so_rcv.sb_cc >= (so)->so_rcv.sb_lowat || \
    ((so)->so_state & SS_CANTRCVMORE) || \
    (so)->so_qlen || (so)->so_error))
@


1.69
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.68 2017/02/14 09:46:21 mpi Exp $	*/
d154 5
d169 9
a177 2
#define	sb_notify(sb)	((((sb)->sb_flags | (sb)->sb_flagsintr) & \
    (SB_WAIT|SB_SEL|SB_ASYNC|SB_SPLICE|SB_KNOTE)) != 0)
d185 7
a191 2
#define	sbspace(sb) \
    lmin((sb)->sb_hiwat - (sb)->sb_cc, (sb)->sb_mbmax - (sb)->sb_mbcnt)
d210 1
a210 1
    ((sbspace(&(so)->so_snd) >= (so)->so_snd.sb_lowat && \
d278 7
a284 7
void	sbappend(struct sockbuf *sb, struct mbuf *m);
void	sbappendstream(struct sockbuf *sb, struct mbuf *m);
int	sbappendaddr(struct sockbuf *sb, struct sockaddr *asa,
	    struct mbuf *m0, struct mbuf *control);
int	sbappendcontrol(struct sockbuf *sb, struct mbuf *m0,
	    struct mbuf *control);
void	sbappendrecord(struct sockbuf *sb, struct mbuf *m0);
d288 1
a288 1
void	sbdrop(struct sockbuf *sb, int len);
d290 1
a290 1
void	sbflush(struct sockbuf *sb);
d292 1
a292 1
void	sbrelease(struct sockbuf *sb);
d295 1
a295 1
int	sbreserve(struct sockbuf *sb, u_long cc);
a338 1
void	soassertlocked(struct socket *);
@


1.68
log
@Wrap the NET_LOCK() into a per-socket solock() that does nothing for
unix domain sockets.

This should prevent the multiple deadlock related to unix domain sockets.

Inputs from millert@@ and bluhm@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.67 2016/12/19 08:36:50 mpi Exp $	*/
a260 2
int	uipc_usrreq(struct socket *, int , struct mbuf *,
			 struct mbuf *, struct mbuf *, struct proc *);
@


1.67
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.66 2016/11/15 11:57:02 bluhm Exp $	*/
d281 1
a281 1
int	sbwait(struct sockbuf *sb);
d320 5
@


1.66
log
@Bring back the SB_LOCK and SB_WANT flags to lock the socket buffers
in process context.  The read/write lock introduced in rev 1.64
would create lock ordering problems with the upcoming SOCKET_LOCK()
mechanism.  The current tsleep() in sblock() must be replaced with
rwsleep(&socketlock) later.  The sb_flags are protected by
KERNEL_LOCK().  They must not be accessed from interrupt context,
but nowadays softnet() is not an interrupt anyway.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.65 2016/09/04 11:10:19 bluhm Exp $	*/
d218 2
d225 1
a225 1
int sblock(struct sockbuf *, int);
@


1.65
log
@Bring back 2 MB socket buffers to speed up TCP.  This increases
window scale option in TCP-SYN to 6.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.64 2016/09/03 17:39:50 bluhm Exp $	*/
a38 1
#include <sys/rwlock.h>
a112 1
		struct	rwlock sb_lock;	/* exclusive access from process */
d118 2
d223 1
a223 1
int sblock(struct sockbuf *sb, int wf);
d226 1
a226 1
void sbunlock(struct sockbuf *sb);
@


1.64
log
@Switch back to 256 KB socket buffer size for TCP.  With 2 MB the
OS finger printing of pf will no longer recognize OpenBSD as the
window scaling factor has changed.  We have to wait until firewalls
have been updated.
Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.63 2016/09/03 14:53:17 bluhm Exp $	*/
d119 1
a119 1
#define	SB_MAX		(256*1024)	/* default for max chars in sockbuf */
@


1.63
log
@Increase the socket buffer size limit from 256 KB to 2 MB.  This
will speed up TCP connections.  If the value is too high, users may
run out of mbufs.  This should be less likely as we have increased
the mbuf cluster limit.
OK claudio@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.62 2016/08/25 14:13:19 bluhm Exp $	*/
d119 1
a119 1
#define	SB_MAX		(2*1024*1024)	/* default for max chars in sockbuf */
@


1.62
log
@Spliced TCP sockets become faster when the output part is running
as its own task thread.  This is inspired by userland copy where a
process also has to go through the scheduler.  This gives the socket
buffer a chance to be filled up and tcp_output() is called less
often and with bigger chunks.
When two kernel tasks share all the workload, the current scheduler
implementation will hang userland processes on single cpu machines.
As a workaround put a yield() into the splicing thread after each
task execution.  This reduces the number of calls of tcp_output()
even more.
OK tedu@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.61 2016/06/28 14:47:00 tedu Exp $	*/
d119 1
a119 1
#define	SB_MAX		(256*1024)	/* default for max chars in sockbuf */
@


1.61
log
@introduce rwlock for socketbuf instead of the old flag and tsleep dance.
ok mikeb bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.60 2016/02/25 07:39:09 semarie Exp $	*/
d37 1
d96 1
@


1.60
log
@corrects a misleading comment about SS_DNS (and adjust tab)

SS_DNS is now created by using SOCK_DNS with socket(2). dnssocket(2) was removed since October 28.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.59 2015/10/18 00:04:43 deraadt Exp $	*/
d38 1
d112 1
a117 2
#define	SB_LOCK		0x01		/* lock on data queue */
#define	SB_WANT		0x02		/* someone is waiting to lock */
d221 1
a221 3
#define sblock(sb, wf) ((sb)->sb_flags & SB_LOCK ? \
		(((wf) == M_WAITOK) ? sb_lock(sb) : EWOULDBLOCK) : \
		((sb)->sb_flags |= SB_LOCK, 0))
d224 1
a224 7
#define	sbunlock(sb) do {						\
	(sb)->sb_flags &= ~SB_LOCK;					\
	if ((sb)->sb_flags & SB_WANT) {					\
		(sb)->sb_flags &= ~SB_WANT;				\
		wakeup((caddr_t)&(sb)->sb_flags);			\
	}								\
} while (/* CONSTCOND */ 0)
@


1.59
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.58 2015/01/19 19:57:59 guenther Exp $	*/
d149 1
a149 1
#define SS_DNS			0x4000	/* created using dnssocket() */
@


1.58
log
@Move doaccept() declaration from its .c file to sys/socketvar.h for use
by compat/linux
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.57 2014/11/03 17:20:46 bluhm Exp $	*/
d149 1
@


1.57
log
@Put the socket splicing fields into a seperate struct sosplice that
gets only allocated when needed.  This way struct socket shrinks
from 472 to 392 bytes on amd64.  When splicing gets active, another
88 bytes are allocated for struct sosplice.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.56 2014/09/09 02:07:17 guenther Exp $	*/
d327 2
@


1.56
log
@Delete the SS_ISCONFIRMING flag that supported delayed connection
confirmation: it was only used for netiso, which was deleted a *decade* ago

ok mpi@@ claudio@@  ports scan by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.55 2013/01/15 11:12:57 bluhm Exp $	*/
d84 11
a94 7

	struct	socket *so_splice;	/* send data to drain socket */
	struct	socket *so_spliceback;	/* back ref for notify and cleanup */
	off_t	so_splicelen;		/* number of bytes spliced so far */
	off_t	so_splicemax;		/* maximum number of bytes to splice */
	struct	timeval so_idletv;	/* idle timeout */
	struct	timeout so_idleto;
d155 3
d183 1
a183 1
    ((so)->so_splice == NULL && \
@


1.55
log
@Changing the socket buffer flags sb_flags was not interrupt safe
as |= and &= are non-atomic operations.  To avoid additional locks,
put the flags that have to be accessed from interrupt into a separate
sb_flagsintr 32 bit integer field.  sb_flagsintr is protected by
splsoftnet.
Input from miod@@ deraadt@@; OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.54 2012/12/31 13:46:49 bluhm Exp $	*/
a142 1
#define	SS_ISCONFIRMING		0x400	/* deciding to accept connection req */
@


1.54
log
@Put the #ifdef SOCKBUF_DEBUG around sbcheck() into a SBCHECK macro.
That is consistent to the SBLASTRECORDCHK and SBLASTMBUFCHK macros.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.53 2012/09/15 00:47:08 guenther Exp $	*/
d107 1
d117 1
a119 1
#define	SB_SPLICE	0x0100		/* buffer is splice source or drain */
d155 2
a156 2
#define	sb_notify(sb)	(((sb)->sb_flags & (SB_WAIT|SB_SEL|SB_ASYNC| \
    SB_KNOTE|SB_SPLICE)) != 0)
@


1.53
log
@Improve POSIX/SUS compliance of <netdb.h>, <sys/socket.h>, and <sys/un.h>.

Much ports testing of various versions by naddy@@ and jasper@@
ok matthew@@, miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.52 2012/07/13 10:51:30 claudio Exp $	*/
a265 1
void	sbcheck(struct sockbuf *sb);
d327 2
d332 1
@


1.52
log
@Move all the macros defined here into the _KERNEL block since userland
has no use for those. OK bluhm@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.51 2012/07/10 09:40:25 claudio Exp $	*/
d38 5
@


1.51
log
@Try to cleanup the macro magic because of socket spliceing. Since struct
socket is no longer affected by option SOCKET_SPLICE we can simplyfy the
code. OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.50 2011/07/04 22:53:53 tedu Exp $	*/
a121 7
#define	SB_EMPTY_FIXUP(sb) do {						\
	if ((sb)->sb_mb == NULL) {					\
		(sb)->sb_mbtail = NULL;					\
		(sb)->sb_lastrecord = NULL;				\
	}								\
} while (/*CONSTCOND*/0)

d141 1
d221 6
a226 2
void	sorwakeup(struct socket *);
void	sowwakeup(struct socket *);
a227 1
#ifdef _KERNEL
d309 2
@


1.50
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.49 2011/07/04 00:33:36 mikeb Exp $	*/
a79 1
#if 1 /*def SOCKET_SPLICE*/
a85 1
#endif /* SOCKET_SPLICE */
d176 2
a177 1
#define	_soreadable(so) \
d179 2
a180 2
	((so)->so_state & SS_CANTRCVMORE) || \
	(so)->so_qlen || (so)->so_error)
a226 11
#define	_sorwakeup(so) do {						\
	sowakeup((so), &(so)->so_rcv);					\
	if ((so)->so_upcall)						\
		(*((so)->so_upcall))((so), (so)->so_upcallarg,		\
		    M_DONTWAIT);					\
} while (/* CONSTCOND */ 0)

#define	_sowwakeup(so)	sowakeup((so), &(so)->so_snd)

#ifdef SOCKET_SPLICE
#define	soreadable(so)	((so)->so_splice == NULL && _soreadable(so))
a228 5
#else /* SOCKET_SPLICE */
#define	soreadable(so)	_soreadable(so)
#define	sorwakeup(so)	_sorwakeup(so)
#define	sowwakeup(so)	_sowwakeup(so)
#endif /* SOCKET_SPLICE */
@


1.49
log
@Implement an idle timeout for the socket splicing.  A new `sp_idle'
field of the `splice' structure can be used to specify a period of
inactivity after which splicing will be dissolved.  ETIMEDOUT error
retrieved with a SO_ERROR indicates the idle timeout expiration.
With comments from and OK bluhm.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.48 2011/01/07 17:50:42 bluhm Exp $	*/
a116 1
	void	*so_internal;		/* Space for svr4 stream data */
@


1.48
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.47 2010/09/24 02:59:46 claudio Exp $	*/
d37 1
d85 2
@


1.47
log
@TCP send and recv buffer scaling.
Send buffer is scaled by not accounting unacknowledged on the wire
data against the buffer limit. Receive buffer scaling is done similar
to FreeBSD -- measure the delay * bandwith product and base the
buffer on that. The problem is that our RTT measurment is coarse
so it overshoots on low delay links. This does not matter that much
since the recvbuffer is almost always empty.
Add a back pressure mechanism to control the amount of memory
assigned to socketbuffers that kicks in when 80% of the cluster
pool is used.
Increases the download speed from 300kB/s to 4.4MB/s on ftp.eu.openbsd.org.

Based on work by markus@@ and djm@@.

OK dlg@@, henning@@, put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.46 2009/08/10 16:49:38 thib Exp $	*/
d78 7
d112 1
d156 1
a156 1
    SB_KNOTE)) != 0)
d176 1
a176 1
#define	soreadable(so) \
d226 1
a226 1
#define	sorwakeup(so) do {						\
d233 11
a243 1
#define	sowwakeup(so)	sowakeup((so), &(so)->so_snd)
@


1.46
log
@Don't use char arrays for sleep wchans and reuse them.
just use strings and make things unique.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.44 2009/01/29 23:59:09 bluhm Exp $	*/
d85 1
a228 1
struct	socket *sonewconn(struct socket *head, int connstatus);
d271 1
@


1.45
log
@fix PR 6082: do not create more fd's than will fit in the message on
the receiving side when passing fd's. ok deraadt@@ kettenis@@
@
text
@a229 3
/* strings for sleep message: */
extern	const char netio[], netcon[], netcls[];

@


1.44
log
@KNF (whitespace fixes).  ok grunk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.43 2008/11/07 17:31:24 deraadt Exp $	*/
d301 2
a302 1
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp);
@


1.43
log
@use do { } while (/* CONSTCOND */ 0) loops for all multi-line macros
ok dlg otto claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.42 2008/10/09 16:00:07 deraadt Exp $	*/
d175 2
a176 2
	(((so)->so_state&SS_ISCONNECTED) || \
	  ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0)) || \
@


1.42
log
@Change sb_timeo to unsigned, so that even if some calculation (ie. n * HZ)
becomes a very large number it will not wrap the short into a negative
number and screw up timeouts.  It will simply become a max of 65535.  Since
this happens when HZ is cranked to a high number, this will still only take
n seconds, or less.  Safer than crashing.
Prompted by PR 5511
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.41 2008/05/23 15:51:12 thib Exp $	*/
d113 1
a113 2
#define	SB_EMPTY_FIXUP(sb)						\
do {									\
d180 8
a187 8
#define	sballoc(sb, m) { \
	(sb)->sb_cc += (m)->m_len; \
	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME) \
		(sb)->sb_datacc += (m)->m_len; \
	(sb)->sb_mbcnt += MSIZE; \
	if ((m)->m_flags & M_EXT) \
		(sb)->sb_mbcnt += (m)->m_ext.ext_size; \
}
d190 8
a197 8
#define	sbfree(sb, m) { \
	(sb)->sb_cc -= (m)->m_len; \
	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME) \
		(sb)->sb_datacc -= (m)->m_len; \
	(sb)->sb_mbcnt -= MSIZE; \
	if ((m)->m_flags & M_EXT) \
		(sb)->sb_mbcnt -= (m)->m_ext.ext_size; \
}
d209 14
a222 12
#define	sbunlock(sb) { \
	(sb)->sb_flags &= ~SB_LOCK; \
	if ((sb)->sb_flags & SB_WANT) { \
		(sb)->sb_flags &= ~SB_WANT; \
		wakeup((caddr_t)&(sb)->sb_flags); \
	} \
}

#define	sorwakeup(so)	{ sowakeup((so), &(so)->so_rcv); \
			  if ((so)->so_upcall) \
			    (*((so)->so_upcall))((so), (so)->so_upcallarg, M_DONTWAIT); \
			}
@


1.41
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.40 2007/07/05 09:04:04 dim Exp $	*/
d94 1
a94 1
		short	sb_timeo;	/* timeout for read/write */
@


1.40
log
@From FreeBSD:

  Fix a bug in sblock() that has existed since revision 1.1 from BSD:
  correctly return an error if M_NOWAIT is passed to sblock() and the
  operation might block.  This remarkably subtle macro bug appears to
  be responsible for quite a few undiagnosed socket buffer corruption
  and mbuf-related kernel panics.

"diff is correct" todd@@, "should go in asap" markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.39 2007/02/26 23:53:33 kurt Exp $	*/
d255 1
a255 1
			 struct mbuf *, struct mbuf *);
d279 1
a279 1
int	sobind(struct socket *so, struct mbuf *nam);
@


1.39
log
@exclude control data from the number of bytes returned by FIONREAD ioctl()
by adding a sb_datacc count to sockbuf that counts data excluding
MT_CONTROL and MT_SONAME mbuf types.  w/help from deraadt@@.
okay deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.38 2005/11/21 18:16:46 millert Exp $	*/
d207 1
a207 1
		((sb)->sb_flags |= SB_LOCK), 0)
@


1.38
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.37 2005/05/27 17:16:13 dhartmei Exp $	*/
d83 1
d183 2
d193 2
@


1.37
log
@add a field to struct socket that stores the pid of the process that
created the socket, and populate it. ok bob@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.36 2004/11/17 13:46:33 markus Exp $	*/
d35 1
a35 1
#include <sys/select.h>			/* for struct selinfo */
@


1.36
log
@use lmin() instead of imin() in sbspace(), ok henning, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.35 2004/09/16 13:11:00 markus Exp $	*/
d109 1
@


1.35
log
@add hint for lower layer that a sosend() is in progress (SS_ISSENDING)
inspired by a posting from David Borman and similar changes in net/freebsd
ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.34 2004/04/19 22:38:37 deraadt Exp $	*/
d152 1
a152 1
 * overflow and return 0.  Should use "lmin" but it doesn't exist now.
d155 1
a155 2
    ((long) imin((int)((sb)->sb_hiwat - (sb)->sb_cc), \
	 (int)((sb)->sb_mbmax - (sb)->sb_mbcnt)))
@


1.34
log
@this is only a work in progress, we can perfect afterwards, but it is time
to get some experience with these ideas.
add sbcheckreserve() api; called by accepting sockets.  if over 95% of
mbuf clusters are busy, consider this a resource starvation just like the
other reasons for accept failing.  also, if over 50% of mbuf clusters are
busy, shrink recv & send sockbuf reserves to "the minimum".
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.33 2004/04/12 23:58:10 tedu Exp $	*/
d136 1
d161 4
@


1.33
log
@make sockargs take void *, combine a len check.
from pedro martelletto, ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.32 2003/09/23 16:51:13 millert Exp $	*/
d262 1
@


1.32
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.31 2003/06/02 23:28:21 millert Exp $	*/
d298 1
a298 1
int	sockargs(struct mbuf **, caddr_t, socklen_t, int);
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.30 2002/10/10 22:27:30 art Exp $	*/
d240 1
a240 1
int	soo_select(struct file *fp, int which, struct proc *p);
@


1.30
log
@constify a few strings. various@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.29 2002/08/08 19:12:33 provos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@missed in last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.28 2002/07/03 21:19:08 miod Exp $	*/
d224 1
a224 1
extern	char netio[], netcon[], netcls[];
@


1.28
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.27 2002/05/11 00:06:33 deraadt Exp $	*/
d91 4
a94 1
		struct	mbuf *sb_mb;	/* the mbuf chain */
d115 8
d251 1
d307 11
@


1.27
log
@track egid/rgid on bound/connected sockets too (pf will use this)
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.26 2002/03/14 01:27:14 millert Exp $	*/
d209 1
a209 1
u_long	sb_max;
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.25 2001/11/27 22:53:20 provos Exp $	*/
d108 2
a109 2
	uid_t	so_euid;		/* who opened the socket */
	uid_t	so_ruid;		/* who opened the socket */
@


1.25
log
@change socket allocation to pool allocator; from netbsd; okay niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.24 2001/11/27 15:51:36 provos Exp $	*/
d106 1
a106 1
	void	(*so_upcall) __P((struct socket *so, caddr_t arg, int waitf));
d210 1
a210 1
struct	socket *sonewconn __P((struct socket *head, int connstatus));
d227 20
a246 20
int	soo_read __P((struct file *fp, off_t *, struct uio *uio, 
	    struct ucred *cred));
int	soo_write __P((struct file *fp, off_t *, struct uio *uio,
	    struct ucred *cred));
int	soo_ioctl __P((struct file *fp, u_long cmd, caddr_t data,
	    struct proc *p));
int	soo_select __P((struct file *fp, int which, struct proc *p));
int	soo_kqfilter __P((struct file *fp, struct knote *kn));
int 	soo_close __P((struct file *fp, struct proc *p));
int	soo_stat __P((struct file *, struct stat *, struct proc *));
int	uipc_usrreq __P((struct socket *, int , struct mbuf *,
			 struct mbuf *, struct mbuf *));
void	sbappend __P((struct sockbuf *sb, struct mbuf *m));
int	sbappendaddr __P((struct sockbuf *sb, struct sockaddr *asa,
	    struct mbuf *m0, struct mbuf *control));
int	sbappendcontrol __P((struct sockbuf *sb, struct mbuf *m0,
	    struct mbuf *control));
void	sbappendrecord __P((struct sockbuf *sb, struct mbuf *m0));
void	sbcheck __P((struct sockbuf *sb));
void	sbcompress __P((struct sockbuf *sb, struct mbuf *m, struct mbuf *n));
d248 9
a256 9
	sbcreatecontrol __P((caddr_t p, int size, int type, int level));
void	sbdrop __P((struct sockbuf *sb, int len));
void	sbdroprecord __P((struct sockbuf *sb));
void	sbflush __P((struct sockbuf *sb));
void	sbinsertoob __P((struct sockbuf *sb, struct mbuf *m0));
void	sbrelease __P((struct sockbuf *sb));
int	sbreserve __P((struct sockbuf *sb, u_long cc));
int	sbwait __P((struct sockbuf *sb));
int	sb_lock __P((struct sockbuf *sb));
d258 37
a294 37
int	soabort __P((struct socket *so));
int	soaccept __P((struct socket *so, struct mbuf *nam));
int	sobind __P((struct socket *so, struct mbuf *nam));
void	socantrcvmore __P((struct socket *so));
void	socantsendmore __P((struct socket *so));
int	soclose __P((struct socket *so));
int	soconnect __P((struct socket *so, struct mbuf *nam));
int	soconnect2 __P((struct socket *so1, struct socket *so2));
int	socreate __P((int dom, struct socket **aso, int type, int proto));
int	sodisconnect __P((struct socket *so));
void	sofree __P((struct socket *so));
int	sogetopt __P((struct socket *so, int level, int optname,
	    struct mbuf **mp));
void	sohasoutofband __P((struct socket *so));
void	soisconnected __P((struct socket *so));
void	soisconnecting __P((struct socket *so));
void	soisdisconnected __P((struct socket *so));
void	soisdisconnecting __P((struct socket *so));
int	solisten __P((struct socket *so, int backlog));
struct socket *sonewconn __P((struct socket *head, int connstatus));
void	soqinsque __P((struct socket *head, struct socket *so, int q));
int	soqremque __P((struct socket *so, int q));
int	soreceive __P((struct socket *so, struct mbuf **paddr, struct uio *uio,
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp));
int	soreserve __P((struct socket *so, u_long sndcc, u_long rcvcc));
void	sorflush __P((struct socket *so));
int	sosend __P((struct socket *so, struct mbuf *addr, struct uio *uio,
	    struct mbuf *top, struct mbuf *control, int flags));
int	sosetopt __P((struct socket *so, int level, int optname,
	    struct mbuf *m0));
int	soshutdown __P((struct socket *so, int how));
void	sowakeup __P((struct socket *so, struct sockbuf *sb));
int	sockargs __P((struct mbuf **, caddr_t, socklen_t, int));

int	sendit __P((struct proc *, int, struct msghdr *, int, register_t *));
int	recvit __P((struct proc *, int, struct msghdr *, caddr_t,
		    register_t *));
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.25 2001/11/27 22:53:20 provos Exp $	*/
d106 1
a106 1
	void	(*so_upcall)(struct socket *so, caddr_t arg, int waitf);
d108 2
a109 2
	uid_t	so_euid, so_ruid;	/* who opened the socket */
	gid_t	so_egid, so_rgid;
d210 1
a210 1
struct	socket *sonewconn(struct socket *head, int connstatus);
d227 20
a246 20
int	soo_read(struct file *fp, off_t *, struct uio *uio, 
	    struct ucred *cred);
int	soo_write(struct file *fp, off_t *, struct uio *uio,
	    struct ucred *cred);
int	soo_ioctl(struct file *fp, u_long cmd, caddr_t data,
	    struct proc *p);
int	soo_select(struct file *fp, int which, struct proc *p);
int	soo_kqfilter(struct file *fp, struct knote *kn);
int 	soo_close(struct file *fp, struct proc *p);
int	soo_stat(struct file *, struct stat *, struct proc *);
int	uipc_usrreq(struct socket *, int , struct mbuf *,
			 struct mbuf *, struct mbuf *);
void	sbappend(struct sockbuf *sb, struct mbuf *m);
int	sbappendaddr(struct sockbuf *sb, struct sockaddr *asa,
	    struct mbuf *m0, struct mbuf *control);
int	sbappendcontrol(struct sockbuf *sb, struct mbuf *m0,
	    struct mbuf *control);
void	sbappendrecord(struct sockbuf *sb, struct mbuf *m0);
void	sbcheck(struct sockbuf *sb);
void	sbcompress(struct sockbuf *sb, struct mbuf *m, struct mbuf *n);
d248 9
a256 9
	sbcreatecontrol(caddr_t p, int size, int type, int level);
void	sbdrop(struct sockbuf *sb, int len);
void	sbdroprecord(struct sockbuf *sb);
void	sbflush(struct sockbuf *sb);
void	sbinsertoob(struct sockbuf *sb, struct mbuf *m0);
void	sbrelease(struct sockbuf *sb);
int	sbreserve(struct sockbuf *sb, u_long cc);
int	sbwait(struct sockbuf *sb);
int	sb_lock(struct sockbuf *sb);
d258 37
a294 37
int	soabort(struct socket *so);
int	soaccept(struct socket *so, struct mbuf *nam);
int	sobind(struct socket *so, struct mbuf *nam);
void	socantrcvmore(struct socket *so);
void	socantsendmore(struct socket *so);
int	soclose(struct socket *so);
int	soconnect(struct socket *so, struct mbuf *nam);
int	soconnect2(struct socket *so1, struct socket *so2);
int	socreate(int dom, struct socket **aso, int type, int proto);
int	sodisconnect(struct socket *so);
void	sofree(struct socket *so);
int	sogetopt(struct socket *so, int level, int optname,
	    struct mbuf **mp);
void	sohasoutofband(struct socket *so);
void	soisconnected(struct socket *so);
void	soisconnecting(struct socket *so);
void	soisdisconnected(struct socket *so);
void	soisdisconnecting(struct socket *so);
int	solisten(struct socket *so, int backlog);
struct socket *sonewconn(struct socket *head, int connstatus);
void	soqinsque(struct socket *head, struct socket *so, int q);
int	soqremque(struct socket *so, int q);
int	soreceive(struct socket *so, struct mbuf **paddr, struct uio *uio,
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp);
int	soreserve(struct socket *so, u_long sndcc, u_long rcvcc);
void	sorflush(struct socket *so);
int	sosend(struct socket *so, struct mbuf *addr, struct uio *uio,
	    struct mbuf *top, struct mbuf *control, int flags);
int	sosetopt(struct socket *so, int level, int optname,
	    struct mbuf *m0);
int	soshutdown(struct socket *so, int how);
void	sowakeup(struct socket *so, struct sockbuf *sb);
int	sockargs(struct mbuf **, caddr_t, socklen_t, int);

int	sendit(struct proc *, int, struct msghdr *, int, register_t *);
int	recvit(struct proc *, int, struct msghdr *, caddr_t,
		    register_t *);
@


1.25.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.25.2.1 2002/06/11 03:32:33 art Exp $	*/
d91 1
a91 4
		struct mbuf *sb_mb;	/* the mbuf chain */
		struct mbuf *sb_mbtail;	/* the last mbuf in the chain */
		struct mbuf *sb_lastrecord;/* first mbuf of last record in
					      socket buffer */
a111 8
#define	SB_EMPTY_FIXUP(sb)						\
do {									\
	if ((sb)->sb_mb == NULL) {					\
		(sb)->sb_mbtail = NULL;					\
		(sb)->sb_lastrecord = NULL;				\
	}								\
} while (/*CONSTCOND*/0)

d209 1
a209 1
extern u_long sb_max;
d213 1
a213 1
extern	const char netio[], netcon[], netcls[];
a239 1
void	sbappendstream(struct sockbuf *sb, struct mbuf *m);
a294 11

#ifdef SOCKBUF_DEBUG
void	sblastrecordchk(struct sockbuf *, const char *);
#define	SBLASTRECORDCHK(sb, where)	sblastrecordchk((sb), (where))

void	sblastmbufchk(struct sockbuf *, const char *);
#define	SBLASTMBUFCHK(sb, where)	sblastmbufchk((sb), (where))
#else
#define	SBLASTRECORDCHK(sb, where)	/* nothing */
#define	SBLASTMBUFCHK(sb, where)	/* nothing */
#endif /* SOCKBUF_DEBUG */
@


1.24
log
@change socket connection queues to use TAILQ_

from NetBSD:
Wed Jan  7 23:47:08 1998 UTC by thorpej

Make insertion and removal of sockets from the partial and incoming
connections queues O(C) rather than O(N).
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.23 2001/07/05 08:10:31 art Exp $	*/
d215 2
d257 1
@


1.23
log
@It feels a bit pointless to have:
#define        sonewconn(head, connstatus)     sonewconn1((head), (connstatus))

Just wastes preprocessor time.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.22 2001/06/22 14:11:00 deraadt Exp $	*/
d40 3
d68 5
a72 3
	struct	socket *so_head;	/* back pointer to accept socket */
	struct	socket *so_q0;		/* queue of partial connections */
	struct	socket *so_q;		/* queue of incoming connections */
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.21 2001/05/14 11:04:03 art Exp $	*/
d205 1
a205 3
/* to catch callers missing new second argument to sonewconn: */
#define	sonewconn(head, connstatus)	sonewconn1((head), (connstatus))
struct	socket *sonewconn1 __P((struct socket *head, int connstatus));
d269 1
a269 2
struct socket *
	sonewconn1 __P((struct socket *head, int connstatus));
@


1.21
log
@More generic arguments to soo_stat.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.20 2001/03/01 20:54:35 provos Exp $	*/
d160 1
a160 2
     ((so)->so_state & SS_CANTSENDMORE) || \
     (so)->so_error)
d223 1
a223 1
            struct ucred *cred));
d225 1
a225 1
            struct ucred *cred));
d276 1
a276 1
		       struct mbuf **mp0, struct mbuf **controlp, int *flagsp));
@


1.20
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.19 2000/11/16 20:02:20 provos Exp $	*/
d232 1
a232 1
int	soo_stat __P((struct socket *, struct stat *));
@


1.19
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.18 2000/04/19 08:34:51 csapuntz Exp $	*/
d218 1
d230 1
@


1.18
log
@

Change struct file interface methods read and write to pass file offset in
and out.

Make pread/pwrite in netbsd & linux thread safe - which is the whole point
anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.17 1999/12/08 06:50:24 itojun Exp $	*/
d98 1
d132 2
a133 1
#define	sb_notify(sb)	(((sb)->sb_flags & (SB_WAIT|SB_SEL|SB_ASYNC)) != 0)
@


1.17
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.16 1999/02/19 15:06:52 millert Exp $	*/
d220 4
a223 2
int	soo_read __P((struct file *fp, struct uio *uio, struct ucred *cred));
int	soo_write __P((struct file *fp, struct uio *uio, struct ucred *cred));
@


1.17.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.20 2001/03/01 20:54:35 provos Exp $	*/
a97 1
#define	SB_KNOTE	0x80		/* kernel note attached */
d131 1
a131 2
#define	sb_notify(sb)	(((sb)->sb_flags & (SB_WAIT|SB_SEL|SB_ASYNC| \
    SB_KNOTE)) != 0)
a215 1
struct knote;
d220 2
a221 4
int	soo_read __P((struct file *fp, off_t *, struct uio *uio, 
            struct ucred *cred));
int	soo_write __P((struct file *fp, off_t *, struct uio *uio,
            struct ucred *cred));
a224 1
int	soo_kqfilter __P((struct file *fp, struct knote *kn));
@


1.17.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.17.2.1 2001/05/14 22:45:04 niklas Exp $	*/
d160 2
a161 1
    ((so)->so_state & SS_CANTSENDMORE) || (so)->so_error)
d224 1
a224 1
	    struct ucred *cred));
d226 1
a226 1
	    struct ucred *cred));
d232 1
a232 1
int	soo_stat __P((struct file *, struct stat *, struct proc *));
d277 1
a277 1
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp));
@


1.17.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.17.2.2 2001/07/04 11:00:30 niklas Exp $	*/
d205 3
a207 1
struct	socket *sonewconn __P((struct socket *head, int connstatus));
d271 2
a272 1
struct socket *sonewconn __P((struct socket *head, int connstatus));
@


1.17.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 3
#include <sys/queue.h>

TAILQ_HEAD(soqhead, socket);
d65 3
a67 5
	struct	socket	*so_head;	/* back pointer to accept socket */
	struct	soqhead	*so_onq;	/* queue (q or q0) that we're on */
	struct	soqhead	so_q0;		/* queue of partial connections */
	struct	soqhead	so_q;		/* queue of incoming connections */
	TAILQ_ENTRY(socket) so_qe;	/* our queue entry (q or q0) */
a209 2
extern struct pool	socket_pool;

a249 1
void	soinit(void);
@


1.17.2.5
log
@Merge in -current from roughly a week ago
@
text
@d106 1
a106 1
	void	(*so_upcall)(struct socket *so, caddr_t arg, int waitf);
d210 1
a210 1
struct	socket *sonewconn(struct socket *head, int connstatus);
d227 20
a246 20
int	soo_read(struct file *fp, off_t *, struct uio *uio, 
	    struct ucred *cred);
int	soo_write(struct file *fp, off_t *, struct uio *uio,
	    struct ucred *cred);
int	soo_ioctl(struct file *fp, u_long cmd, caddr_t data,
	    struct proc *p);
int	soo_select(struct file *fp, int which, struct proc *p);
int	soo_kqfilter(struct file *fp, struct knote *kn);
int 	soo_close(struct file *fp, struct proc *p);
int	soo_stat(struct file *, struct stat *, struct proc *);
int	uipc_usrreq(struct socket *, int , struct mbuf *,
			 struct mbuf *, struct mbuf *);
void	sbappend(struct sockbuf *sb, struct mbuf *m);
int	sbappendaddr(struct sockbuf *sb, struct sockaddr *asa,
	    struct mbuf *m0, struct mbuf *control);
int	sbappendcontrol(struct sockbuf *sb, struct mbuf *m0,
	    struct mbuf *control);
void	sbappendrecord(struct sockbuf *sb, struct mbuf *m0);
void	sbcheck(struct sockbuf *sb);
void	sbcompress(struct sockbuf *sb, struct mbuf *m, struct mbuf *n);
d248 9
a256 9
	sbcreatecontrol(caddr_t p, int size, int type, int level);
void	sbdrop(struct sockbuf *sb, int len);
void	sbdroprecord(struct sockbuf *sb);
void	sbflush(struct sockbuf *sb);
void	sbinsertoob(struct sockbuf *sb, struct mbuf *m0);
void	sbrelease(struct sockbuf *sb);
int	sbreserve(struct sockbuf *sb, u_long cc);
int	sbwait(struct sockbuf *sb);
int	sb_lock(struct sockbuf *sb);
d258 37
a294 37
int	soabort(struct socket *so);
int	soaccept(struct socket *so, struct mbuf *nam);
int	sobind(struct socket *so, struct mbuf *nam);
void	socantrcvmore(struct socket *so);
void	socantsendmore(struct socket *so);
int	soclose(struct socket *so);
int	soconnect(struct socket *so, struct mbuf *nam);
int	soconnect2(struct socket *so1, struct socket *so2);
int	socreate(int dom, struct socket **aso, int type, int proto);
int	sodisconnect(struct socket *so);
void	sofree(struct socket *so);
int	sogetopt(struct socket *so, int level, int optname,
	    struct mbuf **mp);
void	sohasoutofband(struct socket *so);
void	soisconnected(struct socket *so);
void	soisconnecting(struct socket *so);
void	soisdisconnected(struct socket *so);
void	soisdisconnecting(struct socket *so);
int	solisten(struct socket *so, int backlog);
struct socket *sonewconn(struct socket *head, int connstatus);
void	soqinsque(struct socket *head, struct socket *so, int q);
int	soqremque(struct socket *so, int q);
int	soreceive(struct socket *so, struct mbuf **paddr, struct uio *uio,
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp);
int	soreserve(struct socket *so, u_long sndcc, u_long rcvcc);
void	sorflush(struct socket *so);
int	sosend(struct socket *so, struct mbuf *addr, struct uio *uio,
	    struct mbuf *top, struct mbuf *control, int flags);
int	sosetopt(struct socket *so, int level, int optname,
	    struct mbuf *m0);
int	soshutdown(struct socket *so, int how);
void	sowakeup(struct socket *so, struct sockbuf *sb);
int	sockargs(struct mbuf **, caddr_t, socklen_t, int);

int	sendit(struct proc *, int, struct msghdr *, int, register_t *);
int	recvit(struct proc *, int, struct msghdr *, caddr_t,
		    register_t *);
@


1.17.2.6
log
@Sync the SMP branch with 3.3
@
text
@d91 1
a91 4
		struct mbuf *sb_mb;	/* the mbuf chain */
		struct mbuf *sb_mbtail;	/* the last mbuf in the chain */
		struct mbuf *sb_lastrecord;/* first mbuf of last record in
					      socket buffer */
d108 2
a109 2
	uid_t	so_euid, so_ruid;	/* who opened the socket */
	gid_t	so_egid, so_rgid;
a111 8
#define	SB_EMPTY_FIXUP(sb)						\
do {									\
	if ((sb)->sb_mb == NULL) {					\
		(sb)->sb_mbtail = NULL;					\
		(sb)->sb_lastrecord = NULL;				\
	}								\
} while (/*CONSTCOND*/0)

d209 1
a209 1
extern u_long sb_max;
d213 1
a213 1
extern	const char netio[], netcon[], netcls[];
a239 1
void	sbappendstream(struct sockbuf *sb, struct mbuf *m);
a294 11

#ifdef SOCKBUF_DEBUG
void	sblastrecordchk(struct sockbuf *, const char *);
#define	SBLASTRECORDCHK(sb, where)	sblastrecordchk((sb), (where))

void	sblastmbufchk(struct sockbuf *, const char *);
#define	SBLASTMBUFCHK(sb, where)	sblastmbufchk((sb), (where))
#else
#define	SBLASTRECORDCHK(sb, where)	/* nothing */
#define	SBLASTMBUFCHK(sb, where)	/* nothing */
#endif /* SOCKBUF_DEBUG */
@


1.17.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.17.2.6 2003/03/28 00:41:30 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d240 1
a240 1
int	soo_poll(struct file *fp, int events, struct proc *p);
@


1.17.2.9
log
@Merge with the trunk
@
text
@a261 1
int	sbcheckreserve(u_long cnt, u_long defcnt);
d298 1
a298 1
int	sockargs(struct mbuf **, const void *, size_t, int);
@


1.16
log
@fixed patch for accept/select race; mycroft@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.15 1999/02/18 22:56:57 deraadt Exp $	*/
d237 2
@


1.15
log
@undo select/accept patch, which causes full listen queues apparently
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.14 1999/02/15 19:30:49 millert Exp $	*/
d116 1
@


1.14
log
@sockargs() uses socklen_t for length param
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.13 1999/01/21 03:27:43 millert Exp $	*/
a115 1
#define	SS_ISDISCONNECTED	0x800	/* socket disconnected from peer */
@


1.13
log
@Fixes select(2)/accept(2) race condition which permits DoS; mycroft@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.12 1998/02/14 10:55:08 deraadt Exp $	*/
d278 1
a278 1
int	sockargs __P((struct mbuf **, caddr_t, int, int));
@


1.12
log
@add seperate so_euid & so_ruid to struct socket, so that identd is still fast.. Sigh. I will change this again later
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.11 1997/08/31 20:42:02 deraadt Exp $	*/
d116 1
@


1.11
log
@for non-tty TIOCSPGRP/F_SETOWN/FIOSETOWN pgid setting calls, store uid
and euid as well, then deliver them using new csignal() interface
which ensures that pgid setting process is permitted to signal the
pgid process(es). Thanks to newsham@@aloha.net for extensive help and
discussion.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.10 1997/02/28 04:04:13 angelos Exp $	*/
d102 2
a103 1
	uid_t	so_uid;			/* who opened the socket */
@


1.10
log
@Moved things to netinet/in_pcb.h
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.9 1997/02/28 02:22:31 angelos Exp $	*/
d74 2
@


1.9
log
@More changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.8 1997/02/28 02:03:33 angelos Exp $	*/
a100 4
        u_char  so_seclevel[4];         /* security levels XXX unused byte 3 */
#define SL_AUTH           0             /* Authentication level */
#define SL_ESP_TRANS      1             /* ESP transport level */
#define SL_ESP_NETWORK    2             /* ESP network (encapsulation) level */
@


1.8
log
@IPsec socket API.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.6 1996/08/05 01:00:41 deraadt Exp $	*/
d102 3
a104 3
#define SL_AUTH       0                 /* Authentication level */
#define SL_ESP        1                 /* ESP transport level */
#define SL_NET_ESP    2                 /* ESP network (encapsulation) level */
@


1.7
log
@change to so_uid, also fix a missing credential found by dm
@
text
@d101 4
@


1.6
log
@struct socket gets so_ucred; permit only same uid or root to do port takeover.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.5 1996/07/25 09:46:07 deraadt Exp $	*/
d100 1
a100 1
	struct	ucred *so_ucred;	/* who opened the socket */
@


1.5
log
@SS_CONNECTOUT indicates socket was connect()ed at this end, accept()ed at other end
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.4 1996/04/28 18:57:18 mickey Exp $	*/
d100 1
@


1.4
log
@Remove trailing garbage.
@
text
@d1 1
a1 1
/*	$OpenBSD: socketvar.h,v 1.3 1996/03/03 12:12:20 niklas Exp $	*/
d117 1
a117 1

@


1.3
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a279 6
/*###282 [cc] macro `__P' used with too many (33) args%%%*/
/*###283 [cc] macro `__P' used with too many (34) args%%%*/
/*###284 [cc] macro `__P' used with too many (10) args%%%*/
/*###285 [cc] macro `__P' used with too many (15) args%%%*/
/*###286 [cc] macro `__P' used with too many (22) args%%%*/
/*###289 [cc] empty #if expression%%%*/
@


1.2
log
@from NetBSD: so it compiles now again ;)
@
text
@d1 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: socketvar.h,v 1.16 1995/08/17 02:57:39 mycroft Exp $	*/
d96 1
a96 1
	caddr_t	so_tpcb;		/* Wisc. protocol control block XXX */
d149 1
a149 1
    (sbspace(&(so)->so_snd) >= (so)->so_snd.sb_lowat && \
d151 1
a151 1
	  ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || \
d205 6
d220 3
a222 4

struct mbuf;
struct sockaddr;

d249 1
a249 1
int	sofree __P((struct socket *so));
d263 1
a263 1
	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp));
d272 6
d279 6
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
