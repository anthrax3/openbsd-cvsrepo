head	1.14;
access;
symbols
	OPENBSD_5_6:1.13.0.26
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.13.0.24
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.20
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.18
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.16
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.14
	OPENBSD_5_0:1.13.0.12
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.10
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.8
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.4
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.6
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.2
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.12.0.4
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.24
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.22
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.20
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.18
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.16
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.14
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.14
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.12
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.6
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.4
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2014.10.09.04.05.04;	author tedu;	state dead;
branches;
next	1.13;
commitid	0n74lRqjdhzqrMTv;

1.13
date	2008.11.07.02.23.04;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.03.22.23.35;	author mikeb;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.09.18.20.52;	author ericj;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.07.19.23.32;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	99.07.15.17.44.59;	author art;	state Exp;
branches
	1.9.4.1
	1.9.14.1;
next	1.8;

1.8
date	99.02.19.17.17.49;	author art;	state Exp;
branches;
next	1.7;

1.7
date	97.05.29.22.01.25;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.14.13.01.32;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.29.15.17.34;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.06.21.17.03.25;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	96.06.21.11.33.31;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.11.55;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.27;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	;

1.9.14.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove lkm files
@
text
@/*	$OpenBSD: lkm.h,v 1.13 2008/11/07 02:23:04 deraadt Exp $	*/
/*	$NetBSD: lkm.h,v 1.12 1996/02/09 18:25:13 christos Exp $	*/

/*
 * Header file used by loadable kernel modules and loadable kernel module
 * utilities.
 *
 * 23 Jan 93	Terry Lambert		Original
 *
 * Copyright (c) 1996 Michael Shalayeff
 * Copyright (c) 1992 Terrence R. Lambert.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Terrence R. Lambert.
 * 4. The name Terrence R. Lambert may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _SYS_LKM_H_
#define _SYS_LKM_H_

#include <sys/queue.h>

/*
 * Supported module types
 */
typedef enum loadmod {
	LM_SYSCALL,
	LM_VFS,
	LM_DEV,
	LM_EXEC,
	LM_MISC
} MODTYPE;


#define	LKM_OLDVERSION	1		/* version of module loader */
#define	LKM_VERSION	2		/* version of module loader */
#define	MAXLKMNAME	32

/****************************************************************************/

#ifdef _KERNEL

/*
 * Loadable system call
 */
struct lkm_syscall {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;	/* save/assign area */
	struct sysent  *lkm_sysent;
	struct sysent	lkm_oldent;	/* save area for unload */
};

/*
 * Loadable file system
 */
struct lkm_vfs {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct vfsconf *lkm_vfsconf;
};

/*
 * Supported device module types
 */
typedef enum devtype {
	LM_DT_BLOCK,
	LM_DT_CHAR
} DEVTYPE;

/*
 * Loadable device driver
 */
struct lkm_dev {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	DEVTYPE		lkm_devtype;
	union {
		void		*anon;
		struct bdevsw	*bdev;
		struct cdevsw	*cdev;
	} lkm_dev;
	union {
		struct bdevsw	bdev;
		struct cdevsw	cdev;
	} lkm_olddev;
};

/*
 * Exec loader
 */
struct lkm_exec {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct execsw  *lkm_exec;
	struct execsw	lkm_oldexec;
};

/*
 * Miscellaneous module (complex load/unload, potentially complex stat
 */
struct lkm_misc {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
};

/*
 * Any module (to get type and name info without knowing type)
 */
struct lkm_any {
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
};


/*
 * Generic reference ala XEvent to allow single entry point in the xxxinit()
 * routine.
 */
union lkm_generic {
	struct lkm_any		*lkm_any;
	struct lkm_syscall	*lkm_syscall;
	struct lkm_vfs		*lkm_vfs;
	struct lkm_dev		*lkm_dev;
	struct lkm_exec		*lkm_exec;
	struct lkm_misc		*lkm_misc;
};

/*
 * Per module information structure
 */
struct lkm_table {
	TAILQ_ENTRY(lkm_table)	list;
	int	type;
	u_long	size;
	u_long	offset;
	u_long	area;

	int	ver;		/* version (INIT) */
	int	refcnt;		/* reference count (INIT) */
	int	depcnt;		/* dependency count (INIT) */
	int	id;		/* identifier (INIT) */

	int	(*entry)(struct lkm_table *, int, int);	/* entry function */
	union lkm_generic	private;	/* module private data */

				/* ddb support */
	char	*syms;		/* ? start of symbol table */
	u_long	sym_size;	/* ? size of symbol table */
	u_long	sym_offset;	/* ? offset */
	u_long	sym_symsize;	/* ? symsize */
	char	*sym_addr;	/* ? addr */
	int	sym_id;		/* ? symtab id from ddb */
};


#define	LKM_E_LOAD	1
#define	LKM_E_UNLOAD	2
#define	LKM_E_STAT	3


#define	MOD_SYSCALL(name,callslot,sysentp)	\
	static struct lkm_syscall _module = {	\
		LM_SYSCALL,			\
		LKM_VERSION,			\
		name,				\
		callslot,			\
		sysentp				\
	};

#define	MOD_VFS(name,vfsslot,vfsconf)		\
	static struct lkm_vfs _module = {	\
		LM_VFS,				\
		LKM_VERSION,			\
		name,				\
		vfsslot,			\
		vfsconf				\
	};

#define	MOD_DEV(name,devtype,devslot,devp)	\
	static struct lkm_dev _module = {	\
		LM_DEV,				\
		LKM_VERSION,			\
		name,				\
		devslot,			\
		devtype,			\
		{(void *)devp}			\
	};

#define	MOD_EXEC(name,execslot,execsw)		\
	static struct lkm_exec _module = {	\
		LM_EXEC,			\
		LKM_VERSION,			\
		name,				\
		execslot,			\
		execsw				\
	};

#define	MOD_MISC(name)				\
	static struct lkm_misc _module = {	\
		LM_MISC,			\
		LKM_VERSION,			\
		name				\
	};


extern int lkm_nofunc(struct lkm_table *lkmtp, int cmd);
extern struct lkm_table *lkm_list(struct lkm_table *);
extern int lkmdispatch(struct lkm_table *, int);

/*
 * DISPATCH -- body function for use in module entry point function;
 * generally, the function body will consist entirely of a single
 * DISPATCH line.
 *
 * If load/unload/stat are called on each corresponding entry instance.
 * If no function is desired for load/stat/unload, lkm_nofunc() should
 * be specified.  "cmd" is passed to each function so that a single
 * function can be used if desired.
 */
#define	DISPATCH(lkmtp,cmd,ver,load,unload,stat) do {			\
	if (ver != LKM_VERSION)						\
		return EINVAL;	/* version mismatch */			\
	switch (cmd) {							\
	int	error;							\
	case LKM_E_LOAD:						\
		lkmtp->private.lkm_any = (struct lkm_any *)&_module;	\
		if ((error = load(lkmtp, cmd)) != 0)			\
			return error;					\
		break;							\
	case LKM_E_UNLOAD:						\
		if ((error = unload(lkmtp, cmd)) != 0)			\
			return error;					\
		break;							\
	case LKM_E_STAT:						\
		if ((error = stat(lkmtp, cmd)) != 0)			\
			return error;					\
		break;							\
	}								\
	return lkmdispatch(lkmtp, cmd);					\
} while (/* CONSTCOND */ 0)

extern struct vm_map *lkm_map;

#endif /* _KERNEL */

/****************************************************************************/

/*
 * IOCTL's recognized by /dev/lkm
 */
#define	LMRESERV_O	_IOWR('K', 0, struct lmc_resrv)
#define	LMLOADBUF	_IOW('K', 1, struct lmc_loadbuf)
#define	LMUNRESRV	_IO('K', 2)
#define	LMREADY		_IOW('K', 3, u_long)
#define	LMRESERV	_IOWR('K', 4, struct lmc_resrv)

#define	LMLOAD		_IOW('K', 9, struct lmc_load)
#define	LMUNLOAD	_IOWR('K', 10, struct lmc_unload)
#define	LMSTAT		_IOWR('K', 11, struct lmc_stat)
#define	LMLOADSYMS	_IOW('K', 12, struct lmc_loadbuf)

#define	MODIOBUF	512		/* # of bytes at a time to loadbuf */

/*
 * IOCTL arguments
 */


/*
 * Reserve a page-aligned block of kernel memory for the module
 */
struct lmc_resrv {
	u_long	size;		/* IN: size of module to reserve */
	char	*name;		/* IN: name (must be provided */
	int	slot;		/* OUT: allocated slot (module ID) */
	u_long	addr;		/* OUT: Link-to address */
				/* ddb support */
	char	*syms;		/* ? start of symbol table */
	u_long	sym_size;	/* ? size of symbol table */
	u_long	sym_offset;	/* ? offset */
	u_long	sym_symsize;	/* ? symsize */
	char	*sym_addr;	/* ? addr */
};


/*
 * Copy a buffer at a time into the allocated area in the kernel; writes
 * are assumed to occur contiguously.
 */
struct lmc_loadbuf {
	int	cnt;		/* IN: # of chars pointed to by data */
	char	*data;		/* IN: pointer to data buffer */
};


/*
 * Load a module (assumes it's been mmapped to address before call)
 */
struct lmc_load {
	caddr_t	address;	/* IN: user space mmap address */
	int	status;		/* OUT: status of operation */
	int	id;		/* OUT: module ID if loaded */
};

/*
 * Unload a module (by name/id)
 */
struct lmc_unload {
	int	id;		/* IN: module ID to unload */
	char	*name;		/* IN: module name to unload if id -1 */
	int	status;		/* OUT: status of operation */
};


/*
 * Get module information for a given id (or name if id == -1).
 */
struct lmc_stat {
	int	id;		/* IN: module ID to unload */
	char	*name;		/* IN/OUT: name of module */
	u_long	offset;		/* OUT: target table offset */
	MODTYPE	type;		/* OUT: type of module */
	u_long	area;		/* OUT: kernel load addr */
	u_long	size;		/* OUT: module size (pages) */
	u_long	private;	/* OUT: module private data */
	int	ver;		/* OUT: lkm compile version */
};

#endif	/* !_SYS_LKM_H_ */
@


1.13
log
@wrap do/while construct around the function macro DISPATCH(); ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.12 2007/11/03 22:23:35 mikeb Exp $	*/
@


1.12
log
@Fix LKM support for amd64.

ok deraadt weingart
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.11 2002/01/09 18:20:52 ericj Exp $	*/
d256 1
a256 1
#define	DISPATCH(lkmtp,cmd,ver,load,unload,stat)			\
d275 2
a276 1
	return lkmdispatch(lkmtp, cmd);
@


1.11
log
@
streams gone
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.10 2002/01/07 19:23:32 ericj Exp $	*/
d276 2
@


1.10
log
@
first pass cleanup for lkms
- Use queue.h macros instead of accessing members directly
- Allocate from kernel_map instead of kmem_map
- remove streams
- free memory for syms in lkmunreserve()
- change LMREADY arg to u_long (allow it to work on 64bit systems) - NetBSD
- KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.9 1999/07/15 17:44:59 art Exp $	*/
a53 1
	LM_STRMOD,
a159 1
	struct lkm_strmod	*lkm_strmod;
@


1.9
log
@Fix the MOD_VFS macro to reflect reality.
Bump LKM_VERSION (Argh! I should have done that a few months ago!)
Noted by rees@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.8 1999/02/19 17:17:49 art Exp $	*/
d72 5
a76 5
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;		/* save/assign area */
	struct sysent	*lkm_sysent;
d84 5
a88 5
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
	struct vfsconf	*lkm_vfsconf;
d103 5
a107 5
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
	DEVTYPE	lkm_devtype;
d109 1
a109 1
		void	*anon;
a119 13
 * Loadable streams module
 */
struct lkm_strmod {
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
	/*
	 * Removed: future release
	 */
};

/*
d123 5
a127 5
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
	struct execsw	*lkm_exec;
d135 4
a138 4
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
d145 4
a148 4
	MODTYPE	lkm_type;
	int	lkm_ver;
	char	*lkm_name;
	u_long	lkm_offset;
d181 1
a181 1
	int	(*entry) __P((struct lkm_table *, int, int));/* entry function */
d244 3
a246 3
extern int	lkm_nofunc __P((struct lkm_table *lkmtp, int cmd));
extern struct lkm_table *lkm_list __P((struct lkm_table *));
extern int lkmdispatch __P((struct lkm_table *, int));
d289 1
a289 1
#define	LMREADY		_IOW('K', 3, int)
@


1.9.4.1
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d54 1
d72 5
a76 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;	/* save/assign area */
	struct sysent  *lkm_sysent;
d84 5
a88 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct vfsconf *lkm_vfsconf;
d103 5
a107 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	DEVTYPE		lkm_devtype;
d109 1
a109 1
		void		*anon;
d120 13
d136 5
a140 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct execsw  *lkm_exec;
d148 4
a151 4
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
d158 4
a161 4
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
d174 1
d194 1
a194 1
	int	(*entry)(struct lkm_table *, int, int);	/* entry function */
d257 3
a259 3
extern int lkm_nofunc(struct lkm_table *lkmtp, int cmd);
extern struct lkm_table *lkm_list(struct lkm_table *);
extern int lkmdispatch(struct lkm_table *, int);
d302 1
a302 1
#define	LMREADY		_IOW('K', 3, u_long)
@


1.9.14.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.11 2002/01/09 18:20:52 ericj Exp $	*/
d54 1
d72 5
a76 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;	/* save/assign area */
	struct sysent  *lkm_sysent;
d84 5
a88 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct vfsconf *lkm_vfsconf;
d103 5
a107 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	DEVTYPE		lkm_devtype;
d109 1
a109 1
		void		*anon;
d120 13
d136 5
a140 5
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
	struct execsw  *lkm_exec;
d148 4
a151 4
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
d158 4
a161 4
	MODTYPE		lkm_type;
	int		lkm_ver;
	char	       *lkm_name;
	u_long		lkm_offset;
d174 1
d194 1
a194 1
	int	(*entry)(struct lkm_table *, int, int);	/* entry function */
d257 3
a259 3
extern int lkm_nofunc(struct lkm_table *lkmtp, int cmd);
extern struct lkm_table *lkm_list(struct lkm_table *);
extern int lkmdispatch(struct lkm_table *, int);
d302 1
a302 1
#define	LMREADY		_IOW('K', 3, u_long)
@


1.8
log
@Change the vfs lkm interface do it takes a full struct vfsconf instead of
only struct vfsops.
Use the new vfs_register and vfs_unregister in the vfs lkms.
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.7 1997/05/29 22:01:25 mickey Exp $	*/
d61 1
a61 1
#define	LKM_VERSION	1		/* version of module loader */
d221 1
a221 1
#define	MOD_VFS(name,vfsslot,vfsopsp)		\
d227 1
a227 1
		vfsopsp				\
@


1.7
log
@add sym_id lkm_table member
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.6 1996/10/14 13:01:32 mickey Exp $	*/
d88 1
a88 1
	struct vfsops	*lkm_vfsops;
@


1.6
log
@make gcc -Wall happy for lkms...
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.5 1996/08/29 15:17:34 deraadt Exp $	*/
d203 1
@


1.5
log
@lkm ddb symbol table loading. done during the middle ages by jtkohl, merged
to modern day sources by rees@@umich.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.4 1996/06/21 17:03:25 mickey Exp $	*/
d236 1
a236 1
		(void *)devp			\
d258 1
d277 1
a277 1
		if (error = load(lkmtp, cmd))				\
d281 1
a281 1
		if (error = unload(lkmtp, cmd))				\
d285 1
a285 1
		if (error = stat(lkmtp, cmd))				\
@


1.4
log
@allow LKM listing.
@
text
@d1 1
a1 1
/*	$OpenBSD: lkm.h,v 1.3 1996/06/21 11:33:31 mickey Exp $	*/
d60 1
d196 7
d297 1
a297 1
#define	LMRESERV	_IOWR('K', 0, struct lmc_resrv)
d301 1
d306 1
d323 6
@


1.3
log
@allocate LKM slot dynamically.
prepare to LKM symtabs, cross deps, etc!
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d249 1
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d10 1
d45 2
d182 1
a186 1
	char	used;
d348 8
a355 8
	int	id;			/* IN: module ID to unload */
	char	name[MAXLKMNAME];	/* IN/OUT: name of module */
	u_long	offset;			/* OUT: target table offset */
	MODTYPE	type;			/* OUT: type of module */
	u_long	area;			/* OUT: kernel load addr */
	u_long	size;			/* OUT: module size (pages) */
	u_long	private;		/* OUT: module private data */
	int	ver;			/* OUT: lkm compile version */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: lkm.h,v 1.11 1995/03/26 20:24:19 jtc Exp $	*/
d190 1
a190 1
	int	(*entry)();	/* entry function */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
