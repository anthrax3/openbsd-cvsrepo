head	1.45;
access;
symbols
	OPENBSD_4_9:1.44.0.18
	OPENBSD_4_9_BASE:1.44
	OPENBSD_4_8:1.44.0.16
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.44.0.12
	OPENBSD_4_7_BASE:1.44
	OPENBSD_4_6:1.44.0.14
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.44.0.10
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.44.0.8
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.6
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.44.0.4
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.41.0.4
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.41.0.2
	OPENBSD_3_9_BASE:1.41
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.35.0.4
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.2
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.34.0.2
	OPENBSD_3_5_BASE:1.34
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.27.0.6
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.4
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.27.0.2
	OPENBSD_3_1_BASE:1.27
	UBC_SYNC_B:1.27
	UBC:1.24.0.2
	UBC_BASE:1.24
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.11.0.10
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.11.0.8
	OPENBSD_2_7_BASE:1.11
	SMP:1.11.0.6
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.4
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.2
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.45
date	2011.04.02.16.27.29;	author thib;	state dead;
branches;
next	1.44;

1.44
date	2007.01.16.18.05.46;	author thib;	state Exp;
branches;
next	1.43;

1.43
date	2006.10.16.11.29.51;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.03.19.53.15;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2006.01.02.05.06.50;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.25.13.42.47;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.03.20.14.19;	author drahn;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.03.01.09.35;	author jaredy;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.28.03.06.53;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.22.21.09.48;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.13.21.52.08;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.12.04.41.59;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.23.16.46.41;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2003.07.21.22.45.24;	author tedu;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.04.21.48.01;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.02.18.19.10;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.01.21.14.13;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.14.06.28.29;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2002.02.22.20.54.39;	author drahn;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.10.04.46.24;	author art;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.12.10.04.45.31;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.05.00.25.15;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.04.22.44.32;	author art;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.28.16.25.38;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.28.16.24.26;	author art;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.27.05.30.16;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.02.23.06;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.21.17.23.14;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.01.20.55.47;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.26.17.34.52;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.26.17.13.38;	author art;	state Exp;
branches;
next	1.11;

1.11
date	99.03.03.20.58.56;	author deraadt;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	99.03.03.14.23.43;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.12.05.16.55.01;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.08.30.19.06.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.06.05.59.13;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.20.21.14;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.15.25.36;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.01.26.05.22.14;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.11.50.52;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.19.16.10.38;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.03.26.15.09.33;	author mickey;	state Exp;
branches;
next	;

1.11.6.1
date	2001.05.14.22.45.05;	author niklas;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2001.07.04.11.00.39;	author niklas;	state Exp;
branches;
next	1.11.6.3;

1.11.6.3
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.11.6.4;

1.11.6.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.11.6.5;

1.11.6.5
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.11.6.6;

1.11.6.6
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.11.6.7;

1.11.6.7
date	2003.05.15.04.08.03;	author niklas;	state Exp;
branches;
next	1.11.6.8;

1.11.6.8
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.11.6.9;

1.11.6.9
date	2004.02.19.11.01.35;	author niklas;	state Exp;
branches;
next	;

1.24.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.24.2.3;

1.24.2.3
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@remove the vnode_if.* files, as they are now totally
obsolete.

the move to vfs_vops.c is here to stay, so they are
pointless.
@
text
@/*
 * Warning: This file is generated automatically.
 * (Modifications made here may easily be lost!)
 *
 * Created from the file:
 *	OpenBSD: vnode_if.src,v 1.32 2007/01/16 17:52:18 thib Exp 
 * by the script:
 *	OpenBSD: vnode_if.sh,v 1.15 2006/01/02 05:05:11 jsg Exp 
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

extern struct vnodeop_desc vop_default_desc;

#include "systm.h"

struct vop_islocked_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
};
extern struct vnodeop_desc vop_islocked_desc;
int VOP_ISLOCKED(struct vnode *);

struct vop_lookup_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
};
extern struct vnodeop_desc vop_lookup_desc;
int VOP_LOOKUP(struct vnode *, struct vnode **, struct componentname *);

struct vop_create_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
extern struct vnodeop_desc vop_create_desc;
int VOP_CREATE(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_mknod_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
extern struct vnodeop_desc vop_mknod_desc;
int VOP_MKNOD(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_open_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_open_desc;
int VOP_OPEN(struct vnode *, int, struct ucred *, struct proc *);

struct vop_close_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_close_desc;
int VOP_CLOSE(struct vnode *, int, struct ucred *, struct proc *);

struct vop_access_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_mode;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_access_desc;
int VOP_ACCESS(struct vnode *, int, struct ucred *, struct proc *);

struct vop_getattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_getattr_desc;
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_setattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct vattr *a_vap;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_setattr_desc;
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);

struct vop_read_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
extern struct vnodeop_desc vop_read_desc;
int VOP_READ(struct vnode *, struct uio *, int, struct ucred *);

struct vop_write_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct uio *a_uio;
	int a_ioflag;
	struct ucred *a_cred;
};
extern struct vnodeop_desc vop_write_desc;
int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);

struct vop_ioctl_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	u_long a_command;
	void *a_data;
	int a_fflag;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_ioctl_desc;
int VOP_IOCTL(struct vnode *, u_long, void *, int, struct ucred *, 
    struct proc *);

struct vop_poll_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_events;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_poll_desc;
int VOP_POLL(struct vnode *, int, struct proc *);

struct vop_kqfilter_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct knote *a_kn;
};
extern struct vnodeop_desc vop_kqfilter_desc;
int VOP_KQFILTER(struct vnode *, struct knote *);

struct vop_revoke_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_flags;
};
extern struct vnodeop_desc vop_revoke_desc;
int VOP_REVOKE(struct vnode *, int);

struct vop_fsync_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct ucred *a_cred;
	int a_waitfor;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_fsync_desc;
int VOP_FSYNC(struct vnode *, struct ucred *, int, struct proc *);

struct vop_remove_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
extern struct vnodeop_desc vop_remove_desc;
int VOP_REMOVE(struct vnode *, struct vnode *, struct componentname *);

struct vop_link_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
extern struct vnodeop_desc vop_link_desc;
int VOP_LINK(struct vnode *, struct vnode *, struct componentname *);

struct vop_rename_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_fdvp;
	struct vnode *a_fvp;
	struct componentname *a_fcnp;
	struct vnode *a_tdvp;
	struct vnode *a_tvp;
	struct componentname *a_tcnp;
};
extern struct vnodeop_desc vop_rename_desc;
int VOP_RENAME(struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *);

struct vop_mkdir_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
};
extern struct vnodeop_desc vop_mkdir_desc;
int VOP_MKDIR(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);

struct vop_rmdir_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode *a_vp;
	struct componentname *a_cnp;
};
extern struct vnodeop_desc vop_rmdir_desc;
int VOP_RMDIR(struct vnode *, struct vnode *, struct componentname *);

struct vop_symlink_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct vnode **a_vpp;
	struct componentname *a_cnp;
	struct vattr *a_vap;
	char *a_target;
};
extern struct vnodeop_desc vop_symlink_desc;
int VOP_SYMLINK(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *, char *);

struct vop_readdir_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
	int *a_eofflag;
	int *a_ncookies;
	u_long **a_cookies;
};
extern struct vnodeop_desc vop_readdir_desc;
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, int *, 
    u_long **);

struct vop_readlink_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct uio *a_uio;
	struct ucred *a_cred;
};
extern struct vnodeop_desc vop_readlink_desc;
int VOP_READLINK(struct vnode *, struct uio *, struct ucred *);

struct vop_abortop_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct componentname *a_cnp;
};
extern struct vnodeop_desc vop_abortop_desc;
int VOP_ABORTOP(struct vnode *, struct componentname *);

struct vop_inactive_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_inactive_desc;
int VOP_INACTIVE(struct vnode *, struct proc *);

struct vop_reclaim_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_reclaim_desc;
int VOP_RECLAIM(struct vnode *, struct proc *);

struct vop_lock_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_flags;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_lock_desc;
int VOP_LOCK(struct vnode *, int, struct proc *);

struct vop_unlock_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_flags;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_unlock_desc;
int VOP_UNLOCK(struct vnode *, int, struct proc *);

struct vop_bmap_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	daddr64_t a_bn;
	struct vnode **a_vpp;
	daddr64_t *a_bnp;
	int *a_runp;
};
extern struct vnodeop_desc vop_bmap_desc;
int VOP_BMAP(struct vnode *, daddr64_t, struct vnode **, daddr64_t *, int *);

struct vop_print_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
};
extern struct vnodeop_desc vop_print_desc;
int VOP_PRINT(struct vnode *);

struct vop_pathconf_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_name;
	register_t *a_retval;
};
extern struct vnodeop_desc vop_pathconf_desc;
int VOP_PATHCONF(struct vnode *, int, register_t *);

struct vop_advlock_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	void *a_id;
	int a_op;
	struct flock *a_fl;
	int a_flags;
};
extern struct vnodeop_desc vop_advlock_desc;
int VOP_ADVLOCK(struct vnode *, void *, int, struct flock *, int);

struct vop_reallocblks_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct cluster_save *a_buflist;
};
extern struct vnodeop_desc vop_reallocblks_desc;
int VOP_REALLOCBLKS(struct vnode *, struct cluster_save *);

/* Special cases: */
#include <sys/buf.h>

struct vop_strategy_args {
	struct vnodeop_desc *a_desc;
	struct buf *a_bp;
};
extern struct vnodeop_desc vop_strategy_desc;
int VOP_STRATEGY(struct buf *);

struct vop_bwrite_args {
	struct vnodeop_desc *a_desc;
	struct buf *a_bp;
};
extern struct vnodeop_desc vop_bwrite_desc;
int VOP_BWRITE(struct buf *);

/* End of special cases. */
@


1.44
log
@regen
@
text
@@


1.43
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.31 2006/10/16 11:27:53 pedro Exp 
a150 10

struct vop_lease_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
	struct ucred *a_cred;
	int a_flag;
};
extern struct vnodeop_desc vop_lease_desc;
int VOP_LEASE(struct vnode *, struct proc *, struct ucred *, int);
@


1.42
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.30 2006/10/03 19:49:06 pedro Exp 
d340 1
a340 1
	daddr_t a_bn;
d346 1
a346 1
int VOP_BMAP(struct vnode *, daddr_t, struct vnode **, daddr64_t *, int *);
@


1.41
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.29 2005/07/14 09:04:59 pedro Exp 
d342 1
a342 1
	daddr_t *a_bnp;
d346 1
a346 1
int VOP_BMAP(struct vnode *, daddr_t, struct vnode **, daddr_t *, int *);
@


1.40
log
@built files should be checked in after the source file
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.14 2005/05/22 21:07:23 pedro Exp 
@


1.39
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.28 2005/07/03 20:14:00 drahn Exp 
@


1.38
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.27 2005/07/03 01:07:44 jaredy Exp 
a381 27

struct vop_getextattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	size_t *a_size;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_getextattr_desc;
int VOP_GETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    size_t *, struct ucred *, struct proc *);

struct vop_setextattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_setextattr_desc;
int VOP_SETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    struct ucred *, struct proc *);
@


1.37
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.26 2005/05/28 03:05:44 pedro Exp 
@


1.36
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.25 2005/05/22 21:08:21 pedro Exp 
a381 9

struct vop_whiteout_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_dvp;
	struct componentname *a_cnp;
	int a_flags;
};
extern struct vnodeop_desc vop_whiteout_desc;
int VOP_WHITEOUT(struct vnode *, struct componentname *, int);
@


1.35
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
@


1.34
log
@these need to be synced when vnode_if.src changes
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.24 2003/11/08 19:17:28 jmc Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.13 2003/06/02 23:28:07 millert Exp 
@


1.33
log
@regen (Prepare for conversion of select backend -> poll)
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.23 2003/09/23 16:46:02 millert Exp 
@


1.32
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.22 2003/07/21 22:44:50 tedu Exp 
d175 1
a175 1
struct vop_select_args {
d178 1
a178 3
	int a_which;
	int a_fflags;
	struct ucred *a_cred;
d181 2
a182 2
extern struct vnodeop_desc vop_select_desc;
int VOP_SELECT(struct vnode *, int, int, struct ucred *, struct proc *);
@


1.31
log
@mop up some more 3/4 license issues
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.20 2003/05/01 21:13:05 tedu Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.12 2003/05/01 21:41:35 tedu Exp 
d166 1
a166 1
	caddr_t a_data;
d172 1
a172 1
int VOP_IOCTL(struct vnode *, u_long, caddr_t, int, struct ucred *, 
d369 1
a369 1
	caddr_t a_id;
d375 1
a375 1
int VOP_ADVLOCK(struct vnode *, caddr_t, int, struct flock *, int);
@


1.30
log
@sync
@
text
@d23 1
a23 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.11 2003/05/01 21:13:05 tedu Exp 
@


1.28
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.19 2002/02/22 20:37:45 drahn Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.10 2002/03/14 23:47:05 millert Exp 
@


1.27
log
@First round of __P removal in sys
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
d124 1
a124 2
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, 
    struct proc *);
d134 1
a134 2
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, 
    struct proc *);
d276 2
a277 2
int VOP_SYMLINK(struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *, char *);
d289 2
a290 2
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, 
    int *, u_long **);
@


1.26
log
@EA sync
@
text
@d53 1
a53 1
int VOP_ISLOCKED __P((struct vnode *));
d62 1
a62 1
int VOP_LOOKUP __P((struct vnode *, struct vnode **, struct componentname *));
d72 2
a73 2
int VOP_CREATE __P((struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *));
d83 2
a84 2
int VOP_MKNOD __P((struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *));
d94 1
a94 1
int VOP_OPEN __P((struct vnode *, int, struct ucred *, struct proc *));
d104 1
a104 1
int VOP_CLOSE __P((struct vnode *, int, struct ucred *, struct proc *));
d114 1
a114 1
int VOP_ACCESS __P((struct vnode *, int, struct ucred *, struct proc *));
d124 2
a125 2
int VOP_GETATTR __P((struct vnode *, struct vattr *, struct ucred *, 
    struct proc *));
d135 2
a136 2
int VOP_SETATTR __P((struct vnode *, struct vattr *, struct ucred *, 
    struct proc *));
d146 1
a146 1
int VOP_READ __P((struct vnode *, struct uio *, int, struct ucred *));
d156 1
a156 1
int VOP_WRITE __P((struct vnode *, struct uio *, int, struct ucred *));
d166 1
a166 1
int VOP_LEASE __P((struct vnode *, struct proc *, struct ucred *, int));
d178 2
a179 2
int VOP_IOCTL __P((struct vnode *, u_long, caddr_t, int, struct ucred *, 
    struct proc *));
d190 1
a190 1
int VOP_SELECT __P((struct vnode *, int, int, struct ucred *, struct proc *));
d198 1
a198 1
int VOP_KQFILTER __P((struct vnode *, struct knote *));
d206 1
a206 1
int VOP_REVOKE __P((struct vnode *, int));
d216 1
a216 1
int VOP_FSYNC __P((struct vnode *, struct ucred *, int, struct proc *));
d225 1
a225 1
int VOP_REMOVE __P((struct vnode *, struct vnode *, struct componentname *));
d234 1
a234 1
int VOP_LINK __P((struct vnode *, struct vnode *, struct componentname *));
d246 2
a247 2
int VOP_RENAME __P((struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *));
d257 2
a258 2
int VOP_MKDIR __P((struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *));
d267 1
a267 1
int VOP_RMDIR __P((struct vnode *, struct vnode *, struct componentname *));
d278 2
a279 2
int VOP_SYMLINK __P((struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *, char *));
d291 2
a292 2
int VOP_READDIR __P((struct vnode *, struct uio *, struct ucred *, int *, 
    int *, u_long **));
d301 1
a301 1
int VOP_READLINK __P((struct vnode *, struct uio *, struct ucred *));
d309 1
a309 1
int VOP_ABORTOP __P((struct vnode *, struct componentname *));
d317 1
a317 1
int VOP_INACTIVE __P((struct vnode *, struct proc *));
d325 1
a325 1
int VOP_RECLAIM __P((struct vnode *, struct proc *));
d334 1
a334 1
int VOP_LOCK __P((struct vnode *, int, struct proc *));
d343 1
a343 1
int VOP_UNLOCK __P((struct vnode *, int, struct proc *));
d354 1
a354 1
int VOP_BMAP __P((struct vnode *, daddr_t, struct vnode **, daddr_t *, int *));
d361 1
a361 1
int VOP_PRINT __P((struct vnode *));
d370 1
a370 1
int VOP_PATHCONF __P((struct vnode *, int, register_t *));
d381 1
a381 1
int VOP_ADVLOCK __P((struct vnode *, caddr_t, int, struct flock *, int));
d389 1
a389 1
int VOP_REALLOCBLKS __P((struct vnode *, struct cluster_save *));
d398 1
a398 1
int VOP_WHITEOUT __P((struct vnode *, struct componentname *, int));
d411 2
a412 2
int VOP_GETEXTATTR __P((struct vnode *, int, const char *, struct uio *, 
    size_t *, struct ucred *, struct proc *));
d424 2
a425 2
int VOP_SETEXTATTR __P((struct vnode *, int, const char *, struct uio *, 
    struct ucred *, struct proc *));
d435 1
a435 1
int VOP_STRATEGY __P((struct buf *));
d442 1
a442 1
int VOP_BWRITE __P((struct buf *));
@


1.25
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d399 27
@


1.24
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.17 2001/12/10 04:45:31 art Exp 
a398 36

struct vop_getpages_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	voff_t a_offset;
	struct vm_page **a_m;
	int *a_count;
	int a_centeridx;
	vm_prot_t a_access_type;
	int a_advice;
	int a_flags;
};
extern struct vnodeop_desc vop_getpages_desc;
int VOP_GETPAGES __P((struct vnode *, voff_t, struct vm_page **, int *, int, 
    vm_prot_t, int, int));

struct vop_putpages_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct vm_page **a_m;
	int a_count;
	int a_flags;
	int *a_rtvals;
};
extern struct vnodeop_desc vop_putpages_desc;
int VOP_PUTPAGES __P((struct vnode *, struct vm_page **, int, int, int *));

struct vop_mmap_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_fflags;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_mmap_desc;
int VOP_MMAP __P((struct vnode *, int, struct ucred *, struct proc *));
@


1.24.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d418 2
a419 2
	voff_t a_offlo;
	voff_t a_offhi;
d421 1
d424 1
a424 1
int VOP_PUTPAGES __P((struct vnode *, voff_t, voff_t, int));
@


1.24.2.2
log
@Sync UBC branch to -current
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.17.2.1 2002/02/02 03:28:25 art Exp 
d53 1
a53 1
int VOP_ISLOCKED(struct vnode *);
d62 1
a62 1
int VOP_LOOKUP(struct vnode *, struct vnode **, struct componentname *);
d72 2
a73 2
int VOP_CREATE(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d83 2
a84 2
int VOP_MKNOD(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d94 1
a94 1
int VOP_OPEN(struct vnode *, int, struct ucred *, struct proc *);
d104 1
a104 1
int VOP_CLOSE(struct vnode *, int, struct ucred *, struct proc *);
d114 1
a114 1
int VOP_ACCESS(struct vnode *, int, struct ucred *, struct proc *);
d124 2
a125 1
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);
d135 2
a136 1
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);
d146 1
a146 1
int VOP_READ(struct vnode *, struct uio *, int, struct ucred *);
d156 1
a156 1
int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);
d166 1
a166 1
int VOP_LEASE(struct vnode *, struct proc *, struct ucred *, int);
d178 2
a179 2
int VOP_IOCTL(struct vnode *, u_long, caddr_t, int, struct ucred *, 
    struct proc *);
d190 1
a190 1
int VOP_SELECT(struct vnode *, int, int, struct ucred *, struct proc *);
d198 1
a198 1
int VOP_KQFILTER(struct vnode *, struct knote *);
d206 1
a206 1
int VOP_REVOKE(struct vnode *, int);
d216 1
a216 1
int VOP_FSYNC(struct vnode *, struct ucred *, int, struct proc *);
d225 1
a225 1
int VOP_REMOVE(struct vnode *, struct vnode *, struct componentname *);
d234 1
a234 1
int VOP_LINK(struct vnode *, struct vnode *, struct componentname *);
d246 2
a247 2
int VOP_RENAME(struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *);
d257 2
a258 2
int VOP_MKDIR(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d267 1
a267 1
int VOP_RMDIR(struct vnode *, struct vnode *, struct componentname *);
d278 2
a279 2
int VOP_SYMLINK(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *, char *);
d291 2
a292 2
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, int *, 
    u_long **);
d301 1
a301 1
int VOP_READLINK(struct vnode *, struct uio *, struct ucred *);
d309 1
a309 1
int VOP_ABORTOP(struct vnode *, struct componentname *);
d317 1
a317 1
int VOP_INACTIVE(struct vnode *, struct proc *);
d325 1
a325 1
int VOP_RECLAIM(struct vnode *, struct proc *);
d334 1
a334 1
int VOP_LOCK(struct vnode *, int, struct proc *);
d343 1
a343 1
int VOP_UNLOCK(struct vnode *, int, struct proc *);
d354 1
a354 1
int VOP_BMAP(struct vnode *, daddr_t, struct vnode **, daddr_t *, int *);
d361 1
a361 1
int VOP_PRINT(struct vnode *);
d370 1
a370 1
int VOP_PATHCONF(struct vnode *, int, register_t *);
d381 1
a381 1
int VOP_ADVLOCK(struct vnode *, caddr_t, int, struct flock *, int);
d389 1
a389 1
int VOP_REALLOCBLKS(struct vnode *, struct cluster_save *);
d398 1
a398 1
int VOP_WHITEOUT(struct vnode *, struct componentname *, int);
d412 2
a413 2
int VOP_GETPAGES(struct vnode *, voff_t, struct vm_page **, int *, int, 
    vm_prot_t, int, int);
d423 1
a423 1
int VOP_PUTPAGES(struct vnode *, voff_t, voff_t, int);
d433 1
a433 28
int VOP_MMAP(struct vnode *, int, struct ucred *, struct proc *);

struct vop_getextattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	size_t *a_size;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_getextattr_desc;
int VOP_GETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    size_t *, struct ucred *, struct proc *);

struct vop_setextattr_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_setextattr_desc;
int VOP_SETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    struct ucred *, struct proc *);
d443 1
a443 1
int VOP_STRATEGY(struct buf *);
d450 1
a450 1
int VOP_BWRITE(struct buf *);
@


1.24.2.3
log
@sync
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
@


1.23
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.16 2001/12/04 22:44:31 art Exp 
@


1.22
log
@Oops forgot to regen.
@
text
@a399 11
struct vop_ballocn_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_offset;
	off_t a_length;
	struct ucred *a_cred;
	int a_flags;
};
extern struct vnodeop_desc vop_ballocn_desc;
int VOP_BALLOCN __P((struct vnode *, off_t, off_t, struct ucred *, int));

a424 9

struct vop_size_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_size;
	off_t *a_eobp;
};
extern struct vnodeop_desc vop_size_desc;
int VOP_SIZE __P((struct vnode *, off_t, off_t *));
@


1.21
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.15 2001/11/28 16:24:26 art Exp 
@


1.20
log
@regen
@
text
@d446 10
@


1.19
log
@more typedef zapping vm_page_t -> struct vm_page *
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.14 2001/11/27 05:27:12 art Exp 
@


1.18
log
@regen for UBC changes
@
text
@d415 1
a415 1
	vm_page_t *a_m;
d423 1
a423 1
int VOP_GETPAGES __P((struct vnode *, voff_t, vm_page_t *, int *, int, 
d429 1
a429 1
	vm_page_t *a_m;
d435 1
a435 1
int VOP_PUTPAGES __P((struct vnode *, vm_page_t *, int, int, int *));
@


1.17
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.13 2001/07/26 20:24:47 millert Exp 
@


1.16
log
@Bye-bye to UFS-specific and unused functions
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d399 46
@


1.15
log
@Regen with the right vnode_if.sh
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp 
a207 10
struct vop_mmap_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_fflags;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_mmap_desc;
int VOP_MMAP __P((struct vnode *, int, struct ucred *, struct proc *));

a217 10
struct vop_seek_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_oldoff;
	off_t a_newoff;
	struct ucred *a_cred;
};
extern struct vnodeop_desc vop_seek_desc;
int VOP_SEEK __P((struct vnode *, off_t, off_t, struct ucred *));

a382 33
struct vop_blkatoff_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_offset;
	char **a_res;
	struct buf **a_bpp;
};
extern struct vnodeop_desc vop_blkatoff_desc;
int VOP_BLKATOFF __P((struct vnode *, off_t, char **, struct buf **));

struct vop_valloc_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_pvp;
	int a_mode;
	struct ucred *a_cred;
	struct vnode **a_vpp;
};
extern struct vnodeop_desc vop_valloc_desc;
int VOP_VALLOC __P((struct vnode *, int, struct ucred *, struct vnode **));

struct vop_balloc_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_startoffset;
	int a_size;
	struct ucred *a_cred;
	int a_flags;
	struct buf **a_bpp;
};
extern struct vnodeop_desc vop_balloc_desc;
int VOP_BALLOC __P((struct vnode *, off_t, int, struct ucred *, int, 
    struct buf **));

a389 31

struct vop_vfree_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_pvp;
	ino_t a_ino;
	int a_mode;
};
extern struct vnodeop_desc vop_vfree_desc;
int VOP_VFREE __P((struct vnode *, ino_t, int));

struct vop_truncate_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_length;
	int a_flags;
	struct ucred *a_cred;
	struct proc *a_p;
};
extern struct vnodeop_desc vop_truncate_desc;
int VOP_TRUNCATE __P((struct vnode *, off_t, int, struct ucred *, 
    struct proc *));

struct vop_update_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct timespec *a_access;
	struct timespec *a_modify;
	int a_waitfor;
};
extern struct vnodeop_desc vop_update_desc;
int VOP_UPDATE __P((struct vnode *, struct timespec *, struct timespec *, int));
@


1.14
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6 1999/03/03 20:58:27 deraadt Exp 
@


1.13
log
@regen
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.9 1998/12/05 16:54:02 csapuntz Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
d191 8
@


1.12
log
@regen
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.7 2001/02/26 17:12:27 art Exp 
@


1.11
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6 1999/03/03 20:58:27 deraadt Exp 
@


1.11.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.10 2001/03/01 20:54:34 provos Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.8 2001/02/26 17:34:18 art Exp 
a190 8

struct vop_kqfilter_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct knote *a_kn;
};
extern struct vnodeop_desc vop_kqfilter_desc;
int VOP_KQFILTER __P((struct vnode *, struct knote *));
@


1.11.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.11 2001/06/23 02:21:05 csapuntz Exp 
d208 10
d228 10
d403 33
d443 31
@


1.11.6.3
log
@Merge in -current
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.15 2001/11/28 16:24:26 art Exp 
a398 46

struct vop_ballocn_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_offset;
	off_t a_length;
	struct ucred *a_cred;
	int a_flags;
};
extern struct vnodeop_desc vop_ballocn_desc;
int VOP_BALLOCN __P((struct vnode *, off_t, off_t, struct ucred *, int));

struct vop_getpages_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	voff_t a_offset;
	struct vm_page **a_m;
	int *a_count;
	int a_centeridx;
	vm_prot_t a_access_type;
	int a_advice;
	int a_flags;
};
extern struct vnodeop_desc vop_getpages_desc;
int VOP_GETPAGES __P((struct vnode *, voff_t, struct vm_page **, int *, int, 
    vm_prot_t, int, int));

struct vop_putpages_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct vm_page **a_m;
	int a_count;
	int a_flags;
	int *a_rtvals;
};
extern struct vnodeop_desc vop_putpages_desc;
int VOP_PUTPAGES __P((struct vnode *, struct vm_page **, int, int, int *));

struct vop_size_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_size;
	off_t *a_eobp;
};
extern struct vnodeop_desc vop_size_desc;
int VOP_SIZE __P((struct vnode *, off_t, off_t *));
@


1.11.6.4
log
@Merge in trunk
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.19 2002/02/22 20:37:45 drahn Exp 
d400 1
a400 1
struct vop_getextattr_args {
d403 2
a404 4
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	size_t *a_size;
d406 27
a432 1
	struct proc *a_p;
d434 2
a435 3
extern struct vnodeop_desc vop_getextattr_desc;
int VOP_GETEXTATTR __P((struct vnode *, int, const char *, struct uio *, 
    size_t *, struct ucred *, struct proc *));
d437 1
a437 1
struct vop_setextattr_args {
d440 2
a441 5
	int a_attrnamespace;
	const char *a_name;
	struct uio *a_uio;
	struct ucred *a_cred;
	struct proc *a_p;
d443 2
a444 3
extern struct vnodeop_desc vop_setextattr_desc;
int VOP_SETEXTATTR __P((struct vnode *, int, const char *, struct uio *, 
    struct ucred *, struct proc *));
@


1.11.6.5
log
@Merge in -current from roughly a week ago
@
text
@d53 1
a53 1
int VOP_ISLOCKED(struct vnode *);
d62 1
a62 1
int VOP_LOOKUP(struct vnode *, struct vnode **, struct componentname *);
d72 2
a73 2
int VOP_CREATE(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d83 2
a84 2
int VOP_MKNOD(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d94 1
a94 1
int VOP_OPEN(struct vnode *, int, struct ucred *, struct proc *);
d104 1
a104 1
int VOP_CLOSE(struct vnode *, int, struct ucred *, struct proc *);
d114 1
a114 1
int VOP_ACCESS(struct vnode *, int, struct ucred *, struct proc *);
d124 2
a125 2
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, 
    struct proc *);
d135 2
a136 2
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, 
    struct proc *);
d146 1
a146 1
int VOP_READ(struct vnode *, struct uio *, int, struct ucred *);
d156 1
a156 1
int VOP_WRITE(struct vnode *, struct uio *, int, struct ucred *);
d166 1
a166 1
int VOP_LEASE(struct vnode *, struct proc *, struct ucred *, int);
d178 2
a179 2
int VOP_IOCTL(struct vnode *, u_long, caddr_t, int, struct ucred *, 
    struct proc *);
d190 1
a190 1
int VOP_SELECT(struct vnode *, int, int, struct ucred *, struct proc *);
d198 1
a198 1
int VOP_KQFILTER(struct vnode *, struct knote *);
d206 1
a206 1
int VOP_REVOKE(struct vnode *, int);
d216 1
a216 1
int VOP_FSYNC(struct vnode *, struct ucred *, int, struct proc *);
d225 1
a225 1
int VOP_REMOVE(struct vnode *, struct vnode *, struct componentname *);
d234 1
a234 1
int VOP_LINK(struct vnode *, struct vnode *, struct componentname *);
d246 2
a247 2
int VOP_RENAME(struct vnode *, struct vnode *, struct componentname *, 
    struct vnode *, struct vnode *, struct componentname *);
d257 2
a258 2
int VOP_MKDIR(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *);
d267 1
a267 1
int VOP_RMDIR(struct vnode *, struct vnode *, struct componentname *);
d278 2
a279 2
int VOP_SYMLINK(struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *, char *);
d291 2
a292 2
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, 
    int *, u_long **);
d301 1
a301 1
int VOP_READLINK(struct vnode *, struct uio *, struct ucred *);
d309 1
a309 1
int VOP_ABORTOP(struct vnode *, struct componentname *);
d317 1
a317 1
int VOP_INACTIVE(struct vnode *, struct proc *);
d325 1
a325 1
int VOP_RECLAIM(struct vnode *, struct proc *);
d334 1
a334 1
int VOP_LOCK(struct vnode *, int, struct proc *);
d343 1
a343 1
int VOP_UNLOCK(struct vnode *, int, struct proc *);
d354 1
a354 1
int VOP_BMAP(struct vnode *, daddr_t, struct vnode **, daddr_t *, int *);
d361 1
a361 1
int VOP_PRINT(struct vnode *);
d370 1
a370 1
int VOP_PATHCONF(struct vnode *, int, register_t *);
d381 1
a381 1
int VOP_ADVLOCK(struct vnode *, caddr_t, int, struct flock *, int);
d389 1
a389 1
int VOP_REALLOCBLKS(struct vnode *, struct cluster_save *);
d398 1
a398 1
int VOP_WHITEOUT(struct vnode *, struct componentname *, int);
d411 2
a412 2
int VOP_GETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    size_t *, struct ucred *, struct proc *);
d424 2
a425 2
int VOP_SETEXTATTR(struct vnode *, int, const char *, struct uio *, 
    struct ucred *, struct proc *);
d435 1
a435 1
int VOP_STRATEGY(struct buf *);
d442 1
a442 1
int VOP_BWRITE(struct buf *);
@


1.11.6.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.20 2003/05/01 21:13:05 tedu Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.12 2003/05/01 21:41:35 tedu Exp 
d124 2
a125 1
int VOP_GETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);
d135 2
a136 1
int VOP_SETATTR(struct vnode *, struct vattr *, struct ucred *, struct proc *);
d278 2
a279 2
int VOP_SYMLINK(struct vnode *, struct vnode **, struct componentname *, 
    struct vattr *, char *);
d291 2
a292 2
int VOP_READDIR(struct vnode *, struct uio *, struct ucred *, int *, int *, 
    u_long **);
@


1.11.6.7
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.9.6.6 2003/05/13 19:21:29 ho Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.6.6.3 2003/05/13 19:21:29 ho Exp 
@


1.11.6.8
log
@Sync SMP branch to -current
@
text
@d23 5
a27 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11.6.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d6 1
a6 1
 *	OpenBSD
d8 1
a8 1
 *	OpenBSD
d166 1
a166 1
	void *a_data;
d172 1
a172 1
int VOP_IOCTL(struct vnode *, u_long, void *, int, struct ucred *, 
d175 1
a175 1
struct vop_poll_args {
d178 3
a180 1
	int a_events;
d183 2
a184 2
extern struct vnodeop_desc vop_poll_desc;
int VOP_POLL(struct vnode *, int, struct proc *);
d369 1
a369 1
	void *a_id;
d375 1
a375 1
int VOP_ADVLOCK(struct vnode *, void *, int, struct flock *, int);
@


1.10
log
@vnode_if sync
@
text
@d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.5 1999/03/03 14:23:19 deraadt Exp 
a46 11
#ifdef VOP_NOT_INLINE
#define STATIC_INLINE
#else
#define STATIC_INLINE static __inline
#endif
#ifdef INTERNAL_VOP_NOT_INLINE
#define FUNC_STATIC_INLINE
#else
#undef FUNC_STATIC_INLINE
#define FUNC_STATIC_INLINE static __inline
#endif
d53 2
a54 11
STATIC_INLINE int VOP_ISLOCKED __P((struct vnode *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_ISLOCKED(vp)
	struct vnode *vp;
{
	struct vop_islocked_args a;
	a.a_desc = VDESC(vop_islocked);
	a.a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_islocked), &a));
}
#endif /* !VOP_NOT_INLINE */
d62 2
a63 16
STATIC_INLINE int VOP_LOOKUP __P((struct vnode *, struct vnode **, 
    struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_LOOKUP(dvp, vpp, cnp)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
{
	struct vop_lookup_args a;
	a.a_desc = VDESC(vop_lookup);
	a.a_dvp = dvp;
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_lookup), &a));
}
#endif /* !VOP_NOT_INLINE */
d72 3
a74 21
STATIC_INLINE int VOP_CREATE __P((struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_CREATE(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
{
	struct vop_create_args a;
	a.a_desc = VDESC(vop_create);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_create: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_create), &a));
}
#endif /* !VOP_NOT_INLINE */
d83 3
a85 21
STATIC_INLINE int VOP_MKNOD __P((struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_MKNOD(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
{
	struct vop_mknod_args a;
	a.a_desc = VDESC(vop_mknod);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mknod: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_mknod), &a));
}
#endif /* !VOP_NOT_INLINE */
d94 2
a95 18
STATIC_INLINE int VOP_OPEN __P((struct vnode *, int, struct ucred *, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_OPEN(vp, mode, cred, p)
	struct vnode *vp;
	int mode;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_open_args a;
	a.a_desc = VDESC(vop_open);
	a.a_vp = vp;
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_open), &a));
}
#endif /* !VOP_NOT_INLINE */
d104 2
a105 18
STATIC_INLINE int VOP_CLOSE __P((struct vnode *, int, struct ucred *, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_CLOSE(vp, fflag, cred, p)
	struct vnode *vp;
	int fflag;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_close_args a;
	a.a_desc = VDESC(vop_close);
	a.a_vp = vp;
	a.a_fflag = fflag;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_close), &a));
}
#endif /* !VOP_NOT_INLINE */
d114 2
a115 21
STATIC_INLINE int VOP_ACCESS __P((struct vnode *, int, struct ucred *, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_ACCESS(vp, mode, cred, p)
	struct vnode *vp;
	int mode;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_access_args a;
	a.a_desc = VDESC(vop_access);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_access: vp");
#endif
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_access), &a));
}
#endif /* !VOP_NOT_INLINE */
d124 3
a126 18
STATIC_INLINE int VOP_GETATTR __P((struct vnode *, struct vattr *, 
    struct ucred *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_GETATTR(vp, vap, cred, p)
	struct vnode *vp;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_getattr_args a;
	a.a_desc = VDESC(vop_getattr);
	a.a_vp = vp;
	a.a_vap = vap;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_getattr), &a));
}
#endif /* !VOP_NOT_INLINE */
d135 3
a137 21
STATIC_INLINE int VOP_SETATTR __P((struct vnode *, struct vattr *, 
    struct ucred *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_SETATTR(vp, vap, cred, p)
	struct vnode *vp;
	struct vattr *vap;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_setattr_args a;
	a.a_desc = VDESC(vop_setattr);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_setattr: vp");
#endif
	a.a_vap = vap;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_setattr), &a));
}
#endif /* !VOP_NOT_INLINE */
d146 2
a147 21
STATIC_INLINE int VOP_READ __P((struct vnode *, struct uio *, int, 
    struct ucred *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_READ(vp, uio, ioflag, cred)
	struct vnode *vp;
	struct uio *uio;
	int ioflag;
	struct ucred *cred;
{
	struct vop_read_args a;
	a.a_desc = VDESC(vop_read);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_read: vp");
#endif
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_read), &a));
}
#endif /* !VOP_NOT_INLINE */
d156 2
a157 21
STATIC_INLINE int VOP_WRITE __P((struct vnode *, struct uio *, int, 
    struct ucred *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_WRITE(vp, uio, ioflag, cred)
	struct vnode *vp;
	struct uio *uio;
	int ioflag;
	struct ucred *cred;
{
	struct vop_write_args a;
	a.a_desc = VDESC(vop_write);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_write: vp");
#endif
	a.a_uio = uio;
	a.a_ioflag = ioflag;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_write), &a));
}
#endif /* !VOP_NOT_INLINE */
d166 2
a167 18
STATIC_INLINE int VOP_LEASE __P((struct vnode *, struct proc *, 
    struct ucred *, int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_LEASE(vp, p, cred, flag)
	struct vnode *vp;
	struct proc *p;
	struct ucred *cred;
	int flag;
{
	struct vop_lease_args a;
	a.a_desc = VDESC(vop_lease);
	a.a_vp = vp;
	a.a_p = p;
	a.a_cred = cred;
	a.a_flag = flag;
	return (VCALL(vp, VOFFSET(vop_lease), &a));
}
#endif /* !VOP_NOT_INLINE */
d178 3
a180 22
STATIC_INLINE int VOP_IOCTL __P((struct vnode *, u_long, caddr_t, int, 
    struct ucred *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_IOCTL(vp, command, data, fflag, cred, p)
	struct vnode *vp;
	u_long command;
	caddr_t data;
	int fflag;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_ioctl_args a;
	a.a_desc = VDESC(vop_ioctl);
	a.a_vp = vp;
	a.a_command = command;
	a.a_data = data;
	a.a_fflag = fflag;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_ioctl), &a));
}
#endif /* !VOP_NOT_INLINE */
d190 2
a191 20
STATIC_INLINE int VOP_SELECT __P((struct vnode *, int, int, struct ucred *, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_SELECT(vp, which, fflags, cred, p)
	struct vnode *vp;
	int which;
	int fflags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_select_args a;
	a.a_desc = VDESC(vop_select);
	a.a_vp = vp;
	a.a_which = which;
	a.a_fflags = fflags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_select), &a));
}
#endif /* !VOP_NOT_INLINE */
d198 2
a199 13
STATIC_INLINE int VOP_REVOKE __P((struct vnode *, int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_REVOKE(vp, flags)
	struct vnode *vp;
	int flags;
{
	struct vop_revoke_args a;
	a.a_desc = VDESC(vop_revoke);
	a.a_vp = vp;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_revoke), &a));
}
#endif /* !VOP_NOT_INLINE */
d208 2
a209 18
STATIC_INLINE int VOP_MMAP __P((struct vnode *, int, struct ucred *, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_MMAP(vp, fflags, cred, p)
	struct vnode *vp;
	int fflags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_mmap_args a;
	a.a_desc = VDESC(vop_mmap);
	a.a_vp = vp;
	a.a_fflags = fflags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_mmap), &a));
}
#endif /* !VOP_NOT_INLINE */
d218 2
a219 21
STATIC_INLINE int VOP_FSYNC __P((struct vnode *, struct ucred *, int, 
    struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_FSYNC(vp, cred, waitfor, p)
	struct vnode *vp;
	struct ucred *cred;
	int waitfor;
	struct proc *p;
{
	struct vop_fsync_args a;
	a.a_desc = VDESC(vop_fsync);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_fsync: vp");
#endif
	a.a_cred = cred;
	a.a_waitfor = waitfor;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_fsync), &a));
}
#endif /* !VOP_NOT_INLINE */
d228 2
a229 17
STATIC_INLINE int VOP_SEEK __P((struct vnode *, off_t, off_t, struct ucred *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_SEEK(vp, oldoff, newoff, cred)
	struct vnode *vp;
	off_t oldoff;
	off_t newoff;
	struct ucred *cred;
{
	struct vop_seek_args a;
	a.a_desc = VDESC(vop_seek);
	a.a_vp = vp;
	a.a_oldoff = oldoff;
	a.a_newoff = newoff;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_seek), &a));
}
#endif /* !VOP_NOT_INLINE */
d237 2
a238 22
STATIC_INLINE int VOP_REMOVE __P((struct vnode *, struct vnode *, 
    struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_REMOVE(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
{
	struct vop_remove_args a;
	a.a_desc = VDESC(vop_remove);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_remove: dvp");
#endif
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_remove: vp");
#endif
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_remove), &a));
}
#endif /* !VOP_NOT_INLINE */
d246 2
a247 19
STATIC_INLINE int VOP_LINK __P((struct vnode *, struct vnode *, 
    struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_LINK(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
{
	struct vop_link_args a;
	a.a_desc = VDESC(vop_link);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_link: dvp");
#endif
	a.a_vp = vp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_link), &a));
}
#endif /* !VOP_NOT_INLINE */
d258 3
a260 26
STATIC_INLINE int VOP_RENAME __P((struct vnode *, struct vnode *, 
    struct componentname *, struct vnode *, struct vnode *, 
    struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_RENAME(fdvp, fvp, fcnp, tdvp, tvp, tcnp)
	struct vnode *fdvp;
	struct vnode *fvp;
	struct componentname *fcnp;
	struct vnode *tdvp;
	struct vnode *tvp;
	struct componentname *tcnp;
{
	struct vop_rename_args a;
	a.a_desc = VDESC(vop_rename);
	a.a_fdvp = fdvp;
	a.a_fvp = fvp;
	a.a_fcnp = fcnp;
	a.a_tdvp = tdvp;
#ifdef DIAGNOSTIC
	if ((tdvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(tdvp)) panic("vop_rename: tdvp");
#endif
	a.a_tvp = tvp;
	a.a_tcnp = tcnp;
	return (VCALL(fdvp, VOFFSET(vop_rename), &a));
}
#endif /* !VOP_NOT_INLINE */
d269 3
a271 21
STATIC_INLINE int VOP_MKDIR __P((struct vnode *, struct vnode **, 
    struct componentname *, struct vattr *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_MKDIR(dvp, vpp, cnp, vap)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
{
	struct vop_mkdir_args a;
	a.a_desc = VDESC(vop_mkdir);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_mkdir: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	return (VCALL(dvp, VOFFSET(vop_mkdir), &a));
}
#endif /* !VOP_NOT_INLINE */
d279 2
a280 22
STATIC_INLINE int VOP_RMDIR __P((struct vnode *, struct vnode *, 
    struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_RMDIR(dvp, vp, cnp)
	struct vnode *dvp;
	struct vnode *vp;
	struct componentname *cnp;
{
	struct vop_rmdir_args a;
	a.a_desc = VDESC(vop_rmdir);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_rmdir: dvp");
#endif
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_rmdir: vp");
#endif
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_rmdir), &a));
}
#endif /* !VOP_NOT_INLINE */
d290 1
a290 1
STATIC_INLINE int VOP_SYMLINK __P((struct vnode *, struct vnode **, 
d292 1
a292 21
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_SYMLINK(dvp, vpp, cnp, vap, target)
	struct vnode *dvp;
	struct vnode **vpp;
	struct componentname *cnp;
	struct vattr *vap;
	char *target;
{
	struct vop_symlink_args a;
	a.a_desc = VDESC(vop_symlink);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_symlink: dvp");
#endif
	a.a_vpp = vpp;
	a.a_cnp = cnp;
	a.a_vap = vap;
	a.a_target = target;
	return (VCALL(dvp, VOFFSET(vop_symlink), &a));
}
#endif /* !VOP_NOT_INLINE */
d303 3
a305 25
STATIC_INLINE int VOP_READDIR __P((struct vnode *, struct uio *, 
    struct ucred *, int *, int *, u_long **));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_READDIR(vp, uio, cred, eofflag, ncookies, cookies)
	struct vnode *vp;
	struct uio *uio;
	struct ucred *cred;
	int *eofflag;
	int *ncookies;
	u_long **cookies;
{
	struct vop_readdir_args a;
	a.a_desc = VDESC(vop_readdir);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readdir: vp");
#endif
	a.a_uio = uio;
	a.a_cred = cred;
	a.a_eofflag = eofflag;
	a.a_ncookies = ncookies;
	a.a_cookies = cookies;
	return (VCALL(vp, VOFFSET(vop_readdir), &a));
}
#endif /* !VOP_NOT_INLINE */
d313 2
a314 19
STATIC_INLINE int VOP_READLINK __P((struct vnode *, struct uio *, 
    struct ucred *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_READLINK(vp, uio, cred)
	struct vnode *vp;
	struct uio *uio;
	struct ucred *cred;
{
	struct vop_readlink_args a;
	a.a_desc = VDESC(vop_readlink);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_readlink: vp");
#endif
	a.a_uio = uio;
	a.a_cred = cred;
	return (VCALL(vp, VOFFSET(vop_readlink), &a));
}
#endif /* !VOP_NOT_INLINE */
d321 2
a322 13
STATIC_INLINE int VOP_ABORTOP __P((struct vnode *, struct componentname *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_ABORTOP(dvp, cnp)
	struct vnode *dvp;
	struct componentname *cnp;
{
	struct vop_abortop_args a;
	a.a_desc = VDESC(vop_abortop);
	a.a_dvp = dvp;
	a.a_cnp = cnp;
	return (VCALL(dvp, VOFFSET(vop_abortop), &a));
}
#endif /* !VOP_NOT_INLINE */
d329 2
a330 16
STATIC_INLINE int VOP_INACTIVE __P((struct vnode *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_INACTIVE(vp, p)
	struct vnode *vp;
	struct proc *p;
{
	struct vop_inactive_args a;
	a.a_desc = VDESC(vop_inactive);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_inactive: vp");
#endif
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_inactive), &a));
}
#endif /* !VOP_NOT_INLINE */
d337 2
a338 13
STATIC_INLINE int VOP_RECLAIM __P((struct vnode *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_RECLAIM(vp, p)
	struct vnode *vp;
	struct proc *p;
{
	struct vop_reclaim_args a;
	a.a_desc = VDESC(vop_reclaim);
	a.a_vp = vp;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_reclaim), &a));
}
#endif /* !VOP_NOT_INLINE */
d346 2
a347 15
STATIC_INLINE int VOP_LOCK __P((struct vnode *, int, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_LOCK(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
{
	struct vop_lock_args a;
	a.a_desc = VDESC(vop_lock);
	a.a_vp = vp;
	a.a_flags = flags;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_lock), &a));
}
#endif /* !VOP_NOT_INLINE */
d355 2
a356 15
STATIC_INLINE int VOP_UNLOCK __P((struct vnode *, int, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_UNLOCK(vp, flags, p)
	struct vnode *vp;
	int flags;
	struct proc *p;
{
	struct vop_unlock_args a;
	a.a_desc = VDESC(vop_unlock);
	a.a_vp = vp;
	a.a_flags = flags;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_unlock), &a));
}
#endif /* !VOP_NOT_INLINE */
d366 2
a367 23
STATIC_INLINE int VOP_BMAP __P((struct vnode *, daddr_t, struct vnode **, 
    daddr_t *, int *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_BMAP(vp, bn, vpp, bnp, runp)
	struct vnode *vp;
	daddr_t bn;
	struct vnode **vpp;
	daddr_t *bnp;
	int *runp;
{
	struct vop_bmap_args a;
	a.a_desc = VDESC(vop_bmap);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_bmap: vp");
#endif
	a.a_bn = bn;
	a.a_vpp = vpp;
	a.a_bnp = bnp;
	a.a_runp = runp;
	return (VCALL(vp, VOFFSET(vop_bmap), &a));
}
#endif /* !VOP_NOT_INLINE */
d373 2
a374 11
STATIC_INLINE int VOP_PRINT __P((struct vnode *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_PRINT(vp)
	struct vnode *vp;
{
	struct vop_print_args a;
	a.a_desc = VDESC(vop_print);
	a.a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_print), &a));
}
#endif /* !VOP_NOT_INLINE */
d382 2
a383 15
STATIC_INLINE int VOP_PATHCONF __P((struct vnode *, int, register_t *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_PATHCONF(vp, name, retval)
	struct vnode *vp;
	int name;
	register_t *retval;
{
	struct vop_pathconf_args a;
	a.a_desc = VDESC(vop_pathconf);
	a.a_vp = vp;
	a.a_name = name;
	a.a_retval = retval;
	return (VCALL(vp, VOFFSET(vop_pathconf), &a));
}
#endif /* !VOP_NOT_INLINE */
d393 2
a394 20
STATIC_INLINE int VOP_ADVLOCK __P((struct vnode *, caddr_t, int, 
    struct flock *, int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_ADVLOCK(vp, id, op, fl, flags)
	struct vnode *vp;
	caddr_t id;
	int op;
	struct flock *fl;
	int flags;
{
	struct vop_advlock_args a;
	a.a_desc = VDESC(vop_advlock);
	a.a_vp = vp;
	a.a_id = id;
	a.a_op = op;
	a.a_fl = fl;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_advlock), &a));
}
#endif /* !VOP_NOT_INLINE */
d403 2
a404 21
STATIC_INLINE int VOP_BLKATOFF __P((struct vnode *, off_t, char **, 
    struct buf **));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_BLKATOFF(vp, offset, res, bpp)
	struct vnode *vp;
	off_t offset;
	char **res;
	struct buf **bpp;
{
	struct vop_blkatoff_args a;
	a.a_desc = VDESC(vop_blkatoff);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_blkatoff: vp");
#endif
	a.a_offset = offset;
	a.a_res = res;
	a.a_bpp = bpp;
	return (VCALL(vp, VOFFSET(vop_blkatoff), &a));
}
#endif /* !VOP_NOT_INLINE */
d413 2
a414 21
STATIC_INLINE int VOP_VALLOC __P((struct vnode *, int, struct ucred *, 
    struct vnode **));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_VALLOC(pvp, mode, cred, vpp)
	struct vnode *pvp;
	int mode;
	struct ucred *cred;
	struct vnode **vpp;
{
	struct vop_valloc_args a;
	a.a_desc = VDESC(vop_valloc);
	a.a_pvp = pvp;
#ifdef DIAGNOSTIC
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_valloc: pvp");
#endif
	a.a_mode = mode;
	a.a_cred = cred;
	a.a_vpp = vpp;
	return (VCALL(pvp, VOFFSET(vop_valloc), &a));
}
#endif /* !VOP_NOT_INLINE */
d425 3
a427 25
STATIC_INLINE int VOP_BALLOC __P((struct vnode *, off_t, int, 
    struct ucred *, int, struct buf **));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_BALLOC(vp, startoffset, size, cred, flags, bpp)
	struct vnode *vp;
	off_t startoffset;
	int size;
	struct ucred *cred;
	int flags;
	struct buf **bpp;
{
	struct vop_balloc_args a;
	a.a_desc = VDESC(vop_balloc);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_balloc: vp");
#endif
	a.a_startoffset = startoffset;
	a.a_size = size;
	a.a_cred = cred;
	a.a_flags = flags;
	a.a_bpp = bpp;
	return (VCALL(vp, VOFFSET(vop_balloc), &a));
}
#endif /* !VOP_NOT_INLINE */
d434 2
a435 16
STATIC_INLINE int VOP_REALLOCBLKS __P((struct vnode *, struct cluster_save *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_REALLOCBLKS(vp, buflist)
	struct vnode *vp;
	struct cluster_save *buflist;
{
	struct vop_reallocblks_args a;
	a.a_desc = VDESC(vop_reallocblks);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_reallocblks: vp");
#endif
	a.a_buflist = buflist;
	return (VCALL(vp, VOFFSET(vop_reallocblks), &a));
}
#endif /* !VOP_NOT_INLINE */
d443 2
a444 18
STATIC_INLINE int VOP_VFREE __P((struct vnode *, ino_t, int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_VFREE(pvp, ino, mode)
	struct vnode *pvp;
	ino_t ino;
	int mode;
{
	struct vop_vfree_args a;
	a.a_desc = VDESC(vop_vfree);
	a.a_pvp = pvp;
#ifdef DIAGNOSTIC
	if ((pvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(pvp)) panic("vop_vfree: pvp");
#endif
	a.a_ino = ino;
	a.a_mode = mode;
	return (VCALL(pvp, VOFFSET(vop_vfree), &a));
}
#endif /* !VOP_NOT_INLINE */
d454 3
a456 23
STATIC_INLINE int VOP_TRUNCATE __P((struct vnode *, off_t, int, 
    struct ucred *, struct proc *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_TRUNCATE(vp, length, flags, cred, p)
	struct vnode *vp;
	off_t length;
	int flags;
	struct ucred *cred;
	struct proc *p;
{
	struct vop_truncate_args a;
	a.a_desc = VDESC(vop_truncate);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_truncate: vp");
#endif
	a.a_length = length;
	a.a_flags = flags;
	a.a_cred = cred;
	a.a_p = p;
	return (VCALL(vp, VOFFSET(vop_truncate), &a));
}
#endif /* !VOP_NOT_INLINE */
d465 2
a466 21
STATIC_INLINE int VOP_UPDATE __P((struct vnode *, struct timespec *, 
    struct timespec *, int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_UPDATE(vp, access, modify, waitfor)
	struct vnode *vp;
	struct timespec *access;
	struct timespec *modify;
	int waitfor;
{
	struct vop_update_args a;
	a.a_desc = VDESC(vop_update);
	a.a_vp = vp;
#ifdef DIAGNOSTIC
	if ((vp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(vp)) panic("vop_update: vp");
#endif
	a.a_access = access;
	a.a_modify = modify;
	a.a_waitfor = waitfor;
	return (VCALL(vp, VOFFSET(vop_update), &a));
}
#endif /* !VOP_NOT_INLINE */
d474 2
a475 19
STATIC_INLINE int VOP_WHITEOUT __P((struct vnode *, struct componentname *, 
    int));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_WHITEOUT(dvp, cnp, flags)
	struct vnode *dvp;
	struct componentname *cnp;
	int flags;
{
	struct vop_whiteout_args a;
	a.a_desc = VDESC(vop_whiteout);
	a.a_dvp = dvp;
#ifdef DIAGNOSTIC
	if ((dvp->v_flag & VLOCKSWORK) && !VOP_ISLOCKED(dvp)) panic("vop_whiteout: dvp");
#endif
	a.a_cnp = cnp;
	a.a_flags = flags;
	return (VCALL(dvp, VOFFSET(vop_whiteout), &a));
}
#endif /* !VOP_NOT_INLINE */
d484 2
a485 11
STATIC_INLINE int VOP_STRATEGY __P((struct buf *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_STRATEGY(bp)
	struct buf *bp;
{
	struct vop_strategy_args a;
	a.a_desc = VDESC(vop_strategy);
	a.a_bp = bp;
	return (VCALL(bp->b_vp, VOFFSET(vop_strategy), &a));
}
#endif /* !VOP_NOT_INLINE */
d491 2
a492 11
STATIC_INLINE int VOP_BWRITE __P((struct buf *));
#if !defined(VOP_NOT_INLINE) || defined(INTERNAL_VOP_NOT_INLINE)
FUNC_STATIC_INLINE int VOP_BWRITE(bp)
	struct buf *bp;
{
	struct vop_bwrite_args a;
	a.a_desc = VDESC(vop_bwrite);
	a.a_bp = bp;
	return (VCALL(bp->b_vp, VOFFSET(vop_bwrite), &a));
}
#endif /* !VOP_NOT_INLINE */
@


1.9
log
@

Updated generated files
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.8 1998/08/08 03:53:30 csapuntz Exp 
d8 1
a8 1
 *	OpenBSD: vnode_if.sh,v 1.3 1996/04/19 16:09:13 niklas Exp 
d47 11
d64 3
a66 2
static __inline int VOP_ISLOCKED __P((struct vnode *));
static __inline int VOP_ISLOCKED(vp)
d74 1
a74 1

d82 1
a82 1
static __inline int VOP_LOOKUP __P((struct vnode *, struct vnode **, 
d84 2
a85 1
static __inline int VOP_LOOKUP(dvp, vpp, cnp)
d97 1
a97 1

d106 1
a106 1
static __inline int VOP_CREATE __P((struct vnode *, struct vnode **, 
d108 2
a109 1
static __inline int VOP_CREATE(dvp, vpp, cnp, vap)
d126 1
a126 1

d135 1
a135 1
static __inline int VOP_MKNOD __P((struct vnode *, struct vnode **, 
d137 2
a138 1
static __inline int VOP_MKNOD(dvp, vpp, cnp, vap)
d155 1
a155 1

d164 1
a164 1
static __inline int VOP_OPEN __P((struct vnode *, int, struct ucred *, 
d166 2
a167 1
static __inline int VOP_OPEN(vp, mode, cred, p)
d181 1
a181 1

d190 1
a190 1
static __inline int VOP_CLOSE __P((struct vnode *, int, struct ucred *, 
d192 2
a193 1
static __inline int VOP_CLOSE(vp, fflag, cred, p)
d207 1
a207 1

d216 1
a216 1
static __inline int VOP_ACCESS __P((struct vnode *, int, struct ucred *, 
d218 2
a219 1
static __inline int VOP_ACCESS(vp, mode, cred, p)
d236 1
a236 1

d245 1
a245 1
static __inline int VOP_GETATTR __P((struct vnode *, struct vattr *, 
d247 2
a248 1
static __inline int VOP_GETATTR(vp, vap, cred, p)
d262 1
a262 1

d271 1
a271 1
static __inline int VOP_SETATTR __P((struct vnode *, struct vattr *, 
d273 2
a274 1
static __inline int VOP_SETATTR(vp, vap, cred, p)
d291 1
a291 1

d300 1
a300 1
static __inline int VOP_READ __P((struct vnode *, struct uio *, int, 
d302 2
a303 1
static __inline int VOP_READ(vp, uio, ioflag, cred)
d320 1
a320 1

d329 1
a329 1
static __inline int VOP_WRITE __P((struct vnode *, struct uio *, int, 
d331 2
a332 1
static __inline int VOP_WRITE(vp, uio, ioflag, cred)
d349 1
a349 1

d358 1
a358 1
static __inline int VOP_LEASE __P((struct vnode *, struct proc *, 
d360 2
a361 1
static __inline int VOP_LEASE(vp, p, cred, flag)
d375 1
a375 1

d386 1
a386 1
static __inline int VOP_IOCTL __P((struct vnode *, u_long, caddr_t, int, 
d388 2
a389 1
static __inline int VOP_IOCTL(vp, command, data, fflag, cred, p)
d407 1
a407 1

d417 4
a420 3
static __inline int VOP_SELECT __P((struct vnode *, int, int, 
    struct ucred *, struct proc *));
static __inline int VOP_SELECT(vp, which, fflags, cred, p)
d436 1
a436 1

d443 3
a445 2
static __inline int VOP_REVOKE __P((struct vnode *, int));
static __inline int VOP_REVOKE(vp, flags)
d455 1
a455 1

d464 1
a464 1
static __inline int VOP_MMAP __P((struct vnode *, int, struct ucred *, 
d466 2
a467 1
static __inline int VOP_MMAP(vp, fflags, cred, p)
d481 1
a481 1

d490 1
a490 1
static __inline int VOP_FSYNC __P((struct vnode *, struct ucred *, int, 
d492 2
a493 1
static __inline int VOP_FSYNC(vp, cred, waitfor, p)
d510 1
a510 1

d519 3
a521 3
static __inline int VOP_SEEK __P((struct vnode *, off_t, off_t, 
    struct ucred *));
static __inline int VOP_SEEK(vp, oldoff, newoff, cred)
d535 1
a535 1

d543 1
a543 1
static __inline int VOP_REMOVE __P((struct vnode *, struct vnode *, 
d545 2
a546 1
static __inline int VOP_REMOVE(dvp, vp, cnp)
d564 1
a564 1

d572 1
a572 1
static __inline int VOP_LINK __P((struct vnode *, struct vnode *, 
d574 2
a575 1
static __inline int VOP_LINK(dvp, vp, cnp)
d590 1
a590 1

d601 1
a601 1
static __inline int VOP_RENAME __P((struct vnode *, struct vnode *, 
d604 2
a605 1
static __inline int VOP_RENAME(fdvp, fvp, fcnp, tdvp, tvp, tcnp)
d626 1
a626 1

d635 1
a635 1
static __inline int VOP_MKDIR __P((struct vnode *, struct vnode **, 
d637 2
a638 1
static __inline int VOP_MKDIR(dvp, vpp, cnp, vap)
d655 1
a655 1

d663 1
a663 1
static __inline int VOP_RMDIR __P((struct vnode *, struct vnode *, 
d665 2
a666 1
static __inline int VOP_RMDIR(dvp, vp, cnp)
d684 1
a684 1

d694 1
a694 1
static __inline int VOP_SYMLINK __P((struct vnode *, struct vnode **, 
d696 2
a697 1
static __inline int VOP_SYMLINK(dvp, vpp, cnp, vap, target)
d716 1
a716 1

d727 1
a727 1
static __inline int VOP_READDIR __P((struct vnode *, struct uio *, 
d729 2
a730 1
static __inline int VOP_READDIR(vp, uio, cred, eofflag, ncookies, cookies)
d751 1
a751 1

d759 1
a759 1
static __inline int VOP_READLINK __P((struct vnode *, struct uio *, 
d761 2
a762 1
static __inline int VOP_READLINK(vp, uio, cred)
d777 1
a777 1

d784 3
a786 2
static __inline int VOP_ABORTOP __P((struct vnode *, struct componentname *));
static __inline int VOP_ABORTOP(dvp, cnp)
d796 1
a796 1

d803 3
a805 2
static __inline int VOP_INACTIVE __P((struct vnode *, struct proc *));
static __inline int VOP_INACTIVE(vp, p)
d818 1
a818 1

d825 3
a827 2
static __inline int VOP_RECLAIM __P((struct vnode *, struct proc *));
static __inline int VOP_RECLAIM(vp, p)
d837 1
a837 1

d845 3
a847 2
static __inline int VOP_LOCK __P((struct vnode *, int, struct proc *));
static __inline int VOP_LOCK(vp, flags, p)
d859 1
a859 1

d867 3
a869 2
static __inline int VOP_UNLOCK __P((struct vnode *, int, struct proc *));
static __inline int VOP_UNLOCK(vp, flags, p)
d881 1
a881 1

d891 1
a891 1
static __inline int VOP_BMAP __P((struct vnode *, daddr_t, struct vnode **, 
d893 2
a894 1
static __inline int VOP_BMAP(vp, bn, vpp, bnp, runp)
d913 1
a913 1

d919 3
a921 2
static __inline int VOP_PRINT __P((struct vnode *));
static __inline int VOP_PRINT(vp)
d929 1
a929 1

d937 3
a939 2
static __inline int VOP_PATHCONF __P((struct vnode *, int, register_t *));
static __inline int VOP_PATHCONF(vp, name, retval)
d951 1
a951 1

d961 1
a961 1
static __inline int VOP_ADVLOCK __P((struct vnode *, caddr_t, int, 
d963 2
a964 1
static __inline int VOP_ADVLOCK(vp, id, op, fl, flags)
d980 1
a980 1

d989 1
a989 1
static __inline int VOP_BLKATOFF __P((struct vnode *, off_t, char **, 
d991 2
a992 1
static __inline int VOP_BLKATOFF(vp, offset, res, bpp)
d1009 1
a1009 1

d1018 1
a1018 1
static __inline int VOP_VALLOC __P((struct vnode *, int, struct ucred *, 
d1020 2
a1021 1
static __inline int VOP_VALLOC(pvp, mode, cred, vpp)
d1038 1
a1038 1

d1049 1
a1049 1
static __inline int VOP_BALLOC __P((struct vnode *, off_t, int, 
d1051 2
a1052 1
static __inline int VOP_BALLOC(vp, startoffset, size, cred, flags, bpp)
d1073 1
a1073 1

d1080 3
a1082 3
static __inline int VOP_REALLOCBLKS __P((struct vnode *, 
    struct cluster_save *));
static __inline int VOP_REALLOCBLKS(vp, buflist)
d1095 1
a1095 1

d1103 3
a1105 2
static __inline int VOP_VFREE __P((struct vnode *, ino_t, int));
static __inline int VOP_VFREE(pvp, ino, mode)
d1120 1
a1120 1

d1130 1
a1130 1
static __inline int VOP_TRUNCATE __P((struct vnode *, off_t, int, 
d1132 2
a1133 1
static __inline int VOP_TRUNCATE(vp, length, flags, cred, p)
d1152 1
a1152 1

d1161 1
a1161 1
static __inline int VOP_UPDATE __P((struct vnode *, struct timespec *, 
d1163 2
a1164 1
static __inline int VOP_UPDATE(vp, access, modify, waitfor)
d1181 1
a1181 1

d1189 4
a1192 3
static __inline int VOP_WHITEOUT __P((struct vnode *, 
    struct componentname *, int));
static __inline int VOP_WHITEOUT(dvp, cnp, flags)
d1207 1
a1207 1

d1216 3
a1218 2
static __inline int VOP_STRATEGY __P((struct buf *));
static __inline int VOP_STRATEGY(bp)
d1226 1
a1226 1

d1232 3
a1234 2
static __inline int VOP_BWRITE __P((struct buf *));
static __inline int VOP_BWRITE(bp)
d1242 1
a1242 1

@


1.8
log
@sync
@
text
@d46 16
d104 3
d132 3
d210 3
d263 3
d291 3
d319 3
d474 3
d525 7
a531 1
	a.a_vp = vp;
d553 3
d588 3
d615 3
d641 7
a647 1
	a.a_vp = vp;
d673 3
d706 3
d734 3
d774 3
d862 3
a886 15
struct vop_islocked_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
};
extern struct vnodeop_desc vop_islocked_desc;
static __inline int VOP_ISLOCKED __P((struct vnode *));
static __inline int VOP_ISLOCKED(vp)
	struct vnode *vp;
{
	struct vop_islocked_args a;
	a.a_desc = VDESC(vop_islocked);
	a.a_vp = vp;
	return (VCALL(vp, VOFFSET(vop_islocked), &a));
}

d955 3
d983 3
d1015 3
d1041 3
d1064 3
d1093 3
d1122 3
d1148 3
@


1.7
log
@Updates for VFS Lite 2 + soft update.
@
text
@d6 1
a6 1
 *	OpenBSD: vnode_if.src,v 1.4 1996/05/22 11:47:12 deraadt Exp 
@


1.6
log
@back out vfs lite2 till after 2.2
@
text
@d294 25
d378 18
d628 2
a629 2
	u_long *a_cookies;
	int a_ncookies;
d633 2
a634 2
    struct ucred *, int *, u_long *, int));
static __inline int VOP_READDIR(vp, uio, cred, eofflag, cookies, ncookies)
d639 2
a640 2
	u_long *cookies;
	int ncookies;
d648 1
a649 1
	a.a_ncookies = ncookies;
d696 1
d699 2
a700 2
static __inline int VOP_INACTIVE __P((struct vnode *));
static __inline int VOP_INACTIVE(vp)
d702 1
d707 1
d714 1
d717 2
a718 2
static __inline int VOP_RECLAIM __P((struct vnode *));
static __inline int VOP_RECLAIM(vp)
d720 1
d725 1
d732 2
d736 2
a737 2
static __inline int VOP_LOCK __P((struct vnode *));
static __inline int VOP_LOCK(vp)
d739 2
d745 2
d753 2
d757 2
a758 2
static __inline int VOP_UNLOCK __P((struct vnode *));
static __inline int VOP_UNLOCK(vp)
d760 2
d766 2
d928 31
a1049 25
}

struct vop_lease_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
	struct ucred *a_cred;
	int a_flag;
};
extern struct vnodeop_desc vop_lease_desc;
static __inline int VOP_LEASE __P((struct vnode *, struct proc *, 
    struct ucred *, int));
static __inline int VOP_LEASE(vp, p, cred, flag)
	struct vnode *vp;
	struct proc *p;
	struct ucred *cred;
	int flag;
{
	struct vop_lease_args a;
	a.a_desc = VDESC(vop_lease);
	a.a_vp = vp;
	a.a_p = p;
	a.a_cred = cred;
	a.a_flag = flag;
	return (VCALL(vp, VOFFSET(vop_lease), &a));
@


1.5
log
@VFS Lite2 Changes
@
text
@a293 25
struct vop_lease_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
	struct ucred *a_cred;
	int a_flag;
};
extern struct vnodeop_desc vop_lease_desc;
static __inline int VOP_LEASE __P((struct vnode *, struct proc *, 
    struct ucred *, int));
static __inline int VOP_LEASE(vp, p, cred, flag)
	struct vnode *vp;
	struct proc *p;
	struct ucred *cred;
	int flag;
{
	struct vop_lease_args a;
	a.a_desc = VDESC(vop_lease);
	a.a_vp = vp;
	a.a_p = p;
	a.a_cred = cred;
	a.a_flag = flag;
	return (VCALL(vp, VOFFSET(vop_lease), &a));
}

a352 18
struct vop_revoke_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	int a_flags;
};
extern struct vnodeop_desc vop_revoke_desc;
static __inline int VOP_REVOKE __P((struct vnode *, int));
static __inline int VOP_REVOKE(vp, flags)
	struct vnode *vp;
	int flags;
{
	struct vop_revoke_args a;
	a.a_desc = VDESC(vop_revoke);
	a.a_vp = vp;
	a.a_flags = flags;
	return (VCALL(vp, VOFFSET(vop_revoke), &a));
}

d585 2
a586 2
	int *a_ncookies;
	u_long **a_cookies;
d590 2
a591 2
    struct ucred *, int *, int *, u_long **));
static __inline int VOP_READDIR(vp, uio, cred, eofflag, ncookies, cookies)
d596 2
a597 2
	int *ncookies;
	u_long **cookies;
d605 1
a606 1
	a.a_cookies = cookies;
a652 1
	struct proc *a_p;
d655 2
a656 2
static __inline int VOP_INACTIVE __P((struct vnode *, struct proc *));
static __inline int VOP_INACTIVE(vp, p)
a657 1
	struct proc *p;
a661 1
	a.a_p = p;
a667 1
	struct proc *a_p;
d670 2
a671 2
static __inline int VOP_RECLAIM __P((struct vnode *, struct proc *));
static __inline int VOP_RECLAIM(vp, p)
a672 1
	struct proc *p;
a676 1
	a.a_p = p;
a682 2
	int a_flags;
	struct proc *a_p;
d685 2
a686 2
static __inline int VOP_LOCK __P((struct vnode *, int, struct proc *));
static __inline int VOP_LOCK(vp, flags, p)
a687 2
	int flags;
	struct proc *p;
a691 2
	a.a_flags = flags;
	a.a_p = p;
a697 2
	int a_flags;
	struct proc *a_p;
d700 2
a701 2
static __inline int VOP_UNLOCK __P((struct vnode *, int, struct proc *));
static __inline int VOP_UNLOCK(vp, flags, p)
a702 2
	int flags;
	struct proc *p;
a706 2
	a.a_flags = flags;
	a.a_p = p;
a866 31
struct vop_balloc_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	off_t a_startoffset;
	int a_size;
	struct ucred *a_cred;
	int a_flags;
	struct buf **a_bpp;
};
extern struct vnodeop_desc vop_balloc_desc;
static __inline int VOP_BALLOC __P((struct vnode *, off_t, int, 
    struct ucred *, int, struct buf **));
static __inline int VOP_BALLOC(vp, startoffset, size, cred, flags, bpp)
	struct vnode *vp;
	off_t startoffset;
	int size;
	struct ucred *cred;
	int flags;
	struct buf **bpp;
{
	struct vop_balloc_args a;
	a.a_desc = VDESC(vop_balloc);
	a.a_vp = vp;
	a.a_startoffset = startoffset;
	a.a_size = size;
	a.a_cred = cred;
	a.a_flags = flags;
	a.a_bpp = bpp;
	return (VCALL(vp, VOFFSET(vop_balloc), &a));
}

d958 25
@


1.4
log
@Regen.
@
text
@d294 25
d378 18
d628 2
a629 2
	u_long *a_cookies;
	int a_ncookies;
d633 2
a634 2
    struct ucred *, int *, u_long *, int));
static __inline int VOP_READDIR(vp, uio, cred, eofflag, cookies, ncookies)
d639 2
a640 2
	u_long *cookies;
	int ncookies;
d648 1
a649 1
	a.a_ncookies = ncookies;
d696 1
d699 2
a700 2
static __inline int VOP_INACTIVE __P((struct vnode *));
static __inline int VOP_INACTIVE(vp)
d702 1
d707 1
d714 1
d717 2
a718 2
static __inline int VOP_RECLAIM __P((struct vnode *));
static __inline int VOP_RECLAIM(vp)
d720 1
d725 1
d732 2
d736 2
a737 2
static __inline int VOP_LOCK __P((struct vnode *));
static __inline int VOP_LOCK(vp)
d739 2
d745 2
d753 2
d757 2
a758 2
static __inline int VOP_UNLOCK __P((struct vnode *));
static __inline int VOP_UNLOCK(vp)
d760 2
d766 2
d928 31
a1049 25
}

struct vop_lease_args {
	struct vnodeop_desc *a_desc;
	struct vnode *a_vp;
	struct proc *a_p;
	struct ucred *a_cred;
	int a_flag;
};
extern struct vnodeop_desc vop_lease_desc;
static __inline int VOP_LEASE __P((struct vnode *, struct proc *, 
    struct ucred *, int));
static __inline int VOP_LEASE(vp, p, cred, flag)
	struct vnode *vp;
	struct proc *p;
	struct ucred *cred;
	int flag;
{
	struct vop_lease_args a;
	a.a_desc = VDESC(vop_lease);
	a.a_vp = vp;
	a.a_p = p;
	a.a_cred = cred;
	a.a_flag = flag;
	return (VCALL(vp, VOFFSET(vop_lease), &a));
@


1.3
log
@sync
@
text
@d8 1
a8 1
 *	OpenBSD
@


1.2
log
@NetBSD 960317 merge
@
text
@d6 1
a6 1
 *	OpenBSD
d938 2
a939 2
	struct timeval *a_access;
	struct timeval *a_modify;
d943 2
a944 2
static __inline int VOP_UPDATE __P((struct vnode *, struct timeval *, 
    struct timeval *, int));
d947 2
a948 2
	struct timeval *access;
	struct timeval *modify;
@


1.1
log
@From NetBSD: vnode_if.[ch] made machine independent.
very usefull (for <sys/vnode.h> inclusion).
from the other side this is really machine independent ...
tested w/ i386, but should not cause errors w/ other arch's.
pls, test it (don't forget to reconfig kernel ;)
@
text
@d6 1
a6 1
 *	NetBSD: vnode_if.src,v 1.9 1996/02/09 14:45:38 mycroft Exp 
d8 1
a8 1
 *	NetBSD: vnode_if.sh,v 1.9 1996/02/29 20:58:22 cgd Exp 
@
