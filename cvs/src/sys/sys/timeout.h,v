head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.2
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.4
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.25.0.8
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.4
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.6
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.2
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.6
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.4
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.2
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.4
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.2
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.20
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.18
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.16
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.14
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.12
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2;
locks; strict;
comment	@ * @;


1.26
date	2016.09.22.12.55.24;	author mpi;	state Exp;
branches;
next	1.25;
commitid	yHpOPoIDV9B9PJbt;

1.25
date	2014.12.22.04.43.38;	author dlg;	state Exp;
branches;
next	1.24;
commitid	heMRN1DhgQwxUmkV;

1.24
date	2013.11.27.04.28.32;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.23.20.12.05;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2012.05.24.07.17.42;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2011.05.10.00.58.42;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2010.05.26.17.50.00;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.06.02.22.05.54;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.22.08.38.06;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.11.14.18.39;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.03.01.27.31;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.25.19.41.41;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.25.16.25.42;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.22.16.41.51;	author nordin;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.12.15.48.45;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.08.23.12.06.30;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.23.12.02.04;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.23.08.18.59;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.15.16.47.50;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.23.16.52.26;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.03.23.15.47.50;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.23.14.59.23;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.23.11.24.42;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.23.11.07.33;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.23.09.59.57;	author art;	state Exp;
branches;
next	;

1.6.2.1
date	2000.03.24.09.09.45;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.45.04;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	;

1.11.4.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Introduce a new 'softclock' thread that will be used to execute timeout
callbacks needing a process context.

The function timeout_set_proc(9) has to be used instead of timeout_set(9)
when a timeout callback needs a process context.

Note that if such a timeout is waiting, understand sleeping, for a non
negligible amount of time it might delay other timeouts needing a process
context.

dlg@@ agrees with this as a temporary solution.

Manpage tweaks from jmc@@

ok kettenis@@, bluhm@@, mikeb@@
@
text
@/*	$OpenBSD: timeout.h,v 1.25 2014/12/22 04:43:38 dlg Exp $	*/
/*
 * Copyright (c) 2000-2001 Artur Grabowski <art@@openbsd.org>
 * All rights reserved. 
 *
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 */

#ifndef _SYS_TIMEOUT_H_
#define _SYS_TIMEOUT_H_

/*
 * Interface for handling time driven events in the kernel.
 *
 * The basic component of this API is the struct timeout. The user should not
 * touch the internals of this structure, but it's the users responsibility
 * to allocate and deallocate timeouts.
 *
 * The functions used to manipulate timeouts are:
 *  - timeout_set(timeout, function, argument)
 *      Initializes a timeout struct to call the function with the argument.
 *      A timeout only needs to be initialized once.
 *  - timeout_add(timeout, ticks)
 *      Schedule this timeout to run in "ticks" ticks (there are hz ticks in
 *      one second). You may not touch the timeout with timeout_set once the
 *      timeout is scheduled. A second call to timeout_add with an already
 *      scheduled timeout will cause the old timeout to be canceled and the
 *      new will be scheduled.
 *  - timeout_del(timeout)
 *      Remove the timeout from the timeout queue. It's legal to remove
 *      a timeout that has already happened.
 *
 * These functions may be called in interrupt context (anything below splhigh).
 */

struct circq {
	struct circq *next;		/* next element */
	struct circq *prev;		/* previous element */
};

struct timeout {
	struct circq to_list;			/* timeout queue, don't move */
	void (*to_func)(void *);		/* function to call */
	void *to_arg;				/* function argument */
	int to_time;				/* ticks on event */
	int to_flags;				/* misc flags */
};

/*
 * flags in the to_flags field.
 */
#define TIMEOUT_NEEDPROCCTX	1	/* timeout needs a process context */
#define TIMEOUT_ONQUEUE		2	/* timeout is on the todo queue */
#define TIMEOUT_INITIALIZED	4	/* timeout is initialized */
#define TIMEOUT_TRIGGERED	8	/* timeout is running or ran */

#ifdef _KERNEL
/*
 * special macros
 *
 * timeout_pending(to) - is this timeout already scheduled to run?
 * timeout_initialized(to) - is this timeout initialized?
 */
#define timeout_pending(to) ((to)->to_flags & TIMEOUT_ONQUEUE)
#define timeout_initialized(to) ((to)->to_flags & TIMEOUT_INITIALIZED)
#define timeout_triggered(to) ((to)->to_flags & TIMEOUT_TRIGGERED)

#define TIMEOUT_INITIALIZER(_f, _a) \
	{ { NULL, NULL }, (_f), (_a), 0, TIMEOUT_INITIALIZED }

struct bintime;

void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_set_proc(struct timeout *, void (*)(void *), void *);
int timeout_add(struct timeout *, int);
int timeout_add_tv(struct timeout *, const struct timeval *);
int timeout_add_ts(struct timeout *, const struct timespec *);
int timeout_add_bt(struct timeout *, const struct bintime *);
int timeout_add_sec(struct timeout *, int);
int timeout_add_msec(struct timeout *, int);
int timeout_add_usec(struct timeout *, int);
int timeout_add_nsec(struct timeout *, int);
int timeout_del(struct timeout *);

void timeout_startup(void);
void timeout_adjust_ticks(int);

/*
 * called once every hardclock. returns non-zero if we need to schedule a
 * softclock.
 */
int timeout_hardclock_update(void);
#endif /* _KERNEL */

#endif	/* _SYS_TIMEOUT_H_ */
@


1.25
log
@add TIMEOUT_INITIALIZER for initting timeout declaractions.

similar to TASK_INITIALIZER and all the queue _INITIALIZER things.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.24 2013/11/27 04:28:32 dlg Exp $	*/
d70 1
d92 1
@


1.24
log
@make timeout_add and its wrappers return whether the timeout was scheduled
in this call by returning 1, or a previous call by returning 0. this makes
it easy to refcount the stuff we're scheduling a timeout for, and brings
the api in line with what task_add(9) provides.

ok mpi@@ matthew@@ mikeb@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.23 2013/10/23 20:12:05 deraadt Exp $	*/
d84 3
@


1.23
log
@need a forward declaration of bintime for the _KERNEL case, ie. trpt
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.22 2012/05/24 07:17:42 guenther Exp $	*/
d88 8
a95 8
void timeout_add(struct timeout *, int);
void timeout_add_tv(struct timeout *, const struct timeval *);
void timeout_add_ts(struct timeout *, const struct timespec *);
void timeout_add_bt(struct timeout *, const struct bintime *);
void timeout_add_sec(struct timeout *, int);
void timeout_add_msec(struct timeout *, int);
void timeout_add_usec(struct timeout *, int);
void timeout_add_nsec(struct timeout *, int);
@


1.22
log
@On resume, run forward the monotonic and realtimes clocks instead of jumping
just the realtime clock, triggering and adjusting timeouts to reflect that.

ok matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.21 2011/05/10 00:58:42 dlg Exp $	*/
d84 2
@


1.21
log
@tweak timeout_del so it can tell the caller if it actually did remove a
timeout or not.

without this it is impossible to tell if the timeout was removed
or if it is just about to run. if the caller of timeout_del is about
to free some state the timeout itself might use, this could lead
to a use after free.

now if timeout_del returns 1, you know the timeout wont fire and
you can proceed with cleanup. how you cope with the timeout being
about to fire is up to the caller of timeout_del.

discussed with drinking art and art, and most of k2k11
ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.20 2010/05/26 17:50:00 deraadt Exp $	*/
d97 1
@


1.20
log
@libevent has named two of it's new macros by the same name as our kernel
macros, which are visible, and get pulled into some source code...  Hide
the kernel ones inside _KERNEL, and make trpt (the only userland viewer of
them) define _KERNEL temporarily.  This is really gross.  libevent is doing
a poor job of choosing function names!
ok tedu guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.19 2009/06/02 22:05:54 guenther Exp $	*/
d94 1
a94 1
void timeout_del(struct timeout *);
@


1.19
log
@Constipate the second argument to timeout_add_*().  Also, use
nitems() in two places instead of coding the array size and fix a
spot of whitespace.

ok miod@@ blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.18 2008/10/22 08:38:06 blambert Exp $	*/
d74 1
a84 1
#ifdef _KERNEL
@


1.18
log
@Add timeout_add_msec(), for timeouts in milliseconds.

Idea and original patch mk@@

ok mk@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.17 2008/07/11 14:18:39 blambert Exp $	*/
d72 2
a73 1
#define TIMEOUT_TRIGGERED       8       /* timeout is running or ran */
d87 3
a89 3
void timeout_add_tv(struct timeout *, struct timeval *);
void timeout_add_ts(struct timeout *, struct timespec *);
void timeout_add_bt(struct timeout *, struct bintime *);
@


1.17
log
@Add timeout_add_{tv,ts,bt,sec,usec,nsec} so that we can add timeouts
in something other than clock ticks. From art@@'s punchlist and (for
the time being) not yet used.

"you're doing it wrong" art@@,ray@@,otto@@,tedu@@

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.16 2003/06/03 01:27:31 art Exp $	*/
d90 1
@


1.16
log
@license cleaning.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.15 2002/06/25 19:41:41 mickey Exp $	*/
d86 6
@


1.15
log
@still export the macros, some userland uses it
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.14 2002/06/25 16:25:42 mickey Exp $	*/
d12 1
a12 4
 * 2. Redistributions in binary form must reproduce the above copyright 
 *    notice, this list of conditions and the following disclaimer in the 
 *    documentation and/or other materials provided with the distribution. 
 * 3. The name of the author may not be used to endorse or promote products
@


1.14
log
@protos and macros are only for _KERNEL, malliciously pollutes the user name space otherwise
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.13 2002/03/14 01:27:14 millert Exp $	*/
a75 5
#ifdef _KERNEL
void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_add(struct timeout *, int);
void timeout_del(struct timeout *);

d85 5
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.12 2001/12/22 16:41:51 nordin Exp $	*/
d76 1
d98 1
@


1.12
log
@New scalable implementation with constant time add and delete. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.11 2001/09/12 15:48:45 art Exp $	*/
d64 1
a64 1
	void (*to_func) __P((void *));		/* function to call */
@


1.11
log
@Rename timeout_init to timeout_startup to deconfuse a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.10 2001/08/23 12:06:30 art Exp $	*/
d3 1
a3 1
 * Copyright (c) 2000 Artur Grabowski <art@@openbsd.org>
a32 2
#include <sys/queue.h>

d57 5
d63 1
a63 1
	TAILQ_ENTRY(timeout) to_list;		/* timeout queue */
d76 3
a78 3
void timeout_set __P((struct timeout *, void (*)(void *), void *));
void timeout_add __P((struct timeout *, int));
void timeout_del __P((struct timeout *));
d90 1
a90 1
void timeout_startup __P((void));
d96 1
a96 1
int timeout_hardclock_update __P((void));
@


1.11.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.12 2001/12/22 16:41:51 nordin Exp $	*/
d3 1
a3 1
 * Copyright (c) 2000-2001 Artur Grabowski <art@@openbsd.org>
d33 2
a58 5
struct circq {
	struct circq *next;		/* next element */
	struct circq *prev;		/* previous element */
};

d60 1
a60 1
	struct circq to_list;			/* timeout queue, don't move */
d73 3
a75 3
void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_add(struct timeout *, int);
void timeout_del(struct timeout *);
d87 1
a87 1
void timeout_startup(void);
d93 1
a93 1
int timeout_hardclock_update(void);
@


1.11.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.11.4.1 2002/01/31 22:55:49 niklas Exp $	*/
d64 1
a64 1
	void (*to_func)(void *);		/* function to call */
@


1.11.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.11.4.2 2002/06/11 03:32:34 art Exp $	*/
d76 4
a89 5
#ifdef _KERNEL
void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_add(struct timeout *, int);
void timeout_del(struct timeout *);

a96 1
#endif /* _KERNEL */
@


1.10
log
@Remove more.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.9 2001/08/23 12:02:04 art Exp $	*/
d87 1
a87 5
/*
 * timeout_init - called by the machine dependent code to initialize a static
 *                list of preallocated timeout structures.
 */
void timeout_init __P((void));
@


1.9
log
@Remove even more old timeout tentacles.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.8 2001/08/23 08:18:59 miod Exp $	*/
a69 1
#define TIMEOUT_STATIC		1	/* allocated from static pool */
@


1.8
log
@Remove the old timeout legacy code.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.7 2001/03/15 16:47:50 csapuntz Exp $	*/
a99 5
/*
 * XXX - this should go away.
 */
extern int ntimeout;
extern struct timeout *timeouts;
@


1.7
log
@

Triggered mechanism allows a handler to figure out whether a given
timeout is actually executing.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 4
 *
 * XXX - the old timeout()/untimeout() API is kept for compatibility, you may
 *       not use the new API if there is a risk that the same function/argument
 *       pairs are mixed in the new and old API.
@


1.6
log
@Another typo. Noted by aaron.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.5 2000/03/23 15:47:50 art Exp $	*/
d77 1
a77 1

d90 1
@


1.6.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d77 1
a77 1
#define TIMEOUT_TRIGGERED       8       /* timeout is running or ran */
a89 1
#define timeout_triggered(to) ((to)->to_flags & TIMEOUT_TRIGGERED)
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.6.2.2 2001/05/14 22:45:04 niklas Exp $	*/
d57 4
d74 1
d92 5
a96 1
void timeout_startup __P((void));
d104 5
@


1.6.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1
 * Copyright (c) 2000-2001 Artur Grabowski <art@@openbsd.org>
d33 2
a58 5
struct circq {
	struct circq *next;		/* next element */
	struct circq *prev;		/* previous element */
};

d60 1
a60 1
	struct circq to_list;			/* timeout queue, don't move */
d73 3
a75 3
void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_add(struct timeout *, int);
void timeout_del(struct timeout *);
d87 1
a87 1
void timeout_startup(void);
d93 1
a93 1
int timeout_hardclock_update(void);
@


1.6.2.5
log
@Merge in -current from roughly a week ago
@
text
@d64 1
a64 1
	void (*to_func)(void *);		/* function to call */
@


1.6.2.6
log
@Sync the SMP branch with 3.3
@
text
@d76 4
a89 5
#ifdef _KERNEL
void timeout_set(struct timeout *, void (*)(void *), void *);
void timeout_add(struct timeout *, int);
void timeout_del(struct timeout *);

a96 1
#endif /* _KERNEL */
@


1.6.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.6.2.6 2003/03/28 00:41:30 niklas Exp $	*/
d12 4
a15 1
 * 2. The name of the author may not be used to endorse or promote products
@


1.5
log
@Opps. Fix a comment from "should" to "should not".
Thanks to mickey@@ for pointing this out.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.4 2000/03/23 14:59:23 art Exp $	*/
d42 1
a42 1
 * Ther functions used to manipulate timeouts are:
@


1.4
log
@Protect from multiple include.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.3 2000/03/23 11:24:42 art Exp $	*/
d38 1
a38 1
 * The basic component of this API is the struct timeout. The user should
@


1.3
log
@Speling.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.2 2000/03/23 11:07:33 art Exp $	*/
d30 3
d108 1
@


1.2
log
@Provide methods to check if a timeout was initalized and if it is scheduled.
@
text
@d1 1
a1 1
/*	$OpenBSD: timeout.h,v 1.1 2000/03/23 09:59:57 art Exp $	*/
d86 1
a86 1
#define timeout_initalized(to) ((to)->to_flags & TIMEOUT_INITIALIZED)
@


1.1
log
@New API for timeouts. Replaces the old timeout()/untimeout() API and
makes it the callers responsibility to allocate resources for the
timeouts.

This is a KISS implementation and does _not_ solve the problems of slow
handling of a large number of pending timeouts (this will be solved in
future work) (although hardclock is now guarateed to take constant time
for handling of timeouts).

Old timeout() and untimeout() are implemented as wrappers around the new
API and kept for compatibility. They will be removed as soon as all
subsystems are converted to use the new API.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 3
a73 2
#define TIMEOUT_STATIC	1		/* allocated from static pool */
#define TIMEOUT_ONQUEUE	2		/* timeout is on the todo queue */
d78 9
@

