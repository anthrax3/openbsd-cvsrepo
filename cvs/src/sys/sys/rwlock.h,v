head	1.20;
access;
symbols
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.4
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.6
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.18.0.2
	OPENBSD_5_7_BASE:1.18
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.11.0.12
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.8
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.11.0.6
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.4
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.20
date	2016.09.21.10.19.13;	author dlg;	state Exp;
branches;
next	1.19;
commitid	JKa1sfACTGRBYiEl;

1.19
date	2016.09.21.07.44.36;	author mpi;	state Exp;
branches;
next	1.18;
commitid	sb5wacVoRkKzIKLh;

1.18
date	2015.02.11.00.14.11;	author dlg;	state Exp;
branches;
next	1.17;
commitid	OPUATglsyqcmeG4g;

1.17
date	2015.02.10.10.04.27;	author dlg;	state Exp;
branches;
next	1.16;
commitid	BGSlxgt9MbwlOxvC;

1.16
date	2014.07.09.13.32.00;	author guenther;	state Exp;
branches;
next	1.15;
commitid	ZU9xQk5IchFd0Jm2;

1.15
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2013.05.01.17.13.05;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.13.21.30;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	2009.08.13.21.22.29;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.29.00.17.32;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.04.12.56.15;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2007.04.04.18.01.57;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.05.05.15.22;	author tedu;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.02.05.02.34;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2006.05.07.20.12.41;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.06.06.50.31;	author tedu;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.21.12.10.20;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.11.00.42.03;	author tedu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.12.28.17.14.33;	author tedu;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.18.06.11.10;	author tedu;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.20
log
@straighten the chairs
@
text
@/*	$OpenBSD: rwlock.h,v 1.19 2016/09/21 07:44:36 mpi Exp $	*/
/*
 * Copyright (c) 2002 Artur Grabowski <art@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Multiple readers, single writer lock.
 *
 * Simplistic implementation modelled after rw locks in Solaris.
 *
 * The rwl_owner has the following layout:
 * [ owner or count of readers | wrlock | wrwant | wait ]
 *
 * When the WAIT bit is set (bit 0), the lock has waiters sleeping on it.
 * When the WRWANT bit is set (bit 1), at least one waiter wants a write lock.
 * When the WRLOCK bit is set (bit 2) the lock is currently write-locked.
 *
 * When write locked, the upper bits contain the struct proc * pointer to
 * the writer, otherwise they count the number of readers.
 *
 * We provide a simple machine independent implementation:
 *
 * void rw_enter_read(struct rwlock *)
 *  atomically test for RWLOCK_WRLOCK and if not set, increment the lock
 *  by RWLOCK_READ_INCR. While RWLOCK_WRLOCK is set, loop into rw_enter_wait.
 *
 * void rw_enter_write(struct rwlock *);
 *  atomically test for the lock being 0 (it's not possible to have
 *  owner/read count unset and waiter bits set) and if 0 set the owner to
 *  the proc and RWLOCK_WRLOCK. While not zero, loop into rw_enter_wait.
 *
 * void rw_exit_read(struct rwlock *);
 *  atomically decrement lock by RWLOCK_READ_INCR and unset RWLOCK_WAIT and
 *  RWLOCK_WRWANT remembering the old value of lock and if RWLOCK_WAIT was set,
 *  call rw_exit_waiters with the old contents of the lock.
 *
 * void rw_exit_write(struct rwlock *);
 *  atomically swap the contents of the lock with 0 and if RWLOCK_WAIT was
 *  set, call rw_exit_waiters with the old contents of the lock.
 */

#ifndef _SYS_RWLOCK_H
#define _SYS_RWLOCK_H

struct proc;

struct rwlock {
	volatile unsigned long	 rwl_owner;
	const char		*rwl_name;
};

#define RWLOCK_INITIALIZER(name)	{ 0, name }

#define RWLOCK_WAIT		0x01UL
#define RWLOCK_WRWANT		0x02UL
#define RWLOCK_WRLOCK		0x04UL
#define RWLOCK_MASK		0x07UL

#define RWLOCK_OWNER(rwl)	((struct proc *)((rwl)->rwl_owner & ~RWLOCK_MASK))

#define RWLOCK_READER_SHIFT	3UL
#define RWLOCK_READ_INCR	(1UL << RWLOCK_READER_SHIFT)

#define RW_WRITE		0x0001UL /* exclusive lock */
#define RW_READ			0x0002UL /* shared lock */
#define RW_DOWNGRADE		0x0004UL /* downgrade exclusive to shared */
#define RW_OPMASK		0x0007UL

#define RW_INTR			0x0010UL /* interruptible sleep */
#define RW_SLEEPFAIL		0x0020UL /* fail if we slept for the lock */
#define RW_NOSLEEP		0x0040UL /* don't wait for the lock */
#define RW_RECURSEFAIL		0x0080UL /* Fail on recursion for RRW locks. */

/*
 * for rw_status() and rrw_status() only: exclusive lock held by
 * some other thread
 */
#define RW_WRITE_OTHER		0x0100UL

/* recursive rwlocks; */
struct rrwlock {
	struct rwlock		 rrwl_lock;
	uint32_t		 rrwl_wcnt; /* # writers. */
};

#ifdef _KERNEL

void	rw_init(struct rwlock *, const char *);

void	rw_enter_read(struct rwlock *);
void	rw_enter_write(struct rwlock *);
void	rw_exit_read(struct rwlock *);
void	rw_exit_write(struct rwlock *);

#ifdef DIAGNOSTIC
void	rw_assert_wrlock(struct rwlock *);
void	rw_assert_rdlock(struct rwlock *);
void	rw_assert_unlocked(struct rwlock *);
#else
#define rw_assert_wrlock(rwl)	((void)0)
#define rw_assert_rdlock(rwl)	((void)0)
#define rw_assert_unlocked(rwl)	((void)0)
#endif

int	rw_enter(struct rwlock *, int);
void	rw_exit(struct rwlock *);
int	rw_status(struct rwlock *);

void	rrw_init(struct rrwlock *, char *);
int	rrw_enter(struct rrwlock *, int);
void	rrw_exit(struct rrwlock *);
int	rrw_status(struct rrwlock *);

#endif /* _KERNEL */

#endif /* _SYS_RWLOCK_H */
@


1.19
log
@Sprinkle some #ifdef _KERNEL, autumn is here.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.18 2015/02/11 00:14:11 dlg Exp $	*/
d60 2
a61 2
	volatile unsigned long rwl_owner;
	const char *rwl_name;
d76 9
a84 9
#define RW_WRITE	0x0001UL	/* exclusive lock */
#define RW_READ		0x0002UL	/* shared lock */
#define RW_DOWNGRADE	0x0004UL	/* downgrade exclusive to shared */
#define RW_OPMASK	0x0007UL

#define RW_INTR		0x0010UL	/* interruptible sleep */
#define RW_SLEEPFAIL	0x0020UL	/* fail if we slept for the lock */
#define RW_NOSLEEP	0x0040UL	/* don't wait for the lock */
#define RW_RECURSEFAIL	0x0080UL	/* Fail on recursion for RRW locks. */
d90 1
a90 1
#define RW_WRITE_OTHER	0x0100UL
d94 2
a95 2
	struct rwlock	rrwl_lock;
	uint32_t	rrwl_wcnt;	/* # writers. */
d100 1
a100 1
void rw_init(struct rwlock *, const char *);
d102 4
a105 4
void rw_enter_read(struct rwlock *);
void rw_enter_write(struct rwlock *);
void rw_exit_read(struct rwlock *);
void rw_exit_write(struct rwlock *);
d108 3
a110 3
void rw_assert_wrlock(struct rwlock *);
void rw_assert_rdlock(struct rwlock *);
void rw_assert_unlocked(struct rwlock *);
d112 3
a114 3
#define rw_assert_wrlock(rwl) ((void)0)
#define rw_assert_rdlock(rwl) ((void)0)
#define rw_assert_unlocked(rwl) ((void)0)
d117 3
a119 3
int rw_enter(struct rwlock *, int);
void rw_exit(struct rwlock *);
int rw_status(struct rwlock *);
@


1.18
log
@make the rwlock implementation MI.

each arch used to have to provide an rw_cas operation, but now we
have the rwlock code build its own version. on smp machines it uses
atomic_cas_ulong. on uniproc machines it avoids interlocked
instructions by using straight loads and stores. this is safe because
rwlocks are only used from process context and processes are currently
not preemptible in our kernel. so alpha/ppc/etc might get a benefit.

ok miod@@ kettenis@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.17 2015/02/10 10:04:27 dlg Exp $	*/
d54 2
a55 2
#ifndef SYS_RWLOCK_H
#define SYS_RWLOCK_H
a75 21
void rw_init(struct rwlock *, const char *);

void rw_enter_read(struct rwlock *);
void rw_enter_write(struct rwlock *);
void rw_exit_read(struct rwlock *);
void rw_exit_write(struct rwlock *);

#ifdef DIAGNOSTIC
void rw_assert_wrlock(struct rwlock *);
void rw_assert_rdlock(struct rwlock *);
void rw_assert_unlocked(struct rwlock *);
#else
#define rw_assert_wrlock(rwl) ((void)0)
#define rw_assert_rdlock(rwl) ((void)0)
#define rw_assert_unlocked(rwl) ((void)0)
#endif

int rw_enter(struct rwlock *, int);
void rw_exit(struct rwlock *);
int rw_status(struct rwlock *);

d98 23
d126 3
a128 1
#endif
@


1.17
log
@remove #ifndef handling of __HAVE_MD_RWLOCK. it's never set, and with a
reasonable compiler it isnt necessary.

ok miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.16 2014/07/09 13:32:00 guenther Exp $	*/
a111 4

#ifndef rw_cas
int rw_cas(volatile unsigned long *, unsigned long, unsigned long);
#endif
@


1.16
log
@Teach rw_status() and rrw_status() to return LK_EXCLOTHER if it's write
locked by a different thread.  Teach lockstatus() to return LK_EXCLUSIVE
if an exclusive lock is held by some other thread.

ok beck@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.15 2014/03/29 18:09:31 guenther Exp $	*/
d33 1
a33 4
 * We provide a simple machine independent implementation that can be
 * optimized by machine dependent code when __HAVE_MD_RWLOCK is defined.
 *
 * MD code that defines __HAVE_MD_RWLOCK and implement four functions:
a51 2
 *
 * (XXX - the rest of the API for this is not invented yet).
@


1.15
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.14 2013/05/01 17:13:05 tedu Exp $	*/
d111 6
@


1.14
log
@exorcise lockmgr. the api remains, but is now backed by recursive rwlocks.
originally by thib.
ok deraadt jsing and anyone who tested
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.13 2010/09/24 13:21:30 matthew Exp $	*/
d65 1
a65 1
	__volatile unsigned long rwl_owner;
@


1.13
log
@Add stricter asserts to DIAGNOSTIC kernels to help catch mutex and
rwlock misuse.  In particular, this commit makes the following
changes:

  1. i386 and amd64 now count the number of active mutexes so that
assertwaitok(9) can detect attempts to sleep while holding a mutex.

  2. i386 and amd64 check that we actually hold mutexes when passed to
mtx_leave().

  3. Calls to rw_exit*() now call rw_assert_{rd,wr}lock() as
appropriate.

ok krw@@, oga@@; "sounds good to me" deraadt@@; assembly bits double
checked by pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.12 2009/08/13 21:22:29 blambert Exp $	*/
a3 1
 * All rights reserved. 
d5 11
a15 19
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met: 
 *
 * 1. Redistributions of source code must retain the above copyright 
 *    notice, this list of conditions and the following disclaimer. 
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission. 
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL  DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
d37 1
a37 1
 *  
a61 1

d100 11
a110 8
#define RW_WRITE	0x00UL		/* exclusive lock */	
#define RW_READ		0x01UL		/* shared lock */
#define RW_DOWNGRADE	0x02UL		/* downgrade exclusive to shared */
#define RW_OPMASK	0x03UL

#define RW_INTR		0x10UL		/* interruptible sleep */
#define RW_SLEEPFAIL	0x20UL		/* fail if we slept for the lock */
#define RW_NOSLEEP	0x40UL		/* don't wait for the lock */
d115 11
@


1.12
log
@rwlock assertion functions, currently unused

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.11 2007/05/29 00:17:32 thib Exp $	*/
d98 1
d102 5
@


1.11
log
@Add a name argument to the RWLOCK_INITIALIZER macro.
Pick reasonble names for the locks involved..

ok tedu@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.10 2007/05/04 12:56:15 art Exp $	*/
d97 4
@


1.10
log
@- Rename rw_test_and_set to rw_cas, since most litterature uses the
  test_and_set name for some other operation, while cas is generally
  used for compare and set (cmpxchg in intel land, cas in sparc land).

- Make rw locks properly MP safe (provided that rw_cas is implemented
  in MD code). Most operations were MP safe except the sleep where we
  could have set the "I'm sleeping" flag before actually going to sleep
  so that the wakeup could miss us. Now, using the split tsleep,
  we first setup the sleep (put us on the sleep queues), then set
  the flag aborting the sleep if the lock has changed and then finally
  go to sleep.

miod@@ ok (and he's been prodding me for days to get this in)
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.9 2007/04/04 18:01:57 art Exp $	*/
d79 1
a79 1
#define RWLOCK_INITIALIZER	{ 0 }
@


1.9
log
@Implement RW_DOWNGRADE that downgrades an exclusive lock to a shared lock
without letting any other exclusive locks in between. As opposed to upgrading
locks, this is easy and solves real problems.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.8 2006/06/05 05:15:22 tedu Exp $	*/
d109 3
a111 1
int rw_test_and_set(volatile unsigned long *, unsigned long, unsigned long);
@


1.8
log
@fix really stupid botch i made in last commit. RW_WRITE and RW_READ are
array indices not flags, and can't be renumbered trivially.
noticed by sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.7 2006/06/02 05:02:34 tedu Exp $	*/
d102 3
a104 1
#define RW_OPMASK	0x01UL
@


1.7
log
@remove upgrade/downgrade, they are useless.
rework the main entry points to just use rw_test_and_set.
rework exit paths to be more like enter paths.
add sleepfail so more lockmgr can be replaced.
some from art, ok sturm
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.6 2006/05/07 20:12:41 tedu Exp $	*/
d100 3
a102 3
#define RW_WRITE	0x01UL		/* exclusive lock */	
#define RW_READ		0x02UL		/* shared lock */
#define RW_OPMASK	0x03UL
@


1.6
log
@add a name to rwlock so that we can tell where procs are getting stuck
without breaking into ddb.  doubles the size of rwlock [1], but moving
forward this really helps.  ok/tested pedro fgsch millert krw
[1 - next person to add a field to this struct gets whipped with a wet noodle]
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.5 2006/01/06 06:50:31 tedu Exp $	*/
a96 1
int rw_test_and_set(volatile unsigned long *, unsigned long, unsigned long);
d99 4
a102 5
#define RW_WRITE	0x00UL		/* exclusive lock */	
#define RW_READ		0x01UL		/* shared lock */
#define RW_UPGRADE	0x02UL		/* read -> write upgrade */
#define RW_DOWNGRADE	0x03UL		/* write -> read downgrade */
#define RW_OPMASK	0x07UL
d105 1
d107 1
a107 2
int rw_enter_wait(struct rwlock *, struct proc *, int);
void rw_exit_waiters(struct rwlock *, unsigned long);
@


1.5
log
@check in of "rwlock.20051230" from art.
mostly cleanup and simplification, though now also supporting
upgrade and downgrade via the magic wand.
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.4 2004/07/21 12:10:20 art Exp $	*/
d76 1
d91 1
a91 1
void rw_init(struct rwlock *);
@


1.4
log
@I was wrong. The assymetry created by the proc argument to rw_enter_write
is horrible and doesn't add anything.

Remove it.
XXX - the fdplock macro will need a separate cleanup.

niklas@@ markus@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.3 2004/01/11 00:42:03 tedu Exp $	*/
d80 4
a83 4
#define RWLOCK_WAIT		0x01
#define RWLOCK_WRWANT		0x02
#define RWLOCK_WRLOCK		0x04
#define RWLOCK_MASK		0x07
d87 2
a88 2
#define RWLOCK_READER_SHIFT	3
#define RWLOCK_READ_INCR	(1 << RWLOCK_READER_SHIFT)
d96 1
d98 10
a107 6
/*
 * Internal API.
 */
#define RW_WRITE	0x00
#define RW_READ		0x01
void rw_enter_wait(struct rwlock *, struct proc *, int);
@


1.3
log
@let lsof compile again.  report and fix confirmed pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.2 2003/12/28 17:14:33 tedu Exp $	*/
d51 1
a51 1
 * void rw_enter_write(struct rwlock *, struct proc *);
d93 1
a93 1
void rw_enter_write(struct rwlock *, struct proc *);
@


1.3.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@multiple include protection
@
text
@d1 1
a1 1
/*	$OpenBSD: rwlock.h,v 1.1 2003/11/18 06:11:10 tedu Exp $	*/
d70 3
@


1.1
log
@add lightwight reader/writer locks from art@@.  we will be using these
later.  have been looked over for quite some time now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 3
d102 1
@

