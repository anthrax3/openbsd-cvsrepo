head	1.125;
access;
symbols
	OPENBSD_6_0:1.113.0.2
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.109.0.2
	OPENBSD_5_9_BASE:1.109
	OPENBSD_5_8:1.108.0.4
	OPENBSD_5_8_BASE:1.108
	OPENBSD_5_7:1.107.0.2
	OPENBSD_5_7_BASE:1.107
	OPENBSD_5_6:1.101.0.4
	OPENBSD_5_6_BASE:1.101
	OPENBSD_5_5:1.100.0.6
	OPENBSD_5_5_BASE:1.100
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.95.0.2
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.90.0.4
	OPENBSD_5_2_BASE:1.90
	OPENBSD_5_1_BASE:1.90
	OPENBSD_5_1:1.90.0.2
	OPENBSD_5_0:1.89.0.2
	OPENBSD_5_0_BASE:1.89
	OPENBSD_4_9:1.87.0.2
	OPENBSD_4_9_BASE:1.87
	OPENBSD_4_8:1.81.0.2
	OPENBSD_4_8_BASE:1.81
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.76.0.4
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.74.0.2
	OPENBSD_4_4_BASE:1.74
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.72.0.2
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.70.0.2
	OPENBSD_4_1_BASE:1.70
	OPENBSD_4_0:1.69.0.2
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.68.0.2
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.66.0.4
	OPENBSD_3_8_BASE:1.66
	OPENBSD_3_7:1.66.0.2
	OPENBSD_3_7_BASE:1.66
	OPENBSD_3_6:1.63.0.2
	OPENBSD_3_6_BASE:1.63
	SMP_SYNC_A:1.61
	SMP_SYNC_B:1.61
	OPENBSD_3_5:1.60.0.2
	OPENBSD_3_5_BASE:1.60
	OPENBSD_3_4:1.58.0.2
	OPENBSD_3_4_BASE:1.58
	UBC_SYNC_A:1.54
	OPENBSD_3_3:1.54.0.2
	OPENBSD_3_3_BASE:1.54
	OPENBSD_3_2:1.52.0.2
	OPENBSD_3_2_BASE:1.52
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.52
	UBC:1.44.0.2
	UBC_BASE:1.44
	OPENBSD_3_0:1.43.0.2
	OPENBSD_3_0_BASE:1.43
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_9:1.37.0.8
	OPENBSD_2_8:1.37.0.6
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.37.0.4
	OPENBSD_2_7_BASE:1.37
	SMP:1.37.0.2
	SMP_BASE:1.37
	kame_19991208:1.36
	OPENBSD_2_6:1.32.0.2
	OPENBSD_2_6_BASE:1.32
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.24.0.4
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.20.0.2
	OPENBSD_2_1_BASE:1.20
	OPENBSD_2_0:1.9.0.2
	OPENBSD_2_0_BASE:1.9
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.125
date	2017.03.17.17.19.16;	author mpi;	state Exp;
branches;
next	1.124;
commitid	CxqvXOMqotM60GAI;

1.124
date	2017.02.14.09.46.21;	author mpi;	state Exp;
branches;
next	1.123;
commitid	4bln7omqWkS0RJo9;

1.123
date	2017.01.25.06.15.50;	author mpi;	state Exp;
branches;
next	1.122;
commitid	X7Hk1efefaYrWlw3;

1.122
date	2017.01.24.08.09.05;	author kettenis;	state Exp;
branches;
next	1.121;
commitid	AFlGOR9ncGCFYX1V;

1.121
date	2016.12.29.12.12.44;	author mpi;	state Exp;
branches;
next	1.120;
commitid	RhxGXGNe4WuNtTZs;

1.120
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.119;
commitid	QqHqT2WhCBWqYgGJ;

1.119
date	2016.09.24.18.35.52;	author tedu;	state Exp;
branches;
next	1.118;
commitid	1tGMcqbcyDEnrWA7;

1.118
date	2016.09.17.14.56.12;	author jasper;	state Exp;
branches;
next	1.117;
commitid	AME6RanIdONXXrOR;

1.117
date	2016.09.13.08.32.44;	author mpi;	state Exp;
branches;
next	1.116;
commitid	JUinkWUa5er75UzF;

1.116
date	2016.09.04.09.22.29;	author mpi;	state Exp;
branches;
next	1.115;
commitid	jBolvsPoQ0BaYiLs;

1.115
date	2016.09.03.14.46.56;	author naddy;	state Exp;
branches;
next	1.114;
commitid	RpNaiU9Lz1B3rhqT;

1.114
date	2016.09.01.12.50.53;	author akfaew;	state Exp;
branches;
next	1.113;
commitid	dWKlOWgSK0wK2OBV;

1.113
date	2016.05.17.23.28.03;	author bluhm;	state Exp;
branches;
next	1.112;
commitid	mdEa4Ht7h1M2c9Us;

1.112
date	2016.05.10.23.54.01;	author bluhm;	state Exp;
branches;
next	1.111;
commitid	ySY3TBIHoKy6xoBh;

1.111
date	2016.03.24.08.57.51;	author mpi;	state Exp;
branches;
next	1.110;
commitid	Jc6fCB1Fejw18SaQ;

1.110
date	2016.03.15.04.19.26;	author stefan;	state Exp;
branches;
next	1.109;
commitid	dVAAaMtSGQ5wNbP2;

1.109
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.108;
commitid	fbhqfhfdKxBcsetK;

1.108
date	2015.06.11.16.03.04;	author mikeb;	state Exp;
branches;
next	1.107;
commitid	Sz3xmpXbu74b3jvv;

1.107
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.106;
commitid	C5iGb36LQxjM60Q3;

1.106
date	2014.12.10.15.29.53;	author mikeb;	state Exp;
branches;
next	1.105;
commitid	qHQiR2HLROzvZr7B;

1.105
date	2014.12.10.12.27.57;	author mikeb;	state Exp;
branches;
next	1.104;
commitid	v6PAeA18rydwc5Vx;

1.104
date	2014.11.18.18.34.50;	author miod;	state Exp;
branches;
next	1.103;
commitid	WQpb6IGiOsZMlsEz;

1.103
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.102;
commitid	Z1vcFtHO8wRH0yRt;

1.102
date	2014.10.09.04.04.27;	author tedu;	state Exp;
branches;
next	1.101;
commitid	29cCQl7KlarTmoPD;

1.101
date	2014.07.13.15.46.21;	author uebayasi;	state Exp;
branches;
next	1.100;
commitid	Scu6CelRPdB3AwwA;

1.100
date	2013.06.11.18.15.54;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2013.04.24.17.29.02;	author matthew;	state Exp;
branches;
next	1.98;

1.98
date	2013.04.06.03.53.25;	author tedu;	state Exp;
branches;
next	1.97;

1.97
date	2013.04.06.03.44.34;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.28.16.41.39;	author tedu;	state Exp;
branches;
next	1.95;

1.95
date	2013.02.09.20.56.35;	author miod;	state Exp;
branches;
next	1.94;

1.94
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2012.09.26.00.09.48;	author brad;	state Exp;
branches;
next	1.92;

1.92
date	2012.08.07.05.16.53;	author guenther;	state Exp;
branches;
next	1.91;

1.91
date	2012.08.02.03.18.48;	author guenther;	state Exp;
branches;
next	1.90;

1.90
date	2012.01.13.12.55.52;	author jsing;	state Exp;
branches;
next	1.89;

1.89
date	2011.07.06.21.41.37;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2011.04.26.17.20.20;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2011.01.10.23.23.56;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2010.09.21.01.09.10;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2010.09.07.16.21.47;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2010.09.06.19.20.24;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2010.08.27.04.09.21;	author deraadt;	state Exp;
branches;
next	1.82;

1.82
date	2010.08.20.22.03.22;	author matthew;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.08.20.15.01;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.29.00.28.14;	author tedu;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.78;

1.78
date	2010.04.06.22.26.59;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.04.19.14.09;	author kettenis;	state Exp;
branches;
next	1.76;

1.76
date	2009.04.19.17.53.39;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.06.19.12.37;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.16.17.45.37;	author thib;	state Exp;
branches;
next	1.73;

1.73
date	2007.11.27.18.04.01;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.01.19.25.08;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2007.05.11.10.06.56;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2006.10.26.13.18.24;	author jmc;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.27.02.17.21;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.22.22.16.08;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.14.21.46.31;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2005.01.14.04.31.33;	author djm;	state Exp;
branches;
next	1.65;

1.65
date	2004.11.28.02.11.33;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2004.09.16.07.07.17;	author grange;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.20.17.28.26;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.13.21.49.28;	author niklas;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.08.18.09.31;	author marc;	state Exp;
branches;
next	1.60;

1.60
date	2004.01.05.00.16.56;	author espie;	state Exp;
branches;
next	1.59;

1.59
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.24.01.27.07;	author avsm;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.21.22.44.49;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.21.16.17.37;	author art;	state Exp;
branches;
next	1.54;

1.54
date	2003.01.21.16.59.23;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2003.01.09.22.27.12;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2002.07.12.13.31.20;	author art;	state Exp;
branches;
next	1.51;

1.51
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.15.23.17.53;	author art;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.20.31.31;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2002.02.15.01.59.26;	author art;	state Exp;
branches;
next	1.45;

1.45
date	2002.02.04.19.38.20;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2001.11.06.18.41.10;	author art;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2001.08.26.04.10.56;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2001.08.23.08.18.59;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.27.09.55.07;	author niklas;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.27.04.51.49;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.24.20.53.40;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.05.22.34.35;	author art;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.02.06.31.28;	author assar;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	99.12.02.00.23.35;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	99.11.12.05.58.54;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	99.11.12.05.56.33;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	99.11.07.17.39.14;	author provos;	state Exp;
branches;
next	1.32;

1.32
date	99.09.12.19.44.04;	author weingart;	state Exp;
branches;
next	1.31;

1.31
date	99.07.21.21.12.51;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	99.05.20.12.56.40;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	99.05.06.15.33.57;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	99.04.28.09.28.17;	author art;	state Exp;
branches;
next	1.27;

1.27
date	99.02.26.03.19.57;	author art;	state Exp;
branches;
next	1.26;

1.26
date	99.02.26.03.16.47;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	99.01.10.13.34.16;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	97.11.06.05.59.12;	author csapuntz;	state Exp;
branches;
next	1.23;

1.23
date	97.11.04.19.17.34;	author chuck;	state Exp;
branches;
next	1.22;

1.22
date	97.10.06.20.21.12;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.10.06.15.25.35;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	97.03.06.07.05.54;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	97.01.18.13.39.28;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.01.14.02.25.20;	author kstailey;	state Exp;
branches;
next	1.17;

1.17
date	96.12.08.14.25.52;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.11.29.04.53.38;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	96.11.24.04.30.56;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	96.11.11.15.35.20;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	96.11.06.01.29.24;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.10.29.08.46.27;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.10.29.08.28.24;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.10.19.10.02.45;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.08.15.13.49.48;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.07.23.23.54.17;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.07.02.06.52.06;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.06.09.03.40.36;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.05.02.13.14.59;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.32.04;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.21.41.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.57.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches;
next	;

1.37.2.1
date	2000.02.20.11.57.33;	author niklas;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2001.07.04.11.00.35;	author niklas;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.37.2.4;

1.37.2.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.37.2.5;

1.37.2.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.37.2.6;

1.37.2.6
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.37.2.7;

1.37.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.37.2.8;

1.37.2.8
date	2003.05.15.04.08.03;	author niklas;	state Exp;
branches;
next	1.37.2.9;

1.37.2.9
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.37.2.10;

1.37.2.10
date	2004.02.19.11.01.34;	author niklas;	state Exp;
branches;
next	1.37.2.11;

1.37.2.11
date	2004.06.05.17.19.55;	author niklas;	state Exp;
branches;
next	;

1.44.2.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.44.2.3;

1.44.2.3
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.125
log
@Revert the NET_LOCK() and bring back pf's contention lock for release.

For the moment the NET_LOCK() is always taken by threads running under
KERNEL_LOCK().  That means it doesn't buy us anything except a possible
deadlock that we did not spot.  So make sure this doesn't happen, we'll
have plenty of time in the next release cycle to stress test it.

ok visa@@
@
text
@/*	$OpenBSD: systm.h,v 1.124 2017/02/14 09:46:21 mpi Exp $	*/
/*	$NetBSD: systm.h,v 1.50 1996/06/09 04:55:09 briggs Exp $	*/

/*-
 * Copyright (c) 1982, 1988, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)systm.h	8.4 (Berkeley) 2/23/94
 */

#ifndef __SYSTM_H__
#define __SYSTM_H__

#include <sys/queue.h>
#include <sys/stdarg.h>

/*
 * The `securelevel' variable controls the security level of the system.
 * It can only be decreased by process 1 (/sbin/init).
 *
 * Security levels are as follows:
 *   -1	permanently insecure mode - always run system in level 0 mode.
 *    0	insecure mode - immutable and append-only flags may be turned off.
 *	All devices may be read or written subject to permission modes.
 *    1	secure mode - immutable and append-only flags may not be changed;
 *	raw disks of mounted filesystems, /dev/mem, and /dev/kmem are
 *	read-only.
 *    2	highly secure mode - same as (1) plus raw disks are always
 *	read-only whether mounted or not. This level precludes tampering
 *	with filesystems by unmounting them, but also inhibits running
 *	newfs while the system is secured.
 *
 * In normal operation, the system runs in level 0 mode while single user
 * and in level 1 mode while multiuser. If level 2 mode is desired while
 * running multiuser, it can be set in the multiuser startup script
 * (/etc/rc.local) using sysctl(1). If it is desired to run the system
 * in level 0 mode while multiuser, initialize the variable securelevel
 * in /sys/kern/kern_sysctl.c to -1. Note that it is NOT initialized to
 * zero as that would allow the vmunix binary to be patched to -1.
 * Without initialization, securelevel loads in the BSS area which only
 * comes into existence when the kernel is loaded and hence cannot be
 * patched by a stalking hacker.
 */
extern int securelevel;		/* system security level */
extern const char *panicstr;	/* panic message */
extern const char version[];		/* system version */
extern const char copyright[];	/* system copyright */
extern const char ostype[];
extern const char osversion[];
extern const char osrelease[];
extern int cold;		/* cold start flag initialized in locore */

extern int ncpus;		/* number of CPUs used */
extern int ncpusfound;		/* number of CPUs found */
extern int nblkdev;		/* number of entries in bdevsw */
extern int nchrdev;		/* number of entries in cdevsw */

extern int selwait;		/* select timeout address */
extern int maxmem;		/* max memory per process */
extern int physmem;		/* physical memory */

extern dev_t dumpdev;		/* dump device */
extern long dumplo;		/* offset into dumpdev */

extern dev_t rootdev;		/* root device */
extern u_char bootduid[8];	/* boot device disklabel uid */
extern u_char rootduid[8];	/* root device disklabel uid */
extern struct vnode *rootvp;	/* vnode equivalent to above */

extern dev_t swapdev;		/* swapping device */
extern struct vnode *swapdev_vp;/* vnode equivalent to above */

struct proc;
struct process;
#define curproc curcpu()->ci_curproc

typedef int	sy_call_t(struct proc *, void *, register_t *);

extern struct sysent {		/* system call table */
	short	sy_narg;	/* number of args */
	short	sy_argsize;	/* total size of arguments */
	int	sy_flags;
	sy_call_t *sy_call;	/* implementing function */
} sysent[];

#define SY_NOLOCK		0x01

#if	_BYTE_ORDER == _BIG_ENDIAN
#define SCARG(p, k)	((p)->k.be.datum)	/* get arg from args pointer */
#elif	_BYTE_ORDER == _LITTLE_ENDIAN
#define SCARG(p, k)	((p)->k.le.datum)	/* get arg from args pointer */
#else
#error	"what byte order is this machine?"
#endif

#if defined(_KERNEL) && defined(SYSCALL_DEBUG)
void scdebug_call(struct proc *p, register_t code, const register_t retval[]);
void scdebug_ret(struct proc *p, register_t code, int error,
    const register_t retval[]);
#endif /* _KERNEL && SYSCALL_DEBUG */

extern int boothowto;		/* reboot flags, from console subsystem */

extern void (*v_putc)(int); /* Virtual console putc routine */

/*
 * General function declarations.
 */
int	nullop(void *);
int	enodev(void);
int	enosys(void);
int	enoioctl(void);
int	enxio(void);
int	eopnotsupp(void *);

struct vnodeopv_desc;
void vfs_opv_init_explicit(struct vnodeopv_desc *);
void vfs_opv_init_default(struct vnodeopv_desc *);
void vfs_op_init(void);

int	seltrue(dev_t dev, int which, struct proc *);
int	selfalse(dev_t dev, int which, struct proc *);
void	*hashinit(int, int, int, u_long *);
void	 hashfree(void *, int, int);
int	sys_nosys(struct proc *, void *, register_t *);

void	panic(const char *, ...)
    __attribute__((__noreturn__,__format__(__kprintf__,1,2)));
void	__assert(const char *, const char *, int, const char *)
    __attribute__((__noreturn__));
int	printf(const char *, ...)
    __attribute__((__format__(__kprintf__,1,2)));
void	uprintf(const char *, ...)
    __attribute__((__format__(__kprintf__,1,2)));
int	vprintf(const char *, va_list)
    __attribute__((__format__(__kprintf__,1,0)));
int	vsnprintf(char *, size_t, const char *, va_list)
    __attribute__((__format__(__kprintf__,3,0)));
int	snprintf(char *buf, size_t, const char *, ...)
    __attribute__((__format__(__kprintf__,3,4)));
struct tty;
void	ttyprintf(struct tty *, const char *, ...)
    __attribute__((__format__(__kprintf__,2,3)));

void	splassert_fail(int, int, const char *);
extern	int splassert_ctl;

void	assertwaitok(void);

void	tablefull(const char *);

int	kcopy(const void *, void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,3)))
		__attribute__ ((__bounded__(__buffer__,2,3)));

void	bcopy(const void *, void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,3)))
		__attribute__ ((__bounded__(__buffer__,2,3)));
void	bzero(void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,2)));
void	explicit_bzero(void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,2)));
int	bcmp(const void *, const void *, size_t);
void	*memcpy(void *, const void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,3)))
		__attribute__ ((__bounded__(__buffer__,2,3)));
void	*memmove(void *, const void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,3)))
		__attribute__ ((__bounded__(__buffer__,2,3)));
void	*memset(void *, int, size_t)
		__attribute__ ((__bounded__(__buffer__,1,3)));

int	copystr(const void *, void *, size_t, size_t *)
		__attribute__ ((__bounded__(__string__,2,3)));
int	copyinstr(const void *, void *, size_t, size_t *)
		__attribute__ ((__bounded__(__string__,2,3)));
int	copyoutstr(const void *, void *, size_t, size_t *);
int	copyin(const void *, void *, size_t)
		__attribute__ ((__bounded__(__buffer__,2,3)));
int	copyout(const void *, void *, size_t);

void	arc4random_buf(void *, size_t)
		__attribute__ ((__bounded__(__buffer__,1,2)));
u_int32_t arc4random(void);
u_int32_t arc4random_uniform(u_int32_t);

struct timeval;
struct timespec;
int	tvtohz(const struct timeval *);
int	tstohz(const struct timespec *);
void	realitexpire(void *);

struct clockframe;
void	hardclock(struct clockframe *);
void	softclock(void *);
void	statclock(struct clockframe *);

void	initclocks(void);
void	inittodr(time_t);
void	resettodr(void);
void	cpu_initclocks(void);

void	startprofclock(struct process *);
void	stopprofclock(struct process *);
void	setstatclockrate(int);

void	start_periodic_resettodr(void);
void	stop_periodic_resettodr(void);

struct sleep_state;
void	sleep_setup(struct sleep_state *, const volatile void *, int,
	    const char *);
void	sleep_setup_timeout(struct sleep_state *, int);
void	sleep_setup_signal(struct sleep_state *, int);
void	sleep_finish(struct sleep_state *, int);
int	sleep_finish_timeout(struct sleep_state *);
int	sleep_finish_signal(struct sleep_state *);
void	sleep_queue_init(void);

struct mutex;
struct rwlock;
void    wakeup_n(const volatile void *, int);
void    wakeup(const volatile void *);
#define wakeup_one(c) wakeup_n((c), 1)
int	tsleep(const volatile void *, int, const char *, int);
int	msleep(const volatile void *, struct mutex *, int,  const char*, int);
int	rwsleep(const volatile void *, struct rwlock *, int, const char *, int);
void	yield(void);

void	wdog_register(int (*)(void *, int), void *);
void	wdog_shutdown(void *);

/*
 * Startup hooks are functions running after the scheduler has started
 * but before any threads have been created or root has been mounted.
 */

struct hook_desc {
	TAILQ_ENTRY(hook_desc) hd_list;
	void	(*hd_fn)(void *);
	void	*hd_arg;
};
TAILQ_HEAD(hook_desc_head, hook_desc);

extern struct hook_desc_head startuphook_list;

void	*hook_establish(struct hook_desc_head *, int, void (*)(void *), void *);
void	hook_disestablish(struct hook_desc_head *, void *);
void	dohooks(struct hook_desc_head *, int);

#define HOOK_REMOVE	0x01
#define HOOK_FREE	0x02

#define startuphook_establish(fn, arg) \
	hook_establish(&startuphook_list, 1, (fn), (arg))
#define startuphook_disestablish(vhook) \
	hook_disestablish(&startuphook_list, (vhook))
#define dostartuphooks() dohooks(&startuphook_list, HOOK_REMOVE|HOOK_FREE)

struct uio;
int	uiomove(void *, size_t, struct uio *);

#if defined(_KERNEL)

#include <sys/rwlock.h>

#define	NET_LOCK(s)							\
do {									\
	s = splsoftnet();						\
} while (0)

#define	NET_UNLOCK(s)							\
do {									\
	splx(s);							\
} while (0)

#define	NET_ASSERT_LOCKED()						\
do {									\
	splsoftassert(IPL_SOFTNET);					\
} while (0)

#define	NET_ASSERT_UNLOCKED()						\
do {									\
} while (0)

__returns_twice int	setjmp(label_t *);
__dead void	longjmp(label_t *);
#endif

void	consinit(void);

void	cpu_startup(void);
void	cpu_configure(void);
void	diskconf(void);

int nfs_mountroot(void);
int dk_mountroot(void);
extern int (*mountroot)(void);

#include <lib/libkern/libkern.h>

#define bzero(b, n)		__builtin_bzero((b), (n))
#define memcmp(b1, b2, n)	__builtin_memcmp((b1), (b2), (n))
#define memcpy(d, s, n)		__builtin_memcpy((d), (s), (n))
#define memset(b, c, n)		__builtin_memset((b), (c), (n))
#if !defined(__clang__) && (defined(__GNUC__) && __GNUC__ >= 4)
#define bcmp(b1, b2, n)		__builtin_bcmp((b1), (b2), (n))
#define bcopy(s, d, n)		__builtin_bcopy((s), (d), (n))
#define memmove(d, s, n)	__builtin_memmove((d), (s), (n))
#endif

#if defined(DDB) || defined(KGDB)
/* debugger entry points */
void	Debugger(void);	/* in DDB only */
#endif

#ifdef BOOT_CONFIG
void	user_config(void);
#endif

#if defined(MULTIPROCESSOR)
void	_kernel_lock_init(void);
void	_kernel_lock(void);
void	_kernel_unlock(void);
int	_kernel_lock_held(void);

#define	KERNEL_LOCK_INIT()		_kernel_lock_init()
#define	KERNEL_LOCK()			_kernel_lock()
#define	KERNEL_UNLOCK()			_kernel_unlock()
#define	KERNEL_ASSERT_LOCKED()		KASSERT(_kernel_lock_held())
#define	KERNEL_ASSERT_UNLOCKED()	KASSERT(!_kernel_lock_held())

#else /* ! MULTIPROCESSOR */

#define	KERNEL_LOCK_INIT()		/* nothing */
#define	KERNEL_LOCK()			/* nothing */
#define	KERNEL_UNLOCK()			/* nothing */
#define	KERNEL_ASSERT_LOCKED()		/* nothing */
#define	KERNEL_ASSERT_UNLOCKED()	/* nothing */

#endif /* MULTIPROCESSOR */

#endif /* __SYSTM_H__ */
@


1.124
log
@Wrap the NET_LOCK() into a per-socket solock() that does nothing for
unix domain sockets.

This should prevent the multiple deadlock related to unix domain sockets.

Inputs from millert@@ and bluhm@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.123 2017/01/25 06:15:50 mpi Exp $	*/
a295 2
extern struct rwlock netlock;

a297 1
	rw_enter_write(&netlock);					\
a303 1
	rw_exit_write(&netlock);					\
a307 2
	if (rw_status(&netlock) != RW_WRITE)				\
		splassert_fail(RW_WRITE, rw_status(&netlock), __func__);\
a312 2
	if (rw_status(&netlock) == RW_WRITE)				\
		splassert_fail(0, rw_status(&netlock), __func__);	\
@


1.123
log
@Enable the NET_LOCK(), take 2.

Recursions are currently known and marked a XXXSMP.

Please report any assert to bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.122 2017/01/24 08:09:05 kettenis Exp $	*/
d304 1
a304 1
#define	NET_UNLOCK(s)						\
@


1.122
log
@In preparation of compiling our kernels with -ffreestanding, explicitly map
a few performance-critical functions to compiler builtins.  Since the
builtins supported by gcc3, gcc4 and clang are not the same, there are
(unfortunately) some compiler checks to make sure we only do the mapping
for builtins that are actually supported by the compiler.

ok jca@@, tom@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.121 2016/12/29 12:12:44 mpi Exp $	*/
d294 4
d300 1
d304 1
a304 1
#define	NET_UNLOCK(s)							\
d307 1
d312 2
d315 6
@


1.121
log
@Change NET_LOCK()/NET_UNLOCK() to be simple wrappers around
splsoftnet()/splx() until the known issues are fixed.

In other words, stop using a rwlock since it creates a deadlock when
chrome is used.

Issue reported by Dimitris Papastamos and kettenis@@

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.120 2016/12/19 08:36:50 mpi Exp $	*/
d324 10
@


1.120
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.119 2016/09/24 18:35:52 tedu Exp $	*/
a293 4
#include <sys/rwlock.h>

extern struct rwlock netlock;

a295 1
	rw_enter_write(&netlock);					\
d299 1
a299 1
#define	NET_UNLOCK(s)						\
a301 1
	rw_exit_write(&netlock);					\
a305 2
	if (rw_status(&netlock) != RW_WRITE)				\
		splassert_fail(RW_WRITE, rw_status(&netlock), __func__);\
@


1.119
log
@introduce hashfree() function to free hash tables, with sizes.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.118 2016/09/17 14:56:12 jasper Exp $	*/
d293 24
@


1.118
log
@garbage collect dead prototype

ok kettenis@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.117 2016/09/13 08:32:44 mpi Exp $	*/
d153 1
@


1.117
log
@Introduce rwsleep(9), an equivalent to msleep(9) but for code protected
by a write lock.

ok guenther@@, vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.116 2016/09/04 09:22:29 mpi Exp $	*/
a310 1
int	read_symtab_from_file(struct proc *,struct vnode *,const char *);
@


1.116
log
@Introduce Dynamic Profiling, a ddb(4) based & gprof compatible kernel
profiling framework.

Code patching is used to enable probes when entering functions.  The
probes will call a mcount()-like function to match the behavior of a
GPROF kernel.

Currently only available on amd64 and guarded under DDBPROF.  Support
for other archs will follow soon.

A new sysctl knob, ddb.console, need to be set to 1 in securelevel 0
to be able to use this feature.

Inputs and ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.115 2016/09/03 14:46:56 naddy Exp $	*/
d249 1
d255 1
@


1.115
log
@Write the system time back to the RTC every 30 minutes.
This fixes the problem that long-running machines which were not
shut down properly would reboot with a badly offset system time.

hints and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.114 2016/09/01 12:50:53 akfaew Exp $	*/
a298 4

#ifdef GPROF
void	kmstartup(void);
#endif
@


1.114
log
@MPSAFE is never used, so get rid of it.

OK natano@@ mpi@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.113 2016/05/17 23:28:03 bluhm Exp $	*/
d234 3
@


1.113
log
@Backout the previous fix for the sendsyslog(2) with LOG_CONS solution.
Permanently holding /dev/console open in the kernel works only until
init(8) calls revoke(2).  After that the console device vnode cannot
be used anymore.  It still resulted in a hanging init(8) if it tried
to syslog(3) something.  With the backout also dmesg -s works again.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.112 2016/05/10 23:54:01 bluhm Exp $	*/
d115 1
a115 2
#define SY_MPSAFE		0x01
#define SY_NOLOCK		0x02
@


1.112
log
@If sendsyslog(2) is called with LOG_CONS before syslogd(8) has been
started and before init(8) has opened the console, the kernel could
crash as the console device has not been initialized.  Open
/dev/console in the kernel before starting init(8) and keep it open.
This way sendsyslog(2) can be called early in the system.
OK beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.111 2016/03/24 08:57:51 mpi Exp $	*/
a100 2

extern struct vnode *consolevp; /* vnode of console tty device */
@


1.111
log
@Remove unused ``curpriority'' define.

Its description might be confusing, it was the pre-SMP parent of what
is now ``spc_curpriority'' which reflects the ``p_usrpri'' of curproc.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.110 2016/03/15 04:19:26 stefan Exp $	*/
d101 2
@


1.110
log
@Remove now unused legacy uiomovei() function.

All its callers got reviewed and converted to
use uiomove() properly.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.109 2015/12/11 16:07:02 mpi Exp $	*/
a87 7

#ifdef MULTIPROCESSOR
#define curpriority (curcpu()->ci_schedstate.spc_curpriority)
#else
extern u_char curpriority;	/* priority of current process */
#endif

@


1.109
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.108 2015/06/11 16:03:04 mikeb Exp $	*/
a292 1
int	uiomovei(void *, int, struct uio *);
@


1.108
log
@Move hzto(9) to the attic;  OK dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.107 2015/02/10 21:56:10 miod Exp $	*/
d276 1
a276 1
extern struct hook_desc_head startuphook_list, mountroothook_list;
a289 6

#define mountroothook_establish(fn, arg) \
	hook_establish(&mountroothook_list, 1, (fn), (arg))
#define mountroothook_disestablish(vhook) \
	hook_disestablish(&mountroothook_list, (vhook))
#define domountroothooks() dohooks(&mountroothook_list, HOOK_REMOVE|HOOK_FREE)
@


1.107
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.106 2014/12/10 15:29:53 mikeb Exp $	*/
a224 1
int	hzto(const struct timeval *);
@


1.106
log
@retire shutdown hooks; ok deraadt, krw
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.105 2014/12/10 12:27:57 mikeb Exp $	*/
d299 2
a300 1
int	uiomove(void *, int, struct uio *);
@


1.105
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.104 2014/11/18 18:34:50 miod Exp $	*/
d266 2
a267 5
 * Startup/shutdown hooks.  Startup hooks are functions running after
 * the scheduler has started but before any threads have been created
 * or root has been mounted. The shutdown hooks are functions to be run
 * with all interrupts disabled immediately before the system is
 * halted or rebooted.
d277 1
a277 2
extern struct hook_desc_head shutdownhook_list, startuphook_list,
    mountroothook_list;
a290 6

#define shutdownhook_establish(fn, arg) \
	hook_establish(&shutdownhook_list, 0, (fn), (arg))
#define shutdownhook_disestablish(vhook) \
	hook_disestablish(&shutdownhook_list, (vhook))
#define doshutdownhooks() dohooks(&shutdownhook_list, HOOK_REMOVE)
@


1.104
log
@Add __attribute__((__bounded__)) to arc4random_buf().
ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.103 2014/11/18 02:37:31 tedu Exp $	*/
d263 1
a263 1
void	wdog_shutdown(int (*)(void *, int), void *);
@


1.103
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.102 2014/10/09 04:04:27 tedu Exp $	*/
d218 2
a219 1
void arc4random_buf(void *, size_t);
@


1.102
log
@remove LKM support
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.101 2014/07/13 15:46:21 uebayasi Exp $	*/
d217 4
@


1.101
log
@KERNEL_ASSERT_LOCKED(9): Assertion for kernel lock (Rev. 3)

This adds a new assertion macro, KERNEL_ASSERT_LOCKED(), to assert that
kernel_lock is held.  In the long process of removing kernel_lock, there will
be a lot (hundreds or thousands) of use of this; virtually almost all functions
in !MP-safe subsystems should have this assertion.  Thus this assertion should
have a short, good name.

Not only that "KERNEL_ASSERT_LOCKED" is consistent with other KERNEL_* and
SCHED_ASSERT_LOCKED() macros.

Input from dlg@@ guenther@@ kettenis@@.

OK dlg@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a151 2

int	lkmenodev(void);
@


1.100
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.99 2013/04/24 17:29:02 matthew Exp $	*/
d343 1
d348 2
d356 2
@


1.99
log
@Add tstohz(9) as the timespec analog to tvtohz(9).

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.98 2013/04/06 03:53:25 tedu Exp $	*/
a194 3
		__attribute__ ((__bounded__(__buffer__,1,3)))
		__attribute__ ((__bounded__(__buffer__,2,3)));
void	ovbcopy(const void *, void *, size_t)
@


1.98
log
@shuffle around some poison code, prototypes, values...
allow some more pool debug code to be enabled if not compiled in
bump poison size back up to 64
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.97 2013/04/06 03:44:34 tedu Exp $	*/
d224 1
d227 1
@


1.97
log
@rthreads are always enabled. remove the sysctl.
ok deraadt guenther kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.96 2013/03/28 16:41:39 tedu Exp $	*/
a186 3

void	poison_mem(void *, size_t);
int	poison_check(void *, size_t, size_t *, int *);
@


1.96
log
@separate memory poisoning code to a new file and make it usable kernel wide
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.95 2013/02/09 20:56:35 miod Exp $	*/
a111 2

extern int rthreads_enabled;
@


1.95
log
@Add explicit __attribute__ ((__format__(__kprintf__)))) to the functions and
function pointer arguments which are {used as,} wrappers around the kernel
printf function.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.94 2012/10/17 22:32:01 deraadt Exp $	*/
d189 3
@


1.94
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.93 2012/09/26 00:09:48 brad Exp $	*/
d175 4
a178 2
int	vprintf(const char *, va_list);
int	vsnprintf(char *, size_t, const char *, va_list);
@


1.93
log
@Explicitly annotate setjmp() and longjmp() (and friends) as
__returns_twice and __dead instead of depending on GCC's special
handling of these function names.

With input from kettenis@@ and guenther@@
Fixes a warning from clang
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.92 2012/08/07 05:16:53 guenther Exp $	*/
d260 2
a261 1
void	wdog_register(void *, int (*)(void *, int));
@


1.92
log
@Move the common bits of syscall invocation and return handling into
an MI file, <sys/syscall_mi.h>, correcting inconsistencies and the
handling when copyin() of arguments fails.

Tested on i386, amd64, sparc64, and alpha (thanks naddy@@)
Any issues with other platforms will be fixed in tree.

header name from millert@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.91 2012/08/02 03:18:48 guenther Exp $	*/
d309 2
a310 2
int	setjmp(label_t *);
void	longjmp(label_t *);
@


1.91
log
@Apply profiling to all threads instead of just the thread that called
profil() by moving P_PROFIL from proc->p_flag to process->ps_flags with
matching adjustment in fork1() and exit1()

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.90 2012/01/13 12:55:52 jsing Exp $	*/
d136 3
a138 2
void scdebug_call(struct proc *p, register_t code, register_t retval[]);
void scdebug_ret(struct proc *p, register_t code, int error, register_t retval[]);
@


1.90
log
@Switch back to bootduid, however remember to include sys/systm.h...
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.88 2011/04/26 17:20:20 jsing Exp $	*/
d110 1
d237 2
a238 2
void	startprofclock(struct proc *);
void	stopprofclock(struct proc *);
@


1.89
log
@Clean up after P_BIGLOCK removal.
KERNEL_PROC_LOCK -> KERNEL_LOCK
KERNEL_PROC_UNLOCK -> KERNEL_UNLOCK

oga@@ ok
@
text
@d102 1
@


1.88
log
@Allow the root device to be identified via its disklabel UID.

ok deraadt@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.86 2010/09/21 01:09:10 matthew Exp $	*/
a339 2
void	_kernel_proc_lock(struct proc *);
void	_kernel_proc_unlock(struct proc *);
a343 2
#define	KERNEL_PROC_LOCK(p)		_kernel_proc_lock((p))
#define	KERNEL_PROC_UNLOCK(p)		_kernel_proc_unlock((p))
a349 2
#define	KERNEL_PROC_LOCK(p)		/* nothing */
#define	KERNEL_PROC_UNLOCK(p)		/* nothing */
@


1.87
log
@add a new function, explicit_bzero, to be used for erasing "secret" stuff.
unlike normal bzero, we guarantee that the compiler will not optimize out
calls to this function for otherwise dead variables.
to be adjusted as needed when compilers and linkers get smarter.
ok deraadt miod
@
text
@d102 1
@


1.86
log
@Add assertwaitok(9) to declare code paths that assume they can sleep.
Currently only checks that we're not in an interrupt context, but will
soon check that we're not holding any mutexes either.

Update malloc(9) and pool(9) to use assertwaitok(9) as appropriate.

"i like it" art@@, oga@@, marco@@; "i see no harm" deraadt@@; too trivial
for me to bother prying actual oks from people.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.85 2010/09/07 16:21:47 deraadt Exp $	*/
d197 2
@


1.85
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.84 2010/09/06 19:20:24 deraadt Exp $	*/
d181 2
@


1.84
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.83 2010/08/27 04:09:21 deraadt Exp $	*/
a295 7

/*
 * Power management hooks.
 */
void	*powerhook_establish(void (*)(int, void *), void *);
void	powerhook_disestablish(void *);
void	dopowerhooks(int);
@


1.83
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.82 2010/08/20 22:03:22 matthew Exp $	*/
a302 2
#define PWR_RESUME 3
#define PWR_SUSPEND 2
@


1.82
log
@Change hzto(9) and tvtohz(9) arguments to const pointers.

ok krw@@, "of course" tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.81 2010/07/08 20:15:01 deraadt Exp $	*/
d303 2
a304 3
#define PWR_RESUME 0
#define PWR_SUSPEND 1
#define PWR_STANDBY 2
@


1.81
log
@Devices which don't have read or write functionality should not return
enodev to poll, because this returns an errno of 19 in revents.  Oops.
Use seltrue where needed, and use a new selfalse function for those which
don't know if the next op will be non-blocking
Mostly discussed with guenther and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.80 2010/06/29 00:28:14 tedu Exp $	*/
d216 2
a217 2
int	hzto(struct timeval *);
int	tvtohz(struct timeval *);
@


1.80
log
@Eliminate RTHREADS kernel option in favor of a sysctl.  The actual status
(not done) hasn't changed, but now it's less work to test things.
ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.79 2010/04/20 22:05:44 tedu Exp $	*/
d159 1
@


1.79
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.78 2010/04/06 22:26:59 tedu Exp $	*/
d109 2
@


1.78
log
@move some of proc.h's greatest hits to systm.h, speeding up compiles.
lots of build testing by deraadt, ok/feedback deraadt guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.77 2009/11/04 19:14:09 kettenis Exp $	*/
d108 1
d247 1
@


1.77
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.76 2009/04/19 17:53:39 deraadt Exp $	*/
d229 17
@


1.76
log
@Count number of cpus found (potentially not attached) and store that
in sysctl hw.ncpufound; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.75 2008/11/06 19:12:37 deraadt Exp $	*/
d218 1
a218 1
void	softclock(void);
@


1.75
log
@queue the mountroot hooks to be run in the same order
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.74 2008/05/16 17:45:37 thib Exp $	*/
d82 2
a83 1
extern int ncpus;		/* number of CPUs */
@


1.74
log
@merge vfs_opv_init into vfs_op_init and remove the former,
as they where called consecutively in vfs_init.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.73 2007/11/27 18:04:01 art Exp $	*/
d269 1
a269 1
	hook_establish(&mountroothook_list, 0, (fn), (arg))
@


1.73
log
@Add possibility to add flags to syscalls in syscalls.master to mark
syscalls as NOLOCK and MPSAFE. The flags have slightly different semantics:
 NOLOCK - the syscall doesn't grab any locks whatsoever.
 MPSAFE - the syscall deals with its own locking.

What this means in practice is that NOLOCK syscalls can always be done
without the biglock. The MPSAFE syscalls can be done without the biglock
on CPUs that don't handle interrupts that require biglock (to preserve
lock ordering).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.72 2007/06/01 19:25:08 deraadt Exp $	*/
a149 1
void vfs_opv_init(void);
@


1.72
log
@some architectures called setroot() from cpu_configure(), *way* before some
subsystems were enabled.  others used a *md_diskconf -> diskconf() method to
make sure init_main could "do late setroot".  Change all architectures to
have diskconf(), use it directly & late.  tested by todd and myself on most
architectures, ok miod too
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.72 2007/06/01 19:20:44 deraadt Exp $	*/
d113 1
d116 4
@


1.71
log
@Don't use LK_CANRECURSE for the kernel lock, okay miod@@ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.70 2006/10/26 13:18:24 jmc Exp $	*/
d292 1
a292 2
extern void (*md_diskconf)(void);

@


1.70
log
@typos; from bret lambert
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.69 2006/04/27 02:17:21 tedu Exp $	*/
d317 1
a317 1
void	_kernel_lock(int);
d323 1
a323 1
#define	KERNEL_LOCK(flag)		_kernel_lock((flag))
d331 1
a331 1
#define	KERNEL_LOCK(flag)		/* nothing */
@


1.69
log
@use the underscore variants of _BYTE_ORDER which are always defined
even when various "strict" compiler options are used
ok deraadt millert
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.68 2006/02/22 22:16:08 miod Exp $	*/
d52 1
a52 1
 *    0	insecure mode - immutable and append-only flags make be turned off.
d230 1
a230 1
 * or root has been mounted The shutdown hooks are functions to be run
@


1.68
log
@Remove unused _{ins,rem}que functions - they were not even implemented on
all architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.67 2005/12/14 21:46:31 millert Exp $	*/
d115 1
a115 1
#if	BYTE_ORDER == BIG_ENDIAN
d117 1
a117 1
#elif	BYTE_ORDER == LITTLE_ENDIAN
@


1.67
log
@convert _FOO_SOURCE -> __FOO_VISIBLE in machine.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.66 2005/01/14 04:31:33 djm Exp $	*/
a130 7

extern	void	_insque(void *, void *);
extern	void	_remque(void *);

/* casts to keep lint happy, but it should be happy with void * */
#define	insque(q,p)	_insque(q, p)
#define	remque(q)	_remque(q)
@


1.66
log
@bounds checking for copystr, copyin and copyinstr;
tested by moritz@@ otto@@ deraadt@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.65 2004/11/28 02:11:33 deraadt Exp $	*/
d290 1
d293 1
@


1.65
log
@mountroothooks are called after the root filesystem is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.64 2004/09/16 07:07:17 grange Exp $	*/
d204 4
a207 2
int	copystr(const void *, void *, size_t, size_t *);
int	copyinstr(const void *, void *, size_t, size_t *);
d209 2
a210 1
int	copyin(const void *, void *, size_t);
@


1.64
log
@We don't have vsprintf/sprintf in the kernel anymore, spotted
by form@@pdp-11.org.ru.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.63 2004/06/20 17:28:26 itojun Exp $	*/
d246 2
a247 1
extern struct hook_desc_head shutdownhook_list, startuphook_list;
d267 6
@


1.63
log
@boundary-check memcpy and friends.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.62 2004/06/13 21:49:28 niklas Exp $	*/
a169 3
int	vsprintf(char *, const char *, va_list);
int	sprintf(char *buf, const char *, ...)
    __attribute__((__format__(__kprintf__,2,3)));
@


1.62
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d185 12
a196 5
int	kcopy(const void *, void *, size_t);

void	bcopy(const void *, void *, size_t);
void	ovbcopy(const void *, void *, size_t);
void	bzero(void *, size_t);
d198 8
a205 3
void	*memcpy(void *, const void *, size_t);
void	*memmove(void *, const void *, size_t);
void	*memset(void *, int, size_t);
@


1.61
log
@pull ncpus support from smp tree into main branch.
remove alpha specific definition of ncpus.
OK (and tested on alpha) deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.60 2004/01/05 00:16:56 espie Exp $	*/
d88 3
d92 1
d300 23
@


1.60
log
@unobfuscate systm.h: use va_list for vprintf.
_BSD_VA_LIST_ explained by millert@@, okay drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.59 2004/01/03 14:08:54 espie Exp $	*/
d82 1
@


1.59
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.58 2003/08/24 01:27:07 avsm Exp $	*/
d164 1
a164 1
int	vprintf(const char *, _BSD_VA_LIST_);
@


1.58
log
@sprinkle some __kprintf__ attributes around functions which use format
strings in the kernel to make gcc aware of the extra modifiers
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.57 2003/07/21 22:44:49 tedu Exp $	*/
d44 1
a44 1
#include <machine/stdarg.h>
@


1.57
log
@remove caddr_t casts.  it's just silly to cast something when the function
takes a void *.  convert uiomove to take a void * as well.  ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.56 2003/06/02 23:28:22 millert Exp $	*/
d157 1
a157 5
#ifdef __KPRINTF_ATTRIBUTE__
    __kprintf_attribute__((__noreturn__,__format__(__kprintf__,1,2)));
#else
    __attribute__((__noreturn__));
#endif
d161 1
a161 1
    __kprintf_attribute__((__format__(__kprintf__,1,2)));
d163 1
a163 1
    __kprintf_attribute__((__format__(__kprintf__,1,2)));
d165 1
a165 2
int	vsprintf(char *, const char *, va_list)
    __kprintf_attribute__((__format__(__kprintf__,2,3)));
d167 2
a168 3
    __kprintf_attribute__((__format__(__kprintf__,2,3)));
int	vsnprintf(char *, size_t, const char *, va_list)
    __kprintf_attribute__((__format__(__kprintf__,3,4)));
d170 1
a170 1
    __kprintf_attribute__((__format__(__kprintf__,3,4)));
d173 1
a173 1
    __kprintf_attribute__((__format__(__kprintf__,2,3)));
@


1.56
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.55 2003/05/21 16:17:37 art Exp $	*/
d270 1
a270 1
int	uiomove(caddr_t, int, struct uio *);
@


1.55
log
@Match vprintf prototype to userland and standards.

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.54 2003/01/21 16:59:23 markus Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.54
log
@add kern.watchdog sysctl and generic watchdog interface;
based on feedback and discussions with mickey, henric, fgsch and jakob.
ok art@@, mickey@@, jakob@@, henric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.53 2003/01/09 22:27:12 miod Exp $	*/
d172 1
a172 1
void	vprintf(const char *, _BSD_VA_LIST_);
@


1.53
log
@Remove fetch(9) and store(9) functions from the kernel, and replace the few
remaining instances of them with appropriate copy(9) usage.

ok art@@, tested on all arches unless my memory is non-ECC
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.52 2002/07/12 13:31:20 art Exp $	*/
d224 2
@


1.52
log
@- Add a flags argument to dohooks.
  The flag can be either HOOK_REMOVE or HOOK_REMOVE|HOOK_FREE.
   o HOOK_REMOVE removes the hook from the list before executing it.
   o HOOK_FREE frees the hook after that.

- Let dostartuphooks use HOOK_REMOVE|HOOK_FREE so we can reclaim the memory.

- Let doshutdownhooks use HOOK_REMOVE so that when some shutdown hook
  panics (they do that all the #@@$%! time these days) we don't loop
  for ever. Don't HOOK_FREE, it doesn't matter and I don't want to add
  another possible panic condition for shutdown hooks.

- Actually free the pointer we're throwing away in hook_disestablish (I wonder
  how much memory this has leaked over the years).
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.51 2002/07/06 19:14:20 nordin Exp $	*/
a204 13

int	fubyte(void *);
#ifdef notdef
int	fuibyte(void *);
#endif
int	subyte(void *, int);
int	suibyte(void *, int);
long	fuword(void *);
long	fuiword(void *);
int	suword(void *, long);
int	suiword(void *, long);
int	fuswintr(caddr_t);
int	suswintr(caddr_t, u_int);
@


1.51
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.50 2002/05/15 23:17:53 art Exp $	*/
d257 4
a260 1
void	dohooks(struct hook_desc_head *);
d266 1
a266 1
#define dostartuphooks() dohooks(&startuphook_list)
d272 1
a272 1
#define doshutdownhooks() dohooks(&shutdownhook_list)
@


1.50
log
@Implement splassert() for sparc - a tool for finding problems related to
spl handling (already found 3 problems).

Man page in a few seconds.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.49 2002/03/14 20:31:31 mickey Exp $	*/
a227 6
#ifdef NTP
void	hardupdate(long offset);
#ifdef PPS_SYNC
void	hardpps(struct timeval *, long);
#endif
#endif
@


1.49
log
@remove ambiguity in version,ostype,osversion,osrelease and their constanity, they are and declarre 'em accordingly also removing private externies of those
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.48 2002/03/14 03:16:12 millert Exp $	*/
d184 3
@


1.48
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.47 2002/03/14 01:27:14 millert Exp $	*/
d79 5
a83 2
extern char version[];		/* system version */
extern char copyright[];	/* system copyright */
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.46 2002/02/15 01:59:26 art Exp $	*/
d255 1
a255 2
void	*hook_establish __P((struct hook_desc_head *, int, void (*)(void *),
    void *));
d274 1
a274 1
void	*powerhook_establish __P((void (*)(int, void *), void *));
@


1.46
log
@Add a tvtohz function. Like hzto, but doesn't subtract the current time.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.45 2002/02/04 19:38:20 miod Exp $	*/
d104 1
a104 1
typedef int	sy_call_t __P((struct proc *, void *, register_t *));
d120 2
a121 2
void scdebug_call __P((struct proc *p, register_t code, register_t retval[]));
void scdebug_ret __P((struct proc *p, register_t code, int error, register_t retval[]));
d126 1
a126 1
extern void (*v_putc) __P((int)); /* Virtual console putc routine */
d128 2
a129 2
extern	void	_insque	__P((void *, void *));
extern	void	_remque	__P((void *));
d138 6
a143 6
int	nullop __P((void *));
int	enodev __P((void));
int	enosys __P((void));
int	enoioctl __P((void));
int	enxio __P((void));
int	eopnotsupp __P((void *));
d145 1
a145 1
int	lkmenodev __P((void));
d148 8
a155 8
void vfs_opv_init __P((void));
void vfs_opv_init_explicit __P((struct vnodeopv_desc *));
void vfs_opv_init_default __P((struct vnodeopv_desc *));
void vfs_op_init __P((void));

int	seltrue __P((dev_t dev, int which, struct proc *));
void	*hashinit __P((int, int, int, u_long *));
int	sys_nosys __P((struct proc *, void *, register_t *));
d157 1
a157 1
void	panic __P((const char *, ...))
d163 1
a163 1
void	__assert __P((const char *, const char *, int, const char *))
d165 1
a165 1
int	printf __P((const char *, ...))
d167 1
a167 1
void	uprintf __P((const char *, ...))
d169 2
a170 2
void	vprintf __P((const char *, _BSD_VA_LIST_));
int	vsprintf __P((char *, const char *, va_list))
d172 1
a172 1
int	sprintf __P((char *buf, const char *, ...))
d174 1
a174 1
int	vsnprintf __P((char *, size_t, const char *, va_list))
d176 1
a176 1
int	snprintf __P((char *buf, size_t, const char *, ...))
d179 1
a179 1
void	ttyprintf __P((struct tty *, const char *, ...))
d182 1
a182 1
void	tablefull __P((const char *));
d184 1
a184 1
int	kcopy __P((const void *, void *, size_t));
d186 13
a198 13
void	bcopy __P((const void *, void *, size_t));
void	ovbcopy __P((const void *, void *, size_t));
void	bzero __P((void *, size_t));
int	bcmp __P((const void *, const void *, size_t));
void	*memcpy __P((void *, const void *, size_t));
void	*memmove __P((void *, const void *, size_t));
void	*memset __P((void *, int, size_t));

int	copystr __P((const void *, void *, size_t, size_t *));
int	copyinstr __P((const void *, void *, size_t, size_t *));
int	copyoutstr __P((const void *, void *, size_t, size_t *));
int	copyin __P((const void *, void *, size_t));
int	copyout __P((const void *, void *, size_t));
d200 1
a200 1
int	fubyte __P((void *));
d202 1
a202 1
int	fuibyte __P((void *));
d204 8
a211 8
int	subyte __P((void *, int));
int	suibyte __P((void *, int));
long	fuword __P((void *));
long	fuiword __P((void *));
int	suword __P((void *, long));
int	suiword __P((void *, long));
int	fuswintr __P((caddr_t));
int	suswintr __P((caddr_t, u_int));
d214 3
a216 3
int	hzto __P((struct timeval *));
int	tvtohz __P((struct timeval *));
void	realitexpire __P((void *));
d219 3
a221 3
void	hardclock __P((struct clockframe *));
void	softclock __P((void));
void	statclock __P((struct clockframe *));
d223 1
a223 1
void	hardupdate __P((long offset));
d225 1
a225 1
void	hardpps __P((struct timeval *, long));
d229 8
a236 8
void	initclocks __P((void));
void	inittodr __P((time_t));
void	resettodr __P((void));
void	cpu_initclocks __P((void));

void	startprofclock __P((struct proc *));
void	stopprofclock __P((struct proc *));
void	setstatclockrate __P((int));
d248 1
a248 1
	void	(*hd_fn) __P((void *));
d257 2
a258 2
void	hook_disestablish __P((struct hook_desc_head *, void *));
void	dohooks __P((struct hook_desc_head *));
d276 2
a277 2
void	powerhook_disestablish __P((void *));
void	dopowerhooks __P((int));
d283 1
a283 1
int	uiomove __P((caddr_t, int, struct uio *));
d285 2
a286 2
int	setjmp	__P((label_t *));
void	longjmp	__P((label_t *));
d288 1
a288 1
void	consinit __P((void));
d290 3
a292 3
void	cpu_startup __P((void));
void	cpu_configure __P((void));
extern void (*md_diskconf) __P((void));
d296 1
a296 1
void	kmstartup __P((void));
d299 3
a301 3
int nfs_mountroot __P((void));
int dk_mountroot __P((void));
extern int (*mountroot)__P((void));
d307 2
a308 2
void	Debugger __P((void));	/* in DDB only */
int	read_symtab_from_file __P((struct proc *,struct vnode *,const char *));
d312 1
a312 1
void	user_config __P((void));
@


1.45
log
@Cleanup mountroot-related definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.44 2001/11/06 18:41:10 art Exp $	*/
d215 1
@


1.44
log
@Let fork1, uvm_fork, and cpu_fork take a function/argument pair as argument,
instead of doing fork1, cpu_set_kpc. This lets us retire cpu_set_kpc and
avoid a multiprocessor race.

This commit breaks vax because it doesn't look like any other arch, someone
working on vax might want to look at this and try to adapt the code to be
more like the rest of the world.

Idea and uvm parts from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.43 2001/08/26 04:10:56 deraadt Exp $	*/
d300 1
a300 1
int (*mountroot)__P((void));
@


1.44.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.44 2001/11/06 18:41:10 art Exp $	*/
d79 2
a80 5
extern const char version[];		/* system version */
extern const char copyright[];	/* system copyright */
extern const char ostype[];
extern const char osversion[];
extern const char osrelease[];
d104 1
a104 1
typedef int	sy_call_t(struct proc *, void *, register_t *);
d120 2
a121 2
void scdebug_call(struct proc *p, register_t code, register_t retval[]);
void scdebug_ret(struct proc *p, register_t code, int error, register_t retval[]);
d126 1
a126 1
extern void (*v_putc)(int); /* Virtual console putc routine */
d128 2
a129 2
extern	void	_insque(void *, void *);
extern	void	_remque(void *);
d138 6
a143 6
int	nullop(void *);
int	enodev(void);
int	enosys(void);
int	enoioctl(void);
int	enxio(void);
int	eopnotsupp(void *);
d145 1
a145 1
int	lkmenodev(void);
d148 8
a155 8
void vfs_opv_init(void);
void vfs_opv_init_explicit(struct vnodeopv_desc *);
void vfs_opv_init_default(struct vnodeopv_desc *);
void vfs_op_init(void);

int	seltrue(dev_t dev, int which, struct proc *);
void	*hashinit(int, int, int, u_long *);
int	sys_nosys(struct proc *, void *, register_t *);
d157 1
a157 1
void	panic(const char *, ...)
d163 1
a163 1
void	__assert(const char *, const char *, int, const char *)
d165 1
a165 1
int	printf(const char *, ...)
d167 1
a167 1
void	uprintf(const char *, ...)
d169 2
a170 2
void	vprintf(const char *, _BSD_VA_LIST_);
int	vsprintf(char *, const char *, va_list)
d172 1
a172 1
int	sprintf(char *buf, const char *, ...)
d174 1
a174 1
int	vsnprintf(char *, size_t, const char *, va_list)
d176 1
a176 1
int	snprintf(char *buf, size_t, const char *, ...)
d179 1
a179 1
void	ttyprintf(struct tty *, const char *, ...)
d182 1
a182 2
void	splassert_fail(int, int, const char *);
extern	int splassert_ctl;
d184 1
a184 1
void	tablefull(const char *);
d186 13
a198 1
int	kcopy(const void *, void *, size_t);
d200 1
a200 15
void	bcopy(const void *, void *, size_t);
void	ovbcopy(const void *, void *, size_t);
void	bzero(void *, size_t);
int	bcmp(const void *, const void *, size_t);
void	*memcpy(void *, const void *, size_t);
void	*memmove(void *, const void *, size_t);
void	*memset(void *, int, size_t);

int	copystr(const void *, void *, size_t, size_t *);
int	copyinstr(const void *, void *, size_t, size_t *);
int	copyoutstr(const void *, void *, size_t, size_t *);
int	copyin(const void *, void *, size_t);
int	copyout(const void *, void *, size_t);

int	fubyte(void *);
d202 1
a202 1
int	fuibyte(void *);
d204 8
a211 8
int	subyte(void *, int);
int	suibyte(void *, int);
long	fuword(void *);
long	fuiword(void *);
int	suword(void *, long);
int	suiword(void *, long);
int	fuswintr(caddr_t);
int	suswintr(caddr_t, u_int);
d214 2
a215 3
int	hzto(struct timeval *);
int	tvtohz(struct timeval *);
void	realitexpire(void *);
d218 3
a220 3
void	hardclock(struct clockframe *);
void	softclock(void);
void	statclock(struct clockframe *);
d222 1
a222 1
void	hardupdate(long offset);
d224 1
a224 1
void	hardpps(struct timeval *, long);
d228 8
a235 8
void	initclocks(void);
void	inittodr(time_t);
void	resettodr(void);
void	cpu_initclocks(void);

void	startprofclock(struct proc *);
void	stopprofclock(struct proc *);
void	setstatclockrate(int);
d247 1
a247 1
	void	(*hd_fn)(void *);
d254 4
a257 3
void	*hook_establish(struct hook_desc_head *, int, void (*)(void *), void *);
void	hook_disestablish(struct hook_desc_head *, void *);
void	dohooks(struct hook_desc_head *);
d274 3
a276 3
void	*powerhook_establish(void (*)(int, void *), void *);
void	powerhook_disestablish(void *);
void	dopowerhooks(int);
d282 1
a282 1
int	uiomove(caddr_t, int, struct uio *);
d284 2
a285 2
int	setjmp(label_t *);
void	longjmp(label_t *);
d287 1
a287 1
void	consinit(void);
d289 3
a291 3
void	cpu_startup(void);
void	cpu_configure(void);
extern void (*md_diskconf)(void);
d295 1
a295 1
void	kmstartup(void);
d298 3
a300 3
int nfs_mountroot(void);
int dk_mountroot(void);
extern int (*mountroot)(void);
d306 2
a307 2
void	Debugger(void);	/* in DDB only */
int	read_symtab_from_file(struct proc *,struct vnode *,const char *);
d311 1
a311 1
void	user_config(void);
@


1.44.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.44.2.1 2002/06/11 03:32:34 art Exp $	*/
d228 6
d263 1
a263 4
void	dohooks(struct hook_desc_head *, int);

#define HOOK_REMOVE	0x01
#define HOOK_FREE	0x02
d269 1
a269 1
#define dostartuphooks() dohooks(&startuphook_list, HOOK_REMOVE|HOOK_FREE)
d275 1
a275 1
#define doshutdownhooks() dohooks(&shutdownhook_list, HOOK_REMOVE)
@


1.44.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 13
a236 2

void	wdog_register(void *, int (*)(void *, int));
@


1.43
log
@be and le varients of syscallarg; from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.42 2001/08/23 08:18:59 miod Exp $	*/
a290 1
void	cpu_set_kpc __P((struct proc *, void (*)(void *), void *));
@


1.42
log
@Remove the old timeout legacy code.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.41 2001/07/27 09:55:07 niklas Exp $	*/
d111 7
a117 1
#define	SCARG(p,k)	((p)->k.datum)	/* get arg from args pointer */
@


1.41
log
@Startup hooks.  Can be used for providing root/swap devices from device
systems which want configuration to finish late, like I2O.  Implemented via
a general hooks mechanism which the shutdown hooks have been converted to
use as well.  It even has manpages!
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.40 2001/06/27 04:51:49 art Exp $	*/
a208 2
void	timeout __P((void (*)(void *), void *, int));
void	untimeout __P((void (*)(void *), void *));
@


1.40
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.39 2001/06/24 20:53:40 mickey Exp $	*/
d47 1
d234 5
a238 2
 * Shutdown hooks.  Functions to be run with all interrupts disabled
 * immediately before the system is halted or rebooted.
d240 26
a265 3
void	*shutdownhook_establish __P((void (*)(void *), void *));
void	shutdownhook_disestablish __P((void *));
void	doshutdownhooks __P((void));
d268 1
a268 1
 * Power managment hooks.
@


1.39
log
@place extern cold here; per discussion w/ art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.38 2001/05/05 22:34:35 art Exp $	*/
a83 4
#if !defined(UVM)
extern int nswdev;		/* number of swap devices */
extern int nswap;		/* size of swap space */
#endif
a176 1
#if defined(UVM)
a177 1
#endif
@


1.38
log
@Rename configure() to cpu_configure().
Move it from cpu_startup() to main().
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37 2000/01/02 06:31:28 assar Exp $	*/
d80 1
@


1.37
log
@(sy_call_t): define a type for the functions in sysent
PR 1032
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.36 1999/12/02 00:23:35 deraadt Exp $	*/
d264 1
@


1.37.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37 2000/01/02 06:31:28 assar Exp $	*/
a80 1
extern int ncpus;		/* number of CPUs */
@


1.37.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37.2.1 2000/02/20 11:57:33 niklas Exp $	*/
a79 1
extern int cold;		/* cold start flag initialized in locore */
d84 4
d181 1
d183 1
a264 1
void	cpu_configure __P((void));
@


1.37.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37.2.2 2001/07/04 11:00:35 niklas Exp $	*/
a46 1
#include <sys/queue.h>
d111 1
a111 7
#if	BYTE_ORDER == BIG_ENDIAN
#define SCARG(p, k)	((p)->k.be.datum)	/* get arg from args pointer */
#elif	BYTE_ORDER == LITTLE_ENDIAN
#define SCARG(p, k)	((p)->k.le.datum)	/* get arg from args pointer */
#else
#error	"what byte order is this machine?"
#endif
d209 2
d234 2
a235 5
 * Startup/shutdown hooks.  Startup hooks are functions running after
 * the scheduler has started but before any threads have been created
 * or root has been mounted The shutdown hooks are functions to be run
 * with all interrupts disabled immediately before the system is
 * halted or rebooted.
d237 3
a239 26

struct hook_desc {
	TAILQ_ENTRY(hook_desc) hd_list;
	void	(*hd_fn) __P((void *));
	void	*hd_arg;
};
TAILQ_HEAD(hook_desc_head, hook_desc);

extern struct hook_desc_head shutdownhook_list, startuphook_list;

void	*hook_establish __P((struct hook_desc_head *, int, void (*)(void *),
    void *));
void	hook_disestablish __P((struct hook_desc_head *, void *));
void	dohooks __P((struct hook_desc_head *));

#define startuphook_establish(fn, arg) \
	hook_establish(&startuphook_list, 1, (fn), (arg))
#define startuphook_disestablish(vhook) \
	hook_disestablish(&startuphook_list, (vhook))
#define dostartuphooks() dohooks(&startuphook_list)

#define shutdownhook_establish(fn, arg) \
	hook_establish(&shutdownhook_list, 0, (fn), (arg))
#define shutdownhook_disestablish(vhook) \
	hook_disestablish(&shutdownhook_list, (vhook))
#define doshutdownhooks() dohooks(&shutdownhook_list)
d242 1
a242 1
 * Power management hooks.
@


1.37.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d292 1
@


1.37.2.5
log
@Merge in trunk
@
text
@a215 1
int	tvtohz __P((struct timeval *));
d301 1
a301 1
extern int (*mountroot)__P((void));
@


1.37.2.6
log
@Merge in -current from roughly a week ago
@
text
@d79 2
a80 5
extern const char version[];		/* system version */
extern const char copyright[];	/* system copyright */
extern const char ostype[];
extern const char osversion[];
extern const char osrelease[];
d105 1
a105 1
typedef int	sy_call_t(struct proc *, void *, register_t *);
d121 2
a122 2
void scdebug_call(struct proc *p, register_t code, register_t retval[]);
void scdebug_ret(struct proc *p, register_t code, int error, register_t retval[]);
d127 1
a127 1
extern void (*v_putc)(int); /* Virtual console putc routine */
d129 2
a130 2
extern	void	_insque(void *, void *);
extern	void	_remque(void *);
d139 6
a144 6
int	nullop(void *);
int	enodev(void);
int	enosys(void);
int	enoioctl(void);
int	enxio(void);
int	eopnotsupp(void *);
d146 1
a146 1
int	lkmenodev(void);
d149 8
a156 8
void vfs_opv_init(void);
void vfs_opv_init_explicit(struct vnodeopv_desc *);
void vfs_opv_init_default(struct vnodeopv_desc *);
void vfs_op_init(void);

int	seltrue(dev_t dev, int which, struct proc *);
void	*hashinit(int, int, int, u_long *);
int	sys_nosys(struct proc *, void *, register_t *);
d158 1
a158 1
void	panic(const char *, ...)
d164 1
a164 1
void	__assert(const char *, const char *, int, const char *)
d166 1
a166 1
int	printf(const char *, ...)
d168 1
a168 1
void	uprintf(const char *, ...)
d170 2
a171 2
void	vprintf(const char *, _BSD_VA_LIST_);
int	vsprintf(char *, const char *, va_list)
d173 1
a173 1
int	sprintf(char *buf, const char *, ...)
d175 1
a175 1
int	vsnprintf(char *, size_t, const char *, va_list)
d177 1
a177 1
int	snprintf(char *buf, size_t, const char *, ...)
d180 1
a180 1
void	ttyprintf(struct tty *, const char *, ...)
d183 1
a183 1
void	tablefull(const char *);
d185 1
a185 1
int	kcopy(const void *, void *, size_t);
d187 13
a199 13
void	bcopy(const void *, void *, size_t);
void	ovbcopy(const void *, void *, size_t);
void	bzero(void *, size_t);
int	bcmp(const void *, const void *, size_t);
void	*memcpy(void *, const void *, size_t);
void	*memmove(void *, const void *, size_t);
void	*memset(void *, int, size_t);

int	copystr(const void *, void *, size_t, size_t *);
int	copyinstr(const void *, void *, size_t, size_t *);
int	copyoutstr(const void *, void *, size_t, size_t *);
int	copyin(const void *, void *, size_t);
int	copyout(const void *, void *, size_t);
d201 1
a201 1
int	fubyte(void *);
d203 1
a203 1
int	fuibyte(void *);
d205 8
a212 8
int	subyte(void *, int);
int	suibyte(void *, int);
long	fuword(void *);
long	fuiword(void *);
int	suword(void *, long);
int	suiword(void *, long);
int	fuswintr(caddr_t);
int	suswintr(caddr_t, u_int);
d215 3
a217 3
int	hzto(struct timeval *);
int	tvtohz(struct timeval *);
void	realitexpire(void *);
d220 3
a222 3
void	hardclock(struct clockframe *);
void	softclock(void);
void	statclock(struct clockframe *);
d224 1
a224 1
void	hardupdate(long offset);
d226 1
a226 1
void	hardpps(struct timeval *, long);
d230 4
a233 4
void	initclocks(void);
void	inittodr(time_t);
void	resettodr(void);
void	cpu_initclocks(void);
d235 3
a237 3
void	startprofclock(struct proc *);
void	stopprofclock(struct proc *);
void	setstatclockrate(int);
d249 1
a249 1
	void	(*hd_fn)(void *);
d256 4
a259 3
void	*hook_establish(struct hook_desc_head *, int, void (*)(void *), void *);
void	hook_disestablish(struct hook_desc_head *, void *);
void	dohooks(struct hook_desc_head *);
d276 3
a278 3
void	*powerhook_establish(void (*)(int, void *), void *);
void	powerhook_disestablish(void *);
void	dopowerhooks(int);
d284 1
a284 1
int	uiomove(caddr_t, int, struct uio *);
d286 2
a287 2
int	setjmp(label_t *);
void	longjmp(label_t *);
d289 1
a289 1
void	consinit(void);
d291 3
a293 3
void	cpu_startup(void);
void	cpu_configure(void);
extern void (*md_diskconf)(void);
d297 1
a297 1
void	kmstartup(void);
d300 3
a302 3
int nfs_mountroot(void);
int dk_mountroot(void);
extern int (*mountroot)(void);
d308 2
a309 2
void	Debugger(void);	/* in DDB only */
int	read_symtab_from_file(struct proc *,struct vnode *,const char *);
d313 1
a313 1
void	user_config(void);
@


1.37.2.7
log
@Sync the SMP branch with 3.3
@
text
@a185 3
void	splassert_fail(int, int, const char *);
extern	int splassert_ctl;

d204 13
d226 6
a241 2
void	wdog_register(void *, int (*)(void *, int));

d261 1
a261 4
void	dohooks(struct hook_desc_head *, int);

#define HOOK_REMOVE	0x01
#define HOOK_FREE	0x02
d267 1
a267 1
#define dostartuphooks() dohooks(&startuphook_list, HOOK_REMOVE|HOOK_FREE)
d273 1
a273 1
#define doshutdownhooks() dohooks(&shutdownhook_list, HOOK_REMOVE)
@


1.37.2.8
log
@Biglock!  Most of the logic
comes from NetBSD.
Also a lot of fixes, enough to get a dual cpu machine actually run MP for a
very short while (we are just talking about seconds) before starving out one
of the cpus.  More coming very soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37.2.7 2003/03/28 00:41:30 niklas Exp $	*/
a305 23

#if defined(MULTIPROCESSOR)
void	_kernel_lock_init(void);
void	_kernel_lock(int);
void	_kernel_unlock(void);
void	_kernel_proc_lock(struct proc *);
void	_kernel_proc_unlock(struct proc *);

#define	KERNEL_LOCK_INIT()		_kernel_lock_init()
#define	KERNEL_LOCK(flag)		_kernel_lock((flag))
#define	KERNEL_UNLOCK()			_kernel_unlock()
#define	KERNEL_PROC_LOCK(p)		_kernel_proc_lock((p))
#define	KERNEL_PROC_UNLOCK(p)		_kernel_proc_unlock((p))

#else /* ! MULTIPROCESSOR */

#define	KERNEL_LOCK_INIT()		/* nothing */
#define	KERNEL_LOCK(flag)		/* nothing */
#define	KERNEL_UNLOCK()			/* nothing */
#define	KERNEL_PROC_LOCK(p)		/* nothing */
#define	KERNEL_PROC_UNLOCK(p)		/* nothing */

#endif /* MULTIPROCESSOR */
@


1.37.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37.2.8 2003/05/15 04:08:03 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
d173 1
a173 1
int	vprintf(const char *, _BSD_VA_LIST_);
@


1.37.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 1
#include <sys/stdarg.h>
d158 5
a162 1
    __attribute__((__noreturn__,__format__(__kprintf__,1,2)));
d166 1
a166 1
    __attribute__((__format__(__kprintf__,1,2)));
d168 4
a171 3
    __attribute__((__format__(__kprintf__,1,2)));
int	vprintf(const char *, va_list);
int	vsprintf(char *, const char *, va_list);
d173 3
a175 2
    __attribute__((__format__(__kprintf__,2,3)));
int	vsnprintf(char *, size_t, const char *, va_list);
d177 1
a177 1
    __attribute__((__format__(__kprintf__,3,4)));
d180 1
a180 1
    __attribute__((__format__(__kprintf__,2,3)));
d271 1
a271 1
int	uiomove(void *, int, struct uio *);
@


1.37.2.11
log
@Make a few scheduling globals per-cpu, mostly NetBSD code
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.37.2.10 2004/02/19 11:01:34 niklas Exp $	*/
a87 3
#ifdef MULTIPROCESSOR
#define curpriority (curcpu()->ci_schedstate.spc_curpriority)
#else
a88 1
#endif
@


1.36
log
@snprintf in kernel; assar@@stacken.kth.se
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.35 1999/11/12 05:58:54 angelos Exp $	*/
d105 3
d111 1
a111 2
				/* implementing function */
	int	(*sy_call) __P((struct proc *, void *, register_t *));
@


1.35
log
@This shouldn't have been committed with the previous commit, revert
(experimental code)
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.34 1999/11/12 05:56:33 angelos Exp $	*/
d168 4
@


1.34
log
@Merge dvdio.h and cdio.h, don't use typedefs, get rid of bitfields (no
good reason to use them, not packed structures anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.33 1999/11/07 17:39:14 provos Exp $	*/
a156 1
char    *bitmask_snprintf __P((u_quad_t, const char *, char *, size_t));
@


1.33
log
@add APM powerhooks.
from NetBSD, Sat Jun 26 08:25:25 1999 UTC by augustss:

Add powerhooks, i.e., the ability to register a function that will be
called when the machine does a suspend or resume.
XXX Will go away when Jason's kevents come to life.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.32 1999/09/12 19:44:04 weingart Exp $	*/
d157 1
@


1.32
log
@Fix rootdev handling, use disk checksums to find the device we were booted
from.  Hopefully this will fix all the hangs/panics where the root device
was not found.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.31 1999/07/21 21:12:51 deraadt Exp $	*/
d238 10
@


1.31
log
@proto mem*() functions
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.30 1999/05/20 12:56:40 aaron Exp $	*/
d249 1
@


1.30
log
@fix some typos; kwesterback@@home.com
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.29 1999/05/06 15:33:57 mickey Exp $	*/
d182 3
@


1.29
log
@add scdebug_{call,ret} to help SYSCALL_DEBUG compile.
remove nsysent extern declaration, since it's no longer defined anywhere,
and SYS_MAXSYSCALL is used everywhere instead.
niklas@@ -- ok
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.28 1999/04/28 09:28:17 art Exp $	*/
d54 1
a54 1
 *   -1	permannently insecure mode - always run system in level 0 mode.
@


1.28
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.27 1999/02/26 03:19:57 art Exp $	*/
a110 1
extern int nsysent;
d112 5
@


1.27
log
@uvm doesn't use nswdev or nswmap.
add prototype for kcopy (uvm)
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.26 1999/02/26 03:16:47 millert Exp $	*/
d144 1
a144 2
void	*hashinit __P((int, int, u_long *));
void	*newhashinit __P((int, int, int, u_long *));
@


1.26
log
@Add newhashinit(), which is identical to hashinit() except it takes a flags
arg for passing to malloc() (hashinit always uses M_WAITOK which is not
always what you want).  Everything that uses hashinit should really
get converted to newhashinit and then newhashinit can be renamed.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.25 1999/01/10 13:34:16 niklas Exp $	*/
d83 1
d86 1
d170 4
@


1.25
log
@Generalize cpu_set_kpc to take any kind of arg; mostly from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.24 1997/11/06 05:59:12 csapuntz Exp $	*/
d143 1
@


1.24
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.23 1997/11/04 19:17:34 chuck Exp $	*/
d235 1
a235 1
void	cpu_set_kpc __P((struct proc *, void (*)(struct proc *)));
@


1.23
log
@add prototype for vprintf
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.22 1997/10/06 20:21:12 deraadt Exp $	*/
d131 1
a131 1
int	eopnotsupp __P((void));
d244 1
a244 1
int (*mountroot) __P((void));
@


1.22
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.20 1997/03/06 07:05:54 tholo Exp $	*/
d157 1
@


1.21
log
@VFS Lite2 Changes
@
text
@d131 1
a131 1
int	eopnotsupp __P((void *));
d243 1
a243 1
int (*mountroot)__P((void));
@


1.20
log
@Prototype hardpps() if PPS_SYNC option is present
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.19 1997/01/18 13:39:28 mickey Exp $	*/
d131 1
a131 1
int	eopnotsupp __P((void));
d243 1
a243 1
int (*mountroot) __P((void));
@


1.19
log
@protect from multiple includes (required by gpl_math_emulate)
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.18 1997/01/14 02:25:20 kstailey Exp $	*/
d203 3
@


1.18
log
@Debugger() is needed by KGDB not just DDB
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.17 1996/12/08 14:25:52 niklas Exp $	*/
d44 3
d254 1
@


1.17
log
@-Wcast-qual happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.16 1996/11/29 04:53:38 kstailey Exp $	*/
d241 1
a241 1
#ifdef DDB
@


1.16
log
@back out bitmask_snprintf()
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.15 1996/11/24 04:30:56 niklas Exp $	*/
d138 2
a139 2
int	seltrue __P((dev_t dev, int which, struct proc *p));
void	*hashinit __P((int count, int type, u_long *hashmask));
d164 10
a173 10
void	bcopy __P((const void *from, void *to, size_t len));
void	ovbcopy __P((const void *from, void *to, size_t len));
void	bzero __P((void *buf, size_t len));
int	bcmp __P((const void *b1, const void *b2, size_t len));

int	copystr __P((void *kfaddr, void *kdaddr, size_t len, size_t *done));
int	copyinstr __P((void *udaddr, void *kaddr, size_t len, size_t *done));
int	copyoutstr __P((void *kaddr, void *udaddr, size_t len, size_t *done));
int	copyin __P((void *udaddr, void *kaddr, size_t len));
int	copyout __P((void *kaddr, void *udaddr, size_t len));
d175 1
a175 1
int	fubyte __P((void *base));
d177 1
a177 1
int	fuibyte __P((void *base));
d179 6
a184 6
int	subyte __P((void *base, int byte));
int	suibyte __P((void *base, int byte));
long	fuword __P((void *base));
long	fuiword __P((void *base));
int	suword __P((void *base, long word));
int	suiword __P((void *base, long word));
d189 3
a191 3
int	hzto __P((struct timeval *tv));
void	timeout __P((void (*func)(void *), void *arg, int ticks));
void	untimeout __P((void (*func)(void *), void *arg));
d195 1
a195 1
void	hardclock __P((struct clockframe *frame));
d197 1
a197 1
void	statclock __P((struct clockframe *frame));
d209 1
a209 1
void	setstatclockrate __P((int hzrate));
@


1.15
log
@Added bitmap_snprintf proto
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.14 1996/11/11 15:35:20 mickey Exp $	*/
a160 1
char	*bitmask_snprintf __P((u_long, const char *, char *, size_t));
@


1.14
log
@export vfs_opv_init*
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.13 1996/11/06 01:29:24 deraadt Exp $	*/
d161 1
@


1.13
log
@proto mountroot and friends
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.12 1996/10/29 08:46:27 mickey Exp $	*/
d131 6
@


1.12
log
@-Wall happiness, especially for sparc/stand
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.11 1996/10/29 08:28:24 mickey Exp $	*/
d228 4
@


1.11
log
@-Wall happiness (especially for sparc)
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.10 1996/10/19 10:02:45 niklas Exp $	*/
d152 1
d213 1
@


1.10
log
@__assert added, impl from netbsd, however put elsewhere. use it instead
of private versions (one even using the userland header) in if_sn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.9 1996/08/15 13:49:48 niklas Exp $	*/
d99 1
@


1.9
log
@-Wall, -Wstrict-prototypes and some KNF cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.8 1996/07/23 23:54:17 deraadt Exp $	*/
d141 2
@


1.8
log
@make printf/addlog return 0, for compat to userland
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.7 1996/07/02 06:52:06 niklas Exp $	*/
d231 5
@


1.7
log
@-Wall & -Wstrict-prototype fixes
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.6 1996/06/09 03:40:36 briggs Exp $	*/
d141 1
a141 1
void	printf __P((const char *, ...))
@


1.6
log
@Add prototype for hardupdate() ifdef NTP.
@
text
@d1 1
a1 1
/*	$OpenBSD: systm.h,v 1.5 1996/05/02 13:14:59 deraadt Exp $	*/
d44 2
d145 2
@


1.5
log
@proto more stuff
@
text
@d1 2
a2 2
/*	$OpenBSD: systm.h,v 1.4 1996/04/21 22:32:04 deraadt Exp $	*/
/*	$NetBSD: systm.h,v 1.49 1996/04/22 01:23:35 christos Exp $	*/
d184 3
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: systm.h,v 1.3 1996/04/18 21:41:14 niklas Exp $	*/
/*	$NetBSD: systm.h,v 1.48 1996/04/09 20:55:38 cgd Exp $	*/
d188 1
d206 6
@


1.3
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD: systm.h,v 1.2 1996/02/29 13:57:30 niklas Exp $	*/
/*	$NetBSD: systm.h,v 1.43 1996/03/14 18:59:12 christos Exp $	*/
d56 1
a56 1
 *	read-only whether mounted or not. This level precludes tampering 
a122 1
int	lkmenodev __P((dev_t, int, int, struct proc *));
d126 3
d133 3
a135 2
#ifdef __GNUC__
volatile void	panic __P((const char *, ...));
d137 1
a137 1
void	panic __P((const char *, ...));
d139 9
a148 4
void	printf __P((const char *, ...));
void	uprintf __P((const char *, ...));
int	sprintf __P((char *buf, const char *, ...));
void	ttyprintf __P((struct tty *, const char *, ...));
d205 4
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: systm.h,v 1.40 1996/02/10 00:13:28 christos Exp $	*/
d195 3
a201 1
#ifdef notyet	/* XXX: Lots of local decls assume int Debugger */
a202 1
#endif
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: systm.h,v 1.37 1995/09/19 21:40:36 thorpej Exp $	*/
d108 8
a115 3
/* casts to keep lint happy */
#define	insque(q,p)	_insque((caddr_t)q,(caddr_t)p)
#define	remque(q)	_remque((caddr_t)q)
d120 1
a120 1
int	nullop __P((void));
d122 2
d129 1
a129 1
int	nosys __P((struct proc *, void *, register_t *));
d138 1
d145 1
d163 2
d166 1
d193 2
d199 3
a201 1
int	Debugger __P((void));	/* in DDB only */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
