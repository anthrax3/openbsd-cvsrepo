head	1.106;
access;
symbols
	OPENBSD_6_2:1.106.0.2
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.105.0.4
	OPENBSD_6_1_BASE:1.105
	OPENBSD_6_0:1.103.0.2
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.99.0.4
	OPENBSD_5_8_BASE:1.99
	OPENBSD_5_7:1.97.0.2
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.93.0.4
	OPENBSD_5_5_BASE:1.93
	OPENBSD_5_4:1.89.0.2
	OPENBSD_5_4_BASE:1.89
	OPENBSD_5_3:1.83.0.2
	OPENBSD_5_3_BASE:1.83
	OPENBSD_5_2:1.78.0.6
	OPENBSD_5_2_BASE:1.78
	OPENBSD_5_1_BASE:1.78
	OPENBSD_5_1:1.78.0.4
	OPENBSD_5_0:1.78.0.2
	OPENBSD_5_0_BASE:1.78
	OPENBSD_4_9:1.74.0.2
	OPENBSD_4_9_BASE:1.74
	OPENBSD_4_8:1.70.0.2
	OPENBSD_4_8_BASE:1.70
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.60.0.4
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.57.0.4
	OPENBSD_4_3_BASE:1.57
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.47.0.2
	OPENBSD_4_0_BASE:1.47
	OPENBSD_3_9:1.46.0.6
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.46.0.4
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.46.0.2
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.45.0.4
	OPENBSD_3_6_BASE:1.45
	SMP_SYNC_A:1.45
	SMP_SYNC_B:1.45
	OPENBSD_3_5:1.45.0.2
	OPENBSD_3_5_BASE:1.45
	OPENBSD_3_4:1.44.0.2
	OPENBSD_3_4_BASE:1.44
	UBC_SYNC_A:1.42
	OPENBSD_3_3:1.42.0.4
	OPENBSD_3_3_BASE:1.42
	OPENBSD_3_2:1.42.0.2
	OPENBSD_3_2_BASE:1.42
	OPENBSD_3_1:1.39.0.2
	OPENBSD_3_1_BASE:1.39
	UBC_SYNC_B:1.42
	UBC:1.36.0.2
	UBC_BASE:1.36
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.15.0.10
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.15.0.8
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.6
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.15.0.4
	OPENBSD_2_6_BASE:1.15
	OPENBSD_2_5:1.15.0.2
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.12.0.2
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.9.0.2
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.106
date	2017.04.16.14.25.42;	author beck;	state Exp;
branches;
next	1.105;
commitid	MPqr2iIfn6hJVsVl;

1.105
date	2017.02.28.10.49.37;	author natano;	state Exp;
branches;
next	1.104;
commitid	9645cvu5lMcc7gZM;

1.104
date	2016.09.16.02.54.51;	author dlg;	state Exp;
branches;
next	1.103;
commitid	KstuxUpRI6RRN5mJ;

1.103
date	2016.05.23.09.31.28;	author natano;	state Exp;
branches;
next	1.102;
commitid	wckQrShbScIX7TCE;

1.102
date	2016.03.10.06.52.37;	author dlg;	state Exp;
branches;
next	1.101;
commitid	YLKyVaQA5RlRnHwN;

1.101
date	2015.12.06.23.42.30;	author guenther;	state Exp;
branches;
next	1.100;
commitid	pHJqSxX05fOZOoIA;

1.100
date	2015.11.28.21.52.02;	author beck;	state Exp;
branches;
next	1.99;
commitid	RTnjsXZgItH5OlTY;

1.99
date	2015.07.19.16.21.11;	author beck;	state Exp;
branches;
next	1.98;
commitid	LZPv3kiZFL3zSeSL;

1.98
date	2015.07.06.10.23.00;	author dlg;	state Exp;
branches;
next	1.97;
commitid	Z1b6qLF8PJH0uwgI;

1.97
date	2015.01.09.05.04.22;	author tedu;	state Exp;
branches;
next	1.96;
commitid	9zgEJHeOLE2yUxI8;

1.96
date	2014.11.17.16.48.33;	author tedu;	state Exp;
branches;
next	1.95;
commitid	0HTG2L1hxB6gzuyL;

1.95
date	2014.08.31.21.08.48;	author tedu;	state Exp;
branches;
next	1.94;
commitid	xu4Eijui8okOw1L6;

1.94
date	2014.04.10.13.48.24;	author tedu;	state Exp;
branches;
next	1.93;

1.93
date	2013.11.21.01.16.52;	author dlg;	state Exp;
branches;
next	1.92;

1.92
date	2013.11.21.00.13.33;	author dlg;	state Exp;
branches;
next	1.91;

1.91
date	2013.11.20.23.52.42;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2013.11.06.07.46.31;	author dlg;	state Exp;
branches;
next	1.89;

1.89
date	2013.07.09.15.37.43;	author beck;	state Exp;
branches;
next	1.88;

1.88
date	2013.06.13.15.00.04;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2013.06.11.21.51.54;	author tedu;	state Exp;
branches;
next	1.86;

1.86
date	2013.06.11.19.01.20;	author beck;	state Exp;
branches;
next	1.85;

1.85
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.84;

1.84
date	2013.03.24.17.42.43;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2013.01.18.08.52.04;	author beck;	state Exp;
branches;
next	1.82;

1.82
date	2012.12.02.19.42.36;	author beck;	state Exp;
branches;
next	1.81;

1.81
date	2012.11.17.23.08.22;	author beck;	state Exp;
branches;
next	1.80;

1.80
date	2012.10.09.15.36.50;	author beck;	state Exp;
branches;
next	1.79;

1.79
date	2012.10.09.15.12.15;	author beck;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.05.19.41.08;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.07.19.07.42;	author beck;	state Exp;
branches;
next	1.75;

1.75
date	2011.04.03.13.52.09;	author beck;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.06.16.33.41;	author thib;	state Exp;
branches;
next	1.72;

1.72
date	2010.09.02.07.05.39;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	2010.09.01.01.38.12;	author dlg;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.30.02.26.58;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	2010.06.29.18.52.20;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.26.16.38.20;	author thib;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.02.16.28.40;	author beck;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.17.01.30.32;	author thib;	state Exp;
branches;
next	1.65;

1.65
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.64;

1.64
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.63;

1.63
date	2009.06.03.04.30.57;	author beck;	state Exp;
branches;
next	1.62;

1.62
date	2009.06.03.03.14.28;	author thib;	state Exp;
branches;
next	1.61;

1.61
date	2009.04.22.13.12.26;	author art;	state Exp;
branches;
next	1.60;

1.60
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.28.18.08.47;	author pedro;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.23.22.04.16;	author pedro;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.24.11.59.47;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.21.18.09.52;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2006.10.19.12.04.31;	author mickey;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.50;

1.50
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.22.23.29.45;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2006.09.22.23.03.52;	author pedro;	state Exp;
branches;
next	1.47;

1.47
date	2006.07.11.21.17.58;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2004.11.30.12.39.43;	author pedro;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.21.21.00.14;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.25.20.52.57;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.02.23.28.20;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2002.05.23.15.31.57;	author art;	state Exp;
branches;
next	1.40;

1.40
date	2002.05.23.13.47.45;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.30.05.45.33;	author csapuntz;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.11.27.06.21.37;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.33;

1.33
date	2001.11.15.23.15.15;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.09.15.32.21;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.09.15.25.55;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.28.00.42.43;	author art;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.20.08.22.26;	author gluk;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.17.19.17.30;	author gluk;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.10.08.48.42;	author gluk;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.30.12.41.14;	author gluk;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.30.12.38.52;	author gluk;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.27.04.51.47;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.22.14.10.59;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.06.18.59.17;	author gluk;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.20.17.30.07;	author gluk;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.24.19.07.07;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.24.10.37.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.23.14.52.49;	author csapuntz;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.23.14.42.37;	author csapuntz;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.21.23.24.30;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	99.02.26.02.15.41;	author art;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	98.11.12.04.30.02;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.08.04.22.01.49;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	98.01.18.14.41.32;	author csapuntz;	state Exp;
branches;
next	1.11;

1.11
date	97.11.22.20.06.27;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.11.06.05.59.07;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.20.21.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.10.06.15.25.32;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.07.28.09.13.14;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.14.04.23.21;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.06.11.03.25.14;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.21.40.46;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.31.13.16.37;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.57.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.25;	author deraadt;	state Exp;
branches;
next	;

1.15.6.1
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.15.6.2;

1.15.6.2
date	2001.07.04.11.00.12;	author niklas;	state Exp;
branches;
next	1.15.6.3;

1.15.6.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.15.6.4;

1.15.6.4
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.15.6.5;

1.15.6.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.15.6.6;

1.15.6.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.15.6.7;

1.15.6.7
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.15.6.8;

1.15.6.8
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.15.6.9;

1.15.6.9
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.15.6.10;

1.15.6.10
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.106
log
@Flip previously warm pages in the buffer cache to memory above the DMA
region if uvm tells us it is available.
nits from deraadt@@
ok krw@@ guenther@@ kettenis@@
@
text
@/*	$OpenBSD: buf.h,v 1.105 2017/02/28 10:49:37 natano Exp $	*/
/*	$NetBSD: buf.h,v 1.25 1997/04/09 21:12:17 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)buf.h	8.7 (Berkeley) 1/21/94
 */

#ifndef _SYS_BUF_H_
#define	_SYS_BUF_H_
#include <sys/queue.h>
#include <sys/tree.h>
#include <sys/mutex.h>

#define NOLIST ((struct buf *)0x87654321)

struct buf;
struct vnode;

LIST_HEAD(bufhead, buf);

/*
 * To avoid including <ufs/ffs/softdep.h>
 */

LIST_HEAD(workhead, worklist);

/*
 * Buffer queues
 */
#define BUFQ_NSCAN_N	128
#define BUFQ_FIFO	0
#define BUFQ_NSCAN	1
#define BUFQ_DEFAULT	BUFQ_NSCAN
#define BUFQ_HOWMANY	2

/*
 * Write limits for bufq - defines high and low water marks for how
 * many kva slots are allowed to be consumed to parallelize writes from
 * the buffer cache from any individual bufq.
 */
#define BUFQ_HI		128
#define BUFQ_LOW	64

struct bufq_impl;

struct bufq {
	SLIST_ENTRY(bufq)	 bufq_entries;
	struct mutex	 	 bufq_mtx;
	void			*bufq_data;
	u_int			 bufq_outstanding;
	u_int			 bufq_hi;
	u_int			 bufq_low;
	int			 bufq_waiting;
	int			 bufq_stop;
	int			 bufq_type;
	const struct bufq_impl	*bufq_impl;
};

int		 bufq_init(struct bufq *, int);
int		 bufq_switch(struct bufq *, int);
void		 bufq_destroy(struct bufq *);

void		 bufq_queue(struct bufq *, struct buf *);
struct buf	*bufq_dequeue(struct bufq *);
void		 bufq_requeue(struct bufq *, struct buf *);
int		 bufq_peek(struct bufq *);
void		 bufq_drain(struct bufq *);

void		 bufq_wait(struct bufq *);
void		 bufq_done(struct bufq *, struct buf *);
void		 bufq_quiesce(void);
void		 bufq_restart(void);

/* fifo */
SIMPLEQ_HEAD(bufq_fifo_head, buf);
struct bufq_fifo {
	SIMPLEQ_ENTRY(buf)	bqf_entries;
};

/* nscan */
SIMPLEQ_HEAD(bufq_nscan_head, buf);
struct bufq_nscan {
	SIMPLEQ_ENTRY(buf)	bqf_entries;
};

/* bufq link in struct buf */
union bufq_data {
	struct bufq_fifo	bufq_data_fifo;
	struct bufq_nscan	bufq_data_nscan;
};

/*
 * These are currently used only by the soft dependency code, hence
 * are stored once in a global variable. If other subsystems wanted
 * to use these hooks, a pointer to a set of bio_ops could be added
 * to each buffer.
 */
extern struct bio_ops {
	void	(*io_start)(struct buf *);
	void	(*io_complete)(struct buf *);
	void	(*io_deallocate)(struct buf *);
	void	(*io_movedeps)(struct buf *, struct buf *);
	int	(*io_countdeps)(struct buf *, int, int);
} bioops;

/* The buffer header describes an I/O operation in the kernel. */
struct buf {
	RBT_ENTRY(buf) b_rbbufs;	/* vnode "hash" tree */
	LIST_ENTRY(buf) b_list;		/* All allocated buffers. */
	LIST_ENTRY(buf) b_vnbufs;	/* Buffer's associated vnode. */
	TAILQ_ENTRY(buf) b_freelist;	/* Free list position if not active. */
	int cache;			/* which cache are we in */
	struct  proc *b_proc;		/* Associated proc; NULL if kernel. */
	volatile long	b_flags;	/* B_* flags. */
	long	b_bufsize;		/* Allocated buffer size. */
	long	b_bcount;		/* Valid bytes in buffer. */
	size_t	b_resid;		/* Remaining I/O. */
	int	b_error;		/* Errno value. */
	dev_t	b_dev;			/* Device associated with buffer. */
	caddr_t	b_data;			/* associated data */
	void	*b_saveaddr;		/* Original b_data for physio. */

	TAILQ_ENTRY(buf) b_valist;	/* LRU of va to reuse. */

	union	bufq_data b_bufq;
	struct	bufq	  *b_bq;	/* What bufq this buf is on */

	struct uvm_object *b_pobj;	/* Object containing the pages */
	off_t	b_poffs;		/* Offset within object */

	daddr_t	b_lblkno;		/* Logical block number. */
	daddr_t	b_blkno;		/* Underlying physical block number. */
					/* Function to call upon completion.
					 * Will be called at splbio(). */
	void	(*b_iodone)(struct buf *);
	struct	vnode *b_vp;		/* Device vnode. */
	int	b_dirtyoff;		/* Offset in buffer of dirty region. */
	int	b_dirtyend;		/* Offset of end of dirty region. */
	int	b_validoff;		/* Offset in buffer of valid region. */
	int	b_validend;		/* Offset of end of valid region. */
 	struct	workhead b_dep;		/* List of filesystem dependencies. */
};

TAILQ_HEAD(bufqueue, buf);

struct bufcache {
	int64_t hotbufpages;
	int64_t warmbufpages;
	int64_t cachepages;
	struct bufqueue hotqueue;
	struct bufqueue coldqueue;
	struct bufqueue warmqueue;
};

/* Device driver compatibility definitions. */
#define	b_active b_bcount		/* Driver queue head: drive active. */

/*
 * These flags are kept in b_flags.
 */
#define	B_WRITE		0x00000000	/* Write buffer (pseudo flag). */
#define	B_AGE		0x00000001	/* Move to age queue when I/O done. */
#define	B_NEEDCOMMIT	0x00000002	/* Needs committing to stable storage */
#define	B_ASYNC		0x00000004	/* Start I/O, do not wait. */
#define	B_BAD		0x00000008	/* Bad block revectoring in progress. */
#define	B_BUSY		0x00000010	/* I/O in progress. */
#define	B_CACHE		0x00000020	/* Bread found us in the cache. */
#define	B_CALL		0x00000040	/* Call b_iodone from biodone. */
#define	B_DELWRI	0x00000080	/* Delay I/O until buffer reused. */
#define	B_DONE		0x00000100	/* I/O completed. */
#define	B_EINTR		0x00000200	/* I/O was interrupted */
#define	B_ERROR		0x00000400	/* I/O error occurred. */
#define	B_INVAL		0x00000800	/* Does not contain valid info. */
#define	B_NOCACHE	0x00001000	/* Do not cache block after use. */
#define	B_PHYS		0x00002000	/* I/O to user memory. */
#define	B_RAW		0x00004000	/* Set by physio for raw transfers. */
#define	B_READ		0x00008000	/* Read buffer. */
#define	B_WANTED	0x00010000	/* Process wants this buffer. */
#define	B_WRITEINPROG	0x00020000	/* Write in progress. */
#define	B_XXX		0x00040000	/* Debugging flag. */
#define	B_DEFERRED	0x00080000	/* Skipped over for cleaning */
#define	B_SCANNED	0x00100000	/* Block already pushed during sync */
#define	B_PDAEMON	0x00200000	/* I/O started by pagedaemon */
#define	B_RELEASED	0x00400000	/* free this buffer after its kvm */
#define	B_WARM		0x00800000	/* buffer is or has been on the warm queue */
#define	B_COLD		0x01000000	/* buffer is on the cold queue */
#define	B_BC		0x02000000	/* buffer is managed by the cache */
#define	B_DMA		0x04000000	/* buffer is DMA reachable */

#define	B_BITS	"\20\001AGE\002NEEDCOMMIT\003ASYNC\004BAD\005BUSY" \
    "\006CACHE\007CALL\010DELWRI\011DONE\012EINTR\013ERROR" \
    "\014INVAL\015NOCACHE\016PHYS\017RAW\020READ" \
    "\021WANTED\022WRITEINPROG\023XXX(FORMAT)\024DEFERRED" \
    "\025SCANNED\026DAEMON\027RELEASED\030WARM\031COLD\032BC\033DMA"

/*
 * Zero out the buffer's data area.
 */
#define	clrbuf(bp) {							\
	bzero((bp)->b_data, (u_int)(bp)->b_bcount);			\
	(bp)->b_resid = 0;						\
}


/* Flags to low-level allocation routines. */
#define B_CLRBUF	0x01	/* Request allocated buffer be cleared. */
#define B_SYNC		0x02	/* Do all allocations synchronously. */

struct cluster_info {
	daddr_t	ci_lastr;	/* last read (read-ahead) */
	daddr_t	ci_lastw;	/* last write (write cluster) */
	daddr_t	ci_cstart;	/* start block of cluster */
	daddr_t	ci_lasta;	/* last allocation */
	int	ci_clen; 	/* length of current cluster */
	int	ci_ralen;	/* Read-ahead length */
	daddr_t	ci_maxra;	/* last readahead block */
};

#ifdef _KERNEL
__BEGIN_DECLS
/* Kva slots (of size MAXPHYS) reserved for syncer and cleaner. */
#define RESERVE_SLOTS 4
/* Buffer cache pages reserved for syncer and cleaner. */
#define RESERVE_PAGES (RESERVE_SLOTS * MAXPHYS / PAGE_SIZE)
/* Minimum size of the buffer cache, in pages. */
#define BCACHE_MIN (RESERVE_PAGES * 2)
#define UNCLEAN_PAGES (bcstats.numbufpages - bcstats.numcleanpages)

extern struct proc *cleanerproc;
extern long bufpages;		/* Max number of pages for buffers' data */
extern struct pool bufpool;
extern struct bufhead bufhead;

void	bawrite(struct buf *);
void	bdwrite(struct buf *);
void	biodone(struct buf *);
int	biowait(struct buf *);
int bread(struct vnode *, daddr_t, int, struct buf **);
int breadn(struct vnode *, daddr_t, int, daddr_t *, int *, int,
    struct buf **);
void	brelse(struct buf *);
#define bremfree bufcache_take
void	bufinit(void);
void	buf_dirty(struct buf *);
void    buf_undirty(struct buf *);
void	buf_adjcnt(struct buf *, long);
int	bwrite(struct buf *);
struct buf *getblk(struct vnode *, daddr_t, int, int, int);
struct buf *geteblk(size_t);
struct buf *incore(struct vnode *, daddr_t);

/*
 * bufcache functions
 */
void bufcache_take(struct buf *);
void bufcache_release(struct buf *);

int buf_flip_high(struct buf *);
void buf_flip_dma(struct buf *);
struct buf *bufcache_getcleanbuf(int, int);
struct buf *bufcache_getanycleanbuf(void);
struct buf *bufcache_getdirtybuf(void);

/*
 * buf_kvm_init initializes the kvm handling for buffers.
 * buf_acquire sets the B_BUSY flag and ensures that the buffer is
 * mapped in the kvm.
 * buf_release clears the B_BUSY flag and allows the buffer to become
 * unmapped.
 * buf_unmap is for internal use only. Unmaps the buffer from kvm.
 */
void	buf_mem_init(vsize_t);
void	buf_acquire(struct buf *);
void	buf_acquire_unmapped(struct buf *);
void	buf_acquire_nomap(struct buf *);
void	buf_map(struct buf *);
void	buf_release(struct buf *);
int	buf_dealloc_mem(struct buf *);
void	buf_fix_mapping(struct buf *, vsize_t);
void	buf_alloc_pages(struct buf *, vsize_t);
void	buf_free_pages(struct buf *);

void	minphys(struct buf *bp);
int	physio(void (*strategy)(struct buf *), dev_t dev, int flags,
	    void (*minphys)(struct buf *), struct uio *uio);
void  brelvp(struct buf *);
void  reassignbuf(struct buf *);
void  bgetvp(struct vnode *, struct buf *);

void  buf_replacevnode(struct buf *, struct vnode *);
void  buf_daemon(struct proc *);
void  buf_replacevnode(struct buf *, struct vnode *);
int bread_cluster(struct vnode *, daddr_t, int, struct buf **);

#ifdef DEBUG
void buf_print(struct buf *);
#endif

static __inline void
buf_start(struct buf *bp)
{
	if (bioops.io_start)
		(*bioops.io_start)(bp);
}

static __inline void
buf_complete(struct buf *bp)
{
	if (bioops.io_complete)
		(*bioops.io_complete)(bp);
}

static __inline void
buf_deallocate(struct buf *bp)
{
	if (bioops.io_deallocate)
		(*bioops.io_deallocate)(bp);
}

static __inline void
buf_movedeps(struct buf *bp, struct buf *bp2)
{
	if (bioops.io_movedeps)
		(*bioops.io_movedeps)(bp, bp2);
}

static __inline int
buf_countdeps(struct buf *bp, int i, int islocked)
{
	if (bioops.io_countdeps)
		return ((*bioops.io_countdeps)(bp, i, islocked));
	else
		return (0);
}

void	cluster_write(struct buf *, struct cluster_info *, u_quad_t);

__END_DECLS
#endif /* _KERNEL */
#endif /* !_SYS_BUF_H_ */
@


1.105
log
@Switch geteblks()'s size argument from int to size_t. It's called with
unsigned variables as argument in most places anyway. Decrease the
chance of signedness/range mismatch issues.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.104 2016/09/16 02:54:51 dlg Exp $	*/
d290 1
a290 1
void buf_flip_high(struct buf *);
a313 1

@


1.104
log
@move buf_rb_bufs from RB macros to RBT functions

i had to shuffle the order of some header bits cos RBT_PROTOTYPE
needs to see what RBT_HEAD produces.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.103 2016/05/23 09:31:28 natano Exp $	*/
d281 1
a281 1
struct buf *geteblk(int);
@


1.103
log
@VOP_REALLOCBLKS() and related code is unused since the removal of
cluster_write().
ok beck zhuk
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.102 2016/03/10 06:52:37 dlg Exp $	*/
a50 3
struct buf_rb_bufs;
RB_PROTOTYPE(buf_rb_bufs, buf, b_rbbufs, rb_buf_compare);

d140 1
a140 1
	RB_ENTRY(buf) b_rbbufs;		/* vnode "hash" tree */
@


1.102
log
@beck@@ forgot to commit this with sys/kern/vfs_bio.c r1.100.

> Start some refactoring in here.  this gets bufadjust  out
> of the hibernate path and starts preparing for some other work in here
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.101 2015/12/06 23:42:30 guenther Exp $	*/
a229 14

/*
 * This structure describes a clustered I/O.  It is stored in the b_saveaddr
 * field of the buffer on which I/O is done.  At I/O completion, cluster
 * callback uses the structure to parcel I/O's to individual buffers, and
 * then free's this structure.
 */
struct cluster_save {
	long	bs_bcount;		/* Saved b_bcount. */
	long	bs_bufsize;		/* Saved b_bufsize. */
	void	*bs_saveaddr;		/* Saved b_addr. */
	int	bs_nchildren;		/* Number of associated buffers. */
	struct buf **bs_children;	/* List of associated buffers. */
};
@


1.101
log
@Only declare buf_daemon() once
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.100 2015/11/28 21:52:02 beck Exp $	*/
d309 1
a309 1
struct buf *bufcache_getcleanbuf(int);
@


1.100
log
@move buffer size adjustment to buf_adjcnt - from Walter Neto
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.99 2015/07/19 16:21:11 beck Exp $	*/
a342 1
void  buf_daemon(struct proc *);
@


1.99
log
@Use two 2q caches for the buffer cache, moving previously warm buffers from the
first queue to the second.
Mark the first queue as DMA in preparation for being able to use more memory
by flipping. Flipper code currently only sets and clears the flag.
ok tedu@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.98 2015/07/06 10:23:00 dlg Exp $	*/
d295 1
@


1.98
log
@disksort is dead, and now so is any code that relied on its compat
in bufqs.

it's only taken us 6 years.

ok millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.97 2015/01/09 05:04:22 tedu Exp $	*/
d147 1
d179 11
d220 4
a223 2
#define	B_WARM		0x00800000	/* keep this buffer on warmqueue */
#define	B_COLD		0x01000000	/* keep this buffer on coldqueue */
d229 1
a229 1
    "\025SCANNED\026DAEMON\027RELEASED"
d306 4
a309 1
struct buf *bufcache_getcleanbuf(void);
@


1.97
log
@save the bufq pointer from the buf before we turn it loose so it won't
change on us. also, remove unused second arg to bufq_wait.
from pedro at bitrig via david hill.
ok beck kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.96 2014/11/17 16:48:33 tedu Exp $	*/
a108 6
/* disksort */
struct bufq_disksort {
	struct buf	 *bqd_actf;
	struct buf	**bqd_actb;
};

a122 1
	struct bufq_disksort	bufq_data_disksort;
a139 4

/* XXX: disksort(); */
#define b_actf	b_bufq.bufq_data_disksort.bqd_actf
#define b_actb	b_bufq.bufq_data_disksort.bqd_actb
@


1.96
log
@rearrange fields for better packing. reduces size to 256 on amd64.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.95 2014/08/31 21:08:48 tedu Exp $	*/
d104 1
a104 1
void		 bufq_wait(struct bufq *, struct buf *);
@


1.95
log
@replace LRU bufcache with something originally modelled after 2Q.
this should provide a degree of scan resistance, and also serves as a
midway point for further development of multi queue algorithms.
i've tried to minimize the risk and degree of regressions.
probably ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.94 2014/04/10 13:48:24 tedu Exp $	*/
a159 1
	int	b_error;		/* Errno value. */
d163 1
@


1.94
log
@pull the bufcache freelist code out into separate functions to allow new
algorithms to be tested. in the process, drop support for unused B_AGE and
b_synctime options.
previous versions ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.93 2013/11/21 01:16:52 dlg Exp $	*/
d219 2
a299 2
void bufcache_init(void);

@


1.93
log
@remove #define b_errcnt b_resid. nothing uses it, and nothing should.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.92 2013/11/21 00:13:33 dlg Exp $	*/
a157 1
	time_t	b_synctime;		/* Time this buffer should be flushed */
d286 1
a286 1
void	bremfree(struct buf *);
d294 11
@


1.92
log
@remove the #define b_cylinder b_resid from bufs. i hated the
overloading of that thing.

the only hardware that seems to care about cylinders in our tree
are floppy drives, and the drivers for those calculate their own
cylinders from logical block addresses and ignore whatever the rest
of the kernel thought b_cylinders should be.

most of this diff is moving the floppy drivers to using b_resid as
a resid and using that as part of the calculation for real cylinder
values.

the rest of the diff is getting rid of the useless assignments to
b_cylinder that dont get used by anything (now that disksort is
gone).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.91 2013/11/20 23:52:42 dlg Exp $	*/
a191 1
#define	b_errcnt b_resid		/* Retry count while I/O in progress. */
@


1.91
log
@now that all the direct users of disksort have been removed, we can now
safely remove disksort.

most hardware and pretty much all of the kernel has moved to logical
block addressing when dealing with disks, so the assumptions disksort
was built against arent useful these days. it also has bad edge cases
with lots of sequential writes being able to starve other io requests
in the system. these issues have been addressed by becks nscan
implementation, which disksort was previously deprecated in favour
of.

this removes the guts of disksort and the bufq wrapper around it.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.90 2013/11/06 07:46:31 dlg Exp $	*/
a188 6

/*
 * For portability with historic industry practice, the cylinder number has
 * to be maintained in the `b_resid' field.
 */
#define	b_cylinder b_resid		/* Cylinder number for disksort(). */
@


1.90
log
@remove some abuse of bufqs where they were overloaded to store workq_tasks
for completing swap io against files. this in turn bloated struct buf.

this moves from using workq_tasks to the task api, but stores the task
handler in vndbuf which is allocated specially for every io in this path
anyway.

ok kettenis@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.89 2013/07/09 15:37:43 beck Exp $	*/
d66 2
a67 3
#define BUFQ_DISKSORT	0
#define BUFQ_FIFO	1
#define BUFQ_NSCAN	2
d69 1
a69 1
#define BUFQ_HOWMANY	3
@


1.89
log
@back out the cache flipper temporarily to work out of tree.
will come back soon.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.85 2013/06/11 16:42:17 deraadt Exp $	*/
a44 1
#include <sys/workq.h>
a127 7
/* Abuse bufq_fifo, for swapping to regular files. */
struct bufq_swapreg {
	SIMPLEQ_ENTRY(buf)	bqf_entries;
	struct workq_task	bqf_wqtask;

};

a132 1
	struct bufq_swapreg	bufq_swapreg;
@


1.88
log
@beck would prefer to keep things just as they were for a while longer.
undo style changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.87 2013/06/11 21:51:54 tedu Exp $	*/
a236 2
#define B_BC		0x00800000      /* Managed by the Buffer Cache. */
#define B_DMA		0x01000000      /* DMA reachable. */
d242 1
a242 1
    "\025SCANNED\026DAEMON\027RELEASED\030BC\031DMA"
a307 1
void	buf_dma(struct buf *);
d331 1
a331 2
struct uvm_constraint_range;
int	buf_realloc_pages(struct buf *, struct uvm_constraint_range *, int);
@


1.87
log
@sprinkle knf fairy dust over new buf code
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.86 2013/06/11 19:01:20 beck Exp $	*/
d237 2
a238 2
#define	B_BC		0x00800000      /* Managed by the Buffer Cache. */
#define	B_DMA		0x01000000      /* DMA reachable. */
d309 1
a309 1
void	buf_undirty(struct buf *);
@


1.86
log
@High memory page flipping for the buffer cache.

This change splits the buffer cache free lists into lists of dma reachable
buffers and high memory buffers based on the ranges returned by pmemrange.
Buffers move from dma to high memory as they age, but are flipped to dma
reachable memory if IO is needed to/from and high mem buffer. The total
amount of buffers  allocated is now bufcachepercent of both the dma and
the high memory region.

This change allows the use of large buffer caches on amd64 using more than
4 GB of memory

ok tedu@@ krw@@ - testing by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.85 2013/06/11 16:42:17 deraadt Exp $	*/
d237 2
a238 2
#define B_BC		0x00800000      /* Managed by the Buffer Cache. */
#define B_DMA		0x01000000      /* DMA reachable. */
d309 1
a309 1
void    buf_undirty(struct buf *);
@


1.85
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.84 2013/03/24 17:42:43 deraadt Exp $	*/
d237 2
d244 1
a244 1
    "\025SCANNED\026DAEMON\027RELEASED"
d310 1
d334 2
a335 1

@


1.84
log
@label some nested #endif's
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.83 2013/01/18 08:52:04 beck Exp $	*/
d187 2
a188 2
	daddr64_t	b_lblkno;	/* Logical block number. */
	daddr64_t	b_blkno;	/* Underlying physical block number. */
d272 7
a278 7
	daddr64_t	ci_lastr;	/* last read (read-ahead) */
	daddr64_t	ci_lastw;	/* last write (write cluster) */
	daddr64_t	ci_cstart;	/* start block of cluster */
	daddr64_t	ci_lasta;	/* last allocation */
	int		ci_clen; 	/* length of current cluster */
	int		ci_ralen;	/* Read-ahead length */
	daddr64_t	ci_maxra;	/* last readahead block */
d300 2
a301 2
int bread(struct vnode *, daddr64_t, int, struct buf **);
int breadn(struct vnode *, daddr64_t, int, daddr64_t *, int *, int,
d309 1
a309 1
struct buf *getblk(struct vnode *, daddr64_t, int, int, int);
d311 1
a311 1
struct buf *incore(struct vnode *, daddr64_t);
d344 1
a344 1
int bread_cluster(struct vnode *, daddr64_t, int, struct buf **);
@


1.83
log
@Give buf_acquire_unmapped and B_NOTMAPPED a viking funeral as they should
really have been called "maybemapped and hope it all works out". - use
buf_acquire_nomap instead which acounts for busymapped bufs correctly.

ok krw@@ guenther@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.82 2012/12/02 19:42:36 beck Exp $	*/
d390 1
a390 1
#endif
@


1.82
log
@Fix kva reserve - ensure that kva reserve is checked for, as well
as fix the case where buffers can be returned on the vinvalbuf path
and we do not get woken up when waiting for kva.

An earlier version looked at and ok'd by guenther@@ in coimbra. - helpful
comments from kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.81 2012/11/17 23:08:22 beck Exp $	*/
a236 1
#define	B_NOTMAPPED	0x00800000	/* BUSY, but not necessarily mapped */
d242 1
a242 1
    "\025SCANNED\026DAEMON\027RELEASED\030NOTMAPPED"
@


1.81
log
@
 Don't map a buffer (and potentially sleep) when invalidating it in vinvalbuf.
This fixes a problem where we could sleep for kva and then our pointers
would not be valid on the next pass through the loop. We do this
by adding buf_acquire_nomap() - which can be used to busy up the buffer
without changing its mapped or unmapped state. We do not need to have
the buffer mapped to invalidate it, so it is sufficient to acquire it
for that. In the case where we write the buffer, we do map the buffer, and
potentially sleep.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.80 2012/10/09 15:36:50 beck Exp $	*/
d284 9
@


1.80
log
@Add nscan as a disk queueing algorithm, and make it the default with
n = 128.

Nscan is essentially, the disksort() style elevator algorithm for ordering
disk io operations. The difference is that we will re-order in chunks of
128 operations before continuing with the rest of the work. This avoids
the problem that the basic SCAN (aka elevator algorithm) has where continued
inserts can cause starvation, where requests can sit for a long time. This
solves problems where usb sticks could be unusable while long sequential
writes happened, and systems would become unresponsive while dumping core.

hacked upon (and this version largely rewritten by) tedu and myself.

Note, can be "backed out" by changing BUFQ_DEFAULT back to disksort in
buf.h

ok kettenis@@, tedu@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.79 2012/10/09 15:12:15 beck Exp $	*/
d316 1
@


1.79
log
@bufq write limiting

This change ensures that writes in flight from the buffer cache via bufq
are limited to a high water mark - when the limit is reached the writes sleep
until the amount of IO in flight reaches a low water mark. This avoids the
problem where userland can queue an unlimited amount of asynchronous writes
resulting in the consumption of all/most of our available buffer mapping kva,
and a long queue of writes to the disk.

ok kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.78 2011/07/04 04:30:41 tedu Exp $	*/
d66 1
d68 4
a71 3
#define	BUFQ_FIFO	1
#define BUFQ_DEFAULT	BUFQ_DISKSORT
#define BUFQ_HOWMANY	2
d123 6
d140 1
@


1.78
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.77 2011/06/05 19:41:08 deraadt Exp $	*/
d71 8
d86 3
d104 1
@


1.77
log
@Move the bufcachepercent setting code to MI locations -- set it to 42%
for now; that is unlikely to hit some of the remaining starvation bugs.
Repair the bufpages calculation too; i386 was doing it ahead of time
(incorrectly) and then re-calculating it.
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.76 2011/04/07 19:07:42 beck Exp $	*/
d271 1
a271 1
int bread(struct vnode *, daddr64_t, int, struct ucred *, struct buf **);
d273 1
a273 1
    struct ucred *, struct buf **);
@


1.76
log
@Revert previous diff decrementing bcstats.numbufpages here. This function
does not do what it purports to do, it shrinks mapping, not allocation, as
the pages have already been given away to other buffers. This also renames
the function to make this a little more obvious

and art should not name funcitons

ok thib@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.75 2011/04/03 13:52:09 beck Exp $	*/
d263 1
a263 1
extern int bufpages;		/* Max number of pages for buffers' data */
@


1.75
log
@Clean up buf flags
ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.74 2010/09/22 01:18:57 matthew Exp $	*/
d298 1
a298 1
void	buf_shrink_mem(struct buf *, vsize_t);
@


1.74
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.73 2010/09/06 16:33:41 thib Exp $	*/
d192 1
d201 22
a222 23
#define	B_DONE		0x00000200	/* I/O completed. */
#define	B_EINTR		0x00000400	/* I/O was interrupted */
#define	B_ERROR		0x00000800	/* I/O error occurred. */
#define	B_INVAL		0x00002000	/* Does not contain valid info. */
#define	B_NOCACHE	0x00008000	/* Do not cache block after use. */
#define	B_PHYS		0x00040000	/* I/O to user memory. */
#define	B_RAW		0x00080000	/* Set by physio for raw transfers. */
#define	B_READ		0x00100000	/* Read buffer. */
#define	B_WANTED	0x00800000	/* Process wants this buffer. */
#define	B_WRITE		0x00000000	/* Write buffer (pseudo flag). */
#define	B_WRITEINPROG	0x01000000	/* Write in progress. */
#define	B_XXX		0x02000000	/* Debugging flag. */
#define	B_DEFERRED	0x04000000	/* Skipped over for cleaning */
#define	B_SCANNED	0x08000000	/* Block already pushed during sync */
#define	B_PDAEMON	0x10000000	/* I/O started by pagedaemon */
#define B_RELEASED	0x20000000	/* free this buffer after its kvm */
#define B_NOTMAPPED	0x40000000	/* BUSY, but not necessarily mapped */

#define	B_BITS	"\010\001AGE\002NEEDCOMMIT\003ASYNC\004BAD\005BUSY\006CACHE" \
    "\007CALL\010DELWRI\012DONE\013EINTR\014ERROR" \
    "\016INVAL\020NOCACHE\023PHYS\024RAW\025READ" \
    "\030WANTED\031WRITEINPROG\032XXX\033DEFERRED" \
    "\034SCANNED\035PDAEMON"
@


1.73
log
@cut swapping to file over from disksort to bufq fifo's and
instead of doing work in the biodone callback for swapping
to file I/O, schedule the work to be done by the system
workq as it will call VOP_STRATEGY() in which we must be
allowed to sleep.

Thanks to Gabriel Kihlman for testing and spotting a bug in
the first version of this diff!

OK beck@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.72 2010/09/02 07:05:39 matthew Exp $	*/
d304 2
a305 2
int	physio(void (*strategy)(struct buf *), struct buf *bp, dev_t dev,
	    int flags, void (*minphys)(struct buf *), struct uio *uio);
@


1.72
log
@Inline bufq_impl_disksort and bufq_impl_fifo's definitions into
bufq_impls.  Also, make bufq_impls const.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.71 2010/09/01 01:38:12 dlg Exp $	*/
d45 1
d109 7
d120 1
@


1.71
log
@make struct bufq a member of the softc for devices that use it,
rather than it being a pointer to something that needs to be allocated
at attach. since all these devices need a bufq to operate, it makes
sense to have it allocated as part of the softc and get bufq_init
to just initialise all its fields. it also gets rid of the possibility
that you wont be able to allocate the bufq struct during attach,
which is something you dont want to happen.

secondly, it consistently implements a split between wrapper functions
and the per discipline implementation of the bufq handlers. it
consistently does the locking in the wrappers rather than doing
half in the wrappers and the other half in the implementations.

it also consistently handles the outstanding bufq bq pointer in the
wrappers.

this hides most of the implementation inside kern_bufq.c. the only
stuff left in buf.h is for the bits each implementation needs to
put inside struct buf.

tested by thib@@ krw@@ and me
ok thib@@ matthew@@
no objection from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.70 2010/06/30 02:26:58 matthew Exp $	*/
d79 1
a79 1
	struct bufq_impl	*bufq_impl;
@


1.70
log
@Switch bufq FIFO disclipline from using TAILQs to SIMPLEQs.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.69 2010/06/29 18:52:20 kettenis Exp $	*/
d70 2
d79 1
d82 15
a96 4
struct buf	*bufq_disksort_dequeue(struct bufq *, int);
void		 bufq_disksort_queue(struct bufq *, struct buf *);
void		 bufq_disksort_requeue(struct bufq *, struct buf *);
int		 bufq_disksort_init(struct bufq *);
d102 1
a102 4
struct buf	*bufq_fifo_dequeue(struct bufq *, int);
void		 bufq_fifo_queue(struct bufq *, struct buf *);
void		 bufq_fifo_requeue(struct bufq *, struct buf *);
int		 bufq_fifo_init(struct bufq *);
d108 1
a112 21

extern struct buf *(*bufq_dequeuev[BUFQ_HOWMANY])(struct bufq *, int);
extern void (*bufq_queuev[BUFQ_HOWMANY])(struct bufq *, struct buf *);
extern void (*bufq_requeuev[BUFQ_HOWMANY])(struct bufq *, struct buf *);

#define	BUFQ_QUEUE(_bufq, _bp)	 bufq_queue(_bufq, _bp)
#define BUFQ_REQUEUE(_bufq, _bp) bufq_requeue(_bufq, _bp)
#define	BUFQ_DEQUEUE(_bufq)		\
	    bufq_dequeuev[(_bufq)->bufq_type](_bufq, 0)
#define	BUFQ_PEEK(_bufq)		\
	bufq_dequeuev[(_bufq)->bufq_type](_bufq, 1)

struct bufq	*bufq_init(int);
void		 bufq_queue(struct bufq *, struct buf *);
void		 bufq_requeue(struct bufq *, struct buf *);
void		 bufq_destroy(struct bufq *);
void		 bufq_drain(struct bufq *);
void		 bufq_done(struct bufq *, struct buf *);
void		 bufq_quiesce(void);
void		 bufq_restart(void);

@


1.69
log
@Introduce bufq_quiesce(), which will block I/O ifrom getting on the queues,
and waits until all I/O currently on the queues has been completed.  To get
I/O going again, call bufq_restart().

To be used for suspend/resume.

Joint effort with thib@@, tedu@@; tested by mlarkin@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.68 2010/05/26 16:38:20 thib Exp $	*/
d92 1
a92 1
TAILQ_HEAD(bufq_fifo_head, buf);
d94 1
a94 1
	TAILQ_ENTRY(buf)	bqf_entries;
@


1.68
log
@Trying this again. Mixing anoncvs with cvs is _not_ a good idea.

Reintroduce bufqs. A few changes since it was backed out after some good
comments from dlg@@.

No need for a separate bufq.h, keep all of in buf.h; As requested by kittens
and deraadt.

Only sd(4) and wd(4) for now. The rest of the drivers will be converted soon,
also other goodies like heuristics for sd(4) for selecting the bufq type and
the death of disksort() are forthcoming.

Tested on: i386, amd64, sparc64, macppc, loongson and alpha by myself and
phessler.

OK art@@, beck@@, kettenis@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.67 2009/08/02 16:28:40 beck Exp $	*/
d71 6
a76 3
	struct mutex	   bufq_mtx;
	void		  *bufq_data;
	int		   bufq_type;
d102 6
a107 8
extern struct buf *(*bufq_dequeue[BUFQ_HOWMANY])(struct bufq *, int);
extern void (*bufq_queue[BUFQ_HOWMANY])(struct bufq *, struct buf *);
extern void (*bufq_requeue[BUFQ_HOWMANY])(struct bufq *, struct buf *);

#define	BUFQ_QUEUE(_bufq, _bp)		\
	    bufq_queue[(_bufq)->bufq_type](_bufq, _bp)
#define BUFQ_REQUEUE(_bufq, _bp)	\
	    bufq_requeue[(_bufq)->bufq_type](_bufq, _bp)
d109 1
a109 1
	    bufq_dequeue[(_bufq)->bufq_type](_bufq, 0)
d111 1
a111 1
	    bufq_dequeue[(_bufq)->bufq_type](_bufq, 1)
d114 2
d118 3
d161 1
@


1.67
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.66 2009/06/17 01:30:32 thib Exp $	*/
d44 1
d63 55
d131 5
a135 3
/*
 * The buffer header describes an I/O operation in the kernel.
 */
a141 1
	struct	buf *b_actf, **b_actb;	/* Device driver queue when active. */
d153 2
@


1.66
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.65 2009/06/15 17:01:26 beck Exp $	*/
d43 1
d50 3
d79 1
a80 1
	LIST_ENTRY(buf) b_hash;		/* Hash chain. */
@


1.65
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.64 2009/06/03 22:09:30 thib Exp $	*/
a107 22

/* BUFQ: flexible buffer queue routines. */
#define BUFQ_DISKSORT	1
#define BUFQ_DEFAULT	BUFQ_DISKSORT

struct bufq {
	struct buf	*(*bufq_get)(struct bufq *, int);
	void		 (*bufq_add)(struct bufq *, struct buf *);
	void		  *bufq_data;
	int		   bufq_type;
};

TAILQ_HEAD(bufq_tailq, buf);

#define	BUFQ_ADD(_bufq, _bp)	(_bufq)->bufq_add(_bufq, _bp)
#define	BUFQ_GET(_bufq)		(_bufq)->bufq_get(_bufq, 0)
#define	BUFQ_PEEK(_bufq)	(_bufq)->bufq_get(_bufq, 1)

struct bufq	*bufq_init(int);
void		 bufq_destroy(struct bufq *);
void		 bufq_drain(struct bufq *);

@


1.64
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.62 2009/06/03 03:14:28 thib Exp $	*/
a42 1
#include <sys/tree.h>
a48 3
struct buf_rb_bufs;
RB_PROTOTYPE(buf_rb_bufs, buf, b_rbbufs, rb_buf_compare);

a74 1
	RB_ENTRY(buf) b_rbbufs;		/* vnode "hash" tree */
d76 1
@


1.63
log
@Change bufhash from the old grotty hash table to red-black trees hanging
off the vnode.
ok art@@, oga@@, miod@@
@
text
@d113 22
@


1.62
log
@remove the never used bufq_ code.

ok oga@@
'dance for me' blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.60 2008/06/12 06:58:40 deraadt Exp $	*/
d43 1
d50 3
d79 1
a80 1
	LIST_ENTRY(buf) b_hash;		/* Hash chain. */
@


1.61
log
@Make the interactions in allocating buffers less confusing.

- getnewbuf dies. instead of having getnewbuf, buf_get, buf_stub and
 buf_init we now have buf_get that is smaller than some of those
 functions were before.

- Instead of allocating anonymous buffers and then freeing them if we
 happened to lose the race to the hash, always allocate a buffer knowing
 which <vnode, block> it will belong to.

- In cluster read, instead of allocating an anonymous buffer to cover
 the whole read and then stubs for every buffer under it, make the
 first buffer in the cluster cover the whole range and then shrink it
 in the callback.

now, all buffers are always on the correct hash and we always know their
identity.

discussed with many, kettenis@@ ok
@
text
@a109 25
 * bufq
 * flexible buffer queue routines
 */
struct bufq {
	void (*bufq_free)(struct bufq *);
	void (*bufq_add)(struct bufq *, struct buf *);
	struct buf *(*bufq_get)(struct bufq *);
};

struct bufq_default {
	struct bufq bufq;
	struct buf bufq_head[3];
};

#define	BUFQ_ALLOC(_type)	bufq_default_alloc()	/* XXX */
#define	BUFQ_FREE(_bufq)	(_bufq)->bufq_free(_bufq)
#define	BUFQ_ADD(_bufq, _bp)	(_bufq)->bufq_add(_bufq, _bp)
#define	BUFQ_GET(_bufq)		(_bufq)->bufq_get(_bufq)

struct bufq *bufq_default_alloc(void);
void bufq_default_free(struct bufq *);
void bufq_default_add(struct bufq *, struct buf *);
struct buf *bufq_default_get(struct bufq *);

/*
@


1.60
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.58 2008/06/10 20:14:37 beck Exp $	*/
d250 1
d253 1
@


1.59
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.57 2007/05/28 18:08:47 pedro Exp $	*/
d90 6
d170 2
d238 17
@


1.58
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a89 6

	TAILQ_ENTRY(buf) b_valist;	/* LRU of va to reuse. */

	struct uvm_object *b_pobj;	/* Object containing the pages */
	off_t	b_poffs;		/* Offset within object */

a163 2
#define B_RELEASED	0x20000000	/* free this buffer after its kvm */
#define B_NOTMAPPED	0x40000000	/* BUSY, but not necessarily mapped */
a229 17

/*
 * buf_kvm_init initializes the kvm handling for buffers.
 * buf_acquire sets the B_BUSY flag and ensures that the buffer is
 * mapped in the kvm.
 * buf_release clears the B_BUSY flag and allows the buffer to become
 * unmapped.
 * buf_unmap is for internal use only. Unmaps the buffer from kvm.
 */
void	buf_mem_init(vsize_t);
void	buf_acquire(struct buf *);
void	buf_acquire_unmapped(struct buf *);
void	buf_release(struct buf *);
int	buf_dealloc_mem(struct buf *);
void	buf_alloc_pages(struct buf *, vsize_t);
void	buf_free_pages(struct buf *);

@


1.57
log
@cluster_read() is gone, so remove its prototype, spotted by mickey@@
okay tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.56 2007/05/26 20:26:51 pedro Exp $	*/
d90 6
d170 2
d238 17
@


1.56
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.55 2007/03/23 22:04:16 pedro Exp $	*/
a284 2
int	cluster_read(struct vnode *, struct cluster_info *,
	    u_quad_t, daddr64_t, long, struct ucred *, struct buf **);
@


1.55
log
@Remove 'b_synclist' from struct buf, okay krw@@
From Juan Hernandez Gonzalez
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.54 2007/02/24 11:59:47 miod Exp $	*/
d49 2
d75 1
d88 2
a89 4
	struct {
		caddr_t	b_addr;		/* Memory, superblocks, indirect etc. */
	} b_un;
	void	*b_saveaddr;		/* Original b_addr for physio. */
a135 1
#define	b_data	 b_un.b_addr		/* b_un.b_addr is not changeable. */
d210 1
a210 5
extern int nbuf;		/* The number of buffer headers */
extern struct buf *buf;		/* The buffer headers. */
extern char *buffers;		/* The buffer contents. */
extern int bufpages;		/* Number of memory pages in the buffer pool. */

d212 1
a213 1
void	allocbuf(struct buf *, int);
d240 3
@


1.54
log
@Remove unused B_DIRTY, B_PAGET, B_PGIN, B_TAPE and B_UAREA b_flags values.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.53 2006/10/21 18:09:52 thib Exp $	*/
a75 1
	TAILQ_ENTRY(buf) b_synclist;	/* List of dirty buffers to be written out */
@


1.53
log
@Retire B_LOCKED and BQ_LOCKED. The last real usage of the
flag and the buffer queue went away when LFS was removed.

ok, pedro@@
"looks sane", deraadt@@
testing: tybollt@@solace.miun.se
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.52 2006/10/19 12:04:31 mickey Exp $	*/
a149 1
#define	B_DIRTY		0x00000100	/* Dirty page to be pushed out async. */
a154 2
#define	B_PAGET		0x00010000	/* Page in/out of page table space. */
#define	B_PGIN		0x00020000	/* Pagein op, so swap() can count it. */
a157 2
#define	B_TAPE		0x00200000	/* Magnetic tape I/O. */
#define	B_UAREA		0x00400000	/* Buffer describes Uarea I/O. */
d167 3
a169 3
    "\007CALL\010DELWRI\011DIRTY\012DONE\013EINTR\014ERROR" \
    "\016INVAL\020NOCACHE\021PAGET\022PGIN\023PHYS\024RAW\025READ" \
    "\026TAPE\027UAREA\030WANTED\031WRITEINPROG\032XXX\033DEFERRED" \
@


1.52
log
@some buffers (containing metadata) can only be written during the
bdwrite call made on 'em due to otherwise pending softdeps and thus
being deferred by the sybcer. promote bdwrite into bawrite for
those cases. tested by many.
pedro@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.51 2006/10/16 11:27:53 pedro Exp $	*/
a154 1
#define	B_LOCKED	0x00004000	/* Locked in core (not reusable). */
d173 1
a173 1
    "\016INVAL\017LOCKED\020NOCACHE\021PAGET\022PGIN\023PHYS\024RAW\025READ" \
@


1.51
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.50 2006/10/03 19:49:06 pedro Exp $	*/
d77 1
a77 1
	long b_synctime;		/* Time this buffer should be flushed */
@


1.50
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.49 2006/09/22 23:29:45 mickey Exp $	*/
d90 1
a90 1
	daddr_t	b_lblkno;		/* Logical block number. */
d229 3
a231 4
int	bread(struct vnode *, daddr_t, int,
		   struct ucred *, struct buf **);
int	breadn(struct vnode *, daddr_t, int, daddr_t *, int *, int,
		    struct ucred *, struct buf **);
d238 1
a238 1
struct buf *getblk(struct vnode *, daddr_t, int, int, int);
d240 1
a240 1
struct buf *incore(struct vnode *, daddr_t);
d294 1
a294 1
	    u_quad_t, daddr_t, long, struct ucred *, struct buf **);
@


1.49
log
@missed B_GATHERED bits removal
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.48 2006/09/22 23:03:52 pedro Exp $	*/
d91 1
a91 1
	daddr_t	b_blkno;		/* Underlying physical block number. */
d206 7
a212 7
	daddr_t	ci_lastr;			/* last read (read-ahead) */
	daddr_t	ci_lastw;			/* last write (write cluster) */
	daddr_t	ci_cstart;			/* start block of cluster */
	daddr_t	ci_lasta;			/* last allocation */
	int	ci_clen;			/* length of current cluster */
	int	ci_ralen;			/* Read-ahead length */
	daddr_t	ci_maxra;			/* last readahead block */
@


1.48
log
@Remove B_GATHERED, okay thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.47 2006/07/11 21:17:58 mickey Exp $	*/
d173 1
a173 1
    "\007CALL\010DELWRI\011DIRTY\012DONE\013EINTR\014ERROR\015GATHERED" \
@


1.47
log
@add mount/vnode/buf and softdep printing commands; tested on a few archs and will make pedro happy too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.46 2004/11/30 12:39:43 pedro Exp $	*/
a153 1
#define	B_GATHERED	0x00001000	/* LFS: already in a segment. */
@


1.46
log
@kill breada(), from Sven Dehmlow. ok tedu@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.45 2004/01/21 21:00:14 tedu Exp $	*/
d171 7
a177 1
#define B_PDAEMON	0x10000000	/* I/O started by pagedaemon */
@


1.45
log
@dynamic bufq support.  basically a nullop.  ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.44 2003/06/25 20:52:57 tedu Exp $	*/
a225 2
int	breada(struct vnode *, daddr_t, int, daddr_t, int,
		    struct ucred *, struct buf **);
@


1.44
log
@implement new means of manipulating buf queues, bufq.
accessed with BUFQ macros, bufq structs support extensible, potentially
changable algorithms and queue formats.  the current default scheme
should support nice priority based queuing, but is missing some vfs_bio.c
support.
only on wd.c for now, other drivers are easy converts.
as a side bonus, this makes the driver code look cleaner.
idea for the name comes from netbsd, but this scheme is incompatible.
thanks to various people for testing.
ok grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.43 2003/06/02 23:28:20 millert Exp $	*/
d108 3
a110 2
	void (*bufq_add)(struct bufq*, struct buf *);
	struct buf *(*bufq_get)(struct bufq*);
d118 4
a121 4
#define BUFQ_ADD(_bufq, _bp) \
    ((struct bufq *)_bufq)->bufq_add((struct bufq *)_bufq, _bp)
#define BUFQ_GET(_bufq) \
    ((struct bufq *)_bufq)->bufq_get((struct bufq *)_bufq)
d123 2
@


1.43
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.42 2002/07/03 21:19:08 miod Exp $	*/
d102 22
@


1.42
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.41 2002/05/23 15:31:57 art Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.41
log
@remove the defines for iodone -> biodone and iowait -> biowait.
Use the correct functions everywhere instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.40 2002/05/23 13:47:45 art Exp $	*/
d190 5
a194 4
int	nbuf;			/* The number of buffer headers */
struct	buf *buf;		/* The buffer headers. */
char	*buffers;		/* The buffer contents. */
int	bufpages;		/* Number of memory pages in the buffer pool. */
a197 1
__BEGIN_DECLS
@


1.40
log
@Make a promise (not yet true) that the b_iodone callback will
be called at splbio.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.39 2002/03/14 03:16:12 millert Exp $	*/
a116 2
#define	iodone	 biodone		/* Old name for biodone. */
#define	iowait	 biowait		/* Old name for biowait. */
@


1.39
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.38 2002/03/14 01:27:13 millert Exp $	*/
d96 2
a97 1
					/* Function to call upon completion. */
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.37 2001/12/19 08:58:06 art Exp $	*/
d221 2
a222 2
int	physio __P((void (*strategy)(struct buf *), struct buf *bp, dev_t dev,
		    int flags, void (*minphys)(struct buf *), struct uio *uio));
@


1.37
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.33 2001/11/15 23:15:15 art Exp $	*/
d66 5
a70 5
	void	(*io_start) __P((struct buf *));
	void	(*io_complete) __P((struct buf *));
	void	(*io_deallocate) __P((struct buf *));
	void	(*io_movedeps) __P((struct buf *, struct buf *));
	int	(*io_countdeps) __P((struct buf *, int, int));
d97 1
a97 1
	void	(*b_iodone) __P((struct buf *));
d199 20
a218 20
void	allocbuf __P((struct buf *, int));
void	bawrite __P((struct buf *));
void	bdwrite __P((struct buf *));
void	biodone __P((struct buf *));
int	biowait __P((struct buf *));
int	bread __P((struct vnode *, daddr_t, int,
		   struct ucred *, struct buf **));
int	breada __P((struct vnode *, daddr_t, int, daddr_t, int,
		    struct ucred *, struct buf **));
int	breadn __P((struct vnode *, daddr_t, int, daddr_t *, int *, int,
		    struct ucred *, struct buf **));
void	brelse __P((struct buf *));
void	bremfree __P((struct buf *));
void	bufinit __P((void));
void	buf_dirty __P((struct buf *));
void    buf_undirty __P((struct buf *));
int	bwrite __P((struct buf *));
struct buf *getblk __P((struct vnode *, daddr_t, int, int, int));
struct buf *geteblk __P((int));
struct buf *incore __P((struct vnode *, daddr_t));
d220 1
a220 1
void	minphys __P((struct buf *bp));
d223 3
a225 3
void  brelvp __P((struct buf *));
void  reassignbuf __P((struct buf *));
void  bgetvp __P((struct vnode *, struct buf *));
d227 2
a228 2
void  buf_replacevnode __P((struct buf *, struct vnode *));
void  buf_daemon __P((struct proc *));
d271 3
a273 3
int	cluster_read __P((struct vnode *, struct cluster_info *,
	    u_quad_t, daddr_t, long, struct ucred *, struct buf **));
void	cluster_write __P((struct buf *, struct cluster_info *, u_quad_t));
@


1.36
log
@Call buf_cleanout, which handles wakeups
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.35 2001/11/27 06:21:37 art Exp $	*/
a70 1
	void	(*io_pageiodone) __P((struct buf *));
d99 4
a102 1
	void	*b_private;
d123 1
d147 1
d206 2
a273 2

int buf_cleanout(struct buf *bp);
@


1.36.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.36 2001/11/30 05:45:33 csapuntz Exp $	*/
d147 1
@


1.36.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.36.2.1 2002/02/02 03:28:26 art Exp $	*/
d66 6
a71 6
	void	(*io_start)(struct buf *);
	void	(*io_complete)(struct buf *);
	void	(*io_deallocate)(struct buf *);
	void	(*io_movedeps)(struct buf *, struct buf *);
	int	(*io_countdeps)(struct buf *, int, int);
	void	(*io_pageiodone)(struct buf *);
d97 2
a98 3
					/* Function to call upon completion.
					 * Will be called at splbio(). */
	void	(*b_iodone)(struct buf *);
d114 2
d194 25
a218 24
void	allocbuf(struct buf *, int);
void	bawrite(struct buf *);
void	bdwrite(struct buf *);
void	biodone(struct buf *);
int	biowait(struct buf *);
int	bread(struct vnode *, daddr_t, int, struct ucred *, struct buf **);
int	breadn(struct vnode *, daddr_t, int, daddr_t *, int *, int,
		    struct ucred *, struct buf **);
void	brelse(struct buf *);
void	bremfree(struct buf *);
void	bufinit(void);
void	buf_dirty(struct buf *);
void    buf_undirty(struct buf *);
int	bwrite(struct buf *);
struct buf *getblk(struct vnode *, daddr_t, int, int, int);
struct buf *geteblk(int);
struct buf *incore(struct vnode *, daddr_t);

void	minphys(struct buf *bp);
int	physio(void (*strategy)(struct buf *), struct buf *bp, dev_t dev,
		    int flags, void (*minphys)(struct buf *), struct uio *uio);
void  brelvp(struct buf *);
void  reassignbuf(struct buf *);
void  bgetvp(struct vnode *, struct buf *);
d220 2
a221 2
void  buf_replacevnode(struct buf *, struct vnode *);
void  buf_daemon(struct proc *);
d264 3
a266 3
int	cluster_read(struct vnode *, struct cluster_info *,
	    u_quad_t, daddr_t, long, struct ucred *, struct buf **);
void	cluster_write(struct buf *, struct cluster_info *, u_quad_t);
@


1.36.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.36.2.2 2002/06/11 03:32:33 art Exp $	*/
d185 4
a188 5
__BEGIN_DECLS
extern int nbuf;		/* The number of buffer headers */
extern struct buf *buf;		/* The buffer headers. */
extern char *buffers;		/* The buffer contents. */
extern int bufpages;		/* Number of memory pages in the buffer pool. */
d192 1
@


1.35
log
@kill breada
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.34 2001/11/27 05:27:12 art Exp $	*/
d268 2
@


1.34
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.33 2001/11/15 23:15:15 art Exp $	*/
a201 2
int	breada __P((struct vnode *, daddr_t, int, daddr_t, int,
		    struct ucred *, struct buf **));
@


1.33
log
@Remove creds from struct buf, move the creds that nfs need into the nfs node.
While in the area, convert nfs node allocation from malloc to pool and do
some cleanups.
Based on the UBC changes in NetBSD. niklas@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.32 2001/11/09 15:32:21 art Exp $	*/
d71 1
d100 1
a100 4
	int	b_dirtyoff;		/* Offset in buffer of dirty region. */
	int	b_dirtyend;		/* Offset of end of dirty region. */
	int	b_validoff;		/* Offset in buffer of valid region. */
	int	b_validend;		/* Offset of end of valid region. */
a120 1
#define	B_NEEDCOMMIT	0x00000002	/* Needs committing to stable storage */
a143 1
#define	B_WRITEINPROG	0x01000000	/* Write in progress. */
@


1.32
log
@Create bufpool - a pool of struct bufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.31 2001/11/09 15:25:55 art Exp $	*/
a100 2
	struct	ucred *b_rcred;		/* Read credentials reference. */
	struct	ucred *b_wcred;		/* Write credentials reference. */
@


1.31
log
@nswbuf hasn't been used for ages. gc.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.30 2001/10/28 00:42:43 art Exp $	*/
d153 1
d197 2
@


1.30
log
@Sprinkle some assertions in the buffer code.
Add a new DEBUG function "buf_print" that prints the contents of struct buf.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.29 2001/09/20 08:22:26 gluk Exp $	*/
a195 1
int	nswbuf;			/* Number of swap I/O buffer headers. */
@


1.29
log
@Get rid of B_VFLUSH. Tested by costa and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.28 2001/09/17 19:17:30 gluk Exp $	*/
d229 4
@


1.28
log
@ The first implementation of the buffer flushing daemon. It solves our
problem when syncer can't do its work because of vnode locks (PR1983).
This also solves our problem where bigger number of buffers results in a
much worse perfomance. In my configuration (i386, 128mb, BUFCACHEPERCENT=35)
this speedup tar -xzf ports.tar.gz in 2-4 times. In configuration with
low number of buffers and softupdates this may slowdown some operations
up to 15%.

 The major difference with current buffer cache is that new implementation
uses separate queues for dirty and clean buffers. I.e. BQ_LRU and BQ_AGE
replaced by BQ_CLEAN and BQ_DIRTY. This simplifies things a lot and
doesn't affect perfomance in a bad manner.

Thanks to art and costa for pointing on errors.

Tested by brad, millert, naddy, art, jj, camield

art, millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.27 2001/09/10 08:48:42 gluk Exp $	*/
d151 1
a151 1
#define	B_VFLUSH	0x04000000	/* Buffer is being synced. */
a152 1
#define	B_DEFERRED	0x10000000	/* Skipped over for cleaning */
@


1.27
log
@Mark buffers with dependencies as B_DEFERRED and skip them one time
when doing sync. From FreeBSD.

art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.26 2001/08/30 12:41:14 gluk Exp $	*/
d229 1
@


1.26
log
@typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.25 2001/08/30 12:38:52 gluk Exp $	*/
d153 1
@


1.25
log
@Change getnewbuf interface so that getnewbuf always return
a new buffer and indicate if it sleep while getting that buffer.
This isn't make a much sense, but farther modifications will use it.

Work by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.24 2001/06/27 04:51:47 art Exp $	*/
d80 1
a80 1
	TAILQ_ENTRY(buf) b_synclist;	/* List of diry buffers to be written out */
@


1.24
log
@kill old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.23 2001/06/22 14:10:59 deraadt Exp $	*/
a217 1
struct buf *getnewbuf __P((int slpflag, int slptimeo));
@


1.23
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.22 2001/04/06 18:59:17 gluk Exp $	*/
a196 4
#if !defined(UVM)
struct	buf *swbuf;		/* Swap I/O buffer headers. */
struct	buf bswlist;		/* Head of swap I/O buffer headers free list. */
#endif
@


1.22
log
@Change softdep_count_dependencies interface so that it may be called
from interrupt at splbio.

costa@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.21 2001/03/20 17:30:07 gluk Exp $	*/
d55 1
a55 1
 */ 
a71 1
 
d237 2
a238 2
        if (bioops.io_start)
                (*bioops.io_start)(bp);
d244 2
a245 2
        if (bioops.io_complete)
                (*bioops.io_complete)(bp);
d251 2
a252 2
        if (bioops.io_deallocate)
                (*bioops.io_deallocate)(bp);
d258 2
a259 2
        if (bioops.io_movedeps)
                (*bioops.io_movedeps)(bp, bp2);
d265 4
a268 4
        if (bioops.io_countdeps)
                return ((*bioops.io_countdeps)(bp, i, islocked));
        else
                return (0);
d272 1
a272 2
			  u_quad_t, daddr_t, long,
			  struct ucred *, struct buf **));
@


1.21
log
@Make fsync a bit more reliable; From Free/NetBSD. art@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.20 2001/02/24 19:07:07 csapuntz Exp $	*/
d70 1
a70 1
	int	(*io_countdeps) __P((struct buf *, int));
d264 1
a264 1
buf_countdeps(struct buf *bp, int i)
d267 1
a267 1
                return ((*bioops.io_countdeps)(bp, i));
@


1.20
log
@

Cleanup of vnode interface continues. Get rid of VHOLD/HOLDRELE.
Change VM/UVM to use buf_replacevnode to change the vnode associated
with a buffer.

Addition v_bioflag for flags written in interrupt handlers
(and read at splbio, though not strictly necessary)

Add vwaitforio and use it instead of a while loop of v_numoutput.

Fix race conditions when manipulation vnode free list
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.19 2001/02/24 10:37:09 deraadt Exp $	*/
d153 1
@


1.19
log
@repair cluster structure damage
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.18 2001/02/23 14:52:49 csapuntz Exp $	*/
d229 1
a229 1
void  reassignbuf __P((struct buf *, struct vnode *));
d231 2
@


1.18
log
@

Change the B_DELWRI flag using buf_dirty and buf_undirty instead of
manually twiddling it. This allows the buffer cache to more easily
keep track of dirty buffers and decide when it is appropriate to speed
up the syncer.

Insipired by FreeBSD.
Look over by art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.17 2001/02/23 14:42:37 csapuntz Exp $	*/
d181 10
a267 11

struct cluster_info {
	daddr_t	ci_lastr;			/* last read (read-ahead) */
	daddr_t	ci_lastw;			/* last write (write cluster) */
	daddr_t	ci_cstart;			/* start block of cluster */
	daddr_t	ci_lasta;			/* last allocation */
	int	ci_clen;				/* length of current cluster */
	int	ci_ralen;			/* Read-ahead length */
	daddr_t	ci_maxra;			/* last readahead block */
};

@


1.17
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.16 2001/02/21 23:24:30 csapuntz Exp $	*/
d207 2
a208 1
void	bdirty __P((struct buf *));
@


1.16
log
@

Latest soft updates from FreeBSD/Kirk McKusick

Snapshot-related code has been commented out.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.15 1999/02/26 02:15:41 art Exp $	*/
a208 4
void	cluster_callback __P((struct buf *));
int	cluster_read __P((struct vnode *, u_quad_t, daddr_t, long,
			  struct ucred *, struct buf **));
void	cluster_write __P((struct buf *, u_quad_t));
d257 16
@


1.15
log
@uvm doesn't need swbuf or bswlist
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.14 1998/11/12 04:30:02 csapuntz Exp $	*/
a64 1
struct mount;
d68 3
a70 3
 	void	(*io_deallocate) __P((struct buf *));
	int     (*io_fsync) __P((struct vnode *));
 	int	(*io_sync) __P((struct mount *));
d176 1
d224 38
@


1.15.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.22 2001/04/06 18:59:17 gluk Exp $	*/
d65 1
d69 3
a71 3
	void	(*io_deallocate) __P((struct buf *));
	void	(*io_movedeps) __P((struct buf *, struct buf *));
	int	(*io_countdeps) __P((struct buf *, int, int));
a153 1
#define	B_SCANNED	0x08000000	/* Block already pushed during sync */
a176 1

a180 10
struct cluster_info {
	daddr_t	ci_lastr;			/* last read (read-ahead) */
	daddr_t	ci_lastw;			/* last write (write cluster) */
	daddr_t	ci_cstart;			/* start block of cluster */
	daddr_t	ci_lasta;			/* last allocation */
	int	ci_clen;			/* length of current cluster */
	int	ci_ralen;			/* Read-ahead length */
	daddr_t	ci_maxra;			/* last readahead block */
};

d207 1
a207 2
void	buf_dirty __P((struct buf *));
void    buf_undirty __P((struct buf *));
d209 4
d222 1
a222 1
void  reassignbuf __P((struct buf *));
a223 45

void  buf_replacevnode __P((struct buf *, struct vnode *));

static __inline void
buf_start(struct buf *bp)
{
        if (bioops.io_start)
                (*bioops.io_start)(bp);
}

static __inline void
buf_complete(struct buf *bp)
{
        if (bioops.io_complete)
                (*bioops.io_complete)(bp);
}

static __inline void
buf_deallocate(struct buf *bp)
{
        if (bioops.io_deallocate)
                (*bioops.io_deallocate)(bp);
}

static __inline void
buf_movedeps(struct buf *bp, struct buf *bp2)
{
        if (bioops.io_movedeps)
                (*bioops.io_movedeps)(bp, bp2);
}

static __inline int
buf_countdeps(struct buf *bp, int i, int islocked)
{
        if (bioops.io_countdeps)
                return ((*bioops.io_countdeps)(bp, i, islocked));
        else
                return (0);
}

int	cluster_read __P((struct vnode *, struct cluster_info *,
			  u_quad_t, daddr_t, long,
			  struct ucred *, struct buf **));
void	cluster_write __P((struct buf *, struct cluster_info *, u_quad_t));

@


1.15.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.15.6.1 2001/05/14 22:45:00 niklas Exp $	*/
d55 1
a55 1
 */
d72 1
d198 4
d238 2
a239 2
	if (bioops.io_start)
		(*bioops.io_start)(bp);
d245 2
a246 2
	if (bioops.io_complete)
		(*bioops.io_complete)(bp);
d252 2
a253 2
	if (bioops.io_deallocate)
		(*bioops.io_deallocate)(bp);
d259 2
a260 2
	if (bioops.io_movedeps)
		(*bioops.io_movedeps)(bp, bp2);
d266 4
a269 4
	if (bioops.io_countdeps)
		return ((*bioops.io_countdeps)(bp, i, islocked));
	else
		return (0);
d273 2
a274 1
	    u_quad_t, daddr_t, long, struct ucred *, struct buf **));
@


1.15.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.15.6.2 2001/07/04 11:00:12 niklas Exp $	*/
d80 1
a80 1
	TAILQ_ENTRY(buf) b_synclist;	/* List of dirty buffers to be written out */
d151 1
a151 1
#define	B_DEFERRED	0x04000000	/* Skipped over for cleaning */
d218 1
a228 1
void  buf_daemon __P((struct proc *));
@


1.15.6.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a152 1
#define B_PDAEMON	0x10000000	/* I/O started by pagedaemon */
d196 1
a196 2

extern struct pool bufpool;
a228 4

#ifdef DEBUG
void buf_print(struct buf *);
#endif
@


1.15.6.5
log
@Merge in -current
@
text
@a70 1
	void	(*io_pageiodone) __P((struct buf *));
d99 6
a104 1
	void	*b_private;
d125 1
d149 1
d208 2
a275 2

int buf_cleanout(struct buf *bp);
@


1.15.6.6
log
@Merge in trunk
@
text
@d71 1
d100 1
a100 4
	int	b_dirtyoff;		/* Offset in buffer of dirty region. */
	int	b_dirtyend;		/* Offset of end of dirty region. */
	int	b_validoff;		/* Offset in buffer of valid region. */
	int	b_validend;		/* Offset of end of valid region. */
a120 1
#define	B_NEEDCOMMIT	0x00000002	/* Needs committing to stable storage */
a143 1
#define	B_WRITEINPROG	0x01000000	/* Write in progress. */
a201 2
int	breada __P((struct vnode *, daddr_t, int, daddr_t, int,
		    struct ucred *, struct buf **));
d268 2
@


1.15.6.7
log
@Merge in -current from roughly a week ago
@
text
@d66 5
a70 5
	void	(*io_start)(struct buf *);
	void	(*io_complete)(struct buf *);
	void	(*io_deallocate)(struct buf *);
	void	(*io_movedeps)(struct buf *, struct buf *);
	int	(*io_countdeps)(struct buf *, int, int);
d97 1
a97 1
	void	(*b_iodone)(struct buf *);
d199 27
a225 27
void	allocbuf(struct buf *, int);
void	bawrite(struct buf *);
void	bdwrite(struct buf *);
void	biodone(struct buf *);
int	biowait(struct buf *);
int	bread(struct vnode *, daddr_t, int,
		   struct ucred *, struct buf **);
int	breada(struct vnode *, daddr_t, int, daddr_t, int,
		    struct ucred *, struct buf **);
int	breadn(struct vnode *, daddr_t, int, daddr_t *, int *, int,
		    struct ucred *, struct buf **);
void	brelse(struct buf *);
void	bremfree(struct buf *);
void	bufinit(void);
void	buf_dirty(struct buf *);
void    buf_undirty(struct buf *);
int	bwrite(struct buf *);
struct buf *getblk(struct vnode *, daddr_t, int, int, int);
struct buf *geteblk(int);
struct buf *incore(struct vnode *, daddr_t);

void	minphys(struct buf *bp);
int	physio(void (*strategy)(struct buf *), struct buf *bp, dev_t dev,
	    int flags, void (*minphys)(struct buf *), struct uio *uio);
void  brelvp(struct buf *);
void  reassignbuf(struct buf *);
void  bgetvp(struct vnode *, struct buf *);
d227 2
a228 2
void  buf_replacevnode(struct buf *, struct vnode *);
void  buf_daemon(struct proc *);
d271 3
a273 3
int	cluster_read(struct vnode *, struct cluster_info *,
	    u_quad_t, daddr_t, long, struct ucred *, struct buf **);
void	cluster_write(struct buf *, struct cluster_info *, u_quad_t);
@


1.15.6.8
log
@Sync the SMP branch with 3.3
@
text
@d96 1
a96 2
					/* Function to call upon completion.
					 * Will be called at splbio(). */
d116 2
d191 4
a194 5
__BEGIN_DECLS
extern int nbuf;		/* The number of buffer headers */
extern struct buf *buf;		/* The buffer headers. */
extern char *buffers;		/* The buffer contents. */
extern int bufpages;		/* Number of memory pages in the buffer pool. */
d198 1
@


1.15.6.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.15.6.8 2003/03/28 00:41:30 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.15.6.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a101 25

/*
 * bufq
 * flexible buffer queue routines
 */
struct bufq {
	void (*bufq_free)(struct bufq *);
	void (*bufq_add)(struct bufq *, struct buf *);
	struct buf *(*bufq_get)(struct bufq *);
};

struct bufq_default {
	struct bufq bufq;
	struct buf bufq_head[3];
};

#define	BUFQ_ALLOC(_type)	bufq_default_alloc()	/* XXX */
#define	BUFQ_FREE(_bufq)	(_bufq)->bufq_free(_bufq)
#define	BUFQ_ADD(_bufq, _bp)	(_bufq)->bufq_add(_bufq, _bp)
#define	BUFQ_GET(_bufq)		(_bufq)->bufq_get(_bufq)

struct bufq *bufq_default_alloc(void);
void bufq_default_free(struct bufq *);
void bufq_default_add(struct bufq *, struct buf *);
struct buf *bufq_default_get(struct bufq *);
@


1.14
log
@

Integrate latest soft updates patches for McKusick.

Integrate cleaner ffs mount code from FreeBSD. Most notably, this mount
code prevents you from mounting an unclean file system read-write.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.13 1998/08/04 22:01:49 millert Exp $	*/
d186 2
a188 1
int	nswbuf;			/* Number of swap I/O buffer headers. */
d190 1
@


1.13
log
@make b_resid size_t
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.12 1998/01/18 14:41:32 csapuntz Exp $	*/
d51 1
d70 1
@


1.12
log
@Get rid of old dirty buffer list
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.11 1997/11/22 20:06:27 mickey Exp $	*/
d88 1
a88 1
	long	b_resid;		/* Remaining I/O. */
@


1.11
log
@declare struct buf earlier to avoid warnings
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.10 1997/11/06 05:59:07 csapuntz Exp $	*/
a186 1
TAILQ_HEAD(, buf) bdirties;	/* Dirty buffer list for update daemon */
@


1.10
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.9 1997/10/06 20:21:03 deraadt Exp $	*/
d49 2
@


1.9
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.7 1997/07/28 09:13:14 deraadt Exp $	*/
d51 21
d103 1
d202 1
@


1.8
log
@VFS Lite2 Changes
@
text
@a50 21
 * To avoid including <ufs/ffs/softdep.h>
 */ 

LIST_HEAD(workhead, worklist);

/*
 * These are currently used only by the soft dependency code, hence
 * are stored once in a global variable. If other subsystems wanted
 * to use these hooks, a pointer to a set of bio_ops could be added
 * to each buffer.
 */
struct mount;
extern struct bio_ops {
	void	(*io_start) __P((struct buf *));
	void	(*io_complete) __P((struct buf *));
 	void	(*io_deallocate) __P((struct buf *));
 	int	(*io_sync) __P((struct mount *));
} bioops;
 

/*
a81 1
 	struct	workhead b_dep;		/* List of filesystem dependencies. */
a179 1
void	bdirty __P((struct buf *));
@


1.7
log
@two unneeded variables; enami@@ba2.so-net.or.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.6 1997/04/14 04:23:21 tholo Exp $	*/
d51 21
d103 1
d202 1
@


1.6
log
@Minor performance enhancements from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.5 1996/06/11 03:25:14 tholo Exp $	*/
a162 1
struct	buf *bclnlist;		/* Head of cleaned page list. */
@


1.5
log
@Kernel-implementation of update(8) my me
@
text
@d1 2
a2 2
/*	$OpenBSD: buf.h,v 1.3 1996/03/31 13:16:37 mickey Exp $	*/
/*	$NetBSD: buf.h,v 1.24 1996/02/18 11:55:45 fvdl Exp $	*/
d127 1
@


1.4
log
@Merge of NetBSD 960317
@
text
@d57 2
d163 1
@


1.3
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: buf.h,v 1.2 1996/02/29 13:57:26 niklas Exp $	*/
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: buf.h,v 1.23 1996/02/09 18:24:59 christos Exp $	*/
d99 1
a99 1
#define	B_APPENDWRITE	0x00000002	/* Append-write in progress. */
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: buf.h,v 1.21 1995/08/12 20:31:53 mycroft Exp $	*/
d163 1
a163 1
int	allocbuf __P((struct buf *, int));
d169 1
a169 1
	    struct ucred *, struct buf **));
d171 1
a171 1
	    struct ucred *, struct buf **));
d173 1
a173 1
	    struct ucred *, struct buf **));
d180 1
a180 1
	    struct ucred *, struct buf **));
d189 4
a192 1
	    int flags, void (*minphys)(struct buf *), struct uio *uio));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
