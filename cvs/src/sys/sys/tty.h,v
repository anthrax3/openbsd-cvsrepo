head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.4
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.2
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.2
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.4
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.2
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.16
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.12
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.10
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.18
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.05.24.16.09.07;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	fXA64S3toS3jz7A7;

1.36
date	2015.12.21.21.49.03;	author sf;	state Exp;
branches;
next	1.35;
commitid	QfhbTzV3KV3v5lir;

1.35
date	2015.07.20.22.28.57;	author sf;	state Exp;
branches;
next	1.34;
commitid	0jNvJBFsXwToDgPd;

1.34
date	2014.09.15.19.08.21;	author miod;	state Exp;
branches;
next	1.33;
commitid	uuiU9j2I8AUx0fez;

1.33
date	2013.12.13.19.55.12;	author naddy;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.17.21.24.58;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.04.22.53.53;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.02.19.57.15;	author tedu;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.30.20.38.50;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.28.14.13.36;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.17.06.27.05;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.27.19.30.28;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.46;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.09.19.21.34.43;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.10.01.31.21;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.10.01.19.47;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.23.16.51.13;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.12.04.17.14;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.05.10.12.28;	author art;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.14.07.07.14;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.01.20.54.35;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.16.20.02.21;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.13.03.38.45;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.19.13.37.27;	author art;	state Exp;
branches;
next	1.4;

1.4
date	96.06.10.07.31.41;	author deraadt;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.04.21.22.32.12;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.32;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.05.14.22.45.05;	author niklas;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2001.07.04.11.00.35;	author niklas;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.4.16.5;

1.4.16.5
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.4.16.6;

1.4.16.6
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.4.16.7;

1.4.16.7
date	2004.02.19.11.01.35;	author niklas;	state Exp;
branches;
next	1.4.16.8;

1.4.16.8
date	2004.06.05.23.13.10;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.22.32.36;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove two sysctls which were introduced only for development of the
ptm/pty subsystem, and got left behind.
ok beck
@
text
@/*	$OpenBSD: tty.h,v 1.36 2015/12/21 21:49:03 sf Exp $	*/
/*	$NetBSD: tty.h,v 1.30.4.1 1996/06/02 09:08:13 mrg Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 * (c) UNIX System Laboratories, Inc.
 * All or some portions of this file are derived from material licensed
 * to the University of California by American Telephone and Telegraph
 * Co. or Unix System Laboratories, Inc. and are reproduced herein with
 * the permission of UNIX System Laboratories, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tty.h	8.6 (Berkeley) 1/21/94
 */

#include <sys/termios.h>
#include <sys/queue.h>
#include <sys/selinfo.h>		/* For struct selinfo. */
#include <sys/timeout.h>

#define KERN_TTY_TKNIN		1	/* quad: input chars */
#define KERN_TTY_TKNOUT		2	/* quad: output chars */
#define KERN_TTY_TKRAWCC	3	/* quad: input chars, raw mode */
#define KERN_TTY_TKCANCC	4	/* quad: input char, cooked mode */
#define KERN_TTY_INFO		5	/* struct: tty stats */
/* was KERN_TTY_MAXPTYS		6 */
/* was KERN_TTY_NPTYS		7 */
#define KERN_TTY_MAXID		8

#define CTL_KERN_TTY_NAMES { \
	{ 0, 0 }, \
	{ "tk_nin", CTLTYPE_QUAD }, \
	{ "tk_nout", CTLTYPE_QUAD }, \
	{ "tk_rawcc", CTLTYPE_QUAD }, \
	{ "tk_cancc", CTLTYPE_QUAD }, \
	{ "ttyinfo", CTLTYPE_STRUCT }, \
	{ "gap", 0 }, \
	{ "gap", 0 }, \
}

/* ptmget, for /dev/ptm pty getting ioctl PTMGET */

struct ptmget {
	int	cfd;
	int	sfd;
	char	cn[16];
	char	sn[16];
};
#define PTMGET _IOR('t', 1, struct ptmget) /* get ptys */
#define PATH_PTMDEV	"/dev/ptm"
#define TTY_GID		4	/* XXX evil hardcoding of tty gid */

/*
 * Clists are actually ring buffers. The c_cc, c_cf, c_cl fields have
 * exactly the same behaviour as in true clists.
 * if c_cq is NULL, the ring buffer has no TTY_QUOTE functionality
 * (but, saves memory and cpu time)
 *
 * *DON'T* play with c_cs, c_ce, c_cq, or c_cl outside tty_subr.c!!!
 */
struct clist {
	int	c_cc;		/* count of characters in queue */
	int	c_cn;		/* total ring buffer length */
	u_char	*c_cf;		/* points to first character */
	u_char	*c_cl;		/* points to next open character */
	u_char	*c_cs;		/* start of ring buffer */
	u_char	*c_ce;		/* c_ce + c_len */
	u_char	*c_cq;		/* N bits/bytes long, see tty_subr.c */
};

/*
 * Per-tty structure.
 *
 * Should be split in two, into device and tty drivers.
 * Glue could be masks of what to echo and circular buffer
 * (low, high, timeout).
 */
struct tty {
	TAILQ_ENTRY(tty) tty_link;	/* Link in global tty list. */
	struct	clist t_rawq;		/* Device raw input queue. */
	long	t_rawcc;		/* Raw input queue statistics. */
	struct	clist t_canq;		/* Device canonical queue. */
	long	t_cancc;		/* Canonical queue statistics. */
	struct	clist t_outq;		/* Device output queue. */
	long	t_outcc;		/* Output queue statistics. */
	int	t_qlen;			/* Length of above queues */
	u_char	t_line;			/* Interface to device drivers. */
	dev_t	t_dev;			/* Device. */
	int	t_state;		/* Device and driver (TS*) state. */
	int	t_flags;		/* Tty flags. */
	struct	pgrp *t_pgrp;		/* Foreground process group. */
	struct	session *t_session;	/* Enclosing session. */
	struct	selinfo t_rsel;		/* Tty read/oob select. */
	struct	selinfo t_wsel;		/* Tty write select. */
	struct	termios t_termios;	/* Termios state. */
	struct	winsize t_winsize;	/* Window size. */
					/* Start output. */
	void	(*t_oproc)(struct tty *);
					/* Set hardware state. */
	int	(*t_param)(struct tty *, struct termios *);
					/* Set hardware flow control. */
	int	(*t_hwiflow)(struct tty *tp, int flag);
	void	*t_sc;			/* XXX: net/if_sl.c:sl_softc. */
	short	t_column;		/* Tty output column. */
	short	t_rocount, t_rocol;	/* Tty. */
	short	t_hiwat;		/* High water mark. */
	short	t_lowat;		/* Low water mark. */
	short	t_gen;			/* Generation number. */
	struct timeout t_rstrt_to;	/* restart timeout */
	struct timeval t_tv;		/* timestamp */
};

/*
 * Small version of struct tty exported via sysctl KERN_TTY_INFO
 */
struct itty {
	dev_t   t_dev;
	int t_rawq_c_cc;
	int t_canq_c_cc;
	int t_outq_c_cc;
	short t_hiwat;
	short t_lowat;
	short t_column;
	int t_state;
	struct session *t_session;
	pid_t t_pgrp_pg_id;
	u_char t_line;
};

#define	t_cc		t_termios.c_cc
#define	t_cflag		t_termios.c_cflag
#define	t_iflag		t_termios.c_iflag
#define	t_ispeed	t_termios.c_ispeed
#define	t_lflag		t_termios.c_lflag
#define	t_min		t_termios.c_min
#define	t_oflag		t_termios.c_oflag
#define	t_ospeed	t_termios.c_ospeed
#define	t_time		t_termios.c_time

#define	TTIPRI	25			/* Sleep priority for tty reads. */
#define	TTOPRI	26			/* Sleep priority for tty writes. */

#define	TTMASK	15
#define	OBUFSIZ	512
#define	TTYHOG(tp)	(tp)->t_qlen

#ifdef _KERNEL
#define	TTMAXLOWAT	256
#define	TTMINLOWAT	32
#define	TTMINHIWAT	100
#define	TTHIWATMINSPACE	200		/* Min space above hiwat */
#endif

/* These flags are kept in t_state. */
#define	TS_ASLEEP	0x00001		/* Process waiting for tty. */
#define	TS_ASYNC	0x00002		/* Tty in async I/O mode. */
#define	TS_BUSY		0x00004		/* Draining output. */
#define	TS_CARR_ON	0x00008		/* Carrier is present. */
#define	TS_FLUSH	0x00010		/* Outq has been flushed during DMA. */
#define	TS_ISOPEN	0x00020		/* Open has completed. */
#define	TS_TBLOCK	0x00040		/* Further input blocked. */
#define	TS_TIMEOUT	0x00080		/* Wait for output char processing. */
#define	TS_TTSTOP	0x00100		/* Output paused. */
#define	TS_WOPEN	0x00200		/* Open in progress. */
#define	TS_XCLUDE	0x00400		/* Tty requires exclusivity. */

/* State for intra-line fancy editing work. */
#define	TS_BKSL		0x00800		/* State for lowercase \ work. */
#define	TS_CNTTB	0x01000		/* Counting tab width, ignore FLUSHO. */
#define	TS_ERASE	0x02000		/* Within a \.../ for PRTRUB. */
#define	TS_LNCH		0x04000		/* Next character is literal. */
#define	TS_TYPEN	0x08000		/* Retyping suspended input (PENDIN). */
#define	TS_LOCAL	(TS_BKSL | TS_CNTTB | TS_ERASE | TS_LNCH | TS_TYPEN)

#define TS_TSTAMPDCDSET	0x10000		/* update timestamp on DCD set */
#define TS_TSTAMPDCDCLR	0x20000		/* update timestamp on DCD clr */
#define TS_TSTAMPCTSSET	0x40000		/* update timestamp on CTS set */
#define TS_TSTAMPCTSCLR	0x80000		/* update timestamp on CTS clr */

/* Character type information. */
#define	ORDINARY	0
#define	CONTROL		1
#define	BACKSPACE	2
#define	NEWLINE		3
#define	TAB		4
#define	VTAB		5
#define	RETURN		6

struct speedtab {
	int sp_speed;			/* Speed. */
	int sp_code;			/* Code. */
};

/* Modem control commands (driver). */
#define	DMSET		0
#define	DMBIS		1
#define	DMBIC		2
#define	DMGET		3

/* Flags on a character passed to ttyinput. */
#define	TTY_CHARMASK	0x000000ff	/* Character mask */
#define	TTY_QUOTE	0x00000100	/* Character quoted */
#define	TTY_ERRORMASK	0xff000000	/* Error mask */
#define	TTY_FE		0x01000000	/* Framing error or BREAK condition */
#define	TTY_PE		0x02000000	/* Parity error */

/* Is tp controlling terminal for pr? */
#define	isctty(pr, tp)							\
	((pr)->ps_session == (tp)->t_session && (pr)->ps_flags & PS_CONTROLT)

/* Is pr in background of tp? */
#define	isbackground(pr, tp)						\
	(isctty((pr), (tp)) && (pr)->ps_pgrp != (tp)->t_pgrp)

/*
 * ttylist_head is defined here so that user-land has access to it.
 */
TAILQ_HEAD(ttylist_head, tty);		/* the ttylist is a TAILQ */

#ifdef _KERNEL

extern	int tty_count;			/* number of ttys in global ttylist */
extern	struct ttychars ttydefaults;

/* Symbolic sleep message strings. */
extern	 char ttyin[], ttyout[], ttopen[], ttclos[], ttybg[], ttybuf[];

extern int64_t tk_cancc, tk_nin, tk_nout, tk_rawcc;

int	sysctl_tty(int *, u_int, void *, size_t *, void *, size_t);
int	sysctl_pty(int *, u_int, void *, size_t *, void *, size_t);

int	 b_to_q(u_char *cp, int cc, struct clist *q);
void	 catq(struct clist *from, struct clist *to);
void	 clist_init(void);
int	 getc(struct clist *q);
void	 ndflush(struct clist *q, int cc);
int	 ndqb(struct clist *q, int flag);
u_char	*nextc(struct clist *q, u_char *cp, int *c);
int	 putc(int c, struct clist *q);
int	 q_to_b(struct clist *q, u_char *cp, int cc);
int	 unputc(struct clist *q);

int	 nullmodem(struct tty *tp, int flag);
int	 tputchar(int c, struct tty *tp);
int	 ttioctl(struct tty *tp, u_long com, caddr_t data, int flag,
	    struct proc *p);
int	 ttread(struct tty *tp, struct uio *uio, int flag);
void	 ttrstrt(void *tp);
int	 ttpoll(dev_t device, int events, struct proc *p);
int	 ttkqfilter(dev_t dev, struct knote *kn);
void	 ttsetwater(struct tty *tp);
int	 ttspeedtab(int speed, const struct speedtab *table);
int	 ttstart(struct tty *tp);
void	 ttwakeupwr(struct tty *tp);
void	 ttwakeup(struct tty *tp);
int	 ttwrite(struct tty *tp, struct uio *uio, int flag);
void	 ttychars(struct tty *tp);
int	 ttycheckoutq(struct tty *tp, int wait);
int	 ttyclose(struct tty *tp);
void	 ttyflush(struct tty *tp, int rw);
void	 ttyinfo(struct tty *tp);
int	 ttyinput(int c, struct tty *tp);
int	 ttylclose(struct tty *tp, int flag, struct proc *p);
int	 ttymodem(struct tty *tp, int flag);
int	 ttyopen(dev_t device, struct tty *tp, struct proc *p);
int	 ttyoutput(int c, struct tty *tp);
void	 ttypend(struct tty *tp);
void	 ttyretype(struct tty *tp);
void	 ttyrub(int c, struct tty *tp);
int	 ttysleep(struct tty *tp,
	    void *chan, int pri, char *wmesg, int timeout);
int	 ttywait(struct tty *tp);
int	 ttywflush(struct tty *tp);
void	 ttytstamp(struct tty *tp, int octs, int ncts, int odcd, int ndcd);

void	tty_init(void);
struct tty *ttymalloc(int);
void	 ttyfree(struct tty *);
u_char	*firstc(struct clist *clp, int *c);

int	cttyopen(dev_t, int, int, struct proc *);
int	cttyread(dev_t, struct uio *, int);
int	cttywrite(dev_t, struct uio *, int);
int	cttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cttypoll(dev_t, int, struct proc *);

void	clalloc(struct clist *, int, int);
void	clfree(struct clist *);

int	nullioctl(struct tty *, u_long, caddr_t, int, struct proc *);

int	pppopen(dev_t dev, struct tty *, struct proc *);
int	pppclose(struct tty *, int, struct proc *);
int	ppptioctl(struct tty *, u_long, caddr_t, int, struct proc *);
int	pppinput(int c, struct tty *);
int	pppstart(struct tty *);
int	pppread(struct tty *, struct uio *, int);
int	pppwrite(struct tty *, struct uio *, int);

int	nmeaopen(dev_t, struct tty *, struct proc *);
int	nmeaclose(struct tty *, int, struct proc *);
int	nmeainput(int, struct tty *);

int	mstsopen(dev_t, struct tty *, struct proc *);
int	mstsclose(struct tty *, int, struct proc *);
int	mstsinput(int, struct tty *);

int	endrunopen(dev_t, struct tty *, struct proc *);
int	endrunclose(struct tty *, int, struct proc *);
int	endruninput(int, struct tty *);

#endif /* _KERNEL */
@


1.36
log
@Move ppp, nmea, endrun, and msts prototypes to tty.h

Fix inconsistent arguments for pppopen/pppclose/pppstart.
Use passed in argument p in pppopen instead of curproc.

"Looks good to me" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.35 2015/07/20 22:28:57 sf Exp $	*/
d50 2
a51 2
#define KERN_TTY_MAXPTYS	6	/* int: max ptys */
#define KERN_TTY_NPTYS		7	/* int: number of allocated ptys */
d61 2
a62 2
	{ "maxptys", CTLTYPE_INT }, \
	{ "nptys", CTLTYPE_INT }, \
@


1.35
log
@Fix tty hiwat handling a bit

- Introduce new defines TTHIWATMINSPACE, TTMINHIWAT for some magic values
  that are used in tty.c.
- Remove hiwat adjustments in ttwrite(). This fixes this codepath not
  being interrupt safe.
- Change ttysetwater() to keep at least TTHIWATMINSPACE space above the high
  water mark. This makes it consistent with ttycheckoutq(). Without this
  change, the hiwat adjustment change above causes deadlocks in pty.

ok kspillner@@
commit it now deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.34 2014/09/15 19:08:21 miod Exp $	*/
d315 23
a337 1
#endif
@


1.34
log
@Remove non-standard <sys/dkstat.h> header. It has not contained anything
related to disk stastics for almost 17 years, and the remaining
userland-visible defines duplicate those found in <sys/sched.h>.

Move the remaining _KERNEL defines to <sys/tty.h> where they belong, and
update all users to cope with this.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.33 2013/12/13 19:55:12 naddy Exp $	*/
d174 2
@


1.33
log
@Remove the 4.3BSD tty(4) compatibility shims.  RIP.  ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.32 2013/01/17 21:24:58 deraadt Exp $	*/
d249 2
@


1.32
log
@Ensure the tty hiwat is less than the size of the ring buffer (since
we do not grow space like clist chains).  Clamp it a bit more precisely,
ensuring a bit of space for kernel ^T handling and such.  It was definately
wrong, and we can tune this if required later.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.31 2011/07/04 22:53:53 tedu Exp $	*/
a309 5

#if defined(COMPAT_43)
# define COMPAT_OLDTTY
int 	ttcompat(struct tty *, u_long, caddr_t, int, struct proc *);
#endif
@


1.31
log
@remove compat_svr4 support.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.30 2011/04/05 12:50:15 guenther Exp $	*/
a171 2
#define	TTMAXHIWAT	roundup(2048, CBSIZE)
#define	TTMINHIWAT	roundup(100, CBSIZE)
@


1.30
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.29 2010/07/26 01:56:27 guenther Exp $	*/
d313 1
a313 1
#if defined(COMPAT_43) || defined(COMPAT_SVR4)
@


1.29
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.28 2010/07/02 19:57:15 tedu Exp $	*/
d313 1
a313 2
#if defined(COMPAT_43) || defined(COMPAT_SVR4) || \
    defined(COMPAT_FREEBSD)
@


1.28
log
@remove support for compat_sunos (and m68k4k).  ok deraadt guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.27 2010/07/02 17:27:01 nicm Exp $	*/
d231 7
a237 7
/* Is tp controlling terminal for p? */
#define	isctty(p, tp)							\
	((p)->p_session == (tp)->t_session && (p)->p_flag & P_CONTROLT)

/* Is p in background of tp? */
#define	isbackground(p, tp)						\
	(isctty((p), (tp)) && (p)->p_pgrp != (tp)->t_pgrp)
@


1.27
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.26 2010/06/30 20:38:50 tedu Exp $	*/
d313 1
a313 1
#if defined(COMPAT_43) || defined(COMPAT_SUNOS) || defined(COMPAT_SVR4) || \
@


1.26
log
@remove compat_osf1 support from the kernel
ok deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.25 2010/06/28 14:13:36 deraadt Exp $	*/
d277 1
@


1.25
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.24 2010/04/12 12:57:52 tedu Exp $	*/
d313 1
a313 1
    defined(COMPAT_FREEBSD) || defined(COMPAT_OSF1)
@


1.24
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.23 2009/07/19 08:16:06 blambert Exp $	*/
d110 1
d169 1
a169 1
#define	TTYHOG	1024
d299 1
a299 1
struct tty *ttymalloc(void);
@


1.23
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.22 2006/08/17 06:27:05 miod Exp $	*/
d284 1
a284 1
int	 ttylclose(struct tty *tp, int flag);
d286 1
a286 1
int	 ttyopen(dev_t device, struct tty *tp);
@


1.22
log
@Jump scroll support for vt100 and sun wscons emulations, helps macppc and
zaurus a lot, tested by many; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.21 2006/04/27 19:30:28 deraadt Exp $	*/
d308 1
a308 1
int	clalloc(struct clist *, int, int);
@


1.21
log
@create a (very simple) method for timestamping CTS & DCD events on ttys,
using ioctl TIOCSTSTAMP & TIOCGTSTAMP.  to be used later for gps monitoring
type things; ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.20 2005/11/21 18:16:46 millert Exp $	*/
d167 1
a167 1
#define	OBUFSIZ	100
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.19 2004/09/19 21:34:43 mickey Exp $	*/
d133 1
d198 5
d295 1
@


1.19
log
@constify speedtabs and make ttspeedtab() take a const struct speedtab *
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.18 2004/02/10 01:31:21 millert Exp $	*/
d42 1
a42 1
#include <sys/select.h>		/* For struct selinfo. */
@


1.18
log
@Add the ptm device to pty(4).  By opening /dev/ptm and using the PTMGET
ioctl(2), an unprivileged process may allocate a pty and have its owner
and mode set appropriately.  This means that programs such as xterm and
screen no longer need to be setuid.  Programs using the openpty()
function require zero changes and will "just work".

Designed by beck@@ and deraadt@@; changes by beck@@ with cleanup (and
a rewrite of the vnode bits) by art@@ and tweaks/bugfixes by me.
Tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.17 2004/02/10 01:19:47 millert Exp $	*/
d268 1
a268 1
int	 ttspeedtab(int speed, struct speedtab *table);
@


1.17
log
@Dynamically allocate space for ptys; adapted from NetBSD by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.16 2003/10/03 16:44:51 miod Exp $	*/
d64 12
@


1.16
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.15 2003/09/23 16:51:13 millert Exp $	*/
d49 4
a52 2
#define KERN_TTY_INFO		5
#define KERN_TTY_MAXID		6
d61 2
d234 1
@


1.15
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.14 2003/06/02 23:28:22 millert Exp $	*/
a273 2
void	tty_attach(struct tty *);
void	tty_detach(struct tty *);
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.13 2002/12/12 04:17:14 deraadt Exp $	*/
d248 1
a248 1
int	 ttselect(dev_t device, int rw, struct proc *p);
d284 1
a284 1
int	cttyselect(dev_t, int, struct proc *);
@


1.13
log
@can now get _ttylist via sysctl; millert ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.12 2002/03/14 01:27:14 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.11 2001/07/05 10:12:28 art Exp $	*/
d53 2
a54 1
#define KERN_TTY_MAXID		5
d62 1
d121 17
@


1.11
log
@Get rid of REAL_CLISTS. It was never implemented and the tentacles are
everywhhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.10 2001/06/22 14:11:00 deraadt Exp $	*/
d107 1
a107 1
	void	(*t_oproc) __P((struct tty *));
d109 1
a109 1
	int	(*t_param) __P((struct tty *, struct termios *));
d111 1
a111 1
	int	(*t_hwiflow) __P((struct tty *tp, int flag));
d214 1
a214 1
int	sysctl_tty __P((int *, u_int, void *, size_t *, void *, size_t));
d216 54
a269 54
int	 b_to_q __P((u_char *cp, int cc, struct clist *q));
void	 catq __P((struct clist *from, struct clist *to));
void	 clist_init __P((void));
int	 getc __P((struct clist *q));
void	 ndflush __P((struct clist *q, int cc));
int	 ndqb __P((struct clist *q, int flag));
u_char	*nextc __P((struct clist *q, u_char *cp, int *c));
int	 putc __P((int c, struct clist *q));
int	 q_to_b __P((struct clist *q, u_char *cp, int cc));
int	 unputc __P((struct clist *q));

int	 nullmodem __P((struct tty *tp, int flag));
int	 tputchar __P((int c, struct tty *tp));
int	 ttioctl __P((struct tty *tp, u_long com, caddr_t data, int flag,
	    struct proc *p));
int	 ttread __P((struct tty *tp, struct uio *uio, int flag));
void	 ttrstrt __P((void *tp));
int	 ttselect __P((dev_t device, int rw, struct proc *p));
int	 ttkqfilter __P((dev_t dev, struct knote *kn));
void	 ttsetwater __P((struct tty *tp));
int	 ttspeedtab __P((int speed, struct speedtab *table));
int	 ttstart __P((struct tty *tp));
void	 ttwakeup __P((struct tty *tp));
int	 ttwrite __P((struct tty *tp, struct uio *uio, int flag));
void	 ttychars __P((struct tty *tp));
int	 ttycheckoutq __P((struct tty *tp, int wait));
int	 ttyclose __P((struct tty *tp));
void	 ttyflush __P((struct tty *tp, int rw));
void	 ttyinfo __P((struct tty *tp));
int	 ttyinput __P((int c, struct tty *tp));
int	 ttylclose __P((struct tty *tp, int flag));
int	 ttymodem __P((struct tty *tp, int flag));
int	 ttyopen __P((dev_t device, struct tty *tp));
int	 ttyoutput __P((int c, struct tty *tp));
void	 ttypend __P((struct tty *tp));
void	 ttyretype __P((struct tty *tp));
void	 ttyrub __P((int c, struct tty *tp));
int	 ttysleep __P((struct tty *tp,
	    void *chan, int pri, char *wmesg, int timeout));
int	 ttywait __P((struct tty *tp));
int	 ttywflush __P((struct tty *tp));

void	tty_init __P((void));
void	tty_attach __P((struct tty *));
void	tty_detach __P((struct tty *));
struct tty *ttymalloc __P((void));
void	 ttyfree __P((struct tty *));
u_char	*firstc __P((struct clist *clp, int *c));

int	cttyopen __P((dev_t, int, int, struct proc *));
int	cttyread __P((dev_t, struct uio *, int));
int	cttywrite __P((dev_t, struct uio *, int));
int	cttyioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	cttyselect __P((dev_t, int, struct proc *));
d271 2
a272 2
int	clalloc __P((struct clist *, int, int));
void	clfree __P((struct clist *));
d277 1
a277 1
int 	ttcompat __P((struct tty *, u_long, caddr_t, int, struct proc *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.11 2001/07/05 10:12:28 art Exp $	*/
d107 1
a107 1
	void	(*t_oproc)(struct tty *);
d109 1
a109 1
	int	(*t_param)(struct tty *, struct termios *);
d111 1
a111 1
	int	(*t_hwiflow)(struct tty *tp, int flag);
d214 1
a214 1
int	sysctl_tty(int *, u_int, void *, size_t *, void *, size_t);
d216 54
a269 54
int	 b_to_q(u_char *cp, int cc, struct clist *q);
void	 catq(struct clist *from, struct clist *to);
void	 clist_init(void);
int	 getc(struct clist *q);
void	 ndflush(struct clist *q, int cc);
int	 ndqb(struct clist *q, int flag);
u_char	*nextc(struct clist *q, u_char *cp, int *c);
int	 putc(int c, struct clist *q);
int	 q_to_b(struct clist *q, u_char *cp, int cc);
int	 unputc(struct clist *q);

int	 nullmodem(struct tty *tp, int flag);
int	 tputchar(int c, struct tty *tp);
int	 ttioctl(struct tty *tp, u_long com, caddr_t data, int flag,
	    struct proc *p);
int	 ttread(struct tty *tp, struct uio *uio, int flag);
void	 ttrstrt(void *tp);
int	 ttselect(dev_t device, int rw, struct proc *p);
int	 ttkqfilter(dev_t dev, struct knote *kn);
void	 ttsetwater(struct tty *tp);
int	 ttspeedtab(int speed, struct speedtab *table);
int	 ttstart(struct tty *tp);
void	 ttwakeup(struct tty *tp);
int	 ttwrite(struct tty *tp, struct uio *uio, int flag);
void	 ttychars(struct tty *tp);
int	 ttycheckoutq(struct tty *tp, int wait);
int	 ttyclose(struct tty *tp);
void	 ttyflush(struct tty *tp, int rw);
void	 ttyinfo(struct tty *tp);
int	 ttyinput(int c, struct tty *tp);
int	 ttylclose(struct tty *tp, int flag);
int	 ttymodem(struct tty *tp, int flag);
int	 ttyopen(dev_t device, struct tty *tp);
int	 ttyoutput(int c, struct tty *tp);
void	 ttypend(struct tty *tp);
void	 ttyretype(struct tty *tp);
void	 ttyrub(int c, struct tty *tp);
int	 ttysleep(struct tty *tp,
	    void *chan, int pri, char *wmesg, int timeout);
int	 ttywait(struct tty *tp);
int	 ttywflush(struct tty *tp);

void	tty_init(void);
void	tty_attach(struct tty *);
void	tty_detach(struct tty *);
struct tty *ttymalloc(void);
void	 ttyfree(struct tty *);
u_char	*firstc(struct clist *clp, int *c);

int	cttyopen(dev_t, int, int, struct proc *);
int	cttyread(dev_t, struct uio *, int);
int	cttywrite(dev_t, struct uio *, int);
int	cttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cttyselect(dev_t, int, struct proc *);
d271 2
a272 2
int	clalloc(struct clist *, int, int);
void	clfree(struct clist *);
d277 1
a277 1
int 	ttcompat(struct tty *, u_long, caddr_t, int, struct proc *);
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 1
a53 2
#define KERN_TTY_INFO		5
#define KERN_TTY_MAXID		6
a60 1
	{ "ttyinfo", CTLTYPE_STRUCT }, \
a118 17
};

/*
 * Small version of struct tty exported via sysctl KERN_TTY_INFO
 */
struct itty {
	dev_t   t_dev;
	int t_rawq_c_cc;
	int t_canq_c_cc;
	int t_outq_c_cc;
	short t_hiwat;
	short t_lowat;
	short t_column;
	int t_state;
	struct session *t_session;
	pid_t t_pgrp_pg_id;
	u_char t_line;
@


1.10
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.9 2001/05/14 07:07:14 angelos Exp $	*/
a62 1
#ifndef REAL_CLISTS
a79 11
#else
/*
 * Clists are character lists, which is a variable length linked list
 * of cblocks, with a count of the number of characters in the list.
 */
struct clist {
	int	c_cc;		/* Number of characters in the clist. */
	u_char	*c_cf;		/* Pointer to the first cblock. */
	u_char	*c_cl;		/* Pointer to the last cblock. */
};
#endif
@


1.9
log
@KERN_TTY sysctl
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.8 2001/03/01 20:54:35 provos Exp $	*/
d275 1
a275 1
u_char	*firstc           __P((struct clist *clp, int *c));
@


1.8
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.7 2000/11/16 20:02:21 provos Exp $	*/
d49 14
d225 2
@


1.7
log
@support kernel event queues, from FreeBSD by Jonathan Lemon,
okay art@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.6 2000/08/13 03:38:45 ericj Exp $	*/
d230 1
@


1.6
log
@
if COMPAT_OSF1 is defined, define COMPAT_OLDSOCK
and COMPAT_OLDTTY.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.5 2000/07/19 13:37:27 art Exp $	*/
d45 1
a46 1
#include <sys/queue.h>
@


1.5
log
@Many drivers use a timeout on ttrstrt, make this a generic interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.4 1996/06/10 07:31:41 deraadt Exp $	*/
d270 1
a270 1
    defined(COMPAT_FREEBSD)
@


1.4
log
@tty stats
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.2 1996/03/03 12:12:32 niklas Exp $	*/
d47 1
d116 1
@


1.4.16.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.8 2001/03/01 20:54:35 provos Exp $	*/
d45 1
a46 2
#include <sys/select.h>		/* For struct selinfo. */
#include <sys/timeout.h>
a114 1
	struct timeout t_rstrt_to;	/* restart timeout */
a227 1
int	 ttkqfilter __P((dev_t dev, struct knote *kn));
d268 1
a268 1
    defined(COMPAT_FREEBSD) || defined(COMPAT_OSF1)
@


1.4.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.4.16.1 2001/05/14 22:45:05 niklas Exp $	*/
a48 14
#define KERN_TTY_TKNIN		1	/* quad: input chars */
#define KERN_TTY_TKNOUT		2	/* quad: output chars */
#define KERN_TTY_TKRAWCC	3	/* quad: input chars, raw mode */
#define KERN_TTY_TKCANCC	4	/* quad: input char, cooked mode */
#define KERN_TTY_MAXID		5

#define CTL_KERN_TTY_NAMES { \
	{ 0, 0 }, \
	{ "tk_nin", CTLTYPE_QUAD }, \
	{ "tk_nout", CTLTYPE_QUAD }, \
	{ "tk_rawcc", CTLTYPE_QUAD }, \
	{ "tk_cancc", CTLTYPE_QUAD }, \
}

a211 2
int	sysctl_tty __P((int *, u_int, void *, size_t *, void *, size_t));

d259 1
a259 1
u_char	*firstc __P((struct clist *clp, int *c));
@


1.4.16.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.4.16.2 2001/07/04 11:00:35 niklas Exp $	*/
d63 1
d81 11
@


1.4.16.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d107 1
a107 1
	void	(*t_oproc)(struct tty *);
d109 1
a109 1
	int	(*t_param)(struct tty *, struct termios *);
d111 1
a111 1
	int	(*t_hwiflow)(struct tty *tp, int flag);
d214 1
a214 1
int	sysctl_tty(int *, u_int, void *, size_t *, void *, size_t);
d216 54
a269 54
int	 b_to_q(u_char *cp, int cc, struct clist *q);
void	 catq(struct clist *from, struct clist *to);
void	 clist_init(void);
int	 getc(struct clist *q);
void	 ndflush(struct clist *q, int cc);
int	 ndqb(struct clist *q, int flag);
u_char	*nextc(struct clist *q, u_char *cp, int *c);
int	 putc(int c, struct clist *q);
int	 q_to_b(struct clist *q, u_char *cp, int cc);
int	 unputc(struct clist *q);

int	 nullmodem(struct tty *tp, int flag);
int	 tputchar(int c, struct tty *tp);
int	 ttioctl(struct tty *tp, u_long com, caddr_t data, int flag,
	    struct proc *p);
int	 ttread(struct tty *tp, struct uio *uio, int flag);
void	 ttrstrt(void *tp);
int	 ttselect(dev_t device, int rw, struct proc *p);
int	 ttkqfilter(dev_t dev, struct knote *kn);
void	 ttsetwater(struct tty *tp);
int	 ttspeedtab(int speed, struct speedtab *table);
int	 ttstart(struct tty *tp);
void	 ttwakeup(struct tty *tp);
int	 ttwrite(struct tty *tp, struct uio *uio, int flag);
void	 ttychars(struct tty *tp);
int	 ttycheckoutq(struct tty *tp, int wait);
int	 ttyclose(struct tty *tp);
void	 ttyflush(struct tty *tp, int rw);
void	 ttyinfo(struct tty *tp);
int	 ttyinput(int c, struct tty *tp);
int	 ttylclose(struct tty *tp, int flag);
int	 ttymodem(struct tty *tp, int flag);
int	 ttyopen(dev_t device, struct tty *tp);
int	 ttyoutput(int c, struct tty *tp);
void	 ttypend(struct tty *tp);
void	 ttyretype(struct tty *tp);
void	 ttyrub(int c, struct tty *tp);
int	 ttysleep(struct tty *tp,
	    void *chan, int pri, char *wmesg, int timeout);
int	 ttywait(struct tty *tp);
int	 ttywflush(struct tty *tp);

void	tty_init(void);
void	tty_attach(struct tty *);
void	tty_detach(struct tty *);
struct tty *ttymalloc(void);
void	 ttyfree(struct tty *);
u_char	*firstc(struct clist *clp, int *c);

int	cttyopen(dev_t, int, int, struct proc *);
int	cttyread(dev_t, struct uio *, int);
int	cttywrite(dev_t, struct uio *, int);
int	cttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cttyselect(dev_t, int, struct proc *);
d271 2
a272 2
int	clalloc(struct clist *, int, int);
void	clfree(struct clist *);
d277 1
a277 1
int 	ttcompat(struct tty *, u_long, caddr_t, int, struct proc *);
@


1.4.16.5
log
@Sync the SMP branch with 3.3
@
text
@d53 1
a53 2
#define KERN_TTY_INFO		5
#define KERN_TTY_MAXID		6
a60 1
	{ "ttyinfo", CTLTYPE_STRUCT }, \
a118 17
};

/*
 * Small version of struct tty exported via sysctl KERN_TTY_INFO
 */
struct itty {
	dev_t   t_dev;
	int t_rawq_c_cc;
	int t_canq_c_cc;
	int t_outq_c_cc;
	short t_hiwat;
	short t_lowat;
	short t_column;
	int t_state;
	struct session *t_session;
	pid_t t_pgrp_pg_id;
	u_char t_line;
@


1.4.16.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tty.h,v 1.4.16.5 2003/03/28 00:41:30 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.16.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 1
a248 1
int	 ttpoll(dev_t device, int events, struct proc *p);
d274 2
d284 1
a284 1
int	cttypoll(dev_t, int, struct proc *);
@


1.4.16.8
log
@Merge with the trunk
@
text
@d49 2
a50 4
#define KERN_TTY_INFO		5	/* struct: tty stats */
#define KERN_TTY_MAXPTYS	6	/* int: max ptys */
#define KERN_TTY_NPTYS		7	/* int: number of allocated ptys */
#define KERN_TTY_MAXID		8
a58 2
	{ "maxptys", CTLTYPE_INT }, \
	{ "nptys", CTLTYPE_INT }, \
a60 12
/* ptmget, for /dev/ptm pty getting ioctl PTMGET */

struct ptmget {
	int	cfd;
	int	sfd;
	char	cn[16];
	char	sn[16];
};
#define PTMGET _IOR('t', 1, struct ptmget) /* get ptys */
#define PATH_PTMDEV	"/dev/ptm"
#define TTY_GID		4	/* XXX evil hardcoding of tty gid */

a229 1
int	sysctl_pty(int *, u_int, void *, size_t *, void *, size_t);
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: tty.h,v 1.30 1996/04/09 20:55:44 cgd Exp $	*/
d46 1
d86 1
d197 5
d203 2
d251 3
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tty.h,v 1.29 1996/02/09 18:25:44 christos Exp $	*/
d53 1
a53 1
 * 
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tty.h,v 1.28 1995/03/26 20:24:57 jtc Exp $	*/
d245 16
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
