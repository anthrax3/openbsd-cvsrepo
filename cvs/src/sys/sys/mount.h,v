head	1.129;
access;
symbols
	OPENBSD_6_1:1.128.0.4
	OPENBSD_6_1_BASE:1.128
	OPENBSD_6_0:1.126.0.2
	OPENBSD_6_0_BASE:1.126
	OPENBSD_5_9:1.121.0.4
	OPENBSD_5_9_BASE:1.121
	OPENBSD_5_8:1.121.0.6
	OPENBSD_5_8_BASE:1.121
	OPENBSD_5_7:1.121.0.2
	OPENBSD_5_7_BASE:1.121
	OPENBSD_5_6:1.120.0.4
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.114.0.2
	OPENBSD_5_4_BASE:1.114
	OPENBSD_5_3:1.108.0.2
	OPENBSD_5_3_BASE:1.108
	OPENBSD_5_2:1.106.0.4
	OPENBSD_5_2_BASE:1.106
	OPENBSD_5_1_BASE:1.106
	OPENBSD_5_1:1.106.0.2
	OPENBSD_5_0:1.105.0.2
	OPENBSD_5_0_BASE:1.105
	OPENBSD_4_9:1.100.0.4
	OPENBSD_4_9_BASE:1.100
	OPENBSD_4_8:1.100.0.2
	OPENBSD_4_8_BASE:1.100
	OPENBSD_4_7:1.99.0.2
	OPENBSD_4_7_BASE:1.99
	OPENBSD_4_6:1.95.0.4
	OPENBSD_4_6_BASE:1.95
	OPENBSD_4_5:1.91.0.4
	OPENBSD_4_5_BASE:1.91
	OPENBSD_4_4:1.91.0.2
	OPENBSD_4_4_BASE:1.91
	OPENBSD_4_3:1.81.0.4
	OPENBSD_4_3_BASE:1.81
	OPENBSD_4_2:1.81.0.2
	OPENBSD_4_2_BASE:1.81
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.75.0.2
	OPENBSD_4_0_BASE:1.75
	OPENBSD_3_9:1.67.0.2
	OPENBSD_3_9_BASE:1.67
	OPENBSD_3_8:1.62.0.2
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.58.0.8
	OPENBSD_3_7_BASE:1.58
	OPENBSD_3_6:1.58.0.6
	OPENBSD_3_6_BASE:1.58
	SMP_SYNC_A:1.58
	SMP_SYNC_B:1.58
	OPENBSD_3_5:1.58.0.4
	OPENBSD_3_5_BASE:1.58
	OPENBSD_3_4:1.58.0.2
	OPENBSD_3_4_BASE:1.58
	UBC_SYNC_A:1.51
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.46.0.2
	OPENBSD_3_1_BASE:1.46
	UBC_SYNC_B:1.48
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.39.0.4
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.37.0.2
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	SMP:1.34.0.2
	SMP_BASE:1.34
	kame_19991208:1.32
	OPENBSD_2_6:1.31.0.2
	OPENBSD_2_6_BASE:1.31
	OPENBSD_2_5:1.27.0.2
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.24.0.2
	OPENBSD_2_4_BASE:1.24
	OPENBSD_2_3:1.22.0.2
	OPENBSD_2_3_BASE:1.22
	OPENBSD_2_2:1.20.0.2
	OPENBSD_2_2_BASE:1.20
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.129
date	2017.04.15.13.56.43;	author bluhm;	state Exp;
branches;
next	1.128;
commitid	nYgciuoKC5HVIW5V;

1.128
date	2017.01.10.19.48.32;	author bluhm;	state Exp;
branches;
next	1.127;
commitid	nzxicVheAaFpfTKW;

1.127
date	2016.09.10.16.53.30;	author natano;	state Exp;
branches;
next	1.126;
commitid	OheBN9SCINTycSAi;

1.126
date	2016.05.27.19.45.04;	author deraadt;	state Exp;
branches;
next	1.125;
commitid	nQEqvpt7rKDi6fz0;

1.125
date	2016.05.25.13.31.44;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	mVwKZyIfHvyXpI49;

1.124
date	2016.05.21.18.11.36;	author natano;	state Exp;
branches;
next	1.123;
commitid	h6HuALSffVqURa2m;

1.123
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.122;
commitid	gFybgYMymUyTbVeS;

1.122
date	2016.02.26.08.56.10;	author natano;	state Exp;
branches;
next	1.121;
commitid	1wcjndbWCkf5R7p2;

1.121
date	2014.09.08.01.47.06;	author guenther;	state Exp;
branches;
next	1.120;
commitid	QKTb36RFnfteZJPE;

1.120
date	2014.06.04.07.58.14;	author claudio;	state Exp;
branches;
next	1.119;
commitid	UIUmMgTXqZXBplEA;

1.119
date	2014.05.20.13.32.22;	author syl;	state Exp;
branches;
next	1.118;

1.118
date	2014.03.24.00.19.48;	author guenther;	state Exp;
branches;
next	1.117;

1.117
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2013.09.24.09.20.12;	author espie;	state Exp;
branches;
next	1.115;

1.115
date	2013.08.14.05.26.14;	author guenther;	state Exp;
branches;
next	1.114;

1.114
date	2013.07.09.15.37.43;	author beck;	state Exp;
branches;
next	1.113;

1.113
date	2013.06.21.21.30.38;	author syl;	state Exp;
branches;
next	1.112;

1.112
date	2013.06.11.19.01.20;	author beck;	state Exp;
branches;
next	1.111;

1.111
date	2013.06.03.15.56.01;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2013.06.03.15.54.48;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2012.09.05.17.01.06;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.23.06.12.49;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2011.09.19.14.48.04;	author beck;	state Exp;
branches;
next	1.105;

1.105
date	2011.07.06.20.50.05;	author beck;	state Exp;
branches;
next	1.104;

1.104
date	2011.07.06.00.11.57;	author beck;	state Exp;
branches;
next	1.103;

1.103
date	2011.04.05.18.51.26;	author thib;	state Exp;
branches;
next	1.102;

1.102
date	2011.04.04.15.22.10;	author thib;	state Exp;
branches;
next	1.101;

1.101
date	2011.04.04.12.50.58;	author thib;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.29.04.09.32;	author tedu;	state Exp;
branches;
next	1.99;

1.99
date	2009.10.14.17.53.30;	author beck;	state Exp;
branches;
next	1.98;

1.98
date	2009.08.09.14.37.46;	author art;	state Exp;
branches;
next	1.97;

1.97
date	2009.08.08.15.04.43;	author beck;	state Exp;
branches;
next	1.96;

1.96
date	2009.08.02.16.28.40;	author beck;	state Exp;
branches;
next	1.95;

1.95
date	2009.06.15.17.01.26;	author beck;	state Exp;
branches;
next	1.94;

1.94
date	2009.06.05.04.29.14;	author beck;	state Exp;
branches;
next	1.93;

1.93
date	2009.06.03.21.30.20;	author beck;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.03.14.45.55;	author jj;	state Exp;
branches;
next	1.91;

1.91
date	2008.07.22.08.05.02;	author thib;	state Exp;
branches;
next	1.90;

1.90
date	2008.07.05.12.56.52;	author thib;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.02.15.21.33;	author art;	state Exp;
branches;
next	1.88;

1.88
date	2008.06.13.01.59.45;	author rainer;	state Exp;
branches;
next	1.87;

1.87
date	2008.06.12.06.58.40;	author deraadt;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.11.12.35.46;	author deraadt;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.10.20.14.37;	author beck;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.07.14.09.36;	author thib;	state Exp;
branches;
next	1.83;

1.83
date	2008.05.06.17.19.40;	author thib;	state Exp;
branches;
next	1.82;

1.82
date	2008.03.16.19.42.57;	author otto;	state Exp;
branches;
next	1.81;

1.81
date	2007.06.01.05.37.14;	author deraadt;	state Exp;
branches;
next	1.80;

1.80
date	2007.05.26.20.26.51;	author pedro;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.24.12.10.28;	author millert;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.21.13.44.04;	author pedro;	state Exp;
branches;
next	1.77;

1.77
date	2006.12.15.03.04.24;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2006.09.22.14.23.03;	author pedro;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.11.21.17.58;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2006.07.11.16.24.09;	author pedro;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.25.15.01.54;	author sturm;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.14.20.01.50;	author sturm;	state Exp;
branches;
next	1.71;

1.71
date	2006.05.28.03.55.56;	author pedro;	state Exp;
branches;
next	1.70;

1.70
date	2006.04.30.14.20.07;	author sturm;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.31.13.05.23;	author pedro;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2005.12.06.20.18.57;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.30.10.35.08;	author pedro;	state Exp;
branches;
next	1.64;

1.64
date	2005.11.24.12.08.16;	author pedro;	state Exp;
branches;
next	1.63;

1.63
date	2005.10.25.18.03.29;	author pedro;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.03.20.14.00;	author drahn;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.26.00.33.45;	author pedro;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.24.05.34.54;	author pedro;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.29.17.24.52;	author pedro;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.14.07.46.40;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2003.08.05.21.27.15;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.05.20.47.36;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.18.23.02.58;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.24.21.48.05;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.20.03.05.42;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.06.20.52.59;	author tedu;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.18.22.12.25;	author tedu;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.24.02.17.22;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.12.14.02.23;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.46;

1.46
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.44;

1.44
date	2002.02.22.20.37.45;	author drahn;	state Exp;
branches;
next	1.43;

1.43
date	2002.01.18.01.36.29;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.41;

1.41
date	2001.11.27.05.27.12;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.11.21.21.13.34;	author csapuntz;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.23.00.24.10;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2001.02.20.01.50.11;	author assar;	state Exp;
branches;
next	1.37;

1.37
date	2000.06.17.17.16.04;	author provos;	state Exp;
branches;
next	1.36;

1.36
date	2000.05.22.17.29.06;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2000.03.24.19.07.48;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2000.02.09.10.29.56;	author assar;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2000.02.07.04.52.11;	author assar;	state Exp;
branches;
next	1.32;

1.32
date	99.12.05.06.56.34;	author art;	state Exp;
branches;
next	1.31;

1.31
date	99.07.02.23.35.53;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	99.06.21.08.27.07;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	99.05.31.17.34.52;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	99.05.06.15.59.48;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	99.03.11.18.55.24;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.03.11.18.29.03;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	99.02.19.17.15.44;	author art;	state Exp;
branches;
next	1.24;

1.24
date	98.09.01.17.01.07;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	98.08.30.17.11.34;	author art;	state Exp;
branches;
next	1.22;

1.22
date	98.02.08.22.41.47;	author tholo;	state Exp;
branches;
next	1.21;

1.21
date	97.11.06.05.59.09;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	97.10.06.20.21.08;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.10.06.15.25.33;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	97.04.16.09.49.00;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	97.04.12.20.20.08;	author graichen;	state Exp;
branches;
next	1.16;

1.16
date	97.04.12.20.02.32;	author graichen;	state Exp;
branches;
next	1.15;

1.15
date	97.03.09.19.26.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	97.03.02.09.52.50;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	97.03.02.09.38.22;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	96.12.24.20.14.35;	author dm;	state Exp;
branches;
next	1.11;

1.11
date	96.12.17.03.46.36;	author dm;	state Exp;
branches;
next	1.10;

1.10
date	96.07.05.09.09.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.07.05.06.52.32;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.06.24.03.35.00;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.21.41.00;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.03.31.13.16.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.02.29.13.57.27;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.01.29.07.05.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.14.04.02.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.06.21.19.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.34.2.1
date	2001.05.14.22.45.02;	author niklas;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.34.2.6;

1.34.2.6
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.34.2.7;

1.34.2.7
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.34.2.8;

1.34.2.8
date	2004.02.19.11.01.33;	author niklas;	state Exp;
branches;
next	;

1.41.2.1
date	2002.01.31.22.55.49;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.129
log
@After forced unmount of a file system that has other mount points
in it, dangling mounts could remain.  When unmounting check the
hierarcy and unmount recursively.  Also prevent that a new mount
appears during the scan.
Joint work with natano@@; testing and OK krw@@
@
text
@/*	$OpenBSD: mount.h,v 1.128 2017/01/10 19:48:32 bluhm Exp $	*/
/*	$NetBSD: mount.h,v 1.48 1996/02/18 11:55:47 fvdl Exp $	*/

/*
 * Copyright (c) 1989, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mount.h	8.15 (Berkeley) 7/14/94
 */

#ifndef _SYS_MOUNT_H_
#define _SYS_MOUNT_H_

#include <sys/cdefs.h>
#ifndef _KERNEL
#include <sys/ucred.h>
#endif
#include <sys/queue.h>
#include <sys/rwlock.h>

typedef struct { int32_t val[2]; } fsid_t;	/* file system id type */

/*
 * File identifier.
 * These are unique per filesystem on a single machine.
 */
#define	MAXFIDSZ	16

struct fid {
	u_short		fid_len;		/* length of data in bytes */
	u_short		fid_reserved;		/* force longword alignment */
	char		fid_data[MAXFIDSZ];	/* data (variable length) */
};

/*
 * Export arguments for local filesystem mount calls.
 */
struct export_args {
	int	ex_flags;		/* export related flags */
	uid_t	ex_root;		/* mapping for root uid */
	struct	xucred ex_anon;		/* mapping for anonymous user */
	struct	sockaddr *ex_addr;	/* net address to which exported */
	int	ex_addrlen;		/* and the net address length */
	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
	int	ex_masklen;		/* and the smask length */
};

/*
 * Arguments to mount UFS-based filesystems
 */
struct ufs_args {
	char	*fspec;			/* block special device to mount */
	struct	export_args export_info;/* network export information */
};

/*
 * Arguments to mount MFS
 */
struct mfs_args {
	char	*fspec;			/* name to export for statfs */
	struct	export_args export_info;/* if exported MFSes are supported */
	caddr_t	base;			/* base of file system in memory */
	u_long	size;			/* size of file system */
};

/*
 * Arguments to mount ISO 9660 filesystems.
 */
struct iso_args {
	char	*fspec;			/* block special device to mount */
	struct	export_args export_info;/* network export info */
	int	flags;			/* mounting flags, see below */
	int	sess;			/* start sector of session */
};

#define	ISOFSMNT_NORRIP		0x00000001	/* disable Rock Ridge Ext.*/
#define	ISOFSMNT_GENS		0x00000002	/* enable generation numbers */
#define	ISOFSMNT_EXTATT		0x00000004	/* enable extended attr. */
#define	ISOFSMNT_NOJOLIET	0x00000008	/* disable Joliet Ext.*/
#define	ISOFSMNT_SESS		0x00000010	/* use iso_args.sess */

/*
 * Arguments to mount NFS
 */
#define NFS_ARGSVERSION	4		/* change when nfs_args changes */
struct nfs_args {
	int		version;	/* args structure version number */
	struct sockaddr	*addr;		/* file server address */
	int		addrlen;	/* length of address */
	int		sotype;		/* Socket type */
	int		proto;		/* and Protocol */
	u_char		*fh;		/* File handle to be mounted */
	int		fhsize;		/* Size, in bytes, of fh */
	int		flags;		/* flags */
	int		wsize;		/* write size in bytes */
	int		rsize;		/* read size in bytes */
	int		readdirsize;	/* readdir size in bytes */
	int		timeo;		/* initial timeout in .1 secs */
	int		retrans;	/* times to retry send */
	int		maxgrouplist;	/* Max. size of group list */
	int		readahead;	/* # of blocks to readahead */
	int		leaseterm;	/* Term (sec) of lease */
	int		deadthresh;	/* Retrans threshold */
	char		*hostname;	/* server's name */
	int		acregmin;	/* Attr cache file recently modified */
	int		acregmax;	/* ac file not recently modified */
	int		acdirmin;	/* ac for dir recently modified */
	int		acdirmax;	/* ac for dir not recently modified */
};
/* NFS args version 3 (for backwards compatibility) */
struct nfs_args3 {
	int		version;	/* args structure version number */
	struct sockaddr	*addr;		/* file server address */
	int		addrlen;	/* length of address */
	int		sotype;		/* Socket type */
	int		proto;		/* and Protocol */
	u_char		*fh;		/* File handle to be mounted */
	int		fhsize;		/* Size, in bytes, of fh */
	int		flags;		/* flags */
	int		wsize;		/* write size in bytes */
	int		rsize;		/* read size in bytes */
	int		readdirsize;	/* readdir size in bytes */
	int		timeo;		/* initial timeout in .1 secs */
	int		retrans;	/* times to retry send */
	int		maxgrouplist;	/* Max. size of group list */
	int		readahead;	/* # of blocks to readahead */
	int		leaseterm;	/* Term (sec) of lease */
	int		deadthresh;	/* Retrans threshold */
	char		*hostname;	/* server's name */
};

/*
 * NFS mount option flags
 */
#define	NFSMNT_RESVPORT		0x00000000  /* always use reserved ports */
#define	NFSMNT_SOFT		0x00000001  /* soft mount (hard is default) */
#define	NFSMNT_WSIZE		0x00000002  /* set write size */
#define	NFSMNT_RSIZE		0x00000004  /* set read size */
#define	NFSMNT_TIMEO		0x00000008  /* set initial timeout */
#define	NFSMNT_RETRANS		0x00000010  /* set number of request retries */
#define	NFSMNT_MAXGRPS		0x00000020  /* set maximum grouplist size */
#define	NFSMNT_INT		0x00000040  /* allow interrupts on hard mount */
#define	NFSMNT_NOCONN		0x00000080  /* Don't Connect the socket */
#define	NFSMNT_NQNFS		0x00000100  /* Use Nqnfs protocol */
#define	NFSMNT_NFSV3		0x00000200  /* Use NFS Version 3 protocol */
#define	NFSMNT_KERB		0x00000400  /* Use Kerberos authentication */
#define	NFSMNT_DUMBTIMR		0x00000800  /* Don't estimate rtt dynamically */
#define	NFSMNT_LEASETERM	0x00001000  /* set lease term (nqnfs) */
#define	NFSMNT_READAHEAD	0x00002000  /* set read ahead */
#define	NFSMNT_DEADTHRESH	0x00004000  /* set dead server retry thresh */
#define	NFSMNT_NOAC		0x00008000  /* disable attribute cache */
#define	NFSMNT_RDIRPLUS		0x00010000  /* Use Readdirplus for V3 */
#define	NFSMNT_READDIRSIZE	0x00020000  /* Set readdir size */

/* Flags valid only in mount syscall arguments */
#define NFSMNT_ACREGMIN		0x00040000  /* acregmin field valid */
#define NFSMNT_ACREGMAX		0x00080000  /* acregmax field valid */
#define NFSMNT_ACDIRMIN		0x00100000  /* acdirmin field valid */
#define NFSMNT_ACDIRMAX		0x00200000  /* acdirmax field valid */

/* Flags valid only in kernel */
#define	NFSMNT_INTERNAL		0xfffc0000  /* Bits set internally */
#define NFSMNT_HASWRITEVERF	0x00040000  /* Has write verifier for V3 */
#define NFSMNT_GOTPATHCONF	0x00080000  /* Got the V3 pathconf info */
#define NFSMNT_GOTFSINFO	0x00100000  /* Got the V3 fsinfo */
#define	NFSMNT_MNTD		0x00200000  /* Mnt server for mnt point */
#define	NFSMNT_DISMINPROG	0x00400000  /* Dismount in progress */
#define	NFSMNT_DISMNT		0x00800000  /* Dismounted */
#define	NFSMNT_SNDLOCK		0x01000000  /* Send socket lock */
#define	NFSMNT_WANTSND		0x02000000  /* Want above */
#define	NFSMNT_RCVLOCK		0x04000000  /* Rcv socket lock */
#define	NFSMNT_WANTRCV		0x08000000  /* Want above */
#define	NFSMNT_WAITAUTH		0x10000000  /* Wait for authentication */
#define	NFSMNT_HASAUTH		0x20000000  /* Has authenticator */
#define	NFSMNT_WANTAUTH		0x40000000  /* Wants an authenticator */
#define	NFSMNT_AUTHERR		0x80000000  /* Authentication error */

/*
 *  Arguments to mount MSDOS filesystems.
 */
struct msdosfs_args {
	char	*fspec;		/* blocks special holding the fs to mount */
	struct	export_args export_info;
				/* network export information */
	uid_t	uid;		/* uid that owns msdosfs files */
	gid_t	gid;		/* gid that owns msdosfs files */
	mode_t  mask;		/* mask to be applied for msdosfs perms */
	int	flags;		/* see below */
};

/*
 * Msdosfs mount options:
 */
#define	MSDOSFSMNT_SHORTNAME	0x01	/* Force old DOS short names only */
#define	MSDOSFSMNT_LONGNAME	0x02	/* Force Win'95 long names */
#define	MSDOSFSMNT_NOWIN95	0x04	/* Completely ignore Win95 entries */

/*
 * Arguments to mount ntfs filesystems
 */
struct ntfs_args {
	char	*fspec;			/* block special device to mount */
	struct	export_args export_info;/* network export information */
	uid_t	uid;			/* uid that owns ntfs files */
	gid_t	gid;			/* gid that owns ntfs files */
	mode_t	mode;			/* mask to be applied for ntfs perms */
	u_long	flag;			/* additional flags */
};

/*
 * ntfs mount options:
 */
#define	NTFS_MFLAG_CASEINS      0x00000001
#define	NTFS_MFLAG_ALLNAMES     0x00000002

/* Arguments to mount UDF file systems */
struct udf_args {
	char *fspec; /* Block special device to mount */
	u_int32_t lastblock; /* Special device last block */
};

/*
 * Arguments to mount tmpfs file systems
 */
#define TMPFS_ARGS_VERSION	1
struct tmpfs_args {
	int			ta_version;

	/* Size counters. */
	ino_t			ta_nodes_max;
	off_t			ta_size_max;

	/* Root node attributes. */
	uid_t			ta_root_uid;
	gid_t			ta_root_gid;
	mode_t			ta_root_mode;
};

/*
 * Arguments to mount fusefs filesystems
 */
struct fusefs_args {
	char *name;
	int fd;
	int max_read;
};

/*
 * file system statistics
 */

#define	MFSNAMELEN	16	/* length of fs type name, including nul */
#define	MNAMELEN	90	/* length of buffer for returned name */

/* per-filesystem mount options */
union mount_info {
	struct ufs_args ufs_args;
	struct mfs_args mfs_args;
	struct nfs_args nfs_args;
	struct iso_args iso_args;
	struct msdosfs_args msdosfs_args;
	struct ntfs_args ntfs_args;
	struct tmpfs_args tmpfs_args;
	char __align[160];	/* 64-bit alignment and room to grow */
};

/* new statfs structure with mount options and statvfs fields */
struct statfs {
	u_int32_t	f_flags;	/* copy of mount flags */
	u_int32_t	f_bsize;	/* file system block size */
	u_int32_t	f_iosize;	/* optimal transfer block size */

					/* unit is f_bsize */
	u_int64_t  	f_blocks;	/* total data blocks in file system */
	u_int64_t  	f_bfree;	/* free blocks in fs */
	int64_t  	f_bavail;	/* free blocks avail to non-superuser */

	u_int64_t 	f_files;	/* total file nodes in file system */
	u_int64_t  	f_ffree;	/* free file nodes in fs */
	int64_t  	f_favail;	/* free file nodes avail to non-root */

	u_int64_t  	f_syncwrites;	/* count of sync writes since mount */
	u_int64_t  	f_syncreads;	/* count of sync reads since mount */
	u_int64_t  	f_asyncwrites;	/* count of async writes since mount */
	u_int64_t  	f_asyncreads;	/* count of async reads since mount */

	fsid_t	   	f_fsid;		/* file system id */
	u_int32_t	f_namemax;      /* maximum filename length */
	uid_t	   	f_owner;	/* user that mounted the file system */
	u_int64_t  	f_ctime;	/* last mount [-u] time */

	char f_fstypename[MFSNAMELEN];	/* fs type name */
	char f_mntonname[MNAMELEN];	/* directory on which mounted */
	char f_mntfromname[MNAMELEN];	/* mounted file system */
	char f_mntfromspec[MNAMELEN];	/* special for mount request */
	union mount_info mount_info;	/* per-filesystem mount options */
};


/*
 * File system types.
 */
#define	MOUNT_FFS	"ffs"		/* UNIX "Fast" Filesystem */
#define	MOUNT_UFS	MOUNT_FFS	/* for compatibility */
#define	MOUNT_NFS	"nfs"		/* Network Filesystem */
#define	MOUNT_MFS	"mfs"		/* Memory Filesystem */
#define	MOUNT_MSDOS	"msdos"		/* MSDOS Filesystem */
#define	MOUNT_AFS	"afs"		/* Andrew Filesystem */
#define	MOUNT_CD9660	"cd9660"	/* ISO9660 (aka CDROM) Filesystem */
#define	MOUNT_EXT2FS	"ext2fs"	/* Second Extended Filesystem */
#define	MOUNT_NCPFS	"ncpfs"		/* NetWare Network File System */
#define	MOUNT_NTFS	"ntfs"		/* NTFS */
#define	MOUNT_UDF	"udf"		/* UDF */
#define	MOUNT_TMPFS	"tmpfs"		/* tmpfs */
#define	MOUNT_FUSEFS	"fuse"		/* FUSE */

/*
 * Structure per mounted file system.  Each mounted file system has an
 * array of operations and an instance record.  The file systems are
 * put on a doubly linked list.
 */
LIST_HEAD(vnodelst, vnode);

struct mount {
	TAILQ_ENTRY(mount) mnt_list;		/* mount list */
	SLIST_ENTRY(mount) mnt_dounmount;	/* unmount work queue */
	const struct vfsops *mnt_op;		/* operations on fs */
	struct vfsconf  *mnt_vfc;               /* configuration info */
	struct vnode	*mnt_vnodecovered;	/* vnode we mounted on */
	struct vnode    *mnt_syncer;            /* syncer vnode */
	struct vnodelst	mnt_vnodelist;		/* list of vnodes this mount */
	struct rwlock   mnt_lock;               /* mount structure lock */
	int		mnt_flag;		/* flags */
	struct statfs	mnt_stat;		/* cache of filesystem stats */
	void		*mnt_data;		/* private data */
};

/*
 * Mount flags.
 *
 * Unmount uses MNT_FORCE flag.
 */
#define	MNT_RDONLY	0x00000001	/* read only filesystem */
#define	MNT_SYNCHRONOUS	0x00000002	/* file system written synchronously */
#define	MNT_NOEXEC	0x00000004	/* can't exec from filesystem */
#define	MNT_NOSUID	0x00000008	/* don't honor setuid bits on fs */
#define	MNT_NODEV	0x00000010	/* don't interpret special files */
#define	MNT_NOPERM	0x00000020	/* don't enforce permission checks */
#define	MNT_ASYNC	0x00000040	/* file system written asynchronously */
#define	MNT_WXALLOWED	0x00000800	/* filesystem allows W|X mappings */

/*
 * exported mount flags.
 */
#define	MNT_EXRDONLY	0x00000080	/* exported read only */
#define	MNT_EXPORTED	0x00000100	/* file system is exported */
#define	MNT_DEFEXPORTED	0x00000200	/* exported to the world */
#define	MNT_EXPORTANON	0x00000400	/* use anon uid mapping for everyone */

/*
 * Flags set by internal operations.
 */
#define	MNT_LOCAL	0x00001000	/* filesystem is stored locally */
#define	MNT_QUOTA	0x00002000	/* quotas are enabled on filesystem */
#define	MNT_ROOTFS	0x00004000	/* identifies the root filesystem */

/*
 * Extra post 4.4BSD-lite2 mount flags.
 */
#define MNT_NOATIME	0x00008000	/* don't update access times on fs */

/*
 * Mask of flags that are visible to statfs()
 */
#define	MNT_VISFLAGMASK	0x0400ffff

#define	MNT_BITS \
    "\010\001RDONLY\002SYNCHRONOUS\003NOEXEC\004NOSUID\005NODEV\006NOPERM" \
    "\007ASYNC\010EXRDONLY\011EXPORTED\012DEFEXPORTED\013EXPORTANON" \
    "\014WXALLOWED\015LOCAL\016QUOTA\017ROOTFS\020NOATIME"

/*
 * filesystem control flags.
 */
#define	MNT_UPDATE	0x00010000	/* not a real mount, just an update */
#define	MNT_DELEXPORT	0x00020000	/* delete export host lists */
#define	MNT_RELOAD	0x00040000	/* reload filesystem data */
#define	MNT_FORCE	0x00080000	/* force unmount or readonly change */
#define MNT_WANTRDWR	0x02000000	/* want upgrade to read/write */
#define MNT_SOFTDEP     0x04000000      /* soft dependencies being done */
#define MNT_DOOMED	0x08000000	/* device behind filesystem is gone */

/*
 * Flags for various system call interfaces.
 *
 * waitfor flags to vfs_sync() and getfsstat()
 */
#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
#define MNT_LAZY	3	/* push data not written by filesystem syncer */

/*
 * Generic file handle
 */
struct fhandle {
	fsid_t	fh_fsid;	/* File system id of mount point */
	struct	fid fh_fid;	/* File sys specific id */
};
typedef struct fhandle	fhandle_t;

/*
 * Sysctl CTL_VFS definitions.
 *
 * Second level identifier specifies which filesystem. Second level
 * identifier VFS_GENERIC returns information about all filesystems.
 */
#define	VFS_GENERIC	0	/* generic filesystem information */
/*
 * Third level identifiers for VFS_GENERIC are given below; third
 * level identifiers for specific filesystems are given in their
 * mount specific header files.
 */
#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
#define VFS_CONF	2	/* struct: vfsconf for filesystem given
				   as next argument */
#define VFS_BCACHESTAT	3	/* struct: buffer cache statistics given 
				   as next argument */
#define	CTL_VFSGENCTL_NAMES { \
	{ 0, 0 }, \
	{ "maxtypenum", CTLTYPE_INT }, \
	{ "conf", CTLTYPE_NODE }, \
	{ "bcachestat", CTLTYPE_STRUCT } \
}

/*
 * Filesystem configuration information. One of these exists for each
 * type of filesystem supported by the kernel. These are searched at
 * mount time to identify the requested filesystem.
 */
struct vfsconf {
	const struct vfsops *vfc_vfsops; /* filesystem operations vector */
	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
	int	vfc_typenum;		/* historic filesystem type number */
	int	vfc_refcount;		/* number mounted of this type */
	int	vfc_flags;		/* permanent flags */
	struct	vfsconf *vfc_next;	/* next in list */
};

/* buffer cache statistics */
struct bcachestats {
	int64_t numbufs;		/* number of buffers allocated */
	int64_t numbufpages;		/* number of pages in buffer cache */
	int64_t numdirtypages; 		/* number of dirty free pages */
	int64_t numcleanpages; 		/* number of clean free pages */
	int64_t pendingwrites;		/* number of pending writes */
	int64_t pendingreads;		/* number of pending reads */
	int64_t numwrites;		/* total writes started */
	int64_t numreads;		/* total reads started */
	int64_t cachehits;		/* total reads found in cache */
	int64_t busymapped;		/* number of busy and mapped buffers */
	int64_t dmapages;		/* dma reachable pages in buffer cache */
	int64_t highpages;		/* pages above dma region */
	int64_t delwribufs;		/* delayed write buffers */
	int64_t kvaslots;		/* kva slots total */
	int64_t kvaslots_avail;		/* available kva slots */
};
#ifdef _KERNEL
extern struct bcachestats bcstats;
extern long buflowpages, bufhighpages, bufbackpages;
#define BUFPAGES_DEFICIT (((buflowpages - bcstats.numbufpages) < 0) ? 0 \
    : buflowpages - bcstats.numbufpages)
#define BUFPAGES_INACT (((bcstats.numcleanpages - buflowpages) < 0) ? 0 \
    : bcstats.numcleanpages - buflowpages)
extern int bufcachepercent;
extern void bufadjust(int);
struct uvm_constraint_range;
extern int bufbackoff(struct uvm_constraint_range*, long);

/*
 * Operations supported on mounted file system.
 */
struct nameidata;
struct mbuf;

extern int maxvfsconf;		/* highest defined filesystem type */
extern struct vfsconf *vfsconf;	/* head of list of filesystem types */

struct vfsops {
	int	(*vfs_mount)(struct mount *mp, const char *path,
				    void *data,
				    struct nameidata *ndp, struct proc *p);
	int	(*vfs_start)(struct mount *mp, int flags,
				    struct proc *p);
	int	(*vfs_unmount)(struct mount *mp, int mntflags,
				    struct proc *p);
	int	(*vfs_root)(struct mount *mp, struct vnode **vpp);
	int	(*vfs_quotactl)(struct mount *mp, int cmds, uid_t uid,
				    caddr_t arg, struct proc *p);
	int	(*vfs_statfs)(struct mount *mp, struct statfs *sbp,
				    struct proc *p);
	int	(*vfs_sync)(struct mount *mp, int waitfor,
				    struct ucred *cred, struct proc *p);
	int	(*vfs_vget)(struct mount *mp, ino_t ino,
				    struct vnode **vpp);
	int	(*vfs_fhtovp)(struct mount *mp, struct fid *fhp,
				     struct vnode **vpp);
	int	(*vfs_vptofh)(struct vnode *vp, struct fid *fhp);
	int	(*vfs_init)(struct vfsconf *);
	int     (*vfs_sysctl)(int *, u_int, void *, size_t *, void *,
				     size_t, struct proc *);
	int	(*vfs_checkexp)(struct mount *mp, struct mbuf *nam,
				    int *extflagsp, struct ucred **credanonp);
};

#define VFS_MOUNT(MP, PATH, DATA, NDP, P) \
	(*(MP)->mnt_op->vfs_mount)(MP, PATH, DATA, NDP, P)
#define VFS_START(MP, FLAGS, P)	  (*(MP)->mnt_op->vfs_start)(MP, FLAGS, P)
#define VFS_UNMOUNT(MP, FORCE, P) (*(MP)->mnt_op->vfs_unmount)(MP, FORCE, P)
#define VFS_ROOT(MP, VPP)	  (*(MP)->mnt_op->vfs_root)(MP, VPP)
#define VFS_QUOTACTL(MP,C,U,A,P)  (*(MP)->mnt_op->vfs_quotactl)(MP, C, U, A, P)
#define VFS_STATFS(MP, SBP, P)	  (*(MP)->mnt_op->vfs_statfs)(MP, SBP, P)
#define VFS_SYNC(MP, WAIT, C, P)  (*(MP)->mnt_op->vfs_sync)(MP, WAIT, C, P)
#define VFS_VGET(MP, INO, VPP)	  (*(MP)->mnt_op->vfs_vget)(MP, INO, VPP)
#define VFS_FHTOVP(MP, FIDP, VPP) \
	(*(MP)->mnt_op->vfs_fhtovp)(MP, FIDP, VPP)
#define	VFS_VPTOFH(VP, FIDP)	  (*(VP)->v_mount->mnt_op->vfs_vptofh)(VP, FIDP)
#define VFS_CHECKEXP(MP, NAM, EXFLG, CRED) \
	(*(MP)->mnt_op->vfs_checkexp)(MP, NAM, EXFLG, CRED)


#include <net/radix.h>
#include <sys/socket.h>		/* XXX for AF_MAX */

/*
 * Network address lookup element
 */
struct netcred {
	struct	radix_node netc_rnodes[2];
	int	netc_exflags;
	struct	ucred netc_anon;
};

/*
 * Network export information
 */
struct netexport {
	struct	netcred ne_defexported;		/* Default export */
	struct	radix_node_head *ne_rtable_inet;/* Individual exports */
};

/*
 * exported vnode operations
 */
int	vfs_busy(struct mount *, int);
#define VB_READ		0x01
#define VB_WRITE	0x02
#define VB_NOWAIT	0x04	/* immediately fail on busy lock */
#define VB_WAIT		0x08	/* sleep fail on busy lock */

int     vfs_isbusy(struct mount *);
int     vfs_mount_foreach_vnode(struct mount *, int (*func)(struct vnode *,
				    void *), void *);
void	vfs_getnewfsid(struct mount *);
struct	mount *vfs_getvfs(fsid_t *);
int	vfs_mountedon(struct vnode *);
int	vfs_rootmountalloc(char *, char *, struct mount **);
void	vfs_unbusy(struct mount *);
void	vfs_unmountall(void);
extern	TAILQ_HEAD(mntlist, mount) mountlist;

struct	mount *getvfs(fsid_t *);	    /* return vfs given fsid */
					    /* process mount export info */
int	vfs_export(struct mount *, struct netexport *, struct export_args *);
					    /* lookup host in fs export list */
struct	netcred *vfs_export_lookup(struct mount *, struct netexport *,
	    struct mbuf *);
int	vfs_allocate_syncvnode(struct mount *);
int	speedup_syncer(void);

int	vfs_syncwait(int);	/* sync and wait for complete */
void	vfs_shutdown(void);	/* unmount and sync file systems */
int	dounmount(struct mount *, int, struct proc *);
void	vfsinit(void);
int	vfs_register(struct vfsconf *);
int	vfs_unregister(struct vfsconf *);
#else /* _KERNEL */
__BEGIN_DECLS
int	fstatfs(int, struct statfs *);
int	getfh(const char *, fhandle_t *);
int	getfsstat(struct statfs *, size_t, int);
int	getmntinfo(struct statfs **, int);
int	mount(const char *, const char *, int, void *);
int	statfs(const char *, struct statfs *);
int	unmount(const char *, int);
#if __BSD_VISIBLE
struct stat;
int	fhopen(const fhandle_t *, int);
int	fhstat(const fhandle_t *, struct stat *);
int	fhstatfs(const fhandle_t *, struct statfs *);
#endif /* __BSD_VISIBLE */
__END_DECLS
#endif /* _KERNEL */
#endif /* !_SYS_MOUNT_H_ */
@


1.128
log
@Remove the unused olddp parameter from function dounmount().
OK mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.127 2016/09/10 16:53:30 natano Exp $	*/
d350 1
@


1.127
log
@Add a noperm mount flag for FFS to be used for building release sets
without root privileges. This is only the kernel/mount flag; additional
work in the build Makefile's will be necessary such that the files in
$DESTDIR are created with correct permissions.

tedu couldn't find anything wrong with it in a quick review
idea & ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.126 2016/05/27 19:45:04 deraadt Exp $	*/
d605 1
a605 1
int	dounmount(struct mount *, int, struct proc *, struct vnode *);
@


1.126
log
@W^X violations are no longer permitted by default.  A kernel log message
is generated, and mprotect/mmap return ENOTSUP.  If the sysctl(8) flag
kern.wxabort is set then a SIGABRT occurs instead, for gdb use or coredump
creation.

W^X violating programs can be permitted on a ffs/nfs filesystem-basis,
using the "wxallowed" mount option.  One day far in the future
upstream software developers will understand that W^X violations are a
tremendously risky practice and that style of programming will be
banished outright.  Until then, we recommend most users need to use the
wxallowed option on their /usr/local filesystem.  At least your other
filesystems don't permit such programs.

ok jca kettenis mlarkin natano
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.125 2016/05/25 13:31:44 deraadt Exp $	*/
d371 1
d401 1
a401 1
    "\010\001RDONLY\002SYNCHRONOUS\003NOEXEC\004NOSUID\005NODEV" \
d403 1
a403 1
    "\014EXKERB\015LOCAL\016QUOTA\017ROOTFS"
@


1.125
log
@MNT_EXKERB bit is unused
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.124 2016/05/21 18:11:36 natano Exp $	*/
d372 1
@


1.124
log
@Remove the -x flag from mount_msdos and always assume the execute bit
for readable directories, while making it subject to the mask option
(-m in mount_msdos), so it is still possible to mount with
non-executable directories, but with semantics that are easier to
comprehend.

This makes directory listings with default mount options work again.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.123 2016/02/27 18:50:38 natano Exp $	*/
a379 1
#define	MNT_EXKERB	0x00000800	/* exported with Kerberos uid mapping */
@


1.123
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.122 2016/02/26 08:56:10 natano Exp $	*/
a220 1
#define MSDOSFSMNT_ALLOWDIRX	0x10	/* dir is mode +x if r */
@


1.122
log
@Convert mnt_maxsymlinklen to unsigned.

This allows to remove some truncating casts in symlink handling code.
Also, validate fs_maxsymlinklen in the superblock at mount time and on
fsck to make sure we don't use bogus data.

discussion & ok millert@@, stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.121 2014/09/08 01:47:06 guenther Exp $	*/
a357 1
	unsigned int	mnt_maxsymlinklen;	/* max size of short symlink */
@


1.121
log
@Delete procfs; it's always had races and is now unused: no one noticed for
months that I broke it before the 5.5 release.

confirmed as not being required by ports by sthen@@, ajacoutot@@, dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.120 2014/06/04 07:58:14 claudio Exp $	*/
d358 1
a358 1
	int		mnt_maxsymlinklen;	/* max size of short symlink */
@


1.120
log
@While it may be smart to use the radix tree for exports it is not OK to
use the domain specific tree initialisation method for this since that one
is multipath enabled and assumes that the radix node is part of a struct
rtentry. This code uses a different struct and so the multipath modifies
wrong fields and breaks stuff in mysterious ways.
Since we only support AF_INET here anyway simplify the code and only have
one radix_node_head pointer instead of AF_MAX ones.
Fixes NFS server issues reported by rpe@@, OK rpe@@, guenther@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.119 2014/05/20 13:32:22 syl Exp $	*/
a264 14
 * Arguments to mount procfs filesystems
 */
struct procfs_args {
	int version;
	int flags;
};

/*
 * procfs mount options:
 */
#define PROCFS_ARGSVERSION      1
#define PROCFSMNT_LINUXCOMPAT   0x01

/*
a285 1
	struct procfs_args procfs_args;
a332 1
#define	MOUNT_PROCFS	"procfs"	/* /proc Filesystem */
@


1.119
log
@Add -o max_read=XXX support in fuse. This is needed by usmb to have a
working read() and write().

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.118 2014/03/24 00:19:48 guenther Exp $	*/
d587 2
a588 2
	struct	netcred ne_defexported;		      /* Default export */
	struct	radix_node_head *ne_rtable[AF_MAX+1]; /* Individual exports */
@


1.118
log
@Split the API: struct ucred remains the kernel internal structure while
struct xucred becomes the structure for syscalls (mount(2) and nfssvc(2)).

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.117 2013/12/01 16:40:56 krw Exp $	*/
a282 1
	char *url;
d284 1
a284 1
	int flags;
@


1.117
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.116 2013/09/24 09:20:12 espie Exp $	*/
d65 1
a65 1
	struct	ucred ex_anon;		/* mapping for anonymous user */
@


1.116
log
@a bit more tmpfs scaffolding (still not active, no kernel change)
reduces the actual diff needed, and allows one to build mount_tmpfs
without reinstalling the includes.

(still awaiting review on the uvm bits)

okay krw@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.115 2013/08/14 05:26:14 guenther Exp $	*/
d367 1
a367 1
	CIRCLEQ_ENTRY(mount) mnt_list;		/* mount list */
d610 1
a610 1
extern	CIRCLEQ_HEAD(mntlist, mount) mountlist;
@


1.115
log
@The last user of the old __tfork() was updated to the current one,
so COMPAT_O51 can go.  The complete ABI role means COMPAT_O53 can
be removed as well.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.114 2013/07/09 15:37:43 beck Exp $	*/
d248 17
d304 1
d356 1
@


1.114
log
@back out the cache flipper temporarily to work out of tree.
will come back soon.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.113 2013/06/21 21:30:38 syl Exp $	*/
a320 34

#ifdef _KERNEL
/* COMPAT_O53 version without f_mntfromspec and smaller f_ctime */
struct statfs53 {
	u_int32_t	f_flags;	/* copy of mount flags */
	u_int32_t	f_bsize;	/* file system block size */
	u_int32_t	f_iosize;	/* optimal transfer block size */

					/* unit is f_bsize */
	u_int64_t  	f_blocks;	/* total data blocks in file system */
	u_int64_t  	f_bfree;	/* free blocks in fs */
	int64_t  	f_bavail;	/* free blocks avail to non-superuser */

	u_int64_t 	f_files;	/* total file nodes in file system */
	u_int64_t  	f_ffree;	/* free file nodes in fs */
	int64_t  	f_favail;	/* free file nodes avail to non-root */

	u_int64_t  	f_syncwrites;	/* count of sync writes since mount */
	u_int64_t  	f_syncreads;	/* count of sync reads since mount */
	u_int64_t  	f_asyncwrites;	/* count of async writes since mount */
	u_int64_t  	f_asyncreads;	/* count of async reads since mount */

	fsid_t	   	f_fsid;		/* file system id */
	u_int32_t	f_namemax;      /* maximum filename length */
	uid_t	   	f_owner;	/* user that mounted the file system */
	u_int32_t  	f_ctime;	/* last mount [-u] time */
	u_int32_t	f_spare[3];	/* spare for later */

	char f_fstypename[MFSNAMELEN];	/* fs type name */
	char f_mntonname[MNAMELEN];	/* directory on which mounted */
	char f_mntfromname[MNAMELEN];	/* mounted file system */
	union mount_info mount_info;	/* per-filesystem mount options */
};
#endif /* _KERNEL */
@


1.113
log
@Make fuse device clonable.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.112 2013/06/11 19:01:20 beck Exp $	*/
a530 1
extern int bufhigh(int);
@


1.112
log
@High memory page flipping for the buffer cache.

This change splits the buffer cache free lists into lists of dma reachable
buffers and high memory buffers based on the ranges returned by pmemrange.
Buffers move from dma to high memory as they age, but are flipped to dma
reachable memory if IO is needed to/from and high mem buffer. The total
amount of buffers  allocated is now bufcachepercent of both the dma and
the high memory region.

This change allows the use of large buffer caches on amd64 using more than
4 GB of memory

ok tedu@@ krw@@ - testing by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.111 2013/06/03 15:56:01 tedu Exp $	*/
d267 1
a267 1
	dev_t dev;
@


1.111
log
@tabs after defines, not spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.110 2013/06/03 15:54:48 tedu Exp $	*/
d531 1
@


1.110
log
@changes for isc fuse support. not enabled. ok beck deraadt.
from Sylvestre Gallon ccna.syl gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.109 2013/04/15 15:32:19 jsing Exp $	*/
d372 1
a372 1
#define MOUNT_FUSEFS	"fuse"		/* FUSE */
@


1.109
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.108 2012/09/05 17:01:06 deraadt Exp $	*/
d261 9
d372 1
@


1.108
log
@struct omount can die; ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.107 2012/08/23 06:12:49 deraadt Exp $	*/
d304 33
d345 2
@


1.107
log
@kill nnpfs dead
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.106 2011/09/19 14:48:04 beck Exp $	*/
a310 21
};

/* old (pre-2.6) statfs structure */
struct ostatfs {
	short	f_type;			/* type of file system (unused; zero) */
	short	f_flags;		/* copy of mount flags */
	long	f_bsize;		/* fundamental file system block size */
	long	f_iosize;		/* optimal transfer block size */
	long	f_blocks;		/* total data blocks in file system */
	long	f_bfree;		/* free blocks in fs */
	long	f_bavail;		/* free blocks avail to non-superuser */
	long	f_files;		/* total file nodes in file system */
	long	f_ffree;		/* free file nodes in fs */
	fsid_t	f_fsid;			/* file system id */
	uid_t	f_owner;		/* user that mounted the file system */
	long	f_syncwrites;		/* count of sync writes since mount */
	long	f_asyncwrites;		/* count of async writes since mount */
	long	f_spare[2];		/* spare for later */
	char	f_fstypename[MFSNAMELEN]; /* fs type name */
	char	f_mntonname[MNAMELEN];	  /* directory on which mounted */
	char	f_mntfromname[MNAMELEN];  /* mounted file system */
@


1.106
log
@clean up buffer cache statistics somewhat to
remove some now useless statistics, and add some
relevant ones regarding kva usage in the cache.

make systat io and show bcstats in ddb both show
these counters.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.105 2011/07/06 20:50:05 beck Exp $	*/
a346 2
#define	MOUNT_XFS	"nnpfs"		/* nnpfs (temp) */
#define	MOUNT_NNPFS	"nnpfs"		/* nnpfs */
@


1.105
log
@the rest of the uvm commit - I commited from uvm instead of sys
(part missed from previous commit)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.104 2011/07/06 00:11:57 beck Exp $	*/
a485 1
	int64_t freebufs;		/* number of free buffers */
a486 1
	int64_t numfreepages; 		/* number of free pages */
d497 3
@


1.104
log
@add a couple of fields needed for buffer flipping, and change systat to
show useful info in systat io instead of goo
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.103 2011/04/05 18:51:26 thib Exp $	*/
d509 2
a510 1
extern int bufbackoff(void);
@


1.103
log
@Remove portalfs.

While it is a terribly cool idea, it's just awful and since noone has stepped
up to the plate to keep it up with the current vop state, retire it to the
attic.

ok krw@@, deraadt@@, guenther@@, miod@@.
comments from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.99 2009/10/14 17:53:30 beck Exp $	*/
d497 2
@


1.102
log
@collapse a few _KERNEL ifdefs and move some
definitions around to allow for this.

kill a protection for a forward decleration
and __STDC__ protections for others.

OK guenther@@
@
text
@a341 1
#define	MOUNT_PORTAL	"portal"	/* Portal Filesystem */
@


1.101
log
@nuke o43statfs as it is unused.

ok dlg@@, blambert@@, mikeb@@, otto@@
@
text
@a158 1
#ifndef _KERNEL
a159 1
#endif /* ! _KERNEL */
a174 1
#ifdef _KERNEL /* Coming soon to a system call near you! */
a175 1
#endif /* _KERNEL */
d429 18
a508 1
#endif
a512 2
#ifdef _KERNEL
#ifdef __STDC__
a514 1
#endif
a559 10
#endif /* _KERNEL */

/*
 * Flags for various system call interfaces.
 *
 * waitfor flags to vfs_sync() and getfsstat()
 */
#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
#define MNT_LAZY	3	/* push data not written by filesystem syncer */
a560 8
/*
 * Generic file handle
 */
struct fhandle {
	fsid_t	fh_fsid;	/* File system id of mount point */
	struct	fid fh_fid;	/* File sys specific id */
};
typedef struct fhandle	fhandle_t;
a561 1
#ifdef _KERNEL
a580 1
#endif /* _KERNEL */
a581 1
#ifdef _KERNEL
a617 5

#ifndef _SYS_STAT_H_
struct stat;
#endif

d627 1
a631 1

a632 1

@


1.100
log
@makefstype was only used in ported from freebsd filesystems.  fix them
and remove the function.  ok thib
@
text
@a316 22
/* old (pre-4.3) statfs structure with mount options */
struct o43statfs {
	u_int32_t  f_flags;		/* copy of mount flags */
	int32_t    f_bsize;		/* fundamental file system block size */
	u_int32_t  f_iosize;		/* optimal transfer block size */
	u_int32_t  f_blocks;		/* total data blocks in file system */
	u_int32_t  f_bfree;		/* free blocks in fs */
	int32_t    f_bavail;		/* free blocks avail to non-superuser */
	u_int32_t  f_files;		/* total file nodes in file system */
	u_int32_t  f_ffree;		/* free file nodes in fs */
	fsid_t	   f_fsid;		/* file system id */
	uid_t	   f_owner;		/* user that mounted the file system */
	u_int32_t  f_syncwrites;	/* count of sync writes since mount */
	u_int32_t  f_asyncwrites;	/* count of async writes since mount */
	u_int32_t  f_ctime;		/* last mount [-u] time */
	u_int32_t  f_spare[3];		/* spare for later */
	char	   f_fstypename[MFSNAMELEN]; /* fs type name */
	char	   f_mntonname[MNAMELEN];    /* directory on which mounted */
	char	   f_mntfromname[MNAMELEN];  /* mounted file system */
	union mount_info mount_info;	    /* per-filesystem mount options */
};

@


1.99
log
@Fix buffer cache backoff in the page daemon - deal with inactive pages to
more correctly reflect the new state of the world - that is - how many pages
can be cheaply reclaimed - which now includes clean buffer cache pages.

This change fixes situations where people would be running with a large bufcachepercent, and still notice swapping without the buffer cache backing off.

ok oga@@, testing by many on tech@@ and others. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.98 2009/08/09 14:37:46 art Exp $	*/
a645 1
long	makefstype(char *);
@


1.98
log
@Keep track of number of currently mapped and B_BUSY buffers. beck@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.97 2009/08/08 15:04:43 beck Exp $	*/
d512 2
@


1.97
log
@two things:
1) fix buffer cache low water mark to allow for extremely low memory machines
without dying
2) Add "show bcstats" to ddb to allow for looking at the buffer cache statistics in ddb

ok art@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.95 2009/06/15 17:01:26 beck Exp $	*/
d505 1
@


1.96
log
@
Dynamic buffer cache support - a re-commit of what was backed out
after c2k9

allows buffer cache to be extended and grow/shrink dynamically

tested by many, ok oga@@, "why not just commit it" deraadt@@
@
text
@a506 1
#define BACKPAGES 100
d508 1
a508 1
extern long buflowpages, bufhighpages;
@


1.95
log
@Back out all the buffer cache changes I committed during c2k9. This reverts three
commits:

1) The sysctl allowing bufcachepercent to be changed at boot time.
2) The change moving the buffer cache hash chains to a red-black tree
3) The dynamic buffer cache (Which depended on the earlier too).

ok on the backout from marco and todd
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.94 2009/06/05 04:29:14 beck Exp $	*/
d507 1
d509 6
a514 1
#define BUFPAGES_DEFICIT (bufpages - bcstats.numbufpages)
@


1.94
log
@Dynamic buffer cache sizing.

This commit won't change the default behaviour of the system unless the
buffer cache size is increased with sysctl kern.bufcachepercent. By default
our buffer cache is 10% of memory, which with this commit is now treated
as a low water mark.  If the buffer cache size is increased, the new size
is treated as a high water mark and the buffer cache is permitted to grow
to that percentage of memory.

If the page daemon is invoked, the page daemon will ask the buffer cache
to relenquish pages. if the buffer cache has more than the low water mark it
will relenquish pages allowing them to be consumed by uvm. after a short
period the buffer cache will attempt to re-grow back to the high water mark.

This permits the use of a large buffer cache without penalizing the available
memory for other purposes.

Above the low water mark the buffer cache remains entirely subservient to
the page daemon, so if uvm requires pages, the buffer cache will abandon
them.

ok art@@ thib@@ oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.93 2009/06/03 21:30:20 beck Exp $	*/
a506 1
#define BACKPAGES 100
d508 1
a508 6
extern long buflowpages, bufhighpages;
#define BUFPAGES_DEFICIT (((buflowpages - bcstats.numbufpages) < 0) ? 0 \
    : buflowpages - bcstats.numbufpages)
extern int bufcachepercent;
extern void bufadjust(int);
extern int bufbackoff(void);
@


1.93
log
@add kern.bufcachepercent sysctl to allow adjusting the buffer cache
size on a running system.
ok art@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.92 2009/06/03 14:45:55 jj Exp $	*/
d507 1
d509 3
a511 1
#define BUFPAGES_DEFICIT (bufpages - bcstats.numbufpages)
d514 1
@


1.92
log
@Arla client rename from xfs to nnpfs for later upgrades. Tested on various arches. ok todd@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.91 2008/07/22 08:05:02 thib Exp $	*/
d509 2
@


1.91
log
@change the bcachestats structures members to int64_t's and do the
printing in systat with the new print_fld_ssize() function.

"same diff I wrote" deraadt@@
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.90 2008/07/05 12:56:52 thib Exp $	*/
d374 2
a375 1
#define	MOUNT_XFS	"xfs"		/* xfs */
@


1.90
log
@
bumb the bcachestats and the nchstats counters from long
to u_int64_t's; add two new counters to nchstats that will
be used in the future.

ok art@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.89 2008/07/02 15:21:33 art Exp $	*/
d493 11
a503 11
	u_int64_t numbufs;		/* number of buffers allocated */
	u_int64_t freebufs;		/* number of free buffers */
	u_int64_t numbufpages;		/* number of pages in buffer cache */
	u_int64_t numfreepages; 	/* number of free pages */
	u_int64_t numdirtypages; 	/* number of dirty free pages */
	u_int64_t numcleanpages; 	/* number of clean free pages */
	u_int64_t pendingwrites;	/* number of pending writes */
	u_int64_t pendingreads;		/* number of pending reads */
	u_int64_t numwrites;		/* total writes started */
	u_int64_t numreads;		/* total reads started */
	u_int64_t cachehits;		/* total reads found in cache */
@


1.89
log
@Make the pagedaemon a bit happier.
1. When checking if the pagedaemon should be awakened and to see how
   much work it should do, consider the buffer cache deficit
   (how much pages the buffer cache can eat max vs. how much it has
   now) as pages that are not free. They are actually still usable by
   the allocator, but the presure on the pagedaemon is increased when
   we starting to chew into the memory that the buffer cache wants to
   use.
2. Remove the stupid 512kB limit of how much memory should be our
   free target. That maybe made sense on 68k, but on modern systems
   512k is just a joke. Keep it at 3% of physical memory just like
   it was meant to be.
3. When doing allocations for the pagedaemon, always let it use the
   reserve. the whole UVM_OBJ_IS_KERN_OBJECT is silly and doesn't
   work in most cases anyway. We still don't have a reserve for
   the pagedaemon in the km_page allocator, but this seems to help
   enough. (yes, there are still bad cases in that code and the comment
   is only half-true, the whole section needs a massage, but that will
   happen later, this diff only touches pagedaemon parts)

Testing by many, prodded by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.88 2008/06/13 01:59:45 rainer Exp $	*/
d493 11
a503 11
	long numbufs; 		/* number of buffers allocated */
	long freebufs;		/* number of free buffers */
	long numbufpages; 	/* number of pages in buffer cache */
	long numfreepages; 	/* number of free pages */
	long numdirtypages; 	/* number of dirty free pages */
	long numcleanpages; 	/* number of clean free pages */
	long pendingwrites;	/* number of pending writes */
	long pendingreads;	/* number of pending reads */
	long numwrites;		/* total writes started */
	long numreads;		/* total reads started */
	long cachehits;		/* total reads found in cache */
@


1.88
log
@Delete vfs_bufstats() leftovers and unbreak compile with -DDEBUG

Ok reyk@@, "kill kill kill" thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.87 2008/06/12 06:58:40 deraadt Exp $	*/
d507 1
@


1.87
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.85 2008/06/10 20:14:37 beck Exp $	*/
a638 1
void	vfs_bufstats(void);
@


1.86
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.84 2008/05/07 14:09:36 thib Exp $	*/
d468 2
d473 2
a474 1
	{ "conf", CTLTYPE_NODE } \
d490 18
@


1.85
log
@
Buffer cache revamp

1) remove multiple size queues, introduced as a stopgap.
2) decouple pages containing data from their mappings
3) only keep buffers mapped when they actually have to be mapped
  (right now, this is when buffers are B_BUSY)
4) New functions to make a buffer busy, and release the busy flag
   (buf_acquire and buf_release)
5) Move high/low water marks and statistics counters into a structure
6) Add a sysctl to retrieve buffer cache statistics

Tested in several variants and beat upon by bob and art for a year. run
accidentally on henning's nfs server for a few months...

ok deraadt@@, krw@@, art@@ - who promises to be around to deal with any fallout
@
text
@a467 2
#define VFS_BCACHESTAT	3	/* struct: buffer cache statistics given 
				   as next argument */
d471 1
a471 2
	{ "conf", CTLTYPE_NODE }, \
	{ "bcachestat", CTLTYPE_STRUCT } \
a486 18

/* buffer cache statistics */
struct bcachestats {
	long numbufs; 		/* number of buffers allocated */
	long freebufs;		/* number of free buffers */
	long numbufpages; 	/* number of pages in buffer cache */
	long numfreepages; 	/* number of free pages */
	long numdirtypages; 	/* number of dirty free pages */
	long numcleanpages; 	/* number of clean free pages */
	long pendingwrites;	/* number of pending writes */
	long pendingreads;	/* number of pending reads */
	long numwrites;		/* total writes started */
	long numreads;		/* total reads started */
	long cachehits;		/* total reads found in cache */
};
#ifdef _KERNEL
extern struct bcachestats bcstats;
#endif
@


1.84
log
@oops, forgot to remove vfc_mountroot from vfsconf for real.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.83 2008/05/06 17:19:40 thib Exp $	*/
d468 2
d473 2
a474 1
	{ "conf", CTLTYPE_NODE } \
d490 18
@


1.83
log
@retire vfs_mountroot();

setroot() is now (and has been) responsible for setting
the mountroot function pointer "to the right thing", or
failing todo that, to ffs_mountroot;

based on a discussion/diff from deraadt@@.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.82 2008/03/16 19:42:57 otto Exp $	*/
a484 1
	int	(*vfc_mountroot)(void);	/* if != NULL, routine to mount root */
@


1.82
log
@Widen some struct statfs fields to support large filesystem stata
and add some to be able to support statvfs(2). Do the compat dance
to provide backward compatibility.  ok thib@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.81 2007/06/01 05:37:14 deraadt Exp $	*/
a599 1
int	vfs_mountroot(void);
@


1.81
log
@remove crufty adosfs.  everytime we try to change a vfs layer interface,
adosfs has the issue and in an entirely different way.  noone uses this
code so this is hte best way to handle the problem
diff from pedro who went to sleep but we need to move ahead; ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.80 2007/05/26 20:26:51 pedro Exp $	*/
d285 1
a285 1
/* new statfs structure with mount options */
d287 32
@


1.80
log
@Dynamic buffer cache. Initial diff from mickey@@, okay art@@ beck@@ toby@@
deraadt@@ dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.79 2007/04/24 12:10:28 millert Exp $	*/
a227 12
 * Arguments to mount amigados filesystems.
 */
struct adosfs_args {
	char	*fspec;		/* blocks special holding the fs to mount */
	struct	export_args export_info;
				/* network export information */
	uid_t	uid;		/* uid that owns adosfs files */
	gid_t	gid;		/* gid that owns adosfs files */
	mode_t	mask;		/* mask to be applied for adosfs perms */
};

/*
a280 1
	struct adosfs_args adosfs_args;
a339 1
#define	MOUNT_ADOSFS	"adosfs"	/* AmigaDOS Filesystem */
@


1.79
log
@Fix mounting of ffs2 via "mount -a".  ffs2 is not separate from ffs
and should not have its own MOUNT_XXX define.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.78 2007/03/21 13:44:04 pedro Exp $	*/
a601 1
#ifdef DEBUG
a602 1
#endif
@


1.78
log
@Add support for mounting arbitrary sessions, from Enache Adrian
OK deraadt@@ mjc@@ canacar@@ krw@@, with much input from Enache himself
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.77 2006/12/15 03:04:24 krw Exp $	*/
a344 1
#define	MOUNT_FFS2	"ffs2"		/* UNIX "Fast" Filesystem, version 2 */
@


1.77
log
@Nuke GEMDOSFS. Unused part of unused atari port. Simplifies
MSDOSFS code. Eliminates -G option to mount_msdos.

Nit detection by gwk@@, tom@@, jmc@@.

ok weingart@@ tom@@ thib@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.76 2006/09/22 14:23:03 pedro Exp $	*/
d97 1
d99 6
a104 4
#define	ISOFSMNT_NORRIP	0x00000001	/* disable Rock Ridge Ext.*/
#define	ISOFSMNT_GENS	0x00000002	/* enable generation numbers */
#define	ISOFSMNT_EXTATT	0x00000004	/* enable extended attributes */
#define	ISOFSMNT_NOJOLIET 0x00000008	/* disable Joliet Ext.*/
@


1.76
log
@Unplug LFS from VFS
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.75 2006/07/11 21:17:58 mickey Exp $	*/
a221 1
#define	MSDOSFSMNT_GEMDOSFS	0x08	/* This is a gemdos-flavour */
@


1.75
log
@add mount/vnode/buf and softdep printing commands; tested on a few archs and will make pedro happy too (;
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.74 2006/07/11 16:24:09 pedro Exp $	*/
a347 1
#define	MOUNT_LFS	"lfs"		/* Log-based Filesystem */
@


1.74
log
@Make the mounting process pass a hint to the kernel of where to find the VAT
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.73 2006/06/25 15:01:54 sturm Exp $	*/
d418 5
@


1.73
log
@rename vfs_busy() flags VB_UMIGNORE/VB_UMWAIT to VB_NOWAIT/VB_WAIT

requested by and ok pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.72 2006/06/14 20:01:50 sturm Exp $	*/
d255 1
a255 3
/*
 * Arguments to mount UDF filesystems.
 */
d257 2
a258 1
	char	*fspec;			/* block special device to mount */
@


1.72
log
@move vfs_busy() to rwlocks and properly hide the locking api from vfs

ok tedu, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.71 2006/05/28 03:55:56 pedro Exp $	*/
d569 2
a570 2
#define VB_UMIGNORE	0x04	/* ignore unmount in progress */
#define VB_UMWAIT	0x08	/* wait for unmount to finish */
@


1.71
log
@Nuke unused VFSGEN_MAXID define
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.70 2006/04/30 14:20:07 sturm Exp $	*/
d43 1
a43 1
#include <sys/lock.h>
d375 1
a375 1
	struct lock     mnt_lock;               /* mount structure lock */
d567 5
@


1.70
log
@remove the simplelock argument from vfs_busy() which is currently not
used and will never be used this way in VFS

requested by and ok pedro, ok krw, biorn
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.69 2006/04/19 11:55:55 pedro Exp $	*/
a445 2
#define	VFSGEN_MAXID	3	/* max number of vfs.generic ids */

@


1.69
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.68 2006/03/31 13:05:23 pedro Exp $	*/
d568 1
a568 1
int	vfs_busy(struct mount *, int, struct simplelock *);
@


1.68
log
@Add MOUNT_FFS2
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.67 2005/12/13 00:35:23 millert Exp $	*/
a579 1
extern	struct simplelock mountlist_slock;
@


1.67
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.66 2005/12/06 20:18:57 pedro Exp $	*/
d344 1
@


1.66
log
@Remove fdescfs
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.65 2005/11/30 10:35:08 pedro Exp $	*/
d38 1
a601 2
#include <sys/cdefs.h>

d614 1
a614 1
#if !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE)
d618 1
a618 1
#endif /* !_POSIX_C_SOURCE */
@


1.65
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.64 2005/11/24 12:08:16 pedro Exp $	*/
a347 1
#define	MOUNT_FDESC	"fdesc"		/* File Descriptor Filesystem */
@


1.64
log
@Remove kernfs, okay deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.63 2005/10/25 18:03:29 pedro Exp $	*/
d567 1
a567 1
int	vfs_busy(struct mount *, int, struct simplelock *, struct proc *);
d576 1
a576 1
void	vfs_unbusy(struct mount *, struct proc *);
@


1.63
log
@kill unused definition, okay krw@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.62 2005/07/03 20:14:00 drahn Exp $	*/
a349 1
#define	MOUNT_KERNFS	"kernfs"	/* Kernel Information Filesystem */
@


1.62
log
@Extended Attributes was a piece to get to ACLs, however ACLs have not
been worked on, so EA is pointless. Also the code is not enabled
in GENERIC so it is not being tested or maintained.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.61 2005/05/26 00:33:45 pedro Exp $	*/
a347 1
#define	MOUNT_LOFS	"lofs"		/* Loopback filesystem */
@


1.61
log
@RIP stackable filesystems, ok marius@@ tedu@@, discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.60 2005/05/24 05:34:54 pedro Exp $	*/
a506 4
	int     (*vfs_extattrctl)(struct mount *mp, int cmd,
				    struct vnode *filename_vp,
				    int attrnamespace, const char *attrname,
				    struct proc *p);
a522 12
#define VFS_EXTATTRCTL(MP, C, FN, NS, N, P) \
	(*(MP)->mnt_op->vfs_extattrctl)(MP, C, FN, NS, N, P)

/*
 * Declarations for these vfs default operations are located in
 * kern/vfs_default.c, they should be used instead of making "dummy"
 * functions or casting entries in the VFS op table to "enopnotsupp()".
 */
int	vfs_stdextattrctl(struct mount *mp, int cmd,
	    struct vnode *filename_vp, int attrnamespace, const char *attrname,
	    struct proc *p);

@


1.60
log
@when a device vnode associated with a mount point disappears, mark the
filesystem as doomed and unmount it
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.59 2005/03/29 17:24:52 pedro Exp $	*/
a350 2
#define	MOUNT_NULL	"null"		/* Minimal Filesystem Layer */
#define	MOUNT_UMAP	"umap"	/* User/Group Identifier Remapping Filesystem */
a354 1
#define	MOUNT_UNION	"union"		/* Union (translucent) Filesystem */
a392 1
#define	MNT_UNION	0x00000020	/* union with underlying filesystem */
@


1.59
log
@Bring in UDF support from FreeBSD, disabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.58 2003/08/14 07:46:40 mickey Exp $	*/
d434 2
@


1.58
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.57 2003/08/05 21:27:15 tedu Exp $	*/
d255 7
d363 1
@


1.57
log
@whitespace pretties.  sorry, couldn't take it anymore
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.56 2003/08/05 20:47:36 tedu Exp $	*/
d366 1
a366 1
	struct vfsops	*mnt_op;		/* operations on fs */
d455 1
a455 1
	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
@


1.56
log
@make procfs support statfs args.  lossage noticed and patch tested by jolan
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.55 2003/07/18 23:02:58 tedu Exp $	*/
d55 1
a55 1
 	char		fid_data[MAXFIDSZ];	/* data (variable length) */
d181 1
a181 1
#define NFSMNT_ACREGMAX 	0x00080000  /* acregmax field valid */
a238 1

d240 6
a245 6
        char    *fspec;                 /* block special device to mount */
        struct  export_args export_info;/* network export information */
        uid_t   uid;                    /* uid that owns ntfs files */
        gid_t   gid;                    /* gid that owns ntfs files */
        mode_t  mode;                   /* mask to be applied for ntfs perms */
        u_long  flag;                   /* additional flags */
d251 2
a252 2
#define     NTFS_MFLAG_CASEINS      0x00000001
#define     NTFS_MFLAG_ALLNAMES     0x00000002
d254 3
d262 3
a265 1

d524 3
a526 3
/* 
 * Declarations for these vfs default operations are located in 
 * kern/vfs_default.c, they should be used instead of making "dummy" 
d528 1
a528 1
 */ 
@


1.55
log
@caddr_t -> void *.  ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.54 2003/06/02 23:28:21 millert Exp $	*/
d255 10
d278 1
@


1.54
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.53 2003/05/24 21:48:05 tedu Exp $	*/
d360 1
a360 1
	qaddr_t		mnt_data;		/* private data */
@


1.53
log
@rename export to export_info for c++ safety.  report by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.52 2003/05/20 03:05:42 tedu Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.52
log
@support for NTFS.  from NetBSD via Julien Bordet
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.51 2003/05/06 20:52:59 tedu Exp $	*/
d246 1
a246 1
        struct  export_args export;     /* network export information */
@


1.51
log
@updated prototype for dounmount
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.50 2003/04/18 22:12:25 tedu Exp $	*/
d241 19
d274 1
d344 1
@


1.50
log
@support for making directories +x without affecting normal files

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.49 2003/02/24 02:17:22 deraadt Exp $	*/
d573 1
a573 1
int	dounmount(struct mount *, int, struct proc *);
@


1.49
log
@bye bye tcfs
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.48 2002/07/12 14:02:23 art Exp $	*/
d222 5
a226 4
#define	MSDOSFSMNT_SHORTNAME	1	/* Force old DOS short names only */
#define	MSDOSFSMNT_LONGNAME	2	/* Force Win'95 long names */
#define	MSDOSFSMNT_NOWIN95	4	/* Completely ignore Win95 entries */
#define	MSDOSFSMNT_GEMDOSFS	8	/* This is a gemdos-flavour */
@


1.48
log
@Change the locking on the mountpoint slightly. Instead of using mnt_lock
to get shared locks for lookup and get the exclusive lock only with
LK_DRAIN on unmount and do the real exclusive locking with flags in
mnt_flags, we now use shared locks for lookup and an exclusive lock for
unmount.

This is accomplished by slightly changing the semantics of vfs_busy.
Old vfs_busy behavior:
 - with LK_NOWAIT set in flags, a shared lock was obtained if the
   mountpoint wasn't being unmounted, otherwise we just returned an error.
 - with no flags, a shared lock was obtained if the mountpoint was being
   unmounted, otherwise we slept until the unmount was done and returned
   an error.
LK_NOWAIT was used for sync(2) and some statistics code where it isn't really
critical that we get the correct results.
0 was used in fchdir and lookup where it's critical that we get the right
directory vnode for the filesystem root.

After this change vfs_busy keeps the same behavior for no flags and LK_NOWAIT.
But if some other flags are passed into it, they are passed directly
into lockmgr (actually LK_SLEEPFAIL is always added to those flags because
if we sleep for the lock, that means someone was holding the exclusive lock
and the exclusive lock is only held when the filesystem is being unmounted.

More changes:
 dounmount must now be called with the exclusive lock held. (before this
 the caller was supposed to hold the vfs_busy lock, but that wasn't always
 true).
 Zap some (now) unused mount flags.
And the highlight of this change:
 Add some vfs_busy calls to match some vfs_unbusy calls, especially in
 sys_mount. (lockmgr doesn't detect the case where we release a lock noone
 holds (it will do that soon)).

If you've seen hangs on reboot with mfs this should solve it (I repeat this
for the fourth time now, but this time I spent two months fixing and
redesigning this and reading the code so this time I must have gotten
this right).
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.47 2002/04/23 18:54:12 espie Exp $	*/
a322 1
#define	MOUNT_TCFS	"tcfs"		/* tcfs */
@


1.47
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.46 2002/03/15 01:20:04 millert Exp $	*/
a386 4
 *
 * MNT_MLOCK lock the mount entry so that name lookup cannot proceed
 * past the mount point.  This keeps the subtree stable during mounts
 * and unmounts.
a391 5
#define	MNT_MLOCK	0x00100000	/* lock so that subtree is stable */
#define	MNT_MWAIT	0x00200000	/* someone is waiting for lock */
#define MNT_MPBUSY	0x00400000	/* scan of mount point in progress */
#define MNT_MPWANT	0x00800000	/* waiting for mount point */
#define MNT_UNMOUNT	0x01000000	/* unmount in progress */
@


1.46
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.45 2002/03/14 01:27:14 millert Exp $	*/
d80 1
a80 1
	struct	export_args export;	/* network export information */
d88 1
a88 1
	struct	export_args export;	/* if exported MFSes are supported */
d98 1
a98 1
	struct	export_args export;	/* network export info */
d211 2
a212 1
	struct	export_args export;	/* network export information */
d232 2
a233 1
	struct	export_args export;	/* network export information */
@


1.45
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.44 2002/02/22 20:37:45 drahn Exp $	*/
d569 5
a573 2
int	vfs_export			    /* process mount export info */(struct mount *, struct netexport *, struct export_args *);
struct	netcred *vfs_export_lookup	    /* lookup host in fs export list */(struct mount *, struct netexport *, struct mbuf *);
@


1.44
log
@Extended Attribute support from FreeBSD/TrustedBSD ok art@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.43 2002/01/18 01:36:29 mickey Exp $	*/
d435 1
a435 1
	int	(*vfc_mountroot)__P((void));	/* if != NULL, routine to mount root */
d452 1
a452 1
	int	(*vfs_mount)	__P((struct mount *mp, const char *path,
d454 23
a476 23
				    struct nameidata *ndp, struct proc *p));
	int	(*vfs_start)	__P((struct mount *mp, int flags,
				    struct proc *p));
	int	(*vfs_unmount)	__P((struct mount *mp, int mntflags,
				    struct proc *p));
	int	(*vfs_root)	__P((struct mount *mp, struct vnode **vpp));
	int	(*vfs_quotactl)	__P((struct mount *mp, int cmds, uid_t uid,
				    caddr_t arg, struct proc *p));
	int	(*vfs_statfs)	__P((struct mount *mp, struct statfs *sbp,
				    struct proc *p));
	int	(*vfs_sync)	__P((struct mount *mp, int waitfor,
				    struct ucred *cred, struct proc *p));
	int	(*vfs_vget)	__P((struct mount *mp, ino_t ino,
				    struct vnode **vpp));
	int	(*vfs_fhtovp)	__P((struct mount *mp, struct fid *fhp,
				     struct vnode **vpp));
	int	(*vfs_vptofh)	__P((struct vnode *vp, struct fid *fhp));
	int	(*vfs_init)	__P((struct vfsconf *));
	int     (*vfs_sysctl)   __P((int *, u_int, void *, size_t *, void *,
				     size_t, struct proc *));
	int	(*vfs_checkexp) __P((struct mount *mp, struct mbuf *nam,
				    int *extflagsp, struct ucred **credanonp));
	int     (*vfs_extattrctl) __P((struct mount *mp, int cmd,
d479 1
a479 1
				    struct proc *p));
d504 1
a504 1
int	vfs_stdextattrctl __P((struct mount *mp, int cmd,
d506 1
a506 1
	    struct proc *p));
d554 1
a554 1
int	vfs_busy __P((struct mount *, int, struct simplelock *, struct proc *));
d558 7
a564 7
void	vfs_getnewfsid __P((struct mount *));
struct	mount *vfs_getvfs __P((fsid_t *));
int	vfs_mountedon __P((struct vnode *));
int	vfs_mountroot __P((void));
int	vfs_rootmountalloc __P((char *, char *, struct mount **));
void	vfs_unbusy __P((struct mount *, struct proc *));
void	vfs_unmountall __P((void));
d568 11
a578 13
struct	mount *getvfs __P((fsid_t *));	    /* return vfs given fsid */
int	vfs_export			    /* process mount export info */
	  __P((struct mount *, struct netexport *, struct export_args *));
struct	netcred *vfs_export_lookup	    /* lookup host in fs export list */
	  __P((struct mount *, struct netexport *, struct mbuf *));
int	vfs_allocate_syncvnode __P((struct mount *));
int	speedup_syncer __P((void));

int	vfs_syncwait __P((int));	/* sync and wait for complete */
void	vfs_shutdown __P((void));	/* unmount and sync file systems */
long	makefstype __P((char *));
int	dounmount __P((struct mount *, int, struct proc *));
void	vfsinit __P((void));
d580 1
a580 1
void	vfs_bufstats __P((void));
d582 2
a583 2
int	vfs_register __P((struct vfsconf *));
int	vfs_unregister __P((struct vfsconf *));
d593 7
a599 7
int	fstatfs __P((int, struct statfs *));
int	getfh __P((const char *, fhandle_t *));
int	getfsstat __P((struct statfs *, size_t, int));
int	getmntinfo __P((struct statfs **, int));
int	mount __P((const char *, const char *, int, void *));
int	statfs __P((const char *, struct statfs *));
int	unmount __P((const char *, int));
d601 3
a603 3
int	fhopen __P((const fhandle_t *, int));
int	fhstat __P((const fhandle_t *, struct stat *));
int	fhstatfs __P((const fhandle_t *, struct statfs *));
@


1.43
log
@record ctime for the mountpoint, mount time or last mount update; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.42 2001/12/19 08:58:06 art Exp $	*/
d476 4
d496 12
@


1.42
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.40 2001/11/21 21:13:34 csapuntz Exp $	*/
d269 2
a270 1
	u_int32_t  f_spare[4];		/* spare for later */
@


1.41
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@a338 2
	int		mnt_fs_bshift;		/* offset shift for lblkno */
	int		mnt_dev_bshift;		/* shift for device sectors */
@


1.41.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.43 2002/01/18 01:36:29 mickey Exp $	*/
d269 1
a269 2
	u_int32_t  f_ctime;		/* last mount [-u] time */
	u_int32_t  f_spare[3];		/* spare for later */
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.41.2.1 2002/01/31 22:55:49 niklas Exp $	*/
d80 1
a80 1
	struct	export_args export_info;/* network export information */
d88 1
a88 1
	struct	export_args export_info;/* if exported MFSes are supported */
d98 1
a98 1
	struct	export_args export_info;/* network export info */
d211 1
a211 2
	struct	export_args export_info;
				/* network export information */
d231 1
a231 2
	struct	export_args export_info;
				/* network export information */
d437 1
a437 1
	int	(*vfc_mountroot)(void);	/* if != NULL, routine to mount root */
d454 1
a454 1
	int	(*vfs_mount)(struct mount *mp, const char *path,
d456 22
a477 26
				    struct nameidata *ndp, struct proc *p);
	int	(*vfs_start)(struct mount *mp, int flags,
				    struct proc *p);
	int	(*vfs_unmount)(struct mount *mp, int mntflags,
				    struct proc *p);
	int	(*vfs_root)(struct mount *mp, struct vnode **vpp);
	int	(*vfs_quotactl)(struct mount *mp, int cmds, uid_t uid,
				    caddr_t arg, struct proc *p);
	int	(*vfs_statfs)(struct mount *mp, struct statfs *sbp,
				    struct proc *p);
	int	(*vfs_sync)(struct mount *mp, int waitfor,
				    struct ucred *cred, struct proc *p);
	int	(*vfs_vget)(struct mount *mp, ino_t ino,
				    struct vnode **vpp);
	int	(*vfs_fhtovp)(struct mount *mp, struct fid *fhp,
				     struct vnode **vpp);
	int	(*vfs_vptofh)(struct vnode *vp, struct fid *fhp);
	int	(*vfs_init)(struct vfsconf *);
	int     (*vfs_sysctl)(int *, u_int, void *, size_t *, void *,
				     size_t, struct proc *);
	int	(*vfs_checkexp)(struct mount *mp, struct mbuf *nam,
				    int *extflagsp, struct ucred **credanonp);
	int     (*vfs_extattrctl)(struct mount *mp, int cmd,
				    struct vnode *filename_vp,
				    int attrnamespace, const char *attrname,
				    struct proc *p);
a493 12
#define VFS_EXTATTRCTL(MP, C, FN, NS, N, P) \
	(*(MP)->mnt_op->vfs_extattrctl)(MP, C, FN, NS, N, P)

/* 
 * Declarations for these vfs default operations are located in 
 * kern/vfs_default.c, they should be used instead of making "dummy" 
 * functions or casting entries in the VFS op table to "enopnotsupp()".
 */ 
int	vfs_stdextattrctl(struct mount *mp, int cmd,
	    struct vnode *filename_vp, int attrnamespace, const char *attrname,
	    struct proc *p);

d540 1
a540 1
int	vfs_busy(struct mount *, int, struct simplelock *, struct proc *);
d544 7
a550 7
void	vfs_getnewfsid(struct mount *);
struct	mount *vfs_getvfs(fsid_t *);
int	vfs_mountedon(struct vnode *);
int	vfs_mountroot(void);
int	vfs_rootmountalloc(char *, char *, struct mount **);
void	vfs_unbusy(struct mount *, struct proc *);
void	vfs_unmountall(void);
d554 13
a566 14
struct	mount *getvfs(fsid_t *);	    /* return vfs given fsid */
					    /* process mount export info */
int	vfs_export(struct mount *, struct netexport *, struct export_args *);
					    /* lookup host in fs export list */
struct	netcred *vfs_export_lookup(struct mount *, struct netexport *,
	    struct mbuf *);
int	vfs_allocate_syncvnode(struct mount *);
int	speedup_syncer(void);

int	vfs_syncwait(int);	/* sync and wait for complete */
void	vfs_shutdown(void);	/* unmount and sync file systems */
long	makefstype(char *);
int	dounmount(struct mount *, int, struct proc *);
void	vfsinit(void);
d568 1
a568 1
void	vfs_bufstats(void);
d570 2
a571 2
int	vfs_register(struct vfsconf *);
int	vfs_unregister(struct vfsconf *);
d581 7
a587 7
int	fstatfs(int, struct statfs *);
int	getfh(const char *, fhandle_t *);
int	getfsstat(struct statfs *, size_t, int);
int	getmntinfo(struct statfs **, int);
int	mount(const char *, const char *, int, void *);
int	statfs(const char *, struct statfs *);
int	unmount(const char *, int);
d589 3
a591 3
int	fhopen(const fhandle_t *, int);
int	fhstat(const fhandle_t *, struct stat *);
int	fhstatfs(const fhandle_t *, struct statfs *);
@


1.41.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.41.2.2 2002/06/11 03:32:33 art Exp $	*/
d389 4
d398 5
@


1.41.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d222 4
a225 5
#define	MSDOSFSMNT_SHORTNAME	0x01	/* Force old DOS short names only */
#define	MSDOSFSMNT_LONGNAME	0x02	/* Force Win'95 long names */
#define	MSDOSFSMNT_NOWIN95	0x04	/* Completely ignore Win95 entries */
#define	MSDOSFSMNT_GEMDOSFS	0x08	/* This is a gemdos-flavour */
#define MSDOSFSMNT_ALLOWDIRX	0x10	/* dir is mode +x if r */
d323 1
d575 1
a575 1
int	dounmount(struct mount *, int, struct proc *, struct vnode *);
@


1.40
log
@Added vfs_isbusy. Useful for verifying that a mount point is locked
Added vfs_mount_foreach_vnode. Several places in the code seem to want to
traverse the mount list and they all seem to handle locking differently.
Centralize traversing the mount list in one place so that we only need
to get the locking right once.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.39 2001/03/23 00:24:10 mickey Exp $	*/
d339 2
@


1.39
log
@protect func ptr ars w/ __P
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.38 2001/02/20 01:50:11 assar Exp $	*/
d538 3
@


1.38
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.37 2000/06/17 17:16:04 provos Exp $	*/
d434 1
a434 1
	int	(*vfc_mountroot)(void);	/* if != NULL, routine to mount root */
@


1.37
log
@initial import of tcfs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.36 2000/05/22 17:29:06 mickey Exp $	*/
d451 2
a452 1
	int	(*vfs_mount)	__P((struct mount *mp, const char *path, caddr_t data,
@


1.36
log
@a little consistency in sysctl definitions
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.35 2000/03/24 19:07:48 millert Exp $	*/
d320 1
@


1.35
log
@Make f_bsize signed.  Having it unsigned causes surprising (and unwanted)
type coercions.  With this fixed I can back out the hack in df.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.34 2000/02/09 10:29:56 assar Exp $	*/
d405 1
a405 1
#define	VFS_GENERIC		0	/* generic filesystem information */
d414 7
@


1.34
log
@add forward declaration of `struct stat' (needed by fhstat
prototype).  From "Todd C. Miller" <Todd.Miller@@courtesan.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.33 2000/02/07 04:52:11 assar Exp $	*/
d258 1
a258 1
	u_int32_t  f_bsize;		/* fundamental file system block size */
@


1.34.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.39 2001/03/23 00:24:10 mickey Exp $	*/
d258 1
a258 1
	int32_t    f_bsize;		/* fundamental file system block size */
a319 1
#define	MOUNT_TCFS	"tcfs"		/* tcfs */
d405 1
a405 1
#define	VFS_GENERIC	0	/* generic filesystem information */
a413 7
#define	VFSGEN_MAXID	3	/* max number of vfs.generic ids */

#define	CTL_VFSGENCTL_NAMES { \
	{ 0, 0 }, \
	{ "maxtypenum", CTLTYPE_INT }, \
	{ "conf", CTLTYPE_NODE } \
}
d426 1
a426 1
	int	(*vfc_mountroot)__P((void));	/* if != NULL, routine to mount root */
d443 1
a443 2
	int	(*vfs_mount)	__P((struct mount *mp, const char *path,
				    void *data,
@


1.34.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a338 2
	int		mnt_fs_bshift;		/* offset shift for lblkno */
	int		mnt_dev_bshift;		/* shift for device sectors */
a537 3
int     vfs_isbusy(struct mount *);
int     vfs_mount_foreach_vnode(struct mount *, int (*func)(struct vnode *,
				    void *), void *);
@


1.34.2.3
log
@Merge in trunk
@
text
@d269 1
a269 2
	u_int32_t  f_ctime;		/* last mount [-u] time */
	u_int32_t  f_spare[3];		/* spare for later */
d339 2
a476 4
	int     (*vfs_extattrctl) __P((struct mount *mp, int cmd,
				    struct vnode *filename_vp,
				    int attrnamespace, const char *attrname,
				    struct proc *p));
a492 12
#define VFS_EXTATTRCTL(MP, C, FN, NS, N, P) \
	(*(MP)->mnt_op->vfs_extattrctl)(MP, C, FN, NS, N, P)

/* 
 * Declarations for these vfs default operations are located in 
 * kern/vfs_default.c, they should be used instead of making "dummy" 
 * functions or casting entries in the VFS op table to "enopnotsupp()".
 */ 
int	vfs_stdextattrctl __P((struct mount *mp, int cmd,
	    struct vnode *filename_vp, int attrnamespace, const char *attrname,
	    struct proc *p));

@


1.34.2.4
log
@Merge in -current from roughly a week ago
@
text
@d435 1
a435 1
	int	(*vfc_mountroot)(void);	/* if != NULL, routine to mount root */
d452 1
a452 1
	int	(*vfs_mount)(struct mount *mp, const char *path,
d454 23
a476 23
				    struct nameidata *ndp, struct proc *p);
	int	(*vfs_start)(struct mount *mp, int flags,
				    struct proc *p);
	int	(*vfs_unmount)(struct mount *mp, int mntflags,
				    struct proc *p);
	int	(*vfs_root)(struct mount *mp, struct vnode **vpp);
	int	(*vfs_quotactl)(struct mount *mp, int cmds, uid_t uid,
				    caddr_t arg, struct proc *p);
	int	(*vfs_statfs)(struct mount *mp, struct statfs *sbp,
				    struct proc *p);
	int	(*vfs_sync)(struct mount *mp, int waitfor,
				    struct ucred *cred, struct proc *p);
	int	(*vfs_vget)(struct mount *mp, ino_t ino,
				    struct vnode **vpp);
	int	(*vfs_fhtovp)(struct mount *mp, struct fid *fhp,
				     struct vnode **vpp);
	int	(*vfs_vptofh)(struct vnode *vp, struct fid *fhp);
	int	(*vfs_init)(struct vfsconf *);
	int     (*vfs_sysctl)(int *, u_int, void *, size_t *, void *,
				     size_t, struct proc *);
	int	(*vfs_checkexp)(struct mount *mp, struct mbuf *nam,
				    int *extflagsp, struct ucred **credanonp);
	int     (*vfs_extattrctl)(struct mount *mp, int cmd,
d479 1
a479 1
				    struct proc *p);
d504 1
a504 1
int	vfs_stdextattrctl(struct mount *mp, int cmd,
d506 1
a506 1
	    struct proc *p);
d554 1
a554 1
int	vfs_busy(struct mount *, int, struct simplelock *, struct proc *);
d558 7
a564 7
void	vfs_getnewfsid(struct mount *);
struct	mount *vfs_getvfs(fsid_t *);
int	vfs_mountedon(struct vnode *);
int	vfs_mountroot(void);
int	vfs_rootmountalloc(char *, char *, struct mount **);
void	vfs_unbusy(struct mount *, struct proc *);
void	vfs_unmountall(void);
d568 13
a580 14
struct	mount *getvfs(fsid_t *);	    /* return vfs given fsid */
					    /* process mount export info */
int	vfs_export(struct mount *, struct netexport *, struct export_args *);
					    /* lookup host in fs export list */
struct	netcred *vfs_export_lookup(struct mount *, struct netexport *,
	    struct mbuf *);
int	vfs_allocate_syncvnode(struct mount *);
int	speedup_syncer(void);

int	vfs_syncwait(int);	/* sync and wait for complete */
void	vfs_shutdown(void);	/* unmount and sync file systems */
long	makefstype(char *);
int	dounmount(struct mount *, int, struct proc *);
void	vfsinit(void);
d582 1
a582 1
void	vfs_bufstats(void);
d584 2
a585 2
int	vfs_register(struct vfsconf *);
int	vfs_unregister(struct vfsconf *);
d595 7
a601 7
int	fstatfs(int, struct statfs *);
int	getfh(const char *, fhandle_t *);
int	getfsstat(struct statfs *, size_t, int);
int	getmntinfo(struct statfs **, int);
int	mount(const char *, const char *, int, void *);
int	statfs(const char *, struct statfs *);
int	unmount(const char *, int);
d603 3
a605 3
int	fhopen(const fhandle_t *, int);
int	fhstat(const fhandle_t *, struct stat *);
int	fhstatfs(const fhandle_t *, struct statfs *);
@


1.34.2.5
log
@Sync the SMP branch with 3.3
@
text
@d80 1
a80 1
	struct	export_args export_info;/* network export information */
d88 1
a88 1
	struct	export_args export_info;/* if exported MFSes are supported */
d98 1
a98 1
	struct	export_args export_info;/* network export info */
d211 1
a211 2
	struct	export_args export_info;
				/* network export information */
d231 1
a231 2
	struct	export_args export_info;
				/* network export information */
d321 1
d385 4
d394 5
@


1.34.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.34.2.5 2003/03/28 00:41:30 niklas Exp $	*/
d222 4
a225 5
#define	MSDOSFSMNT_SHORTNAME	0x01	/* Force old DOS short names only */
#define	MSDOSFSMNT_LONGNAME	0x02	/* Force Win'95 long names */
#define	MSDOSFSMNT_NOWIN95	0x04	/* Completely ignore Win95 entries */
#define	MSDOSFSMNT_GEMDOSFS	0x08	/* This is a gemdos-flavour */
#define MSDOSFSMNT_ALLOWDIRX	0x10	/* dir is mode +x if r */
d572 1
a572 1
int	dounmount(struct mount *, int, struct proc *, struct vnode *);
@


1.34.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.34.2.6 2003/05/13 19:36:57 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
a240 19
 * Arguments to mount ntfs filesystems
 */

struct ntfs_args {
        char    *fspec;                 /* block special device to mount */
        struct  export_args export_info;/* network export information */
        uid_t   uid;                    /* uid that owns ntfs files */
        gid_t   gid;                    /* gid that owns ntfs files */
        mode_t  mode;                   /* mask to be applied for ntfs perms */
        u_long  flag;                   /* additional flags */
};

/*
 * ntfs mount options:
 */
#define     NTFS_MFLAG_CASEINS      0x00000001
#define     NTFS_MFLAG_ALLNAMES     0x00000002

/*
a254 1
	struct ntfs_args ntfs_args;
a323 1
#define	MOUNT_NTFS	"ntfs"		/* NTFS */
@


1.34.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 1
a55 1
	char		fid_data[MAXFIDSZ];	/* data (variable length) */
d181 1
a181 1
#define NFSMNT_ACREGMAX		0x00080000  /* acregmax field valid */
d239 1
d241 6
a246 6
	char	*fspec;			/* block special device to mount */
	struct	export_args export_info;/* network export information */
	uid_t	uid;			/* uid that owns ntfs files */
	gid_t	gid;			/* gid that owns ntfs files */
	mode_t	mode;			/* mask to be applied for ntfs perms */
	u_long	flag;			/* additional flags */
d252 2
a253 17
#define	NTFS_MFLAG_CASEINS      0x00000001
#define	NTFS_MFLAG_ALLNAMES     0x00000002

/*
 * Arguments to mount procfs filesystems
 */
struct procfs_args {
	int version;
	int flags;
};

/*
 * procfs mount options:
 */
#define PROCFS_ARGSVERSION      1
#define PROCFSMNT_LINUXCOMPAT   0x01

a267 1
	struct procfs_args procfs_args;
d351 1
a351 1
	const struct vfsops *mnt_op;		/* operations on fs */
d360 1
a360 1
	void		*mnt_data;		/* private data */
d440 1
a440 1
	const struct vfsops *vfc_vfsops; /* filesystem operations vector */
d509 3
a511 3
/*
 * Declarations for these vfs default operations are located in
 * kern/vfs_default.c, they should be used instead of making "dummy"
d513 1
a513 1
 */
@


1.33
log
@(vfsops): divide up fhtovp into two:  fhtovp that does the mapping and
checkexp that verifies if the client has the right to mount this fs
from us

(fhopen, fhstat, fhstatfs): add prototypes for new syscalls.

(largely based on NetBSD)
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.32 1999/12/05 06:56:34 art Exp $	*/
d560 4
@


1.32
log
@Add a new function "speedup_syncer()" that pushes the syncer to work harder.
Used by the new soft updates code.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.31 1999/07/02 23:35:53 deraadt Exp $	*/
d459 1
a459 2
				    struct mbuf *nam, struct vnode **vpp,
				    int *exflagsp, struct ucred **credanonp));
d464 2
d477 2
a478 2
#define VFS_FHTOVP(MP, FIDP, NAM, VPP, EXFLG, CRED) \
	(*(MP)->mnt_op->vfs_fhtovp)(MP, FIDP, NAM, VPP, EXFLG, CRED)
d480 2
d569 5
a573 1

@


1.31
log
@copy ISOFSMNT_NOJOLIET flag from isofs/cd9660/cd9660_mount.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.30 1999/06/21 08:27:07 niklas Exp $	*/
d542 1
@


1.30
log
@f_bavail can go negative when minfree is passed
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.29 1999/05/31 17:34:52 millert Exp $	*/
d104 1
@


1.29
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.28 1999/05/06 15:59:48 mickey Exp $	*/
d261 1
a261 1
	u_int32_t  f_bavail;		/* free blocks avail to non-superuser */
@


1.28
log
@factor out sync+wait code into vfa_syncwait() routine for
applications in system like power management and such.
art@@ finally said `commit it'
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.27 1999/03/11 18:55:24 deraadt Exp $	*/
d63 174
d243 12
d256 21
d288 2
a289 2
	long    f_syncwrites;           /* count of sync writes since mount */
	long    f_asyncwrites;          /* count of async writes since mount */
a519 174
/*
 * Export arguments for local filesystem mount calls.
 */
struct export_args {
	int	ex_flags;		/* export related flags */
	uid_t	ex_root;		/* mapping for root uid */
	struct	ucred ex_anon;		/* mapping for anonymous user */
	struct	sockaddr *ex_addr;	/* net address to which exported */
	int	ex_addrlen;		/* and the net address length */
	struct	sockaddr *ex_mask;	/* mask of valid bits in saddr */
	int	ex_masklen;		/* and the smask length */
};

/*
 * Arguments to mount UFS-based filesystems
 */
struct ufs_args {
	char	*fspec;			/* block special device to mount */
	struct	export_args export;	/* network export information */
};

/*
 * Arguments to mount MFS
 */
struct mfs_args {
	char	*fspec;			/* name to export for statfs */
	struct	export_args export;	/* if exported MFSes are supported */
	caddr_t	base;			/* base of file system in memory */
	u_long	size;			/* size of file system */
};

/*
 * Arguments to mount ISO 9660 filesystems.
 */
struct iso_args {
	char	*fspec;			/* block special device to mount */
	struct	export_args export;	/* network export info */
	int	flags;			/* mounting flags, see below */
};
#define	ISOFSMNT_NORRIP	0x00000001	/* disable Rock Ridge Ext.*/
#define	ISOFSMNT_GENS	0x00000002	/* enable generation numbers */
#define	ISOFSMNT_EXTATT	0x00000004	/* enable extended attributes */

/*
 * Arguments to mount NFS
 */
#define NFS_ARGSVERSION	4		/* change when nfs_args changes */
struct nfs_args {
	int		version;	/* args structure version number */
	struct sockaddr	*addr;		/* file server address */
	int		addrlen;	/* length of address */
	int		sotype;		/* Socket type */
	int		proto;		/* and Protocol */
	u_char		*fh;		/* File handle to be mounted */
	int		fhsize;		/* Size, in bytes, of fh */
	int		flags;		/* flags */
	int		wsize;		/* write size in bytes */
	int		rsize;		/* read size in bytes */
	int		readdirsize;	/* readdir size in bytes */
	int		timeo;		/* initial timeout in .1 secs */
	int		retrans;	/* times to retry send */
	int		maxgrouplist;	/* Max. size of group list */
	int		readahead;	/* # of blocks to readahead */
	int		leaseterm;	/* Term (sec) of lease */
	int		deadthresh;	/* Retrans threshold */
	char		*hostname;	/* server's name */
	int		acregmin;	/* Attr cache file recently modified */
	int		acregmax;	/* ac file not recently modified */
	int		acdirmin;	/* ac for dir recently modified */
	int		acdirmax;	/* ac for dir not recently modified */
};
/* NFS args version 3 (for backwards compatibility) */
struct nfs_args3 {
	int		version;	/* args structure version number */
	struct sockaddr	*addr;		/* file server address */
	int		addrlen;	/* length of address */
	int		sotype;		/* Socket type */
	int		proto;		/* and Protocol */
	u_char		*fh;		/* File handle to be mounted */
	int		fhsize;		/* Size, in bytes, of fh */
	int		flags;		/* flags */
	int		wsize;		/* write size in bytes */
	int		rsize;		/* read size in bytes */
	int		readdirsize;	/* readdir size in bytes */
	int		timeo;		/* initial timeout in .1 secs */
	int		retrans;	/* times to retry send */
	int		maxgrouplist;	/* Max. size of group list */
	int		readahead;	/* # of blocks to readahead */
	int		leaseterm;	/* Term (sec) of lease */
	int		deadthresh;	/* Retrans threshold */
	char		*hostname;	/* server's name */
};

/*
 * NFS mount option flags
 */
#ifndef _KERNEL
#define	NFSMNT_RESVPORT		0x00000000  /* always use reserved ports */
#endif /* ! _KERNEL */
#define	NFSMNT_SOFT		0x00000001  /* soft mount (hard is default) */
#define	NFSMNT_WSIZE		0x00000002  /* set write size */
#define	NFSMNT_RSIZE		0x00000004  /* set read size */
#define	NFSMNT_TIMEO		0x00000008  /* set initial timeout */
#define	NFSMNT_RETRANS		0x00000010  /* set number of request retries */
#define	NFSMNT_MAXGRPS		0x00000020  /* set maximum grouplist size */
#define	NFSMNT_INT		0x00000040  /* allow interrupts on hard mount */
#define	NFSMNT_NOCONN		0x00000080  /* Don't Connect the socket */
#define	NFSMNT_NQNFS		0x00000100  /* Use Nqnfs protocol */
#define	NFSMNT_NFSV3		0x00000200  /* Use NFS Version 3 protocol */
#define	NFSMNT_KERB		0x00000400  /* Use Kerberos authentication */
#define	NFSMNT_DUMBTIMR		0x00000800  /* Don't estimate rtt dynamically */
#define	NFSMNT_LEASETERM	0x00001000  /* set lease term (nqnfs) */
#define	NFSMNT_READAHEAD	0x00002000  /* set read ahead */
#define	NFSMNT_DEADTHRESH	0x00004000  /* set dead server retry thresh */
#ifdef _KERNEL /* Coming soon to a system call near you! */
#define	NFSMNT_NOAC		0x00008000  /* disable attribute cache */
#endif /* _KERNEL */
#define	NFSMNT_RDIRPLUS		0x00010000  /* Use Readdirplus for V3 */
#define	NFSMNT_READDIRSIZE	0x00020000  /* Set readdir size */

/* Flags valid only in mount syscall arguments */
#define NFSMNT_ACREGMIN		0x00040000  /* acregmin field valid */
#define NFSMNT_ACREGMAX 	0x00080000  /* acregmax field valid */
#define NFSMNT_ACDIRMIN		0x00100000  /* acdirmin field valid */
#define NFSMNT_ACDIRMAX		0x00200000  /* acdirmax field valid */

/* Flags valid only in kernel */
#define	NFSMNT_INTERNAL		0xfffc0000  /* Bits set internally */
#define NFSMNT_HASWRITEVERF	0x00040000  /* Has write verifier for V3 */
#define NFSMNT_GOTPATHCONF	0x00080000  /* Got the V3 pathconf info */
#define NFSMNT_GOTFSINFO	0x00100000  /* Got the V3 fsinfo */
#define	NFSMNT_MNTD		0x00200000  /* Mnt server for mnt point */
#define	NFSMNT_DISMINPROG	0x00400000  /* Dismount in progress */
#define	NFSMNT_DISMNT		0x00800000  /* Dismounted */
#define	NFSMNT_SNDLOCK		0x01000000  /* Send socket lock */
#define	NFSMNT_WANTSND		0x02000000  /* Want above */
#define	NFSMNT_RCVLOCK		0x04000000  /* Rcv socket lock */
#define	NFSMNT_WANTRCV		0x08000000  /* Want above */
#define	NFSMNT_WAITAUTH		0x10000000  /* Wait for authentication */
#define	NFSMNT_HASAUTH		0x20000000  /* Has authenticator */
#define	NFSMNT_WANTAUTH		0x40000000  /* Wants an authenticator */
#define	NFSMNT_AUTHERR		0x80000000  /* Authentication error */

/*
 *  Arguments to mount MSDOS filesystems.
 */
struct msdosfs_args {
	char	*fspec;		/* blocks special holding the fs to mount */
	struct	export_args export;	/* network export information */
	uid_t	uid;		/* uid that owns msdosfs files */
	gid_t	gid;		/* gid that owns msdosfs files */
	mode_t  mask;		/* mask to be applied for msdosfs perms */
	int	flags;		/* see below */
};

/*
 * Msdosfs mount options:
 */
#define	MSDOSFSMNT_SHORTNAME	1	/* Force old DOS short names only */
#define	MSDOSFSMNT_LONGNAME	2	/* Force Win'95 long names */
#define	MSDOSFSMNT_NOWIN95	4	/* Completely ignore Win95 entries */
#define	MSDOSFSMNT_GEMDOSFS	8	/* This is a gemdos-flavour */

/*
 * Arguments to mount amigados filesystems.
 */
struct adosfs_args {
	char	*fspec;		/* blocks special holding the fs to mount */
	struct	export_args export;	/* network export information */
	uid_t	uid;		/* uid that owns msdosfs files */
	gid_t	gid;		/* gid that owns msdosfs files */
	mode_t	mask;		/* mask to be applied for msdosfs perms */
};

d559 1
a559 1
int	getfsstat __P((struct statfs *, long, int));
@


1.27
log
@back out unapproved changes
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.25 1999/02/19 17:15:44 art Exp $	*/
d509 2
a510 1
void	vfs_shutdown __P((void));	    /* unmount and sync file systems */
@


1.26
log
@factor sync+wait operation out into a separate function.
@
text
@d509 1
a509 2
int	vfs_syncwait __P((int));	/* sync and wait for complete */
void	vfs_shutdown __P((void));	/* unmount and sync file systems */
@


1.25
log
@add vfs_register and vfs_unregister functions
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.24 1998/09/01 17:01:07 deraadt Exp $	*/
d509 2
a510 1
void	vfs_shutdown __P((void));	    /* unmount and sync file systems */
@


1.24
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.23 1998/08/30 17:11:34 art Exp $	*/
d516 2
@


1.23
log
@glue for xfs
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.22 1998/02/08 22:41:47 tholo Exp $	*/
d111 1
a111 1
#define MOUNT_XFS	"xfs"		/* xfs */
@


1.22
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.21 1997/11/06 05:59:09 csapuntz Exp $	*/
d111 1
@


1.21
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.20 1997/10/06 20:21:08 deraadt Exp $	*/
d234 1
a234 1
	int	(*vfs_mount)	__P((struct mount *mp, char *path, caddr_t data,
@


1.20
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.18 1997/04/16 09:49:00 downsj Exp $	*/
d46 1
d59 1
a59 1
	char		fid_data[MAXFIDSZ];	/* data (variable length) */
d81 3
a83 1
	long	f_spare[4];		/* spare for later */
d122 1
d124 1
d126 1
d170 1
a170 1
#define	MNT_VISFLAGMASK	0x0000ffff
d189 31
d230 3
a233 1
	char	*vfs_name;
d253 3
a255 2
	void	(*vfs_init)	__P((void));
	int	vfs_refcount;
d277 3
a279 2
#define MNT_WAIT	1
#define MNT_NOWAIT	2
d490 11
d506 2
a507 2
int	vfs_lock __P((struct mount *));	    /* lock a vfs */
int	vfs_mountedon __P((struct vnode *));/* is a vfs mounted on vp */
a508 7
void	vfs_unlock __P((struct mount *));   /* unlock a vfs */
void	vfs_unmountall __P((void));	    /* unmount file systems */
int 	vfs_busy __P((struct mount *));
void	vfs_unbusy __P((struct mount *));
extern	CIRCLEQ_HEAD(mntlist, mount) mountlist;	/* mounted filesystem list */
extern	struct vfsops *vfssw[];		    /* filesystem type table */
extern	int nvfssw;
d527 2
@


1.19
log
@VFS Lite2 Changes
@
text
@a45 1
#include <sys/lock.h>
d58 1
a58 1
 	char		fid_data[MAXFIDSZ];	/* data (variable length) */
d80 1
a80 3
	long    f_syncwrites;           /* count of sync writes since mount */
	long    f_asyncwrites;          /* count of async writes since mount */
	long	f_spare[2];		/* spare for later */
a118 1
	struct vfsconf  *mnt_vfc;               /* configuration info */
a119 1
	struct vnode    *mnt_syncer;            /* syncer vnode */
a120 1
	struct lock     mnt_lock;               /* mount structure lock */
d164 1
a164 1
#define	MNT_VISFLAGMASK	0x0400ffff
a182 31
#define MNT_SOFTDEP     0x04000000      /* soft dependencies being done */
/*
 * Sysctl CTL_VFS definitions.
 *
 * Second level identifier specifies which filesystem. Second level
 * identifier VFS_GENERIC returns information about all filesystems.
 */
#define	VFS_GENERIC		0	/* generic filesystem information */
/*
 * Third level identifiers for VFS_GENERIC are given below; third
 * level identifiers for specific filesystems are given in their
 * mount specific header files.
 */
#define VFS_MAXTYPENUM	1	/* int: highest defined filesystem type */
#define VFS_CONF	2	/* struct: vfsconf for filesystem given
				   as next argument */

/*
 * Filesystem configuration information. One of these exists for each
 * type of filesystem supported by the kernel. These are searched at
 * mount time to identify the requested filesystem.
 */
struct vfsconf {
	struct	vfsops *vfc_vfsops;	/* filesystem operations vector */
	char	vfc_name[MFSNAMELEN];	/* filesystem type name */
	int	vfc_typenum;		/* historic filesystem type number */
	int	vfc_refcount;		/* number mounted of this type */
	int	vfc_flags;		/* permanent flags */
	int	(*vfc_mountroot)(void);	/* if != NULL, routine to mount root */
	struct	vfsconf *vfc_next;	/* next in list */
};
a192 3
extern int maxvfsconf;		/* highest defined filesystem type */
extern struct vfsconf *vfsconf;	/* head of list of filesystem types */

d194 1
d214 2
a215 3
	int	(*vfs_init)	__P((struct vfsconf *));
	int     (*vfs_sysctl)   __P((int *, u_int, void *, size_t *, void *,
				     size_t, struct proc *));
d237 2
a238 3
#define MNT_WAIT	1	/* synchronously wait for I/O to complete */
#define MNT_NOWAIT	2	/* start all I/O, but do not wait for it */
#define MNT_LAZY	3	/* push data not written by filesystem syncer */
a448 11
int	vfs_busy __P((struct mount *, int, struct simplelock *, struct proc *));
void	vfs_getnewfsid __P((struct mount *));
struct	mount *vfs_getvfs __P((fsid_t *));
int	vfs_mountedon __P((struct vnode *));
int	vfs_mountroot __P((void));
int	vfs_rootmountalloc __P((char *, char *, struct mount **));
void	vfs_unbusy __P((struct mount *, struct proc *));
void	vfs_unmountall __P((void));
extern	CIRCLEQ_HEAD(mntlist, mount) mountlist;
extern	struct simplelock mountlist_slock;

d454 2
a455 2
int	vfs_allocate_syncvnode __P((struct mount *));

d457 7
a481 2


@


1.18
log
@Multiple include protection.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.17 1997/04/12 20:20:08 graichen Exp $	*/
d46 1
d59 1
a59 1
	char		fid_data[MAXFIDSZ];	/* data (variable length) */
d81 3
a83 1
	long	f_spare[4];		/* spare for later */
d122 1
d124 1
d126 1
d170 1
a170 1
#define	MNT_VISFLAGMASK	0x0000ffff
d189 31
d230 3
a233 1
	char	*vfs_name;
d253 3
a255 2
	void	(*vfs_init)	__P((void));
	int	vfs_refcount;
d277 3
a279 2
#define MNT_WAIT	1
#define MNT_NOWAIT	2
d490 11
d506 2
a507 2
int	vfs_lock __P((struct mount *));	    /* lock a vfs */
int	vfs_mountedon __P((struct vnode *));/* is a vfs mounted on vp */
a508 7
void	vfs_unlock __P((struct mount *));   /* unlock a vfs */
void	vfs_unmountall __P((void));	    /* unmount file systems */
int 	vfs_busy __P((struct mount *));
void	vfs_unbusy __P((struct mount *));
extern	CIRCLEQ_HEAD(mntlist, mount) mountlist;	/* mounted filesystem list */
extern	struct vfsops *vfssw[];		    /* filesystem type table */
extern	int nvfssw;
d527 2
@


1.17
log
@undo my last commit - theo says NFSMNT_RESVPORT is really not required
inside the kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.16 1997/04/12 20:02:32 graichen Exp $	*/
d39 3
d485 1
@


1.16
log
@remove #ifndef _KERNEL around NFSMNT_RESVPORT:

* this is required to get src/sys/compat/ultrix compiled
* in NetBSD it is'nt #ifndef'ed _KERNEL too

if anyone objects to that change please speak up now ...
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.15 1997/03/09 19:26:05 millert Exp $	*/
d364 1
d366 1
@


1.15
log
@Move MNT_NOATIME so numbers are consecutive.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.14 1997/03/02 09:52:50 millert Exp $	*/
a363 1
#ifndef _KERNEL
a364 1
#endif /* !_KERNEL */
@


1.14
log
@Change MNT_NOATIME to unused value.  This backs out the MNT_* renumbering
that will surely hose people who try to run a new kernel on an old
userland.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.13 1997/03/02 09:38:22 millert Exp $	*/
a135 1
#define MNT_NOATIME	0x00008000	/* don't update atime on files */
d152 5
@


1.13
log
@Add noatime option to not update atime on files in a filesystem (unless
ctime or mtime has changed).  Useful for laptops and news servers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.12 1996/12/24 20:14:35 dm Exp $	*/
d136 1
a136 1
#define	MNT_NOATIME	0x00000080	/* don't update atime on files */
d141 5
a145 5
#define	MNT_EXRDONLY	0x00000100	/* exported read only */
#define	MNT_EXPORTED	0x00000200	/* file system is exported */
#define	MNT_DEFEXPORTED	0x00000400	/* exported to the world */
#define	MNT_EXPORTANON	0x00000800	/* use anon uid mapping for everyone */
#define	MNT_EXKERB	0x00001000	/* exported with Kerberos uid mapping */
d150 3
a152 3
#define	MNT_LOCAL	0x00002000	/* filesystem is stored locally */
#define	MNT_QUOTA	0x00004000	/* quotas are enabled on filesystem */
#define	MNT_ROOTFS	0x00008000	/* identifies the root filesystem */
@


1.12
log
@reclaim NFSMNT_RESVPORT bit, and add more traditional attribute cache timeout flags
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.10 1996/07/05 09:09:06 deraadt Exp $	*/
d136 1
d141 5
a145 5
#define	MNT_EXRDONLY	0x00000080	/* exported read only */
#define	MNT_EXPORTED	0x00000100	/* file system is exported */
#define	MNT_DEFEXPORTED	0x00000200	/* exported to the world */
#define	MNT_EXPORTANON	0x00000400	/* use anon uid mapping for everyone */
#define	MNT_EXKERB	0x00000800	/* exported with Kerberos uid mapping */
d150 3
a152 3
#define	MNT_LOCAL	0x00001000	/* filesystem is stored locally */
#define	MNT_QUOTA	0x00002000	/* quotas are enabled on filesystem */
#define	MNT_ROOTFS	0x00004000	/* identifies the root filesystem */
@


1.11
log
@NFS attribute cache timeout mount param
@
text
@d359 3
d377 3
a379 1
#define	NFSMNT_RESVPORT		0x00008000  /* Allocate a reserved port */
d384 4
a387 1
#define NFSMNT_ACTIMES		0x00040000  /* Args contain attr cache times*/
@


1.10
log
@overly pedantic indentation fix from theo who had a few beer
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.9 1996/07/05 06:52:32 mickey Exp $	*/
d309 1
a309 1
#define NFS_ARGSVERSION	3		/* change when nfs_args changes */
d329 25
d377 5
@


1.9
log
@Add NCPfs constants.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.8 1996/06/24 03:35:00 downsj Exp $	*/
d103 1
a103 1
#define MOUNT_EXT2FS	"ext2fs"	/* Second Extended Filesystem */
@


1.8
log
@ufs changes: add the notion of directory operators.

gnu/ext2fs: add the second extended filesystem.

Note that I'm commiting this now for the sake of the ufs changes; ext2fs
is not yet fully integrated into the system.
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.7 1996/04/18 21:41:00 niklas Exp $	*/
d104 1
@


1.7
log
@Merge of NetBSD 960317
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.6 1996/03/31 13:16:47 mickey Exp $	*/
d103 1
@


1.6
log
@From NetBSD: NFSv3 import (tomorrow's Net's kernel)
Open's patches kept in. i'll possibly take a look at Lite2 soon,
is there smth usefull ?..
@
text
@d1 1
a1 1
/*	$OpenBSD: mount.h,v 1.5 1996/02/29 13:57:27 niklas Exp $	*/
d374 1
a374 1
	mode_t	mask;		/* mask to be applied for msdosfs perms */
d377 1
@


1.5
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: mount.h,v 1.47 1996/02/09 18:25:16 christos Exp $	*/
a304 9
 * File Handle (32 bytes for version 2), variable up to 1024 for version 3
 */
union nfsv2fh {
	fhandle_t	fh_generic;
	u_char		fh_bytes[32];
};
typedef union nfsv2fh nfsv2fh_t;

/*
d307 1
d309 1
d314 2
a315 1
	nfsv2fh_t	*fh;		/* File handle to be mounted */
d319 1
d341 1
a341 1
#define	NFSMNT_MYWRITE		0x00000200  /* Assume writes were mine */
d344 10
a353 7
#define	NFSMNT_RDIRALOOK	0x00001000  /* Do lookup with readdir (nqnfs) */
#define	NFSMNT_LEASETERM	0x00002000  /* set lease term (nqnfs) */
#define	NFSMNT_READAHEAD	0x00004000  /* set read ahead */
#define	NFSMNT_DEADTHRESH	0x00008000  /* set dead server retry thresh */
#define	NFSMNT_NQLOOKLEASE	0x00010000  /* Get lease for lookup */
#define	NFSMNT_RESVPORT		0x00020000  /* Allocate a reserved port */
#define	NFSMNT_INTERNAL		0xffe00000  /* Bits set internally */
@


1.4
log
@from netbsd;
Instead of using '#ifdef atari' to handle the differences of Gemdosfs and
Msdosfs, use a flag that can be set by mount_msdos. This is definitely
more flexible.
Fix error in previous change: don't use the local FS mount data before
it's actually allocated. Pass mount arguments to msdosfs_mountfs instead,
and use them (as in iso_mountfs for example).
@
text
@d1 2
a2 1
/*	$NetBSD: mount.h,v 1.45 1996/01/19 14:29:25 leo Exp $	*/
d204 1
a204 1
	int	(*vfs_init)	__P((void));
d412 2
d417 6
a422 1

d432 1
a432 1
int	mount __P((char *, const char *, int, void *));
@


1.3
log
@from ws@@netbsd:
- Add support for Win'95 separate creation/modification/access timestamps
- Re-introduce lowercase filenames for non-Win'95-filesystems
@
text
@d1 1
a1 1
/*	$NetBSD: mount.h,v 1.44 1995/11/11 22:00:21 mycroft Exp $	*/
d384 1
@


1.2
log
@complete ufs -> ffs change (From John Kohl; PR #1403)
@
text
@d1 1
a1 1
/*	$NetBSD: mount.h,v 1.42.2.1 1995/11/01 00:06:31 jtc Exp $	*/
d85 2
a86 2
#define	MOUNT_FFS	"ffs"		/* Berkeley "Fast" Filesystem */
#define	MOUNT_UFS	MOUNT_FFS
d376 1
d378 6
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: mount.h,v 1.42 1995/06/29 10:05:16 cgd Exp $	*/
d85 2
a86 1
#define	MOUNT_UFS	"ufs"		/* UNIX "Fast" Filesystem */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
