head	1.10;
access;
symbols
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.4
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.8.0.6
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.4
	UBC:1.2.0.12
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.10
	OPENBSD_3_0_BASE:1.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.8
	OPENBSD_2_8:1.2.0.6
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.2;
locks; strict;
comment	@ * @;


1.10
date	2015.08.18.20.19.32;	author miod;	state Exp;
branches;
next	1.9;
commitid	V5l8faEbMLirvCIh;

1.9
date	2015.06.22.18.57.26;	author kettenis;	state Exp;
branches;
next	1.8;
commitid	E55PWdSNtZj8bfyG;

1.8
date	2013.12.19.21.30.02;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.24.04.26.16;	author mlarkin;	state Exp;
branches;
next	1.6;

1.6
date	2013.04.17.16.24.59;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.29.17.11.30;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.14.21.01.01;	author matthieu;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.11.20.13.47.55;	author matthieu;	state Exp;
branches
	1.2.2.1
	1.2.12.1;
next	1.1;

1.1
date	99.11.20.11.11.27;	author matthieu;	state Exp;
branches;
next	;

1.2.2.1
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	;

1.2.12.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.2.12.2;

1.2.12.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@typos
@
text
@/* $OpenBSD: memrange.h,v 1.9 2015/06/22 18:57:26 kettenis Exp $ */
/*-
 * Copyright (c) 1999 Michael Smith <msmith@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*
 * Memory range attribute operations, performed on /dev/mem
 */

/* Memory range attributes */
#define MDF_UNCACHEABLE		(1<<0)	/* region not cached */
#define MDF_WRITECOMBINE	(1<<1)	/* region supports "write combine" action */
#define MDF_WRITETHROUGH	(1<<2)	/* write-through cached */
#define MDF_WRITEBACK		(1<<3)	/* write-back cached */
#define MDF_WRITEPROTECT	(1<<4)	/* read-only region */
#define MDF_UNKNOWN		(1<<5)	/* any state we don't understand */
#define MDF_ATTRMASK		(0x00ffffff)

#define MDF_FIXBASE		(1<<24)	/* fixed base */
#define MDF_FIXLEN		(1<<25)	/* fixed length */
#define MDF_FIRMWARE		(1<<26)	/* set by firmware (XXX not useful?) */
#define MDF_ACTIVE		(1<<27)	/* currently active */
#define MDF_BOGUS		(1<<28)	/* we don't like it */
#define MDF_FIXACTIVE		(1<<29)	/* can't be turned off */
#define MDF_FORCE		(1<<31)	/* force risky changes */

struct mem_range_desc {
	u_int64_t	mr_base;
	u_int64_t	mr_len;
	int		mr_flags;
	char		mr_owner[8];
};

struct mem_range_op {
	struct mem_range_desc	*mo_desc;
	int			mo_arg[2];
#define MEMRANGE_SET_UPDATE	0
#define MEMRANGE_SET_REMOVE	1
	/* XXX want a flag that says "set and undo when I exit" */
};

#define MEMRANGE_GET	_IOWR('m', 50, struct mem_range_op)
#define MEMRANGE_SET	_IOW('m', 51, struct mem_range_op)

/* Offset indicating a write combining mapping is requested.  */
#define MEMRANGE_WC_RANGE	0x4000000000000000ULL

#ifdef _KERNEL

struct mem_range_softc;
struct mem_range_ops {
	void	(*init)(struct mem_range_softc *sc);
	int	(*set)(struct mem_range_softc *sc,
		    struct mem_range_desc *mrd, int *arg);
	void	(*initAP)(struct mem_range_softc *sc);
	void	(*reload)(struct mem_range_softc *sc);
};

struct mem_range_softc {
	struct mem_range_ops	*mr_op;
	int			mr_cap;
	int			mr_ndesc;
	struct mem_range_desc 	*mr_desc;
};

extern struct mem_range_softc mem_range_softc;

__BEGIN_DECLS
extern void mem_range_attach(void);
extern int mem_range_attr_get(struct mem_range_desc *mrd, int *arg);
extern int mem_range_attr_set(struct mem_range_desc *mrd, int *arg);
extern void mem_range_AP_init(void);
extern void mem_range_reload(void);
__END_DECLS
#endif /* _KERNEL */

@


1.9
log
@Make it possible to create write combing mappings through /dev/mem.  This is
done by introducining a magic offset.  Pages below this offset are mapped
with default memory attributes.  Above this offset pages are mapped write
combining.

ok mlarkin@@
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.8 2013/12/19 21:30:02 deraadt Exp $ */
d28 1
a28 1
 * Memory range attribute operations, peformed on /dev/mem
@


1.8
log
@Mtrr stops being a pseudo-device.  We need to probe the cpu type and
initialize the structures when we see the first cpu.  We also need to
initialize each cpu's properly (for PAT) before we setup mtrr on that
cpu.  On i386 (late hatch) we were getting this desperately wrong on
the primary cpu.

After suspend/resume, we also need to do the same work.  re-initialize
PAT before mtrr.  On some laptops apparently PAT was not turned on by the
BIOS, so we ended up with incorrect setup for the primary cpu.  Oops.

This makes mplayer on the x201 (and similar) machines work without weird
pauses after a suspend/resume.  Many other things are likely fixed.
ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.7 2013/08/24 04:26:16 mlarkin Exp $ */
d65 3
@


1.7
log
@

Cleanup amd64 and i386 MTRR code -

1. Makes amd64 and i386 MTRR code nearly identical
2. Removes support for per-process MTRRs (which were never implemented)
3. Treat "unknown" MTRR types as uncacheable instead of trying to preserve
bogus settings made by the BIOS
4. Various KNF cleanups

Should be no functional change.

ok jsg@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.6 2013/04/17 16:24:59 deraadt Exp $ */
d87 1
@


1.6
log
@pretty
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.5 2009/11/29 17:11:30 kettenis Exp $ */
a45 1
#define MDF_BUSY		(1<<30)	/* range is in use */
@


1.5
log
@Reload mtrr state on all CPUs after updates.  Seems to speed up X on MP
systems, at least with Intel graphics.

ok marco@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.4 2002/10/14 21:01:01 matthieu Exp $ */
d49 1
a49 2
struct mem_range_desc
{
d56 1
a56 2
struct mem_range_op
{
d70 1
a70 2
struct mem_range_ops
{
d72 3
a74 2
	int	(*set)(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg);
    	void	(*initAP)(struct mem_range_softc *sc);
d78 1
a78 2
struct mem_range_softc 
{
d93 1
a93 1
#endif
@


1.4
log
@Fix from FreeBSD for atlhon problems with mtrr and XFree86. Ok deraadt@@

FreeBSD commit messages say:

Some BIOSs are using MTRR values that are only documented under NDA
to control the mapping of things like the ACPI and APM into memory.

The problem is that starting X changes these values, so if something
was using the bits of BIOS mapped into memory (say ACPI or APM),
then next time they access this memory the machine would hang.

This patch refuse to change MTRR values it doesn't understand,
unless a new "force" option is given. This means X doesn't change
them by accident but someone can override that if they really want
to.

PR:             28418
Tested by:      Christopher Masto <chris at netmonger dot net>,
                David Bushong <david at bushong dot net>,
                Santos <casd at myrealbox dot com>


Make the MTRR code a bit more defensive - this should help people
trying to run X on some Athlon systems where the BIOS does odd things
(mines an ASUS A7A266, but it seems to also help on other systems).

Here's a description of the problem and my fix:

        The problem with the old MTRR code is that it only expects
        to find documented values in the bytes of MTRR registers.
        To convert the MTRR byte into a FreeBSD "Memory Range Type"
        (mrt) it uses the byte value and looks it up in an array.
        If the value is not in range then the mrt value ends up
        containing random junk.

        This isn't an immediate problem. The mrt value is only used
        later when rewriting the MTRR registers. When we finally
        go to write a value back again, the function i686_mtrrtype()
        searches for the junk value and returns -1 when it fails
        to find it. This is converted to a byte (0xff) and written
        back to the register, causing a GPF as 0xff is an illegal
        value for a MTRR byte.

        To work around this problem I've added a new mrt flag
        MDF_UNKNOWN.  We set this when we read a MTRR byte which
        we do not understand.  If we try to convert a MDF_UNKNOWN
        back into a MTRR value, then the new function, i686_mrt2mtrr,
        just returns the old value of the MTRR byte. This leaves
        the memory range type unchanged.

I have seen one side effect of the fix, which is that ACPI calls
after X has been run seem to hang my machine. As running X would
previously panic the machine, this is still an improvement ;-)

PR:             28418, 25958
Tested by:      jkh, Christopher Masto <chris at netmonger dot net>
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.3 2002/03/14 01:27:14 millert Exp $ */
d77 1
d94 1
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.2 1999/11/20 13:47:55 matthieu Exp $ */
d37 1
d47 1
@


1.2
log
@add copyright notice
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.1 1999/11/20 11:11:27 matthieu Exp $ */
d72 3
a74 3
	void	(*init) __P((struct mem_range_softc *sc));
	int	(*set) __P((struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg));
    	void	(*initAP) __P((struct mem_range_softc *sc));
d88 3
a90 3
extern int mem_range_attr_get __P((struct mem_range_desc *mrd, int *arg));
extern int mem_range_attr_set __P((struct mem_range_desc *mrd, int *arg));
extern void mem_range_AP_init __P((void));
@


1.2.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.2 1999/11/20 13:47:55 matthieu Exp $ */
d72 3
a74 3
	void	(*init)(struct mem_range_softc *sc);
	int	(*set)(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg);
    	void	(*initAP)(struct mem_range_softc *sc);
d88 3
a90 3
extern int mem_range_attr_get(struct mem_range_desc *mrd, int *arg);
extern int mem_range_attr_set(struct mem_range_desc *mrd, int *arg);
extern void mem_range_AP_init(void);
@


1.2.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: memrange.h,v 1.2.12.1 2002/06/11 03:32:33 art Exp $ */
a36 1
#define MDF_UNKNOWN		(1<<5)	/* any state we don't understand */
a45 1
#define MDF_FORCE		(1<<31)	/* force risky changes */
@


1.2.2.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d72 3
a74 3
	void	(*init)(struct mem_range_softc *sc);
	int	(*set)(struct mem_range_softc *sc, struct mem_range_desc *mrd, int *arg);
    	void	(*initAP)(struct mem_range_softc *sc);
d88 3
a90 3
extern int mem_range_attr_get(struct mem_range_desc *mrd, int *arg);
extern int mem_range_attr_set(struct mem_range_desc *mrd, int *arg);
extern void mem_range_AP_init(void);
@


1.2.2.2
log
@Sync the SMP branch with 3.3
@
text
@a36 1
#define MDF_UNKNOWN		(1<<5)	/* any state we don't understand */
a45 1
#define MDF_FORCE		(1<<31)	/* force risky changes */
@


1.1
log
@add MTRR support from FreeBSD
@
text
@d1 26
a26 1
/* $OpenBSD$ */
@

