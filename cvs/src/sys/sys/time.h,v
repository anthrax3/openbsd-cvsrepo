head	1.36;
access;
symbols
	OPENBSD_6_0:1.35.0.12
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.8
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.10
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.35.0.6
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.2
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.28.0.2
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.10
	OPENBSD_5_0:1.26.0.8
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.26.0.6
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.12
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.8
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.6
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.4
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.2
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.4
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.6
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.4
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.6.0.4
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.36
date	2016.09.12.19.41.20;	author guenther;	state Exp;
branches;
next	1.35;
commitid	rDEbJJHj0O4ilibK;

1.35
date	2013.10.25.04.42.48;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.24.07.34.56;	author guenther;	state Exp;
branches;
next	1.33;

1.33
date	2013.09.14.01.35.02;	author guenther;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.13.05.52.27;	author guenther;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.10.03.05.35;	author guenther;	state Exp;
branches;
next	1.30;

1.30
date	2013.04.29.17.06.20;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2012.12.05.23.20.24;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2012.05.10.19.13.12;	author kettenis;	state Exp;
branches;
next	1.27;

1.27
date	2012.05.07.22.34.01;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2009.11.27.19.45.54;	author guenther;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.09.17.42.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.06.29.23.09.03;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.14.19.52.07;	author otto;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.29.00.28.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.19.35.26;	author tholo;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.17;

1.17
date	2003.08.14.05.34.47;	author kevlo;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.11.05.37.59;	author kevlo;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.22;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.22.18.27;	author nordin;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.09.02.18.00;	author millert;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	2000.10.10.13.36.48;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.17.22.24.27;	author jakob;	state Exp;
branches;
next	1.9;

1.9
date	99.12.06.19.36.42;	author aaron;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	98.11.21.03.01.03;	author d;	state Exp;
branches;
next	1.7;

1.7
date	98.02.08.22.41.47;	author tholo;	state Exp;
branches;
next	1.6;

1.6
date	97.04.25.03.55.20;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	97.04.22.00.40.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.20.20.47.34;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.13.14.04;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.13.57.31;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.30;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2000.03.24.09.09.45;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.14.22.45.04;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.28.14.52.02;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.06.07.11.09.08;	author ho;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2004.02.19.11.01.35;	author niklas;	state Exp;
branches;
next	;

1.12.6.1
date	2002.06.11.03.32.34;	author art;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@More #include cleanup per POSIX:
 - <sys/types.h>: don't pull in <sys/select.h>
 - <sys/select.h>: don't pull in <sys/time.h>, but rather declare timeval
   and timespec locally
 - <sys/time.h>: *do* always pull in <sys/select.h>
 - <sys/socket.h>: declare timeval if __BSD_VISIBLE for struct splice

Ports testing and fixed by ajacoutot@@
ok deraadt@@ millert@@
@
text
@/*	$OpenBSD: time.h,v 1.35 2013/10/25 04:42:48 guenther Exp $	*/
/*	$NetBSD: time.h,v 1.18 1996/04/23 10:29:33 mycroft Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)time.h	8.2 (Berkeley) 7/10/94
 */

#ifndef _SYS_TIME_H_
#define _SYS_TIME_H_

#include <sys/select.h>

#ifndef _TIMEVAL_DECLARED
#define _TIMEVAL_DECLARED
/*
 * Structure returned by gettimeofday(2) system call,
 * and used in other calls.
 */
struct timeval {
	time_t		tv_sec;		/* seconds */
	suseconds_t	tv_usec;	/* and microseconds */
};
#endif

#ifndef _TIMESPEC_DECLARED
#define _TIMESPEC_DECLARED
/*
 * Structure defined by POSIX.1b to be like a timeval.
 */
struct timespec {
	time_t	tv_sec;		/* seconds */
	long	tv_nsec;	/* and nanoseconds */
};
#endif

#define	TIMEVAL_TO_TIMESPEC(tv, ts) {					\
	(ts)->tv_sec = (tv)->tv_sec;					\
	(ts)->tv_nsec = (tv)->tv_usec * 1000;				\
}
#define	TIMESPEC_TO_TIMEVAL(tv, ts) {					\
	(tv)->tv_sec = (ts)->tv_sec;					\
	(tv)->tv_usec = (ts)->tv_nsec / 1000;				\
}

struct timezone {
	int	tz_minuteswest;	/* minutes west of Greenwich */
	int	tz_dsttime;	/* type of dst correction */
};
#define	DST_NONE	0	/* not on dst */
#define	DST_USA		1	/* USA style dst */
#define	DST_AUST	2	/* Australian style dst */
#define	DST_WET		3	/* Western European dst */
#define	DST_MET		4	/* Middle European dst */
#define	DST_EET		5	/* Eastern European dst */
#define	DST_CAN		6	/* Canada */

/* Operations on timevals. */
#define	timerclear(tvp)		(tvp)->tv_sec = (tvp)->tv_usec = 0
#define	timerisset(tvp)		((tvp)->tv_sec || (tvp)->tv_usec)
#define	timercmp(tvp, uvp, cmp)						\
	(((tvp)->tv_sec == (uvp)->tv_sec) ?				\
	    ((tvp)->tv_usec cmp (uvp)->tv_usec) :			\
	    ((tvp)->tv_sec cmp (uvp)->tv_sec))
#define	timeradd(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;	\
		if ((vvp)->tv_usec >= 1000000) {			\
			(vvp)->tv_sec++;				\
			(vvp)->tv_usec -= 1000000;			\
		}							\
	} while (0)
#define	timersub(tvp, uvp, vvp)						\
	do {								\
		(vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec;		\
		(vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec;	\
		if ((vvp)->tv_usec < 0) {				\
			(vvp)->tv_sec--;				\
			(vvp)->tv_usec += 1000000;			\
		}							\
	} while (0)

/* Operations on timespecs. */
#define	timespecclear(tsp)		(tsp)->tv_sec = (tsp)->tv_nsec = 0
#define	timespecisset(tsp)		((tsp)->tv_sec || (tsp)->tv_nsec)
#define	timespeccmp(tsp, usp, cmp)					\
	(((tsp)->tv_sec == (usp)->tv_sec) ?				\
	    ((tsp)->tv_nsec cmp (usp)->tv_nsec) :			\
	    ((tsp)->tv_sec cmp (usp)->tv_sec))
#define	timespecadd(tsp, usp, vsp)					\
	do {								\
		(vsp)->tv_sec = (tsp)->tv_sec + (usp)->tv_sec;		\
		(vsp)->tv_nsec = (tsp)->tv_nsec + (usp)->tv_nsec;	\
		if ((vsp)->tv_nsec >= 1000000000L) {			\
			(vsp)->tv_sec++;				\
			(vsp)->tv_nsec -= 1000000000L;			\
		}							\
	} while (0)
#define	timespecsub(tsp, usp, vsp)					\
	do {								\
		(vsp)->tv_sec = (tsp)->tv_sec - (usp)->tv_sec;		\
		(vsp)->tv_nsec = (tsp)->tv_nsec - (usp)->tv_nsec;	\
		if ((vsp)->tv_nsec < 0) {				\
			(vsp)->tv_sec--;				\
			(vsp)->tv_nsec += 1000000000L;			\
		}							\
	} while (0)

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */
#define	ITIMER_REAL	0
#define	ITIMER_VIRTUAL	1
#define	ITIMER_PROF	2

struct	itimerval {
	struct	timeval it_interval;	/* timer interval */
	struct	timeval it_value;	/* current value */
};

#if __BSD_VISIBLE
/*
 * clock information structure for sysctl({CTL_KERN, KERN_CLOCKRATE})
 */
struct clockinfo {
	int	hz;		/* clock frequency */
	int	tick;		/* micro-seconds per hz tick */
	int	tickadj;	/* clock skew rate for adjtime() */
	int	stathz;		/* statistics clock frequency */
	int	profhz;		/* profiling clock frequency */
};
#endif /* __BSD_VISIBLE */

#if defined(_KERNEL) || defined(_STANDALONE)
#include <sys/_time.h>

/* Time expressed as seconds and fractions of a second + operations on it. */
struct bintime {
	time_t	sec;
	uint64_t frac;
};

static __inline void
bintime_addx(struct bintime *bt, uint64_t x)
{
	uint64_t u;

	u = bt->frac;
	bt->frac += x;
	if (u > bt->frac)
		bt->sec++;
}

static __inline void
bintime_add(struct bintime *bt, struct bintime *bt2)
{
	uint64_t u;

	u = bt->frac;
	bt->frac += bt2->frac;
	if (u > bt->frac)
		bt->sec++;
	bt->sec += bt2->sec;
}

static __inline void
bintime_sub(struct bintime *bt, struct bintime *bt2)
{
	uint64_t u;

	u = bt->frac;
	bt->frac -= bt2->frac;
	if (u < bt->frac)
		bt->sec--;
	bt->sec -= bt2->sec;
}

/*-
 * Background information:
 *
 * When converting between timestamps on parallel timescales of differing
 * resolutions it is historical and scientific practice to round down rather
 * than doing 4/5 rounding.
 *
 *   The date changes at midnight, not at noon.
 *
 *   Even at 15:59:59.999999999 it's not four'o'clock.
 *
 *   time_second ticks after N.999999999 not after N.4999999999
 */

static __inline void
bintime2timespec(struct bintime *bt, struct timespec *ts)
{

	ts->tv_sec = bt->sec;
	ts->tv_nsec = (long)(((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}

static __inline void
timespec2bintime(struct timespec *ts, struct bintime *bt)
{

	bt->sec = ts->tv_sec;
	/* 18446744073 = int(2^64 / 1000000000) */
	bt->frac = (uint64_t)ts->tv_nsec * (uint64_t)18446744073ULL; 
}

static __inline void
bintime2timeval(struct bintime *bt, struct timeval *tv)
{

	tv->tv_sec = bt->sec;
	tv->tv_usec = (long)(((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32);
}

static __inline void
timeval2bintime(struct timeval *tv, struct bintime *bt)
{

	bt->sec = (time_t)tv->tv_sec;
	/* 18446744073709 = int(2^64 / 1000000) */
	bt->frac = (uint64_t)tv->tv_usec * (uint64_t)18446744073709ULL;
}

extern volatile time_t time_second;	/* Seconds since epoch, wall time. */
extern volatile time_t time_uptime;	/* Seconds since reboot. */

/*
 * Functions for looking at our clock: [get]{bin,nano,micro}[up]time()
 *
 * Functions without the "get" prefix returns the best timestamp
 * we can produce in the given format.
 *
 * "bin"   == struct bintime  == seconds + 64 bit fraction of seconds.
 * "nano"  == struct timespec == seconds + nanoseconds.
 * "micro" == struct timeval  == seconds + microseconds.
 *              
 * Functions containing "up" returns time relative to boot and
 * should be used for calculating time intervals.
 *
 * Functions without "up" returns GMT time.
 *
 * Functions with the "get" prefix returns a less precise result
 * much faster than the functions without "get" prefix and should
 * be used where a precision of 10 msec is acceptable or where
 * performance is priority. (NB: "precision", _not_ "resolution" !) 
 */

void	bintime(struct bintime *);
void	nanotime(struct timespec *);
void	microtime(struct timeval *);

void	getnanotime(struct timespec *);
void	getmicrotime(struct timeval *);

void	binuptime(struct bintime *);
void	nanouptime(struct timespec *);
void	microuptime(struct timeval *);

void	getnanouptime(struct timespec *);
void	getmicrouptime(struct timeval *);

struct proc;
int	clock_gettime(struct proc *, clockid_t, struct timespec *);

int	timespecfix(struct timespec *);
int	itimerfix(struct timeval *);
int	itimerdecr(struct itimerval *itp, int usec);
void	itimerround(struct timeval *);
int	settime(struct timespec *);
int	ratecheck(struct timeval *, const struct timeval *);
int	ppsratecheck(struct timeval *, int *, int);

/*
 * "POSIX time" to/from "YY/MM/DD/hh/mm/ss"
 */
struct clock_ymdhms {
        u_short dt_year;
        u_char dt_mon;
        u_char dt_day;
        u_char dt_wday; /* Day of week */
        u_char dt_hour;
        u_char dt_min;
        u_char dt_sec;
};

time_t clock_ymdhms_to_secs(struct clock_ymdhms *);
void clock_secs_to_ymdhms(time_t, struct clock_ymdhms *);
/*
 * BCD to decimal and decimal to BCD.
 */
#define FROMBCD(x)      (((x) >> 4) * 10 + ((x) & 0xf))
#define TOBCD(x)        (((x) / 10 * 16) + ((x) % 10))

/* Some handy constants. */
#define SECDAY          86400L
#define SECYR           (SECDAY * 365)

/* Traditional POSIX base year */
#define POSIX_BASE_YEAR 1970

#else /* !_KERNEL */
#include <time.h>

#if __BSD_VISIBLE || __XPG_VISIBLE
__BEGIN_DECLS
#if __BSD_VISIBLE
int	adjtime(const struct timeval *, struct timeval *);
int	adjfreq(const int64_t *, int64_t *);
#endif
#if __XPG_VISIBLE
int	futimes(int, const struct timeval *);
int	getitimer(int, struct itimerval *);
int	gettimeofday(struct timeval *, struct timezone *);
int	setitimer(int, const struct itimerval *, struct itimerval *);
int	settimeofday(const struct timeval *, const struct timezone *);
int	utimes(const char *, const struct timeval *);
#endif /* __XPG_VISIBLE */
__END_DECLS
#endif /* __BSD_VISIBLE || __XPG_VISIBLE */

#endif /* !_KERNEL */

#endif /* !_SYS_TIME_H_ */
@


1.35
log
@Move the declarations for dogetrusage(), itimerround(), and dowait4()
to sys/*.h headers so that the compat/linux code can use them.
Change dowait4() to not copyout() the status value, but rather leave
that for its caller, as compat/linux has to translate it, with the
side benefit of simplifying the native code.

Originally written months ago as part of the time_t work; long
memory, prodding, and ok from pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.34 2013/10/24 07:34:56 guenther Exp $	*/
d38 1
a38 1
#include <sys/types.h>
d40 2
d50 1
a332 4

#if __XPG_VISIBLE >= 420 && __XPG_VISIBLE < 600
#include <sys/select.h>	/* must be after type declarations */
#endif
@


1.34
log
@Align suseconds_t with POSIX: it's the type of the tv_usec member of timeval.
Use useconds_t in the ualarm() declaration.
Bump libstdc++ major to be sure there isn't ABI issues.

ok deraadt@@ jca@@ jmc@@ millert@@
ports testing by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.33 2013/09/14 01:35:02 guenther Exp $	*/
d295 1
@


1.33
log
@Snapshots for all archs have been built, so remove the T32 code
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.32 2013/08/13 05:52:27 guenther Exp $	*/
d45 2
a46 2
	time_t	tv_sec;		/* seconds */
	long	tv_usec;	/* and microseconds */
@


1.32
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.31 2013/07/10 03:05:35 guenther Exp $	*/
a47 14
#ifdef _KERNEL
struct timeval32 {
	long	tv_sec;		/* seconds */
	long	tv_usec;	/* and microseconds */
};
#define TIMEVAL_FROM_32(tv, tv32) {		\
	(tv)->tv_sec = (tv32)->tv_sec;		\
	(tv)->tv_usec = (tv32)->tv_usec;	\
}
#define TIMEVAL_TO_32(tv32, tv) {		\
	(tv32)->tv_sec = (tv)->tv_sec;		\
	(tv32)->tv_usec = (tv)->tv_usec;	\
}
#endif
a57 18
#ifdef _KERNEL
struct timespec32 {
	time32_t tv_sec;	/* seconds */
	long	 tv_nsec;	/* and nanoseconds */
};
#define TIMESPEC_FROM_32(ts, ts32) {		\
	(ts)->tv_sec = (ts32)->tv_sec;		\
	(ts)->tv_nsec = (ts32)->tv_nsec;	\
}
#define TIMESPEC_TO_32(ts32, ts) {		\
	(ts32)->tv_sec = (ts)->tv_sec;		\
	(ts32)->tv_nsec = (ts)->tv_nsec;	\
}
#define TIMESPEC_FROM_TIMEVAL32(ts, tv32) {	\
	(ts)->tv_sec = (tv32)->tv_sec;		\
	(ts)->tv_nsec = (tv32)->tv_usec * 1000;	\
}
#endif
a144 14
#ifdef _KERNEL
struct	itimerval32 {
	struct	timeval32 it_interval;	/* timer interval */
	struct	timeval32 it_value;	/* current value */
};
#define ITIMERVAL_FROM_32(it, it32) {					\
	TIMEVAL_FROM_32(&(it)->it_interval, &(it32)->it_interval);	\
	TIMEVAL_FROM_32(&(it)->it_value, &(it32)->it_value);		\
}
#define ITIMERVAL_TO_32(it32, it) {					\
	TIMEVAL_TO_32(&(it32)->it_interval, &(it)->it_interval);	\
	TIMEVAL_TO_32(&(it32)->it_value, &(it)->it_value);		\
}
#endif
@


1.31
log
@struct bintime is only used inside the kernel, while struct clockinfo is
only used with the BSD-specific sysctl(), so put them behind the proper
#if conditionals.

ports scan sthen@@
ok matthew@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.30 2013/04/29 17:06:20 matthew Exp $	*/
d45 5
d53 9
d72 18
d177 14
@


1.30
log
@Extend P_SIGSUSPEND handling in userret() to properly restore the
sigmask even if there are no pending signals under the temporary
sigmask.

Refactor existing select() and poll() system calls to introduce the
pselect() and ppoll() system calls.

Add rthread wrappers for pselect() and ppoll().  While there, update
cancellation point comments to reflect recent fdatasync() addition.

Minor bumps for libc and librthread due to new symbols.

ok guenther, millert, deraadt, jmc
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.29 2012/12/05 23:20:24 deraadt Exp $	*/
d133 29
a249 27

/*
 * Names of the interval timers, and structure
 * defining a timer setting.
 */
#define	ITIMER_REAL	0
#define	ITIMER_VIRTUAL	1
#define	ITIMER_PROF	2

struct	itimerval {
	struct	timeval it_interval;	/* timer interval */
	struct	timeval it_value;	/* current value */
};

/*
 * Getkerninfo clock information structure
 */
struct clockinfo {
	int	hz;		/* clock frequency */
	int	tick;		/* micro-seconds per hz tick */
	int	tickadj;	/* clock skew rate for adjtime() */
	int	stathz;		/* statistics clock frequency */
	int	profhz;		/* profiling clock frequency */
};

#if defined(_KERNEL) || defined(_STANDALONE)
#include <sys/_time.h>
@


1.29
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.28 2012/05/10 19:13:12 kettenis Exp $	*/
a39 4
#if __XPG_VISIBLE >= 420 && __XPG_VISIBLE < 600
#include <sys/select.h>
#endif

d327 4
@


1.28
log
@Recongnize that:

* strptime(3) was introduced in XPG 4.0
* clock_gettime(3) and friends were introduced in 1003.1b-1993
* asctime_r(3) and friends were introduced in 1003.1c-1995

and conditionally provide prototypes and associated types accordingly.
This makes our <time.h> standards compliant except for some functions that are
still missing.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.27 2012/05/07 22:34:01 kettenis Exp $	*/
a37 1
#include <sys/cdefs.h>
@


1.27
log
@Once more the people behind POSIX didn't think and put clock_gettime(2) and
friends in <time.h>.  The kernel needs access to the associated #defines, but
can't get them from <time.h>, so introduce a new header <sys/_time.h> and
include that from <time.h> for userland and <sys/time.h> for the kernel.

ok matthew@@, guenther@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.26 2009/11/27 19:45:54 guenther Exp $	*/
a237 9
};

/*
 * Structure defined by POSIX 1003.1b to be like a itimerval,
 * but with timespecs. Used in the timer_*() system calls.
 */
struct  itimerspec {
	struct  timespec it_interval;	/* timer interval */
	struct  timespec it_value;	/* timer expiration */
@


1.26
log
@Convert thrsleep() to an absolute timeout with clockid to eliminate a
race condition and prep for later support of pthread_condattr_setclock()

"get it in" deraadt@@, tedu@@, cheers by others
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.25 2007/05/09 17:42:19 deraadt Exp $	*/
d260 2
a261 7
#define CLOCK_REALTIME	0
#define CLOCK_VIRTUAL	1
#define CLOCK_PROF	2
#define	CLOCK_MONOTONIC	3

#define TIMER_RELTIME	0x0	/* relative timer */
#define TIMER_ABSTIME	0x1	/* absolute timer */
a262 1
#if defined(_KERNEL) || defined(_STANDALONE)
a348 3
int	clock_getres(clockid_t, struct timespec *);
int	clock_gettime(clockid_t, struct timespec *);
int	clock_settime(clockid_t, const struct timespec *);
@


1.25
log
@unused apis, very dangerous: getbinuptime() getbintime(),  ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.24 2006/06/29 23:09:03 deraadt Exp $	*/
d307 4
@


1.24
log
@two typecasts which make lint warn a lot less; ok kettenis
otto went further, and verified that the operation is exactly the
same in C, and that it is currently only our lint that is being
a whiner -- but it is a loud enough whine that we should silence it
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.23 2006/06/19 15:13:35 deraadt Exp $	*/
a296 1
void	getbintime(struct bintime *);
a303 1
void	getbinuptime(struct bintime *);
@


1.23
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.22 2006/06/14 19:52:07 otto Exp $	*/
d207 1
a207 1
	bt->frac = ts->tv_nsec * (uint64_t)18446744073ULL; 
d224 1
a224 1
	bt->frac = tv->tv_usec * (uint64_t)18446744073709ULL;
@


1.22
log
@Introducing adjfreq(2), to adjust the clock frequency.
Loosely based on dragonfly code. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.21 2005/12/13 00:35:23 millert Exp $	*/
d207 1
a207 1
	bt->frac = ts->tv_nsec * (uint64_t)18446744073LL; 
d224 1
a224 1
	bt->frac = tv->tv_usec * (uint64_t)18446744073709LL;
d314 29
@


1.21
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.20 2005/11/29 00:28:18 deraadt Exp $	*/
d321 1
@


1.20
log
@add some casts to please lint.  these are the typical tv_sec vs time_t
problems.  in time, we will move to 64 bit time_t, when the time is right
(ha ha) but not before.  These casts do not harm the future model.
ok cloder millert
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.19 2004/06/24 19:35:26 tholo Exp $	*/
d38 1
d41 4
d54 2
d63 1
d317 1
a317 3
#ifndef _POSIX_SOURCE
#include <sys/cdefs.h>

d319 1
d321 2
d332 1
d334 1
a334 1
#endif /* !POSIX */
@


1.19
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.18 2004/06/21 23:50:38 tholo Exp $	*/
d190 1
a190 1
	ts->tv_nsec = ((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32;
d207 1
a207 1
	tv->tv_usec = ((uint64_t)1000000 * (uint32_t)(bt->frac >> 32)) >> 32;
d214 1
a214 1
	bt->sec = tv->tv_sec;
@


1.18
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.17 2003/08/14 05:34:47 kevlo Exp $	*/
d130 89
d264 38
a301 1
int	itimerfix(struct timeval *tv);
d303 1
a303 2
void	microtime(struct timeval *tv);
int	settime(struct timeval *tv);
@


1.17
log
@add itimerspec data structure, defined by POSIX 1003.1b. ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.16 2003/08/11 05:37:59 kevlo Exp $	*/
d172 3
@


1.16
log
@implement CLOCK_MONOTONIC from NetBSD; ok marc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.15 2003/06/02 23:28:22 millert Exp $	*/
d141 9
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.14 2002/07/25 22:18:27 nordin Exp $	*/
d157 1
@


1.14
log
@Avoid time wrap at securelevel 2. ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.13 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.12 2001/03/09 02:18:00 millert Exp $	*/
d169 1
a169 1
void	settime(struct timeval *tv);
@


1.12
log
@Move nanosleep() proto to from sys/time.h to time.h where it belongs.
Problem noted by Jean-Baptiste Marchand
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.11 2000/10/10 13:36:48 itojun Exp $	*/
d166 6
a171 6
int	itimerfix __P((struct timeval *tv));
int	itimerdecr __P((struct itimerval *itp, int usec));
void	microtime __P((struct timeval *tv));
void	settime __P((struct timeval *tv));
int	ratecheck __P((struct timeval *, const struct timeval *));
int	ppsratecheck __P((struct timeval *, int *, int));
d179 10
a188 10
int	adjtime __P((const struct timeval *, struct timeval *));
int	clock_getres __P((clockid_t, struct timespec *));
int	clock_gettime __P((clockid_t, struct timespec *));
int	clock_settime __P((clockid_t, const struct timespec *));
int	futimes __P((int, const struct timeval *));
int	getitimer __P((int, struct itimerval *));
int	gettimeofday __P((struct timeval *, struct timezone *));
int	setitimer __P((int, const struct itimerval *, struct itimerval *));
int	settimeofday __P((const struct timeval *, const struct timezone *));
int	utimes __P((const char *, const struct timeval *));
@


1.12.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.12 2001/03/09 02:18:00 millert Exp $	*/
d166 6
a171 6
int	itimerfix(struct timeval *tv);
int	itimerdecr(struct itimerval *itp, int usec);
void	microtime(struct timeval *tv);
void	settime(struct timeval *tv);
int	ratecheck(struct timeval *, const struct timeval *);
int	ppsratecheck(struct timeval *, int *, int);
d179 10
a188 10
int	adjtime(const struct timeval *, struct timeval *);
int	clock_getres(clockid_t, struct timespec *);
int	clock_gettime(clockid_t, struct timespec *);
int	clock_settime(clockid_t, const struct timespec *);
int	futimes(int, const struct timeval *);
int	getitimer(int, struct itimerval *);
int	gettimeofday(struct timeval *, struct timezone *);
int	setitimer(int, const struct itimerval *, struct itimerval *);
int	settimeofday(const struct timeval *, const struct timezone *);
int	utimes(const char *, const struct timeval *);
@


1.12.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.12.6.1 2002/06/11 03:32:34 art Exp $	*/
d169 1
a169 1
int	settime(struct timeval *tv);
@


1.11
log
@implement ppsratecheck(9).  from netbsd.
refer mono_time only once in ratecheck(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.10 2000/03/17 22:24:27 jakob Exp $	*/
a185 1
int	nanosleep __P((const struct timespec *, struct timespec *));
@


1.10
log
@ratecheck - function to help implement rate-limited actions (from NetBSD)
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.9 1999/12/06 19:36:42 aaron Exp $	*/
d171 1
@


1.9
log
@Implement compatibility for Linux stime() syscall.
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.8 1998/11/21 03:01:03 d Exp $	*/
d170 1
@


1.9.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a169 1
int	ratecheck __P((struct timeval *, const struct timeval *));
@


1.9.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.12 2001/03/09 02:18:00 millert Exp $	*/
a170 1
int	ppsratecheck __P((struct timeval *, int *, int));
d185 1
@


1.9.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d166 6
a171 6
int	itimerfix(struct timeval *tv);
int	itimerdecr(struct itimerval *itp, int usec);
void	microtime(struct timeval *tv);
void	settime(struct timeval *tv);
int	ratecheck(struct timeval *, const struct timeval *);
int	ppsratecheck(struct timeval *, int *, int);
d179 10
a188 10
int	adjtime(const struct timeval *, struct timeval *);
int	clock_getres(clockid_t, struct timespec *);
int	clock_gettime(clockid_t, struct timespec *);
int	clock_settime(clockid_t, const struct timespec *);
int	futimes(int, const struct timeval *);
int	getitimer(int, struct itimerval *);
int	gettimeofday(struct timeval *, struct timezone *);
int	setitimer(int, const struct itimerval *, struct itimerval *);
int	settimeofday(const struct timeval *, const struct timezone *);
int	utimes(const char *, const struct timeval *);
@


1.9.2.4
log
@Sync the SMP branch with 3.3
@
text
@d169 1
a169 1
int	settime(struct timeval *tv);
@


1.9.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.9.2.4 2003/03/28 00:41:30 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a143 9
 * Structure defined by POSIX 1003.1b to be like a itimerval,
 * but with timespecs. Used in the timer_*() system calls.
 */
struct  itimerspec {
	struct  timespec it_interval;	/* timer interval */
	struct  timespec it_value;	/* timer expiration */
};

/*
a156 1
#define	CLOCK_MONOTONIC	3
@


1.8
log
@prototype clock_{gettime,settime,getres}
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.7 1998/02/08 22:41:47 tholo Exp $	*/
d169 1
@


1.7
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.6 1997/04/25 03:55:20 tholo Exp $	*/
d177 3
@


1.6
log
@Prototype nanosleep(2)
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.5 1997/04/22 00:40:17 mickey Exp $	*/
d180 1
a180 1
int	nanosleep __P((struct timespec *, struct timespec *));
@


1.5
log
@hide some pieces under _STANDALONE
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.4 1997/04/20 20:47:34 tholo Exp $	*/
d180 1
@


1.4
log
@Add macros and types needed for POSIX 1003.1b timers
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.3 1996/05/02 13:14:04 deraadt Exp $	*/
d165 1
a165 1
#ifdef _KERNEL
@


1.3
log
@add futimes()
@
text
@d1 1
a1 1
/*	$OpenBSD: time.h,v 1.2 1996/02/29 13:57:31 niklas Exp $	*/
d108 26
d157 7
@


1.2
log
@From NetBSD: Merge with NetBSD 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: time.h,v 1.16 1995/06/15 23:08:11 cgd Exp $	*/
d144 1
@


1.1
log
@Initial revision
@
text
@d1 1
d54 1
a54 1
 * Structure defined by POSIX.4 to be like a timeval.
d57 2
a58 2
	time_t	ts_sec;		/* seconds */
	long	ts_nsec;	/* and nanoseconds */
d62 2
a63 2
	(ts)->ts_sec = (tv)->tv_sec;					\
	(ts)->ts_nsec = (tv)->tv_usec * 1000;				\
d66 2
a67 2
	(tv)->tv_sec = (ts)->ts_sec;					\
	(tv)->tv_usec = (ts)->ts_nsec / 1000;				\
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
