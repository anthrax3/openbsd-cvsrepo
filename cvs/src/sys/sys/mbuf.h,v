head	1.224;
access;
symbols
	OPENBSD_6_1_BASE:1.224
	OPENBSD_6_0:1.216.0.2
	OPENBSD_6_0_BASE:1.216
	OPENBSD_5_9:1.208.0.2
	OPENBSD_5_9_BASE:1.208
	OPENBSD_5_8:1.195.0.4
	OPENBSD_5_8_BASE:1.195
	OPENBSD_5_7:1.187.0.2
	OPENBSD_5_7_BASE:1.187
	OPENBSD_5_6:1.180.0.4
	OPENBSD_5_6_BASE:1.180
	OPENBSD_5_5:1.172.0.4
	OPENBSD_5_5_BASE:1.172
	OPENBSD_5_4:1.165.0.2
	OPENBSD_5_4_BASE:1.165
	OPENBSD_5_3:1.161.0.2
	OPENBSD_5_3_BASE:1.161
	OPENBSD_5_2:1.156.0.4
	OPENBSD_5_2_BASE:1.156
	OPENBSD_5_1_BASE:1.156
	OPENBSD_5_1:1.156.0.2
	OPENBSD_5_0:1.155.0.2
	OPENBSD_5_0_BASE:1.155
	OPENBSD_4_9:1.144.0.2
	OPENBSD_4_9_BASE:1.144
	OPENBSD_4_8:1.142.0.2
	OPENBSD_4_8_BASE:1.142
	OPENBSD_4_7:1.140.0.2
	OPENBSD_4_7_BASE:1.140
	OPENBSD_4_6:1.123.0.4
	OPENBSD_4_6_BASE:1.123
	OPENBSD_4_5:1.121.0.2
	OPENBSD_4_5_BASE:1.121
	OPENBSD_4_4:1.100.0.2
	OPENBSD_4_4_BASE:1.100
	OPENBSD_4_3:1.96.0.2
	OPENBSD_4_3_BASE:1.96
	OPENBSD_4_2:1.92.0.2
	OPENBSD_4_2_BASE:1.92
	OPENBSD_4_1:1.86.0.2
	OPENBSD_4_1_BASE:1.86
	OPENBSD_4_0:1.85.0.4
	OPENBSD_4_0_BASE:1.85
	OPENBSD_3_9:1.85.0.2
	OPENBSD_3_9_BASE:1.85
	OPENBSD_3_8:1.82.0.2
	OPENBSD_3_8_BASE:1.82
	OPENBSD_3_7:1.79.0.2
	OPENBSD_3_7_BASE:1.79
	OPENBSD_3_6:1.77.0.2
	OPENBSD_3_6_BASE:1.77
	SMP_SYNC_A:1.75
	SMP_SYNC_B:1.75
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.72.0.2
	OPENBSD_3_4_BASE:1.72
	UBC_SYNC_A:1.69
	OPENBSD_3_3:1.68.0.2
	OPENBSD_3_3_BASE:1.68
	OPENBSD_3_2:1.66.0.2
	OPENBSD_3_2_BASE:1.66
	OPENBSD_3_1:1.60.0.2
	OPENBSD_3_1_BASE:1.60
	UBC_SYNC_B:1.67
	UBC:1.54.0.4
	UBC_BASE:1.54
	OPENBSD_3_0:1.54.0.2
	OPENBSD_3_0_BASE:1.54
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.16.0.2
	OPENBSD_2_7_BASE:1.16
	SMP:1.14.0.2
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.10.0.2
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.6.0.4
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.6.0.2
	OPENBSD_2_2_BASE:1.6
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.224
date	2017.02.07.06.27.18;	author dlg;	state Exp;
branches;
next	1.223;
commitid	sgyhXmV5BI3vhxqp;

1.223
date	2016.12.01.03.11.04;	author lteo;	state Exp;
branches;
next	1.222;
commitid	n630ti9Svq7rfG6c;

1.222
date	2016.10.24.04.38.44;	author dlg;	state Exp;
branches;
next	1.221;
commitid	FCHpeu0V7ZGrMD9k;

1.221
date	2016.10.17.02.53.47;	author lteo;	state Exp;
branches;
next	1.220;
commitid	kMKoNy6xnp0AkjUZ;

1.220
date	2016.09.17.00.38.43;	author deraadt;	state Exp;
branches;
next	1.219;
commitid	4vUNIFRacabiftOA;

1.219
date	2016.09.15.00.00.40;	author dlg;	state Exp;
branches;
next	1.218;
commitid	4cpeDghFp8TKfeYT;

1.218
date	2016.09.13.19.56.55;	author markus;	state Exp;
branches;
next	1.217;
commitid	MhzOL3PcQJk4ZhiI;

1.217
date	2016.09.03.13.42.28;	author reyk;	state Exp;
branches;
next	1.216;
commitid	43FpwlNR0hlD10yr;

1.216
date	2016.07.19.08.13.45;	author mpi;	state Exp;
branches;
next	1.215;
commitid	ECRL6QXqoTrZfqgd;

1.215
date	2016.06.13.21.24.43;	author bluhm;	state Exp;
branches;
next	1.214;
commitid	t4rQrmZwTmcYiFNW;

1.214
date	2016.05.23.15.22.44;	author tedu;	state Exp;
branches;
next	1.213;
commitid	Hsu9ZZbSw737UJHI;

1.213
date	2016.04.27.12.27.03;	author dlg;	state Exp;
branches;
next	1.212;
commitid	s3yTFCOjRjlGBFpR;

1.212
date	2016.04.15.05.05.21;	author dlg;	state Exp;
branches;
next	1.211;
commitid	ZmGLFaWO5K4UN2cP;

1.211
date	2016.04.08.03.13.38;	author dlg;	state Exp;
branches;
next	1.210;
commitid	Q2yKjnl59QzPTDM9;

1.210
date	2016.04.04.12.14.07;	author dlg;	state Exp;
branches;
next	1.209;
commitid	9JqBqG9smgBluxXi;

1.209
date	2016.03.29.10.34.42;	author sashan;	state Exp;
branches;
next	1.208;
commitid	3oT5Q5z024mhykOL;

1.208
date	2016.02.23.01.39.14;	author dlg;	state Exp;
branches
	1.208.2.1;
next	1.207;
commitid	jBer7f94lwmNypE0;

1.207
date	2016.01.31.00.18.07;	author sashan;	state Exp;
branches;
next	1.206;
commitid	XnM42P9Sq7TQR88T;

1.206
date	2016.01.07.22.23.13;	author sashan;	state Exp;
branches;
next	1.205;
commitid	uGcSilygSiLkUqPZ;

1.205
date	2015.11.21.11.46.25;	author mpi;	state Exp;
branches;
next	1.204;
commitid	R3ua3lEs0X7VVO7b;

1.204
date	2015.11.21.00.32.46;	author dlg;	state Exp;
branches;
next	1.203;
commitid	U6nznGWDCPokFk3a;

1.203
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.202;
commitid	eYnPulzvLjDImPCa;

1.202
date	2015.11.13.10.12.39;	author mpi;	state Exp;
branches;
next	1.201;
commitid	BHDkuvEKkivQfKxx;

1.201
date	2015.11.12.10.07.14;	author mpi;	state Exp;
branches;
next	1.200;
commitid	DLHQ4NjCPIqpY9kD;

1.200
date	2015.11.02.09.21.48;	author dlg;	state Exp;
branches;
next	1.199;
commitid	PesTrvy25aL3WZ7G;

1.199
date	2015.10.30.12.54.36;	author reyk;	state Exp;
branches;
next	1.198;
commitid	suP3B6WRHhMgnRWI;

1.198
date	2015.10.22.05.26.06;	author dlg;	state Exp;
branches;
next	1.197;
commitid	Z4k0lD49Bt5dFQva;

1.197
date	2015.10.08.11.36.15;	author dlg;	state Exp;
branches;
next	1.196;
commitid	U8z6RYthMST4iApN;

1.196
date	2015.08.14.05.25.29;	author dlg;	state Exp;
branches;
next	1.195;
commitid	zw6gETat7LvrmWZO;

1.195
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches
	1.195.4.1;
next	1.194;
commitid	9ERVupAoYqW4Iok9;

1.194
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.193;
commitid	J4OPNuggl4DOKGzM;

1.193
date	2015.06.25.09.20.20;	author mpi;	state Exp;
branches;
next	1.192;
commitid	qTf6nSNIg5TdnuJD;

1.192
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.191;
commitid	h7z8lokZ0dFyuWpg;

1.191
date	2015.05.23.12.52.59;	author markus;	state Exp;
branches;
next	1.190;
commitid	XxDCtGxlGi1shqAt;

1.190
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.189;
commitid	6glXvFR7NxzCcdRd;

1.189
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.188;
commitid	aiRvgNOa4qke9vft;

1.188
date	2015.04.10.11.02.12;	author dlg;	state Exp;
branches;
next	1.187;
commitid	Yo2S19U4e5J9njNu;

1.187
date	2015.02.10.03.46.30;	author lteo;	state Exp;
branches;
next	1.186;
commitid	RItft3Yqie37qlWB;

1.186
date	2015.02.10.03.39.06;	author lteo;	state Exp;
branches;
next	1.185;
commitid	BNCR952JJkJVlkvC;

1.185
date	2015.02.07.02.30.00;	author dlg;	state Exp;
branches;
next	1.184;
commitid	6DIoqO063ylosXnd;

1.184
date	2015.01.20.18.12.49;	author deraadt;	state Exp;
branches;
next	1.183;
commitid	MEOmBKHzdmBjucsS;

1.183
date	2014.10.03.01.02.47;	author dlg;	state Exp;
branches;
next	1.182;
commitid	dj3z1FWbO3vYKmfh;

1.182
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.181;
commitid	hjFdrSJM3VTXJUZV;

1.181
date	2014.08.18.04.06.16;	author dlg;	state Exp;
branches;
next	1.180;
commitid	EElxWqZWwFLxGTC9;

1.180
date	2014.07.13.09.52.48;	author dlg;	state Exp;
branches;
next	1.179;
commitid	EPHrRog2Cgp9jFyM;

1.179
date	2014.07.09.13.05.45;	author dlg;	state Exp;
branches;
next	1.178;
commitid	4rfOQH2rwDpu2Cn0;

1.178
date	2014.07.09.11.22.52;	author dlg;	state Exp;
branches;
next	1.177;
commitid	3BuBUtq7KUGR1P50;

1.177
date	2014.07.08.07.10.12;	author dlg;	state Exp;
branches;
next	1.176;
commitid	LjJqbuphCuSi7amX;

1.176
date	2014.04.22.14.41.03;	author mpi;	state Exp;
branches;
next	1.175;

1.175
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.174;

1.174
date	2014.03.27.10.30.58;	author mpi;	state Exp;
branches;
next	1.173;

1.173
date	2014.03.19.10.09.20;	author mpi;	state Exp;
branches;
next	1.172;

1.172
date	2014.01.19.03.04.54;	author claudio;	state Exp;
branches;
next	1.171;

1.171
date	2014.01.11.04.46.15;	author lteo;	state Exp;
branches;
next	1.170;

1.170
date	2014.01.10.00.47.17;	author bluhm;	state Exp;
branches;
next	1.169;

1.169
date	2013.11.15.16.15.42;	author bluhm;	state Exp;
branches;
next	1.168;

1.168
date	2013.10.13.10.10.04;	author reyk;	state Exp;
branches;
next	1.167;

1.167
date	2013.08.21.05.21.46;	author dlg;	state Exp;
branches;
next	1.166;

1.166
date	2013.08.13.09.52.54;	author mpi;	state Exp;
branches;
next	1.165;

1.165
date	2013.07.06.02.44.23;	author brad;	state Exp;
branches;
next	1.164;

1.164
date	2013.06.03.16.57.06;	author bluhm;	state Exp;
branches;
next	1.163;

1.163
date	2013.04.02.03.34.31;	author lteo;	state Exp;
branches;
next	1.162;

1.162
date	2013.03.29.13.16.14;	author bluhm;	state Exp;
branches;
next	1.161;

1.161
date	2013.02.07.11.06.42;	author mikeb;	state Exp;
branches;
next	1.160;

1.160
date	2013.01.16.10.38.27;	author deraadt;	state Exp;
branches;
next	1.159;

1.159
date	2012.10.05.12.27.02;	author camield;	state Exp;
branches;
next	1.158;

1.158
date	2012.09.26.14.53.23;	author markus;	state Exp;
branches;
next	1.157;

1.157
date	2012.09.19.17.50.17;	author yasuoka;	state Exp;
branches;
next	1.156;

1.156
date	2012.01.14.12.11.35;	author haesbaert;	state Exp;
branches;
next	1.155;

1.155
date	2011.07.08.18.48.51;	author henning;	state Exp;
branches;
next	1.154;

1.154
date	2011.06.17.23.45.19;	author bluhm;	state Exp;
branches;
next	1.153;

1.153
date	2011.05.13.14.31.17;	author oga;	state Exp;
branches;
next	1.152;

1.152
date	2011.05.04.16.05.49;	author blambert;	state Exp;
branches;
next	1.151;

1.151
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.150;

1.150
date	2011.04.06.19.15.34;	author markus;	state Exp;
branches;
next	1.149;

1.149
date	2011.04.05.20.31.41;	author henning;	state Exp;
branches;
next	1.148;

1.148
date	2011.04.05.18.01.21;	author henning;	state Exp;
branches;
next	1.147;

1.147
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.146;

1.146
date	2011.04.04.14.35.31;	author blambert;	state Exp;
branches;
next	1.145;

1.145
date	2011.03.24.20.09.45;	author bluhm;	state Exp;
branches;
next	1.144;

1.144
date	2010.11.05.15.17.50;	author claudio;	state Exp;
branches;
next	1.143;

1.143
date	2010.10.28.16.28.56;	author claudio;	state Exp;
branches;
next	1.142;

1.142
date	2010.07.14.10.31.54;	author matthew;	state Exp;
branches;
next	1.141;

1.141
date	2010.07.02.02.40.17;	author blambert;	state Exp;
branches;
next	1.140;

1.140
date	2010.01.11.03.50.56;	author yasuoka;	state Exp;
branches;
next	1.139;

1.139
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.138;

1.138
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.137;

1.137
date	2009.10.04.16.08.37;	author michele;	state Exp;
branches;
next	1.136;

1.136
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.135;

1.135
date	2009.09.08.17.52.18;	author michele;	state Exp;
branches;
next	1.134;

1.134
date	2009.09.08.17.00.41;	author michele;	state Exp;
branches;
next	1.133;

1.133
date	2009.08.12.20.02.42;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2009.08.12.14.39.05;	author dlg;	state Exp;
branches;
next	1.131;

1.131
date	2009.08.09.21.26.45;	author deraadt;	state Exp;
branches;
next	1.130;

1.130
date	2009.08.09.18.45.30;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2009.08.09.13.53.03;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2009.08.09.12.51.08;	author henning;	state Exp;
branches;
next	1.127;

1.127
date	2009.08.09.12.50.09;	author henning;	state Exp;
branches;
next	1.126;

1.126
date	2009.08.09.12.42.09;	author deraadt;	state Exp;
branches;
next	1.125;

1.125
date	2009.08.09.11.53.54;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.09.11.40.58;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.122;

1.122
date	2009.06.02.00.05.13;	author blambert;	state Exp;
branches;
next	1.121;

1.121
date	2009.01.27.09.17.51;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2008.12.23.01.06.33;	author deraadt;	state Exp;
branches;
next	1.119;

1.119
date	2008.12.11.16.45.44;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2008.11.26.17.36.23;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2008.11.26.16.48.16;	author claudio;	state Exp;
branches;
next	1.116;

1.116
date	2008.11.25.19.09.34;	author claudio;	state Exp;
branches;
next	1.115;

1.115
date	2008.11.25.12.47.00;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2008.11.25.12.07.55;	author claudio;	state Exp;
branches;
next	1.113;

1.113
date	2008.11.24.15.14.33;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2008.11.24.15.09.39;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2008.11.24.15.06.55;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2008.11.24.15.04.37;	author claudio;	state Exp;
branches;
next	1.109;

1.109
date	2008.11.24.12.57.37;	author dlg;	state Exp;
branches;
next	1.108;

1.108
date	2008.11.23.16.17.17;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2008.11.07.17.31.24;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2008.11.02.10.37.29;	author claudio;	state Exp;
branches;
next	1.105;

1.105
date	2008.10.17.19.06.01;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.18.15.16.30;	author naddy;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.29.08.13.08;	author jmc;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.14.19.39.40;	author claudio;	state Exp;
branches;
next	1.101;

1.101
date	2008.08.07.18.33.49;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2008.07.25.08.53.39;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.12.01.47.07;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.11.02.46.35;	author henning;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.09.02.44.54;	author markus;	state Exp;
branches;
next	1.96;

1.96
date	2007.11.28.14.04.26;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2007.11.27.16.38.50;	author tedu;	state Exp;
branches;
next	1.94;

1.94
date	2007.09.26.13.05.52;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2007.09.19.18.19.10;	author blambert;	state Exp;
branches;
next	1.92;

1.92
date	2007.07.20.09.59.19;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2007.07.10.04.43.46;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2007.07.09.19.41.53;	author claudio;	state Exp;
branches;
next	1.89;

1.89
date	2007.06.11.11.18.14;	author henning;	state Exp;
branches;
next	1.88;

1.88
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.87;

1.87
date	2007.05.27.20.54.25;	author claudio;	state Exp;
branches;
next	1.86;

1.86
date	2007.01.03.18.39.56;	author claudio;	state Exp;
branches;
next	1.85;

1.85
date	2005.11.12.20.27.46;	author brad;	state Exp;
branches;
next	1.84;

1.84
date	2005.11.03.20.00.18;	author reyk;	state Exp;
branches;
next	1.83;

1.83
date	2005.10.17.08.43.34;	author henning;	state Exp;
branches;
next	1.82;

1.82
date	2005.05.26.01.49.15;	author markus;	state Exp;
branches;
next	1.81;

1.81
date	2005.04.25.17.55.52;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.20.19.59.29;	author reyk;	state Exp;
branches;
next	1.79;

1.79
date	2005.01.18.23.26.51;	author mpf;	state Exp;
branches;
next	1.78;

1.78
date	2004.11.25.21.54.54;	author markus;	state Exp;
branches;
next	1.77;

1.77
date	2004.09.17.20.17.30;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.22.22.46.30;	author millert;	state Exp;
branches;
next	1.75;

1.75
date	2004.04.25.18.32.43;	author itojun;	state Exp;
branches;
next	1.74;

1.74
date	2003.12.08.07.07.36;	author mcbride;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.17.21.04.59;	author mcbride;	state Exp;
branches;
next	1.72;

1.72
date	2003.08.12.05.09.17;	author mickey;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.28.10.10.16;	author markus;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.13.17.33.16;	author henning;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.12.14.41.08;	author jason;	state Exp;
branches;
next	1.67;

1.67
date	2002.10.08.05.12.08;	author kjc;	state Exp;
branches;
next	1.66;

1.66
date	2002.07.03.21.19.08;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.11.02.19.56;	author frantzen;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.09.04.49.06;	author frantzen;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.09.00.57.05;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.07.19.57.45;	author dhartmei;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.03.12.04.06;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.02.17.22.59.53;	author maja;	state Exp;
branches;
next	1.56;

1.56
date	2002.01.25.15.50.23;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2002.01.02.06.17.26;	author nordin;	state Exp;
branches;
next	1.54;

1.54
date	2001.09.12.00.23.33;	author art;	state Exp;
branches
	1.54.4.1;
next	1.53;

1.53
date	2001.08.24.14.31.58;	author angelos;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.05.08.45.14;	author angelos;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.05.08.33.11;	author jjbg;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.02.01.34.47;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2001.07.01.23.04.44;	author dhartmei;	state Exp;
branches;
next	1.48;

1.48
date	2001.06.27.03.49.55;	author angelos;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.25.05.40.20;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.25.04.01.28;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.25.02.57.46;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.25.02.35.11;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.25.01.50.18;	author fgsch;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.23.04.39.35;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.23.03.57.25;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.23.02.23.01;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.23.02.01.08;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.22.14.11.00;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.31.23.35.56;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.27.04.15.51;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.27.00.38.07;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.26.06.58.30;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.25.22.09.44;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.05.24.18.53.46;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.05.24.11.00.08;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.21.05.53.38;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.21.03.26.26;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.21.03.10.54;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.20.08.31.12;	author angelos;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.19.20.55.32;	author provos;	state Exp;
branches;
next	1.25;

1.25
date	2001.05.17.18.41.44;	author provos;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.16.08.59.04;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.15.22.02.07;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.31.23.03.37;	author angelos;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.28.20.03.09;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.18.18.51.10;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.18.17.15.35;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.26.17.50.26;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.12.17.24.26;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.26.18.40.50;	author chris;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.02.21.39.19;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	99.12.08.06.50.24;	author itojun;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	99.12.05.07.30.31;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	99.10.01.02.00.11;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	99.07.02.01.02.52;	author cmetz;	state Exp;
branches;
next	1.10;

1.10
date	99.03.27.21.04.21;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	99.01.07.22.33.31;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.01.07.22.28.01;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.06.10.23.57.08;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	97.07.23.02.49.35;	author denny;	state Exp;
branches;
next	1.5;

1.5
date	97.07.11.23.37.50;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	97.06.08.18.17.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.09.02.18.14.21;	author dm;	state Exp;
branches;
next	1.2;

1.2
date	96.03.03.12.12.00;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.28;	author deraadt;	state Exp;
branches;
next	;

1.14.2.1
date	2000.03.24.09.09.44;	author niklas;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2001.05.14.22.45.02;	author niklas;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2001.07.04.11.00.23;	author niklas;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.14.2.6;

1.14.2.6
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.14.2.7;

1.14.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.14.2.8;

1.14.2.8
date	2003.05.16.00.29.45;	author niklas;	state Exp;
branches;
next	1.14.2.9;

1.14.2.9
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.14.2.10;

1.14.2.10
date	2004.02.19.11.01.33;	author niklas;	state Exp;
branches;
next	1.14.2.11;

1.14.2.11
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.54.4.1
date	2002.01.31.22.55.48;	author niklas;	state Exp;
branches;
next	1.54.4.2;

1.54.4.2
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	1.54.4.3;

1.54.4.3
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.54.4.4;

1.54.4.4
date	2003.05.19.22.32.19;	author tedu;	state Exp;
branches;
next	;

1.195.4.1
date	2016.07.21.14.31.29;	author tedu;	state Exp;
branches;
next	;
commitid	MLuylNuqysbESCPO;

1.208.2.1
date	2016.07.14.02.56.16;	author tedu;	state Exp;
branches;
next	;
commitid	0mSmzl4NTWthAxT7;


desc
@@


1.224
log
@add m_pool_init(), a wrapper around pool_init for mbuf clusters.

m_pool_init is basically a call to pool_init with everythign except
the size and alignment specified, and a call to pool_set_constraints
so the memroy is always dma reachable. it also wires up the memory
with the custom mbuf pool allocator.

ok bluhm@@ as part of a larger diff
@
text
@/*	$OpenBSD: mbuf.h,v 1.223 2016/12/01 03:11:04 lteo Exp $	*/
/*	$NetBSD: mbuf.h,v 1.19 1996/02/09 18:25:14 christos Exp $	*/

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)mbuf.h	8.5 (Berkeley) 2/19/95
 */

#ifndef _SYS_MBUF_H_
#define _SYS_MBUF_H_

#include <sys/queue.h>

/*
 * Constants related to network buffer management.
 * MCLBYTES must be no larger than PAGE_SIZE (the software page size) and,
 * on machines that exchange pages of input or output buffers with mbuf
 * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
 * of the hardware page size.
 */
#define	MSIZE		256		/* size of an mbuf */

/*
 * Mbufs are of a single size, MSIZE, which includes overhead.  An mbuf may
 * add a single "mbuf cluster" of size MCLBYTES, which has no additional
 * overhead and is used instead of the internal data area; this is done when
 * at least MINCLSIZE of data must be stored.
 */

#define	MLEN		(MSIZE - sizeof(struct m_hdr))	/* normal data len */
#define	MHLEN		(MLEN - sizeof(struct pkthdr))	/* data len w/pkthdr */

#define	MAXMCLBYTES	(64 * 1024)		/* largest cluster from the stack */
#define	MINCLSIZE	(MHLEN + MLEN + 1)	/* smallest amount to put in cluster */
#define	M_MAXCOMPRESS	(MHLEN / 2)		/* max amount to copy for compression */

#define	MCLSHIFT	11		/* convert bytes to m_buf clusters */
					/* 2K cluster can hold Ether frame */
#define	MCLBYTES	(1 << MCLSHIFT)	/* size of a m_buf cluster */
#define	MCLOFSET	(MCLBYTES - 1)

/* Packet tags structure */
struct m_tag {
	SLIST_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
	u_int16_t		m_tag_id;	/* Tag ID */
	u_int16_t		m_tag_len;	/* Length of data */
};

/*
 * Macros for type conversion
 * mtod(m,t) -	convert mbuf pointer to data pointer of correct type
 */
#define	mtod(m,t)	((t)((m)->m_data))

/* header at beginning of each mbuf: */
struct m_hdr {
	struct	mbuf *mh_next;		/* next buffer in chain */
	struct	mbuf *mh_nextpkt;	/* next chain in queue/record */
	caddr_t	mh_data;		/* location of data */
	u_int	mh_len;			/* amount of data in this mbuf */
	short	mh_type;		/* type of data in this mbuf */
	u_short	mh_flags;		/* flags; see below */
};

/* pf stuff */
struct pf_state_key;
struct inpcb;

struct pkthdr_pf {
	struct pf_state_key *statekey;	/* pf stackside statekey */
	struct inpcb	*inp;		/* connected pcb for outgoing packet */
	u_int32_t	 qid;		/* queue id */
	u_int16_t	 tag;		/* tag id */
	u_int8_t	 flags;
	u_int8_t	 routed;
	u_int8_t	 prio;
	u_int8_t	 pad[3];
};

/* pkthdr_pf.flags */
#define	PF_TAG_GENERATED		0x01
#define	PF_TAG_TRANSLATE_LOCALHOST	0x04
#define	PF_TAG_DIVERTED			0x08
#define	PF_TAG_DIVERTED_PACKET		0x10
#define	PF_TAG_REROUTE			0x20
#define	PF_TAG_REFRAGMENTED		0x40	/* refragmented ipv6 packet */
#define	PF_TAG_PROCESSED		0x80	/* packet was checked by pf */

#ifdef _KERNEL
#define MPF_BITS \
    ("\20\1GENERATED\3TRANSLATE_LOCALHOST\4DIVERTED\5DIVERTED_PACKET" \
    "\6REROUTE\7REFRAGMENTED\10PROCESSED")
#endif

/* record/packet header in first mbuf of chain; valid if M_PKTHDR set */
struct	pkthdr {
	void			*ph_cookie;	/* additional data */
	SLIST_HEAD(, m_tag)	 ph_tags;	/* list of packet tags */
	int			 len;		/* total packet length */
	u_int16_t		 ph_tagsset;	/* mtags attached */
	u_int16_t		 ph_flowid;	/* pseudo unique flow id */
	u_int16_t		 csum_flags;	/* checksum flags */
	u_int16_t		 ether_vtag;	/* Ethernet 802.1p+Q vlan tag */
	u_int			 ph_rtableid;	/* routing table id */
	u_int			 ph_ifidx;	/* rcv interface index */
	u_int8_t		 ph_loopcnt;	/* mbuf is looping in kernel */
	struct pkthdr_pf	 pf;
};

/* description of external storage mapped into mbuf, valid if M_EXT set */
struct mbuf_ext {
	caddr_t	ext_buf;		/* start of buffer */
	void	*ext_arg;
	u_int	ext_free_fn;		/* index of free function */
	u_int	ext_size;		/* size of buffer, for ext_free_fn */
	struct mbuf *ext_nextref;
	struct mbuf *ext_prevref;
#ifdef DEBUG
	const char *ext_ofile;
	const char *ext_nfile;
	int ext_oline;
	int ext_nline;
#endif
};

struct mbuf {
	struct	m_hdr m_hdr;
	union {
		struct {
			struct	pkthdr MH_pkthdr;	/* M_PKTHDR set */
			union {
				struct	mbuf_ext MH_ext; /* M_EXT set */
				char	MH_databuf[MHLEN];
			} MH_dat;
		} MH;
		char	M_databuf[MLEN];		/* !M_PKTHDR, !M_EXT */
	} M_dat;
};
#define	m_next		m_hdr.mh_next
#define	m_len		m_hdr.mh_len
#define	m_data		m_hdr.mh_data
#define	m_type		m_hdr.mh_type
#define	m_flags		m_hdr.mh_flags
#define	m_nextpkt	m_hdr.mh_nextpkt
#define	m_pkthdr	M_dat.MH.MH_pkthdr
#define	m_ext		M_dat.MH.MH_dat.MH_ext
#define	m_pktdat	M_dat.MH.MH_dat.MH_databuf
#define	m_dat		M_dat.M_databuf

/* mbuf flags */
#define	M_EXT		0x0001	/* has associated external storage */
#define	M_PKTHDR	0x0002	/* start of record */
#define	M_EOR		0x0004	/* end of record */
#define M_EXTWR		0x0008	/* external storage is writable */
#define	M_PROTO1	0x0010	/* protocol-specific */

/* mbuf pkthdr flags, also in m_flags */
#define M_VLANTAG	0x0020	/* ether_vtag is valid */
#define M_LOOP		0x0040	/* for Mbuf statistics */
#define M_ACAST		0x0080	/* received as IPv6 anycast */
#define M_BCAST		0x0100	/* sent/received as link-level broadcast */
#define M_MCAST		0x0200	/* sent/received as link-level multicast */
#define M_CONF		0x0400  /* payload was encrypted (ESP-transport) */
#define M_AUTH		0x0800  /* payload was authenticated (AH or ESP auth) */
#define M_TUNNEL	0x1000  /* IP-in-IP added by tunnel mode IPsec */
#define M_ZEROIZE	0x2000  /* Zeroize data part on free */
#define M_COMP		0x4000  /* header was decompressed */
#define M_LINK0		0x8000	/* link layer specific flag */

#ifdef _KERNEL
#define M_BITS \
    ("\20\1M_EXT\2M_PKTHDR\3M_EOR\4M_EXTWR\5M_PROTO1\6M_VLANTAG\7M_LOOP" \
    "\10M_ACAST\11M_BCAST\12M_MCAST\13M_CONF\14M_AUTH\15M_TUNNEL" \
    "\16M_ZEROIZE\17M_COMP\20M_LINK0")
#endif

/* flags copied when copying m_pkthdr */
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|M_COMP|\
			 M_AUTH|M_LOOP|M_TUNNEL|M_LINK0|M_VLANTAG|M_ACAST|\
			 M_ZEROIZE)

/* Checksumming flags */
#define	M_IPV4_CSUM_OUT		0x0001	/* IPv4 checksum needed */
#define	M_TCP_CSUM_OUT		0x0002	/* TCP checksum needed */
#define	M_UDP_CSUM_OUT		0x0004	/* UDP checksum needed */
#define	M_IPV4_CSUM_IN_OK	0x0008	/* IPv4 checksum verified */
#define	M_IPV4_CSUM_IN_BAD	0x0010	/* IPv4 checksum bad */
#define	M_TCP_CSUM_IN_OK	0x0020	/* TCP checksum verified */
#define	M_TCP_CSUM_IN_BAD	0x0040	/* TCP checksum bad */
#define	M_UDP_CSUM_IN_OK	0x0080	/* UDP checksum verified */
#define	M_UDP_CSUM_IN_BAD	0x0100	/* UDP checksum bad */
#define	M_ICMP_CSUM_OUT		0x0200	/* ICMP/ICMPv6 checksum needed */
#define	M_ICMP_CSUM_IN_OK	0x0400	/* ICMP/ICMPv6 checksum verified */
#define	M_ICMP_CSUM_IN_BAD	0x0800	/* ICMP/ICMPv6 checksum bad */

#ifdef _KERNEL
#define MCS_BITS \
    ("\20\1IPV4_CSUM_OUT\2TCP_CSUM_OUT\3UDP_CSUM_OUT\4IPV4_CSUM_IN_OK" \
    "\5IPV4_CSUM_IN_BAD\6TCP_CSUM_IN_OK\7TCP_CSUM_IN_BAD\10UDP_CSUM_IN_OK" \
    "\11UDP_CSUM_IN_BAD\12ICMP_CSUM_OUT\13ICMP_CSUM_IN_OK\14ICMP_CSUM_IN_BAD")
#endif

/* mbuf types */
#define	MT_FREE		0	/* should be on free list */
#define	MT_DATA		1	/* dynamic (data) allocation */
#define	MT_HEADER	2	/* packet header */
#define	MT_SONAME	3	/* socket name */
#define	MT_SOOPTS	4	/* socket options */
#define	MT_FTABLE	5	/* fragment reassembly header */
#define	MT_CONTROL	6	/* extra-data protocol message */
#define	MT_OOBDATA	7	/* expedited data  */
#define	MT_NTYPES	8

/* flowid field */
#define M_FLOWID_VALID	0x8000	/* is the flowid set */
#define M_FLOWID_MASK	0x7fff	/* flow id to map to path */

/* flags to m_get/MGET */
#include <sys/malloc.h>
#define	M_DONTWAIT	M_NOWAIT
#define	M_WAIT		M_WAITOK

/*
 * mbuf allocation/deallocation macros:
 *
 *	MGET(struct mbuf *m, int how, int type)
 * allocates an mbuf and initializes it to contain internal data.
 *
 *	MGETHDR(struct mbuf *m, int how, int type)
 * allocates an mbuf and initializes it to contain a packet header
 * and internal data.
 */
#define MGET(m, how, type) m = m_get((how), (type))

#define MGETHDR(m, how, type) m = m_gethdr((how), (type))

/*
 * Macros for tracking external storage associated with an mbuf.
 */
#ifdef DEBUG
#define MCLREFDEBUGN(m, file, line) do {				\
		(m)->m_ext.ext_nfile = (file);				\
		(m)->m_ext.ext_nline = (line);				\
	} while (/* CONSTCOND */ 0)
#define MCLREFDEBUGO(m, file, line) do {				\
		(m)->m_ext.ext_ofile = (file);				\
		(m)->m_ext.ext_oline = (line);				\
	} while (/* CONSTCOND */ 0)
#else
#define MCLREFDEBUGN(m, file, line)
#define MCLREFDEBUGO(m, file, line)
#endif

#define	MCLISREFERENCED(m)	((m)->m_ext.ext_nextref != (m))

#define	MCLADDREFERENCE(o, n)	m_extref((o), (n))

#define	MCLINITREFERENCE(m)	do {					\
		(m)->m_ext.ext_prevref = (m);				\
		(m)->m_ext.ext_nextref = (m);				\
		MCLREFDEBUGO((m), __FILE__, __LINE__);			\
		MCLREFDEBUGN((m), NULL, 0);				\
	} while (/* CONSTCOND */ 0)

/*
 * Macros for mbuf external storage.
 *
 * MEXTADD adds pre-allocated external storage to
 * a normal mbuf; the flag M_EXT is set.
 *
 * MCLGET allocates and adds an mbuf cluster to a normal mbuf;
 * the flag M_EXT is set upon success.
 */
#define	MEXTADD(m, buf, size, mflags, freefn, arg) do {			\
	(m)->m_data = (m)->m_ext.ext_buf = (caddr_t)(buf);		\
	(m)->m_flags |= M_EXT | (mflags & M_EXTWR);			\
	(m)->m_ext.ext_size = (size);					\
	(m)->m_ext.ext_free_fn = (freefn);					\
	(m)->m_ext.ext_arg = (arg);					\
	MCLINITREFERENCE(m);						\
} while (/* CONSTCOND */ 0)

#define MCLGET(m, how) (void) m_clget((m), (how), MCLBYTES)
#define MCLGETI(m, how, ifp, l) m_clget((m), (how), (l))

u_int mextfree_register(void (*)(caddr_t, u_int, void *));
#define	MEXTFREE_POOL 0

/*
 * Move just m_pkthdr from from to to,
 * remove M_PKTHDR and clean flags/tags for from.
 */
#define M_MOVE_HDR(to, from) do {					\
	(to)->m_pkthdr = (from)->m_pkthdr;				\
	(from)->m_flags &= ~M_PKTHDR;					\
	SLIST_INIT(&(from)->m_pkthdr.ph_tags);				\
	(from)->m_pkthdr.pf.statekey = NULL;				\
} while (/* CONSTCOND */ 0)

/*
 * MOVE mbuf pkthdr from from to to.
 * from must have M_PKTHDR set, and to must be empty.
 */
#define	M_MOVE_PKTHDR(to, from) do {					\
	(to)->m_flags = ((to)->m_flags & (M_EXT | M_EXTWR));		\
	(to)->m_flags |= (from)->m_flags & M_COPYFLAGS;			\
	M_MOVE_HDR((to), (from));					\
	if (((to)->m_flags & M_EXT) == 0)				\
		(to)->m_data = (to)->m_pktdat;				\
} while (/* CONSTCOND */ 0)

/*
 * Set the m_data pointer of a newly-allocated mbuf (m_get/MGET) to place
 * an object of the specified size at the end of the mbuf, longword aligned.
 */
#define	M_ALIGN(m, len) \
	(m)->m_data += (MLEN - (len)) &~ (sizeof(long) - 1)
/*
 * As above, for mbufs allocated with m_gethdr/MGETHDR
 * or initialized by M_MOVE_PKTHDR.
 */
#define	MH_ALIGN(m, len) \
	(m)->m_data += (MHLEN - (len)) &~ (sizeof(long) - 1)

/*
 * Determine if an mbuf's data area is read-only. This is true for
 * non-cluster external storage and for clusters that are being
 * referenced by more than one mbuf.
 */
#define	M_READONLY(m)							\
	(((m)->m_flags & M_EXT) != 0 &&					\
	  (((m)->m_flags & M_EXTWR) == 0 || MCLISREFERENCED(m)))

/*
 * Compute the amount of space available
 * before the current start of data in an mbuf.
 */
#define	M_LEADINGSPACE(m) m_leadingspace(m)

/*
 * Compute the amount of space available
 * after the end of data in an mbuf.
 */
#define	M_TRAILINGSPACE(m) m_trailingspace(m)

/*
 * Arrange to prepend space of size plen to mbuf m.
 * If a new mbuf must be allocated, how specifies whether to wait.
 * If how is M_DONTWAIT and allocation fails, the original mbuf chain
 * is freed and m is set to NULL.
 */
#define	M_PREPEND(m, plen, how) \
		(m) = m_prepend((m), (plen), (how))

/* length to m_copy to copy all */
#define	M_COPYALL	1000000000

/*
 * Mbuf statistics.
 * For statistics related to mbuf and cluster allocations, see also the
 * pool headers (mbpool and mclpool).
 */
struct mbstat {
	u_long	m_drops;	/* times failed to find space */
	u_long	m_wait;		/* times waited for space */
	u_long	m_drain;	/* times drained protocols for space */
	u_short	m_mtypes[256];	/* type specific mbuf allocations */
};

#define MBSTAT_TYPES           MT_NTYPES
#define MBSTAT_DROPS           (MBSTAT_TYPES + 0)
#define MBSTAT_WAIT            (MBSTAT_TYPES + 1)
#define MBSTAT_DRAIN           (MBSTAT_TYPES + 2)
#define MBSTAT_COUNT           (MBSTAT_TYPES + 3)

#include <sys/mutex.h>

struct mbuf_list {
	struct mbuf		*ml_head;
	struct mbuf		*ml_tail;
	u_int			ml_len;
};

struct mbuf_queue {
	struct mutex		mq_mtx;
	struct mbuf_list	mq_list;
	u_int			mq_maxlen;
	u_int			mq_drops;
};

#ifdef	_KERNEL
struct pool;

extern	int nmbclust;			/* limit on the # of clusters */
extern	int mblowat;			/* mbuf low water mark */
extern	int mcllowat;			/* mbuf cluster low water mark */
extern	int max_linkhdr;		/* largest link-level header */
extern	int max_protohdr;		/* largest protocol header */
extern	int max_hdr;			/* largest link+protocol header */

void	mbinit(void);
void	mbcpuinit(void);
struct	mbuf *m_copym(struct mbuf *, int, int, int);
struct	mbuf *m_free(struct mbuf *);
struct	mbuf *m_get(int, int);
struct	mbuf *m_getclr(int, int);
struct	mbuf *m_gethdr(int, int);
struct	mbuf *m_inithdr(struct mbuf *);
void	m_resethdr(struct mbuf *);
int	m_defrag(struct mbuf *, int);
struct	mbuf *m_prepend(struct mbuf *, int, int);
struct	mbuf *m_pulldown(struct mbuf *, int, int, int *);
struct	mbuf *m_pullup(struct mbuf *, int);
struct	mbuf *m_split(struct mbuf *, int, int);
struct	mbuf *m_makespace(struct mbuf *, int, int, int *);
struct  mbuf *m_getptr(struct mbuf *, int, int *);
int	m_leadingspace(struct mbuf *);
int	m_trailingspace(struct mbuf *);
struct mbuf *m_clget(struct mbuf *, int, u_int);
void	m_extref(struct mbuf *, struct mbuf *);
void	m_pool_init(struct pool *, u_int, u_int, const char *);
void	m_extfree_pool(caddr_t, u_int, void *);
void	m_adj(struct mbuf *, int);
int	m_copyback(struct mbuf *, int, int, const void *, int);
struct mbuf *m_freem(struct mbuf *);
void	m_purge(struct mbuf *);
void	m_reclaim(void *, int);
void	m_copydata(struct mbuf *, int, int, caddr_t);
void	m_cat(struct mbuf *, struct mbuf *);
struct mbuf *m_devget(char *, int, int);
int	m_apply(struct mbuf *, int, int,
	    int (*)(caddr_t, caddr_t, unsigned int), caddr_t);
struct mbuf *m_dup_pkt(struct mbuf *, unsigned int, int);
int	m_dup_pkthdr(struct mbuf *, struct mbuf *, int);

/* Packet tag routines */
struct m_tag *m_tag_get(int, int, int);
void	m_tag_prepend(struct mbuf *, struct m_tag *);
void	m_tag_delete(struct mbuf *, struct m_tag *);
void	m_tag_delete_chain(struct mbuf *);
struct m_tag *m_tag_find(struct mbuf *, int, struct m_tag *);
struct m_tag *m_tag_copy(struct m_tag *, int);
int	m_tag_copy_chain(struct mbuf *, struct mbuf *, int);
void	m_tag_init(struct mbuf *);
struct m_tag *m_tag_first(struct mbuf *);
struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);

/* Packet tag types */
#define PACKET_TAG_IPSEC_IN_DONE	0x0001  /* IPsec applied, in */
#define PACKET_TAG_IPSEC_OUT_DONE	0x0002  /* IPsec applied, out */
#define PACKET_TAG_GIF			0x0040  /* GIF processing done */
#define PACKET_TAG_GRE			0x0080  /* GRE processing done */
#define PACKET_TAG_DLT			0x0100 /* data link layer type */
#define PACKET_TAG_PF_DIVERT		0x0200 /* pf(4) diverted packet */
#define PACKET_TAG_PF_REASSEMBLED	0x0800 /* pf reassembled ipv6 packet */
#define PACKET_TAG_SRCROUTE		0x1000 /* IPv4 source routing options */
#define PACKET_TAG_TUNNEL		0x2000	/* Tunnel endpoint address */

#define MTAG_BITS \
    ("\20\1IPSEC_IN_DONE\2IPSEC_OUT_DONE\3IPSEC_IN_CRYPTO_DONE" \
    "\4IPSEC_OUT_CRYPTO_NEEDED\5IPSEC_PENDING_TDB\6BRIDGE\7GIF\10GRE\11DLT" \
    "\12PF_DIVERT\14PF_REASSEMBLED\15SRCROUTE\16TUNNEL")

/*
 * Maximum tag payload length (that is excluding the m_tag structure).
 * Please make sure to update this value when increasing the payload
 * length for an existing packet tag type or when adding a new one that
 * has payload larger than the value below.
 */
#define PACKET_TAG_MAXSIZE		60

/* Detect mbufs looping in the kernel when spliced too often. */
#define M_MAXLOOP	128

/*
 * mbuf lists
 */

#define MBUF_LIST_INITIALIZER() { NULL, NULL, 0 }

void			ml_init(struct mbuf_list *);
void			ml_enqueue(struct mbuf_list *, struct mbuf *);
struct mbuf *		ml_dequeue(struct mbuf_list *);
void			ml_enlist(struct mbuf_list *, struct mbuf_list *);
struct mbuf *		ml_dechain(struct mbuf_list *);
unsigned int		ml_purge(struct mbuf_list *);

#define	ml_len(_ml)		((_ml)->ml_len)
#define	ml_empty(_ml)		((_ml)->ml_len == 0)

#define MBUF_LIST_FIRST(_ml)	((_ml)->ml_head)
#define MBUF_LIST_NEXT(_m)	((_m)->m_nextpkt)

#define MBUF_LIST_FOREACH(_ml, _m)					\
	for ((_m) = MBUF_LIST_FIRST(_ml);				\
	    (_m) != NULL;						\
	    (_m) = MBUF_LIST_NEXT(_m))

/*
 * mbuf queues
 */

#define MBUF_QUEUE_INITIALIZER(_maxlen, _ipl) \
    { MUTEX_INITIALIZER(_ipl), MBUF_LIST_INITIALIZER(), (_maxlen), 0 }

void			mq_init(struct mbuf_queue *, u_int, int);
int			mq_enqueue(struct mbuf_queue *, struct mbuf *);
struct mbuf *		mq_dequeue(struct mbuf_queue *);
int			mq_enlist(struct mbuf_queue *, struct mbuf_list *);
void			mq_delist(struct mbuf_queue *, struct mbuf_list *);
struct mbuf *		mq_dechain(struct mbuf_queue *);
unsigned int		mq_purge(struct mbuf_queue *);

#define	mq_len(_mq)		ml_len(&(_mq)->mq_list)
#define	mq_empty(_mq)		ml_empty(&(_mq)->mq_list)
#define	mq_drops(_mq)		((_mq)->mq_drops)
#define	mq_set_maxlen(_mq, _l)	((_mq)->mq_maxlen = (_l))

#endif /* _KERNEL */
#endif /* _SYS_MBUF_H_ */
@


1.223
log
@Update comments in struct mbuf_ext to reflect the replacement of ext_free by
ext_free_fn.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.222 2016/10/24 04:38:44 dlg Exp $	*/
d418 1
d447 1
@


1.222
log
@move the mbstat structure to percpu counters

each cpus counters still have to be protected by splnet, but this
is better thana single set of counters protected by a global mutex.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.221 2016/10/17 02:53:47 lteo Exp $	*/
a138 1
					/* free routine if not the usual */
d140 2
a141 2
	u_int	ext_free_fn;
	u_int	ext_size;		/* size of buffer, for ext_free */
@


1.221
log
@"send/received" -> "sent/received"
ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.220 2016/09/17 00:38:43 deraadt Exp $	*/
d239 1
d397 6
a419 1
extern	struct mbstat mbstat;
d428 1
@


1.220
log
@clean old cruft out of mbstat
ok henning bluhm claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.219 2016/09/15 00:00:40 dlg Exp $	*/
d188 2
a189 2
#define M_BCAST		0x0100	/* send/received as link-level broadcast */
#define M_MCAST		0x0200	/* send/received as link-level multicast */
@


1.219
log
@remove m_copym2 as its use has been replaced by m_dup_pkt

ok millert@@ mpi@@ henning@@ claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.218 2016/09/13 19:56:55 markus Exp $	*/
a389 4
	u_long	_m_spare;	/* formerly m_mbufs */
	u_long	_m_spare1;	/* formerly m_clusters */
	u_long	_m_spare2;	/* spare field */
	u_long	_m_spare3;	/* formely m_clfree - free clusters */
@


1.218
log
@avoid extensive mbuf allocation for IPsec by replacing m_inject(4)
with m_makespace(4) from freebsd; ok mpi@@, bluhm@@, mikeb@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.217 2016/09/03 13:42:28 reyk Exp $	*/
a425 1
struct	mbuf *m_copym2(struct mbuf *, int, int, int);
@


1.217
log
@bump PACKET_TAG_MAXSIZE from 52 to 60 bytes to make room for the
upcoming bridge tunneltag change (the tag is used in the mtagpl pool).

OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.216 2016/07/19 08:13:45 mpi Exp $	*/
d439 1
a439 1
struct  mbuf *m_inject(struct mbuf *, int, int, int);
@


1.216
log
@Use a flag to indicate that a packet has been received on an IPv6
anycast address.

This will allow us to split ip6_input() in two parts using a queue
in the middle.

ok jca@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.215 2016/06/13 21:24:43 bluhm Exp $	*/
d493 1
a493 1
#define PACKET_TAG_MAXSIZE		52
@


1.215
log
@On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.214 2016/05/23 15:22:44 tedu Exp $	*/
d187 1
a187 1
#define M_FILDROP	0x0080	/* dropped by bpf filter */
d200 1
a200 1
    "\10M_FILDROP\11M_BCAST\12M_MCAST\13M_CONF\14M_AUTH\15M_TUNNEL" \
d206 1
a206 1
			 M_AUTH|M_LOOP|M_TUNNEL|M_LINK0|M_VLANTAG|M_FILDROP|\
@


1.214
log
@remove the function pointer from mbufs. this memory is shared with data
via unions, and we don't want to make it easy to control the target.
instead an integer index into an array of acceptable functions is used.
drivers using custom functions must register them to receive an index.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.213 2016/04/27 12:27:03 dlg Exp $	*/
d132 1
d494 3
@


1.213
log
@mbuf tags are in an SLIST, so we need queue.h after all.

found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.212 2016/04/15 05:05:21 dlg Exp $	*/
a138 1
	void	(*ext_free)(caddr_t, u_int, void *);
d140 1
d299 1
a299 1
#define	MEXTADD(m, buf, size, mflags, free, arg) do {			\
d303 1
a303 1
	(m)->m_ext.ext_free = (free);					\
d310 3
@


1.212
log
@remove ml_filter, mq_filter, niq_filter.

theyre currently unused, so no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.211 2016/04/08 03:13:38 dlg Exp $	*/
d37 2
@


1.211
log
@add m_purge for freeing a list of mbufs linked via m_nextpkt

this tweaks m_freem so it returns the m_nextpkt from the mbuf it freed,
like how m_free returns the m_next from the mbuf it frees.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.210 2016/04/04 12:14:07 dlg Exp $	*/
a499 2
struct mbuf *		ml_filter(struct mbuf_list *,
			    int (*)(void *, const struct mbuf *), void *);
a525 2
struct mbuf *		mq_filter(struct mbuf_queue *,
			    int (*)(void *, const struct mbuf *), void *);
@


1.210
log
@mbuf.h doenst need queue.h.

move malloc.h down to where its used, and inside _KERNEL.

ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.209 2016/03/29 10:34:42 sashan Exp $	*/
d442 2
a443 1
void	m_freem(struct mbuf *);
@


1.209
log
@- packet must keep reference to statekey
  this is the second attempt to get it in, the first
  attempt got backed out on Jan 31 2016

  the change also contains fixes contributed by Stefan Kempf
  in earlier iteration.

OK srhen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.208 2016/02/23 01:39:14 dlg Exp $	*/
a37 3
#include <sys/malloc.h>
#include <sys/queue.h>

d242 1
@


1.208
log
@provide m_dup_pkt() for doing fast deep mbuf copies with a specified alignment

if a physical interface receives a multicast/broadcast packet and
has carp interfaces on it, that packet needs to be copied for
reception by each of those carp interfaces.

previously it was using m_copym2, but that doesn't respect the
alignment of the source packet. this meant the ip header in the
copies were aligned incorrectly for the network stack, which breaks
strict alignment archs.

m_dup_pkt lets carp specify that the payload needs an ETHER_ALIGN
adjustment, so the ip header inside will be aligned correctly.

reported and tested by anthony eden who hit this on armv7
i reproduced the problem on sparc64 and verified the fix on amd64
and sparc64
ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.207 2016/01/31 00:18:07 sashan Exp $	*/
d319 1
@


1.208.2.1
log
@backport splice loop fix:
On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.208 2016/02/23 01:39:14 dlg Exp $	*/
a132 1
	u_int8_t		 ph_loopcnt;	/* mbuf is looping in kernel */
a487 3

/* Detect mbufs looping in the kernel when spliced too often. */
#define M_MAXLOOP	128
@


1.207
log
@- m_pkthdr.pf.statekey changes are not ready for 5.9, I must back them out

OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.205 2015/11/21 11:46:25 mpi Exp $	*/
d450 1
@


1.206
log
@- retrying to commit earlier change, which got backed out

    - yet another tiny step towards MP PF. This time we need to make sure
      statekey attached to packet stays around, while accepted packet is
      routed through IP stack.

  this time I'm also bringing fix contributed by Stefan Kempf. Stefan's fix
  makes sure we grab reference in m_dup_pkthdr()

OK bluhm@@
@
text
@a318 1
	(from)->m_pkthdr.pf.statekey = NULL;				\
@


1.205
log
@Retire ml_requeue(9) and mq_requeue(9).

As Kenjiro Cho pointed out it is very hard to cancel a dequeue operation
for some queueing disciplines when such it keeps some internal states.

As you can see, APIs can also Live Fast & Die Young.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.195 2015/07/08 07:21:50 mpi Exp $	*/
d319 1
@


1.204
log
@provide MBUF_LIST_FIRST and MBUF_LIST_NEXT for iterating over an mbuf_list.

MBUF_LIST_FOREACH is then rewritten on top of those.

this makes it easier to get at the head of a list too, which may make
the hfsc ifq backend nicer.

based on a discussion with kenjiro cho
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.203 2015/11/20 03:35:23 dlg Exp $	*/
a496 1
void			ml_requeue(struct mbuf_list *, struct mbuf *);
a523 1
int			mq_requeue(struct mbuf_queue *, struct mbuf *);
@


1.203
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.202 2015/11/13 10:12:39 mpi Exp $	*/
d507 7
a513 2
#define MBUF_LIST_FOREACH(_ml, _m) \
	for ((_m) = (_ml)->ml_head; (_m) != NULL; (_m) = (_m)->m_nextpkt)
@


1.202
log
@Use ph_ prefix for tag-related fields.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.201 2015/11/12 10:07:14 mpi Exp $	*/
d395 15
a491 8
#include <sys/mutex.h>

struct mbuf_list {
	struct mbuf		*ml_head;
	struct mbuf		*ml_tail;
	u_int			ml_len;
};

a512 7

struct mbuf_queue {
	struct mutex		mq_mtx;
	struct mbuf_list	mq_list;
	u_int			mq_maxlen;
	u_int			mq_drops;
};
@


1.201
log
@Prefix flowid with ph_ and print it in m_print().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.200 2015/11/02 09:21:48 dlg Exp $	*/
d125 1
a125 1
	SLIST_HEAD(packet_tags, m_tag) tags;	/* list of packet tags */
d127 1
a127 1
	u_int16_t		 tagsset;	/* mtags attached */
d318 1
a318 1
	SLIST_INIT(&(from)->m_pkthdr.tags);				\
@


1.200
log
@provide ml_purge and mq_purge.

these are modelled on IF_PURGE or IFQ_PURGE. they m_freem all the
mbufs on an mbuf list or queue.

ok jmatthew@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.199 2015/10/30 12:54:36 reyk Exp $	*/
d128 1
a128 1
	u_int16_t		 flowid;	/* pseudo unique flow id */
@


1.199
log
@Add m_resethdr() to clear any state (pf, tags, flags) of an mbuf packet.
Start using it in pair(4) to clear state on the receiving interface;
m_resethdr() will also be used in other parts of the stack.

OK bluhm@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.198 2015/10/22 05:26:06 dlg Exp $	*/
d495 1
d526 1
@


1.198
log
@rename ml_join to ml_enlist and expose it to the rest of the kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.197 2015/10/08 11:36:15 dlg Exp $	*/
d413 2
a414 1
int	      m_defrag(struct mbuf *, int);
@


1.197
log
@steal some padding in mbuf pkthdrs to store a flow id.

the flowid roughly identifies a flow or connection that the mbuf
is a part of, and can be used instead of hashing contents of the
packet (like src+dst mac and ip addresses) to decide which path a
packet should take.

ok mpi@@ mikeb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.196 2015/08/14 05:25:29 dlg Exp $	*/
d490 1
@


1.196
log
@provide ml_requeue and mq_requeue for prepending mbufs on lists/queues

ok mpi@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.195 2015/07/08 07:21:50 mpi Exp $	*/
d128 1
a128 1
	u_int16_t		 pad;
d239 4
@


1.195
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.194 2015/06/30 15:30:17 mpi Exp $	*/
d485 1
d513 1
@


1.195.4.1
log
@I forgot to commit the 5.8 version of the splice fix.
Reminded by Florian Riehm
backport splice loop fix:
On localhost a user program may create a socket splicing loop.
After writing data into this loop, it was spinning forever causing
a kernel hang.  Detect the loop by counting how often the same mbuf
is spliced.  If that happens 128 times, assume that there is a loop
and abort the splicing with ELOOP.
Bug found by tedu@@;  OK tedu@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.195 2015/07/08 07:21:50 mpi Exp $	*/
a132 1
	u_int8_t		 ph_loopcnt;	/* mbuf is looping in kernel */
a466 3

/* Detect mbufs looping in the kernel when spliced too often. */
#define M_MAXLOOP	128
@


1.194
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.193 2015/06/25 09:20:20 mpi Exp $	*/
a305 7

/*
 * MFREE(struct mbuf *m, struct mbuf *n)
 * Free a single mbuf and associated external storage.
 * Place the successor, if any, in n.
 */
#define	MFREE(m, n) n = m_free((m))
@


1.193
log
@Move brige(4)'s output hook outside of ether_output().

This fix some weird bridge(4) configurations involving pseudo-drivers
stacked on top of interfaces in a bridge.

Also simplifies the loop prevention logic to match bridge's input path.
Instead of using a tag per port/bridge simply flag output mbufs to make
sure only one copy per bridge go through bridge_output().

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.192 2015/06/16 11:09:40 mpi Exp $	*/
a380 3

/* compatibility with 4.3 */
#define  m_copy(m, o, l)	m_copym((m), (o), (l), M_DONTWAIT)
@


1.192
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.191 2015/05/23 12:52:59 markus Exp $	*/
a456 1
#define PACKET_TAG_BRIDGE		0x0020  /* Bridge processing done */
@


1.191
log
@remove PACKET_TAG_IPSEC_PENDING_TDB, it is never set; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.190 2015/04/17 11:04:02 mikeb Exp $	*/
d124 1
a124 1
	struct ifnet		*rcvif;		/* rcv interface */
d132 1
a132 1
	void			*ph_cookie;	/* additional data */
@


1.190
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.189 2015/04/13 08:45:48 mpi Exp $	*/
a456 1
#define PACKET_TAG_IPSEC_PENDING_TDB	0x0010  /* Reminder to do IPsec */
@


1.189
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.188 2015/04/10 11:02:12 dlg Exp $	*/
a456 2
#define PACKET_TAG_IPSEC_IN_CRYPTO_DONE	0x0004  /* NIC IPsec crypto done */
#define PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED 0x0008  /* NIC IPsec crypto req'ed */
@


1.188
log
@mpi@@ introduced a ph_cookie in mbuf packet headers that can be used
by a subsystem to stash some state while the mbuf gets queued. eg,
net80211 uses it to keep track of the wireless node associated with
a packet before submitting it to a drivers snd queue for transmission.

this makes pipex use ph_cookie to keep track of the pipex session
associated with a packet before submitting it to the softint queues.
this lets us get rid of an mbuf tag type, and avoids the cost of
tag allocation.

ok yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.187 2015/02/10 03:46:30 lteo Exp $	*/
d304 2
a305 2
#define MCLGET(m, how) (void) m_clget((m), (how), NULL, MCLBYTES)
#define MCLGETI(m, how, ifp, l) m_clget((m), (how), (ifp), (l))
d428 1
a428 1
struct mbuf *m_clget(struct mbuf *, int, struct ifnet *, u_int);
d437 1
a437 1
struct mbuf *m_devget(char *, int, int, struct ifnet *);
@


1.187
log
@Remove references to <sys/param.h> in comment, since MSIZE and MCLBYTES
are no longer defined there.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.186 2015/02/10 03:39:06 lteo Exp $	*/
a464 1
#define PACKET_TAG_PIPEX		0x0400 /* pipex session cache */
d472 1
a472 1
    "\12PF_DIVERT\13PIPEX\14PF_REASSEMBLED\15SRCROUTE\16TUNNEL")
@


1.186
log
@Remove m_act; it was the historical name of m_nextpkt and has been
deprecated for a very long time.

ok claudio@@ dlg@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.185 2015/02/07 02:30:00 dlg Exp $	*/
d51 3
a53 4
 * Mbufs are of a single size, MSIZE (sys/param.h), which
 * includes overhead.  An mbuf may add a single "mbuf cluster" of size
 * MCLBYTES (also in sys/param.h), which has no additional overhead
 * and is used instead of the internal data area; this is done when
@


1.185
log
@add ml_filter and mq_filter functions to the mbuf list and queue apis.

this lets you run a filter function against each mbuf on a list or
queue. if the filter matches on an mbuf, it can return non-zero to
have ml_filter or mq_filter remove the mbuf and return it as part
of a chain of mbufs.

ok mpi@@ claudio@@ henning@@ and s2k15 generally.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.184 2015/01/20 18:12:49 deraadt Exp $	*/
a172 1
#define	m_act		m_nextpkt
@


1.184
log
@Years ago, MSIZE had to be known in <sys/param.h> probably to allocate
memory for the mbuf layer up front.  These days it only matters for
sizing of macros in <sys/mbuf.h>, so move it there.  MCLSHIFT, MCLBYTES,
and MCLOFSET can move also (a decade ago, architectures had different
mbuf sizes.  you don't want to know more)
ok guenther, ports fallout checked for by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.183 2014/10/03 01:02:47 dlg Exp $	*/
d503 2
d532 2
@


1.183
log
@now that pools are mpsafe, we can make the mbuf allocators on top
of pools mpsafe too.

this calles pool_setipl(IPL_NET) against the mbuf and cluster pools,
and removes the use of splnet().

the other locking done in the mbuf layer is for external cluster
references. again, they relied on splnet to serialise these operations.
because there is no shared memory associated with external clusters
(except the cluster itself, which is completely dedicated to data
payload, not meta info like a refcount or lock), this has been
replaced with a single mutex that all reference ops are serialised
with.

tested by me, jmatthew@@, bcook@@, and phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.182 2014/08/18 05:11:03 dlg Exp $	*/
d42 9
d64 5
@


1.182
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.181 2014/08/18 04:06:16 dlg Exp $	*/
a247 2
 *
 * Note: add and delete reference must be called at splnet().
d265 1
a265 10
#define	MCLADDREFERENCE(o, n)	do {					\
		int ms = splnet();					\
		(n)->m_flags |= ((o)->m_flags & (M_EXT|M_EXTWR));	\
		(n)->m_ext.ext_nextref = (o)->m_ext.ext_nextref;	\
		(n)->m_ext.ext_prevref = (o);				\
		(o)->m_ext.ext_nextref = (n);				\
		(n)->m_ext.ext_nextref->m_ext.ext_prevref = (n);	\
		splx(ms);						\
		MCLREFDEBUGN((n), __FILE__, __LINE__);			\
	} while (/* CONSTCOND */ 0)
a402 1
struct	mbuf *m_free_unlocked(struct mbuf *);
d417 1
@


1.181
log
@introduce mbuf list and queue apis. both manage fifo lists of mbufs
and a count of the mbufs.

struct mbuf_list and the ml_foo() apis can be used to build lists of
mbufs where you dont need locking (eg, on the stack).

struct mbuf_queue and mq_foo() wrap mbuf_lists with a mutex, and
limits the number of mbufs that can be queued. they can be useful
for moving mbufs between contexts/subsystems.

with help from jmc@@ for the manpage bits
mpi@@ is keen
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.180 2014/07/13 09:52:48 dlg Exp $	*/
a38 1
#include <sys/pool.h>
@


1.180
log
@treat external storage allocated by the mbuf layer the same as
external storage attached to an mbuf anywhere else. this means it
uses MEXTADD to wire it up to the mbuf, and it relies on the ext_free
and ext_arg bits in the header to call the right free function
against the right pool.

M_CLUSTER gets renamed to M_EXTWR. the type field in MEXTADD gets
reused as a flags field so anything attaching storage to an mbuf
can say if it is writable or not.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.179 2014/07/09 13:05:45 dlg Exp $	*/
d482 51
@


1.179
log
@ext_type is set but never read. its a waste of space.

MEXTADD will be fixed later.

ok henning@@ deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.178 2014/07/09 11:22:52 dlg Exp $	*/
d170 1
a170 1
#define M_CLUSTER	0x0008	/* external storage is a cluster */
d188 1
a188 1
    ("\20\1M_EXT\2M_PKTHDR\3M_EOR\4M_CLUSTER\5M_PROTO1\6M_VLANTAG\7M_LOOP" \
d270 1
a270 1
		(n)->m_flags |= ((o)->m_flags & (M_EXT|M_CLUSTER));	\
d295 1
a295 1
#define	MEXTADD(m, buf, size, type, free, arg) do {			\
d297 1
a297 2
	(m)->m_flags |= M_EXT;						\
	(m)->m_flags &= ~M_CLUSTER;					\
d329 1
a329 1
	(to)->m_flags = ((to)->m_flags & (M_EXT | M_CLUSTER));		\
d356 1
a356 1
	  (((m)->m_flags & M_CLUSTER) == 0 || MCLISREFERENCED(m)))
d430 1
@


1.178
log
@now that mclgeti doesnt do the rx ring accounting, cluster allocation
doesnt need to know which ifp an mbuf was allocated on so it can uncount
it on free.

while here, remove the ext_backend field which identifies the pool the
cluster came from and use ext_arg instead.

ok henning@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.177 2014/07/08 07:10:12 dlg Exp $	*/
a130 1
	int	ext_type;
a301 1
	(m)->m_ext.ext_type = (type);					\
@


1.177
log
@pull the rx ring accounting out of the mbuf layer now that its all done
via if_rxring things. this effectively deprecates the third argument
for MCLGETI and m_clget and makes the mbuf layer no longer care about
interfaces and simplifies the allocation paths.

the timeout used to measure livelock has been moved to net/if.c.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.176 2014/04/22 14:41:03 mpi Exp $	*/
d129 1
a129 1
	void	*ext_arg;		/* argument for ext_free */
a131 2
	u_short	ext_ifidx;		/* index of the interface */
	int	ext_backend;		/* backend pool the storage came from */
@


1.176
log
@Remove some altq tentacles.

ok pelikan@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.175 2014/04/14 09:06:42 mpi Exp $	*/
a434 5
void	m_clsetwms(struct ifnet *, u_int, u_int, u_int);
int	m_cldrop(struct ifnet *, int);
void	m_clcount(struct ifnet *, int);
void	m_cluncount(struct mbuf *, int);
void	m_clinitifp(struct ifnet *);
@


1.175
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.174 2014/03/27 10:30:58 mpi Exp $	*/
a84 1
	void		*hdr;		/* saved hdr pos in mbuf, for ECN */
@


1.174
log
@Store an ifp index instead of a pointer in the "struct mbuf_ext".

This is part of the plan to remove the ifp pointer from the packet
header that will allow us to stop garbage collecting mbuf(9)s when
an ifp is detached/destroyed.

ok mikeb@@, lteo@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.173 2014/03/19 10:09:20 mpi Exp $	*/
d120 1
a120 1
	u_int			 rdomain;	/* routing domain id */
@


1.173
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.172 2014/01/19 03:04:54 claudio Exp $	*/
d133 1
a133 1
	struct ifnet* ext_ifp;
@


1.172
log
@Remove max_datalen. It is only used once an can be replaced easily with
MHLEN - max_hdr in that place. OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.171 2014/01/11 04:46:15 lteo Exp $	*/
d114 1
a114 1
	SLIST_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
d121 1
@


1.171
log
@Sync the comments for the M_ICMP_CSUM_* flags with their descriptions in
the mbuf(9) man page.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.170 2014/01/10 00:47:17 bluhm Exp $	*/
a414 1
extern	int max_datalen;		/* MHLEN - max_hdr */
@


1.170
log
@Let "ddb show mbuf" print all mbuf fields in a consistent way.  Move
bit field names into the header file below the definitions to keep
them in sync.
OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.169 2013/11/15 16:15:42 bluhm Exp $	*/
d211 3
a213 3
#define	M_ICMP_CSUM_OUT		0x0200	/* ICMP checksum needed */
#define	M_ICMP_CSUM_IN_OK	0x0400	/* ICMP checksum verified */
#define	M_ICMP_CSUM_IN_BAD	0x0800	/* ICMP checksum bad */
@


1.169
log
@After discussion with deraadt@@ and Fernando Gont, it seems that the
stack should still scan for IPv6 type 0 routing headers.  There are
OpenBSD routers running without pf and there are plenty of legacy
implementations supporting RH0.

Bring back the function ip6_check_rh0hdr() that I removed a month
ago.  As an improvement to the prevoius solution, only scan the
header chain in ip6_input() if the packet has not been inspected
by pf.  Both implementations drop packets with RH0 anywhere in the
extension header chain.

OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.168 2013/10/13 10:10:04 reyk Exp $	*/
d105 6
d189 7
d215 7
d479 5
@


1.168
log
@Import vxlan(4), the virtual extensible local area network tunnel
interface.  VXLAN is a UDP-based tunnelling protocol for overlaying
virtualized layer 2 networks over layer 3 networks. The implementation
is based on draft-mahalingam-dutt-dcops-vxlan-04 and has been tested
with other implementations in the wild.

put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.167 2013/08/21 05:21:46 dlg Exp $	*/
d103 1
@


1.167
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.166 2013/08/13 09:52:54 mpi Exp $	*/
d457 1
@


1.166
log
@When net.inet.ip.sourceroute is enable, store the source route
of incoming IPv4 packets with the SSRR or LSRR header option in
a m_tag rather than in a single static entry.

Use a new m_tag type, PACKET_TAG_SRCROUTE, for this and bump
PACKET_TAG_MAXSIZE accordingly.

Adapted from FreeBSD r135274 with inputs from bluhm@@.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.165 2013/07/06 02:44:23 brad Exp $	*/
d426 1
a426 2
struct mbuf *m_devget(char *, int, int, struct ifnet *,
	    void (*)(const void *, void *, size_t));
@


1.165
log
@Use a tab here to be consistent with the surrounding flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.164 2013/06/03 16:57:06 bluhm Exp $	*/
d457 1
d465 1
a465 1
#define PACKET_TAG_MAXSIZE		40
@


1.164
log
@Link pf states and socket inpcbs together more tightly.  The linking
was only done when a packet traveled up the stack from pf to
tcp_input().  Now also link the state and inpcb when the packet is
going down from tcp_output() to pf.  As a consequence, divert-reply
states where the initial SYN does not get an answer, can be handled
more correctly.

This change is part of a larger diff that has been backed out in
2011.  Bring the feature back in small steps to see when bad things
start to happen.

OK henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.163 2013/04/02 03:34:31 lteo Exp $	*/
d189 1
a189 1
#define M_TCP_CSUM_OUT		0x0002	/* TCP checksum needed */
@


1.163
log
@Remove "/IPv4" from the comments of the M_{TCP,UDP}_CSUM_IN_* flags,
since they are also used for TCP or UDP checksums over IPv6 (originally
pointed out by naddy@@ when I was updating the mbuf(9) man page).

ok bluhm claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.162 2013/03/29 13:16:14 bluhm Exp $	*/
d82 1
d87 1
@


1.162
log
@Declare struct pf_state_key in the mbuf and in_pcb header files to
avoid ugly casts.
OK krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.161 2013/02/07 11:06:42 mikeb Exp $	*/
d191 4
a194 4
#define	M_TCP_CSUM_IN_OK	0x0020	/* TCP/IPv4 checksum verified */
#define	M_TCP_CSUM_IN_BAD	0x0040	/* TCP/IPv4 checksum bad */
#define	M_UDP_CSUM_IN_OK	0x0080	/* UDP/IPv4 checksum verified */
#define	M_UDP_CSUM_IN_BAD	0x0100	/* UDP/IPv4 checksum bad */
@


1.161
log
@convert mbuf tags to use pool(9) as a backend storage;
ok markus claudio haesbaert henning
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.160 2013/01/16 10:38:27 deraadt Exp $	*/
d81 2
d85 1
a85 1
	void		*statekey;	/* pf stackside statekey */
@


1.160
log
@Move MAXMCLBYTES to mbuf.h so that fewer parts of userland see it.
ok matthieu
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.159 2012/10/05 12:27:02 camield Exp $	*/
d453 8
@


1.159
log
@protect against multiple inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.158 2012/09/26 14:53:23 markus Exp $	*/
d53 3
a55 3
/* smallest amount to put in cluster */
#define	MINCLSIZE	(MHLEN + MLEN + 1)
#define	M_MAXCOMPRESS	(MHLEN / 2)	/* max amount to copy for compression */
@


1.158
log
@add M_ZEROIZE as an mbuf flag, so copied PFKEY messages (with embedded keys)
are cleared as well; from hshoexer@@, feedback and ok bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.157 2012/09/19 17:50:17 yasuoka Exp $	*/
d35 3
d454 2
a455 1
#endif
@


1.157
log
@cleanup around the pipex.  naming style, delete or update comments.
no functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.156 2012/01/14 12:11:35 haesbaert Exp $	*/
d171 1
a171 1
#define M_AUTH_AH	0x2000  /* header was authenticated (AH) */
d177 2
a178 1
			 M_AUTH|M_LOOP|M_TUNNEL|M_LINK0|M_VLANTAG|M_FILDROP)
a420 1
void	m_zero(struct mbuf *);
@


1.156
log
@Remove struct mclsizes, this is a left over.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.155 2011/07/08 18:48:51 henning Exp $	*/
d448 1
a448 1
#define PACKET_TAG_PIPEX		0x0400 /* pipex context XXX */
@


1.155
log
@new priority queueing implementation, extremely low overhead, thus fast.
unconditional, always on. 8 priority levels, as every better switch, the
vlan header etc etc. ok ryan mpf sthen, pea tested as well
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.154 2011/06/17 23:45:19 bluhm Exp $	*/
a377 5

struct	mclsizes {
	u_int	size;
	u_int	hwm;
};
@


1.154
log
@Remove obsolete mbuf PF_TAG_FRAGCACHE flag.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.153 2011/05/13 14:31:17 oga Exp $	*/
d85 2
@


1.153
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.152 2011/05/04 16:05:49 blambert Exp $	*/
a88 1
#define	PF_TAG_FRAGCACHE		0x02
@


1.152
log
@Collapse m_pullup and m_pullup2 into a single function, as they're
essentially identical; the only difference being that m_pullup2 is
capable of handling mbuf clusters, but called m_pullup for shorter
lengths (!).

testing dlg@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.151 2011/04/24 19:36:54 bluhm Exp $	*/
a80 1
	void		*inp;		/* connected pcb for outgoing packet */
@


1.151
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.150 2011/04/06 19:15:34 markus Exp $	*/
a405 1
struct	mbuf *m_pullup2(struct mbuf *, int);
@


1.150
log
@uncompress a packet with an IPcomp header only once; this prevents
endless loops by IPcomp-quine attacks as discovered by Tavis Ormandy;
it also prevents nested IPcomp-IPIP-IPcomp attacks provied by matthew@@;
feedback and ok matthew@@, deraadt@@, djm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.149 2011/04/05 20:31:41 henning Exp $	*/
d81 1
@


1.149
log
@define M_ICMP_CSUM_{OUT,OK,BAD} for consistency with tcp and udp
dunno wether there is any hardware that supports icmp cksum offloading,
but that's not the point - we're moving towards a world where the stack
doesn't bother with setting checksums, and lets the hardware do them. in
case the harware can't the output routines cope
ok dlg, claudio kinda too, he's fondueing and thus not reading the diff
but i explained it to him and he agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.148 2011/04/05 18:01:21 henning Exp $	*/
d171 1
d175 1
a175 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|\
@


1.148
log
@mechanic rename M_{TCP|UDP}V4_CSUM_OUT -> M_{TCP|UDP}_CSUM_OUT
ok claudio krw
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.147 2011/04/05 11:48:28 blambert Exp $	*/
d187 3
@


1.147
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.146 2011/04/04 14:35:31 blambert Exp $	*/
d179 2
a180 2
#define M_TCPV4_CSUM_OUT	0x0002	/* TCP checksum needed */
#define	M_UDPV4_CSUM_OUT	0x0004	/* UDP checksum needed */
@


1.146
log
@When moving packet header data from mbuf to mbuf, re-init the list
of mbuf tags on the `from' mbuf so that we're not in danger of
double-freeing should the M_PKTHDR flag somehow sneak back to
that mbuf.

I'm almost sure that this is theoretical, but I'm erring on the
side of paranoia.

Found when chasing a panic report from phessler@@

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.145 2011/03/24 20:09:45 bluhm Exp $	*/
d424 1
a424 1
int	m_dup_pkthdr(struct mbuf *, struct mbuf *);
d432 2
a433 2
struct m_tag *m_tag_copy(struct m_tag *);
int	m_tag_copy_chain(struct mbuf *, struct mbuf *);
@


1.145
log
@Reassemble IPv6 fragments in pf.  In the forward case, pf refragments
the packets with the same maximum size.  This allows the sender to
determine the optimal fragment size by Path MTU Discovery.
testing sthen@@ matthieu@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.144 2010/11/05 15:17:50 claudio Exp $	*/
d287 1
a287 1
 * remove M_PKTHDR and clean the tag for from.
d292 1
@


1.144
log
@Implement m_print as real ddb command "show mbuf addr" in the way other
such commands are implemented.
"Ja! You'll need to update ddb.4 as well, of course." miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.143 2010/10/28 16:28:56 claudio Exp $	*/
d94 1
d449 1
@


1.143
log
@Add m_print() a function to print mbuf headers. Can be called from ddb
with an mbuf pointer as argument to see the contents of it.
OK thib@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.142 2010/07/14 10:31:54 matthew Exp $	*/
a422 3
#ifdef DDB
void m_print(struct mbuf *);
#endif
@


1.142
log
@Eliminate some unused malloc(9) type defines.  Also get rid of the
mysterious and unused mbtypes[] array in mbuf.h.

ok tedu@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.141 2010/07/02 02:40:17 blambert Exp $	*/
d423 3
@


1.141
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.140 2010/01/11 03:50:56 yasuoka Exp $	*/
a384 1
extern	int mbtypes[];			/* XXX */
a448 12
#ifdef MBTYPES
int mbtypes[] = {				/* XXX */
	M_FREE,		/* MT_FREE	0	   should be on free list */
	M_MBUF,		/* MT_DATA	1	   dynamic (data) allocation */
	M_MBUF,		/* MT_HEADER	2	   packet header */
	M_MBUF,		/* MT_SONAME	8	   socket name */
	M_SOOPTS,	/* MT_SOOPTS	10	   socket options */
	M_FTABLE,	/* MT_FTABLE	11	   fragment reassembly header */
	M_MBUF,		/* MT_CONTROL	14	   extra-data protocol message */
	M_MBUF,		/* MT_OOBDATA	15	   expedited data  */
};
#endif /* MBTYPES */
@


1.140
log
@Initial import PIPEX.  PIPEX(Pppac IP EXtension) is a IP forwarding
acceleration for PPP access concentrator.

ok mcbride@@ dlg@@ deraadt@@ reyk@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.139 2009/11/03 10:59:04 claudio Exp $	*/
d413 1
a413 1
void	m_copyback(struct mbuf *, int, int, const void *);
@


1.139
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.138 2009/10/06 21:21:48 claudio Exp $	*/
d448 1
@


1.138
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.137 2009/10/04 16:08:37 michele Exp $	*/
a81 1
	u_int		 rtableid;	/* alternate routing table id */
@


1.137
log
@Add (again) support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 1

A lot of discussion have happened since my last commit that resulted
in many changes and improvements.
I would *really* like to thank everyone who took part in the discussion
especially canacar@@ who spotted out which are the limitations of this approach.

OpenBSD divert(4) is meant to be compatible with software running on
top of FreeBSD's divert sockets even though they are pretty different and will
become even more with time.

discusses with many, but mainly reyk@@ canacar@@ deraadt@@ dlg@@ claudio@@ beck@@
tested by reyk@@ and myself
ok reyk@@ claudio@@ beck@@
manpage help and ok by jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.136 2009/09/13 14:42:52 krw Exp $	*/
d94 1
@


1.136
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.135 2009/09/08 17:52:18 michele Exp $	*/
d93 1
@


1.135
log
@I had not enough oks to commit this diff.
Sorry.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.133 2009/08/12 20:02:42 dlg Exp $	*/
a292 14
 * Duplicate mbuf pkthdr from from to to.
 * from must have M_PKTHDR set, and to must be empty.
 */
#define M_DUP_PKTHDR(to, from) do {					\
	(to)->m_flags = ((to)->m_flags & (M_EXT | M_CLUSTER));		\
	(to)->m_flags |= (from)->m_flags & M_COPYFLAGS;			\
	(to)->m_pkthdr = (from)->m_pkthdr;				\
	SLIST_INIT(&(to)->m_pkthdr.tags);				\
	m_tag_copy_chain((to), (from));					\
	if (((to)->m_flags & M_EXT) == 0)				\
		(to)->m_data = (to)->m_pktdat;				\
} while (/* CONSTCOND */ 0)

/*
d422 1
@


1.134
log
@Add support for divert sockets. They allow you to:

- queue packets from pf(4) to a userspace application
- reinject packets from the application into the kernel stack.

The divert socket can be bound to a special "divert port" and will
receive every packet diverted to that port by pf(4).

The pf syntax is pretty simple, e.g.:

pass on em0 inet proto tcp from any to any port 80 divert-packet port 8000

test, bugfix and ok by reyk@@
manpage help and ok by jmc@@
no objections from many others.
@
text
@a92 1
#define	PF_TAG_DIVERTED_PACKET		0x10
@


1.133
log
@revert my change to m_cluncount which tries to prevent the system
running out of mbufs for rx rings.

if the system low watermark is lower than a rx rings low watermark,
we'll never send a packet up the stack, we'll always recycle it.

found by thib@@ on a bge
sadface
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.132 2009/08/12 14:39:05 dlg Exp $	*/
d93 1
@


1.132
log
@if we get dangerously low on clusters during interrupts, we need
to free some for use on the rx rings on network cards.

this modifies m_cluncount to advise callers when we're in such a
situation, and makes them responsible for freeing up the cluster
for allocation by MCLGETI later.

fixes an awesome lockup with sis(4) henning has been experiencing.
this is not the best fix, but it is better than the current situation.

yep deraadt@@ tested by henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.131 2009/08/09 21:26:45 deraadt Exp $	*/
d423 1
a423 1
int	m_cluncount(struct mbuf *);
@


1.131
log
@PACKET_TAG_NONE is not used. ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.130 2009/08/09 18:45:30 henning Exp $	*/
d423 1
a423 1
void	m_cluncount(struct mbuf *, int);
@


1.130
log
@kill M_DUP_HDR. M_DUP_PKTHDR was the only user, we can just put the
3 lines of code in there directly, and we hate the M_ macros anyway.
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.129 2009/08/09 13:53:03 henning Exp $	*/
a449 1
#define PACKET_TAG_NONE			0x0000  /* Nadda */
@


1.129
log
@no point in clearing/re-initing packet header fields in a non-packet-header
mbuf. ok claudio theo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.128 2009/08/09 12:51:08 henning Exp $	*/
a292 9
 * Duplicate just m_pkthdr from from to to.
 */
#define M_DUP_HDR(to, from) do {					\
	(to)->m_pkthdr = (from)->m_pkthdr;				\
	SLIST_INIT(&(to)->m_pkthdr.tags);				\
	m_tag_copy_chain((to), (from));					\
} while (/* CONSTCOND */ 0)

/*
d299 3
a301 1
	M_DUP_HDR((to), (from));					\
@


1.128
log
@16 bits are enough for tagsset
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.127 2009/08/09 12:50:09 henning Exp $	*/
a289 1
	SLIST_INIT(&(from)->m_pkthdr.tags);				\
@


1.127
log
@make mbuf tags suck a bit less, performance wise.
the most common operation is checking for a particular tag to be there.
in the majority of the cases it is not.
introduce a "tagsset" in the mbuf packet header which has a bit for
each mbuf tag type that is in the chain set, checking for its existance
is now as easy and cheap as (tagsset & type) != 0. theo ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.126 2009/08/09 12:42:09 deraadt Exp $	*/
d99 2
a100 1
	u_int32_t		 tagsset;	/* mtags attached */
@


1.126
log
@create a m_free_unlocked which is now used by both m_freem() and m_free().
this lets m_freem() only do one splnet/splx instead of repeating this all
the way down a chain
ok henning claudio dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.125 2009/08/09 11:53:54 deraadt Exp $	*/
d99 1
d457 11
a467 13
#define PACKET_TAG_NONE				0  /* Nadda */
#define PACKET_TAG_IPSEC_IN_DONE		1  /* IPsec applied, in */
#define PACKET_TAG_IPSEC_OUT_DONE		2  /* IPsec applied, out */
#define PACKET_TAG_IPSEC_IN_CRYPTO_DONE		3  /* NIC IPsec crypto done */
#define PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED	4  /* NIC IPsec crypto req'ed */
#define PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO	5  /* NIC notifies IPsec */
#define PACKET_TAG_IPSEC_PENDING_TDB		6  /* Reminder to do IPsec */
#define PACKET_TAG_BRIDGE			7  /* Bridge processing done */
#define PACKET_TAG_GIF				8  /* GIF processing done */
#define PACKET_TAG_GRE				9  /* GRE processing done */
#define PACKET_TAG_IN_PACKET_CHECKSUM		10 /* NIC checksumming done */
#define PACKET_TAG_DLT				17 /* data link layer type */
#define PACKET_TAG_PF_DIVERT			18 /* pf(4) diverted packet */
@


1.125
log
@protect MCLGET() from inheriting the new semantics of MCLGETI() by casting
it to void
idea from damien
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.124 2009/08/09 11:40:58 deraadt Exp $	*/
d410 1
@


1.124
log
@MCLGETI() will now allocate a mbuf header if it is not provided, thus
reducing the amount of splnet/splx dancing required.. especially in the
worst case (of m_cldrop)
ok dlg kettenis damien
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.123 2009/06/05 00:05:22 claudio Exp $	*/
d271 1
a271 1
#define MCLGET(m, how) m_clget((m), (how), NULL, MCLBYTES)
@


1.123
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.122 2009/06/02 00:05:13 blambert Exp $	*/
d424 1
a424 1
void	m_clget(struct mbuf *, int, struct ifnet *, u_int);
@


1.122
log
@Move M_PREPEND macro code to be entirely into m_prepend the function;
calling M_PREPEND is now #define'd to be calling m_prepend.

Shaves an unknown but assumed-to-be-nontrivial amount from the kernel.

ok claudio@@ henning@@(who may have had to okay this twice to get me to notice)
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.121 2009/01/27 09:17:51 dlg Exp $	*/
d81 1
a82 1
	u_int32_t	 qid;		/* queue id */
d101 1
@


1.121
log
@make drivers tell the mclgeti allocator what their maximum ring size is
to prevent the hwm growing beyond that. this allows the livelock mitigation
to do something where the hwm used to grow beyond twice the rx rings size.

ok kettenis@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.120 2008/12/23 01:06:33 deraadt Exp $	*/
d363 2
a364 9
#define	M_PREPEND(m, plen, how) do {					\
	if (M_LEADINGSPACE(m) >= (plen)) {				\
		(m)->m_data -= (plen);					\
		(m)->m_len += (plen);					\
	} else								\
		(m) = m_prepend((m), (plen), (how));			\
	if ((m) && (m)->m_flags & M_PKTHDR)				\
		(m)->m_pkthdr.len += (plen);				\
} while (/* CONSTCOND */ 0)
@


1.120
log
@The splvm() protection is way outdated, only splnet is needed to protect
this pool (and the mbstat variables, and a few other things in certain
cases)
ok mikeb, tedu, and discussion with others...
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.119 2008/12/11 16:45:44 deraadt Exp $	*/
d431 1
a431 1
void	m_clsetlwm(struct ifnet *, u_int, u_int);
@


1.119
log
@export per-interface mbuf cluster pool use statistics out to userland
inside if_data, so that netstat(1) and systat(1) can see them
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.118 2008/11/26 17:36:23 dlg Exp $	*/
d214 1
a214 1
 * Note: add and delete reference must be called at splvm().
d233 1
a233 1
		int ms =  splvm();					\
@


1.118
log
@provide m_clsetlwm, an interface for an interface to raise its low
watermark for mbuf cluster allocations.

this is necessary for things like bge which cannot cope with less than a
certain number of pkts on the ring.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.117 2008/11/26 16:48:16 claudio Exp $	*/
d435 1
@


1.117
log
@Make M_DUP_PKTHDR and M_MOVE_PKTHDR a bit saver by respecting the M_EXT &
M_CLUSTER flags from the target mbuf. Still these function are only allowed
on newly allocated buffers.
OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.116 2008/11/25 19:09:34 claudio Exp $	*/
d431 1
@


1.116
log
@m_defrag() a mbuf chain defragmenter. It will collaps a mbuf chain into a
single buffer without changing the head mbuf. This is done with a lot of
magic so there will be dragons.
Tested and OK dlg@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.115 2008/11/25 12:47:00 deraadt Exp $	*/
d304 2
a305 1
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS;			\
d307 2
a308 1
	(to)->m_data = (to)->m_pktdat;					\
d316 2
a317 1
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS;			\
d319 2
a320 1
	(to)->m_data = (to)->m_pktdat;					\
@


1.115
log
@Factor increases are not needed, +1 appears to work as well.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.114 2008/11/25 12:07:55 claudio Exp $	*/
d416 1
@


1.114
log
@m_cluncount() needs to walk the mbuf chain to correctly uncount all clusters
but don't do that in m_free() as that will cause a double loop behaviour when
called via m_freem().
OK dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.113 2008/11/24 15:14:33 claudio Exp $	*/
a395 1
	u_int	factor;
@


1.113
log
@MCLADDREFERENCE() was the last user of MBUFLOCK() inline the code and remove
MBUFLOCK()
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.112 2008/11/24 15:09:39 claudio Exp $	*/
d429 1
a429 1
void	m_cluncount(struct mbuf *);
@


1.112
log
@Another unused macro that needs to go is MCHTYPE. Changing the allocation
type of a mbuf after creation is just wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.111 2008/11/24 15:06:55 claudio Exp $	*/
a197 13
 * mbuf utility macros:
 *
 *	MBUFLOCK(code)
 * prevents a section of code from from being interrupted by network
 * drivers.
 */
#define	MBUFLOCK(code) do {						\
	int ms = splvm();						\
	{ code }							\
	splx(ms);							\
} while (/* CONSTCOND */ 0)

/*
d232 2
a233 1
#define	_MCLADDREFERENCE(o, n)	do {					\
d239 1
a248 2

#define	MCLADDREFERENCE(o, n)	MBUFLOCK(_MCLADDREFERENCE((o), (n));)
@


1.111
log
@Let MRESETDATA follow MEXTMALLOC. That macro is way to dangerous but luckily
it is unused.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.110 2008/11/24 15:04:37 claudio Exp $	*/
a379 9
} while (/* CONSTCOND */ 0)

/* change mbuf to new type */
#define MCHTYPE(m, t) do {						\
	MBUFLOCK(							\
		mbstat.m_mtypes[(m)->m_type]--;				\
		mbstat.m_mtypes[t]++;					\
	);								\
	(m)->m_type = t;						\
@


1.110
log
@Bye bye MEXTMALLOC you're not used and you should not be used. You're evil.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.109 2008/11/24 12:57:37 dlg Exp $	*/
a284 12

/*
 * Reset the data pointer on an mbuf.
 */
#define	MRESETDATA(m) do {						\
	if ((m)->m_flags & M_EXT)					\
		(m)->m_data = (m)->m_ext.ext_buf;			\
	else if ((m)->m_flags & M_PKTHDR)				\
		(m)->m_data = (m)->m_pktdat;				\
	else								\
		(m)->m_data = (m)->m_dat;				\
} while (/* CONSTCOND */ 0)
@


1.109
log
@add several backend pools to allocate mbufs clusters of various sizes out
of. currently limited to MCLBYTES (2048 bytes) and 4096 bytes until pools
can allocate objects of sizes greater than PAGESIZE.

this allows drivers to ask for "jumbo" packets to fill rx rings with.

the second half of this change is per interface mbuf cluster allocator
statistics. drivers can use the new interface (MCLGETI), which will use
these stats to selectively fail allocations based on demand for mbufs. if
the driver isnt rapidly consuming rx mbufs, we dont allow it to allocate
many to put on its rx ring.

drivers require modifications to take advantage of both the new allocation
semantic and large clusters.

this was written and developed with deraadt@@ over the last two days
ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.108 2008/11/23 16:17:17 dlg Exp $	*/
a265 3
 * MEXTMALLOC allocates external storage and adds it to
 * a normal mbuf; the flag M_EXT is set upon success.
 *
a271 15
#define	MEXTMALLOC(m, size, how) do {					\
	(m)->m_ext.ext_buf =						\
	    (caddr_t)malloc((size), mbtypes[(m)->m_type], (how));	\
	if ((m)->m_ext.ext_buf != NULL) {				\
		(m)->m_data = (m)->m_ext.ext_buf;			\
		(m)->m_flags |= M_EXT;					\
		(m)->m_flags &= ~M_CLUSTER;				\
		(m)->m_ext.ext_size = (size);				\
		(m)->m_ext.ext_free = NULL;				\
		(m)->m_ext.ext_arg = NULL;				\
		(m)->m_ext.ext_type = mbtypes[(m)->m_type];		\
		MCLINITREFERENCE(m);					\
	}								\
} while (/* CONSTCOND */ 0)

@


1.108
log
@rename struct m_ext to be struct mbuf_ext.

ok deraadt@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.107 2008/11/07 17:31:24 deraadt Exp $	*/
d112 2
d301 2
a302 1
#define MCLGET(m, how) m_clget((m), (how))
d444 7
d478 4
a481 1
void	m_clget(struct mbuf *, int);
@


1.107
log
@use do { } while (/* CONSTCOND */ 0) loops for all multi-line macros
ok dlg otto claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.106 2008/11/02 10:37:29 claudio Exp $	*/
d105 1
a105 1
struct m_ext {
d128 1
a128 1
				struct	m_ext MH_ext;	/* M_EXT set */
@


1.106
log
@Remove the M_ANYCAST6 mbuf flag by doing the detection all in ip6_input().
M_ANYCAST6 was only used to signal tcp6_input() that it should drop the
packet and send back icmp error. This can be done in ip6_input() without
the need for a mbuf flag. Gives us back one slot in m_flags for possible
future need. Looked at and some input by naddy@@ and henning@@. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.105 2008/10/17 19:06:01 claudio Exp $	*/
d206 1
a206 1
} while(/* CONSTCOND */ 0)
d304 1
a304 2
#define	MRESETDATA(m)							\
do {									\
d324 1
a324 1
#define M_MOVE_HDR(to, from) {						\
d328 1
a328 1
}
d333 1
a333 1
#define M_DUP_HDR(to, from) {						\
d337 1
a337 1
}
d343 1
a343 1
#define M_DUP_PKTHDR(to, from) {					\
d347 1
a347 1
}
d353 1
a353 1
#define	M_MOVE_PKTHDR(to, from) {					\
d357 1
a357 1
}
d364 1
a364 1
	{ (m)->m_data += (MLEN - (len)) &~ (sizeof(long) - 1); }
d370 1
a370 1
	{ (m)->m_data += (MHLEN - (len)) &~ (sizeof(long) - 1); }
d399 1
a399 1
#define	M_PREPEND(m, plen, how) {					\
d407 1
a407 1
}
d410 1
a410 1
#define MCHTYPE(m, t) {							\
d416 1
a416 1
}
@


1.105
log
@reorder mbuf flags so they are in numerical order again. brad@@ concurs
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.104 2008/09/18 15:16:30 naddy Exp $	*/
a163 1
#define M_ANYCAST6	0x4000	/* received as IPv6 anycast */
d168 1
a168 2
			 M_AUTH|M_ANYCAST6|M_LOOP|M_TUNNEL|M_LINK0|M_VLANTAG|\
			 M_FILDROP)
@


1.104
log
@Introduce the infrastructure required to support hardware VLAN tag
stripping:  Add a field to the mbuf pkthdr to hold the tag and an
mbuf flag that tells if the tag is valid.  Inspired by FreeBSD.

Struct packing suggested by kettenis@@.   csum_flags is now 16 bits.
Adapt to this in the drivers.

ok reyk@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.103 2008/08/29 08:13:08 jmc Exp $	*/
d155 5
a159 2
#define	M_BCAST		0x0100	/* send/received as link-level broadcast */
#define	M_MCAST		0x0200	/* send/received as link-level multicast */
d162 1
a163 1
#define M_TUNNEL	0x1000  /* IP-in-IP added by tunnel mode IPsec */
a165 3
#define M_VLANTAG	0x0020	/* ether_vtag is valid */
#define M_LOOP		0x0040	/* for Mbuf statistics */
#define M_FILDROP	0x0080	/* dropped by bpf filter */
@


1.103
log
@MSIZE and MCLBYTES are now defined in sys/param.h; from Jordan Gordeev
ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.102 2008/08/14 19:39:40 claudio Exp $	*/
d99 2
a100 1
	int			 csum_flags;	/* checksum flags */
d163 1
d169 2
a170 1
			 M_AUTH|M_ANYCAST6|M_LOOP|M_TUNNEL|M_LINK0|M_FILDROP)
@


1.102
log
@Kill the _MCLDEREFERENCE() macro it was only used once and it should be only
used once -- in m_free(). Removed so that people don't get stupid ideas.
OK thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.101 2008/08/07 18:33:49 henning Exp $	*/
d40 1
a40 1
 * Mbufs are of a single size, MSIZE (machine/param.h), which
d42 1
a42 1
 * MCLBYTES (also in machine/param.h), which has no additional overhead
@


1.101
log
@grow MINCLSIZE to MHLEN + MLEN + 1 again. we shrinked it just before the
release to be on the safe side, now we have 6 months to find remaining
offenders misusing MINCLSIZE
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.99 2008/06/12 01:47:07 henning Exp $	*/
a240 7

#define	_MCLDEREFERENCE(m)	do {					\
		(m)->m_ext.ext_nextref->m_ext.ext_prevref =		\
			(m)->m_ext.ext_prevref;				\
		(m)->m_ext.ext_prevref->m_ext.ext_nextref =		\
			(m)->m_ext.ext_nextref;				\
	} while (/* CONSTCOND */ 0)
@


1.100
log
@shrink MINCLSIZE to MHLEN + 1 again for the release, we're not confident
enough yet that all drivers handle this correctly. intended to be grown
again after release. discussed with claudio, thib and theo
@
text
@d51 1
a51 1
#define	MINCLSIZE	(MHLEN + 1)
@


1.99
log
@undo r1.77 from 2004 - shrinking MINCLSIZE so that we always use a cluster
for data storage instead of another mbuf if it would fit. we did that
change whiledoing the release and we thought there was a problem with this,
which later turned out not to be true. surprise and ok theo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.98 2008/06/11 02:46:35 henning Exp $	*/
d51 1
a51 1
#define	MINCLSIZE	(MHLEN + MLEN + 1)
@


1.98
log
@store a pointer to the stack side state key in the mbuf packet
header inbound. on the outbound side, we take that and look for the key
that is the exact opposite, and store that mapping in the state key. on
subsequent packets we don't have to do the lookup on outbound any more.
almost unable to get real benchmarks going here, we know for sure this
gives a more than 5% increase in forwarding performance.
many thanks to ckuethe for stress- and performance-testing.
ok ryan theo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.97 2008/05/09 02:44:54 markus Exp $	*/
d50 2
a51 1
#define	MINCLSIZE	(MHLEN + 1)	/* smallest amount to put in cluster */
@


1.97
log
@divert packets to local socket without modifying the ip header;
makes transparent proxies much easier; ok beck@@, feedback claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.96 2007/11/28 14:04:26 deraadt Exp $	*/
d79 1
@


1.96
log
@move protos to right place
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.95 2007/11/27 16:38:50 tedu Exp $	*/
d90 1
d511 1
@


1.95
log
@make the deceptively complicated leading and trailing space into functions.
this reduces kernel size quite a bit. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.94 2007/09/26 13:05:52 henning Exp $	*/
a388 1
int m_leadingspace(struct mbuf *);
a394 1
int m_trailingspace(struct mbuf *);
d470 2
@


1.94
log
@provide m_inithdr(), which takes an mbuf and gives an initialized M_PKTHDR
mbuf back.
for fixing PR5563 in a few, tested janjaap@@stack.nl, ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.93 2007/09/19 18:19:10 blambert Exp $	*/
d389 2
a390 7
#define	_M_LEADINGSPACE(m)						\
	((m)->m_flags & M_EXT ? (m)->m_data - (m)->m_ext.ext_buf :	\
	 (m)->m_flags & M_PKTHDR ? (m)->m_data - (m)->m_pktdat :	\
	 (m)->m_data - (m)->m_dat)

#define	M_LEADINGSPACE(m)	\
	(M_READONLY((m)) ? 0 : _M_LEADINGSPACE((m)))
d396 2
a397 7
#define	_M_TRAILINGSPACE(m)						\
	((m)->m_flags & M_EXT ? (m)->m_ext.ext_buf +			\
	    (m)->m_ext.ext_size - ((m)->m_data + (m)->m_len) :		\
	    &(m)->m_dat[MLEN] - ((m)->m_data + (m)->m_len))

#define	M_TRAILINGSPACE(m)	\
	(M_READONLY((m)) ? 0 : _M_TRAILINGSPACE((m)))
@


1.93
log
@several changes:

- unconditionally include sys/malloc.h
- remove empty and unused MCLBUFREF macro
- remove unused m_clalloc function declaration
- style(9)-ify macros
- remove external declarations of mbpool and mclpool
- minor comment edit for clarity and accuracy
- move MCLGET definition to more logical place

ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.92 2007/07/20 09:59:19 claudio Exp $	*/
d474 1
@


1.92
log
@Remove the MFREE() macro and replace it with a call to m_free().
Also remove the _MEXTREMOVE macro which was only used by MFREE.
This time with the uipc_mbuf.c change that I missed last time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.91 2007/07/10 04:43:46 miod Exp $	*/
a34 1
#ifndef _SYS_MALLOC_H_
a35 1
#endif
d198 4
a201 4
#define	MBUFLOCK(code) do {\
	int ms = splvm(); \
	  { code } \
	  splx(ms); \
a236 1
#define	MCLBUFREF(p)
d238 1
d245 1
d254 1
a266 3
 * MCLGET allocates and adds an mbuf cluster to a normal mbuf;
 * the flag M_EXT is set upon success.
 *
d271 4
a274 1
 * a normal mbuf; the flag M_EXT is set upon success.
d276 13
a288 13
#define	MEXTMALLOC(m, size, how) do { \
	(m)->m_ext.ext_buf = \
	    (caddr_t)malloc((size), mbtypes[(m)->m_type], (how)); \
	if ((m)->m_ext.ext_buf != NULL) { \
		(m)->m_data = (m)->m_ext.ext_buf; \
		(m)->m_flags |= M_EXT; \
		(m)->m_flags &= ~M_CLUSTER; \
		(m)->m_ext.ext_size = (size); \
		(m)->m_ext.ext_free = NULL; \
		(m)->m_ext.ext_arg = NULL; \
		(m)->m_ext.ext_type = mbtypes[(m)->m_type]; \
		MCLINITREFERENCE(m); \
	} \
d291 9
a299 9
#define	MEXTADD(m, buf, size, type, free, arg) do { \
	(m)->m_data = (m)->m_ext.ext_buf = (caddr_t)(buf); \
	(m)->m_flags |= M_EXT; \
	(m)->m_flags &= ~M_CLUSTER; \
	(m)->m_ext.ext_size = (size); \
	(m)->m_ext.ext_free = (free); \
	(m)->m_ext.ext_arg = (arg); \
	(m)->m_ext.ext_type = (type); \
	MCLINITREFERENCE(m); \
d302 2
a316 2
#define MCLGET(m, how) m_clget(m, how)

d328 4
a331 4
#define M_MOVE_HDR(to, from) { \
	(to)->m_pkthdr = (from)->m_pkthdr; \
	(from)->m_flags &= ~M_PKTHDR; \
	SLIST_INIT(&(from)->m_pkthdr.tags); \
d337 4
a340 4
#define M_DUP_HDR(to, from) { \
	(to)->m_pkthdr = (from)->m_pkthdr; \
	SLIST_INIT(&(to)->m_pkthdr.tags); \
	m_tag_copy_chain((to), (from)); \
d347 4
a350 4
#define M_DUP_PKTHDR(to, from) { \
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS; \
	M_DUP_HDR((to), (from)); \
	(to)->m_data = (to)->m_pktdat; \
d357 4
a360 4
#define	M_MOVE_PKTHDR(to, from) { \
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS; \
	M_MOVE_HDR((to), (from)); \
	(to)->m_data = (to)->m_pktdat; \
d381 2
a382 2
#define	M_READONLY(m) \
	(((m)->m_flags & M_EXT) != 0 &&	\
d389 3
a391 3
#define	_M_LEADINGSPACE(m) \
	((m)->m_flags & M_EXT ? (m)->m_data - (m)->m_ext.ext_buf : \
	 (m)->m_flags & M_PKTHDR ? (m)->m_data - (m)->m_pktdat : \
d401 3
a403 3
#define	_M_TRAILINGSPACE(m) \
	((m)->m_flags & M_EXT ? (m)->m_ext.ext_buf + (m)->m_ext.ext_size - \
	    ((m)->m_data + (m)->m_len) : \
d415 8
a422 8
#define	M_PREPEND(m, plen, how) { \
	if (M_LEADINGSPACE(m) >= (plen)) { \
		(m)->m_data -= (plen); \
		(m)->m_len += (plen); \
	} else \
		(m) = m_prepend((m), (plen), (how)); \
	if ((m) && (m)->m_flags & M_PKTHDR) \
		(m)->m_pkthdr.len += (plen); \
d426 6
a431 3
#define MCHTYPE(m, t) { \
	MBUFLOCK(mbstat.m_mtypes[(m)->m_type]--; mbstat.m_mtypes[t]++;); \
	(m)->m_type = t;\
a465 2
extern struct pool mbpool;
extern struct pool mclpool;
a482 1
int	m_clalloc(int, int);
@


1.91
log
@Revert previous commit, it probably was intended to come with matching
changes to uipc_mbuf.c, but right now all it causes is infinite recursion.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.89 2007/06/11 11:18:14 henning Exp $	*/
a301 18
#define	_MEXTREMOVE(m) do { \
	if (MCLISREFERENCED(m)) { \
		_MCLDEREFERENCE(m); \
	} else if ((m)->m_flags & M_CLUSTER) { \
		pool_put(&mclpool, (m)->m_ext.ext_buf); \
	} else if ((m)->m_ext.ext_free) { \
		(*((m)->m_ext.ext_free))((m)->m_ext.ext_buf, \
		    (m)->m_ext.ext_size, (m)->m_ext.ext_arg); \
	} else { \
		free((m)->m_ext.ext_buf,(m)->m_ext.ext_type); \
	} \
	(m)->m_flags &= ~(M_CLUSTER|M_EXT); \
	(m)->m_ext.ext_size = 0;	/* why ??? */ \
} while (/* CONSTCOND */ 0)

#define	MEXTREMOVE(m) \
	MBUFLOCK(_MEXTREMOVE((m));)

d322 1
a322 11
#define	MFREE(m, n) \
	MBUFLOCK( \
		mbstat.m_mtypes[(m)->m_type]--; \
		if ((m)->m_flags & M_PKTHDR) \
			m_tag_delete_chain((m)); \
		if ((m)->m_flags & M_EXT) { \
			_MEXTREMOVE((m)); \
		} \
		(n) = (m)->m_next; \
		pool_put(&mbpool, (m)); \
	)
@


1.90
log
@Replace the huge MFREE macro with a simple call to m_free(). On today's
computer the resulting code is smaller and faster. Also remove the
_MEXTREMOVE macro which was only used by MFREE.
OK markus@@ long time ago
@
text
@d302 18
d340 11
a350 1
#define	MFREE(m, n) n = m_free((m))
@


1.89
log
@move definitions for the flags in the mbuf header used by pf to mbuf.h
since we include the mbuf header parts for pf unconditionally, we should
be able to check them unconditionally as well. ok mcbride markus
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.88 2007/05/28 17:16:39 henning Exp $	*/
a301 18
#define	_MEXTREMOVE(m) do { \
	if (MCLISREFERENCED(m)) { \
		_MCLDEREFERENCE(m); \
	} else if ((m)->m_flags & M_CLUSTER) { \
		pool_put(&mclpool, (m)->m_ext.ext_buf); \
	} else if ((m)->m_ext.ext_free) { \
		(*((m)->m_ext.ext_free))((m)->m_ext.ext_buf, \
		    (m)->m_ext.ext_size, (m)->m_ext.ext_arg); \
	} else { \
		free((m)->m_ext.ext_buf,(m)->m_ext.ext_type); \
	} \
	(m)->m_flags &= ~(M_CLUSTER|M_EXT); \
	(m)->m_ext.ext_size = 0;	/* why ??? */ \
} while (/* CONSTCOND */ 0)

#define	MEXTREMOVE(m) \
	MBUFLOCK(_MEXTREMOVE((m));)

d322 1
a322 11
#define	MFREE(m, n) \
	MBUFLOCK( \
		mbstat.m_mtypes[(m)->m_type]--; \
		if ((m)->m_flags & M_PKTHDR) \
			m_tag_delete_chain((m)); \
		if ((m)->m_flags & M_EXT) { \
			_MEXTREMOVE((m)); \
		} \
		(n) = (m)->m_next; \
		pool_put(&mbpool, (m)); \
	)
@


1.88
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.87 2007/05/27 20:54:25 claudio Exp $	*/
d87 5
@


1.87
log
@Kill the nasty MGET, MGETHDR and MCLGET makros and replace them with normal
functions. The world is no longer running on a PDP11 so function call overhead
is not an issue. Diff by tbert, tested by many, OK art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.86 2007/01/03 18:39:56 claudio Exp $	*/
d78 10
d90 1
a90 1
	struct	ifnet *rcvif;		/* rcv interface */
d92 3
a94 2
	int	len;			/* total packet length */
	int	csum_flags;		/* checksum flags */
a540 1
#define PACKET_TAG_PF				11 /* PF */
@


1.86
log
@Remove two "unused" mbuf tag functions and kill the superfluous argument
to the m_tag_delete_chain() function.
m_tag_free() and m_tag_unlink() are only used by m_tag_delete() and I see
no need to have these functions around.
m_tag_delete_chain() has a second argument to specifiy a starting point
from where the chain should be deleted. This feature is never used and is
more complex because it is not possible to remove a SLIST element without
doing a list walk. Instead use SLIST_FIRST() and SLIST_REMOVE_HEAD() to
remove all items from the list. OK dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.85 2005/11/12 20:27:46 brad Exp $	*/
d200 1
a200 12
#define	_MGET(m, how, type) MBUFLOCK( \
	(m) = pool_get(&mbpool, \
	    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	if (m) { \
		(m)->m_type = (type); \
		mbstat.m_mtypes[type]++; \
		(m)->m_next = (struct mbuf *)NULL; \
		(m)->m_nextpkt = (struct mbuf *)NULL; \
		(m)->m_data = (m)->m_dat; \
		(m)->m_flags = 0; \
	} \
)
d202 1
a202 28
#ifdef SMALL_KERNEL
struct mbuf *_sk_mget(int, int);
#define MGET(m, how, type) { m = _sk_mget(how, type); }
#else
#define MGET(m, how, type) _MGET(m, how, type)
#endif

#define	_MGETHDR(m, how, type) MBUFLOCK( \
	(m) = pool_get(&mbpool, \
	    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	if (m) { \
		(m)->m_type = (type); \
		mbstat.m_mtypes[type]++; \
		(m)->m_next = (struct mbuf *)NULL; \
		(m)->m_nextpkt = (struct mbuf *)NULL; \
		(m)->m_data = (m)->m_pktdat; \
		(m)->m_flags = M_PKTHDR; \
		SLIST_INIT(&(m)->m_pkthdr.tags); \
		(m)->m_pkthdr.csum_flags = 0; \
	} \
)

#ifdef SMALL_KERNEL
struct mbuf *_sk_mgethdr(int, int);
#define MGETHDR(m, how, type) { m = _sk_mgethdr(how, type); }
#else
#define MGETHDR(m, how, type) _MGETHDR(m, how, type)
#endif
a259 15
#define	_MCLGET(m, how) do { \
	MBUFLOCK( \
		(m)->m_ext.ext_buf = pool_get(&mclpool, (how) == M_WAIT ? \
		    (PR_WAITOK|PR_LIMITFAIL) : 0); \
	); \
	if ((m)->m_ext.ext_buf != NULL) { \
		(m)->m_data = (m)->m_ext.ext_buf; \
		(m)->m_flags |= M_EXT|M_CLUSTER; \
		(m)->m_ext.ext_size = MCLBYTES;  \
		(m)->m_ext.ext_free = NULL;  \
		(m)->m_ext.ext_arg = NULL;  \
		MCLINITREFERENCE(m); \
	} \
} while (/* CONSTCOND */ 0)

d317 1
a317 6
#ifdef SMALL_KERNEL
void _sk_mclget(struct mbuf *, int);
#define MCLGET(m, how) _sk_mclget(m, how)
#else
#define MCLGET(m, how) _MCLGET(m, how)
#endif
d492 1
@


1.85
log
@splimp -> splvm in MBUFLOCK() macro.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.84 2005/11/03 20:00:18 reyk Exp $	*/
d386 1
a386 1
			m_tag_delete_chain((m), NULL); \
a564 1
void	m_tag_free(struct m_tag *);
a565 1
void	m_tag_unlink(struct mbuf *, struct m_tag *);
d567 1
a567 1
void	m_tag_delete_chain(struct mbuf *, struct m_tag *);
@


1.84
log
@re-implement the bpf "filter drop" option that it actually works. the
bpf FILDROP interface exists for about one year but the required
interface to the drivers was missing - so it was useless. this new
approach based on a design by henning@@ uses a new mbuf flag to mark
filtered packets and to drop them in the generic network stack input
routines (like ether_input).

for example; after some additional testing, this could be used by
dhclient to filter everything except DHCP packets (track tech@@
for a corresponding dhclient diff). the "filter dropped" packets won't
reach the network stack. so it's probably some kind of a very basic
application layer packet filter ;).

ok canacar@@, discussed with henning@@ and others
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.83 2005/10/17 08:43:34 henning Exp $	*/
d185 1
a185 1
	int ms = splimp(); \
@


1.83
log
@make pf use one mbuf tag instead of 6 distinct ones. use a little struct
in the data part for the data from the previously distinct tags.
look up the tag early and carry a pointer to it around.
makes the code easier and saves some tag lookups and thus helps performance,
as proven by tests run by Schberle Dniel <Schoeberle.Daniel@@aamtech.hu>
Initially hacked up somewhere over the atlantic ocean in an A330
early testing reyk and moritz, "put it in" theo
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.82 2005/05/26 01:49:15 markus Exp $	*/
d146 1
d150 1
a150 1
			 M_AUTH|M_ANYCAST6|M_LOOP|M_TUNNEL|M_LINK0)
@


1.82
log
@protect all of MGET/MGETHDR with MBUFLOCK() otherwise we'll splimp/splx
twice for each mbuf allocation; similar to netbsd; ok hshoexer, deraadt, pedro
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.81 2005/04/25 17:55:52 brad Exp $	*/
d588 1
a588 6
#define PACKET_TAG_PF_GENERATED			11 /* PF generated, pass always */
#define PACKET_TAG_PF_ROUTED			12 /* PF routed, no route loops */
#define PACKET_TAG_PF_FRAGCACHE			13 /* PF fragment cached */
#define	PACKET_TAG_PF_QID			14 /* PF queue id */
#define PACKET_TAG_PF_TAG			15 /* PF tags */
#define PACKET_TAG_PF_TRANSLATE_LOCALHOST	16 /* translated to localhost */
@


1.81
log
@csum -> csum_flags

ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.80 2005/04/20 19:59:29 reyk Exp $	*/
d183 2
a184 2
#define	MBUFLOCK(code) \
	{ int ms = splimp(); \
d187 1
a187 1
	}
d199 3
a201 5
#define	_MGET(m, how, type) do { \
	MBUFLOCK( \
	    	(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d204 1
a204 1
		MBUFLOCK(mbstat.m_mtypes[type]++;) \
d210 1
a210 1
} while(/* CONSTCOND */ 0)
d219 3
a221 5
#define	_MGETHDR(m, how, type) do { \
	MBUFLOCK( \
		(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d224 1
a224 1
		MBUFLOCK(mbstat.m_mtypes[type]++;) \
d232 1
a232 1
} while (/* CONSTCOND */ 0)
d496 1
a496 1
	MBUFLOCK(mbstat.m_mtypes[(m)->m_type]--; mbstat.m_mtypes[t]++;) \
@


1.80
log
@add mbuf tag for the data link type

ok canacar@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.79 2005/01/18 23:26:51 mpf Exp $	*/
d83 1
a83 1
	int	csum;			/* Hardware checksum info */
d234 1
a234 1
		(m)->m_pkthdr.csum = 0; \
@


1.79
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.78 2004/11/25 21:54:54 markus Exp $	*/
d598 1
@


1.78
log
@resolve conflict between M_TUNNEL and M_ANYCAST6, remove M_COMP (it's
only set and never read), update documentation; ok fgsch, deraadt, millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.77 2004/09/17 20:17:30 deraadt Exp $	*/
d597 1
a597 2
#define PACKET_TAG_CARP				16 /* CARP info */
#define PACKET_TAG_PF_TRANSLATE_LOCALHOST	17 /* translated to localhost */
@


1.77
log
@move MINCLSIZE back to preferring clusters; there is some fallout because
the other parts of this were not done.  This is a conservative decision
for this release.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.74 2003/12/08 07:07:36 mcbride Exp $	*/
a140 1
#define M_COMP		0x1000  /* payload was compressed (IPCOMP) */
d142 8
a149 1
#define M_TUNNEL	0x4000  /* IP-in-IP added by tunnel mode IPsec */
a160 11

/* KAME IPv6 */
#define M_ANYCAST6	0x4000	/* received as IPv6 anycast */

#define M_LINK0		0x8000	/* link layer specific flag */

#define M_LOOP		0x0040	/* for Mbuf statistics */

/* flags copied when copying m_pkthdr */
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|\
			 M_AUTH|M_COMP|M_ANYCAST6|M_LOOP|M_TUNNEL|M_LINK0)
@


1.76
log
@Add M_LINK0 for net80211; OK markus@@ and mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.75 2004/04/25 18:32:43 itojun Exp $	*/
d52 1
a52 2
/* smallest amount to put in cluster */
#define	MINCLSIZE	(MHLEN + MLEN + 1)
@


1.75
log
@MINCLSIZE value now back to what 4.4bsd defined.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.74 2003/12/08 07:07:36 mcbride Exp $	*/
d76 1
a76 1
	short	mh_flags;		/* flags; see below */
d160 2
d166 1
a166 1
			 M_AUTH|M_COMP|M_ANYCAST6|M_LOOP|M_TUNNEL)
@


1.74
log
@Mbuf tag tcp and udp packets which are translated to localhost, and
use the the presence of this tag to reverse the match order in
in{6}_pcblookup_listen(). Some daemons (such as portmap) do a double
bind, binding to both * and localhost in order to differentiate local
from non-local connections, and potentially granting more privilege to
local ones. This change ensures that redirected connections to localhost
do not appear local to such a daemon.

Bulk of changes from dhartmei@@, some changes markus@@

ok dhartmei@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.73 2003/10/17 21:04:59 mcbride Exp $	*/
d52 2
a53 1
#define	MINCLSIZE	(MHLEN + 1)	/* smallest amount to put in cluster */
@


1.73
log
@Common Address Redundancy Protocol

Allows multiple hosts to share an IP address, providing high availability
and load balancing.

Based on code by mickey@@, with additional help from markus@@
and Marco_Pfatschbacher@@genua.de

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.72 2003/08/12 05:09:17 mickey Exp $	*/
d601 1
@


1.72
log
@src argument to m_copyback() can be a const; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.71 2003/07/28 10:10:16 markus Exp $	*/
d600 1
@


1.71
log
@allow gif(4) over ipsec: mark mbuf for transport mode SA,
so in_gif_input can detect whether a proto 4 header is due
to ipsec tunnel mode or gif(4) encapsulation; fixes pr 3023
ok itojun@@. provos@@ and angelos@@ agree; tested by sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.70 2003/06/02 23:28:21 millert Exp $	*/
d558 1
a558 1
void	m_copyback(struct mbuf *, int, int, caddr_t);
@


1.70
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.69 2003/05/13 17:33:16 henning Exp $	*/
d143 1
d162 2
a163 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_COMP|M_ANYCAST6|M_LOOP)
@


1.69
log
@add PACKET_TAG_PF_TAG, to be used by PF
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.68 2003/02/12 14:41:08 jason Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.68
log
@Remove commons; inspired by netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.67 2002/10/08 05:12:08 kjc Exp $	*/
d601 1
@


1.67
log
@the first step of pf/altq merge.
this commit is to allow further development in both userland and kernel.

the goal is to replace altq's classifier by pf(4).
- make pf tag a queue id to mbuf and make altq read the queue id
- merge altq config into pf.conf(5)

ok dhartmei@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.66 2002/07/03 21:19:08 miod Exp $	*/
d532 1
a532 1
struct	mbstat mbstat;
@


1.66
log
@Change all variables definitions (int foo) in sys/sys/*.h to variable
declarations (extern int foo), and compensate in the appropriate locations.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.65 2002/06/11 02:19:56 frantzen Exp $	*/
d600 1
@


1.65
log
@add PACKET_TAG_PF_FRAGCACHE mbuf tag so we don't think a outbound fragment
is a duplicate because we saw it first on the inbound direction
ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.64 2002/06/09 04:49:06 frantzen Exp $	*/
d39 1
a39 1
#ifndef M_WAITOK
d536 4
a539 4
int	max_linkhdr;			/* largest link-level header */
int	max_protohdr;			/* largest protocol header */
int	max_hdr;			/* largest link+protocol header */
int	max_datalen;			/* MHLEN - max_hdr */
@


1.64
log
@M_TCPV4_CSUM_OUT=0x0002 not 0x2002
ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.63 2002/06/09 00:57:05 itojun Exp $	*/
d599 1
@


1.63
log
@add M_AUTH_AH.  now M_AUTH means "payload was authenticated by AH or ESP auth",
M_AUTH_AH means "header was authenticated by AH".
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.62 2002/06/07 19:57:45 dhartmei Exp $	*/
d150 1
a150 1
#define M_TCPV4_CSUM_OUT	0x2002	/* TCP checksum needed */
@


1.62
log
@Add mbuf tag PACKET_TAG_PF_ROUTED, used to prevent loops for pf routed
packets. ok angelos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.61 2002/06/03 12:04:06 deraadt Exp $	*/
d143 4
a146 3
#define M_CONF		0x0400  /* packet was encrypted (ESP-transport) */
#define M_AUTH		0x0800  /* packet was authenticated (AH) */
#define M_COMP		0x1000  /* packet was compressed (IPCOMP) */
@


1.61
log
@compatiblity -> compatibility
decriptor -> descriptor
authentciated -> authenticated
transmition -> transmission
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.60 2002/03/15 01:20:04 millert Exp $	*/
d597 1
@


1.60
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.59 2002/03/14 03:16:12 millert Exp $	*/
d511 1
a511 1
/* compatiblity with 4.3 */
@


1.59
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.58 2002/03/14 01:27:14 millert Exp $	*/
d93 2
a94 1
	void	(*ext_free)		/* free routine if not the usual */(caddr_t, u_int, void *);
@


1.58
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.57 2002/02/17 22:59:53 maja Exp $	*/
d563 2
a564 2
struct mbuf *m_devget __P((char *, int, int, struct ifnet *,
	    void (*)(const void *, void *, size_t)));
d566 2
a567 2
int	m_apply __P((struct mbuf *, int, int,
	    int (*)(caddr_t, caddr_t, unsigned int), caddr_t));
@


1.57
log
@Patch from Daniel Lucq <daniel@@lucq.org>

The patch allows you to change the value of NMBCLUSTERS, BUFCACHEPERCENT
and NKMEMPAGES using the config command, instead of recompiling the kernel.

This is the kernel part of the patch. I have compiled it on i386, sparc64,
alpha and macppc. -moj ok art@@ maja@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.56 2002/01/25 15:50:23 art Exp $	*/
d93 1
a93 2
	void	(*ext_free)		/* free routine if not the usual */
		    __P((caddr_t, u_int, void *));
d542 21
a562 21
void	mbinit __P((void));
struct	mbuf *m_copym2 __P((struct mbuf *, int, int, int));
struct	mbuf *m_copym __P((struct mbuf *, int, int, int));
struct	mbuf *m_free __P((struct mbuf *));
struct	mbuf *m_get __P((int, int));
struct	mbuf *m_getclr __P((int, int));
struct	mbuf *m_gethdr __P((int, int));
struct	mbuf *m_prepend __P((struct mbuf *, int, int));
struct	mbuf *m_pulldown __P((struct mbuf *, int, int, int *));
struct	mbuf *m_pullup __P((struct mbuf *, int));
struct	mbuf *m_pullup2 __P((struct mbuf *, int));
struct	mbuf *m_split __P((struct mbuf *, int, int));
struct  mbuf *m_inject __P((struct mbuf *, int, int, int));
struct  mbuf *m_getptr __P((struct mbuf *, int, int *));
void	m_adj __P((struct mbuf *, int));
int	m_clalloc __P((int, int));
void	m_copyback __P((struct mbuf *, int, int, caddr_t));
void	m_freem __P((struct mbuf *));
void	m_reclaim __P((void *, int));
void	m_copydata __P((struct mbuf *, int, int, caddr_t));
void	m_cat __P((struct mbuf *, struct mbuf *));
d564 2
a565 2
	    void (*) __P((const void *, void *, size_t))));
void	m_zero __P((struct mbuf *));
d570 12
a581 12
struct m_tag *m_tag_get __P((int, int, int));
void	m_tag_free __P((struct m_tag *));
void	m_tag_prepend __P((struct mbuf *, struct m_tag *));
void	m_tag_unlink __P((struct mbuf *, struct m_tag *));
void	m_tag_delete __P((struct mbuf *, struct m_tag *));
void	m_tag_delete_chain __P((struct mbuf *, struct m_tag *));
struct m_tag *m_tag_find __P((struct mbuf *, int, struct m_tag *));
struct m_tag *m_tag_copy __P((struct m_tag *));
int	m_tag_copy_chain __P((struct mbuf *, struct mbuf *));
void	m_tag_init __P((struct mbuf *));
struct m_tag *m_tag_first __P((struct mbuf *));
struct m_tag *m_tag_next __P((struct mbuf *, struct m_tag *));
@


1.56
log
@Add a drain hook to each pool. This hook is called in three cases.
1. When a pool hit the hard limit. Just before bailing out/sleeping.
2. When an allocator fails to allocate memory (with PR_NOWAIT).
3. Just before trying to reclaim some page in pool_reclaim.

The function called form the hook should try to free some items to the
pool if possible.

Convert m_reclaim hooks that were embedded in MCLGET, MGET and MGETHDR
into a pool drain hook (making the code much cleaner).
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.55 2002/01/02 06:17:26 nordin Exp $	*/
d532 1
a532 1
extern	int nmbclusters;		/* limit on the # of clusters */
@


1.55
log
@Remove duplicate definition. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.54 2001/09/12 00:23:33 art Exp $	*/
d204 4
a207 1
	MBUFLOCK((m) = pool_get(&mbpool, (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0);); \
d215 1
a215 2
	} else \
		(m) = m_retry((how), (type)); \
d226 4
a229 1
	MBUFLOCK((m) = pool_get(&mbpool, (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0);); \
d239 1
a239 2
	} else \
		(m) = m_retryhdr((how), (type)); \
d307 1
a307 2
		(m)->m_ext.ext_buf = \
		    pool_get(&mclpool, (how) == M_WAIT ? \
a308 6
		if ((m)->m_ext.ext_buf == NULL) { \
			m_reclaim(); \
			(m)->m_ext.ext_buf = \
			    pool_get(&mclpool, \
			    (how) == M_WAIT ? PR_WAITOK : 0); \
		} \
a539 2
extern	int needqueuedrain;		/* True if allocation failed at */
					/* interrupt level */
a553 2
struct	mbuf *m_retry __P((int, int));
struct	mbuf *m_retryhdr __P((int, int));
d561 1
a561 1
void	m_reclaim __P((void));
@


1.54
log
@mbutl no more
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.53 2001/08/24 14:31:58 angelos Exp $	*/
a575 1
void	mbinit __P((void));
@


1.54.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.56 2002/01/25 15:50:23 art Exp $	*/
d204 1
a204 4
	MBUFLOCK( \
	    	(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d212 2
a213 1
	} \
d224 1
a224 4
	MBUFLOCK( \
		(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d234 2
a235 1
	} \
d303 2
a304 1
		(m)->m_ext.ext_buf = pool_get(&mclpool, (how) == M_WAIT ? \
d306 6
d543 2
d559 2
d568 1
a568 1
void	m_reclaim __P((void *, int));
d576 1
@


1.54.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.54.4.1 2002/01/31 22:55:48 niklas Exp $	*/
d93 2
a94 2
					/* free routine if not the usual */
	void	(*ext_free)(caddr_t, u_int, void *);
d143 3
a145 4
#define M_CONF		0x0400  /* payload was encrypted (ESP-transport) */
#define M_AUTH		0x0800  /* payload was authenticated (AH or ESP auth) */
#define M_COMP		0x1000  /* payload was compressed (IPCOMP) */
#define M_AUTH_AH	0x2000  /* header was authenticated (AH) */
d149 1
a149 1
#define M_TCPV4_CSUM_OUT	0x0002	/* TCP checksum needed */
d511 1
a511 1
/* compatibility with 4.3 */
d532 1
a532 1
extern	int nmbclust;			/* limit on the # of clusters */
d543 26
a568 26
void	mbinit(void);
struct	mbuf *m_copym2(struct mbuf *, int, int, int);
struct	mbuf *m_copym(struct mbuf *, int, int, int);
struct	mbuf *m_free(struct mbuf *);
struct	mbuf *m_get(int, int);
struct	mbuf *m_getclr(int, int);
struct	mbuf *m_gethdr(int, int);
struct	mbuf *m_prepend(struct mbuf *, int, int);
struct	mbuf *m_pulldown(struct mbuf *, int, int, int *);
struct	mbuf *m_pullup(struct mbuf *, int);
struct	mbuf *m_pullup2(struct mbuf *, int);
struct	mbuf *m_split(struct mbuf *, int, int);
struct  mbuf *m_inject(struct mbuf *, int, int, int);
struct  mbuf *m_getptr(struct mbuf *, int, int *);
void	m_adj(struct mbuf *, int);
int	m_clalloc(int, int);
void	m_copyback(struct mbuf *, int, int, caddr_t);
void	m_freem(struct mbuf *);
void	m_reclaim(void *, int);
void	m_copydata(struct mbuf *, int, int, caddr_t);
void	m_cat(struct mbuf *, struct mbuf *);
struct mbuf *m_devget(char *, int, int, struct ifnet *,
	    void (*)(const void *, void *, size_t));
void	m_zero(struct mbuf *);
int	m_apply(struct mbuf *, int, int,
	    int (*)(caddr_t, caddr_t, unsigned int), caddr_t);
d571 12
a582 12
struct m_tag *m_tag_get(int, int, int);
void	m_tag_free(struct m_tag *);
void	m_tag_prepend(struct mbuf *, struct m_tag *);
void	m_tag_unlink(struct mbuf *, struct m_tag *);
void	m_tag_delete(struct mbuf *, struct m_tag *);
void	m_tag_delete_chain(struct mbuf *, struct m_tag *);
struct m_tag *m_tag_find(struct mbuf *, int, struct m_tag *);
struct m_tag *m_tag_copy(struct m_tag *);
int	m_tag_copy_chain(struct mbuf *, struct mbuf *);
void	m_tag_init(struct mbuf *);
struct m_tag *m_tag_first(struct mbuf *);
struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);
a596 1
#define PACKET_TAG_PF_ROUTED			12 /* PF routed, no route loops */
@


1.54.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.54.4.2 2002/06/11 03:32:33 art Exp $	*/
d39 1
a39 1
#ifndef _SYS_MALLOC_H_
d536 4
a539 4
extern	int max_linkhdr;		/* largest link-level header */
extern	int max_protohdr;		/* largest protocol header */
extern	int max_hdr;			/* largest link+protocol header */
extern	int max_datalen;		/* MHLEN - max_hdr */
a598 2
#define PACKET_TAG_PF_FRAGCACHE			13 /* PF fragment cached */
#define	PACKET_TAG_PF_QID			14 /* PF queue id */
@


1.54.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d532 1
a532 1
extern	struct mbstat mbstat;
a600 1
#define PACKET_TAG_PF_TAG			15 /* PF tags */
@


1.53
log
@From NetBSD:

Add an M_READONLY() macro, which evaluates to true if the mbuf's
data area is not to be written to.  This is the case for mbufs with
external storage which is either a non-cluster or a cluster referenced
by multiple mbufs.

Change M_LEADINGSPACE() and M_TRAILINGSPACE() to use M_READONLY(),
rather than their own testing for M_EXT.  Previously, M_LEADINGSPACE()
treated all M_EXT mbufs as read-only (which causes an extra mbuf to
be needlessly allocated when sending large TCP packets), and
M_TRAILINGSPACE() previously did not treat any external storage as
read-only (could lead to data corruption of external storage buffers!).
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.52 2001/07/05 08:45:14 angelos Exp $	*/
a533 1
extern	struct mbuf *mbutl;		/* virtual address of mclusters */
@


1.52
log
@Remove dead ifdefs, M_COMP should be copied.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.51 2001/07/05 08:33:11 jjbg Exp $	*/
d457 9
d469 7
a475 4
#define	M_LEADINGSPACE(m) \
	((m)->m_flags & M_EXT ? /* (m)->m_data - (m)->m_ext.ext_buf */ 0 : \
	    (m)->m_flags & M_PKTHDR ? (m)->m_data - (m)->m_pktdat : \
	    (m)->m_data - (m)->m_dat)
d481 1
a481 1
#define	M_TRAILINGSPACE(m) \
d485 3
@


1.51
log
@For IPComp. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.50 2001/07/02 01:34:47 deraadt Exp $	*/
a160 5
#if 0 /*KAME IPSEC*/
#define M_AUTHIPHDR	0x0010	/* data origin authentication for IP header */
#define M_DECRYPTED	0x0020	/* confidentiality */
#endif

a162 4
#if 0 /*KAME IPSEC*/
#define M_AUTHIPDGM	0x0080  /* data origin authentication */
#endif

d164 1
a164 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_ANYCAST6|M_LOOP)
@


1.50
log
@grr, indent
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.49 2001/07/01 23:04:44 dhartmei Exp $	*/
d145 1
@


1.49
log
@tag packets generated by pf (return-rst, return-icmp) so they are not filtered, use existing icmp_error() and ip_output(). ok dugsong@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.48 2001/06/27 03:49:55 angelos Exp $	*/
d587 3
a589 3
#define	PACKET_TAG_NONE				0  /* Nadda */
#define	PACKET_TAG_IPSEC_IN_DONE		1  /* IPsec applied, in */
#define	PACKET_TAG_IPSEC_OUT_DONE		2  /* IPsec applied, out */
d593 1
a593 1
#define	PACKET_TAG_IPSEC_PENDING_TDB		6  /* Reminder to do IPsec */
d597 1
a597 1
#define	PACKET_TAG_IN_PACKET_CHECKSUM		10 /* NIC checksumming done */
@


1.48
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.47 2001/06/25 05:40:20 angelos Exp $	*/
d598 1
@


1.47
log
@Rename checksum tag.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.46 2001/06/25 04:01:28 angelos Exp $	*/
d413 1
a413 1
 * Copy just m_pkthdr from from to to,
d416 1
a416 1
#define M_COPY_HDR(to, from) { \
d442 1
a442 1
 * Copy mbuf pkthdr from from to to.
d445 1
a445 1
#define	M_COPY_PKTHDR(to, from) { \
d447 1
a447 1
	M_COPY_HDR((to), (from)); \
d459 1
a459 1
 * or initialized by M_COPY_PKTHDR.
@


1.46
log
@Add PACKET_TAG_IPSEC_PENDING_TDB and PACKET_TAG_PACKET_CHECKSUM, as
well as add comments on all tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.45 2001/06/25 02:57:46 angelos Exp $	*/
d597 1
a597 1
#define	PACKET_TAG_PACKET_CHECKSUM		10 /* NIC checksumming done */
@


1.45
log
@Copy the m_flags, *then* clear M_PKTHDR on from...bad Federico.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.44 2001/06/25 02:35:11 angelos Exp $	*/
d587 11
a597 9
#define	PACKET_TAG_NONE				0
#define	PACKET_TAG_IPSEC_IN_DONE		1
#define	PACKET_TAG_IPSEC_OUT_DONE		2
#define PACKET_TAG_IPSEC_IN_CRYPTO_DONE		3
#define PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED	4
#define PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO	5
#define PACKET_TAG_BRIDGE			6
#define PACKET_TAG_GIF				7
#define PACKET_TAG_GRE				8
@


1.44
log
@Bad Federico!
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.43 2001/06/25 01:50:18 fgsch Exp $	*/
d446 1
a447 1
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS; \
@


1.43
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.42 2001/06/23 04:39:35 angelos Exp $	*/
d419 1
a419 1
	m_tag_init((from)); \
d426 1
a426 1
	M_COPY_HDR((to), (from)); \
@


1.42
log
@Having to update queue(3) for DLIST_* is a major PITA; thus, just use
SLIST and be done with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.41 2001/06/23 03:57:25 angelos Exp $	*/
d413 2
a414 1
 * Copy just m_pkthdr from from to to.
d418 2
@


1.41
log
@Use DLIST for tags
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.40 2001/06/23 02:23:01 angelos Exp $	*/
d61 1
a61 1
	DLIST_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
d85 1
a85 1
	DLIST_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
d240 1
a240 1
		DLIST_INIT(&(m)->m_pkthdr.tags); \
d424 1
a424 1
	DLIST_INIT(&(to)->m_pkthdr.tags); \
@


1.40
log
@Drop the "v4" for TCP/UDP checksums.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.39 2001/06/23 02:01:08 angelos Exp $	*/
d61 1
a61 1
	LIST_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
d85 1
a85 1
	LIST_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
d240 1
a240 1
		LIST_INIT(&(m)->m_pkthdr.tags); \
a413 1
 * XXX Ugly exposure of tag specifics, and it actually breaks tag copying.
a416 3
	if (!LIST_EMPTY(&(to)->m_pkthdr.tags)) \
		LIST_FIRST(&(to)->m_pkthdr.tags)->m_tag_link.le_prev = \
		    &(to)->m_pkthdr.tags.lh_first; \
d424 1
a424 1
	LIST_INIT(&(to)->m_pkthdr.tags); \
@


1.39
log
@Add csum field for hardware checksumming. Based on NetBSD's approach.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.38 2001/06/22 14:11:00 deraadt Exp $	*/
d152 4
a155 4
#define	M_TCPV4_CSUM_IN_OK	0x0020	/* TCP/IPv4 checksum verified */
#define	M_TCPV4_CSUM_IN_BAD	0x0040	/* TCP/IPv4 checksum bad */
#define	M_UDPV4_CSUM_IN_OK	0x0080	/* UDP/IPv4 checksum verified */
#define	M_UDPV4_CSUM_IN_BAD	0x0100	/* UDP/IPv4 checksum bad */
@


1.38
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.37 2001/05/31 23:35:56 angelos Exp $	*/
d87 1
d146 11
d241 1
@


1.37
log
@Add another tag for IPsec signalling.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.36 2001/05/27 04:15:51 angelos Exp $	*/
d156 1
a156 1
#define M_AUTHIPDGM     0x0080  /* data origin authentication */
d300 1
a300 1
			(PR_WAITOK|PR_LIMITFAIL) : 0); \
d305 1
a305 1
			     (how) == M_WAIT ? PR_WAITOK : 0); \
d554 1
a554 1
			   void (*) __P((const void *, void *, size_t))));
d557 1
a557 1
			int (*)(caddr_t, caddr_t, unsigned int), caddr_t));
@


1.36
log
@ipsp_copy_ident() prototype unneeded now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.35 2001/05/27 00:38:07 angelos Exp $	*/
d580 4
a583 3
#define PACKET_TAG_BRIDGE			5
#define PACKET_TAG_GIF				6
#define PACKET_TAG_GRE				7
@


1.35
log
@Split IPsec-related tags into 4 (instead of 2) names, for
clarity. Also add m_tag_first() and m_tag_next().
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.34 2001/05/26 06:58:30 angelos Exp $	*/
a43 2

extern void *ipsp_copy_ident(void *);
@


1.34
log
@Use LIST instead of TAILQ (actually, we need a new type --- for now,
this'll do), add m_tag_init() prototype, fix COPY_HDR
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.33 2001/05/25 22:09:44 angelos Exp $	*/
d573 2
d577 8
a584 6
#define	PACKET_TAG_NONE			0
#define	PACKET_TAG_IPSEC_DONE		1
#define	PACKET_TAG_IPSEC_NEEDED		2
#define PACKET_TAG_BRIDGE		3
#define PACKET_TAG_GIF			4
#define PACKET_TAG_GRE			5
@


1.33
log
@Initialize tag when duplicating header.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.32 2001/05/24 18:53:46 angelos Exp $	*/
d63 1
a63 1
	TAILQ_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
d87 1
a87 1
	TAILQ_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
d230 1
a230 1
		TAILQ_INIT(&(m)->m_pkthdr.tags); \
d403 1
d407 3
a409 2
	if (TAILQ_EMPTY(&(from)->m_pkthdr.tags)) \
		TAILQ_INIT(&(to)->m_pkthdr.tags); \
d417 1
a417 1
	TAILQ_INIT(&(to)->m_pkthdr.tags); \
a565 1
void	m_tag_append __P((struct mbuf *, struct m_tag *));
d572 1
@


1.32
log
@Move duplication of header (and tags) after assigning the flags, so
diagnostic code won't complain about mbuf with no M_PKTHDR flag set
being treated as a packet header.

Also, remove bogus re-initialization of tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.31 2001/05/24 11:00:08 angelos Exp $	*/
d415 1
@


1.31
log
@If the copied tag head is empty, initialize it properly. This (along
with the kern/uipc_mbuf.c commit) should solve the NFS crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.30 2001/05/21 05:53:38 angelos Exp $	*/
a415 1
	TAILQ_INIT(&(from)->m_pkthdr.tags); \
d423 1
a424 1
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS; \
@


1.30
log
@Remove csum-related tags (we'll use mbuf flags instead), add some new ones.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.29 2001/05/21 03:26:26 angelos Exp $	*/
d406 2
a414 1
	TAILQ_INIT(&(to)->m_pkthdr.tags); \
d416 1
@


1.29
log
@Use int16_t for tag ID and tag length.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.28 2001/05/21 03:10:54 angelos Exp $	*/
d574 3
a576 4
#define	PACKET_TAG_IPV4_CSUM_DONE	3
#define	PACKET_TAG_IPV4_CSUM_NEEDED	4
#define	PACKET_TAG_TCP_CSUM_DONE	5
#define	PACKET_TAG_TCP_CSUM_NEEDED	6
@


1.28
log
@Avoid structure auto-padding (from Theo)
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.27 2001/05/20 08:31:12 angelos Exp $	*/
d64 2
a65 2
	int			m_tag_id;	/* Tag ID */
	int			m_tag_len;	/* Length of data */
@


1.27
log
@Packet tags (similar to NetBSD m_pkthdr.aux structure) -- ok deraadt@@ niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.26 2001/05/19 20:55:32 provos Exp $	*/
d87 1
a88 1
	TAILQ_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
@


1.26
log
@make it compile for DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.25 2001/05/17 18:41:44 provos Exp $	*/
d43 1
d61 7
d88 1
a88 1
	void	*tdbi;			/* pointer to struct tdb_ident */
d230 1
a230 1
 		(m)->m_pkthdr.tdbi = NULL; \
d392 2
a393 4
		if (((m)->m_flags & M_PKTHDR) && ((m)->m_pkthdr.tdbi)) { \
			free((m)->m_pkthdr.tdbi, M_TEMP); \
			(m)->m_pkthdr.tdbi = NULL; \
		} \
a407 1
#ifdef IPSEC
a409 2
 * XXX Deal with a generic packet attribute framework.
 * XXX When that happens, we only need one version of the macro.
d413 2
a414 7
	if ((from)->m_pkthdr.tdbi) { \
		(to)->m_pkthdr.tdbi = ipsp_copy_ident((from)->m_pkthdr.tdbi); \
	} \
}
#else /* IPSEC */
#define M_DUP_HDR(to, from) { \
	M_COPY_HDR((to), (from)); \
a415 1
#endif /* IPSEC */
d557 21
@


1.25
log
@convert mbuf and cluster allocation to pool, mostly from NetBSD
okay art@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.24 2001/05/16 08:59:04 art Exp $	*/
d93 6
@


1.24
log
@Introduce a new kernel option "SMALL_KERNEL" that will be used to keep the
kernel size down.

Two changes. Uninline MALLOC and uninline a few mbuf macros. Saves 140k
on alpha RAMDISK (although only 11k after gzip).
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.23 2001/05/15 22:02:07 deraadt Exp $	*/
d42 1
a62 3
 * dtom(x) -	convert data pointer within mbuf to mbuf pointer (XXX)
 * mtocl(x) -	convert pointer within cluster to cluster index #
 * cltom(x) -	convert cluster # to ptr to beginning of cluster
a64 3
#define	dtom(x)		((struct mbuf *)((long)(x) & ~(MSIZE-1)))
#define	mtocl(x)	(((u_long)(x) - (u_long)mbutl) >> MCLSHIFT)
#define	cltom(x)	((caddr_t)((u_long)mbutl + ((u_long)(x) << MCLSHIFT)))
d87 2
a88 1
		    __P((struct mbuf *));
d90 3
a92 3
	void	(*ext_ref)		/* add a reference to the ext object */
		    __P((struct mbuf *));
	void	*ext_handle;		/* handle for storage manager */
d124 2
a125 1
#define	M_PROTO1	0x0008	/* protocol-specific */
d154 5
a158 12
#define	MT_SOCKET	3	/* socket structure */
#define	MT_PCB		4	/* protocol control block */
#define	MT_RTABLE	5	/* routing tables */
#define	MT_HTABLE	6	/* IMP host tables */
#define	MT_ATABLE	7	/* address resolution tables */
#define	MT_SONAME	8	/* socket name */
#define	MT_SOOPTS	10	/* socket options */
#define	MT_FTABLE	11	/* fragment reassembly header */
#define	MT_RIGHTS	12	/* access rights */
#define	MT_IFADDR	13	/* interface address */
#define	MT_CONTROL	14	/* extra-data protocol message */
#define	MT_OOBDATA	15	/* expedited data  */
d187 2
a188 2
#define	_MGET(m, how, type) { \
	MALLOC((m), struct mbuf *, MSIZE, mbtypes[type], (how)); \
d198 1
a198 1
}
d207 2
a208 2
#define	_MGETHDR(m, how, type) { \
	MALLOC((m), struct mbuf *, MSIZE, mbtypes[type], (how)); \
d219 1
a219 1
}
d229 47
a275 3
 * Mbuf cluster macros.
 * MCLALLOC(caddr_t p, int how) allocates an mbuf cluster.
 * MCLGET adds such clusters to a normal mbuf;
a276 2
 * MCLFREE releases a reference to a cluster allocated by MCLALLOC,
 * freeing the cluster if the reference count has reached 0.
d278 7
a284 10
 * Normal mbuf clusters are normally treated as character arrays
 * after allocation, but use the first word of the buffer as a free list
 * pointer while on the free list.
 */
union mcluster {
	union	mcluster *mcl_next;
	char	mcl_buf[MCLBYTES];
};

#define	MCLALLOC(p, how) \
d286 19
a304 8
	  if (mclfree == 0) \
		(void)m_clalloc(1, (how)); \
	  if (((p) = (caddr_t)mclfree) != 0) { \
		++mclrefcnt[mtocl(p)]; \
		mbstat.m_clfree--; \
		mclfree = ((union mcluster *)(p))->mcl_next; \
	  } \
	)
d306 4
a309 3
#define	_MCLGET(m, how) \
	{ MCLALLOC((m)->m_ext.ext_buf, (how)); \
	  if ((m)->m_ext.ext_buf != NULL) { \
d312 2
a313 1
		(m)->m_ext.ext_size = MCLBYTES;  \
d315 47
a361 4
		(m)->m_ext.ext_ref = NULL; \
		(m)->m_ext.ext_handle = NULL; \
	  } \
	}
a369 15
#define	MCLFREE(p) \
	MBUFLOCK ( \
	  if (--mclrefcnt[mtocl(p)] == 0) { \
		((union mcluster *)(p))->mcl_next = mclfree; \
		mclfree = (union mcluster *)(p); \
		mbstat.m_clfree++; \
	  } \
	)

/*
 * For cluster mbufs (regardless of header or not).
 */
#define MCL_ALIGN(m, len) \
	{ (m)->m_data += (MCLBYTES - (len)) &~ (sizeof(long) -1); }

d376 12
a387 14
	{ MBUFLOCK(mbstat.m_mtypes[(m)->m_type]--;) \
	  if ((m)->m_flags & M_EXT) { \
		if ((m)->m_ext.ext_free) \
			(*((m)->m_ext.ext_free))(m); \
		else \
			MCLFREE((m)->m_ext.ext_buf); \
	  } \
	  if (((m)->m_flags & M_PKTHDR) && ((m)->m_pkthdr.tdbi)) { \
		free((m)->m_pkthdr.tdbi, M_TEMP); \
		(m)->m_pkthdr.tdbi = NULL; \
	  } \
	  (n) = (m)->m_next; \
	  FREE((m), mbtypes[(m)->m_type]); \
	}
d495 2
d499 4
a502 4
	u_long	m_mbufs;	/* mbufs obtained from page pool */
	u_long	m_clusters;	/* clusters obtained from page pool */
	u_long	m_spare;	/* spare field */
	u_long	m_clfree;	/* free clusters */
a510 1
extern	char *mclrefcnt;		/* cluster reference counts */
d512 3
a514 2
extern	int nmbclusters;
union	mcluster *mclfree;
d522 2
d553 1
a559 5
	M_SOCKET,	/* MT_SOCKET	3	   socket structure */
	M_PCB,		/* MT_PCB	4	   protocol control block */
	M_RTABLE,	/* MT_RTABLE	5	   routing tables */
	M_HTABLE,	/* MT_HTABLE	6	   IMP host tables */
	0,		/* MT_ATABLE	7	   address resolution tables */
a560 1
	0,		/* 		9 */
a562 2
	M_MBUF,		/* MT_RIGHTS	12	   access rights */
	M_IFADDR,	/* MT_IFADDR	13	   interface address */
a564 3
#ifdef DATAKIT
	25, 26, 27, 28, 29, 30, 31, 32		/* datakit ugliness */
#endif
d566 1
a566 1
#endif
@


1.23
log
@remove NRL pieces no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.22 2001/03/31 23:03:37 angelos Exp $	*/
d197 1
a197 1
#define	MGET(m, how, type) { \
d210 8
a217 1
#define	MGETHDR(m, how, type) { \
d231 7
d266 1
a266 1
#define	MCLGET(m, how) \
d277 7
@


1.22
log
@Style, and let the kernel compile without option IPSEC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.21 2001/03/28 20:03:09 angelos Exp $	*/
a134 6

#if 0 /* NRL IPv6 */
#define M_TUNNEL       	0x1000  /* packet was tunneled */
#define M_DAD		0x2000	/* Used on outbound packets to indicate that
				 * this is for duplicate address detection */
#endif
@


1.21
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.20 2001/03/18 18:51:10 aaron Exp $	*/
d298 4
a301 4
          if (((m)->m_flags & M_PKTHDR) && ((m)->m_pkthdr.tdbi)) { \
                free((m)->m_pkthdr.tdbi, M_TEMP); \
                (m)->m_pkthdr.tdbi = NULL; \
          } \
d313 1
d317 1
d320 3
a322 3
        M_COPY_HDR((to), (from)); \
        if ((from)->m_pkthdr.tdbi) { \
                (to)->m_pkthdr.tdbi = ipsp_copy_ident((from)->m_pkthdr.tdbi); \
d325 5
d336 1
a336 1
        M_DUP_HDR((to), (from)); \
d346 1
a346 1
        M_COPY_HDR((to), (from)); \
@


1.20
log
@bad angelos
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.19 2001/03/18 17:15:35 angelos Exp $	*/
d43 2
d298 4
d307 28
d339 1
a339 1
	(to)->m_pkthdr = (from)->m_pkthdr; \
@


1.19
log
@Pretty.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.18 2000/09/26 17:50:26 angelos Exp $	*/
d137 1
@


1.18
log
@Set the tdbi field in the pkthdr to NULL in MGETHDR -- avoids some
panics in Alphas (probably others too).
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.17 2000/06/12 17:24:26 itojun Exp $	*/
a83 1
					/* XXX - pull in ip_ipsp.h */ 
d133 1
a136 1
				 * this is for duplicate address detection */
d141 1
d146 1
d148 1
@


1.17
log
@update icmp6 name lookup code to conform to 05 draft.  previous code
was 03/05 chimera.

ping6: -n by default due to too many false error report due to too long
reverse query delay.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.16 2000/04/26 18:40:50 chris Exp $	*/
d220 1
@


1.16
log
@Add mbuf flag
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.15 2000/03/02 21:39:19 angelos Exp $	*/
d401 1
@


1.15
log
@Add prototype for m_getptr()
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.14 1999/12/08 06:50:24 itojun Exp $	*/
d127 1
d152 1
a152 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_ANYCAST6|M_LOOP)
@


1.14
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.13 1999/12/05 07:30:31 angelos Exp $	*/
d406 1
@


1.14.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a405 1
struct  mbuf *m_getptr __P((struct mbuf *, int, int *));
@


1.14.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.22 2001/03/31 23:03:37 angelos Exp $	*/
a42 2
extern void *ipsp_copy_ident(void *);

d84 1
a126 1
#define	M_PROTO1	0x0008	/* protocol-specific */
a132 1

a140 1

a144 1

a145 1

d151 1
a151 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_ANYCAST6|M_LOOP)
a218 1
 		(m)->m_pkthdr.tdbi = NULL; \
a290 4
	  if (((m)->m_flags & M_PKTHDR) && ((m)->m_pkthdr.tdbi)) { \
		free((m)->m_pkthdr.tdbi, M_TEMP); \
		(m)->m_pkthdr.tdbi = NULL; \
	  } \
a295 35
 * Copy just m_pkthdr from from to to.
 */
#define M_COPY_HDR(to, from) { \
	(to)->m_pkthdr = (from)->m_pkthdr; \
}

#ifdef IPSEC
/*
 * Duplicate just m_pkthdr from from to to.
 * XXX Deal with a generic packet attribute framework.
 * XXX When that happens, we only need one version of the macro.
 */
#define M_DUP_HDR(to, from) { \
	M_COPY_HDR((to), (from)); \
	if ((from)->m_pkthdr.tdbi) { \
		(to)->m_pkthdr.tdbi = ipsp_copy_ident((from)->m_pkthdr.tdbi); \
	} \
}
#else /* IPSEC */
#define M_DUP_HDR(to, from) { \
	M_COPY_HDR((to), (from)); \
}
#endif /* IPSEC */

/*
 * Duplicate mbuf pkthdr from from to to.
 * from must have M_PKTHDR set, and to must be empty.
 */
#define M_DUP_PKTHDR(to, from) { \
	M_DUP_HDR((to), (from)); \
	(to)->m_flags = (from)->m_flags & M_COPYFLAGS; \
	(to)->m_data = (to)->m_pktdat; \
}

/*
d300 1
a300 1
	M_COPY_HDR((to), (from)); \
a399 1
struct	mbuf *m_pulldown __P((struct mbuf *, int, int, int *));
@


1.14.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.14.2.2 2001/05/14 22:45:02 niklas Exp $	*/
d42 2
a43 2
#include <sys/pool.h>
#include <sys/queue.h>
a58 7
/* Packet tags structure */
struct m_tag {
	SLIST_ENTRY(m_tag)	m_tag_link;	/* List of packet tags */
	u_int16_t		m_tag_id;	/* Tag ID */
	u_int16_t		m_tag_len;	/* Length of data */
};

d62 3
d67 3
a83 1
	SLIST_HEAD(packet_tags, m_tag) tags; /* list of packet tags */
d85 1
a85 1
	int	csum;			/* Hardware checksum info */
d92 1
a92 2
		    __P((caddr_t, u_int, void *));
	void	*ext_arg;		/* argument for ext_free */
d94 3
a96 9
	int	ext_type;
	struct mbuf *ext_nextref;
	struct mbuf *ext_prevref;
#ifdef DEBUG
	const char *ext_ofile;
	const char *ext_nfile;
	int ext_oline;
	int ext_nline;
#endif
d128 1
a128 2
#define M_CLUSTER	0x0008	/* external storage is a cluster */
#define	M_PROTO1	0x0010	/* protocol-specific */
d136 5
a140 10
/* Checksumming flags */
#define	M_IPV4_CSUM_OUT		0x0001	/* IPv4 checksum needed */
#define M_TCPV4_CSUM_OUT	0x2002	/* TCP checksum needed */
#define	M_UDPV4_CSUM_OUT	0x0004	/* UDP checksum needed */
#define	M_IPV4_CSUM_IN_OK	0x0008	/* IPv4 checksum verified */
#define	M_IPV4_CSUM_IN_BAD	0x0010	/* IPv4 checksum bad */
#define	M_TCP_CSUM_IN_OK	0x0020	/* TCP/IPv4 checksum verified */
#define	M_TCP_CSUM_IN_BAD	0x0040	/* TCP/IPv4 checksum bad */
#define	M_UDP_CSUM_IN_OK	0x0080	/* UDP/IPv4 checksum verified */
#define	M_UDP_CSUM_IN_BAD	0x0100	/* UDP/IPv4 checksum bad */
d153 1
a153 1
#define M_AUTHIPDGM	0x0080  /* data origin authentication */
d163 12
a174 5
#define	MT_SONAME	3	/* socket name */
#define	MT_SOOPTS	4	/* socket options */
#define	MT_FTABLE	5	/* fragment reassembly header */
#define	MT_CONTROL	6	/* extra-data protocol message */
#define	MT_OOBDATA	7	/* expedited data  */
d203 2
a204 2
#define	_MGET(m, how, type) do { \
	MBUFLOCK((m) = pool_get(&mbpool, (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0);); \
d214 1
a214 1
} while(/* CONSTCOND */ 0)
d216 2
a217 9
#ifdef SMALL_KERNEL
struct mbuf *_sk_mget(int, int);
#define MGET(m, how, type) { m = _sk_mget(how, type); }
#else
#define MGET(m, how, type) _MGET(m, how, type)
#endif

#define	_MGETHDR(m, how, type) do { \
	MBUFLOCK((m) = pool_get(&mbpool, (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0);); \
d225 1
a225 2
		SLIST_INIT(&(m)->m_pkthdr.tags); \
		(m)->m_pkthdr.csum = 0; \
d228 1
a228 8
} while (/* CONSTCOND */ 0)

#ifdef SMALL_KERNEL
struct mbuf *_sk_mgethdr(int, int);
#define MGETHDR(m, how, type) { m = _sk_mgethdr(how, type); }
#else
#define MGETHDR(m, how, type) _MGETHDR(m, how, type)
#endif
d231 6
a236 1
 * Macros for tracking external storage associated with an mbuf.
d238 8
a245 38
 * Note: add and delete reference must be called at splvm().
 */
#ifdef DEBUG
#define MCLREFDEBUGN(m, file, line) do {				\
		(m)->m_ext.ext_nfile = (file);				\
		(m)->m_ext.ext_nline = (line);				\
	} while (/* CONSTCOND */ 0)
#define MCLREFDEBUGO(m, file, line) do {				\
		(m)->m_ext.ext_ofile = (file);				\
		(m)->m_ext.ext_oline = (line);				\
	} while (/* CONSTCOND */ 0)
#else
#define MCLREFDEBUGN(m, file, line)
#define MCLREFDEBUGO(m, file, line)
#endif

#define	MCLBUFREF(p)
#define	MCLISREFERENCED(m)	((m)->m_ext.ext_nextref != (m))
#define	_MCLDEREFERENCE(m)	do {					\
		(m)->m_ext.ext_nextref->m_ext.ext_prevref =		\
			(m)->m_ext.ext_prevref;				\
		(m)->m_ext.ext_prevref->m_ext.ext_nextref =		\
			(m)->m_ext.ext_nextref;				\
	} while (/* CONSTCOND */ 0)
#define	_MCLADDREFERENCE(o, n)	do {					\
		(n)->m_flags |= ((o)->m_flags & (M_EXT|M_CLUSTER));	\
		(n)->m_ext.ext_nextref = (o)->m_ext.ext_nextref;	\
		(n)->m_ext.ext_prevref = (o);				\
		(o)->m_ext.ext_nextref = (n);				\
		(n)->m_ext.ext_nextref->m_ext.ext_prevref = (n);	\
		MCLREFDEBUGN((n), __FILE__, __LINE__);			\
	} while (/* CONSTCOND */ 0)
#define	MCLINITREFERENCE(m)	do {					\
		(m)->m_ext.ext_prevref = (m);				\
		(m)->m_ext.ext_nextref = (m);				\
		MCLREFDEBUGO((m), __FILE__, __LINE__);			\
		MCLREFDEBUGN((m), NULL, 0);				\
	} while (/* CONSTCOND */ 0)
d247 1
a247 15
#define	MCLADDREFERENCE(o, n)	MBUFLOCK(_MCLADDREFERENCE((o), (n));)

/*
 * Macros for mbuf external storage.
 *
 * MCLGET allocates and adds an mbuf cluster to a normal mbuf;
 * the flag M_EXT is set upon success.
 *
 * MEXTMALLOC allocates external storage and adds it to
 * a normal mbuf; the flag M_EXT is set upon success.
 *
 * MEXTADD adds pre-allocated external storage to
 * a normal mbuf; the flag M_EXT is set upon success.
 */
#define	_MCLGET(m, how) do { \
d249 8
a256 19
		(m)->m_ext.ext_buf = \
		    pool_get(&mclpool, (how) == M_WAIT ? \
		    (PR_WAITOK|PR_LIMITFAIL) : 0); \
		if ((m)->m_ext.ext_buf == NULL) { \
			m_reclaim(); \
			(m)->m_ext.ext_buf = \
			    pool_get(&mclpool, \
			    (how) == M_WAIT ? PR_WAITOK : 0); \
		} \
	); \
	if ((m)->m_ext.ext_buf != NULL) { \
		(m)->m_data = (m)->m_ext.ext_buf; \
		(m)->m_flags |= M_EXT|M_CLUSTER; \
		(m)->m_ext.ext_size = MCLBYTES;  \
		(m)->m_ext.ext_free = NULL;  \
		(m)->m_ext.ext_arg = NULL;  \
		MCLINITREFERENCE(m); \
	} \
} while (/* CONSTCOND */ 0)
d258 3
a260 4
#define	MEXTMALLOC(m, size, how) do { \
	(m)->m_ext.ext_buf = \
	    (caddr_t)malloc((size), mbtypes[(m)->m_type], (how)); \
	if ((m)->m_ext.ext_buf != NULL) { \
d263 1
a263 2
		(m)->m_flags &= ~M_CLUSTER; \
		(m)->m_ext.ext_size = (size); \
d265 13
a277 5
		(m)->m_ext.ext_arg = NULL; \
		(m)->m_ext.ext_type = mbtypes[(m)->m_type]; \
		MCLINITREFERENCE(m); \
	} \
} while (/* CONSTCOND */ 0)
d279 5
a283 48
#define	MEXTADD(m, buf, size, type, free, arg) do { \
	(m)->m_data = (m)->m_ext.ext_buf = (caddr_t)(buf); \
	(m)->m_flags |= M_EXT; \
	(m)->m_flags &= ~M_CLUSTER; \
	(m)->m_ext.ext_size = (size); \
	(m)->m_ext.ext_free = (free); \
	(m)->m_ext.ext_arg = (arg); \
	(m)->m_ext.ext_type = (type); \
	MCLINITREFERENCE(m); \
} while (/* CONSTCOND */ 0)

#define	_MEXTREMOVE(m) do { \
	if (MCLISREFERENCED(m)) { \
		_MCLDEREFERENCE(m); \
	} else if ((m)->m_flags & M_CLUSTER) { \
		pool_put(&mclpool, (m)->m_ext.ext_buf); \
	} else if ((m)->m_ext.ext_free) { \
		(*((m)->m_ext.ext_free))((m)->m_ext.ext_buf, \
		    (m)->m_ext.ext_size, (m)->m_ext.ext_arg); \
	} else { \
		free((m)->m_ext.ext_buf,(m)->m_ext.ext_type); \
	} \
	(m)->m_flags &= ~(M_CLUSTER|M_EXT); \
	(m)->m_ext.ext_size = 0;	/* why ??? */ \
} while (/* CONSTCOND */ 0)

#define	MEXTREMOVE(m) \
	MBUFLOCK(_MEXTREMOVE((m));)

/*
 * Reset the data pointer on an mbuf.
 */
#define	MRESETDATA(m)							\
do {									\
	if ((m)->m_flags & M_EXT)					\
		(m)->m_data = (m)->m_ext.ext_buf;			\
	else if ((m)->m_flags & M_PKTHDR)				\
		(m)->m_data = (m)->m_pktdat;				\
	else								\
		(m)->m_data = (m)->m_dat;				\
} while (/* CONSTCOND */ 0)

#ifdef SMALL_KERNEL
void _sk_mclget(struct mbuf *, int);
#define MCLGET(m, how) _sk_mclget(m, how)
#else
#define MCLGET(m, how) _MCLGET(m, how)
#endif
d291 14
a304 10
	MBUFLOCK( \
		mbstat.m_mtypes[(m)->m_type]--; \
		if ((m)->m_flags & M_PKTHDR) \
			m_tag_delete_chain((m), NULL); \
		if ((m)->m_flags & M_EXT) { \
			_MEXTREMOVE((m)); \
		} \
		(n) = (m)->m_next; \
		pool_put(&mbpool, (m)); \
	)
d307 1
a307 2
 * Move just m_pkthdr from from to to,
 * remove M_PKTHDR and clean the tag for from.
d309 1
a309 1
#define M_MOVE_HDR(to, from) { \
a310 2
	(from)->m_flags &= ~M_PKTHDR; \
	SLIST_INIT(&(from)->m_pkthdr.tags); \
d313 1
d316 2
d320 8
a327 3
	(to)->m_pkthdr = (from)->m_pkthdr; \
	SLIST_INIT(&(to)->m_pkthdr.tags); \
	m_tag_copy_chain((to), (from)); \
d329 1
d336 1
a337 1
	M_DUP_HDR((to), (from)); \
d342 1
a342 1
 * MOVE mbuf pkthdr from from to to.
d345 2
a346 1
#define	M_MOVE_PKTHDR(to, from) { \
a347 1
	M_MOVE_HDR((to), (from)); \
d359 1
a359 1
 * or initialized by M_MOVE_PKTHDR.
a411 2
 * For statistics related to mbuf and cluster allocations, see also the
 * pool headers (mbpool and mclpool).
d414 4
a417 4
	u_long	_m_spare;	/* formerly m_mbufs */
	u_long	_m_spare1;	/* formerly m_clusters */
	u_long	_m_spare2;	/* spare field */
	u_long	_m_spare3;	/* formely m_clfree - free clusters */
d426 1
d428 2
a429 3
extern	int nmbclusters;		/* limit on the # of clusters */
extern	int mblowat;			/* mbuf low water mark */
extern	int mcllowat;			/* mbuf cluster low water mark */
a436 2
extern struct pool mbpool;
extern struct pool mclpool;
d462 1
a462 1
	    void (*) __P((const void *, void *, size_t))));
d465 1
a465 30
	    int (*)(caddr_t, caddr_t, unsigned int), caddr_t));
void	mbinit __P((void));

/* Packet tag routines */
struct m_tag *m_tag_get __P((int, int, int));
void	m_tag_free __P((struct m_tag *));
void	m_tag_prepend __P((struct mbuf *, struct m_tag *));
void	m_tag_unlink __P((struct mbuf *, struct m_tag *));
void	m_tag_delete __P((struct mbuf *, struct m_tag *));
void	m_tag_delete_chain __P((struct mbuf *, struct m_tag *));
struct m_tag *m_tag_find __P((struct mbuf *, int, struct m_tag *));
struct m_tag *m_tag_copy __P((struct m_tag *));
int	m_tag_copy_chain __P((struct mbuf *, struct mbuf *));
void	m_tag_init __P((struct mbuf *));
struct m_tag *m_tag_first __P((struct mbuf *));
struct m_tag *m_tag_next __P((struct mbuf *, struct m_tag *));

/* Packet tag types */
#define PACKET_TAG_NONE				0  /* Nadda */
#define PACKET_TAG_IPSEC_IN_DONE		1  /* IPsec applied, in */
#define PACKET_TAG_IPSEC_OUT_DONE		2  /* IPsec applied, out */
#define PACKET_TAG_IPSEC_IN_CRYPTO_DONE		3  /* NIC IPsec crypto done */
#define PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED	4  /* NIC IPsec crypto req'ed */
#define PACKET_TAG_IPSEC_IN_COULD_DO_CRYPTO	5  /* NIC notifies IPsec */
#define PACKET_TAG_IPSEC_PENDING_TDB		6  /* Reminder to do IPsec */
#define PACKET_TAG_BRIDGE			7  /* Bridge processing done */
#define PACKET_TAG_GIF				8  /* GIF processing done */
#define PACKET_TAG_GRE				9  /* GRE processing done */
#define PACKET_TAG_IN_PACKET_CHECKSUM		10 /* NIC checksumming done */
#define PACKET_TAG_PF_GENERATED			11 /* PF generated, pass always */
d472 5
d478 1
d481 2
d485 3
d489 1
a489 1
#endif /* MBTYPES */
@


1.14.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.14.2.3 2001/07/04 11:00:23 niklas Exp $	*/
a144 1
#define M_COMP		0x1000  /* packet was compressed (IPCOMP) */
d160 5
d167 4
d172 1
a172 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_COMP|M_ANYCAST6|M_LOOP)
a464 9
 * Determine if an mbuf's data area is read-only. This is true for
 * non-cluster external storage and for clusters that are being
 * referenced by more than one mbuf.
 */
#define	M_READONLY(m) \
	(((m)->m_flags & M_EXT) != 0 &&	\
	  (((m)->m_flags & M_CLUSTER) == 0 || MCLISREFERENCED(m)))

/*
d468 4
a471 7
#define	_M_LEADINGSPACE(m) \
	((m)->m_flags & M_EXT ? (m)->m_data - (m)->m_ext.ext_buf : \
	 (m)->m_flags & M_PKTHDR ? (m)->m_data - (m)->m_pktdat : \
	 (m)->m_data - (m)->m_dat)

#define	M_LEADINGSPACE(m)	\
	(M_READONLY((m)) ? 0 : _M_LEADINGSPACE((m)))
d477 1
a477 1
#define	_M_TRAILINGSPACE(m) \
a481 3
#define	M_TRAILINGSPACE(m)	\
	(M_READONLY((m)) ? 0 : _M_TRAILINGSPACE((m)))

d527 1
@


1.14.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d204 1
a204 4
	MBUFLOCK( \
	    	(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d212 2
a213 1
	} \
d224 1
a224 4
	MBUFLOCK( \
		(m) = pool_get(&mbpool, \
		    (how) == M_WAIT ? PR_WAITOK|PR_LIMITFAIL : 0); \
	); \
d234 2
a235 1
	} \
d303 2
a304 1
		(m)->m_ext.ext_buf = pool_get(&mclpool, (how) == M_WAIT ? \
d306 6
d535 1
a535 1
extern	int nmbclust;			/* limit on the # of clusters */
d543 2
d559 2
d568 1
a568 1
void	m_reclaim __P((void *, int));
d576 1
@


1.14.2.6
log
@Merge in -current from roughly a week ago
@
text
@d93 2
a94 2
					/* free routine if not the usual */
	void	(*ext_free)(caddr_t, u_int, void *);
d543 26
a568 26
void	mbinit(void);
struct	mbuf *m_copym2(struct mbuf *, int, int, int);
struct	mbuf *m_copym(struct mbuf *, int, int, int);
struct	mbuf *m_free(struct mbuf *);
struct	mbuf *m_get(int, int);
struct	mbuf *m_getclr(int, int);
struct	mbuf *m_gethdr(int, int);
struct	mbuf *m_prepend(struct mbuf *, int, int);
struct	mbuf *m_pulldown(struct mbuf *, int, int, int *);
struct	mbuf *m_pullup(struct mbuf *, int);
struct	mbuf *m_pullup2(struct mbuf *, int);
struct	mbuf *m_split(struct mbuf *, int, int);
struct  mbuf *m_inject(struct mbuf *, int, int, int);
struct  mbuf *m_getptr(struct mbuf *, int, int *);
void	m_adj(struct mbuf *, int);
int	m_clalloc(int, int);
void	m_copyback(struct mbuf *, int, int, caddr_t);
void	m_freem(struct mbuf *);
void	m_reclaim(void *, int);
void	m_copydata(struct mbuf *, int, int, caddr_t);
void	m_cat(struct mbuf *, struct mbuf *);
struct mbuf *m_devget(char *, int, int, struct ifnet *,
	    void (*)(const void *, void *, size_t));
void	m_zero(struct mbuf *);
int	m_apply(struct mbuf *, int, int,
	    int (*)(caddr_t, caddr_t, unsigned int), caddr_t);
d571 12
a582 12
struct m_tag *m_tag_get(int, int, int);
void	m_tag_free(struct m_tag *);
void	m_tag_prepend(struct mbuf *, struct m_tag *);
void	m_tag_unlink(struct mbuf *, struct m_tag *);
void	m_tag_delete(struct mbuf *, struct m_tag *);
void	m_tag_delete_chain(struct mbuf *, struct m_tag *);
struct m_tag *m_tag_find(struct mbuf *, int, struct m_tag *);
struct m_tag *m_tag_copy(struct m_tag *);
int	m_tag_copy_chain(struct mbuf *, struct mbuf *);
void	m_tag_init(struct mbuf *);
struct m_tag *m_tag_first(struct mbuf *);
struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);
@


1.14.2.7
log
@Sync the SMP branch with 3.3
@
text
@d39 1
a39 1
#ifndef _SYS_MALLOC_H_
d143 3
a145 4
#define M_CONF		0x0400  /* payload was encrypted (ESP-transport) */
#define M_AUTH		0x0800  /* payload was authenticated (AH or ESP auth) */
#define M_COMP		0x1000  /* payload was compressed (IPCOMP) */
#define M_AUTH_AH	0x2000  /* header was authenticated (AH) */
d149 1
a149 1
#define M_TCPV4_CSUM_OUT	0x0002	/* TCP checksum needed */
d511 1
a511 1
/* compatibility with 4.3 */
d531 1
a531 1
extern	struct mbstat mbstat;
d535 4
a538 4
extern	int max_linkhdr;		/* largest link-level header */
extern	int max_protohdr;		/* largest protocol header */
extern	int max_hdr;			/* largest link+protocol header */
extern	int max_datalen;		/* MHLEN - max_hdr */
a596 3
#define PACKET_TAG_PF_ROUTED			12 /* PF routed, no route loops */
#define PACKET_TAG_PF_FRAGCACHE			13 /* PF fragment cached */
#define	PACKET_TAG_PF_QID			14 /* PF queue id */
@


1.14.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@a600 1
#define PACKET_TAG_PF_TAG			15 /* PF tags */
@


1.14.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.14.2.8 2003/05/16 00:29:45 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a142 1
#define M_TUNNEL	0x4000  /* IP-in-IP added by tunnel mode IPsec */
d161 1
a161 2
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_PROTO1|M_BCAST|M_MCAST|M_CONF|\
			 M_AUTH|M_COMP|M_ANYCAST6|M_LOOP|M_TUNNEL)
d556 1
a556 1
void	m_copyback(struct mbuf *, int, int, const void *);
a597 2
#define PACKET_TAG_CARP				16 /* CARP info */
#define PACKET_TAG_PF_TRANSLATE_LOCALHOST	17 /* translated to localhost */
@


1.14.2.11
log
@Merge with the trunk
@
text
@d52 1
a52 2
/* smallest amount to put in cluster */
#define	MINCLSIZE	(MHLEN + MLEN + 1)
@


1.13
log
@Add an m_inject()
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.12 1999/10/01 02:00:11 jason Exp $	*/
d54 1
a54 1
#define	MINCLSIZE	(MHLEN+MLEN+1)	/* smallest amount to put in cluster */
d133 1
a134 1

d137 12
d151 1
a151 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_TUNNEL|M_DAD)
@


1.12
log
@remove dependency on external storage managed by mclusters and
add more support for external managers
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.11 1999/07/02 01:02:52 cmetz Exp $	*/
d393 1
@


1.11
log
@Added a simple but potentially very useful new mbuf function, m_apply().
It applies the supplied function f(state, p, len) to every contiguous region
in a mbuf, thus mostly handling all the mbuf-isms for you.

It's used by my TCP MD5 signature implementation to run MD5 over the TCP
payload data in a mbuf so that I don't have to spread mbufism-loops all over.
It might also be useful for IPsec.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.10 1999/03/27 21:04:21 provos Exp $	*/
d91 1
a91 1
		    __P((caddr_t, u_int));
d93 3
d245 3
a247 1
		(m)->m_ext.ext_free = 0; \
a270 1
#ifdef notyet
d275 1
a275 2
			(*((m)->m_ext.ext_free))((m)->m_ext.ext_buf, \
			    (m)->m_ext.ext_size); \
a281 10
#else /* notyet */
#define	MFREE(m, nn) \
	{ MBUFLOCK(mbstat.m_mtypes[(m)->m_type]--;) \
	  if ((m)->m_flags & M_EXT) { \
		MCLFREE((m)->m_ext.ext_buf); \
	  } \
	  (nn) = (m)->m_next; \
	  FREE((m), mbtypes[(m)->m_type]); \
	}
#endif
@


1.10
log
@add SADB_X_BINDSA to pfkey allowing incoming SAs to refer to an outgoing
SA to be used, use this SA in ip_output if available. allow mobile road
warriors for bind SAs with wildcard dst and src addresses. check IPSEC
AUTH and ESP level when receiving packets, drop them if protection is
insufficient. add stats to show dropped packets because of insufficient
IPSEC protection. -- phew.  this was all done in canada. dugsong and linh
provided the ride and company.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.9 1999/01/07 22:33:31 deraadt Exp $	*/
d410 2
@


1.9
log
@make MCL_ALIGN() available outside INET6 land
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.8 1999/01/07 22:28:01 deraadt Exp $	*/
d83 2
@


1.8
log
@new APIs: m_pullup2, m_copym2, m_zero, MCL_ALIGN; NRL/cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.7 1998/06/10 23:57:08 provos Exp $	*/
a252 1
#ifdef INET6
a257 1
#endif /* INET6 */
@


1.7
log
@make the packets which were successfully processed by IPSec available to
bpf via the enc0 interface, using linktype DLT_ENC.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.6 1997/07/23 02:49:35 denny Exp $	*/
d74 1
a74 1
	int	mh_len;			/* amount of data in this mbuf */
d130 3
d134 1
a134 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_TUNNEL)
d253 8
d388 1
d396 1
d409 1
@


1.6
log
@Update from 4.4lite2 (needed for netatalk, others).
This changes the def of some of the MT_ flags. Lite2 did it for unknown reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.5 1997/07/11 23:37:50 provos Exp $	*/
d128 1
a128 1
#define M_CTUN		0x1000  /* packet was encrypted (ESP-tunnel) */
d131 1
a131 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_BCAST|M_MCAST|M_CONF|M_AUTH|M_CTUN)
@


1.5
log
@put old esp/ah and new esp/ah in different files.
generalised way of handling transforms.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.4 1997/06/08 18:17:14 deraadt Exp $	*/
d36 1
a36 1
 *	@@(#)mbuf.h	8.3 (Berkeley) 1/21/94
d137 12
a148 5
#define	MT_SONAME	3	/* socket name */
#define	MT_SOOPTS	4	/* socket options */
#define	MT_FTABLE	5	/* fragment reassembly header */
#define MT_CONTROL	6	/* extra-data protocol message */
#define MT_OOBDATA	7	/* expedited data  */
d402 13
a414 5
	M_MBUF,		/* MT_SONAME	3	   socket name */
	M_SOOPTS,	/* MT_SOOPTS	4	   socket options */
	M_FTABLE,	/* MT_FTABLE	5	   fragment reassembly header */
	M_MBUF,		/* MT_CONTROL	6	   extra-data protocol message */
	M_MBUF,		/* MT_OOBDATA	7	   expedited data  */
@


1.4
log
@stevens points out MINCLSIZE is wrong; frueauf@@ira.uka.de
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.3 1996/09/02 18:14:21 dm Exp $	*/
d126 3
d131 1
a131 1
#define	M_COPYFLAGS	(M_PKTHDR|M_EOR|M_BCAST|M_MCAST)
@


1.3
log
@Don't drain the protocol queues at interrupt level.
@
text
@d1 1
a1 1
/*	$OpenBSD: mbuf.h,v 1.2 1996/03/03 12:12:00 niklas Exp $	*/
d44 1
a44 1
 * Mbufs are of a single size, MSIZE (machine/machparam.h), which
d46 1
a46 1
 * MCLBYTES (also in machine/machparam.h), which has no additional overhead
d54 1
a54 1
#define	MINCLSIZE	(MHLEN + MLEN)	/* smallest amount to put in cluster */
@


1.2
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d363 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: mbuf.h,v 1.17 1995/08/16 01:04:06 mycroft Exp $	*/
d88 2
a89 1
	void	(*ext_free)();		/* free routine if not the usual */
d364 1
d379 5
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
