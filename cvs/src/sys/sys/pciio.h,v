head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.26
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.28
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.24
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.20
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.22
	OPENBSD_5_8_BASE:1.7
	OPENBSD_5_7:1.7.0.14
	OPENBSD_5_7_BASE:1.7
	OPENBSD_5_6:1.7.0.18
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.16
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.12
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.2.0.40
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.36
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.34
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.32
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.30
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.28
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.26
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.24
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.22
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.20
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.18
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.16
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.14
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.12
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.10
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.8
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.2.0.6
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.4
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.7
date	2010.09.05.18.14.33;	author kettenis;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.21.18.55.40;	author kettenis;	state Exp;
branches;
next	1.5;

1.5
date	2009.11.05.20.30.47;	author kettenis;	state Exp;
branches;
next	1.4;

1.4
date	2009.07.26.13.21.18;	author kettenis;	state Exp;
branches;
next	1.3;

1.3
date	2009.07.14.18.20.02;	author kettenis;	state Exp;
branches;
next	1.2;

1.2
date	2001.06.26.20.44.14;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.23.03.30.37;	author matthieu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Add an ioctl to figure out the non-sticky bits in PCI BARs used for determining
the size of those BARs.  Make pcidump use this new ioctl to print the size
of PCI BARs.

ok deraadt@@, miod@@
@
text
@/*	$OpenBSD: pciio.h,v 1.6 2010/04/21 18:55:40 kettenis Exp $	*/

/*-
 * Copyright (c) 1997, Stefan Esser <se@@FreeBSD.ORG>
 * Copyright (c) 1997, 1998, 1999, Kenneth D. Merry <ken@@FreeBSD.ORG>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	$FreeBSD: src/sys/sys/pciio.h,v 1.5 1999/12/08 17:44:04 ken Exp $
 *
 */

#ifndef _SYS_PCIIO_H_
#define	_SYS_PCIIO_H_

#include <sys/ioccom.h>

struct pcisel {
	u_int8_t	pc_bus;		/* bus number */
	u_int8_t	pc_dev;		/* device on this bus */
	u_int8_t	pc_func;	/* function on this device */
};

struct pci_io {
	struct pcisel	pi_sel;		/* device to operate on */
	int		pi_reg;		/* configuration register to examine */
	int		pi_width;	/* width (in bytes) of read or write */
	u_int32_t	pi_data;	/* data to write or result of read */
};

struct pci_rom {
	struct pcisel	pr_sel;
	int		pr_romlen;
	char		*pr_rom;
};

struct pci_vga {
	struct pcisel	pv_sel;
	int		pv_lock;
	int		pv_decode;
};

#define	PCI_VGA_UNLOCK		0x00
#define	PCI_VGA_LOCK		0x01
#define	PCI_VGA_TRYLOCK		0x02

#define	PCI_VGA_IO_ENABLE	0x01
#define	PCI_VGA_MEM_ENABLE	0x02

#define	PCIOCREAD	_IOWR('p', 2, struct pci_io)
#define	PCIOCWRITE	_IOWR('p', 3, struct pci_io)
#define	PCIOCGETROMLEN	_IOWR('p', 4, struct pci_rom)
#define	PCIOCGETROM	_IOWR('p', 5, struct pci_rom)
#define	PCIOCGETVGA	_IOWR('p', 6, struct pci_vga)
#define	PCIOCSETVGA	_IOWR('p', 7, struct pci_vga)
#define	PCIOCREADMASK	_IOWR('p', 8, struct pci_io)

#endif /* !_SYS_PCIIO_H_ */
@


1.6
log
@First stab at a VGA arbiter.  The VGA arbiter makes sure that only a single
VGA device can be active, and is responsible for routing IO to the active VGA
device.  Processes can use the new PCIOC_GETVGA and PCIOC_SETVGA ioctls
to manipulate the VGA arbiter.

ok deraadt@@, oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciio.h,v 1.5 2009/11/05 20:30:47 kettenis Exp $	*/
d76 1
@


1.5
log
@Add a new PCIOCGETROMLEN ioctl, to give users of PCIOGETROM a chance to
allocate a buffer of the right size.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciio.h,v 1.4 2009/07/26 13:21:18 kettenis Exp $	*/
d57 12
d74 2
@


1.4
log
@Add PCIOCGETROM, and ioctl(2) to read PCI ROMs.

ok miod@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciio.h,v 1.3 2009/07/14 18:20:02 kettenis Exp $	*/
d60 1
@


1.3
log
@Kill structs and ioctls that were never implemented.

ok oga@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pciio.h,v 1.2 2001/06/26 20:44:14 jason Exp $	*/
d50 7
a56 1
	
d60 1
@


1.2
log
@openbsd tag
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 21
#define PCI_MAXNAMELEN	16

typedef enum {
	PCI_GETCONF_LAST_DEVICE,
	PCI_GETCONF_LIST_CHANGED,
	PCI_GETCONF_MORE_DEVS,
	PCI_GETCONF_ERROR
} pci_getconf_status;

typedef enum {
	PCI_GETCONF_NO_MATCH		= 0x00,
	PCI_GETCONF_MATCH_BUS		= 0x01,
	PCI_GETCONF_MATCH_DEV		= 0x02,
	PCI_GETCONF_MATCH_FUNC		= 0x04,
	PCI_GETCONF_MATCH_NAME		= 0x08,
	PCI_GETCONF_MATCH_UNIT		= 0x10,
	PCI_GETCONF_MATCH_VENDOR	= 0x20,
	PCI_GETCONF_MATCH_DEVICE	= 0x40,
	PCI_GETCONF_MATCH_CLASS		= 0x80
} pci_getconf_flags;

a43 39
struct	pci_conf {
	struct pcisel	pc_sel;		/* bus+slot+function */
	u_int8_t	pc_hdr;		/* PCI header type */
	u_int16_t	pc_subvendor;	/* card vendor ID */
	u_int16_t	pc_subdevice;	/* card device ID, assigned by 
					   card vendor */
	u_int16_t	pc_vendor;	/* chip vendor ID */
	u_int16_t	pc_device;	/* chip device ID, assigned by 
					   chip vendor */
	u_int8_t	pc_class;	/* chip PCI class */
	u_int8_t	pc_subclass;	/* chip PCI subclass */
	u_int8_t	pc_progif;	/* chip PCI programming interface */
	u_int8_t	pc_revid;	/* chip revision ID */
	char		pd_name[PCI_MAXNAMELEN + 1];  /* device name */
	u_long		pd_unit;	/* device unit number */
};

struct pci_match_conf {
	struct pcisel		pc_sel;		/* bus+slot+function */
	char			pd_name[PCI_MAXNAMELEN + 1];  /* device name */
	u_long			pd_unit;	/* Unit number */
	u_int16_t		pc_vendor;	/* PCI Vendor ID */
	u_int16_t		pc_device;	/* PCI Device ID */
	u_int8_t		pc_class;	/* PCI class */
	pci_getconf_flags	flags;		/* Matching expression */
};

struct	pci_conf_io {
	u_int32_t		pat_buf_len;	/* pattern buffer length */
	u_int32_t		num_patterns;	/* number of patterns */
	struct pci_match_conf	*patterns;	/* pattern buffer */
	u_int32_t		match_buf_len;	/* match buffer length */
	u_int32_t		num_matches;	/* number of matches returned */
	struct pci_conf		*matches;	/* match buffer */
	u_int32_t		offset;		/* offset into device list */
	u_int32_t		generation;	/* device list generation */
	pci_getconf_status	status;		/* request status */
};

a51 1
#define	PCIOCGETCONF	_IOWR('p', 1, struct pci_conf_io)
a53 1
#define	PCIOCATTACHED	_IOWR('p', 4, struct pci_io)
@


1.1
log
@PCI bus configuration userland access from FreeBSD.
Will be used by XFree86 on powerpc (works on i386 too, but its not currently
used).
@
text
@d1 2
@

