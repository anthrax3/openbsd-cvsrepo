head	1.74;
access;
symbols
	OPENBSD_6_1:1.74.0.6
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.74.0.4
	OPENBSD_6_0_BASE:1.74
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.54.0.4
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.51.0.2
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.48.0.4
	OPENBSD_4_9_BASE:1.48
	OPENBSD_4_8:1.48.0.2
	OPENBSD_4_8_BASE:1.48
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.4
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.44.0.2
	OPENBSD_4_5_BASE:1.44
	OPENBSD_4_4:1.41.0.4
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.28.0.2
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.26.0.6
	OPENBSD_4_0_BASE:1.26
	OPENBSD_3_9:1.26.0.4
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.24.0.6
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.6
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.4
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.22
	UBC:1.20.0.6
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.18.0.2
	OPENBSD_2_7_BASE:1.18
	SMP:1.17.0.6
	SMP_BASE:1.17
	kame_19991208:1.17
	OPENBSD_2_6:1.17.0.4
	OPENBSD_2_6_BASE:1.17
	OPENBSD_2_5:1.17.0.2
	OPENBSD_2_5_BASE:1.17
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.2
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.13.0.2
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.8.0.2
	OPENBSD_2_0_BASE:1.8
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.74
date	2015.11.03.13.59.07;	author krw;	state Exp;
branches;
next	1.73;
commitid	IMLiiGZoi6Fu4cQk;

1.73
date	2015.10.25.16.35.40;	author krw;	state Exp;
branches;
next	1.72;
commitid	3oFGnk257DgqfXfj;

1.72
date	2015.09.24.19.28.33;	author krw;	state Exp;
branches;
next	1.71;
commitid	tv9K7MeyIhMhM2TZ;

1.71
date	2015.09.13.15.18.14;	author krw;	state Exp;
branches;
next	1.70;
commitid	9SOjAZUWeFi4LA1V;

1.70
date	2015.09.13.14.38.17;	author krw;	state Exp;
branches;
next	1.69;
commitid	c0XpqHGmLc5SimVj;

1.69
date	2015.09.13.12.53.08;	author krw;	state Exp;
branches;
next	1.68;
commitid	4CCbjaLmEQx7b0nk;

1.68
date	2015.09.10.16.30.23;	author krw;	state Exp;
branches;
next	1.67;
commitid	9pWIHufyPNBOOdoM;

1.67
date	2015.08.14.23.45.56;	author krw;	state Exp;
branches;
next	1.66;
commitid	k1yLEw6NQZGoWWtF;

1.66
date	2015.07.23.18.02.59;	author krw;	state Exp;
branches;
next	1.65;
commitid	q5wcyDnmemhtL3T8;

1.65
date	2015.05.09.17.11.26;	author krw;	state Exp;
branches;
next	1.64;
commitid	XgIfRGTOOf864WwV;

1.64
date	2014.08.30.10.44.02;	author miod;	state Exp;
branches;
next	1.63;
commitid	ufag0E85kLt8ZNJV;

1.63
date	2014.07.13.16.50.25;	author deraadt;	state Exp;
branches;
next	1.62;
commitid	w3zzc6gybEZQxIKv;

1.62
date	2014.07.13.15.32.28;	author miod;	state Exp;
branches;
next	1.61;
commitid	PkUmoT9mKpliN2oG;

1.61
date	2014.07.01.05.22.09;	author dlg;	state Exp;
branches;
next	1.60;
commitid	KSGdi4QkFFqkGr5x;

1.60
date	2014.05.05.13.32.15;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.10.04.59.06;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.03.14.18.55;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.19.09.32.15;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2013.09.11.01.42.21;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2013.06.11.16.42.18;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.06.15.10.40;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2011.10.06.21.16.01;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2011.09.29.18.03.44;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	2011.03.22.19.26.55;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2011.03.17.21.44.10;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.25.06.15.16;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.13.15.23.11;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.06.04.21.13.02;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.10.15.52.50;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.09.19.20.07;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.08.23.49.53;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2008.01.14.19.02.11;	author otto;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.09.11.32.57;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.11.04.50.43;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.20.18.15.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.17.00.27.29;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.06.16.42.07;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.05.00.38.24;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.02.02.35.27;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.18.09.52;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.31.03.19.19;	author otto;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.31.02.33.37;	author otto;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.29.16.26.53;	author thib;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.29.06.28.14;	author otto;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.24.20.29.52;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.29.16.30.21;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.28.21.26.19;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.01.23.19.36.25;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.02.23.28.21;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.03.16.12;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.14;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.25.21.32.05;	author hugh;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	2000.08.08.16.03.16;	author peter;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.07.13.53.40;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.01.11.10.23.42;	author niklas;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	98.10.03.21.19.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.05.17.03.09.39;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	98.02.06.22.17.18;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	97.08.08.21.47.06;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.05.31.06.17.10;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.12.05.13.08.47;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.12.03.01.06.50;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.11.06.01.36.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.22.11.40.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.02.13.14.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.31.42;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.10.47;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.03.12.11.33;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.05.05.45;	author briggs;	state Exp;
branches;
next	1.2;

1.2
date	96.02.20.04.53.03;	author briggs;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.26;	author deraadt;	state Exp;
branches;
next	;

1.17.6.1
date	2001.05.14.22.45.01;	author niklas;	state Exp;
branches;
next	1.17.6.2;

1.17.6.2
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.17.6.3;

1.17.6.3
date	2003.06.07.11.09.07;	author ho;	state Exp;
branches;
next	1.17.6.4;

1.17.6.4
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	;

1.20.6.1
date	2002.06.11.03.32.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Add & use a #define GPTPARTNAMESIZE rather than the magic number
'36'.

ok jsg@@ as part of larger diff.
@
text
@/*	$OpenBSD: disklabel.h,v 1.73 2015/10/25 16:35:40 krw Exp $	*/
/*	$NetBSD: disklabel.h,v 1.41 1996/05/10 23:07:37 mark Exp $	*/

/*
 * Copyright (c) 1987, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)disklabel.h	8.2 (Berkeley) 7/10/94
 */

/*
 * Disk description table, see disktab(5)
 */
#define	_PATH_DISKTAB	"/etc/disktab"
#define	DISKTAB		"/etc/disktab"		/* deprecated */

/*
 * Each disk has a label which includes information about the hardware
 * disk geometry, filesystem partitions, and drive specific information.
 * The location of the label, as well as the number of partitions the
 * label can describe and the number of the "whole disk" (raw)
 * partition are machine dependent.
 */
#include <machine/disklabel.h>

#include <sys/uuid.h>

/*
 * The absolute maximum number of disk partitions allowed.
 * This is the maximum value of MAXPARTITIONS for which 'struct disklabel'
 * is <= DEV_BSIZE bytes long.  If MAXPARTITIONS is greater than this, beware.
 */
#define	MAXMAXPARTITIONS	22
#if MAXPARTITIONS > MAXMAXPARTITIONS
#warn beware: MAXPARTITIONS bigger than MAXMAXPARTITIONS
#endif

/*
 * Translate between device numbers and major/disk unit/disk partition.
 */
#define	DISKUNIT(dev)	(minor(dev) / MAXPARTITIONS)
#define	DISKPART(dev)	(minor(dev) % MAXPARTITIONS)
#define	RAW_PART	2	/* 'c' partition */
#define	DISKMINOR(unit, part) \
    (((unit) * MAXPARTITIONS) + (part))
#define	MAKEDISKDEV(maj, unit, part) \
    (makedev((maj), DISKMINOR((unit), (part))))
#define	DISKLABELDEV(dev) \
    (MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART))

#define DISKMAGIC	((u_int32_t)0x82564557)	/* The disk magic number */

#define MAXDISKSIZE	0x7fffffffffffLL	/* 47 bits of reach */

#ifndef _LOCORE
struct disklabel {
	u_int32_t d_magic;		/* the magic number */
	u_int16_t d_type;		/* drive type */
	u_int16_t d_subtype;		/* controller/d_type specific */
	char	  d_typename[16];	/* type name, e.g. "eagle" */
	char	  d_packname[16];	/* pack identifier */

			/* disk geometry: */
	u_int32_t d_secsize;		/* # of bytes per sector */
	u_int32_t d_nsectors;		/* # of data sectors per track */
	u_int32_t d_ntracks;		/* # of tracks per cylinder */
	u_int32_t d_ncylinders;		/* # of data cylinders per unit */
	u_int32_t d_secpercyl;		/* # of data sectors per cylinder */
	u_int32_t d_secperunit;		/* # of data sectors (low part) */

	u_char	d_uid[8];		/* Unique label identifier. */

	/*
	 * Alternate cylinders include maintenance, replacement, configuration
	 * description areas, etc.
	 */
	u_int32_t d_acylinders;		/* # of alt. cylinders per unit */

			/* hardware characteristics: */
	u_int16_t d_bstarth;		/* start of useable region (high part) */
	u_int16_t d_bendh;		/* size of useable region (high part) */
	u_int32_t d_bstart;		/* start of useable region */
	u_int32_t d_bend;		/* end of useable region */
	u_int32_t d_flags;		/* generic flags */
#define NDDATA 5
	u_int32_t d_drivedata[NDDATA];	/* drive-type specific information */
	u_int16_t d_secperunith;	/* # of data sectors (high part) */
	u_int16_t d_version;		/* version # (1=48 bit addressing) */
#define NSPARE 4
	u_int32_t d_spare[NSPARE];	/* reserved for future use */
	u_int32_t d_magic2;		/* the magic number (again) */
	u_int16_t d_checksum;		/* xor of data incl. partitions */

			/* filesystem and partition information: */
	u_int16_t d_npartitions;	/* number of partitions in following */
	u_int32_t d_bbsize;		/* size of boot area at sn0, bytes */
	u_int32_t d_sbsize;		/* max size of fs superblock, bytes */
	struct	partition {		/* the partition table */
		u_int32_t p_size;	/* number of sectors (low part) */
		u_int32_t p_offset;	/* starting sector (low part) */
		u_int16_t p_offseth;	/* starting sector (high part) */
		u_int16_t p_sizeh;	/* number of sectors (high part) */
		u_int8_t p_fstype;	/* filesystem type, see below */
		u_int8_t p_fragblock;	/* encoded filesystem frag/block */
		u_int16_t p_cpg;	/* UFS: FS cylinders per group */
	} d_partitions[MAXPARTITIONS];	/* actually may be more */
};


struct	__partitionv0 {		/* old (v0) partition table entry */
	u_int32_t p_size;	/* number of sectors in partition */
	u_int32_t p_offset;	/* starting sector */
	u_int32_t p_fsize;	/* filesystem basic fragment size */
	u_int8_t p_fstype;	/* filesystem type, see below */
	u_int8_t p_frag;	/* filesystem fragments per block */
	union {
		u_int16_t cpg;	/* UFS: FS cylinders per group */
		u_int16_t sgs;	/* LFS: FS segment shift */
	} __partitionv0_u1;
};
#endif /* _LOCORE */


#define DISKLABELV1_FFS_FRAGBLOCK(fsize, frag) 			\
	((fsize) * (frag) == 0 ? 0 :				\
	(((ffs((fsize) * (frag)) - 13) << 3) | (ffs(frag))))

#define DISKLABELV1_FFS_BSIZE(i) ((i) == 0 ? 0 : (1 << (((i) >> 3) + 12)))
#define DISKLABELV1_FFS_FRAG(i) ((i) == 0 ? 0 : (1 << (((i) & 0x07) - 1)))
#define DISKLABELV1_FFS_FSIZE(i) (DISKLABELV1_FFS_FRAG(i) == 0 ? 0 : \
	(DISKLABELV1_FFS_BSIZE(i) / DISKLABELV1_FFS_FRAG(i)))

#define DL_GETPSIZE(p)		(((u_int64_t)(p)->p_sizeh << 32) + (p)->p_size)
#define DL_SETPSIZE(p, n)	do { \
					u_int64_t x = (n); \
					(p)->p_sizeh = x >> 32; \
					(p)->p_size = x; \
				} while (0)
#define DL_GETPOFFSET(p)	(((u_int64_t)(p)->p_offseth << 32) + (p)->p_offset)
#define DL_SETPOFFSET(p, n)	do { \
					u_int64_t x = (n); \
					(p)->p_offseth = x >> 32; \
					(p)->p_offset = x; \
				} while (0)

#define DL_GETDSIZE(d)		(((u_int64_t)(d)->d_secperunith << 32) + \
				    (d)->d_secperunit)
#define DL_SETDSIZE(d, n)	do { \
					u_int64_t x = (n); \
					(d)->d_secperunith = x >> 32; \
					(d)->d_secperunit = x; \
				} while (0)
#define DL_GETBSTART(d)		(((u_int64_t)(d)->d_bstarth << 32) + \
				    (d)->d_bstart)
#define DL_SETBSTART(d, n)	do { \
					u_int64_t x = (n); \
					(d)->d_bstarth = x >> 32; \
					(d)->d_bstart = x; \
				} while (0)
#define DL_GETBEND(d)		(((u_int64_t)(d)->d_bendh << 32) + \
				    (d)->d_bend)
#define DL_SETBEND(d, n)	do { \
					u_int64_t x = (n); \
					(d)->d_bendh = x >> 32; \
					(d)->d_bend = x; \
				} while (0)

#define DL_BLKSPERSEC(d)	((d)->d_secsize / DEV_BSIZE)
#define DL_SECTOBLK(d, n)	((n) * DL_BLKSPERSEC(d))
#define DL_BLKTOSEC(d, n)	((n) / DL_BLKSPERSEC(d))
#define DL_BLKOFFSET(d, n)	(((n) % DL_BLKSPERSEC(d)) * DEV_BSIZE)

/* d_type values: */
#define	DTYPE_SMD		1		/* SMD, XSMD; VAX hp/up */
#define	DTYPE_MSCP		2		/* MSCP */
#define	DTYPE_DEC		3		/* other DEC (rk, rl) */
#define	DTYPE_SCSI		4		/* SCSI */
#define	DTYPE_ESDI		5		/* ESDI interface */
#define	DTYPE_ST506		6		/* ST506 etc. */
#define	DTYPE_HPIB		7		/* CS/80 on HP-IB */
#define	DTYPE_HPFL		8		/* HP Fiber-link */
#define	DTYPE_FLOPPY		10		/* floppy */
#define	DTYPE_CCD		11		/* was: concatenated disk device */
#define	DTYPE_VND		12		/* vnode pseudo-disk */
#define	DTYPE_ATAPI		13		/* ATAPI */
#define DTYPE_RAID		14		/* was: RAIDframe */
#define DTYPE_RDROOT		15		/* ram disk root */

#ifdef DKTYPENAMES
static char *dktypenames[] = {
	"unknown",
	"SMD",
	"MSCP",
	"old DEC",
	"SCSI",
	"ESDI",
	"ST506",
	"HP-IB",
	"HP-FL",
	"type 9",
	"floppy",
	"ccd",			/* deprecated */
	"vnd",
	"ATAPI",
	"RAID",
	"rdroot",
	NULL
};
#define DKMAXTYPES	(sizeof(dktypenames) / sizeof(dktypenames[0]) - 1)
#endif

/*
 * Filesystem type and version.
 * Used to interpret other filesystem-specific
 * per-partition information.
 */
#define	FS_UNUSED	0		/* unused */
#define	FS_SWAP		1		/* swap */
#define	FS_V6		2		/* Sixth Edition */
#define	FS_V7		3		/* Seventh Edition */
#define	FS_SYSV		4		/* System V */
#define	FS_V71K		5		/* V7 with 1K blocks (4.1, 2.9) */
#define	FS_V8		6		/* Eighth Edition, 4K blocks */
#define	FS_BSDFFS	7		/* 4.2BSD fast file system */
#define	FS_MSDOS	8		/* MSDOS file system */
#define	FS_BSDLFS	9		/* 4.4BSD log-structured file system */
#define	FS_OTHER	10		/* in use, but unknown/unsupported */
#define	FS_HPFS		11		/* OS/2 high-performance file system */
#define	FS_ISO9660	12		/* ISO 9660, normally CD-ROM */
#define	FS_BOOT		13		/* partition contains bootstrap */
#define	FS_ADOS		14		/* AmigaDOS fast file system */
#define	FS_HFS		15		/* Macintosh HFS */
#define	FS_ADFS		16		/* Acorn Disk Filing System */
#define FS_EXT2FS	17		/* ext2fs */
#define FS_CCD		18		/* ccd component */
#define FS_RAID		19		/* RAIDframe or softraid */
#define FS_NTFS		20		/* Windows/NT file system */
#define FS_UDF		21		/* UDF (DVD) filesystem */

#ifdef DKTYPENAMES
static char *fstypenames[] = {
	"unused",
	"swap",
	"Version6",
	"Version7",
	"SystemV",
	"4.1BSD",
	"Eighth-Edition",
	"4.2BSD",
	"MSDOS",
	"4.4LFS",
	"unknown",
	"HPFS",
	"ISO9660",
	"boot",
	"ADOS",
	"HFS",
	"ADFS",
	"ext2fs",
	"ccd",
	"RAID",
	"NTFS",
	"UDF",
	NULL
};

/* Similar to the above, but used for things like the mount command. */
static char *fstypesnames[] = {
	"",		/* 0 */
	"",		/* 1 */
	"",		/* 2 */
	"",		/* 3 */
	"",		/* 4 */
	"",		/* 5 */
	"",		/* 6 */
	"ffs",		/* 7 */
	"msdos",	/* 8 */
	"lfs",		/* 9 */
	"",		/* 10 */
	"",		/* 11 */
	"cd9660",	/* 12 */
	"",		/* 13 */
	"ados",		/* 14 */
	"",		/* 15 */
	"",		/* 16 */
	"ext2fs",	/* 17 */
	"",		/* 18 */
	"",		/* 19 */
	"ntfs",		/* 20 */
	"udf",		/* 21 */
	NULL
};

#define FSMAXTYPES	(sizeof(fstypenames) / sizeof(fstypenames[0]) - 1)
#endif

/*
 * flags shared by various drives:
 */
#define		D_BADSECT	0x04		/* supports bad sector forw. */
#define		D_VENDOR	0x08		/* vendor disklabel */

/*
 * Drive data for SMD.
 */
#define	d_smdflags	d_drivedata[0]
#define		D_SSE		0x1		/* supports skip sectoring */
#define	d_mindist	d_drivedata[1]
#define	d_maxdist	d_drivedata[2]
#define	d_sdist		d_drivedata[3]

/*
 * Drive data for ST506.
 */
#define d_precompcyl	d_drivedata[0]
#define d_gap3		d_drivedata[1]		/* used only when formatting */

/*
 * Drive data for SCSI.
 */
#define	d_blind		d_drivedata[0]

#ifndef _LOCORE
/*
 * Structure used to perform a format or other raw operation, returning
 * data and/or register values.  Register identification and format
 * are device- and driver-dependent.
 */
struct format_op {
	char	*df_buf;
	int	 df_count;		/* value-result */
	daddr_t	 df_startblk;
	int	 df_reg[8];		/* result */
};

/*
 * Structure used internally to retrieve information about a partition
 * on a disk.
 */
struct partinfo {
	struct disklabel *disklab;
	struct partition *part;
};

/* GUID partition table -- located at sector 1 of some disks. */
#define	GPTSECTOR		1	/* DOS boot block relative sector # */
#define	GPTSIGNATURE		0x5452415020494645LL
				/* ASCII string "EFI PART" encoded as 64-bit */
#define	GPTREVISION		0x10000		/* GPT header version 1.0 */
#define	NGPTPARTITIONS		128
#define	GPTDOSACTIVE		0x2
#define	GPTMINHDRSIZE		92
#define	GPTMINPARTSIZE		128
#define	GPTPARTNAMESIZE		36

/* all values in the GPT need to be little endian as per UEFI specification */
struct gpt_header {
	u_int64_t gh_sig;	/* "EFI PART" */
	u_int32_t gh_rev;	/* GPT Version 1.0: 0x00000100 */
	u_int32_t gh_size;	/* Little-Endian */
	u_int32_t gh_csum;	/* CRC32: with this field as 0 */
	u_int32_t gh_rsvd;	/* always zero */
	u_int64_t gh_lba_self;	/* LBA of this header */
	u_int64_t gh_lba_alt;	/* LBA of alternate header */
	u_int64_t gh_lba_start;	/* first usable LBA */
	u_int64_t gh_lba_end;	/* last usable LBA */
	struct uuid gh_guid;	/* disk GUID used to identify the disk */
	u_int64_t gh_part_lba;	/* starting LBA of GPT partition entries */
	u_int32_t gh_part_num;	/* # of partition entries */
	u_int32_t gh_part_size;	/* size per entry, shall be 128*(2**n)
				   with n >= 0 */
	u_int32_t gh_part_csum;	/* CRC32 checksum of all partition entries:
				 * starts at gh_part_lba and is computed over
				 * a byte length of gh_part_num*gh_part_size */
	/* the rest of the block is reserved by UEFI and must be zero */
};

struct gpt_partition {
	struct uuid gp_type;	/* partition type GUID */
	struct uuid gp_guid;	/* unique partition GUID */
	u_int64_t gp_lba_start;	/* starting LBA of this partition */
	u_int64_t gp_lba_end;	/* ending LBA of this partition, inclusive,
				   usually odd */
	u_int64_t gp_attrs;	/* attribute flags */
	u_int16_t gp_name[GPTPARTNAMESIZE]; /* partition name, utf-16le */
	/* the rest of the GPT partition entry, if any, is reserved by UEFI
	   and must be zero */
};

#define GPT_UUID_UNUSED \
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
#define GPT_UUID_MSDOS \
    { 0xeb, 0xd0, 0xa0, 0xa2, 0xb9, 0xe5, 0x44, 0x33, \
      0x87, 0xc0, 0x68, 0xb6, 0xb7, 0x26, 0x99, 0xc7 }
#define GPT_UUID_EFI_SYSTEM \
    { 0xc1, 0x2a, 0x73, 0x28, 0xf8, 0x1f, 0x11, 0xd2, \
      0xba, 0x4b, 0x00, 0xa0, 0xc9, 0x3e, 0xc9, 0x3b }
#define GPT_UUID_LEGACY_MBR \
    { 0x02, 0x4d, 0xee, 0x41, 0x33, 0x37, 0x11, 0xd3, \
      0x9d, 0x69, 0x00, 0x08, 0xc7, 0x81, 0xf3, 0x9f }
#define GPT_UUID_OPENBSD \
    { 0x82, 0x4c, 0xc7, 0xa0, 0x36, 0xa8, 0x11, 0xe3, \
      0x89, 0x0a, 0x95, 0x25, 0x19, 0xad, 0x3f, 0x61 }
#define GPT_UUID_CHROMEROOTFS \
    { 0x3c, 0xb8, 0xe2, 0x02, 0x3b, 0x7e, 0x47, 0xdd, \
      0x8a, 0x3c, 0x7f, 0xf2, 0xa1, 0x3c, 0xfc, 0xec }
#define GPT_UUID_LINUX \
    { 0x0f, 0xc6, 0x3d, 0xaf, 0x84, 0x83, 0x47, 0x72, \
      0x8e, 0x79, 0x3d, 0x69, 0xd8, 0x47, 0x7d, 0xe4 }
#define GPT_UUID_LINUX_HOME \
    { 0x93, 0x3a, 0xc7, 0xe1, 0x2e, 0xb4, 0x4f, 0x13, \
      0xb8, 0x44, 0x0e, 0x14, 0xe2, 0xae, 0xf9, 0x15 }
#define GPT_UUID_LINUX_SRV \
    { 0x3b, 0x8f, 0x84, 0x25, 0x20, 0xe0, 0x4f, 0x3b, \
      0x90, 0x7f, 0x1a, 0x25, 0xa7, 0x6f, 0x98, 0xe8 }
#define GPT_UUID_FBSD_DATA \
    { 0x51, 0x6e, 0x7c, 0xb4, 0x6e, 0xcf, 0x11, 0xd6, \
      0x8f, 0xf8, 0x00, 0x02, 0x2d, 0x09, 0x71, 0x2b }
#define GPT_UUID_FBSD_UFS \
    { 0x51, 0x6e, 0x7c, 0xb6, 0x6e, 0xcf, 0x11, 0xd6, \
      0x8f, 0xf8, 0x00, 0x02, 0x2d, 0x09, 0x71, 0x2b }
#define GPT_UUID_NBSD_UFS \
    { 0x49, 0xf4, 0x8d, 0x5a, 0xb1, 0x0e, 0x11, 0xdc, \
      0xb9, 0x9b, 0x00, 0x19, 0xd1, 0x87, 0x96, 0x48 }
#define GPT_UUID_APPLE_HFS \
    { 0x48, 0x46, 0x53, 0x00, 0x00, 0x00, 0x11, 0xaa, \
      0xaa, 0x11, 0x00, 0x30, 0x65, 0x43, 0xec, 0xac }
#define GPT_UUID_APPLE_UFS \
    { 0x55, 0x46, 0x53, 0x00, 0x00, 0x00, 0x11, 0xaa, \
      0xaa, 0x11, 0x00, 0x30, 0x65, 0x43, 0xec, 0xac }

/* DOS partition table -- located at start of some disks. */
#define	DOS_LABELSECTOR 1
#define	DOSBBSECTOR	0		/* DOS boot block relative sector # */
#define	DOSPARTOFF	446
#define	DOSDISKOFF	444
#define	NDOSPART	4
#define	DOSACTIVE	0x80		/* active partition */

#define	DOSMBR_SIGNATURE	(0xaa55)
#define	DOSMBR_SIGNATURE_OFF	(0x1fe)

/* Maximum number of Extended Boot Records (EBRs) to traverse. */
#define	DOS_MAXEBR	256

struct dos_partition {
	u_int8_t	dp_flag;	/* bootstrap flags */
	u_int8_t	dp_shd;		/* starting head */
	u_int8_t	dp_ssect;	/* starting sector */
	u_int8_t	dp_scyl;	/* starting cylinder */
	u_int8_t	dp_typ;		/* partition type (see below) */
	u_int8_t	dp_ehd;		/* end head */
	u_int8_t	dp_esect;	/* end sector */
	u_int8_t	dp_ecyl;	/* end cylinder */
	u_int32_t	dp_start;	/* absolute starting sector number */
	u_int32_t	dp_size;	/* partition size in sectors */
};

/* Isolate the relevant bits to get sector and cylinder. */
#define	DPSECT(s)	((s) & 0x3f)
#define	DPCYL(c, s)	((c) + (((s) & 0xc0) << 2))

/* Known DOS partition types. */
#define	DOSPTYP_UNUSED	0x00		/* Unused partition */
#define	DOSPTYP_FAT12	0x01		/* 12-bit FAT */
#define	DOSPTYP_FAT16S	0x04		/* 16-bit FAT, less than 32M */
#define	DOSPTYP_EXTEND	0x05		/* Extended; contains sub-partitions */
#define	DOSPTYP_FAT16B	0x06		/* 16-bit FAT, more than 32M */
#define	DOSPTYP_NTFS	0x07		/* NTFS */
#define	DOSPTYP_FAT32	0x0b		/* 32-bit FAT */
#define	DOSPTYP_FAT32L	0x0c		/* 32-bit FAT, LBA-mapped */
#define	DOSPTYP_FAT16L	0x0e		/* 16-bit FAT, LBA-mapped */
#define	DOSPTYP_EXTENDL 0x0f		/* Extended, LBA-mapped; (sub-partitions) */
#define	DOSPTYP_ONTRACK	0x54
#define	DOSPTYP_LINUX	0x83		/* That other thing */
#define	DOSPTYP_FREEBSD	0xa5		/* FreeBSD partition type */
#define	DOSPTYP_OPENBSD	0xa6		/* OpenBSD partition type */
#define	DOSPTYP_NETBSD	0xa9		/* NetBSD partition type */
#define	DOSPTYP_EFI	0xee		/* EFI Protective Partition */
#define	DOSPTYP_EFISYS	0xef		/* EFI System Partition */

struct dos_mbr {
	u_int8_t		dmbr_boot[DOSPARTOFF];
	struct dos_partition	dmbr_parts[NDOSPART];
	u_int16_t		dmbr_sign;
} __packed;

#ifdef _KERNEL
void	 diskerr(struct buf *, char *, char *, int, int, struct disklabel *);
u_int	 dkcksum(struct disklabel *);
int	 initdisklabel(struct disklabel *);
int	 checkdisklabel(void *, struct disklabel *, u_int64_t, u_int64_t);
int	 setdisklabel(struct disklabel *, struct disklabel *, u_int);
int	 readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *, int);
int	 writedisklabel(dev_t, void (*)(struct buf *), struct disklabel *);
int	 bounds_check_with_label(struct buf *, struct disklabel *);
int	 readdisksector(struct buf *, void (*)(struct buf *),
	    struct disklabel *, u_int64_t);
int	 readdoslabel(struct buf *, void (*)(struct buf *),
	    struct disklabel *, daddr_t *, int);
#ifdef CD9660
int iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	struct disklabel *lp);
#endif
#ifdef UDF
int udf_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	struct disklabel *lp);
#endif
#endif
#endif /* _LOCORE */

#if !defined(_KERNEL) && !defined(_LOCORE)

#include <sys/cdefs.h>

__BEGIN_DECLS
struct disklabel *getdiskbyname(const char *);
__END_DECLS

#endif
@


1.73
log
@Nuke union of d_packname with un_d_boot0 & un_d_boot1, keeping
d_packname as a simple field. Also nuke the access #defines, and
support for b0 and b1 capabilities in disktab.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.72 2015/09/24 19:28:33 krw Exp $	*/
d378 1
d409 1
a409 1
	u_int16_t gp_name[36];	/* partition name, utf-16le */
@


1.72
log
@Move declaration of readdisksector() to disklabel.h. This makes it
available to other areas of the kernel suffering from an overburden
of buf tweaking to read a disk sector.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.71 2015/09/13 15:18:14 krw Exp $	*/
d85 1
a85 19

	/*
	 * d_packname contains the pack identifier and is returned when
	 * the disklabel is read off the disk or in-core copy.
	 * d_boot0 and d_boot1 are the (optional) names of the
	 * primary (block 0) and secondary (block 1-15) bootstraps
	 * as found in /usr/mdec.  These are returned when using
	 * getdiskbyname(3) to retrieve the values from /etc/disktab.
	 */
	union {
		char	un_d_packname[16];	/* pack identifier */
		struct {
			char *un_d_boot0;	/* primary bootstrap name */
			char *un_d_boot1;	/* secondary bootstrap name */
		} un_b;
	} d_un;
#define d_packname	d_un.un_d_packname
#define d_boot0		d_un.un_b.un_d_boot0
#define d_boot1		d_un.un_b.un_d_boot1
@


1.71
log
@Remove unused and incorrect defines GPT_PARTSPERSEC and GPT_SECOFFSET.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.70 2015/09/13 14:38:17 krw Exp $	*/
d539 2
@


1.70
log
@Move prototype for spoofgptlabel() from disklabel.h to subr_disk.c.
It's a helper function for readdoslabel(). Not something called
outside of subr_disk.c.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.69 2015/09/13 12:53:08 krw Exp $	*/
a429 3

#define GPT_PARTSPERSEC(gh)	(DEV_BSIZE / letoh32((gh)->gh_part_size))
#define GPT_SECOFFSET(gh, n)	((gh)->gh_part_size * n)
@


1.69
log
@Rename readgptlabel() to spoofgptlabel() because that's what we
really want it to do. Handle all the actual disklabel reading in
readdoslabel().  Makes the code much simpler to understand.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.68 2015/09/10 16:30:23 krw Exp $	*/
a543 2
int	 spoofgptlabel(struct buf *, void (*)(struct buf *),
	    struct disklabel *);
@


1.68
log
@Now that the GPT code tries really hard not to get in the way and
accidentally capture disks ...

Eliminate kernel option GPT and associated #ifdef GPT/#endif. Let
everybody get on the GPT bandwagon and we'll see what wheels fly
off.

Requested by & ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.67 2015/08/14 23:45:56 krw Exp $	*/
d544 2
a545 2
int	 readgptlabel(struct buf *, void (*)(struct buf *),
	    struct disklabel *, daddr_t *, int);
@


1.67
log
@The disktab attribute 'ty' was used to set D_REMOVEABLE and D_RAMDISK
flags in the disklabel. These flags were discarded in 2006.

Remove documentation for and instances of 'ty'. Add instances of
'dt' that were missing. Use 'floppy' as the value of 'dt' for all
floppies and 'rdroot' for all boot images/miniroots.

Add 'rdroot' to dktypenames and an associated #define DTYPE_RDROOT,
since 'dt' values are parsed by matching entries in dktypenames[].

Slightly tweaked part of larger cleanup diff previously ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.66 2015/07/23 18:02:59 krw Exp $	*/
a543 1
#ifdef GPT
a545 1
#endif
@


1.66
log
@Revert attempted GPT code cleanup. Too much code, too little testing.

Requested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.65 2015/05/09 17:11:26 krw Exp $	*/
d229 1
d248 1
@


1.65
log
@Cleanup/rejig GPT code to be more readable, support different endian
archs and different sized disk sectors. Make MBR have higher priority
than GPT. Add many paranoia checks and associated DPRINTF's to make
further development easier. Keep everything hidden behind #ifdef
GPT.

Tested and ok doug@@ mpi@@. Nothing bad seen by millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.64 2014/08/30 10:44:02 miod Exp $	*/
d390 1
a390 3
#define	GPTPARTITIONS		128
#define	GPTSYSTEM		0x0
#define	GPTIGNORE		0x1
d425 2
d429 3
a446 3
#define GPT_UUID_CHROMEKERNELFS \
    { 0xfe, 0x3a, 0x2a, 0x5d, 0x4f, 0x32, 0x41, 0xa7, \
      0xb7, 0x25, 0xac, 0xcc, 0x32, 0x85, 0xa3, 0x09 }
@


1.64
log
@Recognize EFI protective and system partitions. Do not put disklabel entries
for the protective ones when creating a fake label, but do, for the system
ones, so that we may eventually copy boot code to them.

From Markus Mueller
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.63 2014/07/13 16:50:25 deraadt Exp $	*/
d390 3
a392 1
#define	NGPTPARTITIONS		128
a426 2
	/* the rest of the GPT partition entry, if any, is reserved by UEFI
	   and must be zero */
a428 3
#define GPT_PARTSPERSEC(gh)	(DEV_BSIZE / letoh32((gh)->gh_part_size))
#define GPT_SECOFFSET(gh, n)	((gh)->gh_part_size * n)

d444 3
@


1.63
log
@GPTSIGNATURE must be LL, for operation on non-punk machines
ok punk
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.62 2014/07/13 15:32:28 miod Exp $	*/
d522 2
@


1.62
log
@Initial support to read GPT partition tables in the kernel, if option GPT.
Contributed by Markus Mueller; code based upon Bitrig's GPT support, with
stricter GPT structures validation and support for alternate header places.

ok deraadt@@ jsing@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.61 2014/07/01 05:22:09 dlg Exp $	*/
d387 1
a387 1
#define	GPTSIGNATURE		0x5452415020494645
@


1.61
log
@i removed disksort. we dont need its prototype.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.60 2014/05/05 13:32:15 krw Exp $	*/
d50 2
d385 90
d540 4
@


1.60
log
@Tweak comment on struct _partitionv0. It's no longer the partition
table.

Suggested by David Vasek.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.59 2013/11/10 04:59:06 krw Exp $	*/
a438 1
void	 disksort(struct buf *, struct buf *);
@


1.59
log
@Tweak comments to d_secperunit, p_size and p_offset to clearly say
they are the 'low' parts of the disk size, partition size and
partition offset.  Like d_secpuerunith,  p_sizeh and p_offseth were
already commented as the 'high' parts.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.58 2013/11/03 14:18:55 deraadt Exp $	*/
d150 1
a150 1
struct	__partitionv0 {		/* the partition table */
@


1.58
log
@spelling; frantisek holop
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.57 2013/10/19 09:32:15 krw Exp $	*/
d109 1
a109 1
	u_int32_t d_secperunit;		/* # of data sectors per unit */
d139 2
a140 2
		u_int32_t p_size;	/* number of sectors in partition */
		u_int32_t p_offset;	/* starting sector */
@


1.57
log
@Use daddr_t * instead of int * for the partoffp parameter to
readdoslabel(). Ditto all the MD variables whose addresses are passed
to readdoslabel() via partoffp.

Fix some 512-byte block vs disk sector confusion in hppa and sgi.
All the DL_GETxxxxx() defines return disk sector values. All
DL_SETxxxx() take disk sector values. These changes should be no-ops
until a drive using non-512-byte-sectors is encountered.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.56 2013/09/11 01:42:21 krw Exp $	*/
d46 1
a46 1
 * paritition are machine dependent.
@


1.56
log
@Use u_int64_t instead of daddr_t for the local variables in the
DL_SET* macros. These are sector values, not 512-byte block values.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.55 2013/06/11 16:42:18 deraadt Exp $	*/
d448 1
a448 1
	    struct disklabel *, int *, int);
@


1.55
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.54 2012/04/06 15:10:40 jsing Exp $	*/
d175 1
a175 1
					daddr_t x = (n); \
d181 1
a181 1
					daddr_t x = (n); \
d189 1
a189 1
					daddr_t x = (n); \
d196 1
a196 1
					daddr_t x = (n); \
d203 1
a203 1
					daddr_t x = (n); \
@


1.54
log
@tedu the raidframe.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.52 2011/09/29 18:03:44 miod Exp $	*/
d175 1
a175 1
					daddr64_t x = (n); \
d181 1
a181 1
					daddr64_t x = (n); \
d189 1
a189 1
					daddr64_t x = (n); \
d196 1
a196 1
					daddr64_t x = (n); \
d203 1
a203 1
					daddr64_t x = (n); \
d370 1
a370 1
	daddr64_t df_startblk;
@


1.53
log
@mark ccd(4) deprecated in a few more places
@
text
@d226 1
a226 1
#define DTYPE_RAID		14		/* RAIDframe */
d274 1
a274 1
#define FS_RAID		19		/* RAIDframe */
@


1.52
log
@Remove assembly defines for various struct disklabel field offsets, now that
nothing depends on them anymore.
ok jsing@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.51 2011/06/03 21:14:11 matthew Exp $	*/
d223 1
a223 1
#define	DTYPE_CCD		11		/* concatenated disk device */
d241 1
a241 1
	"ccd",
@


1.51
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.50 2011/03/22 19:26:55 krw Exp $	*/
a160 12

#else /* _LOCORE */
	/*
	 * offsets for asm boot files.
	 */
	.set	d_secsize,40
	.set	d_nsectors,44
	.set	d_ntracks,48
	.set	d_ncylinders,52
	.set	d_secpercyl,56
	.set	d_secperunit,60
	.set	d_end_,404		/* size of disk label */
@


1.50
log
@Increase number of EBRs we can transit looking for the OpenBSD partition
to 256 from 8. 256 ought to be enough for anyone.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.49 2011/03/17 21:44:10 krw Exp $	*/
d458 1
a458 1
int	 bounds_check_with_label(struct buf *, struct disklabel *, int);
@


1.49
log
@Uncommitted bits. Spotted by deraadt@@, who theorizes I have insuffient
sushi level.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.48 2010/04/25 06:15:16 deraadt Exp $	*/
d407 1
a407 1
#define	DOS_MAXEBR	8
@


1.48
log
@introducing a 64-bit type to the disklabel structure leads some architectures
to pad-align the size of the structure; it grows, the disklabel ioctl's are
break ABI.  Change the uid to a character array.  this also simplifies some
other stuff
ok jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.47 2010/04/23 15:25:21 jsing Exp $	*/
d405 3
@


1.47
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.45 2009/06/04 21:13:02 deraadt Exp $	*/
d111 1
a111 1
	u_int64_t d_label_uid;		/* Unique label identifier. */
@


1.46
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d111 2
a112 8
	/*
	 * Spares (bad sector replacements) below are not counted in
	 * d_nsectors or d_secpercyl.  Spare sectors are assumed to
	 * be physical sectors which occupy space at the end of each
	 * track and/or cylinder.
	 */
	u_int16_t d_sparespertrack;	/* # of spare sectors per track */
	u_int16_t d_sparespercyl;	/* # of spare sectors per cylinder */
a119 18
	/*
	 * d_interleave, d_trackskew and d_cylskew describe perturbations
	 * in the media format used to compensate for a slow controller.
	 * Interleave is physical sector interleave, set up by the
	 * formatter or controller when formatting.  When interleaving is
	 * in use, logically adjacent sectors are not physically
	 * contiguous, but instead are separated by some number of
	 * sectors.  It is specified as the ratio of physical sectors
	 * traversed per logical sector.  Thus an interleave of 1:1
	 * implies contiguous layout, while 2:1 implies that logical
	 * sector 0 is separated by one sector from logical sector 1.
	 * d_trackskew is the offset of sector 0 on track N relative to
	 * sector 0 on track N-1 on the same cylinder.  Finally, d_cylskew
	 * is the offset of sector 0 on cylinder N relative to sector 0
	 * on cylinder N-1.
	 */
	u_int16_t d_rpm;		/* rotational speed */
	u_int16_t d_interleave;		/* hardware sector interleave */
@


1.45
log
@Recycle four ancient fields in the disklabel structure, replacing them with
bounds information, ie. the zone of the disk that OpenBSD can use.  Have each
pre-disklabel parser (MBR, DPME, or per-arch MD disklabel parsers) figure out
this area and pass it up to userland.  Then, delete all the same disk parsing
code from disklabel(8) since the kernel passes it up.  Lots and lots of - signs
in the disklabel(8) code.
Tested on as many platforms as possible, the fallout will be repaired as time
goes on.  To test, use disklabel -d <drive> and validate that the bounds do not
overlap any boot blocks.  This same information is used by disklabel -A...
OK for the concept from krw, miod, and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.44 2008/08/10 15:52:50 krw Exp $	*/
d474 2
a475 2
char	*initdisklabel(struct disklabel *);
char	*checkdisklabel(void *, struct disklabel *, u_int64_t, u_int64_t);
d477 1
a477 1
char	*readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *, int);
d480 1
a480 1
char	*readdoslabel(struct buf *, void (*)(struct buf *),
@


1.44
log
@Fix other integer overflow vulnerability I introduced, this time in
DL_BLKOFFSET(). Pointed out by kettenis@@ and deraadt@@.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.43 2008/08/09 19:20:07 kettenis Exp $	*/
d144 4
a147 4
	u_int16_t d_trackskew;		/* sector 0 skew, per track */
	u_int16_t d_cylskew;		/* sector 0 skew, per cylinder */
	u_int32_t d_headswitch;		/* head switch time, usec */
	u_int32_t d_trkseek;		/* track-to-track seek, usec */
a209 4
#define DL_GETPOFFSET(p)	(((u_int64_t)(p)->p_offseth << 32) + (p)->p_offset)
#define DL_GETDSIZE(d)		(((u_int64_t)(d)->d_secperunith << 32) + \
				    (d)->d_secperunit)

d215 1
d221 3
d229 14
d475 1
a475 1
char	*checkdisklabel(void *, struct disklabel *);
@


1.43
log
@Prevent integer overflow in DL_BLKTOSEC().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.42 2008/08/08 23:49:53 krw Exp $	*/
d233 1
a233 1
#define DL_BLKOFFSET(d, n)	(((n) * DEV_BSIZE) % (d)->d_secsize)
@


1.42
log
@Admit b_blkno means block number; a block is DEV_BSIZE (a.k.a.
512) bytes; ffs is inextricably tied to using b_blkno and disklabel
always uses sectorsize units.

Thus use DEV_BSIZE units for all fields describing ffs filesystems
and convert to/from sectors where required. This enables the creation
and use of ffs filesystems on non-512 byte sectorsize devices.

This diff allows i386 and sgi (the two test platforms) to find
disklabels that are not on a sectorsize boundary. Same change to
further archs coming.

This is a no-op on 512-byte sectorsize devices.

This work triggered by jsing@@'s need to create ffs filesystems on
sgi cdroms so we can create cdrom install media for sgi.

sgi testing by jsing@@

ok jsing@@ pedro@@ "looks sane" beck@@ weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.41 2008/01/14 19:02:11 otto Exp $	*/
d232 1
a232 1
#define DL_BLKTOSEC(d, n)	(((n) * DEV_BSIZE) / (d)->d_secsize)
@


1.41
log
@Fix max disk size: whe have 48 bits for size in 512 bytes units.
1 bit allowance to avoid possible sign extend issues for now.
This results in a max partition or disk size of 64PB.  ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.40 2007/11/09 11:32:57 jsing Exp $	*/
d229 5
@


1.40
log
@Make disklabel aware of NTFS.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.39 2007/07/11 04:50:43 miod Exp $	*/
d75 1
a75 1
#define MAXDISKSIZE	0x1fffffffffffLL	/* 47 bits of reach */
@


1.39
log
@Do not divide by zero in DISKLABELV1_FFS_FSIZE if the argument value is bogus;
ok otto@@ millert@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.38 2007/06/20 18:15:47 deraadt Exp $	*/
d434 1
@


1.38
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.37 2007/06/17 00:27:29 deraadt Exp $	*/
d206 1
a206 1
#define DISKLABELV1_FFS_FSIZE(i) ((i) == 0 ? 0 : \
@


1.37
log
@significantly simplified disklabel infrastructure.  MBR handling becomes MI
to support hotplug media on most architectures.  disklabel setup and
verification done using new helper functions.  Disklabels must *always*
have a correct checksum now.  Same code paths are used to learn on-disk
location disklabels, to avoid new errors sneaking in.  Tested on almost all
cases, testing help from todd, kettenis, krw, otto, dlg, robert, gwk, drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.36 2007/06/06 16:42:07 deraadt Exp $	*/
d456 4
a459 8
int	 setdisklabel(struct disklabel *, struct disklabel *, u_int,
	    struct cpu_disklabel *);
char	*readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *, int);
int	 writedisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *);
int	 bounds_check_with_label(struct buf *, struct disklabel *,
	    struct cpu_disklabel *, int);
d461 1
a461 1
	    struct disklabel *, struct cpu_disklabel *, int *, int *, int);
@


1.36
log
@a fair sprinking of knf, code movement, and sometimes character-by-character
accuracy so that the variious disksubr.c's can be compared easier.
setdisklabel() starts taking an int for openmask.
ok krw, and read by quite a few other people
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.35 2007/06/05 00:38:24 deraadt Exp $	*/
d65 1
d356 1
d400 50
d454 2
a455 1
void	 disklabeltokernlabel(struct disklabel *);
d464 2
@


1.35
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.34 2007/06/02 02:35:27 krw Exp $	*/
d403 1
a403 1
int	 setdisklabel(struct disklabel *, struct disklabel *, u_long,
@


1.34
log
@Rename cvtdisklabelv1 -> disklabeltokernlabel. It does more than just
convert version 0 to version 1 disklabels.

Suggested by deraadt@@.

ok deraadt@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.33 2007/06/01 18:09:52 deraadt Exp $	*/
d74 2
d208 20
a227 4
#define DL_PSIZE(p)	(((u_int64_t)(p)->p_sizeh << 32) + (p)->p_size)
#define DL_POFFSET(p)	(((u_int64_t)(p)->p_offseth << 32) + (p)->p_offset)
#define DL_DSIZE(d)	(((u_int64_t)(d)->d_secperunith << 32) + (d)->d_secperunit)

@


1.33
log
@format_op df_startblk can be a daddr64_t too
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.32 2007/05/31 03:19:19 otto Exp $	*/
d384 1
a384 1
void	 cvtdisklabelv1(struct disklabel *);
@


1.32
log
@oops, typo
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.31 2007/05/31 02:33:37 otto Exp $	*/
d367 1
a367 1
	daddr_t	 df_startblk;
@


1.31
log
@macros to get the large sizes and offsets from a v1 label. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.30 2007/05/29 16:26:53 thib Exp $	*/
d208 1
a208 1
#define DL_DSIZE(d)	(((u_int64_t)(d)->d_secperunith << 32) + (d)->d_secperun
@


1.30
log
@Collapse the __partition_u1 union in struct disklabel,
keep p_cpg around since its need. remove p_sgs.

ok otto@@,krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.29 2007/05/29 06:28:14 otto Exp $	*/
d205 4
@


1.29
log
@Updated disklabel format to support larger disks and partitions. We
free room in struct partition by packing fragment size and
fragments/block more tighlty and use the resulting space to make
offset and size 48 bits.  For the disk part we use spare fields in
struct disklabel.  Kernel converts in-mem copy of the on-disk
label if needed, disklabel(8) writes new version.
We are careful to only change fields not used by bootloaders.
Conception of basic scheme by deraadt.
ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.28 2006/09/26 23:33:04 krw Exp $	*/
d166 1
a166 6
		union {
			u_int16_t cpg;	/* UFS: FS cylinders per group */
			u_int16_t sgs;	/* LFS: FS segment shift */
		} __partition_u1;
#define	p_cpg	__partition_u1.cpg
#define	p_sgs	__partition_u1.sgs
@


1.28
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.27 2006/09/24 20:29:52 krw Exp $	*/
d148 3
a150 1
#define NSPARE 5
d162 2
a163 1
		u_int32_t p_fsize;	/* filesystem basic fragment size */
d165 1
a165 1
		u_int8_t p_frag;	/* filesystem fragments per block */
d174 14
d201 11
d385 1
@


1.27
log
@Eliminate D_CHAIN, D_ECC and D_RAMDISK flags from disklabel. They were
not being used in the tree for anything obviously useful. Get it done
early so we can find if there are non-obvious uses out there.

ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.26 2005/03/29 16:30:21 deraadt Exp $	*/
a308 1
#define		D_REMOVABLE	0x01		/* removable media */
@


1.26
log
@udf_disklabelspoof() proto
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.25 2005/03/28 21:26:19 deraadt Exp $	*/
a309 1
#define		D_ECC		0x02		/* supports ECC */
a310 2
#define		D_RAMDISK	0x08		/* disk emulator */
#define		D_CHAIN		0x10		/* can do back-back transfers */
@


1.25
log
@p_fstype FS_UDF or #21
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.24 2004/01/23 19:36:25 millert Exp $	*/
d371 4
@


1.24
log
@Add NTFS; deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.23 2003/06/02 23:28:21 millert Exp $	*/
d247 1
d272 1
d299 1
@


1.23
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.22 2002/03/14 03:16:12 millert Exp $	*/
d246 1
d270 1
d296 1
@


1.22
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.21 2002/03/14 01:27:14 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.20 2000/11/25 21:32:05 hugh Exp $	*/
d361 4
a364 4
char	*readdisklabel __P((dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *, int));
int	 writedisklabel __P((dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *));
d368 2
a369 2
int iso_disklabelspoof __P((dev_t dev, void (*strat)(struct buf *),
	struct disklabel *lp));
@


1.20
log
@Change d_end_ to relect the 16 slice struct disklabel OpenBSD uses.
Looks like only vax cares about this.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.19 2000/08/08 16:03:16 peter Exp $	*/
d356 5
a360 6
void	 diskerr
	    __P((struct buf *, char *, char *, int, int, struct disklabel *));
void	 disksort __P((struct buf *, struct buf *));
u_int	 dkcksum __P((struct disklabel *));
int	 setdisklabel __P((struct disklabel *, struct disklabel *, u_long,
	    struct cpu_disklabel *));
d365 2
a366 2
int	 bounds_check_with_label __P((struct buf *, struct disklabel *,
	    struct cpu_disklabel *, int));
d368 1
a368 1
int iso_disklabelspoof __P((dev_t dev, void (*strat) __P((struct buf *)),
d379 1
a379 1
struct disklabel *getdiskbyname __P((const char *));
@


1.20.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.20 2000/11/25 21:32:05 hugh Exp $	*/
d356 12
a367 11
void	 diskerr(struct buf *, char *, char *, int, int, struct disklabel *);
void	 disksort(struct buf *, struct buf *);
u_int	 dkcksum(struct disklabel *);
int	 setdisklabel(struct disklabel *, struct disklabel *, u_long,
	    struct cpu_disklabel *);
char	*readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *, int);
int	 writedisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *);
int	 bounds_check_with_label(struct buf *, struct disklabel *,
	    struct cpu_disklabel *, int);
d369 2
a370 2
int iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	struct disklabel *lp);
d380 1
a380 1
struct disklabel *getdiskbyname(const char *);
@


1.19
log
@add a 'RAID' filesystem type for RAIDframe updates - coming next
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.18 2000/04/07 13:53:40 deraadt Exp $	*/
d185 1
a185 1
	.set	d_end_,276		/* size of disk label */
@


1.18
log
@add DISKMINOR(), and repair redefinitions
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.17 1999/01/11 10:23:42 niklas Exp $	*/
d249 1
d272 1
d297 1
@


1.17
log
@Add ATAPI and RAID types, compatibility with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.16 1998/10/03 21:19:01 millert Exp $	*/
d69 2
d72 3
a74 2
    (makedev((maj), ((unit) * MAXPARTITIONS) + (part)))
#define	DISKLABELDEV(dev)     (MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART))
@


1.17.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.20 2000/11/25 21:32:05 hugh Exp $	*/
a68 2
#define	DISKMINOR(unit, part) \
    (((unit) * MAXPARTITIONS) + (part))
d70 2
a71 3
    (makedev((maj), DISKMINOR((unit), (part))))
#define	DISKLABELDEV(dev) \
    (MAKEDISKDEV(major(dev), DISKUNIT(dev), RAW_PART))
d182 1
a182 1
	.set	d_end_,404		/* size of disk label */
a245 1
#define FS_RAID		19		/* RAIDframe */
a267 1
	"RAID",
a291 1
	"",		/* 19 */
@


1.17.6.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d356 12
a367 11
void	 diskerr(struct buf *, char *, char *, int, int, struct disklabel *);
void	 disksort(struct buf *, struct buf *);
u_int	 dkcksum(struct disklabel *);
int	 setdisklabel(struct disklabel *, struct disklabel *, u_long,
	    struct cpu_disklabel *);
char	*readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *, int);
int	 writedisklabel(dev_t, void (*)(struct buf *), struct disklabel *,
	    struct cpu_disklabel *);
int	 bounds_check_with_label(struct buf *, struct disklabel *,
	    struct cpu_disklabel *, int);
d369 2
a370 2
int iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	struct disklabel *lp);
d380 1
a380 1
struct disklabel *getdiskbyname(const char *);
@


1.17.6.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.17.6.2 2002/03/28 14:52:01 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.6.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a245 1
#define FS_NTFS		20		/* Windows/NT file system */
a268 1
	"NTFS",
a293 1
	"ntfs",		/* 20 */
@


1.16
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.15 1998/05/17 03:09:39 mickey Exp $	*/
d197 2
d215 2
@


1.15
log
@define DISKLABELDEV(dev) macro
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.14 1998/02/06 22:17:18 deraadt Exp $	*/
d353 1
a353 1
	    struct cpu_disklabel *));
@


1.14
log
@add FS_CCD, make ccd prefer such partitions. It still accespts FS_BSDFFS, and something will change about that soon
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.13 1997/08/08 21:47:06 niklas Exp $	*/
d71 1
@


1.13
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.12 1997/05/31 06:17:10 deraadt Exp $	*/
d240 1
d262 1
d286 1
@


1.12
log
@kill spaces in fstypenames[] entries; abs@@mono.org
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.11 1996/12/05 13:08:47 deraadt Exp $	*/
d352 2
a353 1
int	 bounds_check_with_label __P((struct buf *, struct disklabel *, int));
@


1.11
log
@proto iso_disklabelspoof() inside an #ifdef (no nicer place)
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.10 1996/12/03 01:06:50 downsj Exp $	*/
d245 3
a247 3
	"Version 6",
	"Version 7",
	"System V",
d249 1
a249 1
	"Eighth Edition",
@


1.10
log
@Add readlabelfs()'s table, a shorter form of fstypenames.
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.9 1996/11/06 01:36:54 deraadt Exp $	*/
d353 4
@


1.9
log
@FS_EXT2FS
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.8 1996/05/22 11:40:49 deraadt Exp $	*/
d241 1
a241 1
#ifdef	DKTYPENAMES
d263 24
@


1.8
log
@acorn filesystem addition
@
text
@d1 1
a1 1
/*	$OpenBSD: disklabel.h,v 1.6 1996/04/21 22:31:42 deraadt Exp $	*/
d239 1
d260 1
@


1.7
log
@proto more stuff
@
text
@d2 1
a2 1
/*	$NetBSD: disklabel.h,v 1.40 1996/04/22 01:23:13 christos Exp $	*/
d238 1
d258 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: disklabel.h,v 1.5 1996/03/19 21:10:47 mickey Exp $	*/
/*	$NetBSD: disklabel.h,v 1.39 1996/04/09 20:55:26 cgd Exp $	*/
d324 1
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 2
a2 2
/*	$OpenBSD: disklabel.h,v 1.4 1996/03/03 12:11:33 niklas Exp $	*/
/*	$NetBSD: disklabel.h,v 1.38 1996/02/09 18:25:05 christos Exp $	*/
d81 1
a81 1
	/* 
d90 1
a90 1
		char	un_d_packname[16];	/* pack identifier */ 
d94 2
a95 2
		} un_b; 
	} d_un; 
@


1.4
log
@From NetBSD: 960217 merge
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
#ifndef LOCORE
d171 1
a171 1
#else /* LOCORE */
d182 1
a182 1
#endif /* LOCORE */
d291 1
a291 1
#ifndef LOCORE
d325 1
a325 1
#endif /* LOCORE */
d327 1
a327 1
#if !defined(_KERNEL) && !defined(LOCORE)
@


1.3
log
@Not ready for LOCORE -> _LOCORE.
@
text
@d1 1
@


1.2
log
@Merge in changes from NetBSD:
- Filesystem prototype changes
- LOCORE -> _LOCORE
- Move disk-specific ioctls out of <sys/disklabel.h> and into <sys/dkio.h>.
  <sys/dkio.h> is in turn included by <sys/ioctl.h>, much like how
  <sys/filio.h> and <sys/sockio.h> are handled.  This minimizes changes to
  existing sources which use the disk ioctls.
  Define DIOCLOCK which is used to lock and unlock the pack.
@
text
@d73 1
a73 1
#ifndef _LOCORE
d170 1
a170 1
#else /* _LOCORE */
d181 1
a181 1
#endif /* _LOCORE */
d290 1
a290 1
#ifndef _LOCORE
d324 1
a324 1
#endif /* _LOCORE */
d326 1
a326 1
#if !defined(_KERNEL) && !defined(_LOCORE)
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: disklabel.h,v 1.35 1995/10/09 12:00:18 pk Exp $	*/
d73 1
a73 1
#ifndef LOCORE
d170 1
a170 1
#else /* LOCORE */
d181 1
a181 1
#endif /* LOCORE */
d290 1
a290 1
#ifndef LOCORE
a311 20
/*
 * Disk-specific ioctls.
 */
		/* get and set disklabel; DIOCGPART used internally */
#define DIOCGDINFO	_IOR('d', 101, struct disklabel)/* get */
#define DIOCSDINFO	_IOW('d', 102, struct disklabel)/* set */
#define DIOCWDINFO	_IOW('d', 103, struct disklabel)/* set, update disk */
#define DIOCGPART	_IOW('d', 104, struct partinfo)	/* get partition */

/* do format operation, read or write */
#define DIOCRFORMAT	_IOWR('d', 105, struct format_op)
#define DIOCWFORMAT	_IOWR('d', 106, struct format_op)

#define DIOCSSTEP	_IOW('d', 107, int)	/* set step rate */
#define DIOCSRETRIES	_IOW('d', 108, int)	/* set # of retries */
#define DIOCWLABEL	_IOW('d', 109, int)	/* write en/disable label */

#define DIOCSBAD	_IOW('d', 110, struct dkbad)	/* set kernel dkbad */
#define DIOCEJECT	_IO('d', 112)		/* Eject removable disk */

d319 1
a319 1
char	*readdisklabel __P((dev_t, void (*)(), struct disklabel *,
d321 1
a321 1
int	 writedisklabel __P((dev_t, void (*)(), struct disklabel *,
d324 1
a324 1
#endif /* LOCORE */
d326 1
a326 1
#if !defined(_KERNEL) && !defined(LOCORE)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
