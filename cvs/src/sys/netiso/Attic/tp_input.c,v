head	1.9;
access;
symbols
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.9
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.8;

1.8
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.47;	author deraadt;	state Exp;
branches
	1.3.16.1
	1.3.26.1;
next	1.2;

1.2
date	96.03.04.10.36.02;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.3.26.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: tp_input.c,v 1.8 2004/01/03 14:08:54 espie Exp $	*/
/*	$NetBSD: tp_input.c,v 1.9 1996/03/16 23:13:51 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tp_input.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 * tp_input() gets an mbuf chain from ip.  Actually, not directly from ip,
 * because ip calls a net-level routine that strips off the net header and
 * then calls tp_input(), passing the proper type of addresses for the
 * address family in use (how it figures out which AF is not yet determined.)
 *
 * Decomposing the tpdu is some of the most laughable code.  The variable-length
 * parameters and the problem of non-aligned memory references necessitates
 * such abominations as the macros WHILE_OPTIONS (q.v. below) to loop through
 * the header and decompose it.
 *
 * The routine tp_newsocket() is called when a CR comes in for a listening
 * socket.  tp_input calls sonewconn() and tp_newsocket() to set up the
 * "child" socket.  Most tpcb values are copied from the parent tpcb into the
 * child.
 *
 * Also in here is tp_headersize() (grot) which tells the expected size of a tp
 * header, to be used by other layers.  It's in here because it uses the
 * static structure tpdu_info.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>

#include <net/if.h>

#include <netiso/iso.h>
#include <netiso/iso_errno.h>
#include <netiso/iso_pcb.h>
#include <netiso/tp_param.h>
#include <netiso/tp_timer.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_pcb.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_trace.h>
#include <netiso/tp_tpdu.h>
#include <netiso/tp_var.h>
#include <netiso/iso_var.h>

#ifdef TRUE
#undef FALSE
#undef TRUE
#endif
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>

#include <sys/stdarg.h>

static struct socket *tp_newsocket(struct socket *, struct sockaddr *,
					caddr_t, u_int, u_int);

struct mbuf    *
tp_inputprep(m)
	struct mbuf *m;
{
	int             hdrlen;

#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_inputprep: m %p\n", m);
	}
#endif

	while (m->m_len < 1) {
		/*
		 * The "m_free" logic if( (m = m_free(m)) == MNULL ) return
		 * (struct mbuf *)0; would cause a system crash if ever
		 * executed. This logic will be executed if the first mbuf in
		 * the chain only contains a CLNP header. The m_free routine
		 * will release the mbuf containing the CLNP header from the
		 * chain and the new head of the chain will not have the
		 * M_PKTHDR bit set. This routine, tp_inputprep, will
		 * eventually call the "sbappendaddr" routine. "sbappendaddr"
		 * calls "panic" if M_PKTHDR is not set. m_pullup is a cheap
		 * way of keeping the head of the chain from being freed.
		 */
		if ((m = m_pullup(m, 1)) == MNULL)
			return (MNULL);
	}
	if (((long) m->m_data) & 0x3) {
		/*
		 * If we are not 4-byte aligned, we have to be above the
		 * beginning of the mbuf, and it is ok just to slide it back.
		 */
		caddr_t         ocp = m->m_data;

		m->m_data = (caddr_t) (((long) m->m_data) & ~0x3);
		bcopy(ocp, m->m_data, (unsigned) m->m_len);
	}
	CHANGE_MTYPE(m, TPMT_DATA);

	/*
	 * we KNOW that there is at least 1 byte in this mbuf and that it is
	 * hdr->tpdu_li XXXXXXX!
	 */

	hdrlen = 1 + *mtod(m, u_char *);

	/*
	 * now pull up the whole tp header
	 */
	if (m->m_len < hdrlen) {
		if ((m = m_pullup(m, hdrlen)) == MNULL) {
			IncStat(ts_recv_drop);
			return (struct mbuf *) 0;
		}
	}
#ifdef ARGO_DEBUG
	if (argo_debug[D_INPUT]) {
		printf(
		       " at end: m %p hdr->tpdu_li 0x%x m_len 0x%x\n", m,
		       hdrlen, m->m_len);
	}
#endif
	return m;
}

/*
 * begin groan -- this array and the following macros allow you to step
 * through the parameters of the variable part of a header note that if for
 * any reason the values of the **_TPDU macros (in tp_events.h) should
 * change, this array has to be rearranged
 */

#define TP_LEN_CLASS_0_INDEX	2
#define TP_MAX_DATA_INDEX 3

static u_char   tpdu_info[][4] =
{
	/* length						 max data len */
	/* reg fmt 	xtd fmt  class 0  		 	  */
	/* UNUSED		0x0 */ { 0x0, 0x0, 0x0, 0x0		},
	/* XPD_TPDU_type	0x1 */ { 0x5, 0x8, 0x0, TP_MAX_XPD_DATA	},
	/* XAK_TPDU_type	0x2 */ { 0x5, 0x8, 0x0, 0x0		},
	/* GR_TPDU_type		0x3 */ { 0x0, 0x0, 0x0, 0x0		},
	/* UNUSED		0x4 */ { 0x0, 0x0, 0x0, 0x0		},
	/* UNUSED		0x5 */ { 0x0, 0x0, 0x0, 0x0		},
	/* AK_TPDU_type		0x6 */ { 0x5, 0xa, 0x0, 0x0		},
	/* ER_TPDU_type		0x7 */ { 0x5, 0x5, 0x0, 0x0		},
	/* DR_TPDU_type		0x8 */ { 0x7, 0x7, 0x7, TP_MAX_DR_DATA	},
	/* UNUSED		0x9 */ { 0x0, 0x0, 0x0, 0x0		},
	/* UNUSED		0xa */ { 0x0, 0x0, 0x0, 0x0		},
	/* UNUSED		0xb */ { 0x0, 0x0, 0x0, 0x0		},
	/* DC_TPDU_type		0xc */ { 0x6, 0x6, 0x0, 0x0		},
	/* CC_TPDU_type		0xd */ { 0x7, 0x7, 0x7, TP_MAX_CC_DATA	},
	/* CR_TPDU_type		0xe */ { 0x7, 0x7, 0x7, TP_MAX_CR_DATA	},
	/* DT_TPDU_type		0xf */ { 0x5, 0x8, 0x3, 0x0		},
};

#define CHECK(Phrase, Erval, Stat, Whattodo, Loc)\
	if (Phrase) {error = (Erval); errlen = (int)(Loc); IncStat(Stat);\
	goto Whattodo; }

/*
 * WHENEVER YOU USE THE FOLLOWING MACRO, BE SURE THE TPDUTYPE IS A LEGIT
 * VALUE FIRST!
 */

#define WHILE_OPTIONS(P, hdr, format)\
{	caddr_t P = tpdu_info[(hdr)->tpdu_type][(format)] + (caddr_t)hdr;\
	caddr_t PLIM = 1 + hdr->tpdu_li + (caddr_t)hdr;\
	for (;; P += 2 + ((struct tp_vbp *)P)->tpv_len) {\
		CHECK((P > PLIM), E_TP_LENGTH_INVAL, ts_inv_length,\
				respond, P - (caddr_t)hdr);\
		if (P == PLIM) break;

#define END_WHILE_OPTIONS(P) } }

/* end groan */

/*
 * NAME:  tp_newsocket()
 *
 * CALLED FROM:
 *  tp_input() on incoming CR, when a socket w/ the called suffix
 * is awaiting a  connection request
 *
 * FUNCTION and ARGUMENTS:
 *  Create a new socket structure, attach to it a new transport pcb,
 *  using a copy of the net level pcb for the parent socket.
 *  (so) is the parent socket.
 *  (fname) is the foreign address (all that's used is the nsap portion)
 *
 * RETURN VALUE:
 *  a new socket structure, being this end of the newly formed connection.
 *
 * SIDE EFFECTS:
 *  Sets a few things in the tpcb and net level pcb
 *
 * NOTES:
 */
static struct socket *
tp_newsocket(so, fname, cons_channel, class_to_use, netservice)
	struct socket  *so;
	struct sockaddr *fname;
	caddr_t         cons_channel;
	u_int          class_to_use;
	u_int           netservice;
{
	struct tp_pcb *tpcb = sototpcb(so);	/* old tpcb, needed
							 * below */
	struct tp_pcb *newtpcb;

	/*
	 * sonewconn() gets a new socket structure, a new lower layer pcb and
	 * a new tpcb, but the pcbs are unnamed (not bound)
	 */
#ifdef TPPT
	if (tp_traceflags[D_NEWSOCK]) {
		tptraceTPCB(TPPTmisc, "newsock: listg_so, _tpcb, so_head",
			    so, tpcb, so->so_head, 0);
	}
#endif

	if ((so = sonewconn(so, SS_ISCONFIRMING)) == (struct socket *) 0)
		return so;
#ifdef TPPT
	if (tp_traceflags[D_NEWSOCK]) {
		tptraceTPCB(TPPTmisc, "newsock: after newconn so, so_head",
			    so, so->so_head, 0, 0);
	}
#endif

#ifdef ARGO_DEBUG
	if (argo_debug[D_NEWSOCK]) {
		printf("tp_newsocket(channel %p)  after sonewconn so %p \n",
		       cons_channel, so);
		dump_addr(fname);
		{
			struct socket  *t, *head;

			head = so->so_head;
			t = so;
			printf("so %p so_head %p so_q0 %p, q0len %d\n",
			       t, t->so_head, t->so_q0, t->so_q0len);
			while ((t = t->so_q0) && t != so && t != head)
				printf("so %p so_head %p so_q0 %p, q0len %d\n",
				       t, t->so_head, t->so_q0, t->so_q0len);
		}
	}
#endif

	/*
	 * before we clobber the old tpcb ptr, get these items from the
	 * parent pcb
	 */
	newtpcb = sototpcb(so);
	newtpcb->_tp_param = tpcb->_tp_param;
	newtpcb->tp_flags = tpcb->tp_flags;
	newtpcb->tp_lcredit = tpcb->tp_lcredit;
	newtpcb->tp_l_tpdusize = tpcb->tp_l_tpdusize;
	newtpcb->tp_lsuffixlen = tpcb->tp_lsuffixlen;
	bcopy(tpcb->tp_lsuffix, newtpcb->tp_lsuffix, newtpcb->tp_lsuffixlen);

	if ( /* old */ tpcb->tp_ucddata) {
		/*
		 * These data are the connect- , confirm- or disconnect-
		 * data.
		 */
		struct mbuf    *conndata;

		conndata = m_copy(tpcb->tp_ucddata, 0, (int) M_COPYALL);
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
			dump_mbuf(conndata, "conndata after mcopy");
		}
#endif
		newtpcb->tp_ucddata = conndata;
	}
	tpcb = newtpcb;
	tpcb->tp_state = TP_LISTENING;
	tpcb->tp_class = class_to_use;
	tpcb->tp_netservice = netservice;


	ASSERT(fname != 0);	/* just checking */
	if (fname) {
		/*
		 *	tp_route_to takes its address argument in the form of an mbuf.
		 */
		struct mbuf    *m;
		int             err;

		MGET(m, M_DONTWAIT, MT_SONAME);	/* mbuf type used is
						 * confusing */
		if (m) {
			/*
			 * this seems a bit grotesque, but tp_route_to expects
			 * an mbuf * instead of simply a sockaddr; it calls the ll
			 * pcb_connect, which expects the name/addr in an mbuf as well.
			 * sigh.
			 */
			bcopy((caddr_t) fname, mtod(m, caddr_t), fname->sa_len);
			m->m_len = fname->sa_len;

			/*
			 * grot  : have to say the kernel can override params
			 * in the passive open case
			 */
			tpcb->tp_dont_change_params = 0;
			err = tp_route_to(m, tpcb, cons_channel);
			m_free(m);

			if (!err)
				goto ok;
		}
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
			printf("tp_route_to FAILED! detaching tpcb %p, so %p\n",
			       tpcb, so);
		}
#endif
		(void) tp_detach(tpcb);
		return 0;
	}
ok:
#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_newsocket returning so %p, sototpcb(so) %p\n",
		       so, sototpcb(so));
	}
#endif
	return so;
}

/*
 * NAME: 	tp_input()
 *
 * CALLED FROM: net layer input routine
 *
 * FUNCTION and ARGUMENTS: Process an incoming TPDU (m), finding the associated
 * tpcb if there is one. Create the appropriate type of event and call the
 * driver. (faddr) and (laddr) are the foreign and local addresses.
 *
 * When tp_input() is called we KNOW that the ENTIRE TP HEADER has been
 * m_pullup-ed.
 *
 * RETURN VALUE: Nada
 *
 * SIDE EFFECTS: When using COSNS it may affect the state of the net-level pcb
 *
 * NOTE: The initial value of acktime is 2 so that we will never have a 0 value
 * for tp_peer_acktime.  It gets used in the computation of the
 * retransmission timer value, and so it mustn't be zero. 2 seems like a
 * reasonable minimum.
 */
void
tp_input(struct mbuf *m, ...)
{
	struct sockaddr *faddr, *laddr;	/* NSAP addresses */
	caddr_t         cons_channel;
	int             (*dgout_routine)(struct mbuf *, ...);
	int             ce_bit;
	struct tp_pcb *tpcb;
	struct tpdu *hdr;
	struct socket  *so;
	struct tp_event e;
	int             error;
	unsigned        dutype;
	u_short         dref, sref, acktime, subseq;
	u_char          preferred_class, class_to_use, pdusize;
	u_char          opt, dusize, addlopt, version = 0;
#ifdef TP_PERF_MEAS
	u_char          perf_meas;
#endif				/* TP_PERF_MEAS */
	u_char          fsufxlen, lsufxlen;
	caddr_t         fsufxloc, lsufxloc;
	int             tpdu_len;
	u_int           takes_data;
	u_int           fcc_present;
	int             errlen;
	struct tp_conn_param tpp;
	va_list		ap;

	va_start(ap, m);
	faddr = va_arg(ap, struct sockaddr *);
	laddr = va_arg(ap, struct sockaddr *);
	cons_channel = va_arg(ap, caddr_t);
	/* XXX: Does va_arg does not work for function ptrs */
	dgout_routine = (int (*)(struct mbuf *, ...)) va_arg(ap, void *);
	ce_bit = va_arg(ap, int);
	va_end(ap);

again:
	hdr = mtod(m, struct tpdu *);
	tpcb = 0;
	error = errlen = tpdu_len = 0;
	takes_data = fcc_present = FALSE;
	acktime = 2;
	sref = subseq = 0;
	fsufxloc = lsufxloc = NULL;
	fsufxlen = lsufxlen =
		preferred_class = class_to_use = pdusize = addlopt = 0;
	dusize = TP_DFL_TPDUSIZE;
#ifdef TP_PERF_MEAS
	GET_CUR_TIME(&e.e_time);
	perf_meas = 0;
#endif				/* TP_PERF_MEAS */

#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_input(%p, ... %p)\n", m, cons_channel);
	}
#endif


	/*
	 * get the actual tpdu length - necessary for monitoring and for
	 * checksumming
	 *
	 * Also, maybe measure the mbuf chain lengths and sizes.
	 */

	{
		struct mbuf *n = m;
#ifdef ARGO_DEBUG
		int             chain_length = 0;
#endif				/* ARGO_DEBUG */

		for (;;) {
			tpdu_len += n->m_len;
#ifdef ARGO_DEBUG
			if (argo_debug[D_MBUF_MEAS]) {
				if (n->m_flags & M_EXT) {
					IncStat(ts_mb_cluster);
				} else {
					IncStat(ts_mb_small);
				}
				chain_length++;
			}
#endif
			if (n->m_next == MNULL) {
				break;
			}
			n = n->m_next;
		}
#ifdef ARGO_DEBUG
		if (argo_debug[D_MBUF_MEAS]) {
			if (chain_length > 16)
				chain_length = 0;	/* zero used for
							 * anything > 16 */
			tp_stat.ts_mb_len_distr[chain_length]++;
		}
#endif
	}
#ifdef TPPT
	if (tp_traceflags[D_TPINPUT]) {
		tptraceTPCB(TPPTtpduin, hdr->tpdu_type, hdr, hdr->tpdu_li + 1,
			    tpdu_len, 0);
	}
#endif

		dref = ntohs((short) hdr->tpdu_dref);
	sref = ntohs((short) hdr->tpdu_sref);
	dutype = (int) hdr->tpdu_type;

#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("input: dutype 0x%x cons_channel %p dref 0x%x\n",
		    dutype, cons_channel, dref);
		printf("input: dref 0x%x sref 0x%x\n", dref, sref);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_TPINPUT]) {
		tptrace(TPPTmisc, "channel dutype dref ",
			cons_channel, dutype, dref, 0);
	}
#endif


#ifdef ARGO_DEBUG
	if ((dutype < TP_MIN_TPDUTYPE) || (dutype > TP_MAX_TPDUTYPE)) {
		printf("BAD dutype! 0x%x, channel %p dref 0x%x\n",
		       dutype, cons_channel, dref);
		dump_buf(m, sizeof(struct mbuf));

		IncStat(ts_inv_dutype);
		goto discard;
	}
#endif				/* ARGO_DEBUG */

	CHECK((dutype < TP_MIN_TPDUTYPE || dutype > TP_MAX_TPDUTYPE),
	      E_TP_INV_TPDU, ts_inv_dutype, respond,
	      2);
	/*
	 * unfortunately we can't take the address of the tpdu_type field,
	 * since it's a bit field - so we just use the constant offset 2
	 */

	/*
	 * Now this isn't very neat but since you locate a pcb one way at the
	 * beginning of connection establishment, and by the dref for each
	 * tpdu after that, we have to treat CRs differently
	 */
	if (dutype == CR_TPDU_type) {
		u_char          alt_classes = 0;

		preferred_class = 1 << hdr->tpdu_CRclass;
		opt = hdr->tpdu_CRoptions;

		WHILE_OPTIONS(P, hdr, 1)	/* { */
			switch (vbptr(P)->tpv_code) {

		case TPP_tpdu_size:
			vb_getval(P, u_char, dusize);
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CR dusize 0x%x\n", dusize);
			}
#endif
			/* COS tests: NBS IA (Dec. 1987) Sec. 4.5.2.1 */
			if (dusize < TP_MIN_TPDUSIZE || dusize > TP_MAX_TPDUSIZE)
				dusize = TP_DFL_TPDUSIZE;
			break;
		case TPP_ptpdu_size:
			switch (vbptr(P)->tpv_len) {
			case 1:
				pdusize = vbval(P, u_char);
				break;
			case 2:
				pdusize = ntohs(vbval(P, u_short));
				break;
			default:;
#ifdef ARGO_DEBUG
				if (argo_debug[D_TPINPUT]) {
					printf("malformed prefered TPDU option\n");
				}
#endif
			}
			break;
		case TPP_addl_opt:
			vb_getval(P, u_char, addlopt);
			break;
		case TPP_calling_sufx:
			/*
			 * could use vb_getval, but we want to save the loc &
			 * len for later use
			 */
			fsufxloc = (caddr_t) & vbptr(P)->tpv_val;
			fsufxlen = vbptr(P)->tpv_len;
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CR fsufx:");
				{
					int    j;
					for (j = 0; j < fsufxlen; j++) {
						printf(" 0x%x. ", *((caddr_t) (fsufxloc + j)));
					}
					printf("\n");
				}
			}
#endif
			break;
		case TPP_called_sufx:
			/*
			 * could use vb_getval, but we want to save the loc &
			 * len for later use
			 */
			lsufxloc = (caddr_t) & vbptr(P)->tpv_val;
			lsufxlen = vbptr(P)->tpv_len;
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CR lsufx:");
				{
					int    j;
					for (j = 0; j < lsufxlen; j++) {
						printf(" 0x%x. ", *((u_char *) (lsufxloc + j)));
					}
					printf("\n");
				}
			}
#endif
			break;

#ifdef TP_PERF_MEAS
		case TPP_perf_meas:
			vb_getval(P, u_char, perf_meas);
			break;
#endif				/* TP_PERF_MEAS */

		case TPP_vers:
			/* not in class 0; 1 octet; in CR_TPDU only */
			/*
			 * COS tests says if version wrong, use default
			 * version!?XXX
			 */
			CHECK((vbval(P, u_char) != TP_VERSION),
			      E_TP_INV_PVAL, ts_inv_pval, setversion,
			(1 + (caddr_t) & vbptr(P)->tpv_val - (caddr_t) hdr));
	setversion:
			version = vbval(P, u_char);
			break;
		case TPP_acktime:
			vb_getval(P, u_short, acktime);
			acktime = ntohs(acktime);
			acktime = acktime / 500;	/* convert to slowtimo
							 * ticks */
			if ((short) acktime <= 0)
				acktime = 2;	/* don't allow a bad peer to
						 * screw us up */
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CR acktime 0x%x\n", acktime);
			}
#endif
			break;

		case TPP_alt_class:
			{
				u_char         *aclass = 0;
				int    i;
				static u_char   bad_alt_classes[5] =
				{~0, ~3, ~5, ~0xf, ~0x1f};

				aclass =
					(u_char *) & (((struct tp_vbp *) P)->tpv_val);
				for (i = ((struct tp_vbp *) P)->tpv_len; i > 0; i--) {
					alt_classes |= (1 << ((*aclass++) >> 4));
				}
				CHECK((bad_alt_classes[hdr->tpdu_CRclass] & alt_classes),
				      E_TP_INV_PVAL, ts_inv_aclass, respond,
				      ((caddr_t) aclass) - (caddr_t) hdr);
#ifdef ARGO_DEBUG
				if (argo_debug[D_TPINPUT]) {
					printf("alt_classes 0x%x\n", alt_classes);
				}
#endif
			}
			break;

		case TPP_security:
		case TPP_residER:
		case TPP_priority:
		case TPP_transdelay:
		case TPP_throughput:
		case TPP_addl_info:
		case TPP_subseq:
		default:
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("param ignored CR_TPDU code= 0x%x\n",
				       vbptr(P)->tpv_code);
			}
#endif
			IncStat(ts_param_ignored);
			break;

		case TPP_checksum:
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CR before cksum\n");
			}
#endif

			CHECK(iso_check_csum(m, tpdu_len),
			      E_TP_INV_PVAL, ts_bad_csum, discard, 0)
#ifdef ARGO_DEBUG
				if (argo_debug[D_TPINPUT]) {
				printf("CR before cksum\n");
			}
#endif
			break;
		}

		 /* } */ END_WHILE_OPTIONS(P)
			if (lsufxlen == 0) {
			/* can't look for a tpcb w/o any called sufx */
			error = E_TP_LENGTH_INVAL;
			IncStat(ts_inv_sufx);
			goto respond;
		} else {
			struct tp_pcb *t;
			/*
			 * The intention here is to trap all CR requests
			 * to a given nsap, for constructing transport
			 * service bridges at user level; so these
			 * intercepts should precede the normal listens.
			 * Phrasing the logic in this way also allows for
			 * mop-up listeners, which we don't currently implement.
			 * We also wish to have a single socket be able to
			 * listen over any network service provider,
			 * (cons or clns or ip).
			 */
			for (t = tp_listeners; t; t = t->tp_nextlisten)
				if ((t->tp_lsuffixlen == 0 ||
				     (lsufxlen == t->tp_lsuffixlen &&
				      bcmp(lsufxloc, t->tp_lsuffix, lsufxlen) == 0)) &&
				    ((t->tp_flags & TPF_GENERAL_ADDR) ||
				     (laddr->sa_family == t->tp_domain &&
				      (*t->tp_nlproto->nlp_cmpnetaddr)
				      (t->tp_npcb, laddr, TP_LOCAL))))
					break;

			CHECK(t == 0, E_TP_NO_SESSION, ts_inv_sufx, respond,
			  (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
			/*
			 * _tpduf is the fixed part; add 2 to get the dref
			 * bits of the fixed part (can't take the address of
			 * a bit field)
			 */
#ifdef ARGO_DEBUG
				if (argo_debug[D_TPINPUT]) {
				printf("checking if dup CR\n");
			}
#endif
			tpcb = t;
			for (t = tpcb->tp_next; t != tpcb; t = t->tp_next) {
				if (sref != t->tp_fref)
					continue;
				if ((*tpcb->tp_nlproto->nlp_cmpnetaddr) (
					   t->tp_npcb, faddr, TP_FOREIGN)) {
#ifdef ARGO_DEBUG
					if (argo_debug[D_TPINPUT]) {
						printf("duplicate CR discarded\n");
					}
#endif
					goto discard;
				}
			}
#ifdef TPPT
		if (tp_traceflags[D_TPINPUT]) {
				tptrace(TPPTmisc, "tp_input: tpcb *lsufxloc tpstate",
					tpcb, *lsufxloc, tpcb->tp_state, 0);
			}
#endif
		}

		/*
		 * WE HAVE A TPCB already know that the classes in the CR
		 * match at least one class implemented, but we don't know
		 * yet if they include any classes permitted by this server.
		 */

#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("HAVE A TPCB 1: %p\n", tpcb);
		}
#endif
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
			printf(
			       "CR: bef CHKS: flags 0x%x class_to_use 0x%x alt 0x%x opt 0x%x tp_class 0x%x\n",
			       tpcb->tp_flags, class_to_use, alt_classes, opt, tpcb->tp_class);
		}
#endif
		/* tpcb->tp_class doesn't include any classes not implemented  */
		class_to_use = (preferred_class & tpcb->tp_class);
		if ((class_to_use = preferred_class & tpcb->tp_class) == 0)
			class_to_use = alt_classes & tpcb->tp_class;

		class_to_use = 1 << tp_mask_to_num(class_to_use);

		{
			tpp = tpcb->_tp_param;
			tpp.p_class = class_to_use;
			tpp.p_tpdusize = dusize;
			tpp.p_ptpdusize = pdusize;
			tpp.p_xtd_format = (opt & TPO_XTD_FMT) == TPO_XTD_FMT;
			tpp.p_xpd_service = (addlopt & TPAO_USE_TXPD) == TPAO_USE_TXPD;
			tpp.p_use_checksum = (tpp.p_class == TP_CLASS_0) ? 0 :
				(addlopt & TPAO_NO_CSUM) == 0;
			tpp.p_version = version;
#ifdef notdef
			tpp.p_use_efc = (opt & TPO_USE_EFC) == TPO_USE_EFC;
			tpp.p_use_nxpd = (addlopt & TPAO_USE_NXPD) == TPAO_USE_NXPD;
			tpp.p_use_rcc = (addlopt & TPAO_USE_RCC) == TPAO_USE_RCC;
#endif				/* notdef */

			CHECK(
			      tp_consistency(tpcb, 0 /* not force or strict */ , &tpp) != 0,
			E_TP_NEGOT_FAILED, ts_negotfailed, clear_parent_tcb,
			      (1 + 2 + (caddr_t) & hdr->_tpdufr.CRCC - (caddr_t) hdr)
			/* ^ more or less the location of class */
				)
		}
#ifdef TPPT
		if (tp_traceflags[D_CONN]) {
			tptrace(TPPTmisc,
		       "after 1 consist class_to_use class, out, tpconsout",
				class_to_use,
				tpcb->tp_class, dgout_routine, tpcons_output
			);
		}
#endif
		CHECK(((class_to_use == TP_CLASS_0) && 
		      (dgout_routine != tpcons_output)),
			E_TP_NEGOT_FAILED, ts_negotfailed, clear_parent_tcb,
		     (1 + 2 + (caddr_t) & hdr->_tpdufr.CRCC - (caddr_t) hdr)
		/* ^ more or less the location of class */
			)
#ifdef ARGO_DEBUG
			if (argo_debug[D_CONN]) {
			printf("CR: after CRCCCHECKS: tpcb %p, flags 0x%x\n",
			       tpcb, tpcb->tp_flags);
		}
#endif
		takes_data = TRUE;
		e.TPDU_ATTR(CR).e_cdt = hdr->tpdu_CRcdt;
		e.ev_number = CR_TPDU;

		so = tpcb->tp_sock;
		if (so->so_options & SO_ACCEPTCONN) {
			struct tp_pcb  *parent_tpcb = tpcb;
			/*
			 * Create a socket, tpcb, ll pcb, etc. for this
			 * newborn connection, and fill in all the values.
			 */
#ifdef ARGO_DEBUG
			if (argo_debug[D_CONN]) {
				printf("abt to call tp_newsocket(%p, %p, %p, %p)\n",
				       so, laddr, faddr, cons_channel);
			}
#endif
			if ((so =
			     tp_newsocket(so, faddr, cons_channel,
					  class_to_use,
			       ((tpcb->tp_netservice == IN_CLNS) ? IN_CLNS :
				(dgout_routine == tpcons_output) ? ISO_CONS : ISO_CLNS))
			     ) == (struct socket *) 0) {
				/*
				 * note - even if netservice is IN_CLNS, as
				 * far as the tp entity is concerned, the
				 * only differences are CO vs CL
				 */
#ifdef ARGO_DEBUG
				if (argo_debug[D_CONN]) {
					printf("tp_newsocket returns 0\n");
				}
#endif
				goto discard;
		clear_parent_tcb:
				tpcb = 0;
				goto respond;
			}
			tpcb = sototpcb(so);
			insque(tpcb, parent_tpcb);

			/*
			 * Stash the addresses in the net level pcb
			 * kind of like a pcbconnect() but don't need
			 * or want all those checks.
			 */
			(tpcb->tp_nlproto->nlp_putnetaddr) (tpcb->tp_npcb, faddr, TP_FOREIGN);
			(tpcb->tp_nlproto->nlp_putnetaddr) (tpcb->tp_npcb, laddr, TP_LOCAL);

			/* stash the f suffix in the new tpcb */
			if ((tpcb->tp_fsuffixlen = fsufxlen) != 0) {
				bcopy(fsufxloc, tpcb->tp_fsuffix, fsufxlen);
				(tpcb->tp_nlproto->nlp_putsufx)
					(tpcb->tp_npcb, fsufxloc, fsufxlen, TP_FOREIGN);
			}
			/* stash the l suffix in the new tpcb */
			tpcb->tp_lsuffixlen = lsufxlen;
			bcopy(lsufxloc, tpcb->tp_lsuffix, lsufxlen);
			(tpcb->tp_nlproto->nlp_putsufx)
				(tpcb->tp_npcb, lsufxloc, lsufxlen, TP_LOCAL);
#ifdef TP_PERF_MEAS
			if (tpcb->tp_perf_on = perf_meas) {	/* assignment */
				/*
				 * ok, let's create an mbuf for stashing the
				 * statistics if one doesn't already exist
				 */
				(void) tp_setup_perf(tpcb);
			}
#endif				/* TP_PERF_MEAS */
			tpcb->tp_fref = sref;

			/*
			 * We've already checked for consistency with the
			 * options set in tpp,  but we couldn't set them
			 * earlier because we didn't want to change options
			 * in the LISTENING tpcb. Now we set the options in
			 * the new socket's tpcb.
			 */
			(void) tp_consistency(tpcb, TP_FORCE, &tpp);

			if (!tpcb->tp_use_checksum)
				IncStat(ts_csum_off);
			if (tpcb->tp_xpd_service)
				IncStat(ts_use_txpd);
			if (tpcb->tp_xtd_format)
				IncStat(ts_xtd_fmt);

			tpcb->tp_peer_acktime = acktime;

			/*
			 * The following kludge is used to test
			 * retransmissions and timeout during connection
			 * establishment.
			 */
#ifdef ARGO_DEBUG
			if (argo_debug[D_ZDREF]) {
				IncStat(ts_zdebug);
				/* tpcb->tp_fref = 0; */
			}
#endif
		}
		LOCAL_CREDIT(tpcb);
		IncStat(ts_CR_rcvd);
		if (!tpcb->tp_cebit_off) {
			tpcb->tp_win_recv = tp_start_win << 8;
			tpcb->tp_cong_sample.cs_size = 0;
			CONG_INIT_SAMPLE(tpcb);
			CONG_UPDATE_SAMPLE(tpcb, ce_bit);
		}
	} else if (dutype == ER_TPDU_type) {
		/*
		 * ER TPDUs have to be recognized separately because they
		 * don't necessarily have a tpcb with them and we don't want
		 * err out looking for such a beast. We could put a bunch of
		 * little kludges in the next section of code so it would
		 * avoid references to tpcb if dutype == ER_TPDU_type but we
		 * don't want code for ERs to mess up code for data transfer.
		 */
		IncStat(ts_ER_rcvd);
		e.ev_number = ER_TPDU;
		e.TPDU_ATTR(ER).e_reason = (u_char) hdr->tpdu_ERreason;
		CHECK(((int) dref <= 0 || dref >= tp_refinfo.tpr_size ||
		     (tpcb = tp_ref[dref].tpr_pcb) == (struct tp_pcb *) 0 ||
		       tpcb->tp_refstate == REF_FREE ||
		       tpcb->tp_refstate == REF_FROZEN),
		      E_TP_MISM_REFS, ts_inv_dref, discard, 0)
	} else {
		/* tpdu type is CC, XPD, XAK, GR, AK, DR, DC, or DT */

		/*
		 * In the next 4 checks, _tpduf is the fixed part; add 2 to
		 * get the dref bits of the fixed part (can't take the
		 * address of a bit field)
		 */
#ifdef TPCONS
		if (cons_channel && dutype == DT_TPDU_type) {
			struct isopcb  *isop = ((struct isopcb *)
			       ((struct pklcd *) cons_channel)->lcd_upnext);
			if (isop && isop->isop_refcnt == 1 && isop->isop_socket &&
			    (tpcb = sototpcb(isop->isop_socket)) &&
			    (tpcb->tp_class == TP_CLASS_0 /* || == CLASS_1 */ )) {
#ifdef ARGO_DEBUG
				if (argo_debug[D_TPINPUT]) {
					printf("tpinput_dt: class 0 short circuit\n");
				}
#endif
				dref = tpcb->tp_lref;
				sref = tpcb->tp_fref;
				CHECK((tpcb->tp_refstate == REF_FREE),
				      E_TP_MISM_REFS, ts_inv_dref, nonx_dref,
				      (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
					goto tp0_data;
			}
		}
#endif
		{

			CHECK(((int) dref <= 0 || dref >= tp_refinfo.tpr_size),
			      E_TP_MISM_REFS, ts_inv_dref, nonx_dref,
			  (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
				CHECK(((tpcb = tp_ref[dref].tpr_pcb) == (struct tp_pcb *) 0),
				      E_TP_MISM_REFS, ts_inv_dref, nonx_dref,
			  (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
				CHECK((tpcb->tp_refstate == REF_FREE),
				      E_TP_MISM_REFS, ts_inv_dref, nonx_dref,
			  (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
		}

#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("HAVE A TPCB 2: %p\n", tpcb);
		}
#endif

		/* causes a DR to be sent for CC; ER for all else */
		CHECK((tpcb->tp_refstate == REF_FROZEN),
		(dutype == CC_TPDU_type ? E_TP_NO_SESSION : E_TP_MISM_REFS),
		      ts_inv_dref, respond,
		      (1 + 2 + (caddr_t) & hdr->_tpduf - (caddr_t) hdr))
#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("state of dref %d ok, tpcb %p\n", dref, tpcb);
		}
#endif
		/*
		 * At this point the state of the dref could be FROZEN:
		 * tpr_pcb == NULL,  has ( reference only) timers for
		 * example, DC may arrive after the close() has detached the
		 * tpcb (e.g., if user turned off SO_LISTEN option) OPENING :
		 * a tpcb exists but no timers yet OPEN  : tpcb exists &
		 * timers are outstanding
		 */

		if (!tpcb->tp_cebit_off)
			CONG_UPDATE_SAMPLE(tpcb, ce_bit);

		dusize = tpcb->tp_tpdusize;
		pdusize = tpcb->tp_ptpdusize;

		dutype = hdr->tpdu_type << 8;	/* for the switch below */

		WHILE_OPTIONS(P, hdr, tpcb->tp_xtd_format)	/* { */
#define caseof(x,y) case (((x)<<8)+(y))
			switch (dutype | vbptr(P)->tpv_code) {

	caseof(CC_TPDU_type, TPP_addl_opt):
			/* not in class 0; 1 octet */
			vb_getval(P, u_char, addlopt);
			break;
	caseof(CC_TPDU_type, TPP_tpdu_size):
			{
				u_char          odusize = dusize;
				vb_getval(P, u_char, dusize);
				CHECK((dusize < TP_MIN_TPDUSIZE ||
				       dusize > TP_MAX_TPDUSIZE || dusize > odusize),
				      E_TP_INV_PVAL, ts_inv_pval, respond,
				      (1 + (caddr_t) & vbptr(P)->tpv_val - (caddr_t) hdr))
#ifdef ARGO_DEBUG
					if (argo_debug[D_TPINPUT]) {
					printf("CC dusize 0x%x\n", dusize);
				}
#endif
			}
			break;
	caseof(CC_TPDU_type, TPP_ptpdu_size):
			{
				u_short         opdusize = pdusize;
				switch (vbptr(P)->tpv_len) {
				case 1:
					pdusize = vbval(P, u_char);
					break;
				case 2:
					pdusize = ntohs(vbval(P, u_short));
					break;
				default:;
#ifdef ARGO_DEBUG
					if (argo_debug[D_TPINPUT]) {
						printf("malformed prefered TPDU option\n");
					}
#endif
				}
				CHECK((pdusize == 0 ||
				       (opdusize && (pdusize > opdusize))),
				      E_TP_INV_PVAL, ts_inv_pval, respond,
				      (1 + (caddr_t) & vbptr(P)->tpv_val - (caddr_t) hdr))
			}
			break;
	caseof(CC_TPDU_type, TPP_calling_sufx):
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CC calling (local) sufxlen 0x%x\n", lsufxlen);
			}
#endif
			lsufxloc = (caddr_t) & vbptr(P)->tpv_val;
			lsufxlen = vbptr(P)->tpv_len;
			break;
	caseof(CC_TPDU_type, TPP_acktime):
			/* class 4 only, 2 octets */
			vb_getval(P, u_short, acktime);
			acktime = ntohs(acktime);
			acktime = acktime / 500;	/* convert to slowtimo
							 * ticks */
			if ((short) acktime <= 0)
				acktime = 2;
			break;
	caseof(CC_TPDU_type, TPP_called_sufx):
			fsufxloc = (caddr_t) & vbptr(P)->tpv_val;
			fsufxlen = vbptr(P)->tpv_len;
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("CC called (foreign) sufx len %d\n", fsufxlen);
			}
#endif
			break;

	caseof(CC_TPDU_type, TPP_checksum):
	caseof(DR_TPDU_type, TPP_checksum):
	caseof(DT_TPDU_type, TPP_checksum):
	caseof(XPD_TPDU_type, TPP_checksum):
			if (tpcb->tp_use_checksum) {
				CHECK(iso_check_csum(m, tpdu_len),
				      E_TP_INV_PVAL, ts_bad_csum, discard, 0)
			}
			break;

			/*
			 * this is different from the above because in the
			 * context of concat/ sep tpdu_len might not be the
			 * same as hdr len
			 */
	caseof(AK_TPDU_type, TPP_checksum):
	caseof(XAK_TPDU_type, TPP_checksum):
	caseof(DC_TPDU_type, TPP_checksum):
			if (tpcb->tp_use_checksum) {
				CHECK(iso_check_csum(m, (int) hdr->tpdu_li + 1),
				      E_TP_INV_PVAL, ts_bad_csum, discard, 0)
			}
			break;
#ifdef notdef
	caseof(DR_TPDU_type, TPP_addl_info):
			/*
			 * ignore - its length and meaning are user defined
			 * and there's no way to pass this info to the user
			 * anyway
			 */
			break;
#endif				/* notdef */

	caseof(AK_TPDU_type, TPP_subseq):
			/* used after reduction of window */
			vb_getval(P, u_short, subseq);
			subseq = ntohs(subseq);
#ifdef ARGO_DEBUG
			if (argo_debug[D_ACKRECV]) {
				printf("AK dref 0x%x Subseq 0x%x\n", dref, subseq);
			}
#endif
			break;

	caseof(AK_TPDU_type, TPP_flow_cntl_conf):
			{
				u_int           ylwe;
				u_short         ysubseq, ycredit;

				fcc_present = TRUE;
				vb_getval(P, u_int, ylwe);
				vb_getval(P, u_short, ysubseq);
				vb_getval(P, u_short, ycredit);
				ylwe = ntohl(ylwe);
				ysubseq = ntohs(ysubseq);
				ycredit = ntohs(ycredit);
#ifdef ARGO_DEBUG
				if (argo_debug[D_ACKRECV]) {
					printf("%s%x, subseq 0x%x, cdt 0x%x dref 0x%x\n",
					       "AK FCC lwe 0x", ylwe, ysubseq, ycredit, dref);
				}
#endif
			}
			break;

		default:
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("param ignored dutype 0x%x, code  0x%x\n",
				       dutype, vbptr(P)->tpv_code);
			}
#endif
#ifdef TPPT
			if (tp_traceflags[D_TPINPUT]) {
				tptrace(TPPTmisc, "param ignored dutype code ",
					dutype, vbptr(P)->tpv_code, 0, 0);
			}
#endif
			IncStat(ts_param_ignored);
			break;
#undef caseof
		}
		 /* } */ END_WHILE_OPTIONS(P)
		/* NOTE: the variable dutype has been shifted left! */

			switch (hdr->tpdu_type) {
		case CC_TPDU_type:
			/*
			 * If CC comes back with an unacceptable class
			 * respond with a DR or ER
			 */

			opt = hdr->tpdu_CCoptions;	/* 1 byte */

			{
				tpp = tpcb->_tp_param;
				tpp.p_class = (1 << hdr->tpdu_CCclass);
				tpp.p_tpdusize = dusize;
				tpp.p_ptpdusize = pdusize;
				tpp.p_dont_change_params = 0;
				tpp.p_xtd_format = (opt & TPO_XTD_FMT) == TPO_XTD_FMT;
				tpp.p_xpd_service = (addlopt & TPAO_USE_TXPD) == TPAO_USE_TXPD;
				tpp.p_use_checksum = (addlopt & TPAO_NO_CSUM) == 0;
#ifdef notdef
				tpp.p_use_efc = (opt & TPO_USE_EFC) == TPO_USE_EFC;
				tpp.p_use_nxpd = (addlopt & TPAO_USE_NXPD) == TPAO_USE_NXPD;
				tpp.p_use_rcc = (addlopt & TPAO_USE_RCC) == TPAO_USE_RCC;
#endif				/* notdef */

				CHECK(
				  tp_consistency(tpcb, TP_FORCE, &tpp) != 0,
				 E_TP_NEGOT_FAILED, ts_negotfailed, respond,
				      (1 + 2 + (caddr_t) & hdr->_tpdufr.CRCC - (caddr_t) hdr)
				/* ^ more or less the location of class */
					)
#ifdef TPPT
					if (tp_traceflags[D_CONN]) {
					tptrace(TPPTmisc,
				    "after 1 consist class, out, tpconsout",
						tpcb->tp_class, dgout_routine, tpcons_output, 0
					);
				}
#endif
					CHECK(
					    ((class_to_use == TP_CLASS_0) &&
					  (dgout_routine != tpcons_output)),
				 E_TP_NEGOT_FAILED, ts_negotfailed, respond,
					      (1 + 2 + (caddr_t) & hdr->_tpdufr.CRCC - (caddr_t) hdr)
				/* ^ more or less the location of class */
					)
#ifdef TPCONS
					if (tpcb->tp_netservice == ISO_CONS &&
					    class_to_use == TP_CLASS_0) {
					struct isopcb  *isop = (struct isopcb *) tpcb->tp_npcb;
					struct pklcd   *lcp = (struct pklcd *) isop->isop_chan;
					lcp->lcd_flags &= ~X25_DG_CIRCUIT;
				}
#endif
			}
			if (!tpcb->tp_use_checksum)
				IncStat(ts_csum_off);
			if (tpcb->tp_xpd_service)
				IncStat(ts_use_txpd);
			if (tpcb->tp_xtd_format)
				IncStat(ts_xtd_fmt);

#ifdef TPPT
			if (tp_traceflags[D_CONN]) {
				tptrace(TPPTmisc, "after CC class flags dusize CCclass",
			  tpcb->tp_class, tpcb->tp_flags, tpcb->tp_tpdusize,
					hdr->tpdu_CCclass);
			}
#endif

			/*
			 * if called or calling suffices appeared on the CC,
			 * they'd better jive with what's in the pcb
			 */
				if (fsufxlen) {
				CHECK(((tpcb->tp_fsuffixlen != fsufxlen) ||
				bcmp(fsufxloc, tpcb->tp_fsuffix, fsufxlen)),
				      E_TP_INV_PVAL, ts_inv_sufx, respond,
				      (1 + fsufxloc - (caddr_t) hdr))
			}
			if (lsufxlen) {
				CHECK(((tpcb->tp_lsuffixlen != lsufxlen) ||
				bcmp(lsufxloc, tpcb->tp_lsuffix, lsufxlen)),
				      E_TP_INV_PVAL, ts_inv_sufx, respond,
				      (1 + lsufxloc - (caddr_t) hdr))
			}
			e.TPDU_ATTR(CC).e_sref = sref;
			e.TPDU_ATTR(CC).e_cdt = hdr->tpdu_CCcdt;
			takes_data = TRUE;
			e.ev_number = CC_TPDU;
			IncStat(ts_CC_rcvd);
			break;

		case DC_TPDU_type:
			if (sref != tpcb->tp_fref)
				printf("INPUT: inv sufx DCsref 0x%x, tp_fref 0x%x\n",
				       sref, tpcb->tp_fref);

			CHECK((sref != tpcb->tp_fref),
			      E_TP_MISM_REFS, ts_inv_sufx, discard,
			 (1 + (caddr_t) & hdr->tpdu_DCsref - (caddr_t) hdr))
				e.ev_number = DC_TPDU;
			IncStat(ts_DC_rcvd);
			break;

		case DR_TPDU_type:
#ifdef TPPT
			if (tp_traceflags[D_TPINPUT]) {
				tptrace(TPPTmisc, "DR recvd", hdr->tpdu_DRreason, 0, 0, 0);
			}
#endif
				if (sref != tpcb->tp_fref) {
				printf("INPUT: inv sufx DRsref 0x%x tp_fref 0x%x\n",
				       sref, tpcb->tp_fref);
			}
			CHECK((sref != 0 && sref != tpcb->tp_fref &&
			       tpcb->tp_state != TP_CRSENT),
			      (TP_ERROR_SNDC | E_TP_MISM_REFS), ts_inv_sufx, respond,
			 (1 + (caddr_t) & hdr->tpdu_DRsref - (caddr_t) hdr))
				e.TPDU_ATTR(DR).e_reason = hdr->tpdu_DRreason;
			e.TPDU_ATTR(DR).e_sref = (u_short) sref;
			takes_data = TRUE;
			e.ev_number = DR_TPDU;
			IncStat(ts_DR_rcvd);
			break;

		case ER_TPDU_type:
#ifdef TPPT
			if (tp_traceflags[D_TPINPUT]) {
				tptrace(TPPTmisc, "ER recvd", hdr->tpdu_ERreason, 0, 0, 0);
			}
#endif
				e.ev_number = ER_TPDU;
			e.TPDU_ATTR(ER).e_reason = hdr->tpdu_ERreason;
			IncStat(ts_ER_rcvd);
			break;

		case AK_TPDU_type:

			e.TPDU_ATTR(AK).e_subseq = subseq;
			e.TPDU_ATTR(AK).e_fcc_present = fcc_present;

			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seqeot = ntohl(hdr->tpdu_seqeotX);
				e.TPDU_ATTR(AK).e_seq = seqeotX.s_seq;
				e.TPDU_ATTR(AK).e_cdt = ntohs(hdr->tpdu_AKcdtX);
#else
				e.TPDU_ATTR(AK).e_cdt = hdr->tpdu_AKcdtX;
				e.TPDU_ATTR(AK).e_seq = hdr->tpdu_AKseqX;
#endif				/* BYTE_ORDER */
			} else {
				e.TPDU_ATTR(AK).e_cdt = hdr->tpdu_AKcdt;
				e.TPDU_ATTR(AK).e_seq = hdr->tpdu_AKseq;
			}
#ifdef TPPT
			if (tp_traceflags[D_TPINPUT]) {
				tptrace(TPPTmisc, "AK recvd seq cdt subseq fcc_pres",
			       e.TPDU_ATTR(AK).e_seq, e.TPDU_ATTR(AK).e_cdt,
					subseq, fcc_present);
			}
#endif

				e.ev_number = AK_TPDU;
			IncStat(ts_AK_rcvd);
			IncPStat(tpcb, tps_AK_rcvd);
			break;

		case XAK_TPDU_type:
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seqeot = ntohl(hdr->tpdu_seqeotX);
				e.TPDU_ATTR(XAK).e_seq = seqeotX.s_seq;
#else
				e.TPDU_ATTR(XAK).e_seq = hdr->tpdu_XAKseqX;
#endif				/* BYTE_ORDER */
			} else {
				e.TPDU_ATTR(XAK).e_seq = hdr->tpdu_XAKseq;
			}
			e.ev_number = XAK_TPDU;
			IncStat(ts_XAK_rcvd);
			IncPStat(tpcb, tps_XAK_rcvd);
			break;

		case XPD_TPDU_type:
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seqeot = ntohl(hdr->tpdu_seqeotX);
				e.TPDU_ATTR(XPD).e_seq = seqeotX.s_seq;
#else
				e.TPDU_ATTR(XPD).e_seq = hdr->tpdu_XPDseqX;
#endif				/* BYTE_ORDER */
			} else {
				e.TPDU_ATTR(XPD).e_seq = hdr->tpdu_XPDseq;
			}
			takes_data = TRUE;
			e.ev_number = XPD_TPDU;
			IncStat(ts_XPD_rcvd);
			IncPStat(tpcb, tps_XPD_rcvd);
			break;

		case DT_TPDU_type:
			/*
			 * the y option will cause occasional packets
			 * to be dropped. A little crude but it
			 * works.
			 */

#ifdef ARGO_DEBUG
			if (argo_debug[D_DROP]) {
				if (time.tv_usec & 0x4 &&
				    hdr->tpdu_DTseq & 0x1) {
					IncStat(ts_ydebug);
					goto discard;
				}
			}
#endif
			if (tpcb->tp_class == TP_CLASS_0) {
#ifdef TPCONS
		tp0_data:
#endif
				e.TPDU_ATTR(DT).e_seq = 0;	/* actually don't care */
				e.TPDU_ATTR(DT).e_eot = (((struct tp0du *) hdr)->tp0du_eot);
			} else if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seqeot = ntohl(hdr->tpdu_seqeotX);
				e.TPDU_ATTR(DT).e_seq = seqeotX.s_seq;
				e.TPDU_ATTR(DT).e_eot = seqeotX.s_eot;
#else
				e.TPDU_ATTR(DT).e_seq = hdr->tpdu_DTseqX;
				e.TPDU_ATTR(DT).e_eot = hdr->tpdu_DTeotX;
#endif				/* BYTE_ORDER */
			} else {
				e.TPDU_ATTR(DT).e_seq = hdr->tpdu_DTseq;
				e.TPDU_ATTR(DT).e_eot = hdr->tpdu_DTeot;
			}
			if (e.TPDU_ATTR(DT).e_eot)
				IncStat(ts_eot_input);
			takes_data = TRUE;
			e.ev_number = DT_TPDU;
			IncStat(ts_DT_rcvd);
			IncPStat(tpcb, tps_DT_rcvd);
			break;

		case GR_TPDU_type:
			tp_indicate(T_DISCONNECT, tpcb, ECONNABORTED);
			/* drop through */
		default:
			/*
			 * this should NEVER happen because there is a check
			 * for dutype well above here
			 */
			error = E_TP_INV_TPDU;	/* causes an ER  */
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				printf("INVALID dutype 0x%x\n", hdr->tpdu_type);
			}
#endif
			IncStat(ts_inv_dutype);
			goto respond;
		}
	}
	/*
	 * peel off the tp header; remember that the du_li doesn't count
	 * itself. This may leave us w/ an empty mbuf at the front of a
	 * chain. We can't just throw away the empty mbuf because hdr still
	 * points into the mbuf's data area and we're still using hdr (the
	 * tpdu header)
	 */
	m->m_len -= ((int) hdr->tpdu_li + 1);
	m->m_data += ((int) hdr->tpdu_li + 1);

	if (takes_data) {
		int             max = tpdu_info[hdr->tpdu_type][TP_MAX_DATA_INDEX];
		int             datalen = tpdu_len - hdr->tpdu_li - 1, mbtype = MT_DATA;
		struct {
			struct tp_disc_reason dr;
			struct cmsghdr  x_hdr;
		}               x;
#define c_hdr x.x_hdr
		struct mbuf *n;

		CHECK((max && datalen > max), E_TP_LENGTH_INVAL,
		      ts_inv_length, respond, (max + hdr->tpdu_li + 1));
		switch (hdr->tpdu_type) {

		case CR_TPDU_type:
			c_hdr.cmsg_type = TPOPT_CONN_DATA;
			goto make_control_msg;

		case CC_TPDU_type:
			c_hdr.cmsg_type = TPOPT_CFRM_DATA;
			goto make_control_msg;

		case DR_TPDU_type:
			x.dr.dr_hdr.cmsg_len = sizeof(x) - sizeof(c_hdr);
			x.dr.dr_hdr.cmsg_type = TPOPT_DISC_REASON;
			x.dr.dr_hdr.cmsg_level = SOL_TRANSPORT;
			x.dr.dr_reason = hdr->tpdu_DRreason;
			c_hdr.cmsg_type = TPOPT_DISC_DATA;
	make_control_msg:
			datalen += sizeof(c_hdr);
			c_hdr.cmsg_len = datalen;
			c_hdr.cmsg_level = SOL_TRANSPORT;
			mbtype = MT_CONTROL;
			MGET(n, M_DONTWAIT, MT_DATA);
			if (n == 0) {
				m_freem(m);
				m = 0;
				datalen = 0;
				goto invoke;
			}
			if (hdr->tpdu_type == DR_TPDU_type) {
				datalen += sizeof(x) - sizeof(c_hdr);
				bcopy((caddr_t) & x, mtod(n, caddr_t), n->m_len = sizeof(x));
			} else
				bcopy((caddr_t) & c_hdr, mtod(n, caddr_t),
				      n->m_len = sizeof(c_hdr));
			n->m_next = m;
			m = n;
			/* FALLTHROUGH */

		case XPD_TPDU_type:
			if (mbtype != MT_CONTROL)
				mbtype = MT_OOBDATA;
			m->m_flags |= M_EOR;
			/* FALLTHROUGH */

		case DT_TPDU_type:
			for (n = m; n; n = n->m_next) {
				MCHTYPE(n, mbtype);
			}
	invoke:
			e.TPDU_ATTR(DT).e_datalen = datalen;
			e.TPDU_ATTR(DT).e_data = m;
			break;

		default:
			printf(
			       "ERROR in tp_input! hdr->tpdu_type 0x%x takes_data 0x%x m %p\n",
			       hdr->tpdu_type, takes_data, m);
			break;
		}
		/*
		 * prevent m_freem() after tp_driver() from throwing it all
		 * away
		 */
		m = MNULL;
	}
	IncStat(ts_tpdu_rcvd);

#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_input: before driver, state 0x%x event 0x%x m %p",
		       tpcb->tp_state, e.ev_number, m);
		printf(" e.e_data %p\n", e.TPDU_ATTR(DT).e_data);
		printf("takes_data 0x%x m_len 0x%x, tpdu_len 0x%x\n",
		       takes_data, (m == MNULL) ? 0 : m->m_len, tpdu_len);
	}
#endif

	error = tp_driver(tpcb, &e);

	ASSERT(tpcb != (struct tp_pcb *) 0);
	ASSERT(tpcb->tp_sock != (struct socket *) 0);
	if (tpcb->tp_sock->so_error == 0)
		tpcb->tp_sock->so_error = error;

	/*
	 * Kludge to keep the state tables under control (adding data on
	 * connect & disconnect & freeing the mbuf containing the data would
	 * have exploded the tables and made a big mess ).
	 */
	switch (e.ev_number) {
	case CC_TPDU:
	case DR_TPDU:
	case CR_TPDU:
		m = e.TPDU_ATTR(CC).e_data;	/* same field for all three
						 * dutypes */
#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("after driver, restoring m to %p, takes_data 0x%x\n",
			       m, takes_data);
		}
#endif
		break;
	default:
		break;
	}
	/*
	 * Concatenated sequences are terminated by any tpdu that carries
	 * data: CR, CC, DT, XPD, DR. All other tpdu types may be
	 * concatenated: AK, XAK, DC, ER.
	 */

	if (takes_data == 0) {
		ASSERT(m != MNULL);
		/*
		 * we already peeled off the prev. tp header so we can just
		 * pull up some more and repeat
		 */

		if ((m = tp_inputprep(m)) != NULL) {
#ifdef ARGO_DEBUG
			if (argo_debug[D_TPINPUT]) {
				hdr = mtod(m, struct tpdu *);
				printf("tp_input @@ separate: hdr %p size %d m %p\n",
				       hdr, (int) hdr->tpdu_li + 1, m);
				dump_mbuf(m, "tp_input after driver, at separate");
			}
#endif

			IncStat(ts_concat_rcvd);
			goto again;
		}
	}
	if (m != MNULL) {
#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("tp_input : m_freem(%p)\n", m);
		}
#endif
		m_freem(m);
#ifdef ARGO_DEBUG
		if (argo_debug[D_TPINPUT]) {
			printf("tp_input : after m_freem %p\n", m);
		}
#endif
	}
	return;

discard:
	/* class 4: drop the tpdu */
	/*
	 * class 2,0: Should drop the net connection, if you can figure out
	 * to which connection it applies
	 */
#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_input DISCARD\n");
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_TPINPUT]) {
		tptrace(TPPTmisc, "tp_input DISCARD m", m, 0, 0, 0);
	}
#endif
		m_freem(m);
	IncStat(ts_recv_drop);
	return;

nonx_dref:
	switch (dutype) {
	default:
		goto discard;
	case CC_TPDU_type:
		/* error = E_TP_MISM_REFS; */
		break;
	case DR_TPDU_type:
		error |= TP_ERROR_SNDC;
	}
respond:
#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("RESPOND: error 0x%x, errlen 0x%x\n", error, errlen);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_TPINPUT]) {
		tptrace(TPPTmisc, "tp_input RESPOND m error sref", m, error, sref, 0);
	}
#endif
		if (sref == 0)
		goto discard;
	(void) tp_error_emit(error, (u_long) sref, satosiso(faddr),
			     satosiso(laddr), m, errlen, tpcb,
			     cons_channel, dgout_routine);
#ifdef ARGO_DEBUG
	if (argo_debug[D_ERROR_EMIT]) {
		printf("tp_input after error_emit\n");
	}
#endif

#ifdef lint
	printf("", sref, opt);
#endif				/* lint */
	IncStat(ts_recv_drop);
}


/*
 * NAME: tp_headersize()
 *
 * CALLED FROM:
 *  tp_emit() and tp_sbsend()
 *  TP needs to know the header size so it can figure out how
 *  much data to put in each tpdu.
 *
 * FUNCTION, ARGUMENTS, and RETURN VALUE:
 *  For a given connection, represented by (tpcb), and
 *  tpdu type (dutype), return the size of a tp header.
 *
 * RETURNS:	  the expected size of the heade in bytesr
 *
 * SIDE EFFECTS:
 *
 * NOTES:	 It would be nice if it got the network header size as well.
 */
int
tp_headersize(dutype, tpcb)
	int             dutype;
	struct tp_pcb  *tpcb;
{
	int    size = 0;

#ifdef TPPT
	if (tp_traceflags[D_CONN]) {
		tptrace(TPPTmisc, "tp_headersize dutype class xtd_format",
			dutype, tpcb->tp_class, tpcb->tp_xtd_format, 0);
	}
#endif
	if (!((tpcb->tp_class == TP_CLASS_0) ||
		      (tpcb->tp_class == TP_CLASS_4) ||
		      (dutype == DR_TPDU_type) ||
		      (dutype == CR_TPDU_type))) {
		printf("tp_headersize:dutype 0x%x, class 0x%x",
		       dutype, tpcb->tp_class);
		/* TODO: identify this and GET RID OF IT */
	}
	ASSERT((tpcb->tp_class == TP_CLASS_0) ||
	       (tpcb->tp_class == TP_CLASS_4) ||
	       (dutype == DR_TPDU_type) ||
	       (dutype == CR_TPDU_type));

	if (tpcb->tp_class == TP_CLASS_0) {
		size = tpdu_info[dutype][TP_LEN_CLASS_0_INDEX];
	} else {
		size = tpdu_info[dutype][tpcb->tp_xtd_format];
	}
	return size;
	/* caller must get network level header size separately */
}
@


1.8
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.7 2003/12/10 07:22:44 itojun Exp $	*/
@


1.7
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.6 2003/06/02 23:28:18 millert Exp $	*/
d116 1
a116 1
#include <machine/stdarg.h>
@


1.6
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.5 2002/03/15 18:19:53 millert Exp $	*/
d123 1
a123 1
	register struct mbuf *m;
d229 1
a229 1
{	register caddr_t P = tpdu_info[(hdr)->tpdu_type][(format)] + (caddr_t)hdr;\
d269 1
a269 1
	register struct tp_pcb *tpcb = sototpcb(so);	/* old tpcb, needed
d271 1
a271 1
	register struct tp_pcb *newtpcb;
d423 2
a424 2
	register struct tp_pcb *tpcb;
	register struct tpdu *hdr;
d484 1
a484 1
		register struct mbuf *n = m;
d615 1
a615 1
					register int    j;
d635 1
a635 1
					register int    j;
d681 1
a681 1
				register int    i;
d742 1
a742 1
			register struct tp_pcb *t;
d1514 1
a1514 1
		register struct mbuf *n;
d1747 1
a1747 1
	register int    size = 0;
@


1.5
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.4 2002/03/14 01:27:12 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.3 1996/04/21 22:29:47 deraadt Exp $	*/
a420 1
#if __STDC__
a421 5
#else
tp_input(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.2 1996/03/04 10:36:02 mickey Exp $	*/
d122 2
a123 2
static struct socket *tp_newsocket __P((struct socket *, struct sockaddr *,
					caddr_t, u_int, u_int));
d431 1
a431 1
	int             (*dgout_routine) __P((struct mbuf *, ...));
d459 1
a459 1
	dgout_routine = (int (*) __P((struct mbuf *, ...))) va_arg(ap, void *);
@


1.3.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.3 1996/04/21 22:29:47 deraadt Exp $	*/
d122 2
a123 2
static struct socket *tp_newsocket(struct socket *, struct sockaddr *,
					caddr_t, u_int, u_int);
d421 1
d423 5
d431 1
a431 1
	int             (*dgout_routine)(struct mbuf *, ...);
d459 1
a459 1
	dgout_routine = (int (*)(struct mbuf *, ...)) va_arg(ap, void *);
@


1.3.16.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d122 2
a123 2
static struct socket *tp_newsocket(struct socket *, struct sockaddr *,
					caddr_t, u_int, u_int);
d421 1
d423 5
d431 1
a431 1
	int             (*dgout_routine)(struct mbuf *, ...);
d459 1
a459 1
	dgout_routine = (int (*)(struct mbuf *, ...)) va_arg(ap, void *);
@


1.3.16.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_input.c,v 1.3.16.1 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 1
a116 1
#include <sys/stdarg.h>
d123 1
a123 1
	struct mbuf *m;
d229 1
a229 1
{	caddr_t P = tpdu_info[(hdr)->tpdu_type][(format)] + (caddr_t)hdr;\
d269 1
a269 1
	struct tp_pcb *tpcb = sototpcb(so);	/* old tpcb, needed
d271 1
a271 1
	struct tp_pcb *newtpcb;
d423 2
a424 2
	struct tp_pcb *tpcb;
	struct tpdu *hdr;
d484 1
a484 1
		struct mbuf *n = m;
d615 1
a615 1
					int    j;
d635 1
a635 1
					int    j;
d681 1
a681 1
				int    i;
d742 1
a742 1
			struct tp_pcb *t;
d1514 1
a1514 1
		struct mbuf *n;
d1747 1
a1747 1
	int    size = 0;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tp_input.c,v 1.8 1996/02/13 22:11:08 christos Exp $	*/
d133 1
a133 1
		printf("tp_inputprep: m 0x%x\n", m);
d184 1
a184 1
		       " at end: m 0x%x hdr->tpdu_li 0x%x m_len 0x%x\n", m,
d299 1
a299 1
		printf("tp_newsocket(channel 0x%x)  after sonewconn so 0x%x \n",
d307 1
a307 1
			printf("so 0x%x so_head 0x%x so_q0 0x%x, q0len %d\n",
d310 1
a310 1
				printf("so 0x%x so_head 0x%x so_q0 0x%x, q0len %d\n",
d382 1
a382 1
			printf("tp_route_to FAILED! detaching tpcb 0x%x, so 0x%x\n",
d392 1
a392 1
		printf("tp_newsocket returning so 0x%x, sototpcb(so) 0x%x\n",
d481 1
a481 1
		printf("tp_input(0x%x, ... 0x%x)\n", m, cons_channel);
d538 2
a539 2
		printf("input: dutype 0x%x cons_channel 0x%x dref 0x%x\n", dutype,
		       cons_channel, dref);
d553 1
a553 1
		printf("BAD dutype! 0x%x, channel 0x%x dref 0x%x\n",
d816 1
a816 1
			printf("HAVE A TPCB 1: 0x%x\n", tpcb);
d873 1
a873 1
			printf("CR: after CRCCCHECKS: tpcb 0x%x, flags 0x%x\n",
d890 1
a890 1
				printf("abt to call tp_newsocket(0x%x, 0x%x, 0x%x, 0x%x)\n",
d1047 1
a1047 1
			printf("HAVE A TPCB 2: 0x%x\n", tpcb);
d1057 2
a1058 2
			if (argo_debug[D_TPINPUT]) {
			printf("state of dref %d ok, tpcb 0x%x\n", dref, tpcb);
d1583 1
a1583 1
			       "ERROR in tp_input! hdr->tpdu_type 0x%x takes_data 0x%x m 0x%x\n",
d1597 1
a1597 1
		printf("tp_input: before driver, state 0x%x event 0x%x m 0x%x",
d1599 1
a1599 1
		printf(" e.e_data 0x%x\n", e.TPDU_ATTR(DT).e_data);
d1625 1
a1625 1
			printf("after driver, restoring m to 0x%x, takes_data 0x%x\n",
d1650 1
a1650 1
				printf("tp_input @@ separate: hdr 0x%x size %d m 0x%x\n",
d1663 1
a1663 1
			printf("tp_input : m_freem(0x%x)\n", m);
d1669 1
a1669 1
			printf("tp_input : after m_freem 0x%x\n", m);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tp_input.c,v 1.7 1995/06/13 07:13:42 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d65 5
a69 6
/* 
 * tp_input() gets an mbuf chain from ip.  Actually, not directly
 * from ip, because ip calls a net-level routine that strips off
 * the net header and then calls tp_input(), passing the proper type
 * of addresses for the address family in use (how it figures out
 * which AF is not yet determined.)
d72 3
a74 3
 * parameters and the problem of non-aligned memory references
 * necessitates such abominations as the macros WHILE_OPTIONS (q.v. below)
 * to loop through the header and decompose it.
d78 6
a83 6
 * "child" socket.  Most tpcb values are copied from the parent tpcb into
 * the child.
 * 
 * Also in here is tp_headersize() (grot) which tells the expected size
 * of a tp header, to be used by other layers.  It's in here because it
 * uses the static structure tpdu_info.
d97 2
d109 2
a111 1
#include <net/if.h>
d120 1
a120 1
int 	iso_check_csum(), tp_driver(), tp_headersize(), tp_error_emit();
d122 2
a123 6
/*
	#ifdef lint
	#undef ATTR
	#define ATTR(X)ev_number
	#endif lint
*/
d125 2
a126 2
struct mbuf *
tp_inputprep(m) 
d129 1
a129 1
	int hdrlen;
d131 18
a148 17
	IFDEBUG(D_TPINPUT)
		printf("tp_inputprep: m 0x%x\n", m) ;
	ENDDEBUG

	while(  m->m_len < 1 ) {
	    /* The "m_free" logic
	     * if( (m = m_free(m)) == MNULL )
	     *      return (struct mbuf *)0;
		 * would cause a system crash if ever executed.
		 * This logic will be executed if the first mbuf
	     * in the chain only contains a CLNP header. The m_free routine
	     * will release the mbuf containing the CLNP header from the
	     * chain and the new head of the chain will not have the
	     * M_PKTHDR bit set. This routine, tp_inputprep, will
	     * eventually call the "sbappendaddr" routine. "sbappendaddr"
	     * calls "panic" if M_PKTHDR is not set. m_pullup is a cheap
	     * way of keeping the head of the chain from being freed.
d150 1
a150 1
		if((m = m_pullup(m, 1)) == MNULL)
d153 4
a156 4
	if(((long)m->m_data) & 0x3) {
		/* If we are not 4-byte aligned, we have to be
		 * above the beginning of the mbuf, and it is ok just
		 * to slide it back. 
d158 1
a158 1
		caddr_t ocp = m->m_data;
d160 2
a161 2
		m->m_data = (caddr_t)(((long)m->m_data) & ~0x3);
		bcopy(ocp, m->m_data, (unsigned)m->m_len);
d165 4
a168 2
	/* we KNOW that there is at least 1 byte in this mbuf
	   and that it is hdr->tpdu_li XXXXXXX!  */
d170 1
a170 1
	hdrlen = 1 + *mtod( m, u_char *);
d173 1
a173 1
	 * now pull up the whole tp header 
d175 2
a176 2
	if ( m->m_len < hdrlen) {
		if ((m = m_pullup(m, hdrlen)) == MNULL ) {
d178 1
a178 1
			return (struct mbuf *)0;
d181 7
a187 5
	IFDEBUG(D_INPUT)
	printf(
	" at end: m 0x%x hdr->tpdu_li 0x%x m_len 0x%x\n",m,
		hdrlen, m->m_len);
	ENDDEBUG
d191 5
a195 5
/* begin groan
 * -- this array and the following macros allow you to step through the
 * parameters of the variable part of a header
 * note that if for any reason the values of the **_TPDU macros (in tp_events.h)
 * should change, this array has to be rearranged
d201 1
a201 1
static u_char tpdu_info[][4] =
d203 18
a220 18
/*								length						 max data len */
/*								reg fmt 	xtd fmt  class 0  		 	  */
 	/* UNUSED		0x0 */		0x0 ,		0x0,	0x0,		0x0,
 	/* XPD_TPDU_type 0x1 */		0x5,		0x8,	0x0,		TP_MAX_XPD_DATA,
 	/* XAK_TPDU_type 0x2 */		0x5 ,		0x8,	0x0,		0x0,
 	/* GR_TPDU_type	0x3 */		0x0 ,		0x0,	0x0,		0x0,
 	/* UNUSED		0x4 */		0x0 ,		0x0,	0x0,		0x0,
 	/* UNUSED		0x5 */		0x0 ,		0x0,	0x0,		0x0,
 	/* AK_TPDU_type 0x6 */		0x5,		0xa,	0x0,		0x0,
	/* ER_TPDU_type 0x7 */		0x5,		0x5,	0x0,		0x0,
 	/* DR_TPDU_type 0x8 */		0x7,		0x7,	0x7,		TP_MAX_DR_DATA,
 	/* UNUSED		0x9 */		0x0 ,		0x0,	0x0,		0x0,
 	/* UNUSED		0xa */		0x0 ,		0x0,	0x0,		0x0,
 	/* UNUSED		0xb */		0x0 ,		0x0,	0x0,		0x0,
 	/* DC_TPDU_type 0xc */		0x6,		0x6,	0x0,		0x0,
 	/* CC_TPDU_type 0xd */		0x7,		0x7,	0x7,		TP_MAX_CC_DATA,
 	/* CR_TPDU_type 0xe */		0x7,		0x7,	0x7,		TP_MAX_CR_DATA,
 	/* DT_TPDU_type 0xf */		0x5,		0x8,	0x3,		0x0,
d227 3
a229 3
/* 
 * WHENEVER YOU USE THE FOLLOWING MACRO,
 * BE SURE THE TPDUTYPE IS A LEGIT VALUE FIRST! 
d267 5
a271 5
	struct socket				*so;
	struct sockaddr				*fname;
	caddr_t						cons_channel;
	u_char						class_to_use;
	u_int						netservice;
d273 3
a275 2
	register struct tp_pcb	*tpcb = sototpcb(so); /* old tpcb, needed below */
	register struct tp_pcb	*newtpcb;
d277 3
a279 4
	/* 
	 * sonewconn() gets a new socket structure,
	 * a new lower layer pcb and a new tpcb,
	 * but the pcbs are unnamed (not bound)
d281 2
a282 1
	IFTRACE(D_NEWSOCK)
d284 3
a286 2
			so, tpcb, so->so_head, 0);
	ENDTRACE	
d288 1
a288 1
	if ((so = sonewconn(so, SS_ISCONFIRMING)) == (struct socket *)0)
d290 2
a291 1
	IFTRACE(D_NEWSOCK)
d293 3
a295 2
			so, so->so_head, 0, 0);
	ENDTRACE	
d297 2
a298 1
	IFDEBUG(D_NEWSOCK)
d300 1
a300 1
				cons_channel, so);
d302 2
a303 2
		{ 
			struct socket *t, *head ;
d308 2
a309 2
					t, t->so_head, t->so_q0, t->so_q0len);
			while( (t=t->so_q0)  && t!= so  && t!= head)
d311 1
a311 1
					t, t->so_head, t->so_q0, t->so_q0len);
d313 2
a314 1
	ENDDEBUG
d316 3
a318 2
	/* 
	 * before we clobber the old tpcb ptr, get these items from the parent pcb 
d326 1
a326 1
	bcopy( tpcb->tp_lsuffix, newtpcb->tp_lsuffix, newtpcb->tp_lsuffixlen);
d328 4
a331 3
	if( /* old */ tpcb->tp_ucddata) {
		/* 
		 * These data are the connect- , confirm- or disconnect- data.
d333 1
a333 1
		struct mbuf *conndata;
d335 3
a337 2
		conndata = m_copy(tpcb->tp_ucddata, 0, (int)M_COPYALL);
		IFDEBUG(D_CONN)
d339 2
a340 1
		ENDDEBUG
a342 1

d349 2
a350 2
	ASSERT( fname != 0 ) ; /* just checking */
	if ( fname ) {
d354 2
a355 2
		struct mbuf	*m;
		int			err;
d357 2
a358 1
		MGET(m, M_DONTWAIT, MT_SONAME);	/* mbuf type used is confusing */
d366 1
a366 1
			bcopy((caddr_t)fname, mtod(m, caddr_t), fname->sa_len);
d369 3
a371 2
			/* grot  : have to say the kernel can override params in
			 * the passive open case
d374 1
a374 1
			err = tp_route_to( m, tpcb, cons_channel);
d380 2
a381 1
		IFDEBUG(D_CONN)
d383 4
a386 3
				tpcb, so);
		ENDDEBUG
		(void) tp_detach(tpcb); 
d390 2
a391 1
	IFDEBUG(D_TPINPUT)
d393 3
a395 2
			so, sototpcb(so));
	ENDDEBUG
d399 1
a399 8
#ifndef TPCONS
tpcons_output()
{
	return(0);
}
#endif /* !CONS */

/* 
d402 5
a406 2
 * CALLED FROM:
 *  net layer input routine
d408 2
a409 7
 * FUNCTION and ARGUMENTS:
 *  Process an incoming TPDU (m), finding the associated tpcb if there
 *  is one. Create the appropriate type of event and call the driver.
 *  (faddr) and (laddr) are the foreign and local addresses.
 * 
 * 	When tp_input() is called we KNOW that the ENTIRE TP HEADER
 * 	has been m_pullup-ed.
a411 3
 *  
 * SIDE EFFECTS:
 *	When using COSNS it may affect the state of the net-level pcb
d413 6
a418 6
 * NOTE:
 *  The initial value of acktime is 2 so that we will never
 *  have a 0 value for tp_peer_acktime.  It gets used in the
 *  computation of the retransmission timer value, and so it
 *  mustn't be zero.
 *  2 seems like a reasonable minimum.
d421 7
a427 7
tp_input(m, faddr, laddr, cons_channel, dgout_routine, ce_bit)
	register	struct mbuf 	*m;
	struct sockaddr 			*faddr, *laddr; /* NSAP addresses */
	caddr_t						cons_channel;
	int 						(*dgout_routine)();
	int							ce_bit;

d429 13
a441 9
	register struct tp_pcb 	*tpcb;
	register struct tpdu 	*hdr;
	struct socket 			*so;
	struct tp_event 		e;
	int 					error;
	unsigned 				dutype;
	u_short 				dref, sref, acktime, subseq;
	u_char 					preferred_class, class_to_use, pdusize;
	u_char					opt, dusize, addlopt, version;
d443 19
a461 10
	u_char					perf_meas;
#endif /* TP_PERF_MEAS */
	u_char					fsufxlen, lsufxlen;
	caddr_t					fsufxloc, lsufxloc;
	int						tpdu_len;
	u_int 					takes_data;
	u_int					fcc_present; 
	int						errlen;
	struct tp_conn_param 	tpp;
	int						tpcons_output();
d468 2
a469 1
	acktime = 2; sref = subseq = 0;
d475 6
a480 4
	GET_CUR_TIME( &e.e_time ); perf_meas = 0;
#endif /* TP_PERF_MEAS */
	
	IFDEBUG(D_TPINPUT)
d482 2
a483 1
	ENDDEBUG
d486 4
a489 4
	/* 
	 * get the actual tpdu length - necessary for monitoring
	 * and for checksumming
	 * 
d493 5
a497 4
	{ 	register struct mbuf *n=m;
#	ifdef ARGO_DEBUG
		int chain_length = 0;
#	endif ARGO_DEBUG
d499 1
a499 1
		for(;;) {
d501 3
a503 2
			IFDEBUG(D_MBUF_MEAS)
				if( n->m_flags & M_EXT) {
d508 4
a511 3
				chain_length ++;
			ENDDEBUG
			if (n->m_next == MNULL ) {
d516 15
a530 14
		IFDEBUG(D_MBUF_MEAS)
			if(chain_length > 16)
				chain_length = 0; /* zero used for anything > 16 */
			tp_stat.ts_mb_len_distr[chain_length] ++;
		ENDDEBUG
	}
	IFTRACE(D_TPINPUT)
		tptraceTPCB(TPPTtpduin, hdr->tpdu_type, hdr, hdr->tpdu_li+1, tpdu_len, 
			0);
	ENDTRACE

	dref = ntohs((short)hdr->tpdu_dref);
	sref = ntohs((short)hdr->tpdu_sref);
	dutype = (int)hdr->tpdu_type;
d532 6
a537 1
	IFDEBUG(D_TPINPUT)
d539 1
a539 1
			cons_channel, dref);
d541 5
a545 3
	ENDDEBUG
	IFTRACE(D_TPINPUT)
		tptrace(TPPTmisc, "channel dutype dref ", 
d547 2
a548 1
	ENDTRACE
d552 1
a552 1
	if( (dutype < TP_MIN_TPDUTYPE) || (dutype > TP_MAX_TPDUTYPE)) {
d554 2
a555 2
			dutype, cons_channel, dref);
		dump_buf (m, sizeof( struct mbuf ));
d560 1
a560 1
#endif /* ARGO_DEBUG */
d562 7
a568 6
	CHECK( (dutype < TP_MIN_TPDUTYPE || dutype > TP_MAX_TPDUTYPE),
		E_TP_INV_TPDU, ts_inv_dutype, respond, 
		2 );
		/* unfortunately we can't take the address of the tpdu_type field,
		 * since it's a bit field - so we just use the constant offset 2
		 */
d570 4
a573 3
	/* Now this isn't very neat but since you locate a pcb one way
	 * at the beginning of connection establishment, and by
	 * the dref for each tpdu after that, we have to treat CRs differently
d575 2
a576 2
	if ( dutype == CR_TPDU_type ) {
		u_char alt_classes = 0;
d581 2
a582 1
		WHILE_OPTIONS(P, hdr, 1 ) /* { */
d584 18
a601 10
			switch( vbptr(P)->tpv_code ) {

			case	TPP_tpdu_size: 		
				vb_getval(P, u_char, dusize);
				IFDEBUG(D_TPINPUT)
					printf("CR dusize 0x%x\n", dusize);
				ENDDEBUG
				/* COS tests: NBS IA (Dec. 1987) Sec. 4.5.2.1 */
				if (dusize < TP_MIN_TPDUSIZE || dusize > TP_MAX_TPDUSIZE)
						dusize = TP_DFL_TPDUSIZE;
d603 3
a605 6
			case	TPP_ptpdu_size:
				switch (vbptr(P)->tpv_len) {
				case 1: pdusize = vbval(P, u_char); break;
				case 2: pdusize = ntohs(vbval(P, u_short)); break;
				default: ;
				IFDEBUG(D_TPINPUT)
a606 1
				ENDDEBUG
d608 20
a627 17
				break;
			case	TPP_addl_opt:
				vb_getval(P, u_char, addlopt);
				break;
			case	TPP_calling_sufx:
				/* could use vb_getval, but we want to save the loc & len
				 * for later use
				 */
				fsufxloc = (caddr_t) &vbptr(P)->tpv_val;
				fsufxlen = vbptr(P)->tpv_len;
				IFDEBUG(D_TPINPUT)
					printf("CR fsufx:");
					{ register int j;
						for(j=0; j<fsufxlen; j++ ) {
							printf(" 0x%x. ", *((caddr_t)(fsufxloc+j)) );
						}
						printf("\n");
d629 19
a647 15
				ENDDEBUG
				break;
			case	TPP_called_sufx:
				/* could use vb_getval, but we want to save the loc & len
				 * for later use
				 */
				lsufxloc = (caddr_t) &vbptr(P)->tpv_val;
				lsufxlen = vbptr(P)->tpv_len;
				IFDEBUG(D_TPINPUT)
					printf("CR lsufx:");
					{ register int j;
						for(j=0; j<lsufxlen; j++ ) {
							printf(" 0x%x. ", *((u_char *)(lsufxloc+j)) );
						}
						printf("\n");
d649 5
a653 2
				ENDDEBUG
				break;
d656 4
a659 4
			case	TPP_perf_meas:
				vb_getval(P, u_char, perf_meas);
				break;
#endif /* TP_PERF_MEAS */
d661 26
a686 19
			case	TPP_vers:
				/* not in class 0; 1 octet; in CR_TPDU only */
				/* COS tests says if version wrong, use default version!?XXX */
				CHECK( (vbval(P, u_char) != TP_VERSION ), 
					E_TP_INV_PVAL, ts_inv_pval, setversion,
					(1 + (caddr_t)&vbptr(P)->tpv_val - (caddr_t)hdr) );
			setversion:
				version = vbval(P, u_char);
				break;
			case	TPP_acktime:
				vb_getval(P, u_short, acktime);
				acktime = ntohs(acktime);
				acktime = acktime/500; /* convert to slowtimo ticks */
				if((short)acktime <=0 )
					acktime = 2; /* don't allow a bad peer to screw us up */
				IFDEBUG(D_TPINPUT)
					printf("CR acktime 0x%x\n", acktime);
				ENDDEBUG
				break;
d688 18
a705 18
			case	TPP_alt_class:
				{
					u_char *aclass = 0;
					register int i;
					static u_char bad_alt_classes[5] =
						{ ~0, ~3, ~5, ~0xf, ~0x1f};

					aclass = 
						(u_char *) &(((struct tp_vbp *)P)->tpv_val);
					for (i = ((struct tp_vbp *)P)->tpv_len; i>0; i--) {
						alt_classes |= (1<<((*aclass++)>>4));
					}
					CHECK( (bad_alt_classes[hdr->tpdu_CRclass] & alt_classes),
						E_TP_INV_PVAL, ts_inv_aclass, respond,
						((caddr_t)aclass) - (caddr_t)hdr);
					IFDEBUG(D_TPINPUT)
						printf("alt_classes 0x%x\n", alt_classes);
					ENDDEBUG
d707 3
a709 1
				break;
d711 16
a726 14
			case	TPP_security:
			case	TPP_residER:
			case	TPP_priority:
			case	TPP_transdelay:
			case	TPP_throughput: 
			case	TPP_addl_info: 
			case	TPP_subseq:
			default:
				IFDEBUG(D_TPINPUT)
					printf("param ignored CR_TPDU code= 0x%x\n",
						 vbptr(P)->tpv_code);
				ENDDEBUG
				IncStat(ts_param_ignored);
				break;
d728 4
a731 12
			case	TPP_checksum:		
				IFDEBUG(D_TPINPUT)
					printf("CR before cksum\n");
				ENDDEBUG

				CHECK( iso_check_csum(m, tpdu_len), 
					E_TP_INV_PVAL, ts_bad_csum, discard, 0)

				IFDEBUG(D_TPINPUT)
					printf("CR before cksum\n");
				ENDDEBUG
				break;
d733 1
d735 9
a743 1
		/* } */ END_WHILE_OPTIONS(P)
d745 2
a746 1
		if (lsufxlen == 0) {
d748 1
a748 1
			error =  E_TP_LENGTH_INVAL;
d764 1
a764 1
			for (t = tp_listeners; t ; t = t->tp_nextlisten)
d766 6
a771 6
					 (lsufxlen == t->tp_lsuffixlen &&
					  bcmp(lsufxloc, t->tp_lsuffix, lsufxlen) == 0)) &&
					((t->tp_flags & TPF_GENERAL_ADDR) ||
					 (laddr->sa_family == t->tp_domain &&
					  (*t->tp_nlproto->nlp_cmpnetaddr)
								(t->tp_npcb, laddr, TP_LOCAL))))
d775 8
a782 5
				(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))
				/* _tpduf is the fixed part; add 2 to get the dref bits of 
				 * the fixed part (can't take the address of a bit field) 
				 */
			IFDEBUG(D_TPINPUT)
d784 2
a785 1
			ENDDEBUG
d790 4
a793 3
				if ((*tpcb->tp_nlproto->nlp_cmpnetaddr)(
						t->tp_npcb, faddr, TP_FOREIGN)) {
					IFDEBUG(D_TPINPUT)
d795 2
a796 1
					ENDDEBUG
d800 3
a802 2
			IFTRACE(D_TPINPUT)
				tptrace(TPPTmisc, "tp_input: tpcb *lsufxloc tpstate", 
d804 2
a805 1
			ENDTRACE
d808 4
a811 5
		/* 
		 * WE HAVE A TPCB 
		 * already know that the classes in the CR match at least
		 * one class implemented, but we don't know yet if they
		 * include any classes permitted by this server.
d814 2
a815 1
		IFDEBUG(D_TPINPUT)
d817 4
a820 2
		ENDDEBUG
		IFDEBUG(D_CONN)
d822 4
a825 3
"CR: bef CHKS: flags 0x%x class_to_use 0x%x alt 0x%x opt 0x%x tp_class 0x%x\n", 
				tpcb->tp_flags, class_to_use, alt_classes, opt, tpcb->tp_class);
		ENDDEBUG
d828 1
a828 1
		if( (class_to_use = preferred_class & tpcb->tp_class) == 0 )
d840 1
a840 1
			tpp.p_use_checksum = (tpp.p_class == TP_CLASS_0)?0:
d847 1
a847 1
#endif /* notdef */
d849 2
a850 2
		CHECK(
			tp_consistency(tpcb, 0 /* not force or strict */, &tpp) != 0, 
d852 3
a854 3
			(1 + 2 + (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr) 
				/* ^ more or less the location of class */
			)
d856 5
a860 4
		IFTRACE(D_CONN)
			tptrace(TPPTmisc, 
				"after 1 consist class_to_use class, out, tpconsout",
				class_to_use, 
d862 5
a866 4
				);
		ENDTRACE
		CHECK(
			((class_to_use == TP_CLASS_0)&&(dgout_routine != tpcons_output)),
d868 2
a869 2
			(1 + 2 + (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr) 
				/* ^ more or less the location of class */
d871 6
a876 4
		IFDEBUG(D_CONN)
			printf("CR: after CRCCCHECKS: tpcb 0x%x, flags 0x%x\n", 
				tpcb, tpcb->tp_flags);
		ENDDEBUG
d878 1
a878 1
		e.ATTR(CR_TPDU).e_cdt  =  hdr->tpdu_CRcdt;
d883 4
a886 4
			struct tp_pcb *parent_tpcb = tpcb;
			/* 
			 * Create a socket, tpcb, ll pcb, etc. 
			 * for this newborn connection, and fill in all the values. 
d888 2
a889 1
			IFDEBUG(D_CONN)
d891 13
a903 11
					so, laddr, faddr, cons_channel);
			ENDDEBUG
			if( (so = 
				tp_newsocket(so, faddr, cons_channel, 
					class_to_use, 
					((tpcb->tp_netservice == IN_CLNS) ? IN_CLNS :
					(dgout_routine == tpcons_output)?ISO_CONS:ISO_CLNS))
					) == (struct socket *)0 ) {
				/* note - even if netservice is IN_CLNS, as far as
				 * the tp entity is concerned, the only differences
				 * are CO vs CL
d905 2
a906 1
				IFDEBUG(D_CONN)
d908 2
a909 1
				ENDDEBUG
d911 1
a911 1
			clear_parent_tcb:
d919 1
a919 1
			 * Stash the addresses in the net level pcb 
d923 2
a924 2
			(tpcb->tp_nlproto->nlp_putnetaddr)(tpcb->tp_npcb, faddr, TP_FOREIGN);
			(tpcb->tp_nlproto->nlp_putnetaddr)(tpcb->tp_npcb, laddr, TP_LOCAL);
d927 1
a927 1
			if (tpcb->tp_fsuffixlen = fsufxlen) {
d930 1
a930 1
						(tpcb->tp_npcb, fsufxloc, fsufxlen, TP_FOREIGN);
d936 1
a936 1
					(tpcb->tp_npcb, lsufxloc, lsufxlen, TP_LOCAL);
d938 4
a941 3
			if( tpcb->tp_perf_on = perf_meas ) { /* assignment */
				/* ok, let's create an mbuf for stashing the
				 * statistics if one doesn't already exist 
d945 1
a945 1
#endif /* TP_PERF_MEAS */
d948 6
a953 4
			/* We've already checked for consistency with the options 
			 * set in tpp,  but we couldn't set them earlier because 
			 * we didn't want to change options in the LISTENING tpcb.
			 * Now we set the options in the new socket's tpcb.
d955 1
a955 1
			(void) tp_consistency( tpcb, TP_FORCE, &tpp);
d957 1
a957 1
			if(!tpcb->tp_use_checksum)
d959 1
a959 1
			if(tpcb->tp_xpd_service)
d961 1
a961 1
			if(tpcb->tp_xtd_format)
d966 4
a969 3
			/* 
			 * The following kludge is used to test retransmissions and 
			 * timeout during connection establishment.
d971 2
a972 1
			IFDEBUG(D_ZDREF)
d974 3
a976 2
				/*tpcb->tp_fref = 0;*/
			ENDDEBUG
d986 8
a993 10
	} else if ( dutype == ER_TPDU_type ) {
		/* 
		 * ER TPDUs have to be recognized separately
		 * because they don't necessarily have a tpcb
		 * with them and we don't want err out looking for such
		 * a beast.
		 * We could put a bunch of little kludges in the 
		 * next section of code so it would avoid references to tpcb
		 * if dutype == ER_TPDU_type but we don't want code for ERs to
		 * mess up code for data transfer.
d997 6
a1002 7
		e.ATTR(ER_TPDU).e_reason =  (u_char)hdr->tpdu_ERreason;
		CHECK (((int)dref <= 0 || dref >= tp_refinfo.tpr_size || 
			(tpcb = tp_ref[dref].tpr_pcb ) == (struct tp_pcb *) 0 ||
			tpcb->tp_refstate == REF_FREE ||
			tpcb->tp_refstate == REF_FROZEN),
		       E_TP_MISM_REFS, ts_inv_dref, discard, 0)

d1006 4
a1009 3
		/* In the next 4 checks,
		 * _tpduf is the fixed part; add 2 to get the dref bits of 
		 * the fixed part (can't take the address of a bit field) 
d1013 2
a1014 2
			struct isopcb *isop = ((struct isopcb *)
				((struct pklcd *)cons_channel)->lcd_upnext);
d1016 4
a1019 3
				(tpcb = sototpcb(isop->isop_socket)) &&
				 (tpcb->tp_class == TP_CLASS_0/* || == CLASS_1 */)) {
				IFDEBUG(D_TPINPUT)
d1021 2
a1022 1
				ENDDEBUG
d1025 4
a1028 4
				CHECK( (tpcb->tp_refstate == REF_FREE), 
					E_TP_MISM_REFS,ts_inv_dref, nonx_dref,
					(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))
				goto tp0_data;
a1029 1

d1034 9
a1042 9
			CHECK( ((int)dref <= 0 || dref >= tp_refinfo.tpr_size) ,
				E_TP_MISM_REFS,ts_inv_dref, nonx_dref,
				(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))
			CHECK( ((tpcb = tp_ref[dref].tpr_pcb ) == (struct tp_pcb *) 0 ), 
				E_TP_MISM_REFS,ts_inv_dref, nonx_dref,
				(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))
			CHECK( (tpcb->tp_refstate == REF_FREE), 
				E_TP_MISM_REFS,ts_inv_dref, nonx_dref,
				(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))
d1045 2
a1046 1
		IFDEBUG(D_TPINPUT)
d1048 2
a1049 1
		ENDDEBUG
d1052 16
a1067 15
		CHECK( (tpcb->tp_refstate == REF_FROZEN),
			(dutype == CC_TPDU_type?E_TP_NO_SESSION:E_TP_MISM_REFS),
			ts_inv_dref, respond,
			(1 + 2 + (caddr_t)&hdr->_tpduf - (caddr_t)hdr))

		IFDEBUG(D_TPINPUT)
			printf("state of dref %d ok, tpcb 0x%x\n", dref,tpcb);
		ENDDEBUG
		/* 
		 * At this point the state of the dref could be
		 * FROZEN: tpr_pcb == NULL,  has ( reference only) timers
		 *		   for example, DC may arrive after the close() has detached
		 *         the tpcb (e.g., if user turned off SO_LISTEN option)
		 * OPENING : a tpcb exists but no timers yet
		 * OPEN  : tpcb exists & timers are outstanding
d1070 2
a1071 2
        if (!tpcb->tp_cebit_off)
            CONG_UPDATE_SAMPLE(tpcb, ce_bit);
d1076 1
a1076 3
		dutype = hdr->tpdu_type << 8; /* for the switch below */ 

		WHILE_OPTIONS(P, hdr, tpcb->tp_xtd_format) /* { */
d1078 1
d1080 1
a1080 1
		switch( dutype | vbptr(P)->tpv_code ) {
d1082 25
a1106 3
			caseof( CC_TPDU_type, TPP_addl_opt ): 
					/* not in class 0; 1 octet */
					vb_getval(P, u_char, addlopt);
d1108 2
a1109 12
			caseof( CC_TPDU_type, TPP_tpdu_size ): 
				{
					u_char odusize = dusize;
					vb_getval(P, u_char, dusize);
					CHECK( (dusize < TP_MIN_TPDUSIZE ||
							dusize > TP_MAX_TPDUSIZE || dusize > odusize),
						E_TP_INV_PVAL, ts_inv_pval, respond,
						(1 + (caddr_t)&vbptr(P)->tpv_val - (caddr_t)hdr) )
					IFDEBUG(D_TPINPUT)
						printf("CC dusize 0x%x\n", dusize);
					ENDDEBUG
				}
d1111 3
a1113 8
			caseof( CC_TPDU_type, TPP_ptpdu_size ): 
				{
					u_short opdusize = pdusize;
					switch (vbptr(P)->tpv_len) {
					case 1: pdusize = vbval(P, u_char); break;
					case 2: pdusize = ntohs(vbval(P, u_short)); break;
					default: ;
					IFDEBUG(D_TPINPUT)
a1114 1
					ENDDEBUG
d1116 1
a1116 4
					CHECK( (pdusize == 0 ||
							(opdusize && (pdusize > opdusize))),
						E_TP_INV_PVAL, ts_inv_pval, respond,
						(1 + (caddr_t)&vbptr(P)->tpv_val - (caddr_t)hdr) )
d1118 33
a1150 23
					break;
			caseof( CC_TPDU_type, TPP_calling_sufx):
					IFDEBUG(D_TPINPUT)
						printf("CC calling (local) sufxlen 0x%x\n", lsufxlen);
					ENDDEBUG
					lsufxloc = (caddr_t) &vbptr(P)->tpv_val;
					lsufxlen = vbptr(P)->tpv_len;
					break;
			caseof(	CC_TPDU_type, TPP_acktime ):
					/* class 4 only, 2 octets */
					vb_getval(P, u_short, acktime);
					acktime = ntohs(acktime);
					acktime = acktime/500; /* convert to slowtimo ticks */
					if( (short)acktime <=0 )
						acktime = 2;
					break;
			caseof(	CC_TPDU_type, TPP_called_sufx):
					fsufxloc = (caddr_t) &vbptr(P)->tpv_val;
					fsufxlen = vbptr(P)->tpv_len;
					IFDEBUG(D_TPINPUT)
						printf("CC called (foreign) sufx len %d\n", fsufxlen);
					ENDDEBUG
					break;
d1152 9
a1160 9
			caseof( CC_TPDU_type,	TPP_checksum):		
			caseof( DR_TPDU_type,	TPP_checksum):		
			caseof( DT_TPDU_type,	TPP_checksum):		
			caseof( XPD_TPDU_type,	TPP_checksum):		
					if( tpcb->tp_use_checksum )  {
						CHECK( iso_check_csum(m, tpdu_len), 
							E_TP_INV_PVAL, ts_bad_csum, discard, 0)
					}
					break;
d1162 4
a1165 2
			/*  this is different from the above because in the context
			 *  of concat/ sep tpdu_len might not be the same as hdr len 
d1167 8
a1174 8
			caseof( AK_TPDU_type,	TPP_checksum):		
			caseof( XAK_TPDU_type,	TPP_checksum):		
			caseof( DC_TPDU_type,	TPP_checksum):		
					if( tpcb->tp_use_checksum )  {
						CHECK( iso_check_csum(m, (int)hdr->tpdu_li + 1), 
							E_TP_INV_PVAL, ts_bad_csum, discard, 0)
					}
					break;
d1176 8
a1183 7
			caseof( DR_TPDU_type, TPP_addl_info ):
				/* ignore - its length and meaning are
				 * user defined and there's no way
				 * to pass this info to the user anyway
				 */
				break;
#endif /* notdef */
d1185 10
a1194 8
			caseof( AK_TPDU_type, TPP_subseq ):
				/* used after reduction of window */
				vb_getval(P, u_short, subseq);
				subseq = ntohs(subseq);
				IFDEBUG(D_ACKRECV)
					printf("AK dref 0x%x Subseq 0x%x\n", dref, subseq);
				ENDDEBUG
				break;
d1196 4
a1199 4
			caseof( AK_TPDU_type, TPP_flow_cntl_conf ):
				{
					u_int 	ylwe;
					u_short ysubseq, ycredit;
d1201 11
a1211 11
					fcc_present = TRUE;
					vb_getval(P, u_int,	 	ylwe);
					vb_getval(P, u_short, 	ysubseq);
					vb_getval(P, u_short, 	ycredit);
					ylwe = ntohl(ylwe);
					ysubseq = ntohs(ysubseq);
					ycredit = ntohs(ycredit);
					IFDEBUG(D_ACKRECV)
						printf("%s%x, subseq 0x%x, cdt 0x%x dref 0x%x\n", 
							"AK FCC lwe 0x", ylwe, ysubseq, ycredit, dref);
					ENDDEBUG
d1213 3
a1215 1
				break;
d1217 15
a1231 11
			default: 
				IFDEBUG(D_TPINPUT)
					printf("param ignored dutype 0x%x, code  0x%x\n",
						dutype, vbptr(P)->tpv_code);
				ENDDEBUG
				IFTRACE(D_TPINPUT)
					tptrace(TPPTmisc, "param ignored dutype code ",
						dutype, vbptr(P)->tpv_code ,0,0);
				ENDTRACE
				IncStat(ts_param_ignored);
				break;
d1234 1
a1234 2
		/* } */ END_WHILE_OPTIONS(P)

d1237 4
a1240 3
		switch( hdr->tpdu_type ) {
		case CC_TPDU_type: 
			/* If CC comes back with an unacceptable class
d1244 1
a1244 1
			opt = hdr->tpdu_CCoptions; /* 1 byte */
d1248 1
a1248 1
				tpp.p_class = (1<<hdr->tpdu_CCclass);
d1259 1
a1259 1
#endif /* notdef */
d1261 11
a1271 10
			CHECK(
				tp_consistency(tpcb, TP_FORCE, &tpp) != 0, 
				E_TP_NEGOT_FAILED, ts_negotfailed, respond,
				(1 + 2 + (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr) 
					/* ^ more or less the location of class */
				)
			IFTRACE(D_CONN)
				tptrace(TPPTmisc, 
					"after 1 consist class, out, tpconsout",
					tpcb->tp_class, dgout_routine, tpcons_output, 0
d1273 9
a1281 8
			ENDTRACE
			CHECK(
				((class_to_use == TP_CLASS_0)&&
					(dgout_routine != tpcons_output)),
				E_TP_NEGOT_FAILED, ts_negotfailed, respond,
				(1 + 2 + (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr) 
					/* ^ more or less the location of class */
				)
d1283 4
a1286 4
				if (tpcb->tp_netservice == ISO_CONS &&
					class_to_use == TP_CLASS_0) {
					struct isopcb *isop = (struct isopcb *)tpcb->tp_npcb;
					struct pklcd *lcp = (struct pklcd *)isop->isop_chan;
d1291 1
a1291 1
			if( ! tpcb->tp_use_checksum)
d1293 1
a1293 1
			if(tpcb->tp_xpd_service)
d1295 1
a1295 1
			if(tpcb->tp_xtd_format)
d1298 2
a1299 1
			IFTRACE(D_CONN)
d1301 1
a1301 1
					tpcb->tp_class, tpcb->tp_flags, tpcb->tp_tpdusize, 
d1303 2
a1304 1
			ENDTRACE
d1306 2
a1307 1
			/* if called or calling suffices appeared on the CC, 
d1310 5
a1314 11
			if( fsufxlen ) {
				CHECK( ((tpcb->tp_fsuffixlen != fsufxlen) ||
					bcmp(fsufxloc, tpcb->tp_fsuffix, fsufxlen)),
					E_TP_INV_PVAL,ts_inv_sufx, respond, 
					(1+fsufxloc - (caddr_t)hdr))
			}
			if( lsufxlen ) {
				CHECK( ((tpcb->tp_lsuffixlen != lsufxlen) ||
					bcmp(lsufxloc, tpcb->tp_lsuffix, lsufxlen)),
					E_TP_INV_PVAL,ts_inv_sufx, respond, 
					(1+lsufxloc - (caddr_t)hdr))
d1316 8
a1323 3

			e.ATTR(CC_TPDU).e_sref =  sref;
			e.ATTR(CC_TPDU).e_cdt  =  hdr->tpdu_CCcdt;
d1332 6
a1337 7
					sref, tpcb->tp_fref);
					
			CHECK( (sref != tpcb->tp_fref), 
				E_TP_MISM_REFS, ts_inv_sufx, discard,
				(1 + (caddr_t)&hdr->tpdu_DCsref - (caddr_t)hdr))
		
			e.ev_number = DC_TPDU;
d1341 3
a1343 2
		case DR_TPDU_type: 
			IFTRACE(D_TPINPUT)
d1345 3
a1347 2
			ENDTRACE
			if (sref != tpcb->tp_fref) {
d1349 1
a1349 1
					sref, tpcb->tp_fref);
d1351 6
a1356 8
					
			CHECK( (sref != 0 && sref != tpcb->tp_fref &&
					tpcb->tp_state != TP_CRSENT), 
				(TP_ERROR_SNDC | E_TP_MISM_REFS),ts_inv_sufx, respond,
				(1 + (caddr_t)&hdr->tpdu_DRsref - (caddr_t)hdr))

			e.ATTR(DR_TPDU).e_reason = hdr->tpdu_DRreason;
			e.ATTR(DR_TPDU).e_sref =  (u_short)sref;
d1363 7
a1369 5
			IFTRACE(D_TPINPUT)
				tptrace(TPPTmisc, "ER recvd", hdr->tpdu_ERreason,0,0,0);
			ENDTRACE
			e.ev_number = ER_TPDU;
			e.ATTR(ER_TPDU).e_reason = hdr->tpdu_ERreason;
d1373 1
a1373 1
		case AK_TPDU_type: 
d1375 2
a1376 2
			e.ATTR(AK_TPDU).e_subseq = subseq;
			e.ATTR(AK_TPDU).e_fcc_present = fcc_present;
d1380 1
a1380 1
				union seq_type seqeotX;
d1383 2
a1384 2
				e.ATTR(AK_TPDU).e_seq = seqeotX.s_seq;
				e.ATTR(AK_TPDU).e_cdt = ntohs(hdr->tpdu_AKcdtX);
d1386 3
a1388 3
				e.ATTR(AK_TPDU).e_cdt = hdr->tpdu_AKcdtX;
				e.ATTR(AK_TPDU).e_seq = hdr->tpdu_AKseqX;
#endif /* BYTE_ORDER */
d1390 2
a1391 2
				e.ATTR(AK_TPDU).e_cdt = hdr->tpdu_AKcdt;
				e.ATTR(AK_TPDU).e_seq = hdr->tpdu_AKseq;
d1393 4
a1396 3
			IFTRACE(D_TPINPUT)
				tptrace(TPPTmisc, "AK recvd seq cdt subseq fcc_pres", 
					e.ATTR(AK_TPDU).e_seq, e.ATTR(AK_TPDU).e_cdt,
d1398 2
a1399 1
			ENDTRACE
d1401 1
a1401 1
			e.ev_number = AK_TPDU;
d1406 1
a1406 1
		case XAK_TPDU_type: 
d1409 1
a1409 1
				union seq_type seqeotX;
d1412 1
a1412 1
				e.ATTR(XAK_TPDU).e_seq = seqeotX.s_seq;
d1414 2
a1415 2
				e.ATTR(XAK_TPDU).e_seq = hdr->tpdu_XAKseqX;
#endif /* BYTE_ORDER */
d1417 1
a1417 1
				e.ATTR(XAK_TPDU).e_seq = hdr->tpdu_XAKseq;
d1424 1
a1424 1
		case XPD_TPDU_type: 
d1427 1
a1427 1
				union seq_type seqeotX;
d1430 1
a1430 1
				e.ATTR(XPD_TPDU).e_seq = seqeotX.s_seq;
d1432 2
a1433 2
				e.ATTR(XPD_TPDU).e_seq = hdr->tpdu_XPDseqX;
#endif /* BYTE_ORDER */
d1435 1
a1435 1
				e.ATTR(XPD_TPDU).e_seq = hdr->tpdu_XPDseq;
d1444 13
a1456 10
			{ /* the y option will cause occasional packets to be dropped.
			   * A little crude but it works.
			   */

				IFDEBUG(D_DROP)
					if(time.tv_usec & 0x4 && hdr->tpdu_DTseq & 0x1) {
						IncStat(ts_ydebug);
						goto discard;
					}
				ENDDEBUG
d1458 1
d1460 5
a1464 3
			tp0_data:
				e.ATTR(DT_TPDU).e_seq = 0; /* actually don't care */
				e.ATTR(DT_TPDU).e_eot = (((struct tp0du *)hdr)->tp0du_eot);
d1467 1
a1467 1
				union seq_type seqeotX;
d1470 2
a1471 2
				e.ATTR(DT_TPDU).e_seq = seqeotX.s_seq;
				e.ATTR(DT_TPDU).e_eot = seqeotX.s_eot;
d1473 3
a1475 3
				e.ATTR(DT_TPDU).e_seq = hdr->tpdu_DTseqX;
				e.ATTR(DT_TPDU).e_eot = hdr->tpdu_DTeotX;
#endif /* BYTE_ORDER */
d1477 2
a1478 2
				e.ATTR(DT_TPDU).e_seq = hdr->tpdu_DTseq;
				e.ATTR(DT_TPDU).e_eot = hdr->tpdu_DTeot;
d1480 1
a1480 1
			if(e.ATTR(DT_TPDU).e_eot)
d1488 1
a1488 1
		case GR_TPDU_type: 
d1492 3
a1494 2
			/* this should NEVER happen because there is a
			 * check for dutype well above here
d1496 3
a1498 2
			error = E_TP_INV_TPDU; /* causes an ER  */
			IFDEBUG(D_TPINPUT)
d1500 2
a1501 1
			ENDDEBUG
d1506 6
a1511 5
	/* peel off the tp header; 
	 * remember that the du_li doesn't count itself.
	 * This may leave us w/ an empty mbuf at the front of a chain.
	 * We can't just throw away the empty mbuf because hdr still points
	 * into the mbuf's data area and we're still using hdr (the tpdu header)
d1513 2
a1514 2
	m->m_len -= ((int)hdr->tpdu_li + 1);
	m->m_data += ((int)hdr->tpdu_li + 1);
d1517 2
a1518 2
		int max = tpdu_info[ hdr->tpdu_type ] [TP_MAX_DATA_INDEX];
		int datalen = tpdu_len - hdr->tpdu_li - 1, mbtype = MT_DATA;
d1521 2
a1522 2
			struct cmsghdr x_hdr;
		} x;
d1526 3
a1528 3
		CHECK( (max && datalen > max), E_TP_LENGTH_INVAL,
		        ts_inv_length, respond, (max + hdr->tpdu_li + 1) );
		switch( hdr->tpdu_type ) {
d1544 1
a1544 1
		make_control_msg:
d1550 6
a1555 2
			if (n == 0)
				{m_freem(m); m = 0; datalen = 0; goto invoke; }
d1558 1
a1558 1
				bcopy((caddr_t)&x, mtod(n, caddr_t), n->m_len = sizeof(x));
d1560 2
a1561 2
				bcopy((caddr_t)&c_hdr, mtod(n, caddr_t),
					  n->m_len = sizeof(c_hdr));
d1573 1
a1573 1
			for (n = m; n; n = n->m_next) { 
d1576 3
a1578 3
		invoke:
			e.ATTR(DT_TPDU).e_datalen = datalen;
			e.ATTR(DT_TPDU).e_data =  m;
d1583 2
a1584 2
				"ERROR in tp_input! hdr->tpdu_type 0x%x takes_data 0x%x m 0x%x\n",
				hdr->tpdu_type, takes_data, m);
d1587 4
a1590 1
		/* prevent m_freem() after tp_driver() from throwing it all away */
a1592 1

d1595 5
a1599 4
	IFDEBUG(D_TPINPUT)
		printf( "tp_input: before driver, state 0x%x event 0x%x m 0x%x",
			tpcb->tp_state, e.ev_number, m );
		printf(" e.e_data 0x%x\n", e.ATTR(DT_TPDU).e_data);
d1601 3
a1603 2
			takes_data, (m==MNULL)?0:m->m_len,  tpdu_len);
	ENDDEBUG
d1607 3
a1609 3
	ASSERT(tpcb != (struct tp_pcb *)0);
	ASSERT(tpcb->tp_sock != (struct socket *)0);
	if( tpcb->tp_sock->so_error == 0 )
d1612 4
a1615 3
	/* Kludge to keep the state tables under control (adding
	 * data on connect & disconnect & freeing the mbuf containing
	 * the data would have exploded the tables and made a big mess ).
d1617 15
a1631 12
	switch(e.ev_number) {
		case CC_TPDU:
		case DR_TPDU:
		case CR_TPDU:
			m = e.ATTR(CC_TPDU).e_data; /* same field for all three dutypes */
			IFDEBUG(D_TPINPUT)
				printf("after driver, restoring m to 0x%x, takes_data 0x%x\n", 
				m, takes_data);
			ENDDEBUG
			break;
		default:
			break;
d1633 4
a1636 3
	/* Concatenated sequences are terminated by any tpdu that 
	 * carries data: CR, CC, DT, XPD, DR.
	 * All other tpdu types may be concatenated: AK, XAK, DC, ER.
d1639 5
a1643 6
separate:
	if ( takes_data == 0 )  {
		ASSERT( m != MNULL );
		/* 
		 * we already peeled off the prev. tp header so 
		 * we can just pull up some more and repeat
d1646 9
a1654 7
		if( m = tp_inputprep(m) ) {
		IFDEBUG(D_TPINPUT)
			hdr = mtod(m, struct tpdu *);
			printf("tp_input @@ separate: hdr 0x%x size %d m 0x%x\n", 
			hdr, (int) hdr->tpdu_li + 1, m);
			dump_mbuf(m, "tp_input after driver, at separate");
		ENDDEBUG
d1660 3
a1662 2
	if ( m != MNULL ) {
		IFDEBUG(D_TPINPUT)
d1664 2
a1665 1
		ENDDEBUG
d1667 2
a1668 1
		IFDEBUG(D_TPINPUT)
d1670 2
a1671 1
		ENDDEBUG
d1677 2
a1678 1
	/* class 2,0: Should drop the net connection, if you can figure out
d1681 2
a1682 1
	IFDEBUG(D_TPINPUT)
d1684 8
a1691 5
	ENDDEBUG
	IFTRACE(D_TPINPUT)
		tptrace(TPPTmisc, "tp_input DISCARD m",  m,0,0,0);
	ENDTRACE
	m_freem(m);
d1706 2
a1707 1
	IFDEBUG(D_TPINPUT)
d1709 4
a1712 2
	ENDDEBUG
	IFTRACE(D_TPINPUT)
d1714 3
a1716 2
	ENDTRACE
	if (sref == 0)
d1718 5
a1722 4
	(void) tp_error_emit(error, (u_long)sref, satosiso(faddr),
				satosiso(laddr), m, errlen, tpcb,
				cons_channel, dgout_routine);
	IFDEBUG(D_ERROR_EMIT)
d1724 2
a1725 1
	ENDDEBUG
d1728 2
a1729 2
	printf("",sref,opt);
#endif /* lint */
d1743 1
a1743 1
 *  For a given connection, represented by (tpcb), and 
d1748 1
a1748 1
 * SIDE EFFECTS:	
d1753 3
a1755 3
tp_headersize(dutype, tpcb) 
	int 			dutype;
	struct tp_pcb 	*tpcb;
d1757 1
a1757 1
	register int size = 0;
d1759 2
a1760 1
	IFTRACE(D_CONN)
d1763 20
a1782 19
	ENDTRACE
	if( !( (tpcb->tp_class == TP_CLASS_0) || 
			(tpcb->tp_class == TP_CLASS_4) || 
			(dutype == DR_TPDU_type) || 
			(dutype == CR_TPDU_type) )) {
				printf("tp_headersize:dutype 0x%x, class 0x%x", 
			dutype, tpcb->tp_class);
	/* TODO: identify this and GET RID OF IT */
	}
	ASSERT( (tpcb->tp_class == TP_CLASS_0) || 
			(tpcb->tp_class == TP_CLASS_4) || 
			(dutype == DR_TPDU_type) || 
			(dutype == CR_TPDU_type) );

	if( tpcb->tp_class == TP_CLASS_0 ) {
		size =  tpdu_info[ dutype ] [TP_LEN_CLASS_0_INDEX];
	} else  {
		size = tpdu_info[ dutype ] [tpcb->tp_xtd_format];
	} 
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
