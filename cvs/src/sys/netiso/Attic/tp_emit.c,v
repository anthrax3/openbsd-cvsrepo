head	1.11;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.10;

1.10
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.23.03.54.58;	author angelos;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.05.24.03.59.00;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.22.19.02.36;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.25.04.26.11;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.43;	author deraadt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	96.03.04.10.35.56;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2000.03.02.07.04.47;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2001.07.04.10.55.38;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.16.5;

1.3.16.5
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: tp_emit.c,v 1.10 2003/12/10 07:22:44 itojun Exp $	*/
/*	$NetBSD: tp_emit.c,v 1.8 1996/03/16 23:13:48 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tp_emit.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 * This file contains tp_emit() and tp_error_emit(), which form TPDUs and
 * hand them to ip. They take data in the form of mbuf chain, allocate mbufs
 * as necessary for headers, and set the fields as appropriate from
 * information found in the tpcb and net-level pcb.
 *
 * The worst thing about this code is adding the variable-length options on a
 * machine that requires alignment for any memory access that isn't of size
 * 1.  See the macro ADDOPTION() below.
 *
 * We don't do any concatenation. (There's a kludge to test the basic mechanism
 * of separation under the 'w' tpdebug option, that's all.)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>

#include <net/if.h>

#include <netiso/iso.h>
#include <netiso/iso_pcb.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_timer.h>
#include <netiso/tp_param.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_tpdu.h>
#include <netiso/tp_trace.h>
#include <netiso/tp_meas.h>
#include <netiso/tp_seq.h>
#include <netiso/tp_var.h>
#include <netiso/iso_errno.h>
#include <netiso/iso_var.h>

#ifdef TRUE
#undef FALSE
#undef TRUE
#endif
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>

/*
 * Here is a mighty kludge.  The token ring misorders packets if you fire
 * them at it too fast, and TP sans checksum is "too fast", so we have
 * introduced a delay when checksumming isn't used.
 */
char            tp_delay = 0x00;/* delay to keep token ring from blowing it */

/*
 * NAME:	tp_emit()
 *
 * CALLED FROM: tp.trans and from tp_sbsend()
 *
 * FUNCTION and ARGUMENTS:
 * 	Emits one tpdu of the type (dutype), of the format appropriate
 * 	to the connection described by the pcb (tpcb), with sequence
 * 	number (seq) (where appropriate), end-of-tsdu bit (eot) where
 * 	appropriate, and with the data in the mbuf chain (data).
 * 	For DR and ER tpdus, the argument (eot) is
 * 	the reason for issuing the tpdu rather than an end-of-tsdu indicator.
 *
 * RETURNS:
 * 	0  OK
 * 	ENOBUFS
 * 	E* returned from net layer output rtn
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 *
 * 	WE ASSUME that the tp header + all options will fit in ONE mbuf.
 *	If mbufs are 256 this will most likely be true, but if they are 128 it's
 *	possible that they won't.
 *	If you used every option on the CR + max. user data you'd overrun
 *	112 but unless you used > 115 bytes for the security
 *	parameter, it would fit in a 256-byte mbuf (240 bytes for the header)
 *	We don't support the security parameter, so this isn't a problem.
 *	If security is added, we ought to remove this assumption.
 *
 *  We do not implement the flow control confirmation "element of procedure".
 *  A) it should not affect interoperability,
 *  B) it should not be necessary - the protocol will eventually
 *   	straighten things out w/o FCC, as long as we don't have severely
 *		mismatched keepalive and inactivity timers, and
 *	C) it appears not to be REQUIRED, and
 *  D) it's incredibly grotesque, and no doubt will lengthen a few
 *   	critical paths.
 *  HOWEVER, we're thinking about putting it in anyway, for
 *  completeness, just like we did with ack subsequencing.
 */

int
tp_emit(dutype, tpcb, seq, eot, data)
	int             dutype;
	struct tp_pcb  *tpcb;
	SeqNum          seq;
	u_int           eot;
	struct mbuf    *data;
{
	struct tpdu *hdr;
	struct mbuf *m;
	int             csum_offset = 0;
	int             datalen = 0;
	int             error = 0;
	SeqNum          olduwe;
	int             acking_ooo;

	/*
	 * NOTE: here we treat tpdu_li as if it DID include the li field, up
	 * until the end, at which time we subtract 1 THis is because if we
	 * subtract 1 right away, we end up adding one every time we add an
	 * option.
	 */
#ifdef ARGO_DEBUG
	if (argo_debug[D_EMIT]) {
		printf(
		       "tp_emit dutype 0x%x, tpcb %p, eot 0x%x, seq 0x%x, data %p",
		       dutype, tpcb, eot, seq, data);
	}
#endif

	if (dutype == CR_TPDU || dutype == CC_TPDU) {
		m = (struct mbuf *) malloc((u_long) 256, M_MBUF, M_DONTWAIT);
		if (m) {
			m->m_type = TPMT_TPHDR;
			mbstat.m_mtypes[TPMT_TPHDR]++;
			m->m_next = MNULL;
			m->m_nextpkt = MNULL;
			m->m_data = m->m_pktdat;
			m->m_flags = M_PKTHDR;
			m->m_pkthdr.rcvif = 0;
			m->m_pkthdr.len = 0;
			m_tag_init(m);
		}
	} else {
		MGETHDR(m, M_DONTWAIT, TPMT_TPHDR);
	}
	if (m == NULL) {
		if (data != (struct mbuf *) 0)
			m_freem(data);
		error = ENOBUFS;
		goto done;
	}
	m->m_data += max_hdr;
	m->m_len = sizeof(struct tpdu);
	m->m_act = MNULL;

	hdr = mtod(m, struct tpdu *);
	bzero((caddr_t) hdr, sizeof(struct tpdu));

	{
		hdr->tpdu_type = dutype;
		hdr->tpdu_li = tp_headersize(dutype, tpcb);
		/*
		 * class 0 doesn't use this for DT
		 * it'll just get overwritten below
		 */
		hdr->tpdu_dref = htons(tpcb->tp_fref);
		if (tpcb->tp_use_checksum ||
		(dutype == CR_TPDU_type && (tpcb->tp_class & TP_CLASS_4))) {
			csum_offset = hdr->tpdu_li + 2;	/* DOESN'T include csum */
			ADDOPTION(TPP_checksum, hdr, 2, eot /* dummy arg */ );
#ifdef ARGO_DEBUG
			if (argo_debug[D_CHKSUM]) {
				printf(
				       "tp_emit: csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
				       csum_offset, hdr->tpdu_li);
			}
#endif
		}
		/*
		 * VARIABLE PARTS...
		 */
		switch (dutype) {

		case CR_TPDU_type:
			hdr->tpdu_CRdref_0 = 0;	/* must be zero */
		case CC_TPDU_type:
			if (!tpcb->tp_cebit_off) {
				tpcb->tp_win_recv = tp_start_win << 8;
				LOCAL_CREDIT(tpcb);
				CONG_INIT_SAMPLE(tpcb);
			} else
				LOCAL_CREDIT(tpcb);

			/* Case CC_TPDU_type used to be here */
			{
				u_char          x;

				hdr->tpdu_CCsref = htons(tpcb->tp_lref);	/* same as CRsref */

				if (tpcb->tp_class > TP_CLASS_1) {
					tpcb->tp_sent_uwe = tpcb->tp_lcredit - 1;
					tpcb->tp_sent_rcvnxt = 1;
					tpcb->tp_sent_lcdt = tpcb->tp_lcredit;
					hdr->tpdu_cdt = tpcb->tp_lcredit;
				} else {
#ifdef TPCONS
					if (tpcb->tp_netservice == ISO_CONS) {
						struct isopcb  *isop = (struct isopcb *) tpcb->tp_npcb;
						struct pklcd   *lcp = (struct pklcd *) (isop->isop_chan);
						lcp->lcd_flags &= ~X25_DG_CIRCUIT;
					}
#endif
					hdr->tpdu_cdt = 0;
				}
				hdr->tpdu_CCclass = tp_mask_to_num(tpcb->tp_class);
				hdr->tpdu_CCoptions =
					(tpcb->tp_xtd_format ? TPO_XTD_FMT : 0) |
					(tpcb->tp_use_efc ? TPO_USE_EFC : 0);

#ifdef TP_PERF_MEAS
				if (DOPERF(tpcb)) {
					u_char  perf_meas = tpcb->tp_perf_on;
					ADDOPTION(TPP_perf_meas, hdr,
						  sizeof(perf_meas), perf_meas);
				}
#endif

					if (dutype == CR_TPDU_type) {
					IncStat(ts_CR_sent);

					ASSERT(tpcb->tp_lsuffixlen > 0);
					ASSERT(tpcb->tp_fsuffixlen > 0);

					ADDOPTION(TPP_calling_sufx, hdr,
						  tpcb->tp_lsuffixlen, tpcb->tp_lsuffix[0]);
					ADDOPTION(TPP_called_sufx, hdr,
						  tpcb->tp_fsuffixlen, tpcb->tp_fsuffix[0]);
				} else {
					IncStat(ts_CC_sent);
				}

				ADDOPTION(TPP_tpdu_size, hdr,
					  sizeof(tpcb->tp_tpdusize), tpcb->tp_tpdusize);

				if (tpcb->tp_class != TP_CLASS_0) {
					short           millisec = 500 * (tpcb->tp_sendack_ticks);

					millisec = htons(millisec);
					ADDOPTION(TPP_acktime, hdr, sizeof(short), millisec);

					x = (tpcb->tp_use_nxpd ? TPAO_USE_NXPD : 0)
						| (tpcb->tp_use_rcc ? TPAO_USE_RCC : 0)
						| (tpcb->tp_use_checksum ? 0 : TPAO_NO_CSUM)
						| (tpcb->tp_xpd_service ? TPAO_USE_TXPD : 0);
					ADDOPTION(TPP_addl_opt, hdr, 1, x);

					if ((tpcb->tp_l_tpdusize ^ (1 << tpcb->tp_tpdusize)) != 0) {
						u_short         size_s = tpcb->tp_l_tpdusize >> 7;
						u_char          size_c = size_s;
						ASSERT(tpcb->tp_l_tpdusize < 65536 * 128);
						if (dutype == CR_TPDU_type)
							tpcb->tp_ptpdusize = size_s;
						if (size_s < 256) {
							ADDOPTION(TPP_ptpdu_size, hdr, 1, size_c);
						} else {
							size_s = htons(size_s);
							ADDOPTION(TPP_ptpdu_size, hdr, 2, size_s);
						}
					}
				}
				if ((dutype == CR_TPDU_type) && (tpcb->tp_class != TP_CLASS_0)) {

					ASSERT(1 == sizeof(tpcb->tp_vers));
					ADDOPTION(TPP_vers, hdr, 1, tpcb->tp_vers);

					/*
					 * for each alt protocol class x, x =
					 * x<<4; option = concat(option, x);
					 * Well, for now we only have TP0 for
					 * an alternative so... this is easy.
					 *
					 * HOWEVER... There should be NO alt
					 * protocol class over CLNS.  Need to
					 * see if the route suggests CONS,
					 * and iff so add alt class.
					 */
					x = 0;
					ADDOPTION(TPP_alt_class, hdr, 1, x);
				}
				if (hdr->tpdu_li > MLEN)
					panic("tp_emit CR/CC");
			}
			break;

		case DR_TPDU_type:
			if (hdr->tpdu_DRdref == 0) {
				/* don't issue the DR */
				goto done;
			}
			hdr->tpdu_cdt = 0;
			hdr->tpdu_DRsref = htons(tpcb->tp_lref);
			hdr->tpdu_DRreason = (u_char) eot;	/* WHICH BYTE OF THIS??? */

			/* forget the add'l information variable part */
			IncStat(ts_DR_sent);
			break;

		case DC_TPDU_type:	/* not used in class 0 */
			ASSERT(tpcb->tp_class != TP_CLASS_0);
			hdr->tpdu_DCsref = htons(tpcb->tp_lref);
			hdr->tpdu_cdt = 0;
			data = (struct mbuf *) 0;
			IncStat(ts_DC_sent);
			break;

		case XAK_TPDU_type:	/* xak not used in class 0 */
			ASSERT(tpcb->tp_class != TP_CLASS_0);	/* fall through */
			hdr->tpdu_cdt = 0;

#ifdef TPPT
			if (tp_traceflags[D_XPD]) {
				tptraceTPCB(TPPTXack, seq, 0, 0, 0, 0);
			}
#endif
			data = (struct mbuf *) 0;
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seq = seq;
				seqeotX.s_eot = 1;
				hdr->tpdu_seqeotX = htonl(seqeotX.s_seqeot);
#else
				hdr->tpdu_XAKseqX = seq;
#endif				/* BYTE_ORDER */
			} else {
				hdr->tpdu_XAKseq = seq;
			}
			IncStat(ts_XAK_sent);
			IncPStat(tpcb, tps_XAK_sent);
			break;

		case XPD_TPDU_type:	/* xpd not used in class 0 */
			ASSERT(tpcb->tp_class != TP_CLASS_0);	/* fall through */
			hdr->tpdu_cdt = 0;
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seq = seq;
				seqeotX.s_eot = 1;
				hdr->tpdu_seqeotX = htonl(seqeotX.s_seqeot);
#else
				hdr->tpdu_XPDseqX = seq;
				hdr->tpdu_XPDeotX = 1;	/* always 1 for XPD tpdu */
#endif				/* BYTE_ORDER */
			} else {
				hdr->tpdu_XPDseq = seq;
				hdr->tpdu_XPDeot = 1;	/* always 1 for XPD tpdu */
			}
			IncStat(ts_XPD_sent);
			IncPStat(tpcb, tps_XPD_sent);

			/* kludge to test the input size checking */
#ifdef ARGO_DEBUG
			if (argo_debug[D_SIZE_CHECK]) {
				/*
				 * if(data->m_len <= 16 && data->m_off < (MLEN-18) )
				 * { printf("Sending too much data on XPD: 18
				 * bytes\n"); data->m_len = 18; }
				 */
			}
#endif
			break;

		case DT_TPDU_type:
			hdr->tpdu_cdt = 0;
#ifdef TPPT
			if (tp_traceflags[D_DATA]) {
				tptraceTPCB(TPPTmisc,
					    "emit DT: eot seq tpdu_li", eot,
					    seq, hdr->tpdu_li, 0);
			}
#endif
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seq = seq;
				seqeotX.s_eot = eot;
				hdr->tpdu_seqeotX = htonl(seqeotX.s_seqeot);
#else
				hdr->tpdu_DTseqX = seq;
				hdr->tpdu_DTeotX = eot;
#endif				/* BYTE_ORDER */
			} else if (tpcb->tp_class == TP_CLASS_0) {
#ifdef ARGO_DEBUG
				if (argo_debug[D_EMIT]) {
					printf("DT tpdu: class 0 m %p hdr %p\n", m, hdr);
					dump_buf(hdr, hdr->tpdu_li + 1);
				}
#endif
				((struct tp0du *) hdr)->tp0du_eot = eot;
				((struct tp0du *) hdr)->tp0du_mbz = 0;
#ifdef ARGO_DEBUG
				if (argo_debug[D_EMIT]) {
					printf("DT 2 tpdu: class 0 m %p hdr %p\n", m, hdr);
					dump_buf(hdr, hdr->tpdu_li + 1);
				}
#endif
			} else {
				hdr->tpdu_DTseq = seq;
				hdr->tpdu_DTeot = eot;
			}
			if (eot) {
				IncStat(ts_EOT_sent);
			}
			IncStat(ts_DT_sent);
			IncPStat(tpcb, tps_DT_sent);
			break;

		case AK_TPDU_type:	/* ak not used in class 0 */
			ASSERT(tpcb->tp_class != TP_CLASS_0);
			data = (struct mbuf *) 0;
			olduwe = tpcb->tp_sent_uwe;

			if (seq != tpcb->tp_sent_rcvnxt || tpcb->tp_rsycnt == 0) {
				LOCAL_CREDIT(tpcb);
				tpcb->tp_sent_uwe =
					SEQ(tpcb, tpcb->tp_rcvnxt + tpcb->tp_lcredit - 1);
				tpcb->tp_sent_lcdt = tpcb->tp_lcredit;
				acking_ooo = 0;
			} else
				acking_ooo = 1;

#ifdef ARGO_DEBUG
			if (argo_debug[D_RENEG]) {
				/*
				 * occasionally fake a reneging so you can test
				 * subsequencing
				 */
				if (olduwe & 0x1) {
					tpcb->tp_reneged = 1;
					IncStat(ts_ldebug);
				}
			}
#endif
			/*
			 * Are we about to reneg on credit? When might we do
			 * so? a) when using optimistic credit (which we no
			 * longer do). b) when drain() gets implemented (not
			 * in the plans). c) when D_RENEG is on. d) when DEC
			 * BIT response is implemented. (not- when we do
			 * this, we'll need to implement flow control
			 * confirmation)
			 */
			if (SEQ_LT(tpcb, tpcb->tp_sent_uwe, olduwe)) {
				tpcb->tp_reneged = 1;
				IncStat(ts_lcdt_reduced);
#ifdef TPPT
				if (tp_traceflags[D_CREDIT]) {
					tptraceTPCB(TPPTmisc,
				      "RENEG: olduwe newuwe lcredit rcvnxt",
						    olduwe,
					tpcb->tp_sent_uwe, tpcb->tp_lcredit,
						    tpcb->tp_rcvnxt);
				}
#endif
			}
#ifdef TP_PERF_MEAS
			if (DOPERF(tpcb)) {
				/*
				 * new lwe is less than old uwe means we're
				 * acking before we received a whole window full
				 */
				if (SEQ_LT(tpcb, tpcb->tp_rcvnxt, olduwe)) {
					/*
					 * tmp1 = number of pkts fewer than
					 * the full window
					 */
					int    tmp1 =
					(int) SEQ_SUB(tpcb, olduwe,
						      tpcb->tp_rcvnxt);

					if (tmp1 > TP_PM_MAX)
						tmp1 = TP_PM_MAX;
					IncPStat(tpcb, tps_ack_early[tmp1]);

					/*
					 * tmp1 = amt of new cdt we're
					 * advertising 
					 */
					tmp1 = SEQ_SUB(tpcb, seq,
						       tpcb->tp_sent_rcvnxt);
					if (tmp1 > TP_PM_MAX)
						tmp1 = TP_PM_MAX;

					IncPStat(tpcb,
						 tps_cdt_acked[tmp1]
						 [((tpcb->tp_lcredit >
						    TP_PM_MAX) ?
						   TP_PM_MAX : 
						   tpcb->tp_lcredit)]);

				}
			}
#endif

#ifdef TPPT
			if (tp_traceflags[D_ACKSEND]) {
				tptraceTPCB(TPPTack, seq, tpcb->tp_lcredit,
					    tpcb->tp_sent_uwe,
					    tpcb->tp_r_subseq, 0);
			}
#endif
			if (tpcb->tp_xtd_format) {
#ifdef BYTE_ORDER
				union seq_type  seqeotX;

				seqeotX.s_seq = seq;
				seqeotX.s_eot = 0;
				hdr->tpdu_seqeotX = htonl(seqeotX.s_seqeot);
				hdr->tpdu_AKcdtX = htons(tpcb->tp_lcredit);
#else
				hdr->tpdu_cdt = 0;
				hdr->tpdu_AKseqX = seq;
				hdr->tpdu_AKcdtX = tpcb->tp_lcredit;
#endif				/* BYTE_ORDER */
			} else {
				hdr->tpdu_AKseq = seq;
				hdr->tpdu_AKcdt = tpcb->tp_lcredit;
			}
			if ((tpcb->tp_class == TP_CLASS_4) &&
			    (tpcb->tp_reneged || acking_ooo)) {
				/*
				 * Ack subsequence parameter req'd if WE
				 * reneged on credit offered.  (ISO 8073,
				 * 12.2.3.8.2, p. 74)
				 */
#ifdef ARGO_DEBUG
				if (argo_debug[D_RENEG]) {
					printf("Adding subseq 0x%x\n", tpcb->tp_s_subseq);
				}
#endif
				tpcb->tp_s_subseq++;
				/*
				 * add tmp subseq and do a htons on it.
				 */
				ADDOPTION(TPP_subseq, hdr,
					  sizeof(tpcb->tp_s_subseq), tpcb->tp_s_subseq);
			} else
				tpcb->tp_s_subseq = 0;

			if (tpcb->tp_sendfcc || eot) {	/* overloaded to mean
							 * SEND FCC */
				/*
				 * Rules for sending FCC ("should" send when)
				 * : %a) received an ack from peer with NO
				 * NEWS whatsoever, and it did not contain an
				 * FCC b) received an ack from peer that
				 * opens its closed window. c) received an
				 * ack from peer after it reneged on its
				 * offered credit, AND this ack raises UWE
				 * but LWE is same and below UWE at time of
				 * reneging (reduction) Now, ISO 8073
				 * 12.2.3.8.3 says that a retransmitted AK
				 * shall not contain the FCC parameter.  Now,
				 * how the hell you tell the difference
				 * between a retransmitted ack and an ack
				 * that's sent in response to a received ack,
				 * I don't know, because without any local
				 * activity, and w/o any received DTs, they
				 * will contain exactly the same credit/seq#
				 * information. Anyway, given that the
				 * "retransmission of acks" procedure (ISO
				 * 8073 12.2.3.8.3) is optional, and we don't
				 * do it (although the peer can't tell that),
				 * we ignore this last rule.
				 *
				 * We send FCC for reasons a) and b) only. To
				 * add reason c) would require a ridiculous
				 * amount of state.
				 *
				 */
				u_short         bogus[4];	/* lwe(32), subseq(16),
								 * cdt(16) */
				SeqNum          lwe;
				u_short         subseq, fcredit;

				tpcb->tp_sendfcc = 0;

				lwe = (SeqNum) htonl(tpcb->tp_snduna);
				subseq = htons(tpcb->tp_r_subseq);
				fcredit = htons(tpcb->tp_fcredit);

				bcopy((caddr_t) & lwe, (caddr_t) & bogus[0], sizeof(SeqNum));
				bcopy((caddr_t) & subseq, (caddr_t) & bogus[2], sizeof(u_short));
				bcopy((caddr_t) & fcredit, (caddr_t) & bogus[3], sizeof(u_short));

#ifdef TPPT
				if (tp_traceflags[D_ACKSEND]) {
					tptraceTPCB(TPPTmisc,
				      "emit w/FCC: snduna r_subseq fcredit",
					 tpcb->tp_snduna, tpcb->tp_r_subseq,
						    tpcb->tp_fcredit, 0);
				}
#endif

#ifdef ARGO_DEBUG
				if (argo_debug[D_ACKSEND]) {
					printf("Calling ADDOPTION 0x%x, %p, 0x%x,0x%x\n",
					       TPP_flow_cntl_conf,
					       hdr, sizeof(bogus), bogus[0]);
				}
#endif
				ADDOPTION(TPP_flow_cntl_conf, hdr, sizeof(bogus), bogus[0]);
#ifdef ARGO_DEBUG
				if (argo_debug[D_ACKSEND]) {
					printf("after ADDOPTION hdr %p hdr->tpdu_li 0x%x\n",
					       hdr, hdr->tpdu_li);
					printf(
					       "after ADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
					       csum_offset, hdr->tpdu_li);
				}
#endif

			}
			tpcb->tp_reneged = 0;
			tpcb->tp_sent_rcvnxt = seq;
			if (tpcb->tp_fcredit == 0) {
				int             timo = tpcb->tp_keepalive_ticks;
				if (tpcb->tp_rxtshift < TP_MAXRXTSHIFT)
					tpcb->tp_rxtshift++;
				timo = min(timo, ((int) tpcb->tp_dt_ticks) << tpcb->tp_rxtshift);
				tp_ctimeout(tpcb, TM_sendack, timo);
			} else
				tp_ctimeout(tpcb, TM_sendack, tpcb->tp_keepalive_ticks);
			IncStat(ts_AK_sent);
			IncPStat(tpcb, tps_AK_sent);
#ifdef ARGO_DEBUG
			if (argo_debug[D_ACKSEND]) {
				printf(
				       "2 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
				       csum_offset, hdr->tpdu_li);
			}
#endif
			break;

		case ER_TPDU_type:
			hdr->tpdu_ERreason = eot;
			hdr->tpdu_cdt = 0;
			/* no user data */
			data = (struct mbuf *) 0;
			IncStat(ts_ER_sent);
			break;
		}

	}
	ASSERT(((int) hdr->tpdu_li > 0) && ((int) hdr->tpdu_li < MLEN));

	m->m_next = data;

	ASSERT(hdr->tpdu_li < MLEN);	/* leave this in */
	ASSERT(hdr->tpdu_li != 0);	/* leave this in */

	m->m_len = hdr->tpdu_li;
	hdr->tpdu_li--;		/* doesn't include the li field */

	datalen = m_datalen(m);	/* total len */

	ASSERT(datalen <= tpcb->tp_l_tpdusize);	/* may become a problem when
						 * CLNP is used; leave in
						 * here for the time being */
#ifdef ARGO_DEBUG
	if (argo_debug[D_ACKSEND]) {
		printf(
		 "4 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
		       csum_offset, hdr->tpdu_li);
	}
#endif
	if (datalen > tpcb->tp_l_tpdusize) {
		printf("data len 0x%x tpcb->tp_l_tpdusize 0x%x\n",
		       datalen, tpcb->tp_l_tpdusize);
	}
#ifdef ARGO_DEBUG
	if (argo_debug[D_EMIT]) {
		printf(
		       "tp_emit before gen_csum m_len 0x%x, csum_offset 0x%x, datalen 0x%x\n",
		       m->m_len, csum_offset, datalen);
	}
#endif
	if (tpcb->tp_use_checksum ||
	    (dutype == CR_TPDU_type && (tpcb->tp_class & TP_CLASS_4))) {
		iso_gen_csum(m, csum_offset, datalen);
	}
#ifdef ARGO_DEBUG
	if (argo_debug[D_EMIT]) {
		printf("tp_emit before tpxxx_output tpcb %p, dutype 0x%x, datalen 0x%x\n",
		       tpcb, dutype, datalen);
		dump_buf(mtod(m, caddr_t), datalen);
	}
#endif

#ifdef TP_PERF_MEAS
	if (DOPERF(tpcb)) {
		if (dutype == DT_TPDU_type) {
			PStat(tpcb, Nb_to_ll) += (datalen - m->m_len);
			tpmeas(tpcb->tp_lref, TPtime_to_ll, NULL,
			       seq, PStat(tpcb, Nb_to_ll),
			       (datalen - m->m_len));
		}
	}
#endif

#ifdef TPPT
	if (tp_traceflags[D_EMIT]) {
		tptraceTPCB(TPPTtpduout, dutype, hdr, hdr->tpdu_li + 1, datalen, 0);
	}
#endif
#ifdef ARGO_DEBUG
	    if (argo_debug[D_EMIT]) {
		printf("OUTPUT: tpcb %p, isop %p, so %p\n",
		       tpcb, tpcb->tp_npcb, tpcb->tp_sock);
	}
#endif

	{
		extern char     tp_delay;

		if (tp_delay)
			if (tpcb->tp_use_checksum == 0) {
				u_int  i = tp_delay;
				for (; i != 0; i--)
					(void) iso_check_csum(m, datalen);
			}
	}
	ASSERT(m->m_len > 0);
	error = (tpcb->tp_nlproto->nlp_output) (m, datalen, tpcb->tp_npcb,
						!tpcb->tp_use_checksum);
#ifdef ARGO_DEBUG
	if (argo_debug[D_EMIT]) {
		printf("OUTPUT: returned 0x%x\n", error);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_EMIT]) {
		tptraceTPCB(TPPTmisc,
		       "tp_emit nlproto->output netservice returns datalen",
	 tpcb->tp_nlproto->nlp_output, tpcb->tp_netservice, error, datalen);
	}
#endif
done:
	if (error) {
		if (dutype == AK_TPDU_type)
			tp_ctimeout(tpcb, TM_sendack, 1);
		if (error == E_CO_QFULL) {
			tp_quench((struct inpcb *) tpcb, PRC_QUENCH);
			return 0;
		}
	}
	return error;
}
/*
 * NAME:		tp_error_emit()
 * CALLED FROM:	tp_input() when a DR or ER is to be issued in
 *	response to an input error.
 * FUNCTION and ARGUMENTS:
 * 	The error type is the first argument.
 * 	The argument (sref) is the source reference on the bad incoming tpdu,
 * 	and is used for a destination reference on the outgoing packet.
 * 	(faddr) and (laddr) are the foreign and local addresses for this
 *	connection.
 * 	(erdata) is a ptr to the errant incoming tpdu, and is copied into the
 * 	outgoing ER, if an ER is to be issued.
 * 	(erlen)  is the number of octets of the errant tpdu that we should
 * 	try to copy.
 * 	(tpcb) is the pcb that describes the connection for which the bad tpdu
 * 	arrived.
 * RETURN VALUES:
 * 		0 OK
 *  	ENOBUFS
 *  	E* from net layer datagram output routine
 * SIDE EFFECTS:
 *
 * NOTES:
 */

int
tp_error_emit(error, sref, faddr, laddr, erdata, erlen, tpcb, cons_channel,
	      dgout_routine)
	int             error;
	u_long          sref;
	struct sockaddr_iso *faddr, *laddr;
	struct mbuf    *erdata;
	int             erlen;
	struct tp_pcb  *tpcb;
	caddr_t         cons_channel;
        int 	      (*dgout_routine)(struct mbuf *, ...);
{
	int             dutype;
	int             datalen = 0;
	struct tpdu *hdr;
	struct mbuf *m;
	int             csum_offset;

#ifdef TPPT
	if (tp_traceflags[D_ERROR_EMIT]) {
		tptrace(TPPTmisc, "tp_error_emit error sref tpcb erlen",
			error, sref, tpcb, erlen);
	}
#endif
#ifdef ARGO_DEBUG
	if (argo_debug[D_ERROR_EMIT]) {
		printf(
		       "tp_error_emit error 0x%x sref %lx tpcb %p erlen 0x%x chan %p\n",
		       error, sref, tpcb, erlen, cons_channel);
	}
#endif

	MGET(m, M_DONTWAIT, TPMT_TPHDR);
	if (m == NULL) {
		return ENOBUFS;
	}
	m->m_len = sizeof(struct tpdu);
	m->m_act = MNULL;

	hdr = mtod(m, struct tpdu *);

#ifdef ARGO_DEBUG
	if (argo_debug[D_ERROR_EMIT]) {
		printf("[error 0x%x] [error&0xff  0x%x] [(char)error 0x%x]\n",
		       error, error & 0xff, (char) error);
	}
#endif


	if (error & TP_ERROR_SNDC)
		dutype = DC_TPDU_type;
	else if (error & 0x40) {
		error &= ~0x40;
		dutype = ER_TPDU_type;
	} else
		dutype = DR_TPDU_type;
	error &= 0xff;

	hdr->tpdu_type = dutype;
	hdr->tpdu_cdt = 0;

	switch (dutype) {

	case DC_TPDU_type:
		IncStat(ts_DC_sent);
		hdr->tpdu_li = 6;
		hdr->tpdu_DCdref = htons(sref);
		hdr->tpdu_DCsref = tpcb ? htons(tpcb->tp_lref) : 0;
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("DC case:\n");
			dump_buf(hdr, 6);
		}
#endif
		/* forget the add'l information variable part */
		break;

	case DR_TPDU_type:
		IncStat(ts_DR_sent);
		hdr->tpdu_li = 7;
		hdr->tpdu_DRdref = htons(sref);
		hdr->tpdu_DRsref = 0;
		hdr->tpdu_DRreason = (char) error;
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("DR case:\n");
			dump_buf(hdr, 7);
		}
#endif
		/* forget the add'l information variable part */
		break;

	case ER_TPDU_type:
		IncStat(ts_ER_sent);
		hdr->tpdu_li = 5;
		hdr->tpdu_ERreason = (char) error;
		hdr->tpdu_ERdref = htons(sref);
		break;

	default:
		ASSERT(0);
		printf("TP PANIC: bad dutype 0x%x\n", dutype);
	}

	if (tpcb)
		if (tpcb->tp_use_checksum) {
			ADDOPTION(TPP_checksum, hdr, 2, csum_offset /* dummy argument */ );
			csum_offset = hdr->tpdu_li - 2;
		}
	ASSERT(hdr->tpdu_li < MLEN);

	if (dutype == ER_TPDU_type) {
		/* copy the errant tpdu into another 'variable part' */
		caddr_t P;

#ifdef TPPT
		if (tp_traceflags[D_ERROR_EMIT]) {
			tptrace(TPPTmisc, "error_emit ER len tpduli", erlen, hdr->tpdu_li,
				0, 0);
		}
#endif
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("error_emit ER len 0x%x tpduli 0x%x\n", erlen, hdr->tpdu_li);
		}
#endif

		/* copy at most as many octets for which you have room */
		if (erlen + hdr->tpdu_li + 2 > TP_MAX_HEADER_LEN)
			erlen = TP_MAX_HEADER_LEN - hdr->tpdu_li - 2;

		/* add the "invalid tpdu" parameter : required in class 0 */
		P = (caddr_t) hdr + (int) (hdr->tpdu_li);
		vbptr(P)->tpv_code = TPP_invalid_tpdu;	/* parameter code */
		vbptr(P)->tpv_len = erlen;	/* parameter length */
		m->m_len = hdr->tpdu_li + 2;	/* 1 for code, 1 for length */

		/*
		 * tp_input very likely handed us an mbuf chain w/ nothing in
		 * the first mbuf and the data following the empty mbuf
		 */
		if (erdata->m_len == 0) {
			erdata = m_free(erdata);	/* returns the next mbuf
							 * on the chain */
		}
		/*
		 * copy only up to the bad octet
		 * (or max that will fit in a header
		 */
		m->m_next = m_copy(erdata, 0, erlen);
		hdr->tpdu_li += erlen + 2;
		m_freem(erdata);
	} else {
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("error_emit DR error %d tpduli %x\n", error, hdr->tpdu_li);
			dump_buf((char *) hdr, hdr->tpdu_li);
		}
#endif
		m->m_len = hdr->tpdu_li;
		m_freem(erdata);
	}

	hdr->tpdu_li--;
#ifdef TPPT
	if (tp_traceflags[D_ERROR_EMIT]) {
		tptrace(TPPTtpduout, 2, hdr, hdr->tpdu_li + 1, 0, 0);
	}
#endif

	datalen = m_datalen(m);
	if (tpcb) {
		if (tpcb->tp_use_checksum) {
#ifdef TPPT
			if (tp_traceflags[D_ERROR_EMIT]) {
				tptrace(TPPTmisc, "before gen csum datalen", datalen, 0, 0, 0);
			}
#endif
#ifdef ARGO_DEBUG
			if (argo_debug[D_ERROR_EMIT]) {
				printf("before gen csum datalen 0x%x, csum_offset 0x%x\n",
				       datalen, csum_offset);
			}
#endif

			iso_gen_csum(m, csum_offset, datalen);
		}
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("OUTPUT: tpcb %p, isop %p, so %p\n",
			       tpcb, tpcb->tp_npcb, tpcb->tp_sock);
		}
#endif
	}
	if (cons_channel) {
#ifdef TPCONS
		struct pklcd   *lcp = (struct pklcd *) cons_channel;
#ifdef notdef
		struct isopcb  *isop = (struct isopcb *) lcp->lcd_upnext;
#endif
		tpcons_output_dg(m, datalen, cons_channel);
#ifdef notdef
		if (tpcb == 0) iso_pcbdetach(isop);
#endif
		/*
		 * but other side may want to try again over same VC, so,
		 * we'll depend on him closing it, but in case it gets
		 * forgotten we'll mark it for garbage collection
		 */
		lcp->lcd_flags |= X25_DG_CIRCUIT;
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("OUTPUT: dutype 0x%x channel 0x%x\n",
			       dutype, cons_channel);
		}
#endif
#else
		printf("TP panic! cons channel %p but not cons configured\n",
		       cons_channel);
#endif
		return 0;
	} else if (tpcb) {

#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("tp_error_emit 1 sending DG: Laddr\n");
			dump_addr(sisotosa(laddr));
			printf("Faddr\n");
			dump_addr(sisotosa(faddr));
		}
#endif
		return (*tpcb->tp_nlproto->nlp_dgoutput) (m, datalen,
							 &laddr->siso_addr,
							 &faddr->siso_addr,
		        /* no route */ (caddr_t) 0, !tpcb->tp_use_checksum);
	} else if (dgout_routine) {
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("tp_error_emit sending DG: Laddr\n");
			dump_addr(sisotosa(laddr));
			printf("Faddr\n");
			dump_addr(sisotosa(faddr));
		}
#endif
		return (*dgout_routine) (m, datalen, &laddr->siso_addr, &faddr->siso_addr,
				        (caddr_t) 0, /* nochecksum==false */ 0);
	} else {
#ifdef ARGO_DEBUG
		if (argo_debug[D_ERROR_EMIT]) {
			printf("tp_error_emit DROPPING %p\n", m);
		}
#endif
		IncStat(ts_send_drop);
		m_freem(m);
		return 0;
	}
}
@


1.10
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.9 2003/06/02 23:28:18 millert Exp $	*/
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.8 2002/03/14 01:27:12 millert Exp $	*/
d167 2
a168 2
	register struct tpdu *hdr;
	register struct mbuf *m;
d540 1
a540 1
					register int    tmp1 =
d791 1
a791 1
				register u_int  i = tp_delay;
d861 2
a862 2
	register struct tpdu *hdr;
	register struct mbuf *m;
d960 1
a960 1
		register caddr_t P;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.7 2001/06/23 03:54:58 angelos Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@Likewise, use m_tag_init()
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.6 2001/05/24 03:59:00 angelos Exp $	*/
d861 1
a861 1
        int 	      (*dgout_routine) __P((struct mbuf *, ...));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.7 2001/06/23 03:54:58 angelos Exp $	*/
d861 1
a861 1
        int 	      (*dgout_routine)(struct mbuf *, ...);
@


1.6
log
@Dereference mbuf after validity check (tedu@@heorot.stanford.edu)
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.5 2001/05/22 19:02:36 angelos Exp $	*/
d204 1
a204 1
			TAILQ_INIT(&m->m_pkthdr.tags);
@


1.5
log
@Initialize packet tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.4 2000/02/25 04:26:11 itojun Exp $	*/
a208 1
	m->m_data += max_hdr;
d215 1
@


1.4
log
@clear m->m_pkthdr when changing mbuf type to M_PKTHDR.
without it, junk pointer in m->m_pkthdr.tdbi may bite us.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.3 1996/04/21 22:29:43 deraadt Exp $	*/
d202 3
a204 1
			bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.2 1996/03/04 10:35:56 mickey Exp $	*/
d202 1
@


1.3.16.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a201 1
			bzero(&m->m_pkthdr, sizeof(m->m_pkthdr));
@


1.3.16.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.3.16.1 2000/03/02 07:04:47 niklas Exp $	*/
d202 1
a202 3
			m->m_pkthdr.rcvif = 0;
			m->m_pkthdr.len = 0;
			m_tag_init(m);
d207 1
a213 1
	m->m_data += max_hdr;
@


1.3.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d861 1
a861 1
        int 	      (*dgout_routine)(struct mbuf *, ...);
@


1.3.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_emit.c,v 1.3.16.3 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d167 2
a168 2
	struct tpdu *hdr;
	struct mbuf *m;
d540 1
a540 1
					int    tmp1 =
d791 1
a791 1
				u_int  i = tp_delay;
d861 2
a862 2
	struct tpdu *hdr;
	struct mbuf *m;
d960 1
a960 1
		caddr_t P;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tp_emit.c,v 1.7 1996/02/13 22:10:54 christos Exp $	*/
d188 1
a188 1
		       "tp_emit dutype 0x%x, tpcb 0x%x, eot 0x%x, seq 0x%x, data 0x%x",
d459 1
a459 1
					printf("DT tpdu: class 0 m 0x%x hdr 0x%x\n", m, hdr);
d467 1
a467 1
					printf("DT 2 tpdu: class 0 m 0x%x hdr 0x%x\n", m, hdr);
d671 1
a671 1
					printf("Calling ADDOPTION 0x%x, 0x%x, 0x%x,0x%x\n",
d679 1
a679 1
					printf("after ADDOPTION hdr 0x%x hdr->tpdu_li 0x%x\n",
d758 1
a758 1
		printf("tp_emit before tpxxx_output tpcb 0x%x, dutype 0x%x, datalen 0x%x\n",
d782 1
a782 1
		printf("OUTPUT: tpcb 0x%x, isop 0x%x, so 0x%x\n",
d875 1
a875 1
		       "tp_error_emit error 0x%x sref 0x%x tpcb 0x%x erlen 0x%x chan 0x%x\n",
d1003 1
a1003 1
			printf("error_emit DR error tpduli 0x%x\n", error, hdr->tpdu_li);
d1037 1
a1037 1
			printf("OUTPUT: tpcb 0x%x, isop 0x%x, so 0x%x\n",
d1065 1
a1065 1
		printf("TP panic! cons channel 0x%x but not cons configured\n",
d1097 1
a1097 1
			printf("tp_error_emit DROPPING \n", m);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tp_emit.c,v 1.6 1995/06/13 07:13:37 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d65 4
a68 5
/* 
 * This file contains tp_emit() and tp_error_emit(), which
 * form TPDUs and hand them to ip.
 * They take data in the form of mbuf chain, allocate mbufs as
 * necessary for headers, and set the fields as appropriate from
d71 3
a73 3
 * The worst thing about this code is adding the variable-length
 * options on a machine that requires alignment for any memory access
 * that isn't of size 1.  See the macro ADDOPTION() below.
d75 2
a76 2
 * We don't do any concatenation. (There's a kludge to test the
 * basic mechanism of separation under the 'w' tpdebug option, that's all.)
d88 2
d101 1
d103 1
a104 1
#include <net/if.h>
d113 4
a116 6
void iso_gen_csum();


/* Here is a mighty kludge.  The token ring misorders packets if you
 * fire them at it too fast, and TP sans checksum is "too fast", so
 * we have introduced a delay when checksumming isn't used.
d118 1
a118 1
char tp_delay = 0x00; /* delay to keep token ring from blowing it */
d133 1
a133 1
 * RETURNS:			
d135 4
a138 2
 * 	ENOBUFS 
 * 	E* returned from net layer output rtn 
d140 1
a140 1
 * SIDE EFFECTS:	
d142 1
a142 3
 * NOTES:			
 *  
 * 	WE ASSUME that the tp header + all options will fit in ONE mbuf.  
d144 2
a145 2
 *	possible that they won't. 
 *	If you used every option on the CR + max. user data you'd overrun 
d164 6
a169 6
tp_emit(dutype,	tpcb, seq, eot, data)
	int dutype;
	struct tp_pcb *tpcb;
	SeqNum	seq;
	u_int 	eot;
	struct mbuf *data;
d171 1
a171 1
	register struct tpdu *hdr; 
d173 11
a183 11
	int csum_offset=0;
	int datalen = 0;
	int error = 0;
 	SeqNum olduwe;
	int acking_ooo;

	/* NOTE:
	 * here we treat tpdu_li as if it DID include the li field, up until
	 * the end, at which time we subtract 1
	 * THis is because if we subtract 1 right away, we end up adding
	 * one every time we add an option.
d185 2
a186 1
	IFDEBUG(D_EMIT)
d188 4
a191 3
	"tp_emit dutype 0x%x, tpcb 0x%x, eot 0x%x, seq 0x%x, data 0x%x",
		dutype, tpcb, eot, seq, data);
	ENDDEBUG
d194 1
a194 1
		m = (struct mbuf *) malloc((u_long)256, M_MBUF, M_DONTWAIT);
d204 1
a204 1
		MGETHDR(m, M_DONTWAIT, TPMT_TPHDR); 
d208 1
a208 1
		if(data != (struct mbuf *)0)
d217 1
a217 1
	bzero((caddr_t)hdr, sizeof(struct tpdu));
a219 2
		int 	tp_headersize();

d221 1
a221 1
		hdr->tpdu_li = tp_headersize(dutype, tpcb);  
d224 1
a224 1
		 * it'll just get overwritten below 
d226 7
a232 6
		hdr->tpdu_dref = htons(tpcb->tp_fref); 
		if( tpcb->tp_use_checksum || 
			(dutype == CR_TPDU_type && (tpcb->tp_class & TP_CLASS_4) )) {
			csum_offset =  hdr->tpdu_li + 2; /* DOESN'T include csum */
			ADDOPTION(TPP_checksum, hdr, 2, eot /* dummy arg */);
			IFDEBUG(D_CHKSUM)
d234 5
a238 4
					"tp_emit: csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
						csum_offset, hdr->tpdu_li);
			ENDDEBUG
		} 
d242 1
a242 1
		switch( dutype ) {
d246 1
a246 1
		case CC_TPDU_type: 
d254 3
a256 3
/* Case CC_TPDU_type used to be here */
		{
					u_char x;
d258 1
a258 1
				hdr->tpdu_CCsref =  htons(tpcb->tp_lref); /* same as CRsref */
d260 2
a261 2
				if( tpcb->tp_class > TP_CLASS_1 ) {
					tpcb->tp_sent_uwe = tpcb->tp_lcredit -1;
d268 2
a269 2
						struct isopcb *isop = (struct isopcb *)tpcb->tp_npcb;
						struct pklcd *lcp = (struct pklcd *)(isop->isop_chan);
d276 11
a286 8
				hdr->tpdu_CCoptions = 
					(tpcb->tp_xtd_format? TPO_XTD_FMT:0) |
					(tpcb->tp_use_efc? TPO_USE_EFC:0);

				IFPERF(tpcb)
					u_char perf_meas = tpcb->tp_perf_on;
					ADDOPTION(TPP_perf_meas, hdr, sizeof(perf_meas), perf_meas);
				ENDPERF
d288 1
a288 1
				if( dutype == CR_TPDU_type ) {
d291 2
a292 2
					ASSERT( tpcb->tp_lsuffixlen > 0 );
					ASSERT( tpcb->tp_fsuffixlen > 0 );
d295 1
a295 1
						tpcb->tp_lsuffixlen, tpcb->tp_lsuffix[0]);
d297 1
a297 1
						tpcb->tp_fsuffixlen, tpcb->tp_fsuffix[0]);
d302 2
a303 2
				ADDOPTION(TPP_tpdu_size, hdr, 
					sizeof(tpcb->tp_tpdusize), tpcb->tp_tpdusize);
d306 1
a306 1
					short millisec = 500*(tpcb->tp_sendack_ticks);
d311 4
a314 4
					x = (tpcb->tp_use_nxpd? TPAO_USE_NXPD: 0)
					 |	(tpcb->tp_use_rcc?  TPAO_USE_RCC : 0) 
					 |  (tpcb->tp_use_checksum?0: TPAO_NO_CSUM)
					 |	(tpcb->tp_xpd_service? TPAO_USE_TXPD: 0);
d318 2
a319 2
						u_short size_s = tpcb->tp_l_tpdusize >> 7;
						u_char size_c = size_s;
d331 1
a331 2
					
				if( (dutype == CR_TPDU_type) && (tpcb->tp_class != TP_CLASS_0)){
d333 1
a333 1
					ASSERT( 1 == sizeof(tpcb->tp_vers) );
d336 5
a340 5
					/* for each alt protocol class x,
					 * 	x = x<<4;
					 *  option = concat(option, x);
					 * Well, for now we only have TP0 for an
					 * alternative so... this is easy.
d342 4
a345 3
					 * HOWEVER... There should be NO alt protocol
					 * class over CLNS.  Need to see if the route suggests
					 * CONS, and iff so add alt class.
d350 1
a350 2

				if( hdr->tpdu_li > MLEN) 
d356 1
a356 1
			if( hdr->tpdu_DRdref == 0 ) {
d362 1
a362 1
			hdr->tpdu_DRreason = (u_char)eot; /* WHICH BYTE OF THIS??? */
d368 3
a370 3
		case DC_TPDU_type: /* not used in class 0 */
			ASSERT( tpcb->tp_class != TP_CLASS_0);
			hdr->tpdu_DCsref =  htons(tpcb->tp_lref);
d372 1
a372 1
			data = (struct mbuf *)0;
d376 2
a377 2
		case XAK_TPDU_type: /* xak not used in class 0 */
			ASSERT( tpcb->tp_class != TP_CLASS_0); /* fall through */
d380 2
a381 1
			IFTRACE(D_XPD)
d383 3
a385 2
			ENDTRACE
			data = (struct mbuf *)0;
d388 1
a388 1
				union seq_type seqeotX;
d395 1
a395 1
#endif /* BYTE_ORDER */
d403 2
a404 2
		case XPD_TPDU_type: /* xpd not used in class 0 */
			ASSERT( tpcb->tp_class != TP_CLASS_0); /* fall through */
d408 1
a408 1
				union seq_type seqeotX;
d415 2
a416 2
				hdr->tpdu_XPDeotX = 1; /* always 1 for XPD tpdu */
#endif /* BYTE_ORDER */
d419 1
a419 1
				hdr->tpdu_XPDeot = 1; /* always 1 for XPD tpdu */
d425 9
a433 6
			IFDEBUG(D_SIZE_CHECK)
				/*if(data->m_len <= 16 && data->m_off < (MLEN-18) ) {
					printf("Sending too much data on XPD: 18 bytes\n");
					data->m_len = 18;
				}*/
			ENDDEBUG
d438 7
a444 4
			IFTRACE(D_DATA)
				tptraceTPCB(TPPTmisc, "emit DT: eot seq tpdu_li", eot, seq, 
					hdr->tpdu_li, 0);
			ENDTRACE
d447 1
a447 1
				union seq_type seqeotX;
d455 1
a455 1
#endif /* BYTE_ORDER */
d457 2
a458 1
				IFDEBUG(D_EMIT)
d460 7
a466 5
					dump_buf( hdr, hdr->tpdu_li + 1 );
				ENDDEBUG
				((struct tp0du *)hdr)->tp0du_eot = eot;
				((struct tp0du *)hdr)->tp0du_mbz = 0;
				IFDEBUG(D_EMIT)
d468 3
a470 2
					dump_buf( hdr, hdr->tpdu_li + 1 );
				ENDDEBUG
d475 1
a475 1
			if(eot) {
d482 3
a484 3
		case AK_TPDU_type:/* ak not used in class 0 */
			ASSERT( tpcb->tp_class != TP_CLASS_0); 
			data = (struct mbuf *)0;
d488 3
a490 3
				LOCAL_CREDIT( tpcb ); 
				tpcb->tp_sent_uwe = 
					SEQ(tpcb,tpcb->tp_rcvnxt + tpcb->tp_lcredit -1);
d496 7
a502 4
			IFDEBUG(D_RENEG)
				/* occasionally fake a reneging so 
					you can test subsequencing */
				if( olduwe & 0x1 ) {
d506 10
a515 9
			ENDDEBUG
			/* Are we about to reneg on credit? 
			 * When might we do so?
			 *	a) when using optimistic credit (which we no longer do).
			 *  b) when drain() gets implemented (not in the plans).
			 *  c) when D_RENEG is on.
			 *  d) when DEC BIT response is implemented.
			 *	(not- when we do this, we'll need to implement flow control
			 *	confirmation)
d517 1
a517 1
			if( SEQ_LT(tpcb, tpcb->tp_sent_uwe, olduwe) ) {
d520 9
a528 7
				IFTRACE(D_CREDIT)
					tptraceTPCB(TPPTmisc, 
						"RENEG: olduwe newuwe lcredit rcvnxt",
						olduwe,
						tpcb->tp_sent_uwe, tpcb->tp_lcredit,
						tpcb->tp_rcvnxt);
				ENDTRACE
d530 4
a533 2
			IFPERF(tpcb)
				/* new lwe is less than old uwe means we're
d536 8
a543 4
				if( SEQ_LT( tpcb, tpcb->tp_rcvnxt, olduwe) ) {
					/* tmp1 = number of pkts fewer than the full window */
					register int tmp1 = 
						(int) SEQ_SUB( tpcb, olduwe, tpcb->tp_rcvnxt);
d545 1
a545 1
					if(tmp1 > TP_PM_MAX)
d547 1
a547 1
					IncPStat( tpcb,  tps_ack_early[tmp1] );
d549 7
a555 3
					/* tmp1 = amt of new cdt we're advertising */
					tmp1 = SEQ_SUB( tpcb, seq, tpcb->tp_sent_rcvnxt);
					if(tmp1 > TP_PM_MAX )
d558 6
a563 4
					IncPStat( tpcb, 
							tps_cdt_acked [ tmp1 ]
							[ ((tpcb->tp_lcredit > TP_PM_MAX)?
								TP_PM_MAX:tpcb->tp_lcredit) ] );
d566 10
a575 6
			ENDPERF

			IFTRACE(D_ACKSEND)
				tptraceTPCB(TPPTack, seq, tpcb->tp_lcredit, tpcb->tp_sent_uwe, 
					tpcb->tp_r_subseq, 0);
			ENDTRACE
d578 1
a578 1
				union seq_type seqeotX;
d585 1
a585 1
				hdr->tpdu_cdt = 0; 
d588 1
a588 1
#endif /* BYTE_ORDER */
d594 5
a598 4
				(tpcb->tp_reneged || acking_ooo)) {
				/* 
				 * Ack subsequence parameter req'd if WE reneged on 
				 * credit offered.  (ISO 8073, 12.2.3.8.2, p. 74)
d600 2
a601 1
				IFDEBUG(D_RENEG)
d603 2
a604 1
				ENDDEBUG
d609 2
a610 2
				ADDOPTION(TPP_subseq, hdr, 
					sizeof(tpcb->tp_s_subseq), tpcb->tp_s_subseq);
d614 29
a642 20
			if ( tpcb->tp_sendfcc || eot ) /* overloaded to mean SEND FCC */ {
				/* 
				 * Rules for sending FCC ("should" send when) :
				 * %a) received an ack from peer with NO NEWS whatsoever,
				 *  	and it did not contain an FCC
				 * 	b) received an ack from peer that opens its closed window.
				 * 	c) received an ack from peer after it reneged on its
				 *		offered credit, AND this ack raises UWE but LWE is same
				 *		and below UWE at time of reneging (reduction)
				 * Now, ISO 8073 12.2.3.8.3 says
				 * that a retransmitted AK shall not contain the FCC
				 * parameter.  Now, how the hell you tell the difference 
				 * between a retransmitted ack and an ack that's sent in 
				 * response to a received ack, I don't know, because without
				 * any local activity, and w/o any received DTs, they
				 * will contain exactly the same credit/seq# information.
				 * Anyway, given that the "retransmission of acks"
				 * procedure (ISO 8073 12.2.3.8.3) is optional, and we
				 * don't do it (although the peer can't tell that), we 
				 * ignore this last rule.
a643 3
				 * We send FCC for reasons a) and b) only. 
				 * To add reason c) would require a ridiculous amount of state.
				 * 
d645 4
a648 3
				u_short 	bogus[4]; /* lwe(32), subseq(16), cdt(16) */
				SeqNum		lwe;
				u_short		subseq, fcredit;
d656 12
a667 10
				bcopy((caddr_t) &lwe, (caddr_t)&bogus[0], sizeof(SeqNum));
				bcopy((caddr_t) &subseq, (caddr_t)&bogus[2], sizeof(u_short));
				bcopy((caddr_t) &fcredit, (caddr_t)&bogus[3], sizeof(u_short));

				IFTRACE(D_ACKSEND)
					tptraceTPCB(TPPTmisc, 
						"emit w/FCC: snduna r_subseq fcredit", 
						tpcb->tp_snduna, tpcb->tp_r_subseq,
						tpcb->tp_fcredit, 0);
				ENDTRACE
d669 2
a670 1
				IFDEBUG(D_ACKSEND)
d672 4
a675 3
						TPP_flow_cntl_conf, 
						hdr, sizeof(bogus), bogus[0]);
				ENDDEBUG
d677 2
a678 1
				IFDEBUG(D_ACKSEND)
d680 1
a680 1
						hdr, hdr->tpdu_li);
d682 5
a686 4
					"after ADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
							csum_offset, hdr->tpdu_li);
				ENDDEBUG
					
d691 1
a691 1
				int timo = tpcb->tp_keepalive_ticks;
d694 1
a694 1
				timo = min(timo, ((int)tpcb->tp_dt_ticks) << tpcb->tp_rxtshift);
d700 2
a701 1
			IFDEBUG(D_ACKSEND)
d703 4
a706 3
				"2 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
						csum_offset, hdr->tpdu_li);
			ENDDEBUG
d710 1
a710 1
			hdr->tpdu_ERreason = eot; 
d713 1
a713 1
			data = (struct mbuf *)0;
d719 1
a719 1
	ASSERT( ((int)hdr->tpdu_li > 0) && ((int)hdr->tpdu_li < MLEN) );
d723 2
a724 2
	ASSERT( hdr->tpdu_li < MLEN ); /* leave this in */
	ASSERT( hdr->tpdu_li != 0 ); /* leave this in */
d726 2
a727 2
	m->m_len = hdr->tpdu_li ; 
	hdr->tpdu_li --; /* doesn't include the li field */
d729 1
a729 1
	datalen = m_datalen( m ); /* total len */
d731 8
a738 10
	ASSERT( datalen <= tpcb->tp_l_tpdusize ); /* may become a problem
				when CLNP is used; leave in here for the time being */
		IFDEBUG(D_ACKSEND)
			printf(
			"4 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n",
					csum_offset, hdr->tpdu_li);
		ENDDEBUG
	if( datalen > tpcb->tp_l_tpdusize ) {
		printf("data len 0x%x tpcb->tp_l_tpdusize 0x%x\n", 
			datalen, tpcb->tp_l_tpdusize);
d740 7
a746 1
	IFDEBUG(D_EMIT)
d748 6
a753 5
		"tp_emit before gen_csum m_len 0x%x, csum_offset 0x%x, datalen 0x%x\n",
		m->m_len, csum_offset, datalen);
	ENDDEBUG
	if( tpcb->tp_use_checksum || 
		(dutype == CR_TPDU_type && (tpcb->tp_class & TP_CLASS_4)) ) {
d756 4
a759 4

	IFDEBUG(D_EMIT)
	printf("tp_emit before tpxxx_output tpcb 0x%x, dutype 0x%x, datalen 0x%x\n",
		tpcb, dutype, datalen);
d761 2
a762 1
	ENDDEBUG
d764 3
a766 2
	IFPERF(tpcb)
		if( dutype == DT_TPDU_type ) {
d768 3
a770 2
			tpmeas( tpcb->tp_lref, TPtime_to_ll,  (struct timeval *)0,
				seq, PStat(tpcb, Nb_to_ll), (datalen - m->m_len));
d772 2
a773 1
	ENDPERF
d775 7
a781 4
	IFTRACE(D_EMIT)
		tptraceTPCB(TPPTtpduout, dutype, hdr, hdr->tpdu_li+1, datalen, 0);
	ENDTRACE
	IFDEBUG(D_EMIT)
d783 3
a785 2
			tpcb,  tpcb->tp_npcb,  tpcb->tp_sock);
	ENDDEBUG
d787 2
a788 1
	{ extern char tp_delay;
d790 4
a793 4
		if( tp_delay )
			if( tpcb->tp_use_checksum == 0 ) {
				register u_int i  = tp_delay;
				for (; i!= 0; i--)
d797 5
a801 4
	ASSERT( m->m_len > 0 );
	error = (tpcb->tp_nlproto->nlp_output)(tpcb->tp_npcb, m, datalen,
		!tpcb->tp_use_checksum);
	IFDEBUG(D_EMIT)
d803 9
a811 6
	ENDDEBUG
	IFTRACE(D_EMIT)
		tptraceTPCB(TPPTmisc, 
			"tp_emit nlproto->output netservice returns datalen", 
			tpcb->tp_nlproto->nlp_output, tpcb->tp_netservice, error, datalen); 
	ENDTRACE
d817 1
a817 1
			tp_quench(tpcb, PRC_QUENCH);
d826 1
a826 1
 * 		response to an input error.
d828 11
a838 11
 * 		The error type is the first argument.
 * 		The argument (sref) is the source reference on the bad incoming tpdu,
 * 		and is used for a destination reference on the outgoing packet.
 * 		(faddr) and (laddr) are the foreign and local addresses for this 
 *		connection.
 * 		(erdata) is a ptr to the errant incoming tpdu, and is copied into the
 * 		outgoing ER, if an ER is to be issued.
 * 		(erlen)  is the number of octets of the errant tpdu that we should
 * 		try to copy.
 * 		(tpcb) is the pcb that describes the connection for which the bad tpdu
 * 		arrived.
d843 1
a843 1
 * SIDE EFFECTS:	
d845 1
a845 1
 * NOTES:			
d850 3
a852 3
	dgout_routine)
	int				error;
	u_long			sref;
d854 5
a858 5
	struct mbuf 	*erdata;
	int 			erlen;
	struct tp_pcb 	*tpcb;
	caddr_t			cons_channel;
	int				(*dgout_routine)();
d860 5
a864 5
	int						dutype;
	int 					datalen = 0;
	register struct tpdu	*hdr; 
	register struct mbuf	*m;
	int						csum_offset;
d866 3
a868 2
	IFTRACE(D_ERROR_EMIT)
		tptrace(TPPTmisc, "tp_error_emit error sref tpcb erlen", 
d870 4
a873 2
	ENDTRACE
	IFDEBUG(D_ERROR_EMIT)
d875 4
a878 3
		"tp_error_emit error 0x%x sref 0x%x tpcb 0x%x erlen 0x%x chan 0x%x\n", 
			error, sref, tpcb, erlen, cons_channel);
	ENDDEBUG
d880 1
a880 1
	MGET(m, M_DONTWAIT, TPMT_TPHDR); 
d889 2
a890 1
	IFDEBUG(D_ERROR_EMIT)
d892 3
a894 2
			error, error&0xff, (char)error);
	ENDDEBUG
d909 1
a909 1
	switch( dutype ) {
d916 2
a917 1
		IFDEBUG(D_ERROR_EMIT)
d919 3
a921 2
			dump_buf( hdr, 6);
		ENDDEBUG
d930 3
a932 2
		hdr->tpdu_DRreason = (char)error;
		IFDEBUG(D_ERROR_EMIT)
d934 3
a936 2
			dump_buf( hdr, 7);
		ENDDEBUG
d942 2
a943 2
		hdr->tpdu_li = 5; 
		hdr->tpdu_ERreason = (char)error;
d952 4
a955 4
	if(tpcb)
		if( tpcb->tp_use_checksum ) {
			ADDOPTION(TPP_checksum, hdr, 2, csum_offset /* dummy argument */); 
			csum_offset =  hdr->tpdu_li - 2;
d957 1
a957 2

	ASSERT( hdr->tpdu_li < MLEN ); 
d963 2
a964 1
		IFTRACE(D_ERROR_EMIT)
d966 5
a970 3
				0,0);
		ENDTRACE
		IFDEBUG(D_ERROR_EMIT)
d972 2
a973 1
		ENDDEBUG
d978 1
a978 1
			
d980 2
a981 2
		P = (caddr_t)hdr + (int)(hdr->tpdu_li);
		vbptr(P)->tpv_code =  TPP_invalid_tpdu; /* parameter code */
d983 1
a983 1
		m->m_len = hdr->tpdu_li + 2; /* 1 for code, 1 for length */
d985 2
a986 1
		/* tp_input very likely handed us an mbuf chain w/ nothing in
d989 3
a991 2
		if(erdata->m_len == 0) {
			erdata = m_free(erdata); /* returns the next mbuf on the chain */
d998 1
a998 1
		hdr->tpdu_li += erlen + 2; 
d1001 2
a1002 1
		IFDEBUG(D_ERROR_EMIT)
d1004 4
a1007 3
			dump_buf( (char *)hdr, hdr->tpdu_li );
		ENDDEBUG
		m->m_len = hdr->tpdu_li ;
d1011 6
a1016 4
	hdr->tpdu_li --;
	IFTRACE(D_ERROR_EMIT)
		tptrace(TPPTtpduout, 2, hdr, hdr->tpdu_li+1, 0, 0);
	ENDTRACE
d1018 1
a1018 1
	datalen = m_datalen( m);
d1020 12
a1031 8
		if( tpcb->tp_use_checksum ) {
			IFTRACE(D_ERROR_EMIT)
				tptrace(TPPTmisc, "before gen csum datalen", datalen,0,0,0);
			ENDTRACE
			IFDEBUG(D_ERROR_EMIT)
				printf("before gen csum datalen 0x%x, csum_offset 0x%x\n", 
					datalen, csum_offset);
			ENDDEBUG
d1035 2
a1036 2

		IFDEBUG(D_ERROR_EMIT)
d1038 3
a1040 2
				tpcb,  tpcb->tp_npcb,  tpcb->tp_sock);
		ENDDEBUG
d1044 13
a1056 8
		struct pklcd *lcp = (struct pklcd *)cons_channel;
		struct isopcb *isop = (struct isopcb *)lcp->lcd_upnext;

		tpcons_dg_output(cons_channel, m, datalen);
		/* was if (tpcb == 0) iso_pcbdetach(isop); */
		/* but other side may want to try again over same VC,
		   so, we'll depend on him closing it, but in case it gets forgotten
		   we'll mark it for garbage collection */
d1058 2
a1059 1
		IFDEBUG(D_ERROR_EMIT)
d1061 3
a1063 2
				dutype, cons_channel);
		ENDDEBUG
d1066 1
a1066 1
			cons_channel);
d1068 1
d1071 2
a1072 1
		IFDEBUG(D_ERROR_EMIT)
d1077 6
a1082 6
		ENDDEBUG
		return (tpcb->tp_nlproto->nlp_dgoutput)(
			&laddr->siso_addr, 
			&faddr->siso_addr, 
			m, datalen, 
					/* no route */	(caddr_t)0, !tpcb->tp_use_checksum); 
d1084 10
a1093 9
			IFDEBUG(D_ERROR_EMIT)
				printf("tp_error_emit sending DG: Laddr\n");
				dump_addr(sisotosa(laddr));
				printf("Faddr\n");
				dump_addr(sisotosa(faddr));
			ENDDEBUG
				return (*dgout_routine)( &laddr->siso_addr, &faddr->siso_addr, 
					m, datalen, /* no route */ 
					(caddr_t)0, /* nochecksum==false */0);
d1095 8
a1102 6
			IFDEBUG(D_ERROR_EMIT)
				printf("tp_error_emit DROPPING \n", m);
			ENDDEBUG
			IncStat(ts_send_drop);
			m_freem(m);
			return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
