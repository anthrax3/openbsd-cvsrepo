head	1.6;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.32
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.30
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.28
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.5;

1.5
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.08;	author deraadt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	96.03.04.10.34.48;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.13;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: clnp_er.c,v 1.5 2003/12/10 07:22:43 itojun Exp $	*/
/*	$NetBSD: clnp_er.c,v 1.8 1996/04/13 01:34:20 cgd Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)clnp_er.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/route.h>

#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_pcb.h>
#define CLNP_ER_CODES
#include <netiso/clnp.h>
#include <netiso/clnp_stat.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_param.h>
#include <netiso/tp_var.h>

static struct clnp_fixed er_template = {
	ISO8473_CLNP,		/* network identifier */
	0,			/* length */
	ISO8473_V1,		/* version */
	CLNP_TTL,		/* ttl */
	CLNP_ER,		/* type */
	0,			/* segment length */
	0			/* checksum */
};

/*
 * FUNCTION:		clnp_er_input
 *
 * PURPOSE:			Process an ER pdu.
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
clnp_er_input(m, src, reason)
	struct mbuf    *m;	/* ptr to packet itself */
	struct iso_addr *src;	/* ptr to src of er */
	u_int           reason;	/* reason code of er */
{
	int             cmd = -1;

#ifdef ARGO_DEBUG
	if (argo_debug[D_CTLINPUT]) {
		printf("clnp_er_input: m %p, src %s, reason x%x\n",
		       m, clnp_iso_addrp(src), reason);
	}
#endif

	INCSTAT(cns_er_inhist[clnp_er_index(reason)]);
	switch (reason) {
	case GEN_NOREAS:
	case GEN_PROTOERR:
		break;
	case GEN_BADCSUM:
		cmd = PRC_PARAMPROB;
		break;
	case GEN_CONGEST:
		cmd = PRC_QUENCH;
		break;
	case GEN_HDRSYNTAX:
		cmd = PRC_PARAMPROB;
		break;
	case GEN_SEGNEEDED:
		cmd = PRC_MSGSIZE;
		break;
	case GEN_INCOMPLETE:
		cmd = PRC_PARAMPROB;
		break;
	case GEN_DUPOPT:
		cmd = PRC_PARAMPROB;
		break;
	case ADDR_DESTUNREACH:
		cmd = PRC_UNREACH_HOST;
		break;
	case ADDR_DESTUNKNOWN:
		cmd = PRC_UNREACH_PROTOCOL;
		break;
	case SRCRT_UNSPECERR:
	case SRCRT_SYNTAX:
	case SRCRT_UNKNOWNADDR:
	case SRCRT_BADPATH:
		cmd = PRC_UNREACH_SRCFAIL;
		break;
	case TTL_EXPTRANSIT:
		cmd = PRC_TIMXCEED_INTRANS;
		break;
	case TTL_EXPREASS:
		cmd = PRC_TIMXCEED_REASS;
		break;
	case DISC_UNSUPPOPT:
	case DISC_UNSUPPVERS:
	case DISC_UNSUPPSECURE:
	case DISC_UNSUPPSRCRT:
	case DISC_UNSUPPRECRT:
		cmd = PRC_PARAMPROB;
		break;
	case REASS_INTERFERE:
		cmd = PRC_TIMXCEED_REASS;
		break;
	}

	/*
	 *	tpclnp_ctlinput1 is called directly so that we don't
	 *	have to build an iso_sockaddr out of src.
	 */
	if (cmd >= 0)
		tpclnp_ctlinput1(cmd, src);

	m_freem(m);
}

/*
 * FUNCTION:		clnp_discard
 *
 * PURPOSE:		Discard a clnp datagram
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:	Will emit an ER pdu if possible
 *
 * NOTES:		This code assumes that we have previously tried to pull
 *			up the header of the datagram into one mbuf.
 */
void
clnp_discard(m, reason)
	struct mbuf    *m;	/* header of packet to discard */
	u_int           reason;	/* reason for discard */
{
#ifdef ARGO_DEBUG
	if (argo_debug[D_DISCARD]) {
		printf("clnp_discard: m %p, reason x%x\n", m, reason);
	}
#endif

	if (m != NULL) {
		if (m->m_len >= sizeof(struct clnp_fixed)) {
			struct clnp_fixed *clnp =
				mtod(m, struct clnp_fixed *);

			if (((clnp->cnf_type & CNF_TYPE) != CLNP_ER) &&
			    (clnp->cnf_type & CNF_ERR_OK)) {
				clnp_emit_er(m, reason);
				return;
			}
		}
		m_freem(m);
	}
}

/*
 * FUNCTION:		clnp_emit_er
 *
 * PURPOSE:		Send an ER pdu.
 *			The src of the of the ER pdu is the host that is sending
 *			the ER (ie. us), *not* the original destination of the
 *			packet.
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Takes responsibility for freeing mbuf passed
 *			This function may be called with a packet that
 *			was created by us; in this case, do not send
 *			an ER.
 */
void
clnp_emit_er(m, reason)
	struct mbuf    *m;	/* header of packet to discard */
	u_int           reason;	/* reason for discard */
{
	struct clnp_fixed *clnp = mtod(m, struct clnp_fixed *);
	struct clnp_fixed *er;
	struct route_iso route;
	struct ifnet   *ifp;
	struct sockaddr *first_hop;
	struct iso_addr src, dst, *our_addr;
	caddr_t         hoff, hend;
	int             total_len;	/* total len of dg */
	struct mbuf    *m0;	/* contains er pdu hdr */
	struct iso_ifaddr *ia = 0;

#ifdef ARGO_DEBUG
	if (argo_debug[D_DISCARD]) {
		printf("clnp_emit_er: m %p, hdr len %d\n",
		       m, clnp->cnf_hdr_len);
	}
#endif

	bzero((caddr_t) & route, sizeof(route));

	/*
	 * If header length is incorrect, or entire header is not contained
	 * in this mbuf, we punt
	 */
	if ((clnp->cnf_hdr_len < CLNP_HDR_MIN) ||
	    (clnp->cnf_hdr_len > CLNP_HDR_MAX) ||
	    (clnp->cnf_hdr_len > m->m_len))
		goto bad;

	/* extract src, dest address */
	hend = (caddr_t) clnp + clnp->cnf_hdr_len;
	hoff = (caddr_t) clnp + sizeof(struct clnp_fixed);
	CLNP_EXTRACT_ADDR(dst, hoff, hend);
	if (hoff == (caddr_t) 0) {
		goto bad;
	}
	CLNP_EXTRACT_ADDR(src, hoff, hend);
	if (hoff == (caddr_t) 0) {
		goto bad;
	}
	/*
	 * Do not send ER if we generated the packet.
	 */
	if (clnp_ours(&src))
		goto bad;

	/*
	 * Trim mbuf to hold only the header. This mbuf will be the 'data' of
	 * the er pdu
	 */
	if (m->m_next != NULL) {
		m_freem(m->m_next);
		m->m_next = NULL;
	}
	if (m->m_len > clnp->cnf_hdr_len)
		m_adj(m, (int) -(m->m_len - (int) clnp->cnf_hdr_len));

	/* route er pdu: note we send pkt to src of original packet  */
	if (clnp_route(&src, &route, /* flags */ 0, &first_hop, &ia) != 0)
		goto bad;

	/* compute our address based upon firsthop/ifp */
	if (ia)
		our_addr = &ia->ia_addr.siso_addr;
	else
		goto bad;
	ifp = ia->ia_ifp;

#ifdef ARGO_DEBUG
	if (argo_debug[D_DISCARD]) {
		printf("clnp_emit_er: to %s", clnp_iso_addrp(&src));
		printf(" from %s\n", clnp_iso_addrp(our_addr));
	}
#endif

#ifdef ARGO_DEBUG
	if (argo_debug[D_DISCARD]) {
		printf("clnp_emit_er: packet routed to %s\n",
		       clnp_iso_addrp(&satosiso(first_hop)->siso_addr));
	}
#endif

	/* allocate mbuf for er pdu header: punt on no space */
	MGET(m0, M_DONTWAIT, MT_HEADER);
	if (m0 == 0)
		goto bad;

	m0->m_next = m;
	er = mtod(m0, struct clnp_fixed *);
	*er = er_template;

	/* setup src/dst on er pdu */
	/* NOTE REVERSAL OF SRC/DST */
	hoff = (caddr_t) er + sizeof(struct clnp_fixed);
	CLNP_INSERT_ADDR(hoff, src);
	CLNP_INSERT_ADDR(hoff, *our_addr);

	/*
	 *	TODO: if complete src rt was specified, then reverse path, and
	 *	copy into er as option.
	 */

	/* add er option */
	*hoff++ = CLNPOVAL_ERREAS;	/* code */
	*hoff++ = 2;		/* length */
	*hoff++ = reason;	/* discard reason */
	*hoff++ = 0;		/* error localization = not specified */

	/* set length */
	er->cnf_hdr_len = m0->m_len = (u_char) (hoff - (caddr_t) er);
	total_len = m0->m_len + m->m_len;
	HTOC(er->cnf_seglen_msb, er->cnf_seglen_lsb, total_len);

	/* compute checksum (on header only) */
	iso_gen_csum(m0, CLNP_CKSUM_OFF, (int) er->cnf_hdr_len);

	/* trim packet if too large for interface */
	if (total_len > ifp->if_mtu)
		m_adj(m0, -(total_len - ifp->if_mtu));

	/* send packet */
	INCSTAT(cns_er_outhist[clnp_er_index(reason)]);
	(void) (*ifp->if_output) (ifp, m0, first_hop, route.ro_rt);
	goto done;

bad:
	m_freem(m);

done:
	/* free route if it is a temp */
	if (route.ro_rt != NULL)
		RTFREE(route.ro_rt);
}

int
clnp_er_index(p)
	u_int p;
{
	u_char *cp = clnp_er_codes + CLNP_ERRORS;
	while (cp > clnp_er_codes) {
		cp--;
		if (*cp == p)
			return (cp - clnp_er_codes);
	}
	return (CLNP_ERRORS + 1);
}
@


1.5
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: clnp_er.c,v 1.4 2003/06/02 23:28:16 millert Exp $	*/
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: clnp_er.c,v 1.3 1996/04/21 22:29:08 deraadt Exp $	*/
d208 1
a208 1
			register struct clnp_fixed *clnp =
d243 2
a244 2
	register struct clnp_fixed *clnp = mtod(m, struct clnp_fixed *);
	register struct clnp_fixed *er;
d381 1
a381 1
	register u_char *cp = clnp_er_codes + CLNP_ERRORS;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: clnp_er.c,v 1.2 1996/03/04 10:34:48 mickey Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3.16.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: clnp_er.c,v 1.3 1996/04/21 22:29:08 deraadt Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d208 1
a208 1
			struct clnp_fixed *clnp =
d243 2
a244 2
	struct clnp_fixed *clnp = mtod(m, struct clnp_fixed *);
	struct clnp_fixed *er;
d381 1
a381 1
	u_char *cp = clnp_er_codes + CLNP_ERRORS;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: clnp_er.c,v 1.7 1996/02/13 22:08:17 christos Exp $	*/
d119 2
a120 2
		printf("clnp_er_input: m x%x, src %s, reason x%x\n",
		       (unsigned int) m, clnp_iso_addrp(src), reason);
d206 1
a206 2
		printf("clnp_discard: m x%x, reason x%x\n",
		       (unsigned int) m, reason);
d260 2
a261 2
		printf("clnp_emit_er: m x%x, hdr len %d\n",
		       (unsigned int) m, clnp->cnf_hdr_len);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: clnp_er.c,v 1.6 1995/06/13 07:13:17 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d73 1
d85 2
d89 2
a90 2
	ISO8473_CLNP,	/* network identifier */
	0,				/* length */
d94 2
a95 2
	0,				/* segment length */
	0				/* checksum */
d103 1
a103 1
 * RETURNS:			
d105 1
a105 1
 * SIDE EFFECTS:	
d107 1
a107 1
 * NOTES:			
d109 1
d111 3
a113 3
struct mbuf		*m;		/* ptr to packet itself */
struct iso_addr	*src;	/* ptr to src of er */
u_char			reason;	/* reason code of er */
d115 1
a115 2
	int	cmd = -1;
	extern u_char clnp_protox[];
d117 6
a122 4
	IFDEBUG(D_CTLINPUT)
		printf("clnp_er_input: m x%x, src %s, reason x%x\n", m, 
			clnp_iso_addrp(src), reason);
	ENDDEBUG
d126 49
a174 49
		case GEN_NOREAS:
		case GEN_PROTOERR:
			break;
		case GEN_BADCSUM:		
			cmd = PRC_PARAMPROB;
			break;
		case GEN_CONGEST:		
			cmd = PRC_QUENCH;
			break;
		case GEN_HDRSYNTAX:		
			cmd = PRC_PARAMPROB;
			break;
		case GEN_SEGNEEDED:		
			cmd = PRC_MSGSIZE; 
			break;
		case GEN_INCOMPLETE:	
			cmd = PRC_PARAMPROB; 		
			break;
		case GEN_DUPOPT:		
			cmd = PRC_PARAMPROB;		
			break;
		case ADDR_DESTUNREACH:	
			cmd = PRC_UNREACH_HOST; 	
			break;
		case ADDR_DESTUNKNOWN:	
			cmd = PRC_UNREACH_PROTOCOL; 
			break;
		case SRCRT_UNSPECERR:
		case SRCRT_SYNTAX:
		case SRCRT_UNKNOWNADDR:
		case SRCRT_BADPATH:
			cmd = PRC_UNREACH_SRCFAIL;
			break;
		case TTL_EXPTRANSIT:	
			cmd = PRC_TIMXCEED_INTRANS;	
			break;
		case TTL_EXPREASS:		
			cmd = PRC_TIMXCEED_REASS;	
			break;
		case DISC_UNSUPPOPT:
		case DISC_UNSUPPVERS:
		case DISC_UNSUPPSECURE:
		case DISC_UNSUPPSRCRT:
		case DISC_UNSUPPRECRT:
			cmd = PRC_PARAMPROB; 
			break;
		case REASS_INTERFERE:	
			cmd = PRC_TIMXCEED_REASS;
			break;
d190 1
a190 1
 * PURPOSE:			Discard a clnp datagram
d192 1
a192 1
 * RETURNS:			nothing
d196 2
a197 2
 * NOTES:			This code assumes that we have previously tried to pull
 *					up the header of the datagram into one mbuf.
d199 1
d201 2
a202 2
struct mbuf	*m;		/* header of packet to discard */
char					reason;	/* reason for discard */
d204 6
a209 3
	IFDEBUG(D_DISCARD)
		printf("clnp_discard: m x%x, reason x%x\n", m, reason);
	ENDDEBUG
d213 2
a214 1
			register struct clnp_fixed *clnp = mtod(m, struct clnp_fixed *);
d217 3
a219 3
				(clnp->cnf_type & CNF_ERR_OK)) {
					clnp_emit_er(m, reason);
					return;
d229 13
a241 13
 * PURPOSE:			Send an ER pdu.
 *					The src of the of the ER pdu is the host that is sending
 *					the ER (ie. us), *not* the original destination of the
 *					packet.
 *
 * RETURNS:			nothing
 *
 * SIDE EFFECTS:	
 *
 * NOTES:			Takes responsibility for freeing mbuf passed
 *					This function may be called with a packet that
 *					was created by us; in this case, do not send
 *					an ER.
d243 1
d245 2
a246 2
struct mbuf	*m;		/* header of packet to discard */
char					reason;	/* reason for discard */
d248 17
a264 14
	register struct clnp_fixed	*clnp = mtod(m, struct clnp_fixed *);
	register struct clnp_fixed	*er;
	struct route_iso			route;
	struct ifnet				*ifp;
	struct sockaddr				*first_hop;
	struct iso_addr				src, dst, *our_addr;
	caddr_t						hoff, hend;
	int							total_len;		/* total len of dg */
	struct mbuf 				*m0;			/* contains er pdu hdr */
	struct iso_ifaddr			*ia = 0;

	IFDEBUG(D_DISCARD)
		printf("clnp_emit_er: m x%x, hdr len %d\n", m, clnp->cnf_hdr_len);
	ENDDEBUG
d266 1
a266 1
	bzero((caddr_t)&route, sizeof(route));
d269 2
a270 2
	 *	If header length is incorrect, or entire header is not contained
	 *	in this mbuf, we punt
d273 2
a274 2
		(clnp->cnf_hdr_len > CLNP_HDR_MAX) ||
		(clnp->cnf_hdr_len > m->m_len))
d276 1
a276 1
	
d278 2
a279 2
	hend = (caddr_t)clnp + clnp->cnf_hdr_len;
	hoff = (caddr_t)clnp + sizeof(struct clnp_fixed);
d281 1
a281 1
	if (hoff == (caddr_t)0) {
d285 1
a285 1
	if (hoff == (caddr_t)0) {
a287 1
	
d289 1
a289 1
	 *	Do not send ER if we generated the packet.
d294 3
a296 3
	/* 
	 *	Trim mbuf to hold only the header.
	 *	This mbuf will be the 'data' of the er pdu
a301 1

d303 1
a303 1
		m_adj(m, (int)-(m->m_len - (int)clnp->cnf_hdr_len));
d306 1
a306 1
	if (clnp_route(&src, &route, /* flags */0, &first_hop, &ia) != 0)
d311 1
a311 1
			our_addr = &ia->ia_addr.siso_addr;
d313 1
a313 1
			goto bad;
d316 2
a317 1
	IFDEBUG(D_DISCARD)
d320 2
a321 1
	ENDDEBUG
d323 6
a328 4
	IFDEBUG(D_DISCARD)
		printf("clnp_emit_er: packet routed to %s\n", 
			clnp_iso_addrp(&satosiso(first_hop)->siso_addr));
	ENDDEBUG
d334 1
a334 1
	
d341 1
a341 1
	hoff = (caddr_t)er + sizeof(struct clnp_fixed);
d352 3
a354 3
	*hoff++ = 2;				/* length */
	*hoff++ = reason;			/* discard reason */
	*hoff++ = 0;				/* error localization = not specified */
d357 1
a357 1
	er->cnf_hdr_len = m0->m_len = (u_char)(hoff - (caddr_t)er);
d362 1
a362 1
	iso_gen_csum(m0, CLNP_CKSUM_OFF, (int)er->cnf_hdr_len);
d367 1
a367 1
	
d370 1
a370 1
	(void) (*ifp->if_output)(ifp, m0, first_hop, route.ro_rt);
d382 1
d384 1
a384 1
u_char p;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
