head	1.11;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.22
	OPENBSD_2_8:1.4.0.20
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.18
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.16
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.14
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.12
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.10
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.8
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.11
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.10;

1.10
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.10.07.22.43;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.17;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.05.16.12.54.06;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.21;	author deraadt;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	96.04.21.22.29.21;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.10.35.15;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.14;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.14;	author deraadt;	state Exp;
branches;
next	;

1.4.16.1
date	2001.07.04.10.55.33;	author niklas;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.4.16.4;

1.4.16.4
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.4.16.5;

1.4.16.5
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	;


desc
@@


1.11
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: esis.c,v 1.10 2004/01/03 14:08:54 espie Exp $	*/
/*	$NetBSD: esis.c,v 1.14 1996/05/07 02:45:04 thorpej Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)esis.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */

#ifdef ISO

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>
#include <net/raw_cb.h>

#include <netiso/iso.h>
#include <netiso/iso_pcb.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#include <netiso/clnl.h>
#include <netiso/clnp.h>
#include <netiso/clnp_stat.h>
#include <netiso/esis.h>
#include <netiso/argo_debug.h>

#include <sys/stdarg.h>
/*
 *	Global variables to esis implementation
 *
 *	esis_holding_time - the holding time (sec) parameter for outgoing pdus
 *	esis_config_time  - the frequency (sec) that hellos are generated
 *	esis_esconfig_time - suggested es configuration time placed in the ish.
 *
 */
LIST_HEAD(, rawcb) esis_pcb;
int             esis_sendspace = 2048;
int             esis_recvspace = 2048;
short           esis_holding_time = ESIS_HT;
short           esis_config_time = ESIS_CONFIG;
short           esis_esconfig_time = ESIS_CONFIG;
extern int      iso_systype;
struct sockaddr_dl esis_dl = {sizeof(esis_dl), AF_LINK};
extern char     all_es_snpa[], all_is_snpa[];

struct timeout	snpac_timeout;
struct timeout	esis_timeout;

#define EXTEND_PACKET(m, mhdr, cp)\
	if (((m)->m_next = m_getclr(M_DONTWAIT, MT_HEADER)) == NULL) {\
		esis_stat.es_nomem++;\
		m_freem(mhdr);\
		return;\
	} else {\
		(m) = (m)->m_next;\
		(cp) = mtod((m), caddr_t);\
	}

/*
 * FUNCTION:		esis_init
 *
 * PURPOSE:		Initialize the kernel portion of esis protocol
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_init()
{
	extern struct clnl_protosw clnl_protox[256];

	LIST_INIT(&esis_pcb);

	timeout_set(&snpac_timeout, snpac_age, NULL);
	timeout_set(&esis_timeout, esis_config, NULL);
	timeout_add(&snpac_timeout, hz);
	timeout_add(&esis_timeout, hz);

	clnl_protox[ISO9542_ESIS].clnl_input = esis_input;
	clnl_protox[ISO10589_ISIS].clnl_input = isis_input;
#ifdef	ISO_X25ESIS
	clnl_protox[ISO9542X25_ESIS].clnl_input = x25esis_input;
#endif				/* ISO_X25ESIS */
}

/*
 * FUNCTION:		esis_usrreq
 *
 * PURPOSE:		Handle user level esis requests
 *
 * RETURNS:		0 or appropriate errno
 *
 * SIDE EFFECTS:
 *
 */
/* ARGSUSED */
int
esis_usrreq(so, req, m, nam, control)
	struct socket  *so;	/* socket: used only to get to this code */
	int             req;	/* request */
	struct mbuf    *m;	/* data for request */
	struct mbuf    *nam;	/* optional name */
	struct mbuf    *control;/* optional control */
{
	struct rawcb   *rp = sotorawcb(so);
	int             error = 0;

	if ((so->so_state & SS_PRIV) == 0) {
		error = EACCES;
		goto release;
	}
	if (rp == NULL && req != PRU_ATTACH) {
		error = EINVAL;
		goto release;
	}
	switch (req) {
	case PRU_ATTACH:
		if (rp != NULL) {
			error = EINVAL;
			break;
		}
		MALLOC(rp, struct rawcb *, sizeof(*rp), M_PCB, M_WAITOK);
		so->so_pcb = rp;
		bzero(so->so_pcb, sizeof(*rp));
		LIST_INSERT_HEAD(&esis_pcb, rp, rcb_list);
		rp->rcb_socket = so;
		error = soreserve(so, esis_sendspace, esis_recvspace);
		break;

	case PRU_SEND:
		if (nam == NULL) {
			error = EINVAL;
			break;
		}
		/* error checking here */
		error = isis_output(m, mtod(nam, struct sockaddr_dl *));
		m = NULL;
		break;

	case PRU_DETACH:
		raw_detach(rp);
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	case PRU_ABORT:
		soisdisconnected(so);
		raw_detach(rp);
		break;

	case PRU_SENSE:
		return (0);

	default:
		return (EOPNOTSUPP);
	}
release:
	if (m != NULL)
		m_freem(m);

	return (error);
}

/*
 * FUNCTION:		esis_input
 *
 * PURPOSE:		Process an incoming esis packet
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_input(struct mbuf *m0, ...)
{
	struct snpa_hdr *shp;	/* subnetwork header */
	struct esis_fixed *pdu = mtod(m0, struct esis_fixed *);
	int    type;
	va_list ap;

	va_start(ap, m0);
	shp = va_arg(ap, struct snpa_hdr *);
	va_end(ap);

	/*
	 *	check checksum if necessary
	 */
	if (ESIS_CKSUM_REQUIRED(pdu) &&
	    iso_check_csum(m0, (int) pdu->esis_hdr_len)) {
		esis_stat.es_badcsum++;
		goto bad;
	}
	/* check version */
	if (pdu->esis_vers != ESIS_VERSION) {
		esis_stat.es_badvers++;
		goto bad;
	}
	type = pdu->esis_type & 0x1f;
	switch (type) {
	case ESIS_ESH:
		esis_eshinput(m0, shp);
		break;

	case ESIS_ISH:
		esis_ishinput(m0, shp);
		break;

	case ESIS_RD:
		esis_rdinput(m0, shp);
		break;

	default:
		esis_stat.es_badtype++;
	}

bad:
	if (esis_pcb.lh_first != 0)
		isis_input(m0, shp);
	else
		m_freem(m0);
}

/*
 * FUNCTION:		esis_rdoutput
 *
 * PURPOSE:		Transmit a redirect pdu
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Assumes there is enough space for fixed part of header,
 *			DA, BSNPA and NET in first mbuf.
 */
void
esis_rdoutput(inbound_shp, inbound_m, inbound_oidx, rd_dstnsap, rt)
	struct snpa_hdr *inbound_shp;	/* snpa hdr from incoming packet */
	struct mbuf    *inbound_m;	/* incoming pkt itself */
	struct clnp_optidx *inbound_oidx;	/* clnp options assoc with
						 * incoming pkt */
	struct iso_addr *rd_dstnsap;	/* ultimate destination of pkt */
	struct rtentry *rt;	/* snpa cache info regarding next hop of pkt */
{
	struct mbuf    *m, *m0;
	caddr_t         cp;
	struct esis_fixed *pdu;
	int             len;
	struct sockaddr_iso siso;
	struct ifnet   *ifp = inbound_shp->snh_ifp;
	struct sockaddr_dl *sdl;
	struct iso_addr *rd_gwnsap;

	if (rt->rt_flags & RTF_GATEWAY) {
		rd_gwnsap = &satosiso(rt->rt_gateway)->siso_addr;
		rt = rtalloc1(rt->rt_gateway, 0);
	} else
		rd_gwnsap = &satosiso(rt_key(rt))->siso_addr;
	if (rt == 0 || (sdl = (struct sockaddr_dl *) rt->rt_gateway) == 0 ||
	    sdl->sdl_family != AF_LINK) {
		/*
		 * maybe we should have a function that you could put in the
		 * iso_ifaddr structure which could translate iso_addrs into
		 * snpa's where there is a known mapping for that address
		 * type
		 */
		esis_stat.es_badtype++;
		return;
	}
	esis_stat.es_rdsent++;
#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISOUTPUT]) {
		printf(
		"esis_rdoutput: ifp %p (%s), ht %d, m %p, oidx %p\n",
		       ifp, ifp->if_xname, esis_holding_time,
		       inbound_m, inbound_oidx);
		printf("\tdestination: %s\n", clnp_iso_addrp(rd_dstnsap));
		printf("\tredirected toward:%s\n", clnp_iso_addrp(rd_gwnsap));
	}
#endif

	if ((m0 = m = m_gethdr(M_DONTWAIT, MT_HEADER)) == NULL) {
		esis_stat.es_nomem++;
		return;
	}
	bzero(mtod(m, caddr_t), MHLEN);

	pdu = mtod(m, struct esis_fixed *);
	cp = (caddr_t) (pdu + 1);	/* pointer arith.; 1st byte after
					 * header */
	len = sizeof(struct esis_fixed);

	/*
	 *	Build fixed part of header
	 */
	pdu->esis_proto_id = ISO9542_ESIS;
	pdu->esis_vers = ESIS_VERSION;
	pdu->esis_type = ESIS_RD;
	HTOC(pdu->esis_ht_msb, pdu->esis_ht_lsb, esis_holding_time);

	/* Insert destination address */
	(void) esis_insert_addr(&cp, &len, rd_dstnsap, m, 0);

	/* Insert the snpa of better next hop */
	*cp++ = sdl->sdl_alen;
	bcopy(LLADDR(sdl), cp, sdl->sdl_alen);
	cp += sdl->sdl_alen;
	len += (sdl->sdl_alen + 1);

	/*
	 * If the next hop is not the destination, then it ought to be an IS
	 * and it should be inserted next. Else, set the NETL to 0
	 */
	/* PHASE2 use mask from ifp of outgoing interface */
	if (!iso_addrmatch1(rd_dstnsap, rd_gwnsap)) {
#if 0
		/* this should not happen: */
		if ((nhop_sc->sc_flags & SNPA_IS) == 0) {
			printf(
		    "esis_rdoutput: next hop is not dst and not an IS\n");
			m_freem(m0);
			return;
		}
#endif
		(void) esis_insert_addr(&cp, &len, rd_gwnsap, m, 0);
	} else {
		*cp++ = 0;	/* NETL */
		len++;
	}
	m->m_len = len;

	/*
	 * PHASE2
	 * If redirect is to an IS, add an address mask. The mask to be
	 * used should be the mask present in the routing entry used to
	 * forward the original data packet.
	 */

	/*
	 * Copy Qos, priority, or security options present in original npdu
	 */
	if (inbound_oidx) {
		/* THIS CODE IS CURRENTLY (mostly) UNTESTED */
		int             optlen = 0;
		if (inbound_oidx->cni_qos_formatp)
			optlen += (inbound_oidx->cni_qos_len + 2);
		if (inbound_oidx->cni_priorp)	/* priority option is 1 byte
						 * long */
			optlen += 3;
		if (inbound_oidx->cni_securep)
			optlen += (inbound_oidx->cni_secure_len + 2);
		if (M_TRAILINGSPACE(m) < optlen) {
			EXTEND_PACKET(m, m0, cp);
			m->m_len = 0;
			/* assumes MLEN > optlen */
		}
		/* assume MLEN-len > optlen */
		/*
		 * When copying options, copy from ptr - 2 in order to grab
		 * the option code and length
		 */
		if (inbound_oidx->cni_qos_formatp) {
			bcopy(mtod(inbound_m, caddr_t) +
				inbound_oidx->cni_qos_formatp - 2,
			      cp, (unsigned) (inbound_oidx->cni_qos_len + 2));
			cp += inbound_oidx->cni_qos_len + 2;
		}
		if (inbound_oidx->cni_priorp) {
			bcopy(mtod(inbound_m, caddr_t) +
				inbound_oidx->cni_priorp - 2, cp, 3);
			cp += 3;
		}
		if (inbound_oidx->cni_securep) {
			bcopy(mtod(inbound_m, caddr_t) +
				inbound_oidx->cni_securep - 2, cp,
			      (unsigned) (inbound_oidx->cni_secure_len + 2));
			cp += inbound_oidx->cni_secure_len + 2;
		}
		m->m_len += optlen;
		len += optlen;
	}
	pdu->esis_hdr_len = m0->m_pkthdr.len = len;
	iso_gen_csum(m0, ESIS_CKSUM_OFF, (int) pdu->esis_hdr_len);

	bzero((caddr_t) & siso, sizeof(siso));
	siso.siso_family = AF_ISO;
	siso.siso_data[0] = AFI_SNA;
	siso.siso_nlen = 6 + 1;	/* should be taken from snpa_hdr */
	/* +1 is for AFI */
	bcopy(inbound_shp->snh_shost, siso.siso_data + 1, 6);
	(ifp->if_output) (ifp, m0, sisotosa(&siso), 0);
}

/*
 * FUNCTION:		esis_insert_addr
 *
 * PURPOSE:		Insert an iso_addr into a buffer
 *
 * RETURNS:		true if buffer was big enough, else false
 *
 * SIDE EFFECTS:	Increment buf & len according to size of iso_addr
 *
 * NOTES:		Plus 1 here is for length byte
 */
int
esis_insert_addr(buf, len, isoa, m, nsellen)
	caddr_t *buf;	/* ptr to buffer to put address into */
	int            *len;	/* ptr to length of buffer so far */
	struct iso_addr *isoa;	/* ptr to address */
	struct mbuf *m;/* determine if there remains space */
	int             nsellen;
{
	int    newlen, result = 0;

	isoa->isoa_len -= nsellen;
	newlen = isoa->isoa_len + 1;
	if (newlen <= M_TRAILINGSPACE(m)) {
		bcopy((caddr_t) isoa, *buf, newlen);
		*len += newlen;
		*buf += newlen;
		m->m_len += newlen;
		result = 1;
	}
	isoa->isoa_len += nsellen;
	return (result);
}

#define ESIS_EXTRACT_ADDR(d, b) { d = (struct iso_addr *)(b); b += (1 + *b); \
	    if (b > buflim) {esis_stat.es_toosmall++; goto bad;}}
#define ESIS_NEXT_OPTION(b)	{ b += (2 + b[1]); \
	    if (b > buflim) {esis_stat.es_toosmall++; goto bad;}}
int             ESHonly = 0;

/*
 * FUNCTION:		esis_eshinput
 *
 * PURPOSE:		Process an incoming ESH pdu
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_eshinput(m, shp)
	struct mbuf    *m;	/* esh pdu */
	struct snpa_hdr *shp;	/* subnetwork header */
{
	struct esis_fixed *pdu = mtod(m, struct esis_fixed *);
	u_short         ht;	/* holding time */
	struct iso_addr *nsap = NULL;
	int             naddr;
	u_char         *buf = (u_char *) (pdu + 1);
	u_char         *buflim = pdu->esis_hdr_len + (u_char *) pdu;
	int             new_entry = 0;

	esis_stat.es_eshrcvd++;

	CTOH(pdu->esis_ht_msb, pdu->esis_ht_lsb, ht);

	naddr = *buf++;
	if (buf >= buflim)
		goto bad;
	if (naddr == 1) {
		ESIS_EXTRACT_ADDR(nsap, buf);
		new_entry = snpac_add(shp->snh_ifp,
				      nsap, shp->snh_shost, SNPA_ES, ht, 0);
	} else {
		int             nsellength = 0, nlen = 0;
		struct ifaddr *ifa;
		/*
		 * See if we want to compress out multiple nsaps
		 * differing only by nsel
		 */
		for (ifa = shp->snh_ifp->if_addrlist.tqh_first; ifa != 0;
		     ifa = ifa->ifa_list.tqe_next)
			if (ifa->ifa_addr->sa_family == AF_ISO) {
				nsellength =
				((struct iso_ifaddr *) ifa)->ia_addr.siso_tlen;
				break;
			}
#ifdef ARGO_DEBUG
		if (argo_debug[D_ESISINPUT]) {
			printf(
			"esis_eshinput: esh: ht %d, naddr %d nsellength %d\n",
			       ht, naddr, nsellength);
		}
#endif
		while (naddr-- > 0) {
			struct iso_addr *nsap2;
			u_char         *buf2;
			ESIS_EXTRACT_ADDR(nsap, buf);
			/*
			 * see if there is at least one more nsap in ESH
			 * differing only by nsel
			 */
			if (nsellength != 0)
				for (buf2 = buf; buf2 < buflim;) {
					ESIS_EXTRACT_ADDR(nsap2, buf2);
#ifdef ARGO_DEBUG
					if (argo_debug[D_ESISINPUT]) {
						printf(
						"esis_eshinput: comparing %s ",
						       clnp_iso_addrp(nsap));
						printf("and %s\n",
						       clnp_iso_addrp(nsap2));
					}
#endif
					if (Bcmp(nsap->isoa_genaddr,
						 nsap2->isoa_genaddr,
						 nsap->isoa_len - nsellength)
					     == 0) {
						nlen = nsellength;
						break;
					}
				}
			new_entry |= snpac_add(shp->snh_ifp,
				   nsap, shp->snh_shost, SNPA_ES, ht, nlen);
			nlen = 0;
		}
	}
#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISINPUT]) {
		printf("esis_eshinput: nsap %s is %s\n",
		       clnp_iso_addrp(nsap), new_entry ? "new" : "old");
	}
#endif
	if (new_entry && (iso_systype & SNPA_IS))
		esis_shoutput(shp->snh_ifp, ESIS_ISH, esis_holding_time,
			      shp->snh_shost, 6, (struct iso_addr *) 0);
bad:
	return;
}

/*
 * FUNCTION:		esis_ishinput
 *
 * PURPOSE:		process an incoming ISH pdu
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_ishinput(m, shp)
	struct mbuf    *m;	/* esh pdu */
	struct snpa_hdr *shp;	/* subnetwork header */
{
	struct esis_fixed *pdu = mtod(m, struct esis_fixed *);
	u_short         ht, newct;	/* holding time */
	struct iso_addr *nsap;	/* Network Entity Title */
	u_char *buf = (u_char *) (pdu + 1);
	u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;
	int             new_entry;

	esis_stat.es_ishrcvd++;
	CTOH(pdu->esis_ht_msb, pdu->esis_ht_lsb, ht);

#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISINPUT]) {
		printf("esis_ishinput: ish: ht %d\n", ht);
	}
#endif
	if (ESHonly)
		goto bad;

	ESIS_EXTRACT_ADDR(nsap, buf);

	while (buf < buflim) {
		switch (*buf) {
		case ESISOVAL_ESCT:
			if (iso_systype & SNPA_IS)
				break;
			if (buf[1] != 2)
				goto bad;
			CTOH(buf[2], buf[3], newct);
			if ((u_short) esis_config_time != newct) {
				timeout_del(&esis_timeout);
				esis_config_time = newct;
				esis_config(NULL);
			}
			break;

		default:
			printf("Unknown ISH option: %x\n", *buf);
		}
		ESIS_NEXT_OPTION(buf);
	}
	new_entry = snpac_add(shp->snh_ifp, nsap, shp->snh_shost, SNPA_IS,
			      ht, 0);
#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISINPUT]) {
		printf("esis_ishinput: nsap %s is %s\n",
		       clnp_iso_addrp(nsap), new_entry ? "new" : "old");
	}
#endif

	if (new_entry)
		esis_shoutput(shp->snh_ifp,
			      iso_systype & SNPA_ES ? ESIS_ESH : ESIS_ISH,
		esis_holding_time, shp->snh_shost, 6, (struct iso_addr *) 0);
bad:
	return;
}

/*
 * FUNCTION:		esis_rdinput
 *
 * PURPOSE:		Process an incoming RD pdu
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_rdinput(m0, shp)
	struct mbuf    *m0;	/* esh pdu */
	struct snpa_hdr *shp;	/* subnetwork header */
{
	struct esis_fixed *pdu = mtod(m0, struct esis_fixed *);
	u_short         ht;	/* holding time */
	struct iso_addr *da, *net = 0, *netmask = 0, *snpamask = 0;
	struct iso_addr *bsnpa;
	u_char *buf = (u_char *) (pdu + 1);
	u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;

	esis_stat.es_rdrcvd++;

	/* intermediate systems ignore redirects */
	if (iso_systype & SNPA_IS)
		return;
	if (ESHonly)
		return;

	CTOH(pdu->esis_ht_msb, pdu->esis_ht_lsb, ht);
	if (buf >= buflim)
		return;

	/* Extract DA */
	ESIS_EXTRACT_ADDR(da, buf);

	/* Extract better snpa */
	ESIS_EXTRACT_ADDR(bsnpa, buf);

	/* Extract NET if present */
	if (buf < buflim) {
		if (*buf == 0)
			buf++;	/* no NET present, skip NETL anyway */
		else
			ESIS_EXTRACT_ADDR(net, buf);
	}
	/* process options */
	while (buf < buflim) {
		switch (*buf) {
		case ESISOVAL_SNPAMASK:
			if (snpamask)	/* duplicate */
				return;
			snpamask = (struct iso_addr *) (buf + 1);
			break;

		case ESISOVAL_NETMASK:
			if (netmask)	/* duplicate */
				return;
			netmask = (struct iso_addr *) (buf + 1);
			break;

		default:
			printf("Unknown option in ESIS RD (0x%x)\n", buf[-1]);
		}
		ESIS_NEXT_OPTION(buf);
	}

#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISINPUT]) {
		printf("esis_rdinput: rd: ht %d, da %s\n", ht,
		       clnp_iso_addrp(da));
		if (net)
			printf("\t: net %s\n", clnp_iso_addrp(net));
	}
#endif
	/*
	 * If netl is zero, then redirect is to an ES. We need to add an entry
	 * to the snpa cache for (destination, better snpa).
	 * If netl is not zero, then the redirect is to an IS. In this
	 * case, add an snpa cache entry for (net, better snpa).
	 *
	 * If the redirect is to an IS, add a route entry towards that
	 * IS.
	 */
	if (net == 0 || net->isoa_len == 0 || snpamask) {
		/* redirect to an ES */
		snpac_add(shp->snh_ifp, da,
			  bsnpa->isoa_genaddr, SNPA_ES, ht, 0);
	} else {
		snpac_add(shp->snh_ifp, net,
			  bsnpa->isoa_genaddr, SNPA_IS, ht, 0);
		snpac_addrt(shp->snh_ifp, da, net, netmask);
	}
bad:	;	/* Needed by ESIS_NEXT_OPTION */
}

/*
 * FUNCTION:		esis_config
 *
 * PURPOSE:		Report configuration
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Called every esis_config_time seconds
 */
/*ARGSUSED*/
void
esis_config(v)
	void *v;
{
	struct ifnet *ifp;

	timeout_add(&esis_timeout, hz * esis_config_time);

	/*
	 * Report configuration for each interface that - is UP - has
	 * BROADCAST capability - has an ISO address
	 */
	/*
	 * Todo: a better way would be to construct the esh or ish once and
	 * copy it out for all devices, possibly calling a method in the
	 * iso_ifaddr structure to encapsulate and transmit it.  This could
	 * work to advantage for non-broadcast media
	 */

	for (ifp = ifnet.tqh_first; ifp != 0; ifp = ifp->if_list.tqe_next) {
		if ((ifp->if_flags & IFF_UP) &&
		    (ifp->if_flags & IFF_BROADCAST)) {
			/* search for an ISO address family */
			struct ifaddr  *ifa;

			for (ifa = ifp->if_addrlist.tqh_first; ifa != 0;
			     ifa = ifa->ifa_list.tqe_next) {
				if (ifa->ifa_addr->sa_family == AF_ISO) {
					esis_shoutput(ifp,
			      iso_systype & SNPA_ES ? ESIS_ESH : ESIS_ISH,
			      esis_holding_time,
			      (caddr_t) (iso_systype & SNPA_ES ? all_is_snpa :
				     all_es_snpa), 6, (struct iso_addr *) 0);
					break;
				}
			}
		}
	}
}

/*
 * FUNCTION:		esis_shoutput
 *
 * PURPOSE:		Transmit an esh or ish pdu
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
esis_shoutput(ifp, type, ht, sn_addr, sn_len, isoa)
	struct ifnet   *ifp;
	int             type;
	short           ht;
	caddr_t         sn_addr;
	int             sn_len;
	struct iso_addr *isoa;
{
	struct mbuf    *m, *m0;
	caddr_t         cp, naddrp;
	int             naddr = 0;
	struct esis_fixed *pdu;
	struct iso_ifaddr *ia;
	int             len;
	struct sockaddr_iso siso;

	if (type == ESIS_ESH)
		esis_stat.es_eshsent++;
	else if (type == ESIS_ISH)
		esis_stat.es_ishsent++;
	else {
		printf("esis_shoutput: bad pdu type\n");
		return;
	}

#ifdef ARGO_DEBUG
	if (argo_debug[D_ESISOUTPUT]) {
		int             i;
		printf("esis_shoutput: ifp %p (%s), %s, ht %d, to: [%d] ",
		       ifp, ifp->if_xname,
		       type == ESIS_ESH ? "esh" : "ish",
		       ht, sn_len);
		for (i = 0; i < sn_len; i++)
			printf("%x%c", *(sn_addr + i),
			       i < (sn_len - 1) ? ':' : ' ');
		printf("\n");
	}
#endif

	if ((m0 = m = m_gethdr(M_DONTWAIT, MT_HEADER)) == NULL) {
		esis_stat.es_nomem++;
		return;
	}
	bzero(mtod(m, caddr_t), MHLEN);

	pdu = mtod(m, struct esis_fixed *);
	naddrp = cp = (caddr_t) (pdu + 1);
	len = sizeof(struct esis_fixed);

	/*
	 *	Build fixed part of header
	 */
	pdu->esis_proto_id = ISO9542_ESIS;
	pdu->esis_vers = ESIS_VERSION;
	pdu->esis_type = type;
	HTOC(pdu->esis_ht_msb, pdu->esis_ht_lsb, ht);

	if (type == ESIS_ESH) {
		cp++;
		len++;
	}
	m->m_len = len;
	if (isoa) {
		/*
		 * Here we are responding to a clnp packet sent to an NSAP
		 * that is ours which was sent to the MAC addr all_es's.
		 * It is possible that we did not specifically advertise this
		 * NSAP, even though it is ours, so we will respond
		 * directly to the sender that we are here.  If we do have
		 * multiple NSEL's we'll tack them on so he can compress
		 * them out.
		 */
		(void) esis_insert_addr(&cp, &len, isoa, m, 0);
		naddr = 1;
	}
	for (ia = iso_ifaddr.tqh_first; ia != 0; ia = ia->ia_list.tqe_next) {
		int nsellen = (type == ESIS_ISH ? ia->ia_addr.siso_tlen : 0);
		int n = ia->ia_addr.siso_nlen;
		struct iso_ifaddr *ia2;

		if (type == ESIS_ISH && naddr > 0)
			break;
		for (ia2 = iso_ifaddr.tqh_first; ia2 != ia;
		     ia2 = ia2->ia_list.tqe_next)
			if (Bcmp(ia->ia_addr.siso_data,
				 ia2->ia_addr.siso_data, n) == 0)
				break;
		if (ia2 != ia)
			continue;	/* Means we have previously copied
					 * this nsap */
		if (isoa && Bcmp(ia->ia_addr.siso_data,
				 isoa->isoa_genaddr, n) == 0) {
			isoa = 0;
			continue;	/* Ditto */
		}
#ifdef ARGO_DEBUG
		if (argo_debug[D_ESISOUTPUT]) {
			printf("esis_shoutput: adding NSAP %s\n",
			       clnp_iso_addrp(&ia->ia_addr.siso_addr));
		}
#endif
		if (!esis_insert_addr(&cp, &len,
				      &ia->ia_addr.siso_addr, m, nsellen)) {
			EXTEND_PACKET(m, m0, cp);
			(void) esis_insert_addr(&cp, &len,
						&ia->ia_addr.siso_addr, m,
						nsellen);
		}
		naddr++;
	}

	if (type == ESIS_ESH)
		*naddrp = naddr;
	else {
		/* add suggested es config timer option to ISH */
		if (M_TRAILINGSPACE(m) < 4) {
			printf("esis_shoutput: extending packet\n");
			EXTEND_PACKET(m, m0, cp);
		}
		*cp++ = ESISOVAL_ESCT;
		*cp++ = 2;
		HTOC(*cp, *(cp + 1), esis_esconfig_time);
		len += 4;
		m->m_len += 4;
#ifdef ARGO_DEBUG
		if (argo_debug[D_ESISOUTPUT]) {
			printf("m0 %p, m %p, data %p, len %d, cp %p\n",
			       m0, m, m->m_data, m->m_len, cp);
		}
#endif
	}

	m0->m_pkthdr.len = len;
	pdu->esis_hdr_len = len;
	iso_gen_csum(m0, ESIS_CKSUM_OFF, (int) pdu->esis_hdr_len);

	bzero((caddr_t) & siso, sizeof(siso));
	siso.siso_family = AF_ISO;
	siso.siso_data[0] = AFI_SNA;
	siso.siso_nlen = sn_len + 1;
	bcopy(sn_addr, siso.siso_data + 1, (unsigned) sn_len);
	(ifp->if_output) (ifp, m0, sisotosa(&siso), 0);
}

/*
 * FUNCTION:		isis_input
 *
 * PURPOSE:		Process an incoming isis packet
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
isis_input(struct mbuf *m0, ...)
{
	struct snpa_hdr *shp;	/* subnetwork header */
	struct rawcb *rp, *first_rp = 0;
	struct ifnet   *ifp;
	struct mbuf    *mm;
	va_list ap;

	va_start(ap, m0);
	shp = va_arg(ap, struct snpa_hdr *);
	va_end(ap);
	ifp = shp->snh_ifp;

#ifdef ARGO_DEBUG
	if (argo_debug[D_ISISINPUT]) {
		int             i;

		printf("isis_input: pkt on ifp %p (%s): from:",
		       ifp, ifp->if_xname);
		for (i = 0; i < 6; i++)
			printf("%x%c", shp->snh_shost[i] & 0xff,
			       (i < 5) ? ':' : ' ');
		printf(" to:");
		for (i = 0; i < 6; i++)
			printf("%x%c", shp->snh_dhost[i] & 0xff, 
			       (i < 5) ? ':' : ' ');
		printf("\n");
	}
#endif
	esis_dl.sdl_alen = ifp->if_addrlen;
	esis_dl.sdl_index = ifp->if_index;
	bcopy(shp->snh_shost, (caddr_t) esis_dl.sdl_data, esis_dl.sdl_alen);
	for (rp = esis_pcb.lh_first; rp != 0; rp = rp->rcb_list.le_next) {
		if (first_rp == 0) {
			first_rp = rp;
			continue;
		}
		/* can't block at interrupt level */
		if ((mm = m_copy(m0, 0, M_COPYALL)) != NULL) {
			if (sbappendaddr(&rp->rcb_socket->so_rcv,
					 (struct sockaddr *) & esis_dl, mm,
					 (struct mbuf *) 0) != 0) {
				sorwakeup(rp->rcb_socket);
			} else {
#ifdef ARGO_DEBUG
				if (argo_debug[D_ISISINPUT]) {
					printf(
				    "Error in sbappenaddr, mm = %p\n", mm);
				}
#endif
				m_freem(mm);
			}
		}
	}
	if (first_rp && sbappendaddr(&first_rp->rcb_socket->so_rcv,
	       (struct sockaddr *) & esis_dl, m0, (struct mbuf *) 0) != 0) {
		sorwakeup(first_rp->rcb_socket);
		return;
	}
	m_freem(m0);
}

int
isis_output(struct mbuf *m, ...)
{
	struct sockaddr_dl *sdl;
	struct ifnet *ifp;
	struct ifaddr  *ifa;
	struct sockaddr_iso siso;
	int             error = 0;
	unsigned        sn_len;
	va_list ap;

	va_start(ap, m);
	sdl = va_arg(ap, struct sockaddr_dl *);
	va_end(ap);

	ifa = ifa_ifwithnet((struct sockaddr *) sdl);	/* get ifp from sdl */
	if (ifa == 0) {
#ifdef ARGO_DEBUG
		if (argo_debug[D_ISISOUTPUT]) {
			printf("isis_output: interface not found\n");
		}
#endif
		error = EINVAL;
		goto release;
	}
	ifp = ifa->ifa_ifp;
	sn_len = sdl->sdl_alen;
#ifdef ARGO_DEBUG
	if (argo_debug[D_ISISOUTPUT]) {
		u_char *cp = (u_char *) LLADDR(sdl), *cplim = cp + sn_len;
		printf("isis_output: ifp %p (%s), to: ",
		       ifp, ifp->if_xname);
		while (cp < cplim) {
			printf("%x", *cp++);
			printf("%c", (cp < cplim) ? ':' : ' ');
		}
		printf("\n");
	}
#endif
	bzero((caddr_t) & siso, sizeof(siso));
	siso.siso_family = AF_ISO;	/* This convention may be useful for
					 * X.25 */
	siso.siso_data[0] = AFI_SNA;
	siso.siso_nlen = sn_len + 1;
	bcopy(LLADDR(sdl), siso.siso_data + 1, sn_len);
	error = (ifp->if_output) (ifp, m, sisotosa(&siso), 0);
	if (error) {
#ifdef ARGO_DEBUG
		if (argo_debug[D_ISISOUTPUT]) {
			printf("isis_output: error from ether_output is %d\n",
			       error);
		}
#endif
	}
	return (error);

release:
	if (m != NULL)
		m_freem(m);
	return (error);
}


/*
 * FUNCTION:		esis_ctlinput
 *
 * PURPOSE:		Handle the PRC_IFDOWN transition
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Calls snpac_flush for interface specified.
 *			The loop through iso_ifaddr is stupid because
 *			back in if_down, we knew the ifp...
 */
void *
esis_ctlinput(req, siso, dummy)
	int             req;	/* request: we handle only PRC_IFDOWN */
	struct sockaddr *siso;	/* address of ifp */
	void *dummy;
{
	struct iso_ifaddr *ia;	/* scan through interface addresses */

	if (req == PRC_IFDOWN)
		for (ia = iso_ifaddr.tqh_first; ia != 0;
		     ia = ia->ia_list.tqe_next) {
			if (iso_addrmatch(IA_SIS(ia),
					  (struct sockaddr_iso *) siso))
				snpac_flushifp(ia->ia_ifp);
		}
	return NULL;
}

#endif /* ISO */
@


1.10
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.9 2003/12/10 07:22:43 itojun Exp $	*/
@


1.9
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.8 2003/06/02 23:28:17 millert Exp $	*/
d90 1
a90 1
#include <machine/stdarg.h>
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.7 2002/03/15 18:19:53 millert Exp $	*/
d247 2
a248 2
	register struct esis_fixed *pdu = mtod(m0, struct esis_fixed *);
	register int    type;
d476 1
a476 1
	register caddr_t *buf;	/* ptr to buffer to put address into */
d478 2
a479 2
	register struct iso_addr *isoa;	/* ptr to address */
	register struct mbuf *m;/* determine if there remains space */
d482 1
a482 1
	register int    newlen, result = 0;
d624 2
a625 2
	register u_char *buf = (u_char *) (pdu + 1);
	register u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;
d697 3
a699 3
	register struct iso_addr *bsnpa;
	register u_char *buf = (u_char *) (pdu + 1);
	register u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;
d792 1
a792 1
	register struct ifnet *ifp;
d918 1
a918 1
		register struct iso_ifaddr *ia2;
d999 1
a999 1
	register struct rawcb *rp, *first_rp = 0;
d1061 2
a1062 2
	register struct sockaddr_dl *sdl;
	register struct ifnet *ifp;
d1140 1
a1140 1
	register struct iso_ifaddr *ia;	/* scan through interface addresses */
@


1.7
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.6 2001/08/19 15:07:34 miod Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.5 2001/05/16 12:54:06 ho Exp $	*/
a247 1
#if __STDC__
a248 5
#else
esis_input(m0, va_alist)
	struct mbuf    *m0;
	va_dcl
#endif
a999 1
#if __STDC__
a1000 5
#else
isis_input(m0, va_alist)
	struct mbuf    *m0;
	va_dcl
#endif
a1062 1
#if __STDC__
a1063 5
#else
isis_output(m, va_alist)
	struct mbuf    *m;
	va_dcl
#endif
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.6 2001/08/19 15:07:34 miod Exp $	*/
d248 1
d250 5
d1006 1
d1008 5
d1075 1
d1077 5
@


1.5
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.4 1996/05/10 12:31:21 deraadt Exp $	*/
d77 1
d113 3
d144 4
a147 2
	timeout(snpac_age, (caddr_t) 0, hz);
	timeout(esis_config, (caddr_t) 0, hz);
d660 1
a660 1
				untimeout(esis_config, 0);
d804 1
a804 1
	timeout(esis_config, (caddr_t) 0, hz * esis_config_time);
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.2 1996/03/04 10:35:15 mickey Exp $	*/
d187 5
a191 7
		if ((so->so_pcb = rp) != NULL) {
			bzero(so->so_pcb, sizeof(*rp));
			LIST_INSERT_HEAD(&esis_pcb, rp, rcb_list);
			rp->rcb_socket = so;
			error = soreserve(so, esis_sendspace, esis_recvspace);
		} else
			error = ENOBUFS;
@


1.4.16.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.4 1996/05/10 12:31:21 deraadt Exp $	*/
d187 7
a193 5
		so->so_pcb = rp;
		bzero(so->so_pcb, sizeof(*rp));
		LIST_INSERT_HEAD(&esis_pcb, rp, rcb_list);
		rp->rcb_socket = so;
		error = soreserve(so, esis_sendspace, esis_recvspace);
@


1.4.16.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.4.16.1 2001/07/04 10:55:33 niklas Exp $	*/
a76 1
#include <sys/timeout.h>
a111 3
struct timeout	snpac_timeout;
struct timeout	esis_timeout;

d140 2
a141 4
	timeout_set(&snpac_timeout, snpac_age, NULL);
	timeout_set(&esis_timeout, esis_config, NULL);
	timeout_add(&snpac_timeout, hz);
	timeout_add(&esis_timeout, hz);
d654 1
a654 1
				timeout_del(&esis_timeout);
d798 1
a798 1
	timeout_add(&esis_timeout, hz * esis_config_time);
@


1.4.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 1
d250 5
d1006 1
d1008 5
d1075 1
d1077 5
@


1.4.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: esis.c,v 1.4.16.3 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.16.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#include <sys/stdarg.h>
d247 2
a248 2
	struct esis_fixed *pdu = mtod(m0, struct esis_fixed *);
	int    type;
d476 1
a476 1
	caddr_t *buf;	/* ptr to buffer to put address into */
d478 2
a479 2
	struct iso_addr *isoa;	/* ptr to address */
	struct mbuf *m;/* determine if there remains space */
d482 1
a482 1
	int    newlen, result = 0;
d624 2
a625 2
	u_char *buf = (u_char *) (pdu + 1);
	u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;
d697 3
a699 3
	struct iso_addr *bsnpa;
	u_char *buf = (u_char *) (pdu + 1);
	u_char *buflim = pdu->esis_hdr_len + (u_char *) pdu;
d792 1
a792 1
	struct ifnet *ifp;
d918 1
a918 1
		struct iso_ifaddr *ia2;
d999 1
a999 1
	struct rawcb *rp, *first_rp = 0;
d1061 2
a1062 2
	struct sockaddr_dl *sdl;
	struct ifnet *ifp;
d1140 1
a1140 1
	struct iso_ifaddr *ia;	/* scan through interface addresses */
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: esis.c,v 1.13 1996/04/13 01:34:39 cgd Exp $	*/
d349 2
a350 2
		"esis_rdoutput: ifp %p (%s%d), ht %d, m %p, oidx %p\n",
		       ifp, ifp->if_name, ifp->if_unit, esis_holding_time,
d874 2
a875 2
		printf("esis_shoutput: ifp %p (%s%d), %s, ht %d, to: [%d] ",
		       ifp, ifp->if_name, ifp->if_unit,
d1025 2
a1026 2
		printf("isis_input: pkt on ifp %p (%s%d): from:",
		       ifp, ifp->if_name, ifp->if_unit);
d1106 2
a1107 2
		printf("isis_output: ifp %p (%s%d), to: ",
		       ifp, ifp->if_name, ifp->if_unit);
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: esis.c,v 1.12 1996/02/13 22:09:23 christos Exp $	*/
d349 3
a351 4
		"esis_rdoutput: ifp x%x (%s%d), ht %d, m x%x, oidx x%x\n",
		       (unsigned int) ifp, ifp->if_name, ifp->if_unit,
		       esis_holding_time,
		       (unsigned int) inbound_m, (unsigned int) inbound_oidx);
d874 2
a875 2
		printf("esis_shoutput: ifp x%x (%s%d), %s, ht %d, to: [%d] ",
		       (unsigned int) ifp, ifp->if_name, ifp->if_unit,
d972 2
a973 4
			printf("m0 0x%x, m 0x%x, data 0x%x, len %d, cp 0x%x\n",
			       (unsigned int) m0, (unsigned int) m,
			       (unsigned int) m->m_data, m->m_len,
			       (unsigned int) cp);
d1025 2
a1026 3
		printf("isis_input: pkt on ifp x%x (%s%d): from:",
		       (unsigned int) ifp,
		       ifp->if_name, ifp->if_unit);
d1055 1
a1055 2
				    "Error in sbappenaddr, mm = 0x%x\n",
				    (unsigned int) mm);
d1106 2
a1107 2
		printf("isis_output: ifp 0x%x (%s%d), to: ",
		       (unsigned int) ifp, ifp->if_name, ifp->if_unit);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: esis.c,v 1.11 1995/08/17 02:57:31 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d93 1
d99 1
a99 2
 *	esis_esconfig_time - suggested es configuration time placed in the
 *						ish.
d103 8
a110 9
void				esis_config(), snpac_age();
int				esis_sendspace = 2048;
int				esis_recvspace = 2048;
short			esis_holding_time = ESIS_HT;
short			esis_config_time = ESIS_CONFIG;
short			esis_esconfig_time = ESIS_CONFIG;
extern int		iso_systype;
struct sockaddr_dl	esis_dl = { sizeof(esis_dl), AF_LINK };
extern char		all_es_snpa[], all_is_snpa[];
a121 5
void	esis_input(), isis_input();
#ifdef	ISO_X25ESIS
void	x25esis_input();
#endif	/* ISO_X25ESIS */

d125 1
a125 1
 * PURPOSE:			Initialize the kernel portion of esis protocol
d127 1
a127 1
 * RETURNS:			nothing
d129 1
a129 1
 * SIDE EFFECTS:	
d131 1
a131 1
 * NOTES:			
d140 2
a141 2
	timeout(snpac_age, (caddr_t)0, hz);
	timeout(esis_config, (caddr_t)0, hz);
d147 1
a147 1
#endif	/* ISO_X25ESIS */
d153 1
a153 1
 * PURPOSE:			Handle user level esis requests
d155 1
a155 1
 * RETURNS:			0 or appropriate errno
d157 1
a157 1
 * SIDE EFFECTS:	
d160 2
a161 1
/*ARGSUSED*/
d163 5
a167 5
struct socket	*so;		/* socket: used only to get to this code */
int				req;		/* request */
struct mbuf		*m;			/* data for request */
struct mbuf		*nam;		/* optional name */
struct mbuf		*control;	/* optional control */
d169 2
a170 2
	struct rawcb *rp = sotorawcb(so);
	int error = 0;
a179 1

d187 2
a188 2
		if (so->so_pcb = rp) {
			bzero((caddr_t)so->so_pcb, sizeof(*rp));
d202 1
a202 1
		error = isis_output(mtod(nam,struct sockaddr_dl *), m);
d235 1
a235 1
 * PURPOSE:			Process an incoming esis packet
d237 1
a237 1
 * RETURNS:			nothing
d239 1
a239 1
 * SIDE EFFECTS:	
d241 1
a241 1
 * NOTES:			
d244 7
a250 3
esis_input(m0, shp)
struct mbuf		*m0;		/* ptr to first mbuf of pkt */
struct snpa_hdr	*shp;	/* subnetwork header */
d252 8
a259 2
	register struct esis_fixed	*pdu = mtod(m0, struct esis_fixed *);
	register int type;
d264 2
a265 1
	if (ESIS_CKSUM_REQUIRED(pdu) && iso_check_csum(m0, (int)pdu->esis_hdr_len)) {
a268 1

d276 3
a278 3
		case ESIS_ESH:
			esis_eshinput(m0, shp);
			break;
d280 3
a282 3
		case ESIS_ISH:
			esis_ishinput(m0, shp);
			break;
d284 3
a286 3
		case ESIS_RD:
			esis_rdinput(m0, shp);
			break;
d288 2
a289 2
		default:
			esis_stat.es_badtype++;
d302 1
a302 1
 * PURPOSE:			Transmit a redirect pdu
d304 1
a304 1
 * RETURNS:			nothing
d306 1
a306 1
 * SIDE EFFECTS:	
d308 2
a309 2
 * NOTES:			Assumes there is enough space for fixed part of header,
 *					DA, BSNPA and NET in first mbuf.
d311 1
d313 6
a318 6
struct snpa_hdr		*inbound_shp;	/* snpa hdr from incoming packet */
struct mbuf			*inbound_m;		/* incoming pkt itself */
struct clnp_optidx	*inbound_oidx;	/* clnp options assoc with incoming pkt */
struct iso_addr		*rd_dstnsap;	/* ultimate destination of pkt */
struct rtentry		*rt;			/* snpa cache info regarding next hop of
										pkt */
d320 6
a325 6
	struct mbuf			*m, *m0;
	caddr_t				cp;
	struct esis_fixed	*pdu;
	int					len, total_len = 0;
	struct sockaddr_iso	siso;
	struct ifnet 		*ifp = inbound_shp->snh_ifp;
d334 8
a341 6
	if (rt == 0 || (sdl = (struct sockaddr_dl *)rt->rt_gateway) == 0 ||
		sdl->sdl_family != AF_LINK) {
		/* maybe we should have a function that you
		   could put in the iso_ifaddr structure
		   which could translate iso_addrs into snpa's
		   where there is a known mapping for that address type */
d346 7
a352 4
	IFDEBUG(D_ESISOUTPUT)
		printf("esis_rdoutput: ifp x%x (%s%d), ht %d, m x%x, oidx x%x\n",
			ifp, ifp->if_name, ifp->if_unit, esis_holding_time, inbound_m,
			inbound_oidx);
d355 2
a356 1
	ENDDEBUG
d365 2
a366 1
	cp = (caddr_t)(pdu + 1); /*pointer arith.; 1st byte after header */
d386 3
a388 4
	/* 
	 *	If the next hop is not the destination, then it ought to be
	 *	an IS and it should be inserted next. Else, set the
	 *	NETL to 0
d392 2
a393 1
		/* this should not happen: 
d395 2
a396 1
			printf("esis_rdoutput: next hop is not dst and not an IS\n");
d399 2
a400 1
		} */
d409 4
a412 4
	 *	PHASE2
	 *	If redirect is to an IS, add an address mask. The mask to be
	 *	used should be the mask present in the routing entry used to
	 *	forward the original data packet.
d414 1
a414 1
	
d416 1
a416 1
	 *	Copy Qos, priority, or security options present in original npdu
d420 1
a420 1
		int optlen = 0;
d423 2
a424 1
		if (inbound_oidx->cni_priorp)	/* priority option is 1 byte long */
d434 3
a436 3
		/* 
		 *	When copying options, copy from ptr - 2 in order to grab
		 *	the option code and length
d439 3
a441 2
			bcopy(mtod(inbound_m, caddr_t) + inbound_oidx->cni_qos_formatp - 2,
				cp, (unsigned)(inbound_oidx->cni_qos_len + 2));
d445 2
a446 2
			bcopy(mtod(inbound_m, caddr_t) + inbound_oidx->cni_priorp - 2,
					cp, 3);
d450 3
a452 2
			bcopy(mtod(inbound_m, caddr_t) + inbound_oidx->cni_securep - 2, cp, 
				(unsigned)(inbound_oidx->cni_secure_len + 2));
a457 1

d459 1
a459 1
	iso_gen_csum(m0, ESIS_CKSUM_OFF, (int)pdu->esis_hdr_len);
d461 1
a461 1
	bzero((caddr_t)&siso, sizeof(siso));
d465 1
a465 1
										/* +1 is for AFI */
d467 1
a467 1
	(ifp->if_output)(ifp, m0, sisotosa(&siso), 0);
d473 1
a473 1
 * PURPOSE:			Insert an iso_addr into a buffer
d475 1
a475 1
 * RETURNS:			true if buffer was big enough, else false
d479 1
a479 1
 * NOTES:			Plus 1 here is for length byte
d481 1
d483 5
a487 5
register caddr_t			*buf;		/* ptr to buffer to put address into */
int							*len;		/* ptr to length of buffer so far */
register struct iso_addr	*isoa;		/* ptr to address */
register struct mbuf		*m;			/* determine if there remains space */
int							nsellen;
d489 1
a489 1
	register int newlen, result = 0;
d493 2
a494 2
	if (newlen <=  M_TRAILINGSPACE(m)) {
		bcopy((caddr_t)isoa, *buf, newlen);
d508 2
a509 3
int ESHonly = 0;
/*
 
d513 1
a513 1
 * PURPOSE:			Process an incoming ESH pdu
d515 1
a515 1
 * RETURNS:			nothing
d517 1
a517 1
 * SIDE EFFECTS:	
d519 1
a519 1
 * NOTES:			
d521 1
d523 2
a524 2
struct mbuf		*m;	/* esh pdu */
struct snpa_hdr	*shp;	/* subnetwork header */
d526 7
a532 7
	struct	esis_fixed	*pdu = mtod(m, struct esis_fixed *);
	u_short				ht;		/* holding time */
	struct	iso_addr	*nsap;
	int					naddr;
	u_char				*buf = (u_char *)(pdu + 1);
	u_char				*buflim = pdu->esis_hdr_len + (u_char *)pdu;
	int					new_entry = 0;
d544 1
a544 1
								 nsap, shp->snh_shost, SNPA_ES, ht, 0);
d546 12
a557 10
		int nsellength = 0, nlen = 0;
		{
		/* See if we want to compress out multiple nsaps differing
		   only by nsel */
			register struct ifaddr *ifa;
			for (ifa = shp->snh_ifp->if_addrlist.tqh_first; ifa != 0;
			    ifa = ifa->ifa_list.tqe_next)
				if (ifa->ifa_addr->sa_family == AF_ISO) {
					nsellength = ((struct iso_ifaddr *)ifa)->ia_addr.siso_tlen;
					break;
d559 5
d565 1
a565 4
		IFDEBUG(D_ESISINPUT)
			printf("esis_eshinput: esh: ht %d, naddr %d nsellength %d\n",
					ht, naddr, nsellength);
		ENDDEBUG
d567 2
a568 1
			struct iso_addr *nsap2; u_char *buf2;
d570 23
a592 13
			/* see if there is at least one more nsap in ESH differing
			   only by nsel */
			if (nsellength != 0) for (buf2 = buf; buf2 < buflim;) {
				ESIS_EXTRACT_ADDR(nsap2, buf2);
				IFDEBUG(D_ESISINPUT)
					printf("esis_eshinput: comparing %s ", 
						clnp_iso_addrp(nsap));
					printf("and %s\n", clnp_iso_addrp(nsap2));
				ENDDEBUG
				if (Bcmp(nsap->isoa_genaddr, nsap2->isoa_genaddr,
						 nsap->isoa_len - nsellength) == 0) {
					nlen = nsellength;
					break;
a593 1
			}
d595 1
a595 1
									nsap, shp->snh_shost, SNPA_ES, ht, nlen);
d599 6
a604 4
	IFDEBUG(D_ESISINPUT)
		printf("esis_eshinput: nsap %s is %s\n", 
			clnp_iso_addrp(nsap), new_entry ? "new" : "old");
	ENDDEBUG
d607 1
a607 1
						shp->snh_shost, 6, (struct iso_addr *)0);
d615 1
a615 1
 * PURPOSE:			process an incoming ISH pdu
d617 1
a617 1
 * RETURNS:			
d619 1
a619 1
 * SIDE EFFECTS:	
d621 1
a621 1
 * NOTES:			
d623 1
d625 2
a626 2
struct mbuf		*m;	/* esh pdu */
struct snpa_hdr	*shp;	/* subnetwork header */
d628 6
a633 6
	struct esis_fixed	*pdu = mtod(m, struct esis_fixed *);
	u_short				ht, newct;			/* holding time */
	struct iso_addr		*nsap; 				/* Network Entity Title */
	register u_char		*buf = (u_char *) (pdu + 1);
	register u_char		*buflim = pdu->esis_hdr_len + (u_char *)pdu;
	int					new_entry;
d638 2
a639 1
	IFDEBUG(D_ESISINPUT)
d641 2
a642 1
	ENDDEBUG
d656 2
a657 2
			if (esis_config_time != newct) {
				untimeout(esis_config,0);
d659 1
a659 1
				esis_config();
d662 1
a662 1
		
d668 8
a675 5
	new_entry = snpac_add(shp->snh_ifp, nsap, shp->snh_shost, SNPA_IS, ht, 0);
	IFDEBUG(D_ESISINPUT)
		printf("esis_ishinput: nsap %s is %s\n", 
			clnp_iso_addrp(nsap), new_entry ? "new" : "old");
	ENDDEBUG
d678 3
a680 3
		esis_shoutput(shp->snh_ifp, 
			iso_systype & SNPA_ES ? ESIS_ESH : ESIS_ISH,
			esis_holding_time, shp->snh_shost, 6, (struct iso_addr *)0);
d688 1
a688 1
 * PURPOSE:			Process an incoming RD pdu
d690 1
a690 1
 * RETURNS:			
d692 1
a692 1
 * SIDE EFFECTS:	
d694 1
a694 1
 * NOTES:			
d696 1
d698 2
a699 2
struct mbuf		*m0;	/* esh pdu */
struct snpa_hdr	*shp;	/* subnetwork header */
d701 3
a703 3
	struct esis_fixed	*pdu = mtod(m0, struct esis_fixed *);
	u_short				ht;		/* holding time */
	struct iso_addr		*da, *net = 0, *netmask = 0, *snpamask = 0;
d705 2
a706 2
	register u_char		*buf = (u_char *)(pdu + 1);
	register u_char		*buflim = pdu->esis_hdr_len + (u_char *)pdu;
d729 1
a729 1
			buf++; /* no NET present, skip NETL anyway */
a732 1

d737 1
a737 1
			if (snpamask) /* duplicate */
d739 1
a739 1
			snpamask = (struct iso_addr *)(buf + 1);
d743 1
a743 1
			if (netmask) /* duplicate */
d745 1
a745 1
			netmask = (struct iso_addr *)(buf + 1);
d754 4
a757 2
	IFDEBUG(D_ESISINPUT)
		printf("esis_rdinput: rd: ht %d, da %s\n", ht, clnp_iso_addrp(da));
d760 2
a761 1
	ENDDEBUG
d763 4
a766 4
	 *	If netl is zero, then redirect is to an ES. We need to add an entry
	 *	to the snpa cache for (destination, better snpa).
	 *	If netl is not zero, then the redirect is to an IS. In this
	 *	case, add an snpa cache entry for (net, better snpa).
d768 2
a769 2
	 *	If the redirect is to an IS, add a route entry towards that
	 *	IS.
d774 1
a774 1
				bsnpa->isoa_genaddr, SNPA_ES, ht, 0);
d777 1
a777 1
				bsnpa->isoa_genaddr, SNPA_IS, ht, 0);
d780 1
a780 1
bad: ;    /* Needed by ESIS_NEXT_OPTION */
d786 1
a786 1
 * PURPOSE:			Report configuration
d788 1
a788 1
 * RETURNS:			
d790 1
a790 1
 * SIDE EFFECTS:	
d792 1
a792 1
 * NOTES:			Called every esis_config_time seconds
d794 1
d796 2
a797 1
esis_config()
d799 1
a799 1
	register struct ifnet	*ifp;
d801 1
a801 1
	timeout(esis_config, (caddr_t)0, hz * esis_config_time);
d803 3
a805 5
	/* 
	 *	Report configuration for each interface that 
	 *	- is UP
	 *	- has BROADCAST capability
	 *	- has an ISO address
d807 5
a811 4
	/* Todo: a better way would be to construct the esh or ish
	 * once and copy it out for all devices, possibly calling
	 * a method in the iso_ifaddr structure to encapsulate and
	 * transmit it.  This could work to advantage for non-broadcast media
d813 1
a813 1
	
d818 1
a818 1
			struct ifaddr *ifa;
d821 1
a821 1
			    ifa = ifa->ifa_list.tqe_next) {
d823 5
a827 5
					esis_shoutput(ifp, 
						iso_systype & SNPA_ES ? ESIS_ESH : ESIS_ISH,
						esis_holding_time,
						(caddr_t)(iso_systype & SNPA_ES ? all_is_snpa : 
						all_es_snpa), 6, (struct iso_addr *)0);
d838 1
a838 1
 * PURPOSE:			Transmit an esh or ish pdu
d840 1
a840 1
 * RETURNS:			nothing
d842 1
a842 1
 * SIDE EFFECTS:	
d844 1
a844 1
 * NOTES:			
d846 1
d848 6
a853 6
struct ifnet	*ifp;
int				type;
short			ht;
caddr_t 		sn_addr;
int				sn_len;
struct	iso_addr *isoa;
d855 7
a861 7
	struct mbuf			*m, *m0;
	caddr_t				cp, naddrp;
	int					naddr = 0;
	struct esis_fixed	*pdu;
	struct iso_ifaddr	*ia;
	int					len;
	struct sockaddr_iso	siso;
d865 1
a865 1
	else if (type == ESIS_ISH) 
d872 3
a874 2
	IFDEBUG(D_ESISOUTPUT)
		int	i;
d876 6
a881 4
			ifp, ifp->if_name, ifp->if_unit, type == ESIS_ESH ? "esh" : "ish",
			ht, sn_len);
		for (i=0; i<sn_len; i++)
			printf("%x%c", *(sn_addr+i), i < (sn_len-1) ? ':' : ' ');
d883 2
a884 1
	ENDDEBUG
d893 1
a893 1
	naddrp = cp = (caddr_t)(pdu + 1);
a907 1

d916 2
a917 1
		 * multiple NSEL's we'll tack them on so he can compress them out.
d923 1
a923 1
		int nsellen = (type == ESIS_ISH ? ia->ia_addr.siso_tlen : 0); 
d929 4
a932 2
		for (ia2 = iso_ifaddr.tqh_first; ia2 != ia; ia2 = ia2->ia_list.tqe_next)
			if (Bcmp(ia->ia_addr.siso_data, ia2->ia_addr.siso_data, n) == 0)
d935 4
a938 2
			continue;	/* Means we have previously copied this nsap */
		if (isoa && Bcmp(ia->ia_addr.siso_data, isoa->isoa_genaddr, n) == 0) {
d942 6
a947 4
		IFDEBUG(D_ESISOUTPUT)
			printf("esis_shoutput: adding NSAP %s\n", 
				clnp_iso_addrp(&ia->ia_addr.siso_addr));
		ENDDEBUG
d949 1
a949 1
							  &ia->ia_addr.siso_addr, m, nsellen)) {
d951 3
a953 2
			(void) esis_insert_addr(&cp, &len, &ia->ia_addr.siso_addr, m,
									nsellen);
d968 1
a968 1
		HTOC(*cp, *(cp+1), esis_esconfig_time);
d971 2
a972 1
		IFDEBUG(D_ESISOUTPUT)
d974 5
a978 2
			m0, m, m->m_data, m->m_len, cp);
		ENDDEBUG
d983 1
a983 1
	iso_gen_csum(m0, ESIS_CKSUM_OFF, (int)pdu->esis_hdr_len);
d985 1
a985 1
	bzero((caddr_t)&siso, sizeof(siso));
d989 2
a990 2
	bcopy(sn_addr, siso.siso_data + 1, (unsigned)sn_len);
	(ifp->if_output)(ifp, m0, sisotosa(&siso), 0);
d996 1
a996 1
 * PURPOSE:			Process an incoming isis packet
d998 1
a998 1
 * RETURNS:			nothing
d1000 1
a1000 1
 * SIDE EFFECTS:	
d1002 1
a1002 1
 * NOTES:			
d1005 7
a1011 3
isis_input(m0, shp)
struct mbuf		*m0;		/* ptr to first mbuf of pkt */
struct snpa_hdr	*shp;	/* subnetwork header */
d1013 1
a1013 1
	register int type;
d1015 19
a1033 11
	struct ifnet *ifp = shp->snh_ifp;
	char workbuf[16];
	struct mbuf *mm;

	IFDEBUG(D_ISISINPUT)
		int i;

		printf("isis_input: pkt on ifp x%x (%s%d): from:", ifp, 
			ifp->if_name, ifp->if_unit);
		for (i=0; i<6; i++)
			printf("%x%c", shp->snh_shost[i]&0xff, (i<5) ? ':' : ' ');
d1035 3
a1037 2
		for (i=0; i<6; i++)
			printf("%x%c", shp->snh_dhost[i]&0xff, (i<5) ? ':' : ' ');
d1039 2
a1040 1
	ENDDEBUG
d1043 1
a1043 1
	bcopy(shp->snh_shost, (caddr_t)esis_dl.sdl_data, esis_dl.sdl_alen);
d1049 2
a1050 1
		if (mm = m_copy(m0, 0, M_COPYALL)) { /*can't block at interrupt level */
d1052 2
a1053 2
			    (struct sockaddr *)&esis_dl, mm,
			    (struct mbuf *)0) != 0) {
d1055 8
a1062 4
			 } else {
				IFDEBUG(D_ISISINPUT)
					printf("Error in sbappenaddr, mm = 0x%x\n", mm);
				ENDDEBUG
d1068 1
a1068 1
	    (struct sockaddr *)&esis_dl, m0, (struct mbuf *)0) != 0) {
d1075 8
a1082 3
isis_output(sdl, m)
register struct sockaddr_dl	*sdl;
struct mbuf *m;
d1084 1
d1086 1
a1086 1
	struct ifaddr *ifa, *ifa_ifwithnet();
d1088 7
a1094 2
	int error = 0;
	unsigned sn_len;
d1096 1
a1096 1
	ifa = ifa_ifwithnet((struct sockaddr *)sdl);	/* get ifp from sdl */
d1098 2
a1099 1
		IFDEBUG(D_ISISOUTPUT)
d1101 2
a1102 1
		ENDDEBUG
d1108 3
a1110 2
	IFDEBUG(D_ISISOUTPUT)
		u_char *cp = (u_char *)LLADDR(sdl), *cplim = cp + sn_len;
d1112 1
a1112 1
			ifp, ifp->if_name, ifp->if_unit);
d1118 5
a1122 3
	ENDDEBUG
	bzero((caddr_t)&siso, sizeof(siso));
	siso.siso_family = AF_ISO; /* This convention may be useful for X.25 */
d1126 1
a1126 1
	error = (ifp->if_output)(ifp, m, sisotosa(&siso), 0);
d1128 6
a1133 3
		IFDEBUG(D_ISISOUTPUT)
			printf("isis_output: error from ether_output is %d\n", error);
		ENDDEBUG
d1140 1
a1140 1
	return(error);
d1147 1
a1147 1
 * PURPOSE:			Handle the PRC_IFDOWN transition
d1149 1
a1149 1
 * RETURNS:			nothing
d1151 1
a1151 1
 * SIDE EFFECTS:	
d1153 3
a1155 3
 * NOTES:			Calls snpac_flush for interface specified.
 *					The loop through iso_ifaddr is stupid because
 *					back in if_down, we knew the ifp...
d1157 5
a1161 4
void
esis_ctlinput(req, siso)
int						req;		/* request: we handle only PRC_IFDOWN */
struct sockaddr_iso		*siso;		/* address of ifp */
d1166 4
a1169 2
		for (ia = iso_ifaddr.tqh_first; ia != 0; ia = ia->ia_list.tqe_next) {
			if (iso_addrmatch(IA_SIS(ia), siso))
d1172 1
d1175 1
a1175 1
#endif	/* ISO */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
