head	1.12;
access;
symbols
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.14
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.12
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.10
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.8
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.6
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.4
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.6
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.4
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.17;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.19.15.07.34;	author miod;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.01.19.06.37.38;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	98.04.04.02.55.55;	author don;	state Exp;
branches
	1.5.10.1;
next	1.4;

1.4
date	96.05.10.12.31.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.10.35.39;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.15;	author deraadt;	state Exp;
branches;
next	;

1.5.10.1
date	2001.05.14.22.40.22;	author niklas;	state Exp;
branches;
next	1.5.10.2;

1.5.10.2
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.5.10.3;

1.5.10.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.5.10.4;

1.5.10.4
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.5.10.5;

1.5.10.5
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: iso_snpac.c,v 1.11 2004/06/21 23:50:37 tholo Exp $	*/
/*	$NetBSD: iso_snpac.c,v 1.13 1996/05/07 02:45:16 thorpej Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)iso_snpac.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */

#ifdef ISO

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#include <netiso/clnp.h>
#include <netiso/clnp_stat.h>
#include <netiso/esis.h>
#include <netiso/argo_debug.h>

int             iso_systype = SNPA_ES;	/* default to be an ES */
extern short    esis_holding_time, esis_config_time, esis_esconfig_time;

LIST_HEAD(, llinfo_llc) llinfo_llc;

struct sockaddr_iso blank_siso = {sizeof(blank_siso), AF_ISO};
static struct sockaddr_iso
	dst = {sizeof(dst), AF_ISO},
	gte = {sizeof(gte), AF_ISO},
#if 0
	src = {sizeof(src), AF_ISO},
#endif
	msk = {sizeof(msk), AF_ISO},
	zmk = {0, 0};

#define zsi blank_siso
#define zero_isoa	zsi.siso_addr
#define zap_isoaddr(a, b) {Bzero(&a.siso_addr, sizeof(*r)); r = b; \
	   Bcopy(r, &a.siso_addr, 1 + (r)->isoa_len);}
#define S(x) ((struct sockaddr *)&(x))

static struct sockaddr_dl blank_dl = {sizeof(blank_dl), AF_LINK};
static struct sockaddr_dl gte_dl;
#define zap_linkaddr(a, b, c, i) \
	(*a = blank_dl, bcopy(b, a->sdl_data, a->sdl_alen = c), a->sdl_index = i)

static void snpac_fixdstandmask(int);

/*
 *	We only keep track of a single IS at a time.
 */
struct rtentry *known_is;

/*
 *	Addresses taken from NBS agreements, December 1987.
 *
 *	These addresses assume on-the-wire transmission of least significant
 *	bit first. This is the method used by 802.3. When these
 *	addresses are passed to the token ring driver, (802.5), they
 *	must be bit-swapped because 802.5 transmission order is MSb first.
 *
 *	Furthermore, according to IBM Austin, these addresses are not
 *	true token ring multicast addresses. More work is necessary
 *	to get multicast to work right on token ring.
 *
 *	Currently, the token ring driver does not handle multicast, so
 *	these addresses are converted into the broadcast address in
 *	lan_output() That means that if these multicast addresses change
 *	the token ring driver must be altered.
 */
char            all_es_snpa[] = {0x09, 0x00, 0x2b, 0x00, 0x00, 0x04};
char            all_is_snpa[] = {0x09, 0x00, 0x2b, 0x00, 0x00, 0x05};
char            all_l1is_snpa[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x14};
char            all_l2is_snpa[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x15};

union sockunion {
	struct sockaddr_iso siso;
	struct sockaddr_dl sdl;
	struct sockaddr sa;
};

/*
 * FUNCTION:		llc_rtrequest
 *
 * PURPOSE:		Manage routing table entries specific to LLC for ISO.
 *
 * NOTES:		This does a lot of obscure magic;
 */
void
llc_rtrequest(req, rt, info)
	int             req;
	struct rtentry *rt;
	struct rt_addrinfo *info;
{
	union sockunion *gate = (union sockunion *) rt->rt_gateway;
	struct llinfo_llc *lc = (struct llinfo_llc *) rt->rt_llinfo;
	struct ifnet   *ifp = rt->rt_ifp;
	int             addrlen = ifp->if_addrlen;
#define LLC_SIZE 3		/* XXXXXX do this right later */

#ifdef ARGO_DEBUG
	if (argo_debug[D_SNPA]) {
		printf("llc_rtrequest(%d, %p, %p)\n", req, rt, info);
	}
#endif
	if (rt->rt_flags & RTF_GATEWAY)
		return;
	else
		switch (req) {
		case RTM_ADD:
			/*
			 * Case 1: This route may come from a route to iface with mask
			 * or from a default route.
			 */
			if (rt->rt_flags & RTF_CLONING) {
				iso_setmcasts(ifp, req);
				rt_setgate(rt, rt_key(rt),
					   (struct sockaddr *) & blank_dl);
				return;
			}
			if (lc != 0)
				return;	/* happens on a route change */
			/* FALLTHROUGH */
		case RTM_RESOLVE:
			/*
			 * Case 2:  This route may come from cloning, or a manual route
			 * add with a LL address.
			 */
			if (gate->sdl.sdl_family != AF_LINK) {
				log(LOG_DEBUG, "llc_rtrequest: got non-link non-gateway route\n");
				break;
			}
			R_Malloc(lc, struct llinfo_llc *, sizeof(*lc));
			rt->rt_llinfo = (caddr_t) lc;
			if (lc == 0) {
				log(LOG_DEBUG, "llc_rtrequest: malloc failed\n");
				break;
			}
			Bzero(lc, sizeof(*lc));
			lc->lc_rt = rt;
			rt->rt_flags |= RTF_LLINFO;
			LIST_INSERT_HEAD(&llinfo_llc, lc, lc_list);
			if (gate->sdl.sdl_alen == sizeof(struct esis_req) + addrlen) {
				gate->sdl.sdl_alen -= sizeof(struct esis_req);
				bcopy(addrlen + LLADDR(&gate->sdl),
				  (caddr_t) & lc->lc_er, sizeof(lc->lc_er));
			} else if (gate->sdl.sdl_alen == addrlen)
				lc->lc_flags = (SNPA_ES | SNPA_VALID | SNPA_PERM);
			break;
		case RTM_DELETE:
			if (rt->rt_flags & RTF_CLONING)
				iso_setmcasts(ifp, req);
			if (lc == 0)
				return;
			LIST_REMOVE(lc, lc_list);
			Free(lc);
			rt->rt_llinfo = 0;
			rt->rt_flags &= ~RTF_LLINFO;
			break;
		}
	if (rt->rt_rmx.rmx_mtu == 0) {
		rt->rt_rmx.rmx_mtu = rt->rt_ifp->if_mtu - LLC_SIZE;
	}
}

/*
 * FUNCTION:		iso_setmcasts
 *
 * PURPOSE:		Enable/Disable ESIS/ISIS multicast reception on
 *			interfaces.
 *
 * NOTES:		This also does a lot of obscure magic;
 */
void
iso_setmcasts(ifp, req)
	struct ifnet   *ifp;
	int             req;
{
	static char    *addrlist[] =
	{all_es_snpa, all_is_snpa, all_l1is_snpa, all_l2is_snpa, 0};
	struct ifreq    ifr;
	caddr_t *cpp;
	int             doreset = 0;

	bzero((caddr_t) & ifr, sizeof(ifr));
	for (cpp = (caddr_t *) addrlist; *cpp; cpp++) {
		bcopy(*cpp, (caddr_t) ifr.ifr_addr.sa_data, 6);
		if (req == RTM_ADD) {
			if (ether_addmulti(&ifr, (struct arpcom *) ifp) == ENETRESET)
				doreset++;
			else if (ether_delmulti(&ifr, (struct arpcom *) ifp) == ENETRESET)
				doreset++;
		}
	}
	if (doreset) {
		if (ifp->if_reset)
			(*ifp->if_reset) (ifp);
		else
			printf("iso_setmcasts: %s needs reseting to receive iso mcasts\n",
			       ifp->if_xname);
	}
}

/*
 * FUNCTION:		iso_snparesolve
 *
 * PURPOSE:		Resolve an iso address into snpa address
 *
 * RETURNS:		0 if addr is resolved
 *			errno if addr is unknown
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Now that we have folded the snpa cache into the routing
 *			table, we know there is no snpa address known for this
 *			destination.  If we know of a default IS, then the
 *			address of the IS is returned.  If no IS is known,
 *			then return the multi-cast address for "all ES" for
 *			this interface.
 *
 *			NB: the last case described above constitutes the
 *			query configuration function 9542, sec 6.5
 *			A mechanism is needed to prevent this function from
 *			being invoked if the system is an IS.
 */
int
iso_snparesolve(ifp, dest, snpa, snpa_len)
	struct ifnet   *ifp;	/* outgoing interface */
	struct sockaddr_iso *dest;	/* destination */
	caddr_t         snpa;	/* RESULT: snpa to be used */
	int            *snpa_len;	/* RESULT: length of snpa */
{
	struct llinfo_llc *sc;	/* ptr to snpa table entry */
	caddr_t         found_snpa;
	int             addrlen;

	/*
	 * This hack allows us to send esis packets that have the destination
	 * snpa addresss embedded in the destination nsap address
	 */
	if (dest->siso_data[0] == AFI_SNA) {
		/*
		 *	This is a subnetwork address. Return it immediately
		 */
#ifdef ARGO_DEBUG
		if (argo_debug[D_SNPA]) {
			printf("iso_snparesolve: return SN address\n");
		}
#endif
		addrlen = dest->siso_nlen - 1;	/* subtract size of AFI */
		found_snpa = (caddr_t) dest->siso_data + 1;
		/*
		 * If we are an IS, we can't do much with the packet; Check
		 * if we know about an IS.
		 */
	} else if (iso_systype != SNPA_IS && known_is != 0 &&
		   (sc = (struct llinfo_llc *) known_is->rt_llinfo) &&
		   (sc->lc_flags & SNPA_VALID)) {
		struct sockaddr_dl *sdl =
		(struct sockaddr_dl *) (known_is->rt_gateway);
		found_snpa = LLADDR(sdl);
		addrlen = sdl->sdl_alen;
	} else if (ifp->if_flags & IFF_BROADCAST) {
		/*
		 * no IS, no match. Return "all es" multicast address for
		 * this interface, as per Query Configuration Function (9542
		 * sec 6.5)
		 *
		 * Note: there is a potential problem here. If the destination
		 * is on the subnet and it does not respond with a ESH, but
		 * does send back a TP CC, a connection could be established
		 * where we always transmit the CLNP packet to "all es"
		 */
		addrlen = ifp->if_addrlen;
		found_snpa = (caddr_t) all_es_snpa;
	} else
		return (ENETUNREACH);
	bcopy(found_snpa, snpa, *snpa_len = addrlen);
	return (0);
}


/*
 * FUNCTION:		snpac_free
 *
 * PURPOSE:		free an entry in the iso address map table
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		If there is a route entry associated with cache
 *			entry, then delete that as well
 */
void
snpac_free(lc)
	struct llinfo_llc *lc;	/* entry to free */
{
	struct rtentry *rt = lc->lc_rt;

	if (known_is == rt)
		known_is = 0;
	if (rt && (rt->rt_flags & RTF_UP) &&
	    (rt->rt_flags & (RTF_DYNAMIC | RTF_MODIFIED))) {
		RTFREE(rt);
		rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway, rt_mask(rt),
			  rt->rt_flags, (struct rtentry **) 0);
		RTFREE(rt);
	}
}

/*
 * FUNCTION:		snpac_add
 *
 * PURPOSE:		Add an entry to the snpa cache
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:		If entry already exists, then update holding time.
 */
int
snpac_add(ifp, nsap, snpa, type, ht, nsellength)
	struct ifnet   *ifp;	/* interface info is related to */
	struct iso_addr *nsap;	/* nsap to add */
	caddr_t         snpa;	/* translation */
	char            type;	/* SNPA_IS or SNPA_ES */
	u_short         ht;	/* holding time (in seconds) */
	int             nsellength;	/* nsaps may differ only in trailing
					 * bytes */
{
	struct llinfo_llc *lc;
	struct rtentry *rt;
	struct rtentry *mrt = 0;
	struct iso_addr *r;	/* for zap_isoaddr macro */
	int             snpalen = min(ifp->if_addrlen, MAX_SNPALEN);
	int             new_entry = 0, index = ifp->if_index, iftype = ifp->if_type;

#ifdef ARGO_DEBUG
	if (argo_debug[D_SNPA]) {
		printf("snpac_add(%p, %p, %p, %x, %x, %x)\n",
		       ifp, nsap, snpa, type, ht, nsellength);
	}
#endif
	zap_isoaddr(dst, nsap);
	rt = rtalloc1(sisotosa(&dst), 0);
#ifdef ARGO_DEBUG
	if (argo_debug[D_SNPA]) {
		printf("snpac_add: rtalloc1 returns %p\n", rt);
	}
#endif
	if (rt == 0) {
		struct sockaddr *netmask;
		int             flags;
add:
		if (nsellength) {
			netmask = sisotosa(&msk);
			flags = RTF_UP;
			snpac_fixdstandmask(nsellength);
		} else {
			netmask = 0;
			flags = RTF_UP | RTF_HOST;
		}
		new_entry = 1;
		zap_linkaddr((&gte_dl), snpa, snpalen, index);
		gte_dl.sdl_type = iftype;
		if (rtrequest(RTM_ADD, sisotosa(&dst), S(gte_dl), netmask,
			      flags, &mrt) || mrt == 0)
			return (0);
		rt = mrt;
		rt->rt_refcnt--;
	} else {
		struct sockaddr_dl *sdl = (struct sockaddr_dl *) rt->rt_gateway;
		rt->rt_refcnt--;
		if ((rt->rt_flags & RTF_LLINFO) == 0)
			goto add;
		if (nsellength && (rt->rt_flags & RTF_HOST)) {
			if (rt->rt_refcnt == 0) {
				rtrequest(RTM_DELETE, sisotosa(&dst),
				(struct sockaddr *) 0, (struct sockaddr *) 0,
					  0, (struct rtentry **) 0);
				rt = 0;
				goto add;
			} else {
				static struct iso_addr nsap2;
				char  *cp;
				nsap2 = *nsap;
				cp = nsap2.isoa_genaddr + nsap->isoa_len - nsellength;
				while (cp < (char *) (1 + &nsap2))
					*cp++ = 0;
				(void) snpac_add(ifp, &nsap2, snpa, type, ht, nsellength);
			}
		}
		if (sdl->sdl_family != AF_LINK || sdl->sdl_alen == 0) {
			int             old_sdl_len = sdl->sdl_len;
			if (old_sdl_len < sizeof(*sdl)) {
				log(LOG_DEBUG, "snpac_add: cant make room for lladdr\n");
				return (0);
			}
			zap_linkaddr(sdl, snpa, snpalen, index);
			sdl->sdl_len = old_sdl_len;
			sdl->sdl_type = iftype;
			new_entry = 1;
		}
	}
	if ((lc = (struct llinfo_llc *) rt->rt_llinfo) == 0)
		panic("snpac_rtrequest");
	rt->rt_rmx.rmx_expire = ht + time_second;
	lc->lc_flags = SNPA_VALID | type;
	if ((type & SNPA_IS) && !(iso_systype & SNPA_IS))
		snpac_logdefis(rt);
	return (new_entry);
}

static void
snpac_fixdstandmask(nsellength)
	int nsellength;
{
	char  *cp = msk.siso_data, *cplim;

	cplim = cp + (dst.siso_nlen -= nsellength);
	msk.siso_len = cplim - (char *) &msk;
	msk.siso_nlen = 0;
	while (cp < cplim)
		*cp++ = -1;
	while (cp < (char *) msk.siso_pad)
		*cp++ = 0;
	for (cp = dst.siso_data + dst.siso_nlen; cp < (char *) dst.siso_pad;)
		*cp++ = 0;
}

/*
 * FUNCTION:		snpac_ioctl
 *
 * PURPOSE:			Set/Get the system type and esis parameters
 *
 * RETURNS:			0 on success, or unix error code
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
int
snpac_ioctl(so, cmd, data)
	struct socket  *so;
	u_long          cmd;	/* ioctl to process */
	caddr_t         data;	/* data for the cmd */
{
	struct systype_req *rq = (struct systype_req *) data;
	extern struct timeout esis_timeout;

#ifdef ARGO_DEBUG
	if (argo_debug[D_IOCTL]) {
		if (cmd == SIOCSSTYPE)
			printf("snpac_ioctl: cmd set, type x%x, ht %d, ct %d\n",
			       rq->sr_type, rq->sr_holdt, rq->sr_configt);
		else
			printf("snpac_ioctl: cmd get\n");
	}
#endif

	if (cmd == SIOCSSTYPE) {
		if ((so->so_state & SS_PRIV) == 0)
			return (EPERM);
		if ((rq->sr_type & (SNPA_ES | SNPA_IS)) == (SNPA_ES | SNPA_IS))
			return (EINVAL);
		if (rq->sr_type & SNPA_ES) {
			iso_systype = SNPA_ES;
		} else if (rq->sr_type & SNPA_IS) {
			iso_systype = SNPA_IS;
		} else {
			return (EINVAL);
		}
		esis_holding_time = rq->sr_holdt;
		esis_config_time = rq->sr_configt;
		if (esis_esconfig_time != rq->sr_esconfigt) {
			timeout_del(&esis_timeout);
			esis_esconfig_time = rq->sr_esconfigt;
			esis_config(NULL);
		}
	} else if (cmd == SIOCGSTYPE) {
		rq->sr_type = iso_systype;
		rq->sr_holdt = esis_holding_time;
		rq->sr_configt = esis_config_time;
		rq->sr_esconfigt = esis_esconfig_time;
	} else {
		return (EINVAL);
	}
	return (0);
}

/*
 * FUNCTION:		snpac_logdefis
 *
 * PURPOSE:			Mark the IS passed as the default IS
 *
 * RETURNS:			nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
snpac_logdefis(sc)
	struct rtentry *sc;
{
	struct rtentry *rt;

	if (known_is == sc || !(sc->rt_flags & RTF_HOST))
		return;
	if (known_is) {
		RTFREE(known_is);
	}
	known_is = sc;
	sc->rt_refcnt++;
	rt = rtalloc1((struct sockaddr *) & zsi, 0);
	if (rt == 0)
		rtrequest(RTM_ADD, sisotosa(&zsi), rt_key(sc), sisotosa(&zmk),
			  RTF_DYNAMIC | RTF_GATEWAY, 0);
	else {
		if ((rt->rt_flags & RTF_DYNAMIC) &&
		    (rt->rt_flags & RTF_GATEWAY) && rt_mask(rt)->sa_len == 0)
			rt_setgate(rt, rt_key(rt), rt_key(sc));
	}
}

/*
 * FUNCTION:		snpac_age
 *
 * PURPOSE:		Time out snpac entries
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:		When encountering an entry for the first time, snpac_age
 *			may delete up to SNPAC_AGE too many seconds. Ie.
 *			if the entry is added a moment before snpac_age is
 *			called, the entry will immediately have SNPAC_AGE
 *			seconds taken off the holding time, even though
 *			it has only been held a brief moment.
 *
 *			The proper way to do this is set an expiry timeval
 *			equal to current time + holding time. Then snpac_age
 *			would time out entries where expiry date is older
 *			than the current time.
 */
/*ARGSUSED*/
void
snpac_age(v)
	void *v;
{
	struct llinfo_llc *lc, *nlc;
	struct rtentry *rt;

	extern struct timeout snpac_timeout;
	timeout_add(&snpac_timeout, SNPAC_AGE * hz);

	for (lc = llinfo_llc.lh_first; lc != 0; lc = nlc) {
		nlc = lc->lc_list.le_next;
		if (lc->lc_flags & SNPA_VALID) {
			rt = lc->lc_rt;
			if (rt->rt_rmx.rmx_expire && rt->rt_rmx.rmx_expire < time_second)
				snpac_free(lc);
		}
	}
}

/*
 * FUNCTION:		snpac_ownmulti
 *
 * PURPOSE:		Determine if the snpa address is a multicast address
 *			of the same type as the system.
 *
 * RETURNS:		true or false
 *
 * SIDE EFFECTS:
 *
 * NOTES:		Used by interface drivers when not in eavesdrop mode
 *			as interm kludge until
 *			real multicast addresses can be configured
 */
int
snpac_ownmulti(snpa, len)
	caddr_t         snpa;
	u_int           len;
{
	return (((iso_systype & SNPA_ES) &&
		 (!bcmp(snpa, (caddr_t) all_es_snpa, len))) ||
		((iso_systype & SNPA_IS) &&
		 (!bcmp(snpa, (caddr_t) all_is_snpa, len))));
}

/*
 * FUNCTION:		snpac_flushifp
 *
 * PURPOSE:		Flush entries associated with specific ifp
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
snpac_flushifp(ifp)
	struct ifnet   *ifp;
{
	struct llinfo_llc *lc;

	for (lc = llinfo_llc.lh_first; lc != 0; lc = lc->lc_list.le_next) {
		if (lc->lc_rt->rt_ifp == ifp && (lc->lc_flags & SNPA_VALID))
			snpac_free(lc);
	}
}

/*
 * FUNCTION:		snpac_rtrequest
 *
 * PURPOSE:		Make a routing request
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		In the future, this should make a request of a user
 *			level routing daemon.
 */
void
snpac_rtrequest(req, host, gateway, netmask, flags, ret_nrt)
	int             req;
	struct iso_addr *host;
	struct iso_addr *gateway;
	struct iso_addr *netmask;
	short           flags;
	struct rtentry **ret_nrt;
{
	struct iso_addr *r;

#ifdef ARGO_DEBUG
	if (argo_debug[D_SNPA]) {
		printf("snpac_rtrequest: ");
		if (req == RTM_ADD)
			printf("add");
		else if (req == RTM_DELETE)
			printf("delete");
		else
			printf("unknown command");
		printf(" dst: %s\n", clnp_iso_addrp(host));
		printf("\tgateway: %s\n", clnp_iso_addrp(gateway));
	}
#endif


	zap_isoaddr(dst, host);
	zap_isoaddr(gte, gateway);
	if (netmask) {
		zap_isoaddr(msk, netmask);
		msk.siso_nlen = 0;
		msk.siso_len = msk.siso_pad - (u_char *) & msk;
	}
	rtrequest(req, sisotosa(&dst), sisotosa(&gte),
	(netmask ? sisotosa(&msk) : (struct sockaddr *) 0), flags, ret_nrt);
}

/*
 * FUNCTION:		snpac_addrt
 *
 * PURPOSE:		Associate a routing entry with an snpac entry
 *
 * RETURNS:		nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:		If a cache entry exists for gateway, then
 *			make a routing entry (host, gateway) and associate
 *			with gateway.
 *
 *			If a route already exists and is different, first delete
 *			it.
 *
 *			This could be made more efficient by checking
 *			the existing route before adding a new one.
 */
void
snpac_addrt(ifp, host, gateway, netmask)
	struct ifnet   *ifp;
	struct iso_addr *host, *gateway, *netmask;
{
	struct iso_addr *r;

	zap_isoaddr(dst, host);
	zap_isoaddr(gte, gateway);
	if (netmask) {
		zap_isoaddr(msk, netmask);
		msk.siso_nlen = 0;
		msk.siso_len = msk.siso_pad - (u_char *) & msk;
		rtredirect(sisotosa(&dst), sisotosa(&gte), sisotosa(&msk),
			   RTF_DONE, sisotosa(&gte), 0);
	} else
		rtredirect(sisotosa(&dst), sisotosa(&gte), (struct sockaddr *) 0,
			   RTF_DONE | RTF_HOST, sisotosa(&gte), 0);
}
#endif				/* ISO */
@


1.11
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.10 2003/12/10 07:22:44 itojun Exp $	*/
@


1.10
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.9 2003/06/02 23:28:17 millert Exp $	*/
a92 2
extern struct timeval time;
extern int      hz;
d479 1
a479 1
	rt->rt_rmx.rmx_expire = ht + time.tv_sec;
d634 1
a634 1
			if (rt->rt_rmx.rmx_expire && rt->rt_rmx.rmx_expire < time.tv_sec)
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.8 2002/03/14 01:27:12 millert Exp $	*/
d164 1
a164 1
	register struct rtentry *rt;
d167 2
a168 2
	register union sockunion *gate = (union sockunion *) rt->rt_gateway;
	register struct llinfo_llc *lc = (struct llinfo_llc *) rt->rt_llinfo;
d254 1
a254 1
	register caddr_t *cpp;
d331 1
a331 1
		register struct sockaddr_dl *sdl =
d369 1
a369 1
	register struct llinfo_llc *lc;	/* entry to free */
d371 1
a371 1
	register struct rtentry *rt = lc->lc_rt;
d405 2
a406 2
	register struct llinfo_llc *lc;
	register struct rtentry *rt;
d408 1
a408 1
	register struct iso_addr *r;	/* for zap_isoaddr macro */
d446 1
a446 1
		register struct sockaddr_dl *sdl = (struct sockaddr_dl *) rt->rt_gateway;
d459 1
a459 1
				register char  *cp;
d492 1
a492 1
	register char  *cp = msk.siso_data, *cplim;
d522 1
a522 1
	register struct systype_req *rq = (struct systype_req *) data;
d578 1
a578 1
	register struct rtentry *sc;
d580 1
a580 1
	register struct rtentry *rt;
d626 2
a627 2
	register struct llinfo_llc *lc, *nlc;
	register struct rtentry *rt;
d682 1
a682 1
	register struct llinfo_llc *lc;
d711 1
a711 1
	register struct iso_addr *r;
d763 1
a763 1
	register struct iso_addr *r;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.7 2001/08/19 15:07:34 miod Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@More old timeouts removal, mainly affected unused/unmaintained code.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.6 2001/01/19 06:37:38 itojun Exp $	*/
d123 1
a123 1
static void snpac_fixdstandmask __P((int));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.7 2001/08/19 15:07:34 miod Exp $	*/
d123 1
a123 1
static void snpac_fixdstandmask(int);
@


1.6
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.5 1998/04/04 02:55:55 don Exp $	*/
d78 1
d527 1
d554 1
a554 1
			untimeout(esis_config, (caddr_t) 0);
d633 2
a634 1
	timeout(snpac_age, (caddr_t) 0, SNPAC_AGE * hz);
@


1.5
log
@gcc 2.8 supplication
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.4 1996/05/10 12:31:22 deraadt Exp $	*/
d165 1
a165 1
llc_rtrequest(req, rt, sa)
d168 1
a168 1
	struct sockaddr *sa;
d178 1
a178 1
		printf("llc_rtrequest(%d, %p, %p)\n", req, rt, sa);
@


1.5.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.6 2001/01/19 06:37:38 itojun Exp $	*/
d165 1
a165 1
llc_rtrequest(req, rt, info)
d168 1
a168 1
	struct rt_addrinfo *info;
d178 1
a178 1
		printf("llc_rtrequest(%d, %p, %p)\n", req, rt, info);
@


1.5.10.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.5.10.1 2001/05/14 22:40:22 niklas Exp $	*/
a77 1
#include <sys/timeout.h>
a525 1
	extern struct timeout esis_timeout;
d552 1
a552 1
			timeout_del(&esis_timeout);
d631 1
a631 2
	extern struct timeout snpac_timeout;
	timeout_add(&snpac_timeout, SNPAC_AGE * hz);
@


1.5.10.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d123 1
a123 1
static void snpac_fixdstandmask(int);
@


1.5.10.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.5.10.3 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.10.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d164 1
a164 1
	struct rtentry *rt;
d167 2
a168 2
	union sockunion *gate = (union sockunion *) rt->rt_gateway;
	struct llinfo_llc *lc = (struct llinfo_llc *) rt->rt_llinfo;
d254 1
a254 1
	caddr_t *cpp;
d331 1
a331 1
		struct sockaddr_dl *sdl =
d369 1
a369 1
	struct llinfo_llc *lc;	/* entry to free */
d371 1
a371 1
	struct rtentry *rt = lc->lc_rt;
d405 2
a406 2
	struct llinfo_llc *lc;
	struct rtentry *rt;
d408 1
a408 1
	struct iso_addr *r;	/* for zap_isoaddr macro */
d446 1
a446 1
		struct sockaddr_dl *sdl = (struct sockaddr_dl *) rt->rt_gateway;
d459 1
a459 1
				char  *cp;
d492 1
a492 1
	char  *cp = msk.siso_data, *cplim;
d522 1
a522 1
	struct systype_req *rq = (struct systype_req *) data;
d578 1
a578 1
	struct rtentry *sc;
d580 1
a580 1
	struct rtentry *rt;
d626 2
a627 2
	struct llinfo_llc *lc, *nlc;
	struct rtentry *rt;
d682 1
a682 1
	struct llinfo_llc *lc;
d711 1
a711 1
	struct iso_addr *r;
d763 1
a763 1
	struct iso_addr *r;
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$OpenBSD: iso_snpac.c,v 1.2 1996/03/04 10:35:39 mickey Exp $	*/
d263 1
a263 1
		if (req == RTM_ADD)
d268 1
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: iso_snpac.c,v 1.12 1996/04/13 01:35:00 cgd Exp $	*/
d271 1
a271 1
			(*ifp->if_reset) (ifp->if_unit);
d273 2
a274 2
			printf("iso_setmcasts: %s%d needs reseting to receive iso mcasts\n",
			       ifp->if_name, ifp->if_unit);
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: iso_snpac.c,v 1.11 1996/02/13 22:10:25 christos Exp $	*/
d178 1
a178 2
		printf("llc_rtrequest(%d, %x, %x)\n", req, 
			(unsigned int) rt, (unsigned int) sa);
d416 2
a417 4
		printf("snpac_add(%x, %x, %x, %x, %x, %x)\n",
		       (unsigned int) ifp,
		       (unsigned int) nsap,
		       (unsigned int) snpa, type, ht, nsellength);
d424 1
a424 1
		printf("snpac_add: rtalloc1 returns %x\n", (unsigned int) rt);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: iso_snpac.c,v 1.10 1995/06/13 08:12:41 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d83 3
d94 4
a97 6
int 				iso_systype = SNPA_ES;	/* default to be an ES */
extern short	esis_holding_time, esis_config_time, esis_esconfig_time;
extern struct	timeval time;
extern void esis_config();
extern int hz;
static void snpac_fixdstandmask();
a101 1
extern u_long iso_hashchar();
d103 8
a110 5
	dst	= {sizeof(dst), AF_ISO},
	gte	= {sizeof(dst), AF_ISO},
	src	= {sizeof(dst), AF_ISO},
	msk	= {sizeof(dst), AF_ISO},
	zmk = {0};
d122 2
d127 1
a127 1
struct rtentry	*known_is;
d146 4
a149 4
char all_es_snpa[] = { 0x09, 0x00, 0x2b, 0x00, 0x00, 0x04 };
char all_is_snpa[] = { 0x09, 0x00, 0x2b, 0x00, 0x00, 0x05 };
char all_l1is_snpa[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x14};
char all_l2is_snpa[] = {0x01, 0x80, 0xc2, 0x00, 0x00, 0x15};
d153 2
a154 2
	struct sockaddr_dl	sdl;
	struct sockaddr		sa;
d160 1
a160 1
 * PURPOSE:			Manage routing table entries specific to LLC for ISO.
d162 1
a162 1
 * NOTES:			This does a lot of obscure magic;
d164 1
d166 16
a181 14
int req;
register struct rtentry *rt;
struct sockaddr *sa;
{
	register union sockunion *gate = (union sockunion *)rt->rt_gateway;
	register struct llinfo_llc *lc = (struct llinfo_llc *)rt->rt_llinfo, *lc2;
	struct rtentry *rt2;
	struct ifnet *ifp = rt->rt_ifp;
	int addrlen = ifp->if_addrlen;
#define LLC_SIZE 3 /* XXXXXX do this right later */

	IFDEBUG (D_SNPA)
		printf("llc_rtrequest(%d, %x, %x)\n", req, rt, sa);
	ENDDEBUG
d184 41
a224 22
	else switch (req) {
	case RTM_ADD:
		/*
		 * Case 1: This route may come from a route to iface with mask
		 * or from a default route.
		 */
		if (rt->rt_flags & RTF_CLONING) {
			iso_setmcasts(ifp, req);
			rt_setgate(rt, rt_key(rt),
			    (struct sockaddr *)&blank_dl);
			return;
		}
		if (lc != 0)
			return; /* happens on a route change */
		/* FALLTHROUGH */
	case RTM_RESOLVE:
		/*
		 * Case 2:  This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		if (gate->sdl.sdl_family != AF_LINK) {
			log(LOG_DEBUG, "llc_rtrequest: got non-link non-gateway route\n");
d226 9
a234 5
		}
		R_Malloc(lc, struct llinfo_llc *, sizeof (*lc));
		rt->rt_llinfo = (caddr_t)lc;
		if (lc == 0) {
			log(LOG_DEBUG, "llc_rtrequest: malloc failed\n");
a236 22
		Bzero(lc, sizeof(*lc));
		lc->lc_rt = rt;
		rt->rt_flags |= RTF_LLINFO;
		LIST_INSERT_HEAD(&llinfo_llc, lc, lc_list);
		if (gate->sdl.sdl_alen == sizeof(struct esis_req) + addrlen) {
			gate->sdl.sdl_alen -= sizeof(struct esis_req);
			bcopy(addrlen + LLADDR(&gate->sdl),
				  (caddr_t)&lc->lc_er, sizeof(lc->lc_er));
		} else if (gate->sdl.sdl_alen == addrlen)
			lc->lc_flags = (SNPA_ES | SNPA_VALID | SNPA_PERM);
		break;
	case RTM_DELETE:
		if (rt->rt_flags & RTF_CLONING)
			iso_setmcasts(ifp, req);
		if (lc == 0)
			return;
		LIST_REMOVE(lc, lc_list);
		Free(lc);
		rt->rt_llinfo = 0;
		rt->rt_flags &= ~RTF_LLINFO;
		break;
	}
d238 1
a238 1
			rt->rt_rmx.rmx_mtu = rt->rt_ifp->if_mtu - LLC_SIZE;
d241 1
d245 2
a246 1
 * PURPOSE:			Enable/Disable ESIS/ISIS multicast reception on interfaces.
d248 1
a248 1
 * NOTES:			This also does a lot of obscure magic;
d250 1
d252 2
a253 2
	struct	ifnet *ifp;
	int		req;
d255 3
a257 3
	static char *addrlist[] =
		{ all_es_snpa, all_is_snpa, all_l1is_snpa, all_l2is_snpa, 0};
	struct ifreq ifr;
d259 1
a259 1
	int		doreset = 0;
d261 3
a263 3
	bzero((caddr_t)&ifr, sizeof(ifr));
	for (cpp = (caddr_t *)addrlist; *cpp; cpp++) {
		bcopy(*cpp, (caddr_t)ifr.ifr_addr.sa_data, 6);
d265 1
a265 1
			if (ether_addmulti(&ifr, (struct arpcom *)ifp) == ENETRESET)
d267 1
a267 2
		else
			if (ether_delmulti(&ifr, (struct arpcom *)ifp) == ENETRESET)
d272 1
a272 1
			(*ifp->if_reset)(ifp->if_unit);
d275 1
a275 1
					ifp->if_name, ifp->if_unit);
d278 1
d282 1
a282 1
 * PURPOSE:			Resolve an iso address into snpa address
d284 2
a285 2
 * RETURNS:			0 if addr is resolved
 *					errno if addr is unknown
d287 1
a287 1
 * SIDE EFFECTS:	
d289 11
a299 10
 * NOTES:			Now that we have folded the snpa cache into the routing
 *					table, we know there is no snpa address known for this
 *					destination.  If we know of a default IS, then the address
 *					of the IS is returned.  If no IS is known, then return the
 *					multi-cast address for "all ES" for this interface.
 *
 *					NB: the last case described above constitutes the
 *					query configuration function 9542, sec 6.5
 *					A mechanism is needed to prevent this function from
 *					being invoked if the system is an IS.
d301 1
d303 8
a310 8
struct	ifnet *ifp;			/* outgoing interface */
struct	sockaddr_iso *dest;	/* destination */
caddr_t	snpa;				/* RESULT: snpa to be used */
int		*snpa_len;			/* RESULT: length of snpa */
{
	struct	llinfo_llc *sc;	/* ptr to snpa table entry */
	caddr_t	found_snpa;
	int 	addrlen;
d313 2
a314 2
	 *	This hack allows us to send esis packets that have the destination snpa
	 *	addresss embedded in the destination nsap address 
d320 2
a321 1
		IFDEBUG(D_SNPA)
d323 2
a324 1
		ENDDEBUG
d327 4
a330 4
	/* 
	 * If we are an IS, we can't do much with the packet;
	 *	Check if we know about an IS.
	 */
d332 2
a333 2
				(sc = (struct llinfo_llc *)known_is->rt_llinfo) &&
				 (sc->lc_flags & SNPA_VALID)) {
d335 1
a335 1
			(struct sockaddr_dl *)(known_is->rt_gateway);
d339 4
a342 3
		/* 
		 *	no IS, no match. Return "all es" multicast address for this
		 *	interface, as per Query Configuration Function (9542 sec 6.5)
d344 4
a347 4
		 *	Note: there is a potential problem here. If the destination
		 *	is on the subnet and it does not respond with a ESH, but
		 *	does send back a TP CC, a connection could be established
		 *	where we always transmit the CLNP packet to "all es"
d350 1
a350 1
		found_snpa = (caddr_t)all_es_snpa;
d361 1
a361 1
 * PURPOSE:			free an entry in the iso address map table
d363 1
a363 1
 * RETURNS:			nothing
d365 1
a365 1
 * SIDE EFFECTS:	
d367 2
a368 2
 * NOTES:			If there is a route entry associated with cache
 *					entry, then delete that as well
d370 1
d372 1
a372 1
register struct llinfo_llc *lc;		/* entry to free */
a374 1
	register struct iso_addr *r;
d379 4
a382 4
		(rt->rt_flags & (RTF_DYNAMIC | RTF_MODIFIED))) {
			RTFREE(rt);
			rtrequest(RTM_DELETE, rt_key(rt), rt->rt_gateway, rt_mask(rt),
						rt->rt_flags, (struct rtentry **)0);
d390 1
a390 1
 * PURPOSE:			Add an entry to the snpa cache
d392 1
a392 1
 * RETURNS:			
d394 1
a394 1
 * SIDE EFFECTS:	
d396 1
a396 1
 * NOTES:			If entry already exists, then update holding time.
d398 1
d400 7
a406 6
struct ifnet		*ifp;		/* interface info is related to */
struct iso_addr		*nsap;		/* nsap to add */
caddr_t				snpa;		/* translation */
char				type;		/* SNPA_IS or SNPA_ES */
u_short				ht;			/* holding time (in seconds) */
int					nsellength;	/* nsaps may differ only in trailing bytes */
d408 1
a408 1
	register struct	llinfo_llc *lc;
d410 4
a413 4
	struct	rtentry *mrt = 0;
	register struct	iso_addr *r; /* for zap_isoaddr macro */
	int		snpalen = min(ifp->if_addrlen, MAX_SNPALEN);
	int		new_entry = 0, index = ifp->if_index, iftype = ifp->if_type;
d415 2
a416 1
	IFDEBUG(D_SNPA)
d418 5
a422 2
			ifp, nsap, snpa, type, ht, nsellength);
	ENDDEBUG
d425 5
a429 3
	IFDEBUG(D_SNPA)
		printf("snpac_add: rtalloc1 returns %x\n", rt);
	ENDDEBUG
d432 2
a433 2
		int flags;
		add:
d435 2
a436 1
			netmask = sisotosa(&msk); flags = RTF_UP;
d439 2
a440 1
			netmask = 0; flags = RTF_UP | RTF_HOST;
d446 1
a446 1
		    flags, &mrt) || mrt == 0)
d451 1
a451 1
		register struct sockaddr_dl *sdl = (struct sockaddr_dl *)rt->rt_gateway;
d458 2
a459 2
				    (struct sockaddr *)0, (struct sockaddr *)0,
				    0, (struct rtentry **)0);
d463 2
a464 1
				static struct iso_addr nsap2; register char *cp;
d467 1
a467 1
				while (cp < (char *)(1 + &nsap2))
d473 1
a473 1
			int old_sdl_len = sdl->sdl_len;
d484 1
a484 1
	if ((lc = (struct llinfo_llc *)rt->rt_llinfo) == 0)
d495 1
d497 1
a497 1
	register char *cp = msk.siso_data, *cplim;
d500 1
a500 1
	msk.siso_len = cplim - (char *)&msk;
d504 1
a504 1
	while (cp < (char *)msk.siso_pad)
d506 1
a506 1
	for (cp = dst.siso_data + dst.siso_nlen; cp < (char *)dst.siso_pad; )
d517 1
a517 1
 * SIDE EFFECTS:	
d519 1
a519 1
 * NOTES:			
d521 5
a525 4
snpac_ioctl (so, cmd, data)
struct socket *so;
u_long	cmd;	/* ioctl to process */
caddr_t	data;	/* data for the cmd */
d527 1
a527 1
	register struct systype_req *rq = (struct systype_req *)data;
d529 2
a530 1
	IFDEBUG(D_IOCTL)
d533 1
a533 1
				rq->sr_type, rq->sr_holdt, rq->sr_configt);
d536 2
a537 1
	ENDDEBUG
d542 2
a543 2
		if ((rq->sr_type & (SNPA_ES|SNPA_IS)) == (SNPA_ES|SNPA_IS))
			return(EINVAL);
d549 1
a549 1
			return(EINVAL);
d554 1
a554 1
			untimeout(esis_config, (caddr_t)0);
d556 1
a556 1
			esis_config();
d576 1
a576 1
 * SIDE EFFECTS:	
d578 1
a578 1
 * NOTES:			
d580 1
d582 1
a582 1
register struct rtentry *sc;
a583 2
	register struct iso_addr *r;
	register struct sockaddr_dl *sdl = (struct sockaddr_dl *)sc->rt_gateway;
d593 1
a593 1
	rt = rtalloc1((struct sockaddr *)&zsi, 0);
d596 1
a596 1
		    RTF_DYNAMIC|RTF_GATEWAY, 0);
d598 1
a598 1
		if ((rt->rt_flags & RTF_DYNAMIC) && 
d607 1
a607 1
 * PURPOSE:			Time out snpac entries
d609 1
a609 1
 * RETURNS:			
d611 1
a611 1
 * SIDE EFFECTS:	
d613 11
a623 11
 * NOTES:			When encountering an entry for the first time, snpac_age
 *					may delete up to SNPAC_AGE too many seconds. Ie.
 *					if the entry is added a moment before snpac_age is
 *					called, the entry will immediately have SNPAC_AGE
 *					seconds taken off the holding time, even though
 *					it has only been held a brief moment.
 *
 *					The proper way to do this is set an expiry timeval
 *					equal to current time + holding time. Then snpac_age
 *					would time out entries where expiry date is older
 *					than the current time.
d625 1
d627 2
a628 1
snpac_age()
d630 2
a631 2
	register struct	llinfo_llc *lc, *nlc;
	register struct	rtentry *rt;
d633 1
a633 1
	timeout(snpac_age, (caddr_t)0, SNPAC_AGE * hz);
d648 2
a649 2
 * PURPOSE:			Determine if the snpa address is a multicast address
 *					of the same type as the system.
d651 1
a651 1
 * RETURNS:			true or false
d653 1
a653 1
 * SIDE EFFECTS:	
d655 3
a657 3
 * NOTES:			Used by interface drivers when not in eavesdrop mode 
 *					as interm kludge until
 *					real multicast addresses can be configured
d659 1
d661 2
a662 2
caddr_t	snpa;
u_int	len;
d665 3
a667 3
			 (!bcmp(snpa, (caddr_t)all_es_snpa, len))) ||
			((iso_systype & SNPA_IS) &&
			 (!bcmp(snpa, (caddr_t)all_is_snpa, len))));
d673 1
a673 1
 * PURPOSE:			Flush entries associated with specific ifp
d675 1
a675 1
 * RETURNS:			nothing
d677 1
a677 1
 * SIDE EFFECTS:	
d679 1
a679 1
 * NOTES:			
d681 1
d683 1
a683 1
struct ifnet	*ifp;
d685 1
a685 1
	register struct llinfo_llc	*lc;
d696 1
a696 1
 * PURPOSE:			Make a routing request
d698 1
a698 1
 * RETURNS:			nothing
d700 1
a700 1
 * SIDE EFFECTS:	
d702 2
a703 2
 * NOTES:			In the future, this should make a request of a user
 *					level routing daemon.
d705 1
d707 6
a712 6
int				req;
struct iso_addr	*host;
struct iso_addr	*gateway;
struct iso_addr	*netmask;
short			flags;
struct rtentry	**ret_nrt;
d716 2
a717 1
	IFDEBUG(D_SNPA)
d723 1
a723 1
		else 
d727 2
a728 1
	ENDDEBUG
d736 1
a736 1
		msk.siso_len = msk.siso_pad - (u_char *)&msk;
a737 1

d739 1
a739 1
	    (netmask ? sisotosa(&msk) : (struct sockaddr *)0), flags, ret_nrt);
d745 1
a745 1
 * PURPOSE:			Associate a routing entry with an snpac entry
d747 1
a747 1
 * RETURNS:			nothing
d749 1
a749 1
 * SIDE EFFECTS:	
d751 3
a753 3
 * NOTES:			If a cache entry exists for gateway, then
 *					make a routing entry (host, gateway) and associate
 *					with gateway.
d755 2
a756 2
 *					If a route already exists and is different, first delete
 *					it.
d758 2
a759 2
 *					This could be made more efficient by checking 
 *					the existing route before adding a new one.
d761 1
d763 2
a764 2
struct ifnet *ifp;
struct iso_addr	*host, *gateway, *netmask;
d773 1
a773 1
		msk.siso_len = msk.siso_pad - (u_char *)&msk;
d775 1
a775 1
		    RTF_DONE, sisotosa(&gte), 0);
d777 2
a778 2
		rtredirect(sisotosa(&dst), sisotosa(&gte), (struct sockaddr *)0,
		    RTF_DONE | RTF_HOST, sisotosa(&gte), 0);
d780 1
a780 1
#endif	/* ISO */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
