head	1.6;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.32
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.30
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.28
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.5;

1.5
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.55;	author deraadt;	state Exp;
branches
	1.3.16.1;
next	1.2;

1.2
date	96.03.04.10.36.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.17;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: tp_pcb.c,v 1.5 2003/12/10 07:22:44 itojun Exp $	*/
/*	$NetBSD: tp_pcb.c,v 1.13 1996/03/16 23:13:58 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tp_pcb.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
				Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 * This is the initialization and cleanup stuff - for the tp machine in
 * general as well as  for the individual pcbs. tp_init() is called at system
 * startup.  tp_attach() and tp_getref() are called when a socket is created.
 * tp_detach() and tp_freeref() are called during the closing stage and/or
 * when the reference timer goes off. tp_soisdisconnecting() and
 * tp_soisdisconnected() are tp-specific versions of soisconnect* and are
 * called (obviously) during the closing phase.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>

#include <netiso/argo_debug.h>
#include <netiso/tp_param.h>
#include <netiso/tp_timer.h>
#include <netiso/tp_ip.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_tpdu.h>
#include <netiso/tp_trace.h>
#include <netiso/tp_meas.h>
#include <netiso/tp_seq.h>
#include <netiso/tp_clnp.h>
#include <netiso/tp_var.h>

/*
 * ticks are in units of: 500 nano-fortnights ;-) or 500 ms or 1/2 second
 */

struct tp_conn_param tp_conn_param[] = {
	/* ISO_CLNS: TP4 CONNECTION LESS */
	{
		TP_NRETRANS,	/* short p_Nretrans;  */
		20,		/* 10 sec *//* short p_dr_ticks;  */

		20,		/* 10 sec *//* short p_cc_ticks; */
		20,		/* 10 sec *//* short p_dt_ticks; */

		40,		/* 20 sec *//* short p_x_ticks;	 */
		80,		/* 40 sec *//* short p_cr_ticks; */

		240,		/* 2 min *//* short p_keepalive_ticks; */
		10,		/* 5 sec *//* short p_sendack_ticks;  */

		600,		/* 5 min *//* short p_ref_ticks;	 */
		360,		/* 3 min *//* short p_inact_ticks;	 */

		(short) 100,	/* short p_lcdtfract */
		(short) TP_SOCKBUFSIZE,	/* short p_winsize */
		TP_TPDUSIZE,	/* u_char p_tpdusize */

		TPACK_WINDOW,	/* 4 bits p_ack_strat */
		TPRX_USE_CW | TPRX_FASTSTART,
		/* 4 bits p_rx_strat */
		TP_CLASS_4 | TP_CLASS_0,	/* 5 bits p_class */
		1,		/* 1 bit xtd format */
		1,		/* 1 bit xpd service */
		1,		/* 1 bit use_checksum */
		0,		/* 1 bit use net xpd */
		0,		/* 1 bit use rcc */
		0,		/* 1 bit use efc */
		1,		/* no disc indications */
		0,		/* don't change params */
		ISO_CLNS,	/* p_netservice */
	},
	/* IN_CLNS: TP4 CONNECTION LESS */
	{
		TP_NRETRANS,	/* short p_Nretrans;  */
		20,		/* 10 sec *//* short p_dr_ticks;  */

		20,		/* 10 sec *//* short p_cc_ticks; */
		20,		/* 10 sec *//* short p_dt_ticks; */

		40,		/* 20 sec *//* short p_x_ticks;	 */
		80,		/* 40 sec *//* short p_cr_ticks; */

		240,		/* 2 min *//* short p_keepalive_ticks; */
		10,		/* 5 sec *//* short p_sendack_ticks;  */

		600,		/* 5 min *//* short p_ref_ticks;	 */
		360,		/* 3 min *//* short p_inact_ticks;	 */

		(short) 100,	/* short p_lcdtfract */
		(short) TP_SOCKBUFSIZE,	/* short p_winsize */
		TP_TPDUSIZE,	/* u_char p_tpdusize */

		TPACK_WINDOW,	/* 4 bits p_ack_strat */
		TPRX_USE_CW | TPRX_FASTSTART,
		/* 4 bits p_rx_strat */
		TP_CLASS_4,	/* 5 bits p_class */
		1,		/* 1 bit xtd format */
		1,		/* 1 bit xpd service */
		1,		/* 1 bit use_checksum */
		0,		/* 1 bit use net xpd */
		0,		/* 1 bit use rcc */
		0,		/* 1 bit use efc */
		1,		/* no disc indications */
		0,		/* don't change params */
		IN_CLNS,	/* p_netservice */
	},
	/* ISO_CONS: TP0 CONNECTION MODE */
	{
		TP_NRETRANS,	/* short p_Nretrans;  */
		0,		/* n/a *//* short p_dr_ticks; */

		40,		/* 20 sec *//* short p_cc_ticks; */
		0,		/* n/a *//* short p_dt_ticks; */

		0,		/* n/a *//* short p_x_ticks;	 */
		360,		/* 3  min *//* short p_cr_ticks; */

		0,		/* n/a *//* short p_keepalive_ticks; */
		0,		/* n/a *//* short p_sendack_ticks; */

		600,		/* for cr/cc to clear *//* short p_ref_ticks;	 */
		0,		/* n/a *//* short p_inact_ticks;	 */

		/*
		 * Use tp4 defaults just in case the user changes ONLY the
		 * class
		 */
		(short) 100,	/* short p_lcdtfract */
		(short) TP0_SOCKBUFSIZE,	/* short p_winsize */
		TP0_TPDUSIZE,	/* 8 bits p_tpdusize */

		0,		/* 4 bits p_ack_strat */
		0,		/* 4 bits p_rx_strat */
		TP_CLASS_0,	/* 5 bits p_class */
		0,		/* 1 bit xtd format */
		0,		/* 1 bit xpd service */
		0,		/* 1 bit use_checksum */
		0,		/* 1 bit use net xpd */
		0,		/* 1 bit use rcc */
		0,		/* 1 bit use efc */
		0,		/* no disc indications */
		0,		/* don't change params */
		ISO_CONS,	/* p_netservice */
	},
	/* ISO_COSNS: TP4 CONNECTION LESS SERVICE over CONSNS */
	{
		TP_NRETRANS,	/* short p_Nretrans;  */
		40,		/* 20 sec *//* short p_dr_ticks;  */

		40,		/* 20 sec *//* short p_cc_ticks; */
		80,		/* 40 sec *//* short p_dt_ticks; */

		120,		/* 1 min *//* short p_x_ticks;	 */
		360,		/* 3 min *//* short p_cr_ticks; */

		360,		/* 3 min *//* short p_keepalive_ticks; */
		20,		/* 10 sec *//* short p_sendack_ticks;  */

		600,		/* 5 min *//* short p_ref_ticks;	 */
		480,		/* 4 min *//* short p_inact_ticks;	 */

		(short) 100,	/* short p_lcdtfract */
		(short) TP0_SOCKBUFSIZE,	/* short p_winsize */
		TP0_TPDUSIZE,	/* u_char p_tpdusize */

		TPACK_WINDOW,	/* 4 bits p_ack_strat */
		TPRX_USE_CW,	/* No fast start */
		/* 4 bits p_rx_strat */
		TP_CLASS_4 | TP_CLASS_0,	/* 5 bits p_class */
		0,		/* 1 bit xtd format */
		1,		/* 1 bit xpd service */
		1,		/* 1 bit use_checksum */
		0,		/* 1 bit use net xpd */
		0,		/* 1 bit use rcc */
		0,		/* 1 bit use efc */
		0,		/* no disc indications */
		0,		/* don't change params */
		ISO_COSNS,	/* p_netservice */
	},
};

#ifdef INET
struct inpcbtable tp_inpcb;
#endif				/* INET */
#ifdef ISO
struct isopcb   tp_isopcb;
#endif				/* ISO */
#ifdef TPCONS
struct isopcb   tp_isopcb;
#endif				/* TPCONS */


struct nl_protosw nl_protosw[] = {
	/* ISO_CLNS */
#ifdef ISO
	{AF_ISO, iso_putnetaddr, iso_getnetaddr, iso_cmpnetaddr,
		iso_putsufx, iso_getsufx,
		iso_recycle_tsuffix,
		tpclnp_mtu, iso_pcbbind, iso_pcbconnect,
		iso_pcbdisconnect, iso_pcbdetach,
		iso_pcballoc,
		tpclnp_output, tpclnp_output_dg, iso_nlctloutput,
		(caddr_t) & tp_isopcb,
	},
#else
	{0},
#endif				/* ISO */
	/* IN_CLNS */
#ifdef INET
	{AF_INET, in_putnetaddr, in_getnetaddr, in_cmpnetaddr,
		in_putsufx, in_getsufx,
		in_recycle_tsuffix,
		tpip_mtu, in_pcbbind, in_pcbconnect,
		in_pcbdisconnect, in_pcbdetach,
		in_pcballoc,
		tpip_output, tpip_output_dg, /* nl_ctloutput */ NULL,
		(caddr_t) & tp_inpcb,
	},
#else
	{0},
#endif				/* INET */
	/* ISO_CONS */
#if defined(ISO) && defined(TPCONS)
	{AF_ISO, iso_putnetaddr, iso_getnetaddr, iso_cmpnetaddr,
		iso_putsufx, iso_getsufx,
		iso_recycle_tsuffix,
		tpclnp_mtu, iso_pcbbind, tpcons_pcbconnect,
		iso_pcbdisconnect, iso_pcbdetach,
		iso_pcballoc,
		tpcons_output, tpcons_output, iso_nlctloutput,
		(caddr_t) & tp_isopcb,
	},
#else
	{0},
#endif				/* ISO_CONS */
	/* End of protosw marker */
	{0}
};

u_long          tp_sendspace = 1024 * 4;
u_long          tp_recvspace = 1024 * 4;

/*
 * NAME:  tp_init()
 *
 * CALLED FROM:
 *  autoconf through the protosw structure
 *
 * FUNCTION:
 *  initialize tp machine
 *
 * RETURNS:  Nada
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_init()
{
	static int      init_done = 0;

	if (init_done++)
		return;

	/* FOR INET */
	in_pcbinit(&tp_inpcb, 1);
	/* FOR ISO */
	tp_isopcb.isop_next = tp_isopcb.isop_prev = &tp_isopcb;

	tp_start_win = 2;

	tp_timerinit();
	bzero((caddr_t) & tp_stat, sizeof(struct tp_stat));
}

/*
 * NAME: 	tp_soisdisconnecting()
 *
 * CALLED FROM:
 *  tp.trans
 *
 * FUNCTION and ARGUMENTS:
 *  Set state of the socket (so) to reflect that fact that we're disconnectING
 *
 * RETURNS: 	Nada
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 *  This differs from the regular soisdisconnecting() in that the latter
 *  also sets the SS_CANTRECVMORE and SS_CANTSENDMORE flags.
 *  We don't want to set those flags because those flags will cause
 *  a SIGPIPE to be delivered in sosend() and we don't like that.
 *  If anyone else is sleeping on this socket, wake 'em up.
 */
void
tp_soisdisconnecting(so)
	struct socket *so;
{
	soisdisconnecting(so);
	so->so_state &= ~SS_CANTSENDMORE;
#ifdef TP_PERF_MEAS
	if (DOPERF(sototpcb(so))) {
		struct tp_pcb *tpcb = sototpcb(so);
		u_int           fsufx, lsufx;

		bcopy((caddr_t) tpcb->tp_fsuffix, (caddr_t) &fsufx,
		      sizeof(u_int));
		bcopy((caddr_t) tpcb->tp_lsuffix, (caddr_t) &lsufx,
		      sizeof(u_int));

		tpmeas(tpcb->tp_lref, TPtime_close, &time, fsufx, lsufx,
		       tpcb->tp_fref);
		tpcb->tp_perf_on = 0;	/* turn perf off */
	}
#endif
}


/*
 * NAME: tp_soisdisconnected()
 *
 * CALLED FROM:
 *	tp.trans
 *
 * FUNCTION and ARGUMENTS:
 *  Set state of the socket (so) to reflect that fact that we're disconnectED
 *  Set the state of the reference structure to closed, and
 *  recycle the suffix.
 *  Start a reference timer.
 *
 * RETURNS:	Nada
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 *  This differs from the regular soisdisconnected() in that the latter
 *  also sets the SS_CANTRECVMORE and SS_CANTSENDMORE flags.
 *  We don't want to set those flags because those flags will cause
 *  a SIGPIPE to be delivered in sosend() and we don't like that.
 *  If anyone else is sleeping on this socket, wake 'em up.
 */
void
tp_soisdisconnected(tpcb)
	struct tp_pcb *tpcb;
{
	struct socket *so = tpcb->tp_sock;

	soisdisconnecting(so);
	so->so_state &= ~SS_CANTSENDMORE;
#ifdef TP_PERF_MEAS
	if (DOPERF(tpcb)) {
		struct tp_pcb *ttpcb = sototpcb(so);
		u_int           fsufx, lsufx;

		/* CHOKE */
		bcopy((caddr_t) ttpcb->tp_fsuffix, (caddr_t) &fsufx,
		      sizeof(u_int));
		bcopy((caddr_t) ttpcb->tp_lsuffix, (caddr_t) &lsufx,
		      sizeof(u_int));

		tpmeas(ttpcb->tp_lref, TPtime_close,
		       &time, &lsufx, &fsufx, ttpcb->tp_fref);
		tpcb->tp_perf_on = 0;	/* turn perf off */
	}
#endif

	tpcb->tp_refstate = REF_FROZEN;
	tp_recycle_tsuffix(tpcb);
	tp_etimeout(tpcb, TM_reference, (int) tpcb->tp_refer_ticks);
}

/*
 * NAME:	tp_freeref()
 *
 * CALLED FROM:
 *  tp.trans when the reference timer goes off, and
 *  from tp_attach() and tp_detach() when a tpcb is partially set up but not
 *  set up enough to have a ref timer set for it, and it's discarded
 *  due to some sort of error or an early close()
 *
 * FUNCTION and ARGUMENTS:
 *  Frees the reference represented by (r) for re-use.
 *
 * RETURNS: Nothing
 *
 * SIDE EFFECTS:
 *
 * NOTES:	better be called at clock priority !!!!!
 */
void
tp_freeref(n)
	RefNum          n;
{
	struct tp_ref *r = tp_ref + n;
	struct tp_pcb *tpcb;

	tpcb = r->tpr_pcb;
#ifdef ARGO_DEBUG
	if (argo_debug[D_TIMER]) {
		printf("tp_freeref called for ref %d pcb %p maxrefopen %d\n",
		       n, tpcb, tp_refinfo.tpr_maxopen);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_TIMER]) {
		tptrace(TPPTmisc, "tp_freeref ref maxrefopen pcb",
			n, tp_refinfo.tpr_maxopen, tpcb, 0);
	}
#endif
	if (tpcb == 0)
		return;
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("tp_freeref: CLEARING tpr_pcb %p\n", tpcb);
	}
#endif
	r->tpr_pcb = (struct tp_pcb *) 0;
	tpcb->tp_refstate = REF_FREE;

	for (r = tp_ref + tp_refinfo.tpr_maxopen; r > tp_ref; r--)
		if (r->tpr_pcb)
			break;
	tp_refinfo.tpr_maxopen = r - tp_ref;
	tp_refinfo.tpr_numopen--;

#ifdef ARGO_DEBUG
	if (argo_debug[D_TIMER]) {
		printf("tp_freeref ends w/ maxrefopen %d\n", tp_refinfo.tpr_maxopen);
	}
#endif
}

/*
 * NAME:  tp_getref()
 *
 * CALLED FROM:
 *  tp_attach()
 *
 * FUNCTION and ARGUMENTS:
 *  obtains the next free reference and allocates the appropriate
 *  ref structure, links that structure to (tpcb)
 *
 * RETURN VALUE:
 *	a reference number
 *  or TP_ENOREF
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
u_long
tp_getref(tpcb)
	struct tp_pcb *tpcb;
{
	struct tp_ref *r, *rlim;
	int    i;
	caddr_t         obase;
	unsigned        size;

	if (++tp_refinfo.tpr_numopen < tp_refinfo.tpr_size)
		for (r = tp_refinfo.tpr_base, rlim = r + tp_refinfo.tpr_size;
		     ++r < rlim;)	/* tp_ref[0] is never used */
			if (r->tpr_pcb == 0)
				goto got_one;
	/* else have to allocate more space */

	obase = (caddr_t) tp_refinfo.tpr_base;
	size = tp_refinfo.tpr_size * sizeof(struct tp_ref);
	r = (struct tp_ref *) malloc(size + size, M_PCB, M_NOWAIT);
	if (r == 0)
		return (--tp_refinfo.tpr_numopen, TP_ENOREF);
	tp_refinfo.tpr_base = tp_ref = r;
	tp_refinfo.tpr_size *= 2;
	bcopy(obase, (caddr_t) r, size);
	free(obase, M_PCB);
	r = (struct tp_ref *) (size + (caddr_t) r);
	bzero((caddr_t) r, size);

got_one:
	r->tpr_pcb = tpcb;
	tpcb->tp_refstate = REF_OPENING;
	i = r - tp_refinfo.tpr_base;
	if (tp_refinfo.tpr_maxopen < i)
		tp_refinfo.tpr_maxopen = i;
	return (u_long) i;
}

/*
 * NAME: tp_set_npcb()
 *
 * CALLED FROM:
 *	tp_attach(), tp_route_to()
 *
 * FUNCTION and ARGUMENTS:
 *  given a tpcb, allocate an appropriate lower-lever npcb, freeing
 *  any old ones that might need re-assigning.
 */
int
tp_set_npcb(tpcb)
	struct tp_pcb *tpcb;
{
	struct socket *so = tpcb->tp_sock;
	int             error;

	if (tpcb->tp_nlproto && tpcb->tp_npcb) {
		short           so_state = so->so_state;
		so->so_state &= ~SS_NOFDREF;
		(*tpcb->tp_nlproto->nlp_pcbdetach)(tpcb->tp_npcb);
		so->so_state = so_state;
	}
	tpcb->tp_nlproto = &nl_protosw[tpcb->tp_netservice];
	/* xx_pcballoc sets so_pcb */
	error = (*tpcb->tp_nlproto->nlp_pcballoc)(so,
				    tpcb->tp_nlproto->nlp_pcblist);
	tpcb->tp_npcb = so->so_pcb;
	so->so_pcb = tpcb;
	return (error);
}
/*
 * NAME: tp_attach()
 *
 * CALLED FROM:
 *	tp_usrreq, PRU_ATTACH
 *
 * FUNCTION and ARGUMENTS:
 *  given a socket (so) and a protocol family (dom), allocate a tpcb
 *  and ref structure, initialize everything in the structures that
 *  needs to be initialized.
 *
 * RETURN VALUE:
 *  0 ok
 *  EINVAL if DEBUG(X) in is on and a disaster has occurred
 *  ENOPROTOOPT if TP hasn't been configured or if the
 *   socket wasn't created with tp as its protocol
 *  EISCONN if this socket is already part of a connection
 *  ETOOMANYREFS if ran out of tp reference numbers.
 *  E* whatever error is returned from soreserve()
 *    for from the network-layer pcb allocation routine
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
int
tp_attach(so, protocol)
	struct socket  *so;
	long            protocol;
{
	struct tp_pcb *tpcb;
	int             error = 0;
	int             dom = so->so_proto->pr_domain->dom_family;
	u_long          lref;
	extern struct tp_conn_param tp_conn_param[];

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("tp_attach:dom 0x%x so %p ", dom, so);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_CONN]) {
		tptrace(TPPTmisc, "tp_attach:dom so", dom, so, 0, 0);
	}
#endif

	if (so->so_pcb != NULL) {
		return EISCONN;	/* socket already part of a connection */
	}
	if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0)
		error = soreserve(so, tp_sendspace, tp_recvspace);
	/* later an ioctl will allow reallocation IF still in closed state */

	if (error)
		goto bad2;

	MALLOC(tpcb, struct tp_pcb *, sizeof(*tpcb), M_PCB, M_NOWAIT);
	if (tpcb == NULL) {
		error = ENOBUFS;
		goto bad2;
	}
	bzero((caddr_t) tpcb, sizeof(struct tp_pcb));

	if (((lref = tp_getref(tpcb)) & TP_ENOREF) != 0) {
		error = ETOOMANYREFS;
		goto bad3;
	}
	tpcb->tp_lref = lref;
	tpcb->tp_sock = so;
	tpcb->tp_domain = dom;
	tpcb->tp_rhiwat = so->so_rcv.sb_hiwat;
	/* tpcb->tp_proto = protocol; someday maybe? */
	if (protocol && protocol < ISOPROTO_TP4) {
		tpcb->tp_netservice = ISO_CONS;
		tpcb->tp_snduna = (SeqNum) - 1;	/* kludge so the pseudo-ack
						 * from the CR/CC will
						 * generate correct fake-ack
						 * values */
	} else {
		tpcb->tp_netservice = (dom == AF_INET) ? IN_CLNS : ISO_CLNS;
		/* the default */
	}
	tpcb->_tp_param = tp_conn_param[tpcb->tp_netservice];

	tpcb->tp_state = TP_CLOSED;
	tpcb->tp_vers = TP_VERSION;
	tpcb->tp_notdetached = 1;

	/*
	 * Spec says default is 128 octets, that is, if the tpdusize argument
	 * never appears, use 128. As the initiator, we will always "propose"
	 * the 2048 size, that is, we will put this argument in the CR
	 * always, but accept what the other side sends on the CC. If the
	 * initiator sends us something larger on a CR, we'll respond w/
	 * this. Our maximum is 4096.  See tp_chksum.c comments.
	 */
	tpcb->tp_cong_win =
		tpcb->tp_l_tpdusize = 1 << tpcb->tp_tpdusize;

	tpcb->tp_seqmask = TP_NML_FMT_MASK;
	tpcb->tp_seqbit = TP_NML_FMT_BIT;
	tpcb->tp_seqhalf = tpcb->tp_seqbit >> 1;

	/* attach to a network-layer protoswitch */
	if ((error = tp_set_npcb(tpcb)) != 0)
		goto bad4;
	ASSERT(tpcb->tp_nlproto->nlp_afamily == tpcb->tp_domain);

	/* nothing to do for iso case */
	if (dom == AF_INET)
		sotoinpcb(so)->inp_ppcb = (caddr_t) tpcb;

	return 0;

bad4:
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("BAD4 in tp_attach, so %p\n", so);
	}
#endif
	tp_freeref(tpcb->tp_lref);

bad3:
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("BAD3 in tp_attach, so %p\n", so);
	}
#endif

	free((caddr_t) tpcb, M_PCB);	/* never a cluster  */

bad2:
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("BAD2 in tp_attach, so %p\n", so);
	}
#endif
	so->so_pcb = 0;

	/* bad: */
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("BAD in tp_attach, so %p\n", so);
	}
#endif
	return error;
}

/*
 * NAME:  tp_detach()
 *
 * CALLED FROM:
 *	tp.trans, on behalf of a user close request
 *  and when the reference timer goes off
 * (if the disconnect  was initiated by the protocol entity
 * rather than by the user)
 *
 * FUNCTION and ARGUMENTS:
 *  remove the tpcb structure from the list of active or
 *  partially active connections, recycle all the mbufs
 *  associated with the pcb, ref structure, sockbufs, etc.
 *  Only free the ref structure if you know that a ref timer
 *  wasn't set for this tpcb.
 *
 * RETURNS:  Nada
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 *  tp_soisdisconnected() was already when this is called
 */
void
tp_detach(tpcb)
	struct tp_pcb *tpcb;
{
	struct socket *so = tpcb->tp_sock;

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("tp_detach(tpcb %p, so %p)\n",
		       tpcb, so);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_CONN]) {
		tptraceTPCB(TPPTmisc, "tp_detach tpcb so lsufx",
			    tpcb, so, *(u_short *) (tpcb->tp_lsuffix), 0);
	}
#endif

#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
		printf("so_snd at %p so_rcv at %p\n", &so->so_snd, &so->so_rcv);
		dump_mbuf(so->so_snd.sb_mb, "so_snd at detach ");
		printf("about to call LL detach, nlproto %p, nl_detach %p\n",
		       tpcb->tp_nlproto, tpcb->tp_nlproto->nlp_pcbdetach);
	}
#endif

	if (tpcb->tp_Xsnd.sb_mb) {
		printf("Unsent Xdata on detach; would panic");
		sbflush(&tpcb->tp_Xsnd);
	}
	if (tpcb->tp_ucddata)
		m_freem(tpcb->tp_ucddata);

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("reassembly info cnt %d rsyq %p\n",
		       tpcb->tp_rsycnt, tpcb->tp_rsyq);
	}
#endif
	if (tpcb->tp_rsyq)
		tp_rsyflush(tpcb);

	if (tpcb->tp_next) {
		remque(tpcb);
		tpcb->tp_next = tpcb->tp_prev = 0;
	}
	tpcb->tp_notdetached = 0;

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("calling (...nlproto->...)(%p, so %p)\n",
		       tpcb->tp_npcb, so);
		printf("so %p so_head %p,  qlen %d q0len %d qlimit %d\n",
		       so, so->so_head,
		       so->so_q0len, so->so_qlen, so->so_qlimit);
	}
#endif

	(*tpcb->tp_nlproto->nlp_pcbdetach)(tpcb->tp_npcb);
	/* does an so->so_pcb = 0; sofree(so) */

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("after xxx_pcbdetach\n");
	}
#endif

	if (tpcb->tp_state == TP_LISTENING) {
		struct tp_pcb **tt;
		for (tt = &tp_listeners; *tt; tt = &((*tt)->tp_nextlisten))
			if (*tt == tpcb)
				break;
		if (*tt)
			*tt = tpcb->tp_nextlisten;
		else
			printf("tp_detach from listen: should panic\n");
	}
	if (tpcb->tp_refstate == REF_OPENING) {
		/*
		 * no connection existed here so no reference timer will be
		 * called
		 */
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
			printf("SETTING ref %d to REF_FREE\n", tpcb->tp_lref);
		}
#endif

		tp_freeref(tpcb->tp_lref);
	}
#ifdef TP_PERF_MEAS
	/*
	 * Get rid of the cluster mbuf allocated for performance
	 * measurements, if there is one.  Note that tpcb->tp_perf_on says
	 * nothing about whether or not a cluster mbuf was allocated, so you
	 * have to check for a pointer to one (that is, we need the
	 * TP_PERF_MEASs around the following section of code, not the
	 * IFPERFs)
	 */
	if (tpcb->tp_p_meas) {
		struct mbuf *m = tpcb->tp_p_mbuf;
		struct mbuf    *n;
#ifdef ARGO_DEBUG
		if (argo_debug[D_PERF_MEAS]) {
			printf("freeing tp_p_meas 0x%x  ", tpcb->tp_p_meas);
		}
#endif
		free(tpcb->tp_p_meas, M_PCB);
		tpcb->tp_p_meas = 0;
	}
#endif				/* TP_PERF_MEAS */

#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("end of detach, NOT single, tpcb %p\n", tpcb);
	}
#endif
	/* free((caddr_t)tpcb, M_PCB); WHere to put this ? */
}

struct que {
	struct tp_pcb  *next;
	struct tp_pcb  *prev;
}               tp_bound_pcbs =
{
	(struct tp_pcb *) & tp_bound_pcbs, (struct tp_pcb *) & tp_bound_pcbs
};

u_short         tp_unique;

int
tp_tselinuse(tlen, tsel, siso, reuseaddr)
	int tlen;
	caddr_t         tsel;
	struct sockaddr_iso *siso;
	int reuseaddr;
{
	struct tp_pcb  *b = tp_bound_pcbs.next, *l = tp_listeners;
	struct tp_pcb *t;

	for (;;) {
		if (b != (struct tp_pcb *) & tp_bound_pcbs) {
			t = b;
			b = t->tp_next;
		} else if (l) {
			t = l;
			l = t->tp_nextlisten;
		} else
			break;
		if (tlen == t->tp_lsuffixlen && bcmp(tsel, t->tp_lsuffix, tlen) == 0) {
			if (t->tp_flags & TPF_GENERAL_ADDR) {
				if (siso == 0 || reuseaddr == 0)
					return 1;
			} else if (siso) {
				if (siso->siso_family == t->tp_domain &&
				    (*t->tp_nlproto->nlp_cmpnetaddr)(t->tp_npcb,
					(struct sockaddr *) siso, TP_LOCAL))
					return 1;
			} else if (reuseaddr == 0)
				return 1;
		}
	}
	return 0;

}


int
tp_pcbbind(v, nam)
	void *v;
	struct mbuf *nam;
{
	struct tp_pcb *tpcb = v;
	struct sockaddr_iso *siso = 0;
	int             tlen = 0, wrapped = 0;
	caddr_t         tsel = NULL;
	u_short         tutil;

	if (tpcb->tp_state != TP_CLOSED)
		return (EINVAL);
	if (nam) {
		siso = mtod(nam, struct sockaddr_iso *);
		switch (siso->siso_family) {
		default:
			return (EAFNOSUPPORT);
#ifdef ISO
		case AF_ISO:
			tlen = siso->siso_tlen;
			tsel = TSEL(siso);
			if (siso->siso_nlen == 0)
				siso = 0;
			break;
#endif
#ifdef INET
		case AF_INET:
			tsel = (caddr_t) & tutil;
			if ((tutil = satosin(siso)->sin_port) != 0)
				tlen = 2;
			if (satosin(siso)->sin_addr.s_addr == 0)
				siso = 0;
		}
#endif
	}
	if (tpcb->tp_lsuffixlen == 0) {
		if (tlen) {
			if (tp_tselinuse(tlen, tsel, siso,
				  tpcb->tp_sock->so_options & SO_REUSEADDR))
				return (EINVAL);
		} else {
			for (tsel = (caddr_t) & tutil, tlen = 2;;) {
				if (tp_unique++ < ISO_PORT_RESERVED ||
				    tp_unique > ISO_PORT_USERRESERVED) {
					if (wrapped++)
						return ESRCH;
					tp_unique = ISO_PORT_RESERVED;
				}
				tutil = htons(tp_unique);
				if (tp_tselinuse(tlen, tsel, siso, 0) == 0)
					break;
			}
			if (siso)
				switch (siso->siso_family) {
#ifdef ISO
				case AF_ISO:
					bcopy(tsel, TSEL(siso), tlen);
					siso->siso_tlen = tlen;
					break;
#endif
#ifdef INET
				case AF_INET:
					satosin(siso)->sin_port = tutil;
#endif
				}
		}
		bcopy(tsel, tpcb->tp_lsuffix, (tpcb->tp_lsuffixlen = tlen));
		insque(tpcb, &tp_bound_pcbs);
	} else {
		if (tlen || siso == 0)
			return (EINVAL);
	}
	if (siso == 0) {
		tpcb->tp_flags |= TPF_GENERAL_ADDR;
		return (0);
	}
	return (*tpcb->tp_nlproto->nlp_pcbbind)(tpcb->tp_npcb, nam);
}
@


1.5
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_pcb.c,v 1.4 2003/06/02 23:28:18 millert Exp $	*/
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_pcb.c,v 1.3 1996/04/21 22:29:55 deraadt Exp $	*/
d361 1
a361 1
	register struct socket *so;
d367 1
a367 1
		register struct tp_pcb *tpcb = sototpcb(so);
d408 1
a408 1
	register struct tp_pcb *tpcb;
d410 1
a410 1
	register struct socket *so = tpcb->tp_sock;
d416 1
a416 1
		register struct tp_pcb *ttpcb = sototpcb(so);
d458 2
a459 2
	register struct tp_ref *r = tp_ref + n;
	register struct tp_pcb *tpcb;
d517 1
a517 1
	register struct tp_pcb *tpcb;
d519 2
a520 2
	register struct tp_ref *r, *rlim;
	register int    i;
d564 1
a564 1
	register struct tp_pcb *tpcb;
d566 1
a566 1
	register struct socket *so = tpcb->tp_sock;
d613 1
a613 1
	register struct tp_pcb *tpcb;
d757 1
a757 1
	register struct tp_pcb *tpcb;
d759 1
a759 1
	register struct socket *so = tpcb->tp_sock;
d825 1
a825 1
		register struct tp_pcb **tt;
d857 1
a857 1
		register struct mbuf *m = tpcb->tp_p_mbuf;
d891 1
a891 1
	register struct sockaddr_iso *siso;
d895 1
a895 1
	register struct tp_pcb *t;
d926 2
a927 2
	register void *v;
	register struct mbuf *nam;
d929 2
a930 2
	register struct tp_pcb *tpcb = v;
	register struct sockaddr_iso *siso = 0;
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_pcb.c,v 1.2 1996/03/04 10:36:18 mickey Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3.16.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_pcb.c,v 1.3 1996/04/21 22:29:55 deraadt Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d361 1
a361 1
	struct socket *so;
d367 1
a367 1
		struct tp_pcb *tpcb = sototpcb(so);
d408 1
a408 1
	struct tp_pcb *tpcb;
d410 1
a410 1
	struct socket *so = tpcb->tp_sock;
d416 1
a416 1
		struct tp_pcb *ttpcb = sototpcb(so);
d458 2
a459 2
	struct tp_ref *r = tp_ref + n;
	struct tp_pcb *tpcb;
d517 1
a517 1
	struct tp_pcb *tpcb;
d519 2
a520 2
	struct tp_ref *r, *rlim;
	int    i;
d564 1
a564 1
	struct tp_pcb *tpcb;
d566 1
a566 1
	struct socket *so = tpcb->tp_sock;
d613 1
a613 1
	struct tp_pcb *tpcb;
d757 1
a757 1
	struct tp_pcb *tpcb;
d759 1
a759 1
	struct socket *so = tpcb->tp_sock;
d825 1
a825 1
		struct tp_pcb **tt;
d857 1
a857 1
		struct mbuf *m = tpcb->tp_p_mbuf;
d891 1
a891 1
	struct sockaddr_iso *siso;
d895 1
a895 1
	struct tp_pcb *t;
d926 2
a927 2
	void *v;
	struct mbuf *nam;
d929 2
a930 2
	struct tp_pcb *tpcb = v;
	struct sockaddr_iso *siso = 0;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tp_pcb.c,v 1.12 1996/02/13 22:11:39 christos Exp $	*/
d468 1
a468 1
		printf("tp_freeref called for ref %d pcb %x maxrefopen %d\n",
d482 1
a482 1
		printf("tp_freeref: CLEARING tpr_pcb 0x%x\n", tpcb);
d625 1
a625 1
		printf("tp_attach:dom 0x%x so 0x%x ", dom, so);
d705 1
a705 1
		printf("BAD4 in tp_attach, so 0x%x\n", so);
d713 1
a713 1
		printf("BAD3 in tp_attach, so 0x%x\n", so);
d722 1
a722 1
		printf("BAD2 in tp_attach, so 0x%x\n", so);
d730 1
a730 1
		printf("BAD in tp_attach, so 0x%x\n", so);
d767 1
a767 1
		printf("tp_detach(tpcb 0x%x, so 0x%x)\n",
d780 1
a780 1
		printf("so_snd at 0x%x so_rcv at 0x%x\n", &so->so_snd, &so->so_rcv);
d782 1
a782 1
		printf("about to call LL detach, nlproto 0x%x, nl_detach 0x%x\n",
d796 1
a796 1
		printf("reassembly info cnt %d rsyq 0x%x\n",
d811 1
a811 1
		printf("calling (...nlproto->...)(0x%x, so 0x%x)\n",
d813 1
a813 1
		printf("so 0x%x so_head 0x%x,  qlen %d q0len %d qlimit %d\n",
d875 1
a875 1
		printf("end of detach, NOT single, tpcb 0x%x\n", tpcb);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tp_pcb.c,v 1.10 1995/08/17 02:57:36 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d65 8
a72 10
/* 
 * This is the initialization and cleanup stuff - 
 * for the tp machine in general as well as  for the individual pcbs.
 * tp_init() is called at system startup.  tp_attach() and tp_getref() are
 * called when a socket is created.  tp_detach() and tp_freeref()
 * are called during the closing stage and/or when the reference timer 
 * goes off. 
 * tp_soisdisconnecting() and tp_soisdisconnected() are tp-specific 
 * versions of soisconnect*
 * and are called (obviously) during the closing phase.
d96 1
d98 2
a99 4
/* ticks are in units of: 
 * 500 nano-fortnights ;-) or
 * 500 ms or 
 * 1/2 second 
d105 2
a106 2
		TP_NRETRANS, 	/* short p_Nretrans;  */
		20,		/* 10 sec */ 	/* short p_dr_ticks;  */
d108 2
a109 2
		20,		/* 10 sec */ 	/* short p_cc_ticks; */
		20,		/* 10 sec */ 	/* short p_dt_ticks; */
d111 2
a112 2
		40,		/* 20 sec */ 	/* short p_x_ticks;	 */
		80,		/* 40 sec */ 	/* short p_cr_ticks;*/
d114 2
a115 2
		240,	/* 2 min */ 	/* short p_keepalive_ticks;*/
		10,		/* 5 sec */ 	/* short p_sendack_ticks;  */
d117 2
a118 2
		600,	/* 5 min */ 	/* short p_ref_ticks;	*/
		360,	/* 3 min */ 	/* short p_inact_ticks;	*/
d120 1
a120 1
		(short) 100, 			/* short p_lcdtfract */
d122 1
a122 1
		TP_TPDUSIZE, 			/* u_char p_tpdusize */
d124 13
a136 13
		TPACK_WINDOW, 			/* 4 bits p_ack_strat */
		TPRX_USE_CW | TPRX_FASTSTART, 
								/* 4 bits p_rx_strat*/
		TP_CLASS_4 | TP_CLASS_0,/* 5 bits p_class */
		1,						/* 1 bit xtd format */
		1,						/* 1 bit xpd service */
		1,						/* 1 bit use_checksum */
		0,						/* 1 bit use net xpd */
		0,						/* 1 bit use rcc */
		0,						/* 1 bit use efc */
		1,						/* no disc indications */
		0,						/* don't change params */
		ISO_CLNS,				/* p_netservice */
d140 2
a141 2
		TP_NRETRANS, 	/* short p_Nretrans;  */
		20,		/* 10 sec */ 	/* short p_dr_ticks;  */
d143 2
a144 2
		20,		/* 10 sec */ 	/* short p_cc_ticks; */
		20,		/* 10 sec */ 	/* short p_dt_ticks; */
d146 2
a147 2
		40,		/* 20 sec */ 	/* short p_x_ticks;	 */
		80,		/* 40 sec */ 	/* short p_cr_ticks;*/
d149 2
a150 2
		240,	/* 2 min */ 	/* short p_keepalive_ticks;*/
		10,		/* 5 sec */ 	/* short p_sendack_ticks;  */
d152 2
a153 2
		600,	/* 5 min */ 	/* short p_ref_ticks;	*/
		360,	/* 3 min */ 	/* short p_inact_ticks;	*/
d155 1
a155 1
		(short) 100, 			/* short p_lcdtfract */
d157 1
a157 1
		TP_TPDUSIZE, 			/* u_char p_tpdusize */
d159 13
a171 13
		TPACK_WINDOW, 			/* 4 bits p_ack_strat */
		TPRX_USE_CW | TPRX_FASTSTART, 
								/* 4 bits p_rx_strat*/
		TP_CLASS_4,				/* 5 bits p_class */
		1,						/* 1 bit xtd format */
		1,						/* 1 bit xpd service */
		1,						/* 1 bit use_checksum */
		0,						/* 1 bit use net xpd */
		0,						/* 1 bit use rcc */
		0,						/* 1 bit use efc */
		1,						/* no disc indications */
		0,						/* don't change params */
		IN_CLNS,				/* p_netservice */
d175 2
a176 2
		TP_NRETRANS, 			/* short p_Nretrans;  */
		0,		/* n/a */		/* short p_dr_ticks; */
d178 2
a179 2
		40,		/* 20 sec */	/* short p_cc_ticks; */
		0,		/* n/a */		/* short p_dt_ticks; */
d181 2
a182 2
		0,		/* n/a */		/* short p_x_ticks;	*/
		360,	/* 3  min */	/* short p_cr_ticks;*/
d184 2
a185 2
		0,		/* n/a */		/* short p_keepalive_ticks;*/
		0,		/* n/a */		/* short p_sendack_ticks; */
d187 2
a188 2
		600,	/* for cr/cc to clear *//* short p_ref_ticks;	*/
		0,		/* n/a */		/* short p_inact_ticks;	*/
d190 3
a192 2
		/* Use tp4 defaults just in case the user changes ONLY
		 * the class 
d194 1
a194 1
		(short) 100, 			/* short p_lcdtfract */
d196 1
a196 1
		TP0_TPDUSIZE, 			/* 8 bits p_tpdusize */
d198 12
a209 12
		0, 						/* 4 bits p_ack_strat */
		0, 						/* 4 bits p_rx_strat*/
		TP_CLASS_0,				/* 5 bits p_class */
		0,						/* 1 bit xtd format */
		0,						/* 1 bit xpd service */
		0,						/* 1 bit use_checksum */
		0,						/* 1 bit use net xpd */
		0,						/* 1 bit use rcc */
		0,						/* 1 bit use efc */
		0,						/* no disc indications */
		0,						/* don't change params */
		ISO_CONS,				/* p_netservice */
d213 2
a214 2
		TP_NRETRANS, 	/* short p_Nretrans;  */
		40,		/* 20 sec */ 	/* short p_dr_ticks;  */
d216 2
a217 2
		40,		/* 20 sec */ 	/* short p_cc_ticks; */
		80,		/* 40 sec */ 	/* short p_dt_ticks; */
d219 2
a220 2
		120,		/* 1 min */ 	/* short p_x_ticks;	 */
		360,		/* 3 min */ 	/* short p_cr_ticks;*/
d222 2
a223 2
		360,	/* 3 min */ 	/* short p_keepalive_ticks;*/
		20,		/* 10 sec */ 	/* short p_sendack_ticks;  */
d225 2
a226 2
		600,	/* 5 min */ 	/* short p_ref_ticks;	*/
		480,	/* 4 min */ 	/* short p_inact_ticks;	*/
d228 1
a228 1
		(short) 100, 			/* short p_lcdtfract */
d230 1
a230 1
		TP0_TPDUSIZE, 			/* u_char p_tpdusize */
d232 13
a244 13
		TPACK_WINDOW, 			/* 4 bits p_ack_strat */
		TPRX_USE_CW ,			/* No fast start */ 
								/* 4 bits p_rx_strat*/
		TP_CLASS_4 | TP_CLASS_0,/* 5 bits p_class */
		0,						/* 1 bit xtd format */
		1,						/* 1 bit xpd service */
		1,						/* 1 bit use_checksum */
		0,						/* 1 bit use net xpd */
		0,						/* 1 bit use rcc */
		0,						/* 1 bit use efc */
		0,						/* no disc indications */
		0,						/* don't change params */
		ISO_COSNS,				/* p_netservice */
d249 2
a250 16
int		in_putnetaddr();
int		in_getnetaddr();
int		in_cmpnetaddr();
int 	in_putsufx(); 
int 	in_getsufx(); 
int 	in_recycle_tsuffix(); 
int 	tpip_mtu(); 
int 	in_pcbbind(); 
int 	in_pcbconnect(); 
int 	in_pcbdisconnect(); 
int 	in_pcbdetach(); 
int 	in_pcballoc(); 
int 	tpip_output(); 
int 	tpip_output_dg(); 
struct inpcbtable	tp_inpcb;
#endif /* INET */
d252 2
a253 17
int		iso_putnetaddr();
int		iso_getnetaddr();
int		iso_cmpnetaddr();
int 	iso_putsufx(); 
int 	iso_getsufx(); 
int 	iso_recycle_tsuffix(); 
int		tpclnp_mtu(); 
int		iso_pcbbind(); 
int		iso_pcbconnect(); 
int		iso_pcbdisconnect(); 
int 	iso_pcbdetach(); 
int 	iso_pcballoc(); 
int 	tpclnp_output(); 
int 	tpclnp_output_dg(); 
int		iso_nlctloutput();
struct isopcb	tp_isopcb;
#endif /* ISO */
d255 2
a256 15
int		iso_putnetaddr();
int		iso_getnetaddr();
int		iso_cmpnetaddr();
int 	iso_putsufx(); 
int 	iso_getsufx(); 
int 	iso_recycle_tsuffix(); 
int		iso_pcbbind(); 
int		tpcons_pcbconnect(); 
int		tpclnp_mtu();
int		iso_pcbdisconnect(); 
int 	iso_pcbdetach(); 
int 	iso_pcballoc(); 
int 	tpcons_output(); 
struct isopcb	tp_isopcb;
#endif /* TPCONS */
d262 1
a262 1
	{ AF_ISO, iso_putnetaddr, iso_getnetaddr, iso_cmpnetaddr,
d266 1
a266 1
		iso_pcbdisconnect,	iso_pcbdetach,
d269 2
a270 2
		(caddr_t) &tp_isopcb,
		},
d272 2
a273 2
	{ 0 },
#endif /* ISO */
d276 1
a276 1
	{ AF_INET, in_putnetaddr, in_getnetaddr, in_cmpnetaddr,
d280 1
a280 1
		in_pcbdisconnect,	in_pcbdetach,
d283 2
a284 2
		(caddr_t) &tp_inpcb,
		},
d286 2
a287 2
	{ 0 },
#endif /* INET */
d290 1
a290 1
	{ AF_ISO, iso_putnetaddr, iso_getnetaddr, iso_cmpnetaddr,
d294 1
a294 1
		iso_pcbdisconnect,	iso_pcbdetach,
d297 2
a298 2
		(caddr_t) &tp_isopcb,
		},
d300 2
a301 2
	{ 0 },
#endif /* ISO_CONS */
d303 1
a303 1
	{ 0 }
d306 2
a307 2
u_long tp_sendspace = 1024 * 4;
u_long tp_recvspace = 1024 * 4;
d321 1
a321 1
 * 
d327 1
a327 2
	static int 	init_done=0;
	void	 	tp_timerinit();
d333 1
a333 1
	in_pcbinit(&tp_inpcb);
d337 1
a337 1
    tp_start_win = 2;
d340 1
a340 1
	bzero((caddr_t)&tp_stat, sizeof(struct tp_stat));
d369 2
a370 1
	IFPERF(sototpcb(so))
d372 1
a372 1
		u_int 	fsufx, lsufx;
d374 10
a383 6
		bcopy ((caddr_t)tpcb->tp_fsuffix, (caddr_t)&fsufx, sizeof(u_int) );
		bcopy ((caddr_t)tpcb->tp_lsuffix, (caddr_t)&lsufx, sizeof(u_int) );

		tpmeas(tpcb->tp_lref, TPtime_close, &time, fsufx, lsufx, tpcb->tp_fref);
		tpcb->tp_perf_on = 0; /* turn perf off */
	ENDPERF
d391 1
a391 1
 *	tp.trans	
d412 1
a412 1
	register struct tp_pcb	*tpcb;
d414 1
a414 1
	register struct socket	*so = tpcb->tp_sock;
d418 2
a419 1
	IFPERF(tpcb)
d421 1
a421 1
		u_int 	fsufx, lsufx;
d424 10
a433 7
		bcopy ((caddr_t)ttpcb->tp_fsuffix, (caddr_t)&fsufx, sizeof(u_int) );
		bcopy ((caddr_t)ttpcb->tp_lsuffix, (caddr_t)&lsufx, sizeof(u_int) );

		tpmeas(ttpcb->tp_lref, TPtime_close, 
		   &time, &lsufx, &fsufx, ttpcb->tp_fref);
		tpcb->tp_perf_on = 0; /* turn perf off */
	ENDPERF
d437 1
a437 1
	tp_etimeout(tpcb, TM_reference, (int)tpcb->tp_refer_ticks);
d453 1
a453 1
 * 
d460 1
a460 1
RefNum n;
d466 8
a473 5
	IFDEBUG(D_TIMER)
		printf("tp_freeref called for ref %d pcb %x maxrefopen %d\n", 
		n, tpcb, tp_refinfo.tpr_maxopen);
	ENDDEBUG
	IFTRACE(D_TIMER)
d475 3
a477 2
		n, tp_refinfo.tpr_maxopen, tpcb, 0);
	ENDTRACE
d480 2
a481 1
	IFDEBUG(D_CONN)
d483 3
a485 2
	ENDDEBUG
	r->tpr_pcb = (struct tp_pcb *)0;
d494 2
a495 1
	IFDEBUG(D_TIMER)
d497 2
a498 1
	ENDDEBUG
d509 1
a509 1
 *  ref structure, links that structure to (tpcb) 
d520 1
a520 1
tp_getref(tpcb) 
d523 4
a526 4
	register struct tp_ref	*r, *rlim;
	register int 			i;
	caddr_t obase;
	unsigned size;
d530 1
a530 1
								++r < rlim; ) 	/* tp_ref[0] is never used */
d535 1
a535 1
	obase = (caddr_t)tp_refinfo.tpr_base;
d542 1
a542 1
	bcopy(obase, (caddr_t)r, size);
d544 2
a545 2
	r = (struct tp_ref *)(size + (caddr_t)r);
	bzero((caddr_t)r, size);
d551 1
a551 1
	if (tp_refinfo.tpr_maxopen < i) 
d553 1
a553 1
	return (u_long)i;
d566 1
d568 1
a568 1
register struct tp_pcb *tpcb;
d571 1
a571 1
	int error;
d574 1
a574 1
		short so_state = so->so_state;
d576 1
a576 1
		tpcb->tp_nlproto->nlp_pcbdetach(tpcb->tp_npcb);
d581 2
a582 1
	error = tpcb->tp_nlproto->nlp_pcballoc(so, tpcb->tp_nlproto->nlp_pcblist);
d612 1
d614 2
a615 2
	struct socket 			*so;
	long				protocol;
d617 4
a620 4
	register struct tp_pcb	*tpcb;
	int 					error = 0;
	int 					dom = so->so_proto->pr_domain->dom_family;
	u_long					lref;
d623 2
a624 1
	IFDEBUG(D_CONN)
d626 4
a629 2
	ENDDEBUG
	IFTRACE(D_CONN)
d631 2
a632 1
	ENDTRACE
d634 2
a635 2
	if (so->so_pcb != 0) { 
		return EISCONN;	/* socket already part of a connection*/
a636 1

d639 1
a639 1
		/* later an ioctl will allow reallocation IF still in closed state */
d649 1
a649 1
	bzero( (caddr_t)tpcb, sizeof (struct tp_pcb) );
d651 2
a652 2
	if ( ((lref = tp_getref(tpcb)) &  TP_ENOREF) != 0 ) { 
		error = ETOOMANYREFS; 
d656 1
a656 1
	tpcb->tp_sock =  so;
d660 1
a660 1
	if (protocol && protocol<ISOPROTO_TP4) {
d662 4
a665 3
		tpcb->tp_snduna = (SeqNum) -1;/* kludge so the pseudo-ack from the CR/CC
								 * will generate correct fake-ack values
								 */
d667 1
a667 1
		tpcb->tp_netservice = (dom== AF_INET)?IN_CLNS:ISO_CLNS;
d673 1
a673 1
	tpcb->tp_vers  = TP_VERSION;
d676 9
a684 10
		   /* Spec says default is 128 octets,
			* that is, if the tpdusize argument never appears, use 128.
			* As the initiator, we will always "propose" the 2048
			* size, that is, we will put this argument in the CR 
			* always, but accept what the other side sends on the CC.
			* If the initiator sends us something larger on a CR,
			* we'll respond w/ this.
			* Our maximum is 4096.  See tp_chksum.c comments.
			*/
	tpcb->tp_cong_win = 
d687 3
a689 3
	tpcb->tp_seqmask  = TP_NML_FMT_MASK;
	tpcb->tp_seqbit  =  TP_NML_FMT_BIT;
	tpcb->tp_seqhalf  =  tpcb->tp_seqbit >> 1;
d692 1
a692 1
	if ( error =  tp_set_npcb(tpcb))
d694 1
a694 1
	ASSERT( tpcb->tp_nlproto->nlp_afamily == tpcb->tp_domain);
d697 1
a697 1
	if( dom == AF_INET )
d703 2
a704 1
	IFDEBUG(D_CONN)
d706 2
a707 1
	ENDDEBUG
d711 2
a712 1
	IFDEBUG(D_CONN)
d714 2
a715 1
	ENDDEBUG
d717 1
a717 1
	free((caddr_t)tpcb, M_PCB); /* never a cluster  */
d720 2
a721 1
	IFDEBUG(D_CONN)
d723 2
a724 1
	ENDDEBUG
d727 3
a729 2
/*bad:*/
	IFDEBUG(D_CONN)
d731 2
a732 1
	ENDDEBUG
d742 1
a742 1
 * (if the disconnect  was initiated by the protocol entity 
d761 1
a761 1
	register struct tp_pcb 	*tpcb;
d763 1
a763 2
	void					tp_freeref(), tp_rsyflush();
	register struct socket	 *so = tpcb->tp_sock;
d765 2
a766 1
	IFDEBUG(D_CONN)
d768 9
a776 6
			tpcb,so);
	ENDDEBUG
	IFTRACE(D_CONN)
		tptraceTPCB(TPPTmisc, "tp_detach tpcb so lsufx", 
			tpcb, so, *(u_short *)(tpcb->tp_lsuffix), 0);
	ENDTRACE
d778 2
a779 1
	IFDEBUG(D_CONN)
d783 3
a785 2
				tpcb->tp_nlproto, tpcb->tp_nlproto->nlp_pcbdetach);
	ENDDEBUG
d794 2
a795 1
	IFDEBUG(D_CONN)
d797 3
a799 2
		    tpcb->tp_rsycnt, tpcb->tp_rsyq);
	ENDDEBUG
d809 9
a817 7
	IFDEBUG(D_CONN)
		printf("calling (...nlproto->...)(0x%x, so 0x%x)\n", 
			tpcb->tp_npcb, so);
		printf("so 0x%x so_head 0x%x,  qlen %d q0len %d qlimit %d\n", 
		so,  so->so_head,
		so->so_q0len, so->so_qlen, so->so_qlimit);
	ENDDEBUG
d819 2
a820 2
	(tpcb->tp_nlproto->nlp_pcbdetach)(tpcb->tp_npcb);
				/* does an so->so_pcb = 0; sofree(so) */
d822 2
a823 1
	IFDEBUG(D_CONN)
d825 2
a826 1
	ENDDEBUG
d838 7
a844 3
	if (tpcb->tp_refstate == REF_OPENING ) {
		/* no connection existed here so no reference timer will be called */
		IFDEBUG(D_CONN)
d846 2
a847 1
		ENDDEBUG
d852 7
a858 6
	/* 
	 * Get rid of the cluster mbuf allocated for performance measurements, if
	 * there is one.  Note that tpcb->tp_perf_on says nothing about whether or 
	 * not a cluster mbuf was allocated, so you have to check for a pointer 
	 * to one (that is, we need the TP_PERF_MEASs around the following section 
	 * of code, not the IFPERFs)
d861 4
a864 1
		IFDEBUG(D_PERF_MEAS)
d866 2
a867 1
		ENDDEBUG
d871 1
a871 1
#endif /* TP_PERF_MEAS */
d873 5
a877 3
	IFDEBUG(D_CONN)
		printf( "end of detach, NOT single, tpcb 0x%x\n", tpcb);
	ENDDEBUG
d882 6
a887 4
	struct tp_pcb *next;
	struct tp_pcb *prev;
} tp_bound_pcbs =
{(struct tp_pcb *)&tp_bound_pcbs, (struct tp_pcb *)&tp_bound_pcbs};
d889 1
a889 1
u_short tp_unique;
d891 1
d893 4
a896 2
caddr_t tsel;
register struct sockaddr_iso *siso;
d898 1
a898 1
	struct tp_pcb *b = tp_bound_pcbs.next, *l = tp_listeners;
d902 3
a904 2
		if (b != (struct tp_pcb *)&tp_bound_pcbs) {
			t = b; b = t->tp_next;
d906 2
a907 1
			t = l; l = t->tp_nextlisten;
d916 3
a918 2
					t->tp_nlproto->nlp_cmpnetaddr(t->tp_npcb, siso, TP_LOCAL))
						return 1;
d920 1
a920 1
						return 1;
d928 4
a931 3
tp_pcbbind(tpcb, nam)
register struct tp_pcb *tpcb;
register struct mbuf *nam;
d933 1
d935 3
a937 3
	int tlen = 0, wrapped = 0;
	caddr_t tsel;
	u_short tutil;
d956 2
a957 2
			tsel = (caddr_t)&tutil;
			if (tutil = satosin(siso)->sin_port)
d967 1
a967 1
								tpcb->tp_sock->so_options & SO_REUSEADDR))
d970 1
a970 1
			for (tsel = (caddr_t)&tutil, tlen = 2;;){
d972 4
a975 4
					tp_unique > ISO_PORT_USERRESERVED) {
						if (wrapped++)
							return ESRCH;
						tp_unique = ISO_PORT_RESERVED;
d981 2
a982 1
			if (siso) switch (siso->siso_family) {
d1005 1
a1005 1
	return tpcb->tp_nlproto->nlp_pcbbind(tpcb->tp_npcb, nam);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
