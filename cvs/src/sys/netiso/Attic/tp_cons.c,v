head	1.12;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.22
	OPENBSD_2_8:1.2.0.20
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.18
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.16
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.14
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.12
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.10
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.8
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.12
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.11;

1.11
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.05.22.32.40;	author deraadt;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.06.27.03.49.54;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.25.01.50.17;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.27.12.26.05;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.10.35.51;	author mickey;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.16;	author deraadt;	state Exp;
branches;
next	;

1.2.16.1
date	2001.07.04.10.55.37;	author niklas;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.2.16.4;

1.2.16.4
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.2.16.5;

1.2.16.5
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	;


desc
@@


1.12
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: tp_cons.c,v 1.11 2004/01/03 14:08:54 espie Exp $	*/
/*	$NetBSD: tp_cons.c,v 1.8 1996/02/14 21:32:37 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tp_cons.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 * Here is where you find the iso- and cons-dependent code.  We've tried keep
 * all net-level and (primarily) address-family-dependent stuff out of the tp
 * source, and everthing here is reached indirectly through a switch table
 * (struct nl_protosw *) tpcb->tp_nlproto (see tp_pcb.c). The routines here
 * are: tpcons_input: pullup and call tp_input w/ correct arguments
 * tpcons_output: package a pkt for cons given an isopcb & some data
 * cons_chan_to_tpcb: find a tpcb based on the channel #
 */

#ifdef ISO
#ifdef TPCONS

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/domain.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/route.h>

#include <netiso/tp_param.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_trace.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_tpdu.h>
#include <netiso/iso.h>
#include <netiso/iso_errno.h>
#include <netiso/iso_pcb.h>
#include <netiso/iso_var.h>
#include <netiso/cons.h>
#include <netiso/tp_seq.h>
#include <netiso/tp_var.h>
#include <netiso/clnp.h>

#undef FALSE
#undef TRUE
#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

#include <sys/stdarg.h>

#include <netiso/if_cons.c>


/*
 * CALLED FROM:
 *  tp_route_to() for PRU_CONNECT
 * FUNCTION, ARGUMENTS, SIDE EFFECTS and RETURN VALUE:
 *  version of the previous procedure for X.25
 */

int
tpcons_pcbconnect(v, nam)
	void *v;
	struct mbuf *nam;
{
	struct isopcb  *isop = v;
	int             error;
	if ((error = iso_pcbconnect(isop, nam)) != 0)
		return error;
	if ((isop->isop_chan = (caddr_t) pk_attach((struct socket *) 0)) == 0) {
#ifdef ARGO_DEBUG
		if (argo_debug[D_CCONS]) {
			printf("tpcons_pcbconnect: no pklcd; returns 0x%x\n", error);
		}
#endif
		return ENOBUFS;
	}
	if ((error = cons_connect(isop)) != 0) {	/* if it doesn't work */
		/* oh, dear, throw packet away */
		pk_disconnect((struct pklcd *) isop->isop_chan);
		isop->isop_chan = 0;
	} else
		isop->isop_refcnt = 1;
	return error;
}


/*
 * CALLED FROM:
 * 	cons
 * FUNCTION and ARGUMENTS:
 * THIS MAYBE BELONGS IN SOME OTHER PLACE??? but i think not -
 */
void *
tpcons_ctlinput(cmd, siso, v)
	int             cmd;
	struct sockaddr *siso;
	void *v;
{
	struct isopcb  *isop = v;
	struct tp_pcb *tpcb = 0;

	if (isop->isop_socket)
		tpcb = (struct tp_pcb *) isop->isop_socket->so_pcb;
	switch (cmd) {

	case PRC_CONS_SEND_DONE:
		if (tpcb) {
			struct tp_event E;
			int             error = 0;

			if (tpcb->tp_class == TP_CLASS_0) {
				/*
				 * only if class is exactly class zero, not
				 * still in class negotiation
				 */
				/* fake an ack */
				SeqNum seq = SEQ_ADD(tpcb, tpcb->tp_snduna, 1);

#ifdef TPPT
				if(tp_traceflags[D_DATA])
					tptrace(TPPTmisc, "FAKE ACK seq cdt 1",
						seq, 0, 0, 0);
#endif
#ifdef ARGO_DEBUG
					if (argo_debug[D_DATA]) {
					printf("FAKE ACK seq 0x%x cdt 1\n", seq);
				}
#endif
				E.TP_ATTR(AK_TPDU).e_cdt = 1;
				E.TP_ATTR(AK_TPDU).e_seq = seq;
				E.TP_ATTR(AK_TPDU).e_subseq = 0;
				E.TP_ATTR(AK_TPDU).e_fcc_present = 0;
				error = DoEvent(AK_TPDU);
				if (error) {
					tpcb->tp_sock->so_error = error;
				}
			}	/* else ignore it */
		}
		break;
	case PRC_ROUTEDEAD:
		if (tpcb && tpcb->tp_class == TP_CLASS_0) {
			tpiso_reset(isop);
			break;
		}		/* else drop through */
	default:
		tpclnp_ctlinput(cmd, siso, NULL);
		break;
	}
	return NULL;
}

/*
 * CALLED FROM:
 * 	cons's intr routine
 * FUNCTION and ARGUMENTS:
 * Take a packet (m) from cons, pullup m as required by tp,
 *  ignore the socket argument, and call tp_input.
 * No return value.
 */
void
tpcons_input(struct mbuf *m, ...)
{
	struct sockaddr *faddr, *laddr;
	caddr_t         channel;
	va_list ap;
	if (m == NULL)
		return;
	va_start(ap, m);
	faddr = va_arg(ap, struct sockaddr *);
	laddr = va_arg(ap, struct sockaddr *);
	channel = va_arg(ap, caddr_t);
	va_end(ap);

	m = (struct mbuf *) tp_inputprep(m);

#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tpcons_input before tp_input(m 0x%x)\n", m);
		dump_buf(m, 12 + m->m_len);
	}
#endif
	tp_input(m, faddr, laddr, channel, tpcons_output, 0);
}


/*
 * CALLED FROM:
 *  tp_emit()
 * FUNCTION and ARGUMENTS:
 *  Take a packet(m0) from tp and package it so that cons will accept it.
 *  This means filling in a few of the fields.
 *  inp is the isopcb structure; datalen is the length of the data in the
 *  mbuf string m0.
 * RETURN VALUE:
 *  whatever (E*) is returned form the net layer output routine.
 */

int
tpcons_output(struct mbuf *m0, ...)
{
	struct isopcb  *isop;
	int             datalen;
	int             nochksum;
	struct mbuf *m = m0;
	int             error;
	va_list		ap;

	va_start(ap, m0);
	datalen = va_arg(ap, int);
	isop = va_arg(ap, struct isopcb *);
	nochksum = va_arg(ap, int);
	va_end(ap);

#ifdef ARGO_DEBUG
	if (argo_debug[D_EMIT]) {
		printf(
		  "tpcons_output(isop 0x%x, m 0x%x, len 0x%x socket 0x%x\n",
		       isop, m0, datalen, isop->isop_socket);
	}
#endif
	if (m == NULL)
		return 0;
	if ((m->m_flags & M_PKTHDR) == 0) {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == 0)
			return ENOBUFS;
		M_MOVE_HDR(m, m0);
		m->m_next = m0;
	}
	m->m_pkthdr.len = datalen;
	if (isop->isop_chan == 0) {
		/* got a restart maybe? */
		if ((isop->isop_chan = (caddr_t) pk_attach((struct socket *) 0)) == 0) {
#ifdef ARGO_DEBUG
			if (argo_debug[D_CCONS]) {
				printf("tpcons_output: no pklcd\n");
			}
#endif
			error = ENOBUFS;
		}
		if ((error = cons_connect(isop)) != 0) {
			pk_disconnect((struct pklcd *) isop->isop_chan);
			isop->isop_chan = 0;
#ifdef ARGO_DEBUG
			if (argo_debug[D_CCONS]) {
				printf("tpcons_output: can't reconnect\n");
			}
#endif
		}
	} else {
		error = pk_send(m, isop->isop_chan);
		IncStat(ts_tpdu_sent);
	}
	return error;
}
/*
 * CALLED FROM:
 *  tp_error_emit()
 * FUNCTION and ARGUMENTS:
 *  Take a packet(m0) from tp and package it so that cons will accept it.
 *  chan is the cons channel to use; datalen is the length of the data in the
 *  mbuf string m0.
 * RETURN VALUE:
 *  whatever (E*) is returned form the net layer output routine.
 */

int
tpcons_output_dg(struct mbuf *m0, ...)
{
	int             datalen;
	caddr_t         chan;
	va_list		ap;

	va_start(ap, m0);
	datalen = va_arg(ap, int);
	chan = va_arg(ap, caddr_t);
	va_end(ap);

	return tpcons_output(m0, datalen,
			     ((struct pklcd *) chan)->lcd_upnext, 
			     0);
}
#else

#include <sys/param.h>

struct mbuf;

int tpcons_output(struct mbuf *m0, ...);

int
tpcons_output(struct mbuf *m0, ...)
{
	return 0;
}
#endif /* TPCONS */
#endif /* ISO */
@


1.11
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.10 2003/12/10 07:22:44 itojun Exp $	*/
@


1.10
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.9 2003/06/02 23:28:18 millert Exp $	*/
d108 1
a108 1
#include <machine/stdarg.h>
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.8 2002/03/15 18:19:53 millert Exp $	*/
d123 1
a123 1
	register struct mbuf *nam;
d160 1
a160 1
	register struct tp_pcb *tpcb = 0;
d177 1
a177 1
				register SeqNum seq = SEQ_ADD(tpcb, tpcb->tp_snduna, 1);
d264 1
a264 1
	register struct mbuf *m = m0;
@


1.8
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.7 2002/03/14 01:27:12 millert Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.6 2001/09/05 22:32:40 deraadt Exp $	*/
a224 1
#if __STDC__
a225 5
#else
tpcons_input(m, va_alist)
	struct mbuf    *m;
	va_dcl
#endif
a262 1
#if __STDC__
a263 5
#else
tpcons_output(m0, va_alist)
	struct mbuf    *m0;
	va_dcl
#endif
a331 1
#if __STDC__
a332 5
#else
tpcons_output_dg(m0, va_alist)
	struct mbuf    *m0;
	va_dcl
#endif
a355 1
#if __STDC__
a356 5
#else
tpcons_output(m0, va_alist)
	struct mbuf    *m0;
	va_dcl
#endif
@


1.6
log
@make sure that va_start() has matching va_end()
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.5 2001/06/27 03:49:54 angelos Exp $	*/
d371 1
a371 1
int tpcons_output __P((struct mbuf *m0, ...));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.6 2001/09/05 22:32:40 deraadt Exp $	*/
d225 1
d227 5
d269 1
d271 5
d344 1
d346 5
d371 1
a371 1
int tpcons_output(struct mbuf *m0, ...);
d374 1
d376 5
@


1.5
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.4 2001/06/25 01:50:17 fgsch Exp $	*/
d242 1
a242 1

@


1.4
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.3 2001/05/27 12:26:05 angelos Exp $	*/
d303 1
a303 1
		M_COPY_HDR(m, m0);
@


1.3
log
@More tag fixups (why do I bother with this...)
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.2 1996/03/04 10:35:51 mickey Exp $	*/
a303 2
		m_tag_init(m0);
		m0->m_flags &= ~M_PKTHDR;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d303 3
@


1.2.16.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.2 1996/03/04 10:35:51 mickey Exp $	*/
a302 1
		M_MOVE_HDR(m, m0);
@


1.2.16.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.2.16.1 2001/07/04 10:55:37 niklas Exp $	*/
d242 1
a242 1
	va_end(ap);
@


1.2.16.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d225 1
d227 5
d269 1
d271 5
d344 1
d346 5
d371 1
a371 1
int tpcons_output(struct mbuf *m0, ...);
d374 1
d376 5
@


1.2.16.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_cons.c,v 1.2.16.3 2002/03/28 14:57:37 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.16.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
#include <sys/stdarg.h>
d123 1
a123 1
	struct mbuf *nam;
d160 1
a160 1
	struct tp_pcb *tpcb = 0;
d177 1
a177 1
				SeqNum seq = SEQ_ADD(tpcb, tpcb->tp_snduna, 1);
d264 1
a264 1
	struct mbuf *m = m0;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tp_cons.c,v 1.6 1994/06/29 06:39:59 cgd Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d65 8
a72 10
/* 
 * Here is where you find the iso- and cons-dependent code.  We've tried
 * keep all net-level and (primarily) address-family-dependent stuff
 * out of the tp source, and everthing here is reached indirectly
 * through a switch table (struct nl_protosw *) tpcb->tp_nlproto 
 * (see tp_pcb.c). 
 * The routines here are:
 *	tpcons_input: pullup and call tp_input w/ correct arguments
 *	tpcons_output: package a pkt for cons given an isopcb & some data
 *	cons_chan_to_tpcb: find a tpcb based on the channel #
d79 1
d99 1
d102 2
d110 3
d115 1
a115 1
int tpcons_output();
d124 4
a127 3
tpcons_pcbconnect(isop, nam)
struct isopcb *isop;
register struct mbuf *nam;
d129 3
a131 2
	int error;
	if (error = iso_pcbconnect(isop, nam))
d133 3
a135 2
	if ((isop->isop_chan = (caddr_t) pk_attach((struct socket *)0)) == 0) {
		IFDEBUG(D_CCONS)
d137 2
a138 1
		ENDDEBUG
d141 1
a141 1
	if (error = cons_connect(isop)) { /* if it doesn't work */
d143 1
a143 1
		pk_disconnect((struct pklcd *)isop->isop_chan);
d145 1
a145 1
	} else 
d157 5
a161 5
void
tpcons_ctlinput(cmd, siso, isop)
	int cmd; 
	struct sockaddr_iso *siso;
	struct isopcb *isop;
d163 1
d167 1
a167 1
		tpcb = (struct tp_pcb *)isop->isop_socket->so_pcb;
d172 2
a173 2
			struct 	tp_event 		E;
			int 					error = 0;
d176 2
a177 1
				/* only if class is exactly class zero, not
d181 1
a181 1
				register SeqNum	seq =  SEQ_ADD(tpcb, tpcb->tp_snduna, 1);
d183 16
a198 13
				IFTRACE(D_DATA)
					tptrace(TPPTmisc, "FAKE ACK seq cdt 1", 
						seq, 0,0,0);
				ENDTRACE
				IFDEBUG(D_DATA)
					printf("FAKE ACK seq 0x%x cdt 1\n", seq );
				ENDDEBUG
				E.ATTR(AK_TPDU).e_cdt = 1;
				E.ATTR(AK_TPDU).e_seq = seq;
				E.ATTR(AK_TPDU).e_subseq = 0;
				E.ATTR(AK_TPDU).e_fcc_present = 0;
				error =  DoEvent(AK_TPDU);
				if( error ) {
d201 1
a201 1
			} /* else ignore it */
d208 1
a208 1
		} /* else drop through */
d210 1
a210 1
		tpclnp_ctlinput(cmd, siso);
d213 1
d221 2
a222 2
 *  ignore the socket argument, and call tp_input. 
 * No return value.  
d225 7
a231 4
tpcons_input(m, faddr, laddr, channel)
	struct mbuf 		*m;
	struct sockaddr_iso	*faddr, *laddr;
	caddr_t				channel;
d233 4
a236 1
	if( m == MNULL)
d238 4
a242 1
	m = (struct mbuf *)tp_inputprep(m);
d244 4
a247 1
	IFDEBUG(D_TPINPUT)
d249 3
a251 2
		dump_buf( m, 12+ m->m_len);
	ENDDEBUG
d269 7
a275 5
tpcons_output(isop, m0, datalen, nochksum)
	struct isopcb		*isop;
	struct mbuf 		*m0;
	int 				datalen;
	int					nochksum;
d277 12
a288 2
	register	struct mbuf *m = m0;
	int					error;
d290 2
a291 1
	IFDEBUG(D_EMIT)
d293 5
a297 4
		"tpcons_output(isop 0x%x, m 0x%x, len 0x%x socket 0x%x\n",
			isop, m0, datalen, isop->isop_socket);
	ENDDEBUG
	if (m == MNULL)
d308 3
a310 2
		if ((isop->isop_chan = (caddr_t) pk_attach((struct socket *)0)) == 0) {
			IFDEBUG(D_CCONS)
d312 2
a313 1
			ENDDEBUG
d316 2
a317 2
		if (error = cons_connect(isop)) {
			pk_disconnect((struct pklcd *)isop->isop_chan);
d319 2
a320 1
			IFDEBUG(D_CCONS)
d322 2
a323 1
			ENDDEBUG
d326 1
a326 1
		error = pk_send(isop->isop_chan, m);
d343 37
a379 4
tpcons_dg_output(chan, m0, datalen)
	caddr_t				chan;
	struct mbuf 		*m0;
	int 				datalen;
d381 1
a381 1
	return tpcons_output(((struct pklcd *)chan)->lcd_upnext, m0, datalen, 0);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
