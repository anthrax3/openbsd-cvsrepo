head	1.10;
access;
symbols
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.6
	UBC:1.3.0.26
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.24
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.22
	OPENBSD_2_8:1.3.0.20
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.18
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.16
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.14
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.12
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.10
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.8
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2004.07.15.12.10.46;	author henning;	state dead;
branches;
next	1.9;

1.9
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.29.06.26.51;	author pvalchev;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.59;	author deraadt;	state Exp;
branches
	1.3.16.1
	1.3.26.1;
next	1.2;

1.2
date	96.03.04.10.36.32;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.17;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.17;	author deraadt;	state Exp;
branches;
next	;

1.3.16.1
date	2002.03.28.14.57.38;	author niklas;	state Exp;
branches;
next	1.3.16.2;

1.3.16.2
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.3.16.3;

1.3.16.3
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.16.4;

1.3.16.4
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.3.26.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	1.3.26.2;

1.3.26.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.3.26.3;

1.3.26.3
date	2003.05.19.22.41.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.10
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: tp_subr2.c,v 1.9 2003/12/10 07:22:44 itojun Exp $	*/
/*	$NetBSD: tp_subr2.c,v 1.11 1996/03/26 22:27:01 christos Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tp_subr2.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 * Some auxiliary routines: tp_protocol_error: required by xebec- called when
 * a combo of state, event, predicate isn't covered for by the transition
 * file. tp_indicate: gives indications(signals) to the user process
 * tp_getoptions: initializes variables that are affected by the options
 * chosen.
 */

/*
 * this def'n is to cause the expansion of this macro in the routine
 * tp_local_credit :
 */
#define LOCAL_CREDIT_EXPAND

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_types.h>

#include <netiso/argo_debug.h>
#include <netiso/tp_param.h>
#include <netiso/tp_ip.h>
#include <netiso/iso.h>
#include <netiso/iso_errno.h>
#include <netiso/iso_pcb.h>
#include <netiso/iso_var.h>
#include <netiso/tp_timer.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_tpdu.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_seq.h>
#include <netiso/tp_trace.h>
#include <netiso/tp_user.h>
#include <netiso/tp_var.h>
#include <netiso/cons.h>
#include <netiso/clnp.h>


#ifdef TRUE
#undef MNULL
#undef FALSE
#undef TRUE
#endif

#include <netccitt/x25.h>
#include <netccitt/pk.h>
#include <netccitt/pk_var.h>
#include <netccitt/pk_extern.h>

#if 0
static void copyQOSparms(struct tp_conn_param *, struct tp_conn_param *);
#endif

/*
 * NAME: 	tp_local_credit()
 *
 * CALLED FROM:
 *  tp_emit(), tp_usrreq()
 *
 * FUNCTION and ARGUMENTS:
 *	Computes the local credit and stashes it in tpcb->tp_lcredit.
 *  It's a macro in the production system rather than a procdure.
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 *  This doesn't actually get called in a production system -
 *  the macro gets expanded instead in place of calls to this proc.
 *  But for debugging, we call this and that allows us to add
 *  debugging messages easily here.
 */
void
tp_local_credit(tpcb)
	struct tp_pcb  *tpcb;
{
	LOCAL_CREDIT(tpcb);
#ifdef ARGO_DEBUG
	if (argo_debug[D_CREDIT]) {
		printf("ref 0x%x lcdt 0x%x l_tpdusize 0x%x decbit 0x%x cong_win 0x%lx\n",
		       tpcb->tp_lref,
		       tpcb->tp_lcredit,
		       tpcb->tp_l_tpdusize,
		       tpcb->tp_decbit,
		       tpcb->tp_cong_win
			);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_CREDIT]) {
		tptraceTPCB(TPPTmisc,
			    "lcdt tpdusz \n",
			    tpcb->tp_lcredit, tpcb->tp_l_tpdusize, 0, 0);
	}
#endif
}

/*
 * NAME:  tp_protocol_error()
 *
 * CALLED FROM:
 *  tp_driver(), when it doesn't know what to do with
 * 	a combo of event, state, predicate
 *
 * FUNCTION and ARGUMENTS:
 *  print error mesg
 *
 * RETURN VALUE:
 *  EIO - always
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
int
tp_protocol_error(e, tpcb)
	struct tp_event *e;
	struct tp_pcb  *tpcb;
{
	printf("TP PROTOCOL ERROR! tpcb %p event 0x%x, state 0x%x\n",
	       tpcb, e->ev_number, tpcb->tp_state);
#ifdef TPPT
	if (tp_traceflags[D_DRIVER]) {
		tptraceTPCB(TPPTmisc, "PROTOCOL ERROR tpcb event state",
			    tpcb, e->ev_number, tpcb->tp_state, 0);
	}
#endif
	return EIO;	/* for lack of anything better */
}


/* Not used at the moment */
void
tp_drain()
{
}


/*
 * NAME: tp_indicate()
 *
 * CALLED FROM:
 * 	tp.trans when XPD arrive, when a connection is being disconnected by
 *  the arrival of a DR or ER, and when a connection times out.
 *
 * FUNCTION and ARGUMENTS:
 *  (ind) is the type of indication : T_DISCONNECT, T_XPD
 *  (error) is an E* value that will be put in the socket structure
 *  to be passed along to the user later.
 * 	Gives a SIGURG to the user process or group indicated by the socket
 * 	attached to the tpcb.
 *
 * RETURNS:  Rien
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_indicate(ind, tpcb, error)
	int             ind;
	u_short         error;
	struct tp_pcb *tpcb;
{
	struct socket *so = tpcb->tp_sock;
#ifdef TPPT
	if (tp_traceflags[D_INDICATION]) {
		tptraceTPCB(TPPTindicate, ind, *(u_short *) (tpcb->tp_lsuffix),
		       *(u_short *) (tpcb->tp_fsuffix), error, so->so_pgid);
	}
#endif
#ifdef ARGO_DEBUG
	if (argo_debug[D_INDICATION]) {
		char           *ls, *fs;
		ls = tpcb->tp_lsuffix,
			fs = tpcb->tp_fsuffix,

			printf(
			       "indicate 0x%x lsuf 0x%02x%02x fsuf 0x%02x%02x err 0x%x  noind 0x%x ref 0x%x\n",
			       ind,
			       *ls, *(ls + 1), *fs, *(fs + 1),
			       error,	/* so->so_pgrp, */
			       tpcb->tp_no_disc_indications,
			       tpcb->tp_lref);
	}
#endif

	if (ind == ER_TPDU) {
		struct mbuf *m;
		struct tp_disc_reason x;

		if ((so->so_state & SS_CANTRCVMORE) == 0 &&
		    (m = m_get(M_DONTWAIT, MT_OOBDATA)) != 0) {

			x.dr_hdr.cmsg_len = m->m_len = sizeof(x);
			x.dr_hdr.cmsg_level = SOL_TRANSPORT;
			x.dr_hdr.cmsg_type = TPOPT_DISC_REASON;
			x.dr_reason = error;
			*mtod(m, struct tp_disc_reason *) = x;
			sbappendrecord(&tpcb->tp_Xrcv, m);
			error = 0;
		} else
			error = ECONNRESET;
	}
	so->so_error = error;

	if (ind == T_DISCONNECT) {
		if (error == 0)
			so->so_error = ENOTCONN;
		if (tpcb->tp_no_disc_indications)
			return;
	}
#ifdef TPPT
	if (tp_traceflags[D_INDICATION]) {
		tptraceTPCB(TPPTmisc, "doing sohasoutofband(so)", so, 0, 0, 0);
	}
#endif
	sohasoutofband(so);
}

/*
 * NAME : tp_getoptions()
 *
 * CALLED FROM:
 * 	tp.trans whenever we go into OPEN state
 *
 * FUNCTION and ARGUMENTS:
 *  sets the proper flags and values in the tpcb, to control
 *  the appropriate actions for the given class, options,
 *  sequence space, etc, etc.
 *
 * RETURNS: Nada
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_getoptions(tpcb)
	struct tp_pcb  *tpcb;
{
	tpcb->tp_seqmask =
		tpcb->tp_xtd_format ? TP_XTD_FMT_MASK : TP_NML_FMT_MASK;
	tpcb->tp_seqbit =
		tpcb->tp_xtd_format ? TP_XTD_FMT_BIT : TP_NML_FMT_BIT;
	tpcb->tp_seqhalf = tpcb->tp_seqbit >> 1;
	tpcb->tp_dt_ticks =
		max(tpcb->tp_dt_ticks, (tpcb->tp_peer_acktime + 2));
	tp_rsyset(tpcb);

}

/*
 * NAME:  tp_recycle_tsuffix()
 *
 * CALLED FROM:
 *  Called when a ref is frozen.
 *
 * FUNCTION and ARGUMENTS:
 *  allows the suffix to be reused.
 *
 * RETURNS: zilch
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_recycle_tsuffix(v)
	void *v;
{
	struct tp_pcb  *tpcb = v;
	bzero((caddr_t) tpcb->tp_lsuffix, sizeof(tpcb->tp_lsuffix));
	bzero((caddr_t) tpcb->tp_fsuffix, sizeof(tpcb->tp_fsuffix));
	tpcb->tp_fsuffixlen = tpcb->tp_lsuffixlen = 0;

	(tpcb->tp_nlproto->nlp_recycle_suffix) (tpcb->tp_npcb);
}

/*
 * NAME: tp_quench()
 *
 * CALLED FROM:
 *  tp{af}_quench() when ICMP source quench or similar thing arrives.
 *
 * FUNCTION and ARGUMENTS:
 *  Drop the congestion window back to 1.
 *  Congestion window scheme:
 *  Initial value is 1.  ("slow start" as Nagle, et. al. call it)
 *  For each good ack that arrives, the congestion window is increased
 *  by 1 (up to max size of logical infinity, which is to say,
 *	it doesn't wrap around).
 *  Source quench causes it to drop back to 1.
 *  tp_send() uses the smaller of (regular window, congestion window).
 *  One retransmission strategy option is to have any retransmission
 *	cause reset the congestion window back  to 1.
 *
 *	(cmd) is either PRC_QUENCH: source quench, or
 *		PRC_QUENCH2: dest. quench (dec bit)
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_quench(ipcb, cmd)
	struct inpcb  *ipcb;
	int             cmd;
{
	struct tp_pcb  *tpcb = (struct tp_pcb *) ipcb;
#ifdef ARGO_DEBUG
	if (argo_debug[D_QUENCH]) {
		printf("tp_quench tpcb %p ref 0x%x sufx 0x%x\n",
		       tpcb, tpcb->tp_lref, *(u_short *) (tpcb->tp_lsuffix));
		printf("cong_win 0x%lx decbit 0x%x \n",
		       tpcb->tp_cong_win, tpcb->tp_decbit);
	}
#endif
	switch (cmd) {
	case PRC_QUENCH:
		tpcb->tp_cong_win = tpcb->tp_l_tpdusize;
		IncStat(ts_quench);
		break;
	case PRC_QUENCH2:
		/* might as well quench source also */
		tpcb->tp_cong_win = tpcb->tp_l_tpdusize;
		tpcb->tp_decbit = TP_DECBIT_CLEAR_COUNT;
		IncStat(ts_rcvdecbit);
		break;
	}
}


/*
 * NAME:	tp_netcmd()
 *
 * CALLED FROM:
 *
 * FUNCTION and ARGUMENTS:
 *
 * RETURNS:
 *
 * SIDE EFFECTS:
 *
 * NOTES:
 */
void
tp_netcmd(tpcb, cmd)
	struct tp_pcb  *tpcb;
	int             cmd;
{
#ifdef TPCONS
	struct isopcb  *isop;
	struct pklcd   *lcp;

	if (tpcb->tp_netservice != ISO_CONS)
		return;
	isop = (struct isopcb *) tpcb->tp_npcb;
	lcp = (struct pklcd *) isop->isop_chan;
	switch (cmd) {

	case CONN_CLOSE:
	case CONN_REFUSE:
		if (isop->isop_refcnt == 1) {
			/*
			 * This is really superfluous, since it would happen
			 * anyway in iso_pcbdetach, although it is a courtesy
			 * to free up the x.25 channel before the refwait
			 * timer expires.
			 */
			lcp->lcd_upper = 0;
			lcp->lcd_upnext = 0;
			pk_disconnect(lcp);
			isop->isop_chan = 0;
			isop->isop_refcnt = 0;
		}
		break;

	default:
		printf("tp_netcmd(0x%x, 0x%x) NOT IMPLEMENTED\n", tpcb, cmd);
		break;
	}
#else				/* TPCONS */
	printf("tp_netcmd(): X25 NOT CONFIGURED!!\n");
#endif
}

/*
 * CALLED FROM:
 *  tp_ctloutput() and tp_emit()
 * FUNCTION and ARGUMENTS:
 * 	Convert a class mask to the highest numeric value it represents.
 */
int
tp_mask_to_num(x)
	u_char          x;
{
	int    j;

	for (j = 4; j >= 0; j--) {
		if (x & (1 << j))
			break;
	}
	ASSERT((j == 4) || (j == 0));	/* for now */
	if ((j != 4) && (j != 0)) {
		printf("ASSERTION ERROR: tp_mask_to_num: x 0x%x j %d\n",
		       x, j);
	}
#ifdef TPPT
	if (tp_traceflags[D_TPINPUT]) {
		tptrace(TPPTmisc, "tp_mask_to_num(x) returns j", x, j, 0, 0);
	}
#endif
#ifdef ARGO_DEBUG
	if (argo_debug[D_TPINPUT]) {
		printf("tp_mask_to_num(0x%x) returns 0x%x\n", x, j);
	}
#endif
	return j;
}

#if 0
static void
copyQOSparms(src, dst)
	struct tp_conn_param *src, *dst;
{
	/* copy all but the bits stuff at the end */
#define COPYSIZE (12 * sizeof(short))

	bcopy((caddr_t) src, (caddr_t) dst, COPYSIZE);
	dst->p_tpdusize = src->p_tpdusize;
	dst->p_ack_strat = src->p_ack_strat;
	dst->p_rx_strat = src->p_rx_strat;
#undef COPYSIZE
}
#endif

/*
 * Determine a reasonable value for maxseg size.
 * If the route is known, check route for mtu.
 * We also initialize the congestion/slow start
 * window to be a single segment if the destination isn't local.
 * While looking at the routing entry, we also initialize other path-dependent
 * parameters from pre-set or cached values in the routing entry.
 */
void
tp_mss(tpcb, nhdr_size)
	struct tp_pcb *tpcb;
	int             nhdr_size;
{
	struct rtentry *rt;
	struct ifnet   *ifp;
	int    rtt, mss;
	u_long          bufsize;
	int             i, ssthresh = 0, rt_mss;
	struct socket  *so;

	if (tpcb->tp_ptpdusize)
		mss = tpcb->tp_ptpdusize << 7;
	else
		mss = 1 << tpcb->tp_tpdusize;
	so = tpcb->tp_sock;
	if ((rt = *(tpcb->tp_routep)) == 0) {
		bufsize = so->so_rcv.sb_hiwat;
		goto punt_route;
	}
	ifp = rt->rt_ifp;

#ifdef RTV_MTU			/* if route characteristics exist ... */
	/*
	 * While we're here, check if there's an initial rtt
	 * or rttvar.  Convert from the route-table units
	 * to hz ticks for the smoothed timers and slow-timeout units
	 * for other initial variables.
	 */
	if (tpcb->tp_rtt == 0 && (rtt = rt->rt_rmx.rmx_rtt)) {
		tpcb->tp_rtt = rtt * hz / RTM_RTTUNIT;
		if (rt->rt_rmx.rmx_rttvar)
			tpcb->tp_rtv = rt->rt_rmx.rmx_rttvar
				* hz / RTM_RTTUNIT;
		else
			tpcb->tp_rtv = tpcb->tp_rtt;
	}
	/*
	 * if there's an mtu associated with the route, use it
	 */
	if (rt->rt_rmx.rmx_mtu)
		rt_mss = rt->rt_rmx.rmx_mtu - nhdr_size;
	else
#endif				/* RTV_MTU */
		rt_mss = (ifp->if_mtu - nhdr_size);
	if (tpcb->tp_ptpdusize == 0 ||	/* assume application doesn't care */
	    mss > rt_mss /* network won't support what was asked for */ )
		mss = rt_mss;
	/* can propose mtu which are multiples of 128 */
	mss &= ~0x7f;
	/*
	 * If there's a pipesize, change the socket buffer
	 * to that size.
	 */
#ifdef RTV_SPIPE
	if ((bufsize = rt->rt_rmx.rmx_sendpipe) > 0) {
#endif
		bufsize = min(bufsize, so->so_snd.sb_hiwat);
		(void) sbreserve(&so->so_snd, bufsize);
	}
#ifdef RTV_SPIPE
	if ((bufsize = rt->rt_rmx.rmx_recvpipe) > 0) {
#endif
		bufsize = min(bufsize, so->so_rcv.sb_hiwat);
		(void) sbreserve(&so->so_rcv, bufsize);
	} else
		bufsize = so->so_rcv.sb_hiwat;
#ifdef RTV_SSTHRESH
	/*
	 * There's some sort of gateway or interface
	 * buffer limit on the path.  Use this to set
	 * the slow start threshhold, but set the
	 * threshold to no less than 2*mss.
	 */
	ssthresh = rt->rt_rmx.rmx_ssthresh;
punt_route:
	/*
	 * The current mss is initialized to the default value.
	 * If we compute a smaller value, reduce the current mss.
	 * If we compute a larger value, return it for use in sending
	 * a max seg size option.
	 * If we received an offer, don't exceed it.
	 * However, do not accept offers under 128 bytes.
	 */
	if (tpcb->tp_l_tpdusize)
		mss = min(mss, tpcb->tp_l_tpdusize);
	/*
	 * We want a minimum recv window of 4 packets to
	 * signal packet loss by duplicate acks.
	 */
	mss = min(mss, bufsize >> 2) & ~0x7f;
	mss = max(mss, 128);	/* sanity */
	tpcb->tp_cong_win =
		(rt == 0 || (rt->rt_flags & RTF_GATEWAY)) ? mss : bufsize;
	tpcb->tp_l_tpdusize = mss;
	tp_rsyset(tpcb);
	tpcb->tp_ssthresh = max(2 * mss, ssthresh);
	/* Calculate log2 of mss */
	for (i = TP_MIN_TPDUSIZE + 1; i <= TP_MAX_TPDUSIZE; i++)
		if ((1 << i) > mss)
			break;
	i--;
	tpcb->tp_tpdusize = i;
#endif	/* RTV_MTU */
}

/*
 * CALLED FROM:
 *  tp_usrreq on PRU_CONNECT and tp_input on receipt of CR
 *
 * FUNCTION and ARGUMENTS:
 * 	-- An mbuf containing the peer's network address.
 *  -- Our control block, which will be modified
 *  -- In the case of cons, a control block for that layer.
 *
 *
 * RETURNS:
 *	errno value	 :
 *	EAFNOSUPPORT if can't find an nl_protosw for x.25 (really could panic)
 *	ECONNREFUSED if trying to run TP0 with non-type 37 address
 *  possibly other E* returned from cons_netcmd()
 *
 * SIDE EFFECTS:
 *   Determines recommended tpdusize, buffering and initial delays
 *	 based on information cached on the route.
 */
int
tp_route_to(m, tpcb, channel)
	struct mbuf    *m;
	struct tp_pcb *tpcb;
	caddr_t         channel;
{
	struct sockaddr_iso *siso;	/* NOTE: this may be a
						 * sockaddr_in */
	int             error = 0, save_netservice = tpcb->tp_netservice;
	struct rtentry *rt = 0;
	int             nhdr_size;

	siso = mtod(m, struct sockaddr_iso *);
#ifdef TPPT
	if (tp_traceflags[D_CONN]) {
		tptraceTPCB(TPPTmisc,
			    "route_to: so  afi netservice class",
	tpcb->tp_sock, siso->siso_addr.isoa_genaddr[0], tpcb->tp_netservice,
			    tpcb->tp_class);
	}
#endif
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
		printf("tp_route_to( m %p, channel %p, tpcb %p netserv 0x%x)\n",
		       m, channel, tpcb, tpcb->tp_netservice);
		printf("m->mlen x%x, m->m_data:\n", m->m_len);
		dump_buf(mtod(m, caddr_t), m->m_len);
	}
#endif
	if (channel) {
#ifdef TPCONS
		struct pklcd   *lcp = (struct pklcd *) channel;
		struct isopcb  *isop = (struct isopcb *) lcp->lcd_upnext,
		               *isop_new = (struct isopcb *) tpcb->tp_npcb;
		/*
		 * The next 2 lines believe that you haven't set any network
		 * level options or done a pcbconnect and XXXXXXX'edly apply
		 * to both inpcb's and isopcb's
		 */
		remque(isop_new);
		free(isop_new, M_PCB);
		tpcb->tp_npcb = (caddr_t) isop;
		tpcb->tp_netservice = ISO_CONS;
		tpcb->tp_nlproto = nl_protosw + ISO_CONS;
		if (isop->isop_refcnt++ == 0) {
			iso_putsufx(isop, tpcb->tp_lsuffix,
				    tpcb->tp_lsuffixlen, TP_LOCAL);
			isop->isop_socket = tpcb->tp_sock;
		}
#endif
	} else {
		switch (siso->siso_family) {
		default:
			error = EAFNOSUPPORT;
			goto done;
#ifdef ISO
		case AF_ISO:
			{
				struct isopcb  *isop = (struct isopcb *) tpcb->tp_npcb;
				int             flags = tpcb->tp_sock->so_options & SO_DONTROUTE;
				tpcb->tp_netservice = ISO_CLNS;
				if (clnp_route(&siso->siso_addr, &isop->isop_route,
				    flags, NULL, NULL) == 0) {
					rt = isop->isop_route.ro_rt;
					if (rt && rt->rt_flags & RTF_PROTO1)
						tpcb->tp_netservice = ISO_CONS;
				}
			} break;
#endif
#ifdef INET
		case AF_INET:
			tpcb->tp_netservice = IN_CLNS;
#endif
		}
		if (tpcb->tp_nlproto->nlp_afamily != siso->siso_family) {
#ifdef ARGO_DEBUG
			if (argo_debug[D_CONN]) {
				printf("tp_route_to( CHANGING nlproto old 0x%x new 0x%x)\n",
				       save_netservice, tpcb->tp_netservice);
			}
#endif
			if ((error = tp_set_npcb(tpcb)) != 0)
				goto done;
		}
#ifdef ARGO_DEBUG
		if (argo_debug[D_CONN]) {
			printf("tp_route_to  calling nlp_pcbconn, netserv %d\n",
			       tpcb->tp_netservice);
		}
#endif
		tpcb->tp_nlproto = nl_protosw + tpcb->tp_netservice;
		error = (*tpcb->tp_nlproto->nlp_pcbconn) (tpcb->tp_npcb, m);
	}
	if (error)
		goto done;
	/* only gets common info */
	nhdr_size = (*tpcb->tp_nlproto->nlp_mtu)(tpcb);
	tp_mss(tpcb, nhdr_size);
done:
#ifdef ARGO_DEBUG
	if (argo_debug[D_CONN]) {
		printf("tp_route_to  returns 0x%x\n", error);
	}
#endif
#ifdef TPPT
	if (tp_traceflags[D_CONN]) {
		tptraceTPCB(TPPTmisc, "route_to: returns: error netserv class", error,
			    tpcb->tp_netservice, tpcb->tp_class, 0);
	}
#endif
	return error;
}

#ifndef CCITT
void
pk_flowcontrol(lcp, foo, bar)
	struct pklcd *lcp;
	int foo, bar;
{
}
#endif

/* class zero version */
void
tp0_stash(tpcb, e)
	struct tp_pcb *tpcb;
	struct tp_event *e;
{
#define E e->TPDU_ATTR(DT)

	struct sockbuf *sb = &tpcb->tp_sock->so_rcv;
	struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;

#ifdef TP_PERF_MEAS
	if (DOPERF(tpcb)) {
		PStat(tpcb, Nb_from_ll) += E.e_datalen;
	tpmeas(tpcb->tp_lref, TPtime_from_ll, &e->e_time,
	       E.e_seq, PStat(tpcb, Nb_from_ll), E.e_datalen);
	}
#endif

#ifdef ARGO_DEBUG
		if (argo_debug[D_STASH]) {
		printf("stash EQ: seq 0x%x datalen 0x%x eot 0x%x",
		       E.e_seq, E.e_datalen, E.e_eot);
	}
#endif

#ifdef TPPT
	if (tp_traceflags[D_STASH]) {
		tptraceTPCB(TPPTmisc, "stash EQ: seq len eot",
			    E.e_seq, E.e_datalen, E.e_eot, 0);
	}
#endif

	if (E.e_eot) {
		struct mbuf *n = E.e_data;
		n->m_flags |= M_EOR;
		n->m_act = NULL;	/* set on tp_input */
	}
	sbappend(sb, E.e_data);
#ifdef ARGO_DEBUG
	if (argo_debug[D_STASH]) {
		dump_mbuf(sb->sb_mb, "stash 0: so_rcv after appending");
	}
#endif
	if (tpcb->tp_netservice != ISO_CONS)
		printf("tp0_stash: tp running over something weird\n");
	else {
		struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
		pk_flowcontrol(lcp, sbspace(sb) <= 0, 1);
	}
}

void
tp0_openflow(tpcb)
	struct tp_pcb *tpcb;
{
	struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;
	if (tpcb->tp_netservice != ISO_CONS)
		printf("tp0_openflow: tp running over something weird\n");
	else {
		struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
		if (lcp->lcd_rxrnr_condition)
			pk_flowcontrol(lcp, 0, 0);
	}
}

#ifdef TP_PERF_MEAS
/*
 * CALLED FROM:
 *  tp_ctloutput() when the user sets TPOPT_PERF_MEAS on
 *  and tp_newsocket() when a new connection is made from
 *  a listening socket with tp_perf_on == true.
 * FUNCTION and ARGUMENTS:
 *  (tpcb) is the usual; this procedure gets a clear cluster mbuf for
 *  a tp_pmeas structure, and makes tpcb->tp_p_meas point to it.
 * RETURN VALUE:
 *  ENOBUFS if it cannot get a cluster mbuf.
 */

int
tp_setup_perf(tpcb)
	struct tp_pcb *tpcb;
{
	if (tpcb->tp_p_meas == 0) {
		tpcb->tp_p_meas = malloc(sizeof(struct tp_pmeas), M_PCB, M_WAITOK);
		bzero((caddr_t)tpcb->tp_p_meas, sizeof(struct tp_pmeas));
#ifdef ARGO_DEBUG
		if (argo_debug[D_PERF_MEAS]) {
			printf(
			       "tpcb 0x%x so 0x%x ref 0x%x tp_p_meas 0x%x tp_perf_on 0x%x\n",
			       tpcb, tpcb->tp_sock, tpcb->tp_lref,
			       tpcb->tp_p_meas, tpcb->tp_perf_on);
		}
#endif
		tpcb->tp_perf_on = 1;
	}
	return 0;
}
#endif				/* TP_PERF_MEAS */

#ifdef ARGO_DEBUG
void
dump_addr(addr)
	struct sockaddr *addr;
{
	switch (addr->sa_family) {
	case AF_INET:
		dump_inaddr(satosin(addr));
		break;
#ifdef ISO
	case AF_ISO:
		dump_isoaddr(satosiso(addr));
		break;
#endif				/* ISO */
	default:
		printf("BAD AF: 0x%x\n", addr->sa_family);
		break;
	}
}

#define	MAX_COLUMNS	8
/*
 *	Dump the buffer to the screen in a readable format. Format is:
 *
 *		hex/dec  where hex is the hex format, dec is the decimal format.
 *		columns of hex/dec numbers will be printed, followed by the
 *		character representations (if printable).
 */
void
Dump_buf(buf, len)
	caddr_t         buf;
	int             len;
{
	int             i, j;
#define Buf ((u_char *)buf)
	printf("Dump buf %p len 0x%x\n", buf, len);
	for (i = 0; i < len; i += MAX_COLUMNS) {
		printf("+%d:\t", i);
		for (j = 0; j < MAX_COLUMNS; j++) {
			if (i + j < len) {
				printf("%x/%d\t", Buf[i + j], Buf[i + j]);
			} else {
				printf("	");
			}
		}

		for (j = 0; j < MAX_COLUMNS; j++) {
			if (i + j < len) {
				if (((Buf[i + j]) > 31) && ((Buf[i + j]) < 128))
					printf("%c", Buf[i + j]);
				else
					printf(".");
			}
		}
		printf("\n");
	}
}
#endif /* ARGO_DEBUG */
@


1.9
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.8 2003/06/02 23:28:18 millert Exp $	*/
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.7 2003/02/18 13:14:43 jmc Exp $	*/
d234 1
a234 1
	register struct tp_pcb *tpcb;
d236 1
a236 1
	register struct socket *so = tpcb->tp_sock;
d260 1
a260 1
		register struct mbuf *m;
d471 1
a471 1
	register int    j;
d521 1
a521 1
	register struct tp_pcb *tpcb;
d524 1
a524 1
	register struct rtentry *rt;
d526 1
a526 1
	register int    rtt, mss;
d649 1
a649 1
	register struct tp_pcb *tpcb;
d652 1
a652 1
	register struct sockaddr_iso *siso;	/* NOTE: this may be a
d655 1
a655 1
	register struct rtentry *rt = 0;
d771 2
a772 2
	register struct tp_pcb *tpcb;
	register struct tp_event *e;
d776 2
a777 2
	register struct sockbuf *sb = &tpcb->tp_sock->so_rcv;
	register struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;
d802 1
a802 1
		register struct mbuf *n = E.e_data;
d815 1
a815 1
		register struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
d822 1
a822 1
	register struct tp_pcb *tpcb;
d824 1
a824 1
	register struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;
d828 1
a828 1
		register struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
d849 1
a849 1
	register struct tp_pcb *tpcb;
d871 1
a871 1
	register struct sockaddr *addr;
@


1.7
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.6 2002/07/02 19:38:55 nate Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.5 2002/04/29 06:26:51 pvalchev Exp $	*/
d647 1
a647 1
 *   Determines recommended tpdusize, buffering and intial delays
@


1.5
log
@wierd -> weird
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.4 2002/03/14 01:27:12 millert Exp $	*/
d551 1
a551 1
	 * for other inital variables.
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.3 1996/04/21 22:29:59 deraadt Exp $	*/
d817 1
a817 1
		printf("tp0_stash: tp running over something wierd\n");
d830 1
a830 1
		printf("tp0_openflow: tp running over something wierd\n");
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.2 1996/03/04 10:36:32 mickey Exp $	*/
d125 1
a125 1
static void copyQOSparms __P((struct tp_conn_param *, struct tp_conn_param *));
@


1.3.26.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.3 1996/04/21 22:29:59 deraadt Exp $	*/
d125 1
a125 1
static void copyQOSparms(struct tp_conn_param *, struct tp_conn_param *);
d817 1
a817 1
		printf("tp0_stash: tp running over something weird\n");
d830 1
a830 1
		printf("tp0_openflow: tp running over something weird\n");
@


1.3.26.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.3.26.1 2002/06/11 03:31:38 art Exp $	*/
d551 1
a551 1
	 * for other initial variables.
@


1.3.26.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d647 1
a647 1
 *   Determines recommended tpdusize, buffering and initial delays
@


1.3.16.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
a125 1
static void copyQOSparms(struct tp_conn_param *, struct tp_conn_param *);
@


1.3.16.2
log
@Sync the SMP branch with 3.3
@
text
@d551 1
a551 1
	 * for other initial variables.
d647 1
a647 1
 *   Determines recommended tpdusize, buffering and initial delays
d817 1
a817 1
		printf("tp0_stash: tp running over something weird\n");
d830 1
a830 1
		printf("tp0_openflow: tp running over something weird\n");
@


1.3.16.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tp_subr2.c,v 1.3.16.2 2003/03/28 00:06:55 niklas Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.16.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d234 1
a234 1
	struct tp_pcb *tpcb;
d236 1
a236 1
	struct socket *so = tpcb->tp_sock;
d260 1
a260 1
		struct mbuf *m;
d471 1
a471 1
	int    j;
d521 1
a521 1
	struct tp_pcb *tpcb;
d524 1
a524 1
	struct rtentry *rt;
d526 1
a526 1
	int    rtt, mss;
d649 1
a649 1
	struct tp_pcb *tpcb;
d652 1
a652 1
	struct sockaddr_iso *siso;	/* NOTE: this may be a
d655 1
a655 1
	struct rtentry *rt = 0;
d771 2
a772 2
	struct tp_pcb *tpcb;
	struct tp_event *e;
d776 2
a777 2
	struct sockbuf *sb = &tpcb->tp_sock->so_rcv;
	struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;
d802 1
a802 1
		struct mbuf *n = E.e_data;
d815 1
a815 1
		struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
d822 1
a822 1
	struct tp_pcb *tpcb;
d824 1
a824 1
	struct isopcb *isop = (struct isopcb *) tpcb->tp_npcb;
d828 1
a828 1
		struct pklcd *lcp = (struct pklcd *) isop->isop_chan;
d849 1
a849 1
	struct tp_pcb *tpcb;
d871 1
a871 1
	struct sockaddr *addr;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: tp_subr2.c,v 1.9 1996/02/13 22:12:04 christos Exp $	*/
a126 3
#if 0
static void pk_flowcontrol __P((struct pklcd *, int, int));
#endif
d155 1
a155 1
		printf("ref 0x%x lcdt 0x%x l_tpdusize 0x%x decbit 0x%x\n",
d195 1
a195 1
	printf("TP PROTOCOL ERROR! tpcb 0x%x event 0x%x, state 0x%x\n",
d390 1
a390 1
		printf("tp_quench tpcb 0x%x ref 0x%x sufx 0x%x\n",
d392 1
a392 1
		printf("cong_win 0x%x decbit 0x%x \n",
d673 1
a673 1
		printf("tp_route_to( m x%x, channel 0x%x, tpcb 0x%x netserv 0x%x)\n",
d763 1
a763 2
#if 0
static
d907 1
a907 1
	printf("Dump buf 0x%x len 0x%x\n", buf, len);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tp_subr2.c,v 1.8 1995/08/16 00:38:58 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d65 6
a70 7
/* 
 * Some auxiliary routines:
 * 	tp_protocol_error: required by xebec- called when a combo of state,
 *	    event, predicate isn't covered for by the transition file.
 *	tp_indicate: gives indications(signals) to the user process
 *	tp_getoptions: initializes variables that are affected by the options
 *	    chosen.
d73 3
a75 2
/* this def'n is to cause the expansion of this macro in the
 * routine tp_local_credit :
d89 4
a93 1
#undef MNULL
d100 1
d108 1
d110 2
a112 2
#include <net/if.h>
#include <net/if_types.h>
d114 1
d118 1
d122 1
d124 6
a129 1
void tp_rsyset();
d146 1
a146 1
 *  This doesn't actually get called in a production system - 
d153 1
a153 1
	struct tp_pcb *tpcb;
d156 2
a157 1
	IFDEBUG(D_CREDIT)
d159 5
a163 5
			tpcb->tp_lref, 
			tpcb->tp_lcredit, 
			tpcb->tp_l_tpdusize, 
			tpcb->tp_decbit, 
			tpcb->tp_cong_win
d165 4
a168 2
	ENDDEBUG
	IFTRACE(D_CREDIT)
d170 4
a173 3
			"lcdt tpdusz \n",
			 tpcb->tp_lcredit, tpcb->tp_l_tpdusize, 0, 0);
	ENDTRACE
d184 1
a184 1
 *  print error mesg 
d194 3
a196 3
tp_protocol_error(e,tpcb)
	struct tp_event	*e;
	struct tp_pcb	*tpcb;
d199 3
a201 2
		tpcb, e->ev_number, tpcb->tp_state);
	IFTRACE(D_DRIVER)
d203 4
a206 3
			tpcb, e->ev_number, tpcb->tp_state, 0 );
	ENDTRACE
	return EIO; /* for lack of anything better */
a213 1

d232 1
a232 1
 * 
d239 3
a241 3
	int				ind; 
	u_short			error;
	register struct tp_pcb	*tpcb;
d244 21
a264 17
	IFTRACE(D_INDICATION)
		tptraceTPCB(TPPTindicate, ind, *(u_short *)(tpcb->tp_lsuffix), 
			*(u_short *)(tpcb->tp_fsuffix), error,so->so_pgid);
	ENDTRACE
	IFDEBUG(D_INDICATION)
		char *ls, *fs;
		ls = tpcb->tp_lsuffix, 
		fs = tpcb->tp_fsuffix, 

		printf(
"indicate 0x%x lsuf 0x%02x%02x fsuf 0x%02x%02x err 0x%x  noind 0x%x ref 0x%x\n",
		ind, 
		*ls, *(ls+1), *fs, *(fs+1),
		error, /*so->so_pgrp,*/
		tpcb->tp_no_disc_indications,
		tpcb->tp_lref);
	ENDDEBUG
d271 1
a271 1
				(m = m_get(M_DONTWAIT, MT_OOBDATA)) != 0) {
d275 1
a275 1
			x.dr_hdr.cmsg_type= TPOPT_DISC_REASON;
d285 1
a285 1
	if (ind == T_DISCONNECT)  {
d288 1
a288 1
		if ( tpcb->tp_no_disc_indications )
d291 5
a295 3
	IFTRACE(D_INDICATION)
		tptraceTPCB(TPPTmisc, "doing sohasoutofband(so)", so,0,0,0);
	ENDTRACE
d303 1
a303 1
 * 	tp.trans whenever we go into OPEN state 
d309 1
a309 1
 * 
d311 1
a311 1
 * 
d318 1
a318 1
struct tp_pcb *tpcb;
d320 2
a321 2
	tpcb->tp_seqmask = 
		tpcb->tp_xtd_format ?	TP_XTD_FMT_MASK :	TP_NML_FMT_MASK ;
d323 1
a323 1
		tpcb->tp_xtd_format ?	TP_XTD_FMT_BIT :	TP_NML_FMT_BIT ;
d328 1
a328 1
	
d338 1
a338 1
 *  allows the suffix to be reused. 
d347 2
a348 2
tp_recycle_tsuffix(tpcb)
	struct tp_pcb	*tpcb;
d350 3
a352 2
	bzero((caddr_t)tpcb->tp_lsuffix, sizeof( tpcb->tp_lsuffix));
	bzero((caddr_t)tpcb->tp_fsuffix, sizeof( tpcb->tp_fsuffix));
d355 1
a355 1
	(tpcb->tp_nlproto->nlp_recycle_suffix)(tpcb->tp_npcb);
d369 1
a369 1
 *  by 1 (up to max size of logical infinity, which is to say, 
d372 2
a373 2
 *  tp_send() uses the smaller of (regular window, congestion window). 
 *  One retransmission strategy option is to have any retransmission 
d380 1
a380 1
 * 
d382 1
a382 1
 * 
d386 3
a388 3
tp_quench( tpcb, cmd )
	struct tp_pcb *tpcb;
	int cmd;
d390 3
a392 1
	IFDEBUG(D_QUENCH)
d394 1
a394 1
			tpcb, tpcb->tp_lref, *(u_short *)(tpcb->tp_lsuffix));
d396 14
a409 12
			tpcb->tp_cong_win, tpcb->tp_decbit);
	ENDDEBUG
	switch(cmd) {
		case PRC_QUENCH:
			tpcb->tp_cong_win = tpcb->tp_l_tpdusize;
			IncStat(ts_quench);
			break;
		case PRC_QUENCH2:
			tpcb->tp_cong_win = tpcb->tp_l_tpdusize; /* might as well quench source also */
			tpcb->tp_decbit = TP_DECBIT_CLEAR_COUNT;
			IncStat(ts_rcvdecbit);
			break;
d417 1
a417 1
 * CALLED FROM:			
d419 1
a419 1
 * FUNCTION and ARGUMENTS:			
d421 1
a421 1
 * RETURNS:			
d423 1
a423 1
 * SIDE EFFECTS:	
d425 1
a425 1
 * NOTES:			
d427 4
a430 3
tp_netcmd( tpcb, cmd )
	struct tp_pcb *tpcb;
	int cmd;
d433 2
a434 2
	struct isopcb *isop;
	struct pklcd *lcp;
d438 2
a439 2
	isop = (struct isopcb *)tpcb->tp_npcb;
	lcp = (struct pklcd *)isop->isop_chan;
d445 6
a450 4
			/* This is really superfluous, since it would happen
			   anyway in iso_pcbdetach, although it is a courtesy
			   to free up the x.25 channel before the refwait timer
			   expires. */
d463 1
a463 1
#else /* TPCONS */
d467 1
a473 1

d476 1
a476 1
	u_char x;
d478 1
a478 1
	register int j;
d480 2
a481 2
	for(j = 4; j>=0 ;j--) {
		if(x & (1<<j))
d484 2
a485 2
	ASSERT( (j == 4) || (j == 0) ); /* for now */
	if( (j != 4) && (j != 0) ) {
d487 1
a487 1
			x, j);
d489 2
a490 1
	IFTRACE(D_TPINPUT)
d492 4
a495 2
	ENDTRACE
	IFDEBUG(D_TPINPUT)
d497 2
a498 1
	ENDDEBUG
d502 2
a503 1
static 
d510 1
a510 1
	bcopy((caddr_t)src, (caddr_t)dst, COPYSIZE);
d516 2
d529 1
a529 1
	int nhdr_size;
d532 5
a536 5
	struct ifnet *ifp;
	register int rtt, mss;
	u_long bufsize;
	int i, ssthresh = 0, rt_mss;
	struct socket *so;
d549 1
a549 1
#ifdef RTV_MTU	/* if route characteristics exist ... */
d560 1
a560 1
						* hz / RTM_RTTUNIT;
d570 1
a570 1
#endif /* RTV_MTU */
d572 2
a573 2
	if (tpcb->tp_ptpdusize == 0 || /* assume application doesn't care */
	    mss > rt_mss /* network won't support what was asked for */)
d618 1
a618 1
	mss = max(mss, 128);		/* sanity */
d630 1
a630 1
#endif /* RTV_MTU */
d636 1
a636 1
 *	
d642 1
a642 1
 *	
d644 1
a644 1
 *	errno value	 : 
d654 8
a661 8
tp_route_to( m, tpcb, channel)
	struct mbuf					*m;
	register struct tp_pcb		*tpcb;
	caddr_t 					channel;
{
	register struct sockaddr_iso *siso;	/* NOTE: this may be a sockaddr_in */
	extern struct tp_conn_param tp_conn_param[];
	int error = 0, save_netservice = tpcb->tp_netservice;
d663 1
a663 1
	int nhdr_size, mtu, bufsize;
d666 12
a677 9
	IFTRACE(D_CONN)
		tptraceTPCB(TPPTmisc, 
		"route_to: so  afi netservice class",
		tpcb->tp_sock, siso->siso_addr.isoa_genaddr[0], tpcb->tp_netservice,
			tpcb->tp_class);
	ENDTRACE
	IFDEBUG(D_CONN)
		printf("tp_route_to( m x%x, channel 0x%x, tpcb 0x%x netserv 0x%x)\n", 
			m, channel, tpcb, tpcb->tp_netservice);
d680 2
a681 1
	ENDDEBUG
d684 8
a691 6
		struct pklcd *lcp = (struct pklcd *)channel;
		struct isopcb *isop = (struct isopcb *)lcp->lcd_upnext,
			*isop_new = (struct isopcb *)tpcb->tp_npcb;
		/* The next 2 lines believe that you haven't
		   set any network level options or done a pcbconnect
		   and XXXXXXX'edly apply to both inpcb's and isopcb's */
d694 1
a694 1
		tpcb->tp_npcb = (caddr_t)isop;
d698 2
a699 1
			iso_putsufx(isop, tpcb->tp_lsuffix, tpcb->tp_lsuffixlen, TP_LOCAL);
d701 1
a701 2
		} else
			/* there are already connections sharing this */;
d710 11
a720 11
		{
			struct isopcb *isop = (struct isopcb *)tpcb->tp_npcb;
			int flags = tpcb->tp_sock->so_options & SO_DONTROUTE;
			tpcb->tp_netservice = ISO_CLNS;
			if (clnp_route(&siso->siso_addr, &isop->isop_route,
							flags, (void **)0, (void **)0) == 0) {
				rt = isop->isop_route.ro_rt;
				if (rt && rt->rt_flags & RTF_PROTO1)
					tpcb->tp_netservice = ISO_CONS;
			}
		}    break;
d728 7
a734 5
			IFDEBUG(D_CONN)
				printf("tp_route_to( CHANGING nlproto old 0x%x new 0x%x)\n", 
						save_netservice, tpcb->tp_netservice);
			ENDDEBUG
			if (error = tp_set_npcb(tpcb))
d737 2
a738 1
		IFDEBUG(D_CONN)
d740 3
a742 2
				tpcb->tp_netservice);
		ENDDEBUG
d744 1
a744 1
		error = (tpcb->tp_nlproto->nlp_pcbconn)(tpcb->tp_npcb, m);
d748 2
a749 1
	nhdr_size = tpcb->tp_nlproto->nlp_mtu(tpcb); /* only gets common info */
d752 2
a753 1
	IFDEBUG(D_CONN)
d755 8
a762 5
	ENDDEBUG
	IFTRACE(D_CONN)
		tptraceTPCB(TPPTmisc, "route_to: returns: error netserv class", error, 
			tpcb->tp_netservice, tpcb->tp_class, 0);
	ENDTRACE
d766 1
a766 1
#ifndef TPCONS
d768 6
a773 1
pk_flowcontrol() {}
d778 5
a782 9
tp0_stash( tpcb, e )
	register struct tp_pcb		*tpcb;
	register struct tp_event	*e;
{
#ifndef lint
#define E e->ATTR(DT_TPDU)
#else /* lint */
#define E e->ev_union.EV_DT_TPDU
#endif /* lint */
d785 1
a785 1
	register struct isopcb *isop = (struct isopcb *)tpcb->tp_npcb;
d787 2
a788 1
	IFPERF(tpcb)
d790 18
a807 13
		tpmeas(tpcb->tp_lref, TPtime_from_ll, &e->e_time,
				E.e_seq, PStat(tpcb, Nb_from_ll), E.e_datalen);
	ENDPERF

	IFDEBUG(D_STASH)
		printf("stash EQ: seq 0x%x datalen 0x%x eot 0x%x", 
		E.e_seq, E.e_datalen, E.e_eot);
	ENDDEBUG

	IFTRACE(D_STASH)
		tptraceTPCB(TPPTmisc, "stash EQ: seq len eot", 
		E.e_seq, E.e_datalen, E.e_eot, 0);
	ENDTRACE
d809 1
a809 1
	if ( E.e_eot ) {
d812 1
a812 1
		n->m_act = MNULL; /* set on tp_input */
d815 2
a816 1
	IFDEBUG(D_STASH)
d818 2
a819 1
	ENDDEBUG
d823 1
a823 1
		register struct pklcd *lcp = (struct pklcd *)isop->isop_chan;
d826 1
a826 1
} 
d830 1
a830 1
register struct tp_pcb *tpcb;
d832 1
a832 1
	register struct isopcb *isop = (struct isopcb *)tpcb->tp_npcb;
d836 1
a836 1
		register struct pklcd *lcp = (struct pklcd *)isop->isop_chan;
d846 1
a846 1
 *  and tp_newsocket() when a new connection is made from 
d855 1
a855 1
int 
d859 1
a859 2

	if( tpcb->tp_p_meas == 0 ) {
d862 2
a863 1
		IFDEBUG(D_PERF_MEAS)
d865 5
a869 4
			"tpcb 0x%x so 0x%x ref 0x%x tp_p_meas 0x%x tp_perf_on 0x%x\n", 
				tpcb, tpcb->tp_sock, tpcb->tp_lref, 
				tpcb->tp_p_meas, tpcb->tp_perf_on);
		ENDDEBUG
d874 1
a874 1
#endif /* TP_PERF_MEAS */
d877 2
a878 1
dump_addr (addr)
d881 4
a884 4
	switch( addr->sa_family ) {
		case AF_INET:
			dump_inaddr(satosin(addr));
			break;
d886 7
a892 7
		case AF_ISO:
			dump_isoaddr(satosiso(addr));
			break;
#endif /* ISO */
		default:
			printf("BAD AF: 0x%x\n", addr->sa_family);
			break;
d904 1
d906 2
a907 2
caddr_t	buf;
int		len;
d909 1
a909 1
	int		i,j;
d916 1
a916 1
				printf("%x/%d\t", Buf[i+j], Buf[i+j]);
d924 2
a925 2
				if (((Buf[i+j]) > 31) && ((Buf[i+j]) < 128))
					printf("%c", Buf[i+j]);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
