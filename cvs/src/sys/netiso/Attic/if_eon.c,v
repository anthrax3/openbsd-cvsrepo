head	1.25;
access;
symbols
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.17
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.5.0.12
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.5.0.10
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.5.0.8
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.5.0.6
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.25
date	2004.07.15.12.10.45;	author henning;	state dead;
branches;
next	1.24;

1.24
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.28.23.17.45;	author cloder;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.09.22.03.16;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.17;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.03.22.20.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.28.15.43.03;	author pefo;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.31.00.13.37;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.26.19.12.56;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.03.49.54;	author angelos;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.06.25.01.50.17;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.03.38.35;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.27.12.26.05;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.06.00.22.25;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.19.06.37.38;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	99.12.08.06.50.24;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.04.22.20.02.44;	author art;	state Exp;
branches;
next	1.5;

1.5
date	96.05.22.12.02.42;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.31.22;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.29.23;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.03.04.10.35.24;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.15;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.15;	author deraadt;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.22;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.55.34;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2002.03.28.14.57.37;	author niklas;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.03.28.00.06.55;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.05.19.22.41.16;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.25
log
@bye bye netiso, you won't be missed
ok millert deraadt
@
text
@/*	$OpenBSD: if_eon.c,v 1.24 2004/06/21 23:50:37 tholo Exp $	*/
/*	$NetBSD: if_eon.c,v 1.15 1996/05/09 22:29:37 scottr Exp $	*/

/*-
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_eon.c	8.1 (Berkeley) 6/10/93
 */

/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/*
 *	EON rfc
 *  Layer between IP and CLNL
 *
 * TODO:
 * Put together a current rfc986 address format and get the right offset
 * for the nsel
 */

#ifdef EON
#define NEON 1


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/buf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/types.h>

#include <machine/cpu.h>	/* XXX for setsoftnet().  This must die. */

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/if_ether.h>

#include <netiso/iso.h>
#include <netiso/iso_var.h>
#include <netiso/iso_snpac.h>
#include <netiso/argo_debug.h>
#include <netiso/iso_errno.h>
#include <netiso/eonvar.h>

#include <sys/stdarg.h>

#define EOK 0

struct ifnet    eonif[1];

void
eonprotoinit()
{
	(void) eonattach();
}

struct eon_llinfo eon_llinfo;
#define PROBE_OK 0;


/*
 * FUNCTION:		eonattach
 *
 * PURPOSE:			autoconf attach routine
 *
 * RETURNS:			void
 */

void
eonattach()
{
	struct ifnet *ifp = eonif;

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonattach()\n");
	}
#endif
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "eon%d", 0);
	ifp->if_mtu = ETHERMTU;
	ifp->if_softc = NULL;
	/* since everything will go out over ether or token ring */

	ifp->if_ioctl = eonioctl;
	ifp->if_output = eonoutput;
	ifp->if_type = IFT_EON;
	ifp->if_addrlen = 5;
	ifp->if_hdrlen = EONIPLEN;
	ifp->if_flags = IFF_BROADCAST;
	if_attach(ifp);
	eonioctl(ifp, SIOCSIFADDR, (caddr_t) ifp->if_addrlist.tqh_first);
	eon_llinfo.el_qhdr.link =
		eon_llinfo.el_qhdr.rlink = &(eon_llinfo.el_qhdr);

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonattach()\n");
	}
#endif
}


/*
 * FUNCTION:		eonioctl
 *
 * PURPOSE:			io controls - ifconfig
 *				need commands to
 *					link-UP (core addr) (flags: ES, IS)
 *					link-DOWN (core addr) (flags: ES, IS)
 *				must be callable from kernel or user
 *
 * RETURNS:			nothing
 */
int
eonioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long          cmd;
	caddr_t data;
{
	int             s = splimp();
	int    error = 0;

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonioctl (cmd 0x%lx) \n", cmd);
	}
#endif

	switch (cmd) {
		struct ifaddr *ifa;

	case SIOCSIFADDR:
		if ((ifa = (struct ifaddr *) data) != NULL) {
			ifp->if_flags |= IFF_UP;
			if (ifa->ifa_addr->sa_family != AF_LINK)
				ifa->ifa_rtrequest = eonrtrequest;
		}
		break;
	}
	splx(s);
	return (error);
}


void
eoniphdr(hdr, loc, ro, class, zero)
	struct route   *ro;
	struct eon_iphdr *hdr;
	caddr_t         loc;
	int		class, zero;
{
	struct mbuf     mhead;
	struct sockaddr_in *sin = satosin(&ro->ro_dst);
	if (zero) {
		bzero((caddr_t) hdr, sizeof(*hdr));
		bzero((caddr_t) ro, sizeof(*ro));
	}
	sin->sin_family = AF_INET;
	sin->sin_len = sizeof(*sin);
	bcopy(loc, (caddr_t) & sin->sin_addr, sizeof(struct in_addr));
	/*
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up.  If not, free it and try again.
	 */
	if (ro->ro_rt) {
		struct sockaddr_in *dst = satosin(rt_key(ro->ro_rt));
		if ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    sin->sin_addr.s_addr != dst->sin_addr.s_addr) {
			RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *) 0;
		}
	}
	rtalloc(ro);
	if (ro->ro_rt)
		ro->ro_rt->rt_use++;
	hdr->ei_ip.ip_dst = sin->sin_addr;
	hdr->ei_ip.ip_p = IPPROTO_EON;
	hdr->ei_ip.ip_ttl = MAXTTL;
	hdr->ei_eh.eonh_class = class;
	hdr->ei_eh.eonh_vers = EON_VERSION;
	hdr->ei_eh.eonh_csum = 0;
	mhead.m_data = (caddr_t) & hdr->ei_eh;
	mhead.m_len = sizeof(struct eon_hdr);
	mhead.m_next = 0;
#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonoutput : gen csum (%p, offset %d, datalen %d)\n",
		       &mhead, _offsetof(struct eon_hdr, eonh_csum),
		       sizeof(struct eon_hdr));
	}
#endif
	iso_gen_csum(&mhead,
	      _offsetof(struct eon_hdr, eonh_csum), sizeof(struct eon_hdr));
}
/*
 * FUNCTION:		eonrtrequest
 *
 * PURPOSE:			maintains list of direct eon recipients.
 *					sets up IP route for rest.
 *
 * RETURNS:			nothing
 */
void
eonrtrequest(cmd, rt, info)
	int cmd;
	struct rtentry *rt;
	struct rt_addrinfo *info;
{
	unsigned long   zerodst = 0;
	caddr_t         ipaddrloc = (caddr_t) & zerodst;
	struct eon_llinfo *el = (struct eon_llinfo *) rt->rt_llinfo;
	struct sockaddr *gate;

	/*
	 * Common Housekeeping
	 */
	switch (cmd) {
	case RTM_DELETE:
		if (el) {
			remque(&(el->el_qhdr));
			if (el->el_iproute.ro_rt)
				RTFREE(el->el_iproute.ro_rt);
			Free(el);
			rt->rt_llinfo = 0;
		}
		return;

	case RTM_ADD:
	case RTM_RESOLVE:
		rt->rt_rmx.rmx_mtu = lo0ifp->if_mtu;	/* unless better below */
		R_Malloc(el, struct eon_llinfo *, sizeof(*el));
		rt->rt_llinfo = (caddr_t) el;
		if (el == 0)
			return;
		Bzero(el, sizeof(*el));
		insque(&(el->el_qhdr), &eon_llinfo.el_qhdr);
		el->el_rt = rt;
		break;
	}
	if (info && (gate = info->rti_info[RTAX_GATEWAY]))	/*XXX*/
		switch (gate->sa_family) {
		case AF_LINK:
#define SDL(x) ((struct sockaddr_dl *)x)
			if (SDL(gate)->sdl_alen == 1)
				el->el_snpaoffset = *(u_char *) LLADDR(SDL(gate));
			else
				ipaddrloc = LLADDR(SDL(gate));
			break;
		case AF_INET:
			ipaddrloc = (caddr_t) & satosin(gate)->sin_addr;
			break;
		default:
			return;
		}
	el->el_flags |= RTF_UP;
	eoniphdr(&el->el_ei, ipaddrloc, &el->el_iproute, EON_NORMAL_ADDR, 0);
	if (el->el_iproute.ro_rt)
		rt->rt_rmx.rmx_mtu = el->el_iproute.ro_rt->rt_rmx.rmx_mtu
			- sizeof(el->el_ei);
}

/*
 * FUNCTION:		eonoutput
 *
 * PURPOSE:		prepend an eon header and hand to IP
 * ARGUMENTS:	 	(ifp) is points to the ifnet structure for this
 *			unit/device (m)  is an mbuf *, *m is a CLNL packet
 *			(dst) is a destination address - have to interp. as
 *			multicast or broadcast or real address.
 *
 * RETURNS:		unix error code
 *
 * NOTES:
 *
 */
int
eonoutput(ifp, m, sdst, rt)
	struct ifnet   *ifp;
	struct mbuf *m;	/* packet */
	struct sockaddr *sdst;		/* destination addr */
	struct rtentry *rt;
{
	struct sockaddr_iso *dst = (struct sockaddr_iso *) sdst;
	struct eon_llinfo *el;
	struct eon_iphdr *ei;
	struct route   *ro;
	int             datalen;
	struct mbuf    *mh;
	int             error = 0, class = 0, alen = 0;
	caddr_t         ipaddrloc = NULL;
	static struct eon_iphdr eon_iphdr;
	static struct route route;

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonoutput \n");
	}
#endif

	ifp->if_opackets++;
	if (rt == 0 || (el = (struct eon_llinfo *) rt->rt_llinfo) == 0) {
		if (dst->siso_family == AF_LINK) {
			struct sockaddr_dl *sdl = (struct sockaddr_dl *) dst;

			ipaddrloc = LLADDR(sdl);
			alen = sdl->sdl_alen;
		} else if (dst->siso_family == AF_ISO &&
			   dst->siso_data[0] == AFI_SNA) {
			alen = dst->siso_nlen - 1;
			ipaddrloc = (caddr_t) dst->siso_data + 1;
		}
		switch (alen) {
		case 5:
			class = 4[(u_char *) ipaddrloc];
		case 4:
			ro = &route;
			ei = &eon_iphdr;
			eoniphdr(ei, ipaddrloc, ro, class, 1);
			goto send;
		}
einval:
		error = EINVAL;
		goto flush;
	}
	if ((el->el_flags & RTF_UP) == 0) {
		eonrtrequest(RTM_CHANGE, rt, (struct sockaddr *) 0);
		if ((el->el_flags & RTF_UP) == 0) {
			error = EHOSTUNREACH;
			goto flush;
		}
	}
	if ((m->m_flags & M_PKTHDR) == 0) {
		printf("eon: got non headered packet\n");
		goto einval;
	}
	ei = &el->el_ei;
	ro = &el->el_iproute;
	if (el->el_snpaoffset) {
		if (dst->siso_family == AF_ISO) {
			bcopy((caddr_t) & dst->siso_data[el->el_snpaoffset],
			      (caddr_t) & ei->ei_ip.ip_dst, sizeof(ei->ei_ip.ip_dst));
		} else
			goto einval;
	}
send:
	/* put an eon_hdr in the buffer, prepended by an ip header */
	datalen = m->m_pkthdr.len + EONIPLEN;
	MGETHDR(mh, M_DONTWAIT, MT_HEADER);
	if (mh == (struct mbuf *) 0)
		goto flush;
	M_MOVE_HDR(mh, m);
	mh->m_next = m;
	m = mh;
	MH_ALIGN(m, sizeof(struct eon_iphdr));
	m->m_len = sizeof(struct eon_iphdr);
	m->m_pkthdr.len = datalen;
	ei->ei_ip.ip_len = htons(datalen);
	ifp->if_obytes += datalen;
	*mtod(m, struct eon_iphdr *) = *ei;

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonoutput dst ip addr : %x\n", ei->ei_ip.ip_dst.s_addr);
		printf("eonoutput ip_output : eonip header:\n");
		dump_buf(ei, sizeof(struct eon_iphdr));
	}
#endif

	error = ip_output(m, (struct mbuf *) 0, ro, (void *)NULL, (void *)NULL);
	m = 0;
	if (error) {
		ifp->if_oerrors++;
		ifp->if_opackets--;
		ifp->if_obytes -= datalen;
	}
flush:
	if (m)
		m_freem(m);
	return error;
}

void
eoninput(struct mbuf *m, ...)
{
	int             iphlen;
	struct eon_hdr *eonhdr;
	struct ip *iphdr;
	struct ifnet   *eonifp;
	int             s;
	va_list ap;

	va_start(ap, m);
	iphlen = va_arg(ap, int);
	va_end(ap);

	eonifp = &eonif[0];	/* kludge - really want to give CLNP the ifp
				 * for eon, not for the real device */

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eoninput() %p m_data %p m_len 0x%x dequeued\n",
		       m, (m ? m->m_data : 0), m ? m->m_len : 0);
	}
#endif

	if (m == 0)
		return;
	if (iphlen > sizeof(struct ip))
		ip_stripoptions(m, (struct mbuf *) 0);
	if (m->m_len < EONIPLEN) {
		if ((m = m_pullup(m, EONIPLEN)) == 0) {
			IncStat(es_badhdr);
	drop:
#ifdef ARGO_DEBUG
			if (argo_debug[D_EON]) {
				printf("eoninput: DROP \n");
			}
#endif
			eonifp->if_ierrors++;
			if (m != 0)
				m_freem(m);
			return;
		}
	}
	eonif->if_ibytes += m->m_pkthdr.len;
	iphdr = mtod(m, struct ip *);
	/* do a few checks for debugging */
	if (iphdr->ip_p != IPPROTO_EON) {
		IncStat(es_badhdr);
		goto drop;
	}
	/* temporarily drop ip header from the mbuf */
	m->m_data += sizeof(struct ip);
	eonhdr = mtod(m, struct eon_hdr *);
	if (iso_check_csum(m, sizeof(struct eon_hdr)) != EOK) {
		IncStat(es_badcsum);
		goto drop;
	}
	m->m_data -= sizeof(struct ip);

#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eoninput csum ok class 0x%x\n", eonhdr->eonh_class);
		printf("eoninput: eon header:\n");
		dump_buf(eonhdr, sizeof(struct eon_hdr));
	}
#endif

	/* checks for debugging */
	if (eonhdr->eonh_vers != EON_VERSION) {
		IncStat(es_badhdr);
		goto drop;
	}
	m->m_flags &= ~(M_BCAST | M_MCAST);
	switch (eonhdr->eonh_class) {
	case EON_BROADCAST:
		IncStat(es_in_broad);
		m->m_flags |= M_BCAST;
		break;
	case EON_NORMAL_ADDR:
		IncStat(es_in_normal);
		break;
	case EON_MULTICAST_ES:
		IncStat(es_in_multi_es);
		m->m_flags |= M_MCAST;
		break;
	case EON_MULTICAST_IS:
		IncStat(es_in_multi_is);
		m->m_flags |= M_MCAST;
		break;
	}
	eonifp->if_ipackets++;

	{
		/* put it on the CLNP queue and set soft interrupt */
		struct ifqueue *ifq;
		extern struct ifqueue clnlintrq;

		m->m_pkthdr.rcvif = eonifp;	/* KLUDGE */
#ifdef ARGO_DEBUG
		if (argo_debug[D_EON]) {
			printf("eoninput to clnl IFQ\n");
		}
#endif
		ifq = &clnlintrq;
		s = splimp();
		if (IF_QFULL(ifq)) {
			IF_DROP(ifq);
			m_freem(m);
			eonifp->if_iqdrops++;
			eonifp->if_ipackets--;
			splx(s);
			return;
		}
		IF_ENQUEUE(ifq, m);
#ifdef ARGO_DEBUG
		if (argo_debug[D_EON]) {
			printf(
			       "%p enqueued on clnp Q: m_len 0x%x m_type 0x%x m_data %p\n",
			       m, m->m_len, m->m_type, m->m_data);
			dump_buf(mtod(m, caddr_t), m->m_len);
		}
#endif
		schednetisr(NETISR_ISO);
		splx(s);
	}
}

void *
eonctlinput(cmd, sa, dummy)
	int             cmd;
	struct sockaddr *sa;
	void *dummy;
{
	struct sockaddr_in *sin = (struct sockaddr_in *) sa;
#ifdef ARGO_DEBUG
	if (argo_debug[D_EON]) {
		printf("eonctlinput: cmd 0x%x addr: ", cmd);
		dump_isoaddr((struct sockaddr_iso *) sin);
		printf("\n");
	}
#endif

	if (cmd < 0 || cmd >= PRC_NCMDS)
		return NULL;

	IncStat(es_icmp[cmd]);
	switch (cmd) {

	case PRC_QUENCH:
	case PRC_QUENCH2:
		/* TODO: set the dec bit */
		break;
	case PRC_TIMXCEED_REASS:
	case PRC_ROUTEDEAD:
	case PRC_HOSTUNREACH:
	case PRC_UNREACH_NET:
	case PRC_IFDOWN:
	case PRC_UNREACH_HOST:
	case PRC_HOSTDEAD:
	case PRC_TIMXCEED_INTRANS:
		/* TODO: mark the link down */
		break;

	case PRC_UNREACH_PROTOCOL:
	case PRC_UNREACH_PORT:
	case PRC_UNREACH_SRCFAIL:
	case PRC_REDIRECT_NET:
	case PRC_REDIRECT_HOST:
	case PRC_REDIRECT_TOSNET:
	case PRC_REDIRECT_TOSHOST:
	case PRC_MSGSIZE:
	case PRC_PARAMPROB:
		/* printf("eonctlinput: ICMP cmd 0x%x\n", cmd ); */
		break;
	}
	return NULL;
}

#endif
@


1.24
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.23 2004/01/03 14:08:54 espie Exp $	*/
@


1.23
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.22 2003/12/10 07:22:44 itojun Exp $	*/
a106 2

extern struct timeval time;
@


1.22
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.21 2003/09/28 23:17:45 cloder Exp $	*/
d106 1
a106 1
#include <machine/stdarg.h>
@


1.21
log
@Correct off-by-ones with respect to PRC_NCMDS.  Mostly from FreeBSD.
OK krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.20 2003/07/09 22:03:16 itojun Exp $	*/
d135 1
a135 1
	register struct ifnet *ifp = eonif;
d179 1
a179 1
	register struct ifnet *ifp;
d181 1
a181 1
	register caddr_t data;
d184 1
a184 1
	register int    error = 0;
d193 1
a193 1
		register struct ifaddr *ifa;
d211 1
a211 1
	register struct eon_iphdr *hdr;
d216 1
a216 1
	register struct sockaddr_in *sin = satosin(&ro->ro_dst);
d270 2
a271 2
	register struct rtentry *rt;
	register struct rt_addrinfo *info;
d275 1
a275 1
	register struct eon_llinfo *el = (struct eon_llinfo *) rt->rt_llinfo;
d343 1
a343 1
	register struct mbuf *m;	/* packet */
d348 2
a349 2
	register struct eon_llinfo *el;
	register struct eon_iphdr *ei;
d367 1
a367 1
			register struct sockaddr_dl *sdl = (struct sockaddr_dl *) dst;
d450 2
a451 2
	register struct eon_hdr *eonhdr;
	register struct ip *iphdr;
@


1.20
log
@do not flip ip_len/ip_off in netinet stack.  deraadt ok.
(please test, especially PF portion)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.19 2003/06/02 23:28:17 millert Exp $	*/
d588 1
a588 1
	if (cmd < 0 || cmd > PRC_NCMDS)
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.18 2003/05/03 22:20:19 deraadt Exp $	*/
d420 3
a422 2
	ifp->if_obytes +=
		(ei->ei_ip.ip_len = (u_short) (m->m_pkthdr.len = datalen));
@


1.18
log
@string fix
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.17 2002/08/28 15:43:03 pefo Exp $	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@Fix a problem where passing NULL as a pointer with varargs does not promote
NULL to full 64 bits on a 64 bit address system. Soultion is to add a
(void *) cast before NULL. This makes a 64 bit MIPS kernel work and will
probably help future 64 bit ports as well.

OK from art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.16 2002/07/31 00:13:37 itojun Exp $	*/
d146 1
a146 1
	sprintf(ifp->if_xname, "eon%d", 0);
@


1.16
log
@fix potential NULL pointer deref.  From: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.15 2002/03/26 19:12:56 niklas Exp $	*/
d436 1
a436 1
	error = ip_output(m, (struct mbuf *) 0, ro, 0, NULL);
@


1.15
log
@m_freem(NULL) bad style, ok jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.14 2002/03/15 18:19:53 millert Exp $	*/
d308 1
a308 1
	if (info || (gate = info->rti_info[RTAX_GATEWAY]))	/*XXX*/
@


1.14
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.13 2001/06/27 03:49:54 angelos Exp $	*/
d487 2
a488 1
			m_freem(m);
@


1.13
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.12 2001/06/25 01:50:17 fgsch Exp $	*/
a449 1
#if __STDC__
a450 5
#else
eoninput(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.13 2001/06/27 03:49:54 angelos Exp $	*/
d450 1
d452 5
d493 1
a493 2
			if (m != 0)
				m_freem(m);
@


1.13.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.13.4.1 2002/06/11 03:31:38 art Exp $	*/
d308 1
a308 1
	if (info && (gate = info->rti_info[RTAX_GATEWAY]))	/*XXX*/
d436 1
a436 1
	error = ip_output(m, (struct mbuf *) 0, ro, (void *)NULL, (void *)NULL);
@


1.13.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d146 1
a146 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "eon%d", 0);
@


1.12
log
@Move common post M_COPY_HDR manipulation to the macro itself; angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.11 2001/06/15 03:38:35 itojun Exp $	*/
d419 1
a419 1
	M_COPY_HDR(mh, m);
@


1.11
log
@change the meaning of ifnet.if_lastchange to meet RFC1573 ifLastChange.
follows BSD/OS practice and ucd-snmp code (FreeBSD does it for specific
interfaces only).

was: if_lastchange get updated on every packet transmission/receipt.
now: if_lastchange get updated when IFF_UP is changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.10 2001/05/27 12:26:05 angelos Exp $	*/
a419 2
	m->m_flags &= ~M_PKTHDR;
	m_tag_init(m);
@


1.10
log
@More tag fixups (why do I bother with this...)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.9 2001/02/06 00:22:25 mickey Exp $	*/
a367 1
	ifp->if_lastchange = time;
a499 1
	eonif->if_lastchange = time;
@


1.9
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.8 2001/01/19 06:37:38 itojun Exp $	*/
d420 3
@


1.8
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.7 1999/12/08 06:50:24 itojun Exp $	*/
a111 4
#include "loop.h"

extern struct ifnet loif[NLOOP];

d298 1
a298 1
		rt->rt_rmx.rmx_mtu = loif[0].if_mtu;	/* unless better below */
@


1.7
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.5 1996/05/22 12:02:42 deraadt Exp $	*/
d276 1
a276 1
eonrtrequest(cmd, rt, gate)
d279 1
a279 1
	register struct sockaddr *gate;
d284 1
d312 1
a312 1
	if (gate || (gate = rt->rt_gateway))
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.9 2001/02/06 00:22:25 mickey Exp $	*/
d112 4
d276 1
a276 1
eonrtrequest(cmd, rt, info)
d279 1
a279 1
	register struct rt_addrinfo *info;
a283 1
	struct sockaddr *gate;
d301 1
a301 1
		rt->rt_rmx.rmx_mtu = lo0ifp->if_mtu;	/* unless better below */
d311 1
a311 1
	if (info || (gate = info->rti_info[RTAX_GATEWAY]))	/*XXX*/
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.7.2.1 2001/05/14 22:40:22 niklas Exp $	*/
d368 1
a419 1
	M_MOVE_HDR(mh, m);
d498 1
@


1.7.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d450 1
d452 5
@


1.7.2.4
log
@Sync the SMP branch with 3.3
@
text
@d308 1
a308 1
	if (info && (gate = info->rti_info[RTAX_GATEWAY]))	/*XXX*/
d436 1
a436 1
	error = ip_output(m, (struct mbuf *) 0, ro, (void *)NULL, (void *)NULL);
d487 1
a487 2
			if (m != 0)
				m_freem(m);
@


1.7.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.7.2.4 2003/03/28 00:06:55 niklas Exp $	*/
d146 1
a146 1
	snprintf(ifp->if_xname, sizeof ifp->if_xname, "eon%d", 0);
@


1.7.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.7.2.5 2003/05/13 19:36:18 ho Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d106 1
a106 1
#include <sys/stdarg.h>
d135 1
a135 1
	struct ifnet *ifp = eonif;
d179 1
a179 1
	struct ifnet *ifp;
d181 1
a181 1
	caddr_t data;
d184 1
a184 1
	int    error = 0;
d193 1
a193 1
		struct ifaddr *ifa;
d211 1
a211 1
	struct eon_iphdr *hdr;
d216 1
a216 1
	struct sockaddr_in *sin = satosin(&ro->ro_dst);
d270 2
a271 2
	struct rtentry *rt;
	struct rt_addrinfo *info;
d275 1
a275 1
	struct eon_llinfo *el = (struct eon_llinfo *) rt->rt_llinfo;
d343 1
a343 1
	struct mbuf *m;	/* packet */
d348 2
a349 2
	struct eon_llinfo *el;
	struct eon_iphdr *ei;
d367 1
a367 1
			struct sockaddr_dl *sdl = (struct sockaddr_dl *) dst;
d420 2
a421 3
	m->m_pkthdr.len = datalen;
	ei->ei_ip.ip_len = htons(datalen);
	ifp->if_obytes += datalen;
d449 2
a450 2
	struct eon_hdr *eonhdr;
	struct ip *iphdr;
d587 1
a587 1
	if (cmd < 0 || cmd >= PRC_NCMDS)
@


1.6
log
@we don't need to include buf.h
@
text
@d81 1
d112 4
a116 1
extern struct ifnet loif;
d301 1
a301 1
		rt->rt_rmx.rmx_mtu = loif.if_mtu;	/* unless better below */
@


1.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eon.c,v 1.4 1996/05/10 12:31:22 deraadt Exp $	*/
a80 1
#include <sys/buf.h>
@


1.4
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD: if_eon.c,v 1.2 1996/03/04 10:35:24 mickey Exp $	*/
/*	$NetBSD: if_eon.c,v 1.14 1996/05/07 02:45:10 thorpej Exp $	*/
d87 2
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: if_eon.c,v 1.13 1996/04/13 01:34:44 cgd Exp $	*/
d145 1
a145 2
	ifp->if_unit = 0;
	ifp->if_name = "eon";
d147 1
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: if_eon.c,v 1.12 1996/02/13 22:09:50 christos Exp $	*/
d254 3
a256 3
		printf("eonoutput : gen csum (0x%x, offset %d, datalen %d)\n",
		       (unsigned int) &mhead,
		       _offsetof(struct eon_hdr, eonh_csum), sizeof(struct eon_hdr));
d472 2
a473 3
		printf("eoninput() 0x%x m_data 0x%x m_len 0x%x dequeued\n",
		       (unsigned int) m, 
		       (unsigned int) (m ? m->m_data : 0), m ? m->m_len : 0);
d570 2
a571 3
			       "0x%x enqueued on clnp Q: m_len 0x%x m_type 0x%x m_data 0x%x\n",
			       (unsigned int) m, m->m_len, m->m_type,
			       (unsigned int) m->m_data);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: if_eon.c,v 1.11 1995/06/13 07:13:28 mycroft Exp $	*/
d44 2
a45 2
Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
d47 1
a47 1
both that copyright notice and this permission notice appear in 
d50 1
a50 1
software without specific, written prior permission.  
d66 1
a66 1
 *	EON rfc 
d108 2
d115 1
a115 6
int						eoninput();
int						eonoutput();
int						eonioctl();
int						eonattach();
void						eonrtrequest();
struct ifnet			eonif[1];
d117 3
a119 1
eonprotoinit() {
d135 1
d140 2
a141 1
	IFDEBUG(D_EON)
d143 2
a144 1
	ENDDEBUG
d147 2
a148 2
	ifp->if_mtu = ETHERMTU; 
		/* since everything will go out over ether or token ring */
d157 2
a158 2
	eonioctl(ifp, SIOCSIFADDR, (caddr_t)ifp->if_addrlist.tqh_first);
	eon_llinfo.el_qhdr.link = 
d161 2
a162 1
	IFDEBUG(D_EON)
d164 2
a165 1
	ENDDEBUG
d173 1
a173 1
 *				need commands to 
d180 1
d183 1
a183 1
	u_long cmd;
d186 2
a187 2
	int s = splimp();
	register int error = 0;
d189 2
a190 1
	IFDEBUG(D_EON)
d192 2
a193 1
	ENDDEBUG
d199 1
a199 1
		if (ifa = (struct ifaddr *)data) {
d207 1
a207 1
	return(error);
d211 1
d213 4
a216 3
struct route *ro;
register struct eon_iphdr *hdr;
caddr_t loc;
d218 1
a218 1
	struct mbuf mhead;
d221 2
a222 2
		bzero((caddr_t)hdr, sizeof (*hdr));
		bzero((caddr_t)ro, sizeof (*ro));
d225 2
a226 2
	sin->sin_len = sizeof (*sin);
	bcopy(loc, (caddr_t)&sin->sin_addr, sizeof(struct in_addr));
d235 1
a235 1
		   sin->sin_addr.s_addr != dst->sin_addr.s_addr) {
d237 1
a237 1
			ro->ro_rt = (struct rtentry *)0;
d245 1
a245 1
	hdr->ei_ip.ip_ttl = MAXTTL;	
d249 1
a249 1
	mhead.m_data = (caddr_t) &hdr->ei_eh;
d252 9
a260 7
	IFDEBUG(D_EON)
		printf("eonoutput : gen csum (0x%x, offset %d, datalen %d)\n", 
			&mhead,
			_offsetof(struct eon_hdr, eonh_csum), sizeof(struct eon_hdr)); 
	ENDDEBUG
	iso_gen_csum(&mhead, 
		_offsetof(struct eon_hdr, eonh_csum), sizeof(struct eon_hdr)); 
d272 3
a274 2
register struct rtentry *rt;
register struct sockaddr *gate;
d276 3
a278 3
	unsigned long zerodst = 0;
	caddr_t	ipaddrloc = (caddr_t) &zerodst;
	register struct eon_llinfo *el = (struct eon_llinfo *)rt->rt_llinfo;
d296 1
a296 1
		rt->rt_rmx.rmx_mtu = loif.if_mtu; /* unless better below */
d298 1
a298 1
		rt->rt_llinfo = (caddr_t)el;
d306 2
a307 1
	if (gate || (gate = rt->rt_gateway)) switch (gate->sa_family) {
d311 1
a311 1
				el->el_snpaoffset = *(u_char *)LLADDR(SDL(gate));
d316 1
a316 1
			ipaddrloc = (caddr_t) &satosin(gate)->sin_addr;
d320 1
a320 1
	}
d325 1
a325 1
							- sizeof(el->el_ei);
d331 5
a335 5
 * PURPOSE:			prepend an eon header and hand to IP
 * ARGUMENTS:	 	(ifp) is points to the ifnet structure for this unit/device
 *					(m)  is an mbuf *, *m is a CLNL packet
 *					(dst) is a destination address - have to interp. as
 *					multicast or broadcast or real address.
d337 1
a337 1
 * RETURNS:			unix error code
d339 1
a339 1
 * NOTES:			
d342 5
a346 4
eonoutput(ifp, m, dst, rt)
	struct ifnet 	*ifp;
	register struct mbuf	*m;		/* packet */
	struct sockaddr_iso		*dst;		/* destination addr */
d349 1
d352 5
a356 5
	struct route *ro;
	int	datalen;
	struct mbuf *mh;
	int	error = 0, class = 0, alen = 0;
	caddr_t ipaddrloc;
d360 5
a364 3
	IFDEBUG(D_EON)
		printf("eonoutput \n" );
	ENDDEBUG
d368 1
a368 1
	if (rt == 0 || (el = (struct eon_llinfo *)rt->rt_llinfo) == 0) {
d370 1
a370 1
			register struct sockaddr_dl *sdl = (struct sockaddr_dl *)dst;
d374 2
a375 1
		} else if (dst->siso_family == AF_ISO && dst->siso_data[0] == AFI_SNA) {
d381 1
a381 1
			class =  4[(u_char *)ipaddrloc];
d389 1
a389 1
		error =  EINVAL;
d393 1
a393 1
		eonrtrequest(RTM_CHANGE, rt, (struct sockaddr *)0);
d407 2
a408 2
			bcopy((caddr_t) &dst->siso_data[el->el_snpaoffset],
					(caddr_t) &ei->ei_ip.ip_dst, sizeof(ei->ei_ip.ip_dst));
d416 1
a416 1
	if(mh == (struct mbuf *)0)
d423 1
a423 1
		(ei->ei_ip.ip_len = (u_short)(m->m_pkthdr.len = datalen));
d426 3
a428 2
	IFDEBUG(D_EON)
		printf("eonoutput dst ip addr : %x\n",  ei->ei_ip.ip_dst.s_addr);
d431 2
a432 1
	ENDDEBUG
d434 1
a434 1
	error = ip_output(m, (struct mbuf *)0, ro, 0, NULL);
d447 8
a454 3
eoninput(m, iphlen)
	register struct mbuf	*m;
	int iphlen;
d456 13
a468 8
	register struct eon_hdr	*eonhdr;
	register struct ip		*iphdr;
	struct ifnet 			*eonifp;
	int						s;

	eonifp = &eonif[0]; /* kludge - really want to give CLNP
						* the ifp for eon, not for the real device
						*/
d470 2
a471 1
	IFDEBUG(D_EON)
d473 4
a476 2
			m, m?m->m_data:0, m?m->m_len:0);
	ENDDEBUG
d480 2
a481 2
	if (iphlen > sizeof (struct ip))
		ip_stripoptions(m, (struct mbuf *)0);
d485 7
a491 5
drop:
			IFDEBUG(D_EON)
				printf("eoninput: DROP \n" );
			ENDDEBUG
			eonifp->if_ierrors ++;
d500 1
a500 1
	if( iphdr->ip_p != IPPROTO_EON ) {
d507 1
a507 1
	if( iso_check_csum( m, sizeof(struct eon_hdr) )   != EOK ) {
d512 4
a515 3
		
	IFDEBUG(D_EON)
		printf("eoninput csum ok class 0x%x\n", eonhdr->eonh_class );
d518 2
a519 1
	ENDDEBUG
d522 1
a522 1
	if( eonhdr->eonh_vers != EON_VERSION) {
d526 17
a542 17
	m->m_flags &= ~(M_BCAST|M_MCAST);
	switch( eonhdr->eonh_class) {
		case EON_BROADCAST:
			IncStat(es_in_broad);
			m->m_flags |= M_BCAST;
			break;
		case EON_NORMAL_ADDR:
			IncStat(es_in_normal);
			break;
		case EON_MULTICAST_ES:
			IncStat(es_in_multi_es);
			m->m_flags |= M_MCAST;
			break;
		case EON_MULTICAST_IS:
			IncStat(es_in_multi_is);
			m->m_flags |= M_MCAST;
			break;
d548 2
a549 2
		struct ifqueue 			*ifq;
		extern struct ifqueue 	clnlintrq;
d551 3
a553 2
		m->m_pkthdr.rcvif = eonifp; /* KLUDGE */
		IFDEBUG(D_EON)
d555 2
a556 1
		ENDDEBUG
d568 2
a569 1
		IFDEBUG(D_EON) 
d571 3
a573 2
	"0x%x enqueued on clnp Q: m_len 0x%x m_type 0x%x m_data 0x%x\n", 
				m, m->m_len, m->m_type, m->m_data);
d575 2
a576 1
		ENDDEBUG
d582 5
a586 4
int
eonctlinput(cmd, sin)
	int cmd;
	struct sockaddr_in *sin;
d588 3
a590 3
	extern u_char inetctlerrmap[];

	IFDEBUG(D_EON)
d592 1
a592 1
		dump_isoaddr(sin);
d594 2
a595 1
	ENDDEBUG
d598 1
a598 1
		return 0;
d603 14
a616 14
		case	PRC_QUENCH:
		case	PRC_QUENCH2:
			/* TODO: set the dec bit */
			break;
		case	PRC_TIMXCEED_REASS:
		case	PRC_ROUTEDEAD:
		case	PRC_HOSTUNREACH:
		case	PRC_UNREACH_NET:
		case	PRC_IFDOWN:
		case	PRC_UNREACH_HOST:
		case	PRC_HOSTDEAD:
		case	PRC_TIMXCEED_INTRANS:
			/* TODO: mark the link down */
			break;
d618 10
a627 10
		case	PRC_UNREACH_PROTOCOL:
		case	PRC_UNREACH_PORT:
		case	PRC_UNREACH_SRCFAIL:
		case	PRC_REDIRECT_NET:
		case	PRC_REDIRECT_HOST:
		case	PRC_REDIRECT_TOSNET:
		case	PRC_REDIRECT_TOSHOST:
		case	PRC_MSGSIZE:
		case	PRC_PARAMPROB:
			/* printf("eonctlinput: ICMP cmd 0x%x\n", cmd );*/
d630 1
a630 1
	return 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
