head	1.6;
access;
symbols
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.26
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.24
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.22
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.3.0.20
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.18
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.16
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.10
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.6
date	2004.06.20.17.19.27;	author itojun;	state dead;
branches;
next	1.5;

1.5
date	2003.12.10.07.22.44;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.02.23.28.18;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.01.03.22.32.56;	author deraadt;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	96.03.04.10.36.54;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.18;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.18;	author deraadt;	state Exp;
branches;
next	;

1.3.10.1
date	2003.06.07.11.06.10;	author ho;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2004.02.19.10.57.26;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.6
log
@goodbye TUBA.  deraadt ok
@
text
@/*	$OpenBSD: tuba_usrreq.c,v 1.5 2003/12/10 07:22:44 itojun Exp $	*/
/*	$NetBSD: tuba_usrreq.c,v 1.8 1996/02/13 22:12:40 christos Exp $	*/

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)tuba_usrreq.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/stat.h>

#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_debug.h>

#include <netiso/argo_debug.h>
#include <netiso/iso.h>
#include <netiso/clnp.h>
#include <netiso/iso_pcb.h>
#include <netiso/iso_var.h>
#include <netiso/tuba_table.h>
/*
 * TCP protocol interface to socket abstraction.
 */
extern char    *tcpstates[];
extern struct inpcbtable tuba_inpcb;
extern struct isopcb tuba_isopcb;

/*
 * Process a TCP user request for TCP tb.  If this is a send request
 * then m is the mbuf chain of send data.  If this is a timer expiration
 * (called from the software clock routine), then timertype tells which timer.
 */
/* ARGSUSED */
int
tuba_usrreq(so, req, m, nam, control)
	struct socket  *so;
	int             req;
	struct mbuf    *m, *nam, *control;
{
	struct inpcb *inp;
	struct isopcb *isop = NULL;
	struct tcpcb *tp = NULL;
	int             s;
	int             error = 0;
	int             ostate;
	struct sockaddr_iso *siso;

	if (req == PRU_CONTROL)
		return (iso_control(so, (long) m, (caddr_t) nam,
				    (struct ifnet *) control));

	s = splsoftnet();
	inp = sotoinpcb(so);
	/*
	 * When a TCP is attached to a socket, then there will be
	 * a (struct inpcb) pointed at by the socket, and this
	 * structure will point at a subsidary (struct tcpcb).
	 */
	if (inp == 0 && req != PRU_ATTACH) {
		splx(s);
		return (EINVAL);/* XXX */
	}
	if (inp) {
		tp = intotcpcb(inp);
		if (tp == 0)
			panic("tuba_usrreq");
		ostate = tp->t_state;
		isop = (struct isopcb *) tp->t_tuba_pcb;
		if (isop == 0)
			panic("tuba_usrreq 2");
	} else
		ostate = 0;
	switch (req) {

		/*
		 * TCP attaches to socket via PRU_ATTACH, reserving space,
		 * and an internet control block.  We also need to
		 * allocate an isopcb and separate the control block from
		 * tcp/ip ones.
		 */
	case PRU_ATTACH:
		if ((error = iso_pcballoc(so, &tuba_isopcb)) != 0)
			break;
		isop = (struct isopcb *) so->so_pcb;
		so->so_pcb = 0;
		if ((error = tcp_usrreq(so, req, m, nam, control)) != 0) {
			isop->isop_socket = 0;
			iso_pcbdetach(isop);
		} else {
			inp = sotoinpcb(so);
			CIRCLEQ_REMOVE(&inp->inp_table->inpt_queue, inp,
				       inp_queue);
			CIRCLEQ_INSERT_HEAD(&tuba_inpcb.inpt_queue, inp,
					    inp_queue);
			inp->inp_table = &tuba_inpcb;
			tp = intotcpcb(inp);
			if (tp == 0)
				panic("tuba_usrreq 3");
			tp->t_tuba_pcb = (caddr_t) isop;
		}
		goto notrace;

		/*
		 * PRU_DETACH detaches the TCP protocol from the socket.
		 * If the protocol state is non-embryonic, then can't
		 * do this directly: have to initiate a PRU_DISCONNECT,
		 * which may finish later; embryonic TCB's can just
		 * be discarded here.
		 */
	case PRU_DETACH:
		if (tp->t_state > TCPS_LISTEN)
			tp = tcp_disconnect(tp);
		else
			tp = tcp_close(tp);
		if (tp == 0)
			tuba_pcbdetach(isop);
		break;

		/*
		 * Give the socket an address.
		 */
	case PRU_BIND:
		siso = mtod(nam, struct sockaddr_iso *);
		if (siso->siso_tlen && siso->siso_tlen != 2) {
			error = EINVAL;
			break;
		}
		if ((error = iso_pcbbind(isop, nam)) ||
		    (siso = isop->isop_laddr) == 0)
			break;
		bcopy(TSEL(siso), &inp->inp_lport, 2);
		if (siso->siso_nlen &&
		    !(inp->inp_laddr.s_addr = tuba_lookup(siso, M_WAITOK)))
			error = ENOBUFS;
		break;

		/*
		 * Prepare to accept connections.
		 */
	case PRU_CONNECT:
	case PRU_LISTEN:
		if (inp->inp_lport == 0 &&
		    (error = iso_pcbbind(isop, NULL)))
			break;
		bcopy(TSEL(isop->isop_laddr), &inp->inp_lport, 2);
		if (req == PRU_LISTEN) {
			tp->t_state = TCPS_LISTEN;
			break;
		}
		/* FALLTHROUGH */
		/*
		 * Initiate connection to peer.
		 * Create a template for use in transmissions on this connection.
		 * Enter SYN_SENT state, and mark socket as connecting.
		 * Start keep-alive timer, and seed output sequence space.
		 * Send initial segment on connection.
		 */
		/* case PRU_CONNECT: */
		if ((error = iso_pcbconnect(isop, nam)) != 0)
			break;
		if ((siso = isop->isop_laddr) && siso->siso_nlen > 1)
			siso->siso_data[siso->siso_nlen - 1] = ISOPROTO_TCP;
		else
			panic("tuba_usrreq: connect");
		siso = mtod(nam, struct sockaddr_iso *);
		if (!(inp->inp_faddr.s_addr = tuba_lookup(siso, M_WAITOK))) {
	unconnect:
			iso_pcbdisconnect(isop);
			error = ENOBUFS;
			break;
		}
		bcopy(TSEL(isop->isop_faddr), &inp->inp_fport, 2);
		if (inp->inp_laddr.s_addr == 0 &&
		    (inp->inp_laddr.s_addr =
		     tuba_lookup(isop->isop_laddr, M_WAITOK)) == 0)
			goto unconnect;
		if ((tp->t_template = tcp_template(tp)) == 0)
			goto unconnect;
		soisconnecting(so);
		tcpstat.tcps_connattempt++;
		tp->t_state = TCPS_SYN_SENT;
		tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
		tp->iss = tcp_iss;
		tcp_iss += TCP_ISSINCR / 2;
		tcp_sendseqinit(tp);
		error = tcp_output(tp);
		tuba_refcnt(isop, 1);
		break;

		/*
		 * Initiate disconnect from peer.
		 * If connection never passed embryonic stage, just drop;
		 * else if don't need to let data drain, then can just drop anyways,
		 * else have to begin TCP shutdown process: mark socket disconnecting,
		 * drain unread data, state switch to reflect user close, and
		 * send segment (e.g. FIN) to peer.  Socket will be really disconnected
		 * when peer sends FIN and acks ours.
		 *
		 * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
		 */
	case PRU_DISCONNECT:
		if ((tp = tcp_disconnect(tp)) == 0)
			tuba_pcbdetach(isop);
		break;

		/*
		 * Accept a connection.  Essentially all the work is
		 * done at higher levels; just return the address
		 * of the peer, storing through addr.
		 */
	case PRU_ACCEPT:
		bcopy((caddr_t) isop->isop_faddr, mtod(nam, caddr_t),
		      nam->m_len = isop->isop_faddr->siso_len);
		break;

		/*
		 * Mark the connection as being incapable of further output.
		 */
	case PRU_SHUTDOWN:
		if (so->so_state & SS_CANTSENDMORE)
			break;
		socantsendmore(so);
		tp = tcp_usrclosed(tp);
		if (tp)
			error = tcp_output(tp);
		else
			tuba_pcbdetach(isop);
		break;
		/*
		 * Abort the TCP.
		 */
	case PRU_ABORT:
		if ((tp = tcp_drop(tp, ECONNABORTED)) == 0)
			tuba_pcbdetach(isop);
		break;


	case PRU_SOCKADDR:
		if (isop->isop_laddr)
			bcopy((caddr_t) isop->isop_laddr, mtod(nam, caddr_t),
			      nam->m_len = isop->isop_laddr->siso_len);
		break;

	case PRU_PEERADDR:
		if (isop->isop_faddr)
			bcopy((caddr_t) isop->isop_faddr, mtod(nam, caddr_t),
			      nam->m_len = isop->isop_faddr->siso_len);
		break;

	default:
		error = tcp_usrreq(so, req, m, nam, control);
		goto notrace;
	}
	if (tp && (so->so_options & SO_DEBUG))
		tcp_trace(TA_USER, ostate, tp, (struct tcpiphdr *) 0, req);
notrace:
	splx(s);
	return (error);
}

int
tuba_ctloutput(op, so, level, optname, mp)
	int             op;
	struct socket  *so;
	int             level, optname;
	struct mbuf   **mp;
{
	if (level != IPPROTO_TCP)
		return rclnp_ctloutput(op, so, level, optname, mp);
	else
		return tcp_ctloutput(op, so, level, optname, mp);
}
@


1.5
log
@de-register.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: tuba_usrreq.c,v 1.4 2003/06/02 23:28:18 millert Exp $	*/
@


1.4
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: tuba_usrreq.c,v 1.3 1998/01/03 22:32:56 deraadt Exp $	*/
d86 3
a88 3
	register struct inpcb *inp;
	register struct isopcb *isop = NULL;
	register struct tcpcb *tp = NULL;
@


1.3
log
@ignore PRU_SHUTDOWN if socket is already shutdown
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d16 1
a16 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3.10.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: tuba_usrreq.c,v 1.3 1998/01/03 22:32:56 deraadt Exp $	*/
d16 5
a20 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.10.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 3
a88 3
	struct inpcb *inp;
	struct isopcb *isop = NULL;
	struct tcpcb *tp = NULL;
@


1.2
log
@Initial commit of NetBSD 960217 netiso.
all the rest is the fixes to the import by Niklas.
@
text
@d270 2
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: tuba_usrreq.c,v 1.7 1995/08/12 23:59:55 mycroft Exp $	*/
d74 3
a76 3
extern	char *tcpstates[];
extern	struct inpcbtable tuba_inpcb;
extern	struct isopcb tuba_isopcb;
d83 2
a84 1
/*ARGSUSED*/
d86 3
a88 3
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
d91 5
a95 5
	register struct isopcb *isop;
	register struct tcpcb *tp;
	int s;
	int error = 0;
	int ostate;
d99 2
a100 2
		return (iso_control(so, (long)m, (caddr_t)nam,
			(struct ifnet *)control));
d109 1
a109 1
	if (inp == 0  && req != PRU_ATTACH) {
d111 1
a111 1
		return (EINVAL);		/* XXX */
d118 1
a118 1
		isop = (struct isopcb *)tp->t_tuba_pcb;
d125 6
a130 6
	/*
	 * TCP attaches to socket via PRU_ATTACH, reserving space,
	 * and an internet control block.  We also need to
	 * allocate an isopcb and separate the control block from
	 * tcp/ip ones.
	 */
d132 1
a132 1
		if (error = iso_pcballoc(so, &tuba_isopcb))
d134 1
a134 1
		isop = (struct isopcb *)so->so_pcb;
d136 1
a136 1
		if (error = tcp_usrreq(so, req, m, nam, control)) {
d142 1
a142 1
			    inp_queue);
d144 1
a144 1
			    inp_queue);
d153 7
a159 7
	/*
	 * PRU_DETACH detaches the TCP protocol from the socket.
	 * If the protocol state is non-embryonic, then can't
	 * do this directly: have to initiate a PRU_DISCONNECT,
	 * which may finish later; embryonic TCB's can just
	 * be discarded here.
	 */
d169 3
a171 3
	/*
	 * Give the socket an address.
	 */
d178 1
a178 1
		if ((error = iso_pcbbind(isop, nam)) || 
d187 3
a189 3
	/*
	 * Prepare to accept connections.
	 */
d193 1
a193 1
		    (error = iso_pcbbind(isop, (struct mbuf *)0)))
d200 10
a209 10
	/*FALLTHROUGH*/
	/*
	 * Initiate connection to peer.
	 * Create a template for use in transmissions on this connection.
	 * Enter SYN_SENT state, and mark socket as connecting.
	 * Start keep-alive timer, and seed output sequence space.
	 * Send initial segment on connection.
	 */
	/* case PRU_CONNECT: */
		if (error = iso_pcbconnect(isop, nam))
d217 1
a217 1
		unconnect:
d224 2
a225 2
		     (inp->inp_laddr.s_addr = 
			    tuba_lookup(isop->isop_laddr, M_WAITOK)) == 0)
d233 2
a234 1
		tp->iss = tcp_iss; tcp_iss += TCP_ISSINCR/2;
d240 11
a250 11
	/*
	 * Initiate disconnect from peer.
	 * If connection never passed embryonic stage, just drop;
	 * else if don't need to let data drain, then can just drop anyways,
	 * else have to begin TCP shutdown process: mark socket disconnecting,
	 * drain unread data, state switch to reflect user close, and
	 * send segment (e.g. FIN) to peer.  Socket will be really disconnected
	 * when peer sends FIN and acks ours.
	 *
	 * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
	 */
d256 5
a260 5
	/*
	 * Accept a connection.  Essentially all the work is
	 * done at higher levels; just return the address
	 * of the peer, storing through addr.
	 */
d262 2
a263 2
		bcopy((caddr_t)isop->isop_faddr, mtod(nam, caddr_t),
			nam->m_len = isop->isop_faddr->siso_len);
d266 3
a268 3
	/*
	 * Mark the connection as being incapable of further output.
	 */
d277 3
a279 3
	/*
	 * Abort the TCP.
	 */
d288 2
a289 2
			bcopy((caddr_t)isop->isop_laddr, mtod(nam, caddr_t),
				nam->m_len = isop->isop_laddr->siso_len);
d294 2
a295 2
			bcopy((caddr_t)isop->isop_faddr, mtod(nam, caddr_t),
				nam->m_len = isop->isop_faddr->siso_len);
d303 1
a303 1
		tcp_trace(TA_USER, ostate, tp, (struct tcpiphdr *)0, req);
d306 1
a306 1
	return(error);
d309 1
d311 4
a314 4
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d316 4
a319 4
	int clnp_ctloutput(), tcp_ctloutput();

	return ((level != IPPROTO_TCP ? clnp_ctloutput : tcp_ctloutput)
			(op, so, level, optname, mp));
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
