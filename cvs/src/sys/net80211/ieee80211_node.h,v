head	1.68;
access;
symbols
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.60.0.2
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.46.0.6
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.2
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.44.0.6
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.4
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.41.0.10
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.41.0.8
	OPENBSD_4_9_BASE:1.41
	OPENBSD_4_8:1.41.0.6
	OPENBSD_4_8_BASE:1.41
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.41.0.4
	OPENBSD_4_6_BASE:1.41
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.68
date	2017.03.12.03.13.50;	author stsp;	state Exp;
branches;
next	1.67;
commitid	iIk6bEDpMYi2n0yI;

1.67
date	2017.03.04.12.44.27;	author stsp;	state Exp;
branches;
next	1.66;
commitid	18dFS4hxKhmyoW32;

1.66
date	2017.03.01.19.28.48;	author stsp;	state Exp;
branches;
next	1.65;
commitid	ziqUM3IRerOy1q1r;

1.65
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.64;
commitid	PETPfbQ5ZWdJqIYS;

1.64
date	2017.01.09.20.18.59;	author stsp;	state Exp;
branches;
next	1.63;
commitid	cqn8VXxfpVIojpbn;

1.63
date	2016.09.21.12.21.27;	author stsp;	state Exp;
branches;
next	1.62;
commitid	ExqBSY6QNe8gxCt8;

1.62
date	2016.09.20.13.24.42;	author stsp;	state Exp;
branches;
next	1.61;
commitid	5T5FK9pNEKxdvb99;

1.61
date	2016.09.15.03.32.48;	author dlg;	state Exp;
branches;
next	1.60;
commitid	prdL2stxGjOBR6s3;

1.60
date	2016.04.28.08.18.10;	author stsp;	state Exp;
branches
	1.60.2.1;
next	1.59;
commitid	NT7Z6NK9H28KEHUj;

1.59
date	2016.02.11.17.15.43;	author stsp;	state Exp;
branches
	1.59.2.1;
next	1.58;
commitid	Z5Amp1zl34DneeCP;

1.58
date	2016.02.08.01.00.47;	author stsp;	state Exp;
branches;
next	1.57;
commitid	t6UAoTbJMjqNPVER;

1.57
date	2016.02.08.00.54.57;	author stsp;	state Exp;
branches;
next	1.56;
commitid	3JZeHvAofgIJAyva;

1.56
date	2016.02.05.16.07.57;	author stsp;	state Exp;
branches;
next	1.55;
commitid	xkYUdKYZXQrBH3Sl;

1.55
date	2016.02.04.16.23.40;	author stsp;	state Exp;
branches;
next	1.54;
commitid	CoUDEKOEoQ2LZ3mp;

1.54
date	2016.02.01.18.43.22;	author stsp;	state Exp;
branches;
next	1.53;
commitid	4NOoNc6ASRY2FA63;

1.53
date	2016.01.25.15.10.37;	author stsp;	state Exp;
branches;
next	1.52;
commitid	hMc0oSgmsLkJIc3U;

1.52
date	2016.01.07.23.22.31;	author stsp;	state Exp;
branches;
next	1.51;
commitid	fZfOIgRYw9oUaCc3;

1.51
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.50;
commitid	2QagMjdMhQhIaQgu;

1.50
date	2015.12.12.11.25.46;	author stsp;	state Exp;
branches;
next	1.49;
commitid	yJtuIKjLQDddhkbQ;

1.49
date	2015.11.15.12.34.07;	author stsp;	state Exp;
branches;
next	1.48;
commitid	H9x7JLZ3OXXsR8Zh;

1.48
date	2015.11.15.10.07.03;	author stsp;	state Exp;
branches;
next	1.47;
commitid	Nt1Hw5JFHrcEBdto;

1.47
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.46;
commitid	YT6fyIEviv9qwbl6;

1.46
date	2014.09.12.16.02.40;	author sthen;	state Exp;
branches;
next	1.45;
commitid	aKTqOYHA8eIImugJ;

1.45
date	2014.03.20.13.19.06;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.24.17.01.23;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2012.11.07.19.41.25;	author stsp;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.21.19.42.16;	author stsp;	state Exp;
branches;
next	1.41;

1.41
date	2009.03.26.20.38.29;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.26.20.34.54;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.28.17.15.21;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.26.21.55.58;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.26.21.28.55;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.12.14.10.17.24;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.12.18.22.41;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.02.08.24.15;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.02.08.20.16;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.27.18.24.01;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.11.03.14.59.55;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.01.22.34.19;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.27.20.14.21;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.27.18.53.27;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.03.16.51.06;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.01.15.40.40;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.01.12.32.26;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.28.11.09.03;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.06.18.18.43;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.03.19.44.54;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.17.09.05.44;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.16.13.21.44;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.07.20.24.42;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.26.11.14.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.08.08.36.12;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.59.2.1
date	2017.03.01.20.57.29;	author benno;	state Exp;
branches;
next	;
commitid	Yy9A53bTb4WnX3us;

1.60.2.1
date	2017.03.01.20.57.51;	author benno;	state Exp;
branches;
next	;
commitid	ChXblF78aIW5HGQF;


desc
@@


1.68
log
@Introduce separate fields for supported WPA protocols and AKMs in struct
ieee80211_node. Pass these fields to 'ifconfig scan' instead of giving it
currently configured/enabled settings.
Fixes display of AP WPA capabilities in 'ifconfig scan' while the wifi
interface is not configured to use WPA (my previous commit attempted to
fix the same problem but didn't make it work in all cases).
ok tb@@
@
text
@/*	$OpenBSD: ieee80211_node.h,v 1.67 2017/03/04 12:44:27 stsp Exp $	*/
/*	$NetBSD: ieee80211_node.h,v 1.9 2004/04/30 22:57:32 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net80211/ieee80211_node.h,v 1.10 2004/04/05 22:10:26 sam Exp $
 */
#ifndef _NET80211_IEEE80211_NODE_H_
#define _NET80211_IEEE80211_NODE_H_

#include <sys/tree.h>

#define	IEEE80211_PSCAN_WAIT	5		/* passive scan wait */
#define	IEEE80211_TRANS_WAIT	5		/* transition wait */
#define	IEEE80211_INACT_WAIT	5		/* inactivity timer interval */
#define	IEEE80211_INACT_MAX	(300/IEEE80211_INACT_WAIT)
#define	IEEE80211_CACHE_SIZE	100
#define	IEEE80211_CACHE_WAIT	30

struct ieee80211_rateset {
	u_int8_t		rs_nrates;
	u_int8_t		rs_rates[IEEE80211_RATE_MAXSIZE];
};

extern const struct ieee80211_rateset ieee80211_std_rateset_11a;
extern const struct ieee80211_rateset ieee80211_std_rateset_11b;
extern const struct ieee80211_rateset ieee80211_std_rateset_11g;

enum ieee80211_node_state {
	IEEE80211_STA_CACHE,	/* cached node */
	IEEE80211_STA_BSS,	/* ic->ic_bss, the network we joined */
	IEEE80211_STA_AUTH,	/* successfully authenticated */
	IEEE80211_STA_ASSOC,	/* successfully associated */
	IEEE80211_STA_COLLECT	/* This node remains in the cache while
				 * the driver sends a de-auth message;
				 * afterward it should be freed to make room
				 * for a new node.
				 */
};

#define	ieee80211_node_newstate(__ni, __state)	\
	do {					\
		(__ni)->ni_state = (__state);	\
	} while (0)

enum ieee80211_node_psstate {
	IEEE80211_PS_AWAKE,
	IEEE80211_PS_DOZE
};

#define	IEEE80211_PS_MAX_QUEUE	50	/* maximum saved packets */

/* Authenticator state machine: 4-Way Handshake (see 8.5.6.1.1) */
enum {
	RSNA_INITIALIZE,
	RSNA_AUTHENTICATION,
	RSNA_AUTHENTICATION_2,
	RSNA_INITPMK,
	RSNA_INITPSK,
	RSNA_PTKSTART,
	RSNA_PTKCALCNEGOTIATING,
	RSNA_PTKCALCNEGOTIATING_2,
	RSNA_PTKINITNEGOTIATING,
	RSNA_PTKINITDONE,
	RSNA_DISCONNECT,
	RSNA_DISCONNECTED
};

/* Authenticator state machine: Group Key Handshake (see 8.5.6.1.2) */
enum {
	RSNA_IDLE,
	RSNA_REKEYNEGOTIATING,
	RSNA_REKEYESTABLISHED,
	RSNA_KEYERROR
};

/* Supplicant state machine: 4-Way Handshake (not documented in standard) */
enum {
	RSNA_SUPP_INITIALIZE,		/* not expecting any messages */
	RSNA_SUPP_PTKSTART,		/* awaiting handshake message 1 */
	RSNA_SUPP_PTKNEGOTIATING,	/* got message 1 and derived PTK */
	RNSA_SUPP_PTKDONE		/* got message 3 and authenticated AP */
};

struct ieee80211_rxinfo {
	u_int32_t		rxi_flags;
	u_int32_t		rxi_tstamp;
	int			rxi_rssi;
};
#define IEEE80211_RXI_HWDEC		0x00000001
#define IEEE80211_RXI_AMPDU_DONE	0x00000002

/* Block Acknowledgement Record */
struct ieee80211_tx_ba {
	struct ieee80211_node	*ba_ni;	/* backpointer for callbacks */
	struct timeout		ba_to;
	int			ba_timeout_val;
	int			ba_state;
#define IEEE80211_BA_INIT	0
#define IEEE80211_BA_REQUESTED	1
#define IEEE80211_BA_AGREED	2

	/* ADDBA parameter set field for this BA agreement. */
	u_int16_t		ba_params;

	/* These values are IEEE802.11 frame sequence numbers (0x0-0xfff) */
	u_int16_t		ba_winstart;
	u_int16_t		ba_winend;

	/* Number of A-MPDU subframes in reorder buffer. */
	u_int16_t		ba_winsize;
#define IEEE80211_BA_MAX_WINSZ	64	/* corresponds to maximum ADDBA BUFSZ */

	u_int8_t		ba_token;
};

struct ieee80211_rx_ba {
	struct ieee80211_node	*ba_ni;	/* backpointer for callbacks */
	struct {
		struct mbuf		*m;
		struct ieee80211_rxinfo	rxi;
	}			*ba_buf;
	struct timeout		ba_to;
	int			ba_timeout_val;
	int			ba_state;
	u_int16_t		ba_params;
	u_int16_t		ba_winstart;
	u_int16_t		ba_winend;
	u_int16_t		ba_winsize;
	u_int16_t		ba_head;
	struct timeout		ba_gap_to;
#define IEEE80211_BA_GAP_TIMEOUT	300 /* msec */
	/* Counter for consecutive frames which missed the BA window. */
	int			ba_winmiss;
	/* Sequence number of previous frame which missed the BA window. */
	uint16_t		ba_missedsn;
	/* Window moves forward after this many frames have missed it. */
#define IEEE80211_BA_MAX_WINMISS	8

	uint8_t			ba_token;
};

/*
 * Node specific information.  Note that drivers are expected
 * to derive from this structure to add device-specific per-node
 * state.  This is done by overriding the ic_node_* methods in
 * the ieee80211com structure.
 */
struct ieee80211_node {
	RBT_ENTRY(ieee80211_node)	ni_node;

	struct ieee80211com	*ni_ic;		/* back-pointer */

	u_int			ni_refcnt;
	u_int			ni_scangen;	/* gen# for timeout scan */

	/* hardware */
	u_int32_t		ni_rstamp;	/* recv timestamp */
	u_int8_t		ni_rssi;	/* recv ssi */

	/* header */
	u_int8_t		ni_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t		ni_bssid[IEEE80211_ADDR_LEN];

	/* beacon, probe response */
	u_int8_t		ni_tstamp[8];	/* from last rcv'd beacon */
	u_int16_t		ni_intval;	/* beacon interval */
	u_int16_t		ni_capinfo;	/* capabilities */
	u_int8_t		ni_esslen;
	u_int8_t		ni_essid[IEEE80211_NWID_LEN];
	struct ieee80211_rateset ni_rates;	/* negotiated rate set */
	u_int8_t		*ni_country;	/* country information XXX */
	struct ieee80211_channel *ni_chan;
	u_int8_t		ni_erp;		/* 11g only */

	/* DTIM and contention free period (CFP) */
	u_int8_t		ni_dtimcount;
	u_int8_t		ni_dtimperiod;
#ifdef notyet
	u_int8_t		ni_cfpperiod;	/* # of DTIMs between CFPs */
	u_int16_t		ni_cfpduremain;	/* remaining cfp duration */
	u_int16_t		ni_cfpmaxduration;/* max CFP duration in TU */
	u_int16_t		ni_nextdtim;	/* time to next DTIM */
	u_int16_t		ni_timoffset;
#endif

	/* power saving mode */
	u_int8_t		ni_pwrsave;
	struct mbuf_queue	ni_savedq;	/* packets queued for pspoll */

	/* RSN */
	struct timeout		ni_eapol_to;
	u_int			ni_rsn_state;
	u_int			ni_rsn_supp_state;
	u_int			ni_rsn_gstate;
	u_int			ni_rsn_retries;
	u_int			ni_supported_rsnprotos;
	u_int			ni_rsnprotos;
	u_int			ni_supported_rsnakms;
	u_int			ni_rsnakms;
	u_int			ni_rsnciphers;
	enum ieee80211_cipher	ni_rsngroupcipher;
	enum ieee80211_cipher	ni_rsngroupmgmtcipher;
	u_int16_t		ni_rsncaps;
	enum ieee80211_cipher	ni_rsncipher;
	u_int8_t		ni_nonce[EAPOL_KEY_NONCE_LEN];
	u_int8_t		ni_pmk[IEEE80211_PMK_LEN];
	u_int8_t		ni_pmkid[IEEE80211_PMKID_LEN];
	u_int64_t		ni_replaycnt;
	u_int8_t		ni_replaycnt_ok;
	u_int64_t		ni_reqreplaycnt;
	u_int8_t		ni_reqreplaycnt_ok;
	u_int8_t		*ni_rsnie;
	struct ieee80211_key	ni_pairwise_key;
	struct ieee80211_ptk	ni_ptk;
	u_int8_t		ni_key_count;
	int			ni_port_valid;

	/* SA Query */
	u_int16_t		ni_sa_query_trid;
	struct timeout		ni_sa_query_to;
	int			ni_sa_query_count;

	/* HT capabilities */
	uint16_t		ni_htcaps;
	uint8_t			ni_ampdu_param;
	uint8_t			ni_rxmcs[howmany(80,NBBY)];
	uint16_t		ni_max_rxrate;	/* in Mb/s, 0 <= rate <= 1023 */
	uint8_t			ni_tx_mcs_set;
	uint16_t		ni_htxcaps;
	uint32_t		ni_txbfcaps;
	uint8_t			ni_aselcaps;

	/* HT operation */
	uint8_t			ni_primary_chan; /* XXX corresponds to ni_chan */
	uint8_t			ni_htop0;
	uint16_t		ni_htop1;
	uint16_t		ni_htop2;
	uint8_t			ni_basic_mcs[howmany(128,NBBY)];

	/* Block Ack records */
	struct ieee80211_tx_ba	ni_tx_ba[IEEE80211_NUM_TID];
	struct ieee80211_rx_ba	ni_rx_ba[IEEE80211_NUM_TID];

	int			ni_txmcs;	/* current MCS used for TX */

	/* others */
	u_int16_t		ni_associd;	/* assoc response */
	u_int16_t		ni_txseq;	/* seq to be transmitted */
	u_int16_t		ni_rxseq;	/* seq previous received */
	u_int16_t		ni_qos_txseqs[IEEE80211_NUM_TID];
	u_int16_t		ni_qos_rxseqs[IEEE80211_NUM_TID];
	int			ni_fails;	/* failure count to associate */
	int			ni_inact;	/* inactivity mark count */
	int			ni_txrate;	/* index to ni_rates[] */
	int			ni_state;

	u_int16_t		ni_flags;	/* special-purpose state */
#define IEEE80211_NODE_ERP		0x0001
#define IEEE80211_NODE_QOS		0x0002
#define IEEE80211_NODE_REKEY		0x0004	/* GTK rekeying in progress */
#define IEEE80211_NODE_RXPROT		0x0008	/* RX protection ON */
#define IEEE80211_NODE_TXPROT		0x0010	/* TX protection ON */
#define IEEE80211_NODE_TXRXPROT	\
	(IEEE80211_NODE_TXPROT | IEEE80211_NODE_RXPROT)
#define IEEE80211_NODE_RXMGMTPROT	0x0020	/* RX MMPDU protection ON */
#define IEEE80211_NODE_TXMGMTPROT	0x0040	/* TX MMPDU protection ON */
#define IEEE80211_NODE_MFP		0x0080	/* MFP negotiated */
#define IEEE80211_NODE_PMK		0x0100	/* ni_pmk set */
#define IEEE80211_NODE_PMKID		0x0200	/* ni_pmkid set */
#define IEEE80211_NODE_HT		0x0400	/* HT negotiated */
#define IEEE80211_NODE_SA_QUERY		0x0800	/* SA Query in progress */
#define IEEE80211_NODE_SA_QUERY_FAILED	0x1000	/* last SA Query failed */
};

RBT_HEAD(ieee80211_tree, ieee80211_node);

static __inline void
ieee80211_node_incref(struct ieee80211_node *ni)
{
	int		s;

	s = splnet();
	ni->ni_refcnt++;
	splx(s);
}

static __inline u_int
ieee80211_node_decref(struct ieee80211_node *ni)
{
	u_int		refcnt;
	int 		s;

	s = splnet();
	refcnt = --ni->ni_refcnt;
	splx(s);
	return refcnt;
}

static __inline struct ieee80211_node *
ieee80211_ref_node(struct ieee80211_node *ni)
{
	ieee80211_node_incref(ni);
	return ni;
}

static __inline void
ieee80211_unref_node(struct ieee80211_node **ni)
{
	ieee80211_node_decref(*ni);
	*ni = NULL;			/* guard against use */
}

struct ieee80211com;

#ifdef MALLOC_DECLARE
MALLOC_DECLARE(M_80211_NODE);
#endif

extern	void ieee80211_node_attach(struct ifnet *);
extern	void ieee80211_node_lateattach(struct ifnet *);
extern	void ieee80211_node_detach(struct ifnet *);

extern	void ieee80211_begin_scan(struct ifnet *);
extern	void ieee80211_next_scan(struct ifnet *);
extern	void ieee80211_end_scan(struct ifnet *);
extern	void ieee80211_reset_scan(struct ifnet *);
extern	struct ieee80211_node *ieee80211_alloc_node(struct ieee80211com *,
		const u_int8_t *);
extern	struct ieee80211_node *ieee80211_dup_bss(struct ieee80211com *,
		const u_int8_t *);
extern	struct ieee80211_node *ieee80211_find_node(struct ieee80211com *,
		const u_int8_t *);
extern	struct ieee80211_node *ieee80211_find_rxnode(struct ieee80211com *,
		const struct ieee80211_frame *);
extern	struct ieee80211_node *ieee80211_find_txnode(struct ieee80211com *,
		const u_int8_t *);
extern	struct ieee80211_node *
		ieee80211_find_node_for_beacon(struct ieee80211com *,
		const u_int8_t *, const struct ieee80211_channel *,
		const char *, u_int8_t);
extern	void ieee80211_release_node(struct ieee80211com *,
		struct ieee80211_node *);
extern	void ieee80211_free_allnodes(struct ieee80211com *);
typedef void ieee80211_iter_func(void *, struct ieee80211_node *);
extern	void ieee80211_iterate_nodes(struct ieee80211com *ic,
		ieee80211_iter_func *, void *);
extern	void ieee80211_clean_cached(struct ieee80211com *ic);
extern	void ieee80211_clean_nodes(struct ieee80211com *, int);
void ieee80211_setup_htcaps(struct ieee80211_node *, const uint8_t *,
    uint8_t);
void ieee80211_clear_htcaps(struct ieee80211_node *);
int ieee80211_setup_htop(struct ieee80211_node *, const uint8_t *,
    uint8_t);
extern	int ieee80211_setup_rates(struct ieee80211com *,
	    struct ieee80211_node *, const u_int8_t *, const u_int8_t *, int);
extern  int ieee80211_iserp_sta(const struct ieee80211_node *);
extern void ieee80211_count_longslotsta(void *, struct ieee80211_node *);
extern void ieee80211_count_nonerpsta(void *, struct ieee80211_node *);
extern void ieee80211_count_pssta(void *, struct ieee80211_node *);
extern void ieee80211_count_rekeysta(void *, struct ieee80211_node *);
extern	void ieee80211_node_join(struct ieee80211com *,
		struct ieee80211_node *, int);
extern	void ieee80211_node_leave(struct ieee80211com *,
		struct ieee80211_node *);
extern	int ieee80211_match_bss(struct ieee80211com *,
		struct ieee80211_node *);
extern	void ieee80211_create_ibss(struct ieee80211com* ,
		struct ieee80211_channel *);
extern	void ieee80211_notify_dtim(struct ieee80211com *);
extern	void ieee80211_set_tim(struct ieee80211com *, int, int);

extern	int ieee80211_node_cmp(const struct ieee80211_node *,
		const struct ieee80211_node *);
RBT_PROTOTYPE(ieee80211_tree, ieee80211_node, ni_node, ieee80211_node_cmp);

#endif /* _NET80211_IEEE80211_NODE_H_ */
@


1.67
log
@In 11n hostap mode, dynamically adjust HT protection settings based on
the presence of non-HT nodes in the node cache.
OpenBSD 11n APs will now disable HT protection if it is not necessary.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.66 2017/03/01 19:28:48 stsp Exp $	*/
d222 1
d224 1
@


1.66
log
@Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.65 2017/02/02 16:47:53 stsp Exp $	*/
d43 1
a43 1
#define	IEEE80211_CACHE_WAIT	3600
a382 1
extern void ieee80211_count_nonhtsta(void *, struct ieee80211_node *);
@


1.65
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.64 2017/01/09 20:18:59 stsp Exp $	*/
d102 8
d219 1
@


1.64
log
@When a HT node leaves or reassociates as a non-HT node,
clear HT capabilities stored in its node cache object.

A node may switch from 11n mode to 11a/b/g mode.
If we don't clear HT capabilities from the cache the node will
be mistaken as 11n-capable after reassociation.

ok phessler@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.63 2016/09/21 12:21:27 stsp Exp $	*/
d372 5
a376 1

@


1.63
log
@When processing an ADDBA request, iwm(4) runs a task which sends a
command to the firmware and waits for confirmation. This command can
fail and there was no way we could recover from such an error.

Allow drivers to return EBUSY from their ic_ampdu_rx_start() handler to
tell the stack not to send a confirmation just yet. The stack provides
functions which the driver can call to accept or refuse the request.

There is no functional change yet. This just shuffles code around so
drivers may insert themselves into the process.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.62 2016/09/20 13:24:42 stsp Exp $	*/
d366 1
@


1.62
log
@Parse the DTIM count and period advertised in beacons and store them
in the node structure. This should be useful for iwm(4) in the future.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.61 2016/09/15 03:32:48 dlg Exp $	*/
d156 2
@


1.61
log
@move from RB macros to the RBT functions.

shaves about 5k off an amd64 GENERIC.MP kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.60 2016/04/28 08:18:10 stsp Exp $	*/
a190 1
#ifdef notyet
d192 1
d194 1
@


1.60
log
@Reduce block ack gap timeout to 300 msec in order to reduce Rx latency.
This value seems to be a sweet spot.
testing and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.59 2016/02/11 17:15:43 stsp Exp $	*/
d165 1
a165 1
	RB_ENTRY(ieee80211_node)	ni_node;
d287 1
a287 1
RB_HEAD(ieee80211_tree, ieee80211_node);
d382 1
a382 1
RB_PROTOTYPE(ieee80211_tree, ieee80211_node, ni_node, ieee80211_node_cmp);
@


1.60.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 5.9 errata 35, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.60 2016/04/28 08:18:10 stsp Exp $	*/
a101 8
/* Supplicant state machine: 4-Way Handshake (not documented in standard) */
enum {
	RSNA_SUPP_INITIALIZE,		/* not expecting any messages */
	RSNA_SUPP_PTKSTART,		/* awaiting handshake message 1 */
	RSNA_SUPP_PTKNEGOTIATING,	/* got message 1 and derived PTK */
	RNSA_SUPP_PTKDONE		/* got message 3 and authenticated AP */
};

a207 1
	u_int			ni_rsn_supp_state;
@


1.59
log
@Fix whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.58 2016/02/08 01:00:47 stsp Exp $	*/
d149 1
a149 1
#define IEEE80211_BA_GAP_TIMEOUT	500 /* msec */
@


1.59.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 6.0 errata 18, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.59 2016/02/11 17:15:43 stsp Exp $	*/
a101 8
/* Supplicant state machine: 4-Way Handshake (not documented in standard) */
enum {
	RSNA_SUPP_INITIALIZE,		/* not expecting any messages */
	RSNA_SUPP_PTKSTART,		/* awaiting handshake message 1 */
	RSNA_SUPP_PTKNEGOTIATING,	/* got message 1 and derived PTK */
	RNSA_SUPP_PTKDONE		/* got message 3 and authenticated AP */
};

a207 1
	u_int			ni_rsn_supp_state;
@


1.58
log
@Stop requiring a BlockAck session timeout (again), and just use it if the AP
is asking for it. This timeout should not be required anymore now that krw@@'s
hangs are fixed by working around APs which make sequence numbers jump about.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.57 2016/02/08 00:54:57 stsp Exp $	*/
d150 1
a150 1
 	/* Counter for consecutive frames which missed the BA window. */
d152 1
a152 1
 	/* Sequence number of previous frame which missed the BA window. */
d154 1
a154 1
 	/* Window moves forward after this many frames have missed it. */
@


1.57
log
@Work around buggy APs which occasionally emit sequence numbers much higher
than the current 11n BlockAck window. The previous code would be fooled into
moving the window forward and then drop packets until their sequence numbers
catch up with the new window, which can take several minutes.
Fixes traffic stalls observed with Broadcom APs.
ok krw@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.56 2016/02/05 16:07:57 stsp Exp $	*/
a114 3
#define IEEE80211_BA_MIN_TIMEOUT	(1000 * 1000)	/* 1 sec */
#define IEEE80211_BA_MAX_TIMEOUT	(5000 * 1000)	/* 5 sec */

@


1.56
log
@Store ADDBA request and response parameters in the block ack record of
ieee80211_node. This way, we can keep track of the ACK policy and echo
it back to the AP as required by the standard. And use the correct bit
flag for the policy -- this code was confused between BlockAck and ADDBA,
both of which have a policy bit but in different places.

Fixes apple airport APs.

tested by tb@@, krw@@, sthen@@, abieber@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.55 2016/02/04 16:23:40 stsp Exp $	*/
d153 6
@


1.55
log
@Restore the BlockAck session timer. It is still required to work around
stalled BA sessions observed with iwn(4). We can revisit this later once
the underlying problem in iwn(4) has been found.
Prompted by report from krw@@, I could reproduce the issue.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.54 2016/02/01 18:43:22 stsp Exp $	*/
d123 3
d146 1
@


1.54
log
@Stop requiring a BlockAck session timeout. We still honour the timeout if
the AP requests it, though I don't think I've ever seen one that does.
Per the 802.11-2012 spec a value of zero disables the timeout and some
APs seem to have trouble with timeouts forced onto them.
Our behaviour now matches Linux in this regard.

This gets Apple Airport APs somewhat working in 11n mode but there
is still a remaining issue with receiving frames from them.
Doesn't seem to hurt any other APs I've tried.

ok sthen@@ mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.53 2016/01/25 15:10:37 stsp Exp $	*/
d115 3
@


1.53
log
@Don't try to interpret htprot data if the last beacon didn't contain such data.
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.52 2016/01/07 23:22:31 stsp Exp $	*/
a114 3
#define IEEE80211_BA_MIN_TIMEOUT	(1000 * 1000)	/* 1 sec */
#define IEEE80211_BA_MAX_TIMEOUT	(5000 * 1000)	/* 5 sec */

@


1.52
log
@Make the A-MPDU reordering buffer more resilient against APs which drop
some subframes or let the sequence number jump up by more than 1 (hard
to tell which it is). We decrease the BA inactivity timeout for quicker
recovery from stalled BA sessions, and add a new timeout which keeps track
of gaps in the subframe sequence number space due to dropped frames.
Gaps expire after 500 msec, the same value FreeBSD uses for their
implementation of this workaround. And Linux uses this trick, too.

This should fix network stalls some people have been seeing in 11n mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.51 2016/01/05 18:41:16 stsp Exp $	*/
d356 1
a356 1
void ieee80211_setup_htop(struct ieee80211_node *, const uint8_t *,
@


1.51
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.50 2015/12/12 11:25:46 stsp Exp $	*/
d115 2
a116 2
#define IEEE80211_BA_MIN_TIMEOUT	(10 * 1000 * 1000)	/* 10 sec */
#define IEEE80211_BA_MAX_TIMEOUT	(60 * 1000 * 1000)	/* 60 sec */
d123 1
d126 2
d129 1
a129 1
#define IEEE80211_BA_MAX_WINSZ	128	/* maximum we will accept */
d147 2
@


1.50
log
@Finish support for receiving 11n A-MPDUs.

The initial implementation was added by damien@@ years ago.
Summary of the changes made in this commit:
 - In ieee80211_input(), process A-MPDUs before duplicate detection.
 - Don't forget to set ba->ba_ni in ieee80211_recv_addba_req()
   so we don't crash in ieee80211_rx_ba_timeout().
 - In ieee80211_recv_addba_req(), tweak the logic to deny BlockAck
   requests if the driver has no callback for doing so.
 - Implement ieee80211_ba_del() which cleans up BlockAck state.
 - Increase the minimum and maximum lifetime for BlockAck agrements.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.49 2015/11/15 12:34:07 stsp Exp $	*/
a222 1
#ifndef IEEE80211_NO_HT
a244 1
#endif
a348 1
#ifndef IEEE80211_NO_HT
a352 1
#endif 
@


1.49
log
@Expose 11n mode to the ifmedia layer and introduce the concept of MCS.
Make sure 11n features are enabled only if media type is autoselect or 11n.

11n mode uses MCS (modulation & coding scheme) instead of rates like 11a/b/g.
This means we'll have to take the current mode into account and decide whether
to use a rate or an MCS for transmission. Receiving frames on legacy rates
will still work in 11n mode. We just won't be using legacy rates to send
data frames to an STA or AP we negotiated 11n features with.

My initial plan was to grow the ieee80211_rateset structure and treat MCS
just like rates. However, ieee80211_rateset corresponds to rates and xrates
elements in management frames and is copied directly into such elements
so its size cannot change. Thus, MCS stands on its own and corresponds to
elements in management frames related to 11n HT capabilities.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.48 2015/11/15 10:07:03 stsp Exp $	*/
d115 2
a116 2
#define IEEE80211_BA_MIN_TIMEOUT	(10 * 1000)		/* 10msec */
#define IEEE80211_BA_MAX_TIMEOUT	(10 * 1000 * 1000)	/* 10sec */
@


1.48
log
@Extend struct ieee80211_node with fields for 11n STA HT capabilities and
HT operational information sent by 11n APs. These fields reflect the structure
of elements in management frames so that IEEE80211_HTCAP* and IEEE80211_HTOP*
macros designed to operate on frame elements can be used directly to read
or set the fields.

Populate nodes with HT information received in probe responses, probe
requests, and association requests.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.47 2015/11/04 12:12:00 dlg Exp $	*/
d244 2
@


1.47
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.46 2014/09/12 16:02:40 sthen Exp $	*/
d223 18
d244 1
d349 6
@


1.46
log
@Remove cached 802.11 nodes in IEEE80211_STA_CACHE state (these are nodes
which have been seen but which haven't otherwise interacted with us), fixing
a problem where old cached nodes are seen when doing a scan.
From Marcin Piotr Pawlowski, feedback stsp@@ ok kspillner@@ dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.45 2014/03/20 13:19:06 mpi Exp $	*/
d191 1
a191 1
	struct ifqueue		ni_savedq;	/* packets queued for pspoll */
@


1.45
log
@Do not pull <sys/tree.h> unconditionally in <net/if.h>, only the address
tree and the 80211 nodes need it.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.44 2013/03/24 17:01:23 claudio Exp $	*/
d328 1
@


1.44
log
@Make ieee80211_set_tim() available from outside of ieee80211_node.c
so drivers like acx(4) can use that function directly instead of
reimplementing the function again. Requested by kettenis@@ long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.43 2012/11/07 19:41:25 stsp Exp $	*/
d35 2
@


1.43
log
@Make the ieee80211_node_incref() macro a static inline function, as its
siblings already are. And fix return value of ieee80211_node_decref()
which should be unsigned but was signed.
diff originally from dhill; ok kettenis reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.42 2012/01/21 19:42:16 stsp Exp $	*/
d340 1
@


1.42
log
@Implement missing bits of node inactivity accounting in hostap mode.
Small parts of code for this feature were already present but unused.

A node becomes inactive after not sending or receiving a frame within
5 minutes. Inactive cached nodes (not authenticated or associated) are
automatically cleared from the cache once every hour, making room for
new nodes. If the node cache is full and room must be made for a new node,
clean either a cached node (active or inactive), or an inactive
authenticated or associated node.

Also, do not send de-auth frames to nodes which never authenticated,
and only send a de-auth frame once for a given node.
This part was contributed by Steven Chamberlain, thanks!

Tested by myself, krw@@, edd@@, Steven Chamberlain, and Markus Schatzl.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.41 2009/03/26 20:38:29 damien Exp $	*/
d256 9
a264 6
#define ieee80211_node_incref(ni)			\
	do {						\
		int _s = splnet();			\
		(ni)->ni_refcnt++;			\
		splx(_s);				\
	} while (0)
d266 1
a266 1
static __inline int
d269 3
a271 1
	int refcnt, s;
@


1.41
log
@move #define IEEE80211_NO_HT under #ifdef SMALL_KERNEL instead
of defining it unconditionnaly.
although the HT code is not ready yet, making it compile on
GENERIC kernels will help catch regressions/bugs if any.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.40 2009/03/26 20:34:54 damien Exp $	*/
d41 1
d321 1
a321 1
extern	void ieee80211_clean_nodes(struct ieee80211com *);
@


1.40
log
@sync with 802.11w draft 8.0.
the SA Query Transaction Identifier field is now a 16-bit non-negative
counter value instead of a 128-bit random value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.39 2009/01/28 18:55:18 damien Exp $	*/
a219 1
#ifdef notyet
a222 1
#endif
@


1.39
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.38 2009/01/28 17:15:21 damien Exp $	*/
d216 1
a216 1
	u_int8_t		ni_sa_query_trid[16];
@


1.38
log
@In ieee80211_find_node(), roll our own RB_FIND() based on the key (macaddr)
instead of resorting to horrid hacks/casts.
Restore the ieee80211_node structure back to its original state.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.37 2009/01/26 21:55:58 damien Exp $	*/
d108 1
a108 1
struct ieee80211_ba {
a109 4
	struct {
		struct mbuf		*m;
		struct ieee80211_rxinfo	rxi;
	}			*ba_buf;
d125 15
a140 1
	u_int8_t		ba_token;
d221 3
a223 2
	/* HT-immediate Block Ack */
	struct ieee80211_ba	ni_ba[IEEE80211_NUM_TID];
@


1.37
log
@move ni_macaddr field at the top of the ieee80211_node structure.
this way we can avoid putting a full node structure (which is huge)
on the stack in ieee80211_find_node().
this is a bit tricky but the RB_FIND macro wants an "elem" structure,
not a field of "elem".
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.36 2009/01/26 21:28:55 damien Exp $	*/
d140 1
a140 3
	/* ni_macaddr must be the first field for RB_FIND() */
	u_int8_t		ni_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t		ni_bssid[IEEE80211_ADDR_LEN];
d151 4
a241 2

	RB_ENTRY(ieee80211_node)	ni_node;
@


1.36
log
@remove ni_ba field from ieee80211_node structure as it is not used yet.
this reduces memory footprint and avoids a stack usage warning in
ieee80211_find_node() that breaks amd64 build.

pointed out by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.35 2009/01/26 19:09:41 damien Exp $	*/
d140 3
a142 1
	RB_ENTRY(ieee80211_node)	ni_node;
a152 4
	/* header */
	u_int8_t		ni_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t		ni_bssid[IEEE80211_ADDR_LEN];

d240 2
@


1.35
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.34 2008/12/14 10:17:24 damien Exp $	*/
d210 1
d213 1
@


1.34
log
@Add an ieee80211_notify_dtim() function that drivers should call after
every DTIM in HostAP mode.
Flushes all group addressed MSDUs buffered at the AP for power management.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.33 2008/09/27 15:16:09 damien Exp $	*/
d99 34
d181 1
a184 1
	struct timeout		ni_rsn_timeout;
d205 8
d237 3
@


1.33
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.32 2008/08/29 12:14:53 damien Exp $	*/
d277 1
@


1.32
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.31 2008/08/12 18:22:41 damien Exp $	*/
d159 2
d182 6
a187 6
	u_int8_t		ni_flags;	/* special-purpose state */
#define IEEE80211_NODE_ERP		0x01
#define IEEE80211_NODE_QOS		0x02
#define IEEE80211_NODE_REKEY		0x04	/* GTK rekeying in progress */
#define IEEE80211_NODE_RXPROT		0x08	/* RX protection ON */
#define IEEE80211_NODE_TXPROT		0x10	/* TX protection ON */
d190 5
a194 3
#define IEEE80211_NODE_RXMGMTPROT	0x20	/* RX MMPDU protection ON */
#define IEEE80211_NODE_TXMGMTPROT	0x40	/* TX MMPDU protection ON */
#define IEEE80211_NODE_MFP		0x80	/* MFP negotiated */
@


1.31
log
@process IGTK KDEs in EAPOL-Key frames and install integrity group keys
if MFP was negotiated with the peer (not possible yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.30 2008/08/02 08:24:15 damien Exp $	*/
a129 2
	u_int16_t		ni_fhdwell;	/* FH only */
	u_int8_t		ni_fhindex;	/* FH only */
@


1.30
log
@typo in a comment. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.29 2008/08/02 08:20:16 damien Exp $	*/
d157 1
d183 5
a187 5
#define IEEE80211_NODE_ERP	0x01
#define IEEE80211_NODE_QOS	0x02
#define IEEE80211_NODE_REKEY	0x04	/* GTK rekeying in progress */
#define IEEE80211_NODE_RXPROT	0x08	/* RX protection ON */
#define IEEE80211_NODE_TXPROT	0x10	/* TX protection ON */
d190 3
@


1.29
log
@Drop frames that are received unencrypted when WEP is on or when
WPA is on and RX protection for TA is on.
Keep track of the TX/RX protection for each node when WPA is on.

tested by djm@@ (ral+wpa), ckuethe@@ (ath-noenc) and krw@@ (wpi<->ral+wpa).
hints from bluhm@@
has been in snaps for a few days.

pointed out by bluhm@@ something like 1 year ago but we did not have
the right infrastructure to fix it properly at that time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.28 2008/07/27 18:24:01 damien Exp $	*/
d184 1
a184 1
#define IEEE80211_NODE_REKEY	0x04	/* GTK rekying in progress */
@


1.28
log
@sanitize RX path a bit.
make sure drivers pass a contiguous header, check header length earlier.
fix checking of frames sequence number for frames containing an Address 4
field (required for future work).
fix processing of control frames (only pspoll for now).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.27 2008/04/21 19:37:18 damien Exp $	*/
d184 5
a188 1
#define IEEE80211_NODE_REKEY	0x04
@


1.27
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.26 2008/04/16 18:32:15 damien Exp $	*/
d67 7
@


1.26
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.25 2007/11/03 14:59:55 mglocker Exp $	*/
d248 2
@


1.25
log
@Revert last commit which added ieee80211_rate2plcp() and
ieee80211_plcp2rate() because I've got a late feedback from Damien that
he dislike the implementation method a lot.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.24 2007/11/01 22:34:19 mglocker Exp $	*/
d68 1
a68 1
/* RSNA Authenticator state machine (see 8.5.6). */
d70 1
d81 5
a85 2
	RSNA_DISCONNECTED,
	RSNA_INITIALIZE,
a87 1
	RSNA_KEYERROR,
d89 1
a89 3
	RSNA_GTK_INIT,
	RSNA_SETKEYSDONE,
	RSNA_SETKEYS
d101 2
d143 7
a149 6
	u_int			ni_rsn_tocnt;
	u_int			ni_group_cipher;
	enum ieee80211_cipher	ni_pairwise_cipher;
	u_int			ni_pairwise_cipherset;
	enum ieee80211_akm	ni_akm;
	u_int			ni_akmset;
d151 1
a151 2
	int			ni_port_valid;
	u_int8_t		ni_eapol_desc;
d155 2
d161 1
d177 1
@


1.24
log
@Add ieee80211_rate2plcp() and ieee80211_plcp2rate() functions.

Help and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.23 2007/08/27 20:14:21 damien Exp $	*/
a44 1
	u_int8_t		rs_plcp[IEEE80211_RATE_MAXSIZE];
@


1.23
log
@rework ieee80211_recv_4way_msg2() function.
add some RSNA authenticator state machine bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.22 2007/08/27 18:53:27 damien Exp $	*/
d45 1
@


1.22
log
@Checking the MIC early in ieee80211_recv_eapol() does not work for
message 2/4 of the 4-way handshake because the authenticator must
derive the PTK first (the MIC is computed using the KCK).
Move calls to ieee80211_eapol_key_check_mic() - and as a consequence
ieee80211_eapol_key_decrypt() - directly in the
ieee80211_recv_{group,4way}_msg*() functions.
Unconstify the first parameter since checking the MIC modifies the
frame. Remove ni->ni_ptk_ok field while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.21 2007/08/03 16:51:06 damien Exp $	*/
d68 23
d139 2
@


1.21
log
@add a ni_eapol_desc field to struct ieee80211_node to know whether
a station is using WPA1 or RSN descriptors.
make sure that a station that advertises WPA1 capability in an IE
uses the WPA1 EAPOL-Key descriptor type and not the RSN one.
fix construction of EAPOL-Key frames for WPA1.
i can now successfuly complete a 4-way and group-key handshake
with both a WPA1 and a WPA2 access point.
add some TKIP encapsulation code (no SW crypto yet).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.20 2007/08/01 15:40:40 damien Exp $	*/
a129 1
	u_int8_t		ni_ptk_ok;
@


1.20
log
@add generic ieee80211_encrypt() and ieee80211_decrypt() functions that
can handle multiple ciphers (the key to use is determined automatically
by these functions based on the frame's destination address).
add ieee80211_ccmp_encrypt() and ieee80211_ccmp_decrypt().
those two functions only do encapsulation/decapsulation of CCMP frames
for now (they don't do SW crypto). they will help to test things with
drivers that can do HW crypto.
add a ni_pairwise_key field to struct ieee80211_node to actually install
the pairwise transient key.
install the GTK in ic_nw_keys[].
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.19 2007/08/01 12:32:26 damien Exp $	*/
d123 1
@


1.19
log
@PMKID KDE is optionnal in message 1 of the 4-way handshake (at least
when using WPA-PSK).
add a ni_replaycnt_ok flag to struct ieee80211_node to mark the replay
counter as valid.  the replay counter is marked valid only when message
3 of the 4-way handshake is received since message 1 contains no MIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.18 2007/07/28 11:09:03 damien Exp $	*/
d127 1
@


1.18
log
@add a couple of fields to the ieee80211_node structure to manage RSN
states. those fields will be put in a separate structure (ieee80211_rsna)
in a future cleanup phase to save some space.

add a ni_port_valid field to manage PAE state.
in pre-RSNA networks, this field will be set to 1 after a successful
open authentication.  in RSNA networks, this field will be set to 1
after a successful 4-way handshake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.17 2007/07/06 18:18:43 damien Exp $	*/
d125 1
@


1.17
log
@remove remaining bits for pre-RSNA shared authmode support.
it has been #if 0'd since 3.9 and we have never supported this mode (no
ifconfig option etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.16 2007/07/03 19:44:54 damien Exp $	*/
d117 1
d119 1
d122 7
@


1.16
log
@add a function that builds an RSN IE (ieee80211_add_rsn).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.15 2007/06/17 09:05:44 damien Exp $	*/
a130 1
	u_int32_t		*ni_challenge;	/* shared-key challenge */
@


1.15
log
@keep track of the Tx/Rx sequence numbers for each TID in the
ieee80211_node structure.
add a flag to indicate whether a STA is a QSTA or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.14 2007/06/16 13:21:44 damien Exp $	*/
a111 1

d115 6
d132 1
@


1.14
log
@ieee80211_lookup_node() does not exist.
remove prototype in .h and ref in man pages.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.13 2007/06/16 13:17:05 damien Exp $	*/
d120 2
d129 1
@


1.13
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.12 2007/06/07 20:24:42 damien Exp $	*/
a189 2
extern	struct ieee80211_node * ieee80211_lookup_node(struct ieee80211com *,
		u_int8_t *, struct ieee80211_channel *);
@


1.12
log
@expand the IEEE80211_NODE_{LOCK,UNLOCK}* macros into their respective
definitions.
remove comments about "lock order reversals" that are specific to freebsd.

ok reyk@@ jsg@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.11 2007/06/06 19:31:07 damien Exp $	*/
d47 3
a49 3
extern struct ieee80211_rateset ieee80211_std_rateset_11a;
extern struct ieee80211_rateset ieee80211_std_rateset_11b;
extern struct ieee80211_rateset ieee80211_std_rateset_11g;
d177 1
a177 1
		u_int8_t *);
d179 1
a179 1
		u_int8_t *);
d181 1
a181 1
		u_int8_t *);
d183 1
a183 1
		struct ieee80211_frame *);
d185 1
a185 1
		u_int8_t *);
d188 2
a189 1
		u_int8_t *, struct ieee80211_channel *, char *, u_int8_t);
d199 1
a199 1
extern  int ieee80211_iserp_sta(struct ieee80211_node *);
d210 2
a211 1
extern	int ieee80211_node_cmp(struct ieee80211_node *, struct ieee80211_node *);
@


1.11
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.10 2006/11/26 11:14:23 deraadt Exp $	*/
a160 9

typedef int ieee80211_node_lock_t;
#define	IEEE80211_NODE_LOCK_INIT(_ic, _name)
#define	IEEE80211_NODE_LOCK_DESTROY(_ic)
#define	IEEE80211_NODE_LOCK(_ic)		(_ic)->ic_nodelock = splnet()
#define	IEEE80211_NODE_UNLOCK(_ic)		splx((_ic)->ic_nodelock)
#define	IEEE80211_NODE_LOCK_ASSERT(_ic)
#define	IEEE80211_NODE_LOCK_BH		IEEE80211_NODE_LOCK
#define	IEEE80211_NODE_UNLOCK_BH	IEEE80211_NODE_UNLOCK
@


1.10
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.9 2006/06/18 18:39:41 damien Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.9
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.8 2005/09/13 12:11:03 reyk Exp $	*/
d50 4
@


1.8
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.7 2005/09/08 13:24:53 reyk Exp $	*/
d125 2
d207 1
@


1.7
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.6 2005/09/08 08:36:12 reyk Exp $	*/
a45 5
#define	IEEE80211_NODE_HASHSIZE	32
/* simple hash is enough for variation of macaddr */
#define	IEEE80211_NODE_HASH(addr)	\
	(((u_int8_t *)(addr))[IEEE80211_ADDR_LEN - 1] % IEEE80211_NODE_HASHSIZE)

d75 2
a76 2
	TAILQ_ENTRY(ieee80211_node)	ni_list;
	LIST_ENTRY(ieee80211_node)	ni_hash;
d127 2
d195 1
a195 1
		u_int8_t *, struct ieee80211_channel *, char *);
a209 1

d214 4
@


1.6
log
@reset the scan state for each new mode

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.5 2005/09/07 05:40:11 jsg Exp $	*/
d40 2
a41 2
#define	IEEE80211_PSCAN_WAIT 	5		/* passive scan wait */
#define	IEEE80211_TRANS_WAIT 	5		/* transition wait */
d196 3
a198 3
extern	struct ieee80211_node *ieee80211_find_node_for_beacon(
	        struct ieee80211com *, u_int8_t *macaddr,
		struct ieee80211_channel *, char *ssid);
d200 1
a200 1
		u_int8_t *macaddr, struct ieee80211_channel *);
@


1.5
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.4 2005/05/25 07:40:49 reyk Exp $	*/
d185 1
@


1.4
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.3 2005/02/17 18:28:05 reyk Exp $	*/
a131 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a148 13
#else
#define ieee80211_node_incref(ni) atomic_add_int(&(ni)->ni_refcnt, 1)
static __inline int
ieee80211_node_decref(struct ieee80211_node *ni)
{
	int orefcnt;
	do {
		orefcnt = ni->ni_refcnt;
	} while (atomic_cmpset_int(&ni->ni_refcnt, orefcnt, orefcnt - 1) == 0);
	return orefcnt - 1;
}
#endif

a162 10
#ifdef __FreeBSD__
typedef struct mtx ieee80211_node_lock_t;
#define	IEEE80211_NODE_LOCK_INIT(_ic, _name) \
	mtx_init(&(_ic)->ic_nodelock, _name, "802.11 node table", MTX_DEF)
#define	IEEE80211_NODE_LOCK_DESTROY(_ic)	mtx_destroy(&(_ic)->ic_nodelock)
#define	IEEE80211_NODE_LOCK(_ic)		mtx_lock(&(_ic)->ic_nodelock)
#define	IEEE80211_NODE_UNLOCK(_ic)		mtx_unlock(&(_ic)->ic_nodelock)
#define	IEEE80211_NODE_LOCK_ASSERT(_ic) \
	mtx_assert(&(_ic)->ic_nodelock, MA_OWNED)
#else
a168 1
#endif
@


1.3
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.2 2004/11/02 02:15:49 reyk Exp $	*/
a49 3

#define	IEEE80211_RATE_SIZE	8		/* 802.11 standard */
#define	IEEE80211_RATE_MAXSIZE	15		/* max rates we'll handle */
@


1.2
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.h,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d44 1
d180 2
d189 10
d223 3
d228 1
a228 1
extern	void ieee80211_free_node(struct ieee80211com *,
d234 6
a239 1
extern	void ieee80211_timeout_nodes(struct ieee80211com *);
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 17
d130 1
@

