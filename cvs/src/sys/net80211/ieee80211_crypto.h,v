head	1.25;
access;
symbols
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.23.0.4
	OPENBSD_6_0_BASE:1.23
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.22.0.30
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.22
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.26
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.24
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.20
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.18
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.16
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.14
	OPENBSD_5_0:1.22.0.12
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.10
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.8
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.4
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.1.0.12
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.10
	OPENBSD_4_0_BASE:1.1
	OPENBSD_3_9:1.1.0.8
	OPENBSD_3_9_BASE:1.1
	OPENBSD_3_8:1.1.0.6
	OPENBSD_3_8_BASE:1.1
	OPENBSD_3_7:1.1.0.4
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.08.18.17.30.12;	author stsp;	state Exp;
branches;
next	1.24;
commitid	X7DNufuhLgsHcrsJ;

1.24
date	2016.12.17.18.35.54;	author stsp;	state Exp;
branches
	1.24.4.1;
next	1.23;
commitid	jPAQ1b8Z1ErNDg1z;

1.23
date	2015.12.05.16.26.53;	author mpi;	state Exp;
branches
	1.23.4.1;
next	1.22;
commitid	GzWKQyX3jA35FJdn;

1.22
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.12.16.56.45;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.12.16.51.39;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2008.08.12.16.33.38;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2008.08.12.16.14.05;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2008.08.12.16.05.15;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.21.19.01.01;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.18.09.16.14;	author djm;	state Exp;
branches;
next	1.10;

1.10
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2007.08.23.16.50.30;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.22.20.52.26;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.22.20.40.34;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2007.08.01.15.40.40;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2007.08.01.12.37.46;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2007.07.28.11.01.19;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.23.4.1
date	2017.08.30.15.08.46;	author stsp;	state Exp;
branches;
next	;
commitid	uJxOvDLDwHi7tkZk;

1.24.4.1
date	2017.08.30.15.08.30;	author stsp;	state Exp;
branches;
next	;
commitid	rHceBzDEJfOyPHhV;


desc
@@


1.25
log
@Clear WPA group keys from memory before initiating a key exchange
with an access point. Prevents false positive 'reused group key'
warnings in dmesg when re-associating to the same access point.
Problem reported by tb@@
ok tb@@
@
text
@/*	$OpenBSD: ieee80211_crypto.h,v 1.24 2016/12/17 18:35:54 stsp Exp $	*/

/*-
 * Copyright (c) 2007,2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET80211_IEEE80211_CRYPTO_H_
#define _NET80211_IEEE80211_CRYPTO_H_

/*
 * 802.11 protocol crypto-related definitions.
 */

/*
 * 802.11 ciphers.
 */
enum ieee80211_cipher {
	IEEE80211_CIPHER_NONE		= 0x00000000,
	IEEE80211_CIPHER_USEGROUP	= 0x00000001,
	IEEE80211_CIPHER_WEP40		= 0x00000002,
	IEEE80211_CIPHER_TKIP		= 0x00000004,
	IEEE80211_CIPHER_CCMP		= 0x00000008,
	IEEE80211_CIPHER_WEP104		= 0x00000010,
	IEEE80211_CIPHER_BIP		= 0x00000020	/* 11w */
};

/*
 * 802.11 Authentication and Key Management Protocols.
 */
enum ieee80211_akm {
	IEEE80211_AKM_NONE		= 0x00000000,
	IEEE80211_AKM_8021X		= 0x00000001,
	IEEE80211_AKM_PSK		= 0x00000002,
	IEEE80211_AKM_SHA256_8021X	= 0x00000004,	/* 11w */
	IEEE80211_AKM_SHA256_PSK	= 0x00000008	/* 11w */
};

#define IEEE80211_TKIP_HDRLEN	8
#define IEEE80211_TKIP_MICLEN	8
#define IEEE80211_TKIP_ICVLEN	4
#define IEEE80211_CCMP_HDRLEN	8
#define IEEE80211_CCMP_MICLEN	8

#define IEEE80211_PMK_LEN	32

#ifdef _KERNEL 

static __inline int
ieee80211_is_8021x_akm(enum ieee80211_akm akm)
{
	return akm == IEEE80211_AKM_8021X ||
	    akm == IEEE80211_AKM_SHA256_8021X;
}

static __inline int
ieee80211_is_sha256_akm(enum ieee80211_akm akm)
{
	return akm == IEEE80211_AKM_SHA256_8021X ||
	    akm == IEEE80211_AKM_SHA256_PSK;
}

struct ieee80211_key {
	u_int8_t		k_id;		/* identifier (0-5) */
	enum ieee80211_cipher	k_cipher;
	u_int			k_flags;
#define IEEE80211_KEY_GROUP	0x00000001	/* group data key */
#define IEEE80211_KEY_TX	0x00000002	/* Tx+Rx */
#define IEEE80211_KEY_IGTK	0x00000004	/* integrity group key */

	u_int			k_len;
	u_int64_t		k_rsc[IEEE80211_NUM_TID];
	u_int64_t		k_mgmt_rsc;
	u_int64_t		k_tsc;
	u_int8_t		k_key[32];
	void			*k_priv;
};

#define IEEE80211_KEYBUF_SIZE	16

/*
 * Entry in the PMKSA cache.
 */
struct ieee80211_pmk {
	enum ieee80211_akm	pmk_akm;
	u_int32_t		pmk_lifetime;
#define IEEE80211_PMK_INFINITE	0

	u_int8_t		pmk_pmkid[IEEE80211_PMKID_LEN];
	u_int8_t		pmk_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t		pmk_key[IEEE80211_PMK_LEN];

	TAILQ_ENTRY(ieee80211_pmk) pmk_next;
};

/* forward references */
struct	ieee80211com;
struct	ieee80211_node;

void	ieee80211_crypto_attach(struct ifnet *);
void	ieee80211_crypto_detach(struct ifnet *);

void	ieee80211_crypto_clear_groupkeys(struct ieee80211com *);
struct	ieee80211_key *ieee80211_get_txkey(struct ieee80211com *,
	    const struct ieee80211_frame *, struct ieee80211_node *);
struct	ieee80211_key *ieee80211_get_rxkey(struct ieee80211com *,
	    struct mbuf *, struct ieee80211_node *);
struct	mbuf *ieee80211_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_decrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);

int	ieee80211_set_key(struct ieee80211com *, struct ieee80211_node *,
	    struct ieee80211_key *);
void	ieee80211_delete_key(struct ieee80211com *, struct ieee80211_node *,
	    struct ieee80211_key *);

void	ieee80211_eapol_key_mic(struct ieee80211_eapol_key *,
	    const u_int8_t *);
int	ieee80211_eapol_key_check_mic(struct ieee80211_eapol_key *,
	    const u_int8_t *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_eapol_key_encrypt(struct ieee80211com *,
	    struct ieee80211_eapol_key *, const u_int8_t *);
#endif
int	ieee80211_eapol_key_decrypt(struct ieee80211_eapol_key *,
	    const u_int8_t *);

struct	ieee80211_pmk *ieee80211_pmksa_add(struct ieee80211com *,
	    enum ieee80211_akm, const u_int8_t *, const u_int8_t *, u_int32_t);
struct	ieee80211_pmk *ieee80211_pmksa_find(struct ieee80211com *,
	    struct ieee80211_node *, const u_int8_t *);
void	ieee80211_derive_ptk(enum ieee80211_akm, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *,
	    const u_int8_t *, struct ieee80211_ptk *);
int	ieee80211_cipher_keylen(enum ieee80211_cipher);

int	ieee80211_wep_set_key(struct ieee80211com *, struct ieee80211_key *);
void	ieee80211_wep_delete_key(struct ieee80211com *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_wep_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_wep_decrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);

int	ieee80211_tkip_set_key(struct ieee80211com *, struct ieee80211_key *);
void	ieee80211_tkip_delete_key(struct ieee80211com *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_tkip_encrypt(struct ieee80211com *,
	    struct mbuf *, struct ieee80211_key *);
struct	mbuf *ieee80211_tkip_decrypt(struct ieee80211com *,
	    struct mbuf *, struct ieee80211_key *);
void	ieee80211_tkip_mic(struct mbuf *, int, const u_int8_t *,
	    u_int8_t[IEEE80211_TKIP_MICLEN]);
void	ieee80211_michael_mic_failure(struct ieee80211com *, u_int64_t);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_michael_mic_failure_timeout(void *);
#endif

int	ieee80211_ccmp_set_key(struct ieee80211com *, struct ieee80211_key *);
void	ieee80211_ccmp_delete_key(struct ieee80211com *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_ccmp_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_ccmp_decrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);

int	ieee80211_bip_set_key(struct ieee80211com *, struct ieee80211_key *);
void	ieee80211_bip_delete_key(struct ieee80211com *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_bip_encap(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct	mbuf *ieee80211_bip_decap(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);

#endif /* _KERNEL */
#endif /* _NET80211_IEEE80211_CRYPTO_H_ */
@


1.24
log
@Complete our half-done implementation of TKIP countermeasures in hostap mode.

The previous code would disable the AP until next reboot upon MIC failure.
Instead, disable the AP for 60 seconds, as required by the 802.11 standard.
I randomly added a bit of time (up to 120 seconds total) just because we can.

Problem reported by Mathy Vanhoef, thanks!
ok deraadt@@
random input reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.23 2015/12/05 16:26:53 mpi Exp $	*/
d114 1
@


1.24.4.1
log
@MFC:
Add an entry to dmesg if pairwise WPA keys arrive unexpectedly or if WPA
group keys are being reused. OpenBSD wireless clients will now leave a
trail of such events in their message log.

Clear WPA group keys from memory before initiating a key exchange
with an access point. Prevents false positive 'reused group key'
warnings in dmesg when re-associating to the same access point.

(OpenBSD 6.1 errata 027, August 30, 2017)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.24 2016/12/17 18:35:54 stsp Exp $	*/
a113 1
void	ieee80211_crypto_clear_groupkeys(struct ieee80211com *);
@


1.23
log
@Keep kernel definitions under _KERNEL to unbreak security/wpa_supplicant
because of a missing forward declaration for kernel functions.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.22 2009/01/26 19:09:41 damien Exp $	*/
d166 3
@


1.23.4.1
log
@MFC:
Add an entry to dmesg if pairwise WPA keys arrive unexpectedly or if WPA
group keys are being reused. OpenBSD wireless clients will now leave a
trail of such events in their message log.

Clear WPA group keys from memory before initiating a key exchange
with an access point. Prevents false positive 'reused group key'
warnings in dmesg when re-associating to the same access point.

(OpenBSD 6.0 errata 041, August 30, 2017)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.23 2015/12/05 16:26:53 mpi Exp $	*/
a113 1
void	ieee80211_crypto_clear_groupkeys(struct ieee80211com *);
@


1.22
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.21 2008/09/27 15:16:09 damien Exp $	*/
d50 10
a73 10
#define	IEEE80211_KEYBUF_SIZE	16

#define IEEE80211_TKIP_HDRLEN	8
#define IEEE80211_TKIP_MICLEN	8
#define IEEE80211_TKIP_ICVLEN	4
#define IEEE80211_CCMP_HDRLEN	8
#define IEEE80211_CCMP_MICLEN	8

#define IEEE80211_PMK_LEN	32

d90 2
d183 1
@


1.21
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.20 2008/08/27 09:05:04 damien Exp $	*/
d36 1
a36 1
	IEEE80211_CIPHER_AES128_CMAC	= 0x00000020	/* 11w */
@


1.20
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.19 2008/08/12 19:29:07 damien Exp $	*/
d46 2
a47 4
	IEEE80211_AKM_FBT_8021X		= 0x00000004,	/* 11r */
	IEEE80211_AKM_FBT_PSK		= 0x00000008,	/* 11r */
	IEEE80211_AKM_SHA256_8021X	= 0x00000010,	/* 11w */
	IEEE80211_AKM_SHA256_PSK	= 0x00000020	/* 11w */
d50 14
d90 15
d137 3
a139 1
const	u_int8_t *ieee80211_get_pmk(struct ieee80211com *,
@


1.19
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.18 2008/08/12 16:56:45 damien Exp $	*/
d103 1
d106 1
@


1.18
log
@add new IEEE80211_CIPHER_AES128_CMAC cipher and new key flag
IEEE80211_KEY_IGTK.
lot of cleanup while i'm here (indent function prototypes).
change license since this file was completely rewritten.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.17 2008/08/12 16:51:39 damien Exp $	*/
d44 6
a49 2
	IEEE80211_AKM_IEEE8021X		= 0x00000001,
	IEEE80211_AKM_PSK		= 0x00000002
@


1.17
log
@Welcome BIP: the Broadcast/Multicast Integrity Protocol defined
in Draft IEEE P802.11w.
It provides data integrity and replay protection for broadcast/
multicast robust management frames (not used yet) using AES-128
in CMAC mode.
@
text
@d1 1
a1 2
/*	$OpenBSD: ieee80211_crypto.h,v 1.16 2008/08/12 16:33:38 damien Exp $	*/
/*	$NetBSD: ieee80211_crypto.h,v 1.2 2003/09/14 01:14:55 dyoung Exp $	*/
d4 1
a4 3
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 12
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net80211/ieee80211_crypto.h,v 1.2 2003/06/27 05:13:52 sam Exp $
d18 1
d27 1
a27 1
 * 802.11i ciphers.
d30 7
a36 6
	IEEE80211_CIPHER_NONE     = 0x00000000,
	IEEE80211_CIPHER_USEGROUP = 0x00000001,
	IEEE80211_CIPHER_WEP40    = 0x00000002,
	IEEE80211_CIPHER_TKIP     = 0x00000004,
	IEEE80211_CIPHER_CCMP     = 0x00000008,
	IEEE80211_CIPHER_WEP104   = 0x00000010
d40 1
a40 1
 * 802.11i Authentication and Key Management Protocols.
d43 3
a45 3
	IEEE80211_AKM_NONE	= 0x00000000,
	IEEE80211_AKM_IEEE8021X	= 0x00000001,
	IEEE80211_AKM_PSK	= 0x00000002
d59 1
a59 1
	u_int8_t		k_id;		/* identifier (0-3) */
d62 1
a62 1
#define IEEE80211_KEY_GROUP	0x00000001	/* group key */
d64 1
d75 2
a76 2
struct ieee80211com;
struct ieee80211_node;
d78 2
a79 2
extern	void ieee80211_crypto_attach(struct ifnet *);
extern	void ieee80211_crypto_detach(struct ifnet *);
d81 1
a81 4
extern	const u_int8_t *ieee80211_get_pmk(struct ieee80211com *,
	    struct ieee80211_node *, const u_int8_t *);

extern	struct ieee80211_key *ieee80211_get_txkey(struct ieee80211com *,
d83 3
a85 1
extern	struct mbuf *ieee80211_encrypt(struct ieee80211com *, struct mbuf *,
d87 1
a87 1
extern	struct mbuf *ieee80211_decrypt(struct ieee80211com *, struct mbuf *,
d90 13
a102 4
int ieee80211_set_key(struct ieee80211com *, struct ieee80211_node *,
    struct ieee80211_key *);
void ieee80211_delete_key(struct ieee80211com *, struct ieee80211_node *,
    struct ieee80211_key *);
d104 6
a109 8
int ieee80211_wep_set_key(struct ieee80211com *, struct ieee80211_key *);
void ieee80211_wep_delete_key(struct ieee80211com *, struct ieee80211_key *);
struct mbuf *
ieee80211_wep_encrypt(struct ieee80211com *, struct mbuf *,
    struct ieee80211_key *);
struct mbuf *
ieee80211_wep_decrypt(struct ieee80211com *, struct mbuf *,
    struct ieee80211_key *);
d111 2
a112 3
int ieee80211_tkip_set_key(struct ieee80211com *, struct ieee80211_key *);
void ieee80211_tkip_delete_key(struct ieee80211com *, struct ieee80211_key *);
struct mbuf *ieee80211_tkip_encrypt(struct ieee80211com *, struct mbuf *,
d114 3
a116 1
struct mbuf *ieee80211_tkip_decrypt(struct ieee80211com *, struct mbuf *,
d119 2
a120 5
int ieee80211_ccmp_set_key(struct ieee80211com *, struct ieee80211_key *);
void ieee80211_ccmp_delete_key(struct ieee80211com *, struct ieee80211_key *);
struct mbuf *ieee80211_ccmp_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct mbuf *ieee80211_ccmp_decrypt(struct ieee80211com *, struct mbuf *,
d122 5
a126 2

extern	void ieee80211_tkip_mic(struct mbuf *, int, const u_int8_t *,
d128 1
a128 1
extern	void ieee80211_michael_mic_failure(struct ieee80211com *, u_int64_t);
d130 7
a136 8
extern	void ieee80211_eapol_key_mic(struct ieee80211_eapol_key *,
		const u_int8_t *);
extern	int ieee80211_eapol_key_check_mic(struct ieee80211_eapol_key *,
		const u_int8_t *);
extern	void ieee80211_eapol_key_encrypt(struct ieee80211com *,
		struct ieee80211_eapol_key *, const u_int8_t *);
extern	int ieee80211_eapol_key_decrypt(struct ieee80211_eapol_key *,
		const u_int8_t *);
d138 2
a139 8
extern	void ieee80211_derive_ptk(enum ieee80211_akm, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *,
	    const u_int8_t *, struct ieee80211_ptk *);
extern	int ieee80211_cipher_keylen(enum ieee80211_cipher);

extern	int ieee80211_bip_set_key(struct ieee80211com *,
	    struct ieee80211_key *);
extern	void ieee80211_bip_delete_key(struct ieee80211com *,
d141 1
a141 1
extern	struct	mbuf *ieee80211_bip_encap(struct ieee80211com *, struct mbuf *,
d143 1
a143 1
extern	struct	mbuf *ieee80211_bip_decap(struct ieee80211com *, struct mbuf *,
@


1.16
log
@add replay counter for management frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.15 2008/08/12 16:14:05 damien Exp $	*/
d148 9
@


1.15
log
@get rid of the map_ptk()/map_gtk() functions, just inline them
which makes things easier to track.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.14 2008/08/12 16:05:15 damien Exp $	*/
d80 1
@


1.14
log
@simplify ieee80211_derive_ptk() prototype.
pass the AKMP so we can support other key derivation functions in the
future.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.13 2008/04/21 19:37:18 damien Exp $	*/
a146 5
extern	void ieee80211_map_ptk(const struct ieee80211_ptk *,
	    enum ieee80211_cipher, u_int64_t, struct ieee80211_key *);
extern	void ieee80211_map_gtk(const u_int8_t *, enum ieee80211_cipher, int,
	    int, u_int64_t, struct ieee80211_key *);

@


1.13
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.12 2008/04/21 19:01:01 damien Exp $	*/
d143 3
a145 3
extern	void ieee80211_derive_ptk(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *, u_int8_t *,
	    size_t);
@


1.12
log
@- do not process ethernet PAE frames if RSN is not enabled
- add a ieee80211_recv_action() function (will be used later)
- some cleanup, remove unused prototypes, get rid of the
  IEEE80211_VERIFY_* macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.11 2008/04/18 09:16:14 djm Exp $	*/
d133 9
@


1.11
log
@extend the if_ethersubr.c crc functions to support updating a running
crc in addition to the existing "oneshot" mode and use them to replace
ieee80211_crc_update() with the new ether_crc32_le_update(). Saves 1k
kernel bss + some code.

Mark the new ether_crc32_[lb]e_update functions as __pure for a
~25x speedup (on my i386 at least).

feedback and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.10 2008/04/16 18:32:15 damien Exp $	*/
a93 1

@


1.10
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.9 2007/08/23 16:50:30 damien Exp $	*/
a101 2

u_int32_t ieee80211_crc_update(u_int32_t, const u_int8_t *, int);
@


1.9
log
@add pseudo-header definition for TKIP MIC computation.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.8 2007/08/22 20:52:26 damien Exp $	*/
d53 1
a53 1
 * 802.11i Authentication and Key Management.
d78 2
a79 1
	u_int64_t		k_rsc;
d81 2
a82 4
	int			k_len;
	u_int8_t		k_key[IEEE80211_KEYBUF_SIZE];
	u_int8_t		k_rxmic[IEEE80211_TKIP_MICLEN];
	u_int8_t		k_txmic[IEEE80211_TKIP_MICLEN];
a84 8
/* pseudo-header used for TKIP MIC computation */
struct ieee80211_tkip_frame {
	u_int8_t	i_da[IEEE80211_ADDR_LEN];
	u_int8_t	i_sa[IEEE80211_ADDR_LEN];
	u_int8_t	i_pri;
	u_int8_t	i_pad[3];
} __packed;

d91 5
d102 35
a136 1
extern	struct mbuf *ieee80211_wep_crypt(struct ifnet *, struct mbuf *, int);
d142 1
a142 1
	    enum ieee80211_cipher, struct ieee80211_key *);
d145 1
@


1.8
log
@add a ieee80211_get_txkey() function to determine the key to use for
transmitting a frame to a given node.
change ieee80211_encrypt() so that it now takes the key as parameter.
this change is required because drivers doing hardware crypto need to
know what key is being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.7 2007/08/22 20:40:34 damien Exp $	*/
d85 8
@


1.7
log
@- add k_rxmic and k_txmic fields to struct ieee80211_key to store the
  Tx/Rx MIC for TKIP.
- add two functions to map a PTK and a GTK to an IEEE 802.11 key and
  use them in ieee80211_input.c instead of duplicating the same code.
  properly set Tx/Rx MIC in the IEEE 802.11 key in the case of TKIP.
- add ic_psk to struct ieee80211com to store the pre-shared key.
- fix setting of the SECURE bit in outgoing EAPOL-Key frames.
- when receiving msg 2 of the 4-way handshake, deauthenticate the
  station if the RSN IE does not match that of the (Re)Association
  request.
- before parsing an RSN or WPA IE, check that there's enough room for
  the version field (2 bytes) which is mandatory.
- various tweaks while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.6 2007/08/01 15:40:40 damien Exp $	*/
d92 2
d95 1
a95 1
	    struct ieee80211_node *);
@


1.6
log
@add generic ieee80211_encrypt() and ieee80211_decrypt() functions that
can handle multiple ciphers (the key to use is determined automatically
by these functions based on the frame's destination address).
add ieee80211_ccmp_encrypt() and ieee80211_ccmp_decrypt().
those two functions only do encapsulation/decapsulation of CCMP frames
for now (they don't do SW crypto). they will help to test things with
drivers that can do HW crypto.
add a ni_pairwise_key field to struct ieee80211_node to actually install
the pairwise transient key.
install the GTK in ic_nw_keys[].
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.5 2007/08/01 12:37:46 damien Exp $	*/
d63 8
d82 2
d101 4
@


1.5
log
@add a TSC field to the key structure. it will be used to store the
TKIP sequence counter (TKIP) or the PN (packet number, CCMP).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.4 2007/07/28 11:01:19 damien Exp $	*/
d76 4
d82 4
@


1.4
log
@extend the ieee80211_key structure with a key identifier, a flags field
and a 64-bit receive sequence counter (for group keys).
add a ieee80211_cipher_keylen() function to retrieve the key length
in bytes used by a specific cipher.
account for 802.1X header size when computing the Key MIC.
some cleanup in comments and variable names while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.3 2007/07/18 18:10:31 damien Exp $	*/
d70 2
a71 1
	u_int64_t		k_rsc;		/* receive sequence counter */
@


1.3
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.2 2007/06/06 19:31:07 damien Exp $	*/
d64 1
d66 5
d78 5
@


1.2
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.h,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d39 22
d63 4
a66 3
struct ieee80211_wepkey {
	int			wk_len;
	u_int8_t		wk_key[IEEE80211_KEYBUF_SIZE];
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@

