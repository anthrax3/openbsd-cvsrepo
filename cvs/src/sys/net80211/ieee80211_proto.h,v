head	1.42;
access;
symbols
	OPENBSD_6_1:1.42.0.2
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.41.0.4
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.39.0.26
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.39.0.18
	OPENBSD_5_7_BASE:1.39
	OPENBSD_5_6:1.39.0.22
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.20
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.16
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.14
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.12
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.10
	OPENBSD_5_0:1.39.0.8
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.6
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.6
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.42
date	2016.09.21.12.21.27;	author stsp;	state Exp;
branches;
next	1.41;
commitid	ExqBSY6QNe8gxCt8;

1.41
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.40;
commitid	2QagMjdMhQhIaQgu;

1.40
date	2015.11.15.11.14.17;	author stsp;	state Exp;
branches;
next	1.39;
commitid	fROBylLWPLvwXRar;

1.39
date	2009.11.21.18.09.31;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.28.06.43.07;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.27.15.00.08;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.09.01.19.41.10;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.14.15.51.43;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.12.17.53.13;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.21.19.05.21;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.23.16.59.32;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.03.16.51.06;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.08.01.12.47.55;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.28.11.24.06;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.24.20.34.16;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.24.16.53.03;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.14.19.58.05;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.06.18.18.43;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.05.20.19.21;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.03.19.44.54;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.03.16.43.41;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.02.16.46.44;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.21.21.06.12;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.07.20.20.15;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.25.19.24.27;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.03.19.02.08;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.19.18.06.50;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.20.19.52.43;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.03.14.36.41;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.25.20.40.19;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.23.12.27.25;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.23.11.54.09;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.42
log
@When processing an ADDBA request, iwm(4) runs a task which sends a
command to the firmware and waits for confirmation. This command can
fail and there was no way we could recover from such an error.

Allow drivers to return EBUSY from their ic_ampdu_rx_start() handler to
tell the stack not to send a confirmation just yet. The stack provides
functions which the driver can call to accept or refuse the request.

There is no functional change yet. This just shuffles code around so
drivers may insert themselves into the process.

ok mpi@@
@
text
@/*	$OpenBSD: ieee80211_proto.h,v 1.41 2016/01/05 18:41:16 stsp Exp $	*/
/*	$NetBSD: ieee80211_proto.h,v 1.3 2003/10/13 04:23:56 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net80211/ieee80211_proto.h,v 1.4 2003/08/19 22:17:03 sam Exp $
 */
#ifndef _NET80211_IEEE80211_PROTO_H_
#define _NET80211_IEEE80211_PROTO_H_

/*
 * 802.11 protocol implementation definitions.
 */

enum ieee80211_state {
	IEEE80211_S_INIT	= 0,	/* default state */
	IEEE80211_S_SCAN	= 1,	/* scanning */
	IEEE80211_S_AUTH	= 2,	/* try to authenticate */
	IEEE80211_S_ASSOC	= 3,	/* try to assoc */
	IEEE80211_S_RUN		= 4	/* associated */
};
#define	IEEE80211_S_MAX		(IEEE80211_S_RUN+1)

#define	IEEE80211_SEND_MGMT(_ic,_ni,_type,_arg) \
	((*(_ic)->ic_send_mgmt)(_ic, _ni, _type, _arg, 0))
/* shortcut */
#define IEEE80211_SEND_ACTION(_ic,_ni,_categ,_action,_arg) \
	((*(_ic)->ic_send_mgmt)(_ic, _ni, IEEE80211_FC0_SUBTYPE_ACTION, \
	    (_categ) << 16 | (_action), _arg))

extern	const char * const ieee80211_mgt_subtype_name[];
extern	const char * const ieee80211_state_name[IEEE80211_S_MAX];
extern	const char * const ieee80211_phymode_name[];

extern	void ieee80211_proto_attach(struct ifnet *);
extern	void ieee80211_proto_detach(struct ifnet *);

struct ieee80211_node;
struct ieee80211_rxinfo;
struct ieee80211_rsnparams;
extern	void ieee80211_set_link_state(struct ieee80211com *, int);
extern	u_int ieee80211_get_hdrlen(const struct ieee80211_frame *);
extern	void ieee80211_input(struct ifnet *, struct mbuf *,
		struct ieee80211_node *, struct ieee80211_rxinfo *);
extern	int ieee80211_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		struct rtentry *);
extern	void ieee80211_recv_mgmt(struct ieee80211com *, struct mbuf *,
		struct ieee80211_node *, struct ieee80211_rxinfo *, int);
extern	int ieee80211_send_mgmt(struct ieee80211com *, struct ieee80211_node *,
		int, int, int);
extern	void ieee80211_eapol_key_input(struct ieee80211com *, struct mbuf *,
		struct ieee80211_node *);
extern	struct mbuf *ieee80211_encap(struct ifnet *, struct mbuf *,
		struct ieee80211_node **);
extern	struct mbuf *ieee80211_get_rts(struct ieee80211com *,
		const struct ieee80211_frame *, u_int16_t);
extern	struct mbuf *ieee80211_get_cts_to_self(struct ieee80211com *,
		u_int16_t);
extern	struct mbuf *ieee80211_beacon_alloc(struct ieee80211com *,
		struct ieee80211_node *);
extern int ieee80211_save_ie(const u_int8_t *, u_int8_t **);
extern	void ieee80211_eapol_timeout(void *);
extern	int ieee80211_send_4way_msg1(struct ieee80211com *,
		struct ieee80211_node *);
extern	int ieee80211_send_4way_msg2(struct ieee80211com *,
		struct ieee80211_node *, const u_int8_t *,
		const struct ieee80211_ptk *);
extern	int ieee80211_send_4way_msg3(struct ieee80211com *,
		struct ieee80211_node *);
extern	int ieee80211_send_4way_msg4(struct ieee80211com *,
		struct ieee80211_node *);
extern	int ieee80211_send_group_msg1(struct ieee80211com *,
		struct ieee80211_node *);
extern	int ieee80211_send_group_msg2(struct ieee80211com *,
		struct ieee80211_node *, const struct ieee80211_key *);
extern	int ieee80211_send_eapol_key_req(struct ieee80211com *,
		struct ieee80211_node *, u_int16_t, u_int64_t);
extern	int ieee80211_pwrsave(struct ieee80211com *, struct mbuf *,
		struct ieee80211_node *);
#define	ieee80211_new_state(_ic, _nstate, _arg) \
	(((_ic)->ic_newstate)((_ic), (_nstate), (_arg)))
extern	enum ieee80211_edca_ac ieee80211_up_to_ac(struct ieee80211com *, int);
extern	u_int8_t *ieee80211_add_capinfo(u_int8_t *, struct ieee80211com *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_ssid(u_int8_t *, const u_int8_t *, u_int);
extern	u_int8_t *ieee80211_add_rates(u_int8_t *,
		const struct ieee80211_rateset *);
extern	u_int8_t *ieee80211_add_fh_params(u_int8_t *, struct ieee80211com *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_ds_params(u_int8_t *, struct ieee80211com *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_tim(u_int8_t *, struct ieee80211com *);
extern	u_int8_t *ieee80211_add_ibss_params(u_int8_t *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_edca_params(u_int8_t *, struct ieee80211com *);
extern	u_int8_t *ieee80211_add_erp(u_int8_t *, struct ieee80211com *);
extern	u_int8_t *ieee80211_add_qos_capability(u_int8_t *,
		struct ieee80211com *);
extern	u_int8_t *ieee80211_add_rsn(u_int8_t *, struct ieee80211com *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_wpa(u_int8_t *, struct ieee80211com *,
		const struct ieee80211_node *);
extern	u_int8_t *ieee80211_add_xrates(u_int8_t *,
		const struct ieee80211_rateset *);
extern	u_int8_t *ieee80211_add_htcaps(u_int8_t *, struct ieee80211com *);
extern	u_int8_t *ieee80211_add_htop(u_int8_t *, struct ieee80211com *);
extern	u_int8_t *ieee80211_add_tie(u_int8_t *, u_int8_t, u_int32_t);

extern	int ieee80211_parse_rsn(struct ieee80211com *, const u_int8_t *,
		struct ieee80211_rsnparams *);
extern	int ieee80211_parse_wpa(struct ieee80211com *, const u_int8_t *,
		struct ieee80211_rsnparams *);
extern	void ieee80211_print_essid(const u_int8_t *, int);
#ifdef IEEE80211_DEBUG
extern	void ieee80211_dump_pkt(const u_int8_t *, int, int, int);
#endif
extern	int ieee80211_ibss_merge(struct ieee80211com *,
		struct ieee80211_node *, u_int64_t);
extern	void ieee80211_reset_erp(struct ieee80211com *);
extern	void ieee80211_set_shortslottime(struct ieee80211com *, int);
extern	void ieee80211_auth_open(struct ieee80211com *,
	    const struct ieee80211_frame *, struct ieee80211_node *,
	    struct ieee80211_rxinfo *rs, u_int16_t, u_int16_t);
extern	void ieee80211_gtk_rekey_timeout(void *);
extern	int ieee80211_keyrun(struct ieee80211com *, u_int8_t *);
extern	void ieee80211_setkeys(struct ieee80211com *);
extern	void ieee80211_setkeysdone(struct ieee80211com *);
extern	void ieee80211_sa_query_timeout(void *);
extern	void ieee80211_sa_query_request(struct ieee80211com *,
	    struct ieee80211_node *);
extern	void ieee80211_ht_negotiate(struct ieee80211com *,
    struct ieee80211_node *);
extern	void ieee80211_tx_ba_timeout(void *);
extern	void ieee80211_rx_ba_timeout(void *);
extern	int ieee80211_addba_request(struct ieee80211com *,
	    struct ieee80211_node *,  u_int16_t, u_int8_t);
extern	void ieee80211_delba_request(struct ieee80211com *,
	    struct ieee80211_node *, u_int16_t, u_int8_t, u_int8_t);
extern	void ieee80211_addba_req_accept(struct ieee80211com *,
	    struct ieee80211_node *, uint8_t);
extern	void ieee80211_addba_req_refuse(struct ieee80211com *,
	    struct ieee80211_node *, uint8_t);


#endif /* _NET80211_IEEE80211_PROTO_H_ */
@


1.41
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.40 2015/11/15 11:14:17 stsp Exp $	*/
d164 5
@


1.40
log
@Parse 11n HT capabilities and operational info from association response
frames, negotiate HT with the AP, and move the interface into or out of
11n mode accordingly. If running as AP negotiate HT with nodes joining the BSS.

ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.39 2009/11/21 18:09:31 damien Exp $	*/
a155 1
#ifndef IEEE80211_NO_HT
a163 1
#endif
@


1.39
log
@when wpa is enabled, defer setting the link up until the 802.1X
port is valid (keys have been successfully exchanged.)
this avoids dhclient timeouts when wpa is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.38 2009/01/28 18:55:18 damien Exp $	*/
d157 2
@


1.38
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.37 2009/01/26 19:09:41 damien Exp $	*/
d66 1
@


1.37
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.36 2008/09/28 06:43:07 damien Exp $	*/
d156 2
a157 1
extern	void ieee80211_ba_timeout(void *);
d161 1
a161 1
	    struct ieee80211_node *, u_int16_t, u_int8_t);
@


1.36
log
@unbreak the tree.
pointed out by deraadt@@, Markus Peloquin

sorry guys.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.34 2008/09/01 19:41:10 damien Exp $	*/
d50 5
a54 1
	((*(_ic)->ic_send_mgmt)(_ic, _ni, _type, _arg))
d74 1
a74 1
		int, int);
a103 1
extern	struct mbuf *ieee80211_decap(struct ifnet *, struct mbuf *, int);
d129 4
d152 10
@


1.35
log
@Add some inline functions to test the presence of optional 802.11
header fields (Sequence Control, Address 4, QoS Control, +HTC) and
use them where appropriate.

Add ieee80211_get_qos() inline function to extract the QoS control
field of an 802.11 header instead of duplicating the same scary
code everywhere (the location of this field depends on the presence
of an Address 4 field).

Export ieee80211_up_to_ac() so that drivers can select the access
category to use based on the TID subfield of the QoS Control field.

Define more QoS-related bits for the RSN Capabilities field of RSN IE
(will be used later).
@
text
@d142 1
@


1.34
log
@rework previously unused ieee80211_pwrsave() function, call it from
ieee80211_mgmt_output() and ieee80211_encap().
use new IEEE80211_C_APPMGT capability flag where appropriate.
rename ic_tim_mcast to ic_tim_mcast_pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.33 2008/08/14 15:51:43 damien Exp $	*/
d62 1
a62 1
extern	u_int ieee80211_get_hdrlen(const void *);
d103 1
@


1.33
log
@put ieee80211_dump_pkt() under #ifdef IEEE80211_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.32 2008/08/12 17:53:13 damien Exp $	*/
d98 2
a99 2
extern	void ieee80211_pwrsave(struct ieee80211com *, struct ieee80211_node *,
		struct mbuf *);
@


1.32
log
@Change the way we process EAPOL-Key frames.
Free the mbuf in the ieee80211_eapol_key_input() function.
Do not assume the frame is contiguous, call m_pullup2() if it is not.
We need the frame to be contiguous to process KDEs efficiently in
EAPOL-Key frames (just like we process IEs in management frames).
However, there are drivers like upgt(4) that use m_devget() in the
RX path.  m_devget() can return fragmented mbuf chains.
Notice that we should do the same m_pullup2() for management frames.
This will be done later.
Remove the ic_recv_eapol callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.31 2008/07/21 19:05:21 damien Exp $	*/
d130 1
d132 1
@


1.31
log
@move processing of EAPOL frames away from ieee80211_{input,output}.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.30 2008/07/21 18:43:18 damien Exp $	*/
d71 1
a71 1
extern	void ieee80211_recv_eapol(struct ieee80211com *, struct mbuf *,
@


1.30
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.29 2008/04/21 19:37:18 damien Exp $	*/
d61 1
d125 4
@


1.29
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.28 2008/04/16 18:32:15 damien Exp $	*/
d60 1
d63 1
a63 1
		struct ieee80211_node *, int, u_int32_t);
d67 1
a67 1
		struct ieee80211_node *, int, int, u_int32_t);
d131 2
a132 2
	    const struct ieee80211_frame *, struct ieee80211_node *, int,
	    u_int32_t, u_int16_t, u_int16_t);
@


1.28
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.27 2007/08/23 16:59:32 damien Exp $	*/
d129 3
a131 8
extern	void ieee80211_eapol_key_mic(struct ieee80211_eapol_key *,
		const u_int8_t *);
extern	int ieee80211_eapol_key_check_mic(struct ieee80211_eapol_key *,
		const u_int8_t *);
extern	void ieee80211_eapol_key_encrypt(struct ieee80211com *,
		struct ieee80211_eapol_key *, const u_int8_t *);
extern	int ieee80211_eapol_key_decrypt(struct ieee80211_eapol_key *,
		const u_int8_t *);
@


1.27
log
@add ieee80211_get_hdrlen() to compute the size of the 802.11 header
of a management or data frame  (check if the i_qos, i_ht or i_addr4
are present).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.26 2007/08/03 16:51:06 damien Exp $	*/
d79 2
d84 2
a85 1
		struct ieee80211_node *, const u_int8_t *);
d119 1
a119 1
extern	u_int8_t *ieee80211_add_wpa1(u_int8_t *, struct ieee80211com *,
d137 3
@


1.26
log
@add a ni_eapol_desc field to struct ieee80211_node to know whether
a station is using WPA1 or RSN descriptors.
make sure that a station that advertises WPA1 capability in an IE
uses the WPA1 EAPOL-Key descriptor type and not the RSN one.
fix construction of EAPOL-Key frames for WPA1.
i can now successfuly complete a 4-way and group-key handshake
with both a WPA1 and a WPA2 access point.
add some TKIP encapsulation code (no SW crypto yet).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.25 2007/08/01 12:47:55 damien Exp $	*/
d60 1
@


1.25
log
@pass the supplicant's nonce generated on reception of message 1 of the
4-way handshake to ieee80211_send_4way_msg2().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.24 2007/07/28 11:24:06 damien Exp $	*/
d89 1
a89 1
		struct ieee80211_node *);
d91 1
a91 1
		struct ieee80211_node *, int);
@


1.24
log
@adds functions to parse and to build EAPOL-Key frames used in
the 4-way and group-key handshake.
the state machine is still missing though so this is not used
anywhere yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.23 2007/07/24 20:34:16 damien Exp $	*/
d81 1
a81 1
		struct ieee80211_node *);
@


1.23
log
@new function to check the MIC of a received EAPOL-Key frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.22 2007/07/24 16:53:03 damien Exp $	*/
d68 2
d78 14
@


1.22
log
@add functions to compute EAPOL-Key Key MIC fields and to encrypt/decrypt
EAPOL-Key Data fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.21 2007/07/14 19:58:05 damien Exp $	*/
d110 2
@


1.21
log
@update QoS Tx/Rx sequence numbers for each TID.
add a parameter to ieee80211_decap() to handle different 802.11
header sizes.
cleanup and clarify ieee80211_classify().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.20 2007/07/06 18:18:43 damien Exp $	*/
d109 6
@


1.20
log
@remove remaining bits for pre-RSNA shared authmode support.
it has been #if 0'd since 3.9 and we have never supported this mode (no
ifconfig option etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.19 2007/07/05 20:19:21 damien Exp $	*/
d78 1
a78 1
extern	struct mbuf *ieee80211_decap(struct ifnet *, struct mbuf *);
@


1.19
log
@split ieee80211_add_rsn() so that the code can be reused for
vendor-specific IE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.18 2007/07/03 19:44:54 damien Exp $	*/
a93 1
extern	u_int8_t *ieee80211_add_challenge(u_int8_t *, const u_int8_t *, u_int);
@


1.18
log
@add a function that builds an RSN IE (ieee80211_add_rsn).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.17 2007/07/03 16:43:41 damien Exp $	*/
d99 2
@


1.17
log
@move construction of IEs into individual functions so that we don't
duplicate the same code multiple times.
add references to the spec for all these functions.
fixes beacon_alloc() for FH PHYs as a side-effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.16 2007/07/02 16:46:44 damien Exp $	*/
d98 2
@


1.16
log
@initial bits for proper TIM support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.15 2007/06/21 21:06:12 damien Exp $	*/
a78 2
extern	u_int8_t *ieee80211_add_rates(u_int8_t *frm,
		const struct ieee80211_rateset *);
d81 4
a84 1
extern	u_int8_t *ieee80211_add_xrates(u_int8_t *frm,
d86 9
a94 1
extern	u_int8_t *ieee80211_add_ssid(u_int8_t *, const u_int8_t *, u_int);
a95 1
extern	u_int8_t *ieee80211_add_tim(u_int8_t *, struct ieee80211com *);
d98 2
a99 1
extern	u_int8_t *ieee80211_add_edca_params(u_int8_t *, struct ieee80211com *);
@


1.15
log
@add EDCA Parameter Set and QoS capability IEs to appropriate frames
when QoS is supported and activated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.14 2007/06/16 13:17:05 damien Exp $	*/
d87 1
@


1.14
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.13 2007/06/07 20:20:15 damien Exp $	*/
d87 3
@


1.13
log
@move ieee80211_compute_duration() and ieee80211_compute_duration1()
functions into the two drivers that use them (atw and rtw.)
this code is not generic enough to be used by other drivers and
there is no chance that it will ever be used in newer driver since
it supports 802.11b only.
plus, it hurts my eyes each time i look into ieee80211_output.c.

"fine with me as long as the logic doesn't change in the functions" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.12 2007/06/06 19:31:07 damien Exp $	*/
d52 3
a54 2
extern	const char *ieee80211_mgt_subtype_name[];
extern	const char *ieee80211_phymode_name[];
d87 2
a88 2
extern	void ieee80211_print_essid(u_int8_t *, int);
extern	void ieee80211_dump_pkt(u_int8_t *, int, int, int);
a93 1
extern	const char *ieee80211_state_name[IEEE80211_S_MAX];
@


1.12
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.11 2006/12/25 19:24:27 reyk Exp $	*/
a89 3
extern	int ieee80211_compute_duration(struct ieee80211_frame *, int,
		uint32_t, int, int, struct ieee80211_duration *,
		struct ieee80211_duration *, int *, int);
@


1.11
log
@print the phy mode in IFF_DEBUG status output which helps to debug
dual/multi mode chipset operation.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.10 2006/11/03 19:02:08 damien Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.10
log
@Add two new functions:
- ieee80211_get_rts
- ieee80211_get_cts_to_self
that can be use by drivers for chipsets that don't offer hardware assisted
RTS/CTS protection (like ral/ural/rum).

"no objections here" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.9 2006/06/18 18:39:41 damien Exp $	*/
d57 1
@


1.9
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.8 2006/05/19 18:06:50 damien Exp $	*/
d72 4
@


1.8
log
@- export ieee80211_add_ssid() just like ieee80211_add_(x)rates() so I don't
  need to duplicate the code in wpi(4)
- fix ieee80211_alloc_beacon()
- clean two comments while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.7 2005/04/20 19:52:43 reyk Exp $	*/
d84 1
d92 2
@


1.7
log
@send raw 802.11 frames with bpf(4) using the IEEE802_11 or
IEEE802_11_RADIO data link types.

ok canacar@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.6 2005/03/03 14:36:41 damien Exp $	*/
d83 1
@


1.6
log
@addtion of a generic function for allocating beacons: ieee80211_beacon_alloc().
ok jsg@@, reyk@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.5 2004/12/25 20:40:19 deraadt Exp $	*/
d64 2
@


1.5
log
@in real C, there is not , after the last enum entry; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.4 2004/12/23 12:27:25 jsg Exp $	*/
d70 2
@


1.4
log
@From dyoung@@NetBSD:

ieee80211.h r 1.9

#define the difference in microseconds between a fast and a slow
preamble and PLCP header.

ieee80211_output.c r 1.19

Fix a bug in ieee80211_compute_duration: the 802.11 Duration field
in an 802.11 unicast data packet is equal to the duration of the
SIFS and Acknowledgement.  That is, the amount of time reserved
*after* the packet has finished transmitting.

Change the arguments to ieee80211_compute_duration: pass the entire
packet length, not just the payload length.  Add a 'debug' argument
to ieee80211_compute_duration and its helper subroutine,
ieee80211_compute_duration1.

If debug != 0, ieee80211_compute_duration printfs its arguments
and several local variables.

In rtw(4), load the 802.11 Duration field with the result from
ieee80211_compute_duration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.3 2004/12/23 11:54:09 jsg Exp $	*/
d49 1
a49 1
	IEEE80211_S_RUN		= 4,	/* associated */
@


1.3
log
@From dyoung@@NetBSD:

Define for more bits in the Service field of the 802.11 PLCP Header.

For use by the subroutine ieee80211_compute_duration, add struct
ieee80211_duration, and #define a number of microsecond constants
used for the transmit timing of 802.11 packets.

Add the subroutine ieee80211_compute_duration, which computes for
any packet the appropriate 802.11 Duration field, the PLCP Length
field, as well as the Duration and Length fields for an RTS frame.

atw(4), rtw(4), future drivers, and possibly ath(4) will share
ieee80211_compute_duration.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.2 2004/11/02 02:15:49 reyk Exp $	*/
d85 1
a85 1
		struct ieee80211_duration *, int *);
@


1.2
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.h,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d83 3
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d81 2
@

