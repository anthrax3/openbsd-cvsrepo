head	1.8;
access;
symbols
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.4
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.4.0.4
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.3.0.14
	OPENBSD_5_4_BASE:1.3
	OPENBSD_5_3:1.3.0.12
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.10
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.8
	OPENBSD_5_0:1.3.0.6
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.4
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.4
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.6
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.2
	OPENBSD_4_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.8
date	2017.03.23.04.10.10;	author tb;	state Exp;
branches;
next	1.7;
commitid	EiuhETcE9N1Gqn0A;

1.7
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.6;
commitid	FuSD2mFDJWATHIDx;

1.6
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.5;
commitid	PYnSnAqgemmk34E3;

1.5
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.4;
commitid	B4dZSbxas1X1IpXI;

1.4
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2008.08.12.16.51.39;	author damien;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Use explicit_bzero() to wipe out key material and add some sizes to free().

ok stsp
@
text
@/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.7 2015/11/24 13:45:06 mpi Exp $	*/

/*-
 * Copyright (c) 2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This code implements the Broadcast/Multicast Integrity Protocol (BIP)
 * defined in IEEE P802.11w/D7.0 section 8.3.4.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_crypto.h>
#include <net80211/ieee80211_priv.h>

#include <crypto/rijndael.h>
#include <crypto/cmac.h>

/* BIP software crypto context */
struct ieee80211_bip_ctx {
	AES_CMAC_CTX	cmac;
};

/*
 * Initialize software crypto context.  This function can be overridden
 * by drivers doing hardware crypto.
 */
int
ieee80211_bip_set_key(struct ieee80211com *ic, struct ieee80211_key *k)
{
	struct ieee80211_bip_ctx *ctx;

	ctx = malloc(sizeof(*ctx), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ctx == NULL)
		return ENOMEM;
	AES_CMAC_SetKey(&ctx->cmac, k->k_key);
	k->k_priv = ctx;
	return 0;
}

void
ieee80211_bip_delete_key(struct ieee80211com *ic, struct ieee80211_key *k)
{
	if (k->k_priv != NULL) {
		explicit_bzero(k->k_priv, sizeof(struct ieee80211_bip_ctx));
		free(k->k_priv, M_DEVBUF, sizeof(struct ieee80211_bip_ctx));
	}
	k->k_priv = NULL;
}

/* pseudo-header used for BIP MIC computation */
struct ieee80211_bip_frame {
	u_int8_t	i_fc[2];
	u_int8_t	i_addr1[IEEE80211_ADDR_LEN];
	u_int8_t	i_addr2[IEEE80211_ADDR_LEN];
	u_int8_t	i_addr3[IEEE80211_ADDR_LEN];
} __packed;

struct mbuf *
ieee80211_bip_encap(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_bip_ctx *ctx = k->k_priv;
	struct ieee80211_bip_frame aad;
	struct ieee80211_frame *wh;
	u_int8_t *mmie, mic[AES_CMAC_DIGEST_LENGTH];
	struct mbuf *m;

	wh = mtod(m0, struct ieee80211_frame *);
	KASSERT((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT);
	/* clear Protected bit from group management frames */
	wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;

	/* construct AAD (additional authenticated data) */
	aad.i_fc[0] = wh->i_fc[0];
	aad.i_fc[1] = wh->i_fc[1] & ~(IEEE80211_FC1_RETRY |
	    IEEE80211_FC1_PWR_MGT | IEEE80211_FC1_MORE_DATA);
	/* XXX 11n may require clearing the Order bit too */
	IEEE80211_ADDR_COPY(aad.i_addr1, wh->i_addr1);
	IEEE80211_ADDR_COPY(aad.i_addr2, wh->i_addr2);
	IEEE80211_ADDR_COPY(aad.i_addr3, wh->i_addr3);

	AES_CMAC_Init(&ctx->cmac);
	AES_CMAC_Update(&ctx->cmac, (u_int8_t *)&aad, sizeof aad);
	AES_CMAC_Update(&ctx->cmac, (u_int8_t *)&wh[1],
	    m0->m_len - sizeof(*wh));

	m = m0;
	/* reserve trailing space for MMIE */
	if (M_TRAILINGSPACE(m) < IEEE80211_MMIE_LEN) {
		MGET(m->m_next, M_DONTWAIT, m->m_type);
		if (m->m_next == NULL)
			goto nospace;
		m = m->m_next;
		m->m_len = 0;
	}

	/* construct Management MIC IE */
	mmie = mtod(m, u_int8_t *) + m->m_len;
	mmie[0] = IEEE80211_ELEMID_MMIE;
	mmie[1] = 16;
	LE_WRITE_2(&mmie[2], k->k_id);
	LE_WRITE_6(&mmie[4], k->k_tsc);
	memset(&mmie[10], 0, 8);	/* MMIE MIC field set to 0 */

	AES_CMAC_Update(&ctx->cmac, mmie, IEEE80211_MMIE_LEN);
	AES_CMAC_Final(mic, &ctx->cmac);
	/* truncate AES-128-CMAC to 64-bit */
	memcpy(&mmie[10], mic, 8);

	m->m_len += IEEE80211_MMIE_LEN;
	m0->m_pkthdr.len += IEEE80211_MMIE_LEN;

	k->k_tsc++;

	return m0;
 nospace:
	ic->ic_stats.is_tx_nombuf++;
	m_freem(m0);
	return NULL;
}

struct mbuf *
ieee80211_bip_decap(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_bip_ctx *ctx = k->k_priv;
	struct ieee80211_frame *wh;
	struct ieee80211_bip_frame aad;
	u_int8_t *mmie, mic0[8], mic[AES_CMAC_DIGEST_LENGTH];
	u_int64_t ipn;

	wh = mtod(m0, struct ieee80211_frame *);
	KASSERT((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT);

	/*
	 * It is assumed that management frames are contiguous and that
	 * the mbuf length has already been checked to contain at least
	 * a header and a MMIE (checked in ieee80211_decrypt()).
	 */
	KASSERT(m0->m_len >= sizeof(*wh) + IEEE80211_MMIE_LEN);
	mmie = mtod(m0, u_int8_t *) + m0->m_len - IEEE80211_MMIE_LEN;

	ipn = LE_READ_6(&mmie[4]);
	if (ipn <= k->k_mgmt_rsc) {
		/* replayed frame, discard */
		ic->ic_stats.is_cmac_replays++;
		m_freem(m0);
		return NULL;
	}

	/* save and mask MMIE MIC field to 0 */
	memcpy(mic0, &mmie[10], 8);
	memset(&mmie[10], 0, 8);

	/* construct AAD (additional authenticated data) */
	aad.i_fc[0] = wh->i_fc[0];
	aad.i_fc[1] = wh->i_fc[1] & ~(IEEE80211_FC1_RETRY |
	    IEEE80211_FC1_PWR_MGT | IEEE80211_FC1_MORE_DATA);
	/* XXX 11n may require clearing the Order bit too */
	IEEE80211_ADDR_COPY(aad.i_addr1, wh->i_addr1);
	IEEE80211_ADDR_COPY(aad.i_addr2, wh->i_addr2);
	IEEE80211_ADDR_COPY(aad.i_addr3, wh->i_addr3);

	/* compute MIC */
	AES_CMAC_Init(&ctx->cmac);
	AES_CMAC_Update(&ctx->cmac, (u_int8_t *)&aad, sizeof aad);
	AES_CMAC_Update(&ctx->cmac, (u_int8_t *)&wh[1],
	    m0->m_len - sizeof(*wh));
	AES_CMAC_Final(mic, &ctx->cmac);

	/* check that MIC matches the one in MMIE */
	if (timingsafe_bcmp(mic, mic0, 8) != 0) {
		ic->ic_stats.is_cmac_icv_errs++;
		m_freem(m0);
		return NULL;
	}
	/*
	 * There is no need to trim the MMIE from the mbuf since it is
	 * an information element and will be ignored by upper layers.
	 * We do it anyway as it is cheap to do it here and because it
	 * may be confused with fixed fields by upper layers.
	 */
	m_adj(m0, -IEEE80211_MMIE_LEN);

	/* update last seen packet number (MIC is validated) */
	k->k_mgmt_rsc = ipn;

	return m0;
}
@


1.7
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.6 2014/12/23 03:24:08 tedu Exp $	*/
d71 4
a74 2
	if (k->k_priv != NULL)
		free(k->k_priv, M_DEVBUF, 0);
@


1.6
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.5 2014/07/12 18:44:22 tedu Exp $	*/
a34 1
#include <net/if_arp.h>
@


1.5
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.4 2013/11/21 16:16:08 mpi Exp $	*/
a36 1
#ifdef INET
a38 1
#endif
@


1.4
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.3 2010/07/20 15:36:03 matthew Exp $	*/
d75 1
a75 1
		free(k->k_priv, M_DEVBUF);
@


1.3
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.2 2009/01/26 19:09:41 damien Exp $	*/
a35 1
#include <net/if_llc.h>
@


1.2
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_bip.c,v 1.1 2008/08/12 16:51:39 damien Exp $	*/
d204 1
a204 1
	if (memcmp(mic, mic0, 8) != 0) {
@


1.1
log
@Welcome BIP: the Broadcast/Multicast Integrity Protocol defined
in Draft IEEE P802.11w.
It provides data integrity and replay protection for broadcast/
multicast robust management frames (not used yet) using AES-128
in CMAC mode.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d21 1
a21 1
 * defined in IEEE P802.11w/D6.0 section 8.3.4.
a201 2
	/* truncate AES-128-CMAC to 64-bit */
	memcpy(&mmie[10], mic, 8);
d204 1
a204 1
	if (memcmp(&mmie[10], mic0, 8) != 0) {
d212 2
a213 2
	 * We do it anyway as it is cheap to do it here and because we
	 * did not check for the presence of fixed fields yet.
@

