head	1.53;
access;
symbols
	OPENBSD_6_1:1.52.0.4
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.40.0.2
	OPENBSD_5_9_BASE:1.40
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.2
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.35.0.4
	OPENBSD_5_6_BASE:1.35
	OPENBSD_5_5:1.34.0.16
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.34.0.12
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.10
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.8
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.6
	OPENBSD_5_0:1.34.0.4
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.2
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.21.0.2
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.13.0.2
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.53
date	2017.07.19.22.04.46;	author stsp;	state Exp;
branches;
next	1.52;
commitid	gZpvksHeFnEVQiKg;

1.52
date	2017.03.23.04.10.10;	author tb;	state Exp;
branches
	1.52.4.1;
next	1.51;
commitid	EiuhETcE9N1Gqn0A;

1.51
date	2017.03.21.07.59.54;	author stsp;	state Exp;
branches;
next	1.50;
commitid	hdWNGSwm3UusNuyH;

1.50
date	2017.03.12.03.13.50;	author stsp;	state Exp;
branches;
next	1.49;
commitid	iIk6bEDpMYi2n0yI;

1.49
date	2017.03.11.13.22.36;	author stsp;	state Exp;
branches;
next	1.48;
commitid	Xn9kwljCeGOAIQo7;

1.48
date	2017.01.19.01.07.35;	author stsp;	state Exp;
branches;
next	1.47;
commitid	paqYPEm5MHXteY8R;

1.47
date	2016.12.31.17.51.44;	author phessler;	state Exp;
branches;
next	1.46;
commitid	kptA5JlWY04FswYn;

1.46
date	2016.12.20.13.27.58;	author stsp;	state Exp;
branches;
next	1.45;
commitid	DvA0P57klhTJwCz0;

1.45
date	2016.12.18.10.37.42;	author stsp;	state Exp;
branches;
next	1.44;
commitid	AFQR1xEK0cL7id30;

1.44
date	2016.09.15.03.32.48;	author dlg;	state Exp;
branches;
next	1.43;
commitid	prdL2stxGjOBR6s3;

1.43
date	2016.08.31.13.33.52;	author stsp;	state Exp;
branches;
next	1.42;
commitid	mlevwZuIrxBJkfDR;

1.42
date	2016.08.15.22.14.19;	author stsp;	state Exp;
branches;
next	1.41;
commitid	62DrW0TOO8uk24Wm;

1.41
date	2016.04.28.13.50.14;	author stsp;	state Exp;
branches;
next	1.40;
commitid	YnzDLdKGW1ZO3XJS;

1.40
date	2016.01.04.12.28.46;	author stsp;	state Exp;
branches;
next	1.39;
commitid	S2NzzdVoyw4dWKcX;

1.39
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.37;
commitid	PYnSnAqgemmk34E3;

1.37
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.36;
commitid	uzzBR7hz9ncd4O6G;

1.36
date	2014.09.12.16.02.40;	author sthen;	state Exp;
branches;
next	1.35;
commitid	aKTqOYHA8eIImugJ;

1.35
date	2014.07.10.14.32.28;	author stsp;	state Exp;
branches;
next	1.34;
commitid	l6yVFVZyUhUAysk2;

1.34
date	2010.09.29.20.00.51;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2009.09.12.19.37.27;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.06.07.57.27;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.15.08.34.36;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.13.17.24.54;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.12.14.11.59.41;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2008.12.03.17.24.45;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2008.10.02.20.21.15;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.25.16.47.44;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.12.29.15.45.56;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.23.21.34.15;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.03.08.06.14;	author uwe;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.02.22.00.49;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.01.16.52.25;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.01.16.29.55;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.27.22.27.56;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.25.11.20.04;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.19.29.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.28.02.51.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.52.4.1
date	2017.08.01.23.07.01;	author bluhm;	state Exp;
branches;
next	;
commitid	Ll7Tdjdwlohem5uJ;


desc
@@


1.53
log
@Plug an information leak in ieee80211_node2req().
Problem reported by Ilja Van Sprundel.
ok tb@@
@
text
@/*	$OpenBSD: ieee80211_ioctl.c,v 1.52 2017/03/23 04:10:10 tb Exp $	*/
/*	$NetBSD: ieee80211_ioctl.c,v 1.15 2004/05/06 02:58:16 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IEEE 802.11 ioctl support
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/endian.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_crypto.h>
#include <net80211/ieee80211_ioctl.h>

void	 ieee80211_node2req(struct ieee80211com *,
	    const struct ieee80211_node *, struct ieee80211_nodereq *);
void	 ieee80211_req2node(struct ieee80211com *,
	    const struct ieee80211_nodereq *, struct ieee80211_node *);
void	 ieee80211_disable_wep(struct ieee80211com *); 
void	 ieee80211_disable_rsn(struct ieee80211com *); 

void
ieee80211_node2req(struct ieee80211com *ic, const struct ieee80211_node *ni,
    struct ieee80211_nodereq *nr)
{
	uint8_t rssi;

	memset(nr, 0, sizeof(*nr));

	strlcpy(nr->nr_ifname, ic->ic_if.if_xname, sizeof(nr->nr_ifname));

	/* Node address and name information */
	IEEE80211_ADDR_COPY(nr->nr_macaddr, ni->ni_macaddr);
	IEEE80211_ADDR_COPY(nr->nr_bssid, ni->ni_bssid);
	nr->nr_nwid_len = ni->ni_esslen;
	bcopy(ni->ni_essid, nr->nr_nwid, IEEE80211_NWID_LEN);

	/* Channel and rates */
	nr->nr_channel = ieee80211_chan2ieee(ic, ni->ni_chan);
	nr->nr_chan_flags = ni->ni_chan->ic_flags;
	if (ic->ic_curmode != IEEE80211_MODE_11N)
		nr->nr_chan_flags &= ~IEEE80211_CHAN_HT;
	nr->nr_nrates = ni->ni_rates.rs_nrates;
	bcopy(ni->ni_rates.rs_rates, nr->nr_rates, IEEE80211_RATE_MAXSIZE);

	/* Node status information */
	rssi = (*ic->ic_node_getrssi)(ic, ni);
	if (ic->ic_max_rssi) {
		/* Driver reports RSSI relative to ic_max_rssi. */
		nr->nr_rssi = rssi;
	} else {
		/*
		 * Driver reports RSSI value in dBm.
		 * Convert from unsigned to signed.
		 * Some drivers report a negative value, some don't.
		 * Reasonable range is -20dBm to -80dBm.
		 */
		nr->nr_rssi = (rssi < 128) ? -rssi : rssi;
	}
	nr->nr_max_rssi = ic->ic_max_rssi;
	bcopy(ni->ni_tstamp, nr->nr_tstamp, sizeof(nr->nr_tstamp));
	nr->nr_intval = ni->ni_intval;
	nr->nr_capinfo = ni->ni_capinfo;
	nr->nr_erp = ni->ni_erp;
	nr->nr_pwrsave = ni->ni_pwrsave;
	nr->nr_associd = ni->ni_associd;
	nr->nr_txseq = ni->ni_txseq;
	nr->nr_rxseq = ni->ni_rxseq;
	nr->nr_fails = ni->ni_fails;
	nr->nr_inact = ni->ni_inact;
	nr->nr_txrate = ni->ni_txrate;
	nr->nr_state = ni->ni_state;

	/* RSN */
	nr->nr_rsnciphers = ni->ni_rsnciphers;
	nr->nr_rsnakms = 0;
	nr->nr_rsnprotos = 0;
	if (ni->ni_supported_rsnprotos & IEEE80211_PROTO_RSN)
		nr->nr_rsnprotos |= IEEE80211_WPA_PROTO_WPA2;
	if (ni->ni_supported_rsnprotos & IEEE80211_PROTO_WPA)
		nr->nr_rsnprotos |= IEEE80211_WPA_PROTO_WPA1;
	if (ni->ni_supported_rsnakms & IEEE80211_AKM_8021X)
		nr->nr_rsnakms |= IEEE80211_WPA_AKM_8021X;
	if (ni->ni_supported_rsnakms & IEEE80211_AKM_PSK)
		nr->nr_rsnakms |= IEEE80211_WPA_AKM_PSK;
	if (ni->ni_supported_rsnakms & IEEE80211_AKM_SHA256_8021X)
		nr->nr_rsnakms |= IEEE80211_WPA_AKM_SHA256_8021X;
	if (ni->ni_supported_rsnakms & IEEE80211_AKM_SHA256_PSK)
		nr->nr_rsnakms |= IEEE80211_WPA_AKM_SHA256_PSK;

	/* Node flags */
	nr->nr_flags = 0;
	if (bcmp(nr->nr_macaddr, nr->nr_bssid, IEEE80211_ADDR_LEN) == 0)
		nr->nr_flags |= IEEE80211_NODEREQ_AP;
	if (ni == ic->ic_bss)
		nr->nr_flags |= IEEE80211_NODEREQ_AP_BSS;

	/* HT */
	nr->nr_htcaps = ni->ni_htcaps;
	memcpy(nr->nr_rxmcs, ni->ni_rxmcs, sizeof(nr->nr_rxmcs));
	nr->nr_max_rxrate = ni->ni_max_rxrate;
	nr->nr_tx_mcs_set = ni->ni_tx_mcs_set;
	nr->nr_txmcs = ni->ni_txmcs;
	if (ni->ni_flags & IEEE80211_NODE_HT)
		nr->nr_flags |= IEEE80211_NODEREQ_HT;
}

void
ieee80211_req2node(struct ieee80211com *ic, const struct ieee80211_nodereq *nr,
    struct ieee80211_node *ni)
{
	/* Node address and name information */
	IEEE80211_ADDR_COPY(ni->ni_macaddr, nr->nr_macaddr);
	IEEE80211_ADDR_COPY(ni->ni_bssid, nr->nr_bssid);
	ni->ni_esslen = nr->nr_nwid_len;
	bcopy(nr->nr_nwid, ni->ni_essid, IEEE80211_NWID_LEN);

	/* Rates */
	ni->ni_rates.rs_nrates = nr->nr_nrates;
	bcopy(nr->nr_rates, ni->ni_rates.rs_rates, IEEE80211_RATE_MAXSIZE);

	/* Node information */
	ni->ni_intval = nr->nr_intval;
	ni->ni_capinfo = nr->nr_capinfo;
	ni->ni_erp = nr->nr_erp;
	ni->ni_pwrsave = nr->nr_pwrsave;
	ni->ni_associd = nr->nr_associd;
	ni->ni_txseq = nr->nr_txseq;
	ni->ni_rxseq = nr->nr_rxseq;
	ni->ni_fails = nr->nr_fails;
	ni->ni_inact = nr->nr_inact;
	ni->ni_txrate = nr->nr_txrate;
	ni->ni_state = nr->nr_state;
}

void
ieee80211_disable_wep(struct ieee80211com *ic)
{
	struct ieee80211_key *k;
	int i;
	
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		k = &ic->ic_nw_keys[i];
		if (k->k_cipher != IEEE80211_CIPHER_NONE)
			(*ic->ic_delete_key)(ic, NULL, k);
		explicit_bzero(k, sizeof(*k));
	}
	ic->ic_flags &= ~IEEE80211_F_WEPON;
}

void
ieee80211_disable_rsn(struct ieee80211com *ic)
{
	ic->ic_flags &= ~(IEEE80211_F_PSK | IEEE80211_F_RSNON);
	explicit_bzero(ic->ic_psk, sizeof(ic->ic_psk));
	ic->ic_rsnprotos = 0;
	ic->ic_rsnakms = 0;
	ic->ic_rsngroupcipher = 0;
	ic->ic_rsnciphers = 0;
}

static int
ieee80211_ioctl_setnwkeys(struct ieee80211com *ic,
    const struct ieee80211_nwkey *nwkey)
{
	struct ieee80211_key *k;
	int error, i;

	if (!(ic->ic_caps & IEEE80211_C_WEP))
		return ENODEV;

	if (nwkey->i_wepon == IEEE80211_NWKEY_OPEN) {
		if (!(ic->ic_flags & IEEE80211_F_WEPON))
			return 0;
		ic->ic_flags &= ~IEEE80211_F_WEPON;
		return ENETRESET;
	}
	if (nwkey->i_defkid < 1 || nwkey->i_defkid > IEEE80211_WEP_NKID)
		return EINVAL;

	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keylen == 0 ||
		    nwkey->i_key[i].i_keydat == NULL)
			continue;	/* entry not set */
		if (nwkey->i_key[i].i_keylen > IEEE80211_KEYBUF_SIZE)
			return EINVAL;

		/* map wep key to ieee80211_key */
		k = &ic->ic_nw_keys[i];
		if (k->k_cipher != IEEE80211_CIPHER_NONE)
			(*ic->ic_delete_key)(ic, NULL, k);
		memset(k, 0, sizeof(*k));
		if (nwkey->i_key[i].i_keylen <= 5)
			k->k_cipher = IEEE80211_CIPHER_WEP40;
		else
			k->k_cipher = IEEE80211_CIPHER_WEP104;
		k->k_len = ieee80211_cipher_keylen(k->k_cipher);
		k->k_flags = IEEE80211_KEY_GROUP | IEEE80211_KEY_TX;
		error = copyin(nwkey->i_key[i].i_keydat, k->k_key, k->k_len);
		if (error != 0)
			return error;
		if ((error = (*ic->ic_set_key)(ic, NULL, k)) != 0)
			return error;
	}

	ic->ic_def_txkey = nwkey->i_defkid - 1;
	ic->ic_flags |= IEEE80211_F_WEPON;
	if (ic->ic_flags & IEEE80211_F_RSNON)
		ieee80211_disable_rsn(ic);

	return ENETRESET;
}

static int
ieee80211_ioctl_getnwkeys(struct ieee80211com *ic,
    struct ieee80211_nwkey *nwkey)
{
	struct ieee80211_key *k;
	int error, i;

	if (ic->ic_flags & IEEE80211_F_WEPON)
		nwkey->i_wepon = IEEE80211_NWKEY_WEP;
	else
		nwkey->i_wepon = IEEE80211_NWKEY_OPEN;

	nwkey->i_defkid = ic->ic_wep_txkey + 1;

	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (nwkey->i_key[i].i_keydat == NULL)
			continue;
		/* do not show any keys to non-root user */
		if ((error = suser(curproc, 0)) != 0)
			return error;
		k = &ic->ic_nw_keys[i];
		if (k->k_cipher != IEEE80211_CIPHER_WEP40 &&
		    k->k_cipher != IEEE80211_CIPHER_WEP104)
			nwkey->i_key[i].i_keylen = 0;
		else
			nwkey->i_key[i].i_keylen = k->k_len;
		error = copyout(k->k_key, nwkey->i_key[i].i_keydat,
		    nwkey->i_key[i].i_keylen);
		if (error != 0)
			return error;
	}
	return 0;
}

static int
ieee80211_ioctl_setwpaparms(struct ieee80211com *ic,
    const struct ieee80211_wpaparams *wpa)
{
	if (!(ic->ic_caps & IEEE80211_C_RSN))
		return ENODEV;

	if (!wpa->i_enabled) {
		if (!(ic->ic_flags & IEEE80211_F_RSNON))
			return 0;
		ic->ic_flags &= ~IEEE80211_F_RSNON;
		ic->ic_rsnprotos = 0;
		ic->ic_rsnakms = 0;
		ic->ic_rsngroupcipher = 0;
		ic->ic_rsnciphers = 0;
		return ENETRESET;
	}

	ic->ic_rsnprotos = 0;
	if (wpa->i_protos & IEEE80211_WPA_PROTO_WPA1)
		ic->ic_rsnprotos |= IEEE80211_PROTO_WPA;
	if (wpa->i_protos & IEEE80211_WPA_PROTO_WPA2)
		ic->ic_rsnprotos |= IEEE80211_PROTO_RSN;
	if (ic->ic_rsnprotos == 0)	/* set to default (RSN) */
		ic->ic_rsnprotos = IEEE80211_PROTO_RSN;

	ic->ic_rsnakms = 0;
	if (wpa->i_akms & IEEE80211_WPA_AKM_PSK)
		ic->ic_rsnakms |= IEEE80211_AKM_PSK;
	if (wpa->i_akms & IEEE80211_WPA_AKM_SHA256_PSK)
		ic->ic_rsnakms |= IEEE80211_AKM_SHA256_PSK;
	if (wpa->i_akms & IEEE80211_WPA_AKM_8021X)
		ic->ic_rsnakms |= IEEE80211_AKM_8021X;
	if (wpa->i_akms & IEEE80211_WPA_AKM_SHA256_8021X)
		ic->ic_rsnakms |= IEEE80211_AKM_SHA256_8021X;
	if (ic->ic_rsnakms == 0)	/* set to default (PSK) */
		ic->ic_rsnakms = IEEE80211_AKM_PSK;

	if (wpa->i_groupcipher == IEEE80211_WPA_CIPHER_WEP40)
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_WEP40;
	else if (wpa->i_groupcipher == IEEE80211_WPA_CIPHER_TKIP)
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_TKIP;
	else if (wpa->i_groupcipher == IEEE80211_WPA_CIPHER_CCMP)
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_CCMP;
	else if (wpa->i_groupcipher == IEEE80211_WPA_CIPHER_WEP104)
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_WEP104;
	else  {	/* set to default */
		if (ic->ic_rsnprotos & IEEE80211_PROTO_WPA)
			ic->ic_rsngroupcipher = IEEE80211_CIPHER_TKIP;
		else
			ic->ic_rsngroupcipher = IEEE80211_CIPHER_CCMP;
	}

	ic->ic_rsnciphers = 0;
	if (wpa->i_ciphers & IEEE80211_WPA_CIPHER_TKIP)
		ic->ic_rsnciphers |= IEEE80211_CIPHER_TKIP;
	if (wpa->i_ciphers & IEEE80211_WPA_CIPHER_CCMP)
		ic->ic_rsnciphers |= IEEE80211_CIPHER_CCMP;
	if (wpa->i_ciphers & IEEE80211_WPA_CIPHER_USEGROUP)
		ic->ic_rsnciphers = IEEE80211_CIPHER_USEGROUP;
	if (ic->ic_rsnciphers == 0) { /* set to default (CCMP, TKIP if WPA1) */
		ic->ic_rsnciphers = IEEE80211_CIPHER_CCMP;
		if (ic->ic_rsnprotos & IEEE80211_PROTO_WPA)
			ic->ic_rsnciphers |= IEEE80211_CIPHER_TKIP;
	}

	ic->ic_flags |= IEEE80211_F_RSNON;

	return ENETRESET;
}

static int
ieee80211_ioctl_getwpaparms(struct ieee80211com *ic,
    struct ieee80211_wpaparams *wpa)
{
	wpa->i_enabled = (ic->ic_flags & IEEE80211_F_RSNON) ? 1 : 0;

	wpa->i_protos = 0;
	if (ic->ic_rsnprotos & IEEE80211_PROTO_WPA)
		wpa->i_protos |= IEEE80211_WPA_PROTO_WPA1;
	if (ic->ic_rsnprotos & IEEE80211_PROTO_RSN)
		wpa->i_protos |= IEEE80211_WPA_PROTO_WPA2;

	wpa->i_akms = 0;
	if (ic->ic_rsnakms & IEEE80211_AKM_PSK)
		wpa->i_akms |= IEEE80211_WPA_AKM_PSK;
	if (ic->ic_rsnakms & IEEE80211_AKM_SHA256_PSK)
		wpa->i_akms |= IEEE80211_WPA_AKM_SHA256_PSK;
	if (ic->ic_rsnakms & IEEE80211_AKM_8021X)
		wpa->i_akms |= IEEE80211_WPA_AKM_8021X;
	if (ic->ic_rsnakms & IEEE80211_AKM_SHA256_8021X)
		wpa->i_akms |= IEEE80211_WPA_AKM_SHA256_8021X;

	if (ic->ic_rsngroupcipher == IEEE80211_CIPHER_WEP40)
		wpa->i_groupcipher = IEEE80211_WPA_CIPHER_WEP40;
	else if (ic->ic_rsngroupcipher == IEEE80211_CIPHER_TKIP)
		wpa->i_groupcipher = IEEE80211_WPA_CIPHER_TKIP;
	else if (ic->ic_rsngroupcipher == IEEE80211_CIPHER_CCMP)
		wpa->i_groupcipher = IEEE80211_WPA_CIPHER_CCMP;
	else if (ic->ic_rsngroupcipher == IEEE80211_CIPHER_WEP104)
		wpa->i_groupcipher = IEEE80211_WPA_CIPHER_WEP104;
	else
		wpa->i_groupcipher = IEEE80211_WPA_CIPHER_NONE;

	wpa->i_ciphers = 0;
	if (ic->ic_rsnciphers & IEEE80211_CIPHER_TKIP)
		wpa->i_ciphers |= IEEE80211_WPA_CIPHER_TKIP;
	if (ic->ic_rsnciphers & IEEE80211_CIPHER_CCMP)
		wpa->i_ciphers |= IEEE80211_WPA_CIPHER_CCMP;
	if (ic->ic_rsnciphers & IEEE80211_CIPHER_USEGROUP)
		wpa->i_ciphers = IEEE80211_WPA_CIPHER_USEGROUP;

	return 0;
}

int
ieee80211_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ifreq *ifr = (struct ifreq *)data;
	int i, error = 0;
	struct ieee80211_nwid nwid;
	struct ieee80211_wpapsk *psk;
	struct ieee80211_wmmparams *wmm;
	struct ieee80211_keyavail *ka;
	struct ieee80211_keyrun *kr;
	struct ieee80211_power *power;
	struct ieee80211_bssid *bssid;
	struct ieee80211chanreq *chanreq;
	struct ieee80211_channel *chan;
	struct ieee80211_txpower *txpower;
	static const u_int8_t empty_macaddr[IEEE80211_ADDR_LEN] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	struct ieee80211_nodereq *nr, nrbuf;
	struct ieee80211_nodereq_all *na;
	struct ieee80211_node *ni;
	u_int32_t flags;

	switch (cmd) {
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &ic->ic_media, cmd);
		break;
	case SIOCS80211NWID:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if ((error = copyin(ifr->ifr_data, &nwid, sizeof(nwid))) != 0)
			break;
		if (nwid.i_len > IEEE80211_NWID_LEN) {
			error = EINVAL;
			break;
		}
		memset(ic->ic_des_essid, 0, IEEE80211_NWID_LEN);
		ic->ic_des_esslen = nwid.i_len;
		memcpy(ic->ic_des_essid, nwid.i_nwid, nwid.i_len);
		error = ENETRESET;
		break;
	case SIOCG80211NWID:
		memset(&nwid, 0, sizeof(nwid));
		switch (ic->ic_state) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
			nwid.i_len = ic->ic_des_esslen;
			memcpy(nwid.i_nwid, ic->ic_des_essid, nwid.i_len);
			break;
		default:
			nwid.i_len = ic->ic_bss->ni_esslen;
			memcpy(nwid.i_nwid, ic->ic_bss->ni_essid, nwid.i_len);
			break;
		}
		error = copyout(&nwid, ifr->ifr_data, sizeof(nwid));
		break;
	case SIOCS80211NWKEY:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = ieee80211_ioctl_setnwkeys(ic, (void *)data);
		break;
	case SIOCG80211NWKEY:
		error = ieee80211_ioctl_getnwkeys(ic, (void *)data);
		break;
	case SIOCS80211WMMPARMS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		if (!(ic->ic_flags & IEEE80211_C_QOS)) {
			error = ENODEV;
			break;
		}
		wmm = (struct ieee80211_wmmparams *)data;
		if (wmm->i_enabled)
			ic->ic_flags |= IEEE80211_F_QOS;
		else
			ic->ic_flags &= ~IEEE80211_F_QOS;
		error = ENETRESET;
		break;
	case SIOCG80211WMMPARMS:
		wmm = (struct ieee80211_wmmparams *)data;
		wmm->i_enabled = (ic->ic_flags & IEEE80211_F_QOS) ? 1 : 0;
		break;
	case SIOCS80211WPAPARMS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		error = ieee80211_ioctl_setwpaparms(ic, (void *)data);
		break;
	case SIOCG80211WPAPARMS:
		error = ieee80211_ioctl_getwpaparms(ic, (void *)data);
		break;
	case SIOCS80211WPAPSK:
		if ((error = suser(curproc, 0)) != 0)
			break;
		psk = (struct ieee80211_wpapsk *)data;
		if (psk->i_enabled) {
			ic->ic_flags |= IEEE80211_F_PSK;
			memcpy(ic->ic_psk, psk->i_psk, sizeof(ic->ic_psk));
			if (ic->ic_flags & IEEE80211_F_WEPON)
				ieee80211_disable_wep(ic);
		} else {
			ic->ic_flags &= ~IEEE80211_F_PSK;
			memset(ic->ic_psk, 0, sizeof(ic->ic_psk));
		}
		error = ENETRESET;
		break;
	case SIOCG80211WPAPSK:
		psk = (struct ieee80211_wpapsk *)data;
		if (ic->ic_flags & IEEE80211_F_PSK) {
			psk->i_enabled = 1;
			/* do not show any keys to non-root user */
			if (suser(curproc, 0) != 0) {
				psk->i_enabled = 2;
				memset(psk->i_psk, 0, sizeof(psk->i_psk));
				break;	/* return ok but w/o key */
			}
			memcpy(psk->i_psk, ic->ic_psk, sizeof(psk->i_psk));
		} else
			psk->i_enabled = 0;
		break;
	case SIOCS80211KEYAVAIL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		ka = (struct ieee80211_keyavail *)data;
		(void)ieee80211_pmksa_add(ic, IEEE80211_AKM_8021X,
		    ka->i_macaddr, ka->i_key, ka->i_lifetime);
		break;
	case SIOCS80211KEYRUN:
		if ((error = suser(curproc, 0)) != 0)
			break;
		kr = (struct ieee80211_keyrun *)data;
		error = ieee80211_keyrun(ic, kr->i_macaddr);
		if (error == 0 && (ic->ic_flags & IEEE80211_F_WEPON))
			ieee80211_disable_wep(ic);
		break;
	case SIOCS80211POWER:
		if ((error = suser(curproc, 0)) != 0)
			break;
		power = (struct ieee80211_power *)data;
		ic->ic_lintval = power->i_maxsleep;
		if (power->i_enabled != 0) {
			if ((ic->ic_caps & IEEE80211_C_PMGT) == 0)
				error = EINVAL;
			else if ((ic->ic_flags & IEEE80211_F_PMGTON) == 0) {
				ic->ic_flags |= IEEE80211_F_PMGTON;
				error = ENETRESET;
			}
		} else {
			if (ic->ic_flags & IEEE80211_F_PMGTON) {
				ic->ic_flags &= ~IEEE80211_F_PMGTON;
				error = ENETRESET;
			}
		}
		break;
	case SIOCG80211POWER:
		power = (struct ieee80211_power *)data;
		power->i_enabled = (ic->ic_flags & IEEE80211_F_PMGTON) ? 1 : 0;
		power->i_maxsleep = ic->ic_lintval;
		break;
	case SIOCS80211BSSID:
		if ((error = suser(curproc, 0)) != 0)
			break;
		bssid = (struct ieee80211_bssid *)data;
		if (IEEE80211_ADDR_EQ(bssid->i_bssid, empty_macaddr))
			ic->ic_flags &= ~IEEE80211_F_DESBSSID;
		else {
			ic->ic_flags |= IEEE80211_F_DESBSSID;
			IEEE80211_ADDR_COPY(ic->ic_des_bssid, bssid->i_bssid);
		}
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP)
			break;
#endif
		switch (ic->ic_state) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
			error = ENETRESET;
			break;
		default:
			if ((ic->ic_flags & IEEE80211_F_DESBSSID) &&
			    !IEEE80211_ADDR_EQ(ic->ic_des_bssid,
			    ic->ic_bss->ni_bssid))
				error = ENETRESET;
			break;
		}
		break;
	case SIOCG80211BSSID:
		bssid = (struct ieee80211_bssid *)data;
		switch (ic->ic_state) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP)
				IEEE80211_ADDR_COPY(bssid->i_bssid,
				    ic->ic_myaddr);
			else
#endif
			if (ic->ic_flags & IEEE80211_F_DESBSSID)
				IEEE80211_ADDR_COPY(bssid->i_bssid,
				    ic->ic_des_bssid);
			else
				memset(bssid->i_bssid, 0, IEEE80211_ADDR_LEN);
			break;
		default:
			IEEE80211_ADDR_COPY(bssid->i_bssid,
			    ic->ic_bss->ni_bssid);
			break;
		}
		break;
	case SIOCS80211CHANNEL:
		if ((error = suser(curproc, 0)) != 0)
			break;
		chanreq = (struct ieee80211chanreq *)data;
		if (chanreq->i_channel == IEEE80211_CHAN_ANY)
			ic->ic_des_chan = IEEE80211_CHAN_ANYC;
		else if (chanreq->i_channel > IEEE80211_CHAN_MAX ||
		    isclr(ic->ic_chan_active, chanreq->i_channel)) {
			error = EINVAL;
			break;
		} else
			ic->ic_ibss_chan = ic->ic_des_chan =
			    &ic->ic_channels[chanreq->i_channel];
		switch (ic->ic_state) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
			error = ENETRESET;
			break;
		default:
			if (ic->ic_opmode == IEEE80211_M_STA) {
				if (ic->ic_des_chan != IEEE80211_CHAN_ANYC &&
				    ic->ic_bss->ni_chan != ic->ic_des_chan)
					error = ENETRESET;
			} else {
				if (ic->ic_bss->ni_chan != ic->ic_ibss_chan)
					error = ENETRESET;
			}
			break;
		}
		break;
	case SIOCG80211CHANNEL:
		chanreq = (struct ieee80211chanreq *)data;
		switch (ic->ic_state) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
			if (ic->ic_opmode == IEEE80211_M_STA)
				chan = ic->ic_des_chan;
			else
				chan = ic->ic_ibss_chan;
			break;
		default:
			chan = ic->ic_bss->ni_chan;
			break;
		}
		chanreq->i_channel = ieee80211_chan2ieee(ic, chan);
		break;
	case SIOCG80211ALLCHANS:
		error = copyout(ic->ic_channels,
		    ((struct ieee80211_chanreq_all *)data)->i_chans,
		    sizeof(ic->ic_channels));
		break;
#if 0
	case SIOCG80211ZSTATS:
#endif
	case SIOCG80211STATS:
		ifr = (struct ifreq *)data;
		error = copyout(&ic->ic_stats, ifr->ifr_data,
		    sizeof(ic->ic_stats));
#if 0
		if (cmd == SIOCG80211ZSTATS)
			memset(&ic->ic_stats, 0, sizeof(ic->ic_stats));
#endif
		break;
	case SIOCS80211TXPOWER:
		if ((error = suser(curproc, 0)) != 0)
			break;
		txpower = (struct ieee80211_txpower *)data;
		if ((ic->ic_caps & IEEE80211_C_TXPMGT) == 0) {
			error = EINVAL;
			break;
		}
		if (!(IEEE80211_TXPOWER_MIN <= txpower->i_val &&
			txpower->i_val <= IEEE80211_TXPOWER_MAX)) {
			error = EINVAL;
			break;
		}
		ic->ic_txpower = txpower->i_val;
		error = ENETRESET;
		break;
	case SIOCG80211TXPOWER:
		txpower = (struct ieee80211_txpower *)data;
		if ((ic->ic_caps & IEEE80211_C_TXPMGT) == 0)
			error = EINVAL;
		else
			txpower->i_val = ic->ic_txpower;
		break;
	case SIOCSIFMTU:
		ifr = (struct ifreq *)data;
		if (!(IEEE80211_MTU_MIN <= ifr->ifr_mtu &&
		    ifr->ifr_mtu <= IEEE80211_MTU_MAX))
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCS80211SCAN:
		if ((error = suser(curproc, 0)) != 0)
			break;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP)
			break;
#endif
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) !=
		    (IFF_UP | IFF_RUNNING)) {
			error = ENETDOWN;
			break;
		}
		if ((ic->ic_scan_lock & IEEE80211_SCAN_REQUEST) == 0) {
			if (ic->ic_scan_lock & IEEE80211_SCAN_LOCKED)
				ic->ic_scan_lock |= IEEE80211_SCAN_RESUME;
			ic->ic_scan_lock |= IEEE80211_SCAN_REQUEST;
			if (ic->ic_state != IEEE80211_S_SCAN) {
				ieee80211_clean_cached(ic);
				if (ic->ic_opmode == IEEE80211_M_STA &&
				    ic->ic_state == IEEE80211_S_RUN &&
				    IFM_MODE(ic->ic_media.ifm_cur->ifm_media)
				    == IFM_AUTO) {
					/* 
					 * We're already associated to an AP.
					 * Make the scanning loop start off in
					 * auto mode so all supported bands
					 * get scanned.
					 */
					ieee80211_setmode(ic,
					    IEEE80211_MODE_AUTO);
				}
				ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
			}
		}
		/* Let the userspace process wait for completion */
		error = tsleep(&ic->ic_scan_lock, PCATCH, "80211scan",
		    hz * IEEE80211_SCAN_TIMEOUT);
		break;
	case SIOCG80211NODE:
		nr = (struct ieee80211_nodereq *)data;
		ni = ieee80211_find_node(ic, nr->nr_macaddr);
		if (ni == NULL) {
			error = ENOENT;
			break;
		}
		ieee80211_node2req(ic, ni, nr);
		break;
	case SIOCS80211NODE:
		if ((error = suser(curproc, 0)) != 0)
			break;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			error = EINVAL;
			break;
		}
#endif
		nr = (struct ieee80211_nodereq *)data;

		ni = ieee80211_find_node(ic, nr->nr_macaddr);
		if (ni == NULL)
			ni = ieee80211_alloc_node(ic, nr->nr_macaddr);
		if (ni == NULL) {
			error = ENOENT;
			break;
		}

		if (nr->nr_flags & IEEE80211_NODEREQ_COPY)
			ieee80211_req2node(ic, nr, ni);
		break;
#ifndef IEEE80211_STA_ONLY
	case SIOCS80211DELNODE:
		if ((error = suser(curproc, 0)) != 0)
			break;
		nr = (struct ieee80211_nodereq *)data;
		ni = ieee80211_find_node(ic, nr->nr_macaddr);
		if (ni == NULL)
			error = ENOENT;
		else if (ni == ic->ic_bss)
			error = EPERM;
		else {
			if (ni->ni_state == IEEE80211_STA_COLLECT)
				break;

			/* Disassociate station. */
			if (ni->ni_state == IEEE80211_STA_ASSOC)
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DISASSOC,
				    IEEE80211_REASON_ASSOC_LEAVE);

			/* Deauth station. */
			if (ni->ni_state >= IEEE80211_STA_AUTH)
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DEAUTH,
				    IEEE80211_REASON_AUTH_LEAVE);

			ieee80211_node_leave(ic, ni);
		}
		break;
#endif
	case SIOCG80211ALLNODES:
		na = (struct ieee80211_nodereq_all *)data;
		na->na_nodes = i = 0;
		ni = RBT_MIN(ieee80211_tree, &ic->ic_tree);
		while (ni && na->na_size >=
		    i + sizeof(struct ieee80211_nodereq)) {
			ieee80211_node2req(ic, ni, &nrbuf);
			error = copyout(&nrbuf, (caddr_t)na->na_node + i,
			    sizeof(struct ieee80211_nodereq));
			if (error)
				break;
			i += sizeof(struct ieee80211_nodereq);
			na->na_nodes++;
			ni = RBT_NEXT(ieee80211_tree, ni);
		}
		break;
	case SIOCG80211FLAGS:
		flags = ic->ic_flags;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
			flags &= ~IEEE80211_F_HOSTAPMASK;
		ifr->ifr_flags = flags >> IEEE80211_F_USERSHIFT;
		break;
	case SIOCS80211FLAGS:
		if ((error = suser(curproc, 0)) != 0)
			break;
		flags = (u_int32_t)ifr->ifr_flags << IEEE80211_F_USERSHIFT;
		if (
#ifndef IEEE80211_STA_ONLY
		    ic->ic_opmode != IEEE80211_M_HOSTAP &&
#endif
		    (flags & IEEE80211_F_HOSTAPMASK)) {
			error = EINVAL;
			break;
		}
		ic->ic_flags = (ic->ic_flags & ~IEEE80211_F_USERMASK) | flags;
		error = ENETRESET;
		break;
	default:
		error = ether_ioctl(ifp, &ic->ic_ac, cmd, data);
	}

	return error;
}
@


1.52
log
@Use explicit_bzero() to wipe out key material and add some sizes to free().

ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.51 2017/03/21 07:59:54 stsp Exp $	*/
d66 4
@


1.52.4.1
log
@Plug an information leak in ieee80211_node2req().
Problem reported by Ilja Van Sprundel.
errata 023
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.52 2017/03/23 04:10:10 tb Exp $	*/
a65 4

	memset(nr, 0, sizeof(*nr));

	strlcpy(nr->nr_ifname, ic->ic_if.if_xname, sizeof(nr->nr_ifname));
@


1.51
log
@When a new WPA key is set while WEP is enabled, disable WEP,
and when a new WEP key is set while WPA is enabled, disable WPA.
Prevents unusable configurations where both WEP and WPA are active
and makes switching between WEP/WPA networks easier.
ok deraadt@@ tb@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.50 2017/03/12 03:13:50 stsp Exp $	*/
d181 1
a181 1
		memset(k, 0, sizeof(*k));
d190 1
a190 1
	memset(ic->ic_psk, 0, sizeof(ic->ic_psk));
@


1.50
log
@Introduce separate fields for supported WPA protocols and AKMs in struct
ieee80211_node. Pass these fields to 'ifconfig scan' instead of giving it
currently configured/enabled settings.
Fixes display of AP WPA capabilities in 'ifconfig scan' while the wifi
interface is not configured to use WPA (my previous commit attempted to
fix the same problem but didn't make it work in all cases).
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.49 2017/03/11 13:22:36 stsp Exp $	*/
d58 2
d171 26
d243 2
d497 2
d531 2
@


1.49
log
@Make 'ifconfig scan' display AP encryption correctly if WEP is configured
on the local wifi interface. ifconfig was mistakenly showing the common
supported subset of client and AP, rather than showing the AP's capabilities.
Exposes WPA protocol capabilities in struct ieee80211_nodereq, which means
ifconfig must be recompiled to run on a new kernel.
ok deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.48 2017/01/19 01:07:35 stsp Exp $	*/
d111 3
a113 1
	if (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)
d115 1
a115 3
	if (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)
		nr->nr_rsnprotos |= IEEE80211_WPA_PROTO_WPA2;
	if (ni->ni_rsnakms & IEEE80211_AKM_8021X)
d117 1
a117 1
	if (ni->ni_rsnakms & IEEE80211_AKM_PSK)
d119 1
a119 1
	if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_8021X)
d121 1
a121 1
	if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_PSK)
@


1.48
log
@Enable TKIP as pairwise cipher when ifconfig's wpaprotos option enables WPA1.
Without this fix it was impossible to use WPA1 without also making use of the
wpaciphers option to enable TKIP. Problem noticed by pirofti@@.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.47 2016/12/31 17:51:44 phessler Exp $	*/
d110 5
@


1.47
log
@When we disable WPA on an interface, wipe all of the WPA parameters,
including removing the 802.1x configuration from the card.

Found while coming home from CCC Congress.

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.46 2016/12/20 13:27:58 stsp Exp $	*/
d308 1
a308 1
	if (ic->ic_rsnciphers == 0)	/* set to default (CCMP) */
d310 3
@


1.46
log
@Disable TKIP (WPA1) by default.

It is time for this legacy of WEP to die (remember WEP?).
The 802.11-2012 standard says:
  The use of TKIP is deprecated. The TKIP algorithm is unsuitable for
  the purposes of this standard.

TKIP has numerous problems. One of which is that TKIP allows a denial of
service attack which can be triggered by any client. Report 2 Michael MIC
failures to a TKIP AP to trigger "TKIP countermeasures". The AP is now
required by the 802.11 standard to lock everyone out for at least 60 seconds.
The network will remain unusable for as long as such MIC failure reports
are sent twice per minute.

TKIP remains available for interoperability purposes, for now.
It must be enabled manually with ifconfig(8).

Prompted by discussion with Mathy Vanhoef.
ok deraadt@@ sthen@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.45 2016/12/18 10:37:42 stsp Exp $	*/
d259 4
@


1.45
log
@While copying out channel flags to userspace, omit the HT channel flag if
we're not in 11n mode. This will allow tcpdump to show the mode correctly.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.44 2016/09/15 03:32:48 dlg Exp $	*/
d267 2
a268 2
	if (ic->ic_rsnprotos == 0)	/* set to default (WPA+RSN) */
		ic->ic_rsnprotos = IEEE80211_PROTO_WPA | IEEE80211_PROTO_RSN;
d304 2
a305 3
	if (ic->ic_rsnciphers == 0)	/* set to default (TKIP+CCMP) */
		ic->ic_rsnciphers = IEEE80211_CIPHER_TKIP |
		    IEEE80211_CIPHER_CCMP;
@


1.44
log
@move from RB macros to the RBT functions.

shaves about 5k off an amd64 GENERIC.MP kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.43 2016/08/31 13:33:52 stsp Exp $	*/
d74 2
@


1.43
log
@If a driver reports RSSI in the 20-100 range, convert to a negative value.
Fixes dBm values displayed by 'ifconfig scan' with several drivers.
ok mpi@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.42 2016/08/15 22:14:19 stsp Exp $	*/
d757 1
a757 1
		ni = RB_MIN(ieee80211_tree, &ic->ic_tree);
d767 1
a767 1
			ni = RB_NEXT(ieee80211_tree, &ic->ic_tree, ni);
@


1.42
log
@Expose more 802.11n information to userspace:
A flag which indicates whether HT has been negotiated with a node,
and the current Tx MCS value we use for a node.

This grows struct ieee80211_nodereq. Applications using it must be recompiled.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.41 2016/04/28 13:50:14 stsp Exp $	*/
d63 2
d78 13
a90 1
	nr->nr_rssi = (*ic->ic_node_getrssi)(ic, ni);
@


1.41
log
@Copy some ieee8021_node HT information to userspace.
ifconfig needs to be recompiled.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.40 2016/01/04 12:28:46 stsp Exp $	*/
d115 3
@


1.40
log
@Fix manual scan while associated in 11a mode. It would only show APs on 5GHz.
Problem found by benno@@
ok benno@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.39 2015/03/14 03:38:51 jsg Exp $	*/
d109 6
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.38 2014/12/23 03:24:08 tedu Exp $	*/
d650 13
@


1.38
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.37 2014/09/14 14:17:26 jsg Exp $	*/
a44 1
#include <net/if_arp.h>
@


1.37
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.36 2014/09/12 16:02:40 sthen Exp $	*/
a47 1
#ifdef INET
a49 1
#endif
@


1.36
log
@Remove cached 802.11 nodes in IEEE80211_STA_CACHE state (these are nodes
which have been seen but which haven't otherwise interacted with us), fixing
a problem where old cached nodes are seen when doing a scan.
From Marcin Piotr Pawlowski, feedback stsp@@ ok kspillner@@ dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.35 2014/07/10 14:32:28 stsp Exp $	*/
a41 1
#include <sys/proc.h>
@


1.35
log
@Return RSN (WPA) information to userland during wireless scan, and
make ifconfig show whether a wireless network uses WEP or WPA.
Since struct ieee80211_nodereq grows in size old ifconfig won't be
able to scan when running on a new kernel.
While here, add missing ioctl constant IEEE80211_WPA_CIPHER_BIP.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.34 2010/09/29 20:00:51 kettenis Exp $	*/
d652 2
a653 1
			if (ic->ic_state != IEEE80211_S_SCAN)
d655 1
@


1.34
log
@In the implementation of the SIOCS80211DELNODE ioctl, call
ieee80211_node_leave() instead of ieee80211_release_node() which screws
up reference counting and leads to use after free problems elsewhere in the
code.  Since ieee80211_node_leave() is only available if hostap support is
compiled in, don't privide the SIOCS80211DELNODE ioctl if we're compiling
without hostap support (e.g. on ramdisks).

ok deraadt@@, damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.33 2009/09/12 19:37:27 miod Exp $	*/
d94 12
a105 1
	/* XXX RSN */
@


1.33
log
@Correctly report copyout() failure in SIOCG80211STATS ioctl; ok damien@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.32 2009/06/06 07:57:27 damien Exp $	*/
d679 1
d705 1
a705 1
			ieee80211_release_node(ic, ni);
d708 1
@


1.32
log
@In SIOCS80211SCAN, fail if the interface is not up *and* running.
There are cases where the interface can be up but not running, for
instance if the driver's if_init routine fails halfway for whatever
reason (firmware file not found, hardware switch turned off etc...)
This is because in sys/net/if.c, the returned code of the driver
is ignored for SIOCSIFFLAGS and the IFF_UP flags is left set.
netintro(4) does not say anything about values returned by
SIOCSIFFLAGS, so I don't know whether it is the expected behavior
or not.

pointed out by halex@@ and jacekm@@ who noticed it was possible to
trigger a scan on wpi(4) even when the hardware switch was turned off.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.31 2009/02/15 08:34:36 damien Exp $	*/
d587 2
a588 1
		copyout(&ic->ic_stats, ifr->ifr_data, sizeof (ic->ic_stats));
@


1.31
log
@make "ifconfig if0 chan" list the channels supported by the device.
add "ifconfig if0 scan" to scan for access points or to list known
stations in Host AP mode.
remove the [-]wmm command while i'm here.  QoS is mandatory with
802.11n so there's not much point into making it an option.
fix parsing of the "powersave" command too.

discussed with deraadt@@
man page hints from jmc@@
display hints from sobrado@@
"i like it" cnst@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.30 2009/02/13 17:24:54 damien Exp $	*/
d631 2
a632 1
		if ((ifp->if_flags & IFF_UP) == 0) {
@


1.30
log
@Change ifconfig wpaakms default setting to `psk' instead of `psk,802.1x'.
Some supplicants will autoselect 802.1X without giving users the
possibility to choose between PSK or 802.1X.

Similarly, no longer announce `PSK with SHA-256 based KDF' AKMP (defined
in Draft 802.11w) by default in the RSN IE of beacons and probe responses
as it confuses some broken supplicants.  This kind of sacrifies security
for interoperability with shitty (but unfortunately widespread) clients
that do not follow the 802.11 standard properly.
This fixes associations from Intel PROSet on XP and also reportedly fixes
some Mac OS clients.  I will likely make `psk-sha256' configurable through
ifconfig wpaakms after the 4.5 release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.29 2009/01/26 19:09:41 damien Exp $	*/
d576 5
@


1.29
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.28 2008/12/14 11:59:41 jsg Exp $	*/
d240 9
a248 9
		ic->ic_rsnakms |=
		    IEEE80211_AKM_PSK | IEEE80211_AKM_SHA256_PSK;
	if (wpa->i_akms & IEEE80211_WPA_AKM_IEEE8021X)
		ic->ic_rsnakms |=
		    IEEE80211_AKM_8021X | IEEE80211_AKM_SHA256_8021X;
	if (ic->ic_rsnakms == 0)	/* set to default (PSK+802.1X) */
		ic->ic_rsnakms =
		    IEEE80211_AKM_PSK | IEEE80211_AKM_8021X /*|
		    IEEE80211_AKM_SHA256_PSK | IEEE80211_AKM_SHA256_8021X*/;
d294 1
a294 2
	if (ic->ic_rsnakms &
	    (IEEE80211_AKM_PSK | IEEE80211_AKM_SHA256_PSK))
d296 6
a301 3
	if (ic->ic_rsnakms &
	    (IEEE80211_AKM_8021X | IEEE80211_AKM_SHA256_8021X))
		wpa->i_akms |= IEEE80211_WPA_AKM_IEEE8021X;
@


1.28
log
@txpower range checks should be inclusive.
From FreeBSD via mickey in pr 6024.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.27 2008/12/03 17:24:45 damien Exp $	*/
d167 1
a167 1
		k->k_len = nwkey->i_key[i].i_keylen;
d169 1
a169 2
		error = copyin(nwkey->i_key[i].i_keydat, k->k_key,
		    nwkey->i_key[i].i_keylen);
d247 2
a248 2
		    IEEE80211_AKM_PSK | IEEE80211_AKM_8021X |
		    IEEE80211_AKM_SHA256_PSK | IEEE80211_AKM_SHA256_8021X;
a446 2
		    ka->i_macaddr, ka->i_key, ka->i_lifetime);
		(void)ieee80211_pmksa_add(ic, IEEE80211_AKM_SHA256_8021X,
@


1.27
log
@small fix for IEEE80211_STA_ONLY: do not let users set HostAP specific
flags using "nwflag".
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.26 2008/10/02 20:21:15 brad Exp $	*/
d597 2
a598 2
		if (!(IEEE80211_TXPOWER_MIN < txpower->i_val &&
			txpower->i_val < IEEE80211_TXPOWER_MAX)) {
@


1.26
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.25 2008/09/27 15:16:09 damien Exp $	*/
d729 1
d731 2
a732 1
		if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
a736 1
#endif
@


1.25
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.24 2008/08/29 12:14:53 damien Exp $	*/
a348 4
	case SIOCSIFADDR:
	case SIOCGIFADDR:
		error = ether_ioctl(ifp, &ic->ic_ac, cmd, data);
		break;
d740 1
a740 2
		error = ENOTTY;
		break;
d742 1
@


1.24
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.23 2008/08/27 09:05:04 damien Exp $	*/
d55 1
d241 2
a242 1
		ic->ic_rsnakms |= IEEE80211_AKM_PSK;
d244 2
a245 1
		ic->ic_rsnakms |= IEEE80211_AKM_8021X;
d247 3
a249 1
		ic->ic_rsnakms = IEEE80211_AKM_PSK | IEEE80211_AKM_8021X;
d295 2
a296 1
	if (ic->ic_rsnakms & IEEE80211_AKM_PSK)
d298 2
a299 1
	if (ic->ic_rsnakms & IEEE80211_AKM_8021X)
d333 2
d446 15
@


1.23
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.22 2008/08/12 19:29:07 damien Exp $	*/
a83 2
	nr->nr_fhdwell = ni->ni_fhdwell;
	nr->nr_fhindex = ni->ni_fhindex;
a119 2
	ni->ni_fhdwell = nr->nr_fhdwell;
	ni->ni_fhindex = nr->nr_fhindex;
@


1.22
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.21 2008/04/16 18:32:15 damien Exp $	*/
d476 1
d479 1
d498 1
d502 3
a504 1
			else if (ic->ic_flags & IEEE80211_F_DESBSSID)
d607 1
d610 1
d638 1
d643 1
d703 1
d705 1
d713 1
d719 1
@


1.21
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.20 2007/11/25 16:47:44 brad Exp $	*/
d246 1
a246 1
		ic->ic_rsnakms |= IEEE80211_AKM_IEEE8021X;
d248 1
a248 1
		ic->ic_rsnakms = IEEE80211_AKM_PSK | IEEE80211_AKM_IEEE8021X;
d296 1
a296 1
	if (ic->ic_rsnakms & IEEE80211_AKM_IEEE8021X)
@


1.20
log
@return ENOTTY not EINVAL for an unknown ioctl.

ok reyk@@ deraadt@@ jsg@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.19 2007/07/18 18:10:31 damien Exp $	*/
d95 1
d135 186
d328 2
a329 1
	struct ieee80211_nwkey *nwkey;
a334 1
	struct ieee80211_key keys[IEEE80211_WEP_NKID];
d384 10
a393 4
		nwkey = (struct ieee80211_nwkey *)data;
		if ((ic->ic_caps & IEEE80211_C_WEP) == 0 &&
		    nwkey->i_wepon != IEEE80211_NWKEY_OPEN) {
			error = EINVAL;
d396 21
a416 19
		/* check and copy keys */
		memset(keys, 0, sizeof(keys));
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			keys[i].k_len = nwkey->i_key[i].i_keylen;
			/*
			 * Limit the maximal allowed key size to 
			 * IEEE80211_KEYBUF_SIZE bytes.
			 */
			if (keys[i].k_len > sizeof(keys[i].k_key)) {
				error = EINVAL;
				break;
			}
			if (keys[i].k_len <= 0)
				continue;
			if ((error = copyin(nwkey->i_key[i].i_keydat,
			    keys[i].k_key, keys[i].k_len)) != 0)
				break;
		}
		if (error)
d418 7
a424 27
		i = nwkey->i_defkid - 1;
		if (i < 0 || i >= IEEE80211_WEP_NKID ||
		    keys[i].k_len == 0 ||
		    (keys[i].k_len == -1 && ic->ic_nw_keys[i].k_len == 0)) {
			if (nwkey->i_wepon != IEEE80211_NWKEY_OPEN) {
				error = EINVAL;
				break;
			}
		} else
			ic->ic_wep_txkey = i;
		/* save the key */
		if (nwkey->i_wepon == IEEE80211_NWKEY_OPEN)
			ic->ic_flags &= ~IEEE80211_F_WEPON;
		else
			ic->ic_flags |= IEEE80211_F_WEPON;
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			struct ieee80211_key *k = &ic->ic_nw_keys[i];
			if (keys[i].k_len < 0)
				continue;
			if (keys[i].k_len == 0)
				k->k_cipher = IEEE80211_CIPHER_NONE;
			else if (keys[i].k_len <= 5)
				k->k_cipher = IEEE80211_CIPHER_WEP40;
			else
				k->k_cipher = IEEE80211_CIPHER_WEP104;
			k->k_len = keys[i].k_len;
			memcpy(k->k_key, keys[i].k_key, sizeof(keys[i].k_key));
d428 4
a431 10
	case SIOCG80211NWKEY:
		nwkey = (struct ieee80211_nwkey *)data;
		if (ic->ic_flags & IEEE80211_F_WEPON)
			nwkey->i_wepon = IEEE80211_NWKEY_WEP;
		else
			nwkey->i_wepon = IEEE80211_NWKEY_OPEN;
		nwkey->i_defkid = ic->ic_wep_txkey + 1;
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			if (nwkey->i_key[i].i_keydat == NULL)
				continue;
d433 8
a440 8
			if ((error = suser(curproc, 0)) != 0)
				break;
			nwkey->i_key[i].i_keylen = ic->ic_nw_keys[i].k_len;
			if ((error = copyout(ic->ic_nw_keys[i].k_key,
			    nwkey->i_key[i].i_keydat,
			    ic->ic_nw_keys[i].k_len)) != 0)
				break;
		}
@


1.19
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.18 2007/06/16 13:17:05 damien Exp $	*/
d542 1
a542 1
		error = EINVAL;
@


1.18
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.17 2007/06/06 19:31:07 damien Exp $	*/
d147 1
a147 1
	struct ieee80211_wepkey keys[IEEE80211_WEP_NKID];
d206 1
a206 1
			keys[i].wk_len = nwkey->i_key[i].i_keylen;
d211 1
a211 1
			if (keys[i].wk_len > sizeof(keys[i].wk_key)) {
d215 1
a215 1
			if (keys[i].wk_len <= 0)
d218 1
a218 1
			    keys[i].wk_key, keys[i].wk_len)) != 0)
d225 2
a226 2
		    keys[i].wk_len == 0 ||
		    (keys[i].wk_len == -1 && ic->ic_nw_keys[i].wk_len == 0)) {
d239 2
a240 1
			if (keys[i].wk_len < 0)
d242 8
a249 3
			ic->ic_nw_keys[i].wk_len = keys[i].wk_len;
			memcpy(ic->ic_nw_keys[i].wk_key, keys[i].wk_key,
			    sizeof(keys[i].wk_key));
d266 2
a267 2
			nwkey->i_key[i].i_keylen = ic->ic_nw_keys[i].wk_len;
			if ((error = copyout(ic->ic_nw_keys[i].wk_key,
d269 1
a269 1
			    ic->ic_nw_keys[i].wk_len)) != 0)
@


1.17
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.16 2006/12/29 15:45:56 reyk Exp $	*/
d57 4
a60 4
void	 ieee80211_node2req(struct ieee80211com *, struct ieee80211_node *,
	    struct ieee80211_nodereq *);
void	 ieee80211_req2node(struct ieee80211com *, struct ieee80211_nodereq *,
	    struct ieee80211_node *);
d63 1
a63 1
ieee80211_node2req(struct ieee80211com *ic, struct ieee80211_node *ni,
d105 1
a105 1
ieee80211_req2node(struct ieee80211com *ic, struct ieee80211_nodereq *nr,
@


1.16
log
@fix the key buffer size used for software wep, this could cause
problems with non-standard wep keys >= 104 bits.

thanks to Alexander Bluhm

ok mglocker@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.15 2006/06/27 20:55:51 reyk Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.15
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.14 2006/06/23 21:34:15 reyk Exp $	*/
d211 4
@


1.14
log
@add an optional max_rssi attribute to the ieee80211com structure and
allow to export the RSSI Max value with ioctls and by radiotap
headers.

ok damien@@ jsg@@

description:

we currently use "dB" as an indication for the signal strength in
ifconfig and in the radiotap headers. it means "decibel difference
from an arbitrary, fixed reference". this is quite confusing, because
different chipsets have different references for the dB/rssi values.

we can use the plain RSSI which is described in IEEE 802.11: "The
receive signal strength indicator (RSSI) is an optional parameter that
has a value of 0 through RSSI Max.". all wireless chipsets have
something like a RSSI (normally as a Rx descriptor field), but the
value for RSSI Max is chipset-specific.

if we know the RSSI Max, we can calculate a percentage which is much
easier to understand for the user. we even don't have to use the
absolute RSSI Max, we can use an average RSSI Max, figured out by
monitoring and tuning the RSSI Max of the drivers. if the user gets a
signal of 110%, it would mean "better than the average Max signal".

there's no need to do any RSSI calculations in the kernel, it just
passes the the relative rssi and max_rssi values to userspace. this is
done in the ieee80211_nodereq ioctl structure and possible with a new
radiotap header. the radiotap RSSI header allows to get a flexible but
common signal indicator instead of the complex and unrelated dB/dBm
signal fields. it must include two 8bit values current rssi and RSSI
max.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.13 2005/09/13 12:11:03 reyk Exp $	*/
d158 1
d516 18
@


1.13
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.12 2005/05/25 07:40:49 reyk Exp $	*/
d84 1
@


1.12
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.11 2005/04/03 08:06:14 uwe Exp $	*/
d47 1
d502 1
a502 1
		ni = TAILQ_FIRST(&ic->ic_node);
d512 1
a512 1
			ni = TAILQ_NEXT(ni, ni_list);
@


1.11
log
@remove redundant suser() checks
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.10 2005/04/02 22:00:49 uwe Exp $	*/
a35 7
#include <sys/cdefs.h>
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_ioctl.c,v 1.13 2004/03/30 22:57:57 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_ioctl.c,v 1.15 2004/05/06 02:58:16 dyoung Exp $");
#endif

a39 4
#ifdef __NetBSD__
#include "opt_inet.h"
#endif

a50 3
#if defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a53 1
#if defined(__OpenBSD__)
a55 4
#ifndef __OpenBSD__
#include <netinet/if_inarp.h>
#endif
#endif
d60 4
a63 6
#if defined(__OpenBSD__)
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wi_hostap.h>
#else
#include <dev/ic/wi_ieee.h>
#endif
d65 3
a67 13
#if defined(__OpenBSD__)
void	 node2sta(struct ieee80211com *, struct ieee80211_node *,
	    struct hostap_sta *);
#endif

/*
 * XXX
 * Wireless LAN specific configuration interface, which is compatible
 * with wicontrol(8).
 */

int
ieee80211_cfgget(struct ifnet *ifp, u_long cmd, caddr_t data)
d69 35
a103 317
	struct ieee80211com *ic = (void *)ifp;
	int i, j, error;
	struct ifreq *ifr = (struct ifreq *)data;
	struct wi_req wreq;
	struct wi_ltv_keys *keys;
	struct wi_apinfo *ap;
	struct ieee80211_node *ni;
	struct ieee80211_rateset *rs;
#ifdef WICACHE
	struct wi_sigcache wsc;
#endif /* WICACHE */
	struct wi_scan_p2_hdr *p2;
	struct wi_scan_res *res;

	error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
	if (error)
		return error;
	wreq.wi_len = 0;
	switch (wreq.wi_type) {
	case WI_RID_SERIALNO:
	case WI_RID_STA_IDENTITY:
	case WI_RID_CARD_ID:
	case WI_RID_PROCFRAME:
	case WI_RID_SYMBOL_DIVERSITY:
	case WI_RID_ENH_SECURITY:
	case WI_RID_AUTH_STATION:
		/* nothing appropriate */
		break;
	case WI_RID_NODENAME:
		strlcpy((char *)&wreq.wi_val[1], hostname,
		    sizeof(wreq.wi_val) - sizeof(wreq.wi_val[0]));
		wreq.wi_val[0] = htole16(strlen(hostname));
		wreq.wi_len = (1 + strlen(hostname) + 1) / 2;
		break;
	case WI_RID_CURRENT_SSID:
		if (ic->ic_state != IEEE80211_S_RUN) {
			wreq.wi_val[0] = 0;
			wreq.wi_len = 1;
			break;
		}
		wreq.wi_val[0] = htole16(ic->ic_bss->ni_esslen);
		memcpy(&wreq.wi_val[1], ic->ic_bss->ni_essid,
		    ic->ic_bss->ni_esslen);
		wreq.wi_len = (1 + ic->ic_bss->ni_esslen + 1) / 2;
		break;
	case WI_RID_OWN_SSID:
	case WI_RID_DESIRED_SSID:
		wreq.wi_val[0] = htole16(ic->ic_des_esslen);
		memcpy(&wreq.wi_val[1], ic->ic_des_essid, ic->ic_des_esslen);
		wreq.wi_len = (1 + ic->ic_des_esslen + 1) / 2;
		break;
	case WI_RID_CURRENT_BSSID:
		if (ic->ic_state == IEEE80211_S_RUN)
			IEEE80211_ADDR_COPY(wreq.wi_val, ic->ic_bss->ni_bssid);
		else
			memset(wreq.wi_val, 0, IEEE80211_ADDR_LEN);
		wreq.wi_len = IEEE80211_ADDR_LEN / 2;
		break;
	case WI_RID_CHANNEL_LIST:
		memset(wreq.wi_val, 0, sizeof(wreq.wi_val));
		/*
		 * Since channel 0 is not available for DS, channel 1
		 * is assigned to LSB on WaveLAN.
		 */
		if (ic->ic_phytype == IEEE80211_T_DS)
			i = 1;
		else
			i = 0;
		for (j = 0; i <= IEEE80211_CHAN_MAX; i++, j++)
			if (isset(ic->ic_chan_active, i)) {
				setbit((u_int8_t *)wreq.wi_val, j);
				wreq.wi_len = j / 16 + 1;
			}
		break;
	case WI_RID_OWN_CHNL:
		wreq.wi_val[0] = htole16(
			ieee80211_chan2ieee(ic, ic->ic_ibss_chan));
		wreq.wi_len = 1;
		break;
	case WI_RID_CURRENT_CHAN:
		wreq.wi_val[0] = htole16(
			ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan));
		wreq.wi_len = 1;
		break;
	case WI_RID_COMMS_QUALITY:
		wreq.wi_val[0] = 0;				/* quality */
		wreq.wi_val[1] =
			htole16((*ic->ic_node_getrssi)(ic, ic->ic_bss));
		wreq.wi_val[2] = 0;				/* noise */
		wreq.wi_len = 3;
		break;
	case WI_RID_PROMISC:
		wreq.wi_val[0] = htole16((ifp->if_flags & IFF_PROMISC) ? 1 : 0);
		wreq.wi_len = 1;
		break;
	case WI_RID_PORTTYPE:
		wreq.wi_val[0] = htole16(ic->ic_opmode);
		wreq.wi_len = 1;
		break;
	case WI_RID_MAC_NODE:
		IEEE80211_ADDR_COPY(wreq.wi_val, ic->ic_myaddr);
		wreq.wi_len = IEEE80211_ADDR_LEN / 2;
		break;
	case WI_RID_TX_RATE:
		if (ic->ic_fixed_rate == -1)
			wreq.wi_val[0] = 0;	/* auto */
		else
			wreq.wi_val[0] = htole16(
			    (ic->ic_sup_rates[ic->ic_curmode].rs_rates[ic->ic_fixed_rate] &
			    IEEE80211_RATE_VAL) / 2);
		wreq.wi_len = 1;
		break;
	case WI_RID_CUR_TX_RATE:
		wreq.wi_val[0] = htole16(
		    (ic->ic_bss->ni_rates.rs_rates[ic->ic_bss->ni_txrate] &
		    IEEE80211_RATE_VAL) / 2);
		wreq.wi_len = 1;
		break;
	case WI_RID_FRAG_THRESH:
		wreq.wi_val[0] = htole16(ic->ic_fragthreshold);
		wreq.wi_len = 1;
		break;
	case WI_RID_RTS_THRESH:
		wreq.wi_val[0] = htole16(ic->ic_rtsthreshold);
		wreq.wi_len = 1;
		break;
	case WI_RID_CREATE_IBSS:
		wreq.wi_val[0] =
		    htole16((ic->ic_flags & IEEE80211_F_IBSSON) ? 1 : 0);
		wreq.wi_len = 1;
		break;
	case WI_RID_MICROWAVE_OVEN:
		wreq.wi_val[0] = 0;	/* no ... not supported */
		wreq.wi_len = 1;
		break;
	case WI_RID_ROAMING_MODE:
		wreq.wi_val[0] = htole16(1);	/* enabled ... not supported */
		wreq.wi_len = 1;
		break;
	case WI_RID_SYSTEM_SCALE:
		wreq.wi_val[0] = htole16(1);	/* low density ... not supp */
		wreq.wi_len = 1;
		break;
	case WI_RID_PM_ENABLED:
		wreq.wi_val[0] =
		    htole16((ic->ic_flags & IEEE80211_F_PMGTON) ? 1 : 0);
		wreq.wi_len = 1;
		break;
	case WI_RID_MAX_SLEEP:
		wreq.wi_val[0] = htole16(ic->ic_lintval);
		wreq.wi_len = 1;
		break;
	case WI_RID_CUR_BEACON_INT:
		wreq.wi_val[0] = htole16(ic->ic_bss->ni_intval);
		wreq.wi_len = 1;
		break;
	case WI_RID_WEP_AVAIL:
		wreq.wi_val[0] =
		    htole16((ic->ic_caps & IEEE80211_C_WEP) ? 1 : 0);
		wreq.wi_len = 1;
		break;
	case WI_RID_CNFAUTHMODE:
		wreq.wi_val[0] = htole16(1);	/* TODO: open system only */
		wreq.wi_len = 1;
		break;
	case WI_RID_ENCRYPTION:
		wreq.wi_val[0] =
		    htole16((ic->ic_flags & IEEE80211_F_WEPON) ? 1 : 0);
		wreq.wi_len = 1;
		break;
	case WI_RID_TX_CRYPT_KEY:
		wreq.wi_val[0] = htole16(ic->ic_wep_txkey);
		wreq.wi_len = 1;
		break;
	case WI_RID_DEFLT_CRYPT_KEYS:
		keys = (struct wi_ltv_keys *)&wreq;
		memset(keys, 0, sizeof(*keys));
		/* do not show keys to non-root user */
		error = suser(curproc, 0);
		if (error) {
			error = 0;
			break;
		}
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			keys->wi_keys[i].wi_keylen =
			    htole16(ic->ic_nw_keys[i].wk_len);
			memcpy(keys->wi_keys[i].wi_keydat,
			    ic->ic_nw_keys[i].wk_key, ic->ic_nw_keys[i].wk_len);
		}
		wreq.wi_len = sizeof(*keys) / 2;
		break;
	case WI_RID_MAX_DATALEN:
		wreq.wi_val[0] = htole16(IEEE80211_MAX_LEN);	/* TODO: frag */
		wreq.wi_len = 1;
		break;
	case WI_RID_DBM_ADJUST:
		/* not supported, we just pass rssi value from driver. */
		break;
	case WI_RID_IFACE_STATS:
		/* XXX: should be implemented in lower drivers */
		break;
	case WI_RID_READ_APS:
		if (ic->ic_opmode != IEEE80211_M_HOSTAP) {
			/*
			 * Don't return results until active scan completes.
			 */
			if (ic->ic_state == IEEE80211_S_SCAN &&
			    (ic->ic_flags & IEEE80211_F_ASCAN)) {
				error = EINPROGRESS;
				break;
			}
		}
		i = 0;
		ap = (void *)((char *)wreq.wi_val + sizeof(i));
		TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
			if ((caddr_t)(ap + 1) > (caddr_t)(&wreq + 1))
				break;
			memset(ap, 0, sizeof(*ap));
			if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
				IEEE80211_ADDR_COPY(ap->bssid, ni->ni_macaddr);
				ap->namelen = ic->ic_des_esslen;
				if (ic->ic_des_esslen)
					memcpy(ap->name, ic->ic_des_essid,
					    ic->ic_des_esslen);
			} else {
				IEEE80211_ADDR_COPY(ap->bssid, ni->ni_bssid);
				ap->namelen = ni->ni_esslen;
				if (ni->ni_esslen)
					memcpy(ap->name, ni->ni_essid,
					    ni->ni_esslen);
			}
			ap->channel = ieee80211_chan2ieee(ic, ni->ni_chan);
			ap->signal = (*ic->ic_node_getrssi)(ic, ni);
			ap->capinfo = ni->ni_capinfo;
			ap->interval = ni->ni_intval;
			rs = &ni->ni_rates;
			for (j = 0; j < rs->rs_nrates; j++) {
				if (rs->rs_rates[j] & IEEE80211_RATE_BASIC) {
					ap->rate = (rs->rs_rates[j] &
					    IEEE80211_RATE_VAL) * 5; /* XXX */
				}
			}
			i++;
			ap++;
		}
		memcpy(wreq.wi_val, &i, sizeof(i));
		wreq.wi_len = (sizeof(int) + sizeof(*ap) * i) / 2;
		break;
	case WI_RID_PRISM2:
		wreq.wi_val[0] = 1;	/* XXX lie so SCAN_RES can give rates */
		wreq.wi_len = sizeof(u_int16_t) / 2;
		break;
	case WI_RID_SCAN_RES:			/* compatibility interface */
		if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
		    ic->ic_state == IEEE80211_S_SCAN &&
		    (ic->ic_flags & IEEE80211_F_ASCAN)) {
			error = EINPROGRESS;
			break;
		}
		/* NB: we use the Prism2 format so we can return rate info */
		p2 = (struct wi_scan_p2_hdr *)wreq.wi_val;
		res = (void *)&p2[1];
		i = 0;
		TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
			if ((caddr_t)(res + 1) > (caddr_t)(&wreq + 1))
				break;
			res->wi_chan = ieee80211_chan2ieee(ic, ni->ni_chan);
			res->wi_noise = 0;
			res->wi_signal = (*ic->ic_node_getrssi)(ic, ni);
			IEEE80211_ADDR_COPY(res->wi_bssid, ni->ni_bssid);
			res->wi_interval = ni->ni_intval;
			res->wi_capinfo = ni->ni_capinfo;
			res->wi_ssid_len = ni->ni_esslen;
			memcpy(res->wi_ssid, ni->ni_essid, IEEE80211_NWID_LEN);
			/* NB: assumes wi_srates holds <= ni->ni_rates */
			memcpy(res->wi_srates, ni->ni_rates.rs_rates,
				sizeof(res->wi_srates));
			if (ni->ni_rates.rs_nrates < 10)
				res->wi_srates[ni->ni_rates.rs_nrates] = 0;
			res->wi_rate = ni->ni_rates.rs_rates[ni->ni_txrate];
			res->wi_rsvd = 0;
			res++, i++;
		}
		p2->wi_rsvd = 0;
		p2->wi_reason = i;
		wreq.wi_len = (sizeof(*p2) + sizeof(*res) * i) / 2;
		break;
#ifdef WICACHE
	case WI_RID_READ_CACHE:
		i = 0;
		TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
			if (i == (WI_MAX_DATALEN/sizeof(struct wi_sigcache))-1)
				break;
			IEEE80211_ADDR_COPY(wsc.macsrc, ni->ni_macaddr);
			memset(&wsc.ipsrc, 0, sizeof(wsc.ipsrc));
			wsc.signal = (*ic->ic_node_getrssi)(ic, ni);
			wsc.noise = 0;
			wsc.quality = 0;
			memcpy((caddr_t)wreq.wi_val + sizeof(wsc) * i,
			    &wsc, sizeof(wsc));
			i++;
		}
		wreq.wi_len = sizeof(wsc) * i / 2;
		break;
#endif /* WICACHE */
	case WI_RID_SCAN_APS:
		error = EINVAL;
		break;
	default:
		error = EINVAL;
		break;
	}
	if (error == 0) {
		wreq.wi_len++;
		error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
	}
	return error;
d106 3
a108 21
static int
findrate(struct ieee80211com *ic, enum ieee80211_phymode mode, int rate)
{
#define	IEEERATE(_ic,_m,_i) \
	((_ic)->ic_sup_rates[_m].rs_rates[_i] & IEEE80211_RATE_VAL)
	int i, nrates = ic->ic_sup_rates[mode].rs_nrates;
	for (i = 0; i < nrates; i++)
		if (IEEERATE(ic, mode, i) == rate)
			return i;
	return -1;
#undef IEEERATE
}

/*
 * Prepare to do a user-initiated scan for AP's.  If no
 * current/default channel is setup or the current channel
 * is invalid then pick the first available channel from
 * the active list as the place to start the scan.
 */
static int
ieee80211_setupscan(struct ieee80211com *ic)
d110 24
a133 361
	u_char *chanlist = ic->ic_chan_active;
	int i;

	if (ic->ic_ibss_chan == NULL ||
	    isclr(chanlist, ieee80211_chan2ieee(ic, ic->ic_ibss_chan))) {
		for (i = 0; i <= IEEE80211_CHAN_MAX; i++)
			if (isset(chanlist, i)) {
				ic->ic_ibss_chan = &ic->ic_channels[i];
				goto found;
			}
		return EINVAL;			/* no active channels */
found:
		;
	}
	if (ic->ic_bss->ni_chan == IEEE80211_CHAN_ANYC ||
	    isclr(chanlist, ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan)))
		ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	/*
	 * XXX don't permit a scan to be started unless we
	 * know the device is ready.  For the moment this means
	 * the device is marked up as this is the required to
	 * initialize the hardware.  It would be better to permit
	 * scanning prior to being up but that'll require some
	 * changes to the infrastructure.
	 */
	return (ic->ic_if.if_flags & IFF_UP) ? 0 : ENETRESET;
}

int
ieee80211_cfgset(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ieee80211com *ic = (void *)ifp;
	int i, j, len, error, rate;
	struct ifreq *ifr = (struct ifreq *)data;
	struct wi_ltv_keys *keys;
	struct wi_req wreq;
	u_char chanlist[roundup(IEEE80211_CHAN_MAX, NBBY)];

	error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
	if (error)
		return error;
	len = wreq.wi_len ? (wreq.wi_len - 1) * 2 : 0;
	switch (wreq.wi_type) {
	case WI_RID_SERIALNO:
	case WI_RID_NODENAME:
		return EPERM;
	case WI_RID_CURRENT_SSID:
		return EPERM;
	case WI_RID_OWN_SSID:
	case WI_RID_DESIRED_SSID:
		if (letoh16(wreq.wi_val[0]) * 2 > len ||
		    letoh16(wreq.wi_val[0]) > IEEE80211_NWID_LEN) {
			error = ENOSPC;
			break;
		}
		memset(ic->ic_des_essid, 0, sizeof(ic->ic_des_essid));
		ic->ic_des_esslen = letoh16(wreq.wi_val[0]) * 2;
		memcpy(ic->ic_des_essid, &wreq.wi_val[1], ic->ic_des_esslen);
		error = ENETRESET;
		break;
	case WI_RID_CURRENT_BSSID:
		return EPERM;
	case WI_RID_OWN_CHNL:
		if (len != 2)
			return EINVAL;
		i = letoh16(wreq.wi_val[0]);
		if (i < 0 ||
		    i > IEEE80211_CHAN_MAX ||
		    isclr(ic->ic_chan_active, i))
			return EINVAL;
		ic->ic_ibss_chan = &ic->ic_channels[i];
		if (ic->ic_flags & IEEE80211_F_SIBSS)
			error = ENETRESET;
		break;
	case WI_RID_CURRENT_CHAN:
		return EPERM;
	case WI_RID_COMMS_QUALITY:
		return EPERM;
	case WI_RID_PROMISC:
		if (len != 2)
			return EINVAL;
		if (ifp->if_flags & IFF_PROMISC) {
			if (wreq.wi_val[0] == 0) {
				ifp->if_flags &= ~IFF_PROMISC;
				error = ENETRESET;
			}
		} else {
			if (wreq.wi_val[0] != 0) {
				ifp->if_flags |= IFF_PROMISC;
				error = ENETRESET;
			}
		}
		break;
	case WI_RID_PORTTYPE:
		if (len != 2)
			return EINVAL;
		switch (letoh16(wreq.wi_val[0])) {
		case IEEE80211_M_STA:
			break;
		case IEEE80211_M_IBSS:
			if (!(ic->ic_caps & IEEE80211_C_IBSS))
				return EINVAL;
			break;
		case IEEE80211_M_AHDEMO:
			if (ic->ic_phytype != IEEE80211_T_DS ||
			    !(ic->ic_caps & IEEE80211_C_AHDEMO))
				return EINVAL;
			break;
		case IEEE80211_M_HOSTAP:
			if (!(ic->ic_caps & IEEE80211_C_HOSTAP))
				return EINVAL;
			break;
		default:
			return EINVAL;
		}
		if (letoh16(wreq.wi_val[0]) != ic->ic_opmode) {
			ic->ic_opmode = letoh16(wreq.wi_val[0]);
			error = ENETRESET;
		}
		break;
#if 0
	case WI_RID_MAC_NODE:
		if (len != IEEE80211_ADDR_LEN)
			return EINVAL;
		IEEE80211_ADDR_COPY(LLADDR(ifp->if_sadl), wreq.wi_val);
		/* if_init will copy lladdr into ic_myaddr */
		error = ENETRESET;
		break;
#endif
	case WI_RID_TX_RATE:
		if (len != 2)
			return EINVAL;
		if (wreq.wi_val[0] == 0) {
			/* auto */
			ic->ic_fixed_rate = -1;
			break;
		}
		rate = 2 * letoh16(wreq.wi_val[0]);
		if (ic->ic_curmode == IEEE80211_MODE_AUTO) {
			/*
			 * In autoselect mode search for the rate.  We take
			 * the first instance which may not be right, but we
			 * are limited by the interface.  Note that we also
			 * lock the mode to insure the rate is meaningful
			 * when it is used.
			 */
			for (j = IEEE80211_MODE_11A;
			     j < IEEE80211_MODE_MAX; j++) {
				if ((ic->ic_modecaps & (1<<j)) == 0)
					continue;
				i = findrate(ic, j, rate);
				if (i != -1) {
					/* lock mode too */
					ic->ic_curmode = j;
					goto setrate;
				}
			}
		} else {
			i = findrate(ic, ic->ic_curmode, rate);
			if (i != -1)
				goto setrate;
		}
		return EINVAL;
	setrate:
		ic->ic_fixed_rate = i;
		error = ENETRESET;
		break;
	case WI_RID_CUR_TX_RATE:
		return EPERM;
	case WI_RID_FRAG_THRESH:
		if (len != 2)
			return EINVAL;
		ic->ic_fragthreshold = letoh16(wreq.wi_val[0]);
		error = ENETRESET;
		break;
	case WI_RID_RTS_THRESH:
		if (len != 2)
			return EINVAL;
		ic->ic_rtsthreshold = letoh16(wreq.wi_val[0]);
		error = ENETRESET;
		break;
	case WI_RID_CREATE_IBSS:
		if (len != 2)
			return EINVAL;
		if (wreq.wi_val[0] != 0) {
			if ((ic->ic_caps & IEEE80211_C_IBSS) == 0)
				return EINVAL;
			if ((ic->ic_flags & IEEE80211_F_IBSSON) == 0) {
				ic->ic_flags |= IEEE80211_F_IBSSON;
				if (ic->ic_opmode == IEEE80211_M_IBSS &&
				    ic->ic_state == IEEE80211_S_SCAN)
					error = ENETRESET;
			}
		} else {
			if (ic->ic_flags & IEEE80211_F_IBSSON) {
				ic->ic_flags &= ~IEEE80211_F_IBSSON;
				if (ic->ic_flags & IEEE80211_F_SIBSS) {
					ic->ic_flags &= ~IEEE80211_F_SIBSS;
					error = ENETRESET;
				}
			}
		}
		break;
	case WI_RID_MICROWAVE_OVEN:
		if (len != 2)
			return EINVAL;
		if (wreq.wi_val[0] != 0)
			return EINVAL;		/* not supported */
		break;
	case WI_RID_ROAMING_MODE:
		if (len != 2)
			return EINVAL;
		if (letoh16(wreq.wi_val[0]) != 1)
			return EINVAL;		/* not supported */
		break;
	case WI_RID_SYSTEM_SCALE:
		if (len != 2)
			return EINVAL;
		if (letoh16(wreq.wi_val[0]) != 1)
			return EINVAL;		/* not supported */
		break;
	case WI_RID_PM_ENABLED:
		if (len != 2)
			return EINVAL;
		if (wreq.wi_val[0] != 0) {
			if ((ic->ic_caps & IEEE80211_C_PMGT) == 0)
				return EINVAL;
			if ((ic->ic_flags & IEEE80211_F_PMGTON) == 0) {
				ic->ic_flags |= IEEE80211_F_PMGTON;
				error = ENETRESET;
			}
		} else {
			if (ic->ic_flags & IEEE80211_F_PMGTON) {
				ic->ic_flags &= ~IEEE80211_F_PMGTON;
				error = ENETRESET;
			}
		}
		break;
	case WI_RID_MAX_SLEEP:
		if (len != 2)
			return EINVAL;
		ic->ic_lintval = letoh16(wreq.wi_val[0]);
		if (ic->ic_flags & IEEE80211_F_PMGTON)
			error = ENETRESET;
		break;
	case WI_RID_CUR_BEACON_INT:
		return EPERM;
	case WI_RID_WEP_AVAIL:
		return EPERM;
	case WI_RID_CNFAUTHMODE:
		if (len != 2)
			return EINVAL;
		if (letoh16(wreq.wi_val[0]) != 1)
			return EINVAL;		/* TODO: shared key auth */
		break;
	case WI_RID_ENCRYPTION:
		if (len != 2)
			return EINVAL;
		if (wreq.wi_val[0] != 0) {
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0)
				return EINVAL;
			if ((ic->ic_flags & IEEE80211_F_WEPON) == 0) {
				ic->ic_flags |= IEEE80211_F_WEPON;
				error = ENETRESET;
			}
		} else {
			if (ic->ic_flags & IEEE80211_F_WEPON) {
				ic->ic_flags &= ~IEEE80211_F_WEPON;
				error = ENETRESET;
			}
		}
		break;
	case WI_RID_TX_CRYPT_KEY:
		if (len != 2)
			return EINVAL;
		i = letoh16(wreq.wi_val[0]);
		if (i >= IEEE80211_WEP_NKID)
			return EINVAL;
		ic->ic_wep_txkey = i;
		break;
	case WI_RID_DEFLT_CRYPT_KEYS:
		if (len != sizeof(struct wi_ltv_keys))
			return EINVAL;
		keys = (struct wi_ltv_keys *)&wreq;
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			len = letoh16(keys->wi_keys[i].wi_keylen);
			if (len < 0 || len > sizeof(ic->ic_nw_keys[i].wk_key))
				return EINVAL;
		}
		memset(ic->ic_nw_keys, 0, sizeof(ic->ic_nw_keys));
		for (i = 0; i < IEEE80211_WEP_NKID; i++) {
			len = letoh16(keys->wi_keys[i].wi_keylen);
			ic->ic_nw_keys[i].wk_len = len;
			memcpy(ic->ic_nw_keys[i].wk_key,
			    keys->wi_keys[i].wi_keydat, len);
		}
		error = ENETRESET;
		break;
	case WI_RID_MAX_DATALEN:
		if (len != 2)
			return EINVAL;
		len = letoh16(wreq.wi_val[0]);
		if (len < 350 /* ? */ || len > IEEE80211_MAX_LEN)
			return EINVAL;
		if (len != IEEE80211_MAX_LEN)
			return EINVAL;		/* TODO: fragment */
		ic->ic_fragthreshold = len;
		error = ENETRESET;
		break;
	case WI_RID_IFACE_STATS:
		error = EPERM;
		break;
	case WI_RID_SCAN_REQ:			/* XXX wicontrol */
		if (ic->ic_opmode == IEEE80211_M_HOSTAP)
			break;
		error = ieee80211_setupscan(ic);
		if (error == 0)
			error = ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		break;
	case WI_RID_SCAN_APS:
		if (ic->ic_opmode == IEEE80211_M_HOSTAP)
			break;
		len--;			/* XXX: tx rate? */
		/* FALLTHRU */
	case WI_RID_CHANNEL_LIST:
		memset(chanlist, 0, sizeof(chanlist));
		/*
		 * Since channel 0 is not available for DS, channel 1
		 * is assigned to LSB on WaveLAN.
		 */
		if (ic->ic_phytype == IEEE80211_T_DS)
			i = 1;
		else
			i = 0;
		for (j = 0; i <= IEEE80211_CHAN_MAX; i++, j++) {
			if ((j / 8) >= len)
				break;
			if (isclr((u_int8_t *)wreq.wi_val, j))
				continue;
			if (isclr(ic->ic_chan_active, i)) {
				if (wreq.wi_type != WI_RID_CHANNEL_LIST)
					continue;
				if (isclr(ic->ic_chan_avail, i))
					return EPERM;
			}
			setbit(chanlist, i);
		}
		memcpy(ic->ic_chan_active, chanlist,
		    sizeof(ic->ic_chan_active));
		error = ieee80211_setupscan(ic);
		if (wreq.wi_type == WI_RID_CHANNEL_LIST) {
			/* NB: ignore error from ieee80211_setupscan */
			error = ENETRESET;
		} else if (error == 0)
			error = ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		break;
	default:
		error = EINVAL;
		break;
	}
	return error;
d153 2
a154 1
#if defined(__OpenBSD__)
a155 3
	struct hostap_getall reqall;
	struct hostap_sta stabuf;
#endif
a159 1
#ifdef __OpenBSD__
a160 3
#else
		error = ether_ioctl(ifp, cmd, data);
#endif
a378 9
	case SIOCGIFGENERIC:
		error = ieee80211_cfgget(ifp, cmd, data);
		break;
	case SIOCSIFGENERIC:
		error = suser(curproc, 0);
		if (error)
			break;
		error = ieee80211_cfgset(ifp, cmd, data);
		break;
d421 31
a451 3
#if defined(__OpenBSD__)
	case SIOCHOSTAP_DEL:
		if ((error = suser(curproc, 0)))
d453 2
a454 1
		if ((error = copyin(ifr->ifr_data, &stabuf, sizeof(stabuf))))
d456 4
a459 1
		ni = ieee80211_find_node(ic, stabuf.addr);
d461 2
d464 15
d498 3
a500 17
	case SIOCHOSTAP_GET:
		if ((error = copyin(ifr->ifr_data, &stabuf, sizeof(stabuf))))
			break;
		ni = ieee80211_find_node(ic, stabuf.addr);
		if (ni == NULL)
			error = ENOENT;
		else {
			node2sta(ic, ni, &stabuf);
			error = copyout(&stabuf, ifr->ifr_data,
			    sizeof(stabuf));
		}
		break;
	case SIOCHOSTAP_GETALL:
		if ((error = copyin(ifr->ifr_data, &reqall, sizeof(reqall))))
			break;

		reqall.nstations = i = 0;
d502 5
a506 4
		while(ni && reqall.size >= i + sizeof(struct hostap_sta)) {
			node2sta(ic, ni, &stabuf);
			error = copyout(&stabuf, (caddr_t) reqall.addr + i,
			    sizeof(struct hostap_sta));
d509 2
a510 2
			i += sizeof(struct hostap_sta);
			reqall.nstations++;
d513 1
a513 9

		if (!error)
			error = copyout(&reqall, ifr->ifr_data,
			    sizeof(reqall));
		break;
	case SIOCHOSTAP_ADD:
	case SIOCHOSTAP_GFLAGS:
	case SIOCHOSTAP_SFLAGS:
#endif
a519 18

#if defined(__OpenBSD__)
void
node2sta(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct hostap_sta *sta)
{
	bcopy(ni->ni_macaddr, sta->addr, IEEE80211_ADDR_LEN);
	sta->flags = 0;
	if (ni->ni_state >= IEEE80211_STA_AUTH)
		sta->flags |= HOSTAP_FLAGS_AUTHEN;
	if (ni->ni_state >= IEEE80211_STA_ASSOC)
		sta->flags |= HOSTAP_FLAGS_ASSOC;
	sta->asid = ni->ni_associd;
	sta->capinfo = ni->ni_capinfo;
	sta->sig_info = (*ic->ic_node_getrssi)(ic, ni);
	sta->rates = 0x00;	/* not compatible */
}
#endif
@


1.10
log
@Protect SIOCSIFMTU, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.9 2005/04/01 16:52:25 uwe Exp $	*/
a1096 2
		if ((error = suser(curproc, 0)) != 0)
			break;
@


1.9
log
@Protect more SIOCS* commands with suser() checks.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.8 2005/04/01 16:29:55 uwe Exp $	*/
d1097 2
@


1.8
log
@Fix some ioctl permission checks on the basis of what if_wi.c does.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.7 2005/02/27 22:27:56 reyk Exp $	*/
a827 12
	case SIOCS80211NWID:
	case SIOCS80211NWKEY:
	case SIOCS80211POWER:
	case SIOCS80211TXPOWER:
		error = suser(curproc, 0);
		if (error)
			return (error);
	default:
		break;
	}

	switch (cmd) {
d841 2
d870 2
d939 2
d963 2
d1008 2
d1074 2
@


1.7
log
@remove dead code of unsupported ioctls from FreeBSD. we do it in a
different way.

ok deraadt@@, martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.6 2005/02/17 18:28:05 reyk Exp $	*/
d828 12
a1076 2
		if ((error = suser(curproc, 0)))
			break;
@


1.6
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.5 2005/02/15 19:44:15 reyk Exp $	*/
d44 1
a44 1
 * IEEE 802.11 ioctl support (FreeBSD-specific)
d62 1
a62 3
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
d68 1
a68 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d70 1
a70 1
#endif /* __FreeBSD__ */
d79 1
a79 3
#if defined(__FreeBSD__)
#include <dev/wi/if_wavelan_ieee.h>
#elif defined(__OpenBSD__)
a803 313
#ifdef __FreeBSD__
int
ieee80211_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ieee80211com *ic = (void *)ifp;
	int error = 0;
	u_int kid, len;
	struct ieee80211req *ireq;
	struct ifreq *ifr;
	u_int8_t tmpkey[IEEE80211_KEYBUF_SIZE];
	char tmpssid[IEEE80211_NWID_LEN];
	struct ieee80211_channel *chan;
	struct ifaddr *ifa;			/* XXX */

	switch (cmd) {
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, (struct ifreq *) data,
				&ic->ic_media, cmd);
		break;
	case SIOCG80211:
		ireq = (struct ieee80211req *) data;
		switch (ireq->i_type) {
		case IEEE80211_IOC_SSID:
			switch (ic->ic_state) {
			case IEEE80211_S_INIT:
			case IEEE80211_S_SCAN:
				ireq->i_len = ic->ic_des_esslen;
				memcpy(tmpssid, ic->ic_des_essid, ireq->i_len);
				break;
			default:
				ireq->i_len = ic->ic_bss->ni_esslen;
				memcpy(tmpssid, ic->ic_bss->ni_essid,
					ireq->i_len);
				break;
			}
			error = copyout(tmpssid, ireq->i_data, ireq->i_len);
			break;
		case IEEE80211_IOC_NUMSSIDS:
			ireq->i_val = 1;
			break;
		case IEEE80211_IOC_WEP:
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0) {
				ireq->i_val = IEEE80211_WEP_NOSUP;
			} else {
				if (ic->ic_flags & IEEE80211_F_WEPON) {
					ireq->i_val =
					    IEEE80211_WEP_MIXED;
				} else {
					ireq->i_val =
					    IEEE80211_WEP_OFF;
				}
			}
			break;
		case IEEE80211_IOC_WEPKEY:
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0) {
				error = EINVAL;
				break;
			}
			kid = (u_int) ireq->i_val;
			if (kid >= IEEE80211_WEP_NKID) {
				error = EINVAL;
				break;
			}
			len = (u_int) ic->ic_nw_keys[kid].wk_len;
			/* NB: only root can read WEP keys */
			if (suser(curthread) == 0) {
				bcopy(ic->ic_nw_keys[kid].wk_key, tmpkey, len);
			} else {
				bzero(tmpkey, len);
			}
			ireq->i_len = len;
			error = copyout(tmpkey, ireq->i_data, len);
			break;
		case IEEE80211_IOC_NUMWEPKEYS:
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0)
				error = EINVAL;
			else
				ireq->i_val = IEEE80211_WEP_NKID;
			break;
		case IEEE80211_IOC_WEPTXKEY:
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0)
				error = EINVAL;
			else
				ireq->i_val = ic->ic_wep_txkey;
			break;
		case IEEE80211_IOC_AUTHMODE:
			ireq->i_val = IEEE80211_AUTH_OPEN;
			break;
		case IEEE80211_IOC_CHANNEL:
			switch (ic->ic_state) {
			case IEEE80211_S_INIT:
			case IEEE80211_S_SCAN:
				if (ic->ic_opmode == IEEE80211_M_STA)
					chan = ic->ic_des_chan;
				else
					chan = ic->ic_ibss_chan;
				break;
			default:
				chan = ic->ic_bss->ni_chan;
				break;
			}
			ireq->i_val = ieee80211_chan2ieee(ic, chan);
			break;
		case IEEE80211_IOC_POWERSAVE:
			if (ic->ic_flags & IEEE80211_F_PMGTON)
				ireq->i_val = IEEE80211_POWERSAVE_ON;
			else
				ireq->i_val = IEEE80211_POWERSAVE_OFF;
			break;
		case IEEE80211_IOC_POWERSAVESLEEP:
			ireq->i_val = ic->ic_lintval;
			break;
		case IEEE80211_IOC_RTSTHRESHOLD:
			ireq->i_val = ic->ic_rtsthreshold;
			break;
		case IEEE80211_IOC_PROTMODE:
			ireq->i_val = ic->ic_protmode;
			break;
		case IEEE80211_IOC_TXPOWER:
			if ((ic->ic_caps & IEEE80211_C_TXPMGT) == 0)
				error = EINVAL;
			else
				ireq->i_val = ic->ic_txpower;
			break;
		default:
			error = EINVAL;
			break;
		}
		break;
	case SIOCS80211:
		error = suser(curproc, 0);
		if (error)
			break;
		ireq = (struct ieee80211req *) data;
		switch (ireq->i_type) {
		case IEEE80211_IOC_SSID:
			if (ireq->i_val != 0 ||
			    ireq->i_len > IEEE80211_NWID_LEN) {
				error = EINVAL;
				break;
			}
			error = copyin(ireq->i_data, tmpssid, ireq->i_len);
			if (error)
				break;
			memset(ic->ic_des_essid, 0, IEEE80211_NWID_LEN);
			ic->ic_des_esslen = ireq->i_len;
			memcpy(ic->ic_des_essid, tmpssid, ireq->i_len);
			error = ENETRESET;
			break;
		case IEEE80211_IOC_WEP:
			/*
			 * These cards only support one mode so
			 * we just turn wep on if what ever is
			 * passed in is not OFF.
			 */
			if (ireq->i_val == IEEE80211_WEP_OFF) {
				ic->ic_flags &= ~IEEE80211_F_WEPON;
			} else {
				ic->ic_flags |= IEEE80211_F_WEPON;
			}
			error = ENETRESET;
			break;
		case IEEE80211_IOC_WEPKEY:
			if ((ic->ic_caps & IEEE80211_C_WEP) == 0) {
				error = EINVAL;
				break;
			}
			kid = (u_int) ireq->i_val;
			if (kid >= IEEE80211_WEP_NKID) {
				error = EINVAL;
				break;
			}
			if (ireq->i_len > sizeof(tmpkey)) {
				error = EINVAL;
				break;
			}
			memset(tmpkey, 0, sizeof(tmpkey));
			error = copyin(ireq->i_data, tmpkey, ireq->i_len);
			if (error)
				break;
			memcpy(ic->ic_nw_keys[kid].wk_key, tmpkey,
				sizeof(tmpkey));
			ic->ic_nw_keys[kid].wk_len = ireq->i_len;
			error = ENETRESET;
			break;
		case IEEE80211_IOC_WEPTXKEY:
			kid = (u_int) ireq->i_val;
			if (kid >= IEEE80211_WEP_NKID) {
				error = EINVAL;
				break;
			}
			ic->ic_wep_txkey = kid;
			error = ENETRESET;
			break;
#if 0
		case IEEE80211_IOC_AUTHMODE:
			sc->wi_authmode = ireq->i_val;
			break;
#endif
		case IEEE80211_IOC_CHANNEL:
			/* XXX 0xffff overflows 16-bit signed */
			if (ireq->i_val == 0 ||
			    ireq->i_val == (int16_t) IEEE80211_CHAN_ANY)
				ic->ic_des_chan = IEEE80211_CHAN_ANYC;
			else if ((u_int) ireq->i_val > IEEE80211_CHAN_MAX ||
			    isclr(ic->ic_chan_active, ireq->i_val)) {
				error = EINVAL;
				break;
			} else
				ic->ic_ibss_chan = ic->ic_des_chan =
					&ic->ic_channels[ireq->i_val];
			switch (ic->ic_state) {
			case IEEE80211_S_INIT:
			case IEEE80211_S_SCAN:
				error = ENETRESET;
				break;
			default:
				if (ic->ic_opmode == IEEE80211_M_STA) {
					if (ic->ic_des_chan != IEEE80211_CHAN_ANYC &&
					    ic->ic_bss->ni_chan != ic->ic_des_chan)
						error = ENETRESET;
				} else {
					if (ic->ic_bss->ni_chan != ic->ic_ibss_chan)
						error = ENETRESET;
				}
				break;
			}
			break;
		case IEEE80211_IOC_POWERSAVE:
			switch (ireq->i_val) {
			case IEEE80211_POWERSAVE_OFF:
				if (ic->ic_flags & IEEE80211_F_PMGTON) {
					ic->ic_flags &= ~IEEE80211_F_PMGTON;
					error = ENETRESET;
				}
				break;
			case IEEE80211_POWERSAVE_ON:
				if ((ic->ic_caps & IEEE80211_C_PMGT) == 0)
					error = EINVAL;
				else if ((ic->ic_flags & IEEE80211_F_PMGTON) == 0) {
					ic->ic_flags |= IEEE80211_F_PMGTON;
					error = ENETRESET;
				}
				break;
			default:
				error = EINVAL;
				break;
			}
			break;
		case IEEE80211_IOC_POWERSAVESLEEP:
			if (ireq->i_val < 0) {
				error = EINVAL;
				break;
			}
			ic->ic_lintval = ireq->i_val;
			error = ENETRESET;
			break;
		case IEEE80211_IOC_RTSTHRESHOLD:
			if (!(IEEE80211_RTS_MIN < ireq->i_val &&
			      ireq->i_val <= IEEE80211_RTS_MAX + 1)) {
				error = EINVAL;
				break;
			}
			ic->ic_rtsthreshold = ireq->i_val;
			error = ENETRESET;
			break;
		case IEEE80211_IOC_PROTMODE:
			if (ireq->i_val > IEEE80211_PROT_RTSCTS) {
				error = EINVAL;
				break;
			}
			ic->ic_protmode = ireq->i_val;
			/* NB: if not operating in 11g this can wait */
			if (ic->ic_curmode == IEEE80211_MODE_11G)
				error = ENETRESET;
			break;
		case IEEE80211_IOC_TXPOWER:
			if ((ic->ic_caps & IEEE80211_C_TXPMGT) == 0) {
				error = EINVAL;
				break;
			}
			if (!(IEEE80211_TXPOWER_MIN < ireq->i_val &&
			      ireq->i_val < IEEE80211_TXPOWER_MAX)) {
				error = EINVAL;
				break;
			}
			ic->ic_txpower = ireq->i_val;
			error = ENETRESET;
			break;
		default:
			error = EINVAL;
			break;
		}
		break;
	case SIOCGIFGENERIC:
		error = ieee80211_cfgget(ifp, cmd, data);
		break;
	case SIOCSIFGENERIC:
		error = suser(curproc, 0);
		if (error)
			break;
		error = ieee80211_cfgset(ifp, cmd, data);
		break;
	default:
		error = ether_ioctl(ifp, cmd, data);
		break;
	}
	return error;
}

#else /* !__FreeBSD__ */

a1164 1
#endif /* !__FreeBSD__ */
@


1.5
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.4 2004/11/25 11:20:04 reyk Exp $	*/
d1369 3
d1375 4
d1436 1
a1436 1
			ieee80211_free_node(ic, ni);
@


1.4
log
@compatibility ioctls for things like "wicontrol ath0 -l" to
list known stations on a net80211-based ap.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.3 2004/06/28 19:29:40 millert Exp $	*/
d1133 1
d1372 23
@


1.3
log
@Don't restrict WEP keys to exactly 40 or 108 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.2 2004/06/28 02:51:18 millert Exp $	*/
d85 1
d90 5
d1137 5
d1380 65
d1452 18
@


1.2
log
@Enable AP scanning via the WI_RID_PRISM2 ioctl.  Now atw(4) can do
ap scanning via wicontrol.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.c,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d274 1
a277 1
			memset(keys, 0, sizeof(*keys));
d725 1
a725 3
			if (len != 0 && len < IEEE80211_WEP_KEYLEN)
				return EINVAL;
			if (len > sizeof(ic->ic_nw_keys[i].wk_key))
d1183 1
a1183 3
			if ((keys[i].wk_len > 0 &&
			    keys[i].wk_len < IEEE80211_WEP_KEYLEN) ||
			    keys[i].wk_len > sizeof(keys[i].wk_key)) {
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a108 1
#if 0 /* TBD */
a110 1
#endif
a120 1
	case WI_RID_PRISM2:
a345 1
#if 0
a384 1
#endif /* 0 */
@

