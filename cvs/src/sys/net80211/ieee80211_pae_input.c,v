head	1.29;
access;
symbols
	OPENBSD_6_1:1.28.0.4
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.25.0.6
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.23.0.2
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.6
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.29
date	2017.07.22.16.48.21;	author stsp;	state Exp;
branches;
next	1.28;
commitid	K0lWmxq54ENyHiOt;

1.28
date	2017.03.01.20.20.45;	author stsp;	state Exp;
branches
	1.28.4.1;
next	1.27;
commitid	hDlvjfzLM3GN2lHt;

1.27
date	2017.03.01.19.28.48;	author stsp;	state Exp;
branches;
next	1.26;
commitid	ziqUM3IRerOy1q1r;

1.26
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.25;
commitid	PETPfbQ5ZWdJqIYS;

1.25
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches
	1.25.2.1
	1.25.6.1;
next	1.24;
commitid	ncpqEGjDtSFuLAgn;

1.24
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.23;
commitid	p4LJxGKbi0BU2cG6;

1.23
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.22;
commitid	PYnSnAqgemmk34E3;

1.22
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.21;
commitid	Z1vcFtHO8wRH0yRt;

1.21
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.20;
commitid	uzzBR7hz9ncd4O6G;

1.20
date	2014.07.24.08.23.12;	author mpi;	state Exp;
branches;
next	1.19;
commitid	BthvtJHvqLhPjgJz;

1.19
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.18;
commitid	DQakU8LLWV6Iwx84;

1.18
date	2011.05.04.16.05.49;	author blambert;	state Exp;
branches;
next	1.17;

1.17
date	2010.02.06.15.16.27;	author jcs;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.23.16.54.38;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2008.12.06.09.02.47;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2008.08.13.17.38.02;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2008.08.12.18.22.41;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2008.08.12.17.53.13;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2008.08.12.16.14.05;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.12.16.05.15;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.02.08.25.59;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.02.08.20.16;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.21.19.05.21;	author damien;	state Exp;
branches;
next	;

1.25.2.1
date	2017.03.01.20.57.29;	author benno;	state Exp;
branches;
next	;
commitid	Yy9A53bTb4WnX3us;

1.25.6.1
date	2017.03.01.20.57.51;	author benno;	state Exp;
branches;
next	;
commitid	ChXblF78aIW5HGQF;

1.28.4.1
date	2017.08.01.22.30.29;	author bluhm;	state Exp;
branches;
next	;
commitid	xsXnpuiIggt965bT;


desc
@@


1.29
log
@Fix length checks in EAPOL key frame parsing.
Problem reported by Ilja Van Sprundel.
ok tb@@ kevlo@@
@
text
@/*	$OpenBSD: ieee80211_pae_input.c,v 1.28 2017/03/01 20:20:45 stsp Exp $	*/

/*-
 * Copyright (c) 2007,2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This code implements the 4-Way Handshake and Group Key Handshake protocols
 * (both Supplicant and Authenticator Key Receive state machines) defined in
 * IEEE Std 802.11-2007 section 8.5.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

void	ieee80211_recv_4way_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_4way_msg2(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *,
	    const u_int8_t *);
#endif
void	ieee80211_recv_4way_msg3(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_4way_msg4(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_4way_msg2or4(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
#endif
void	ieee80211_recv_rsn_group_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_wpa_group_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_group_msg2(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_eapol_key_req(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
#endif

/*
 * Process an incoming EAPOL frame.  Notice that we are only interested in
 * EAPOL-Key frames with an IEEE 802.11 or WPA descriptor type.
 */
void
ieee80211_eapol_key_input(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ether_header *eh;
	struct ieee80211_eapol_key *key;
	u_int16_t info, desc;
	int totlen, bodylen, paylen;

	ifp->if_ibytes += m->m_pkthdr.len;

	eh = mtod(m, struct ether_header *);
	if (IEEE80211_IS_MULTICAST(eh->ether_dhost)) {
		ifp->if_imcasts++;
		goto done;
	}
	m_adj(m, sizeof(*eh));

	if (m->m_pkthdr.len < sizeof(*key))
		goto done;
	if (m->m_len < sizeof(*key) &&
	    (m = m_pullup(m, sizeof(*key))) == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		goto done;
	}
	key = mtod(m, struct ieee80211_eapol_key *);

	if (key->type != EAPOL_KEY)
		goto done;
	ic->ic_stats.is_rx_eapol_key++;

	if ((ni->ni_rsnprotos == IEEE80211_PROTO_RSN &&
	     key->desc != EAPOL_KEY_DESC_IEEE80211) ||
	    (ni->ni_rsnprotos == IEEE80211_PROTO_WPA &&
	     key->desc != EAPOL_KEY_DESC_WPA))
		goto done;

	/* check packet body length */
	bodylen = BE_READ_2(key->len);
	totlen = 4 + bodylen;
	if (m->m_pkthdr.len < totlen || totlen > MCLBYTES)
		goto done;

	/* check key data length */
	paylen = BE_READ_2(key->paylen);
	if (paylen > totlen - sizeof(*key))
		goto done;

	info = BE_READ_2(key->info);

	/* discard EAPOL-Key frames with an unknown descriptor version */
	desc = info & EAPOL_KEY_VERSION_MASK;
	if (desc < EAPOL_KEY_DESC_V1 || desc > EAPOL_KEY_DESC_V3)
		goto done;

	if (ieee80211_is_sha256_akm(ni->ni_rsnakms)) {
		if (desc != EAPOL_KEY_DESC_V3)
			goto done;
	} else if (ni->ni_rsncipher == IEEE80211_CIPHER_CCMP ||
	     ni->ni_rsngroupcipher == IEEE80211_CIPHER_CCMP) {
		if (desc != EAPOL_KEY_DESC_V2)
			goto done;
	}

	/* make sure the key data field is contiguous */
	if (m->m_len < totlen && (m = m_pullup(m, totlen)) == NULL) {
		ic->ic_stats.is_rx_nombuf++;
		goto done;
	}
	key = mtod(m, struct ieee80211_eapol_key *);

	/* determine message type (see 8.5.3.7) */
	if (info & EAPOL_KEY_REQUEST) {
#ifndef IEEE80211_STA_ONLY
		/* EAPOL-Key Request frame */
		ieee80211_recv_eapol_key_req(ic, key, ni);
#endif
	} else if (info & EAPOL_KEY_PAIRWISE) {
		/* 4-Way Handshake */
		if (info & EAPOL_KEY_KEYMIC) {
			if (info & EAPOL_KEY_KEYACK)
				ieee80211_recv_4way_msg3(ic, key, ni);
#ifndef IEEE80211_STA_ONLY
			else
				ieee80211_recv_4way_msg2or4(ic, key, ni);
#endif
		} else if (info & EAPOL_KEY_KEYACK)
			ieee80211_recv_4way_msg1(ic, key, ni);
	} else {
		/* Group Key Handshake */
		if (!(info & EAPOL_KEY_KEYMIC))
			goto done;
		if (info & EAPOL_KEY_KEYACK) {
			if (key->desc == EAPOL_KEY_DESC_WPA)
				ieee80211_recv_wpa_group_msg1(ic, key, ni);
			else
				ieee80211_recv_rsn_group_msg1(ic, key, ni);
		}
#ifndef IEEE80211_STA_ONLY
		else
			ieee80211_recv_group_msg2(ic, key, ni);
#endif
	}
 done:
	m_freem(m);
}

/*
 * Process Message 1 of the 4-Way Handshake (sent by Authenticator).
 */
void
ieee80211_recv_4way_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_ptk tptk;
	struct ieee80211_pmk *pmk;
	const u_int8_t *frm, *efrm;
	const u_int8_t *pmkid;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;
#endif
	/* 
	 * Message 1 is always expected while RSN is active since some
	 * APs will rekey the PTK by sending Msg1/4 after some time.
	 */
	if (ni->ni_rsn_supp_state == RSNA_SUPP_INITIALIZE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_supp_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (ni->ni_replaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}

	/* parse key data field (may contain an encapsulated PMKID) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	pmkid = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_PMKID:
					pmkid = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* check that the PMKID KDE is valid (if present) */
	if (pmkid != NULL && pmkid[1] != 4 + 16)
		return;

	if (ieee80211_is_8021x_akm(ni->ni_rsnakms)) {
		/* retrieve the PMK for this (AP,PMKID) */
		pmk = ieee80211_pmksa_find(ic, ni,
		    (pmkid != NULL) ? &pmkid[6] : NULL);
		if (pmk == NULL) {
			DPRINTF(("no PMK available for %s\n",
			    ether_sprintf(ni->ni_macaddr)));
			return;
		}
		memcpy(ni->ni_pmk, pmk->pmk_key, IEEE80211_PMK_LEN);
	} else	/* use pre-shared key */
		memcpy(ni->ni_pmk, ic->ic_psk, IEEE80211_PMK_LEN);
	ni->ni_flags |= IEEE80211_NODE_PMK;

	/* save authenticator's nonce (ANonce) */
	memcpy(ni->ni_nonce, key->nonce, EAPOL_KEY_NONCE_LEN);

	/* generate supplicant's nonce (SNonce) */
	arc4random_buf(ic->ic_nonce, EAPOL_KEY_NONCE_LEN);

	/* TPTK = CalcPTK(PMK, ANonce, SNonce) */
	ieee80211_derive_ptk(ni->ni_rsnakms, ni->ni_pmk, ni->ni_macaddr,
	    ic->ic_myaddr, ni->ni_nonce, ic->ic_nonce, &tptk);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator using TPTK */
	(void)ieee80211_send_4way_msg2(ic, ni, key->replaycnt, &tptk);
}

#ifndef IEEE80211_STA_ONLY
/*
 * Process Message 2 of the 4-Way Handshake (sent by Supplicant).
 */
void
ieee80211_recv_4way_msg2(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni,
    const u_int8_t *rsnie)
{
	struct ieee80211_ptk tptk;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKSTART &&
	    ni->ni_rsn_state != RSNA_PTKCALCNEGOTIATING) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING;

	/* NB: replay counter has already been verified by caller */

	/* PTK = CalcPTK(ANonce, SNonce) */
	ieee80211_derive_ptk(ni->ni_rsnakms, ni->ni_pmk, ic->ic_myaddr,
	    ni->ni_macaddr, ni->ni_nonce, key->nonce, &tptk);

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, tptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;	/* will timeout.. */
	}

	timeout_del(&ni->ni_eapol_to);
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING_2;
	ni->ni_rsn_retries = 0;

	/* install TPTK as PTK now that MIC is verified */
	memcpy(&ni->ni_ptk, &tptk, sizeof(tptk));

	/*
	 * The RSN IE must match bit-wise with what the STA included in its
	 * (Re)Association Request.
	 */
	if (ni->ni_rsnie == NULL || rsnie[1] != ni->ni_rsnie[1] ||
	    memcmp(rsnie, ni->ni_rsnie, 2 + rsnie[1]) != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_RSN_DIFFERENT_IE);
		ieee80211_node_leave(ic, ni);
		return;
	}

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 2, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 3 to supplicant */
	(void)ieee80211_send_4way_msg3(ic, ni);
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Process Message 3 of the 4-Way Handshake (sent by Authenticator).
 */
void
ieee80211_recv_4way_msg3(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_ptk tptk;
	struct ieee80211_key *k;
	const u_int8_t *frm, *efrm;
	const u_int8_t *rsnie1, *rsnie2, *gtk, *igtk;
	u_int16_t info, reason = 0;
	int keylen;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;
#endif
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RSNA_SUPP_PTKNEGOTIATING &&
	    ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_supp_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (ni->ni_replaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* make sure that a PMK has been selected */
	if (!(ni->ni_flags & IEEE80211_NODE_PMK)) {
		DPRINTF(("no PMK found for %s\n",
		    ether_sprintf(ni->ni_macaddr)));
		return;
	}
	/* check that ANonce matches that of Message 1 */
	if (memcmp(key->nonce, ni->ni_nonce, EAPOL_KEY_NONCE_LEN) != 0) {
		DPRINTF(("ANonce does not match msg 1/4\n"));
		return;
	}
	/* TPTK = CalcPTK(PMK, ANonce, SNonce) */
	ieee80211_derive_ptk(ni->ni_rsnakms, ni->ni_pmk, ni->ni_macaddr,
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, &tptk);

	info = BE_READ_2(key->info);

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, tptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/* install TPTK as PTK now that MIC is verified */
	memcpy(&ni->ni_ptk, &tptk, sizeof(tptk));

	/* if encrypted, decrypt Key Data field using KEK */
	if ((info & EAPOL_KEY_ENCRYPTED) &&
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		DPRINTF(("decryption failed\n"));
		return;
	}

	/* parse key data field */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	/*
	 * Some WPA1+WPA2 APs (like hostapd) appear to include both WPA and
	 * RSN IEs in message 3/4.  We only take into account the IE of the
	 * version of the protocol we negotiated at association time.
	 */
	rsnie1 = rsnie2 = gtk = igtk = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_RSN:
			if (ni->ni_rsnprotos != IEEE80211_PROTO_RSN)
				break;
			if (rsnie1 == NULL)
				rsnie1 = frm;
			else if (rsnie2 == NULL)
				rsnie2 = frm;
			/* ignore others if more than two RSN IEs */
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_GTK:
					gtk = frm;
					break;
				case IEEE80211_KDE_IGTK:
					if (ni->ni_flags & IEEE80211_NODE_MFP)
						igtk = frm;
					break;
				}
			} else if (memcmp(&frm[2], MICROSOFT_OUI, 3) == 0) {
				switch (frm[5]) {
				case 1:	/* WPA */
					if (ni->ni_rsnprotos !=
					    IEEE80211_PROTO_WPA)
						break;
					rsnie1 = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* first WPA/RSN IE is mandatory */
	if (rsnie1 == NULL) {
		DPRINTF(("missing RSN IE\n"));
		return;
	}
	/* key data must be encrypted if GTK is included */
	if (gtk != NULL && !(info & EAPOL_KEY_ENCRYPTED)) {
		DPRINTF(("GTK not encrypted\n"));
		return;
	}
	/* GTK KDE must be included if IGTK KDE is present */
	if (igtk != NULL && gtk == NULL) {
		DPRINTF(("IGTK KDE found but GTK KDE missing\n"));
		return;
	}
	/* check that the Install bit is set if using pairwise keys */
	if (ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP &&
	    !(info & EAPOL_KEY_INSTALL)) {
		DPRINTF(("pairwise cipher but !Install\n"));
		return;
	}

	/*
	 * Check that first WPA/RSN IE is identical to the one received in
	 * the beacon or probe response frame.
	 */
	if (ni->ni_rsnie == NULL || rsnie1[1] != ni->ni_rsnie[1] ||
	    memcmp(rsnie1, ni->ni_rsnie, 2 + rsnie1[1]) != 0) {
		reason = IEEE80211_REASON_RSN_DIFFERENT_IE;
		goto deauth;
	}

	/*
	 * If a second RSN information element is present, use its pairwise
	 * cipher suite or deauthenticate.
	 */
	if (rsnie2 != NULL) {
		struct ieee80211_rsnparams rsn;

		if (ieee80211_parse_rsn(ic, rsnie2, &rsn) == 0) {
			if (rsn.rsn_akms != ni->ni_rsnakms ||
			    rsn.rsn_groupcipher != ni->ni_rsngroupcipher ||
			    rsn.rsn_nciphers != 1 ||
			    !(rsn.rsn_ciphers & ic->ic_rsnciphers)) {
				reason = IEEE80211_REASON_BAD_PAIRWISE_CIPHER;
				goto deauth;
			}
			/* use pairwise cipher suite of second RSN IE */
			ni->ni_rsnciphers = rsn.rsn_ciphers;
			ni->ni_rsncipher = ni->ni_rsnciphers;
		}
	}

	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);
	ni->ni_replaycnt_ok = 1;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 3, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 4 to authenticator */
	if (ieee80211_send_4way_msg4(ic, ni) != 0)
		return;	/* ..authenticator will retry */

	if (ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP) {
		u_int64_t prsc;

		/* check that key length matches that of pairwise cipher */
		keylen = ieee80211_cipher_keylen(ni->ni_rsncipher);
		if (BE_READ_2(key->keylen) != keylen) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		prsc = (gtk == NULL) ? LE_READ_6(key->rsc) : 0;

		/* map PTK to 802.11 key */
		k = &ni->ni_pairwise_key;
		memset(k, 0, sizeof(*k));
		k->k_cipher = ni->ni_rsncipher;
		k->k_rsc[0] = prsc;
		k->k_len = keylen;
		memcpy(k->k_key, ni->ni_ptk.tk, k->k_len);
		/* install the PTK */
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		ni->ni_flags &= ~IEEE80211_NODE_TXRXPROT;
		ni->ni_flags |= IEEE80211_NODE_RXPROT;
	}
	if (gtk != NULL) {
		u_int8_t kid;

		/* check that key length matches that of group cipher */
		keylen = ieee80211_cipher_keylen(ni->ni_rsngroupcipher);
		if (gtk[1] != 6 + keylen) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* map GTK to 802.11 key */
		kid = gtk[6] & 3;
		k = &ic->ic_nw_keys[kid];
		memset(k, 0, sizeof(*k));
		k->k_id = kid;	/* 0-3 */
		k->k_cipher = ni->ni_rsngroupcipher;
		k->k_flags = IEEE80211_KEY_GROUP;
		if (gtk[6] & (1 << 2))
			k->k_flags |= IEEE80211_KEY_TX;
		k->k_rsc[0] = LE_READ_6(key->rsc);
		k->k_len = keylen;
		memcpy(k->k_key, &gtk[8], k->k_len);
		/* install the GTK */
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
	}
	if (igtk != NULL) {	/* implies MFP && gtk != NULL */
		u_int16_t kid;

		/* check that the IGTK KDE is valid */
		if (igtk[1] != 4 + 24) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		kid = LE_READ_2(&igtk[6]);
		if (kid != 4 && kid != 5) {
			DPRINTF(("unsupported IGTK id %u\n", kid));
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* map IGTK to 802.11 key */
		k = &ic->ic_nw_keys[kid];
		memset(k, 0, sizeof(*k));
		k->k_id = kid;	/* either 4 or 5 */
		k->k_cipher = ni->ni_rsngroupmgmtcipher;
		k->k_flags = IEEE80211_KEY_IGTK;
		k->k_mgmt_rsc = LE_READ_6(&igtk[8]);	/* IPN */
		k->k_len = 16;
		memcpy(k->k_key, &igtk[14], k->k_len);
		/* install the IGTK */
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
	}
	if (info & EAPOL_KEY_INSTALL)
		ni->ni_flags |= IEEE80211_NODE_TXRXPROT;

	if (info & EAPOL_KEY_SECURE) {
		ni->ni_flags |= IEEE80211_NODE_TXRXPROT;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2)
#endif
		{
			DPRINTF(("marking port %s valid\n",
			    ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
			ieee80211_set_link_state(ic, LINK_STATE_UP);
		}
	}
 deauth:
	if (reason != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    reason);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	}
}

#ifndef IEEE80211_STA_ONLY
/*
 * Process Message 4 of the 4-Way Handshake (sent by Supplicant).
 */
void
ieee80211_recv_4way_msg4(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKINITNEGOTIATING) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}

	/* NB: replay counter has already been verified by caller */

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;	/* will timeout.. */
	}

	timeout_del(&ni->ni_eapol_to);
	ni->ni_rsn_state = RSNA_PTKINITDONE;
	ni->ni_rsn_retries = 0;

	if (ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP) {
		struct ieee80211_key *k;

		/* map PTK to 802.11 key */
		k = &ni->ni_pairwise_key;
		memset(k, 0, sizeof(*k));
		k->k_cipher = ni->ni_rsncipher;
		k->k_len = ieee80211_cipher_keylen(k->k_cipher);
		memcpy(k->k_key, ni->ni_ptk.tk, k->k_len);
		/* install the PTK */
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_DEAUTH,
			    IEEE80211_REASON_ASSOC_TOOMANY);
			ieee80211_node_leave(ic, ni);
			return;
		}
		ni->ni_flags |= IEEE80211_NODE_TXRXPROT;
	}
	if (ic->ic_opmode != IEEE80211_M_IBSS || ++ni->ni_key_count == 2) {
		DPRINTF(("marking port %s valid\n",
		    ether_sprintf(ni->ni_macaddr)));
		ni->ni_port_valid = 1;
	}

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 4, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* initiate a group key handshake for WPA */
	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA)
		(void)ieee80211_send_group_msg1(ic, ni);
	else
		ni->ni_rsn_gstate = RSNA_IDLE;
}

/*
 * Differentiate Message 2 from Message 4 of the 4-Way Handshake based on
 * the presence of an RSN or WPA Information Element.
 */
void
ieee80211_recv_4way_msg2or4(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	const u_int8_t *frm, *efrm;
	const u_int8_t *rsnie;

	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}

	/* parse key data field (check if an RSN IE is present) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	rsnie = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_RSN:
			rsnie = frm;
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], MICROSOFT_OUI, 3) == 0) {
				switch (frm[5]) {
				case 1:	/* WPA */
					rsnie = frm;
					break;
				}
			}
		}
		frm += 2 + frm[1];
	}
	if (rsnie != NULL)
		ieee80211_recv_4way_msg2(ic, key, ni, rsnie);
	else
		ieee80211_recv_4way_msg4(ic, key, ni);
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Process Message 1 of the RSN Group Key Handshake (sent by Authenticator).
 */
void
ieee80211_recv_rsn_group_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_key *k;
	const u_int8_t *frm, *efrm;
	const u_int8_t *gtk, *igtk;
	u_int16_t info, kid, reason = 0;
	int keylen;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;
#endif
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_supp_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	info = BE_READ_2(key->info);

	/* check that encrypted and decrypt Key Data field using KEK */
	if (!(info & EAPOL_KEY_ENCRYPTED) ||
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		DPRINTF(("decryption failed\n"));
		return;
	}

	/* parse key data field (shall contain a GTK KDE) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	gtk = igtk = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_GTK:
					gtk = frm;
					break;
				case IEEE80211_KDE_IGTK:
					if (ni->ni_flags & IEEE80211_NODE_MFP)
						igtk = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* check that the GTK KDE is present */
	if (gtk == NULL) {
		DPRINTF(("GTK KDE missing\n"));
		return;
	}

	/* check that key length matches that of group cipher */
	keylen = ieee80211_cipher_keylen(ni->ni_rsngroupcipher);
	if (gtk[1] != 6 + keylen)
		return;

	/* map GTK to 802.11 key */
	kid = gtk[6] & 3;
	k = &ic->ic_nw_keys[kid];
	memset(k, 0, sizeof(*k));
	k->k_id = kid;	/* 0-3 */
	k->k_cipher = ni->ni_rsngroupcipher;
	k->k_flags = IEEE80211_KEY_GROUP;
	if (gtk[6] & (1 << 2))
		k->k_flags |= IEEE80211_KEY_TX;
	k->k_rsc[0] = LE_READ_6(key->rsc);
	k->k_len = keylen;
	memcpy(k->k_key, &gtk[8], k->k_len);
	/* install the GTK */
	if ((*ic->ic_set_key)(ic, ni, k) != 0) {
		reason = IEEE80211_REASON_AUTH_LEAVE;
		goto deauth;
	}
	if (igtk != NULL) {	/* implies MFP */
		/* check that the IGTK KDE is valid */
		if (igtk[1] != 4 + 24) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		kid = LE_READ_2(&igtk[6]);
		if (kid != 4 && kid != 5) {
			DPRINTF(("unsupported IGTK id %u\n", kid));
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* map IGTK to 802.11 key */
		k = &ic->ic_nw_keys[kid];
		memset(k, 0, sizeof(*k));
		k->k_id = kid;	/* either 4 or 5 */
		k->k_cipher = ni->ni_rsngroupmgmtcipher;
		k->k_flags = IEEE80211_KEY_IGTK;
		k->k_mgmt_rsc = LE_READ_6(&igtk[8]);	/* IPN */
		k->k_len = 16;
		memcpy(k->k_key, &igtk[14], k->k_len);
		/* install the IGTK */
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
	}
	if (info & EAPOL_KEY_SECURE) {
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2)
#endif
		{
			DPRINTF(("marking port %s valid\n",
			    ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
			ieee80211_set_link_state(ic, LINK_STATE_UP);
		}
	}
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator */
	(void)ieee80211_send_group_msg2(ic, ni, NULL);
	return;
 deauth:
	IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH, reason);
	ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
}

/*
 * Process Message 1 of the WPA Group Key Handshake (sent by Authenticator).
 */
void
ieee80211_recv_wpa_group_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_key *k;
	u_int16_t info;
	u_int8_t kid;
	int keylen;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;
#endif
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_supp_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/*
	 * EAPOL-Key data field is encrypted even though WPA doesn't set
	 * the ENCRYPTED bit in the info field.
	 */
	if (ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		DPRINTF(("decryption failed\n"));
		return;
	}

	/* check that key length matches that of group cipher */
	keylen = ieee80211_cipher_keylen(ni->ni_rsngroupcipher);
	if (BE_READ_2(key->keylen) != keylen)
		return;

	/* check that the data length is large enough to hold the key */
	if (BE_READ_2(key->paylen) < keylen)
		return;

	info = BE_READ_2(key->info);

	/* map GTK to 802.11 key */
	kid = (info >> EAPOL_KEY_WPA_KID_SHIFT) & 3;
	k = &ic->ic_nw_keys[kid];
	memset(k, 0, sizeof(*k));
	k->k_id = kid;	/* 0-3 */
	k->k_cipher = ni->ni_rsngroupcipher;
	k->k_flags = IEEE80211_KEY_GROUP;
	if (info & EAPOL_KEY_WPA_TX)
		k->k_flags |= IEEE80211_KEY_TX;
	k->k_rsc[0] = LE_READ_6(key->rsc);
	k->k_len = keylen;
	/* key data field contains the GTK */
	memcpy(k->k_key, &key[1], k->k_len);
	/* install the GTK */
	if ((*ic->ic_set_key)(ic, ni, k) != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_AUTH_LEAVE);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		return;
	}
	if (info & EAPOL_KEY_SECURE) {
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2)
#endif
		{
			DPRINTF(("marking port %s valid\n",
			    ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
			ieee80211_set_link_state(ic, LINK_STATE_UP);
		}
	}
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator */
	(void)ieee80211_send_group_msg2(ic, ni, k);
}

#ifndef IEEE80211_STA_ONLY
/*
 * Process Message 2 of the Group Key Handshake (sent by Supplicant).
 */
void
ieee80211_recv_group_msg2(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_gstate != RSNA_REKEYNEGOTIATING) {
		DPRINTF(("%s: unexpected in state: %d\n", ic->ic_if.if_xname,
		     ni->ni_rsn_gstate));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		DPRINTF(("key MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}

	timeout_del(&ni->ni_eapol_to);
	ni->ni_rsn_gstate = RSNA_REKEYESTABLISHED;

	if (ni->ni_flags & IEEE80211_NODE_REKEY) {
		int rekeysta = 0;
		ni->ni_flags &= ~IEEE80211_NODE_REKEY;
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_rekeysta, &rekeysta);
		if (rekeysta == 0)
			ieee80211_setkeysdone(ic);
	}
	ni->ni_flags |= IEEE80211_NODE_TXRXPROT;

	ni->ni_rsn_gstate = RSNA_IDLE;
	ni->ni_rsn_retries = 0;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 2, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));
}

/*
 * EAPOL-Key Request frames are sent by the supplicant to request that the
 * authenticator initiates either a 4-Way Handshake or Group Key Handshake,
 * or to report a MIC failure in a TKIP MSDU.
 */
void
ieee80211_recv_eapol_key_req(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	u_int16_t info;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKINITDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
	if (ni->ni_reqreplaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_reqreplaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	info = BE_READ_2(key->info);

	if (!(info & EAPOL_KEY_KEYMIC) ||
	    ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		DPRINTF(("key request MIC failed\n"));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/* update key request replay counter now that MIC is verified */
	ni->ni_reqreplaycnt = BE_READ_8(key->replaycnt);
	ni->ni_reqreplaycnt_ok = 1;

	if (info & EAPOL_KEY_ERROR) {	/* TKIP MIC failure */
		/* ignore reports from STAs not using TKIP */
		if (ic->ic_bss->ni_rsngroupcipher != IEEE80211_CIPHER_TKIP &&
		    ni->ni_rsncipher != IEEE80211_CIPHER_TKIP) {
			DPRINTF(("MIC failure report from !TKIP STA: %s\n",
			    ether_sprintf(ni->ni_macaddr)));
			return;
		}
		ic->ic_stats.is_rx_remmicfail++;
		ieee80211_michael_mic_failure(ic, LE_READ_6(key->rsc));

	} else if (info & EAPOL_KEY_PAIRWISE) {
		/* initiate a 4-Way Handshake */

	} else {
		/*
		 * Should change the GTK, initiate the 4-Way Handshake and
		 * then execute a Group Key Handshake with all supplicants.
		 */
	}
}
#endif	/* IEEE80211_STA_ONLY */
@


1.28
log
@Fix some DPRINTFs I just added to ieee80211_pae_input.c.
No fnuctional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.27 2017/03/01 19:28:48 stsp Exp $	*/
d81 1
a81 1
	int totlen;
d112 3
a114 1
	if (m->m_pkthdr.len < 4 + BE_READ_2(key->len))
d118 2
a119 2
	totlen = sizeof(*key) + BE_READ_2(key->paylen);
	if (m->m_pkthdr.len < totlen || totlen > MCLBYTES)
@


1.28.4.1
log
@Fix length checks in EAPOL key frame parsing.
Problem reported by Ilja Van Sprundel.
errata 023
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.28 2017/03/01 20:20:45 stsp Exp $	*/
d81 1
a81 1
	int totlen, bodylen, paylen;
d112 1
a112 3
	bodylen = BE_READ_2(key->len);
	totlen = 4 + bodylen;
	if (m->m_pkthdr.len < totlen || totlen > MCLBYTES)
d116 2
a117 2
	paylen = BE_READ_2(key->paylen);
	if (paylen > totlen - sizeof(*key))
@


1.27
log
@Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.26 2017/02/02 16:47:53 stsp Exp $	*/
d201 1
a201 1
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
d358 1
a358 1
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
d758 1
a758 1
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
d910 1
a910 1
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
@


1.26
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.25 2015/07/15 22:16:42 deraadt Exp $	*/
d196 9
d355 7
d756 6
d908 6
d1006 1
d1055 5
@


1.25
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.24 2015/03/14 03:38:51 jsg Exp $	*/
d992 8
a999 4
	if ((ni->ni_flags & IEEE80211_NODE_REKEY) &&
	    --ic->ic_rsn_keydonesta == 0)
		ieee80211_setkeysdone(ic);
	ni->ni_flags &= ~IEEE80211_NODE_REKEY;
@


1.25.6.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 5.9 errata 35, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.25 2015/07/15 22:16:42 deraadt Exp $	*/
a195 9
	/* 
	 * Message 1 is always expected while RSN is active since some
	 * APs will rekey the PTK by sending Msg1/4 after some time.
	 */
	if (ni->ni_rsn_supp_state == RSNA_SUPP_INITIALIZE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a345 7
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RSNA_SUPP_PTKNEGOTIATING &&
	    ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a739 6
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a885 6
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a977 1
	/* enforce monotonicity of key request replay counter */
a1021 5
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKINITDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
@


1.25.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 6.0 errata 18, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.25 2015/07/15 22:16:42 deraadt Exp $	*/
a195 9
	/* 
	 * Message 1 is always expected while RSN is active since some
	 * APs will rekey the PTK by sending Msg1/4 after some time.
	 */
	if (ni->ni_rsn_supp_state == RSNA_SUPP_INITIALIZE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a345 7
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RSNA_SUPP_PTKNEGOTIATING &&
	    ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a739 6
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a885 6
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_supp_state != RNSA_SUPP_PTKDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
	/* enforce monotonicity of key request replay counter */
a977 1
	/* enforce monotonicity of key request replay counter */
a1021 5
	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKINITDONE) {
		DPRINTF(("unexpected in state: %d\n", ni->ni_rsn_state));
		return;
	}
@


1.24
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.23 2014/12/23 03:24:08 tedu Exp $	*/
d176 1
a176 2
	if (m != NULL)
		m_freem(m);
@


1.23
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.22 2014/11/18 02:37:31 tedu Exp $	*/
a35 1
#include <net/if_arp.h>
@


1.22
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.21 2014/09/14 14:17:26 jsg Exp $	*/
a37 1
#ifdef INET
a39 1
#endif
@


1.21
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.20 2014/07/24 08:23:12 mpi Exp $	*/
a44 2

#include <dev/rndvar.h>
@


1.20
log
@Fix debug printf, from Nathanael Rensen and chris@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.19 2014/07/22 11:06:10 mpi Exp $	*/
a31 1
#include <sys/proc.h>
@


1.19
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.18 2011/05/04 16:05:49 blambert Exp $	*/
d981 2
a982 1
		DPRINTF(("%s: unexpected in state: %d\n", ni->ni_rsn_gstate));
@


1.18
log
@Collapse m_pullup and m_pullup2 into a single function, as they're
essentially identical; the only difference being that m_pullup2 is
capable of handling mbuf clusters, but called m_pullup for shorter
lengths (!).

testing dlg@@ ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.17 2010/02/06 15:16:27 jcs Exp $	*/
a41 1
#include <netinet/in_systm.h>
@


1.17
log
@when receiving the first message of an rsn group key handshake
packet, copy the key out of it properly.

fixes the problem where only broadcast packets like ipv6 router
advertisements were failing decryption and processing, only after a
rekey.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.16 2009/11/23 16:54:38 damien Exp $	*/
d144 1
a144 1
	if (m->m_len < totlen && (m = m_pullup2(m, totlen)) == NULL) {
@


1.16
log
@how did i manage to forget that file in my last commit?
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.15 2009/01/26 19:09:41 damien Exp $	*/
d816 1
@


1.15
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.14 2008/12/06 09:02:47 damien Exp $	*/
d603 1
d857 1
d952 1
@


1.14
log
@typo, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.13 2008/09/27 15:16:09 damien Exp $	*/
d81 1
a81 1
ieee80211_eapol_key_input(struct ieee80211com *ic, struct mbuf *m0,
d90 1
a90 1
	ifp->if_ibytes += m0->m_pkthdr.len;
d92 1
a92 1
	eh = mtod(m0, struct ether_header *);
d97 1
a97 1
	m_adj(m0, sizeof(*eh));
d99 1
a99 1
	if (m0->m_pkthdr.len < sizeof(*key))
d101 2
a102 2
	if (m0->m_len < sizeof(*key) &&
	    (m0 = m_pullup(m0, sizeof(*key))) == NULL) {
d106 1
a106 1
	key = mtod(m0, struct ieee80211_eapol_key *);
d119 1
a119 1
	if (m0->m_pkthdr.len < 4 + BE_READ_2(key->len))
d124 1
a124 1
	if (m0->m_pkthdr.len < totlen || totlen > MCLBYTES)
d144 1
a144 1
	if (m0->m_len < totlen && (m0 = m_pullup2(m0, totlen)) == NULL) {
d148 1
a148 1
	key = mtod(m0, struct ieee80211_eapol_key *);
d183 2
a184 2
	if (m0 != NULL)
		m_freem(m0);
d306 1
a306 1
	timeout_del(&ni->ni_rsn_timeout);
d640 1
a640 1
	timeout_del(&ni->ni_rsn_timeout);
d992 1
a992 1
	timeout_del(&ni->ni_rsn_timeout);
@


1.13
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.12 2008/08/27 09:05:04 damien Exp $	*/
d359 1
a359 1
	/* make sure that a PMK as been selected */
@


1.12
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.11 2008/08/13 17:38:02 damien Exp $	*/
d134 1
a134 2
	if (ni->ni_rsnakms == IEEE80211_AKM_SHA256_8021X ||
	    ni->ni_rsnakms == IEEE80211_AKM_SHA256_PSK) {
d195 1
a197 1
	const u_int8_t *pmk;
d234 1
a234 1
	if (pmkid != NULL && pmkid[1] < 4 + 16)
d237 14
a250 5
	/* retrieve PMK */
	if ((pmk = ieee80211_get_pmk(ic, ni, &pmkid[6])) == NULL) {
		/* no PMK configured for this STA/PMKID */
		return;
	}
d257 2
a258 2
	/* derive TPTK */
	ieee80211_derive_ptk(ni->ni_rsnakms, pmk, ni->ni_macaddr,
a279 1
	const u_int8_t *pmk;
d293 1
a293 1
	/* replay counter has already been verified by caller */
d295 2
a296 6
	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, NULL)) == NULL) {
		/* no PMK configured for this STA */
		return;	/* will timeout.. */
	}
	ieee80211_derive_ptk(ni->ni_rsnakms, pmk, ic->ic_myaddr,
a345 1
	const u_int8_t *pmk;
d359 7
a365 2

	/* check that ANonce matches that of message 1 */
d370 2
a371 6
	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, NULL)) == NULL) {
		/* no PMK configured for this STA */
		return;
	}
	ieee80211_derive_ptk(ni->ni_rsnakms, pmk, ni->ni_macaddr,
d457 6
d508 1
a508 1
	if (info & EAPOL_KEY_INSTALL) {
d631 1
a631 1
	/* replay counter has already been verified by caller */
@


1.11
log
@do not increment is_rx_eapol_key twice for each frame.
fix a test on the mbuf length and one on the descriptor version.
remove redundant checking of GTK KDE length.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.10 2008/08/12 19:29:07 damien Exp $	*/
d52 1
d56 1
d59 1
d64 1
d69 1
d74 1
d153 1
d156 1
a156 1

d162 1
d165 1
d177 3
a179 1
		} else
d181 1
d200 1
d204 1
a204 1

d262 1
d330 1
d347 1
d351 1
a351 1

d586 1
d588 3
a590 1
		    ++ni->ni_key_count == 2) {
d604 1
d718 1
d733 1
d737 1
a737 1

d839 1
d841 3
a843 1
		    ++ni->ni_key_count == 2) {
d877 1
d881 1
a881 1

d933 1
d935 3
a937 1
		    ++ni->ni_key_count == 2) {
d955 1
d1055 1
@


1.10
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.9 2008/08/12 18:22:41 damien Exp $	*/
a99 2

	ic->ic_stats.is_rx_eapol_key++;
d113 1
a113 1
	if (m0->m_len < 4 + BE_READ_2(key->len))
d128 9
a136 9
	if ((ni->ni_rsnakms == IEEE80211_AKM_SHA256_8021X ||
	     ni->ni_rsnakms == IEEE80211_AKM_SHA256_PSK) &&
	    desc != EAPOL_KEY_DESC_V3)
		goto done;

	if ((ni->ni_rsncipher == IEEE80211_CIPHER_CCMP ||
	     ni->ni_rsngroupcipher == IEEE80211_CIPHER_CCMP) &&
	    desc != EAPOL_KEY_DESC_V2)
		goto done;
a511 5
		/* check that the GTK KDE is valid */
		if (gtk[1] < 4 + 2) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
d762 3
a764 3
	/* check that the GTK KDE is present and valid */
	if (gtk == NULL || gtk[1] < 4 + 2) {
		DPRINTF(("missing or invalid GTK KDE\n"));
a873 2
	info = BE_READ_2(key->info);
	keylen = ieee80211_cipher_keylen(ni->ni_rsngroupcipher);
d876 1
d883 2
@


1.9
log
@process IGTK KDEs in EAPOL-Key frames and install integrity group keys
if MFP was negotiated with the peer (not possible yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.8 2008/08/12 17:53:13 damien Exp $	*/
d127 6
a132 1
	if (desc != EAPOL_KEY_DESC_V1 && desc != EAPOL_KEY_DESC_V2)
@


1.8
log
@Change the way we process EAPOL-Key frames.
Free the mbuf in the ieee80211_eapol_key_input() function.
Do not assume the frame is contiguous, call m_pullup2() if it is not.
We need the frame to be contiguous to process KDEs efficiently in
EAPOL-Key frames (just like we process IEs in management frames).
However, there are drivers like upgt(4) that use m_devget() in the
RX path.  m_devget() can return fragmented mbuf chains.
Notice that we should do the same m_pullup2() for management frames.
This will be done later.
Remove the ic_recv_eapol callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.7 2008/08/12 16:14:05 damien Exp $	*/
d19 6
d174 1
a174 2
 * 4-Way Handshake Message 1 is sent by the authenticator to the supplicant
 * (see 8.5.3.1).
a193 2
	/* save authenticator's nonce (ANonce) */
	memcpy(ni->ni_nonce, key->nonce, EAPOL_KEY_NONCE_LEN);
d222 2
a223 5
	/* generate a new supplicant's nonce (SNonce) */
	arc4random_buf(ic->ic_nonce, EAPOL_KEY_NONCE_LEN);

	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, pmkid)) == NULL) {
d227 7
d235 1
a235 1
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, &tptk);
d247 1
a247 2
 * 4-Way Handshake Message 2 is sent by the supplicant to the authenticator
 * (see 8.5.3.2).
d315 1
a315 2
 * 4-Way Handshake Message 3 is sent by the authenticator to the supplicant
 * (see 8.5.3.3).
d324 1
a324 1
	const u_int8_t *rsnie1, *rsnie2, *gtk;
d379 1
a379 1
	rsnie1 = rsnie2 = gtk = NULL;
d401 4
d430 6
d503 1
d538 29
d588 1
a588 2
 * 4-Way Handshake Message 4 is sent by the supplicant to the authenticator
 * (see 8.5.3.4).
d702 1
a702 2
 * Group Key Handshake Message 1 is sent by the authenticator to the
 * supplicant (see 8.5.4.1).
d710 2
a711 3
	const u_int8_t *gtk;
	u_int16_t info;
	u_int8_t kid;
d741 1
a741 1
	gtk = NULL;
d754 4
d788 29
a816 4
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_AUTH_LEAVE);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		return;
d835 5
a839 1
	(void)ieee80211_send_group_msg2(ic, ni, k);
d842 3
d928 1
a928 2
 * Group Key Handshake Message 2 is sent by the supplicant to the
 * authenticator (see 8.5.4.2).
d997 1
a997 1
		DPRINTF(("key MIC failed\n"));
@


1.7
log
@get rid of the map_ptk()/map_gtk() functions, just inline them
which makes things easier to track.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.6 2008/08/12 16:05:15 damien Exp $	*/
d69 1
a69 1
ieee80211_recv_eapol(struct ieee80211com *ic, struct mbuf *m0,
d76 1
a79 2
	if (m0->m_len < sizeof(*eh) + sizeof(*key))
		return;
d83 1
a83 1
		return;
d86 10
d99 1
a99 1
		return;
d106 1
a106 1
		return;
d110 1
a110 1
		return;
d113 3
a115 2
	if (m0->m_len < sizeof(*key) + BE_READ_2(key->paylen))
		return;
d122 1
a122 1
		return;
d127 8
a134 1
		return;
d153 1
a153 1
			return;
d162 3
@


1.6
log
@simplify ieee80211_derive_ptk() prototype.
pass the AKMP so we can support other key derivation functions in the
future.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.5 2008/08/02 08:25:59 damien Exp $	*/
d302 1
d449 2
a450 2
		if (BE_READ_2(key->keylen) !=
		    ieee80211_cipher_keylen(ni->ni_rsncipher)) {
a453 1
		/* install the PTK */
d455 2
d458 6
a463 1
		ieee80211_map_ptk(&ni->ni_ptk, ni->ni_rsncipher, prsc, k);
a470 1
		u_int64_t rsc;
d479 2
a480 2
		if (gtk[1] - 6 !=
		    ieee80211_cipher_keylen(ni->ni_rsngroupcipher)) {
d484 1
a484 1
		/* install the GTK */
a485 1
		rsc = LE_READ_6(key->rsc);
d487 10
a496 2
		ieee80211_map_gtk(&gtk[8], ni->ni_rsngroupcipher, kid,
		    gtk[6] & (1 << 2), rsc, k);
d554 8
a562 2
		struct ieee80211_key *k = &ni->ni_pairwise_key;
		ieee80211_map_ptk(&ni->ni_ptk, ni->ni_rsncipher, 0, k);
a647 1
	u_int64_t rsc;
d650 1
d705 2
a706 1
	if (gtk[1] - 6 != ieee80211_cipher_keylen(ni->ni_rsngroupcipher))
d709 1
a709 1
	/* install the GTK */
a710 1
	rsc = LE_READ_6(key->rsc);
d712 9
a720 2
	ieee80211_map_gtk(&gtk[8], ni->ni_rsngroupcipher, kid,
	    gtk[6] & (1 << 2), rsc, k);
a751 2
	const u_int8_t *frm;
	u_int64_t rsc;
d789 11
d801 1
a801 2
	frm = (const u_int8_t *)&key[1];

a802 5
	kid = (info >> EAPOL_KEY_WPA_KID_SHIFT) & 3;
	rsc = LE_READ_6(key->rsc);
	k = &ic->ic_nw_keys[kid];
	ieee80211_map_gtk(frm, ni->ni_rsngroupcipher, kid,
	    info & EAPOL_KEY_WPA_TX, rsc, k);
@


1.5
log
@print the correct value in a debug message.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.4 2008/08/02 08:20:16 damien Exp $	*/
d207 2
a208 3
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ni->ni_macaddr,
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));
d250 2
a251 3
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ic->ic_myaddr,
	    ni->ni_macaddr, ni->ni_nonce, key->nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));
d323 2
a324 3
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ni->ni_macaddr,
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));
@


1.4
log
@Drop frames that are received unencrypted when WEP is on or when
WPA is on and RX protection for TA is on.
Keep track of the TX/RX protection for each node when WPA is on.

tested by djm@@ (ral+wpa), ckuethe@@ (ath-noenc) and krw@@ (wpi<->ral+wpa).
hints from bluhm@@
has been in snaps for a few days.

pointed out by bluhm@@ something like 1 year ago but we did not have
the right infrastructure to fix it properly at that time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.3 2008/07/27 14:21:15 damien Exp $	*/
d817 1
a817 1
		DPRINTF(("%s: unexpected in state: %d\n", ni->ni_rsn_state));
a863 2
	info = BE_READ_2(key->info);

d870 2
@


1.3
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_pae_input.c,v 1.2 2008/07/21 19:27:26 damien Exp $	*/
d464 1
d492 3
d496 1
d554 1
d838 1
@


1.2
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a24 1
#include <sys/endian.h>
a36 1
#include <netinet/ip.h>
d239 1
a239 2
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
d257 1
a257 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d317 1
a317 2
		IEEE80211_DPRINTF(("%s: ANonce does not match msg 1/4\n",
		    __func__));
d333 1
a333 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d343 1
a343 1
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
d395 1
a395 1
		IEEE80211_DPRINTF(("%s: missing RSN IE\n", __func__));
d400 1
a400 1
		IEEE80211_DPRINTF(("%s: GTK not encrypted\n", __func__));
d494 2
a495 2
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
d521 1
a521 2
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
d529 1
a529 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d551 1
a551 1
		IEEE80211_DPRINTF(("%s: marking port %s valid\n", __func__,
d640 1
a640 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d649 1
a649 1
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
d678 1
a678 2
		IEEE80211_DPRINTF(("%s: missing or invalid GTK KDE\n",
		    __func__));
d701 2
a702 2
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
d739 1
a739 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d748 1
a748 1
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
d780 2
a781 2
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
d811 1
a811 2
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
d820 1
a820 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d867 1
a867 1
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
d879 1
a879 2
			IEEE80211_DPRINTF(("%s: MIC failure report from "
			    "STA not using TKIP: %s\n", __func__,
@


1.1
log
@move processing of EAPOL frames away from ieee80211_{input,output}.c
@
text
@d1 2
d42 1
a64 16

/* unaligned big endian access */
#define BE_READ_2(p)						\
	((u_int16_t)(p)[0] << 8 | (u_int16_t)(p)[1])

#define BE_READ_8(p)						\
	((u_int64_t)(p)[0] << 56 | (u_int64_t)(p)[1] << 48 |	\
	 (u_int64_t)(p)[2] << 40 | (u_int64_t)(p)[3] << 32 |	\
	 (u_int64_t)(p)[4] << 24 | (u_int64_t)(p)[5] << 16 |	\
	 (u_int64_t)(p)[6] <<  8 | (u_int64_t)(p)[7])

/* unaligned little endian access */
#define LE_READ_6(p)						\
	((u_int64_t)(p)[5] << 40 | (u_int64_t)(p)[4] << 32 |	\
	 (u_int64_t)(p)[3] << 24 | (u_int64_t)(p)[2] << 16 |	\
	 (u_int64_t)(p)[1] <<  8 | (u_int64_t)(p)[0])
@

