head	1.77;
access;
symbols
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.64.0.2
	OPENBSD_5_9_BASE:1.64
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.47.0.4
	OPENBSD_5_6_BASE:1.47
	OPENBSD_5_5:1.46.0.12
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.8
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.6
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.46.0.4
	OPENBSD_5_2_BASE:1.46
	OPENBSD_5_1_BASE:1.46
	OPENBSD_5_1:1.46.0.2
	OPENBSD_5_0:1.45.0.4
	OPENBSD_5_0_BASE:1.45
	OPENBSD_4_9:1.45.0.2
	OPENBSD_4_9_BASE:1.45
	OPENBSD_4_8:1.44.0.2
	OPENBSD_4_8_BASE:1.44
	OPENBSD_4_7:1.41.0.2
	OPENBSD_4_7_BASE:1.41
	OPENBSD_4_6:1.40.0.4
	OPENBSD_4_6_BASE:1.40
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.9.0.2
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.2.0.2
	OPENBSD_3_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.77
date	2017.06.03.15.44.03;	author tb;	state Exp;
branches;
next	1.76;
commitid	Fy9gzTb9KEKQjy5d;

1.76
date	2017.06.02.15.31.26;	author stsp;	state Exp;
branches;
next	1.75;
commitid	Ud2FIqEh0ExyHqCE;

1.75
date	2017.05.30.10.50.33;	author stsp;	state Exp;
branches;
next	1.74;
commitid	wqD4ozJRoDb9ofwR;

1.74
date	2017.03.02.09.41.27;	author stsp;	state Exp;
branches;
next	1.73;
commitid	zHrxkRC3LDo7M0GH;

1.73
date	2017.03.01.19.28.48;	author stsp;	state Exp;
branches;
next	1.72;
commitid	ziqUM3IRerOy1q1r;

1.72
date	2017.02.07.15.07.14;	author stsp;	state Exp;
branches;
next	1.71;
commitid	gKNEp259c3MOTEXq;

1.71
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.70;
commitid	PETPfbQ5ZWdJqIYS;

1.70
date	2016.12.26.23.25.11;	author stsp;	state Exp;
branches;
next	1.69;
commitid	FmQXyzHPjc37lhXV;

1.69
date	2016.09.15.03.32.48;	author dlg;	state Exp;
branches;
next	1.68;
commitid	prdL2stxGjOBR6s3;

1.68
date	2016.07.20.15.40.27;	author stsp;	state Exp;
branches
	1.68.2.1;
next	1.67;
commitid	KNQyych1SveTbQn1;

1.67
date	2016.05.18.08.15.28;	author stsp;	state Exp;
branches;
next	1.66;
commitid	h4943tbngzO3CJ4g;

1.66
date	2016.04.27.11.58.10;	author stsp;	state Exp;
branches;
next	1.65;
commitid	2WbLmzkj7ZM3hH4a;

1.65
date	2016.04.12.14.33.27;	author mpi;	state Exp;
branches;
next	1.64;
commitid	0LA0xiKsLRo4rVjB;

1.64
date	2016.02.08.01.00.47;	author stsp;	state Exp;
branches
	1.64.2.1;
next	1.63;
commitid	t6UAoTbJMjqNPVER;

1.63
date	2016.02.05.16.07.57;	author stsp;	state Exp;
branches;
next	1.62;
commitid	xkYUdKYZXQrBH3Sl;

1.62
date	2016.02.04.16.23.40;	author stsp;	state Exp;
branches;
next	1.61;
commitid	CoUDEKOEoQ2LZ3mp;

1.61
date	2016.02.01.18.43.22;	author stsp;	state Exp;
branches;
next	1.60;
commitid	4NOoNc6ASRY2FA63;

1.60
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.59;
commitid	1npmDuWgN1zBR6BQ;

1.59
date	2016.01.07.23.22.31;	author stsp;	state Exp;
branches;
next	1.58;
commitid	fZfOIgRYw9oUaCc3;

1.58
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.57;
commitid	2QagMjdMhQhIaQgu;

1.57
date	2016.01.04.12.25.46;	author stsp;	state Exp;
branches;
next	1.56;
commitid	qxghNKrIQP4oLgDx;

1.56
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.55;
commitid	FuSD2mFDJWATHIDx;

1.55
date	2015.11.15.12.34.07;	author stsp;	state Exp;
branches;
next	1.54;
commitid	H9x7JLZ3OXXsR8Zh;

1.54
date	2015.11.15.11.14.17;	author stsp;	state Exp;
branches;
next	1.53;
commitid	fROBylLWPLvwXRar;

1.53
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.52;
commitid	YT6fyIEviv9qwbl6;

1.52
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.51;
commitid	ncpqEGjDtSFuLAgn;

1.51
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.50;
commitid	p4LJxGKbi0BU2cG6;

1.50
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.49;
commitid	PYnSnAqgemmk34E3;

1.49
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.48;
commitid	Z1vcFtHO8wRH0yRt;

1.48
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.47;
commitid	uzzBR7hz9ncd4O6G;

1.47
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.46;
commitid	B4dZSbxas1X1IpXI;

1.46
date	2012.01.18.14.35.56;	author stsp;	state Exp;
branches;
next	1.45;

1.45
date	2011.02.21.20.00.54;	author stsp;	state Exp;
branches;
next	1.44;

1.44
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2010.07.28.21.24.52;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.05.15.54.35;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.21.18.09.31;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2009.03.26.20.34.54;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.14.15.51.43;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.12.19.50.39;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.12.18.37.23;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.12.17.53.13;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.12.16.14.05;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2008.07.26.12.56.06;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.08.17.31.24;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.28.11.24.06;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.04.20.32.43;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.16.13.29.11;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.25.19.24.27;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.29.17.56.32;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.19.12.38.16;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.13.13.48.45;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.04.22.34.14;	author naddy;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.64.2.1
date	2017.03.01.20.57.29;	author benno;	state Exp;
branches;
next	1.64.2.2;
commitid	Yy9A53bTb4WnX3us;

1.64.2.2
date	2017.03.02.09.48.37;	author stsp;	state Exp;
branches;
next	;
commitid	DFYEvYKrbVsJvUkv;

1.68.2.1
date	2017.03.01.20.57.51;	author benno;	state Exp;
branches;
next	1.68.2.2;
commitid	ChXblF78aIW5HGQF;

1.68.2.2
date	2017.03.02.09.47.32;	author stsp;	state Exp;
branches;
next	;
commitid	pmRUfXMoQKocNmK3;


desc
@@


1.77
log
@Add a few sizes to free().

Input, help & ok stsp
@
text
@/*	$OpenBSD: ieee80211_proto.c,v 1.76 2017/06/02 15:31:26 stsp Exp $	*/
/*	$NetBSD: ieee80211_proto.c,v 1.8 2004/04/30 23:58:20 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * Copyright (c) 2008, 2009 Damien Bergamini
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IEEE 802.11 protocol support.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_llc.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

const char * const ieee80211_mgt_subtype_name[] = {
	"assoc_req",	"assoc_resp",	"reassoc_req",	"reassoc_resp",
	"probe_req",	"probe_resp",	"reserved#6",	"reserved#7",
	"beacon",	"atim",		"disassoc",	"auth",
	"deauth",	"action",	"action_noack",	"reserved#15"
};
const char * const ieee80211_state_name[IEEE80211_S_MAX] = {
	"INIT",		/* IEEE80211_S_INIT */
	"SCAN",		/* IEEE80211_S_SCAN */
	"AUTH",		/* IEEE80211_S_AUTH */
	"ASSOC",	/* IEEE80211_S_ASSOC */
	"RUN"		/* IEEE80211_S_RUN */
};
const char * const ieee80211_phymode_name[] = {
	"auto",		/* IEEE80211_MODE_AUTO */
	"11a",		/* IEEE80211_MODE_11A */
	"11b",		/* IEEE80211_MODE_11B */
	"11g",		/* IEEE80211_MODE_11G */
	"11n",		/* IEEE80211_MODE_11N */
};

void ieee80211_set_beacon_miss_threshold(struct ieee80211com *);
int ieee80211_newstate(struct ieee80211com *, enum ieee80211_state, int);

void
ieee80211_proto_attach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	mq_init(&ic->ic_mgtq, IFQ_MAXLEN, IPL_NET);
	mq_init(&ic->ic_pwrsaveq, IFQ_MAXLEN, IPL_NET);

	ifp->if_hdrlen = sizeof(struct ieee80211_frame);

	ic->ic_rtsthreshold = IEEE80211_RTS_DEFAULT;
	ic->ic_fragthreshold = 2346;		/* XXX not used yet */
	ic->ic_fixed_rate = -1;			/* no fixed rate */
	ic->ic_fixed_mcs = -1;			/* no fixed mcs */
	ic->ic_protmode = IEEE80211_PROT_CTSONLY;

	/* protocol state change handler */
	ic->ic_newstate = ieee80211_newstate;

	/* initialize management frame handlers */
	ic->ic_recv_mgmt = ieee80211_recv_mgmt;
	ic->ic_send_mgmt = ieee80211_send_mgmt;
}

void
ieee80211_proto_detach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	mq_purge(&ic->ic_mgtq);
	mq_purge(&ic->ic_pwrsaveq);
}

void
ieee80211_print_essid(const u_int8_t *essid, int len)
{
	int i;
	const u_int8_t *p;

	if (len > IEEE80211_NWID_LEN)
		len = IEEE80211_NWID_LEN;
	/* determine printable or not */
	for (i = 0, p = essid; i < len; i++, p++) {
		if (*p < ' ' || *p > 0x7e)
			break;
	}
	if (i == len) {
		printf("\"");
		for (i = 0, p = essid; i < len; i++, p++)
			printf("%c", *p);
		printf("\"");
	} else {
		printf("0x");
		for (i = 0, p = essid; i < len; i++, p++)
			printf("%02x", *p);
	}
}

#ifdef IEEE80211_DEBUG
void
ieee80211_dump_pkt(const u_int8_t *buf, int len, int rate, int rssi)
{
	struct ieee80211_frame *wh;
	int i;

	wh = (struct ieee80211_frame *)buf;
	switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_NODS:
		printf("NODS %s", ether_sprintf(wh->i_addr2));
		printf("->%s", ether_sprintf(wh->i_addr1));
		printf("(%s)", ether_sprintf(wh->i_addr3));
		break;
	case IEEE80211_FC1_DIR_TODS:
		printf("TODS %s", ether_sprintf(wh->i_addr2));
		printf("->%s", ether_sprintf(wh->i_addr3));
		printf("(%s)", ether_sprintf(wh->i_addr1));
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		printf("FRDS %s", ether_sprintf(wh->i_addr3));
		printf("->%s", ether_sprintf(wh->i_addr1));
		printf("(%s)", ether_sprintf(wh->i_addr2));
		break;
	case IEEE80211_FC1_DIR_DSTODS:
		printf("DSDS %s", ether_sprintf((u_int8_t *)&wh[1]));
		printf("->%s", ether_sprintf(wh->i_addr3));
		printf("(%s", ether_sprintf(wh->i_addr2));
		printf("->%s)", ether_sprintf(wh->i_addr1));
		break;
	}
	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_DATA:
		printf(" data");
		break;
	case IEEE80211_FC0_TYPE_MGT:
		printf(" %s", ieee80211_mgt_subtype_name[
		    (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK)
		    >> IEEE80211_FC0_SUBTYPE_SHIFT]);
		break;
	default:
		printf(" type#%d", wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK);
		break;
	}
	if (wh->i_fc[1] & IEEE80211_FC1_WEP)
		printf(" WEP");
	if (rate >= 0)
		printf(" %d%sM", rate / 2, (rate & 1) ? ".5" : "");
	if (rssi >= 0)
		printf(" +%d", rssi);
	printf("\n");
	if (len > 0) {
		for (i = 0; i < len; i++) {
			if ((i & 1) == 0)
				printf(" ");
			printf("%02x", buf[i]);
		}
		printf("\n");
	}
}
#endif

int
ieee80211_fix_rate(struct ieee80211com *ic, struct ieee80211_node *ni,
    int flags)
{
#define	RV(v)	((v) & IEEE80211_RATE_VAL)
	int i, j, ignore, error;
	int okrate, badrate, fixedrate;
	const struct ieee80211_rateset *srs;
	struct ieee80211_rateset *nrs;
	u_int8_t r;

	/*
	 * If the fixed rate check was requested but no fixed rate has been
	 * defined then just remove the check.
	 */
	if ((flags & IEEE80211_F_DOFRATE) && ic->ic_fixed_rate == -1)
		flags &= ~IEEE80211_F_DOFRATE;

	error = 0;
	okrate = badrate = fixedrate = 0;
	srs = &ic->ic_sup_rates[ieee80211_chan2mode(ic, ni->ni_chan)];
	nrs = &ni->ni_rates;
	for (i = 0; i < nrs->rs_nrates; ) {
		ignore = 0;
		if (flags & IEEE80211_F_DOSORT) {
			/*
			 * Sort rates.
			 */
			for (j = i + 1; j < nrs->rs_nrates; j++) {
				if (RV(nrs->rs_rates[i]) >
				    RV(nrs->rs_rates[j])) {
					r = nrs->rs_rates[i];
					nrs->rs_rates[i] = nrs->rs_rates[j];
					nrs->rs_rates[j] = r;
				}
			}
		}
		r = nrs->rs_rates[i] & IEEE80211_RATE_VAL;
		badrate = r;
		if (flags & IEEE80211_F_DOFRATE) {
			/*
			 * Check fixed rate is included.
			 */
			if (r == RV(srs->rs_rates[ic->ic_fixed_rate]))
				fixedrate = r;
		}
		if (flags & IEEE80211_F_DONEGO) {
			/*
			 * Check against supported rates.
			 */
			for (j = 0; j < srs->rs_nrates; j++) {
				if (r == RV(srs->rs_rates[j])) {
					/*
					 * Overwrite with the supported rate
					 * value so any basic rate bit is set.
					 * This insures that response we send
					 * to stations have the necessary basic
					 * rate bit set.
					 */
					nrs->rs_rates[i] = srs->rs_rates[j];
					break;
				}
			}
			if (j == srs->rs_nrates) {
				/*
				 * A rate in the node's rate set is not
				 * supported.  If this is a basic rate and we
				 * are operating as an AP then this is an error.
				 * Otherwise we just discard/ignore the rate.
				 * Note that this is important for 11b stations
				 * when they want to associate with an 11g AP.
				 */
#ifndef IEEE80211_STA_ONLY
				if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
				    (nrs->rs_rates[i] & IEEE80211_RATE_BASIC))
					error++;
#endif
				ignore++;
			}
		}
		if (flags & IEEE80211_F_DODEL) {
			/*
			 * Delete unacceptable rates.
			 */
			if (ignore) {
				nrs->rs_nrates--;
				for (j = i; j < nrs->rs_nrates; j++)
					nrs->rs_rates[j] = nrs->rs_rates[j + 1];
				nrs->rs_rates[j] = 0;
				continue;
			}
		}
		if (!ignore)
			okrate = nrs->rs_rates[i];
		i++;
	}
	if (okrate == 0 || error != 0 ||
	    ((flags & IEEE80211_F_DOFRATE) && fixedrate == 0))
		return badrate | IEEE80211_RATE_BASIC;
	else
		return RV(okrate);
#undef RV
}

/*
 * Reset 11g-related state.
 */
void
ieee80211_reset_erp(struct ieee80211com *ic)
{
	ic->ic_flags &= ~IEEE80211_F_USEPROT;

	ieee80211_set_shortslottime(ic,
	    ic->ic_curmode == IEEE80211_MODE_11A ||
	    (ic->ic_curmode == IEEE80211_MODE_11N &&
	    IEEE80211_IS_CHAN_5GHZ(ic->ic_ibss_chan))
#ifndef IEEE80211_STA_ONLY
	    ||
	    ((ic->ic_curmode == IEEE80211_MODE_11G ||
	    (ic->ic_curmode == IEEE80211_MODE_11N &&
	    IEEE80211_IS_CHAN_2GHZ(ic->ic_ibss_chan))) &&
	     ic->ic_opmode == IEEE80211_M_HOSTAP &&
	     (ic->ic_caps & IEEE80211_C_SHSLOT))
#endif
	);

	if (ic->ic_curmode == IEEE80211_MODE_11A ||
	    (ic->ic_curmode == IEEE80211_MODE_11N &&
	    IEEE80211_IS_CHAN_5GHZ(ic->ic_ibss_chan)) ||
	    (ic->ic_caps & IEEE80211_C_SHPREAMBLE))
		ic->ic_flags |= IEEE80211_F_SHPREAMBLE;
	else
		ic->ic_flags &= ~IEEE80211_F_SHPREAMBLE;
}

/*
 * Set the short slot time state and notify the driver.
 */
void
ieee80211_set_shortslottime(struct ieee80211com *ic, int on)
{
	if (on)
		ic->ic_flags |= IEEE80211_F_SHSLOT;
	else
		ic->ic_flags &= ~IEEE80211_F_SHSLOT;

	/* notify the driver */
	if (ic->ic_updateslot != NULL)
		ic->ic_updateslot(ic);
}

/*
 * This function is called by the 802.1X PACP machine (via an ioctl) when
 * the transmit key machine (4-Way Handshake for 802.11) should run.
 */
int
ieee80211_keyrun(struct ieee80211com *ic, u_int8_t *macaddr)
{
	struct ieee80211_node *ni = ic->ic_bss;
#ifndef IEEE80211_STA_ONLY
	struct ieee80211_pmk *pmk;
#endif

	/* STA must be associated or AP must be ready */
	if (ic->ic_state != IEEE80211_S_RUN ||
	    !(ic->ic_flags & IEEE80211_F_RSNON))
		return ENETDOWN;

	ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_STA)
#endif
		return 0;	/* supplicant only, do nothing */

#ifndef IEEE80211_STA_ONLY
	/* find the STA with which we must start the key exchange */
	if ((ni = ieee80211_find_node(ic, macaddr)) == NULL) {
		DPRINTF(("no node found for %s\n", ether_sprintf(macaddr)));
		return EINVAL;
	}
	/* check that the STA is in the correct state */
	if (ni->ni_state != IEEE80211_STA_ASSOC ||
	    ni->ni_rsn_state != RSNA_AUTHENTICATION_2) {
		DPRINTF(("unexpected in state %d\n", ni->ni_rsn_state));
		return EINVAL;
	}
	ni->ni_rsn_state = RSNA_INITPMK;

	/* make sure a PMK is available for this STA, otherwise deauth it */
	if ((pmk = ieee80211_pmksa_find(ic, ni, NULL)) == NULL) {
		DPRINTF(("no PMK available for %s\n", ether_sprintf(macaddr)));
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_AUTH_LEAVE);
		ieee80211_node_leave(ic, ni);
		return EINVAL;
	}
	memcpy(ni->ni_pmk, pmk->pmk_key, IEEE80211_PMK_LEN);
	memcpy(ni->ni_pmkid, pmk->pmk_pmkid, IEEE80211_PMKID_LEN);
	ni->ni_flags |= IEEE80211_NODE_PMK;

	/* initiate key exchange (4-Way Handshake) with STA */
	return ieee80211_send_4way_msg1(ic, ni);
#endif	/* IEEE80211_STA_ONLY */
}

#ifndef IEEE80211_STA_ONLY
/*
 * Initiate a group key handshake with a node.
 */
static void
ieee80211_node_gtk_rekey(void *arg, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = arg;

	if (ni->ni_state != IEEE80211_STA_ASSOC ||
	    ni->ni_rsn_gstate != RSNA_IDLE)
		return;

	/* initiate a group key handshake with STA */
	ni->ni_flags |= IEEE80211_NODE_REKEY;
	if (ieee80211_send_group_msg1(ic, ni) != 0)
		ni->ni_flags &= ~IEEE80211_NODE_REKEY;
}

/*
 * This function is called in HostAP mode when the group key needs to be
 * changed.
 */
void
ieee80211_setkeys(struct ieee80211com *ic)
{
	struct ieee80211_key *k;
	u_int8_t kid;

	/* Swap(GM, GN) */
	kid = (ic->ic_def_txkey == 1) ? 2 : 1;
	k = &ic->ic_nw_keys[kid];
	memset(k, 0, sizeof(*k));
	k->k_id = kid;
	k->k_cipher = ic->ic_bss->ni_rsngroupcipher;
	k->k_flags = IEEE80211_KEY_GROUP | IEEE80211_KEY_TX;
	k->k_len = ieee80211_cipher_keylen(k->k_cipher);
	arc4random_buf(k->k_key, k->k_len);

	if (ic->ic_caps & IEEE80211_C_MFP) {
		/* Swap(GM_igtk, GN_igtk) */
		kid = (ic->ic_igtk_kid == 4) ? 5 : 4;
		k = &ic->ic_nw_keys[kid];
		memset(k, 0, sizeof(*k));
		k->k_id = kid;
		k->k_cipher = ic->ic_bss->ni_rsngroupmgmtcipher;
		k->k_flags = IEEE80211_KEY_IGTK | IEEE80211_KEY_TX;
		k->k_len = 16;
		arc4random_buf(k->k_key, k->k_len);
	}

	ieee80211_iterate_nodes(ic, ieee80211_node_gtk_rekey, ic);
}

/*
 * The group key handshake has been completed with all associated stations.
 */
void
ieee80211_setkeysdone(struct ieee80211com *ic)
{
	u_int8_t kid;

	/* install GTK */
	kid = (ic->ic_def_txkey == 1) ? 2 : 1;
	if ((*ic->ic_set_key)(ic, ic->ic_bss, &ic->ic_nw_keys[kid]) == 0)
		ic->ic_def_txkey = kid;

	if (ic->ic_caps & IEEE80211_C_MFP) {
		/* install IGTK */
		kid = (ic->ic_igtk_kid == 4) ? 5 : 4;
		if ((*ic->ic_set_key)(ic, ic->ic_bss,
		    &ic->ic_nw_keys[kid]) == 0)
			ic->ic_igtk_kid = kid;
	}
}

/*
 * Group key lifetime has expired, update it.
 */
void
ieee80211_gtk_rekey_timeout(void *arg)
{
	struct ieee80211com *ic = arg;
	int s;

	s = splnet();
	ieee80211_setkeys(ic);
	splx(s);

	/* re-schedule a GTK rekeying after 3600s */
	timeout_add_sec(&ic->ic_rsn_timeout, 3600);
}

void
ieee80211_sa_query_timeout(void *arg)
{
	struct ieee80211_node *ni = arg;
	struct ieee80211com *ic = ni->ni_ic;
	int s;

	s = splnet();
	if (++ni->ni_sa_query_count >= 3) {
		ni->ni_flags &= ~IEEE80211_NODE_SA_QUERY;
		ni->ni_flags |= IEEE80211_NODE_SA_QUERY_FAILED;
	} else	/* retry SA Query Request */
		ieee80211_sa_query_request(ic, ni);
	splx(s);
}

/*
 * Request that a SA Query Request frame be sent to a specified peer STA
 * to which the STA is associated.
 */
void
ieee80211_sa_query_request(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	/* MLME-SAQuery.request */

	if (!(ni->ni_flags & IEEE80211_NODE_SA_QUERY)) {
		ni->ni_flags |= IEEE80211_NODE_SA_QUERY;
		ni->ni_flags &= ~IEEE80211_NODE_SA_QUERY_FAILED;
		ni->ni_sa_query_count = 0;
	}
	/* generate new Transaction Identifier */
	ni->ni_sa_query_trid++;

	/* send SA Query Request */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_SA_QUERY,
	    IEEE80211_ACTION_SA_QUERY_REQ, 0);
	timeout_add_msec(&ni->ni_sa_query_to, 10);
}
#endif	/* IEEE80211_STA_ONLY */

void
ieee80211_ht_negotiate(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	int i;

	ni->ni_flags &= ~IEEE80211_NODE_HT; 

	/* Check if we support HT. */
	if ((ic->ic_modecaps & (1 << IEEE80211_MODE_11N)) == 0)
		return;

	/* Check if HT support has been explicitly disabled. */
	if ((ic->ic_flags & IEEE80211_F_HTON) == 0)
		return;

	/* 
	 * Check if the peer supports HT.
	 * Require at least one of the mandatory MCS.
	 * MCS 0-7 are mandatory but some APs have particular MCS disabled.
	 */
	if ((ni->ni_rxmcs[0] & 0xff) == 0) {
		ic->ic_stats.is_ht_nego_no_mandatory_mcs++;
		return;
	}

	if (ic->ic_opmode == IEEE80211_M_STA) {
		/* We must support the AP's basic MCS set. */
		for (i = 0; i < IEEE80211_HT_NUM_MCS; i++) {
			if (isset(ni->ni_basic_mcs, i) &&
			    !isset(ic->ic_sup_mcs, i)) {
				ic->ic_stats.is_ht_nego_no_basic_mcs++;
				return;
			}
		}
	}

	/* 
	 * Don't allow group cipher (includes WEP) or TKIP
	 * for pairwise encryption (see 802.11-2012 11.1.6).
	 */
	if (ic->ic_flags & IEEE80211_F_WEPON) {
		ic->ic_stats.is_ht_nego_bad_crypto++;
		return;
	}
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ni->ni_rsnciphers & IEEE80211_CIPHER_USEGROUP ||
	    ni->ni_rsnciphers & IEEE80211_CIPHER_TKIP)) {
		ic->ic_stats.is_ht_nego_bad_crypto++;
		return;
	}

	ni->ni_flags |= IEEE80211_NODE_HT; 
}

void
ieee80211_tx_ba_timeout(void *arg)
{
	struct ieee80211_tx_ba *ba = arg;
	struct ieee80211_node *ni = ba->ba_ni;
	struct ieee80211com *ic = ni->ni_ic;
	u_int8_t tid;
	int s;

	ic->ic_stats.is_ht_tx_ba_timeout++;

	s = splnet();
	if (ba->ba_state == IEEE80211_BA_REQUESTED) {
		/* MLME-ADDBA.confirm(TIMEOUT) */
		ba->ba_state = IEEE80211_BA_INIT;

	} else if (ba->ba_state == IEEE80211_BA_AGREED) {
		/* Block Ack inactivity timeout */
		tid = ((caddr_t)ba - (caddr_t)ni->ni_tx_ba) / sizeof(*ba);
		ieee80211_delba_request(ic, ni, IEEE80211_REASON_TIMEOUT,
		    1, tid);
	}
	splx(s);
}

void
ieee80211_rx_ba_timeout(void *arg)
{
	struct ieee80211_rx_ba *ba = arg;
	struct ieee80211_node *ni = ba->ba_ni;
	struct ieee80211com *ic = ni->ni_ic;
	u_int8_t tid;
	int s;

	ic->ic_stats.is_ht_rx_ba_timeout++;

	s = splnet();

	/* Block Ack inactivity timeout */
	tid = ((caddr_t)ba - (caddr_t)ni->ni_rx_ba) / sizeof(*ba);
	ieee80211_delba_request(ic, ni, IEEE80211_REASON_TIMEOUT, 0, tid);

	splx(s);
}

/*
 * Request initiation of Block Ack with the specified peer.
 */
int
ieee80211_addba_request(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t ssn, u_int8_t tid)
{
	struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];

	/* MLME-ADDBA.request */

	/* setup Block Ack */
	ba->ba_state = IEEE80211_BA_REQUESTED;
	ba->ba_token = ic->ic_dialog_token++;
	ba->ba_timeout_val = 0;
	timeout_set(&ba->ba_to, ieee80211_tx_ba_timeout, ba);
	ba->ba_winsize = IEEE80211_BA_MAX_WINSZ;
	ba->ba_winstart = ssn;
	ba->ba_winend = (ba->ba_winstart + ba->ba_winsize - 1) & 0xfff;
	ba->ba_params =
	    (ba->ba_winsize << IEEE80211_ADDBA_BUFSZ_SHIFT) |
	    (tid << IEEE80211_ADDBA_TID_SHIFT) | IEEE80211_ADDBA_AMSDU;
	if ((ic->ic_htcaps & IEEE80211_HTCAP_DELAYEDBA) == 0)
		/* immediate BA */
		ba->ba_params |= IEEE80211_ADDBA_BA_POLICY;

	timeout_add_sec(&ba->ba_to, 1);	/* dot11ADDBAResponseTimeout */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
	    IEEE80211_ACTION_ADDBA_REQ, tid);
	return 0;
}

/*
 * Request the deletion of Block Ack with a peer.
 */
void
ieee80211_delba_request(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t reason, u_int8_t dir, u_int8_t tid)
{
	/* MLME-DELBA.request */

	/* transmit a DELBA frame */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
	    IEEE80211_ACTION_DELBA, reason << 16 | dir << 8 | tid);
	if (dir) {
		/* MLME-DELBA.confirm(Originator) */
		struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];

		if (ic->ic_ampdu_tx_stop != NULL)
			ic->ic_ampdu_tx_stop(ic, ni, tid);

		ba->ba_state = IEEE80211_BA_INIT;
		/* stop Block Ack inactivity timer */
		timeout_del(&ba->ba_to);
	} else {
		/* MLME-DELBA.confirm(Recipient) */
		struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
		int i;

		if (ic->ic_ampdu_rx_stop != NULL)
			ic->ic_ampdu_rx_stop(ic, ni, tid);

		ba->ba_state = IEEE80211_BA_INIT;
		/* stop Block Ack inactivity timer */
		timeout_del(&ba->ba_to);
		timeout_del(&ba->ba_gap_to);

		if (ba->ba_buf != NULL) {
			/* free all MSDUs stored in reordering buffer */
			for (i = 0; i < IEEE80211_BA_MAX_WINSZ; i++)
				m_freem(ba->ba_buf[i].m);
			/* free reordering buffer */
			free(ba->ba_buf, M_DEVBUF,
			    IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf));
			ba->ba_buf = NULL;
		}
	}
}

void
ieee80211_auth_open(struct ieee80211com *ic, const struct ieee80211_frame *wh,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, u_int16_t seq,
    u_int16_t status)
{
	struct ifnet *ifp = &ic->ic_if;
	switch (ic->ic_opmode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		if (ic->ic_state != IEEE80211_S_RUN ||
		    seq != IEEE80211_AUTH_OPEN_REQUEST) {
			DPRINTF(("discard auth from %s; state %u, seq %u\n",
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		ieee80211_new_state(ic, IEEE80211_S_AUTH,
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);

		/* In IBSS mode no (re)association frames are sent. */
		if (ic->ic_flags & IEEE80211_F_RSNON)
			ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
		break;

	case IEEE80211_M_AHDEMO:
		/* should not come here */
		break;

	case IEEE80211_M_HOSTAP:
		if (ic->ic_state != IEEE80211_S_RUN ||
		    seq != IEEE80211_AUTH_OPEN_REQUEST) {
			DPRINTF(("discard auth from %s; state %u, seq %u\n",
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		if (ni == ic->ic_bss) {
			ni = ieee80211_find_node(ic, wh->i_addr2);
			if (ni == NULL)
				ni = ieee80211_alloc_node(ic, wh->i_addr2);
			if (ni == NULL) {
				return;
			}
			IEEE80211_ADDR_COPY(ni->ni_bssid, ic->ic_bss->ni_bssid);
			ni->ni_rssi = rxi->rxi_rssi;
			ni->ni_rstamp = rxi->rxi_tstamp;
			ni->ni_chan = ic->ic_bss->ni_chan;
		}
		IEEE80211_SEND_MGMT(ic, ni,
			IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s %s authenticated (open)\n",
			    ifp->if_xname,
			    ether_sprintf((u_int8_t *)ni->ni_macaddr),
			    ni->ni_state != IEEE80211_STA_CACHE ?
			    "newly" : "already");
		ieee80211_node_newstate(ni, IEEE80211_STA_AUTH);
		break;
#endif	/* IEEE80211_STA_ONLY */

	case IEEE80211_M_STA:
		if (ic->ic_state != IEEE80211_S_AUTH ||
		    seq != IEEE80211_AUTH_OPEN_RESPONSE) {
			ic->ic_stats.is_rx_bad_auth++;
			DPRINTF(("discard auth from %s; state %u, seq %u\n",
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			return;
		}
		if (ic->ic_flags & IEEE80211_F_RSNON) {
			/* XXX not here! */
			ic->ic_bss->ni_flags &= ~IEEE80211_NODE_TXRXPROT;
			ic->ic_bss->ni_port_valid = 0;
			ic->ic_bss->ni_replaycnt_ok = 0;
			(*ic->ic_delete_key)(ic, ic->ic_bss,
			    &ic->ic_bss->ni_pairwise_key);
		}
		if (status != 0) {
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: open authentication failed "
				    "(reason %d) for %s\n", ifp->if_xname,
				    status,
				    ether_sprintf((u_int8_t *)wh->i_addr3));
			if (ni != ic->ic_bss)
				ni->ni_fails++;
			ic->ic_stats.is_rx_auth_fail++;
			return;
		}
		ieee80211_new_state(ic, IEEE80211_S_ASSOC,
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
		break;
	default:
		break;
	}
}

void
ieee80211_set_beacon_miss_threshold(struct ieee80211com *ic)
{
	struct ifnet *ifp = &ic->ic_if;

	/* 
	 * Scale the missed beacon counter threshold to the AP's actual
	 * beacon interval. Give the AP at least 700 ms to time out and
	 * round up to ensure that at least one beacon may be missed.
	 */
	int btimeout = MIN(7 * ic->ic_bss->ni_intval, 700);
	btimeout = MAX(btimeout, 2 * ic->ic_bss->ni_intval);
	if (ic->ic_bss->ni_intval > 0) /* don't crash if interval is bogus */
		ic->ic_bmissthres = btimeout / ic->ic_bss->ni_intval;

	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: missed beacon threshold set to %d beacons, "
		    "beacon interval is %u TU\n", ifp->if_xname,
		    ic->ic_bmissthres, ic->ic_bss->ni_intval);
}

int
ieee80211_newstate(struct ieee80211com *ic, enum ieee80211_state nstate,
    int mgt)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_node *ni;
	enum ieee80211_state ostate;
	u_int rate;
#ifndef IEEE80211_STA_ONLY
	int s;
#endif

	ostate = ic->ic_state;
	DPRINTF(("%s -> %s\n", ieee80211_state_name[ostate],
	    ieee80211_state_name[nstate]));
	ic->ic_state = nstate;			/* state transition */
	ni = ic->ic_bss;			/* NB: no reference held */
	ieee80211_set_link_state(ic, LINK_STATE_DOWN);
	switch (nstate) {
	case IEEE80211_S_INIT:
		/*
		 * If mgt = -1, driver is already partway down, so do
		 * not send management frames.
		 */
		switch (ostate) {
		case IEEE80211_S_INIT:
			break;
		case IEEE80211_S_RUN:
			if (mgt == -1)
				goto justcleanup;
			switch (ic->ic_opmode) {
			case IEEE80211_M_STA:
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DISASSOC,
				    IEEE80211_REASON_ASSOC_LEAVE);
				break;
#ifndef IEEE80211_STA_ONLY
			case IEEE80211_M_HOSTAP:
				s = splnet();
				RBT_FOREACH(ni, ieee80211_tree, &ic->ic_tree) {
					if (ni->ni_state != IEEE80211_STA_ASSOC)
						continue;
					IEEE80211_SEND_MGMT(ic, ni,
					    IEEE80211_FC0_SUBTYPE_DISASSOC,
					    IEEE80211_REASON_ASSOC_LEAVE);
				}
				splx(s);
				break;
#endif
			default:
				break;
			}
			/* FALLTHROUGH */
		case IEEE80211_S_ASSOC:
			if (mgt == -1)
				goto justcleanup;
			switch (ic->ic_opmode) {
			case IEEE80211_M_STA:
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DEAUTH,
				    IEEE80211_REASON_AUTH_LEAVE);
				break;
#ifndef IEEE80211_STA_ONLY
			case IEEE80211_M_HOSTAP:
				s = splnet();
				RBT_FOREACH(ni, ieee80211_tree, &ic->ic_tree) {
					IEEE80211_SEND_MGMT(ic, ni,
					    IEEE80211_FC0_SUBTYPE_DEAUTH,
					    IEEE80211_REASON_AUTH_LEAVE);
				}
				splx(s);
				break;
#endif
			default:
				break;
			}
			/* FALLTHROUGH */
		case IEEE80211_S_AUTH:
		case IEEE80211_S_SCAN:
justcleanup:
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP)
				timeout_del(&ic->ic_rsn_timeout);
#endif
			ic->ic_mgt_timer = 0;
			mq_purge(&ic->ic_mgtq);
			mq_purge(&ic->ic_pwrsaveq);
			ieee80211_free_allnodes(ic);
			break;
		}
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
		break;
	case IEEE80211_S_SCAN:
		ic->ic_flags &= ~IEEE80211_F_SIBSS;
		/* initialize bss for probe request */
		IEEE80211_ADDR_COPY(ni->ni_macaddr, etherbroadcastaddr);
		IEEE80211_ADDR_COPY(ni->ni_bssid, etherbroadcastaddr);
		ni->ni_rates = ic->ic_sup_rates[
			ieee80211_chan2mode(ic, ni->ni_chan)];
		ni->ni_associd = 0;
		ni->ni_rstamp = 0;
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
		switch (ostate) {
		case IEEE80211_S_INIT:
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
			    ic->ic_des_chan != IEEE80211_CHAN_ANYC) {
				/*
				 * AP operation and we already have a channel;
				 * bypass the scan and startup immediately.
				 */
				ieee80211_create_ibss(ic, ic->ic_des_chan);
			} else
#endif
				ieee80211_begin_scan(ifp);
			break;
		case IEEE80211_S_SCAN:
			/* scan next */
			if (ic->ic_flags & IEEE80211_F_ASCAN) {
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_PROBE_REQ, 0);
			}
			break;
		case IEEE80211_S_RUN:
			/* beacon miss */
			if (ifp->if_flags & IFF_DEBUG) {
				/* XXX bssid clobbered above */
				printf("%s: no recent beacons from %s;"
				    " rescanning\n", ifp->if_xname,
				    ether_sprintf(ic->ic_bss->ni_bssid));
			}
			ieee80211_free_allnodes(ic);
			/* FALLTHROUGH */
		case IEEE80211_S_AUTH:
		case IEEE80211_S_ASSOC:
			/* timeout restart scan */
			ni = ieee80211_find_node(ic, ic->ic_bss->ni_macaddr);
			if (ni != NULL)
				ni->ni_fails++;
			ieee80211_begin_scan(ifp);
			break;
		}
		break;
	case IEEE80211_S_AUTH:
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
		switch (ostate) {
		case IEEE80211_S_INIT:
			DPRINTF(("invalid transition\n"));
			break;
		case IEEE80211_S_SCAN:
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_AUTH, 1);
			break;
		case IEEE80211_S_AUTH:
		case IEEE80211_S_ASSOC:
			switch (mgt) {
			case IEEE80211_FC0_SUBTYPE_AUTH:
				/* ??? */
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_AUTH, 2);
				break;
			case IEEE80211_FC0_SUBTYPE_DEAUTH:
				/* ignore and retry scan on timeout */
				break;
			}
			break;
		case IEEE80211_S_RUN:
			switch (mgt) {
			case IEEE80211_FC0_SUBTYPE_AUTH:
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_AUTH, 2);
				ic->ic_state = ostate;	/* stay RUN */
				break;
			case IEEE80211_FC0_SUBTYPE_DEAUTH:
				/* try to reauth */
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_AUTH, 1);
				break;
			}
			break;
		}
		break;
	case IEEE80211_S_ASSOC:
		switch (ostate) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_SCAN:
		case IEEE80211_S_ASSOC:
			DPRINTF(("invalid transition\n"));
			break;
		case IEEE80211_S_AUTH:
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_ASSOC_REQ, 0);
			break;
		case IEEE80211_S_RUN:
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_ASSOC_REQ, 1);
			break;
		}
		break;
	case IEEE80211_S_RUN:
		switch (ostate) {
		case IEEE80211_S_INIT:
		case IEEE80211_S_AUTH:
		case IEEE80211_S_RUN:
			DPRINTF(("invalid transition\n"));
			break;
		case IEEE80211_S_SCAN:		/* adhoc/hostap mode */
		case IEEE80211_S_ASSOC:		/* infra mode */
			if (ni->ni_txrate >= ni->ni_rates.rs_nrates)
				panic("%s: bogus xmit rate %u setup",
				    __func__, ni->ni_txrate);
			if (ifp->if_flags & IFF_DEBUG) {
				printf("%s: %s with %s ssid ",
				    ifp->if_xname,
				    ic->ic_opmode == IEEE80211_M_STA ?
				    "associated" : "synchronized",
				    ether_sprintf(ni->ni_bssid));
				ieee80211_print_essid(ic->ic_bss->ni_essid,
				    ni->ni_esslen);
				rate = ni->ni_rates.rs_rates[ni->ni_txrate] &
				    IEEE80211_RATE_VAL;
				printf(" channel %d",
				    ieee80211_chan2ieee(ic, ni->ni_chan));
				if (ni->ni_flags & IEEE80211_NODE_HT)
					printf(" start MCS %u", ni->ni_txmcs);
				else
					printf(" start %u%sMb",
					    rate / 2, (rate & 1) ? ".5" : "");
				printf(" %s preamble %s slot time%s%s\n",
				    (ic->ic_flags & IEEE80211_F_SHPREAMBLE) ?
					"short" : "long",
				    (ic->ic_flags & IEEE80211_F_SHSLOT) ?
					"short" : "long",
				    (ic->ic_flags & IEEE80211_F_USEPROT) ?
					" protection enabled" : "",
				    (ni->ni_flags & IEEE80211_NODE_HT) ?
					" HT enabled" : "");
			}
			if (!(ic->ic_flags & IEEE80211_F_RSNON)) {
				/*
				 * NB: When RSN is enabled, we defer setting
				 * the link up until the port is valid.
				 */
				ieee80211_set_link_state(ic, LINK_STATE_UP);
			}
			ic->ic_mgt_timer = 0;
			ieee80211_set_beacon_miss_threshold(ic);
			if_start(ifp);
			break;
		}
		break;
	}
	return 0;
}

void
ieee80211_set_link_state(struct ieee80211com *ic, int nstate)
{
	struct ifnet *ifp = &ic->ic_if;

	switch (ic->ic_opmode) {
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
	case IEEE80211_M_HOSTAP:
		nstate = LINK_STATE_UNKNOWN;
		break;
#endif
	case IEEE80211_M_MONITOR:
		nstate = LINK_STATE_DOWN;
		break;
	default:
		break;
	}
	if (nstate != ifp->if_link_state) {
		ifp->if_link_state = nstate;
		if_link_state_change(ifp);
	}
}
@


1.76
log
@Scale the missed beacon counter threshold to the AP's beacon interval.

This should make fading APs time out consistently regardless of what the
beacon interval is set to (range is 1 to 2^16 TU, though in practice 100 TU
seems to be a common value).

Print the beacon interval and missed beacon counter threshold to dmesg
if the DEBUG flag was set on the wireless interface with ifconfig(8).
This should help with diagnosing any issues that pop up.

Requested and diff eye-balled by kettenis@@
help & ok tb@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.75 2017/05/30 10:50:33 stsp Exp $	*/
d711 2
a712 1
			free(ba->ba_buf, M_DEVBUF, 0);
@


1.75
log
@Always set the link state DOWN once we enter ieee80211_newstate(), regardless
of whether the wifi interface happens to be leaving RUN state. The interface
is never usable during state transitions so setting the link DOWN is the only
reasonable option when any transition is triggered.

Fixes a problem where, at boot time, the link state of wifi interfaces was
reported to userland as UNKNOWN (which, curiously, has value 0). dhclient's
link detection logic was recently changed from ifmedia to getifaddrs which
exposed the UNKOWN link state. Since dhclient assumes an UNKNOWN link state
means UP it would start trying to negotiate a lease too early during boot.

Problem reported by tb@@
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.74 2017/03/02 09:41:27 stsp Exp $	*/
d79 1
d815 21
d1082 1
@


1.74
log
@Initialize 'ni' pointer in ieee80211_keyrun(). Fallout from last minute
changes I made to my WPA security patch. Affects WPA enterprise only.
Problem found by patrick@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.73 2017/03/01 19:28:48 stsp Exp $	*/
d831 1
a831 2
	if (ostate == IEEE80211_S_RUN)
		ieee80211_set_link_state(ic, LINK_STATE_DOWN);
@


1.73
log
@Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.72 2017/02/07 15:07:14 stsp Exp $	*/
d359 1
a359 1
	struct ieee80211_node *ni;
@


1.72
log
@Enable the short slot time feature in 802.11n mode.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.71 2017/02/02 16:47:53 stsp Exp $	*/
d359 1
a360 1
	struct ieee80211_node *ni;
d369 1
d735 4
d905 1
d916 1
d959 1
@


1.71
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.70 2016/12/26 23:25:11 stsp Exp $	*/
a312 6
	/*
	 * Enable short slot time iff:
	 * - we're operating in 802.11a or
	 * - we're operating in 802.11g and we're not in IBSS mode and
	 *   the device supports short slot time
	 */
d314 3
a316 1
	    ic->ic_curmode == IEEE80211_MODE_11A
d319 3
a321 1
	    (ic->ic_curmode == IEEE80211_MODE_11G &&
d328 2
@


1.70
log
@Allow using 11n mode with APs that do not advertise support for all of MCS 0-7.
ok phessler@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.69 2016/09/15 03:32:48 dlg Exp $	*/
a311 2
	ic->ic_nonerpsta = 0;
	ic->ic_longslotsta = 0;
a421 2
	else
		ic->ic_rsn_keydonesta++;
a455 1
	ic->ic_rsn_keydonesta = 0;
@


1.69
log
@move from RB macros to the RBT functions.

shaves about 5k off an amd64 GENERIC.MP kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.68 2016/07/20 15:40:27 stsp Exp $	*/
d558 6
a563 2
	/* Check if the peer supports HT. MCS 0-7 are mandatory. */
	if (ni->ni_rxmcs[0] != 0xff) {
@


1.68
log
@In net80211, enable RTS for frames above a particular size (currently 512
bytes). This is what other OS have been doing for years. In our stack this
feature was present but disabled at compile-time by an #ifdef.

This is a low risk change because drivers were already required to use RTS
whenever the AP set the USE_PROTECTION flag in ERP elements of its beacons.

This change allows for reasonable throughput on loaded 11g networks
whereas before they were practically unusable.

tests and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.67 2016/05/18 08:15:28 stsp Exp $	*/
d850 1
a850 1
				RB_FOREACH(ni, ieee80211_tree, &ic->ic_tree) {
d876 1
a876 1
				RB_FOREACH(ni, ieee80211_tree, &ic->ic_tree) {
@


1.68.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 5.9 errata 35, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.68 2016/07/20 15:40:27 stsp Exp $	*/
d361 1
a362 1
#ifndef IEEE80211_STA_ONLY
a370 1
	ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
a734 4

		/* In IBSS mode no (re)association frames are sent. */
		if (ic->ic_flags & IEEE80211_F_RSNON)
			ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
a900 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
a910 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
a952 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
@


1.68.2.2
log
@Merge ieee80211_proto.c r1.74 to 6.0-stable:
Initialize 'ni' pointer in ieee80211_keyrun(). Fallout from last minute
changes I made to my WPA security patch. Affects WPA enterprise only.
Problem found by patrick@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.68.2.1 2017/03/01 20:57:51 benno Exp $	*/
d361 1
a361 1
	struct ieee80211_node *ni = ic->ic_bss;
@


1.67
log
@In hostap mode, don't re-use association IDs (AIDs) of nodes which are
still lingering in the node cache. This could cause an AID to be assigned
twice, once to a newly associated node and once to a different node in
COLLECT cache state (i.e. marked for future eviction from the node cache).

Drivers (e.g. rt2860) may use AIDs to keep track of nodes in firmware
tables and get confused when AIDs aren't unique across the node cache.
The symptom observed with rt2860 were nodes stuck at 1 Mbps Tx rate since
the duplicate AID made the driver perform Tx rate (AMRR) accounting on
the wrong node object.

To find out if a node is associated we now check the node's cache state,
rather than comparing the node's AID against zero. An AID is assigned when
a node associates and it lasts until the node is eventually purged from the
node cache (previously, the AID was made available for re-use when the node
was placed in COLLECT state). There is no need to be stingy with AIDs since
the number of possible AIDs exceeds the maximum number of nodes in the cache.

Problem found by Nathanael Rensen.
Fix written by Nathanael and myself. Tested by Nathanael.
Comitting now to get this change tested across as many drivers as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.66 2016/04/27 11:58:10 stsp Exp $	*/
a90 1
#ifdef notdef
a91 3
#else
	ic->ic_rtsthreshold = IEEE80211_RTS_MAX;
#endif
@


1.66
log
@Add some stat counters for events related to 802.11n.
netstat(1) needs to be recompiled to work with new kernel.
ok deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.65 2016/04/12 14:33:27 mpi Exp $	*/
d855 1
a855 1
					if (ni->ni_associd == 0)
@


1.65
log
@Call if_enqueue() and if_start() instead of dereferencing the ifp
pointers.

These functions have been introduced to abstract some of the MP-
safeness^Wmadness and should be use everywhere.

Prodded by a comment from jsg@@.

ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.64 2016/02/08 01:00:47 stsp Exp $	*/
d563 2
a564 1
	if (ni->ni_rxmcs[0] != 0xff)
d566 1
d572 2
a573 1
			    !isset(ic->ic_sup_mcs, i))
d575 1
d583 2
a584 1
	if (ic->ic_flags & IEEE80211_F_WEPON)
d586 1
d589 2
a590 1
	    ni->ni_rsnciphers & IEEE80211_CIPHER_TKIP))
d592 1
d606 2
d630 2
@


1.64
log
@Stop requiring a BlockAck session timeout (again), and just use it if the AP
is asking for it. This timeout should not be required anymore now that krw@@'s
hangs are fixed by working around APs which make sequence numbers jump about.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.63 2016/02/05 16:07:57 stsp Exp $	*/
d1046 1
a1046 1
			(*ifp->if_start)(ifp);
@


1.64.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 6.0 errata 18, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.64 2016/02/08 01:00:47 stsp Exp $	*/
d365 1
a366 1
#ifndef IEEE80211_STA_ONLY
a374 1
	ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
a726 4

		/* In IBSS mode no (re)association frames are sent. */
		if (ic->ic_flags & IEEE80211_F_RSNON)
			ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
a892 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
a902 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
a944 1
		ni->ni_rsn_supp_state = RSNA_SUPP_INITIALIZE;
@


1.64.2.2
log
@Merge ieee80211_proto.c r1.74 to 5.9-stable:
Initialize 'ni' pointer in ieee80211_keyrun(). Fallout from last minute
changes I made to my WPA security patch. Affects WPA enterprise only.
Problem found by patrick@@
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.64.2.1 2017/03/01 20:57:29 benno Exp $	*/
d365 1
a365 1
	struct ieee80211_node *ni = ic->ic_bss;
@


1.63
log
@Store ADDBA request and response parameters in the block ack record of
ieee80211_node. This way, we can keep track of the ACK policy and echo
it back to the AP as required by the standard. And use the correct bit
flag for the policy -- this code was confused between BlockAck and ADDBA,
both of which have a policy bit but in different places.

Fixes apple airport APs.

tested by tb@@, krw@@, sthen@@, abieber@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.62 2016/02/04 16:23:40 stsp Exp $	*/
d644 1
a644 1
	ba->ba_timeout_val = IEEE80211_BA_MAX_TIMEOUT;
@


1.62
log
@Restore the BlockAck session timer. It is still required to work around
stalled BA sessions observed with iwn(4). We can revisit this later once
the underlying problem in iwn(4) has been found.
Prompted by report from krw@@, I could reproduce the issue.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.61 2016/02/01 18:43:22 stsp Exp $	*/
d649 6
@


1.61
log
@Stop requiring a BlockAck session timeout. We still honour the timeout if
the AP requests it, though I don't think I've ever seen one that does.
Per the 802.11-2012 spec a value of zero disables the timeout and some
APs seem to have trouble with timeouts forced onto them.
Our behaviour now matches Linux in this regard.

This gets Apple Airport APs somewhat working in 11n mode but there
is still a remaining issue with receiving frames from them.
Doesn't seem to hurt any other APs I've tried.

ok sthen@@ mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.60 2016/01/12 09:28:09 stsp Exp $	*/
d644 1
a644 1
	ba->ba_timeout_val = 0;
@


1.60
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.59 2016/01/07 23:22:31 stsp Exp $	*/
d644 1
a644 1
	ba->ba_timeout_val = IEEE80211_BA_MAX_TIMEOUT;
@


1.59
log
@Make the A-MPDU reordering buffer more resilient against APs which drop
some subframes or let the sequence number jump up by more than 1 (hard
to tell which it is). We decrease the BA inactivity timeout for quicker
recovery from stalled BA sessions, and add a new timeout which keeps track
of gaps in the subframe sequence number space due to dropped frames.
Gaps expire after 500 msec, the same value FreeBSD uses for their
implementation of this workaround. And Linux uses this trick, too.

This should fix network stalls some people have been seeing in 11n mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.58 2016/01/05 18:41:16 stsp Exp $	*/
a75 1
	"turbo",	/* IEEE80211_MODE_TURBO */
@


1.58
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.57 2016/01/04 12:25:46 stsp Exp $	*/
d690 1
@


1.57
log
@Don't return 11n mode from ieee80211_chan2mode() so we can switch into
11a and 11b/g mode correctly when the driver supports 11n.
And make sure the result of this funtion is only used to index ic_sup_rates.
Its stated purpose is to help select a legacy rate.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.56 2015/11/24 13:45:06 mpi Exp $	*/
a98 1
#ifndef IEEE80211_NO_HT
a99 1
#endif
a547 1
#ifndef IEEE80211_NO_HT
a700 1
#endif	/* !IEEE80211_NO_HT */
a1016 1
#ifndef IEEE80211_NO_HT
a1019 1
#endif
@


1.56
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.55 2015/11/15 12:34:07 stsp Exp $	*/
d897 2
a898 9
#ifndef IEEE80211_NO_HT
		if (ic->ic_curmode == IEEE80211_MODE_11N)
			ni->ni_rates = ic->ic_sup_rates[
			IEEE80211_IS_CHAN_2GHZ(ni->ni_chan) ?
				IEEE80211_MODE_11G : IEEE80211_MODE_11A];
		else
#endif
			ni->ni_rates = ic->ic_sup_rates[
				ieee80211_chan2mode(ic, ni->ni_chan)];
@


1.55
log
@Expose 11n mode to the ifmedia layer and introduce the concept of MCS.
Make sure 11n features are enabled only if media type is autoselect or 11n.

11n mode uses MCS (modulation & coding scheme) instead of rates like 11a/b/g.
This means we'll have to take the current mode into account and decide whether
to use a rate or an MCS for transmission. Receiving frames on legacy rates
will still work in 11n mode. We just won't be using legacy rates to send
data frames to an STA or AP we negotiated 11n features with.

My initial plan was to grow the ieee80211_rateset structure and treat MCS
just like rates. However, ieee80211_rateset corresponds to rates and xrates
elements in management frames and is copied directly into such elements
so its size cannot change. Thus, MCS stands on its own and corresponds to
elements in management frames related to 11n HT capabilities.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.54 2015/11/15 11:14:17 stsp Exp $	*/
a49 1
#include <net/if_arp.h>
@


1.54
log
@Parse 11n HT capabilities and operational info from association response
frames, negotiate HT with the AP, and move the interface into or out of
11n mode accordingly. If running as AP negotiate HT with nodes joining the BSS.

ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.53 2015/11/04 12:12:00 dlg Exp $	*/
d78 1
d100 3
d898 9
a906 2
		ni->ni_rates = ic->ic_sup_rates[
			ieee80211_chan2mode(ic, ni->ni_chan)];
d1027 10
a1036 4
				printf(" channel %d start %u%sMb",
				    ieee80211_chan2ieee(ic, ni->ni_chan),
				    rate / 2, (rate & 1) ? ".5" : "");
				printf(" %s preamble %s slot time%s\n",
d1042 3
a1044 1
					" protection enabled" : "");
@


1.53
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.52 2015/07/15 22:16:42 deraadt Exp $	*/
d548 42
@


1.52
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.51 2015/03/14 03:38:51 jsg Exp $	*/
d87 3
d114 2
a115 2
	IF_PURGE(&ic->ic_mgtq);
	IF_PURGE(&ic->ic_pwrsaveq);
d841 2
a842 2
			IF_PURGE(&ic->ic_mgtq);
			IF_PURGE(&ic->ic_pwrsaveq);
@


1.51
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.50 2014/12/23 03:24:08 tedu Exp $	*/
d649 1
a649 2
				if (ba->ba_buf[i].m != NULL)
					m_freem(ba->ba_buf[i].m);
@


1.50
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.49 2014/11/18 02:37:31 tedu Exp $	*/
a36 2
#include "bpfilter.h"

a51 4

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
@


1.49
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.48 2014/09/14 14:17:26 jsg Exp $	*/
a58 1
#ifdef INET
a60 1
#endif
@


1.48
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.47 2014/07/12 18:44:23 tedu Exp $	*/
a65 2

#include <dev/rndvar.h>
@


1.47
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.46 2012/01/18 14:35:56 stsp Exp $	*/
a46 1
#include <sys/proc.h>
@


1.46
log
@Don't unconditionally allocate new nodes in the hostap auth frame input path.
Check if the node was already cached first. Duplicate nodes aren't reachable
from the node cache's RB tree, so they leak and mess up node cache accounting.
As more and more nodes leak the global nodes counter keeps increasing,
eventually reaching the limit and hovering there. The system then constantly
tries to clean the node cache, sending de-auth frames to stations in the
process, even if the actual number of associated stations is small.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.45 2011/02/21 20:00:54 stsp Exp $	*/
d663 1
a663 1
			free(ba->ba_buf, M_DEVBUF);
@


1.45
log
@Fix stats about node allocation failures.
ok damien; committing with miod's permission (src is soft-locked)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.44 2010/08/07 03:50:02 krw Exp $	*/
d705 3
a707 1
			ni = ieee80211_alloc_node(ic, wh->i_addr2);
@


1.44
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.43 2010/07/28 21:24:52 deraadt Exp $	*/
a706 1
				ic->ic_stats.is_rx_nodealloc++;
@


1.43
log
@Suspending drivers need to do as little as possible in here, so when the
transition is to INIT, try to not generate management frames if we can
avoid it.
ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.42 2010/06/05 15:54:35 damien Exp $	*/
d970 1
a970 1
				panic("%s: bogus xmit rate %u setup\n",
@


1.42
log
@when rekeying the GTK/IGTK, send the new key to clients, not the
old one.

found after reading a post by Nathanael Rensen to tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.41 2009/11/21 18:09:31 damien Exp $	*/
d784 4
d792 2
d818 2
d843 1
@


1.41
log
@when wpa is enabled, defer setting the link up until the 802.1X
port is valid (keys have been successfully exchanged.)
this avoids dhclient timeouts when wpa is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.40 2009/03/26 20:34:54 damien Exp $	*/
d433 4
a436 2
	if (ieee80211_send_group_msg1(ic, ni) == 0) {
		ni->ni_flags |= IEEE80211_NODE_REKEY;
a437 1
	}
@


1.40
log
@sync with 802.11w draft 8.0.
the SA Query Transaction Identifier field is now a 16-bit non-negative
counter value instead of a 128-bit random value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.39 2009/01/28 18:55:18 damien Exp $	*/
a91 1
void ieee80211_set_link_state(struct ieee80211com *, int);
a950 1
		ieee80211_set_link_state(ic, LINK_STATE_UP);
d982 7
@


1.39
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.38 2009/01/26 19:09:41 damien Exp $	*/
d545 2
a546 2
	/* generate random Transaction Identifier */
	arc4random_buf(ni->ni_sa_query_trid, 16);
@


1.38
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.37 2008/10/15 19:12:18 blambert Exp $	*/
d557 1
a557 1
ieee80211_ba_timeout(void *arg)
d559 1
a559 1
	struct ieee80211_ba *ba = arg;
a568 2
		free(ba->ba_buf, M_DEVBUF);
		ba->ba_buf = NULL;
d572 3
a574 2
		tid = ((caddr_t)ba - (caddr_t)ni->ni_ba) / sizeof(*ba);
		ieee80211_delba_request(ic, ni, IEEE80211_REASON_TIMEOUT, tid);
d579 18
d604 1
a604 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
d612 1
a612 1
	timeout_set(&ba->ba_to, ieee80211_ba_timeout, ba);
a615 6
	/* allocate and setup our reordering buffer */
	ba->ba_buf = malloc(IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ba->ba_buf == NULL)
		return ENOMEM;
	ba->ba_head = 0;
d628 1
a628 1
    u_int16_t reason, u_int8_t tid)
a629 3
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
	int i;

d634 32
a665 21
	    IEEE80211_ACTION_DELBA, reason << 16 | tid);
	/*
	 * XXX We should wait for an acknowledgment of the DELBA frame but
	 * drivers are not necessarily notified when a frame is ACK'ed by
	 * hardware.
	 */
	/* MLME-DELBA.confirm */
	if (ic->ic_htimmba_stop != NULL)
		ic->ic_htimmba_stop(ic, ni, tid);

	ba->ba_state = IEEE80211_BA_INIT;
	/* stop Block Ack inactivity timer */
	timeout_del(&ba->ba_to);
	if (ba->ba_buf != NULL) {
		/* free all MSDUs stored in reordering buffer */
		for (i = 0; i < IEEE80211_BA_MAX_WINSZ; i++)
			if (ba->ba_buf[i].m != NULL)
				m_freem(ba->ba_buf[i].m);
		/* free reordering buffer */
		free(ba->ba_buf, M_DEVBUF);
		ba->ba_buf = NULL;
@


1.37
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.36 2008/09/27 15:16:09 damien Exp $	*/
d7 1
a7 1
 * Copyright (c) 2008 Damien Bergamini
d514 39
d554 96
@


1.36
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.35 2008/08/29 12:14:53 damien Exp $	*/
d512 1
a512 1
	timeout_add(&ic->ic_rsn_timeout, 3600 * hz);
@


1.35
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.34 2008/08/27 09:05:04 damien Exp $	*/
d365 53
@


1.34
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.33 2008/08/14 15:51:43 damien Exp $	*/
a87 1
	"fh",		/* IEEE80211_MODE_FH */
@


1.33
log
@put ieee80211_dump_pkt() under #ifdef IEEE80211_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.32 2008/08/12 19:50:39 damien Exp $	*/
d287 1
d291 1
d336 3
a338 1
	    ic->ic_curmode == IEEE80211_MODE_11A ||
d341 3
a343 1
	     (ic->ic_caps & IEEE80211_C_SHSLOT)));
d368 1
d462 1
d471 1
d519 1
d552 1
a552 1
	case IEEE80211_M_MONITOR:
d565 1
d567 1
d588 1
d600 1
d612 1
d622 1
d629 1
d632 1
d651 1
d659 2
a660 1
			} else {
a661 1
			}
d794 1
d799 1
@


1.32
log
@clear Tx_Rx protection bits properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.31 2008/08/12 18:37:23 damien Exp $	*/
d153 1
d213 1
@


1.31
log
@generate a random IGTK in HostAP mode if we're MFP-capable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.30 2008/08/12 17:53:13 damien Exp $	*/
d520 1
@


1.30
log
@Change the way we process EAPOL-Key frames.
Free the mbuf in the ieee80211_eapol_key_input() function.
Do not assume the frame is contiguous, call m_pullup2() if it is not.
We need the frame to be contiguous to process KDEs efficiently in
EAPOL-Key frames (just like we process IEs in management frames).
However, there are drivers like upgt(4) that use m_devget() in the
RX path.  m_devget() can return fragmented mbuf chains.
Notice that we should do the same m_pullup2() for management frames.
This will be done later.
Remove the ic_recv_eapol callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.29 2008/08/12 16:14:05 damien Exp $	*/
d399 12
d427 8
@


1.29
log
@get rid of the map_ptk()/map_gtk() functions, just inline them
which makes things easier to track.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.28 2008/07/27 14:21:15 damien Exp $	*/
a116 3

	/* initialize EAPOL frame handler */
	ic->ic_recv_eapol = ieee80211_recv_eapol;
@


1.28
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.27 2008/07/26 12:56:06 damien Exp $	*/
d389 1
a389 1
	u_int8_t gtk[IEEE80211_PMK_LEN];
d394 7
a400 4

	arc4random_buf(gtk, sizeof(gtk));
	ieee80211_map_gtk(gtk, ic->ic_bss->ni_rsngroupcipher, kid, 1, 0,
	    &ic->ic_nw_keys[kid]);
@


1.27
log
@shrink ieee80211_set_link_state().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.26 2008/07/21 19:27:26 damien Exp $	*/
d444 1
a444 2
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
d461 1
a461 2
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
d493 1
a493 2
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
d535 2
a536 2
	IEEE80211_DPRINTF(("%s: %s -> %s\n", __func__,
	    ieee80211_state_name[ostate], ieee80211_state_name[nstate]));
d651 1
a651 2
			IEEE80211_DPRINTF(("%s: invalid transition\n",
				__func__));
d691 1
a691 2
			IEEE80211_DPRINTF(("%s: invalid transition\n",
				__func__));
d709 1
a709 2
			IEEE80211_DPRINTF(("%s: invalid transition\n",
				__func__));
@


1.26
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.25 2008/07/21 18:43:18 damien Exp $	*/
a757 35
	case IEEE80211_M_AHDEMO:
		/* FALLTHROUGH */
	case IEEE80211_M_STA:
		if (ifp->if_link_state != nstate) {
			if (nstate == LINK_STATE_UP) {
				/* Change link state to UP. */
				ifp->if_link_state = LINK_STATE_UP;
				if_link_state_change(ifp);
				if (ifp->if_flags & IFF_DEBUG) {
					printf("%s: set STA link state UP\n",
					    ifp->if_xname);
				}
			}

			if (nstate == LINK_STATE_DOWN) {
				/* Change link state to DOWN. */
				ifp->if_link_state = LINK_STATE_DOWN;
				if_link_state_change(ifp);
				if (ifp->if_flags & IFF_DEBUG) {
					printf("%s: set STA link state DOWN\n",
					    ifp->if_xname);
				}
			}

			if (nstate == LINK_STATE_UNKNOWN) {
				/* Change link state to UNKNOWN. */
				ifp->if_link_state = LINK_STATE_UNKNOWN;
				if_link_state_change(ifp);
				if (ifp->if_flags & IFF_DEBUG) {
					printf("%s: set STA link state UNKNOWN\n",
					    ifp->if_xname);
				}
			}
		}
		break;
a758 10
		/* Always change link state to UNKNOWN in IBSS mode. */
		if (ifp->if_link_state != LINK_STATE_UNKNOWN) {
			ifp->if_link_state = LINK_STATE_UNKNOWN;
			if_link_state_change(ifp); 
			if (ifp->if_flags & IFF_DEBUG) {
				printf("%s: set IBSS link state UNKNOWN\n",
				    ifp->if_xname);
			}
		}
		break;
d760 1
a760 9
		/* Always change link state to UNKNOWN in HOSTAP mode. */
		if (ifp->if_link_state != LINK_STATE_UNKNOWN) {
			ifp->if_link_state = LINK_STATE_UNKNOWN;
			if_link_state_change(ifp);
			if (ifp->if_flags & IFF_DEBUG) {
				printf("%s: set HOSTAP link state UNKNOWN\n",
				    ifp->if_xname);
			}
		}
d763 1
a763 9
		/* Always change link state to DOWN in MONITOR mode. */
		if (ifp->if_link_state != LINK_STATE_DOWN) {
			ifp->if_link_state = LINK_STATE_DOWN;
			if_link_state_change(ifp);
			if (ifp->if_flags & IFF_DEBUG) {
				printf("%s: set MONITOR link state DOWN\n",
				    ifp->if_xname);
			}
		}
a765 2
		printf("%s: can't set link state (unknown mediaopt)!\n",
		    ifp->if_xname);
d767 4
@


1.25
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.24 2008/06/09 07:07:16 djm Exp $	*/
d66 1
@


1.24
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.23 2008/04/21 19:37:18 damien Exp $	*/
d435 1
a435 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp, u_int16_t seq,
d475 2
a476 2
			ni->ni_rssi = rssi;
			ni->ni_rstamp = rstamp;
@


1.23
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.22 2008/04/16 18:32:15 damien Exp $	*/
d394 1
a394 1
	arc4random_bytes(gtk, sizeof(gtk));
@


1.22
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.21 2007/10/08 17:31:24 mglocker Exp $	*/
d431 93
@


1.21
log
@Get trunk(4) working again with 802.11 devices.  Spotted by ajacoutot@@.

Diff has been done in co-work with damien@@, jsg@@, reyk@@, and claudio@@.

OK damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.20 2007/07/28 11:24:06 damien Exp $	*/
d7 1
d67 2
d362 71
d499 2
a503 4
			if (ic->ic_wep_ctx != NULL) {
				free(ic->ic_wep_ctx, M_DEVBUF);
				ic->ic_wep_ctx = NULL;
			}
@


1.20
log
@adds functions to parse and to build EAPOL-Key frames used in
the 4-way and group-key handshake.
the state machine is still missing though so this is not used
anywhere yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.19 2007/07/04 20:32:43 damien Exp $	*/
d89 1
d374 2
d543 1
d584 81
@


1.19
log
@add subtype "Action" for management frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.18 2007/06/16 13:29:11 damien Exp $	*/
d112 3
@


1.18
log
@remove stupid macro.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.17 2007/06/16 13:17:05 damien Exp $	*/
d70 1
a70 1
	"deauth",	"reserved#13",	"reserved#14",	"reserved#15"
@


1.17
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.16 2007/06/16 11:56:20 damien Exp $	*/
a65 2
#define	IEEE80211_RATE2MBS(r)	(((r) & IEEE80211_RATE_VAL) / 2)

d194 1
a194 1
		printf(" %dM", rate / 2);
d362 1
a362 1
	u_int mbps;
d557 5
a561 4
				mbps = IEEE80211_RATE2MBS(
				    ni->ni_rates.rs_rates[ni->ni_txrate]);
				printf(" channel %d start %uMb",
				    ieee80211_chan2ieee(ic, ni->ni_chan), mbps);
@


1.16
log
@de-static

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.15 2007/06/06 19:31:07 damien Exp $	*/
d68 1
a68 1
const char *ieee80211_mgt_subtype_name[] = {
d74 1
a74 1
const char *ieee80211_state_name[IEEE80211_S_MAX] = {
d81 1
a81 1
const char *ieee80211_phymode_name[] = {
d126 1
a126 1
ieee80211_print_essid(u_int8_t *essid, int len)
d129 1
a129 1
	u_int8_t *p;
d151 1
a151 1
ieee80211_dump_pkt(u_int8_t *buf, int len, int rate, int rssi)
d217 2
a218 1
	struct ieee80211_rateset *srs, *nrs;
@


1.15
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.14 2007/02/14 01:12:16 jsg Exp $	*/
d90 1
a90 1
static int ieee80211_newstate(struct ieee80211com *, enum ieee80211_state, int);
d356 1
a356 1
static int
@


1.14
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.13 2006/12/25 19:24:27 reyk Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.13
log
@print the phy mode in IFF_DEBUG status output which helps to debug
dual/multi mode chipset operation.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.12 2006/08/29 17:56:32 damien Exp $	*/
d401 1
a401 1
			/* FALLTHRU */
d421 1
a421 1
			/* FALLTHRU */
d473 1
a473 1
			/* FALLTHRU */
@


1.12
log
@Change the way ieee80211_fix_rate() handles the IEEE80211_F_DOFRATE flag.
Instead of removing the rates from the node's rate set, just check that
the fixed rate is present in the rate set. Otherwise, the node will be
marked non-ERP which will force the use of protection mode (either
CTS-to-self or RTS/CTS) in an 802.11g network and degrade performance.
This fixes HostAP mode for 11g with a fixed rate.
Problem originally reported by Sam Fourman Jr.
Code from FreeBSD.

ok reyk@@, "no objections here" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.11 2006/08/19 12:38:16 damien Exp $	*/
d84 8
@


1.11
log
@move computation of mbps after checking the value of ni->ni_txrate
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.10 2006/06/18 18:39:41 damien Exp $	*/
d212 1
a212 1
	int okrate, badrate;
d216 7
d224 1
a224 1
	okrate = badrate = 0;
d246 1
a246 6
			 * Apply fixed rate constraint.  Note that we do
			 * not apply the constraint to basic rates as
			 * otherwise we may not be able to associate if
			 * the rate set we submit to the AP is invalid
			 * (e.g. fix rate at 36Mb/s which is not a basic
			 * rate for 11a operation).
d248 2
a249 4
			if ((nrs->rs_rates[i] & IEEE80211_RATE_BASIC) == 0 &&
			    ic->ic_fixed_rate >= 0 &&
			    r != RV(srs->rs_rates[ic->ic_fixed_rate]))
				ignore++;
d299 2
a300 1
	if (okrate == 0 || error != 0)
@


1.10
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.9 2005/09/13 12:11:03 reyk Exp $	*/
a365 1
	mbps = IEEE80211_RATE2MBS(ni->ni_rates.rs_rates[ni->ni_txrate]);
d553 2
@


1.9
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.8 2005/09/08 13:24:53 reyk Exp $	*/
a35 2
#include <sys/cdefs.h>

d306 45
d554 1
a554 1
				printf(" channel %d start %uMb\n",
d556 7
@


1.8
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.7 2005/09/08 12:44:55 jsg Exp $	*/
d338 1
a338 1
				TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
d360 1
a360 1
				TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
@


1.7
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.6 2005/09/08 09:11:08 jsg Exp $	*/
d209 2
a210 1
ieee80211_fix_rate(struct ieee80211com *ic, struct ieee80211_node *ni, int flags)
d229 2
a230 1
				if (RV(nrs->rs_rates[i]) > RV(nrs->rs_rates[j])) {
d309 2
a310 1
ieee80211_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int mgt)
d315 1
d320 1
a320 1
		ieee80211_state_name[ostate], ieee80211_state_name[nstate]));
d323 1
d512 1
a512 2
				    ieee80211_chan2ieee(ic, ni->ni_chan),
				    IEEE80211_RATE2MBS(ni->ni_rates.rs_rates[ni->ni_txrate]));
@


1.6
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.5 2005/09/07 05:40:11 jsg Exp $	*/
a70 1
#include <net80211/ieee80211_compat.h>
d312 1
a312 1
	ieee80211_node_critsec_decl(s);
d332 1
a332 1
				ieee80211_node_critsec_begin(ic, s);
d340 1
a340 1
				ieee80211_node_critsec_end(ic, s);
d354 1
a354 1
				ieee80211_node_critsec_begin(ic, s);
d360 1
a360 1
				ieee80211_node_critsec_end(ic, s);
d495 3
a497 3
			IASSERT(ni->ni_txrate < ni->ni_rates.rs_nrates,
				("%s: bogus xmit rate %u setup\n", __func__,
				ni->ni_txrate));
@


1.5
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.4 2005/03/13 13:48:45 reyk Exp $	*/
d413 2
a414 2
				if_printf(ifp, "no recent beacons from %s;"
				    " rescanning\n",
d500 2
a501 1
				if_printf(ifp, "%s with %s ssid ",
@


1.4
log
@fix whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.3 2005/02/17 18:28:05 reyk Exp $	*/
a36 5
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_proto.c,v 1.8 2004/04/02 20:22:25 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_proto.c,v 1.8 2004/04/30 23:58:20 dyoung Exp $");
#endif
a41 4
#if defined(__NetBSD__)
#include "opt_inet.h"
#endif

a51 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a54 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a58 5
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a66 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a67 3
#else
#include <net/if_ether.h>
#endif
a106 4
#ifdef __FreeBSD__
	mtx_init(&ic->ic_mgtq.ifq_mtx, ifp->if_xname, "mgmt send q", MTX_DEF);
#endif

a119 4
#ifdef __FreeBSD__
	IF_DRAIN(&ic->ic_mgtq);
	mtx_destroy(&ic->ic_mgtq.ifq_mtx);
#else
a121 1
#endif
a369 3
#ifdef __FreeBSD__
			IF_DRAIN(&ic->ic_mgtq);
#else
a371 1
#endif
a382 1
#if defined(__OpenBSD__)
a384 4
#else
		IEEE80211_ADDR_COPY(ni->ni_macaddr, ifp->if_broadcastaddr);
		IEEE80211_ADDR_COPY(ni->ni_bssid, ifp->if_broadcastaddr);
#endif
@


1.3
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.2 2004/07/04 22:34:14 naddy Exp $	*/
d541 1
a541 1
					ni->ni_txrate));
d543 3
a545 6
				if_printf(ifp, " ");
				if (ic->ic_opmode == IEEE80211_M_STA)
					printf("associated ");
				else
					printf("synchronized ");
				printf("with %s ssid ",
d550 2
a551 2
					ieee80211_chan2ieee(ic, ni->ni_chan),
					IEEE80211_RATE2MBS(ni->ni_rates.rs_rates[ni->ni_txrate]));
@


1.2
log
@fix a NetBSDism and a pasto left over from the import; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_proto.c,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d466 1
a466 1
			if (ni != NULL) {
a467 2
				ieee80211_unref_node(&ni);
			}
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 1
a38 2
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_proto.c,v 1.8 2004/04/02 20:22:25
 sam Exp $");
@

