head	1.11;
access;
symbols
	OPENBSD_6_2:1.11.0.10
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.11.0.8
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.16
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.14
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.10
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.8
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.6
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.4
	OPENBSD_5_0:1.7.0.2
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.5.0.6
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.8
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.4
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.2
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.3.0.4
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.2
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.11
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.10;
commitid	2QagMjdMhQhIaQgu;

1.10
date	2015.12.14.08.37.01;	author stsp;	state Exp;
branches;
next	1.9;
commitid	UrJWsGSrvr0k3RnS;

1.9
date	2015.11.15.13.20.16;	author stsp;	state Exp;
branches;
next	1.8;
commitid	cqWr7csXLfydFCja;

1.8
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.7;
commitid	PYnSnAqgemmk34E3;

1.7
date	2011.03.02.08.48.59;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.17.19.07.19;	author damien;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@/*	$OpenBSD: ieee80211_amrr.c,v 1.10 2015/12/14 08:37:01 stsp Exp $	*/

/*-
 * Copyright (c) 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>
#include <net80211/ieee80211_amrr.h>

#define is_success(amn)	\
	((amn)->amn_retrycnt < (amn)->amn_txcnt / 10)
#define is_failure(amn)	\
	((amn)->amn_retrycnt > (amn)->amn_txcnt / 3)
#define is_enough(amn)		\
	((amn)->amn_txcnt > 10)
#define reset_cnt(amn)		\
	do { (amn)->amn_txcnt = (amn)->amn_retrycnt = 0; } while (0)

/* 
 * XXX In HT mode we only support MCS 0-7, for now.
 * Beyond MCS 7, incrementing the MCS index does not imply a
 * higher data rate, so this simple implementation will need
 * to be enhanced.
 */

static inline int
is_min_rate(struct ieee80211_node *ni)
{
	if (ni->ni_flags & IEEE80211_NODE_HT)
		return (ni->ni_txmcs == 0);
	return (ni->ni_txrate == 0);
}

static inline int
is_max_rate(struct ieee80211_node *ni)
{
	if (ni->ni_flags & IEEE80211_NODE_HT)
		return (ni->ni_txmcs == 7); /* XXX up to MCS 7 only */
	return (ni->ni_txrate == ni->ni_rates.rs_nrates - 1);
}

static inline void
increase_rate(struct ieee80211_node *ni)
{
	if (ni->ni_flags & IEEE80211_NODE_HT)
		ni->ni_txmcs++;
	else
		ni->ni_txrate++;
}

static inline void
decrease_rate(struct ieee80211_node *ni)
{
	if (ni->ni_flags & IEEE80211_NODE_HT)
		ni->ni_txmcs--;
	else
		ni->ni_txrate--;
}

void
ieee80211_amrr_node_init(const struct ieee80211_amrr *amrr,
    struct ieee80211_amrr_node *amn)
{
	amn->amn_success = 0;
	amn->amn_recovery = 0;
	amn->amn_txcnt = amn->amn_retrycnt = 0;
	amn->amn_success_threshold = amrr->amrr_min_success_threshold;
}

/*
 * Update ni->ni_txrate.
 */
void
ieee80211_amrr_choose(struct ieee80211_amrr *amrr, struct ieee80211_node *ni,
    struct ieee80211_amrr_node *amn)
{
#define RV(rate)	((rate) & IEEE80211_RATE_VAL)
	int need_change = 0;

	if (is_success(amn) && is_enough(amn)) {
		amn->amn_success++;
		if (amn->amn_success >= amn->amn_success_threshold &&
		    !is_max_rate(ni)) {
			amn->amn_recovery = 1;
			amn->amn_success = 0;
			increase_rate(ni);
			DPRINTF(("increase rate=%d,#tx=%d,#retries=%d\n",
			    (ni->ni_flags & IEEE80211_NODE_HT) ? ni->ni_txmcs :
			    RV(ni->ni_rates.rs_rates[ni->ni_txrate]),
			    amn->amn_txcnt, amn->amn_retrycnt));
			need_change = 1;
		} else {
			amn->amn_recovery = 0;
		}
	} else if (is_failure(amn)) {
		amn->amn_success = 0;
		if (!is_min_rate(ni)) {
			if (amn->amn_recovery) {
				amn->amn_success_threshold *= 2;
				if (amn->amn_success_threshold >
				    amrr->amrr_max_success_threshold)
					amn->amn_success_threshold =
					    amrr->amrr_max_success_threshold;
			} else {
				amn->amn_success_threshold =
				    amrr->amrr_min_success_threshold;
			}
			decrease_rate(ni);
			DPRINTF(("decrease rate=%d,#tx=%d,#retries=%d\n",
			    (ni->ni_flags & IEEE80211_NODE_HT) ? ni->ni_txmcs :
			    RV(ni->ni_rates.rs_rates[ni->ni_txrate]),
			    amn->amn_txcnt, amn->amn_retrycnt));
			need_change = 1;
		}
		amn->amn_recovery = 0;
	}

	if (is_enough(amn) || need_change)
		reset_cnt(amn);
#undef RV
}
@


1.10
log
@In AMRR debug printfs, show ni_txmcs instead of ni_txrate for HT nodes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.9 2015/11/15 13:20:16 stsp Exp $	*/
a53 1
#ifndef IEEE80211_NO_HT
a55 1
#endif
a61 1
#ifndef IEEE80211_NO_HT
a63 1
#endif
a69 1
#ifndef IEEE80211_NO_HT
a72 1
#endif
a78 1
#ifndef IEEE80211_NO_HT
a81 1
#endif
@


1.9
log
@Add support for 11n mode to the rate adaptation (AMRR) code.

Currently limited to MCS 0-7. For now, drivers must not configure 11n
hardware to use MCS other than MCS 0-7, which limits us to 65Mbit/s.
MCS 8 and above use MIMO and will require more work in AMRR once we get there.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.8 2014/12/23 03:24:08 tedu Exp $	*/
d121 1
d143 1
@


1.8
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.7 2011/03/02 08:48:59 fgsch Exp $	*/
a40 8
#define is_min_rate(ni)		\
	((ni)->ni_txrate == 0)
#define is_max_rate(ni)		\
	((ni)->ni_txrate == (ni)->ni_rates.rs_nrates - 1)
#define increase_rate(ni)	\
	((ni)->ni_txrate++)
#define decrease_rate(ni)	\
	((ni)->ni_txrate--)
d43 49
@


1.7
log
@Allow the kernel to compile with IEEE80211_DEBUG.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.6 2010/04/20 22:05:43 tedu Exp $	*/
a27 1
#ifdef INET
a29 1
#endif
@


1.6
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.5 2008/07/27 14:21:15 damien Exp $	*/
d21 1
@


1.5
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.4 2008/07/21 19:27:26 damien Exp $	*/
a22 1
#include <sys/sysctl.h>
@


1.4
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.3 2007/06/16 13:17:05 damien Exp $	*/
d71 1
d81 2
a82 4
			IEEE80211_DPRINTF(("AMRR increasing rate %d (txcnt=%d "
			    "retrycnt=%d)\n",
			    ni->ni_rates.rs_rates[ni->ni_txrate] &
				IEEE80211_RATE_VAL,
d102 2
a103 4
			IEEE80211_DPRINTF(("AMRR decreasing rate %d (txcnt=%d "
			    "retrycnt=%d)\n",
			    ni->ni_rates.rs_rates[ni->ni_txrate] &
				IEEE80211_RATE_VAL,
d112 1
@


1.3
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.2 2006/11/26 19:46:28 deraadt Exp $	*/
d34 1
@


1.2
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_amrr.c,v 1.1 2006/06/17 19:07:19 damien Exp $	*/
d54 1
a54 1
ieee80211_amrr_node_init(struct ieee80211_amrr *amrr,
@


1.1
log
@Move AMRR rate control algorithm out of wpi(4) and ural(4), into net80211.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a32 1
#include <net80211/ieee80211.h>
@

