head	1.28;
access;
symbols
	OPENBSD_6_1_BASE:1.28
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.21.0.6
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.14
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.10
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.10
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.8
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.4
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.2
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.28
date	2017.03.11.13.22.36;	author stsp;	state Exp;
branches;
next	1.27;
commitid	Xn9kwljCeGOAIQo7;

1.27
date	2016.08.15.22.14.19;	author stsp;	state Exp;
branches;
next	1.26;
commitid	62DrW0TOO8uk24Wm;

1.26
date	2016.04.28.14.46.10;	author stsp;	state Exp;
branches;
next	1.25;
commitid	FMpYe8618R2JWiMB;

1.25
date	2016.04.28.13.50.14;	author stsp;	state Exp;
branches;
next	1.24;
commitid	YnzDLdKGW1ZO3XJS;

1.24
date	2016.04.27.11.58.10;	author stsp;	state Exp;
branches;
next	1.23;
commitid	2WbLmzkj7ZM3hH4a;

1.23
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.22;
commitid	1npmDuWgN1zBR6BQ;

1.22
date	2015.11.15.01.05.25;	author stsp;	state Exp;
branches;
next	1.21;
commitid	8QkBLu4fXKUF5YHk;

1.21
date	2015.01.09.20.34.21;	author sthen;	state Exp;
branches;
next	1.20;
commitid	w6lKJJggebn63qFk;

1.20
date	2014.08.24.18.01.27;	author zhuk;	state Exp;
branches;
next	1.19;
commitid	U5Tni3KouSny7h2m;

1.19
date	2014.07.10.14.32.28;	author stsp;	state Exp;
branches;
next	1.18;
commitid	l6yVFVZyUhUAysk2;

1.18
date	2011.03.04.23.48.15;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2009.02.15.08.34.36;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.13.17.24.54;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2008.08.12.16.51.39;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2008.08.12.16.45.44;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2007.08.14.20.33.47;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.06.19.33.58;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.23.21.34.15;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.08.13.24.52;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.27.22.27.56;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.28
log
@Make 'ifconfig scan' display AP encryption correctly if WEP is configured
on the local wifi interface. ifconfig was mistakenly showing the common
supported subset of client and AP, rather than showing the AP's capabilities.
Exposes WPA protocol capabilities in struct ieee80211_nodereq, which means
ifconfig must be recompiled to run on a new kernel.
ok deraadt@@ mpi@@
@
text
@/*	$OpenBSD: ieee80211_ioctl.h,v 1.27 2016/08/15 22:14:19 stsp Exp $	*/
/*	$NetBSD: ieee80211_ioctl.h,v 1.7 2004/04/30 22:51:04 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net80211/ieee80211_ioctl.h,v 1.5 2004/03/30 22:57:57 sam Exp $
 */
#ifndef _NET80211_IEEE80211_IOCTL_H_
#define _NET80211_IEEE80211_IOCTL_H_

/*
 * IEEE 802.11 ioctls.
 */

/* per-interface statistics */
struct ieee80211_stats {
	u_int32_t	is_rx_badversion;	/* rx frame with bad version */
	u_int32_t	is_rx_tooshort;		/* rx frame too short */
	u_int32_t	is_rx_wrongbss;		/* rx from wrong bssid */
	u_int32_t	is_rx_dup;		/* rx discard 'cuz dup */
	u_int32_t	is_rx_wrongdir;		/* rx w/ wrong direction */
	u_int32_t	is_rx_mcastecho;	/* rx discard 'cuz mcast echo */
	u_int32_t	is_rx_notassoc;		/* rx discard 'cuz sta !assoc */
	u_int32_t	is_rx_nowep;		/* rx w/ wep but wep !config */
	u_int32_t	is_rx_unencrypted;	/* rx w/o wep but wep config */
	u_int32_t	is_rx_wepfail;		/* rx wep processing failed */
	u_int32_t	is_rx_decap;		/* rx decapsulation failed */
	u_int32_t	is_rx_mgtdiscard;	/* rx discard mgt frames */
	u_int32_t	is_rx_ctl;		/* rx discard ctrl frames */
	u_int32_t	is_rx_rstoobig;		/* rx rate set truncated */
	u_int32_t	is_rx_elem_missing;	/* rx required element missing*/
	u_int32_t	is_rx_elem_toobig;	/* rx element too big */
	u_int32_t	is_rx_elem_toosmall;	/* rx element too small */
	u_int32_t	is_rx_badchan;		/* rx frame w/ invalid chan */
	u_int32_t	is_rx_chanmismatch;	/* rx frame chan mismatch */
	u_int32_t	is_rx_nodealloc;	/* rx frame dropped */
	u_int32_t	is_rx_ssidmismatch;	/* rx frame ssid mismatch  */
	u_int32_t	is_rx_auth_unsupported;	/* rx w/ unsupported auth alg */
	u_int32_t	is_rx_auth_fail;	/* rx sta auth failure */
	u_int32_t	is_rx_assoc_bss;	/* rx assoc from wrong bssid */
	u_int32_t	is_rx_assoc_notauth;	/* rx assoc w/o auth */
	u_int32_t	is_rx_assoc_capmismatch;/* rx assoc w/ cap mismatch */
	u_int32_t	is_rx_assoc_norate;	/* rx assoc w/ no rate match */
	u_int32_t	is_rx_deauth;		/* rx deauthentication */
	u_int32_t	is_rx_disassoc;		/* rx disassociation */
	u_int32_t	is_rx_badsubtype;	/* rx frame w/ unknown subtype*/
	u_int32_t	is_rx_nombuf;		/* rx failed for lack of mbuf */
	u_int32_t	is_rx_decryptcrc;	/* rx decrypt failed on crc */
	u_int32_t	is_rx_ahdemo_mgt;	/* rx discard ahdemo mgt frame*/
	u_int32_t	is_rx_bad_auth;		/* rx bad auth request */
	u_int32_t	is_tx_nombuf;		/* tx failed for lack of mbuf */
	u_int32_t	is_tx_nonode;		/* tx failed for no node */
	u_int32_t	is_tx_unknownmgt;	/* tx of unknown mgt frame */
	u_int32_t	is_scan_active;		/* active scans started */
	u_int32_t	is_scan_passive;	/* passive scans started */
	u_int32_t	is_node_timeout;	/* nodes timed out inactivity */
	u_int32_t	is_crypto_nomem;	/* no memory for crypto ctx */
	u_int32_t	is_rx_assoc_badrsnie;	/* rx assoc w/ bad RSN IE */
	u_int32_t	is_rx_unauth;		/* rx port not valid */
	u_int32_t	is_tx_noauth;		/* tx port not valid */
	u_int32_t	is_rx_eapol_key;	/* rx eapol-key frames */
	u_int32_t	is_rx_eapol_replay;	/* rx replayed eapol frames */
	u_int32_t	is_rx_eapol_badmic;	/* rx eapol frames w/ bad mic */
	u_int32_t	is_rx_remmicfail;	/* rx tkip remote mic fails */
	u_int32_t	is_rx_locmicfail;	/* rx tkip local mic fails */
	u_int32_t	is_tkip_replays;
	u_int32_t	is_tkip_icv_errs;
	u_int32_t	is_ccmp_replays;
	u_int32_t	is_ccmp_dec_errs;
	u_int32_t	is_cmac_replays;
	u_int32_t	is_cmac_icv_errs;
	u_int32_t	is_pbac_errs;
	u_int32_t	is_ht_nego_no_mandatory_mcs;
	u_int32_t	is_ht_nego_no_basic_mcs;
	u_int32_t	is_ht_nego_bad_crypto;
	u_int32_t	is_ht_prot_change;
	u_int32_t	is_ht_rx_ba_agreements;
	u_int32_t	is_ht_tx_ba_agreements;
	u_int32_t	is_ht_rx_frame_below_ba_winstart;
	u_int32_t	is_ht_rx_frame_above_ba_winend;
	u_int32_t	is_ht_rx_ba_window_slide;
	u_int32_t	is_ht_rx_ba_window_jump;
	u_int32_t	is_ht_rx_ba_no_buf;
	u_int32_t	is_ht_rx_ba_frame_lost;
	u_int32_t	is_ht_rx_ba_window_gap_timeout;
	u_int32_t	is_ht_rx_ba_timeout;
	u_int32_t	is_ht_tx_ba_timeout;
};

#define	SIOCG80211STATS		_IOWR('i', 242, struct ifreq)

/* network identifier (ESSID), nwid is pointed at by ifr.ifr_data */
struct ieee80211_nwid {
	u_int8_t	i_len;
	u_int8_t	i_nwid[IEEE80211_NWID_LEN];
};

#define	SIOCS80211NWID		_IOWR('i', 230, struct ifreq)
#define	SIOCG80211NWID		_IOWR('i', 231, struct ifreq)

/* network key (WEP), the first member must be matched with struct ifreq */
struct ieee80211_nwkey {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	int		i_wepon;		/* wep enabled flag */
	int		i_defkid;		/* default encrypt key id */
	struct {
		int		i_keylen;
		u_int8_t	*i_keydat;
	}		i_key[IEEE80211_WEP_NKID];
};

#define	IEEE80211_NWKEY_OPEN	0		/* No privacy */
#define	IEEE80211_NWKEY_WEP	1		/* WEP enabled */
#define	IEEE80211_NWKEY_EAP	2		/* EAP enabled */
#define	IEEE80211_NWKEY_PERSIST	0x100		/* designate persist keyset */

#define	SIOCS80211NWKEY		 _IOW('i', 232, struct ieee80211_nwkey)
#define	SIOCG80211NWKEY		_IOWR('i', 233, struct ieee80211_nwkey)

/* power management parameters */
struct ieee80211_power {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	int		i_enabled;		/* 1 == on, 0 == off */
	int		i_maxsleep;		/* max sleep in ms */
};
#define	SIOCS80211POWER		 _IOW('i', 234, struct ieee80211_power)
#define	SIOCG80211POWER		_IOWR('i', 235, struct ieee80211_power)

/* authentication type */
struct ieee80211_auth {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	int		i_authtype;
};

#define	IEEE80211_AUTH_NONE	0
#define	IEEE80211_AUTH_OPEN	1
#define	IEEE80211_AUTH_SHARED	2

#define	SIOCS80211AUTH		 _IOW('i', 236, struct ieee80211_auth)
#define	SIOCG80211AUTH		_IOWR('i', 237, struct ieee80211_auth)

/* channel request */
struct ieee80211chanreq {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	u_int16_t	i_channel;
};

#ifndef _KERNEL
/*
 * Channels are specified by frequency and attributes.
 */
struct ieee80211_channel {
	u_int16_t	ic_freq;	/* setting in MHz */
	u_int16_t	ic_flags;	/* see below */
};

/*
 * Channel attributes (XXX must keep in sync with radiotap flags).
 */
#define IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
#define IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
#define IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel */
#define IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
#define IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
#define IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
#define IEEE80211_CHAN_XR	0x1000	/* Extended range OFDM channel */
#define IEEE80211_CHAN_HT	0x2000	/* 11n/HT channel */
#endif	/* !_KERNEL */

struct ieee80211_chanreq_all {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	struct ieee80211_channel *i_chans;
};

#ifndef IEEE80211_CHAN_ANY
#define	IEEE80211_CHAN_ANY	0xffff
#endif

#define	SIOCS80211CHANNEL	 _IOW('i', 238, struct ieee80211chanreq)
#define	SIOCG80211CHANNEL	_IOWR('i', 239, struct ieee80211chanreq)
#define	SIOCG80211ALLCHANS	_IOWR('i', 215, struct ieee80211_chanreq_all)

/* BSS identifier */
struct ieee80211_bssid {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	u_int8_t	i_bssid[IEEE80211_ADDR_LEN];
};

#define	SIOCS80211BSSID		 _IOW('i', 240, struct ieee80211_bssid)
#define	SIOCG80211BSSID		_IOWR('i', 241, struct ieee80211_bssid)

/* transmit power */
struct ieee80211_txpower {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	int		i_mode;			/* auto, manual */
	int16_t		i_val;			/* dBm */
};

#define	SIOCS80211TXPOWER	 _IOW('i', 243, struct ieee80211_txpower)
#define	SIOCG80211TXPOWER	_IOWR('i', 244, struct ieee80211_txpower)

#define IEEE80211_TXPOWER_MODE_FIXED	0	/* fixed tx power value */
#define IEEE80211_TXPOWER_MODE_AUTO	1	/* auto level control */

struct ieee80211_wpapsk {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	int		i_enabled;
	u_int8_t	i_psk[32];
};

#define SIOCS80211WPAPSK	 _IOW('i', 245, struct ieee80211_wpapsk)
#define SIOCG80211WPAPSK	_IOWR('i', 246, struct ieee80211_wpapsk)

#define IEEE80211_WPA_PROTO_WPA1	0x01
#define IEEE80211_WPA_PROTO_WPA2	0x02

#define IEEE80211_WPA_CIPHER_NONE	0x00
#define IEEE80211_WPA_CIPHER_USEGROUP	0x01
#define IEEE80211_WPA_CIPHER_WEP40	0x02
#define IEEE80211_WPA_CIPHER_TKIP	0x04
#define IEEE80211_WPA_CIPHER_CCMP	0x08
#define IEEE80211_WPA_CIPHER_WEP104	0x10
#define IEEE80211_WPA_CIPHER_BIP	0x20

#define IEEE80211_WPA_AKM_PSK		0x01
#define IEEE80211_WPA_AKM_8021X		0x02
#define IEEE80211_WPA_AKM_SHA256_PSK	0x04
#define IEEE80211_WPA_AKM_SHA256_8021X	0x08

struct ieee80211_wpaparams {
	char	i_name[IFNAMSIZ];		/* if_name, e.g. "wi0" */
	int	i_enabled;
	u_int	i_protos;
	u_int	i_akms;
	u_int	i_ciphers;
	u_int	i_groupcipher;
};

#define SIOCS80211WPAPARMS	 _IOW('i', 247, struct ieee80211_wpaparams)
#define SIOCG80211WPAPARMS	_IOWR('i', 248, struct ieee80211_wpaparams)

struct ieee80211_wmmparams {
	char	i_name[IFNAMSIZ];		/* if_name, e.g. "wi0" */
	int	i_enabled;
	/* XXX more */
};

#define SIOCS80211WMMPARMS	 _IOW('i', 249, struct ieee80211_wmmparams)
#define SIOCG80211WMMPARMS	_IOWR('i', 250, struct ieee80211_wmmparams)

struct ieee80211_keyavail {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	u_int8_t	i_macaddr[IEEE80211_ADDR_LEN];
	u_int8_t	i_key[32];
	u_int32_t	i_lifetime;
};

struct ieee80211_keyrun {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	u_int8_t	i_macaddr[IEEE80211_ADDR_LEN];
};

#define SIOCS80211KEYAVAIL	 _IOW('i', 251, struct ieee80211_keyavail)
#define SIOCS80211KEYRUN	 _IOW('i', 252, struct ieee80211_keyrun)

/* scan request (will block) */
#define IEEE80211_SCAN_TIMEOUT	30	/* timeout in seconds */

#define SIOCS80211SCAN		 _IOW('i', 210, struct ifreq)

/* node and requests */
struct ieee80211_nodereq {
	char		nr_ifname[IFNAMSIZ];		/* e.g. "ath0" */

	/* Node address and name information */
	u_int8_t	nr_macaddr[IEEE80211_ADDR_LEN];	/* node lladdr */
	u_int8_t	nr_bssid[IEEE80211_ADDR_LEN];	/* bssid */
	u_int8_t	nr_nwid_len;			/* ESSID length */
	u_int8_t	nr_nwid[IEEE80211_NWID_LEN];	/* ESSID */

	/* Channel and rates */
	u_int16_t	nr_channel;			/* last channel */
	u_int16_t	nr_chan_flags;			/* channel flags */
	u_int8_t	nr_nrates;			/* rate count */
	u_int8_t	nr_rates[IEEE80211_RATE_MAXSIZE];	/* rate set */

	/* Node status information */
	int8_t		nr_rssi;	/* received signal strength */
	int8_t		nr_max_rssi;	/* maximum rssi */
	u_int8_t	nr_tstamp[8];	/* from last received beacon */
	u_int16_t	nr_intval;	/* beacon interval */
	u_int16_t	nr_capinfo;	/* capabilities */
	u_int16_t	nr_fhdwell;	/* FH only */
	u_int8_t	nr_fhindex;	/* FH only */
	u_int8_t	nr_erp;		/* 11g only */
	u_int8_t	nr_pwrsave;	/* power saving mode */
	u_int16_t	nr_associd;	/* assoc response */
	u_int16_t	nr_txseq;	/* seq to be transmitted */
	u_int16_t	nr_rxseq;	/* seq previous received */
	u_int32_t	nr_fails;	/* failure count to associate */
	u_int32_t	nr_inact;	/* inactivity mark count */
	u_int8_t	nr_txrate;	/* index to nr_rates[] */
	u_int16_t	nr_state;	/* node state in the cache */

	/* RSN */
	u_int		nr_rsnprotos;
	u_int		nr_rsnciphers;
	u_int		nr_rsnakms;

	/* Node flags */
	u_int8_t	nr_flags;

	/* HT */
	uint16_t		nr_htcaps;
	uint8_t			nr_rxmcs[howmany(80,NBBY)];
	uint16_t		nr_max_rxrate;	/* in Mb/s, 0 <= rate <= 1023 */
	uint8_t			nr_tx_mcs_set;
	uint8_t			nr_txmcs;
};

#define IEEE80211_NODEREQ_STATE(_s)	(1 << _s)
#define IEEE80211_NODEREQ_STATE_BITS					\
	"\20\01CACHE\02BSS\03AUTH\04ASSOC\05COLLECT"

#define IEEE80211_NODEREQ_RSSI(_nr)					\
	((u_int)(((float)(_nr)->nr_rssi / (_nr)->nr_max_rssi) * 100))

#define IEEE80211_NODEREQ_STA		0x00	/* station */
#define IEEE80211_NODEREQ_AP		0x01	/* access point */
#define IEEE80211_NODEREQ_AP_BSS	0x02	/* current bss access point */
#define IEEE80211_NODEREQ_COPY		0x04	/* add node with flags */
#define IEEE80211_NODEREQ_HT		0x08	/* HT negotiated */

#define SIOCG80211NODE		_IOWR('i', 211, struct ieee80211_nodereq)
#define SIOCS80211NODE		 _IOW('i', 212, struct ieee80211_nodereq)
#define SIOCS80211DELNODE	 _IOW('i', 213, struct ieee80211_nodereq)

/* get the entire node cache */
struct ieee80211_nodereq_all {
	char				na_ifname[IFNAMSIZ];	/* e.g. "ath0" */

	int				na_nodes;	/* returned count */
	size_t				na_size;	/* size of node buffer */
	struct ieee80211_nodereq	*na_node;	/* allocated node buffer */

	/* Match nodes by flag */
	u_int8_t			na_flags;	/* IEEE80211_NODEREQ_* */
};

#define SIOCG80211ALLNODES	_IOWR('i', 214, struct ieee80211_nodereq_all)

/* net80211 specific interface flags */
#define IEEE80211_F_HIDENWID	0x10000000	/* CONF: hidden ssid mode */
#define IEEE80211_F_NOBRIDGE	0x20000000	/* CONF: no internal bridging */
#define IEEE80211_F_HOSTAPMASK	0x30000000
#define IEEE80211_F_USERSHIFT	28
#define IEEE80211_F_USERBITS	"\20\01HIDENWID\02NOBRIDGE"

struct ieee80211_flags {
	const char		*f_name;
	u_int			f_flag;
};

#define IEEE80211_FLAGS	{						\
	{ "hidenwid", IEEE80211_F_HIDENWID >> IEEE80211_F_USERSHIFT },	\
	{ "nobridge", IEEE80211_F_NOBRIDGE >> IEEE80211_F_USERSHIFT }	\
}

#define SIOCG80211FLAGS		_IOWR('i', 216, struct ifreq)
#define SIOCS80211FLAGS		 _IOW('i', 217, struct ifreq)

#endif /* _NET80211_IEEE80211_IOCTL_H_ */
@


1.27
log
@Expose more 802.11n information to userspace:
A flag which indicates whether HT has been negotiated with a node,
and the current Tx MCS value we use for a node.

This grows struct ieee80211_nodereq. Applications using it must be recompiled.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.26 2016/04/28 14:46:10 stsp Exp $	*/
d331 1
@


1.26
log
@Add a net80211 stat counter for block ack window "slides" as opposed
to "jumps". Will be used soon by refined block ack window handling.
netstat needs to be recompiled.
With and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.25 2016/04/28 13:50:14 stsp Exp $	*/
d342 1
d356 1
@


1.25
log
@Copy some ieee8021_node HT information to userspace.
ifconfig needs to be recompiled.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.24 2016/04/27 11:58:10 stsp Exp $	*/
d106 1
@


1.24
log
@Add some stat counters for events related to 802.11n.
netstat(1) needs to be recompiled to work with new kernel.
ok deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.23 2016/01/12 09:28:09 stsp Exp $	*/
d335 6
@


1.23
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.22 2015/11/15 01:05:25 stsp Exp $	*/
d98 14
@


1.22
log
@Declare 802.11n mode and channel flags. Tweak 11n related fields in struct
ieee80211com and move them inside #ifndef IEEE80211_NO_HT without breaking
the build in rsu(4) for RAMDISK_CD.
Also declare 11n protection modes and MCS count.
ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.21 2015/01/09 20:34:21 sthen Exp $	*/
a169 1
#define IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
@


1.21
log
@Change rssi passed to ifconfig(8) to a signed value to fix printing signal
strengths on 802.11 interfaces.  ok stsp@@

Power on wireless interfaces is usually scaled in dBm. rssi (received signal
strength) is expected to be a -ve dBm values (i.e. [much] <1mW). Some (though
not all!) drivers store this as negative values, so it needs to be passed to
ifconfig that way for printing, not cast to an unsigned value. Valid range is
something like -40 to -90dBm, so the range available with a signed char is
reasonable whether it's stored as a +ve or -ve number.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.20 2014/08/24 18:01:27 zhuk Exp $	*/
d178 1
@


1.20
log
@Fix wrong IEEE 802.11 ioctl's:

  * SIOCG80211ALLNODES operates on struct ieee80211_nodereq_all, not
    struct ieee80211_nodereq.

  * Six SIOC* from wi(4) were using same codes with generic parts of
    IEEE 802.11 framework. Things worked due to the fact that size
    of data struct being passed is encoded in actual SIOC*, too.

This commit means that ifconfig and some ports will need to be rebuilt,
if any of affected SIOC* codes is used. Port bumps to follow.

First part okay reyk@@, whole diff okay mpi@@
Heavy prodding to commit now from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.19 2014/07/10 14:32:28 stsp Exp $	*/
d298 2
a299 2
	u_int8_t	nr_rssi;	/* received signal strength */
	u_int8_t	nr_max_rssi;	/* maximum rssi */
@


1.19
log
@Return RSN (WPA) information to userland during wireless scan, and
make ifconfig show whether a wireless network uses WEP or WPA.
Since struct ieee80211_nodereq grows in size old ifconfig won't be
able to scan when running on a new kernel.
While here, add missing ioctl constant IEEE80211_WPA_CIPHER_BIP.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.18 2011/03/04 23:48:15 fgsch Exp $	*/
d351 1
a351 1
#define SIOCG80211ALLNODES	_IOWR('i', 214, struct ieee80211_nodereq)
@


1.18
log
@kill is_rx_elem_unknown.
damien@@ ok. ports checked by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.17 2009/02/15 08:34:36 damien Exp $	*/
d233 1
d315 3
a317 1
	/* XXX RSN */
@


1.17
log
@make "ifconfig if0 chan" list the channels supported by the device.
add "ifconfig if0 scan" to scan for access points or to list known
stations in Host AP mode.
remove the [-]wmm command while i'm here.  QoS is mandatory with
802.11n so there's not much point into making it an option.
fix parsing of the "powersave" command too.

discussed with deraadt@@
man page hints from jmc@@
display hints from sobrado@@
"i like it" cnst@@, grange@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.16 2009/02/13 17:24:54 damien Exp $	*/
a58 1
	u_int32_t	is_rx_elem_unknown;	/* rx element unknown */
@


1.16
log
@Change ifconfig wpaakms default setting to `psk' instead of `psk,802.1x'.
Some supplicants will autoselect 802.1X without giving users the
possibility to choose between PSK or 802.1X.

Similarly, no longer announce `PSK with SHA-256 based KDF' AKMP (defined
in Draft 802.11w) by default in the RSN IE of beacons and probe responses
as it confuses some broken supplicants.  This kind of sacrifies security
for interoperability with shitty (but unfortunately widespread) clients
that do not follow the 802.11 standard properly.
This fixes associations from Intel PROSet on XP and also reportedly fixes
some Mac OS clients.  I will likely make `psk-sha256' configurable through
ifconfig wpaakms after the 4.5 release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.15 2009/01/26 19:09:41 damien Exp $	*/
d159 27
d192 1
@


1.15
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.14 2008/09/27 15:16:09 damien Exp $	*/
d208 3
a210 1
#define IEEE80211_WPA_AKM_IEEE8021X	0x02
@


1.14
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.13 2008/08/12 16:51:39 damien Exp $	*/
d98 1
@


1.13
log
@Welcome BIP: the Broadcast/Multicast Integrity Protocol defined
in Draft IEEE P802.11w.
It provides data integrity and replay protection for broadcast/
multicast robust management frames (not used yet) using AES-128
in CMAC mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.12 2008/08/12 16:45:44 damien Exp $	*/
d229 15
@


1.12
log
@maintain a count of TKIP and CCMP replayed frames.
some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.11 2008/04/16 18:32:15 damien Exp $	*/
d96 2
@


1.11
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.10 2007/08/14 20:33:47 bluhm Exp $	*/
d92 4
@


1.10
log
@Prevent sneaking in unencrypted packets into WEP traffic.
ok damien@@, put it ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.9 2007/07/06 19:33:58 damien Exp $	*/
d85 7
d181 43
d262 2
@


1.9
log
@have ieee80211_parse_rsn() return a reason code so that we can
deauth associating stations with bad RSN IEs.
cleanup parsing of vendor-specific IEs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.8 2007/06/06 19:31:07 damien Exp $	*/
d50 1
@


1.8
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.7 2006/06/27 20:55:51 reyk Exp $	*/
d83 1
@


1.7
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.6 2006/06/23 21:34:15 reyk Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.6
log
@add an optional max_rssi attribute to the ieee80211com structure and
allow to export the RSSI Max value with ioctls and by radiotap
headers.

ok damien@@ jsg@@

description:

we currently use "dB" as an indication for the signal strength in
ifconfig and in the radiotap headers. it means "decibel difference
from an arbitrary, fixed reference". this is quite confusing, because
different chipsets have different references for the dB/rssi values.

we can use the plain RSSI which is described in IEEE 802.11: "The
receive signal strength indicator (RSSI) is an optional parameter that
has a value of 0 through RSSI Max.". all wireless chipsets have
something like a RSSI (normally as a Rx descriptor field), but the
value for RSSI Max is chipset-specific.

if we know the RSSI Max, we can calculate a percentage which is much
easier to understand for the user. we even don't have to use the
absolute RSSI Max, we can use an average RSSI Max, figured out by
monitoring and tuning the RSSI Max of the drivers. if the user gets a
signal of 110%, it would mean "better than the average Max signal".

there's no need to do any RSSI calculations in the kernel, it just
passes the the relative rssi and max_rssi values to userspace. this is
done in the ieee80211_nodereq ioctl structure and possible with a new
radiotap header. the radiotap RSSI header allows to get a flexible but
common signal indicator instead of the complex and unrelated dB/dBm
signal fields. it must include two 8bit values current rssi and RSSI
max.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.5 2005/09/08 13:24:52 reyk Exp $	*/
d248 20
@


1.5
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.4 2005/05/25 07:40:49 reyk Exp $	*/
d199 1
d222 3
@


1.4
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.3 2005/02/27 22:27:56 reyk Exp $	*/
d219 2
a220 1
#define IEEE80211_NODEREQ_STATE_BITS	"\20\01CACHE\02BSS\03AUTH\04ASSOC\05COLLECT"
@


1.3
log
@remove dead code of unsupported ioctls from FreeBSD. we do it in a
different way.

ok deraadt@@, martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.2 2005/02/15 19:44:15 reyk Exp $	*/
d44 1
d89 3
a91 1
/* nwid is pointed at by ifr.ifr_data */
d100 1
a100 1
/* the first member must be matched with struct ifreq */
d110 1
a110 3
#define	SIOCS80211NWKEY		 _IOW('i', 232, struct ieee80211_nwkey)
#define	SIOCG80211NWKEY		_IOWR('i', 233, struct ieee80211_nwkey)
/* i_wepon */
d116 3
d128 1
d141 1
d154 1
d163 1
a163 2
#define	SIOCG80211STATS		_IOWR('i', 242, struct ifreq)

d175 68
@


1.2
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_ioctl.h,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
a87 51
#ifdef __FreeBSD__
/*
 * FreeBSD-style ioctls.
 */
/* the first member must be matched with struct ifreq */
struct ieee80211req {
	char		i_name[IFNAMSIZ];	/* if_name, e.g. "wi0" */
	u_int16_t	i_type;			/* req type */
	int16_t		i_val;			/* Index or simple value */
	int16_t		i_len;			/* Index or simple value */
	void		*i_data;		/* Extra data */
};
#define	SIOCS80211		 _IOW('i', 234, struct ieee80211req)
#define	SIOCG80211		_IOWR('i', 235, struct ieee80211req)

#define IEEE80211_IOC_SSID		1
#define IEEE80211_IOC_NUMSSIDS		2
#define IEEE80211_IOC_WEP		3
#define 	IEEE80211_WEP_NOSUP	-1
#define 	IEEE80211_WEP_OFF	0
#define 	IEEE80211_WEP_ON	1
#define 	IEEE80211_WEP_MIXED	2
#define IEEE80211_IOC_WEPKEY		4
#define IEEE80211_IOC_NUMWEPKEYS	5
#define IEEE80211_IOC_WEPTXKEY		6
#define IEEE80211_IOC_AUTHMODE		7
#define IEEE80211_IOC_STATIONNAME	8
#define IEEE80211_IOC_CHANNEL		9
#define IEEE80211_IOC_POWERSAVE		10
#define 	IEEE80211_POWERSAVE_NOSUP	-1
#define 	IEEE80211_POWERSAVE_OFF		0
#define 	IEEE80211_POWERSAVE_CAM		1
#define 	IEEE80211_POWERSAVE_PSP		2
#define 	IEEE80211_POWERSAVE_PSP_CAM	3
#define 	IEEE80211_POWERSAVE_ON		IEEE80211_POWERSAVE_CAM
#define IEEE80211_IOC_POWERSAVESLEEP	11
#define	IEEE80211_IOC_RTSTHRESHOLD	12
#define IEEE80211_IOC_PROTMODE		13
#define 	IEEE80211_PROTMODE_OFF		0
#define 	IEEE80211_PROTMODE_CTS		1
#define 	IEEE80211_PROTMODE_RTSCTS	2
#define IEEE80211_IOC_TXPOWER		14

#ifndef IEEE80211_CHAN_ANY
#define	IEEE80211_CHAN_ANY	0xffff		/* token for ``any channel'' */
#endif

#define	SIOCG80211STATS		_IOWR('i', 236, struct ifreq)
#endif /* __FreeBSD__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
a168 2

#endif
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$OpenBSD$	*/
d208 13
@

