head	1.118;
access;
symbols
	OPENBSD_6_2:1.118.0.2
	OPENBSD_6_2_BASE:1.118
	OPENBSD_6_1:1.118.0.4
	OPENBSD_6_1_BASE:1.118
	OPENBSD_6_0:1.111.0.2
	OPENBSD_6_0_BASE:1.111
	OPENBSD_5_9:1.110.0.2
	OPENBSD_5_9_BASE:1.110
	OPENBSD_5_8:1.97.0.4
	OPENBSD_5_8_BASE:1.97
	OPENBSD_5_7:1.93.0.2
	OPENBSD_5_7_BASE:1.93
	OPENBSD_5_6:1.91.0.4
	OPENBSD_5_6_BASE:1.91
	OPENBSD_5_5:1.89.0.4
	OPENBSD_5_5_BASE:1.89
	OPENBSD_5_4:1.88.0.14
	OPENBSD_5_4_BASE:1.88
	OPENBSD_5_3:1.88.0.12
	OPENBSD_5_3_BASE:1.88
	OPENBSD_5_2:1.88.0.10
	OPENBSD_5_2_BASE:1.88
	OPENBSD_5_1_BASE:1.88
	OPENBSD_5_1:1.88.0.8
	OPENBSD_5_0:1.88.0.6
	OPENBSD_5_0_BASE:1.88
	OPENBSD_4_9:1.88.0.4
	OPENBSD_4_9_BASE:1.88
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.87.0.4
	OPENBSD_4_6_BASE:1.87
	OPENBSD_4_5:1.83.0.2
	OPENBSD_4_5_BASE:1.83
	OPENBSD_4_4:1.66.0.2
	OPENBSD_4_4_BASE:1.66
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.118
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.117;
commitid	PETPfbQ5ZWdJqIYS;

1.117
date	2017.01.31.11.06.15;	author stsp;	state Exp;
branches;
next	1.116;
commitid	5rybxaiaACEyUZvZ;

1.116
date	2017.01.31.09.39.27;	author stsp;	state Exp;
branches;
next	1.115;
commitid	Fv523RsT7kYntBaJ;

1.115
date	2017.01.30.18.21.13;	author stsp;	state Exp;
branches;
next	1.114;
commitid	w2LbgTYoQ2p1IyTt;

1.114
date	2017.01.09.16.24.20;	author stsp;	state Exp;
branches;
next	1.113;
commitid	2R4xID7oIXEJOE2Q;

1.113
date	2017.01.09.13.01.37;	author stsp;	state Exp;
branches;
next	1.112;
commitid	qd4T28XczxoOsKsr;

1.112
date	2017.01.09.09.30.02;	author stsp;	state Exp;
branches;
next	1.111;
commitid	ixfrgSxBuSUvZF6u;

1.111
date	2016.04.12.14.33.27;	author mpi;	state Exp;
branches;
next	1.110;
commitid	0LA0xiKsLRo4rVjB;

1.110
date	2016.02.05.19.11.31;	author stsp;	state Exp;
branches;
next	1.109;
commitid	TUhFaIKWHpAU462I;

1.109
date	2016.02.05.16.07.57;	author stsp;	state Exp;
branches;
next	1.108;
commitid	xkYUdKYZXQrBH3Sl;

1.108
date	2016.01.21.20.33.20;	author stsp;	state Exp;
branches;
next	1.107;
commitid	NTJ00Ve3Ie13NV6I;

1.107
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.106;
commitid	1npmDuWgN1zBR6BQ;

1.106
date	2016.01.06.19.56.50;	author stsp;	state Exp;
branches;
next	1.105;
commitid	vqkvQcVZc1K7MmHQ;

1.105
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.104;
commitid	2QagMjdMhQhIaQgu;

1.104
date	2016.01.04.13.29.04;	author stsp;	state Exp;
branches;
next	1.103;
commitid	ACktK8irmoCvha3m;

1.103
date	2016.01.04.12.32.06;	author stsp;	state Exp;
branches;
next	1.102;
commitid	4X5pVUcDTAvM2jfa;

1.102
date	2015.12.12.11.31.48;	author stsp;	state Exp;
branches;
next	1.101;
commitid	EBnB8TwMx3GtMtNg;

1.101
date	2015.11.24.12.32.53;	author mpi;	state Exp;
branches;
next	1.100;
commitid	N4FwuXZDsGAH4cQz;

1.100
date	2015.11.15.01.05.25;	author stsp;	state Exp;
branches;
next	1.99;
commitid	8QkBLu4fXKUF5YHk;

1.99
date	2015.11.08.18.48.07;	author stsp;	state Exp;
branches;
next	1.98;
commitid	AsYxGnv8IL7VhokH;

1.98
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.97;
commitid	YT6fyIEviv9qwbl6;

1.97
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.96;
commitid	ncpqEGjDtSFuLAgn;

1.96
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.95;
commitid	fE8TgA9vpwdUU5Wy;

1.95
date	2015.05.26.15.34.00;	author mpi;	state Exp;
branches;
next	1.94;
commitid	Eqi0E8Lq2fFITtoM;

1.94
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.93;
commitid	p4LJxGKbi0BU2cG6;

1.93
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.92;
commitid	PYnSnAqgemmk34E3;

1.92
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.91;
commitid	uzzBR7hz9ncd4O6G;

1.91
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.90;
commitid	DQakU8LLWV6Iwx84;

1.90
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.89;

1.89
date	2013.12.07.01.55.06;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.17.16.30.01;	author damien;	state Exp;
branches;
next	1.87;

1.87
date	2009.05.24.07.46.04;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2009.05.19.16.09.02;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2009.03.26.20.34.54;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.06.18.35.02;	author damien;	state Exp;
branches;
next	1.83;

1.83
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.26.21.28.55;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.02.17.37.11;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2008.09.27.15.00.08;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2008.09.03.19.53.37;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.01.19.55.21;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.09.01.19.43.33;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.09.01.19.41.10;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.15.08.15.27;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2008.08.12.19.56.59;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2008.08.12.19.21.04;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2008.08.12.19.05.39;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.02.08.35.48;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2008.08.02.08.33.21;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2008.08.02.08.20.16;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.23.15.55.46;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2008.07.21.19.05.21;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.27.20.14.21;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2007.08.27.18.53.27;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.22.20.40.34;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.05.21.41.11;	author claudio;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.03.16.51.06;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.01.13.10.01;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.01.12.47.55;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.01.12.26.16;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.01.12.15.48;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.01.11.59.40;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2007.07.28.11.24.06;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.14.19.58.05;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.13.19.59.56;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.06.19.00.56;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.06.18.18.43;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.05.21.35.45;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.05.20.29.22;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.05.20.19.21;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.04.20.18.00;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.03.20.25.32;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.03.19.44.54;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.03.16.43.41;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.03.16.10.38;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.03.16.07.10;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.03.16.03.48;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.03.16.00.07;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.02.16.46.44;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.02.16.19.49;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.21.21.06.12;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.21.20.38.55;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.16.11.59.58;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.11.19.35.24;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.07.20.20.15;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.25.19.24.26;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.03.19.02.08;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.21.07.47.26;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.19.18.14.35;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.19.18.06.51;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.20.20.12.14;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.11.00.18.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.20.19.52.43;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.11.23.20.26;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.03.14.36.41;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.26.15.49.34;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.28.23.07.32;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.23.12.27.25;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.23.11.54.09;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.118
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@/*	$OpenBSD: ieee80211_output.c,v 1.117 2017/01/31 11:06:15 stsp Exp $	*/
/*	$NetBSD: ieee80211_output.c,v 1.13 2004/05/31 11:02:55 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * Copyright (c) 2007-2009 Damien Bergamini
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"
#include "vlan.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_llc.h>
#include <net/bpf.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip.h>
#ifdef INET6
#include <netinet/ip6.h>
#endif

#if NVLAN > 0
#include <net/if_vlan_var.h>
#endif

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

int	ieee80211_classify(struct ieee80211com *, struct mbuf *);
int	ieee80211_mgmt_output(struct ifnet *, struct ieee80211_node *,
	    struct mbuf *, int);
u_int8_t *ieee80211_add_rsn_body(u_int8_t *, struct ieee80211com *,
	    const struct ieee80211_node *, int);
struct	mbuf *ieee80211_getmgmt(int, int, u_int);
struct	mbuf *ieee80211_get_probe_req(struct ieee80211com *,
	    struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
struct	mbuf *ieee80211_get_probe_resp(struct ieee80211com *,
	    struct ieee80211_node *);
#endif
struct	mbuf *ieee80211_get_auth(struct ieee80211com *,
	    struct ieee80211_node *, u_int16_t, u_int16_t);
struct	mbuf *ieee80211_get_deauth(struct ieee80211com *,
	    struct ieee80211_node *, u_int16_t);
struct	mbuf *ieee80211_get_assoc_req(struct ieee80211com *,
	    struct ieee80211_node *, int);
#ifndef IEEE80211_STA_ONLY
struct	mbuf *ieee80211_get_assoc_resp(struct ieee80211com *,
	    struct ieee80211_node *, u_int16_t);
#endif
struct	mbuf *ieee80211_get_disassoc(struct ieee80211com *,
	    struct ieee80211_node *, u_int16_t);
struct	mbuf *ieee80211_get_addba_req(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t);
struct	mbuf *ieee80211_get_addba_resp(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t, u_int8_t, u_int16_t);
struct	mbuf *ieee80211_get_delba(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t, u_int8_t, u_int16_t);
uint8_t *ieee80211_add_wme_info(uint8_t *, struct ieee80211com *);
#ifndef IEEE80211_STA_ONLY
uint8_t *ieee80211_add_wme_param(uint8_t *, struct ieee80211com *);
#endif
struct	mbuf *ieee80211_get_sa_query(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t);
struct	mbuf *ieee80211_get_action(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t, u_int8_t, int);

/*
 * IEEE 802.11 output routine. Normally this will directly call the
 * Ethernet output routine because 802.11 encapsulation is called
 * later by the driver. This function can be used to send raw frames
 * if the mbuf has been tagged with a 802.11 data link type.
 */
int
ieee80211_output(struct ifnet *ifp, struct mbuf *m, struct sockaddr *dst,
    struct rtentry *rt)
{
	struct ieee80211_frame *wh;
	struct m_tag *mtag;
	int error = 0;

	/* Interface has to be up and running */
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) !=
	    (IFF_UP | IFF_RUNNING)) {
		error = ENETDOWN;
		goto bad;
	}

	/* Try to get the DLT from a mbuf tag */
	if ((mtag = m_tag_find(m, PACKET_TAG_DLT, NULL)) != NULL) {
		struct ieee80211com *ic = (void *)ifp;
		u_int dlt = *(u_int *)(mtag + 1);

		/* Fallback to ethernet for non-802.11 linktypes */
		if (!(dlt == DLT_IEEE802_11 || dlt == DLT_IEEE802_11_RADIO))
			goto fallback;

		if (m->m_pkthdr.len < sizeof(struct ieee80211_frame_min))
			return (EINVAL);
		wh = mtod(m, struct ieee80211_frame *);
		if ((wh->i_fc[0] & IEEE80211_FC0_VERSION_MASK) !=
		    IEEE80211_FC0_VERSION_0)
			return (EINVAL);
		if (!(ic->ic_caps & IEEE80211_C_RAWCTL) &&
		    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_CTL)
			return (EINVAL);

		return (if_enqueue(ifp, m));
	}

 fallback:
	return (ether_output(ifp, m, dst, rt));

 bad:
	m_freem(m);
	return (error);
}

/*
 * Send a management frame to the specified node.  The node pointer
 * must have a reference as the pointer will be passed to the driver
 * and potentially held for a long time.  If the frame is successfully
 * dispatched to the driver, then it is responsible for freeing the
 * reference (and potentially free'ing up any associated storage).
 */
int
ieee80211_mgmt_output(struct ifnet *ifp, struct ieee80211_node *ni,
    struct mbuf *m, int type)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_frame *wh;

	if (ni == NULL)
		panic("null node");
	ni->ni_inact = 0;

	/*
	 * We want to pass the node down to the driver's start
	 * routine.  We could stick this in an m_tag and tack that
	 * on to the mbuf.  However that's rather expensive to do
	 * for every frame so instead we stuff it in a special pkthdr
	 * field.
	 */
	M_PREPEND(m, sizeof(struct ieee80211_frame), M_DONTWAIT);
	if (m == NULL)
		return ENOMEM;
	m->m_pkthdr.ph_cookie = ni;

	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT | type;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)&wh->i_dur[0] = 0;
	*(u_int16_t *)&wh->i_seq[0] =
	    htole16(ni->ni_txseq << IEEE80211_SEQ_SEQ_SHIFT);
	ni->ni_txseq++;
	IEEE80211_ADDR_COPY(wh->i_addr1, ni->ni_macaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, ni->ni_bssid);

	/* check if protection is required for this mgmt frame */
	if ((ic->ic_caps & IEEE80211_C_MFP) &&
	    (type == IEEE80211_FC0_SUBTYPE_DISASSOC ||
	     type == IEEE80211_FC0_SUBTYPE_DEAUTH ||
	     type == IEEE80211_FC0_SUBTYPE_ACTION)) {
		/*
		 * Hack: we should not set the Protected bit in outgoing
		 * group management frames, however it is used as an
		 * indication to the drivers that they must encrypt the
		 * frame.  Drivers should clear this bit from group
		 * management frames (software crypto code will do it).
		 * XXX could use an mbuf flag..
		 */
		if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
		    (ni->ni_flags & IEEE80211_NODE_TXMGMTPROT))
			wh->i_fc[1] |= IEEE80211_FC1_PROTECTED;
	}

	if (ifp->if_flags & IFF_DEBUG) {
		/* avoid to print too many frames */
		if (
#ifndef IEEE80211_STA_ONLY
		    ic->ic_opmode == IEEE80211_M_IBSS ||
#endif
#ifdef IEEE80211_DEBUG
		    ieee80211_debug > 1 ||
#endif
		    (type & IEEE80211_FC0_SUBTYPE_MASK) !=
		    IEEE80211_FC0_SUBTYPE_PROBE_RESP)
			printf("%s: sending %s to %s on channel %u mode %s\n",
			    ifp->if_xname,
			    ieee80211_mgt_subtype_name[
			    (type & IEEE80211_FC0_SUBTYPE_MASK)
			    >> IEEE80211_FC0_SUBTYPE_SHIFT],
			    ether_sprintf(ni->ni_macaddr),
			    ieee80211_chan2ieee(ic, ni->ni_chan),
			    ieee80211_phymode_name[ic->ic_curmode]);
	}

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
	    ieee80211_pwrsave(ic, m, ni) != 0)
		return 0;
#endif
	mq_enqueue(&ic->ic_mgtq, m);
	ifp->if_timer = 1;
	if_start(ifp);
	return 0;
}

/*-
 * EDCA tables are computed using the following formulas:
 *
 * 1) EDCATable (non-AP QSTA)
 *
 * AC     CWmin 	   CWmax	   AIFSN  TXOP limit(ms)
 * -------------------------------------------------------------
 * AC_BK  aCWmin	   aCWmax	   7	  0
 * AC_BE  aCWmin	   aCWmax	   3	  0
 * AC_VI  (aCWmin+1)/2-1   aCWmin	   2	  agn=3.008 b=6.016 others=0
 * AC_VO  (aCWmin+1)/4-1   (aCWmin+1)/2-1  2	  agn=1.504 b=3.264 others=0
 *
 * 2) QAPEDCATable (QAP)
 *
 * AC     CWmin 	   CWmax	   AIFSN  TXOP limit(ms)
 * -------------------------------------------------------------
 * AC_BK  aCWmin	   aCWmax	   7	  0
 * AC_BE  aCWmin	   4*(aCWmin+1)-1  3	  0
 * AC_VI  (aCWmin+1)/2-1   aCWmin	   1	  agn=3.008 b=6.016 others=0
 * AC_VO  (aCWmin+1)/4-1   (aCWmin+1)/2-1  1	  agn=1.504 b=3.264 others=0
 *
 * and the following aCWmin/aCWmax values:
 *
 * PHY		aCWmin	aCWmax
 * ---------------------------
 * 11A		15	1023
 * 11B  	31	1023
 * 11G		15*	1023	(*) aCWmin(1)
 * 11N		15	1023
 */
const struct ieee80211_edca_ac_params
    ieee80211_edca_table[IEEE80211_MODE_MAX][EDCA_NUM_AC] = {
	[IEEE80211_MODE_11B] = {
		[EDCA_AC_BK] = { 5, 10, 7,   0 },
		[EDCA_AC_BE] = { 5, 10, 3,   0 },
		[EDCA_AC_VI] = { 4,  5, 2, 188 },
		[EDCA_AC_VO] = { 3,  4, 2, 102 }
	},
	[IEEE80211_MODE_11A] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4, 10, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 2,  94 },
		[EDCA_AC_VO] = { 2,  3, 2,  47 }
	},
	[IEEE80211_MODE_11G] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4, 10, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 2,  94 },
		[EDCA_AC_VO] = { 2,  3, 2,  47 }
	},
	[IEEE80211_MODE_11N] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4, 10, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 2,  94 },
		[EDCA_AC_VO] = { 2,  3, 2,  47 }
	},
};

#ifndef IEEE80211_STA_ONLY
const struct ieee80211_edca_ac_params
    ieee80211_qap_edca_table[IEEE80211_MODE_MAX][EDCA_NUM_AC] = {
	[IEEE80211_MODE_11B] = {
		[EDCA_AC_BK] = { 5, 10, 7,   0 },
		[EDCA_AC_BE] = { 5,  7, 3,   0 },
		[EDCA_AC_VI] = { 4,  5, 1, 188 },
		[EDCA_AC_VO] = { 3,  4, 1, 102 }
	},
	[IEEE80211_MODE_11A] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4,  6, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 1,  94 },
		[EDCA_AC_VO] = { 2,  3, 1,  47 }
	},
	[IEEE80211_MODE_11G] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4,  6, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 1,  94 },
		[EDCA_AC_VO] = { 2,  3, 1,  47 }
	},
	[IEEE80211_MODE_11N] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4,  6, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 1,  94 },
		[EDCA_AC_VO] = { 2,  3, 1,  47 }
	},
};
#endif	/* IEEE80211_STA_ONLY */

/*
 * Return the EDCA Access Category to be used for transmitting a frame with
 * user-priority `up'.
 */
enum ieee80211_edca_ac
ieee80211_up_to_ac(struct ieee80211com *ic, int up)
{
	/* see Table 9-1 */
	static const enum ieee80211_edca_ac up_to_ac[] = {
		EDCA_AC_BE,	/* BE */
		EDCA_AC_BK,	/* BK */
		EDCA_AC_BK,	/* -- */
		EDCA_AC_BE,	/* EE */
		EDCA_AC_VI,	/* CL */
		EDCA_AC_VI,	/* VI */
		EDCA_AC_VO,	/* VO */
		EDCA_AC_VO	/* NC */
	};
	enum ieee80211_edca_ac ac;

	ac = (up <= 7) ? up_to_ac[up] : EDCA_AC_BE;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		return ac;
#endif
	/*
	 * We do not support the admission control procedure defined in
	 * IEEE Std 802.11-2012 section 9.19.4.2.3. The spec says that
	 * non-AP QSTAs that don't support this procedure shall use EDCA
	 * parameters of a lower priority AC that does not require
	 * admission control.
	 */
	while (ac != EDCA_AC_BK && ic->ic_edca_ac[ac].ac_acm) {
		switch (ac) {
		case EDCA_AC_BK:
			/* can't get there */
			break;
		case EDCA_AC_BE:
			/* BE shouldn't require admission control */
			ac = EDCA_AC_BK;
			break;
		case EDCA_AC_VI:
			ac = EDCA_AC_BE;
			break;
		case EDCA_AC_VO:
			ac = EDCA_AC_VI;
			break;
		}
	}
	return ac;
}

/*
 * Get mbuf's user-priority: if mbuf is not VLAN tagged, select user-priority
 * based on the DSCP (Differentiated Services Codepoint) field.
 */
int
ieee80211_classify(struct ieee80211com *ic, struct mbuf *m)
{
	struct ether_header *eh;
	u_int8_t ds_field;
#if NVLAN > 0
	if (m->m_flags & M_VLANTAG)	/* use VLAN 802.1D user-priority */
		return EVL_PRIOFTAG(m->m_pkthdr.ether_vtag);
#endif
	eh = mtod(m, struct ether_header *);
	if (eh->ether_type == htons(ETHERTYPE_IP)) {
		struct ip *ip = (struct ip *)&eh[1];
		if (ip->ip_v != 4)
			return 0;
		ds_field = ip->ip_tos;
	}
#ifdef INET6
	else if (eh->ether_type == htons(ETHERTYPE_IPV6)) {
		struct ip6_hdr *ip6 = (struct ip6_hdr *)&eh[1];
		u_int32_t flowlabel;

		flowlabel = ntohl(ip6->ip6_flow);
		if ((flowlabel >> 28) != 6)
			return 0;
		ds_field = (flowlabel >> 20) & 0xff;
	}
#endif	/* INET6 */
	else	/* neither IPv4 nor IPv6 */
		return 0;

	/*
	 * Map Differentiated Services Codepoint field (see RFC2474).
	 * Preserves backward compatibility with IP Precedence field.
	 */
	switch (ds_field & 0xfc) {
	case IPTOS_PREC_PRIORITY:
		return 2;
	case IPTOS_PREC_IMMEDIATE:
		return 1;
	case IPTOS_PREC_FLASH:
		return 3;
	case IPTOS_PREC_FLASHOVERRIDE:
		return 4;
	case IPTOS_PREC_CRITIC_ECP:
		return 5;
	case IPTOS_PREC_INTERNETCONTROL:
		return 6;
	case IPTOS_PREC_NETCONTROL:
		return 7;
	}
	return 0;	/* default to Best-Effort */
}

/*
 * Encapsulate an outbound data frame.  The mbuf chain is updated and
 * a reference to the destination node is returned.  If an error is
 * encountered NULL is returned and the node reference will also be NULL.
 *
 * NB: The caller is responsible for free'ing a returned node reference.
 *     The convention is ic_bss is not reference counted; the caller must
 *     maintain that.
 */
struct mbuf *
ieee80211_encap(struct ifnet *ifp, struct mbuf *m, struct ieee80211_node **pni)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ether_header eh;
	struct ieee80211_frame *wh;
	struct ieee80211_node *ni = NULL;
	struct llc *llc;
	struct m_tag *mtag;
	u_int8_t *addr;
	u_int dlt, hdrlen;
	int addqos, tid;

	/* Handle raw frames if mbuf is tagged as 802.11 */
	if ((mtag = m_tag_find(m, PACKET_TAG_DLT, NULL)) != NULL) {
		dlt = *(u_int *)(mtag + 1);

		if (!(dlt == DLT_IEEE802_11 || dlt == DLT_IEEE802_11_RADIO))
			goto fallback;

		wh = mtod(m, struct ieee80211_frame *);
		switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
		case IEEE80211_FC1_DIR_NODS:
		case IEEE80211_FC1_DIR_FROMDS:
			addr = wh->i_addr1;
			break;
		case IEEE80211_FC1_DIR_DSTODS:
		case IEEE80211_FC1_DIR_TODS:
			addr = wh->i_addr3;
			break;
		default:
			goto bad;
		}

		ni = ieee80211_find_txnode(ic, addr);
		if (ni == NULL)
			ni = ieee80211_ref_node(ic->ic_bss);
		if (ni == NULL) {
			printf("%s: no node for dst %s, "
			    "discard raw tx frame\n", ifp->if_xname,
			    ether_sprintf(addr));
			ic->ic_stats.is_tx_nonode++;
			goto bad;
		}
		ni->ni_inact = 0;

		*pni = ni;
		return (m);
	}

 fallback:
	if (m->m_len < sizeof(struct ether_header)) {
		m = m_pullup(m, sizeof(struct ether_header));
		if (m == NULL) {
			ic->ic_stats.is_tx_nombuf++;
			goto bad;
		}
	}
	memcpy(&eh, mtod(m, caddr_t), sizeof(struct ether_header));

	ni = ieee80211_find_txnode(ic, eh.ether_dhost);
	if (ni == NULL) {
		DPRINTF(("no node for dst %s, discard frame\n",
		    ether_sprintf(eh.ether_dhost)));
		ic->ic_stats.is_tx_nonode++;
		goto bad;
	}

	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    !ni->ni_port_valid &&
	    eh.ether_type != htons(ETHERTYPE_PAE)) {
		DPRINTF(("port not valid: %s\n",
		    ether_sprintf(eh.ether_dhost)));
		ic->ic_stats.is_tx_noauth++;
		goto bad;
	}

	if ((ic->ic_flags & IEEE80211_F_COUNTERM) &&
	    ni->ni_rsncipher == IEEE80211_CIPHER_TKIP)
		/* XXX TKIP countermeasures! */;

	ni->ni_inact = 0;

	if ((ic->ic_flags & IEEE80211_F_QOS) &&
	    (ni->ni_flags & IEEE80211_NODE_QOS) &&
	    /* do not QoS-encapsulate EAPOL frames */
	    eh.ether_type != htons(ETHERTYPE_PAE)) {
		tid = ieee80211_classify(ic, m);
		hdrlen = sizeof(struct ieee80211_qosframe);
		addqos = 1;
	} else {
		hdrlen = sizeof(struct ieee80211_frame);
		addqos = 0;
	}
	m_adj(m, sizeof(struct ether_header) - LLC_SNAPFRAMELEN);
	llc = mtod(m, struct llc *);
	llc->llc_dsap = llc->llc_ssap = LLC_SNAP_LSAP;
	llc->llc_control = LLC_UI;
	llc->llc_snap.org_code[0] = 0;
	llc->llc_snap.org_code[1] = 0;
	llc->llc_snap.org_code[2] = 0;
	llc->llc_snap.ether_type = eh.ether_type;
	M_PREPEND(m, hdrlen, M_DONTWAIT);
	if (m == NULL) {
		ic->ic_stats.is_tx_nombuf++;
		goto bad;
	}
	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA;
	*(u_int16_t *)&wh->i_dur[0] = 0;
	if (addqos) {
		struct ieee80211_qosframe *qwh =
		    (struct ieee80211_qosframe *)wh;
		u_int16_t qos = tid;

		if (ic->ic_tid_noack & (1 << tid))
			qos |= IEEE80211_QOS_ACK_POLICY_NOACK;
		else if (ni->ni_tx_ba[tid].ba_state == IEEE80211_BA_AGREED)
			qos |= IEEE80211_QOS_ACK_POLICY_BA;
		qwh->i_fc[0] |= IEEE80211_FC0_SUBTYPE_QOS;
		*(u_int16_t *)qwh->i_qos = htole16(qos);
		*(u_int16_t *)qwh->i_seq =
		    htole16(ni->ni_qos_txseqs[tid] << IEEE80211_SEQ_SEQ_SHIFT);
		ni->ni_qos_txseqs[tid]++;
	} else {
		*(u_int16_t *)&wh->i_seq[0] =
		    htole16(ni->ni_txseq << IEEE80211_SEQ_SEQ_SHIFT);
		ni->ni_txseq++;
	}
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		wh->i_fc[1] = IEEE80211_FC1_DIR_TODS;
		IEEE80211_ADDR_COPY(wh->i_addr1, ni->ni_bssid);
		IEEE80211_ADDR_COPY(wh->i_addr2, eh.ether_shost);
		IEEE80211_ADDR_COPY(wh->i_addr3, eh.ether_dhost);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
		IEEE80211_ADDR_COPY(wh->i_addr1, eh.ether_dhost);
		IEEE80211_ADDR_COPY(wh->i_addr2, eh.ether_shost);
		IEEE80211_ADDR_COPY(wh->i_addr3, ic->ic_bss->ni_bssid);
		break;
	case IEEE80211_M_HOSTAP:
		wh->i_fc[1] = IEEE80211_FC1_DIR_FROMDS;
		IEEE80211_ADDR_COPY(wh->i_addr1, eh.ether_dhost);
		IEEE80211_ADDR_COPY(wh->i_addr2, ni->ni_bssid);
		IEEE80211_ADDR_COPY(wh->i_addr3, eh.ether_shost);
		break;
#endif
	default:
		/* should not get there */
		goto bad;
	}

	if ((ic->ic_flags & IEEE80211_F_WEPON) ||
	    ((ic->ic_flags & IEEE80211_F_RSNON) &&
	     (ni->ni_flags & IEEE80211_NODE_TXPROT)))
		wh->i_fc[1] |= IEEE80211_FC1_PROTECTED;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
	    ieee80211_pwrsave(ic, m, ni) != 0) {
		*pni = NULL;
		return NULL;
	}
#endif
	*pni = ni;
	return m;
bad:
	m_freem(m);
	if (ni != NULL)
		ieee80211_release_node(ic, ni);
	*pni = NULL;
	return NULL;
}

/*
 * Add a Capability Information field to a frame (see 7.3.1.4).
 */
u_int8_t *
ieee80211_add_capinfo(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	u_int16_t capinfo;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		capinfo = IEEE80211_CAPINFO_ESS;
	else
#endif
		capinfo = 0;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
	    (ic->ic_flags & (IEEE80211_F_WEPON | IEEE80211_F_RSNON)))
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
#endif
	/* NB: some 11a AP's reject the request when short preamble is set */
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	LE_WRITE_2(frm, capinfo);
	return frm + 2;
}

/*
 * Add an SSID element to a frame (see 7.3.2.1).
 */
u_int8_t *
ieee80211_add_ssid(u_int8_t *frm, const u_int8_t *ssid, u_int len)
{
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = len;
	memcpy(frm, ssid, len);
	return frm + len;
}

/*
 * Add a supported rates element to a frame (see 7.3.2.2).
 */
u_int8_t *
ieee80211_add_rates(u_int8_t *frm, const struct ieee80211_rateset *rs)
{
	int nrates;

	*frm++ = IEEE80211_ELEMID_RATES;
	nrates = min(rs->rs_nrates, IEEE80211_RATE_SIZE);
	*frm++ = nrates;
	memcpy(frm, rs->rs_rates, nrates);
	return frm + nrates;
}

#ifndef IEEE80211_STA_ONLY
/*
 * Add a DS Parameter Set element to a frame (see 7.3.2.4).
 */
u_int8_t *
ieee80211_add_ds_params(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
	return frm;
}

/*
 * Add a TIM element to a frame (see 7.3.2.6 and Annex L).
 */
u_int8_t *
ieee80211_add_tim(u_int8_t *frm, struct ieee80211com *ic)
{
	u_int i, offset = 0, len;

	/* find first non-zero octet in the virtual bit map */
	for (i = 0; i < ic->ic_tim_len && ic->ic_tim_bitmap[i] == 0; i++);

	/* clear the lsb as it is reserved for the broadcast indication bit */
	if (i < ic->ic_tim_len)
		offset = i & ~1;

	/* find last non-zero octet in the virtual bit map */
	for (i = ic->ic_tim_len - 1; i > 0 && ic->ic_tim_bitmap[i] == 0; i--);

	len = i - offset + 1;

	*frm++ = IEEE80211_ELEMID_TIM;
	*frm++ = len + 3;		/* length */
	*frm++ = ic->ic_dtim_count;	/* DTIM count */
	*frm++ = ic->ic_dtim_period;	/* DTIM period */

	/* Bitmap Control */
	*frm = offset;
	/* set broadcast/multicast indication bit if necessary */
	if (ic->ic_dtim_count == 0 && ic->ic_tim_mcast_pending)
		*frm |= 0x01;
	frm++;

	/* Partial Virtual Bitmap */
	memcpy(frm, &ic->ic_tim_bitmap[offset], len);
	return frm + len;
}

/*
 * Add an IBSS Parameter Set element to a frame (see 7.3.2.7).
 */
u_int8_t *
ieee80211_add_ibss_params(u_int8_t *frm, const struct ieee80211_node *ni)
{
	*frm++ = IEEE80211_ELEMID_IBSSPARMS;
	*frm++ = 2;
	LE_WRITE_2(frm, 0);	/* TODO: ATIM window */
	return frm + 2;
}

/*
 * Add an EDCA Parameter Set element to a frame (see 7.3.2.29).
 */
u_int8_t *
ieee80211_add_edca_params(u_int8_t *frm, struct ieee80211com *ic)
{
	const struct ieee80211_edca_ac_params *edca;
	int aci;

	*frm++ = IEEE80211_ELEMID_EDCAPARMS;
	*frm++ = 18;	/* length */
	*frm++ = 0;	/* QoS Info */
	*frm++ = 0;	/* reserved */

	/* setup AC Parameter Records */
	edca = ieee80211_edca_table[ic->ic_curmode];
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		const struct ieee80211_edca_ac_params *ac = &edca[aci];

		*frm++ = (aci << 5) | ((ac->ac_acm & 0x1) << 4) |
			 (ac->ac_aifsn & 0xf);
		*frm++ = (ac->ac_ecwmax << 4) |
			 (ac->ac_ecwmin & 0xf);
		LE_WRITE_2(frm, ac->ac_txoplimit); frm += 2;
	}
	return frm;
}

/*
 * Add an ERP element to a frame (see 7.3.2.13).
 */
u_int8_t *
ieee80211_add_erp(u_int8_t *frm, struct ieee80211com *ic)
{
	u_int8_t erp;
	int nonerpsta = 0;

	*frm++ = IEEE80211_ELEMID_ERP;
	*frm++ = 1;
	erp = 0;
	/*
	 * The NonERP_Present bit shall be set to 1 when a NonERP STA
	 * is associated with the BSS.
	 */
	ieee80211_iterate_nodes(ic, ieee80211_count_nonerpsta, &nonerpsta);
	if (nonerpsta != 0)
		erp |= IEEE80211_ERP_NON_ERP_PRESENT;
	/*
	 * If one or more NonERP STAs are associated in the BSS, the
	 * Use_Protection bit shall be set to 1 in transmitted ERP
	 * Information Elements.
	 */
	if (ic->ic_flags & IEEE80211_F_USEPROT)
		erp |= IEEE80211_ERP_USE_PROTECTION;
	/*
	 * The Barker_Preamble_Mode bit shall be set to 1 by the ERP
	 * Information Element sender if one or more associated NonERP
	 * STAs are not short preamble capable.
	 */
	if (!(ic->ic_flags & IEEE80211_F_SHPREAMBLE))
		erp |= IEEE80211_ERP_BARKER_MODE;
	*frm++ = erp;
	return frm;
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Add a QoS Capability element to a frame (see 7.3.2.35).
 */
u_int8_t *
ieee80211_add_qos_capability(u_int8_t *frm, struct ieee80211com *ic)
{
	*frm++ = IEEE80211_ELEMID_QOS_CAP;
	*frm++ = 1;
	*frm++ = 0;	/* QoS Info */
	return frm;
}

/*
 * Add a Wifi-Alliance WME (aka WMM) info element to a frame.
 * WME is a requirement for Wifi-Alliance compliance and some
 * 11n APs will not negotiate HT if this element is missing.
 */
uint8_t *
ieee80211_add_wme_info(uint8_t *frm, struct ieee80211com *ic)
{
	*frm++ = IEEE80211_ELEMID_VENDOR;
	*frm++ = 7;
	memcpy(frm, MICROSOFT_OUI, 3); frm += 3;
	*frm++ = 2; /* OUI type */
	*frm++ = 0; /* OUI subtype */
	*frm++ = 1; /* version */
	*frm++ = 0; /* info */

	return frm;
}

#ifndef IEEE80211_STA_ONLY
/*
 * Add a Wifi-Alliance WMM (aka WME) parameter element to a frame.
 */
uint8_t *
ieee80211_add_wme_param(uint8_t *frm, struct ieee80211com *ic)
{
	const struct ieee80211_edca_ac_params *edca;
	int aci;

	*frm++ = IEEE80211_ELEMID_VENDOR;
	*frm++ = 24;
	memcpy(frm, MICROSOFT_OUI, 3); frm += 3;
	*frm++ = 2; /* OUI type */
	*frm++ = 1; /* OUI subtype */
	*frm++ = 1; /* version */
	*frm++ = 0; /* info */
	*frm++ = 0; /* reserved */

	/* setup AC Parameter Records */
	edca = ieee80211_edca_table[ic->ic_curmode];
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		const struct ieee80211_edca_ac_params *ac = &edca[aci];

		*frm++ = (aci << 5) | ((ac->ac_acm & 0x1) << 4) |
			 (ac->ac_aifsn & 0xf);
		*frm++ = (ac->ac_ecwmax << 4) |
			 (ac->ac_ecwmin & 0xf);
		LE_WRITE_2(frm, ac->ac_txoplimit); frm += 2;
	}

	return frm;
}
#endif

/*
 * Add an RSN element to a frame (see 802.11-2012 8.4.2.27)
 */
u_int8_t *
ieee80211_add_rsn_body(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni, int wpa)
{
	const u_int8_t *oui = wpa ? MICROSOFT_OUI : IEEE80211_OUI;
	u_int8_t *pcount;
	u_int16_t count;

	/* write Version field */
	LE_WRITE_2(frm, 1); frm += 2;

	/* write Group Data Cipher Suite field (see 802.11-2012 Table 8-99) */
	memcpy(frm, oui, 3); frm += 3;
	switch (ni->ni_rsngroupcipher) {
	case IEEE80211_CIPHER_WEP40:
		*frm++ = 1;
		break;
	case IEEE80211_CIPHER_TKIP:
		*frm++ = 2;
		break;
	case IEEE80211_CIPHER_CCMP:
		*frm++ = 4;
		break;
	case IEEE80211_CIPHER_WEP104:
		*frm++ = 5;
		break;
	default:
		/* can't get there */
		panic("invalid group data cipher!");
	}

	pcount = frm; frm += 2;
	count = 0;
	/* write Pairwise Cipher Suite List */
	if (ni->ni_rsnciphers & IEEE80211_CIPHER_USEGROUP) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 0;
		count++;
	}
	if (ni->ni_rsnciphers & IEEE80211_CIPHER_TKIP) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 2;
		count++;
	}
	if (ni->ni_rsnciphers & IEEE80211_CIPHER_CCMP) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 4;
		count++;
	}
	/* write Pairwise Cipher Suite Count field */
	LE_WRITE_2(pcount, count);

	pcount = frm; frm += 2;
	count = 0;
	/* write AKM Suite List (see Table 20dc) */
	if (ni->ni_rsnakms & IEEE80211_AKM_8021X) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 1;
		count++;
	}
	if (ni->ni_rsnakms & IEEE80211_AKM_PSK) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 2;
		count++;
	}
	if (!wpa && (ni->ni_rsnakms & IEEE80211_AKM_SHA256_8021X)) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 5;
		count++;
	}
	if (!wpa && (ni->ni_rsnakms & IEEE80211_AKM_SHA256_PSK)) {
		memcpy(frm, oui, 3); frm += 3;
		*frm++ = 6;
		count++;
	}
	/* write AKM Suite List Count field */
	LE_WRITE_2(pcount, count);

	if (wpa)
		return frm;

	/* write RSN Capabilities field */
	LE_WRITE_2(frm, ni->ni_rsncaps); frm += 2;

	if (ni->ni_flags & IEEE80211_NODE_PMKID) {
		/* write PMKID Count field */
		LE_WRITE_2(frm, 1); frm += 2;
		/* write PMKID List (only 1) */
		memcpy(frm, ni->ni_pmkid, IEEE80211_PMKID_LEN);
		frm += IEEE80211_PMKID_LEN;
	} else {
		/* no PMKID (PMKID Count=0) */
		LE_WRITE_2(frm, 0); frm += 2;
	}

	if (!(ic->ic_caps & IEEE80211_C_MFP))
		return frm;

	/* write Group Integrity Cipher Suite field */
	memcpy(frm, oui, 3); frm += 3;
	switch (ic->ic_rsngroupmgmtcipher) {
	case IEEE80211_CIPHER_BIP:
		*frm++ = 6;
		break;
	default:
		/* can't get there */
		panic("invalid integrity group cipher!");
	}
	return frm;
}

u_int8_t *
ieee80211_add_rsn(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	u_int8_t *plen;

	*frm++ = IEEE80211_ELEMID_RSN;
	plen = frm++;	/* length filled in later */
	frm = ieee80211_add_rsn_body(frm, ic, ni, 0);

	/* write length field */
	*plen = frm - plen - 1;
	return frm;
}

/*
 * Add a vendor-specific WPA element to a frame.
 * This is required for compatibility with Wi-Fi Alliance WPA.
 */
u_int8_t *
ieee80211_add_wpa(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	u_int8_t *plen;

	*frm++ = IEEE80211_ELEMID_VENDOR;
	plen = frm++;	/* length filled in later */
	memcpy(frm, MICROSOFT_OUI, 3); frm += 3;
	*frm++ = 1;	/* WPA */
	frm = ieee80211_add_rsn_body(frm, ic, ni, 1);

	/* write length field */
	*plen = frm - plen - 1;
	return frm;
}

/*
 * Add an extended supported rates element to a frame (see 7.3.2.14).
 */
u_int8_t *
ieee80211_add_xrates(u_int8_t *frm, const struct ieee80211_rateset *rs)
{
	int nrates;

	KASSERT(rs->rs_nrates > IEEE80211_RATE_SIZE);

	*frm++ = IEEE80211_ELEMID_XRATES;
	nrates = rs->rs_nrates - IEEE80211_RATE_SIZE;
	*frm++ = nrates;
	memcpy(frm, rs->rs_rates + IEEE80211_RATE_SIZE, nrates);
	return frm + nrates;
}

/*
 * Add an HT Capabilities element to a frame (see 7.3.2.57).
 */
u_int8_t *
ieee80211_add_htcaps(u_int8_t *frm, struct ieee80211com *ic)
{
	*frm++ = IEEE80211_ELEMID_HTCAPS;
	*frm++ = 26;
	LE_WRITE_2(frm, ic->ic_htcaps); frm += 2;
	*frm++ = ic->ic_ampdu_params;
	memcpy(frm, ic->ic_sup_mcs, 10); frm += 10;
	LE_WRITE_2(frm, (ic->ic_max_rxrate & IEEE80211_MCS_RX_RATE_HIGH));
	frm += 2;
	*frm++ = ic->ic_tx_mcs_set;
	*frm++ = 0; /* reserved */
	*frm++ = 0; /* reserved */
	*frm++ = 0; /* reserved */
	LE_WRITE_2(frm, ic->ic_htxcaps); frm += 2;
	LE_WRITE_4(frm, ic->ic_txbfcaps); frm += 4;
	*frm++ = ic->ic_aselcaps;
	return frm;
}

#ifndef IEEE80211_STA_ONLY
/*
 * Add an HT Operation element to a frame (see 7.3.2.58).
 */
u_int8_t *
ieee80211_add_htop(u_int8_t *frm, struct ieee80211com *ic)
{
	*frm++ = IEEE80211_ELEMID_HTOP;
	*frm++ = 22;
	*frm++ = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	*frm++ = ic->ic_bss->ni_htop0;
	LE_WRITE_2(frm, ic->ic_bss->ni_htop1); frm += 2;
	LE_WRITE_2(frm, ic->ic_bss->ni_htop2); frm += 2;
	memset(frm, 0, 16); frm += 16;
	return frm;
}
#endif	/* !IEEE80211_STA_ONLY */

#ifndef IEEE80211_STA_ONLY
/*
 * Add a Timeout Interval element to a frame (see 7.3.2.49).
 */
u_int8_t *
ieee80211_add_tie(u_int8_t *frm, u_int8_t type, u_int32_t value)
{
	*frm++ = IEEE80211_ELEMID_TIE;
	*frm++ = 5;	/* length */
	*frm++ = type;	/* Timeout Interval type */
	LE_WRITE_4(frm, value);
	return frm + 4;
}
#endif

struct mbuf *
ieee80211_getmgmt(int flags, int type, u_int pktlen)
{
	struct mbuf *m;

	/* reserve space for 802.11 header */
	pktlen += sizeof(struct ieee80211_frame);

	if (pktlen > MCLBYTES)
		panic("management frame too large: %u", pktlen);
	MGETHDR(m, flags, type);
	if (m == NULL)
		return NULL;
	if (pktlen > MHLEN) {
		MCLGET(m, flags);
		if (!(m->m_flags & M_EXT))
			return m_free(m);
	}
	m->m_data += sizeof(struct ieee80211_frame);
	return m;
}

/*-
 * Probe request frame format:
 * [tlv] SSID
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] HT Capabilities (802.11n)
 */
struct mbuf *
ieee80211_get_probe_req(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	const struct ieee80211_rateset *rs =
	    &ic->ic_sup_rates[ieee80211_chan2mode(ic, ni->ni_chan)];
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA,
	    2 + ic->ic_des_esslen +
	    2 + min(rs->rs_nrates, IEEE80211_RATE_SIZE) +
	    ((rs->rs_nrates > IEEE80211_RATE_SIZE) ?
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0) +
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 9 : 0));
	if (m == NULL)
		return NULL;

	frm = mtod(m, u_int8_t *);
	frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if (ic->ic_flags & IEEE80211_F_HTON) {
		frm = ieee80211_add_htcaps(frm, ic);
		frm = ieee80211_add_wme_info(frm, ic);
	}

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

#ifndef IEEE80211_STA_ONLY
/*-
 * Probe response frame format:
 * [8]   Timestamp
 * [2]   Beacon interval
 * [2]   Capability
 * [tlv] Service Set Identifier (SSID)
 * [tlv] Supported rates
 * [tlv] DS Parameter Set (802.11g)
 * [tlv] ERP Information (802.11g)
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] RSN (802.11i)
 * [tlv] EDCA Parameter Set (802.11e)
 * [tlv] HT Capabilities (802.11n)
 * [tlv] HT Operation (802.11n)
 */
struct mbuf *
ieee80211_get_probe_resp(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	const struct ieee80211_rateset *rs = &ic->ic_bss->ni_rates;
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA,
	    8 + 2 + 2 +
	    2 + ni->ni_esslen +
	    2 + min(rs->rs_nrates, IEEE80211_RATE_SIZE) +
	    2 + 1 +
	    ((ic->ic_opmode == IEEE80211_M_IBSS) ? 2 + 2 : 0) +
	    ((ic->ic_curmode == IEEE80211_MODE_11G) ? 2 + 1 : 0) +
	    ((rs->rs_nrates > IEEE80211_RATE_SIZE) ?
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_RSN)) ?
		2 + IEEE80211_RSNIE_MAXLEN : 0) +
	    ((ic->ic_flags & IEEE80211_F_QOS) ? 2 + 18 : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_WPA)) ?
		2 + IEEE80211_WPAIE_MAXLEN : 0) +
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 + 26 : 0));
	if (m == NULL)
		return NULL;

	frm = mtod(m, u_int8_t *);
	memset(frm, 0, 8); frm += 8;	/* timestamp is set by hardware */
	LE_WRITE_2(frm, ic->ic_bss->ni_intval); frm += 2;
	frm = ieee80211_add_capinfo(frm, ic, ni);
	frm = ieee80211_add_ssid(frm, ic->ic_bss->ni_essid,
	    ic->ic_bss->ni_esslen);
	frm = ieee80211_add_rates(frm, rs);
	frm = ieee80211_add_ds_params(frm, ic, ni);
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		frm = ieee80211_add_ibss_params(frm, ni);
	if (ic->ic_curmode == IEEE80211_MODE_11G)
		frm = ieee80211_add_erp(frm, ic);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_RSN))
		frm = ieee80211_add_rsn(frm, ic, ic->ic_bss);
	if (ic->ic_flags & IEEE80211_F_QOS)
		frm = ieee80211_add_edca_params(frm, ic);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_WPA))
		frm = ieee80211_add_wpa(frm, ic, ic->ic_bss);
	if (ic->ic_flags & IEEE80211_F_HTON) {
		frm = ieee80211_add_htcaps(frm, ic);
		frm = ieee80211_add_htop(frm, ic);
		frm = ieee80211_add_wme_param(frm, ic);
	}

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}
#endif	/* IEEE80211_STA_ONLY */

/*-
 * Authentication frame format:
 * [2] Authentication algorithm number
 * [2] Authentication transaction sequence number
 * [2] Status code
 */
struct mbuf *
ieee80211_get_auth(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t status, u_int16_t seq)
{
	struct mbuf *m;
	u_int8_t *frm;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;
	MH_ALIGN(m, 2 * 3);
	m->m_pkthdr.len = m->m_len = 2 * 3;

	frm = mtod(m, u_int8_t *);
	LE_WRITE_2(frm, IEEE80211_AUTH_ALG_OPEN); frm += 2;
	LE_WRITE_2(frm, seq); frm += 2;
	LE_WRITE_2(frm, status);

	return m;
}

/*-
 * Deauthentication frame format:
 * [2] Reason code
 */
struct mbuf *
ieee80211_get_deauth(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t reason)
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;
	MH_ALIGN(m, 2);

	m->m_pkthdr.len = m->m_len = 2;
	*mtod(m, u_int16_t *) = htole16(reason);

	return m;
}

/*-
 * (Re)Association request frame format:
 * [2]   Capability information
 * [2]   Listen interval
 * [6*]  Current AP address (Reassociation only)
 * [tlv] SSID
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] RSN (802.11i)
 * [tlv] QoS Capability (802.11e)
 * [tlv] HT Capabilities (802.11n)
 */
struct mbuf *
ieee80211_get_assoc_req(struct ieee80211com *ic, struct ieee80211_node *ni,
    int type)
{
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	struct mbuf *m;
	u_int8_t *frm;
	u_int16_t capinfo;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA,
	    2 + 2 +
	    ((type == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) ?
		IEEE80211_ADDR_LEN : 0) +
	    2 + ni->ni_esslen +
	    2 + min(rs->rs_nrates, IEEE80211_RATE_SIZE) +
	    ((rs->rs_nrates > IEEE80211_RATE_SIZE) ?
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)) ?
		2 + IEEE80211_RSNIE_MAXLEN : 0) +
	    ((ni->ni_flags & IEEE80211_NODE_QOS) ? 2 + 1 : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)) ?
		2 + IEEE80211_WPAIE_MAXLEN : 0) +
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 9 : 0));
	if (m == NULL)
		return NULL;

	frm = mtod(m, u_int8_t *);
	capinfo = IEEE80211_CAPINFO_ESS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_caps & IEEE80211_C_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	LE_WRITE_2(frm, capinfo); frm += 2;
	LE_WRITE_2(frm, ic->ic_lintval); frm += 2;
	if (type == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {
		IEEE80211_ADDR_COPY(frm, ic->ic_bss->ni_bssid);
		frm += IEEE80211_ADDR_LEN;
	}
	frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ni->ni_rsnprotos & IEEE80211_PROTO_RSN))
		frm = ieee80211_add_rsn(frm, ic, ni);
	if (ni->ni_flags & IEEE80211_NODE_QOS)
		frm = ieee80211_add_qos_capability(frm, ic);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ni->ni_rsnprotos & IEEE80211_PROTO_WPA))
		frm = ieee80211_add_wpa(frm, ic, ni);
	if (ic->ic_flags & IEEE80211_F_HTON) {
		frm = ieee80211_add_htcaps(frm, ic);
		frm = ieee80211_add_wme_info(frm, ic);
	}

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

#ifndef IEEE80211_STA_ONLY
/*-
 * (Re)Association response frame format:
 * [2]   Capability information
 * [2]   Status code
 * [2]   Association ID (AID)
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] EDCA Parameter Set (802.11e)
 * [tlv] Timeout Interval (802.11w)
 * [tlv] HT Capabilities (802.11n)
 * [tlv] HT Operation (802.11n)
 */
struct mbuf *
ieee80211_get_assoc_resp(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t status)
{
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA,
	    2 + 2 + 2 +
	    2 + min(rs->rs_nrates, IEEE80211_RATE_SIZE) +
	    ((rs->rs_nrates > IEEE80211_RATE_SIZE) ?
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0) +
	    ((ni->ni_flags & IEEE80211_NODE_QOS) ? 2 + 18 : 0) +
	    ((status == IEEE80211_STATUS_TRY_AGAIN_LATER) ? 2 + 7 : 0) +
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 + 26 : 0));
	if (m == NULL)
		return NULL;

	frm = mtod(m, u_int8_t *);
	frm = ieee80211_add_capinfo(frm, ic, ni);
	LE_WRITE_2(frm, status); frm += 2;
	if (status == IEEE80211_STATUS_SUCCESS)
		LE_WRITE_2(frm, ni->ni_associd);
	else
		LE_WRITE_2(frm, 0);
	frm += 2;
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if (ni->ni_flags & IEEE80211_NODE_QOS)
		frm = ieee80211_add_edca_params(frm, ic);
	if ((ni->ni_flags & IEEE80211_NODE_MFP) &&
	    status == IEEE80211_STATUS_TRY_AGAIN_LATER) {
		/* Association Comeback Time */
		frm = ieee80211_add_tie(frm, 3, 1000 /* XXX */);
	}
	if (ic->ic_flags & IEEE80211_F_HTON) {
		frm = ieee80211_add_htcaps(frm, ic);
		frm = ieee80211_add_htop(frm, ic);
		frm = ieee80211_add_wme_param(frm, ic);
	}

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}
#endif	/* IEEE80211_STA_ONLY */

/*-
 * Disassociation frame format:
 * [2] Reason code
 */
struct mbuf *
ieee80211_get_disassoc(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int16_t reason)
{
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;
	MH_ALIGN(m, 2);

	m->m_pkthdr.len = m->m_len = 2;
	*mtod(m, u_int16_t *) = htole16(reason);

	return m;
}

/*-
 * ADDBA Request frame format:
 * [1] Category
 * [1] Action
 * [1] Dialog Token
 * [2] Block Ack Parameter Set
 * [2] Block Ack Timeout Value
 * [2] Block Ack Starting Sequence Control
 */
struct mbuf *
ieee80211_get_addba_req(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t tid)
{
	struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA, 9);
	if (m == NULL)
		return m;

	frm = mtod(m, u_int8_t *);
	*frm++ = IEEE80211_CATEG_BA;
	*frm++ = IEEE80211_ACTION_ADDBA_REQ;
	*frm++ = ba->ba_token;
	LE_WRITE_2(frm, ba->ba_params); frm += 2;
	LE_WRITE_2(frm, ba->ba_timeout_val / IEEE80211_DUR_TU); frm += 2;
	LE_WRITE_2(frm, ba->ba_winstart); frm += 2;

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

/*-
 * ADDBA Response frame format:
 * [1] Category
 * [1] Action
 * [1] Dialog Token
 * [2] Status Code
 * [2] Block Ack Parameter Set
 * [2] Block Ack Timeout Value
 */
struct mbuf *
ieee80211_get_addba_resp(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t tid, u_int8_t token, u_int16_t status)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	struct mbuf *m;
	u_int8_t *frm;
	u_int16_t params;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA, 9);
	if (m == NULL)
		return m;

	frm = mtod(m, u_int8_t *);
	*frm++ = IEEE80211_CATEG_BA;
	*frm++ = IEEE80211_ACTION_ADDBA_RESP;
	*frm++ = token;
	LE_WRITE_2(frm, status); frm += 2;
	if (status == 0)
		params = ba->ba_params;
	else
		params = tid << IEEE80211_ADDBA_TID_SHIFT;
	LE_WRITE_2(frm, params); frm += 2;
	if (status == 0)
		LE_WRITE_2(frm, ba->ba_timeout_val / IEEE80211_DUR_TU);
	else
		LE_WRITE_2(frm, 0);
	frm += 2;

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

/*-
 * DELBA frame format:
 * [1] Category
 * [1] Action
 * [2] DELBA Parameter Set
 * [2] Reason Code
 */
struct mbuf *
ieee80211_get_delba(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t tid, u_int8_t dir, u_int16_t reason)
{
	struct mbuf *m;
	u_int8_t *frm;
	u_int16_t params;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA, 6);
	if (m == NULL)
		return m;

	frm = mtod(m, u_int8_t *);
	*frm++ = IEEE80211_CATEG_BA;
	*frm++ = IEEE80211_ACTION_DELBA;
	params = tid << 12;
	if (dir)
		params |= IEEE80211_DELBA_INITIATOR;
	LE_WRITE_2(frm, params); frm += 2;
	LE_WRITE_2(frm, reason); frm += 2;

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

/*-
 * SA Query Request/Reponse frame format:
 * [1]  Category
 * [1]  Action
 * [16] Transaction Identifier
 */
struct mbuf *
ieee80211_get_sa_query(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t action)
{
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA, 4);
	if (m == NULL)
		return NULL;

	frm = mtod(m, u_int8_t *);
	*frm++ = IEEE80211_CATEG_SA_QUERY;
	*frm++ = action;	/* ACTION_SA_QUERY_REQ/RESP */
	LE_WRITE_2(frm, ni->ni_sa_query_trid); frm += 2;

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);

	return m;
}

struct mbuf *
ieee80211_get_action(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t categ, u_int8_t action, int arg)
{
	struct mbuf *m = NULL;

	switch (categ) {
	case IEEE80211_CATEG_BA:
		switch (action) {
		case IEEE80211_ACTION_ADDBA_REQ:
			m = ieee80211_get_addba_req(ic, ni, arg & 0xffff);
			break;
		case IEEE80211_ACTION_ADDBA_RESP:
			m = ieee80211_get_addba_resp(ic, ni, arg & 0xff,
			    arg >> 8, arg >> 16);
			break;
		case IEEE80211_ACTION_DELBA:
			m = ieee80211_get_delba(ic, ni, arg & 0xff, arg >> 8,
			    arg >> 16);
			break;
		}
		break;
	case IEEE80211_CATEG_SA_QUERY:
		switch (action) {
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_ACTION_SA_QUERY_REQ:
#endif
		case IEEE80211_ACTION_SA_QUERY_RESP:
			m = ieee80211_get_sa_query(ic, ni, action);
			break;
		}
		break;
	}
	return m;
}

/*
 * Send a management frame.  The node is for the destination (or ic_bss
 * when in station mode).  Nodes other than ic_bss have their reference
 * count bumped to reflect our use for an indeterminant time.
 */
int
ieee80211_send_mgmt(struct ieee80211com *ic, struct ieee80211_node *ni,
    int type, int arg1, int arg2)
{
#define	senderr(_x, _v)	do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
	struct ifnet *ifp = &ic->ic_if;
	struct mbuf *m;
	int ret, timer;

	if (ni == NULL)
		panic("null node");

	/*
	 * Hold a reference on the node so it doesn't go away until after
	 * the xmit is complete all the way in the driver.  On error we
	 * will remove our reference.
	 */
	ieee80211_ref_node(ni);
	timer = 0;
	switch (type) {
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		if ((m = ieee80211_get_probe_req(ic, ni)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);

		timer = IEEE80211_TRANS_WAIT;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
		if ((m = ieee80211_get_probe_resp(ic, ni)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);
		break;
#endif
	case IEEE80211_FC0_SUBTYPE_AUTH:
		m = ieee80211_get_auth(ic, ni, arg1 >> 16, arg1 & 0xffff);
		if (m == NULL)
			senderr(ENOMEM, is_tx_nombuf);

		if (ic->ic_opmode == IEEE80211_M_STA)
			timer = IEEE80211_TRANS_WAIT;
		break;

	case IEEE80211_FC0_SUBTYPE_DEAUTH:
		if ((m = ieee80211_get_deauth(ic, ni, arg1)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);

		if (ifp->if_flags & IFF_DEBUG) {
			printf("%s: station %s deauthenticate (reason %d)\n",
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr),
			    arg1);
		}
		break;

	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
		if ((m = ieee80211_get_assoc_req(ic, ni, type)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);

		timer = IEEE80211_TRANS_WAIT;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
		if ((m = ieee80211_get_assoc_resp(ic, ni, arg1)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);
		break;
#endif
	case IEEE80211_FC0_SUBTYPE_DISASSOC:
		if ((m = ieee80211_get_disassoc(ic, ni, arg1)) == NULL)
			senderr(ENOMEM, is_tx_nombuf);

		if (ifp->if_flags & IFF_DEBUG) {
			printf("%s: station %s disassociate (reason %d)\n",
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr),
			    arg1);
		}
		break;

	case IEEE80211_FC0_SUBTYPE_ACTION:
		m = ieee80211_get_action(ic, ni, arg1 >> 16, arg1 & 0xffff,
		    arg2);
		if (m == NULL)
			senderr(ENOMEM, is_tx_nombuf);
		break;

	default:
		DPRINTF(("invalid mgmt frame type %u\n", type));
		senderr(EINVAL, is_tx_unknownmgt);
		/* NOTREACHED */
	}

	ret = ieee80211_mgmt_output(ifp, ni, m, type);
	if (ret == 0) {
		if (timer)
			ic->ic_mgt_timer = timer;
	} else {
bad:
		ieee80211_release_node(ic, ni);
	}
	return ret;
#undef senderr
}

/*
 * Build a RTS (Request To Send) control frame (see 7.2.1.1).
 */
struct mbuf *
ieee80211_get_rts(struct ieee80211com *ic, const struct ieee80211_frame *wh,
    u_int16_t dur)
{
	struct ieee80211_frame_rts *rts;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;

	m->m_pkthdr.len = m->m_len = sizeof(struct ieee80211_frame_rts);

	rts = mtod(m, struct ieee80211_frame_rts *);
	rts->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_CTL |
	    IEEE80211_FC0_SUBTYPE_RTS;
	rts->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)rts->i_dur = htole16(dur);
	IEEE80211_ADDR_COPY(rts->i_ra, wh->i_addr1);
	IEEE80211_ADDR_COPY(rts->i_ta, wh->i_addr2);

	return m;
}

/*
 * Build a CTS-to-self (Clear To Send) control frame (see 7.2.1.2).
 */
struct mbuf *
ieee80211_get_cts_to_self(struct ieee80211com *ic, u_int16_t dur)
{
	struct ieee80211_frame_cts *cts;
	struct mbuf *m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return NULL;

	m->m_pkthdr.len = m->m_len = sizeof(struct ieee80211_frame_cts);

	cts = mtod(m, struct ieee80211_frame_cts *);
	cts->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_CTL |
	    IEEE80211_FC0_SUBTYPE_CTS;
	cts->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)cts->i_dur = htole16(dur);
	IEEE80211_ADDR_COPY(cts->i_ra, ic->ic_myaddr);

	return m;
}

#ifndef IEEE80211_STA_ONLY
/*-
 * Beacon frame format:
 * [8]   Timestamp
 * [2]   Beacon interval
 * [2]   Capability
 * [tlv] Service Set Identifier (SSID)
 * [tlv] Supported rates
 * [tlv] DS Parameter Set (802.11g)
 * [tlv] IBSS Parameter Set
 * [tlv] Traffic Indication Map (TIM)
 * [tlv] ERP Information (802.11g)
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] RSN (802.11i)
 * [tlv] EDCA Parameter Set (802.11e)
 * [tlv] HT Capabilities (802.11n)
 * [tlv] HT Operation (802.11n)
 */
struct mbuf *
ieee80211_beacon_alloc(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	struct ieee80211_frame *wh;
	struct mbuf *m;
	u_int8_t *frm;

	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA,
	    8 + 2 + 2 +
	    2 + ((ic->ic_flags & IEEE80211_F_HIDENWID) ? 0 : ni->ni_esslen) +
	    2 + min(rs->rs_nrates, IEEE80211_RATE_SIZE) +
	    2 + 1 +
	    2 + ((ic->ic_opmode == IEEE80211_M_IBSS) ? 2 : 254) +
	    ((ic->ic_curmode == IEEE80211_MODE_11G) ? 2 + 1 : 0) +
	    ((rs->rs_nrates > IEEE80211_RATE_SIZE) ?
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)) ?
		2 + IEEE80211_RSNIE_MAXLEN : 0) +
	    ((ic->ic_flags & IEEE80211_F_QOS) ? 2 + 18 : 0) +
	    (((ic->ic_flags & IEEE80211_F_RSNON) &&
	      (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)) ?
		2 + IEEE80211_WPAIE_MAXLEN : 0) +
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 + 26 : 0));
	if (m == NULL)
		return NULL;

	M_PREPEND(m, sizeof(struct ieee80211_frame), M_DONTWAIT);
	if (m == NULL)
		return NULL;
	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_BEACON;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)wh->i_dur = 0;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, ni->ni_bssid);
	*(u_int16_t *)wh->i_seq = 0;

	frm = (u_int8_t *)&wh[1];
	memset(frm, 0, 8); frm += 8;	/* timestamp is set by hardware */
	LE_WRITE_2(frm, ni->ni_intval); frm += 2;
	frm = ieee80211_add_capinfo(frm, ic, ni);
	if (ic->ic_flags & IEEE80211_F_HIDENWID)
		frm = ieee80211_add_ssid(frm, NULL, 0);
	else
		frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);
	frm = ieee80211_add_rates(frm, rs);
	frm = ieee80211_add_ds_params(frm, ic, ni);
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		frm = ieee80211_add_ibss_params(frm, ni);
	else
		frm = ieee80211_add_tim(frm, ic);
	if (ic->ic_curmode == IEEE80211_MODE_11G)
		frm = ieee80211_add_erp(frm, ic);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ni->ni_rsnprotos & IEEE80211_PROTO_RSN))
		frm = ieee80211_add_rsn(frm, ic, ni);
	if (ic->ic_flags & IEEE80211_F_QOS)
		frm = ieee80211_add_edca_params(frm, ic);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    (ni->ni_rsnprotos & IEEE80211_PROTO_WPA))
		frm = ieee80211_add_wpa(frm, ic, ni);
	if (ic->ic_flags & IEEE80211_F_HTON) {
		frm = ieee80211_add_htcaps(frm, ic);
		frm = ieee80211_add_htop(frm, ic);
		frm = ieee80211_add_wme_param(frm, ic);
	}

	m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
	m->m_pkthdr.ph_cookie = ni;

	return m;
}

/*
 * Check if an outgoing MSDU or management frame should be buffered into
 * the AP for power management.  Return 1 if the frame was buffered into
 * the AP, or 0 if the frame shall be transmitted immediately.
 */
int
ieee80211_pwrsave(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	int pssta = 0;

	KASSERT(ic->ic_opmode == IEEE80211_M_HOSTAP);
	if (!(ic->ic_caps & IEEE80211_C_APPMGT))
		return 0;

	wh = mtod(m, struct ieee80211_frame *);
	if (IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/*
		 * Buffer group addressed MSDUs with the Order bit clear
		 * if any associated STAs are in PS mode.
		 */
		ieee80211_iterate_nodes(ic, ieee80211_count_pssta, &pssta);
		if ((wh->i_fc[1] & IEEE80211_FC1_ORDER) || pssta == 0)
			return 0;
		ic->ic_tim_mcast_pending = 1;
	} else {
		/*
		 * Buffer MSDUs, A-MSDUs or management frames destined for
		 * PS STAs.
		 */
		if (ni->ni_pwrsave == IEEE80211_PS_AWAKE ||
		    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_CTL)
			return 0;
		if (mq_empty(&ni->ni_savedq))
			(*ic->ic_set_tim)(ic, ni->ni_associd, 1);
	}
	/* NB: ni == ic->ic_bss for broadcast/multicast */
	/*
	 * Similar to ieee80211_mgmt_output, store the node in a
	 * special pkthdr field.
	 */
	m->m_pkthdr.ph_cookie = ni;
	mq_enqueue(&ni->ni_savedq, m);
	return 1;
}
#endif	/* IEEE80211_STA_ONLY */
@


1.117
log
@In a comment inside ieee80211_up_to_ac(), update a reference section
number from the 802.11-2007 standard to the 802.11-2012 standard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.116 2017/01/31 09:39:27 stsp Exp $	*/
d790 1
d799 2
a800 1
	if (ic->ic_nonerpsta != 0)
d1895 1
d1907 2
a1908 2
		if ((wh->i_fc[1] & IEEE80211_FC1_ORDER) ||
		    ic->ic_pssta == 0)
@


1.116
log
@When telling clients which EDCA parameters to use, copy these parameters
from the client parameter set, rather than from the AP parameter set.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.115 2017/01/30 18:21:13 stsp Exp $	*/
d364 1
a364 1
	 * IEEE Std 802.11-2007 section 9.9.3.1.2.  The spec says that
@


1.115
log
@Enable ieee80211_edca_table, which was under #if 0. This table can be used
by drivers to pass default EDCA parameters to firmware instead of passing
local hardcoded values.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.114 2017/01/09 16:24:20 stsp Exp $	*/
d770 1
a770 1
	edca = ieee80211_qap_edca_table[ic->ic_curmode];
d870 1
a870 1
	edca = ieee80211_qap_edca_table[ic->ic_curmode];
@


1.114
log
@Make the net80211 stack send EDCA parameters to the driver in hostap mode.
Fixes problems with timing of frame transmissions which caused packet loss.
tested by myself and tb@@
ok phessler@@ mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.113 2017/01/09 13:01:37 stsp Exp $	*/
d278 1
a278 2
#if 0
static const struct ieee80211_edca_ac_params
a304 1
#endif
@


1.113
log
@When acting as 11n hostap, send Microsoft WME parameters to clients so
that Linux clients will decide to use 11n mode.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.112 2017/01/09 09:30:02 stsp Exp $	*/
d309 1
a309 1
static const struct ieee80211_edca_ac_params
@


1.112
log
@Fix ieee80211_add_htop(), which is not yet called in active code paths.
It was creating a corrupt beacon element by ommitting one byte.
Fix this and fill the element with actual data from the ic_bss node instead
of filling it with zeroes, allowing future 11n hostap to announce the current
HT protection mode correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.111 2016/04/12 14:33:27 mpi Exp $	*/
d1210 1
a1210 1
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 : 0));
d1239 1
d1401 1
a1401 1
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 : 0));
d1426 1
d1830 1
a1830 1
	    ((ic->ic_flags & IEEE80211_F_HTON) ? 28 + 24 : 0));
d1876 1
@


1.111
log
@Call if_enqueue() and if_start() instead of dereferencing the ifp
pointers.

These functions have been introduced to abstract some of the MP-
safeness^Wmadness and should be use everywhere.

Prodded by a comment from jsg@@.

ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.110 2016/02/05 19:11:31 stsp Exp $	*/
d1087 3
a1089 2
	LE_WRITE_2(frm, 0); frm += 2;
	LE_WRITE_2(frm, 0); frm += 2;
@


1.110
log
@Define EDCA tables for 11n mode. Per 802.11-2012 they are the same as
the tables for 11a/11g modes.
Add a function to append a Microsoft WME parameter element to a frame,
using EDCA tables to construct the parameter records. Some 11n AP's I have
observed provide this element.

None of this code is used yet, so no functional change. I wrote this while
debugging BlockAck and then realized it was only needed for hostap mode.
Once we support 11n in hostap mode and send A-MPDUs, this code will be needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.109 2016/02/05 16:07:57 stsp Exp $	*/
d244 1
a244 1
	(*ifp->if_start)(ifp);
@


1.109
log
@Store ADDBA request and response parameters in the block ack record of
ieee80211_node. This way, we can keep track of the ACK policy and echo
it back to the AP as required by the standard. And use the correct bit
flag for the policy -- this code was confused between BlockAck and ADDBA,
both of which have a policy bit but in different places.

Fixes apple airport APs.

tested by tb@@, krw@@, sthen@@, abieber@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.108 2016/01/21 20:33:20 stsp Exp $	*/
d97 3
d276 1
d299 6
d329 6
d851 36
@


1.108
log
@Fix the timeout value sent in ADDBA request and response frames.
ba_timeout_val is in usec so we must divide by TU when copying it to the frame.
ok kettenis@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.107 2016/01/12 09:28:09 stsp Exp $	*/
a1416 1
	u_int16_t params;
d1426 1
a1426 6
	params = ba->ba_winsize << IEEE80211_ADDBA_BUFSZ_SHIFT |
	    tid << IEEE80211_ADDBA_TID_SHIFT |
	    IEEE80211_ADDBA_AMSDU;
	if ((ic->ic_htcaps & IEEE80211_HTCAP_DELAYEDBA) == 0)
		params |= IEEE80211_ADDBA_BA_POLICY; /* use immediate BA */
	LE_WRITE_2(frm, params); frm += 2;
a1461 1
	params = tid << 2 | IEEE80211_BA_ACK_POLICY;
d1463 3
a1465 1
		params |= ba->ba_winsize << 6;
@


1.107
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.106 2016/01/06 19:56:50 stsp Exp $	*/
d1433 1
a1433 1
	LE_WRITE_2(frm, ba->ba_timeout_val); frm += 2;
d1473 1
a1473 1
		LE_WRITE_2(frm, ba->ba_timeout_val);
@


1.106
log
@Initialize the A-MPDU parameters field in HT capability elements.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.105 2016/01/05 18:41:16 stsp Exp $	*/
a272 1
 * Turbo A/G	7	1023	(Atheros proprietary mode)
a294 6
	[IEEE80211_MODE_TURBO] = {
		[EDCA_AC_BK] = { 3, 10, 7,   0 },
		[EDCA_AC_BE] = { 3, 10, 2,   0 },
		[EDCA_AC_VI] = { 2,  3, 2,  94 },
		[EDCA_AC_VO] = { 2,  2, 1,  47 }
	}
a318 6
	[IEEE80211_MODE_TURBO] = {
		[EDCA_AC_BK] = { 3, 10, 7,   0 },
		[EDCA_AC_BE] = { 3,  5, 2,   0 },
		[EDCA_AC_VI] = { 2,  3, 1,  94 },
		[EDCA_AC_VO] = { 2,  2, 1,  47 }
	}
@


1.105
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.104 2016/01/04 13:29:04 stsp Exp $	*/
d1024 1
a1024 1
	*frm++ = 0; /* XXX A-MPDU params */
@


1.104
log
@Fix another case where the return value of ieee80211_chan2mode() was
used for indexing something other than ic_sup_rates. Should have been
part of earlier commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.103 2016/01/04 12:32:06 stsp Exp $	*/
a89 1
#ifndef IEEE80211_NO_HT
a96 1
#endif
a570 1
#ifndef IEEE80211_NO_HT
a572 1
#endif
a829 1
#ifndef IEEE80211_NO_HT
a847 1
#endif
a1014 1
#ifndef IEEE80211_NO_HT
a1053 1
#endif	/* !IEEE80211_NO_HT */
a1120 1
#ifndef IEEE80211_NO_HT
a1124 1
#endif
a1195 1
#ifndef IEEE80211_NO_HT
a1199 1
#endif
a1321 1
#ifndef IEEE80211_NO_HT
a1325 1
#endif
a1381 1
#ifndef IEEE80211_NO_HT
a1385 1
#endif
a1413 1
#ifndef IEEE80211_NO_HT
a1527 1
#endif	/* !IEEE80211_NO_HT */
a1562 1
#ifndef IEEE80211_NO_HT
a1577 1
#endif
a1835 1
#ifndef IEEE80211_NO_HT
a1839 1
#endif
@


1.103
log
@ADDBA frames have a parameter set which we check against our own capabilities
but we were checking bits in these parameters with the wrong set of bitmasks.
Negotiating A-MPDUs with some APs failed because of this bug.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.102 2015/12/12 11:31:48 stsp Exp $	*/
d233 1
a233 2
			    ieee80211_phymode_name[
			    ieee80211_chan2mode(ic, ni->ni_chan)]);
@


1.102
log
@11n/HT negotiation fixes:

Some APs will not negotiate HT if the vendor-specific WME info
element is missing in probe and association requests, so add one.

Fix the wrong flag (NODE_HT) being checked to determine whether 11n
related elements should be included in management frames. If 11n mode
is enabled (F_HTON flag) we can always include 11n related elements
in management frames.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.101 2015/11/24 12:32:53 mpi Exp $	*/
d1458 5
a1462 1
	params = ba->ba_winsize << 6 | tid << 2 | IEEE80211_BA_ACK_POLICY;
@


1.101
log
@No need to include <net/if_types.h> for <net/if_vlan_var.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.100 2015/11/15 01:05:25 stsp Exp $	*/
d97 1
d835 20
d1121 1
a1121 1
	    ((ni->ni_flags & IEEE80211_NODE_HT) ? 28 : 0));
d1131 1
a1131 1
	if (ni->ni_flags & IEEE80211_NODE_HT)
d1133 2
d1304 1
a1304 1
	    ((ni->ni_flags & IEEE80211_NODE_HT) ? 28 : 0));
d1336 1
a1336 1
	if (ni->ni_flags & IEEE80211_NODE_HT)
d1338 2
d1375 1
a1375 1
	    ((ni->ni_flags & IEEE80211_NODE_HT) ? 28 + 24 : 0));
d1398 1
a1398 1
	if (ni->ni_flags & IEEE80211_NODE_HT) {
@


1.100
log
@Declare 802.11n mode and channel flags. Tweak 11n related fields in struct
ieee80211com and move them inside #ifndef IEEE80211_NO_HT without breaking
the build in rsu(4) for RAMDISK_CD.
Also declare 11n protection modes and MCS count.
ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.99 2015/11/08 18:48:07 stsp Exp $	*/
a59 1
#include <net/if_types.h>
@


1.99
log
@Update section and table numbers inside comments in the RSN code to
the 802.11-2012 standard.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.98 2015/11/04 12:12:00 dlg Exp $	*/
d1012 8
a1019 2
	*frm++ = 0;
	memcpy(frm, ic->ic_sup_mcs, 16); frm += 16;
@


1.98
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.97 2015/07/15 22:16:42 deraadt Exp $	*/
d836 1
a836 1
 * Add an RSN element to a frame (see 7.3.2.25).
d849 1
a849 1
	/* write Group Data Cipher Suite field (see Table 20da) */
@


1.97
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.96 2015/06/30 13:54:42 mpi Exp $	*/
d242 1
a242 1
	IF_ENQUEUE(&ic->ic_mgtq, m);
d1870 1
a1870 1
		if (IF_IS_EMPTY(&ni->ni_savedq))
d1874 6
a1879 12
	if (IF_QFULL(&ni->ni_savedq)) {
		/* XXX should we drop the oldest instead? */
		IF_DROP(&ni->ni_savedq);
		m_freem(m);
	} else {
		IF_ENQUEUE(&ni->ni_savedq, m);
		/*
		 * Similar to ieee80211_mgmt_output, store the node in a
		 * special pkthdr field.
		 */
		m->m_pkthdr.ph_cookie = ni;
	}
@


1.96
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.95 2015/05/26 15:34:00 mpi Exp $	*/
d152 1
a152 2
	if (m)
		m_freem(m);
d630 1
a630 2
	if (m != NULL)
		m_freem(m);
@


1.95
log
@Use if_output() instead of rerolling it.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.94 2015/03/14 03:38:51 jsg Exp $	*/
d145 1
a145 1
		return (if_output(ifp, m));
@


1.94
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.93 2014/12/23 03:24:08 tedu Exp $	*/
d116 1
a116 2
	int s, len, error = 0;
	u_short mflags;
d145 1
a145 24
		/*
		 * Queue message on interface without adding any
		 * further headers, and start output if interface not
		 * yet active.
		 */
		mflags = m->m_flags;
		len = m->m_pkthdr.len;
		s = splnet();
		IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
		if (error) {
			/* mbuf is already freed */
			splx(s);
			printf("%s: failed to queue raw tx frame\n",
			    ifp->if_xname);
			return (error);
		}
		ifp->if_obytes += len;
		if (mflags & M_MCAST)
			ifp->if_omcasts++;
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
		splx(s);

		return (error);
@


1.93
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.92 2014/09/14 14:17:26 jsg Exp $	*/
a48 1
#include <net/if_arp.h>
@


1.92
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.91 2014/07/22 11:06:10 mpi Exp $	*/
a52 1
#ifdef INET
a58 1
#endif
a423 1
#ifdef INET
a425 1
#endif
a429 1
#ifdef INET
a470 1
#endif	/* INET */
@


1.91
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.90 2014/03/19 10:09:19 mpi Exp $	*/
a43 1
#include <sys/proc.h>
@


1.90
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.89 2013/12/07 01:55:06 brad Exp $	*/
a56 1
#include <netinet/in_systm.h>
@


1.89
log
@#if 0 out the ieee80211_edca_table table to appease the LLVM warning.

ieee80211_output.c:311:5: error: unused variable 'ieee80211_edca_table' [-Werror,-Wunused-const-variable]

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.88 2010/07/17 16:30:01 damien Exp $	*/
d205 5
a209 6
	 * Yech, hack alert!  We want to pass the node down to the
	 * driver's start routine.  We could stick this in an m_tag
	 * and tack that on to the mbuf.  However that's rather
	 * expensive to do for every frame so instead we stuff it in
	 * the rcvif field since outbound frames do not (presently)
	 * use this.
d214 1
a214 1
	m->m_pkthdr.rcvif = (void *)ni;
d1866 1
a1866 1
	m->m_pkthdr.rcvif = (void *)ni;
d1916 2
a1917 2
		 * Similar to ieee80211_mgmt_output, store the node in the
		 * rcvif field.
d1919 1
a1919 1
		m->m_pkthdr.rcvif = (void *)ni;
@


1.88
log
@use the correct block ack structure when building an ADDBA response.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.87 2009/05/24 07:46:04 damien Exp $	*/
d309 1
d337 1
@


1.87
log
@fix prev commit (s/ic_flags/ic_caps/).

from dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.86 2009/05/19 16:09:02 damien Exp $	*/
d1485 1
a1485 1
	struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];
@


1.86
log
@prevent injection of raw 802.11 control frames through bpf on drivers
that do not explicitly state this capability (using flag IEEE80211_C_RAWCTL).
also, perform all the sanity checks on injected raw 802.11 frames earlier
(in ieee80211_output instead of ieee80211_encap).

prevent kernel panics with many drivers when running aircrack-ng.
when/if all drivers are capable, we can remove this C_RAWCTL flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.85 2009/03/26 20:34:54 damien Exp $	*/
d146 1
a146 1
		if (!(ic->ic_flags & IEEE80211_C_RAWCTL) &&
@


1.85
log
@sync with 802.11w draft 8.0.
the SA Query Transaction Identifier field is now a 16-bit non-negative
counter value instead of a 128-bit random value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.84 2009/03/06 18:35:02 damien Exp $	*/
d119 1
d133 1
d140 11
a510 8

		if (m->m_pkthdr.len < sizeof(struct ieee80211_frame_min))
			goto bad;

		if ((wh->i_fc[0] & IEEE80211_FC0_VERSION_MASK) !=
		    IEEE80211_FC0_VERSION_0)
			goto bad;

@


1.84
log
@Fix setting of the Short Slot Time subfield of the Capability Information
field in (Re)Association Requests.
This fixes association with APs refusing non-short-slot-time capable STAs.
This should also prevent the AP we're associating with to disable the use
of short slot time in the BSS as we join.
Fix debug message in recv_assoc_resp() while I'm here (s/reason/status/).
Scary.

Thanks to Adam Emanuel for spotting this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.83 2009/01/28 18:55:18 damien Exp $	*/
d1556 1
a1556 1
	m = ieee80211_getmgmt(M_DONTWAIT, MT_DATA, 18);
d1563 3
a1565 1
	memcpy(frm, ni->ni_sa_query_trid, 16);
@


1.83
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.82 2009/01/26 21:28:55 damien Exp $	*/
d1316 1
a1316 2
	if ((ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME) &&
	    (ic->ic_flags & IEEE80211_F_SHSLOT))
@


1.82
log
@remove ni_ba field from ieee80211_node structure as it is not used yet.
this reduces memory footprint and avoids a stack usage warning in
ieee80211_find_node() that breaks amd64 build.

pointed out by landry@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.81 2009/01/26 19:09:41 damien Exp $	*/
d100 1
a100 1
	    struct ieee80211_node *, u_int8_t, u_int16_t);
d102 1
a102 1
	    struct ieee80211_node *, u_int8_t, u_int16_t);
d603 1
a603 1
		else if (ni->ni_ba[tid].ba_state == IEEE80211_BA_AGREED)
d1049 1
d1064 1
d1445 1
a1445 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
d1479 1
a1479 1
    u_int8_t tid, u_int16_t status)
d1481 1
a1481 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
d1493 1
a1493 1
	*frm++ = ba->ba_token;
d1495 3
a1497 1
	params = ba->ba_winsize << 6 | tid << 2 | IEEE80211_BA_ACK_POLICY;
d1499 5
a1503 1
	LE_WRITE_2(frm, ba->ba_timeout_val); frm += 2;
d1519 1
a1519 1
    u_int8_t tid, u_int16_t reason)
d1532 3
a1534 1
	params = tid << 12;	/* XXX initiator */
d1583 2
a1584 2
			m = ieee80211_get_addba_resp(ic, ni, arg & 0xffff,
			    arg >> 16);
d1587 1
a1587 1
			m = ieee80211_get_delba(ic, ni, arg & 0xffff,
@


1.81
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.80 2008/12/02 17:37:11 damien Exp $	*/
d602 1
d605 1
a605 1

@


1.80
log
@cleanup ieee80211_classify(): retrieve VLAN tag from m_pkthdr.ether_vtag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.79 2008/09/27 15:16:09 damien Exp $	*/
d7 1
a7 1
 * Copyright (c) 2007, 2008 Damien Bergamini
d96 12
d598 7
d606 2
a607 7
		qwh->i_qos[0] = tid;
		if (ic->ic_tid_noack & (1 << tid)) {
			qwh->i_qos[0] |= IEEE80211_QOS_ACK_POLICY_NOACK <<
			    IEEE80211_QOS_ACK_POLICY_SHIFT;
		}
		qwh->i_qos[1] = 0;	/* unused/set by hardware */
		*(u_int16_t *)&qwh->i_seq[0] =
d967 1
a967 1
	case IEEE80211_CIPHER_AES128_CMAC:
d1030 49
d1106 1
d1120 2
a1121 1
		2 + rs->rs_nrates - IEEE80211_RATE_SIZE : 0));
d1130 4
d1143 12
a1154 10
 * [8]    Timestamp
 * [2]    Beacon interval
 * [2]    Capability
 * [tlv]  Service Set Identifier (SSID)
 * [tlv]  Supported rates
 * [tlv*] DS Parameter Set (802.11g)
 * [tlv]  ERP Information (802.11g)
 * [tlv]  Extended Supported Rates (802.11g)
 * [tlv]  RSN (802.11i)
 * [tlv]  EDCA Parameter Set (802.11e)
d1178 2
a1179 1
		2 + IEEE80211_WPAIE_MAXLEN : 0));
d1205 6
d1276 1
d1298 1
a1298 1
	    ((ic->ic_flags & IEEE80211_F_QOS) ? 2 + 1 : 0) +
d1301 2
a1302 1
		2 + IEEE80211_WPAIE_MAXLEN : 0));
d1329 1
a1329 2
	if ((ic->ic_flags & IEEE80211_F_QOS) &&
	    (ni->ni_flags & IEEE80211_NODE_QOS))
d1334 4
d1353 3
d1370 3
a1372 1
	    ((ic->ic_flags & IEEE80211_F_QOS) ? 2 + 18 : 0));
d1387 1
a1387 2
	if ((ic->ic_flags & IEEE80211_F_QOS) &&
	    (ni->ni_flags & IEEE80211_NODE_QOS))
d1389 11
d1428 168
d1603 1
a1603 1
    int type, int arg)
d1634 1
a1634 1
		m = ieee80211_get_auth(ic, ni, arg >> 16, arg & 0xffff);
d1643 1
a1643 1
		if ((m = ieee80211_get_deauth(ic, ni, arg)) == NULL)
d1648 2
a1649 1
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr), arg);
d1663 1
a1663 1
		if ((m = ieee80211_get_assoc_resp(ic, ni, arg)) == NULL)
d1668 1
a1668 1
		if ((m = ieee80211_get_disassoc(ic, ni, arg)) == NULL)
d1673 2
a1674 1
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr), arg);
d1678 7
d1758 14
a1771 12
 * [8]    Timestamp
 * [2]    Beacon interval
 * [2]    Capability
 * [tlv]  Service Set Identifier (SSID)
 * [tlv]  Supported rates
 * [tlv*] DS Parameter Set (802.11g)
 * [tlv*] IBSS Parameter Set
 * [tlv]  Traffic Indication Map (TIM)
 * [tlv]  ERP Information (802.11g)
 * [tlv]  Extended Supported Rates (802.11g)
 * [tlv]  RSN (802.11i)
 * [tlv]  EDCA Parameter Set (802.11e)
d1796 2
a1797 1
		2 + IEEE80211_WPAIE_MAXLEN : 0));
d1840 6
@


1.79
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.77 2008/09/03 19:53:37 damien Exp $	*/
d407 2
a408 7
	if ((m->m_flags & M_PROTO1) == M_PROTO1 && m->m_pkthdr.rcvif != NULL) {
		struct ifvlan *ifv = m->m_pkthdr.rcvif->if_softc;

		/* use VLAN 802.1D user-priority */
		if (ifv->ifv_prio <= 7)
			return ifv->ifv_prio;
	}
@


1.78
log
@Add some inline functions to test the presence of optional 802.11
header fields (Sequence Control, Address 4, QoS Control, +HTC) and
use them where appropriate.

Add ieee80211_get_qos() inline function to extract the QoS control
field of an 802.11 header instead of duplicating the same scary
code everywhere (the location of this field depends on the presence
of an Address 4 field).

Export ieee80211_up_to_ac() so that drivers can select the access
category to use based on the TID subfield of the QoS Control field.

Define more QoS-related bits for the RSN Capabilities field of RSN IE
(will be used later).
@
text
@d922 1
a922 1
	if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_8021X) {
d927 1
a927 1
	if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_PSK) {
d941 11
a953 3

	/* no PMKID List for now */
	LE_WRITE_2(frm, 0); frm += 2;
@


1.77
log
@third parameter of ieee80211_get_assoc_req() is a management frame
subtype, not a boolean indicating assoc or reassoc.
rename the parameter and use if (type == IEEE80211_FC0_SUBTYPE_REASSOC_REQ)
instead of if (reassoc).
it worked only because IEEE80211_FC0_SUBTYPE_ASSOC_REQ is equal to 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.76 2008/09/01 19:55:21 damien Exp $	*/
a71 1
enum	ieee80211_edca_ac ieee80211_up_to_ac(struct ieee80211com *, int);
@


1.76
log
@add ic_tid_noack bitmap to indicate a per-TID ACK policy (1=no ack,
0=normal ack).  all bits are currently set to 0.
use this bitmap to set the ACK policy of the QoS control field of
outgoing QoS frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.75 2008/09/01 19:43:33 damien Exp $	*/
d1199 1
a1199 1
    int reassoc)
d1208 1
a1208 1
	    ((reassoc == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) ?
d1236 1
a1236 1
	if (reassoc) {
@


1.75
log
@extend ieee80211_classify() to extract DSCP field from IPv6 packets too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.74 2008/09/01 19:41:10 damien Exp $	*/
d350 1
a350 1
	/* IEEE Std 802.11e-2005, table 20i */
d371 1
a371 1
	 * IEEE Std 802.11e-2005 section 9.9.3.1.2.  The spec says that
d593 6
a598 2
		qwh->i_qos[0] = tid & 0xf;
		qwh->i_qos[1] = 0;	/* no TXOP requested */
d1512 1
a1512 1
	     (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)) ?
@


1.74
log
@rework previously unused ieee80211_pwrsave() function, call it from
ieee80211_mgmt_output() and ieee80211_encap().
use new IEEE80211_C_APPMGT capability flag where appropriate.
rename ic_tim_mcast to ic_tim_mcast_pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.73 2008/08/29 12:14:53 damien Exp $	*/
d59 3
d404 2
a405 1
	const struct ether_header *eh;
d409 1
a409 1
		const struct ifvlan *ifv = m->m_pkthdr.rcvif->if_softc;
d419 38
a456 21
		const struct ip *ip = (const struct ip *)(eh + 1);
		/*
		 * Map Differentiated Services Codepoint field (see RFC2474).
		 * Preserves backward compatibility with IP Precedence field.
		 */
		switch (ip->ip_tos & 0xfc) {
		case IPTOS_PREC_PRIORITY:
			return 2;
		case IPTOS_PREC_IMMEDIATE:
			return 1;
		case IPTOS_PREC_FLASH:
			return 3;
		case IPTOS_PREC_FLASHOVERRIDE:
			return 4;
		case IPTOS_PREC_CRITIC_ECP:
			return 5;
		case IPTOS_PREC_INTERNETCONTROL:
			return 6;
		case IPTOS_PREC_NETCONTROL:
			return 7;
		}
d458 1
a458 1
#endif
@


1.73
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.72 2008/08/27 09:05:04 damien Exp $	*/
d241 5
d614 7
d733 1
a733 1
	if (ic->ic_dtim_count == 0 && ic->ic_tim_mcast)
d1542 14
a1555 7
void
ieee80211_pwrsave(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct mbuf *m)
{
	/* store the new packet on our queue, changing the TIM if necessary */
	if (IF_IS_EMPTY(&ni->ni_savedq))
		(*ic->ic_set_tim)(ic, ni->ni_associd, 1);
d1557 25
a1581 1
	if (ni->ni_savedq.ifq_len >= IEEE80211_PS_MAX_QUEUE) {
a1583 7
		if (ic->ic_if.if_flags & IFF_DEBUG)
			printf("%s: station %s power save queue overflow"
			    " of size %d drops %d\n",
			    ic->ic_if.if_xname,
			    ether_sprintf(ni->ni_macaddr),
			    IEEE80211_PS_MAX_QUEUE,
			    ni->ni_savedq.ifq_drops);
d1585 1
d1587 2
a1588 2
		 * Similar to ieee80211_mgmt_output, store the node in
		 * the rcvif field.
a1589 1
		IF_ENQUEUE(&ni->ni_savedq, m);
d1592 1
@


1.72
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.71 2008/08/15 08:15:27 damien Exp $	*/
a274 1
 * FH		15	1023
a278 6
	[IEEE80211_MODE_FH] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4, 10, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 2,   0 },
		[EDCA_AC_VO] = { 2,  3, 2,   0 }
	},
a307 6
	[IEEE80211_MODE_FH] = {
		[EDCA_AC_BK] = { 4, 10, 7,   0 },
		[EDCA_AC_BE] = { 4,  6, 3,   0 },
		[EDCA_AC_VI] = { 3,  4, 1,   0 },
		[EDCA_AC_VO] = { 2,  3, 1,   0 }
	},
a680 18
 * Add a FH Parameter Set element to a frame (see 7.3.2.3).
 */
u_int8_t *
ieee80211_add_fh_params(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	u_int chan = ieee80211_chan2ieee(ic, ni->ni_chan);

	*frm++ = IEEE80211_ELEMID_FHPARMS;
	*frm++ = 5;
	LE_WRITE_2(frm, ni->ni_fhdwell); frm += 2;
	*frm++ = IEEE80211_FH_CHANSET(chan);
	*frm++ = IEEE80211_FH_CHANPAT(chan);
	*frm++ = ni->ni_fhindex;
	return frm;
}

/*
a1039 1
 * [tlv*] Frequency-Hopping (FH) Parameter Set
d1057 1
a1057 1
	    2 + ((ic->ic_phytype == IEEE80211_T_FH) ? 5 : 1) +
d1079 1
a1079 4
	if (ic->ic_phytype == IEEE80211_T_FH)
		frm = ieee80211_add_fh_params(frm, ic, ni);
	else
		frm = ieee80211_add_ds_params(frm, ic, ni);
a1448 1
 * [tlv*] Frequency-Hopping (FH) Parameter Set
d1469 1
a1469 1
	    2 + ((ic->ic_phytype == IEEE80211_T_FH) ? 5 : 1) +
d1506 1
a1506 4
	if (ic->ic_phytype == IEEE80211_T_FH)
		frm = ieee80211_add_fh_params(frm, ic, ni);
	else
		frm = ieee80211_add_ds_params(frm, ic, ni);
@


1.71
log
@use LLC_SNAPFRAMELEN here too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.70 2008/08/12 19:56:59 damien Exp $	*/
d78 1
d81 1
d88 1
d91 1
d221 4
a224 1
		if (ic->ic_opmode == IEEE80211_M_IBSS ||
d312 1
d346 1
d370 1
d373 1
a373 1

d597 1
d611 3
a613 1
	case IEEE80211_M_MONITOR:
d642 1
d648 1
d650 1
d654 1
d692 1
d835 1
d1063 1
d1134 1
d1257 1
d1303 1
d1357 1
a1357 1

d1362 1
a1362 1

d1389 1
a1389 1

d1395 1
a1395 1

d1476 1
d1596 1
@


1.70
log
@add the code to encrypt/decrypt management frames, retrieve key id
from MMIE etc...
this code can't be triggered as no drivers claim MFP capability yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.69 2008/08/12 19:29:07 damien Exp $	*/
d550 1
a550 1
	m_adj(m, sizeof(struct ether_header) - sizeof(struct llc));
d1184 1
a1184 1
	    2 +	2 +
d1254 1
a1254 1
	    2 +	2 + 2 +
@


1.69
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.68 2008/08/12 19:21:04 damien Exp $	*/
d196 18
@


1.68
log
@add/process group integrity cipher suite in RSN IEs.
add support for MFP negotiation during association.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.67 2008/08/12 19:05:39 damien Exp $	*/
d870 1
a870 1
	if (ni->ni_rsnakms & IEEE80211_AKM_IEEE8021X) {
d878 10
@


1.67
log
@add IEEE80211_RSNIE_MAXLEN and IEEE80211_WPAIE_MAXLEN definitions
instead of hard-coding values.
for RSN IE, request space for Group Integrity Cipher Suite.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.66 2008/08/02 08:35:48 damien Exp $	*/
d826 1
a826 1
	/* write Group Cipher Suite field (see Table 20da) */
d843 1
a843 1
		panic("invalid group cipher!");
d883 2
a884 3
	if (!wpa) {
		/* write RSN Capabilities field */
		LE_WRITE_2(frm, ni->ni_rsncaps); frm += 2;
d886 18
a903 1
		/* no PMKID List for now */
@


1.66
log
@do not use IEEE80211_QOS_TID.  its definition in ieee80211.h is
wrong.  hard-code 0xf for now.  will be fixed post-release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.65 2008/08/02 08:33:21 damien Exp $	*/
d1031 2
a1032 1
	      (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_RSN)) ? 2 + 44 : 0) +
d1035 2
a1036 1
	      (ic->ic_bss->ni_rsnprotos & IEEE80211_PROTO_WPA)) ? 2 + 48 : 0));
d1148 2
a1149 1
	      (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)) ? 2 + 44 : 0) +
d1152 2
a1153 1
	      (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)) ? 2 + 48 : 0));
d1443 2
a1444 1
	     (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)) ? 2 + 44 : 0) +
d1447 2
a1448 1
	      (ni->ni_rsnprotos & IEEE80211_PROTO_WPA)) ? 2 + 48 : 0));
@


1.65
log
@do not touch m after it has been enqueued with IFQ_ENQUEUE().
copy m_pkthdr.len and m_flags before and use that after to update
the statistics.

from altq(4) man page and for consistency with what is done in
other parts of the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.64 2008/08/02 08:20:16 damien Exp $	*/
d552 1
a552 1
		qwh->i_qos[0] = tid & IEEE80211_QOS_TID;
@


1.64
log
@Drop frames that are received unencrypted when WEP is on or when
WPA is on and RX protection for TA is on.
Keep track of the TX/RX protection for each node when WPA is on.

tested by djm@@ (ral+wpa), ckuethe@@ (ath-noenc) and krw@@ (wpi<->ral+wpa).
hints from bluhm@@
has been in snaps for a few days.

pointed out by bluhm@@ something like 1 year ago but we did not have
the right infrastructure to fix it properly at that time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.63 2008/07/27 14:21:15 damien Exp $	*/
a100 2
	u_int dlt = 0;
	int s, error = 0;
d102 2
d114 1
a114 1
		dlt = *(u_int *)(mtag + 1);
d125 2
d136 2
a137 2
		ifp->if_obytes += m->m_pkthdr.len;
		if (m->m_flags & M_MCAST)
@


1.63
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.62 2008/07/23 15:55:46 damien Exp $	*/
d504 2
a505 1
	if ((ic->ic_flags & IEEE80211_F_RSNON) && !ni->ni_port_valid &&
d585 2
a586 1
	    ((ic->ic_flags & IEEE80211_F_RSNON) && ni->ni_port_valid))
@


1.62
log
@Fix a blatant misuse of MINCLSIZE I introduced in ieee80211_output.c r1.59
The bug was added on 04/16 but it started to show up only after 06/12 when
the value of MINCLSIZE was changed to something different from MHLEN + 1.

Thanks to dlg@@ and giovanni (qgiovanni at gmail dot com) for putting me
on the right track.

Tested by giovanni.
Should fix system/5881 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.61 2008/07/21 19:27:26 damien Exp $	*/
d498 2
a499 2
		IEEE80211_DPRINTF(("%s: no node for dst %s, discard frame\n",
		    __func__, ether_sprintf(eh.ether_dhost)));
d506 2
a507 2
		IEEE80211_DPRINTF(("%s: port not valid: %s\n",
		    __func__, ether_sprintf(eh.ether_dhost)));
d1332 1
a1332 2
		IEEE80211_DPRINTF(("%s: invalid mgmt frame type %u\n",
		    __func__, type));
d1426 1
a1426 1
	    8 +	2 + 2 +
@


1.61
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.60 2008/07/21 19:05:21 damien Exp $	*/
d954 1
a954 1
	if (pktlen >= MINCLSIZE) {
@


1.60
log
@move processing of EAPOL frames away from ieee80211_{input,output}.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.59 2008/04/16 18:32:15 damien Exp $	*/
d67 1
a596 6

/* unaligned little endian access */
#define LE_WRITE_2(p, v) do {			\
	((u_int8_t *)(p))[0] = (v) & 0xff;	\
	((u_int8_t *)(p))[1] = (v) >> 8;	\
} while (0)
@


1.59
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.58 2007/08/27 20:14:21 damien Exp $	*/
a88 7
int	ieee80211_send_eapol_key(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, const struct ieee80211_ptk *);
u_int8_t *ieee80211_add_gtk_kde(u_int8_t *, struct ieee80211_node *,
	    const struct ieee80211_key *);
u_int8_t *ieee80211_add_pmkid_kde(u_int8_t *, const u_int8_t *);
struct	mbuf *ieee80211_get_eapol_key(int, int, u_int);

a1494 557
}

/* unaligned big endian access */
#define BE_READ_2(p)				\
	((u_int16_t)(p)[0] << 8 | (u_int16_t)(p)[1])

#define BE_WRITE_2(p, v) do {			\
	(p)[0] = (v) >>  8; (p)[1] = (v);	\
} while (0)

#define BE_WRITE_8(p, v) do {			\
	(p)[0] = (v) >> 56; (p)[1] = (v) >> 48;	\
	(p)[2] = (v) >> 40; (p)[3] = (v) >> 32;	\
	(p)[4] = (v) >> 24; (p)[5] = (v) >> 16;	\
	(p)[6] = (v) >>  8; (p)[7] = (v);	\
} while (0)

/* unaligned little endian access */
#define LE_WRITE_6(p, v) do {			\
	(p)[5] = (v) >> 40; (p)[4] = (v) >> 32;	\
	(p)[3] = (v) >> 24; (p)[2] = (v) >> 16;	\
	(p)[1] = (v) >>  8; (p)[0] = (v);	\
} while (0)

/*
 * Handle EAPOL-Key timeouts (no answer from supplicant).
 */
void
ieee80211_eapol_timeout(void *arg)
{
	struct ieee80211_node *ni = arg;
	struct ieee80211com *ic = ni->ni_ic;
	int s;

	IEEE80211_DPRINTF(("%s: no answer from station %s in state %d\n",
	    __func__, ether_sprintf(ni->ni_macaddr), ni->ni_rsn_state));

	s = splnet();

	switch (ni->ni_rsn_state) {
	case RSNA_PTKSTART:
	case RSNA_PTKCALCNEGOTIATING:
		(void)ieee80211_send_4way_msg1(ic, ni);
		break;
	case RSNA_PTKINITNEGOTIATING:
		(void)ieee80211_send_4way_msg3(ic, ni);
		break;
	}

	switch (ni->ni_rsn_gstate) {
	case RSNA_REKEYNEGOTIATING:
		(void)ieee80211_send_group_msg1(ic, ni);
		break;
	}

	splx(s);
}

/*
 * Send an EAPOL-Key frame to node `ni'.  If MIC or encryption is required,
 * the PTK must be passed (otherwise it can be set to NULL.)
 */
int
ieee80211_send_eapol_key(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, const struct ieee80211_ptk *ptk)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ether_header *eh;
	struct ieee80211_eapol_key *key;
	u_int16_t len, info;
	int s, error;

	M_PREPEND(m, sizeof(struct ether_header), M_DONTWAIT);
	if (m == NULL)
		return ENOMEM;
	/* no need to m_pullup here (ok by construction) */
	eh = mtod(m, struct ether_header *);
	eh->ether_type = htons(ETHERTYPE_PAE);
	IEEE80211_ADDR_COPY(eh->ether_shost, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(eh->ether_dhost, ni->ni_macaddr);

	key = (struct ieee80211_eapol_key *)&eh[1];
	key->version = EAPOL_VERSION;
	key->type = EAPOL_KEY;
	key->desc = (ni->ni_rsnprotos == IEEE80211_PROTO_RSN) ?
	    EAPOL_KEY_DESC_IEEE80211 : EAPOL_KEY_DESC_WPA;

	info = BE_READ_2(key->info);
	/* use V2 descriptor if pairwise or group cipher is CCMP */
	if (ni->ni_rsncipher == IEEE80211_CIPHER_CCMP ||
	    ni->ni_rsngroupcipher == IEEE80211_CIPHER_CCMP)
		info |= EAPOL_KEY_DESC_V2;
	else
		info |= EAPOL_KEY_DESC_V1;
	BE_WRITE_2(key->info, info);

	len = m->m_len - sizeof(struct ether_header);
	BE_WRITE_2(key->paylen, len - sizeof(*key));
	BE_WRITE_2(key->len, len - 4);

	if (info & EAPOL_KEY_ENCRYPTED) {
		if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA) {
			/* clear "Encrypted" bit for WPA */
			info &= ~EAPOL_KEY_ENCRYPTED;
			BE_WRITE_2(key->info, info);
		}
		ieee80211_eapol_key_encrypt(ic, key, ptk->kek);

		if ((info & EAPOL_KEY_VERSION_MASK) == EAPOL_KEY_DESC_V2) {
			/* AES Key Wrap adds 8 bytes + padding */
			m->m_pkthdr.len = m->m_len =
			    sizeof(*eh) + 4 + BE_READ_2(key->len);
		}
	}
	if (info & EAPOL_KEY_KEYMIC)
		ieee80211_eapol_key_mic(key, ptk->kck);

	s = splnet();
	/* start a 100ms timeout if an answer is expected from supplicant */
	if (info & EAPOL_KEY_KEYACK)
		timeout_add(&ni->ni_rsn_timeout, hz / 10);
	IFQ_ENQUEUE(&ifp->if_snd, m, NULL, error);
	if (error == 0) {
		ifp->if_obytes += m->m_pkthdr.len;
		if ((ifp->if_flags & IFF_OACTIVE) == 0)
			(*ifp->if_start)(ifp);
	}
	splx(s);

	return error;
}

/*
 * Add a GTK KDE to an EAPOL-Key frame (see Figure 144).
 */
u_int8_t *
ieee80211_add_gtk_kde(u_int8_t *frm, struct ieee80211_node *ni,
    const struct ieee80211_key *k)
{
	KASSERT(k->k_flags & IEEE80211_KEY_GROUP);

	*frm++ = IEEE80211_ELEMID_VENDOR;
	*frm++ = 6 + k->k_len;
	memcpy(frm, IEEE80211_OUI, 3); frm += 3;
	*frm++ = IEEE80211_KDE_GTK;
	*frm = k->k_id & 3;
	/*
	 * The TxRx flag for sending a GTK is always the opposite of whether
	 * the pairwise key is used for data encryption/integrity or not.
	 */
	if (ni->ni_rsncipher == IEEE80211_CIPHER_USEGROUP)
		*frm |= 1 << 2;	/* set the Tx bit */
	frm++;
	*frm++ = 0;	/* reserved */
	memcpy(frm, k->k_key, k->k_len);
	return frm + k->k_len;
}

/*
 * Add a PMKID KDE to an EAPOL-Key frame (see Figure 146).
 */
u_int8_t *
ieee80211_add_pmkid_kde(u_int8_t *frm, const u_int8_t *pmkid)
{
	*frm++ = IEEE80211_ELEMID_VENDOR;
	*frm++ = 20;
	memcpy(frm, IEEE80211_OUI, 3); frm += 3;
	*frm++ = IEEE80211_KDE_PMKID;
	memcpy(frm, pmkid, IEEE80211_PMKID_LEN);
	return frm + IEEE80211_PMKID_LEN;
}

struct mbuf *
ieee80211_get_eapol_key(int flags, int type, u_int pktlen)
{
	struct mbuf *m;

	/* reserve space for 802.11 encapsulation and EAPOL-Key header */
	pktlen += sizeof(struct ieee80211_frame) + sizeof(struct llc) +
	    sizeof(struct ieee80211_eapol_key);

	if (pktlen > MCLBYTES)
		panic("EAPOL-Key frame too large: %u", pktlen);
	MGETHDR(m, flags, type);
	if (m == NULL)
		return NULL;
	if (pktlen >= MINCLSIZE) {
		MCLGET(m, flags);
		if (!(m->m_flags & M_EXT))
			return m_free(m);
	}
	m->m_data += sizeof(struct ieee80211_frame) + sizeof(struct llc);
	return m;
}

/*
 * 4-Way Handshake Message 1 is sent by the authenticator to the supplicant
 * (see 8.5.3.1).
 */
int
ieee80211_send_4way_msg1(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ieee80211_eapol_key *key;
	struct mbuf *m;
	u_int16_t info, keylen;
	u_int8_t *frm;

	ni->ni_rsn_state = RSNA_PTKSTART;
	if (++ni->ni_rsn_retries > 3) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_4WAY_TIMEOUT);
		ieee80211_node_leave(ic, ni);
		return 0;
	}
	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA,
	    (ni->ni_rsnprotos == IEEE80211_PROTO_RSN) ? 2 + 20 : 0);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_KEYACK;
	BE_WRITE_2(key->info, info);

	/* copy the authenticator's nonce (ANonce) */
	memcpy(key->nonce, ni->ni_nonce, EAPOL_KEY_NONCE_LEN);

	keylen = ieee80211_cipher_keylen(ni->ni_rsncipher);
	BE_WRITE_2(key->keylen, keylen);

	frm = (u_int8_t *)&key[1];
	/* WPA does not have PMKID KDE */
	if (ni->ni_rsnprotos == IEEE80211_PROTO_RSN &&
	    ni->ni_rsnakms == IEEE80211_AKM_IEEE8021X) {
		/* XXX retrieve PMKID from the PMKSA cache */
		/* frm = ieee80211_add_pmkid_kde(frm, pmkid); */
	}

	m->m_pkthdr.len = m->m_len = frm - (u_int8_t *)key;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 1, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	ni->ni_replaycnt++;
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);

	return ieee80211_send_eapol_key(ic, m, ni, NULL);
}

/*
 * 4-Way Handshake Message 2 is sent by the supplicant to the authenticator
 * (see 8.5.3.2).
 */
int
ieee80211_send_4way_msg2(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *replaycnt, const struct ieee80211_ptk *tptk)
{
	struct ieee80211_eapol_key *key;
	struct mbuf *m;
	u_int16_t info;
	u_int8_t *frm;

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA,
	    2 + 48);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_KEYMIC;
	BE_WRITE_2(key->info, info);

	/* copy key replay counter from Message 1/4 */
	memcpy(key->replaycnt, replaycnt, 8);

	/* copy the supplicant's nonce (SNonce) */
	memcpy(key->nonce, ic->ic_nonce, EAPOL_KEY_NONCE_LEN);

	frm = (u_int8_t *)&key[1];
	/* add the WPA/RSN IE used in the (Re)Association Request */
	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA) {
		u_int16_t keylen;
		frm = ieee80211_add_wpa(frm, ic, ni);
		/* WPA sets the key length field here */
		keylen = ieee80211_cipher_keylen(ni->ni_rsncipher);
		BE_WRITE_2(key->keylen, keylen);
	} else	/* RSN */
		frm = ieee80211_add_rsn(frm, ic, ni);

	m->m_pkthdr.len = m->m_len = frm - (u_int8_t *)key;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 2, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, tptk);
}

/*
 * 4-Way Handshake Message 3 is sent by the authenticator to the supplicant
 * (see 8.5.3.3).
 */
int
ieee80211_send_4way_msg3(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ieee80211_eapol_key *key;
	struct ieee80211_key *k;
	struct mbuf *m;
	u_int16_t info, keylen;
	u_int8_t *frm;

	ni->ni_rsn_state = RSNA_PTKINITNEGOTIATING;
	if (++ni->ni_rsn_retries > 3) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_4WAY_TIMEOUT);
		ieee80211_node_leave(ic, ni);
		return 0;
	}
	if (ni->ni_rsnprotos == IEEE80211_PROTO_RSN)
		k = &ic->ic_nw_keys[ic->ic_def_txkey];

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA,
	    2 + 48 +
	    ((ni->ni_rsnprotos == IEEE80211_PROTO_RSN) ?
		2 + 6 + k->k_len : 0) +
	    8);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_KEYACK | EAPOL_KEY_KEYMIC;
	if (ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP)
		info |= EAPOL_KEY_INSTALL;

	/* use same nonce as in Message 1 */
	memcpy(key->nonce, ni->ni_nonce, EAPOL_KEY_NONCE_LEN);

	ni->ni_replaycnt++;
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);

	keylen = ieee80211_cipher_keylen(ni->ni_rsncipher);
	BE_WRITE_2(key->keylen, keylen);

	frm = (u_int8_t *)&key[1];
	/* add the WPA/RSN IE included in Beacon/Probe Response */
	if (ni->ni_rsnprotos == IEEE80211_PROTO_RSN) {
		frm = ieee80211_add_rsn(frm, ic, ic->ic_bss);
		/* encapsulate the GTK and ask for encryption */
		frm = ieee80211_add_gtk_kde(frm, ni, k);
		LE_WRITE_6(key->rsc, k->k_tsc);
		info |= EAPOL_KEY_ENCRYPTED | EAPOL_KEY_SECURE;
	} else	/* WPA */
		frm = ieee80211_add_wpa(frm, ic, ic->ic_bss);

	/* write the key info field */
	BE_WRITE_2(key->info, info);

	m->m_pkthdr.len = m->m_len = frm - (u_int8_t *)key;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 3, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, &ni->ni_ptk);
}

/*
 * 4-Way Handshake Message 4 is sent by the supplicant to the authenticator
 * (see 8.5.3.4).
 */
int
ieee80211_send_4way_msg4(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ieee80211_eapol_key *key;
	struct mbuf *m;
	u_int16_t info;

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA, 0);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_KEYMIC;

	/* copy key replay counter from authenticator */
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);

	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA) {
		u_int16_t keylen;
		/* WPA sets the key length field here */
		keylen = ieee80211_cipher_keylen(ni->ni_rsncipher);
		BE_WRITE_2(key->keylen, keylen);
	} else
		info |= EAPOL_KEY_SECURE;

	/* write the key info field */
	BE_WRITE_2(key->info, info);

	/* empty key data field */
	m->m_pkthdr.len = m->m_len = sizeof(*key);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 4, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, &ni->ni_ptk);
}

/*
 * Group Key Handshake Message 1 is sent by the authenticator to the
 * supplicant (see 8.5.4.1).
 */
int
ieee80211_send_group_msg1(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ieee80211_eapol_key *key;
	const struct ieee80211_key *k;
	struct mbuf *m;
	u_int16_t info;
	u_int8_t *frm;

	ni->ni_rsn_gstate = RSNA_REKEYNEGOTIATING;
	if (++ni->ni_rsn_retries > 3) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_GROUP_TIMEOUT);
		ieee80211_node_leave(ic, ni);
		return 0;
	}
	k = &ic->ic_nw_keys[ic->ic_def_txkey];

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA,
	    ((ni->ni_rsnprotos == IEEE80211_PROTO_WPA) ?
		k->k_len : 2 + 6 + k->k_len) +
	    8);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_KEYACK | EAPOL_KEY_KEYMIC | EAPOL_KEY_SECURE |
	    EAPOL_KEY_ENCRYPTED;

	ni->ni_replaycnt++;
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);

	frm = (u_int8_t *)&key[1];
	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA) {
		/* WPA does not have GTK KDE */
		BE_WRITE_2(key->keylen, k->k_len);
		memcpy(frm, k->k_key, k->k_len);
		frm += k->k_len;
		info |= (k->k_id & 0x3) << EAPOL_KEY_WPA_KID_SHIFT;
		if (ni->ni_rsncipher == IEEE80211_CIPHER_USEGROUP)
			info |= EAPOL_KEY_WPA_TX;
	} else	/* RSN */
		frm = ieee80211_add_gtk_kde(frm, ni, k);

	/* RSC = last transmit sequence number for the GTK */
	LE_WRITE_6(key->rsc, k->k_tsc);

	/* write the key info field */
	BE_WRITE_2(key->info, info);

	m->m_pkthdr.len = m->m_len = frm - (u_int8_t *)key;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 1, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, &ni->ni_ptk);
}

/*
 * Group Key Handshake Message 2 is sent by the supplicant to the
 * authenticator (see 8.5.4.2).
 */
int
ieee80211_send_group_msg2(struct ieee80211com *ic, struct ieee80211_node *ni,
    const struct ieee80211_key *k)
{
	struct ieee80211_eapol_key *key;
	u_int16_t info;
	struct mbuf *m;

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA, 0);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info = EAPOL_KEY_KEYMIC | EAPOL_KEY_SECURE;

	/* copy key replay counter from authenticator */
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);

	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA) {
		/* WPA sets the key length and key id fields here */
		BE_WRITE_2(key->keylen, k->k_len);
		info |= (k->k_id & 3) << EAPOL_KEY_WPA_KID_SHIFT;
	}

	/* write the key info field */
	BE_WRITE_2(key->info, info);

	/* empty key data field */
	m->m_pkthdr.len = m->m_len = sizeof(*key);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending msg %d/%d of the %s handshake to %s\n",
		    ic->ic_if.if_xname, 2, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, &ni->ni_ptk);
}

/*
 * EAPOL-Key Request frames are sent by the supplicant to request that the
 * authenticator initiates either a 4-Way Handshake or Group Key Handshake,
 * or to report a MIC failure in a TKIP MSDU.
 */
int
ieee80211_send_eapol_key_req(struct ieee80211com *ic,
    struct ieee80211_node *ni, u_int16_t info, u_int64_t tsc)
{
	struct ieee80211_eapol_key *key;
	struct mbuf *m;

	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA, 0);
	if (m == NULL)
		return ENOMEM;
	key = mtod(m, struct ieee80211_eapol_key *);
	memset(key, 0, sizeof(*key));

	info |= EAPOL_KEY_REQUEST;
	BE_WRITE_2(key->info, info);

	/* in case of TKIP MIC failure, fill the RSC field */
	if (info & EAPOL_KEY_ERROR)
		LE_WRITE_6(key->rsc, tsc);

	/* use our separate key replay counter for key requests */
	BE_WRITE_8(key->replaycnt, ni->ni_reqreplaycnt);
	ni->ni_reqreplaycnt++;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: sending EAPOL-Key request to %s\n",
		    ic->ic_if.if_xname, ether_sprintf(ni->ni_macaddr));

	return ieee80211_send_eapol_key(ic, m, ni, &ni->ni_ptk);
@


1.58
log
@rework ieee80211_recv_4way_msg2() function.
add some RSNA authenticator state machine bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.57 2007/08/27 18:53:27 damien Exp $	*/
d7 1
a7 1
 * Copyright (c) 2007 Damien Bergamini
a67 2
#include <dev/rndvar.h>

d74 1
a74 1
struct	mbuf *ieee80211_getmbuf(int, int, u_int);
d90 3
a92 2
	    struct ieee80211_node *);
u_int8_t *ieee80211_add_gtk_kde(u_int8_t *, const struct ieee80211_key *);
d509 3
a511 2
#if 0
	if (!ni->ni_port_valid && eh.ether_type != htons(ETHERTYPE_PAE)) {
d517 5
a521 1
#endif
d588 5
a592 2
	if (ic->ic_flags & IEEE80211_F_WEPON)
		wh->i_fc[1] |= IEEE80211_FC1_WEP;
d625 2
a626 1
	if (ic->ic_flags & IEEE80211_F_WEPON)
d825 1
a825 1
    const struct ieee80211_node *ni, int wpa1)
d827 1
a827 1
	const u_int8_t *oui = wpa1 ? MICROSOFT_OUI : IEEE80211_OUI;
d836 1
a836 5
	switch (ni->ni_group_cipher) {
	case IEEE80211_CIPHER_USEGROUP:
		/* can't get there */
		panic("invalid group cipher!");
		break;
d849 3
d857 1
a857 1
	if (ni->ni_pairwise_cipherset & IEEE80211_CIPHER_USEGROUP) {
d862 1
a862 1
	if (ni->ni_pairwise_cipherset & IEEE80211_CIPHER_TKIP) {
d867 1
a867 1
	if (ni->ni_pairwise_cipherset & IEEE80211_CIPHER_CCMP) {
d878 1
a878 1
	if (ni->ni_akmset & IEEE80211_AKM_IEEE8021X) {
d883 1
a883 1
	if (ni->ni_akmset & IEEE80211_AKM_PSK) {
d891 3
a893 4
	/* write RSN Capabilities field */
	LE_WRITE_2(frm, ni->ni_rsncaps); frm += 2;

	/* no PMKID List for now */
d895 2
d916 2
a917 2
 * Add a vendor specific WPA1 element to a frame.
 * This is required for compatibility with Wi-Fi Alliance WPA1/WPA1+WPA2.
d920 1
a920 1
ieee80211_add_wpa1(u_int8_t *frm, struct ieee80211com *ic,
d928 1
a928 1
	*frm++ = 1;	/* WPA1 */
d954 1
a954 1
ieee80211_getmbuf(int flags, int type, u_int pktlen)
d958 1
a958 1
	/* account for 802.11 header */
d962 1
a962 1
		panic("802.11 packet too large: %u", pktlen);
d964 3
a966 1
	if (m != NULL && pktlen > MHLEN) {
d969 1
a969 1
			m = m_free(m);
d971 1
d989 1
a989 1
	m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
a996 2
	m->m_data += sizeof(struct ieee80211_frame);

d1029 1
a1029 1
	m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
d1038 2
a1039 1
	    ((ic->ic_flags & IEEE80211_F_RSN) ? 2 + 44 : 0) +
d1041 2
a1042 1
	    ((ic->ic_flags & IEEE80211_F_WPA1) ? 2 + 48 : 0));
a1045 2
	m->m_data += sizeof(struct ieee80211_frame);

d1063 2
a1064 1
	if (ic->ic_flags & IEEE80211_F_RSN)
d1068 3
a1070 2
	if (ic->ic_flags & IEEE80211_F_WPA1)
		frm = ieee80211_add_wpa1(frm, ic, ic->ic_bss);
d1145 1
a1145 1
	m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
d1153 2
a1154 1
	    ((ic->ic_flags & IEEE80211_F_RSN) ? 2 + 44 : 0) +
d1156 2
a1157 1
	    ((ic->ic_flags & IEEE80211_F_WPA1) ? 2 + 48 : 0));
a1160 2
	m->m_data += sizeof(struct ieee80211_frame);

d1173 1
a1173 1
	if (reassoc == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {
d1181 3
a1183 2
	if (ic->ic_flags & IEEE80211_F_RSN)
		frm = ieee80211_add_rsn(frm, ic, ic->ic_bss);
d1187 3
a1189 2
	if (ic->ic_flags & IEEE80211_F_WPA1)
		frm = ieee80211_add_wpa1(frm, ic, ic->ic_bss);
d1213 1
a1213 1
	m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
a1221 2
	m->m_data += sizeof(struct ieee80211_frame);

d1376 1
a1376 1
	m->m_pkthdr.len = m->m_len = sizeof (struct ieee80211_frame_rts);
d1402 1
a1402 1
	m->m_pkthdr.len = m->m_len = sizeof (struct ieee80211_frame_cts);
d1438 1
a1438 1
	m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
d1447 2
a1448 1
	    ((ic->ic_flags & IEEE80211_F_RSN) ? 2 + 44 : 0) +
d1450 2
a1451 1
	    ((ic->ic_flags & IEEE80211_F_WPA1) ? 2 + 48 : 0));
d1455 3
d1489 2
a1490 1
	if (ic->ic_flags & IEEE80211_F_RSN)
d1494 3
a1496 2
	if (ic->ic_flags & IEEE80211_F_WPA1)
		frm = ieee80211_add_wpa1(frm, ic, ni);
d1520 1
a1520 2
#define LE_WRITE_8(p, v) do {			\
	(p)[7] = (v) >> 56; (p)[6] = (v) >> 48;	\
d1526 38
d1566 1
a1566 1
    struct ieee80211_node *ni)
d1577 1
d1586 2
a1587 1
	key->desc = ni->ni_eapol_desc;
d1590 6
a1595 3
	/* use V2 descriptor iff pairwise cipher is CCMP */
	info |= (ni->ni_pairwise_cipher != IEEE80211_CIPHER_CCMP) ?
	    EAPOL_KEY_DESC_V1 : EAPOL_KEY_DESC_V2;
d1602 7
a1608 2
	if (info & EAPOL_KEY_ENCRYPTED)
		ieee80211_eapol_key_encrypt(ic, key, ni->ni_ptk.kek);
d1610 6
d1617 1
a1617 1
		ieee80211_eapol_key_mic(key, ni->ni_ptk.kck);
d1620 3
d1624 4
a1627 3
	if (error) {
		splx(s);
		return error;
a1628 3
	ifp->if_obytes += m->m_pkthdr.len;
	if ((ifp->if_flags & IFF_OACTIVE) == 0)
		(*ifp->if_start)(ifp);
d1631 1
a1631 1
	return 0;
d1638 2
a1639 1
ieee80211_add_gtk_kde(u_int8_t *frm, const struct ieee80211_key *k)
d1648 5
a1652 1
	if (k->k_flags & IEEE80211_KEY_TX)
d1679 2
a1680 1
	pktlen += sizeof(struct ether_header) +
d1686 3
a1688 1
	if (m != NULL && pktlen > MHLEN) {
d1691 1
a1691 1
			m = m_free(m);
d1693 1
a1693 1
	m->m_data += sizeof(struct ether_header);
a1706 1
	u_int8_t *pmkid;
d1710 6
a1715 3
	if (++ni->ni_rsn_tocnt == 3)
		return 0;	/* XXX move to RSNA_DISCONNECT */

d1717 1
a1717 1
	    (ni->ni_eapol_desc == EAPOL_KEY_DESC_IEEE80211) ? 2 + 20 : 0);
d1729 1
a1729 1
	keylen = ieee80211_cipher_keylen(ni->ni_pairwise_cipher);
d1733 3
a1735 2
	/* WPA1 does not have PMKID KDE */
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_IEEE80211) {
d1737 1
a1737 1
		frm = ieee80211_add_pmkid_kde(frm, pmkid);
d1747 4
a1750 1
	return ieee80211_send_eapol_key(ic, m, ni);
d1759 1
a1759 1
    const u_int8_t *snonce)
d1776 2
a1777 2
	/* copy key replay counter from authenticator */
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);
d1780 1
a1780 1
	memcpy(key->nonce, snonce, EAPOL_KEY_NONCE_LEN);
d1784 1
a1784 1
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_WPA1) {
d1786 3
a1788 3
		frm = ieee80211_add_wpa1(frm, ic, ni);
		/* WPA1 sets the key length field here */
		keylen = ieee80211_cipher_keylen(ni->ni_pairwise_cipher);
d1800 1
a1800 1
	return ieee80211_send_eapol_key(ic, m, ni);
d1811 1
a1811 1
	struct ieee80211_key *gtk;
d1817 8
a1824 2
	if (++ni->ni_rsn_tocnt == 3)
		return 0;	/* XXX move to RSNA_KEYERROR */
d1828 2
a1829 2
	    ((ni->ni_eapol_desc == EAPOL_KEY_DESC_IEEE80211) ?
		2 + 6 + gtk->k_len : 0) +
d1836 3
a1838 2
	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_INSTALL | EAPOL_KEY_KEYACK |
	    EAPOL_KEY_KEYMIC;
a1839 1
	BE_WRITE_8(key->replaycnt, ni->ni_replaycnt);
d1843 4
a1846 1
	keylen = ieee80211_cipher_keylen(ni->ni_pairwise_cipher);
d1851 1
a1851 1
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_IEEE80211) {
d1853 3
a1855 3
		/* RSN: encapsulate the GTK and ask for encryption */
		frm = ieee80211_add_gtk_kde(frm, gtk);
		LE_WRITE_8(key->rsc, gtk->k_rsc);
d1857 2
a1858 2
	} else	/* WPA1 */
		frm = ieee80211_add_wpa1(frm, ic, ic->ic_bss);
d1870 1
a1870 1
	return ieee80211_send_eapol_key(ic, m, ni);
d1895 1
a1895 1
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_WPA1) {
d1897 2
a1898 2
		/* WPA1 sets the key length field here */
		keylen = ieee80211_cipher_keylen(ni->ni_pairwise_cipher);
d1914 1
a1914 1
	return ieee80211_send_eapol_key(ic, m, ni);
d1925 1
a1925 1
	struct ieee80211_key *gtk;
d1930 9
d1940 2
a1941 2
	    ((ni->ni_eapol_desc == EAPOL_KEY_DESC_WPA1) ?
		gtk->k_len : 2 + 6 + gtk->k_len) +
d1951 1
d1953 1
a1953 6
#if 0
	/* use global counter as GNonce */
	ieee80211_derive_gtk(ic->ic_gmk, IEEE80211_PMK_LEN, ic->ic_myaddr,
	    ic->ic_globalcnt, &gtk, sizeof gtk);
	/* XXX increment global counter */
#endif
d1955 7
a1961 7
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_WPA1) {
		/* WPA1 does not have GTK KDE */
		BE_WRITE_2(key->keylen, gtk->k_len);
		memcpy(frm, gtk->k_key, gtk->k_len);
		frm += gtk->k_len;
		info |= gtk->k_id << EAPOL_KEY_WPA_KID_SHIFT;
		if (gtk->k_flags & IEEE80211_KEY_TX)
d1964 1
a1964 1
		frm = ieee80211_add_gtk_kde(frm, gtk);
d1966 2
a1967 1
	LE_WRITE_8(key->rsc, gtk->k_rsc);
d1979 1
a1979 1
	return ieee80211_send_eapol_key(ic, m, ni);
d1988 1
a1988 1
    const struct ieee80211_key *gtk)
d2005 4
a2008 4
	if (ni->ni_eapol_desc == EAPOL_KEY_DESC_WPA1) {
		/* WPA1 sets the key length and key id fields here */
		BE_WRITE_2(key->keylen, gtk->k_len);
		info |= (gtk->k_id & 3) << EAPOL_KEY_WPA_KID_SHIFT;
d2022 1
a2022 1
	return ieee80211_send_eapol_key(ic, m, ni);
d2027 2
a2028 2
 * authenticator initiate either a 4-Way Handshake or Group Key Handshake
 * and to report a MIC failure in a TKIP MSDU.
d2043 1
d2048 1
a2048 1
		LE_WRITE_8(key->rsc, tsc);
d2051 2
a2052 2
	BE_WRITE_8(key->replaycnt, ic->ic_keyreplaycnt);
	ic->ic_keyreplaycnt++;
d2058 1
a2058 1
	return ieee80211_send_eapol_key(ic, m, ni);
@


1.57
log
@Checking the MIC early in ieee80211_recv_eapol() does not work for
message 2/4 of the 4-way handshake because the authenticator must
derive the PTK first (the MIC is computed using the KCK).
Move calls to ieee80211_eapol_key_check_mic() - and as a consequence
ieee80211_eapol_key_decrypt() - directly in the
ieee80211_recv_{group,4way}_msg*() functions.
Unconstify the first parameter since checking the MIC modifies the
frame. Remove ni->ni_ptk_ok field while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.56 2007/08/22 20:40:34 damien Exp $	*/
d1630 4
d1644 1
a1644 2
	/* generate a new nonce ANonce */
	get_random_bytes(ni->ni_nonce, EAPOL_KEY_NONCE_LEN);
d1729 4
@


1.56
log
@- add k_rxmic and k_txmic fields to struct ieee80211_key to store the
  Tx/Rx MIC for TKIP.
- add two functions to map a PTK and a GTK to an IEEE 802.11 key and
  use them in ieee80211_input.c instead of duplicating the same code.
  properly set Tx/Rx MIC in the IEEE 802.11 key in the case of TKIP.
- add ic_psk to struct ieee80211com to store the pre-shared key.
- fix setting of the SECURE bit in outgoing EAPOL-Key frames.
- when receiving msg 2 of the 4-way handshake, deauthenticate the
  station if the RSN IE does not match that of the (Re)Association
  request.
- before parsing an RSN or WPA IE, check that there's enough room for
  the version field (2 bytes) which is mandatory.
- various tweaks while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.55 2007/08/05 21:41:11 claudio Exp $	*/
a1540 3

	KASSERT((info & (EAPOL_KEY_ENCRYPTED | EAPOL_KEY_KEYMIC)) == 0 ||
	    ni->ni_ptk_ok);
@


1.55
log
@Fix the length calculation of the TIM bitmask in ieee80211_add_tim().
Even no bit was set we copied the full 225bytes bitmaks into the beacon.
Found the hard way with acx(4) by mglocker@@ and myself.
OK mglocker@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.54 2007/08/03 16:51:06 damien Exp $	*/
d1533 1
a1533 1
	/* use V2 descriptor only when pairwise cipher is CCMP */
d1741 1
a1741 1
	    EAPOL_KEY_KEYMIC | EAPOL_KEY_SECURE;
d1757 1
a1757 1
		info |= EAPOL_KEY_ENCRYPTED;
d1791 1
a1791 2
	info = EAPOL_KEY_PAIRWISE | EAPOL_KEY_KEYMIC | EAPOL_KEY_SECURE;
	BE_WRITE_2(key->info, info);
d1801 5
a1805 1
	}
d1844 6
a1849 1

@


1.54
log
@add a ni_eapol_desc field to struct ieee80211_node to know whether
a station is using WPA1 or RSN descriptors.
make sure that a station that advertises WPA1 capability in an IE
uses the WPA1 EAPOL-Key descriptor type and not the RSN one.
fix construction of EAPOL-Key frames for WPA1.
i can now successfuly complete a 4-way and group-key handshake
with both a WPA1 and a WPA2 access point.
add some TKIP encapsulation code (no SW crypto yet).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.53 2007/08/01 13:10:01 damien Exp $	*/
d704 1
a704 1
	for (i = ic->ic_tim_len - 1; i > 0 && ic->ic_tim_bitmap[i] != 0; i--);
@


1.53
log
@set key length field in message 1 & 3 of the 4-way handshake.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.52 2007/08/01 12:47:55 damien Exp $	*/
d1107 1
d1530 1
a1530 1
	key->desc = EAPOL_KEY_DESC_IEEE80211;	/* XXX WPA1 */
d1634 1
a1634 1
	    2 + 20);
a1646 2
	/* XXX retrieve PMKID from the PMKSA cache */

d1651 5
a1655 1
	frm = ieee80211_add_pmkid_kde(frm, pmkid);
d1681 1
a1681 1
	    2 + 44);
d1693 1
d1697 9
a1705 2
	/* add the RSN IE used in the (Re)Association Request */
	frm = ieee80211_add_rsn(frm, ic, ni);
d1731 3
a1733 2
	    2 + 44 +
	    2 + 6 + gtk->k_len +
a1739 1
	/* XXX no need to encrypt if GTK is not included */
d1741 1
a1741 2
	    EAPOL_KEY_KEYMIC | EAPOL_KEY_SECURE | EAPOL_KEY_ENCRYPTED;
	BE_WRITE_2(key->info, info);
d1744 1
a1744 1
	/* use same Nonce as Message 1 */
d1751 12
a1762 5
	/* add the RSN IE included in Beacon/Probe Response */
	frm = ieee80211_add_rsn(frm, ic, ni);
	/* XXX always include GTK? */
	frm = ieee80211_add_gtk_kde(frm, gtk);
	LE_WRITE_8(key->rsc, gtk->k_rsc);
d1785 1
a1785 1
	m = ieee80211_get_eapol_key(M_DONTWAIT, MT_DATA, 8);
d1797 7
d1829 2
a1830 1
	    2 + 6 + gtk->k_len +
a1838 1
	BE_WRITE_2(key->info, info);
d1843 11
a1853 1
	frm = ieee80211_add_gtk_kde(frm, gtk);
d1856 3
d1874 2
a1875 1
ieee80211_send_group_msg2(struct ieee80211com *ic, struct ieee80211_node *ni)
a1887 1
	BE_WRITE_2(key->info, info);
d1892 9
d1919 1
a1919 1
    struct ieee80211_node *ni, int is4way)
a1922 1
	u_int16_t info;
a1929 1
	info = is4way ? EAPOL_KEY_PAIRWISE : 0;
d1931 4
@


1.52
log
@pass the supplicant's nonce generated on reception of message 1 of the
4-way handshake to ieee80211_send_4way_msg2().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.51 2007/08/01 12:26:16 damien Exp $	*/
d1628 1
a1628 1
	u_int16_t info;
d1648 3
d1716 1
a1716 1
	u_int16_t info;
d1736 3
@


1.51
log
@fix parsing and construction of RSN/WPA IEs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.50 2007/08/01 12:15:48 damien Exp $	*/
d1666 2
a1667 1
ieee80211_send_4way_msg2(struct ieee80211com *ic, struct ieee80211_node *ni)
d1687 1
a1687 1
	/* XXX memcpy(key->nonce, snonce, EAPOL_KEY_NONCE_LEN); */
@


1.50
log
@the EAPOL-Key MIC must be computed with the MIC bit set.
this simplifies ieee80211_eapol_key_mic() and ieee80211_eapol_key_check_mic()
quite a bit.
set the EAPOL-Key body length before computing the MIC since the MIC is
computed with the 802.1X header too.
add a missing htons() while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.49 2007/08/01 11:59:40 damien Exp $	*/
d903 1
a903 1
	*plen = frm - plen + 1;
d924 1
a924 1
	*plen = frm - plen + 1;
@


1.49
log
@cipher suite type for CCMP is 4 not 3.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.48 2007/07/28 11:24:06 damien Exp $	*/
d1522 1
a1522 1
	eh->ether_type = ETHERTYPE_PAE;
d1536 4
a1539 1
	BE_WRITE_2(key->paylen, m->m_len - sizeof(*key));
d1544 1
a1544 3
	if (info & EAPOL_KEY_ENCRYPTED) {
		info &= ~EAPOL_KEY_ENCRYPTED;
		BE_WRITE_2(key->info, info);
a1545 1
	}
d1547 1
a1547 3
	if (info & EAPOL_KEY_KEYMIC) {
		info &= ~EAPOL_KEY_KEYMIC;
		BE_WRITE_2(key->info, info);
a1548 5
	}

	/* write packet body length field */
	len = BE_READ_2(key->paylen);
	BE_WRITE_2(key->len, sizeof(*key) + len);
@


1.48
log
@adds functions to parse and to build EAPOL-Key frames used in
the 4-way and group-key handshake.
the state machine is still missing though so this is not used
anywhere yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.47 2007/07/14 19:58:05 damien Exp $	*/
d840 1
a840 1
		*frm++ = 3;
d862 1
a862 1
		*frm++ = 3;
@


1.47
log
@update QoS Tx/Rx sequence numbers for each TID.
add a parameter to ieee80211_decap() to handle different 802.11
header sizes.
cleanup and clarify ieee80211_classify().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.46 2007/07/13 19:59:56 damien Exp $	*/
d68 2
d91 5
d510 8
d521 3
a523 1
	    (ni->ni_flags & IEEE80211_NODE_QOS)) {
d1351 1
a1351 1
 * Build a RTS (Request To Send) control frame.
d1378 1
a1378 1
 * Build a CTS-to-self (Clear To Send) control frame.
d1483 414
@


1.46
log
@do not increment ic_stats.is_tx_nombuf in ieee80211_get_rts() and
ieee80211_get_cts_to_self() if mbuf allocation fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.45 2007/07/06 19:00:56 damien Exp $	*/
d69 1
a69 1
struct	mbuf *ieee80211_classify(struct ieee80211com *, struct mbuf *, int *);
d373 1
a373 1
 * based on the IP TOS precedence field.
d375 2
a376 2
struct mbuf *
ieee80211_classify(struct ieee80211com *ic, struct mbuf *m, int *up)
d386 2
a387 4
		if (ifv->ifv_prio <= 7) {
			*up = ifv->ifv_prio;
			return m;
		}
d393 1
a393 9
		const struct ip *ip;

		if (m->m_len < sizeof(*eh) + sizeof(*ip)) {
			m = m_pullup(m, sizeof(*eh) + sizeof(*ip));
			if (m == NULL)
				return NULL;
		}
		ip = (struct ip *)(mtod(m, struct ether_header *) + 1);

d395 2
a396 1
		 * IP packet, map TOS precedence field.
d400 1
a400 2
			*up = 2;
			break;
d402 1
a402 2
			*up = 1;
			break;
d404 1
a404 2
			*up = 3;
			break;
d406 1
a406 2
			*up = 4;
			break;
d408 1
a408 2
			*up = 5;
			break;
d410 1
a410 2
			*up = 6;
			break;
d412 1
a412 4
			*up = 7;
			break;
		default:
			*up = 0;
a413 1
		return m;
d416 1
a416 2
	*up = 0;	/* default to Best-Effort */
	return m;
d438 2
a439 1
	u_int dlt;
d505 9
d522 1
a522 1
	M_PREPEND(m, sizeof(struct ieee80211_frame), M_DONTWAIT);
d530 14
a543 3
	*(u_int16_t *)&wh->i_seq[0] =
	    htole16(ni->ni_txseq << IEEE80211_SEQ_SEQ_SHIFT);
	ni->ni_txseq++;
@


1.45
log
@cleanup the computation of mgmt frames sizes.
still very ugly but hopefully correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.44 2007/07/06 18:18:43 damien Exp $	*/
d1004 1
a1004 1
	    2 + ni->ni_esslen +		/* ssid */
d1050 3
a1052 3
 * [2]    Authentication algorithm number
 * [2]    Authentication transaction sequence number
 * [2]    Status code
d1343 1
a1343 2
	if (m == NULL) {
		ic->ic_stats.is_tx_nombuf++;
d1345 1
a1345 1
	}
d1369 1
a1369 2
	if (m == NULL) {
		ic->ic_stats.is_tx_nombuf++;
d1371 1
a1371 1
	}
@


1.44
log
@remove remaining bits for pre-RSNA shared authmode support.
it has been #if 0'd since 3.9 and we have never supported this mode (no
ifconfig option etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.43 2007/07/05 21:35:45 damien Exp $	*/
d955 2
a958 1
	struct ieee80211_rateset *rs;
d962 3
a964 2
	    2 + IEEE80211_RATE_SIZE +
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
a971 1
	rs = &ic->ic_sup_rates[ieee80211_chan2mode(ic, ni->ni_chan)];
d998 1
a1000 1
	struct ieee80211_rateset *rs;
d1003 1
a1003 3
	    8 +				/* time stamp */
	    2 +				/* beacon interval */
	    2 +				/* cabability information */
d1005 9
a1013 8
	    2 + IEEE80211_RATE_SIZE +	/* supported rates */
	    7 +				/* parameter set (FH/DS) */
	    6 +				/* parameter set (IBSS) */
	    2 + 1 +			/* extended rate phy (ERP) */
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
	    2 + 44 +			/* RSN (XXX 44) */
	    2 +	18 +			/* parameter set (EDCA) */
	    2 + 48);			/* WPA (XXX 48) */
d1020 1
a1020 2
	memset(frm, 0, 8);	/* timestamp is set by hardware */
	frm += 8;
a1022 1

a1024 1
	rs = &ic->ic_bss->ni_rates;
a1025 1

a1029 1

d1110 1
a1113 1
	struct ieee80211_rateset *rs;
d1116 10
a1125 9
	    2 +				/* capability information */
	    2 +				/* listen interval */
	    IEEE80211_ADDR_LEN +	/* current AP address */
	    2 + ni->ni_esslen +		/* ssid */
	    2 + IEEE80211_RATE_SIZE +	/* supported rates */
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
	    2 + 44 +			/* RSN (XXX 44) */
	    2 + 1 +			/* QoS capability */
	    2 + 48);			/* WPA (XXX 48) */
a1134 4
	/*
	 * NB: Some 11a AP's reject the request when
	 *     short preamble is set.
	 */
a1141 1

a1142 1

a1147 1
	rs = &ni->ni_rates;
d1177 1
a1179 1
	struct ieee80211_rateset *rs;
d1182 5
a1186 6
	    2 +				/* capability information */
	    2 +				/* status */
	    2 +				/* association ID */
	    2 + IEEE80211_RATE_SIZE +	/* supported rates */
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
	    2 + 18);			/* parameter set (EDCA) */
a1194 1

a1199 2

	rs = &ni->ni_rates;
a1400 1
 * [tlv]  QoS Capability (802.11e)
d1405 1
a1408 1
	struct ieee80211_rateset *rs;
d1411 11
a1421 12
	    8 +				/* time stamp */
	    2 +				/* beacon interval */
	    2 +				/* cabability information */
	    2 + ni->ni_esslen +		/* ssid */
	    2 + IEEE80211_RATE_SIZE +	/* supported rates */
	    2 + 1 +			/* parameter set (DS) */
	    2 + 254 +			/* parameter set (IBSS/TIM) */
	    2 + 1 +			/* extended rate phy (ERP) */
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
	    2 + 44 +			/* RSN (XXX 44) */
	    2 + 18 +			/* parameter set (EDCA) */
	    2 + 48);			/* WPA (XXX 48) */
d1436 1
a1436 2
	memset(frm, 0, 8);	/* timestamp is set by hardware */
	frm += 8;
a1438 1

a1442 2

	rs = &ni->ni_rates;
a1443 1

a1447 1

a1451 1

@


1.43
log
@always set the IEEE80211_CAPINFO_ESS bit in association requests.
fixes my 1.36 commit (the bit should not be set for non-AP STA
only in Probe Responses and Beacons).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.42 2007/07/05 20:29:22 damien Exp $	*/
a194 7
	if ((m->m_flags & M_LINK0) != 0 && ni->ni_challenge != NULL) {
		m->m_flags &= ~M_LINK0;
		IEEE80211_DPRINTF(("%s: encrypting frame for %s\n", __func__,
		    ether_sprintf(wh->i_addr1)));
		wh->i_fc[1] |= IEEE80211_FC1_WEP;
	}

a747 12
 * Add a Challenge Text element to a frame (see 7.3.2.8).
 */
u_int8_t *
ieee80211_add_challenge(u_int8_t *frm, const u_int8_t *challenge, u_int len)
{
	*frm++ = IEEE80211_ELEMID_CHALLENGE;
	*frm++ = len;
	memcpy(frm, challenge, len);
	return frm + len;
}

/*
a1057 1
 * [tlv*] Challenge text
a1064 1
	int has_challenge, is_shared_key;
d1069 2
a1070 16

	has_challenge = (seq == IEEE80211_AUTH_SHARED_CHALLENGE ||
	    seq == IEEE80211_AUTH_SHARED_RESPONSE) &&
	    ni->ni_challenge != NULL;

	is_shared_key = has_challenge || (ni->ni_challenge != NULL &&
	    seq == IEEE80211_AUTH_SHARED_PASS);

	if (has_challenge && status == IEEE80211_STATUS_SUCCESS) {
		MH_ALIGN(m, 2 * 3 + 2 + IEEE80211_CHALLENGE_LEN);
		m->m_pkthdr.len = m->m_len =
		    2 * 3 + 2 + IEEE80211_CHALLENGE_LEN;
	} else {
		MH_ALIGN(m, 2 * 3);
		m->m_pkthdr.len = m->m_len = 2 * 3;
	}
d1073 1
a1073 5
	if (is_shared_key)
		LE_WRITE_2(frm, IEEE80211_AUTH_ALG_SHARED);
	else
		LE_WRITE_2(frm, IEEE80211_AUTH_ALG_OPEN);
	frm += 2;
d1075 1
a1075 1
	LE_WRITE_2(frm, status); frm += 2;
a1076 9
	if (has_challenge && status == IEEE80211_STATUS_SUCCESS) {
		frm = ieee80211_add_challenge(frm,
		    (u_int8_t *)ni->ni_challenge, IEEE80211_CHALLENGE_LEN);
		if (seq == IEEE80211_AUTH_SHARED_RESPONSE) {
			IEEE80211_DPRINTF((
			    "%s: request encrypt frame\n", __func__));
			m->m_flags |= M_LINK0; /* WEP-encrypt, please */
		}
	}
@


1.42
log
@move the logic of determining whether an extended supported rates IE is
needed or not to the callers (instead of doing nothing in add_xrates).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.41 2007/07/05 20:19:21 damien Exp $	*/
d1184 1
a1184 6
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		capinfo = IEEE80211_CAPINFO_ESS;
	else
		capinfo = 0;
@


1.41
log
@split ieee80211_add_rsn() so that the code can be reused for
vendor-specific IE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.40 2007/07/04 20:18:00 damien Exp $	*/
d935 9
a943 8
	if (rs->rs_nrates > IEEE80211_RATE_SIZE) {
		int nrates = rs->rs_nrates - IEEE80211_RATE_SIZE;
		*frm++ = IEEE80211_ELEMID_XRATES;
		*frm++ = nrates;
		memcpy(frm, rs->rs_rates + IEEE80211_RATE_SIZE, nrates);
		frm += nrates;
	}
	return frm;
d976 1
a976 1
	enum ieee80211_phymode mode;
d989 4
a992 3
	mode = ieee80211_chan2mode(ic, ni->ni_chan);
	frm = ieee80211_add_rates(frm, &ic->ic_sup_rates[mode]);
	frm = ieee80211_add_xrates(frm, &ic->ic_sup_rates[mode]);
d1018 1
d1046 2
a1047 1
	frm = ieee80211_add_rates(frm, &ic->ic_bss->ni_rates);
d1058 2
a1059 1
	frm = ieee80211_add_xrates(frm, &ic->ic_bss->ni_rates);
d1166 1
d1211 4
a1214 2
	frm = ieee80211_add_rates(frm, &ni->ni_rates);
	frm = ieee80211_add_xrates(frm, &ni->ni_rates);
d1243 1
d1267 4
a1270 2
	frm = ieee80211_add_rates(frm, &ni->ni_rates);
	frm = ieee80211_add_xrates(frm, &ni->ni_rates);
d1531 2
a1532 1
	frm = ieee80211_add_xrates(frm, rs);
@


1.40
log
@allow USEGROUP as the pairwise cipher for RSN IE.
add RSN IE to beacons, probe responses and (re)association requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.39 2007/07/03 20:25:32 damien Exp $	*/
d72 2
d817 2
a818 2
ieee80211_add_rsn(u_int8_t *frm, struct ieee80211com *ic,
    const struct ieee80211_node *ni)
d820 2
a821 1
	u_int8_t *plen, *pcount;
a823 3
	*frm++ = IEEE80211_ELEMID_RSN;
	plen = frm++;	/* length filled in later */

d828 1
a828 1
	memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d852 1
a852 1
		memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d857 1
a857 1
		memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d862 1
a862 1
		memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d873 1
a873 1
		memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d878 1
a878 1
		memcpy(frm, IEEE80211_OUI, 3); frm += 3;
d890 34
d1028 2
a1029 1
	    2 +	18);			/* parameter set (EDCA) */
d1059 2
d1170 2
a1171 1
	    2 + 1);			/* QoS capability */
d1212 2
d1479 2
a1480 1
	    2 + 18);			/* parameter set (EDCA) */
d1525 2
@


1.39
log
@maintain the traffic-indication (TIM) virtual bitmap by defining
a default ieee80211_set_tim() function that drivers can override
by setting ic_set_tim.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.38 2007/07/03 19:44:54 damien Exp $	*/
d830 4
a845 4
	case IEEE80211_CIPHER_USEGROUP:
		/* can't get there */
		panic("invalid group cipher!");
		break;
d851 5
d993 1
d1020 2
d1132 1
d1169 2
d1438 1
d1480 2
@


1.38
log
@add a function that builds an RSN IE (ieee80211_add_rsn).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.37 2007/07/03 16:43:41 damien Exp $	*/
d1424 1
a1424 1
	    6 +				/* parameter set (IBSS/TIM) */
d1460 1
a1460 1
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
d1462 3
a1464 9
	} else {
		/* TODO: TIM */
		*frm++ = IEEE80211_ELEMID_TIM;
		*frm++ = 4;	/* length */
		*frm++ = 0;	/* DTIM count */ 
		*frm++ = 1;	/* DTIM period */
		*frm++ = 0;	/* bitmap control */
		*frm++ = 0;	/* Partial Virtual Bitmap (variable length) */
	}
d1481 3
a1483 1
	/* Store the new packet on our queue, changing the TIM if necessary */
a1484 3
	if (IF_IS_EMPTY(&ni->ni_savedq)) {
		ic->ic_set_tim(ic, ni->ni_associd, 1);
	}
d1496 2
a1497 1
		/* Similar to ieee80211_mgmt_output, store the node in
@


1.37
log
@move construction of IEs into individual functions so that we don't
duplicate the same code multiple times.
add references to the spec for all these functions.
fixes beacon_alloc() for FH PHYs as a side-effect.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.36 2007/07/03 16:10:38 damien Exp $	*/
d808 79
@


1.36
log
@don't set the IEEE80211_CAPINFO_ESS bit in the Capability Information
field if we're not operating as an AP (see 7.3.1.4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.35 2007/07/03 16:07:10 damien Exp $	*/
d584 33
d618 13
a630 1
 * Add a supported rates element to a frame.
d645 1
a645 1
 * Add an extended supported rates element to a frame.
d648 2
a649 1
ieee80211_add_xrates(u_int8_t *frm, const struct ieee80211_rateset *rs)
d651 8
a658 7
	if (rs->rs_nrates > IEEE80211_RATE_SIZE) {
		int nrates = rs->rs_nrates - IEEE80211_RATE_SIZE;
		*frm++ = IEEE80211_ELEMID_XRATES;
		*frm++ = nrates;
		memcpy(frm, rs->rs_rates + IEEE80211_RATE_SIZE, nrates);
		frm += nrates;
	}
d663 1
a663 1
 * Add an SSID element to a frame.
d666 2
a667 1
ieee80211_add_ssid(u_int8_t *frm, const u_int8_t *ssid, u_int len)
d669 1
a669 15
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = len;
	memcpy(frm, ssid, len);
	return frm + len;
}

/*
 * Add an ERP element to a frame.
 */
u_int8_t *
ieee80211_add_erp(u_int8_t *frm, struct ieee80211com *ic)
{
	u_int8_t erp;

	*frm++ = IEEE80211_ELEMID_ERP;
d671 1
a671 22
	erp = 0;
	/*
	 * The NonERP_Present bit shall be set to 1 when a NonERP STA
	 * is associated with the BSS.
	 */
	if (ic->ic_nonerpsta != 0)
		erp |= IEEE80211_ERP_NON_ERP_PRESENT;
	/*
	 * If one or more NonERP STAs are associated in the BSS, the
	 * Use_Protection bit shall be set to 1 in transmitted ERP
	 * Information Elements.
	 */
	if (ic->ic_flags & IEEE80211_F_USEPROT)
		erp |= IEEE80211_ERP_USE_PROTECTION;
	/*
	 * The Barker_Preamble_Mode bit shall be set to 1 by the ERP
	 * Information Element sender if one or more associated NonERP
	 * STAs are not short preamble capable.
	 */
	if (!(ic->ic_flags & IEEE80211_F_SHPREAMBLE))
		erp |= IEEE80211_ERP_BARKER_MODE;
	*frm++ = erp;
d676 1
a676 1
 * Add a TIM element to a frame (see Annex L).
d713 1
a713 1
 * Add a QoS Capability element to a frame.
d716 1
a716 1
ieee80211_add_qos_capability(u_int8_t *frm, struct ieee80211com *ic)
d718 4
a721 5
	*frm++ = IEEE80211_ELEMID_QOS_CAP;
	*frm++ = 1;
	*frm++ = 0;	/* QoS Info */

	return frm;
d725 1
a725 1
 * Add an EDCA Parameter Set element to a frame.
d747 76
a822 2
		*frm++ = ac->ac_txoplimit & 0xff;
		*frm++ = ac->ac_txoplimit >> 8;
d880 1
a880 1
 * Beacon/Probe response frame format:
a887 1
 * [tlv]  Country
a891 1
 * [tlv]  QoS Capability (Beacon only, 802.11e)
a897 1
	u_int16_t capinfo;
d916 1
a916 1
	memset(frm, 0, 8);	/* timestamp should be filled later */
d918 2
a919 17
	*(u_int16_t *)frm = htole16(ic->ic_bss->ni_intval);
	frm += 2;
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		capinfo = IEEE80211_CAPINFO_ESS;
	else
		capinfo = 0;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	*(u_int16_t *)frm = htole16(capinfo);
	frm += 2;
d925 4
a928 15
	if (ic->ic_phytype == IEEE80211_T_FH) {
		*frm++ = IEEE80211_ELEMID_FHPARMS;
		*frm++ = 5;
		*frm++ = ni->ni_fhdwell & 0x00ff;
		*frm++ = (ni->ni_fhdwell >> 8) & 0x00ff;
		*frm++ = IEEE80211_FH_CHANSET(
		    ieee80211_chan2ieee(ic, ni->ni_chan));
		*frm++ = IEEE80211_FH_CHANPAT(
		    ieee80211_chan2ieee(ic, ni->ni_chan));
		*frm++ = ni->ni_fhindex;
	} else {
		*frm++ = IEEE80211_ELEMID_DSPARMS;
		*frm++ = 1;
		*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
	}
d930 2
a931 5
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */
	}
d979 7
a985 5
	((u_int16_t *)frm)[0] =
	    (is_shared_key) ? htole16(IEEE80211_AUTH_ALG_SHARED) :
	    htole16(IEEE80211_AUTH_ALG_OPEN);
	((u_int16_t *)frm)[1] = htole16(seq);	/* sequence number */
	((u_int16_t *)frm)[2] = htole16(status);/* status */
d988 2
a989 5
		((u_int16_t *)frm)[3] =
		    htole16((IEEE80211_CHALLENGE_LEN << 8) |
		    IEEE80211_ELEMID_CHALLENGE);
		memcpy(&((u_int16_t *)frm)[4], ni->ni_challenge,
		    IEEE80211_CHALLENGE_LEN);
d1070 1
a1070 2
	*(u_int16_t *)frm = htole16(capinfo);
	frm += 2;
d1072 1
a1072 2
	*(u_int16_t *)frm = htole16(ic->ic_lintval);
	frm += 2;
a1077 1

a1104 1
	u_int16_t capinfo;
d1119 2
a1120 13
	capinfo = IEEE80211_CAPINFO_ESS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	*(u_int16_t *)frm = htole16(capinfo);
	frm += 2;

	*(u_int16_t *)frm = htole16(status);
	frm += 2;
d1123 3
a1125 1
		*(u_int16_t *)frm = htole16(ni->ni_associd);
d1313 17
a1335 1
	u_int16_t capinfo;
a1337 13
	/*
	 * beacon frame format
	 *	[8] time stamp
	 *	[2] beacon interval
	 *	[2] cabability information
	 *	[tlv] ssid
	 *	[tlv] supported rates
	 *	[3] parameter set (DS)
	 *	[tlv] parameter set (IBSS/TIM)
	 *	[tlv] extended rate phy (ERP)
	 *	[tlv] extended supported rates
	 *	[tlv] parameter set (EDCA)
	 */
d1363 1
a1363 1
	bzero(frm, 8);	/* timestamp is set by hardware */
d1365 3
a1367 17
	*(u_int16_t *)frm = htole16(ni->ni_intval);
	frm += 2;
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		capinfo = IEEE80211_CAPINFO_IBSS;
	else if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		capinfo = IEEE80211_CAPINFO_ESS;
	else
		capinfo = 0;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
	*(u_int16_t *)frm = htole16(capinfo);
	frm += 2;
d1372 1
d1375 6
a1380 3
	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
d1382 1
a1382 3
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
		*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */
d1397 1
@


1.35
log
@no TIM in probe reponses.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.34 2007/07/03 16:03:48 damien Exp $	*/
d839 2
d842 1
a842 1
		capinfo = IEEE80211_CAPINFO_ESS;
a998 1
	capinfo = 0;
d1000 5
a1004 3
		capinfo |= IEEE80211_CAPINFO_IBSS;
	else		/* IEEE80211_M_STA */
		capinfo |= IEEE80211_CAPINFO_ESS;
d1324 1
a1324 1
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
d1326 1
a1326 1
	} else {
d1328 2
a1329 1
	}
@


1.34
log
@In ieee80211_getmbuf(), if we need to allocate a mbuf cluster because
the length is greater than MHLEN, test that the allocation succeeded.
Otherwise, free the mbuf header and return NULL.
Callers assume that if the function returns a value != NULL then
enough space has been allocated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.33 2007/07/03 16:00:07 damien Exp $	*/
a874 8
	} else {	/* IEEE80211_M_HOSTAP */
		/* TODO: TIM */
		*frm++ = IEEE80211_ELEMID_TIM;
		*frm++ = 4;	/* length */
		*frm++ = 0;	/* DTIM count */
		*frm++ = 1;	/* DTIM period */
		*frm++ = 0;	/* bitmap control */
		*frm++ = 0;	/* Partial Virtual Bitmap (variable) */
@


1.33
log
@fix SSID IE in the case where HIDENWID is used.
HIDENWID has been broken from the very beginning.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.32 2007/07/02 16:46:44 damien Exp $	*/
d752 1
a752 1
	if (m != NULL && pktlen > MHLEN)
d754 3
@


1.32
log
@initial bits for proper TIM support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.31 2007/07/02 16:19:49 damien Exp $	*/
d1341 1
a1341 1
		*frm++ = 0;
@


1.31
log
@split ieee80211_send_mgmt() like I did for ieee80211_recv_mgmt()
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.30 2007/06/21 21:06:12 damien Exp $	*/
d660 37
@


1.30
log
@add EDCA Parameter Set and QoS capability IEs to appropriate frames
when QoS is supported and activated.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.29 2007/06/21 20:38:55 damien Exp $	*/
d73 15
d585 1
a585 1
 * Add a supported rates element id to a frame.
d593 1
a593 3
	nrates = rs->rs_nrates;
	if (nrates > IEEE80211_RATE_SIZE)
		nrates = IEEE80211_RATE_SIZE;
d600 1
a600 1
 * Add an extended supported rates element id to a frame.
a604 3
	/*
	 * Add an extended supported rates element if operating in 11g mode.
	 */
d616 1
a616 1
 * Add an ssid element to a frame.
d720 365
d1092 1
a1092 1
	int type, int arg)
d1097 1
a1097 4
	u_int8_t *frm;
	enum ieee80211_phymode mode;
	u_int16_t capinfo;
	int has_challenge, is_shared_key, ret, timer, status;
d1111 1
a1111 11
		/*
		 * probe request frame format
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 */
		m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
		    2 + ic->ic_des_esslen +
		    2 + IEEE80211_RATE_SIZE +
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
		if (m == NULL)
a1112 8
		m->m_data += sizeof(struct ieee80211_frame);
		frm = mtod(m, u_int8_t *);
		frm = ieee80211_add_ssid(frm, ic->ic_des_essid,
		    ic->ic_des_esslen);
		mode = ieee80211_chan2mode(ic, ni->ni_chan);
		frm = ieee80211_add_rates(frm, &ic->ic_sup_rates[mode]);
		frm = ieee80211_add_xrates(frm, &ic->ic_sup_rates[mode]);
		m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
d1118 1
a1118 25
		/*
		 * probe response frame format
		 *	[8] time stamp
		 *	[2] beacon interval
		 *	[2] cabability information
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] parameter set (FH/DS)
		 *	[tlv] parameter set (IBSS)
		 *	[tlv] extended rate phy (ERP)
		 *	[tlv] extended supported rates
		 *	[tlv] parameter set (EDCA)
		 */
		m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
		    8 +				/* time stamp */
		    2 +				/* beacon interval */
		    2 +				/* cabability information */
		    2 + ni->ni_esslen +		/* ssid */
		    2 + IEEE80211_RATE_SIZE +	/* supported rates */
		    7 +				/* parameter set (FH/DS) */
		    6 +				/* parameter set (IBSS) */
		    2 + 1 +			/* extended rate phy (ERP) */
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
		    2 +	18);			/* parameter set (EDCA) */
		if (m == NULL)
a1119 60
		m->m_data += sizeof(struct ieee80211_frame);
		frm = mtod(m, u_int8_t *);

		memset(frm, 0, 8);	/* timestamp should be filled later */
		frm += 8;
		*(u_int16_t *)frm = htole16(ic->ic_bss->ni_intval);
		frm += 2;
		if (ic->ic_opmode == IEEE80211_M_IBSS)
			capinfo = IEEE80211_CAPINFO_IBSS;
		else
			capinfo = IEEE80211_CAPINFO_ESS;
		if (ic->ic_flags & IEEE80211_F_WEPON)
			capinfo |= IEEE80211_CAPINFO_PRIVACY;
		if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
		    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
			capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
		if (ic->ic_flags & IEEE80211_F_SHSLOT)
			capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
		*(u_int16_t *)frm = htole16(capinfo);
		frm += 2;

		frm = ieee80211_add_ssid(frm, ic->ic_bss->ni_essid,
				ic->ic_bss->ni_esslen);
		frm = ieee80211_add_rates(frm, &ic->ic_bss->ni_rates);

		if (ic->ic_phytype == IEEE80211_T_FH) {
			*frm++ = IEEE80211_ELEMID_FHPARMS;
			*frm++ = 5;
			*frm++ = ni->ni_fhdwell & 0x00ff;
			*frm++ = (ni->ni_fhdwell >> 8) & 0x00ff;
			*frm++ = IEEE80211_FH_CHANSET(
			    ieee80211_chan2ieee(ic, ni->ni_chan));
			*frm++ = IEEE80211_FH_CHANPAT(
			    ieee80211_chan2ieee(ic, ni->ni_chan));
			*frm++ = ni->ni_fhindex;
		} else {
			*frm++ = IEEE80211_ELEMID_DSPARMS;
			*frm++ = 1;
			*frm++ = ieee80211_chan2ieee(ic, ni->ni_chan);
		}

		if (ic->ic_opmode == IEEE80211_M_IBSS) {
			*frm++ = IEEE80211_ELEMID_IBSSPARMS;
			*frm++ = 2;
			*frm++ = 0; *frm++ = 0;		/* TODO: ATIM window */
		} else {	/* IEEE80211_M_HOSTAP */
			/* TODO: TIM */
			*frm++ = IEEE80211_ELEMID_TIM;
			*frm++ = 4;	/* length */
			*frm++ = 0;	/* DTIM count */
			*frm++ = 1;	/* DTIM period */
			*frm++ = 0;	/* bitmap control */
			*frm++ = 0;	/* Partial Virtual Bitmap (variable) */
		}
		if (ic->ic_curmode == IEEE80211_MODE_11G)
			frm = ieee80211_add_erp(frm, ic);
		frm = ieee80211_add_xrates(frm, &ic->ic_bss->ni_rates);
		if (ic->ic_flags & IEEE80211_F_QOS)
			frm = ieee80211_add_edca_params(frm, ic);
		m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
d1123 1
a1123 1
		MGETHDR(m, M_DONTWAIT, MT_DATA);
a1126 36
		status = arg >> 16;
		arg &= 0xffff;
		has_challenge = ((arg == IEEE80211_AUTH_SHARED_CHALLENGE ||
		    arg == IEEE80211_AUTH_SHARED_RESPONSE) &&
		    ni->ni_challenge != NULL);

		is_shared_key = has_challenge || (ni->ni_challenge != NULL &&
		    arg == IEEE80211_AUTH_SHARED_PASS);

		if (has_challenge && status == IEEE80211_STATUS_SUCCESS) {
			MH_ALIGN(m, 2 * 3 + 2 + IEEE80211_CHALLENGE_LEN);
			m->m_pkthdr.len = m->m_len =
			    2 * 3 + 2 + IEEE80211_CHALLENGE_LEN;
		} else {
			MH_ALIGN(m, 2 * 3);
			m->m_pkthdr.len = m->m_len = 2 * 3;
		}
		frm = mtod(m, u_int8_t *);
		((u_int16_t *)frm)[0] =
		    (is_shared_key) ? htole16(IEEE80211_AUTH_ALG_SHARED) :
		    htole16(IEEE80211_AUTH_ALG_OPEN);
		((u_int16_t *)frm)[1] = htole16(arg);	/* sequence number */
		((u_int16_t *)frm)[2] = htole16(status);/* status */

		if (has_challenge && status == IEEE80211_STATUS_SUCCESS) {
			((u_int16_t *)frm)[3] =
			    htole16((IEEE80211_CHALLENGE_LEN << 8) |
			    IEEE80211_ELEMID_CHALLENGE);
			memcpy(&((u_int16_t *)frm)[4], ni->ni_challenge,
			    IEEE80211_CHALLENGE_LEN);
			if (arg == IEEE80211_AUTH_SHARED_RESPONSE) {
				IEEE80211_DPRINTF((
				    "%s: request encrypt frame\n", __func__));
				m->m_flags |= M_LINK0; /* WEP-encrypt, please */
			}
		}
d1132 4
a1135 1
		if (ifp->if_flags & IFF_DEBUG)
d1138 1
a1138 6
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			senderr(ENOMEM, is_tx_nombuf);
		MH_ALIGN(m, 2);
		m->m_pkthdr.len = m->m_len = 2;
		*mtod(m, u_int16_t *) = htole16(arg);	/* reason */
d1143 1
a1143 19
		/*
		 * association request frame format
		 *	[2] capability information
		 *	[2] listen interval
		 *	[6*] current AP address (reassoc only)
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 *	[tlv] QoS Capability (802.11e)
		 */
		m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
		    2 +				/* capability information */
		    2 +				/* listen interval */
		    IEEE80211_ADDR_LEN +	/* current AP address */
		    2 + ni->ni_esslen +		/* ssid */
		    2 + IEEE80211_RATE_SIZE +	/* supported rates */
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
		    2 + 1);			/* QoS capability */
		if (m == NULL)
a1144 38
		m->m_data += sizeof(struct ieee80211_frame);
		frm = mtod(m, u_int8_t *);

		capinfo = 0;
		if (ic->ic_opmode == IEEE80211_M_IBSS)
			capinfo |= IEEE80211_CAPINFO_IBSS;
		else		/* IEEE80211_M_STA */
			capinfo |= IEEE80211_CAPINFO_ESS;
		if (ic->ic_flags & IEEE80211_F_WEPON)
			capinfo |= IEEE80211_CAPINFO_PRIVACY;
		/*
		 * NB: Some 11a AP's reject the request when
		 *     short preamble is set.
		 */
		if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
		    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
			capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
		if ((ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME) &&
		    (ic->ic_flags & IEEE80211_F_SHSLOT))
			capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
		*(u_int16_t *)frm = htole16(capinfo);
		frm += 2;

		*(u_int16_t *)frm = htole16(ic->ic_lintval);
		frm += 2;

		if (type == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {
			IEEE80211_ADDR_COPY(frm, ic->ic_bss->ni_bssid);
			frm += IEEE80211_ADDR_LEN;
		}

		frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);
		frm = ieee80211_add_rates(frm, &ni->ni_rates);
		frm = ieee80211_add_xrates(frm, &ni->ni_rates);
		if ((ic->ic_flags & IEEE80211_F_QOS) &&
		    (ni->ni_flags & IEEE80211_NODE_QOS))
			frm = ieee80211_add_qos_capability(frm, ic);
		m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
d1151 1
a1151 17
		/*
		 * association response frame format
		 *	[2] capability information
		 *	[2] status
		 *	[2] association ID
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 *	[tlv] parameter set (EDCA)
		 */
		m = ieee80211_getmbuf(M_DONTWAIT, MT_DATA,
		    2 +				/* capability information */
		    2 +				/* status */
		    2 +				/* association ID */
		    2 + IEEE80211_RATE_SIZE +	/* supported rates */
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE) +
		    2 + 18);			/* parameter set (EDCA) */
		if (m == NULL)
a1152 27
		m->m_data += sizeof(struct ieee80211_frame);
		frm = mtod(m, u_int8_t *);

		capinfo = IEEE80211_CAPINFO_ESS;
		if (ic->ic_flags & IEEE80211_F_WEPON)
			capinfo |= IEEE80211_CAPINFO_PRIVACY;
		if ((ic->ic_flags & IEEE80211_F_SHPREAMBLE) &&
		    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))
			capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
		if (ic->ic_flags & IEEE80211_F_SHSLOT)
			capinfo |= IEEE80211_CAPINFO_SHORT_SLOTTIME;
		*(u_int16_t *)frm = htole16(capinfo);
		frm += 2;

		*(u_int16_t *)frm = htole16(arg);	/* status */
		frm += 2;

		if (arg == IEEE80211_STATUS_SUCCESS)
			*(u_int16_t *)frm = htole16(ni->ni_associd);
		frm += 2;

		frm = ieee80211_add_rates(frm, &ni->ni_rates);
		frm = ieee80211_add_xrates(frm, &ni->ni_rates);
		if ((ic->ic_flags & IEEE80211_F_QOS) &&
		    (ni->ni_flags & IEEE80211_NODE_QOS))
			frm = ieee80211_add_edca_params(frm, ic);
		m->m_pkthdr.len = m->m_len = frm - mtod(m, u_int8_t *);
d1156 4
a1159 1
		if (ifp->if_flags & IFF_DEBUG)
d1162 1
a1162 6
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			senderr(ENOMEM, is_tx_nombuf);
		MH_ALIGN(m, 2);
		m->m_pkthdr.len = m->m_len = 2;
		*mtod(m, u_int16_t *) = htole16(arg);	/* reason */
@


1.29
log
@add two new functions:

ieee80211_up_to_ac(): returns the access category to be used for
transmitting a frame with a given user priority.

ieee80211_classify(): returns the user-priority of an mbuf based
on VLAN 802.1D user-priority (if any) or IP TOS precedence field.

indent prototypes and add myself to the copyright list while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.28 2007/06/16 11:59:58 damien Exp $	*/
d652 42
d775 1
d786 2
a787 1
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d847 2
d919 1
d927 2
a928 1
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d965 3
d982 1
d989 2
a990 1
		    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d1016 3
d1127 1
d1138 2
a1139 1
	    2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d1197 2
@


1.28
log
@don't mix u_int{8,16,32}_t and uint{8,16,32}_t
use u_int{8,16,32}_t everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.27 2007/06/16 11:56:20 damien Exp $	*/
d7 1
d34 1
d57 7
d68 5
a72 3
int ieee80211_mgmt_output(struct ifnet *, struct ieee80211_node *,
    struct mbuf *, int);
struct mbuf *ieee80211_getmbuf(int, int, u_int);
d308 120
@


1.27
log
@de-static

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.26 2007/06/11 19:35:24 damien Exp $	*/
d887 1
a887 1
	*(uint16_t *)rts->i_dur = htole16(dur);
d914 1
a914 1
	*(uint16_t *)cts->i_dur = htole16(dur);
@


1.26
log
@adds 802.11e EDCA tables for QAPs and non-AP QSTAs.
not used yet.

ok jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.25 2007/06/07 20:20:15 damien Exp $	*/
d59 4
d132 1
a132 1
static int
d521 1
a521 1
static struct mbuf *
@


1.25
log
@move ieee80211_compute_duration() and ieee80211_compute_duration1()
functions into the two drivers that use them (atw and rtw.)
this code is not generic enough to be used by other drivers and
there is no chance that it will ever be used in newer driver since
it supports 802.11b only.
plus, it hurts my eyes each time i look into ieee80211_output.c.

"fine with me as long as the logic doesn't change in the functions" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.24 2007/06/06 19:31:07 damien Exp $	*/
d194 99
@


1.24
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.23 2006/12/25 19:24:26 reyk Exp $	*/
a332 167
}

/*
 * Arguments in:
 *
 * paylen:  payload length (no FCS, no WEP header)
 *
 * hdrlen:  header length
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * flags:   IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d:       802.11 Duration field for RTS,
 *          802.11 Duration field for data frame,
 *          PLCP Length for data frame,
 *          residual octets at end of data slot
 */
static int
ieee80211_compute_duration1(int len, int use_ack, uint32_t flags, int rate,
    struct ieee80211_duration *d)
{
	int pre, ctsrate;
	int ack, bitlen, data_dur, remainder;

	/* RTS reserves medium for SIFS | CTS | SIFS | (DATA) | SIFS | ACK
	 * DATA reserves medium for SIFS | ACK
	 *
	 * XXXMYC: no ACK on multicast/broadcast or control packets
	 */

	bitlen = len * 8;

	pre = IEEE80211_DUR_DS_SIFS;
	if ((flags & IEEE80211_F_SHPREAMBLE) != 0)
		pre += IEEE80211_DUR_DS_SHORT_PREAMBLE +
		    IEEE80211_DUR_DS_FAST_PLCPHDR;
	else
		pre += IEEE80211_DUR_DS_LONG_PREAMBLE +
		    IEEE80211_DUR_DS_SLOW_PLCPHDR;

	d->d_residue = 0;
	data_dur = (bitlen * 2) / rate;
	remainder = (bitlen * 2) % rate;
	if (remainder != 0) {
		d->d_residue = (rate - remainder) / 16;
		data_dur++;
	}

	switch (rate) {
	case 2:		/* 1 Mb/s */
	case 4:		/* 2 Mb/s */
		/* 1 - 2 Mb/s WLAN: send ACK/CTS at 1 Mb/s */
		ctsrate = 2;
		break;
	case 11:	/* 5.5 Mb/s */
	case 22:	/* 11  Mb/s */
	case 44:	/* 22  Mb/s */
		/* 5.5 - 11 Mb/s WLAN: send ACK/CTS at 2 Mb/s */
		ctsrate = 4;
		break;
	default:
		/* TBD */
		return -1;
	}

	d->d_plcp_len = data_dur;

	ack = (use_ack) ? pre + (IEEE80211_DUR_DS_SLOW_ACK * 2) / ctsrate : 0;

	d->d_rts_dur =
	    pre + (IEEE80211_DUR_DS_SLOW_CTS * 2) / ctsrate +
	    pre + data_dur +
	    ack;

	d->d_data_dur = ack;

	return 0;
}

/*
 * Arguments in:
 *
 * wh:      802.11 header
 *
 * len: packet length 
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * fraglen: fragment length, set to maximum (or higher) for no
 *          fragmentation
 *
 * flags:   IEEE80211_F_WEPON (hardware adds WEP),
 *          IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d0: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 *
 * dn: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 */
int
ieee80211_compute_duration(struct ieee80211_frame *wh, int len,
    uint32_t flags, int fraglen, int rate, struct ieee80211_duration *d0,
    struct ieee80211_duration *dn, int *npktp, int debug)
{
	int ack, rc;
	int firstlen, hdrlen, lastlen, lastlen0, npkt, overlen, paylen;

	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		hdrlen = sizeof(struct ieee80211_frame_addr4);
	else
		hdrlen = sizeof(struct ieee80211_frame);

	paylen = len - hdrlen;

	if ((flags & IEEE80211_F_WEPON) != 0)
		overlen = IEEE80211_WEP_TOTLEN + IEEE80211_CRC_LEN;
	else
		overlen = IEEE80211_CRC_LEN;

	npkt = paylen / fraglen;
	lastlen0 = paylen % fraglen;

	if (npkt == 0)			/* no fragments */
		lastlen = paylen + overlen;
	else if (lastlen0 != 0) {	/* a short "tail" fragment */
		lastlen = lastlen0 + overlen;
		npkt++;
	} else				/* full-length "tail" fragment */
		lastlen = fraglen + overlen;

	if (npktp != NULL)
		*npktp = npkt;

	if (npkt > 1)
		firstlen = fraglen + overlen;
	else
		firstlen = paylen + overlen;

	if (debug) {
		printf("%s: npkt %d firstlen %d lastlen0 %d lastlen %d "
		    "fraglen %d overlen %d len %d rate %d flags %08x\n",
		    __func__, npkt, firstlen, lastlen0, lastlen, fraglen,
		    overlen, len, rate, flags);
	}

	ack = !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (wh->i_fc[1] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL;

	rc = ieee80211_compute_duration1(firstlen + hdrlen,
	    ack, flags, rate, d0);
	if (rc == -1)
		return rc;

	if (npkt <= 1) {
		*dn = *d0;
		return 0;
	}
	return ieee80211_compute_duration1(lastlen + hdrlen, ack, flags, rate,
	    dn);
@


1.23
log
@print the phy mode in IFF_DEBUG status output which helps to debug
dual/multi mode chipset operation.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.22 2006/11/03 19:02:08 damien Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.22
log
@Add two new functions:
- ieee80211_get_rts
- ieee80211_get_cts_to_self
that can be use by drivers for chipsets that don't offer hardware assisted
RTS/CTS protection (like ral/ural/rum).

"no objections here" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.21 2006/06/27 20:55:51 reyk Exp $	*/
d182 1
a182 1
			printf("%s: sending %s to %s on channel %u\n",
d188 3
a190 1
			    ieee80211_chan2ieee(ic, ni->ni_chan));
@


1.21
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.20 2006/06/18 18:39:41 damien Exp $	*/
d930 54
@


1.20
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.19 2006/05/21 07:47:26 damien Exp $	*/
d995 4
a998 1
	frm = ieee80211_add_ssid(frm, ni->ni_essid, ni->ni_esslen);
@


1.19
log
@account for the size of a 802.11 header in ieee80211_getmbuf().
fix some typos while i'm here.

ok reyk@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.18 2006/05/19 18:14:35 damien Exp $	*/
a35 2
#include <sys/cdefs.h>

d66 1
a66 1
 * later by the driver. This function could be used to send raw frames
d552 35
d639 2
a640 1
		    2 + ic->ic_des_esslen + 2 + IEEE80211_RATE_SIZE +
d666 1
d670 8
a677 3
		    8 + 2 + 2 + 2 + 2 + ni->ni_esslen +
		    2 + IEEE80211_RATE_SIZE +
		    (ic->ic_phytype == IEEE80211_T_FH ? 7 : 3) + 6 +
d697 2
d735 2
d810 6
a815 4
		    sizeof(capinfo) + sizeof(u_int16_t) +
		    IEEE80211_ADDR_LEN + 2 + ni->ni_esslen +
		    2 + IEEE80211_RATE_SIZE + 2 +
		    (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d835 2
a836 1
		if (ic->ic_flags & IEEE80211_F_SHSLOT)
d868 4
a871 2
		    sizeof(capinfo) + sizeof(u_int16_t) +
		    sizeof(u_int16_t) + 2 + IEEE80211_RATE_SIZE +
d884 2
a936 1
	int pktlen;
d941 12
a952 5
	rs = &ni->ni_rates;
	pktlen = sizeof (struct ieee80211_frame)
	    + 8 + 2 + 2 + 2+ni->ni_esslen + 2+rs->rs_nrates + 3 + 6;
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		pktlen += 2;
d954 8
a961 1
	    2 + ni->ni_esslen + 2 + IEEE80211_RATE_SIZE +
a975 10
	/*
	 * beacon frame format
	 *	[8] time stamp
	 *	[2] beacon interval
	 *	[2] cabability information
	 *	[tlv] ssid
	 *	[tlv] supported rates
	 *	[tlv] parameter set (IBSS)
	 *	[tlv] extended supported rates
	 */
d996 1
d1014 2
d1019 1
a1019 3
	if (m->m_pkthdr.len > pktlen)
		panic("beacon bigger than expected, len %u calculated %u",
		    m->m_pkthdr.len, pktlen);
@


1.18
log
@use ieee80211_add_ssid() in ieee80211_beacon_alloc() and wpi(4) instead
of duplicating the code.

last commit was ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.17 2006/05/19 18:06:51 damien Exp $	*/
d559 3
d600 1
a600 1
		 * prreq frame format
d757 1
a757 1
		 * asreq frame format
d784 1
a784 1
		 *     short premable is set.
d813 1
a813 1
		 * asreq frame format
@


1.17
log
@- export ieee80211_add_ssid() just like ieee80211_add_(x)rates() so I don't
  need to duplicate the code in wpi(4)
- fix ieee80211_alloc_beacon()
- clean two comments while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.16 2006/03/04 22:40:16 brad Exp $	*/
d938 1
a938 4
	*frm++ = IEEE80211_ELEMID_SSID;
	*frm++ = ni->ni_esslen;
	memcpy(frm, ni->ni_essid, ni->ni_esslen);
	frm += ni->ni_esslen;
@


1.16
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.15 2006/02/20 20:12:14 damien Exp $	*/
d147 5
a151 9
	 * driver's start routine.  If we don't do so then the start
	 * routine must immediately look it up again and that can
	 * cause a lock order reversal if, for example, this frame
	 * is being sent because the station is being timedout and
	 * the frame being sent is a DEAUTH message.  We could stick
	 * this in an m_tag and tack that on to the mbuf.  However
	 * that's rather expensive to do for every frame so instead
	 * we stuff it in the rcvif field since outbound frames do
	 * not (presently) use this.
d543 1
a543 1
 * Add an ssid elemet to a frame.
d545 1
a545 1
static u_int8_t *
d894 1
a894 1
	    2 + ic->ic_des_esslen + 2 + IEEE80211_RATE_SIZE +
@


1.15
log
@Fix kernel builds without bpfilter. Linking is still broken.

"Please commit this diff ASAP" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.14 2006/01/11 00:18:17 millert Exp $	*/
d99 1
a99 1
		s = splimp();
@


1.14
log
@Disable shared key mode until we have a way for the user to specify
that they explicitly want it.  What we have currently doesn't seem
to work anyway.  Add support for specifying a status type when
sending managemnent frames; adapted from FreeBSD.  OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.13 2005/09/08 13:24:53 reyk Exp $	*/
a55 2

#if NBPFILTER > 0
a56 1
#endif
@


1.13
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.12 2005/09/08 12:44:55 jsg Exp $	*/
d589 1
a589 1
	int has_challenge, is_shared_key, ret, timer;
d706 2
d715 1
a715 1
		if (has_challenge) {
d728 1
a728 1
		((u_int16_t *)frm)[2] = 0;		/* status */
d730 1
a730 1
		if (has_challenge) {
@


1.12
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.11 2005/09/08 09:11:08 jsg Exp $	*/
d81 1
a81 1
	
d230 1
a230 1
		
d233 1
a233 1
		
d382 2
a383 1
		pre += IEEE80211_DUR_DS_SHORT_PREAMBLE + IEEE80211_DUR_DS_FAST_PLCPHDR;
d385 2
a386 1
		pre += IEEE80211_DUR_DS_LONG_PREAMBLE + IEEE80211_DUR_DS_SLOW_PLCPHDR;
d610 2
a611 3
			 2 + ic->ic_des_esslen
		       + 2 + IEEE80211_RATE_SIZE
		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d616 2
a617 1
		frm = ieee80211_add_ssid(frm, ic->ic_des_essid, ic->ic_des_esslen);
d639 4
a642 6
			 8 + 2 + 2 + 2
		       + 2 + ni->ni_esslen
		       + 2 + IEEE80211_RATE_SIZE
		       + (ic->ic_phytype == IEEE80211_T_FH ? 7 : 3)
		       + 6
		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d669 5
a673 5
                        *frm++ = IEEE80211_ELEMID_FHPARMS;
                        *frm++ = 5;
                        *frm++ = ni->ni_fhdwell & 0x00ff;
                        *frm++ = (ni->ni_fhdwell >> 8) & 0x00ff;
                        *frm++ = IEEE80211_FH_CHANSET(
d675 1
a675 1
                        *frm++ = IEEE80211_FH_CHANPAT(
d677 1
a677 1
                        *frm++ = ni->ni_fhindex;
d695 1
a695 1
			*frm++ = 0;	/* Partial Virtual Bitmap (variable length) */
d723 2
a724 2
		    (is_shared_key) ? htole16(IEEE80211_AUTH_ALG_SHARED)
		                    : htole16(IEEE80211_AUTH_ALG_OPEN);
d768 4
a771 6
			 sizeof(capinfo)
		       + sizeof(u_int16_t)
		       + IEEE80211_ADDR_LEN
		       + 2 + ni->ni_esslen
		       + 2 + IEEE80211_RATE_SIZE
		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d823 3
a825 5
			 sizeof(capinfo)
		       + sizeof(u_int16_t)
		       + sizeof(u_int16_t)
		       + 2 + IEEE80211_RATE_SIZE
		       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d899 2
a900 3
		 2 + ic->ic_des_esslen
	       + 2 + IEEE80211_RATE_SIZE
	       + 2 + (IEEE80211_RATE_MAXSIZE - IEEE80211_RATE_SIZE));
d975 1
a975 1
		  struct mbuf *m)
d987 5
a991 5
			       " of size %d drops %d\n",
			       ic->ic_if.if_xname,
			       ether_sprintf(ni->ni_macaddr),
			       IEEE80211_PS_MAX_QUEUE,
			       ni->ni_savedq.ifq_drops);
@


1.11
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.10 2005/09/07 05:40:11 jsg Exp $	*/
a66 1
#include <net80211/ieee80211_compat.h>
d144 2
a145 1
	IASSERT(ni != NULL, ("null node"));
d564 2
a565 1
	IASSERT(pktlen <= MCLBYTES, ("802.11 packet too large: %u", pktlen));
d589 2
a590 1
	IASSERT(ni != NULL, ("null node"));
d972 3
a974 3
	IASSERT(m->m_pkthdr.len <= pktlen,
		("beacon bigger than expected, len %u calculated %u",
		m->m_pkthdr.len, pktlen));
@


1.10
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.9 2005/04/20 19:52:43 reyk Exp $	*/
d108 2
a109 1
			if_printf(ifp, "failed to queue raw tx frame\n");
d191 2
a192 1
			if_printf(ifp, "sending %s to %s on channel %u\n",
d260 3
a262 2
			if_printf(ifp, "no node for dst %s, "
			    "discard raw tx frame\n", ether_sprintf(addr));
d744 2
a745 2
			if_printf(ifp, "station %s deauthenticate (reason %d)\n",
			    ether_sprintf(ni->ni_macaddr), arg);
d856 2
a857 2
			if_printf(ifp, "station %s disassociate (reason %d)\n",
			    ether_sprintf(ni->ni_macaddr), arg);
@


1.9
log
@send raw 802.11 frames with bpf(4) using the IEEE802_11 or
IEEE802_11_RADIO data link types.

ok canacar@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.8 2005/03/11 23:20:26 jsg Exp $	*/
a36 9
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_output.c,v 1.10 2004/04/02 23:25:39 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_output.c,v 1.13 2004/05/31 11:02:55 dyoung Exp $");
#endif

#ifdef __NetBSD__
#include "opt_inet.h"
#endif
a47 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a50 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a54 5
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a62 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a63 3
#else
#include <net/if_ether.h>
#endif
a161 3
#ifdef __FreeBSD__
	KASSERT(m->m_pkthdr.rcvif == NULL, ("rcvif not null"));
#endif
a561 6
#ifdef __FreeBSD__
	if (pktlen <= MHLEN)
		MGETHDR(m, flags, type);
	else
		m = m_getcl(flags, type, M_PKTHDR);
#else
a564 1
#endif
@


1.8
log
@Make sure we associate an interface with the m_pkthdr in
ieee80211_beacon_alloc.
ok damien@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.7 2005/03/03 14:36:41 damien Exp $	*/
d95 61
d249 47
d297 1
@


1.7
log
@addtion of a generic function for allocating beacons: ieee80211_beacon_alloc().
ok jsg@@, reyk@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.6 2005/02/26 15:49:34 jsg Exp $	*/
d892 1
@


1.6
log
@Fix a problem introduced with the recent lru cache change.
Check that we actually have a node before trying to release it.
This was causing a panic when playing with IBSS. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.5 2005/02/17 18:28:05 reyk Exp $	*/
d806 90
@


1.5
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.4 2004/12/28 23:07:32 jsg Exp $	*/
d256 2
a257 1
	ieee80211_release_node(ic, ni);
@


1.4
log
@Sync with recent NetBSD ieee80211_compute_duration() changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.3 2004/12/23 12:27:25 jsg Exp $	*/
d201 1
a201 1
			__func__, ether_sprintf(eh.ether_dhost)));
d238 1
a238 1
		IEEE80211_ADDR_COPY(wh->i_addr3, ni->ni_bssid);
d256 1
a256 2
	if (ni && ni != ic->ic_bss)
		ieee80211_free_node(ic, ni);
d392 1
a392 1
	} else
d517 1
a517 2
	if (ni != ic->ic_bss)
		ieee80211_ref_node(ni);
d790 1
a790 1
			__func__, type));
d801 1
a801 2
		if (ni != ic->ic_bss)		/* remove ref we added */
			ieee80211_free_node(ic, ni);
@


1.3
log
@From dyoung@@NetBSD:

ieee80211.h r 1.9

#define the difference in microseconds between a fast and a slow
preamble and PLCP header.

ieee80211_output.c r 1.19

Fix a bug in ieee80211_compute_duration: the 802.11 Duration field
in an 802.11 unicast data packet is equal to the duration of the
SIFS and Acknowledgement.  That is, the amount of time reserved
*after* the packet has finished transmitting.

Change the arguments to ieee80211_compute_duration: pass the entire
packet length, not just the payload length.  Add a 'debug' argument
to ieee80211_compute_duration and its helper subroutine,
ieee80211_compute_duration1.

If debug != 0, ieee80211_compute_duration printfs its arguments
and several local variables.

In rtw(4), load the 802.11 Duration field with the result from
ieee80211_compute_duration.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.2 2004/12/23 11:54:09 jsg Exp $	*/
d276 2
a277 1
 * d:       802.11 Duration field for data frame,
d279 1
a279 2
 *          PLCP Service field for data frame,
 *          802.11 Duration field for RTS
d282 1
a282 1
ieee80211_compute_duration1(int len, uint32_t flags, int rate,
d285 2
a286 1
	int ack, bitlen, cts, data_dur, remainder;
d290 2
d296 13
a308 5
#if 0
	/* RTS is always sent at 1 Mb/s.  (XXX Really?) */
	d->d_rts_plcp_len = sizeof(struct ieee80211_frame_rts) * 8;
#endif
	d->d_plcp_svc = 0;
a312 2
		data_dur = (bitlen * 2) / rate;

d314 1
a314 2
		cts = IEEE80211_DUR_DS_SLOW_CTS;
		ack = IEEE80211_DUR_DS_SLOW_ACK;
a315 3
	case 44:	/* 22  Mb/s */
		d->d_plcp_svc = IEEE80211_PLCP_SERVICE_PBCC;
		/*FALLTHROUGH*/
d318 1
a318 10
		remainder = (bitlen * 2) % rate;

		if (remainder != 0)
			data_dur = (bitlen * 2) / rate + 1;
		else
			data_dur = (bitlen * 2) / rate;

		if (rate == 22 && remainder <= 6)
			d->d_plcp_svc |= IEEE80211_PLCP_SERVICE_LENEXT;

d320 1
a320 2
		cts = IEEE80211_DUR_DS_FAST_CTS;
		ack = IEEE80211_DUR_DS_FAST_ACK;
d329 5
a333 10
	d->d_rts_dur = data_dur + 3 * (IEEE80211_DUR_DS_SIFS +
	    IEEE80211_DUR_DS_SHORT_PREAMBLE +
	    IEEE80211_DUR_DS_FAST_PLCPHDR) + cts + ack;

	/* Note that this is the amount of time reserved *after*
	 * the packet is transmitted: just long enough for a SIFS
	 * and an ACK.
	 */
	d->d_data_dur = IEEE80211_DUR_DS_SIFS +
	    IEEE80211_DUR_DS_SHORT_PREAMBLE + IEEE80211_DUR_DS_FAST_PLCPHDR +
d336 1
a336 2
	if ((flags & IEEE80211_F_SHPREAMBLE) != 0)
		return 0;
a337 4
	d->d_rts_dur += 3 * IEEE80211_DUR_DS_PREAMBLE_DIFFERENCE +
			3 * IEEE80211_DUR_DS_PLCPHDR_DIFFERENCE;
	d->d_data_dur += IEEE80211_DUR_DS_PREAMBLE_DIFFERENCE +
			 IEEE80211_DUR_DS_PLCPHDR_DIFFERENCE;
d370 1
a370 1
	int rc;
d380 1
a380 1
	if ((flags & IEEE80211_F_WEPON) != 0) {
d382 1
a382 10
#if 0	/* 802.11 lets us extend a fragment's length by the length of
	 * a WEP header, AFTER fragmentation.  Might want to disable
	 * this while fancy link adaptations are running.
	 */
		fraglen -= IEEE80211_WEP_TOTLEN;
#endif
#if 0	/* Ditto CRC? */
		fraglen -= IEEE80211_CRC_LEN;
#endif
	} else
d388 1
a388 2
	if (npkt == 0) {
		/* no fragments */
d390 1
a390 2
	} else if (lastlen0 != 0) {
		/* a short fragment */
d410 6
a415 1
	rc = ieee80211_compute_duration1(firstlen + hdrlen, flags, rate, d0);
d423 2
a424 1
	return ieee80211_compute_duration1(lastlen + hdrlen, flags, rate, dn);
@


1.2
log
@From dyoung@@NetBSD:

Define for more bits in the Service field of the 802.11 PLCP Header.

For use by the subroutine ieee80211_compute_duration, add struct
ieee80211_duration, and #define a number of microsecond constants
used for the transmit timing of 802.11 packets.

Add the subroutine ieee80211_compute_duration, which computes for
any packet the appropriate 802.11 Duration field, the PLCP Length
field, as well as the Duration and Length fields for an RTS frame.

atw(4), rtw(4), future drivers, and possibly ath(4) will share
ieee80211_compute_duration.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_output.c,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d332 2
a336 3
	d->d_data_dur = data_dur + IEEE80211_DUR_DS_SIFS +
	    2 * (IEEE80211_DUR_DS_SHORT_PREAMBLE +
	         IEEE80211_DUR_DS_FAST_PLCPHDR) + ack;
d338 7
a344 1
	d->d_plcp_len = data_dur;
d349 4
a352 8
	d->d_rts_dur += 3 * (IEEE80211_DUR_DS_LONG_PREAMBLE -
			     IEEE80211_DUR_DS_SHORT_PREAMBLE) +
			3 * (IEEE80211_DUR_DS_SLOW_PLCPHDR -
			     IEEE80211_DUR_DS_FAST_PLCPHDR);
	d->d_data_dur += 2 * (IEEE80211_DUR_DS_LONG_PREAMBLE -
			      IEEE80211_DUR_DS_SHORT_PREAMBLE) +
			 2 * (IEEE80211_DUR_DS_SLOW_PLCPHDR -
			      IEEE80211_DUR_DS_FAST_PLCPHDR);
d361 1
a361 1
 * paylen:  payload length (no FCS, no WEP header)
d381 1
a381 1
ieee80211_compute_duration(struct ieee80211_frame *wh, int paylen,
d383 1
a383 1
    struct ieee80211_duration *dn, int *npktp)
d386 1
a386 1
	int firstlen, hdrlen, lastlen, lastlen0, npkt, overlen;
d393 2
d430 6
d439 2
a440 1
	if (npkt > 1) {
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 175
@

