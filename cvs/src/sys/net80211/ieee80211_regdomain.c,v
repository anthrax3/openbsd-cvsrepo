head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.10
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.8
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.4
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.7.0.34
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.32
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.28
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.26
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.24
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.22
	OPENBSD_5_0:1.7.0.20
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.18
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.16
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.12
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.14
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.4
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.4.0.4
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4;
locks; strict;
comment	@ * @;


1.10
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.9;
commitid	FuSD2mFDJWATHIDx;

1.9
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.8;
commitid	PYnSnAqgemmk34E3;

1.8
date	2014.08.08.15.16.39;	author jasper;	state Exp;
branches;
next	1.7;
commitid	XqlyEl7HuWPLWo47;

1.7
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2005.12.18.17.59.59;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.17.23.52.05;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.06.18.31.41;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	;


desc
@@


1.10
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@/*	$OpenBSD: ieee80211_regdomain.c,v 1.9 2014/12/23 03:24:08 tedu Exp $	*/

/*
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Basic regulation domain extensions for the IEEE 802.11 stack
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_llc.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_regdomain.h>

int	 ieee80211_regdomain_compare_cn(const void *, const void *);
int	 ieee80211_regdomain_compare_rn(const void *, const void *);

static const struct ieee80211_regdomainname
ieee80211_r_names[] = IEEE80211_REGDOMAIN_NAMES;

static const struct ieee80211_regdomainmap
ieee80211_r_map[] = IEEE80211_REGDOMAIN_MAP;

static const struct ieee80211_countryname
ieee80211_r_ctry[] = IEEE80211_REGDOMAIN_COUNTRY_NAMES;

#ifndef bsearch
const void *bsearch(const void *, const void *, size_t, size_t,
    int (*)(const void *, const void *));

const void *
bsearch(const void *key, const void *base0, size_t nmemb, size_t size,
    int (*compar)(const void *, const void *))
{
	const char *base = base0;
	int lim, cmp;
	const void *p;

	for (lim = nmemb; lim != 0; lim >>= 1) {
		p = base + (lim >> 1) * size;
		cmp = (*compar)(key, p);
		if (cmp == 0)
			return ((const void *)p);
		if (cmp > 0) {  /* key > p: move right */
			base = (const char *)p + size;
			lim--;
		} /* else move left */
	}
	return (NULL);
}
#endif

int
ieee80211_regdomain_compare_cn(const void *a, const void *b)
{
	return (strcmp(((const struct ieee80211_countryname*)a)->cn_name,
	    ((const struct ieee80211_countryname*)b)->cn_name));
}

int
ieee80211_regdomain_compare_rn(const void *a, const void *b)
{
	return (strcmp(((const struct ieee80211_regdomainname*)a)->rn_name,
	    ((const struct ieee80211_regdomainname*)b)->rn_name));
}

u_int16_t
ieee80211_name2countrycode(const char *name)
{
	const struct ieee80211_countryname key = { CTRY_DEFAULT, name }, *value;

	if ((value = bsearch(&key, &ieee80211_r_ctry,
	    nitems(ieee80211_r_ctry), sizeof(struct ieee80211_countryname),
	    ieee80211_regdomain_compare_cn)) != NULL)
		return (value->cn_code);

	return (CTRY_DEFAULT);
}

u_int32_t
ieee80211_name2regdomain(const char *name)
{
	const struct ieee80211_regdomainname *value;
	struct ieee80211_regdomainname key;

	key.rn_domain = DMN_DEFAULT;
	key.rn_name = name;

	if ((value = bsearch(&key, &ieee80211_r_names,
	    nitems(ieee80211_r_names), sizeof(struct ieee80211_regdomainname),
	    ieee80211_regdomain_compare_rn)) != NULL)
		return ((u_int32_t)value->rn_domain);

	return ((u_int32_t)DMN_DEFAULT);
}

const char *
ieee80211_countrycode2name(u_int16_t code)
{
	int i;

	/* Linear search over the table */
	for (i = 0; i < (sizeof(ieee80211_r_ctry) /
	    sizeof(ieee80211_r_ctry[0])); i++)
		if (ieee80211_r_ctry[i].cn_code == code)
			return (ieee80211_r_ctry[i].cn_name);

	return (NULL);
}

const char *
ieee80211_regdomain2name(u_int32_t regdomain)
{
	int i;

	/* Linear search over the table */
	for (i = 0; i < (sizeof(ieee80211_r_names) /
		sizeof(ieee80211_r_names[0])); i++)
		if (ieee80211_r_names[i].rn_domain == regdomain)
			return (ieee80211_r_names[i].rn_name);

	return (ieee80211_r_names[0].rn_name);
}

u_int32_t
ieee80211_regdomain2flag(u_int16_t regdomain, u_int16_t mhz)
{
	int i;

	for (i = 0; i < (sizeof(ieee80211_r_map) /
		sizeof(ieee80211_r_map[0])); i++) {
		if (ieee80211_r_map[i].rm_domain == regdomain) {
			if (mhz >= 2000 && mhz <= 3000)
				return ((u_int32_t)
				    ieee80211_r_map[i].rm_domain_2ghz);
			if (mhz >= IEEE80211_CHANNELS_5GHZ_MIN &&
			    mhz <= IEEE80211_CHANNELS_5GHZ_MAX)
				return ((u_int32_t)
				    ieee80211_r_map[i].rm_domain_5ghz);
		}
	}

	return ((u_int32_t)DMN_DEBUG);
}

u_int32_t
ieee80211_countrycode2regdomain(u_int16_t code)
{
	int i;

	for (i = 0; i < nitems(ieee80211_r_ctry); i++)
		if (ieee80211_r_ctry[i].cn_code == code)
			return (ieee80211_r_ctry[i].cn_domain);

	return ((u_int32_t)DMN_DEFAULT);
}
@


1.9
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.8 2014/08/08 15:16:39 jasper Exp $	*/
a34 1
#include <net/if_arp.h>
@


1.8
log
@use nitems() instead of various local constructs

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.7 2006/11/26 19:46:28 deraadt Exp $	*/
a37 1
#ifdef INET
a39 1
#endif
@


1.7
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.6 2005/12/18 17:59:59 reyk Exp $	*/
d104 1
a104 2
	    sizeof(ieee80211_r_ctry) / sizeof(ieee80211_r_ctry[0]),
	    sizeof(struct ieee80211_countryname),
d121 1
a121 2
	    sizeof(ieee80211_r_names) / sizeof(ieee80211_r_names[0]),
	    sizeof(struct ieee80211_regdomainname),
d182 1
a182 2
	for (i = 0;
	     i < (sizeof(ieee80211_r_ctry) / sizeof(ieee80211_r_ctry[0])); i++)
@


1.6
log
@Update my e-mail address in the copyright statement, no binary changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.5 2005/09/08 13:24:53 reyk Exp $	*/
a42 1
#include <net80211/ieee80211.h>
@


1.5
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.4 2005/02/17 23:52:05 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004, 2005 Reyk Floeter <reyk@@vantronix.net>
@


1.4
log
@a new year and a new, less restrictive license. because it has to be
free.

go ahead miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.3 2005/02/17 18:28:05 reyk Exp $	*/
d70 1
a70 1
	
d88 2
a89 2
	return(strcmp(((const struct ieee80211_countryname*)a)->cn_name, 
		   ((const struct ieee80211_countryname*)b)->cn_name));
d95 2
a96 2
	return(strcmp(((const struct ieee80211_regdomainname*)a)->rn_name, 
		   ((const struct ieee80211_regdomainname*)b)->rn_name));
d104 5
a108 5
	if((value = bsearch(&key, &ieee80211_r_ctry,
		sizeof(ieee80211_r_ctry) / sizeof(ieee80211_r_ctry[0]),
		sizeof(struct ieee80211_countryname),
		ieee80211_regdomain_compare_cn)) != NULL)
		return(value->cn_code);
d110 1
a110 1
	return(CTRY_DEFAULT);
d116 5
a120 1
	const struct ieee80211_regdomainname key = { DMN_DEFAULT, name }, *value;
d122 5
a126 5
	if((value = bsearch(&key, &ieee80211_r_names,
		sizeof(ieee80211_r_names) / sizeof(ieee80211_r_names[0]),
		sizeof(struct ieee80211_regdomainname),
		ieee80211_regdomain_compare_rn)) != NULL)
		return((u_int32_t)value->rn_domain);
d128 1
a128 1
	return((u_int32_t)DMN_DEFAULT);
d137 4
a140 3
	for(i = 0; i < (sizeof(ieee80211_r_ctry) / sizeof(ieee80211_r_ctry[0])); i++)
		if(ieee80211_r_ctry[i].cn_code == code)
			return(ieee80211_r_ctry[i].cn_name);
d142 1
a142 1
	return(NULL);
d151 1
a151 1
	for(i = 0; i < (sizeof(ieee80211_r_names) /
d153 2
a154 2
		if(ieee80211_r_names[i].rn_domain == regdomain)
			return(ieee80211_r_names[i].rn_name);
d156 1
a156 1
	return(ieee80211_r_names[0].rn_name);
d163 2
a164 2
	
	for(i = 0; i < (sizeof(ieee80211_r_map) / 
d166 5
a170 4
		if(ieee80211_r_map[i].rm_domain == regdomain) {
			if(mhz >= 2000 && mhz <= 3000)
				return((u_int32_t)ieee80211_r_map[i].rm_domain_2ghz);
			if(mhz >= IEEE80211_CHANNELS_5GHZ_MIN && 
d172 2
a173 1
				return((u_int32_t)ieee80211_r_map[i].rm_domain_5ghz);
d177 1
a177 1
	return((u_int32_t)DMN_DEBUG);
d190 1
a190 1
	return((u_int32_t)DMN_DEFAULT);
@


1.3
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.2 2004/11/06 18:31:41 reyk Exp $	*/
d4 1
a4 1
 * Copyright (c) 2004 Reyk Floeter <reyk@@vantronix.net>. 
d6 3
a8 1
 * All rights reserved.
d10 7
a16 18
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY
 * SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
 * CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
@


1.2
log
@fixed types in ieee80211_regdomain (thanks to Joerg Sonnenberger). now it
also works with gcc3 (ok naddy@@).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_regdomain.c,v 1.1 2004/11/02 02:15:49 reyk Exp $	*/
d182 12
@


1.1
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
a69 1
void *bsearch(const void *, const void *, size_t, size_t,
d72 1
a72 1
void *
d84 1
a84 1
			return ((void *)p);
d86 1
a86 1
			base = (char *)p + size;
d97 2
a98 2
	return(strcmp(((struct ieee80211_countryname*)a)->cn_name, 
		   ((struct ieee80211_countryname*)b)->cn_name));
d104 2
a105 2
	return(strcmp(((struct ieee80211_regdomainname*)a)->rn_name, 
		   ((struct ieee80211_regdomainname*)b)->rn_name));
d111 1
a111 1
	struct ieee80211_countryname key = { CTRY_DEFAULT, name }, *value;
d125 1
a125 1
	struct ieee80211_regdomainname key = { DMN_DEFAULT, name }, *value;
@

