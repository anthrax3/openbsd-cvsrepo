head	1.69;
access;
symbols
	OPENBSD_6_1_BASE:1.69
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.65.0.6
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.60.0.12
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.10
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.8
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.6
	OPENBSD_5_0:1.60.0.4
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.58.0.4
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.58.0.6
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.43.0.2
	OPENBSD_4_4_BASE:1.43
	OPENBSD_4_3:1.36.0.2
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.3.0.6
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.4
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.3.0.2
	OPENBSD_3_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.69
date	2017.03.23.04.10.10;	author tb;	state Exp;
branches;
next	1.68;
commitid	EiuhETcE9N1Gqn0A;

1.68
date	2016.12.20.13.27.58;	author stsp;	state Exp;
branches;
next	1.67;
commitid	DvA0P57klhTJwCz0;

1.67
date	2016.12.17.18.35.54;	author stsp;	state Exp;
branches;
next	1.66;
commitid	jPAQ1b8Z1ErNDg1z;

1.66
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.65;
commitid	FuSD2mFDJWATHIDx;

1.65
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.64;
commitid	PYnSnAqgemmk34E3;

1.64
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.63;
commitid	Z1vcFtHO8wRH0yRt;

1.63
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.62;
commitid	uzzBR7hz9ncd4O6G;

1.62
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.61;
commitid	B4dZSbxas1X1IpXI;

1.61
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.13.17.24.54;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2008.08.14.16.14.53;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2008.08.14.16.10.01;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.12.19.56.59;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.12.19.34.54;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.12.18.48.35;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.12.18.41.18;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.12.18.01.41;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.12.16.14.05;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.12.16.05.15;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.12.15.59.40;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.16.18.32.04;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.04.26.20.03.34;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2008.04.21.19.01.01;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2008.04.18.09.16.14;	author djm;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.17.18.05.33;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2007.09.11.19.03.33;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.29.19.54.46;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.23.16.49.57;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.22.20.52.26;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.22.20.40.34;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.03.16.51.06;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.01.15.40.40;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.01.12.59.33;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.08.01.12.23.26;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.08.01.12.15.48;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.28.11.01.19;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.24.20.34.16;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.24.19.39.22;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.24.18.44.36;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.24.18.42.16;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.24.16.53.03;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.24.16.49.16;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.18.19.47.44;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.18.18.16.33;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.14.20.00.33;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.14.19.58.04;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.05.20.18.02;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.20.11.04;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.12.29.15.45.56;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.13.24.52;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.28.19.29.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.06.27.04.14.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Use explicit_bzero() to wipe out key material and add some sizes to free().

ok stsp
@
text
@/*	$OpenBSD: ieee80211_crypto.c,v 1.68 2016/12/20 13:27:58 stsp Exp $	*/

/*-
 * Copyright (c) 2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

#include <crypto/arc4.h>
#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/sha2.h>
#include <crypto/hmac.h>
#include <crypto/rijndael.h>
#include <crypto/cmac.h>
#include <crypto/key_wrap.h>

void	ieee80211_prf(const u_int8_t *, size_t, const u_int8_t *, size_t,
	    const u_int8_t *, size_t, u_int8_t *, size_t);
void	ieee80211_kdf(const u_int8_t *, size_t, const u_int8_t *, size_t,
	    const u_int8_t *, size_t, u_int8_t *, size_t);
void	ieee80211_derive_pmkid(enum ieee80211_akm, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, u_int8_t *);

void
ieee80211_crypto_attach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	TAILQ_INIT(&ic->ic_pmksa);
	if (ic->ic_caps & IEEE80211_C_RSN) {
		ic->ic_rsnprotos = IEEE80211_PROTO_RSN;
		ic->ic_rsnakms = IEEE80211_AKM_PSK;
		ic->ic_rsnciphers = IEEE80211_CIPHER_CCMP;
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_CCMP;
		ic->ic_rsngroupmgmtcipher = IEEE80211_CIPHER_BIP;
	}
	ic->ic_set_key = ieee80211_set_key;
	ic->ic_delete_key = ieee80211_delete_key;
#ifndef IEEE80211_STA_ONLY
	timeout_set(&ic->ic_tkip_micfail_timeout,
	    ieee80211_michael_mic_failure_timeout, ic);
#endif
}


void
ieee80211_crypto_detach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_pmk *pmk;
	int i;

	/* purge the PMKSA cache */
	while ((pmk = TAILQ_FIRST(&ic->ic_pmksa)) != NULL) {
		TAILQ_REMOVE(&ic->ic_pmksa, pmk, pmk_next);
		explicit_bzero(pmk, sizeof(*pmk));
		free(pmk, M_DEVBUF, sizeof(*pmk));
	}

	/* clear all group keys from memory */
	for (i = 0; i < IEEE80211_GROUP_NKID; i++) {
		struct ieee80211_key *k = &ic->ic_nw_keys[i];
		if (k->k_cipher != IEEE80211_CIPHER_NONE)
			(*ic->ic_delete_key)(ic, NULL, k);
		explicit_bzero(k, sizeof(*k));
	}

	/* clear pre-shared key from memory */
	explicit_bzero(ic->ic_psk, IEEE80211_PMK_LEN);

#ifndef IEEE80211_STA_ONLY
	timeout_del(&ic->ic_tkip_micfail_timeout);
#endif
}

/*
 * Return the length in bytes of a cipher suite key (see Table 60).
 */
int
ieee80211_cipher_keylen(enum ieee80211_cipher cipher)
{
	switch (cipher) {
	case IEEE80211_CIPHER_WEP40:
		return 5;
	case IEEE80211_CIPHER_TKIP:
		return 32;
	case IEEE80211_CIPHER_CCMP:
		return 16;
	case IEEE80211_CIPHER_WEP104:
		return 13;
	case IEEE80211_CIPHER_BIP:
		return 16;
	default:	/* unknown cipher */
		return 0;
	}
}

int
ieee80211_set_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	int error;

	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
	case IEEE80211_CIPHER_WEP104:
		error = ieee80211_wep_set_key(ic, k);
		break;
	case IEEE80211_CIPHER_TKIP:
		error = ieee80211_tkip_set_key(ic, k);
		break;
	case IEEE80211_CIPHER_CCMP:
		error = ieee80211_ccmp_set_key(ic, k);
		break;
	case IEEE80211_CIPHER_BIP:
		error = ieee80211_bip_set_key(ic, k);
		break;
	default:
		/* should not get there */
		error = EINVAL;
	}
	return error;
}

void
ieee80211_delete_key(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_key *k)
{
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
	case IEEE80211_CIPHER_WEP104:
		ieee80211_wep_delete_key(ic, k);
		break;
	case IEEE80211_CIPHER_TKIP:
		ieee80211_tkip_delete_key(ic, k);
		break;
	case IEEE80211_CIPHER_CCMP:
		ieee80211_ccmp_delete_key(ic, k);
		break;
	case IEEE80211_CIPHER_BIP:
		ieee80211_bip_delete_key(ic, k);
		break;
	default:
		/* should not get there */
		break;
	}
	explicit_bzero(k, sizeof(*k));
}

struct ieee80211_key *
ieee80211_get_txkey(struct ieee80211com *ic, const struct ieee80211_frame *wh,
    struct ieee80211_node *ni)
{
	int kid;

	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP)
		return &ni->ni_pairwise_key;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=
	    IEEE80211_FC0_TYPE_MGT)
		kid = ic->ic_def_txkey;
	else
		kid = ic->ic_igtk_kid;
	return &ic->ic_nw_keys[kid];
}

struct mbuf *
ieee80211_encrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
	case IEEE80211_CIPHER_WEP104:
		m0 = ieee80211_wep_encrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_TKIP:
		m0 = ieee80211_tkip_encrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_CCMP:
		m0 = ieee80211_ccmp_encrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_BIP:
		m0 = ieee80211_bip_encap(ic, m0, k);
		break;
	default:
		/* should not get there */
		m_freem(m0);
		m0 = NULL;
	}
	return m0;
}

struct mbuf *
ieee80211_decrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	u_int8_t *ivp, *mmie;
	u_int16_t kid;
	int hdrlen;

	/* find key for decryption */
	wh = mtod(m0, struct ieee80211_frame *);
	if ((ic->ic_flags & IEEE80211_F_RSNON) &&
	    !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP) {
		k = &ni->ni_pairwise_key;

	} else if (!IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=
	    IEEE80211_FC0_TYPE_MGT) {
		/* retrieve group data key id from IV field */
		hdrlen = ieee80211_get_hdrlen(wh);
		/* check that IV field is present */
		if (m0->m_len < hdrlen + 4) {
			m_freem(m0);
			return NULL;
		}
		ivp = (u_int8_t *)wh + hdrlen;
		kid = ivp[3] >> 6;
		k = &ic->ic_nw_keys[kid];
	} else {
		/* retrieve integrity group key id from MMIE */
		if (m0->m_len < sizeof(*wh) + IEEE80211_MMIE_LEN) {
			m_freem(m0);
			return NULL;
		}
		/* it is assumed management frames are contiguous */
		mmie = (u_int8_t *)wh + m0->m_len - IEEE80211_MMIE_LEN;
		/* check that MMIE is valid */
		if (mmie[0] != IEEE80211_ELEMID_MMIE || mmie[1] != 16) {
			m_freem(m0);
			return NULL;
		}
		kid = LE_READ_2(&mmie[2]);
		if (kid != 4 && kid != 5) {
			m_freem(m0);
			return NULL;
		}
		k = &ic->ic_nw_keys[kid];
	}
	switch (k->k_cipher) {
	case IEEE80211_CIPHER_WEP40:
	case IEEE80211_CIPHER_WEP104:
		m0 = ieee80211_wep_decrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_TKIP:
		m0 = ieee80211_tkip_decrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_CCMP:
		m0 = ieee80211_ccmp_decrypt(ic, m0, k);
		break;
	case IEEE80211_CIPHER_BIP:
		m0 = ieee80211_bip_decap(ic, m0, k);
		break;
	default:
		/* key not defined */
		m_freem(m0);
		m0 = NULL;
	}
	return m0;
}

/*
 * SHA1-based Pseudo-Random Function (see 8.5.1.1).
 */
void
ieee80211_prf(const u_int8_t *key, size_t key_len, const u_int8_t *label,
    size_t label_len, const u_int8_t *context, size_t context_len,
    u_int8_t *output, size_t len)
{
	HMAC_SHA1_CTX ctx;
	u_int8_t digest[SHA1_DIGEST_LENGTH];
	u_int8_t count;

	for (count = 0; len != 0; count++) {
		HMAC_SHA1_Init(&ctx, key, key_len);
		HMAC_SHA1_Update(&ctx, label, label_len);
		HMAC_SHA1_Update(&ctx, context, context_len);
		HMAC_SHA1_Update(&ctx, &count, 1);
		if (len < SHA1_DIGEST_LENGTH) {
			HMAC_SHA1_Final(digest, &ctx);
			/* truncate HMAC-SHA1 to len bytes */
			memcpy(output, digest, len);
			break;
		}
		HMAC_SHA1_Final(output, &ctx);
		output += SHA1_DIGEST_LENGTH;
		len -= SHA1_DIGEST_LENGTH;
	}
}

/*
 * SHA256-based Key Derivation Function (see 8.5.1.5.2).
 */
void
ieee80211_kdf(const u_int8_t *key, size_t key_len, const u_int8_t *label,
    size_t label_len, const u_int8_t *context, size_t context_len,
    u_int8_t *output, size_t len)
{
	HMAC_SHA256_CTX ctx;
	u_int8_t digest[SHA256_DIGEST_LENGTH];
	u_int16_t i, iter, length;

	length = htole16(len * NBBY);
	for (i = 1; len != 0; i++) {
		HMAC_SHA256_Init(&ctx, key, key_len);
		iter = htole16(i);
		HMAC_SHA256_Update(&ctx, (u_int8_t *)&iter, sizeof iter);
		HMAC_SHA256_Update(&ctx, label, label_len);
		HMAC_SHA256_Update(&ctx, context, context_len);
		HMAC_SHA256_Update(&ctx, (u_int8_t *)&length, sizeof length);
		if (len < SHA256_DIGEST_LENGTH) {
			HMAC_SHA256_Final(digest, &ctx);
			/* truncate HMAC-SHA-256 to len bytes */
			memcpy(output, digest, len);
			break;
		}
		HMAC_SHA256_Final(output, &ctx);
		output += SHA256_DIGEST_LENGTH;
		len -= SHA256_DIGEST_LENGTH;
	}
}

/*
 * Derive Pairwise Transient Key (PTK) (see 8.5.1.2).
 */
void
ieee80211_derive_ptk(enum ieee80211_akm akm, const u_int8_t *pmk,
    const u_int8_t *aa, const u_int8_t *spa, const u_int8_t *anonce,
    const u_int8_t *snonce, struct ieee80211_ptk *ptk)
{
	void (*kdf)(const u_int8_t *, size_t, const u_int8_t *, size_t,
	    const u_int8_t *, size_t, u_int8_t *, size_t);
	u_int8_t buf[2 * IEEE80211_ADDR_LEN + 2 * EAPOL_KEY_NONCE_LEN];
	int ret;

	/* Min(AA,SPA) || Max(AA,SPA) */
	ret = memcmp(aa, spa, IEEE80211_ADDR_LEN) < 0;
	memcpy(&buf[ 0], ret ? aa : spa, IEEE80211_ADDR_LEN);
	memcpy(&buf[ 6], ret ? spa : aa, IEEE80211_ADDR_LEN);

	/* Min(ANonce,SNonce) || Max(ANonce,SNonce) */
	ret = memcmp(anonce, snonce, EAPOL_KEY_NONCE_LEN) < 0;
	memcpy(&buf[12], ret ? anonce : snonce, EAPOL_KEY_NONCE_LEN);
	memcpy(&buf[44], ret ? snonce : anonce, EAPOL_KEY_NONCE_LEN);

	kdf = ieee80211_is_sha256_akm(akm) ? ieee80211_kdf : ieee80211_prf;
	(*kdf)(pmk, IEEE80211_PMK_LEN, "Pairwise key expansion", 23,
	    buf, sizeof buf, (u_int8_t *)ptk, sizeof(*ptk));
}

static void
ieee80211_pmkid_sha1(const u_int8_t *pmk, const u_int8_t *aa,
    const u_int8_t *spa, u_int8_t *pmkid)
{
	HMAC_SHA1_CTX ctx;
	u_int8_t digest[SHA1_DIGEST_LENGTH];

	HMAC_SHA1_Init(&ctx, pmk, IEEE80211_PMK_LEN);
	HMAC_SHA1_Update(&ctx, "PMK Name", 8);
	HMAC_SHA1_Update(&ctx, aa, IEEE80211_ADDR_LEN);
	HMAC_SHA1_Update(&ctx, spa, IEEE80211_ADDR_LEN);
	HMAC_SHA1_Final(digest, &ctx);
	/* use the first 128 bits of HMAC-SHA1 */
	memcpy(pmkid, digest, IEEE80211_PMKID_LEN);
}

static void
ieee80211_pmkid_sha256(const u_int8_t *pmk, const u_int8_t *aa,
    const u_int8_t *spa, u_int8_t *pmkid)
{
	HMAC_SHA256_CTX ctx;
	u_int8_t digest[SHA256_DIGEST_LENGTH];

	HMAC_SHA256_Init(&ctx, pmk, IEEE80211_PMK_LEN);
	HMAC_SHA256_Update(&ctx, "PMK Name", 8);
	HMAC_SHA256_Update(&ctx, aa, IEEE80211_ADDR_LEN);
	HMAC_SHA256_Update(&ctx, spa, IEEE80211_ADDR_LEN);
	HMAC_SHA256_Final(digest, &ctx);
	/* use the first 128 bits of HMAC-SHA-256 */
	memcpy(pmkid, digest, IEEE80211_PMKID_LEN);
}

/*
 * Derive Pairwise Master Key Identifier (PMKID) (see 8.5.1.2).
 */
void
ieee80211_derive_pmkid(enum ieee80211_akm akm, const u_int8_t *pmk,
    const u_int8_t *aa, const u_int8_t *spa, u_int8_t *pmkid)
{
	if (ieee80211_is_sha256_akm(akm))
		ieee80211_pmkid_sha256(pmk, aa, spa, pmkid);
	else
		ieee80211_pmkid_sha1(pmk, aa, spa, pmkid);
}

typedef union _ANY_CTX {
	HMAC_MD5_CTX	md5;
	HMAC_SHA1_CTX	sha1;
	AES_CMAC_CTX	cmac;
} ANY_CTX;

/*
 * Compute the Key MIC field of an EAPOL-Key frame using the specified Key
 * Confirmation Key (KCK).  The hash function can be HMAC-MD5, HMAC-SHA1
 * or AES-128-CMAC depending on the EAPOL-Key Key Descriptor Version.
 */
void
ieee80211_eapol_key_mic(struct ieee80211_eapol_key *key, const u_int8_t *kck)
{
	u_int8_t digest[SHA1_DIGEST_LENGTH];
	ANY_CTX ctx;	/* XXX off stack? */
	u_int len;

	len = BE_READ_2(key->len) + 4;

	switch (BE_READ_2(key->info) & EAPOL_KEY_VERSION_MASK) {
	case EAPOL_KEY_DESC_V1:
		HMAC_MD5_Init(&ctx.md5, kck, 16);
		HMAC_MD5_Update(&ctx.md5, (u_int8_t *)key, len);
		HMAC_MD5_Final(key->mic, &ctx.md5);
		break;
	case EAPOL_KEY_DESC_V2:
		HMAC_SHA1_Init(&ctx.sha1, kck, 16);
		HMAC_SHA1_Update(&ctx.sha1, (u_int8_t *)key, len);
		HMAC_SHA1_Final(digest, &ctx.sha1);
		/* truncate HMAC-SHA1 to its 128 MSBs */
		memcpy(key->mic, digest, EAPOL_KEY_MIC_LEN);
		break;
	case EAPOL_KEY_DESC_V3:
		AES_CMAC_Init(&ctx.cmac);
		AES_CMAC_SetKey(&ctx.cmac, kck);
		AES_CMAC_Update(&ctx.cmac, (u_int8_t *)key, len);
		AES_CMAC_Final(key->mic, &ctx.cmac);
		break;
	}
}

/*
 * Check the MIC of a received EAPOL-Key frame using the specified Key
 * Confirmation Key (KCK).
 */
int
ieee80211_eapol_key_check_mic(struct ieee80211_eapol_key *key,
    const u_int8_t *kck)
{
	u_int8_t mic[EAPOL_KEY_MIC_LEN];

	memcpy(mic, key->mic, EAPOL_KEY_MIC_LEN);
	memset(key->mic, 0, EAPOL_KEY_MIC_LEN);
	ieee80211_eapol_key_mic(key, kck);

	return timingsafe_bcmp(key->mic, mic, EAPOL_KEY_MIC_LEN) != 0;
}

#ifndef IEEE80211_STA_ONLY
/*
 * Encrypt the Key Data field of an EAPOL-Key frame using the specified Key
 * Encryption Key (KEK).  The encryption algorithm can be either ARC4 or
 * AES Key Wrap depending on the EAPOL-Key Key Descriptor Version.
 */
void
ieee80211_eapol_key_encrypt(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, const u_int8_t *kek)
{
	union {
		struct rc4_ctx rc4;
		aes_key_wrap_ctx aes;
	} ctx;	/* XXX off stack? */
	u_int8_t keybuf[EAPOL_KEY_IV_LEN + 16];
	u_int16_t len, info;
	u_int8_t *data;
	int n;

	len  = BE_READ_2(key->paylen);
	info = BE_READ_2(key->info);
	data = (u_int8_t *)(key + 1);

	switch (info & EAPOL_KEY_VERSION_MASK) {
	case EAPOL_KEY_DESC_V1:
		/* set IV to the lower 16 octets of our global key counter */
		memcpy(key->iv, ic->ic_globalcnt + 16, 16);
		/* increment our global key counter (256-bit, big-endian) */
		for (n = 31; n >= 0 && ++ic->ic_globalcnt[n] == 0; n--);

		/* concatenate the EAPOL-Key IV field and the KEK */
		memcpy(keybuf, key->iv, EAPOL_KEY_IV_LEN);
		memcpy(keybuf + EAPOL_KEY_IV_LEN, kek, 16);

		rc4_keysetup(&ctx.rc4, keybuf, sizeof keybuf);
		/* discard the first 256 octets of the ARC4 key stream */
		rc4_skip(&ctx.rc4, RC4STATE);
		rc4_crypt(&ctx.rc4, data, data, len);
		break;
	case EAPOL_KEY_DESC_V2:
	case EAPOL_KEY_DESC_V3:
		if (len < 16 || (len & 7) != 0) {
			/* insert padding */
			n = (len < 16) ? 16 - len : 8 - (len & 7);
			data[len++] = IEEE80211_ELEMID_VENDOR;
			memset(&data[len], 0, n - 1);
			len += n - 1;
		}
		aes_key_wrap_set_key_wrap_only(&ctx.aes, kek, 16);
		aes_key_wrap(&ctx.aes, data, len / 8, data);
		len += 8;	/* AES Key Wrap adds 8 bytes */
		/* update key data length */
		BE_WRITE_2(key->paylen, len);
		/* update packet body length */
		BE_WRITE_2(key->len, sizeof(*key) + len - 4);
		break;
	}
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Decrypt the Key Data field of an EAPOL-Key frame using the specified Key
 * Encryption Key (KEK).  The encryption algorithm can be either ARC4 or
 * AES Key Wrap depending on the EAPOL-Key Key Descriptor Version.
 */
int
ieee80211_eapol_key_decrypt(struct ieee80211_eapol_key *key,
    const u_int8_t *kek)
{
	union {
		struct rc4_ctx rc4;
		aes_key_wrap_ctx aes;
	} ctx;	/* XXX off stack? */
	u_int8_t keybuf[EAPOL_KEY_IV_LEN + 16];
	u_int16_t len, info;
	u_int8_t *data;

	len  = BE_READ_2(key->paylen);
	info = BE_READ_2(key->info);
	data = (u_int8_t *)(key + 1);

	switch (info & EAPOL_KEY_VERSION_MASK) {
	case EAPOL_KEY_DESC_V1:
		/* concatenate the EAPOL-Key IV field and the KEK */
		memcpy(keybuf, key->iv, EAPOL_KEY_IV_LEN);
		memcpy(keybuf + EAPOL_KEY_IV_LEN, kek, 16);

		rc4_keysetup(&ctx.rc4, keybuf, sizeof keybuf);
		/* discard the first 256 octets of the ARC4 key stream */
		rc4_skip(&ctx.rc4, RC4STATE);
		rc4_crypt(&ctx.rc4, data, data, len);
		return 0;
	case EAPOL_KEY_DESC_V2:
	case EAPOL_KEY_DESC_V3:
		/* Key Data Length must be a multiple of 8 */
		if (len < 16 + 8 || (len & 7) != 0)
			return 1;
		len -= 8;	/* AES Key Wrap adds 8 bytes */
		aes_key_wrap_set_key(&ctx.aes, kek, 16);
		return aes_key_unwrap(&ctx.aes, data, data, len / 8);
	}

	return 1;	/* unknown Key Descriptor Version */
}

/*
 * Add a PMK entry to the PMKSA cache.
 */
struct ieee80211_pmk *
ieee80211_pmksa_add(struct ieee80211com *ic, enum ieee80211_akm akm,
    const u_int8_t *macaddr, const u_int8_t *key, u_int32_t lifetime)
{
	struct ieee80211_pmk *pmk;

	/* check if an entry already exists for this (STA,AKMP) */
	TAILQ_FOREACH(pmk, &ic->ic_pmksa, pmk_next) {
		if (pmk->pmk_akm == akm &&
		    IEEE80211_ADDR_EQ(pmk->pmk_macaddr, macaddr))
			break;
	}
	if (pmk == NULL) {
		/* allocate a new PMKSA entry */
		if ((pmk = malloc(sizeof(*pmk), M_DEVBUF, M_NOWAIT)) == NULL)
			return NULL;
		pmk->pmk_akm = akm;
		IEEE80211_ADDR_COPY(pmk->pmk_macaddr, macaddr);
		TAILQ_INSERT_TAIL(&ic->ic_pmksa, pmk, pmk_next);
	}
	memcpy(pmk->pmk_key, key, IEEE80211_PMK_LEN);
	pmk->pmk_lifetime = lifetime;	/* XXX not used yet */
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		ieee80211_derive_pmkid(pmk->pmk_akm, pmk->pmk_key,
		    ic->ic_myaddr, macaddr, pmk->pmk_pmkid);
	} else
#endif
	{
		ieee80211_derive_pmkid(pmk->pmk_akm, pmk->pmk_key,
		    macaddr, ic->ic_myaddr, pmk->pmk_pmkid);
	}
	return pmk;
}

/*
 * Check if we have a cached PMK entry for the specified node and PMKID.
 */
struct ieee80211_pmk *
ieee80211_pmksa_find(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *pmkid)
{
	struct ieee80211_pmk *pmk;

	TAILQ_FOREACH(pmk, &ic->ic_pmksa, pmk_next) {
		if (pmk->pmk_akm == ni->ni_rsnakms &&
		    IEEE80211_ADDR_EQ(pmk->pmk_macaddr, ni->ni_macaddr) &&
		    (pmkid == NULL ||
		     memcmp(pmk->pmk_pmkid, pmkid, IEEE80211_PMKID_LEN) == 0))
			break;
	}
	return pmk;
}
@


1.68
log
@Disable TKIP (WPA1) by default.

It is time for this legacy of WEP to die (remember WEP?).
The 802.11-2012 standard says:
  The use of TKIP is deprecated. The TKIP algorithm is unsuitable for
  the purposes of this standard.

TKIP has numerous problems. One of which is that TKIP allows a denial of
service attack which can be triggered by any client. Report 2 Michael MIC
failures to a TKIP AP to trigger "TKIP countermeasures". The AP is now
required by the 802.11 standard to lock everyone out for at least 60 seconds.
The network will remain unusable for as long as such MIC failure reports
are sent twice per minute.

TKIP remains available for interoperability purposes, for now.
It must be enabled manually with ifconfig(8).

Prompted by discussion with Mathy Vanhoef.
ok deraadt@@ sthen@@ reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.67 2016/12/17 18:35:54 stsp Exp $	*/
d89 1
a89 1
		free(pmk, M_DEVBUF, 0);
@


1.67
log
@Complete our half-done implementation of TKIP countermeasures in hostap mode.

The previous code would disable the AP until next reboot upon MIC failure.
Instead, disable the AP for 60 seconds, as required by the 802.11 standard.
I randomly added a bit of time (up to 120 seconds total) just because we can.

Problem reported by Mathy Vanhoef, thanks!
ok deraadt@@
random input reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.66 2015/11/24 13:45:06 mpi Exp $	*/
d63 1
a63 1
		ic->ic_rsnprotos = IEEE80211_PROTO_WPA | IEEE80211_PROTO_RSN;
d65 2
a66 3
		ic->ic_rsnciphers = IEEE80211_CIPHER_TKIP |
		    IEEE80211_CIPHER_CCMP;
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_TKIP;
@


1.66
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.65 2014/12/23 03:24:08 tedu Exp $	*/
d72 4
d78 1
d103 4
@


1.65
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.64 2014/11/18 02:37:31 tedu Exp $	*/
a32 1
#include <net/if_arp.h>
@


1.64
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.63 2014/09/14 14:17:26 jsg Exp $	*/
a34 1
#ifdef INET
a36 1
#endif
@


1.63
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.62 2014/07/12 18:44:22 tedu Exp $	*/
a42 1
#include <dev/rndvar.h>
@


1.62
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.61 2013/11/21 16:16:08 mpi Exp $	*/
a27 1
#include <sys/proc.h>
@


1.61
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.60 2011/01/11 15:42:05 deraadt Exp $	*/
d90 1
a90 1
		free(pmk, M_DEVBUF);
@


1.60
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.59 2010/07/20 15:36:03 matthew Exp $	*/
a34 1
#include <net/if_llc.h>
@


1.59
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.58 2009/02/13 17:24:54 damien Exp $	*/
d90 1
a90 1
		memset(pmk, 0, sizeof(*pmk));
d99 1
a99 1
		memset(k, 0, sizeof(*k));
d103 1
a103 1
	memset(ic->ic_psk, 0, IEEE80211_PMK_LEN);
d177 1
a177 1
	memset(k, 0, sizeof(*k));
@


1.58
log
@Change ifconfig wpaakms default setting to `psk' instead of `psk,802.1x'.
Some supplicants will autoselect 802.1X without giving users the
possibility to choose between PSK or 802.1X.

Similarly, no longer announce `PSK with SHA-256 based KDF' AKMP (defined
in Draft 802.11w) by default in the RSN IE of beacons and probe responses
as it confuses some broken supplicants.  This kind of sacrifies security
for interoperability with shitty (but unfortunately widespread) clients
that do not follow the 802.11 standard properly.
This fixes associations from Intel PROSet on XP and also reportedly fixes
some Mac OS clients.  I will likely make `psk-sha256' configurable through
ifconfig wpaakms after the 4.5 release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.57 2009/01/26 19:09:41 damien Exp $	*/
d488 1
a488 1
	return memcmp(key->mic, mic, EAPOL_KEY_MIC_LEN) != 0;
@


1.57
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.56 2008/09/27 15:16:09 damien Exp $	*/
d70 1
a70 2
		ic->ic_rsnakms = IEEE80211_AKM_PSK | IEEE80211_AKM_SHA256_PSK |
		    IEEE80211_AKM_8021X | IEEE80211_AKM_SHA256_8021X;
@


1.56
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.55 2008/08/27 09:05:04 damien Exp $	*/
d75 1
a75 1
		ic->ic_rsngroupmgmtcipher = IEEE80211_CIPHER_AES128_CMAC;
d122 1
a122 1
	case IEEE80211_CIPHER_AES128_CMAC:
d146 1
a146 1
	case IEEE80211_CIPHER_AES128_CMAC:
d171 1
a171 1
	case IEEE80211_CIPHER_AES128_CMAC:
d216 1
a216 1
	case IEEE80211_CIPHER_AES128_CMAC:
d288 1
a288 1
	case IEEE80211_CIPHER_AES128_CMAC:
@


1.55
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.54 2008/08/14 16:14:53 damien Exp $	*/
a56 1
#ifdef notyet
d59 2
a60 3
void	ieee80211_derive_pmkid(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, u_int8_t *);
#endif
d67 1
d70 2
a71 1
		ic->ic_rsnakms = IEEE80211_AKM_PSK | IEEE80211_AKM_8021X;
d85 1
d88 8
a95 1
	/* clear all keys from memory */
d102 2
a180 18
/*
 * Retrieve the pairwise master key configured for a given node.
 * When PSK AKMP is in use, the pairwise master key is the pre-shared key
 * and the node is not used.
 */
const u_int8_t *
ieee80211_get_pmk(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *pmkid)
{
	if (ni->ni_rsnakms == IEEE80211_AKM_PSK ||
	    ni->ni_rsnakms == IEEE80211_AKM_SHA256_PSK)
		return ic->ic_psk;	/* the PMK is the PSK */

	/* XXX find the PMK in the PMKSA cache using the PMKID */

	return NULL;	/* not yet supported */
}

a330 1
#ifdef notyet
a358 1
#endif
d368 2
d383 2
a384 1
	ieee80211_prf(pmk, IEEE80211_PMK_LEN, "Pairwise key expansion", 23,
d388 2
a389 6
/*
 * Derive Pairwise Master Key Identifier (PMKID) (see 8.5.1.2).
 */
#ifdef notyet
void
ieee80211_derive_pmkid(const u_int8_t *pmk, size_t pmk_len, const u_int8_t *aa,
d395 1
a395 1
	HMAC_SHA1_Init(&ctx, pmk, pmk_len);
d400 17
a416 1
	/* use the first 128 bits of the HMAC-SHA1 */
d419 13
a431 1
#endif
d595 57
@


1.54
log
@ieee80211_derive_pmkid() is not used either
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.53 2008/08/14 16:10:01 damien Exp $	*/
d475 1
d533 1
@


1.53
log
@#ifdef notyet ieee80211_kdf() as it is not used yet (shrink kernel a bit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.52 2008/08/12 19:56:59 damien Exp $	*/
a59 1
#endif
d62 1
d398 1
d414 1
@


1.52
log
@add the code to encrypt/decrypt management frames, retrieve key id
from MMIE etc...
this code can't be triggered as no drivers claim MFP capability yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.51 2008/08/12 19:34:54 damien Exp $	*/
d57 1
d60 1
d339 1
d368 1
@


1.51
log
@missing SHA-256 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.50 2008/08/12 19:29:07 damien Exp $	*/
d191 14
a204 5
	if (!(ic->ic_flags & IEEE80211_F_RSNON) ||
	    IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ni->ni_rsncipher == IEEE80211_CIPHER_USEGROUP)
		return &ic->ic_nw_keys[ic->ic_wep_txkey];
	return &ni->ni_pairwise_key;
d222 3
d239 3
d243 1
a243 1
	/* select the key for decryption */
d245 3
a247 10
	if (!(ic->ic_flags & IEEE80211_F_RSNON) ||
	    IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ni->ni_rsncipher == IEEE80211_CIPHER_USEGROUP) {
		/* XXX check length! */
		int hdrlen = ieee80211_get_hdrlen(wh);
		const u_int8_t *ivp = (u_int8_t *)wh + hdrlen;
		/* key identifier is always located at the same index */
		int kid = ivp[IEEE80211_WEP_IVLEN] >> 6;
		k = &ic->ic_nw_keys[kid];
	} else
d250 33
d293 3
@


1.50
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.49 2008/08/12 18:48:35 damien Exp $	*/
d178 2
a179 1
	if (ni->ni_rsnakms == IEEE80211_AKM_PSK)
@


1.49
log
@add support for EAPOL-Key v3 descriptors (similar to v2 except that the
MIC is computed using AES-128-CMAC instead of HMAC-SHA1).
add a SHA-256 based key derivation function (not used yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.48 2008/08/12 18:41:18 damien Exp $	*/
d69 1
a69 1
		ic->ic_rsnakms = IEEE80211_AKM_PSK | IEEE80211_AKM_IEEE8021X;
@


1.48
log
@the only integrity group cipher currently supported is AES-128-CMAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.47 2008/08/12 18:01:41 damien Exp $	*/
d52 1
d57 2
d134 3
d159 3
d166 1
a166 1
	memset(k, 0, sizeof(*k));	/* XXX */
d290 32
d368 1
d373 2
a374 2
 * Confirmation Key (KCK).  The hash function can be either HMAC-MD5 or
 * HMAC-SHA1 depending on the EAPOL-Key Key Descriptor Version.
d398 6
d463 1
d515 1
@


1.47
log
@extend the ic_nw_keys[] array to 6 elements.
indices 0-3 will be used for group data keys while indices 4-5 will
be used for integrity group keys.
add a ic_rsngroupmgmtcipher field too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.46 2008/08/12 16:14:05 damien Exp $	*/
d70 1
d107 2
@


1.46
log
@get rid of the map_ptk()/map_gtk() functions, just inline them
which makes things easier to track.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.45 2008/08/12 16:05:15 damien Exp $	*/
d82 5
a86 4
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (ic->ic_nw_keys[i].k_cipher != IEEE80211_CIPHER_NONE)
			(*ic->ic_delete_key)(ic, NULL, &ic->ic_nw_keys[i]);
		memset(&ic->ic_nw_keys[i], 0, sizeof(struct ieee80211_key));
d91 20
a471 20
}

/*
 * Return the length in bytes of a cipher suite key (see Table 60).
 */
int
ieee80211_cipher_keylen(enum ieee80211_cipher cipher)
{
	switch (cipher) {
	case IEEE80211_CIPHER_WEP40:
		return 5;
	case IEEE80211_CIPHER_TKIP:
		return 32;
	case IEEE80211_CIPHER_CCMP:
		return 16;
	case IEEE80211_CIPHER_WEP104:
		return 13;
	default:	/* unknown cipher */
		return 0;
	}
@


1.45
log
@simplify ieee80211_derive_ptk() prototype.
pass the AKMP so we can support other key derivation functions in the
future.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.44 2008/08/12 15:59:40 damien Exp $	*/
a470 33
}

/*
 * Map PTK to IEEE 802.11 key (see 8.6).
 */
void
ieee80211_map_ptk(const struct ieee80211_ptk *ptk,
    enum ieee80211_cipher cipher, u_int64_t rsc, struct ieee80211_key *k)
{
	memset(k, 0, sizeof(*k));
	k->k_cipher = cipher;
	k->k_flags = IEEE80211_KEY_TX;
	k->k_len = ieee80211_cipher_keylen(cipher);
	k->k_rsc[0] = rsc;
	memcpy(k->k_key, ptk->tk, k->k_len);
}

/*
 * Map GTK to IEEE 802.11 key (see 8.6).
 */
void
ieee80211_map_gtk(const u_int8_t *gtk, enum ieee80211_cipher cipher, int kid,
    int txflag, u_int64_t rsc, struct ieee80211_key *k)
{
	memset(k, 0, sizeof(*k));
	k->k_id = kid;
	k->k_cipher = cipher;
	k->k_flags = IEEE80211_KEY_GROUP;
	if (txflag)
		k->k_flags |= IEEE80211_KEY_TX;
	k->k_len = ieee80211_cipher_keylen(cipher);
	k->k_rsc[0] = rsc;
	memcpy(k->k_key, gtk, k->k_len);
@


1.44
log
@use HMAC-MD5, HMAC-SHA1 and AES Key Wrap sys/crypto/
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.43 2008/07/21 19:27:26 damien Exp $	*/
d260 3
a262 3
ieee80211_derive_ptk(const u_int8_t *pmk, size_t pmk_len, const u_int8_t *aa,
    const u_int8_t *spa, const u_int8_t *anonce, const u_int8_t *snonce,
    u_int8_t *ptk, size_t ptk_len)
d277 2
a278 2
	ieee80211_prf(pmk, pmk_len, "Pairwise key expansion", 23,
	    buf, sizeof buf, ptk, ptk_len);
@


1.43
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.42 2008/06/16 18:32:04 damien Exp $	*/
d49 2
d52 1
d54 2
a55 8
/* similar to iovec except that it accepts const pointers */
struct vector {
	const void	*base;
	size_t		len;
};

void	ieee80211_prf(const u_int8_t *, size_t, struct vector *, int,
	    u_int8_t *, size_t);
a227 156
 * AES Key Wrap (see RFC 3394).
 */
static const u_int8_t aes_key_wrap_iv[8] =
	{ 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6 };

static void
aes_key_wrap(const u_int8_t *kek, size_t kek_len, const u_int8_t *pt,
    size_t len, u_int8_t *ct)
{
	rijndael_ctx ctx;
	u_int8_t *a, *r, ar[16];
	u_int64_t t, b[2];
	size_t i;
	int j;

	/* allow ciphertext and plaintext to overlap (ct == pt) */
	ovbcopy(pt, ct + 8, len * 8);
	a = ct;
	memcpy(a, aes_key_wrap_iv, 8);	/* default IV */

	rijndael_set_key_enc_only(&ctx, kek, kek_len * 8);

	for (j = 0, t = 1; j < 6; j++) {
		r = ct + 8;
		for (i = 0; i < len; i++, t++) {
			memcpy(ar, a, 8);
			memcpy(ar + 8, r, 8);
			rijndael_encrypt(&ctx, ar, (u_int8_t *)b);
			b[0] ^= htobe64(t);
			memcpy(a, &b[0], 8);
			memcpy(r, &b[1], 8);

			r += 8;
		}
	}
}

static int
aes_key_unwrap(const u_int8_t *kek, size_t kek_len, const u_int8_t *ct,
    u_int8_t *pt, size_t len)
{
	rijndael_ctx ctx;
	u_int8_t a[8], *r, b[16];
	u_int64_t t, ar[2];
	size_t i;
	int j;

	memcpy(a, ct, 8);
	/* allow ciphertext and plaintext to overlap (ct == pt) */
	ovbcopy(ct + 8, pt, len * 8);

	rijndael_set_key(&ctx, kek, kek_len * 8);

	for (j = 0, t = 6 * len; j < 6; j++) {
		r = pt + (len - 1) * 8;
		for (i = 0; i < len; i++, t--) {
			memcpy(&ar[0], a, 8);
			ar[0] ^= htobe64(t);
			memcpy(&ar[1], r, 8);
			rijndael_decrypt(&ctx, (u_int8_t *)ar, b);
			memcpy(a, b, 8);
			memcpy(r, b + 8, 8);

			r -= 8;
		}
	}
	return memcmp(a, aes_key_wrap_iv, 8) != 0;
}

/*
 * HMAC-MD5 (see RFC 2104).
 */
static void
hmac_md5(const struct vector *vec, int vcnt, const u_int8_t *key,
    size_t key_len, u_int8_t digest[MD5_DIGEST_LENGTH])
{
	MD5_CTX ctx;
	u_int8_t k_pad[MD5_BLOCK_LENGTH];
	u_int8_t tk[MD5_DIGEST_LENGTH];
	int i;

	if (key_len > MD5_BLOCK_LENGTH) {
		MD5Init(&ctx);
		MD5Update(&ctx, key, key_len);
		MD5Final(tk, &ctx);

		key = tk;
		key_len = MD5_DIGEST_LENGTH;
	}

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < MD5_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x36;

	MD5Init(&ctx);
	MD5Update(&ctx, k_pad, MD5_BLOCK_LENGTH);
	for (i = 0; i < vcnt; i++)
		MD5Update(&ctx, vec[i].base, vec[i].len);
	MD5Final(digest, &ctx);

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < MD5_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x5c;

	MD5Init(&ctx);
	MD5Update(&ctx, k_pad, MD5_BLOCK_LENGTH);
	MD5Update(&ctx, digest, MD5_DIGEST_LENGTH);
	MD5Final(digest, &ctx);
}

/*
 * HMAC-SHA1 (see RFC 2104).
 */
static void
hmac_sha1(const struct vector *vec, int vcnt, const u_int8_t *key,
    size_t key_len, u_int8_t digest[SHA1_DIGEST_LENGTH])
{
	SHA1_CTX ctx;
	u_int8_t k_pad[SHA1_BLOCK_LENGTH];
	u_int8_t tk[SHA1_DIGEST_LENGTH];
	int i;

	if (key_len > SHA1_BLOCK_LENGTH) {
		SHA1Init(&ctx);
		SHA1Update(&ctx, key, key_len);
		SHA1Final(tk, &ctx);

		key = tk;
		key_len = SHA1_DIGEST_LENGTH;
	}

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < SHA1_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x36;

	SHA1Init(&ctx);
	SHA1Update(&ctx, k_pad, SHA1_BLOCK_LENGTH);
	for (i = 0; i < vcnt; i++)
		SHA1Update(&ctx, vec[i].base, vec[i].len);
	SHA1Final(digest, &ctx);

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < SHA1_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x5c;

	SHA1Init(&ctx);
	SHA1Update(&ctx, k_pad, SHA1_BLOCK_LENGTH);
	SHA1Update(&ctx, digest, SHA1_DIGEST_LENGTH);
	SHA1Final(digest, &ctx);
}

/*
d231 20
a250 15
ieee80211_prf(const u_int8_t *key, size_t key_len, struct vector *vec,
    int vcnt, u_int8_t *output, size_t len)
{
	u_int8_t hash[SHA1_DIGEST_LENGTH];
	u_int8_t count = 0;

	/* single octet count, starts at 0 */
	vec[vcnt].base = &count;
	vec[vcnt].len  = 1;
	vcnt++;

	while (len >= SHA1_DIGEST_LENGTH) {
		hmac_sha1(vec, vcnt, key, key_len, output);
		count++;

a253 5
	if (len > 0) {
		hmac_sha1(vec, vcnt, key, key_len, hash);
		/* truncate HMAC-SHA1 to len bytes */
		memcpy(output, hash, len);
	}
d264 1
a264 1
	struct vector vec[6];	/* +1 for PRF */
d267 1
a267 3
	vec[0].base = "Pairwise key expansion";
	vec[0].len  = 23;	/* include trailing '\0' */

d269 2
a270 6
	/* Min(AA,SPA) */
	vec[1].base = ret ? aa : spa;
	vec[1].len  = IEEE80211_ADDR_LEN;
	/* Max(AA,SPA) */
	vec[2].base = ret ? spa : aa;
	vec[2].len  = IEEE80211_ADDR_LEN;
d272 1
d274 2
a275 6
	/* Min(ANonce,SNonce) */
	vec[3].base = ret ? anonce : snonce;
	vec[3].len  = EAPOL_KEY_NONCE_LEN;
	/* Max(ANonce,SNonce) */
	vec[4].base = ret ? snonce : anonce;
	vec[4].len  = EAPOL_KEY_NONCE_LEN;
d277 2
a278 1
	ieee80211_prf(pmk, pmk_len, vec, 5, ptk, ptk_len);
d288 2
a289 2
	struct vector vec[3];
	u_int8_t hash[SHA1_DIGEST_LENGTH];
d291 5
a295 8
	vec[0].base = "PMK Name";
	vec[0].len  = 8;	/* does *not* include trailing '\0' */
	vec[1].base = aa;
	vec[1].len  = IEEE80211_ADDR_LEN;
	vec[2].base = spa;
	vec[2].len  = IEEE80211_ADDR_LEN;

	hmac_sha1(vec, 3, pmk, pmk_len, hash);
d297 1
a297 1
	memcpy(pmkid, hash, IEEE80211_PMKID_LEN);
d300 5
d313 3
a315 2
	u_int8_t hash[SHA1_DIGEST_LENGTH];
	struct vector vec;
d317 1
a317 2
	vec.base = key;
	vec.len  = BE_READ_2(key->len) + 4;
d321 3
a323 1
		hmac_md5(&vec, 1, kck, 16, key->mic);
d326 3
a328 1
		hmac_sha1(&vec, 1, kck, 16, hash);
d330 1
a330 1
		memcpy(key->mic, hash, EAPOL_KEY_MIC_LEN);
d361 4
a364 1
	struct rc4_ctx ctx;
d385 1
a385 1
		rc4_keysetup(&ctx, keybuf, sizeof keybuf);
d387 2
a388 2
		rc4_skip(&ctx, RC4STATE);
		rc4_crypt(&ctx, data, data, len);
d398 2
a399 1
		aes_key_wrap(kek, 16, data, len / 8, data);
d418 4
a421 1
	struct rc4_ctx ctx;
d436 1
a436 1
		rc4_keysetup(&ctx, keybuf, sizeof keybuf);
d438 2
a439 2
		rc4_skip(&ctx, RC4STATE);
		rc4_crypt(&ctx, data, data, len);
d446 2
a447 1
		return aes_key_unwrap(kek, 16, data, data, len / 8);
@


1.42
log
@remove now useless casts since the rijndael_* protos have been
constified.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.41 2008/04/26 20:03:34 damien Exp $	*/
d43 1
a468 11

/* unaligned big endian access */
#define BE_READ_2(p)				\
	((u_int16_t)				\
         ((((const u_int8_t *)(p))[0] << 8) |	\
          (((const u_int8_t *)(p))[1])))

#define BE_WRITE_2(p, v) do {			\
	((u_int8_t *)(p))[0] = (v) >> 8;	\
	((u_int8_t *)(p))[1] = (v) & 0xff;	\
} while (0)
@


1.41
log
@move things from ieee80211_ifattach() to ieee80211_crypto_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.40 2008/04/21 19:01:01 damien Exp $	*/
d250 1
a250 1
	rijndael_set_key_enc_only(&ctx, (u_int8_t *)kek, kek_len * 8);
d281 1
a281 1
	rijndael_set_key(&ctx, (u_int8_t *)kek, kek_len * 8);
@


1.40
log
@- do not process ethernet PAE frames if RSN is not enabled
- add a ieee80211_recv_action() function (will be used later)
- some cleanup, remove unused prototypes, get rid of the
  IEEE80211_VERIFY_* macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.39 2008/04/18 09:16:14 djm Exp $	*/
d64 11
@


1.39
log
@extend the if_ethersubr.c crc functions to support updating a running
crc in addition to the existing "oneshot" mode and use them to replace
ieee80211_crc_update() with the new ether_crc32_le_update(). Saves 1k
kernel bss + some code.

Mark the new ether_crc32_[lb]e_update functions as __pure for a
~25x speedup (on my i386 at least).

feedback and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.38 2008/04/17 18:05:33 damien Exp $	*/
a59 2
void	ieee80211_derive_gtk(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, u_int8_t *, size_t);
@


1.38
log
@call ieee80211_crc_init() only once, when the first 802.11 device
attaches instead of at every attach.

discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.37 2008/04/16 18:32:15 damien Exp $	*/
a55 1
void	ieee80211_crc_init(void);
a65 1
	ieee80211_crc_init();
a217 47
}

/*
 * CRC (Cyclic Redundancy Check) (routine from RFC 2083).
 */

/* Table of CRCs of all 8-bit messages. */
static u_int32_t ieee80211_crc_table[256];

/* Make the table for a fast CRC. */
void
ieee80211_crc_init(void)
{
	/* Flag: has the table been computed? Initially false. */
	static int crc_table_computed = 0;
	u_int32_t c;
	int n, k;

	if (crc_table_computed)
		return;

	for (n = 0; n < 256; n++) {
		c = (u_int32_t)n;
		for (k = 0; k < 8; k++) {
			if (c & 1)
				c = 0xedb88320UL ^ (c >> 1);
			else
				c = c >> 1;
		}
		ieee80211_crc_table[n] = c;
	}
	crc_table_computed = 1;
}

/*
 * Update a running CRC with the bytes buf[0..len-1]--the CRC
 * should be initialized to all 1's, and the transmitted value
 * is the 1's complement of the final running CRC.
 */
u_int32_t
ieee80211_crc_update(u_int32_t crc, const u_int8_t *buf, int len)
{
	const u_int8_t *endbuf;

	for (endbuf = buf + len; buf < endbuf; buf++)
		crc = ieee80211_crc_table[(crc ^ *buf) & 0xff] ^ (crc >> 8);
	return crc;
@


1.37
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
a67 1
	ieee80211_crc_init();	/* XXX only once? */
d223 1
a223 1
 * CRC 32 -- routine from RFC 2083
d226 1
a226 1
/* Table of CRCs of all 8-bit messages */
d233 2
d238 3
d251 1
d257 1
a257 1
 * is the 1's complement of the final running CRC
@


1.36
log
@remove horrid casts now that SHA1Update() has been constified.
@
text
@d1 1
a1 2
/*	$OpenBSD: ieee80211_crypto.c,v 1.35 2007/08/29 19:54:46 damien Exp $	*/
/*	$NetBSD: ieee80211_crypto.c,v 1.5 2003/12/14 09:56:53 dyoung Exp $	*/
d4 1
a4 4
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * Copyright (c) 2007 Damien Bergamini
 * All rights reserved.
d6 3
a8 10
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
d10 7
a16 10
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a18 2
#include "bpfilter.h"

a36 4
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

d50 1
a56 21
u_int32_t ieee80211_crc_update(u_int32_t, const u_int8_t *, int);
struct mbuf *ieee80211_ccmp_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct mbuf *ieee80211_ccmp_decrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct mbuf *ieee80211_tkip_encrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
struct mbuf *ieee80211_tkip_decrypt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_key *);
void	ieee80211_aes_key_wrap(const u_int8_t *, size_t, const u_int8_t *,
	    size_t, u_int8_t *);
int	ieee80211_aes_key_unwrap(const u_int8_t *, size_t, const u_int8_t *,
	    u_int8_t *, size_t);
void	ieee80211_hmac_md5_v(const struct vector *, int, const u_int8_t *,
	    size_t, u_int8_t digest[]);
void	ieee80211_hmac_md5(const u_int8_t *, size_t, const u_int8_t *, size_t,
	    u_int8_t digest[]);
void	ieee80211_hmac_sha1_v(const struct vector *, int, const u_int8_t *,
	    size_t, u_int8_t digest[]);
void	ieee80211_hmac_sha1(const u_int8_t *, size_t, const u_int8_t *, size_t,
	    u_int8_t digest[]);
d67 6
d74 10
d85 5
a89 1
	ieee80211_crc_init();
d91 16
a106 2
	/* initialize 256-bit global key counter to a random value */
	get_random_bytes(ic->ic_globalcnt, EAPOL_KEY_NONCE_LEN);
d110 29
a138 1
ieee80211_crypto_detach(struct ifnet *ifp)
d140 4
a143 1
	struct ieee80211com *ic = (void *)ifp;
d145 1
a145 4
	if (ic->ic_wep_ctx != NULL) {
		free(ic->ic_wep_ctx, M_DEVBUF);
		ic->ic_wep_ctx = NULL;
	}
d152 3
a154 2
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ni->ni_pairwise_cipher == IEEE80211_CIPHER_USEGROUP)
d166 1
a166 1
		m0 = ieee80211_wep_crypt(&ic->ic_if, m0, 1);
d191 4
a194 2
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ni->ni_pairwise_cipher == IEEE80211_CIPHER_USEGROUP) {
d196 1
a196 1
		u_int8_t *ivp = (u_int8_t *)wh + hdrlen;
d206 1
a206 1
		m0 = ieee80211_wep_crypt(&ic->ic_if, m0, 0);
d215 1
a215 1
		/* should not get there */
a221 355
struct mbuf *
ieee80211_ccmp_encrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	u_int8_t *ivp;
	int hdrlen;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	M_PREPEND(m0, IEEE80211_CCMP_HDRLEN, M_NOWAIT);
	if (m0 == NULL)
		return m0;
	wh = mtod(m0, struct ieee80211_frame *);
	ovbcopy(mtod(m0, u_int8_t *) + IEEE80211_CCMP_HDRLEN, wh, hdrlen);
	ivp = (u_int8_t *)wh + hdrlen;

	k->k_tsc++;	/* increment the 48-bit PN */
	ivp[0] = k->k_tsc;		/* PN0 */
	ivp[1] = k->k_tsc >> 8;		/* PN1 */
	ivp[2] = 0;			/* Rsvd */
	ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;	/* KeyID | ExtIV */
	ivp[4] = k->k_tsc >> 16;	/* PN2 */
	ivp[5] = k->k_tsc >> 24;	/* PN3 */
	ivp[6] = k->k_tsc >> 32;	/* PN4 */
	ivp[7] = k->k_tsc >> 40;	/* PN5 */

	/* XXX encrypt payload if HW encryption not supported */

	return m0;
}

struct mbuf *
ieee80211_ccmp_decrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	u_int64_t pn;
	u_int8_t *ivp;
	int hdrlen;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (u_int8_t *)wh + hdrlen;

	/* check that ExtIV bit is be set */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV)) {
		m_freem(m0);
		return NULL;
	}
	/* extract the 48-bit PN from the CCMP header */
	pn = (u_int64_t)ivp[0]       |
	     (u_int64_t)ivp[1] <<  8 |
	     (u_int64_t)ivp[4] << 16 |
	     (u_int64_t)ivp[5] << 24 |
	     (u_int64_t)ivp[6] << 32 |
	     (u_int64_t)ivp[7] << 40;
	/* NB: the keys are refreshed, we'll never overflow the 48 bits */
	if (pn <= k->k_rsc) {
		/* replayed frame, discard */
		/* XXX statistics */
		m_freem(m0);
		return NULL;
	}

	/* XXX decrypt payload if HW encryption not supported */

	ovbcopy(mtod(m0, u_int8_t *),
	    mtod(m0, u_int8_t *) + IEEE80211_CCMP_HDRLEN, hdrlen);
	m_adj(m0, IEEE80211_CCMP_HDRLEN);
	m_adj(m0, -IEEE80211_CCMP_MICLEN);

	/* update last seen packet number */
	k->k_rsc = pn;

	return m0;
}

struct mbuf *
ieee80211_tkip_encrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	u_int8_t *ivp;
	int hdrlen;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	M_PREPEND(m0, IEEE80211_TKIP_HDRLEN, M_NOWAIT);
	if (m0 == NULL)
		return m0;
	wh = mtod(m0, struct ieee80211_frame *);
	ovbcopy(mtod(m0, u_int8_t *) + IEEE80211_TKIP_HDRLEN, wh, hdrlen);
	ivp = (u_int8_t *)wh + hdrlen;

	ivp[0] = k->k_tsc >> 8;		/* TSC1 */
	/* WEP Seed = (TSC1 | 0x20) & 0x7f (see 8.3.2.2) */
	ivp[1] = (ivp[0] | 0x20) & 0x7f;
	ivp[2] = k->k_tsc;		/* TSC0 */
	ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;	/* KeyID | ExtIV */
	ivp[4] = k->k_tsc >> 16;	/* TSC2 */
	ivp[5] = k->k_tsc >> 24;	/* TSC3 */
	ivp[6] = k->k_tsc >> 32;	/* TSC4 */
	ivp[7] = k->k_tsc >> 40;	/* TSC5 */

	/* XXX encrypt payload if HW encryption not supported */

	k->k_tsc++;	/* increment the 48-bit TSC */

	return m0;
}

struct mbuf *
ieee80211_tkip_decrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_frame *wh;
	u_int64_t tsc;
	u_int8_t *ivp;
	int hdrlen;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (u_int8_t *)wh + hdrlen;

	/* check that ExtIV bit is be set */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV)) {
		m_freem(m0);
		return NULL;
	}
	/* extract the 48-bit TSC from the TKIP header */
	tsc = (u_int64_t)ivp[2]       |
	      (u_int64_t)ivp[0] <<  8 |
	      (u_int64_t)ivp[4] << 16 |
	      (u_int64_t)ivp[5] << 24 |
	      (u_int64_t)ivp[6] << 32 |
	      (u_int64_t)ivp[7] << 40;
	/* NB: the keys are refreshed, we'll never overflow the 48 bits */
	if (tsc <= k->k_rsc) {
		/* replayed frame, discard */
		/* XXX statistics */
		m_freem(m0);
		return NULL;
	}

	/* XXX decrypt payload if HW encryption not supported */

	ovbcopy(mtod(m0, u_int8_t *),
	    mtod(m0, u_int8_t *) + IEEE80211_TKIP_HDRLEN, hdrlen);
	m_adj(m0, IEEE80211_TKIP_HDRLEN);
	m_adj(m0, -IEEE80211_TKIP_ICVLEN);

	/* update last seen packet number */
	k->k_rsc = tsc;

	return m0;
}

/* Round up to a multiple of IEEE80211_WEP_KEYLEN + IEEE80211_WEP_IVLEN */
#define klen_round(x)							\
	(((x) + (IEEE80211_WEP_KEYLEN + IEEE80211_WEP_IVLEN - 1)) &	\
	~(IEEE80211_WEP_KEYLEN + IEEE80211_WEP_IVLEN - 1))

struct mbuf *
ieee80211_wep_crypt(struct ifnet *ifp, struct mbuf *m0, int txflag)
{
	struct ieee80211com *ic = (void *)ifp;
	struct mbuf *m, *n, *n0;
	struct ieee80211_frame *wh;
	int i, left, len, moff, noff, kid;
	u_int32_t iv, crc;
	u_int8_t *ivp;
	void *ctx;
	u_int8_t keybuf[klen_round(IEEE80211_WEP_IVLEN + IEEE80211_KEYBUF_SIZE)];
	u_int8_t crcbuf[IEEE80211_WEP_CRCLEN];

	n0 = NULL;
	if ((ctx = ic->ic_wep_ctx) == NULL) {
		ctx = malloc(sizeof(struct rc4_ctx), M_DEVBUF, M_NOWAIT);
		if (ctx == NULL) {
			ic->ic_stats.is_crypto_nomem++;
			goto fail;
		}
		ic->ic_wep_ctx = ctx;
	}
	m = m0;
	left = m->m_pkthdr.len;
	MGET(n, M_DONTWAIT, m->m_type);
	n0 = n;
	if (n == NULL) {
		if (txflag)
			ic->ic_stats.is_tx_nombuf++;
		else
			ic->ic_stats.is_rx_nombuf++;
		goto fail;
	}
	M_DUP_PKTHDR(n, m);
	len = IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN + IEEE80211_WEP_CRCLEN;
	if (txflag) {
		n->m_pkthdr.len += len;
	} else {
		n->m_pkthdr.len -= len;
		left -= len;
	}
	n->m_len = MHLEN;
	if (n->m_pkthdr.len >= MINCLSIZE) {
		MCLGET(n, M_DONTWAIT);
		if (n->m_flags & M_EXT)
			n->m_len = n->m_ext.ext_size;
	}
	wh = mtod(m, struct ieee80211_frame *);
	len = ieee80211_get_hdrlen(wh);
	memcpy(mtod(n, caddr_t), wh, len);
	wh = mtod(n, struct ieee80211_frame *);
	left -= len;
	moff = len;
	noff = len;
	if (txflag) {
		kid = ic->ic_wep_txkey;
		wh->i_fc[1] |= IEEE80211_FC1_WEP;
		iv = ic->ic_iv ? ic->ic_iv : arc4random();
		/*
		 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir:
		 * (B, 255, N) with 3 <= B < 8
		 */
		if (iv >= 0x03ff00 &&
		    (iv & 0xf8ff00) == 0x00ff00)
			iv += 0x000100;
		ic->ic_iv = iv + 1;
		/* put iv in little endian to prepare 802.11i */
		ivp = mtod(n, u_int8_t *) + noff;
		for (i = 0; i < IEEE80211_WEP_IVLEN; i++) {
			ivp[i] = iv & 0xff;
			iv >>= 8;
		}
		ivp[IEEE80211_WEP_IVLEN] = kid << 6;	/* pad and keyid */
		noff += IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN;
	} else {
		wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
		ivp = mtod(m, u_int8_t *) + moff;
		kid = ivp[IEEE80211_WEP_IVLEN] >> 6;
		moff += IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN;
	}

	/*
	 * Copy the IV and the key material.  The input key has been padded
	 * with zeros by the ioctl.  The output key buffer length is rounded
	 * to a multiple of 64bit to allow variable length keys padded by
	 * zeros.
	 */
	bzero(&keybuf, sizeof(keybuf));
	memcpy(keybuf, ivp, IEEE80211_WEP_IVLEN);
	memcpy(keybuf + IEEE80211_WEP_IVLEN, ic->ic_nw_keys[kid].k_key,
	    ic->ic_nw_keys[kid].k_len);
	len = klen_round(IEEE80211_WEP_IVLEN + ic->ic_nw_keys[kid].k_len);
	rc4_keysetup(ctx, keybuf, len);

	/* encrypt with calculating CRC */
	crc = ~0;
	while (left > 0) {
		len = m->m_len - moff;
		if (len == 0) {
			m = m->m_next;
			moff = 0;
			continue;
		}
		if (len > n->m_len - noff) {
			len = n->m_len - noff;
			if (len == 0) {
				MGET(n->m_next, M_DONTWAIT, n->m_type);
				if (n->m_next == NULL) {
					if (txflag)
						ic->ic_stats.is_tx_nombuf++;
					else
						ic->ic_stats.is_rx_nombuf++;
					goto fail;
				}
				n = n->m_next;
				n->m_len = MLEN;
				if (left >= MINCLSIZE) {
					MCLGET(n, M_DONTWAIT);
					if (n->m_flags & M_EXT)
						n->m_len = n->m_ext.ext_size;
				}
				noff = 0;
				continue;
			}
		}
		if (len > left)
			len = left;
		rc4_crypt(ctx, mtod(m, caddr_t) + moff,
		    mtod(n, caddr_t) + noff, len);
		if (txflag)
			crc = ieee80211_crc_update(crc,
			    mtod(m, u_int8_t *) + moff, len);
		else
			crc = ieee80211_crc_update(crc,
			    mtod(n, u_int8_t *) + noff, len);
		left -= len;
		moff += len;
		noff += len;
	}
	crc = ~crc;
	if (txflag) {
		*(u_int32_t *)crcbuf = htole32(crc);
		if (n->m_len >= noff + sizeof(crcbuf))
			n->m_len = noff + sizeof(crcbuf);
		else {
			n->m_len = noff;
			MGET(n->m_next, M_DONTWAIT, n->m_type);
			if (n->m_next == NULL) {
				ic->ic_stats.is_tx_nombuf++;
				goto fail;
			}
			n = n->m_next;
			n->m_len = sizeof(crcbuf);
			noff = 0;
		}
		rc4_crypt(ctx, crcbuf, mtod(n, caddr_t) + noff,
		    sizeof(crcbuf));
	} else {
		n->m_len = noff;
		for (noff = 0; noff < sizeof(crcbuf); noff += len) {
			len = sizeof(crcbuf) - noff;
			if (len > m->m_len - moff)
				len = m->m_len - moff;
			if (len > 0)
				rc4_crypt(ctx, mtod(m, caddr_t) + moff,
				    crcbuf + noff, len);
			m = m->m_next;
			moff = 0;
		}
		if (crc != letoh32(*(u_int32_t *)crcbuf)) {
#ifdef IEEE80211_DEBUG
			if (ieee80211_debug) {
				printf("%s: decrypt CRC error\n",
				    ifp->if_xname);
				if (ieee80211_debug > 1)
					ieee80211_dump_pkt(n0->m_data,
					    n0->m_len, -1, -1);
			}
#endif
			ic->ic_stats.is_rx_decryptcrc++;
			goto fail;
		}
	}
	m_freem(m0);
	return n0;

 fail:
	m_freem(m0);
	m_freem(n0);
	return NULL;
}

d264 1
a264 1
 * AES Key Wrap Algorithm (see RFC 3394).
d269 2
a270 2
void
ieee80211_aes_key_wrap(const u_int8_t *kek, size_t kek_len, const u_int8_t *pt,
d301 3
a303 3
int
ieee80211_aes_key_unwrap(const u_int8_t *kek, size_t kek_len,
    const u_int8_t *ct, u_int8_t *pt, size_t len)
d333 5
a337 2
void
ieee80211_hmac_md5_v(const struct vector *vec, int vcnt, const u_int8_t *key,
d347 1
a347 1
		MD5Update(&ctx, (u_int8_t *)key, key_len);
d362 1
a362 1
		MD5Update(&ctx, (u_int8_t *)vec[i].base, vec[i].len);
d376 5
a380 12
void
ieee80211_hmac_md5(const u_int8_t *text, size_t text_len, const u_int8_t *key,
    size_t key_len, u_int8_t digest[MD5_DIGEST_LENGTH])
{
	struct vector vec;
	vec.base = text;
	vec.len  = text_len;
	ieee80211_hmac_md5_v(&vec, 1, key, key_len, digest);
}

void
ieee80211_hmac_sha1_v(const struct vector *vec, int vcnt, const u_int8_t *key,
a418 10
void
ieee80211_hmac_sha1(const u_int8_t *text, size_t text_len, const u_int8_t *key,
    size_t key_len, u_int8_t digest[SHA1_DIGEST_LENGTH])
{
	struct vector vec;
	vec.base = text;
	vec.len  = text_len;
	ieee80211_hmac_sha1_v(&vec, 1, key, key_len, digest);
}

d434 2
a435 2
	while (len > SHA1_DIGEST_LENGTH) {
		ieee80211_hmac_sha1_v(vec, vcnt, key, key_len, output);
d442 1
a442 1
		ieee80211_hmac_sha1_v(vec, vcnt, key, key_len, hash);
d498 1
a498 1
	ieee80211_hmac_sha1_v(vec, 3, pmk, pmk_len, hash);
a502 19
/*
 * Derive Group Temporal Key (GTK) (see 8.5.1.3).
 */
void
ieee80211_derive_gtk(const u_int8_t *gmk, size_t gmk_len, const u_int8_t *aa,
    const u_int8_t *gnonce, u_int8_t *gtk, size_t gtk_len)
{
	struct vector vec[4];	/* +1 for PRF */

	vec[0].base = "Group key expansion";
	vec[0].len  = 20;	/* include trailing '\0' */
	vec[1].base = aa;
	vec[1].len  = IEEE80211_ADDR_LEN;
	vec[2].base = gnonce;
	vec[2].len  = EAPOL_KEY_NONCE_LEN;

	ieee80211_prf(gmk, gmk_len, vec, 3, gtk, gtk_len);
}

d523 1
a523 1
	u_int16_t len, info;
d525 2
a526 2
	len  = BE_READ_2(key->len) + 4;
	info = BE_READ_2(key->info);
d528 1
a528 1
	switch (info & EAPOL_KEY_VERSION_MASK) {
d530 1
a530 1
		ieee80211_hmac_md5((u_int8_t *)key, len, kck, 16, key->mic);
d533 1
a533 1
		ieee80211_hmac_sha1((u_int8_t *)key, len, kck, 16, hash);
d600 1
a600 1
		ieee80211_aes_key_wrap(kek, 16, data, len / 8, data);
d644 1
a644 1
		return ieee80211_aes_key_unwrap(kek, 16, data, data, len / 8);
d675 1
a675 1
    enum ieee80211_cipher cipher, struct ieee80211_key *k)
d681 2
a682 8
	if (cipher == IEEE80211_CIPHER_TKIP) {
		memcpy(k->k_key, ptk->tk, 16);
		/* use bits 128-191 as the Michael key for AA->SPA */
		memcpy(k->k_rxmic, &ptk->tk[16], 8);
		/* use bits 192-255 as the Michael key for SPA->AA */
		memcpy(k->k_txmic, &ptk->tk[24], 8);
	} else
		memcpy(k->k_key, ptk->tk, k->k_len);
d699 2
a700 9
	k->k_rsc = rsc;
	if (cipher == IEEE80211_CIPHER_TKIP) {
		memcpy(k->k_key, gtk, 16);
		/* use bits 128-191 as the Michael key for AA->SPA */
		memcpy(k->k_rxmic, &gtk[16], 8);
		/* use bits 192-255 as the Michael key for SPA->AA */
		memcpy(k->k_txmic, &gtk[24], 8);
	} else
		memcpy(k->k_key, gtk, k->k_len);
@


1.35
log
@- use ieee80211_get_hdrlen() where appropriate.
- discard all EAPOL-Key frames with an unknown descriptor version.
- when receiving message 3/4 of the 4-way handshake, do not install
  the PTK if the INSTALL bit is not set. this fixes 4-way handshake
  with APs using group keys only.
- similarly, do not mark the 802.1X port as valid if the SECURE bit
  is not set (it will be marked as valid after group key handshake).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.34 2007/08/23 16:49:57 damien Exp $	*/
d724 1
a724 1
		SHA1Update(&ctx, (u_int8_t *)key, key_len);
d739 1
a739 1
		SHA1Update(&ctx, (u_int8_t *)vec[i].base, vec[i].len);
@


1.34
log
@fix ieee80211_map_ptk() for TKIP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.33 2007/08/22 20:52:26 damien Exp $	*/
d170 1
a170 1
		size_t hdrlen = sizeof(*wh);	/* XXX QoS */
a201 1
	size_t hdrlen = sizeof(*wh);	/* XXX QoS */
d203 1
d205 2
a233 1
	size_t hdrlen = sizeof(*wh);	/* XXX QoS */
d236 1
d239 1
a279 1
	size_t hdrlen = sizeof(*wh);	/* XXX QoS */
d281 1
d283 2
a313 1
	size_t hdrlen = sizeof(*wh);	/* XXX QoS */
d316 1
d319 1
d408 1
a408 6
	if ((wh->i_fc[0] &
	     (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
		len = sizeof(struct ieee80211_qosframe);
	else
		len = sizeof(struct ieee80211_frame);
@


1.33
log
@add a ieee80211_get_txkey() function to determine the key to use for
transmitting a frame to a given node.
change ieee80211_encrypt() so that it now takes the key as parameter.
this change is required because drivers doing hardware crypto need to
know what key is being used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.32 2007/08/22 20:40:34 damien Exp $	*/
d1048 1
a1048 1
		memcpy(k->k_rxmic, &ptk->tk[24], 8);
@


1.32
log
@- add k_rxmic and k_txmic fields to struct ieee80211_key to store the
  Tx/Rx MIC for TKIP.
- add two functions to map a PTK and a GTK to an IEEE 802.11 key and
  use them in ieee80211_input.c instead of duplicating the same code.
  properly set Tx/Rx MIC in the IEEE 802.11 key in the case of TKIP.
- add ic_psk to struct ieee80211com to store the pre-shared key.
- fix setting of the SECURE bit in outgoing EAPOL-Key frames.
- when receiving msg 2 of the 4-way handshake, deauthenticate the
  station if the RSN IE does not match that of the (Re)Association
  request.
- before parsing an RSN or WPA IE, check that there's enough room for
  the version field (2 bytes) which is mandatory.
- various tweaks while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.31 2007/08/03 16:51:06 damien Exp $	*/
d126 2
a127 2
struct mbuf *
ieee80211_encrypt(struct ieee80211com *ic, struct mbuf *m0,
a129 5
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;

	/* select the key for encryption */
	wh = mtod(m0, struct ieee80211_frame *);
d132 3
a134 3
		k = &ic->ic_nw_keys[ic->ic_wep_txkey];
	else
		k = &ni->ni_pairwise_key;
d136 4
@


1.31
log
@add a ni_eapol_desc field to struct ieee80211_node to know whether
a station is using WPA1 or RSN descriptors.
make sure that a station that advertises WPA1 capability in an IE
uses the WPA1 EAPOL-Key descriptor type and not the RSN one.
fix construction of EAPOL-Key frames for WPA1.
i can now successfuly complete a 4-way and group-key handshake
with both a WPA1 and a WPA2 access point.
add some TKIP encapsulation code (no SW crypto yet).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.30 2007/08/01 15:40:40 damien Exp $	*/
a197 3
#define IEEE80211_CCMP_HDRLEN	8
#define IEEE80211_CCMP_MICLEN	8

a272 4
#define IEEE80211_TKIP_HDRLEN	8
#define IEEE80211_TKIP_MICLEN	8
#define IEEE80211_TKIP_ICVLEN	4

d1031 46
@


1.30
log
@add generic ieee80211_encrypt() and ieee80211_decrypt() functions that
can handle multiple ciphers (the key to use is determined automatically
by these functions based on the frame's destination address).
add ieee80211_ccmp_encrypt() and ieee80211_ccmp_decrypt().
those two functions only do encapsulation/decapsulation of CCMP frames
for now (they don't do SW crypto). they will help to test things with
drivers that can do HW crypto.
add a ni_pairwise_key field to struct ieee80211_node to actually install
the pairwise transient key.
install the GTK in ic_nw_keys[].
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.29 2007/08/01 12:59:33 damien Exp $	*/
d81 4
a141 3
	case IEEE80211_CIPHER_CCMP:
		m0 = ieee80211_ccmp_encrypt(ic, m0, k);
		break;
d146 6
a179 3
	case IEEE80211_CIPHER_CCMP:
		m0 = ieee80211_ccmp_decrypt(ic, m0, k);
		break;
d184 6
d272 81
@


1.29
log
@group key handshake message 1 is very different between RSN and WPA1.
RSN uses a GTK KDE while WPA1 stores the GTK in the EAPOL-Key frame
data field (encrypted) and uses some bits in the info field.
split ieee80211_recv_group_msg1() in two separate functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.28 2007/08/01 12:23:26 damien Exp $	*/
d77 4
d120 144
@


1.28
log
@all WPA implementations i have tested use EAPOL-Key frames version 1,
so use that too and remove a check in ieee80211_recv_eapol().
WPA1 stores the group key id into bits 4-5 of the EAPOL-Key frame info
field and uses bit 6 to indicate if the key is Rx/Tx or Rx only.
remove a check in ieee80211_eapol_key_decrypt() because WPA1 encrypts
the payload of message 1 of the group-key handshake without setting the
encrypted bit in the info field.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.27 2007/08/01 12:15:48 damien Exp $	*/
d782 1
a782 1
 * Return the length in bytes of keys used by the specified cipher.
@


1.27
log
@the EAPOL-Key MIC must be computed with the MIC bit set.
this simplifies ieee80211_eapol_key_mic() and ieee80211_eapol_key_check_mic()
quite a bit.
set the EAPOL-Key body length before computing the MIC since the MIC is
computed with the 802.1X header too.
add a missing htons() while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.26 2007/07/28 11:01:19 damien Exp $	*/
a756 2
	/* should not come here if key data is not encrypted */
	KASSERT(info & EAPOL_KEY_ENCRYPTED);
@


1.26
log
@extend the ieee80211_key structure with a key identifier, a flags field
and a 64-bit receive sequence counter (for group keys).
add a ieee80211_cipher_keylen() function to retrieve the key length
in bytes used by a specific cipher.
account for 802.1X header size when computing the Key MIC.
some cleanup in comments and variable names while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.25 2007/07/24 20:34:16 damien Exp $	*/
a657 1
	KASSERT(!(info & EAPOL_KEY_KEYMIC));
d661 1
a661 1
		ieee80211_hmac_md5(kck, 16, &key->version, len, key->mic);
d664 1
a664 1
		ieee80211_hmac_sha1(kck, 16, &key->version, len, hash);
a668 4

	/* set the Key MIC bit */
	info |= EAPOL_KEY_KEYMIC;
	BE_WRITE_2(key->info, info);
a679 4
	u_int16_t info;

	info = BE_READ_2(key->info);
	KASSERT(info & EAPOL_KEY_KEYMIC);
a682 2
	info &= ~EAPOL_KEY_KEYMIC;
	BE_WRITE_2(key->info, info);
a704 2
	/* should not come here if key data is already encrypted */
	KASSERT(!(info & EAPOL_KEY_ENCRYPTED));
d735 2
a738 4

	/* set the Encrypted Key Data bit */
	info |= EAPOL_KEY_ENCRYPTED;
	BE_WRITE_2(key->info, info);
@


1.25
log
@new function to check the MIC of a received EAPOL-Key frame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.24 2007/07/24 19:39:22 damien Exp $	*/
a90 3
void	ieee80211_derive_ptk(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *, u_int8_t *,
	    size_t);
d656 1
a656 1
	len  = BE_READ_2(key->len);
d662 1
a662 1
		ieee80211_hmac_md5(kck, 16, (u_int8_t *)key, len, key->mic);
d665 1
a665 1
		ieee80211_hmac_sha1(kck, 16, (u_int8_t *)key, len, hash);
d671 1
a671 1
	/* set the Key MIC field */
d709 1
a709 1
	u_int8_t buf[EAPOL_KEY_IV_LEN + 16];
d728 2
a729 2
		memcpy(buf, key->iv, EAPOL_KEY_IV_LEN);
		memcpy(buf + EAPOL_KEY_IV_LEN, kek, 16);
d731 1
a731 1
		rc4_keysetup(&ctx, buf, sizeof buf);
d751 1
a751 1
	/* set the Encrypted Key Data field */
d766 1
a766 1
	u_int8_t buf[EAPOL_KEY_IV_LEN + 16];
d779 2
a780 2
		memcpy(buf, key->iv, EAPOL_KEY_IV_LEN);
		memcpy(buf + EAPOL_KEY_IV_LEN, kek, 16);
d782 1
a782 1
		rc4_keysetup(&ctx, buf, sizeof buf);
d791 2
a792 2
		len = (len / 8) - 1;
		return ieee80211_aes_key_unwrap(kek, 16, data, data, len);
d796 20
@


1.24
log
@use rc4_skip().
fix ieee80211_eapol_key_encrypt() so that we don't add more padding
bytes than necessary in the case of AES Key Wrap encryption.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.23 2007/07/24 18:44:36 damien Exp $	*/
d677 23
@


1.23
log
@remove some unused key derivation functions.
we won't support PeerKey handshake in a first time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.22 2007/07/24 18:42:16 damien Exp $	*/
a711 1
#ifdef notyet
a713 1
#endif
d719 1
d721 2
a722 3
			n = (len < 16) ? 16 - len : 8 - (len & 7);
			memset(&data[len], 0, n);
			len += n;
a762 1
#ifdef notyet
a764 1
#endif
@


1.22
log
@remove arc4_ compatibility macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.21 2007/07/24 16:53:03 damien Exp $	*/
a97 5
void	ieee80211_derive_stk(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *, u_int8_t *,
	    size_t);
void	ieee80211_derive_smkid(const u_int8_t *, size_t, const u_int8_t *,
	    const u_int8_t *, const u_int8_t *, const u_int8_t *, u_int8_t *);
a634 60
}

/*
 * Derive Station to Station Transient Key (STK) (see 8.5.1.4).
 */
void
ieee80211_derive_stk(const u_int8_t *smk, size_t smk_len, const u_int8_t *imac,
    const u_int8_t *pmac, const u_int8_t *inonce, const u_int8_t *pnonce,
    u_int8_t *stk, size_t stk_len)
{
	struct vector vec[6];	/* +1 for PRF */
	int ret;

	vec[0].base = "Peer key expansion";
	vec[0].len  = 19;	/* include trailing '\0' */

	ret = memcmp(imac, pmac, IEEE80211_ADDR_LEN) < 0;
	/* Min(MAC_I,MAC_P) */
	vec[1].base = ret ? imac : pmac;
	vec[1].len  = IEEE80211_ADDR_LEN;
	/* Max(MAC_I,MAC_P) */
	vec[2].base = ret ? pmac : imac;
	vec[2].len  = IEEE80211_ADDR_LEN;

	ret = memcmp(inonce, pnonce, EAPOL_KEY_NONCE_LEN) < 0;
	/* Min(INonce,PNonce) */
	vec[3].base = ret ? inonce : pnonce;
	vec[3].len  = EAPOL_KEY_NONCE_LEN;
	/* Max(INonce,PNonce) */
	vec[4].base = ret ? pnonce : inonce;
	vec[4].len  = EAPOL_KEY_NONCE_LEN;

	ieee80211_prf(smk, smk_len, vec, 5, stk, stk_len);
}

/*
 * Derive Station to Station Master Key Identifier (SMKID) (see 8.5.1.4).
 */
void
ieee80211_derive_smkid(const u_int8_t *smk, size_t smk_len,
    const u_int8_t *imac, const u_int8_t *pmac, const u_int8_t *inonce,
    const u_int8_t *pnonce, u_int8_t *smkid)
{
	struct vector vec[5];
	u_int8_t hash[SHA1_DIGEST_LENGTH];

	vec[0].base = "SMK Name";
	vec[0].len  = 8;	/* does *not* include trailing '\0' */
	vec[1].base = pnonce;
	vec[1].len  = EAPOL_KEY_NONCE_LEN;
	vec[2].base = pmac;
	vec[2].len  = IEEE80211_ADDR_LEN;
	vec[3].base = inonce;
	vec[3].len  = EAPOL_KEY_NONCE_LEN;
	vec[4].base = imac;
	vec[4].len  = IEEE80211_ADDR_LEN;

	ieee80211_hmac_sha1_v(vec, 5, smk, smk_len, hash);
	/* use the first 128 bits of the HMAC-SHA1 */
	memcpy(smkid, hash, IEEE80211_SMKID_LEN);
@


1.21
log
@add functions to compute EAPOL-Key Key MIC fields and to encrypt/decrypt
EAPOL-Key Data fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.20 2007/07/24 16:49:16 damien Exp $	*/
a68 3
#define	arc4_ctxlen()			sizeof (struct rc4_ctx)
#define	arc4_setkey(_c,_k,_l)		rc4_keysetup(_c,_k,_l)
#define	arc4_encrypt(_c,_d,_s,_l)	rc4_crypt(_c,_s,_d,_l)
d146 1
a146 1
		ctx = malloc(arc4_ctxlen(), M_DEVBUF, M_NOWAIT);
d228 1
a228 1
	arc4_setkey(ctx, keybuf, len);
d263 2
a264 2
		arc4_encrypt(ctx, mtod(n, caddr_t) + noff,
		    mtod(m, caddr_t) + moff, len);
d291 1
a291 1
		arc4_encrypt(ctx, mtod(n, caddr_t) + noff, crcbuf,
d300 2
a301 2
				arc4_encrypt(ctx, crcbuf + noff,
				    mtod(m, caddr_t) + moff, len);
@


1.20
log
@add ic_globalcnt to struct ieee80211com:
in an RSNA, each STA must maintain a 256-bit global key counter that
must be initialized to a random value (see 8.5.7).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.19 2007/07/18 19:47:44 damien Exp $	*/
d703 145
@


1.19
log
@modify ieee80211_aes_key_wrap() to support in-place encryption.
explicitly use ovbcopy() even if our kernel memcpy() supports
overlapping buffers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.18 2007/07/18 18:16:33 damien Exp $	*/
d110 2
a111 3
	/*
	 * Setup crypto support.
	 */
d113 3
@


1.18
log
@add AES Key Wrap algorithm (see RFC 3394).
this will be used to encrypt/decrypt EAPOL-Key frames payload.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.17 2007/07/18 18:10:31 damien Exp $	*/
d386 2
a389 1
	memcpy(ct + 8, pt, len * 8);
a479 1
/* wrapper around ieee80211_hmac_md5_v */
a529 1
/* wrapper around ieee80211_hmac_sha1_v */
@


1.17
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.16 2007/07/14 20:00:33 damien Exp $	*/
d68 1
d80 4
d368 69
@


1.16
log
@s/uint8_t/u_int8_t/ for consistency.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.15 2007/07/14 19:58:04 damien Exp $	*/
d221 3
a223 3
	memcpy(keybuf + IEEE80211_WEP_IVLEN, ic->ic_nw_keys[kid].wk_key,
	    ic->ic_nw_keys[kid].wk_len);
	len = klen_round(IEEE80211_WEP_IVLEN + ic->ic_nw_keys[kid].wk_len);
@


1.15
log
@update QoS Tx/Rx sequence numbers for each TID.
add a parameter to ieee80211_decap() to handle different 802.11
header sizes.
cleanup and clarify ieee80211_classify().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.14 2007/07/05 20:18:02 damien Exp $	*/
d79 8
a86 8
void	ieee80211_hmac_md5_v(const struct vector *, int, const uint8_t *,
	    size_t, uint8_t digest[]);
void	ieee80211_hmac_md5(const u_int8_t *, size_t, const uint8_t *, size_t,
	    uint8_t digest[]);
void	ieee80211_hmac_sha1_v(const struct vector *, int, const uint8_t *,
	    size_t, uint8_t digest[]);
void	ieee80211_hmac_sha1(const u_int8_t *, size_t, const uint8_t *, size_t,
	    uint8_t digest[]);
d366 2
a367 2
ieee80211_hmac_md5_v(const struct vector *vec, int vcnt, const uint8_t *key,
    size_t key_len, uint8_t digest[MD5_DIGEST_LENGTH])
d370 2
a371 2
	uint8_t k_pad[MD5_BLOCK_LENGTH];
	uint8_t tk[MD5_DIGEST_LENGTH];
d407 2
a408 2
ieee80211_hmac_md5(const u_int8_t *text, size_t text_len, const uint8_t *key,
    size_t key_len, uint8_t digest[MD5_DIGEST_LENGTH])
d417 2
a418 2
ieee80211_hmac_sha1_v(const struct vector *vec, int vcnt, const uint8_t *key,
    size_t key_len, uint8_t digest[SHA1_DIGEST_LENGTH])
d421 2
a422 2
	uint8_t k_pad[SHA1_BLOCK_LENGTH];
	uint8_t tk[SHA1_DIGEST_LENGTH];
d458 2
a459 2
ieee80211_hmac_sha1(const u_int8_t *text, size_t text_len, const uint8_t *key,
    size_t key_len, uint8_t digest[SHA1_DIGEST_LENGTH])
@


1.14
log
@add myself to the copyright list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.13 2007/07/05 20:11:04 damien Exp $	*/
d174 8
a181 2
	len = sizeof(struct ieee80211_frame);
	memcpy(mtod(n, caddr_t), mtod(m, caddr_t), len);
@


1.13
log
@add the pseudo-random function (PRF) and various key derivation
functions defined in 802.11i.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.12 2007/06/16 13:17:05 damien Exp $	*/
d7 1
@


1.12
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.11 2007/06/16 11:56:20 damien Exp $	*/
d65 2
d71 6
a76 1
void ieee80211_crc_init(void);
d78 22
a347 1

d356 265
@


1.11
log
@de-static

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.10 2007/06/06 19:31:07 damien Exp $	*/
d70 1
a70 1
u_int32_t ieee80211_crc_update(u_int32_t crc, u_int8_t *buf, int len);
d321 1
a321 1
ieee80211_crc_update(u_int32_t crc, u_int8_t *buf, int len)
d323 1
a323 1
	u_int8_t *endbuf;
@


1.10
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.9 2006/12/29 15:45:56 reyk Exp $	*/
d69 2
a70 2
static	void ieee80211_crc_init(void);
static	u_int32_t ieee80211_crc_update(u_int32_t crc, u_int8_t *buf, int len);
d296 1
a296 1
static void
d320 1
a320 1
static u_int32_t
@


1.9
log
@fix the key buffer size used for software wep, this could cause
problems with non-standard wep keys >= 104 bits.

thanks to Alexander Bluhm

ok mglocker@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.8 2006/06/18 18:39:41 damien Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.8
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.7 2005/09/08 13:24:52 reyk Exp $	*/
d111 1
a111 1
	u_int8_t keybuf[IEEE80211_WEP_IVLEN + IEEE80211_KEYBUF_SIZE];
d180 8
d189 2
a191 1
	memcpy(keybuf + IEEE80211_WEP_IVLEN, ic->ic_nw_keys[kid].wk_key, len);
@


1.7
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.6 2005/09/08 12:44:55 jsg Exp $	*/
a34 2

#include <sys/cdefs.h>
@


1.6
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.5 2005/09/08 09:11:08 jsg Exp $	*/
d99 3
a101 1
#define klen_round(x)	(((x) + (IEEE80211_WEP_KEYLEN + IEEE80211_WEP_IVLEN - 1)) & ~(IEEE80211_WEP_KEYLEN + IEEE80211_WEP_IVLEN - 1))
d279 1
a279 1
  fail:
@


1.5
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.4 2005/09/07 05:40:11 jsg Exp $	*/
a67 1
#include <net80211/ieee80211_compat.h>
@


1.4
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.3 2004/06/28 19:29:40 millert Exp $	*/
d264 2
a265 1
				if_printf(ifp, "decrypt CRC error\n");
@


1.3
log
@Don't restrict WEP keys to exactly 40 or 108 bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.2 2004/06/27 04:14:23 millert Exp $	*/
a36 9
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_crypto.c,v 1.3 2003/10/17 23:15:30 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_crypto.c,v 1.5 2003/12/14 09:56:53 dyoung Exp $");
#endif

#if defined(__NetBSD__)
#include "opt_inet.h"
#endif
a48 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a51 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a55 5
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a63 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a64 3
#else
#include <net/if_ether.h>
#endif
a69 6
#if defined(__FreeBSD__)
#include <crypto/rc4/rc4.h>
#define	arc4_ctxlen()			sizeof (struct rc4_state)
#define	arc4_setkey(_c,_k,_l)		rc4_init(_c,_k,_l)
#define	arc4_encrypt(_c,_d,_s,_l)	rc4_crypt(_c,_s,_d,_l)
#elif defined(__OpenBSD__)
a74 3
#else
#include <crypto/arc4/arc4.h>
#endif
a134 3
#if defined(__FreeBSD__)
	M_MOVE_PKTHDR(n, m);
#elif defined(__OpenBSD__)
a135 3
#else
	M_COPY_PKTHDR(n, m);
#endif
@


1.2
log
@Hack to avoid panic in arc4maybeinit() due to rnd device not being
attached yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto.c,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d133 3
d222 3
a224 4
	memcpy(keybuf + IEEE80211_WEP_IVLEN, ic->ic_nw_keys[kid].wk_key,
	    ic->ic_nw_keys[kid].wk_len);
	arc4_setkey(ctx, keybuf,
	    IEEE80211_WEP_IVLEN + ic->ic_nw_keys[kid].wk_len);
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a115 2
	struct ieee80211com *ic = (void *)ifp;

a119 1
	ic->ic_iv = arc4random();
d195 1
a195 1
		iv = ic->ic_iv;
@

