head	1.120;
access;
symbols
	OPENBSD_6_1:1.115.0.4
	OPENBSD_6_1_BASE:1.115
	OPENBSD_6_0:1.103.0.2
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.88.0.4
	OPENBSD_5_8_BASE:1.88
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.78.0.2
	OPENBSD_5_4_BASE:1.78
	OPENBSD_5_3:1.77.0.2
	OPENBSD_5_3_BASE:1.77
	OPENBSD_5_2:1.71.0.2
	OPENBSD_5_2_BASE:1.71
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.2
	OPENBSD_5_0:1.63.0.2
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.62.0.4
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.55.0.6
	OPENBSD_4_6_BASE:1.55
	OPENBSD_4_5:1.55.0.2
	OPENBSD_4_5_BASE:1.55
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.5.0.2
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.3.0.2
	OPENBSD_3_7_BASE:1.3
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.120
date	2017.08.17.06.01.05;	author stsp;	state Exp;
branches;
next	1.119;
commitid	Mvash3pgQqv8cBC5;

1.119
date	2017.08.04.17.31.46;	author stsp;	state Exp;
branches;
next	1.118;
commitid	ioQzqypouODA1ThZ;

1.118
date	2017.07.19.19.50.58;	author stsp;	state Exp;
branches;
next	1.117;
commitid	gDsiC9tBwKUKUV2C;

1.117
date	2017.06.04.12.48.42;	author tb;	state Exp;
branches;
next	1.116;
commitid	TmCEidI2en4vCuLK;

1.116
date	2017.06.03.15.44.03;	author tb;	state Exp;
branches;
next	1.115;
commitid	Fy9gzTb9KEKQjy5d;

1.115
date	2017.03.04.12.44.27;	author stsp;	state Exp;
branches
	1.115.4.1;
next	1.114;
commitid	18dFS4hxKhmyoW32;

1.114
date	2017.02.03.09.32.26;	author stsp;	state Exp;
branches;
next	1.113;
commitid	MRqMRWZEGgk8iIVU;

1.113
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.112;
commitid	PETPfbQ5ZWdJqIYS;

1.112
date	2017.01.16.09.35.43;	author stsp;	state Exp;
branches;
next	1.111;
commitid	X8CcXePi1iYsreWy;

1.111
date	2017.01.09.20.18.59;	author stsp;	state Exp;
branches;
next	1.110;
commitid	cqn8VXxfpVIojpbn;

1.110
date	2017.01.09.16.24.20;	author stsp;	state Exp;
branches;
next	1.109;
commitid	2R4xID7oIXEJOE2Q;

1.109
date	2017.01.09.12.40.00;	author stsp;	state Exp;
branches;
next	1.108;
commitid	G3vWsV1lhNxxnROO;

1.108
date	2017.01.09.09.31.18;	author stsp;	state Exp;
branches;
next	1.107;
commitid	RdyzR3TtCSrh0EP8;

1.107
date	2017.01.09.09.30.47;	author stsp;	state Exp;
branches;
next	1.106;
commitid	Tu3x1v4IIHWusNFX;

1.106
date	2016.12.17.18.35.54;	author stsp;	state Exp;
branches;
next	1.105;
commitid	jPAQ1b8Z1ErNDg1z;

1.105
date	2016.09.15.03.32.48;	author dlg;	state Exp;
branches;
next	1.104;
commitid	prdL2stxGjOBR6s3;

1.104
date	2016.08.17.09.42.03;	author stsp;	state Exp;
branches;
next	1.103;
commitid	04nhXoSavbGGMypk;

1.103
date	2016.05.21.09.07.11;	author stsp;	state Exp;
branches
	1.103.2.1;
next	1.102;
commitid	2Km71Ne0nKLHIdCy;

1.102
date	2016.05.18.08.15.28;	author stsp;	state Exp;
branches;
next	1.101;
commitid	h4943tbngzO3CJ4g;

1.101
date	2016.04.12.14.33.27;	author mpi;	state Exp;
branches;
next	1.100;
commitid	0LA0xiKsLRo4rVjB;

1.100
date	2016.03.03.07.20.45;	author gerhard;	state Exp;
branches;
next	1.99;
commitid	t8jeYaoxQko1CuFD;

1.99
date	2016.01.25.15.14.22;	author stsp;	state Exp;
branches
	1.99.2.1;
next	1.98;
commitid	9rrpvMUbRKud5zGd;

1.98
date	2016.01.25.15.10.37;	author stsp;	state Exp;
branches;
next	1.97;
commitid	hMc0oSgmsLkJIc3U;

1.97
date	2016.01.07.23.22.31;	author stsp;	state Exp;
branches;
next	1.96;
commitid	fZfOIgRYw9oUaCc3;

1.96
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.95;
commitid	2QagMjdMhQhIaQgu;

1.95
date	2016.01.04.12.25.00;	author stsp;	state Exp;
branches;
next	1.94;
commitid	di0zXRfXIFBF1XlJ;

1.94
date	2015.12.18.13.27.00;	author sthen;	state Exp;
branches;
next	1.93;
commitid	V99oiTXXvJitvwyp;

1.93
date	2015.12.12.11.25.46;	author stsp;	state Exp;
branches;
next	1.92;
commitid	yJtuIKjLQDddhkbQ;

1.92
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.91;
commitid	FuSD2mFDJWATHIDx;

1.91
date	2015.11.15.11.14.17;	author stsp;	state Exp;
branches;
next	1.90;
commitid	fROBylLWPLvwXRar;

1.90
date	2015.11.15.10.07.03;	author stsp;	state Exp;
branches;
next	1.89;
commitid	Nt1Hw5JFHrcEBdto;

1.89
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.88;
commitid	YT6fyIEviv9qwbl6;

1.88
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	ncpqEGjDtSFuLAgn;

1.87
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.86;
commitid	p4LJxGKbi0BU2cG6;

1.86
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.85;
commitid	PYnSnAqgemmk34E3;

1.85
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.84;
commitid	Z1vcFtHO8wRH0yRt;

1.84
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.83;
commitid	uzzBR7hz9ncd4O6G;

1.83
date	2014.09.12.16.02.40;	author sthen;	state Exp;
branches;
next	1.82;
commitid	aKTqOYHA8eIImugJ;

1.82
date	2014.08.08.15.16.39;	author jasper;	state Exp;
branches;
next	1.81;
commitid	XqlyEl7HuWPLWo47;

1.81
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.80;
commitid	B4dZSbxas1X1IpXI;

1.80
date	2013.12.01.10.08.55;	author stsp;	state Exp;
branches;
next	1.79;

1.79
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.78;

1.78
date	2013.03.24.17.01.23;	author claudio;	state Exp;
branches;
next	1.77;

1.77
date	2012.11.07.19.39.08;	author stsp;	state Exp;
branches;
next	1.76;

1.76
date	2012.10.10.09.23.06;	author kettenis;	state Exp;
branches;
next	1.75;

1.75
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.74;

1.74
date	2012.09.20.17.21.13;	author stsp;	state Exp;
branches;
next	1.73;

1.73
date	2012.08.25.11.34.27;	author kettenis;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.17.14.49.17;	author stsp;	state Exp;
branches;
next	1.71;

1.71
date	2012.07.18.13.24.28;	author stsp;	state Exp;
branches;
next	1.70;

1.70
date	2012.07.16.14.51.46;	author stsp;	state Exp;
branches;
next	1.69;

1.69
date	2012.07.13.09.46.33;	author stsp;	state Exp;
branches;
next	1.68;

1.68
date	2012.01.25.17.04.02;	author stsp;	state Exp;
branches;
next	1.67;

1.67
date	2012.01.25.17.03.31;	author stsp;	state Exp;
branches;
next	1.66;

1.66
date	2012.01.21.19.42.16;	author stsp;	state Exp;
branches;
next	1.65;

1.65
date	2012.01.21.19.01.04;	author stsp;	state Exp;
branches;
next	1.64;

1.64
date	2012.01.18.14.35.34;	author stsp;	state Exp;
branches;
next	1.63;

1.63
date	2011.03.28.14.49.40;	author kettenis;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.19.18.53.52;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2010.06.19.08.33.50;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2010.06.14.17.51.43;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2010.06.14.17.39.20;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2010.03.28.13.02.58;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2010.02.17.18.34.37;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2009.01.29.17.19.10;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.28.17.15.21;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2009.01.27.17.02.29;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2009.01.26.21.55.58;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2008.12.14.10.17.24;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2008.10.23.16.21.21;	author mk;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.46;

1.46
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2008.08.12.19.21.04;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.08.12.18.41.18;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2008.08.12.18.37.23;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2008.08.12.16.14.05;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.02.08.20.16;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.07.28.19.42.13;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.21.20.16.34;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.29.15.40.23;	author chl;	state Exp;
branches;
next	1.29;

1.29
date	2007.09.07.20.23.30;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.06.18.18.43;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.06.17.47.19;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.03.20.25.32;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.02.16.46.44;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.16.11.59.58;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.07.20.24.42;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.15.18.59.37;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.11.13.20.32.45;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.19.12.17.56;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.19.17.34.13;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2005.10.09.19.44.22;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.10.07.23.30.02;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.08.08.36.12;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.21.22.47.15;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.15.39.02;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.99.2.1
date	2016.05.05.09.41.33;	author stsp;	state Exp;
branches;
next	;
commitid	9r0UiZmqSOMj8avE;

1.103.2.1
date	2017.08.30.15.08.46;	author stsp;	state Exp;
branches;
next	;
commitid	uJxOvDLDwHi7tkZk;

1.115.4.1
date	2017.08.30.15.08.30;	author stsp;	state Exp;
branches;
next	;
commitid	rHceBzDEJfOyPHhV;


desc
@@


1.120
log
@Add an entry to dmesg if pairwise WPA keys arrive unexpectedly or if WPA
group keys are being reused. OpenBSD wireless clients will now leave a
trail of such events in their message log.

There has been increased public scrutiny of WPA's security recently, so
I am curious to see if anyone is attempting replay attacks in the wild.

ok deraadt
@
text
@/*	$OpenBSD: ieee80211_node.c,v 1.119 2017/08/04 17:31:46 stsp Exp $	*/
/*	$NetBSD: ieee80211_node.c,v 1.14 2004/05/09 09:18:47 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * Copyright (c) 2008 Damien Bergamini
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bridge.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

struct ieee80211_node *ieee80211_node_alloc(struct ieee80211com *);
void ieee80211_node_free(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_copy(struct ieee80211com *, struct ieee80211_node *,
    const struct ieee80211_node *);
void ieee80211_choose_rsnparams(struct ieee80211com *);
u_int8_t ieee80211_node_getrssi(struct ieee80211com *,
    const struct ieee80211_node *);
void ieee80211_setup_node(struct ieee80211com *, struct ieee80211_node *,
    const u_int8_t *);
void ieee80211_free_node(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_ba_del(struct ieee80211_node *);
struct ieee80211_node *ieee80211_alloc_node_helper(struct ieee80211com *);
void ieee80211_node_cleanup(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_needs_auth(struct ieee80211com *, struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void ieee80211_node_join_ht(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_join_rsn(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_join_11g(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_leave_ht(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_leave_rsn(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_node_leave_11g(struct ieee80211com *, struct ieee80211_node *);
void ieee80211_inact_timeout(void *);
void ieee80211_node_cache_timeout(void *);
#endif

#ifndef IEEE80211_STA_ONLY
void
ieee80211_inact_timeout(void *arg)
{
	struct ieee80211com *ic = arg;
	struct ieee80211_node *ni, *next_ni;
	int s;

	s = splnet();
	for (ni = RBT_MIN(ieee80211_tree, &ic->ic_tree);
	    ni != NULL; ni = next_ni) {
		next_ni = RBT_NEXT(ieee80211_tree, ni);
		if (ni->ni_refcnt > 0)
			continue;
		if (ni->ni_inact < IEEE80211_INACT_MAX)
			ni->ni_inact++;
	}
	splx(s);

	timeout_add_sec(&ic->ic_inact_timeout, IEEE80211_INACT_WAIT);
}

void
ieee80211_node_cache_timeout(void *arg)
{
	struct ieee80211com *ic = arg;

	ieee80211_clean_nodes(ic, 1);
	timeout_add_sec(&ic->ic_node_cache_timeout, IEEE80211_CACHE_WAIT);
}
#endif

void
ieee80211_node_attach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
#ifndef IEEE80211_STA_ONLY
	int size;
#endif

	RBT_INIT(ieee80211_tree, &ic->ic_tree);
	ic->ic_node_alloc = ieee80211_node_alloc;
	ic->ic_node_free = ieee80211_node_free;
	ic->ic_node_copy = ieee80211_node_copy;
	ic->ic_node_getrssi = ieee80211_node_getrssi;
	ic->ic_scangen = 1;
	ic->ic_max_nnodes = ieee80211_cache_size;

	if (ic->ic_max_aid == 0)
		ic->ic_max_aid = IEEE80211_AID_DEF;
	else if (ic->ic_max_aid > IEEE80211_AID_MAX)
		ic->ic_max_aid = IEEE80211_AID_MAX;
#ifndef IEEE80211_STA_ONLY
	size = howmany(ic->ic_max_aid, 32) * sizeof(u_int32_t);
	ic->ic_aid_bitmap = malloc(size, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ic->ic_aid_bitmap == NULL) {
		/* XXX no way to recover */
		printf("%s: no memory for AID bitmap!\n", __func__);
		ic->ic_max_aid = 0;
	}
	if (ic->ic_caps & (IEEE80211_C_HOSTAP | IEEE80211_C_IBSS)) {
		ic->ic_tim_len = howmany(ic->ic_max_aid, 8);
		ic->ic_tim_bitmap = malloc(ic->ic_tim_len, M_DEVBUF,
		    M_NOWAIT | M_ZERO);
		if (ic->ic_tim_bitmap == NULL) {
			printf("%s: no memory for TIM bitmap!\n", __func__);
			ic->ic_tim_len = 0;
		} else
			ic->ic_set_tim = ieee80211_set_tim;
		timeout_set(&ic->ic_rsn_timeout,
		    ieee80211_gtk_rekey_timeout, ic);
		timeout_set(&ic->ic_inact_timeout,
		    ieee80211_inact_timeout, ic);
		timeout_set(&ic->ic_node_cache_timeout,
		    ieee80211_node_cache_timeout, ic);
	}
#endif
}

struct ieee80211_node *
ieee80211_alloc_node_helper(struct ieee80211com *ic)
{
	struct ieee80211_node *ni;
	if (ic->ic_nnodes >= ic->ic_max_nnodes)
		ieee80211_clean_nodes(ic, 0);
	if (ic->ic_nnodes >= ic->ic_max_nnodes)
		return NULL;
	ni = (*ic->ic_node_alloc)(ic);
	return ni;
}

void
ieee80211_node_lateattach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_node *ni;

	ni = ieee80211_alloc_node_helper(ic);
	if (ni == NULL)
		panic("unable to setup inital BSS node");
	ni->ni_chan = IEEE80211_CHAN_ANYC;
	ic->ic_bss = ieee80211_ref_node(ni);
	ic->ic_txpower = IEEE80211_TXPOWER_MAX;
#ifndef IEEE80211_STA_ONLY
	mq_init(&ni->ni_savedq, IEEE80211_PS_MAX_QUEUE, IPL_NET);
#endif
}

void
ieee80211_node_detach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	if (ic->ic_bss != NULL) {
		(*ic->ic_node_free)(ic, ic->ic_bss);
		ic->ic_bss = NULL;
	}
	ieee80211_free_allnodes(ic);
#ifndef IEEE80211_STA_ONLY
	free(ic->ic_aid_bitmap, M_DEVBUF,
	    howmany(ic->ic_max_aid, 32) * sizeof(u_int32_t));
	free(ic->ic_tim_bitmap, M_DEVBUF, ic->ic_tim_len);
	timeout_del(&ic->ic_inact_timeout);
	timeout_del(&ic->ic_node_cache_timeout);
	timeout_del(&ic->ic_tkip_micfail_timeout);
#endif
	timeout_del(&ic->ic_rsn_timeout);
}

/*
 * AP scanning support.
 */

/*
 * Initialize the active channel set based on the set
 * of available channels and the current PHY mode.
 */
void
ieee80211_reset_scan(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	memcpy(ic->ic_chan_scan, ic->ic_chan_active,
		sizeof(ic->ic_chan_active));
	/* NB: hack, setup so next_scan starts with the first channel */
	if (ic->ic_bss != NULL && ic->ic_bss->ni_chan == IEEE80211_CHAN_ANYC)
		ic->ic_bss->ni_chan = &ic->ic_channels[IEEE80211_CHAN_MAX];
}

/*
 * Begin an active scan.
 */
void
ieee80211_begin_scan(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	if (ic->ic_scan_lock & IEEE80211_SCAN_LOCKED)
		return;
	ic->ic_scan_lock |= IEEE80211_SCAN_LOCKED;

	/*
	 * In all but hostap mode scanning starts off in
	 * an active mode before switching to passive.
	 */
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
	{
		ic->ic_flags |= IEEE80211_F_ASCAN;
		ic->ic_stats.is_scan_active++;
	}
#ifndef IEEE80211_STA_ONLY
	else
		ic->ic_stats.is_scan_passive++;
#endif
	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: begin %s scan\n", ifp->if_xname,
			(ic->ic_flags & IEEE80211_F_ASCAN) ?
				"active" : "passive");

	/*
	 * Flush any previously seen AP's. Note that the latter 
	 * assumes we don't act as both an AP and a station,
	 * otherwise we'll potentially flush state of stations
	 * associated with us.
	 */
	ieee80211_free_allnodes(ic);

	/*
	 * Reset the current mode. Setting the current mode will also
	 * reset scan state.
	 */
	if (IFM_MODE(ic->ic_media.ifm_cur->ifm_media) == IFM_AUTO)
		ic->ic_curmode = IEEE80211_MODE_AUTO;
	ieee80211_setmode(ic, ic->ic_curmode);

	ic->ic_scan_count = 0;

	/* Scan the next channel. */
	ieee80211_next_scan(ifp);
}

/*
 * Switch to the next channel marked for scanning.
 */
void
ieee80211_next_scan(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_channel *chan;

	chan = ic->ic_bss->ni_chan;
	for (;;) {
		if (++chan > &ic->ic_channels[IEEE80211_CHAN_MAX])
			chan = &ic->ic_channels[0];
		if (isset(ic->ic_chan_scan, ieee80211_chan2ieee(ic, chan))) {
			/*
			 * Ignore channels marked passive-only
			 * during an active scan.
			 */
			if ((ic->ic_flags & IEEE80211_F_ASCAN) == 0 ||
			    (chan->ic_flags & IEEE80211_CHAN_PASSIVE) == 0)
				break;
		}
		if (chan == ic->ic_bss->ni_chan) {
			ieee80211_end_scan(ifp);
			return;
		}
	}
	clrbit(ic->ic_chan_scan, ieee80211_chan2ieee(ic, chan));
	DPRINTF(("chan %d->%d\n",
	    ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan),
	    ieee80211_chan2ieee(ic, chan)));
	ic->ic_bss->ni_chan = chan;
	ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
}

#ifndef IEEE80211_STA_ONLY
void
ieee80211_create_ibss(struct ieee80211com* ic, struct ieee80211_channel *chan)
{
	struct ieee80211_node *ni;
	struct ifnet *ifp = &ic->ic_if;

	ni = ic->ic_bss;
	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: creating ibss\n", ifp->if_xname);
	ic->ic_flags |= IEEE80211_F_SIBSS;
	ni->ni_chan = chan;
	ni->ni_rates = ic->ic_sup_rates[ieee80211_chan2mode(ic, ni->ni_chan)];
	ni->ni_txrate = 0;
	IEEE80211_ADDR_COPY(ni->ni_macaddr, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(ni->ni_bssid, ic->ic_myaddr);
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		if ((ic->ic_flags & IEEE80211_F_DESBSSID) != 0)
			IEEE80211_ADDR_COPY(ni->ni_bssid, ic->ic_des_bssid);
		else
			ni->ni_bssid[0] |= 0x02;	/* local bit for IBSS */
	}
	ni->ni_esslen = ic->ic_des_esslen;
	memcpy(ni->ni_essid, ic->ic_des_essid, ni->ni_esslen);
	ni->ni_rssi = 0;
	ni->ni_rstamp = 0;
	memset(ni->ni_tstamp, 0, sizeof(ni->ni_tstamp));
	ni->ni_intval = ic->ic_lintval;
	ni->ni_capinfo = IEEE80211_CAPINFO_IBSS;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		ni->ni_capinfo |= IEEE80211_CAPINFO_PRIVACY;
	if (ic->ic_flags & IEEE80211_F_HTON) {
		const struct ieee80211_edca_ac_params *ac_qap;
		struct ieee80211_edca_ac_params *ac;
		int aci;

		/* 
		 * Default to non-member HT protection. This will be updated
		 * later based on the number of non-HT nodes in the node cache.
		 */
		ni->ni_htop1 = IEEE80211_HTPROT_NONMEMBER;
		ic->ic_protmode = IEEE80211_PROT_RTSCTS;

		/* Configure QoS EDCA parameters. */
		for (aci = 0; aci < EDCA_NUM_AC; aci++) {
			ac = &ic->ic_edca_ac[aci];
			ac_qap = &ieee80211_qap_edca_table[ic->ic_curmode][aci];
			ac->ac_acm       = ac_qap->ac_acm;
			ac->ac_aifsn     = ac_qap->ac_aifsn;
			ac->ac_ecwmin    = ac_qap->ac_ecwmin;
			ac->ac_ecwmax    = ac_qap->ac_ecwmax;
			ac->ac_txoplimit = ac_qap->ac_txoplimit;
		}
		if (ic->ic_updateedca)
			(*ic->ic_updateedca)(ic);
	}
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		struct ieee80211_key *k;

		/* initialize 256-bit global key counter to a random value */
		arc4random_buf(ic->ic_globalcnt, EAPOL_KEY_NONCE_LEN);

		ni->ni_rsnprotos = ic->ic_rsnprotos;
		ni->ni_rsnakms = ic->ic_rsnakms;
		ni->ni_rsnciphers = ic->ic_rsnciphers;
		ni->ni_rsngroupcipher = ic->ic_rsngroupcipher;
		ni->ni_rsngroupmgmtcipher = ic->ic_rsngroupmgmtcipher;
		ni->ni_rsncaps = 0;
		if (ic->ic_caps & IEEE80211_C_MFP) {
			ni->ni_rsncaps |= IEEE80211_RSNCAP_MFPC;
			if (ic->ic_flags & IEEE80211_F_MFPR)
				ni->ni_rsncaps |= IEEE80211_RSNCAP_MFPR;
		}

		ic->ic_def_txkey = 1;
		ic->ic_flags &= ~IEEE80211_F_COUNTERM;
		k = &ic->ic_nw_keys[ic->ic_def_txkey];
		memset(k, 0, sizeof(*k));
		k->k_id = ic->ic_def_txkey;
		k->k_cipher = ni->ni_rsngroupcipher;
		k->k_flags = IEEE80211_KEY_GROUP | IEEE80211_KEY_TX;
		k->k_len = ieee80211_cipher_keylen(k->k_cipher);
		arc4random_buf(k->k_key, k->k_len);
		(*ic->ic_set_key)(ic, ni, k);	/* XXX */

		if (ic->ic_caps & IEEE80211_C_MFP) {
			ic->ic_igtk_kid = 4;
			k = &ic->ic_nw_keys[ic->ic_igtk_kid];
			memset(k, 0, sizeof(*k));
			k->k_id = ic->ic_igtk_kid;
			k->k_cipher = ni->ni_rsngroupmgmtcipher;
			k->k_flags = IEEE80211_KEY_IGTK | IEEE80211_KEY_TX;
			k->k_len = 16;
			arc4random_buf(k->k_key, k->k_len);
			(*ic->ic_set_key)(ic, ni, k);	/* XXX */
		}
		/*
		 * In HostAP mode, multicast traffic is sent using ic_bss
		 * as the Tx node, so mark our node as valid so we can send
		 * multicast frames using the group key we've just configured.
		 */
		ni->ni_port_valid = 1;
		ni->ni_flags |= IEEE80211_NODE_TXPROT;

		/* schedule a GTK/IGTK rekeying after 3600s */
		timeout_add_sec(&ic->ic_rsn_timeout, 3600);
	}
	timeout_add_sec(&ic->ic_inact_timeout, IEEE80211_INACT_WAIT);
	timeout_add_sec(&ic->ic_node_cache_timeout, IEEE80211_CACHE_WAIT);
	ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
}
#endif	/* IEEE80211_STA_ONLY */

int
ieee80211_match_bss(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	u_int8_t rate;
	int fail;

	fail = 0;
	if (isclr(ic->ic_chan_active, ieee80211_chan2ieee(ic, ni->ni_chan)))
		fail |= 0x01;
	if (ic->ic_des_chan != IEEE80211_CHAN_ANYC &&
	    ni->ni_chan != ic->ic_des_chan)
		fail |= 0x01;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		if ((ni->ni_capinfo & IEEE80211_CAPINFO_IBSS) == 0)
			fail |= 0x02;
	} else
#endif
	{
		if ((ni->ni_capinfo & IEEE80211_CAPINFO_ESS) == 0)
			fail |= 0x02;
	}
	if (ic->ic_flags & (IEEE80211_F_WEPON | IEEE80211_F_RSNON)) {
		if ((ni->ni_capinfo & IEEE80211_CAPINFO_PRIVACY) == 0)
			fail |= 0x04;
	} else {
		if (ni->ni_capinfo & IEEE80211_CAPINFO_PRIVACY)
			fail |= 0x04;
	}

	rate = ieee80211_fix_rate(ic, ni, IEEE80211_F_DONEGO);
	if (rate & IEEE80211_RATE_BASIC)
		fail |= 0x08;
	if (ic->ic_des_esslen != 0 &&
	    (ni->ni_esslen != ic->ic_des_esslen ||
	     memcmp(ni->ni_essid, ic->ic_des_essid, ic->ic_des_esslen) != 0))
		fail |= 0x10;
	if ((ic->ic_flags & IEEE80211_F_DESBSSID) &&
	    !IEEE80211_ADDR_EQ(ic->ic_des_bssid, ni->ni_bssid))
		fail |= 0x20;

	if (ic->ic_flags & IEEE80211_F_RSNON) {
		/*
		 * If at least one RSN IE field from the AP's RSN IE fails
		 * to overlap with any value the STA supports, the STA shall
		 * decline to associate with that AP.
		 */
		if ((ni->ni_rsnprotos & ic->ic_rsnprotos) == 0)
			fail |= 0x40;
		if ((ni->ni_rsnakms & ic->ic_rsnakms) == 0)
			fail |= 0x40;
		if ((ni->ni_rsnakms & ic->ic_rsnakms &
		     ~(IEEE80211_AKM_PSK | IEEE80211_AKM_SHA256_PSK)) == 0) {
			/* AP only supports PSK AKMPs */
			if (!(ic->ic_flags & IEEE80211_F_PSK))
				fail |= 0x40;
		}
		if (ni->ni_rsngroupcipher != IEEE80211_CIPHER_WEP40 &&
		    ni->ni_rsngroupcipher != IEEE80211_CIPHER_TKIP &&
		    ni->ni_rsngroupcipher != IEEE80211_CIPHER_CCMP &&
		    ni->ni_rsngroupcipher != IEEE80211_CIPHER_WEP104)
			fail |= 0x40;
		if ((ni->ni_rsnciphers & ic->ic_rsnciphers) == 0)
			fail |= 0x40;

		/* we only support BIP as the IGTK cipher */
		if ((ni->ni_rsncaps & IEEE80211_RSNCAP_MFPC) &&
		    ni->ni_rsngroupmgmtcipher != IEEE80211_CIPHER_BIP)
			fail |= 0x40;

		/* we do not support MFP but AP requires it */
		if (!(ic->ic_caps & IEEE80211_C_MFP) &&
		    (ni->ni_rsncaps & IEEE80211_RSNCAP_MFPR))
			fail |= 0x40;

		/* we require MFP but AP does not support it */
		if ((ic->ic_caps & IEEE80211_C_MFP) &&
		    (ic->ic_flags & IEEE80211_F_MFPR) &&
		    !(ni->ni_rsncaps & IEEE80211_RSNCAP_MFPC))
			fail |= 0x40;
	}

	if (ic->ic_if.if_flags & IFF_DEBUG) {
		printf(" %c %s%c", fail ? '-' : '+',
		    ether_sprintf(ni->ni_bssid),
		    fail & 0x20 ? '!' : ' ');
		printf(" %3d%c", ieee80211_chan2ieee(ic, ni->ni_chan),
			fail & 0x01 ? '!' : ' ');
		printf(" %+4d", ni->ni_rssi);
		printf(" %2dM%c", (rate & IEEE80211_RATE_VAL) / 2,
		    fail & 0x08 ? '!' : ' ');
		printf(" %4s%c",
		    (ni->ni_capinfo & IEEE80211_CAPINFO_ESS) ? "ess" :
		    (ni->ni_capinfo & IEEE80211_CAPINFO_IBSS) ? "ibss" :
		    "????",
		    fail & 0x02 ? '!' : ' ');
		printf(" %7s%c ",
		    (ni->ni_capinfo & IEEE80211_CAPINFO_PRIVACY) ?
		    "privacy" : "no",
		    fail & 0x04 ? '!' : ' ');
		printf(" %3s%c ",
		    (ic->ic_flags & IEEE80211_F_RSNON) ?
		    "rsn" : "no",
		    fail & 0x40 ? '!' : ' ');
		ieee80211_print_essid(ni->ni_essid, ni->ni_esslen);
		printf("%s\n", fail & 0x10 ? "!" : "");
	}

	return fail;
}

/*
 * Complete a scan of potential channels.
 */
void
ieee80211_end_scan(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_node *ni, *nextbs, *selbs;

	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: end %s scan\n", ifp->if_xname,
			(ic->ic_flags & IEEE80211_F_ASCAN) ?
				"active" : "passive");

	if (ic->ic_scan_count)
		ic->ic_flags &= ~IEEE80211_F_ASCAN;

	ni = RBT_MIN(ieee80211_tree, &ic->ic_tree);

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
		/* XXX off stack? */
		u_char occupied[howmany(IEEE80211_CHAN_MAX, NBBY)];
		int i, fail;

		/*
		 * The passive scan to look for existing AP's completed,
		 * select a channel to camp on.  Identify the channels
		 * that already have one or more AP's and try to locate
		 * an unoccupied one.  If that fails, pick a random
		 * channel from the active set.
		 */
		memset(occupied, 0, sizeof(occupied));
		RBT_FOREACH(ni, ieee80211_tree, &ic->ic_tree)
			setbit(occupied, ieee80211_chan2ieee(ic, ni->ni_chan));
		for (i = 0; i < IEEE80211_CHAN_MAX; i++)
			if (isset(ic->ic_chan_active, i) && isclr(occupied, i))
				break;
		if (i == IEEE80211_CHAN_MAX) {
			fail = arc4random() & 3;	/* random 0-3 */
			for (i = 0; i < IEEE80211_CHAN_MAX; i++)
				if (isset(ic->ic_chan_active, i) && fail-- == 0)
					break;
		}
		ieee80211_create_ibss(ic, &ic->ic_channels[i]);
		goto wakeup;
	}
#endif
	if (ni == NULL) {
		DPRINTF(("no scan candidate\n"));
 notfound:

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_IBSS &&
		    (ic->ic_flags & IEEE80211_F_IBSSON) &&
		    ic->ic_des_esslen != 0) {
			ieee80211_create_ibss(ic, ic->ic_ibss_chan);
			goto wakeup;
		}
#endif
		/*
		 * Scan the next mode if nothing has been found. This
		 * is necessary if the device supports different
		 * incompatible modes in the same channel range, like
		 * like 11b and "pure" 11G mode.
		 * If the device scans all bands in one fell swoop, return
		 * current scan results to userspace regardless of mode.
		 * This will loop forever except for user-initiated scans.
		 */
		if (ieee80211_next_mode(ifp) == IEEE80211_MODE_AUTO ||
		    (ic->ic_caps & IEEE80211_C_SCANALLBAND)) {
			if (ic->ic_scan_lock & IEEE80211_SCAN_REQUEST &&
			    ic->ic_scan_lock & IEEE80211_SCAN_RESUME) {
				ic->ic_scan_lock = IEEE80211_SCAN_LOCKED;
				/* Return from a user-initiated scan. */
				wakeup(&ic->ic_scan_lock);
			} else if (ic->ic_scan_lock & IEEE80211_SCAN_REQUEST)
				goto wakeup;
			ic->ic_scan_count++;
		}

		/*
		 * Reset the list of channels to scan and start again.
		 */
		ieee80211_next_scan(ifp);
		return;
	}
	selbs = NULL;

	for (; ni != NULL; ni = nextbs) {
		nextbs = RBT_NEXT(ieee80211_tree, ni);
		if (ni->ni_fails) {
			/*
			 * The configuration of the access points may change
			 * during my scan.  So delete the entry for the AP
			 * and retry to associate if there is another beacon.
			 */
			if (ni->ni_fails++ > 2)
				ieee80211_free_node(ic, ni);
			continue;
		}
		if (ieee80211_match_bss(ic, ni) != 0)
			continue;

		/* Pick the AP/IBSS match with the best RSSI. */
		if (selbs == NULL)
			selbs = ni;
		else if ((ic->ic_caps & IEEE80211_C_SCANALLBAND) &&
		    IEEE80211_IS_CHAN_5GHZ(selbs->ni_chan) &&
		    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan) &&
		    ni->ni_rssi > selbs->ni_rssi) {
		    	uint8_t min_rssi = 0, max_rssi = ic->ic_max_rssi;

			/* 
			 * Prefer 5GHz (with reasonable RSSI) over 2GHz since
			 * the 5GHz band is usually less saturated.
			 */
			if (max_rssi) {
				/* Driver reports RSSI relative to maximum. */
				if (ni->ni_rssi > max_rssi / 3)
					min_rssi = ni->ni_rssi - (max_rssi / 3);
			} else {
				/* Driver reports RSSI value in dBm. */
				if (ni->ni_rssi > 10) /* XXX magic number */
		    			min_rssi = ni->ni_rssi - 10;
			}
			if (selbs->ni_rssi >= min_rssi)
				continue;
		}

		if (ni->ni_rssi > selbs->ni_rssi)
			selbs = ni;
	}
	if (selbs == NULL)
		goto notfound;
	(*ic->ic_node_copy)(ic, ic->ic_bss, selbs);
	ni = ic->ic_bss;

	ic->ic_curmode = ieee80211_chan2mode(ic, ni->ni_chan);

	/* Make sure we send valid rates in an association request. */
	if (ic->ic_opmode == IEEE80211_M_STA)
		ieee80211_fix_rate(ic, ni,
		    IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
		    IEEE80211_F_DONEGO | IEEE80211_F_DODEL);

	if (ic->ic_flags & IEEE80211_F_RSNON)
		ieee80211_choose_rsnparams(ic);
	else if (ic->ic_flags & IEEE80211_F_WEPON)
		ni->ni_rsncipher = IEEE80211_CIPHER_USEGROUP;

	ieee80211_node_newstate(selbs, IEEE80211_STA_BSS);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		ieee80211_fix_rate(ic, ni, IEEE80211_F_DOFRATE |
		    IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
		if (ni->ni_rates.rs_nrates == 0)
			goto notfound;
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	} else
#endif
		ieee80211_new_state(ic, IEEE80211_S_AUTH, -1);

 wakeup:
	if (ic->ic_scan_lock & IEEE80211_SCAN_REQUEST) {
		/* Return from a user-initiated scan. */
		wakeup(&ic->ic_scan_lock);
	}

	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;
}

/*
 * Autoselect the best RSN parameters (protocol, AKMP, pairwise cipher...)
 * that are supported by both peers (STA mode only).
 */
void
ieee80211_choose_rsnparams(struct ieee80211com *ic)
{
	struct ieee80211_node *ni = ic->ic_bss;
	struct ieee80211_pmk *pmk;

	/* filter out unsupported protocol versions */
	ni->ni_rsnprotos &= ic->ic_rsnprotos;
	/* prefer RSN (aka WPA2) over WPA */
	if (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)
		ni->ni_rsnprotos = IEEE80211_PROTO_RSN;
	else
		ni->ni_rsnprotos = IEEE80211_PROTO_WPA;

	/* filter out unsupported AKMPs */
	ni->ni_rsnakms &= ic->ic_rsnakms;
	/* prefer SHA-256 based AKMPs */
	if ((ic->ic_flags & IEEE80211_F_PSK) && (ni->ni_rsnakms &
	    (IEEE80211_AKM_PSK | IEEE80211_AKM_SHA256_PSK))) {
		/* AP supports PSK AKMP and a PSK is configured */
		if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_PSK)
			ni->ni_rsnakms = IEEE80211_AKM_SHA256_PSK;
		else
			ni->ni_rsnakms = IEEE80211_AKM_PSK;
	} else {
		if (ni->ni_rsnakms & IEEE80211_AKM_SHA256_8021X)
			ni->ni_rsnakms = IEEE80211_AKM_SHA256_8021X;
		else
			ni->ni_rsnakms = IEEE80211_AKM_8021X;
		/* check if we have a cached PMK for this AP */
		if (ni->ni_rsnprotos == IEEE80211_PROTO_RSN &&
		    (pmk = ieee80211_pmksa_find(ic, ni, NULL)) != NULL) {
			memcpy(ni->ni_pmkid, pmk->pmk_pmkid,
			    IEEE80211_PMKID_LEN);
			ni->ni_flags |= IEEE80211_NODE_PMKID;
		}
	}

	/* filter out unsupported pairwise ciphers */
	ni->ni_rsnciphers &= ic->ic_rsnciphers;
	/* prefer CCMP over TKIP */
	if (ni->ni_rsnciphers & IEEE80211_CIPHER_CCMP)
		ni->ni_rsnciphers = IEEE80211_CIPHER_CCMP;
	else
		ni->ni_rsnciphers = IEEE80211_CIPHER_TKIP;
	ni->ni_rsncipher = ni->ni_rsnciphers;

	/* use MFP if we both support it */
	if ((ic->ic_caps & IEEE80211_C_MFP) &&
	    (ni->ni_rsncaps & IEEE80211_RSNCAP_MFPC))
		ni->ni_flags |= IEEE80211_NODE_MFP;
}

int
ieee80211_get_rate(struct ieee80211com *ic)
{
	u_int8_t (*rates)[IEEE80211_RATE_MAXSIZE];
	int rate;

	rates = &ic->ic_bss->ni_rates.rs_rates;

	if (ic->ic_fixed_rate != -1)
		rate = (*rates)[ic->ic_fixed_rate];
	else if (ic->ic_state == IEEE80211_S_RUN)
		rate = (*rates)[ic->ic_bss->ni_txrate];
	else
		rate = 0;

	return rate & IEEE80211_RATE_VAL;
}

struct ieee80211_node *
ieee80211_node_alloc(struct ieee80211com *ic)
{
	return malloc(sizeof(struct ieee80211_node), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
}

void
ieee80211_node_cleanup(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	if (ni->ni_rsnie != NULL) {
		free(ni->ni_rsnie, M_DEVBUF, 2 + ni->ni_rsnie[1]);
		ni->ni_rsnie = NULL;
	}
	ieee80211_ba_del(ni);
}

void
ieee80211_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	ieee80211_node_cleanup(ic, ni);
	free(ni, M_DEVBUF, 0);
}

void
ieee80211_node_copy(struct ieee80211com *ic,
	struct ieee80211_node *dst, const struct ieee80211_node *src)
{
	ieee80211_node_cleanup(ic, dst);
	*dst = *src;
	dst->ni_rsnie = NULL;
	if (src->ni_rsnie != NULL)
		ieee80211_save_ie(src->ni_rsnie, &dst->ni_rsnie);
}

u_int8_t
ieee80211_node_getrssi(struct ieee80211com *ic,
    const struct ieee80211_node *ni)
{
	return ni->ni_rssi;
}

void
ieee80211_setup_node(struct ieee80211com *ic,
	struct ieee80211_node *ni, const u_int8_t *macaddr)
{
	int s;

	DPRINTF(("%s\n", ether_sprintf((u_int8_t *)macaddr)));
	IEEE80211_ADDR_COPY(ni->ni_macaddr, macaddr);
	ieee80211_node_newstate(ni, IEEE80211_STA_CACHE);

	ni->ni_ic = ic;	/* back-pointer */
#ifndef IEEE80211_STA_ONLY
	mq_init(&ni->ni_savedq, IEEE80211_PS_MAX_QUEUE, IPL_NET);
	timeout_set(&ni->ni_eapol_to, ieee80211_eapol_timeout, ni);
	timeout_set(&ni->ni_sa_query_to, ieee80211_sa_query_timeout, ni);
#endif
	s = splnet();
	RBT_INSERT(ieee80211_tree, &ic->ic_tree, ni);
	ic->ic_nnodes++;
	splx(s);
}

struct ieee80211_node *
ieee80211_alloc_node(struct ieee80211com *ic, const u_int8_t *macaddr)
{
	struct ieee80211_node *ni = ieee80211_alloc_node_helper(ic);
	if (ni != NULL)
		ieee80211_setup_node(ic, ni, macaddr);
	else
		ic->ic_stats.is_rx_nodealloc++;
	return ni;
}

struct ieee80211_node *
ieee80211_dup_bss(struct ieee80211com *ic, const u_int8_t *macaddr)
{
	struct ieee80211_node *ni = ieee80211_alloc_node_helper(ic);
	if (ni != NULL) {
		ieee80211_setup_node(ic, ni, macaddr);
		/*
		 * Inherit from ic_bss.
		 */
		IEEE80211_ADDR_COPY(ni->ni_bssid, ic->ic_bss->ni_bssid);
		ni->ni_chan = ic->ic_bss->ni_chan;
	} else
		ic->ic_stats.is_rx_nodealloc++;
	return ni;
}

struct ieee80211_node *
ieee80211_find_node(struct ieee80211com *ic, const u_int8_t *macaddr)
{
	struct ieee80211_node *ni;
	int cmp;

	/* similar to RBT_FIND except we compare keys, not nodes */
	ni = RBT_ROOT(ieee80211_tree, &ic->ic_tree);
	while (ni != NULL) {
		cmp = memcmp(macaddr, ni->ni_macaddr, IEEE80211_ADDR_LEN);
		if (cmp < 0)
			ni = RBT_LEFT(ieee80211_tree, ni);
		else if (cmp > 0)
			ni = RBT_RIGHT(ieee80211_tree, ni);
		else
			break;
	}
	return ni;
}

/*
 * Return a reference to the appropriate node for sending
 * a data frame.  This handles node discovery in adhoc networks.
 *
 * Drivers will call this, so increase the reference count before
 * returning the node.
 */
struct ieee80211_node *
ieee80211_find_txnode(struct ieee80211com *ic, const u_int8_t *macaddr)
{
#ifndef IEEE80211_STA_ONLY
	struct ieee80211_node *ni;
	int s;
#endif

	/*
	 * The destination address should be in the node table
	 * unless we are operating in station mode or this is a
	 * multicast/broadcast frame.
	 */
	if (ic->ic_opmode == IEEE80211_M_STA || IEEE80211_IS_MULTICAST(macaddr))
		return ieee80211_ref_node(ic->ic_bss);

#ifndef IEEE80211_STA_ONLY
	s = splnet();
	ni = ieee80211_find_node(ic, macaddr);
	splx(s);
	if (ni == NULL) {
		if (ic->ic_opmode != IEEE80211_M_IBSS &&
		    ic->ic_opmode != IEEE80211_M_AHDEMO)
			return NULL;

		/*
		 * Fake up a node; this handles node discovery in
		 * adhoc mode.  Note that for the driver's benefit
		 * we we treat this like an association so the driver
		 * has an opportunity to setup its private state.
		 *
		 * XXX need better way to handle this; issue probe
		 *     request so we can deduce rate set, etc.
		 */
		if ((ni = ieee80211_dup_bss(ic, macaddr)) == NULL)
			return NULL;
		/* XXX no rate negotiation; just dup */
		ni->ni_rates = ic->ic_bss->ni_rates;
		ni->ni_txrate = 0;
		if (ic->ic_newassoc)
			(*ic->ic_newassoc)(ic, ni, 1);
	}
	return ieee80211_ref_node(ni);
#else
	return NULL;	/* can't get there */
#endif	/* IEEE80211_STA_ONLY */
}

/*
 * It is usually desirable to process a Rx packet using its sender's
 * node-record instead of the BSS record.
 *
 * - AP mode: keep a node-record for every authenticated/associated
 *   station *in the BSS*. For future use, we also track neighboring
 *   APs, since they might belong to the same ESS.  APs in the same
 *   ESS may bridge packets to each other, forming a Wireless
 *   Distribution System (WDS).
 *
 * - IBSS mode: keep a node-record for every station *in the BSS*.
 *   Also track neighboring stations by their beacons/probe responses.
 *
 * - monitor mode: keep a node-record for every sender, regardless
 *   of BSS.
 *
 * - STA mode: the only available node-record is the BSS record,
 *   ic->ic_bss.
 *
 * Of all the 802.11 Control packets, only the node-records for
 * RTS packets node-record can be looked up.
 *
 * Return non-zero if the packet's node-record is kept, zero
 * otherwise.
 */
static __inline int
ieee80211_needs_rxnode(struct ieee80211com *ic,
    const struct ieee80211_frame *wh, const u_int8_t **bssid)
{
	int monitor, rc = 0;

	monitor = (ic->ic_opmode == IEEE80211_M_MONITOR);

	*bssid = NULL;

	switch (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) {
	case IEEE80211_FC0_TYPE_CTL:
		if (!monitor)
			break;
		return (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
		    IEEE80211_FC0_SUBTYPE_RTS;
	case IEEE80211_FC0_TYPE_MGT:
		*bssid = wh->i_addr3;
		switch (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) {
		case IEEE80211_FC0_SUBTYPE_BEACON:
		case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
			break;
		default:
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_STA)
				break;
			rc = IEEE80211_ADDR_EQ(*bssid, ic->ic_bss->ni_bssid) ||
			     IEEE80211_ADDR_EQ(*bssid, etherbroadcastaddr);
#endif
			break;
		}
		break;
	case IEEE80211_FC0_TYPE_DATA:
		switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
		case IEEE80211_FC1_DIR_NODS:
			*bssid = wh->i_addr3;
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_IBSS ||
			    ic->ic_opmode == IEEE80211_M_AHDEMO)
				rc = IEEE80211_ADDR_EQ(*bssid,
				    ic->ic_bss->ni_bssid);
#endif
			break;
		case IEEE80211_FC1_DIR_TODS:
			*bssid = wh->i_addr1;
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP)
				rc = IEEE80211_ADDR_EQ(*bssid,
				    ic->ic_bss->ni_bssid);
#endif
			break;
		case IEEE80211_FC1_DIR_FROMDS:
		case IEEE80211_FC1_DIR_DSTODS:
			*bssid = wh->i_addr2;
#ifndef IEEE80211_STA_ONLY
			rc = (ic->ic_opmode == IEEE80211_M_HOSTAP);
#endif
			break;
		}
		break;
	}
	return monitor || rc;
}

/* 
 * Drivers call this, so increase the reference count before returning
 * the node.
 */
struct ieee80211_node *
ieee80211_find_rxnode(struct ieee80211com *ic,
    const struct ieee80211_frame *wh)
{
	static const u_int8_t zero[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
	struct ieee80211_node *ni;
	const u_int8_t *bssid;
	int s;

	if (!ieee80211_needs_rxnode(ic, wh, &bssid))
		return ieee80211_ref_node(ic->ic_bss);

	s = splnet();
	ni = ieee80211_find_node(ic, wh->i_addr2);
	splx(s);

	if (ni != NULL)
		return ieee80211_ref_node(ni);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		return ieee80211_ref_node(ic->ic_bss);
#endif
	/* XXX see remarks in ieee80211_find_txnode */
	/* XXX no rate negotiation; just dup */
	if ((ni = ieee80211_dup_bss(ic, wh->i_addr2)) == NULL)
		return ieee80211_ref_node(ic->ic_bss);

	IEEE80211_ADDR_COPY(ni->ni_bssid, (bssid != NULL) ? bssid : zero);

	ni->ni_rates = ic->ic_bss->ni_rates;
	ni->ni_txrate = 0;
	if (ic->ic_newassoc)
		(*ic->ic_newassoc)(ic, ni, 1);

	DPRINTF(("faked-up node %p for %s\n", ni,
	    ether_sprintf((u_int8_t *)wh->i_addr2)));

	return ieee80211_ref_node(ni);
}

struct ieee80211_node *
ieee80211_find_node_for_beacon(struct ieee80211com *ic,
    const u_int8_t *macaddr, const struct ieee80211_channel *chan,
    const char *ssid, u_int8_t rssi)
{
	struct ieee80211_node *ni, *keep = NULL;
	int s, score = 0;

	if ((ni = ieee80211_find_node(ic, macaddr)) != NULL) {
		s = splnet();

		if (ni->ni_chan != chan && ni->ni_rssi >= rssi)
			score++;
		if (ssid[1] == 0 && ni->ni_esslen != 0)
			score++;
		if (score > 0)
			keep = ni;

		splx(s);
	}

	return (keep);
}

void
ieee80211_ba_del(struct ieee80211_node *ni)
{
	int tid;

	for (tid = 0; tid < nitems(ni->ni_rx_ba); tid++) {
		struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
		if (ba->ba_state != IEEE80211_BA_INIT) {
			if (timeout_pending(&ba->ba_to))
				timeout_del(&ba->ba_to);
			if (timeout_pending(&ba->ba_gap_to))
				timeout_del(&ba->ba_gap_to);
			ba->ba_state = IEEE80211_BA_INIT;
		}
	}

	for (tid = 0; tid < nitems(ni->ni_tx_ba); tid++) {
		struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];
		if (ba->ba_state != IEEE80211_BA_INIT) {
			if (timeout_pending(&ba->ba_to))
				timeout_del(&ba->ba_to);
			ba->ba_state = IEEE80211_BA_INIT;
		}
	}
}

void
ieee80211_free_node(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	if (ni == ic->ic_bss)
		panic("freeing bss node");

	splassert(IPL_NET);

	DPRINTF(("%s\n", ether_sprintf(ni->ni_macaddr)));
#ifndef IEEE80211_STA_ONLY
	timeout_del(&ni->ni_eapol_to);
	timeout_del(&ni->ni_sa_query_to);
	IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
#endif
	ieee80211_ba_del(ni);
	RBT_REMOVE(ieee80211_tree, &ic->ic_tree, ni);
	ic->ic_nnodes--;
#ifndef IEEE80211_STA_ONLY
	if (mq_purge(&ni->ni_savedq) > 0) {
		if (ic->ic_set_tim != NULL)
			(*ic->ic_set_tim)(ic, ni->ni_associd, 0);
	}
#endif
	(*ic->ic_node_free)(ic, ni);
	/* TBD indicate to drivers that a new node can be allocated */
}

void
ieee80211_release_node(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	int s;

	DPRINTF(("%s refcnt %u\n", ether_sprintf(ni->ni_macaddr),
	    ni->ni_refcnt));
	s = splnet();
	if (ieee80211_node_decref(ni) == 0 &&
	    ni->ni_state == IEEE80211_STA_COLLECT) {
		ieee80211_free_node(ic, ni);
	}
	splx(s);
}

void
ieee80211_free_allnodes(struct ieee80211com *ic)
{
	struct ieee80211_node *ni;
	int s;

	DPRINTF(("freeing all nodes\n"));
	s = splnet();
	while ((ni = RBT_MIN(ieee80211_tree, &ic->ic_tree)) != NULL)
		ieee80211_free_node(ic, ni);
	splx(s);

	if (ic->ic_bss != NULL)
		ieee80211_node_cleanup(ic, ic->ic_bss);	/* for station mode */
}

void
ieee80211_clean_cached(struct ieee80211com *ic)
{
	struct ieee80211_node *ni, *next_ni;
	int s;

	s = splnet();
	for (ni = RBT_MIN(ieee80211_tree, &ic->ic_tree);
	    ni != NULL; ni = next_ni) {
		next_ni = RBT_NEXT(ieee80211_tree, ni);
		if (ni->ni_state == IEEE80211_STA_CACHE)
			ieee80211_free_node(ic, ni);
	}
	splx(s);
}
/*
 * Timeout inactive nodes.
 *
 * If called because of a cache timeout, which happens only in hostap and ibss
 * modes, clean all inactive cached or authenticated nodes but don't de-auth
 * any associated nodes. Also update HT protection settings.
 *
 * Else, this function is called because a new node must be allocated but the
 * node cache is full. In this case, return as soon as a free slot was made
 * available. If acting as hostap, clean cached nodes regardless of their
 * recent activity and also allow de-authing of authenticated nodes older
 * than one cache wait interval, and de-authing of inactive associated nodes.
 */
void
ieee80211_clean_nodes(struct ieee80211com *ic, int cache_timeout)
{
	struct ieee80211_node *ni, *next_ni;
	u_int gen = ic->ic_scangen++;		/* NB: ok 'cuz single-threaded*/
	int s;
#ifndef IEEE80211_STA_ONLY
	int nnodes = 0, nonht = 0, nonhtassoc = 0;
	struct ifnet *ifp = &ic->ic_if;
	enum ieee80211_htprot htprot = IEEE80211_HTPROT_NONE;
	enum ieee80211_protmode protmode = IEEE80211_PROT_NONE;
#endif

	s = splnet();
	for (ni = RBT_MIN(ieee80211_tree, &ic->ic_tree);
	    ni != NULL; ni = next_ni) {
		next_ni = RBT_NEXT(ieee80211_tree, ni);
		if (!cache_timeout && ic->ic_nnodes < ic->ic_max_nnodes)
			break;
		if (ni->ni_scangen == gen)	/* previously handled */
			continue;
#ifndef IEEE80211_STA_ONLY
		nnodes++;
		if ((ic->ic_flags & IEEE80211_F_HTON) && cache_timeout) {
			if ((ni->ni_rxmcs[0] & 0xff) == 0) {
				nonht++;
				if (ni->ni_state == IEEE80211_STA_ASSOC)
					nonhtassoc++;
			}
		}
#endif
		ni->ni_scangen = gen;
		if (ni->ni_refcnt > 0)
			continue;
#ifndef IEEE80211_STA_ONLY
		if ((ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS) &&
		    ic->ic_state == IEEE80211_S_RUN) {
			if (cache_timeout) {
				if (ni->ni_state != IEEE80211_STA_COLLECT &&
				    (ni->ni_state == IEEE80211_STA_ASSOC ||
				    ni->ni_inact < IEEE80211_INACT_MAX))
					continue;
			} else {
				if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
				    ((ni->ni_state == IEEE80211_STA_ASSOC &&
				    ni->ni_inact < IEEE80211_INACT_MAX) ||
				    (ni->ni_state == IEEE80211_STA_AUTH &&
				     ni->ni_inact == 0)))
				    	continue;

				if (ic->ic_opmode == IEEE80211_M_IBSS &&
				    ni->ni_state != IEEE80211_STA_COLLECT &&
				    ni->ni_state != IEEE80211_STA_CACHE &&
				    ni->ni_inact < IEEE80211_INACT_MAX)
					continue;
			}
		}
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s purged from node cache\n",
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr));
#endif
		/*
		 * If we're hostap and the node is authenticated, send
		 * a deauthentication frame. The node will be freed when
		 * the driver calls ieee80211_release_node().
		 */
#ifndef IEEE80211_STA_ONLY
		nnodes--;
		if ((ic->ic_flags & IEEE80211_F_HTON) && cache_timeout) {
			if ((ni->ni_rxmcs[0] & 0xff) == 0) {
				nonht--;
				if (ni->ni_state == IEEE80211_STA_ASSOC)
					nonhtassoc--;
			}
		}
		if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
		    ni->ni_state >= IEEE80211_STA_AUTH &&
		    ni->ni_state != IEEE80211_STA_COLLECT) {
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_DEAUTH,
			    IEEE80211_REASON_AUTH_EXPIRE);
			ieee80211_node_leave(ic, ni);
		} else
#endif
			ieee80211_free_node(ic, ni);
		ic->ic_stats.is_node_timeout++;
	}

#ifndef IEEE80211_STA_ONLY
	if ((ic->ic_flags & IEEE80211_F_HTON) && cache_timeout) {
		/* Update HT protection settings. */
		if (nonht) {
			protmode = IEEE80211_PROT_RTSCTS;
			if (nonhtassoc)
				htprot = IEEE80211_HTPROT_NONHT_MIXED;
			else
				htprot = IEEE80211_HTPROT_NONMEMBER;
		}
		if (ic->ic_bss->ni_htop1 != htprot) {
			ic->ic_bss->ni_htop1 = htprot;
			ic->ic_protmode = protmode;
			if (ic->ic_update_htprot)
				ic->ic_update_htprot(ic, ic->ic_bss);
		}
	}

	/* 
	 * During a cache timeout we iterate over all nodes.
	 * Check for node leaks by comparing the actual number of cached
	 * nodes with the ic_nnodes count, which is maintained while adding
	 * and removing nodes from the cache.
	 */
	if ((ifp->if_flags & IFF_DEBUG) && cache_timeout &&
	    nnodes != ic->ic_nnodes)
		printf("%s: number of cached nodes is %d, expected %d,"
		    "possible nodes leak\n", ifp->if_xname, nnodes,
		    ic->ic_nnodes);
#endif
	splx(s);
}

void
ieee80211_iterate_nodes(struct ieee80211com *ic, ieee80211_iter_func *f,
    void *arg)
{
	struct ieee80211_node *ni;
	int s;

	s = splnet();
	RBT_FOREACH(ni, ieee80211_tree, &ic->ic_tree)
		(*f)(arg, ni);
	splx(s);
}


/*
 * Install received HT caps information in the node's state block.
 */
void
ieee80211_setup_htcaps(struct ieee80211_node *ni, const uint8_t *data,
    uint8_t len)
{
	uint16_t rxrate;

	if (len != 26)
		return;

	ni->ni_htcaps = (data[0] | (data[1] << 8));
	ni->ni_ampdu_param = data[2];

	memcpy(ni->ni_rxmcs, &data[3], sizeof(ni->ni_rxmcs));
	/* clear reserved bits */
	clrbit(ni->ni_rxmcs, 77);
	clrbit(ni->ni_rxmcs, 78);
	clrbit(ni->ni_rxmcs, 79);

	/* Max MCS Rx rate in 1Mb/s units (0 means "not specified"). */
	rxrate = ((data[13] | (data[14]) << 8) & IEEE80211_MCS_RX_RATE_HIGH);
	if (rxrate < 1024)
		ni->ni_max_rxrate = rxrate;

	ni->ni_tx_mcs_set = data[15];
	ni->ni_htxcaps = (data[19] | (data[20] << 8));
	ni->ni_txbfcaps = (data[21] | (data[22] << 8) | (data[23] << 16) |
		(data[24] << 24));
	ni->ni_aselcaps = data[25];
}

#ifndef IEEE80211_STA_ONLY
/* 
 * Handle nodes switching from 11n into legacy modes.
 */
void
ieee80211_clear_htcaps(struct ieee80211_node *ni)
{
	ni->ni_htcaps = 0;
	ni->ni_ampdu_param = 0;
	memset(ni->ni_rxmcs, 0, sizeof(ni->ni_rxmcs));
	ni->ni_max_rxrate = 0;
	ni->ni_tx_mcs_set = 0;
	ni->ni_htxcaps = 0;
	ni->ni_txbfcaps = 0;
	ni->ni_aselcaps = 0;

	ni->ni_flags &= ~IEEE80211_NODE_HT;

}
#endif

/*
 * Install received HT op information in the node's state block.
 */
int
ieee80211_setup_htop(struct ieee80211_node *ni, const uint8_t *data,
    uint8_t len)
{
	if (len != 22)
		return 0;

	ni->ni_primary_chan = data[0]; /* XXX corresponds to ni_chan */

	ni->ni_htop0 = data[1];
	ni->ni_htop1 = (data[2] | (data[3] << 8));
	ni->ni_htop2 = (data[3] | (data[4] << 8));

	memcpy(ni->ni_basic_mcs, &data[6], sizeof(ni->ni_basic_mcs));

	return 1;
}

/*
 * Install received rate set information in the node's state block.
 */
int
ieee80211_setup_rates(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *rates, const u_int8_t *xrates, int flags)
{
	struct ieee80211_rateset *rs = &ni->ni_rates;

	memset(rs, 0, sizeof(*rs));
	rs->rs_nrates = rates[1];
	memcpy(rs->rs_rates, rates + 2, rs->rs_nrates);
	if (xrates != NULL) {
		u_int8_t nxrates;
		/*
		 * Tack on 11g extended supported rate element.
		 */
		nxrates = xrates[1];
		if (rs->rs_nrates + nxrates > IEEE80211_RATE_MAXSIZE) {
			nxrates = IEEE80211_RATE_MAXSIZE - rs->rs_nrates;
			DPRINTF(("extended rate set too large; "
			    "only using %u of %u rates\n",
			    nxrates, xrates[1]));
			ic->ic_stats.is_rx_rstoobig++;
		}
		memcpy(rs->rs_rates + rs->rs_nrates, xrates+2, nxrates);
		rs->rs_nrates += nxrates;
	}
	return ieee80211_fix_rate(ic, ni, flags);
}

#ifndef IEEE80211_STA_ONLY
/*
 * Check if the specified node supports ERP.
 */
int
ieee80211_iserp_sta(const struct ieee80211_node *ni)
{
	static const u_int8_t rates[] = { 2, 4, 11, 22, 12, 24, 48 };
	const struct ieee80211_rateset *rs = &ni->ni_rates;
	int i, j;

	/*
	 * A STA supports ERP operation if it includes all the Clause 19
	 * mandatory rates in its supported rate set.
	 */
	for (i = 0; i < nitems(rates); i++) {
		for (j = 0; j < rs->rs_nrates; j++) {
			if ((rs->rs_rates[j] & IEEE80211_RATE_VAL) == rates[i])
				break;
		}
		if (j == rs->rs_nrates)
			return 0;
	}
	return 1;
}

/*
 * This function is called to notify the 802.1X PACP machine that a new
 * 802.1X port is enabled and must be authenticated. For 802.11, a port
 * becomes enabled whenever a STA successfully completes Open System
 * authentication with an AP.
 */
void
ieee80211_needs_auth(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	/*
	 * XXX this could be done via the route socket of via a dedicated
	 * EAP socket or another kernel->userland notification mechanism.
	 * The notification should include the MAC address (ni_macaddr).
	 */
}

/*
 * Handle an HT STA joining an HT network.
 */
void
ieee80211_node_join_ht(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	enum ieee80211_htprot;

	/* Update HT protection setting. */
	if ((ni->ni_flags & IEEE80211_NODE_HT) == 0) {
		ic->ic_bss->ni_htop1 = IEEE80211_HTPROT_NONHT_MIXED;
		if (ic->ic_update_htprot)
			ic->ic_update_htprot(ic, ic->ic_bss);
	}
}

/*
 * Handle a station joining an RSN network.
 */
void
ieee80211_node_join_rsn(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	DPRINTF(("station %s associated using proto %d akm 0x%x "
	    "cipher 0x%x groupcipher 0x%x\n", ether_sprintf(ni->ni_macaddr),
	    ni->ni_rsnprotos, ni->ni_rsnakms, ni->ni_rsnciphers,
	    ni->ni_rsngroupcipher));

	ni->ni_rsn_state = RSNA_AUTHENTICATION;

	ni->ni_key_count = 0;
	ni->ni_port_valid = 0;
	ni->ni_flags &= ~IEEE80211_NODE_TXRXPROT;
	ni->ni_flags &= ~IEEE80211_NODE_RSN_NEW_PTK;
	ni->ni_replaycnt = -1;	/* XXX */
	ni->ni_rsn_retries = 0;
	ni->ni_rsncipher = ni->ni_rsnciphers;

	ni->ni_rsn_state = RSNA_AUTHENTICATION_2;

	/* generate a new authenticator nonce (ANonce) */
	arc4random_buf(ni->ni_nonce, EAPOL_KEY_NONCE_LEN);

	if (!ieee80211_is_8021x_akm(ni->ni_rsnakms)) {
		memcpy(ni->ni_pmk, ic->ic_psk, IEEE80211_PMK_LEN);
		ni->ni_flags |= IEEE80211_NODE_PMK;
		(void)ieee80211_send_4way_msg1(ic, ni);
	} else if (ni->ni_flags & IEEE80211_NODE_PMK) {
		/* skip 802.1X auth if a cached PMK was found */
		(void)ieee80211_send_4way_msg1(ic, ni);
	} else {
		/* no cached PMK found, needs full 802.1X auth */
		ieee80211_needs_auth(ic, ni);
	}
}

void
ieee80211_count_longslotsta(void *arg, struct ieee80211_node *ni)
{
	int *longslotsta = arg;

	if (ni->ni_associd == 0 || ni->ni_state == IEEE80211_STA_COLLECT)
		return;

	if (!(ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME))
		(*longslotsta)++;
}

void
ieee80211_count_nonerpsta(void *arg, struct ieee80211_node *ni)
{
	int *nonerpsta = arg;

	if (ni->ni_associd == 0 || ni->ni_state == IEEE80211_STA_COLLECT)
		return;

	if (!ieee80211_iserp_sta(ni))
		(*nonerpsta)++;
}

void
ieee80211_count_pssta(void *arg, struct ieee80211_node *ni)
{
	int *pssta = arg;

	if (ni->ni_associd == 0 || ni->ni_state == IEEE80211_STA_COLLECT)
		return;

 	if (ni->ni_pwrsave == IEEE80211_PS_DOZE)
		(*pssta)++;
}

void
ieee80211_count_rekeysta(void *arg, struct ieee80211_node *ni)
{
	int *rekeysta = arg;

	if (ni->ni_associd == 0 || ni->ni_state == IEEE80211_STA_COLLECT)
		return;

	if (ni->ni_flags & IEEE80211_NODE_REKEY)
		(*rekeysta)++;
}

/*
 * Handle a station joining an 11g network.
 */
void
ieee80211_node_join_11g(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	int longslotsta = 0, nonerpsta = 0;

	if (!(ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME)) {
		/*
		 * Joining STA doesn't support short slot time.  We must
		 * disable the use of short slot time for all other associated
		 * STAs and give the driver a chance to reconfigure the
		 * hardware.
		 */
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_longslotsta, &longslotsta);
		if (longslotsta == 1) {
			if (ic->ic_caps & IEEE80211_C_SHSLOT)
				ieee80211_set_shortslottime(ic, 0);
		}
		DPRINTF(("[%s] station needs long slot time, count %d\n",
		    ether_sprintf(ni->ni_macaddr), longslotsta));
	}

	if (!ieee80211_iserp_sta(ni)) {
		/*
		 * Joining STA is non-ERP.
		 */
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_nonerpsta, &nonerpsta);
		DPRINTF(("[%s] station is non-ERP, %d non-ERP "
		    "stations associated\n", ether_sprintf(ni->ni_macaddr),
		    nonerpsta));
		/* must enable the use of protection */
		if (ic->ic_protmode != IEEE80211_PROT_NONE) {
			DPRINTF(("enable use of protection\n"));
			ic->ic_flags |= IEEE80211_F_USEPROT;
		}

		if (!(ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE))
			ic->ic_flags &= ~IEEE80211_F_SHPREAMBLE;
	} else
		ni->ni_flags |= IEEE80211_NODE_ERP;
}

void
ieee80211_node_join(struct ieee80211com *ic, struct ieee80211_node *ni,
    int resp)
{
	int newassoc = (ni->ni_state != IEEE80211_STA_ASSOC);

	if (ni->ni_associd == 0) {
		u_int16_t aid;

		/*
		 * It would be clever to search the bitmap
		 * more efficiently, but this will do for now.
		 */
		for (aid = 1; aid < ic->ic_max_aid; aid++) {
			if (!IEEE80211_AID_ISSET(aid,
			    ic->ic_aid_bitmap))
				break;
		}
		if (aid >= ic->ic_max_aid) {
			IEEE80211_SEND_MGMT(ic, ni, resp,
			    IEEE80211_REASON_ASSOC_TOOMANY);
			ieee80211_node_leave(ic, ni);
			return;
		}
		ni->ni_associd = aid | 0xc000;
		IEEE80211_AID_SET(ni->ni_associd, ic->ic_aid_bitmap);
		if (ic->ic_curmode == IEEE80211_MODE_11G ||
		    (ic->ic_curmode == IEEE80211_MODE_11N &&
		    IEEE80211_IS_CHAN_2GHZ(ic->ic_bss->ni_chan)))
			ieee80211_node_join_11g(ic, ni);
	}

	DPRINTF(("station %s %s associated at aid %d\n",
	    ether_sprintf(ni->ni_macaddr), newassoc ? "newly" : "already",
	    ni->ni_associd & ~0xc000));

	ieee80211_ht_negotiate(ic, ni);
	if (ic->ic_flags & IEEE80211_F_HTON)
		ieee80211_node_join_ht(ic, ni);

	/* give driver a chance to setup state like ni_txrate */
	if (ic->ic_newassoc)
		(*ic->ic_newassoc)(ic, ni, newassoc);
	IEEE80211_SEND_MGMT(ic, ni, resp, IEEE80211_STATUS_SUCCESS);
	ieee80211_node_newstate(ni, IEEE80211_STA_ASSOC);

	if (!(ic->ic_flags & IEEE80211_F_RSNON)) {
		ni->ni_port_valid = 1;
		ni->ni_rsncipher = IEEE80211_CIPHER_USEGROUP;
	} else
		ieee80211_node_join_rsn(ic, ni);

#if NBRIDGE > 0
	/*
	 * If the parent interface is a bridgeport, learn
	 * the node's address dynamically on this interface.
	 */
	if (ic->ic_if.if_bridgeport != NULL)
		bridge_update(&ic->ic_if,
		    (struct ether_addr *)ni->ni_macaddr, 0);
#endif
}

/*
 * Handle an HT STA leaving an HT network.
 */
void
ieee80211_node_leave_ht(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct ieee80211_rx_ba *ba;
	u_int8_t tid;
	int i;

	/* free all Block Ack records */
	ieee80211_ba_del(ni);
	for (tid = 0; tid < IEEE80211_NUM_TID; tid++) {
		ba = &ni->ni_rx_ba[tid];
		if (ba->ba_buf != NULL) {
			for (i = 0; i < IEEE80211_BA_MAX_WINSZ; i++)
				m_freem(ba->ba_buf[i].m);
			free(ba->ba_buf, M_DEVBUF,
			    IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf));
			ba->ba_buf = NULL;
		}
	}

	ieee80211_clear_htcaps(ni);
}

/*
 * Handle a station leaving an RSN network.
 */
void
ieee80211_node_leave_rsn(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	int rekeysta = 0;

	ni->ni_rsn_state = RSNA_DISCONNECTED;

	ni->ni_rsn_state = RSNA_INITIALIZE;
	if (ni->ni_flags & IEEE80211_NODE_REKEY) {
		ni->ni_flags &= ~IEEE80211_NODE_REKEY;
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_rekeysta, &rekeysta);
		if (rekeysta == 0)
			ieee80211_setkeysdone(ic);
	}
	ni->ni_flags &= ~IEEE80211_NODE_PMK;
	ni->ni_rsn_gstate = RSNA_IDLE;

	timeout_del(&ni->ni_eapol_to);
	timeout_del(&ni->ni_sa_query_to);

	ni->ni_rsn_retries = 0;
	ni->ni_flags &= ~IEEE80211_NODE_TXRXPROT;
	ni->ni_port_valid = 0;
	(*ic->ic_delete_key)(ic, ni, &ni->ni_pairwise_key);
}

/*
 * Handle a station leaving an 11g network.
 */
void
ieee80211_node_leave_11g(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	int longslotsta = 0, nonerpsta = 0;

	if (!(ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME)) {
		/* leaving STA did not support short slot time */
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_longslotsta, &longslotsta);
		if (longslotsta == 1) {
			/*
			 * All associated STAs now support short slot time, so
			 * enable this feature and give the driver a chance to
			 * reconfigure the hardware. Notice that IBSS always
			 * use a long slot time.
			 */
			if ((ic->ic_caps & IEEE80211_C_SHSLOT) &&
			    ic->ic_opmode != IEEE80211_M_IBSS)
				ieee80211_set_shortslottime(ic, 1);
		}
		DPRINTF(("[%s] long slot time station leaves, count %d\n",
		    ether_sprintf(ni->ni_macaddr), longslotsta));
	}

	if (!(ni->ni_flags & IEEE80211_NODE_ERP)) {
		/* leaving STA was non-ERP */
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_nonerpsta, &nonerpsta);
		if (nonerpsta == 1) {
			/*
			 * All associated STAs are now ERP capable, disable use
			 * of protection and re-enable short preamble support.
			 */
			ic->ic_flags &= ~IEEE80211_F_USEPROT;
			if (ic->ic_caps & IEEE80211_C_SHPREAMBLE)
				ic->ic_flags |= IEEE80211_F_SHPREAMBLE;
		}
		DPRINTF(("[%s] non-ERP station leaves, count %d\n",
		    ether_sprintf(ni->ni_macaddr), nonerpsta));
	}
}

/*
 * Handle bookkeeping for station deauthentication/disassociation
 * when operating as an ap.
 */
void
ieee80211_node_leave(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	if (ic->ic_opmode != IEEE80211_M_HOSTAP)
		panic("not in ap mode, mode %u", ic->ic_opmode);

	if (ni->ni_state == IEEE80211_STA_COLLECT)
		return;
	/*
	 * If node wasn't previously associated all we need to do is
	 * reclaim the reference.
	 */
	if (ni->ni_associd == 0) {
		ieee80211_node_newstate(ni, IEEE80211_STA_COLLECT);
		return;
	}

	if (ni->ni_pwrsave == IEEE80211_PS_DOZE)
		ni->ni_pwrsave = IEEE80211_PS_AWAKE;

	if (mq_purge(&ni->ni_savedq) > 0) {
		if (ic->ic_set_tim != NULL)
			(*ic->ic_set_tim)(ic, ni->ni_associd, 0);
	}

	if (ic->ic_flags & IEEE80211_F_RSNON)
		ieee80211_node_leave_rsn(ic, ni);

	if (ic->ic_curmode == IEEE80211_MODE_11G ||
	    (ic->ic_curmode == IEEE80211_MODE_11N &&
	    IEEE80211_IS_CHAN_2GHZ(ic->ic_bss->ni_chan)))
		ieee80211_node_leave_11g(ic, ni);

	if (ni->ni_flags & IEEE80211_NODE_HT)
		ieee80211_node_leave_ht(ic, ni);

	if (ic->ic_node_leave != NULL)
		(*ic->ic_node_leave)(ic, ni);

	ieee80211_node_newstate(ni, IEEE80211_STA_COLLECT);

#if NBRIDGE > 0
	/*
	 * If the parent interface is a bridgeport, delete
	 * any dynamically learned address for this node.
	 */
	if (ic->ic_if.if_bridgeport != NULL)
		bridge_update(&ic->ic_if,
		    (struct ether_addr *)ni->ni_macaddr, 1);
#endif
}

static int
ieee80211_do_slow_print(struct ieee80211com *ic, int *did_print)
{
	static const struct timeval merge_print_intvl = {
		.tv_sec = 1, .tv_usec = 0
	};
	if ((ic->ic_if.if_flags & IFF_LINK0) == 0)
		return 0;
	if (!*did_print && (ic->ic_if.if_flags & IFF_DEBUG) == 0 &&
	    !ratecheck(&ic->ic_last_merge_print, &merge_print_intvl))
		return 0;

	*did_print = 1;
	return 1;
}

/* ieee80211_ibss_merge helps merge 802.11 ad hoc networks.  The
 * convention, set by the Wireless Ethernet Compatibility Alliance
 * (WECA), is that an 802.11 station will change its BSSID to match
 * the "oldest" 802.11 ad hoc network, on the same channel, that
 * has the station's desired SSID.  The "oldest" 802.11 network
 * sends beacons with the greatest TSF timestamp.
 *
 * Return ENETRESET if the BSSID changed, 0 otherwise.
 *
 * XXX Perhaps we should compensate for the time that elapses
 * between the MAC receiving the beacon and the host processing it
 * in ieee80211_ibss_merge.
 */
int
ieee80211_ibss_merge(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int64_t local_tsft)
{
	u_int64_t beacon_tsft;
	int did_print = 0, sign;
	union {
		u_int64_t	word;
		u_int8_t	tstamp[8];
	} u;

	/* ensure alignment */
	(void)memcpy(&u, &ni->ni_tstamp[0], sizeof(u));
	beacon_tsft = letoh64(u.word);

	/* we are faster, let the other guy catch up */
	if (beacon_tsft < local_tsft)
		sign = -1;
	else
		sign = 1;

	if (IEEE80211_ADDR_EQ(ni->ni_bssid, ic->ic_bss->ni_bssid)) {
		if (!ieee80211_do_slow_print(ic, &did_print))
			return 0;
		printf("%s: tsft offset %s%llu\n", ic->ic_if.if_xname,
		    (sign < 0) ? "-" : "",
		    (sign < 0)
			? (local_tsft - beacon_tsft)
			: (beacon_tsft - local_tsft));
		return 0;
	}

	if (sign < 0)
		return 0;

	if (ieee80211_match_bss(ic, ni) != 0)
		return 0;

	if (ieee80211_do_slow_print(ic, &did_print)) {
		printf("%s: ieee80211_ibss_merge: bssid mismatch %s\n",
		    ic->ic_if.if_xname, ether_sprintf(ni->ni_bssid));
		printf("%s: my tsft %llu beacon tsft %llu\n",
		    ic->ic_if.if_xname, local_tsft, beacon_tsft);
		printf("%s: sync TSF with %s\n",
		    ic->ic_if.if_xname, ether_sprintf(ni->ni_macaddr));
	}

	ic->ic_flags &= ~IEEE80211_F_SIBSS;

	/* negotiate rates with new IBSS */
	ieee80211_fix_rate(ic, ni, IEEE80211_F_DOFRATE |
	    IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
	if (ni->ni_rates.rs_nrates == 0) {
		if (ieee80211_do_slow_print(ic, &did_print)) {
			printf("%s: rates mismatch, BSSID %s\n",
			    ic->ic_if.if_xname, ether_sprintf(ni->ni_bssid));
		}
		return 0;
	}

	if (ieee80211_do_slow_print(ic, &did_print)) {
		printf("%s: sync BSSID %s -> ",
		    ic->ic_if.if_xname, ether_sprintf(ic->ic_bss->ni_bssid));
		printf("%s ", ether_sprintf(ni->ni_bssid));
		printf("(from %s)\n", ether_sprintf(ni->ni_macaddr));
	}

	ieee80211_node_newstate(ni, IEEE80211_STA_BSS);
	(*ic->ic_node_copy)(ic, ic->ic_bss, ni);

	return ENETRESET;
}

void
ieee80211_set_tim(struct ieee80211com *ic, int aid, int set)
{
	if (set)
		setbit(ic->ic_tim_bitmap, aid & ~0xc000);
	else
		clrbit(ic->ic_tim_bitmap, aid & ~0xc000);
}

/*
 * This function shall be called by drivers immediately after every DTIM.
 * Transmit all group addressed MSDUs buffered at the AP.
 */
void
ieee80211_notify_dtim(struct ieee80211com *ic)
{
	/* NB: group addressed MSDUs are buffered in ic_bss */
	struct ieee80211_node *ni = ic->ic_bss;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
	struct mbuf *m;

	KASSERT(ic->ic_opmode == IEEE80211_M_HOSTAP);

	while ((m = mq_dequeue(&ni->ni_savedq)) != NULL) {
		if (!mq_empty(&ni->ni_savedq)) {
			/* more queued frames, set the more data bit */
			wh = mtod(m, struct ieee80211_frame *);
			wh->i_fc[1] |= IEEE80211_FC1_MORE_DATA;
		}
		mq_enqueue(&ic->ic_pwrsaveq, m);
		if_start(ifp);
	}
	/* XXX assumes everything has been sent */
	ic->ic_tim_mcast_pending = 0;
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Compare nodes in the tree by lladdr
 */
int
ieee80211_node_cmp(const struct ieee80211_node *b1,
    const struct ieee80211_node *b2)
{
	return (memcmp(b1->ni_macaddr, b2->ni_macaddr, IEEE80211_ADDR_LEN));
}

/*
 * Generate red-black tree function logic
 */
RBT_GENERATE(ieee80211_tree, ieee80211_node, ni_node, ieee80211_node_cmp);
@


1.119
log
@Compile a debug printf in ieee80211_match_bss() by default, previously
guarded by the IEEE80211_DEBUG preprocessor flag. This shows one line
per detected AP after a scan, and indicates which APs are considered
candidates for association.
Shorten the output a bit to fit into 80 columns more likely.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.118 2017/07/19 19:50:58 stsp Exp $	*/
d1546 1
@


1.118
log
@Improve the heuristic which selects 5GHz APs over 2GHz APs.

The previous code wasn't quite right: it didn't account for the fact that
some drivers don't set ic_max_rssi, and it compared 5GHz APs to a threshold
relative to the max RSSI, rather than comparing RSSI on 5GHz relative to
RSSI on 2GHz.

This heuristic is only used by SCANNALLBAND drivers: iwn(4), iwm(4), wpi(4)

In the future the AP selection heuristic should be made more intelligent,
e.g. it should take BSS load information in beacons into account.
Another open problem is inconsistent representation of RSSI measurement
values throughout our drivers and stack. Help is welcome!

For now, this hopefully improves AP selection at busy airports.

ok sthen@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.117 2017/06/04 12:48:42 tb Exp $	*/
a518 1
#ifdef IEEE80211_DEBUG
d520 2
a521 3
		printf(" %c %s", fail ? '-' : '+',
		    ether_sprintf(ni->ni_macaddr));
		printf(" %s%c", ether_sprintf(ni->ni_bssid),
d544 1
a544 1
#endif
@


1.117
log
@Add sizes for free for the RSN IEs. Rewrite ieee80211_save_ie() slightly
to make it more readable.

help, many explanations and ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.116 2017/06/03 15:44:03 tb Exp $	*/
d660 3
a662 1
		    selbs->ni_rssi >= (ic->ic_max_rssi - (ic->ic_max_rssi / 4)))
d667 14
a680 2
			continue;
		else if (ni->ni_rssi > selbs->ni_rssi)
@


1.116
log
@Add a few sizes to free().

Input, help & ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.115 2017/03/04 12:44:27 stsp Exp $	*/
d794 1
a794 1
		free(ni->ni_rsnie, M_DEVBUF, 0);
@


1.115
log
@In 11n hostap mode, dynamically adjust HT protection settings based on
the presence of non-HT nodes in the node cache.
OpenBSD 11n APs will now disable HT protection if it is not necessary.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.114 2017/02/03 09:32:26 stsp Exp $	*/
d205 3
a207 4
	if (ic->ic_aid_bitmap != NULL)
		free(ic->ic_aid_bitmap, M_DEVBUF, 0);
	if (ic->ic_tim_bitmap != NULL)
		free(ic->ic_tim_bitmap, M_DEVBUF, 0);
d1730 2
a1731 1
			free(ba->ba_buf, M_DEVBUF, 0);
@


1.115.4.1
log
@MFC:
Add an entry to dmesg if pairwise WPA keys arrive unexpectedly or if WPA
group keys are being reused. OpenBSD wireless clients will now leave a
trail of such events in their message log.

Clear WPA group keys from memory before initiating a key exchange
with an access point. Prevents false positive 'reused group key'
warnings in dmesg when re-associating to the same access point.

(OpenBSD 6.1 errata 027, August 30, 2017)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.115 2017/03/04 12:44:27 stsp Exp $	*/
a1534 1
	ni->ni_flags &= ~IEEE80211_NODE_RSN_NEW_PTK;
@


1.114
log
@Fix 11b clients sending bogus ratesets in association requests. The common
rateset with the AP is calculated only after the association response was
received, which is too late. Fix rates when an AP is selected after a scan.
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.113 2017/02/02 16:47:53 stsp Exp $	*/
d362 2
a363 4
		 * Default to non-member HT protection until we have a way
		 * of picking up information from the environment (such as
		 * beacons from other networks) which proves that only HT
		 * STAs are on the air.
d1211 1
a1211 1
 * any associated nodes.
d1226 1
a1226 1
	int nnodes = 0;
d1228 2
d1242 7
d1288 7
a1297 1
			splx(s);
a1300 1
			s = splnet();
d1309 17
a1581 12
ieee80211_count_nonhtsta(void *arg, struct ieee80211_node *ni)
{
	int *nonhtsta = arg;

	if (ni->ni_associd == 0 || ni->ni_state == IEEE80211_STA_COLLECT)
		return;

	if (!(ni->ni_flags & IEEE80211_NODE_HT))
		(*nonhtsta)++;
}

void
a1852 11
	else if (ic->ic_flags & IEEE80211_F_HTON) {
		int nonhtsta = 0;
		ieee80211_iterate_nodes(ic,
		    ieee80211_count_nonhtsta, &nonhtsta);
		if (nonhtsta == 1) {
			/* All associated stations now support HT. */
			ic->ic_bss->ni_htop1 = IEEE80211_HTPROT_NONMEMBER;
			if (ic->ic_update_htprot)
				ic->ic_update_htprot(ic, ic->ic_bss);
		}
	}
@


1.113
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.112 2017/01/16 09:35:43 stsp Exp $	*/
d678 6
@


1.112
log
@Reset block ack state and cancel related timeouts when a HT node disassociates.
The existing code (from damien@@) already took care of freeing related buffers
but because block ack state was not reset we were still trying to use these
buffers if the node sent another A-MPDU. This problem only affects 11n hostap.
Fixes kernel crash reported by Timo Myyra on bugs@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.111 2017/01/09 20:18:59 stsp Exp $	*/
a1477 1
		ic->ic_nonhtsta++;
a1495 1
	ic->ic_rsnsta++;
d1522 60
d1588 2
d1597 3
a1599 1
		if (++ic->ic_longslotsta == 1) {
d1604 1
a1604 1
		    ether_sprintf(ni->ni_macaddr), ic->ic_longslotsta));
d1611 2
a1612 2
		ic->ic_nonerpsta++;

d1615 1
a1615 2
		    ic->ic_nonerpsta));

d1722 2
a1724 1
	ic->ic_rsnsta--;
d1727 7
a1733 5
	if ((ni->ni_flags & IEEE80211_NODE_REKEY) &&
	    --ic->ic_rsn_keydonesta == 0)
		ieee80211_setkeysdone(ic);
	ni->ni_flags &= ~IEEE80211_NODE_REKEY;

d1752 2
a1754 6
#ifdef DIAGNOSTIC
		if (ic->ic_longslotsta == 0) {
			panic("bogus long slot station count %d",
			    ic->ic_longslotsta);
		}
#endif
d1756 3
a1758 1
		if (--ic->ic_longslotsta == 0) {
d1770 1
a1770 1
		    ether_sprintf(ni->ni_macaddr), ic->ic_longslotsta));
a1773 6
#ifdef DIAGNOSTIC
		if (ic->ic_nonerpsta == 0) {
			panic("bogus non-ERP station count %d",
			    ic->ic_nonerpsta);
		}
#endif
d1775 3
a1777 1
		if (--ic->ic_nonerpsta == 0) {
d1787 1
a1787 1
		    ether_sprintf(ni->ni_macaddr), ic->ic_nonerpsta));
d1812 1
a1812 2
	if (ni->ni_pwrsave == IEEE80211_PS_DOZE) {
		ic->ic_pssta--;
a1813 1
	}
d1831 4
a1834 3
		if (ic->ic_nonhtsta == 0)
			panic("bogus non-HT station count %d", ic->ic_nonhtsta);
		if (--ic->ic_nonhtsta == 0) {
@


1.111
log
@When a HT node leaves or reassociates as a non-HT node,
clear HT capabilities stored in its node cache object.

A node may switch from 11n mode to 11a/b/g mode.
If we don't clear HT capabilities from the cache the node will
be mistaken as 11n-capable after reassociation.

ok phessler@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.110 2017/01/09 16:24:20 stsp Exp $	*/
d1641 1
@


1.110
log
@Make the net80211 stack send EDCA parameters to the driver in hostap mode.
Fixes problems with timing of frame transmissions which caused packet loss.
tested by myself and tb@@
ok phessler@@ mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.109 2017/01/09 12:40:00 stsp Exp $	*/
d1353 21
d1650 2
@


1.109
log
@Manage the HT protection setting if acting as hostap with 11n enabled.

For now we flip-flop only between non-member protection and non-HT protection.
Running a HT network without protection would require monitoring environmental
conditions (e.g. foreign beacons) which make HT protection necessary.

The ic_update_htprot driver function becomes optional because it won't be
needed by all drivers. Only call it if the driver has set a function pointer.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.108 2017/01/09 09:31:18 stsp Exp $	*/
d357 4
d369 13
@


1.108
log
@The point of ieee80211_node_leave() is to place the node in COLLECT state.
Return early and do nothing if the node is already in COLLECT state upon
entry to this function.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.107 2017/01/09 09:30:47 stsp Exp $	*/
d356 10
d1436 9
a1444 1
	/* TBD */
d1733 10
@


1.107
log
@When acting as hostap, negotiate HT before calling the driver's ic_newassoc()
function, not afterwards. Drivers now know whether a joining node supports HT
which helps with setting up state such as which Tx rate to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.106 2016/12/17 18:35:54 stsp Exp $	*/
d1683 3
@


1.106
log
@Complete our half-done implementation of TKIP countermeasures in hostap mode.

The previous code would disable the AP until next reboot upon MIC failure.
Instead, disable the AP for 60 seconds, as required by the 802.11 standard.
I randomly added a bit of time (up to 120 seconds total) just because we can.

Problem reported by Mathy Vanhoef, thanks!
ok deraadt@@
random input reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.105 2016/09/15 03:32:48 dlg Exp $	*/
d1547 4
a1561 4

	ieee80211_ht_negotiate(ic, ni);
	if (ni->ni_flags & IEEE80211_NODE_HT)
		ieee80211_node_join_ht(ic, ni);
@


1.105
log
@move from RB macros to the RBT functions.

shaves about 5k off an amd64 GENERIC.MP kernel
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.104 2016/08/17 09:42:03 stsp Exp $	*/
d211 1
d375 1
@


1.104
log
@If a wireless device or driver scans all bands at once give 5GHz APs
a slight priority in cases where good matches exist in either band.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.103 2016/05/21 09:07:11 stsp Exp $	*/
d95 1
a95 1
	for (ni = RB_MIN(ieee80211_tree, &ic->ic_tree);
d97 1
a97 1
		next_ni = RB_NEXT(ieee80211_tree, &ic->ic_tree, ni);
d126 1
a126 1
	RB_INIT(&ic->ic_tree);
d541 1
a541 1
	ni = RB_MIN(ieee80211_tree, &ic->ic_tree);
d557 1
a557 1
		RB_FOREACH(ni, ieee80211_tree, &ic->ic_tree)
d614 1
a614 1
		nextbs = RB_NEXT(ieee80211_tree, &ic->ic_tree, ni);
d810 1
a810 1
	RB_INSERT(ieee80211_tree, &ic->ic_tree, ni);
d848 2
a849 2
	/* similar to RB_FIND except we compare keys, not nodes */
	ni = RB_ROOT(&ic->ic_tree);
d853 1
a853 1
			ni = RB_LEFT(ni, ni_node);
d855 1
a855 1
			ni = RB_RIGHT(ni, ni_node);
d1115 1
a1115 1
	RB_REMOVE(ieee80211_tree, &ic->ic_tree, ni);
d1150 1
a1150 1
	while ((ni = RB_MIN(ieee80211_tree, &ic->ic_tree)) != NULL)
d1165 1
a1165 1
	for (ni = RB_MIN(ieee80211_tree, &ic->ic_tree);
d1167 1
a1167 1
		next_ni = RB_NEXT(ieee80211_tree, &ic->ic_tree, ni);
d1198 1
a1198 1
	for (ni = RB_MIN(ieee80211_tree, &ic->ic_tree);
d1200 1
a1200 1
		next_ni = RB_NEXT(ieee80211_tree, &ic->ic_tree, ni);
d1285 1
a1285 1
	RB_FOREACH(ni, ieee80211_tree, &ic->ic_tree)
d1880 1
a1880 1
RB_GENERATE(ieee80211_tree, ieee80211_node, ni_node, ieee80211_node_cmp);
@


1.103
log
@Add a wireless driver capability flag for devices which scan 2GHz and 5GHz
bands in a single scan offload request. This will be used by iwm(4) soon.
ok kettenis@@, earlier version ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.102 2016/05/18 08:15:28 stsp Exp $	*/
d625 17
a641 6
		if (ieee80211_match_bss(ic, ni) == 0) {
			if (selbs == NULL)
				selbs = ni;
			else if (ni->ni_rssi > selbs->ni_rssi)
				selbs = ni;
		}
@


1.103.2.1
log
@MFC:
Add an entry to dmesg if pairwise WPA keys arrive unexpectedly or if WPA
group keys are being reused. OpenBSD wireless clients will now leave a
trail of such events in their message log.

Clear WPA group keys from memory before initiating a key exchange
with an access point. Prevents false positive 'reused group key'
warnings in dmesg when re-associating to the same access point.

(OpenBSD 6.0 errata 041, August 30, 2017)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.103 2016/05/21 09:07:11 stsp Exp $	*/
a1432 1
	ni->ni_flags &= ~IEEE80211_NODE_RSN_NEW_PTK;
@


1.102
log
@In hostap mode, don't re-use association IDs (AIDs) of nodes which are
still lingering in the node cache. This could cause an AID to be assigned
twice, once to a newly associated node and once to a different node in
COLLECT cache state (i.e. marked for future eviction from the node cache).

Drivers (e.g. rt2860) may use AIDs to keep track of nodes in firmware
tables and get confused when AIDs aren't unique across the node cache.
The symptom observed with rt2860 were nodes stuck at 1 Mbps Tx rate since
the duplicate AID made the driver perform Tx rate (AMRR) accounting on
the wrong node object.

To find out if a node is associated we now check the node's cache state,
rather than comparing the node's AID against zero. An AID is assigned when
a node associates and it lasts until the node is eventually purged from the
node cache (previously, the AID was made available for re-use when the node
was placed in COLLECT state). There is no need to be stingy with AIDs since
the number of possible AIDs exceeds the maximum number of nodes in the cache.

Problem found by Nathanael Rensen.
Fix written by Nathanael and myself. Tested by Nathanael.
Comitting now to get this change tested across as many drivers as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.101 2016/04/12 14:33:27 mpi Exp $	*/
d588 4
a591 2
		 * like 11b and "pure" 11G mode. This will loop
		 * forever except for user-initiated scans.
d593 2
a594 1
		if (ieee80211_next_mode(ifp) == IEEE80211_MODE_AUTO) {
d598 1
a598 1
				/* Return from an user-initiated scan */
d658 1
a658 1
		/* Return from an user-initiated scan */
@


1.101
log
@Call if_enqueue() and if_start() instead of dereferencing the ifp
pointers.

These functions have been introduced to abstract some of the MP-
safeness^Wmadness and should be use everywhere.

Prodded by a comment from jsg@@.

ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.100 2016/03/03 07:20:45 gerhard Exp $	*/
d1499 1
a1499 1
	int newassoc;
a1520 1
		newassoc = 1;
d1525 1
a1525 2
	} else
		newassoc = 0;
a1699 2
	IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
	ni->ni_associd = 0;
@


1.100
log
@Restore assignment of ic_curmode that was accidentally removed when
moving the ERP code to post-assoc phase. Fixes iwi(4) fatal firmware
errors.

ok stsp@@, sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.99 2016/01/25 15:14:22 stsp Exp $	*/
d1850 1
a1850 1
		(*ifp->if_start)(ifp);
@


1.99
log
@Honour ERP protection on 2 GHz channels in 11n mode, as done for 11g.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.98 2016/01/25 15:10:37 stsp Exp $	*/
d633 2
@


1.99.2.1
log
@Merge ieee80211_node.c r1.100 to 5.9-stable.
Fixes iwi(4) and perhaps other wireless devices.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.100 2016/03/03 07:20:45 gerhard Exp $	*/
a632 2

	ic->ic_curmode = ieee80211_chan2mode(ic, ni->ni_chan);
@


1.98
log
@Don't try to interpret htprot data if the last beacon didn't contain such data.
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.97 2016/01/07 23:22:31 stsp Exp $	*/
d1520 3
a1522 1
		if (ic->ic_curmode == IEEE80211_MODE_11G)
d1689 3
a1691 1
	if (ic->ic_curmode == IEEE80211_MODE_11G)
@


1.97
log
@Make the A-MPDU reordering buffer more resilient against APs which drop
some subframes or let the sequence number jump up by more than 1 (hard
to tell which it is). We decrease the BA inactivity timeout for quicker
recovery from stalled BA sessions, and add a new timeout which keeps track
of gaps in the subframe sequence number space due to dropped frames.
Gaps expire after 500 msec, the same value FreeBSD uses for their
implementation of this workaround. And Linux uses this trick, too.

This should fix network stalls some people have been seeing in 11n mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.96 2016/01/05 18:41:16 stsp Exp $	*/
d1311 1
a1311 1
void
d1316 1
a1316 1
		return;
d1325 2
@


1.96
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.95 2016/01/04 12:25:00 stsp Exp $	*/
d1065 1
a1065 1
		if (ba->ba_state == IEEE80211_BA_AGREED) {
d1068 2
d1076 1
a1076 1
		if (ba->ba_state == IEEE80211_BA_AGREED) {
@


1.95
log
@While configuring ERP we need to know if we're in 11a or 11g mode so only
configure ERP once we are sure about our operation mode against the AP.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.94 2015/12/18 13:27:00 sthen Exp $	*/
a70 1
#ifndef IEEE80211_NO_HT
a71 1
#endif
a75 1
#ifndef IEEE80211_NO_HT
a76 1
#endif
a78 1
#ifndef IEEE80211_NO_HT
a79 1
#endif
a748 1
#ifndef IEEE80211_NO_HT
a749 1
#endif
a1057 1
#ifndef IEEE80211_NO_HT
a1080 1
#endif
a1095 1
#ifndef IEEE80211_NO_HT
a1096 1
#endif
a1272 1
#ifndef IEEE80211_NO_HT
a1323 1
#endif /* IEEE80211_NO_HT */
a1397 1
#ifndef IEEE80211_NO_HT
a1405 1
#endif	/* !IEEE80211_NO_HT */
a1536 1
#ifndef IEEE80211_NO_HT
a1539 1
#endif
a1551 1
#ifndef IEEE80211_NO_HT
a1572 1
#endif	/* !IEEE80211_NO_HT */
a1685 1
#ifndef IEEE80211_NO_HT
a1687 1
#endif
@


1.94
log
@unnoccupied->unoccupied
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.93 2015/12/12 11:25:46 stsp Exp $	*/
a638 8

	/*
	 * Set the erp state (mostly the slot time) to deal with
	 * the auto-select case; this should be redundant if the
	 * mode is locked.
	 */
	ic->ic_curmode = ieee80211_chan2mode(ic, ni->ni_chan);
	ieee80211_reset_erp(ic);
@


1.93
log
@Finish support for receiving 11n A-MPDUs.

The initial implementation was added by damien@@ years ago.
Summary of the changes made in this commit:
 - In ieee80211_input(), process A-MPDUs before duplicate detection.
 - Don't forget to set ba->ba_ni in ieee80211_recv_addba_req()
   so we don't crash in ieee80211_rx_ba_timeout().
 - In ieee80211_recv_addba_req(), tweak the logic to deny BlockAck
   requests if the driver has no callback for doing so.
 - Implement ieee80211_ba_del() which cleans up BlockAck state.
 - Increase the minimum and maximum lifetime for BlockAck agrements.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.92 2015/11/24 13:45:06 mpi Exp $	*/
d559 1
a559 1
		 * an unnoccupied one.  If that fails, pick a random
@


1.92
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.91 2015/11/15 11:14:17 stsp Exp $	*/
d71 3
d763 3
d1074 26
d1113 3
@


1.91
log
@Parse 11n HT capabilities and operational info from association response
frames, negotiate HT with the AP, and move the interface into or out of
11n mode accordingly. If running as AP negotiate HT with nodes joining the BSS.

ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.90 2015/11/15 10:07:03 stsp Exp $	*/
a49 1
#include <net/if_arp.h>
@


1.90
log
@Extend struct ieee80211_node with fields for 11n STA HT capabilities and
HT operational information sent by 11n APs. These fields reflect the structure
of elements in management frames so that IEEE80211_HTCAP* and IEEE80211_HTOP*
macros designed to operate on frame elements can be used directly to read
or set the fields.

Populate nodes with HT information received in probe responses, probe
requests, and association requests.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.89 2015/11/04 12:12:00 dlg Exp $	*/
d1528 1
@


1.89
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.88 2015/07/15 22:16:42 deraadt Exp $	*/
d1257 55
@


1.88
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.87 2015/03/14 03:38:51 jsg Exp $	*/
d194 1
a194 1
	IFQ_SET_MAXLEN(&ni->ni_savedq, IEEE80211_PS_MAX_QUEUE);
d800 1
a800 1
	IFQ_SET_MAXLEN(&ni->ni_savedq, IEEE80211_PS_MAX_QUEUE);
d1086 1
a1086 2
	if (!IF_IS_EMPTY(&ni->ni_savedq)) {
		IF_PURGE(&ni->ni_savedq);
d1613 1
a1613 2
	if (!IF_IS_EMPTY(&ni->ni_savedq)) {
		IF_PURGE(&ni->ni_savedq);
d1773 2
a1774 5
	for (;;) {
		IF_DEQUEUE(&ni->ni_savedq, m);
		if (m == NULL)
			break;
		if (!IF_IS_EMPTY(&ni->ni_savedq)) {
d1779 1
a1779 1
		IF_ENQUEUE(&ic->ic_pwrsaveq, m);
@


1.87
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.86 2014/12/23 03:24:08 tedu Exp $	*/
d1505 1
a1505 2
				if (ba->ba_buf[i].m != NULL)
					m_freem(ba->ba_buf[i].m);
@


1.86
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.85 2014/11/18 02:37:31 tedu Exp $	*/
a32 1
#include "bpfilter.h"
a50 4

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
@


1.85
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.84 2014/09/14 14:17:26 jsg Exp $	*/
a56 1
#ifdef INET
a58 1
#endif
@


1.84
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.83 2014/09/12 16:02:40 sthen Exp $	*/
a67 2

#include <dev/rndvar.h>
@


1.83
log
@Remove cached 802.11 nodes in IEEE80211_STA_CACHE state (these are nodes
which have been seen but which haven't otherwise interacted with us), fixing
a problem where old cached nodes are seen when doing a scan.
From Marcin Piotr Pawlowski, feedback stsp@@ ok kspillner@@ dcoppa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.82 2014/08/08 15:16:39 jasper Exp $	*/
a44 1
#include <sys/proc.h>
@


1.82
log
@use nitems() instead of various local constructs

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.81 2014/07/12 18:44:22 tedu Exp $	*/
d1137 15
@


1.81
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.80 2013/12/01 10:08:55 stsp Exp $	*/
a1291 1
#define N(a)	(sizeof (a) / sizeof (a)[0])
d1300 1
a1300 1
	for (i = 0; i < N(rates); i++) {
a1308 1
#undef N
@


1.80
log
@Reset txrate array index after changing a node's rate list.
Should prevent "bogus xmit rate %d setup" panics, which I ran into again
in IBSS mode.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.79 2013/11/21 16:16:08 mpi Exp $	*/
d220 1
a220 1
		free(ic->ic_aid_bitmap, M_DEVBUF);
d222 1
a222 1
		free(ic->ic_tim_bitmap, M_DEVBUF);
d768 1
a768 1
		free(ni->ni_rsnie, M_DEVBUF);
d777 1
a777 1
	free(ni, M_DEVBUF);
d1504 1
a1504 1
			free(ba->ba_buf, M_DEVBUF);
@


1.79
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.78 2013/03/24 17:01:23 claudio Exp $	*/
d912 1
d1045 1
@


1.78
log
@Make ieee80211_set_tim() available from outside of ieee80211_node.c
so drivers like acx(4) can use that function directly instead of
reimplementing the function again. Requested by kettenis@@ long time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.77 2012/11/07 19:39:08 stsp Exp $	*/
a52 1
#include <net/if_llc.h>
@


1.77
log
@Fix DPRINTF() format string treating n->ni_refcnt, which is unsigned, as signed.
diff from dhill; ok kettenis reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.76 2012/10/10 09:23:06 kettenis Exp $	*/
a96 1
void ieee80211_set_tim(struct ieee80211com *, int, int);
@


1.76
log
@Clear the powersave flag and purge queued packets when a node leaves the AP
(either by disassociating or by timeout).  Fixes (most) remaining issues with
power saving.

From Nathanael Rensen.

ok claudio@@, krw@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.75 2012/10/05 17:17:04 camield Exp $	*/
d1111 1
a1111 1
	DPRINTF(("%s refcnt %d\n", ether_sprintf(ni->ni_macaddr),
@


1.75
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.74 2012/09/20 17:21:13 stsp Exp $	*/
d1607 1
a1607 1
	if (ni->ni_pwrsave == IEEE80211_PS_DOZE)
d1609 8
@


1.74
log
@Nuke M_80211_NODE #define which mapped to M_DEVBUF and use M_DEVBUF directly.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.73 2012/08/25 11:34:27 kettenis Exp $	*/
d1477 1
a1477 1
	 * If the parent interface belongs to a bridge, learn
d1480 1
a1480 1
	if (ic->ic_if.if_bridge != NULL)
d1630 1
a1630 1
	 * If the parent interface belongs to a bridge, delete
d1633 1
a1633 1
	if (ic->ic_if.if_bridge != NULL)
@


1.73
log
@Set up ni_savedq for the initial BSS node such that it can actually be used
to store multicast frames when one of the associated stations is in power
saving mode.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.72 2012/08/17 14:49:17 stsp Exp $	*/
a101 2
#define M_80211_NODE	M_DEVBUF

d762 1
a762 1
	return malloc(sizeof(struct ieee80211_node), M_80211_NODE,
d779 1
a779 1
	free(ni, M_80211_NODE);
@


1.72
log
@Fix possible panic while switching from STA mode into hostap/ibss modes.
ieee80211_create_ibss() resets the set of supported rates but failed
to update the index into the rate set array accordingly. If the rate
configured during STA operation didn't belong to the newly configured
rate set the system ran into an assertion ("bogus xmit rate %u setup")
while trying to create the IBSS.
ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.71 2012/07/18 13:24:28 stsp Exp $	*/
d207 3
@


1.71
log
@Print messages about nodes purged from the node cache if hostap/ibss modes are
compiled in and the interface is in debug mode. ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.70 2012/07/16 14:51:46 stsp Exp $	*/
d352 1
@


1.70
log
@Move increment of ic_nnodes closer to where the node is actually inserted
into the cache. Make sure we're at IPL_NET while incrementing/decrementing
ic_nnodes. Add a debug message that warns about possible node leaks.
All of this affects hostap mode only.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.69 2012/07/13 09:46:33 stsp Exp $	*/
d1197 3
a1200 2
		DPRINTF(("station %s purged from LRU cache\n",
		    ether_sprintf(ni->ni_macaddr)));
@


1.69
log
@Tweak node cache eviction strategy when the cache is full: kick off new nodes
in AUTH state that weren't active during the cache wait interval rather than
keeping them for the entire cache timeout interval. Fixes association failures
in noisy RF environments. Tested by edd and myself with a slow soekris
suffering from RF noise with about of 50 interrupts per second on ral0.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.68 2012/01/25 17:04:02 stsp Exp $	*/
a191 2
	if (ni != NULL)
		ic->ic_nnodes++;
d816 1
d1083 2
d1154 4
d1167 3
d1206 1
d1221 14
@


1.68
log
@There is no need to explicitly skip ic_bss when iterating over cached nodes.
The ic_bss is never put into the RB tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.67 2012/01/25 17:03:31 stsp Exp $	*/
d1144 2
a1145 2
 * recent activity and also allow de-authing inactive authenticated or
 * associated nodes.
d1175 9
a1183 1
				if (ni->ni_state != IEEE80211_STA_COLLECT &&
@


1.67
log
@Clean inactive authenticated nodes during cache timeout as well.
There is no need to keep nodes cached with never associated and were
inactive within the last 5 minutes or more. Keeps the node cache pretty
clean in my environment with typical city-center wlan noise.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.66 2012/01/21 19:42:16 stsp Exp $	*/
a115 2
		if (ni == ic->ic_bss)
			continue;
@


1.66
log
@Implement missing bits of node inactivity accounting in hostap mode.
Small parts of code for this feature were already present but unused.

A node becomes inactive after not sending or receiving a frame within
5 minutes. Inactive cached nodes (not authenticated or associated) are
automatically cleared from the cache once every hour, making room for
new nodes. If the node cache is full and room must be made for a new node,
clean either a cached node (active or inactive), or an inactive
authenticated or associated node.

Also, do not send de-auth frames to nodes which never authenticated,
and only send a de-auth frame once for a given node.
This part was contributed by Steven Chamberlain, thanks!

Tested by myself, krw@@, edd@@, Steven Chamberlain, and Markus Schatzl.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.65 2012/01/21 19:01:04 stsp Exp $	*/
d1140 2
a1141 2
 * modes, clean all inactive cached nodes but don't de-auth any authenticated
 * or associated nodes.
d1173 1
a1173 1
				    (ni->ni_state >= IEEE80211_STA_AUTH ||
@


1.65
log
@Hold interrupts blocked while comparing a cached node's refcount to zero
and freeing the node. Just in case an interrupt happens to ref the node after
the refcount was checked but before the node is freed.
Tested by several as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.64 2012/01/18 14:35:34 stsp Exp $	*/
d98 2
d104 34
d177 4
d190 1
a190 1
		ieee80211_clean_nodes(ic);
d228 2
d423 2
a817 10

	/*
	 * Note we don't enable the inactive timer when acting
	 * as a station.  Nodes created in this mode represent
	 * AP's identified while scanning.  If we time them out
	 * then several things happen: we can't return the data
	 * to users to show the list of AP's we encountered, and
	 * more importantly, we'll incorrectly deauthenticate
	 * ourself because the inactivity timer will kick us off.
	 */
a818 3
	if (ic->ic_opmode != IEEE80211_M_STA &&
	    RB_EMPTY(&ic->ic_tree))
		ic->ic_inact_timer = IEEE80211_INACT_WAIT;
a1100 2
	if (RB_EMPTY(&ic->ic_tree))
		ic->ic_inact_timer = 0;
d1138 10
d1150 1
a1150 1
ieee80211_clean_nodes(struct ieee80211com *ic)
d1160 1
a1160 1
		if (ic->ic_nnodes < ic->ic_max_nnodes)
d1167 17
d1187 3
a1189 1
		 * Send a deauthenticate frame.
d1192 3
a1194 1
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
@


1.64
log
@Make it possible to free cached nodes which never associated (e.g. nodes
only scanning for networks). These were never put into COLLECT state and
were thus never evicted from the node cache in hostap mode.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.63 2011/03/28 14:49:40 kettenis Exp $	*/
d1083 1
a1085 1
		s = splnet();
a1086 1
		splx(s);
d1088 1
@


1.63
log
@Clean nodes until the number of cached nodes is smaller than the maximum number
of nodes, otherwise we'll never actually clean any nodes.  Fixes issues with
clients failing too attach because the node cache is completely filled.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.62 2010/08/07 03:50:02 krw Exp $	*/
d1510 2
a1511 1
	if (ni->ni_associd == 0)
d1513 1
@


1.62
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.61 2010/07/19 18:53:52 damien Exp $	*/
d1121 1
a1121 1
		if (ic->ic_nnodes <= ic->ic_max_nnodes)
@


1.61
log
@in hostap mode, notify drivers via a new callback when a STA leaves
the BSS. this is needed by drivers that need to maintain a hardware
table of associated STAs (like ral(4) RT2860).

idea from Nathanael Rensen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.60 2010/06/19 08:33:50 damien Exp $	*/
d1478 1
a1478 1
			panic("bogus non-ERP station count %d\n",
@


1.60
log
@In ieee80211_node_leave(), clear the associd after calling
ieee80211_node_leave_rsn() since ieee80211_node_leave_rsn()
calls ic_delete_key() and drivers like ral(4) RT2860 need
a valid associd in their delete_key callbacks.
This affects HostAP mode only.

from Nathanael Rensen.

remove a useless (nested) #ifndef IEEE80211_STA_ONLY while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.59 2010/06/14 17:51:43 damien Exp $	*/
d1526 3
@


1.59
log
@fix my previous commit, i forgot BIP, so instead of enumerating
what is not supported as a group cipher, enumerate what is supported.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.58 2010/06/14 17:39:20 damien Exp $	*/
a1436 1
#ifndef IEEE80211_STA_ONLY
d1439 1
a1439 1
#endif
d1507 2
a1508 2
	 * If node wasn't previously associated all
	 * we need to do is reclaim the reference.
a1511 2
	IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
	ni->ni_associd = 0;
d1527 2
@


1.58
log
@do not try to associate with an AP using an unsupported group cipher,
otherwise we will panic in ieee80211_add_rsn_body().

this may be the cause of a panic seen by reyk@@ though i'm not 100% sure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.57 2010/03/28 13:02:58 krw Exp $	*/
d442 4
a445 2
		if (ni->ni_rsngroupcipher == IEEE80211_CIPHER_NONE ||
		    ni->ni_rsngroupcipher == IEEE80211_CIPHER_USEGROUP)
@


1.57
log
@Four uses of uninitialized variables found by clang via jsg@@. ar5416, ar9287
and athn are only theoretically interesting. i33380211_node fixes a real
bug in occupied channel detection.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.56 2010/02/17 18:34:37 damien Exp $	*/
d442 3
@


1.56
log
@Do not always create a new node when a beacon or a probe response
is received.  The creation of a new node is already handled in
ieee80211_recv_probe_resp() when necessary.
This avoids creating empty nodes with wrong channels when beacons
are received on the wrong channel (overlapping channels).
Those empty nodes may also prevent the real node from being
discovered because of ieee80211_find_node_for_beacon() filtering.

This should prevent entries of the form:
	nwid "" chan 3 bssid 00:01:02:03:04:05 0dB 54M
in "ifconfig if0 scan" output, like reported by Rivo Nurges.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.55 2009/01/29 17:19:10 damien Exp $	*/
d525 1
@


1.55
log
@fix a panic that occurs when IEEE80211_STA_ONLY is defined (SMALL_KERNEL).

noticed by ray@@, more investigation from sthen@@
fix tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.54 2009/01/28 18:55:18 damien Exp $	*/
a932 1
			rc = 1;
@


1.54
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.53 2009/01/28 17:15:21 damien Exp $	*/
d183 1
d188 1
a188 1

d1054 1
a1055 1
	IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
@


1.53
log
@In ieee80211_find_node(), roll our own RB_FIND() based on the key (macaddr)
instead of resorting to horrid hacks/casts.
Restore the ieee80211_node structure back to its original state.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.52 2009/01/27 17:02:29 damien Exp $	*/
d1395 1
a1395 1
	struct ieee80211_ba *ba;
d1401 1
a1401 1
		ba = &ni->ni_ba[tid];
@


1.52
log
@unbreak SMALL_KERNEL builds by adding missing #ifndef IEEE80211_STA_ONLY

pointed out by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.51 2009/01/26 21:55:58 damien Exp $	*/
d815 15
a829 3
	/* XXX ugly, but avoids a full node structure in the stack */
	return (RB_FIND(ieee80211_tree, &ic->ic_tree,
	    (struct ieee80211_node *)macaddr));
@


1.51
log
@move ni_macaddr field at the top of the ieee80211_node structure.
this way we can avoid putting a full node structure (which is huge)
on the stack in ieee80211_find_node().
this is a bit tricky but the RB_FIND macro wants an "elem" structure,
not a field of "elem".
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.50 2009/01/26 19:09:41 damien Exp $	*/
d762 1
d766 1
d1038 1
d1041 1
d1045 1
d1051 1
d1419 2
d1422 1
a1422 1
	timeout_del(&ni->ni_eapol_to);
@


1.50
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.49 2008/12/14 10:17:24 damien Exp $	*/
d813 3
a815 4
	struct ieee80211_node ni;

	IEEE80211_ADDR_COPY(ni.ni_macaddr, macaddr);
	return (RB_FIND(ieee80211_tree, &ic->ic_tree, &ni));
@


1.49
log
@Add an ieee80211_notify_dtim() function that drivers should call after
every DTIM in HostAP mode.
Flushes all group addressed MSDUs buffered at the AP for power management.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.48 2008/10/23 16:21:21 mk Exp $	*/
d87 3
d92 3
d444 1
a444 1
		/* we only support AES-128-CMAC as the IGTK cipher */
d446 1
a446 1
		    ni->ni_rsngroupmgmtcipher != IEEE80211_CIPHER_AES128_CMAC)
d762 3
d766 1
a766 1
	/* 
d1037 2
d1214 11
a1244 1
	timeout_set(&ni->ni_rsn_timeout, ieee80211_eapol_timeout, ni);
d1355 5
d1371 25
d1414 2
a1415 1
	timeout_del(&ni->ni_rsn_timeout);
d1499 5
@


1.48
log
@Prevent a crash in ieee80211_setkeys() when unplugging an interface in
hostap mode by canceling the group rekey timeout in ieee80211_node_detach().

ok damien
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.47 2008/10/15 19:12:18 blambert Exp $	*/
d1570 31
@


1.47
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.46 2008/09/27 15:16:09 damien Exp $	*/
d181 2
@


1.46
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.45 2008/08/29 12:14:53 damien Exp $	*/
d370 1
a370 1
		timeout_add(&ic->ic_rsn_timeout, 3600 * hz);
@


1.45
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.44 2008/08/27 09:05:04 damien Exp $	*/
d7 1
d77 1
d85 1
d427 6
a432 3
		if ((ni->ni_rsnakms & ic->ic_rsnakms) == IEEE80211_AKM_PSK &&
		    !(ic->ic_flags & IEEE80211_F_PSK))
			fail |= 0x40;
d601 3
a603 33
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		/* prefer RSN (WPA2) over WPA */
		ni->ni_rsnprotos &= ic->ic_rsnprotos;
		if (ni->ni_rsnprotos & IEEE80211_PROTO_RSN)
			ni->ni_rsnprotos = IEEE80211_PROTO_RSN;
		else
			ni->ni_rsnprotos = IEEE80211_PROTO_WPA;
		/*
		 * If a pre-shared key is configured and AP supports PSK,
		 * choose PSK as AKMP.
		 */
		ni->ni_rsnakms &= ic->ic_rsnakms;
		if ((ni->ni_rsnakms & IEEE80211_AKM_PSK) &&
		    (ic->ic_flags & IEEE80211_F_PSK))
			ni->ni_rsnakms = IEEE80211_AKM_PSK;
		else
			ni->ni_rsnakms = IEEE80211_AKM_8021X;

		/* prefer CCMP over TKIP if the AP supports it */
		ni->ni_rsnciphers &= ic->ic_rsnciphers;
		if (ni->ni_rsnciphers & IEEE80211_CIPHER_CCMP)
			ni->ni_rsnciphers = IEEE80211_CIPHER_CCMP;
		else
			ni->ni_rsnciphers = IEEE80211_CIPHER_TKIP;

		ni->ni_rsncipher = ni->ni_rsnciphers;

		/* use MFP if we both support it */
		if ((ic->ic_caps & IEEE80211_C_MFP) &&
		    (ni->ni_rsncaps & IEEE80211_RSNCAP_MFPC))
			ni->ni_flags |= IEEE80211_NODE_MFP;

	} else if (ic->ic_flags & IEEE80211_F_WEPON)
d627 57
d1186 16
d1228 6
a1233 2
	/* initiate 4-way handshake */
	if (ni->ni_rsnakms == IEEE80211_AKM_PSK)
d1235 4
d1358 1
@


1.44
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.43 2008/08/12 19:29:07 damien Exp $	*/
a367 4
	}
	if (ic->ic_phytype == IEEE80211_T_FH) {
		ni->ni_fhdwell = 200;	/* XXX */
		ni->ni_fhindex = 1;
@


1.43
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.42 2008/08/12 19:21:04 damien Exp $	*/
d83 1
d89 1
d97 1
d99 1
d113 1
d133 1
d216 4
a219 1
	if (ic->ic_opmode != IEEE80211_M_HOSTAP) {
d222 3
a224 1
	} else
d226 1
d289 1
d375 1
d389 1
d393 3
a395 1
	} else {
a489 1
	int i, fail;
d501 1
d505 2
d528 1
d532 2
d540 1
a540 1

d635 1
d642 2
a643 1
	} else {
a644 1
	}
d789 1
d792 1
d802 1
d828 3
a861 1
	struct ieee80211_node *bss = ic->ic_bss;
d882 1
d885 1
a885 1
			rc = IEEE80211_ADDR_EQ(*bssid, bss->ni_bssid) ||
d887 1
d895 1
d898 3
a900 1
				rc = IEEE80211_ADDR_EQ(*bssid, bss->ni_bssid);
d904 1
d906 3
a908 1
				rc = IEEE80211_ADDR_EQ(*bssid, bss->ni_bssid);
d913 1
d915 1
d945 1
d948 1
a948 1

d1068 1
d1077 1
d1128 1
d1515 1
@


1.42
log
@add/process group integrity cipher suite in RSN IEs.
add support for MFP negotiation during association.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.41 2008/08/12 18:41:18 damien Exp $	*/
d593 1
a593 1
			ni->ni_rsnakms = IEEE80211_AKM_IEEE8021X;
@


1.41
log
@the only integrity group cipher currently supported is AES-128-CMAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.40 2008/08/12 18:37:23 damien Exp $	*/
d318 5
d353 1
a353 1
		/* schedule a GTK rekeying after 3600s */
d416 16
d603 5
@


1.40
log
@generate a random IGTK in HostAP mode if we're MFP-capable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.39 2008/08/12 16:14:05 damien Exp $	*/
d316 1
@


1.39
log
@get rid of the map_ptk()/map_gtk() functions, just inline them
which makes things easier to track.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.38 2008/08/02 08:20:16 damien Exp $	*/
d328 11
@


1.38
log
@Drop frames that are received unencrypted when WEP is on or when
WPA is on and RX protection for TA is on.
Keep track of the TX/RX protection for each node when WPA is on.

tested by djm@@ (ral+wpa), ckuethe@@ (ath-noenc) and krw@@ (wpi<->ral+wpa).
hints from bluhm@@
has been in snaps for a few days.

pointed out by bluhm@@ something like 1 year ago but we did not have
the right infrastructure to fix it properly at that time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.37 2008/07/28 19:42:13 damien Exp $	*/
a307 1
		u_int8_t gtk[IEEE80211_PMK_LEN];
d320 6
a325 3
		arc4random_buf(gtk, sizeof(gtk));
		ieee80211_map_gtk(gtk, ni->ni_rsngroupcipher,
		    ic->ic_def_txkey, 1, 0, k);
@


1.37
log
@ignore PS mode changes and PS-Poll from non-associated STAs.
keep track of the number of associated STAs in PS mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.36 2008/07/27 14:21:15 damien Exp $	*/
d332 1
d1090 1
d1227 1
@


1.36
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.35 2008/07/21 19:27:26 damien Exp $	*/
d1297 3
@


1.35
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.34 2008/06/09 07:07:16 djm Exp $	*/
d270 1
a270 1
	IEEE80211_DPRINTF(("%s: chan %d->%d\n", __func__,
d474 1
a474 1
		IEEE80211_DPRINTF(("%s: no scan candidate\n", __func__));
d656 1
a656 2
	IEEE80211_DPRINTF(("%s %s\n", __func__,
	    ether_sprintf((u_int8_t *)macaddr)));
d880 1
a880 1
	IEEE80211_DPRINTF(("%s: faked-up node %p for %s\n", __func__, ni,
d916 1
a916 1
	IEEE80211_DPRINTF(("%s %s\n", __func__, ether_sprintf(ni->ni_macaddr)));
d936 2
a937 2
	IEEE80211_DPRINTF(("%s %s refcnt %d\n", __func__,
	    ether_sprintf(ni->ni_macaddr), ni->ni_refcnt));
d952 1
a952 1
	IEEE80211_DPRINTF(("%s\n", __func__));
d983 1
a983 1
		IEEE80211_DPRINTF(("station %s purged from LRU cache\n",
d1035 3
a1037 3
			IEEE80211_DPRINTF(("%s: extended rate set too large;"
				" only using %u of %u rates\n",
				__func__, nxrates, xrates[1]));
d1079 1
a1079 1
	IEEE80211_DPRINTF(("station %s associated using proto %d akm 0x%x "
d1121 2
a1122 3
		IEEE80211_DPRINTF(("[%s] station needs long slot time, "
		    "count %d\n", ether_sprintf(ni->ni_macaddr),
		    ic->ic_longslotsta));
d1131 1
a1131 1
		IEEE80211_DPRINTF(("[%s] station is non-ERP, %d non-ERP "
d1137 1
a1137 2
			IEEE80211_DPRINTF(("%s: enable use of protection\n",
			    __func__));
d1179 2
a1180 3
	IEEE80211_DPRINTF(("station %s %s associated at aid %d\n",
	    ether_sprintf(ni->ni_macaddr),
	    (newassoc ? "newly" : "already"),
d1254 2
a1255 3
		IEEE80211_DPRINTF(("[%s] long slot time station leaves, "
		    "count now %d\n", ether_sprintf(ni->ni_macaddr),
		    ic->ic_longslotsta));
d1275 2
a1276 3
		IEEE80211_DPRINTF(("[%s] non-ERP station leaves, "
		    "count now %d\n", ether_sprintf(ni->ni_macaddr),
		    ic->ic_nonerpsta));
@


1.34
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.33 2008/04/21 20:16:34 damien Exp $	*/
d68 1
@


1.33
log
@move ieee80211_ibss_merge() from ieee80211_input.c to ieee80211_node.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.32 2008/04/21 19:37:18 damien Exp $	*/
d310 1
a310 1
		arc4random_bytes(ic->ic_globalcnt, EAPOL_KEY_NONCE_LEN);
d320 1
a320 1
		arc4random_bytes(gtk, sizeof(gtk));
d1097 1
a1097 1
	arc4random_bytes(ni->ni_nonce, EAPOL_KEY_NONCE_LEN);
@


1.32
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.31 2008/04/16 18:32:15 damien Exp $	*/
d1320 102
@


1.31
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.30 2007/10/29 15:40:23 chl Exp $	*/
d1013 31
@


1.30
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.29 2007/09/07 20:23:30 damien Exp $	*/
d82 1
d84 1
a114 1

d124 2
d305 30
d361 1
a361 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
a364 1
		/* XXX does this mean privacy is supported or required? */
d368 1
d379 18
d413 1
a413 1
		printf(" %3s%c ",
d415 1
a415 1
		    "wep" : "no",
d417 4
d530 1
d537 1
a537 1
	ic->ic_curmode = ieee80211_chan2mode(ic, selbs->ni_chan);
d540 30
d572 1
a572 1
		ieee80211_fix_rate(ic, ic->ic_bss, IEEE80211_F_DOFRATE |
d574 1
a574 1
		if (ic->ic_bss->ni_rates.rs_nrates == 0)
d618 4
d637 3
d660 2
d1043 31
d1161 6
d1179 23
d1271 3
@


1.29
log
@use new malloc M_ZERO flag + replace MALLOC with malloc
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.28 2007/07/06 18:18:43 damien Exp $	*/
d165 1
a165 1
		FREE(ic->ic_aid_bitmap, M_DEVBUF);
d167 1
a167 1
		FREE(ic->ic_tim_bitmap, M_DEVBUF);
d538 1
a538 1
	FREE(ni, M_80211_NODE);
@


1.28
log
@remove remaining bits for pre-RSNA shared authmode support.
it has been #if 0'd since 3.9 and we have never supported this mode (no
ifconfig option etc...).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.27 2007/07/06 17:47:19 damien Exp $	*/
d107 1
a107 1
	MALLOC(ic->ic_aid_bitmap, u_int32_t *, size, M_DEVBUF, M_NOWAIT);
d112 1
a112 2
	} else
		memset(ic->ic_aid_bitmap, 0, size);
d116 2
a117 2
		MALLOC(ic->ic_tim_bitmap, u_int8_t *, ic->ic_tim_len, M_DEVBUF,
		    M_NOWAIT);
d121 1
a121 2
		} else {
			memset(ic->ic_tim_bitmap, 0, ic->ic_tim_len);
a122 1
		}
d525 2
a526 6
	struct ieee80211_node *ni;
	MALLOC(ni, struct ieee80211_node *, sizeof(struct ieee80211_node),
	    M_80211_NODE, M_NOWAIT);
	if (ni != NULL)
		memset(ni, 0, sizeof(struct ieee80211_node));
	return ni;
@


1.27
log
@initialize an unitialized variable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.26 2007/07/03 20:25:32 damien Exp $	*/
a538 4
	if (ni->ni_challenge != NULL) {
		FREE(ni->ni_challenge, M_DEVBUF);
		ni->ni_challenge = NULL;
	}
a553 1
	dst->ni_challenge = NULL;
@


1.26
log
@maintain the traffic-indication (TIM) virtual bitmap by defining
a default ieee80211_set_tim() function that drivers can override
by setting ic_set_tim.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.25 2007/07/02 16:46:44 damien Exp $	*/
d769 1
a770 1
	const static u_int8_t zero[IEEE80211_ADDR_LEN];
@


1.25
log
@initial bits for proper TIM support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.24 2007/06/16 13:17:05 damien Exp $	*/
d84 1
d122 1
a122 1
		} else
d124 2
d839 1
a839 1
		if (ic->ic_set_tim)
d1143 9
@


1.24
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.23 2007/06/16 11:59:58 damien Exp $	*/
d113 11
d166 2
@


1.23
log
@don't mix u_int{8,16,32}_t and uint{8,16,32}_t
use u_int{8,16,32}_t everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.22 2007/06/16 11:56:20 damien Exp $	*/
d76 1
a76 1
    struct ieee80211_node *);
d78 1
a78 1
    u_int8_t *);
d546 2
a547 1
ieee80211_node_getrssi(struct ieee80211com *ic, struct ieee80211_node *ni)
d554 1
a554 1
	struct ieee80211_node *ni, u_int8_t *macaddr)
d558 2
a559 1
	IEEE80211_DPRINTF(("%s %s\n", __func__, ether_sprintf(macaddr)));
d581 1
a581 1
ieee80211_alloc_node(struct ieee80211com *ic, u_int8_t *macaddr)
d592 1
a592 1
ieee80211_dup_bss(struct ieee80211com *ic, u_int8_t *macaddr)
d608 1
a608 1
ieee80211_find_node(struct ieee80211com *ic, u_int8_t *macaddr)
d624 1
a624 1
ieee80211_find_txnode(struct ieee80211com *ic, u_int8_t *macaddr)
d690 2
a691 2
ieee80211_needs_rxnode(struct ieee80211com *ic, struct ieee80211_frame *wh,
    u_int8_t **bssid)
d750 2
a751 1
ieee80211_find_rxnode(struct ieee80211com *ic, struct ieee80211_frame *wh)
d755 1
a755 1
	u_int8_t *bssid;
d782 1
a782 1
	    ether_sprintf(wh->i_addr2)));
d788 3
a790 2
ieee80211_find_node_for_beacon(struct ieee80211com *ic, u_int8_t *macaddr,
    struct ieee80211_channel *chan, char *ssid, u_int8_t rssi)
d920 1
a920 1
ieee80211_iserp_sta(struct ieee80211_node *ni)
d924 1
a924 1
	struct ieee80211_rateset *rs = &ni->ni_rates;
d1133 2
a1134 1
ieee80211_node_cmp(struct ieee80211_node *b1, struct ieee80211_node *b2)
@


1.22
log
@de-static

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.21 2007/06/07 20:24:42 damien Exp $	*/
d919 1
a919 1
	static const uint8_t rates[] = { 2, 4, 11, 22, 12, 24, 48 };
@


1.21
log
@expand the IEEE80211_NODE_{LOCK,UNLOCK}* macros into their respective
definitions.
remove comments about "lock order reversals" that are specific to freebsd.

ok reyk@@ jsg@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.20 2007/06/06 19:31:07 damien Exp $	*/
d71 5
a75 17
static struct ieee80211_node *ieee80211_node_alloc(struct ieee80211com *);
static void ieee80211_node_free(struct ieee80211com *, struct ieee80211_node *);
static void ieee80211_node_copy(struct ieee80211com *,
    struct ieee80211_node *, const struct ieee80211_node *);
static u_int8_t ieee80211_node_getrssi(struct ieee80211com *,
    struct ieee80211_node *);
static void ieee80211_setup_node(struct ieee80211com *ic,
    struct ieee80211_node *ni, u_int8_t *macaddr);
static void ieee80211_free_node(struct ieee80211com *,
    struct ieee80211_node *);
static struct ieee80211_node *
    ieee80211_alloc_node_helper(struct ieee80211com *);
static void ieee80211_node_cleanup(struct ieee80211com *,
    struct ieee80211_node *);
static void ieee80211_node_join_11g(struct ieee80211com *,
    struct ieee80211_node *);
static void ieee80211_node_leave_11g(struct ieee80211com *,
d77 7
d115 1
a115 1
static struct ieee80211_node *
d509 1
a509 1
static struct ieee80211_node *
d520 1
a520 1
static void
d529 1
a529 1
static void
d536 1
a536 1
static void
d545 1
a545 1
static u_int8_t
d551 1
a551 1
static void
d807 1
a807 1
static void
d942 1
a942 1
static void
d1041 1
a1041 1
static void
@


1.20
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.19 2007/04/10 17:47:55 miod Exp $	*/
a97 1
	IEEE80211_NODE_LOCK_INIT(ic, ifp->if_xname);
a157 1
	IEEE80211_NODE_LOCK_DESTROY(ic);
d560 2
a564 1
	IEEE80211_NODE_LOCK_BH(ic);
d575 1
d580 1
a580 1
	IEEE80211_NODE_UNLOCK_BH(ic);
d630 1
d640 1
a640 2
	/* XXX can't hold lock across dup_bss 'cuz of recursive locking */
	IEEE80211_NODE_LOCK(ic);
d642 1
a642 1
	IEEE80211_NODE_UNLOCK(ic);
d758 1
d763 1
a763 1
	IEEE80211_NODE_LOCK(ic);
d765 1
a765 1
	IEEE80211_NODE_UNLOCK(ic);
d794 1
a794 1
	int score = 0;
d797 1
a797 1
		IEEE80211_NODE_LOCK(ic);
d806 1
a806 1
		IEEE80211_NODE_UNLOCK(ic);
d836 2
d842 1
a842 1
		IEEE80211_NODE_LOCK_BH(ic);
d844 1
a844 1
		IEEE80211_NODE_UNLOCK_BH(ic);
d852 1
d855 1
a855 1
	IEEE80211_NODE_LOCK_BH(ic);
d858 1
a858 1
	IEEE80211_NODE_UNLOCK_BH(ic);
d865 1
a865 7
 * Timeout inactive nodes.  Note that we cannot hold the node
 * lock while sending a frame as this would lead to a LOR.
 * Instead we use a generation number to mark nodes that we've
 * scanned and drop the lock and restart a scan if we have to
 * time out a node.  Since we are single-threaded by virtue of
 * controlling the inactivity timer we can be sure this will
 * process each node only once.
d872 1
d874 1
a874 1
	IEEE80211_NODE_LOCK(ic);
d891 1
a891 1
			IEEE80211_NODE_UNLOCK(ic);
d895 1
a895 1
			IEEE80211_NODE_LOCK(ic);
d901 1
a901 1
	IEEE80211_NODE_UNLOCK(ic);
d909 1
d911 1
a911 1
	IEEE80211_NODE_LOCK(ic);
d914 1
a914 1
	IEEE80211_NODE_UNLOCK(ic);
@


1.19
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.18 2006/11/15 18:59:37 damien Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.18
log
@s/roundup/howmany/ where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.17 2006/11/13 20:32:45 damien Exp $	*/
d656 1
a656 1
		 * has an opportunity to setup it's private state.
@


1.17
log
@fix a possible NULL deref.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.16 2006/06/19 12:17:56 reyk Exp $	*/
d393 1
a393 1
		u_char occupied[roundup(IEEE80211_CHAN_MAX, NBBY)];
@


1.16
log
@unbreak the code if compiled with IEEE80211_DEBUG by using the right
node attribute.

ok damien@@, figured out by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.15 2006/06/18 18:39:41 damien Exp $	*/
d121 2
a122 2
	}
	memset(ic->ic_aid_bitmap, 0, size);
@


1.15
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.14 2006/02/19 17:34:13 damien Exp $	*/
d1074 1
a1074 1
		    ic->ic_longsta));
@


1.14
log
@Fix a comment in ieee80211_next_scan().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.13 2005/10/09 19:44:22 reyk Exp $	*/
a35 2
#include <sys/cdefs.h>

d89 4
d473 9
d921 72
d1020 2
a1021 2
		/* XXX for 11g must turn off short slot time if long
		   slot time sta associates */
d1048 53
d1117 4
a1146 1

@


1.13
log
@if the wireless hostap interface belongs to a bridge, learn the node's
address dynamically on this interface after successful association.
this could speed wireless roaming to openbsd accesspoints.

ok jason@@, jsg@@ can't see anything obectionable
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.12 2005/10/07 23:30:02 reyk Exp $	*/
d249 1
a249 1
			 * Honor channels marked passive-only
@


1.12
log
@minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.11 2005/09/13 12:11:03 reyk Exp $	*/
d39 1
d69 4
d952 10
d982 10
@


1.11
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.10 2005/09/08 13:24:53 reyk Exp $	*/
d864 2
a865 1
	for (ni = RB_MIN(ieee80211_tree, &ic->ic_tree); ni != NULL; ni = next_ni) {
@


1.10
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.9 2005/09/08 12:44:55 jsg Exp $	*/
d51 1
d96 1
a96 1
	TAILQ_INIT(&ic->ic_node);
d382 1
a382 1
	ni = TAILQ_FIRST(&ic->ic_node);
d394 1
a394 2
		for (; ni != NULL; ni = nextbs) {
			nextbs = TAILQ_NEXT(ni, ni_list);
a395 1
		}
d445 1
a445 1
		nextbs = TAILQ_NEXT(ni, ni_list);
a549 2
	int hash;

a551 1
	hash = IEEE80211_NODE_HASH(macaddr);
d565 1
a565 1
	    TAILQ_EMPTY(&ic->ic_node))
d567 1
a567 2
	TAILQ_INSERT_TAIL(&ic->ic_node, ni, ni_list);
	LIST_INSERT_HEAD(&ic->ic_hash[hash], ni, ni_hash);
a597 20
static struct ieee80211_node *
_ieee80211_find_node(struct ieee80211com *ic, u_int8_t *macaddr)
{
	struct ieee80211_node *ni;
	int hash;

	IEEE80211_NODE_LOCK_ASSERT(ic);

	hash = IEEE80211_NODE_HASH(macaddr);
	LIST_FOREACH(ni, &ic->ic_hash[hash], ni_hash) {
		if (IEEE80211_ADDR_EQ(ni->ni_macaddr, macaddr)) {
			/* least-recently used is at tail */
			TAILQ_REMOVE(&ic->ic_node, ni, ni_list);
			TAILQ_INSERT_TAIL(&ic->ic_node, ni, ni_list);
			return ni;
		}
	}
	return NULL;
}

d601 1
a601 1
	struct ieee80211_node *ni;
d603 2
a604 4
	IEEE80211_NODE_LOCK(ic);
	ni = _ieee80211_find_node(ic, macaddr);
	IEEE80211_NODE_UNLOCK(ic);
	return ni;
d629 1
a629 1
	ni = _ieee80211_find_node(ic, macaddr);
d751 1
a751 1
	ni = _ieee80211_find_node(ic, wh->i_addr2);
a775 7
/*
 * Like find but search based on the channel too.
 *
 * Note that ieee80211_find_node_for_beacon does not increase the
 * reference count before returning the node, because drivers are not
 * expected to call it.
 */
d778 1
a778 1
    struct ieee80211_channel *chan, char *ssid)
d780 2
a781 2
	struct ieee80211_node *ni, *best;
	int hash, best_score, score;
d783 2
a784 2
	best = NULL;
	best_score = -1;
d786 3
a788 9
	hash = IEEE80211_NODE_HASH(macaddr);
	IEEE80211_NODE_LOCK(ic);
	LIST_FOREACH(ni, &ic->ic_hash[hash], ni_hash) {
		if (!IEEE80211_ADDR_EQ(ni->ni_macaddr, macaddr))
			continue;

		score = (ni->ni_chan == chan) ? 1 : 0;

		if (ssid[1] == 0 || ni->ni_esslen == 0)
d790 2
a791 3
		else if (ssid[1] != ni->ni_esslen ||
		     memcmp(ssid + 2, ni->ni_essid, ssid[1]) != 0)
			continue;
d793 1
a793 4
		if (score > best_score) {
			best = ni;
			best_score = score;
		}
a794 3
	IEEE80211_NODE_UNLOCK(ic);
	return best;
}
d796 1
a796 6
struct ieee80211_node *
ieee80211_lookup_node(struct ieee80211com *ic,
	u_int8_t *macaddr, struct ieee80211_channel *chan)
{
	char ssid[2] = { 0, 0 };
	return ieee80211_find_node_for_beacon(ic, macaddr, chan, ssid);
d807 1
a807 2
	TAILQ_REMOVE(&ic->ic_node, ni, ni_list);
	LIST_REMOVE(ni, ni_hash);
d814 1
a814 1
	if (TAILQ_EMPTY(&ic->ic_node))
d840 1
a840 1
	while ((ni = TAILQ_FIRST(&ic->ic_node)) != NULL)
d864 2
a865 2
	for (ni = TAILQ_FIRST(&ic->ic_node); ni != NULL; ni = next_ni) {
		next_ni = TAILQ_NEXT(ni, ni_list);
d899 1
a899 1
	TAILQ_FOREACH(ni, &ic->ic_node, ni_list)
d967 15
@


1.9
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.8 2005/09/08 09:11:08 jsg Exp $	*/
d74 1
a74 1
		struct ieee80211_node *, const struct ieee80211_node *);
d76 1
a76 2
		struct ieee80211_node *);

d78 1
a78 1
		struct ieee80211_node *ni, u_int8_t *macaddr);
d80 3
a82 2
		struct ieee80211_node *);
static struct ieee80211_node *ieee80211_alloc_node_helper(struct ieee80211com *);
d84 1
a84 1
                struct ieee80211_node *);
d156 2
a157 2
        if (ic->ic_aid_bitmap != NULL)
                FREE(ic->ic_aid_bitmap, M_DEVBUF);
d302 2
a303 2
        u_int8_t rate;
        int fail;
d411 1
a411 1
  notfound:
d519 4
a522 4
        if (ni->ni_challenge != NULL) {
                FREE(ni->ni_challenge, M_DEVBUF);
                ni->ni_challenge = NULL;
        }
d775 1
a775 1
	        return ieee80211_ref_node(ic->ic_bss);
d946 2
a947 1
ieee80211_iterate_nodes(struct ieee80211com *ic, ieee80211_iter_func *f, void *arg)
@


1.8
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.7 2005/09/08 08:36:12 reyk Exp $	*/
a67 1
#include <net80211/ieee80211_compat.h>
d138 2
a139 1
	IASSERT(ni != NULL, ("unable to setup inital BSS node"));
d854 2
a855 1
	IASSERT(ni != ic->ic_bss, ("freeing bss node"));
d1007 2
a1008 3

	IASSERT(ic->ic_opmode == IEEE80211_M_HOSTAP,
	    ("not in ap mode, mode %u", ic->ic_opmode));
@


1.7
log
@reset the scan state for each new mode

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.6 2005/09/07 05:40:11 jsg Exp $	*/
d202 1
a202 1
		if_printf(ifp, "begin %s scan\n",
d271 1
a271 1
		if_printf(ifp, "creating ibss\n");
d374 1
a374 1
		if_printf(ifp, "end %s scan\n",
@


1.6
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.5 2005/05/25 07:40:49 reyk Exp $	*/
d168 1
a168 1
static void
d176 1
a176 1
	if (ic->ic_bss->ni_chan == IEEE80211_CHAN_ANYC)
d205 1
d207 4
a210 5
	 * Clear scan state and flush any previously seen
	 * AP's.  Note that the latter assumes we don't act
	 * as both an AP and a station, otherwise we'll
	 * potentially flush state of stations associated
	 * with us.
a211 1
	ieee80211_reset_scan(ifp);
d214 5
a218 2
	/* Reset the current mode. */
	if (IFM_MODE(ic->ic_media.ifm_cur->ifm_media) == IFM_AUTO) {
d220 1
a220 2
		ieee80211_setmode(ic, ic->ic_curmode);
	}
a439 1
		ieee80211_reset_scan(ifp);
@


1.5
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.4 2005/04/21 22:47:15 reyk Exp $	*/
a36 9
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_node.c,v 1.22 2004/04/05 04:15:55 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_node.c,v 1.14 2004/05/09 09:18:47 dyoung Exp $");
#endif

#if defined(__NetBSD__)
#include "opt_inet.h"
#endif
a48 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a51 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a55 5
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a63 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a64 3
#else
#include <net/if_ether.h>
#endif
a69 1
#ifdef __OpenBSD__
a70 1
#endif
a86 3
#ifdef __NetBSD__
MALLOC_DEFINE(M_80211_NODE, "80211node", "802.11 node state");
#else
a87 1
#endif
@


1.4
log
@scan the next mode if nothing has been found. this is necessary if the
device supports different incompatible modes in the same channel
range, like like 11b and "pure" 11G mode.

ok dlg@@ pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.3 2005/02/17 18:28:05 reyk Exp $	*/
d219 4
d252 2
d408 3
a410 1
	ic->ic_flags &= ~IEEE80211_F_ASCAN;
d437 1
a437 1
		return;
d446 1
a446 1
			return;
d453 2
a454 1
		 * like 11b and "pure" 11G mode.
d456 10
a465 1
		ieee80211_next_mode(ifp);
d508 8
@


1.3
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_node.c,v 1.2 2004/11/02 15:39:02 millert Exp $	*/
d242 6
d440 9
@


1.2
log
@Don't call memset() if MALLOC returns NULL; also fix the rcs ID.
From Patrick Latifi; OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
static void _ieee80211_free_node(struct ieee80211com *,
d110 3
d124 1
a125 2
#ifdef __FreeBSD__
	/* XXX need unit */
a126 1
#endif
d133 28
d169 1
a169 1
	ni = (*ic->ic_node_alloc)(ic);
d172 1
a172 1
	ic->ic_bss = ni;
d181 1
a181 1
	if (ic->ic_bss != NULL)
d183 2
a185 1
#ifdef __FreeBSD__
d187 2
a188 1
#endif
d274 1
a274 1
	IEEE80211_DPRINTF(("ieee80211_next_scan: chan %d->%d\n",
d295 6
a300 2
	if (ic->ic_opmode == IEEE80211_M_IBSS)
		ni->ni_bssid[0] |= 0x02;	/* local bit for IBSS */
d391 5
a409 1
			ieee80211_ref_node(ni);
a411 1
			ieee80211_free_node(ic, ni);
d442 1
a442 2
	if (ifp->if_flags & IFF_DEBUG)
		if_printf(ifp, "\tmacaddr          bssid         chan  rssi rate flag  wep  essid\n");
a443 1
		ieee80211_ref_node(ni);
d458 1
a458 2
			else if (ni->ni_rssi > selbs->ni_rssi) {
				ieee80211_unref_node(&selbs);
a459 4
			} else
				ieee80211_unref_node(&ni);
		} else {
			ieee80211_unref_node(&ni);
d465 1
d469 1
a469 3
		if (ic->ic_bss->ni_rates.rs_nrates == 0) {
			selbs->ni_fails++;
			ieee80211_unref_node(&selbs);
a470 10
		}
		ieee80211_unref_node(&selbs);
		/*
		 * Discard scan set; the nodes have a refcnt of zero
		 * and have not asked the driver to setup private
		 * node state.  Let them be repopulated on demand either
		 * through transmission (ieee80211_find_txnode) or receipt
		 * of a probe response (to be added).
		 */
		ieee80211_free_allnodes(ic);
a472 1
		ieee80211_unref_node(&selbs);
d507 9
d518 1
a518 4
	if (ni->ni_challenge != NULL) {
		FREE(ni->ni_challenge, M_DEVBUF);
		ni->ni_challenge = NULL;
	}
d526 1
a541 1
	ieee80211_node_critsec_decl(s);
d543 1
d546 4
a549 5
	ni->ni_refcnt = 1;		/* mark referenced */
	ieee80211_node_critsec_begin(ic, s);
	TAILQ_INSERT_TAIL(&ic->ic_node, ni, ni_list);
	LIST_INSERT_HEAD(&ic->ic_hash[hash], ni, ni_hash);
	/*
d558 2
a559 1
	if (ic->ic_opmode != IEEE80211_M_STA)
d561 3
a563 1
	ieee80211_node_critsec_end(ic, s);
d569 1
a569 1
	struct ieee80211_node *ni = (*ic->ic_node_alloc)(ic);
d580 1
a580 1
	struct ieee80211_node *ni = (*ic->ic_node_alloc)(ic);
a598 1
#ifdef __FreeBSD__
a599 1
#endif /* __FreeBSD__ */
d604 3
a606 1
			ieee80211_node_incref(ni); /* mark referenced */
a616 1
	ieee80211_node_critsec_decl(s);
d618 1
a618 1
	ieee80211_node_critsec_begin(ic, s);
d620 1
a620 1
	ieee80211_node_critsec_end(ic, s);
d627 3
a634 1
	ieee80211_node_critsec_decl(s);
d642 1
a642 1
		return ic->ic_bss;
d645 1
a645 1
	ieee80211_node_critsec_begin(ic, s);
d647 6
a652 4
	ieee80211_node_critsec_end(ic, s);
	if (ni == NULL &&
	    (ic->ic_opmode == IEEE80211_M_IBSS ||
	     ic->ic_opmode == IEEE80211_M_AHDEMO)) {
d662 6
a667 7
		ni = ieee80211_dup_bss(ic, macaddr);
		if (ni != NULL) {
			/* XXX no rate negotiation; just dup */
			ni->ni_rates = ic->ic_bss->ni_rates;
			if (ic->ic_newassoc)
				(*ic->ic_newassoc)(ic, ni, 1);
		}
d669 1
a669 1
	return ni;
d673 8
a680 8
 * For some types of packet and for some operating modes, it is
 * desirable to process a Rx packet using its sender's node-record
 * instead of the BSS record, when that is possible.
 *
 * - AP mode: it is desirable to keep a node-record for every
 *   authenticated/associated station *in the BSS*. For future use,
 *   we also track neighboring APs, since they might belong to the
 *   same ESSID.
d682 2
a683 2
 * - IBSS mode: it is desirable to keep a node-record for every
 *   station *in the BSS*.
d685 2
a686 2
 * - monitor mode: it is desirable to keep a node-record for every
 *   sender, regardless of BSS.
d702 1
a702 1
	int needsnode, rc = 0;
d704 1
a704 4
	if (ic->ic_opmode == IEEE80211_M_STA)
		return 0;

	needsnode = (ic->ic_opmode == IEEE80211_M_MONITOR);
d710 2
a713 1

d716 12
a727 1
		rc = IEEE80211_ADDR_EQ(*bssid, bss->ni_bssid);
d750 1
a750 1
	return needsnode || rc;
d753 4
a762 1
	ieee80211_node_critsec_decl(s);
d767 1
a767 1
	ieee80211_node_critsec_begin(ic, s);
d769 1
a769 1
	ieee80211_node_critsec_end(ic, s);
d771 20
a790 20
	if (ni == NULL) {
		if (ic->ic_opmode != IEEE80211_M_HOSTAP) {
			if ((ni = ieee80211_dup_bss(ic, wh->i_addr2)) != NULL)
				IEEE80211_ADDR_COPY(ni->ni_bssid,
				    (bssid != NULL) ? bssid : zero);

			/* XXX see remarks in ieee80211_find_txnode */
			if (ni != NULL) {
				/* XXX no rate negotiation; just dup */
				ni->ni_rates = ic->ic_bss->ni_rates;
				if (ic->ic_newassoc)
					(*ic->ic_newassoc)(ic, ni, 1);
			}
			IEEE80211_DPRINTF(("%s: faked-up node %p for %s\n",
			    __func__, ni, ether_sprintf(wh->i_addr2)));
		}
		ni = ieee80211_ref_node((ni == NULL) ? ic->ic_bss : ni);
	}
	IASSERT(ni != NULL, ("%s: null node", __func__));
	return ni;
d795 4
d801 2
a802 2
ieee80211_lookup_node(struct ieee80211com *ic,
	u_int8_t *macaddr, struct ieee80211_channel *chan)
d804 5
a808 3
	struct ieee80211_node *ni;
	int hash;
	ieee80211_node_critsec_decl(s);
d811 1
a811 1
	ieee80211_node_critsec_begin(ic, s);
d813 14
a826 4
		if (IEEE80211_ADDR_EQ(ni->ni_macaddr, macaddr) &&
		    ni->ni_chan == chan) {
			ieee80211_node_incref(ni);/* mark referenced */
			break;
d829 10
a838 2
	ieee80211_node_critsec_end(ic, s);
	return ni;
d842 1
a842 1
_ieee80211_free_node(struct ieee80211com *ic, struct ieee80211_node *ni)
d846 1
d850 1
d854 1
a854 1
			ic->ic_set_tim(ic, ni->ni_associd, 0);
d859 1
d863 1
a863 1
ieee80211_free_node(struct ieee80211com *ic, struct ieee80211_node *ni)
d865 7
a871 8
	ieee80211_node_critsec_decl(s);

	IASSERT(ni != ic->ic_bss, ("freeing ic_bss"));

	if (ieee80211_node_decref(ni) == 0) {
		ieee80211_node_critsec_begin(ic, s);
		_ieee80211_free_node(ic, ni);
		ieee80211_node_critsec_end(ic, s);
a878 1
	ieee80211_node_critsec_decl(s);
d880 2
a881 1
	ieee80211_node_critsec_begin(ic, s);
d883 5
a887 2
		_ieee80211_free_node(ic, ni);
	ieee80211_node_critsec_end(ic, s);
d900 1
a900 1
ieee80211_timeout_nodes(struct ieee80211com *ic)
d902 1
a902 2
	struct ieee80211_node *ni;
	ieee80211_node_critsec_decl(s);
d905 5
a909 3
restart:
	ieee80211_node_critsec_begin(ic, s);
	TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
d913 9
a921 14
		if (++ni->ni_inact > ieee80211_inact_max) {
			IEEE80211_DPRINTF(("station %s timed out "
			    "due to inactivity (%u secs)\n",
			    ether_sprintf(ni->ni_macaddr),
			    ni->ni_inact));
			/*
			 * Send a deauthenticate frame.
			 *
			 * Drop the node lock before sending the
			 * deauthentication frame in case the driver takes
			 * a lock, as this will result in a LOR between the
			 * node lock and the driver lock.
			 */
			ieee80211_node_critsec_end(ic, s);
d925 3
d929 1
a929 3
			ic->ic_stats.is_node_timeout++;
			goto restart;
		}
d931 1
a931 3
	if (!TAILQ_EMPTY(&ic->ic_node))
		ic->ic_inact_timer = IEEE80211_INACT_WAIT;
	ieee80211_node_critsec_end(ic, s);
a937 1
	ieee80211_node_critsec_decl(s);
d939 1
a939 1
	ieee80211_node_critsec_begin(ic, s);
d942 66
a1007 1
	ieee80211_node_critsec_end(ic, s);
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD $	*/
d482 2
a483 1
	memset(ni, 0, sizeof(struct ieee80211_node));
@

