head	1.58;
access;
symbols
	OPENBSD_6_0:1.58.0.4
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.2
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.40.0.6
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.14
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.12
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.10
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.8
	OPENBSD_5_0:1.39.0.6
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.39.0.4
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.36.0.4
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.29.0.2
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.4.0.2
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.58
date	2016.01.13.14.33.07;	author stsp;	state Exp;
branches;
next	1.57;
commitid	e5aJLtIDyRGeLf8e;

1.57
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.56;
commitid	1npmDuWgN1zBR6BQ;

1.56
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.55;
commitid	2QagMjdMhQhIaQgu;

1.55
date	2016.01.04.12.25.46;	author stsp;	state Exp;
branches;
next	1.54;
commitid	qxghNKrIQP4oLgDx;

1.54
date	2016.01.04.12.23.53;	author stsp;	state Exp;
branches;
next	1.53;
commitid	QO4kbODgjb7dCHKd;

1.53
date	2015.12.18.07.42.24;	author stsp;	state Exp;
branches;
next	1.52;
commitid	ge5Esp6WEV2EfITy;

1.52
date	2015.12.16.12.52.03;	author stsp;	state Exp;
branches;
next	1.51;
commitid	W5JoApj5cAa7SF36;

1.51
date	2015.11.27.04.03.45;	author jsg;	state Exp;
branches;
next	1.50;
commitid	dasRFlLIaXe6kALB;

1.50
date	2015.11.15.12.34.07;	author stsp;	state Exp;
branches;
next	1.49;
commitid	H9x7JLZ3OXXsR8Zh;

1.49
date	2015.11.15.10.21.58;	author stsp;	state Exp;
branches;
next	1.48;
commitid	qP9X1zKeQo43nhkU;

1.48
date	2015.11.15.01.05.25;	author stsp;	state Exp;
branches;
next	1.47;
commitid	8QkBLu4fXKUF5YHk;

1.47
date	2015.10.17.21.30.29;	author stsp;	state Exp;
branches;
next	1.46;
commitid	VsP1IfuyBfXQB0ql;

1.46
date	2015.09.27.16.51.31;	author stsp;	state Exp;
branches;
next	1.45;
commitid	5o9NLs0KUeEhqoBD;

1.45
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.44;
commitid	6vhYvh5CxZAHMnsN;

1.44
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.43;
commitid	p4LJxGKbi0BU2cG6;

1.43
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.42;
commitid	PYnSnAqgemmk34E3;

1.42
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.41;
commitid	uzzBR7hz9ncd4O6G;

1.41
date	2014.08.08.15.16.39;	author jasper;	state Exp;
branches;
next	1.40;
commitid	XqlyEl7HuWPLWo47;

1.40
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.21.18.09.31;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.02.22.31.50;	author sobrado;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.03.20.35.37;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.26.20.03.34;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.11.17.14.05.01;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.11.14.11.16.27;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2007.11.03.14.59.55;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.01.22.34.19;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.15.14.55.30;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.03.20.25.32;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.12.25.19.24.26;	author reyk;	state Exp;
branches;
next	1.19;

1.19
date	2006.12.20.08.13.56;	author grange;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.26.11.14.23;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.04.06.04.42;	author canacar;	state Exp;
branches;
next	1.15;

1.15
date	2005.12.09.03.48.11;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.07.23.30.02;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.08.13.24.52;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.08.08.36.12;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.28.12.01.53;	author reyk;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.21.22.47.15;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.20.19.52.43;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.03.20.42.41;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Fix fallout from turbo mode removal commit: Channel initialization
was broken and lots of drivers ran into trouble as a result.
ok deraadt@@
@
text
@/*	$OpenBSD: ieee80211.c,v 1.57 2016/01/12 09:28:09 stsp Exp $	*/
/*	$NetBSD: ieee80211.c,v 1.19 2004/06/06 05:45:29 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IEEE 802.11 generic handler
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

#ifdef IEEE80211_DEBUG
int	ieee80211_debug = 0;
#endif

int ieee80211_cache_size = IEEE80211_CACHE_SIZE;

struct ieee80211com_head ieee80211com_head =
    LIST_HEAD_INITIALIZER(ieee80211com_head);

void ieee80211_setbasicrates(struct ieee80211com *);
int ieee80211_findrate(struct ieee80211com *, enum ieee80211_phymode, int);

void
ieee80211_channel_init(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_channel *c;
	int i;

	/*
	 * Fill in 802.11 available channel set, mark
	 * all available channels as active, and pick
	 * a default channel if not already specified.
	 */
	memset(ic->ic_chan_avail, 0, sizeof(ic->ic_chan_avail));
	ic->ic_modecaps |= 1<<IEEE80211_MODE_AUTO;
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		c = &ic->ic_channels[i];
		if (c->ic_flags) {
			/*
			 * Verify driver passed us valid data.
			 */
			if (i != ieee80211_chan2ieee(ic, c)) {
				printf("%s: bad channel ignored; "
					"freq %u flags %x number %u\n",
					ifp->if_xname, c->ic_freq, c->ic_flags,
					i);
				c->ic_flags = 0;	/* NB: remove */
				continue;
			}
			setbit(ic->ic_chan_avail, i);
			/*
			 * Identify mode capabilities.
			 */
			if (IEEE80211_IS_CHAN_A(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_11A;
			if (IEEE80211_IS_CHAN_B(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_11B;
			if (IEEE80211_IS_CHAN_PUREG(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_11G;
			if (IEEE80211_IS_CHAN_N(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_11N;
		}
	}
	/* validate ic->ic_curmode */
	if ((ic->ic_modecaps & (1<<ic->ic_curmode)) == 0)
		ic->ic_curmode = IEEE80211_MODE_AUTO;
	ic->ic_des_chan = IEEE80211_CHAN_ANYC;	/* any channel is ok */
	ic->ic_scan_lock = IEEE80211_SCAN_UNLOCKED;
}

void
ieee80211_ifattach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	memcpy(((struct arpcom *)ifp)->ac_enaddr, ic->ic_myaddr,
		ETHER_ADDR_LEN);
	ether_ifattach(ifp);

	ifp->if_output = ieee80211_output;

#if NBPFILTER > 0
	bpfattach(&ic->ic_rawbpf, ifp, DLT_IEEE802_11,
	    sizeof(struct ieee80211_frame_addr4));
#endif
	ieee80211_crypto_attach(ifp);

	ieee80211_channel_init(ifp);

	/* IEEE 802.11 defines a MTU >= 2290 */
	ifp->if_capabilities |= IFCAP_VLAN_MTU;

	ieee80211_setbasicrates(ic);
	(void)ieee80211_setmode(ic, ic->ic_curmode);

	if (ic->ic_lintval == 0)
		ic->ic_lintval = 100;		/* default sleep */
	ic->ic_bmisstimeout = 7*ic->ic_lintval;	/* default 7 beacons */
	ic->ic_dtim_period = 1;	/* all TIMs are DTIMs */

	LIST_INSERT_HEAD(&ieee80211com_head, ic, ic_list);
	ieee80211_node_attach(ifp);
	ieee80211_proto_attach(ifp);

	if_addgroup(ifp, "wlan");
	ifp->if_priority = IF_WIRELESS_DEFAULT_PRIORITY;
}

void
ieee80211_ifdetach(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	ieee80211_proto_detach(ifp);
	ieee80211_crypto_detach(ifp);
	ieee80211_node_detach(ifp);
	LIST_REMOVE(ic, ic_list);
	ifmedia_delete_instance(&ic->ic_media, IFM_INST_ANY);
	ether_ifdetach(ifp);
}

/*
 * Convert MHz frequency to IEEE channel number.
 */
u_int
ieee80211_mhz2ieee(u_int freq, u_int flags)
{
	if (flags & IEEE80211_CHAN_2GHZ) {	/* 2GHz band */
		if (freq == 2484)
			return 14;
		if (freq < 2484)
			return (freq - 2407) / 5;
		else
			return 15 + ((freq - 2512) / 20);
	} else if (flags & IEEE80211_CHAN_5GHZ) {	/* 5GHz band */
		return (freq - 5000) / 5;
	} else {				/* either, guess */
		if (freq == 2484)
			return 14;
		if (freq < 2484)
			return (freq - 2407) / 5;
		if (freq < 5000)
			return 15 + ((freq - 2512) / 20);
		return (freq - 5000) / 5;
	}
}

/*
 * Convert channel to IEEE channel number.
 */
u_int
ieee80211_chan2ieee(struct ieee80211com *ic, const struct ieee80211_channel *c)
{
	struct ifnet *ifp = &ic->ic_if;
	if (ic->ic_channels <= c && c <= &ic->ic_channels[IEEE80211_CHAN_MAX])
		return c - ic->ic_channels;
	else if (c == IEEE80211_CHAN_ANYC)
		return IEEE80211_CHAN_ANY;
	else if (c != NULL) {
		printf("%s: invalid channel freq %u flags %x\n",
			ifp->if_xname, c->ic_freq, c->ic_flags);
		return 0;		/* XXX */
	} else {
		printf("%s: invalid channel (NULL)\n", ifp->if_xname);
		return 0;		/* XXX */
	}
}

/*
 * Convert IEEE channel number to MHz frequency.
 */
u_int
ieee80211_ieee2mhz(u_int chan, u_int flags)
{
	if (flags & IEEE80211_CHAN_2GHZ) {	/* 2GHz band */
		if (chan == 14)
			return 2484;
		if (chan < 14)
			return 2407 + chan*5;
		else
			return 2512 + ((chan-15)*20);
	} else if (flags & IEEE80211_CHAN_5GHZ) {/* 5GHz band */
		return 5000 + (chan*5);
	} else {				/* either, guess */
		if (chan == 14)
			return 2484;
		if (chan < 14)			/* 0-13 */
			return 2407 + chan*5;
		if (chan < 27)			/* 15-26 */
			return 2512 + ((chan-15)*20);
		return 5000 + (chan*5);
	}
}

/*
 * Setup the media data structures according to the channel and
 * rate tables.  This must be called by the driver after
 * ieee80211_attach and before most anything else.
 */
void
ieee80211_media_init(struct ifnet *ifp,
	ifm_change_cb_t media_change, ifm_stat_cb_t media_stat)
{
#define	ADD(_ic, _s, _o) \
	ifmedia_add(&(_ic)->ic_media, \
		IFM_MAKEWORD(IFM_IEEE80211, (_s), (_o), 0), 0, NULL)
	struct ieee80211com *ic = (void *)ifp;
	struct ifmediareq imr;
	int i, j, mode, rate, maxrate, r;
	uint64_t mword, mopt;
	const struct ieee80211_rateset *rs;
	struct ieee80211_rateset allrates;

	/*
	 * Do late attach work that must wait for any subclass
	 * (i.e. driver) work such as overriding methods.
	 */
	ieee80211_node_lateattach(ifp);

	/*
	 * Fill in media characteristics.
	 */
	ifmedia_init(&ic->ic_media, 0, media_change, media_stat);
	maxrate = 0;
	memset(&allrates, 0, sizeof(allrates));
	for (mode = IEEE80211_MODE_AUTO; mode <= IEEE80211_MODE_11G; mode++) {
		static const uint64_t mopts[] = {
			IFM_AUTO,
			IFM_IEEE80211_11A,
			IFM_IEEE80211_11B,
			IFM_IEEE80211_11G,
		};
		if ((ic->ic_modecaps & (1<<mode)) == 0)
			continue;
		mopt = mopts[mode];
		ADD(ic, IFM_AUTO, mopt);	/* e.g. 11a auto */
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_caps & IEEE80211_C_IBSS)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_IBSS);
		if (ic->ic_caps & IEEE80211_C_HOSTAP)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_HOSTAP);
		if (ic->ic_caps & IEEE80211_C_AHDEMO)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_ADHOC);
#endif
		if (ic->ic_caps & IEEE80211_C_MONITOR)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_MONITOR);
		if (mode == IEEE80211_MODE_AUTO)
			continue;
		rs = &ic->ic_sup_rates[mode];
		for (i = 0; i < rs->rs_nrates; i++) {
			rate = rs->rs_rates[i];
			mword = ieee80211_rate2media(ic, rate, mode);
			if (mword == 0)
				continue;
			ADD(ic, mword, mopt);
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_caps & IEEE80211_C_IBSS)
				ADD(ic, mword, mopt | IFM_IEEE80211_IBSS);
			if (ic->ic_caps & IEEE80211_C_HOSTAP)
				ADD(ic, mword, mopt | IFM_IEEE80211_HOSTAP);
			if (ic->ic_caps & IEEE80211_C_AHDEMO)
				ADD(ic, mword, mopt | IFM_IEEE80211_ADHOC);
#endif
			if (ic->ic_caps & IEEE80211_C_MONITOR)
				ADD(ic, mword, mopt | IFM_IEEE80211_MONITOR);
			/*
			 * Add rate to the collection of all rates.
			 */
			r = rate & IEEE80211_RATE_VAL;
			for (j = 0; j < allrates.rs_nrates; j++)
				if (allrates.rs_rates[j] == r)
					break;
			if (j == allrates.rs_nrates) {
				/* unique, add to the set */
				allrates.rs_rates[j] = r;
				allrates.rs_nrates++;
			}
			rate = (rate & IEEE80211_RATE_VAL) / 2;
			if (rate > maxrate)
				maxrate = rate;
		}
	}
	for (i = 0; i < allrates.rs_nrates; i++) {
		mword = ieee80211_rate2media(ic, allrates.rs_rates[i],
				IEEE80211_MODE_AUTO);
		if (mword == 0)
			continue;
		mword = IFM_SUBTYPE(mword);	/* remove media options */
		ADD(ic, mword, 0);
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_caps & IEEE80211_C_IBSS)
			ADD(ic, mword, IFM_IEEE80211_IBSS);
		if (ic->ic_caps & IEEE80211_C_HOSTAP)
			ADD(ic, mword, IFM_IEEE80211_HOSTAP);
		if (ic->ic_caps & IEEE80211_C_AHDEMO)
			ADD(ic, mword, IFM_IEEE80211_ADHOC);
#endif
		if (ic->ic_caps & IEEE80211_C_MONITOR)
			ADD(ic, mword, IFM_IEEE80211_MONITOR);
	}

	if (ic->ic_modecaps & (1 << IEEE80211_MODE_11N)) {
		mopt = IFM_IEEE80211_11N;
		ADD(ic, IFM_AUTO, mopt);
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_caps & IEEE80211_C_IBSS)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_IBSS);
		if (ic->ic_caps & IEEE80211_C_HOSTAP)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_HOSTAP);
#endif
		if (ic->ic_caps & IEEE80211_C_MONITOR)
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_MONITOR);
		for (i = 0; i < IEEE80211_HT_NUM_MCS; i++) {
			if (!isset(ic->ic_sup_mcs, i))
				continue;
			ADD(ic, IFM_IEEE80211_HT_MCS0 + i, mopt);
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_caps & IEEE80211_C_IBSS)
				ADD(ic, IFM_IEEE80211_HT_MCS0 + i,
				     mopt | IFM_IEEE80211_IBSS);
			if (ic->ic_caps & IEEE80211_C_HOSTAP)
				ADD(ic, IFM_IEEE80211_HT_MCS0 + i,
				    mopt | IFM_IEEE80211_HOSTAP);
#endif
			if (ic->ic_caps & IEEE80211_C_MONITOR)
				ADD(ic, IFM_IEEE80211_HT_MCS0 + i,
				    mopt | IFM_IEEE80211_MONITOR);
		}
		ic->ic_flags |= IEEE80211_F_HTON; /* enable 11n by default */
	}

	ieee80211_media_status(ifp, &imr);
	ifmedia_set(&ic->ic_media, imr.ifm_active);

	if (maxrate)
		ifp->if_baudrate = IF_Mbps(maxrate);

#undef ADD
}

int
ieee80211_findrate(struct ieee80211com *ic, enum ieee80211_phymode mode,
    int rate)
{
#define	IEEERATE(_ic,_m,_i) \
	((_ic)->ic_sup_rates[_m].rs_rates[_i] & IEEE80211_RATE_VAL)
	int i, nrates = ic->ic_sup_rates[mode].rs_nrates;
	for (i = 0; i < nrates; i++)
		if (IEEERATE(ic, mode, i) == rate)
			return i;
	return -1;
#undef IEEERATE
}

/*
 * Handle a media change request.
 */
int
ieee80211_media_change(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ifmedia_entry *ime;
	enum ieee80211_opmode newopmode;
	enum ieee80211_phymode newphymode;
	int i, j, newrate, error = 0;

	ime = ic->ic_media.ifm_cur;
	/*
	 * First, identify the phy mode.
	 */
	switch (IFM_MODE(ime->ifm_media)) {
	case IFM_IEEE80211_11A:
		newphymode = IEEE80211_MODE_11A;
		break;
	case IFM_IEEE80211_11B:
		newphymode = IEEE80211_MODE_11B;
		break;
	case IFM_IEEE80211_11G:
		newphymode = IEEE80211_MODE_11G;
		break;
	case IFM_IEEE80211_11N:
		newphymode = IEEE80211_MODE_11N;
		break;
	case IFM_AUTO:
		newphymode = IEEE80211_MODE_AUTO;
		break;
	default:
		return EINVAL;
	}

	/*
	 * Validate requested mode is available.
	 */
	if ((ic->ic_modecaps & (1<<newphymode)) == 0)
		return EINVAL;

	/*
	 * Next, the fixed/variable rate.
	 */
	i = -1;
	if (IFM_SUBTYPE(ime->ifm_media) >= IFM_IEEE80211_HT_MCS0 &&
	    IFM_SUBTYPE(ime->ifm_media) <= IFM_IEEE80211_HT_MCS76) {
		if ((ic->ic_modecaps & (1 << IEEE80211_MODE_11N)) == 0)
			return EINVAL;
		if (newphymode != IEEE80211_MODE_AUTO &&
		    newphymode != IEEE80211_MODE_11N)
			return EINVAL;
		i = ieee80211_media2mcs(ime->ifm_media);
		if (i == -1 || isclr(ic->ic_sup_mcs, i))
			return EINVAL;
	} else if (IFM_SUBTYPE(ime->ifm_media) != IFM_AUTO) {
		/*
		 * Convert media subtype to rate.
		 */
		newrate = ieee80211_media2rate(ime->ifm_media);
		if (newrate == 0)
			return EINVAL;
		/*
		 * Check the rate table for the specified/current phy.
		 */
		if (newphymode == IEEE80211_MODE_AUTO) {
			/*
			 * In autoselect mode search for the rate.
			 */
			for (j = IEEE80211_MODE_11A;
			     j < IEEE80211_MODE_MAX; j++) {
				if ((ic->ic_modecaps & (1<<j)) == 0)
					continue;
				i = ieee80211_findrate(ic, j, newrate);
				if (i != -1) {
					/* lock mode too */
					newphymode = j;
					break;
				}
			}
		} else {
			i = ieee80211_findrate(ic, newphymode, newrate);
		}
		if (i == -1)			/* mode/rate mismatch */
			return EINVAL;
	}
	/* NB: defer rate setting to later */

	/*
	 * Deduce new operating mode but don't install it just yet.
	 */
#ifndef IEEE80211_STA_ONLY
	if (ime->ifm_media & IFM_IEEE80211_ADHOC)
		newopmode = IEEE80211_M_AHDEMO;
	else if (ime->ifm_media & IFM_IEEE80211_HOSTAP)
		newopmode = IEEE80211_M_HOSTAP;
	else if (ime->ifm_media & IFM_IEEE80211_IBSS)
		newopmode = IEEE80211_M_IBSS;
	else
#endif
	if (ime->ifm_media & IFM_IEEE80211_MONITOR)
		newopmode = IEEE80211_M_MONITOR;
	else
		newopmode = IEEE80211_M_STA;

#ifndef IEEE80211_STA_ONLY
	/*
	 * Autoselect doesn't make sense when operating as an AP.
	 * If no phy mode has been selected, pick one and lock it
	 * down so rate tables can be used in forming beacon frames
	 * and the like.
	 */
	if (newopmode == IEEE80211_M_HOSTAP &&
	    newphymode == IEEE80211_MODE_AUTO) {
		if (ic->ic_modecaps & (1 << IEEE80211_MODE_11N))
			newphymode = IEEE80211_MODE_11N;
		else if (ic->ic_modecaps & (1 << IEEE80211_MODE_11A))
			newphymode = IEEE80211_MODE_11A;
		else if (ic->ic_modecaps & (1 << IEEE80211_MODE_11G))
			newphymode = IEEE80211_MODE_11G;
		else
			newphymode = IEEE80211_MODE_11B;
	}
#endif

	/*
	 * Handle phy mode change.
	 */
	if (ic->ic_curmode != newphymode) {		/* change phy mode */
		error = ieee80211_setmode(ic, newphymode);
		if (error != 0)
			return error;
		error = ENETRESET;
	}

	/*
	 * Committed to changes, install the MCS/rate setting.
	 */
	ic->ic_flags &= ~IEEE80211_F_HTON;
	if ((ic->ic_modecaps & (1 << IEEE80211_MODE_11N)) &&
	    (newphymode == IEEE80211_MODE_AUTO ||
	    newphymode == IEEE80211_MODE_11N))
		ic->ic_flags |= IEEE80211_F_HTON;
	if ((ic->ic_flags & IEEE80211_F_HTON) == 0) {
		ic->ic_fixed_mcs = -1;
	    	if (ic->ic_fixed_rate != i) {
			ic->ic_fixed_rate = i;		/* set fixed tx rate */
			error = ENETRESET;
		}
	} else {
		ic->ic_fixed_rate = -1;
		if (ic->ic_fixed_mcs != i) {
			ic->ic_fixed_mcs = i;		/* set fixed mcs */
			error = ENETRESET;
		}
	}

	/*
	 * Handle operating mode change.
	 */
	if (ic->ic_opmode != newopmode) {
		ic->ic_opmode = newopmode;
#ifndef IEEE80211_STA_ONLY
		switch (newopmode) {
		case IEEE80211_M_AHDEMO:
		case IEEE80211_M_HOSTAP:
		case IEEE80211_M_STA:
		case IEEE80211_M_MONITOR:
			ic->ic_flags &= ~IEEE80211_F_IBSSON;
			break;
		case IEEE80211_M_IBSS:
			ic->ic_flags |= IEEE80211_F_IBSSON;
			break;
		}
#endif
		/*
		 * Yech, slot time may change depending on the
		 * operating mode so reset it to be sure everything
		 * is setup appropriately.
		 */
		ieee80211_reset_erp(ic);
		error = ENETRESET;
	}
#ifdef notdef
	if (error == 0)
		ifp->if_baudrate = ifmedia_baudrate(ime->ifm_media);
#endif
	return error;
}

void
ieee80211_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct ieee80211com *ic = (void *)ifp;
	const struct ieee80211_node *ni = NULL;

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN &&
	    (ic->ic_opmode != IEEE80211_M_STA ||
	     !(ic->ic_flags & IEEE80211_F_RSNON) ||
	     ic->ic_bss->ni_port_valid))
		imr->ifm_status |= IFM_ACTIVE;
	imr->ifm_active |= IFM_AUTO;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		ni = ic->ic_bss;
		if (ic->ic_curmode == IEEE80211_MODE_11N)
			imr->ifm_active |= ieee80211_mcs2media(ic,
				ni->ni_txmcs, ic->ic_curmode);
		else
			/* calculate rate subtype */
			imr->ifm_active |= ieee80211_rate2media(ic,
				ni->ni_rates.rs_rates[ni->ni_txrate],
				ic->ic_curmode);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_IBSS;
		break;
	case IEEE80211_M_AHDEMO:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_HOSTAP:
		imr->ifm_active |= IFM_IEEE80211_HOSTAP;
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		break;
	}
	switch (ic->ic_curmode) {
	case IEEE80211_MODE_11A:
		imr->ifm_active |= IFM_IEEE80211_11A;
		break;
	case IEEE80211_MODE_11B:
		imr->ifm_active |= IFM_IEEE80211_11B;
		break;
	case IEEE80211_MODE_11G:
		imr->ifm_active |= IFM_IEEE80211_11G;
		break;
	case IEEE80211_MODE_11N:
		imr->ifm_active |= IFM_IEEE80211_11N;
		break;
	}
}

void
ieee80211_watchdog(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	if (ic->ic_mgt_timer && --ic->ic_mgt_timer == 0)
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	if (ic->ic_mgt_timer != 0)
		ifp->if_timer = 1;
}

const struct ieee80211_rateset ieee80211_std_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

const struct ieee80211_rateset ieee80211_std_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

const struct ieee80211_rateset ieee80211_std_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

/*
 * Mark the basic rates for the 11g rate table based on the
 * operating mode.  For real 11g we mark all the 11b rates
 * and 6, 12, and 24 OFDM.  For 11b compatibility we mark only
 * 11b rates.  There's also a pseudo 11a-mode used to mark only
 * the basic OFDM rates.
 */
void
ieee80211_setbasicrates(struct ieee80211com *ic)
{
	static const struct ieee80211_rateset basic[] = {
	    { 0 },				/* IEEE80211_MODE_AUTO */
	    { 3, { 12, 24, 48 } },		/* IEEE80211_MODE_11A */
	    { 2, { 2, 4 } },			/* IEEE80211_MODE_11B */
	    { 4, { 2, 4, 11, 22 } },		/* IEEE80211_MODE_11G */
	    { 0 },				/* IEEE80211_MODE_11N	*/
	};
	enum ieee80211_phymode mode;
	struct ieee80211_rateset *rs;
	int i, j;

	for (mode = 0; mode < IEEE80211_MODE_MAX; mode++) {
		rs = &ic->ic_sup_rates[mode];
		for (i = 0; i < rs->rs_nrates; i++) {
			rs->rs_rates[i] &= IEEE80211_RATE_VAL;
			for (j = 0; j < basic[mode].rs_nrates; j++) {
				if (basic[mode].rs_rates[j] ==
				    rs->rs_rates[i]) {
					rs->rs_rates[i] |=
					    IEEE80211_RATE_BASIC;
					break;
				}
			}
		}
	}
}

/*
 * Set the current phy mode and recalculate the active channel
 * set based on the available channels for this mode.  Also
 * select a new default/current channel if the current one is
 * inappropriate for this mode.
 */
int
ieee80211_setmode(struct ieee80211com *ic, enum ieee80211_phymode mode)
{
	struct ifnet *ifp = &ic->ic_if;
	static const u_int chanflags[] = {
		0,			/* IEEE80211_MODE_AUTO */
		IEEE80211_CHAN_A,	/* IEEE80211_MODE_11A */
		IEEE80211_CHAN_B,	/* IEEE80211_MODE_11B */
		IEEE80211_CHAN_PUREG,	/* IEEE80211_MODE_11G */
		IEEE80211_CHAN_HT,	/* IEEE80211_MODE_11N */
	};
	const struct ieee80211_channel *c;
	u_int modeflags;
	int i;

	/* validate new mode */
	if ((ic->ic_modecaps & (1<<mode)) == 0) {
		DPRINTF(("mode %u not supported (caps 0x%x)\n",
		    mode, ic->ic_modecaps));
		return EINVAL;
	}

	/*
	 * Verify at least one channel is present in the available
	 * channel list before committing to the new mode.
	 */
	if (mode >= nitems(chanflags))
		panic("unexpected mode %u", mode);
	modeflags = chanflags[mode];
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		c = &ic->ic_channels[i];
		if (mode == IEEE80211_MODE_AUTO) {
			if (c->ic_flags != 0)
				break;
		} else if ((c->ic_flags & modeflags) == modeflags)
			break;
	}
	if (i > IEEE80211_CHAN_MAX) {
		DPRINTF(("no channels found for mode %u\n", mode));
		return EINVAL;
	}

	/*
	 * Calculate the active channel set.
	 */
	memset(ic->ic_chan_active, 0, sizeof(ic->ic_chan_active));
	for (i = 0; i <= IEEE80211_CHAN_MAX; i++) {
		c = &ic->ic_channels[i];
		if (mode == IEEE80211_MODE_AUTO) {
			if (c->ic_flags != 0)
				setbit(ic->ic_chan_active, i);
		} else if ((c->ic_flags & modeflags) == modeflags)
			setbit(ic->ic_chan_active, i);
	}
	/*
	 * If no current/default channel is setup or the current
	 * channel is wrong for the mode then pick the first
	 * available channel from the active list.  This is likely
	 * not the right one.
	 */
	if (ic->ic_ibss_chan == NULL || isclr(ic->ic_chan_active,
	    ieee80211_chan2ieee(ic, ic->ic_ibss_chan))) {
		for (i = 0; i <= IEEE80211_CHAN_MAX; i++)
			if (isset(ic->ic_chan_active, i)) {
				ic->ic_ibss_chan = &ic->ic_channels[i];
				break;
			}
		if ((ic->ic_ibss_chan == NULL) || isclr(ic->ic_chan_active,
		    ieee80211_chan2ieee(ic, ic->ic_ibss_chan)))
			panic("Bad IBSS channel %u",
			    ieee80211_chan2ieee(ic, ic->ic_ibss_chan));
	}

	/*
	 * Reset the scan state for the new mode. This avoids scanning
	 * of invalid channels, ie. 5GHz channels in 11b mode.
	 */
	ieee80211_reset_scan(ifp);

	ic->ic_curmode = mode;
	ieee80211_reset_erp(ic);	/* reset ERP state */

	return 0;
}

enum ieee80211_phymode
ieee80211_next_mode(struct ifnet *ifp)
{
	struct ieee80211com *ic = (void *)ifp;

	if (IFM_MODE(ic->ic_media.ifm_cur->ifm_media) != IFM_AUTO) {
		/*
		 * Reset the scan state and indicate a wrap around
		 * if we're running in a fixed, user-specified phy mode.
		 */
		ieee80211_reset_scan(ifp);
		return (IEEE80211_MODE_AUTO);
	}

	/*
	 * Get the next supported mode
	 */
	for (++ic->ic_curmode;
	    ic->ic_curmode <= IEEE80211_MODE_MAX;
	    ic->ic_curmode++) {
		/* 
		 * Skip over 11n mode. Its set of channels is the superset
		 * of all channels supported by the other modes.
		 */
		if (ic->ic_curmode == IEEE80211_MODE_11N)
			continue;

		if (ic->ic_curmode >= IEEE80211_MODE_MAX) {
			ic->ic_curmode = IEEE80211_MODE_AUTO;
			break;
		}

		if (ic->ic_modecaps & (1 << ic->ic_curmode))
			break;
	}

	ieee80211_setmode(ic, ic->ic_curmode);

	return (ic->ic_curmode);
}

/*
 * Return the phy mode for with the specified channel so the
 * caller can select a rate set.  This is problematic and the
 * work here assumes how things work elsewhere in this code.
 *
 * Because the result of this function is ultimately used to select a
 * rate from the rate set of the returned mode, it must not return
 * IEEE80211_MODE_11N, which uses MCS instead of rates for unicast frames.
 */
enum ieee80211_phymode
ieee80211_chan2mode(struct ieee80211com *ic,
    const struct ieee80211_channel *chan)
{
	/*
	 * NB: this assumes the channel would not be supplied to us
	 *     unless it was already compatible with the current mode.
	 */
	if (ic->ic_curmode != IEEE80211_MODE_11N &&
	    (ic->ic_curmode != IEEE80211_MODE_AUTO ||
	    chan == IEEE80211_CHAN_ANYC))
		return ic->ic_curmode;
	/*
	 * In autoselect or 11n mode; deduce a mode based on the channel
	 * characteristics.
	 */
	if (IEEE80211_IS_CHAN_5GHZ(chan))
		return IEEE80211_MODE_11A;
	else if (chan->ic_flags & (IEEE80211_CHAN_OFDM|IEEE80211_CHAN_DYN))
		return IEEE80211_MODE_11G;
	else
		return IEEE80211_MODE_11B;
}

/*
 * Convert IEEE80211 MCS index to ifmedia subtype.
 */
uint64_t
ieee80211_mcs2media(struct ieee80211com *ic, int mcs,
    enum ieee80211_phymode mode)
{
	switch (mode) {
	case IEEE80211_MODE_11A:
	case IEEE80211_MODE_11B:
	case IEEE80211_MODE_11G:
		/* these modes use rates, not MCS */
		panic("unexpected mode %d", mode);
		break;
	case IEEE80211_MODE_AUTO:
	case IEEE80211_MODE_11N:
		if (mcs >= 0 && mcs < IEEE80211_HT_NUM_MCS)
			return (IFM_IEEE80211_11N |
			    (IFM_IEEE80211_HT_MCS0 + mcs));
		break;
	}

	return IFM_AUTO;
}

/*
 * Convert ifmedia subtype to IEEE80211 MCS index.
 */
int
ieee80211_media2mcs(uint64_t mword)
{
	uint64_t subtype;

	subtype = IFM_SUBTYPE(mword);

	if (subtype == IFM_AUTO)
		return -1;
	else if (subtype == IFM_MANUAL || subtype == IFM_NONE)
		return 0;

	if (subtype >= IFM_IEEE80211_HT_MCS0 &&
	    subtype <= IFM_IEEE80211_HT_MCS76)
		return (int)(subtype - IFM_IEEE80211_HT_MCS0);

	return -1;
}

/*
 * convert IEEE80211 rate value to ifmedia subtype.
 * ieee80211 rate is in unit of 0.5Mbps.
 */
uint64_t
ieee80211_rate2media(struct ieee80211com *ic, int rate,
    enum ieee80211_phymode mode)
{
	static const struct {
		uint64_t	m;	/* rate + mode */
		uint64_t	r;	/* if_media rate */
	} rates[] = {
		{   2 | IFM_IEEE80211_11B, IFM_IEEE80211_DS1 },
		{   4 | IFM_IEEE80211_11B, IFM_IEEE80211_DS2 },
		{  11 | IFM_IEEE80211_11B, IFM_IEEE80211_DS5 },
		{  22 | IFM_IEEE80211_11B, IFM_IEEE80211_DS11 },
		{  44 | IFM_IEEE80211_11B, IFM_IEEE80211_DS22 },
		{  12 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM6 },
		{  18 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM9 },
		{  24 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM12 },
		{  36 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM18 },
		{  48 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM24 },
		{  72 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM36 },
		{  96 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM48 },
		{ 108 | IFM_IEEE80211_11A, IFM_IEEE80211_OFDM54 },
		{   2 | IFM_IEEE80211_11G, IFM_IEEE80211_DS1 },
		{   4 | IFM_IEEE80211_11G, IFM_IEEE80211_DS2 },
		{  11 | IFM_IEEE80211_11G, IFM_IEEE80211_DS5 },
		{  22 | IFM_IEEE80211_11G, IFM_IEEE80211_DS11 },
		{  12 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM6 },
		{  18 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM9 },
		{  24 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM12 },
		{  36 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM18 },
		{  48 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM24 },
		{  72 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM36 },
		{  96 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM48 },
		{ 108 | IFM_IEEE80211_11G, IFM_IEEE80211_OFDM54 },
		/* NB: OFDM72 doesn't really exist so we don't handle it */
	};
	uint64_t mask;
	int i;

	mask = rate & IEEE80211_RATE_VAL;
	switch (mode) {
	case IEEE80211_MODE_11A:
		mask |= IFM_IEEE80211_11A;
		break;
	case IEEE80211_MODE_11B:
		mask |= IFM_IEEE80211_11B;
		break;
	case IEEE80211_MODE_AUTO:
		/* NB: hack, 11g matches both 11b+11a rates */
		/* FALLTHROUGH */
	case IEEE80211_MODE_11G:
		mask |= IFM_IEEE80211_11G;
		break;
	case IEEE80211_MODE_11N:
		/* 11n uses MCS, not rates. */
		panic("unexpected mode %d", mode);
		break;
	}
	for (i = 0; i < nitems(rates); i++)
		if (rates[i].m == mask)
			return rates[i].r;
	return IFM_AUTO;
}

int
ieee80211_media2rate(uint64_t mword)
{
	int i;
	static const struct {
		uint64_t subtype;
		int rate;
	} ieeerates[] = {
		{ IFM_AUTO,		-1	},
		{ IFM_MANUAL,		0	},
		{ IFM_NONE,		0	},
		{ IFM_IEEE80211_DS1,	2	},
		{ IFM_IEEE80211_DS2,	4	},
		{ IFM_IEEE80211_DS5,	11	},
		{ IFM_IEEE80211_DS11,	22	},
		{ IFM_IEEE80211_DS22,	44	},
		{ IFM_IEEE80211_OFDM6,	12	},
		{ IFM_IEEE80211_OFDM9,	18	},
		{ IFM_IEEE80211_OFDM12,	24	},
		{ IFM_IEEE80211_OFDM18,	36	},
		{ IFM_IEEE80211_OFDM24,	48	},
		{ IFM_IEEE80211_OFDM36,	72	},
		{ IFM_IEEE80211_OFDM48,	96	},
		{ IFM_IEEE80211_OFDM54,	108	},
		{ IFM_IEEE80211_OFDM72,	144	},
	};
	for (i = 0; i < nitems(ieeerates); i++) {
		if (ieeerates[i].subtype == IFM_SUBTYPE(mword))
			return ieeerates[i].rate;
	}
	return 0;
}

/*
 * Convert bit rate (in 0.5Mbps units) to PLCP signal (R4-R1) and vice versa.
 */
u_int8_t
ieee80211_rate2plcp(u_int8_t rate, enum ieee80211_phymode mode)
{
	rate &= IEEE80211_RATE_VAL;

	if (mode == IEEE80211_MODE_11B) {
		/* IEEE Std 802.11b-1999 page 15, subclause 18.2.3.3 */
		switch (rate) {
		case 2:		return 10;
		case 4:		return 20;
		case 11:	return 55;
		case 22:	return 110;
		/* IEEE Std 802.11g-2003 page 19, subclause 19.3.2.1 */
		case 44:	return 220;
		}
	} else if (mode == IEEE80211_MODE_11G || mode == IEEE80211_MODE_11A) {
		/* IEEE Std 802.11a-1999 page 14, subclause 17.3.4.1 */
		switch (rate) {
		case 12:	return 0x0b;
		case 18:	return 0x0f;
		case 24:	return 0x0a;
		case 36:	return 0x0e;
		case 48:	return 0x09;
		case 72:	return 0x0d;
		case 96:	return 0x08;
		case 108:	return 0x0c;
		}
        } else
		panic("unexpected mode %u", mode);

	DPRINTF(("unsupported rate %u\n", rate));

	return 0;
}

u_int8_t
ieee80211_plcp2rate(u_int8_t plcp, enum ieee80211_phymode mode)
{
	if (mode == IEEE80211_MODE_11B) {
		/* IEEE Std 802.11g-2003 page 19, subclause 19.3.2.1 */
		switch (plcp) {
		case 10:	return 2;
		case 20:	return 4;
		case 55:	return 11;
		case 110:	return 22;
		/* IEEE Std 802.11g-2003 page 19, subclause 19.3.2.1 */
		case 220:	return 44;
		}
	} else if (mode == IEEE80211_MODE_11G || mode == IEEE80211_MODE_11A) {
		/* IEEE Std 802.11a-1999 page 14, subclause 17.3.4.1 */
		switch (plcp) {
		case 0x0b:	return 12;
		case 0x0f:	return 18;
		case 0x0a:	return 24;
		case 0x0e:	return 36;
		case 0x09:	return 48;
		case 0x0d:	return 72;
		case 0x08:	return 96;
		case 0x0c:	return 108;
		}
	} else
		panic("unexpected mode %u", mode);

	DPRINTF(("unsupported plcp %u\n", plcp));

	return 0;
}
@


1.57
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.56 2016/01/05 18:41:16 stsp Exp $	*/
d752 4
a755 2
		if (mode == IEEE80211_MODE_AUTO ||
		    (c->ic_flags & modeflags) == modeflags)
d769 4
a772 2
		if (mode == IEEE80211_MODE_AUTO ||
		    (c->ic_flags & modeflags) == modeflags)
@


1.56
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.55 2016/01/04 12:25:46 stsp Exp $	*/
a111 2
			if (IEEE80211_IS_CHAN_T(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_TURBO;
d278 1
a278 1
	for (mode = IEEE80211_MODE_AUTO; mode <= IEEE80211_MODE_TURBO; mode++) {
a283 1
			IFM_IEEE80211_11A | IFM_IEEE80211_TURBO,
d442 1
a442 9
	/*
	 * Turbo mode is an ``option''.  Eventually it
	 * needs to be applied to 11g too.
	 */
	if (ime->ifm_media & IFM_IEEE80211_TURBO) {
		if (newphymode != IEEE80211_MODE_11A)
			return EINVAL;
		newphymode = IEEE80211_MODE_TURBO;
	}
a650 4
	case IEEE80211_MODE_TURBO:
		imr->ifm_active |= IFM_IEEE80211_11A
				|  IFM_IEEE80211_TURBO;
		break;
a692 1
	    { 0 },				/* IEEE80211_MODE_TURBO	*/
a729 1
		IEEE80211_CHAN_T,	/* IEEE80211_MODE_TURBO	*/
d752 3
a754 8
		if (mode == IEEE80211_MODE_AUTO) {
			/* ignore turbo channels for autoselect */
			if ((c->ic_flags &~ IEEE80211_CHAN_TURBO) != 0)
				break;
		} else {
			if ((c->ic_flags & modeflags) == modeflags)
				break;
		}
d767 3
a769 8
		if (mode == IEEE80211_MODE_AUTO) {
			/* take anything but pure turbo channels */
			if ((c->ic_flags &~ IEEE80211_CHAN_TURBO) != 0)
				setbit(ic->ic_chan_active, i);
		} else {
			if ((c->ic_flags & modeflags) == modeflags)
				setbit(ic->ic_chan_active, i);
		}
a821 4
		/* Wrap around and ignore turbo mode */
		if (ic->ic_curmode == IEEE80211_MODE_TURBO)
			continue;

a850 2
 *
 * XXX never returns turbo modes -dcy
d866 1
a866 2
	 * characteristics.  We assume that turbo-only channels
	 * are not considered when the channel set is constructed.
d868 1
a868 3
	if (IEEE80211_IS_CHAN_T(chan))
		return IEEE80211_MODE_TURBO;
	else if (IEEE80211_IS_CHAN_5GHZ(chan))
a884 1
	case IEEE80211_MODE_TURBO:
a967 1
	case IEEE80211_MODE_TURBO:
@


1.55
log
@Don't return 11n mode from ieee80211_chan2mode() so we can switch into
11a and 11b/g mode correctly when the driver supports 11n.
And make sure the result of this funtion is only used to index ic_sup_rates.
Its stated purpose is to help select a legacy rate.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.54 2016/01/04 12:23:53 stsp Exp $	*/
a113 1
#ifndef IEEE80211_NO_HT
a115 1
#endif
a356 1
#ifndef IEEE80211_NO_HT
a385 1
#endif /* IEEE80211_NO_HT */
a435 1
#ifndef IEEE80211_NO_HT
a438 1
#endif
a465 1
#ifndef IEEE80211_NO_HT
a473 3
#else
			return EINVAL;
#endif
a532 1
#ifndef IEEE80211_NO_HT
d535 1
a535 3
		else
#endif
		if (ic->ic_modecaps & (1 << IEEE80211_MODE_11A))
a557 1
#ifndef IEEE80211_NO_HT
a561 1
#endif
a562 1
#ifndef IEEE80211_NO_HT
a563 1
#endif
d568 1
a568 3
	}
#ifndef IEEE80211_NO_HT
	else {
a574 1
#endif
a625 1
#ifndef IEEE80211_NO_HT
a629 1
#endif
a665 1
#ifndef IEEE80211_NO_HT
a668 1
#endif
a746 1
#ifndef IEEE80211_NO_HT
a747 1
#endif
d852 1
a852 1
#ifndef IEEE80211_NO_HT
d859 1
a859 1
#endif
a911 1
#ifndef IEEE80211_NO_HT
a958 1
#endif /* IEEE80211_NO_HT */
@


1.54
log
@Skip over 11n mode during scanning to avoid scanning channels more than once.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.53 2015/12/18 07:42:24 stsp Exp $	*/
d905 4
d919 3
a921 2
	if (ic->ic_curmode != IEEE80211_MODE_AUTO ||
	    chan == IEEE80211_CHAN_ANYC)
d924 1
a924 1
	 * In autoselect mode; deduce a mode based on the channel
a927 5
#ifndef IEEE80211_NO_HT
	if (IEEE80211_IS_CHAN_N(chan))
		return IEEE80211_MODE_11N;
	else
#endif
@


1.53
log
@Fix out of bounds array access in ieee80211_setbasicrates().
found by + ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.52 2015/12/16 12:52:03 stsp Exp $	*/
d878 8
@


1.52
log
@Don't forget about monitor mode while building the ifmedia list
for 802.11n capable wireless drivers.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.51 2015/11/27 04:03:45 jsg Exp $	*/
d733 1
@


1.51
log
@correct logic for a IEEE80211_MODE_11N test
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.50 2015/11/15 12:34:07 stsp Exp $	*/
d369 2
d383 3
@


1.50
log
@Expose 11n mode to the ifmedia layer and introduce the concept of MCS.
Make sure 11n features are enabled only if media type is autoselect or 11n.

11n mode uses MCS (modulation & coding scheme) instead of rates like 11a/b/g.
This means we'll have to take the current mode into account and decide whether
to use a rate or an MCS for transmission. Receiving frames on legacy rates
will still work in 11n mode. We just won't be using legacy rates to send
data frames to an STA or AP we negotiated 11n features with.

My initial plan was to grow the ieee80211_rateset structure and treat MCS
just like rates. However, ieee80211_rateset corresponds to rates and xrates
elements in management frames and is copied directly into such elements
so its size cannot change. Thus, MCS stands on its own and corresponds to
elements in management frames related to 11n HT capabilities.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.49 2015/11/15 10:21:58 stsp Exp $	*/
d470 1
a470 1
		if (newphymode != IEEE80211_MODE_AUTO ||
@


1.49
log
@IEEE80211_MODE_MAX has been raised to include 11n mode so make sure that
ieee80211_media_init doesn't index its rates array beyond turbo mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.48 2015/11/15 01:05:25 stsp Exp $	*/
d114 4
d358 28
d435 5
d465 15
a479 1
	if (IFM_SUBTYPE(ime->ifm_media) != IFM_AUTO) {
d538 11
a548 5
		for (j = IEEE80211_MODE_11A; j < IEEE80211_MODE_MAX; j++)
			if (ic->ic_modecaps & (1<<j)) {
				newphymode = j;
				break;
			}
d563 1
a563 1
	 * Committed to changes, install the rate setting.
d565 23
a587 3
	if (ic->ic_fixed_rate != i) {
		ic->ic_fixed_rate = i;			/* set fixed tx rate */
		error = ENETRESET;
d589 1
d641 10
a650 3
		/* calculate rate subtype */
		imr->ifm_active |= ieee80211_rate2media(ic,
			ni->ni_rates.rs_rates[ni->ni_txrate], ic->ic_curmode);
d683 5
d765 3
d867 1
a867 1
	    ic->ic_curmode <= IEEE80211_MODE_TURBO;
d870 3
a872 1
		if (ic->ic_curmode >= IEEE80211_MODE_TURBO) {
d909 5
d923 50
@


1.48
log
@Declare 802.11n mode and channel flags. Tweak 11n related fields in struct
ieee80211com and move them inside #ifndef IEEE80211_NO_HT without breaking
the build in rsu(4) for RAMDISK_CD.
Also declare 11n protection modes and MCS count.
ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.47 2015/10/17 21:30:29 stsp Exp $	*/
d278 1
a278 1
	for (mode = IEEE80211_MODE_AUTO; mode < IEEE80211_MODE_MAX; mode++) {
@


1.47
log
@Spell all "unexpected mode %u" panics in lower case, not just one of them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.46 2015/09/27 16:51:31 stsp Exp $	*/
d880 4
@


1.46
log
@Add ieee80211_channel_init(), factored out from ieee80211_ifattach().
Will be used by iwm(4) soon.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.45 2015/09/11 13:02:28 stsp Exp $	*/
d692 1
a692 1
		panic("Unexpected mode %u", mode);
d952 1
a952 1
		panic("Unexpected mode %u", mode);
@


1.45
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.44 2015/03/14 03:38:51 jsg Exp $	*/
d75 1
a75 1
ieee80211_ifattach(struct ifnet *ifp)
a80 12
	memcpy(((struct arpcom *)ifp)->ac_enaddr, ic->ic_myaddr,
		ETHER_ADDR_LEN);
	ether_ifattach(ifp);

	ifp->if_output = ieee80211_output;

#if NBPFILTER > 0
	bpfattach(&ic->ic_rawbpf, ifp, DLT_IEEE802_11,
	    sizeof(struct ieee80211_frame_addr4));
#endif
	ieee80211_crypto_attach(ifp);

d121 20
@


1.44
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.43 2014/12/23 03:24:08 tedu Exp $	*/
d253 2
a254 1
	int i, j, mode, rate, maxrate, mword, mopt, r;
d271 1
a271 1
		static const u_int mopts[] = {
d820 1
a820 1
int
d825 2
a826 2
		u_int	m;	/* rate + mode */
		u_int	r;	/* if_media rate */
d855 2
a856 1
	u_int mask, i;
d881 1
a881 1
ieee80211_media2rate(int mword)
d885 1
a885 1
		int subtype;
@


1.43
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.42 2014/09/14 14:17:26 jsg Exp $	*/
a50 1
#include <net/if_arp.h>
@


1.42
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.41 2014/08/08 15:16:39 jasper Exp $	*/
a56 1
#ifdef INET
a58 1
#endif
@


1.41
log
@use nitems() instead of various local constructs

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.40 2013/11/21 16:16:08 mpi Exp $	*/
a45 1
#include <sys/proc.h>
@


1.40
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.39 2010/08/07 03:50:02 krw Exp $	*/
a662 1
#define	N(a)	(sizeof(a) / sizeof(a[0]))
d686 1
a686 1
	if (mode >= N(chanflags))
a748 1
#undef N
a826 1
#define	N(a)	(sizeof(a) / sizeof(a[0]))
d876 1
a876 1
	for (i = 0; i < N(rates); i++)
a879 1
#undef N
a884 1
#define	N(a)	(sizeof(a) / sizeof(a[0]))
d908 1
a908 1
	for (i = 0; i < N(ieeerates); i++) {
a912 1
#undef N
@


1.39
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.38 2009/11/21 18:09:31 damien Exp $	*/
a52 1
#include <net/if_llc.h>
@


1.38
log
@when wpa is enabled, defer setting the link up until the 802.1X
port is valid (keys have been successfully exchanged.)
this avoids dhclient timeouts when wpa is enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.37 2009/11/02 22:31:50 sobrado Exp $	*/
d737 1
a737 1
			panic("Bad IBSS channel %u\n",
@


1.37
log
@s/hz/Hz/ on multiples of the SI unit hertz other than MHz.

reminded by STeve Andre.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.36 2009/06/03 20:35:37 beck Exp $	*/
d550 4
a553 1
	if (ic->ic_state == IEEE80211_S_RUN)
@


1.36
log
@make wireless interfaces priority 4 by default. other interfaces remain
priority 0.  while we are in here make sure we add wi interfaces to group "wlan"
in the same way the net80211 stuff already is.

this makes dhcp multiple default routes useful on laptops.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.35 2008/08/29 12:14:53 damien Exp $	*/
d184 1
a184 1
	} else if (flags & IEEE80211_CHAN_5GHZ) {	/* 5Ghz band */
d231 1
a231 1
	} else if (flags & IEEE80211_CHAN_5GHZ) {/* 5Ghz band */
@


1.35
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.34 2008/08/27 09:05:04 damien Exp $	*/
d155 1
@


1.34
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.33 2008/07/27 14:21:15 damien Exp $	*/
a128 2
			if (IEEE80211_IS_CHAN_FHSS(c))
				ic->ic_modecaps |= 1<<IEEE80211_MODE_FH;
a278 1
			IFM_IEEE80211_FH,
a397 3
	case IFM_IEEE80211_FH:
		newphymode = IEEE80211_MODE_FH;
		break;
a585 3
	case IEEE80211_MODE_FH:
		imr->ifm_active |= IFM_IEEE80211_FH;
		break;
a628 1
	    { 2, { 2, 4 } },			/* IEEE80211_MODE_FH */
a666 1
		IEEE80211_CHAN_FHSS,	/* IEEE80211_MODE_FH */
a811 2
	else if (IEEE80211_IS_CHAN_FHSS(chan))
		return IEEE80211_MODE_FH;
a830 2
		{   2 | IFM_IEEE80211_FH, IFM_IEEE80211_FH1 },
		{   4 | IFM_IEEE80211_FH, IFM_IEEE80211_FH2 },
a868 3
	case IEEE80211_MODE_FH:
		mask |= IFM_IEEE80211_FH;
		break;
a869 5
		/* NB: ic may be NULL for some drivers */
		if (ic && ic->ic_phytype == IEEE80211_T_FH) {
			mask |= IFM_IEEE80211_FH;
			break;
		}
a894 2
		{ IFM_IEEE80211_FH1,	2	},
		{ IFM_IEEE80211_FH2,	4	},
@


1.33
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.32 2008/07/21 19:27:26 damien Exp $	*/
d288 1
d295 1
d307 1
d314 1
d341 1
d348 1
d465 1
d472 3
a474 1
	else if (ime->ifm_media & IFM_IEEE80211_MONITOR)
d479 1
d494 1
d519 1
d531 1
d565 1
d575 1
d578 2
@


1.32
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.31 2008/04/26 20:03:34 damien Exp $	*/
d669 2
a670 2
		IEEE80211_DPRINTF(("%s: mode %u not supported (caps 0x%x)\n",
			__func__, mode, ic->ic_modecaps));
d693 1
a693 2
		IEEE80211_DPRINTF(("%s: no channels found for mode %u\n",
			__func__, mode));
d959 1
a959 1
	IEEE80211_DPRINTF(("%s: unsupported rate %u\n", __func__, rate));
d990 1
a990 1
		panic("Unexpected mode %u", mode);
d992 1
a992 1
	IEEE80211_DPRINTF(("%s: unsupported plcp %u\n", __func__, plcp));
@


1.31
log
@move things from ieee80211_ifattach() to ieee80211_crypto_attach().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.30 2008/04/16 18:32:15 damien Exp $	*/
d65 1
@


1.30
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.29 2007/11/17 14:05:01 damien Exp $	*/
d144 1
a144 1
	(void) ieee80211_setmode(ic, ic->ic_curmode);
a149 12

	if (ic->ic_caps & IEEE80211_C_RSN) {
		ic->ic_rsnprotos =
		    IEEE80211_PROTO_WPA | IEEE80211_PROTO_RSN;
		ic->ic_rsnakms =
		    IEEE80211_AKM_PSK | IEEE80211_AKM_IEEE8021X;
		ic->ic_rsnciphers =
		    IEEE80211_CIPHER_TKIP | IEEE80211_CIPHER_CCMP;
		ic->ic_rsngroupcipher = IEEE80211_CIPHER_TKIP;
	}
	ic->ic_set_key = ieee80211_set_key;
	ic->ic_delete_key = ieee80211_delete_key;
@


1.29
log
@make it clear in the code and in the man page that the rate2plcp and
plcp2rate functions use plcp codes in most-significant-bit-first format
(R4-R1).
some drivers like wpi(4) and iwn(4) want plcp codes in lsb-first format
so they can't use those functions.
also the IEEE standard uses R1-R4 notation so this can be a bit confusing
for those refering to it.

use u_int8_t for plcp code and rate instead of int.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.28 2007/11/14 11:16:27 mglocker Exp $	*/
d151 12
a1007 1

@


1.28
log
@Add ieee80211_rate2plcp() and ieee80211_plcp2rate() functions, which
convert the PLCP header signal field to a rate value and vice versa.

This implementation has been discussed with Damien and doesn't change
any existing net80211 structures.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.27 2007/11/03 14:59:55 mglocker Exp $	*/
d927 1
a927 1
 * Convert bit rate (in 0.5Mbps units) to PLCP signal and vice versa.
d929 2
a930 2
int
ieee80211_rate2plcp(int rate, enum ieee80211_phymode mode)
d964 2
a965 2
int
ieee80211_plcp2rate(int plcp, enum ieee80211_phymode mode)
d996 1
@


1.27
log
@Revert last commit which added ieee80211_rate2plcp() and
ieee80211_plcp2rate() because I've got a late feedback from Damien that
he dislike the implementation method a lot.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.26 2007/11/01 22:34:19 mglocker Exp $	*/
d924 71
@


1.26
log
@Add ieee80211_rate2plcp() and ieee80211_plcp2rate() functions.

Help and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.25 2007/09/15 14:55:30 krw Exp $	*/
d597 1
a597 2
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 },
	{ 0x0b, 0x0f, 0x0a, 0x0e, 0x09, 0x0d, 0x08, 0x0c } };
d600 1
a600 2
	{ 4, { 2, 4, 11, 22 },
	{ 0x0a, 0x14, 0x37, 0x6e } };
d603 1
a603 3
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 },
	{ 0x0a, 0x14, 0x37, 0x6e, 0x0b, 0x0f, 0x0a, 0x0e, 0x09, 0x0d, 0x08,
	  0x0c } };
a923 38
}

/*
 * Convert bit rate (in 0.5Mbps units) to PLCP signal and vice versa.
 */
u_int8_t
ieee80211_rate2plcp(struct ieee80211com *ic, int rate,
    enum ieee80211_phymode mode)
{
	int i;

	rate &= IEEE80211_RATE_VAL;

	for (i = 0; i < IEEE80211_RATE_MAXSIZE; i++) {
		if (ic->ic_sup_rates[mode].rs_rates[i] == rate)
			return (ic->ic_sup_rates[mode].rs_plcp[i]);
	}

	IEEE80211_DPRINTF(("%s: unsupported rate %u\n", __func__, rate));

	return (0);
}

int
ieee80211_plcp2rate(struct ieee80211com *ic, u_int8_t plcp,
    enum ieee80211_phymode mode)
{
	int i;

	for (i = 0; i < IEEE80211_RATE_MAXSIZE; i++) {
		if (ic->ic_sup_rates[mode].rs_plcp[i] == plcp)
			return (ic->ic_sup_rates[mode].rs_rates[i] &
			    IEEE80211_RATE_VAL);
	}

	IEEE80211_DPRINTF(("%s: unsupported plcp %u\n", __func__, plcp));

	return (0);
@


1.25
log
@realy -> really in comments. Most reported on tech@@ by Jung.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.24 2007/07/03 20:25:32 damien Exp $	*/
d597 2
a598 1
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };
d601 2
a602 1
	{ 4, { 2, 4, 11, 22 } };
d605 3
a607 1
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };
d928 38
@


1.24
log
@maintain the traffic-indication (TIM) virtual bitmap by defining
a default ieee80211_set_tim() function that drivers can override
by setting ic_set_tim.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.23 2007/06/16 13:17:05 damien Exp $	*/
d854 1
a854 1
		/* NB: OFDM72 doesn't realy exist so we don't handle it */
@


1.23
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.22 2007/06/16 11:56:20 damien Exp $	*/
d149 1
@


1.22
log
@de-static

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.21 2007/06/06 19:31:07 damien Exp $	*/
d200 1
a200 1
ieee80211_chan2ieee(struct ieee80211com *ic, struct ieee80211_channel *c)
d258 1
a258 1
	struct ieee80211_rateset *rs;
d536 1
a536 1
	struct ieee80211_node *ni = NULL;
d595 1
a595 1
struct ieee80211_rateset ieee80211_std_rateset_11a =
d598 1
a598 1
struct ieee80211_rateset ieee80211_std_rateset_11b =
d601 1
a601 1
struct ieee80211_rateset ieee80211_std_rateset_11g =
d661 1
a661 1
	struct ieee80211_channel *c;
d786 2
a787 1
ieee80211_chan2mode(struct ieee80211com *ic, struct ieee80211_channel *chan)
@


1.21
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.20 2006/12/25 19:24:26 reyk Exp $	*/
d75 2
a76 1
static void ieee80211_setbasicrates(struct ieee80211com *);
d353 3
a355 2
static int
findrate(struct ieee80211com *ic, enum ieee80211_phymode mode, int rate)
d439 1
a439 1
				i = findrate(ic, j, newrate);
d447 1
a447 1
			i = findrate(ic, newphymode, newrate);
d611 1
a611 1
static void
@


1.20
log
@print the phy mode in IFF_DEBUG status output which helps to debug
dual/multi mode chipset operation.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.19 2006/12/20 08:13:56 grange Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.19
log
@Put all net80211 interfaces into the ``wlan'' interface group. Idea from me,
name ``wlan'' from henning@@.

ok mbalmer@@, reyk@@, henning@@, msf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.18 2006/11/26 11:14:23 deraadt Exp $	*/
a79 11

#if 0
static const char *ieee80211_phymode_name[] = {
	"auto",		/* IEEE80211_MODE_AUTO */
	"11a",		/* IEEE80211_MODE_11A */
	"11b",		/* IEEE80211_MODE_11B */
	"11g",		/* IEEE80211_MODE_11G */
	"FH",		/* IEEE80211_MODE_FH */
	"turbo",	/* IEEE80211_MODE_TURBO */
};
#endif
@


1.18
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.17 2006/06/18 18:39:41 damien Exp $	*/
d167 2
@


1.17
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.16 2006/01/04 06:04:42 canacar Exp $	*/
d605 9
@


1.16
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.15 2005/12/09 03:48:11 jsg Exp $	*/
a35 2
#include <sys/cdefs.h>

a80 2
#define	LOGICALLY_EQUAL(x, y)	(!(x) == !(y))

d528 6
d738 2
a739 20
	/*
	 * Set/reset state flags that influence beacon contents, etc.
	 *
	 * XXX what if we have stations already associated???
	 * XXX probably not right for autoselect?
	 *
	 * Short preamble is not interoperable with legacy .11b
	 * equipment, so it should not be the default for b or
	 * mixed b/g networks. -dcy
	 */
#if 0
	if (ic->ic_caps & IEEE80211_C_SHPREAMBLE)
		ic->ic_flags |= IEEE80211_F_SHPREAMBLE;
#endif
	if (mode == IEEE80211_MODE_11G) {
		if (ic->ic_caps & IEEE80211_C_SHSLOT)
			ic->ic_flags |= IEEE80211_F_SHSLOT;
	} else {
		ic->ic_flags &= ~IEEE80211_F_SHSLOT;
	}
a740 1
	ic->ic_curmode = mode;
@


1.15
log
@/* fall thru... */ -> /* FALLTHROUGH */
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.14 2005/10/07 23:30:02 reyk Exp $	*/
a182 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.14
log
@minor knf
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.13 2005/09/08 13:24:52 reyk Exp $	*/
d897 1
a897 1
		/* fall thru... */
@


1.13
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.12 2005/09/08 12:44:55 jsg Exp $	*/
d111 1
a111 1
	    sizeof(struct ieee80211_frame_addr4)); 
@


1.12
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.11 2005/09/08 09:11:08 jsg Exp $	*/
d76 1
a76 1
int 	ieee80211_cache_size = IEEE80211_CACHE_SIZE;
d182 1
a182 1
        ifmedia_delete_instance(&ic->ic_media, IFM_INST_ANY);
d633 5
a637 3
			for (j = 0; j < basic[mode].rs_nrates; j++)
				if (basic[mode].rs_rates[j] == rs->rs_rates[i]) {
					rs->rs_rates[i] |= IEEE80211_RATE_BASIC;
d640 1
d720 2
a721 2
	if (ic->ic_ibss_chan == NULL ||
	    isclr(ic->ic_chan_active, ieee80211_chan2ieee(ic, ic->ic_ibss_chan))) {
d727 2
a728 3
		if ((ic->ic_ibss_chan == NULL) ||
		    isclr(ic->ic_chan_active,
		       ieee80211_chan2ieee(ic, ic->ic_ibss_chan))) 
d765 1
a765 1
enum ieee80211_phymode 
d839 2
a840 1
ieee80211_rate2media(struct ieee80211com *ic, int rate, enum ieee80211_phymode mode)
@


1.11
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.10 2005/09/08 08:36:12 reyk Exp $	*/
a70 1
#include <net80211/ieee80211_compat.h>
d110 2
a111 2
	BPF_ATTACH(ifp, DLT_IEEE802_11,
	    sizeof(struct ieee80211_frame_addr4), &ic->ic_rawbpf);
d184 1
a184 1
	BPF_DETACH(ifp);
d676 2
a677 1
	IASSERT(mode < N(chanflags), ("Unexpected mode %u", mode));
d724 5
a728 5
		IASSERT(ic->ic_ibss_chan != NULL &&
		    isset(ic->ic_chan_active,
			ieee80211_chan2ieee(ic, ic->ic_ibss_chan)),
		    ("Bad IBSS channel %u\n",
		     ieee80211_chan2ieee(ic, ic->ic_ibss_chan)));
@


1.10
log
@reset the scan state for each new mode

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.9 2005/09/07 05:40:11 jsg Exp $	*/
d130 1
a130 1
				if_printf(ifp, "bad channel ignored; "
d132 2
a133 1
					c->ic_freq, c->ic_flags, i);
d222 1
d228 2
a229 2
		if_printf(&ic->ic_if, "invalid channel freq %u flags %x\n",
			c->ic_freq, c->ic_flags);
d232 1
a232 1
		if_printf(&ic->ic_if, "invalid channel (NULL)\n");
@


1.9
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.8 2005/05/28 12:01:53 reyk Exp $	*/
d651 1
d730 6
d766 8
a773 2
	if (IFM_MODE(ic->ic_media.ifm_cur->ifm_media) != IFM_AUTO)
		return (IEEE80211_MODE_AUTO);	/* Indicate a wrap around */
@


1.8
log
@enable IFCAP_VLAN_MTU because IEEE 802.11 defines a MTU of about 2290.
successfully tested with ural, ath, atw, atu and ath.

ok jsg@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.7 2005/05/25 07:40:49 reyk Exp $	*/
a36 5
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211.c,v 1.11 2004/04/02 20:19:20 sam Exp $");
#elif defined (__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211.c,v 1.19 2004/06/06 05:45:29 dyoung Exp $");
#endif
a41 4
#ifdef __NetBSD__
#include "opt_inet.h"
#endif

a51 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a54 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a58 5
#if defined( __FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a66 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a67 3
#else
#include <net/if_ether.h>
#endif
a74 8
#ifdef __NetBSD__
static int ieee80211_debug_nodenum;
#endif /* __NetBSD__ */

#ifdef __FreeBSD__
SYSCTL_INT(_debug, OID_AUTO, ieee80211, CTLFLAG_RW, &ieee80211_debug,
	    0, "IEEE 802.11 media debugging printfs");
#endif
a77 3
#ifdef __NetBSD__
static int ieee80211_cache_size_nodenum;
#endif
a83 11
#ifdef __NetBSD__
static void sysctl_ieee80211_fill_node(struct ieee80211_node *,
    struct ieee80211_node_sysctl *, int, struct ieee80211_channel *, int);
static struct ieee80211_node *ieee80211_node_walknext(
    struct ieee80211_node_walk *);
static struct ieee80211_node *ieee80211_node_walkfirst(
    struct ieee80211_node_walk *, u_short);
static int sysctl_ieee80211_verify(SYSCTLFN_ARGS);
static int sysctl_ieee80211_node(SYSCTLFN_ARGS);
#endif /* __NetBSD__ */

a103 1
#if defined(__OpenBSD__)
a106 3
#else
	ether_ifattach(ifp, ic->ic_myaddr);
#endif
a181 3
#ifdef __FreeBSD__
	ifmedia_removeall(&ic->ic_media);
#else
a182 1
#endif
a926 313

#ifdef __NetBSD__
static void
ieee80211_clean_all_nodes(int cache_size)
{
	struct ieee80211com *ic;
	LIST_FOREACH(ic, &ieee80211com_head, ic_list) {
		ic->ic_max_nnodes = cache_size;
		ieee80211_clean_nodes(ic);
	}
}

/* TBD factor with sysctl_ath_verify. */
static int
sysctl_ieee80211_verify(SYSCTLFN_ARGS)
{
	int error, t;
	struct sysctlnode node;

	node = *rnode;
	t = *(int*)rnode->sysctl_data;
	node.sysctl_data = &t;
	error = sysctl_lookup(SYSCTLFN_CALL(&node));
	if (error || newp == NULL)
		return (error);

	if (node.sysctl_num == ieee80211_cache_size_nodenum) {
		if (t < 0)
			return (EINVAL);
#ifdef IEEE80211_DEBUG
	} else if (node.sysctl_num != ieee80211_debug_nodenum)
#else /* IEEE80211_DEBUG */
	} else
#endif /* IEEE80211_DEBUG */
		return (EINVAL);

	*(int*)rnode->sysctl_data = t;

	return (0);
}

/*
 * Pointers for testing:
 *
 *	If there are no interfaces, or else no 802.11 interfaces,
 *	ieee80211_node_walkfirst must return NULL.
 *
 *	If there is any single 802.11 interface, ieee80211_node_walkfirst
 *	must not return NULL.
 */	
static struct ieee80211_node *
ieee80211_node_walkfirst(struct ieee80211_node_walk *nw,
    u_short if_index)
{
	struct ieee80211com *ic;
	(void)memset(nw, 0, sizeof(*nw));

	nw->nw_ifindex = if_index;

	LIST_FOREACH(ic, &ieee80211com_head, ic_list) {
		if (if_index != 0 && ic->ic_if.if_index != if_index)
			continue;
		nw->nw_ic = ic;
		nw->nw_ni = ic->ic_bss;
		break;
	}

	KASSERT(LOGICALLY_EQUAL(nw->nw_ni == NULL, nw->nw_ic == NULL));

	return nw->nw_ni;
}

static struct ieee80211_node *
ieee80211_node_walknext(struct ieee80211_node_walk *nw)
{
	KASSERT(LOGICALLY_EQUAL(nw->nw_ni == NULL, nw->nw_ic == NULL));

	if (nw->nw_ic == NULL && nw->nw_ni == NULL)
		return NULL;

	if (nw->nw_ni == nw->nw_ic->ic_bss)
		nw->nw_ni = TAILQ_FIRST(&nw->nw_ic->ic_node);
	else
		nw->nw_ni = TAILQ_NEXT(nw->nw_ni, ni_list);

	if (nw->nw_ni == NULL) {
		if (nw->nw_ifindex != 0)
			return NULL;

		nw->nw_ic = LIST_NEXT(nw->nw_ic, ic_list);
		if (nw->nw_ic == NULL)
			return NULL;

		nw->nw_ni = nw->nw_ic->ic_bss;
	}

	KASSERT(LOGICALLY_EQUAL(nw->nw_ni == NULL, nw->nw_ic == NULL));

	return nw->nw_ni;
}

static void
sysctl_ieee80211_fill_node(struct ieee80211_node *ni,
    struct ieee80211_node_sysctl *ns, int ifindex,
    struct ieee80211_channel *chan0, int is_bss)
{
	ns->ns_ifindex = ifindex;
	ns->ns_capinfo = ni->ni_capinfo;
	ns->ns_flags = (is_bss) ? IEEE80211_NODE_SYSCTL_F_BSS : 0;
	(void)memcpy(ns->ns_macaddr, ni->ni_macaddr, sizeof(ns->ns_macaddr));
	(void)memcpy(ns->ns_bssid, ni->ni_bssid, sizeof(ns->ns_bssid));
	if (ni->ni_chan != IEEE80211_CHAN_ANYC) {
		ns->ns_freq = ni->ni_chan->ic_freq;
		ns->ns_chanflags = ni->ni_chan->ic_flags;
		ns->ns_chanidx = ni->ni_chan - chan0;
	} else {
		ns->ns_freq = ns->ns_chanflags = 0;
		ns->ns_chanidx = 0;
	}
	ns->ns_rssi = ni->ni_rssi;
	ns->ns_esslen = ni->ni_esslen;
	(void)memcpy(ns->ns_essid, ni->ni_essid, sizeof(ns->ns_essid));
	ns->ns_pwrsave = ni->ni_pwrsave;
	ns->ns_erp = ni->ni_erp;
	ns->ns_associd = ni->ni_associd;
	ns->ns_inact = ni->ni_inact * IEEE80211_INACT_WAIT;
	ns->ns_rstamp = ni->ni_rstamp;
	ns->ns_rates = ni->ni_rates;
	ns->ns_txrate = ni->ni_txrate;
	ns->ns_intval = ni->ni_intval;
	(void)memcpy(ns->ns_tstamp, ni->ni_tstamp, sizeof(ns->ns_tstamp));
	ns->ns_txseq = ni->ni_txseq;
	ns->ns_rxseq = ni->ni_rxseq;
	ns->ns_fhdwell = ni->ni_fhdwell;
	ns->ns_fhindex = ni->ni_fhindex;
	ns->ns_fails = ni->ni_fails;
}

/* Between two examinations of the sysctl tree, I expect each
 * interface to add no more than 5 nodes.
 */
#define IEEE80211_SYSCTL_NODE_GROWTH	5

static int
sysctl_ieee80211_node(SYSCTLFN_ARGS)
{
	struct ieee80211_node_walk nw;
	struct ieee80211_node *ni;
	struct ieee80211_node_sysctl ns;
	char *dp;
	u_int cur_ifindex, ifcount, ifindex, last_ifindex, op, arg, hdr_type;
	size_t len, needed, eltsize, out_size;
	int error, s, nelt;

	if (namelen == 1 && name[0] == CTL_QUERY)
		return (sysctl_query(SYSCTLFN_CALL(rnode)));

	if (namelen != IEEE80211_SYSCTL_NODENAMELEN)
		return (EINVAL);

	/* ifindex.op.arg.header-type.eltsize.nelt */
	dp = oldp;
	len = (oldp != NULL) ? *oldlenp : 0;
	ifindex = name[IEEE80211_SYSCTL_NODENAME_IF];
	op = name[IEEE80211_SYSCTL_NODENAME_OP];
	arg = name[IEEE80211_SYSCTL_NODENAME_ARG];
	hdr_type = name[IEEE80211_SYSCTL_NODENAME_TYPE];
	eltsize = name[IEEE80211_SYSCTL_NODENAME_ELTSIZE];
	nelt = name[IEEE80211_SYSCTL_NODENAME_ELTCOUNT];
	out_size = MIN(sizeof(ns), eltsize);

	if (op != IEEE80211_SYSCTL_OP_ALL || arg != 0 ||
	    hdr_type != IEEE80211_SYSCTL_T_NODE || eltsize < 1 || nelt < 0)
		return (EINVAL);

	error = 0;
	needed = 0;
	ifcount = 0;
	last_ifindex = 0;

	s = splnet();

	for (ni = ieee80211_node_walkfirst(&nw, ifindex); ni != NULL;
	     ni = ieee80211_node_walknext(&nw)) {
		struct ieee80211com *ic;

		ic = nw.nw_ic;
		cur_ifindex = ic->ic_if.if_index;

		if (cur_ifindex != last_ifindex) {
			ifcount++;
			last_ifindex = cur_ifindex;
		}

		if (nelt <= 0)
			continue;

		if (len >= eltsize) {
			sysctl_ieee80211_fill_node(ni, &ns, cur_ifindex,
			    &ic->ic_channels[0], ni == ic->ic_bss);
			error = copyout(&ns, dp, out_size);
			if (error)
				goto cleanup;
			dp += eltsize;
			len -= eltsize;
		}
		needed += eltsize;
		if (nelt != INT_MAX)
			nelt--;
	}
cleanup:
	splx(s);

	*oldlenp = needed;
	if (oldp == NULL)
		*oldlenp += ifcount * IEEE80211_SYSCTL_NODE_GROWTH * eltsize;

	return (error);
}

/*
 * Setup sysctl(3) MIB, net.ieee80211.*
 *
 * TBD condition CTLFLAG_PERMANENT on being an LKM or not
 */
SYSCTL_SETUP(sysctl_ieee80211, "sysctl ieee80211 subtree setup")
{
	int rc;
	struct sysctlnode *cnode, *rnode;

	if ((rc = sysctl_createv(clog, 0, NULL, &rnode,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "net", NULL,
	    NULL, 0, NULL, 0, CTL_NET, CTL_EOL)) != 0)
		goto err;

	if ((rc = sysctl_createv(clog, 0, &rnode, &rnode,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "link",
	    "link-layer statistics and controls",
	    NULL, 0, NULL, 0, PF_LINK, CTL_EOL)) != 0)
		goto err;

	if ((rc = sysctl_createv(clog, 0, &rnode, &rnode,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "ieee80211",
	    "IEEE 802.11 WLAN statistics and controls",
	    NULL, 0, NULL, 0, CTL_CREATE, CTL_EOL)) != 0)
		goto err;

	if ((rc = sysctl_createv(clog, 0, &rnode, NULL,
	    CTLFLAG_PERMANENT, CTLTYPE_NODE, "nodes", "client/peer stations",
	    sysctl_ieee80211_node, 0, NULL, 0, CTL_CREATE, CTL_EOL)) != 0)
		goto err;

#ifdef IEEE80211_DEBUG

	/* control debugging printfs */
	if ((rc = sysctl_createv(clog, 0, &rnode, &cnode,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE, CTLTYPE_INT,
	    "debug", SYSCTL_DESCR("Enable IEEE 802.11 debugging output"),
	    sysctl_ieee80211_verify, 0, &ieee80211_debug, 0,
	    CTL_CREATE, CTL_EOL)) != 0)
		goto err;

	ieee80211_debug_nodenum = cnode->sysctl_num;

#endif /* IEEE80211_DEBUG */

	/* control LRU cache size */
	if ((rc = sysctl_createv(clog, 0, &rnode, &cnode,
	    CTLFLAG_PERMANENT|CTLFLAG_READWRITE, CTLTYPE_INT,
	    "maxnodecache", SYSCTL_DESCR("Maximum station cache size"),
	    sysctl_ieee80211_verify, 0, &ieee80211_cache_size,
	    0, CTL_CREATE, CTL_EOL)) != 0)
		goto err;

	ieee80211_cache_size_nodenum = cnode->sysctl_num;

	return;
err:
	printf("%s: sysctl_createv failed (rc = %d)\n", __func__, rc);
}
#endif /* __NetBSD__ */

#ifdef __FreeBSD__
/*
 * Module glue.
 *
 * NB: the module name is "wlan" for compatibility with NetBSD.
 */

static int
ieee80211_modevent(module_t mod, int type, void *unused)
{
	switch (type) {
	case MOD_LOAD:
		if (bootverbose)
			printf("wlan: <802.11 Link Layer>\n");
		return 0;
	case MOD_UNLOAD:
		return 0;
	}
	return EINVAL;
}

static moduledata_t ieee80211_mod = {
	"wlan",
	ieee80211_modevent,
	0
};
DECLARE_MODULE(wlan, ieee80211_mod, SI_SUB_DRIVERS, SI_ORDER_FIRST);
MODULE_VERSION(wlan, 1);
MODULE_DEPEND(wlan, rc4, 1, 1, 1);
MODULE_DEPEND(wlan, ether, 1, 1, 1);
#endif
@


1.7
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.6 2005/04/21 22:47:15 reyk Exp $	*/
d208 3
@


1.6
log
@scan the next mode if nothing has been found. this is necessary if the
device supports different incompatible modes in the same channel
range, like like 11b and "pure" 11G mode.

ok dlg@@ pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.5 2005/04/20 19:52:43 reyk Exp $	*/
d207 1
d806 1
a806 1
void
d812 1
a812 1
		return;
d831 2
@


1.5
log
@send raw 802.11 frames with bpf(4) using the IEEE802_11 or
IEEE802_11_RADIO data link types.

ok canacar@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.4 2005/02/17 18:28:05 reyk Exp $	*/
d803 27
@


1.4
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.3 2004/11/03 20:42:41 claudio Exp $	*/
d158 3
@


1.3
log
@Use IFM_IEEE80211_IBSS for IBSS mode instead of IFM_IEEE80211_ADHOC.
With this ipw(4) works in IBSS mode.
ok millert@@ aaron@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.2 2004/11/02 02:15:49 reyk Exp $	*/
d110 1
a110 1
int	ieee80211_inact_max = IEEE80211_INACT_MAX;
d112 1
a112 1
static int ieee80211_inact_max_nodenum;
d115 3
d120 13
d212 1
d225 1
a415 3
	if (ic->ic_max_aid == 0)
		ic->ic_max_aid = IEEE80211_MAX_AID;

a648 2
	if (ic->ic_inact_timer && --ic->ic_inact_timer == 0)
		ieee80211_timeout_nodes(ic);
d650 1
a650 1
	if (ic->ic_mgt_timer != 0 || ic->ic_inact_timer != 0)
d781 4
d786 1
d789 1
d948 10
d972 2
a973 5
	IEEE80211_DPRINTF(("%s: t = %d, nodenum = %d, rnodenum = %d\n",
	    __func__, t, node.sysctl_num, rnode->sysctl_num));

	if (node.sysctl_num == ieee80211_inact_max_nodenum) {
		if (t < 1)
a974 1
		t = roundup(t, IEEE80211_INACT_WAIT) / IEEE80211_INACT_WAIT;
d976 3
a978 3
	} else if (node.sysctl_num == ieee80211_debug_nodenum) {
		if (t < 0 || t > 2)
			return (EINVAL);
a979 1
	} else
d988 179
d1193 5
d1212 1
a1212 1
	/* control inactivity timer */
d1215 2
a1216 2
	    "maxinact", SYSCTL_DESCR("Station inactivity timeout"),
	    sysctl_ieee80211_verify, 0, &ieee80211_inact_max,
d1220 1
a1220 1
	ieee80211_inact_max_nodenum = cnode->sysctl_num;
@


1.2
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211.c,v 1.1 2004/06/22 22:53:51 millert Exp $	*/
d335 1
a335 1
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_ADHOC);
d339 1
a339 1
			ADD(ic, IFM_AUTO, mopt | IFM_IEEE80211_ADHOC | IFM_FLAG0);
d352 1
a352 1
				ADD(ic, mword, mopt | IFM_IEEE80211_ADHOC);
d356 1
a356 1
				ADD(ic, mword, mopt | IFM_IEEE80211_ADHOC | IFM_FLAG0);
d384 1
a384 1
			ADD(ic, mword, IFM_IEEE80211_ADHOC);
d388 1
a388 1
			ADD(ic, mword, IFM_IEEE80211_ADHOC | IFM_FLAG0);
d507 1
a507 2
	if ((ime->ifm_media & (IFM_IEEE80211_ADHOC|IFM_FLAG0)) ==
	    (IFM_IEEE80211_ADHOC|IFM_FLAG0))
d511 1
a511 1
	else if (ime->ifm_media & IFM_IEEE80211_ADHOC)
d595 1
a595 1
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
d598 1
a598 1
		/* should not come here */
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d115 1
a115 2
static void ieee80211_set11gbasicrates(struct ieee80211_rateset *,
		enum ieee80211_phymode);
d189 1
a565 6
#ifdef notdef
			if (ic->ic_curmode == IEEE80211_MODE_11G)
				ieee80211_set11gbasicrates(
					&ic->ic_sup_rates[newphymode],
					IEEE80211_MODE_11B);
#endif
d650 1
a650 1
ieee80211_set11gbasicrates(struct ieee80211_rateset *rs, enum ieee80211_phymode mode)
d653 1
d655 3
a657 3
	    { 4, { 2, 4, 11, 22 } },		/* IEEE80211_MODE_11B */
	    { 7, { 2, 4, 11, 22, 12, 24, 48 } },/* IEEE80211_MODE_11G */
	    { 0 },				/* IEEE80211_MODE_FH */
d660 2
d664 10
a673 7
	for (i = 0; i < rs->rs_nrates; i++) {
		rs->rs_rates[i] &= IEEE80211_RATE_VAL;
		for (j = 0; j < basic[mode].rs_nrates; j++)
			if (basic[mode].rs_rates[j] == rs->rs_rates[i]) {
				rs->rs_rates[i] |= IEEE80211_RATE_BASIC;
				break;
			}
a774 2
		ieee80211_set11gbasicrates(&ic->ic_sup_rates[mode],
			IEEE80211_MODE_11G);
d806 3
a808 1
	if (IEEE80211_IS_CHAN_5GHZ(chan))
@

