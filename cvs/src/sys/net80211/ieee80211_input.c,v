head	1.196;
access;
symbols
	OPENBSD_6_1:1.189.0.4
	OPENBSD_6_1_BASE:1.189
	OPENBSD_6_0:1.178.0.2
	OPENBSD_6_0_BASE:1.178
	OPENBSD_5_9:1.168.0.2
	OPENBSD_5_9_BASE:1.168
	OPENBSD_5_8:1.137.0.4
	OPENBSD_5_8_BASE:1.137
	OPENBSD_5_7:1.132.0.2
	OPENBSD_5_7_BASE:1.132
	OPENBSD_5_6:1.126.0.4
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.123.0.6
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.123.0.2
	OPENBSD_5_4_BASE:1.123
	OPENBSD_5_3:1.122.0.2
	OPENBSD_5_3_BASE:1.122
	OPENBSD_5_2:1.121.0.2
	OPENBSD_5_2_BASE:1.121
	OPENBSD_5_1_BASE:1.119
	OPENBSD_5_1:1.119.0.4
	OPENBSD_5_0:1.119.0.2
	OPENBSD_5_0_BASE:1.119
	OPENBSD_4_9:1.117.0.2
	OPENBSD_4_9_BASE:1.117
	OPENBSD_4_8:1.116.0.2
	OPENBSD_4_8_BASE:1.116
	OPENBSD_4_7:1.113.0.2
	OPENBSD_4_7_BASE:1.113
	OPENBSD_4_6:1.111.0.4
	OPENBSD_4_6_BASE:1.111
	OPENBSD_4_5:1.109.0.2
	OPENBSD_4_5_BASE:1.109
	OPENBSD_4_4:1.89.0.2
	OPENBSD_4_4_BASE:1.89
	OPENBSD_4_3:1.72.0.2
	OPENBSD_4_3_BASE:1.72
	OPENBSD_4_2:1.63.0.2
	OPENBSD_4_2_BASE:1.63
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.6.0.2
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.196
date	2017.09.04.09.11.46;	author stsp;	state Exp;
branches;
next	1.195;
commitid	Z0g41xr6U3J7KsQI;

1.195
date	2017.08.04.17.31.05;	author stsp;	state Exp;
branches;
next	1.194;
commitid	Hbga0KyTegllV1bF;

1.194
date	2017.06.04.12.48.42;	author tb;	state Exp;
branches;
next	1.193;
commitid	TmCEidI2en4vCuLK;

1.193
date	2017.06.03.15.44.03;	author tb;	state Exp;
branches;
next	1.192;
commitid	Fy9gzTb9KEKQjy5d;

1.192
date	2017.05.02.11.03.48;	author stsp;	state Exp;
branches;
next	1.191;
commitid	AjCsoeHFrGqcMwYv;

1.191
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.190;
commitid	zztPc3QpQPdWwQ6h;

1.190
date	2017.04.09.18.15.32;	author dhill;	state Exp;
branches;
next	1.189;
commitid	5UczsZXp16hq8Bis;

1.189
date	2017.03.13.07.44.10;	author stsp;	state Exp;
branches;
next	1.188;
commitid	8zS4E5lABrkExtNm;

1.188
date	2017.03.12.03.13.50;	author stsp;	state Exp;
branches;
next	1.187;
commitid	iIk6bEDpMYi2n0yI;

1.187
date	2017.03.01.19.28.48;	author stsp;	state Exp;
branches;
next	1.186;
commitid	ziqUM3IRerOy1q1r;

1.186
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.185;
commitid	PETPfbQ5ZWdJqIYS;

1.185
date	2017.01.25.09.23.08;	author stsp;	state Exp;
branches;
next	1.184;
commitid	4ZjwqIiysiXJB94K;

1.184
date	2017.01.16.09.35.06;	author stsp;	state Exp;
branches;
next	1.183;
commitid	wxfLLSkIsWFlDf1U;

1.183
date	2017.01.10.08.19.49;	author stsp;	state Exp;
branches;
next	1.182;
commitid	8SP1NIHY6ThHyLNj;

1.182
date	2017.01.09.20.18.59;	author stsp;	state Exp;
branches;
next	1.181;
commitid	cqn8VXxfpVIojpbn;

1.181
date	2017.01.09.12.40.00;	author stsp;	state Exp;
branches;
next	1.180;
commitid	G3vWsV1lhNxxnROO;

1.180
date	2016.09.21.12.21.27;	author stsp;	state Exp;
branches;
next	1.179;
commitid	ExqBSY6QNe8gxCt8;

1.179
date	2016.09.20.13.24.42;	author stsp;	state Exp;
branches;
next	1.178;
commitid	5T5FK9pNEKxdvb99;

1.178
date	2016.05.18.08.15.28;	author stsp;	state Exp;
branches
	1.178.2.1;
next	1.177;
commitid	h4943tbngzO3CJ4g;

1.177
date	2016.05.10.06.37.15;	author dlg;	state Exp;
branches;
next	1.176;
commitid	SOBlB2bxzuD6MSBb;

1.176
date	2016.05.02.09.35.49;	author tb;	state Exp;
branches;
next	1.175;
commitid	naam8oiW3BVVAYm3;

1.175
date	2016.05.02.08.12.42;	author stsp;	state Exp;
branches;
next	1.174;
commitid	qeX61hmO9C5TFHFZ;

1.174
date	2016.04.28.15.00.27;	author stsp;	state Exp;
branches;
next	1.173;
commitid	A5pKebtCJTCmiceN;

1.173
date	2016.04.28.13.58.00;	author stsp;	state Exp;
branches;
next	1.172;
commitid	f6nIIyDltuYmUgy2;

1.172
date	2016.04.27.11.58.10;	author stsp;	state Exp;
branches;
next	1.171;
commitid	2WbLmzkj7ZM3hH4a;

1.171
date	2016.04.15.03.04.27;	author dlg;	state Exp;
branches;
next	1.170;
commitid	lI7V09eB1vBPRxZq;

1.170
date	2016.04.12.14.33.27;	author mpi;	state Exp;
branches;
next	1.169;
commitid	0LA0xiKsLRo4rVjB;

1.169
date	2016.03.22.11.37.35;	author dlg;	state Exp;
branches;
next	1.168;
commitid	UysJPrtvT8DzdEPs;

1.168
date	2016.02.12.10.12.42;	author stsp;	state Exp;
branches
	1.168.2.1;
next	1.167;
commitid	dfBskBcDMEFCyqlF;

1.167
date	2016.02.11.19.36.48;	author stsp;	state Exp;
branches;
next	1.166;
commitid	4T0ToRqQiBjEsdQJ;

1.166
date	2016.02.11.17.14.29;	author stsp;	state Exp;
branches;
next	1.165;
commitid	GcijoorN50aznJJW;

1.165
date	2016.02.11.17.06.01;	author stsp;	state Exp;
branches;
next	1.164;
commitid	JdnqcaCSXmAw8r8Y;

1.164
date	2016.02.11.16.43.40;	author stsp;	state Exp;
branches;
next	1.163;
commitid	LS8j2Fs1noJkBSNd;

1.163
date	2016.02.11.16.25.15;	author stsp;	state Exp;
branches;
next	1.162;
commitid	Zj4feSKmc1tA1EKV;

1.162
date	2016.02.09.13.48.31;	author stsp;	state Exp;
branches;
next	1.161;
commitid	JHUQtNY8ItWJ0Xzw;

1.161
date	2016.02.08.01.00.47;	author stsp;	state Exp;
branches;
next	1.160;
commitid	t6UAoTbJMjqNPVER;

1.160
date	2016.02.08.00.54.57;	author stsp;	state Exp;
branches;
next	1.159;
commitid	3JZeHvAofgIJAyva;

1.159
date	2016.02.07.23.36.43;	author stsp;	state Exp;
branches;
next	1.158;
commitid	fPzte7eZqxVpIuAi;

1.158
date	2016.02.05.19.42.04;	author stsp;	state Exp;
branches;
next	1.157;
commitid	ptr47nK2fwXP9F6f;

1.157
date	2016.02.05.16.07.57;	author stsp;	state Exp;
branches;
next	1.156;
commitid	xkYUdKYZXQrBH3Sl;

1.156
date	2016.02.04.16.23.40;	author stsp;	state Exp;
branches;
next	1.155;
commitid	CoUDEKOEoQ2LZ3mp;

1.155
date	2016.02.01.18.43.22;	author stsp;	state Exp;
branches;
next	1.154;
commitid	4NOoNc6ASRY2FA63;

1.154
date	2016.01.25.15.14.22;	author stsp;	state Exp;
branches;
next	1.153;
commitid	9rrpvMUbRKud5zGd;

1.153
date	2016.01.25.15.10.37;	author stsp;	state Exp;
branches;
next	1.152;
commitid	hMc0oSgmsLkJIc3U;

1.152
date	2016.01.25.11.27.11;	author stsp;	state Exp;
branches;
next	1.151;
commitid	U9Unyh02TU5iq9jc;

1.151
date	2016.01.07.23.22.31;	author stsp;	state Exp;
branches;
next	1.150;
commitid	fZfOIgRYw9oUaCc3;

1.150
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.149;
commitid	2QagMjdMhQhIaQgu;

1.149
date	2016.01.04.13.29.31;	author stsp;	state Exp;
branches;
next	1.148;
commitid	8C0m2OLtWbHCkBZE;

1.148
date	2016.01.04.12.32.06;	author stsp;	state Exp;
branches;
next	1.147;
commitid	4X5pVUcDTAvM2jfa;

1.147
date	2016.01.04.12.25.46;	author stsp;	state Exp;
branches;
next	1.146;
commitid	qxghNKrIQP4oLgDx;

1.146
date	2016.01.04.12.25.00;	author stsp;	state Exp;
branches;
next	1.145;
commitid	di0zXRfXIFBF1XlJ;

1.145
date	2015.12.12.13.56.10;	author stsp;	state Exp;
branches;
next	1.144;
commitid	mzJ9C1npolpZzz6c;

1.144
date	2015.12.12.12.22.14;	author stsp;	state Exp;
branches;
next	1.143;
commitid	eIdOEcarSAEaWJ10;

1.143
date	2015.12.12.11.25.46;	author stsp;	state Exp;
branches;
next	1.142;
commitid	yJtuIKjLQDddhkbQ;

1.142
date	2015.11.15.11.14.17;	author stsp;	state Exp;
branches;
next	1.141;
commitid	fROBylLWPLvwXRar;

1.141
date	2015.11.15.10.07.03;	author stsp;	state Exp;
branches;
next	1.140;
commitid	Nt1Hw5JFHrcEBdto;

1.140
date	2015.11.08.18.51.47;	author stsp;	state Exp;
branches;
next	1.139;
commitid	Rm2b1244EZ2IbV0Y;

1.139
date	2015.11.08.18.48.07;	author stsp;	state Exp;
branches;
next	1.138;
commitid	AsYxGnv8IL7VhokH;

1.138
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.137;
commitid	YT6fyIEviv9qwbl6;

1.137
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches
	1.137.4.1;
next	1.136;
commitid	ncpqEGjDtSFuLAgn;

1.136
date	2015.06.30.13.54.42;	author mpi;	state Exp;
branches;
next	1.135;
commitid	fE8TgA9vpwdUU5Wy;

1.135
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.134;
commitid	MVWrtktB46JRxFWT;

1.134
date	2015.05.26.15.34.00;	author mpi;	state Exp;
branches;
next	1.133;
commitid	Eqi0E8Lq2fFITtoM;

1.133
date	2015.03.14.03.38.51;	author jsg;	state Exp;
branches;
next	1.132;
commitid	p4LJxGKbi0BU2cG6;

1.132
date	2015.02.09.03.09.57;	author dlg;	state Exp;
branches
	1.132.2.1;
next	1.131;
commitid	fE9MPAUoNdw8sZYO;

1.131
date	2015.02.08.06.03.07;	author mpi;	state Exp;
branches;
next	1.130;
commitid	CSlT28puBPpnoc0D;

1.130
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.129;
commitid	MyKPm9Q3dQu92BiX;

1.129
date	2015.01.13.23.16.59;	author stsp;	state Exp;
branches;
next	1.128;
commitid	crX6wctRAUzHeD1b;

1.128
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.127;
commitid	PYnSnAqgemmk34E3;

1.127
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.126;
commitid	uzzBR7hz9ncd4O6G;

1.126
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.125;
commitid	B4dZSbxas1X1IpXI;

1.125
date	2014.07.11.08.19.40;	author blambert;	state Exp;
branches;
next	1.124;
commitid	NEBqb4BFPxFuLkjg;

1.124
date	2014.07.10.14.32.28;	author stsp;	state Exp;
branches;
next	1.123;
commitid	l6yVFVZyUhUAysk2;

1.123
date	2013.06.11.18.15.53;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2012.10.12.19.53.24;	author haesbaert;	state Exp;
branches;
next	1.121;

1.121
date	2012.07.16.14.51.31;	author stsp;	state Exp;
branches;
next	1.120;

1.120
date	2012.07.13.11.25.04;	author stsp;	state Exp;
branches;
next	1.119;

1.119
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.04.23.48.15;	author fgsch;	state Exp;
branches;
next	1.117;

1.117
date	2011.02.21.20.00.12;	author stsp;	state Exp;
branches;
next	1.116;

1.116
date	2010.06.07.16.51.22;	author damien;	state Exp;
branches;
next	1.115;

1.115
date	2010.06.07.16.46.17;	author damien;	state Exp;
branches;
next	1.114;

1.114
date	2010.06.05.13.13.43;	author damien;	state Exp;
branches;
next	1.113;

1.113
date	2010.02.25.17.49.16;	author damien;	state Exp;
branches;
next	1.112;

1.112
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.111;

1.111
date	2009.03.26.20.34.54;	author damien;	state Exp;
branches;
next	1.110;

1.110
date	2009.03.06.18.35.02;	author damien;	state Exp;
branches;
next	1.109;

1.109
date	2009.02.08.15.34.39;	author damien;	state Exp;
branches;
next	1.108;

1.108
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.107;

1.107
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.106;

1.106
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.105;

1.105
date	2008.09.27.15.00.08;	author damien;	state Exp;
branches;
next	1.104;

1.104
date	2008.09.01.19.41.10;	author damien;	state Exp;
branches;
next	1.103;

1.103
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.102;

1.102
date	2008.08.28.17.56.24;	author damien;	state Exp;
branches;
next	1.101;

1.101
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.100;

1.100
date	2008.08.14.16.07.58;	author damien;	state Exp;
branches;
next	1.99;

1.99
date	2008.08.14.16.02.23;	author damien;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.13.17.44.45;	author damien;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.12.20.07.13;	author damien;	state Exp;
branches;
next	1.96;

1.96
date	2008.08.12.19.56.59;	author damien;	state Exp;
branches;
next	1.95;

1.95
date	2008.08.12.19.50.39;	author damien;	state Exp;
branches;
next	1.94;

1.94
date	2008.08.12.19.45.22;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2008.08.12.19.42.37;	author damien;	state Exp;
branches;
next	1.92;

1.92
date	2008.08.12.19.29.07;	author damien;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.12.19.21.04;	author damien;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.12.17.53.13;	author damien;	state Exp;
branches;
next	1.89;

1.89
date	2008.08.02.08.35.48;	author damien;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.02.08.20.16;	author damien;	state Exp;
branches;
next	1.87;

1.87
date	2008.07.28.19.42.13;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2008.07.28.10.38.05;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.27.18.24.01;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2008.07.27.14.21.15;	author damien;	state Exp;
branches;
next	1.83;

1.83
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.21.19.05.21;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.06.09.07.07.16;	author djm;	state Exp;
branches;
next	1.79;

1.79
date	2008.04.26.19.57.49;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.21.20.16.34;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2008.04.21.19.37.18;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2008.04.21.19.27.13;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.04.21.19.01.01;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.04.21.16.14.25;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2007.10.29.15.40.23;	author chl;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.18.22.02.18;	author djm;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.29.19.54.46;	author damien;	state Exp;
branches;
next	1.69;

1.69
date	2007.08.27.20.14.21;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2007.08.27.18.53.27;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2007.08.23.18.44.00;	author damien;	state Exp;
branches;
next	1.66;

1.66
date	2007.08.23.16.59.32;	author damien;	state Exp;
branches;
next	1.65;

1.65
date	2007.08.23.16.53.51;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2007.08.22.20.40.34;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2007.08.16.14.59.14;	author deraadt;	state Exp;
branches;
next	1.62;

1.62
date	2007.08.14.20.33.47;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2007.08.03.20.18.42;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2007.08.03.16.51.06;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2007.08.01.18.14.00;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.01.16.23.48;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2007.08.01.16.16.09;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.01.15.40.40;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.01.15.22.12;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.01.13.25.19;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.01.12.59.33;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.01.12.47.55;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.01.12.43.58;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.01.12.32.26;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.01.12.26.16;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.01.12.23.26;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.01.12.02.50;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.01.11.59.40;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.28.11.24.06;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.14.19.58.05;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.13.19.56.03;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.13.19.32.53;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2007.07.13.19.26.09;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2007.07.13.19.09.23;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2007.07.06.19.33.58;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2007.07.06.18.18.43;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2007.07.06.17.58.04;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.04.20.19.12;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.03.20.25.32;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.03.17.04.13;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.02.20.21.46;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.02.16.29.26;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.21.20.11.16;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.21.19.48.48;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.21.18.20.18;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.21.16.15.29;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.16.18.36.01;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.16.11.59.58;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.16.11.56.20;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.25.19.24.26;	author reyk;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.29.18.10.34;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.29.18.02.41;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.29.11.31.47;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.18.18.55.27;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.25.22.41.48;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.11.00.18.17;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.02.08.05.36;	author reyk;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.03.20.00.18;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.08.13.24.52;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.09.08.09.11.08;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.07.02.50.47;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.08.18.09.20;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.06.11.15.14;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;

1.132.2.1
date	2015.11.09.18.48.34;	author stsp;	state Exp;
branches;
next	;
commitid	iJWmBM1XLa2KstK2;

1.137.4.1
date	2015.11.09.18.48.11;	author stsp;	state Exp;
branches;
next	;
commitid	YotnYXtkWKL0Cekg;

1.168.2.1
date	2017.03.01.20.57.29;	author benno;	state Exp;
branches;
next	;
commitid	Yy9A53bTb4WnX3us;

1.178.2.1
date	2017.03.01.20.57.50;	author benno;	state Exp;
branches;
next	;
commitid	ChXblF78aIW5HGQF;


desc
@@


1.196
log
@If a beacon is received in RUN state, reset the management timer.

Some wifi drivers send a probe request if the hardware reports "missed beacon"
events. If the AP replies with a probe response it is still servicing us and
there is no need to search for a new AP. However, the management timer was not
reset if a beacon was received while in RUN state. So the interface watchdog
always ended up putting the driver into SCAN state after a missed beacon event,
even if the AP did respond to our probe request. Under some conditions this
bug would cause spurious disconnects.

Problem reported and fix tested by mlarkin@@

(Using the management timer in RUN state is a new convention. Before support
for missed beacons was added, this timer was only used during the association
sequence to handle APs which don't respond to our assoc requests and such.)
@
text
@/*	$OpenBSD: ieee80211_input.c,v 1.195 2017/08/04 17:31:05 stsp Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * Copyright (c) 2007-2009 Damien Bergamini
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/endian.h>
#include <sys/errno.h>
#include <sys/sysctl.h>
#include <sys/task.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_llc.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_priv.h>

struct	mbuf *ieee80211_defrag(struct ieee80211com *, struct mbuf *, int);
void	ieee80211_defrag_timeout(void *);
void	ieee80211_input_ba(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int, struct ieee80211_rxinfo *);
void	ieee80211_input_ba_flush(struct ieee80211com *, struct ieee80211_node *,
	    struct ieee80211_rx_ba *);
void	ieee80211_input_ba_gap_timeout(void *arg);
void	ieee80211_ba_move_window(struct ieee80211com *,
	    struct ieee80211_node *, u_int8_t, u_int16_t);
void	ieee80211_input_ba_seq(struct ieee80211com *,
	    struct ieee80211_node *, uint8_t, uint16_t);
struct	mbuf *ieee80211_align_mbuf(struct mbuf *);
void	ieee80211_decap(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int);
void	ieee80211_amsdu_decap(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int);
void	ieee80211_deliver_data(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int);
int	ieee80211_parse_edca_params_body(struct ieee80211com *,
	    const u_int8_t *);
int	ieee80211_parse_edca_params(struct ieee80211com *, const u_int8_t *);
int	ieee80211_parse_wmm_params(struct ieee80211com *, const u_int8_t *);
enum	ieee80211_cipher ieee80211_parse_rsn_cipher(const u_int8_t[]);
enum	ieee80211_akm ieee80211_parse_rsn_akm(const u_int8_t[]);
int	ieee80211_parse_rsn_body(struct ieee80211com *, const u_int8_t *,
	    u_int, struct ieee80211_rsnparams *);
int	ieee80211_save_ie(const u_int8_t *, u_int8_t **);
void	ieee80211_recv_probe_resp(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *, int);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_probe_req(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *);
#endif
void	ieee80211_recv_auth(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_assoc_req(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *, int);
#endif
void	ieee80211_recv_assoc_resp(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int);
void	ieee80211_recv_deauth(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_recv_disassoc(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_recv_addba_req(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_recv_addba_resp(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_recv_delba(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_recv_sa_query_req(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_sa_query_resp(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
#endif
void	ieee80211_recv_action(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_pspoll(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
#endif
void	ieee80211_recv_bar(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
void	ieee80211_bar_tid(struct ieee80211com *, struct ieee80211_node *,
	    u_int8_t, u_int16_t);

/*
 * Retrieve the length in bytes of an 802.11 header.
 */
u_int
ieee80211_get_hdrlen(const struct ieee80211_frame *wh)
{
	u_int size = sizeof(*wh);

	/* NB: does not work with control frames */
	KASSERT(ieee80211_has_seq(wh));

	if (ieee80211_has_addr4(wh))
		size += IEEE80211_ADDR_LEN;	/* i_addr4 */
	if (ieee80211_has_qos(wh))
		size += sizeof(u_int16_t);	/* i_qos */
	if (ieee80211_has_htc(wh))
		size += sizeof(u_int32_t);	/* i_ht */
	return size;
}

/*
 * Process a received frame.  The node associated with the sender
 * should be supplied.  If nothing was found in the node table then
 * the caller is assumed to supply a reference to ic_bss instead.
 * The RSSI and a timestamp are also supplied.  The RSSI data is used
 * during AP scanning to select a AP to associate with; it can have
 * any units so long as values have consistent units and higher values
 * mean ``better signal''.  The receive timestamp is currently not used
 * by the 802.11 layer.
 */
void
ieee80211_input(struct ifnet *ifp, struct mbuf *m, struct ieee80211_node *ni,
    struct ieee80211_rxinfo *rxi)
{
	struct ieee80211com *ic = (void *)ifp;
	struct ieee80211_frame *wh;
	u_int16_t *orxseq, nrxseq, qos;
	u_int8_t dir, type, subtype, tid;
	int hdrlen, hasqos;

	KASSERT(ni != NULL);

	/* in monitor mode, send everything directly to bpf */
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		goto out;

	/*
	 * Do not process frames without an Address 2 field any further.
	 * Only CTS and ACK control frames do not have this field.
	 */
	if (m->m_len < sizeof(struct ieee80211_frame_min)) {
		DPRINTF(("frame too short, len %u\n", m->m_len));
		ic->ic_stats.is_rx_tooshort++;
		goto out;
	}

	wh = mtod(m, struct ieee80211_frame *);
	if ((wh->i_fc[0] & IEEE80211_FC0_VERSION_MASK) !=
	    IEEE80211_FC0_VERSION_0) {
		DPRINTF(("frame with wrong version: %x\n", wh->i_fc[0]));
		ic->ic_stats.is_rx_badversion++;
		goto err;
	}

	dir = wh->i_fc[1] & IEEE80211_FC1_DIR_MASK;
	type = wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK;
	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	if (type != IEEE80211_FC0_TYPE_CTL) {
		hdrlen = ieee80211_get_hdrlen(wh);
		if (m->m_len < hdrlen) {
			DPRINTF(("frame too short, len %u\n", m->m_len));
			ic->ic_stats.is_rx_tooshort++;
			goto err;
		}
	}
	if ((hasqos = ieee80211_has_qos(wh))) {
		qos = ieee80211_get_qos(wh);
		tid = qos & IEEE80211_QOS_TID;
	} else {
		qos = 0;
		tid = 0;
	}

	if (type == IEEE80211_FC0_TYPE_DATA && hasqos &&
	    (subtype & IEEE80211_FC0_SUBTYPE_NODATA) == 0 &&
	    !(rxi->rxi_flags & IEEE80211_RXI_AMPDU_DONE)) {
		int ba_state = ni->ni_rx_ba[tid].ba_state;

		/* 
		 * If Block Ack was explicitly requested, check
		 * if we have a BA agreement for this RA/TID.
		 */
		if ((qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
		    IEEE80211_QOS_ACK_POLICY_BA &&
		    ba_state != IEEE80211_BA_AGREED) {
			DPRINTF(("no BA agreement for %s, TID %d\n",
			    ether_sprintf(ni->ni_macaddr), tid));
			/* send a DELBA with reason code UNKNOWN-BA */
			IEEE80211_SEND_ACTION(ic, ni,
			    IEEE80211_CATEG_BA, IEEE80211_ACTION_DELBA,
			    IEEE80211_REASON_SETUP_REQUIRED << 16 | tid);
			goto err;
		}

		/* 
		 * Check if we have an explicit or implicit
		 * Block Ack Request for a valid BA agreement.
		 */
		if (ba_state == IEEE80211_BA_AGREED &&
		    ((qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
		    IEEE80211_QOS_ACK_POLICY_BA ||
		    (qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
		    IEEE80211_QOS_ACK_POLICY_NORMAL)) {
			/* go through A-MPDU reordering */
			ieee80211_input_ba(ic, m, ni, tid, rxi);
			return;	/* don't free m! */
		}
	}

	/* duplicate detection (see 9.2.9) */
	if (ieee80211_has_seq(wh) &&
	    ic->ic_state != IEEE80211_S_SCAN) {
		nrxseq = letoh16(*(u_int16_t *)wh->i_seq) >>
		    IEEE80211_SEQ_SEQ_SHIFT;
		if (hasqos)
			orxseq = &ni->ni_qos_rxseqs[tid];
		else
			orxseq = &ni->ni_rxseq;
		if ((wh->i_fc[1] & IEEE80211_FC1_RETRY) &&
		    nrxseq == *orxseq) {
			/* duplicate, silently discarded */
			ic->ic_stats.is_rx_dup++;
			goto out;
		}
		*orxseq = nrxseq;
	}
	if (ic->ic_state != IEEE80211_S_SCAN) {
		ni->ni_rssi = rxi->rxi_rssi;
		ni->ni_rstamp = rxi->rxi_tstamp;
		ni->ni_inact = 0;
	}

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
	    (ic->ic_caps & IEEE80211_C_APPMGT) &&
	    ni->ni_state == IEEE80211_STA_ASSOC) {
		if (wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) {
			if (ni->ni_pwrsave == IEEE80211_PS_AWAKE) {
				/* turn on PS mode */
				ni->ni_pwrsave = IEEE80211_PS_DOZE;
				DPRINTF(("PS mode on for %s\n",
				    ether_sprintf(wh->i_addr2)));
			}
		} else if (ni->ni_pwrsave == IEEE80211_PS_DOZE) {
			struct mbuf *m;

			/* turn off PS mode */
			ni->ni_pwrsave = IEEE80211_PS_AWAKE;
			DPRINTF(("PS mode off for %s\n",
			    ether_sprintf(wh->i_addr2)));

			(*ic->ic_set_tim)(ic, ni->ni_associd, 0);

			/* dequeue buffered unicast frames */
			while ((m = mq_dequeue(&ni->ni_savedq)) != NULL) {
				mq_enqueue(&ic->ic_pwrsaveq, m);
				if_start(ifp);
			}
		}
	}
#endif
	switch (type) {
	case IEEE80211_FC0_TYPE_DATA:
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			if (dir != IEEE80211_FC1_DIR_FROMDS) {
				ic->ic_stats.is_rx_wrongdir++;
				goto out;
			}
			if (ic->ic_state != IEEE80211_S_SCAN &&
			    !IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_bssid)) {
				/* Source address is not our BSS. */
				DPRINTF(("discard frame from SA %s\n",
				    ether_sprintf(wh->i_addr2)));
				ic->ic_stats.is_rx_wrongbss++;
				goto out;
			}
			if ((ifp->if_flags & IFF_SIMPLEX) &&
			    IEEE80211_IS_MULTICAST(wh->i_addr1) &&
			    IEEE80211_ADDR_EQ(wh->i_addr3, ic->ic_myaddr)) {
				/*
				 * In IEEE802.11 network, multicast frame
				 * sent from me is broadcasted from AP.
				 * It should be silently discarded for
				 * SIMPLEX interface.
				 */
				ic->ic_stats.is_rx_mcastecho++;
				goto out;
			}
			break;
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_M_IBSS:
		case IEEE80211_M_AHDEMO:
			if (dir != IEEE80211_FC1_DIR_NODS) {
				ic->ic_stats.is_rx_wrongdir++;
				goto out;
			}
			if (ic->ic_state != IEEE80211_S_SCAN &&
			    !IEEE80211_ADDR_EQ(wh->i_addr3,
				ic->ic_bss->ni_bssid) &&
			    !IEEE80211_ADDR_EQ(wh->i_addr3,
				etherbroadcastaddr)) {
				/* Destination is not our BSS or broadcast. */
				DPRINTF(("discard data frame to DA %s\n",
				    ether_sprintf(wh->i_addr3)));
				ic->ic_stats.is_rx_wrongbss++;
				goto out;
			}
			break;
		case IEEE80211_M_HOSTAP:
			if (dir != IEEE80211_FC1_DIR_TODS) {
				ic->ic_stats.is_rx_wrongdir++;
				goto out;
			}
			if (ic->ic_state != IEEE80211_S_SCAN &&
			    !IEEE80211_ADDR_EQ(wh->i_addr1,
				ic->ic_bss->ni_bssid) &&
			    !IEEE80211_ADDR_EQ(wh->i_addr1,
				etherbroadcastaddr)) {
				/* BSS is not us or broadcast. */
				DPRINTF(("discard data frame to BSS %s\n",
				    ether_sprintf(wh->i_addr1)));
				ic->ic_stats.is_rx_wrongbss++;
				goto out;
			}
			/* check if source STA is associated */
			if (ni == ic->ic_bss) {
				DPRINTF(("data from unknown src %s\n",
				    ether_sprintf(wh->i_addr2)));
				/* NB: caller deals with reference */
				ni = ieee80211_find_node(ic, wh->i_addr2);
				if (ni == NULL)
					ni = ieee80211_dup_bss(ic, wh->i_addr2);
				if (ni != NULL) {
					IEEE80211_SEND_MGMT(ic, ni,
					    IEEE80211_FC0_SUBTYPE_DEAUTH,
					    IEEE80211_REASON_NOT_AUTHED);
				}
				ic->ic_stats.is_rx_notassoc++;
				goto err;
			}
			if (ni->ni_state != IEEE80211_STA_ASSOC) {
				DPRINTF(("data from unassoc src %s\n",
				    ether_sprintf(wh->i_addr2)));
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DISASSOC,
				    IEEE80211_REASON_NOT_ASSOCED);
				ic->ic_stats.is_rx_notassoc++;
				goto err;
			}
			break;
#endif	/* IEEE80211_STA_ONLY */
		default:
			/* can't get there */
			goto out;
		}

		if ((ic->ic_flags & IEEE80211_F_WEPON) ||
		    ((ic->ic_flags & IEEE80211_F_RSNON) &&
		     (ni->ni_flags & IEEE80211_NODE_RXPROT))) {
			/* protection is on for Rx */
			if (!(rxi->rxi_flags & IEEE80211_RXI_HWDEC)) {
				if (!(wh->i_fc[1] & IEEE80211_FC1_PROTECTED)) {
					/* drop unencrypted */
					ic->ic_stats.is_rx_unencrypted++;
					goto err;
				}
				/* do software decryption */
				m = ieee80211_decrypt(ic, m, ni);
				if (m == NULL) {
					ic->ic_stats.is_rx_wepfail++;
					goto err;
				}
				wh = mtod(m, struct ieee80211_frame *);
			}
		} else if ((wh->i_fc[1] & IEEE80211_FC1_PROTECTED) ||
		    (rxi->rxi_flags & IEEE80211_RXI_HWDEC)) {
			/* frame encrypted but protection off for Rx */
			ic->ic_stats.is_rx_nowep++;
			goto out;
		}

#if NBPFILTER > 0
		/* copy to listener after decrypt */
		if (ic->ic_rawbpf)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_IN);
#endif

		if ((ni->ni_flags & IEEE80211_NODE_HT) &&
		    hasqos && (qos & IEEE80211_QOS_AMSDU))
			ieee80211_amsdu_decap(ic, m, ni, hdrlen);
		else
			ieee80211_decap(ic, m, ni, hdrlen);
		return;

	case IEEE80211_FC0_TYPE_MGT:
		if (dir != IEEE80211_FC1_DIR_NODS) {
			ic->ic_stats.is_rx_wrongdir++;
			goto err;
		}
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_AHDEMO) {
			ic->ic_stats.is_rx_ahdemo_mgt++;
			goto out;
		}
#endif
		/* drop frames without interest */
		if (ic->ic_state == IEEE80211_S_SCAN) {
			if (subtype != IEEE80211_FC0_SUBTYPE_BEACON &&
			    subtype != IEEE80211_FC0_SUBTYPE_PROBE_RESP) {
				ic->ic_stats.is_rx_mgtdiscard++;
				goto out;
			}
		}

		if (ni->ni_flags & IEEE80211_NODE_RXMGMTPROT) {
			/* MMPDU protection is on for Rx */
			if (subtype == IEEE80211_FC0_SUBTYPE_DISASSOC ||
			    subtype == IEEE80211_FC0_SUBTYPE_DEAUTH ||
			    subtype == IEEE80211_FC0_SUBTYPE_ACTION) {
				if (!IEEE80211_IS_MULTICAST(wh->i_addr1) &&
				    !(wh->i_fc[1] & IEEE80211_FC1_PROTECTED)) {
					/* unicast mgmt not encrypted */
					goto out;
				}
				/* do software decryption */
				m = ieee80211_decrypt(ic, m, ni);
				if (m == NULL) {
					/* XXX stats */
					goto out;
				}
				wh = mtod(m, struct ieee80211_frame *);
			}
		} else if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    (wh->i_fc[1] & IEEE80211_FC1_PROTECTED)) {
			/* encrypted but MMPDU Rx protection off for TA */
			goto out;
		}

#if NBPFILTER > 0
		if (bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_IN) != 0) {
			/*
			 * Drop mbuf if it was filtered by bpf. Normally,
			 * this is done in ether_input() but IEEE 802.11
			 * management frames are a special case.
			 */
			m_freem(m);
			return;
		}
#endif
		(*ic->ic_recv_mgmt)(ic, m, ni, rxi, subtype);
		m_freem(m);
		return;

	case IEEE80211_FC0_TYPE_CTL:
		ic->ic_stats.is_rx_ctl++;
		switch (subtype) {
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_FC0_SUBTYPE_PS_POLL:
			ieee80211_recv_pspoll(ic, m, ni);
			break;
#endif
		case IEEE80211_FC0_SUBTYPE_BAR:
			ieee80211_recv_bar(ic, m, ni);
			break;
		default:
			break;
		}
		goto out;

	default:
		DPRINTF(("bad frame type %x\n", type));
		/* should not come here */
		break;
	}
 err:
	ifp->if_ierrors++;
 out:
	if (m != NULL) {
#if NBPFILTER > 0
		if (ic->ic_rawbpf)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_IN);
#endif
		m_freem(m);
	}
}

/*
 * Handle defragmentation (see 9.5 and Annex C).  We support the concurrent
 * reception of fragments of three fragmented MSDUs or MMPDUs.
 */
struct mbuf *
ieee80211_defrag(struct ieee80211com *ic, struct mbuf *m, int hdrlen)
{
	const struct ieee80211_frame *owh, *wh;
	struct ieee80211_defrag *df;
	u_int16_t rxseq, seq;
	u_int8_t frag;
	int i;

	wh = mtod(m, struct ieee80211_frame *);
	rxseq = letoh16(*(const u_int16_t *)wh->i_seq);
	seq = rxseq >> IEEE80211_SEQ_SEQ_SHIFT;
	frag = rxseq & IEEE80211_SEQ_FRAG_MASK;

	if (frag == 0 && !(wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG))
		return m;	/* not fragmented */

	if (frag == 0) {
		/* first fragment, setup entry in the fragment cache */
		if (++ic->ic_defrag_cur == IEEE80211_DEFRAG_SIZE)
			ic->ic_defrag_cur = 0;
		df = &ic->ic_defrag[ic->ic_defrag_cur];
		m_freem(df->df_m);	/* discard old entry */
		df->df_seq = seq;
		df->df_frag = 0;
		df->df_m = m;
		/* start receive MSDU timer of aMaxReceiveLifetime */
		timeout_add_sec(&df->df_to, 1);
		return NULL;	/* MSDU or MMPDU not yet complete */
	}

	/* find matching entry in the fragment cache */
	for (i = 0; i < IEEE80211_DEFRAG_SIZE; i++) {
		df = &ic->ic_defrag[i];
		if (df->df_m == NULL)
			continue;
		if (df->df_seq != seq || df->df_frag + 1 != frag)
			continue;
		owh = mtod(df->df_m, struct ieee80211_frame *);
		/* frame type, source and destination must match */
		if (((wh->i_fc[0] ^ owh->i_fc[0]) & IEEE80211_FC0_TYPE_MASK) ||
		    !IEEE80211_ADDR_EQ(wh->i_addr1, owh->i_addr1) ||
		    !IEEE80211_ADDR_EQ(wh->i_addr2, owh->i_addr2))
			continue;
		/* matching entry found */
		break;
	}
	if (i == IEEE80211_DEFRAG_SIZE) {
		/* no matching entry found, discard fragment */
		ic->ic_if.if_ierrors++;
		m_freem(m);
		return NULL;
	}

	df->df_frag = frag;
	/* strip 802.11 header and concatenate fragment */
	m_adj(m, hdrlen);
	m_cat(df->df_m, m);
	df->df_m->m_pkthdr.len += m->m_pkthdr.len;

	if (wh->i_fc[1] & IEEE80211_FC1_MORE_FRAG)
		return NULL;	/* MSDU or MMPDU not yet complete */

	/* MSDU or MMPDU complete */
	timeout_del(&df->df_to);
	m = df->df_m;
	df->df_m = NULL;
	return m;
}

/*
 * Receive MSDU defragmentation timer exceeds aMaxReceiveLifetime.
 */
void
ieee80211_defrag_timeout(void *arg)
{
	struct ieee80211_defrag *df = arg;
	int s = splnet();

	/* discard all received fragments */
	m_freem(df->df_m);
	df->df_m = NULL;

	splx(s);
}

/*
 * Process a received data MPDU related to a specific HT-immediate Block Ack
 * agreement (see 9.10.7.6).
 */
void
ieee80211_input_ba(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, int tid, struct ieee80211_rxinfo *rxi)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	struct ieee80211_frame *wh;
	int idx, count;
	u_int16_t sn;

	wh = mtod(m, struct ieee80211_frame *);
	sn = letoh16(*(u_int16_t *)wh->i_seq) >> IEEE80211_SEQ_SEQ_SHIFT;

	/* reset Block Ack inactivity timer */
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);

	if (SEQ_LT(sn, ba->ba_winstart)) {	/* SN < WinStartB */
		ic->ic_stats.is_ht_rx_frame_below_ba_winstart++;
		m_freem(m);	/* discard the MPDU */
		return;
	}
	if (SEQ_LT(ba->ba_winend, sn)) {	/* WinEndB < SN */
		ic->ic_stats.is_ht_rx_frame_above_ba_winend++;
		count = (sn - ba->ba_winend) & 0xfff;
		if (count > ba->ba_winsize) {
			/* 
			 * Check whether we're consistently behind the window,
			 * and let the window move forward if neccessary.
			 */
			if (ba->ba_winmiss < IEEE80211_BA_MAX_WINMISS) { 
				if (ba->ba_missedsn == ((sn - 1) & 0xfff))
					ba->ba_winmiss++;
				else
					ba->ba_winmiss = 0;
				ba->ba_missedsn = sn;
				ifp->if_ierrors++;
				m_freem(m);	/* discard the MPDU */
				return;
			}

			/* It appears the window has moved for real. */
			ic->ic_stats.is_ht_rx_ba_window_jump++;
			ba->ba_winmiss = 0;
			ba->ba_missedsn = 0;
			ieee80211_ba_move_window(ic, ni, tid, sn);
		} else {
			ic->ic_stats.is_ht_rx_ba_window_slide++;
			ieee80211_input_ba_seq(ic, ni, tid,
			    (ba->ba_winstart + count) & 0xfff);
			ieee80211_input_ba_flush(ic, ni, ba);
		}
	}
	/* WinStartB <= SN <= WinEndB */

	ba->ba_winmiss = 0;
	ba->ba_missedsn = 0;
	idx = (sn - ba->ba_winstart) & 0xfff;
	idx = (ba->ba_head + idx) % IEEE80211_BA_MAX_WINSZ;
	/* store the received MPDU in the buffer */
	if (ba->ba_buf[idx].m != NULL) {
		ifp->if_ierrors++;
		ic->ic_stats.is_ht_rx_ba_no_buf++;
		m_freem(m);
		return;
	}
	ba->ba_buf[idx].m = m;
	/* store Rx meta-data too */
	rxi->rxi_flags |= IEEE80211_RXI_AMPDU_DONE;
	ba->ba_buf[idx].rxi = *rxi;

	if (ba->ba_buf[ba->ba_head].m == NULL)
		timeout_add_msec(&ba->ba_gap_to, IEEE80211_BA_GAP_TIMEOUT);
	else if (timeout_pending(&ba->ba_gap_to))
		timeout_del(&ba->ba_gap_to);

	ieee80211_input_ba_flush(ic, ni, ba);
}

/* 
 * Forward buffered frames with sequence number lower than max_seq.
 * See 802.11-2012 9.21.7.6.2 b.
 */
void
ieee80211_input_ba_seq(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid, uint16_t max_seq)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	struct ieee80211_frame *wh;
	uint16_t seq;
	int i = 0;

	while (i++ < ba->ba_winsize) {
		/* gaps may exist */
		if (ba->ba_buf[ba->ba_head].m != NULL) {
			wh = mtod(ba->ba_buf[ba->ba_head].m,
			    struct ieee80211_frame *);
			KASSERT(ieee80211_has_seq(wh));
			seq = letoh16(*(u_int16_t *)wh->i_seq) >>
			    IEEE80211_SEQ_SEQ_SHIFT;
			if (!SEQ_LT(seq, max_seq))
				return;
			ieee80211_input(ifp, ba->ba_buf[ba->ba_head].m,
			    ni, &ba->ba_buf[ba->ba_head].rxi);
			ba->ba_buf[ba->ba_head].m = NULL;
		} else
			ic->ic_stats.is_ht_rx_ba_frame_lost++;
		ba->ba_head = (ba->ba_head + 1) % IEEE80211_BA_MAX_WINSZ;
	}
}

/* Flush a consecutive sequence of frames from the reorder buffer. */
void
ieee80211_input_ba_flush(struct ieee80211com *ic, struct ieee80211_node *ni,
    struct ieee80211_rx_ba *ba)

{
	struct ifnet *ifp = &ic->ic_if;

	/* pass reordered MPDUs up to the next MAC process */
	while (ba->ba_buf[ba->ba_head].m != NULL) {
		ieee80211_input(ifp, ba->ba_buf[ba->ba_head].m, ni,
		    &ba->ba_buf[ba->ba_head].rxi);
		ba->ba_buf[ba->ba_head].m = NULL;

		ba->ba_head = (ba->ba_head + 1) % IEEE80211_BA_MAX_WINSZ;
		/* move window forward */
		ba->ba_winstart = (ba->ba_winstart + 1) & 0xfff;
	}
	ba->ba_winend = (ba->ba_winstart + ba->ba_winsize - 1) & 0xfff;
}

/* 
 * Forcibly move the BA window forward to remove a leading gap which has
 * been causing frames to linger in the reordering buffer for too long.
 * A leading gap will occur if a particular A-MPDU subframe never arrives
 * or if a bug in the sender causes sequence numbers to jump forward by > 1.
 */
void
ieee80211_input_ba_gap_timeout(void *arg)
{
	struct ieee80211_rx_ba *ba = arg;
	struct ieee80211_node *ni = ba->ba_ni;
	struct ieee80211com *ic = ni->ni_ic;
	int s, skipped;

	ic->ic_stats.is_ht_rx_ba_window_gap_timeout++;

	s = splnet();

	skipped = 0;
	while (skipped < ba->ba_winsize && ba->ba_buf[ba->ba_head].m == NULL) {
		/* move window forward */
		ba->ba_head = (ba->ba_head + 1) % IEEE80211_BA_MAX_WINSZ;
		ba->ba_winstart = (ba->ba_winstart + 1) & 0xfff;
		skipped++;
		ic->ic_stats.is_ht_rx_ba_frame_lost++;
	}
	if (skipped > 0)
		ba->ba_winend = (ba->ba_winstart + ba->ba_winsize - 1) & 0xfff;

	ieee80211_input_ba_flush(ic, ni, ba);

	splx(s);	
}


/*
 * Change the value of WinStartB (move window forward) upon reception of a
 * BlockAckReq frame or an ADDBA Request (PBAC).
 */
void
ieee80211_ba_move_window(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t tid, u_int16_t ssn)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];
	int count;

	/* assert(WinStartB <= SSN) */

	count = (ssn - ba->ba_winstart) & 0xfff;
	if (count > ba->ba_winsize)	/* no overlap */
		count = ba->ba_winsize;
	while (count-- > 0) {
		/* gaps may exist */
		if (ba->ba_buf[ba->ba_head].m != NULL) {
			ieee80211_input(ifp, ba->ba_buf[ba->ba_head].m, ni,
			    &ba->ba_buf[ba->ba_head].rxi);
			ba->ba_buf[ba->ba_head].m = NULL;
		} else
			ic->ic_stats.is_ht_rx_ba_frame_lost++;
		ba->ba_head = (ba->ba_head + 1) % IEEE80211_BA_MAX_WINSZ;
	}
	/* move window forward */
	ba->ba_winstart = ssn;

	ieee80211_input_ba_flush(ic, ni, ba);
}

void
ieee80211_deliver_data(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, int mcast)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ether_header *eh;
	struct mbuf *m1;

	eh = mtod(m, struct ether_header *);

	if ((ic->ic_flags & IEEE80211_F_RSNON) && !ni->ni_port_valid &&
	    eh->ether_type != htons(ETHERTYPE_PAE)) {
		DPRINTF(("port not valid: %s\n",
		    ether_sprintf(eh->ether_dhost)));
		ic->ic_stats.is_rx_unauth++;
		m_freem(m);
		return;
	}

	/*
	 * Perform as a bridge within the AP.  Notice that we do not
	 * bridge EAPOL frames as suggested in C.1.1 of IEEE Std 802.1X.
	 * And we do not forward unicast frames received on a multicast address.
	 */
	m1 = NULL;
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
	    !(ic->ic_flags & IEEE80211_F_NOBRIDGE) &&
	    eh->ether_type != htons(ETHERTYPE_PAE)) {
		struct ieee80211_node *ni1;

		if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
			m1 = m_dup_pkt(m, ETHER_ALIGN, M_DONTWAIT);
			if (m1 == NULL)
				ifp->if_oerrors++;
			else
				m1->m_flags |= M_MCAST;
		} else if (!mcast) {
			ni1 = ieee80211_find_node(ic, eh->ether_dhost);
			if (ni1 != NULL &&
			    ni1->ni_state == IEEE80211_STA_ASSOC) {
				m1 = m;
				m = NULL;
			}
		}
		if (m1 != NULL) {
			if (if_enqueue(ifp, m1))
				 ifp->if_oerrors++;
		}
	}
#endif
	if (m != NULL) {
		if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    eh->ether_type == htons(ETHERTYPE_PAE)) {
			ifp->if_ipackets++;
#if NBPFILTER > 0
			/*
			 * If we forward frame into transmitter of the AP,
			 * we don't need to duplicate for DLT_EN10MB.
			 */
			if (ifp->if_bpf && m1 == NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
			ieee80211_eapol_key_input(ic, m, ni);
		} else {
			struct mbuf_list ml = MBUF_LIST_INITIALIZER();
			ml_enqueue(&ml, m);
			if_input(ifp, &ml);
		}
	}
}

void
ieee80211_decap(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, int hdrlen)
{
	struct ether_header eh;
	struct ieee80211_frame *wh;
	struct llc *llc;
	int mcast;

	if (m->m_len < hdrlen + LLC_SNAPFRAMELEN &&
	    (m = m_pullup(m, hdrlen + LLC_SNAPFRAMELEN)) == NULL) {
		ic->ic_stats.is_rx_decap++;
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	mcast = IEEE80211_IS_MULTICAST(wh->i_addr1);
	switch (wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_NODS:
		IEEE80211_ADDR_COPY(eh.ether_dhost, wh->i_addr1);
		IEEE80211_ADDR_COPY(eh.ether_shost, wh->i_addr2);
		break;
	case IEEE80211_FC1_DIR_TODS:
		IEEE80211_ADDR_COPY(eh.ether_dhost, wh->i_addr3);
		IEEE80211_ADDR_COPY(eh.ether_shost, wh->i_addr2);
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		IEEE80211_ADDR_COPY(eh.ether_dhost, wh->i_addr1);
		IEEE80211_ADDR_COPY(eh.ether_shost, wh->i_addr3);
		break;
	case IEEE80211_FC1_DIR_DSTODS:
		IEEE80211_ADDR_COPY(eh.ether_dhost, wh->i_addr3);
		IEEE80211_ADDR_COPY(eh.ether_shost,
		    ((struct ieee80211_frame_addr4 *)wh)->i_addr4);
		break;
	}
	llc = (struct llc *)((caddr_t)wh + hdrlen);
	if (llc->llc_dsap == LLC_SNAP_LSAP &&
	    llc->llc_ssap == LLC_SNAP_LSAP &&
	    llc->llc_control == LLC_UI &&
	    llc->llc_snap.org_code[0] == 0 &&
	    llc->llc_snap.org_code[1] == 0 &&
	    llc->llc_snap.org_code[2] == 0) {
		eh.ether_type = llc->llc_snap.ether_type;
		m_adj(m, hdrlen + LLC_SNAPFRAMELEN - ETHER_HDR_LEN);
	} else {
		eh.ether_type = htons(m->m_pkthdr.len - hdrlen);
		m_adj(m, hdrlen - ETHER_HDR_LEN);
	}
	memcpy(mtod(m, caddr_t), &eh, ETHER_HDR_LEN);
	if (!ALIGNED_POINTER(mtod(m, caddr_t) + ETHER_HDR_LEN, u_int32_t)) {
		struct mbuf *m0 = m;
		m = m_dup_pkt(m0, ETHER_ALIGN, M_NOWAIT);
		m_freem(m0);
		if (m == NULL) {
			ic->ic_stats.is_rx_decap++;
			return;
		}
	}
	ieee80211_deliver_data(ic, m, ni, mcast);
}

/*
 * Decapsulate an Aggregate MSDU (see 7.2.2.2).
 */
void
ieee80211_amsdu_decap(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, int hdrlen)
{
	struct mbuf *n;
	struct ether_header *eh;
	struct llc *llc;
	int len, pad, mcast;
	struct ieee80211_frame *wh;

	wh = mtod(m, struct ieee80211_frame *);
	mcast = IEEE80211_IS_MULTICAST(wh->i_addr1);

	/* strip 802.11 header */
	m_adj(m, hdrlen);

	for (;;) {
		/* process an A-MSDU subframe */
		if (m->m_len < ETHER_HDR_LEN + LLC_SNAPFRAMELEN) {
			m = m_pullup(m, ETHER_HDR_LEN + LLC_SNAPFRAMELEN);
			if (m == NULL) {
				ic->ic_stats.is_rx_decap++;
				break;
			}
		}
		eh = mtod(m, struct ether_header *);
		/* examine 802.3 header */
		len = ntohs(eh->ether_type);
		if (len < LLC_SNAPFRAMELEN) {
			DPRINTF(("A-MSDU subframe too short (%d)\n", len));
			/* stop processing A-MSDU subframes */
			ic->ic_stats.is_rx_decap++;
			m_freem(m);
			break;
		}
		llc = (struct llc *)&eh[1];
		/* examine 802.2 LLC header */
		if (llc->llc_dsap == LLC_SNAP_LSAP &&
		    llc->llc_ssap == LLC_SNAP_LSAP &&
		    llc->llc_control == LLC_UI &&
		    llc->llc_snap.org_code[0] == 0 &&
		    llc->llc_snap.org_code[1] == 0 &&
		    llc->llc_snap.org_code[2] == 0) {
			/* convert to Ethernet II header */
			eh->ether_type = llc->llc_snap.ether_type;
			/* strip LLC+SNAP headers */
			memmove((u_int8_t *)eh + LLC_SNAPFRAMELEN, eh,
			    ETHER_HDR_LEN);
			m_adj(m, LLC_SNAPFRAMELEN);
			len -= LLC_SNAPFRAMELEN;
		}
		len += ETHER_HDR_LEN;
		if (len > m->m_pkthdr.len) {
			/* stop processing A-MSDU subframes */
			DPRINTF(("A-MSDU subframe too long (%d)\n", len));
			ic->ic_stats.is_rx_decap++;
			m_freem(m);
			break;
		}

		/* "detach" our A-MSDU subframe from the others */
		n = m_split(m, len, M_NOWAIT);
		if (n == NULL) {
			/* stop processing A-MSDU subframes */
			ic->ic_stats.is_rx_decap++;
			m_freem(m);
			break;
		}
		ieee80211_deliver_data(ic, m, ni, mcast);

		if (n->m_pkthdr.len == 0) {
			m_freem(n);
			break;
		}
		m = n;
		/* remove padding */
		pad = ((len + 3) & ~3) - len;
		m_adj(m, pad);
	}
}

/*
 * Parse an EDCA Parameter Set element (see 7.3.2.27).
 */
int
ieee80211_parse_edca_params_body(struct ieee80211com *ic, const u_int8_t *frm)
{
	u_int updtcount;
	int aci;

	/*
	 * Check if EDCA parameters have changed XXX if we miss more than
	 * 15 consecutive beacons, we might not detect changes to EDCA
	 * parameters due to wraparound of the 4-bit Update Count field.
	 */
	updtcount = frm[0] & 0xf;
	if (updtcount == ic->ic_edca_updtcount)
		return 0;	/* no changes to EDCA parameters, ignore */
	ic->ic_edca_updtcount = updtcount;

	frm += 2;	/* skip QoS Info & Reserved fields */

	/* parse AC Parameter Records */
	for (aci = 0; aci < EDCA_NUM_AC; aci++) {
		struct ieee80211_edca_ac_params *ac = &ic->ic_edca_ac[aci];

		ac->ac_acm       = (frm[0] >> 4) & 0x1;
		ac->ac_aifsn     = frm[0] & 0xf;
		ac->ac_ecwmin    = frm[1] & 0xf;
		ac->ac_ecwmax    = frm[1] >> 4;
		ac->ac_txoplimit = LE_READ_2(frm + 2);
		frm += 4;
	}
	/* give drivers a chance to update their settings */
	if ((ic->ic_flags & IEEE80211_F_QOS) && ic->ic_updateedca != NULL)
		(*ic->ic_updateedca)(ic);

	return 0;
}

int
ieee80211_parse_edca_params(struct ieee80211com *ic, const u_int8_t *frm)
{
	if (frm[1] < 18) {
		ic->ic_stats.is_rx_elem_toosmall++;
		return IEEE80211_REASON_IE_INVALID;
	}
	return ieee80211_parse_edca_params_body(ic, frm + 2);
}

int
ieee80211_parse_wmm_params(struct ieee80211com *ic, const u_int8_t *frm)
{
	if (frm[1] < 24) {
		ic->ic_stats.is_rx_elem_toosmall++;
		return IEEE80211_REASON_IE_INVALID;
	}
	return ieee80211_parse_edca_params_body(ic, frm + 8);
}

enum ieee80211_cipher
ieee80211_parse_rsn_cipher(const u_int8_t selector[4])
{
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0) {	/* WPA */
		switch (selector[3]) {
		case 0:	/* use group data cipher suite */
			return IEEE80211_CIPHER_USEGROUP;
		case 1:	/* WEP-40 */
			return IEEE80211_CIPHER_WEP40;
		case 2:	/* TKIP */
			return IEEE80211_CIPHER_TKIP;
		case 4:	/* CCMP (RSNA default) */
			return IEEE80211_CIPHER_CCMP;
		case 5:	/* WEP-104 */
			return IEEE80211_CIPHER_WEP104;
		}
	} else if (memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN */
		/* see 802.11-2012 Table 8-99 */
		switch (selector[3]) {
		case 0:	/* use group data cipher suite */
			return IEEE80211_CIPHER_USEGROUP;
		case 1:	/* WEP-40 */
			return IEEE80211_CIPHER_WEP40;
		case 2:	/* TKIP */
			return IEEE80211_CIPHER_TKIP;
		case 4:	/* CCMP (RSNA default) */
			return IEEE80211_CIPHER_CCMP;
		case 5:	/* WEP-104 */
			return IEEE80211_CIPHER_WEP104;
		case 6:	/* BIP */
			return IEEE80211_CIPHER_BIP;
		}
	}
	return IEEE80211_CIPHER_NONE;	/* ignore unknown ciphers */
}

enum ieee80211_akm
ieee80211_parse_rsn_akm(const u_int8_t selector[4])
{
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0) {	/* WPA */
		switch (selector[3]) {
		case 1:	/* IEEE 802.1X (RSNA default) */
			return IEEE80211_AKM_8021X;
		case 2:	/* PSK */
			return IEEE80211_AKM_PSK;
		}
	} else if (memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN */
		/* from IEEE Std 802.11i-2004 - Table 20dc */
		switch (selector[3]) {
		case 1:	/* IEEE 802.1X (RSNA default) */
			return IEEE80211_AKM_8021X;
		case 2:	/* PSK */
			return IEEE80211_AKM_PSK;
		case 5:	/* IEEE 802.1X with SHA256 KDF */
			return IEEE80211_AKM_SHA256_8021X;
		case 6:	/* PSK with SHA256 KDF */
			return IEEE80211_AKM_SHA256_PSK;
		}
	}
	return IEEE80211_AKM_NONE;	/* ignore unknown AKMs */
}

/*
 * Parse an RSN element (see 802.11-2012 8.4.2.27)
 */
int
ieee80211_parse_rsn_body(struct ieee80211com *ic, const u_int8_t *frm,
    u_int len, struct ieee80211_rsnparams *rsn)
{
	const u_int8_t *efrm;
	u_int16_t m, n, s;

	efrm = frm + len;

	/* check Version field */
	if (LE_READ_2(frm) != 1)
		return IEEE80211_STATUS_RSN_IE_VER_UNSUP;
	frm += 2;

	/* all fields after the Version field are optional */

	/* if Cipher Suite missing, default to CCMP */
	rsn->rsn_groupcipher = IEEE80211_CIPHER_CCMP;
	rsn->rsn_nciphers = 1;
	rsn->rsn_ciphers = IEEE80211_CIPHER_CCMP;
	/* if Group Management Cipher Suite missing, defaut to BIP */
	rsn->rsn_groupmgmtcipher = IEEE80211_CIPHER_BIP;
	/* if AKM Suite missing, default to 802.1X */
	rsn->rsn_nakms = 1;
	rsn->rsn_akms = IEEE80211_AKM_8021X;
	/* if RSN capabilities missing, default to 0 */
	rsn->rsn_caps = 0;
	rsn->rsn_npmkids = 0;

	/* read Group Data Cipher Suite field */
	if (frm + 4 > efrm)
		return 0;
	rsn->rsn_groupcipher = ieee80211_parse_rsn_cipher(frm);
	if (rsn->rsn_groupcipher == IEEE80211_CIPHER_NONE ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_USEGROUP ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_BIP)
		return IEEE80211_STATUS_BAD_GROUP_CIPHER;
	frm += 4;

	/* read Pairwise Cipher Suite Count field */
	if (frm + 2 > efrm)
		return 0;
	m = rsn->rsn_nciphers = LE_READ_2(frm);
	frm += 2;

	/* read Pairwise Cipher Suite List */
	if (frm + m * 4 > efrm)
		return IEEE80211_STATUS_IE_INVALID;
	rsn->rsn_ciphers = IEEE80211_CIPHER_NONE;
	while (m-- > 0) {
		rsn->rsn_ciphers |= ieee80211_parse_rsn_cipher(frm);
		frm += 4;
	}
	if (rsn->rsn_ciphers & IEEE80211_CIPHER_USEGROUP) {
		if (rsn->rsn_ciphers != IEEE80211_CIPHER_USEGROUP)
			return IEEE80211_STATUS_BAD_PAIRWISE_CIPHER;
		if (rsn->rsn_groupcipher == IEEE80211_CIPHER_CCMP)
			return IEEE80211_STATUS_BAD_PAIRWISE_CIPHER;
	}

	/* read AKM Suite List Count field */
	if (frm + 2 > efrm)
		return 0;
	n = rsn->rsn_nakms = LE_READ_2(frm);
	frm += 2;

	/* read AKM Suite List */
	if (frm + n * 4 > efrm)
		return IEEE80211_STATUS_IE_INVALID;
	rsn->rsn_akms = IEEE80211_AKM_NONE;
	while (n-- > 0) {
		rsn->rsn_akms |= ieee80211_parse_rsn_akm(frm);
		frm += 4;
	}

	/* read RSN Capabilities field */
	if (frm + 2 > efrm)
		return 0;
	rsn->rsn_caps = LE_READ_2(frm);
	frm += 2;

	/* read PMKID Count field */
	if (frm + 2 > efrm)
		return 0;
	s = rsn->rsn_npmkids = LE_READ_2(frm);
	frm += 2;

	/* read PMKID List */
	if (frm + s * IEEE80211_PMKID_LEN > efrm)
		return IEEE80211_STATUS_IE_INVALID;
	if (s != 0) {
		rsn->rsn_pmkids = frm;
		frm += s * IEEE80211_PMKID_LEN;
	}

	/* read Group Management Cipher Suite field */
	if (frm + 4 > efrm)
		return 0;
	rsn->rsn_groupmgmtcipher = ieee80211_parse_rsn_cipher(frm);
	if (rsn->rsn_groupmgmtcipher != IEEE80211_CIPHER_BIP)
		return IEEE80211_STATUS_BAD_GROUP_CIPHER;

	return IEEE80211_STATUS_SUCCESS;
}

int
ieee80211_parse_rsn(struct ieee80211com *ic, const u_int8_t *frm,
    struct ieee80211_rsnparams *rsn)
{
	if (frm[1] < 2) {
		ic->ic_stats.is_rx_elem_toosmall++;
		return IEEE80211_STATUS_IE_INVALID;
	}
	return ieee80211_parse_rsn_body(ic, frm + 2, frm[1], rsn);
}

int
ieee80211_parse_wpa(struct ieee80211com *ic, const u_int8_t *frm,
    struct ieee80211_rsnparams *rsn)
{
	if (frm[1] < 6) {
		ic->ic_stats.is_rx_elem_toosmall++;
		return IEEE80211_STATUS_IE_INVALID;
	}
	return ieee80211_parse_rsn_body(ic, frm + 6, frm[1] - 4, rsn);
}

/*
 * Create (or update) a copy of an information element.
 */
int
ieee80211_save_ie(const u_int8_t *frm, u_int8_t **ie)
{
	int olen = *ie ? 2 + (*ie)[1] : 0;
	int len = 2 + frm[1];

	if (*ie == NULL || olen != len) {
		if (*ie != NULL)
			free(*ie, M_DEVBUF, olen);
		*ie = malloc(len, M_DEVBUF, M_NOWAIT);
		if (*ie == NULL)
			return ENOMEM;
	}
	memcpy(*ie, frm, len);
	return 0;
}

/*-
 * Beacon/Probe response frame format:
 * [8]   Timestamp
 * [2]   Beacon interval
 * [2]   Capability
 * [tlv] Service Set Identifier (SSID)
 * [tlv] Supported rates
 * [tlv] DS Parameter Set (802.11g)
 * [tlv] ERP Information (802.11g)
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] RSN (802.11i)
 * [tlv] EDCA Parameter Set (802.11e)
 * [tlv] QoS Capability (Beacon only, 802.11e)
 * [tlv] HT Capabilities (802.11n)
 * [tlv] HT Operation (802.11n)
 */
void
ieee80211_recv_probe_resp(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int isprobe)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm, *efrm;
	const u_int8_t *tstamp, *ssid, *rates, *xrates, *edcaie, *wmmie;
	const u_int8_t *rsnie, *wpaie, *htcaps, *htop;
	u_int16_t capinfo, bintval;
	u_int8_t chan, bchan, erp, dtim_count, dtim_period;
	int is_new;

	/*
	 * We process beacon/probe response frames for:
	 *    o station mode: to collect state
	 *      updates such as 802.11g slot time and for passive
	 *      scanning of APs
	 *    o adhoc mode: to discover neighbors
	 *    o hostap mode: for passive scanning of neighbor APs
	 *    o when scanning
	 * In other words, in all modes other than monitor (which
	 * does not process incoming frames) and adhoc-demo (which
	 * does not use management frames at all).
	 */
#ifdef DIAGNOSTIC
	if (ic->ic_opmode != IEEE80211_M_STA &&
#ifndef IEEE80211_STA_ONLY
	    ic->ic_opmode != IEEE80211_M_IBSS &&
	    ic->ic_opmode != IEEE80211_M_HOSTAP &&
#endif
	    ic->ic_state != IEEE80211_S_SCAN) {
		panic("%s: impossible operating mode", __func__);
	}
#endif
	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + 12) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m, u_int8_t *) + m->m_len;

	tstamp  = frm; frm += 8;
	bintval = LE_READ_2(frm); frm += 2;
	capinfo = LE_READ_2(frm); frm += 2;

	ssid = rates = xrates = edcaie = wmmie = rsnie = wpaie = NULL;
	htcaps = htop = NULL;
	bchan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	chan = bchan;
	erp = 0;
	dtim_count = dtim_period = 0;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm) {
			ic->ic_stats.is_rx_elem_toosmall++;
			break;
		}
		switch (frm[0]) {
		case IEEE80211_ELEMID_SSID:
			ssid = frm;
			break;
		case IEEE80211_ELEMID_RATES:
			rates = frm;
			break;
		case IEEE80211_ELEMID_DSPARMS:
			if (frm[1] < 1) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			chan = frm[2];
			break;
		case IEEE80211_ELEMID_XRATES:
			xrates = frm;
			break;
		case IEEE80211_ELEMID_ERP:
			if (frm[1] < 1) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			erp = frm[2];
			break;
		case IEEE80211_ELEMID_RSN:
			rsnie = frm;
			break;
		case IEEE80211_ELEMID_EDCAPARMS:
			edcaie = frm;
			break;
		case IEEE80211_ELEMID_HTCAPS:
			htcaps = frm;
			break;
		case IEEE80211_ELEMID_HTOP:
			htop = frm;
			break;
		case IEEE80211_ELEMID_TIM:
			if (frm[1] > 3) {
				dtim_count = frm[2];
				dtim_period = frm[3];
			}
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			if (memcmp(frm + 2, MICROSOFT_OUI, 3) == 0) {
				if (frm[5] == 1)
					wpaie = frm;
				else if (frm[1] >= 5 &&
				    frm[5] == 2 && frm[6] == 1)
					wmmie = frm;
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* supported rates element is mandatory */
	if (rates == NULL || rates[1] > IEEE80211_RATE_MAXSIZE) {
		DPRINTF(("invalid supported rates element\n"));
		return;
	}
	/* SSID element is mandatory */
	if (ssid == NULL || ssid[1] > IEEE80211_NWID_LEN) {
		DPRINTF(("invalid SSID element\n"));
		return;
	}

	if (
#if IEEE80211_CHAN_MAX < 255
	    chan > IEEE80211_CHAN_MAX ||
#endif
	    isclr(ic->ic_chan_active, chan)) {
		DPRINTF(("ignore %s with invalid channel %u\n",
		    isprobe ? "probe response" : "beacon", chan));
		ic->ic_stats.is_rx_badchan++;
		return;
	}
	if ((ic->ic_state != IEEE80211_S_SCAN ||
	     !(ic->ic_caps & IEEE80211_C_SCANALL)) &&
	    chan != bchan) {
		/*
		 * Frame was received on a channel different from the
		 * one indicated in the DS params element id;
		 * silently discard it.
		 *
		 * NB: this can happen due to signal leakage.
		 */
		DPRINTF(("ignore %s on channel %u marked for channel %u\n",
		    isprobe ? "probe response" : "beacon", bchan, chan));
		ic->ic_stats.is_rx_chanmismatch++;
		return;
	}
	/*
	 * Use mac, channel and rssi so we collect only the
	 * best potential AP with the equal bssid while scanning.
	 * Collecting all potential APs may result in bloat of
	 * the node tree. This call will return NULL if the node
	 * for this APs does not exist or if the new node is the
	 * potential better one.
	 */
	ni = ieee80211_find_node_for_beacon(ic, wh->i_addr2,
	    &ic->ic_channels[chan], ssid, rxi->rxi_rssi);
	if (ni != NULL) {
		/*
		 * If we are doing a directed scan for an AP with a hidden SSID
		 * we must collect the SSID from a probe response to override
		 * a non-zero-length SSID filled with zeroes that we may have
		 * received earlier in a beacon.
		 */
		if (isprobe && ssid[1] != 0 && ni->ni_essid[0] == '\0') {
			ni->ni_esslen = ssid[1];
			memset(ni->ni_essid, 0, sizeof(ni->ni_essid));
			/* we know that ssid[1] <= IEEE80211_NWID_LEN */
			memcpy(ni->ni_essid, &ssid[2], ssid[1]);
		}

		return;
	}

#ifdef IEEE80211_DEBUG
	if (ieee80211_debug > 1 &&
	    (ni == NULL || ic->ic_state == IEEE80211_S_SCAN)) {
		printf("%s: %s%s on chan %u (bss chan %u) ",
		    __func__, (ni == NULL ? "new " : ""),
		    isprobe ? "probe response" : "beacon",
		    chan, bchan);
		ieee80211_print_essid(ssid + 2, ssid[1]);
		printf(" from %s\n", ether_sprintf((u_int8_t *)wh->i_addr2));
		printf("%s: caps 0x%x bintval %u erp 0x%x\n",
			__func__, capinfo, bintval, erp);
	}
#endif

	if ((ni = ieee80211_find_node(ic, wh->i_addr2)) == NULL) {
		ni = ieee80211_alloc_node(ic, wh->i_addr2);
		if (ni == NULL)
			return;
		is_new = 1;
	} else
		is_new = 0;

	if (htcaps)
		ieee80211_setup_htcaps(ni, htcaps + 2, htcaps[1]);
	if (htop && !ieee80211_setup_htop(ni, htop + 2, htop[1]))
		htop = NULL; /* invalid HTOP */

	ni->ni_dtimcount = dtim_count;
	ni->ni_dtimperiod = dtim_period;

	/*
	 * When operating in station mode, check for state updates
	 * while we're associated.
	 */
	if (ic->ic_opmode == IEEE80211_M_STA &&
	    ic->ic_state == IEEE80211_S_RUN &&
	    ni->ni_state == IEEE80211_STA_BSS) {
		/*
		 * Check if protection mode has changed since last beacon.
		 */
		if (ni->ni_erp != erp) {
			DPRINTF(("[%s] erp change: was 0x%x, now 0x%x\n",
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ni->ni_erp, erp));
			if (ic->ic_curmode == IEEE80211_MODE_11G &&
			    (erp & IEEE80211_ERP_USE_PROTECTION))
				ic->ic_flags |= IEEE80211_F_USEPROT;
			else
				ic->ic_flags &= ~IEEE80211_F_USEPROT;
			ic->ic_bss->ni_erp = erp;
		}
		if (htop && (ic->ic_bss->ni_flags & IEEE80211_NODE_HT)) {
			enum ieee80211_htprot htprot_last, htprot;
			htprot_last =
			    ((ic->ic_bss->ni_htop1 & IEEE80211_HTOP1_PROT_MASK)
			    >> IEEE80211_HTOP1_PROT_SHIFT);
			htprot = ((ni->ni_htop1 & IEEE80211_HTOP1_PROT_MASK) >>
			    IEEE80211_HTOP1_PROT_SHIFT);
			if (htprot_last != htprot) {
				DPRINTF(("[%s] htprot change: was %d, now %d\n",
				    ether_sprintf((u_int8_t *)wh->i_addr2),
				    htprot_last, htprot));
				ic->ic_stats.is_ht_prot_change++;
				ic->ic_bss->ni_htop1 = ni->ni_htop1;
				if (ic->ic_update_htprot)
					ic->ic_update_htprot(ic, ic->ic_bss);
			}
		}

		/*
		 * Check if AP short slot time setting has changed
		 * since last beacon and give the driver a chance to
		 * update the hardware.
		 */
		if ((ni->ni_capinfo ^ capinfo) &
		    IEEE80211_CAPINFO_SHORT_SLOTTIME) {
			ieee80211_set_shortslottime(ic,
			    ic->ic_curmode == IEEE80211_MODE_11A ||
			    (capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME));
		}

		/* 
		 * Reset management timer. If it is non-zero in RUN state, the
		 * driver sent a probe request after a missed beacon event.
		 * This probe response indicates the AP is still serving us
		 * so don't allow ieee80211_watchdog() to move us into SCAN.
		 */
		 ic->ic_mgt_timer = 0;
	}
	/*
	 * We do not try to update EDCA parameters if QoS was not negotiated
	 * with the AP at association time.
	 */
	if (ni->ni_flags & IEEE80211_NODE_QOS) {
		/* always prefer EDCA IE over Wi-Fi Alliance WMM IE */
		if ((edcaie != NULL &&
		     ieee80211_parse_edca_params(ic, edcaie) == 0) ||
		    (wmmie != NULL &&
		     ieee80211_parse_wmm_params(ic, wmmie) == 0))
			ni->ni_flags |= IEEE80211_NODE_QOS;
		else
			ni->ni_flags &= ~IEEE80211_NODE_QOS;
	}

	if (ic->ic_state == IEEE80211_S_SCAN) {
		struct ieee80211_rsnparams rsn, wpa;

		ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
		ni->ni_supported_rsnprotos = IEEE80211_PROTO_NONE;
		ni->ni_rsnakms = 0;
		ni->ni_supported_rsnakms = 0;
		ni->ni_rsnciphers = 0;
		ni->ni_rsngroupcipher = 0;
		ni->ni_rsngroupmgmtcipher = 0;
		ni->ni_rsncaps = 0;

		if (rsnie != NULL &&
		    ieee80211_parse_rsn(ic, rsnie, &rsn) == 0) {
			ni->ni_supported_rsnprotos |= IEEE80211_PROTO_RSN;
			ni->ni_supported_rsnakms |= rsn.rsn_akms;
		}
		if (wpaie != NULL &&
		    ieee80211_parse_wpa(ic, wpaie, &wpa) == 0) {
			ni->ni_supported_rsnprotos |= IEEE80211_PROTO_WPA;
			ni->ni_supported_rsnakms |= wpa.rsn_akms;
		}

		/*
		 * If the AP advertises both WPA and RSN IEs (WPA1+WPA2),
		 * we only use the highest protocol version we support.
		 */
		if (rsnie != NULL &&
		    (ni->ni_supported_rsnprotos & IEEE80211_PROTO_RSN) &&
		    (ic->ic_rsnprotos & IEEE80211_PROTO_RSN)) {
			if (ieee80211_save_ie(rsnie, &ni->ni_rsnie) == 0
#ifndef IEEE80211_STA_ONLY
	    		&& ic->ic_opmode != IEEE80211_M_HOSTAP
#endif
			) {
				ni->ni_rsnprotos = IEEE80211_PROTO_RSN;
				ni->ni_rsnakms = rsn.rsn_akms;
				ni->ni_rsnciphers = rsn.rsn_ciphers;
				ni->ni_rsngroupcipher = rsn.rsn_groupcipher;
				ni->ni_rsngroupmgmtcipher =
				    rsn.rsn_groupmgmtcipher;
				ni->ni_rsncaps = rsn.rsn_caps;
			}
		} else if (wpaie != NULL &&
		    (ni->ni_supported_rsnprotos & IEEE80211_PROTO_WPA) &&
		    (ic->ic_rsnprotos & IEEE80211_PROTO_WPA)) {
			if (ieee80211_save_ie(wpaie, &ni->ni_rsnie) == 0
#ifndef IEEE80211_STA_ONLY
	    		&& ic->ic_opmode != IEEE80211_M_HOSTAP
#endif
			) {
				ni->ni_rsnprotos = IEEE80211_PROTO_WPA;
				ni->ni_rsnakms = wpa.rsn_akms;
				ni->ni_rsnciphers = wpa.rsn_ciphers;
				ni->ni_rsngroupcipher = wpa.rsn_groupcipher;
				ni->ni_rsngroupmgmtcipher =
				    wpa.rsn_groupmgmtcipher;
				ni->ni_rsncaps = wpa.rsn_caps;
			}
		}
	}

	if (ssid[1] != 0 && ni->ni_essid[0] == '\0') {
		ni->ni_esslen = ssid[1];
		memset(ni->ni_essid, 0, sizeof(ni->ni_essid));
		/* we know that ssid[1] <= IEEE80211_NWID_LEN */
		memcpy(ni->ni_essid, &ssid[2], ssid[1]);
	}
	IEEE80211_ADDR_COPY(ni->ni_bssid, wh->i_addr3);
	ni->ni_rssi = rxi->rxi_rssi;
	ni->ni_rstamp = rxi->rxi_tstamp;
	memcpy(ni->ni_tstamp, tstamp, sizeof(ni->ni_tstamp));
	ni->ni_intval = bintval;
	ni->ni_capinfo = capinfo;
	/* XXX validate channel # */
	ni->ni_chan = &ic->ic_channels[chan];
	ni->ni_erp = erp;
	/* NB: must be after ni_chan is setup */
	ieee80211_setup_rates(ic, ni, rates, xrates, IEEE80211_F_DOSORT);
#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS && is_new && isprobe) {
		/*
		 * Fake an association so the driver can setup it's
		 * private state.  The rate set has been setup above;
		 * there is no handshake as in ap/station operation.
		 */
		if (ic->ic_newassoc)
			(*ic->ic_newassoc)(ic, ni, 1);
	}
#endif
}

#ifndef IEEE80211_STA_ONLY
/*-
 * Probe request frame format:
 * [tlv] SSID
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] HT Capabilities (802.11n)
 */
void
ieee80211_recv_probe_req(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm, *efrm;
	const u_int8_t *ssid, *rates, *xrates, *htcaps;
	u_int8_t rate;

	if (ic->ic_opmode == IEEE80211_M_STA ||
	    ic->ic_state != IEEE80211_S_RUN)
		return;

	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m, u_int8_t *) + m->m_len;

	ssid = rates = xrates = htcaps = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm) {
			ic->ic_stats.is_rx_elem_toosmall++;
			break;
		}
		switch (frm[0]) {
		case IEEE80211_ELEMID_SSID:
			ssid = frm;
			break;
		case IEEE80211_ELEMID_RATES:
			rates = frm;
			break;
		case IEEE80211_ELEMID_XRATES:
			xrates = frm;
			break;
		case IEEE80211_ELEMID_HTCAPS:
			htcaps = frm;
			break;
		}
		frm += 2 + frm[1];
	}
	/* supported rates element is mandatory */
	if (rates == NULL || rates[1] > IEEE80211_RATE_MAXSIZE) {
		DPRINTF(("invalid supported rates element\n"));
		return;
	}
	/* SSID element is mandatory */
	if (ssid == NULL || ssid[1] > IEEE80211_NWID_LEN) {
		DPRINTF(("invalid SSID element\n"));
		return;
	}
	/* check that the specified SSID (if not wildcard) matches ours */
	if (ssid[1] != 0 && (ssid[1] != ic->ic_bss->ni_esslen ||
	    memcmp(&ssid[2], ic->ic_bss->ni_essid, ic->ic_bss->ni_esslen))) {
		DPRINTF(("SSID mismatch\n"));
		ic->ic_stats.is_rx_ssidmismatch++;
		return;
	}
	/* refuse wildcard SSID if we're hiding our SSID in beacons */
	if (ssid[1] == 0 && (ic->ic_flags & IEEE80211_F_HIDENWID)) {
		DPRINTF(("wildcard SSID rejected"));
		ic->ic_stats.is_rx_ssidmismatch++;
		return;
	}

	if (ni == ic->ic_bss) {
		ni = ieee80211_find_node(ic, wh->i_addr2);
		if (ni == NULL)
			ni = ieee80211_dup_bss(ic, wh->i_addr2);
		if (ni == NULL)
			return;
		DPRINTF(("new probe req from %s\n",
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
	}
	ni->ni_rssi = rxi->rxi_rssi;
	ni->ni_rstamp = rxi->rxi_tstamp;
	rate = ieee80211_setup_rates(ic, ni, rates, xrates,
	    IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE | IEEE80211_F_DONEGO |
	    IEEE80211_F_DODEL);
	if (rate & IEEE80211_RATE_BASIC) {
		DPRINTF(("rate mismatch for %s\n",
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
		return;
	}
	if (htcaps)
		ieee80211_setup_htcaps(ni, htcaps + 2, htcaps[1]);
	else
		ieee80211_clear_htcaps(ni);
	IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_PROBE_RESP, 0);
}
#endif	/* IEEE80211_STA_ONLY */

/*-
 * Authentication frame format:
 * [2] Authentication algorithm number
 * [2] Authentication transaction sequence number
 * [2] Status code
 */
void
ieee80211_recv_auth(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	u_int16_t algo, seq, status;

	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + 6) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	algo   = LE_READ_2(frm); frm += 2;
	seq    = LE_READ_2(frm); frm += 2;
	status = LE_READ_2(frm); frm += 2;
	DPRINTF(("auth %d seq %d from %s\n", algo, seq,
	    ether_sprintf((u_int8_t *)wh->i_addr2)));

	/* only "open" auth mode is supported */
	if (algo != IEEE80211_AUTH_ALG_OPEN) {
		DPRINTF(("unsupported auth algorithm %d from %s\n",
		    algo, ether_sprintf((u_int8_t *)wh->i_addr2)));
		ic->ic_stats.is_rx_auth_unsupported++;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
			/* XXX hack to workaround calling convention */
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_AUTH,
			    IEEE80211_STATUS_ALG << 16 | ((seq + 1) & 0xffff));
		}
#endif
		return;
	}
	ieee80211_auth_open(ic, wh, ni, rxi, seq, status);
}

#ifndef IEEE80211_STA_ONLY
/*-
 * (Re)Association request frame format:
 * [2]   Capability information
 * [2]   Listen interval
 * [6*]  Current AP address (Reassociation only)
 * [tlv] SSID
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] RSN (802.11i)
 * [tlv] QoS Capability (802.11e)
 * [tlv] HT Capabilities (802.11n)
 */
void
ieee80211_recv_assoc_req(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int reassoc)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm, *efrm;
	const u_int8_t *ssid, *rates, *xrates, *rsnie, *wpaie, *htcaps;
	u_int16_t capinfo, bintval;
	int resp, status = 0;
	struct ieee80211_rsnparams rsn;
	u_int8_t rate;
	const u_int8_t *saveie = NULL;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP ||
	    ic->ic_state != IEEE80211_S_RUN)
		return;

	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + (reassoc ? 10 : 4)) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m, u_int8_t *) + m->m_len;

	if (!IEEE80211_ADDR_EQ(wh->i_addr3, ic->ic_bss->ni_bssid)) {
		DPRINTF(("ignore other bss from %s\n",
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
		ic->ic_stats.is_rx_assoc_bss++;
		return;
	}
	capinfo = LE_READ_2(frm); frm += 2;
	bintval = LE_READ_2(frm); frm += 2;
	if (reassoc) {
		frm += IEEE80211_ADDR_LEN;	/* skip current AP address */
		resp = IEEE80211_FC0_SUBTYPE_REASSOC_RESP;
	} else
		resp = IEEE80211_FC0_SUBTYPE_ASSOC_RESP;

	ssid = rates = xrates = rsnie = wpaie = htcaps = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm) {
			ic->ic_stats.is_rx_elem_toosmall++;
			break;
		}
		switch (frm[0]) {
		case IEEE80211_ELEMID_SSID:
			ssid = frm;
			break;
		case IEEE80211_ELEMID_RATES:
			rates = frm;
			break;
		case IEEE80211_ELEMID_XRATES:
			xrates = frm;
			break;
		case IEEE80211_ELEMID_RSN:
			rsnie = frm;
			break;
		case IEEE80211_ELEMID_QOS_CAP:
			break;
		case IEEE80211_ELEMID_HTCAPS:
			htcaps = frm;
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			if (memcmp(frm + 2, MICROSOFT_OUI, 3) == 0) {
				if (frm[5] == 1)
					wpaie = frm;
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* supported rates element is mandatory */
	if (rates == NULL || rates[1] > IEEE80211_RATE_MAXSIZE) {
		DPRINTF(("invalid supported rates element\n"));
		return;
	}
	/* SSID element is mandatory */
	if (ssid == NULL || ssid[1] > IEEE80211_NWID_LEN) {
		DPRINTF(("invalid SSID element\n"));
		return;
	}
	/* check that the specified SSID matches ours */
	if (ssid[1] != ic->ic_bss->ni_esslen ||
	    memcmp(&ssid[2], ic->ic_bss->ni_essid, ic->ic_bss->ni_esslen)) {
		DPRINTF(("SSID mismatch\n"));
		ic->ic_stats.is_rx_ssidmismatch++;
		return;
	}

	if (ni->ni_state != IEEE80211_STA_AUTH &&
	    ni->ni_state != IEEE80211_STA_ASSOC) {
		DPRINTF(("deny %sassoc from %s, not authenticated\n",
		    reassoc ? "re" : "",
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
		ni = ieee80211_find_node(ic, wh->i_addr2);
		if (ni == NULL)
			ni = ieee80211_dup_bss(ic, wh->i_addr2);
		if (ni != NULL) {
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_DEAUTH,
			    IEEE80211_REASON_ASSOC_NOT_AUTHED);
		}
		ic->ic_stats.is_rx_assoc_notauth++;
		return;
	}

	if (ni->ni_state == IEEE80211_STA_ASSOC &&
	    (ni->ni_flags & IEEE80211_NODE_MFP)) {
		if (ni->ni_flags & IEEE80211_NODE_SA_QUERY_FAILED) {
			/* send a protected Disassociate frame */
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_DISASSOC,
			    IEEE80211_REASON_AUTH_EXPIRE);
			/* terminate the old SA */
			ieee80211_node_leave(ic, ni);
		} else {
			/* reject the (Re)Association Request temporarily */
			IEEE80211_SEND_MGMT(ic, ni, resp,
			    IEEE80211_STATUS_TRY_AGAIN_LATER);
			/* start SA Query procedure if not already engaged */
			if (!(ni->ni_flags & IEEE80211_NODE_SA_QUERY))
				ieee80211_sa_query_request(ic, ni);
			/* do not modify association state */
		}
		return;
	}

	if (!(capinfo & IEEE80211_CAPINFO_ESS)) {
		ic->ic_stats.is_rx_assoc_capmismatch++;
		status = IEEE80211_STATUS_CAPINFO;
		goto end;
	}
	rate = ieee80211_setup_rates(ic, ni, rates, xrates,
	    IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE | IEEE80211_F_DONEGO |
	    IEEE80211_F_DODEL);
	if (rate & IEEE80211_RATE_BASIC) {
		ic->ic_stats.is_rx_assoc_norate++;
		status = IEEE80211_STATUS_BASIC_RATE;
		goto end;
	}

	ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
	ni->ni_supported_rsnprotos = IEEE80211_PROTO_NONE;
	ni->ni_rsnakms = 0;
	ni->ni_supported_rsnakms = 0;
	ni->ni_rsnciphers = 0;
	ni->ni_rsngroupcipher = 0;
	ni->ni_rsngroupmgmtcipher = 0;
	ni->ni_rsncaps = 0;

	/*
	 * A station should never include both a WPA and an RSN IE
	 * in its (Re)Association Requests, but if it does, we only
	 * consider the IE of the highest version of the protocol
	 * that is allowed (ie RSN over WPA).
	 */
	if (rsnie != NULL) {
		status = ieee80211_parse_rsn(ic, rsnie, &rsn);
		if (status != 0)
			goto end;
		ni->ni_supported_rsnprotos = IEEE80211_PROTO_RSN;
		ni->ni_supported_rsnakms = rsn.rsn_akms;
		if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    (ic->ic_rsnprotos & IEEE80211_PROTO_RSN)) {
			ni->ni_rsnprotos = IEEE80211_PROTO_RSN;
			saveie = rsnie;
		}
	} else if (wpaie != NULL) {
		status = ieee80211_parse_wpa(ic, wpaie, &rsn);
		if (status != 0)
			goto end;
		ni->ni_supported_rsnprotos = IEEE80211_PROTO_WPA;
		ni->ni_supported_rsnakms = rsn.rsn_akms;
		if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    (ic->ic_rsnprotos & IEEE80211_PROTO_WPA)) {
			ni->ni_rsnprotos = IEEE80211_PROTO_WPA;
			saveie = wpaie;
		}
	}

	if (ic->ic_flags & IEEE80211_F_RSNON) {
		if (ni->ni_rsnprotos == IEEE80211_PROTO_NONE) {
			/*
			 * In an RSN, an AP shall not associate with STAs
			 * that fail to include the RSN IE in the
			 * (Re)Association Request.
			 */
			status = IEEE80211_STATUS_IE_INVALID;
			goto end;
		}
		/*
		 * The initiating STA's RSN IE shall include one authentication
		 * and pairwise cipher suite among those advertised by the
		 * targeted AP.  It shall also specify the group cipher suite
		 * specified by the targeted AP.
		 */
		if (rsn.rsn_nakms != 1 ||
		    !(rsn.rsn_akms & ic->ic_bss->ni_rsnakms)) {
			status = IEEE80211_STATUS_BAD_AKMP;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}
		if (rsn.rsn_nciphers != 1 ||
		    !(rsn.rsn_ciphers & ic->ic_bss->ni_rsnciphers)) {
			status = IEEE80211_STATUS_BAD_PAIRWISE_CIPHER;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}
		if (rsn.rsn_groupcipher != ic->ic_bss->ni_rsngroupcipher) {
			status = IEEE80211_STATUS_BAD_GROUP_CIPHER;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}

		if ((ic->ic_bss->ni_rsncaps & IEEE80211_RSNCAP_MFPR) &&
		    !(rsn.rsn_caps & IEEE80211_RSNCAP_MFPC)) {
			status = IEEE80211_STATUS_MFP_POLICY;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}
		if ((ic->ic_bss->ni_rsncaps & IEEE80211_RSNCAP_MFPC) &&
		    (rsn.rsn_caps & (IEEE80211_RSNCAP_MFPC |
		     IEEE80211_RSNCAP_MFPR)) == IEEE80211_RSNCAP_MFPR) {
			/* STA advertises an invalid setting */
			status = IEEE80211_STATUS_MFP_POLICY;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}
		/*
		 * A STA that has associated with Management Frame Protection
		 * enabled shall not use cipher suite pairwise selector WEP40,
		 * WEP104, TKIP, or "Use Group cipher suite".
		 */
		if ((rsn.rsn_caps & IEEE80211_RSNCAP_MFPC) &&
		    (rsn.rsn_ciphers != IEEE80211_CIPHER_CCMP ||
		     rsn.rsn_groupmgmtcipher !=
		     ic->ic_bss->ni_rsngroupmgmtcipher)) {
			status = IEEE80211_STATUS_MFP_POLICY;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}

		/*
		 * Disallow new associations using TKIP if countermeasures
		 * are active.
		 */
		if ((ic->ic_flags & IEEE80211_F_COUNTERM) &&
		    (rsn.rsn_ciphers == IEEE80211_CIPHER_TKIP ||
		     rsn.rsn_groupcipher == IEEE80211_CIPHER_TKIP)) {
			status = IEEE80211_STATUS_CIPHER_REJ_POLICY;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}

		/* everything looks fine, save IE and parameters */
		if (saveie == NULL ||
		    ieee80211_save_ie(saveie, &ni->ni_rsnie) != 0) {
			status = IEEE80211_STATUS_TOOMANY;
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
			goto end;
		}
		ni->ni_rsnakms = rsn.rsn_akms;
		ni->ni_rsnciphers = rsn.rsn_ciphers;
		ni->ni_rsngroupcipher = ic->ic_bss->ni_rsngroupcipher;
		ni->ni_rsngroupmgmtcipher = ic->ic_bss->ni_rsngroupmgmtcipher;
		ni->ni_rsncaps = rsn.rsn_caps;

		if (ieee80211_is_8021x_akm(ni->ni_rsnakms)) {
			struct ieee80211_pmk *pmk = NULL;
			const u_int8_t *pmkid = rsn.rsn_pmkids;
			/*
			 * Check if we have a cached PMK entry matching one
			 * of the PMKIDs specified in the RSN IE.
			 */
			while (rsn.rsn_npmkids-- > 0) {
				pmk = ieee80211_pmksa_find(ic, ni, pmkid);
				if (pmk != NULL)
					break;
				pmkid += IEEE80211_PMKID_LEN;
			}
			if (pmk != NULL) {
				memcpy(ni->ni_pmk, pmk->pmk_key,
				    IEEE80211_PMK_LEN);
				memcpy(ni->ni_pmkid, pmk->pmk_pmkid,
				    IEEE80211_PMKID_LEN);
				ni->ni_flags |= IEEE80211_NODE_PMK;
			}
		}
	}

	ni->ni_rssi = rxi->rxi_rssi;
	ni->ni_rstamp = rxi->rxi_tstamp;
	ni->ni_intval = bintval;
	ni->ni_capinfo = capinfo;
	ni->ni_chan = ic->ic_bss->ni_chan;
	if (htcaps)
		ieee80211_setup_htcaps(ni, htcaps + 2, htcaps[1]);
	else
		ieee80211_clear_htcaps(ni);
 end:
	if (status != 0) {
		IEEE80211_SEND_MGMT(ic, ni, resp, status);
		ieee80211_node_leave(ic, ni);
	} else
		ieee80211_node_join(ic, ni, resp);
}
#endif	/* IEEE80211_STA_ONLY */

/*-
 * (Re)Association response frame format:
 * [2]   Capability information
 * [2]   Status code
 * [2]   Association ID (AID)
 * [tlv] Supported rates
 * [tlv] Extended Supported Rates (802.11g)
 * [tlv] EDCA Parameter Set (802.11e)
 * [tlv] HT Capabilities (802.11n)
 * [tlv] HT Operation (802.11n)
 */
void
ieee80211_recv_assoc_resp(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, int reassoc)
{
	struct ifnet *ifp = &ic->ic_if;
	const struct ieee80211_frame *wh;
	const u_int8_t *frm, *efrm;
	const u_int8_t *rates, *xrates, *edcaie, *wmmie, *htcaps, *htop;
	u_int16_t capinfo, status, associd;
	u_int8_t rate;

	if (ic->ic_opmode != IEEE80211_M_STA ||
	    ic->ic_state != IEEE80211_S_ASSOC) {
		ic->ic_stats.is_rx_mgtdiscard++;
		return;
	}

	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + 6) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m, u_int8_t *) + m->m_len;

	capinfo = LE_READ_2(frm); frm += 2;
	status =  LE_READ_2(frm); frm += 2;
	if (status != IEEE80211_STATUS_SUCCESS) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: %sassociation failed (status %d)"
			    " for %s\n", ifp->if_xname,
			    reassoc ?  "re" : "",
			    status, ether_sprintf((u_int8_t *)wh->i_addr3));
		if (ni != ic->ic_bss)
			ni->ni_fails++;
		ic->ic_stats.is_rx_auth_fail++;
		return;
	}
	associd = LE_READ_2(frm); frm += 2;

	rates = xrates = edcaie = wmmie = htcaps = htop = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm) {
			ic->ic_stats.is_rx_elem_toosmall++;
			break;
		}
		switch (frm[0]) {
		case IEEE80211_ELEMID_RATES:
			rates = frm;
			break;
		case IEEE80211_ELEMID_XRATES:
			xrates = frm;
			break;
		case IEEE80211_ELEMID_EDCAPARMS:
			edcaie = frm;
			break;
		case IEEE80211_ELEMID_HTCAPS:
			htcaps = frm;
			break;
		case IEEE80211_ELEMID_HTOP:
			htop = frm;
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			if (memcmp(frm + 2, MICROSOFT_OUI, 3) == 0) {
				if (frm[1] >= 5 && frm[5] == 2 && frm[6] == 1)
					wmmie = frm;
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* supported rates element is mandatory */
	if (rates == NULL || rates[1] > IEEE80211_RATE_MAXSIZE) {
		DPRINTF(("invalid supported rates element\n"));
		return;
	}
	rate = ieee80211_setup_rates(ic, ni, rates, xrates,
	    IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE | IEEE80211_F_DONEGO |
	    IEEE80211_F_DODEL);
	if (rate & IEEE80211_RATE_BASIC) {
		DPRINTF(("rate mismatch for %s\n",
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
		ic->ic_stats.is_rx_assoc_norate++;
		return;
	}
	ni->ni_capinfo = capinfo;
	ni->ni_associd = associd;
	if (edcaie != NULL || wmmie != NULL) {
		/* force update of EDCA parameters */
		ic->ic_edca_updtcount = -1;

		if ((edcaie != NULL &&
		     ieee80211_parse_edca_params(ic, edcaie) == 0) ||
		    (wmmie != NULL &&
		     ieee80211_parse_wmm_params(ic, wmmie) == 0))
			ni->ni_flags |= IEEE80211_NODE_QOS;
		else	/* for Reassociation */
			ni->ni_flags &= ~IEEE80211_NODE_QOS;
	}
	if (htcaps)
		ieee80211_setup_htcaps(ni, htcaps + 2, htcaps[1]);
	if (htop)
		ieee80211_setup_htop(ni, htop + 2, htop[1]);
	ieee80211_ht_negotiate(ic, ni);

	/* Hop into 11n mode after associating to an HT AP in a non-11n mode. */
	if (ni->ni_flags & IEEE80211_NODE_HT)
		ieee80211_setmode(ic, IEEE80211_MODE_11N);
	else
		ieee80211_setmode(ic, ieee80211_chan2mode(ic, ni->ni_chan));
	/*
	 * Reset the erp state (mostly the slot time) now that
	 * our operating mode has been nailed down.
	 */
	ieee80211_reset_erp(ic);

	/*
	 * Configure state now that we are associated.
	 */
	if (ic->ic_curmode == IEEE80211_MODE_11A ||
	    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE))
		ic->ic_flags |= IEEE80211_F_SHPREAMBLE;
	else
		ic->ic_flags &= ~IEEE80211_F_SHPREAMBLE;

	ieee80211_set_shortslottime(ic,
	    ic->ic_curmode == IEEE80211_MODE_11A ||
	    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME));
	/*
	 * Honor ERP protection.
	 */
	if ((ic->ic_curmode == IEEE80211_MODE_11G ||
	    (ic->ic_curmode == IEEE80211_MODE_11N &&
	    IEEE80211_IS_CHAN_2GHZ(ni->ni_chan))) &&
	    (ni->ni_erp & IEEE80211_ERP_USE_PROTECTION))
		ic->ic_flags |= IEEE80211_F_USEPROT;
	else
		ic->ic_flags &= ~IEEE80211_F_USEPROT;
	/*
	 * If not an RSNA, mark the port as valid, otherwise wait for
	 * 802.1X authentication and 4-way handshake to complete..
	 */
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		/* XXX ic->ic_mgt_timer = 5; */
		ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
	} else if (ic->ic_flags & IEEE80211_F_WEPON)
		ni->ni_flags |= IEEE80211_NODE_TXRXPROT;

	ieee80211_new_state(ic, IEEE80211_S_RUN,
	    IEEE80211_FC0_SUBTYPE_ASSOC_RESP);
}

/*-
 * Deauthentication frame format:
 * [2] Reason code
 */
void
ieee80211_recv_deauth(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	u_int16_t reason;

	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + 2) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	reason = LE_READ_2(frm);

	ic->ic_stats.is_rx_deauth++;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		ieee80211_new_state(ic, IEEE80211_S_AUTH,
		    IEEE80211_FC0_SUBTYPE_DEAUTH);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_HOSTAP:
		if (ni != ic->ic_bss) {
			if (ic->ic_if.if_flags & IFF_DEBUG)
				printf("%s: station %s deauthenticated "
				    "by peer (reason %d)\n",
				    ic->ic_if.if_xname,
				    ether_sprintf(ni->ni_macaddr),
				    reason);
			ieee80211_node_leave(ic, ni);
		}
		break;
#endif
	default:
		break;
	}
}

/*-
 * Disassociation frame format:
 * [2] Reason code
 */
void
ieee80211_recv_disassoc(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	u_int16_t reason;

	/* make sure all mandatory fixed fields are present */
	if (m->m_len < sizeof(*wh) + 2) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	reason = LE_READ_2(frm);

	ic->ic_stats.is_rx_disassoc++;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		ieee80211_new_state(ic, IEEE80211_S_ASSOC,
		    IEEE80211_FC0_SUBTYPE_DISASSOC);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_HOSTAP:
		if (ni != ic->ic_bss) {
			if (ic->ic_if.if_flags & IFF_DEBUG)
				printf("%s: station %s disassociated "
				    "by peer (reason %d)\n",
				    ic->ic_if.if_xname,
				    ether_sprintf(ni->ni_macaddr),
				    reason);
			ieee80211_node_leave(ic, ni);
		}
		break;
#endif
	default:
		break;
	}
}

/*-
 * ADDBA Request frame format:
 * [1] Category
 * [1] Action
 * [1] Dialog Token
 * [2] Block Ack Parameter Set
 * [2] Block Ack Timeout Value
 * [2] Block Ack Starting Sequence Control
 */
void
ieee80211_recv_addba_req(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	struct ieee80211_rx_ba *ba;
	u_int16_t params, ssn, bufsz, timeout;
	u_int8_t token, tid;
	int err = 0;

	if (!(ni->ni_flags & IEEE80211_NODE_HT)) {
		DPRINTF(("received ADDBA req from non-HT STA %s\n",
		    ether_sprintf(ni->ni_macaddr)));
		return;
	}
	if (m->m_len < sizeof(*wh) + 9) {
		DPRINTF(("frame too short\n"));
		return;
	}
	/* MLME-ADDBA.indication */
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	token = frm[2];
	params = LE_READ_2(&frm[3]);
	tid = ((params & IEEE80211_ADDBA_TID_MASK) >>
	    IEEE80211_ADDBA_TID_SHIFT);
	bufsz = (params & IEEE80211_ADDBA_BUFSZ_MASK) >>
	    IEEE80211_ADDBA_BUFSZ_SHIFT;
	timeout = LE_READ_2(&frm[5]);
	ssn = LE_READ_2(&frm[7]) >> 4;

	ba = &ni->ni_rx_ba[tid];
	/* check if we already have a Block Ack agreement for this RA/TID */
	if (ba->ba_state == IEEE80211_BA_AGREED) {
		/* XXX should we update the timeout value? */
		/* reset Block Ack inactivity timer */
		if (ba->ba_timeout_val != 0)
			timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);

		/* check if it's a Protected Block Ack agreement */
		if (!(ni->ni_flags & IEEE80211_NODE_MFP) ||
		    !(ni->ni_rsncaps & IEEE80211_RSNCAP_PBAC))
			return;	/* not a PBAC, ignore */

		/* PBAC: treat the ADDBA Request like a BlockAckReq */
		if (SEQ_LT(ba->ba_winstart, ssn))
			ieee80211_ba_move_window(ic, ni, tid, ssn);
		return;
	}

	/* if PBAC required but RA does not support it, refuse request */
	if ((ic->ic_flags & IEEE80211_F_PBAR) &&
	    (!(ni->ni_flags & IEEE80211_NODE_MFP) ||
	     !(ni->ni_rsncaps & IEEE80211_RSNCAP_PBAC)))
		goto refuse;
	/*
	 * If the TID for which the Block Ack agreement is requested is
	 * configured with a no-ACK policy, refuse the agreement.
	 */
	if (ic->ic_tid_noack & (1 << tid))
		goto refuse;

	/* check that we support the requested Block Ack Policy */
	if (!(ic->ic_htcaps & IEEE80211_HTCAP_DELAYEDBA) &&
	    !(params & IEEE80211_ADDBA_BA_POLICY))
		goto refuse;

	/* setup Block Ack agreement */
	ba->ba_state = IEEE80211_BA_INIT;
	ba->ba_timeout_val = timeout * IEEE80211_DUR_TU;
	ba->ba_ni = ni;
	ba->ba_token = token;
	timeout_set(&ba->ba_to, ieee80211_rx_ba_timeout, ba);
	timeout_set(&ba->ba_gap_to, ieee80211_input_ba_gap_timeout, ba);
	ba->ba_winsize = bufsz;
	if (ba->ba_winsize == 0 || ba->ba_winsize > IEEE80211_BA_MAX_WINSZ)
		ba->ba_winsize = IEEE80211_BA_MAX_WINSZ;
	ba->ba_params = (params & IEEE80211_ADDBA_BA_POLICY);
	ba->ba_params |= ((ba->ba_winsize << IEEE80211_ADDBA_BUFSZ_SHIFT) |
	    (tid << IEEE80211_ADDBA_TID_SHIFT) | IEEE80211_ADDBA_AMSDU);
	ba->ba_winstart = ssn;
	ba->ba_winend = (ba->ba_winstart + ba->ba_winsize - 1) & 0xfff;
	/* allocate and setup our reordering buffer */
	ba->ba_buf = malloc(IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf),
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ba->ba_buf == NULL)
		goto refuse;

	ba->ba_head = 0;

	/* notify drivers of this new Block Ack agreement */
	if (ic->ic_ampdu_rx_start != NULL)
		err = ic->ic_ampdu_rx_start(ic, ni, tid);
	if (err == EBUSY) {
		/* driver will accept or refuse agreement when done */
		return;
	} else if (err) {
		/* driver failed to setup, rollback */
		ieee80211_addba_req_refuse(ic, ni, tid);
	} else
		ieee80211_addba_req_accept(ic, ni, tid);
	return;

 refuse:
	/* MLME-ADDBA.response */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
	    IEEE80211_ACTION_ADDBA_RESP,
	    IEEE80211_STATUS_REFUSED << 16 | token << 8 | tid);
}

void
ieee80211_addba_req_accept(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];

	ba->ba_state = IEEE80211_BA_AGREED;
	ic->ic_stats.is_ht_rx_ba_agreements++;
	/* start Block Ack inactivity timer */
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);

	/* MLME-ADDBA.response */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
	    IEEE80211_ACTION_ADDBA_RESP,
	    IEEE80211_STATUS_SUCCESS << 16 | ba->ba_token << 8 | tid);
}

void
ieee80211_addba_req_refuse(struct ieee80211com *ic, struct ieee80211_node *ni,
    uint8_t tid)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];

	free(ba->ba_buf, M_DEVBUF,
	    IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf));
	ba->ba_buf = NULL;

	/* MLME-ADDBA.response */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
	    IEEE80211_ACTION_ADDBA_RESP,
	    IEEE80211_STATUS_REFUSED << 16 | ba->ba_token << 8 | tid);
}

/*-
 * ADDBA Response frame format:
 * [1] Category
 * [1] Action
 * [1] Dialog Token
 * [2] Status Code
 * [2] Block Ack Parameter Set
 * [2] Block Ack Timeout Value
 */
void
ieee80211_recv_addba_resp(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	struct ieee80211_tx_ba *ba;
	u_int16_t status, params, bufsz, timeout;
	u_int8_t token, tid;

	if (m->m_len < sizeof(*wh) + 9) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	token = frm[2];
	status = LE_READ_2(&frm[3]);
	params = LE_READ_2(&frm[5]);
	tid = (params >> 2) & 0xf;
	bufsz = (params >> 6) & 0x3ff;
	timeout = LE_READ_2(&frm[7]);

	DPRINTF(("received ADDBA resp from %s, TID %d, status %d\n",
	    ether_sprintf(ni->ni_macaddr), tid, status));

	/*
	 * Ignore if no ADDBA request has been sent for this RA/TID or
	 * if we already have a Block Ack agreement.
	 */
	ba = &ni->ni_tx_ba[tid];
	if (ba->ba_state != IEEE80211_BA_REQUESTED) {
		DPRINTF(("no matching ADDBA req found\n"));
		return;
	}
	if (token != ba->ba_token) {
		DPRINTF(("ignoring ADDBA resp from %s: token %x!=%x\n",
		    ether_sprintf(ni->ni_macaddr), token, ba->ba_token));
		return;
	}
	/* we got an ADDBA Response matching our request, stop timeout */
	timeout_del(&ba->ba_to);

	if (status != IEEE80211_STATUS_SUCCESS) {
		/* MLME-ADDBA.confirm(Failure) */
		ba->ba_state = IEEE80211_BA_INIT;
		return;
	}
	/* MLME-ADDBA.confirm(Success) */
	ba->ba_state = IEEE80211_BA_AGREED;
	ic->ic_stats.is_ht_tx_ba_agreements++;

	/* notify drivers of this new Block Ack agreement */
	if (ic->ic_ampdu_tx_start != NULL)
		(void)ic->ic_ampdu_tx_start(ic, ni, tid);

	/* start Block Ack inactivity timeout */
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
}

/*-
 * DELBA frame format:
 * [1] Category
 * [1] Action
 * [2] DELBA Parameter Set
 * [2] Reason Code
 */
void
ieee80211_recv_delba(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;
	u_int16_t params, reason;
	u_int8_t tid;
	int i;

	if (m->m_len < sizeof(*wh) + 6) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	params = LE_READ_2(&frm[2]);
	reason = LE_READ_2(&frm[4]);
	tid = params >> 12;

	DPRINTF(("received DELBA from %s, TID %d, reason %d\n",
	    ether_sprintf(ni->ni_macaddr), tid, reason));

	if (params & IEEE80211_DELBA_INITIATOR) {
		/* MLME-DELBA.indication(Originator) */
		struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];

		if (ba->ba_state != IEEE80211_BA_AGREED) {
			DPRINTF(("no matching Block Ack agreement\n"));
			return;
		}
		/* notify drivers of the end of the Block Ack agreement */
		if (ic->ic_ampdu_rx_stop != NULL)
			ic->ic_ampdu_rx_stop(ic, ni, tid);

		ba->ba_state = IEEE80211_BA_INIT;
		/* stop Block Ack inactivity timer */
		timeout_del(&ba->ba_to);
		timeout_del(&ba->ba_gap_to);

		if (ba->ba_buf != NULL) {
			/* free all MSDUs stored in reordering buffer */
			for (i = 0; i < IEEE80211_BA_MAX_WINSZ; i++)
				m_freem(ba->ba_buf[i].m);
			/* free reordering buffer */
			free(ba->ba_buf, M_DEVBUF,
			    IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf));
			ba->ba_buf = NULL;
		}
	} else {
		/* MLME-DELBA.indication(Recipient) */
		struct ieee80211_tx_ba *ba = &ni->ni_tx_ba[tid];

		if (ba->ba_state != IEEE80211_BA_AGREED) {
			DPRINTF(("no matching Block Ack agreement\n"));
			return;
		}
		/* notify drivers of the end of the Block Ack agreement */
		if (ic->ic_ampdu_tx_stop != NULL)
			ic->ic_ampdu_tx_stop(ic, ni, tid);

		ba->ba_state = IEEE80211_BA_INIT;
		/* stop Block Ack inactivity timer */
		timeout_del(&ba->ba_to);
	}
}

/*-
 * SA Query Request frame format:
 * [1] Category
 * [1] Action
 * [2] Transaction Identifier
 */
void
ieee80211_recv_sa_query_req(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;

	if (ic->ic_opmode != IEEE80211_M_STA ||
	    !(ni->ni_flags & IEEE80211_NODE_MFP)) {
		DPRINTF(("unexpected SA Query req from %s\n",
		    ether_sprintf(ni->ni_macaddr)));
		return;
	}
	if (m->m_len < sizeof(*wh) + 4) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	/* MLME-SAQuery.indication */

	/* save Transaction Identifier for SA Query Response */
	ni->ni_sa_query_trid = LE_READ_2(&frm[2]);

	/* MLME-SAQuery.response */
	IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_SA_QUERY,
	    IEEE80211_ACTION_SA_QUERY_RESP, 0);
}

#ifndef IEEE80211_STA_ONLY
/*-
 * SA Query Response frame format:
 * [1] Category
 * [1] Action
 * [2] Transaction Identifier
 */
void
ieee80211_recv_sa_query_resp(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;

	/* ignore if we're not engaged in an SA Query with that STA */
	if (!(ni->ni_flags & IEEE80211_NODE_SA_QUERY)) {
		DPRINTF(("unexpected SA Query resp from %s\n",
		    ether_sprintf(ni->ni_macaddr)));
		return;
	}
	if (m->m_len < sizeof(*wh) + 4) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	/* check that Transaction Identifier matches */
	if (ni->ni_sa_query_trid != LE_READ_2(&frm[2])) {
		DPRINTF(("transaction identifier does not match\n"));
		return;
	}
	/* MLME-SAQuery.confirm */
	timeout_del(&ni->ni_sa_query_to);
	ni->ni_flags &= ~IEEE80211_NODE_SA_QUERY;
}
#endif

/*-
 * Action frame format:
 * [1] Category
 * [1] Action
 */
void
ieee80211_recv_action(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame *wh;
	const u_int8_t *frm;

	if (m->m_len < sizeof(*wh) + 2) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];

	switch (frm[0]) {
	case IEEE80211_CATEG_BA:
		switch (frm[1]) {
		case IEEE80211_ACTION_ADDBA_REQ:
			ieee80211_recv_addba_req(ic, m, ni);
			break;
		case IEEE80211_ACTION_ADDBA_RESP:
			ieee80211_recv_addba_resp(ic, m, ni);
			break;
		case IEEE80211_ACTION_DELBA:
			ieee80211_recv_delba(ic, m, ni);
			break;
		}
		break;
	case IEEE80211_CATEG_SA_QUERY:
		switch (frm[1]) {
		case IEEE80211_ACTION_SA_QUERY_REQ:
			ieee80211_recv_sa_query_req(ic, m, ni);
			break;
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_ACTION_SA_QUERY_RESP:
			ieee80211_recv_sa_query_resp(ic, m, ni);
			break;
#endif
		}
		break;
	default:
		DPRINTF(("action frame category %d not handled\n", frm[0]));
		break;
	}
}

void
ieee80211_recv_mgmt(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int subtype)
{
	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_BEACON:
		ieee80211_recv_probe_resp(ic, m, ni, rxi, 0);
		break;
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
		ieee80211_recv_probe_resp(ic, m, ni, rxi, 1);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		ieee80211_recv_probe_req(ic, m, ni, rxi);
		break;
#endif
	case IEEE80211_FC0_SUBTYPE_AUTH:
		ieee80211_recv_auth(ic, m, ni, rxi);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
		ieee80211_recv_assoc_req(ic, m, ni, rxi, 0);
		break;
	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ:
		ieee80211_recv_assoc_req(ic, m, ni, rxi, 1);
		break;
#endif
	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
		ieee80211_recv_assoc_resp(ic, m, ni, 0);
		break;
	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP:
		ieee80211_recv_assoc_resp(ic, m, ni, 1);
		break;
	case IEEE80211_FC0_SUBTYPE_DEAUTH:
		ieee80211_recv_deauth(ic, m, ni);
		break;
	case IEEE80211_FC0_SUBTYPE_DISASSOC:
		ieee80211_recv_disassoc(ic, m, ni);
		break;
	case IEEE80211_FC0_SUBTYPE_ACTION:
		ieee80211_recv_action(ic, m, ni);
		break;
	default:
		DPRINTF(("mgmt frame with subtype 0x%x not handled\n",
		    subtype));
		ic->ic_stats.is_rx_badsubtype++;
		break;
	}
}

#ifndef IEEE80211_STA_ONLY
/*
 * Process an incoming PS-Poll control frame (see 11.2).
 */
void
ieee80211_recv_pspoll(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame_pspoll *psp;
	struct ieee80211_frame *wh;
	u_int16_t aid;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP ||
	    !(ic->ic_caps & IEEE80211_C_APPMGT) ||
	    ni->ni_state != IEEE80211_STA_ASSOC)
		return;

	if (m->m_len < sizeof(*psp)) {
		DPRINTF(("frame too short, len %u\n", m->m_len));
		ic->ic_stats.is_rx_tooshort++;
		return;
	}
	psp = mtod(m, struct ieee80211_frame_pspoll *);
	if (!IEEE80211_ADDR_EQ(psp->i_bssid, ic->ic_bss->ni_bssid)) {
		DPRINTF(("discard pspoll frame to BSS %s\n",
		    ether_sprintf(psp->i_bssid)));
		ic->ic_stats.is_rx_wrongbss++;
		return;
	}
	aid = letoh16(*(u_int16_t *)psp->i_aid);
	if (aid != ni->ni_associd) {
		DPRINTF(("invalid pspoll aid %x from %s\n", aid,
		    ether_sprintf(psp->i_ta)));
		return;
	}

	/* take the first queued frame and put it out.. */
	m = mq_dequeue(&ni->ni_savedq);
	if (m == NULL)
		return;
	if (mq_empty(&ni->ni_savedq)) {
		/* last queued frame, turn off the TIM bit */
		(*ic->ic_set_tim)(ic, ni->ni_associd, 0);
	} else {
		/* more queued frames, set the more data bit */
		wh = mtod(m, struct ieee80211_frame *);
		wh->i_fc[1] |= IEEE80211_FC1_MORE_DATA;
	}
	mq_enqueue(&ic->ic_pwrsaveq, m);
	if_start(ifp);
}
#endif	/* IEEE80211_STA_ONLY */

/*
 * Process an incoming BlockAckReq control frame (see 7.2.1.7).
 */
void
ieee80211_recv_bar(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni)
{
	const struct ieee80211_frame_min *wh;
	const u_int8_t *frm;
	u_int16_t ctl, ssn;
	u_int8_t tid, ntids;

	if (!(ni->ni_flags & IEEE80211_NODE_HT)) {
		DPRINTF(("received BlockAckReq from non-HT STA %s\n",
		    ether_sprintf(ni->ni_macaddr)));
		return;
	}
	if (m->m_len < sizeof(*wh) + 4) {
		DPRINTF(("frame too short\n"));
		return;
	}
	wh = mtod(m, struct ieee80211_frame_min *);
	frm = (const u_int8_t *)&wh[1];

	/* read BlockAckReq Control field */
	ctl = LE_READ_2(&frm[0]);
	tid = ctl >> 12;

	/* determine BlockAckReq frame variant */
	if (ctl & IEEE80211_BA_MULTI_TID) {
		/* Multi-TID BlockAckReq variant (PSMP only) */
		ntids = tid + 1;

		if (m->m_len < sizeof(*wh) + 2 + 4 * ntids) {
			DPRINTF(("MTBAR frame too short\n"));
			return;
		}
		frm += 2;	/* skip BlockAckReq Control field */
		while (ntids-- > 0) {
			/* read MTBAR Information field */
			tid = LE_READ_2(&frm[0]) >> 12;
			ssn = LE_READ_2(&frm[2]) >> 4;
			ieee80211_bar_tid(ic, ni, tid, ssn);
			frm += 4;
		}
	} else {
		/* Basic or Compressed BlockAckReq variants */
		ssn = LE_READ_2(&frm[2]) >> 4;
		ieee80211_bar_tid(ic, ni, tid, ssn);
	}
}

/*
 * Process a BlockAckReq for a specific TID (see 9.10.7.6.3).
 * This is the common back-end for all BlockAckReq frame variants.
 */
void
ieee80211_bar_tid(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int8_t tid, u_int16_t ssn)
{
	struct ieee80211_rx_ba *ba = &ni->ni_rx_ba[tid];

	/* check if we have a Block Ack agreement for RA/TID */
	if (ba->ba_state != IEEE80211_BA_AGREED) {
		/* XXX not sure in PBAC case */
		/* send a DELBA with reason code UNKNOWN-BA */
		IEEE80211_SEND_ACTION(ic, ni, IEEE80211_CATEG_BA,
		    IEEE80211_ACTION_DELBA,
		    IEEE80211_REASON_SETUP_REQUIRED << 16 | tid);
		return;
	}
	/* check if it is a Protected Block Ack agreement */
	if ((ni->ni_flags & IEEE80211_NODE_MFP) &&
	    (ni->ni_rsncaps & IEEE80211_RSNCAP_PBAC)) {
		/* ADDBA Requests must be used in PBAC case */
		if (SEQ_LT(ssn, ba->ba_winstart) ||
		    SEQ_LT(ba->ba_winend, ssn))
			ic->ic_stats.is_pbac_errs++;
		return;	/* PBAC, do not move window */
	}
	/* reset Block Ack inactivity timer */
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);

	if (SEQ_LT(ba->ba_winstart, ssn))
		ieee80211_ba_move_window(ic, ni, tid, ssn);
}
@


1.195
log
@Remove ieee80211_input_print() which printed information about received
frames to dmesg, if debug mode was enabled with ifconfig.
This debug output was much too verbose and not actually useful for debugging.
tcpdump -y IEEE802_11_RADIO will show the same information.
ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.194 2017/06/04 12:48:42 tb Exp $	*/
d1585 8
@


1.194
log
@Add sizes for free for the RSN IEs. Rewrite ieee80211_save_ie() slightly
to make it more readable.

help, many explanations and ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.193 2017/06/03 15:44:03 tb Exp $	*/
a127 8
void	ieee80211_input_print(struct ieee80211com *,  struct ifnet *,
	    struct ieee80211_frame *, struct ieee80211_rxinfo *);
void	ieee80211_input_print_task(void *);

struct ieee80211printmsg {
	struct task	task;
	char		text[512];
};
a148 59
/* 
 * Work queue task that prints a received frame.  Avoids printf() from
 * interrupt context at IPL_NET making slow machines unusable when many
 * frames are received and the interface is put in debug mode.
 */
void
ieee80211_input_print_task(void *arg1)
{
	struct ieee80211printmsg *msg = arg1;

	printf("%s", msg->text);
	free(msg, M_DEVBUF, sizeof *msg);
}

void
ieee80211_input_print(struct ieee80211com *ic,  struct ifnet *ifp,
    struct ieee80211_frame *wh, struct ieee80211_rxinfo *rxi)
{
	int doprint;
	struct ieee80211printmsg *msg;
	u_int8_t subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	/* avoid printing too many frames */
	doprint = 0;
	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_BEACON:
		if (ic->ic_state == IEEE80211_S_SCAN)
			doprint = 1;
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		if (ic->ic_opmode == IEEE80211_M_IBSS)
			doprint = 1;
		break;
#endif
	default:
		doprint = 1;
		break;
	}
#ifdef IEEE80211_DEBUG
	doprint += (ieee80211_debug > 1);
#endif
	if (!doprint)
		return;

	msg = malloc(sizeof(*msg), M_DEVBUF, M_NOWAIT);
	if (msg == NULL)
		return;

	snprintf(msg->text, sizeof(msg->text),
	    "%s: received %s from %s rssi %d mode %s\n", ifp->if_xname,
	    ieee80211_mgt_subtype_name[subtype >> IEEE80211_FC0_SUBTYPE_SHIFT],
	    ether_sprintf(wh->i_addr2), rxi->rxi_rssi,
	    ieee80211_phymode_name[ic->ic_curmode]);

	task_set(&msg->task, ieee80211_input_print_task, msg);
	task_add(systq, &msg->task);
}

a478 2
		if (ifp->if_flags & IFF_DEBUG)
			ieee80211_input_print(ic, ifp, wh, rxi);
@


1.193
log
@Add a few sizes to free().

Input, help & ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.192 2017/05/02 11:03:48 stsp Exp $	*/
d1365 4
a1368 1
	if (*ie == NULL || (*ie)[1] != frm[1]) {
d1370 2
a1371 2
			free(*ie, M_DEVBUF, 0);
		*ie = malloc(2 + frm[1], M_DEVBUF, M_NOWAIT);
d1375 1
a1375 1
	memcpy(*ie, frm, 2 + frm[1]);
@


1.192
log
@Fix a problem with associating to wifi networks with a hidden SSID.

If an AP is configured to hide its SSID it sends a non-zero length SSID
which contains only zeroes. The AP sends its actual SSID only in probe
responses after a client includes this SSID in a probe request.
If we happened to receive a beacon before the probe response we stored a
non-zero-length SSID of zeroes and never updated the SSID when the probe
response arrived. The client was then unable to find the AP.

test & ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.191 2017/04/11 14:43:49 dhill Exp $	*/
d168 1
a168 1
	free(msg, M_DEVBUF, 0);
d2635 2
a2636 1
	free(ba->ba_buf, M_DEVBUF, 0);
d2769 2
a2770 1
			free(ba->ba_buf, M_DEVBUF, 0);
@


1.191
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.190 2017/04/09 18:15:32 dhill Exp $	*/
d1552 16
a1567 2
	if ((ni = ieee80211_find_node_for_beacon(ic, wh->i_addr2,
	    &ic->ic_channels[chan], ssid, rxi->rxi_rssi)) != NULL)
d1569 1
d1729 1
a1729 1
	if (ssid[1] != 0 && ni->ni_esslen == 0) {
@


1.190
log
@Convert a malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.189 2017/03/13 07:44:10 stsp Exp $	*/
d2569 1
a2569 1
	ba->ba_buf = mallocarray(IEEE80211_BA_MAX_WINSZ, sizeof(*ba->ba_buf),
@


1.189
log
@Make 'ifconfig scan' show WPA information for other APs correctly while
the interface operates in hostap mode.
test & ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.188 2017/03/12 03:13:50 stsp Exp $	*/
d2569 1
a2569 1
	ba->ba_buf = malloc(IEEE80211_BA_MAX_WINSZ * sizeof(*ba->ba_buf),
@


1.188
log
@Introduce separate fields for supported WPA protocols and AKMs in struct
ieee80211_node. Pass these fields to 'ifconfig scan' instead of giving it
currently configured/enabled settings.
Fixes display of AP WPA capabilities in 'ifconfig scan' while the wifi
interface is not configured to use WPA (my previous commit attempted to
fix the same problem but didn't make it work in all cases).
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.187 2017/03/01 19:28:48 stsp Exp $	*/
d1652 1
a1652 5
	if (ic->ic_state == IEEE80211_S_SCAN
#ifndef IEEE80211_STA_ONLY
	    && ic->ic_opmode != IEEE80211_M_HOSTAP
#endif
	   ) {
d1682 5
a1686 1
			if (ieee80211_save_ie(rsnie, &ni->ni_rsnie) == 0) {
d1698 5
a1702 1
			if (ieee80211_save_ie(wpaie, &ni->ni_rsnie) == 0) {
d1912 1
d2057 13
a2069 9
	if (ic->ic_flags & IEEE80211_F_RSNON) {
		const u_int8_t *saveie;
		/*
		 * A station should never include both a WPA and an RSN IE
		 * in its (Re)Association Requests, but if it does, we only
		 * consider the IE of the highest version of the protocol
		 * that is allowed (ie RSN over WPA).
		 */
		if (rsnie != NULL &&
a2070 3
			status = ieee80211_parse_rsn(ic, rsnie, &rsn);
			if (status != 0)
				goto end;
a2071 1
			ni->ni_supported_rsnprotos = IEEE80211_PROTO_RSN;
d2073 8
a2080 1
		} else if (wpaie != NULL &&
a2081 3
			status = ieee80211_parse_wpa(ic, wpaie, &rsn);
			if (status != 0)
				goto end;
a2082 1
			ni->ni_supported_rsnprotos = IEEE80211_PROTO_WPA;
d2084 5
a2088 1
		} else {
d2106 1
d2112 1
d2117 1
d2124 1
d2132 1
d2145 1
d2157 1
d2162 2
a2163 1
		if (ieee80211_save_ie(saveie, &ni->ni_rsnie) != 0) {
d2165 1
a2168 1
		ni->ni_supported_rsnakms = rsn.rsn_akms;
@


1.187
log
@Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.186 2017/02/02 16:47:53 stsp Exp $	*/
d1657 22
a1678 2
		struct ieee80211_rsnparams rsn;
		const u_int8_t *saveie = NULL;
d1680 2
a1681 3
		 * If the AP advertises both RSN and WPA IEs (WPA1+WPA2),
		 * we only store the parameters of the highest protocol
		 * version we support.
d1684 1
d1686 1
a1686 1
			if (ieee80211_parse_rsn(ic, rsnie, &rsn) == 0) {
d1688 6
a1693 1
				saveie = rsnie;
d1696 1
d1698 1
a1698 1
			if (ieee80211_parse_wpa(ic, wpaie, &rsn) == 0) {
d1700 6
a1705 1
				saveie = wpaie;
a1707 9
		if (saveie != NULL &&
		    ieee80211_save_ie(saveie, &ni->ni_rsnie) == 0) {
			ni->ni_rsnakms = rsn.rsn_akms;
			ni->ni_rsnciphers = rsn.rsn_ciphers;
			ni->ni_rsngroupcipher = rsn.rsn_groupcipher;
			ni->ni_rsngroupmgmtcipher = rsn.rsn_groupmgmtcipher;
			ni->ni_rsncaps = rsn.rsn_caps;
		} else
			ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
d2043 9
d2066 1
d2074 1
d2148 1
d2175 1
a2175 2
	} else
		ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
@


1.186
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.185 2017/01/25 09:23:08 stsp Exp $	*/
d2322 1
@


1.185
log
@In amsdu_decap() check the actual length of the data in the remaining mbuf
chain. Else this function will sometimes signal end of AMSDU frame too early.
Patch by Imre Vadasz.
ok mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.184 2017/01/16 09:35:06 stsp Exp $	*/
d347 2
a348 3
				ic->ic_pssta++;
				DPRINTF(("PS mode on for %s, count %d\n",
				    ether_sprintf(wh->i_addr2), ic->ic_pssta));
d355 2
a356 3
			ic->ic_pssta--;
			DPRINTF(("PS mode off for %s, count %d\n",
			    ether_sprintf(wh->i_addr2), ic->ic_pssta));
@


1.184
log
@Prevent wireless frame injection attack described at 33C3 in the talk
titled "Predicting and Abusing WPA2/802.11 Group Keys" by Mathy Vanhoef.
https://media.ccc.de/v/33c3-8195-predicting_and_abusing_wpa2_802_11_group_keys

If an attacker knows the WPA group key the attacker could inject a unicast
frame by sending a group-encrypted frame to the AP with addresses set as:
addr1 (receiver): ff:ff:ff:ff:ff:ff
addr2 (source): MAC of attacker
addr3 (target): MAC of victim client

The AP would forward this frame as unicast, re-encrypted with the pair-wise
session key of the victim client. But an AP should not forward such frames.

Guessing a WPA group key used by an OpenBSD AP is hard because our random
numbers are actually random. So we are not vulnerable to this attack but
we are fixing the forwarding path anyway.

ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.183 2017/01/10 08:19:49 stsp Exp $	*/
d1099 1
a1099 1
		if (n->m_len == 0) {
@


1.183
log
@Make receiving A-MPDUs with an 11n-enabled athn(4) driver work by not
requiring 11n wireless drivers to provide an ic_ampdu_rx_start() function.
The athn(4) driver won't need this function since the hardware receives
A-MPDU and sends block ack without setting up anything.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.182 2017/01/09 20:18:59 stsp Exp $	*/
d78 1
a78 1
	    struct ieee80211_node *);
d895 1
a895 1
    struct ieee80211_node *ni)
d915 1
d930 1
a930 1
		} else {
d972 1
d980 1
d1023 1
a1023 1
	ieee80211_deliver_data(ic, m, ni);
d1036 5
a1040 1
	int len, pad;
d1097 1
a1097 1
		ieee80211_deliver_data(ic, m, ni);
@


1.182
log
@When a HT node leaves or reassociates as a non-HT node,
clear HT capabilities stored in its node cache object.

A node may switch from 11n mode to 11a/b/g mode.
If we don't clear HT capabilities from the cache the node will
be mistaken as 11n-capable after reassociation.

ok phessler@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.181 2017/01/09 12:40:00 stsp Exp $	*/
d2434 1
a2434 1
	int err;
a2476 4
	/* If the driver does not support A-MPDU, refuse the request. */
	if (ic->ic_ampdu_rx_start == NULL)
		goto refuse;

d2518 2
a2519 1
	err = ic->ic_ampdu_rx_start(ic, ni, tid);
@


1.181
log
@Manage the HT protection setting if acting as hostap with 11n enabled.

For now we flip-flop only between non-member protection and non-HT protection.
Running a HT network without protection would require monitoring environmental
conditions (e.g. foreign beacons) which make HT protection necessary.

The ic_update_htprot driver function becomes optional because it won't be
needed by all drivers. Only call it if the driver has set a function pointer.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.180 2016/09/21 12:21:27 stsp Exp $	*/
d1805 2
d2146 2
@


1.180
log
@When processing an ADDBA request, iwm(4) runs a task which sends a
command to the firmware and waits for confirmation. This command can
fail and there was no way we could recover from such an error.

Allow drivers to return EBUSY from their ic_ampdu_rx_start() handler to
tell the stack not to send a confirmation just yet. The stack provides
functions which the driver can call to accept or refuse the request.

There is no functional change yet. This just shuffles code around so
drivers may insert themselves into the process.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.179 2016/09/20 13:24:42 stsp Exp $	*/
d1615 2
a1616 1
				ic->ic_update_htprot(ic, ic->ic_bss);
@


1.179
log
@Parse the DTIM count and period advertised in beacons and store them
in the node structure. This should be useful for iwm(4) in the future.
ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.178 2016/05/18 08:15:28 stsp Exp $	*/
d2427 1
a2427 1
	u_int16_t params, ssn, bufsz, timeout, status;
d2429 1
d2471 5
d2479 2
a2480 4
	     !(ni->ni_rsncaps & IEEE80211_RSNCAP_PBAC))) {
		status = IEEE80211_STATUS_REFUSED;
		goto resp;
	}
d2485 3
a2487 4
	if (ic->ic_tid_noack & (1 << tid)) {
		status = IEEE80211_STATUS_REFUSED;
		goto resp;
	}
d2490 2
a2491 4
	    !(params & IEEE80211_ADDBA_BA_POLICY)) {
		status = IEEE80211_STATUS_INVALID_PARAM;
		goto resp;
	}
d2497 1
d2511 3
a2513 4
	if (ba->ba_buf == NULL) {
		status = IEEE80211_STATUS_REFUSED;
		goto resp;
	}
d2517 5
a2521 2
	if (ic->ic_ampdu_rx_start == NULL ||
	    ic->ic_ampdu_rx_start(ic, ni, tid) != 0) {
d2523 18
a2540 5
		free(ba->ba_buf, M_DEVBUF, 0);
		ba->ba_buf = NULL;
		status = IEEE80211_STATUS_REFUSED;
		goto resp;
	}
d2546 16
a2561 2
	status = IEEE80211_STATUS_SUCCESS;
 resp:
d2564 2
a2565 1
	    IEEE80211_ACTION_ADDBA_RESP, status << 16 | token << 8 | tid);
@


1.178
log
@In hostap mode, don't re-use association IDs (AIDs) of nodes which are
still lingering in the node cache. This could cause an AID to be assigned
twice, once to a newly associated node and once to a different node in
COLLECT cache state (i.e. marked for future eviction from the node cache).

Drivers (e.g. rt2860) may use AIDs to keep track of nodes in firmware
tables and get confused when AIDs aren't unique across the node cache.
The symptom observed with rt2860 were nodes stuck at 1 Mbps Tx rate since
the duplicate AID made the driver perform Tx rate (AMRR) accounting on
the wrong node object.

To find out if a node is associated we now check the node's cache state,
rather than comparing the node's AID against zero. An AID is assigned when
a node associates and it lasts until the node is eventually purged from the
node cache (previously, the AID was made available for re-use when the node
was placed in COLLECT state). There is no need to be stingy with AIDs since
the number of possible AIDs exceeds the maximum number of nodes in the cache.

Problem found by Nathanael Rensen.
Fix written by Nathanael and myself. Tested by Nathanael.
Comitting now to get this change tested across as many drivers as possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.177 2016/05/10 06:37:15 dlg Exp $	*/
d1396 1
a1396 1
	u_int8_t chan, bchan, erp;
d1439 1
d1481 6
d1577 3
@


1.178.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 5.9 errata 35, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.178 2016/05/18 08:15:28 stsp Exp $	*/
a2301 1
		ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
@


1.177
log
@make bpf_mtap callers set the M_FILDROP flag if they care about it.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.176 2016/05/02 09:35:49 tb Exp $	*/
d450 1
a450 1
			if (ni->ni_associd == 0) {
@


1.176
log
@Fix a corner case of 12-bit arithmetic: also increment the ba_winmiss
counter if sn == 0 and ba_missedsn == 0xfff.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.175 2016/05/02 08:12:42 stsp Exp $	*/
d551 6
a556 8
		if (ic->ic_rawbpf)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_IN);
		/*
		 * Drop mbuf if it was filtered by bpf. Normally, this is
		 * done in ether_input() but IEEE 802.11 management frames
		 * are a special case.
		 */
		if (m->m_flags & M_FILDROP) {
@


1.175
log
@IEEE 802.11 sequence numbers wrap at 12 bit.
Fix a case where ieee80211_ba_input() failed to account for that.
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.174 2016/04/28 15:00:27 stsp Exp $	*/
d725 1
a725 1
				if (ba->ba_missedsn == sn - 1)
@


1.174
log
@Rework handling of frames which fall beyond the block ack window.

tb@@ discovered that we were not following the 802.11-2012 standard correctly
for frames which fall within the range [winend, windend+winsize]. This could
cause valid frames to be dropped because we moved the window too far ahead.

with and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.173 2016/04/28 13:58:00 stsp Exp $	*/
d743 1
a743 1
			    ba->ba_winstart + count);
@


1.173
log
@When a frame which falls into the block ack window is received, clear
counters that keep track of consecutive frames falling outside the window.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.172 2016/04/27 11:58:10 stsp Exp $	*/
d70 2
d717 1
a717 11
		/* 
		 * If this frame would move the window outside the range of
		 * winend + winsize, drop it. This is likely a fluke and the
		 * next frame will fit into the window again. Allowing the
		 * window to be moved too far ahead makes us drop frames
		 * until their sequence numbers catch up with the new window.
		 *
		 * However, if the window really did move arbitrarily, we must
		 * allow it to move forward. We try to detect this condition
		 * by counting missed consecutive frames.
		 */
a718 7
#ifdef DIAGNOSTIC
		if ((ifp->if_flags & IFF_DEBUG) && count > 1)
			printf("%s: received frame with bad sequence number "
			    "%d, expecting %d:%d\n", __func__,
			    sn, ba->ba_winstart, ba->ba_winend);
#endif
		ic->ic_stats.is_ht_rx_frame_above_ba_winend++;
d720 4
d739 6
a744 2

			count = ba->ba_winsize;	/* no overlap */
a745 14
		while (count-- > 0) {
			/* gaps may exist */
			if (ba->ba_buf[ba->ba_head].m != NULL) {
				ieee80211_input(ifp, ba->ba_buf[ba->ba_head].m,
				    ni, &ba->ba_buf[ba->ba_head].rxi);
				ba->ba_buf[ba->ba_head].m = NULL;
			} else
				ic->ic_stats.is_ht_rx_ba_frame_lost++;
			ba->ba_head = (ba->ba_head + 1) %
			    IEEE80211_BA_MAX_WINSZ;
		}
		/* move window forward */
		ba->ba_winend = sn;
		ba->ba_winstart = (sn - ba->ba_winsize + 1) & 0xfff;
d771 33
@


1.172
log
@Add some stat counters for events related to 802.11n.
netstat(1) needs to be recompiled to work with new kernel.
ok deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.171 2016/04/15 03:04:27 dlg Exp $	*/
d770 2
@


1.171
log
@replace m_copym2 with m_dup_pkt

tested by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.170 2016/04/12 14:33:27 mpi Exp $	*/
d710 1
a710 1
		ic->ic_stats.is_rx_dup++;
d733 1
d747 1
d759 2
a760 1
			}
d775 1
d827 2
d837 1
d871 2
a872 1
		}
d1591 1
d2503 1
d2574 1
@


1.170
log
@Call if_enqueue() and if_start() instead of dereferencing the ifp
pointers.

These functions have been introduced to abstract some of the MP-
safeness^Wmadness and should be use everywhere.

Prodded by a comment from jsg@@.

ok mikeb@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.169 2016/03/22 11:37:35 dlg Exp $	*/
d904 1
a904 1
			m1 = m_copym2(m, 0, M_COPYALL, M_DONTWAIT);
@


1.169
log
@replace ieee80211_align_mbuf with m_dup_pkt

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.168 2016/02/12 10:12:42 stsp Exp $	*/
d363 1
a363 1
				(*ifp->if_start)(ifp);
d2873 1
a2873 1
	(*ifp->if_start)(ifp);
@


1.168
log
@Remove superfluous assignments of 'subtype' in ieee80211_input().
Suggested by sthen@@
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.167 2016/02/11 19:36:48 stsp Exp $	*/
a943 68
#ifdef __STRICT_ALIGNMENT
/*
 * Make sure protocol header (e.g. IP) is aligned on a 32-bit boundary.
 * This is achieved by copying mbufs so drivers should try to map their
 * buffers such that this copying is not necessary.  It is however not
 * always possible because 802.11 header length may vary (non-QoS+LLC
 * is 32 bytes while QoS+LLC is 34 bytes).  Some devices are smart and
 * add 2 padding bytes after the 802.11 header in the QoS case so this
 * function is there for stupid drivers/devices only.
 *
 * XXX -- this is horrible
 */
struct mbuf *
ieee80211_align_mbuf(struct mbuf *m)
{
	struct mbuf *n, *n0, **np;
	caddr_t newdata;
	int off, pktlen;

	n0 = NULL;
	np = &n0;
	off = 0;
	pktlen = m->m_pkthdr.len;
	while (pktlen > off) {
		if (n0 == NULL) {
			MGETHDR(n, M_DONTWAIT, MT_DATA);
			if (n == NULL) {
				m_freem(m);
				return NULL;
			}
			if (m_dup_pkthdr(n, m, M_DONTWAIT)) {
				m_free(n);
				m_freem(m);
				return (NULL);
			}
			n->m_len = MHLEN;
		} else {
			MGET(n, M_DONTWAIT, MT_DATA);
			if (n == NULL) {
				m_freem(m);
				m_freem(n0);
				return NULL;
			}
			n->m_len = MLEN;
		}
		if (pktlen - off >= MINCLSIZE) {
			MCLGET(n, M_DONTWAIT);
			if (n->m_flags & M_EXT)
				n->m_len = n->m_ext.ext_size;
		}
		if (n0 == NULL) {
			newdata = (caddr_t)ALIGN(n->m_data + ETHER_HDR_LEN) -
			    ETHER_HDR_LEN;
			n->m_len -= newdata - n->m_data;
			n->m_data = newdata;
		}
		if (n->m_len > pktlen - off)
			n->m_len = pktlen - off;
		m_copydata(m, off, n->m_len, mtod(n, caddr_t));
		off += n->m_len;
		*np = n;
		np = &n->m_next;
	}
	m_freem(m);
	return n0;
}
#endif	/* __STRICT_ALIGNMENT */

a990 1
#ifdef __STRICT_ALIGNMENT
d992 4
a995 1
		if ((m = ieee80211_align_mbuf(m)) == NULL) {
a999 1
#endif
@


1.168.2.1
log
@MFC: Fix a bug allowing a man-in-the-middle attack against WPA wireless clients.
A malicious AP could trick clients into connecting to the malicious AP
instead of the desired AP. All frames would then be sent in the clear.
This problem was found and reported by Mathy Vanhoef who also provided
an initial patch which we improved together.
(OpenBSD 6.0 errata 18, Mar 1, 2017)
by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.168 2016/02/12 10:12:42 stsp Exp $	*/
a2347 1
		ni->ni_rsn_supp_state = RSNA_SUPP_PTKSTART;
@


1.167
log
@In ieee80211_input(), initialize 'subtype' variable before using it.
Should have been part of the QoS "no data" fix.
ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.166 2016/02/11 17:14:29 stsp Exp $	*/
a512 2
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

a566 1
		subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;
@


1.166
log
@Make the heuristic which catches frames with sequence numbers outside the
current BlockAck window compare against the actual window size, rather than
the maximum window size possible. As a result, two consecutive if-blocks
now check for the same condition, so merge them.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.165 2016/02/11 17:06:01 stsp Exp $	*/
d260 1
@


1.165
log
@Trim text in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.164 2016/02/11 16:43:40 stsp Exp $	*/
d735 1
a735 1
		if (count > IEEE80211_BA_MAX_WINSZ) {
d750 2
a752 2
		if (count > ba->ba_winsize)	/* no overlap */
			count = ba->ba_winsize;
@


1.164
log
@In ieee80211_ba_input(), compute the expression '(sn - ba->ba_winend) & 0xfff'
just once, by assigning its value to the 'count' variable earlier and reusing
'count' where this expression was used.
No functional change. This just results in better readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.163 2016/02/11 16:25:15 stsp Exp $	*/
a726 4
		 *
		 * Works around buggy behaviour observed with Broadcom-based
		 * APs, which emit "sequence" numbers such as 1888, 1889, 2501,
		 * 1890, 1891, ... all for the same TID.
@


1.163
log
@Don't pass QoS "no data" frames to the A-MPDU reordering logic. Such frames
will cause major confusion since they don't carry a sequence number.
ok mpi@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.162 2016/02/09 13:48:31 stsp Exp $	*/
d732 1
d734 1
a734 2
		if ((ifp->if_flags & IFF_DEBUG) &&
		    ((sn - ba->ba_winend) & 0xfff) > 1)
d739 1
a739 1
		if (((sn - ba->ba_winend) & 0xfff) > IEEE80211_BA_MAX_WINSZ) {
a754 1
		count = (sn - ba->ba_winend) & 0xfff;
@


1.162
log
@Log frames which fall outside the BlockAack window in dmesg if the
interface debug flag is set (enabled with: ifconfig iwn0 debug).
Shows the frame's sequence number and the current BA window.
I'm adding this for diagnosis, just in case it will be needed to make
future decisions about tuning the heuristic which works around network
stalls caused by such frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.161 2016/02/08 01:00:47 stsp Exp $	*/
d278 1
@


1.161
log
@Stop requiring a BlockAck session timeout (again), and just use it if the AP
is asking for it. This timeout should not be required anymore now that krw@@'s
hangs are fixed by working around APs which make sequence numbers jump about.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.160 2016/02/08 00:54:57 stsp Exp $	*/
d731 7
@


1.160
log
@Work around buggy APs which occasionally emit sequence numbers much higher
than the current 11n BlockAck window. The previous code would be fooled into
moving the window forward and then drop packets until their sequence numbers
catch up with the new window, which can take several minutes.
Fixes traffic stalls observed with Broadcom APs.
ok krw@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.159 2016/02/07 23:36:43 stsp Exp $	*/
d707 2
a708 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2492 2
a2493 1
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
a2529 4
	if (ba->ba_timeout_val < IEEE80211_BA_MIN_TIMEOUT)
		ba->ba_timeout_val = IEEE80211_BA_MIN_TIMEOUT;
	else if (ba->ba_timeout_val > IEEE80211_BA_MAX_TIMEOUT)
		ba->ba_timeout_val = IEEE80211_BA_MAX_TIMEOUT;
d2561 2
a2562 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d3024 2
a3025 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
@


1.159
log
@Hide some excessive net80211 debug printfs behind ieee80211_debug >= 2.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.158 2016/02/05 19:42:04 stsp Exp $	*/
d715 31
@


1.158
log
@Count A-MPDU subframes with sequence number below the current BA window as
duplicates rather than input errors. These subframes have either already
been received, or the window was moved by the gap timeout which should only
happen with buggy APs. Neither condition indicates a severe problem.
Perhaps we will introduce a separate counter for this later.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.157 2016/02/05 16:07:57 stsp Exp $	*/
d195 1
a195 1
	doprint += ieee80211_debug;
d1559 1
a1559 1
	if (ieee80211_debug &&
@


1.157
log
@Store ADDBA request and response parameters in the block ack record of
ieee80211_node. This way, we can keep track of the ACK policy and echo
it back to the AP as required by the standard. And use the correct bit
flag for the policy -- this code was confused between BlockAck and ADDBA,
both of which have a policy bit but in different places.

Fixes apple airport APs.

tested by tb@@, krw@@, sthen@@, abieber@@, and Henrik Friedrichsen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.156 2016/02/04 16:23:40 stsp Exp $	*/
d710 1
a710 1
		ifp->if_ierrors++;
@


1.156
log
@Restore the BlockAck session timer. It is still required to work around
stalled BA sessions observed with iwn(4). We can revisit this later once
the underlying problem in iwn(4) has been found.
Prompted by report from krw@@, I could reproduce the issue.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.155 2016/02/01 18:43:22 stsp Exp $	*/
d2507 3
@


1.155
log
@Stop requiring a BlockAck session timeout. We still honour the timeout if
the AP requests it, though I don't think I've ever seen one that does.
Per the 802.11-2012 spec a value of zero disables the timeout and some
APs seem to have trouble with timeouts forced onto them.
Our behaviour now matches Linux in this regard.

This gets Apple Airport APs somewhat working in 11n mode but there
is still a remaining issue with receiving frames from them.
Doesn't seem to hurt any other APs I've tried.

ok sthen@@ mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.154 2016/01/25 15:14:22 stsp Exp $	*/
d707 1
a707 2
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2460 1
a2460 2
		if (ba->ba_timeout_val != 0)
			timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2497 4
d2529 1
a2529 2
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2991 1
a2991 2
	if (ba->ba_timeout_val != 0)
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
@


1.154
log
@Honour ERP protection on 2 GHz channels in 11n mode, as done for 11g.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.153 2016/01/25 15:10:37 stsp Exp $	*/
d707 2
a708 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2461 2
a2462 1
		timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
a2498 4
	if (ba->ba_timeout_val < IEEE80211_BA_MIN_TIMEOUT)
		ba->ba_timeout_val = IEEE80211_BA_MIN_TIMEOUT;
	else if (ba->ba_timeout_val > IEEE80211_BA_MAX_TIMEOUT)
		ba->ba_timeout_val = IEEE80211_BA_MAX_TIMEOUT;
d2527 2
a2528 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
d2990 2
a2991 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
@


1.153
log
@Don't try to interpret htprot data if the last beacon didn't contain such data.
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.152 2016/01/25 11:27:11 stsp Exp $	*/
d2302 3
a2304 1
	if (ic->ic_curmode == IEEE80211_MODE_11G &&
@


1.152
log
@Keep track of HT protection settings in beacons and have 11n-capable
drivers update hardware configuration accordingly.
tested by myself, tb@@, deraadt@@, abieber@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.151 2016/01/07 23:22:31 stsp Exp $	*/
d1582 2
a1583 2
	if (htop)
		ieee80211_setup_htop(ni, htop + 2, htop[1]);
d1606 1
a1606 1
		if (ic->ic_bss->ni_flags & IEEE80211_NODE_HT) {
@


1.151
log
@Make the A-MPDU reordering buffer more resilient against APs which drop
some subframes or let the sequence number jump up by more than 1 (hard
to tell which it is). We decrease the BA inactivity timeout for quicker
recovery from stalled BA sessions, and add a new timeout which keeps track
of gaps in the subframe sequence number space due to dropped frames.
Gaps expire after 500 msec, the same value FreeBSD uses for their
implementation of this workaround. And Linux uses this trick, too.

This should fix network stalls some people have been seeing in 11n mode.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.150 2016/01/05 18:41:16 stsp Exp $	*/
d1580 5
d1587 1
a1587 2
	 * while we're associated. We consider only 11g stuff right
	 * now.
d1606 16
a1701 4
	if (htcaps)
		ieee80211_setup_htcaps(ni, htcaps + 2, htcaps[1]);
	if (htop)
		ieee80211_setup_htop(ni, htop + 2, htop[1]);
@


1.150
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.149 2016/01/04 13:29:31 stsp Exp $	*/
d63 1
a63 1
void	ieee80211_input_ba(struct ifnet *, struct mbuf *,
d65 3
d307 1
a307 1
			ieee80211_input_ba(ifp, m, ni, tid, rxi);
d694 1
a694 1
ieee80211_input_ba(struct ifnet *ifp, struct mbuf *m,
d697 1
d747 16
d776 32
d837 1
a837 11
	/* pass reordered MPDUs up to the next MAC process */
	while (ba->ba_buf[ba->ba_head].m != NULL) {
		ieee80211_input(ifp, ba->ba_buf[ba->ba_head].m, ni,
		    &ba->ba_buf[ba->ba_head].rxi);
		ba->ba_buf[ba->ba_head].m = NULL;

		ba->ba_head = (ba->ba_head + 1) % IEEE80211_BA_MAX_WINSZ;
		/* move window forward */
		ba->ba_winstart = (ba->ba_winstart + 1) & 0xfff;
	}
	ba->ba_winend = (ba->ba_winstart + ba->ba_winsize - 1) & 0xfff;
d2485 1
d2635 1
@


1.149
log
@Replace magic shifts and bitmasks used for ADDBA parameters
with proper names, now that we have the corresponding macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.148 2016/01/04 12:32:06 stsp Exp $	*/
a62 1
#ifndef IEEE80211_NO_HT
a66 1
#endif
a69 1
#ifndef IEEE80211_NO_HT
a71 1
#endif
a100 1
#ifndef IEEE80211_NO_HT
a106 1
#endif
a118 1
#ifndef IEEE80211_NO_HT
a122 1
#endif
a273 1
#ifndef IEEE80211_NO_HT
a307 1
#endif
a489 1
#ifndef IEEE80211_NO_HT
a493 1
#endif
a570 1
#ifndef IEEE80211_NO_HT
a573 1
#endif
a685 1
#ifndef IEEE80211_NO_HT
a796 1
#endif	/* !IEEE80211_NO_HT */
a994 1
#ifndef IEEE80211_NO_HT
a1073 1
#endif	/* !IEEE80211_NO_HT */
a1445 1
#ifndef IEEE80211_NO_HT
a1451 1
#endif
a1639 1
#ifndef IEEE80211_NO_HT
a1643 1
#endif
a1697 1
#ifndef IEEE80211_NO_HT
a1700 1
#endif
a1746 1
#ifndef IEEE80211_NO_HT
a1748 1
#endif
a1871 1
#ifndef IEEE80211_NO_HT
a1874 1
#endif
a2085 1
#ifndef IEEE80211_NO_HT
a2087 1
#endif
a2164 1
#ifndef IEEE80211_NO_HT
a2170 1
#endif
a2211 1
#ifndef IEEE80211_NO_HT
a2221 1
#endif
a2353 1
#ifndef IEEE80211_NO_HT
a2617 1
#endif	/* !IEEE80211_NO_HT */
a2712 1
#ifndef IEEE80211_NO_HT
a2725 1
#endif
a2847 1
#ifndef IEEE80211_NO_HT
a2933 1
#endif	/* !IEEE80211_NO_HT */
@


1.148
log
@ADDBA frames have a parameter set which we check against our own capabilities
but we were checking bits in these parameters with the wrong set of bitmasks.
Negotiating A-MPDUs with some APs failed because of this bug.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.147 2016/01/04 12:25:46 stsp Exp $	*/
d2423 4
a2426 2
	tid = (params >> 2) & 0xf;
	bufsz = (params >> 6) & 0x3ff;
@


1.147
log
@Don't return 11n mode from ieee80211_chan2mode() so we can switch into
11a and 11b/g mode correctly when the driver supports 11n.
And make sure the result of this funtion is only used to index ic_sup_rates.
Its stated purpose is to help select a legacy rate.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.146 2016/01/04 12:25:00 stsp Exp $	*/
d2462 1
a2462 1
	    !(params & IEEE80211_BA_ACK_POLICY)) {
@


1.146
log
@While configuring ERP we need to know if we're in 11a or 11g mode so only
configure ERP once we are sure about our operation mode against the AP.
ok sthen jasper kettenis deraadt mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.145 2015/12/12 13:56:10 stsp Exp $	*/
d213 1
a213 2
	    ieee80211_phymode_name[ieee80211_chan2mode(
	        ic, ic->ic_bss->ni_chan)]);
@


1.145
log
@In the A-MSDU receive code path, add an upper bounds check on A-MSDU
subframe length and a clean exit at the bottom of the subframe loop.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.144 2015/12/12 12:22:14 stsp Exp $	*/
d2253 1
a2253 3
	if (ic->ic_curmode != IEEE80211_MODE_AUTO &&
	    ic->ic_curmode != IEEE80211_MODE_11N &&
	    (ni->ni_flags & IEEE80211_NODE_HT))
d2255 8
a2263 13
	/* Hop out of 11n mode after associating to a non-HT AP. */
	if (ic->ic_curmode == IEEE80211_MODE_11N &&
	    (ni->ni_flags & IEEE80211_NODE_HT) == 0) {
		if (IEEE80211_IS_CHAN_T(ni->ni_chan))
			ieee80211_setmode(ic, IEEE80211_MODE_TURBO);
		else if (IEEE80211_IS_CHAN_A(ni->ni_chan))
			ieee80211_setmode(ic, IEEE80211_MODE_11A);
		else if (IEEE80211_IS_CHAN_G(ni->ni_chan))
			ieee80211_setmode(ic, IEEE80211_MODE_11G);
		else
			ieee80211_setmode(ic, IEEE80211_MODE_11B);
	}
#endif
@


1.144
log
@Flag AP as QoS capable when EDCA or WME information elements occur in beacons
or probe responses. Makes 11n negotiation with Linux iwlwifi AP succeed.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.143 2015/12/12 11:25:46 stsp Exp $	*/
d1064 7
d1082 4
@


1.143
log
@Finish support for receiving 11n A-MPDUs.

The initial implementation was added by damien@@ years ago.
Summary of the changes made in this commit:
 - In ieee80211_input(), process A-MPDUs before duplicate detection.
 - Don't forget to set ba->ba_ni in ieee80211_recv_addba_req()
   so we don't crash in ieee80211_rx_ba_timeout().
 - In ieee80211_recv_addba_req(), tweak the logic to deny BlockAck
   requests if the driver has no callback for doing so.
 - Implement ieee80211_ba_del() which cleans up BlockAck state.
 - Increase the minimum and maximum lifetime for BlockAck agrements.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.142 2015/11/15 11:14:17 stsp Exp $	*/
d1588 7
a1594 4
		if (edcaie != NULL)
			ieee80211_parse_edca_params(ic, edcaie);
		else if (wmmie != NULL)
			ieee80211_parse_wmm_params(ic, wmmie);
@


1.142
log
@Parse 11n HT capabilities and operational info from association response
frames, negotiate HT with the AP, and move the interface into or out of
11n mode accordingly. If running as AP negotiate HT with nodes joining the BSS.

ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.141 2015/11/15 10:07:03 stsp Exp $	*/
d283 37
a469 21
#ifndef IEEE80211_NO_HT
		if (!(rxi->rxi_flags & IEEE80211_RXI_AMPDU_DONE) &&
		    hasqos && (qos & IEEE80211_QOS_ACK_POLICY_MASK) ==
		    IEEE80211_QOS_ACK_POLICY_BA) {
			/* check if we have a BA agreement for this RA/TID */
			if (ni->ni_rx_ba[tid].ba_state !=
			    IEEE80211_BA_AGREED) {
				DPRINTF(("no BA agreement for %s, TID %d\n",
				    ether_sprintf(ni->ni_macaddr), tid));
				/* send a DELBA with reason code UNKNOWN-BA */
				IEEE80211_SEND_ACTION(ic, ni,
				    IEEE80211_CATEG_BA, IEEE80211_ACTION_DELBA,
				    IEEE80211_REASON_SETUP_REQUIRED << 16 |
				    tid);
				goto err;
			}
			/* go through A-MPDU reordering */
			ieee80211_input_ba(ifp, m, ni, tid, rxi);
			return;	/* don't free m! */
		}
#endif
d2468 1
d2485 1
a2485 1
	if (ic->ic_ampdu_rx_start != NULL &&
@


1.141
log
@Extend struct ieee80211_node with fields for 11n STA HT capabilities and
HT operational information sent by 11n APs. These fields reflect the structure
of elements in management frames so that IEEE80211_HTCAP* and IEEE80211_HTOP*
macros designed to operate on frame elements can be used directly to read
or set the fields.

Populate nodes with HT information received in probe responses, probe
requests, and association requests.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.140 2015/11/08 18:51:47 stsp Exp $	*/
d2215 26
@


1.140
log
@Handle additional RSN element group ciphers.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.139 2015/11/08 18:48:07 stsp Exp $	*/
d1631 6
a1636 1

d1742 4
d2085 4
@


1.139
log
@Update section and table numbers inside comments in the RSN code to
the 802.11-2012 standard.
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.138 2015/11/04 12:12:00 dlg Exp $	*/
d1224 3
a1226 1
	if (rsn->rsn_groupcipher == IEEE80211_CIPHER_USEGROUP)
d1290 2
@


1.138
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.137 2015/07/15 22:16:42 deraadt Exp $	*/
d1143 1
a1143 1
		/* from IEEE Std 802.11 - Table 20da */
d1189 1
a1189 1
 * Parse an RSN element (see 7.3.2.25).
@


1.137
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.136 2015/06/30 13:54:42 mpi Exp $	*/
d319 2
d330 2
a331 4
			while (!IF_IS_EMPTY(&ni->ni_savedq)) {
				struct mbuf *m;
				IF_DEQUEUE(&ni->ni_savedq, m);
				IF_ENQUEUE(&ic->ic_pwrsaveq, m);
d2802 1
a2802 1
	IF_DEQUEUE(&ni->ni_savedq, m);
d2805 1
a2805 1
	if (IF_IS_EMPTY(&ni->ni_savedq)) {
d2813 1
a2813 1
	IF_ENQUEUE(&ic->ic_pwrsaveq, m);
@


1.137.4.1
log
@Merge 'Handle additional RSN element group ciphers' fix to 5.8-stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.137 2015/07/15 22:16:42 deraadt Exp $	*/
d1224 1
a1224 3
	if (rsn->rsn_groupcipher == IEEE80211_CIPHER_NONE ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_USEGROUP ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_BIP)
a1287 2
	if (rsn->rsn_groupmgmtcipher != IEEE80211_CIPHER_BIP)
		return IEEE80211_STATUS_BAD_GROUP_CIPHER;
@


1.136
log
@Rename if_output() into if_enqueue() to avoid confusion with comments
talking about (*ifp->if_output)().

ok claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.135 2015/06/24 09:40:54 mpi Exp $	*/
d621 1
a621 2
		if (df->df_m != NULL)
			m_freem(df->df_m);	/* discard old entry */
d2563 1
a2563 2
				if (ba->ba_buf[i].m != NULL)
					m_freem(ba->ba_buf[i].m);
@


1.135
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.134 2015/05/26 15:34:00 mpi Exp $	*/
d845 1
a845 1
			if (if_output(ifp, m1))
@


1.134
log
@Use if_output() instead of rerolling it.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.133 2015/03/14 03:38:51 jsg Exp $	*/
a817 1
	ifp->if_ipackets++;
d853 1
@


1.133
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.132 2015/02/09 03:09:57 dlg Exp $	*/
a829 1
		int error, len;
d846 2
a847 10
			len = m1->m_pkthdr.len;
			IFQ_ENQUEUE(&ifp->if_snd, m1, NULL, error);
			if (error)
				ifp->if_oerrors++;
			else {
				if (m != NULL)
					ifp->if_omcasts++;
				ifp->if_obytes += len;
				if_start(ifp);
			}
@


1.132
log
@tweak the new if_input function so it takes an mbuf_list instead
of a single mbuf. this forces us to batch work between the hardware
rx handlers and the stack.

this includes a converstion of bge from ether_input to if_input.

ok claudio@@ pelikan@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.131 2015/02/08 06:03:07 mpi Exp $	*/
a48 1
#include <net/if_arp.h>
@


1.132.2.1
log
@Merge 'Handle additional RSN element group ciphers' fix to 5.7-stable.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.132 2015/02/09 03:09:57 dlg Exp $	*/
d1235 1
a1235 3
	if (rsn->rsn_groupcipher == IEEE80211_CIPHER_NONE ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_USEGROUP ||
	    rsn->rsn_groupcipher == IEEE80211_CIPHER_BIP)
a1298 2
	if (rsn->rsn_groupmgmtcipher != IEEE80211_CIPHER_BIP)
		return IEEE80211_STATUS_BAD_GROUP_CIPHER;
@


1.131
log
@Convert wirless devices to if_input(), tested with iwn(4) and urtwn(4).

ok pelikan@@, reyk@@, blambert@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.130 2015/01/27 03:17:36 dlg Exp $	*/
d873 5
a877 2
		} else
			if_input(ifp, m);
@


1.130
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.129 2015/01/13 23:16:59 stsp Exp $	*/
d862 2
d865 6
a870 6
		/*
		 * If we forward frame into transmitter of the AP,
		 * we don't need to duplicate for DLT_EN10MB.
		 */
		if (ifp->if_bpf && m1 == NULL)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
a871 2
		if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    eh->ether_type == htons(ETHERTYPE_PAE))
d873 2
a874 2
		else
			ether_input_mbuf(ifp, m);
@


1.129
log
@In IBSS mode, stop calling the driver's newassoc() each time a probe
response is received from a node. Only call it once when the node is
initially discovered, as used to be the case before r1.4 of this file.
Asking the driver to set up its per-node private state once is enough.
Also remove an outdated comment.
ok sthen deraadt jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.128 2014/12/23 03:24:08 tedu Exp $	*/
d134 1
a134 1
void	ieee80211_input_print_task(void *, void *);
d167 1
a167 1
ieee80211_input_print_task(void *arg1, void *arg2)
d217 1
a217 1
	task_set(&msg->task, ieee80211_input_print_task, msg, NULL);
@


1.128
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.127 2014/09/14 14:17:26 jsg Exp $	*/
a1635 8
	/*
	 * When scanning we record results (nodes) with a zero
	 * refcnt.  Otherwise we want to hold the reference for
	 * ibss neighbors so the nodes don't get released prematurely.
	 * Anything else can be discarded (XXX and should be handled
	 * above so we don't do so much work).
	 */
	if (
d1637 1
a1637 3
	    ic->ic_opmode == IEEE80211_M_IBSS ||
#endif
	    (is_new && isprobe)) {
d1646 1
@


1.127
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.126 2014/07/12 18:44:22 tedu Exp $	*/
a55 1
#ifdef INET
a57 1
#endif
@


1.126
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.125 2014/07/11 08:19:40 blambert Exp $	*/
a42 1
#include <sys/proc.h>
@


1.125
log
@move ieee80211 message printing from workq to taskq

testing stsp@@
ok stsp@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.124 2014/07/10 14:32:28 stsp Exp $	*/
d175 1
a175 1
	free(msg, M_DEVBUF);
d1333 1
a1333 1
			free(*ie, M_DEVBUF);
d2448 1
a2448 1
		free(ba->ba_buf, M_DEVBUF);
d2586 1
a2586 1
			free(ba->ba_buf, M_DEVBUF);
@


1.124
log
@Return RSN (WPA) information to userland during wireless scan, and
make ifconfig show whether a wireless network uses WEP or WPA.
Since struct ieee80211_nodereq grows in size old ifconfig won't be
able to scan when running on a new kernel.
While here, add missing ioctl constant IEEE80211_WPA_CIPHER_BIP.
ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.123 2013/06/11 18:15:53 deraadt Exp $	*/
d45 1
a45 1
#include <sys/workq.h>
d139 5
d172 1
a172 1
	char *msg = arg1;
d174 1
a174 1
	printf("%s", msg);
a175 1

d182 2
a183 2
	int doprint, error;
	char *msg;
d209 1
a209 1
	msg = malloc(1024, M_DEVBUF, M_NOWAIT);
d213 2
a214 2
	snprintf(msg, 1024, "%s: received %s from %s rssi %d mode %s\n",
	    ifp->if_xname,
d220 2
a221 3
	error = workq_add_task(NULL, 0, ieee80211_input_print_task, msg, NULL);
	if (error)
		free(msg, M_DEVBUF);
@


1.123
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.122 2012/10/12 19:53:24 haesbaert Exp $	*/
d1582 1
a1582 1
	if (ic->ic_state == IEEE80211_S_SCAN &&
d1584 1
a1584 1
	    ic->ic_opmode != IEEE80211_M_HOSTAP &&
d1586 1
a1586 1
	    (ic->ic_flags & IEEE80211_F_RSNON)) {
d1616 1
a1616 2
	} else if (ic->ic_state == IEEE80211_S_SCAN)
		ni->ni_rsnprotos = IEEE80211_PROTO_NONE;
@


1.122
log
@Cleanup false positives for uninitialized uses.
Part of the work to remove -Wno-uninitialized.

ok blambert jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.121 2012/07/16 14:51:31 stsp Exp $	*/
d1050 1
a1050 1
			ovbcopy(eh, (u_int8_t *)eh + LLC_SNAPFRAMELEN,
@


1.121
log
@Fix a couple of possible node leaks in ieee80211_input().
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.120 2012/07/13 11:25:04 stsp Exp $	*/
d279 3
@


1.120
log
@Fix wireless scanning on slow systems with a high RX rate and interface
in debug mode.

If the interface is in debug mode ieee80211_input() will print messages
about received frames to the console. On slow systems, printf() calls can
take so long that the next RX interrupt will be serviced immediately, if
the RX rate is sufficiently high. This effectively locks the system at IPL_NET.
If a concurrent scan is running, the scan will never finish because it
relies on a timeout at IPL_SOFTCLOCK to hop channels every 200msec.
This timeout never runs in the above situation, leaving the wireless
interface in 'scan' state forever.

To give the timeout a chance to run, perform the printf() call from a
work queue (idea from guenther@@). This allows edd's slow soekris AP to
recover from 'ifconfig ral0 debug down up' in noisy RF environments.

With input from guenther, kettenis, blambert and deraadt.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.119 2011/04/05 11:48:28 blambert Exp $	*/
d404 3
a406 1
				ni = ieee80211_dup_bss(ic, wh->i_addr2);
d1730 3
a1732 1
		ni = ieee80211_dup_bss(ic, wh->i_addr2);
d1912 3
a1914 1
		ni = ieee80211_dup_bss(ic, wh->i_addr2);
@


1.119
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.118 2011/03/04 23:48:15 fgsch Exp $	*/
d45 1
d135 3
d159 62
d536 2
a537 31
		if (ifp->if_flags & IFF_DEBUG) {
			/* avoid to print too many frames */
			int doprint = 0;

			switch (subtype) {
			case IEEE80211_FC0_SUBTYPE_BEACON:
				if (ic->ic_state == IEEE80211_S_SCAN)
					doprint = 1;
				break;
#ifndef IEEE80211_STA_ONLY
			case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
				if (ic->ic_opmode == IEEE80211_M_IBSS)
					doprint = 1;
				break;
#endif
			default:
				doprint = 1;
				break;
			}
#ifdef IEEE80211_DEBUG
			doprint += ieee80211_debug;
#endif
			if (doprint)
				printf("%s: received %s from %s rssi %d mode %s\n",
				    ifp->if_xname,
				    ieee80211_mgt_subtype_name[subtype
				    >> IEEE80211_FC0_SUBTYPE_SHIFT],
				    ether_sprintf(wh->i_addr2), rxi->rxi_rssi,
				    ieee80211_phymode_name[ieee80211_chan2mode(ic,
				    ic->ic_bss->ni_chan)]);
		}
@


1.118
log
@kill is_rx_elem_unknown.
damien@@ ok. ports checked by sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.117 2011/02/21 20:00:12 stsp Exp $	*/
d845 2
d866 1
a866 1
			if (m_dup_pkthdr(n, m)) {
@


1.117
log
@When bridging multicast frames in hostap mode, make a deep copy of the mbuf
instead of a shallow copy to avoid problems if the mbuf is modified later
(e.g. if the frame is encrypted).
From FreeBSD.
http://marc.info/?l=freebsd-current&m=114168135819304&w=2
http://svn.freebsd.org/viewvc/base?view=revision&revision=156367
ok damien; committing with miod's permission (src is soft-locked)
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.116 2010/06/07 16:51:22 damien Exp $	*/
a1381 4
		case IEEE80211_ELEMID_TIM:
			break;
		case IEEE80211_ELEMID_IBSSPARMS:
			break;
a1397 2
		case IEEE80211_ELEMID_QOS_CAP:
			break;
a1417 5
			break;
		default:
			DPRINTF(("element id %u/len %u ignored\n",
			    frm[0], frm[1]));
			ic->ic_stats.is_rx_elem_unknown++;
@


1.116
log
@no need to include <sys/endian.h> twice!
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.115 2010/06/07 16:46:17 damien Exp $	*/
d792 1
a792 1
			m1 = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
@


1.115
log
@tweak ieee80211_decap():
instead of copying the 802.11 header on the stack and building
the ethernet header directly in the mbuf, build the ethernet
header on the stack directly from the 802.11 header in the
mbuf and copy the ethernet header to the mbuf after stripping
the 802.11 header.
makes the code easier to read/understand, especially, it is
now explicit what is being put in the ether_type field.

diff from Matthew Dempsky (matthew at dempsky dot org)

moved ieee80211_align_mbuf() under #ifdef __STRICT_ALIGNMENT
while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.113 2010/02/25 17:49:16 damien Exp $	*/
a44 1
#include <sys/endian.h>
@


1.114
log
@there is no need to copy the full 802.11 header in ieee80211_decap()
as we do not use any field after i_addr4.

slightly modified version of a diff from Matthew Dempsky (matthew at
dempsky dot org), used MIN instead of min.
@
text
@d837 1
d901 1
d907 2
a908 2
	struct ieee80211_frame_addr4 wh;
	struct ether_header *eh;
d916 21
a936 2
	memcpy(&wh, mtod(m, caddr_t), MIN(hdrlen, sizeof(wh)));
	llc = (struct llc *)(mtod(m, caddr_t) + hdrlen);
d943 1
a944 1
		llc = NULL;
d946 1
d949 2
a950 19
	eh = mtod(m, struct ether_header *);
	switch (wh.i_fc[1] & IEEE80211_FC1_DIR_MASK) {
	case IEEE80211_FC1_DIR_NODS:
		IEEE80211_ADDR_COPY(eh->ether_dhost, wh.i_addr1);
		IEEE80211_ADDR_COPY(eh->ether_shost, wh.i_addr2);
		break;
	case IEEE80211_FC1_DIR_TODS:
		IEEE80211_ADDR_COPY(eh->ether_dhost, wh.i_addr3);
		IEEE80211_ADDR_COPY(eh->ether_shost, wh.i_addr2);
		break;
	case IEEE80211_FC1_DIR_FROMDS:
		IEEE80211_ADDR_COPY(eh->ether_dhost, wh.i_addr1);
		IEEE80211_ADDR_COPY(eh->ether_shost, wh.i_addr3);
		break;
	case IEEE80211_FC1_DIR_DSTODS:
		IEEE80211_ADDR_COPY(eh->ether_dhost, wh.i_addr3);
		IEEE80211_ADDR_COPY(eh->ether_shost, wh.i_addr4);
		break;
	}
d957 1
a957 4
	if (llc != NULL) {
		eh = mtod(m, struct ether_header *);
		eh->ether_type = htons(m->m_pkthdr.len - ETHER_HDR_LEN);
	}
@


1.113
log
@fix two comments that i forgot when the SA query transaction identifier
changed from 16 bytes to 2 bytes.

no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.112 2009/09/13 14:42:52 krw Exp $	*/
d905 1
a905 1
	struct ieee80211_qosframe_addr4 wh;	/* largest 802.11 header */
d914 1
a914 1
	memcpy(&wh, mtod(m, caddr_t), hdrlen);
@


1.112
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.111 2009/03/26 20:34:54 damien Exp $	*/
d2570 3
a2572 3
 * [1]  Category
 * [1]  Action
 * [16] Transaction Identifier
d2607 3
a2609 3
 * [1]  Category
 * [1]  Action
 * [16] Transaction Identifier
@


1.111
log
@sync with 802.11w draft 8.0.
the SA Query Transaction Identifier field is now a 16-bit non-negative
counter value instead of a 128-bit random value.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.110 2009/03/06 18:35:02 damien Exp $	*/
d864 5
a868 1
			M_DUP_PKTHDR(n, m);
@


1.110
log
@Fix setting of the Short Slot Time subfield of the Capability Information
field in (Re)Association Requests.
This fixes association with APs refusing non-short-slot-time capable STAs.
This should also prevent the AP we're associating with to disable the use
of short slot time in the BSS as we join.
Fix debug message in recv_assoc_resp() while I'm here (s/reason/status/).
Scary.

Thanks to Adam Emanuel for spotting this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.109 2009/02/08 15:34:39 damien Exp $	*/
d2583 1
a2583 1
	if (m->m_len < sizeof(*wh) + 18) {
d2593 1
a2593 1
	memcpy(ni->ni_sa_query_trid, &frm[2], 16);
d2620 1
a2620 1
	if (m->m_len < sizeof(*wh) + 18) {
d2628 1
a2628 1
	if (memcmp(&frm[2], ni->ni_sa_query_trid, 16) != 0) {
@


1.109
log
@initial 802.11 defragmentation bits.
the code will allow the concurrent reception of fragments of three
fragmented MSDUs or MMPDUs as required by the 802.11 standard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.108 2009/01/28 18:55:18 damien Exp $	*/
d2098 1
a2098 1
			printf("%s: %sassociation failed (reason %d)"
@


1.108
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.107 2009/01/26 19:09:41 damien Exp $	*/
d65 2
d553 91
@


1.107
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.106 2008/09/27 15:16:09 damien Exp $	*/
d367 2
a368 1
			if (ni->ni_ba[tid].ba_state != IEEE80211_BA_AGREED) {
d562 1
a562 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
d626 1
a626 1
 * Block Ack Request frame or an ADDBA Request (PBAC).
d633 1
a633 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
d751 1
a751 1
 * function is there for brain-dead devices only.
d1214 1
a1214 1
ieee80211_recv_probe_resp(struct ieee80211com *ic, struct mbuf *m0,
d1248 1
a1248 1
	if (m0->m_len < sizeof(*wh) + 12) {
d1252 1
a1252 1
	wh = mtod(m0, struct ieee80211_frame *);
d1254 1
a1254 1
	efrm = mtod(m0, u_int8_t *) + m0->m_len;
d1537 1
a1537 1
ieee80211_recv_probe_req(struct ieee80211com *ic, struct mbuf *m0,
d1549 1
a1549 1
	wh = mtod(m0, struct ieee80211_frame *);
d1551 1
a1551 1
	efrm = mtod(m0, u_int8_t *) + m0->m_len;
d1629 1
a1629 1
ieee80211_recv_auth(struct ieee80211com *ic, struct mbuf *m0,
d1637 1
a1637 1
	if (m0->m_len < sizeof(*wh) + 6) {
d1641 1
a1641 1
	wh = mtod(m0, struct ieee80211_frame *);
d1682 1
a1682 1
ieee80211_recv_assoc_req(struct ieee80211com *ic, struct mbuf *m0,
d1698 1
a1698 1
	if (m0->m_len < sizeof(*wh) + (reassoc ? 10 : 4)) {
d1702 1
a1702 1
	wh = mtod(m0, struct ieee80211_frame *);
d1704 1
a1704 1
	efrm = mtod(m0, u_int8_t *) + m0->m_len;
d1976 1
a1976 1
ieee80211_recv_assoc_resp(struct ieee80211com *ic, struct mbuf *m0,
d1993 1
a1993 1
	if (m0->m_len < sizeof(*wh) + 6) {
d1997 1
a1997 1
	wh = mtod(m0, struct ieee80211_frame *);
d1999 1
a1999 1
	efrm = mtod(m0, u_int8_t *) + m0->m_len;
d2119 1
a2119 1
ieee80211_recv_deauth(struct ieee80211com *ic, struct mbuf *m0,
d2127 1
a2127 1
	if (m0->m_len < sizeof(*wh) + 2) {
d2131 1
a2131 1
	wh = mtod(m0, struct ieee80211_frame *);
d2165 1
a2165 1
ieee80211_recv_disassoc(struct ieee80211com *ic, struct mbuf *m0,
d2173 1
a2173 1
	if (m0->m_len < sizeof(*wh) + 2) {
d2177 1
a2177 1
	wh = mtod(m0, struct ieee80211_frame *);
d2222 1
a2222 1
	struct ieee80211_ba *ba;
d2246 2
a2247 2
	ba = &ni->ni_ba[tid];
	/* check if we already have a BA agreement for this RA/TID */
d2250 1
a2250 1
		/* reset BA inactivity timer */
d2258 1
a2258 1
		/* PBAC: treat the ADDBA Request like a BAR */
a2286 1
	ba->ba_token = token;	/* save Dialog Token for ADDBA Resp */
d2292 1
a2292 1
	timeout_set(&ba->ba_to, ieee80211_ba_timeout, ba);
d2308 2
a2309 2
	if (ic->ic_htimmba_start != NULL &&
	    ic->ic_htimmba_start(ic, ni, tid) != 0) {
d2323 1
a2323 1
	    IEEE80211_ACTION_ADDBA_RESP, status << 16 | tid);
d2341 1
a2341 1
	struct ieee80211_ba *ba;
d2366 1
a2366 1
	ba = &ni->ni_ba[tid];
d2388 2
a2389 2
	if (ic->ic_htimmba_start != NULL)
		(void)ic->ic_htimmba_start(ic, ni, tid);
d2392 2
a2393 1
	timeout_add_usec(&ba->ba_to, ba->ba_timeout_val);
a2408 1
	struct ieee80211_ba *ba;
d2427 15
a2441 7
	ba = &ni->ni_ba[tid];
	if (ba->ba_state != IEEE80211_BA_AGREED &&
	    ba->ba_state != IEEE80211_BA_REQUESTED) {
		DPRINTF(("no matching BA agreement found\n"));
		return;
	}
	/* MLME-DELBA.indication */
d2443 12
a2454 3
	/* notify drivers of the end of the Block Ack agreement */
	if (ic->ic_htimmba_stop != NULL)
		ic->ic_htimmba_stop(ic, ni, tid);
d2456 11
a2466 11
	ba->ba_state = IEEE80211_BA_INIT;
	/* stop Block Ack inactivity timer */
	timeout_del(&ba->ba_to);
	if (ba->ba_buf != NULL) {
		/* free all MSDUs stored in reordering buffer */
		for (i = 0; i < IEEE80211_BA_MAX_WINSZ; i++)
			if (ba->ba_buf[i].m != NULL)
				m_freem(ba->ba_buf[i].m);
		/* free reordering buffer */
		free(ba->ba_buf, M_DEVBUF);
		ba->ba_buf = NULL;
d2704 1
a2704 1
 * Process an incoming Block Ack Request control frame (see 7.2.1.7).
d2716 1
a2716 1
		DPRINTF(("received BAR from non-HT STA %s\n",
d2727 1
a2727 1
	/* read BAR Control field */
d2740 1
a2740 1
		frm += 2;	/* skip BAR Control field */
d2756 1
a2756 1
 * Process a Block Ack Request for a specific TID (see 9.10.7.6.3).
d2763 1
a2763 1
	struct ieee80211_ba *ba = &ni->ni_ba[tid];
a2789 1

@


1.106
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.104 2008/09/01 19:41:10 damien Exp $	*/
d6 1
a6 1
 * Copyright (c) 2007, 2008 Damien Bergamini
d65 13
a88 4
#ifndef IEEE80211_STA_ONLY
void	ieee80211_recv_pspoll(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *);
#endif
d107 14
d123 10
d135 1
a135 1
 * Retrieve the length in bytes of a 802.11 header.
d170 1
a170 1
	u_int16_t *orxseq, nrxseq;
d172 3
a174 1
	int hdrlen;
a175 4
#ifdef DIAGNOSTIC
	if (ni == NULL)
		panic("null node");
#endif
d209 6
a214 1
	/* check and save sequence control field, if present */
d219 1
a219 2
		if (ieee80211_has_qos(wh)) {
			tid = ieee80211_get_qos(wh) & IEEE80211_QOS_TID;
d221 1
a221 1
		} else
d362 20
d412 8
a419 8
		m = ieee80211_decap(ifp, m, hdrlen);
		if (m == NULL) {
			DPRINTF(("decapsulation error for src %s\n",
			    ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_decap++;
			goto err;
		}
		ieee80211_deliver_data(ic, m, ni);
d525 1
d527 1
a527 1
			/* NYI */
d529 2
a530 2
		case IEEE80211_FC0_SUBTYPE_BA:
			/* NYI */
d552 114
d743 9
d753 53
a805 1
ieee80211_decap(struct ifnet *ifp, struct mbuf *m, int hdrlen)
d811 4
a814 4
	if (m->m_len < hdrlen + LLC_SNAPFRAMELEN) {
		m = m_pullup(m, hdrlen + LLC_SNAPFRAMELEN);
		if (m == NULL)
			return NULL;
d824 1
a824 1
		m_adj(m, hdrlen + LLC_SNAPFRAMELEN - sizeof(*eh));
d827 1
a827 1
		m_adj(m, hdrlen - sizeof(*eh));
d848 4
a851 45
	if (!ALIGNED_POINTER(mtod(m, caddr_t) + sizeof(*eh), u_int32_t)) {
		struct mbuf *n, *n0, **np;
		caddr_t newdata;
		int off, pktlen;

		n0 = NULL;
		np = &n0;
		off = 0;
		pktlen = m->m_pkthdr.len;
		while (pktlen > off) {
			if (n0 == NULL) {
				MGETHDR(n, M_DONTWAIT, MT_DATA);
				if (n == NULL) {
					m_freem(m);
					return NULL;
				}
				M_DUP_PKTHDR(n, m);
				n->m_len = MHLEN;
			} else {
				MGET(n, M_DONTWAIT, MT_DATA);
				if (n == NULL) {
					m_freem(m);
					m_freem(n0);
					return NULL;
				}
				n->m_len = MLEN;
			}
			if (pktlen - off >= MINCLSIZE) {
				MCLGET(n, M_DONTWAIT);
				if (n->m_flags & M_EXT)
					n->m_len = n->m_ext.ext_size;
			}
			if (n0 == NULL) {
				newdata =
				    (caddr_t)ALIGN(n->m_data + sizeof(*eh)) -
				    sizeof(*eh);
				n->m_len -= newdata - n->m_data;
				n->m_data = newdata;
			}
			if (n->m_len > pktlen - off)
				n->m_len = pktlen - off;
			m_copydata(m, off, n->m_len, mtod(n, caddr_t));
			off += n->m_len;
			*np = n;
			np = &n->m_next;
a852 2
		m_freem(m);
		m = n0;
d856 1
a856 1
		eh->ether_type = htons(m->m_pkthdr.len - sizeof(*eh));
d858 1
a858 1
	return m;
d861 71
d1020 2
a1021 2
		case 6:	/* AES-128-CMAC */
			return IEEE80211_CIPHER_AES128_CMAC;
d1076 2
a1077 2
	/* if Group Management Cipher Suite missing, defaut to AES-128-CMAC */
	rsn->rsn_groupmgmtcipher = IEEE80211_CIPHER_AES128_CMAC;
d1198 13
a1210 11
 * [8]    Timestamp
 * [2]    Beacon interval
 * [2]    Capability
 * [tlv]  Service Set Identifier (SSID)
 * [tlv]  Supported rates
 * [tlv*] DS Parameter Set (802.11g)
 * [tlv]  ERP Information (802.11g)
 * [tlv]  Extended Supported Rates (802.11g)
 * [tlv]  RSN (802.11i)
 * [tlv]  EDCA Parameter Set (802.11e)
 * [tlv]  QoS Capability (Beacon only, 802.11e)
d1219 1
a1219 1
	const u_int8_t *rsnie, *wpaie;
d1260 1
d1305 8
d1533 1
d1541 1
a1541 1
	const u_int8_t *ssid, *rates, *xrates;
d1552 1
a1552 1
	ssid = rates = xrates = NULL;
d1568 5
d1658 2
a1659 2
				IEEE80211_FC0_SUBTYPE_AUTH,
				(seq+1) | (IEEE80211_STATUS_ALG<<16));
d1678 1
d1686 1
a1686 1
	const u_int8_t *ssid, *rates, *xrates, *rsnie, *wpaie;
d1713 1
a1713 1
	if (reassoc)
d1715 3
d1719 1
a1719 1
	ssid = rates = xrates = rsnie = wpaie = NULL;
d1740 5
d1791 21
d1878 3
a1880 3
		if (!(rsn.rsn_caps & IEEE80211_RSNCAP_MFPC) &&
		    (ic->ic_bss->ni_rsncaps & IEEE80211_RSNCAP_MFPR)) {
			status = IEEE80211_REASON_MFP_POLICY;	/* XXX */
d1887 1
a1887 1
			status = IEEE80211_REASON_MFP_POLICY;	/* XXX */
d1890 5
d1896 4
a1899 4
		    rsn.rsn_groupmgmtcipher !=
		    ic->ic_bss->ni_rsngroupmgmtcipher) {
			/* XXX satus not reason?! */
			status = IEEE80211_REASON_BAD_GROUP_MGMT_CIPHER;
a1954 2
	resp = reassoc ? IEEE80211_FC0_SUBTYPE_REASSOC_RESP :
	    IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
d1971 2
d1981 1
a1981 1
	const u_int8_t *rates, *xrates, *edcaie, *wmmie;
d2015 1
a2015 1
	rates = xrates = edcaie = wmmie = NULL;
d2031 8
d2205 323
d2534 1
a2534 1
ieee80211_recv_action(struct ieee80211com *ic, struct mbuf *m0,
d2540 1
a2540 1
	if (m0->m_len < sizeof(*wh) + 2) {
d2544 1
a2544 1
	wh = mtod(m0, struct ieee80211_frame *);
d2548 1
d2552 1
a2552 1
			/* NYI */
d2555 1
a2555 1
			/* NYI */
d2558 1
a2558 1
			/* NYI */
d2562 2
a2563 1
	case IEEE80211_CATEG_HT:
d2565 2
a2566 2
		case IEEE80211_ACTION_NOTIFYCW:
			/* NYI */
d2568 3
a2570 9
		}
		break;
	case IEEE80211_CATEG_SALT:
		switch (frm[1]) {
		case IEEE80211_ACTION_SALT_REQ:
			/* NYI */
			break;
		case IEEE80211_ACTION_SALT_RESP:
			/* NYI */
d2572 1
d2582 1
a2582 1
ieee80211_recv_mgmt(struct ieee80211com *ic, struct mbuf *m0,
d2587 1
a2587 1
		ieee80211_recv_probe_resp(ic, m0, ni, rxi, 0);
d2590 1
a2590 1
		ieee80211_recv_probe_resp(ic, m0, ni, rxi, 1);
d2594 1
a2594 1
		ieee80211_recv_probe_req(ic, m0, ni, rxi);
d2598 1
a2598 1
		ieee80211_recv_auth(ic, m0, ni, rxi);
d2602 1
a2602 1
		ieee80211_recv_assoc_req(ic, m0, ni, rxi, 0);
d2605 1
a2605 1
		ieee80211_recv_assoc_req(ic, m0, ni, rxi, 1);
d2609 1
a2609 1
		ieee80211_recv_assoc_resp(ic, m0, ni, 0);
d2612 1
a2612 1
		ieee80211_recv_assoc_resp(ic, m0, ni, 1);
d2615 1
a2615 1
		ieee80211_recv_deauth(ic, m0, ni);
d2618 1
a2618 1
		ieee80211_recv_disassoc(ic, m0, ni);
d2621 1
a2621 1
		ieee80211_recv_action(ic, m0, ni);
d2684 90
@


1.105
log
@Add some inline functions to test the presence of optional 802.11
header fields (Sequence Control, Address 4, QoS Control, +HTC) and
use them where appropriate.

Add ieee80211_get_qos() inline function to extract the QoS control
field of an 802.11 header instead of duplicating the same scary
code everywhere (the location of this field depends on the presence
of an Address 4 field).

Export ieee80211_up_to_ac() so that drivers can select the access
category to use based on the TID subfield of the QoS Control field.

Define more QoS-related bits for the RSN Capabilities field of RSN IE
(will be used later).
@
text
@a784 4
		case 3:	/* Fast BSS Transition IEEE 802.1X */
			return IEEE80211_AKM_FBT_8021X;
		case 4:	/* Fast BSS Transition PSK */
			return IEEE80211_AKM_FBT_PSK;
d824 1
d879 1
a879 1
	s = LE_READ_2(frm);
d885 3
a887 3
	while (s-- > 0) {
		/* ignore PMKIDs for now */
		frm += IEEE80211_PMKID_LEN;
d1613 22
@


1.104
log
@rework previously unused ieee80211_pwrsave() function, call it from
ieee80211_mgmt_output() and ieee80211_encap().
use new IEEE80211_C_APPMGT capability flag where appropriate.
rename ic_tim_mcast to ic_tim_mcast_pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.103 2008/08/29 12:14:53 damien Exp $	*/
d105 1
a105 1
ieee80211_get_hdrlen(const void *data)
d107 1
a107 2
	const u_int8_t *fc = data;
	u_int size = sizeof(struct ieee80211_frame);
d109 2
a110 2
	/* NB: doesn't work with control frames */
	KASSERT((fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL);
d112 6
a117 10
	if ((fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		size += IEEE80211_ADDR_LEN;		/* i_addr4 */
	if ((fc[0] & (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS)) {
		size += sizeof(u_int16_t);		/* i_qos */
		if (fc[1] & IEEE80211_FC1_ORDER)
			size += sizeof(u_int32_t);	/* i_ht */
	} else if ((fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT && (fc[1] & IEEE80211_FC1_ORDER))
		size += sizeof(u_int32_t);		/* i_ht */
d179 2
a180 2
	if (ic->ic_state != IEEE80211_S_SCAN &&
	    type != IEEE80211_FC0_TYPE_CTL) {
d183 2
a184 12
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
		    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS)) {
			if (dir == IEEE80211_FC1_DIR_DSTODS) {
				struct ieee80211_qosframe_addr4 *qwh4 =
				    (struct ieee80211_qosframe_addr4 *)wh;
				tid = qwh4->i_qos[0] & 0x0f;
			} else {
				struct ieee80211_qosframe *qwh =
				    (struct ieee80211_qosframe *)wh;
				tid = qwh->i_qos[0] & 0x0f;
			}
@


1.103
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.102 2008/08/28 17:56:24 damien Exp $	*/
d218 2
a219 2
	if ((ic->ic_caps & IEEE80211_C_PMGT) &&
	    ic->ic_opmode == IEEE80211_M_HOSTAP &&
d2001 2
a2002 2
	if (!(ic->ic_caps & IEEE80211_C_PMGT) ||
	    ic->ic_opmode != IEEE80211_M_HOSTAP ||
@


1.102
log
@unbreak IEEE80211_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.101 2008/08/27 09:05:04 damien Exp $	*/
a961 1
 * [tlv*] Frequency-Hopping (FH) Parameter Set
d977 2
a978 2
	u_int16_t capinfo, bintval, fhdwell;
	u_int8_t chan, bchan, fhindex, erp;
a1018 2
	fhdwell = 0;
	fhindex = 0;
a1031 11
		case IEEE80211_ELEMID_FHPARMS:
			if (ic->ic_phytype != IEEE80211_T_FH)
				break;
			if (frm[1] < 5) {
				ic->ic_stats.is_rx_elem_toosmall++;
				break;
			}
			fhdwell = LE_READ_2(frm + 2);
			chan = IEEE80211_FH_CHAN(frm[4], frm[5]);
			fhindex = frm[6];
			break;
a1032 2
			if (ic->ic_phytype == IEEE80211_T_FH)
				break;
d1105 1
a1105 1
	    chan != bchan && ic->ic_phytype != IEEE80211_T_FH) {
a1111 3
		 *     But we should take it for FH phy because
		 *     the rssi value should be correct even for
		 *     different hop pattern in FH.
a1248 2
	ni->ni_fhdwell = fhdwell;
	ni->ni_fhindex = fhindex;
a1638 2
	ni->ni_fhdwell = ic->ic_bss->ni_fhdwell;
	ni->ni_fhindex = ic->ic_bss->ni_fhindex;
@


1.101
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.100 2008/08/14 16:07:58 damien Exp $	*/
d1956 1
a1956 1
		DPRINTF(("action frame category %d not handled\n", categ));
@


1.100
log
@move the HostAP bridge code and the delivery of data frames to ether_input
to a separate ieee80211_deliver_data() function.
this will later be called by the A-MSDU deaggregation routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.98 2008/08/13 17:44:45 damien Exp $	*/
d76 1
d79 1
d82 1
d85 1
d88 1
d91 1
d217 1
d247 1
a247 1

d277 1
d336 2
a337 1
		case IEEE80211_M_MONITOR:
d387 1
d392 1
d437 1
d442 1
d480 1
d484 1
a515 1
	struct ieee80211_node *ni1;
a517 1
	int error, len;
d536 1
d540 3
d570 1
d996 1
d999 1
d1108 1
d1218 1
d1220 1
d1281 5
a1285 1
	if (ic->ic_opmode == IEEE80211_M_IBSS || (is_new && isprobe)) {
d1296 1
d1382 1
d1417 1
d1424 1
d1430 1
d1671 1
a1820 1
	struct ifnet *ifp = &ic->ic_if;
d1841 1
d1844 1
a1844 1
			if (ifp->if_flags & IFF_DEBUG)
d1847 1
a1847 1
				    ifp->if_xname,
d1853 1
a1866 1
	struct ifnet *ifp = &ic->ic_if;
d1887 1
d1890 1
a1890 1
			if (ifp->if_flags & IFF_DEBUG)
d1893 1
a1893 1
				    ifp->if_xname,
d1899 1
d1972 1
d1976 1
d1980 1
d1987 1
d2011 1
d2063 1
@


1.99
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d65 2
a135 4
	struct ether_header *eh;
	struct mbuf *m1;
	int error, hdrlen, len;
	u_int8_t dir, type, subtype;
d137 2
a138 1
	int tid;
d370 1
a370 64
		eh = mtod(m, struct ether_header *);

		if ((ic->ic_flags & IEEE80211_F_RSNON) &&
		    !ni->ni_port_valid &&
		    eh->ether_type != htons(ETHERTYPE_PAE)) {
			DPRINTF(("port not valid: %s\n",
			    ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_unauth++;
			goto err;
		}
		ifp->if_ipackets++;

		/*
		 * Perform as a bridge within the AP.  XXX we do not bridge
		 * 802.1X frames as suggested in C.1.1 of IEEE Std 802.1X.
		 */
		m1 = NULL;
		if (ic->ic_opmode == IEEE80211_M_HOSTAP &&
		    !(ic->ic_flags & IEEE80211_F_NOBRIDGE) &&
		    eh->ether_type != htons(ETHERTYPE_PAE)) {
			if (ETHER_IS_MULTICAST(eh->ether_dhost)) {
				m1 = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
				if (m1 == NULL)
					ifp->if_oerrors++;
				else
					m1->m_flags |= M_MCAST;
			} else {
				struct ieee80211_node *ni;
				ni = ieee80211_find_node(ic, eh->ether_dhost);
				if (ni != NULL) {
					if (ni->ni_associd != 0) {
						m1 = m;
						m = NULL;
					}
				}
			}
			if (m1 != NULL) {
				len = m1->m_pkthdr.len;
				IFQ_ENQUEUE(&ifp->if_snd, m1, NULL, error);
				if (error)
					ifp->if_oerrors++;
				else {
					if (m != NULL)
						ifp->if_omcasts++;
					ifp->if_obytes += len;
					if_start(ifp);
				}
			}
		}
		if (m != NULL) {
#if NBPFILTER > 0
			/*
			 * If we forward frame into transmitter of the AP,
			 * we don't need to duplicate for DLT_EN10MB.
			 */
			if (ifp->if_bpf && m1 == NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
			if ((ic->ic_flags & IEEE80211_F_RSNON) &&
			    eh->ether_type == htons(ETHERTYPE_PAE))
				ieee80211_eapol_key_input(ic, m, ni);
			else
				ether_input_mbuf(ifp, m);
		}
d496 74
d573 1
a573 1
	struct ieee80211_frame wh;
d582 1
a582 1
	memcpy(&wh, mtod(m, caddr_t), sizeof(wh));
d610 3
a612 4
		/* not yet supported */
		DPRINTF(("discard DS to DS frame\n"));
		m_freem(m);
		return NULL;
@


1.98
log
@one should never use sizeof(struct llc) since 802.2 LLC headers
have a variable length.  use LLC_SNAPFRAMELEN instead (which happen
to be equal to sizeof(struct llc)) as we only deal with LLC+SNAP
headers.

some indentation tweaks while i'm here.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.97 2008/08/12 20:07:13 damien Exp $	*/
d416 1
@


1.97
log
@adopt the integrity group cipher of the AP at association time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.96 2008/08/12 19:56:59 damien Exp $	*/
d566 2
a567 2
	if (m->m_len < hdrlen + sizeof(*llc)) {
		m = m_pullup(m, hdrlen + sizeof(*llc));
d579 1
a579 1
		m_adj(m, hdrlen + sizeof(*llc) - sizeof(*eh));
d724 1
a724 1
		case 0: /* use group data cipher suite */
d726 1
a726 1
		case 1: /* WEP-40 */
d728 1
a728 1
		case 2: /* TKIP */
d730 1
a730 1
		case 4: /* CCMP (RSNA default) */
d732 1
a732 1
		case 5: /* WEP-104 */
d738 1
a738 1
		case 0: /* use group data cipher suite */
d740 1
a740 1
		case 1: /* WEP-40 */
d742 1
a742 1
		case 2: /* TKIP */
d744 1
a744 1
		case 4: /* CCMP (RSNA default) */
d746 1
a746 1
		case 5: /* WEP-104 */
@


1.96
log
@add the code to encrypt/decrypt management frames, retrieve key id
from MMIE etc...
this code can't be triggered as no drivers claim MFP capability yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.95 2008/08/12 19:50:39 damien Exp $	*/
d1608 1
d1962 3
@


1.95
log
@clear Tx_Rx protection bits properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.94 2008/08/12 19:45:22 damien Exp $	*/
d454 24
@


1.94
log
@do not drop frames that have an invalid IE, just stop processing
more IEs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.93 2008/08/12 19:42:37 damien Exp $	*/
d1738 3
a1740 1
	}
@


1.93
log
@populate ieee80211_recv_action(), does nothing yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.92 2008/08/12 19:29:07 damien Exp $	*/
d972 1
a972 1
			return;
d1262 1
a1262 1
			return;
d1416 1
a1416 1
			return;
d1659 1
a1659 1
			return;
@


1.92
log
@new SHA-256 based AKMPs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.91 2008/08/12 19:21:04 damien Exp $	*/
d509 6
d1835 1
d1842 45
a1886 1
	/* TBD */
@


1.91
log
@add/process group integrity cipher suite in RSN IEs.
add support for MFP negotiation during association.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.90 2008/08/12 17:53:13 damien Exp $	*/
d728 9
a736 3
	/* from IEEE Std 802.11i-2004 - Table 20dc */
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0 ||	/* WPA */
	    memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN */
d739 1
a739 1
			return IEEE80211_AKM_IEEE8021X;
d742 8
d782 1
a782 1
	rsn->rsn_akms = IEEE80211_AKM_IEEE8021X;
@


1.90
log
@Change the way we process EAPOL-Key frames.
Free the mbuf in the ieee80211_eapol_key_input() function.
Do not assume the frame is contiguous, call m_pullup2() if it is not.
We need the frame to be contiguous to process KDEs efficiently in
EAPOL-Key frames (just like we process IEs in management frames).
However, there are drivers like upgt(4) that use m_devget() in the
RX path.  m_devget() can return fragmented mbuf chains.
Notice that we should do the same m_pullup2() for management frames.
This will be done later.
Remove the ic_recv_eapol callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.89 2008/08/02 08:35:48 damien Exp $	*/
d692 15
a706 3
	/* from IEEE Std 802.11i-2004 - Table 20da */
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0 ||	/* WPA */
	    memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN */
d708 1
a708 1
		case 0:	/* use group cipher suite */
d710 1
a710 1
		case 1:	/* WEP-40 */
d712 1
a712 1
		case 2:	/* TKIP */
d714 1
a714 1
		case 4:	/* CCMP (RSNA default) */
d716 1
a716 1
		case 5:	/* WEP-104 */
d718 2
d764 2
d772 1
a772 1
	/* read Group Cipher Suite field */
d836 5
d1170 1
d1524 21
@


1.89
log
@do not use IEEE80211_QOS_TID.  its definition in ieee80211.h is
wrong.  hard-code 0xf for now.  will be fixed post-release.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.88 2008/08/02 08:20:16 damien Exp $	*/
d429 3
a431 4
			    eh->ether_type == htons(ETHERTYPE_PAE)) {
				(*ic->ic_recv_eapol)(ic, m, ni);
				m_freem(m);
			} else
@


1.88
log
@Drop frames that are received unencrypted when WEP is on or when
WPA is on and RX protection for TA is on.
Keep track of the TX/RX protection for each node when WPA is on.

tested by djm@@ (ral+wpa), ckuethe@@ (ath-noenc) and krw@@ (wpi<->ral+wpa).
hints from bluhm@@
has been in snaps for a few days.

pointed out by bluhm@@ something like 1 year ago but we did not have
the right infrastructure to fix it properly at that time.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.87 2008/07/28 19:42:13 damien Exp $	*/
d189 1
a189 1
				tid = qwh4->i_qos[0] & IEEE80211_QOS_TID;
d193 1
a193 1
				tid = qwh->i_qos[0] & IEEE80211_QOS_TID;
@


1.87
log
@ignore PS mode changes and PS-Poll from non-associated STAs.
keep track of the number of associated STAs in PS mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.86 2008/07/28 10:38:05 damien Exp $	*/
d334 11
a344 3
		if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
			if (ic->ic_flags &
			    (IEEE80211_F_WEPON | IEEE80211_F_RSNON)) {
a350 3
			} else {
				ic->ic_stats.is_rx_nowep++;
				goto out;
d352 5
a356 2
		} else if (!(rxi->rxi_flags & IEEE80211_RXI_HWDEC)) {
			/* XXX */
d358 1
d373 2
a374 1
		if ((ic->ic_flags & IEEE80211_F_RSNON) && !ni->ni_port_valid &&
@


1.86
log
@missing "goto err".
fix IEEE80211_DEBUG builds.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.85 2008/07/27 18:24:01 damien Exp $	*/
d74 2
a75 1
void	ieee80211_recv_pspoll(struct ieee80211com *, struct mbuf *);
d214 10
a223 11
	    ic->ic_state == IEEE80211_S_RUN &&
	    dir == IEEE80211_FC1_DIR_TODS) {
		if ((wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) &&
		    ni->ni_pwrsave == IEEE80211_PS_AWAKE) {
			/* turn on PS mode */
			ni->ni_pwrsave = IEEE80211_PS_DOZE;
			DPRINTF(("power saving on for %s\n",
			    ether_sprintf(wh->i_addr2)));
		}
		if (!(wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) &&
		    ni->ni_pwrsave == IEEE80211_PS_DOZE) {
d226 3
a228 2
			DPRINTF(("power saving off for %s\n",
			    ether_sprintf(wh->i_addr2)));
d498 1
a498 1
			ieee80211_recv_pspoll(ic, m);
d540 1
a540 1
		m_adj(m, hdrlen + sizeof(struct llc) - sizeof(*eh));
d1819 2
a1820 1
ieee80211_recv_pspoll(struct ieee80211com *ic, struct mbuf *m)
a1824 1
	struct ieee80211_node *ni;
d1828 2
a1829 1
	    ic->ic_opmode != IEEE80211_M_HOSTAP)
a1841 4
		return;
	}
	if ((ni = ieee80211_find_node(ic, psp->i_ta)) == NULL) {
		DPRINTF(("no node found for %s", ether_sprintf(psp->i_ta)));
@


1.85
log
@sanitize RX path a bit.
make sure drivers pass a contiguous header, check header length earlier.
fix checking of frames sequence number for frames containing an Address 4
field (required for future work).
fix processing of control frames (only pspoll for now).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_input.c,v 1.84 2008/07/27 14:21:15 damien Exp $	*/
d174 1
d1523 2
a1525 2
		resp = reassoc ? IEEE80211_FC0_SUBTYPE_REASSOC_RESP :
		    IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
d1560 1
a1560 1
		DPRINTF(("%s: frame too short\n"));
d1849 1
a1849 1
		    ether_sprintf(psp->i_addr2)));
@


1.84
log
@s/IEEE80211_DPRINTF/DPRINTF/
automatically prepend __func__ to output.

deobfuscates debug messages a bit.
no binary change unless compiled with IEEE80211_DEBUG.
@
text
@d1 1
a1 2
/*	$NetBSD: ieee80211_input.c,v 1.24 2004/05/31 11:12:24 dyoung Exp $	*/
/*	$OpenBSD: ieee80211_input.c,v 1.83 2008/07/21 19:27:26 damien Exp $	*/
d137 2
a138 1
	u_int16_t orxseq, nrxseq;
d140 1
d143 4
d149 2
a150 2
	 * In monitor mode, send everything directly to bpf.
	 * XXX may want to include the CRC
d152 2
a153 6
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		goto out;

	/* do not process frames w/o i_addr2 any further */
	if (m->m_pkthdr.len < sizeof(struct ieee80211_frame_min)) {
		DPRINTF(("frame too short (1), len %u\n", m->m_pkthdr.len));
d161 1
a161 1
		DPRINTF(("packet with wrong version: %x\n", wh->i_fc[0]));
d169 34
a202 9
	/*
	 * NB: We are not yet prepared to handle control frames,
	 *     but permitting drivers to send them to us allows
	 *     them to go through bpf tapping at the 802.11 layer.
	 */
	if (m->m_pkthdr.len < sizeof(struct ieee80211_frame)) {
		DPRINTF(("frame too short (2), len %u\n", m->m_pkthdr.len));
		ic->ic_stats.is_rx_tooshort++;
		goto out;
a206 22
		if (type == IEEE80211_FC0_TYPE_DATA &&
		    (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_QOS)) {
			struct ieee80211_qosframe *qwh =
			    (struct ieee80211_qosframe *)wh;
			int tid = qwh->i_qos[0] & IEEE80211_QOS_TID;
			orxseq = ni->ni_qos_rxseqs[tid];
			nrxseq = ni->ni_qos_rxseqs[tid] =
			    letoh16(*(u_int16_t *)qwh->i_seq) >>
				IEEE80211_SEQ_SEQ_SHIFT;
		} else {
			orxseq = ni->ni_rxseq;
			nrxseq = ni->ni_rxseq =
			    letoh16(*(u_int16_t *)wh->i_seq) >>
				IEEE80211_SEQ_SEQ_SHIFT;
		}
		/* TODO: fragment */
		if ((wh->i_fc[1] & IEEE80211_FC1_RETRY) &&
		    orxseq == nrxseq) {
			/* duplicate, silently discarded */
			ic->ic_stats.is_rx_dup++; /* XXX per-station stat */
			goto out;
		}
d210 4
a213 2
	if ((ic->ic_opmode == IEEE80211_M_HOSTAP ||
	     ic->ic_opmode == IEEE80211_M_IBSS) && ic->ic_set_tim != NULL) {
d215 5
a219 8
		    ni->ni_pwrsave == 0) {
			/* turn on power save mode */

			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: power save mode on for %s\n",
				    ifp->if_xname, ether_sprintf(wh->i_addr2));

			ni->ni_pwrsave = IEEE80211_PS_SLEEP;
d222 5
a226 2
		    ni->ni_pwrsave != 0) {
			/* turn off power save mode, dequeue stored packets */
a227 1
			ni->ni_pwrsave = 0;
d230 1
a230 4
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: power save mode off for %s\n",
				    ifp->if_xname, ether_sprintf(wh->i_addr2));

d260 1
a260 1
				 * In IEEE802.11 network, multicast packet
a331 2
		hdrlen = ieee80211_get_hdrlen(wh);

d410 1
a410 1
			 * If we forward packet into transmitter of the AP,
a492 2
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
			goto out;
d494 2
a495 7
		if (subtype == IEEE80211_FC0_SUBTYPE_PS_POLL) {
			/* XXX statistic */
			/* Dump out a single packet from the host */
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: got power save probe from %s\n",
				    ifp->if_xname,
				    ether_sprintf(wh->i_addr2));
d497 1
d502 1
a502 1
		DPRINTF(("bad packet type %x\n", type));
d887 1
a887 1
	 * does not process incoming packets) and adhoc-demo (which
d898 5
a906 5
	/* make sure all mandatory fixed fields are present */
	if (efrm - frm < 12) {
		DPRINTF(("frame too short\n"));
		return;
	}
d1279 1
a1279 1
	const u_int8_t *frm, *efrm;
a1281 4
	wh = mtod(m0, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m0, u_int8_t *) + m0->m_len;

d1283 1
a1283 1
	if (efrm - frm < 6) {
d1287 3
d1339 5
a1347 8
	resp = reassoc ? IEEE80211_FC0_SUBTYPE_REASSOC_RESP :
	    IEEE80211_FC0_SUBTYPE_ASSOC_RESP;

	/* make sure all mandatory fixed fields are present */
	if (efrm - frm < (reassoc ? 10 : 4)) {
		DPRINTF(("frame too short\n"));
		return;
	}
d1523 2
d1557 5
a1565 5
	/* make sure all mandatory fixed fields are present */
	if (efrm - frm < 6) {
		DPRINTF(("%s: frame too short\n"));
		return;
	}
d1679 1
a1679 1
	const u_int8_t *frm, *efrm;
a1681 4
	wh = mtod(m0, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m0, u_int8_t *) + m0->m_len;

d1683 1
a1683 1
	if (efrm - frm < 2) {
d1687 3
d1724 1
a1724 1
	const u_int8_t *frm, *efrm;
a1726 4
	wh = mtod(m0, struct ieee80211_frame *);
	frm = (const u_int8_t *)&wh[1];
	efrm = mtod(m0, u_int8_t *) + m0->m_len;

d1728 1
a1728 1
	if (efrm - frm < 2) {
d1732 3
d1817 1
a1817 1
ieee80211_recv_pspoll(struct ieee80211com *ic, struct mbuf *m0)
d1820 1
a1822 1
	struct mbuf *m;
d1825 2
a1826 1
	if (ic->ic_set_tim == NULL)	/* no powersaving functionality */
d1829 10
a1838 6
	wh = mtod(m0, struct ieee80211_frame *);

	if ((ni = ieee80211_find_node(ic, wh->i_addr2)) == NULL) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s sent bogus power save poll\n",
			    ifp->if_xname, ether_sprintf(wh->i_addr2));
d1841 2
a1842 6

	memcpy(&aid, wh->i_dur, sizeof(wh->i_dur));
	if ((aid & 0xc000) != 0xc000) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s sent bogus aid %x\n",
			    ifp->if_xname, ether_sprintf(wh->i_addr2), aid);
d1845 1
a1845 1

d1847 2
a1848 4
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s aid %x doesn't match pspoll "
			    "aid %x\n", ifp->if_xname,
			    ether_sprintf(wh->i_addr2), ni->ni_associd, aid);
d1852 1
a1852 2
	/* Okay, take the first queued packet and put it out... */

d1854 1
a1854 5
	if (m == NULL) {
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s sent pspoll, "
			    "but no packets are saved\n",
			    ifp->if_xname, ether_sprintf(wh->i_addr2));
d1856 2
a1857 9
	}
	wh = mtod(m, struct ieee80211_frame *);

	/*
	 * If this is the last packet, turn off the TIM fields.
	 * If there are more packets, set the more packets bit.
	 */

	if (IF_IS_EMPTY(&ni->ni_savedq))
d1859 3
a1861 1
	else
d1863 1
a1863 5

	if (ifp->if_flags & IFF_DEBUG)
		printf("%s: enqueued power saving packet for station %s\n",
		    ifp->if_xname, ether_sprintf(ni->ni_macaddr));

@


1.83
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.82 2008/07/21 19:05:21 damien Exp $	*/
d152 1
a152 2
		IEEE80211_DPRINTF2(("%s: frame too short (1), len %u\n",
		    __func__, m->m_pkthdr.len));
d160 1
a160 2
		IEEE80211_DPRINTF(("%s: packet with wrong version: %x\n",
		    __func__, wh->i_fc[0]));
d174 1
a174 2
		IEEE80211_DPRINTF2(("%s: frame too short (2), len %u\n",
		    __func__, m->m_pkthdr.len));
d249 2
a250 3
				IEEE80211_DPRINTF(
				    ("%s: discard frame from SA %s\n",
				    __func__, ether_sprintf(wh->i_addr2)));
d279 2
a280 3
				IEEE80211_DPRINTF2(
				    ("%s: discard data frame to DA %s\n",
				    __func__, ether_sprintf(wh->i_addr3)));
d296 2
a297 3
				IEEE80211_DPRINTF2(
				    ("%s: discard data frame to BSS %s\n",
				    __func__, ether_sprintf(wh->i_addr1)));
d303 1
a303 2
				IEEE80211_DPRINTF(("%s: "
				    "data from unknown src %s\n", __func__,
d316 1
a316 2
				IEEE80211_DPRINTF(("%s: "
				    "data from unassoc src %s\n", __func__,
d355 2
a356 3
			IEEE80211_DPRINTF(("%s: "
			    "decapsulation error for src %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
d364 2
a365 2
			IEEE80211_DPRINTF(("%s: port not valid: %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
d508 1
a508 1
		IEEE80211_DPRINTF(("%s: bad packet type %x\n", __func__, type));
d565 1
a565 1
		IEEE80211_DPRINTF(("%s: discard DS to DS frame\n", __func__));
a666 1
	/* check IE length */
a667 2
		IEEE80211_DPRINTF(("%s: invalid EDCA parameter set IE;"
		    " length %u, expecting 18\n", __func__, frm[1]));
a676 1
	/* check IE length */
a677 2
		IEEE80211_DPRINTF(("%s: invalid WMM parameter set IE;"
		    " length %u, expecting 24\n", __func__, frm[1]));
a821 1
	/* check IE length */
a822 2
		IEEE80211_DPRINTF(("%s: invalid RSN IE;"
		    " length %u, expecting at least 2\n", __func__, frm[1]));
a832 1
	/* check IE length */
a833 2
		IEEE80211_DPRINTF(("%s: invalid WPA IE;"
		    " length %u, expecting at least 6\n", __func__, frm[1]));
d910 1
a910 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d991 2
a992 2
			IEEE80211_DPRINTF2(("%s: element id %u/len %u "
			    "ignored\n", __func__, *frm, frm[1]));
d1000 1
a1000 2
		IEEE80211_DPRINTF(("%s: invalid supported rates element\n",
		    __func__));
d1005 1
a1005 1
		IEEE80211_DPRINTF(("%s: invalid SSID element\n", __func__));
d1013 2
a1014 3
		IEEE80211_DPRINTF(("%s: ignore %s with invalid channel "
		    "%u\n", __func__, isprobe ?
		    "probe response" : "beacon", chan));
d1031 2
a1032 3
		IEEE80211_DPRINTF(("%s: ignore %s on channel %u marked "
		    "for channel %u\n", __func__, isprobe ?
		    "probe response" : "beacon", bchan, chan));
d1082 1
a1082 2
			IEEE80211_DPRINTF((
			    "[%s] erp change: was 0x%x, now 0x%x\n",
d1232 1
a1232 2
		IEEE80211_DPRINTF(("%s: invalid supported rates element\n",
		    __func__));
d1237 1
a1237 1
		IEEE80211_DPRINTF(("%s: invalid SSID element\n", __func__));
d1243 1
a1243 1
		IEEE80211_DPRINTF(("%s: SSID mismatch\n", __func__));
d1249 1
a1249 1
		IEEE80211_DPRINTF(("%s: wildcard SSID rejected", __func__));
d1258 2
a1259 2
		IEEE80211_DPRINTF(("%s: new probe req from %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1267 2
a1268 2
		IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1294 1
a1294 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d1300 2
a1301 2
	IEEE80211_DPRINTF(("%s: auth %d seq %d from %s\n",
	    __func__, algo, seq, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1305 2
a1306 3
		IEEE80211_DPRINTF(("%s: unsupported authentication "
		    "algorithm %d from %s\n",
		    __func__, algo, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1355 1
a1355 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d1359 2
a1360 2
		IEEE80211_DPRINTF(("%s: ignore other bss from %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1405 1
a1405 2
		IEEE80211_DPRINTF(("%s: invalid supported rates element\n",
		    __func__));
d1410 1
a1410 1
		IEEE80211_DPRINTF(("%s: invalid SSID element\n", __func__));
d1416 1
a1416 1
		IEEE80211_DPRINTF(("%s: SSID mismatch\n", __func__));
d1423 2
a1424 3
		IEEE80211_DPRINTF(
		    ("%s: deny %sassoc from %s, not authenticated\n",
		    __func__, reassoc ? "re" : "",
d1571 1
a1571 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d1620 1
a1620 2
		IEEE80211_DPRINTF(("%s: invalid supported rates element\n",
		    __func__));
d1627 2
a1628 2
		IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
d1696 1
a1696 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d1742 1
a1742 1
		IEEE80211_DPRINTF(("%s: frame too short\n", __func__));
d1819 2
a1820 2
		IEEE80211_DPRINTF(("%s: mgmt frame with subtype 0x%x not "
		    "handled\n", __func__, subtype));
@


1.82
log
@move processing of EAPOL frames away from ieee80211_{input,output}.c
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.81 2008/07/21 18:43:18 damien Exp $	*/
d64 1
a632 12

/* unaligned little endian access */
#define LE_READ_2(p)					\
	((u_int16_t)					\
	 ((((const u_int8_t *)(p))[0]) |		\
	  (((const u_int8_t *)(p))[1] <<  8)))
#define LE_READ_4(p)					\
	((u_int32_t)					\
	 ((((const u_int8_t *)(p))[0])       |		\
	  (((const u_int8_t *)(p))[1] <<  8) |		\
	  (((const u_int8_t *)(p))[2] << 16) |		\
	  (((const u_int8_t *)(p))[3] << 24)))
@


1.81
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.80 2008/06/09 07:07:16 djm Exp $	*/
a64 2
#include <dev/rndvar.h>

a72 4
int	ieee80211_parse_rsn(struct ieee80211com *, const u_int8_t *,
	    struct ieee80211_rsnparams *);
int	ieee80211_parse_wpa(struct ieee80211com *, const u_int8_t *,
	    struct ieee80211_rsnparams *);
a90 19
void	ieee80211_recv_4way_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_4way_msg2(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *,
	    const u_int8_t *);
void	ieee80211_recv_4way_msg3(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_4way_msg4(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_4way_msg2or4(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_rsn_group_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_wpa_group_msg1(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_group_msg2(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
void	ieee80211_recv_eapol_key_req(struct ieee80211com *,
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
a1863 855
	}
}

/* unaligned big endian access */
#define BE_READ_2(p)						\
	((u_int16_t)(p)[0] << 8 | (u_int16_t)(p)[1])

#define BE_READ_8(p)						\
	((u_int64_t)(p)[0] << 56 | (u_int64_t)(p)[1] << 48 |	\
	 (u_int64_t)(p)[2] << 40 | (u_int64_t)(p)[3] << 32 |	\
	 (u_int64_t)(p)[4] << 24 | (u_int64_t)(p)[5] << 16 |	\
	 (u_int64_t)(p)[6] <<  8 | (u_int64_t)(p)[7])

/* unaligned little endian access */
#define LE_READ_6(p)						\
	((u_int64_t)(p)[5] << 40 | (u_int64_t)(p)[4] << 32 |	\
	 (u_int64_t)(p)[3] << 24 | (u_int64_t)(p)[2] << 16 |	\
	 (u_int64_t)(p)[1] <<  8 | (u_int64_t)(p)[0])

/*
 * 4-Way Handshake Message 1 is sent by the authenticator to the supplicant
 * (see 8.5.3.1).
 */
void
ieee80211_recv_4way_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_ptk tptk;
	const u_int8_t *frm, *efrm;
	const u_int8_t *pmkid;
	const u_int8_t *pmk;

	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (ni->ni_replaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* save authenticator's nonce (ANonce) */
	memcpy(ni->ni_nonce, key->nonce, EAPOL_KEY_NONCE_LEN);

	/* parse key data field (may contain an encapsulated PMKID) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	pmkid = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_PMKID:
					pmkid = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* check that the PMKID KDE is valid (if present) */
	if (pmkid != NULL && pmkid[1] < 4 + 16)
		return;

	/* generate a new supplicant's nonce (SNonce) */
	arc4random_buf(ic->ic_nonce, EAPOL_KEY_NONCE_LEN);

	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, pmkid)) == NULL) {
		/* no PMK configured for this STA/PMKID */
		return;
	}
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ni->ni_macaddr,
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator using TPTK */
	(void)ieee80211_send_4way_msg2(ic, ni, key->replaycnt, &tptk);
}

/*
 * 4-Way Handshake Message 2 is sent by the supplicant to the authenticator
 * (see 8.5.3.2).
 */
void
ieee80211_recv_4way_msg2(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni,
    const u_int8_t *rsnie)
{
	struct ieee80211_ptk tptk;
	const u_int8_t *pmk;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKSTART &&
	    ni->ni_rsn_state != RSNA_PTKCALCNEGOTIATING) {
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
		return;
	}
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING;

	/* replay counter has already been verified by caller */

	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, NULL)) == NULL) {
		/* no PMK configured for this STA */
		return;	/* will timeout.. */
	}
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ic->ic_myaddr,
	    ni->ni_macaddr, ni->ni_nonce, key->nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, tptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;	/* will timeout.. */
	}

	timeout_del(&ni->ni_rsn_timeout);
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING_2;
	ni->ni_rsn_retries = 0;

	/* install TPTK as PTK now that MIC is verified */
	memcpy(&ni->ni_ptk, &tptk, sizeof(tptk));

	/*
	 * The RSN IE must match bit-wise with what the STA included in its
	 * (Re)Association Request.
	 */
	if (ni->ni_rsnie == NULL || rsnie[1] != ni->ni_rsnie[1] ||
	    memcmp(rsnie, ni->ni_rsnie, 2 + rsnie[1]) != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_RSN_DIFFERENT_IE);
		ieee80211_node_leave(ic, ni);
		return;
	}

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 2, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 3 to supplicant */
	(void)ieee80211_send_4way_msg3(ic, ni);
}

/*
 * 4-Way Handshake Message 3 is sent by the authenticator to the supplicant
 * (see 8.5.3.3).
 */
void
ieee80211_recv_4way_msg3(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_ptk tptk;
	struct ieee80211_key *k;
	const u_int8_t *frm, *efrm;
	const u_int8_t *rsnie1, *rsnie2, *gtk;
	const u_int8_t *pmk;
	u_int16_t info, reason = 0;

	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (ni->ni_replaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}

	/* check that ANonce matches that of message 1 */
	if (memcmp(key->nonce, ni->ni_nonce, EAPOL_KEY_NONCE_LEN) != 0) {
		IEEE80211_DPRINTF(("%s: ANonce does not match msg 1/4\n",
		    __func__));
		return;
	}
	/* retrieve PMK and derive TPTK */
	if ((pmk = ieee80211_get_pmk(ic, ni, NULL)) == NULL) {
		/* no PMK configured for this STA */
		return;
	}
	ieee80211_derive_ptk(pmk, IEEE80211_PMK_LEN, ni->ni_macaddr,
	    ic->ic_myaddr, key->nonce, ic->ic_nonce, (u_int8_t *)&tptk,
	    sizeof(tptk));

	info = BE_READ_2(key->info);

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, tptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/* install TPTK as PTK now that MIC is verified */
	memcpy(&ni->ni_ptk, &tptk, sizeof(tptk));

	/* if encrypted, decrypt Key Data field using KEK */
	if ((info & EAPOL_KEY_ENCRYPTED) &&
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
		return;
	}

	/* parse key data field */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	/*
	 * Some WPA1+WPA2 APs (like hostapd) appear to include both WPA and
	 * RSN IEs in message 3/4.  We only take into account the IE of the
	 * version of the protocol we negotiated at association time.
	 */
	rsnie1 = rsnie2 = gtk = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_RSN:
			if (ni->ni_rsnprotos != IEEE80211_PROTO_RSN)
				break;
			if (rsnie1 == NULL)
				rsnie1 = frm;
			else if (rsnie2 == NULL)
				rsnie2 = frm;
			/* ignore others if more than two RSN IEs */
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_GTK:
					gtk = frm;
					break;
				}
			} else if (memcmp(&frm[2], MICROSOFT_OUI, 3) == 0) {
				switch (frm[5]) {
				case 1:	/* WPA */
					if (ni->ni_rsnprotos !=
					    IEEE80211_PROTO_WPA)
						break;
					rsnie1 = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* first WPA/RSN IE is mandatory */
	if (rsnie1 == NULL) {
		IEEE80211_DPRINTF(("%s: missing RSN IE\n", __func__));
		return;
	}
	/* key data must be encrypted if GTK is included */
	if (gtk != NULL && !(info & EAPOL_KEY_ENCRYPTED)) {
		IEEE80211_DPRINTF(("%s: GTK not encrypted\n", __func__));
		return;
	}
	/*
	 * Check that first WPA/RSN IE is identical to the one received in
	 * the beacon or probe response frame.
	 */
	if (ni->ni_rsnie == NULL || rsnie1[1] != ni->ni_rsnie[1] ||
	    memcmp(rsnie1, ni->ni_rsnie, 2 + rsnie1[1]) != 0) {
		reason = IEEE80211_REASON_RSN_DIFFERENT_IE;
		goto deauth;
	}

	/*
	 * If a second RSN information element is present, use its pairwise
	 * cipher suite or deauthenticate.
	 */
	if (rsnie2 != NULL) {
		struct ieee80211_rsnparams rsn;

		if (ieee80211_parse_rsn(ic, rsnie2, &rsn) == 0) {
			if (rsn.rsn_akms != ni->ni_rsnakms ||
			    rsn.rsn_groupcipher != ni->ni_rsngroupcipher ||
			    rsn.rsn_nciphers != 1 ||
			    !(rsn.rsn_ciphers & ic->ic_rsnciphers)) {
				reason = IEEE80211_REASON_BAD_PAIRWISE_CIPHER;
				goto deauth;
			}
			/* use pairwise cipher suite of second RSN IE */
			ni->ni_rsnciphers = rsn.rsn_ciphers;
			ni->ni_rsncipher = ni->ni_rsnciphers;
		}
	}

	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);
	ni->ni_replaycnt_ok = 1;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 3, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 4 to authenticator */
	if (ieee80211_send_4way_msg4(ic, ni) != 0)
		return;	/* ..authenticator will retry */

	if (info & EAPOL_KEY_INSTALL) {
		u_int64_t prsc;

		/* check that key length matches that of pairwise cipher */
		if (BE_READ_2(key->keylen) !=
		    ieee80211_cipher_keylen(ni->ni_rsncipher)) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* install the PTK */
		prsc = (gtk == NULL) ? LE_READ_6(key->rsc) : 0;
		k = &ni->ni_pairwise_key;
		ieee80211_map_ptk(&ni->ni_ptk, ni->ni_rsncipher, prsc, k);
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
	}
	if (gtk != NULL) {
		u_int64_t rsc;
		u_int8_t kid;

		/* check that the GTK KDE is valid */
		if (gtk[1] < 4 + 2) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* check that key length matches that of group cipher */
		if (gtk[1] - 6 !=
		    ieee80211_cipher_keylen(ni->ni_rsngroupcipher)) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
		/* install the GTK */
		kid = gtk[6] & 3;
		rsc = LE_READ_6(key->rsc);
		k = &ic->ic_nw_keys[kid];
		ieee80211_map_gtk(&gtk[8], ni->ni_rsngroupcipher, kid,
		    gtk[6] & (1 << 2), rsc, k);
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			reason = IEEE80211_REASON_AUTH_LEAVE;
			goto deauth;
		}
	}
	if (info & EAPOL_KEY_SECURE) {
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2) {
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
		}
	}
 deauth:
	if (reason != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    reason);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	}
}

/*
 * 4-Way Handshake Message 4 is sent by the supplicant to the authenticator
 * (see 8.5.3.4).
 */
void
ieee80211_recv_4way_msg4(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_state != RSNA_PTKINITNEGOTIATING) {
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
		return;
	}

	/* replay counter has already been verified by caller */

	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;	/* will timeout.. */
	}

	timeout_del(&ni->ni_rsn_timeout);
	ni->ni_rsn_state = RSNA_PTKINITDONE;
	ni->ni_rsn_retries = 0;

	if (ni->ni_rsncipher != IEEE80211_CIPHER_USEGROUP) {
		/* install the PTK */
		struct ieee80211_key *k = &ni->ni_pairwise_key;
		ieee80211_map_ptk(&ni->ni_ptk, ni->ni_rsncipher, 0, k);
		if ((*ic->ic_set_key)(ic, ni, k) != 0) {
			IEEE80211_SEND_MGMT(ic, ni,
			    IEEE80211_FC0_SUBTYPE_DEAUTH,
			    IEEE80211_REASON_ASSOC_TOOMANY);
			ieee80211_node_leave(ic, ni);
			return;
		}
	}
	if (ic->ic_opmode != IEEE80211_M_IBSS || ++ni->ni_key_count == 2) {
		IEEE80211_DPRINTF(("%s: marking port %s valid\n", __func__,
		    ether_sprintf(ni->ni_macaddr)));
		ni->ni_port_valid = 1;
	}

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 4, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* initiate a group key handshake for WPA */
	if (ni->ni_rsnprotos == IEEE80211_PROTO_WPA)
		(void)ieee80211_send_group_msg1(ic, ni);
	else
		ni->ni_rsn_gstate = RSNA_IDLE;
}

/*
 * Differentiate Message 2 from Message 4 of the 4-Way Handshake based on
 * the presence of an RSN or WPA Information Element.
 */
void
ieee80211_recv_4way_msg2or4(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	const u_int8_t *frm, *efrm;
	const u_int8_t *rsnie;

	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}

	/* parse key data field (check if an RSN IE is present) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	rsnie = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_RSN:
			rsnie = frm;
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], MICROSOFT_OUI, 3) == 0) {
				switch (frm[5]) {
				case 1:	/* WPA */
					rsnie = frm;
					break;
				}
			}
		}
		frm += 2 + frm[1];
	}
	if (rsnie != NULL)
		ieee80211_recv_4way_msg2(ic, key, ni, rsnie);
	else
		ieee80211_recv_4way_msg4(ic, key, ni);
}

/*
 * Group Key Handshake Message 1 is sent by the authenticator to the
 * supplicant (see 8.5.4.1).
 */
void
ieee80211_recv_rsn_group_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_key *k;
	const u_int8_t *frm, *efrm;
	const u_int8_t *gtk;
	u_int64_t rsc;
	u_int16_t info;
	u_int8_t kid;

	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	info = BE_READ_2(key->info);

	/* check that encrypted and decrypt Key Data field using KEK */
	if (!(info & EAPOL_KEY_ENCRYPTED) ||
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
		return;
	}

	/* parse key data field (shall contain a GTK KDE) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	gtk = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], IEEE80211_OUI, 3) == 0) {
				switch (frm[5]) {
				case IEEE80211_KDE_GTK:
					gtk = frm;
					break;
				}
			}
			break;
		}
		frm += 2 + frm[1];
	}
	/* check that the GTK KDE is present and valid */
	if (gtk == NULL || gtk[1] < 4 + 2) {
		IEEE80211_DPRINTF(("%s: missing or invalid GTK KDE\n",
		    __func__));
		return;
	}

	/* check that key length matches that of group cipher */
	if (gtk[1] - 6 != ieee80211_cipher_keylen(ni->ni_rsngroupcipher))
		return;

	/* install the GTK */
	kid = gtk[6] & 3;
	rsc = LE_READ_6(key->rsc);
	k = &ic->ic_nw_keys[kid];
	ieee80211_map_gtk(&gtk[8], ni->ni_rsngroupcipher, kid,
	    gtk[6] & (1 << 2), rsc, k);
	if ((*ic->ic_set_key)(ic, ni, k) != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_AUTH_LEAVE);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		return;
	}
	if (info & EAPOL_KEY_SECURE) {
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2) {
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
		}
	}
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator */
	(void)ieee80211_send_group_msg2(ic, ni, k);
}

void
ieee80211_recv_wpa_group_msg1(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	struct ieee80211_key *k;
	const u_int8_t *frm;
	u_int64_t rsc;
	u_int16_t info;
	u_int8_t kid;
	int keylen;

	if (ic->ic_opmode != IEEE80211_M_STA &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/*
	 * EAPOL-Key data field is encrypted even though WPA doesn't set
	 * the ENCRYPTED bit in the info field.
	 */
	if (ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0) {
		IEEE80211_DPRINTF(("%s: decryption failed\n", __func__));
		return;
	}
	info = BE_READ_2(key->info);
	keylen = ieee80211_cipher_keylen(ni->ni_rsngroupcipher);

	/* check that key length matches that of group cipher */
	if (BE_READ_2(key->keylen) != keylen)
		return;

	/* check that the data length is large enough to hold the key */
	if (BE_READ_2(key->paylen) < keylen)
		return;

	/* key data field contains the GTK */
	frm = (const u_int8_t *)&key[1];

	/* install the GTK */
	kid = (info >> EAPOL_KEY_WPA_KID_SHIFT) & 3;
	rsc = LE_READ_6(key->rsc);
	k = &ic->ic_nw_keys[kid];
	ieee80211_map_gtk(frm, ni->ni_rsngroupcipher, kid,
	    info & EAPOL_KEY_WPA_TX, rsc, k);
	if ((*ic->ic_set_key)(ic, ni, k) != 0) {
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    IEEE80211_REASON_AUTH_LEAVE);
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		return;
	}
	if (info & EAPOL_KEY_SECURE) {
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ++ni->ni_key_count == 2) {
			IEEE80211_DPRINTF(("%s: marking port %s valid\n",
			    __func__, ether_sprintf(ni->ni_macaddr)));
			ni->ni_port_valid = 1;
		}
	}
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 1, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 2 to authenticator */
	(void)ieee80211_send_group_msg2(ic, ni, k);
}

/*
 * Group Key Handshake Message 2 is sent by the supplicant to the
 * authenticator (see 8.5.4.2).
 */
void
ieee80211_recv_group_msg2(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	/* discard if we're not expecting this message */
	if (ni->ni_rsn_gstate != RSNA_REKEYNEGOTIATING) {
		IEEE80211_DPRINTF(("%s: unexpected in state: %d\n",
		    __func__, ni->ni_rsn_state));
		return;
	}
	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	/* check Key MIC field using KCK */
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}

	timeout_del(&ni->ni_rsn_timeout);
	ni->ni_rsn_gstate = RSNA_REKEYESTABLISHED;

	if ((ni->ni_flags & IEEE80211_NODE_REKEY) &&
	    --ic->ic_rsn_keydonesta == 0)
		ieee80211_setkeysdone(ic);
	ni->ni_flags &= ~IEEE80211_NODE_REKEY;

	ni->ni_rsn_gstate = RSNA_IDLE;
	ni->ni_rsn_retries = 0;

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 2, 2, "group key",
		    ether_sprintf(ni->ni_macaddr));
}

/*
 * EAPOL-Key Request frames are sent by the supplicant to request that the
 * authenticator initiates either a 4-Way Handshake or Group Key Handshake,
 * or to report a MIC failure in a TKIP MSDU.
 */
void
ieee80211_recv_eapol_key_req(struct ieee80211com *ic,
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
{
	u_int16_t info;

	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	info = BE_READ_2(key->info);

	/* enforce monotonicity of key request replay counter */
	if (ni->ni_reqreplaycnt_ok &&
	    BE_READ_8(key->replaycnt) <= ni->ni_reqreplaycnt) {
		ic->ic_stats.is_rx_eapol_replay++;
		return;
	}
	if (!(info & EAPOL_KEY_KEYMIC) ||
	    ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0) {
		IEEE80211_DPRINTF(("%s: key MIC failed\n", __func__));
		ic->ic_stats.is_rx_eapol_badmic++;
		return;
	}
	/* update key request replay counter now that MIC is verified */
	ni->ni_reqreplaycnt = BE_READ_8(key->replaycnt);
	ni->ni_reqreplaycnt_ok = 1;

	if (info & EAPOL_KEY_ERROR) {	/* TKIP MIC failure */
		/* ignore reports from STAs not using TKIP */
		if (ic->ic_bss->ni_rsngroupcipher != IEEE80211_CIPHER_TKIP &&
		    ni->ni_rsncipher != IEEE80211_CIPHER_TKIP) {
			IEEE80211_DPRINTF(("%s: MIC failure report from "
			    "STA not using TKIP: %s\n", __func__,
			    ether_sprintf(ni->ni_macaddr)));
			return;
		}
		ic->ic_stats.is_rx_remmicfail++;
		ieee80211_michael_mic_failure(ic, LE_READ_6(key->rsc));

	} else if (info & EAPOL_KEY_PAIRWISE) {
		/* initiate a 4-Way Handshake */

	} else {
		/*
		 * Should change the GTK, initiate the 4-Way Handshake and
		 * then execute a Group Key Handshake with all supplicants.
		 */
	}
}

/*
 * Process an incoming EAPOL frame.  Notice that we are only interested in
 * EAPOL-Key frames with an IEEE 802.11 or WPA descriptor type.
 */
void
ieee80211_recv_eapol(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_node *ni)
{
	struct ifnet *ifp = &ic->ic_if;
	struct ether_header *eh;
	struct ieee80211_eapol_key *key;
	u_int16_t info, desc;

	ifp->if_ibytes += m0->m_pkthdr.len;

	if (m0->m_len < sizeof(*eh) + sizeof(*key))
		return;
	eh = mtod(m0, struct ether_header *);
	if (IEEE80211_IS_MULTICAST(eh->ether_dhost)) {
		ifp->if_imcasts++;
		return;
	}
	m_adj(m0, sizeof(*eh));
	key = mtod(m0, struct ieee80211_eapol_key *);

	if (key->type != EAPOL_KEY)
		return;
	ic->ic_stats.is_rx_eapol_key++;

	if ((ni->ni_rsnprotos == IEEE80211_PROTO_RSN &&
	     key->desc != EAPOL_KEY_DESC_IEEE80211) ||
	    (ni->ni_rsnprotos == IEEE80211_PROTO_WPA &&
	     key->desc != EAPOL_KEY_DESC_WPA))
		return;

	/* check packet body length */
	if (m0->m_len < 4 + BE_READ_2(key->len))
		return;

	/* check key data length */
	if (m0->m_len < sizeof(*key) + BE_READ_2(key->paylen))
		return;

	info = BE_READ_2(key->info);

	/* discard EAPOL-Key frames with an unknown descriptor version */
	desc = info & EAPOL_KEY_VERSION_MASK;
	if (desc != EAPOL_KEY_DESC_V1 && desc != EAPOL_KEY_DESC_V2)
		return;

	if ((ni->ni_rsncipher == IEEE80211_CIPHER_CCMP ||
	     ni->ni_rsngroupcipher == IEEE80211_CIPHER_CCMP) &&
	    desc != EAPOL_KEY_DESC_V2)
		return;

	/* determine message type (see 8.5.3.7) */
	if (info & EAPOL_KEY_REQUEST) {
		/* EAPOL-Key Request frame */
		ieee80211_recv_eapol_key_req(ic, key, ni);

	} else if (info & EAPOL_KEY_PAIRWISE) {
		/* 4-Way Handshake */
		if (info & EAPOL_KEY_KEYMIC) {
			if (info & EAPOL_KEY_KEYACK)
				ieee80211_recv_4way_msg3(ic, key, ni);
			else
				ieee80211_recv_4way_msg2or4(ic, key, ni);
		} else if (info & EAPOL_KEY_KEYACK)
			ieee80211_recv_4way_msg1(ic, key, ni);
	} else {
		/* Group Key Handshake */
		if (!(info & EAPOL_KEY_KEYMIC))
			return;
		if (info & EAPOL_KEY_KEYACK) {
			if (key->desc == EAPOL_KEY_DESC_WPA)
				ieee80211_recv_wpa_group_msg1(ic, key, ni);
			else
				ieee80211_recv_rsn_group_msg1(ic, key, ni);
		} else
			ieee80211_recv_group_msg2(ic, key, ni);
@


1.80
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.79 2008/04/26 19:57:49 damien Exp $	*/
d82 1
a82 1
	    struct ieee80211_node *, int, u_int32_t, int);
d84 1
a84 1
	    struct ieee80211_node *, int, u_int32_t);
d86 1
a86 1
	    struct ieee80211_node *, int, u_int32_t);
d88 1
a88 1
	    struct ieee80211_node *, int, u_int32_t, int);
d154 1
a154 1
    int rssi, u_int32_t rstamp)
d206 2
a207 2
		ni->ni_rssi = rssi;
		ni->ni_rstamp = rstamp;
d377 2
a379 4
		/*
		 * XXX else: drivers should pass a flag to indicate if the
		 * frame was successfully decrypted or not.
		 */
d503 1
a503 1
				    ether_sprintf(wh->i_addr2), rssi,
d520 1
a520 1
		(*ic->ic_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
d875 1
a875 1
		IEEE80211_DPRINTF(("%s: invalid RSN/WPA2 IE;"
d931 1
a931 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp, int isprobe)
d1105 1
a1105 1
	    &ic->ic_channels[chan], ssid, rssi)) != NULL)
d1218 2
a1219 2
	ni->ni_rssi = rssi;
	ni->ni_rstamp = rstamp;
d1257 1
a1257 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
d1323 2
a1324 2
	ni->ni_rssi = rssi;
	ni->ni_rstamp = rstamp;
d1344 1
a1344 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
d1379 1
a1379 1
	ieee80211_auth_open(ic, wh, ni, rssi, rstamp, seq, status);
d1395 1
a1395 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp, int reassoc)
d1589 2
a1590 2
	ni->ni_rssi = rssi;
	ni->ni_rstamp = rstamp;
d1848 1
a1848 1
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
d1852 1
a1852 1
		ieee80211_recv_probe_resp(ic, m0, ni, rssi, rstamp, 0);
d1855 1
a1855 1
		ieee80211_recv_probe_resp(ic, m0, ni, rssi, rstamp, 1);
d1858 1
a1858 1
		ieee80211_recv_probe_req(ic, m0, ni, rssi, rstamp);
d1861 1
a1861 1
		ieee80211_recv_auth(ic, m0, ni, rssi, rstamp);
d1864 1
a1864 1
		ieee80211_recv_assoc_req(ic, m0, ni, rssi, rstamp, 0);
d1867 1
a1867 1
		ieee80211_recv_assoc_req(ic, m0, ni, rssi, rstamp, 1);
@


1.79
log
@unbreak hostap mode.
do not parse RSN IE from beacons/probe responses if not scanning.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.78 2008/04/21 20:16:34 damien Exp $	*/
d1963 1
a1963 1
	arc4random_bytes(ic->ic_nonce, EAPOL_KEY_NONCE_LEN);
@


1.78
log
@move ieee80211_ibss_merge() from ieee80211_input.c to ieee80211_node.c
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.77 2008/04/21 19:37:18 damien Exp $	*/
d1079 3
a1081 2
	if (!(ic->ic_caps & IEEE80211_C_SCANALL) &&
	    (chan != bchan && ic->ic_phytype != IEEE80211_T_FH)) {
d1179 3
a1181 1
	if (ic->ic_flags & IEEE80211_F_RSNON) {
d1210 1
a1210 1
	} else
a1213 4
		/*
		 * Update ESSID at probe response to adopt hidden AP by
		 * Lucent/Cisco, which announces null ESSID in beacon.
		 */
d1216 2
a1217 1
		memcpy(ni->ni_essid, ssid + 2, ssid[1]);
d1305 2
a1306 2
	if (ssid[1] != 0 && (ssid[1] != ni->ni_esslen ||
	    memcmp(&ssid[2], ni->ni_essid, ni->ni_esslen) != 0)) {
d1480 2
a1481 2
	if (ssid[1] != ni->ni_esslen ||
	    memcmp(&ssid[2], ni->ni_essid, ni->ni_esslen) != 0) {
@


1.77
log
@move ieee80211_auth_open() to ieee80211_proto.c
move ieee80211_setup_rates() to ieee80211_node.c
move some prototypes from ieee80211_proto.h to ieee80211_crypto.h
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.76 2008/04/21 19:27:13 damien Exp $	*/
a80 1
int	ieee80211_do_slow_print(struct ieee80211com *, int *);
a2813 102
}

int
ieee80211_do_slow_print(struct ieee80211com *ic, int *did_print)
{
	static const struct timeval merge_print_intvl = {
		.tv_sec = 1, .tv_usec = 0
	};
	if ((ic->ic_if.if_flags & IFF_LINK0) == 0)
		return 0;
	if (!*did_print && (ic->ic_if.if_flags & IFF_DEBUG) == 0 &&
	    !ratecheck(&ic->ic_last_merge_print, &merge_print_intvl))
		return 0;

	*did_print = 1;
	return 1;
}

/* ieee80211_ibss_merge helps merge 802.11 ad hoc networks.  The
 * convention, set by the Wireless Ethernet Compatibility Alliance
 * (WECA), is that an 802.11 station will change its BSSID to match
 * the "oldest" 802.11 ad hoc network, on the same channel, that
 * has the station's desired SSID.  The "oldest" 802.11 network
 * sends beacons with the greatest TSF timestamp.
 *
 * Return ENETRESET if the BSSID changed, 0 otherwise.
 *
 * XXX Perhaps we should compensate for the time that elapses
 * between the MAC receiving the beacon and the host processing it
 * in ieee80211_ibss_merge.
 */
int
ieee80211_ibss_merge(struct ieee80211com *ic, struct ieee80211_node *ni,
    u_int64_t local_tsft)
{
	u_int64_t beacon_tsft;
	int did_print = 0, sign;
	union {
		u_int64_t	word;
		u_int8_t	tstamp[8];
	} u;

	/* ensure alignment */
	(void)memcpy(&u, &ni->ni_tstamp[0], sizeof(u));
	beacon_tsft = letoh64(u.word);

	/* we are faster, let the other guy catch up */
	if (beacon_tsft < local_tsft)
		sign = -1;
	else
		sign = 1;

	if (IEEE80211_ADDR_EQ(ni->ni_bssid, ic->ic_bss->ni_bssid)) {
		if (!ieee80211_do_slow_print(ic, &did_print))
			return 0;
		printf("%s: tsft offset %s%llu\n", ic->ic_if.if_xname,
		    (sign < 0) ? "-" : "",
		    (sign < 0)
			? (local_tsft - beacon_tsft)
			: (beacon_tsft - local_tsft));
		return 0;
	}

	if (sign < 0)
		return 0;

	if (ieee80211_match_bss(ic, ni) != 0)
		return 0;

	if (ieee80211_do_slow_print(ic, &did_print)) {
		printf("%s: ieee80211_ibss_merge: bssid mismatch %s\n",
		    ic->ic_if.if_xname, ether_sprintf(ni->ni_bssid));
		printf("%s: my tsft %llu beacon tsft %llu\n",
		    ic->ic_if.if_xname, local_tsft, beacon_tsft);
		printf("%s: sync TSF with %s\n",
		    ic->ic_if.if_xname, ether_sprintf(ni->ni_macaddr));
	}

	ic->ic_flags &= ~IEEE80211_F_SIBSS;

	/* negotiate rates with new IBSS */
	ieee80211_fix_rate(ic, ni, IEEE80211_F_DOFRATE |
	    IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
	if (ni->ni_rates.rs_nrates == 0) {
		if (ieee80211_do_slow_print(ic, &did_print)) {
			printf("%s: rates mismatch, BSSID %s\n",
			    ic->ic_if.if_xname, ether_sprintf(ni->ni_bssid));
		}
		return 0;
	}

	if (ieee80211_do_slow_print(ic, &did_print)) {
		printf("%s: sync BSSID %s -> ",
		    ic->ic_if.if_xname, ether_sprintf(ic->ic_bss->ni_bssid));
		printf("%s ", ether_sprintf(ni->ni_bssid));
		printf("(from %s)\n", ether_sprintf(ni->ni_macaddr));
	}

	ieee80211_node_newstate(ni, IEEE80211_STA_BSS);
	(*ic->ic_node_copy)(ic, ic->ic_bss, ni);

	return ENETRESET;
@


1.76
log
@refuse association requests containing a wildcard SSID.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.75 2008/04/21 19:01:01 damien Exp $	*/
a66 5
int	ieee80211_setup_rates(struct ieee80211com *, struct ieee80211_node *,
	    const u_int8_t *, const u_int8_t *, int);
void	ieee80211_auth_open(struct ieee80211com *,
	    const struct ieee80211_frame *, struct ieee80211_node *, int,
	    u_int32_t, u_int16_t, u_int16_t);
a658 124
}

/*
 * Install received rate set information in the node's state block.
 */
int
ieee80211_setup_rates(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *rates, const u_int8_t *xrates, int flags)
{
	struct ieee80211_rateset *rs = &ni->ni_rates;

	memset(rs, 0, sizeof(*rs));
	rs->rs_nrates = rates[1];
	memcpy(rs->rs_rates, rates + 2, rs->rs_nrates);
	if (xrates != NULL) {
		u_int8_t nxrates;
		/*
		 * Tack on 11g extended supported rate element.
		 */
		nxrates = xrates[1];
		if (rs->rs_nrates + nxrates > IEEE80211_RATE_MAXSIZE) {
			nxrates = IEEE80211_RATE_MAXSIZE - rs->rs_nrates;
			IEEE80211_DPRINTF(("%s: extended rate set too large;"
				" only using %u of %u rates\n",
				__func__, nxrates, xrates[1]));
			ic->ic_stats.is_rx_rstoobig++;
		}
		memcpy(rs->rs_rates + rs->rs_nrates, xrates+2, nxrates);
		rs->rs_nrates += nxrates;
	}
	return ieee80211_fix_rate(ic, ni, flags);
}

void
ieee80211_auth_open(struct ieee80211com *ic, const struct ieee80211_frame *wh,
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp, u_int16_t seq,
    u_int16_t status)
{
	struct ifnet *ifp = &ic->ic_if;
	switch (ic->ic_opmode) {
	case IEEE80211_M_IBSS:
		if (ic->ic_state != IEEE80211_S_RUN ||
		    seq != IEEE80211_AUTH_OPEN_REQUEST) {
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		ieee80211_new_state(ic, IEEE80211_S_AUTH,
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
		break;

	case IEEE80211_M_AHDEMO:
		/* should not come here */
		break;

	case IEEE80211_M_HOSTAP:
		if (ic->ic_state != IEEE80211_S_RUN ||
		    seq != IEEE80211_AUTH_OPEN_REQUEST) {
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		if (ni == ic->ic_bss) {
			ni = ieee80211_alloc_node(ic, wh->i_addr2);
			if (ni == NULL) {
				ic->ic_stats.is_rx_nodealloc++;
				return;
			}
			IEEE80211_ADDR_COPY(ni->ni_bssid, ic->ic_bss->ni_bssid);
			ni->ni_rssi = rssi;
			ni->ni_rstamp = rstamp;
			ni->ni_chan = ic->ic_bss->ni_chan;
		}
		IEEE80211_SEND_MGMT(ic, ni,
			IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: station %s %s authenticated (open)\n",
			    ifp->if_xname,
			    ether_sprintf((u_int8_t *)ni->ni_macaddr),
			    ni->ni_state != IEEE80211_STA_CACHE ?
			    "newly" : "already");
		ieee80211_node_newstate(ni, IEEE80211_STA_AUTH);
		break;

	case IEEE80211_M_STA:
		if (ic->ic_state != IEEE80211_S_AUTH ||
		    seq != IEEE80211_AUTH_OPEN_RESPONSE) {
			ic->ic_stats.is_rx_bad_auth++;
			IEEE80211_DPRINTF(("%s: discard auth from %s; "
			    "state %u, seq %u\n", __func__,
			    ether_sprintf((u_int8_t *)wh->i_addr2),
			    ic->ic_state, seq));
			return;
		}
		if (ic->ic_flags & IEEE80211_F_RSNON) {
			/* XXX not here! */
			ic->ic_bss->ni_port_valid = 0;
			ic->ic_bss->ni_replaycnt_ok = 0;
			(*ic->ic_delete_key)(ic, ic->ic_bss,
			    &ic->ic_bss->ni_pairwise_key);
		}
		if (status != 0) {
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: open authentication failed "
				    "(reason %d) for %s\n", ifp->if_xname,
				    status,
				    ether_sprintf((u_int8_t *)wh->i_addr3));
			if (ni != ic->ic_bss)
				ni->ni_fails++;
			ic->ic_stats.is_rx_auth_fail++;
			return;
		}
		ieee80211_new_state(ic, IEEE80211_S_ASSOC,
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
		break;
	case IEEE80211_M_MONITOR:
		break;
	}
@


1.75
log
@- do not process ethernet PAE frames if RSN is not enabled
- add a ieee80211_recv_action() function (will be used later)
- some cleanup, remove unused prototypes, get rid of the
  IEEE80211_VERIFY_* macros
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.74 2008/04/21 16:14:25 damien Exp $	*/
d1609 3
a1611 3
	/* check that the specified SSID (if not wildcard) matches ours */
	if (ssid[1] != 0 && (ssid[1] != ni->ni_esslen ||
	    memcmp(&ssid[2], ni->ni_essid, ni->ni_esslen) != 0)) {
@


1.74
log
@Some WPA1+WPA2 APs include both a WPA and an RSN IE in message 3 of the
4-way handshake, regardless of what protocol the supplicant is using.
Ignore the IEs we don't care about instead of deauthenticating with a
reason code of 'RSN_DIFFERENT_IE'.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.73 2008/04/16 18:32:15 damien Exp $	*/
d85 1
a85 2
void	ieee80211_recv_pspoll(struct ieee80211com *, struct mbuf *, int,
	    u_int32_t);
d101 2
a172 6
	/* trim CRC here so WEP can find its own CRC at the end of packet. */
	if (m->m_flags & M_HASFCS) {
		m_adj(m, -IEEE80211_CRC_LEN);
		m->m_flags &= ~M_HASFCS;
	}

d457 2
a458 1
			if (eh->ether_type == htons(ETHERTYPE_PAE)) {
d544 1
a544 1
			ieee80211_recv_pspoll(ic, m, rssi, rstamp);
a696 72
/* Verify the existence and length of __elem or get out. */
#define IEEE80211_VERIFY_ELEMENT(__elem, __maxlen) do {			\
	if ((__elem) == NULL) {						\
		IEEE80211_DPRINTF(("%s: no " #__elem "in %s frame\n",	\
			__func__, ieee80211_mgt_subtype_name[		\
				(wh->i_fc[0] &				\
				    IEEE80211_FC0_SUBTYPE_MASK) >>	\
				IEEE80211_FC0_SUBTYPE_SHIFT]));		\
		ic->ic_stats.is_rx_elem_missing++;			\
		return;							\
	}								\
	if ((__elem)[1] > (__maxlen)) {					\
		IEEE80211_DPRINTF(("%s: bad " #__elem " len %d in %s "	\
			"frame from %s\n", __func__, (__elem)[1],	\
			ieee80211_mgt_subtype_name[(wh->i_fc[0] & 	\
			        IEEE80211_FC0_SUBTYPE_MASK) >>		\
			    IEEE80211_FC0_SUBTYPE_SHIFT],		\
			ether_sprintf((u_int8_t *)wh->i_addr2)));	\
		ic->ic_stats.is_rx_elem_toobig++;			\
		return;							\
	}								\
} while (0)

#define	IEEE80211_VERIFY_LENGTH(_len, _minlen) do {			\
	if ((_len) < (_minlen)) {					\
		IEEE80211_DPRINTF(("%s: %s frame too short from %s\n",	\
			__func__,					\
			ieee80211_mgt_subtype_name[(wh->i_fc[0] & 	\
			        IEEE80211_FC0_SUBTYPE_MASK) >>		\
			    IEEE80211_FC0_SUBTYPE_SHIFT],		\
			ether_sprintf((u_int8_t *)wh->i_addr2)));	\
		ic->ic_stats.is_rx_elem_toosmall++;			\
		return;							\
	}								\
} while (0)

#ifdef IEEE80211_DEBUG
void
ieee80211_ssid_mismatch(struct ieee80211com *, const char *,
    const u_int8_t[IEEE80211_ADDR_LEN], const u_int8_t *);
void
ieee80211_ssid_mismatch(struct ieee80211com *ic, const char *tag,
    const u_int8_t mac[IEEE80211_ADDR_LEN], const u_int8_t *ssid)
{
	printf("[%s] %s req ssid mismatch: ",
	    ether_sprintf((u_int8_t *)mac), tag);
	ieee80211_print_essid(ssid + 2, ssid[1]);
	printf("\n");
}

#define IEEE80211_VERIFY_SSID(_ni, _ssid, _packet_type) do {		\
	if ((_ssid)[1] != 0 &&						\
	    ((_ssid)[1] != (_ni)->ni_esslen ||				\
	    memcmp((_ssid) + 2, (_ni)->ni_essid, (_ssid)[1]) != 0)) {   \
		if (ieee80211_debug)					\
			ieee80211_ssid_mismatch(ic, _packet_type,       \
				wh->i_addr2, _ssid);			\
		ic->ic_stats.is_rx_ssidmismatch++;			\
		return;							\
	}								\
} while (0)
#else /* !IEEE80211_DEBUG */
#define IEEE80211_VERIFY_SSID(_ni, _ssid, _packet_type) do {		\
	if ((_ssid)[1] != 0 &&						\
	    ((_ssid)[1] != (_ni)->ni_esslen ||				\
	    memcmp((_ssid) + 2, (_ni)->ni_essid, (_ssid)[1]) != 0)) {   \
		ic->ic_stats.is_rx_ssidmismatch++;			\
		return;							\
	}								\
} while (0)
#endif /* !IEEE80211_DEBUG */

d1097 5
a1101 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, 12);
d1105 1
d1187 11
a1197 3
	IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
	IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);

d1423 21
a1443 6
	IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
	IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
	IEEE80211_VERIFY_SSID(ic->ic_bss, ssid, "probe");
	if ((ic->ic_flags & IEEE80211_F_HIDENWID) && ssid[1] == 0) {
		IEEE80211_DPRINTF(("%s: no ssid "
		    "with ssid suppression enabled", __func__));
d1486 5
a1490 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, 6);
d1497 2
a1498 3
	if (algo == IEEE80211_AUTH_ALG_OPEN)
		ieee80211_auth_open(ic, wh, ni, rssi, rstamp, seq, status);
	else {
d1509 1
d1511 1
d1548 5
a1552 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, (reassoc ? 10 : 4));
d1563 1
d1598 19
a1616 4
	IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
	IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
	IEEE80211_VERIFY_SSID(ic->ic_bss, ssid,
		reassoc ? "reassoc" : "assoc");
a1631 7
	if (reassoc && ni->ni_state != IEEE80211_STA_ASSOC) {
		IEEE80211_DPRINTF(("%s: deny reassoc from %s, not "
		    "associated\n", __func__,
		    ether_sprintf((u_int8_t *)wh->i_addr2)));
		status = IEEE80211_STATUS_NOT_ASSOCED;
		goto end;
	}
d1766 5
a1770 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, 6);
d1773 1
a1773 1
	if (status != 0) {
d1815 6
a1820 2

	IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
d1892 5
a1896 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, 2);
d1898 1
d1938 5
a1942 1
	IEEE80211_VERIFY_LENGTH(efrm - frm, 2);
d1944 1
d1967 11
d2013 3
a2022 3
#undef IEEE80211_VERIFY_LENGTH
#undef IEEE80211_VERIFY_ELEMENT
#undef IEEE80211_VERIFY_SSID
d2880 1
a2880 2
ieee80211_recv_pspoll(struct ieee80211com *ic, struct mbuf *m0, int rssi,
    u_int32_t rstamp)
@


1.73
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.72 2007/10/29 15:40:23 chl Exp $	*/
d2121 1
a2121 1
    const u_int8_t *rsn)
d2168 2
a2169 2
	if (ni->ni_rsnie == NULL || rsn[1] != ni->ni_rsnie[1] ||
	    memcmp(rsn, ni->ni_rsnie, 2 + rsn[1]) != 0) {
d2247 5
d2258 2
d2278 3
d2313 1
a2313 1
	if (rsnie2 != NULL && ni->ni_rsnprotos == IEEE80211_PROTO_RSN) {
@


1.72
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d2 2
a3 1
/*	$OpenBSD: ieee80211_input.c,v 1.71 2007/09/18 22:02:18 djm Exp $	*/
d7 1
a7 1
 * Copyright (c) 2007 Damien Bergamini
a66 1

d78 6
a83 6
int	ieee80211_parse_rsn_body(struct ieee80211com *,
	    struct ieee80211_node *, const u_int8_t *, u_int);
int	ieee80211_parse_rsn(struct ieee80211com *, struct ieee80211_node *,
	    const u_int8_t *);
int	ieee80211_parse_wpa1(struct ieee80211com *, struct ieee80211_node *,
	    const u_int8_t *);
d89 1
a89 1
	    struct ieee80211_node *, int, u_int32_t);
d95 1
a95 1
	    struct ieee80211_node *, int, u_int32_t);
d97 1
a97 1
	    struct ieee80211_node *, int, u_int32_t);
d99 1
a99 1
	    struct ieee80211_node *, int, u_int32_t);
d101 1
a101 1
	    struct ieee80211_node *, int, u_int32_t);
d159 1
a159 1
	int rssi, u_int32_t rstamp)
d170 1
a170 1
		panic("null mode");
d244 5
a248 4
	if (ic->ic_set_tim != NULL &&
	    (wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) &&
	    ni->ni_pwrsave == 0) {
		/* turn on power save mode */
d250 3
a252 3
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: power save mode on for %s\n",
			    ifp->if_xname, ether_sprintf(wh->i_addr2));
d254 5
a258 6
		ni->ni_pwrsave = IEEE80211_PS_SLEEP;
	}
	if (ic->ic_set_tim != NULL &&
	    !(wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) &&
	    ni->ni_pwrsave != 0) {
		/* turn off power save mode, dequeue stored packets */
d260 2
a261 2
		ni->ni_pwrsave = 0;
		(*ic->ic_set_tim)(ic, ni->ni_associd, 0);
d263 3
a265 3
		if (ifp->if_flags & IFF_DEBUG)
			printf("%s: power save mode off for %s\n",
			    ifp->if_xname, ether_sprintf(wh->i_addr2));
d267 6
a272 5
		while (!IF_IS_EMPTY(&ni->ni_savedq)) {
			struct mbuf *m;
			IF_DEQUEUE(&ni->ni_savedq, m);
			IF_ENQUEUE(&ic->ic_pwrsaveq, m);
			(*ifp->if_start)(ifp);
d375 4
a378 3
		if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
			if (ic->ic_flags & IEEE80211_F_WEPON) {
				m = ieee80211_wep_crypt(ifp, m, 0);
d389 4
d407 2
a408 2
#if 0
		if (!ni->ni_port_valid &&
a414 1
#endif
d417 4
a420 1
		/* perform as a bridge within the AP */
d423 2
a424 1
		    (ic->ic_flags & IEEE80211_F_NOBRIDGE) == 0) {
d432 1
d462 5
a466 1
			ether_input_mbuf(ifp, m);
d840 7
d947 2
a948 2
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0 ||	/* WPA1 */
	    memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN (aka WPA2) */
d969 2
a970 2
	if (memcmp(selector, MICROSOFT_OUI, 3) == 0 ||	/* WPA1 */
	    memcmp(selector, IEEE80211_OUI, 3) == 0) {	/* RSN (aka WPA2) */
d985 2
a986 2
ieee80211_parse_rsn_body(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *frm, u_int len)
a989 3
	u_int16_t rsncaps;
	enum ieee80211_cipher group_cipher;
	u_int akmset, pairwise_cipherset;
d995 1
a995 1
		return IEEE80211_REASON_RSN_IE_VER_UNSUP;
d1001 3
a1003 2
	ni->ni_group_cipher = IEEE80211_CIPHER_CCMP;
	ni->ni_pairwise_cipherset = IEEE80211_CIPHER_CCMP;
d1005 4
a1008 1
	ni->ni_akmset = IEEE80211_AKM_IEEE8021X;
d1013 3
a1015 3
	group_cipher = ieee80211_parse_rsn_cipher(frm);
	if (group_cipher == IEEE80211_CIPHER_USEGROUP)
		return IEEE80211_REASON_BAD_GROUP_CIPHER;
d1021 1
a1021 1
	m = LE_READ_2(frm);
d1026 2
a1027 2
		return IEEE80211_REASON_IE_INVALID;
	pairwise_cipherset = IEEE80211_CIPHER_NONE;
d1029 1
a1029 1
		pairwise_cipherset |= ieee80211_parse_rsn_cipher(frm);
d1032 5
a1036 5
	if (pairwise_cipherset & IEEE80211_CIPHER_USEGROUP) {
		if (pairwise_cipherset != IEEE80211_CIPHER_USEGROUP)
			return IEEE80211_REASON_BAD_PAIRWISE_CIPHER;
		if (group_cipher == IEEE80211_CIPHER_CCMP)
			return IEEE80211_REASON_BAD_PAIRWISE_CIPHER;
d1042 1
a1042 1
	n = LE_READ_2(frm);
d1047 2
a1048 2
		return IEEE80211_REASON_IE_INVALID;
	akmset = IEEE80211_AKM_NONE;
d1050 1
a1050 1
		akmset |= ieee80211_parse_rsn_akm(frm);
d1057 1
a1057 1
	rsncaps = LE_READ_2(frm);
d1068 1
a1068 1
		return IEEE80211_REASON_IE_INVALID;
d1074 1
a1074 6
	ni->ni_group_cipher = group_cipher;
	ni->ni_pairwise_cipherset = pairwise_cipherset;
	ni->ni_akmset = akmset;
	ni->ni_rsncaps = rsncaps;

	return 0;
d1078 2
a1079 2
ieee80211_parse_rsn(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *frm)
d1086 1
a1086 1
		return IEEE80211_REASON_IE_INVALID;
d1088 1
a1088 1
	return ieee80211_parse_rsn_body(ic, ni, frm + 2, frm[1]);
d1092 2
a1093 2
ieee80211_parse_wpa1(struct ieee80211com *ic, struct ieee80211_node *ni,
    const u_int8_t *frm)
d1097 1
a1097 1
		IEEE80211_DPRINTF(("%s: invalid WPA1 IE;"
d1100 1
a1100 1
		return IEEE80211_REASON_IE_INVALID;
d1102 1
a1102 1
	return ieee80211_parse_rsn_body(ic, ni, frm + 6, frm[1] - 4);
d1106 1
a1106 1
 * Create a copy of an information element.
d1139 1
a1139 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
a1140 3
#define	ISPROBE(_wh)	(((_wh)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == \
	IEEE80211_FC0_SUBTYPE_PROBE_RESP)

d1143 2
a1144 2
	const u_int8_t *tstamp, *ssid, *rates, *xrates, *edca, *wmm;
	const u_int8_t *rsn, *wpa;
d1177 1
a1177 1
	ssid = rates = xrates = edca = wmm = rsn = wpa = NULL;
d1230 1
a1230 1
			rsn = frm;
d1233 1
a1233 1
			edca = frm;
d1244 1
a1244 1
					wpa = frm;
d1247 1
a1247 1
					wmm = frm;
d1267 1
a1267 1
		    "%u\n", __func__, ISPROBE(wh) ?
d1285 1
a1285 1
		    "for channel %u\n", __func__, ISPROBE(wh) ?
d1307 1
a1307 1
		    ISPROBE(wh) ? "probe response" : "beacon",
d1330 1
a1330 1
	    ic->ic_state == IEEE80211_S_ASSOC &&
d1333 1
a1333 2
		 * Check if protection mode has changed since last
		 * beacon.
d1359 4
d1364 5
a1368 4
		if (edca != NULL)
			ieee80211_parse_edca_params(ic, edca);
		else if (wmm != NULL)
			ieee80211_parse_wmm_params(ic, edca);
d1370 33
d1433 1
a1433 1
	if (ic->ic_opmode == IEEE80211_M_IBSS || (is_new && ISPROBE(wh))) {
a1441 1
#undef ISPROBE
d1511 1
a1511 3
	} else {
		IEEE80211_SEND_MGMT(ic, ni,
			IEEE80211_FC0_SUBTYPE_PROBE_RESP, 0);
d1513 1
d1570 1
a1570 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
a1571 3
#define ISREASSOC(_wh)	(((_wh)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == \
	IEEE80211_FC0_SUBTYPE_REASSOC_REQ)

d1574 1
a1574 1
	const u_int8_t *ssid, *rates, *xrates, *rsn, *wpa;
d1576 2
a1577 1
	int reassoc, resp, reason = 0;
d1588 2
a1589 7
	if (ISREASSOC(wh)) {
		reassoc = 1;
		resp = IEEE80211_FC0_SUBTYPE_REASSOC_RESP;
	} else {
		reassoc = 0;
		resp = IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
	}
d1602 1
a1602 1
	ssid = rates = xrates = rsn = wpa = NULL;
d1619 1
a1619 1
			rsn = frm;
d1630 1
a1630 1
					wpa = frm;
d1655 6
a1660 12
	if (rsn != NULL)
		reason = ieee80211_parse_rsn(ic, ni, rsn);
	else if (wpa != NULL)
		reason = ieee80211_parse_wpa1(ic, ni, wpa);
	if (reason != 0) {
		IEEE80211_DPRINTF(("%s: invalid RSN IE for %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
		IEEE80211_SEND_MGMT(ic, ni, IEEE80211_FC0_SUBTYPE_DEAUTH,
		    reason);
		ieee80211_node_leave(ic, ni);
		ic->ic_stats.is_rx_assoc_badrsnie++;
		return;
d1662 1
a1663 4
		IEEE80211_DPRINTF(("%s: capinfo mismatch for %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
		IEEE80211_SEND_MGMT(ic, ni, resp, IEEE80211_STATUS_CAPINFO);
		ieee80211_node_leave(ic, ni);
d1665 2
a1666 1
		return;
a1671 4
		IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
		    __func__, ether_sprintf((u_int8_t *)wh->i_addr2)));
		IEEE80211_SEND_MGMT(ic, ni, resp, IEEE80211_STATUS_BASIC_RATE);
		ieee80211_node_leave(ic, ni);
d1673 2
a1674 1
		return;
d1676 75
d1758 6
a1763 3

	ieee80211_node_join(ic, ni, resp);
#undef ISREASSOC
d1777 1
a1777 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
a1778 3
#define ISREASSOC(_wh)	(((_wh)->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) == \
	IEEE80211_FC0_SUBTYPE_REASSOC_RESP)

d1782 1
a1782 1
	const u_int8_t *rates, *xrates, *edca, *wmm;
a1796 1
	ni = ic->ic_bss;
d1803 1
a1803 1
			    ISREASSOC(wh) ?  "re" : "",
d1812 1
a1812 1
	rates = xrates = edca = wmm = NULL;
d1826 1
a1826 1
			edca = frm;
d1835 1
a1835 1
					wmm = frm;
d1854 1
a1854 1
	if (edca != NULL || wmm != NULL) {
d1858 4
a1861 4
		if ((edca != NULL &&
		     ieee80211_parse_edca_params(ic, edca) == 0) ||
		    (wmm != NULL &&
		     ieee80211_parse_wmm_params(ic, wmm) == 0))
d1886 7
a1892 1

d1894 1
a1894 2
		wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
#undef ISREASSOC
d1903 1
a1903 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
d1920 1
a1920 1
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
d1944 1
a1944 1
    struct ieee80211_node *ni, int rssi, u_int32_t rstamp)
d1961 1
a1961 1
		    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
d1984 3
d1988 1
a1988 2
	case IEEE80211_FC0_SUBTYPE_BEACON:
		ieee80211_recv_probe_resp(ic, m0, ni, rssi, rstamp);
d1997 2
d2000 1
a2000 1
		ieee80211_recv_assoc_req(ic, m0, ni, rssi, rstamp);
d2003 2
d2006 1
a2006 1
		ieee80211_recv_assoc_resp(ic, m0, ni, rssi, rstamp);
d2009 1
a2009 1
		ieee80211_recv_deauth(ic, m0, ni, rssi, rstamp);
d2012 1
a2012 1
		ieee80211_recv_disassoc(ic, m0, ni, rssi, rstamp);
a2034 5
#define BE_WRITE_2(p, v) do {	\
	(p)[0] = (v) >> 8;	\
	(p)[1] = (v) & 0xff;	\
} while (0)

d2036 2
a2037 3
#define LE_READ_8(p)						\
	((u_int64_t)(p)[7] << 56 | (u_int64_t)(p)[6] << 48 |	\
	 (u_int64_t)(p)[5] << 40 | (u_int64_t)(p)[4] << 32 |	\
d2049 1
a2049 1
	u_int8_t snonce[EAPOL_KEY_NONCE_LEN];
a2052 1
	size_t pmk_len;
d2059 2
a2060 1
	    BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d2062 1
a2062 1

d2066 1
a2066 1
	/* parse key data field (shall contain an encapsulated PMKID) */
d2089 1
a2089 1
	/* check that the PMKID KDE is valid */
d2093 2
a2094 2
	/* generate a new nonce (SNonce) */
	arc4random_bytes(snonce, EAPOL_KEY_NONCE_LEN);
d2096 4
a2099 6
	if (ni->ni_akm == IEEE80211_AKM_IEEE8021X) {
		/* XXX find the PMK in the PMKSA cache using the PMKID */
	} else {
		/* the PMK is the PSK */
		pmk = ic->ic_psk;
		pmk_len = IEEE80211_PMK_LEN;
d2101 3
a2103 4

	/* derive PTK from PMK */
	ieee80211_derive_ptk(pmk, pmk_len, ni->ni_macaddr, ic->ic_myaddr,
	    ni->ni_nonce, snonce, (u_int8_t *)&ni->ni_ptk, sizeof(ni->ni_ptk));
d2110 2
a2111 2
	/* send message 2 to authenticator */
	ieee80211_send_4way_msg2(ic, ni, snonce);
d2125 4
a2128 1
	size_t pmk_len;
d2132 3
a2134 1
	    ni->ni_rsn_state != RSNA_PTKCALCNEGOTIATING)
d2136 2
d2139 1
a2139 1
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING;
d2141 8
a2148 3
	/* derive TPTK from PMK */
	ieee80211_derive_ptk(pmk, pmk_len, ic->ic_myaddr, ni->ni_macaddr,
	    ni->ni_nonce, key->nonce, (u_int8_t *)&tptk, sizeof(tptk));
d2151 9
a2159 2
	if (ieee80211_eapol_key_check_mic(key, tptk.kck) != 0)
		return;
d2161 1
a2161 1
	/* use TPTK as PTK now that MIC is verified */
d2171 1
a2171 1
		    IEEE80211_REASON_IE_INVALID);
a2175 3
	ni->ni_rsn_state = RSNA_PTKCALCNEGOTIATING_2;
	ni->ni_rsn_tocnt = 0;

d2182 1
a2182 1
	ieee80211_send_4way_msg3(ic, ni);
d2193 1
d2196 3
a2198 2
	const u_int8_t *rsn1, *rsn2, *gtk;
	u_int16_t info;
d2204 3
a2206 1
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d2208 1
d2210 4
a2213 2
	/* check that ANonce matches the one received in message 1 */
	if (memcmp(key->nonce, ni->ni_nonce, EAPOL_KEY_NONCE_LEN) != 0)
d2215 9
d2228 3
a2230 1
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
d2232 3
d2238 2
a2239 1
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0)
d2241 1
d2247 1
a2247 1
	rsn1 = rsn2 = gtk = NULL;
d2253 5
a2257 5
			if (rsn1 == NULL)
				rsn1 = frm;
			else if (rsn2 == NULL)
				rsn2 = frm;
			/* ignore if more than two RSN IEs */
d2271 1
a2271 1
					rsn1 = frm;
d2280 2
a2281 1
	if (rsn1 == NULL)
d2283 1
d2285 2
a2286 1
	if (gtk != NULL && !(info & EAPOL_KEY_ENCRYPTED))
d2288 1
a2288 1

d2293 4
a2296 4
	if (ni->ni_rsnie == NULL || rsn1[1] != ni->ni_rsnie[1] ||
	    memcmp(rsn1, ni->ni_rsnie, 2 + rsn1[1]) != 0) {
		/*ieee80211_new_state();*/
		return;
d2303 15
a2317 4
	if (rsn2 != NULL) {
		/* XXX ieee80211_parse_rsn(rsn2); */
		/*ieee80211_new_state();*/
		return;
d2320 1
a2320 1
	/* update the last-seen value of the key replay counter field */
d2331 1
a2331 1
		return;	/* ..authenticator will timeout */
d2334 2
d2338 4
a2341 2
		    ieee80211_cipher_keylen(ni->ni_pairwise_cipher))
			return;
d2343 1
d2345 4
a2348 5
		ieee80211_map_ptk(&ni->ni_ptk, ni->ni_pairwise_cipher, k);
		if (ic->ic_set_key != NULL &&
		    (*ic->ic_set_key)(ic, ni, k) != 0) {
			/* XXX deauthenticate */
			return;
d2356 4
a2359 2
		if (gtk[1] < 4 + 2)
			return;
d2361 5
a2365 2
		if (gtk[1] - 6 != ieee80211_cipher_keylen(ni->ni_group_cipher))
			return;	/* XXX PTK already installed! */
d2368 1
a2368 1
		rsc = LE_READ_8(key->rsc);
d2370 1
a2370 1
		ieee80211_map_gtk(&gtk[8], ni->ni_group_cipher, kid,
d2372 3
a2374 4
		if (ic->ic_set_key != NULL &&
		    (*ic->ic_set_key)(ic, ni, k) != 0) {
			/* XXX deauthenticate */
			return;
d2378 4
a2381 4
		if (ic->ic_opmode == IEEE80211_M_IBSS) {
			if (++ni->ni_key_count == 2)
				ni->ni_port_valid = 1;
		} else
d2383 7
d2401 3
a2403 1
	struct ieee80211_key *k;
d2406 3
a2408 1
	if (ni->ni_rsn_state != RSNA_PTKINITNEGOTIATING)
d2410 3
d2415 5
a2419 2
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
		return;
d2421 1
d2423 1
d2425 15
a2439 12
	/* empty key data field */

	/* install the PTK */
	k = &ni->ni_pairwise_key;
	ieee80211_map_ptk(&ni->ni_ptk, ni->ni_pairwise_cipher, k);
	if (ic->ic_set_key != NULL && (*ic->ic_set_key)(ic, ni, k) != 0)
		return;

	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		if (++ni->ni_key_count == 2)
			ni->ni_port_valid = 1;
	} else
d2441 1
a2441 3

	/* increment the 64-bit Key Replay Counter */
	ni->ni_replaycnt++;
d2448 5
a2452 1
	/* XXX start a group key handshake w/ WPA1 */
d2464 1
a2464 1
	const u_int8_t *rsn;
d2466 2
a2467 1
	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt)
d2469 1
d2475 1
a2475 1
	rsn = NULL;
d2481 1
a2481 1
			rsn = frm;
d2489 1
a2489 1
					rsn = frm;
d2496 2
a2497 2
	if (rsn != NULL)
		ieee80211_recv_4way_msg2(ic, key, ni, rsn);
d2521 2
a2522 1
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d2524 1
a2524 3

	info = BE_READ_2(key->info);

d2526 3
a2528 1
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
d2530 2
d2535 2
a2536 1
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0)
d2538 1
d2563 4
a2566 1
	if (gtk == NULL)
d2568 1
a2569 3
	/* check that the GTK KDE is valid */
	if (gtk[1] < 4 + 2)
		return;
d2571 1
a2571 1
	if (gtk[1] - 6 != ieee80211_cipher_keylen(ni->ni_group_cipher))
d2573 1
d2576 1
a2576 1
	rsc = LE_READ_8(key->rsc);
d2578 1
a2578 1
	ieee80211_map_gtk(&gtk[8], ni->ni_group_cipher, kid,
d2580 4
a2583 1
	if (ic->ic_set_key != NULL && (*ic->ic_set_key)(ic, ni, k) != 0)
d2585 9
a2593 1

d2603 1
a2603 1
	ieee80211_send_group_msg2(ic, ni, k);
d2611 1
d2615 1
d2621 2
a2622 1
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d2624 1
a2624 1

d2626 3
a2628 1
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
d2630 1
a2630 1

d2632 1
a2632 1
	 * EAPOL-Key data field is encrypted even though WPA1 doesn't set
d2635 2
a2636 1
	if (ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0)
d2638 1
a2638 1

d2640 1
d2643 5
a2647 2
	if (BE_READ_2(key->keylen) !=
	    ieee80211_cipher_keylen(ni->ni_group_cipher))
d2649 4
d2655 1
a2655 1
	rsc = LE_READ_8(key->rsc);
d2657 1
a2657 1
	ieee80211_map_gtk((u_int8_t *)&key[1], ni->ni_group_cipher, kid,
d2659 4
a2662 1
	if (ic->ic_set_key != NULL && (*ic->ic_set_key)(ic, ni, k) != 0)
d2664 9
a2672 1

d2682 1
a2682 1
	ieee80211_send_group_msg2(ic, ni, k);
d2697 4
a2700 1
	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt)
d2702 5
a2706 1

d2708 3
a2710 1
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
d2712 4
d2717 7
a2723 1
	/* empty key data field */
a2724 5
#ifdef notyet
	if (--ic->ic_keydone_sta == 0) {
		/* install GTK */
	}
#endif
d2733 2
a2734 2
 * authenticator initiate either a 4-Way Handshake or Group Key Handshake
 * and to report a MIC failure in a TKIP MSDU.
d2748 27
a2774 2
	if (info & EAPOL_KEY_ERROR) {
		/* TKIP MIC failure */
d2777 1
a2777 1
		/* initiate the 4-Way Handshake */
a2786 37
#ifdef IEEE80211_DEBUG
static void
ieee80211_print_eapol_key(struct ieee80211com *ic,
    const struct ieee80211_eapol_key *key, const struct ieee80211_node *ni)
{
	int i;
	printf("%s: received EAPOL-Key frame from %s\n",
	    ic->ic_if.if_xname, ether_sprintf((u_int8_t *)ni->ni_macaddr));
	printf("version=0x%02x type=0x%02x desc=0x%02x body length=%d "
	    "data length=%d\n", key->version, key->type, key->desc,
	    BE_READ_2(key->len), BE_READ_2(key->paylen));
	printf("info=%b\n", BE_READ_2(key->info),
	    "\20\x03PAIRWISE\x06INSTALL\x07KEYACK\x08KEYMIC\x09SECURE"
	    "\x0aERROR\x0bREQUEST\x0cENCRYPTED\x0dSMK");
	printf("Key Replay Counter=0x");
	for (i = 0; i < 8; i++)
		printf("%02x", key->replaycnt[i]);
	printf("\n");
	printf("Key Nonce=0x");
	for (i = 0; i < EAPOL_KEY_NONCE_LEN; i++)
		printf("%02x", key->nonce[i]);
	printf("\n");
	printf("Key IV=0x");
	for (i = 0; i < EAPOL_KEY_IV_LEN; i++)
		printf("%02x", key->iv[i]);
	printf("\n");
	printf("Key RSC=0x");
	for (i = 0; i < 8; i++)
		printf("%02x", key->rsc[i]);
	printf("\n");
	printf("Key MIC=0x");
	for (i = 0; i < EAPOL_KEY_MIC_LEN; i++)
		printf("%02x", key->mic[i]);
	printf("\n");
}
#endif

d2789 1
a2789 1
 * EAPOL-Key frames with an IEEE 802.11 or WPA1 descriptor type.
d2795 2
d2800 1
a2800 2
	if (m0->m_len < sizeof(struct ether_header) + sizeof(*key))
		goto out;
d2802 8
a2809 1
	m_adj(m0, sizeof(struct ether_header));
d2812 9
a2820 2
	if (key->type != EAPOL_KEY || key->desc != ni->ni_eapol_desc)
		goto out;
d2824 1
a2824 1
		goto out;
d2828 1
a2828 1
		goto out;
a2829 4
#ifdef IEEE80211_DEBUG
	if (ieee80211_debug > 0)
		ieee80211_print_eapol_key(ic, key, ni);
#endif
d2835 1
a2835 1
		goto out;
d2837 2
a2838 1
	if (ni->ni_pairwise_cipher == IEEE80211_CIPHER_CCMP &&
d2840 1
a2840 1
		goto out;
d2844 1
a2844 1
		/* EAPOL-Key Request */
d2854 1
a2854 1
		} else
d2859 1
a2859 1
			goto out;
d2861 1
a2861 1
			if (key->desc == EAPOL_KEY_DESC_WPA1)
a2867 2
 out:
	m_freem(m0);
d2880 1
a2880 1
	if (ic->ic_set_tim == NULL)  /* no powersaving functionality */
@


1.71
log
@arc4random_bytes() is the preferred interface for generating nonces;
"looks ok" markus@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.70 2007/08/29 19:54:46 damien Exp $	*/
d1096 2
a1097 2
			FREE(*ie, M_DEVBUF);
		MALLOC(*ie, u_int8_t *, 2 + frm[1], M_DEVBUF, M_NOWAIT);
@


1.70
log
@- use ieee80211_get_hdrlen() where appropriate.
- discard all EAPOL-Key frames with an unknown descriptor version.
- when receiving message 3/4 of the 4-way handshake, do not install
  the PTK if the INSTALL bit is not set. this fixes 4-way handshake
  with APs using group keys only.
- similarly, do not mark the 802.1X port as valid if the SECURE bit
  is not set (it will be marked as valid after group key handshake).
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.69 2007/08/27 20:14:21 damien Exp $	*/
d1984 1
a1984 1
	get_random_bytes(snonce, EAPOL_KEY_NONCE_LEN);
@


1.69
log
@rework ieee80211_recv_4way_msg2() function.
add some RSNA authenticator state machine bits.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.68 2007/08/27 18:53:27 damien Exp $	*/
d371 3
a373 4
		if (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_QOS)
			hdrlen = sizeof(struct ieee80211_qosframe);
		else
			hdrlen = sizeof(struct ieee80211_frame);
a1982 4
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);
	/* do not set ni_replaycnt_ok since the frame contains no MIC */

d2016 1
d2027 1
a2027 1
	/* derive PTK from PMK */
d2029 1
a2029 2
	    ni->ni_nonce, key->nonce, (u_int8_t *)&ni->ni_ptk,
	    sizeof(ni->ni_ptk));
d2032 1
a2032 1
	if (ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
d2035 3
d2141 1
a2141 1
	 * Check that first RSN IE is identical to the one received in
d2145 1
a2145 1
	    memcmp(rsn1, ni->ni_rsnie, 2 + rsn1[1]) != 0)
d2148 1
d2171 1
a2171 11
		return;

	/* check that key length matches that of pairwise cipher */
	if (BE_READ_2(key->keylen) !=
	    ieee80211_cipher_keylen(ni->ni_pairwise_cipher))
		return;
	/* install the PTK */
	k = &ni->ni_pairwise_key;
	ieee80211_map_ptk(&ni->ni_ptk, ni->ni_pairwise_cipher, k);
	if (ic->ic_set_key != NULL && (*ic->ic_set_key)(ic, ni, k) != 0)
		return;
d2173 14
d2204 2
a2205 1
		    (*ic->ic_set_key)(ic, ni, k) != 0)
d2207 8
a2215 3

	/* mark the PAE port as valid */
	ni->ni_port_valid = 1;
d2557 1
a2557 1
	u_int16_t info;
d2582 5
d2588 1
a2588 1
	    (info & EAPOL_KEY_VERSION_MASK) != EAPOL_KEY_DESC_V2)
@


1.68
log
@Checking the MIC early in ieee80211_recv_eapol() does not work for
message 2/4 of the 4-way handshake because the authenticator must
derive the PTK first (the MIC is computed using the KCK).
Move calls to ieee80211_eapol_key_check_mic() - and as a consequence
ieee80211_eapol_key_decrypt() - directly in the
ieee80211_recv_{group,4way}_msg*() functions.
Unconstify the first parameter since checking the MIC modifies the
frame. Remove ni->ni_ptk_ok field while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.67 2007/08/23 18:44:00 damien Exp $	*/
d105 2
a106 1
	    struct ieee80211_eapol_key *, struct ieee80211_node *);
d111 2
d2018 2
a2019 1
    struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
a2020 2
	const u_int8_t *frm, *efrm;
	const u_int8_t *rsn;
d2024 3
a2026 5
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt)
d2029 1
a2029 30
	/* parse key data field (shall contain an RSN IE) */
	frm = (const u_int8_t *)&key[1];
	efrm = frm + BE_READ_2(key->paylen);

	rsn = NULL;
	while (frm + 2 <= efrm) {
		if (frm + 2 + frm[1] > efrm)
			break;
		switch (frm[0]) {
		case IEEE80211_ELEMID_RSN:
			rsn = frm;
			break;
		case IEEE80211_ELEMID_VENDOR:
			if (frm[1] < 4)
				break;
			if (memcmp(&frm[2], MICROSOFT_OUI, 3) == 0) {
				switch (frm[5]) {
				case 1:	/* WPA */
					rsn = frm;
					break;
				}
			}
		}
		frm += 2 + frm[1];
	}
	if (rsn == NULL) {
		/* no RSN/WPA IE, must be message 4 of the 4-Way Handshake */
		ieee80211_recv_4way_msg4(ic, key, ni);
		return;
	}
d2052 3
d2219 3
a2221 4
	/*
	 * ic->ic_opmode and key->replaycnt have already been validated by
	 * ieee80211_recv_4way_msg2() from where we're called.
	 */
d2227 2
d2255 45
d2588 1
a2588 1
				ieee80211_recv_4way_msg2(ic, key, ni);
@


1.67
log
@add a new ieee80211_save_ie() function to make a copy of an
information element in a management frame.
the authenticator has to make a copy of the RSN/WPA1 IE from
(Re)Association requests so that it can be compared with the
one included in message 2/4 of the 4-way handshake.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.66 2007/08/23 16:59:32 damien Exp $	*/
d103 1
a103 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d105 1
a105 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d107 1
a107 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d109 1
a109 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d111 1
a111 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d115 1
a115 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d117 1
a117 1
	    const struct ieee80211_eapol_key *, struct ieee80211_node *);
d1935 1
a1935 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
a1998 1
	ni->ni_ptk_ok = 1;
d2015 1
a2015 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2060 9
a2080 6
	/* derive PTK from PMK */
	ieee80211_derive_ptk(pmk, pmk_len, ic->ic_myaddr, ni->ni_macaddr,
	    ni->ni_nonce, key->nonce, (u_int8_t *)&ni->ni_ptk,
	    sizeof(ni->ni_ptk));
	ni->ni_ptk_ok = 1;

d2096 1
a2096 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2101 1
d2114 11
d2165 1
a2165 1
	if (gtk != NULL && !(BE_READ_2(key->info) & EAPOL_KEY_ENCRYPTED))
d2241 1
a2241 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2250 4
d2285 1
a2285 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2291 1
d2301 11
d2335 1
a2335 1
	if (gtk == NULL || !(BE_READ_2(key->info) & EAPOL_KEY_ENCRYPTED))
d2381 4
d2389 1
a2389 2
	if (!ni->ni_ptk_ok ||
	    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0)
d2425 1
a2425 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2434 4
d2458 1
a2458 1
    const struct ieee80211_eapol_key *key, struct ieee80211_node *ni)
d2553 3
a2555 19
	if (info & (EAPOL_KEY_KEYMIC | EAPOL_KEY_ENCRYPTED)) {
		/* check that we have a valid PTK or TPTK */
		if (!ni->ni_ptk_ok)
			goto out;

		if (ni->ni_pairwise_cipher == IEEE80211_CIPHER_CCMP &&
		    (info & EAPOL_KEY_VERSION_MASK) != EAPOL_KEY_DESC_V2)
			goto out;

		/* check Key MIC field using KCK */
		if ((info & EAPOL_KEY_KEYMIC) &&
		    ieee80211_eapol_key_check_mic(key, ni->ni_ptk.kck) != 0)
			goto out;

		/* decrypt Key Data field using KEK */
		if ((info & EAPOL_KEY_ENCRYPTED) &&
		    ieee80211_eapol_key_decrypt(key, ni->ni_ptk.kek) != 0)
			goto out;
	}
@


1.66
log
@add ieee80211_get_hdrlen() to compute the size of the 802.11 header
of a management or data frame  (check if the i_qos, i_ht or i_addr4
are present).
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.65 2007/08/23 16:53:51 damien Exp $	*/
d84 1
d1084 17
@


1.65
log
@the authenticator can't differentiate 4-way handshake message 2 from
message 4 based on the EAPOL-Key frame secure bit.
the only thing that differentiate these messages is the presence of
the RSN/WPA1 IE in the EAPOL-Key frame data field.
only message 2/4 contains this IE.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.64 2007/08/22 20:40:34 damien Exp $	*/
d117 25
@


1.64
log
@- add k_rxmic and k_txmic fields to struct ieee80211_key to store the
  Tx/Rx MIC for TKIP.
- add two functions to map a PTK and a GTK to an IEEE 802.11 key and
  use them in ieee80211_input.c instead of duplicating the same code.
  properly set Tx/Rx MIC in the IEEE 802.11 key in the case of TKIP.
- add ic_psk to struct ieee80211com to store the pre-shared key.
- fix setting of the SECURE bit in outgoing EAPOL-Key frames.
- when receiving msg 2 of the 4-way handshake, deauthenticate the
  station if the RSN IE does not match that of the (Re)Association
  request.
- before parsing an RSN or WPA IE, check that there's enough room for
  the version field (2 bytes) which is mandatory.
- various tweaks while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.63 2007/08/16 14:59:14 deraadt Exp $	*/
d1037 1
a1037 1
	if (frm[1] < 4) {
d1039 1
a1039 1
		    " length %u, expecting at least 4\n", __func__, frm[1]));
d1043 1
a1043 1
	return ieee80211_parse_rsn_body(ic, ni, frm + 2, frm[1] - 2);
d1051 1
a1051 1
	if (frm[1] < 8) {
d1053 1
a1053 1
		    " length %u, expecting at least 8\n", __func__, frm[1]));
d2012 3
a2014 1
	if (rsn == NULL)
d2016 1
d2188 4
a2191 6
	if (ic->ic_opmode != IEEE80211_M_HOSTAP &&
	    ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (BE_READ_8(key->replaycnt) != ni->ni_replaycnt)
		return;
d2501 1
a2501 6
			if (!(info & EAPOL_KEY_KEYACK)) {
				if (info & EAPOL_KEY_SECURE)
					ieee80211_recv_4way_msg4(ic, key, ni);
				else
					ieee80211_recv_4way_msg2(ic, key, ni);
			} else
d2503 2
@


1.63
log
@back out part of last diff; breaks all hardware wep decryption.
from damien
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.61 2007/08/03 20:18:42 damien Exp $	*/
d1037 1
a1037 1
	if (frm[1] < 2) {
d1039 1
a1039 1
		    " length %u, expecting at least 2\n", __func__, frm[1]));
d1051 1
a1051 1
	if (frm[1] < 6) {
d1053 1
a1053 1
		    " length %u, expecting at least 6\n", __func__, frm[1]));
d1935 1
a1935 1
	if (pmkid != NULL && pmkid[1] - 4 < 16)
d1948 3
a1950 1
		/* XXX the PMK is the PSK */
a1986 6
	/* derive PTK from PMK */
	ieee80211_derive_ptk(pmk, pmk_len, ic->ic_myaddr, ni->ni_macaddr,
	    ni->ni_nonce, key->nonce, (u_int8_t *)&ni->ni_ptk,
	    sizeof(ni->ni_ptk));
	ni->ni_ptk_ok = 1;

d2020 4
a2023 1
	    memcmp(rsn, ni->ni_rsnie, 2 + rsn[1]) != 0)
d2025 7
d2114 1
a2116 4
	/* update the last seen value of the key replay counter field */
	ni->ni_replaycnt = BE_READ_8(key->replaycnt);
	ni->ni_replaycnt_ok = 1;

d2123 2
d2127 17
d2146 1
a2146 8
	memset(k, 0, sizeof(*k));
	k->k_cipher = ni->ni_pairwise_cipher;
	k->k_flags = IEEE80211_KEY_TX;
	k->k_len = BE_READ_2(key->keylen);
	/* check that key length matches pairwise cipher */
	if (k->k_len != ieee80211_cipher_keylen(k->k_cipher))
		return;
	memcpy(k->k_key, ni->ni_ptk.tk, k->k_len);
d2151 1
d2155 1
a2155 1
		if (gtk[1] - 4 < 2)
d2157 3
a2159 1

d2162 1
d2164 2
a2165 12
		memset(k, 0, sizeof(*k));
		k->k_id = kid;
		k->k_cipher = ni->ni_group_cipher;
		k->k_flags = IEEE80211_KEY_GROUP;
		if (gtk[6] & (1 << 2))	/* Tx bit */
			k->k_flags |= IEEE80211_KEY_TX;
		k->k_len = gtk[1] - 6;
		/* check that key length matches group cipher */
		if (k->k_len != ieee80211_cipher_keylen(k->k_cipher))
			return;	/* XXX PTK already installed! */
		memcpy(k->k_key, &gtk[8], k->k_len);
		k->k_rsc = LE_READ_8(key->rsc);
a2172 8

	if (ic->ic_if.if_flags & IFF_DEBUG)
		printf("%s: received msg %d/%d of the %s handshake from %s\n",
		    ic->ic_if.if_xname, 3, 4, "4-way",
		    ether_sprintf(ni->ni_macaddr));

	/* send message 4 to authenticator */
	ieee80211_send_4way_msg4(ic, ni);
d2196 1
a2196 5
	memset(k, 0, sizeof(*k));
	k->k_cipher = ni->ni_pairwise_cipher;
	k->k_flags = IEEE80211_KEY_TX;
	k->k_len = ieee80211_cipher_keylen(k->k_cipher);
	memcpy(k->k_key, ni->ni_ptk.tk, k->k_len);
d2213 2
d2228 1
d2265 4
a2268 1
	if (gtk[1] - 4 < 2)
a2269 1

d2272 1
d2274 2
a2275 12
	memset(k, 0, sizeof(*k));
	k->k_id = kid;
	k->k_cipher = ni->ni_group_cipher;
	k->k_flags = IEEE80211_KEY_GROUP;
	if (gtk[6] & (1 << 2))	/* Tx bit */
		k->k_flags |= IEEE80211_KEY_TX;
	k->k_len = gtk[1] - 6;
	/* check that key length matches group cipher */
	if (k->k_len != ieee80211_cipher_keylen(k->k_cipher))
		return;
	memcpy(k->k_key, &gtk[8], k->k_len);
	k->k_rsc = LE_READ_8(key->rsc);
d2296 1
d2317 4
d2323 1
d2325 2
a2326 12
	memset(k, 0, sizeof(*k));
	k->k_id = kid;
	k->k_cipher = ni->ni_group_cipher;
	k->k_flags = IEEE80211_KEY_GROUP;
	if (info & EAPOL_KEY_WPA_TX)
		k->k_flags |= IEEE80211_KEY_TX;
	k->k_len = BE_READ_2(key->keylen);
	/* check that key length matches group cipher */
	if (k->k_len != ieee80211_cipher_keylen(k->k_cipher))
		return;
	memcpy(k->k_key, (u_int8_t *)&key[1], k->k_len);
	k->k_rsc = LE_READ_8(key->rsc);
@


1.62
log
@Prevent sneaking in unencrypted packets into WEP traffic.
ok damien@@, put it ok deraadt@@
@
text
@a357 3
		} else if (ic->ic_flags & IEEE80211_F_WEPON) {
			ic->ic_stats.is_rx_unencrypted++;
			goto out;
@


1.61
log
@fix parsing of GTK KDE.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.60 2007/08/03 16:51:06 damien Exp $	*/
d358 3
@


1.60
log
@add a ni_eapol_desc field to struct ieee80211_node to know whether
a station is using WPA1 or RSN descriptors.
make sure that a station that advertises WPA1 capability in an IE
uses the WPA1 EAPOL-Key descriptor type and not the RSN one.
fix construction of EAPOL-Key frames for WPA1.
i can now successfuly complete a 4-way and group-key handshake
with both a WPA1 and a WPA2 access point.
add some TKIP encapsulation code (no SW crypto yet).

ok deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.59 2007/08/01 18:14:00 damien Exp $	*/
d2155 1
a2155 1
		memcpy(k->k_key, &gtk[7], k->k_len);
d2267 1
d2281 1
a2281 1
	memcpy(k->k_key, &gtk[7], k->k_len);
d2434 1
a2434 1
	printf("EAPOL-Key IV=0x");
@


1.59
log
@allow ic_set_key to be NULL so that drivers won't need to implement it
(for instance if they don't support HW crypto).
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.58 2007/08/01 16:23:48 damien Exp $	*/
d2023 1
a2023 1
	if (rsn[1] != ni->ni_rsnie[1] ||
d2106 1
a2106 1
	if (rsn1[1] != ni->ni_rsnie[1] ||
d2294 1
a2294 1
	ieee80211_send_group_msg2(ic, ni);
d2349 1
a2349 1
	ieee80211_send_group_msg2(ic, ni);
d2439 1
a2439 1
		printf("%02x", key->replaycnt[i]);
d2465 1
a2465 3
	if (key->type != EAPOL_KEY ||
	    (key->desc != EAPOL_KEY_DESC_IEEE80211 &&
	     key->desc != EAPOL_KEY_DESC_WPA1))
@


1.58
log
@make sure the MIC field is set in group key handshake messages before
passing the frame to the handlers.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.57 2007/08/01 16:16:09 damien Exp $	*/
d2132 1
a2132 1
	if ((*ic->ic_set_key)(ic, ni, k) != 0)
d2157 2
a2158 1
		if ((*ic->ic_set_key)(ic, ni, k) != 0)
d2200 1
a2200 1
	if ((*ic->ic_set_key)(ic, ni, k) != 0)
d2282 1
a2282 1
	if ((*ic->ic_set_key)(ic, ni, k) != 0)
d2337 1
a2337 1
	if ((*ic->ic_set_key)(ic, ni, k) != 0)
@


1.57
log
@make ieee80211_recv_wpa_group_msg1() install the GTK in ic_nw_keys[] too.
i only converted ieee80211_recv_rsn_group_msg1() in my previous commit.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.56 2007/08/01 15:40:40 damien Exp $	*/
d2522 2
@


1.56
log
@add generic ieee80211_encrypt() and ieee80211_decrypt() functions that
can handle multiple ciphers (the key to use is determined automatically
by these functions based on the frame's destination address).
add ieee80211_ccmp_encrypt() and ieee80211_ccmp_decrypt().
those two functions only do encapsulation/decapsulation of CCMP frames
for now (they don't do SW crypto). they will help to test things with
drivers that can do HW crypto.
add a ni_pairwise_key field to struct ieee80211_node to actually install
the pairwise transient key.
install the GTK in ic_nw_keys[].
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.55 2007/08/01 15:22:12 damien Exp $	*/
d2300 1
a2300 1
	struct ieee80211_key k;
d2302 1
d2322 6
a2327 4
	memset(&k, 0, sizeof k);
	k.k_id = (info >> EAPOL_KEY_WPA_KID_SHIFT) & 3;
	k.k_cipher = ni->ni_group_cipher;
	k.k_flags = IEEE80211_KEY_GROUP;
d2329 2
a2330 2
		k.k_flags |= IEEE80211_KEY_TX;
	k.k_len = BE_READ_2(key->keylen);
d2332 1
a2332 1
	if (k.k_len != ieee80211_cipher_keylen(k.k_cipher))
d2334 3
a2336 3
	memcpy(k.k_key, (u_int8_t *)&key[1], k.k_len);
	k.k_rsc = LE_READ_8(key->rsc);
	if ((*ic->ic_set_key)(ic, ni, &k) != 0)
@


1.55
log
@unbreak.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.54 2007/08/01 13:25:19 damien Exp $	*/
d2044 1
a2044 1
	struct ieee80211_key k;
d2123 5
a2127 4
	memset(&k, 0, sizeof k);
	k.k_cipher = ni->ni_pairwise_cipher;
	k.k_flags = IEEE80211_KEY_TX;
	k.k_len = BE_READ_2(key->keylen);
d2129 1
a2129 1
	if (k.k_len != ieee80211_cipher_keylen(k.k_cipher))
d2131 2
a2132 2
	memcpy(k.k_key, ni->ni_ptk.tk, k.k_len);
	if ((*ic->ic_set_key)(ic, ni, &k) != 0)
d2136 2
d2141 1
d2143 6
a2148 4
		memset(&k, 0, sizeof k);
		k.k_id = gtk[6] & 3;
		k.k_cipher = ni->ni_group_cipher;
		k.k_flags = IEEE80211_KEY_GROUP;
d2150 2
a2151 2
			k.k_flags |= IEEE80211_KEY_TX;
		k.k_len = gtk[1] - 6;
d2153 1
a2153 1
		if (k.k_len != ieee80211_cipher_keylen(k.k_cipher))
d2155 3
a2157 3
		memcpy(k.k_key, &gtk[7], k.k_len);
		k.k_rsc = LE_READ_8(key->rsc);
		if ((*ic->ic_set_key)(ic, ni, &k) != 0)
d2181 1
a2181 1
	struct ieee80211_key k;
d2193 7
a2199 6
	memset(&k, 0, sizeof k);
	k.k_cipher = ni->ni_pairwise_cipher;
	k.k_flags = IEEE80211_KEY_TX;
	k.k_len = ieee80211_cipher_keylen(k.k_cipher);
	memcpy(k.k_key, ni->ni_ptk.tk, k.k_len);
	if ((*ic->ic_set_key)(ic, ni, &k) != 0)
d2225 1
a2225 1
	struct ieee80211_key k;
d2228 1
d2267 6
a2272 4
	memset(&k, 0, sizeof k);
	k.k_id = gtk[6] & 3;
	k.k_cipher = ni->ni_group_cipher;
	k.k_flags = IEEE80211_KEY_GROUP;
d2274 2
a2275 2
		k.k_flags |= IEEE80211_KEY_TX;
	k.k_len = gtk[1] - 6;
d2277 1
a2277 1
	if (k.k_len != ieee80211_cipher_keylen(k.k_cipher))
d2279 3
a2281 3
	memcpy(k.k_key, &gtk[7], k.k_len);
	k.k_rsc = LE_READ_8(key->rsc);
	if ((*ic->ic_set_key)(ic, ni, &k) != 0)
@


1.54
log
@check the key length field in message 3 of the 4-way handshake.
change ieee80211_recv_eapol() so that it is called without the
ethernet header striped.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.53 2007/08/01 12:59:33 damien Exp $	*/
d2448 1
a2448 1
	m_adj(m, sizeof(struct ether_header));
@


1.53
log
@group key handshake message 1 is very different between RSN and WPA1.
RSN uses a GTK KDE while WPA1 stores the GTK in the EAPOL-Key frame
data field (encrypted) and uses some bits in the info field.
split ieee80211_recv_group_msg1() in two separate functions.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.52 2007/08/01 12:47:55 damien Exp $	*/
d2126 4
a2129 1
	k.k_len = ieee80211_cipher_keylen(k.k_cipher);
d2436 1
a2436 1
 * EAPOL-Key frames with an IEEE 802.11 descriptor type.
d2445 1
a2445 1
	if (m0->m_len < sizeof(*key))
d2448 1
@


1.52
log
@pass the supplicant's nonce generated on reception of message 1 of the
4-way handshake to ieee80211_send_4way_msg2().
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.51 2007/08/01 12:43:58 damien Exp $	*/
d109 1
a109 1
void	ieee80211_recv_group_msg1(struct ieee80211com *,
d111 2
d2095 1
a2095 1
	/* first RSN IE is mandatory */
d2212 1
a2212 1
ieee80211_recv_group_msg1(struct ieee80211com *ic,
d2283 52
d2505 6
a2510 3
		if (info & EAPOL_KEY_KEYACK)
			ieee80211_recv_group_msg1(ic, key, ni);
		else
@


1.51
log
@in 4-way handshake messages 2 and 3, parse vendor-specific WPA1 IEs too.
fix a test for ni_replaycnt_ok while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.50 2007/08/01 12:32:26 damien Exp $	*/
d1960 1
a1960 1
	ieee80211_send_4way_msg2(ic, ni);
@


1.50
log
@PMKID KDE is optionnal in message 1 of the 4-way handshake (at least
when using WPA-PSK).
add a ni_replaycnt_ok flag to struct ieee80211_node to mark the replay
counter as valid.  the replay counter is marked valid only when message
3 of the 4-way handshake is received since message 1 contains no MIC.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.49 2007/08/01 12:26:16 damien Exp $	*/
d1902 2
a1903 1
	if (ni->ni_replaycnt && BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d2001 10
d2080 6
@


1.49
log
@fix parsing and construction of RSN/WPA IEs.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.48 2007/08/01 12:23:26 damien Exp $	*/
d1902 1
a1902 1
	if (BE_READ_8(key->replaycnt) <= ni->ni_replaycnt)
d1931 2
a1932 2
	/* check that we have a valid PMKID KDE */
	if (pmkid == NULL || pmkid[1] - 4 < 16)
d1935 3
a1937 1
	/* do not update replaycnt since the frame contains no MIC */
d2093 1
@


1.48
log
@all WPA implementations i have tested use EAPOL-Key frames version 1,
so use that too and remove a check in ieee80211_recv_eapol().
WPA1 stores the group key id into bits 4-5 of the EAPOL-Key frame info
field and uses bit 6 to indicate if the key is Rx/Tx or Rx only.
remove a check in ieee80211_eapol_key_decrypt() because WPA1 encrypts
the payload of message 1 of the group-key handshake without setting the
encrypted bit in the info field.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.47 2007/08/01 12:02:50 damien Exp $	*/
d1055 1
a1055 1
	return ieee80211_parse_rsn_body(ic, ni, frm + 6, frm[1] - 6);
@


1.47
log
@KEYACK bit is not set for 4-way handshake messages 2 and 4.
it is set in message 3.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.46 2007/08/01 11:59:40 damien Exp $	*/
a2371 3

	if (key->version < EAPOL_VERSION)
		goto out;
@


1.46
log
@cipher suite type for CCMP is 4 not 3.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.45 2007/07/28 11:24:06 damien Exp $	*/
d2423 1
a2423 1
			if (info & EAPOL_KEY_KEYACK) {
@


1.45
log
@adds functions to parse and to build EAPOL-Key frames used in
the 4-way and group-key handshake.
the state machine is still missing though so this is not used
anywhere yet.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.44 2007/07/14 19:58:05 damien Exp $	*/
d905 1
a905 1
		case 3:	/* CCMP (RSNA default) */
@


1.44
log
@update QoS Tx/Rx sequence numbers for each TID.
add a parameter to ieee80211_decap() to handle different 802.11
header sizes.
cleanup and clarify ieee80211_classify().
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.43 2007/07/13 19:56:03 damien Exp $	*/
d101 14
d370 10
a385 1
			eh = mtod(m, struct ether_header *);
d1861 581
@


1.43
log
@cleanup parsing of beacon and probe response mgmt frames.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.42 2007/07/13 19:32:53 damien Exp $	*/
d120 1
a120 1
	int error, len;
d122 1
a122 1
	u_int16_t rxseq;
d159 1
d167 1
a167 1
			__func__, m->m_pkthdr.len));
d174 15
a188 3
		rxseq = ni->ni_rxseq;
		ni->ni_rxseq =
		    letoh16(*(u_int16_t *)wh->i_seq) >> IEEE80211_SEQ_SEQ_SHIFT;
d191 1
a191 1
		    rxseq == ni->ni_rxseq) {
a196 2
		if (ic->ic_opmode == IEEE80211_M_MONITOR)
			goto out;
d323 2
a324 1
			break;
d326 4
d348 1
a348 1
		m = ieee80211_decap(ifp, m);
d503 1
a503 1
ieee80211_decap(struct ifnet *ifp, struct mbuf *m)
d505 1
a506 1
	struct ieee80211_frame wh;
d509 2
a510 2
	if (m->m_len < sizeof(wh) + sizeof(*llc)) {
		m = m_pullup(m, sizeof(wh) + sizeof(*llc));
d515 1
a515 1
	llc = (struct llc *)(mtod(m, caddr_t) + sizeof(wh));
d522 1
a522 1
		m_adj(m, sizeof(wh) + sizeof(struct llc) - sizeof(*eh));
d525 1
a525 1
		m_adj(m, sizeof(wh) - sizeof(*eh));
@


1.42
log
@in ieee80211_recv_assoc_resp(), do not start updating the node
structure until the frame has been fully validated.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.41 2007/07/13 19:26:09 damien Exp $	*/
a1027 1
 * [tlv]  Country
d1043 1
a1043 2
	const u_int8_t *tstamp, *bintval, *capinfo, *country;
	const u_int8_t *ssid, *rates, *xrates, *edca, *wmm;
d1045 1
a1046 1
	u_int16_t fhdwell;
d1074 4
a1077 4
	tstamp  = frm;	frm += 8;
	bintval = frm;	frm += 2;
	capinfo = frm;	frm += 2;
	ssid = rates = xrates = country = edca = wmm = rsn = wpa = NULL;
a1094 3
		case IEEE80211_ELEMID_COUNTRY:
			country = frm;
			break;
d1212 1
a1212 9
			__func__, letoh16(*(u_int16_t *)capinfo),
			letoh16(*(u_int16_t *)bintval), erp);
		if (country) {
			int i;
			printf("%s: country info", __func__);
			for (i = 0; i < country[1]; i++)
				printf(" %02x", country[i+2]);
			printf("\n");
		}
d1253 1
a1253 1
		if ((ni->ni_capinfo ^ letoh16(*(u_int16_t *)capinfo)) &
d1257 1
a1257 2
			    (letoh16(*(u_int16_t *)capinfo) &
			     IEEE80211_CAPINFO_SHORT_SLOTTIME));
d1279 2
a1280 2
	ni->ni_intval = letoh16(*(u_int16_t *)bintval);
	ni->ni_capinfo = letoh16(*(u_int16_t *)capinfo);
@


1.41
log
@change the way we parse IEs to make sure we never read past the end of
the rx buffer.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.40 2007/07/13 19:09:23 damien Exp $	*/
d1605 1
a1605 1
	u_int16_t status;
d1620 2
a1621 5
	ni->ni_capinfo = LE_READ_2(frm);
	frm += 2;

	status = LE_READ_2(frm);
	frm += 2;
d1633 1
a1633 2
	ni->ni_associd = LE_READ_2(frm);
	frm += 2;
d1675 2
@


1.40
log
@properly check ieee80211_setup_rates() return code.
some cleanup while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.39 2007/07/06 19:33:58 damien Exp $	*/
d1085 6
a1090 2
	while (frm < efrm) {
		switch (*frm) {
d1101 5
a1105 4
			if (ic->ic_phytype == IEEE80211_T_FH) {
				fhdwell = (frm[3] << 8) | frm[2];
				chan = IEEE80211_FH_CHAN(frm[4], frm[5]);
				fhindex = frm[6];
d1107 3
d1112 7
a1118 6
			/*
			 * XXX hack this since depending on phytype
			 * is problematic for multi-mode devices.
			 */
			if (ic->ic_phytype != IEEE80211_T_FH)
				chan = frm[2];
d1128 2
a1129 5
			if (frm[1] != 1) {
				IEEE80211_DPRINTF(("%s: invalid ERP "
				    "element; length %u, expecting "
				    "1\n", __func__, frm[1]));
				ic->ic_stats.is_rx_elem_toobig++;
d1161 1
a1161 1
		frm += frm[1] + 2;
d1346 6
a1351 2
	while (frm < efrm) {
		switch (*frm) {
d1362 1
a1362 1
		frm += frm[1] + 2;
d1489 6
a1494 2
	while (frm < efrm) {
		switch (*frm) {
d1520 1
a1520 1
		frm += frm[1] + 2;
d1640 6
a1645 2
	while (frm < efrm) {
		switch (*frm) {
d1666 1
a1666 1
		frm += frm[1] + 2;
@


1.39
log
@have ieee80211_parse_rsn() return a reason code so that we can
deauth associating stations with bad RSN IEs.
cleanup parsing of vendor-specific IEs.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.38 2007/07/06 18:18:43 damien Exp $	*/
d82 1
a82 1
int	ieee80211_parse_wpa(struct ieee80211com *, struct ieee80211_node *,
d500 6
a505 3
	if (llc->llc_dsap == LLC_SNAP_LSAP && llc->llc_ssap == LLC_SNAP_LSAP &&
	    llc->llc_control == LLC_UI && llc->llc_snap.org_code[0] == 0 &&
	    llc->llc_snap.org_code[1] == 0 && llc->llc_snap.org_code[2] == 0) {
d592 1
a592 1
	const u_int8_t *rates, const u_int8_t *xrates, int flags)
d788 2
a789 3
/*-
 * Parse an EDCA Parameter Set Information Element.
 * See IEEE Std 802.11e-2005 - Section 7.3.2.27.
a839 6
/*
 * And now comes the Wi-Fi Alliance WMM compatibility mess.
 * Most APs that advertise themselves as being 802.11e-compatible still
 * continue to use the vendor-specific IE instead of the one defined in
 * the IEEE standard.
 */
d891 2
a892 3
/*-
 * Parse an RSN Information Element.
 * See IEEE Std 802.11i-2004 - Section 7.3.2.25.
d914 2
a915 1
	group_cipher = pairwise_cipherset = IEEE80211_CIPHER_CCMP;
d917 1
a917 1
	akmset = IEEE80211_AKM_IEEE8021X;
d1006 1
a1006 1
ieee80211_parse_wpa(struct ieee80211com *ic, struct ieee80211_node *ni,
d1374 2
a1375 2
			IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
			IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
d1377 2
a1378 2
		IEEE80211_DPRINTF(("%s: rate negotiation failed: %s\n",
		    __func__,ether_sprintf((u_int8_t *)wh->i_addr2)));
d1387 3
a1389 3
 * [2]    Authentication algorithm number
 * [2]    Authentication transaction sequence number
 * [2]    Status code
d1449 1
d1530 1
a1530 1
		reason = ieee80211_parse_wpa(ic, ni, wpa);
d1548 4
a1551 3
	ieee80211_setup_rates(ic, ni, rates, xrates, IEEE80211_F_DOSORT |
	    IEEE80211_F_DOFRATE | IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
	if (ni->ni_rates.rs_nrates == 0) {
a1553 2
		IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
		ni->ni_associd = 0;
d1555 1
d1592 1
d1652 7
a1658 4
	ieee80211_setup_rates(ic, ni, rates, xrates,
			IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
			IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
	if (ni->ni_rates.rs_nrates == 0)
d1660 1
a1660 1

@


1.38
log
@remove remaining bits for pre-RSNA shared authmode support.
it has been #if 0'd since 3.9 and we have never supported this mode (no
ifconfig option etc...).
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.37 2007/07/06 17:58:04 damien Exp $	*/
d833 1
a833 1
		return 1;
d852 1
a852 1
		return 1;
d905 3
a907 3
	u_int16_t cap;
	enum ieee80211_cipher cipher_group;
	u_int akm_mask, cipher_mask;
d913 1
a913 1
		return 1;
d919 1
a919 1
	cipher_group = cipher_mask = IEEE80211_CIPHER_CCMP;
d921 1
a921 1
	akm_mask = IEEE80211_AKM_IEEE8021X;
d926 3
a928 3
	cipher_group = ieee80211_parse_rsn_cipher(frm);
	if (cipher_group == IEEE80211_CIPHER_USEGROUP)
		return 1;
d939 2
a940 2
		return 1;
	cipher_mask = IEEE80211_CIPHER_NONE;
d942 1
a942 1
		cipher_mask |= ieee80211_parse_rsn_cipher(frm);
d945 5
a949 6
	if (cipher_mask & IEEE80211_CIPHER_USEGROUP) {
		if (cipher_mask != IEEE80211_CIPHER_USEGROUP)
			return 1;
		if (cipher_group == IEEE80211_CIPHER_CCMP)
			return 1;
		cipher_mask = cipher_group;
d960 2
a961 2
		return 1;
	akm_mask = IEEE80211_AKM_NONE;
d963 1
a963 1
		akm_mask |= ieee80211_parse_rsn_akm(frm);
d970 1
a970 1
	cap = LE_READ_2(frm);
d980 2
a981 2
	if (frm + s * 16 > efrm)
		return 1;
d984 1
a984 1
		frm += 16;
d987 5
d1004 1
a1004 1
		return 1;
d1018 1
a1018 1
		return 1;
d1146 1
a1146 2
				switch (frm[5]) {
				case 1:	/* WPA */
d1148 3
a1150 6
					break;
				case 2:	/* WMM */
					if (frm[1] >= 5 && frm[6] == 1)
						wmm = frm;
					break;
				}
d1452 1
a1452 1
	int reassoc, resp;
d1498 10
d1531 1
a1531 1
		ieee80211_parse_rsn(ic, ni, rsn);
d1533 10
a1542 2
		ieee80211_parse_wpa(ic, ni, wpa);

d1645 2
a1646 6
				switch (frm[5]) {
				case 2:	/* WMM */
					if (frm[1] >= 5 && frm[6] == 1)
						wmm = frm;
					break;
				}
@


1.37
log
@don't check the IEEE80211_CAPINFO_PRIVACY bit in (re)association requests.
the spec says that "APs ignore the Privacy subfield within received
Association and Reassociation Request managements frames".
if the IEEE80211_CAPINFO_ESS bit is not set, reply with the correct status
code (IEEE80211_STATUS_CAPINFO instead of IEEE80211_STATUS_BASIC_RATE).
indent things a bit while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.36 2007/07/04 20:19:12 damien Exp $	*/
a772 173
#if 0
/* TBD send appropriate responses on error? */
void
ieee80211_auth_shared(struct ieee80211com *ic, struct ieee80211_frame *wh,
    u_int8_t *frm, u_int8_t *efrm, struct ieee80211_node *ni, int rssi,
    u_int32_t rstamp, u_int16_t seq, u_int16_t status)
{
	struct ifnet *ifp = &ic->ic_if;
	u_int8_t *challenge = NULL;
	int i;

	if ((ic->ic_flags & IEEE80211_F_WEPON) == 0) {
		IEEE80211_DPRINTF(("%s: WEP is off\n", __func__));
		return;
	}

	if (frm + 1 < efrm) {
		if (frm[1] + 2 > efrm - frm) {
			IEEE80211_DPRINTF(("elt %d %d bytes too long\n",
			    frm[0], (frm[1] + 2) - (int)(efrm - frm)));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		if (*frm == IEEE80211_ELEMID_CHALLENGE)
			challenge = frm;
		frm += frm[1] + 2;
	}
	switch (seq) {
	case IEEE80211_AUTH_SHARED_CHALLENGE:
	case IEEE80211_AUTH_SHARED_RESPONSE:
		if (challenge == NULL) {
			IEEE80211_DPRINTF(("%s: no challenge sent\n",
			    __func__));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		if (challenge[1] != IEEE80211_CHALLENGE_LEN) {
			IEEE80211_DPRINTF(("%s: bad challenge len %d\n",
			    __func__, challenge[1]));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
	default:
		break;
	}
	switch (ic->ic_opmode) {
	case IEEE80211_M_MONITOR:
	case IEEE80211_M_AHDEMO:
	case IEEE80211_M_IBSS:
		IEEE80211_DPRINTF(("%s: unexpected operating mode\n",
		    __func__));
		return;
	case IEEE80211_M_HOSTAP:
		if (ic->ic_state != IEEE80211_S_RUN) {
			IEEE80211_DPRINTF(("%s: not running\n", __func__));
			return;
		}
		switch (seq) {
		case IEEE80211_AUTH_SHARED_REQUEST:
			if (ni == ic->ic_bss) {
				ni = ieee80211_alloc_node(ic, wh->i_addr2);
				if (ni == NULL) {
					ic->ic_stats.is_rx_nodealloc++;
					return;
				}
				IEEE80211_ADDR_COPY(ni->ni_bssid,
				    ic->ic_bss->ni_bssid);
				ni->ni_rssi = rssi;
				ni->ni_rstamp = rstamp;
				ni->ni_chan = ic->ic_bss->ni_chan;
			}
			if (ni->ni_challenge == NULL)
				ni->ni_challenge = (u_int32_t*)malloc(
				    IEEE80211_CHALLENGE_LEN, M_DEVBUF,
				    M_NOWAIT);
			if (ni->ni_challenge == NULL) {
				IEEE80211_DPRINTF(("%s: "
				    "challenge alloc failed\n", __func__));
				/* XXX statistic */
				return;
			}
			for (i = IEEE80211_CHALLENGE_LEN / sizeof(u_int32_t);
			     --i >= 0; )
				ni->ni_challenge[i] = arc4random();
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: station %s shared key "
				    "%sauthentication\n", ifp->if_xname,
				    ether_sprintf(ni->ni_macaddr),
				    ni->ni_state != IEEE80211_STA_CACHE ?
				    "" : "re");
			break;
		case IEEE80211_AUTH_SHARED_RESPONSE:
			if (ni == ic->ic_bss) {
				IEEE80211_DPRINTF(("%s: unknown STA\n",
				    __func__));
				return;
			}
			if (ni->ni_challenge == NULL) {
				IEEE80211_DPRINTF((
				    "%s: no challenge recorded\n", __func__));
				ic->ic_stats.is_rx_bad_auth++;
				return;
			}
			if (memcmp(ni->ni_challenge, &challenge[2],
			    challenge[1]) != 0) {
				IEEE80211_DPRINTF(("%s: challenge mismatch\n",
				    __func__));
				ic->ic_stats.is_rx_auth_fail++;
				return;
			}
			if (ifp->if_flags & IFF_DEBUG)
				printf("%s: station %s authenticated "
					"(shared key)\n", ifp->if_xname,
					ether_sprintf(ni->ni_macaddr));
			ieee80211_node_newstate(ni, IEEE80211_STA_AUTH);
			break;
		default:
			IEEE80211_DPRINTF(("%s: bad seq %d from %s\n",
			    __func__, seq, ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		IEEE80211_SEND_MGMT(ic, ni,
			IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);
		break;

	case IEEE80211_M_STA:
		if (ic->ic_state != IEEE80211_S_AUTH)
			return;
		switch (seq) {
		case IEEE80211_AUTH_SHARED_PASS:
			if (ni->ni_challenge != NULL) {
				FREE(ni->ni_challenge, M_DEVBUF);
				ni->ni_challenge = NULL;
			}
			if (status != 0) {
				printf("%s: %s: shared authentication failed "
				    "(reason %d) for %s\n", ifp->if_xname,
				    __func__, status,
				    ether_sprintf(wh->i_addr3));
				if (ni != ic->ic_bss)
					ni->ni_fails++;
				ic->ic_stats.is_rx_auth_fail++;
				return;
			}
			ieee80211_new_state(ic, IEEE80211_S_ASSOC,
			    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
			break;
		case IEEE80211_AUTH_SHARED_CHALLENGE:
			if (ni->ni_challenge == NULL)
				ni->ni_challenge = (u_int32_t*)malloc(
				    challenge[1], M_DEVBUF, M_NOWAIT);
			if (ni->ni_challenge == NULL) {
				IEEE80211_DPRINTF((
				    "%s: challenge alloc failed\n", __func__));
				/* XXX statistic */
				return;
			}
			memcpy(ni->ni_challenge, &challenge[2], challenge[1]);
			IEEE80211_SEND_MGMT(ic, ni,
				IEEE80211_FC0_SUBTYPE_AUTH, seq + 1);
			break;
		default:
			IEEE80211_DPRINTF(("%s: bad seq %d from %s\n",
			    __func__, seq, ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_bad_auth++;
			return;
		}
		break;
	}
}
#endif

a1393 1
 * [tlv*] Challenge text
a1415 5
#if 0
	else if (algo == IEEE80211_AUTH_ALG_SHARED)
		ieee80211_auth_shared(ic, wh, frm, efrm, ni, rssi, rstamp,
		    seq, status);
#endif
a1524 5
	/* discard challenge after association */
	if (ni->ni_challenge != NULL) {
		FREE(ni->ni_challenge, M_DEVBUF);
		ni->ni_challenge = NULL;
	}
@


1.36
log
@ignore WMM vendor IEs that are not parameter sets.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.35 2007/07/03 20:25:32 damien Exp $	*/
d1709 2
a1710 8
	/* XXX per-node cipher suite */
	/* XXX some stations use the privacy bit for handling APs
	       that suport both encrypted and unencrypted traffic */
	if ((capinfo & IEEE80211_CAPINFO_ESS) == 0 ||
	    (capinfo & IEEE80211_CAPINFO_PRIVACY) !=
	    ((ic->ic_flags & IEEE80211_F_WEPON) ?
	     IEEE80211_CAPINFO_PRIVACY : 0)) {
		IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
d1712 1
a1712 3
		/* XXX what rate will we send this at? */
		IEEE80211_SEND_MGMT(ic, ni, resp,
		    IEEE80211_STATUS_BASIC_RATE);
d1717 2
a1718 3
	ieee80211_setup_rates(ic, ni, rates, xrates,
			IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
				IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
d1724 1
a1724 2
		IEEE80211_SEND_MGMT(ic, ni, resp,
			IEEE80211_STATUS_BASIC_RATE);
@


1.35
log
@maintain the traffic-indication (TIM) virtual bitmap by defining
a default ieee80211_set_tim() function that drivers can override
by setting ic_set_tim.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.34 2007/07/03 17:04:13 damien Exp $	*/
d1218 1
a1218 1
	const u_int8_t *ssid, *rates, *xrates, *edca, *wmm, *oui;
d1314 2
a1315 3
			oui = frm + 2;
			if (memcmp(oui, MICROSOFT_OUI, 3) == 0) {
				switch (oui[3]) {
d1320 2
a1321 1
					wmm = frm;
d1769 1
a1769 1
	const u_int8_t *rates, *xrates, *edca, *wmm, *oui;
d1820 2
a1821 3
			oui = frm + 2;
			if (memcmp(oui, MICROSOFT_OUI, 3) == 0) {
				switch (oui[3]) {
d1823 2
a1824 1
					wmm = frm;
@


1.34
log
@fix kernel builds with IEEE80211_DEBUG enabled.

pointed out by claudio@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.33 2007/07/02 20:21:46 damien Exp $	*/
d189 2
a190 2
	    (wh->i_fc[1] & IEEE80211_FC1_PWR_MGT)
	    && ni->ni_pwrsave == 0) {
d200 1
a200 1
	    (wh->i_fc[1] & IEEE80211_FC1_PWR_MGT) == 0 &&
d205 1
a205 2
		if (ic->ic_set_tim)
			ic->ic_set_tim(ic, ni->ni_associd, 0);
d2010 1
a2010 1
	if (ic->ic_set_tim == NULL)  /* No powersaving functionality */
d2055 3
a2057 4
	if (IF_IS_EMPTY(&ni->ni_savedq)) {
		if (ic->ic_set_tim)
			ic->ic_set_tim(ic, ni->ni_associd, 0);
	} else {
a2058 1
	}
@


1.33
log
@split ieee80211_parse_rsn() so the same function can be used
to parse both WPA1 and RSN (WPA2) IEs.
rename ieee80211_parse_edca_params_common() into
ieee80211_parse_edca_params_body() while i'm here.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.32 2007/07/02 16:29:26 damien Exp $	*/
d620 3
a622 1
			__func__, ieee80211_mgt_subtype_name[subtype >>	\
d630 4
a633 3
			ieee80211_mgt_subtype_name[subtype >>		\
				IEEE80211_FC0_SUBTYPE_SHIFT],		\
			ether_sprintf(wh->i_addr2)));			\
d643 4
a646 3
			ieee80211_mgt_subtype_name[subtype >>		\
				IEEE80211_FC0_SUBTYPE_SHIFT],		\
			ether_sprintf(wh->i_addr2)));			\
d655 1
a655 1
    u_int8_t[IEEE80211_ADDR_LEN], const u_int8_t *);
d658 1
a658 1
    u_int8_t mac[IEEE80211_ADDR_LEN], const u_int8_t *ssid)
d660 2
a661 1
	printf("[%s] %s req ssid mismatch: ", ether_sprintf(mac), tag);
d700 1
a700 1
			    ether_sprintf(wh->i_addr2),
d718 1
a718 1
			    ether_sprintf(wh->i_addr2),
d751 1
a751 1
			    ether_sprintf(wh->i_addr2),
d979 1
a979 1
	frm += 2;	/* skip QoS Info + Reserved fields */
d1344 1
a1344 1
		    "%u\n", __func__, ISPROBE(subtype) ?
d1362 1
a1362 1
		    "for channel %u\n", __func__, ISPROBE(subtype) ?
d1384 1
a1384 1
		    ISPROBE(subtype) ? "probe response" : "beacon",
d1387 1
a1387 1
		printf(" from %s\n", ether_sprintf(wh->i_addr2));
d1424 2
a1425 2
			    ether_sprintf(wh->i_addr2), ni->ni_erp,
			    erp));
d1547 1
a1547 1
		    __func__, ether_sprintf(wh->i_addr2)));
d1556 1
a1556 1
		    __func__,ether_sprintf(wh->i_addr2)));
d1587 1
a1587 1
	    __func__, algo, seq, ether_sprintf(wh->i_addr2)));
d1599 1
a1599 1
		    __func__, algo, ether_sprintf(wh->i_addr2)));
d1653 1
a1653 1
		    __func__, ether_sprintf(wh->i_addr2)));
d1690 1
a1690 1
		    ether_sprintf(wh->i_addr2)));
d1718 1
a1718 1
		    __func__, ether_sprintf(wh->i_addr2)));
d1731 1
a1731 1
		    __func__, ether_sprintf(wh->i_addr2)));
@


1.32
log
@replace some letoh16(*(u_int16_t *)frm) by LE_READ_2(frm)
for consistency.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.31 2007/06/21 20:11:16 damien Exp $	*/
d72 1
a72 1
int	ieee80211_parse_edca_params_common(struct ieee80211com *,
a75 1
int	ieee80211_parse_rsn(struct ieee80211com *, const u_int8_t *);
d78 6
d959 1
a959 2
ieee80211_parse_edca_params_common(struct ieee80211com *ic,
    const u_int8_t *frm)
d1004 1
a1004 1
	return ieee80211_parse_edca_params_common(ic, frm + 2);
d1023 39
a1061 1
	return ieee80211_parse_edca_params_common(ic, frm + 8);
d1069 2
a1070 1
ieee80211_parse_rsn(struct ieee80211com *ic, const u_int8_t *frm)
d1078 1
a1078 2
	efrm = frm + frm[1];
	frm += 2;
a1080 2
	if (frm + 2 > efrm)
		return 1;
d1150 1
a1150 1
	if (frm + 16 * s > efrm)
d1160 3
a1162 2
enum ieee80211_cipher
ieee80211_parse_rsn_cipher(const u_int8_t selector[4])
d1164 6
a1169 14
	/* from IEEE Std 802.11i-2004 - Table 20da */
	if (memcmp(selector, IEEE80211_OUI, 3) == 0) {
		switch (selector[3]) {
		case 0:	/* use group cipher suite */
			return IEEE80211_CIPHER_USEGROUP;
		case 1:	/* WEP-40 */
			return IEEE80211_CIPHER_WEP40;
		case 2:	/* TKIP */
			return IEEE80211_CIPHER_TKIP;
		case 3:	/* CCMP (RSNA default) */
			return IEEE80211_CIPHER_CCMP;
		case 5:	/* WEP-104 */
			return IEEE80211_CIPHER_WEP104;
		}
d1171 1
a1171 1
	return IEEE80211_CIPHER_NONE;	/* ignore unknown ciphers */
d1174 3
a1176 2
enum ieee80211_akm
ieee80211_parse_rsn_akm(const u_int8_t selector[4])
d1178 6
a1183 8
	/* from IEEE Std 802.11i-2004 - Table 20dc */
	if (memcmp(selector, IEEE80211_OUI, 3) == 0) {
		switch (selector[3]) {
		case 1:	/* IEEE 802.1X (RSNA default) */
			return IEEE80211_AKM_IEEE8021X;
		case 2:	/* PSK */
			return IEEE80211_AKM_PSK;
		}
d1185 1
a1185 1
	return IEEE80211_AKM_NONE;	/* ignore unknown AKMs */
d1695 5
@


1.31
log
@add (currently unused) code to parse RSN IEs.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.30 2007/06/21 19:48:48 damien Exp $	*/
d1160 2
a1161 2
 * [2]    Capability information
 * [tlv]  SSID
d1163 1
a1163 2
 * [tlv]  Country information
 * [tlv*] FH Parameter Set
d1165 1
d1546 3
a1548 3
	algo   = letoh16(*(u_int16_t *)frm);
	seq    = letoh16(*(u_int16_t *)(frm + 2));
	status = letoh16(*(u_int16_t *)(frm + 4));
d1556 1
a1556 1
		ieee80211_auth_shared(ic, wh, frm + 6, efrm, ni, rssi, rstamp,
d1620 2
a1621 2
	capinfo = letoh16(*(u_int16_t *)frm);	frm += 2;
	bintval = letoh16(*(u_int16_t *)frm);	frm += 2;
d1623 1
a1623 1
		frm += 6;	/* ignore current AP info */
d1743 1
a1743 1
	ni->ni_capinfo = letoh16(*(u_int16_t *)frm);
d1746 1
a1746 1
	status = letoh16(*(u_int16_t *)frm);
d1759 1
a1759 1
	ni->ni_associd = letoh16(*(u_int16_t *)frm);
d1855 1
a1855 1
	reason = letoh16(*(u_int16_t *)frm);
d1896 1
a1896 1
	reason = letoh16(*(u_int16_t *)frm);
@


1.30
log
@parse vendor-specific Microsoft WMM OUI.
unfortunately, most APs that advertise themselves as being
802.11e capable still use the Microsoft OUI instead of the
standard IEEE 802.11 information element.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.29 2007/06/21 18:20:18 damien Exp $	*/
d76 3
d949 4
d1023 134
d1168 1
d1181 1
d1183 1
a1183 1
	const u_int8_t *tstamp, *bintval, *capinfo, *country;
d1216 1
a1216 1
	ssid = rates = xrates = country = edca = wmm = NULL;
d1265 3
d1281 3
d1581 1
d1593 1
a1593 1
	const u_int8_t *ssid, *rates, *xrates;
d1624 1
a1624 1
	ssid = rates = xrates = NULL;
d1635 3
@


1.29
log
@add code to parse EDCA parameter set information elements.
add myself to the copyright list.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.28 2007/06/21 16:15:29 damien Exp $	*/
d1039 1
a1039 1
	const u_int8_t *ssid, *rates, *xrates, *edca;
d1073 1
a1073 1
	ssid = rates = xrates = country = edca = NULL;
d1127 14
d1260 6
a1265 3
	if (edca != NULL && (ni->ni_flags & IEEE80211_NODE_QOS))
		ieee80211_parse_edca_params(ic, edca);

d1575 1
a1575 1
	const u_int8_t *rates, *xrates, *edca;
d1609 1
a1609 1
	rates = xrates = edca = NULL;
d1621 14
d1646 1
a1646 1
	if (edca != NULL) {
d1650 4
a1653 1
		if (ieee80211_parse_edca_params(ic, edca) == 0)
@


1.28
log
@split ieee80211_recv_mgmt() into smaller functions:
- ieee80211_recv_probe_resp
- ieee80211_recv_probe_req
- ieee80211_recv_auth
- ieee80211_recv_assoc_req
- ieee80211_recv_assoc_resp
- ieee80211_recv_deauth
- ieee80211_recv_disassoc

"reads ok" jsg@@ claudio@@ mglocker@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.27 2007/06/16 18:36:01 damien Exp $	*/
d6 1
d72 4
d934 81
d1027 2
d1039 1
a1039 1
	const u_int8_t *ssid, *rates, *xrates;
d1073 1
a1073 1
	ssid = rates = xrates = country = NULL;
d1122 5
d1246 2
d1415 1
d1469 2
d1546 1
d1558 1
a1558 1
	const u_int8_t *rates, *xrates;
d1592 1
a1592 1
	rates = xrates = NULL;
d1601 3
d1615 9
@


1.27
log
@move global declaration of ieee80211_merge_print_intvl into the only
function that uses it.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.26 2007/06/16 13:17:05 damien Exp $	*/
d66 22
a87 7
int ieee80211_setup_rates(struct ieee80211com *, struct ieee80211_node *,
    const u_int8_t *, const u_int8_t *, int);
void ieee80211_auth_open(struct ieee80211com *, struct ieee80211_frame *,
    struct ieee80211_node *, int, u_int32_t, u_int16_t, u_int16_t);
void ieee80211_recv_pspoll(struct ieee80211com *, struct mbuf *, int,
    u_int32_t);
int ieee80211_do_slow_print(struct ieee80211com *, int *);
d671 1
a671 1
ieee80211_auth_open(struct ieee80211com *ic, struct ieee80211_frame *wh,
d720 2
a721 1
			    ifp->if_xname, ether_sprintf(ni->ni_macaddr),
d741 2
a742 1
				    status, ether_sprintf(wh->i_addr3));
d929 13
d943 2
a944 3
ieee80211_recv_mgmt(struct ieee80211com *ic, struct mbuf *m0,
	struct ieee80211_node *ni,
	int subtype, int rssi, u_int32_t rstamp)
d946 4
a949 4
#define	ISPROBE(_st)	((_st) == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
#define	ISREASSOC(_st)	((_st) == IEEE80211_FC0_SUBTYPE_REASSOC_RESP)
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_frame *wh;
d952 4
a955 1
	int is_new, reassoc, resp;
d957 20
d978 1
a978 1
	frm = (u_int8_t *)&wh[1];
a979 6
	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
	case IEEE80211_FC0_SUBTYPE_BEACON: {
		const u_int8_t *tstamp, *bintval, *capinfo, *country;
		u_int8_t chan, bchan, fhindex, erp;
		u_int16_t fhdwell;
d981 49
a1029 91
		/*
		 * We process beacon/probe response frames for:
		 *    o station mode: to collect state
		 *      updates such as 802.11g slot time and for passive
		 *      scanning of APs
		 *    o adhoc mode: to discover neighbors
		 *    o hostap mode: for passive scanning of neighbor APs
		 *    o when scanning
		 * In other words, in all modes other than monitor (which
		 * does not process incoming packets) and adhoc-demo (which
		 * does not use management frames at all).
		 */
#ifdef DIAGNOSTIC
		if (ic->ic_opmode != IEEE80211_M_STA &&
		    ic->ic_opmode != IEEE80211_M_IBSS &&
		    ic->ic_opmode != IEEE80211_M_HOSTAP &&
		    ic->ic_state != IEEE80211_S_SCAN) {
			panic("%s: impossible operating mode", __func__);
		}
#endif

		/*
		 * beacon/probe response frame format
		 *	[8] time stamp
		 *	[2] beacon interval
		 *	[2] capability information
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] country information
		 *	[tlv] parameter set (FH/DS)
		 *	[tlv] erp information
		 *	[tlv] extended supported rates
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, 12);
		tstamp  = frm;	frm += 8;
		bintval = frm;	frm += 2;
		capinfo = frm;	frm += 2;
		ssid = rates = xrates = country = NULL;
		bchan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
		chan = bchan;
		fhdwell = 0;
		fhindex = 0;
		erp = 0;
		while (frm < efrm) {
			switch (*frm) {
			case IEEE80211_ELEMID_SSID:
				ssid = frm;
				break;
			case IEEE80211_ELEMID_RATES:
				rates = frm;
				break;
			case IEEE80211_ELEMID_COUNTRY:
				country = frm;
				break;
			case IEEE80211_ELEMID_FHPARMS:
				if (ic->ic_phytype == IEEE80211_T_FH) {
					fhdwell = (frm[3] << 8) | frm[2];
					chan = IEEE80211_FH_CHAN(frm[4],
					    frm[5]);
					fhindex = frm[6];
				}
				break;
			case IEEE80211_ELEMID_DSPARMS:
				/*
				 * XXX hack this since depending on phytype
				 * is problematic for multi-mode devices.
				 */
				if (ic->ic_phytype != IEEE80211_T_FH)
					chan = frm[2];
				break;
			case IEEE80211_ELEMID_TIM:
				break;
			case IEEE80211_ELEMID_IBSSPARMS:
				break;
			case IEEE80211_ELEMID_XRATES:
				xrates = frm;
				break;
			case IEEE80211_ELEMID_ERP:
				if (frm[1] != 1) {
					IEEE80211_DPRINTF(("%s: invalid ERP "
					    "element; length %u, expecting "
					    "1\n", __func__, frm[1]));
					ic->ic_stats.is_rx_elem_toobig++;
					break;
				}
				erp = frm[2];
				break;
			default:
				IEEE80211_DPRINTF2(("%s: element id %u/len %u "
				    "ignored\n", __func__, *frm, frm[1]));
				ic->ic_stats.is_rx_elem_unknown++;
d1032 7
a1038 1
			frm += frm[1] + 2;
d1040 6
a1045 3
		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
		if (
d1047 1
a1047 1
		    chan > IEEE80211_CHAN_MAX ||
d1049 9
a1057 25
		    isclr(ic->ic_chan_active, chan)) {
			IEEE80211_DPRINTF(("%s: ignore %s with invalid channel "
			    "%u\n", __func__, ISPROBE(subtype) ?
			    "probe response" : "beacon", chan));
			ic->ic_stats.is_rx_badchan++;
			return;
		}
		if (!(ic->ic_caps & IEEE80211_C_SCANALL) &&
		    (chan != bchan && ic->ic_phytype != IEEE80211_T_FH)) {
			/*
			 * Frame was received on a channel different from the
			 * one indicated in the DS params element id;
			 * silently discard it.
			 *
			 * NB: this can happen due to signal leakage.
			 *     But we should take it for FH phy because
			 *     the rssi value should be correct even for
			 *     different hop pattern in FH.
			 */
			IEEE80211_DPRINTF(("%s: ignore %s on channel %u marked "
			    "for channel %u\n", __func__, ISPROBE(subtype) ?
			    "probe response" : "beacon", bchan, chan));
			ic->ic_stats.is_rx_chanmismatch++;
			return;
		}
d1059 8
a1066 6
		 * Use mac, channel and rssi so we collect only the
		 * best potential AP with the equal bssid while scanning.
		 * Collecting all potential APs may result in bloat of
		 * the node tree. This call will return NULL if the node
		 * for this APs does not exist or if the new node is the
		 * potential better one.
d1068 17
a1084 3
		if ((ni = ieee80211_find_node_for_beacon(ic, wh->i_addr2,
		    &ic->ic_channels[chan], ssid, rssi)) != NULL)
			break;
d1087 17
a1103 18
		if (ieee80211_debug &&
		    (ni == NULL || ic->ic_state == IEEE80211_S_SCAN)) {
			printf("%s: %s%s on chan %u (bss chan %u) ",
			    __func__, (ni == NULL ? "new " : ""),
			    ISPROBE(subtype) ? "probe response" : "beacon",
			    chan, bchan);
			ieee80211_print_essid(ssid + 2, ssid[1]);
			printf(" from %s\n", ether_sprintf(wh->i_addr2));
			printf("%s: caps 0x%x bintval %u erp 0x%x\n",
				__func__, letoh16(*(u_int16_t *)capinfo),
				letoh16(*(u_int16_t *)bintval), erp);
			if (country) {
				int i;
				printf("%s: country info", __func__);
				for (i = 0; i < country[1]; i++)
					printf(" %02x", country[i+2]);
				printf("\n");
			}
d1105 1
d1108 7
a1114 7
		if ((ni = ieee80211_find_node(ic, wh->i_addr2)) == NULL) {
			ni = ieee80211_alloc_node(ic, wh->i_addr2);
			if (ni == NULL)
				return;
			is_new = 1;
		} else
			is_new = 0;
d1116 8
d1125 2
a1126 3
		 * When operating in station mode, check for state updates
		 * while we're associated. We consider only 11g stuff right
		 * now.
d1128 23
a1150 32
		if (ic->ic_opmode == IEEE80211_M_STA &&
		    ic->ic_state == IEEE80211_S_ASSOC &&
		    ni->ni_state == IEEE80211_STA_BSS) {
			/*
			 * Check if protection mode has changed since last
			 * beacon.
			 */
			if (ni->ni_erp != erp) {
				IEEE80211_DPRINTF((
				    "[%s] erp change: was 0x%x, now 0x%x\n",
				    ether_sprintf(wh->i_addr2), ni->ni_erp,
				    erp));
				if (ic->ic_curmode == IEEE80211_MODE_11G &&
				    (erp & IEEE80211_ERP_USE_PROTECTION))
					ic->ic_flags |= IEEE80211_F_USEPROT;
				else
					ic->ic_flags &= ~IEEE80211_F_USEPROT;
				ic->ic_bss->ni_erp = erp;
			}

			/*
			 * Check if AP short slot time setting has changed
			 * since last beacon and give the driver a chance to
			 * update the hardware.
			 */
			if ((ni->ni_capinfo ^ letoh16(*(u_int16_t *)capinfo)) &
			    IEEE80211_CAPINFO_SHORT_SLOTTIME) {
				ieee80211_set_shortslottime(ic,
				    ic->ic_curmode == IEEE80211_MODE_11A ||
				    (letoh16(*(u_int16_t *)capinfo) &
				     IEEE80211_CAPINFO_SHORT_SLOTTIME));
			}
d1152 1
d1154 22
a1175 23
		if (ssid[1] != 0 && ni->ni_esslen == 0) {
			/*
			 * Update ESSID at probe response to adopt hidden AP by
			 * Lucent/Cisco, which announces null ESSID in beacon.
			 */
			ni->ni_esslen = ssid[1];
			memset(ni->ni_essid, 0, sizeof(ni->ni_essid));
			memcpy(ni->ni_essid, ssid + 2, ssid[1]);
		}
		IEEE80211_ADDR_COPY(ni->ni_bssid, wh->i_addr3);
		ni->ni_rssi = rssi;
		ni->ni_rstamp = rstamp;
		memcpy(ni->ni_tstamp, tstamp, sizeof(ni->ni_tstamp));
		ni->ni_intval = letoh16(*(u_int16_t *)bintval);
		ni->ni_capinfo = letoh16(*(u_int16_t *)capinfo);
		/* XXX validate channel # */
		ni->ni_chan = &ic->ic_channels[chan];
		ni->ni_fhdwell = fhdwell;
		ni->ni_fhindex = fhindex;
		ni->ni_erp = erp;
		/* NB: must be after ni_chan is setup */
		ieee80211_setup_rates(ic, ni, rates, xrates,
		    IEEE80211_F_DOSORT);
d1177 8
d1186 3
a1188 5
		 * When scanning we record results (nodes) with a zero
		 * refcnt.  Otherwise we want to hold the reference for
		 * ibss neighbors so the nodes don't get released prematurely.
		 * Anything else can be discarded (XXX and should be handled
		 * above so we don't do so much work).
d1190 2
a1191 11
		if (ic->ic_opmode == IEEE80211_M_IBSS || (is_new &&
		    ISPROBE(subtype))) {
			/*
			 * Fake an association so the driver can setup it's
			 * private state.  The rate set has been setup above;
			 * there is no handshake as in ap/station operation.
			 */
			if (ic->ic_newassoc)
				(*ic->ic_newassoc)(ic, ni, 1);
		}
		break;
d1193 2
d1196 14
a1209 2
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ: {
		u_int8_t rate;
d1211 7
a1217 3
		if (ic->ic_opmode == IEEE80211_M_STA ||
		    ic->ic_state != IEEE80211_S_RUN)
			return;
d1219 12
a1230 29
		/*
		 * prreq frame format
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 */
		ssid = rates = xrates = NULL;
		while (frm < efrm) {
			switch (*frm) {
			case IEEE80211_ELEMID_SSID:
				ssid = frm;
				break;
			case IEEE80211_ELEMID_RATES:
				rates = frm;
				break;
			case IEEE80211_ELEMID_XRATES:
				xrates = frm;
				break;
			}
			frm += frm[1] + 2;
		}
		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
		IEEE80211_VERIFY_SSID(ic->ic_bss, ssid, "probe");
		if ((ic->ic_flags & IEEE80211_F_HIDENWID) && ssid[1] == 0) {
			IEEE80211_DPRINTF(("%s: no ssid "
			    "with ssid suppression enabled", __func__));
			ic->ic_stats.is_rx_ssidmismatch++;
			return;
d1232 11
d1244 18
a1261 20
		if (ni == ic->ic_bss) {
			ni = ieee80211_dup_bss(ic, wh->i_addr2);
			if (ni == NULL)
				return;
			IEEE80211_DPRINTF(("%s: new probe req from %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
		}
		ni->ni_rssi = rssi;
		ni->ni_rstamp = rstamp;
		rate = ieee80211_setup_rates(ic, ni, rates, xrates,
				IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
				IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
		if (rate & IEEE80211_RATE_BASIC) {
			IEEE80211_DPRINTF(("%s: rate negotiation failed: %s\n",
			    __func__,ether_sprintf(wh->i_addr2)));
		} else {
			IEEE80211_SEND_MGMT(ic, ni,
				IEEE80211_FC0_SUBTYPE_PROBE_RESP, 0);
		}
		break;
d1263 1
d1265 28
a1292 19
	case IEEE80211_FC0_SUBTYPE_AUTH: {
		u_int16_t algo, seq, status;
		/*
		 * auth frame format
		 *	[2] algorithm
		 *	[2] sequence
		 *	[2] status
		 *	[tlv*] challenge
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, 6);
		algo   = letoh16(*(u_int16_t *)frm);
		seq    = letoh16(*(u_int16_t *)(frm + 2));
		status = letoh16(*(u_int16_t *)(frm + 4));
		IEEE80211_DPRINTF(("%s: auth %d seq %d from %s\n",
		    __func__, algo, seq, ether_sprintf(wh->i_addr2)));

		if (algo == IEEE80211_AUTH_ALG_OPEN)
			ieee80211_auth_open(ic, wh, ni, rssi, rstamp, seq,
			    status);
d1294 3
a1296 3
		else if (algo == IEEE80211_AUTH_ALG_SHARED)
			ieee80211_auth_shared(ic, wh, frm + 6, efrm, ni, rssi,
			    rstamp, seq, status);
d1298 10
a1307 12
		else {
			IEEE80211_DPRINTF(("%s: unsupported authentication "
			    "algorithm %d from %s\n",
			    __func__, algo, ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_auth_unsupported++;
			if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
				/* XXX hack to workaround calling convention */
				IEEE80211_SEND_MGMT(ic, ni,
					IEEE80211_FC0_SUBTYPE_AUTH,
					(seq+1) | (IEEE80211_STATUS_ALG<<16));
			}
			return;
a1308 1
		break;
d1310 17
d1328 13
a1340 3
	case IEEE80211_FC0_SUBTYPE_ASSOC_REQ:
	case IEEE80211_FC0_SUBTYPE_REASSOC_REQ: {
		u_int16_t capinfo, bintval;
d1342 7
a1348 3
		if (ic->ic_opmode != IEEE80211_M_HOSTAP ||
		    ic->ic_state != IEEE80211_S_RUN)
			return;
d1350 23
a1372 6
		if (subtype == IEEE80211_FC0_SUBTYPE_REASSOC_REQ) {
			reassoc = 1;
			resp = IEEE80211_FC0_SUBTYPE_REASSOC_RESP;
		} else {
			reassoc = 0;
			resp = IEEE80211_FC0_SUBTYPE_ASSOC_RESP;
d1374 17
a1390 15
		/*
		 * asreq frame format
		 *	[2] capability information
		 *	[2] listen interval
		 *	[6*] current AP address (reassoc only)
		 *	[tlv] ssid
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, (reassoc ? 10 : 4));
		if (!IEEE80211_ADDR_EQ(wh->i_addr3, ic->ic_bss->ni_bssid)) {
			IEEE80211_DPRINTF(("%s: ignore other bss from %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
			ic->ic_stats.is_rx_assoc_bss++;
			return;
d1392 26
a1417 62
		capinfo = letoh16(*(u_int16_t *)frm);	frm += 2;
		bintval = letoh16(*(u_int16_t *)frm);	frm += 2;
		if (reassoc)
			frm += 6;	/* ignore current AP info */
		ssid = rates = xrates = NULL;
		while (frm < efrm) {
			switch (*frm) {
			case IEEE80211_ELEMID_SSID:
				ssid = frm;
				break;
			case IEEE80211_ELEMID_RATES:
				rates = frm;
				break;
			case IEEE80211_ELEMID_XRATES:
				xrates = frm;
				break;
			}
			frm += frm[1] + 2;
		}
		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
		IEEE80211_VERIFY_ELEMENT(ssid, IEEE80211_NWID_LEN);
		IEEE80211_VERIFY_SSID(ic->ic_bss, ssid,
			reassoc ? "reassoc" : "assoc");

		if (ni->ni_state != IEEE80211_STA_AUTH &&
		    ni->ni_state != IEEE80211_STA_ASSOC) {
			IEEE80211_DPRINTF(
			    ("%s: deny %sassoc from %s, not authenticated\n",
			    __func__, reassoc ? "re" : "",
			    ether_sprintf(wh->i_addr2)));
			ni = ieee80211_dup_bss(ic, wh->i_addr2);
			if (ni != NULL) {
				IEEE80211_SEND_MGMT(ic, ni,
				    IEEE80211_FC0_SUBTYPE_DEAUTH,
				    IEEE80211_REASON_ASSOC_NOT_AUTHED);
			}
			ic->ic_stats.is_rx_assoc_notauth++;
			return;
		}
		/* discard challenge after association */
		if (ni->ni_challenge != NULL) {
			FREE(ni->ni_challenge, M_DEVBUF);
			ni->ni_challenge = NULL;
		}
		/* XXX per-node cipher suite */
		/* XXX some stations use the privacy bit for handling APs
		       that suport both encrypted and unencrypted traffic */
		if ((capinfo & IEEE80211_CAPINFO_ESS) == 0 ||
		    (capinfo & IEEE80211_CAPINFO_PRIVACY) !=
		    ((ic->ic_flags & IEEE80211_F_WEPON) ?
		     IEEE80211_CAPINFO_PRIVACY : 0)) {
			IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
			/* XXX what rate will we send this at? */
			IEEE80211_SEND_MGMT(ic, ni, resp,
			    IEEE80211_STATUS_BASIC_RATE);
			ieee80211_node_leave(ic, ni);
			ic->ic_stats.is_rx_assoc_capmismatch++;
			return;
		}
		ieee80211_setup_rates(ic, ni, rates, xrates,
				IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
d1419 42
a1460 17
		if (ni->ni_rates.rs_nrates == 0) {
			IEEE80211_DPRINTF(("%s: rate mismatch for %s\n",
			    __func__, ether_sprintf(wh->i_addr2)));
			IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
			ni->ni_associd = 0;
			IEEE80211_SEND_MGMT(ic, ni, resp,
				IEEE80211_STATUS_BASIC_RATE);
			ic->ic_stats.is_rx_assoc_norate++;
			return;
		}
		ni->ni_rssi = rssi;
		ni->ni_rstamp = rstamp;
		ni->ni_intval = bintval;
		ni->ni_capinfo = capinfo;
		ni->ni_chan = ic->ic_bss->ni_chan;
		ni->ni_fhdwell = ic->ic_bss->ni_fhdwell;
		ni->ni_fhindex = ic->ic_bss->ni_fhindex;
d1462 4
a1465 2
		ieee80211_node_join(ic, ni, resp);
		break;
d1468 24
a1491 3
	case IEEE80211_FC0_SUBTYPE_ASSOC_RESP:
	case IEEE80211_FC0_SUBTYPE_REASSOC_RESP: {
		u_int16_t status;
d1493 9
a1501 4
		if (ic->ic_opmode != IEEE80211_M_STA ||
		    ic->ic_state != IEEE80211_S_ASSOC) {
			ic->ic_stats.is_rx_mgtdiscard++;
			return;
d1503 35
d1539 16
a1554 12
		/*
		 * asresp frame format
		 *	[2] capability information
		 *	[2] status
		 *	[2] association ID
		 *	[tlv] supported rates
		 *	[tlv] extended supported rates
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, 6);
		ni = ic->ic_bss;
		ni->ni_capinfo = letoh16(*(u_int16_t *)frm);
		frm += 2;
d1556 10
a1565 3
		status = letoh16(*(u_int16_t *)frm);
		frm += 2;
		if (status != 0) {
d1567 6
a1572 8
				printf("%s: %sassociation failed (reason %d)"
				    " for %s\n", ifp->if_xname,
				    ISREASSOC(subtype) ?  "re" : "",
				    status, ether_sprintf(wh->i_addr3));
			if (ni != ic->ic_bss)
				ni->ni_fails++;
			ic->ic_stats.is_rx_auth_fail++;
			return;
d1574 5
a1578 2
		ni->ni_associd = letoh16(*(u_int16_t *)frm);
		frm += 2;
d1580 12
a1591 12
		rates = xrates = NULL;
		while (frm < efrm) {
			switch (*frm) {
			case IEEE80211_ELEMID_RATES:
				rates = frm;
				break;
			case IEEE80211_ELEMID_XRATES:
				xrates = frm;
				break;
			}
			frm += frm[1] + 2;
		}
d1593 3
a1595 6
		IEEE80211_VERIFY_ELEMENT(rates, IEEE80211_RATE_MAXSIZE);
		ieee80211_setup_rates(ic, ni, rates, xrates,
				IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE |
				IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
		if (ni->ni_rates.rs_nrates == 0)
			break;
d1597 7
a1603 23
		/*
		 * Configure state now that we are associated.
		 */
		if (ic->ic_curmode == IEEE80211_MODE_11A ||
		    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_PREAMBLE))
			ic->ic_flags |= IEEE80211_F_SHPREAMBLE;
		else
			ic->ic_flags &= ~IEEE80211_F_SHPREAMBLE;

		ieee80211_set_shortslottime(ic,
		    ic->ic_curmode == IEEE80211_MODE_11A ||
		    (ni->ni_capinfo & IEEE80211_CAPINFO_SHORT_SLOTTIME));
		/*
		 * Honor ERP protection.
		 */
		if (ic->ic_curmode == IEEE80211_MODE_11G &&
		    (ni->ni_erp & IEEE80211_ERP_USE_PROTECTION))
			ic->ic_flags |= IEEE80211_F_USEPROT;
		else
			ic->ic_flags &= ~IEEE80211_F_USEPROT;

		ieee80211_new_state(ic, IEEE80211_S_RUN,
			wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
d1605 9
a1613 29
	}

	case IEEE80211_FC0_SUBTYPE_DEAUTH: {
		u_int16_t reason;
		/*
		 * deauth frame format
		 *	[2] reason
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, 2);
		reason = letoh16(*(u_int16_t *)frm);
		ic->ic_stats.is_rx_deauth++;
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			ieee80211_new_state(ic, IEEE80211_S_AUTH,
			    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
			break;
		case IEEE80211_M_HOSTAP:
			if (ni != ic->ic_bss) {
				if (ifp->if_flags & IFF_DEBUG)
					printf("%s: station %s deauthenticated "
					    "by peer (reason %d)\n",
					    ifp->if_xname,
					    ether_sprintf(ni->ni_macaddr),
					    reason);
				ieee80211_node_leave(ic, ni);
			}
			break;
		default:
			break;
d1616 2
d1619 1
d1621 28
a1648 28
	case IEEE80211_FC0_SUBTYPE_DISASSOC: {
		u_int16_t reason;
		/*
		 * disassoc frame format
		 *	[2] reason
		 */
		IEEE80211_VERIFY_LENGTH(efrm - frm, 2);
		reason = letoh16(*(u_int16_t *)frm);
		ic->ic_stats.is_rx_disassoc++;
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			ieee80211_new_state(ic, IEEE80211_S_ASSOC,
			    wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
			break;
		case IEEE80211_M_HOSTAP:
			if (ni != ic->ic_bss) {
				if (ifp->if_flags & IFF_DEBUG)
					printf("%s: station %s disassociated "
					    "by peer (reason %d)\n",
					    ifp->if_xname,
					    ether_sprintf(ni->ni_macaddr),
					    reason);
				ieee80211_node_leave(ic, ni);
			}
			break;
		default:
			break;
		}
a1649 1
	}
@


1.26
log
@constify
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.25 2007/06/16 11:59:58 damien Exp $	*/
a64 5
const struct timeval ieee80211_merge_print_intvl = {
	.tv_sec = 1,
	.tv_usec = 0
};

d1632 3
d1638 1
a1638 1
	    !ratecheck(&ic->ic_last_merge_print, &ieee80211_merge_print_intvl))
@


1.25
log
@don't mix u_int{8,16,32}_t and uint{8,16,32}_t
use u_int{8,16,32}_t everywhere.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.24 2007/06/16 11:56:20 damien Exp $	*/
d72 1
a72 1
    u_int8_t *, u_int8_t *, int);
d567 1
a567 1
	u_int8_t *rates, u_int8_t *xrates, int flags)
d627 3
d631 1
a631 1
    u_int8_t mac[IEEE80211_ADDR_LEN], u_int8_t *ssid)
d926 2
a927 2
	u_int8_t *frm, *efrm;
	u_int8_t *ssid, *rates, *xrates;
d936 1
a936 1
		u_int8_t *tstamp, *bintval, *capinfo, *country;
@


1.24
log
@de-static

ok jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.23 2007/06/06 19:31:07 damien Exp $	*/
d1659 1
a1659 1
    uint64_t local_tsft)
d1661 1
a1661 1
	uint64_t beacon_tsft;
d1664 2
a1665 2
		uint64_t	word;
		uint8_t		tstamp[8];
@


1.23
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.22 2006/12/25 19:24:26 reyk Exp $	*/
d70 8
a77 3
static void ieee80211_recv_pspoll(struct ieee80211com *,
    struct mbuf *, int, u_int32_t);
static int ieee80211_do_slow_print(struct ieee80211com *, int *);
d565 1
a565 1
static int
d626 1
a626 1
static void
d657 1
a657 1
static void
d743 1
a743 1
static void
d1561 1
a1561 1
static void
d1631 1
a1631 1
static int
@


1.22
log
@print the phy mode in IFF_DEBUG status output which helps to debug
dual/multi mode chipset operation.

ok jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.21 2006/08/29 18:10:34 damien Exp $	*/
a17 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.21
log
@Fix handling of beacon frames by stations while they're associated.
Changes in the ERP information element and in the capinfo field were not
detected properly, so the drivers were not able to adjust their settings
(like short slot time, short preamble, protection mode etc...)
dynamically. Should fix BSS mode with both 802.11b and 802.11g stations.

ok reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.20 2006/08/29 18:02:41 damien Exp $	*/
d405 1
a405 1
				printf("%s: received %s from %s rssi %d\n",
d409 3
a411 1
				    ether_sprintf(wh->i_addr2), rssi);
@


1.20
log
@make ic_stats.is_rx_tooshort statistic more accurate.
cosmetic tweaks.

ok reyk@@
@
text
@d2 1
a2 2
/*	$OpenBSD: ieee80211_input.c,v 1.19 2006/07/29 11:31:47 miod Exp $	*/

d1108 2
a1109 6
		    ni->ni_associd != 0 &&
		    (!(ic->ic_flags & IEEE80211_F_ASCAN) ||
		     IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_bssid))) {
			/* record tsf of last beacon */
			ni->ni_rstamp = rstamp;
			memcpy(ni->ni_tstamp, tstamp, sizeof(ni->ni_tstamp));
d1118 1
a1118 1
				    erp)); 
d1124 1
a1124 1
				ni->ni_erp = erp;
a1137 2
				ni->ni_capinfo =
				    letoh16(*(u_int16_t *)capinfo);
a1138 1
			break;
@


1.19
log
@ALIGNED_POINTER is always defined.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.18 2006/06/27 20:55:51 reyk Exp $	*/
a111 1
	 * Also do not process frames w/o i_addr2 any further.
d114 1
a114 2
	if (ic->ic_opmode == IEEE80211_M_MONITOR ||
	    m->m_pkthdr.len < sizeof(struct ieee80211_frame_min))
d117 8
d142 1
a142 2
		/* XXX statistic */
		IEEE80211_DPRINTF2(("%s: frame too short, len %u\n",
d265 3
a267 3
				IEEE80211_DPRINTF(("%s: data from unknown src "
					"%s\n", __func__,
					ether_sprintf(wh->i_addr2)));
d423 1
a423 1
		}			
d1241 2
a1242 2
				IEEE80211_F_DOSORT | IEEE80211_F_DOFRATE
				| IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
d1562 3
a1733 3
#undef IEEE80211_VERIFY_LENGTH
#undef IEEE80211_VERIFY_ELEMENT
#undef IEEE80211_VERIFY_SSID
@


1.18
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.17 2006/06/18 18:55:27 damien Exp $	*/
a498 1
#ifdef ALIGNED_POINTER
a547 1
#endif /* ALIGNED_POINTER */
@


1.17
log
@s/memcmp/IEEE80211_ADDR_EQ/
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.16 2006/06/18 18:39:41 damien Exp $	*/
d317 2
a318 1
		if (ic->ic_opmode == IEEE80211_M_HOSTAP) {
d1221 6
@


1.16
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.15 2006/03/25 22:41:48 djm Exp $	*/
d1670 1
a1670 2
	if (memcmp(ni->ni_bssid, ic->ic_bss->ni_bssid,
	    IEEE80211_ADDR_LEN) == 0) {
@


1.15
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.14 2006/01/11 00:18:17 millert Exp $	*/
a35 2
#include <sys/cdefs.h>

a1056 1

d1099 46
d1168 1
d1192 2
a1193 3
		if (ic->ic_opmode == IEEE80211_M_STA)
			return;
		if (ic->ic_state != IEEE80211_S_RUN)
d1288 1
a1288 1
		    (ic->ic_state != IEEE80211_S_RUN))
d1455 26
a1480 3
		if (ni->ni_rates.rs_nrates != 0)
			ieee80211_new_state(ic, IEEE80211_S_RUN,
				wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK);
@


1.14
log
@Disable shared key mode until we have a way for the user to specify
that they explicitly want it.  What we have currently doesn't seem
to work anyway.  Add support for specifying a status type when
sending managemnent frames; adapted from FreeBSD.  OK jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.13 2006/01/02 08:05:36 reyk Exp $	*/
d305 1
a305 1
			bpf_mtap(ic->ic_rawbpf, m);
d355 1
a355 1
				bpf_mtap(ifp->if_bpf, m);
d410 1
a410 1
			bpf_mtap(ic->ic_rawbpf, m);
d452 1
a452 1
			bpf_mtap(ic->ic_rawbpf, m);
@


1.13
log
@use the correct format string directive %llu instead of "%ull".
pointed out by Thorsten Glaser.
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.12 2005/11/03 20:00:18 reyk Exp $	*/
d737 1
d908 1
d1216 5
a1220 1
		if (algo == IEEE80211_AUTH_ALG_SHARED)
d1223 1
a1223 3
		else if (algo == IEEE80211_AUTH_ALG_OPEN)
			ieee80211_auth_open(ic, wh, ni, rssi, rstamp, seq,
			    status);
d1229 6
@


1.12
log
@re-implement the bpf "filter drop" option that it actually works. the
bpf FILDROP interface exists for about one year but the required
interface to the drivers was missing - so it was useless. this new
approach based on a design by henning@@ uses a new mbuf flag to mark
filtered packets and to drop them in the generic network stack input
routines (like ether_input).

for example; after some additional testing, this could be used by
dhclient to filter everything except DHCP packets (track tech@@
for a corresponding dhclient diff). the "filter dropped" packets won't
reach the network stack. so it's probably some kind of a very basic
application layer packet filter ;).

ok canacar@@, discussed with henning@@ and others
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.11 2005/09/13 12:11:03 reyk Exp $	*/
d1598 1
a1598 1
		printf("%s: tsft offset %s%ull\n", ic->ic_if.if_xname,
d1615 1
a1615 1
		printf("%s: my tsft %ull beacon tsft %ull\n",
@


1.11
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.10 2005/09/08 13:24:52 reyk Exp $	*/
d411 9
@


1.10
log
@mostly knf

ok jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.9 2005/09/08 12:44:55 jsg Exp $	*/
d1050 6
a1055 8
		 * Use mac and channel for lookup so we collect all
		 * potential AP's when scanning.  Otherwise we may
		 * see the same AP on multiple channels and will only
		 * record the last one.  We could filter APs here based
		 * on rssi, etc. but leave that to the end of the scan
		 * so we can keep the selection criteria in one spot.
		 * This may result in a bloat of the scanned AP list but
		 * it shouldn't be too much.
d1057 4
a1060 2
		ni = ieee80211_find_node_for_beacon(ic, wh->i_addr2,
		    &ic->ic_channels[chan], ssid);
d1082 2
a1083 1
		if (ni == NULL) {
@


1.9
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.8 2005/09/08 09:11:08 jsg Exp $	*/
d73 2
a74 2
    .tv_sec = 1, 
    .tv_usec = 0
d357 1
a357 1
 			ether_input_mbuf(ifp, m);
d437 1
a437 1
  err:
d439 1
a439 1
  out:
d813 4
a816 4
					"%sauthentication\n", ifp->if_xname,
					ether_sprintf(ni->ni_macaddr),
					ni->ni_state != IEEE80211_STA_CACHE ?
				        "" : "re");
d831 1
a831 1
			           challenge[1]) != 0) {
d979 2
a980 1
					chan = IEEE80211_FH_CHAN(frm[4], frm[5]);
d1025 2
a1026 2
			    "%u\n", __func__,
			    ISPROBE(subtype) ? "probe response" : "beacon", chan));
d1030 1
a1030 1
		if (!(ic->ic_caps & IEEE80211_C_SCANALL) && 
d1043 2
a1044 2
			    "for channel %u\n", __func__,
			    ISPROBE(subtype) ? "probe response" : "beacon", bchan, chan));
d1111 2
a1112 1
		ieee80211_setup_rates(ic, ni, rates, xrates, IEEE80211_F_DOSORT);
d1469 1
a1469 1
		      u_int32_t rstamp)
d1485 1
a1485 1
			       ifp->if_xname, ether_sprintf(wh->i_addr2));
d1493 1
a1493 1
			       ifp->if_xname, ether_sprintf(wh->i_addr2), aid);
d1500 2
a1501 3
			       "aid %x\n",
			       ifp->if_xname, ether_sprintf(wh->i_addr2),
			       ni->ni_associd, aid);
d1511 2
a1512 2
			       "but no packets are saved\n",
			       ifp->if_xname, ether_sprintf(wh->i_addr2));
d1531 1
a1531 1
		       ifp->if_xname, ether_sprintf(ni->ni_macaddr));
@


1.8
log
@Remove FreeBSD if_printf compat function from net80211.
ok reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.7 2005/09/07 05:40:11 jsg Exp $	*/
a68 1
#include <net80211/ieee80211_compat.h>
d103 2
a104 1
	IASSERT(ni != NULL, ("null node"));
d305 1
a305 1
			BPF_MTAP(ic->ic_rawbpf, m);
d355 1
a355 1
				BPF_MTAP(ifp->if_bpf, m);
d410 1
a410 1
			BPF_MTAP(ic->ic_rawbpf, m);
d443 1
a443 1
			BPF_MTAP(ic->ic_rawbpf, m);
@


1.7
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.6 2005/05/07 02:50:47 jsg Exp $	*/
d402 2
a403 1
				if_printf(ifp, "received %s from %s rssi %d\n",
d693 2
a694 2
			if_printf(ifp, "station %s %s authenticated (open)\n",
			    ether_sprintf(ni->ni_macaddr),
d712 3
a714 4
				if_printf(&ic->ic_if,
				    "open authentication failed (reason %d) "
				    "for %s\n", status,
				    ether_sprintf(wh->i_addr3));
d812 2
a813 2
				if_printf(ifp, "station %s shared key "
					"%sauthentication\n",
d838 2
a839 2
				if_printf(ifp, "station %s authenticated "
					"(shared key)\n",
d863 2
a864 3
				if_printf(&ic->ic_if,
				    "%s: shared authentication failed "
				    "(reason %d) for %s\n",
d1361 2
a1362 2
				if_printf(ifp,
				    "%sassociation failed (reason %d) for %s\n",
d1413 1
a1413 2
					if_printf(ifp,
					    "station %s deauthenticated "
d1415 1
d1444 1
a1444 2
					if_printf(ifp,
					    "station %s disassociated "
d1446 1
@


1.6
log
@Fix compilation with IEEE80211_DEBUG defined. Spotted by djm@@.
ok djm@@, reyk@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.5 2005/03/08 18:09:20 mickey Exp $	*/
a36 9
#if defined(__FreeBSD__)
__FBSDID("$FreeBSD: src/sys/net80211/ieee80211_input.c,v 1.20 2004/04/02 23:35:24 sam Exp $");
#elif defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ieee80211_input.c,v 1.24 2004/05/31 11:12:24 dyoung Exp $");
#endif

#if defined(__NetBSD__)
#include "opt_inet.h"
#endif
a48 3
#ifdef __FreeBSD__
#include <sys/bus.h>
#endif
a52 4
#ifdef __FreeBSD__
#include <machine/atomic.h>
#endif

a56 5
#if defined(__FreeBSD__)
#include <net/ethernet.h>
#elif defined(__NetBSD__)
#include <net/if_ether.h>
#endif
a64 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a65 3
#else
#include <net/if_ether.h>
#endif
a70 1
#ifdef __OpenBSD__
a71 1
#endif
a102 3
#if !defined(__OpenBSD__)
	ALTQ_DECL(struct altq_pktattr pktattr;)
#endif
a232 1
#ifdef __OpenBSD__
a234 4
#else
			    !IEEE80211_ADDR_EQ(wh->i_addr3,
 			        ifp->if_broadcastaddr)) {
#endif
a250 1
#ifdef __OpenBSD__
a252 4
#else
			    !IEEE80211_ADDR_EQ(wh->i_addr1,
 			        ifp->if_broadcastaddr)) {
#endif
a336 7
#if !defined(__OpenBSD__)
#ifdef ALTQ
				if (ALTQ_IS_ENABLED(&ifp->if_snd))
					altq_etherclassify(&ifp->if_snd, m1,
					    &pktattr);
#endif
#endif
a356 1
#if defined(__OpenBSD__)
a357 3
#else
			(*ifp->if_input)(ifp, m);
#endif
a506 3
#if defined(__FreeBSD__)
				M_MOVE_PKTHDR(n, m);
#elif defined(__OpenBSD__)
a507 3
#else
				M_COPY_PKTHDR(n, m);
#endif
@


1.5
log
@make this compile
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.4 2005/02/17 18:28:05 reyk Exp $	*/
d682 1
a682 1
		if (ieee80211_msg_input(ic))				\
d1083 1
a1083 1
			    isprobe ? "probe response" : "beacon", chan));
d1101 1
a1101 1
			    isprobe ? "probe response" : "beacon", bchan, chan));
@


1.4
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.3 2004/12/06 11:15:14 dlg Exp $	*/
d263 1
d265 1
a265 2
#ifdef __OpenBSD__
				etherbroadcastaddr
d267 2
a268 1
 			        ifp->if_broadcastaddr
a269 1
				    )) {
d286 1
d288 1
a288 2
#ifdef __OpenBSD__
				etherbroadcastaddr
d290 2
a291 1
 			        ifp->if_broadcastaddr
a292 1
				    )) {
@


1.3
log
@add a flag that lets a wireless card indicate it can receive probe responses
or beacons on any channel during a scan.

ok damien@@ "come on" deraadt@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.2 2004/11/02 02:15:49 reyk Exp $	*/
a128 1
	u_int8_t *bssid;
d154 2
a155 3
		if (ifp->if_flags & IFF_DEBUG)
			if_printf(ifp, "receive packet with wrong version: %x\n",
			    wh->i_fc[0]);
d172 1
a172 1
		goto out;		/* XXX */
a174 40
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			if (!IEEE80211_ADDR_EQ(wh->i_addr2, ni->ni_bssid)) {
				/* not interested in */
				IEEE80211_DPRINTF2(("%s: discard frame from "
					"bss %s\n", __func__,
					ether_sprintf(wh->i_addr2)));
				ic->ic_stats.is_rx_wrongbss++;
				goto out;
			}
			break;
		case IEEE80211_M_IBSS:
		case IEEE80211_M_AHDEMO:
		case IEEE80211_M_HOSTAP:
			if (dir == IEEE80211_FC1_DIR_NODS)
				bssid = wh->i_addr3;
			else
				bssid = wh->i_addr1;
			if (!IEEE80211_ADDR_EQ(bssid, ic->ic_bss->ni_bssid) &&
#ifdef __OpenBSD__
			    !IEEE80211_ADDR_EQ(bssid, etherbroadcastaddr) &&
#else
			    !IEEE80211_ADDR_EQ(bssid, ifp->if_broadcastaddr) &&
#endif
			    (wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
			    IEEE80211_FC0_TYPE_DATA) {
				/* not interested in */
				IEEE80211_DPRINTF2(("%s: discard frame from "
					"bss %s\n", __func__,
					ether_sprintf(bssid)));
				ic->ic_stats.is_rx_wrongbss++;
				goto out;
			}
			break;
		case IEEE80211_M_MONITOR:
			goto out;
		default:
			/* XXX catch bad values */
			break;
		}
d188 2
d232 9
d260 17
d283 17
a310 1
					ieee80211_free_node(ic, ni);
d316 2
a317 2
				IEEE80211_DPRINTF(("ieee80211_input: "
				    "data from unassoc src %s\n",
a321 1
				ieee80211_unref_node(&ni);
d349 1
a349 1
			IEEE80211_DPRINTF(("ieee80211_input: "
d351 1
a351 1
			    ether_sprintf(wh->i_addr2)));
a373 1
					ieee80211_free_node(ic, ni);
a429 6
		} else {
			if (ic->ic_opmode != IEEE80211_M_IBSS &&
			    subtype == IEEE80211_FC0_SUBTYPE_BEACON) {
				ic->ic_stats.is_rx_mgtdiscard++;
				goto out;
			}
d483 1
a483 1
		IEEE80211_DPRINTF(("%s: bad type %x\n", __func__, type));
d537 1
a537 1
		IEEE80211_DPRINTF(("%s: DS to DS\n", __func__));
d668 32
a705 1
	int allocbs;
d711 3
a713 3
				"state %u, seq %u\n", __func__,
				ether_sprintf(wh->i_addr2),
				ic->ic_state, seq));
d729 3
a731 3
				"state %u, seq %u\n", __func__,
				ether_sprintf(wh->i_addr2),
				ic->ic_state, seq));
d745 1
a745 3
			allocbs = 1;
		} else
			allocbs = 0;
d751 3
a753 1
			    (allocbs ? "newly" : "already"));
d755 1
d761 3
a763 3
				"state %u, seq %u\n", __func__,
				ether_sprintf(wh->i_addr2),
				ic->ic_state, seq));
d767 5
a771 4
			if_printf(&ic->ic_if,
			    "open authentication failed (reason %d) for %s\n",
			    status,
			    ether_sprintf(wh->i_addr3));
d793 1
a793 1
	int allocbs, i;
d854 1
a854 3
				allocbs = 1;
			} else
				allocbs = 0;
d860 2
a861 1
				IEEE80211_DPRINTF(("challenge alloc failed\n"));
d872 2
a873 1
					allocbs ? "" : "re");
d898 1
d962 2
d968 1
a968 1
	int reassoc, resp, newassoc, allocbs;
a978 1
		int isprobe;
d980 16
a995 1
		if (ic->ic_opmode != IEEE80211_M_IBSS &&
d997 1
a997 2
			/* XXX: may be useful for background scan */
			return;
d999 1
a999 1
		isprobe = (subtype == IEEE80211_FC0_SUBTYPE_PROBE_RESP);
d1059 2
a1060 2
						"element; length %u, expecting "
						"1\n", __func__, frm[1]));
d1068 1
a1068 1
					"ignored\n", __func__, *frm, frm[1]));
d1082 2
a1083 3
				"%u\n", __func__,
				isprobe ? "probe response" : "beacon",
				chan));
d1100 2
a1101 3
				"for channel %u\n", __func__,
				isprobe ? "probe response" : "beacon",
				bchan, chan));
d1116 2
a1117 2
		ni = ieee80211_lookup_node(ic, wh->i_addr2,
				&ic->ic_channels[chan]);
d1123 1
a1123 1
			    isprobe ? "probe response" : "beacon",
d1143 5
a1147 5
			ni->ni_esslen = ssid[1];
			memset(ni->ni_essid, 0, sizeof(ni->ni_essid));
			memcpy(ni->ni_essid, ssid + 2, ssid[1]);
			allocbs = 1;
		} else if (ssid[1] != 0 && (isprobe || ni->ni_esslen == 0)) {
d1155 1
a1155 3
			allocbs = 0;
		} else
			allocbs = 0;
d1176 2
a1177 4
		if (ic->ic_state == IEEE80211_S_SCAN)
			ieee80211_unref_node(&ni);	/* NB: do not free */
		else if (ic->ic_opmode == IEEE80211_M_IBSS &&
		    allocbs && isprobe) {
a1184 4
			/* NB: hold reference */
		} else {
			/* XXX optimize to avoid work done above */
			ieee80211_free_node(ic, ni);
d1220 1
a1220 13
		if (ssid[1] != 0 &&
		    (ssid[1] != ic->ic_bss->ni_esslen ||
		    memcmp(ssid + 2, ic->ic_bss->ni_essid, ic->ic_bss->ni_esslen) != 0)) {
#ifdef IEEE80211_DEBUG
			if (ieee80211_debug) {
				printf("%s: ssid mismatch ", __func__);
				ieee80211_print_essid(ssid + 2, ssid[1]);
				printf(" from %s\n", ether_sprintf(wh->i_addr2));
			}
#endif
			ic->ic_stats.is_rx_ssidmismatch++;
			return;
		}
d1226 3
a1228 5
			IEEE80211_DPRINTF(("%s: new req from %s\n",
				__func__, ether_sprintf(wh->i_addr2)));
			allocbs = 1;
		} else
			allocbs = 0;
d1236 1
a1236 1
				__func__,ether_sprintf(wh->i_addr2)));
a1240 2
		if (allocbs)
			ieee80211_free_node(ic, ni);
d1268 2
a1269 2
				"algorithm %d from %s\n",
				__func__, algo, ether_sprintf(wh->i_addr2)));
d1303 1
a1303 1
				__func__, ether_sprintf(wh->i_addr2)));
d1328 9
a1336 15
		if (ssid[1] != ic->ic_bss->ni_esslen ||
		    memcmp(ssid + 2, ic->ic_bss->ni_essid, ssid[1]) != 0) {
#ifdef IEEE80211_DEBUG
			if (ieee80211_debug) {
				printf("%s: ssid mismatch ", __func__);
				ieee80211_print_essid(ssid + 2, ssid[1]);
				printf(" from %s\n", ether_sprintf(wh->i_addr2));
			}
#endif
			ic->ic_stats.is_rx_ssidmismatch++;
			return;
		}
		if (ni == ic->ic_bss) {
			IEEE80211_DPRINTF(("%s: not authenticated for %s\n",
				__func__, ether_sprintf(wh->i_addr2)));
a1341 1
				ieee80211_free_node(ic, ni);
d1358 3
a1360 4
			IEEE80211_DPRINTF(("%s: capability mismatch %x for %s\n",
				__func__, capinfo, ether_sprintf(wh->i_addr2)));
			IEEE80211_AID_CLR(ni->ni_associd, ic->ic_aid_bitmap);
			ni->ni_associd = 0;
d1362 2
a1363 1
				IEEE80211_STATUS_CAPINFO);
d1372 1
a1372 1
				__func__, ether_sprintf(wh->i_addr2)));
a1386 2
		if (ni->ni_associd == 0) {
			u_int16_t aid;
d1388 1
a1388 33
			/*
			 * It would be clever to search the bitmap
			 * more efficiently, but this will do for now.
			 */
			for (aid = 1; aid < ic->ic_max_aid; aid++) {
				if (!IEEE80211_AID_ISSET(aid,
				    ic->ic_aid_bitmap))
					break;
			}

			if (ic->ic_bss->ni_associd >= ic->ic_max_aid) {
				IEEE80211_SEND_MGMT(ic, ni, resp,
				    IEEE80211_REASON_ASSOC_TOOMANY);
				return;
			} else {
				ni->ni_associd = aid | 0xc000;
				IEEE80211_AID_SET(ni->ni_associd,
				    ic->ic_aid_bitmap);
				newassoc = 1;
			}
		} else
			newassoc = 0;
		/* XXX for 11g must turn off short slot time if long
	           slot time sta associates */
		IEEE80211_SEND_MGMT(ic, ni, resp, IEEE80211_STATUS_SUCCESS);
		if (ifp->if_flags & IFF_DEBUG)
			if_printf(ifp, "station %s %s associated at aid %d\n",
			    (newassoc ? "newly" : "already"),
			    ether_sprintf(ni->ni_macaddr),
			    ni->ni_associd & ~0xc000);
		/* give driver a chance to setup state like ni_txrate */
		if (ic->ic_newassoc)
			(*ic->ic_newassoc)(ic, ni, newassoc);
d1397 2
a1398 1
		    ic->ic_state != IEEE80211_S_ASSOC)
d1400 1
d1420 2
a1421 1
				    "association failed (reason %d) for %s\n",
d1471 6
a1476 5
					if_printf(ifp, "station %s deauthenticated"
					    " by peer (reason %d)\n",
					    ether_sprintf(ni->ni_macaddr), reason);
				/* node will be free'd on return */
				ieee80211_unref_node(&ni);
d1502 6
a1507 7
					if_printf(ifp, "station %s disassociated"
					    " by peer (reason %d)\n",
					    ether_sprintf(ni->ni_macaddr), reason);
				IEEE80211_AID_CLR(ni->ni_associd,
				    ic->ic_aid_bitmap);
				ni->ni_associd = 0;
				/* XXX node reclaimed how? */
d1517 1
a1517 1
			"handled\n", __func__, subtype));
d1662 4
d1695 1
@


1.2
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d2 1
a2 1
/*	$OpenBSD: ieee80211_input.c,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d1045 2
a1046 1
		if (chan != bchan && ic->ic_phytype != IEEE80211_T_FH) {
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d2 1
a2 1
/*	$OpenBSD$	*/
d63 1
d100 5
d107 1
d1612 96
@

