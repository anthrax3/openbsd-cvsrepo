head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3;
locks; strict;
comment	@ * @;


1.3
date	2017.01.12.18.06.57;	author stsp;	state Exp;
branches;
next	1.2;
commitid	j9xl1Hx6fze7kB7x;

1.2
date	2016.12.10.14.46.04;	author stsp;	state Exp;
branches;
next	1.1;
commitid	gXYN9oldVl2kFhzl;

1.1
date	2016.11.30.11.38.25;	author stsp;	state Exp;
branches;
next	;
commitid	KrNKZc9DW7M5MWhj;


desc
@@


1.3
log
@Rename ieee80211_mira_node_destroy() to ieee80211_mira_cancel_timeouts().
No functional change.

The previous name was chosen at a time when I could not yet anticipate
what this function would really end up doing.
The new name should make this function's purpose more obvious, especially
where it appears at strategic places in driver code.
@
text
@/*	$OpenBSD: ieee80211_mira.h,v 1.2 2016/12/10 14:46:04 stsp Exp $	*/

/*
 * Copyright (c) 2016 Stefan Sperling <stsp@@openbsd.org>
 * Copyright (c) 2016 Theo Buehler <tb@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _NET80211_IEEE80211_MIRA_H_
#define _NET80211_IEEE80211_MIRA_H_

/* 
 * MiRA - "MIMO Rate Adaptation in 802.11n Wireless Networks"
 * Ioannis Pefkianakis, Yun Hu, Starsky H.Y. Wong, Hao Yang, Songwu Lu
 * http://www.cs.ucla.edu/wing/publication/papers/Pefkianakis.MOBICOM10.pdf
 */

/* The number of data rates MiRA can choose from. */
#define IEEE80211_MIRA_NUM_RATES 32 /* XXX limited to MCS 0-31 */

/* 
 * Goodput statistics struct. Measures the effective data rate of an MCS
 * index and contains data related to time-based probing to a new rate.
 * All uint64_t numbers in this struct use fixed-point arithmetic.
 */
struct ieee80211_mira_goodput_stats {
	uint64_t measured;	/* Most recently measured goodput. */
	uint64_t average;	/* Average measured goodput. */
	uint64_t average_agg;	/* Average number of subframes per frame. */
	uint64_t stddeviation;	/* Goodput standard deviation. */

	/* These fields are used while calculating probe intervals: */
	uint64_t loss;		/* This rate's loss percentage SFER. */
	uint32_t nprobes;	/* Number of probe attempts. */
	uint32_t nprobe_bytes;	/* Number of bytes sent while probing. */
	int probe_interval;	/* Probe interval for this rate. */
	int probe_timeout_triggered; /* It is time to probe this rate. */
};

/*
 * Rate control state.
 */
struct ieee80211_mira_node {
	/*
	 * Fields set by drivers before calling ieee80211_mira_choose().
	 */
	uint32_t frames;	/* Increment per (sub-)frame transmitted. */
	uint32_t retries;	/* Increment per Tx retry (frame not ACKed). */
	uint32_t txfail;	/* Increment per Tx failure (also not ACKed). */
	uint32_t ampdu_size;	/* Length of last (aggregated) frame sent. */
	uint32_t agglen;	/* Number of subframes in last frame (1-64). */

	/* 
	 * Private fields for use by the rate control algorithm.
	 */

	/* Bitmaps MCS 0-31. */
	uint32_t valid_rates;
	uint32_t candidate_rates;
	uint32_t probed_rates;

	/* Timeouts which trigger time-driven probing. */
	struct timeout probe_to[2];
#define IEEE80211_MIRA_PROBE_TO_INVALID	-1
#define IEEE80211_MIRA_PROBE_TO_UP	0
#define IEEE80211_MIRA_PROBE_TO_DOWN	1
	int probe_timer_expired[2];

	/* Probing state. */
	int probing;
#define IEEE80211_MIRA_NOT_PROBING	0x0
#define IEEE80211_MIRA_PROBING_DOWN	0x1
#define IEEE80211_MIRA_PROBING_UP	0x2
#define IEEE80211_MIRA_PROBING_INTER	0x4 /* combined with UP or DOWN */

	/* The current best MCS found by probing. */
	int best_mcs;

	/* Goodput statistics for each MCS. */
	struct ieee80211_mira_goodput_stats g[IEEE80211_MIRA_NUM_RATES];
};

/* Initialize rate control state. */
void	ieee80211_mira_node_init(struct ieee80211_mira_node *);

/* Called by drivers from the Tx completion interrupt handler. */
void	ieee80211_mira_choose(struct ieee80211_mira_node *,
	    struct ieee80211com *, struct ieee80211_node *);

/* Cancel timeouts scheduled by ieee80211_mira_choose(). */
void	ieee80211_mira_cancel_timeouts(struct ieee80211_mira_node *);

#endif /* _NET80211_IEEE80211_MIRA_H_ */
@


1.2
log
@Make mira rate scaling actually work with MIMO Tx rates.
The previous approach with an extra timeout was dumb (and of course untested).

Additional fixes include:
- Take HT protection settings into account when determining whether RTS is used.
- Stop probing the current rateset as soon as measurements become worse.
- Properly move probing timeouts for bad rates further into the future.

Tested with MIMO-enabled iwm(4) (MCS 0-15) and also iwn(4) (MCS 0-7 only).
Early versions also tested by phessler@@ and bmercer@@, and more testing by tb@@.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_mira.h,v 1.1 2016/11/30 11:38:25 stsp Exp $	*/
d94 1
a94 1
/* Set up and tear down rate control. */
a95 1
void	ieee80211_mira_node_destroy(struct ieee80211_mira_node *);
d100 3
@


1.1
log
@Add a new implementation of MiRA, a rate scaling algorithm for 802.11n.
This algorithm was designed for use with MIMO and Tx aggregation.

This is joint work with tb@@, who helped with all the tricky math bits.
Additional help with testing by phessler@@, mpi@@, and jmatthew@@.
I believe this is now ready for wider testing, and for future work to
happen in-tree.

A paper which explains the algorithm can be found at:
http://www.cs.ucla.edu/wing/publication/papers/Pefkianakis.MOBICOM10.pdf

Roughly, this algorithm attempts to keep track of the current "goodput"
(the effective data rate) for each MCS. It converges towards a rate which
gets the most bits per second transmitted with least loss.

Occasionally, frames will be steered to different rates to probe for changes.
(The algorithm does not send frames on its own. It only advances whenever
the driver has sent a frame.)

Time-based probing to adjacent MCS rates occurs periodically.
This is similar to what AMRR does, except that eventually mira will
try out multi-antenna modes as well.

Event-based probing happens when a sudden change in goodput is detected.
I've chosen to make downwards probing fast, and upwards probing slow.
(The paper does not specify such a preference.)
This means it should react quickly to worsening conditions and pull the
rate down (perhaps to the lowest possible rate). It should then raise
upwards slowly on a rate-per-rate basis as conditions improve again.
In my testing this works as intended as I keep moving a laptop outside
and inside the AP's range.

Not linked to the build yet.

ok mpi@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a74 1
	struct timeout probe_to[3];
d78 1
a78 2
#define IEEE80211_MIRA_PROBE_TO_INTER	2
	int probe_timer_expired[3];
d82 4
a85 4
#define IEEE80211_MIRA_PROBING_DOWN	(-1)
#define IEEE80211_MIRA_NOT_PROBING	(0)
#define IEEE80211_MIRA_PROBING_UP	(1)
#define IEEE80211_MIRA_PROBING_INTER	(2)
a88 3

	/* The first rateset we probed during inter-rateset probing. */
	const struct ieee80211_mira_rateset *rs_inter;
@

