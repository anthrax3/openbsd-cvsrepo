head	1.79;
access;
symbols
	OPENBSD_6_2:1.79.0.2
	OPENBSD_6_2_BASE:1.79
	OPENBSD_6_1:1.77.0.4
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.72.0.2
	OPENBSD_6_0_BASE:1.72
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.62.0.18
	OPENBSD_5_8_BASE:1.62
	OPENBSD_5_7:1.62.0.10
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.62.0.14
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.62.0.12
	OPENBSD_5_5_BASE:1.62
	OPENBSD_5_4:1.62.0.8
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.62.0.6
	OPENBSD_5_3_BASE:1.62
	OPENBSD_5_2:1.62.0.4
	OPENBSD_5_2_BASE:1.62
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.61.0.6
	OPENBSD_5_0_BASE:1.61
	OPENBSD_4_9:1.61.0.4
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.60.0.2
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.60.0.4
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.6.0.2
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.1.0.2
	OPENBSD_3_6_BASE:1.1;
locks; strict;
comment	@ * @;


1.79
date	2017.05.31.09.17.40;	author stsp;	state Exp;
branches;
next	1.78;
commitid	HdZFWQoBUy9k2Mzr;

1.78
date	2017.05.30.11.00.38;	author stsp;	state Exp;
branches;
next	1.77;
commitid	NPhlcjTPJ3dZlUbu;

1.77
date	2017.02.02.16.47.53;	author stsp;	state Exp;
branches;
next	1.76;
commitid	PETPfbQ5ZWdJqIYS;

1.76
date	2017.01.30.18.21.13;	author stsp;	state Exp;
branches;
next	1.75;
commitid	w2LbgTYoQ2p1IyTt;

1.75
date	2017.01.09.16.24.20;	author stsp;	state Exp;
branches;
next	1.74;
commitid	2R4xID7oIXEJOE2Q;

1.74
date	2017.01.09.12.40.00;	author stsp;	state Exp;
branches;
next	1.73;
commitid	G3vWsV1lhNxxnROO;

1.73
date	2016.12.17.18.35.54;	author stsp;	state Exp;
branches;
next	1.72;
commitid	jPAQ1b8Z1ErNDg1z;

1.72
date	2016.05.21.09.07.11;	author stsp;	state Exp;
branches;
next	1.71;
commitid	2Km71Ne0nKLHIdCy;

1.71
date	2016.01.25.11.27.11;	author stsp;	state Exp;
branches;
next	1.70;
commitid	U9Unyh02TU5iq9jc;

1.70
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.69;
commitid	1npmDuWgN1zBR6BQ;

1.69
date	2016.01.06.19.56.50;	author stsp;	state Exp;
branches;
next	1.68;
commitid	vqkvQcVZc1K7MmHQ;

1.68
date	2016.01.05.18.41.16;	author stsp;	state Exp;
branches;
next	1.67;
commitid	2QagMjdMhQhIaQgu;

1.67
date	2015.11.15.12.34.07;	author stsp;	state Exp;
branches;
next	1.66;
commitid	H9x7JLZ3OXXsR8Zh;

1.66
date	2015.11.15.01.05.25;	author stsp;	state Exp;
branches;
next	1.65;
commitid	8QkBLu4fXKUF5YHk;

1.65
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.64;
commitid	YT6fyIEviv9qwbl6;

1.64
date	2015.09.27.16.51.31;	author stsp;	state Exp;
branches;
next	1.63;
commitid	5o9NLs0KUeEhqoBD;

1.63
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.62;
commitid	6vhYvh5CxZAHMnsN;

1.62
date	2012.01.21.19.42.16;	author stsp;	state Exp;
branches;
next	1.61;

1.61
date	2010.07.19.18.53.52;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2009.05.19.16.09.02;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.26.20.38.29;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2009.02.08.15.34.39;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.28.18.55.18;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2008.11.13.13.42.35;	author djm;	state Exp;
branches;
next	1.54;

1.54
date	2008.09.27.15.16.09;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2008.09.08.13.13.01;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.01.19.55.21;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2008.09.01.19.41.11;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2008.08.29.08.40.53;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.27.10.58.01;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2008.08.27.09.05.04;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2008.08.12.19.59.09;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2008.08.12.18.30.56;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2008.08.12.18.01.41;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2008.08.12.17.53.13;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.28.19.42.13;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2008.07.27.18.24.01;	author damien;	state Exp;
branches;
next	1.40;

1.40
date	2008.07.21.19.27.26;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2008.07.21.18.43.18;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.17.14.05.01;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2007.11.14.11.16.27;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2007.11.03.14.59.55;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2007.11.01.22.34.19;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.22.20.40.34;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.28.11.13.41;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.24.16.49.16;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.05.20.19.21;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.04.20.16.25;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.03.20.25.33;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.02.16.46.44;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.21.20.11.16;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.21.18.21.01;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.17.09.09.35;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.16.13.17.05;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.11.19.35.24;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.07.20.24.42;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.06.19.31.07;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.15.18.59.37;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.27.20.55.51;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.24.14.14.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.23.21.34.15;	author reyk;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.18.18.39.41;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2005.09.13.12.11.03;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.08.13.24.53;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.09.07.05.40.11;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.25.07.40.49;	author reyk;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.13.01.06.41;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.04.21.22.47.15;	author reyk;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.15.19.44.15;	author reyk;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.25.20.40.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.06.11.15.14;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.02.02.15.49;	author reyk;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.22.53.52;	author millert;	state Exp;
branches;
next	;


desc
@@


1.79
log
@The net80211 stack was providing a 'beacon miss timeout' value (in ms)
which specified how much time may elapse without beacons before drivers
begin searching for a new AP.

Drivers convert this timeout value into the amount of beacons they're allowed
to miss. Having the stack provide this number upfront simplifies things.

ok mpi@@
@
text
@/*	$OpenBSD: ieee80211_var.h,v 1.78 2017/05/30 11:00:38 stsp Exp $	*/
/*	$NetBSD: ieee80211_var.h,v 1.7 2004/05/06 03:07:10 dyoung Exp $	*/

/*-
 * Copyright (c) 2001 Atsushi Onoe
 * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/net80211/ieee80211_var.h,v 1.15 2004/04/05 22:10:26 sam Exp $
 */
#ifndef _NET80211_IEEE80211_VAR_H_
#define _NET80211_IEEE80211_VAR_H_

/*
 * Definitions for IEEE 802.11 drivers.
 */

#ifdef	SMALL_KERNEL
#define IEEE80211_STA_ONLY	1
#endif

#include <sys/timeout.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_crypto.h>
#include <net80211/ieee80211_ioctl.h>		/* for ieee80211_stats */
#include <net80211/ieee80211_node.h>
#include <net80211/ieee80211_proto.h>

#define	IEEE80211_CHAN_MAX	255
#define	IEEE80211_CHAN_ANY	0xffff		/* token for ``any channel'' */
#define	IEEE80211_CHAN_ANYC \
	((struct ieee80211_channel *) IEEE80211_CHAN_ANY)

#define	IEEE80211_TXPOWER_MAX	100	/* max power */
#define	IEEE80211_TXPOWER_MIN	-50	/* kill radio (if possible) */

enum ieee80211_phytype {
	IEEE80211_T_DS,			/* direct sequence spread spectrum */
	IEEE80211_T_OFDM,		/* frequency division multiplexing */
	IEEE80211_T_XR		        /* extended range mode */
};
#define	IEEE80211_T_CCK	IEEE80211_T_DS	/* more common nomenclature */

/* XXX not really a mode; there are really multiple PHY's */
enum ieee80211_phymode {
	IEEE80211_MODE_AUTO	= 0,	/* autoselect */
	IEEE80211_MODE_11A	= 1,	/* 5GHz, OFDM */
	IEEE80211_MODE_11B	= 2,	/* 2GHz, CCK */
	IEEE80211_MODE_11G	= 3,	/* 2GHz, OFDM */
	IEEE80211_MODE_11N	= 4,	/* 11n, 2GHz/5GHz */
};
#define	IEEE80211_MODE_MAX	(IEEE80211_MODE_11N+1)

enum ieee80211_opmode {
	IEEE80211_M_STA		= 1,	/* infrastructure station */
#ifndef IEEE80211_STA_ONLY
	IEEE80211_M_IBSS	= 0,	/* IBSS (adhoc) station */
	IEEE80211_M_AHDEMO	= 3,	/* Old lucent compatible adhoc demo */
	IEEE80211_M_HOSTAP	= 6,	/* Software Access Point */
#endif
	IEEE80211_M_MONITOR	= 8	/* Monitor mode */
};

/*
 * 802.11g protection mode.
 */
enum ieee80211_protmode {
	IEEE80211_PROT_NONE	= 0,	/* no protection */
	IEEE80211_PROT_CTSONLY	= 1,	/* CTS to self */
	IEEE80211_PROT_RTSCTS	= 2	/* RTS-CTS */
};

/*
 * Channels are specified by frequency and attributes.
 */
struct ieee80211_channel {
	u_int16_t	ic_freq;	/* setting in MHz */
	u_int16_t	ic_flags;	/* see below */
};

/*
 * Channel attributes (XXX must keep in sync with radiotap flags).
 */
#define IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
#define IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
#define IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel */
#define IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
#define IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
#define IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
#define IEEE80211_CHAN_XR	0x1000	/* Extended range OFDM channel */
#define IEEE80211_CHAN_HT	0x2000	/* 11n/HT channel */

/*
 * Useful combinations of channel characteristics.
 */
#define IEEE80211_CHAN_A \
	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)
#define IEEE80211_CHAN_B \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)
#define IEEE80211_CHAN_PUREG \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)
#define IEEE80211_CHAN_G \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)

#define	IEEE80211_IS_CHAN_A(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_A) == IEEE80211_CHAN_A)
#define	IEEE80211_IS_CHAN_B(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_B) == IEEE80211_CHAN_B)
#define	IEEE80211_IS_CHAN_PUREG(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_PUREG) == IEEE80211_CHAN_PUREG)
#define	IEEE80211_IS_CHAN_G(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_G) == IEEE80211_CHAN_G)
#define	IEEE80211_IS_CHAN_N(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_HT) == IEEE80211_CHAN_HT)

#define	IEEE80211_IS_CHAN_2GHZ(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_2GHZ) != 0)
#define	IEEE80211_IS_CHAN_5GHZ(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_5GHZ) != 0)
#define	IEEE80211_IS_CHAN_OFDM(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_OFDM) != 0)
#define	IEEE80211_IS_CHAN_CCK(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_CCK) != 0)
#define	IEEE80211_IS_CHAN_XR(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_XR) != 0)

/*
 * EDCA AC parameters.
 */
struct ieee80211_edca_ac_params {
	u_int8_t	ac_ecwmin;	/* CWmin = 2^ECWmin - 1 */
	u_int8_t	ac_ecwmax;	/* CWmax = 2^ECWmax - 1 */
	u_int8_t	ac_aifsn;
	u_int16_t	ac_txoplimit;	/* 32TU */
#define IEEE80211_TXOP_TO_US(txop)	((txop) * 32)

	u_int8_t	ac_acm;
};

extern const struct ieee80211_edca_ac_params
	    ieee80211_edca_table[IEEE80211_MODE_MAX][EDCA_NUM_AC];
extern const struct ieee80211_edca_ac_params
	    ieee80211_qap_edca_table[IEEE80211_MODE_MAX][EDCA_NUM_AC];

#define IEEE80211_DEFRAG_SIZE	3	/* must be >= 3 according to spec */
/*
 * Entry in the fragment cache.
 */
struct ieee80211_defrag {
	struct timeout	df_to;
	struct mbuf	*df_m;
	u_int16_t	df_seq;
	u_int8_t	df_frag;
};

#define IEEE80211_PROTO_NONE	0
#define IEEE80211_PROTO_RSN	(1 << 0)
#define IEEE80211_PROTO_WPA	(1 << 1)

#define	IEEE80211_SCAN_UNLOCKED	0x0
#define	IEEE80211_SCAN_LOCKED	0x1
#define	IEEE80211_SCAN_REQUEST	0x2
#define	IEEE80211_SCAN_RESUME	0x4

#define IEEE80211_GROUP_NKID	6

struct ieee80211com {
	struct arpcom		ic_ac;
	LIST_ENTRY(ieee80211com) ic_list;	/* chain of all ieee80211com */
	void			(*ic_recv_mgmt)(struct ieee80211com *,
				    struct mbuf *, struct ieee80211_node *,
				    struct ieee80211_rxinfo *, int);
	int			(*ic_send_mgmt)(struct ieee80211com *,
				    struct ieee80211_node *, int, int, int);
	int			(*ic_newstate)(struct ieee80211com *,
				    enum ieee80211_state, int);
	void			(*ic_newassoc)(struct ieee80211com *,
				    struct ieee80211_node *, int);
	void			(*ic_node_leave)(struct ieee80211com *,
				    struct ieee80211_node *);
	void			(*ic_updateslot)(struct ieee80211com *);
	void			(*ic_updateedca)(struct ieee80211com *);
	void			(*ic_set_tim)(struct ieee80211com *, int, int);
	int			(*ic_set_key)(struct ieee80211com *,
				    struct ieee80211_node *,
				    struct ieee80211_key *);
	void			(*ic_delete_key)(struct ieee80211com *,
				    struct ieee80211_node *,
				    struct ieee80211_key *);
	int			(*ic_ampdu_tx_start)(struct ieee80211com *,
				    struct ieee80211_node *, u_int8_t);
	void			(*ic_ampdu_tx_stop)(struct ieee80211com *,
				    struct ieee80211_node *, u_int8_t);
	int			(*ic_ampdu_rx_start)(struct ieee80211com *,
				    struct ieee80211_node *, u_int8_t);
	void			(*ic_ampdu_rx_stop)(struct ieee80211com *,
				    struct ieee80211_node *, u_int8_t);
	void			(*ic_update_htprot)(struct ieee80211com *,
					struct ieee80211_node *);
	u_int8_t		ic_myaddr[IEEE80211_ADDR_LEN];
	struct ieee80211_rateset ic_sup_rates[IEEE80211_MODE_MAX];
	struct ieee80211_channel ic_channels[IEEE80211_CHAN_MAX+1];
	u_char			ic_chan_avail[howmany(IEEE80211_CHAN_MAX,NBBY)];
	u_char			ic_chan_active[howmany(IEEE80211_CHAN_MAX, NBBY)];
	u_char			ic_chan_scan[howmany(IEEE80211_CHAN_MAX,NBBY)];
	struct mbuf_queue	ic_mgtq;
	struct mbuf_queue	ic_pwrsaveq;
	u_int			ic_scan_lock;	/* user-initiated scan */
	u_int8_t		ic_scan_count;	/* count scans */
	u_int32_t		ic_flags;	/* state flags */
	u_int32_t		ic_caps;	/* capabilities */
	u_int16_t		ic_modecaps;	/* set of mode capabilities */
	u_int16_t		ic_curmode;	/* current mode */
	enum ieee80211_phytype	ic_phytype;	/* XXX wrong for multi-mode */
	enum ieee80211_opmode	ic_opmode;	/* operation mode */
	enum ieee80211_state	ic_state;	/* 802.11 state */
	u_int32_t		*ic_aid_bitmap;
	u_int16_t		ic_max_aid;
	enum ieee80211_protmode	ic_protmode;	/* 802.11g protection mode */
	struct ifmedia		ic_media;	/* interface media config */
	caddr_t			ic_rawbpf;	/* packet filter structure */
	struct ieee80211_node	*ic_bss;	/* information for this node */
	struct ieee80211_channel *ic_ibss_chan;
	int			ic_fixed_rate;	/* index to ic_sup_rates[] */
	u_int16_t		ic_rtsthreshold;
	u_int16_t		ic_fragthreshold;
	u_int			ic_scangen;	/* gen# for timeout scan */
	struct ieee80211_node	*(*ic_node_alloc)(struct ieee80211com *);
	void			(*ic_node_free)(struct ieee80211com *,
					struct ieee80211_node *);
	void			(*ic_node_copy)(struct ieee80211com *,
					struct ieee80211_node *,
					const struct ieee80211_node *);
	u_int8_t		(*ic_node_getrssi)(struct ieee80211com *,
					const struct ieee80211_node *);
	u_int8_t		ic_max_rssi;
	struct ieee80211_tree	ic_tree;
	int			ic_nnodes;	/* length of ic_nnodes */
	int			ic_max_nnodes;	/* max length of ic_nnodes */
	u_int16_t		ic_lintval;	/* listen interval */
	int16_t			ic_txpower;	/* tx power setting (dBm) */
	int			ic_bmissthres;	/* beacon miss threshold */
	int			ic_mgt_timer;	/* mgmt timeout */
#ifndef IEEE80211_STA_ONLY
	struct timeout		ic_inact_timeout; /* node inactivity timeout */
	struct timeout		ic_node_cache_timeout;
#endif
	int			ic_des_esslen;
	u_int8_t		ic_des_essid[IEEE80211_NWID_LEN];
	struct ieee80211_channel *ic_des_chan;	/* desired channel */
	u_int8_t		ic_des_bssid[IEEE80211_ADDR_LEN];
	struct ieee80211_key	ic_nw_keys[IEEE80211_GROUP_NKID];
	int			ic_def_txkey;	/* group data key index */
#define ic_wep_txkey	ic_def_txkey
	int			ic_igtk_kid;	/* IGTK key index */
	u_int32_t		ic_iv;		/* initial vector for wep */
	struct ieee80211_stats	ic_stats;	/* statistics */
	struct timeval		ic_last_merge_print;	/* for rate-limiting
							 * IBSS merge print-outs
							 */
	struct ieee80211_edca_ac_params ic_edca_ac[EDCA_NUM_AC];
	u_int			ic_edca_updtcount;
	u_int16_t		ic_tid_noack;
	u_int8_t		ic_globalcnt[EAPOL_KEY_NONCE_LEN];
	u_int8_t		ic_nonce[EAPOL_KEY_NONCE_LEN];
	u_int8_t		ic_psk[IEEE80211_PMK_LEN];
	struct timeout		ic_rsn_timeout;
	int			ic_tkip_micfail;
	u_int64_t		ic_tkip_micfail_last_tsc;
#ifndef IEEE80211_STA_ONLY
	struct timeout		ic_tkip_micfail_timeout;
#endif

	TAILQ_HEAD(, ieee80211_pmk) ic_pmksa;	/* PMKSA cache */
	u_int			ic_rsnprotos;
	u_int			ic_rsnakms;
	u_int			ic_rsnciphers;
	enum ieee80211_cipher	ic_rsngroupcipher;
	enum ieee80211_cipher	ic_rsngroupmgmtcipher;

	struct ieee80211_defrag	ic_defrag[IEEE80211_DEFRAG_SIZE];
	int			ic_defrag_cur;

	u_int8_t		*ic_tim_bitmap;
	u_int			ic_tim_len;
	u_int			ic_tim_mcast_pending;
	u_int			ic_dtim_period;
	u_int			ic_dtim_count;

	u_int32_t		ic_txbfcaps;
	u_int16_t		ic_htcaps;
	u_int8_t		ic_ampdu_params;
	u_int8_t		ic_sup_mcs[howmany(80, NBBY)];
	u_int16_t		ic_max_rxrate;	/* in Mb/s, 0 <= rate <= 1023 */
	u_int8_t		ic_tx_mcs_set;
	u_int16_t		ic_htxcaps;
	u_int8_t		ic_aselcaps;
	u_int8_t		ic_dialog_token;
	int			ic_fixed_mcs;

	LIST_HEAD(, ieee80211_vap) ic_vaps;
};
#define	ic_if		ic_ac.ac_if
#define	ic_softc	ic_if.if_softc

LIST_HEAD(ieee80211com_head, ieee80211com);
extern struct ieee80211com_head ieee80211com_head;

#define	IEEE80211_ADDR_EQ(a1,a2)	(memcmp(a1,a2,IEEE80211_ADDR_LEN) == 0)
#define	IEEE80211_ADDR_COPY(dst,src)	memcpy(dst,src,IEEE80211_ADDR_LEN)

/* ic_flags */
#define	IEEE80211_F_ASCAN	0x00000001	/* STATUS: active scan */
#define	IEEE80211_F_SIBSS	0x00000002	/* STATUS: start IBSS */
#define	IEEE80211_F_WEPON	0x00000100	/* CONF: WEP enabled */
#define	IEEE80211_F_IBSSON	0x00000200	/* CONF: IBSS creation enable */
#define	IEEE80211_F_PMGTON	0x00000400	/* CONF: Power mgmt enable */
#define	IEEE80211_F_DESBSSID	0x00000800	/* CONF: des_bssid is set */
#define	IEEE80211_F_ROAMING	0x00002000	/* CONF: roaming enabled */
#define	IEEE80211_F_TXPMGT	0x00018000	/* STATUS: tx power */
#define IEEE80211_F_TXPOW_OFF	0x00000000	/* TX Power: radio disabled */
#define IEEE80211_F_TXPOW_FIXED	0x00008000	/* TX Power: fixed rate */
#define IEEE80211_F_TXPOW_AUTO	0x00010000	/* TX Power: undefined */
#define	IEEE80211_F_SHSLOT	0x00020000	/* STATUS: short slot time */
#define	IEEE80211_F_SHPREAMBLE	0x00040000	/* STATUS: short preamble */
#define IEEE80211_F_QOS		0x00080000	/* CONF: QoS enabled */
#define	IEEE80211_F_USEPROT	0x00100000	/* STATUS: protection enabled */
#define	IEEE80211_F_RSNON	0x00200000	/* CONF: RSN enabled */
#define	IEEE80211_F_PSK		0x00400000	/* CONF: pre-shared key set */
#define IEEE80211_F_COUNTERM	0x00800000	/* STATUS: countermeasures */
#define IEEE80211_F_MFPR	0x01000000	/* CONF: MFP required */
#define	IEEE80211_F_HTON	0x02000000	/* CONF: HT enabled */
#define	IEEE80211_F_PBAR	0x04000000	/* CONF: PBAC required */
#define IEEE80211_F_USERMASK	0xf0000000	/* CONF: ioctl flag mask */

/* ic_caps */
#define	IEEE80211_C_WEP		0x00000001	/* CAPABILITY: WEP available */
#define	IEEE80211_C_IBSS	0x00000002	/* CAPABILITY: IBSS available */
#define	IEEE80211_C_PMGT	0x00000004	/* CAPABILITY: Power mgmt */
#define	IEEE80211_C_HOSTAP	0x00000008	/* CAPABILITY: HOSTAP avail */
#define	IEEE80211_C_AHDEMO	0x00000010	/* CAPABILITY: Old Adhoc Demo */
#define	IEEE80211_C_APPMGT	0x00000020	/* CAPABILITY: AP power mgmt */
#define	IEEE80211_C_TXPMGT	0x00000040	/* CAPABILITY: tx power mgmt */
#define	IEEE80211_C_SHSLOT	0x00000080	/* CAPABILITY: short slottime */
#define	IEEE80211_C_SHPREAMBLE	0x00000100	/* CAPABILITY: short preamble */
#define	IEEE80211_C_MONITOR	0x00000200	/* CAPABILITY: monitor mode */
#define IEEE80211_C_SCANALL	0x00000400	/* CAPABILITY: scan all chan */
#define IEEE80211_C_QOS		0x00000800	/* CAPABILITY: QoS avail */
#define IEEE80211_C_RSN		0x00001000	/* CAPABILITY: RSN avail */
#define IEEE80211_C_MFP		0x00002000	/* CAPABILITY: MFP avail */
#define IEEE80211_C_RAWCTL	0x00004000	/* CAPABILITY: raw ctl */
#define IEEE80211_C_SCANALLBAND	0x00008000	/* CAPABILITY: scan all bands */

/* flags for ieee80211_fix_rate() */
#define	IEEE80211_F_DOSORT	0x00000001	/* sort rate list */
#define	IEEE80211_F_DOFRATE	0x00000002	/* use fixed rate */
#define	IEEE80211_F_DONEGO	0x00000004	/* calc negotiated rate */
#define	IEEE80211_F_DODEL	0x00000008	/* delete ignore rate */

void	ieee80211_ifattach(struct ifnet *);
void	ieee80211_ifdetach(struct ifnet *);
void	ieee80211_channel_init(struct ifnet *);
void	ieee80211_media_init(struct ifnet *, ifm_change_cb_t, ifm_stat_cb_t);
int	ieee80211_media_change(struct ifnet *);
void	ieee80211_media_status(struct ifnet *, struct ifmediareq *);
int	ieee80211_ioctl(struct ifnet *, u_long, caddr_t);
int	ieee80211_get_rate(struct ieee80211com *);
void	ieee80211_watchdog(struct ifnet *);
int	ieee80211_fix_rate(struct ieee80211com *, struct ieee80211_node *, int);
uint64_t	ieee80211_rate2media(struct ieee80211com *, int,
		    enum ieee80211_phymode);
int	ieee80211_media2rate(uint64_t);
uint64_t	ieee80211_mcs2media(struct ieee80211com *, int,
		    enum ieee80211_phymode);
int	ieee80211_media2mcs(uint64_t);
u_int8_t ieee80211_rate2plcp(u_int8_t, enum ieee80211_phymode);
u_int8_t ieee80211_plcp2rate(u_int8_t, enum ieee80211_phymode);
u_int	ieee80211_mhz2ieee(u_int, u_int);
u_int	ieee80211_chan2ieee(struct ieee80211com *,
		const struct ieee80211_channel *);
u_int	ieee80211_ieee2mhz(u_int, u_int);
int	ieee80211_min_basic_rate(struct ieee80211com *);
int	ieee80211_max_basic_rate(struct ieee80211com *);
int	ieee80211_setmode(struct ieee80211com *, enum ieee80211_phymode);
enum ieee80211_phymode ieee80211_next_mode(struct ifnet *);
enum ieee80211_phymode ieee80211_chan2mode(struct ieee80211com *,
		const struct ieee80211_channel *);

extern	int ieee80211_cache_size;

#endif /* _NET80211_IEEE80211_VAR_H_ */
@


1.78
log
@Introduce ieee80211_min_basic_rate() and ieee80211_max_basic_rate().

These helpers can be used by drivers to improve compatibility with APs
that disable some mandatory PHY rates in the basic rate set.

For instance, many of our drivers hard-code 11b rates on 2 Ghz and run
into problems when APs disable them. Since 11b rates are being disabled
by default by some vendors, hardcoding them is not a good idea anymore.

ok mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.77 2017/02/02 16:47:53 stsp Exp $	*/
d265 1
a265 1
	u_int16_t		ic_bmisstimeout;/* beacon miss threshold (ms) */
@


1.77
log
@Remove global counters from struct ieee80211com which track the number of
associated nodes with particular properties: 11b-only ("non-ERP") nodes,
nodes requiring long slot time, nodes using WPA, nodes not supporting 11n,
nodes currently dozing in powersave state, and nodes with a pending group
key update confirmation.

These counters weren't properly maintained.
There are bugs in the stack where these counters and actual node properties
got out of sync. This is exposed by panics which are supposed to help us
catch such bugs. But these panics don't provide real clues.

Instead of maintaining global counters forcing us to hunt refcounting bugs,
count nodes with the property in question on demand, by iterating over all
nodes and checking their state.
This is cheap since we'll never have more than 100 nodes cached, and none of
the cases where we need such information is in a performance critical path.

Prevents panics in hostap mode reported by Lauri Tirkkonen on bugs@@ last
year (https://marc.info/?l=openbsd-bugs&m=147513817930489&w=2) and also
encountered by my 11n APs ("panic: bogus non-HT station count 0").

tested by Lauri, tb@@, and myself
ok mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.76 2017/01/30 18:21:13 stsp Exp $	*/
d405 2
@


1.76
log
@Enable ieee80211_edca_table, which was under #if 0. This table can be used
by drivers to pass default EDCA parameters to firmware instead of passing
local hardcoded values.
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.75 2017/01/09 16:24:20 stsp Exp $	*/
a265 4
	u_int16_t		ic_nonerpsta;	/* # non-ERP stations */
	u_int16_t		ic_longslotsta;	/* # long slot time stations */
	u_int16_t		ic_rsnsta;	/* # RSN stations */
	u_int16_t		ic_pssta;	/* # ps mode stations */
a290 1
	u_int16_t		ic_rsn_keydonesta;
a312 3
#ifndef IEEE80211_STA_ONLY
	u_int16_t		ic_nonhtsta;	/* # non-HT stations */
#endif
@


1.75
log
@Make the net80211 stack send EDCA parameters to the driver in hostap mode.
Fixes problems with timing of frame transmissions which caused packet loss.
tested by myself and tb@@
ok phessler@@ mpi@@ tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.74 2017/01/09 12:40:00 stsp Exp $	*/
d163 2
@


1.74
log
@Manage the HT protection setting if acting as hostap with 11n enabled.

For now we flip-flop only between non-member protection and non-HT protection.
Running a HT network without protection would require monitoring environmental
conditions (e.g. foreign beacons) which make HT protection necessary.

The ic_update_htprot driver function becomes optional because it won't be
needed by all drivers. Only call it if the driver has set a function pointer.

ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.73 2016/12/17 18:35:54 stsp Exp $	*/
d162 3
@


1.73
log
@Complete our half-done implementation of TKIP countermeasures in hostap mode.

The previous code would disable the AP until next reboot upon MIC failure.
Instead, disable the AP for 60 seconds, as required by the 802.11 standard.
I randomly added a bit of time (up to 120 seconds total) just because we can.

Problem reported by Mathy Vanhoef, thanks!
ok deraadt@@
random input reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.72 2016/05/21 09:07:11 stsp Exp $	*/
d313 3
@


1.72
log
@Add a wireless driver capability flag for devices which scan 2GHz and 5GHz
bands in a single scan offload request. This will be used by iwm(4) soon.
ok kettenis@@, earlier version ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.71 2016/01/25 11:27:11 stsp Exp $	*/
d293 3
@


1.71
log
@Keep track of HT protection settings in beacons and have 11n-capable
drivers update hardware configuration accordingly.
tested by myself, tb@@, deraadt@@, abieber@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.70 2016/01/12 09:28:09 stsp Exp $	*/
d372 1
@


1.70
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.69 2016/01/06 19:56:50 stsp Exp $	*/
d216 2
@


1.69
log
@Initialize the A-MPDU parameters field in HT capability elements.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.68 2016/01/05 18:41:16 stsp Exp $	*/
a62 1
	IEEE80211_T_TURBO,		/* high rate OFDM, aka turbo mode */
d73 1
a73 2
	IEEE80211_MODE_TURBO	= 4,	/* 5GHz, OFDM, 2x clock */
	IEEE80211_MODE_11N	= 5,	/* 11n, 2GHz/5GHz */
a106 1
#define IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
a126 4
#define IEEE80211_CHAN_T \
	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
#define IEEE80211_CHAN_TG \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
a135 4
#define	IEEE80211_IS_CHAN_T(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_T) == IEEE80211_CHAN_T)
#define	IEEE80211_IS_CHAN_TG(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_TG) == IEEE80211_CHAN_TG)
@


1.68
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.67 2015/11/15 12:34:07 stsp Exp $	*/
d321 1
@


1.67
log
@Expose 11n mode to the ifmedia layer and introduce the concept of MCS.
Make sure 11n features are enabled only if media type is autoselect or 11n.

11n mode uses MCS (modulation & coding scheme) instead of rates like 11a/b/g.
This means we'll have to take the current mode into account and decide whether
to use a rate or an MCS for transmission. Receiving frames on legacy rates
will still work in 11n mode. We just won't be using legacy rates to send
data frames to an STA or AP we negotiated 11n features with.

My initial plan was to grow the ieee80211_rateset structure and treat MCS
just like rates. However, ieee80211_rateset corresponds to rates and xrates
elements in management frames and is copied directly into such elements
so its size cannot change. Thus, MCS stands on its own and corresponds to
elements in management frames related to 11n HT capabilities.

ok deraadt mpi phessler kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.66 2015/11/15 01:05:25 stsp Exp $	*/
a41 1
#define IEEE80211_NO_HT		1	/* no HT yet */
a318 1
#ifndef IEEE80211_NO_HT
a327 1
#endif
a399 1
#ifndef IEEE80211_NO_HT
a402 1
#endif
@


1.66
log
@Declare 802.11n mode and channel flags. Tweak 11n related fields in struct
ieee80211com and move them inside #ifndef IEEE80211_NO_HT without breaking
the build in rsu(4) for RAMDISK_CD.
Also declare 11n protection modes and MCS count.
ok deraadt mpi kettenis guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.65 2015/11/04 12:12:00 dlg Exp $	*/
d403 5
@


1.65
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.64 2015/09/27 16:51:31 stsp Exp $	*/
d75 2
a76 1
	IEEE80211_MODE_TURBO	= 4	/* 5GHz, OFDM, 2x clock */
d78 1
a78 1
#define	IEEE80211_MODE_MAX	(IEEE80211_MODE_TURBO+1)
d118 1
d148 2
d320 1
d323 3
a327 1
	u_int8_t		ic_sup_mcs[16];
d329 2
@


1.64
log
@Add ieee80211_channel_init(), factored out from ieee80211_ifattach().
Will be used by iwm(4) soon.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.63 2015/09/11 13:02:28 stsp Exp $	*/
d230 2
a231 2
	struct ifqueue		ic_mgtq;
	struct ifqueue		ic_pwrsaveq;
@


1.63
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.62 2012/01/21 19:42:16 stsp Exp $	*/
d383 1
@


1.62
log
@Implement missing bits of node inactivity accounting in hostap mode.
Small parts of code for this feature were already present but unused.

A node becomes inactive after not sending or receiving a frame within
5 minutes. Inactive cached nodes (not authenticated or associated) are
automatically cleared from the cache once every hour, making room for
new nodes. If the node cache is full and room must be made for a new node,
clean either a cached node (active or inactive), or an inactive
authenticated or associated node.

Also, do not send de-auth frames to nodes which never authenticated,
and only send a de-auth frame once for a given node.
This part was contributed by Steven Chamberlain, thanks!

Tested by myself, krw@@, edd@@, Steven Chamberlain, and Markus Schatzl.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.61 2010/07/19 18:53:52 damien Exp $	*/
d390 3
a392 3
int	ieee80211_rate2media(struct ieee80211com *, int,
		enum ieee80211_phymode);
int	ieee80211_media2rate(int);
@


1.61
log
@in hostap mode, notify drivers via a new callback when a STA leaves
the BSS. this is needed by drivers that need to maintain a hardware
table of associated STAs (like ral(4) RT2860).

idea from Nathanael Rensen
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.60 2009/05/19 16:09:02 damien Exp $	*/
d272 4
a275 1
	int			ic_inact_timer;	/* inactivity timer wait */
@


1.60
log
@prevent injection of raw 802.11 control frames through bpf on drivers
that do not explicitly state this capability (using flag IEEE80211_C_RAWCTL).
also, perform all the sanity checks on injected raw 802.11 frames earlier
(in ieee80211_output instead of ieee80211_encap).

prevent kernel panics with many drivers when running aircrack-ng.
when/if all drivers are capable, we can remove this C_RAWCTL flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.59 2009/03/26 20:38:29 damien Exp $	*/
d205 2
@


1.59
log
@move #define IEEE80211_NO_HT under #ifdef SMALL_KERNEL instead
of defining it unconditionnaly.
although the HT code is not ready yet, making it compile on
GENERIC kernels will help catch regressions/bugs if any.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.58 2009/02/08 15:34:39 damien Exp $	*/
d368 1
@


1.58
log
@initial 802.11 defragmentation bits.
the code will allow the concurrent reception of fragments of three
fragmented MSDUs or MMPDUs as required by the 802.11 standard.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.57 2009/01/28 18:55:18 damien Exp $	*/
d42 1
a43 1
#define IEEE80211_NO_HT		1	/* no HT yet */
@


1.57
log
@Block Ack agreements are unidirectional.
Maintain state for both originator and recipient roles separately.
Do not allocate receive reordering buffer in addba_request().
Test the "initiator" bit in incoming DELBA frames and set it appropriately
in outgoing DELBA frames.
Separate callbacks for Tx/Rx too.

no binary change since all this is #ifdef'ed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.56 2009/01/26 19:09:41 damien Exp $	*/
d171 11
d301 3
@


1.56
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.55 2008/11/13 13:42:35 djm Exp $	*/
d203 1
a203 1
	int			(*ic_htimmba_start)(struct ieee80211com *,
d205 5
a209 1
	void			(*ic_htimmba_stop)(struct ieee80211com *,
@


1.55
log
@use different TSCs when sending the two MIC failure report frames
to our AP as we enter TKIP countermeasures by caching the TSC of
the last frame to fail the MIC; prompted by and ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.54 2008/09/27 15:16:09 damien Exp $	*/
d41 1
a41 1
#define IEEE80211_STA_ONLY 1
d43 1
a174 7
struct ieee80211_rxinfo {
	u_int32_t		rxi_flags;
	u_int32_t		rxi_tstamp;
	int			rxi_rssi;
};
#define IEEE80211_RXI_HWDEC	0x00000001

d189 1
a189 1
				    struct ieee80211_node *, int, int);
d203 4
d292 9
d330 3
a332 1
#define IEEE80211_F_MFPR	0x01000000	/* CONF: MFP requested */
a349 1
#define	IEEE80211_C_HT		0x00004000	/* CAPABILITY: HT avail */
@


1.54
log
@Initial implementation of PMKSA caching and pre-authentication.
This will be required for future WPA-Enterprise support (802.1X).
Add ieee80211_needs_auth() function (not implemented yet) to
notify the userland 802.1X PACP machine when an 802.1X port
becomes enabled (that is after successfull 802.11 Open System
authentication).
Add SIOCS80211KEYRUN and SIOCS80211KEYAVAIL ioctls so that the
PACP state machine can kick the 802.11 key state machine and
install PMKs obtained from 802.1X (pre-)authentication.

Enable SHA-256 based AKMPs by default while I'm here (TGw).
This uses SHA-256 for key-derivation (instead of SHA1), AES-128-CMAC
for data integrity, and AES Key Wrap for data protection of EAPOL-Key
frames.  An OpenBSD AP will always advertise this capability and an
OpenBSD STA will always prefer SHA-256 based AKMPs over SHA1 based
ones if both are supported by an AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.53 2008/09/08 13:13:01 jsg Exp $	*/
d280 1
@


1.53
log
@define IEEE80211_STA_ONLY if SMALL_KERNEL is defined to shrink
the size of install media.

ok damien@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.52 2008/09/01 19:55:21 damien Exp $	*/
a173 10
struct ieee80211_rsnparams {
	u_int16_t		rsn_nakms;
	u_int32_t		rsn_akms;
	u_int16_t		rsn_nciphers;
	u_int32_t		rsn_ciphers;
	enum ieee80211_cipher	rsn_groupcipher;
	enum ieee80211_cipher	rsn_groupmgmtcipher;
	u_int16_t		rsn_caps;
};

d281 1
@


1.52
log
@add ic_tid_noack bitmap to indicate a per-TID ACK policy (1=no ack,
0=normal ack).  all bits are currently set to 0.
use this bitmap to set the ACK policy of the QoS control field of
outgoing QoS frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.51 2008/09/01 19:41:11 damien Exp $	*/
d39 4
@


1.51
log
@rework previously unused ieee80211_pwrsave() function, call it from
ieee80211_mgmt_output() and ieee80211_encap().
use new IEEE80211_C_APPMGT capability flag where appropriate.
rename ic_tim_mcast to ic_tim_mcast_pending.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.50 2008/08/29 12:14:53 damien Exp $	*/
d279 1
@


1.50
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.49 2008/08/29 08:40:53 damien Exp $	*/
d294 1
a294 1
	u_int			ic_tim_mcast;
@


1.49
log
@garbage collect unused capabilities and configurations flags.
add two capabilities flags: IEEE80211_C_HT for HT STAs (802.11n)
and IEEE80211_C_APPMGT which indicates the capability for an AP
to buffer unicast and multicast traffic for STAs in PS mode.
all drivers claiming HostAP support should support that but the
truth is that none of them do.
most of them are still at the 802.11b-only era and do not update
dynamic parts of beacons or process frames from ic_pwrsaveq.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.48 2008/08/27 10:58:01 damien Exp $	*/
a57 1
	IEEE80211_T_FH,			/* frequency hopping */
d70 1
a70 2
	IEEE80211_MODE_FH	= 4,	/* 2GHz, GFSK */
	IEEE80211_MODE_TURBO	= 5	/* 5GHz, OFDM, 2x clock */
a110 1
#define IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
a115 2
#define IEEE80211_CHAN_FHSS \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)
a128 2
#define	IEEE80211_IS_CHAN_FHSS(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_FHSS) == IEEE80211_CHAN_FHSS)
a149 2
#define	IEEE80211_IS_CHAN_GFSK(_c) \
	(((_c)->ic_flags & IEEE80211_CHAN_GFSK) != 0)
a151 6

/* ni_chan encoding for FH phy */
#define	IEEE80211_FH_CHANMOD	80
#define	IEEE80211_FH_CHAN(set,pat)	(((set)-1)*IEEE80211_FH_CHANMOD+(pat))
#define	IEEE80211_FH_CHANSET(chan)	((chan)/IEEE80211_FH_CHANMOD+1)
#define	IEEE80211_FH_CHANPAT(chan)	((chan)%IEEE80211_FH_CHANMOD)
@


1.48
log
@move definitions of channels attributes away from ieee80211.h such
that ieee80211.h contains only definitions that are part of the
802.11 standard and not constants used internally by net80211.
because channels attributes are exported to userland through the
radiotap BPF interface, add the definitions to ieee80211_radiotap.h
too (which must be kept in sync with what is used in net80211).
also, do not export combinations of channel attributes to userland
so that noone get stupid ideas.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.47 2008/08/27 09:05:04 damien Exp $	*/
a328 1
#define	IEEE80211_F_SCANAP	0x00001000	/* CONF: Scanning AP */
a329 1
#define	IEEE80211_F_SWRETRY	0x00004000	/* CONF: sw tx retry enabled */
d350 1
a350 1
#define	IEEE80211_C_SWRETRY	0x00000020	/* CAPABILITY: sw tx retry */
d359 1
@


1.47
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.46 2008/08/12 19:59:09 damien Exp $	*/
d102 31
@


1.46
log
@nuke unused fields.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.45 2008/08/12 18:30:56 damien Exp $	*/
d78 1
d82 1
@


1.45
log
@add IEEE80211_F_MFPR config flags (management frame protection required)
and IEEE80211_C_MFP capability bit (driver supports MFP).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.44 2008/08/12 18:01:41 damien Exp $	*/
a237 4
	u_int16_t		ic_holdover;	/* PM hold over duration */
	u_int16_t		ic_txmin;	/* min tx retry count */
	u_int16_t		ic_txmax;	/* max tx retry count */
	u_int16_t		ic_txlifetime;	/* tx lifetime */
@


1.44
log
@extend the ic_nw_keys[] array to 6 elements.
indices 0-3 will be used for group data keys while indices 4-5 will
be used for integrity group keys.
add a ic_rsngroupmgmtcipher field too.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.43 2008/08/12 17:53:13 damien Exp $	*/
d158 1
d314 1
d331 1
@


1.43
log
@Change the way we process EAPOL-Key frames.
Free the mbuf in the ieee80211_eapol_key_input() function.
Do not assume the frame is contiguous, call m_pullup2() if it is not.
We need the frame to be contiguous to process KDEs efficiently in
EAPOL-Key frames (just like we process IEs in management frames).
However, there are drivers like upgt(4) that use m_devget() in the
RX path.  m_devget() can return fragmented mbuf chains.
Notice that we should do the same m_pullup2() for management frames.
This will be done later.
Remove the ic_recv_eapol callback.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.42 2008/07/28 19:42:13 damien Exp $	*/
d173 2
d253 2
a254 2
	struct ieee80211_key	ic_nw_keys[IEEE80211_WEP_NKID];
	int			ic_def_txkey;	/* default tx key index */
d256 1
d275 1
@


1.42
log
@ignore PS mode changes and PS-Poll from non-associated STAs.
keep track of the number of associated STAs in PS mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.41 2008/07/27 18:24:01 damien Exp $	*/
a180 2
	void			(*ic_recv_eapol)(struct ieee80211com *,
				    struct mbuf *, struct ieee80211_node *);
@


1.41
log
@sanitize RX path a bit.
make sure drivers pass a contiguous header, check header length earlier.
fix checking of frames sequence number for frames containing an Address 4
field (required for future work).
fix processing of control frames (only pspoll for now).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.40 2008/07/21 19:27:26 damien Exp $	*/
d246 1
@


1.40
log
@add ieee80211_priv.h file: contains definitions private to net80211.
this must not be included by drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.39 2008/07/21 18:43:18 damien Exp $	*/
d136 1
a136 1
 * 802.11e EDCA AC parameters.
a166 4

#define	IEEE80211_PS_SLEEP	0x1	/* STA is in power saving mode */

#define	IEEE80211_PS_MAX_QUEUE	50	/* maximum saved packets */
@


1.39
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.38 2008/04/16 18:32:15 damien Exp $	*/
a358 9

#ifdef IEEE80211_DEBUG
extern	int ieee80211_debug;
#define	IEEE80211_DPRINTF(X)	do { if (ieee80211_debug) printf X; } while(0)
#define	IEEE80211_DPRINTF2(X)	do { if (ieee80211_debug>1) printf X; } while(0)
#else
#define	IEEE80211_DPRINTF(X)
#define	IEEE80211_DPRINTF2(X)
#endif
@


1.38
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.37 2007/11/17 14:05:01 damien Exp $	*/
d161 7
d182 1
a182 1
				    int, int, u_int32_t);
@


1.37
log
@make it clear in the code and in the man page that the rate2plcp and
plcp2rate functions use plcp codes in most-significant-bit-first format
(R4-R1).
some drivers like wpi(4) and iwn(4) want plcp codes in lsb-first format
so they can't use those functions.
also the IEEE standard uses R1-R4 notation so this can be a bit confusing
for those refering to it.

use u_int8_t for plcp code and rate instead of int.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.36 2007/11/14 11:16:27 mglocker Exp $	*/
d40 2
d148 13
d189 1
a189 1
				    const struct ieee80211_key *);
d191 2
a192 1
				    struct ieee80211_node *, int);
d242 1
d250 2
a251 2
	int			ic_wep_txkey;	/* default tx key index */
	void			*ic_wep_ctx;	/* wep crypt context */
d260 1
a260 1
	u_int64_t		ic_keyreplaycnt;
d262 8
d304 3
a306 2
#define	IEEE80211_F_RSN		0x00200000	/* CONF: RSN enabled */
#define	IEEE80211_F_WPA1	0x00400000	/* CONF: WPA1 enabled */
@


1.36
log
@Add ieee80211_rate2plcp() and ieee80211_plcp2rate() functions, which
convert the PLCP header signal field to a rate value and vice versa.

This implementation has been discussed with Damien and doesn't change
any existing net80211 structures.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.35 2007/11/03 14:59:55 mglocker Exp $	*/
d316 2
a317 2
int	ieee80211_rate2plcp(int, enum ieee80211_phymode);
int	ieee80211_plcp2rate(int, enum ieee80211_phymode);
@


1.35
log
@Revert last commit which added ieee80211_rate2plcp() and
ieee80211_plcp2rate() because I've got a late feedback from Damien that
he dislike the implementation method a lot.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.34 2007/11/01 22:34:19 mglocker Exp $	*/
d316 2
@


1.34
log
@Add ieee80211_rate2plcp() and ieee80211_plcp2rate() functions.

Help and OK reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.33 2007/08/22 20:40:34 damien Exp $	*/
a315 4
u_int8_t
	ieee80211_rate2plcp(struct ieee80211com *, int, enum ieee80211_phymode);
int	ieee80211_plcp2rate(struct ieee80211com *, u_int8_t,
		enum ieee80211_phymode mode);
@


1.33
log
@- add k_rxmic and k_txmic fields to struct ieee80211_key to store the
  Tx/Rx MIC for TKIP.
- add two functions to map a PTK and a GTK to an IEEE 802.11 key and
  use them in ieee80211_input.c instead of duplicating the same code.
  properly set Tx/Rx MIC in the IEEE 802.11 key in the case of TKIP.
- add ic_psk to struct ieee80211com to store the pre-shared key.
- fix setting of the SECURE bit in outgoing EAPOL-Key frames.
- when receiving msg 2 of the 4-way handshake, deauthenticate the
  station if the RSN IE does not match that of the (Re)Association
  request.
- before parsing an RSN or WPA IE, check that there's enough room for
  the version field (2 bytes) which is mandatory.
- various tweaks while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.32 2007/07/28 11:13:41 damien Exp $	*/
d316 4
@


1.32
log
@add callbacks that drivers must implement to install/reset keys.
add a 64-bit replay counter for sending EAPOL-Key request frames.
add a ic_recv_eapol callback to process EAPOL frames.
drivers can redefine this callback but net80211 will implement it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.31 2007/07/24 16:49:16 damien Exp $	*/
d244 1
@


1.31
log
@add ic_globalcnt to struct ieee80211com:
in an RSNA, each STA must maintain a 256-bit global key counter that
must be initialized to a random value (see 8.5.7).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.30 2007/07/18 18:10:31 damien Exp $	*/
d163 2
d172 5
d243 1
@


1.30
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.29 2007/07/05 20:19:21 damien Exp $	*/
d235 1
@


1.29
log
@split ieee80211_add_rsn() so that the code can be reused for
vendor-specific IE.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.28 2007/07/04 20:16:25 damien Exp $	*/
a91 21
 * 802.11i ciphers.
 */
enum ieee80211_cipher {
	IEEE80211_CIPHER_NONE     = 0x00000000,
	IEEE80211_CIPHER_USEGROUP = 0x00000001,
	IEEE80211_CIPHER_WEP40    = 0x00000002,
	IEEE80211_CIPHER_TKIP     = 0x00000004,
	IEEE80211_CIPHER_CCMP     = 0x00000008,
	IEEE80211_CIPHER_WEP104   = 0x00000010
};

/*
 * 802.11i Authentication and Key Management.
 */
enum ieee80211_akm {
	IEEE80211_AKM_NONE      = 0x00000000,
	IEEE80211_AKM_IEEE8021X = 0x00000001,
	IEEE80211_AKM_PSK       = 0x00000002
};

/*
d225 1
a225 1
	struct ieee80211_wepkey	ic_nw_keys[IEEE80211_WEP_NKID];
@


1.28
log
@add RSN flags for ic_caps and ic_flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.27 2007/07/03 20:25:33 damien Exp $	*/
d291 1
@


1.27
log
@maintain the traffic-indication (TIM) virtual bitmap by defining
a default ieee80211_set_tim() function that drivers can override
by setting ic_set_tim.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.26 2007/07/02 16:46:44 damien Exp $	*/
d290 1
d305 2
a306 1
#define IEEE80211_C_QOS		0x00000800	/* CAPABILITY: QoS */
@


1.26
log
@initial bits for proper TIM support.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.25 2007/06/21 20:11:16 damien Exp $	*/
d190 1
a190 1
	int			(*ic_set_tim)(struct ieee80211com *, int, int);
@


1.25
log
@add (currently unused) code to parse RSN IEs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.24 2007/06/21 18:21:01 damien Exp $	*/
d256 6
@


1.24
log
@add fields for EDCA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.23 2007/06/17 09:09:35 damien Exp $	*/
d89 21
@


1.23
log
@Add a new capability flag IEEE80211_C_QOS indicating that the driver
supports QoS.
Add a new flag IEEE80211_F_QOS indicating whether QoS is enabled or not.
Add a callback to notify drivers that AC parameters have changed in
the QBSS.  Drivers implementing QoS should define this callback and
update their EDCA settings accordingly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.22 2007/06/16 13:17:05 damien Exp $	*/
d137 4
a140 4
	u_int8_t	ecwmin;		/* CWmin = 2^ECWmin - 1 */
	u_int8_t	ecwmax;		/* CWmax = 2^ECWmax - 1 */
	u_int8_t	aifsn;
	u_int16_t	txoplimit;	/* 32TU */
d142 2
d233 2
@


1.22
log
@constify
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.21 2007/06/11 19:35:24 damien Exp $	*/
d166 1
d257 1
d273 1
@


1.21
log
@adds 802.11e EDCA tables for QAPs and non-AP QSTAs.
not used yet.

ok jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.20 2007/06/07 20:24:42 damien Exp $	*/
d202 1
a202 1
					struct ieee80211_node *);
d291 2
a292 1
u_int	ieee80211_chan2ieee(struct ieee80211com *, struct ieee80211_channel *);
d297 1
a297 1
		struct ieee80211_channel *);
@


1.20
log
@expand the IEEE80211_NODE_{LOCK,UNLOCK}* macros into their respective
definitions.
remove comments about "lock order reversals" that are specific to freebsd.

ok reyk@@ jsg@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.19 2007/06/06 19:31:07 damien Exp $	*/
d132 11
@


1.19
log
@The license permits us to redistribute this code under the BSD or the GPLv2.
Choose the BSD license so that future enhancements will be BSD-only.

ok jsg@@ reyk@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.18 2006/11/15 18:59:37 damien Exp $	*/
a182 1
	ieee80211_node_lock_t	ic_nodelock;	/* on node table */
@


1.18
log
@s/roundup/howmany/ where it makes sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.17 2006/10/19 10:55:56 tom Exp $	*/
a18 4
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU General Public License ("GPL") version 2 as published by the Free
 * Software Foundation.
@


1.17
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.16 2006/06/27 20:55:51 reyk Exp $	*/
d163 3
a165 3
	u_char			ic_chan_avail[roundup(IEEE80211_CHAN_MAX,NBBY)];
	u_char			ic_chan_active[roundup(IEEE80211_CHAN_MAX, NBBY)];
	u_char			ic_chan_scan[roundup(IEEE80211_CHAN_MAX,NBBY)];
@


1.16
log
@add the net80211 hostap options "nwflag hidenwid" for hidden SSID mode
and "nwflag nobridge" to prevent inter-station communications.
"hidenwid" will also work with wi(4) to replace the old -E 3 option of
wicontrol.

ok damien@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.15 2006/06/24 14:14:18 deraadt Exp $	*/
d99 1
a99 1
	u_int16_t	ic_freq;	/* setting in Mhz */
@


1.15
log
@ieee80211_cfgget() and ieee80211_cfgset() are dead; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.14 2006/06/23 21:34:15 reyk Exp $	*/
d251 1
@


1.14
log
@add an optional max_rssi attribute to the ieee80211com structure and
allow to export the RSSI Max value with ioctls and by radiotap
headers.

ok damien@@ jsg@@

description:

we currently use "dB" as an indication for the signal strength in
ifconfig and in the radiotap headers. it means "decibel difference
from an arbitrary, fixed reference". this is quite confusing, because
different chipsets have different references for the dB/rssi values.

we can use the plain RSSI which is described in IEEE 802.11: "The
receive signal strength indicator (RSSI) is an optional parameter that
has a value of 0 through RSSI Max.". all wireless chipsets have
something like a RSSI (normally as a Rx descriptor field), but the
value for RSSI Max is chipset-specific.

if we know the RSSI Max, we can calculate a percentage which is much
easier to understand for the user. we even don't have to use the
absolute RSSI Max, we can use an average RSSI Max, figured out by
monitoring and tuning the RSSI Max of the drivers. if the user gets a
signal of 110%, it would mean "better than the average Max signal".

there's no need to do any RSSI calculations in the kernel, it just
passes the the relative rssi and max_rssi values to userspace. this is
done in the ieee80211_nodereq ioctl structure and possible with a new
radiotap header. the radiotap RSSI header allows to get a flexible but
common signal indicator instead of the complex and unrelated dB/dBm
signal fields. it must include two 8bit values current rssi and RSSI
max.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.13 2006/06/18 18:39:41 damien Exp $	*/
a277 2
int	ieee80211_cfgget(struct ifnet *, u_long, caddr_t);
int	ieee80211_cfgset(struct ifnet *, u_long, caddr_t);
@


1.13
log
@Improve 802.11b/g interoperability and move toward better compliance
with IEEE Std 802.11g-2003 standard:

- add ERP Information Element in probe responses and beacons
- keep track of the number of associated non-ERP STAs and non-short slot
  time capable STAs in the BSS
- enable use of RTS/CTS or CTS-to-self protection when required by the BSS
- add a ic_updateslot() callback to notify drivers of slot time changes
- cleanup computation of mgmt frames sizes in ieee80211_output.c
- nuke unnecessary <sys/cdefs.h> includes
- remove an unused macro (LOGICALLY_EQUAL) while i'm here

From {free,net}bsd, with additional fixes.

ok brad@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.12 2005/09/13 12:11:03 reyk Exp $	*/
d197 1
@


1.12
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.11 2005/09/08 13:24:53 reyk Exp $	*/
d158 1
d207 2
d247 2
a248 2
#define	IEEE80211_F_SHSLOT	0x00020000	/* CONF: short slot time */
#define	IEEE80211_F_SHPREAMBLE	0x00040000	/* CONF: short preamble */
a249 1
#define	IEEE80211_F_USEBARKER	0x00200000	/* STATUS: use barker preamble*/
@


1.11
log
@mostly knf

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.10 2005/09/07 05:40:11 jsg Exp $	*/
d196 1
a196 3
	TAILQ_HEAD(, ieee80211_node) ic_node;	/* information of all nodes
						 * LRU at tail
						 */
a198 1
	LIST_HEAD(, ieee80211_node) ic_hash[IEEE80211_NODE_HASHSIZE];
@


1.10
log
@Remove FreeBSD/NetBSD ifdef mess.  We are not likely to be
doing a wholesale merge with them in future.
very enthusiastic ok from reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.9 2005/05/25 07:40:49 reyk Exp $	*/
d80 1
a80 1
	IEEE80211_M_IBSS 	= 0,	/* IBSS (adhoc) station */
@


1.9
log
@add ifconfig -M option to replace wicontrol -L and -l for ap scanning
and node listing. wicontrol is not supported by net80211 drivers
anymore. further improvements will be done.

ok dlg@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.8 2005/05/13 01:06:41 jsg Exp $	*/
a146 3
#ifdef __NetBSD__
	struct ethercom		ic_ec;
#else
a147 1
#endif
a179 3
#ifdef __FreeBSD__
	struct bpf_if		*ic_rawbpf;	/* packet filter structure */
#else
a180 1
#endif
a223 3
#ifdef __NetBSD__
#define	ic_if		ic_ec.ec_if
#else
a224 1
#endif
@


1.8
log
@do { } while (0) wrappers on debug printf macros. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.7 2005/04/21 22:47:15 reyk Exp $	*/
a102 30
/* bits 0-3 are for private use by drivers */
/* channel attributes */
#define	IEEE80211_CHAN_TURBO	0x0010	/* Turbo channel */
#define	IEEE80211_CHAN_CCK	0x0020	/* CCK channel */
#define	IEEE80211_CHAN_OFDM	0x0040	/* OFDM channel */
#define	IEEE80211_CHAN_2GHZ	0x0080	/* 2 GHz spectrum channel. */
#define	IEEE80211_CHAN_5GHZ	0x0100	/* 5 GHz spectrum channel */
#define	IEEE80211_CHAN_PASSIVE	0x0200	/* Only passive scan allowed */
#define	IEEE80211_CHAN_DYN	0x0400	/* Dynamic CCK-OFDM channel */
#define	IEEE80211_CHAN_GFSK	0x0800	/* GFSK channel (FHSS PHY) */
#define	IEEE80211_CHAN_XR	0x1000	/* Extended range OFDM channel */

/*
 * Useful combinations of channel characteristics.
 */
#define	IEEE80211_CHAN_FHSS \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_GFSK)
#define	IEEE80211_CHAN_A \
	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM)
#define	IEEE80211_CHAN_B \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_CCK)
#define	IEEE80211_CHAN_PUREG \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM)
#define	IEEE80211_CHAN_G \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_DYN)
#define	IEEE80211_CHAN_T \
	(IEEE80211_CHAN_5GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)
#define	IEEE80211_CHAN_TG \
	(IEEE80211_CHAN_2GHZ | IEEE80211_CHAN_OFDM | IEEE80211_CHAN_TURBO)

d141 5
d171 2
d301 1
a301 1
void	ieee80211_next_mode(struct ifnet *);
@


1.7
log
@scan the next mode if nothing has been found. this is necessary if the
device supports different incompatible modes in the same channel
range, like like 11b and "pure" 11G mode.

ok dlg@@ pvalchev@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.6 2005/02/17 18:28:05 reyk Exp $	*/
d330 2
a331 2
#define	IEEE80211_DPRINTF(X)	if (ieee80211_debug) printf X
#define	IEEE80211_DPRINTF2(X)	if (ieee80211_debug>1) printf X
@


1.6
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.5 2005/02/15 19:44:15 reyk Exp $	*/
d324 1
@


1.5
log
@add the manual tx power option. this is supported by some prism2/2.5/3
cards in hostap mode but it depends on the firmware version. support
for other wireless chipsets will be added in the future using the
net80211-framework.

ok robert@@ bob@@ danh@@, tested by some others
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.4 2004/12/25 20:40:19 deraadt Exp $	*/
d113 1
d130 2
d145 2
d158 2
d177 1
d203 1
a203 1
	u_int32_t		ic_aid_bitmap[IEEE80211_MAX_AID / 32 + 1];
d217 1
a217 3
#ifdef __FreeBSD__
	struct mtx		ic_nodelock;	/* on node table */
#endif
d227 5
a231 1
	TAILQ_HEAD(, ieee80211_node) ic_node;	/* information of all nodes */
d262 3
d336 1
a336 1
extern	int ieee80211_inact_max;
@


1.4
log
@in real C, there is not , after the last enum entry; ok reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.3 2004/12/06 11:15:14 dlg Exp $	*/
d56 1
a56 1
#define	IEEE80211_TXPOWER_MIN	0	/* kill radio (if possible) */
d228 1
a228 1
	u_int16_t		ic_txpower;	/* tx power setting (dbM) */
@


1.3
log
@add a flag that lets a wireless card indicate it can receive probe responses
or beacons on any channel during a scan.

ok damien@@ "come on" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.2 2004/11/02 02:15:49 reyk Exp $	*/
d63 1
a63 1
	IEEE80211_T_XR,		        /* extended range mode */
d74 1
a74 1
	IEEE80211_MODE_TURBO	= 5,	/* 5GHz, OFDM, 2x clock */
d92 1
a92 1
	IEEE80211_PROT_RTSCTS	= 2,	/* RTS-CTS */
@


1.2
log
@some changes merged in from netbsd. ieee80211_regdomain.# will be used
by sdr (software defined radios).

ok deraadt@@ millert@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_var.h,v 1.1 2004/06/22 22:53:52 millert Exp $	*/
d285 1
@


1.1
log
@Import current NetBSD/FreeBSD 802.11 framework.
Based in part on a diff from Matthew Gream.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 1
d241 3
@

