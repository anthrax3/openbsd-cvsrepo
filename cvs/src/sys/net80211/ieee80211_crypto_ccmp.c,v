head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.2
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.4
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.12.0.10
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.2.0.2
	OPENBSD_4_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2017.05.02.17.07.06;	author mikeb;	state Exp;
branches;
next	1.19;
commitid	8itHxD4pqII16hPy;

1.19
date	2017.03.23.04.10.10;	author tb;	state Exp;
branches;
next	1.18;
commitid	EiuhETcE9N1Gqn0A;

1.18
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.17;
commitid	FuSD2mFDJWATHIDx;

1.17
date	2015.11.15.01.43.21;	author stsp;	state Exp;
branches;
next	1.16;
commitid	fszzG2ugiSa7pXZZ;

1.16
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	ncpqEGjDtSFuLAgn;

1.15
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.14;
commitid	PYnSnAqgemmk34E3;

1.14
date	2014.07.12.18.44.22;	author tedu;	state Exp;
branches;
next	1.13;
commitid	B4dZSbxas1X1IpXI;

1.13
date	2013.11.21.16.16.08;	author mpi;	state Exp;
branches;
next	1.12;

1.12
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2010.07.20.15.36.03;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.24.16.03.10;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.03.17.25.41;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.27.15.00.08;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2008.08.12.17.54.57;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2008.08.12.16.45.44;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2008.08.12.16.21.46;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2008.08.12.16.14.45;	author henning;	state Exp;
branches;
next	1.2;

1.2
date	2008.07.26.12.41.34;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Switch 802.11 crypto over to the new AES

OK stsp@@
@
text
@/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.19 2017/03/23 04:10:10 tb Exp $	*/

/*-
 * Copyright (c) 2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This code implements the CTR with CBC-MAC protocol (CCMP) defined in
 * IEEE Std 802.11-2007 section 8.3.3.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_crypto.h>

#include <crypto/aes.h>

/* CCMP software crypto context */
struct ieee80211_ccmp_ctx {
	AES_CTX		aesctx;
};

/*
 * Initialize software crypto context.  This function can be overridden
 * by drivers doing hardware crypto.
 */
int
ieee80211_ccmp_set_key(struct ieee80211com *ic, struct ieee80211_key *k)
{
	struct ieee80211_ccmp_ctx *ctx;

	ctx = malloc(sizeof(*ctx), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ctx == NULL)
		return ENOMEM;
	AES_Setkey(&ctx->aesctx, k->k_key, 16);
	k->k_priv = ctx;
	return 0;
}

void
ieee80211_ccmp_delete_key(struct ieee80211com *ic, struct ieee80211_key *k)
{
	if (k->k_priv != NULL) {
		explicit_bzero(k->k_priv, sizeof(struct ieee80211_ccmp_ctx));
		free(k->k_priv, M_DEVBUF, sizeof(struct ieee80211_ccmp_ctx));
	}
	k->k_priv = NULL;
}

/*-
 * Counter with CBC-MAC (CCM) - see RFC3610.
 * CCMP uses the following CCM parameters: M = 8, L = 2
 */
static void
ieee80211_ccmp_phase1(AES_CTX *ctx, const struct ieee80211_frame *wh,
    u_int64_t pn, int lm, u_int8_t b[16], u_int8_t a[16], u_int8_t s0[16])
{
	u_int8_t auth[32], nonce[13];
	u_int8_t *aad;
	u_int8_t tid = 0;
	int la, i;

	/* construct AAD (additional authenticated data) */
	aad = &auth[2];	/* skip l(a), will be filled later */
	*aad = wh->i_fc[0];
	/* 11w: conditionally mask subtype field */
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_DATA)
		*aad &= ~IEEE80211_FC0_SUBTYPE_MASK |
		   IEEE80211_FC0_SUBTYPE_QOS;
	aad++;
	/* protected bit is already set in wh */
	*aad = wh->i_fc[1];
	*aad &= ~(IEEE80211_FC1_RETRY | IEEE80211_FC1_PWR_MGT |
	    IEEE80211_FC1_MORE_DATA);
	/* 11n: conditionally mask order bit */
	if (ieee80211_has_qos(wh))
		*aad &= ~IEEE80211_FC1_ORDER;
	aad++;
	IEEE80211_ADDR_COPY(aad, wh->i_addr1); aad += IEEE80211_ADDR_LEN;
	IEEE80211_ADDR_COPY(aad, wh->i_addr2); aad += IEEE80211_ADDR_LEN;
	IEEE80211_ADDR_COPY(aad, wh->i_addr3); aad += IEEE80211_ADDR_LEN;
	*aad++ = wh->i_seq[0] & ~0xf0;
	*aad++ = 0;
	if (ieee80211_has_addr4(wh)) {
		IEEE80211_ADDR_COPY(aad,
		    ((const struct ieee80211_frame_addr4 *)wh)->i_addr4);
		aad += IEEE80211_ADDR_LEN;
	}
	if (ieee80211_has_qos(wh)) {
		/* 
		 * XXX 802.11-2012 11.4.3.3.3 g says the A-MSDU present bit
		 * must be set here if both STAs are SPP A-MSDU capable.
		 */
		*aad++ = tid = ieee80211_get_qos(wh) & IEEE80211_QOS_TID;
		*aad++ = 0;
	}

	/* construct CCM nonce */
	nonce[ 0] = tid;
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT)
		nonce[0] |= 1 << 4;	/* 11w: set management bit */
	IEEE80211_ADDR_COPY(&nonce[1], wh->i_addr2);
	nonce[ 7] = pn >> 40;	/* PN5 */
	nonce[ 8] = pn >> 32;	/* PN4 */
	nonce[ 9] = pn >> 24;	/* PN3 */
	nonce[10] = pn >> 16;	/* PN2 */
	nonce[11] = pn >> 8;	/* PN1 */
	nonce[12] = pn;		/* PN0 */

	/* add 2 authentication blocks (including l(a) and padded AAD) */
	la = aad - &auth[2];		/* fill l(a) */
	auth[0] = la >> 8;
	auth[1] = la & 0xff;
	memset(aad, 0, 30 - la);	/* pad AAD with zeros */

	/* construct first block B_0 */
	b[ 0] = 89;	/* Flags = 64*Adata + 8*((M-2)/2) + (L-1) */
	memcpy(&b[1], nonce, 13);
	b[14] = lm >> 8;
	b[15] = lm & 0xff;
	AES_Encrypt(ctx, b, b);

	for (i = 0; i < 16; i++)
		b[i] ^= auth[i];
	AES_Encrypt(ctx, b, b);
	for (i = 0; i < 16; i++)
		b[i] ^= auth[16 + i];
	AES_Encrypt(ctx, b, b);

	/* construct S_0 */
	a[ 0] = 1;	/* Flags = L' = (L-1) */
	memcpy(&a[1], nonce, 13);
	a[14] = a[15] = 0;
	AES_Encrypt(ctx, a, s0);
}

struct mbuf *
ieee80211_ccmp_encrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_ccmp_ctx *ctx = k->k_priv;
	const struct ieee80211_frame *wh;
	const u_int8_t *src;
	u_int8_t *ivp, *mic, *dst;
	u_int8_t a[16], b[16], s0[16], s[16];
	struct mbuf *n0, *m, *n;
	int hdrlen, left, moff, noff, len;
	u_int16_t ctr;
	int i, j;

	MGET(n0, M_DONTWAIT, m0->m_type);
	if (n0 == NULL)
		goto nospace;
	if (m_dup_pkthdr(n0, m0, M_DONTWAIT))
		goto nospace;
	n0->m_pkthdr.len += IEEE80211_CCMP_HDRLEN;
	n0->m_len = MHLEN;
	if (n0->m_pkthdr.len >= MINCLSIZE - IEEE80211_CCMP_MICLEN) {
		MCLGET(n0, M_DONTWAIT);
		if (n0->m_flags & M_EXT)
			n0->m_len = n0->m_ext.ext_size;
	}
	if (n0->m_len > n0->m_pkthdr.len)
		n0->m_len = n0->m_pkthdr.len;

	/* copy 802.11 header */
	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	memcpy(mtod(n0, caddr_t), wh, hdrlen);

	k->k_tsc++;	/* increment the 48-bit PN */

	/* construct CCMP header */
	ivp = mtod(n0, u_int8_t *) + hdrlen;
	ivp[0] = k->k_tsc;		/* PN0 */
	ivp[1] = k->k_tsc >> 8;		/* PN1 */
	ivp[2] = 0;			/* Rsvd */
	ivp[3] = k->k_id << 6 | IEEE80211_WEP_EXTIV;	/* KeyID | ExtIV */
	ivp[4] = k->k_tsc >> 16;	/* PN2 */
	ivp[5] = k->k_tsc >> 24;	/* PN3 */
	ivp[6] = k->k_tsc >> 32;	/* PN4 */
	ivp[7] = k->k_tsc >> 40;	/* PN5 */

	/* construct initial B, A and S_0 blocks */
	ieee80211_ccmp_phase1(&ctx->aesctx, wh, k->k_tsc,
	    m0->m_pkthdr.len - hdrlen, b, a, s0);

	/* construct S_1 */
	ctr = 1;
	a[14] = ctr >> 8;
	a[15] = ctr & 0xff;
	AES_Encrypt(&ctx->aesctx, a, s);

	/* encrypt frame body and compute MIC */
	j = 0;
	m = m0;
	n = n0;
	moff = hdrlen;
	noff = hdrlen + IEEE80211_CCMP_HDRLEN;
	left = m0->m_pkthdr.len - moff;
	while (left > 0) {
		if (moff == m->m_len) {
			/* nothing left to copy from m */
			m = m->m_next;
			moff = 0;
		}
		if (noff == n->m_len) {
			/* n is full and there's more data to copy */
			MGET(n->m_next, M_DONTWAIT, n->m_type);
			if (n->m_next == NULL)
				goto nospace;
			n = n->m_next;
			n->m_len = MLEN;
			if (left >= MINCLSIZE - IEEE80211_CCMP_MICLEN) {
				MCLGET(n, M_DONTWAIT);
				if (n->m_flags & M_EXT)
					n->m_len = n->m_ext.ext_size;
			}
			if (n->m_len > left)
				n->m_len = left;
			noff = 0;
		}
		len = min(m->m_len - moff, n->m_len - noff);

		src = mtod(m, u_int8_t *) + moff;
		dst = mtod(n, u_int8_t *) + noff;
		for (i = 0; i < len; i++) {
			/* update MIC with clear text */
			b[j] ^= src[i];
			/* encrypt message */
			dst[i] = src[i] ^ s[j];
			if (++j < 16)
				continue;
			/* we have a full block, encrypt MIC */
			AES_Encrypt(&ctx->aesctx, b, b);
			/* construct a new S_ctr block */
			ctr++;
			a[14] = ctr >> 8;
			a[15] = ctr & 0xff;
			AES_Encrypt(&ctx->aesctx, a, s);
			j = 0;
		}

		moff += len;
		noff += len;
		left -= len;
	}
	if (j != 0)	/* partial block, encrypt MIC */
		AES_Encrypt(&ctx->aesctx, b, b);

	/* reserve trailing space for MIC */
	if (M_TRAILINGSPACE(n) < IEEE80211_CCMP_MICLEN) {
		MGET(n->m_next, M_DONTWAIT, n->m_type);
		if (n->m_next == NULL)
			goto nospace;
		n = n->m_next;
		n->m_len = 0;
	}
	/* finalize MIC, U := T XOR first-M-bytes( S_0 ) */
	mic = mtod(n, u_int8_t *) + n->m_len;
	for (i = 0; i < IEEE80211_CCMP_MICLEN; i++)
		mic[i] = b[i] ^ s0[i];
	n->m_len += IEEE80211_CCMP_MICLEN;
	n0->m_pkthdr.len += IEEE80211_CCMP_MICLEN;

	m_freem(m0);
	return n0;
 nospace:
	ic->ic_stats.is_tx_nombuf++;
	m_freem(m0);
	m_freem(n0);
	return NULL;
}

struct mbuf *
ieee80211_ccmp_decrypt(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_key *k)
{
	struct ieee80211_ccmp_ctx *ctx = k->k_priv;
	struct ieee80211_frame *wh;
	u_int64_t pn, *prsc;
	const u_int8_t *ivp, *src;
	u_int8_t *dst;
	u_int8_t mic0[IEEE80211_CCMP_MICLEN];
	u_int8_t a[16], b[16], s0[16], s[16];
	struct mbuf *n0, *m, *n;
	int hdrlen, left, moff, noff, len;
	u_int16_t ctr;
	int i, j;

	wh = mtod(m0, struct ieee80211_frame *);
	hdrlen = ieee80211_get_hdrlen(wh);
	ivp = (u_int8_t *)wh + hdrlen;

	if (m0->m_pkthdr.len < hdrlen + IEEE80211_CCMP_HDRLEN +
	    IEEE80211_CCMP_MICLEN) {
		m_freem(m0);
		return NULL;
	}
	/* check that ExtIV bit is set */
	if (!(ivp[3] & IEEE80211_WEP_EXTIV)) {
		m_freem(m0);
		return NULL;
	}

	/* retrieve last seen packet number for this frame type/priority */
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_DATA) {
		u_int8_t tid = ieee80211_has_qos(wh) ?
		    ieee80211_get_qos(wh) & IEEE80211_QOS_TID : 0;
		prsc = &k->k_rsc[tid];
	} else	/* 11w: management frames have their own counters */
		prsc = &k->k_mgmt_rsc;

	/* extract the 48-bit PN from the CCMP header */
	pn = (u_int64_t)ivp[0]       |
	     (u_int64_t)ivp[1] <<  8 |
	     (u_int64_t)ivp[4] << 16 |
	     (u_int64_t)ivp[5] << 24 |
	     (u_int64_t)ivp[6] << 32 |
	     (u_int64_t)ivp[7] << 40;
	if (pn <= *prsc) {
		/* replayed frame, discard */
		ic->ic_stats.is_ccmp_replays++;
		m_freem(m0);
		return NULL;
	}

	MGET(n0, M_DONTWAIT, m0->m_type);
	if (n0 == NULL)
		goto nospace;
	if (m_dup_pkthdr(n0, m0, M_DONTWAIT))
		goto nospace;
	n0->m_pkthdr.len -= IEEE80211_CCMP_HDRLEN + IEEE80211_CCMP_MICLEN;
	n0->m_len = MHLEN;
	if (n0->m_pkthdr.len >= MINCLSIZE) {
		MCLGET(n0, M_DONTWAIT);
		if (n0->m_flags & M_EXT)
			n0->m_len = n0->m_ext.ext_size;
	}
	if (n0->m_len > n0->m_pkthdr.len)
		n0->m_len = n0->m_pkthdr.len;

	/* construct initial B, A and S_0 blocks */
	ieee80211_ccmp_phase1(&ctx->aesctx, wh, pn,
	    n0->m_pkthdr.len - hdrlen, b, a, s0);

	/* copy 802.11 header and clear protected bit */
	memcpy(mtod(n0, caddr_t), wh, hdrlen);
	wh = mtod(n0, struct ieee80211_frame *);
	wh->i_fc[1] &= ~IEEE80211_FC1_PROTECTED;

	/* construct S_1 */
	ctr = 1;
	a[14] = ctr >> 8;
	a[15] = ctr & 0xff;
	AES_Encrypt(&ctx->aesctx, a, s);

	/* decrypt frame body and compute MIC */
	j = 0;
	m = m0;
	n = n0;
	moff = hdrlen + IEEE80211_CCMP_HDRLEN;
	noff = hdrlen;
	left = n0->m_pkthdr.len - noff;
	while (left > 0) {
		if (moff == m->m_len) {
			/* nothing left to copy from m */
			m = m->m_next;
			moff = 0;
		}
		if (noff == n->m_len) {
			/* n is full and there's more data to copy */
			MGET(n->m_next, M_DONTWAIT, n->m_type);
			if (n->m_next == NULL)
				goto nospace;
			n = n->m_next;
			n->m_len = MLEN;
			if (left >= MINCLSIZE) {
				MCLGET(n, M_DONTWAIT);
				if (n->m_flags & M_EXT)
					n->m_len = n->m_ext.ext_size;
			}
			if (n->m_len > left)
				n->m_len = left;
			noff = 0;
		}
		len = min(m->m_len - moff, n->m_len - noff);

		src = mtod(m, u_int8_t *) + moff;
		dst = mtod(n, u_int8_t *) + noff;
		for (i = 0; i < len; i++) {
			/* decrypt message */
			dst[i] = src[i] ^ s[j];
			/* update MIC with clear text */
			b[j] ^= dst[i];
			if (++j < 16)
				continue;
			/* we have a full block, encrypt MIC */
			AES_Encrypt(&ctx->aesctx, b, b);
			/* construct a new S_ctr block */
			ctr++;
			a[14] = ctr >> 8;
			a[15] = ctr & 0xff;
			AES_Encrypt(&ctx->aesctx, a, s);
			j = 0;
		}

		moff += len;
		noff += len;
		left -= len;
	}
	if (j != 0)	/* partial block, encrypt MIC */
		AES_Encrypt(&ctx->aesctx, b, b);

	/* finalize MIC, U := T XOR first-M-bytes( S_0 ) */
	for (i = 0; i < IEEE80211_CCMP_MICLEN; i++)
		b[i] ^= s0[i];

	/* check that it matches the MIC in received frame */
	m_copydata(m, moff, IEEE80211_CCMP_MICLEN, mic0);
	if (timingsafe_bcmp(mic0, b, IEEE80211_CCMP_MICLEN) != 0) {
		ic->ic_stats.is_ccmp_dec_errs++;
		m_freem(m0);
		m_freem(n0);
		return NULL;
	}

	/* update last seen packet number (MIC is validated) */
	*prsc = pn;

	m_freem(m0);
	return n0;
 nospace:
	ic->ic_stats.is_rx_nombuf++;
	m_freem(m0);
	m_freem(n0);
	return NULL;
}
@


1.19
log
@Use explicit_bzero() to wipe out key material and add some sizes to free().

ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.18 2015/11/24 13:45:06 mpi Exp $	*/
d42 1
a42 1
#include <crypto/rijndael.h>
d46 1
a46 1
	rijndael_ctx	rijndael;
d61 1
a61 1
	rijndael_set_key_enc_only(&ctx->rijndael, k->k_key, 128);
d81 1
a81 1
ieee80211_ccmp_phase1(rijndael_ctx *ctx, const struct ieee80211_frame *wh,
d149 1
a149 1
	rijndael_encrypt(ctx, b, b);
d153 1
a153 1
	rijndael_encrypt(ctx, b, b);
d156 1
a156 1
	rijndael_encrypt(ctx, b, b);
d162 1
a162 1
	rijndael_encrypt(ctx, a, s0);
d213 1
a213 1
	ieee80211_ccmp_phase1(&ctx->rijndael, wh, k->k_tsc,
d220 1
a220 1
	rijndael_encrypt(&ctx->rijndael, a, s);
d263 1
a263 1
			rijndael_encrypt(&ctx->rijndael, b, b);
d268 1
a268 1
			rijndael_encrypt(&ctx->rijndael, a, s);
d277 1
a277 1
		rijndael_encrypt(&ctx->rijndael, b, b);
d373 1
a373 1
	ieee80211_ccmp_phase1(&ctx->rijndael, wh, pn,
d385 1
a385 1
	rijndael_encrypt(&ctx->rijndael, a, s);
d428 1
a428 1
			rijndael_encrypt(&ctx->rijndael, b, b);
d433 1
a433 1
			rijndael_encrypt(&ctx->rijndael, a, s);
d442 1
a442 1
		rijndael_encrypt(&ctx->rijndael, b, b);
@


1.18
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.17 2015/11/15 01:43:21 stsp Exp $	*/
d69 4
a72 2
	if (k->k_priv != NULL)
		free(k->k_priv, M_DEVBUF, 0);
@


1.17
log
@Fix CCMP (WPA2) in preparation for 11n. This code didn't handle QoS
frames correctly but QoS frames are required for 11n A-MPDU aggregation
and 11n STAs are required to use CCMP instead of WEP or TKIP ciphers.

The QoS bit in FC0 is part of AAD (additional authentication data) but
was being masked unconditionally.
The FC1 order bit is masked to 0 in AAD if a data frame contains a QoS
control field but this code was looking for HT control fields instead.

Add an XXX comment about another bit which must be set if SPP (signaling
and payload protected) A-MSDUs are supported. Neither Linux nor FreeBSD
seem to set this bit, and we don't support SPP A-MSDUs yet so a comment
seems good enough for now.

ok deraadt mpi kettenis guenther
helpful hints from mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.16 2015/07/15 22:16:42 deraadt Exp $	*/
a34 1
#include <net/if_arp.h>
@


1.16
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.15 2014/12/23 03:24:08 tedu Exp $	*/
d91 1
a91 1
	/* 11w: conditionnally mask subtype field */
d94 2
a95 1
		*aad &= ~IEEE80211_FC0_SUBTYPE_MASK;
d101 2
a102 2
	/* 11n: conditionnally mask order bit */
	if (ieee80211_has_htc(wh))
d116 4
@


1.15
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.14 2014/07/12 18:44:22 tedu Exp $	*/
d293 1
a293 2
	if (n0 != NULL)
		m_freem(n0);
d459 1
a459 2
	if (n0 != NULL)
		m_freem(n0);
@


1.14
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.13 2013/11/21 16:16:08 mpi Exp $	*/
a36 1
#ifdef INET
a38 1
#endif
@


1.13
log
@Remove unneeded include.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.12 2011/04/05 11:48:28 blambert Exp $	*/
d73 1
a73 1
		free(k->k_priv, M_DEVBUF);
@


1.12
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.11 2010/07/20 15:36:03 matthew Exp $	*/
a35 1
#include <net/if_llc.h>
@


1.11
log
@Switch some obvious network stack MAC comparisons from bcmp() to
timingsafe_bcmp().

ok deraadt@@; committed over WPA.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.10 2009/09/24 16:03:10 damien Exp $	*/
d179 1
a179 1
	if (m_dup_pkthdr(n0, m0))
d358 1
a358 1
	if (m_dup_pkthdr(n0, m0))
@


1.10
log
@do not call m_free(n0) followed by m_freem(n0) when m_dup_pkthdr()
call fails.  this double-free was introduced with the M_DUP_PKTHRD
to m_dup_pkthdr change that got committed before I had a chance to
review it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.9 2009/09/13 14:42:52 krw Exp $	*/
d448 1
a448 1
	if (memcmp(mic0, b, IEEE80211_CCMP_MICLEN) != 0) {
@


1.9
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.8 2008/12/03 17:25:41 damien Exp $	*/
d179 1
a179 2
	if (m_dup_pkthdr(n0, m0)) {
		m_free(n0);
a180 1
	}
d358 1
a358 2
	if (m_dup_pkthdr(n0, m0)) {
		m_free(n0);
a359 1
	}
@


1.8
log
@typos in comments - no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.7 2008/09/27 15:00:08 damien Exp $	*/
d179 4
a182 1
	M_DUP_PKTHDR(n0, m0);
d360 4
a363 1
	M_DUP_PKTHDR(n0, m0);
@


1.7
log
@Add some inline functions to test the presence of optional 802.11
header fields (Sequence Control, Address 4, QoS Control, +HTC) and
use them where appropriate.

Add ieee80211_get_qos() inline function to extract the QoS control
field of an 802.11 header instead of duplicating the same scary
code everywhere (the location of this field depends on the presence
of an Address 4 field).

Export ieee80211_up_to_ac() so that drivers can select the access
category to use based on the TID subfield of the QoS Control field.

Define more QoS-related bits for the RSN Capabilities field of RSN IE
(will be used later).
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.6 2008/08/12 17:54:57 damien Exp $	*/
d283 1
a283 1
	/* finalize MIC, U := T XOR first-M-bytes( S_O ) */
d325 1
a325 1
	/* check that ExtIV bit is be set */
d440 1
a440 1
	/* finalize MIC, U := T XOR first-M-bytes( S_O ) */
@


1.6
log
@in a near future, unicast management frames will be encrypted/decrypted
using CCMP.  use the right replay counter in this case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.5 2008/08/12 16:45:44 damien Exp $	*/
d104 1
a104 3
	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS))
d112 3
a114 5
	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) ==
	    IEEE80211_FC1_DIR_DSTODS) {
		const struct ieee80211_frame_addr4 *wh4 =
		    (const struct ieee80211_frame_addr4 *)wh;
		IEEE80211_ADDR_COPY(aad, wh4->i_addr4);
d116 3
a118 14
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
		    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS)) {
			const struct ieee80211_qosframe_addr4 *qwh4 =
			    (const struct ieee80211_qosframe_addr4 *)wh;
			*aad++ = tid = qwh4->i_qos[0] & 0x0f;
			*aad++ = 0;
		}
	} else if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS)) {
		const struct ieee80211_qosframe *qwh =
		    (const struct ieee80211_qosframe *)wh;
		*aad++ = tid = qwh->i_qos[0] & 0x0f;
d331 5
a335 15
	/* retrieve last seen packet number for this frame type/TID */
	if ((wh->i_fc[0] &
	    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_QOS)) ==
	    (IEEE80211_FC0_TYPE_DATA | IEEE80211_FC0_SUBTYPE_QOS)) {
		u_int8_t tid;
		if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) ==
		    IEEE80211_FC1_DIR_DSTODS) {
			struct ieee80211_qosframe_addr4 *qwh4 =
			    (struct ieee80211_qosframe_addr4 *)wh;
			tid = qwh4->i_qos[0] & 0x0f;
		} else {
			struct ieee80211_qosframe *qwh =
			    (struct ieee80211_qosframe *)wh;
			tid = qwh->i_qos[0] & 0x0f;
		}
a336 3
	} else if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) !=
	    IEEE80211_FC0_TYPE_MGT) {
		prsc = &k->k_rsc[0];
@


1.5
log
@maintain a count of TKIP and CCMP replayed frames.
some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.4 2008/08/12 16:21:46 damien Exp $	*/
d362 2
a363 1
	} else
d365 2
@


1.4
log
@retrieve the TID from QoS frames to use with the appropriate
replay counter.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.3 2008/08/12 16:14:45 henning Exp $	*/
d19 5
a29 1
#include <sys/sockio.h>
d91 1
a91 1
	/* construct AAD (additional authentication data) */
d374 1
d472 1
d478 1
a478 4
	/*
	 * Update last seen packet number (note that it must be done
	 * after MIC is validated.)
	 */
@


1.3
log
@use MINCLSIZE to decide wether we need to allocate an mbuf cluster instead
of MLEM, damien ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.2 2008/07/26 12:41:34 damien Exp $	*/
d317 1
a317 1
	u_int64_t pn;
d341 20
d368 1
a368 1
	if (pn <= k->k_rsc[0]) {
d476 1
a476 1
	k->k_rsc[0] = pn;
@


1.2
log
@properly handle management frames (required for future work).
remove useless #includes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ieee80211_crypto_ccmp.c,v 1.1 2008/04/16 18:32:15 damien Exp $	*/
d249 1
a249 1
			if (left > MLEN - IEEE80211_CCMP_MICLEN) {
d403 1
a403 1
			if (left > MLEN) {
@


1.1
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a26 3
#include <sys/errno.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
d74 1
a74 1
/*
d89 16
a104 5
	*aad++ = wh->i_fc[0] & ~IEEE80211_FC0_SUBTYPE_MASK;
	/* NB: 'Protected' bit is already set in wh->i_fc[1] */
	/* 'Order' bit was added as part of 802.11n-Draft 2.0 */
	*aad++ = wh->i_fc[1] & ~(IEEE80211_FC1_RETRY | IEEE80211_FC1_ORDER |
	    IEEE80211_FC1_PWR_MGT | IEEE80211_FC1_MORE_DATA);
d134 4
a137 1
	nonce[0]  = tid;
d139 3
a141 3
	nonce[7]  = pn >> 40;	/* PN5 */
	nonce[8]  = pn >> 32;	/* PN4 */
	nonce[9]  = pn >> 24;	/* PN3 */
d153 1
a153 1
	b[0] = 89;	/* Flags = 64*Adata + 8*((M-2)/2) + (L-1) */
d167 1
a167 1
	a[0] = 1;	/* Flags = L' = (L-1) */
@

