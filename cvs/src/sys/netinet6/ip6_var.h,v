head	1.72;
access;
symbols
	OPENBSD_6_1:1.71.0.4
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.62.0.2
	OPENBSD_6_0_BASE:1.62
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.51.0.6
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.44.0.6
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.2
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.36.0.4
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.25.0.6
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.4
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.24.0.4
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.2
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.20
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.72
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.71;
commitid	00hB28wQPwG5Ysk0;

1.71
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.70;
commitid	ZsxSSZJSFxZH81LL;

1.70
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.69;
commitid	LtQeAWkATeJFPv2t;

1.69
date	2017.02.28.09.59.34;	author mpi;	state Exp;
branches;
next	1.68;
commitid	T3PPWgqAoWqJuqmb;

1.68
date	2017.02.08.12.37.43;	author bluhm;	state Exp;
branches;
next	1.67;
commitid	h9Q88VpdY8UDaqEf;

1.67
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.66;
commitid	2R0NOjEDy2jGtnjL;

1.66
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.65;
commitid	UBL7uwpXqTP4EWIu;

1.65
date	2016.12.02.11.16.04;	author mpi;	state Exp;
branches;
next	1.64;
commitid	WNL3JHfh9QQ4epFM;

1.64
date	2016.08.24.09.41.12;	author mpi;	state Exp;
branches;
next	1.63;
commitid	0Qtt2cJVj3irHniv;

1.63
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.62;
commitid	nbCHuHn2E9uBfKJT;

1.62
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.61;
commitid	Cm0qxR09oTCkXjXZ;

1.61
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.60;
commitid	jodmGXAB42f8N6nf;

1.60
date	2016.06.01.11.11.44;	author jca;	state Exp;
branches;
next	1.59;
commitid	sy5Ke15K2mroYglc;

1.59
date	2016.05.19.11.34.40;	author jca;	state Exp;
branches;
next	1.58;
commitid	vkyQX2LT0UqUpZLs;

1.58
date	2016.04.27.21.14.29;	author markus;	state Exp;
branches;
next	1.57;
commitid	nWBKWy8IKn6P3HG1;

1.57
date	2015.12.03.21.11.54;	author sashan;	state Exp;
branches;
next	1.56;
commitid	nhuzteWvIf6uiITt;

1.56
date	2015.10.25.14.43.06;	author florian;	state Exp;
branches;
next	1.55;
commitid	YdNR4Tx8Af0XRTgT;

1.55
date	2015.09.11.19.23.00;	author mpi;	state Exp;
branches;
next	1.54;
commitid	ZcCSlMJqT7JT7yQD;

1.54
date	2015.09.11.13.53.04;	author mpi;	state Exp;
branches;
next	1.53;
commitid	PQQVxswGql4gzKJa;

1.53
date	2015.09.11.09.58.33;	author mpi;	state Exp;
branches;
next	1.52;
commitid	QtNDimZdovXpU3uh;

1.52
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.51;
commitid	Cr0DVA7exR1t2zXg;

1.51
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.50;
commitid	cYQY7jiay4SydLhD;

1.50
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.49;
commitid	Vq8oSnWLkf7dyy0N;

1.49
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.48;
commitid	AGagL83SRBC6d7e7;

1.48
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.47;

1.47
date	2013.10.21.12.27.16;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2012.01.09.14.47.53;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.09.01.01.12;	author bluhm;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.05.21.02.42;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.22.23.13.01;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2011.03.06.19.55.54;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2010.12.21.13.12.59;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2008.11.25.12.11.45;	author markus;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.03.08.41.57;	author mpf;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.32;

1.32
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.30;

1.30
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2006.11.21.05.37.32;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2006.07.06.02.56.58;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.18.03.59.34;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2003.08.07.09.11.53;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2002.12.09.00.45.37;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.21.47.44;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.07.15.27.58;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.29.23.38.58;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.28.03.04.38;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.28.05.28.48;	author angelos;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.02.08.18.46.23;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.12.16.41.31;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.06.10.11.25;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.19.03.43.17;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.22.03.50.35;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.28.16.40.39;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.04.18.11.38;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.01.08.13.54.36;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.03.24.09.09.40;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.05.14.22.40.19;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.07.04.10.55.24;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.72
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: ip6_var.h,v 1.71 2017/03/13 20:18:21 claudio Exp $	*/
/*	$KAME: ip6_var.h,v 1.33 2000/06/11 14:59:20 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET6_IP6_VAR_H_
#define _NETINET6_IP6_VAR_H_

/*
 * IP6 reassembly queue structure.  Each fragment
 * being reassembled is attached to one of these structures.
 */
struct	ip6q {
	TAILQ_ENTRY(ip6q) ip6q_queue;
	LIST_HEAD(ip6asfrag_list, ip6asfrag) ip6q_asfrag;
	struct in6_addr	ip6q_src, ip6q_dst;
	int		ip6q_unfrglen;	/* len of unfragmentable part */
	int		ip6q_nfrag;	/* # of fragments */
	u_int32_t	ip6q_ident;	/* fragment identification */
	u_int8_t	ip6q_nxt;	/* ip6f_nxt in first fragment */
	u_int8_t	ip6q_ttl;	/* time to live in slowtimo units */
};

struct	ip6asfrag {
	LIST_ENTRY(ip6asfrag) ip6af_list;
	struct mbuf	*ip6af_m;
	int		ip6af_offset;	/* offset in ip6af_m to next header */
	int		ip6af_frglen;	/* fragmentable part length */
	int		ip6af_off;	/* fragment offset */
	u_int32_t	ip6af_flow;	/* ip header flow id */
	u_int16_t	ip6af_mff;	/* more fragment bit in frag off */
};

#define IP6_REASS_MBUF(ip6af) ((ip6af)->ip6af_m)

struct	ip6_moptions {
	LIST_HEAD(, in6_multi_mship) im6o_memberships;
	unsigned short im6o_ifidx;	/* ifp index for outgoing multicasts */
	u_char	im6o_hlim;	/* hoplimit for outgoing multicasts */
	u_char	im6o_loop;	/* 1 >= hear sends if a member */
};

/*
 * Control options for outgoing packets
 */

/* Routing header related info */
struct	ip6po_rhinfo {
	struct	ip6_rthdr *ip6po_rhi_rthdr; /* Routing header */
	struct	route_in6 ip6po_rhi_route; /* Route to the 1st hop */
};
#define ip6po_rthdr	ip6po_rhinfo.ip6po_rhi_rthdr
#define ip6po_route	ip6po_rhinfo.ip6po_rhi_route

struct	ip6_pktopts {
	/* Hoplimit for outgoing packets */
	int	ip6po_hlim;

	/* Outgoing IF/address information */
	struct in6_pktinfo *ip6po_pktinfo;

	/* Hop-by-Hop options header */
	struct	ip6_hbh *ip6po_hbh;

	/* Destination options header (before a routing header) */
	struct	ip6_dest *ip6po_dest1;

	/* Routing header related info. */
	struct	ip6po_rhinfo ip6po_rhinfo;

	/* Destination options header (after a routing header) */
	struct	ip6_dest *ip6po_dest2;

	/* traffic class */
	int	ip6po_tclass;

	/* fragment vs PMTU discovery policy */
	int	ip6po_minmtu;
#define IP6PO_MINMTU_MCASTONLY	-1 /* default: send at min MTU for multicast */
#define IP6PO_MINMTU_DISABLE	0  /* always perform pmtu disc */
#define IP6PO_MINMTU_ALL	1  /* always send at min MTU */

	int	ip6po_flags;
#define	IP6PO_DONTFRAG	0x04	/* disable fragmentation (IPV6_DONTFRAG) */
};

struct	ip6stat {
	u_int64_t ip6s_total;		/* total packets received */
	u_int64_t ip6s_tooshort;	/* packet too short */
	u_int64_t ip6s_toosmall;	/* not enough data */
	u_int64_t ip6s_fragments;	/* fragments received */
	u_int64_t ip6s_fragdropped;	/* frags dropped(dups, out of space) */
	u_int64_t ip6s_fragtimeout;	/* fragments timed out */
	u_int64_t ip6s_fragoverflow;	/* fragments that exceeded limit */
	u_int64_t ip6s_forward;		/* packets forwarded */
	u_int64_t ip6s_cantforward;	/* packets rcvd for unreachable dest */
	u_int64_t ip6s_redirectsent;	/* packets forwarded on same net */
	u_int64_t ip6s_delivered;	/* datagrams delivered to upper level*/
	u_int64_t ip6s_localout;	/* total ip packets generated here */
	u_int64_t ip6s_odropped;	/* lost packets due to nobufs, etc. */
	u_int64_t ip6s_reassembled;	/* total packets reassembled ok */
	u_int64_t ip6s_fragmented;	/* datagrams successfully fragmented */
	u_int64_t ip6s_ofragments;	/* output fragments created */
	u_int64_t ip6s_cantfrag;	/* don't fragment flag was set, etc. */
	u_int64_t ip6s_badoptions;	/* error in option processing */
	u_int64_t ip6s_noroute;		/* packets discarded due to no route */
	u_int64_t ip6s_badvers;		/* ip6 version != 6 */
	u_int64_t ip6s_rawout;		/* total raw ip packets generated */
	u_int64_t ip6s_badscope;	/* scope error */
	u_int64_t ip6s_notmember;	/* don't join this multicast group */
	u_int64_t ip6s_nxthist[256];	/* next header history */
	u_int64_t ip6s_m1;		/* one mbuf */
	u_int64_t ip6s_m2m[32];		/* two or more mbuf */
	u_int64_t ip6s_mext1;		/* one ext mbuf */
	u_int64_t ip6s_mext2m;		/* two or more ext mbuf */
	u_int64_t ip6s_nogif;		/* no match gif found */
	u_int64_t ip6s_toomanyhdr;	/* discarded due to too many headers */

	/*
	 * statistics for improvement of the source address selection
	 * algorithm:
	 * XXX: hardcoded 16 = # of ip6 multicast scope types + 1
	 */
	/* number of times that address selection fails */
	u_int64_t ip6s_sources_none;
	/* number of times that an address on the outgoing I/F is chosen */
	u_int64_t ip6s_sources_sameif[16];
	/* number of times that an address on a non-outgoing I/F is chosen */
	u_int64_t ip6s_sources_otherif[16];
	/*
	 * number of times that an address that has the same scope
	 * from the destination is chosen.
	 */
	u_int64_t ip6s_sources_samescope[16];
	/*
	 * number of times that an address that has a different scope
	 * from the destination is chosen.
	 */
	u_int64_t ip6s_sources_otherscope[16];
	/* number of times that an deprecated address is chosen */
	u_int64_t ip6s_sources_deprecated[16];

	u_int64_t ip6s_forward_cachehit;
	u_int64_t ip6s_forward_cachemiss;
};

#ifdef _KERNEL

#include <sys/percpu.h>

enum ip6stat_counters {
	ip6s_total,
	ip6s_tooshort,
	ip6s_toosmall,
	ip6s_fragments,
	ip6s_fragdropped,
	ip6s_fragtimeout,
	ip6s_fragoverflow,
	ip6s_forward,
	ip6s_cantforward,
	ip6s_redirectsent,
	ip6s_delivered,
	ip6s_localout,
	ip6s_odropped,
	ip6s_reassembled,
	ip6s_fragmented,
	ip6s_ofragments,
	ip6s_cantfrag,
	ip6s_badoptions,
	ip6s_noroute,
	ip6s_badvers,
	ip6s_rawout,
	ip6s_badscope,
	ip6s_notmember,
	ip6s_nxthist,
	ip6s_m1 = ip6s_nxthist + 256,
	ip6s_m2m,
	ip6s_mext1 = ip6s_m2m + 32,
	ip6s_mext2m,
	ip6s_nogif,
	ip6s_toomanyhdr,
	ip6s_sources_none,
	ip6s_sources_sameif,
	ip6s_sources_otherif = ip6s_sources_sameif + 16,
	ip6s_sources_samescope = ip6s_sources_otherif + 16,
	ip6s_sources_otherscope = ip6s_sources_samescope + 16,
	ip6s_sources_deprecated = ip6s_sources_otherscope + 16,
	ip6s_forward_cachehit = ip6s_sources_deprecated + 16,
	ip6s_forward_cachemiss,
	ip6s_ncounters,
};

extern struct cpumem *ip6counters;

static inline void
ip6stat_inc(enum ip6stat_counters c)
{
	counters_inc(ip6counters, c);
}

static inline void
ip6stat_add(enum ip6stat_counters c, uint64_t v)
{
	counters_add(ip6counters, c, v);
}

/* flags passed to ip6_output as last parameter */
#define	IPV6_UNSPECSRC		0x01	/* allow :: as the source address */
#define	IPV6_FORWARDING		0x02	/* most of IPv6 header exists */
#define	IPV6_MINMTU		0x04	/* use minimum MTU (IPV6_USE_MIN_MTU) */

extern int ip6_mtudisc_timeout;		/* mtu discovery */
extern struct rttimer_queue *icmp6_mtudisc_timeout_q;

extern int	ip6_defhlim;		/* default hop limit */
extern int	ip6_defmcasthlim;	/* default multicast hop limit */
extern int	ip6_forwarding;		/* act as router? */
extern int	ip6_mforwarding;	/* act as multicast router? */
extern int	ip6_multipath;		/* use multipath routes */
extern int	ip6_sendredirect;	/* send ICMPv6 redirect? */
extern int	ip6_use_deprecated;	/* allow deprecated addr as source */
extern int	ip6_mcast_pmtu;		/* path MTU discovery for multicast */
extern int	ip6_neighborgcthresh; /* Threshold # of NDP entries for GC */
extern int	ip6_maxifprefixes; /* Max acceptable prefixes via RA per IF */
extern int	ip6_maxifdefrouters; /* Max acceptable def routers via RA */
extern int	ip6_maxdynroutes; /* Max # of routes created via redirect */

extern struct socket *ip6_mrouter; 	/* multicast routing daemon */
extern int	ip6_sendredirects;	/* send IP redirects when forwarding? */
extern int	ip6_maxfragpackets; /* Maximum packets in reassembly queue */
extern int	ip6_maxfrags;	/* Maximum fragments in reassembly queue */
extern int	ip6_log_interval;
extern time_t	ip6_log_time;
extern int	ip6_hdrnestlimit; /* upper limit of # of extension headers */
extern int	ip6_dad_count;		/* DupAddrDetectionTransmits */
extern int	ip6_dad_pending;	/* number of currently running DADs */

extern int ip6_auto_flowlabel;
extern int ip6_auto_linklocal;

struct in6pcb;
struct inpcb;

int	icmp6_ctloutput(int, struct socket *, int, int, struct mbuf *);

void	ip6_init(void);
void	ip6intr(void);
void	ip6_input(struct mbuf *);
void	ip6_local(struct mbuf *, int, int);
void	ip6_freepcbopts(struct ip6_pktopts *);
void	ip6_freemoptions(struct ip6_moptions *);
int	ip6_unknown_opt(u_int8_t *, struct mbuf *, int);
u_int8_t *ip6_get_prevhdr(struct mbuf *, int);
int	ip6_nexthdr(struct mbuf *, int, int, int *);
int	ip6_lasthdr(struct mbuf *, int, int, int *);
int	ip6_mforward(struct ip6_hdr *, struct ifnet *, struct mbuf *);
int	ip6_process_hopopts(struct mbuf *, u_int8_t *, int, u_int32_t *,
	     u_int32_t *);
void	ip6_savecontrol(struct inpcb *, struct mbuf *, struct mbuf **);
int	ip6_sysctl(int *, u_int, void *, size_t *, void *, size_t);

void	ip6_forward(struct mbuf *, struct rtentry *, int);

void	ip6_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in6 *);
int	ip6_output(struct mbuf *, struct ip6_pktopts *, struct route_in6 *, int,
	    struct ip6_moptions *, struct inpcb *);
int	ip6_fragment(struct mbuf *, int, u_char, u_long);
int	ip6_ctloutput(int, struct socket *, int, int, struct mbuf *);
int	ip6_raw_ctloutput(int, struct socket *, int, int, struct mbuf *);
void	ip6_initpktopts(struct ip6_pktopts *);
int	ip6_setpktopts(struct mbuf *, struct ip6_pktopts *,
	    struct ip6_pktopts *, int, int);
void	ip6_clearpktopts(struct ip6_pktopts *, int);
void	ip6_randomid_init(void);
u_int32_t ip6_randomid(void);
void	ip6_send(struct mbuf *);

int	route6_input(struct mbuf **, int *, int, int);

void	frag6_init(void);
int	frag6_input(struct mbuf **, int *, int, int);
int	frag6_deletefraghdr(struct mbuf *, int);
void	frag6_slowtimo(void);
void	frag6_drain(void);

void	rip6_init(void);
int	rip6_input(struct mbuf **, int *, int, int);
void	rip6_ctlinput(int, struct sockaddr *, u_int, void *);
int	rip6_ctloutput(int, struct socket *, int, int, struct mbuf *);
int	rip6_output(struct mbuf *, struct socket *, struct sockaddr *,
	    struct mbuf *);
int	rip6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
int	rip6_attach(struct socket *, int);
int	rip6_sysctl(int *, u_int, void *, size_t *, void *, size_t);

int	dest6_input(struct mbuf **, int *, int, int);
int	none_input(struct mbuf **, int *, int);

int	in6_pcbselsrc(struct in6_addr **, struct sockaddr_in6 *,
	    struct inpcb *, struct ip6_pktopts *);
int	in6_selectsrc(struct in6_addr **, struct sockaddr_in6 *,
	    struct ip6_moptions *, unsigned int);
struct rtentry *in6_selectroute(struct sockaddr_in6 *, struct ip6_pktopts *,
	    struct route_in6 *, unsigned int rtableid);

u_int32_t ip6_randomflowlabel(void);

#ifdef IPSEC
struct tdb;
struct tdb *
	ip6_output_ipsec_lookup(struct mbuf *, int *, struct inpcb *);
int	ip6_output_ipsec_send(struct tdb *, struct mbuf *, int, int);
#endif /* IPSEC */

#endif /* _KERNEL */

#endif /* !_NETINET6_IP6_VAR_H_ */
@


1.71
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.70 2017/03/03 15:48:02 bluhm Exp $	*/
d336 1
a336 1
int	route6_input(struct mbuf **, int *, int);
d339 1
a339 1
int	frag6_input(struct mbuf **, int *, int);
d345 1
a345 1
int	rip6_input(struct mbuf **mp, int *offp, int proto);
d355 1
a355 1
int	dest6_input(struct mbuf **, int *, int);
@


1.70
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.69 2017/02/28 09:59:34 mpi Exp $	*/
d352 1
@


1.69
log
@Some refactoring in ip6_input() needed to un-KERNEL_LOCK() the IPv6
forwarding path.

Rename ip6_ours() in ip6_local() as this function dispatches packets
to the upper layer.

Introduce ip6_ours() and get rid of 'goto hbhcheck'.  This function
will be later used to enqueue local packets.

As a bonus this reduces differences with IPv4.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.68 2017/02/08 12:37:43 bluhm Exp $	*/
d348 2
a349 1
int	rip6_output(struct mbuf *, ...);
@


1.68
log
@Remove the ipsec protocol callbacks which all do the same.  Implement
it in ipsec_common_input_cb() instead.  The code that was copied
to ah6_input_cb() is now in ip6_ours() so we can call it directly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.67 2017/02/05 16:04:14 jca Exp $	*/
d307 1
a307 1
void	ip6_ours(struct mbuf *, int, int);
@


1.67
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.66 2017/02/01 20:59:47 dhill Exp $	*/
d307 1
@


1.66
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.65 2016/12/02 11:16:04 mpi Exp $	*/
d206 59
a272 1
extern struct	ip6stat ip6stat;	/* statistics */
@


1.65
log
@Rremoves 'struct route_in6 *' argument from in6_selectsrc().

Move the corresponding code in in6_pcbselsrc().  This reduces
differences with IPv4 and will help us to get rid of 'struct route*'.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.64 2016/08/24 09:41:12 mpi Exp $	*/
d244 1
a244 1
int	icmp6_ctloutput(int, struct socket *, int, int, struct mbuf **);
d267 2
a268 2
int	ip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	ip6_raw_ctloutput(int, struct socket *, int, int, struct mbuf **);
d288 1
a288 1
int	rip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
@


1.64
log
@Kill ip6_forward_rt reducing differences between v4 and v6.

A single forwarding cache is not the answer.  The answer is 42... err PF!

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.63 2016/08/04 20:46:24 vgross Exp $	*/
d300 1
a300 1
	    struct ip6_moptions *, struct route_in6 *, u_int);
@


1.63
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.62 2016/07/22 11:14:41 mpi Exp $	*/
d261 1
a261 1
void	ip6_forward(struct mbuf *, int);
@


1.62
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.60 2016/06/01 11:11:44 jca Exp $	*/
d297 2
d300 1
a300 2
	    struct ip6_pktopts *, struct ip6_moptions *, struct route_in6 *,
	    struct in6_addr *, u_int);
@


1.61
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@a296 2
int	in6_pcbselsrc(struct in6_addr **, struct sockaddr_in6 *,
	    struct inpcb *, struct ip6_pktopts *);
d298 2
a299 1
	    struct ip6_moptions *, struct route_in6 *, u_int);
@


1.60
log
@Kill sysctl net.inet6.ip6.rr_prune

We don't support Router Renumbering and there are no plans to change
that.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.59 2016/05/19 11:34:40 jca Exp $	*/
d297 2
d300 1
a300 2
	    struct ip6_pktopts *, struct ip6_moptions *, struct route_in6 *,
	    struct in6_addr *, u_int);
@


1.59
log
@Remove sysctl net.inet6.ip6.v6only

This sysctl is a no-op, read-only since it was introduced.  There are no
plans to support IPv4-mapped addresses on OpenBSD, thus this sysctl is
meaningless.

Noticed by djm@@, ok claudio@@ mpi@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.58 2016/04/27 21:14:29 markus Exp $	*/
a221 2
extern int	ip6_rr_prune;		/* router renumbering prefix
					 * walk list every 5 sec.    */
@


1.58
log
@factor out ipsec into ip6_output_ipsec_{lookup,send}(); ok mpi@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.57 2015/12/03 21:11:54 sashan Exp $	*/
a224 1
extern const int	ip6_v6only;
@


1.57
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.56 2015/10/25 14:43:06 florian Exp $	*/
d307 8
@


1.56
log
@Remove IPV6_NEXTHOP implementation. Source routing is considered to be
a bad idea these days.
kill it mpi@@
general agreement in the network hackers room at u2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.55 2015/09/11 19:23:00 mpi Exp $	*/
d278 1
@


1.55
log
@Rewrite in6_selectroute() to no longer return an ifp.

The returned "struct rtentry" is either the cached one or the one passed
in options.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.54 2015/09/11 13:53:04 mpi Exp $	*/
a112 8
/* Nexthop related info */
struct	ip6po_nhinfo {
	struct sockaddr *ip6po_nhi_nexthop;
	struct route_in6 ip6po_nhi_route;
};
#define ip6po_nexthop	ip6po_nhinfo.ip6po_nhi_nexthop
#define ip6po_nextroute	ip6po_nhinfo.ip6po_nhi_route

a118 3

	/* Next-hop address information */
	struct	ip6po_nhinfo ip6po_nhinfo;
@


1.54
log
@Move the multicast option parsing out of in6_selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.53 2015/09/11 09:58:33 mpi Exp $	*/
d313 2
a314 3
int	in6_selectroute(struct sockaddr_in6 *, struct ip6_pktopts *,
	    struct route_in6 *, struct ifnet **,
	    struct rtentry **, unsigned int rtableid);
@


1.53
log
@Kill selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.52 2015/09/11 08:17:06 claudio Exp $	*/
d314 2
a315 2
	    struct ip6_moptions *, struct route_in6 *, struct ifnet **,
	    struct rtentry **, int, u_int rtableid);
@


1.52
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.51 2014/12/17 09:57:13 mpi Exp $	*/
d315 1
a315 1
	    struct rtentry **, u_int rtableid);
@


1.51
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.50 2014/12/17 09:45:59 mpi Exp $	*/
d279 1
a279 1
	    struct ip6_moptions *, struct ifnet **, struct inpcb *);
@


1.50
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.49 2014/07/11 16:39:06 henning Exp $	*/
d97 2
a98 2
	u_char	im6o_multicast_hlim;	/* hoplimit for outgoing multicasts */
	u_char	im6o_multicast_loop;	/* 1 >= hear sends if a member */
@


1.49
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.47 2013/10/21 12:27:16 deraadt Exp $	*/
d95 2
a96 1
	struct	ifnet *im6o_multicast_ifp; /* ifp for outgoing multicasts */
a98 1
	LIST_HEAD(, in6_multi_mship) im6o_memberships;
@


1.48
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@a245 1
extern int	ip6_accept_rtadv;	/* Acts as a host not a router */
@


1.47
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.46 2013/06/01 16:22:05 bluhm Exp $	*/
d311 3
a313 3
struct in6_addr *in6_selectsrc(struct sockaddr_in6 *, struct ip6_pktopts *,
	    struct ip6_moptions *, struct route_in6 *, struct in6_addr *,
	    int *, u_int);
@


1.46
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.45 2013/03/14 11:18:37 mpi Exp $	*/
d221 3
@


1.45
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.44 2012/01/09 14:47:53 bluhm Exp $	*/
d298 1
a298 1
void	rip6_ctlinput(int, struct sockaddr *, void *);
@


1.44
log
@Remove the IPv6 fragment overlapping length adjustment code.  It
was already #if 0 and will never come back.  Remove unused fragment
struct fields and sort the others.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.43 2012/01/09 01:01:12 bluhm Exp $	*/
a243 1
extern int	ip6_keepfaith;		/* Firewall Aided Internet Translator */
@


1.43
log
@Replace the hand-crafted queue for IPv6 fragments with LIST.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.42 2012/01/05 21:02:42 bluhm Exp $	*/
d72 1
a72 1
	u_int8_t	ip6q_nxt;	/* ip6f_nxt in first fragment */
a73 3
	u_int32_t	ip6q_ident;
	u_int8_t	ip6q_arrive;
	u_int8_t	ip6q_ttl;
a74 1
	TAILQ_ENTRY(ip6q) ip6q_queue;
a75 3
#ifdef notyet
	u_char		*ip6q_nxtp;
#endif
d77 3
a82 5
	u_int32_t	ip6af_head;
	u_int16_t	ip6af_len;
	u_int8_t	ip6af_nxt;
	u_int8_t	ip6af_hlim;
	/* must not override the above members during reassembling */
d88 1
@


1.42
log
@Replace the hand-crafted queue for fragmented IPv6 packets with TAILQ.
I forgot the header file containing struct ip6q in the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.41 2011/11/24 17:39:55 sperreault Exp $	*/
a71 2
	u_int32_t	ip6q_head;
	u_int16_t	ip6q_len;
d73 1
a73 3
	u_int8_t	ip6q_hlim;
	struct ip6asfrag *ip6q_down;
	struct ip6asfrag *ip6q_up;
d92 1
a92 2
	struct ip6asfrag *ip6af_down;
	struct ip6asfrag *ip6af_up;
@


1.41
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.40 2011/03/22 23:13:01 bluhm Exp $	*/
d82 1
a82 2
	struct ip6q	*ip6q_next;
	struct ip6q	*ip6q_prev;
@


1.40
log
@Extract the new function ip6_fragment() from ip6_output() to make
it reusable by pf.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.39 2011/03/06 19:55:54 bluhm Exp $	*/
d325 1
a325 1
	    int *);
d328 1
a328 1
	    struct rtentry **);
@


1.39
log
@Extract the new function frag6_deletefraghdr() from frag6_input()
to make it reusable by pf.  No functional change.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.38 2010/12/21 13:12:59 claudio Exp $	*/
d293 1
@


1.38
log
@Remove the no longer used ip6s_exthdrtoolong field.
OK mikeb@@, henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.37 2010/07/08 19:42:46 jsg Exp $	*/
d306 1
@


1.37
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.36 2008/11/25 12:11:45 markus Exp $	*/
a198 1
	u_int64_t ip6s_exthdrtoolong;	/* ext hdr are not continuous */
@


1.36
log
@delay /etc/netstart until IPv6-DAD (dup-address-detection) is completed.
ok fries, hshoexer, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.35 2008/09/03 08:41:57 mpf Exp $	*/
a243 1
extern int	ip6_forward_srcrt;	/* forward src-routed? */
a257 2
extern int	ip6_sourcecheck;	/* Verify source interface */
extern int	ip6_sourcecheck_interval; /* Interval between log messages */
a299 1
int	ip6_optlen(struct inpcb *);
@


1.35
log
@Remove dead code: ip6_copypktopts() is not used anywhere.
OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.34 2008/06/11 06:30:36 mcbride Exp $	*/
d267 1
@


1.34
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.33 2008/06/09 22:47:42 djm Exp $	*/
a301 1
struct ip6_pktopts *ip6_copypktopts(struct ip6_pktopts *, int);
@


1.33
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.32 2007/12/14 18:33:41 deraadt Exp $	*/
d250 4
@


1.32
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.31 2007/06/01 00:52:38 henning Exp $	*/
d300 2
a328 1
u_int32_t ip6_randomid(void);
@


1.31
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.30 2006/12/09 01:12:28 itojun Exp $	*/
d315 1
@


1.30
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.29 2006/11/21 05:37:32 itojun Exp $	*/
d291 1
a291 1
	    struct ip6_moptions *, struct ifnet **);
@


1.29
log
@introduce sysctl net.inet6.ip6.multicast_mtudisc (for multicast routers).
deraadt ok.  manpage nit by jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.28 2006/07/06 02:56:58 brad Exp $	*/
d127 8
d136 32
a167 8
	struct	mbuf *ip6po_m;	/* Pointer to mbuf storing the data */
	int	ip6po_hlim;		/* Hoplimit for outgoing packets */
	struct	in6_pktinfo *ip6po_pktinfo; /* Outgoing IF/address information */
	struct	sockaddr *ip6po_nexthop;	/* Next-hop address */
	struct	ip6_hbh *ip6po_hbh; /* Hop-by-Hop options header */
	struct	ip6_dest *ip6po_dest1; /* Destination options header(1st part) */
	struct	ip6po_rhinfo ip6po_rhinfo; /* Routing header related info. */
	struct	ip6_dest *ip6po_dest2; /* Destination options header(2nd part) */
d275 1
d283 2
a284 3
				 u_int32_t *);
void	ip6_savecontrol(struct inpcb *, struct mbuf **, struct ip6_hdr *,
		struct mbuf *);
d290 2
a291 3
int	ip6_output(struct mbuf *, struct ip6_pktopts *,
			struct route_in6 *, int,
			struct ip6_moptions *, struct ifnet **);
d294 5
a298 1
int	ip6_setpktoptions(struct mbuf *, struct ip6_pktopts *, int);
d319 6
a324 2
struct 	in6_addr *in6_selectsrc(struct sockaddr_in6 *, struct ip6_pktopts *,
	struct ip6_moptions *, struct route_in6 *, struct in6_addr *, int *);
@


1.28
log
@u_quad_t -> u_int64_t

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.27 2006/06/18 11:47:46 pascoe Exp $	*/
d216 1
@


1.27
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.26 2006/05/27 23:40:27 claudio Exp $	*/
d139 31
a169 31
	u_quad_t ip6s_total;		/* total packets received */
	u_quad_t ip6s_tooshort;		/* packet too short */
	u_quad_t ip6s_toosmall;		/* not enough data */
	u_quad_t ip6s_fragments;	/* fragments received */
	u_quad_t ip6s_fragdropped;	/* frags dropped(dups, out of space) */
	u_quad_t ip6s_fragtimeout;	/* fragments timed out */
	u_quad_t ip6s_fragoverflow;	/* fragments that exceeded limit */
	u_quad_t ip6s_forward;		/* packets forwarded */
	u_quad_t ip6s_cantforward;	/* packets rcvd for unreachable dest */
	u_quad_t ip6s_redirectsent;	/* packets forwarded on same net */
	u_quad_t ip6s_delivered;	/* datagrams delivered to upper level*/
	u_quad_t ip6s_localout;		/* total ip packets generated here */
	u_quad_t ip6s_odropped;		/* lost packets due to nobufs, etc. */
	u_quad_t ip6s_reassembled;	/* total packets reassembled ok */
	u_quad_t ip6s_fragmented;	/* datagrams successfully fragmented */
	u_quad_t ip6s_ofragments;	/* output fragments created */
	u_quad_t ip6s_cantfrag;		/* don't fragment flag was set, etc. */
	u_quad_t ip6s_badoptions;	/* error in option processing */
	u_quad_t ip6s_noroute;		/* packets discarded due to no route */
	u_quad_t ip6s_badvers;		/* ip6 version != 6 */
	u_quad_t ip6s_rawout;		/* total raw ip packets generated */
	u_quad_t ip6s_badscope;		/* scope error */
	u_quad_t ip6s_notmember;	/* don't join this multicast group */
	u_quad_t ip6s_nxthist[256];	/* next header history */
	u_quad_t ip6s_m1;		/* one mbuf */
	u_quad_t ip6s_m2m[32];		/* two or more mbuf */
	u_quad_t ip6s_mext1;		/* one ext mbuf */
	u_quad_t ip6s_mext2m;		/* two or more ext mbuf */
	u_quad_t ip6s_exthdrtoolong;	/* ext hdr are not continuous */
	u_quad_t ip6s_nogif;		/* no match gif found */
	u_quad_t ip6s_toomanyhdr;	/* discarded due to too many headers */
d177 1
a177 1
	u_quad_t ip6s_sources_none;
d179 1
a179 1
	u_quad_t ip6s_sources_sameif[16];
d181 1
a181 1
	u_quad_t ip6s_sources_otherif[16];
d186 1
a186 1
	u_quad_t ip6s_sources_samescope[16];
d191 1
a191 1
	u_quad_t ip6s_sources_otherscope[16];
d193 1
a193 1
	u_quad_t ip6s_sources_deprecated[16];
d195 2
a196 2
	u_quad_t ip6s_forward_cachehit;
	u_quad_t ip6s_forward_cachemiss;
@


1.26
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.25 2004/10/18 03:59:34 itojun Exp $	*/
d210 1
@


1.25
log
@g/c ip6_flow_seq.  found by mcbride.  mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.24 2003/10/01 21:41:05 itojun Exp $	*/
d209 1
@


1.24
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.23 2003/08/07 09:11:53 itojun Exp $	*/
a228 1
extern u_int32_t ip6_flow_seq;
@


1.23
log
@make net.inet6.ip6.redirect actually work.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.22 2003/06/02 23:28:16 millert Exp $	*/
a205 1
extern u_int32_t ip6_id;		/* fragment identifier */
d284 3
@


1.22
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.21 2002/12/09 00:45:37 millert Exp $	*/
d210 1
@


1.21
log
@From Andrushock, s/sucess/success/g
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.20 2002/09/11 03:27:30 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.20
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.19 2002/06/08 21:22:03 itojun Exp $	*/
d157 1
a157 1
	u_quad_t ip6s_fragmented;	/* datagrams sucessfully fragmented */
@


1.19
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.18 2002/06/07 21:47:44 itojun Exp $	*/
d247 1
a247 1
char *	ip6_get_prevhdr(struct mbuf *, int);
@


1.18
log
@move IPV6_CHECKSUM processing to ip6_raw_ctloutput().  bunch of KNFs.
rip6 stats.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.17 2002/06/07 15:27:58 itojun Exp $	*/
d110 1
a110 1
#define IP6_REASS_MBUF(ip6af) (*(struct mbuf **)&((ip6af)->ip6af_m))
d205 1
a205 1
#define	IPV6_DADOUTPUT		0x01	/* DAD */
d218 2
a219 1
extern const int ip6_v6only;
d235 1
d285 3
@


1.17
log
@just for consistency/compatibility, have net.inet6.ip6.v6only sysctl MIB,
as well as set/getsockopt(IPV6_V6ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.16 2002/05/29 23:38:58 itojun Exp $	*/
d262 1
@


1.16
log
@force fragment to minimum link MTU (1280) when needed (when PMTUD does
not take effect) - like icmp6 responses or foo-over-IPv6 tunnel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.15 2002/05/28 03:04:38 itojun Exp $	*/
d218 1
@


1.15
log
@limit number of IPv6 fragments (not the fragment queue size) to
fight against lots-of-frags DoS attacks.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.14 2002/03/14 01:27:12 millert Exp $	*/
d207 1
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.13 2001/05/28 05:28:48 angelos Exp $	*/
d92 1
d220 1
@


1.13
log
@Deprecated IPV6_ENCAPSULATED
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.12 2001/02/08 18:46:23 itojun Exp $	*/
d234 1
a234 1
int	icmp6_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
d236 14
a249 14
void	ip6_init __P((void));
void	ip6intr __P((void));
void	ip6_input __P((struct mbuf *));
void	ip6_freemoptions __P((struct ip6_moptions *));
int	ip6_unknown_opt __P((u_int8_t *, struct mbuf *, int));
char *	ip6_get_prevhdr __P((struct mbuf *, int));
int	ip6_nexthdr __P((struct mbuf *, int, int, int *));
int	ip6_lasthdr __P((struct mbuf *, int, int, int *));
int	ip6_mforward __P((struct ip6_hdr *, struct ifnet *, struct mbuf *));
int	ip6_process_hopopts __P((struct mbuf *, u_int8_t *, int, u_int32_t *,
				 u_int32_t *));
void	ip6_savecontrol __P((struct inpcb *, struct mbuf **, struct ip6_hdr *,
		struct mbuf *));
int	ip6_sysctl __P((int *, u_int, void *, size_t *, void *, size_t));
d251 1
a251 1
void	ip6_forward __P((struct mbuf *, int));
d253 2
a254 2
void	ip6_mloopback __P((struct ifnet *, struct mbuf *, struct sockaddr_in6 *));
int	ip6_output __P((struct mbuf *, struct ip6_pktopts *,
d256 19
a274 19
			struct ip6_moptions *, struct ifnet **));
int	ip6_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
int	ip6_setpktoptions __P((struct mbuf *, struct ip6_pktopts *, int));
int	ip6_optlen __P((struct inpcb *));

int	route6_input __P((struct mbuf **, int *, int));

void	frag6_init __P((void));
int	frag6_input __P((struct mbuf **, int *, int));
void	frag6_slowtimo __P((void));
void	frag6_drain __P((void));

void	rip6_init __P((void));
int	rip6_input __P((struct mbuf **mp, int *offp, int proto));
void	rip6_ctlinput __P((int, struct sockaddr *, void *));
int	rip6_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
int	rip6_output __P((struct mbuf *, ...));
int	rip6_usrreq __P((struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *));
d276 2
a277 2
int	dest6_input __P((struct mbuf **, int *, int));
int	none_input __P((struct mbuf **, int *, int));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.13 2001/05/28 05:28:48 angelos Exp $	*/
a91 1
	int		ip6q_nfrag;	/* # of fragments */
d109 1
a109 1
#define IP6_REASS_MBUF(ip6af) ((ip6af)->ip6af_m)
d204 1
a204 1
#define	IPV6_UNSPECSRC		0x01	/* allow :: as the source address */
a205 1
#define	IPV6_MINMTU		0x04	/* use minimum MTU (IPV6_USE_MIN_MTU) */
a215 2
extern const int	ip6_v6only;

a218 1
extern int	ip6_maxfrags;	/* Maximum fragments in reassembly queue */
a229 1
extern int ip6_auto_linklocal;
d234 1
a234 1
int	icmp6_ctloutput(int, struct socket *, int, int, struct mbuf **);
d236 14
a249 14
void	ip6_init(void);
void	ip6intr(void);
void	ip6_input(struct mbuf *);
void	ip6_freemoptions(struct ip6_moptions *);
int	ip6_unknown_opt(u_int8_t *, struct mbuf *, int);
char *	ip6_get_prevhdr(struct mbuf *, int);
int	ip6_nexthdr(struct mbuf *, int, int, int *);
int	ip6_lasthdr(struct mbuf *, int, int, int *);
int	ip6_mforward(struct ip6_hdr *, struct ifnet *, struct mbuf *);
int	ip6_process_hopopts(struct mbuf *, u_int8_t *, int, u_int32_t *,
				 u_int32_t *);
void	ip6_savecontrol(struct inpcb *, struct mbuf **, struct ip6_hdr *,
		struct mbuf *);
int	ip6_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d251 1
a251 1
void	ip6_forward(struct mbuf *, int);
d253 2
a254 2
void	ip6_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in6 *);
int	ip6_output(struct mbuf *, struct ip6_pktopts *,
d256 19
a274 23
			struct ip6_moptions *, struct ifnet **);
int	ip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	ip6_raw_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	ip6_setpktoptions(struct mbuf *, struct ip6_pktopts *, int);
int	ip6_optlen(struct inpcb *);

int	route6_input(struct mbuf **, int *, int);

void	frag6_init(void);
int	frag6_input(struct mbuf **, int *, int);
void	frag6_slowtimo(void);
void	frag6_drain(void);

void	rip6_init(void);
int	rip6_input(struct mbuf **mp, int *offp, int proto);
void	rip6_ctlinput(int, struct sockaddr *, void *);
int	rip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	rip6_output(struct mbuf *, ...);
int	rip6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);

int	dest6_input(struct mbuf **, int *, int);
int	none_input(struct mbuf **, int *, int);
d276 2
a277 2
struct 	in6_addr *in6_selectsrc(struct sockaddr_in6 *, struct ip6_pktopts *,
	struct ip6_moptions *, struct route_in6 *, struct in6_addr *, int *);
@


1.13.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.13.4.1 2002/06/11 03:31:37 art Exp $	*/
d247 1
a247 1
u_int8_t *ip6_get_prevhdr(struct mbuf *, int);
@


1.13.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d157 1
a157 1
	u_quad_t ip6s_fragmented;	/* datagrams successfully fragmented */
@


1.12
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.11 2000/07/12 16:41:31 itojun Exp $	*/
a205 1
#define	IPV6_ENCAPSULATED	0x04	/* encapsulated already */
@


1.11
log
@remove m_pulldown statistics, which is highly experimental
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.10 2000/07/06 10:11:25 itojun Exp $	*/
d234 2
@


1.10
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.9 2000/06/19 03:43:17 itojun Exp $	*/
a172 14
	/* XXX the following two items are not really AF_INET6 thing */
	u_quad_t ip6s_exthdrget;	/* # of calls to IP6_EXTHDR_GET */
	u_quad_t ip6s_exthdrget0;	/* # of calls to IP6_EXTHDR_GET0 */
	u_quad_t ip6s_pulldown;		/* # of calls to m_pulldown */
	u_quad_t ip6s_pulldown_copy;	/* # of mbuf copies in m_pulldown */
	u_quad_t ip6s_pulldown_alloc;	/* # of mbuf allocs in m_pulldown */
	u_quad_t ip6s_pullup;		/* # of calls to m_pullup */
	u_quad_t ip6s_pullup_copy;	/* # of possible m_pullup copies */
	u_quad_t ip6s_pullup_alloc;	/* # of possible m_pullup mallocs */
	u_quad_t ip6s_pullup_fail;	/* # of possible m_pullup failures */
	u_quad_t ip6s_pullup2;		/* # of calls to m_pullup2 */
	u_quad_t ip6s_pullup2_copy;	/* # of possible m_pullup2 copies */
	u_quad_t ip6s_pullup2_alloc;	/* # of possible m_pullup2 mallocs */
	u_quad_t ip6s_pullup2_fail;	/* # of possible m_pullup2 failures */
@


1.9
log
@IPv6 IPsec, outbound direction.

restriction: if there's any extension header (except fragment)
and outbound packet matches tdb, we can't encrypt it.
packet will not go out of the node (dropped).
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_var.h,v 1.8 2000/05/25 01:22:00 itojun Exp $	*/
/*	$KAME: ip6_var.h,v 1.28 2000/03/09 00:46:12 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d211 3
a230 4
#ifdef MAPPED_ADDR_ENABLED
extern int	ip6_mapped_addr_on;
#endif /* MAPPED_ADDR_ENABLED */

@


1.8
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.7 2000/03/22 03:50:35 itojun Exp $	*/
d217 1
@


1.7
log
@aintroduce ip6_{next,last}hdr which lets us parse IPv6 header chain correctly.
use it from icmp6 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.6 2000/02/28 16:40:39 itojun Exp $	*/
a223 1
extern int	ip6_gif_hlim;		/* Hop limit for gif encap packet */
@


1.6
log
@- check raw socket icmp6 filter only if the packet is icmp6.
- allow setting raw socket icmp6 filter only if it is IPPROTO_ICMPV6 socket.
	(cmetz may object about above two items...)
- add rip6_ctlinput, to flush cached router properly on redirects.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_var.h,v 1.5 2000/02/28 11:55:22 itojun Exp $	*/
/*	$KAME: ip6_var.h,v 1.27 2000/02/22 14:04:22 itojun Exp $	*/
d256 2
@


1.5
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.4 2000/02/04 18:11:38 itojun Exp $	*/
d282 1
@


1.4
log
@make IPv6 reass work on alpha.  NetBSD PR 9340.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_var.h,v 1.3 2000/01/08 13:54:36 itojun Exp $	*/
d174 2
d179 32
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: ip6_var.h,v 1.27 2000/02/22 14:04:22 itojun Exp $	*/
a172 2
	u_quad_t ip6s_exthdrget;	/* # of calls to IP6_EXTHDR_GET */
	u_quad_t ip6s_exthdrget0;	/* # of calls to IP6_EXTHDR_GET0 */
a175 32
	u_quad_t ip6s_pullup;		/* # of calls to m_pullup */
	u_quad_t ip6s_pullup_copy;	/* # of possible m_pullup copies */
	u_quad_t ip6s_pullup_alloc;	/* # of possible m_pullup mallocs */
	u_quad_t ip6s_pullup_fail;	/* # of possible m_pullup failures */
	u_quad_t ip6s_pullup2;		/* # of calls to m_pullup2 */
	u_quad_t ip6s_pullup2_copy;	/* # of possible m_pullup2 copies */
	u_quad_t ip6s_pullup2_alloc;	/* # of possible m_pullup2 mallocs */
	u_quad_t ip6s_pullup2_fail;	/* # of possible m_pullup2 failures */

	/*
	 * statistics for improvement of the source address selection
	 * algorithm:
	 * XXX: hardcoded 16 = # of ip6 multicast scope types + 1
	 */
	/* number of times that address selection fails */
	u_quad_t ip6s_sources_none;
	/* number of times that an address on the outgoing I/F is chosen */
	u_quad_t ip6s_sources_sameif[16];
	/* number of times that an address on a non-outgoing I/F is chosen */
	u_quad_t ip6s_sources_otherif[16];
	/*
	 * number of times that an address that has the same scope
	 * from the destination is chosen.
	 */
	u_quad_t ip6s_sources_samescope[16];
	/*
	 * number of times that an address that has a different scope
	 * from the destination is chosen.
	 */
	u_quad_t ip6s_sources_otherscope[16];
	/* number of times that an deprecated address is chosen */
	u_quad_t ip6s_sources_deprecated[16];
a246 1
void	rip6_ctlinput __P((int, struct sockaddr *, void *));
@


1.4.2.2
log
@Sync with -current
@
text
@d2 1
a2 1
/*	$KAME: ip6_var.h,v 1.28 2000/03/09 00:46:12 itojun Exp $	*/
a255 2
int	ip6_nexthdr __P((struct mbuf *, int, int, int *));
int	ip6_lasthdr __P((struct mbuf *, int, int, int *));
@


1.4.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_var.h,v 1.12 2001/02/08 18:46:23 itojun Exp $	*/
/*	$KAME: ip6_var.h,v 1.33 2000/06/11 14:59:20 jinmei Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d173 14
a210 3

	u_quad_t ip6s_forward_cachehit;
	u_quad_t ip6s_forward_cachemiss;
a216 1
#define	IPV6_ENCAPSULATED	0x04	/* encapsulated already */
d224 1
d228 4
a248 2

int	icmp6_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
@


1.4.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.4.2.3 2001/05/14 22:40:19 niklas Exp $	*/
d206 1
@


1.4.2.5
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d234 1
a234 1
int	icmp6_ctloutput(int, struct socket *, int, int, struct mbuf **);
d236 14
a249 14
void	ip6_init(void);
void	ip6intr(void);
void	ip6_input(struct mbuf *);
void	ip6_freemoptions(struct ip6_moptions *);
int	ip6_unknown_opt(u_int8_t *, struct mbuf *, int);
char *	ip6_get_prevhdr(struct mbuf *, int);
int	ip6_nexthdr(struct mbuf *, int, int, int *);
int	ip6_lasthdr(struct mbuf *, int, int, int *);
int	ip6_mforward(struct ip6_hdr *, struct ifnet *, struct mbuf *);
int	ip6_process_hopopts(struct mbuf *, u_int8_t *, int, u_int32_t *,
				 u_int32_t *);
void	ip6_savecontrol(struct inpcb *, struct mbuf **, struct ip6_hdr *,
		struct mbuf *);
int	ip6_sysctl(int *, u_int, void *, size_t *, void *, size_t);
d251 1
a251 1
void	ip6_forward(struct mbuf *, int);
d253 2
a254 2
void	ip6_mloopback(struct ifnet *, struct mbuf *, struct sockaddr_in6 *);
int	ip6_output(struct mbuf *, struct ip6_pktopts *,
d256 19
a274 19
			struct ip6_moptions *, struct ifnet **);
int	ip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	ip6_setpktoptions(struct mbuf *, struct ip6_pktopts *, int);
int	ip6_optlen(struct inpcb *);

int	route6_input(struct mbuf **, int *, int);

void	frag6_init(void);
int	frag6_input(struct mbuf **, int *, int);
void	frag6_slowtimo(void);
void	frag6_drain(void);

void	rip6_init(void);
int	rip6_input(struct mbuf **mp, int *offp, int proto);
void	rip6_ctlinput(int, struct sockaddr *, void *);
int	rip6_ctloutput(int, struct socket *, int, int, struct mbuf **);
int	rip6_output(struct mbuf *, ...);
int	rip6_usrreq(struct socket *,
	    int, struct mbuf *, struct mbuf *, struct mbuf *, struct proc *);
d276 2
a277 2
int	dest6_input(struct mbuf **, int *, int);
int	none_input(struct mbuf **, int *, int);
@


1.4.2.6
log
@Sync the SMP branch with 3.3
@
text
@a91 1
	int		ip6q_nfrag;	/* # of fragments */
d109 1
a109 1
#define IP6_REASS_MBUF(ip6af) ((ip6af)->ip6af_m)
d156 1
a156 1
	u_quad_t ip6s_fragmented;	/* datagrams successfully fragmented */
d204 1
a204 1
#define	IPV6_UNSPECSRC		0x01	/* allow :: as the source address */
a205 1
#define	IPV6_MINMTU		0x04	/* use minimum MTU (IPV6_USE_MIN_MTU) */
a215 2
extern const int	ip6_v6only;

a218 1
extern int	ip6_maxfrags;	/* Maximum fragments in reassembly queue */
a229 1
extern int ip6_auto_linklocal;
d241 1
a241 1
u_int8_t *ip6_get_prevhdr(struct mbuf *, int);
a257 1
int	ip6_raw_ctloutput(int, struct socket *, int, int, struct mbuf **);
a277 3

struct 	in6_addr *in6_selectsrc(struct sockaddr_in6 *, struct ip6_pktopts *,
	struct ip6_moptions *, struct route_in6 *, struct in6_addr *, int *);
@


1.4.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.4.2.6 2003/03/28 00:41:30 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d206 1
a209 1
extern int	ip6_sendredirect;	/* send ICMPv6 redirect? */
a283 3

u_int32_t ip6_randomid(void);
u_int32_t ip6_randomflowlabel(void);
@


1.3
log
@remove never-visited function icmp6_ctloutput().
for openbsd, this is integrated into rip6_ctloutput().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d75 13
a87 13
	u_long	ip6q_head;
	u_short	ip6q_len;
	u_char	ip6q_nxt;
	u_char	ip6q_hlim;
	struct	ip6asfrag *ip6q_down;
	struct	ip6asfrag *ip6q_up;
	u_long	ip6q_ident;
	u_char	ip6q_arrive;
	u_char	ip6q_ttl;
	struct  in6_addr ip6q_src, ip6q_dst;
	struct	ip6q *ip6q_next;
	struct	ip6q *ip6q_prev;
	int	ip6q_unfrglen;
d89 1
a89 1
	u_char	*ip6q_nxtp;
d94 4
a97 4
	u_long	ip6af_head;
	u_short	ip6af_len;
	u_char	ip6af_nxt;
	u_char	ip6af_hlim;
d99 7
a105 8
	struct	ip6asfrag *ip6af_down;
	struct	ip6asfrag *ip6af_up;
	u_short	ip6af_mff;
	u_short	ip6af_off;
	struct	mbuf *ip6af_m;
	u_long	ip6af_offset;		/* offset where next header starts */
	u_short ip6af_frglen;	/* fragmentable part length */
	u_char	ip6af_x1[10];
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_var.h,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
a214 2

int	icmp6_ctloutput __P((int, struct socket *, int, int, struct mbuf **));
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a212 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a213 7
#endif
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
extern struct	pr_usrreqs rip6_usrreqs;
struct sockopt;
#endif

#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a214 1
#endif
a215 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int	icmp6_ctloutput __P((struct socket *, struct sockopt *sopt));
#else
a216 1
#endif
a226 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a228 4
#else
void	ip6_savecontrol __P((struct in6pcb *, struct mbuf **, struct ip6_hdr *,
		struct mbuf *));
#endif
a236 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int	ip6_ctloutput __P((struct socket *, struct sockopt *sopt));
#else
a237 1
#endif
a238 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a239 3
#else
int	ip6_optlen __P((struct in6pcb *));
#endif
a249 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int	rip6_ctloutput __P((struct socket *so, struct sockopt *sopt));
#else
a250 1
#endif
@

