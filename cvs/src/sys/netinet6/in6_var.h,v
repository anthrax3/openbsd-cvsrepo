head	1.67;
access;
symbols
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.59.0.2
	OPENBSD_5_9_BASE:1.59
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.51.0.2
	OPENBSD_5_7_BASE:1.51
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.47.0.4
	OPENBSD_5_5_BASE:1.47
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.4
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.4
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.2
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.30.0.4
	OPENBSD_4_7_BASE:1.30
	OPENBSD_4_6:1.30.0.6
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.2
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.28.0.8
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.6
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.28.0.4
	OPENBSD_4_1_BASE:1.28
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28
	OPENBSD_3_9:1.26.0.2
	OPENBSD_3_9_BASE:1.26
	OPENBSD_3_8:1.24.0.6
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.4
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.2
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.20.0.4
	OPENBSD_3_3_BASE:1.20
	OPENBSD_3_2:1.20.0.2
	OPENBSD_3_2_BASE:1.20
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.20
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.67
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.66;
commitid	iTlWhLM2orYZnz27;

1.66
date	2017.03.06.08.59.07;	author mpi;	state Exp;
branches;
next	1.65;
commitid	5F7mwVgpVaCdO0cW;

1.65
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.64;
commitid	1ap8YFU49Zg4mM41;

1.64
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.63;
commitid	LxUFHuffW7GZZ01f;

1.63
date	2016.06.13.10.34.40;	author mpi;	state Exp;
branches;
next	1.62;
commitid	Lm2Xf1RxdPM3vZDo;

1.62
date	2016.03.03.12.57.15;	author jca;	state Exp;
branches;
next	1.61;
commitid	WUjfyeigg4TuFbFK;

1.61
date	2016.03.03.12.51.51;	author jca;	state Exp;
branches;
next	1.60;
commitid	lKjXzeXRhqiMIGLh;

1.60
date	2016.02.28.07.15.34;	author stefan;	state Exp;
branches;
next	1.59;
commitid	v8soDTXVbwYaYMrw;

1.59
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.58;
commitid	5qLGnZtXVLeqUvHc;

1.58
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.57;
commitid	uGqqOfOdbFUfC7aN;

1.57
date	2015.10.05.01.22.34;	author deraadt;	state Exp;
branches;
next	1.56;
commitid	l8g9I3KbTRcbSRkA;

1.56
date	2015.09.10.16.39.39;	author mpi;	state Exp;
branches;
next	1.55;
commitid	7KYjCOTlSY9IP6al;

1.55
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.54;
commitid	MtXIH0WHmPXVgeDN;

1.54
date	2015.09.01.17.21.36;	author mpi;	state Exp;
branches;
next	1.53;
commitid	R2xygFRJqL64twbR;

1.53
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.52;
commitid	hOA5qIh5CrYvhG4e;

1.52
date	2015.07.08.08.48.34;	author mpi;	state Exp;
branches;
next	1.51;
commitid	PeSgmtaVq0R4a133;

1.51
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.50;
commitid	StxeqV93bwujMj7n;

1.50
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.49;
commitid	fUNtd3qRJAn6fam0;

1.49
date	2014.04.03.08.22.10;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2013.10.14.11.07.42;	author mpi;	state Exp;
branches;
next	1.41;

1.41
date	2013.08.26.07.15.58;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2013.06.17.18.02.24;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.11.14.08.04;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.04.14.23.35;	author bluhm;	state Exp;
branches;
next	1.35;

1.35
date	2012.11.11.04.45.44;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.26.21.19.51;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.01.21.17.06;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2006.07.06.02.56.58;	author brad;	state Exp;
branches
	1.28.6.1
	1.28.8.1;
next	1.27;

1.27
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.11.17.21.53;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.19.19.36.49;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.16.02.38.23;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.13.06.28.16;	author mcbride;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.15.23.35.42;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.08.00.06.58;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.07.15.00.55;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.29.02.59.12;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.23.06.56.16;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.18.12.50.44;	author itojun;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.02.16.14.45.12;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.16.08.22.06;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.17.04.44.50;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.04.18.13.36;	author itojun;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.02.02.17.16.52;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.04.36.42;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.01.08.00.50.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.56;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	;

1.28.6.1
date	2008.10.02.17.28.12;	author brad;	state Exp;
branches;
next	;

1.28.8.1
date	2008.10.02.17.28.35;	author brad;	state Exp;
branches;
next	;

1.29.2.1
date	2008.11.02.04.02.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@/*	$OpenBSD: in6_var.h,v 1.66 2017/03/06 08:59:07 mpi Exp $	*/
/*	$KAME: in6_var.h,v 1.55 2001/02/16 12:49:45 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1985, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_var.h	8.1 (Berkeley) 6/10/93
 */

#ifndef _NETINET6_IN6_VAR_H_
#define _NETINET6_IN6_VAR_H_

/*
 * Interface address, Internet version.  One of these structures
 * is allocated for each interface with an Internet address.
 * The ifaddr structure contains the protocol-independent part
 * of the structure and is assumed to be first.
 */

/*
 * pltime/vltime are just for future reference (required to implements 2
 * hour rule for hosts).  they should never be modified by nd6_timeout or
 * anywhere else.
 *	userland -> kernel: accept pltime/vltime
 *	kernel -> userland: throw up everything
 *	in kernel: modify preferred/expire only
 */
struct in6_addrlifetime {
	time_t ia6t_expire;	/* valid lifetime expiration time */
	time_t ia6t_preferred;	/* preferred lifetime expiration time */
	u_int32_t ia6t_vltime;	/* valid lifetime */
	u_int32_t ia6t_pltime;	/* prefix lifetime */
};

#ifdef _KERNEL
struct nd_ifinfo;
struct in6_ifextra {
	struct nd_ifinfo *nd_ifinfo;
	void *rs_lhcookie;
	int nprefixes;
	int ndefrouters;
};

struct	in6_ifaddr {
	struct	ifaddr ia_ifa;		/* protocol-independent info */
#define	ia_ifp		ia_ifa.ifa_ifp
#define	ia_flags	ia_ifa.ifa_flags

	struct	sockaddr_in6 ia_addr;	/* interface address */
	struct	sockaddr_in6 ia_dstaddr; /* space for destination addr */
	struct	sockaddr_in6 ia_prefixmask; /* prefix mask */
	TAILQ_ENTRY(in6_ifaddr) ia_list;	/* list of IP6 addresses */
	int	ia6_flags;

	struct in6_addrlifetime ia6_lifetime;
	time_t	ia6_createtime; /* the creation time of this address, which is
				 * currently used for temporary addresses only.
				 */
	time_t	ia6_updatetime;

	/* multicast addresses joined from the kernel */
	LIST_HEAD(, in6_multi_mship) ia6_memberships;
};
#endif /* _KERNEL */

/*
 * IPv6 interface statistics, as defined in RFC2465 Ipv6IfStatsEntry (p12).
 */
struct in6_ifstat {
	u_int64_t ifs6_in_receive;	/* # of total input datagram */
	u_int64_t ifs6_in_hdrerr;	/* # of datagrams with invalid hdr */
	u_int64_t ifs6_in_toobig;	/* # of datagrams exceeded MTU */
	u_int64_t ifs6_in_noroute;	/* # of datagrams with no route */
	u_int64_t ifs6_in_addrerr;	/* # of datagrams with invalid dst */
	u_int64_t ifs6_in_protounknown;	/* # of datagrams with unknown proto */
					/* NOTE: increment on final dst if */
	u_int64_t ifs6_in_truncated;	/* # of truncated datagrams */
	u_int64_t ifs6_in_discard;	/* # of discarded datagrams */
					/* NOTE: fragment timeout is not here */
	u_int64_t ifs6_in_deliver;	/* # of datagrams delivered to ULP */
					/* NOTE: increment on final dst if */
	u_int64_t ifs6_out_forward;	/* # of datagrams forwarded */
					/* NOTE: increment on outgoing if */
	u_int64_t ifs6_out_request;	/* # of outgoing datagrams from ULP */
					/* NOTE: does not include forwrads */
	u_int64_t ifs6_out_discard;	/* # of discarded datagrams */
	u_int64_t ifs6_out_fragok;	/* # of datagrams fragmented */
	u_int64_t ifs6_out_fragfail;	/* # of datagrams failed on fragment */
	u_int64_t ifs6_out_fragcreat;	/* # of fragment datagrams */
					/* NOTE: this is # after fragment */
	u_int64_t ifs6_reass_reqd;	/* # of incoming fragmented packets */
					/* NOTE: increment on final dst if */
	u_int64_t ifs6_reass_ok;	/* # of reassembled packets */
					/* NOTE: this is # after reass */
					/* NOTE: increment on final dst if */
	u_int64_t ifs6_reass_fail;	/* # of reass failures */
					/* NOTE: may not be packet count */
					/* NOTE: increment on final dst if */
	u_int64_t ifs6_in_mcast;	/* # of inbound multicast datagrams */
	u_int64_t ifs6_out_mcast;	/* # of outbound multicast datagrams */
};

/*
 * ICMPv6 interface statistics, as defined in RFC2466 Ipv6IfIcmpEntry.
 * XXX: I'm not sure if this file is the right place for this structure...
 */
struct icmp6_ifstat {
	/*
	 * Input statistics
	 */
	/* ipv6IfIcmpInMsgs, total # of input messages */
	u_int64_t ifs6_in_msg;
	/* ipv6IfIcmpInErrors, # of input error messages */
	u_int64_t ifs6_in_error;
	/* ipv6IfIcmpInDestUnreachs, # of input dest unreach errors */
	u_int64_t ifs6_in_dstunreach;
	/* ipv6IfIcmpInAdminProhibs, # of input administratively prohibited errs */
	u_int64_t ifs6_in_adminprohib;
	/* ipv6IfIcmpInTimeExcds, # of input time exceeded errors */
	u_int64_t ifs6_in_timeexceed;
	/* ipv6IfIcmpInParmProblems, # of input parameter problem errors */
	u_int64_t ifs6_in_paramprob;
	/* ipv6IfIcmpInPktTooBigs, # of input packet too big errors */
	u_int64_t ifs6_in_pkttoobig;
	/* ipv6IfIcmpInEchos, # of input echo requests */
	u_int64_t ifs6_in_echo;
	/* ipv6IfIcmpInEchoReplies, # of input echo replies */
	u_int64_t ifs6_in_echoreply;
	/* ipv6IfIcmpInRouterSolicits, # of input router solicitations */
	u_int64_t ifs6_in_routersolicit;
	/* ipv6IfIcmpInRouterAdvertisements, # of input router advertisements */
	u_int64_t ifs6_in_routeradvert;
	/* ipv6IfIcmpInNeighborSolicits, # of input neighbor solicitations */
	u_int64_t ifs6_in_neighborsolicit;
	/* ipv6IfIcmpInNeighborAdvertisements, # of input neighbor advertisements */
	u_int64_t ifs6_in_neighboradvert;
	/* ipv6IfIcmpInRedirects, # of input redirects */
	u_int64_t ifs6_in_redirect;
	/* ipv6IfIcmpInGroupMembQueries, # of input MLD queries */
	u_int64_t ifs6_in_mldquery;
	/* ipv6IfIcmpInGroupMembResponses, # of input MLD reports */
	u_int64_t ifs6_in_mldreport;
	/* ipv6IfIcmpInGroupMembReductions, # of input MLD done */
	u_int64_t ifs6_in_mlddone;

	/*
	 * Output statistics. We should solve unresolved routing problem...
	 */
	/* ipv6IfIcmpOutMsgs, total # of output messages */
	u_int64_t ifs6_out_msg;
	/* ipv6IfIcmpOutErrors, # of output error messages */
	u_int64_t ifs6_out_error;
	/* ipv6IfIcmpOutDestUnreachs, # of output dest unreach errors */
	u_int64_t ifs6_out_dstunreach;
	/* ipv6IfIcmpOutAdminProhibs, # of output administratively prohibited errs */
	u_int64_t ifs6_out_adminprohib;
	/* ipv6IfIcmpOutTimeExcds, # of output time exceeded errors */
	u_int64_t ifs6_out_timeexceed;
	/* ipv6IfIcmpOutParmProblems, # of output parameter problem errors */
	u_int64_t ifs6_out_paramprob;
	/* ipv6IfIcmpOutPktTooBigs, # of output packet too big errors */
	u_int64_t ifs6_out_pkttoobig;
	/* ipv6IfIcmpOutEchos, # of output echo requests */
	u_int64_t ifs6_out_echo;
	/* ipv6IfIcmpOutEchoReplies, # of output echo replies */
	u_int64_t ifs6_out_echoreply;
	/* ipv6IfIcmpOutRouterSolicits, # of output router solicitations */
	u_int64_t ifs6_out_routersolicit;
	/* ipv6IfIcmpOutRouterAdvertisements, # of output router advertisements */
	u_int64_t ifs6_out_routeradvert;
	/* ipv6IfIcmpOutNeighborSolicits, # of output neighbor solicitations */
	u_int64_t ifs6_out_neighborsolicit;
	/* ipv6IfIcmpOutNeighborAdvertisements, # of output neighbor advertisements */
	u_int64_t ifs6_out_neighboradvert;
	/* ipv6IfIcmpOutRedirects, # of output redirects */
	u_int64_t ifs6_out_redirect;
	/* ipv6IfIcmpOutGroupMembQueries, # of output MLD queries */
	u_int64_t ifs6_out_mldquery;
	/* ipv6IfIcmpOutGroupMembResponses, # of output MLD reports */
	u_int64_t ifs6_out_mldreport;
	/* ipv6IfIcmpOutGroupMembReductions, # of output MLD done */
	u_int64_t ifs6_out_mlddone;
};

struct	in6_ifreq {
	char	ifr_name[IFNAMSIZ];
	union {
		struct	sockaddr_in6 ifru_addr;
		struct	sockaddr_in6 ifru_dstaddr;
		short	ifru_flags;
		int	ifru_flags6;
		int	ifru_metric;
		caddr_t	ifru_data;
		struct in6_addrlifetime ifru_lifetime;
		struct in6_ifstat ifru_stat;
		struct icmp6_ifstat ifru_icmp6stat;
	} ifr_ifru;
};

struct	in6_aliasreq {
	char	ifra_name[IFNAMSIZ];
	union {
		struct	sockaddr_in6 ifrau_addr;
		int	ifrau_align;
	 } ifra_ifrau;
#ifndef ifra_addr
#define ifra_addr	ifra_ifrau.ifrau_addr
#endif
	struct	sockaddr_in6 ifra_dstaddr;
	struct	sockaddr_in6 ifra_prefixmask;
	int	ifra_flags;
	struct in6_addrlifetime ifra_lifetime;
};

/*
 * Given a pointer to an in6_ifaddr (ifaddr),
 * return a pointer to the addr as a sockaddr_in6
 */
#define IA6_IN6(ia)	(&((ia)->ia_addr.sin6_addr))
#define IA6_DSTIN6(ia)	(&((ia)->ia_dstaddr.sin6_addr))
#define IA6_MASKIN6(ia)	(&((ia)->ia_prefixmask.sin6_addr))
#define IA6_SIN6(ia)	(&((ia)->ia_addr))
#define IA6_DSTSIN6(ia)	(&((ia)->ia_dstaddr))
#define IFA_IN6(x)	(&((struct sockaddr_in6 *)((x)->ifa_addr))->sin6_addr)
#define IFA_DSTIN6(x)	(&((struct sockaddr_in6 *)((x)->ifa_dstaddr))->sin6_addr)

#ifdef _KERNEL
#define IN6_ARE_MASKED_ADDR_EQUAL(d, a, m)	(	\
	(((d)->s6_addr32[0] ^ (a)->s6_addr32[0]) & (m)->s6_addr32[0]) == 0 && \
	(((d)->s6_addr32[1] ^ (a)->s6_addr32[1]) & (m)->s6_addr32[1]) == 0 && \
	(((d)->s6_addr32[2] ^ (a)->s6_addr32[2]) & (m)->s6_addr32[2]) == 0 && \
	(((d)->s6_addr32[3] ^ (a)->s6_addr32[3]) & (m)->s6_addr32[3]) == 0 )
#endif /* _KERNEL */

#define SIOCGIFADDR_IN6		_IOWR('i', 33, struct in6_ifreq)

#define SIOCGIFDSTADDR_IN6	_IOWR('i', 34, struct in6_ifreq)
#define SIOCGIFNETMASK_IN6	_IOWR('i', 37, struct in6_ifreq)

#define SIOCDIFADDR_IN6		 _IOW('i', 25, struct in6_ifreq)
#define SIOCAIFADDR_IN6		 _IOW('i', 26, struct in6_aliasreq)

#define SIOCSIFPHYADDR_IN6       _IOW('i', 70, struct in6_aliasreq)
#define	SIOCGIFPSRCADDR_IN6	_IOWR('i', 71, struct in6_ifreq)
#define	SIOCGIFPDSTADDR_IN6	_IOWR('i', 72, struct in6_ifreq)

#define SIOCGIFAFLAG_IN6	_IOWR('i', 73, struct in6_ifreq)

#define SIOCGIFINFO_IN6		_IOWR('i', 108, struct in6_ndireq)
#define SIOCSNDFLUSH_IN6	_IOWR('i', 77, struct in6_ifreq)
#define SIOCGNBRINFO_IN6	_IOWR('i', 78, struct in6_nbrinfo)
#define SIOCSPFXFLUSH_IN6	_IOWR('i', 79, struct in6_ifreq)
#define SIOCSRTRFLUSH_IN6	_IOWR('i', 80, struct in6_ifreq)

#define SIOCGIFALIFETIME_IN6	_IOWR('i', 81, struct in6_ifreq)
#define SIOCGIFSTAT_IN6		_IOWR('i', 83, struct in6_ifreq)
#define SIOCGIFSTAT_ICMP6	_IOWR('i', 84, struct in6_ifreq)

#define SIOCSIFINFO_FLAGS	_IOWR('i', 87, struct in6_ndireq) /* XXX */

#define SIOCGETSGCNT_IN6	_IOWR('u', 106, \
				      struct sioc_sg_req6) /* get s,g pkt cnt */
#define SIOCGETMIFCNT_IN6	_IOWR('u', 107, \
				      struct sioc_mif_req6) /* get pkt cnt per if */

#define IN6_IFF_ANYCAST		0x01	/* anycast address */
#define IN6_IFF_TENTATIVE	0x02	/* tentative address */
#define IN6_IFF_DUPLICATED	0x04	/* DAD detected duplicate */
#define IN6_IFF_DETACHED	0x08	/* may be detached from the link */
#define IN6_IFF_DEPRECATED	0x10	/* deprecated address */
#define IN6_IFF_AUTOCONF	0x40	/* autoconfigurable address. */
#define IN6_IFF_PRIVACY		0x80	/* RFC 4941 temporary address */

#ifdef _KERNEL
#define IN6_ARE_SCOPE_CMP(a,b) ((a)-(b))
#define IN6_ARE_SCOPE_EQUAL(a,b) ((a)==(b))

/*
 * Multi-cast membership entry.  One for each group/ifp that a PCB
 * belongs to.
 */
struct in6_multi_mship {
	struct	in6_multi *i6mm_maddr;	/* Multicast address pointer */
	LIST_ENTRY(in6_multi_mship) i6mm_chain;  /* multicast options chain */
};

struct in6_multi {
	struct ifmaddr		in6m_ifma;   /* Protocol-independent info */
#define in6m_refcnt		in6m_ifma.ifma_refcnt
#define in6m_ifidx		in6m_ifma.ifma_ifidx

	struct sockaddr_in6	in6m_sin;   /* IPv6 multicast address */
#define in6m_addr		in6m_sin.sin6_addr

	u_int			in6m_state; /* state of membership */
	u_int			in6m_timer; /* MLD6 membership report timer */
};

static __inline struct in6_multi *
ifmatoin6m(struct ifmaddr *ifma)
{
       return ((struct in6_multi *)(ifma));
}

/*
 * Macros for looking up the in6_multi record for a given IP6 multicast
 * address on a given interface. If no matching record is found, "in6m"
 * returns NULL.
 */
#define IN6_LOOKUP_MULTI(addr, ifp, in6m)				\
	/* struct in6_addr addr; */					\
	/* struct ifnet *ifp; */					\
	/* struct in6_multi *in6m; */					\
do {									\
	struct ifmaddr *ifma;						\
									\
	(in6m) = NULL;							\
	TAILQ_FOREACH(ifma, &(ifp)->if_maddrlist, ifma_list)		\
		if (ifma->ifma_addr->sa_family == AF_INET6 &&		\
		    IN6_ARE_ADDR_EQUAL(&ifmatoin6m(ifma)->in6m_addr,	\
				       &(addr))) {			\
			(in6m) = ifmatoin6m(ifma);			\
			break;						\
		}							\
} while (/* CONSTCOND */ 0)

struct	in6_multi *in6_addmulti(struct in6_addr *, struct ifnet *, int *);
void	in6_delmulti(struct in6_multi *);
int	in6_hasmulti(struct in6_addr *, struct ifnet *);
struct in6_multi_mship *in6_joingroup(struct ifnet *, struct in6_addr *, int *);
int	in6_leavegroup(struct in6_multi_mship *);
int	in6_control(struct socket *, u_long, caddr_t, struct ifnet *);
int	in6_ioctl(u_long, caddr_t, struct ifnet *, int);
int	in6_update_ifa(struct ifnet *, struct in6_aliasreq *,
	struct in6_ifaddr *);
void	in6_purgeaddr(struct ifaddr *);
int	in6if_do_dad(struct ifnet *);
void	*in6_domifattach(struct ifnet *);
void	in6_domifdetach(struct ifnet *, void *);
struct in6_ifaddr *in6ifa_ifpforlinklocal(struct ifnet *, int);
struct in6_ifaddr *in6ifa_ifpwithaddr(struct ifnet *, struct in6_addr *);
int	in6_addr2scopeid(unsigned int, struct in6_addr *);
int	in6_matchlen(struct in6_addr *, struct in6_addr *);
int	in6_are_prefix_equal(struct in6_addr *, struct in6_addr *, int);
void	in6_prefixlen2mask(struct in6_addr *, int);
void	in6_purgeprefix(struct ifnet *);
#endif /* _KERNEL */

#endif /* _NETINET6_IN6_VAR_H_ */
@


1.66
log
@Kill global list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.65 2017/02/09 15:23:35 jca Exp $	*/
a113 3

	/* back pointer to the prefix (for autoconf) */
	struct nd_prefix *ia6_ndpr;
@


1.65
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.64 2016/07/05 10:17:14 mpi Exp $	*/
a333 3

TAILQ_HEAD(in6_ifaddrhead, in6_ifaddr);
extern struct in6_ifaddrhead in6_ifaddr;
@


1.64
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.63 2016/06/13 10:34:40 mpi Exp $	*/
a336 1
extern struct icmp6stat icmp6stat;
@


1.63
log
@Move the ioctl(2) logic of in{,6}_control() into two new functions
in{,6}_ioctl() that do not deal with sockets.

This will allow to automagically configure interface addresses in
the kernel without too many layer violations.

Required by upcoming umb(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.62 2016/03/03 12:57:15 jca Exp $	*/
a329 3

/* do not input/output */
#define IN6_IFF_NOTREADY (IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED)
@


1.62
log
@Kill IPv6 prefix and router renumbering ioctls.

Router renumbering was never supported, prefix ioctls were deprecated
~15 years ago.  Move some items in netinet6/nd6.h where they are still
used.

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.60 2016/02/28 07:15:34 stefan Exp $	*/
d397 1
@


1.61
log
@Delete all traces of SIOCSIF(ADDR|DSTADDR|NETMASK)_IN6

Those ioctls never made sense, IPv6 was designed right from the start
with support for multiple addresses by interface.

ok mikeb@@ mpi@@
@
text
@a271 85
/* prefix type macro */
#define IN6_PREFIX_ND	1
#define IN6_PREFIX_RR	2

/*
 * prefix related flags passed between kernel(NDP related part) and
 * userland command(ifconfig) and daemon(rtadvd).
 */
struct prf_ra {
	u_int onlink : 1;
	u_int autonomous : 1;
	u_int router : 1;
	u_int reserved : 5;
};

struct in6_prflags {
	struct prf_ra prf_ra;
	u_char prf_reserved1;
	u_short prf_reserved2;
	/* want to put this on 4byte offset */
	struct prf_rr {
		u_int decrvalid : 1;
		u_int decrprefd : 1;
		u_int reserved : 6;
	} prf_rr;
	u_char prf_reserved3;
	u_short prf_reserved4;
};

struct  in6_prefixreq {
	char	ipr_name[IFNAMSIZ];
	u_char	ipr_origin;
	u_char	ipr_plen;
	u_int32_t ipr_vltime;
	u_int32_t ipr_pltime;
	struct in6_prflags ipr_flags;
	struct	sockaddr_in6 ipr_prefix;
};

#define PR_ORIG_RA	0
#define PR_ORIG_RR	1
#define PR_ORIG_STATIC	2
#define PR_ORIG_KERNEL	3

#define ipr_raf_onlink		ipr_flags.prf_ra.onlink
#define ipr_raf_auto		ipr_flags.prf_ra.autonomous

#define ipr_statef_onlink	ipr_flags.prf_state.onlink

#define ipr_rrf_decrvalid	ipr_flags.prf_rr.decrvalid
#define ipr_rrf_decrprefd	ipr_flags.prf_rr.decrprefd

struct	in6_rrenumreq {
	char	irr_name[IFNAMSIZ];
	u_char	irr_origin;
	u_char	irr_m_len;	/* match len for matchprefix */
	u_char	irr_m_minlen;	/* minlen for matching prefix */
	u_char	irr_m_maxlen;	/* maxlen for matching prefix */
	u_char	irr_u_uselen;	/* uselen for adding prefix */
	u_char	irr_u_keeplen;	/* keeplen from matching prefix */
	struct irr_raflagmask {
		u_int onlink : 1;
		u_int autonomous : 1;
		u_int reserved : 6;
	} irr_raflagmask;
	u_int32_t irr_vltime;
	u_int32_t irr_pltime;
	struct in6_prflags irr_flags;
	struct	sockaddr_in6 irr_matchprefix;
	struct	sockaddr_in6 irr_useprefix;
};

#define irr_raf_mask_onlink	irr_raflagmask.onlink
#define irr_raf_mask_auto	irr_raflagmask.autonomous
#define irr_raf_mask_reserved	irr_raflagmask.reserved

#define irr_raf_onlink		irr_flags.prf_ra.onlink
#define irr_raf_auto		irr_flags.prf_ra.autonomous

#define irr_statef_onlink	irr_flags.prf_state.onlink

#define irr_rrf			irr_flags.prf_rr
#define irr_rrf_decrvalid	irr_flags.prf_rr.decrvalid
#define irr_rrf_decrprefd	irr_flags.prf_rr.decrprefd

a316 9

#define SIOCSIFPREFIX_IN6	_IOW('i', 100, struct in6_prefixreq) /* set */
#define SIOCGIFPREFIX_IN6	_IOWR('i', 101, struct in6_prefixreq) /* get */
#define SIOCDIFPREFIX_IN6	_IOW('i', 102, struct in6_prefixreq) /* del */
#define SIOCAIFPREFIX_IN6	_IOW('i', 103, struct in6_rrenumreq) /* add */
#define SIOCCIFPREFIX_IN6	_IOW('i', 104, \
				     struct in6_rrenumreq) /* change */
#define SIOCSGIFPREFIX_IN6	_IOW('i', 105, \
				     struct in6_rrenumreq) /* set global */
@


1.60
log
@Remove SIOCSIFALIFETIME_IN6 ioctl, as NetBSD did.

As described in NetBSD kern/35897 PR, the parameters
this ioctl needs overlay each other in a union. The ioctl
cannot have worked properly.

Discovered while discussing overflow checks with mmcc@@ and mpi@@
The checks were part of the removed code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.59 2016/01/21 11:23:48 mpi Exp $	*/
a376 1
#define SIOCSIFADDR_IN6		 _IOW('i', 12, struct in6_ifreq)
a377 9

#ifdef _KERNEL
/*
 * SIOCSxxx ioctls should be unused (see comments in in6.c), but
 * we do not shift numbers for binary compatibility.
 */
#define SIOCSIFDSTADDR_IN6	 _IOW('i', 14, struct in6_ifreq)
#define SIOCSIFNETMASK_IN6	 _IOW('i', 22, struct in6_ifreq)
#endif /* _KERNEL */
@


1.59
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.58 2015/11/18 13:58:02 mpi Exp $	*/
a407 1
#define SIOCSIFALIFETIME_IN6	_IOWR('i', 82, struct in6_ifreq)
@


1.58
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.57 2015/10/05 01:22:34 deraadt Exp $	*/
d498 1
@


1.57
log
@user land -> userland; from Rob Pierce
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.56 2015/09/10 16:39:39 mpi Exp $	*/
a508 1
int	in6_ifpprefix(const struct ifnet *, const struct in6_addr *);
@


1.56
log
@Kill in6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_IN6 is no longer supported.

ok mikeb@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.55 2015/09/09 15:51:40 mpi Exp $	*/
d278 1
a278 1
 * user land command(ifconfig) and daemon(rtadvd).
@


1.55
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.54 2015/09/01 17:21:36 mpi Exp $	*/
a91 1
	struct in6_ifstat *in6_ifstat;
a444 1

a445 5
#define in6_ifstat_inc(ifp, tag) \
do {								\
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->in6_ifstat->tag++; \
} while (0)
@


1.54
log
@Kill unused ``ia_net'' field in the struct in6_ifaddr, bad copy
paste from the IPv4 time.

While here update the comment about ``ia6_ndpr'' it's now only
used for autoconf.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.53 2015/08/24 15:58:35 mpi Exp $	*/
a92 1
	struct icmp6_ifstat *icmp6_ifstat;
@


1.53
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.52 2015/07/08 08:48:34 mpi Exp $	*/
a105 1
	struct	sockaddr_in6 ia_net;	/* network number of interface */
d117 1
a117 1
	/* back pointer to the prefix (for all addresses, not just autoconf) */
@


1.52
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.51 2014/11/20 09:55:57 mpi Exp $	*/
a435 3
#define IN6_IFF_NODAD		0x20	/* don't perform DAD on this address
					 * (used only at first SIOC* call)
					 */
@


1.51
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.50 2014/08/25 14:00:34 florian Exp $	*/
d522 1
a522 1
int	in6_addr2scopeid(struct ifnet *, struct in6_addr *);
@


1.50
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.49 2014/04/03 08:22:10 mpi Exp $	*/
a516 1
void	in6_setmaxmtu(void);
@


1.49
log
@Introduce rt_ifa_{add,del}loop() to replace in6_{add,rem}loop().

Move these functions to a more generic place and make them reuse
existing code, they'll be soon used in IPv4 too.

Tested by André Lucas, Vigdis and sthen@@, thanks!

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.48 2014/03/27 10:39:23 mpi Exp $	*/
d95 1
@


1.48
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.47 2014/01/21 10:18:26 mpi Exp $	*/
a526 2
void	in6_ifaddloop(struct ifaddr *);
void	in6_ifremloop(struct ifaddr *);
@


1.47
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.46 2013/11/28 10:16:44 mpi Exp $	*/
d102 1
a102 1
#define ia_flags	ia_ifa.ifa_flags
@


1.46
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.45 2013/11/22 07:59:09 mpi Exp $	*/
d470 1
a470 1
#define in6m_ifp		in6m_ifma.ifma_ifp
@


1.45
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.44 2013/10/24 11:31:43 mpi Exp $	*/
a108 2
	LIST_HEAD(in6_multihead, in6_multi) ia6_multiaddrs;
					/* list of multicast addresses */
a458 18
 * Macro for finding the internet address structure (in6_ifaddr) corresponding
 * to a given interface (ifnet structure).
 */
#define IFP_TO_IA6(ifp, ia)				\
/* struct ifnet *ifp; */				\
/* struct in6_ifaddr *ia; */				\
do {									\
	struct ifaddr *ifa;						\
	TAILQ_FOREACH(ifa, &(ifp)->if_addrlist, ifa_list) {		\
		if (!ifa->ifa_addr)					\
			continue;					\
		if (ifa->ifa_addr->sa_family == AF_INET6)		\
			break;						\
	}								\
	(ia) = (struct in6_ifaddr *)ifa;				\
} while (0)

/*
d467 17
a483 21
struct	in6_multi {
	LIST_ENTRY(in6_multi) in6m_entry; /* list glue */
	struct	in6_addr in6m_addr;	/* IP6 multicast address */
	struct	ifnet *in6m_ifp;	/* back pointer to ifnet */
	struct	in6_ifaddr *in6m_ia;	/* back pointer to in6_ifaddr */
	u_int	in6m_refcount;		/* # membership claims by sockets */
	u_int	in6m_state;		/* state of the membership */
	u_int	in6m_timer;		/* MLD6 listener report timer */
};

/*
 * Macro for iterating over all the in6_multi records linked to a given
 * interface.
 */
#define IN6_FOREACH_MULTI(ia, ifp, in6m)				\
	/* struct in6_ifaddr *ia; */					\
	/* struct ifnet *ifp; */					\
	/* struct in6_multi *in6m; */					\
	IFP_TO_IA6((ifp), ia);						\
	if (ia != NULL)							\
		LIST_FOREACH((in6m), &ia->ia6_multiaddrs, in6m_entry)	\
d495 1
a495 1
	struct in6_ifaddr *ia;						\
d498 5
a502 2
	IN6_FOREACH_MULTI(ia, ifp, in6m)				\
		if (IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr, &(addr)))	\
d504 1
a515 1
void	in6_savemkludge(struct in6_ifaddr *);
a518 3
void	in6_restoremkludge(struct in6_ifaddr *, struct ifnet *);
void	in6_createmkludge(struct ifnet *);
void	in6_purgemkludge(struct ifnet *);
@


1.44
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.43 2013/10/24 11:20:18 deraadt Exp $	*/
d531 1
a531 2
int	in6_control(struct socket *, u_long, caddr_t, struct ifnet *,
	struct proc *);
@


1.43
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.42 2013/10/14 11:07:42 mpi Exp $	*/
a459 5
extern struct ifqueue ip6intrq;		/* IP6 packet input queue */
extern struct in6_addr zeroin6_addr;
extern u_char inet6ctlerrmap[];
extern unsigned long in6_maxmtu;

a546 1
char	*ip6_sprintf(struct in6_addr *);
a553 7

struct inpcb;
int in6_embedscope(struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **);
int in6_recoverscope(struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *);
void in6_clearscope(struct in6_addr *);
@


1.42
log
@Change the macros used to iterate over the multicast records of an
interface to not depend on the global list of addresses.

For IPv4 the IP_TO_IA() macro still depends on the global list of
addresses because we want to be sure to grab the first configured
address of an interface, where the records are linked.

Tested by sthen@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.41 2013/08/26 07:15:58 bluhm Exp $	*/
d89 1
d125 1
d379 1
a379 1
#endif
d391 1
a391 1
#endif
a448 1
#endif
a449 1
#ifdef _KERNEL
a481 1
#endif /* _KERNEL */
a501 1
#ifdef _KERNEL
@


1.41
log
@No one uses the obsolete IPv6 ioctls SIOCGDRLST_IN6, SIOCGPRLST_IN6,
OSIOCGIFINFO_IN6 anymore.  Remove them together with the structs
in6_drlist, in6_oprlist, in6_prlist, in6_ondireq and the kernel
implementation.
OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.40 2013/06/17 18:02:24 bluhm Exp $	*/
d505 2
a506 2
 * Structure used by macros below to remember position when stepping through
 * all of the in6_multi records.
d508 7
a514 4
struct	in6_multistep {
	struct	in6_ifaddr *i_ia;
	struct	in6_multi *i_in6m;
};
d519 1
a519 1
 * returns NLL.
d521 4
a524 29

#define IN6_LOOKUP_MULTI(addr, ifp, in6m)			\
/* struct in6_addr addr; */					\
/* struct ifnet *ifp; */					\
/* struct in6_multi *in6m; */					\
do {								\
	struct in6_ifaddr *ia;					\
								\
	IFP_TO_IA6((ifp), ia);					\
	if (ia == NULL)						\
	  	(in6m) = NULL;					\
	else							\
		for ((in6m) = LIST_FIRST(&ia->ia6_multiaddrs);	\
		     (in6m) != NULL &&	\
		     !IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr, &(addr));	\
		     (in6m) = LIST_NEXT((in6m), in6m_entry))	\
			continue;				\
} while (0)

/*
 * Macro to step through all of the in6_multi records, one at a time.
 * The current position is remembered in "step", which the caller must
 * provide.  IN6_FIRST_MULTI(), below, must be called to initialize "step"
 * and get the first record.  Both macros return a NULL "in6m" when there
 * are no remaining records.
 */
#define IN6_NEXT_MULTI(step, in6m)					\
/* struct in6_multistep step; */					\
/* struct in6_multi *in6m; */						\
d526 7
a532 21
	if (((in6m) = (step).i_in6m) != NULL)				\
		(step).i_in6m = LIST_NEXT((in6m), in6m_entry);		\
	else								\
		while ((step).i_ia != NULL) {				\
			(in6m) = LIST_FIRST(&(step).i_ia->ia6_multiaddrs); \
			(step).i_ia = TAILQ_NEXT((step).i_ia, ia_list);	\
			if ((in6m) != NULL) {				\
				(step).i_in6m = LIST_NEXT((in6m), in6m_entry); \
				break;					\
			}						\
		}							\
} while (0)

#define IN6_FIRST_MULTI(step, in6m)		\
/* struct in6_multistep step; */		\
/* struct in6_multi *in6m */			\
do {						\
	(step).i_ia = TAILQ_FIRST(&in6_ifaddr);	\
	(step).i_in6m = NULL;			\
	IN6_NEXT_MULTI((step), (in6m));		\
} while (0)
@


1.40
log
@Remove unused field ia_plen from struct in6_ifaddr.  The prefix
length is always calculated on demand from ia_prefixmask.
OK claudio@@ mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.39 2013/03/25 14:40:57 mpi Exp $	*/
a402 5
#define SIOCGDRLST_IN6		_IOWR('i', 74, struct in6_drlist)
#define SIOCGPRLST_IN6		_IOWR('i', 75, struct in6_prlist)
#ifdef _KERNEL
#define OSIOCGIFINFO_IN6	_IOWR('i', 76, struct in6_ondireq)
#endif
@


1.39
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.38 2013/03/22 01:41:12 tedu Exp $	*/
a106 1
	u_int32_t ia_plen;		/* prefix length */
@


1.38
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.37 2013/03/11 14:08:04 mpi Exp $	*/
d102 1
d108 1
a108 1
	struct	in6_ifaddr *ia_next;	/* next in6 list of IP6 addresses */
d456 2
a457 1
extern struct in6_ifaddr *in6_ifaddr;
d559 1
a559 1
			(step).i_ia = (step).i_ia->ia_next;		\
d571 1
a571 1
	(step).i_ia = in6_ifaddr;		\
@


1.37
log
@Remove unused code manipulating a default interface and its index,
This is a leftover from the on-link assumption behavior removal,
which has been deprecated by RFC4861 anyway.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.36 2013/03/04 14:23:35 bluhm Exp $	*/
d535 1
a535 1
		     (in6m) != LIST_END(&ia->ia6_multiaddrs) &&	\
@


1.36
log
@When deleting an IPv6 interface address, also remove the prefix and
the cloning route.
bug report and test Florian Riehm; original fix sperreault@@; OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.35 2012/11/11 04:45:44 deraadt Exp $	*/
a417 3

#define SIOCSDEFIFACE_IN6	_IOWR('i', 85, struct in6_ndifreq)
#define SIOCGDEFIFACE_IN6	_IOWR('i', 86, struct in6_ndifreq)
@


1.35
log
@align ifaliasreq.ifra_addr similar to the way that ifreq is fixed --
a gruesome union, to block the compiler from placing the struct
incorrectly aligned on stack frames
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.34 2011/10/13 18:23:40 claudio Exp $	*/
d118 1
a118 1
	/* back pointer to the ND prefix (for autoconfigured addresses only) */
@


1.34
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.33 2011/07/26 21:19:51 bluhm Exp $	*/
d261 7
a267 1
	struct	sockaddr_in6 ifra_addr;
@


1.33
log
@Accept neighbor discovery packets from source IPv6 addresses for
which we have a cloning or cloned route.  The old check was based
on configured interface addresses, now we use a route lookup.  This
allows us to use prefixes for the local network that ospf6d has
added.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.32 2010/07/08 19:42:46 jsg Exp $	*/
a574 1
int	in6_mask2len(struct in6_addr *, u_char *);
@


1.32
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.31 2010/04/06 14:12:10 stsp Exp $	*/
d591 1
a591 2
struct in6_ifaddr *in6ifa_ifplocaladdr(const struct ifnet *,
	    const struct in6_addr *);
@


1.31
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.30 2008/10/01 21:17:06 claudio Exp $	*/
a581 1
void	in6_purgeif(struct ifnet *);
a601 1
int	in6_is_addr_deprecated(struct sockaddr_in6 *);
@


1.30
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
From NetBSD, tested by todd@@ and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.29 2008/06/11 06:30:36 mcbride Exp $	*/
d441 1
@


1.29
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.28 2006/07/06 02:56:58 brad Exp $	*/
d591 2
@


1.29.2.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.29 2008/06/11 06:30:36 mcbride Exp $	*/
a590 2
struct in6_ifaddr *in6ifa_ifplocaladdr(const struct ifnet *,
	    const struct in6_addr *);
@


1.28
log
@u_quad_t -> u_int64_t

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.27 2006/03/05 21:48:57 miod Exp $	*/
d94 2
@


1.28.8.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.28 2006/07/06 02:56:58 brad Exp $	*/
a588 2
struct in6_ifaddr *in6ifa_ifplocaladdr(const struct ifnet *,
	    const struct in6_addr *);
@


1.28.6.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.28 2006/07/06 02:56:58 brad Exp $	*/
a588 2
struct in6_ifaddr *in6ifa_ifplocaladdr(const struct ifnet *,
	    const struct in6_addr *);
@


1.27
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.26 2005/12/11 17:21:53 deraadt Exp $	*/
d127 6
a132 6
	u_quad_t ifs6_in_receive;	/* # of total input datagram */
	u_quad_t ifs6_in_hdrerr;	/* # of datagrams with invalid hdr */
	u_quad_t ifs6_in_toobig;	/* # of datagrams exceeded MTU */
	u_quad_t ifs6_in_noroute;	/* # of datagrams with no route */
	u_quad_t ifs6_in_addrerr;	/* # of datagrams with invalid dst */
	u_quad_t ifs6_in_protounknown;	/* # of datagrams with unknown proto */
d134 2
a135 2
	u_quad_t ifs6_in_truncated;	/* # of truncated datagrams */
	u_quad_t ifs6_in_discard;	/* # of discarded datagrams */
d137 1
a137 1
	u_quad_t ifs6_in_deliver;	/* # of datagrams delivered to ULP */
d139 1
a139 1
	u_quad_t ifs6_out_forward;	/* # of datagrams forwarded */
d141 1
a141 1
	u_quad_t ifs6_out_request;	/* # of outgoing datagrams from ULP */
d143 4
a146 4
	u_quad_t ifs6_out_discard;	/* # of discarded datagrams */
	u_quad_t ifs6_out_fragok;	/* # of datagrams fragmented */
	u_quad_t ifs6_out_fragfail;	/* # of datagrams failed on fragment */
	u_quad_t ifs6_out_fragcreat;	/* # of fragment datagrams */
d148 1
a148 1
	u_quad_t ifs6_reass_reqd;	/* # of incoming fragmented packets */
d150 1
a150 1
	u_quad_t ifs6_reass_ok;		/* # of reassembled packets */
d153 1
a153 1
	u_quad_t ifs6_reass_fail;	/* # of reass failures */
d156 2
a157 2
	u_quad_t ifs6_in_mcast;		/* # of inbound multicast datagrams */
	u_quad_t ifs6_out_mcast;	/* # of outbound multicast datagrams */
d169 1
a169 1
	u_quad_t ifs6_in_msg;
d171 1
a171 1
	u_quad_t ifs6_in_error;
d173 1
a173 1
	u_quad_t ifs6_in_dstunreach;
d175 1
a175 1
	u_quad_t ifs6_in_adminprohib;
d177 1
a177 1
	u_quad_t ifs6_in_timeexceed;
d179 1
a179 1
	u_quad_t ifs6_in_paramprob;
d181 1
a181 1
	u_quad_t ifs6_in_pkttoobig;
d183 1
a183 1
	u_quad_t ifs6_in_echo;
d185 1
a185 1
	u_quad_t ifs6_in_echoreply;
d187 1
a187 1
	u_quad_t ifs6_in_routersolicit;
d189 1
a189 1
	u_quad_t ifs6_in_routeradvert;
d191 1
a191 1
	u_quad_t ifs6_in_neighborsolicit;
d193 1
a193 1
	u_quad_t ifs6_in_neighboradvert;
d195 1
a195 1
	u_quad_t ifs6_in_redirect;
d197 1
a197 1
	u_quad_t ifs6_in_mldquery;
d199 1
a199 1
	u_quad_t ifs6_in_mldreport;
d201 1
a201 1
	u_quad_t ifs6_in_mlddone;
d207 1
a207 1
	u_quad_t ifs6_out_msg;
d209 1
a209 1
	u_quad_t ifs6_out_error;
d211 1
a211 1
	u_quad_t ifs6_out_dstunreach;
d213 1
a213 1
	u_quad_t ifs6_out_adminprohib;
d215 1
a215 1
	u_quad_t ifs6_out_timeexceed;
d217 1
a217 1
	u_quad_t ifs6_out_paramprob;
d219 1
a219 1
	u_quad_t ifs6_out_pkttoobig;
d221 1
a221 1
	u_quad_t ifs6_out_echo;
d223 1
a223 1
	u_quad_t ifs6_out_echoreply;
d225 1
a225 1
	u_quad_t ifs6_out_routersolicit;
d227 1
a227 1
	u_quad_t ifs6_out_routeradvert;
d229 1
a229 1
	u_quad_t ifs6_out_neighborsolicit;
d231 1
a231 1
	u_quad_t ifs6_out_neighboradvert;
d233 1
a233 1
	u_quad_t ifs6_out_redirect;
d235 1
a235 1
	u_quad_t ifs6_out_mldquery;
d237 1
a237 1
	u_quad_t ifs6_out_mldreport;
d239 1
a239 1
	u_quad_t ifs6_out_mlddone;
@


1.26
log
@bitfields must be off an int or such type
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.25 2005/09/19 19:36:49 brad Exp $	*/
d472 1
a472 1
	for (ifa = (ifp)->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next) {	\
d528 2
a529 2
		for ((in6m) = ia->ia6_multiaddrs.lh_first;	\
		     (in6m) != NULL &&				\
d531 1
a531 1
		     (in6m) = (in6m)->in6m_entry.le_next)	\
d547 1
a547 1
		(step).i_in6m = (in6m)->in6m_entry.le_next;		\
d550 1
a550 1
			(in6m) = (step).i_ia->ia6_multiaddrs.lh_first;	\
d553 1
a553 1
				(step).i_in6m = (in6m)->in6m_entry.le_next; \
@


1.25
log
@remove the unused in6_ifindex2scopeid()
if at all, it works with site-local addresses whose fate is uncertain
to say the least

From drochner NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.24 2004/06/16 02:38:23 itojun Exp $	*/
d275 4
a278 4
	u_char onlink : 1;
	u_char autonomous : 1;
	u_char router : 1;
	u_char reserved : 5;
d287 3
a289 3
		u_char decrvalid : 1;
		u_char decrprefd : 1;
		u_char reserved : 6;
d327 3
a329 3
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char reserved : 6;
@


1.24
log
@missing paren in macro def.  Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.23 2004/01/13 06:28:16 mcbride Exp $	*/
a571 1
int	in6_ifindex2scopeid(int);
@


1.23
log
@Expose in6_ifremloop() and in6_ifaddloop() so that they can be used by carp.

ok henning@@ millert@@ itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.22 2003/10/15 23:35:42 itojun Exp $	*/
d531 1
a531 1
		     (in6m) = in6m->in6m_entry.le_next)		\
@


1.22
log
@c++ friendly, sync w/kame.  pvalchev ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.21 2003/06/02 23:28:15 millert Exp $	*/
d596 2
@


1.21
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.20 2002/06/08 21:22:02 itojun Exp $	*/
d274 7
d282 1
a282 6
	struct prf_ra {
		u_char onlink : 1;
		u_char autonomous : 1;
		u_char router : 1;
		u_char reserved : 5;
	} prf_ra;
@


1.20
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.19 2002/06/08 00:06:58 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.19
log
@in6_len2mask is a duplicate of in6_prefixlen2mask.  unify.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.18 2002/06/07 15:00:55 itojun Exp $	*/
d83 1
a83 1
 *	kernel -> userland: throuw up everything
d114 11
a124 2
	struct in6_addrlifetime ia6_lifetime;	/* NULL = infty */
	struct ifprefix *ia6_ifpr; /* back pointer to ifprefix */
d282 2
a283 1
		u_char reserved : 6;
a364 2
#define IFPR_IN6(x)	(&((struct sockaddr_in6 *)((x)->ifpr_prefix))->sin6_addr)

d437 4
d506 1
a506 1
 * all of eht in6_multi records.
a569 2
int	in6_ifinit(struct ifnet *, struct in6_ifaddr *, struct sockaddr_in6 *,
	int);
a573 1
void	in6_ifscrub(struct ifnet *, struct in6_ifaddr *);
d575 1
a575 1
int	in6_mask2len(struct in6_addr *);
d578 3
a580 1
void	in6_purgeaddr(struct ifaddr *, struct ifnet *);
d582 1
a596 3
int	in6_prefix_ioctl(struct socket *, u_long, caddr_t, struct ifnet *);
int	in6_prefix_add_ifid(int, struct in6_ifaddr *);
void	in6_prefix_remove_ifid(int, struct in6_ifaddr *);
d599 1
@


1.18
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.17 2002/05/29 07:54:59 itojun Exp $	*/
a566 1
void	in6_len2mask(struct in6_addr *, int);
@


1.17
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.16 2002/05/29 02:59:12 itojun Exp $	*/
d558 3
a560 4
int	in6_ifinit(struct ifnet *,
			struct in6_ifaddr *, struct sockaddr_in6 *, int);
struct	in6_multi *in6_addmulti(struct in6_addr *, struct ifnet *,
				     int *);
d562 2
d565 5
a569 5
extern int in6_ifindex2scopeid(int);
extern int in6_mask2len(struct in6_addr *);
extern void in6_len2mask(struct in6_addr *, int);
int	in6_control(struct socket *,
			 u_long, caddr_t, struct ifnet *, struct proc *);
d580 1
a580 2
struct in6_ifaddr *in6ifa_ifpwithaddr(struct ifnet *,
					     struct in6_addr *);
d584 5
a588 7
int	in6_are_prefix_equal(struct in6_addr *p1, struct in6_addr *p2,
				  int len);
void	in6_prefixlen2mask(struct in6_addr *maskp, int len);
int	in6_prefix_ioctl(struct socket *so, u_long cmd, caddr_t data,
			      struct ifnet *ifp);
int	in6_prefix_add_ifid(int iilen, struct in6_ifaddr *ia);
void	in6_prefix_remove_ifid(int iilen, struct in6_ifaddr *ia);
@


1.16
log
@move per-interface ip6/icmp6 stat to ifnet->if_afdata.   sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.15 2002/05/23 06:56:16 itojun Exp $	*/
a92 1
#if 0
a93 1
#endif
a96 1
#if 0
a97 1
#endif
d391 4
a394 1
#define SIOCGIFINFO_IN6		_IOWR('i', 76, struct in6_ndireq)
a440 2
extern struct in6_ifstat **in6_ifstat;
extern size_t in6_ifstatmax;
a441 2
extern struct icmp6_ifstat **icmp6_ifstat;
extern size_t icmp6_ifstatmax;
@


1.15
log
@simplify condition to perform DAD.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.14 2002/03/14 01:27:12 millert Exp $	*/
d93 11
d449 2
a450 5
	if ((ifp) && (ifp)->if_index <= if_index		\
	 && (ifp)->if_index < in6_ifstatmax			\
	 && in6_ifstat && in6_ifstat[(ifp)->if_index]) {	\
		in6_ifstat[(ifp)->if_index]->tag++;		\
	}							\
d578 2
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.13 2001/07/18 12:50:44 itojun Exp $	*/
d567 1
@


1.13
log
@avoid using malloc() during interupt context for multicast kludge entry.
allocate it on interface initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.12 2001/02/16 14:45:12 itojun Exp $	*/
d555 31
a585 31
int	in6_ifinit __P((struct ifnet *,
			struct in6_ifaddr *, struct sockaddr_in6 *, int));
struct	in6_multi *in6_addmulti __P((struct in6_addr *, struct ifnet *,
				     int *));
void	in6_delmulti __P((struct in6_multi *));
void	in6_ifscrub __P((struct ifnet *, struct in6_ifaddr *));
extern int in6_ifindex2scopeid __P((int));
extern int in6_mask2len __P((struct in6_addr *));
extern void in6_len2mask __P((struct in6_addr *, int));
int	in6_control __P((struct socket *,
			 u_long, caddr_t, struct ifnet *, struct proc *));
void	in6_purgeaddr __P((struct ifaddr *, struct ifnet *));
void	in6_savemkludge __P((struct in6_ifaddr *));
void	in6_setmaxmtu   __P((void));
void	in6_restoremkludge __P((struct in6_ifaddr *, struct ifnet *));
void	in6_createmkludge __P((struct ifnet *));
void	in6_purgemkludge __P((struct ifnet *));
struct in6_ifaddr *in6ifa_ifpforlinklocal __P((struct ifnet *, int));
struct in6_ifaddr *in6ifa_ifpwithaddr __P((struct ifnet *,
					     struct in6_addr *));
char	*ip6_sprintf __P((struct in6_addr *));
int	in6_addr2scopeid __P((struct ifnet *, struct in6_addr *));
int	in6_matchlen __P((struct in6_addr *, struct in6_addr *));
int	in6_are_prefix_equal __P((struct in6_addr *p1, struct in6_addr *p2,
				  int len));
void	in6_prefixlen2mask __P((struct in6_addr *maskp, int len));
int	in6_prefix_ioctl __P((struct socket *so, u_long cmd, caddr_t data,
			      struct ifnet *ifp));
int	in6_prefix_add_ifid __P((int iilen, struct in6_ifaddr *ia));
void	in6_prefix_remove_ifid __P((int iilen, struct in6_ifaddr *ia));
void	in6_purgeprefix __P((struct ifnet *));
d588 5
a592 5
int in6_embedscope __P((struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **));
int in6_recoverscope __P((struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *));
void in6_clearscope __P((struct in6_addr *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.13 2001/07/18 12:50:44 itojun Exp $	*/
d83 1
a83 1
 *	kernel -> userland: throw up everything
a92 7
struct nd_ifinfo;
struct in6_ifextra {
	struct in6_ifstat *in6_ifstat;
	struct icmp6_ifstat *icmp6_ifstat;
	struct nd_ifinfo *nd_ifinfo;
};

d107 2
a108 11
	struct in6_addrlifetime ia6_lifetime;
	time_t	ia6_createtime; /* the creation time of this address, which is
				 * currently used for temporary addresses only.
				 */
	time_t	ia6_updatetime;

	/* back pointer to the ND prefix (for autoconfigured addresses only) */
	struct nd_prefix *ia6_ndpr;

	/* multicast addresses joined from the kernel */
	LIST_HEAD(, in6_multi_mship) ia6_memberships;
d266 1
a266 2
		u_char router : 1;
		u_char reserved : 5;
d348 2
d384 1
a384 4
#ifdef _KERNEL
#define OSIOCGIFINFO_IN6	_IOWR('i', 76, struct in6_ondireq)
#endif
#define SIOCGIFINFO_IN6		_IOWR('i', 108, struct in6_ndireq)
a418 4
#define IN6_IFF_NODAD		0x20	/* don't perform DAD on this address
					 * (used only at first SIOC* call)
					 */
#define IN6_IFF_AUTOCONF	0x40	/* autoconfigurable address. */
d431 2
d434 2
d438 5
a442 2
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->in6_ifstat->tag++; \
d491 1
a491 1
 * all of the in6_multi records.
d555 31
a585 28
struct	in6_multi *in6_addmulti(struct in6_addr *, struct ifnet *, int *);
void	in6_delmulti(struct in6_multi *);
struct in6_multi_mship *in6_joingroup(struct ifnet *, struct in6_addr *, int *);
int	in6_leavegroup(struct in6_multi_mship *);
int	in6_ifindex2scopeid(int);
int	in6_mask2len(struct in6_addr *, u_char *);
int	in6_control(struct socket *, u_long, caddr_t, struct ifnet *,
	struct proc *);
int	in6_update_ifa(struct ifnet *, struct in6_aliasreq *,
	struct in6_ifaddr *);
void	in6_purgeaddr(struct ifaddr *);
int	in6if_do_dad(struct ifnet *);
void	in6_purgeif(struct ifnet *);
void	in6_savemkludge(struct in6_ifaddr *);
void	in6_setmaxmtu(void);
void	*in6_domifattach(struct ifnet *);
void	in6_domifdetach(struct ifnet *, void *);
void	in6_restoremkludge(struct in6_ifaddr *, struct ifnet *);
void	in6_createmkludge(struct ifnet *);
void	in6_purgemkludge(struct ifnet *);
struct in6_ifaddr *in6ifa_ifpforlinklocal(struct ifnet *, int);
struct in6_ifaddr *in6ifa_ifpwithaddr(struct ifnet *, struct in6_addr *);
char	*ip6_sprintf(struct in6_addr *);
int	in6_addr2scopeid(struct ifnet *, struct in6_addr *);
int	in6_matchlen(struct in6_addr *, struct in6_addr *);
int	in6_are_prefix_equal(struct in6_addr *, struct in6_addr *, int);
void	in6_prefixlen2mask(struct in6_addr *, int);
void	in6_purgeprefix(struct ifnet *);
a586 1
int	in6_is_addr_deprecated(struct sockaddr_in6 *);
d588 5
a592 5
int in6_embedscope(struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **);
int in6_recoverscope(struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *);
void in6_clearscope(struct in6_addr *);
@


1.12
log
@amove in6_{embed,recover}scope prototypes to in6_var.h (kernel only).
add in6_clearscope.  sync better with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.11 2001/02/16 08:22:06 itojun Exp $	*/
d570 1
@


1.11
log
@kill register declarations.  to sync with kame better.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_var.h,v 1.10 2000/04/17 04:44:50 itojun Exp $	*/
/*	$KAME: in6_var.h,v 1.31 2000/03/25 07:23:46 sumikawa Exp $	*/
d482 1
a482 1
	struct	in6_ifaddr *in6m_ia;    /* back pointer to in6_ifaddr */ 
d585 7
@


1.10
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.9 2000/02/28 11:55:22 itojun Exp $	*/
d509 1
a509 1
	register struct in6_ifaddr *ia;				\
@


1.9
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_var.h,v 1.8 2000/02/04 18:13:36 itojun Exp $	*/
/*	$KAME: in6_var.h,v 1.29 2000/02/25 05:20:58 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d192 1
a192 1
	 * Output statistics. We should solve unresolved routing problem...  
d368 1
a368 1
#endif 
d397 2
@


1.8
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 2
a2 1
/* $OpenBSD: in6_var.h,v 1.7 2000/02/02 17:16:52 itojun Exp $ */
d360 6
d367 3
a370 1
#define SIOCSIFNETMASK_IN6	 _IOW('i', 22, struct in6_ifreq)
d395 3
d422 5
d569 1
a569 1
struct in6_ifaddr *in6ifa_ifpforlinklocal __P((struct ifnet *));
d573 1
@


1.8.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: in6_var.h,v 1.29 2000/02/25 05:20:58 itojun Exp $	*/
a358 6

#ifdef _KERNEL
/*
 * SIOCSxxx ioctls should be unused (see comments in in6.c), but
 * we do not shift numbers for binary compatibility.
 */
d360 1
a361 3
#endif 

#define SIOCGIFDSTADDR_IN6	_IOWR('i', 34, struct in6_ifreq)
a385 3
#define SIOCSDEFIFACE_IN6	_IOWR('i', 85, struct in6_ndifreq)
#define SIOCGDEFIFACE_IN6	_IOWR('i', 86, struct in6_ndifreq)

a409 5
#define IN6_ARE_SCOPE_CMP(a,b) ((a)-(b))
#define IN6_ARE_SCOPE_EQUAL(a,b) ((a)==(b))
#endif

#ifdef _KERNEL
d552 1
a552 1
struct in6_ifaddr *in6ifa_ifpforlinklocal __P((struct ifnet *, int));
a555 1
int	in6_addr2scopeid __P((struct ifnet *, struct in6_addr *));
@


1.8.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_var.h,v 1.12 2001/02/16 14:45:12 itojun Exp $	*/
/*	$KAME: in6_var.h,v 1.55 2001/02/16 12:49:45 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d192 1
a192 1
	 * Output statistics. We should solve unresolved routing problem...
d368 1
a368 1
#endif
a397 2
#define SIOCSIFINFO_FLAGS	_IOWR('i', 87, struct in6_ndireq) /* XXX */

d480 1
a480 1
	struct	in6_ifaddr *in6m_ia;	/* back pointer to in6_ifaddr */
d507 1
a507 1
	struct in6_ifaddr *ia;					\
a582 7

struct inpcb;
int in6_embedscope __P((struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **));
int in6_recoverscope __P((struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *));
void in6_clearscope __P((struct in6_addr *));
@


1.8.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.8.2.2 2001/05/14 22:40:18 niklas Exp $	*/
a569 1
void	in6_createmkludge __P((struct ifnet *));
@


1.8.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d555 31
a585 31
int	in6_ifinit(struct ifnet *,
			struct in6_ifaddr *, struct sockaddr_in6 *, int);
struct	in6_multi *in6_addmulti(struct in6_addr *, struct ifnet *,
				     int *);
void	in6_delmulti(struct in6_multi *);
void	in6_ifscrub(struct ifnet *, struct in6_ifaddr *);
extern int in6_ifindex2scopeid(int);
extern int in6_mask2len(struct in6_addr *);
extern void in6_len2mask(struct in6_addr *, int);
int	in6_control(struct socket *,
			 u_long, caddr_t, struct ifnet *, struct proc *);
void	in6_purgeaddr(struct ifaddr *, struct ifnet *);
void	in6_savemkludge(struct in6_ifaddr *);
void	in6_setmaxmtu(void);
void	in6_restoremkludge(struct in6_ifaddr *, struct ifnet *);
void	in6_createmkludge(struct ifnet *);
void	in6_purgemkludge(struct ifnet *);
struct in6_ifaddr *in6ifa_ifpforlinklocal(struct ifnet *, int);
struct in6_ifaddr *in6ifa_ifpwithaddr(struct ifnet *,
					     struct in6_addr *);
char	*ip6_sprintf(struct in6_addr *);
int	in6_addr2scopeid(struct ifnet *, struct in6_addr *);
int	in6_matchlen(struct in6_addr *, struct in6_addr *);
int	in6_are_prefix_equal(struct in6_addr *p1, struct in6_addr *p2,
				  int len);
void	in6_prefixlen2mask(struct in6_addr *maskp, int len);
int	in6_prefix_ioctl(struct socket *so, u_long cmd, caddr_t data,
			      struct ifnet *ifp);
int	in6_prefix_add_ifid(int iilen, struct in6_ifaddr *ia);
void	in6_prefix_remove_ifid(int iilen, struct in6_ifaddr *ia);
void	in6_purgeprefix(struct ifnet *);
d588 5
a592 5
int in6_embedscope(struct in6_addr *, const struct sockaddr_in6 *,
	struct inpcb *, struct ifnet **);
int in6_recoverscope(struct sockaddr_in6 *, const struct in6_addr *,
	struct ifnet *);
void in6_clearscope(struct in6_addr *);
@


1.8.2.5
log
@Sync the SMP branch with 3.3
@
text
@d83 1
a83 1
 *	kernel -> userland: throw up everything
a92 7
struct nd_ifinfo;
struct in6_ifextra {
	struct in6_ifstat *in6_ifstat;
	struct icmp6_ifstat *icmp6_ifstat;
	struct nd_ifinfo *nd_ifinfo;
};

d107 2
a108 11
	struct in6_addrlifetime ia6_lifetime;
	time_t	ia6_createtime; /* the creation time of this address, which is
				 * currently used for temporary addresses only.
				 */
	time_t	ia6_updatetime;

	/* back pointer to the ND prefix (for autoconfigured addresses only) */
	struct nd_prefix *ia6_ndpr;

	/* multicast addresses joined from the kernel */
	LIST_HEAD(, in6_multi_mship) ia6_memberships;
d266 1
a266 2
		u_char router : 1;
		u_char reserved : 5;
d348 2
d384 1
a384 4
#ifdef _KERNEL
#define OSIOCGIFINFO_IN6	_IOWR('i', 76, struct in6_ondireq)
#endif
#define SIOCGIFINFO_IN6		_IOWR('i', 108, struct in6_ndireq)
a418 4
#define IN6_IFF_NODAD		0x20	/* don't perform DAD on this address
					 * (used only at first SIOC* call)
					 */
#define IN6_IFF_AUTOCONF	0x40	/* autoconfigurable address. */
d431 2
d434 2
d438 5
a442 2
	if (ifp)						\
		((struct in6_ifextra *)((ifp)->if_afdata[AF_INET6]))->in6_ifstat->tag++; \
d491 1
a491 1
 * all of the in6_multi records.
d555 4
a558 1
struct	in6_multi *in6_addmulti(struct in6_addr *, struct ifnet *, int *);
d560 7
a566 11
struct in6_multi_mship *in6_joingroup(struct ifnet *, struct in6_addr *, int *);
int	in6_leavegroup(struct in6_multi_mship *);
int	in6_ifindex2scopeid(int);
int	in6_mask2len(struct in6_addr *, u_char *);
int	in6_control(struct socket *, u_long, caddr_t, struct ifnet *,
	struct proc *);
int	in6_update_ifa(struct ifnet *, struct in6_aliasreq *,
	struct in6_ifaddr *);
void	in6_purgeaddr(struct ifaddr *);
int	in6if_do_dad(struct ifnet *);
void	in6_purgeif(struct ifnet *);
a568 2
void	*in6_domifattach(struct ifnet *);
void	in6_domifdetach(struct ifnet *, void *);
d573 2
a574 1
struct in6_ifaddr *in6ifa_ifpwithaddr(struct ifnet *, struct in6_addr *);
d578 7
a584 2
int	in6_are_prefix_equal(struct in6_addr *, struct in6_addr *, int);
void	in6_prefixlen2mask(struct in6_addr *, int);
a586 1
int	in6_is_addr_deprecated(struct sockaddr_in6 *);
@


1.8.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_var.h,v 1.8.2.5 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a273 7
struct prf_ra {
	u_char onlink : 1;
	u_char autonomous : 1;
	u_char router : 1;
	u_char reserved : 5;
};

d275 6
a280 1
	struct prf_ra prf_ra;
a593 2
void	in6_ifaddloop(struct ifaddr *);
void	in6_ifremloop(struct ifaddr *);
@


1.7
log
@- improve in6_ifdetach to remove (1) multicast kludge list (2) route to
  link-local allnode multicast (ff02:x::/32)
- fix ifnet refcnt'ing in multicast kludge list management.
- avoid dangling pointer in multicast kludge management.

(angelos, try this version of in6_ifdetach() - it should be better)
@
text
@d1 1
a1 1
/* $OpenBSD: in6_var.h,v 1.6 1999/12/10 10:04:28 angelos Exp $ */
d547 1
d564 1
@


1.6
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/* $OpenBSD: in6_var.h,v 1.5 1999/12/10 08:53:17 angelos Exp $ */
d550 1
@


1.5
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a101 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a103 1
#endif
a429 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#ifdef MALLOC_DECLARE
MALLOC_DECLARE(M_IPMADDR);
#endif /* MALLOC_DECLARE */
#endif
a434 18
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)

#define IFP_TO_IA6(ifp, ia)				\
/* struct ifnet *ifp; */				\
/* struct in6_ifaddr *ia; */				\
do {									\
	struct ifaddr *ifa;						\
	for (ifa = (ifp)->if_addrlist; ifa; ifa = ifa->ifa_next) {	\
		if (!ifa->ifa_addr)					\
			continue;					\
		if (ifa->ifa_addr->sa_family == AF_INET6)		\
			break;						\
	}								\
	(ia) = (struct in6_ifaddr *)ifa;				\
} while (0)

#else

a449 2
#endif

a462 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a463 3
#else
	struct	ifmultiaddr *in6m_ifma;	/* back pointer to ifmultiaddr */
#endif
a469 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
extern LIST_HEAD(in6_multihead, in6_multi) in6_multihead;
#endif

a484 43
#if defined(__FreeBSD__) && __FreeBSD__ >= 3

#define IN6_LOOKUP_MULTI(addr, ifp, in6m)			\
/* struct in6_addr addr; */					\
/* struct ifnet *ifp; */					\
/* struct in6_multi *in6m; */					\
do { \
	register struct ifmultiaddr *ifma; \
	for (ifma = (ifp)->if_multiaddrs.lh_first; ifma; \
	     ifma = ifma->ifma_link.le_next) { \
		if (ifma->ifma_addr->sa_family == AF_INET6 \
		    && IN6_ARE_ADDR_EQUAL(&((struct sockaddr_in6 *)ifma->ifma_addr)->sin6_addr, \
					  &(addr))) \
			break; \
	} \
	(in6m) = (struct in6_multi *)(ifma ? ifma->ifma_protospec : 0); \
} while(0)

/*
 * Macro to step through all of the in6_multi records, one at a time.
 * The current position is remembered in "step", which the caller must
 * provide.  IN6_FIRST_MULTI(), below, must be called to initialize "step"
 * and get the first record.  Both macros return a NULL "in6m" when there
 * are no remaining records.
 */
#define IN6_NEXT_MULTI(step, in6m)					\
/* struct in6_multistep step; */					\
/* struct in6_multi *in6m; */						\
do { \
	if (((in6m) = (step).i_in6m) != NULL) \
		(step).i_in6m = (step).i_in6m->in6m_entry.le_next; \
} while(0)

#define IN6_FIRST_MULTI(step, in6m)		\
/* struct in6_multistep step; */		\
/* struct in6_multi *in6m */			\
do { \
	(step).i_in6m = in6_multihead.lh_first; \
		IN6_NEXT_MULTI((step), (in6m)); \
} while(0)

#else /* not FreeBSD3 */

a535 2
#endif /* not FreeBSD3 */

a544 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a546 3
#else
int	in6_control __P((struct socket *, u_long, caddr_t, struct ifnet *));
#endif
@


1.4
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 2
@


1.3
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d2 643
a644 196
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.

*/

#ifndef _NETINET6_IN6_VAR_H
#define _NETINET6_IN6_VAR_H 1

/*
 * IPv6 interface request and alias request.  Use sockaddr_in6 because
 * it is larger than sockaddr.
 */

struct inet6_ifreq
{
#if !__OpenBSD__ && !defined(IFNAMSIZ)
#define IFNAMSIZ        16
#endif /* !__OpenBSD__ && !defined(IFNAMSIZ) */
        char    ifr_name[IFNAMSIZ];             /* if name, e.g. "en0" */
        union {
                struct  sockaddr_in6 ifru_addr;
                struct  sockaddr_in6 ifru_dstaddr;
                struct  sockaddr_in6 ifru_broadaddr;
                short   ifru_flags;
                int     ifru_metric;
                caddr_t ifru_data;
	      } ifr_ifru;
#define ifr_addr        ifr_ifru.ifru_addr      /* address */
#define ifr_dstaddr     ifr_ifru.ifru_dstaddr   /* other end of p-to-p link */
#define ifr_broadaddr   ifr_ifru.ifru_broadaddr /* broadcast address */
#define ifr_flags       ifr_ifru.ifru_flags     /* flags */
#define ifr_metric      ifr_ifru.ifru_metric    /* metric */
#define ifr_data        ifr_ifru.ifru_data      /* for use by interface */
      };

/*
 * IPv6 interface "alias" request.  Used to add interface addresses.  This 
 * may be needed to be expanded to pass down/up permanancy information, and
 * possibly deprecation lifetime values.  (That is, if the kernel doesn't
 * compute that stuff itself.)
 */

struct inet6_aliasreq
{
  char ifra_name[IFNAMSIZ];
  struct sockaddr_in6 ifra_addr;
  struct sockaddr_in6 ifra_dstaddr;
#define	ifra_broadaddr ifra_dstaddr
  struct sockaddr_in6 ifra_mask;
};

/* ioctl()'s for stuff with inet6_{aliasreq,ifreq}  (gag!) */

#define SIOCDIFADDR_INET6 _IOW('i',25, struct inet6_ifreq)  /* delete IF addr */
#define SIOCAIFADDR_INET6 _IOW('i',26, struct inet6_aliasreq)/* add/chg IFalias */
#define SIOCGIFADDR_INET6 _IOWR('i',33, struct inet6_ifreq) /* get ifnet address */
#define SIOCGIFDSTADDR_INET6 _IOWR('i',34, struct inet6_ifreq) /* get dst address */
#define SIOCSIFDSTADDR_INET6 _IOW('i', 14, struct inet6_ifreq) /* set dst address */
#define SIOCGIFNETMASK_INET6 _IOWR('i',37, struct inet6_ifreq) /* get netmask */

#define SIOCVIFADDR_INET6 _IOW('i',69,struct inet6_ifreq) /* Verify IPv6 addr */

/*
 * INET6 interface address.  This might also serve as the prefix list,
 * with the help of the I6AF_PREFIX flag.
 */

struct in6_ifaddr
{
  struct ifaddr i6a_ifa; /* protocol-independent info (32 bytes) */
#define i6a_ifp    i6a_ifa.ifa_ifp
#if defined(_KERNEL) || defined(KERNEL)
#define i6a_flags  i6a_ifa.ifa_flags
#endif /* defined(_KERNEL) || defined(KERNEL) */
  
  /* All sorts of INET6-specific junk, some of it, very similar to IP's
     in_ifaddr. */
  
  /* Put any subnetting, etc here. */
  
  struct in6_ifaddr *i6a_next;
  struct in6_ifnet *i6a_i6ifp;           /* Pointer to IPv6 interface info */
  struct sockaddr_in6 i6a_addr;          /* Address. */
  struct sockaddr_in6 i6a_dstaddr;       /* Dest. if PPP link. */
  struct sockaddr_in6 i6a_sockmask;      /* Netmask.  This is IPv6, so
					    there is no "subnet/net"
					    distinction. */
  
  /*
   * IPv6 addresses have lifetimes.  Put in expiration information in
   * here.  A DEPRECATED address is still valid for inbound, but not for
   * outbound.  An EXPIRED address is invalid for both inbound and outbound,
   * and should be put out of its misery (and our in6_ifaddr list) ASAP.
   */
  u_long i6a_preferred;                 /* Preferred lifetime. */
  u_long i6a_expire;                    /* Expiration time. */
  u_short i6a_preflen;                  /* Prefix length for link-locals
					   (in bits). */
  u_short i6a_addrflags;                /* Additional flags because
					   ifa_flags isn't big enough. */
};

#define I6A_SIN(i6a) (&(((struct in6_ifaddr *)(i6a))->i6a_addr))
#define IS_EXPIRED(i6a) ((i6a->i6a_expire != 0 && \
			  i6a->i6a_expire < time.tv_sec))
#define IS_DEPRECATED(i6a) ((i6a)->i6a_addrflags & I6AF_DEPRECATED)

#define I6AF_LINKLOC 0x1    /* Link-local address.  Saves the IS_IN6_LINKLOC
			       check. */
#define I6AF_PERMANENT 0x2  /* Permanent address */
#define I6AF_PREFIX 0x4     /* I am a, "prefix list entry," meaning that
			       the portion of the address inside the mask
			       is directly attached to the link. */
#define I6AF_NOTSURE 0x8    /* I'm not sure if I'm allowed to be used yet.
			       This is designed for use with addresses
			       that haven't been verified as unique on a
			       link yet. */
#define I6AF_DEPRECATED 0x10  /* The use of this address should be discouraged.
                                 The address should not be used as a source
                                 address for new communications.  The address
                                 is still valid for receiving packets.  */

/*
 * IPv6 multicast structures and macros.
 */

struct in6_multi
{
  struct in6_multi *in6m_next;          /* Ptr. to next one. */
  struct in6_addr in6m_addr;            /* Multicast address. */
  struct ifnet *in6m_ifp;               /* Pointer to interface. */
  struct in6_ifnet *in6m_i6ifp;         /* Back ptr. to IPv6 if info. */
  uint in6m_refcount;                  /* Number of membership claims by
					   sockets. */
  uint in6m_timer;                     /* IGMP membership report timer. */
};

#if defined(_KERNEL) || defined(KERNEL)
/* General case IN6 multicast lookup.  Can be optimized out in certain
   places (like netinet6/ipv6_input.c ?). */

#define IN6_LOOKUP_MULTI(addr,ifp,in6m) \
{\
  register struct in6_ifnet *i6ifp;\
\
  for (i6ifp=in6_ifnet; i6ifp != NULL && i6ifp->i6ifp_ifp != ifp;\
       i6ifp=i6ifp->i6ifp_next)\
   ;\
  if (i6ifp == NULL)\
    in6m=NULL;\
  else\
    for ((in6m) = i6ifp->i6ifp_multiaddrs;\
       (in6m) != NULL && !IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr,(addr));\
       (in6m) = (in6m)->in6m_next) ;\
}


#define IN6_MCASTOPTS 0x2

#define ETHER_MAP_IN6_MULTICAST(in6addr,enaddr) { \
   (enaddr)[0] = 0x33; \
   (enaddr)[1] = 0x33; \
   (enaddr)[2] = in6addr.s6_addr[12]; \
   (enaddr)[3] = in6addr.s6_addr[13]; \
   (enaddr)[4] = in6addr.s6_addr[14]; \
   (enaddr)[5] = in6addr.s6_addr[15]; \
   }

#define IN6ADDR_ALLNODES_INIT	{{{ 0xff,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }}}
#define IN6ADDR_ALLROUTERS_INIT {{{ 0xff,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2 }}}
#define IN6ADDR_ALLHOSTS_INIT	{{{ 0xff,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3 }}}
#define IN6ADDR_SN_PREFIX_INIT	{{{ 0xff,2,0,0,0,0,0,0,0,0,0,1,0xff,0,0,0 }}}

struct in6_ifnet
{
  struct in6_ifnet *i6ifp_next;         /* Next in list. */
  struct ifnet *i6ifp_ifp;              /* Back pointer to actual interface. */
  struct in6_multi *i6ifp_multiaddrs;   /* Multicast addresses for this
					   interface. */
  uint i6ifp_numaddrs;                 /* Number of IPv6 addresses on this
					   interface. */

  /* Addrconf and ND variables will go here. */
};

extern struct ifqueue ipv6intrq;

int ipv6_discov_resolve __P((struct ifnet *, struct rtentry *, struct mbuf *,
	struct sockaddr *, u_char *));
#endif /* defined(_KERNEL) || defined(KERNEL) */
d646 1
a646 1
#endif /* _NETINET6_IN6_VAR_H */
@


1.2
log
@use _KERNEL, add ipv6intrq decl
@
text
@d10 1
d23 3
d41 1
a41 1
};
d79 1
a79 1
#ifdef _KERNEL
d81 1
a81 1
#endif
d145 3
a147 5
#ifdef _KERNEL
/*
 * General case IN6 multicast lookup.  Can be optimized out in certain
 * places (like netinet6/ipv6_input.c ?).
 */
d150 12
a161 12
	{ \
	struct in6_ifnet *i6ifp; \
	for (i6ifp=in6_ifnet; i6ifp != NULL && i6ifp->i6ifp_ifp != ifp; \
	    i6ifp=i6ifp->i6ifp_next) \
		; \
	if (i6ifp == NULL) \
		in6m=NULL; \
	else \
		for ((in6m) = i6ifp->i6ifp_multiaddrs; \
		    (in6m) != NULL && !IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr,(addr)); \
		(in6m) = (in6m)->in6m_next) \
			; \
d164 1
d176 5
d197 1
a197 2

#endif /* _KERNEL */
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@d10 1
a11 1
*/
a21 3
#ifndef IFNAMSIZ
#define IFNAMSIZ        16
#endif /* IFNAMSIZ */
d37 1
a37 1
      };
d75 1
a75 1
#ifdef KERNEL
d141 5
a145 3
#ifdef KERNEL
/* General case IN6 multicast lookup.  Can be optimized out in certain
   places (like netinet6/ipv6_input.c ?). */
d148 12
a159 12
{\
  register struct in6_ifnet *i6ifp;\
\
  for (i6ifp=in6_ifnet; i6ifp != NULL && i6ifp->i6ifp_ifp != ifp;\
       i6ifp=i6ifp->i6ifp_next)\
   ;\
  if (i6ifp == NULL)\
    in6m=NULL;\
  else\
    for ((in6m) = i6ifp->i6ifp_multiaddrs;\
       (in6m) != NULL && !IN6_ARE_ADDR_EQUAL(&(in6m)->in6m_addr,(addr));\
       (in6m) = (in6m)->in6m_next) ;\
a161 1

d185 6
a190 1
#endif /* KERNEL */
@

