head	1.95;
access;
symbols
	OPENBSD_6_2:1.95.0.4
	OPENBSD_6_2_BASE:1.95
	OPENBSD_6_1:1.94.0.4
	OPENBSD_6_1_BASE:1.94
	OPENBSD_6_0:1.91.0.2
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.71.0.2
	OPENBSD_5_7_BASE:1.71
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.60.0.2
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.54.0.2
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.4
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.40.0.2
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.39.0.4
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.2
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.8
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.34.0.6
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.34.0.4
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.2
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.27.0.2
	OPENBSD_3_4_BASE:1.27
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.4
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.2
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.20.0.4
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.24
	UBC:1.20.0.2
	UBC_BASE:1.20
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.95
date	2017.06.30.11.29.15;	author bluhm;	state Exp;
branches;
next	1.94;
commitid	mKojwKlJQV2JAUBB;

1.94
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.93;
commitid	2R0NOjEDy2jGtnjL;

1.93
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.92;
commitid	ymldqUr8o0SRU6R6;

1.92
date	2016.08.24.09.41.12;	author mpi;	state Exp;
branches;
next	1.91;
commitid	0Qtt2cJVj3irHniv;

1.91
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.90;
commitid	qWegq9wDcxofLjIV;

1.90
date	2016.05.02.09.30.47;	author mpi;	state Exp;
branches;
next	1.89;
commitid	LamsMQyL49HM375K;

1.89
date	2016.04.27.21.14.29;	author markus;	state Exp;
branches;
next	1.88;
commitid	nWBKWy8IKn6P3HG1;

1.88
date	2016.04.19.08.23.13;	author mpi;	state Exp;
branches;
next	1.87;
commitid	6aaC9jQAC2YWe333;

1.87
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.86;
commitid	AZTNcVhJxOTcjeS6;

1.86
date	2015.11.02.07.22.28;	author mpi;	state Exp;
branches;
next	1.85;
commitid	tbVuKXiiNk7Z7jhT;

1.85
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.84;
commitid	Ajb0hNGeCqGFHjjg;

1.84
date	2015.10.25.15.01.59;	author mpi;	state Exp;
branches;
next	1.83;
commitid	y7UrrAmR7zcM69wb;

1.83
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.82;
commitid	aMzCQ7pRC6VLKZyx;

1.82
date	2015.09.10.09.14.59;	author mpi;	state Exp;
branches;
next	1.81;
commitid	lAvOdkHyrVIrW5gv;

1.81
date	2015.09.09.14.02.29;	author mpi;	state Exp;
branches;
next	1.80;
commitid	rqcRalpFRBw7CAML;

1.80
date	2015.08.31.07.17.12;	author mpi;	state Exp;
branches;
next	1.79;
commitid	cniCJ6rbTz2M0Mvg;

1.79
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.78;
commitid	VGPlklxThaST7mIm;

1.78
date	2015.07.08.08.48.35;	author mpi;	state Exp;
branches;
next	1.77;
commitid	PeSgmtaVq0R4a133;

1.77
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.76;
commitid	J4OPNuggl4DOKGzM;

1.76
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.75;
commitid	h7z8lokZ0dFyuWpg;

1.75
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.74;
commitid	4Ro7ulidQXNcMvmM;

1.74
date	2015.05.23.12.52.59;	author markus;	state Exp;
branches;
next	1.73;
commitid	XxDCtGxlGi1shqAt;

1.73
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.72;
commitid	6glXvFR7NxzCcdRd;

1.72
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.71;
commitid	p4LJxGKbi0BU2cG6;

1.71
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.70;
commitid	t9FBKDfc4VDxpEy2;

1.70
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.69;
commitid	F3Fu23ZZ8dwzir4r;

1.69
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.68;
commitid	6AYfDT0Lpez1LFQp;

1.68
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.67;
commitid	HQcmytntiCJTHORs;

1.67
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.66;
commitid	2Ufy37wyO5neufOK;

1.66
date	2014.05.06.09.49.58;	author gerhard;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.29.00.50.56;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.07.31.15.41.52;	author mikeb;	state Exp;
branches;
next	1.60;

1.60
date	2013.07.04.19.10.41;	author sf;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.58;

1.58
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.56;

1.56
date	2012.11.05.21.49.15;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.54;

1.54
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.24.20.09.45;	author bluhm;	state Exp;
branches;
next	1.51;

1.51
date	2011.03.23.09.26.12;	author bluhm;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.09.20.25.46;	author bluhm;	state Exp;
branches;
next	1.49;

1.49
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.47;

1.47
date	2010.06.29.21.28.38;	author reyk;	state Exp;
branches;
next	1.46;

1.46
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.43;

1.43
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.42;

1.42
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.22.14.36.08;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.37;

1.37
date	2006.11.27.12.27.45;	author henning;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.14.20.19.58;	author dhartmei;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.12.00.50.22;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.25.00.42.58;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.24.15.01.32;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.21.19.26.02;	author mcbride;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.02.20.13.01;	author cedric;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.07.09.11.53;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.15.05.37.39;	author todd;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.07.04.13.10;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.29.08.02.07;	author jasoni;	state Exp;
branches;
next	1.16;

1.16
date	2001.07.18.09.56.49;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.22.12.30.34;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.30.11.09.00;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.16.16.38.14;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.16.08.48.05;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.16.08.22.06;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.27.16.05.07;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.30.19.45.36;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.03.13.42.33;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.19.20.12.10;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.19.13.55.16;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.07.04.10.55.22;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.20.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.95
log
@In OpenBSD 6.0 we had the check (ip6_forward_rt.ro_tableid !=
m->m_pkthdr.ph_rtableid) after going to reroute in ip6_forward().
As this had been lost during refactoring, the old route was used
after pf has changed the routing table.  Solution is to reset the
route, then it is not valid and will be reallocated.
from markus@@; OK mpi@@
@
text
@/*	$OpenBSD: ip6_forward.c,v 1.94 2017/02/05 16:04:14 jca Exp $	*/
/*	$KAME: ip6_forward.c,v 1.75 2001/06/29 12:42:13 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_enc.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip_var.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/nd6.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#endif

/*
 * Forward a packet.  If some error occurs return the sender
 * an icmp packet.  Note we can't always generate a meaningful
 * icmp message because icmp doesn't have a large enough repertoire
 * of codes and types.
 *
 * If not forwarding, just drop the packet.  This could be confusing
 * if ipforwarding was zero but some routing protocol was advancing
 * us as a gateway to somewhere.  However, we must let the routing
 * protocol deal with that.
 *
 */

void
ip6_forward(struct mbuf *m, struct rtentry *rt, int srcrt)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct sockaddr_in6 *dst, sin6;
	struct ifnet *ifp = NULL;
	int error = 0, type = 0, code = 0;
	struct mbuf *mcopy = NULL;
#ifdef IPSEC
	struct tdb *tdb = NULL;
#endif /* IPSEC */
	char src6[INET6_ADDRSTRLEN], dst6[INET6_ADDRSTRLEN];

	/*
	 * Do not forward packets to multicast destination (should be handled
	 * by ip6_mforward().
	 * Do not forward packets with unspecified source.  It was discussed
	 * in July 2000, on ipngwg mailing list.
	 */
	if ((m->m_flags & (M_BCAST|M_MCAST)) != 0 ||
	    IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
		ip6stat_inc(ip6s_cantforward);
		if (ip6_log_time + ip6_log_interval < time_uptime) {
			ip6_log_time = time_uptime;
			inet_ntop(AF_INET6, &ip6->ip6_src, src6, sizeof(src6));
			inet_ntop(AF_INET6, &ip6->ip6_dst, dst6, sizeof(dst6));
			log(LOG_DEBUG,
			    "cannot forward "
			    "from %s to %s nxt %d received on inteface %u\n",
			    src6, dst6,
			    ip6->ip6_nxt,
			    m->m_pkthdr.ph_ifidx);
		}
		m_freem(m);
		goto out;
	}

	if (ip6->ip6_hlim <= IPV6_HLIMDEC) {
		icmp6_error(m, ICMP6_TIME_EXCEEDED,
				ICMP6_TIME_EXCEED_TRANSIT, 0);
		goto out;
	}
	ip6->ip6_hlim -= IPV6_HLIMDEC;

	/*
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
	 *
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
	 */
	mcopy = m_copym(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN),
	    M_NOWAIT);

#if NPF > 0
reroute:
#endif

#ifdef IPSEC
	if (ipsec_in_use) {
		tdb = ip6_output_ipsec_lookup(m, &error, NULL);
		if (error != 0) {
			/*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
			if (error == -EINVAL) /* Should silently drop packet */
				error = 0;

			m_freem(m);
			goto freecopy;
		}
	}
#endif /* IPSEC */

	dst = &sin6;
	memset(dst, 0, sizeof(*dst));
	dst->sin6_len = sizeof(struct sockaddr_in6);
	dst->sin6_family = AF_INET6;
	dst->sin6_addr = ip6->ip6_dst;

	if (!rtisvalid(rt)) {
		rtfree(rt);
		rt = rtalloc_mpath(sin6tosa(dst), &ip6->ip6_src.s6_addr32[0],
		    m->m_pkthdr.ph_rtableid);
		if (rt == NULL) {
			ip6stat_inc(ip6s_noroute);
			if (mcopy) {
				icmp6_error(mcopy, ICMP6_DST_UNREACH,
					    ICMP6_DST_UNREACH_NOROUTE, 0);
			}
			m_freem(m);
			goto out;
		}
	}

	/*
	 * Scope check: if a packet can't be delivered to its destination
	 * for the reason that the destination is beyond the scope of the
	 * source address, discard the packet and return an icmp6 destination
	 * unreachable error with Code 2 (beyond scope of source address).
	 * [draft-ietf-ipngwg-icmp-v3-00.txt, Section 3.1]
	 */
	if (in6_addr2scopeid(m->m_pkthdr.ph_ifidx, &ip6->ip6_src) !=
	    in6_addr2scopeid(rt->rt_ifidx, &ip6->ip6_src)) {
		ip6stat_inc(ip6s_cantforward);
		ip6stat_inc(ip6s_badscope);

		if (ip6_log_time + ip6_log_interval < time_uptime) {
			ip6_log_time = time_uptime;
			inet_ntop(AF_INET6, &ip6->ip6_src, src6, sizeof(src6));
			inet_ntop(AF_INET6, &ip6->ip6_dst, dst6, sizeof(dst6));
			log(LOG_DEBUG,
			    "cannot forward "
			    "src %s, dst %s, nxt %d, rcvif %u, outif %u\n",
			    src6, dst6,
			    ip6->ip6_nxt,
			    m->m_pkthdr.ph_ifidx, rt->rt_ifidx);
		}
		if (mcopy)
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_BEYONDSCOPE, 0);
		m_freem(m);
		goto out;
	}

#ifdef IPSEC
	/*
	 * Check if the packet needs encapsulation.
	 * ipsp_process_packet will never come back to here.
	 * XXX ipsp_process_packet() calls ip6_output(), and there'll be no
	 * PMTU notification.  is it okay?
	 */
	if (tdb != NULL) {
		/* Callee frees mbuf */
		error = ip6_output_ipsec_send(tdb, m, 0, 1);
		if (error)
			goto senderr;
		goto freecopy;
	}
#endif /* IPSEC */

	if (rt->rt_flags & RTF_GATEWAY)
		dst = satosin6(rt->rt_gateway);

	/*
	 * If we are to forward the packet using the same interface
	 * as one we got the packet from, perhaps we should send a redirect
	 * to sender to shortcut a hop.
	 * Only send redirect if source is sending directly to us,
	 * and if packet was not source routed (or has any options).
	 * Also, don't send redirect if forwarding using a route
	 * modified by a redirect.
	 */
	ifp = if_get(rt->rt_ifidx);
	if (rt->rt_ifidx == m->m_pkthdr.ph_ifidx && !srcrt &&
	    ip6_sendredirects &&
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0) {
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    nd6_is_addr_neighbor(&sin6, ifp)) {
			/*
			 * If the incoming interface is equal to the outgoing
			 * one, the link attached to the interface is
			 * point-to-point, and the IPv6 destination is
			 * regarded as on-link on the link, then it will be
			 * highly probable that the destination address does
			 * not exist on the link and that the packet is going
			 * to loop.  Thus, we immediately drop the packet and
			 * send an ICMPv6 error message.
			 * For other routing loops, we dare to let the packet
			 * go to the loop, so that a remote diagnosing host
			 * can detect the loop by traceroute.
			 * type/code is based on suggestion by Rich Draves.
			 * not sure if it is the best pick.
			 */
			if (mcopy)
				icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_ADDR, 0);
			m_freem(m);
			goto out;
		}
		type = ND_REDIRECT;
	}

	/*
	 * Fake scoped addresses. Note that even link-local source or
	 * destinaion can appear, if the originating node just sends the
	 * packet to us (without address resolution for the destination).
	 * Since both icmp6_error and icmp6_redirect_output fill the embedded
	 * link identifiers, we can do this stuff after making a copy for
	 * returning an error.
	 */
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;

#if NPF > 0
	if (pf_test(AF_INET6, PF_FWD, ifp, &m) != PF_PASS) {
		m_freem(m);
		goto senderr;
	}
	if (m == NULL)
		goto senderr;
	ip6 = mtod(m, struct ip6_hdr *);
	if ((m->m_pkthdr.pf.flags & (PF_TAG_REROUTE | PF_TAG_GENERATED)) ==
	    (PF_TAG_REROUTE | PF_TAG_GENERATED)) {
		/* already rerun the route lookup, go on */
		m->m_pkthdr.pf.flags &= ~(PF_TAG_GENERATED | PF_TAG_REROUTE);
	} else if (m->m_pkthdr.pf.flags & PF_TAG_REROUTE) {
		/* tag as generated to skip over pf_test on rerun */
		m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
		srcrt = 1;
		rtfree(rt);
		rt = NULL;
		if_put(ifp);
		ifp = NULL;
		goto reroute;
	}
#endif
	in6_proto_cksum_out(m, ifp);

	/* Check the size after pf_test to give pf a chance to refragment. */
	if (m->m_pkthdr.len > ifp->if_mtu) {
		if (mcopy)
			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0,
			    ifp->if_mtu);
		m_freem(m);
		goto out;
	}

	error = ifp->if_output(ifp, m, sin6tosa(dst), rt);
	if (error) {
		ip6stat_inc(ip6s_cantforward);
	} else {
		ip6stat_inc(ip6s_forward);
		if (type)
			ip6stat_inc(ip6s_redirectsent);
		else {
			if (mcopy)
				goto freecopy;
		}
	}

#if NPF > 0 || defined(IPSEC)
senderr:
#endif
	if (mcopy == NULL)
		goto out;
	switch (error) {
	case 0:
		if (type == ND_REDIRECT) {
			icmp6_redirect_output(mcopy, rt);
			goto out;
		}
		goto freecopy;

	case EMSGSIZE:
		/* xxx MTU is constant in PPP? */
		goto freecopy;

	case ENOBUFS:
		/* Tell source to slow down like source quench in IP? */
		goto freecopy;

	case ENETUNREACH:	/* shouldn't happen, checked above */
	case EHOSTUNREACH:
	case ENETDOWN:
	case EHOSTDOWN:
	default:
		type = ICMP6_DST_UNREACH;
		code = ICMP6_DST_UNREACH_ADDR;
		break;
	}
	icmp6_error(mcopy, type, code, 0);
	goto out;

freecopy:
	m_freem(mcopy);
out:
	rtfree(rt);
	if_put(ifp);
}
@


1.94
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.93 2016/10/03 12:33:21 mpi Exp $	*/
d301 2
@


1.93
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.92 2016/08/24 09:41:12 mpi Exp $	*/
d106 1
a106 1
		ip6stat.ip6s_cantforward++;
d174 1
a174 1
			ip6stat.ip6s_noroute++;
d193 2
a194 2
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
d319 1
a319 1
		ip6stat.ip6s_cantforward++;
d321 1
a321 1
		ip6stat.ip6s_forward++;
d323 1
a323 1
			ip6stat.ip6s_redirectsent++;
@


1.92
log
@Kill ip6_forward_rt reducing differences between v4 and v6.

A single forwarding cache is not the answer.  The answer is 42... err PF!

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.91 2016/06/15 11:49:34 mpi Exp $	*/
d107 2
a108 2
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
d196 2
a197 2
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
@


1.91
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.90 2016/05/02 09:30:47 mpi Exp $	*/
a70 2
struct	route_in6 ip6_forward_rt;

d85 1
a85 1
ip6_forward(struct mbuf *m, int srcrt)
d88 1
a88 2
	struct sockaddr_in6 *dst;
	struct rtentry *rt;
a94 1
	u_int rtableid = 0;
d119 1
a119 1
		return;
d125 1
a125 1
		return;
d163 11
a173 24
#if NPF > 0
	rtableid = m->m_pkthdr.ph_rtableid;
#endif

	dst = &ip6_forward_rt.ro_dst;
	if (!rtisvalid(ip6_forward_rt.ro_rt) ||
	   ISSET(ip6_forward_rt.ro_rt->rt_flags, RTF_MPATH) ||
	   !IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &dst->sin6_addr) ||
	   ip6_forward_rt.ro_tableid != rtableid) {
		if (ip6_forward_rt.ro_rt) {
			rtfree(ip6_forward_rt.ro_rt);
			ip6_forward_rt.ro_rt = NULL;
		}
		bzero(dst, sizeof(*dst));
		dst->sin6_len = sizeof(struct sockaddr_in6);
		dst->sin6_family = AF_INET6;
		dst->sin6_addr = ip6->ip6_dst;
		ip6_forward_rt.ro_tableid = rtableid;
		ip6_forward_rt.ro_rt = rtalloc_mpath(
		    sin6tosa(&ip6_forward_rt.ro_dst),
		    &ip6->ip6_src.s6_addr32[0],
		    ip6_forward_rt.ro_tableid);

		if (ip6_forward_rt.ro_rt == NULL) {
d180 1
a180 1
			return;
a182 1
	rt = ip6_forward_rt.ro_rt;
d247 1
a247 1
		    nd6_is_addr_neighbor(&ip6_forward_rt.ro_dst, ifp)) {
d366 1
@


1.90
log
@Merge two identical code paths.

ok benno@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.89 2016/04/27 21:14:29 markus Exp $	*/
d335 1
a335 1
	error = nd6_output(ifp, m, dst, rt);
@


1.89
log
@factor out ipsec into ip6_output_ipsec_{lookup,send}(); ok mpi@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.88 2016/04/19 08:23:13 mpi Exp $	*/
d172 1
a172 29
	if (!srcrt) {
		/*
		 * ip6_forward_rt.ro_dst.sin6_addr is equal to ip6->ip6_dst
		 */
		if (!rtisvalid(ip6_forward_rt.ro_rt) ||
		    ISSET(ip6_forward_rt.ro_rt->rt_flags, RTF_MPATH) ||
		    ip6_forward_rt.ro_tableid != rtableid) {
			if (ip6_forward_rt.ro_rt) {
				rtfree(ip6_forward_rt.ro_rt);
				ip6_forward_rt.ro_rt = NULL;
			}
			/* this probably fails but give it a try again */
			ip6_forward_rt.ro_tableid = rtableid;
			ip6_forward_rt.ro_rt = rtalloc_mpath(
			    sin6tosa(&ip6_forward_rt.ro_dst),
			    &ip6->ip6_src.s6_addr32[0],
			    ip6_forward_rt.ro_tableid);
		}

		if (ip6_forward_rt.ro_rt == NULL) {
			ip6stat.ip6s_noroute++;
			if (mcopy) {
				icmp6_error(mcopy, ICMP6_DST_UNREACH,
					    ICMP6_DST_UNREACH_NOROUTE, 0);
			}
			m_freem(m);
			return;
		}
	} else if (!rtisvalid(ip6_forward_rt.ro_rt) ||
@


1.88
log
@Instead of freeing a cached RTF_MPATH route after using it, free it
when the next packet needs to be forwarded, just like if the route
was invalid.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.87 2016/03/29 11:57:51 chl Exp $	*/
d96 1
a96 9
	u_int8_t sproto = 0;
	struct m_tag *mtag;
	union sockaddr_union sdst;
	struct tdb_ident *tdbi;
	u_int32_t sspi;
	struct tdb *tdb;
#if NPF > 0
	struct ifnet *encif;
#endif
d150 4
a153 23
	if (!ipsec_in_use)
		goto done_spd;

	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */

	/* Do we have any pending SAs to apply ? */
	tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
	    &error, IPSP_DIRECTION_OUT, NULL, NULL, 0);

	if (tdb == NULL) {
		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;

			/* Fall through to routing/multicast handling */
		} else {
		        /*
d158 1
a158 1
		        if (error == -EINVAL) /* Should silently drop packet */
a163 21
	} else {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    tdbi->rdomain == tdb->tdb_rdomain &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
			}
		}

	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
a164 3

	/* Fall through to the routing/multicast handling code */
 done_spd:
d267 4
a270 18
	if (sproto != 0) {
		tdb = gettdb(rtable_l2(m->m_pkthdr.ph_rtableid),
		    sspi, &sdst, sproto);
		if (tdb == NULL) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto senderr;	/*XXX*/
		}

#if NPF > 0
		if ((encif = enc_getif(tdb->tdb_rdomain,
		    tdb->tdb_tap)) == NULL ||
		    pf_test(AF_INET6, PF_FWD, encif, &m) != PF_PASS) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto senderr;
		}
		if (m == NULL)
d272 1
a272 15
		/*
		 * PF_TAG_REROUTE handling or not...
		 * Packet is entering IPsec so the routing is
		 * already overruled by the IPsec policy.
		 * Until now the change was not reconsidered.
		 * What's the behaviour?
		 */
		in6_proto_cksum_out(m, encif);
#endif
		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

		/* Callee frees mbuf */
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
		m_freem(mcopy);
		goto out;
@


1.87
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.86 2015/11/02 07:22:28 mpi Exp $	*/
d228 1
d252 1
d308 1
a308 1
		goto freert;
d351 1
a351 1
		goto freert;
d392 1
a392 1
			goto freert;
d439 1
a439 1
		goto freert;
d459 1
a459 1
		goto freert;
d464 1
a464 1
			goto freert;
d486 1
a486 1
	goto freert;
d488 1
a488 1
 freecopy:
d490 1
a490 8
 freert:
#ifndef SMALL_KERNEL
	if (ip6_multipath && ip6_forward_rt.ro_rt &&
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_MPATH)) {
		rtfree(ip6_forward_rt.ro_rt);
		ip6_forward_rt.ro_rt = NULL;
	}
#endif
@


1.86
log
@Stop using rt_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.85 2015/10/28 12:14:25 florian Exp $	*/
a334 1
		ip6 = mtod(m, struct ip6_hdr *);
@


1.85
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.84 2015/10/25 15:01:59 mpi Exp $	*/
d92 1
d366 2
a367 1
	if (rt->rt_ifp->if_index == m->m_pkthdr.ph_ifidx && !srcrt &&
d370 2
a371 2
		if ((rt->rt_ifp->if_flags & IFF_POINTOPOINT) &&
		    nd6_is_addr_neighbor(&ip6_forward_rt.ro_dst, rt->rt_ifp)) {
d410 1
a410 1
	if (pf_test(AF_INET6, PF_FWD, rt->rt_ifp, &m) != PF_PASS) {
d425 2
d430 1
a430 1
	in6_proto_cksum_out(m, rt->rt_ifp);
d433 1
a433 1
	if (m->m_pkthdr.len > rt->rt_ifp->if_mtu) {
d436 1
a436 1
			    rt->rt_ifp->if_mtu);
d441 1
a441 1
	error = nd6_output(rt->rt_ifp, m, dst, rt);
d497 1
a497 1
	return;
@


1.84
log
@Trivial rt_ifp->if_index -> rt_ifidx conversions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.83 2015/10/19 12:11:28 mpi Exp $	*/
d429 4
a432 8
	if (m->m_pkthdr.len > IN6_LINKMTU(rt->rt_ifp)) {
		if (mcopy) {
			u_long mtu;

			mtu = IN6_LINKMTU(rt->rt_ifp);

			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0, mtu);
		}
@


1.83
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.82 2015/09/10 09:14:59 mpi Exp $	*/
d286 1
a286 1
	    in6_addr2scopeid(rt->rt_ifp->if_index, &ip6->ip6_src)) {
d299 1
a299 1
			    m->m_pkthdr.ph_ifidx, rt->rt_ifp->if_index);
@


1.82
log
@Fewer in6_ifstat_inc()

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.81 2015/09/09 14:02:29 mpi Exp $	*/
d226 1
a226 2
		if (ip6_forward_rt.ro_rt == NULL ||
		    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) == 0 ||
d249 1
a249 2
	} else if (ip6_forward_rt.ro_rt == NULL ||
	   (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) == 0 ||
@


1.81
log
@Kill some commented out in6_ifstat_inc().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.80 2015/08/31 07:17:12 mpi Exp $	*/
a290 1
		in6_ifstat_inc(rt->rt_ifp, ifs6_in_discard);
a431 1
		in6_ifstat_inc(rt->rt_ifp, ifs6_in_toobig);
a444 1
		in6_ifstat_inc(rt->rt_ifp, ifs6_out_discard);
a447 1
		in6_ifstat_inc(rt->rt_ifp, ifs6_out_forward);
@


1.80
log
@`encif' should only be used under #ifdef NPF.

Reported by jsg@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.79 2015/07/16 21:14:21 mpi Exp $	*/
a117 1
		/* XXX in6_ifstat_inc(rt->rt_ifp, ifs6_in_discard) */
a133 1
		/* XXX in6_ifstat_inc(rt->rt_ifp, ifs6_in_discard) */
a242 1
			/* XXX in6_ifstat_inc(rt->rt_ifp, ifs6_in_noroute) */
a269 1
			/* XXX in6_ifstat_inc(rt->rt_ifp, ifs6_in_noroute) */
@


1.79
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.78 2015/07/08 08:48:35 mpi Exp $	*/
d349 1
a350 2
		in6_proto_cksum_out(m, encif);

@


1.78
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.77 2015/06/30 15:30:17 mpi Exp $	*/
d334 1
a334 1
		    pf_test(AF_INET6, PF_FWD, encif, &m, NULL) != PF_PASS) {
d416 1
a416 1
	if (pf_test(AF_INET6, PF_FWD, rt->rt_ifp, &m, NULL) != PF_PASS) {
@


1.77
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.76 2015/06/16 11:09:40 mpi Exp $	*/
d291 2
a292 2
	if (in6_addr2scopeid(if_get(m->m_pkthdr.ph_ifidx), &ip6->ip6_src) !=
	    in6_addr2scopeid(rt->rt_ifp, &ip6->ip6_src)) {
@


1.76
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.75 2015/06/08 22:19:28 krw Exp $	*/
d151 2
a152 1
	mcopy = m_copy(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN));
@


1.75
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.74 2015/05/23 12:52:59 markus Exp $	*/
d125 1
a125 1
			    "from %s to %s nxt %d received on %s\n",
d128 1
a128 1
			    m->m_pkthdr.rcvif->if_xname);
d290 1
a290 1
	if (in6_addr2scopeid(m->m_pkthdr.rcvif, &ip6->ip6_src) !=
d302 1
a302 1
			    "src %s, dst %s, nxt %d, rcvif %s, outif %s\n",
d305 1
a305 1
			    m->m_pkthdr.rcvif->if_xname, rt->rt_ifp->if_xname);
d372 2
a373 1
	if (rt->rt_ifp == m->m_pkthdr.rcvif && !srcrt && ip6_sendredirects &&
@


1.74
log
@remove PACKET_TAG_IPSEC_PENDING_TDB, it is never set; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.73 2015/04/17 11:04:02 mikeb Exp $	*/
d227 1
a227 1
		if (ip6_forward_rt.ro_rt == 0 ||
d242 1
a242 1
		if (ip6_forward_rt.ro_rt == 0) {
d252 1
a252 1
	} else if (ip6_forward_rt.ro_rt == 0 ||
d270 1
a270 1
		if (ip6_forward_rt.ro_rt == 0) {
d413 1
a413 1
#if NPF > 0 
d431 1
a431 1
#endif 
@


1.73
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.72 2015/03/14 03:38:52 jsg Exp $	*/
d167 2
a168 16
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip6_forward: tag of length %hu (should be %zu",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
#endif
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst,
		    tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	} else
		tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
		    &error, IPSP_DIRECTION_OUT, NULL, NULL, 0);
@


1.72
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.71 2014/12/05 15:50:04 mpi Exp $	*/
d209 1
a209 3
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
@


1.71
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.70 2014/11/20 13:54:24 mpi Exp $	*/
a68 1
#include <net/pfkeyv2.h>
@


1.70
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.69 2014/10/14 09:52:26 mpi Exp $	*/
d47 1
@


1.69
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.68 2014/09/27 12:26:16 mpi Exp $	*/
a93 1
	struct ifnet *origifp;	/* maybe unnecessary */
a423 30
	if ((rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
		/*
		 * See corresponding comments in ip6_output.
		 * XXX: but is it possible that ip6_forward() sends a packet
		 *      to a loopback interface? I don't think so, and thus
		 *      I bark here. (jinmei@@kame.net)
		 * XXX: it is common to route invalid packets to loopback.
		 *	also, the codepath will be visited on use of ::1 in
		 *	rthdr. (itojun)
		 */
#if 1
		if (0)
#else
		if ((rt->rt_flags & (RTF_BLACKHOLE|RTF_REJECT)) == 0)
#endif
		{
			inet_ntop(AF_INET6, &ip6->ip6_src, src6, sizeof(src6));
			inet_ntop(AF_INET6, &ip6->ip6_dst, dst6, sizeof(dst6));
			printf("ip6_forward: outgoing interface is loopback. "
			       "src %s, dst %s, nxt %d, rcvif %s, outif %s\n",
			       src6, dst6,
			       ip6->ip6_nxt, m->m_pkthdr.rcvif->if_xname,
			       rt->rt_ifp->if_xname);
		}

		/* we can just use rcvif in forwarding. */
		origifp = m->m_pkthdr.rcvif;
	}
	else
		origifp = rt->rt_ifp;
d464 1
a464 1
	error = nd6_output(rt->rt_ifp, origifp, m, dst, rt);
@


1.68
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.67 2014/06/03 13:32:24 mpi Exp $	*/
d248 2
a249 2
				RTFREE(ip6_forward_rt.ro_rt);
				ip6_forward_rt.ro_rt = 0;
d274 2
a275 2
			RTFREE(ip6_forward_rt.ro_rt);
			ip6_forward_rt.ro_rt = 0;
d549 2
a550 2
		RTFREE(ip6_forward_rt.ro_rt);
		ip6_forward_rt.ro_rt = 0;
@


1.67
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.66 2014/05/06 09:49:58 gerhard Exp $	*/
d253 4
a256 2
			rtalloc_mpath((struct route *)&ip6_forward_rt,
			    &ip6->ip6_src.s6_addr32[0]);
d282 4
a285 3

		rtalloc_mpath((struct route *)&ip6_forward_rt,
		    &ip6->ip6_src.s6_addr32[0]);
@


1.66
log
@Fix a memleak when lookup of SA fails during forwarding of encrypted IPv6
pakets.

ok mpi@@ markus@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.65 2014/04/14 09:06:42 mpi Exp $	*/
a36 1
#include <sys/malloc.h>
@


1.65
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.64 2014/01/29 00:50:56 dlg Exp $	*/
d204 1
@


1.64
log
@move the allocation of the mbuf copy to use for sending icmp errors
above the reroute label that pf uses after it does dest addr rewriting
on outgoing packets. previously rerouting caused an extra copy to
be allocated, which caused the first copy to be leaked.

this has been bugging me for over half a year probably. after i got
some rudimental mbuf tracing in place it took me and alex wilson
most of a work day to audit the stack.

ok claudio@@ on an earlier diff
ok mpi@@, who made my first diff better and was gracious enough to
let me commit his because of the pain id been through finding this
leak.
ok pelikan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.63 2013/11/11 09:15:35 mpi Exp $	*/
d236 1
a236 1
	rtableid = m->m_pkthdr.rdomain;
d336 1
a336 1
		tdb = gettdb(rtable_l2(m->m_pkthdr.rdomain),
@


1.63
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.62 2013/10/17 16:27:46 bluhm Exp $	*/
d144 11
a237 11

	/*
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
	 *
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
	 */
	mcopy = m_copy(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN));
@


1.62
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.61 2013/07/31 15:41:52 mikeb Exp $	*/
d108 1
d123 2
d128 1
a128 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
d312 2
d317 1
a317 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
d438 2
d442 1
a442 2
			       ip6_sprintf(&ip6->ip6_src),
			       ip6_sprintf(&ip6->ip6_dst),
@


1.61
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.60 2013/07/04 19:10:41 sf Exp $	*/
a51 1
#include <netinet/in_var.h>
d53 1
@


1.60
log
@format string fixes: size_t and uint16_t

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.59 2013/06/26 09:12:40 henning Exp $	*/
a102 1
	int s;
a149 2
	s = splnet();

a173 2
	        splx(s);

a206 1
				splx(s);
a215 1
	        splx(s);
a332 2
		s = splnet();

a335 1
			splx(s);
a344 1
			splx(s);
d349 1
a349 2
		if (m == NULL) {
			splx(s);
a350 1
		}
a365 1
		splx(s);
@


1.59
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.58 2013/05/31 15:04:24 bluhm Exp $	*/
d163 1
a163 1
			panic("ip6_forward: tag of length %d (should be %d",
@


1.58
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.57 2012/11/06 12:32:42 henning Exp $	*/
d373 1
a473 1

d486 1
@


1.57
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.56 2012/11/05 21:49:15 claudio Exp $	*/
d385 1
a385 1
		dst = (struct sockaddr_in6 *)rt->rt_gateway;
d399 1
a399 1
		    nd6_is_addr_neighbor((struct sockaddr_in6 *)&ip6_forward_rt.ro_dst, rt->rt_ifp)) {
@


1.56
log
@Make sure that in[6]_proto_cksum_out() is called unconditinally and not
inside the NPF block. Fixes checksum issues seen on ramdisk kernels.
Initial diff by naddy@@, tested and OK by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.55 2012/11/01 07:55:56 henning Exp $	*/
a372 1
		in6_proto_cksum_out(m, encif);
d473 1
a485 1
	in6_proto_cksum_out(m, rt->rt_ifp);
@


1.55
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.53 2011/07/04 06:54:49 claudio Exp $	*/
a363 1
		in6_proto_cksum_out(m, encif);
d373 1
a473 1
	in6_proto_cksum_out(m, rt->rt_ifp);
d486 1
@


1.54
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d364 1
d474 1
a474 1

@


1.53
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.52 2011/03/24 20:09:45 bluhm Exp $	*/
d174 1
a174 1
		    &error, IPSP_DIRECTION_OUT, NULL, NULL);
@


1.52
log
@Reassemble IPv6 fragments in pf.  In the forward case, pf refragments
the packets with the same maximum size.  This allows the sender to
determine the optimal fragment size by Path MTU Discovery.
testing sthen@@ matthieu@@
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.51 2011/03/23 09:26:12 bluhm Exp $	*/
d354 1
a354 1
		    pf_test6(PF_FWD, encif, &m, NULL) != PF_PASS) {
d467 1
a467 1
	if (pf_test6(PF_FWD, rt->rt_ifp, &m, NULL) != PF_PASS) {
d487 1
a487 1
	/* Check the size after pf_test6 to give pf a chance to refragment. */
@


1.51
log
@With pf IPv6 fragment reassembly, a large packet gets refragmented
by pf in the forward path.  To avoid dropping the unfragmented
packet in ip6_forward(), move the MTU size check behind pf_test6().
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.50 2011/01/09 20:25:46 bluhm Exp $	*/
d354 1
a354 1
		    pf_test6(PF_OUT, encif, &m, NULL) != PF_PASS) {
d467 1
a467 1
	if (pf_test6(PF_OUT, rt->rt_ifp, &m, NULL) != PF_PASS) {
@


1.50
log
@In ip6_forward() only one call to icmp6_error() was not protected
by an if (mcopy).  The variable mcopy comes from m_copy() and could
be NULL.  Bring this call in line with all the other icmp6_error()
calls.
ok henning@@, claudio@@, markus@@, mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.49 2010/07/09 16:58:06 reyk Exp $	*/
a383 13
	if (m->m_pkthdr.len > IN6_LINKMTU(rt->rt_ifp)) {
		in6_ifstat_inc(rt->rt_ifp, ifs6_in_toobig);
		if (mcopy) {
			u_long mtu;

			mtu = IN6_LINKMTU(rt->rt_ifp);

			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0, mtu);
		}
		m_freem(m);
		goto freert;
	}

d486 14
@


1.49
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.48 2010/07/01 02:09:45 reyk Exp $	*/
d428 2
a429 1
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
@


1.48
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.47 2010/06/29 21:28:38 reyk Exp $	*/
d167 2
a168 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d209 1
d342 2
a343 1
		tdb = gettdb(sspi, &sdst, sproto);
d352 2
a353 1
		if ((encif = enc_getif(0, tdb->tdb_tap)) == NULL ||
@


1.47
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.45 2009/11/03 10:59:04 claudio Exp $	*/
d340 8
d349 1
a349 1
		if ((encif = enc_getif(0)) == NULL ||
a368 7
		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			splx(s);
			error = EHOSTUNREACH;
			m_freem(m);
			goto senderr;	/*XXX*/
		}
@


1.46
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d104 3
d341 2
a342 1
		if (pf_test6(PF_OUT, &encif[0].sc_if, &m, NULL) != PF_PASS) {
@


1.45
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.44 2009/10/06 21:21:48 claudio Exp $	*/
a72 1
u_int	ip6_forward_rtableid;
d246 1
a246 1
		    ip6_forward_rtableid != rtableid) {
d252 1
d254 1
a254 2
			    &ip6->ip6_src.s6_addr32[0], rtableid);
			ip6_forward_rtableid = rtableid;
d270 1
a270 1
	   ip6_forward_rtableid != rtableid) {
d279 1
d282 1
a282 2
		    &ip6->ip6_src.s6_addr32[0], rtableid);
		ip6_forward_rtableid = rtableid;
@


1.44
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.43 2009/05/18 20:37:13 bluhm Exp $	*/
d226 1
a226 1
	rtableid = m->m_pkthdr.pf.rtableid;
@


1.43
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.42 2008/11/23 13:30:59 claudio Exp $	*/
d141 4
d270 2
a271 1
	   !IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &dst->sin6_addr)) {
d282 2
a283 1
		    &ip6->ip6_src.s6_addr32[0], 0);
d350 7
d479 10
@


1.42
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.41 2008/10/22 14:36:08 markus Exp $	*/
d73 1
a73 1
int	ip6_forward_rtableid;
d106 1
a106 1
	int rtableid = 0;
@


1.41
log
@filter ipv6 ipsec packets on enc0 (in and out), similar to ipv4;
ok bluhm, fries, mpf; fixes pr 4188
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.40 2008/06/11 19:00:50 mcbride Exp $	*/
d264 3
a266 2
	} else if ((rt = ip6_forward_rt.ro_rt) == 0 ||
		 !IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &dst->sin6_addr)) {
@


1.40
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.39 2007/06/01 00:52:38 henning Exp $	*/
d48 1
d331 13
@


1.39
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.38 2007/05/28 17:16:39 henning Exp $	*/
d88 1
a88 3
ip6_forward(m, srcrt)
	struct mbuf *m;
	int srcrt;
@


1.38
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.37 2006/11/27 12:27:45 henning Exp $	*/
d143 3
@


1.37
log
@make use of multiple routing tables.
hook up looking up routes in alternate tables to the packet forwarding path.
alternate routing tables are mintained with route(8), table selection via pf.
mostly hacked on a train ride with ryan some time ago, ok mcbride claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.36 2006/11/17 01:11:23 itojun Exp $	*/
a106 3
#if NPF > 0
	struct pf_mtag *pft;
#endif
d220 1
a220 2
	if ((pft = pf_find_mtag(m)) != NULL)
		rtableid = pft->rtableid;
@


1.36
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.35 2006/06/18 11:47:46 pascoe Exp $	*/
d72 1
d107 4
d222 5
d244 2
a245 1
		    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) == 0) {
d252 2
a253 1
			    &ip6->ip6_src.s6_addr32[0], 0);
@


1.35
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.34 2004/07/14 20:19:58 dhartmei Exp $	*/
d428 1
a428 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d430 1
a430 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
@


1.34
log
@completely revert to r1.31, there were still problems on the forwarding
path
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.33 2004/07/12 00:50:22 itojun Exp $	*/
d240 2
a241 1
			rtalloc((struct route *)&ip6_forward_rt);
d265 2
a266 1
		rtalloc((struct route *)&ip6_forward_rt);
d308 1
a308 1
		return;
d335 1
a335 1
		return;  /* Nothing more to be done */
d349 1
a349 1
		return;
d386 1
a386 1
			return;
d463 1
a463 1
		return;
d468 1
a468 1
			return;
d490 1
a490 1
	return;
d494 8
@


1.33
log
@remove PF_FORWARD (which was introduced by ipv6 reass-on-scrub).
daniel found it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.32 2004/06/25 00:42:58 itojun Exp $	*/
d438 2
d442 12
a453 19
#if NPF > 0
	for (; m; m = m->m_nextpkt)
#else
	if (1)
#endif
	{
		error = nd6_output(rt->rt_ifp, origifp, m, dst, rt);
		if (error) {
			in6_ifstat_inc(rt->rt_ifp, ifs6_out_discard);
			ip6stat.ip6s_cantforward++;
		} else {
			ip6stat.ip6s_forward++;
			in6_ifstat_inc(rt->rt_ifp, ifs6_out_forward);
			if (type)
				ip6stat.ip6s_redirectsent++;
			else {
				if (mcopy)
					goto freecopy;
			}
@


1.32
log
@IPv6 reassembly on "scrub" directive.

caveats: (to be addressed soon)
- "scrub in" should queue fragments back into ip6intrq again, but
  somehow it does not happen - the packet is kept inside reass queue.
  need investigation
- ip6_forwarding path is not tested
- does not use red-black tree.  somehow red-black tree behaved badly
  and was not robust.  performance issue, the above one is more
  important.

good things:
- "scrub out" is perfectly ok
- i think now we can inspect upper-layer protocol fields (tcp port)
  even if ip6 packet is fragmented.
- reass queue will be cleaned up properly by timeout (60sec).  we might
  want to impose pool limit as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.31 2004/06/24 15:01:32 itojun Exp $	*/
d432 1
a432 1
	if (pf_test6(PF_FORWARD, rt->rt_ifp, &m, NULL) != PF_PASS) {
@


1.31
log
@"error" could be left uninitialized
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.30 2004/06/21 23:50:37 tholo Exp $	*/
d432 1
a432 1
	if (pf_test6(PF_OUT, rt->rt_ifp, &m, NULL) != PF_PASS) {
a437 2

	ip6 = mtod(m, struct ip6_hdr *);
d440 19
a458 12
	error = nd6_output(rt->rt_ifp, origifp, m, dst, rt);
	if (error) {
		in6_ifstat_inc(rt->rt_ifp, ifs6_out_discard);
		ip6stat.ip6s_cantforward++;
	} else {
		ip6stat.ip6s_forward++;
		in6_ifstat_inc(rt->rt_ifp, ifs6_out_forward);
		if (type)
			ip6stat.ip6s_redirectsent++;
		else {
			if (mcopy)
				goto freecopy;
@


1.30
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.29 2004/06/21 19:26:02 mcbride Exp $	*/
d94 1
a94 1
	int error, type = 0, code = 0;
@


1.29
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.28 2004/02/02 20:13:01 cedric Exp $	*/
d118 2
a119 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
d292 2
a293 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
@


1.28
log
@make the stack compile if NPF=0. ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.27 2003/08/07 09:11:53 itojun Exp $	*/
d432 1
a432 1
	if (pf_test6(PF_OUT, rt->rt_ifp, &m) != PF_PASS) {
@


1.27
log
@make net.inet6.ip6.redirect actually work.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.26 2003/06/24 07:47:54 itojun Exp $	*/
d63 1
d457 1
a457 1
#if NPF > 0
@


1.26
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.25 2003/05/15 05:37:39 todd Exp $	*/
d361 1
a361 1
	if (rt->rt_ifp == m->m_pkthdr.rcvif && !srcrt &&
@


1.25
log
@IPv6 IPsec gateway now functions; patch by itojun, tested by myself and vincent
closes pr 3231
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.24 2002/06/09 14:38:39 itojun Exp $	*/
a94 1
	long time_second = time.tv_sec;
d117 2
a118 2
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
d291 2
a292 2
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
@


1.24
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.23 2002/06/08 21:22:03 itojun Exp $	*/
d62 7
a68 5
#ifdef IPSEC_IPV6FWD
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif /* IPSEC_IPV6FWD */
d97 9
a105 19

#ifdef IPSEC_IPV6FWD
	struct secpolicy *sp = NULL;
#endif

#ifdef IPSEC_IPV6FWD
	/*
	 * Check AH/ESP integrity.
	 */
	/*
	 * Don't increment ip6s_cantforward because this is the check
	 * before forwarding packet actually.
	 */
	if (ipsec6_in_reject(m, NULL)) {
		ipsec6stat.in_polvio++;
		m_freem(m);
		return;
	}
#endif /*IPSEC_IPV6FWD*/
d140 3
d144 2
a145 7
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
	 *
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
a146 1
	mcopy = m_copy(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN));
d148 7
a154 11
#ifdef IPSEC_IPV6FWD
	/* get a security policy for this packet */
	sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_OUTBOUND, 0, &error);
	if (sp == NULL) {
		ipsec6stat.out_inval++;
		ip6stat.ip6s_cantforward++;
		if (mcopy) {
#if 0
			/* XXX: what icmp ? */
#else
			m_freem(mcopy);
d156 18
a173 4
		}
		m_freem(m);
		return;
	}
d175 9
a183 1
	error = 0;
d185 1
a185 15
	/* check policy */
	switch (sp->policy) {
	case IPSEC_POLICY_DISCARD:
		/*
		 * This packet is just discarded.
		 */
		ipsec6stat.out_polvio++;
		ip6stat.ip6s_cantforward++;
		key_freesp(sp);
		if (mcopy) {
#if 0
			/* XXX: what icmp ? */
#else
			m_freem(mcopy);
#endif
d187 16
a202 21
		m_freem(m);
		return;

	case IPSEC_POLICY_BYPASS:
	case IPSEC_POLICY_NONE:
		/* no need to do IPsec. */
		key_freesp(sp);
		goto skip_ipsec;

	case IPSEC_POLICY_IPSEC:
		if (sp->req == NULL) {
			/* XXX should be panic ? */
			printf("ip6_forward: No IPsec request specified.\n");
			ip6stat.ip6s_cantforward++;
			key_freesp(sp);
			if (mcopy) {
#if 0
				/* XXX: what icmp ? */
#else
				m_freem(mcopy);
#endif
a203 2
			m_freem(m);
			return;
a204 2
		/* do IPsec */
		break;
d206 5
a210 6
	case IPSEC_POLICY_ENTRUST:
	default:
		/* should be panic ?? */
		printf("ip6_forward: Invalid policy found. %d\n", sp->policy);
		key_freesp(sp);
		goto skip_ipsec;
d213 3
a215 2
    {
	struct ipsec_output_state state;
d218 4
a221 4
	 * All the extension headers will become inaccessible
	 * (since they can be encrypted).
	 * Don't panic, we need no more updates to extension headers
	 * on inner IPv6 packet (since they are now encapsulated).
d223 2
a224 1
	 * IPv6 [ESP|AH] IPv6 [extension headers] payload
d226 1
a226 44
	bzero(&state, sizeof(state));
	state.m = m;
	state.ro = NULL;	/* update at ipsec6_output_tunnel() */
	state.dst = NULL;	/* update at ipsec6_output_tunnel() */

	error = ipsec6_output_tunnel(&state, sp, 0);

	m = state.m;
#if 0	/* XXX allocate a route (ro, dst) again later */
	ro = (struct route_in6 *)state.ro;
	dst = (struct sockaddr_in6 *)state.dst;
#endif
	key_freesp(sp);

	if (error) {
		/* mbuf is already reclaimed in ipsec6_output_tunnel. */
		switch (error) {
		case EHOSTUNREACH:
		case ENETUNREACH:
		case EMSGSIZE:
		case ENOBUFS:
		case ENOMEM:
			break;
		default:
			printf("ip6_output (ipsec): error code %d\n", error);
			/* FALLTHROUGH */
		case ENOENT:
			/* don't show these error codes to the user */
			break;
		}
		ip6stat.ip6s_cantforward++;
		if (mcopy) {
#if 0
			/* XXX: what icmp ? */
#else
			m_freem(mcopy);
#endif
		}
		m_freem(m);
		return;
	}
    }
    skip_ipsec:
#endif /* IPSEC_IPV6FWD */
d309 28
a340 5
#ifdef IPSEC_IPV6FWD
			struct secpolicy *sp;
			int ipsecerror;
			size_t ipsechdrsiz;
#endif
a342 16
#ifdef IPSEC_IPV6FWD
			/*
			 * When we do IPsec tunnel ingress, we need to play
			 * with the link value (decrement IPsec header size
			 * from mtu value).  The code is much simpler than v4
			 * case, as we have the outgoing interface for
			 * encapsulated packet as "rt->rt_ifp".
			 */
			sp = ipsec6_getpolicybyaddr(mcopy, IPSEC_DIR_OUTBOUND,
				IP_FORWARDING, &ipsecerror);
			if (sp) {
				ipsechdrsiz = ipsec6_hdrsiz(mcopy,
					IPSEC_DIR_OUTBOUND, NULL);
				if (ipsechdrsiz < mtu)
					mtu -= ipsechdrsiz;
			}
a343 7
			/*
			 * if mtu becomes less than minimum MTU,
			 * tell minimum MTU (and I'll need to fragment it).
			 */
			if (mtu < IPV6_MMTU)
				mtu = IPV6_MMTU;
#endif
@


1.23
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.22 2002/06/07 04:13:10 itojun Exp $	*/
d406 1
a406 1
 	}
@


1.22
log
@'fall through' is not a valid LINT keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.21 2002/05/29 07:54:59 itojun Exp $	*/
a521 1
#if 1
a525 1
#endif
@


1.21
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.20 2001/12/07 09:16:07 itojun Exp $	*/
d266 1
a266 1
			/* fall through */
@


1.20
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.19 2001/11/30 07:59:17 itojun Exp $	*/
d367 1
a367 1
	if (m->m_pkthdr.len > rt->rt_ifp->if_mtu) {
d377 1
a377 1
			mtu = rt->rt_ifp->if_mtu;
d381 1
a381 1
			 * with if_mtu value (decrement IPsec header size
@


1.20.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.20 2001/12/07 09:16:07 itojun Exp $	*/
d266 1
a266 1
			/* FALLTHROUGH */
d367 1
a367 1
	if (m->m_pkthdr.len > IN6_LINKMTU(rt->rt_ifp)) {
d377 1
a377 1
			mtu = IN6_LINKMTU(rt->rt_ifp);
d381 1
a381 1
			 * with the link value (decrement IPsec header size
d522 1
d527 1
@


1.20.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.20.2.1 2002/06/11 03:31:37 art Exp $	*/
d406 1
a406 1
	}
@


1.20.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d62 5
a66 7
#ifdef IPSEC
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <net/pfkeyv2.h>
#endif
d95 19
a113 9
#ifdef IPSEC
	u_int8_t sproto = 0;
	struct m_tag *mtag;
	union sockaddr_union sdst;
	struct tdb_ident *tdbi;
	u_int32_t sspi;
	struct tdb *tdb;
	int s;
#endif /* IPSEC */
a147 3
#ifdef IPSEC
	s = splnet();

d149 7
a155 2
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
d157 1
d159 11
a169 7
	/* Do we have any pending SAs to apply ? */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip6_forward: tag of length %d (should be %d",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
d171 4
a174 18
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	} else
		tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
		    &error, IPSP_DIRECTION_OUT, NULL, NULL);

	if (tdb == NULL) {
	        splx(s);

		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;
d176 1
a176 9
			/* Fall through to routing/multicast handling */
		} else {
		        /*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
		        if (error == -EINVAL) /* Should silently drop packet */
				error = 0;
d178 15
a192 1
			goto freecopy;
d194 21
a214 16
	} else {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				splx(s);
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
d216 2
d219 2
d222 6
a227 5
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
	        splx(s);
d230 2
a231 3
	/* Fall through to the routing/multicast handling code */
 done_spd:
#endif /* IPSEC */
d234 4
a237 4
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
d239 1
a239 2
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
d241 44
a284 1
	mcopy = m_copy(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN));
a366 28
#ifdef IPSEC
	/*
	 * Check if the packet needs encapsulation.
	 * ipsp_process_packet will never come back to here.
	 * XXX ipsp_process_packet() calls ip6_output(), and there'll be no
	 * PMTU notification.  is it okay?
	 */
	if (sproto != 0) {
		s = splnet();

		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			splx(s);
			error = EHOSTUNREACH;
			m_freem(m);
			goto senderr;	/*XXX*/
		}

		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

		/* Callee frees mbuf */
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
		splx(s);
		m_freem(mcopy);
		return;  /* Nothing more to be done */
	}
#endif /* IPSEC */

d371 5
d378 16
d395 7
@


1.19
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.18 2001/11/26 16:50:26 jasoni Exp $	*/
d266 1
a266 1
			/*fall through*/
a519 1

@


1.18
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.17 2001/09/29 08:02:07 jasoni Exp $	*/
a499 5
#ifdef OLDIP6OUTPUT
	error = (*rt->rt_ifp->if_output)(rt->rt_ifp, m,
					 (struct sockaddr *)dst,
					 ip6_forward_rt.ro_rt);
#else
a500 1
#endif
@


1.17
log
@filter forwarded ipv6 packets; checked by itojun, tested by
mcbride@@countersiege.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.16 2001/07/18 09:56:49 itojun Exp $	*/
d490 1
a490 1
        if (pf_test6(PF_OUT, rt->rt_ifp, &m) != PF_PASS) {
d494 3
@


1.16
log
@sync with draft-ietf-ipngwg-p2p-pingpong-00.txt.  apply special behavior
only if ip6_dst is "neighbor" within p2p prefix.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.15 2001/06/22 12:30:34 itojun Exp $	*/
d33 2
d58 4
d489 8
d517 4
@


1.15
log
@do not forward packet back into point-to-point link, if the packet has
destination address that matches the p2p interface.  this would
lead us to pingpong (= chews bandwidth, can be attacked from remote).
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.14 2001/06/09 06:43:38 angelos Exp $	*/
/*	$KAME: ip6_forward.c,v 1.74 2001/06/12 23:54:55 itojun Exp $	*/
d416 2
a417 1
		if ((rt->rt_ifp->if_flags & IFF_POINTOPOINT) != 0) {
d420 10
a429 5
			 * one, and the link attached to the interface is
			 * point-to-point, then it will be highly probable
			 * that a routing loop occurs. Thus, we immediately
			 * drop the packet and send an ICMPv6 error message.
			 *
@


1.14
log
@No need for net/net_osdep.h
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.13 2001/03/30 11:09:00 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.67 2001/03/29 05:34:31 itojun Exp $	*/
d415 17
a431 1
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0)
d433 1
@


1.13
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.12 2001/02/16 16:38:14 itojun Exp $	*/
a61 2
#include <net/net_osdep.h>

d128 1
a128 1
			    if_name(m->m_pkthdr.rcvif));
d352 1
a352 1
			    if_name(m->m_pkthdr.rcvif), if_name(rt->rt_ifp));
d446 2
a447 2
			       ip6->ip6_nxt, if_name(m->m_pkthdr.rcvif),
			       if_name(rt->rt_ifp));
@


1.12
log
@get rid of #ifdef IPV6FIREWALL (never used, will never be used)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.11 2001/02/16 08:48:05 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.44 2000/07/27 13:43:21 itojun Exp $	*/
d452 2
a453 6
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			origifp = ifindex2ifnet[ntohs(ip6->ip6_src.s6_addr16[1])];
		else if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			origifp = ifindex2ifnet[ntohs(ip6->ip6_dst.s6_addr16[1])];
		else
			origifp = rt->rt_ifp;
d457 4
a460 11
#ifndef FAKE_LOOPBACK_IF
	if ((rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
#else
	if (1)
#endif
	{
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;
	}
@


1.11
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.10 2001/02/16 08:22:06 itojun Exp $	*/
a418 16

#ifdef IPV6FIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip6_fw_chk_ptr) {
		u_short port = 0;
		/* If ipfw says divert, we have to just drop packet */
		if ((*ip6_fw_chk_ptr)(&ip6, rt->rt_ifp, &port, &m)) {
			m_freem(m);
			goto freecopy;
		}
		if (!m)
			goto freecopy;
	}
#endif
@


1.10
log
@kill register declarations.  to sync with kame better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.9 2000/07/27 16:05:07 itojun Exp $	*/
d441 2
a442 2
	 * link identifiers, we can do this stuff after make a copy for
	 * returning error.
@


1.9
log
@do not forward packet with :: in the source.
this is not in the spec - we had rough consensus on it in ipngwg,
spec will get updated to include this behavior.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.8 2000/06/30 19:45:36 itojun Exp $	*/
d85 2
a86 2
	register struct sockaddr_in6 *dst;
	register struct rtentry *rt;
@


1.8
log
@suppress too noisy warning on forward-over-loopback case.  from kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.7 2000/06/03 13:42:33 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.38 2000/06/22 21:02:05 itojun Exp $	*/
d111 6
d118 2
a119 1
	    IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
@


1.7
log
@do not bark even if forwarding to loopback, since it is common
to route packet to be rejected/dropped to loopback. (sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.6 2000/05/19 20:12:10 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.37 2000/05/28 12:17:19 itojun Exp $	*/
d191 1
a191 1
	
d289 1
a289 1
		
d444 2
a445 1
		 *	(itojun)
d447 6
a452 2

		if ((rt->rt_flags & (RTF_BLACKHOLE|RTF_REJECT)) == 0) {
d460 1
a460 1
		       
@


1.6
log
@correct "telnet fe80::1%lo0".
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.5 2000/05/19 13:55:16 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.36 2000/05/19 19:10:06 itojun Exp $	*/
d443 2
d446 9
a454 5
		printf("ip6_forward: outgoing interface is loopback. "
		       "src %s, dst %s, nxt %d, rcvif %s, outif %s\n",
		       ip6_sprintf(&ip6->ip6_src), ip6_sprintf(&ip6->ip6_dst),
		       ip6->ip6_nxt, if_name(m->m_pkthdr.rcvif),
		       if_name(rt->rt_ifp));
@


1.5
log
@never forward packet with link-local address.
experimental support for new loopback packet handling (with FAKE_LOOPBACK_IF,
rcvif will be set to real outgoing interface, not the loopback, to honor scope)
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.4 2000/02/28 11:55:22 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.35 2000/05/18 16:31:27 itojun Exp $	*/
d460 1
a460 1
	if ((rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0)
@


1.4
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.3 2000/02/07 06:09:10 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.29 2000/02/26 18:08:38 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d90 1
d385 1
a385 1
			 * if mtu becomes less than minimum MTU, 
d429 42
d476 2
a477 2
	error = nd6_output(rt->rt_ifp, m, dst, rt);
#endif 
@


1.3
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_forward.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d50 1
a55 2
#undef IPSEC

a61 4
#ifdef IPV6FIREWALL
#include <netinet6/ip6_fw.h>
#endif

d110 2
a111 2
	if (m->m_flags & (M_BCAST|M_MCAST) ||
	   in6_canforward(&ip6->ip6_src, &ip6->ip6_dst) == 0) {
a112 1
		ip6stat.ip6s_badscope++;
a114 1
			char addr[INET6_ADDRSTRLEN];
a115 1
			strncpy(addr, ip6_sprintf(&ip6->ip6_src), sizeof(addr));
d119 2
a120 1
			    addr, ip6_sprintf(&ip6->ip6_dst),
d324 32
a355 1
	if (m->m_pkthdr.len > rt->rt_ifp->if_mtu){
d358 9
a367 1
			 * XXX
d370 3
a372 1
			 * from mtu value).  see ip_input().
d374 17
a390 2
			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0,
				rt->rt_ifp->if_mtu);
@


1.3.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: ip6_forward.c,v 1.29 2000/02/26 18:08:38 itojun Exp $	*/
a48 1
#include <netinet/ip_var.h>
d54 2
d62 4
d114 2
a115 2
	if ((m->m_flags & (M_BCAST|M_MCAST)) != 0 ||
	    IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
d117 1
d120 1
d122 1
d126 1
a126 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
d330 1
a330 32

	/*
	 * Scope check: if a packet can't be delivered to its destination
	 * for the reason that the destination is beyond the scope of the
	 * source address, discard the packet and return an icmp6 destination
	 * unreachable error with Code 2 (beyond scope of source address).
	 * [draft-ietf-ipngwg-icmp-v3-00.txt, Section 3.1]
	 */
	if (in6_addr2scopeid(m->m_pkthdr.rcvif, &ip6->ip6_src) !=
	    in6_addr2scopeid(rt->rt_ifp, &ip6->ip6_src)) {
		ip6stat.ip6s_cantforward++;
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(rt->rt_ifp, ifs6_in_discard);

		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
			log(LOG_DEBUG,
			    "cannot forward "
			    "src %s, dst %s, nxt %d, rcvif %s, outif %s\n",
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    ip6->ip6_nxt,
			    if_name(m->m_pkthdr.rcvif), if_name(rt->rt_ifp));
		}
		if (mcopy)
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_BEYONDSCOPE, 0);
		m_freem(m);
		return;
	}

	if (m->m_pkthdr.len > rt->rt_ifp->if_mtu) {
a332 9
			u_long mtu;
#ifdef IPSEC_IPV6FWD
			struct secpolicy *sp;
			int ipsecerror;
			size_t ipsechdrsiz;
#endif

			mtu = rt->rt_ifp->if_mtu;
#ifdef IPSEC_IPV6FWD
d334 1
d337 1
a337 3
			 * from mtu value).  The code is much simpler than v4
			 * case, as we have the outgoing interface for
			 * encapsulated packet as "rt->rt_ifp".
d339 2
a340 17
			sp = ipsec6_getpolicybyaddr(mcopy, IPSEC_DIR_OUTBOUND,
				IP_FORWARDING, &ipsecerror);
			if (sp) {
				ipsechdrsiz = ipsec6_hdrsiz(mcopy,
					IPSEC_DIR_OUTBOUND, NULL);
				if (ipsechdrsiz < mtu)
					mtu -= ipsechdrsiz;
			}

			/*
			 * if mtu becomes less than minimum MTU, 
			 * tell minimum MTU (and I'll need to fragment it).
			 */
			if (mtu < IPV6_MMTU)
				mtu = IPV6_MMTU;
#endif
			icmp6_error(mcopy, ICMP6_PACKET_TOO_BIG, 0, mtu);
@


1.3.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.13 2001/03/30 11:09:00 itojun Exp $	*/
/*	$KAME: ip6_forward.c,v 1.67 2001/03/29 05:34:31 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d85 2
a86 2
	struct sockaddr_in6 *dst;
	struct rtentry *rt;
a89 1
	struct ifnet *origifp;	/* maybe unnecessary */
a109 6
	/*
	 * Do not forward packets to multicast destination (should be handled
	 * by ip6_mforward().
	 * Do not forward packets with unspecified source.  It was discussed
	 * in July 2000, on ipngwg mailing list.
	 */
d111 1
a111 2
	    IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
d190 1
a190 1

d288 1
a288 1

d384 1
a384 1
			 * if mtu becomes less than minimum MTU,
d412 1
d414 1
a414 6
	 * Fake scoped addresses. Note that even link-local source or
	 * destinaion can appear, if the originating node just sends the
	 * packet to us (without address resolution for the destination).
	 * Since both icmp6_error and icmp6_redirect_output fill the embedded
	 * link identifiers, we can do this stuff after making a copy for
	 * returning an error.
d416 6
a421 22
	if ((rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
		/*
		 * See corresponding comments in ip6_output.
		 * XXX: but is it possible that ip6_forward() sends a packet
		 *      to a loopback interface? I don't think so, and thus
		 *      I bark here. (jinmei@@kame.net)
		 * XXX: it is common to route invalid packets to loopback.
		 *	also, the codepath will be visited on use of ::1 in
		 *	rthdr. (itojun)
		 */
#if 1
		if (0)
#else
		if ((rt->rt_flags & (RTF_BLACKHOLE|RTF_REJECT)) == 0)
#endif
		{
			printf("ip6_forward: outgoing interface is loopback. "
			       "src %s, dst %s, nxt %d, rcvif %s, outif %s\n",
			       ip6_sprintf(&ip6->ip6_src),
			       ip6_sprintf(&ip6->ip6_dst),
			       ip6->ip6_nxt, if_name(m->m_pkthdr.rcvif),
			       if_name(rt->rt_ifp));
d423 2
a424 3

		/* we can just use rcvif in forwarding. */
		origifp = m->m_pkthdr.rcvif;
d426 1
a426 6
	else
		origifp = rt->rt_ifp;
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;
d433 2
a434 2
	error = nd6_output(rt->rt_ifp, origifp, m, dst, rt);
#endif
@


1.3.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: ip6_forward.c,v 1.74 2001/06/12 23:54:55 itojun Exp $	*/
d62 2
d130 1
a130 1
			    m->m_pkthdr.rcvif->if_xname);
d354 1
a354 1
			    m->m_pkthdr.rcvif->if_xname, rt->rt_ifp->if_xname);
d417 1
a417 17
	    (rt->rt_flags & (RTF_DYNAMIC|RTF_MODIFIED)) == 0) {
		if ((rt->rt_ifp->if_flags & IFF_POINTOPOINT) != 0) {
			/*
			 * If the incoming interface is equal to the outgoing
			 * one, and the link attached to the interface is
			 * point-to-point, then it will be highly probable
			 * that a routing loop occurs. Thus, we immediately
			 * drop the packet and send an ICMPv6 error message.
			 *
			 * type/code is based on suggestion by Rich Draves.
			 * not sure if it is the best pick.
			 */
			icmp6_error(mcopy, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_ADDR, 0);
			m_freem(m);
			return;
		}
a418 1
	}
d448 2
a449 2
			       ip6->ip6_nxt, m->m_pkthdr.rcvif->if_xname,
			       rt->rt_ifp->if_xname);
@


1.3.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_forward.c,v 1.3.2.3 2001/07/04 10:55:22 niklas Exp $	*/
/*	$KAME: ip6_forward.c,v 1.75 2001/06/29 12:42:13 jinmei Exp $	*/
a32 2
#include "pf.h"

a55 4
#if NPF > 0
#include <net/pfvar.h>
#endif

d416 1
a416 2
		if ((rt->rt_ifp->if_flags & IFF_POINTOPOINT) &&
		    nd6_is_addr_neighbor((struct sockaddr_in6 *)&ip6_forward_rt.ro_dst, rt->rt_ifp)) {
d419 5
a423 10
			 * one, the link attached to the interface is
			 * point-to-point, and the IPv6 destination is
			 * regarded as on-link on the link, then it will be
			 * highly probable that the destination address does
			 * not exist on the link and that the packet is going
			 * to loop.  Thus, we immediately drop the packet and
			 * send an ICMPv6 error message.
			 * For other routing loops, we dare to let the packet
			 * go to the loop, so that a remote diagnosing host
			 * can detect the loop by traceroute.
a476 8
#if NPF > 0 
        if (pf_test6(PF_OUT, rt->rt_ifp, &m) != PF_PASS) {
		m_freem(m);
		goto senderr;
	}
	ip6 = mtod(m, struct ip6_hdr *);
#endif 

a496 4

#if NPF > 0
senderr:
#endif
@


1.3.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d490 1
a490 1
	if (pf_test6(PF_OUT, rt->rt_ifp, &m) != PF_PASS) {
a493 3
	if (m == NULL)
		goto senderr;

d497 5
d503 1
@


1.3.2.6
log
@Merge in trunk
@
text
@d266 1
a266 1
			/* fall through */
d520 1
@


1.3.2.7
log
@Sync the SMP branch with 3.3
@
text
@d266 1
a266 1
			/* FALLTHROUGH */
d367 1
a367 1
	if (m->m_pkthdr.len > IN6_LINKMTU(rt->rt_ifp)) {
d377 1
a377 1
			mtu = IN6_LINKMTU(rt->rt_ifp);
d381 1
a381 1
			 * with the link value (decrement IPsec header size
d406 1
a406 1
	}
d522 1
d527 1
@


1.3.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d62 5
a66 7
#ifdef IPSEC
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <net/pfkeyv2.h>
#endif
d95 19
a113 9
#ifdef IPSEC
	u_int8_t sproto = 0;
	struct m_tag *mtag;
	union sockaddr_union sdst;
	struct tdb_ident *tdbi;
	u_int32_t sspi;
	struct tdb *tdb;
	int s;
#endif /* IPSEC */
a147 3
#ifdef IPSEC
	s = splnet();

d149 7
a155 2
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
d157 1
d159 11
a169 7
	/* Do we have any pending SAs to apply ? */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip6_forward: tag of length %d (should be %d",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
d171 4
a174 18
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	} else
		tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
		    &error, IPSP_DIRECTION_OUT, NULL, NULL);

	if (tdb == NULL) {
	        splx(s);

		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;
d176 1
a176 9
			/* Fall through to routing/multicast handling */
		} else {
		        /*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
		        if (error == -EINVAL) /* Should silently drop packet */
				error = 0;
d178 15
a192 1
			goto freecopy;
d194 21
a214 16
	} else {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				splx(s);
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
d216 2
d219 2
d222 6
a227 5
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
	        splx(s);
d230 2
a231 3
	/* Fall through to the routing/multicast handling code */
 done_spd:
#endif /* IPSEC */
d234 4
a237 4
	 * Save at most ICMPV6_PLD_MAXLEN (= the min IPv6 MTU -
	 * size of IPv6 + ICMPv6 headers) bytes of the packet in case
	 * we need to generate an ICMP6 message to the src.
	 * Thanks to M_EXT, in most cases copy will not occur.
d239 1
a239 2
	 * It is important to save it before IPsec processing as IPsec
	 * processing may modify the mbuf.
d241 44
a284 1
	mcopy = m_copy(m, 0, imin(m->m_pkthdr.len, ICMPV6_PLD_MAXLEN));
a366 28
#ifdef IPSEC
	/*
	 * Check if the packet needs encapsulation.
	 * ipsp_process_packet will never come back to here.
	 * XXX ipsp_process_packet() calls ip6_output(), and there'll be no
	 * PMTU notification.  is it okay?
	 */
	if (sproto != 0) {
		s = splnet();

		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			splx(s);
			error = EHOSTUNREACH;
			m_freem(m);
			goto senderr;	/*XXX*/
		}

		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

		/* Callee frees mbuf */
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
		splx(s);
		m_freem(mcopy);
		return;  /* Nothing more to be done */
	}
#endif /* IPSEC */

d371 5
d378 16
d395 7
@


1.3.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a62 1
#include <netinet/ip_ipsp.h>
d95 1
d118 2
a119 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
d292 2
a293 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
d362 1
a362 1
	if (rt->rt_ifp == m->m_pkthdr.rcvif && !srcrt && ip6_sendredirects &&
d457 1
a457 1
#if NPF > 0 || defined(IPSEC)
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_forward.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d49 1
a49 1
#include <netinet6/ip6.h>
d51 1
a51 1
#include <netinet6/icmp6.h>
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 5
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3)
#include "opt_ip6fw.h"
#include "opt_inet.h"
#endif

a53 1
#ifdef __OpenBSD__ /*KAME IPSEC*/
a54 1
#endif
d93 2
a97 3
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
	long time_second = time.tv_sec;
#endif
a291 4
#ifdef __FreeBSD__
			rtalloc_ign((struct route *)&ip6_forward_rt,
				    RTF_PRCLONING);
#else
a292 1
#endif
a315 3
#ifdef __FreeBSD__
  		rtalloc_ign((struct route *)&ip6_forward_rt, RTF_PRCLONING);
#else
d317 1
a317 1
#endif
@

