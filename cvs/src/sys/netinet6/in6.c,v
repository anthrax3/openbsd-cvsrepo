head	1.210;
access;
symbols
	OPENBSD_6_1:1.201.0.4
	OPENBSD_6_1_BASE:1.201
	OPENBSD_6_0:1.189.0.2
	OPENBSD_6_0_BASE:1.189
	OPENBSD_5_9:1.183.0.2
	OPENBSD_5_9_BASE:1.183
	OPENBSD_5_8:1.161.0.4
	OPENBSD_5_8_BASE:1.161
	OPENBSD_5_7:1.153.0.2
	OPENBSD_5_7_BASE:1.153
	OPENBSD_5_6:1.138.0.4
	OPENBSD_5_6_BASE:1.138
	OPENBSD_5_5:1.132.0.4
	OPENBSD_5_5_BASE:1.132
	OPENBSD_5_4:1.116.0.2
	OPENBSD_5_4_BASE:1.116
	OPENBSD_5_3:1.101.0.2
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.98.0.2
	OPENBSD_5_2_BASE:1.98
	OPENBSD_5_1_BASE:1.96
	OPENBSD_5_1:1.96.0.2
	OPENBSD_5_0:1.93.0.2
	OPENBSD_5_0_BASE:1.93
	OPENBSD_4_9:1.89.0.2
	OPENBSD_4_9_BASE:1.89
	OPENBSD_4_8:1.88.0.2
	OPENBSD_4_8_BASE:1.88
	OPENBSD_4_7:1.86.0.2
	OPENBSD_4_7_BASE:1.86
	OPENBSD_4_6:1.82.0.4
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.80.0.2
	OPENBSD_4_5_BASE:1.80
	OPENBSD_4_4:1.78.0.2
	OPENBSD_4_4_BASE:1.78
	OPENBSD_4_3:1.73.0.2
	OPENBSD_4_3_BASE:1.73
	OPENBSD_4_2:1.72.0.4
	OPENBSD_4_2_BASE:1.72
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.62.0.2
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.60.0.4
	OPENBSD_3_8_BASE:1.60
	OPENBSD_3_7:1.60.0.2
	OPENBSD_3_7_BASE:1.60
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	SMP_SYNC_A:1.54
	SMP_SYNC_B:1.54
	OPENBSD_3_5:1.54.0.2
	OPENBSD_3_5_BASE:1.54
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.49
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.49
	UBC:1.30.0.2
	UBC_BASE:1.30
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.2
	OPENBSD_2_8:1.21.0.2
	OPENBSD_2_8_BASE:1.21
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.4
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4;
locks; strict;
comment	@ * @;


1.210
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.209;
commitid	ZSLEQCt6cCaCd9uI;

1.209
date	2017.08.08.18.15.58;	author florian;	state Exp;
branches;
next	1.208;
commitid	0uoQs1W80abGpq2t;

1.208
date	2017.08.06.08.15.58;	author florian;	state Exp;
branches;
next	1.207;
commitid	kPBvz3spgEiELjP1;

1.207
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.206;
commitid	iTlWhLM2orYZnz27;

1.206
date	2017.05.29.20.28.57;	author florian;	state Exp;
branches;
next	1.205;
commitid	NhfXCJEyvJbcWb5e;

1.205
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.204;
commitid	SAe3SQ48vKH6r5FL;

1.204
date	2017.05.08.08.46.39;	author rzalamena;	state Exp;
branches;
next	1.203;
commitid	ffGuaP6j4fxaZcHM;

1.203
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.202;
commitid	Gef6NNDxonzfVaq2;

1.202
date	2017.04.17.10.29.01;	author florian;	state Exp;
branches;
next	1.201;
commitid	Bj9sk5ZAiL0q6glx;

1.201
date	2017.03.16.10.42.01;	author florian;	state Exp;
branches;
next	1.200;
commitid	0yphyGTsIEtHYJbZ;

1.200
date	2017.03.06.08.59.07;	author mpi;	state Exp;
branches;
next	1.199;
commitid	5F7mwVgpVaCdO0cW;

1.199
date	2017.02.16.10.15.12;	author mpi;	state Exp;
branches;
next	1.198;
commitid	NChVcK48FdZeU9j9;

1.198
date	2017.02.07.10.08.21;	author mpi;	state Exp;
branches;
next	1.197;
commitid	gzLIBtF3UIhyOxtA;

1.197
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.196;
commitid	2R0NOjEDy2jGtnjL;

1.196
date	2016.12.21.12.11.12;	author mpi;	state Exp;
branches;
next	1.195;
commitid	2WAwLMIriNRZieyo;

1.195
date	2016.11.28.14.14.39;	author mpi;	state Exp;
branches;
next	1.194;
commitid	6k4TK07Jp4xe3PKg;

1.194
date	2016.10.04.14.04.19;	author mpi;	state Exp;
branches;
next	1.193;
commitid	gXQbDuFtHAj5VAfn;

1.193
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.192;
commitid	ymldqUr8o0SRU6R6;

1.192
date	2016.09.04.10.32.01;	author mpi;	state Exp;
branches;
next	1.191;
commitid	0JNLzz71W0Jm1WWQ;

1.191
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.190;
commitid	ZsKqEaqTKPu9hWk6;

1.190
date	2016.08.08.13.09.36;	author mpi;	state Exp;
branches;
next	1.189;
commitid	ZP8AdZHShgWcyNBW;

1.189
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.188;
commitid	VkTTZG0LgjCK3eLa;

1.188
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.187;
commitid	LxUFHuffW7GZZ01f;

1.187
date	2016.06.13.10.34.40;	author mpi;	state Exp;
branches;
next	1.186;
commitid	Lm2Xf1RxdPM3vZDo;

1.186
date	2016.03.03.12.57.15;	author jca;	state Exp;
branches;
next	1.185;
commitid	WUjfyeigg4TuFbFK;

1.185
date	2016.03.03.12.51.51;	author jca;	state Exp;
branches;
next	1.184;
commitid	lKjXzeXRhqiMIGLh;

1.184
date	2016.02.28.07.15.34;	author stefan;	state Exp;
branches;
next	1.183;
commitid	v8soDTXVbwYaYMrw;

1.183
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.182;
commitid	5qLGnZtXVLeqUvHc;

1.182
date	2015.12.22.10.01.01;	author mpi;	state Exp;
branches;
next	1.181;
commitid	HTyZ16vLsgsSbHID;

1.181
date	2015.12.03.13.13.42;	author tedu;	state Exp;
branches;
next	1.180;
commitid	B6mmJF8KPnwvL8eB;

1.180
date	2015.12.01.10.03.53;	author mpi;	state Exp;
branches;
next	1.179;
commitid	xTHt7exLqk74Pvfa;

1.179
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.178;
commitid	uGqqOfOdbFUfC7aN;

1.178
date	2015.11.02.15.05.23;	author mpi;	state Exp;
branches;
next	1.177;
commitid	aK60XMOKqPFfSdCc;

1.177
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.176;
commitid	7wrRch1SS813fOcY;

1.176
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.175;
commitid	G2nTzngqgXpQqcJB;

1.175
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.174;
commitid	L7FukNYlBzoQuXvw;

1.174
date	2015.09.10.16.39.39;	author mpi;	state Exp;
branches;
next	1.173;
commitid	7KYjCOTlSY9IP6al;

1.173
date	2015.09.10.14.02.35;	author bluhm;	state Exp;
branches;
next	1.172;
commitid	37AgR6gAJyJwWUSC;

1.172
date	2015.09.10.08.45.32;	author claudio;	state Exp;
branches;
next	1.171;
commitid	Dg09eZf8iAopCPmp;

1.171
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.170;
commitid	MtXIH0WHmPXVgeDN;

1.170
date	2015.09.04.13.00.41;	author mpi;	state Exp;
branches;
next	1.169;
commitid	OXjJIP37j7lOibnT;

1.169
date	2015.08.31.08.33.01;	author mpi;	state Exp;
branches;
next	1.168;
commitid	872UGCRTS8S2bBua;

1.168
date	2015.08.24.23.26.43;	author mpi;	state Exp;
branches;
next	1.167;
commitid	RvboqW7afhR7jBgv;

1.167
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.166;
commitid	hOA5qIh5CrYvhG4e;

1.166
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.165;
commitid	0LcoZC9QTu9wgpyX;

1.165
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.164;
commitid	t09qBDKQRv4jxgp3;

1.164
date	2015.08.19.11.09.24;	author mpi;	state Exp;
branches;
next	1.163;
commitid	zwou0rOj83L8dpFm;

1.163
date	2015.08.18.08.48.36;	author mpi;	state Exp;
branches;
next	1.162;
commitid	wPy6rlOFqOcnyi3J;

1.162
date	2015.08.12.09.06.18;	author mpi;	state Exp;
branches;
next	1.161;
commitid	nWFfKwWYobSFURG7;

1.161
date	2015.07.18.15.05.32;	author mpi;	state Exp;
branches;
next	1.160;
commitid	8XKIMnE4aOLeVqIl;

1.160
date	2015.07.08.08.48.34;	author mpi;	state Exp;
branches;
next	1.159;
commitid	PeSgmtaVq0R4a133;

1.159
date	2015.06.08.22.19.27;	author krw;	state Exp;
branches;
next	1.158;
commitid	4Ro7ulidQXNcMvmM;

1.158
date	2015.05.26.12.19.52;	author mpi;	state Exp;
branches;
next	1.157;
commitid	iiHJitHd0U6t7lGT;

1.157
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.156;
commitid	Gl6pqKOqk2n9Lwhq;

1.156
date	2015.04.20.09.07.42;	author mpi;	state Exp;
branches;
next	1.155;
commitid	oEREyuqIGnjF1tsU;

1.155
date	2015.04.20.08.53.36;	author mpi;	state Exp;
branches;
next	1.154;
commitid	K7n0tmkUei2v5uNT;

1.154
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.153;
commitid	p4LJxGKbi0BU2cG6;

1.153
date	2015.02.19.22.23.05;	author bluhm;	state Exp;
branches;
next	1.152;
commitid	zDfuA3cPL7qk4nPz;

1.152
date	2015.01.27.10.34.27;	author mpi;	state Exp;
branches;
next	1.151;
commitid	kvmsvCh7USa79N2Z;

1.151
date	2015.01.27.10.31.19;	author mpi;	state Exp;
branches;
next	1.150;
commitid	5QOPq50YTGxsLtYH;

1.150
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.149;
commitid	VK3ncyiP3NS1N4Sy;

1.149
date	2015.01.10.11.43.37;	author mpi;	state Exp;
branches;
next	1.148;
commitid	wic8NM5ErVdwMnNC;

1.148
date	2015.01.06.21.26.46;	author stsp;	state Exp;
branches;
next	1.147;
commitid	jH0HZyR3DaPVl7Rm;

1.147
date	2014.12.08.10.38.48;	author mpi;	state Exp;
branches;
next	1.146;
commitid	knBysdGSwagqyjfc;

1.146
date	2014.11.24.12.43.54;	author mpi;	state Exp;
branches;
next	1.145;
commitid	xHA3kihmdbMHtfu3;

1.145
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.144;
commitid	StxeqV93bwujMj7n;

1.144
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.143;
commitid	w0MRp28dmfD1ZzO8;

1.143
date	2014.10.22.09.48.19;	author stsp;	state Exp;
branches;
next	1.142;
commitid	82nz4dDPGRrp9Tee;

1.142
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.141;
commitid	6AYfDT0Lpez1LFQp;

1.141
date	2014.10.07.08.47.28;	author mpi;	state Exp;
branches;
next	1.140;
commitid	YwQD6dPTFjvxMtlw;

1.140
date	2014.08.26.21.44.29;	author florian;	state Exp;
branches;
next	1.139;
commitid	yPNaXDJAsGXelPnV;

1.139
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.138;
commitid	fUNtd3qRJAn6fam0;

1.138
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.137;
commitid	B4dZSbxas1X1IpXI;

1.137
date	2014.05.15.09.05.13;	author mpi;	state Exp;
branches;
next	1.136;

1.136
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.135;

1.135
date	2014.04.10.13.47.21;	author mpi;	state Exp;
branches;
next	1.134;

1.134
date	2014.04.03.08.22.10;	author mpi;	state Exp;
branches;
next	1.133;

1.133
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.132;

1.132
date	2014.02.12.10.03.07;	author mpi;	state Exp;
branches;
next	1.131;

1.131
date	2014.01.22.13.19.12;	author mpi;	state Exp;
branches;
next	1.130;

1.130
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.129;

1.129
date	2014.01.15.09.25.38;	author mpi;	state Exp;
branches;
next	1.128;

1.128
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.127;

1.127
date	2014.01.07.16.34.05;	author stsp;	state Exp;
branches;
next	1.126;

1.126
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2013.11.13.08.27.24;	author stsp;	state Exp;
branches;
next	1.123;

1.123
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.120;

1.120
date	2013.10.17.16.27.45;	author bluhm;	state Exp;
branches;
next	1.119;

1.119
date	2013.10.01.08.25.35;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2013.08.26.07.15.58;	author bluhm;	state Exp;
branches;
next	1.117;

1.117
date	2013.08.13.05.52.25;	author guenther;	state Exp;
branches;
next	1.116;

1.116
date	2013.06.20.12.03.40;	author mpi;	state Exp;
branches;
next	1.115;

1.115
date	2013.06.20.09.38.24;	author mpi;	state Exp;
branches;
next	1.114;

1.114
date	2013.06.16.21.27.15;	author bluhm;	state Exp;
branches;
next	1.113;

1.113
date	2013.06.13.21.06.58;	author bluhm;	state Exp;
branches;
next	1.112;

1.112
date	2013.05.31.15.04.23;	author bluhm;	state Exp;
branches;
next	1.111;

1.111
date	2013.05.30.15.23.38;	author claudio;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.11.14.08.03;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.103;

1.103
date	2013.03.04.14.23.35;	author bluhm;	state Exp;
branches;
next	1.102;

1.102
date	2013.03.03.00.35.13;	author bluhm;	state Exp;
branches;
next	1.101;

1.101
date	2012.11.30.13.48.12;	author stsp;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2012.10.05.17.17.04;	author camield;	state Exp;
branches;
next	1.99;

1.99
date	2012.09.19.09.47.25;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2012.07.14.17.23.16;	author sperreault;	state Exp;
branches
	1.98.2.1;
next	1.97;

1.97
date	2012.07.08.18.01.25;	author bluhm;	state Exp;
branches;
next	1.96;

1.96
date	2012.01.17.02.07.32;	author stsp;	state Exp;
branches;
next	1.95;

1.95
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.94;

1.94
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.93;

1.93
date	2011.08.08.13.04.35;	author bluhm;	state Exp;
branches;
next	1.92;

1.92
date	2011.08.07.15.18.40;	author bluhm;	state Exp;
branches;
next	1.91;

1.91
date	2011.07.26.21.19.51;	author bluhm;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.03.13.55.36;	author stsp;	state Exp;
branches;
next	1.89;

1.89
date	2010.10.07.22.07.06;	author mpf;	state Exp;
branches;
next	1.88;

1.88
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2010.05.08.10.55.06;	author stsp;	state Exp;
branches;
next	1.86;

1.86
date	2010.02.08.12.04.35;	author jsing;	state Exp;
branches;
next	1.85;

1.85
date	2010.01.13.02.13.12;	author henning;	state Exp;
branches;
next	1.84;

1.84
date	2010.01.13.02.02.43;	author henning;	state Exp;
branches;
next	1.83;

1.83
date	2009.12.21.23.46.25;	author sthen;	state Exp;
branches;
next	1.82;

1.82
date	2009.06.04.19.07.21;	author henning;	state Exp;
branches;
next	1.81;

1.81
date	2009.03.15.19.40.41;	author miod;	state Exp;
branches;
next	1.80;

1.80
date	2009.01.30.10.47.46;	author mcbride;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.01.21.17.06;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2008.07.13.20.41.39;	author claudio;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.76;

1.76
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.75;

1.75
date	2008.05.11.08.13.02;	author claudio;	state Exp;
branches;
next	1.74;

1.74
date	2008.05.07.05.14.21;	author claudio;	state Exp;
branches;
next	1.73;

1.73
date	2007.12.09.21.24.58;	author hshoexer;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches
	1.72.4.1;
next	1.71;

1.71
date	2006.11.15.03.07.44;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2006.11.14.04.44.22;	author itojun;	state Exp;
branches;
next	1.69;

1.69
date	2006.10.31.12.49.45;	author mpf;	state Exp;
branches;
next	1.68;

1.68
date	2006.08.28.17.29.53;	author mcbride;	state Exp;
branches
	1.68.2.1;
next	1.67;

1.67
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2006.04.16.19.09.56;	author canacar;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2006.02.14.10.34.31;	author otto;	state Exp;
branches
	1.62.2.1;
next	1.61;

1.61
date	2005.09.19.19.36.49;	author brad;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.07.12.08.25;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2004.08.24.02.57.33;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2004.08.21.06.57.50;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.17.09.43.55;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.15.04.03.20;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.23.05.06.41;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.13.06.28.16;	author mcbride;	state Exp;
branches;
next	1.52;

1.52
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.49;

1.49
date	2002.10.17.00.09.39;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2002.09.23.23.28.15;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.11.07.36.00;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.06.08.00.06.58;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.08.00.00.59;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.06.07.15.00.54;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.06.07.04.18.56;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.07.04.13.10;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.07.04.11.51;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.29.02.59.12;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.23.06.56.16;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.23.00.50.59;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.07.18.12.50.44;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.16.12.53.36;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.16.15.58.50;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.16.08.22.05;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.07.11.46.22;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.18.06.11.12;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.11.00.11.15;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.06.05.52.01;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.12.05.18.56;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.27.16.42.22;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.17.04.44.50;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.22.03.48.30;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.03.12.06.16.58;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.02.09.44.28;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.28.11.55.21;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.07.06.05.06;	author itojun;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.02.04.18.13.35;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.02.17.53.52;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.02.17.16.52;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.02.17.01.50;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.12.09.13.59.57;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	99.12.08.11.51.12;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.03.24.02.28.22;	author cmetz;	state Exp;
branches;
next	1.3;

1.3
date	99.03.09.05.31.52;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.04.36.40;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.55;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2000.03.02.07.04.44;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2000.03.24.09.09.40;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.07.04.10.55.18;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.13.2.10;

1.13.2.10
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.13.2.11;

1.13.2.11
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;

1.62.2.1
date	2006.11.09.02.31.28;	author brad;	state Exp;
branches;
next	;

1.68.2.1
date	2006.11.09.02.35.47;	author brad;	state Exp;
branches;
next	;

1.72.4.1
date	2008.10.02.17.28.12;	author brad;	state Exp;
branches;
next	;

1.73.2.1
date	2008.10.02.17.28.35;	author brad;	state Exp;
branches;
next	;

1.78.2.1
date	2008.11.02.04.02.10;	author brad;	state Exp;
branches;
next	;

1.98.2.1
date	2013.05.30.20.41.54;	author sthen;	state Exp;
branches;
next	;

1.101.2.1
date	2013.05.30.20.41.24;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.210
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@/*	$OpenBSD: in6.c,v 1.209 2017/08/08 18:15:58 florian Exp $	*/
/*	$KAME: in6.c,v 1.372 2004/06/14 08:14:21 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in.c	8.2 (Berkeley) 11/15/93
 */

#include "carp.h"

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet6/mld6_var.h>
#ifdef MROUTING
#include <netinet6/ip6_mroute.h>
#endif
#include <netinet6/in6_ifattach.h>
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

/* backward compatibility for a while... */
#define COMPAT_IN6IFIOCTL

/*
 * Definitions of some constant IP6 addresses.
 */
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
const struct in6_addr in6addr_intfacelocal_allnodes =
	IN6ADDR_INTFACELOCAL_ALLNODES_INIT;
const struct in6_addr in6addr_linklocal_allnodes =
	IN6ADDR_LINKLOCAL_ALLNODES_INIT;
const struct in6_addr in6addr_linklocal_allrouters =
	IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;

const struct in6_addr in6mask0 = IN6MASK0;
const struct in6_addr in6mask32 = IN6MASK32;
const struct in6_addr in6mask64 = IN6MASK64;
const struct in6_addr in6mask96 = IN6MASK96;
const struct in6_addr in6mask128 = IN6MASK128;

int in6_lifaddr_ioctl(u_long, caddr_t, struct ifnet *, int);
int in6_ioctl(u_long, caddr_t, struct ifnet *, int);
int in6_ifinit(struct ifnet *, struct in6_ifaddr *, int);
void in6_unlink_ifa(struct in6_ifaddr *, struct ifnet *);

const struct sockaddr_in6 sa6_any = {
	sizeof(sa6_any), AF_INET6, 0, 0, IN6ADDR_ANY_INIT, 0
};

int
in6_mask2len(struct in6_addr *mask, u_char *lim0)
{
	int x = 0, y;
	u_char *lim = lim0, *p;

	/* ignore the scope_id part */
	if (lim0 == NULL || lim0 - (u_char *)mask > sizeof(*mask))
		lim = (u_char *)mask + sizeof(*mask);
	for (p = (u_char *)mask; p < lim; x++, p++) {
		if (*p != 0xff)
			break;
	}
	y = 0;
	if (p < lim) {
		for (y = 0; y < 8; y++) {
			if ((*p & (0x80 >> y)) == 0)
				break;
		}
	}

	/*
	 * when the limit pointer is given, do a stricter check on the
	 * remaining bits.
	 */
	if (p < lim) {
		if (y != 0 && (*p & (0x00ff >> y)) != 0)
			return (-1);
		for (p = p + 1; p < lim; p++)
			if (*p != 0)
				return (-1);
	}

	return x * 8 + y;
}

int
in6_nam2sin6(const struct mbuf *nam, struct sockaddr_in6 **sin6)
{
	struct sockaddr *sa = mtod(nam, struct sockaddr *);

	if (nam->m_len < offsetof(struct sockaddr, sa_data))
		return EINVAL;
	if (sa->sa_family != AF_INET6)
		return EAFNOSUPPORT;
	if (sa->sa_len != nam->m_len)
		return EINVAL;
	if (sa->sa_len != sizeof(struct sockaddr_in6))
		return EINVAL;
	*sin6 = satosin6(sa);

	return 0;
}

int
in6_control(struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp)
{
	int privileged;

	privileged = 0;
	if ((so->so_state & SS_PRIV) != 0)
		privileged++;

#ifdef MROUTING
	switch (cmd) {
	case SIOCGETSGCNT_IN6:
	case SIOCGETMIFCNT_IN6:
		return (mrt6_ioctl(so, cmd, data));
	}
#endif

	return (in6_ioctl(cmd, data, ifp, privileged));
}

int
in6_ioctl(u_long cmd, caddr_t data, struct ifnet *ifp, int privileged)
{
	struct	in6_ifreq *ifr = (struct in6_ifreq *)data;
	struct	in6_ifaddr *ia6 = NULL;
	struct	in6_aliasreq *ifra = (struct in6_aliasreq *)data;
	struct sockaddr_in6 *sa6;
	int error;

	if (ifp == NULL)
		return (EOPNOTSUPP);

	switch (cmd) {
	case SIOCSNDFLUSH_IN6:
	case SIOCSPFXFLUSH_IN6:
	case SIOCSRTRFLUSH_IN6:
	case SIOCSIFINFO_FLAGS:
		if (!privileged)
			return (EPERM);
		/* FALLTHROUGH */
	case SIOCGIFINFO_IN6:
	case SIOCGNBRINFO_IN6:
		return (nd6_ioctl(cmd, data, ifp));
	}

	switch (cmd) {
	case SIOCALIFADDR:
	case SIOCDLIFADDR:
		if (!privileged)
			return (EPERM);
		/* FALLTHROUGH */
	case SIOCGLIFADDR:
		return in6_lifaddr_ioctl(cmd, data, ifp, privileged);
	}

	/*
	 * Find address for this interface, if it exists.
	 *
	 * In netinet code, we have checked ifra_addr in SIOCSIF*ADDR operation
	 * only, and used the first interface address as the target of other
	 * operations (without checking ifra_addr).  This was because netinet
	 * code/API assumed at most 1 interface address per interface.
	 * Since IPv6 allows a node to assign multiple addresses
	 * on a single interface, we almost always look and check the
	 * presence of ifra_addr, and reject invalid ones here.
	 * It also decreases duplicated code among SIOC*_IN6 operations.
	 */
	switch (cmd) {
	case SIOCAIFADDR_IN6:
	case SIOCSIFPHYADDR_IN6:
		sa6 = &ifra->ifra_addr;
		break;
	case SIOCGIFADDR_IN6:
	case SIOCGIFDSTADDR_IN6:
	case SIOCGIFNETMASK_IN6:
	case SIOCDIFADDR_IN6:
	case SIOCGIFPSRCADDR_IN6:
	case SIOCGIFPDSTADDR_IN6:
	case SIOCGIFAFLAG_IN6:
	case SIOCSNDFLUSH_IN6:
	case SIOCSPFXFLUSH_IN6:
	case SIOCSRTRFLUSH_IN6:
	case SIOCGIFALIFETIME_IN6:
	case SIOCGIFSTAT_IN6:
	case SIOCGIFSTAT_ICMP6:
		sa6 = &ifr->ifr_addr;
		break;
	case SIOCSIFADDR:
	case SIOCSIFDSTADDR:
	case SIOCSIFBRDADDR:
	case SIOCSIFNETMASK:
		/*
		 * Do not pass those ioctl to driver handler since they are not
		 * properly setup. Instead just error out.
		 */
		return (EOPNOTSUPP);
	default:
		sa6 = NULL;
		break;
	}
	if (sa6 && sa6->sin6_family == AF_INET6) {
		if (IN6_IS_ADDR_LINKLOCAL(&sa6->sin6_addr)) {
			if (sa6->sin6_addr.s6_addr16[1] == 0) {
				/* link ID is not embedded by the user */
				sa6->sin6_addr.s6_addr16[1] =
				    htons(ifp->if_index);
			} else if (sa6->sin6_addr.s6_addr16[1] !=
			    htons(ifp->if_index)) {
				return (EINVAL);	/* link ID contradicts */
			}
			if (sa6->sin6_scope_id) {
				if (sa6->sin6_scope_id !=
				    (u_int32_t)ifp->if_index)
					return (EINVAL);
				sa6->sin6_scope_id = 0; /* XXX: good way? */
			}
		}
		ia6 = in6ifa_ifpwithaddr(ifp, &sa6->sin6_addr);
	} else
		ia6 = NULL;

	switch (cmd) {
	case SIOCDIFADDR_IN6:
		/*
		 * for IPv4, we look for existing in_ifaddr here to allow
		 * "ifconfig if0 delete" to remove the first IPv4 address on
		 * the interface.  For IPv6, as the spec allows multiple
		 * interface address from the day one, we consider "remove the
		 * first one" semantics to be not preferable.
		 */
		if (ia6 == NULL)
			return (EADDRNOTAVAIL);
		/* FALLTHROUGH */
	case SIOCAIFADDR_IN6:
		/*
		 * We always require users to specify a valid IPv6 address for
		 * the corresponding operation.
		 */
		if (ifra->ifra_addr.sin6_family != AF_INET6 ||
		    ifra->ifra_addr.sin6_len != sizeof(struct sockaddr_in6))
			return (EAFNOSUPPORT);
		if (!privileged)
			return (EPERM);

		break;

	case SIOCGIFADDR_IN6:
		/* This interface is basically deprecated. use SIOCGIFCONF. */
		/* FALLTHROUGH */
	case SIOCGIFAFLAG_IN6:
	case SIOCGIFNETMASK_IN6:
	case SIOCGIFDSTADDR_IN6:
	case SIOCGIFALIFETIME_IN6:
		/* must think again about its semantics */
		if (ia6 == NULL)
			return (EADDRNOTAVAIL);
		break;
	}

	switch (cmd) {

	case SIOCGIFADDR_IN6:
		ifr->ifr_addr = ia6->ia_addr;
		break;

	case SIOCGIFDSTADDR_IN6:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return (EINVAL);
		/*
		 * XXX: should we check if ifa_dstaddr is NULL and return
		 * an error?
		 */
		ifr->ifr_dstaddr = ia6->ia_dstaddr;
		break;

	case SIOCGIFNETMASK_IN6:
		ifr->ifr_addr = ia6->ia_prefixmask;
		break;

	case SIOCGIFAFLAG_IN6:
		ifr->ifr_ifru.ifru_flags6 = ia6->ia6_flags;
		break;

	case SIOCGIFSTAT_IN6:
	case SIOCGIFSTAT_ICMP6:
		return (EOPNOTSUPP);

	case SIOCGIFALIFETIME_IN6:
		ifr->ifr_ifru.ifru_lifetime = ia6->ia6_lifetime;
		if (ia6->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			time_t expire, maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;

			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire =
			    (time_t)~(1ULL << ((sizeof(maxexpire) * 8) - 1));
			if (ia6->ia6_lifetime.ia6t_vltime <
			    maxexpire - ia6->ia6_updatetime) {
				expire = ia6->ia6_updatetime +
				    ia6->ia6_lifetime.ia6t_vltime;
				if (expire != 0) {
					expire -= time_uptime;
					expire += time_second;
				}
				retlt->ia6t_expire = expire;
			} else
				retlt->ia6t_expire = maxexpire;
		}
		if (ia6->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			time_t expire, maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;

			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire =
			    (time_t)~(1ULL << ((sizeof(maxexpire) * 8) - 1));
			if (ia6->ia6_lifetime.ia6t_pltime <
			    maxexpire - ia6->ia6_updatetime) {
				expire = ia6->ia6_updatetime +
				    ia6->ia6_lifetime.ia6t_pltime;
				if (expire != 0) {
					expire -= time_uptime;
					expire += time_second;
				}
				retlt->ia6t_preferred = expire;
			} else
				retlt->ia6t_preferred = maxexpire;
		}
		break;

	case SIOCAIFADDR_IN6:
	{
		int plen, error = 0, newifaddr = 0;

		/* reject read-only flags */
		if ((ifra->ifra_flags & IN6_IFF_DUPLICATED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_DETACHED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0) {
			return (EINVAL);
		}

		if (ia6 == NULL)
			newifaddr = 1;

		/*
		 * Make the address tentative before joining multicast
		 * addresses, so that corresponding MLD responses would
		 * not have a tentative source address.
		 */
		if (newifaddr && in6if_do_dad(ifp))
			ifra->ifra_flags |= IN6_IFF_TENTATIVE;

		/*
		 * first, make or update the interface address structure,
		 * and link it to the list. try to enable inet6 if there
		 * is no link-local yet.
		 */
		error = in6_ifattach(ifp);
		if (error != 0)
			return (error);
		error = in6_update_ifa(ifp, ifra, ia6);
		if (error != 0)
			return (error);

		ia6 = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr);
		if (ia6 == NULL) {
			/*
			 * this can happen when the user specify the 0 valid
			 * lifetime.
			 */
			break;
		}

		if (!newifaddr) {
			dohooks(ifp->if_addrhooks, 0);
			break;
		}

		/* Perform DAD, if needed. */
		if (ia6->ia6_flags & IN6_IFF_TENTATIVE)
			nd6_dad_start(&ia6->ia_ifa);

		plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if ((ifp->if_flags & IFF_LOOPBACK) || plen == 128) {
			dohooks(ifp->if_addrhooks, 0);
			break;	/* No need to install a connected route. */
		}

		error = rt_ifa_add(&ia6->ia_ifa, RTF_CLONING | RTF_CONNECTED,
		    ia6->ia_ifa.ifa_addr);
		if (error) {
			in6_purgeaddr(&ia6->ia_ifa);
			return (error);
		}
		dohooks(ifp->if_addrhooks, 0);
		break;
	}

	case SIOCDIFADDR_IN6:
		in6_purgeaddr(&ia6->ia_ifa);
		dohooks(ifp->if_addrhooks, 0);
		break;

	default:
		if (ifp->if_ioctl == NULL)
			return (EOPNOTSUPP);
		error = ((*ifp->if_ioctl)(ifp, cmd, data));
		return (error);
	}

	return (0);
}

/*
 * Update parameters of an IPv6 interface address.
 * If necessary, a new entry is created and linked into address chains.
 * This function is separated from in6_control().
 */
int
in6_update_ifa(struct ifnet *ifp, struct in6_aliasreq *ifra,
    struct in6_ifaddr *ia6)
{
	int error = 0, hostIsNew = 0, plen = -1;
	struct sockaddr_in6 dst6;
	struct in6_addrlifetime *lt;
	struct in6_multi_mship *imm;
	struct rtentry *rt;
	char addr[INET6_ADDRSTRLEN];

	NET_ASSERT_LOCKED();

	/* Validate parameters */
	if (ifp == NULL || ifra == NULL) /* this maybe redundant */
		return (EINVAL);

	/*
	 * The destination address for a p2p link must have a family
	 * of AF_UNSPEC or AF_INET6.
	 */
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    ifra->ifra_dstaddr.sin6_family != AF_INET6 &&
	    ifra->ifra_dstaddr.sin6_family != AF_UNSPEC)
		return (EAFNOSUPPORT);

	/*
	 * validate ifra_prefixmask.  don't check sin6_family, netmask
	 * does not carry fields other than sin6_len.
	 */
	if (ifra->ifra_prefixmask.sin6_len > sizeof(struct sockaddr_in6))
		return (EINVAL);
	/*
	 * Because the IPv6 address architecture is classless, we require
	 * users to specify a (non 0) prefix length (mask) for a new address.
	 * We also require the prefix (when specified) mask is valid, and thus
	 * reject a non-consecutive mask.
	 */
	if (ia6 == NULL && ifra->ifra_prefixmask.sin6_len == 0)
		return (EINVAL);
	if (ifra->ifra_prefixmask.sin6_len != 0) {
		plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    (u_char *)&ifra->ifra_prefixmask +
		    ifra->ifra_prefixmask.sin6_len);
		if (plen <= 0)
			return (EINVAL);
	} else {
		/*
		 * In this case, ia6 must not be NULL.  We just use its prefix
		 * length.
		 */
		plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
	}
	/*
	 * If the destination address on a p2p interface is specified,
	 * and the address is a scoped one, validate/set the scope
	 * zone identifier.
	 */
	dst6 = ifra->ifra_dstaddr;
	if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) != 0 &&
	    (dst6.sin6_family == AF_INET6)) {
		/* link-local index check: should be a separate function? */
		if (IN6_IS_ADDR_LINKLOCAL(&dst6.sin6_addr)) {
			if (dst6.sin6_addr.s6_addr16[1] == 0) {
				/*
				 * interface ID is not embedded by
				 * the user
				 */
				dst6.sin6_addr.s6_addr16[1] =
				    htons(ifp->if_index);
			} else if (dst6.sin6_addr.s6_addr16[1] !=
			    htons(ifp->if_index)) {
				return (EINVAL);	/* ifid contradicts */
			}
		}
	}
	/*
	 * The destination address can be specified only for a p2p or a
	 * loopback interface.  If specified, the corresponding prefix length
	 * must be 128.
	 */
	if (ifra->ifra_dstaddr.sin6_family == AF_INET6) {
		if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) == 0)
			return (EINVAL);
		if (plen != 128)
			return (EINVAL);
	}
	/* lifetime consistency check */
	lt = &ifra->ifra_lifetime;
	if (lt->ia6t_pltime > lt->ia6t_vltime)
		return (EINVAL);
	if (lt->ia6t_vltime == 0) {
		/*
		 * the following log might be noisy, but this is a typical
		 * configuration mistake or a tool's bug.
		 */
		nd6log((LOG_INFO,
		    "in6_update_ifa: valid lifetime is 0 for %s\n",
		    inet_ntop(AF_INET6, &ifra->ifra_addr.sin6_addr,
		        addr, sizeof(addr))));

		if (ia6 == NULL)
			return (0); /* there's nothing to do */
	}

	/*
	 * If this is a new address, allocate a new ifaddr and link it
	 * into chains.
	 */
	if (ia6 == NULL) {
		hostIsNew = 1;
		ia6 = malloc(sizeof(*ia6), M_IFADDR, M_WAITOK | M_ZERO);
		LIST_INIT(&ia6->ia6_memberships);
		/* Initialize the address and masks, and put time stamp */
		ia6->ia_ifa.ifa_addr = sin6tosa(&ia6->ia_addr);
		ia6->ia_addr.sin6_family = AF_INET6;
		ia6->ia_addr.sin6_len = sizeof(ia6->ia_addr);
		ia6->ia6_createtime = ia6->ia6_updatetime = time_uptime;
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) != 0) {
			/*
			 * XXX: some functions expect that ifa_dstaddr is not
			 * NULL for p2p interfaces.
			 */
			ia6->ia_ifa.ifa_dstaddr = sin6tosa(&ia6->ia_dstaddr);
		} else {
			ia6->ia_ifa.ifa_dstaddr = NULL;
		}
		ia6->ia_ifa.ifa_netmask = sin6tosa(&ia6->ia_prefixmask);

		ia6->ia_ifp = ifp;
		ia6->ia_addr = ifra->ifra_addr;
		ifa_add(ifp, &ia6->ia_ifa);
	}

	/* set prefix mask */
	if (ifra->ifra_prefixmask.sin6_len) {
		/*
		 * We prohibit changing the prefix length of an existing
		 * address, because
		 * + such an operation should be rare in IPv6, and
		 * + the operation would confuse prefix management.
		 */
		if (ia6->ia_prefixmask.sin6_len &&
		    in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL) != plen) {
			error = EINVAL;
			goto unlink;
		}
		ia6->ia_prefixmask = ifra->ifra_prefixmask;
	}

	/*
	 * If a new destination address is specified, scrub the old one and
	 * install the new destination.  Note that the interface must be
	 * p2p or loopback (see the check above.)
	 */
	if ((ifp->if_flags & IFF_POINTOPOINT) && dst6.sin6_family == AF_INET6 &&
	    !IN6_ARE_ADDR_EQUAL(&dst6.sin6_addr, &ia6->ia_dstaddr.sin6_addr)) {
		struct ifaddr *ifa = &ia6->ia_ifa;

		if ((ia6->ia_flags & IFA_ROUTE) != 0 &&
		    rt_ifa_del(ifa, RTF_HOST, ifa->ifa_dstaddr) != 0) {
			nd6log((LOG_ERR, "in6_update_ifa: failed to remove "
			    "a route to the old destination: %s\n",
			    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
				addr, sizeof(addr))));
			/* proceed anyway... */
		} else
			ia6->ia_flags &= ~IFA_ROUTE;
		ia6->ia_dstaddr = dst6;
	}

	/*
	 * Set lifetimes.  We do not refer to ia6t_expire and ia6t_preferred
	 * to see if the address is deprecated or invalidated, but initialize
	 * these members for applications.
	 */
	ia6->ia6_updatetime = time_uptime;
	ia6->ia6_lifetime = ifra->ifra_lifetime;
	if (ia6->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
		ia6->ia6_lifetime.ia6t_expire =
		    time_uptime + ia6->ia6_lifetime.ia6t_vltime;
	} else
		ia6->ia6_lifetime.ia6t_expire = 0;
	if (ia6->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
		ia6->ia6_lifetime.ia6t_preferred =
		    time_uptime + ia6->ia6_lifetime.ia6t_pltime;
	} else
		ia6->ia6_lifetime.ia6t_preferred = 0;

	/* reset the interface and routing table appropriately. */
	if ((error = in6_ifinit(ifp, ia6, hostIsNew)) != 0)
		goto unlink;

	/*
	 * configure address flags.
	 */
	ia6->ia6_flags = ifra->ifra_flags;

	nd6_expire_timer_update(ia6);

	/*
	 * We are done if we have simply modified an existing address.
	 */
	if (!hostIsNew)
		return (error);

	/*
	 * Beyond this point, we should call in6_purgeaddr upon an error,
	 * not just go to unlink.
	 */

	/* join necessary multiast groups */
	if ((ifp->if_flags & IFF_MULTICAST) != 0) {
		struct sockaddr_in6 mltaddr, mltmask;

		/* join solicited multicast addr for new host id */
		struct sockaddr_in6 llsol;

		bzero(&llsol, sizeof(llsol));
		llsol.sin6_family = AF_INET6;
		llsol.sin6_len = sizeof(llsol);
		llsol.sin6_addr.s6_addr16[0] = htons(0xff02);
		llsol.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		llsol.sin6_addr.s6_addr32[1] = 0;
		llsol.sin6_addr.s6_addr32[2] = htonl(1);
		llsol.sin6_addr.s6_addr32[3] =
		    ifra->ifra_addr.sin6_addr.s6_addr32[3];
		llsol.sin6_addr.s6_addr8[12] = 0xff;
		imm = in6_joingroup(ifp, &llsol.sin6_addr, &error);
		if (!imm)
			goto cleanup;
		LIST_INSERT_HEAD(&ia6->ia6_memberships, imm, i6mm_chain);

		bzero(&mltmask, sizeof(mltmask));
		mltmask.sin6_len = sizeof(struct sockaddr_in6);
		mltmask.sin6_family = AF_INET6;
		mltmask.sin6_addr = in6mask32;

		/*
		 * join link-local all-nodes address
		 */
		bzero(&mltaddr, sizeof(mltaddr));
		mltaddr.sin6_len = sizeof(struct sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_linklocal_allnodes;
		mltaddr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		mltaddr.sin6_scope_id = 0;

		/*
		 * XXX: do we really need this automatic routes?
		 * We should probably reconsider this stuff.  Most applications
		 * actually do not need the routes, since they usually specify
		 * the outgoing interface.
		 */
		rt = rtalloc(sin6tosa(&mltaddr), 0, ifp->if_rdomain);
		if (rt) {
			/* 32bit came from "mltmask" */
			if (memcmp(&mltaddr.sin6_addr,
			    &satosin6(rt_key(rt))->sin6_addr,
			    32 / 8)) {
				rtfree(rt);
				rt = NULL;
			}
		}
		if (!rt) {
			struct rt_addrinfo info;

			bzero(&info, sizeof(info));
			info.rti_ifa = &ia6->ia_ifa;
			info.rti_info[RTAX_DST] = sin6tosa(&mltaddr);
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia6->ia_addr);
			info.rti_info[RTAX_NETMASK] = sin6tosa(&mltmask);
			info.rti_info[RTAX_IFA] = sin6tosa(&ia6->ia_addr);
			info.rti_flags = RTF_MULTICAST;
			error = rtrequest(RTM_ADD, &info, RTP_CONNECTED, NULL,
			    ifp->if_rdomain);
			if (error)
				goto cleanup;
		} else {
			rtfree(rt);
		}
		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
		if (!imm)
			goto cleanup;
		LIST_INSERT_HEAD(&ia6->ia6_memberships, imm, i6mm_chain);

		/*
		 * join node information group address
		 */
		if (in6_nigroup(ifp, hostname, hostnamelen, &mltaddr) == 0) {
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (!imm) {
				/* XXX not very fatal, go on... */
			} else {
				LIST_INSERT_HEAD(&ia6->ia6_memberships,
				    imm, i6mm_chain);
			}
		}

		/*
		 * join interface-local all-nodes address.
		 * (ff01::1%ifN, and ff01::%ifN/32)
		 */
		bzero(&mltaddr, sizeof(mltaddr));
		mltaddr.sin6_len = sizeof(struct sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_intfacelocal_allnodes;
		mltaddr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		mltaddr.sin6_scope_id = 0;

		/* XXX: again, do we really need the route? */
		rt = rtalloc(sin6tosa(&mltaddr), 0, ifp->if_rdomain);
		if (rt) {
			/* 32bit came from "mltmask" */
			if (memcmp(&mltaddr.sin6_addr,
			    &satosin6(rt_key(rt))->sin6_addr,
			    32 / 8)) {
				rtfree(rt);
				rt = NULL;
			}
		}
		if (!rt) {
			struct rt_addrinfo info;

			bzero(&info, sizeof(info));
			info.rti_ifa = &ia6->ia_ifa;
			info.rti_info[RTAX_DST] = sin6tosa(&mltaddr);
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia6->ia_addr);
			info.rti_info[RTAX_NETMASK] = sin6tosa(&mltmask);
			info.rti_info[RTAX_IFA] = sin6tosa(&ia6->ia_addr);
			info.rti_flags = RTF_MULTICAST;
			error = rtrequest(RTM_ADD, &info, RTP_CONNECTED, NULL,
			    ifp->if_rdomain);
			if (error)
				goto cleanup;
		} else {
			rtfree(rt);
		}
		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
		if (!imm)
			goto cleanup;
		LIST_INSERT_HEAD(&ia6->ia6_memberships, imm, i6mm_chain);
	}

	return (error);

  unlink:
	/*
	 * XXX: if a change of an existing address failed, keep the entry
	 * anyway.
	 */
	if (hostIsNew)
		in6_unlink_ifa(ia6, ifp);
	return (error);

  cleanup:
	in6_purgeaddr(&ia6->ia_ifa);
	return error;
}

void
in6_purgeaddr(struct ifaddr *ifa)
{
	struct ifnet *ifp = ifa->ifa_ifp;
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
	struct in6_multi_mship *imm;

	/* stop DAD processing */
	nd6_dad_stop(ifa);

	/*
	 * delete route to the destination of the address being purged.
	 * The interface must be p2p or loopback in this case.
	 */
	if ((ifp->if_flags & IFF_POINTOPOINT) && (ia6->ia_flags & IFA_ROUTE) &&
	    ia6->ia_dstaddr.sin6_len != 0) {
		int e;

		if ((e = rt_ifa_del(ifa, RTF_HOST, ifa->ifa_dstaddr)) != 0) {
			char addr[INET6_ADDRSTRLEN];
			log(LOG_ERR, "in6_purgeaddr: failed to remove "
			    "a route to the p2p destination: %s on %s, "
			    "errno=%d\n",
			    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
				addr, sizeof(addr)),
			    ifp->if_xname, e);
			/* proceed anyway... */
		} else
			ia6->ia_flags &= ~IFA_ROUTE;
	}

	/* Remove ownaddr's loopback rtentry, if it exists. */
	rt_ifa_dellocal(&(ia6->ia_ifa));

	/*
	 * leave from multicast groups we have joined for the interface
	 */
	while (!LIST_EMPTY(&ia6->ia6_memberships)) {
		imm = LIST_FIRST(&ia6->ia6_memberships);
		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
	}

	in6_unlink_ifa(ia6, ifp);
}

void
in6_unlink_ifa(struct in6_ifaddr *ia6, struct ifnet *ifp)
{
	struct ifaddr *ifa = &ia6->ia_ifa;
	extern int ifatrash;
	int plen;

	NET_ASSERT_LOCKED();

	/* Release the reference to the base prefix. */
	plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
	if ((ifp->if_flags & IFF_LOOPBACK) == 0 && plen != 128) {
		rt_ifa_del(ifa, RTF_CLONING | RTF_CONNECTED,
		    ifa->ifa_addr);
	}

	rt_ifa_purge(ifa);
	ifa_del(ifp, ifa);

	ifatrash++;
	ia6->ia_ifp = NULL;
	ifafree(&ia6->ia_ifa);
}

/*
 * SIOC[GAD]LIFADDR.
 *	SIOCGLIFADDR: get first address. (?)
 *	SIOCGLIFADDR with IFLR_PREFIX:
 *		get first address that matches the specified prefix.
 *	SIOCALIFADDR: add the specified address.
 *	SIOCALIFADDR with IFLR_PREFIX:
 *		add the specified prefix, filling hostid part from
 *		the first link-local address.  prefixlen must be <= 64.
 *	SIOCDLIFADDR: delete the specified address.
 *	SIOCDLIFADDR with IFLR_PREFIX:
 *		delete the first address that matches the specified prefix.
 * return values:
 *	EINVAL on invalid parameters
 *	EADDRNOTAVAIL on prefix match failed/specified address not found
 *	other values may be returned from in6_ioctl()
 *
 * NOTE: SIOCALIFADDR(with IFLR_PREFIX set) allows prefixlen less than 64.
 * this is to accommodate address naming scheme other than RFC2374,
 * in the future.
 * RFC2373 defines interface id to be 64bit, but it allows non-RFC2374
 * address encoding scheme. (see figure on page 8)
 */
int
in6_lifaddr_ioctl(u_long cmd, caddr_t data, struct ifnet *ifp, int privileged)
{
	struct if_laddrreq *iflr = (struct if_laddrreq *)data;
	struct ifaddr *ifa;
	struct sockaddr *sa;

	/* sanity checks */
	if (!data || !ifp) {
		panic("invalid argument to in6_lifaddr_ioctl");
		/* NOTREACHED */
	}

	switch (cmd) {
	case SIOCGLIFADDR:
		/* address must be specified on GET with IFLR_PREFIX */
		if ((iflr->flags & IFLR_PREFIX) == 0)
			break;
		/* FALLTHROUGH */
	case SIOCALIFADDR:
	case SIOCDLIFADDR:
		/* address must be specified on ADD and DELETE */
		sa = sstosa(&iflr->addr);
		if (sa->sa_family != AF_INET6)
			return EINVAL;
		if (sa->sa_len != sizeof(struct sockaddr_in6))
			return EINVAL;
		/* XXX need improvement */
		sa = sstosa(&iflr->dstaddr);
		if (sa->sa_family && sa->sa_family != AF_INET6)
			return EINVAL;
		if (sa->sa_len && sa->sa_len != sizeof(struct sockaddr_in6))
			return EINVAL;
		break;
	default: /* shouldn't happen */
#if 0
		panic("invalid cmd to in6_lifaddr_ioctl");
		/* NOTREACHED */
#else
		return EOPNOTSUPP;
#endif
	}
	if (sizeof(struct in6_addr) * 8 < iflr->prefixlen)
		return EINVAL;

	switch (cmd) {
	case SIOCALIFADDR:
	    {
		struct in6_aliasreq ifra;
		struct in6_addr *hostid = NULL;
		int prefixlen;

		if ((iflr->flags & IFLR_PREFIX) != 0) {
			struct sockaddr_in6 *sin6;

			/*
			 * hostid is to fill in the hostid part of the
			 * address.  hostid points to the first link-local
			 * address attached to the interface.
			 */
			ifa = &in6ifa_ifpforlinklocal(ifp, 0)->ia_ifa;
			if (!ifa)
				return EADDRNOTAVAIL;
			hostid = IFA_IN6(ifa);

			/* prefixlen must be <= 64. */
			if (64 < iflr->prefixlen)
				return EINVAL;
			prefixlen = iflr->prefixlen;

			/* hostid part must be zero. */
			sin6 = (struct sockaddr_in6 *)&iflr->addr;
			if (sin6->sin6_addr.s6_addr32[2] != 0
			 || sin6->sin6_addr.s6_addr32[3] != 0) {
				return EINVAL;
			}
		} else
			prefixlen = iflr->prefixlen;

		/* copy args to in6_aliasreq, perform ioctl(SIOCAIFADDR_IN6). */
		bzero(&ifra, sizeof(ifra));
		bcopy(iflr->iflr_name, ifra.ifra_name, sizeof(ifra.ifra_name));

		bcopy(&iflr->addr, &ifra.ifra_addr, iflr->addr.ss_len);
		if (hostid) {
			/* fill in hostid part */
			ifra.ifra_addr.sin6_addr.s6_addr32[2] =
			    hostid->s6_addr32[2];
			ifra.ifra_addr.sin6_addr.s6_addr32[3] =
			    hostid->s6_addr32[3];
		}

		if (iflr->dstaddr.ss_family) {	/*XXX*/
			bcopy(&iflr->dstaddr, &ifra.ifra_dstaddr,
			    iflr->dstaddr.ss_len);
			if (hostid) {
				ifra.ifra_dstaddr.sin6_addr.s6_addr32[2] =
				    hostid->s6_addr32[2];
				ifra.ifra_dstaddr.sin6_addr.s6_addr32[3] =
				    hostid->s6_addr32[3];
			}
		}

		ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
		in6_prefixlen2mask(&ifra.ifra_prefixmask.sin6_addr, prefixlen);

		ifra.ifra_flags = iflr->flags & ~IFLR_PREFIX;
		return in6_ioctl(SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp,
		    privileged);
	    }
	case SIOCGLIFADDR:
	case SIOCDLIFADDR:
	    {
		struct in6_ifaddr *ia6;
		struct in6_addr mask, candidate, match;
		struct sockaddr_in6 *sin6;
		int cmp;

		bzero(&mask, sizeof(mask));
		if (iflr->flags & IFLR_PREFIX) {
			/* lookup a prefix rather than address. */
			in6_prefixlen2mask(&mask, iflr->prefixlen);

			sin6 = (struct sockaddr_in6 *)&iflr->addr;
			bcopy(&sin6->sin6_addr, &match, sizeof(match));
			match.s6_addr32[0] &= mask.s6_addr32[0];
			match.s6_addr32[1] &= mask.s6_addr32[1];
			match.s6_addr32[2] &= mask.s6_addr32[2];
			match.s6_addr32[3] &= mask.s6_addr32[3];

			/* if you set extra bits, that's wrong */
			if (bcmp(&match, &sin6->sin6_addr, sizeof(match)))
				return EINVAL;

			cmp = 1;
		} else {
			if (cmd == SIOCGLIFADDR) {
				/* on getting an address, take the 1st match */
				cmp = 0;	/* XXX */
			} else {
				/* on deleting an address, do exact match */
				in6_prefixlen2mask(&mask, 128);
				sin6 = (struct sockaddr_in6 *)&iflr->addr;
				bcopy(&sin6->sin6_addr, &match, sizeof(match));

				cmp = 1;
			}
		}

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			if (!cmp)
				break;

			bcopy(IFA_IN6(ifa), &candidate, sizeof(candidate));
			candidate.s6_addr32[0] &= mask.s6_addr32[0];
			candidate.s6_addr32[1] &= mask.s6_addr32[1];
			candidate.s6_addr32[2] &= mask.s6_addr32[2];
			candidate.s6_addr32[3] &= mask.s6_addr32[3];
			if (IN6_ARE_ADDR_EQUAL(&candidate, &match))
				break;
		}
		if (!ifa)
			return EADDRNOTAVAIL;
		ia6 = ifatoia6(ifa);

		if (cmd == SIOCGLIFADDR) {
			/* fill in the if_laddrreq structure */
			bcopy(&ia6->ia_addr, &iflr->addr, ia6->ia_addr.sin6_len);
			if ((ifp->if_flags & IFF_POINTOPOINT) != 0) {
				bcopy(&ia6->ia_dstaddr, &iflr->dstaddr,
				    ia6->ia_dstaddr.sin6_len);
			} else
				bzero(&iflr->dstaddr, sizeof(iflr->dstaddr));

			iflr->prefixlen =
			    in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);

			iflr->flags = ia6->ia6_flags;	/*XXX*/

			return 0;
		} else {
			struct in6_aliasreq ifra;

			/* fill in6_aliasreq and do ioctl(SIOCDIFADDR_IN6) */
			bzero(&ifra, sizeof(ifra));
			bcopy(iflr->iflr_name, ifra.ifra_name,
			    sizeof(ifra.ifra_name));

			bcopy(&ia6->ia_addr, &ifra.ifra_addr,
			    ia6->ia_addr.sin6_len);
			if ((ifp->if_flags & IFF_POINTOPOINT) != 0) {
				bcopy(&ia6->ia_dstaddr, &ifra.ifra_dstaddr,
				    ia6->ia_dstaddr.sin6_len);
			} else {
				bzero(&ifra.ifra_dstaddr,
				    sizeof(ifra.ifra_dstaddr));
			}
			bcopy(&ia6->ia_prefixmask, &ifra.ifra_dstaddr,
			    ia6->ia_prefixmask.sin6_len);

			ifra.ifra_flags = ia6->ia6_flags;
			return in6_ioctl(SIOCDIFADDR_IN6, (caddr_t)&ifra, ifp,
			    privileged);
		}
	    }
	}

	return EOPNOTSUPP;	/* just for safety */
}

/*
 * Initialize an interface's intetnet6 address
 * and routing table entry.
 */
int
in6_ifinit(struct ifnet *ifp, struct in6_ifaddr *ia6, int newhost)
{
	int	error = 0, plen, ifacount = 0;
	struct ifaddr *ifa;

	NET_ASSERT_LOCKED();

	/*
	 * Give the interface a chance to initialize
	 * if this is its first address (or it is a CARP interface)
	 * and to validate the address if necessary.
	 */
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ifacount++;
	}

	if ((ifacount <= 1 || ifp->if_type == IFT_CARP ||
	    (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))) &&
	    ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia6))) {
		return (error);
	}

	ia6->ia_ifa.ifa_metric = ifp->if_metric;

	/* we could do in(6)_socktrim here, but just omit it at this moment. */

	/*
	 * Special case:
	 * If the destination address is specified for a point-to-point
	 * interface, install a route to the destination as an interface
	 * direct route.
	 */
	plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL); /* XXX */
	if ((ifp->if_flags & IFF_POINTOPOINT) && plen == 128 &&
	    ia6->ia_dstaddr.sin6_family == AF_INET6) {
		ifa = &ia6->ia_ifa;
		error = rt_ifa_add(ifa, RTF_HOST, ifa->ifa_dstaddr);
		if (error != 0)
			return (error);
		ia6->ia_flags |= IFA_ROUTE;
	}

	if (newhost)
		error = rt_ifa_addlocal(&(ia6->ia_ifa));

	return (error);
}

/*
 * Add an address to the list of IP6 multicast addresses for a
 * given interface.
 */
struct in6_multi *
in6_addmulti(struct in6_addr *maddr6, struct ifnet *ifp, int *errorp)
{
	struct	in6_ifreq ifr;
	struct	in6_multi *in6m;

	NET_ASSERT_LOCKED();

	*errorp = 0;
	/*
	 * See if address already in list.
	 */
	IN6_LOOKUP_MULTI(*maddr6, ifp, in6m);
	if (in6m != NULL) {
		/*
		 * Found it; just increment the refrence count.
		 */
		in6m->in6m_refcnt++;
	} else {
		if (ifp->if_ioctl == NULL) {
			*errorp = ENXIO; /* XXX: appropriate? */
			return (NULL);
		}

		/*
		 * New address; allocate a new multicast record
		 * and link it into the interface's multicast list.
		 */
		in6m = malloc(sizeof(*in6m), M_IPMADDR, M_NOWAIT | M_ZERO);
		if (in6m == NULL) {
			*errorp = ENOBUFS;
			return (NULL);
		}

		in6m->in6m_sin.sin6_len = sizeof(struct sockaddr_in6);
		in6m->in6m_sin.sin6_family = AF_INET6;
		in6m->in6m_sin.sin6_addr = *maddr6;
		in6m->in6m_refcnt = 1;
		in6m->in6m_ifidx = ifp->if_index;
		in6m->in6m_ifma.ifma_addr = sin6tosa(&in6m->in6m_sin);

		/*
		 * Ask the network driver to update its multicast reception
		 * filter appropriately for the new address.
		 */
		memcpy(&ifr.ifr_addr, &in6m->in6m_sin, sizeof(in6m->in6m_sin));
		*errorp = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)&ifr);
		if (*errorp) {
			free(in6m, M_IPMADDR, sizeof(*in6m));
			return (NULL);
		}

		TAILQ_INSERT_HEAD(&ifp->if_maddrlist, &in6m->in6m_ifma,
		    ifma_list);

		/*
		 * Let MLD6 know that we have joined a new IP6 multicast
		 * group.
		 */
		mld6_start_listening(in6m);
	}

	return (in6m);
}

/*
 * Delete a multicast address record.
 */
void
in6_delmulti(struct in6_multi *in6m)
{
	struct	in6_ifreq ifr;
	struct	ifnet *ifp;

	NET_ASSERT_LOCKED();

	if (--in6m->in6m_refcnt == 0) {
		/*
		 * No remaining claims to this record; let MLD6 know
		 * that we are leaving the multicast group.
		 */
		mld6_stop_listening(in6m);
		ifp = if_get(in6m->in6m_ifidx);

		/*
		 * Notify the network driver to update its multicast
		 * reception filter.
		 */
		if (ifp != NULL) {
			bzero(&ifr.ifr_addr, sizeof(struct sockaddr_in6));
			ifr.ifr_addr.sin6_len = sizeof(struct sockaddr_in6);
			ifr.ifr_addr.sin6_family = AF_INET6;
			ifr.ifr_addr.sin6_addr = in6m->in6m_addr;
			(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);

			TAILQ_REMOVE(&ifp->if_maddrlist, &in6m->in6m_ifma,
			    ifma_list);
		}
		if_put(ifp);

		free(in6m, M_IPMADDR, sizeof(*in6m));
	}
}

/*
 * Return 1 if the multicast group represented by ``maddr6'' has been
 * joined by interface ``ifp'', 0 otherwise.
 */
int
in6_hasmulti(struct in6_addr *maddr6, struct ifnet *ifp)
{
	struct in6_multi *in6m;
	int joined;

	IN6_LOOKUP_MULTI(*maddr6, ifp, in6m);
	joined = (in6m != NULL);

	return (joined);
}

struct in6_multi_mship *
in6_joingroup(struct ifnet *ifp, struct in6_addr *addr, int *errorp)
{
	struct in6_multi_mship *imm;

	imm = malloc(sizeof(*imm), M_IPMADDR, M_NOWAIT);
	if (!imm) {
		*errorp = ENOBUFS;
		return NULL;
	}
	imm->i6mm_maddr = in6_addmulti(addr, ifp, errorp);
	if (!imm->i6mm_maddr) {
		/* *errorp is alrady set */
		free(imm, M_IPMADDR, sizeof(*imm));
		return NULL;
	}
	return imm;
}

void
in6_leavegroup(struct in6_multi_mship *imm)
{

	if (imm->i6mm_maddr)
		in6_delmulti(imm->i6mm_maddr);
	free(imm,  M_IPMADDR, sizeof(*imm));
}

/*
 * Find an IPv6 interface link-local address specific to an interface.
 */
struct in6_ifaddr *
in6ifa_ifpforlinklocal(struct ifnet *ifp, int ignoreflags)
{
	struct ifaddr *ifa;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa))) {
			if ((ifatoia6(ifa)->ia6_flags & ignoreflags) != 0)
				continue;
			break;
		}
	}

	return (ifatoia6(ifa));
}


/*
 * find the internet address corresponding to a given interface and address.
 */
struct in6_ifaddr *
in6ifa_ifpwithaddr(struct ifnet *ifp, struct in6_addr *addr)
{
	struct ifaddr *ifa;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (IN6_ARE_ADDR_EQUAL(addr, IFA_IN6(ifa)))
			break;
	}

	return (ifatoia6(ifa));
}

/*
 * Get a scope of the address. Node-local, link-local, site-local or global.
 */
int
in6_addrscope(struct in6_addr *addr)
{
	int scope;

	if (addr->s6_addr8[0] == 0xfe) {
		scope = addr->s6_addr8[1] & 0xc0;

		switch (scope) {
		case 0x80:
			return __IPV6_ADDR_SCOPE_LINKLOCAL;
			break;
		case 0xc0:
			return __IPV6_ADDR_SCOPE_SITELOCAL;
			break;
		default:
			return __IPV6_ADDR_SCOPE_GLOBAL; /* just in case */
			break;
		}
	}


	if (addr->s6_addr8[0] == 0xff) {
		scope = addr->s6_addr8[1] & 0x0f;

		/*
		 * due to other scope such as reserved,
		 * return scope doesn't work.
		 */
		switch (scope) {
		case __IPV6_ADDR_SCOPE_INTFACELOCAL:
			return __IPV6_ADDR_SCOPE_INTFACELOCAL;
			break;
		case __IPV6_ADDR_SCOPE_LINKLOCAL:
			return __IPV6_ADDR_SCOPE_LINKLOCAL;
			break;
		case __IPV6_ADDR_SCOPE_SITELOCAL:
			return __IPV6_ADDR_SCOPE_SITELOCAL;
			break;
		default:
			return __IPV6_ADDR_SCOPE_GLOBAL;
			break;
		}
	}

	if (bcmp(&in6addr_loopback, addr, sizeof(*addr) - 1) == 0) {
		if (addr->s6_addr8[15] == 1) /* loopback */
			return __IPV6_ADDR_SCOPE_INTFACELOCAL;
		if (addr->s6_addr8[15] == 0) /* unspecified */
			return __IPV6_ADDR_SCOPE_LINKLOCAL;
	}

	return __IPV6_ADDR_SCOPE_GLOBAL;
}

int
in6_addr2scopeid(unsigned int ifidx, struct in6_addr *addr)
{
	int scope = in6_addrscope(addr);

	switch(scope) {
	case __IPV6_ADDR_SCOPE_INTFACELOCAL:
	case __IPV6_ADDR_SCOPE_LINKLOCAL:
		/* XXX: we do not distinguish between a link and an I/F. */
		return (ifidx);

	case __IPV6_ADDR_SCOPE_SITELOCAL:
		return (0);	/* XXX: invalid. */

	default:
		return (0);	/* XXX: treat as global. */
	}
}

/*
 * return length of part which dst and src are equal
 * hard coding...
 */
int
in6_matchlen(struct in6_addr *src, struct in6_addr *dst)
{
	int match = 0;
	u_char *s = (u_char *)src, *d = (u_char *)dst;
	u_char *lim = s + 16, r;

	while (s < lim)
		if ((r = (*d++ ^ *s++)) != 0) {
			while (r < 128) {
				match++;
				r <<= 1;
			}
			break;
		} else
			match += 8;
	return match;
}

int
in6_are_prefix_equal(struct in6_addr *p1, struct in6_addr *p2, int len)
{
	int bytelen, bitlen;

	/* sanity check */
	if (0 > len || len > 128) {
		log(LOG_ERR, "in6_are_prefix_equal: invalid prefix length(%d)\n",
		    len);
		return (0);
	}

	bytelen = len / 8;
	bitlen = len % 8;

	if (bcmp(&p1->s6_addr, &p2->s6_addr, bytelen))
		return (0);
	/* len == 128 is ok because bitlen == 0 then */
	if (bitlen != 0 &&
	    p1->s6_addr[bytelen] >> (8 - bitlen) !=
	    p2->s6_addr[bytelen] >> (8 - bitlen))
		return (0);

	return (1);
}

void
in6_prefixlen2mask(struct in6_addr *maskp, int len)
{
	u_char maskarray[8] = {0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff};
	int bytelen, bitlen, i;

	/* sanity check */
	if (0 > len || len > 128) {
		log(LOG_ERR, "in6_prefixlen2mask: invalid prefix length(%d)\n",
		    len);
		return;
	}

	bzero(maskp, sizeof(*maskp));
	bytelen = len / 8;
	bitlen = len % 8;
	for (i = 0; i < bytelen; i++)
		maskp->s6_addr[i] = 0xff;
	/* len == 128 is ok because bitlen == 0 then */
	if (bitlen)
		maskp->s6_addr[bytelen] = maskarray[bitlen - 1];
}

/*
 * return the best address out of the same scope
 */
struct in6_ifaddr *
in6_ifawithscope(struct ifnet *oifp, struct in6_addr *dst, u_int rdomain)
{
	int dst_scope =	in6_addrscope(dst), src_scope, best_scope = 0;
	int blen = -1;
	struct ifaddr *ifa;
	struct ifnet *ifp;
	struct in6_ifaddr *ia6_best = NULL;

	if (oifp == NULL) {
		printf("in6_ifawithscope: output interface is not specified\n");
		return (NULL);
	}

	/*
	 * We search for all addresses on all interfaces from the beginning.
	 * Comparing an interface with the outgoing interface will be done
	 * only at the final stage of tiebreaking.
	 */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rdomain)
			continue;
#if NCARP > 0
		/*
		 * Never use a carp address of an interface which is not
		 * the master.
		 */
		if (ifp->if_type == IFT_CARP && !carp_iamatch6(ifp))
			continue;
#endif

		/*
		 * We can never take an address that breaks the scope zone
		 * of the destination.
		 */
		if (in6_addr2scopeid(ifp->if_index, dst) !=
		    in6_addr2scopeid(oifp->if_index, dst))
			continue;

		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			int tlen = -1, dscopecmp, bscopecmp, matchcmp;

			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;

			src_scope = in6_addrscope(IFA_IN6(ifa));

#ifdef ADDRSELECT_DEBUG		/* should be removed after stabilization */
		{
			char adst[INET6_ADDRSTRLEN], asrc[INET6_ADDRSTRLEN];
			char bestaddr[INET6_ADDRSTRLEN];


			dscopecmp = IN6_ARE_SCOPE_CMP(src_scope, dst_scope);
			printf("in6_ifawithscope: dst=%s bestaddr=%s, "
			       "newaddr=%s, scope=%x, dcmp=%d, bcmp=%d, "
			       "matchlen=%d, flgs=%x\n",
			       inet_ntop(AF_INET6, dst, adst, sizeof(adst)),
			       (ia6_best == NULL) ? "none" :
			       inet_ntop(AF_INET6, &ia6_best->ia_addr.sin6_addr,
			           bestaddr, sizeof(bestaddr)),
			       inet_ntop(AF_INET6, IFA_IN6(ifa),
			           asrc, sizeof(asrc)),
			       src_scope, dscopecmp,
			       ia6_best ? IN6_ARE_SCOPE_CMP(src_scope, best_scope) : -1,
			       in6_matchlen(IFA_IN6(ifa), dst),
			       ifatoia6(ifa)->ia6_flags);
		}
#endif

			/*
			 * Don't use an address before completing DAD
			 * nor a duplicated address.
			 */
			if (ifatoia6(ifa)->ia6_flags &
			    (IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED))
				continue;

			/* XXX: is there any case to allow anycasts? */
			if (ifatoia6(ifa)->ia6_flags & IN6_IFF_ANYCAST)
				continue;

			if (ifatoia6(ifa)->ia6_flags & IN6_IFF_DETACHED)
				continue;

			/*
			 * If this is the first address we find,
			 * keep it anyway.
			 */
			if (ia6_best == NULL)
				goto replace;

			/*
			 * ia6_best is never NULL beyond this line except
			 * within the block labeled "replace".
			 */

			/*
			 * If ia6_best has a smaller scope than dst and
			 * the current address has a larger one than
			 * (or equal to) dst, always replace ia6_best.
			 * Also, if the current address has a smaller scope
			 * than dst, ignore it unless ia6_best also has a
			 * smaller scope.
			 */
			if (IN6_ARE_SCOPE_CMP(best_scope, dst_scope) < 0 &&
			    IN6_ARE_SCOPE_CMP(src_scope, dst_scope) >= 0)
				goto replace;
			if (IN6_ARE_SCOPE_CMP(src_scope, dst_scope) < 0 &&
			    IN6_ARE_SCOPE_CMP(best_scope, dst_scope) >= 0)
				continue;

			/*
			 * A deprecated address SHOULD NOT be used in new
			 * communications if an alternate (non-deprecated)
			 * address is available and has sufficient scope.
			 * RFC 2462, Section 5.5.4.
			 */
			if (ifatoia6(ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
				/*
				 * Ignore any deprecated addresses if
				 * specified by configuration.
				 */
				if (!ip6_use_deprecated)
					continue;

				/*
				 * If we have already found a non-deprecated
				 * candidate, just ignore deprecated addresses.
				 */
				if ((ia6_best->ia6_flags & IN6_IFF_DEPRECATED)
				    == 0)
					continue;
			}

			/*
			 * A non-deprecated address is always preferred
			 * to a deprecated one regardless of scopes and
			 * address matching.
			 */
			if ((ia6_best->ia6_flags & IN6_IFF_DEPRECATED) &&
			    (ifatoia6(ifa)->ia6_flags &
			     IN6_IFF_DEPRECATED) == 0)
				goto replace;

			/* RFC 3484 5. Rule 5: Prefer outgoing interface */
			if (ia6_best->ia_ifp == oifp && ifp != oifp)
				continue;
			if (ia6_best->ia_ifp != oifp && ifp == oifp)
				goto replace;

			/*
			 * At this point, we have two cases:
			 * 1. we are looking at a non-deprecated address,
			 *    and ia6_best is also non-deprecated.
			 * 2. we are looking at a deprecated address,
			 *    and ia6_best is also deprecated.
			 * Also, we do not have to consider a case where
			 * the scope of if_best is larger(smaller) than dst and
			 * the scope of the current address is smaller(larger)
			 * than dst. Such a case has already been covered.
			 * Tiebreaking is done according to the following
			 * items:
			 * - the scope comparison between the address and
			 *   dst (dscopecmp)
			 * - the scope comparison between the address and
			 *   ia6_best (bscopecmp)
			 * - if the address match dst longer than ia6_best
			 *   (matchcmp)
			 * - if the address is on the outgoing I/F (outI/F)
			 *
			 * Roughly speaking, the selection policy is
			 * - the most important item is scope. The same scope
			 *   is best. Then search for a larger scope.
			 *   Smaller scopes are the last resort.
			 * - A deprecated address is chosen only when we have
			 *   no address that has an enough scope, but is
			 *   prefered to any addresses of smaller scopes.
			 * - Longest address match against dst is considered
			 *   only for addresses that has the same scope of dst.
			 * - If there is no other reasons to choose one,
			 *   addresses on the outgoing I/F are preferred.
			 *
			 * The precise decision table is as follows:
			 * dscopecmp bscopecmp matchcmp outI/F | replace?
			 *    !equal     equal      N/A    Yes |      Yes (1)
			 *    !equal     equal      N/A     No |       No (2)
			 *    larger    larger      N/A    N/A |       No (3)
			 *    larger   smaller      N/A    N/A |      Yes (4)
			 *   smaller    larger      N/A    N/A |      Yes (5)
			 *   smaller   smaller      N/A    N/A |       No (6)
			 *     equal   smaller      N/A    N/A |      Yes (7)
			 *     equal    larger       (already done)
			 *     equal     equal   larger    N/A |      Yes (8)
			 *     equal     equal  smaller    N/A |       No (9)
			 *     equal     equal    equal    Yes |      Yes (a)
			 *     equal     equal    equal     No |       No (b)
			 */
			dscopecmp = IN6_ARE_SCOPE_CMP(src_scope, dst_scope);
			bscopecmp = IN6_ARE_SCOPE_CMP(src_scope, best_scope);

			if (dscopecmp && bscopecmp == 0) {
				if (oifp == ifp) /* (1) */
					goto replace;
				continue; /* (2) */
			}
			if (dscopecmp > 0) {
				if (bscopecmp > 0) /* (3) */
					continue;
				goto replace; /* (4) */
			}
			if (dscopecmp < 0) {
				if (bscopecmp > 0) /* (5) */
					goto replace;
				continue; /* (6) */
			}

			/* now dscopecmp must be 0 */
			if (bscopecmp < 0)
				goto replace; /* (7) */

			/*
			 * At last both dscopecmp and bscopecmp must be 0.
			 * We need address matching against dst for
			 * tiebreaking.
			 * Privacy addresses are preferred over public
			 * addresses (RFC3484 requires a config knob for
			 * this which we don't provide).
			 */
			if (oifp == ifp) {
				/* Do not replace temporary autoconf addresses
				 * with non-temporary addresses. */
				if ((ia6_best->ia6_flags & IN6_IFF_PRIVACY) &&
			            !(ifatoia6(ifa)->ia6_flags &
				    IN6_IFF_PRIVACY))
					continue;

				/* Replace non-temporary autoconf addresses
				 * with temporary addresses. */
				if (!(ia6_best->ia6_flags & IN6_IFF_PRIVACY) &&
			            (ifatoia6(ifa)->ia6_flags &
				    IN6_IFF_PRIVACY))
					goto replace;
			}
			tlen = in6_matchlen(IFA_IN6(ifa), dst);
			matchcmp = tlen - blen;
			if (matchcmp > 0) { /* (8) */
#if NCARP > 0
				/* 
				 * Don't let carp interfaces win a tie against
				 * the output interface based on matchlen.
				 * We should only use a carp address if no
				 * other interface has a usable address.
				 * Otherwise, when communicating from a carp
				 * master to a carp slave, the slave won't
				 * respond since the carp address is also
				 * configured as a local address on the slave.
				 * Note that carp interfaces in backup state
				 * were already skipped above.
				 */
				if (ifp->if_type == IFT_CARP &&
				    oifp->if_type != IFT_CARP)
					continue;
#endif
				goto replace;
			}
			if (matchcmp < 0) /* (9) */
				continue;
			if (oifp == ifp) /* (a) */
				goto replace;
			continue; /* (b) */

		  replace:
			ia6_best = ifatoia6(ifa);
			blen = tlen >= 0 ? tlen :
				in6_matchlen(IFA_IN6(ifa), dst);
			best_scope = in6_addrscope(&ia6_best->ia_addr.sin6_addr);
		}
	}

	/* count statistics for future improvements */
	if (ia6_best == NULL)
		ip6stat_inc(ip6s_sources_none);
	else {
		if (oifp == ia6_best->ia_ifp)
			ip6stat_inc(ip6s_sources_sameif + best_scope);
		else
			ip6stat_inc(ip6s_sources_otherif + best_scope);

		if (best_scope == dst_scope)
			ip6stat_inc(ip6s_sources_samescope + best_scope);
		else
			ip6stat_inc(ip6s_sources_otherscope + best_scope);

		if ((ia6_best->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			ip6stat_inc(ip6s_sources_deprecated + best_scope);
	}

	return (ia6_best);
}

int
in6if_do_dad(struct ifnet *ifp)
{
	if ((ifp->if_flags & IFF_LOOPBACK) != 0)
		return (0);

	switch (ifp->if_type) {
#if NCARP > 0
	case IFT_CARP:
		/*
		 * XXX: DAD does not work currently on carp(4)
		 * so disable it for now.
		 */
		return (0);
#endif
	default:
		/*
		 * Our DAD routine requires the interface up and running.
		 * However, some interfaces can be up before the RUNNING
		 * status.  Additionaly, users may try to assign addresses
		 * before the interface becomes up (or running).
		 * We simply skip DAD in such a case as a work around.
		 * XXX: we should rather mark "tentative" on such addresses,
		 * and do DAD after the interface becomes ready.
		 */
		if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			return (0);

		return (1);
	}
}

void *
in6_domifattach(struct ifnet *ifp)
{
	struct in6_ifextra *ext;

	ext = malloc(sizeof(*ext), M_IFADDR, M_WAITOK | M_ZERO);

	ext->nd_ifinfo = nd6_ifattach(ifp);
	ext->nprefixes = 0;
	ext->ndefrouters = 0;
	return ext;
}

void
in6_domifdetach(struct ifnet *ifp, void *aux)
{
	struct in6_ifextra *ext = (struct in6_ifextra *)aux;

	nd6_ifdetach(ext->nd_ifinfo);
	free(ext, M_IFADDR, sizeof(*ext));
}
@


1.209
log
@Stop running nd6_expire every second.
We know when pltime or vltime decrease to zero. Run nd6_expire then.
Input & OK mpi, bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.208 2017/08/06 08:15:58 florian Exp $	*/
d164 18
@


1.208
log
@in6_leavegroup can't fail; OK phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.207 2017/07/11 12:51:05 florian Exp $	*/
d688 2
@


1.207
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.206 2017/05/29 20:28:57 florian Exp $	*/
d1353 1
a1353 1
int
a1359 1
	return 0;
@


1.206
log
@Allow passing in IN6_IFF_AUTOCONF from userland. Needed by slaacd(8)
OK naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.205 2017/05/16 12:24:02 mpi Exp $	*/
d905 4
a908 12
	if (ia6->ia6_ndpr == NULL) {
		plen = in6_mask2len(&ia6->ia_prefixmask.sin6_addr, NULL);
		if ((ifp->if_flags & IFF_LOOPBACK) == 0 && plen != 128) {
			rt_ifa_del(ifa, RTF_CLONING | RTF_CONNECTED,
			    ifa->ifa_addr);
		}
	} else {
		KASSERT(ia6->ia6_flags & IN6_IFF_AUTOCONF);
		ia6->ia6_flags &= ~IN6_IFF_AUTOCONF;
		if (--ia6->ia6_ndpr->ndpr_refcnt == 0)
			prelist_remove(ia6->ia6_ndpr);
		ia6->ia6_ndpr = NULL;
@


1.205
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.204 2017/05/08 08:46:39 rzalamena Exp $	*/
d410 1
a410 2
		    (ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0) {
@


1.204
log
@Added initial IPv6 multicast routing support for multiple rdomains:

* don't share mifs (multicast interface) between rdomains
* allow multiple routing sockets connected at the same time if they are
  in different rdomains.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.203 2017/05/04 15:00:24 bluhm Exp $	*/
d503 1
a503 1
	splsoftassert(IPL_SOFTNET);
d903 1
a903 1
	splsoftassert(IPL_SOFTNET);
d1173 1
a1173 1
	splsoftassert(IPL_SOFTNET);
d1229 1
a1229 1
	splsoftassert(IPL_SOFTNET);
d1297 1
a1297 1
	splsoftassert(IPL_SOFTNET);
@


1.203
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.202 2017/04/17 10:29:01 florian Exp $	*/
d179 1
a179 1
		return (mrt6_ioctl(cmd, data));
@


1.202
log
@We need to update the ia6_updatetime when changing the vltime/pltime
vio ioctl(2). Otherwise ifconfig shows the wrong times since
vltime/pltime are calculated from this value on export.

The handling of router advertisements does the right thing.
OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.201 2017/03/16 10:42:01 florian Exp $	*/
d973 1
a973 1
		sa = (struct sockaddr *)&iflr->addr;
d979 1
a979 1
		sa = (struct sockaddr *)&iflr->dstaddr;
d1034 1
a1034 2
		bcopy(&iflr->addr, &ifra.ifra_addr,
		    ((struct sockaddr *)&iflr->addr)->sa_len);
d1043 1
a1043 1
		if (((struct sockaddr *)&iflr->dstaddr)->sa_family) {	/*XXX*/
d1045 1
a1045 1
			    ((struct sockaddr *)&iflr->dstaddr)->sa_len);
@


1.201
log
@Userland expects pltime to be a time stamp not number of seconds.
pltime conversion was missing from rev 1.193 which did the vltime
conversion only.
OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.200 2017/03/06 08:59:07 mpi Exp $	*/
d668 1
@


1.200
log
@Kill global list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.199 2017/02/16 10:15:12 mpi Exp $	*/
d379 1
a379 1
			time_t maxexpire;
d391 1
a391 1
				retlt->ia6t_preferred = ia6->ia6_updatetime +
d393 5
@


1.199
log
@Revert "Release the NET_LOCK() before entering per-driver ioctl() routine".

This is most likely to be the cause of the deadlock seen by port builders
since it's the only changed that happened after a2k17.

Instead bring back pirofti@@ original hack to release the NET_LOCK() inside
iwm(4) and iwn(4).

This fixes some splassert reported by bluhm@@

Deadlock reported by naddy@@ and rpe@@ and ajacoutot@@ confirmed the deadlock
has been introduced post a2k17.

Tested by and ok tb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.198 2017/02/07 10:08:21 mpi Exp $	*/
a616 1
		TAILQ_INSERT_TAIL(&in6_ifaddr, ia6, ia_list);
a897 2

	TAILQ_REMOVE(&in6_ifaddr, ia6, ia_list);
@


1.198
log
@Release the NET_LOCK() before entering per-driver ioctl() routine.

This prevents a deadlock with the X server and some wireless drivers.
The real fix is to take unix domain socket code out of the NET_LOCK().

Issue reported by pirofti@@ and ajacoutot@@

ok tb@@, stsp@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.197 2017/02/05 16:04:14 jca Exp $	*/
a474 2
		/* XXXSMP breaks atomicity */
		rw_exit_write(&netlock);
a475 1
		rw_enter_write(&netlock);
@


1.197
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.196 2016/12/21 12:11:12 mpi Exp $	*/
d193 1
d473 1
a473 1
		if (ifp == NULL || ifp->if_ioctl == 0)
d475 5
a479 1
		return ((*ifp->if_ioctl)(ifp, cmd, data));
@


1.196
log
@Remove recursive splsoftnet() from the ioctl(2) path.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.195 2016/11/28 14:14:39 mpi Exp $	*/
d1842 1
a1842 1
		ip6stat.ip6s_sources_none++;
d1845 1
a1845 1
			ip6stat.ip6s_sources_sameif[best_scope]++;
d1847 1
a1847 1
			ip6stat.ip6s_sources_otherif[best_scope]++;
d1850 1
a1850 1
			ip6stat.ip6s_sources_samescope[best_scope]++;
d1852 1
a1852 1
			ip6stat.ip6s_sources_otherscope[best_scope]++;
d1855 1
a1855 1
			ip6stat.ip6s_sources_deprecated[best_scope]++;
@


1.195
log
@Explicitly initialize rti_ifa when automagically adding a route.

This will allow to strengthen checks when userland adds a route.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.194 2016/10/04 14:04:19 mpi Exp $	*/
a192 1
	int s;
a424 1
		s = splsoftnet();
d426 1
a426 2
		if (error != 0) {
			splx(s);
a427 1
		}
a428 1
		splx(s);
a455 1
		s = splsoftnet();
a459 1
			splx(s);
a462 1
		splx(s);
a466 1
		s = splsoftnet();
a468 1
		splx(s);
d1224 2
a1225 1
	int	s;
a1270 1
		s = splsoftnet();
a1272 1
		splx(s);
d1292 2
a1293 1
	int	s;
a1313 1
			s = splsoftnet();
a1315 1
			splx(s);
@


1.194
log
@Correct the flag checks inside rt_ifa_addlocal(9) and rt_ifa_dellocal(9).

There's no need to insert an RTF_LOCAL route if it is already there, not
if a route with the same destination exist.

This fixes a KASSERT() triggered by adding an alias for an address already
present in the ARP cache as reported by weerd@@ and Peter J. Philipp.

This should also fix a KASSERT() triggered by a NDP change reported by
Sebastien Marie.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.193 2016/10/03 12:33:21 mpi Exp $	*/
d749 1
a749 3
			/*
			 * 32bit came from "mltmask"
			 */
d761 1
d818 1
@


1.193
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.192 2016/09/04 10:32:01 mpi Exp $	*/
d1220 1
a1220 1
		rt_ifa_addlocal(&(ia6->ia_ifa));
@


1.192
log
@Purge routes attached to an address when this address is removed.

This is done to stop using stale ifa attached to routes, which is
the easiest way to make rtisvalid(9) MP-safe.

sthen@@ and henning@@ like it, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.191 2016/08/22 10:33:22 mpi Exp $	*/
d356 1
a356 1
			time_t maxexpire;
d368 1
a368 1
				retlt->ia6t_expire = ia6->ia6_updatetime +
d370 5
d612 1
a612 1
		ia6->ia6_createtime = ia6->ia6_updatetime = time_second;
d675 1
a675 1
		    time_second + ia6->ia6_lifetime.ia6t_vltime;
d680 1
a680 1
		    time_second + ia6->ia6_lifetime.ia6t_pltime;
@


1.191
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.190 2016/08/08 13:09:36 mpi Exp $	*/
d898 1
a902 2
	ifa_del(ifp, ifa);

d920 5
a924 4
	/*
	 * release another refcnt for the link from in6_ifaddr.
	 * Note that we should decrement the refcnt at least once for all *BSD.
	 */
@


1.190
log
@Execute address hooks in the update case.

This matches what IPv4 is doing and unbreak carp(4) when the same
address is set twice, for example when running netstart(8) multiple
times.

Issue reported by and fix from Simon Mages.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.189 2016/07/13 08:40:46 mpi Exp $	*/
d1920 1
a1920 1
	free(ext, M_IFADDR, 0);
@


1.189
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.188 2016/07/05 10:17:14 mpi Exp $	*/
d441 2
a442 1
		if (!newifaddr)
d444 1
@


1.188
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.187 2016/06/13 10:34:40 mpi Exp $	*/
d760 1
a760 2
			/* XXX: we need RTF_CLONING to fake nd6_rtrequest */
			info.rti_flags = RTF_CLONING;
d816 1
a816 1
			info.rti_flags = RTF_CLONING;
@


1.187
log
@Move the ioctl(2) logic of in{,6}_control() into two new functions
in{,6}_ioctl() that do not deal with sockets.

This will allow to automagically configure interface addresses in
the kernel without too many layer violations.

Required by upcoming umb(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.186 2016/03/03 12:57:15 jca Exp $	*/
d1640 2
a1641 1
			if (ifatoia6(ifa)->ia6_flags & IN6_IFF_NOTREADY)
@


1.186
log
@Kill IPv6 prefix and router renumbering ioctls.

Router renumbering was never supported, prefix ioctls were deprecated
~15 years ago.  Move some items in netinet6/nd6.h where they are still
used.

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.184 2016/02/28 07:15:34 stefan Exp $	*/
d121 2
a122 1
int in6_lifaddr_ioctl(struct socket *, u_long, caddr_t, struct ifnet *);
d169 1
a169 5
	struct	in6_ifreq *ifr = (struct in6_ifreq *)data;
	struct	in6_ifaddr *ia6 = NULL;
	struct	in6_aliasreq *ifra = (struct in6_aliasreq *)data;
	struct sockaddr_in6 *sa6;
	int s, privileged;
d183 12
d218 1
a218 1
		return in6_lifaddr_ioctl(so, cmd, data, ifp);
d951 1
a951 2
in6_lifaddr_ioctl(struct socket *so, u_long cmd, caddr_t data,
    struct ifnet *ifp)
d1058 2
a1059 1
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp);
d1154 2
a1155 2
			return in6_control(so, SIOCDIFADDR_IN6, (caddr_t)&ifra,
			    ifp);
@


1.185
log
@Delete all traces of SIOCSIF(ADDR|DSTADDR|NETMASK)_IN6

Those ioctls never made sense, IPv6 was designed right from the start
with support for multiple addresses by interface.

ok mikeb@@ mpi@@
@
text
@a202 13
	case SIOCSIFPREFIX_IN6:
	case SIOCDIFPREFIX_IN6:
	case SIOCAIFPREFIX_IN6:
	case SIOCCIFPREFIX_IN6:
	case SIOCSGIFPREFIX_IN6:
	case SIOCGIFPREFIX_IN6:
		log(LOG_NOTICE,
		    "prefix ioctls are now invalidated. "
		    "please use ifconfig.\n");
		return (EOPNOTSUPP);
	}

	switch (cmd) {
@


1.184
log
@Remove SIOCSIFALIFETIME_IN6 ioctl, as NetBSD did.

As described in NetBSD kern/35897 PR, the parameters
this ioctl needs overlay each other in a union. The ioctl
cannot have worked properly.

Discovered while discussing overflow checks with mmcc@@ and mpi@@
The checks were part of the removed code.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.183 2016/01/21 11:23:48 mpi Exp $	*/
a241 1
	case SIOCSIFADDR_IN6:
a242 2
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
a291 9
	case SIOCSIFADDR_IN6:
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
		/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are deprecated.
		 */
		return (EINVAL);

@


1.183
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.182 2015/12/22 10:01:01 mpi Exp $	*/
a255 1
	case SIOCSIFALIFETIME_IN6:
a338 20
	case SIOCSIFALIFETIME_IN6:
	    {
		struct in6_addrlifetime *lt;

		if (!privileged)
			return (EPERM);
		if (ia6 == NULL)
			return (EADDRNOTAVAIL);
		/* sanity for overflow - beware unsigned */
		lt = &ifr->ifr_ifru.ifru_lifetime;
		if (lt->ia6t_vltime != ND6_INFINITE_LIFETIME
		 && lt->ia6t_vltime + time_second < time_second) {
			return EINVAL;
		}
		if (lt->ia6t_pltime != ND6_INFINITE_LIFETIME
		 && lt->ia6t_pltime + time_second < time_second) {
			return EINVAL;
		}
		break;
	    }
a406 15
		break;

	case SIOCSIFALIFETIME_IN6:
		ia6->ia6_lifetime = ifr->ifr_ifru.ifru_lifetime;
		/* for sanity */
		if (ia6->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			ia6->ia6_lifetime.ia6t_expire =
				time_second + ia6->ia6_lifetime.ia6t_vltime;
		} else
			ia6->ia6_lifetime.ia6t_expire = 0;
		if (ia6->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			ia6->ia6_lifetime.ia6t_preferred =
				time_second + ia6->ia6_lifetime.ia6t_pltime;
		} else
			ia6->ia6_lifetime.ia6t_preferred = 0;
@


1.182
log
@Do not return EEXIST if the same address is added twice.

Reported by sebastisa@@.

ok sebasitia@@, stsp@@, florian@@, vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.181 2015/12/03 13:13:42 tedu Exp $	*/
d1379 16
@


1.181
log
@add sizes to some free() calls. ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.180 2015/12/01 10:03:53 mpi Exp $	*/
d447 1
a447 1
		int plen, error = 0;
d457 3
d465 1
a465 1
		if ((ia6 == NULL) && in6if_do_dad(ifp))
d483 3
a485 2
		if ((ia6 = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr))
		    == NULL) {
d492 3
@


1.180
log
@Remove "just for safety" over engineering checks.

ifa->ifa_addr must not be NULL when an ifa is on a per-interface list of
addresses.

ok bluhm@@, sthen@@, benno@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.179 2015/11/18 13:58:02 mpi Exp $	*/
d1315 1
a1315 1
			free(in6m, M_IPMADDR, 0);
d1370 1
a1370 1
		free(in6m, M_IPMADDR, 0);
d1387 1
a1387 1
		free(imm, M_IPMADDR, 0);
d1399 1
a1399 1
	free(imm,  M_IPMADDR, 0);
@


1.179
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.178 2015/11/02 15:05:23 mpi Exp $	*/
a1225 2
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
a1411 2
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
a1433 2
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
@


1.178
log
@Retire ARP load-balacing, thanks for all the fish!

One of the keys of our MP work relies on making OpenBSD's kernel simpler!
In this case turning ARP processing MP-safe is quite complicated due to
the way carp(4) is hooked in arpinput() and nowadays you'd better run
kitchensinkd(9) anyway :)

ok bluhm@@, claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.177 2015/10/30 09:39:42 bluhm Exp $	*/
a63 1
#include "bridge.h"
a85 3
#if NBRIDGE > 0
#include <net/if_bridge.h>
#endif
a1446 38
}

/*
 * Check whether an interface has a prefix by looking up the cloning route.
 */
int
in6_ifpprefix(const struct ifnet *ifp, const struct in6_addr *addr)
{
	struct sockaddr_in6 dst;
	struct rtentry *rt;
	u_int tableid = ifp->if_rdomain;

	bzero(&dst, sizeof(dst));
	dst.sin6_len = sizeof(struct sockaddr_in6);
	dst.sin6_family = AF_INET6;
	dst.sin6_addr = *addr;
	rt = rtalloc(sin6tosa(&dst), 0, tableid);

	if (rt == NULL)
		return (0);
	if ((rt->rt_flags & (RTF_CLONING | RTF_CLONED)) == 0 ||
	    (rt->rt_ifp != ifp &&
#if NBRIDGE > 0
	    !SAME_BRIDGE(rt->rt_ifp->if_bridgeport, ifp->if_bridgeport) &&
#endif
#if NCARP > 0
	    (ifp->if_type != IFT_CARP || rt->rt_ifp != ifp->if_carpdev) &&
	    (rt->rt_ifp->if_type != IFT_CARP || rt->rt_ifp->if_carpdev != ifp)&&
	    (ifp->if_type != IFT_CARP || rt->rt_ifp->if_type != IFT_CARP ||
	    rt->rt_ifp->if_carpdev != ifp->if_carpdev) &&
#endif
	    1)) {
		rtfree(rt);
		return (0);
	}

	rtfree(rt);
	return (1);
@


1.177
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.176 2015/10/25 11:58:11 mpi Exp $	*/
a1650 3
#if NCARP > 0
	struct sockaddr_dl *proxydl = NULL;
#endif
d1670 1
a1670 2
		if (ifp->if_type == IFT_CARP &&
		    !carp_iamatch6(ifp, NULL, &proxydl))
@


1.176
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.175 2015/09/12 20:50:17 mpi Exp $	*/
d811 1
a811 1
			error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, NULL,
d867 1
a867 1
			error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, NULL,
@


1.175
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.174 2015/09/10 16:39:39 mpi Exp $	*/
d1264 1
a1264 6
	/* Add ownaddr as loopback rtentry, if necessary (ex. on p2p link). */
	if (newhost) {
		/* set the rtrequest function to create llinfo */
		if ((ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) == 0)
			ia6->ia_ifa.ifa_rtrequest = nd6_rtrequest;

a1265 1
	}
@


1.174
log
@Kill in6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_IN6 is no longer supported.

ok mikeb@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.173 2015/09/10 14:02:35 bluhm Exp $	*/
d504 2
a505 2
		error = rt_ifa_add(&ia6->ia_ifa,
		    RTF_UP|RTF_CLONING|RTF_CONNECTED, ia6->ia_ifa.ifa_addr);
d810 1
a810 1
			info.rti_flags = RTF_UP | RTF_CLONING;
d866 1
a866 1
			info.rti_flags = RTF_UP | RTF_CLONING;
d1258 1
a1258 1
		error = rt_ifa_add(ifa, RTF_UP | RTF_HOST, ifa->ifa_dstaddr);
@


1.173
log
@In IPv6 source address selection prefer addresses of the outgoing
interface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.172 2015/09/10 08:45:32 claudio Exp $	*/
a390 8
		if (ifp == NULL)
			return EINVAL;
		bzero(&ifr->ifr_ifru.ifru_stat,
		    sizeof(ifr->ifr_ifru.ifru_stat));
		ifr->ifr_ifru.ifru_stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->in6_ifstat;
		break;

a1992 3
	ext->in6_ifstat = malloc(sizeof(*ext->in6_ifstat), M_IFADDR,
	    M_WAITOK | M_ZERO);

a2004 1
	free(ext->in6_ifstat, M_IFADDR, 0);
@


1.172
log
@Trivial if_put addition. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.171 2015/09/09 15:51:40 mpi Exp $	*/
d1803 6
@


1.171
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.170 2015/09/04 13:00:41 mpi Exp $	*/
d1388 1
@


1.170
log
@Tunnels also need a cloning route.

Fix a regression reported by Brad.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.169 2015/08/31 08:33:01 mpi Exp $	*/
d400 1
a400 7
		if (ifp == NULL)
			return EINVAL;
		bzero(&ifr->ifr_ifru.ifru_icmp6stat,
		    sizeof(ifr->ifr_ifru.ifru_icmp6stat));
		ifr->ifr_ifru.ifru_icmp6stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->icmp6_ifstat;
		break;
a1996 3
	ext->icmp6_ifstat = malloc(sizeof(*ext->icmp6_ifstat), M_IFADDR,
	    M_WAITOK | M_ZERO);

a2009 1
	free(ext->icmp6_ifstat, M_IFADDR, 0);
@


1.169
log
@Do not install connected routes on loopback interfaces.

Previously loopback connected routes were managed via the global list
of prefixes, which mean that systems with AUTOCONF'd addresses did not
see them in the routing table.

This also makes inet6 route creation coherent with inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.168 2015/08/24 23:26:43 mpi Exp $	*/
d465 1
a465 1
		int error = 0;
d511 2
a512 1
		if (ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) {
d960 1
d970 2
a971 1
		if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) == 0) {
@


1.168
log
@Start moving away from the global prefix list by limiting its usage to
AUTOCONF'd addresses.

This prevent the kernel from removing connected (/64) routes as soon as
it configures an AUTOCONF'd address based on a RA.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.167 2015/08/24 15:58:35 mpi Exp $	*/
d465 1
a465 1
		int plen, error = 0;
d511 1
a511 2
		plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr, NULL);
		if (plen == 128) {
d513 1
a513 1
			break;	/* we don't need to install a host route. */
d968 4
a971 1
		rt_ifa_del(ifa, RTF_CLONING | RTF_CONNECTED, ifa->ifa_addr);
@


1.167
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.166 2015/08/24 14:00:29 bluhm Exp $	*/
a464 1
		struct nd_prefix *pr;
a510 1

d517 7
a523 18
		/*
		 * then, make the prefix on-link on the interface.
		 * XXX: we'd rather create the prefix before the address, but
		 * we need at least one address to install the corresponding
		 * interface route, so we configure the address first.
		 */
		pr = nd6_prefix_add(ifp, &ifra->ifra_addr,
		    &ifra->ifra_prefixmask, &ifra->ifra_lifetime,
		    ((ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0));
		if (pr == NULL) {
			log(LOG_ERR, "cannot add prefix\n");
			return (EINVAL); /* XXX panic here? */
		}

		/* relate the address to the prefix */
		if (ia6->ia6_ndpr == NULL) {
			ia6->ia6_ndpr = pr;
			pr->ndpr_refcnt++;
a524 8

		s = splsoftnet();
		/*
		 * this might affect the status of autoconfigured addresses,
		 * that is, this address might make other addresses detached.
		 */
		pfxlist_onlink_check();

d959 2
d963 1
a963 1
	ifa_del(ifp, &ia6->ia_ifa);
d969 1
a969 9
		char addr[INET6_ADDRSTRLEN];

		if (!IN6_IS_ADDR_LINKLOCAL(IA6_IN6(ia6)) &&
		    !IN6_IS_ADDR_LOOPBACK(IA6_IN6(ia6)) &&
		    !IN6_ARE_ADDR_EQUAL(IA6_MASKIN6(ia6), &in6mask128))
			log(LOG_NOTICE, "in6_unlink_ifa: interface address "
			    "%s has no prefix\n",
			    inet_ntop(AF_INET6, IA6_IN6(ia6), addr,
				sizeof(addr)));
d971 1
@


1.166
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.165 2015/08/19 13:27:38 bluhm Exp $	*/
a470 1
		    (ifra->ifra_flags & IN6_IFF_NODAD) != 0 ||
d475 9
d508 5
a768 9
	/*
	 * Make the address tentative before joining multicast addresses,
	 * so that corresponding MLD responses would not have a tentative
	 * source address.
	 */
	ia6->ia6_flags &= ~IN6_IFF_DUPLICATED;	/* safety */
	if (hostIsNew && in6if_do_dad(ifp) &&
	    (ifra->ifra_flags & IN6_IFF_NODAD) == 0)
		ia6->ia6_flags |= IN6_IFF_TENTATIVE;
a912 11
	}

	/*
	 * Perform DAD, if needed.
	 * XXX It may be of use, if we can administratively
	 * disable DAD.
	 */
	if (hostIsNew && in6if_do_dad(ifp) &&
	    (ifra->ifra_flags & IN6_IFF_NODAD) == 0)
	{
		nd6_dad_start(&ia6->ia_ifa, NULL);
@


1.165
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.164 2015/08/19 11:09:24 mpi Exp $	*/
d871 1
a871 1
		bzero(&mltaddr.sin6_addr, sizeof(mltaddr.sin6_addr));
d1349 1
a1349 1
		in6m = malloc(sizeof(*in6m), M_IPMADDR, M_NOWAIT);
@


1.164
log
@Remove some verbose logs in in6_update_ifa() now that errors are
propagated.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.163 2015/08/18 08:48:36 mpi Exp $	*/
d898 2
a899 2
			error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED,
			    NULL, ifp->if_rdomain);
@


1.163
log
@Check the error value returned by in6_ifattach().

Prodded by and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.162 2015/08/12 09:06:18 mpi Exp $	*/
d641 1
a641 4
		if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) == 0) {
			/* XXX: noisy message */
			nd6log((LOG_INFO, "in6_update_ifa: a destination can "
			    "be specified for a p2p or a loopback IF only\n"));
d643 1
a643 4
		}
		if (plen != 128) {
			nd6log((LOG_INFO, "in6_update_ifa: prefixlen should "
			    "be 128 when dstaddr is specified\n"));
a644 1
		}
a703 4
			nd6log((LOG_INFO, "in6_update_ifa: the prefix length of an"
			    " existing (%s) address should not be changed\n",
			    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
				addr, sizeof(addr))));
d795 1
a795 6
		if (!imm) {
			nd6log((LOG_ERR, "in6_update_ifa: "
			    "addmulti failed for %s on %s (errno=%d)\n",
			    inet_ntop(AF_INET6, &llsol.sin6_addr,
				addr, sizeof(addr)),
			    ifp->if_xname, error));
a796 1
		}
d850 1
a850 7
		if (!imm) {
			nd6log((LOG_WARNING,
			    "in6_update_ifa: addmulti failed for "
			    "%s on %s (errno=%d)\n",
			    inet_ntop(AF_INET6, &mltaddr.sin6_addr,
				addr, sizeof(addr)),
			    ifp->if_xname, error));
a851 1
		}
a859 5
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s (errno=%d)\n",
				    inet_ntop(AF_INET6, &mltaddr.sin6_addr,
					addr, sizeof(addr)),
				    ifp->if_xname, error));
d906 1
a906 6
		if (!imm) {
			nd6log((LOG_WARNING, "in6_update_ifa: "
			    "addmulti failed for %s on %s (errno=%d)\n",
			    inet_ntop(AF_INET6, &mltaddr.sin6_addr,
				addr, sizeof(addr)),
			    ifp->if_xname, error));
a907 1
		}
@


1.162
log
@Remove backward compatibilify goos for IN6_IFF_DEPRECATED and instead
reject SIOCAIFADDR_IN6 ioctl(2) where it is set.

ok jca@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.161 2015/07/18 15:05:32 mpi Exp $	*/
d482 5
a486 1
		in6_ifattach(ifp);
@


1.161
log
@Merge two identical chunks to add new prefixes to the global data
structures into a function.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.160 2015/07/08 08:48:34 mpi Exp $	*/
d472 1
a762 8
	/*
	 * backward compatibility - if IN6_IFF_DEPRECATED is set from the
	 * userland, make it deprecated.
	 */
	if ((ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0) {
		ia6->ia6_lifetime.ia6t_pltime = 0;
		ia6->ia6_lifetime.ia6t_preferred = time_second;
	}
@


1.160
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.159 2015/06/08 22:19:27 krw Exp $	*/
d465 2
a466 2
		int i, error = 0;
		struct nd_prefix pr0, *pr;
d495 6
d507 6
a512 46

		/*
		 * convert mask to prefix length (prefixmask has already
		 * been validated in in6_update_ifa().
		 */
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128) {
			dohooks(ifp->if_addrhooks, 0);
			break;	/* we don't need to install a host route. */
		}
		pr0.ndpr_prefix = ifra->ifra_addr;
		pr0.ndpr_mask = ifra->ifra_prefixmask.sin6_addr;
		/* apply the mask for safety. */
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ifra->ifra_prefixmask.sin6_addr.s6_addr32[i];
		}
		/*
		 * XXX: since we don't have an API to set prefix (not address)
		 * lifetimes, we just use the same lifetimes as addresses.
		 * The (temporarily) installed lifetimes can be overridden by
		 * later advertised RAs (when accept_rtadv is non 0), which is
		 * an intended behavior.
		 */
		pr0.ndpr_raf_onlink = 1; /* should be configurable? */
		pr0.ndpr_raf_auto =
		    ((ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0);
		pr0.ndpr_vltime = ifra->ifra_lifetime.ia6t_vltime;
		pr0.ndpr_pltime = ifra->ifra_lifetime.ia6t_pltime;

		/* add the prefix if not yet. */
		if ((pr = nd6_prefix_lookup(&pr0)) == NULL) {
			/*
			 * nd6_prelist_add will install the corresponding
			 * interface route.
			 */
			if ((error = nd6_prelist_add(&pr0, NULL, &pr)) != 0)
				return (error);
			if (pr == NULL) {
				log(LOG_ERR, "nd6_prelist_add succeeded but "
				    "no prefix\n");
				return (EINVAL); /* XXX panic here? */
			}
@


1.159
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.158 2015/05/26 12:19:52 mpi Exp $	*/
a1667 5
/*
 * ifp - must not be NULL
 * addr - must not be NULL
 */

d1669 1
a1669 1
in6_addr2scopeid(struct ifnet *ifp, struct in6_addr *addr)
d1677 1
a1677 1
		return (ifp->if_index);
d1801 2
a1802 1
		if (in6_addr2scopeid(ifp, dst) != in6_addr2scopeid(oifp, dst))
@


1.158
log
@Store the IP address of the corresponding ifa in the rt_gateway field
of RTF_CLONING and RTF_BROASCAST routes to not create MPATH conflicts
when IP address aliases are used.

This change makes it possible to have multiple RTF_CLONING routes with
the same priority.  Note that any of the existing RTF_CLONING route
might be used by the kernel to create a RTF_CLONED route which should
not be a problem with aliases since they are attached to the same ifp.

This unbreak address aliases since the kernel supports multiple connected
routes for a subnet.

Found the hardway by djm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.157 2015/05/15 12:00:57 claudio Exp $	*/
d480 1
a480 1
 		s = splsoftnet();
d488 1
a488 1
		    	/*
d757 1
a757 1
	    	struct ifaddr *ifa = &ia6->ia_ifa;
d1179 1
a1179 1
		 	/* prefixlen must be <= 64. */
d1467 1
a1467 1
	struct 	ifnet *ifp;
@


1.157
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.156 2015/04/20 09:07:42 mpi Exp $	*/
a830 4
		struct sockaddr_dl sa_dl = { sizeof(sa_dl), AF_LINK };

		sa_dl.sdl_type = ifp->if_type;
		sa_dl.sdl_index = ifp->if_index;
d891 1
a891 1
			info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
d960 1
a960 1
			info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
@


1.156
log
@Do not treat loopback interfaces as p2p interfaces and create only
one route to "::1".

Due to a clever BSD trick, the `ifa_dstaddr` field of addresses on
IFF_LOOPBACK ifps is set to the same value that `ifa_addr`.  That's
why filtering for broadcast addresses is so complicated, because
guess what, `ifa_broadaddr` is the same as `ifa_dstaddr`!

Sadly our IPv6 code was "only" checking for `ifa_dstaddr` without
looking if the ifa was attached to a IFF_POINTOTPOINT interface.
So it always tried to create two routes to "::1" and, with the
recent RTF_LOCAL work, succeed.

You should now have only one local route to "::1".

 ::1             ::1         UHl       14  0 32768     1 lo0
-::1             ::1         UH         0  0 32768     4 lo0

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.155 2015/04/20 08:53:36 mpi Exp $	*/
d81 1
d831 4
d895 1
a895 1
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia6->ia_addr);
d964 1
a964 1
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia6->ia_addr);
@


1.155
log
@Always call rt_ifa_dellocal(9) when removing an IPv6 address.

The routing layer already check for the correct ifa when asked
to delete a local route, so do not try to be clever here.

This change also prevent having a NULL ifp pointer in your routing
table when you delete loopback interfaces having the same address.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.154 2015/03/14 03:38:52 jsg Exp $	*/
d754 1
a754 1
	if (dst6.sin6_family == AF_INET6 &&
d1023 2
a1024 1
	if ((ia6->ia_flags & IFA_ROUTE) != 0 && ia6->ia_dstaddr.sin6_len != 0) {
d1368 2
a1369 1
	if (plen == 128 && ia6->ia_dstaddr.sin6_family == AF_INET6) {
@


1.154
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.153 2015/02/19 22:23:05 bluhm Exp $	*/
d1013 1
a1013 1
	struct in6_ifaddr *tmp, *ia6 = ifatoia6(ifa);
a1014 1
	int ia6_count = 0;
d1039 2
a1040 29
	/* Remove ownaddr's loopback rtentry, if it exists.
	 *
	 * Some of BSD variants do not remove cloned routes from an
	 * interface direct route, when removing the direct route (see
	 * comments in net/net_osdep.h).  Even for variants that do
	 * remove cloned routes, they could fail to remove the cloned
	 * routes when we handle multiple addresses that share a common
	 * prefix.  So, we should remove the route corresponding to the
	 * deleted address.
	 *
	 * Delete the entry only if exact one ifa exists.  More than one
	 * ifa can exist if we assign a same single address to multiple
	 * (probably p2p) interfaces.
	 * XXX: we should avoid such a configuration in IPv6...
	 */
	TAILQ_FOREACH(tmp, &in6_ifaddr, ia_list) {
		if (tmp->ia_ifp->if_rdomain != ifp->if_rdomain)
			continue;

		if (IN6_ARE_ADDR_EQUAL(&tmp->ia_addr.sin6_addr,
		    &ia6->ia_addr.sin6_addr)) {
			ia6_count++;
			if (ia6_count > 1)
				break;
		}
	}

	if (ia6_count == 1)
		rt_ifa_dellocal(&(ia6->ia_ifa));
@


1.153
log
@All other calls to pfxlist_onlink_check() are protected by splsoftnet.
Put an splsoftnet() around the call to pfxlist_onlink_check() in
in6_control(SIOCAIFADDR_IN6).  Include the call to dohooks() in the
protection like it is done elsewhere.
splassert failure reported and fix tested by matthieu@@;  OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.152 2015/01/27 10:34:27 mpi Exp $	*/
a82 1
#include <net/if_dl.h>
@


1.152
log
@Always call if_ioctl() for loopback interfaces, just like IPv4 do, to
make sure the default MTU is set for every address configured on the
ifp and not just the first one.

Regress test breakage reported by daniel@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.151 2015/01/27 10:31:19 mpi Exp $	*/
d555 1
d563 1
@


1.151
log
@Ensure that link-local addresses are correctly configured on loopback
interfaces.

When the kernel automagically configures IPv6 addresses on loopback
interfaces, start by assigning a link-local address and then try to
assign "::1".

Only the first configured loopback interface per rdomain can have the
"::1" address.  But even if other loopback interfaces failed to get
this address, because it is already taken, give them a chance to have
a link-local address.

While here change in6_ifattach() to return an error value and remove
duplicated code.

Fix a regression introduced by the NOINET6 flag removal.

ok henning@@, stsp@@, florian@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.150 2015/01/24 00:29:06 deraadt Exp $	*/
d1377 2
a1378 1
	    (ifp->if_flags & IFF_POINTOPOINT)) && ifp->if_ioctl &&
@


1.150
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.149 2015/01/10 11:43:37 mpi Exp $	*/
d481 1
a481 2
		if (in6ifa_ifpforlinklocal(ifp, 0) == NULL)
			in6_ifattach(ifp);
@


1.149
log
@Correct some comments and merge in6_if_up() into in6_ifattach() to
reflect that IPv6 link-local addresses are no longer automagically
configured the first time an interface is brought up.

ok henning@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.148 2015/01/06 21:26:46 stsp Exp $	*/
d74 1
@


1.148
log
@Remove the NOINET6 interface flag, a left-over from the times when IPv6
was enabled by default. Add AFATTACH/AFDETACH ioctls which enable/disable
an address family for an interface (currently used for IPv6 only).

New kernel needs new ifconfig for IPv6 configuration (address assignment
still works with old ifconfig making this easy to cross over).

Committing on behalf of henning@@ who is currently lebensmittelvergiftet.
ok stsp, benno, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.147 2014/12/08 10:38:48 mpi Exp $	*/
d481 1
a481 1
			in6_if_up(ifp);
a2084 28
}

/*
 * perform DAD when interface becomes IFF_UP.
 */
void
in6_if_up(struct ifnet *ifp)
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia6;
	int dad_delay;		/* delay ticks before DAD output */

	/*
	 * special cases, like 6to4, are handled in in6_ifattach
	 */
	in6_ifattach(ifp);

	dad_delay = 0;
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ia6 = ifatoia6(ifa);
		if (ia6->ia6_flags & IN6_IFF_TENTATIVE)
			nd6_dad_start(ifa, &dad_delay);
	}

	if (ifp->if_xflags & IFXF_AUTOCONF6)
		nd6_rs_output_set_timo(ND6_RS_OUTPUT_QUICK_INTERVAL);
@


1.147
log
@Do not take into account addresses configured in a different rdomain
to decide whether or not to remove local routes.

Prevent from having a NULL ifp pointer in the routing table when an
address present in another rdomain is removed from an interface.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.146 2014/11/24 12:43:54 mpi Exp $	*/
d476 2
a477 1
		 * and link it to the list.
d480 2
a609 4
		return (EAFNOSUPPORT);

	/* must have link-local */
	if (ifp->if_xflags & IFXF_NOINET6)
@


1.146
log
@Rename rt_ifa_addloop() into rt_ifa_addlocal() and make it return an
error code on failure (unchecked for the moment).

ok mikeb@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.145 2014/11/20 09:55:57 mpi Exp $	*/
d1056 3
@


1.145
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.144 2014/11/01 21:40:39 mpi Exp $	*/
d1065 1
a1065 1
		rt_ifa_delloop(&(ia6->ia_ifa));
d1405 1
a1405 1
		rt_ifa_addloop(&(ia6->ia_ifa));
@


1.144
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.143 2014/10/22 09:48:19 stsp Exp $	*/
a2143 22
}

/*
 * Calculate max IPv6 MTU through all the interfaces and store it
 * to in6_maxmtu.
 */
void
in6_setmaxmtu(void)
{
	unsigned long maxmtu = 0;
	struct ifnet *ifp;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		/* this function can be called during ifnet initialization */
		if (!ifp->if_afdata[AF_INET6])
			continue;
		if ((ifp->if_flags & IFF_LOOPBACK) == 0 &&
		    IN6_LINKMTU(ifp) > maxmtu)
			maxmtu = IN6_LINKMTU(ifp);
	}
	if (maxmtu)	     /* update only when maxmtu is positive */
		in6_maxmtu = maxmtu;
@


1.143
log
@Introduce a special hack for carp during IPv6 source address selection:

If there is a tie then a carp interface is not allowed to win even if
it has an address with a longer bitwise match. This allows reliable IPv6
communication between carp master and backup across a shared IPv6 subnet.

Consider the carp address 2001:DB8:10::14, which is configured on firewall A
(in carp master state) and firewall B (in carp backup state), each of which
has another address in the same prefix on a non-carp interface (A has
2001:DB8:10::1 and B has 2001:DB8:10::11). In this setup, A would use
2001:DB8:10::14 as source address when sending neighbour solicitations to B.
Since 2001:DB8:10::14 is a local address from B's point of view, B never
replied to the neighbour solicitations sent by A.
With this change A uses 2001:DB8:10::1 as source address instead.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.142 2014/10/14 09:52:26 mpi Exp $	*/
d873 1
a873 1
		rt = rtalloc1(sin6tosa(&mltaddr), 0, ifp->if_rdomain);
d944 1
a944 1
		rt = rtalloc1(sin6tosa(&mltaddr), 0, ifp->if_rdomain);
d1607 1
a1607 1
	rt = rtalloc1(sin6tosa(&dst), RT_NOCLONING, tableid);
@


1.142
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.141 2014/10/07 08:47:28 mpi Exp $	*/
d2030 18
a2047 1
			if (matchcmp > 0) /* (8) */
d2049 1
@


1.141
log
@Do not protect the SIOCSIFADDR call by splnet().  Drivers already
raise it inside their ioctl handler (except for carp(4), what else?).

In general, global structures manipulated in the softnet codepath only
require a splsoftnet() protection when they are modified in process
(ioctl) context.

Also put some IPL_SOFNET asserts in functions accessing global structures.

Previous version diff ok mikeb@@, with inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.140 2014/08/26 21:44:29 florian Exp $	*/
d881 1
a881 1
				RTFREE(rt);
d900 1
a900 1
			RTFREE(rt);
d950 1
a950 1
				RTFREE(rt);
d968 1
a968 1
			RTFREE(rt);
d1623 1
a1623 1
		RTFREE(rt);
d1627 1
a1627 1
	RTFREE(rt);
@


1.140
log
@Do not hand-roll all routers link local address.
pointed out & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.139 2014/08/25 14:00:34 florian Exp $	*/
d175 1
a175 1
	int privileged;
a465 1
		int s;
d563 1
d566 1
d1082 1
a1082 1
	int	s = splnet();
a1110 2

	splx(s);
a1356 1
	int	s = splnet();
d1359 2
a1376 1
		splx(s);
a1378 1
	splx(s);
@


1.139
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.138 2014/07/12 18:44:23 tedu Exp $	*/
d115 2
@


1.138
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.137 2014/05/15 09:05:13 mpi Exp $	*/
d2090 3
@


1.137
log
@Do not use nd6_rtrequest() for addresses configured on loopback
interfaces.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.136 2014/05/05 11:44:33 mpi Exp $	*/
d1462 1
a1462 1
			free(in6m, M_IPMADDR);
d1516 1
a1516 1
		free(in6m, M_IPMADDR);
d1533 1
a1533 1
		free(imm, M_IPMADDR);
d1545 1
a1545 1
	free(imm,  M_IPMADDR);
d2172 3
a2174 3
	free(ext->in6_ifstat, M_IFADDR);
	free(ext->icmp6_ifstat, M_IFADDR);
	free(ext, M_IFADDR);
@


1.136
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.135 2014/04/10 13:47:21 mpi Exp $	*/
d1402 1
a1402 1
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
@


1.135
log
@Retire rtinit() an use rt_ifa_add(9) and rt_ifa_del(9) to manage
connected routes to prefixes/hosts.

Since the introduction of rt_ifa_addloop(9) and rt_ifa_delloop(9),
rtinit() was just a wrapper, so use the underlying functions
directly and document them.

Inputs from and ok mikeb@@, manpage tweaks from jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.134 2014/04/03 08:22:10 mpi Exp $	*/
d1372 2
a1373 1
	if ((ifacount <= 1 || ifp->if_type == IFT_CARP) && ifp->if_ioctl &&
d1402 3
a1404 1
		ia6->ia_ifa.ifa_rtrequest = nd6_rtrequest;
@


1.134
log
@Introduce rt_ifa_{add,del}loop() to replace in6_{add,rem}loop().

Move these functions to a more generic place and make them reuse
existing code, they'll be soon used in IPv4 too.

Tested by André Lucas, Vigdis and sthen@@, thanks!

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.133 2014/03/27 10:39:23 mpi Exp $	*/
d753 1
d756 1
a756 1
		    rtinit(&ia6->ia_ifa, RTM_DELETE, RTF_UP | RTF_HOST)) {
d1024 1
a1024 2
		if ((e = rtinit(&ia6->ia_ifa, RTM_DELETE,
		    RTF_UP | RTF_HOST)) != 0) {
d1391 3
a1393 1
		if ((error = rtinit(&ia6->ia_ifa, RTM_ADD, RTF_UP | RTF_HOST)))
@


1.133
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.132 2014/02/12 10:03:07 mpi Exp $	*/
a124 1
void in6_ifloop_request(int, struct ifaddr *);
a129 144
/*
 * Subroutine for in6_ifaddloop() and in6_ifremloop().
 * This routine does actual work.
 */
void
in6_ifloop_request(int cmd, struct ifaddr *ifa)
{
	struct rt_addrinfo info;
	struct rtentry *nrt = NULL;
	int e;

	/*
	 * We specify the address itself as the gateway, and set the
	 * RTF_LLINFO flag, so that the corresponding host route would have
	 * the flag, and thus applications that assume traditional behavior
	 * would be happy.  Note that we assume the caller of the function
	 * (probably implicitly) set nd6_rtrequest() to ifa->ifa_rtrequest,
	 * which changes the outgoing interface to the loopback interface.
	 * XXX only table 0 for now
	 */
	bzero(&info, sizeof(info));
	info.rti_flags = RTF_UP | RTF_HOST | RTF_LLINFO;
	info.rti_info[RTAX_DST] = ifa->ifa_addr;
	if (cmd != RTM_DELETE)
		info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
	e = rtrequest1(cmd, &info, RTP_CONNECTED, &nrt,
	    ifa->ifa_ifp->if_rdomain);
	if (e != 0) {
		char addr[INET6_ADDRSTRLEN];
		log(LOG_ERR, "in6_ifloop_request: "
		    "%s operation failed for %s (errno=%d)\n",
		    cmd == RTM_ADD ? "ADD" : "DELETE",
		    inet_ntop(AF_INET6,
			&ifatoia6(ifa)->ia_addr.sin6_addr, addr, sizeof(addr)),
		    e);
	}

	/*
	 * Make sure rt_ifa be equal to IFA, the second argument of the
	 * function.
	 * We need this because when we refer to rt_ifa->ia6_flags in
	 * ip6_input, we assume that the rt_ifa points to the address instead
	 * of the loopback address.
	 */
	if (cmd == RTM_ADD && nrt && ifa != nrt->rt_ifa) {
		ifafree(nrt->rt_ifa);
		ifa->ifa_refcnt++;
		nrt->rt_ifa = ifa;
	}

	/*
	 * Report the addition/removal of the address to the routing socket.
	 * XXX: since we called rtinit for a p2p interface with a destination,
	 *      we end up reporting twice in such a case.  Should we rather
	 *      omit the second report?
	 */
	if (nrt) {
		rt_newaddrmsg(cmd, ifa, e, nrt);
		if (cmd == RTM_DELETE) {
			if (nrt->rt_refcnt <= 0) {
				/* XXX: we should free the entry ourselves. */
				nrt->rt_refcnt++;
				rtfree(nrt);
			}
		} else {
			/* the cmd must be RTM_ADD here */
			nrt->rt_refcnt--;
		}
	}
}

/*
 * Add ownaddr as loopback rtentry.  We previously add the route only if
 * necessary (ex. on a p2p link).  However, since we now manage addresses
 * separately from prefixes, we should always add the route.  We can't
 * rely on the cloning mechanism from the corresponding interface route
 * any more.
 */
void
in6_ifaddloop(struct ifaddr *ifa)
{
	struct rtentry *rt;

	/* If there is no loopback entry, allocate one. */
	rt = rtalloc1(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
	if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0 ||
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
		in6_ifloop_request(RTM_ADD, ifa);
	if (rt)
		rt->rt_refcnt--;
}

/*
 * Remove loopback rtentry of ownaddr generated by in6_ifaddloop(),
 * if it exists.
 */
void
in6_ifremloop(struct ifaddr *ifa)
{
	struct in6_ifaddr *ia6;
	struct rtentry *rt;
	int ia_count = 0;

	/*
	 * Some of BSD variants do not remove cloned routes
	 * from an interface direct route, when removing the direct route
	 * (see comments in net/net_osdep.h).  Even for variants that do remove
	 * cloned routes, they could fail to remove the cloned routes when
	 * we handle multple addresses that share a common prefix.
	 * So, we should remove the route corresponding to the deleted address.
	 */

	/*
	 * Delete the entry only if exact one ifa exists.  More than one ifa
	 * can exist if we assign a same single address to multiple
	 * (probably p2p) interfaces.
	 * XXX: we should avoid such a configuration in IPv6...
	 */
	TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list) {
		if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &ia6->ia_addr.sin6_addr)) {
			ia_count++;
			if (ia_count > 1)
				break;
		}
	}

	if (ia_count == 1) {
		/*
		 * Before deleting, check if a corresponding loopbacked host
		 * route surely exists.  With this check, we can avoid to
		 * delete an interface direct route whose destination is same
		 * as the address being removed.  This can happen when removing
		 * a subnet-router anycast address on an interface attached
		 * to a shared medium.
		 */
		rt = rtalloc1(ifa->ifa_addr, 0, ifa->ifa_ifp->if_rdomain);
		if (rt != NULL && (rt->rt_flags & RTF_HOST) != 0 &&
		    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
			rt->rt_refcnt--;
			in6_ifloop_request(RTM_DELETE, ifa);
		}
	}
}

d1009 1
a1009 1
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
d1011 1
d1037 26
a1062 2
	/* Remove ownaddr's loopback rtentry, if it exists. */
	in6_ifremloop(&(ia6->ia_ifa));
d1400 1
a1400 1
		in6_ifaddloop(&(ia6->ia_ifa));
@


1.132
log
@Kill a never defined old compatibility goo from 12 years ago.

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.131 2014/01/22 13:19:12 mpi Exp $	*/
a897 1
		int e;
d900 1
a900 1
		    (e = rtinit(&(ia6->ia_ifa), (int)RTM_DELETE, RTF_HOST)) != 0) {
d1167 2
a1168 2
		if ((e = rtinit(&(ia6->ia_ifa), (int)RTM_DELETE, RTF_HOST))
		    != 0) {
d1511 1
a1511 2
		if ((error = rtinit(&(ia6->ia_ifa), (int)RTM_ADD,
				    RTF_UP | RTF_HOST)) != 0)
@


1.131
log
@There's no reason to pass a netmask argument when doing a RTF_HOST
request, so kill it along with the associated global variable.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.130 2014/01/21 10:18:26 mpi Exp $	*/
a810 4
#ifdef FORCE_P2PPLEN
		int i;
#endif

a819 14
#ifdef FORCE_P2PPLEN
			/*
			 * To be compatible with old configurations,
			 * such as ifconfig gif0 inet6 2001::1 2001::2
			 * prefixlen 126, we override the specified
			 * prefixmask as if the prefix length was 128.
			 */
			ifra->ifra_prefixmask.sin6_len =
			    sizeof(struct sockaddr_in6);
			for (i = 0; i < 4; i++)
				ifra->ifra_prefixmask.sin6_addr.s6_addr32[i] =
				    0xffffffff;
			plen = 128;
#else
a820 1
#endif
@


1.130
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.129 2014/01/15 09:25:38 mpi Exp $	*/
a138 1
	struct sockaddr_in6 all1_sa;
a141 5
	bzero(&all1_sa, sizeof(all1_sa));
	all1_sa.sin6_family = AF_INET6;
	all1_sa.sin6_len = sizeof(struct sockaddr_in6);
	all1_sa.sin6_addr = in6mask128;

a155 1
	info.rti_info[RTAX_NETMASK] = sin6tosa(&all1_sa);
@


1.129
log
@Remove assigned but never read value.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.128 2014/01/13 23:03:52 bluhm Exp $	*/
d1595 1
a1595 1
		in6m->in6m_ifp = ifp;
d1640 1
a1640 1
		ifp = in6m->in6m_ifp;
d1646 12
a1657 9
		bzero(&ifr.ifr_addr, sizeof(struct sockaddr_in6));
		ifr.ifr_addr.sin6_len = sizeof(struct sockaddr_in6);
		ifr.ifr_addr.sin6_family = AF_INET6;
		ifr.ifr_addr.sin6_addr = in6m->in6m_addr;
		(*ifp->if_ioctl)(in6m->in6m_ifp, SIOCDELMULTI, (caddr_t)&ifr);

		s = splsoftnet();
		TAILQ_REMOVE(&ifp->if_maddrlist, &in6m->in6m_ifma, ifma_list);
		splx(s);
@


1.128
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.127 2014/01/07 16:34:05 stsp Exp $	*/
a138 1
	struct sockaddr_in6 lo_sa;
a142 1
	bzero(&lo_sa, sizeof(lo_sa));
d144 2
a145 3
	lo_sa.sin6_family = all1_sa.sin6_family = AF_INET6;
	lo_sa.sin6_len = all1_sa.sin6_len = sizeof(struct sockaddr_in6);
	lo_sa.sin6_addr = in6addr_loopback;
@


1.127
log
@Some follow-up fixes for IFID collision handling in IPv6CP.

Really change the link-local address in the unlikely event of an IFID
collision, instead of going into an infinite conf-nak loop with the peer.

To make the netinet6 code use the IPv6CP IFID in a new link-local address,
in6_ifattach_linklocal() must accept a provided IFID.  Replace the unused
'altifp' parameter with a new 'ifid' parameter for this purpose.

Always use the latest suggested address in IPv6CP replies, even if
the task to update the interface's address hasn't run yet.
Also, clear the ifindex (KAME hack) in addresses sent during IPv6CP.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.126 2013/11/28 10:16:44 mpi Exp $	*/
d240 1
a240 1
	struct in6_ifaddr *ia;
d259 2
a260 2
	TAILQ_FOREACH(ia, &in6_ifaddr, ia_list) {
		if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &ia->ia_addr.sin6_addr)) {
d325 1
a325 1
	struct	in6_ifaddr *ia = NULL;
d447 1
a447 1
		ia = in6ifa_ifpwithaddr(ifp, &sa6->sin6_addr);
d449 1
a449 1
		ia = NULL;
d469 1
a469 1
		if (ia == NULL)
d493 1
a493 1
		if (ia == NULL)
d502 1
a502 1
		if (ia == NULL)
d521 1
a521 1
		ifr->ifr_addr = ia->ia_addr;
d531 1
a531 1
		ifr->ifr_dstaddr = ia->ia_dstaddr;
d535 1
a535 1
		ifr->ifr_addr = ia->ia_prefixmask;
d539 1
a539 1
		ifr->ifr_ifru.ifru_flags6 = ia->ia6_flags;
d561 2
a562 2
		ifr->ifr_ifru.ifru_lifetime = ia->ia6_lifetime;
		if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
d573 4
a576 4
			if (ia->ia6_lifetime.ia6t_vltime <
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_expire = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_vltime;
d580 1
a580 1
		if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
d591 4
a594 4
			if (ia->ia6_lifetime.ia6t_pltime <
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_preferred = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_pltime;
d601 1
a601 1
		ia->ia6_lifetime = ifr->ifr_ifru.ifru_lifetime;
d603 3
a605 3
		if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			ia->ia6_lifetime.ia6t_expire =
				time_second + ia->ia6_lifetime.ia6t_vltime;
d607 4
a610 4
			ia->ia6_lifetime.ia6t_expire = 0;
		if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			ia->ia6_lifetime.ia6t_preferred =
				time_second + ia->ia6_lifetime.ia6t_pltime;
d612 1
a612 1
			ia->ia6_lifetime.ia6t_preferred = 0;
d633 1
a633 1
		error = in6_update_ifa(ifp, ifra, ia);
d637 1
a637 1
		if ((ia = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr))
d701 2
a702 2
		if (ia->ia6_ndpr == NULL) {
			ia->ia6_ndpr = pr;
d717 1
a717 1
		in6_purgeaddr(&ia->ia_ifa);
d737 1
a737 1
    struct in6_ifaddr *ia)
d777 1
a777 1
	if (ia == NULL && ifra->ifra_prefixmask.sin6_len == 0)
d787 1
a787 1
		 * In this case, ia must not be NULL.  We just use its prefix
d790 1
a790 1
		plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
d866 1
a866 1
		if (ia == NULL)
d874 1
a874 1
	if (ia == NULL) {
d876 2
a877 2
		ia = malloc(sizeof(*ia), M_IFADDR, M_WAITOK | M_ZERO);
		LIST_INIT(&ia->ia6_memberships);
d879 4
a882 4
		ia->ia_ifa.ifa_addr = sin6tosa(&ia->ia_addr);
		ia->ia_addr.sin6_family = AF_INET6;
		ia->ia_addr.sin6_len = sizeof(ia->ia_addr);
		ia->ia6_createtime = ia->ia6_updatetime = time_second;
d888 1
a888 1
			ia->ia_ifa.ifa_dstaddr = sin6tosa(&ia->ia_dstaddr);
d890 1
a890 1
			ia->ia_ifa.ifa_dstaddr = NULL;
d892 1
a892 1
		ia->ia_ifa.ifa_netmask = sin6tosa(&ia->ia_prefixmask);
d894 4
a897 4
		ia->ia_ifp = ifp;
		TAILQ_INSERT_TAIL(&in6_ifaddr, ia, ia_list);
		ia->ia_addr = ifra->ifra_addr;
		ifa_add(ifp, &ia->ia_ifa);
d908 2
a909 2
		if (ia->ia_prefixmask.sin6_len &&
		    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL) != plen) {
d912 1
a912 1
			    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d917 1
a917 1
		ia->ia_prefixmask = ifra->ifra_prefixmask;
d926 1
a926 1
	    !IN6_ARE_ADDR_EQUAL(&dst6.sin6_addr, &ia->ia_dstaddr.sin6_addr)) {
d929 2
a930 2
		if ((ia->ia_flags & IFA_ROUTE) != 0 &&
		    (e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST)) != 0) {
d933 1
a933 1
			    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d937 2
a938 2
			ia->ia_flags &= ~IFA_ROUTE;
		ia->ia_dstaddr = dst6;
d946 4
a949 4
	ia->ia6_lifetime = ifra->ifra_lifetime;
	if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_expire =
		    time_second + ia->ia6_lifetime.ia6t_vltime;
d951 4
a954 4
		ia->ia6_lifetime.ia6t_expire = 0;
	if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_preferred =
		    time_second + ia->ia6_lifetime.ia6t_pltime;
d956 1
a956 1
		ia->ia6_lifetime.ia6t_preferred = 0;
d959 1
a959 1
	if ((error = in6_ifinit(ifp, ia, hostIsNew)) != 0)
d965 1
a965 1
	ia->ia6_flags = ifra->ifra_flags;
d971 2
a972 2
		ia->ia6_lifetime.ia6t_pltime = 0;
		ia->ia6_lifetime.ia6t_preferred = time_second;
d979 1
a979 1
	ia->ia6_flags &= ~IN6_IFF_DUPLICATED;	/* safety */
d982 1
a982 1
		ia->ia6_flags |= IN6_IFF_TENTATIVE;
d1021 1
a1021 1
		LIST_INSERT_HEAD(&ia->ia6_memberships, imm, i6mm_chain);
d1061 1
a1061 1
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia->ia_addr);
d1063 1
a1063 1
			info.rti_info[RTAX_IFA] = sin6tosa(&ia->ia_addr);
d1083 1
a1083 1
		LIST_INSERT_HEAD(&ia->ia6_memberships, imm, i6mm_chain);
d1098 1
a1098 1
				LIST_INSERT_HEAD(&ia->ia6_memberships,
d1130 1
a1130 1
			info.rti_info[RTAX_GATEWAY] = sin6tosa(&ia->ia_addr);
d1132 1
a1132 1
			info.rti_info[RTAX_IFA] = sin6tosa(&ia->ia_addr);
d1150 1
a1150 1
		LIST_INSERT_HEAD(&ia->ia6_memberships, imm, i6mm_chain);
d1161 1
a1161 1
		nd6_dad_start(&ia->ia_ifa, NULL);
d1172 1
a1172 1
		in6_unlink_ifa(ia, ifp);
d1176 1
a1176 1
	in6_purgeaddr(&ia->ia_ifa);
d1184 1
a1184 1
	struct in6_ifaddr *ia = ifatoia6(ifa);
d1194 1
a1194 1
	if ((ia->ia_flags & IFA_ROUTE) != 0 && ia->ia_dstaddr.sin6_len != 0) {
d1197 1
a1197 1
		if ((e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST))
d1203 1
a1203 1
			    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1208 1
a1208 1
			ia->ia_flags &= ~IFA_ROUTE;
d1212 1
a1212 1
	in6_ifremloop(&(ia->ia_ifa));
d1217 2
a1218 2
	while (!LIST_EMPTY(&ia->ia6_memberships)) {
		imm = LIST_FIRST(&ia->ia6_memberships);
d1223 1
a1223 1
	in6_unlink_ifa(ia, ifp);
d1227 1
a1227 1
in6_unlink_ifa(struct in6_ifaddr *ia, struct ifnet *ifp)
d1231 1
a1231 1
	ifa_del(ifp, &ia->ia_ifa);
d1233 1
a1233 1
	TAILQ_REMOVE(&in6_ifaddr, ia, ia_list);
d1236 1
a1236 1
	if (ia->ia6_ndpr == NULL) {
d1239 3
a1241 3
		if (!IN6_IS_ADDR_LINKLOCAL(IA6_IN6(ia)) &&
		    !IN6_IS_ADDR_LOOPBACK(IA6_IN6(ia)) &&
		    !IN6_ARE_ADDR_EQUAL(IA6_MASKIN6(ia), &in6mask128))
d1244 1
a1244 1
			    inet_ntop(AF_INET6, IA6_IN6(ia), addr,
d1247 4
a1250 4
		ia->ia6_flags &= ~IN6_IFF_AUTOCONF;
		if (--ia->ia6_ndpr->ndpr_refcnt == 0)
			prelist_remove(ia->ia6_ndpr);
		ia->ia6_ndpr = NULL;
d1257 1
a1257 1
	ifafree(&ia->ia_ifa);
d1399 1
a1399 1
		struct in6_ifaddr *ia;
d1451 1
a1451 1
		ia = ifatoia6(ifa);
d1455 1
a1455 1
			bcopy(&ia->ia_addr, &iflr->addr, ia->ia_addr.sin6_len);
d1457 2
a1458 2
				bcopy(&ia->ia_dstaddr, &iflr->dstaddr,
				    ia->ia_dstaddr.sin6_len);
d1463 1
a1463 1
			    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
d1465 1
a1465 1
			iflr->flags = ia->ia6_flags;	/*XXX*/
d1476 2
a1477 2
			bcopy(&ia->ia_addr, &ifra.ifra_addr,
			    ia->ia_addr.sin6_len);
d1479 2
a1480 2
				bcopy(&ia->ia_dstaddr, &ifra.ifra_dstaddr,
				    ia->ia_dstaddr.sin6_len);
d1485 2
a1486 2
			bcopy(&ia->ia_prefixmask, &ifra.ifra_dstaddr,
			    ia->ia_prefixmask.sin6_len);
d1488 1
a1488 1
			ifra.ifra_flags = ia->ia6_flags;
d1503 1
a1503 1
in6_ifinit(struct ifnet *ifp, struct in6_ifaddr *ia, int newhost)
d1523 1
a1523 1
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
d1529 1
a1529 1
	ia->ia_ifa.ifa_metric = ifp->if_metric;
d1539 3
a1541 3
	plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL); /* XXX */
	if (plen == 128 && ia->ia_dstaddr.sin6_family == AF_INET6) {
		if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD,
d1544 1
a1544 1
		ia->ia_flags |= IFA_ROUTE;
d1550 2
a1551 2
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		in6_ifaddloop(&(ia->ia_ifa));
d1938 1
a1938 1
	struct in6_ifaddr *ifa_best = NULL;
d1992 2
a1993 2
			       (ifa_best == NULL) ? "none" :
			       inet_ntop(AF_INET6, &ifa_best->ia_addr.sin6_addr,
d1998 1
a1998 1
			       ifa_best ? IN6_ARE_SCOPE_CMP(src_scope, best_scope) : -1,
d2022 1
a2022 1
			if (ifa_best == NULL)
d2026 1
a2026 1
			 * ifa_best is never NULL beyond this line except
d2031 1
a2031 1
			 * If ifa_best has a smaller scope than dst and
d2033 1
a2033 1
			 * (or equal to) dst, always replace ifa_best.
d2035 1
a2035 1
			 * than dst, ignore it unless ifa_best also has a
d2063 1
a2063 1
				if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED)
d2073 1
a2073 1
			if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED) &&
d2081 1
a2081 1
			 *    and ifa_best is also non-deprecated.
d2083 1
a2083 1
			 *    and ifa_best is also deprecated.
d2093 2
a2094 2
			 *   ifa_best (bscopecmp)
			 * - if the address match dst longer than ifa_best
d2159 1
a2159 1
				if ((ifa_best->ia6_flags & IN6_IFF_PRIVACY) &&
d2166 1
a2166 1
				if (!(ifa_best->ia6_flags & IN6_IFF_PRIVACY) &&
d2182 1
a2182 1
			ifa_best = ifatoia6(ifa);
d2185 1
a2185 1
			best_scope = in6_addrscope(&ifa_best->ia_addr.sin6_addr);
d2190 1
a2190 1
	if (ifa_best == NULL)
d2193 1
a2193 1
		if (oifp == ifa_best->ia_ifp)
d2203 1
a2203 1
		if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED) != 0)
d2207 1
a2207 1
	return (ifa_best);
d2217 1
a2217 1
	struct in6_ifaddr *ia;
d2229 2
a2230 2
		ia = ifatoia6(ifa);
		if (ia->ia6_flags & IN6_IFF_TENTATIVE)
@


1.126
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.125 2013/11/22 07:59:09 mpi Exp $	*/
d2223 1
a2223 1
	in6_ifattach(ifp, NULL);
@


1.125
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.124 2013/11/13 08:27:24 stsp Exp $	*/
a131 12
 * This structure is used to keep track of in6_multi chains which belong to
 * deleted interface addresses.
 */
static LIST_HEAD(, multi6_kludge) in6_mk; /* XXX BSS initialization */

struct multi6_kludge {
	LIST_ENTRY(multi6_kludge) mk_entry;
	struct ifnet *mk_ifp;
	struct in6_multihead mk_head;
};

/*
a1234 4
	if (!LIST_EMPTY(&ia->ia6_multiaddrs)) {
		in6_savemkludge(ia);
	}

a1553 3
	if (ifp->if_flags & IFF_MULTICAST)
		in6_restoremkludge(ia, ifp);

a1557 118
 * Multicast address kludge:
 * If there were any multicast addresses attached to this interface address,
 * either move them to another address on this interface, or save them until
 * such time as this interface is reconfigured for IPv6.
 */
void
in6_savemkludge(struct in6_ifaddr *oia)
{
	struct in6_ifaddr *ia;
	struct in6_multi *in6m, *next;

	IFP_TO_IA6(oia->ia_ifp, ia);
	if (ia) {	/* there is another address */
		for (in6m = LIST_FIRST(&oia->ia6_multiaddrs);
		    in6m != NULL; in6m = next) {
			next = LIST_NEXT(in6m, in6m_entry);
			ifafree(&in6m->in6m_ia->ia_ifa);
			ia->ia_ifa.ifa_refcnt++;
			in6m->in6m_ia = ia;
			LIST_INSERT_HEAD(&ia->ia6_multiaddrs, in6m, in6m_entry);
		}
	} else {	/* last address on this if deleted, save */
		struct multi6_kludge *mk;

		LIST_FOREACH(mk, &in6_mk, mk_entry) {
			if (mk->mk_ifp == oia->ia_ifp)
				break;
		}
		if (mk == NULL) /* this should not happen! */
			panic("in6_savemkludge: no kludge space");

		for (in6m = LIST_FIRST(&oia->ia6_multiaddrs);
		    in6m != NULL; in6m = next) {
			next = LIST_NEXT(in6m, in6m_entry);
			ifafree(&in6m->in6m_ia->ia_ifa); /* release reference */
			in6m->in6m_ia = NULL;
			LIST_INSERT_HEAD(&mk->mk_head, in6m, in6m_entry);
		}
	}
}

/*
 * Continuation of multicast address hack:
 * If there was a multicast group list previously saved for this interface,
 * then we re-attach it to the first address configured on the i/f.
 */
void
in6_restoremkludge(struct in6_ifaddr *ia, struct ifnet *ifp)
{
	struct multi6_kludge *mk;

	LIST_FOREACH(mk, &in6_mk, mk_entry) {
		if (mk->mk_ifp == ifp) {
			struct in6_multi *in6m, *next;

			for (in6m = LIST_FIRST(&mk->mk_head); in6m != NULL;
			    in6m = next) {
				next = LIST_NEXT(in6m, in6m_entry);
				in6m->in6m_ia = ia;
				ia->ia_ifa.ifa_refcnt++;
				LIST_INSERT_HEAD(&ia->ia6_multiaddrs,
						 in6m, in6m_entry);
			}
			LIST_INIT(&mk->mk_head);
			break;
		}
	}
}

/*
 * Allocate space for the kludge at interface initialization time.
 * Formerly, we dynamically allocated the space in in6_savemkludge() with
 * malloc(M_WAITOK).  However, it was wrong since the function could be called
 * under an interrupt context (software timer on address lifetime expiration).
 * Also, we cannot just give up allocating the strucutre, since the group
 * membership structure is very complex and we need to keep it anyway.
 * Of course, this function MUST NOT be called under an interrupt context.
 * Specifically, it is expected to be called only from in6_ifattach(), though
 * it is a global function.
 */
void
in6_createmkludge(struct ifnet *ifp)
{
	struct multi6_kludge *mk;

	LIST_FOREACH(mk, &in6_mk, mk_entry) {
		/* If we've already had one, do not allocate. */
		if (mk->mk_ifp == ifp)
			return;
	}

	mk = malloc(sizeof(*mk), M_IPMADDR, M_WAITOK | M_ZERO);

	LIST_INIT(&mk->mk_head);
	mk->mk_ifp = ifp;
	LIST_INSERT_HEAD(&in6_mk, mk, mk_entry);
}

void
in6_purgemkludge(struct ifnet *ifp)
{
	struct multi6_kludge *mk;
	struct in6_multi *in6m;

	LIST_FOREACH(mk, &in6_mk, mk_entry) {
		if (mk->mk_ifp != ifp)
			continue;

		/* leave from all multicast groups joined */
		while ((in6m = LIST_FIRST(&mk->mk_head)) != NULL)
			in6_delmulti(in6m);
		LIST_REMOVE(mk, mk_entry);
		free(mk, M_IPMADDR);
		break;
	}
}

/*
a1563 1
	struct	in6_ifaddr *ia;
d1566 1
a1566 1
	int	s = splsoftnet();
d1577 1
a1577 1
		in6m->in6m_refcount++;
d1579 5
d1588 1
a1588 2
		in6m = (struct in6_multi *)
			malloc(sizeof(*in6m), M_IPMADDR, M_NOWAIT);
a1589 1
			splx(s);
d1593 5
a1597 1
		in6m->in6m_addr = *maddr6;
d1599 1
a1599 11
		in6m->in6m_refcount = 1;
		IFP_TO_IA6(ifp, ia);
		if (ia == NULL) {
			free(in6m, M_IPMADDR);
			splx(s);
			*errorp = EADDRNOTAVAIL; /* appropriate? */
			return (NULL);
		}
		in6m->in6m_ia = ia;
		ia->ia_ifa.ifa_refcnt++; /* gain a reference */
		LIST_INSERT_HEAD(&ia->ia6_multiaddrs, in6m, in6m_entry);
d1605 2
a1606 9
		bzero(&ifr.ifr_addr, sizeof(struct sockaddr_in6));
		ifr.ifr_addr.sin6_len = sizeof(struct sockaddr_in6);
		ifr.ifr_addr.sin6_family = AF_INET6;
		ifr.ifr_addr.sin6_addr = *maddr6;
		if (ifp->if_ioctl == NULL)
			*errorp = ENXIO; /* XXX: appropriate? */
		else
			*errorp = (*ifp->if_ioctl)(ifp, SIOCADDMULTI,
			    (caddr_t)&ifr);
a1607 1
			LIST_REMOVE(in6m, in6m_entry);
a1608 2
			ifafree(&ia->ia_ifa);
			splx(s);
d1611 6
d1623 1
a1623 1
	splx(s);
d1634 2
a1635 1
	int	s = splsoftnet();
d1637 1
a1637 1
	if (--in6m->in6m_refcount == 0) {
d1643 1
a1643 8

		/*
		 * Unlink from list.
		 */
		LIST_REMOVE(in6m, in6m_entry);
		if (in6m->in6m_ia) {
			ifafree(&in6m->in6m_ia->ia_ifa); /* release reference */
		}
d1653 6
a1658 2
		(*in6m->in6m_ifp->if_ioctl)(in6m->in6m_ifp,
					    SIOCDELMULTI, (caddr_t)&ifr);
a1660 1
	splx(s);
@


1.124
log
@In in6_update_ifa(), don't set the TENTATIVE flag on an IPv6 address that
is marked as NODAD.

Since we're not gonna do duplicate address detection for this address,
the TENTATIVE flag won't get cleared, rendering the address unusable.
The existing logic only checked whether DAD was enabled for the interface,
but DAD can be configured on a per-address basis.

ok sthen@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.123 2013/11/11 09:15:35 mpi Exp $	*/
d122 1
a122 2
int in6_lifaddr_ioctl(struct socket *, u_long, caddr_t, struct ifnet *,
	    struct proc *);
d334 1
a334 2
in6_control(struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp,
    struct proc *p)
d390 1
a390 1
		return in6_lifaddr_ioctl(so, cmd, data, ifp, p);
d1302 2
a1303 2
in6_lifaddr_ioctl(struct socket *so, u_long cmd, caddr_t data, 
    struct ifnet *ifp, struct proc *p)
d1410 1
a1410 1
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp, p);
d1506 1
a1506 1
			    ifp, p);
@


1.123
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.122 2013/10/24 11:20:18 deraadt Exp $	*/
d994 2
a995 1
	if (hostIsNew && in6if_do_dad(ifp))
@


1.122
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.121 2013/10/20 11:03:02 phessler Exp $	*/
d182 1
d186 3
a188 1
		    ip6_sprintf(&ifatoia6(ifa)->ia_addr.sin6_addr), e);
d758 1
d877 2
a878 1
		    ip6_sprintf(&ifra->ifra_addr.sin6_addr)));
d926 2
a927 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d947 2
a948 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d1029 2
a1030 1
			    ip6_sprintf(&llsol.sin6_addr),
d1091 2
a1092 1
			    ip6_sprintf(&mltaddr.sin6_addr),
d1106 2
a1107 1
				    ip6_sprintf(&mltaddr.sin6_addr),
d1158 2
a1159 1
			    ip6_sprintf(&mltaddr.sin6_addr),
d1212 1
d1216 3
a1218 2
			    ip6_sprintf(&ia->ia_addr.sin6_addr), ifp->if_xname,
			    e);
d1254 2
d1260 3
a1262 1
			    "%s has no prefix\n", ip6_sprintf(IA6_IN6(ia)));
a1923 53
 * Convert IP6 address to printable (loggable) representation.
 */
static char digits[] = "0123456789abcdef";
static int ip6round = 0;
char *
ip6_sprintf(struct in6_addr *addr)
{
	static char ip6buf[8][48];
	int i;
	char *cp;
	u_short *a = (u_short *)addr;
	u_char *d;
	int dcolon = 0;

	ip6round = (ip6round + 1) & 7;
	cp = ip6buf[ip6round];

	for (i = 0; i < 8; i++) {
		if (dcolon == 1) {
			if (*a == 0) {
				if (i == 7)
					*cp++ = ':';
				a++;
				continue;
			} else
				dcolon = 2;
		}
		if (*a == 0) {
			if (dcolon == 0 && *(a + 1) == 0) {
				if (i == 0)
					*cp++ = ':';
				*cp++ = ':';
				dcolon = 1;
			} else {
				*cp++ = '0';
				*cp++ = ':';
			}
			a++;
			continue;
		}
		d = (u_char *)a;
		*cp++ = digits[*d >> 4];
		*cp++ = digits[*d++ & 0xf];
		*cp++ = digits[*d >> 4];
		*cp++ = digits[*d & 0xf];
		*cp++ = ':';
		a++;
	}
	*--cp = 0;
	return (ip6buf[ip6round]);
}

/*
d2131 5
d2140 7
a2146 4
			       ip6_sprintf(dst),
			       ifa_best ? ip6_sprintf(&ifa_best->ia_addr.sin6_addr) : "none",
			       ip6_sprintf(IFA_IN6(ifa)), src_scope,
			       dscopecmp,
d2150 1
@


1.121
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.120 2013/10/17 16:27:45 bluhm Exp $	*/
d1972 1
a1972 1
			return IPV6_ADDR_SCOPE_LINKLOCAL;
d1975 1
a1975 1
			return IPV6_ADDR_SCOPE_SITELOCAL;
d1978 1
a1978 1
			return IPV6_ADDR_SCOPE_GLOBAL; /* just in case */
d1992 2
a1993 2
		case IPV6_ADDR_SCOPE_INTFACELOCAL:
			return IPV6_ADDR_SCOPE_INTFACELOCAL;
d1995 2
a1996 2
		case IPV6_ADDR_SCOPE_LINKLOCAL:
			return IPV6_ADDR_SCOPE_LINKLOCAL;
d1998 2
a1999 2
		case IPV6_ADDR_SCOPE_SITELOCAL:
			return IPV6_ADDR_SCOPE_SITELOCAL;
d2002 1
a2002 1
			return IPV6_ADDR_SCOPE_GLOBAL;
d2009 1
a2009 1
			return IPV6_ADDR_SCOPE_INTFACELOCAL;
d2011 1
a2011 1
			return IPV6_ADDR_SCOPE_LINKLOCAL;
d2014 1
a2014 1
	return IPV6_ADDR_SCOPE_GLOBAL;
d2028 2
a2029 2
	case IPV6_ADDR_SCOPE_INTFACELOCAL:
	case IPV6_ADDR_SCOPE_LINKLOCAL:
d2033 1
a2033 1
	case IPV6_ADDR_SCOPE_SITELOCAL:
@


1.120
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.119 2013/10/01 08:25:35 mpi Exp $	*/
d286 1
a286 1
		rt = rtalloc1(ifa->ifa_addr, 0, 0);
@


1.119
log
@Do not pass the SIOCSIF{DSTADDR,BRDADDR,NETMASK} ioctls down to the
driver when using an AF_INET6 socket without checking for permission.

From Loganaden Velvindron, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.118 2013/08/26 07:15:58 bluhm Exp $	*/
a84 1
#include <netinet/in_var.h>
d90 1
@


1.118
log
@No one uses the obsolete IPv6 ioctls SIOCGDRLST_IN6, SIOCGPRLST_IN6,
OSIOCGIFINFO_IN6 anymore.  Remove them together with the structs
in6_drlist, in6_oprlist, in6_prlist, in6_ondireq and the kernel
implementation.
OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.117 2013/08/13 05:52:25 guenther Exp $	*/
d429 3
d433 1
a433 1
		 * Do not pass this ioctl to driver handler since it is not
@


1.117
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.116 2013/06/20 12:03:40 mpi Exp $	*/
a363 1
	case OSIOCGIFINFO_IN6:
a364 2
	case SIOCGDRLST_IN6:
	case SIOCGPRLST_IN6:
@


1.116
log
@Revert previous and unbreak asr, the new include should be protected.

Reported by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.115 2013/06/20 09:38:24 mpi Exp $	*/
d582 2
a583 2
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
d600 2
a601 2
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
@


1.115
log
@Allocate the various hook head descriptors as part of the ifnet
structure rather than doing various M_WAITOK allocations during
the *attach() functions, we always rely on them anyway.

ok mikeb@@, uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.114 2013/06/16 21:27:15 bluhm Exp $	*/
d673 1
a673 1
			dohooks(&ifp->if_addrhooks, 0);
d723 1
a723 1
		dohooks(&ifp->if_addrhooks, 0);
d729 1
a729 1
		dohooks(&ifp->if_addrhooks, 0);
@


1.114
log
@If the prefixlen is 128, SIOCAIFADDR_IN6 does not add a prefix.  In
this case, in6_unlink_ifa() must not complain about a missing prefix.
To avoid a false log message, check the prefixmask when the interface
address gets deleted.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.113 2013/06/13 21:06:58 bluhm Exp $	*/
d673 1
a673 1
			dohooks(ifp->if_addrhooks, 0);
d723 1
a723 1
		dohooks(ifp->if_addrhooks, 0);
d729 1
a729 1
		dohooks(ifp->if_addrhooks, 0);
@


1.113
log
@As it is correct that the loopback address has no prefix, do not
complain about a missing prefix for ::1 in in6_unlink_ifa().  Also
log the actual IPv6 address in the error message instead of the
kernel pointer of the interface address.
OK sthen@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.112 2013/05/31 15:04:23 bluhm Exp $	*/
d1242 2
a1243 1
		    !IN6_IS_ADDR_LOOPBACK(IA6_IN6(ia)))
@


1.112
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.111 2013/05/30 15:23:38 claudio Exp $	*/
d1241 2
a1242 1
		if (!IN6_IS_ADDR_LINKLOCAL(IA6_IN6(ia)))
d1244 1
a1244 1
			    "%p has no prefix\n", ia);
@


1.111
log
@Do not allow SIOCSIFADDR on AF_INET6 sockets. The ioctl is handled down
to the driver where uninitialized data will be accessed.
Problem reported by hugh@@, OK and input deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.110 2013/03/28 16:45:16 tedu Exp $	*/
d178 1
a178 1
	info.rti_info[RTAX_NETMASK] = (struct sockaddr *)&all1_sa;
d888 1
a888 1
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
d897 1
a897 2
			ia->ia_ifa.ifa_dstaddr =
			    (struct sockaddr *)&ia->ia_dstaddr;
d901 1
a901 2
		ia->ia_ifa.ifa_netmask =
		    (struct sockaddr *)&ia->ia_prefixmask;
d1049 1
a1049 1
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0, ifp->if_rdomain);
d1055 1
a1055 1
			    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
d1065 4
a1068 7
			info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&mltmask;
			info.rti_info[RTAX_IFA] =
			    (struct sockaddr *)&ia->ia_addr;
d1118 1
a1118 1
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0, ifp->if_rdomain);
d1122 1
a1122 1
			    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
d1132 4
a1135 7
			info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&mltmask;
			info.rti_info[RTAX_IFA] =
			    (struct sockaddr *)&ia->ia_addr;
d1880 1
a1880 1
	rt = rtalloc1((struct sockaddr *)&dst, RT_NOCLONING, tableid);
@


1.110
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.109 2013/03/25 14:40:57 mpi Exp $	*/
d431 6
@


1.109
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.108 2013/03/22 01:41:12 tedu Exp $	*/
a74 1
#include <sys/proc.h>
@


1.108
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.107 2013/03/14 11:18:37 mpi Exp $	*/
d270 1
a270 1
	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
a745 1
	struct in6_ifaddr *oia;
d901 1
a901 6
		if ((oia = in6_ifaddr) != NULL) {
			for ( ; oia->ia_next; oia = oia->ia_next)
				continue;
			oia->ia_next = ia;
		} else
			in6_ifaddr = ia;
a1231 1
	struct in6_ifaddr *oia;
d1236 1
a1236 13
	oia = ia;
	if (oia == (ia = in6_ifaddr))
		in6_ifaddr = ia->ia_next;
	else {
		while (ia->ia_next && (ia->ia_next != oia))
			ia = ia->ia_next;
		if (ia->ia_next)
			ia->ia_next = oia->ia_next;
		else {
			/* search failed */
			printf("Couldn't unlink in6_ifaddr from in6_ifaddr\n");
		}
	}
d1238 2
a1239 2
	if (!LIST_EMPTY(&oia->ia6_multiaddrs)) {
		in6_savemkludge(oia);
d1243 2
a1244 2
	if (oia->ia6_ndpr == NULL) {
		if (!IN6_IS_ADDR_LINKLOCAL(IA6_IN6(oia)))
d1246 1
a1246 1
			    "%p has no prefix\n", oia);
d1248 4
a1251 4
		oia->ia6_flags &= ~IN6_IFF_AUTOCONF;
		if (--oia->ia6_ndpr->ndpr_refcnt == 0)
			prelist_remove(oia->ia6_ndpr);
		oia->ia6_ndpr = NULL;
d1258 1
a1258 1
	ifafree(&oia->ia_ifa);
@


1.107
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.106 2013/03/11 14:08:03 mpi Exp $	*/
d1595 1
a1595 1
		    in6m != LIST_END(&oia->ia6_multiaddrs); in6m = next) {
d1613 1
a1613 1
		    in6m != LIST_END(&oia->ia6_multiaddrs); in6m = next) {
d1636 1
a1636 2
			for (in6m = LIST_FIRST(&mk->mk_head);
			    in6m != LIST_END(&mk->mk_head);
@


1.106
log
@Remove unused code manipulating a default interface and its index,
This is a leftover from the on-link assumption behavior removal,
which has been deprecated by RFC4861 anyway.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.105 2013/03/07 09:03:16 mpi Exp $	*/
a2438 8
	case IFT_FAITH:
		/*
		 * These interfaces do not have the IFF_LOOPBACK flag,
		 * but loop packets back.  We do not have to do DAD on such
		 * interfaces.  We should even omit it, because loop-backed
		 * NS would confuse the DAD procedure.
		 */
		return (0);
@


1.105
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.104 2013/03/04 14:42:25 bluhm Exp $	*/
a360 1
	case SIOCSDEFIFACE_IN6:
a369 1
	case SIOCGDEFIFACE_IN6:
@


1.104
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.103 2013/03/04 14:23:35 bluhm Exp $	*/
d197 1
a197 1
		IFAFREE(nrt->rt_ifa);
d1279 1
a1279 1
	IFAFREE(&oia->ia_ifa);
d1599 1
a1599 1
			IFAFREE(&in6m->in6m_ia->ia_ifa);
d1617 1
a1617 1
			IFAFREE(&in6m->in6m_ia->ia_ifa); /* release reference */
d1765 1
a1765 1
			IFAFREE(&ia->ia_ifa);
d1800 1
a1800 1
			IFAFREE(&in6m->in6m_ia->ia_ifa); /* release reference */
@


1.103
log
@When deleting an IPv6 interface address, also remove the prefix and
the cloning route.
bug report and test Florian Riehm; original fix sperreault@@; OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.102 2013/03/03 00:35:13 bluhm Exp $	*/
d1867 1
a1867 1
	return ((struct in6_ifaddr *)ifa);
d1888 1
a1888 1
	return ((struct in6_ifaddr *)ifa);
d2200 1
a2200 1
			       ((struct in6_ifaddr *)ifa)->ia6_flags);
d2381 1
a2381 1
			ifa_best = (struct in6_ifaddr *)ifa;
@


1.102
log
@Make sure that IPv6 source address selection only chooses a CARP
address if the interface is in master state.  Disable duplicate
address detection on CARP interfaces as the peer may have the same
addresses.
Test and OK sthen@@ florian@@ benno@@ camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.101 2012/11/30 13:48:12 stsp Exp $	*/
d1263 4
a1266 7
	/*
	 * When an autoconfigured address is being removed, release the
	 * reference to the base prefix.
	 */
	if ((oia->ia6_flags & IN6_IFF_AUTOCONF) != 0) {
		if (oia->ia6_ndpr == NULL) {
			log(LOG_NOTICE, "in6_unlink_ifa: autoconf'ed address "
d1268 5
a1272 6
		} else {
			oia->ia6_flags &= ~IN6_IFF_AUTOCONF;
			if (--oia->ia6_ndpr->ndpr_refcnt == 0)
				prelist_remove(oia->ia6_ndpr);
			oia->ia6_ndpr = NULL;
		}
@


1.101
log
@Fix typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.100 2012/10/05 17:17:04 camield Exp $	*/
d100 3
d2151 3
d2168 9
d2453 8
@


1.101.2.1
log
@MFC claudio's commit, in6.c:1.110->1.111

Do not allow SIOCSIFADDR on AF_INET6 sockets. The ioctl is handled down
to the driver where uninitialized data will be accessed.
Problem reported by hugh@@, OK and input deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.101 2012/11/30 13:48:12 stsp Exp $	*/
a430 6
	case SIOCSIFADDR:
		/*
		 * Do not pass this ioctl to driver handler since it is not
		 * properly setup. Instead just error out.
		 */
		return (EOPNOTSUPP);
@


1.100
log
@Point an interface directly to its bridgeport configuration, instead
of to the bridge itself.  This is ok, since an interface can only be part
of one bridge, and the parent bridge is easy to find from the bridgeport.

This way we can get rid of a lot of list walks, improving performance
and shortening the code.

ok henning stsp sthen reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.99 2012/09/19 09:47:25 bluhm Exp $	*/
d1893 1
a1893 1
 * Check wether an interface has a prefix by looking up the cloning route.
@


1.99
log
@Use TAILQ_FOREACH macro for loops.  No binary diff.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.98 2012/07/14 17:23:16 sperreault Exp $	*/
d88 3
d1913 1
a1913 2
	    (rt->rt_ifp->if_bridge == NULL || ifp->if_bridge == NULL ||
	    rt->rt_ifp->if_bridge != ifp->if_bridge) &&
@


1.98
log
@Make IPv6 privacy addresses appear alongside regular SLAAC addresses.
Also fix a memory management problem that was made obvious by this diff.

ok bluhm@@, previous version ok @@stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.97 2012/07/08 18:01:25 bluhm Exp $	*/
d2157 1
a2157 2
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
d2464 1
a2464 2
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
@


1.98.2.1
log
@MFC claudio's commit, in6.c:1.110->1.111

Do not allow SIOCSIFADDR on AF_INET6 sockets. The ioctl is handled down
to the driver where uninitialized data will be accessed.
Problem reported by hugh@@, OK and input deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.98 2012/07/14 17:23:16 sperreault Exp $	*/
a427 6
	case SIOCSIFADDR:
		/*
		 * Do not pass this ioctl to driver handler since it is not
		 * properly setup. Instead just error out.
		 */
		return (EOPNOTSUPP);
@


1.97
log
@Instead of casting interface address pointers, use the macro
ifatoia6().  No binary diff.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.96 2012/01/17 02:07:32 stsp Exp $	*/
a718 33
	{
		int i = 0, purgeprefix = 0;
		struct nd_prefix pr0, *pr = NULL;

		/*
		 * If the address being deleted is the only one that owns
		 * the corresponding prefix, expire the prefix as well.
		 * XXX: theoretically, we don't have to worry about such
		 * relationship, since we separate the address management
		 * and the prefix management.  We do this, however, to provide
		 * as much backward compatibility as possible in terms of
		 * the ioctl operation.
		 */
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128)
			goto purgeaddr;
		pr0.ndpr_prefix = ia->ia_addr;
		pr0.ndpr_mask = ia->ia_prefixmask.sin6_addr;
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ia->ia_prefixmask.sin6_addr.s6_addr32[i];
		}
		if ((pr = nd6_prefix_lookup(&pr0)) != NULL &&
		    pr == ia->ia6_ndpr) {
			pr->ndpr_refcnt--;
			if (pr->ndpr_refcnt == 0)
				purgeprefix = 1;
		}

	  purgeaddr:
a719 2
		if (pr && purgeprefix)
			prelist_remove(pr);
a721 1
	}
d1259 1
a1259 3
	 * reference to the base prefix.  Also, since the release might
	 * affect the status of other (detached) addresses, call
	 * pfxlist_onlink_check().
a1265 1
			oia->ia6_ndpr->ndpr_refcnt--;
d1267 2
a1270 2

		pfxlist_onlink_check();
@


1.96
log
@During IPv6 source address selection, give address scope higher priority
than the autoconfprivacy bit, as per by RFC3484. Prevents privacy addresses
from being erroneously used as source address if the destination address is
in a different scope. Privacy addresses are still preferred over other source
addresses from the same scope.
Problem found by sthen, fix suggested by sperreault; ok sperreault
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.95 2012/01/03 23:41:51 bluhm Exp $	*/
d180 1
a180 2
		    ip6_sprintf(&((struct in6_ifaddr *)ifa)->ia_addr.sin6_addr),
		    e);
a325 3
#define ifa2ia6(ifa)	((struct in6_ifaddr *)(ifa))
#define ia62ifa(ia6)	(&((ia6)->ia_ifa))

d1227 1
a1227 1
	struct in6_ifaddr *ia = (struct in6_ifaddr *) ifa;
d1510 1
a1510 1
		ia = ifa2ia6(ifa);
d1898 1
a1898 2
			if ((((struct in6_ifaddr *)ifa)->ia6_flags &
			     ignoreflags) != 0)
d2234 1
a2234 2
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_NOTREADY)
d2238 1
a2238 2
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_ANYCAST)
d2241 1
a2241 2
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_DETACHED)
d2277 1
a2277 2
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_DEPRECATED) {
d2300 1
a2300 1
			    (((struct in6_ifaddr *)ifa)->ia6_flags &
d2386 1
a2386 1
			            !(((struct in6_ifaddr *)ifa)->ia6_flags &
d2393 1
a2393 1
			            (((struct in6_ifaddr *)ifa)->ia6_flags &
d2455 1
a2455 1
		ia = (struct in6_ifaddr *)ifa;
@


1.95
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.94 2011/11/24 17:39:55 sperreault Exp $	*/
a2312 16
			if (oifp == ifp) {
				/* Do not replace temporary autoconf addresses
				 * with non-temporary addresses. */
				if ((ifa_best->ia6_flags & IN6_IFF_PRIVACY) &&
			            !(((struct in6_ifaddr *)ifa)->ia6_flags &
				    IN6_IFF_PRIVACY))
					continue;

				/* Replace non-temporary autoconf addresses
				 * with temporary addresses. */
				if (!(ifa_best->ia6_flags & IN6_IFF_PRIVACY) &&
			            (((struct in6_ifaddr *)ifa)->ia6_flags &
				    IN6_IFF_PRIVACY))
					goto replace;
			}

d2387 3
d2391 15
@


1.94
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.93 2011/08/08 13:04:35 bluhm Exp $	*/
d1208 1
a1208 1
		nd6_dad_start((struct ifaddr *)ia, NULL);
d1409 1
a1409 1
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0);
@


1.93
log
@If two carp interfaces on the same physical interface had addresses
with the same prefix, neighbor discovery did not work.  When comparing
two carp interfaces in in6_ifpprefix(), assume they share the prefix
if they have the same parent.
sure deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.92 2011/08/07 15:18:40 bluhm Exp $	*/
d174 2
a175 1
	e = rtrequest1(cmd, &info, RTP_CONNECTED, &nrt, 0);
d231 1
a231 1
	rt = rtalloc1(ifa->ifa_addr, 0, 0);
d1088 1
a1088 1
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0, 0);
d1114 1
a1114 1
			    0);
d1160 1
a1160 1
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0, 0);
d1183 1
a1183 1
			    NULL, 0);
d1941 1
a1941 1
	u_int tableid = 0;  /* XXX */
d2183 1
a2183 1
in6_ifawithscope(struct ifnet *oifp, struct in6_addr *dst)
d2203 3
@


1.92
log
@When checking wether a prefix belongs to an interface, also allow
the route to be at the corresponding carp or physical interface or
at an interface belonging to a common bridge.  This fixes IPv6
neighbor discovery with carp.
bug report and tested by Florian Fuessl
put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.91 2011/07/26 21:19:51 bluhm Exp $	*/
d1959 2
@


1.91
log
@Accept neighbor discovery packets from source IPv6 addresses for
which we have a cloning or cloned route.  The old check was based
on configured interface addresses, now we use a route lookup.  This
allows us to use prefixes for the local network that ospf6d has
added.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.90 2011/04/03 13:55:36 stsp Exp $	*/
d64 3
d1951 10
a1960 1
	    rt->rt_ifp != ifp) {
@


1.90
log
@As of r1.54 of nd6_rtr.c we don't add addresses from interrupt context
anymore so the allocation in in6_update_ifa() can now wait.
ok deraadt henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.89 2010/10/07 22:07:06 mpf Exp $	*/
d1930 1
a1930 2
 * find the internet address on a given interface corresponding to a neighbor's
 * address.
d1932 2
a1933 2
struct in6_ifaddr *
in6ifa_ifplocaladdr(const struct ifnet *ifp, const struct in6_addr *addr)
d1935 3
a1937 2
	struct ifaddr *ifa;
	struct in6_ifaddr *ia;
d1939 12
a1950 10
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ia = (struct in6_ifaddr *)ifa;
		if (IN6_ARE_MASKED_ADDR_EQUAL(addr,
				&ia->ia_addr.sin6_addr,
				&ia->ia_prefixmask.sin6_addr))
			return ia;
d1953 2
a1954 1
	return NULL;
@


1.89
log
@Also call addrhooks for IPv6 addresses with a 128 bit prefixlen.
I overlooked that one case in rev. 1.69.  Fix from Pedro Martelletto.
OK mcbride, claudio, henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.88 2010/07/08 19:42:46 jsg Exp $	*/
d913 1
a913 8
		/*
		 * When in6_update_ifa() is called in a process of a received
		 * RA, it is called under an interrupt context.  So, we should
		 * call malloc with M_NOWAIT.
		 */
		ia = malloc(sizeof(*ia), M_IFADDR, M_NOWAIT | M_ZERO);
		if (ia == NULL)
			return (ENOBUFS);
@


1.88
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.87 2010/05/08 10:55:06 stsp Exp $	*/
d664 1
@


1.87
log
@During IPv6 source address selection, prefer RFC 4941 temporary addresses
over other addresses configured on the same interface.
Facilitates peaceful coexistence of temporary addresses for outgoing
connections and static addresses for incoming connections.
Fix typo in comment while here.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.86 2010/02/08 12:04:35 jsing Exp $	*/
a106 2
const struct in6_addr in6addr_linklocal_allrouters =
	IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;
a1326 16
void
in6_purgeif(struct ifnet *ifp)
{
	struct ifaddr *ifa, *nifa;

	for (ifa = TAILQ_FIRST(&ifp->if_addrlist); ifa != NULL; ifa = nifa)
	{
		nifa = TAILQ_NEXT(ifa, ifa_list);
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		in6_purgeaddr(ifa);
	}

	in6_ifdetach(ifp);
}

a2094 17
int
in6_is_addr_deprecated(struct sockaddr_in6 *sa6)
{
	struct in6_ifaddr *ia;

	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IN6_ARE_ADDR_EQUAL(&ia->ia_addr.sin6_addr,
		    &sa6->sin6_addr) &&
		    (ia->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			return (1); /* true */

		/* XXX: do we still have to go thru the rest of the list? */
	}

	return (0);		/* false */
}

a2425 81
}

/*
 * return the best address out of the same scope. if no address was
 * found, return the first valid address from designated IF.
 */
struct in6_ifaddr *
in6_ifawithifp(struct ifnet *ifp, struct in6_addr *dst)
{
	int dst_scope =	in6_addrscope(dst), blen = -1, tlen;
	struct ifaddr *ifa;
	struct in6_ifaddr *besta = 0;
	struct in6_ifaddr *dep[2];	/*last-resort: deprecated*/

	dep[0] = dep[1] = NULL;

	/*
	 * We first look for addresses in the same scope.
	 * If there is one, return it.
	 * If two or more, return one which matches the dst longest.
	 * If none, return one of global addresses assigned other ifs.
	 */
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_ANYCAST)
			continue; /* XXX: is there any case to allow anycast? */
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_NOTREADY)
			continue; /* don't use this interface */
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DETACHED)
			continue;
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
			if (ip6_use_deprecated)
				dep[0] = (struct in6_ifaddr *)ifa;
			continue;
		}

		if (dst_scope == in6_addrscope(IFA_IN6(ifa))) {
			/*
			 * call in6_matchlen() as few as possible
			 */
			if (besta) {
				if (blen == -1)
					blen = in6_matchlen(&besta->ia_addr.sin6_addr, dst);
				tlen = in6_matchlen(IFA_IN6(ifa), dst);
				if (tlen > blen) {
					blen = tlen;
					besta = (struct in6_ifaddr *)ifa;
				}
			} else
				besta = (struct in6_ifaddr *)ifa;
		}
	}
	if (besta)
		return (besta);

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_ANYCAST)
			continue; /* XXX: is there any case to allow anycast? */
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_NOTREADY)
			continue; /* don't use this interface */
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DETACHED)
			continue;
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
			if (ip6_use_deprecated)
				dep[1] = (struct in6_ifaddr *)ifa;
			continue;
		}

		return (struct in6_ifaddr *)ifa;
	}

	/* use the last-resort values, that are, deprecated addresses */
	if (dep[0])
		return dep[0];
	if (dep[1])
		return dep[1];

	return NULL;
@


1.86
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.84 2010/01/13 02:02:43 henning Exp $	*/
d2333 16
d2394 1
a2394 1
			 *     eaual     eqaul    equal     No |       No (b)
@


1.85
log
@instead of fiddling with the per-interface address lists directly in
many places create a proper API (ifa_add / ifa_del) and use it.
ok theo ryan dlg
@
text
@d116 5
a120 4
static int in6_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *, struct proc *);
static int in6_ifinit(struct ifnet *, struct in6_ifaddr *, int);
static void in6_unlink_ifa(struct in6_ifaddr *, struct ifnet *);
d122 3
a124 2
const struct sockaddr_in6 sa6_any = {sizeof(sa6_any), AF_INET6,
				     0, 0, IN6ADDR_ANY_INIT, 0};
d142 1
a142 1
static void
d329 2
a330 2
in6_control(struct socket *so, u_long cmd, caddr_t data, 
	struct ifnet *ifp, struct proc *p)
d775 2
a776 2
in6_update_ifa(struct ifnet *ifp, struct in6_aliasreq *ifra, 
	struct in6_ifaddr *ia)
d1275 1
a1275 1
static void
d1368 1
a1368 1
static int
d1370 1
a1370 1
	struct ifnet *ifp, struct proc *p)
d1585 1
a1585 1
static int
d1899 1
a1899 2
in6_leavegroup(imm)
	struct in6_multi_mship *imm;
d2591 1
a2591 1
in6_setmaxmtu()
@


1.84
log
@adding an empty ifaddr struct to the per-interface ifaddr list and
somewhen later eventually filling the address in is NOT nice.
set address first, then insert. ok dlg theo ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.83 2009/12/21 23:46:25 sthen Exp $	*/
d947 1
a947 2
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, &ia->ia_ifa,
				  ifa_list);
d1279 1
a1279 1
	TAILQ_REMOVE(&ifp->if_addrlist, &ia->ia_ifa, ifa_list);
@


1.83
log
@typo in comment; Holger Mikolon
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.82 2009/06/04 19:07:21 henning Exp $	*/
d118 1
a118 2
static int in6_ifinit(struct ifnet *, struct in6_ifaddr *,
	struct sockaddr_in6 *, int);
d946 1
d1008 1
a1008 1
	if ((error = in6_ifinit(ifp, ia, &ifra->ifra_addr, hostIsNew)) != 0)
d1585 1
a1585 2
in6_ifinit(struct ifnet *ifp, struct in6_ifaddr *ia, 
	struct sockaddr_in6 *sin6, int newhost)
a1602 2

	ia->ia_addr = *sin6;
@


1.82
log
@allow IPvShit to be turned off completely per-interface.
ifconfig em0 -inet6
deletes all v6 addresses including link-local and prevents new ones from
being added.
ifconfig em0 inet6 <addr>
re-enables v6, brings the link local back and adds optional <addr>
ok theo reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.81 2009/03/15 19:40:41 miod Exp $	*/
d276 1
a276 1
		 * a subnet-router anycast address on an interface attahced
@


1.81
log
@Introduce splsoftassert(), similar to splassert() but for soft interrupt
levels. This will allow for platforms where soft interrupt levels do not
map to real hardware interrupt levels to have soft ipl values overlapping
hard ipl values without breaking spl asserts.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.80 2009/01/30 10:47:46 mcbride Exp $	*/
d798 5
@


1.80
log
@"XXX: should this be performed under splnet()?"... Yes, yes it should.
Interface configuration causes neighbour discoverery, which runs packets
through parts of the stack that require at least splsoftnet(), like pf and
pfsync.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.79 2008/10/01 21:17:06 claudio Exp $	*/
d784 1
a784 1
	splassert(IPL_SOFTNET);
@


1.79
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
From NetBSD, tested by todd@@ and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.78 2008/07/13 20:41:39 claudio Exp $	*/
d622 1
d635 4
a638 1
		if ((error = in6_update_ifa(ifp, ifra, ia)) != 0)
a771 1
 * XXX: should this be performed under splnet()?
d783 2
@


1.78
log
@Do not specify the gateway on RTM_DELETE -- similar fix was done in the arp
code. This fixes in6_ifloop_request warnings seen on carp interfaces.
OK henning@@, found and tested by david@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.77 2008/06/11 19:00:50 mcbride Exp $	*/
d1944 25
@


1.78.2.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.78 2008/07/13 20:41:39 claudio Exp $	*/
a1943 25
}

/*
 * find the internet address on a given interface corresponding to a neighbor's
 * address.
 */
struct in6_ifaddr *
in6ifa_ifplocaladdr(const struct ifnet *ifp, const struct in6_addr *addr)
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ia = (struct in6_ifaddr *)ifa;
		if (IN6_ARE_MASKED_ADDR_EQUAL(addr,
				&ia->ia_addr.sin6_addr,
				&ia->ia_prefixmask.sin6_addr))
			return ia;
	}

	return NULL;
@


1.77
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.76 2008/06/11 06:30:36 mcbride Exp $	*/
d169 2
a170 1
	info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
@


1.76
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.75 2008/05/11 08:13:02 claudio Exp $	*/
d288 1
a288 3
in6_mask2len(mask, lim0)
	struct in6_addr *mask;
	u_char *lim0;
d327 2
a328 6
in6_control(so, cmd, data, ifp, p)
	struct	socket *so;
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
	struct proc *p;
d770 2
a771 4
in6_update_ifa(ifp, ifra, ia)
	struct ifnet *ifp;
	struct in6_aliasreq *ifra;
	struct in6_ifaddr *ia;
d1220 1
a1220 2
in6_purgeaddr(ifa)
	struct ifaddr *ifa;
d1264 1
a1264 3
in6_unlink_ifa(ia, ifp)
	struct in6_ifaddr *ia;
	struct ifnet *ifp;
d1318 1
a1318 2
in6_purgeif(ifp)
	struct ifnet *ifp;
d1357 2
a1358 6
in6_lifaddr_ioctl(so, cmd, data, ifp, p)
	struct socket *so;
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
	struct proc *p;
d1574 2
a1575 5
in6_ifinit(ifp, ia, sin6, newhost)
	struct ifnet *ifp;
	struct in6_ifaddr *ia;
	struct sockaddr_in6 *sin6;
	int newhost;
d1641 1
a1641 2
in6_savemkludge(oia)
	struct in6_ifaddr *oia;
d1682 1
a1682 3
in6_restoremkludge(ia, ifp)
	struct in6_ifaddr *ia;
	struct ifnet *ifp;
d1717 1
a1717 2
in6_createmkludge(ifp)
	struct ifnet *ifp;
d1735 1
a1735 2
in6_purgemkludge(ifp)
	struct ifnet *ifp;
d1757 2
a1758 5
struct	in6_multi *
in6_addmulti(maddr6, ifp, errorp)
	struct in6_addr *maddr6;
	struct ifnet *ifp;
	int *errorp;
d1835 1
a1835 2
in6_delmulti(in6m)
	struct in6_multi *in6m;
d1871 1
a1871 4
in6_joingroup(ifp, addr, errorp)
	struct ifnet *ifp;
	struct in6_addr *addr;
	int *errorp;
d1904 1
a1904 3
in6ifa_ifpforlinklocal(ifp, ignoreflags)
	struct ifnet *ifp;
	int ignoreflags;
d1929 1
a1929 3
in6ifa_ifpwithaddr(ifp, addr)
	struct ifnet *ifp;
	struct in6_addr *addr;
d1951 1
a1951 2
ip6_sprintf(addr)
	struct in6_addr *addr;
d2002 1
a2002 2
in6_addrscope (addr)
struct in6_addr *addr;
d2056 5
d2062 1
a2062 3
in6_addr2scopeid(ifp, addr)
	struct ifnet *ifp;	/* must not be NULL */
	struct in6_addr *addr;	/* must not be NULL */
d2081 1
a2081 2
in6_is_addr_deprecated(sa6)
	struct sockaddr_in6 *sa6;
d2102 1
a2102 2
in6_matchlen(src, dst)
struct in6_addr *src, *dst;
d2121 1
a2121 3
in6_are_prefix_equal(p1, p2, len)
	struct in6_addr *p1, *p2;
	int len;
d2147 1
a2147 3
in6_prefixlen2mask(maskp, len)
	struct in6_addr *maskp;
	int len;
d2173 1
a2173 3
in6_ifawithscope(oifp, dst)
	struct ifnet *oifp;
	struct in6_addr *dst;
d2419 1
a2419 3
in6_ifawithifp(ifp, dst)
	struct ifnet *ifp;
	struct in6_addr *dst;
d2499 1
a2499 2
in6_if_up(ifp)
	struct ifnet *ifp;
d2521 1
a2521 2
in6if_do_dad(ifp)
	struct ifnet *ifp;
d2577 1
a2577 2
in6_domifattach(ifp)
	struct ifnet *ifp;
d2596 1
a2596 3
in6_domifdetach(ifp, aux)
	struct ifnet *ifp;
	void *aux;
@


1.75
log
@rtrequest to rtrequest1 conversion in inet6. With that no rtrequest should
be left over. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.74 2008/05/07 05:14:21 claudio Exp $	*/
d2637 2
@


1.74
log
@Implement routing priorities. Every route inserted has a priority assigned
and the one route with the lowest number wins. This will be used by the
routing daemons to resolve the synchronisations issue in case of conflicts.
The nasty bits of this are in the multipath code. If no priority is specified
the kernel will choose an appropriate priority.

Looked at by a few people at n2k8 code is much older
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.73 2007/12/09 21:24:58 hshoexer Exp $	*/
d144 1
d166 6
a171 2
	e = rtrequest(cmd, ifa->ifa_addr, ifa->ifa_addr,
	    (struct sockaddr *)&all1_sa, RTF_UP|RTF_HOST|RTF_LLINFO, &nrt, 0);
@


1.73
log
@take advantage of M_ZERO

ok claudio gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.72 2006/11/17 01:11:23 itojun Exp $	*/
d1108 2
a1109 1
			error = rtrequest1(RTM_ADD, &info, NULL, 0);
d1177 2
a1178 1
			error = rtrequest1(RTM_ADD, &info, NULL, 0);
@


1.73.2.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.73 2007/12/09 21:24:58 hshoexer Exp $	*/
a1970 25
}

/*
 * find the internet address on a given interface corresponding to a neighbor's
 * address.
 */
struct in6_ifaddr *
in6ifa_ifplocaladdr(const struct ifnet *ifp, const struct in6_addr *addr)
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ia = (struct in6_ifaddr *)ifa;
		if (IN6_ARE_MASKED_ADDR_EQUAL(addr,
				&ia->ia_addr.sin6_addr,
				&ia->ia_prefixmask.sin6_addr))
			return ia;
	}

	return NULL;
@


1.72
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.71 2006/11/15 03:07:44 itojun Exp $	*/
d910 1
a910 2
		ia = (struct in6_ifaddr *) malloc(sizeof(*ia), M_IFADDR,
		    M_NOWAIT);
a912 1
		bzero((caddr_t)ia, sizeof(*ia));
d1743 1
a1743 1
	mk = malloc(sizeof(*mk), M_IPMADDR, M_WAITOK);
a1744 1
	bzero(mk, sizeof(*mk));
d2621 1
a2621 2
	ext = (struct in6_ifextra *)malloc(sizeof(*ext), M_IFADDR, M_WAITOK);
	bzero(ext, sizeof(*ext));
d2623 5
a2627 8
	ext->in6_ifstat = (struct in6_ifstat *)malloc(sizeof(struct in6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->in6_ifstat, sizeof(*ext->in6_ifstat));

	ext->icmp6_ifstat =
	    (struct icmp6_ifstat *)malloc(sizeof(struct icmp6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->icmp6_ifstat, sizeof(*ext->icmp6_ifstat));
@


1.72.4.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.72 2006/11/17 01:11:23 itojun Exp $	*/
a1973 25
}

/*
 * find the internet address on a given interface corresponding to a neighbor's
 * address.
 */
struct in6_ifaddr *
in6ifa_ifplocaladdr(const struct ifnet *ifp, const struct in6_addr *addr)
{
	struct ifaddr *ifa;
	struct in6_ifaddr *ia;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ia = (struct in6_ifaddr *)ifa;
		if (IN6_ARE_MASKED_ADDR_EQUAL(addr,
				&ia->ia_addr.sin6_addr,
				&ia->ia_prefixmask.sin6_addr))
			return ia;
	}

	return NULL;
@


1.71
log
@unifdef -USCOPEDROUTING
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.70 2006/11/14 04:44:22 itojun Exp $	*/
d103 2
a104 2
const struct in6_addr in6addr_nodelocal_allnodes =
	IN6ADDR_NODELOCAL_ALLNODES_INIT;
a1039 1
		u_int32_t zoneid = 0;
d1077 1
a1115 1
		mltaddr.sin6_scope_id = zoneid;	/* XXX */
d1144 10
a1153 6
		if (ifp->if_flags & IFF_LOOPBACK) {
			/*
			 * join node-local all-nodes address, on loopback.
			 * (ff01::1%ifN, and ff01::%ifN/32)
			 */
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;
d1155 9
a1163 10
			/* XXX: again, do we really need the route? */
			rt = rtalloc1((struct sockaddr *)&mltaddr, 0, 0);
			if (rt) {
				/* 32bit came from "mltmask" */
				if (memcmp(&mltaddr.sin6_addr,
				    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
				    32 / 8)) {
					RTFREE(rt);
					rt = NULL;
				}
d1165 3
a1167 2
			if (!rt) {
				struct rt_addrinfo info;
d1169 11
a1179 21
				bzero(&info, sizeof(info));
				info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
				info.rti_info[RTAX_GATEWAY] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_info[RTAX_NETMASK] =
				    (struct sockaddr *)&mltmask;
				info.rti_info[RTAX_IFA] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_flags = RTF_UP | RTF_CLONING;
				error = rtrequest1(RTM_ADD, &info, NULL, 0);
				if (error)
					goto cleanup;
			} else {
				RTFREE(rt);
			}
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (!imm) {
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
d1181 10
a1190 2
			}
			LIST_INSERT_HEAD(&ia->ia6_memberships, imm, i6mm_chain);
d1192 1
d2064 2
a2065 2
		case IPV6_ADDR_SCOPE_NODELOCAL:
			return IPV6_ADDR_SCOPE_NODELOCAL;
d2081 1
a2081 1
			return IPV6_ADDR_SCOPE_NODELOCAL;
d2097 1
a2097 3
	case IPV6_ADDR_SCOPE_NODELOCAL:
		return (-1);	/* XXX: is this an appropriate value? */

@


1.70
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.69 2006/10/31 12:49:45 mpf Exp $	*/
a1039 1
#ifndef SCOPEDROUTING
a1040 1
#endif
a1088 1
			 * XXX: only works in !SCOPEDROUTING case.
a1115 1
#ifndef SCOPEDROUTING
a1116 1
#endif
a2118 3
#ifdef SCOPEDROUTING
		    ia->ia_addr.sin6_scope_id == sa6->sin6_scope_id &&
#endif
@


1.69
log
@Only run address hooks on SIOCAIFADDR_IN6 and SIOCDIFADDR_IN6.
Before a normal user running ifconfig(8) could trigger up to three
address hook calls per interface.
OK mcbride@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.68 2006/08/28 17:29:53 mcbride Exp $	*/
d99 1
a99 1
 * Definitions of some costant IP6 addresses.
@


1.68
log
@Make carp see all IPv6 address additions and remove dead code in carp_ioctl()

ok mpf@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.67 2006/06/16 16:49:40 henning Exp $	*/
d710 1
d751 1
a760 1
	dohooks(ifp->if_addrhooks, 0);
@


1.68.2.1
log
@MFC:
Fix by mpf@@

Only run address hooks on SIOCAIFADDR_IN6 and SIOCDIFADDR_IN6.
Before a normal user running ifconfig(8) could trigger up to three
address hook calls per interface.

ok mcbride@@ deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.68 2006/08/28 17:29:53 mcbride Exp $	*/
a709 1
		dohooks(ifp->if_addrhooks, 0);
a749 1
		dohooks(ifp->if_addrhooks, 0);
d759 1
@


1.67
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.66 2006/05/27 23:40:27 claudio Exp $	*/
d1599 1
a1599 1
	 * if this is its first address,
d1612 1
a1612 1
	if (ifacount <= 1 && ifp->if_ioctl &&
@


1.66
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.65 2006/04/16 19:09:56 canacar Exp $	*/
d163 1
d166 1
a166 1
	    (struct sockaddr *)&all1_sa, RTF_UP|RTF_HOST|RTF_LLINFO, &nrt);
d222 1
a222 1
	rt = rtalloc1(ifa->ifa_addr, 0);
d273 1
a273 1
		rt = rtalloc1(ifa->ifa_addr, 0);
d1086 1
a1086 1
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
d1112 1
a1112 1
			error = rtrequest1(RTM_ADD, &info, NULL);
d1157 1
a1157 1
			rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
d1179 1
a1179 1
				error = rtrequest1(RTM_ADD, &info, NULL);
@


1.65
log
@Fix typo in queue.h conversion.
ok miod@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.64 2006/03/05 21:48:57 miod Exp $	*/
d90 1
d92 1
d340 1
d346 1
@


1.64
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.63 2006/03/04 22:40:16 brad Exp $	*/
d1704 2
a1705 2
			for (in6m = LIST_FIRST(&ia->ia6_multiaddrs);
			    in6m != LIST_END(&ia->ia6_multiaddrs);
@


1.63
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.62 2006/02/14 10:34:31 otto Exp $	*/
d1255 2
a1256 1
	while ((imm = ia->ia6_memberships.lh_first) != NULL) {
d1288 1
a1288 1
	if (oia->ia6_multiaddrs.lh_first != NULL) {
d1514 1
a1514 4
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
d1597 1
a1597 3
	for (ifa = ifp->if_addrlist.tqh_first; ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d1660 3
a1662 2
		for (in6m = oia->ia6_multiaddrs.lh_first; in6m; in6m = next){
			next = in6m->in6m_entry.le_next;
d1671 1
a1671 1
		for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
d1678 3
a1680 2
		for (in6m = oia->ia6_multiaddrs.lh_first; in6m; in6m = next){
			next = in6m->in6m_entry.le_next;
d1700 1
a1700 1
	for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
d1704 4
a1707 2
			for (in6m = mk->mk_head.lh_first; in6m; in6m = next) {
				next = in6m->in6m_entry.le_next;
d1736 1
a1736 1
	for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
d1757 1
a1757 1
	for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
d1934 1
a1934 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d1961 1
a1961 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d2240 1
a2240 3
		for (ifa = ifp->if_addrlist.tqh_first; ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
d2476 1
a2476 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d2510 1
a2510 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d2554 1
a2554 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
@


1.62
log
@Fix pasto: clear correct buffer, from James Juran via NetBSD. ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.61 2005/09/19 19:36:49 brad Exp $	*/
d1591 1
a1591 1
	int	s = splimp();
@


1.62.2.1
log
@MFC:
Fix by mpf@@

Only run address hooks on SIOCAIFADDR_IN6 and SIOCDIFADDR_IN6.
Before a normal user running ifconfig(8) could trigger up to three
address hook calls per interface.

ok mcbride@@ deraadt@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.62 2006/02/14 10:34:31 otto Exp $	*/
a704 1
		dohooks(ifp->if_addrhooks, 0);
a744 1
		dohooks(ifp->if_addrhooks, 0);
d754 1
@


1.61
log
@remove the unused in6_ifindex2scopeid()
if at all, it works with site-local addresses whose fate is uncertain
to say the least

From drochner NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.60 2004/10/07 12:08:25 henning Exp $	*/
d552 1
a552 1
		bzero(&ifr->ifr_ifru.ifru_stat,
@


1.60
log
@missing dohooks(), needed for (em0:network) style notation with v6, was not
updated properly in all cases. from cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.59 2004/08/24 02:57:33 tedu Exp $	*/
a276 26
}

int
in6_ifindex2scopeid(idx)
	int idx;
{
	struct ifnet *ifp;
	struct ifaddr *ifa;
	struct sockaddr_in6 *sin6;

	if (idx < 0 || if_indexlim <= idx)
		return -1;
	ifp = ifindex2ifnet[idx];
	if (!ifp)
		return -1;

	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		sin6 = (struct sockaddr_in6 *)ifa->ifa_addr;
		if (IN6_IS_ADDR_SITELOCAL(&sin6->sin6_addr))
			return sin6->sin6_scope_id & 0xffff;
	}

	return -1;
@


1.59
log
@revert.  itojun notes that 128 is ok because of bitlen check.
add a comment to this effect since many of us were confused.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.58 2004/08/21 06:57:50 tedu Exp $	*/
d780 1
@


1.58
log
@correct bounds checks.  found at/by Coverity.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.57 2004/06/21 23:50:37 tholo Exp $	*/
d2193 1
a2193 1
	if (0 > len || len >= 128) {
d2204 1
d2222 1
a2222 1
	if (0 > len || len >= 128) {
d2233 1
@


1.57
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.56 2004/06/17 09:43:55 itojun Exp $	*/
d2193 1
a2193 1
	if (0 > len || len > 128) {
d2221 1
a2221 1
	if (0 > len || len > 128) {
@


1.56
log
@correct multicast handling for special groups (like solicited node multicast).
from jinmei@@kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.55 2004/06/15 04:03:20 itojun Exp $	*/
d531 1
a531 1
		 && lt->ia6t_vltime + time.tv_sec < time.tv_sec) {
d535 1
a535 1
		 && lt->ia6t_pltime + time.tv_sec < time.tv_sec) {
d629 1
a629 1
				time.tv_sec + ia->ia6_lifetime.ia6t_vltime;
d634 1
a634 1
				time.tv_sec + ia->ia6_lifetime.ia6t_pltime;
d939 1
a939 1
		ia->ia6_createtime = ia->ia6_updatetime = time.tv_sec;
d1011 1
a1011 1
		    time.tv_sec + ia->ia6_lifetime.ia6t_vltime;
d1016 1
a1016 1
		    time.tv_sec + ia->ia6_lifetime.ia6t_pltime;
d1034 1
a1034 1
		ia->ia6_lifetime.ia6t_preferred = time.tv_sec;
@


1.55
log
@avoid creating multiple multicast filter entry for the same group.
notified from Patrick Latifi, deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.54 2004/02/23 05:06:41 itojun Exp $	*/
a798 1
	struct in6_multi *in6m;
d1046 6
d1056 1
d1063 20
a1082 29
		if (hostIsNew) {
			/* join solicited multicast addr for new host id */
			struct sockaddr_in6 llsol;

			bzero(&llsol, sizeof(llsol));
			llsol.sin6_family = AF_INET6;
			llsol.sin6_len = sizeof(llsol);
			llsol.sin6_addr.s6_addr16[0] = htons(0xff02);
			llsol.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
			llsol.sin6_addr.s6_addr32[1] = 0;
			llsol.sin6_addr.s6_addr32[2] = htonl(1);
			llsol.sin6_addr.s6_addr32[3] =
			    ifra->ifra_addr.sin6_addr.s6_addr32[3];
			llsol.sin6_addr.s6_addr8[12] = 0xff;
			IN6_LOOKUP_MULTI(llsol.sin6_addr, ifp, in6m);
			if (!in6m) {
				imm = in6_joingroup(ifp, &llsol.sin6_addr,
				    &error);
				if (!imm) {
					nd6log((LOG_ERR, "in6_update_ifa: "
					    "addmulti failed for %s on %s "
					    "(errno=%d)\n",
					    ip6_sprintf(&llsol.sin6_addr),
					    ifp->if_xname, error));
					goto cleanup;
				}
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			}
d1084 1
d1141 8
a1148 12
		IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
		if (!in6m) {
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (!imm) {
				nd6log((LOG_WARNING,
				    "in6_update_ifa: addmulti failed for "
				    "%s on %s (errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
				goto cleanup;
			}
			LIST_INSERT_HEAD(&ia->ia6_memberships, imm, i6mm_chain);
d1150 1
d1156 10
a1165 15
			IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
			if (!in6m) {
				imm = in6_joingroup(ifp, &mltaddr.sin6_addr,
				    &error);
				if (!imm) {
					nd6log((LOG_WARNING, "in6_update_ifa: "
					    "addmulti failed for %s on %s "
					    "(errno=%d)\n",
					    ip6_sprintf(&mltaddr.sin6_addr),
					    ifp->if_xname, error));
					/* XXX not very fatal, go on... */
				} else {
					LIST_INSERT_HEAD(&ia->ia6_memberships,
					    imm, i6mm_chain);
				}
d1205 7
a1211 14
			IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
			if (!in6m) {
				imm = in6_joingroup(ifp, &mltaddr.sin6_addr,
				    &error);
				if (!imm) {
					nd6log((LOG_WARNING, "in6_update_ifa: "
					    "addmulti failed for %s on %s "
					    "(errno=%d)\n",
					    ip6_sprintf(&mltaddr.sin6_addr),
					    ifp->if_xname, error));
					goto cleanup;
				}
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
d1213 1
@


1.54
log
@avoid touching out-of-bound memory if len == 128.
Ted Unangst via Colin Percival
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.53 2004/01/13 06:28:16 mcbride Exp $	*/
/*	$KAME: in6.c,v 1.198 2001/07/18 09:12:38 itojun Exp $	*/
d799 1
d1071 12
a1082 2
			imm = in6_joingroup(ifp, &llsol.sin6_addr, &error);
			if (imm) {
a1084 6
			} else {
				nd6log((LOG_ERR, "in6_update_ifa: addmulti "
				    "failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&llsol.sin6_addr),
				    ifp->if_xname, error));
				goto cleanup;
d1143 12
a1154 11
		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
		if (imm) {
			LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
			    i6mm_chain);
		} else {
			nd6log((LOG_WARNING,
			    "in6_update_ifa: addmulti failed for "
			    "%s on %s (errno=%d)\n",
			    ip6_sprintf(&mltaddr.sin6_addr),
			    ifp->if_xname, error));
			goto cleanup;
d1161 15
a1175 10
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
				/* XXX not very fatal, go on... */
d1215 12
a1226 2
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
a1228 7
			} else {
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s "
				    "(errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
				goto cleanup;
@


1.53
log
@Expose in6_ifremloop() and in6_ifaddloop() so that they can be used by carp.

ok henning@@ millert@@ itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.52 2003/12/10 03:30:21 itojun Exp $	*/
d2206 2
a2207 1
	if (p1->s6_addr[bytelen] >> (8 - bitlen) !=
@


1.52
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.51 2003/06/24 07:47:54 itojun Exp $	*/
d213 1
a213 1
static void
d231 1
a231 1
static void
@


1.51
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.50 2003/06/02 23:28:15 millert Exp $	*/
d287 1
a287 1
	if (idx < 0 || if_index < idx)
d290 2
@


1.50
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.49 2002/10/17 00:09:39 itojun Exp $	*/
a355 1
	time_t time_second = (time_t)time.tv_sec;
d529 1
a529 1
		 && lt->ia6t_vltime + time_second < time_second) {
d533 1
a533 1
		 && lt->ia6t_pltime + time_second < time_second) {
d627 1
a627 1
				time_second + ia->ia6_lifetime.ia6t_vltime;
d632 1
a632 1
				time_second + ia->ia6_lifetime.ia6t_pltime;
a797 1
	time_t time_second = (time_t)time.tv_sec;
d937 1
a937 1
		ia->ia6_createtime = ia->ia6_updatetime = time_second;
d1009 1
a1009 1
		    time_second + ia->ia6_lifetime.ia6t_vltime;
d1014 1
a1014 1
		    time_second + ia->ia6_lifetime.ia6t_pltime;
d1032 1
a1032 1
		ia->ia6_lifetime.ia6t_preferred = time_second;
@


1.49
log
@do not differentiate manually configured address from autoconfigured ones
wrt prefix management;
- always earn a reference to the prefix when an address is configured
 (by ioctl).
- always delete the prefix when an address that has the last referene
  is manually removed.

The change should solve the problem raised in KAME-snap 6989.

sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.48 2002/09/23 23:28:15 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.48
log
@better "ifconfig ipv6addr deprecated" flag handling.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.47 2002/09/11 03:15:36 itojun Exp $	*/
d707 1
a707 1
		/* add the prefix if there's one. */
d721 3
a723 2
		if ((ia->ia6_flags & IN6_IFF_AUTOCONF) &&
		    ia->ia6_ndpr == NULL) { /* new autoconfed addr */
a762 8
		/*
		 * The logic of the following condition is a bit complicated.
		 * We expire the prefix when
		 * 1. the address obeys autoconfiguration and it is the
		 *    only owner of the associated prefix, or
		 * 2. the address does not obey autoconf and there is no
		 *    other owner of the prefix.
		 */
d764 5
a768 5
		    (((ia->ia6_flags & IN6_IFF_AUTOCONF) != 0 &&
		      pr->ndpr_refcnt == 1) ||
		     ((ia->ia6_flags & IN6_IFF_AUTOCONF) == 0 &&
		      pr->ndpr_refcnt == 0)))
			purgeprefix = 1;
@


1.47
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.46 2002/06/14 21:35:00 todd Exp $	*/
d647 7
d887 2
a888 2
			nd6log((LOG_INFO, "in6_update_ifa: a destination can be "
			    "specified for a p2p or a loopback IF only\n"));
d892 2
a893 2
			nd6log((LOG_INFO, "in6_update_ifa: prefixlen should be "
			    "128 when dstaddr is specified\n"));
d1036 12
a1051 1
	ia->ia6_flags = ifra->ifra_flags;
@


1.46
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.45 2002/06/11 07:36:00 itojun Exp $	*/
d336 1
a336 1
			return(-1);
d339 1
a339 1
				return(-1);
d374 1
a374 1
		return(EOPNOTSUPP);
d383 1
a383 1
			return(EPERM);
d391 1
a391 1
		return(nd6_ioctl(cmd, data, ifp));
d404 1
a404 1
		return(EOPNOTSUPP);
d411 1
a411 1
			return(EPERM);
d465 1
a465 1
				return(EINVAL);	/* link ID contradicts */
d470 1
a470 1
					return(EINVAL);
d486 1
a486 1
		return(EINVAL);
d497 1
a497 1
			return(EADDRNOTAVAIL);
d506 1
a506 1
			return(EAFNOSUPPORT);
d508 1
a508 1
			return(EPERM);
d521 1
a521 1
			return(EADDRNOTAVAIL);
d528 1
a528 1
			return(EPERM);
d530 1
a530 1
			return(EADDRNOTAVAIL);
d553 1
a553 1
			return(EINVAL);
d652 1
a652 1
			return(error);
d707 1
a707 1
				return(error);
d711 1
a711 1
				return(EINVAL); /* XXX panic here? */
d779 2
a780 2
			return(EOPNOTSUPP);
		return((*ifp->if_ioctl)(ifp, cmd, data));
d783 1
a783 1
	return(0);
d808 1
a808 1
		return(EINVAL);
d817 1
a817 1
		return(EAFNOSUPPORT);
d823 1
a823 1
		return(EINVAL);
d831 1
a831 1
		return(EINVAL);
d837 1
a837 1
			return(EINVAL);
d864 1
a864 1
				return(EINVAL);	/* ifid contradicts */
d882 1
a882 1
			return(EINVAL);
d901 1
a901 1
			return(EINVAL);
d908 1
a908 1
		return(EINVAL);
d919 1
a919 1
			return(0); /* there's nothing to do */
d1223 1
a1223 1
	return(error);
d1232 1
a1232 1
	return(error);
d1634 1
a1634 1
		return(error);
d1652 1
a1652 1
			return(error);
d1666 1
a1666 1
	return(error);
d1825 1
a1825 1
			return(NULL);
d1835 1
a1835 1
			return(NULL);
d1859 1
a1859 1
			return(NULL);
d1868 1
a1868 1
	return(in6m);
d1970 1
a1970 1
	return((struct in6_ifaddr *)ifa);
d1996 1
a1996 1
	return((struct in6_ifaddr *)ifa);
d2050 1
a2050 1
	return(ip6buf[ip6round]);
d2121 1
a2121 1
		return(-1);	/* XXX: is this an appropriate value? */
d2125 1
a2125 1
		return(ifp->if_index);
d2128 1
a2128 1
		return(0);	/* XXX: invalid. */
d2131 1
a2131 1
		return(0);	/* XXX: treat as global. */
d2148 1
a2148 1
			return(1); /* true */
d2153 1
a2153 1
	return(0);		/* false */
d2191 1
a2191 1
		return(0);
d2198 1
a2198 1
		return(0);
d2201 1
a2201 1
		return(0);
d2203 1
a2203 1
	return(1);
d2246 1
a2246 1
		return(NULL);
d2476 1
a2476 1
	return(ifa_best);
d2536 1
a2536 1
		return(besta);
d2602 1
a2602 1
		return(0);
d2612 1
a2612 1
		return(0);
d2625 1
a2625 1
			return(0);
d2627 1
a2627 1
		return(1);
@


1.45
log
@silence some of log(), as the codepath will be visited for IPv6-non-capable
interfaces too and can be annoying.  net.inet6.icmp6.nd6_debug will
re-enable them.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.44 2002/06/09 14:38:39 itojun Exp $	*/
d1374 1
a1374 1
 * this is to accomodate address naming scheme other than RFC2374,
@


1.44
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.43 2002/06/08 21:51:08 itojun Exp $	*/
d880 2
a881 2
			log(LOG_INFO, "in6_update_ifa: a destination can be "
			    "specified for a p2p or a loopback IF only\n");
d885 2
a886 2
			log(LOG_INFO, "in6_update_ifa: prefixlen should be "
			    "128 when dstaddr is specified\n");
d914 1
a914 1
		log(LOG_INFO,
d916 1
a916 1
		    ip6_sprintf(&ifra->ifra_addr.sin6_addr));
d978 1
a978 1
			log(LOG_INFO, "in6_update_ifa: the prefix length of an"
d980 1
a980 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr));
d998 1
a998 1
			log(LOG_ERR, "in6_update_ifa: failed to remove "
d1000 1
a1000 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr));
d1068 1
a1068 1
				log(LOG_ERR, "in6_update_ifa: addmulti "
d1071 1
a1071 1
				    ifp->if_xname, error);
d1136 1
a1136 1
			log(LOG_WARNING,
d1140 1
a1140 1
			    ifp->if_xname, error);
d1153 1
a1153 1
				log(LOG_WARNING, "in6_update_ifa: "
d1156 1
a1156 1
				    ifp->if_xname, error);
d1202 1
a1202 1
				log(LOG_WARNING, "in6_update_ifa: "
d1206 1
a1206 1
				    ifp->if_xname, error);
@


1.43
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.42 2002/06/08 21:22:02 itojun Exp $	*/
d150 1
a150 1
	
d157 1
a157 1
	
d341 1
a341 1
	
d600 1
a600 1
			if (ia->ia6_lifetime.ia6t_vltime < 
d618 1
a618 1
			if (ia->ia6_lifetime.ia6t_pltime < 
d895 1
a895 1
			    sizeof(struct sockaddr_in6); 
d990 1
a990 1
	 * p2p or loopback (see the check above.) 
d1040 1
a1040 1
	 * not just go to unlink. 
d1070 1
a1070 1
				    ip6_sprintf(&llsol.sin6_addr), 
d1139 1
a1139 1
			    ip6_sprintf(&mltaddr.sin6_addr), 
d1155 1
a1155 1
				    ip6_sprintf(&mltaddr.sin6_addr), 
d1205 1
a1205 1
				    ip6_sprintf(&mltaddr.sin6_addr), 
d2118 1
a2118 1
		
d2243 1
a2243 1
	
@


1.42
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.41 2002/06/08 00:06:58 itojun Exp $	*/
d1803 1
a1803 1
	int	s = splnet();
d1879 1
a1879 1
	int	s = splnet();
@


1.41
log
@in6_len2mask is a duplicate of in6_prefixlen2mask.  unify.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.40 2002/06/08 00:00:59 itojun Exp $	*/
d120 3
a139 11
 * Check if the loopback entry will be automatically generated.
 *   if 0 returned, will not be automatically generated.
 *   if 1 returned, will be automatically generated.
 */
static int
in6_is_ifloop_auto(struct ifaddr *ifa)
{
	return 0;
}

/*
d148 2
a149 1
	struct rtentry *nrt = NULL, **nrtp = NULL;
d153 2
a154 3
	lo_sa.sin6_family = AF_INET6;
	lo_sa.sin6_len = sizeof(struct sockaddr_in6);
	all1_sa = lo_sa;
d159 16
a174 10
	 * So we add or remove static loopback entry, here.
	 * This request for deletion could fail, e.g. when we remove
	 * an address right after adding it.
	 */
	if (cmd == RTM_ADD)
		nrtp = &nrt;
	rtrequest(cmd, ifa->ifa_addr,
		  (struct sockaddr *)&lo_sa,
		  (struct sockaddr *)&all1_sa,
		  RTF_UP|RTF_HOST, nrtp);
d188 20
a207 2
	if (nrt)
		nrt->rt_refcnt--;
d211 5
a215 3
 * Add ownaddr as loopback rtentry, if necessary(ex. on p2p link).
 * Because, KAME needs loopback rtentry for ownaddr check in
 * ip6_input().
d220 1
a220 2
	if (!in6_is_ifloop_auto(ifa)) {
		struct rtentry *rt;
d222 7
a228 7
		/* If there is no loopback entry, allocate one. */
		rt = rtalloc1(ifa->ifa_addr, 0);
		if (rt == 0 || (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
			in6_ifloop_request(RTM_ADD, ifa);
		if (rt)
			rt->rt_refcnt--;
	}
d238 12
a249 3
	if (!in6_is_ifloop_auto(ifa)) {
		struct in6_ifaddr *ia;
		int ia_count = 0;
d251 11
a261 8
		/* If only one ifa for the loopback entry, delete it. */
		for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
			if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa),
					       &ia->ia_addr.sin6_addr)) {
				ia_count++;
				if (ia_count > 1)
					break;
			}
d263 15
a277 1
		if (ia_count == 1)
d279 1
d308 1
a308 1
in6_mask2len(mask)
d310 1
d312 2
a313 1
	int x, y;
d315 5
a319 2
	for (x = 0; x < sizeof(*mask); x++) {
		if (mask->s6_addr8[x] != 0xff)
d323 1
a323 1
	if (x < sizeof(*mask)) {
d325 1
a325 1
			if ((mask->s6_addr8[x] & (0x80 >> y)) == 0)
d329 13
d357 1
a357 1
	struct	in6_ifaddr *ia, *oia;
a359 3
	struct	sockaddr_in6 oldaddr;
	int error = 0, hostIsNew, prefixIsNew;
	int newifaddr;
d373 1
a373 1
	if (ifp == 0)
a508 36
		if (ia == NULL) {
			ia = (struct in6_ifaddr *)
				malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
			bzero((caddr_t)ia, sizeof(*ia));
			/* Initialize the address and masks */
			ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
			ia->ia_addr.sin6_family = AF_INET6;
			ia->ia_addr.sin6_len = sizeof(ia->ia_addr);
			if (ifp->if_flags & IFF_POINTOPOINT) {
				ia->ia_ifa.ifa_dstaddr
					= (struct sockaddr *)&ia->ia_dstaddr;
				ia->ia_dstaddr.sin6_family = AF_INET6;
				ia->ia_dstaddr.sin6_len = sizeof(ia->ia_dstaddr);
			} else {
				ia->ia_ifa.ifa_dstaddr = NULL;
				bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
			}
			ia->ia_ifa.ifa_netmask
				= (struct sockaddr *)&ia->ia_prefixmask;

			ia->ia_ifp = ifp;
			if ((oia = in6_ifaddr) != NULL) {
				for ( ; oia->ia_next; oia = oia->ia_next)
					continue;
				oia->ia_next = ia;
			} else
				in6_ifaddr = ia;
			ia->ia_ifa.ifa_refcnt++;

			TAILQ_INSERT_TAIL(&ifp->if_addrlist,
				(struct ifaddr *)ia, ifa_list);
			ia->ia_ifa.ifa_refcnt++;

			newifaddr = 1;
		} else
			newifaddr = 0;
a509 13
		if (cmd == SIOCAIFADDR_IN6) {
			/* sanity for overflow - beware unsigned */
			struct in6_addrlifetime *lt;
			lt = &ifra->ifra_lifetime;
			if (lt->ia6t_vltime != ND6_INFINITE_LIFETIME
			 && lt->ia6t_vltime + time_second < time_second) {
				return EINVAL;
			}
			if (lt->ia6t_pltime != ND6_INFINITE_LIFETIME
			 && lt->ia6t_pltime + time_second < time_second) {
				return EINVAL;
			}
		}
d554 4
d589 36
d643 90
a732 2
		prefixIsNew = 0;
		hostIsNew = 1;
a733 16
		if (ifra->ifra_addr.sin6_len == 0) {
			ifra->ifra_addr = ia->ia_addr;
			hostIsNew = 0;
		} else if (IN6_ARE_ADDR_EQUAL(&ifra->ifra_addr.sin6_addr,
					      &ia->ia_addr.sin6_addr))
			hostIsNew = 0;

		/* Validate address families: */
		/*
		 * The destination address for a p2p link must have a family
		 * of AF_UNSPEC or AF_INET6.
		 */
		if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
		    ifra->ifra_dstaddr.sin6_family != AF_INET6 &&
		    ifra->ifra_dstaddr.sin6_family != AF_UNSPEC)
			return(EAFNOSUPPORT);
d735 27
a761 1
		 * The prefixmask must have a family of AF_UNSPEC or AF_INET6.
d763 46
a808 3
		if (ifra->ifra_prefixmask.sin6_family != AF_INET6 &&
		    ifra->ifra_prefixmask.sin6_family != AF_UNSPEC)
			return(EAFNOSUPPORT);
d810 55
a864 24
		if (ifra->ifra_prefixmask.sin6_len) {
			in6_ifscrub(ifp, ia);
			ia->ia_prefixmask = ifra->ifra_prefixmask;
			prefixIsNew = 1;
		}
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    (ifra->ifra_dstaddr.sin6_family == AF_INET6)) {
			in6_ifscrub(ifp, ia);
			oldaddr = ia->ia_dstaddr;
			ia->ia_dstaddr = ifra->ifra_dstaddr;
			/* link-local index check: should be a separate function? */
			if (IN6_IS_ADDR_LINKLOCAL(&ia->ia_dstaddr.sin6_addr)) {
				if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] == 0) {
					/*
					 * interface ID is not embedded by
					 * the user
					 */
					ia->ia_dstaddr.sin6_addr.s6_addr16[1]
						= htons(ifp->if_index);
				} else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
					    htons(ifp->if_index)) {
					ia->ia_dstaddr = oldaddr;
					return(EINVAL);	/* ifid contradicts */
				}
a865 1
			prefixIsNew = 1; /* We lie; but effect's the same */
d867 35
a901 5
		if (hostIsNew || prefixIsNew) {
			error = in6_ifinit(ifp, ia, &ifra->ifra_addr, 0);
#if 0
			if (error)
				goto undo;
d904 13
a916 2
		if (hostIsNew && (ifp->if_flags & IFF_MULTICAST)) {
			int error_local = 0;
d918 27
d946 2
a947 1
			 * join solicited multicast addr for new host id
d949 4
a952 12
			struct in6_addr llsol;
			bzero(&llsol, sizeof(struct in6_addr));
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr32[3] =
				ifra->ifra_addr.sin6_addr.s6_addr32[3];
			llsol.s6_addr8[12] = 0xff;
			(void)in6_addmulti(&llsol, ifp, &error_local);
			if (error == 0)
				error = error_local;
d954 2
d957 29
a985 2
		ia->ia6_flags = ifra->ifra_flags;
		ia->ia6_flags &= ~IN6_IFF_DUPLICATED;	/*safety*/
d987 15
a1001 5
		ia->ia6_lifetime = ifra->ifra_lifetime;
		/* for sanity */
		if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			ia->ia6_lifetime.ia6t_expire =
				time_second + ia->ia6_lifetime.ia6t_vltime;
d1003 86
a1088 6
			ia->ia6_lifetime.ia6t_expire = 0;
		if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			ia->ia6_lifetime.ia6t_preferred =
				time_second + ia->ia6_lifetime.ia6t_pltime;
		} else
			ia->ia6_lifetime.ia6t_preferred = 0;
d1091 4
a1094 1
		 * Perform DAD, if needed.
d1096 12
a1107 3
		if (in6if_do_dad(ifp)) {
			ia->ia6_flags |= IN6_IFF_TENTATIVE;
			nd6_dad_start((struct ifaddr *)ia, NULL);
d1109 2
d1112 31
a1142 3
		if (hostIsNew) {
			int iilen;
			int error_local = 0;
d1144 15
a1158 5
			iilen = (sizeof(ia->ia_prefixmask.sin6_addr) << 3) -
				in6_mask2len(&ia->ia_prefixmask.sin6_addr);
			error_local = in6_prefix_add_ifid(iilen, ia);
			if (error == 0)
				error = error_local;
d1161 20
a1180 1
		return(error);
d1182 29
a1210 3
	case SIOCDIFADDR_IN6:
		in6_purgeaddr(&ia->ia_ifa, ifp);
		break;
d1212 9
a1220 4
	default:
		if (ifp == NULL || ifp->if_ioctl == 0)
			return(EOPNOTSUPP);
		return((*ifp->if_ioctl)(ifp, cmd, data));
d1223 14
a1236 1
	return(0);
d1240 1
a1240 1
in6_purgeaddr(ifa, ifp)
a1241 1
	struct ifnet *ifp;
d1243 3
a1245 1
	struct in6_ifaddr *oia, *ia = (void *) ifa;
d1250 18
a1267 1
	in6_ifscrub(ifp, ia);
d1269 2
a1270 14
	if (ifp->if_flags & IFF_MULTICAST) {
		/*
		 * delete solicited multicast addr for deleting host id
		 */
		struct in6_multi *in6m;
		struct in6_addr llsol;
		bzero(&llsol, sizeof(struct in6_addr));
		llsol.s6_addr16[0] = htons(0xff02);
		llsol.s6_addr16[1] = htons(ifp->if_index);
		llsol.s6_addr32[1] = 0;
		llsol.s6_addr32[2] = htonl(1);
		llsol.s6_addr32[3] =
			ia->ia_addr.sin6_addr.s6_addr32[3];
		llsol.s6_addr8[12] = 0xff;
d1272 6
a1277 3
		IN6_LOOKUP_MULTI(llsol, ifp, in6m);
		if (in6m)
			in6_delmulti(in6m);
d1280 11
a1291 1
	IFAFREE(&ia->ia_ifa);
d1301 8
a1308 2
		else
			printf("Didn't unlink in6_ifaddr from list\n");
a1309 2
	{
		int iilen;
d1311 17
a1327 3
		iilen = (sizeof(oia->ia_prefixmask.sin6_addr) << 3) -
			in6_mask2len(&oia->ia_prefixmask.sin6_addr);
		in6_prefix_remove_ifid(iilen, oia);
a1328 2
	if (oia->ia6_multiaddrs.lh_first != NULL)
		in6_savemkludge(oia);
d1330 4
d1335 19
d1465 1
a1465 2
		bcopy(iflr->iflr_name, ifra.ifra_name,
			sizeof(ifra.ifra_name));
d1468 1
a1468 1
			((struct sockaddr *)&iflr->addr)->sa_len);
d1472 1
a1472 1
				hostid->s6_addr32[2];
d1474 1
a1474 1
				hostid->s6_addr32[3];
d1479 1
a1479 1
				((struct sockaddr *)&iflr->dstaddr)->sa_len);
d1482 1
a1482 1
					hostid->s6_addr32[2];
d1484 1
a1484 1
					hostid->s6_addr32[3];
a1487 1
		ifra.ifra_prefixmask.sin6_family = AF_INET6;
d1492 1
a1492 2
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra,
				   ifp, p);
d1522 1
a1522 1
				cmp = 0;	/*XXX*/
d1541 1
a1556 1

d1559 1
a1559 1
					ia->ia_dstaddr.sin6_len);
d1564 1
a1564 1
				in6_mask2len(&ia->ia_prefixmask.sin6_addr);
d1575 1
a1575 1
				sizeof(ifra.ifra_name));
d1578 1
a1578 1
				ia->ia_addr.sin6_len);
d1581 1
a1581 1
					ia->ia_dstaddr.sin6_len);
d1587 1
a1587 1
				ia->ia_prefixmask.sin6_len);
a1589 1

d1591 1
a1591 1
				ifp, p);
d1596 1
a1596 28
	return EOPNOTSUPP;	/*just for safety*/
}

/*
 * Delete any existing route for an interface.
 */
void
in6_ifscrub(ifp, ia)
	struct ifnet *ifp;
	struct in6_ifaddr *ia;
{
	if ((ia->ia_flags & IFA_ROUTE) == 0)
		return;
	/*
	 * We should check the existence of dstaddr, because link-local
	 * addresses can be configured without particular destinations
	 * even on point-to-point or loopback interfaces.
	 * In this case, kernel would panic in rtinit()...
	 */
	if (ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT) &&
	    (ia->ia_ifa.ifa_dstaddr != NULL))
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
	else
		rtinit(&(ia->ia_ifa), (int)RTM_DELETE, 0);
	ia->ia_flags &= ~IFA_ROUTE;

	/* Remove ownaddr's loopback rtentry, if it exists. */
	in6_ifremloop(&(ia->ia_ifa));
d1603 2
a1604 2
int
in6_ifinit(ifp, ia, sin6, scrub)
d1608 1
a1608 1
	int scrub;
d1610 1
a1610 2
	struct	sockaddr_in6 oldaddr;
	int	error, flags = RTF_UP;
d1612 1
a1613 2
	oldaddr = ia->ia_addr;
	ia->ia_addr = *sin6;
d1619 14
a1632 2
	if (ifp->if_ioctl &&
	   (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
a1633 1
		ia->ia_addr = oldaddr;
d1636 3
d1640 1
a1640 12
	switch (ifp->if_type) {
	case IFT_ARCNET:
	case IFT_ETHER:
	case IFT_FDDI:
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		ia->ia_ifa.ifa_flags |= RTF_CLONING;
		break;
	case IFT_PPP:
		ia->ia_ifa.ifa_rtrequest = nd6_p2p_rtrequest;
		ia->ia_ifa.ifa_flags |= RTF_CLONING;
		break;
	}
a1641 9
	splx(s);
	if (scrub) {
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&oldaddr;
		in6_ifscrub(ifp, ia);
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	}
	/* xxx
	 * in_socktrim
	 */
d1643 4
a1646 1
	 * Add route for the network.
d1648 6
a1653 8
	ia->ia_ifa.ifa_metric = ifp->if_metric;
	if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_ifa.ifa_dstaddr = ia->ia_ifa.ifa_addr;
		flags |= RTF_HOST;
	} else if (ifp->if_flags & IFF_POINTOPOINT) {
		if (ia->ia_dstaddr.sin6_family != AF_INET6)
			return(0);
		flags |= RTF_HOST;
a1654 2
	if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD, flags)) == 0)
		ia->ia_flags |= IFA_ROUTE;
d1656 6
a1661 2
	/* Add ownaddr as loopback rtentry, if necessary(ex. on p2p link). */
	in6_ifaddloop(&(ia->ia_ifa));
d1853 1
a1853 1
						    (caddr_t)&ifr);
a2052 17
int
in6_localaddr(in6)
	struct in6_addr *in6;
{
	struct in6_ifaddr *ia;

	if (IN6_IS_ADDR_LOOPBACK(in6) || IN6_IS_ADDR_LINKLOCAL(in6))
		return 1;

	for (ia = in6_ifaddr; ia; ia = ia->ia_next)
		if (IN6_ARE_MASKED_ADDR_EQUAL(in6, &ia->ia_addr.sin6_addr,
					      &ia->ia_prefixmask.sin6_addr))
			return 1;

	return (0);
}

d2133 21
@


1.40
log
@on SIOCAIFADDR_IN6 check if sin6_len is sane.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.39 2002/06/07 15:00:54 itojun Exp $	*/
a282 14
void
in6_len2mask(mask, len)
	struct in6_addr *mask;
	int len;
{
	int i;

	bzero(mask, sizeof(*mask));
	for (i = 0; i < len / 8; i++)
		mask->s6_addr8[i] = 0xff;
	if (len % 8)
		mask->s6_addr8[i] = (0xff00 >> (len % 8)) & 0xff;
}

d917 1
a917 1
		in6_len2mask(&ifra.ifra_prefixmask.sin6_addr, prefixlen);
d934 1
a934 1
			in6_len2mask(&mask, iflr->prefixlen);
d954 1
a954 1
				in6_len2mask(&mask, 128);
@


1.39
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.38 2002/06/07 04:18:56 itojun Exp $	*/
d455 6
a460 1
		if (ifra->ifra_addr.sin6_family != AF_INET6)
@


1.38
log
@whitespace sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.37 2002/06/07 04:13:10 itojun Exp $	*/
d1380 33
@


1.37
log
@'fall through' is not a valid LINT keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.36 2002/06/07 04:11:51 itojun Exp $	*/
d339 1
a339 1
		/*FALLTHROUGH*/
d367 1
a367 1
		/*FALLTHROUGH*/
@


1.36
log
@remove support for deprecated ioctls (EINVAL).  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.35 2002/05/29 07:54:59 itojun Exp $	*/
d339 1
a339 1
		/*fall through*/
d367 1
a367 1
		/*fall through*/
d513 1
a513 1
		/* fall through */
@


1.35
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.34 2002/05/29 02:59:12 itojun Exp $	*/
d311 1
a312 3
#ifdef COMPAT_IN6IFIOCTL
	struct	sockaddr_in6 net;
#endif
a354 3
		if (!privileged)
			return(EPERM);
		/*fall through*/
d356 4
a359 1
		return(in6_prefix_ioctl(so, cmd, data, ifp));
d374 9
d384 29
a412 4
	if (ifra->ifra_addr.sin6_family == AF_INET6) { /* XXX */
		struct sockaddr_in6 *sa6 =
			(struct sockaddr_in6 *)&ifra->ifra_addr;

d415 1
a415 1
				/* interface ID is not embedded by the user */
d417 1
a417 1
					htons(ifp->if_index);
d419 2
a420 2
				    htons(ifp->if_index)) {
				return(EINVAL);	/* ifid contradicts */
d429 3
a431 2
		ia = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr);
	}
d434 8
d446 4
a449 4
		 * "ifconfig if0 delete" to remove first IPv4 address on the
		 * interface.  For IPv6, as the spec allow multiple interface
		 * address from the day one, we consider "remove the first one"
		 * semantics to be not preferable.
a454 10
	case SIOCSIFADDR_IN6:
#ifdef COMPAT_IN6IFIOCTL
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
		/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are not suitable
		 * and should be unused.
		 */
#endif
a581 35
#ifdef COMPAT_IN6IFIOCTL		/* should be unused */
	case SIOCSIFDSTADDR_IN6:
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
			return(EINVAL);
		oldaddr = ia->ia_dstaddr;
		ia->ia_dstaddr = ifr->ifr_dstaddr;

		/* link-local index check */
		if (IN6_IS_ADDR_LINKLOCAL(&ia->ia_dstaddr.sin6_addr)) {
			if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] == 0) {
				/* interface ID is not embedded by the user */
				ia->ia_dstaddr.sin6_addr.s6_addr16[1]
					= htons(ifp->if_index);
			} else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
				    htons(ifp->if_index)) {
				ia->ia_dstaddr = oldaddr;
				return(EINVAL);	/* ifid contradicts */
			}
		}

		if (ifp->if_ioctl && (error = (ifp->if_ioctl)
				      (ifp, SIOCSIFDSTADDR, (caddr_t)ia))) {
			ia->ia_dstaddr = oldaddr;
			return(error);
		}
		if (ia->ia_flags & IFA_ROUTE) {
			ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&oldaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST);
			ia->ia_ifa.ifa_dstaddr =
				(struct sockaddr *)&ia->ia_dstaddr;
			rtinit(&(ia->ia_ifa), (int)RTM_ADD, RTF_HOST|RTF_UP);
		}
		break;

#endif
a599 57

	case SIOCSIFADDR_IN6:
		error = in6_ifinit(ifp, ia, &ifr->ifr_addr, 1);
#if 0
		/*
		 * the code chokes if we are to assign multiple addresses with
		 * the same address prefix (rtinit() will return EEXIST, which
		 * is not fatal actually).  we will get memory leak if we
		 * don't do it.
		 * -> we may want to hide EEXIST from rtinit().
		 */
  undo:
		if (error && newifaddr) {
			TAILQ_REMOVE(&ifp->if_addrlist, &ia->ia_ifa, ifa_list);
			IFAFREE(&ia->ia_ifa);

			oia = ia;
			if (oia == (ia = in6_ifaddr))
				in6_ifaddr = ia->ia_next;
			else {
				while (ia->ia_next && (ia->ia_next != oia))
					ia = ia->ia_next;
				if (ia->ia_next)
					ia->ia_next = oia->ia_next;
				else {
					printf("Didn't unlink in6_ifaddr "
					    "from list\n");
				}
			}
			IFAFREE(&oia->ia_ifa);
		}
#endif
		return error;

#ifdef COMPAT_IN6IFIOCTL		/* XXX should be unused */
	case SIOCSIFNETMASK_IN6:
		ia->ia_prefixmask = ifr->ifr_addr;
		bzero(&net, sizeof(net));
		net.sin6_len = sizeof(struct sockaddr_in6);
		net.sin6_family = AF_INET6;
		net.sin6_port = htons(0);
		net.sin6_flowinfo = htonl(0);
		net.sin6_addr.s6_addr32[0]
			= ia->ia_addr.sin6_addr.s6_addr32[0] &
				ia->ia_prefixmask.sin6_addr.s6_addr32[0];
		net.sin6_addr.s6_addr32[1]
			= ia->ia_addr.sin6_addr.s6_addr32[1] &
				ia->ia_prefixmask.sin6_addr.s6_addr32[1];
		net.sin6_addr.s6_addr32[2]
			= ia->ia_addr.sin6_addr.s6_addr32[2] &
				ia->ia_prefixmask.sin6_addr.s6_addr32[2];
		net.sin6_addr.s6_addr32[3]
			= ia->ia_addr.sin6_addr.s6_addr32[3] &
				ia->ia_prefixmask.sin6_addr.s6_addr32[3];
		ia->ia_net = net;
		break;
#endif
@


1.34
log
@move per-interface ip6/icmp6 stat to ifnet->if_afdata.   sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.33 2002/05/23 06:56:16 itojun Exp $	*/
d342 1
a759 8
		 * make sure to initialize ND6 information.  this is to
		 * workaround issues with interfaces with IPv6 addresses,
		 * which have never brought # up.  we are assuming that it is
		 * safe to nd6_ifattach multiple times.
		 */
		nd6_ifattach(ifp);

		/*
d2138 3
d2142 2
a2143 2
		    nd_ifinfo[ifp->if_index].linkmtu > maxmtu)
			maxmtu =  nd_ifinfo[ifp->if_index].linkmtu;
d2145 1
a2145 1
	if (maxmtu)	/* update only when maxmtu is positive */
a2166 1
#if 0
a2167 1
#endif
a2177 1
#if 0
a2178 1
#endif
@


1.33
log
@simplify condition to perform DAD.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.32 2002/03/23 00:50:59 itojun Exp $	*/
d535 4
a538 7
		if (in6_ifstat == NULL || ifp->if_index >= in6_ifstatmax
		 || in6_ifstat[ifp->if_index] == NULL) {
			/* return EAFNOSUPPORT? */
			bzero(&ifr->ifr_ifru.ifru_stat,
				sizeof(ifr->ifr_ifru.ifru_stat));
		} else
			ifr->ifr_ifru.ifru_stat = *in6_ifstat[ifp->if_index];
d544 4
a547 8
		if (icmp6_ifstat == NULL || ifp->if_index >= icmp6_ifstatmax ||
		    icmp6_ifstat[ifp->if_index] == NULL) {
			/* return EAFNOSUPPORT? */
			bzero(&ifr->ifr_ifru.ifru_stat,
				sizeof(ifr->ifr_ifru.ifru_icmp6stat));
		} else
			ifr->ifr_ifru.ifru_icmp6stat =
				*icmp6_ifstat[ifp->if_index];
d2151 39
@


1.32
log
@correct arg to bcmp().  need to compare 15 bytes, not 3 bytes.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.31 2002/03/14 01:27:11 millert Exp $	*/
a774 2
		 * XXX It may be of use, if we can administratively
		 * disable DAD.
d776 1
a776 9
		switch (ifp->if_type) {
		case IFT_ARCNET:
		case IFT_ETHER:
		case IFT_FDDI:
#if 0
		case IFT_ATM:
		case IFT_SLIP:
		case IFT_PPP:
#endif
a778 7
			break;
		case IFT_DUMMY:
		case IFT_FAITH:
		case IFT_GIF:
		case IFT_LOOP:
		default:
			break;
d2103 34
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.30 2001/12/07 09:16:07 itojun Exp $	*/
d1649 1
a1649 1
	if (bcmp(&in6addr_loopback, addr, sizeof(addr) - 1) == 0) {
@


1.30
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.29 2001/07/18 12:50:44 itojun Exp $	*/
d118 2
a119 2
static int in6_lifaddr_ioctl __P((struct socket *, u_long, caddr_t,
	struct ifnet *, struct proc *));
@


1.30.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.30 2001/12/07 09:16:07 itojun Exp $	*/
d118 2
a119 5
static int in6_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *, struct proc *);
static int in6_ifinit(struct ifnet *, struct in6_ifaddr *,
	struct sockaddr_in6 *, int);
static void in6_unlink_ifa(struct in6_ifaddr *, struct ifnet *);
d137 11
d156 1
a156 2
	struct rtentry *nrt = NULL;
	int e;
d160 3
a162 2
	lo_sa.sin6_family = all1_sa.sin6_family = AF_INET6;
	lo_sa.sin6_len = all1_sa.sin6_len = sizeof(struct sockaddr_in6);
d167 10
a176 16
	 * We specify the address itself as the gateway, and set the
	 * RTF_LLINFO flag, so that the corresponding host route would have
	 * the flag, and thus applications that assume traditional behavior
	 * would be happy.  Note that we assume the caller of the function
	 * (probably implicitly) set nd6_rtrequest() to ifa->ifa_rtrequest,
	 * which changes the outgoing interface to the loopback interface.
	 */
	e = rtrequest(cmd, ifa->ifa_addr, ifa->ifa_addr,
	    (struct sockaddr *)&all1_sa, RTF_UP|RTF_HOST|RTF_LLINFO, &nrt);
	if (e != 0) {
		log(LOG_ERR, "in6_ifloop_request: "
		    "%s operation failed for %s (errno=%d)\n",
		    cmd == RTM_ADD ? "ADD" : "DELETE",
		    ip6_sprintf(&((struct in6_ifaddr *)ifa)->ia_addr.sin6_addr),
		    e);
	}
d190 2
a191 20

	/*
	 * Report the addition/removal of the address to the routing socket.
	 * XXX: since we called rtinit for a p2p interface with a destination,
	 *      we end up reporting twice in such a case.  Should we rather
	 *      omit the second report?
	 */
	if (nrt) {
		rt_newaddrmsg(cmd, ifa, e, nrt);
		if (cmd == RTM_DELETE) {
			if (nrt->rt_refcnt <= 0) {
				/* XXX: we should free the entry ourselves. */
				nrt->rt_refcnt++;
				rtfree(nrt);
			}
		} else {
			/* the cmd must be RTM_ADD here */
			nrt->rt_refcnt--;
		}
	}
d195 3
a197 5
 * Add ownaddr as loopback rtentry.  We previously add the route only if
 * necessary (ex. on a p2p link).  However, since we now manage addresses
 * separately from prefixes, we should always add the route.  We can't
 * rely on the cloning mechanism from the corresponding interface route
 * any more.
d202 2
a203 1
	struct rtentry *rt;
d205 7
a211 7
	/* If there is no loopback entry, allocate one. */
	rt = rtalloc1(ifa->ifa_addr, 0);
	if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0 ||
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
		in6_ifloop_request(RTM_ADD, ifa);
	if (rt)
		rt->rt_refcnt--;
d221 3
a223 3
	struct in6_ifaddr *ia;
	struct rtentry *rt;
	int ia_count = 0;
d225 8
a232 20
	/*
	 * Some of BSD variants do not remove cloned routes
	 * from an interface direct route, when removing the direct route
	 * (see comments in net/net_osdep.h).  Even for variants that do remove
	 * cloned routes, they could fail to remove the cloned routes when
	 * we handle multple addresses that share a common prefix.
	 * So, we should remove the route corresponding to the deleted address.
	 */

	/*
	 * Delete the entry only if exact one ifa exists.  More than one ifa
	 * can exist if we assign a same single address to multiple
	 * (probably p2p) interfaces.
	 * XXX: we should avoid such a configuration in IPv6...
	 */
	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &ia->ia_addr.sin6_addr)) {
			ia_count++;
			if (ia_count > 1)
				break;
d234 1
a234 15
	}

	if (ia_count == 1) {
		/*
		 * Before deleting, check if a corresponding loopbacked host
		 * route surely exists.  With this check, we can avoid to
		 * delete an interface direct route whose destination is same
		 * as the address being removed.  This can happen when removing
		 * a subnet-router anycast address on an interface attahced
		 * to a shared medium.
		 */
		rt = rtalloc1(ifa->ifa_addr, 0);
		if (rt != NULL && (rt->rt_flags & RTF_HOST) != 0 &&
		    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
			rt->rt_refcnt--;
a235 1
		}
d264 1
a264 1
in6_mask2len(mask, lim0)
a265 1
	u_char *lim0;
d267 1
a267 2
	int x = 0, y;
	u_char *lim = lim0, *p;
d269 2
a270 5
	/* ignore the scope_id part */
	if (lim0 == NULL || lim0 - (u_char *)mask > sizeof(*mask))
		lim = (u_char *)mask + sizeof(*mask);
	for (p = (u_char *)mask; p < lim; x++, p++) {
		if (*p != 0xff)
d274 1
a274 1
	if (p < lim) {
d276 1
a276 1
			if ((*p & (0x80 >> y)) == 0)
d280 9
d290 5
a294 13
	/*
	 * when the limit pointer is given, do a stricter check on the
	 * remaining bits.
	 */
	if (p < lim) {
		if (y != 0 && (*p & (0x00ff >> y)) != 0)
			return(-1);
		for (p = p + 1; p < lim; p++)
			if (*p != 0)
				return(-1);
	}
	
	return x * 8 + y;
d309 1
a309 1
	struct	in6_ifaddr *ia = NULL;
d311 6
a316 1
	struct sockaddr_in6 *sa6;
d330 1
a330 1
	if (ifp == NULL)
d341 1
a341 2
		/* FALLTHROUGH */
	case OSIOCGIFINFO_IN6:
d356 3
d360 1
a360 4
		log(LOG_NOTICE,
		    "prefix ioctls are now invalidated. "
		    "please use ifconfig.\n");
		return(EOPNOTSUPP);
d368 1
a368 1
		/* FALLTHROUGH */
a374 9
	 *
	 * In netinet code, we have checked ifra_addr in SIOCSIF*ADDR operation
	 * only, and used the first interface address as the target of other
	 * operations (without checking ifra_addr).  This was because netinet
	 * code/API assumed at most 1 interface address per interface.
	 * Since IPv6 allows a node to assign multiple addresses
	 * on a single interface, we almost always look and check the
	 * presence of ifra_addr, and reject invalid ones here.
	 * It also decreases duplicated code among SIOC*_IN6 operations.
d376 4
a379 29
	switch (cmd) {
	case SIOCAIFADDR_IN6:
	case SIOCSIFPHYADDR_IN6:
		sa6 = &ifra->ifra_addr;
		break;
	case SIOCSIFADDR_IN6:
	case SIOCGIFADDR_IN6:
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
	case SIOCGIFDSTADDR_IN6:
	case SIOCGIFNETMASK_IN6:
	case SIOCDIFADDR_IN6:
	case SIOCGIFPSRCADDR_IN6:
	case SIOCGIFPDSTADDR_IN6:
	case SIOCGIFAFLAG_IN6:
	case SIOCSNDFLUSH_IN6:
	case SIOCSPFXFLUSH_IN6:
	case SIOCSRTRFLUSH_IN6:
	case SIOCGIFALIFETIME_IN6:
	case SIOCSIFALIFETIME_IN6:
	case SIOCGIFSTAT_IN6:
	case SIOCGIFSTAT_ICMP6:
		sa6 = &ifr->ifr_addr;
		break;
	default:
		sa6 = NULL;
		break;
	}
	if (sa6 && sa6->sin6_family == AF_INET6) {
d382 1
a382 1
				/* link ID is not embedded by the user */
d384 1
a384 1
				    htons(ifp->if_index);
d386 2
a387 2
			    htons(ifp->if_index)) {
				return(EINVAL);	/* link ID contradicts */
d396 2
a397 3
		ia = in6ifa_ifpwithaddr(ifp, &sa6->sin6_addr);
	} else
		ia = NULL;
a399 8
	case SIOCSIFADDR_IN6:
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
		/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are deprecated.
		 */
		return(EINVAL);
d404 4
a407 4
		 * "ifconfig if0 delete" to remove the first IPv4 address on
		 * the interface.  For IPv6, as the spec allows multiple
		 * interface address from the day one, we consider "remove the
		 * first one" semantics to be not preferable.
d413 4
d418 3
a420 2
		 * We always require users to specify a valid IPv6 address for
		 * the corresponding operation.
d422 2
a423 2
		if (ifra->ifra_addr.sin6_family != AF_INET6 ||
		    ifra->ifra_addr.sin6_len != sizeof(struct sockaddr_in6))
d427 19
d447 30
d481 1
a481 1
		/* FALLTHROUGH */
a520 4
		/*
		 * XXX: should we check if ifa_dstaddr is NULL and return
		 * an error?
		 */
d535 7
a541 4
		bzero(&ifr->ifr_ifru.ifru_stat,
		    sizeof(ifr->ifr_ifru.ifru_stat));
		ifr->ifr_ifru.ifru_stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->in6_ifstat;
d547 8
a554 4
		bzero(&ifr->ifr_ifru.ifru_stat,
		    sizeof(ifr->ifr_ifru.ifru_icmp6stat));
		ifr->ifr_ifru.ifru_icmp6stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->icmp6_ifstat;
d557 6
a562 6
	case SIOCGIFALIFETIME_IN6:
		ifr->ifr_ifru.ifru_lifetime = ia->ia6_lifetime;
		if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			time_t maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;
d564 11
a574 12
			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
			if (ia->ia6_lifetime.ia6t_vltime < 
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_expire = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_vltime;
			} else
				retlt->ia6t_expire = maxexpire;
a575 4
		if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			time_t maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;
d577 11
a587 12
			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
			if (ia->ia6_lifetime.ia6t_pltime < 
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_preferred = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_pltime;
			} else
				retlt->ia6t_preferred = maxexpire;
d591 5
d611 3
a613 5
	case SIOCAIFADDR_IN6:
	{
		int i, error = 0;
		struct nd_prefix pr0, *pr;

d615 10
a624 13
		 * first, make or update the interface address structure,
		 * and link it to the list.
		 */
		if ((error = in6_update_ifa(ifp, ifra, ia)) != 0)
			return(error);
		if ((ia = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr))
		    == NULL) {
		    	/*
			 * this can happen when the user specify the 0 valid
			 * lifetime.
			 */
			break;
		}
d626 12
a637 50
		/*
		 * then, make the prefix on-link on the interface.
		 * XXX: we'd rather create the prefix before the address, but
		 * we need at least one address to install the corresponding
		 * interface route, so we configure the address first.
		 */

		/*
		 * convert mask to prefix length (prefixmask has already
		 * been validated in in6_update_ifa().
		 */
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128) {
			break;	/* we don't need to install a host route. */
		}
		pr0.ndpr_prefix = ifra->ifra_addr;
		pr0.ndpr_mask = ifra->ifra_prefixmask.sin6_addr;
		/* apply the mask for safety. */
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ifra->ifra_prefixmask.sin6_addr.s6_addr32[i];
		}
		/*
		 * XXX: since we don't have an API to set prefix (not address)
		 * lifetimes, we just use the same lifetimes as addresses.
		 * The (temporarily) installed lifetimes can be overridden by
		 * later advertised RAs (when accept_rtadv is non 0), which is
		 * an intended behavior.
		 */
		pr0.ndpr_raf_onlink = 1; /* should be configurable? */
		pr0.ndpr_raf_auto =
		    ((ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0);
		pr0.ndpr_vltime = ifra->ifra_lifetime.ia6t_vltime;
		pr0.ndpr_pltime = ifra->ifra_lifetime.ia6t_pltime;

		/* add the prefix if there's one. */
		if ((pr = nd6_prefix_lookup(&pr0)) == NULL) {
			/*
			 * nd6_prelist_add will install the corresponding
			 * interface route.
			 */
			if ((error = nd6_prelist_add(&pr0, NULL, &pr)) != 0)
				return(error);
			if (pr == NULL) {
				log(LOG_ERR, "nd6_prelist_add succeeded but "
				    "no prefix\n");
				return(EINVAL); /* XXX panic here? */
d639 1
d641 2
a642 11
		if ((ia->ia6_flags & IN6_IFF_AUTOCONF) &&
		    ia->ia6_ndpr == NULL) { /* new autoconfed addr */
			ia->ia6_ndpr = pr;
			pr->ndpr_refcnt++;
		}

		/*
		 * this might affect the status of autoconfigured addresses,
		 * that is, this address might make other addresses detached.
		 */
		pfxlist_onlink_check();
d644 21
d666 1
a666 1
	}
d668 3
a670 4
	case SIOCDIFADDR_IN6:
	{
		int i = 0, purgeprefix = 0;
		struct nd_prefix pr0, *pr = NULL;
d672 16
d689 1
a689 7
		 * If the address being deleted is the only one that owns
		 * the corresponding prefix, expire the prefix as well.
		 * XXX: theoretically, we don't have to worry about such
		 * relationship, since we separate the address management
		 * and the prefix management.  We do this, however, to provide
		 * as much backward compatibility as possible in terms of
		 * the ioctl operation.
d691 3
a693 33
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128)
			goto purgeaddr;
		pr0.ndpr_prefix = ia->ia_addr;
		pr0.ndpr_mask = ia->ia_prefixmask.sin6_addr;
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ia->ia_prefixmask.sin6_addr.s6_addr32[i];
		}
		/*
		 * The logic of the following condition is a bit complicated.
		 * We expire the prefix when
		 * 1. the address obeys autoconfiguration and it is the
		 *    only owner of the associated prefix, or
		 * 2. the address does not obey autoconf and there is no
		 *    other owner of the prefix.
		 */
		if ((pr = nd6_prefix_lookup(&pr0)) != NULL &&
		    (((ia->ia6_flags & IN6_IFF_AUTOCONF) != 0 &&
		      pr->ndpr_refcnt == 1) ||
		     ((ia->ia6_flags & IN6_IFF_AUTOCONF) == 0 &&
		      pr->ndpr_refcnt == 0)))
			purgeprefix = 1;

	  purgeaddr:
		in6_purgeaddr(&ia->ia_ifa);
		if (pr && purgeprefix)
			prelist_remove(pr);
		break;
	}
d695 24
a718 88
	default:
		if (ifp == NULL || ifp->if_ioctl == 0)
			return(EOPNOTSUPP);
		return((*ifp->if_ioctl)(ifp, cmd, data));
	}

	return(0);
}

/*
 * Update parameters of an IPv6 interface address.
 * If necessary, a new entry is created and linked into address chains.
 * This function is separated from in6_control().
 * XXX: should this be performed under splnet()?
 */
int
in6_update_ifa(ifp, ifra, ia)
	struct ifnet *ifp;
	struct in6_aliasreq *ifra;
	struct in6_ifaddr *ia;
{
	int error = 0, hostIsNew = 0, plen = -1;
	struct in6_ifaddr *oia;
	struct sockaddr_in6 dst6;
	struct in6_addrlifetime *lt;
	struct in6_multi_mship *imm;
	time_t time_second = (time_t)time.tv_sec;
	struct rtentry *rt;

	/* Validate parameters */
	if (ifp == NULL || ifra == NULL) /* this maybe redundant */
		return(EINVAL);

	/*
	 * The destination address for a p2p link must have a family
	 * of AF_UNSPEC or AF_INET6.
	 */
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    ifra->ifra_dstaddr.sin6_family != AF_INET6 &&
	    ifra->ifra_dstaddr.sin6_family != AF_UNSPEC)
		return(EAFNOSUPPORT);
	/*
	 * validate ifra_prefixmask.  don't check sin6_family, netmask
	 * does not carry fields other than sin6_len.
	 */
	if (ifra->ifra_prefixmask.sin6_len > sizeof(struct sockaddr_in6))
		return(EINVAL);
	/*
	 * Because the IPv6 address architecture is classless, we require
	 * users to specify a (non 0) prefix length (mask) for a new address.
	 * We also require the prefix (when specified) mask is valid, and thus
	 * reject a non-consecutive mask.
	 */
	if (ia == NULL && ifra->ifra_prefixmask.sin6_len == 0)
		return(EINVAL);
	if (ifra->ifra_prefixmask.sin6_len != 0) {
		plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    (u_char *)&ifra->ifra_prefixmask +
		    ifra->ifra_prefixmask.sin6_len);
		if (plen <= 0)
			return(EINVAL);
	} else {
		/*
		 * In this case, ia must not be NULL.  We just use its prefix
		 * length.
		 */
		plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
	}
	/*
	 * If the destination address on a p2p interface is specified,
	 * and the address is a scoped one, validate/set the scope
	 * zone identifier.
	 */
	dst6 = ifra->ifra_dstaddr;
	if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) != 0 &&
	    (dst6.sin6_family == AF_INET6)) {
		/* link-local index check: should be a separate function? */
		if (IN6_IS_ADDR_LINKLOCAL(&dst6.sin6_addr)) {
			if (dst6.sin6_addr.s6_addr16[1] == 0) {
				/*
				 * interface ID is not embedded by
				 * the user
				 */
				dst6.sin6_addr.s6_addr16[1] =
				    htons(ifp->if_index);
			} else if (dst6.sin6_addr.s6_addr16[1] !=
			    htons(ifp->if_index)) {
				return(EINVAL);	/* ifid contradicts */
d720 1
d722 5
a726 9
	}
	/*
	 * The destination address can be specified only for a p2p or a
	 * loopback interface.  If specified, the corresponding prefix length
	 * must be 128.
	 */
	if (ifra->ifra_dstaddr.sin6_family == AF_INET6) {
#ifdef FORCE_P2PPLEN
		int i;
d728 3
a731 10
		if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) == 0) {
			/* XXX: noisy message */
			log(LOG_INFO, "in6_update_ifa: a destination can be "
			    "specified for a p2p or a loopback IF only\n");
			return(EINVAL);
		}
		if (plen != 128) {
			log(LOG_INFO, "in6_update_ifa: prefixlen should be "
			    "128 when dstaddr is specified\n");
#ifdef FORCE_P2PPLEN
d733 1
a733 4
			 * To be compatible with old configurations,
			 * such as ifconfig gif0 inet6 2001::1 2001::2
			 * prefixlen 126, we override the specified
			 * prefixmask as if the prefix length was 128.
d735 12
a746 9
			ifra->ifra_prefixmask.sin6_len =
			    sizeof(struct sockaddr_in6); 
			for (i = 0; i < 4; i++)
				ifra->ifra_prefixmask.sin6_addr.s6_addr32[i] =
				    0xffffffff;
			plen = 128;
#else
			return(EINVAL);
#endif
a747 13
	}
	/* lifetime consistency check */
	lt = &ifra->ifra_lifetime;
	if (lt->ia6t_pltime > lt->ia6t_vltime)
		return(EINVAL);
	if (lt->ia6t_vltime == 0) {
		/*
		 * the following log might be noisy, but this is a typical
		 * configuration mistake or a tool's bug.
		 */
		log(LOG_INFO,
		    "in6_update_ifa: valid lifetime is 0 for %s\n",
		    ip6_sprintf(&ifra->ifra_addr.sin6_addr));
d749 2
a750 3
		if (ia == NULL)
			return(0); /* there's nothing to do */
	}
d752 10
a761 40
	/*
	 * If this is a new address, allocate a new ifaddr and link it
	 * into chains.
	 */
	if (ia == NULL) {
		hostIsNew = 1;
		/*
		 * When in6_update_ifa() is called in a process of a received
		 * RA, it is called under an interrupt context.  So, we should
		 * call malloc with M_NOWAIT.
		 */
		ia = (struct in6_ifaddr *) malloc(sizeof(*ia), M_IFADDR,
		    M_NOWAIT);
		if (ia == NULL)
			return (ENOBUFS);
		bzero((caddr_t)ia, sizeof(*ia));
		LIST_INIT(&ia->ia6_memberships);
		/* Initialize the address and masks, and put time stamp */
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
		ia->ia_addr.sin6_family = AF_INET6;
		ia->ia_addr.sin6_len = sizeof(ia->ia_addr);
		ia->ia6_createtime = ia->ia6_updatetime = time_second;
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) != 0) {
			/*
			 * XXX: some functions expect that ifa_dstaddr is not
			 * NULL for p2p interfaces.
			 */
			ia->ia_ifa.ifa_dstaddr =
			    (struct sockaddr *)&ia->ia_dstaddr;
		} else {
			ia->ia_ifa.ifa_dstaddr = NULL;
		}
		ia->ia_ifa.ifa_netmask =
		    (struct sockaddr *)&ia->ia_prefixmask;

		ia->ia_ifp = ifp;
		if ((oia = in6_ifaddr) != NULL) {
			for ( ; oia->ia_next; oia = oia->ia_next)
				continue;
			oia->ia_next = ia;
d763 1
a763 4
			in6_ifaddr = ia;
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, &ia->ia_ifa,
				  ifa_list);
	}
a764 2
	/* set prefix mask */
	if (ifra->ifra_prefixmask.sin6_len) {
d766 30
a795 12
		 * We prohibit changing the prefix length of an existing
		 * address, because
		 * + such an operation should be rare in IPv6, and
		 * + the operation would confuse prefix management.
		 */
		if (ia->ia_prefixmask.sin6_len &&
		    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL) != plen) {
			log(LOG_INFO, "in6_update_ifa: the prefix length of an"
			    " existing (%s) address should not be changed\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr));
			error = EINVAL;
			goto unlink;
a796 64
		ia->ia_prefixmask = ifra->ifra_prefixmask;
	}

	/*
	 * If a new destination address is specified, scrub the old one and
	 * install the new destination.  Note that the interface must be
	 * p2p or loopback (see the check above.) 
	 */
	if (dst6.sin6_family == AF_INET6 &&
	    !IN6_ARE_ADDR_EQUAL(&dst6.sin6_addr, &ia->ia_dstaddr.sin6_addr)) {
		int e;

		if ((ia->ia_flags & IFA_ROUTE) != 0 &&
		    (e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST)) != 0) {
			log(LOG_ERR, "in6_update_ifa: failed to remove "
			    "a route to the old destination: %s\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr));
			/* proceed anyway... */
		} else
			ia->ia_flags &= ~IFA_ROUTE;
		ia->ia_dstaddr = dst6;
	}

	/*
	 * Set lifetimes.  We do not refer to ia6t_expire and ia6t_preferred
	 * to see if the address is deprecated or invalidated, but initialize
	 * these members for applications.
	 */
	ia->ia6_lifetime = ifra->ifra_lifetime;
	if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_expire =
		    time_second + ia->ia6_lifetime.ia6t_vltime;
	} else
		ia->ia6_lifetime.ia6t_expire = 0;
	if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_preferred =
		    time_second + ia->ia6_lifetime.ia6t_pltime;
	} else
		ia->ia6_lifetime.ia6t_preferred = 0;

	/* reset the interface and routing table appropriately. */
	if ((error = in6_ifinit(ifp, ia, &ifra->ifra_addr, hostIsNew)) != 0)
		goto unlink;

	/*
	 * Make the address tentative before joining multicast addresses,
	 * so that corresponding MLD responses would not have a tentative
	 * source address.
	 */
	ia->ia6_flags = ifra->ifra_flags;
	ia->ia6_flags &= ~IN6_IFF_DUPLICATED;	/* safety */
	if (hostIsNew && in6if_do_dad(ifp))
		ia->ia6_flags |= IN6_IFF_TENTATIVE;

	/*
	 * Beyond this point, we should call in6_purgeaddr upon an error,
	 * not just go to unlink. 
	 */

	if ((ifp->if_flags & IFF_MULTICAST) != 0) {
		struct sockaddr_in6 mltaddr, mltmask;
#ifndef SCOPEDROUTING
		u_int32_t zoneid = 0;
#endif
d799 2
a800 39
			/* join solicited multicast addr for new host id */
			struct sockaddr_in6 llsol;

			bzero(&llsol, sizeof(llsol));
			llsol.sin6_family = AF_INET6;
			llsol.sin6_len = sizeof(llsol);
			llsol.sin6_addr.s6_addr16[0] = htons(0xff02);
			llsol.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
			llsol.sin6_addr.s6_addr32[1] = 0;
			llsol.sin6_addr.s6_addr32[2] = htonl(1);
			llsol.sin6_addr.s6_addr32[3] =
			    ifra->ifra_addr.sin6_addr.s6_addr32[3];
			llsol.sin6_addr.s6_addr8[12] = 0xff;
			imm = in6_joingroup(ifp, &llsol.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				log(LOG_ERR, "in6_update_ifa: addmulti "
				    "failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&llsol.sin6_addr), 
				    ifp->if_xname, error);
				goto cleanup;
			}
		}

		bzero(&mltmask, sizeof(mltmask));
		mltmask.sin6_len = sizeof(struct sockaddr_in6);
		mltmask.sin6_family = AF_INET6;
		mltmask.sin6_addr = in6mask32;

		/*
		 * join link-local all-nodes address
		 */
		bzero(&mltaddr, sizeof(mltaddr));
		mltaddr.sin6_len = sizeof(struct sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_linklocal_allnodes;
		mltaddr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
d802 5
a806 18
		/*
		 * XXX: do we really need this automatic routes?
		 * We should probably reconsider this stuff.  Most applications
		 * actually do not need the routes, since they usually specify
		 * the outgoing interface.
		 */
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
		if (rt) {
			/*
			 * 32bit came from "mltmask"
			 * XXX: only works in !SCOPEDROUTING case.
			 */
			if (memcmp(&mltaddr.sin6_addr,
			    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
			    32 / 8)) {
				RTFREE(rt);
				rt = NULL;
			}
a807 2
		if (!rt) {
			struct rt_addrinfo info;
d809 1
a809 31
			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&mltmask;
			info.rti_info[RTAX_IFA] =
			    (struct sockaddr *)&ia->ia_addr;
			/* XXX: we need RTF_CLONING to fake nd6_rtrequest */
			info.rti_flags = RTF_UP | RTF_CLONING;
			error = rtrequest1(RTM_ADD, &info, NULL);
			if (error)
				goto cleanup;
		} else {
			RTFREE(rt);
		}
#ifndef SCOPEDROUTING
		mltaddr.sin6_scope_id = zoneid;	/* XXX */
#endif
		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
		if (imm) {
			LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
			    i6mm_chain);
		} else {
			log(LOG_WARNING,
			    "in6_update_ifa: addmulti failed for "
			    "%s on %s (errno=%d)\n",
			    ip6_sprintf(&mltaddr.sin6_addr), 
			    ifp->if_xname, error);
			goto cleanup;
		}
d811 3
a813 16
		/*
		 * join node information group address
		 */
		if (in6_nigroup(ifp, hostname, hostnamelen, &mltaddr) == 0) {
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				log(LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr), 
				    ifp->if_xname, error);
				/* XXX not very fatal, go on... */
			}
		}
d815 4
a818 49
		if (ifp->if_flags & IFF_LOOPBACK) {
			/*
			 * join node-local all-nodes address, on loopback.
			 * (ff01::1%ifN, and ff01::%ifN/32)
			 */
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;

			/* XXX: again, do we really need the route? */
			rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
			if (rt) {
				/* 32bit came from "mltmask" */
				if (memcmp(&mltaddr.sin6_addr,
				    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
				    32 / 8)) {
					RTFREE(rt);
					rt = NULL;
				}
			}
			if (!rt) {
				struct rt_addrinfo info;

				bzero(&info, sizeof(info));
				info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
				info.rti_info[RTAX_GATEWAY] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_info[RTAX_NETMASK] =
				    (struct sockaddr *)&mltmask;
				info.rti_info[RTAX_IFA] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_flags = RTF_UP | RTF_CLONING;
				error = rtrequest1(RTM_ADD, &info, NULL);
				if (error)
					goto cleanup;
			} else {
				RTFREE(rt);
			}
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				log(LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s "
				    "(errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr), 
				    ifp->if_xname, error);
				goto cleanup;
			}
		}
d821 1
a821 25
	/*
	 * Perform DAD, if needed.
	 * XXX It may be of use, if we can administratively
	 * disable DAD.
	 */
	if (hostIsNew && in6if_do_dad(ifp) &&
	    (ifra->ifra_flags & IN6_IFF_NODAD) == 0)
	{
		nd6_dad_start((struct ifaddr *)ia, NULL);
	}

	return(error);

  unlink:
	/*
	 * XXX: if a change of an existing address failed, keep the entry
	 * anyway.
	 */
	if (hostIsNew)
		in6_unlink_ifa(ia, ifp);
	return(error);

  cleanup:
	in6_purgeaddr(&ia->ia_ifa);
	return error;
d825 1
a825 1
in6_purgeaddr(ifa)
d827 1
d829 1
a829 3
	struct ifnet *ifp = ifa->ifa_ifp;
	struct in6_ifaddr *ia = (struct in6_ifaddr *) ifa;
	struct in6_multi_mship *imm;
d834 1
a834 6
	/*
	 * delete route to the destination of the address being purged.
	 * The interface must be p2p or loopback in this case.
	 */
	if ((ia->ia_flags & IFA_ROUTE) != 0 && ia->ia_dstaddr.sin6_len != 0) {
		int e;
d836 14
a849 11
		if ((e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST))
		    != 0) {
			log(LOG_ERR, "in6_purgeaddr: failed to remove "
			    "a route to the p2p destination: %s on %s, "
			    "errno=%d\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr), ifp->if_xname,
			    e);
			/* proceed anyway... */
		} else
			ia->ia_flags &= ~IFA_ROUTE;
	}
d851 3
a853 9
	/* Remove ownaddr's loopback rtentry, if it exists. */
	in6_ifremloop(&(ia->ia_ifa));

	/*
	 * leave from multicast groups we have joined for the interface
	 */
	while ((imm = ia->ia6_memberships.lh_first) != NULL) {
		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
a855 11
	in6_unlink_ifa(ia, ifp);
}

static void
in6_unlink_ifa(ia, ifp)
	struct in6_ifaddr *ia;
	struct ifnet *ifp;
{
	struct in6_ifaddr *oia;
	int	s = splnet();

d857 1
d867 2
a868 4
		else {
			/* search failed */
			printf("Couldn't unlink in6_ifaddr from in6_ifaddr\n");
		}
d870 2
d873 5
a877 1
	if (oia->ia6_multiaddrs.lh_first != NULL) {
a878 17
	}

	/*
	 * When an autoconfigured address is being removed, release the
	 * reference to the base prefix.  Also, since the release might
	 * affect the status of other (detached) addresses, call
	 * pfxlist_onlink_check().
	 */
	if ((oia->ia6_flags & IN6_IFF_AUTOCONF) != 0) {
		if (oia->ia6_ndpr == NULL) {
			log(LOG_NOTICE, "in6_unlink_ifa: autoconf'ed address "
			    "%p has no prefix\n", oia);
		} else {
			oia->ia6_ndpr->ndpr_refcnt--;
			oia->ia6_flags &= ~IN6_IFF_AUTOCONF;
			oia->ia6_ndpr = NULL;
		}
a879 7
		pfxlist_onlink_check();
	}

	/*
	 * release another refcnt for the link from in6_ifaddr.
	 * Note that we should decrement the refcnt at least once for all *BSD.
	 */
a880 19

	splx(s);
}

void
in6_purgeif(ifp)
	struct ifnet *ifp;
{
	struct ifaddr *ifa, *nifa;

	for (ifa = TAILQ_FIRST(&ifp->if_addrlist); ifa != NULL; ifa = nifa)
	{
		nifa = TAILQ_NEXT(ifa, ifa_list);
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		in6_purgeaddr(ifa);
	}

	in6_ifdetach(ifp);
d992 2
a993 1
		bcopy(iflr->iflr_name, ifra.ifra_name, sizeof(ifra.ifra_name));
d996 1
a996 1
		    ((struct sockaddr *)&iflr->addr)->sa_len);
d1000 1
a1000 1
			    hostid->s6_addr32[2];
d1002 1
a1002 1
			    hostid->s6_addr32[3];
d1007 1
a1007 1
			    ((struct sockaddr *)&iflr->dstaddr)->sa_len);
d1010 1
a1010 1
				    hostid->s6_addr32[2];
d1012 1
a1012 1
				    hostid->s6_addr32[3];
d1016 1
d1018 1
a1018 1
		in6_prefixlen2mask(&ifra.ifra_prefixmask.sin6_addr, prefixlen);
d1021 2
a1022 1
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp, p);
d1035 1
a1035 1
			in6_prefixlen2mask(&mask, iflr->prefixlen);
d1052 1
a1052 1
				cmp = 0;	/* XXX */
d1055 1
a1055 1
				in6_prefixlen2mask(&mask, 128);
a1070 1

d1086 1
d1089 1
a1089 1
				    ia->ia_dstaddr.sin6_len);
d1094 1
a1094 1
			    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
d1105 1
a1105 1
			    sizeof(ifra.ifra_name));
d1108 1
a1108 1
			    ia->ia_addr.sin6_len);
d1111 1
a1111 1
				    ia->ia_dstaddr.sin6_len);
d1117 1
a1117 1
			    ia->ia_prefixmask.sin6_len);
d1120 1
d1122 1
a1122 1
			    ifp, p);
d1127 28
a1154 1
	return EOPNOTSUPP;	/* just for safety */
d1161 2
a1162 2
static int
in6_ifinit(ifp, ia, sin6, newhost)
d1166 1
a1166 1
	int newhost;
d1168 2
a1169 1
	int	error = 0, plen, ifacount = 0;
a1170 1
	struct ifaddr *ifa;
d1172 2
d1179 2
a1180 14
	for (ifa = ifp->if_addrlist.tqh_first; ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ifacount++;
	}

	ia->ia_addr = *sin6;

	if (ifacount <= 1 && ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
d1182 1
a1184 1
	splx(s);
d1186 12
a1197 3
	ia->ia_ifa.ifa_metric = ifp->if_metric;

	/* we could do in(6)_socktrim here, but just omit it at this moment. */
d1199 9
d1209 1
a1209 4
	 * Special case:
	 * If the destination address is specified for a point-to-point
	 * interface, install a route to the destination as an interface
	 * direct route.
d1211 10
a1220 5
	plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL); /* XXX */
	if (plen == 128 && ia->ia_dstaddr.sin6_family == AF_INET6) {
		if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD,
				    RTF_UP | RTF_HOST)) != 0)
			return(error);
a1221 1
	}
d1223 2
a1224 6
	/* Add ownaddr as loopback rtentry, if necessary (ex. on p2p link). */
	if (newhost) {
		/* set the rtrequest function to create llinfo */
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		in6_ifaddloop(&(ia->ia_ifa));
	}
d1366 1
a1366 1
	int	s = splsoftnet();
d1416 1
a1416 1
			    (caddr_t)&ifr);
d1442 1
a1442 1
	int	s = splsoftnet();
a1473 33
struct in6_multi_mship *
in6_joingroup(ifp, addr, errorp)
	struct ifnet *ifp;
	struct in6_addr *addr;
	int *errorp;
{
	struct in6_multi_mship *imm;

	imm = malloc(sizeof(*imm), M_IPMADDR, M_NOWAIT);
	if (!imm) {
		*errorp = ENOBUFS;
		return NULL;
	}
	imm->i6mm_maddr = in6_addmulti(addr, ifp, errorp);
	if (!imm->i6mm_maddr) {
		/* *errorp is alrady set */
		free(imm, M_IPMADDR);
		return NULL;
	}
	return imm;
}

int
in6_leavegroup(imm)
	struct in6_multi_mship *imm;
{

	if (imm->i6mm_maddr)
		in6_delmulti(imm->i6mm_maddr);
	free(imm,  M_IPMADDR);
	return 0;
}

d1583 17
d1649 1
a1649 1
	if (bcmp(&in6addr_loopback, addr, sizeof(*addr) - 1) == 0) {
a1681 21
int
in6_is_addr_deprecated(sa6)
	struct sockaddr_in6 *sa6;
{
	struct in6_ifaddr *ia;

	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IN6_ARE_ADDR_EQUAL(&ia->ia_addr.sin6_addr,
		    &sa6->sin6_addr) &&
#ifdef SCOPEDROUTING
		    ia->ia_addr.sin6_scope_id == sa6->sin6_scope_id &&
#endif
		    (ia->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			return(1); /* true */

		/* XXX: do we still have to go thru the rest of the list? */
	}

	return(0);		/* false */
}

a2122 34
int
in6if_do_dad(ifp)
	struct ifnet *ifp;
{
	if ((ifp->if_flags & IFF_LOOPBACK) != 0)
		return(0);

	switch (ifp->if_type) {
	case IFT_FAITH:
		/*
		 * These interfaces do not have the IFF_LOOPBACK flag,
		 * but loop packets back.  We do not have to do DAD on such
		 * interfaces.  We should even omit it, because loop-backed
		 * NS would confuse the DAD procedure.
		 */
		return(0);
	default:
		/*
		 * Our DAD routine requires the interface up and running.
		 * However, some interfaces can be up before the RUNNING
		 * status.  Additionaly, users may try to assign addresses
		 * before the interface becomes up (or running).
		 * We simply skip DAD in such a case as a work around.
		 * XXX: we should rather mark "tentative" on such addresses,
		 * and do DAD after the interface becomes ready.
		 */
		if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			return(0);

		return(1);
	}
}

a2134 3
		/* this function can be called during ifnet initialization */
		if (!ifp->if_afdata[AF_INET6])
			continue;
d2136 2
a2137 2
		    IN6_LINKMTU(ifp) > maxmtu)
			maxmtu = IN6_LINKMTU(ifp);
d2139 1
a2139 1
	if (maxmtu)	     /* update only when maxmtu is positive */
a2140 35
}

void *
in6_domifattach(ifp)
	struct ifnet *ifp;
{
	struct in6_ifextra *ext;

	ext = (struct in6_ifextra *)malloc(sizeof(*ext), M_IFADDR, M_WAITOK);
	bzero(ext, sizeof(*ext));

	ext->in6_ifstat = (struct in6_ifstat *)malloc(sizeof(struct in6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->in6_ifstat, sizeof(*ext->in6_ifstat));

	ext->icmp6_ifstat =
	    (struct icmp6_ifstat *)malloc(sizeof(struct icmp6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->icmp6_ifstat, sizeof(*ext->icmp6_ifstat));

	ext->nd_ifinfo = nd6_ifattach(ifp);
	return ext;
}

void
in6_domifdetach(ifp, aux)
	struct ifnet *ifp;
	void *aux;
{
	struct in6_ifextra *ext = (struct in6_ifextra *)aux;

	nd6_ifdetach(ext->nd_ifinfo);
	free(ext->in6_ifstat, M_IFADDR);
	free(ext->icmp6_ifstat, M_IFADDR);
	free(ext, M_IFADDR);
@


1.30.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.30.2.1 2002/06/11 03:31:37 art Exp $	*/
d150 1
a150 1

d157 1
a157 1

d336 1
a336 1
			return (-1);
d339 1
a339 1
				return (-1);
d341 1
a341 1

d374 1
a374 1
		return (EOPNOTSUPP);
d383 1
a383 1
			return (EPERM);
d391 1
a391 1
		return (nd6_ioctl(cmd, data, ifp));
d404 1
a404 1
		return (EOPNOTSUPP);
d411 1
a411 1
			return (EPERM);
d465 1
a465 1
				return (EINVAL);	/* link ID contradicts */
d470 1
a470 1
					return (EINVAL);
d486 1
a486 1
		return (EINVAL);
d497 1
a497 1
			return (EADDRNOTAVAIL);
d506 1
a506 1
			return (EAFNOSUPPORT);
d508 1
a508 1
			return (EPERM);
d521 1
a521 1
			return (EADDRNOTAVAIL);
d528 1
a528 1
			return (EPERM);
d530 1
a530 1
			return (EADDRNOTAVAIL);
d553 1
a553 1
			return (EINVAL);
d600 1
a600 1
			if (ia->ia6_lifetime.ia6t_vltime <
d618 1
a618 1
			if (ia->ia6_lifetime.ia6t_pltime <
a646 7
		/* reject read-only flags */
		if ((ifra->ifra_flags & IN6_IFF_DUPLICATED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_DETACHED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_NODAD) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0) {
			return (EINVAL);
		}
d652 1
a652 1
			return (error);
d700 1
a700 1
		/* add the prefix if not yet. */
d707 1
a707 1
				return (error);
d711 1
a711 1
				return (EINVAL); /* XXX panic here? */
d714 2
a715 3

		/* relate the address to the prefix */
		if (ia->ia6_ndpr == NULL) {
d755 8
d764 5
a768 5
		    pr == ia->ia6_ndpr) {
			pr->ndpr_refcnt--;
			if (pr->ndpr_refcnt == 0)
				purgeprefix = 1;
		}
d779 2
a780 2
			return (EOPNOTSUPP);
		return ((*ifp->if_ioctl)(ifp, cmd, data));
d783 1
a783 1
	return (0);
d808 1
a808 1
		return (EINVAL);
d817 1
a817 1
		return (EAFNOSUPPORT);
d823 1
a823 1
		return (EINVAL);
d831 1
a831 1
		return (EINVAL);
d837 1
a837 1
			return (EINVAL);
d864 1
a864 1
				return (EINVAL);	/* ifid contradicts */
d880 3
a882 3
			nd6log((LOG_INFO, "in6_update_ifa: a destination can "
			    "be specified for a p2p or a loopback IF only\n"));
			return (EINVAL);
d885 2
a886 2
			nd6log((LOG_INFO, "in6_update_ifa: prefixlen should "
			    "be 128 when dstaddr is specified\n"));
d895 1
a895 1
			    sizeof(struct sockaddr_in6);
d901 1
a901 1
			return (EINVAL);
d908 1
a908 1
		return (EINVAL);
d914 1
a914 1
		nd6log((LOG_INFO,
d916 1
a916 1
		    ip6_sprintf(&ifra->ifra_addr.sin6_addr)));
d919 1
a919 1
			return (0); /* there's nothing to do */
d978 1
a978 1
			nd6log((LOG_INFO, "in6_update_ifa: the prefix length of an"
d980 1
a980 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d990 1
a990 1
	 * p2p or loopback (see the check above.)
d998 1
a998 1
			nd6log((LOG_ERR, "in6_update_ifa: failed to remove "
d1000 1
a1000 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
a1028 12
	 * configure address flags.
	 */
	ia->ia6_flags = ifra->ifra_flags;
	/*
	 * backward compatibility - if IN6_IFF_DEPRECATED is set from the
	 * userland, make it deprecated.
	 */
	if ((ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0) {
		ia->ia6_lifetime.ia6t_pltime = 0;
		ia->ia6_lifetime.ia6t_preferred = time_second;
	}
	/*
d1033 1
d1040 1
a1040 1
	 * not just go to unlink.
d1068 1
a1068 1
				nd6log((LOG_ERR, "in6_update_ifa: addmulti "
d1070 2
a1071 2
				    ip6_sprintf(&llsol.sin6_addr),
				    ifp->if_xname, error));
d1136 1
a1136 1
			nd6log((LOG_WARNING,
d1139 2
a1140 2
			    ip6_sprintf(&mltaddr.sin6_addr),
			    ifp->if_xname, error));
d1153 1
a1153 1
				nd6log((LOG_WARNING, "in6_update_ifa: "
d1155 2
a1156 2
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
d1202 1
a1202 1
				nd6log((LOG_WARNING, "in6_update_ifa: "
d1205 2
a1206 2
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
d1223 1
a1223 1
	return (error);
d1232 1
a1232 1
	return (error);
d1374 1
a1374 1
 * this is to accommodate address naming scheme other than RFC2374,
d1634 1
a1634 1
		return (error);
d1652 1
a1652 1
			return (error);
d1666 1
a1666 1
	return (error);
d1825 1
a1825 1
			return (NULL);
d1835 1
a1835 1
			return (NULL);
d1859 1
a1859 1
			return (NULL);
d1868 1
a1868 1
	return (in6m);
d1970 1
a1970 1
	return ((struct in6_ifaddr *)ifa);
d1996 1
a1996 1
	return ((struct in6_ifaddr *)ifa);
d2050 1
a2050 1
	return (ip6buf[ip6round]);
d2118 1
a2118 1

d2121 1
a2121 1
		return (-1);	/* XXX: is this an appropriate value? */
d2125 1
a2125 1
		return (ifp->if_index);
d2128 1
a2128 1
		return (0);	/* XXX: invalid. */
d2131 1
a2131 1
		return (0);	/* XXX: treat as global. */
d2148 1
a2148 1
			return (1); /* true */
d2153 1
a2153 1
	return (0);		/* false */
d2191 1
a2191 1
		return (0);
d2198 1
a2198 1
		return (0);
d2201 1
a2201 1
		return (0);
d2203 1
a2203 1
	return (1);
d2243 1
a2243 1

d2246 1
a2246 1
		return (NULL);
d2476 1
a2476 1
	return (ifa_best);
d2536 1
a2536 1
		return (besta);
d2602 1
a2602 1
		return (0);
d2612 1
a2612 1
		return (0);
d2625 1
a2625 1
			return (0);
d2627 1
a2627 1
		return (1);
@


1.29
log
@avoid using malloc() during interupt context for multicast kludge entry.
allocate it on interface initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.28 2001/06/09 06:43:37 angelos Exp $	*/
d181 3
a183 3
	 * We need this because when we refer rt_ifa->ia6_flags in ip6_input,
	 * we assume that the rt_ifa points to the address instead of the
	 * loopback address.
d820 1
d885 1
a885 1
 *	SIOCGLIFADDR: get first address. (???)
d921 1
a921 1
		/*NOTRECHED*/
d929 1
a929 1
		/*FALLTHROUGH*/
d945 1
a945 1
	default: /*shouldn't happen*/
d948 1
a948 1
		/*NOTREACHED*/
a1685 1

a2008 1

@


1.28
log
@No need for net/net_osdep.h
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.27 2001/05/16 12:53:36 ho Exp $	*/
/*	$KAME: in6.c,v 1.176 2001/02/16 12:49:45 itojun Exp $	*/
a89 1
#include <netinet6/nd6.h>
d92 1
d1256 6
a1261 4
		mk = malloc(sizeof(*mk), M_IPMADDR, M_WAITOK);

		LIST_INIT(&mk->mk_head);
		mk->mk_ifp = oia->ia_ifp;
a1268 6

		if (mk->mk_head.lh_first != NULL) {
			LIST_INSERT_HEAD(&in6_mk, mk, mk_entry);
		} else {
			FREE(mk, M_IPMADDR);
		}
d1295 1
a1295 2
			LIST_REMOVE(mk, mk_entry);
			free(mk, M_IPMADDR);
d1299 31
@


1.27
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.26 2001/02/16 15:58:50 itojun Exp $	*/
a95 2

#include <net/net_osdep.h>
@


1.26
log
@cosmetic.  add missing IFAFREE on failure case
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.25 2001/02/16 08:22:05 itojun Exp $	*/
a431 2
			if (ia == NULL)
				return (ENOBUFS);
@


1.25
log
@kill register declarations.  to sync with kame better.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.24 2001/02/07 11:46:22 itojun Exp $	*/
/*	$KAME: in6.c,v 1.109 2000/10/24 07:19:01 jinmei Exp $	*/
d123 3
d389 1
a389 1
				return(EINVAL);	/* ifid is contradict */
d405 1
a405 1
		 * for IPv4, we look for existing in6_ifaddr here to allow
d409 1
a409 1
		 * semantics to be not preferrable.
d577 1
a577 1
				return(EINVAL);	/* ifid is contradict */
d721 1
a721 1
					return(EINVAL);	/* ifid is contradict */
d1296 1
a1296 1
			for (in6m = mk->mk_head.lh_first; in6m; in6m = next){
d1397 1
d1432 1
a1432 1
		if (in6m->in6m_ia)
d1434 1
@


1.24
log
@turn off duplicated address detection when interface address gets deleted.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.23 2001/01/18 06:11:12 itojun Exp $	*/
d1135 2
a1136 2
	register struct ifnet *ifp;
	register struct in6_ifaddr *ia;
d1333 2
a1334 2
	register struct in6_addr *maddr6;
	register struct ifnet *ifp;
d1454 1
a1454 1
	register struct ifaddr *ifa;
d1484 1
a1484 1
	register struct ifaddr *ifa;
d1508 1
a1508 1
register struct in6_addr *addr;
d1511 4
a1514 4
	register int i;
	register char *cp;
	register u_short *a = (u_short *)addr;
	register u_char *d;
d1734 2
a1735 2
	register struct ifnet *oifp;
	register struct in6_addr *dst;
d1985 2
a1986 2
	register struct ifnet *ifp;
	register struct in6_addr *dst;
@


1.23
log
@workaround; be sure to initialize nd6 interface information when IPv6
interface address gets added.  this will avoid presenting EMSGSIZE when
outgoing interface is down (and never brought up).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.22 2000/11/11 00:11:15 itojun Exp $	*/
d830 3
@


1.22
log
@do not panic on "ifconfig lo0 inet6 fe80::1 -alias".  KAME PR 295.
(NOTE: only root can do it)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.21 2000/10/06 05:52:01 itojun Exp $	*/
d765 8
@


1.21
log
@remove now-obsolete SIOCSIFPHY* handling in in{6,}_control.
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.20 2000/07/12 05:18:56 itojun Exp $	*/
/*	$KAME: in6.c,v 1.107 2000/10/06 04:58:30 itojun Exp $	*/
d1129 8
a1136 1
	if (ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT))
@


1.20
log
@correct rtentry reference count in in6_ifloop_request().
if you reconfigure inet6 too much, the reference count can go
into negative by mistake.  KAME in6.c 1.98 -> 1.99.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: in6.c,v 1.99 2000/07/11 17:00:58 jinmei Exp $	*/
a83 4
#include "gif.h"
#if NGIF > 0
#include <net/if_gif.h>
#endif
a322 16
	/*
	 * xxx should prevent processes for link-local addresses?
	 */
#if NGIF > 0
	if (ifp && ifp->if_type == IFT_GIF) {
		switch (cmd) {
		case SIOCSIFPHYADDR_IN6:
			if (!privileged)
				return(EPERM);
			/*fall through*/
		case SIOCGIFPSRCADDR_IN6:
		case SIOCGIFPDSTADDR_IN6:
			return gif_ioctl(ifp, cmd, data);
		}
	}
#endif
@


1.19
log
@use of free(ia) in #if 0.
From: Lennart Augustsson <lennart@@augustsson.net>
@
text
@d1 2
a2 1
/*	$KAME: in6.c,v 1.75 2000/04/12 03:51:29 itojun Exp $	*/
d159 1
a159 1
	struct rtentry *nrt = NULL;
d169 7
a175 1
	/* So we add or remove static loopback entry, here. */
d179 1
a179 1
		  RTF_UP|RTF_HOST, &nrt);
@


1.18
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d653 1
a653 1
			IFAFREE(&ia->ia_ifa);
@


1.17
log
@comment out ifconfig undo code.  they are necessary to avoid memory
leakage, however, was too strict that they disallow multiple address
from same prefix to be assigned (when rtinit returns EEXIST).
we'll need to improve it.
@
text
@d1 1
a1 2
/*	$OpenBSD: in6.c,v 1.16 2000/03/12 06:16:58 itojun Exp $	*/
/*	$KAME: in6.c,v 1.63 2000/03/21 05:18:38 itojun Exp $	*/
a83 1

a86 1

d309 1
a309 1
	struct sockaddr_in6 net;
d350 1
d397 1
a397 2
			}
			else if (sa6->sin6_addr.s6_addr16[1] !=
d434 1
a434 1
#endif 
d584 1
a584 2
			}
			else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
d605 1
a605 1
#endif 
d680 1
a680 1
#endif 
d1266 1
a1266 2
		}
		else {
d1732 1
a1732 1
	int dst_scope =	in6_addrscope(dst), src_scope, best_scope;
a2071 4
	struct sockaddr_dl *sdl;
	int type;
	struct ether_addr ea;
	int off;
d2074 4
a2077 50
	bzero(&ea, sizeof(ea));
	sdl = NULL;

	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr->sa_family == AF_INET6
		 && IN6_IS_ADDR_LINKLOCAL(&((struct sockaddr_in6 *)ifa->ifa_addr)->sin6_addr)) {
			goto dad;
		}
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		break;
	}

	switch (ifp->if_type) {
	case IFT_LOOP:
		in6_ifattach(ifp, IN6_IFT_LOOP, NULL, 1);
		break;
	case IFT_SLIP:
	case IFT_PPP:
	case IFT_DUMMY:
	case IFT_GIF:
	case IFT_FAITH:
		type = IN6_IFT_P2P;
		in6_ifattach(ifp, type, 0, 1);
		break;
	case IFT_ETHER:
	case IFT_FDDI:
	case IFT_ATM:
		type = IN6_IFT_802;
		if (sdl == NULL)
			break;
		off = sdl->sdl_nlen;
		if (bcmp(&sdl->sdl_data[off], &ea, sizeof(ea)) != 0)
			in6_ifattach(ifp, type, LLADDR(sdl), 0);
		break;
	case IFT_ARCNET:
		type = IN6_IFT_ARCNET;
		if (sdl == NULL)
			break;
		off = sdl->sdl_nlen;
		if (sdl->sdl_data[off] != 0)	/* XXX ?: */
			in6_ifattach(ifp, type, LLADDR(sdl), 0);
		break;
	default:
		break;
	}
a2078 1
dad:
@


1.16
log
@undo interface address addition if in6_ifinit fails.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.15 2000/03/02 09:44:28 itojun Exp $	*/
/*	$KAME: in6.c,v 1.55 2000/02/25 00:32:23 itojun Exp $	*/
d631 8
d659 1
d742 1
d745 1
@


1.15
log
@do not add ifa_dstaddr for non-pointopoint interface.  IPv6 has no
concept for "broadcast".
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.14 2000/02/28 11:55:21 itojun Exp $	*/
d314 2
a315 1
	int	error = 0, hostIsNew, prefixIsNew;
d476 4
a479 1
		}
d630 22
a651 1
		return(in6_ifinit(ifp, ia, &ifr->ifr_addr, 1));
d731 1
a731 1
		if (hostIsNew || prefixIsNew)
d733 3
@


1.14
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.13 2000/02/07 06:05:06 itojun Exp $	*/
a450 2
			ia->ia_ifa.ifa_dstaddr
				= (struct sockaddr *)&ia->ia_dstaddr;
d452 2
d456 3
d1079 3
@


1.13
log
@fix ifa refcnt'ing.
fix include file path.
@
text
@d1 3
a3 1
/* $OpenBSD: in6.c,v 1.12 2000/02/04 18:13:35 itojun Exp $ */
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d105 3
a141 16
 * Determine whether an IP6 address is in a reserved set of addresses
 * that may not be forwarded, or whether datagrams to that destination
 * may be forwarded.
 */
int
in6_canforward(src, dst)
	struct	in6_addr *src, *dst;
{
	if (IN6_IS_ADDR_LINKLOCAL(src) ||
	   IN6_IS_ADDR_LINKLOCAL(dst) ||
	   IN6_IS_ADDR_MULTICAST(dst))
		return(0);
	return(1);
}

/*
a237 84
/*
 * Subroutine for in6_ifaddproxy() and in6_ifremproxy().
 * This routine does actual work.
 * call in6_addmulti() when cmd == 1.
 * call in6_delmulti() when cmd == 2.
 */
static int
in6_ifproxy_request(int cmd, struct in6_ifaddr *ia)
{
	int error = 0;

	/* 
	 * If we have an IPv6 dstaddr on adding p2p interface,
	 * join dstaddr's solicited multicast on necessary interface.
	 */
	if ((ia->ia_ifp->if_flags & IFF_POINTOPOINT) &&
	    ia->ia_dstaddr.sin6_family == AF_INET6 &&
	    !IN6_IS_ADDR_LINKLOCAL(&ia->ia_dstaddr.sin6_addr)) {
		struct in6_ifaddr *ia_lan;

		/*
		 * TODO: Join only on some specified interfaces by some
		 * configuration.
		 * Unsolicited Neighbor Advertisements will be also necessary.
		 *
		 * Now, join on interfaces which meets following.
		 *   -IFF_BROADCAST and IFF_MULTICAST
		 *    (NBMA is out of scope)
		 *   -the prefix value is same as p2p dstaddr
		 */
		for (ia_lan = in6_ifaddr; ia_lan; ia_lan = ia_lan->ia_next) {
			struct in6_addr llsol;

			if ((ia_lan->ia_ifp->if_flags &
			     (IFF_BROADCAST|IFF_MULTICAST)) !=
			    (IFF_BROADCAST|IFF_MULTICAST))
				continue;
			if (!IN6_ARE_MASKED_ADDR_EQUAL(IA6_IN6(ia),
						       IA6_IN6(ia_lan),
						       IA6_MASKIN6(ia_lan)))
				continue;
			if (ia_lan->ia_ifp == ia->ia_ifp)
				continue;

			/* init llsol */
			bzero(&llsol, sizeof(struct in6_addr));
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ia_lan->ia_ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr32[3] = 
				ia->ia_dstaddr.sin6_addr.s6_addr32[3];
			llsol.s6_addr8[12] = 0xff;

			if (cmd == 1)
				(void)in6_addmulti(&llsol,
						   ia_lan->ia_ifp,
						   &error);
			else if (cmd == 2) {
				struct in6_multi *in6m;

				IN6_LOOKUP_MULTI(llsol,
						 ia_lan->ia_ifp,
						 in6m);
				if (in6m)
					in6_delmulti(in6m);
			}
		}
	}
	return error;
}

static int
in6_ifaddproxy(struct in6_ifaddr *ia)
{
	return(in6_ifproxy_request(1, ia));
}

static void
in6_ifremproxy(struct in6_ifaddr *ia)
{
	in6_ifproxy_request(2, ia);
}

d297 1
a297 1
#define ia62ifa(ia6)	((struct ifaddr *)(ia6))
d310 4
a313 1
	struct	sockaddr_in6 oldaddr, net;
d351 1
d359 1
d389 1
a389 2
	{

d399 4
a402 4
			else
				if (sa6->sin6_addr.s6_addr16[1] !=
				    htons(ifp->if_index))
					return(EINVAL);	/* ifid is contradict */
a409 3
	}
#if 0
	if (ifra->ifra_addr.sin6_family == AF_INET6) {
a411 3
#else
 	ia = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr);
#endif
d416 8
a423 1
		if (ia == 0)
d428 2
d431 8
a438 1
	case SIOCSIFDSTADDR_IN6:
d441 1
a441 1
		if (ia == 0) {
d447 1
d449 2
d453 4
d471 1
a471 1
			oia->ia_next = ia;
d497 1
a497 1
		if (ia == 0)
d506 1
a506 1
		if (ia == 0)
d541 1
a541 1
 
d567 1
d581 1
a581 2
			else
				if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
d583 3
a585 3
					ia->ia_dstaddr = oldaddr;
					return(EINVAL);	/* ifid is contradict */
				}
d602 1
d625 1
d647 1
d660 16
d695 4
a699 6
				else
					if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
					    htons(ifp->if_index)) {
						ia->ia_dstaddr = oldaddr;
						return(EINVAL);	/* ifid is contradict */
					}
d703 1
a703 2
		if (ifra->ifra_addr.sin6_family == AF_INET6 &&
		    (hostIsNew || prefixIsNew))
d705 1
a705 2
		if (ifra->ifra_addr.sin6_family == AF_INET6
		    && hostIsNew && (ifp->if_flags & IFF_MULTICAST)) {
a723 8
		/* Join dstaddr's solicited multicast if necessary. */
		if (nd6_proxyall && hostIsNew) {
			int error_local;

			error_local = in6_ifaddproxy(ia);
			if (error == 0)
				error = error_local;
		}
d742 1
a742 1
		 * Perform DAD, if needed. 
d784 1
a784 1
		if (ifp == 0 || ifp->if_ioctl == 0)
a818 3
	/* Leave dstaddr's solicited multicast if necessary. */
	if (nd6_proxyall)
		in6_ifremproxy(ia);
d935 1
a935 1
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp);
d1159 1
a1159 1
	/* xxx 
d1283 1
a1283 1
 * Add an address to the list of IP6 multicast addresses for a 
d1387 1
a1387 1
		 * Notify the network driver to update its multicast 
d1405 1
a1405 1
in6ifa_ifpforlinklocal(ifp)
d1407 1
d1419 4
a1422 1
		if (IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa)))
d1424 1
d1556 1
a1556 1
		/* 
d1586 23
a1686 1

d1688 2
a1689 2
in6_ifawithscope(ifp, dst)
	register struct ifnet *ifp;
d1692 2
a1693 1
	int dst_scope =	in6_addrscope(dst), blen = -1, tlen;
d1695 7
a1701 4
	struct in6_ifaddr *besta = NULL, *ia;
	struct in6_ifaddr *dep[2];	/*last-resort: deprecated*/

	dep[0] = dep[1] = NULL;
d1704 3
a1706 4
	 * We first look for addresses in the same scope. 
	 * If there is one, return it.
	 * If two or more, return one which matches the dst longest.
	 * If none, return one of global addresses assigned other ifs.
d1708 1
a1708 3
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
d1710 5
a1714 1
		if (ifa->ifa_addr->sa_family != AF_INET6)
a1715 12
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_ANYCAST)
		        continue; /* XXX: is there any case to allow anycast?*/
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_NOTREADY)
			continue; /* don't use this interface */
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DETACHED)
			continue;
		if (((struct in6_ifaddr *)ifa)->ia6_flags &
		    IN6_IFF_DEPRECATED) {
			if (ip6_use_deprecated)
				dep[0] = (struct in6_ifaddr *)ifa;
			continue;
		}
d1717 172
a1888 1
		if (dst_scope == in6_addrscope(IFA_IN6(ifa))) {
d1890 3
a1892 1
			 * call in6_matchlen() as few as possible
d1894 15
a1908 10
			if (besta) {
				if (blen == -1)
					blen = in6_matchlen(&besta->ia_addr.sin6_addr, dst);
				tlen = in6_matchlen(IFA_IN6(ifa), dst);
				if (tlen > blen) {
					blen = tlen;
					besta = (struct in6_ifaddr *)ifa;
				}
			} else 
				besta = (struct in6_ifaddr *)ifa;
a1910 2
	if (besta)
		return besta;
d1912 16
a1927 17
	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IPV6_ADDR_SCOPE_GLOBAL != 
		    in6_addrscope(&(ia->ia_addr.sin6_addr)))
			continue;
		/* XXX: is there any case to allow anycast? */
		if ((ia->ia6_flags & IN6_IFF_ANYCAST) != 0)
			continue;
		if ((ia->ia6_flags & IN6_IFF_NOTREADY) != 0)
			continue;
		if ((ia->ia6_flags & IN6_IFF_DETACHED) != 0)
			continue;
		if ((ia->ia6_flags & IN6_IFF_DEPRECATED) != 0) {
			if (ip6_use_deprecated)
				dep[1] = (struct in6_ifaddr *)ifa;
			continue;
		}
		return ia;
d1930 1
a1930 7
	/* use the last-resort values, that are, deprecated addresses */
	if (dep[0])
		return dep[0];
	if (dep[1])
		return dep[1];

	return NULL;
d1951 1
a1951 1
	 * We first look for addresses in the same scope. 
d1963 1
a1963 1
			continue; /* XXX: is there any case to allow anycast?*/
d1968 1
a1968 2
		if (((struct in6_ifaddr *)ifa)->ia6_flags &
		    IN6_IFF_DEPRECATED) {
d1986 1
a1986 1
			} else 
d2000 1
a2000 1
			continue; /* XXX: is there any case to allow anycast?*/
d2005 1
a2005 2
		if (((struct in6_ifaddr *)ifa)->ia6_flags &
		    IN6_IFF_DEPRECATED) {
a2121 1

@


1.13.2.1
log
@Sync with -current
@
text
@d1 1
a1 3
/*	$OpenBSD$	*/
/*	$KAME: in6.c,v 1.55 2000/02/25 00:32:23 itojun Exp $	*/

d5 1
a5 1
 *
d17 1
a17 1
 *
a102 3
/* backward compatibility for a while... */
#define COMPAT_IN6IFIOCTL

d137 16
d249 84
d392 1
a392 1
#define ia62ifa(ia6)	(&((ia6)->ia_ifa))
d405 1
a405 4
	struct	sockaddr_in6 oldaddr;
#ifdef COMPAT_IN6IFIOCTL
	struct sockaddr_in6 net;
#endif
a442 1
	case SIOCSDEFIFACE_IN6:
a449 1
	case SIOCGDEFIFACE_IN6:
d479 2
a480 1
	if (ifra->ifra_addr.sin6_family == AF_INET6) { /* XXX */
d490 4
a493 4
			else if (sa6->sin6_addr.s6_addr16[1] !=
				    htons(ifp->if_index)) {
				return(EINVAL);	/* ifid is contradict */
			}
d501 3
d506 3
d513 1
a513 8
		/*
		 * for IPv4, we look for existing in6_ifaddr here to allow
		 * "ifconfig if0 delete" to remove first IPv4 address on the
		 * interface.  For IPv6, as the spec allow multiple interface
		 * address from the day one, we consider "remove the first one"
		 * semantics to be not preferrable.
		 */
		if (ia == NULL)
d518 1
a518 1
#ifdef COMPAT_IN6IFIOCTL
a519 9
	case SIOCSIFNETMASK_IN6:
		/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are not suitable
		 * and should be unused.
		 */
#endif 
		if (ifra->ifra_addr.sin6_family != AF_INET6)
			return(EAFNOSUPPORT);
d522 1
a522 1
		if (ia == NULL) {
a527 1
			/* Initialize the address and masks */
a528 2
			ia->ia_addr.sin6_family = AF_INET6;
			ia->ia_addr.sin6_len = sizeof(ia->ia_addr);
a530 4
			if (ifp->if_flags & IFF_POINTOPOINT) {
				ia->ia_dstaddr.sin6_family = AF_INET6;
				ia->ia_dstaddr.sin6_len = sizeof(ia->ia_dstaddr);
			}
d545 1
a545 1
			ia->ia_ifa.ifa_refcnt++;
d571 1
a571 1
		if (ia == NULL)
d580 1
a580 1
		if (ia == NULL)
d615 1
a615 1

a640 1
#ifdef COMPAT_IN6IFIOCTL		/* should be unused */
d654 2
a655 1
			else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
d657 3
a659 3
				ia->ia_dstaddr = oldaddr;
				return(EINVAL);	/* ifid is contradict */
			}
a675 1
#endif 
a697 1
#ifdef COMPAT_IN6IFIOCTL		/* XXX should be unused */
a718 1
#endif 
a730 16
		/* Validate address families: */
		/*
		 * The destination address for a p2p link must have a family
		 * of AF_UNSPEC or AF_INET6.
		 */
		if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
		    ifra->ifra_dstaddr.sin6_family != AF_INET6 &&
		    ifra->ifra_dstaddr.sin6_family != AF_UNSPEC)
			return(EAFNOSUPPORT);
		/*
		 * The prefixmask must have a family of AF_UNSPEC or AF_INET6.
		 */
		if (ifra->ifra_prefixmask.sin6_family != AF_INET6 &&
		    ifra->ifra_prefixmask.sin6_family != AF_UNSPEC)
			return(EAFNOSUPPORT);

d750 3
a752 1
				} else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
d754 3
a756 3
					ia->ia_dstaddr = oldaddr;
					return(EINVAL);	/* ifid is contradict */
				}
d760 2
a761 1
		if (hostIsNew || prefixIsNew)
d763 2
a764 1
		if (hostIsNew && (ifp->if_flags & IFF_MULTICAST)) {
d783 8
d809 1
a809 1
		 * Perform DAD, if needed.
d851 1
a851 1
		if (ifp == NULL || ifp->if_ioctl == 0)
d886 3
d1005 1
a1005 1
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp, 0);
d1229 1
a1229 1
	/* xxx
d1353 1
a1353 1
 * Add an address to the list of IP6 multicast addresses for a
d1457 1
a1457 1
		 * Notify the network driver to update its multicast
d1475 1
a1475 1
in6ifa_ifpforlinklocal(ifp, ignoreflags)
a1476 1
	int ignoreflags;
d1488 1
a1488 4
		if (IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa))) {
			if ((((struct in6_ifaddr *)ifa)->ia6_flags &
			     ignoreflags) != 0)
				continue;
a1489 1
		}
d1621 1
a1621 1
		/*
a1650 23
int
in6_addr2scopeid(ifp, addr)
	struct ifnet *ifp;	/* must not be NULL */
	struct in6_addr *addr;	/* must not be NULL */
{
	int scope = in6_addrscope(addr);
		
	switch(scope) {
	case IPV6_ADDR_SCOPE_NODELOCAL:
		return(-1);	/* XXX: is this an appropriate value? */

	case IPV6_ADDR_SCOPE_LINKLOCAL:
		/* XXX: we do not distinguish between a link and an I/F. */
		return(ifp->if_index);

	case IPV6_ADDR_SCOPE_SITELOCAL:
		return(0);	/* XXX: invalid. */

	default:
		return(0);	/* XXX: treat as global. */
	}
}

d1729 1
d1731 2
a1732 2
in6_ifawithscope(oifp, dst)
	register struct ifnet *oifp;
d1735 1
a1735 2
	int dst_scope =	in6_addrscope(dst), src_scope, best_scope;
	int blen = -1;
d1737 4
a1740 7
	struct ifnet *ifp;
	struct in6_ifaddr *ifa_best = NULL;
	
	if (oifp == NULL) {
		printf("in6_ifawithscope: output interface is not specified\n");
		return(NULL);
	}
d1743 4
a1746 3
	 * We search for all addresses on all interfaces from the beginning.
	 * Comparing an interface with the outgoing interface will be done
	 * only at the final stage of tiebreaking.
d1748 3
a1750 1
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
d1752 12
a1763 5
		/*
		 * We can never take an address that breaks the scope zone
		 * of the destination.
		 */
		if (in6_addr2scopeid(ifp, dst) != in6_addr2scopeid(oifp, dst))
d1765 1
d1767 1
a1767 24
		for (ifa = ifp->if_addrlist.tqh_first; ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
			int tlen = -1, dscopecmp, bscopecmp, matchcmp;

			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;

			src_scope = in6_addrscope(IFA_IN6(ifa));

#ifdef ADDRSELECT_DEBUG		/* should be removed after stabilization */
			dscopecmp = IN6_ARE_SCOPE_CMP(src_scope, dst_scope);
			printf("in6_ifawithscope: dst=%s bestaddr=%s, "
			       "newaddr=%s, scope=%x, dcmp=%d, bcmp=%d, "
			       "matchlen=%d, flgs=%x\n",
			       ip6_sprintf(dst),
			       ifa_best ? ip6_sprintf(&ifa_best->ia_addr.sin6_addr) : "none",
			       ip6_sprintf(IFA_IN6(ifa)), src_scope,
			       dscopecmp,
			       ifa_best ? IN6_ARE_SCOPE_CMP(src_scope, best_scope) : -1,
			       in6_matchlen(IFA_IN6(ifa), dst),
			       ((struct in6_ifaddr *)ifa)->ia6_flags);
#endif

d1769 1
a1769 2
			 * Don't use an address before completing DAD
			 * nor a duplicated address.
d1771 14
a1784 3
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_NOTREADY)
				continue;
d1786 15
a1800 160
			/* XXX: is there any case to allow anycasts? */
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_ANYCAST)
				continue;

			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_DETACHED)
				continue;

			/*
			 * If this is the first address we find,
			 * keep it anyway.
			 */
			if (ifa_best == NULL)
				goto replace;

			/*
			 * ifa_best is never NULL beyond this line except
			 * within the block labeled "replace".
			 */

			/*
			 * If ifa_best has a smaller scope than dst and
			 * the current address has a larger one than
			 * (or equal to) dst, always replace ifa_best.
			 * Also, if the current address has a smaller scope
			 * than dst, ignore it unless ifa_best also has a
			 * smaller scope.
			 */
			if (IN6_ARE_SCOPE_CMP(best_scope, dst_scope) < 0 &&
			    IN6_ARE_SCOPE_CMP(src_scope, dst_scope) >= 0)
				goto replace;
			if (IN6_ARE_SCOPE_CMP(src_scope, dst_scope) < 0 &&
			    IN6_ARE_SCOPE_CMP(best_scope, dst_scope) >= 0)
				continue;

			/*
			 * A deprecated address SHOULD NOT be used in new
			 * communications if an alternate (non-deprecated)
			 * address is available and has sufficient scope.
			 * RFC 2462, Section 5.5.4.
			 */
			if (((struct in6_ifaddr *)ifa)->ia6_flags &
			    IN6_IFF_DEPRECATED) {
				/*
				 * Ignore any deprecated addresses if
				 * specified by configuration.
				 */
				if (!ip6_use_deprecated)
					continue;

				/*
				 * If we have already found a non-deprecated
				 * candidate, just ignore deprecated addresses.
				 */
				if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED)
				    == 0)
					continue;
			}

			/*
			 * A non-deprecated address is always preferred
			 * to a deprecated one regardless of scopes and
			 * address matching.
			 */
			if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED) &&
			    (((struct in6_ifaddr *)ifa)->ia6_flags &
			     IN6_IFF_DEPRECATED) == 0)
				goto replace;

			/*
			 * At this point, we have two cases:
			 * 1. we are looking at a non-deprecated address,
			 *    and ifa_best is also non-deprecated.
			 * 2. we are looking at a deprecated address,
			 *    and ifa_best is also deprecated.
			 * Also, we do not have to consider a case where
			 * the scope of if_best is larger(smaller) than dst and
			 * the scope of the current address is smaller(larger)
			 * than dst. Such a case has already been covered.
			 * Tiebreaking is done according to the following
			 * items:
			 * - the scope comparison between the address and
			 *   dst (dscopecmp)
			 * - the scope comparison between the address and
			 *   ifa_best (bscopecmp)
			 * - if the address match dst longer than ifa_best
			 *   (matchcmp)
			 * - if the address is on the outgoing I/F (outI/F)
			 *
			 * Roughly speaking, the selection policy is
			 * - the most important item is scope. The same scope
			 *   is best. Then search for a larger scope.
			 *   Smaller scopes are the last resort.
			 * - A deprecated address is chosen only when we have
			 *   no address that has an enough scope, but is
			 *   prefered to any addresses of smaller scopes.
			 * - Longest address match against dst is considered
			 *   only for addresses that has the same scope of dst.
			 * - If there is no other reasons to choose one,
			 *   addresses on the outgoing I/F are preferred.
			 *
			 * The precise decision table is as follows:
			 * dscopecmp bscopecmp matchcmp outI/F | replace?
			 *    !equal     equal      N/A    Yes |      Yes (1)
			 *    !equal     equal      N/A     No |       No (2)
			 *    larger    larger      N/A    N/A |       No (3)
			 *    larger   smaller      N/A    N/A |      Yes (4)
			 *   smaller    larger      N/A    N/A |      Yes (5)
			 *   smaller   smaller      N/A    N/A |       No (6)
			 *     equal   smaller      N/A    N/A |      Yes (7)
			 *     equal    larger       (already done)
			 *     equal     equal   larger    N/A |      Yes (8)
			 *     equal     equal  smaller    N/A |       No (9)
			 *     equal     equal    equal    Yes |      Yes (a)
			 *     eaual     eqaul    equal     No |       No (b)
			 */
			dscopecmp = IN6_ARE_SCOPE_CMP(src_scope, dst_scope);
			bscopecmp = IN6_ARE_SCOPE_CMP(src_scope, best_scope);

			if (dscopecmp && bscopecmp == 0) {
				if (oifp == ifp) /* (1) */
					goto replace;
				continue; /* (2) */
			}
			if (dscopecmp > 0) {
				if (bscopecmp > 0) /* (3) */
					continue;
				goto replace; /* (4) */
			}
			if (dscopecmp < 0) {
				if (bscopecmp > 0) /* (5) */
					goto replace;
				continue; /* (6) */
			}

			/* now dscopecmp must be 0 */
			if (bscopecmp < 0)
				goto replace; /* (7) */

			/*
			 * At last both dscopecmp and bscopecmp must be 0.
			 * We need address matching against dst for
			 * tiebreaking.
			 */
			tlen = in6_matchlen(IFA_IN6(ifa), dst);
			matchcmp = tlen - blen;
			if (matchcmp > 0) /* (8) */
				goto replace;
			if (matchcmp < 0) /* (9) */
				continue;
			if (oifp == ifp) /* (a) */
				goto replace;
			continue; /* (b) */

		  replace:
			ifa_best = (struct in6_ifaddr *)ifa;
			blen = tlen >= 0 ? tlen :
				in6_matchlen(IFA_IN6(ifa), dst);
			best_scope = in6_addrscope(&ifa_best->ia_addr.sin6_addr);
d1802 1
d1805 5
a1809 8
	/* count statistics for future improvements */
	if (ifa_best == NULL)
		ip6stat.ip6s_sources_none++;
	else {
		if (oifp == ifa_best->ia_ifp)
			ip6stat.ip6s_sources_sameif[best_scope]++;
		else
			ip6stat.ip6s_sources_otherif[best_scope]++;
d1811 1
a1811 10
		if (best_scope == dst_scope)
			ip6stat.ip6s_sources_samescope[best_scope]++;
		else
			ip6stat.ip6s_sources_otherscope[best_scope]++;

		if ((ifa_best->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			ip6stat.ip6s_sources_deprecated[best_scope]++;
	}

	return(ifa_best);
d1832 1
a1832 1
	 * We first look for addresses in the same scope.
d1844 1
a1844 1
			continue; /* XXX: is there any case to allow anycast? */
d1849 2
a1850 1
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
d1868 1
a1868 1
			} else
d1882 1
a1882 1
			continue; /* XXX: is there any case to allow anycast? */
d1887 2
a1888 1
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
d2005 1
@


1.13.2.2
log
@Sync with -current
@
text
@d2 1
a2 1
/*	$KAME: in6.c,v 1.63 2000/03/21 05:18:38 itojun Exp $	*/
d314 1
a314 2
	int error = 0, hostIsNew, prefixIsNew;
	int newifaddr;
d451 2
a453 2
				ia->ia_ifa.ifa_dstaddr
					= (struct sockaddr *)&ia->ia_dstaddr;
a455 3
			} else {
				ia->ia_ifa.ifa_dstaddr = NULL;
				bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
d472 1
a472 4

			newifaddr = 1;
		} else
			newifaddr = 0;
d623 1
a623 31
		error = in6_ifinit(ifp, ia, &ifr->ifr_addr, 1);
#if 0
		/*
		 * the code chokes if we are to assign multiple addresses with
		 * the same address prefix (rtinit() will return EEXIST, which
		 * is not fatal actually).  we will get memory leak if we
		 * don't do it.
		 * -> we may want to hide EEXIST from rtinit().
		 */
  undo:
		if (error && newifaddr) {
			TAILQ_REMOVE(&ifp->if_addrlist, &ia->ia_ifa, ifa_list);
			IFAFREE(&ia->ia_ifa);

			oia = ia;
			if (oia == (ia = in6_ifaddr))
				in6_ifaddr = ia->ia_next;
			else {
				while (ia->ia_next && (ia->ia_next != oia))
					ia = ia->ia_next;
				if (ia->ia_next)
					ia->ia_next = oia->ia_next;
				else {
					printf("Didn't unlink in6_ifaddr "
					    "from list\n");
				}
			}
			IFAFREE(&ia->ia_ifa);
		}
#endif
		return error;
d703 1
a703 1
		if (hostIsNew || prefixIsNew) {
a704 5
#if 0
			if (error)
				goto undo;
#endif
		}
a1075 3
			} else {
				bzero(&ifra.ifra_dstaddr,
				    sizeof(ifra.ifra_dstaddr));
@


1.13.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.26 2001/02/16 15:58:50 itojun Exp $	*/
/*	$KAME: in6.c,v 1.176 2001/02/16 12:49:45 itojun Exp $	*/
d84 6
a128 3
const struct sockaddr_in6 sa6_any = {sizeof(sa6_any), AF_INET6,
				     0, 0, IN6ADDR_ANY_INIT, 0};

d161 1
a161 1
	struct rtentry *nrt = NULL, **nrtp = NULL;
d171 1
a171 7
	/*
	 * So we add or remove static loopback entry, here.
	 * This request for deletion could fail, e.g. when we remove
	 * an address right after adding it.
	 */
	if (cmd == RTM_ADD)
		nrtp = &nrt;
d175 1
a175 1
		  RTF_UP|RTF_HOST, nrtp);
d312 1
a312 1
	struct	sockaddr_in6 net;
d323 16
a352 1
	case SIOCSIFINFO_FLAGS:
d399 2
a400 1
			} else if (sa6->sin6_addr.s6_addr16[1] !=
d402 1
a402 1
				return(EINVAL);	/* ifid contradicts */
d418 1
a418 1
		 * for IPv4, we look for existing in_ifaddr here to allow
d422 1
a422 1
		 * semantics to be not preferable.
d437 1
a437 1
#endif
d587 2
a588 1
			} else if (ia->ia_dstaddr.sin6_addr.s6_addr16[1] !=
d591 1
a591 1
				return(EINVAL);	/* ifid contradicts */
d609 1
a609 1
#endif
d657 1
a657 1
			IFAFREE(&oia->ia_ifa);
d684 1
a684 1
#endif
d735 1
a735 1
					return(EINVAL);	/* ifid contradicts */
a783 8
		 * make sure to initialize ND6 information.  this is to
		 * workaround issues with interfaces with IPv6 addresses,
		 * which have never brought # up.  we are assuming that it is
		 * safe to nd6_ifattach multiple times.
		 */
		nd6_ifattach(ifp);

		/*
a839 3
	/* stop DAD processing */
	nd6_dad_stop(ifa);

d1141 2
a1142 2
	struct ifnet *ifp;
	struct in6_ifaddr *ia;
d1146 1
a1146 8
	/*
	 * We should check the existence of dstaddr, because link-local
	 * addresses can be configured without particular destinations
	 * even on point-to-point or loopback interfaces.
	 * In this case, kernel would panic in rtinit()...
	 */
	if (ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT) &&
	    (ia->ia_ifa.ifa_dstaddr != NULL))
d1270 2
a1271 1
		} else {
d1293 1
a1293 1
			for (in6m = mk->mk_head.lh_first; in6m; in6m = next) {
d1333 2
a1334 2
	struct in6_addr *maddr6;
	struct ifnet *ifp;
a1393 1
			IFAFREE(&ia->ia_ifa);
d1428 1
a1428 1
		if (in6m->in6m_ia) {
a1429 1
		}
d1454 1
a1454 1
	struct ifaddr *ifa;
d1484 1
a1484 1
	struct ifaddr *ifa;
d1508 1
a1508 1
	struct in6_addr *addr;
d1511 4
a1514 4
	int i;
	char *cp;
	u_short *a = (u_short *)addr;
	u_char *d;
d1734 2
a1735 2
	struct ifnet *oifp;
	struct in6_addr *dst;
d1737 1
a1737 1
	int dst_scope =	in6_addrscope(dst), src_scope, best_scope = 0;
d1985 2
a1986 2
	struct ifnet *ifp;
	struct in6_addr *dst;
d2077 4
d2083 50
a2132 4
	/*
	 * special cases, like 6to4, are handled in in6_ifattach
	 */
	in6_ifattach(ifp, NULL);
d2134 1
@


1.13.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.13.2.3 2001/05/14 22:40:17 niklas Exp $	*/
d97 2
d432 2
@


1.13.2.5
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.c,v 1.13.2.4 2001/07/04 10:55:18 niklas Exp $	*/
/*	$KAME: in6.c,v 1.198 2001/07/18 09:12:38 itojun Exp $	*/
d90 1
a92 1
#include <netinet6/nd6.h>
d1256 4
a1259 6
		for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
			if (mk->mk_ifp == oia->ia_ifp)
				break;
		}
		if (mk == NULL) /* this should not happen! */
			panic("in6_savemkludge: no kludge space");
d1267 6
d1299 2
a1300 1
			LIST_INIT(&mk->mk_head);
a1303 31
}

/*
 * Allocate space for the kludge at interface initialization time.
 * Formerly, we dynamically allocated the space in in6_savemkludge() with
 * malloc(M_WAITOK).  However, it was wrong since the function could be called
 * under an interrupt context (software timer on address lifetime expiration).
 * Also, we cannot just give up allocating the strucutre, since the group
 * membership structure is very complex and we need to keep it anyway.
 * Of course, this function MUST NOT be called under an interrupt context.
 * Specifically, it is expected to be called only from in6_ifattach(), though
 * it is a global function.
 */
void
in6_createmkludge(ifp)
	struct ifnet *ifp;
{
	struct multi6_kludge *mk;

	for (mk = in6_mk.lh_first; mk; mk = mk->mk_entry.le_next) {
		/* If we've already had one, do not allocate. */
		if (mk->mk_ifp == ifp)
			return;
	}

	mk = malloc(sizeof(*mk), M_IPMADDR, M_WAITOK);

	bzero(mk, sizeof(*mk));
	LIST_INIT(&mk->mk_head);
	mk->mk_ifp = ifp;
	LIST_INSERT_HEAD(&in6_mk, mk, mk_entry);
@


1.13.2.6
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d181 3
a183 3
	 * We need this because when we refer to rt_ifa->ia6_flags in
	 * ip6_input, we assume that the rt_ifa points to the address instead
	 * of the loopback address.
a819 1

d884 1
a884 1
 *	SIOCGLIFADDR: get first address. (?)
d920 1
a920 1
		/* NOTREACHED */
d928 1
a928 1
		/* FALLTHROUGH */
d944 1
a944 1
	default: /* shouldn't happen */
d947 1
a947 1
		/* NOTREACHED */
d1685 1
d2009 1
@


1.13.2.7
log
@Merge in -current from roughly a week ago
@
text
@d118 2
a119 2
static int in6_lifaddr_ioctl(struct socket *, u_long, caddr_t,
	struct ifnet *, struct proc *);
@


1.13.2.8
log
@Sync the SMP branch with 3.3
@
text
@a119 3
static int in6_ifinit(struct ifnet *, struct in6_ifaddr *,
	struct sockaddr_in6 *, int);
static void in6_unlink_ifa(struct in6_ifaddr *, struct ifnet *);
d137 11
d156 2
a157 3
	struct rtentry *nrt = NULL;
	int e;

d160 3
a162 2
	lo_sa.sin6_family = all1_sa.sin6_family = AF_INET6;
	lo_sa.sin6_len = all1_sa.sin6_len = sizeof(struct sockaddr_in6);
d165 1
a165 1

d167 10
a176 16
	 * We specify the address itself as the gateway, and set the
	 * RTF_LLINFO flag, so that the corresponding host route would have
	 * the flag, and thus applications that assume traditional behavior
	 * would be happy.  Note that we assume the caller of the function
	 * (probably implicitly) set nd6_rtrequest() to ifa->ifa_rtrequest,
	 * which changes the outgoing interface to the loopback interface.
	 */
	e = rtrequest(cmd, ifa->ifa_addr, ifa->ifa_addr,
	    (struct sockaddr *)&all1_sa, RTF_UP|RTF_HOST|RTF_LLINFO, &nrt);
	if (e != 0) {
		log(LOG_ERR, "in6_ifloop_request: "
		    "%s operation failed for %s (errno=%d)\n",
		    cmd == RTM_ADD ? "ADD" : "DELETE",
		    ip6_sprintf(&((struct in6_ifaddr *)ifa)->ia_addr.sin6_addr),
		    e);
	}
d190 2
a191 20

	/*
	 * Report the addition/removal of the address to the routing socket.
	 * XXX: since we called rtinit for a p2p interface with a destination,
	 *      we end up reporting twice in such a case.  Should we rather
	 *      omit the second report?
	 */
	if (nrt) {
		rt_newaddrmsg(cmd, ifa, e, nrt);
		if (cmd == RTM_DELETE) {
			if (nrt->rt_refcnt <= 0) {
				/* XXX: we should free the entry ourselves. */
				nrt->rt_refcnt++;
				rtfree(nrt);
			}
		} else {
			/* the cmd must be RTM_ADD here */
			nrt->rt_refcnt--;
		}
	}
d195 3
a197 5
 * Add ownaddr as loopback rtentry.  We previously add the route only if
 * necessary (ex. on a p2p link).  However, since we now manage addresses
 * separately from prefixes, we should always add the route.  We can't
 * rely on the cloning mechanism from the corresponding interface route
 * any more.
d202 2
a203 1
	struct rtentry *rt;
d205 7
a211 7
	/* If there is no loopback entry, allocate one. */
	rt = rtalloc1(ifa->ifa_addr, 0);
	if (rt == NULL || (rt->rt_flags & RTF_HOST) == 0 ||
	    (rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0)
		in6_ifloop_request(RTM_ADD, ifa);
	if (rt)
		rt->rt_refcnt--;
d221 3
a223 3
	struct in6_ifaddr *ia;
	struct rtentry *rt;
	int ia_count = 0;
d225 8
a232 20
	/*
	 * Some of BSD variants do not remove cloned routes
	 * from an interface direct route, when removing the direct route
	 * (see comments in net/net_osdep.h).  Even for variants that do remove
	 * cloned routes, they could fail to remove the cloned routes when
	 * we handle multple addresses that share a common prefix.
	 * So, we should remove the route corresponding to the deleted address.
	 */

	/*
	 * Delete the entry only if exact one ifa exists.  More than one ifa
	 * can exist if we assign a same single address to multiple
	 * (probably p2p) interfaces.
	 * XXX: we should avoid such a configuration in IPv6...
	 */
	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &ia->ia_addr.sin6_addr)) {
			ia_count++;
			if (ia_count > 1)
				break;
d234 1
a234 15
	}

	if (ia_count == 1) {
		/*
		 * Before deleting, check if a corresponding loopbacked host
		 * route surely exists.  With this check, we can avoid to
		 * delete an interface direct route whose destination is same
		 * as the address being removed.  This can happen when removing
		 * a subnet-router anycast address on an interface attahced
		 * to a shared medium.
		 */
		rt = rtalloc1(ifa->ifa_addr, 0);
		if (rt != NULL && (rt->rt_flags & RTF_HOST) != 0 &&
		    (rt->rt_ifp->if_flags & IFF_LOOPBACK) != 0) {
			rt->rt_refcnt--;
a235 1
		}
d264 1
a264 1
in6_mask2len(mask, lim0)
a265 1
	u_char *lim0;
d267 1
a267 2
	int x = 0, y;
	u_char *lim = lim0, *p;
d269 2
a270 5
	/* ignore the scope_id part */
	if (lim0 == NULL || lim0 - (u_char *)mask > sizeof(*mask))
		lim = (u_char *)mask + sizeof(*mask);
	for (p = (u_char *)mask; p < lim; x++, p++) {
		if (*p != 0xff)
d274 1
a274 1
	if (p < lim) {
d276 1
a276 1
			if ((*p & (0x80 >> y)) == 0)
d280 2
d283 6
a288 11
	/*
	 * when the limit pointer is given, do a stricter check on the
	 * remaining bits.
	 */
	if (p < lim) {
		if (y != 0 && (*p & (0x00ff >> y)) != 0)
			return (-1);
		for (p = p + 1; p < lim; p++)
			if (*p != 0)
				return (-1);
	}
d290 5
a294 1
	return x * 8 + y;
d309 1
a309 1
	struct	in6_ifaddr *ia = NULL;
d311 6
a316 1
	struct sockaddr_in6 *sa6;
d330 2
a331 2
	if (ifp == NULL)
		return (EOPNOTSUPP);
d340 2
a341 3
			return (EPERM);
		/* FALLTHROUGH */
	case OSIOCGIFINFO_IN6:
d347 1
a347 1
		return (nd6_ioctl(cmd, data, ifp));
d356 3
d360 1
a360 4
		log(LOG_NOTICE,
		    "prefix ioctls are now invalidated. "
		    "please use ifconfig.\n");
		return (EOPNOTSUPP);
d367 2
a368 2
			return (EPERM);
		/* FALLTHROUGH */
a374 9
	 *
	 * In netinet code, we have checked ifra_addr in SIOCSIF*ADDR operation
	 * only, and used the first interface address as the target of other
	 * operations (without checking ifra_addr).  This was because netinet
	 * code/API assumed at most 1 interface address per interface.
	 * Since IPv6 allows a node to assign multiple addresses
	 * on a single interface, we almost always look and check the
	 * presence of ifra_addr, and reject invalid ones here.
	 * It also decreases duplicated code among SIOC*_IN6 operations.
d376 4
a379 29
	switch (cmd) {
	case SIOCAIFADDR_IN6:
	case SIOCSIFPHYADDR_IN6:
		sa6 = &ifra->ifra_addr;
		break;
	case SIOCSIFADDR_IN6:
	case SIOCGIFADDR_IN6:
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
	case SIOCGIFDSTADDR_IN6:
	case SIOCGIFNETMASK_IN6:
	case SIOCDIFADDR_IN6:
	case SIOCGIFPSRCADDR_IN6:
	case SIOCGIFPDSTADDR_IN6:
	case SIOCGIFAFLAG_IN6:
	case SIOCSNDFLUSH_IN6:
	case SIOCSPFXFLUSH_IN6:
	case SIOCSRTRFLUSH_IN6:
	case SIOCGIFALIFETIME_IN6:
	case SIOCSIFALIFETIME_IN6:
	case SIOCGIFSTAT_IN6:
	case SIOCGIFSTAT_ICMP6:
		sa6 = &ifr->ifr_addr;
		break;
	default:
		sa6 = NULL;
		break;
	}
	if (sa6 && sa6->sin6_family == AF_INET6) {
d382 1
a382 1
				/* link ID is not embedded by the user */
d384 1
a384 1
				    htons(ifp->if_index);
d386 2
a387 2
			    htons(ifp->if_index)) {
				return (EINVAL);	/* link ID contradicts */
d392 1
a392 1
					return (EINVAL);
d396 2
a397 3
		ia = in6ifa_ifpwithaddr(ifp, &sa6->sin6_addr);
	} else
		ia = NULL;
a399 8
	case SIOCSIFADDR_IN6:
	case SIOCSIFDSTADDR_IN6:
	case SIOCSIFNETMASK_IN6:
		/*
		 * Since IPv6 allows a node to assign multiple addresses
		 * on a single interface, SIOCSIFxxx ioctls are deprecated.
		 */
		return (EINVAL);
d404 4
a407 4
		 * "ifconfig if0 delete" to remove the first IPv4 address on
		 * the interface.  For IPv6, as the spec allows multiple
		 * interface address from the day one, we consider "remove the
		 * first one" semantics to be not preferable.
d410 1
a410 1
			return (EADDRNOTAVAIL);
d413 4
d418 3
a420 2
		 * We always require users to specify a valid IPv6 address for
		 * the corresponding operation.
d422 3
a424 3
		if (ifra->ifra_addr.sin6_family != AF_INET6 ||
		    ifra->ifra_addr.sin6_len != sizeof(struct sockaddr_in6))
			return (EAFNOSUPPORT);
d426 20
a445 1
			return (EPERM);
d447 30
d481 1
a481 1
		/* FALLTHROUGH */
d488 1
a488 1
			return (EADDRNOTAVAIL);
d495 1
a495 1
			return (EPERM);
d497 1
a497 1
			return (EADDRNOTAVAIL);
d520 1
a520 5
			return (EINVAL);
		/*
		 * XXX: should we check if ifa_dstaddr is NULL and return
		 * an error?
		 */
d535 7
a541 4
		bzero(&ifr->ifr_ifru.ifru_stat,
		    sizeof(ifr->ifr_ifru.ifru_stat));
		ifr->ifr_ifru.ifru_stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->in6_ifstat;
d547 8
a554 4
		bzero(&ifr->ifr_ifru.ifru_stat,
		    sizeof(ifr->ifr_ifru.ifru_icmp6stat));
		ifr->ifr_ifru.ifru_icmp6stat =
		    *((struct in6_ifextra *)ifp->if_afdata[AF_INET6])->icmp6_ifstat;
d557 19
a575 6
	case SIOCGIFALIFETIME_IN6:
		ifr->ifr_ifru.ifru_lifetime = ia->ia6_lifetime;
		if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
			time_t maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;
d577 11
a587 12
			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
			if (ia->ia6_lifetime.ia6t_vltime <
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_expire = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_vltime;
			} else
				retlt->ia6t_expire = maxexpire;
d589 1
a589 4
		if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
			time_t maxexpire;
			struct in6_addrlifetime *retlt =
			    &ifr->ifr_ifru.ifru_lifetime;
d591 3
a593 13
			/*
			 * XXX: adjust expiration time assuming time_t is
			 * signed.
			 */
			maxexpire = (-1) &
			    ~(1 << ((sizeof(maxexpire) * 8) - 1));
			if (ia->ia6_lifetime.ia6t_pltime <
			    maxexpire - ia->ia6_updatetime) {
				retlt->ia6t_preferred = ia->ia6_updatetime +
				    ia->ia6_lifetime.ia6t_pltime;
			} else
				retlt->ia6t_preferred = maxexpire;
		}
d611 3
a613 12
	case SIOCAIFADDR_IN6:
	{
		int i, error = 0;
		struct nd_prefix pr0, *pr;

		/* reject read-only flags */
		if ((ifra->ifra_flags & IN6_IFF_DUPLICATED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_DETACHED) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_NODAD) != 0 ||
		    (ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0) {
			return (EINVAL);
		}
d615 10
a624 13
		 * first, make or update the interface address structure,
		 * and link it to the list.
		 */
		if ((error = in6_update_ifa(ifp, ifra, ia)) != 0)
			return (error);
		if ((ia = in6ifa_ifpwithaddr(ifp, &ifra->ifra_addr.sin6_addr))
		    == NULL) {
		    	/*
			 * this can happen when the user specify the 0 valid
			 * lifetime.
			 */
			break;
		}
d626 12
a637 50
		/*
		 * then, make the prefix on-link on the interface.
		 * XXX: we'd rather create the prefix before the address, but
		 * we need at least one address to install the corresponding
		 * interface route, so we configure the address first.
		 */

		/*
		 * convert mask to prefix length (prefixmask has already
		 * been validated in in6_update_ifa().
		 */
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128) {
			break;	/* we don't need to install a host route. */
		}
		pr0.ndpr_prefix = ifra->ifra_addr;
		pr0.ndpr_mask = ifra->ifra_prefixmask.sin6_addr;
		/* apply the mask for safety. */
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ifra->ifra_prefixmask.sin6_addr.s6_addr32[i];
		}
		/*
		 * XXX: since we don't have an API to set prefix (not address)
		 * lifetimes, we just use the same lifetimes as addresses.
		 * The (temporarily) installed lifetimes can be overridden by
		 * later advertised RAs (when accept_rtadv is non 0), which is
		 * an intended behavior.
		 */
		pr0.ndpr_raf_onlink = 1; /* should be configurable? */
		pr0.ndpr_raf_auto =
		    ((ifra->ifra_flags & IN6_IFF_AUTOCONF) != 0);
		pr0.ndpr_vltime = ifra->ifra_lifetime.ia6t_vltime;
		pr0.ndpr_pltime = ifra->ifra_lifetime.ia6t_pltime;

		/* add the prefix if not yet. */
		if ((pr = nd6_prefix_lookup(&pr0)) == NULL) {
			/*
			 * nd6_prelist_add will install the corresponding
			 * interface route.
			 */
			if ((error = nd6_prelist_add(&pr0, NULL, &pr)) != 0)
				return (error);
			if (pr == NULL) {
				log(LOG_ERR, "nd6_prelist_add succeeded but "
				    "no prefix\n");
				return (EINVAL); /* XXX panic here? */
d639 1
d641 2
d644 21
a664 12
		/* relate the address to the prefix */
		if (ia->ia6_ndpr == NULL) {
			ia->ia6_ndpr = pr;
			pr->ndpr_refcnt++;
		}

		/*
		 * this might affect the status of autoconfigured addresses,
		 * that is, this address might make other addresses detached.
		 */
		pfxlist_onlink_check();

d666 1
a666 1
	}
d668 3
a670 4
	case SIOCDIFADDR_IN6:
	{
		int i = 0, purgeprefix = 0;
		struct nd_prefix pr0, *pr = NULL;
d672 47
a718 123
		/*
		 * If the address being deleted is the only one that owns
		 * the corresponding prefix, expire the prefix as well.
		 * XXX: theoretically, we don't have to worry about such
		 * relationship, since we separate the address management
		 * and the prefix management.  We do this, however, to provide
		 * as much backward compatibility as possible in terms of
		 * the ioctl operation.
		 */
		bzero(&pr0, sizeof(pr0));
		pr0.ndpr_ifp = ifp;
		pr0.ndpr_plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr,
		    NULL);
		if (pr0.ndpr_plen == 128)
			goto purgeaddr;
		pr0.ndpr_prefix = ia->ia_addr;
		pr0.ndpr_mask = ia->ia_prefixmask.sin6_addr;
		for (i = 0; i < 4; i++) {
			pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
			    ia->ia_prefixmask.sin6_addr.s6_addr32[i];
		}
		if ((pr = nd6_prefix_lookup(&pr0)) != NULL &&
		    pr == ia->ia6_ndpr) {
			pr->ndpr_refcnt--;
			if (pr->ndpr_refcnt == 0)
				purgeprefix = 1;
		}

	  purgeaddr:
		in6_purgeaddr(&ia->ia_ifa);
		if (pr && purgeprefix)
			prelist_remove(pr);
		break;
	}

	default:
		if (ifp == NULL || ifp->if_ioctl == 0)
			return (EOPNOTSUPP);
		return ((*ifp->if_ioctl)(ifp, cmd, data));
	}

	return (0);
}

/*
 * Update parameters of an IPv6 interface address.
 * If necessary, a new entry is created and linked into address chains.
 * This function is separated from in6_control().
 * XXX: should this be performed under splnet()?
 */
int
in6_update_ifa(ifp, ifra, ia)
	struct ifnet *ifp;
	struct in6_aliasreq *ifra;
	struct in6_ifaddr *ia;
{
	int error = 0, hostIsNew = 0, plen = -1;
	struct in6_ifaddr *oia;
	struct sockaddr_in6 dst6;
	struct in6_addrlifetime *lt;
	struct in6_multi_mship *imm;
	time_t time_second = (time_t)time.tv_sec;
	struct rtentry *rt;

	/* Validate parameters */
	if (ifp == NULL || ifra == NULL) /* this maybe redundant */
		return (EINVAL);

	/*
	 * The destination address for a p2p link must have a family
	 * of AF_UNSPEC or AF_INET6.
	 */
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    ifra->ifra_dstaddr.sin6_family != AF_INET6 &&
	    ifra->ifra_dstaddr.sin6_family != AF_UNSPEC)
		return (EAFNOSUPPORT);
	/*
	 * validate ifra_prefixmask.  don't check sin6_family, netmask
	 * does not carry fields other than sin6_len.
	 */
	if (ifra->ifra_prefixmask.sin6_len > sizeof(struct sockaddr_in6))
		return (EINVAL);
	/*
	 * Because the IPv6 address architecture is classless, we require
	 * users to specify a (non 0) prefix length (mask) for a new address.
	 * We also require the prefix (when specified) mask is valid, and thus
	 * reject a non-consecutive mask.
	 */
	if (ia == NULL && ifra->ifra_prefixmask.sin6_len == 0)
		return (EINVAL);
	if (ifra->ifra_prefixmask.sin6_len != 0) {
		plen = in6_mask2len(&ifra->ifra_prefixmask.sin6_addr,
		    (u_char *)&ifra->ifra_prefixmask +
		    ifra->ifra_prefixmask.sin6_len);
		if (plen <= 0)
			return (EINVAL);
	} else {
		/*
		 * In this case, ia must not be NULL.  We just use its prefix
		 * length.
		 */
		plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
	}
	/*
	 * If the destination address on a p2p interface is specified,
	 * and the address is a scoped one, validate/set the scope
	 * zone identifier.
	 */
	dst6 = ifra->ifra_dstaddr;
	if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) != 0 &&
	    (dst6.sin6_family == AF_INET6)) {
		/* link-local index check: should be a separate function? */
		if (IN6_IS_ADDR_LINKLOCAL(&dst6.sin6_addr)) {
			if (dst6.sin6_addr.s6_addr16[1] == 0) {
				/*
				 * interface ID is not embedded by
				 * the user
				 */
				dst6.sin6_addr.s6_addr16[1] =
				    htons(ifp->if_index);
			} else if (dst6.sin6_addr.s6_addr16[1] !=
			    htons(ifp->if_index)) {
				return (EINVAL);	/* ifid contradicts */
d720 1
d722 5
a726 9
	}
	/*
	 * The destination address can be specified only for a p2p or a
	 * loopback interface.  If specified, the corresponding prefix length
	 * must be 128.
	 */
	if (ifra->ifra_dstaddr.sin6_family == AF_INET6) {
#ifdef FORCE_P2PPLEN
		int i;
d728 3
a731 10
		if ((ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) == 0) {
			/* XXX: noisy message */
			nd6log((LOG_INFO, "in6_update_ifa: a destination can "
			    "be specified for a p2p or a loopback IF only\n"));
			return (EINVAL);
		}
		if (plen != 128) {
			nd6log((LOG_INFO, "in6_update_ifa: prefixlen should "
			    "be 128 when dstaddr is specified\n"));
#ifdef FORCE_P2PPLEN
d733 1
a733 4
			 * To be compatible with old configurations,
			 * such as ifconfig gif0 inet6 2001::1 2001::2
			 * prefixlen 126, we override the specified
			 * prefixmask as if the prefix length was 128.
d735 12
a746 9
			ifra->ifra_prefixmask.sin6_len =
			    sizeof(struct sockaddr_in6);
			for (i = 0; i < 4; i++)
				ifra->ifra_prefixmask.sin6_addr.s6_addr32[i] =
				    0xffffffff;
			plen = 128;
#else
			return (EINVAL);
#endif
a747 13
	}
	/* lifetime consistency check */
	lt = &ifra->ifra_lifetime;
	if (lt->ia6t_pltime > lt->ia6t_vltime)
		return (EINVAL);
	if (lt->ia6t_vltime == 0) {
		/*
		 * the following log might be noisy, but this is a typical
		 * configuration mistake or a tool's bug.
		 */
		nd6log((LOG_INFO,
		    "in6_update_ifa: valid lifetime is 0 for %s\n",
		    ip6_sprintf(&ifra->ifra_addr.sin6_addr)));
d749 2
a750 3
		if (ia == NULL)
			return (0); /* there's nothing to do */
	}
d752 10
a761 40
	/*
	 * If this is a new address, allocate a new ifaddr and link it
	 * into chains.
	 */
	if (ia == NULL) {
		hostIsNew = 1;
		/*
		 * When in6_update_ifa() is called in a process of a received
		 * RA, it is called under an interrupt context.  So, we should
		 * call malloc with M_NOWAIT.
		 */
		ia = (struct in6_ifaddr *) malloc(sizeof(*ia), M_IFADDR,
		    M_NOWAIT);
		if (ia == NULL)
			return (ENOBUFS);
		bzero((caddr_t)ia, sizeof(*ia));
		LIST_INIT(&ia->ia6_memberships);
		/* Initialize the address and masks, and put time stamp */
		ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
		ia->ia_addr.sin6_family = AF_INET6;
		ia->ia_addr.sin6_len = sizeof(ia->ia_addr);
		ia->ia6_createtime = ia->ia6_updatetime = time_second;
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) != 0) {
			/*
			 * XXX: some functions expect that ifa_dstaddr is not
			 * NULL for p2p interfaces.
			 */
			ia->ia_ifa.ifa_dstaddr =
			    (struct sockaddr *)&ia->ia_dstaddr;
		} else {
			ia->ia_ifa.ifa_dstaddr = NULL;
		}
		ia->ia_ifa.ifa_netmask =
		    (struct sockaddr *)&ia->ia_prefixmask;

		ia->ia_ifp = ifp;
		if ((oia = in6_ifaddr) != NULL) {
			for ( ; oia->ia_next; oia = oia->ia_next)
				continue;
			oia->ia_next = ia;
d763 1
a763 4
			in6_ifaddr = ia;
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, &ia->ia_ifa,
				  ifa_list);
	}
a764 2
	/* set prefix mask */
	if (ifra->ifra_prefixmask.sin6_len) {
d766 30
a795 12
		 * We prohibit changing the prefix length of an existing
		 * address, because
		 * + such an operation should be rare in IPv6, and
		 * + the operation would confuse prefix management.
		 */
		if (ia->ia_prefixmask.sin6_len &&
		    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL) != plen) {
			nd6log((LOG_INFO, "in6_update_ifa: the prefix length of an"
			    " existing (%s) address should not be changed\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
			error = EINVAL;
			goto unlink;
a796 75
		ia->ia_prefixmask = ifra->ifra_prefixmask;
	}

	/*
	 * If a new destination address is specified, scrub the old one and
	 * install the new destination.  Note that the interface must be
	 * p2p or loopback (see the check above.)
	 */
	if (dst6.sin6_family == AF_INET6 &&
	    !IN6_ARE_ADDR_EQUAL(&dst6.sin6_addr, &ia->ia_dstaddr.sin6_addr)) {
		int e;

		if ((ia->ia_flags & IFA_ROUTE) != 0 &&
		    (e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST)) != 0) {
			nd6log((LOG_ERR, "in6_update_ifa: failed to remove "
			    "a route to the old destination: %s\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
			/* proceed anyway... */
		} else
			ia->ia_flags &= ~IFA_ROUTE;
		ia->ia_dstaddr = dst6;
	}

	/*
	 * Set lifetimes.  We do not refer to ia6t_expire and ia6t_preferred
	 * to see if the address is deprecated or invalidated, but initialize
	 * these members for applications.
	 */
	ia->ia6_lifetime = ifra->ifra_lifetime;
	if (ia->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_expire =
		    time_second + ia->ia6_lifetime.ia6t_vltime;
	} else
		ia->ia6_lifetime.ia6t_expire = 0;
	if (ia->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME) {
		ia->ia6_lifetime.ia6t_preferred =
		    time_second + ia->ia6_lifetime.ia6t_pltime;
	} else
		ia->ia6_lifetime.ia6t_preferred = 0;

	/* reset the interface and routing table appropriately. */
	if ((error = in6_ifinit(ifp, ia, &ifra->ifra_addr, hostIsNew)) != 0)
		goto unlink;

	/*
	 * configure address flags.
	 */
	ia->ia6_flags = ifra->ifra_flags;
	/*
	 * backward compatibility - if IN6_IFF_DEPRECATED is set from the
	 * userland, make it deprecated.
	 */
	if ((ifra->ifra_flags & IN6_IFF_DEPRECATED) != 0) {
		ia->ia6_lifetime.ia6t_pltime = 0;
		ia->ia6_lifetime.ia6t_preferred = time_second;
	}
	/*
	 * Make the address tentative before joining multicast addresses,
	 * so that corresponding MLD responses would not have a tentative
	 * source address.
	 */
	ia->ia6_flags &= ~IN6_IFF_DUPLICATED;	/* safety */
	if (hostIsNew && in6if_do_dad(ifp))
		ia->ia6_flags |= IN6_IFF_TENTATIVE;

	/*
	 * Beyond this point, we should call in6_purgeaddr upon an error,
	 * not just go to unlink.
	 */

	if ((ifp->if_flags & IFF_MULTICAST) != 0) {
		struct sockaddr_in6 mltaddr, mltmask;
#ifndef SCOPEDROUTING
		u_int32_t zoneid = 0;
#endif
d799 2
a800 30
			/* join solicited multicast addr for new host id */
			struct sockaddr_in6 llsol;

			bzero(&llsol, sizeof(llsol));
			llsol.sin6_family = AF_INET6;
			llsol.sin6_len = sizeof(llsol);
			llsol.sin6_addr.s6_addr16[0] = htons(0xff02);
			llsol.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
			llsol.sin6_addr.s6_addr32[1] = 0;
			llsol.sin6_addr.s6_addr32[2] = htonl(1);
			llsol.sin6_addr.s6_addr32[3] =
			    ifra->ifra_addr.sin6_addr.s6_addr32[3];
			llsol.sin6_addr.s6_addr8[12] = 0xff;
			imm = in6_joingroup(ifp, &llsol.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				nd6log((LOG_ERR, "in6_update_ifa: addmulti "
				    "failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&llsol.sin6_addr),
				    ifp->if_xname, error));
				goto cleanup;
			}
		}

		bzero(&mltmask, sizeof(mltmask));
		mltmask.sin6_len = sizeof(struct sockaddr_in6);
		mltmask.sin6_family = AF_INET6;
		mltmask.sin6_addr = in6mask32;
d802 5
a806 61
		/*
		 * join link-local all-nodes address
		 */
		bzero(&mltaddr, sizeof(mltaddr));
		mltaddr.sin6_len = sizeof(struct sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_linklocal_allnodes;
		mltaddr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);

		/*
		 * XXX: do we really need this automatic routes?
		 * We should probably reconsider this stuff.  Most applications
		 * actually do not need the routes, since they usually specify
		 * the outgoing interface.
		 */
		rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
		if (rt) {
			/*
			 * 32bit came from "mltmask"
			 * XXX: only works in !SCOPEDROUTING case.
			 */
			if (memcmp(&mltaddr.sin6_addr,
			    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
			    32 / 8)) {
				RTFREE(rt);
				rt = NULL;
			}
		}
		if (!rt) {
			struct rt_addrinfo info;

			bzero(&info, sizeof(info));
			info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&mltmask;
			info.rti_info[RTAX_IFA] =
			    (struct sockaddr *)&ia->ia_addr;
			/* XXX: we need RTF_CLONING to fake nd6_rtrequest */
			info.rti_flags = RTF_UP | RTF_CLONING;
			error = rtrequest1(RTM_ADD, &info, NULL);
			if (error)
				goto cleanup;
		} else {
			RTFREE(rt);
		}
#ifndef SCOPEDROUTING
		mltaddr.sin6_scope_id = zoneid;	/* XXX */
#endif
		imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
		if (imm) {
			LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
			    i6mm_chain);
		} else {
			nd6log((LOG_WARNING,
			    "in6_update_ifa: addmulti failed for "
			    "%s on %s (errno=%d)\n",
			    ip6_sprintf(&mltaddr.sin6_addr),
			    ifp->if_xname, error));
			goto cleanup;
d809 1
a809 16
		/*
		 * join node information group address
		 */
		if (in6_nigroup(ifp, hostname, hostnamelen, &mltaddr) == 0) {
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s (errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
				/* XXX not very fatal, go on... */
			}
		}
d811 3
a813 6
		if (ifp->if_flags & IFF_LOOPBACK) {
			/*
			 * join node-local all-nodes address, on loopback.
			 * (ff01::1%ifN, and ff01::%ifN/32)
			 */
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;
d815 4
a818 42
			/* XXX: again, do we really need the route? */
			rt = rtalloc1((struct sockaddr *)&mltaddr, 0);
			if (rt) {
				/* 32bit came from "mltmask" */
				if (memcmp(&mltaddr.sin6_addr,
				    &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
				    32 / 8)) {
					RTFREE(rt);
					rt = NULL;
				}
			}
			if (!rt) {
				struct rt_addrinfo info;

				bzero(&info, sizeof(info));
				info.rti_info[RTAX_DST] = (struct sockaddr *)&mltaddr;
				info.rti_info[RTAX_GATEWAY] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_info[RTAX_NETMASK] =
				    (struct sockaddr *)&mltmask;
				info.rti_info[RTAX_IFA] =
				    (struct sockaddr *)&ia->ia_addr;
				info.rti_flags = RTF_UP | RTF_CLONING;
				error = rtrequest1(RTM_ADD, &info, NULL);
				if (error)
					goto cleanup;
			} else {
				RTFREE(rt);
			}
			imm = in6_joingroup(ifp, &mltaddr.sin6_addr, &error);
			if (imm) {
				LIST_INSERT_HEAD(&ia->ia6_memberships, imm,
				    i6mm_chain);
			} else {
				nd6log((LOG_WARNING, "in6_update_ifa: "
				    "addmulti failed for %s on %s "
				    "(errno=%d)\n",
				    ip6_sprintf(&mltaddr.sin6_addr),
				    ifp->if_xname, error));
				goto cleanup;
			}
		}
d821 1
a821 25
	/*
	 * Perform DAD, if needed.
	 * XXX It may be of use, if we can administratively
	 * disable DAD.
	 */
	if (hostIsNew && in6if_do_dad(ifp) &&
	    (ifra->ifra_flags & IN6_IFF_NODAD) == 0)
	{
		nd6_dad_start((struct ifaddr *)ia, NULL);
	}

	return (error);

  unlink:
	/*
	 * XXX: if a change of an existing address failed, keep the entry
	 * anyway.
	 */
	if (hostIsNew)
		in6_unlink_ifa(ia, ifp);
	return (error);

  cleanup:
	in6_purgeaddr(&ia->ia_ifa);
	return error;
d825 1
a825 1
in6_purgeaddr(ifa)
d827 1
d829 1
a829 3
	struct ifnet *ifp = ifa->ifa_ifp;
	struct in6_ifaddr *ia = (struct in6_ifaddr *) ifa;
	struct in6_multi_mship *imm;
d834 1
a834 6
	/*
	 * delete route to the destination of the address being purged.
	 * The interface must be p2p or loopback in this case.
	 */
	if ((ia->ia_flags & IFA_ROUTE) != 0 && ia->ia_dstaddr.sin6_len != 0) {
		int e;
d836 14
a849 11
		if ((e = rtinit(&(ia->ia_ifa), (int)RTM_DELETE, RTF_HOST))
		    != 0) {
			log(LOG_ERR, "in6_purgeaddr: failed to remove "
			    "a route to the p2p destination: %s on %s, "
			    "errno=%d\n",
			    ip6_sprintf(&ia->ia_addr.sin6_addr), ifp->if_xname,
			    e);
			/* proceed anyway... */
		} else
			ia->ia_flags &= ~IFA_ROUTE;
	}
d851 3
a853 9
	/* Remove ownaddr's loopback rtentry, if it exists. */
	in6_ifremloop(&(ia->ia_ifa));

	/*
	 * leave from multicast groups we have joined for the interface
	 */
	while ((imm = ia->ia6_memberships.lh_first) != NULL) {
		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
a855 11
	in6_unlink_ifa(ia, ifp);
}

static void
in6_unlink_ifa(ia, ifp)
	struct in6_ifaddr *ia;
	struct ifnet *ifp;
{
	struct in6_ifaddr *oia;
	int	s = splnet();

d857 1
d867 2
a868 4
		else {
			/* search failed */
			printf("Couldn't unlink in6_ifaddr from in6_ifaddr\n");
		}
d870 2
d873 5
a877 1
	if (oia->ia6_multiaddrs.lh_first != NULL) {
a878 1
	}
a879 23
	/*
	 * When an autoconfigured address is being removed, release the
	 * reference to the base prefix.  Also, since the release might
	 * affect the status of other (detached) addresses, call
	 * pfxlist_onlink_check().
	 */
	if ((oia->ia6_flags & IN6_IFF_AUTOCONF) != 0) {
		if (oia->ia6_ndpr == NULL) {
			log(LOG_NOTICE, "in6_unlink_ifa: autoconf'ed address "
			    "%p has no prefix\n", oia);
		} else {
			oia->ia6_ndpr->ndpr_refcnt--;
			oia->ia6_flags &= ~IN6_IFF_AUTOCONF;
			oia->ia6_ndpr = NULL;
		}

		pfxlist_onlink_check();
	}

	/*
	 * release another refcnt for the link from in6_ifaddr.
	 * Note that we should decrement the refcnt at least once for all *BSD.
	 */
a880 19

	splx(s);
}

void
in6_purgeif(ifp)
	struct ifnet *ifp;
{
	struct ifaddr *ifa, *nifa;

	for (ifa = TAILQ_FIRST(&ifp->if_addrlist); ifa != NULL; ifa = nifa)
	{
		nifa = TAILQ_NEXT(ifa, ifa_list);
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		in6_purgeaddr(ifa);
	}

	in6_ifdetach(ifp);
d901 1
a901 1
 * this is to accommodate address naming scheme other than RFC2374,
d992 2
a993 1
		bcopy(iflr->iflr_name, ifra.ifra_name, sizeof(ifra.ifra_name));
d996 1
a996 1
		    ((struct sockaddr *)&iflr->addr)->sa_len);
d1000 1
a1000 1
			    hostid->s6_addr32[2];
d1002 1
a1002 1
			    hostid->s6_addr32[3];
d1007 1
a1007 1
			    ((struct sockaddr *)&iflr->dstaddr)->sa_len);
d1010 1
a1010 1
				    hostid->s6_addr32[2];
d1012 1
a1012 1
				    hostid->s6_addr32[3];
d1016 1
d1018 1
a1018 1
		in6_prefixlen2mask(&ifra.ifra_prefixmask.sin6_addr, prefixlen);
d1021 2
a1022 1
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp, p);
d1035 1
a1035 1
			in6_prefixlen2mask(&mask, iflr->prefixlen);
d1052 1
a1052 1
				cmp = 0;	/* XXX */
d1055 1
a1055 1
				in6_prefixlen2mask(&mask, 128);
a1070 1

d1086 1
d1089 1
a1089 1
				    ia->ia_dstaddr.sin6_len);
d1094 1
a1094 1
			    in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL);
d1105 1
a1105 1
			    sizeof(ifra.ifra_name));
d1108 1
a1108 1
			    ia->ia_addr.sin6_len);
d1111 1
a1111 1
				    ia->ia_dstaddr.sin6_len);
d1117 1
a1117 1
			    ia->ia_prefixmask.sin6_len);
d1120 1
d1122 1
a1122 1
			    ifp, p);
d1127 28
a1154 1
	return EOPNOTSUPP;	/* just for safety */
d1161 2
a1162 2
static int
in6_ifinit(ifp, ia, sin6, newhost)
d1166 1
a1166 1
	int newhost;
d1168 2
a1169 1
	int	error = 0, plen, ifacount = 0;
a1170 1
	struct ifaddr *ifa;
d1172 2
d1179 5
a1183 8
	for (ifa = ifp->if_addrlist.tqh_first; ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		ifacount++;
d1186 12
a1197 1
	ia->ia_addr = *sin6;
d1199 5
a1203 4
	if (ifacount <= 1 && ifp->if_ioctl &&
	    (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia))) {
		splx(s);
		return (error);
d1205 3
a1207 6
	splx(s);

	ia->ia_ifa.ifa_metric = ifp->if_metric;

	/* we could do in(6)_socktrim here, but just omit it at this moment. */

d1209 1
a1209 4
	 * Special case:
	 * If the destination address is specified for a point-to-point
	 * interface, install a route to the destination as an interface
	 * direct route.
d1211 10
a1220 5
	plen = in6_mask2len(&ia->ia_prefixmask.sin6_addr, NULL); /* XXX */
	if (plen == 128 && ia->ia_dstaddr.sin6_family == AF_INET6) {
		if ((error = rtinit(&(ia->ia_ifa), (int)RTM_ADD,
				    RTF_UP | RTF_HOST)) != 0)
			return (error);
a1221 1
	}
d1223 2
a1224 6
	/* Add ownaddr as loopback rtentry, if necessary (ex. on p2p link). */
	if (newhost) {
		/* set the rtrequest function to create llinfo */
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		in6_ifaddloop(&(ia->ia_ifa));
	}
d1229 1
a1229 1
	return (error);
d1366 1
a1366 1
	int	s = splsoftnet();
d1388 1
a1388 1
			return (NULL);
d1398 1
a1398 1
			return (NULL);
d1416 1
a1416 1
			    (caddr_t)&ifr);
d1422 1
a1422 1
			return (NULL);
d1431 1
a1431 1
	return (in6m);
d1442 1
a1442 1
	int	s = splsoftnet();
a1473 33
struct in6_multi_mship *
in6_joingroup(ifp, addr, errorp)
	struct ifnet *ifp;
	struct in6_addr *addr;
	int *errorp;
{
	struct in6_multi_mship *imm;

	imm = malloc(sizeof(*imm), M_IPMADDR, M_NOWAIT);
	if (!imm) {
		*errorp = ENOBUFS;
		return NULL;
	}
	imm->i6mm_maddr = in6_addmulti(addr, ifp, errorp);
	if (!imm->i6mm_maddr) {
		/* *errorp is alrady set */
		free(imm, M_IPMADDR);
		return NULL;
	}
	return imm;
}

int
in6_leavegroup(imm)
	struct in6_multi_mship *imm;
{

	if (imm->i6mm_maddr)
		in6_delmulti(imm->i6mm_maddr);
	free(imm,  M_IPMADDR);
	return 0;
}

d1500 1
a1500 1
	return ((struct in6_ifaddr *)ifa);
d1526 1
a1526 1
	return ((struct in6_ifaddr *)ifa);
d1580 18
a1597 1
	return (ip6buf[ip6round]);
d1649 1
a1649 1
	if (bcmp(&in6addr_loopback, addr, sizeof(*addr) - 1) == 0) {
d1665 1
a1665 1

d1668 1
a1668 1
		return (-1);	/* XXX: is this an appropriate value? */
d1672 1
a1672 1
		return (ifp->if_index);
d1675 1
a1675 1
		return (0);	/* XXX: invalid. */
d1678 1
a1678 1
		return (0);	/* XXX: treat as global. */
a1681 21
int
in6_is_addr_deprecated(sa6)
	struct sockaddr_in6 *sa6;
{
	struct in6_ifaddr *ia;

	for (ia = in6_ifaddr; ia; ia = ia->ia_next) {
		if (IN6_ARE_ADDR_EQUAL(&ia->ia_addr.sin6_addr,
		    &sa6->sin6_addr) &&
#ifdef SCOPEDROUTING
		    ia->ia_addr.sin6_scope_id == sa6->sin6_scope_id &&
#endif
		    (ia->ia6_flags & IN6_IFF_DEPRECATED) != 0)
			return (1); /* true */

		/* XXX: do we still have to go thru the rest of the list? */
	}

	return (0);		/* false */
}

d1717 1
a1717 1
		return (0);
d1724 1
a1724 1
		return (0);
d1727 1
a1727 1
		return (0);
d1729 1
a1729 1
	return (1);
d1769 1
a1769 1

d1772 1
a1772 1
		return (NULL);
d2002 1
a2002 1
	return (ifa_best);
d2062 1
a2062 1
		return (besta);
a2122 34
int
in6if_do_dad(ifp)
	struct ifnet *ifp;
{
	if ((ifp->if_flags & IFF_LOOPBACK) != 0)
		return (0);

	switch (ifp->if_type) {
	case IFT_FAITH:
		/*
		 * These interfaces do not have the IFF_LOOPBACK flag,
		 * but loop packets back.  We do not have to do DAD on such
		 * interfaces.  We should even omit it, because loop-backed
		 * NS would confuse the DAD procedure.
		 */
		return (0);
	default:
		/*
		 * Our DAD routine requires the interface up and running.
		 * However, some interfaces can be up before the RUNNING
		 * status.  Additionaly, users may try to assign addresses
		 * before the interface becomes up (or running).
		 * We simply skip DAD in such a case as a work around.
		 * XXX: we should rather mark "tentative" on such addresses,
		 * and do DAD after the interface becomes ready.
		 */
		if ((ifp->if_flags & (IFF_UP|IFF_RUNNING)) !=
		    (IFF_UP|IFF_RUNNING))
			return (0);

		return (1);
	}
}

a2134 3
		/* this function can be called during ifnet initialization */
		if (!ifp->if_afdata[AF_INET6])
			continue;
d2136 2
a2137 2
		    IN6_LINKMTU(ifp) > maxmtu)
			maxmtu = IN6_LINKMTU(ifp);
d2139 1
a2139 1
	if (maxmtu)	     /* update only when maxmtu is positive */
a2140 35
}

void *
in6_domifattach(ifp)
	struct ifnet *ifp;
{
	struct in6_ifextra *ext;

	ext = (struct in6_ifextra *)malloc(sizeof(*ext), M_IFADDR, M_WAITOK);
	bzero(ext, sizeof(*ext));

	ext->in6_ifstat = (struct in6_ifstat *)malloc(sizeof(struct in6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->in6_ifstat, sizeof(*ext->in6_ifstat));

	ext->icmp6_ifstat =
	    (struct icmp6_ifstat *)malloc(sizeof(struct icmp6_ifstat),
	    M_IFADDR, M_WAITOK);
	bzero(ext->icmp6_ifstat, sizeof(*ext->icmp6_ifstat));

	ext->nd_ifinfo = nd6_ifattach(ifp);
	return ext;
}

void
in6_domifdetach(ifp, aux)
	struct ifnet *ifp;
	void *aux;
{
	struct in6_ifextra *ext = (struct in6_ifextra *)aux;

	nd6_ifdetach(ext->nd_ifinfo);
	free(ext->in6_ifstat, M_IFADDR);
	free(ext->icmp6_ifstat, M_IFADDR);
	free(ext, M_IFADDR);
@


1.13.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.c,v 1.13.2.8 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.13.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d213 1
a213 1
void
d231 1
a231 1
void
d287 1
a287 1
	if (idx < 0 || if_indexlim <= idx)
a289 2
	if (!ifp)
		return -1;
d356 1
d530 1
a530 1
		 && lt->ia6t_vltime + time.tv_sec < time.tv_sec) {
d534 1
a534 1
		 && lt->ia6t_pltime + time.tv_sec < time.tv_sec) {
d628 1
a628 1
				time.tv_sec + ia->ia6_lifetime.ia6t_vltime;
d633 1
a633 1
				time.tv_sec + ia->ia6_lifetime.ia6t_pltime;
d799 1
d939 1
a939 1
		ia->ia6_createtime = ia->ia6_updatetime = time.tv_sec;
d1011 1
a1011 1
		    time.tv_sec + ia->ia6_lifetime.ia6t_vltime;
d1016 1
a1016 1
		    time.tv_sec + ia->ia6_lifetime.ia6t_pltime;
d1034 1
a1034 1
		ia->ia6_lifetime.ia6t_preferred = time.tv_sec;
@


1.13.2.11
log
@Merge with the trunk
@
text
@d2206 1
a2206 2
	if (bitlen != 0 &&
	    p1->s6_addr[bytelen] >> (8 - bitlen) !=
@


1.12
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 1
a1 1
/* $OpenBSD: in6.c,v 1.11 2000/02/02 17:53:52 itojun Exp $ */
d95 1
a95 1
#include <netinet6/ip6.h>
d196 1
a196 1
		nrt->rt_ifa->ifa_refcnt--;
a390 2
int	in6_interfaces;		/* number of external internet interfaces */

d541 1
d545 1
a545 3

			if ((ifp->if_flags & IFF_LOOPBACK) == 0)
				in6_interfaces++;	/*XXX*/
@


1.11
log
@make sure to nuke kludge entries, regardless from refcnt.
@
text
@d1 1
a1 1
/* $OpenBSD: in6.c,v 1.10 2000/02/02 17:16:52 itojun Exp $ */
d742 1
d850 1
a850 53
		in6_ifscrub(ifp, ia);

		if (ifp->if_flags & IFF_MULTICAST) {
			/*
			 * delete solicited multicast addr for deleting host id
			 */
			struct in6_multi *in6m;
			struct in6_addr llsol;
			bzero(&llsol, sizeof(struct in6_addr));
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr32[3] =
				ia->ia_addr.sin6_addr.s6_addr32[3];
			llsol.s6_addr8[12] = 0xff;

			IN6_LOOKUP_MULTI(llsol, ifp, in6m);
			if (in6m)
				in6_delmulti(in6m);
		}
		/* Leave dstaddr's solicited multicast if necessary. */
		if (nd6_proxyall)
			in6_ifremproxy(ia);

		TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
		oia = ia;
		if (oia == (ia = in6_ifaddr))
			in6_ifaddr = ia->ia_next;
		else {
			while (ia->ia_next && (ia->ia_next != oia))
				ia = ia->ia_next;
			if (ia->ia_next)
				ia->ia_next = oia->ia_next;
			else
				printf("Didn't unlink in6_ifaddr from list\n");
		}
		{
			int iilen;

			iilen = (sizeof(oia->ia_prefixmask.sin6_addr) << 3) -
				in6_mask2len(&oia->ia_prefixmask.sin6_addr);
			in6_prefix_remove_ifid(iilen, oia);
		}

		if (oia->ia6_multiaddrs.lh_first == NULL) {
			IFAFREE(&oia->ia_ifa);
			break;
		}
		else
			in6_savemkludge(oia);

		IFAFREE((&oia->ia_ifa));
d859 59
@


1.10
log
@- improve in6_ifdetach to remove (1) multicast kludge list (2) route to
  link-local allnode multicast (ff02:x::/32)
- fix ifnet refcnt'ing in multicast kludge list management.
- avoid dangling pointer in multicast kludge management.

(angelos, try this version of in6_ifdetach() - it should be better)
@
text
@d1 1
a1 1
/* $OpenBSD: in6.c,v 1.9 2000/02/02 17:01:50 itojun Exp $ */
d1332 1
a1332 1
	struct in6_multi *in6m, *next;
d1338 2
a1339 3
		for (in6m = mk->mk_head.lh_first; in6m; in6m = next) {
			next = in6m->in6m_entry.le_next;
			LIST_REMOVE(in6m, in6m_entry);
a1340 2
			in6m = NULL;
		}
@


1.9
log
@remove never-visited code (#ifdef MAPPED_ADDR_ENABLED)
@
text
@d1 1
a1 1
/* $OpenBSD: in6.c,v 1.8 1999/12/10 08:53:17 angelos Exp $ */
d1283 2
d1315 2
d1327 23
d1451 2
a1452 1
		IFAFREE(&in6m->in6m_ia->ia_ifa); /* release reference */
@


1.8
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a1974 61

#ifdef MAPPED_ADDR_ENABLED
/* 
 * Convert sockaddr_in6 to sockaddr_in. Original sockaddr_in6 must be
 * v4 mapped addr or v4 compat addr
 */
void
in6_sin6_2_sin(struct sockaddr_in *sin, struct sockaddr_in6 *sin6)
{
	bzero(sin, sizeof(*sin));
	sin->sin_len = sizeof(struct sockaddr_in);
	sin->sin_family = AF_INET;
	sin->sin_port = sin6->sin6_port;
	sin->sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];	
}

/* Convert sockaddr_in to sockaddr_in6 in v4 mapped addr format. */
void
in6_sin_2_v4mapsin6(struct sockaddr_in *sin, struct sockaddr_in6 *sin6)
{
	bzero(sin6, sizeof(*sin6));
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_family = AF_INET6;
	sin6->sin6_port = sin->sin_port;
	sin6->sin6_addr.s6_addr32[0] = 0;
	sin6->sin6_addr.s6_addr32[1] = 0;
	sin6->sin6_addr.s6_addr32[2] = IPV6_ADDR_INT32_SMP;
	sin6->sin6_addr.s6_addr32[3] = sin->sin_addr.s_addr;
}

/* Convert sockaddr_in6 into sockaddr_in. */
void
in6_sin6_2_sin_in_sock(struct sockaddr *nam)
{
	struct sockaddr_in *sin_p;
	struct sockaddr_in6 sin6;

	/*
	 * Save original sockaddr_in6 addr and convert it
	 * to sockaddr_in.
	 */
	sin6 = *(struct sockaddr_in6 *)nam;
	sin_p = (struct sockaddr_in *)nam;
	in6_sin6_2_sin(sin_p, &sin6);
}

/* Convert sockaddr_in into sockaddr_in6 in v4 mapped addr format. */
void
in6_sin_2_v4mapsin6_in_sock(struct sockaddr **nam)
{
	struct sockaddr_in *sin_p;
	struct sockaddr_in6 *sin6_p;

	MALLOC(sin6_p, struct sockaddr_in6 *, sizeof *sin6_p, M_SONAME,
	       M_WAITOK);
	sin_p = (struct sockaddr_in *)*nam;
	in6_sin_2_v4mapsin6(sin_p, sin6_p);
	FREE(*nam, M_SONAME);
	*nam = (struct sockaddr *)sin6_p;
}
#endif /* MAPPED_ADDR_ENABLED */
@


1.7
log
@do not perform IPv6 initialization for loopback interface.
MUST make lo0 up before any IPv6 operations.
it will be considered a pilot error if you don't.
(I prefer to have lo0 initialized automatically)
@
text
@d1 1
@


1.6
log
@ifdef cleanup...
@
text
@d1908 3
@


1.5
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@a64 4
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#endif

a65 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a66 1
#endif
a72 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a73 1
#endif
d82 1
d86 1
a90 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#else
a91 1
#endif
a101 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
MALLOC_DEFINE(M_IPMADDR, "in6_multi", "internet multicast address");
#endif

a119 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a121 4
#else
static int in6_lifaddr_ioctl __P((struct socket *, u_long, caddr_t,
	struct ifnet *));
#endif
a122 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
struct in6_multihead in6_multihead;	/* XXX BSS initialization */
#else
a133 1
#endif
a158 1
#ifdef __OpenBSD__
a159 19
#else
#define SIN6(s) ((struct sockaddr_in6 *)s)
	/*
	 * If RTF_CLONING is unset, or (IFF_LOOPBACK | IFF_POINTOPOINT),
	 * or netmask is all0 or all1, then cloning will not happen,
	 * then we can't rely on its loopback entry generation.
	 */
	if ((ifa->ifa_flags & RTF_CLONING) == 0 ||
	    (ifa->ifa_ifp->if_flags & (IFF_LOOPBACK | IFF_POINTOPOINT)) ||
	    (SIN6(ifa->ifa_netmask)->sin6_len == sizeof(struct sockaddr_in6)
	     &&
	     IN6_ARE_ADDR_EQUAL(&SIN6(ifa->ifa_netmask)->sin6_addr,
				&in6mask128)) ||
	    ((struct sockaddr_in6 *)ifa->ifa_netmask)->sin6_len == 0)
		return 0;
	else
		return 1;
#undef SIN6
#endif
d215 1
a215 5
		rt = rtalloc1(ifa->ifa_addr, 0
#ifdef __FreeBSD__
			      , 0
#endif /* __FreeBSD__ */
			      );
a343 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a344 1
#endif
a395 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a401 7
#else
in6_control(so, cmd, data, ifp)
	struct	socket *so;
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
#endif
a403 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	struct  ifaddr *ifa;
#endif
a407 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a408 1
#endif
a411 4
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	if (p && !suser(p->p_ucred, &p->p_acflag))
		privileged++;
#else
a413 1
#endif
a473 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a474 3
#else
		return in6_lifaddr_ioctl(so, cmd, data, ifp);
#endif
d542 1
a542 8
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
			if ((ifa = ifp->if_addrlist) != NULL) {
				for ( ; ifa->ifa_next; ifa = ifa->ifa_next)
					continue;
				ifa->ifa_next = ia62ifa(ia);
			} else
				ifp->if_addrlist = ia62ifa(ia);
#else
d545 1
a545 1
#endif
a872 13
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		if ((ifa = ifp->if_addrlist) == ia62ifa(ia))
			ifp->if_addrlist = ifa->ifa_next;
		else {
			while (ifa->ifa_next &&
			       (ifa->ifa_next != ia62ifa(ia)))
				ifa = ifa->ifa_next;
			if (ifa->ifa_next)
				ifa->ifa_next = ia62ifa(ia)->ifa_next;
			else
				printf("Couldn't unlink in6_ifaddr from ifp\n");
		}
#else
a873 1
#endif
d892 1
a892 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a898 1
#endif
a934 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a940 7
#else
in6_lifaddr_ioctl(so, cmd, data, ifp)
	struct socket *so;
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
#endif
d1049 2
a1050 5
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp, p);
#else
		return in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, ifp);
#endif
a1090 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a1093 1
#endif
d1145 1
a1145 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a1147 4
#else
			return in6_control(so, SIOCDIFADDR_IN6, (caddr_t)&ifra,
				ifp);
#endif
a1243 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1245 1
#endif
a1249 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1334 3
#ifdef __NetBSD__
	int	s = splsoftnet();
#else
a1335 1
#endif
a1409 3
#ifdef __NetBSD__
	int	s = splsoftnet();
#else
a1410 1
#endif
a1438 89
#else /* not FreeBSD3 */
/*
 * Add an address to the list of IP6 multicast addresses for a 
 * given interface.
 */
struct	in6_multi *
in6_addmulti(maddr6, ifp, errorp)
	register struct in6_addr *maddr6;
	register struct ifnet *ifp;
	int *errorp;
{
	struct	in6_multi *in6m;
	struct sockaddr_in6 sin6;
	struct ifmultiaddr *ifma;
	int	s = splnet();

	*errorp = 0;

	/*
	 * Call generic routine to add membership or increment
	 * refcount.  It wants addresses in the form of a sockaddr,
	 * so we build one here (being careful to zero the unused bytes).
	 */
	bzero(&sin6, sizeof sin6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof sin6;
	sin6.sin6_addr = *maddr6;
	*errorp = if_addmulti(ifp, (struct sockaddr *)&sin6, &ifma);
	if (*errorp) {
		splx(s);
		return 0;
	}

	/*
	 * If ifma->ifma_protospec is null, then if_addmulti() created
	 * a new record.  Otherwise, we are done.
	 */
	if (ifma->ifma_protospec != 0)
		return ifma->ifma_protospec;

	/* XXX - if_addmulti uses M_WAITOK.  Can this really be called
	   at interrupt time?  If so, need to fix if_addmulti. XXX */
	in6m = (struct in6_multi *)malloc(sizeof(*in6m), M_IPMADDR, M_NOWAIT);
	if (in6m == NULL) {
		splx(s);
		return (NULL);
	}

	bzero(in6m, sizeof *in6m);
	in6m->in6m_addr = *maddr6;
	in6m->in6m_ifp = ifp;
	in6m->in6m_ifma = ifma;
	ifma->ifma_protospec = in6m;
	LIST_INSERT_HEAD(&in6_multihead, in6m, in6m_entry);

	/*
	 * Let MLD6 know that we have joined a new IP6 multicast
	 * group.
	 */
	mld6_start_listening(in6m);
	splx(s);
	return(in6m);
}

/*
 * Delete a multicast address record.
 */
void
in6_delmulti(in6m)
	struct in6_multi *in6m;
{
	struct ifmultiaddr *ifma = in6m->in6m_ifma;
	int	s = splnet();

	if (ifma->ifma_refcount == 1) {
		/*
		 * No remaining claims to this record; let MLD6 know
		 * that we are leaving the multicast group.
		 */
		mld6_stop_listening(in6m);
		ifma->ifma_protospec = 0;
		LIST_REMOVE(in6m, in6m_entry);
		free(in6m, M_IPMADDR);
	}
	/* XXX - should be separate API for when we have an ifma? */
	if_delmulti(ifma->ifma_ifp, ifma->ifma_addr);
	splx(s);
}
#endif /* not FreeBSD3 */
d1449 3
a1451 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1475 3
a1477 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1717 3
a1719 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1724 1
a1724 1
			continue; /* XXX: is there any case to allow anycast? */
d1729 2
a1730 1
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
d1806 3
a1808 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1813 1
a1813 1
			continue; /* XXX: is there any case to allow anycast? */
d1818 2
a1819 1
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
d1844 3
a1846 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1851 1
a1851 1
			continue; /* XXX: is there any case to allow anycast? */
d1856 2
a1857 1
		if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DEPRECATED) {
a1885 3
#ifdef __bsdi__
	u_char ea[ETHER_ADDR_LEN];
#else
a1886 1
#endif
d1893 3
a1895 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
d1940 3
a1942 5
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
#endif
a1961 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
#else
a1962 1
#endif
@


1.4
log
@Replace 'in6a_words' (old NRL convention) with 's6_addr32' (new BSDI et al.
convention that is more common and more specific as to the access size)
@
text
@d2 62
a63 8
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
d65 3
a67 1
*/
d70 1
d72 1
d77 1
d79 1
a79 1
#if __NetBSD__ || __FreeBSD__
d81 4
a84 1
#endif /* __NetBSD__ || __FreeBSD__ */
d88 5
a93 1
#include <net/route.h>
d96 19
a114 15

#include <netinet6/in6_var.h>
#include <netinet6/ipv6.h>
#include <netinet6/ipv6_var.h>
#include <netinet6/ipv6_icmp.h>

#ifdef DEBUG_NRL
#include <sys/debug.h>
#else /* DEBUG_NRL */
#if __OpenBSD__
#include <netinet6/debug.h>
#else /* __OpenBSD__ */
#include <sys/debug.h>
#endif /* __OpenBSD__ */
#endif /* DEBUG_NRL */
d117 31
a147 1
 * Globals
d149 1
d151 6
a156 1
struct ifnet *mcastdefault = NULL;   /* Should be changeable by sysctl(). */
d158 15
a172 2
const struct in6_addr in6addr_any = IN6ADDR_ANY_INIT;
const struct in6_addr in6addr_loopback = IN6ADDR_LOOPBACK_INIT;
d175 3
a177 1
 * External globals
d179 25
d205 40
a244 20
extern struct sockaddr_in6 in6_allones;
extern struct in6_ifaddr *in6_ifaddr;
extern struct in6_ifnet *in6_ifnet;
extern int ipv6forwarding;

static void setmcastdef __P((register struct ifnet *));
void del_in6_ifnet __P((struct ifnet *));
struct in6_ifnet *add_in6_ifnet __P((struct ifnet *, int *));
int in6_ifscrub __P((struct ifnet *, struct in6_ifaddr *));
int in6_ifinit __P((register struct ifnet *, register struct in6_ifaddr *, struct sockaddr_in6 *, int, int));
void addrconf_dad __P((struct in6_ifaddr *));

/*----------------------------------------------------------------------
 * Set the default multicast interface.  In single-homed case, this will
 * always be the non-loopback interface.  In multi-homed cases, the function
 * should be able to set one accordingly.  The multicast route entry
 * (ff00::/8) will have its rt_ifp point to this interface, and its rt_ifa
 * point to whatever rtrequest() does.  The rt_ifa should be more intelligently
 * set eventually.
 ----------------------------------------------------------------------*/
d246 5
d252 1
a252 2
setmcastdef(ifp)
     register struct ifnet *ifp;
d254 5
d260 1
a260 7
struct ifaddr *ifa = ifp->if_addrhead.tqh_first;
#else /* __FreeBSD__ */
#if __NetBSD__ || __OpenBSD__
  struct ifaddr *ifa = ifp->if_addrlist.tqh_first;
#else /* __NetBSD__ || __OpenBSD__ */
  struct ifaddr *ifa = ifp->if_addrlist;
#endif /* __NetBSD__ || __OpenBSD__ */
d262 32
a293 15
  struct sockaddr_dl lsdl;
  struct sockaddr_in6 lsin6;
  struct rtentry *newrt=NULL;
  int s;

  if (ifp == mcastdefault)
    return;

  /*
   * If NULL, nuke any mcast entry.
   */

  /*
   * Find link addr for ifp.
   */
d295 77
a371 10
  while (ifa != NULL && ifa->ifa_addr->sa_family != AF_LINK)
#ifdef __FreeBSD__
    ifa = ifa->ifa_link.tqe_next;
#else /* __FreeBSD__ */
#if __NetBSD__ || __OpenBSD__
    ifa = ifa->ifa_list.tqe_next;
#else /* __NetBSD__ || __OpenBSD__ */
    ifa = ifa->ifa_next;
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* __FreeBSD__ */
d373 5
a377 2
  if (ifa == NULL)
    panic("Can't find AF_LINK for new multicast default interface.");
d379 17
a395 62
  bcopy(ifa->ifa_addr,&lsdl,ifa->ifa_addr->sa_len);
  DDO(IDL_EVENT,dump_smart_sockaddr((struct sockaddr *)&lsdl));
  lsdl.sdl_alen = 0;
  lsdl.sdl_slen = 0;
  lsdl.sdl_nlen = 0;

  /*
   * Delete old route, and add new one.
   */

  bzero(&lsin6,sizeof(lsin6));
  lsin6.sin6_family = AF_INET6;
  lsin6.sin6_len = sizeof(lsin6);
  lsin6.sin6_addr.s6_addr[0]=0xff;

  /* Neat property, mask and value are identical! */

  s = splnet();
  rtrequest(RTM_DELETE,(struct sockaddr *)&lsin6,NULL,
	    (struct sockaddr *)&lsin6,0,NULL);
  /*
   *
   * NB: If we clone, we have mcast dests being on a route.  
   *     Consider multihomed system with processes talking to the 
   *     same mcast group, but out different interfaces.
   *
   * Also, the RTM_ADD will do its best to find a "source address" to stick
   * in the rt_ifa field.  (See ipv6_rtrequest.c for this code.)
   */
  rtrequest(RTM_ADD,(struct sockaddr *)&lsin6,(struct sockaddr *)&lsdl,
	    (struct sockaddr *)&lsin6,0,&newrt);
  if (newrt == NULL)
    panic("Assigning default multicast if.");
  newrt->rt_rmx.rmx_mtu = ifp->if_mtu;
  newrt->rt_refcnt--;
  mcastdefault = ifp;
  splx(s);
}

/*----------------------------------------------------------------------
 * Delete an "IPv6 interface".  Only called inside splnet().
 ----------------------------------------------------------------------*/

void
del_in6_ifnet(ifp)
     struct ifnet *ifp;
{
  struct in6_ifnet *i6ifp,*prev = NULL;

  for (i6ifp = in6_ifnet; i6ifp != NULL; i6ifp = i6ifp->i6ifp_next)
    {
      if (i6ifp->i6ifp_ifp == ifp)
	break;
      prev = i6ifp;
    }

  if (i6ifp == NULL)
    panic("Ooooh boy, consistency mismatch in del_in6_ifnet!");

  if (--(i6ifp->i6ifp_numaddrs) == 0)
    {
      while (i6ifp->i6ifp_multiaddrs != NULL)
d397 19
a415 2
	  i6ifp->i6ifp_multiaddrs->in6m_refcount = 1;
	  in6_delmulti(i6ifp->i6ifp_multiaddrs);
d417 6
a422 34
      if (prev == NULL)
	in6_ifnet = i6ifp->i6ifp_next;
      else prev->i6ifp_next = i6ifp->i6ifp_next;
      free(i6ifp,M_I6IFP);
    }
}

/*----------------------------------------------------------------------
 * Add a new "IPv6 interface".  Only called inside splnet().
 * Perhaps send router adverts when this gets called.  For now, they
 * are issued when duplicate address detection succeeds on link-locals.
 * See ipv6_addrconf.c for details.
 ----------------------------------------------------------------------*/

struct in6_ifnet *
add_in6_ifnet(ifp, new)
     struct ifnet *ifp;  /* Assume an in6_ifaddr with this ifp is already
			    allocated and linked into the master list. */
     int *new;           /* XXX */
{
  struct in6_ifnet *i6ifp;

  *new = 0;
  for (i6ifp = in6_ifnet; i6ifp != NULL; i6ifp = i6ifp->i6ifp_next)
    if (i6ifp->i6ifp_ifp == ifp)
      break;

  if (i6ifp == NULL)
    {
      i6ifp = malloc(sizeof(*i6ifp),M_I6IFP,M_NOWAIT);
      if (i6ifp == NULL)
	{
	  printf("DANGER!  Malloc for i6ifp failed.\n");
	  return NULL;
d424 21
a444 17
      i6ifp->i6ifp_ifp = ifp;
      i6ifp->i6ifp_multiaddrs = NULL;
      i6ifp->i6ifp_numaddrs = 1;
      /* Other inits... */
      i6ifp->i6ifp_next = in6_ifnet;
      in6_ifnet = i6ifp;
      *new = 1;
    }

  return i6ifp;
}

/*----------------------------------------------------------------------
 * This function is called by the PRU_CONTROL handlers in both TCP and UDP.
 * (Actually raw_ipv6 might need a PRU_CONTROL handler, but raw_ip doesn't
 * have one.)
 ----------------------------------------------------------------------*/
d447 106
a552 104
#if __NetBSD__ || __FreeBSD__
in6_control(so, cmd, data, ifp, internal, p)
#else /* __NetBSD__ || __FreeBSD__ */
in6_control(so, cmd, data, ifp, internal)
#endif /* __NetBSD__ || __FreeBSD__ */
     struct socket *so;
#if __NetBSD__
     u_long cmd;
#else /* __NetBSD__ */
     int cmd;
#endif /* __NetBSD__ */
     caddr_t data;
     register struct ifnet *ifp;
     int internal;
#if __NetBSD__ || __FreeBSD__
     struct proc *p;
#endif /* __NetBSD__ || __FreeBSD__ */
{
  register struct inet6_ifreq *ifr = (struct inet6_ifreq *)data;
  register struct in6_ifaddr *i6a = 0;
  struct in6_ifaddr *oi6a;
  struct inet6_aliasreq *ifra = (struct inet6_aliasreq *)data;
  struct sockaddr_in6 oldaddr;
  int error, hostIsNew, maskIsNew, ifnetIsNew = 0;
#if !__NetBSD__ && !__OpenBSD__ && !__FreeBSD__
  struct ifaddr *ifa;
#endif /* !__NetBSD__ && !__OpenBSD__ && !__FreeBSD__ */

  /*
   * If given an interface, find first IPv6 address on that interface.
   * I may want to change how this is searched.  I also may want to
   * discriminate between link-local, site-local, v4-compatible, etc.
   *
   * This is used by the SIOCGIFADDR_INET6, and other such things.
   * Those ioctls() currently assume only one IPv6 address on an interface.
   * This is not a good assumption, and this code will have to be modified
   * to correct that assumption.
   */
  if (ifp)
    for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
      if (i6a->i6a_ifp == ifp)
	break;

  switch (cmd)
    {
    case SIOCAIFADDR_INET6:
    case SIOCDIFADDR_INET6:
    case SIOCVIFADDR_INET6:
      /*
       * For adding and deleting an address, find an exact match for
       * that address.  Note that ifr_addr and ifra_addr are in the same
       * place, so even though VIFADDR uses a different struct than AIFADDR,
       * the match will still occur.
       */
      if (ifra->ifra_addr.sin6_family == AF_INET6 &&
			(cmd != SIOCDIFADDR_INET6 ||
			!IN6_IS_ADDR_UNSPECIFIED(&ifra->ifra_addr.sin6_addr)))
	for (oi6a = i6a; i6a; i6a = i6a->i6a_next)
	  {
	    if (i6a->i6a_ifp == ifp &&
		IN6_ARE_ADDR_EQUAL(&i6a->i6a_addr.sin6_addr, &ifra->ifra_addr.sin6_addr))
	      break; /* Out of for loop. */
	  }

      /*
       * You can't delete what you don't have...
       */
      if (cmd == SIOCDIFADDR_INET6 && i6a == 0)
	return EADDRNOTAVAIL;

      /*
       * User program requests verification of address.  No harm done in
       * letting ANY program use this ioctl(), so we put code in for it
       * here.
       *
       * If I found the i6a, check if I'm not sure.  Return EWOULDBLOCK if
       * not sure, return 0 if sure.  Return EADDRNOTAVAIL if not available
       * (i.e. DAD failed.).
       */
      if (cmd == SIOCVIFADDR_INET6) {
	if (i6a == NULL) {
	  return EADDRNOTAVAIL;
	} else {
          if (i6a->i6a_addrflags & I6AF_NOTSURE) {
	    return EWOULDBLOCK;
	  } else {
            return 0;
          }
        }
      }

      /* FALLTHROUGH TO... */

    case SIOCSIFDSTADDR_INET6:
#if __NetBSD__ || __FreeBSD__
      if (p == 0 || (error = suser(p->p_ucred, &p->p_acflag)) )
#else /* __NetBSD__ || __FreeBSD__ */
      if ((so->so_state & SS_PRIV) == 0)
#endif /* __NetBSD__ || __FreeBSD__ */
	return EPERM;

      if (ifp==0)
	panic("in6_control, ifp==0");
      if (i6a == NULL)
a553 1
	  struct in6_ifaddr *tmp;
d555 102
a656 6
	  /*
	   * Create new in6_ifaddr (IPv6 interface address) for additions
	   * and destination settings.
	   */
	  if (!(tmp = (struct in6_ifaddr *)malloc(sizeof(struct in6_ifaddr),
						  M_IFADDR,M_NOWAIT)))
d658 17
a674 1
	      return ENOBUFS;
d676 3
d680 409
a1088 6
	  bzero(tmp,sizeof(struct in6_ifaddr));
	  /*
	   * Set NOTSURE addrflag before putting in list.
	   */
	  tmp->i6a_addrflags = I6AF_NOTSURE;
	  if ((i6a = in6_ifaddr))
d1090 67
a1156 3
	      for (; i6a->i6a_next; i6a=i6a->i6a_next)
		;
	      i6a->i6a_next = tmp;
d1158 2
a1159 11
	  else in6_ifaddr = tmp;
	  i6a = tmp;
#ifdef __FreeBSD__
	  TAILQ_INSERT_TAIL(&ifp->if_addrhead, (struct ifaddr *)i6a,
			    ifa_link);
#else /* __FreeBSD__ */
#if __NetBSD__ || __OpenBSD__
	  TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)i6a,
			    ifa_list);
#else /* __NetBSD__ || __OpenBSD__ */
	  if (ifa = ifp->if_addrlist)
d1161 102
a1262 3
	      for (; ifa->ifa_next; ifa=ifa->ifa_next)
		;
	      ifa->ifa_next = (struct ifaddr *)i6a;
a1263 65
	  else ifp->if_addrlist = (struct ifaddr *)i6a;
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* __FreeBSD__ */
	  i6a->i6a_ifa.ifa_addr = (struct sockaddr *)&i6a->i6a_addr;
	  i6a->i6a_ifa.ifa_dstaddr = (struct sockaddr *)&i6a->i6a_dstaddr;
	  i6a->i6a_ifa.ifa_netmask
	    = (struct sockaddr *)&i6a->i6a_sockmask;
	  i6a->i6a_sockmask.sin6_len = sizeof(struct sockaddr_in6);
	  i6a->i6a_ifp = ifp;

	  /*
	   * Add address to IPv6 interface lists.
	   */
	  i6a->i6a_i6ifp = add_in6_ifnet(ifp, &ifnetIsNew);
	}
      break;
    case SIOCGIFADDR_INET6:
    case SIOCGIFNETMASK_INET6:
    case SIOCGIFDSTADDR_INET6:
      /*
       * Can't get information on what is not there...
       */
      if (i6a == NULL)
	return EADDRNOTAVAIL;
      break;

    default:
      return EOPNOTSUPP;
    }

  switch (cmd)
    {
      /*
       * The following three cases assume that there is only one address per
       * interface; this is not good in IPv6-land.  Unfortunately, the
       * ioctl() interface, is such that I'll have to rewrite the way things
       * work here, either that, or curious user programs will have to troll
       * /dev/kmem (like netstat(8) does).
       */
    case SIOCGIFADDR_INET6:
      bcopy(&(i6a->i6a_addr),&(ifr->ifr_addr),sizeof(struct sockaddr_in6));
      break;

    case SIOCGIFDSTADDR_INET6:
      if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
	return EINVAL;
      bcopy(&(i6a->i6a_dstaddr),&(ifr->ifr_dstaddr),
	    sizeof(struct sockaddr_in6));
      break;

    case SIOCGIFNETMASK_INET6:
      bcopy(&(i6a->i6a_sockmask),&(ifr->ifr_addr),sizeof(struct sockaddr_in6));
      break;

    case SIOCSIFDSTADDR_INET6:
      i6a->i6a_addrflags &= ~I6AF_NOTSURE;
      if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
	return EINVAL;
      oldaddr = i6a->i6a_dstaddr;
      i6a->i6a_dstaddr = *(struct sockaddr_in6 *)&ifr->ifr_dstaddr;
      if (ifp->if_ioctl && (error = (*ifp->if_ioctl)(ifp, SIOCSIFDSTADDR,
						     (caddr_t)i6a)))
	{
	  i6a->i6a_dstaddr = oldaddr;
	  return error;
d1265 203
a1467 24
      if (i6a->i6a_flags & IFA_ROUTE)
	{
	  i6a->i6a_ifa.ifa_dstaddr = (struct sockaddr *)&oldaddr;
	  rtinit(&(i6a->i6a_ifa), RTM_DELETE, RTF_HOST);
	  i6a->i6a_ifa.ifa_dstaddr = (struct sockaddr *)&i6a->i6a_dstaddr;
	  rtinit(&(i6a->i6a_ifa), RTM_ADD, RTF_HOST|RTF_UP);
	}
      break;

      /*
       * For adding new IPv6 addresses to an interface, I stuck to the way
       * that IPv4 uses, pretty much.
       */
    case SIOCAIFADDR_INET6:
      maskIsNew = 0;
      hostIsNew = 1;
      error = 0;
      if (i6a->i6a_addr.sin6_family == AF_INET6) {
	if (ifra->ifra_addr.sin6_len == 0) {
	  {
	    bcopy(&(i6a->i6a_addr),&(ifra->ifra_addr),
		  sizeof(struct sockaddr_in6));
	    hostIsNew = 0;
	  }
d1469 193
a1661 4
          if (IN6_ARE_ADDR_EQUAL(&ifra->ifra_addr.sin6_addr, &i6a->i6a_addr.sin6_addr))
	    hostIsNew = 0;
        }
      }
d1663 5
a1667 1
      if (ifra->ifra_mask.sin6_len)
d1669 6
a1674 4
	  in6_ifscrub(ifp,i6a);
	  bcopy(&(ifra->ifra_mask),&(i6a->i6a_sockmask),
		sizeof(struct sockaddr_in6));
	  maskIsNew = 1;
d1677 3
a1679 12
      if ((ifp->if_flags & IFF_POINTOPOINT) &&
	  (ifra->ifra_dstaddr.sin6_family == AF_INET6))
	{
	  in6_ifscrub(ifp,i6a);
	  bcopy(&(ifra->ifra_dstaddr),&(i6a->i6a_dstaddr),
		sizeof(struct sockaddr_in6));
	  maskIsNew = 1;  /* We lie, simply so that in6_ifinit() will be
			     called to initialize the peer's address. */
	}
      if (ifra->ifra_addr.sin6_family == AF_INET6 && (hostIsNew || maskIsNew))
	error = in6_ifinit(ifp,i6a,&ifra->ifra_addr,0,!internal);
      /* else i6a->i6a_addrflags &= ~I6AF_NOTSURE; */
d1681 9
a1689 2
      if (error == EEXIST)   /* XXX, if route exists, we should be ok */
	error = 0;
d1691 5
a1695 1
      if (hostIsNew && !ifnetIsNew /* && (!error || error == EEXIST) */) 
d1697 7
a1703 13
	  if (i6a->i6a_i6ifp)
	    i6a->i6a_i6ifp->i6ifp_numaddrs++;
	  else
	    panic("in6_control: missing i6ifp");
	}
      return error;

    case SIOCDIFADDR_INET6:
      in6_ifscrub(ifp, i6a);
      /*
       * If last address on this interface, delete IPv6 interface record.
       */
      del_in6_ifnet(ifp);
d1705 52
a1756 17
#ifdef __FreeBSD__
      TAILQ_REMOVE(&ifp->if_addrhead, (struct ifaddr *)i6a, ifa_link);
#else /* __FreeBSD__ */
#if __NetBSD__ || __OpenBSD__
      TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)i6a, ifa_list);
#else /* __NetBSD__ || __OpenBSD__ */
      if ((ifa = ifp->if_addrlist) == (struct ifaddr *)i6a)
	ifp->if_addrlist = ifa->ifa_next;
      else
	{
	  while (ifa->ifa_next &&
		 (ifa->ifa_next != (struct ifaddr *)i6a))
	    ifa=ifa->ifa_next;
	  if (ifa->ifa_next)
	    ifa->ifa_next = i6a->i6a_ifa.ifa_next;
	  else 
	    DPRINTF(IDL_ERROR, ("Couldn't unlink in6_ifaddr from ifp!\n"));
d1758 20
a1777 31
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* __FreeBSD__ */
      oi6a = i6a;
      if (oi6a == (i6a = in6_ifaddr))
	in6_ifaddr = i6a->i6a_next;
      else
	{
	  while (i6a->i6a_next && (i6a->i6a_next != oi6a))
	    i6a = i6a->i6a_next;
	  if (i6a->i6a_next)
	    i6a->i6a_next = oi6a->i6a_next;
	  else 
	    DPRINTF(IDL_ERROR, ("Didn't unlink in6_ifaddr from list.\n"));
	}
      IFAFREE((&oi6a->i6a_ifa));  /* For the benefit of routes pointing
				     to this ifa. */
      break;

    default:
      DPRINTF(IDL_ERROR, 
	      ("in6_control(): Default case not implemented.\n"));
      return EOPNOTSUPP;
    }

  return 0;
}

/*----------------------------------------------------------------------
 * in6_ifscrub:   
 *     Delete any existing route for an IPv6 interface.
 ----------------------------------------------------------------------*/
d1779 3
d1783 2
a1784 3
in6_ifscrub(ifp,i6a)
     register struct ifnet *ifp;
     register struct in6_ifaddr *i6a;
d1786 18
a1803 2
  if (!(i6a->i6a_flags & IFA_ROUTE))
    return 1;
d1805 2
a1806 5
  if (ifp->if_flags & (IFF_LOOPBACK|IFF_POINTOPOINT))
    rtinit(&(i6a->i6a_ifa), (int)RTM_DELETE, RTF_HOST);
  else
    rtinit(&(i6a->i6a_ifa), (int)RTM_DELETE, 0);
  i6a->i6a_flags &= ~IFA_ROUTE;
d1808 28
a1835 1
  return 0;
d1838 24
a1861 6
/*----------------------------------------------------------------------
 * Initialize an IPv6 address for an interface.
 *
 * When I get around to doing duplicate address detection, this is probably
 * the place to do it.
 ----------------------------------------------------------------------*/
d1864 76
a1939 59
in6_ifinit(ifp, i6a, sin6, scrub, useDAD)
     register struct ifnet *ifp;
     register struct in6_ifaddr *i6a;
     struct sockaddr_in6 *sin6;
     int scrub;
     int useDAD;
{
  int s, error, flags = RTF_UP;
  struct sockaddr_in6 oldaddr;

  DPRINTF(IDL_EVENT,("Before splimp in in6_ifinit()\n"));
  s = splimp();

  bcopy(&(i6a->i6a_addr),&oldaddr,sizeof(struct sockaddr_in6));
  bcopy(sin6,&(i6a->i6a_addr),sizeof(struct sockaddr_in6));

  /*
   * Give the interface a chance to initialize
   * if this is its first address,
   * and to validate the address if necessary.
   */

  if (ifp->if_ioctl && (error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR,
						 (caddr_t)i6a)))
    { 
      bcopy(&oldaddr,&(i6a->i6a_addr),sizeof(struct sockaddr_in6));
      splx(s);
      return error;
    }

  /*
   * IPv4 in 4.4BSD sets the RTF_CLONING flag here if it's an Ethernet.
   * I delay this until later.
   */

  splx(s);
  DPRINTF(IDL_EVENT,("After splx() in in6_ifinit().\n"));

  sin6->sin6_port = 0;

  if (scrub)
    {
      i6a->i6a_ifa.ifa_addr = (struct sockaddr *)&oldaddr;
      in6_ifscrub(ifp, i6a);
      i6a->i6a_ifa.ifa_addr = (struct sockaddr *)&i6a->i6a_addr;
    }

  /*
   * Adjust the sin6_len such that it only counts mask bytes with
   * 1's in them.
   */

  {
    register char *cpbase = (char *)&(i6a->i6a_sockmask.sin6_addr);
    register char *cp = cpbase + sizeof(struct in6_addr);

    i6a->i6a_sockmask.sin6_len = 0;
    while (--cp >=cpbase)
      if (*cp)
d1941 29
a1969 2
	  i6a->i6a_sockmask.sin6_len = 1 + cp - (char *)&(i6a->i6a_sockmask);
	  break;
d1971 2
a1972 1
  }
d1974 27
a2000 23
  /*
   * Add route.  Also, set some properties of the interface address here.
   * (Properties include permanance, lifetime, etc.)
   */

  i6a->i6a_ifa.ifa_metric = ifp->if_metric;
  i6a->i6a_ifa.ifa_rtrequest = ipv6_rtrequest;  /* Want this to be true
						   for ALL IPv6 ifaddrs. */
  if (ifp->if_flags & IFF_LOOPBACK)
    {
      useDAD = 0;
      i6a->i6a_ifa.ifa_dstaddr = i6a->i6a_ifa.ifa_addr;
      flags |= RTF_HOST;

      /* Loopback is definitely a permanent address. */
      if (IN6_IS_ADDR_LOOPBACK(&i6a->i6a_addr.sin6_addr))
	i6a->i6a_addrflags |= I6AF_PERMANENT;
    }
  else if (ifp->if_flags & IFF_POINTOPOINT)
    {
      useDAD = 0;  /* ??!!?? */
      if (i6a->i6a_dstaddr.sin6_family != AF_INET6)
	return 0;
d2002 4
a2005 9
      flags |= RTF_HOST;
    }
  else 
    {
      /*
       * No b-cast in IPv6, therefore the ifa_broadaddr (concidentally the
       * dest address filled in above...) should be set to NULL!
       */
      i6a->i6a_ifa.ifa_broadaddr = NULL;
d2007 23
a2029 1
      if (IN6_IS_ADDR_LINKLOCAL(&i6a->i6a_addr.sin6_addr))
d2031 32
a2062 2
	  flags |= RTF_HOST;
	  i6a->i6a_ifa.ifa_dstaddr = i6a->i6a_ifa.ifa_addr;
d2064 19
a2082 19
	  /*
	   * Possibly do other stuff specific to link-local addresses, hence
	   * keeping this separate from IFF_LOOPBACK case above.  I may move
	   * the link-local check to || with IFF_LOOPBACK.
	   *
	   * Other stuff includes setting i6a_preflen so when addrconf
	   * needs to know what part of the link-local is used for uniqueness,
	   * it doesn't have to gyrate.
	   */
	  switch(i6a->i6a_ifp->if_type)
	    {
	    case IFT_ETHER:
	      i6a->i6a_preflen = 64;
	      break;
	    default:
	      DPRINTF(IDL_ERROR,("Can't set i6a_preflen for type %d.\n",\
				    i6a->i6a_ifp->if_type));
	      break;
	    }
d2084 1
a2084 1
	  i6a->i6a_addrflags |= (I6AF_LINKLOC | I6AF_PERMANENT);
a2085 59
      else
	{
	  if (!(i6a->i6a_sockmask.sin6_len == sizeof(struct sockaddr_in6) &&
		IN6_ARE_ADDR_EQUAL(&i6a->i6a_sockmask.sin6_addr, &in6_allones.sin6_addr)))
	    flags |= RTF_CLONING;  /* IMHO, ALL network routes
				      have the cloning bit set for next-hop
				      resolution if they aren't loopback or
				      pt. to pt. */
	  i6a->i6a_addrflags |= I6AF_PREFIX;  /* I'm a 'prefix list entry'. */
	}
    }

  if ((error = rtinit(&(i6a->i6a_ifa), RTM_ADD,flags)) == 0)
    {
      i6a->i6a_flags |= IFA_ROUTE;
    }

  /*
   * If the interface supports multicast, join the appropriate
   * multicast groups (all {nodes, routers}) on that interface.
   *
   * Also join the solicited nodes discovery multicast group for that
   * destination.
   */
  if (ifp->if_flags & IFF_MULTICAST)
    {
      struct in6_multi *rc;
      
      /* NOTE2:  Set default multicast interface here.
                 Set up cloning route for ff00::0/8 */
      if (ifp->if_type != IFT_LOOP && mcastdefault == NULL)
	setmcastdef(ifp);

      {
        struct in6_addr addr = IN6ADDR_ALLNODES_INIT;

        rc = in6_addmulti(&addr, ifp);
      };

      /* All-routers, if forwarding */
      if (ipv6forwarding) {
        struct in6_addr addr = IN6ADDR_ALLROUTERS_INIT;

	rc = in6_addmulti(&addr, ifp);
      };

      {
        struct in6_addr addr = IN6ADDR_ALLHOSTS_INIT;

        rc = in6_addmulti(&addr, ifp);
      };

      /* Solicited-nodes. */
      {
        struct in6_addr addr = IN6ADDR_SN_PREFIX_INIT;

	addr.s6_addr[13] = i6a->i6a_addr.sin6_addr.s6_addr32[13];
	addr.s6_addr[14] = i6a->i6a_addr.sin6_addr.s6_addr32[14];
	addr.s6_addr[15] = i6a->i6a_addr.sin6_addr.s6_addr32[15];
d2087 5
a2091 1
        DDO(IDL_EVENT, dump_in6_addr(&addr));
d2093 2
a2094 2
        rc=in6_addmulti(&addr, ifp);
      };
d2096 27
a2122 57
#if 0
      addr.s6_addr32[0] = htonl(0xff020000);
      addr.s6_addr32[1] = 0;
      addr.s6_addr32[2] = htonl(1);
      addr.s6_addr32[3] = i6a->i6a_addr.sin6_addr.s6_addr32[3] | htonl(0xff000000);
#endif /* 0 */
    }

  if (useDAD /*&& error != 0*/)
    addrconf_dad(i6a);
  else
    i6a->i6a_addrflags &= ~I6AF_NOTSURE;

  return error;
}

/*----------------------------------------------------------------------
 * Add IPv6 multicast address.  IPv6 multicast addresses are handled
 * pretty much like IP multicast addresses for now.
 *
 * Multicast addresses hang off in6_ifaddr's.  Eventually, they should hang
 * off the link-local multicast address, this way, there are no ambiguities.
 ----------------------------------------------------------------------*/

struct in6_multi *in6_addmulti(addr,ifp)
     register struct in6_addr *addr;
     struct ifnet *ifp;

{
  register struct in6_multi *in6m;
  struct inet6_ifreq ifr;
  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ifr.ifr_addr;
  struct in6_ifnet *i6ifp;
  int s = splnet();

  /*
   * See if address is already in list..
   */

  IN6_LOOKUP_MULTI(addr,ifp,in6m);

  if (in6m != NULL)
    {
      /* Increment the reference count. */
      in6m->in6m_refcount++;
    }
  else
    {
#if __FreeBSD__
      struct ifmultiaddr *ifma;
#endif /* __FreeBSD__ */
      /*
       * Otherwise, allocate a new m-cast record and link it to
       * the interface's multicast list.
       */
      
      if ((in6m=malloc(sizeof(struct in6_multi),M_IPMADDR,M_NOWAIT)) == NULL)
d2124 8
a2131 2
	  splx(s);
	  return NULL;
d2133 39
a2171 9
      bzero(in6m,sizeof(struct in6_multi));
      in6m->in6m_addr = *addr;
      in6m->in6m_refcount = 1;
      in6m->in6m_ifp = ifp;

      for(i6ifp = in6_ifnet; i6ifp != NULL && i6ifp->i6ifp_ifp != ifp;
	  i6ifp = i6ifp->i6ifp_next)
	;
      if (i6ifp == NULL)
d2173 23
a2195 25
	  free(in6m,M_IPMADDR);
	  splx(s);
	  return NULL;
	}
      in6m->in6m_i6ifp = i6ifp;
      in6m->in6m_next = i6ifp->i6ifp_multiaddrs;
      i6ifp->i6ifp_multiaddrs = in6m;

      /*
       * Ask the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      sin6->sin6_family=AF_INET6;
      sin6->sin6_len=sizeof(struct sockaddr_in6);
      sin6->sin6_addr = *addr;
      sin6->sin6_port = 0;
      sin6->sin6_flowinfo = 0;


#if __FreeBSD__
      if (if_addmulti(ifp, (struct sockaddr *) sin6, &ifma))
#else /* __FreeBSD */
      if (ifp->if_ioctl == NULL ||
	  (*ifp->if_ioctl)(ifp, SIOCADDMULTI,(caddr_t)&ifr) != 0)
#endif /* __FreeBSD__ */
d2197 3
a2199 4
	  i6ifp->i6ifp_multiaddrs = in6m->in6m_next;
	  free(in6m,M_IPMADDR);
	  splx(s);
	  return NULL;
d2201 31
a2231 9
#ifdef __FreeBSD__
      ifma->ifma_protospec = in6m;
#endif /* __FreeBSD__ */
      
      /* Tell IGMP that we've joined a new group. */
      /*ipv6_igmp_joingroup(in6m);*/
    }
  splx(s);
  return in6m;
d2234 6
a2239 3
/*----------------------------------------------------------------------
 * Delete IPv6 multicast address.
 ----------------------------------------------------------------------*/
d2241 10
d2252 1
a2252 2
in6_delmulti(in6m)
     register struct in6_multi *in6m;
d2254 9
a2262 32
  register struct in6_multi **p;
  struct inet6_ifreq ifr;
  struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&(ifr.ifr_addr);
  int s = splnet();

  if (--in6m->in6m_refcount == 0)
    {
      /* Tell IGMP that I'm bailing this group. */
      /* ipv6_igmp_leavegroup(in6m);*/

      /* Unlink from list. */
      for (p = &(in6m->in6m_i6ifp->i6ifp_multiaddrs);
	   *p != in6m;
	   p = &(*p)->in6m_next)
	;
      *p = (*p)->in6m_next;

      /*
       * Notify the network driver to update its multicast reception
       * filter.
       */
      sin6->sin6_family = AF_INET6;
      sin6->sin6_len = sizeof(struct sockaddr_in6);
      sin6->sin6_port = 0;
      sin6->sin6_flowinfo = 0;
      sin6->sin6_addr = in6m->in6m_addr;
      (*(in6m->in6m_ifp->if_ioctl))(in6m->in6m_ifp, SIOCDELMULTI,
					 (caddr_t)&ifr);

      free(in6m,M_IPMADDR);
    }
  splx(s);
d2264 2
@


1.3
log
@Demangled the INET6 stuff so as not to require any extra options and not to
be mutually exclusive with the IPSEC option.
@
text
@d780 3
a782 3
	addr.s6_addr[13] = i6a->i6a_addr.sin6_addr.in6a_words[13];
	addr.s6_addr[14] = i6a->i6a_addr.sin6_addr.in6a_words[14];
	addr.s6_addr[15] = i6a->i6a_addr.sin6_addr.in6a_words[15];
d790 4
a793 4
      addr.in6a_words[0] = htonl(0xff020000);
      addr.in6a_words[1] = 0;
      addr.in6a_words[2] = htonl(1);
      addr.in6a_words[3] = i6a->i6a_addr.sin6_addr.in6a_words[3] | htonl(0xff000000);
@


1.2
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d36 1
a36 1
#ifdef DEBUG_NRL_SYS
d38 2
a39 2
#endif /* DEBUG_NRL_SYS */
#ifdef DEBUG_NRL_NETINET6
d41 4
a44 1
#endif /* DEBUG_NRL_NETINET6 */
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@d36 1
d38 4
d319 2
a320 2
      if (cmd == SIOCVIFADDR_INET6)
	if (i6a == NULL)
d322 8
a329 3
	else if (i6a->i6a_addrflags & I6AF_NOTSURE)
	  return EWOULDBLOCK;
	else return 0;
d467 2
a468 2
      if (i6a->i6a_addr.sin6_family == AF_INET6)
	if (ifra->ifra_addr.sin6_len == 0)
d474 5
a478 2
	else if (IN6_ARE_ADDR_EQUAL(&ifra->ifra_addr.sin6_addr, &i6a->i6a_addr.sin6_addr))
	  hostIsNew = 0;
a746 1
      struct in6_addr addr;
d754 5
a758 4
      /* All-nodes. */
      SET_IN6_ALLNODES(addr);
      SET_IN6_MCASTSCOPE(addr,IN6_INTRA_LINK);
      rc = in6_addmulti(&addr, ifp);
d762 2
a763 2
	SET_IN6_ALLROUTERS(addr);
	SET_IN6_MCASTSCOPE(addr, IN6_INTRA_LINK);
d767 6
d774 13
d791 1
a791 4

      DDO(IDL_EVENT, dump_in6_addr(&addr));

      rc=in6_addmulti(&addr, ifp);
@

