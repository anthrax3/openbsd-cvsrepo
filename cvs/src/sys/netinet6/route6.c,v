head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.2
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.4
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.4
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.6
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.22
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.10.0.14
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.12
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.10
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.8
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.8
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.20;
commitid	00hB28wQPwG5Ysk0;

1.20
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.19;
commitid	2R0NOjEDy2jGtnjL;

1.19
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.18;
commitid	t9FBKDfc4VDxpEy2;

1.18
date	2013.10.19.21.25.15;	author bluhm;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.16;

1.16
date	2007.05.31.23.17.38;	author mcbride;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.21.16.47.42;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.27.05.12.13;	author itojun;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.08.21.49.03;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.08.21.32.27;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches
	1.10.12.1
	1.10.14.1;
next	1.9;

1.9
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.06.08.00.08.40;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.16.08.48.07;	author itojun;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2001.02.16.08.22.07;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.02.04.44.08;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	99.12.08.06.50.24;	author itojun;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.40.21;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2000.10.21.05.28.44;	author jason;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.5.6.3;

1.5.6.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.10.12.1
date	2007.04.23.07.39.48;	author mbalmer;	state Exp;
branches;
next	;

1.10.14.1
date	2007.04.22.19.48.14;	author mbalmer;	state Exp;
branches;
next	;

1.14.2.1
date	2007.04.28.05.01.02;	author ckuethe;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: route6.c,v 1.20 2017/02/05 16:04:14 jca Exp $	*/
/*	$KAME: route6.c,v 1.22 2000/12/03 00:54:00 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>

#include <netinet/icmp6.h>

/*
 * proto is unused
 */

int
route6_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct ip6_hdr *ip6;
	struct mbuf *m = *mp;
	struct ip6_rthdr *rh;
	int off = *offp, rhlen;

	ip6 = mtod(m, struct ip6_hdr *);
	IP6_EXTHDR_GET(rh, struct ip6_rthdr *, m, off, sizeof(*rh));
	if (rh == NULL) {
		ip6stat_inc(ip6s_tooshort);
		return IPPROTO_DONE;
	}

	switch (rh->ip6r_type) {
	case IPV6_RTHDR_TYPE_0:
		/*
		 * RFC 5095 specifies to handle routing header type 0
		 * the same way as an unrecognised routing type.
		 */
		/* FALLTHROUGH */
	default:
		/* unknown routing type */
		if (rh->ip6r_segleft == 0) {
			rhlen = (rh->ip6r_len + 1) << 3;
			break;	/* Final dst. Just ignore the header. */
		}
		ip6stat_inc(ip6s_badoptions);
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    (caddr_t)&rh->ip6r_type - (caddr_t)ip6);
		return (IPPROTO_DONE);
	}

	*offp += rhlen;
	return (rh->ip6r_nxt);
}
@


1.20
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.19 2014/12/05 15:50:04 mpi Exp $	*/
d53 1
a53 1
route6_input(struct mbuf **mp, int *offp, int proto)
@


1.19
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.18 2013/10/19 21:25:15 bluhm Exp $	*/
d63 1
a63 1
		ip6stat.ip6s_tooshort++;
d80 1
a80 1
		ip6stat.ip6s_badoptions++;
@


1.18
log
@Our IPv6 stack was scanning all extension headers for routing header
type 0 and dropped the packet if it found one.  RFC 5095 demands
to handle a routing header type 0 like an unrecognised routing type.
This is enough to protect the own machine.

To protect a network as a firewall, we have pf which does the same
full scan in pf_walk_header6().  As pf is enabled by default, nothing
changes for most users.  If you turn off pf on your router, you
should not expect extra protection.

Get rid of the double scanning in ip6_input() and and the older
disabled code in route6_input().  No more special treatment of
routing header type 0 in the IPv6 stack.

OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.17 2008/06/11 19:00:50 mcbride Exp $	*/
d39 1
@


1.17
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.16 2007/05/31 23:17:38 mcbride Exp $	*/
a46 4
#if 0
static int ip6_rthdr0(struct mbuf *, struct ip6_hdr *, struct ip6_rthdr0 *);
#endif

a66 16
#if 0
	/*
	 * See http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf
	 * for why IPV6_RTHDR_TYPE_0 is banned here.
	 *
	 * We return ICMPv6 parameter problem so that innocent people
	 * (not an attacker) would notice about the use of IPV6_RTHDR_TYPE_0.
	 * Since there's no amplification, and ICMPv6 error will be rate-
	 * controlled, it shouldn't cause any problem.
	 * If you are concerned about this, you may want to use the following
	 * code fragment:
	 *
	 * case IPV6_RTHDR_TYPE_0:
	 *	m_freem(m);
	 *	return (IPPROTO_DONE);
	 */
a67 3
		rhlen = (rh->ip6r_len + 1) << 3;
		if (rh->ip6r_segleft == 0)
			break;	/* Final dst. Just ignore the header. */
d69 2
a70 6
		 * note on option length:
		 * maximum rhlen: 2048
		 * max mbuf m_pulldown can handle: MCLBYTES == usually 2048
		 * so, here we are assuming that m_pulldown can handle
		 * rhlen == 2048 case.  this may not be a good thing to
		 * assume - we may want to avoid pulling it up altogether.
d72 1
a72 9
		IP6_EXTHDR_GET(rh, struct ip6_rthdr *, m, off, rhlen);
		if (rh == NULL) {
			ip6stat.ip6s_tooshort++;
			return IPPROTO_DONE;
		}
		if (ip6_rthdr0(m, ip6, (struct ip6_rthdr0 *)rh))
			return (IPPROTO_DONE);
		break;
#endif
a87 80

#if 0
/*
 * Type0 routing header processing
 *
 * RFC2292 backward compatibility warning: no support for strict/loose bitmap,
 * as it was dropped between RFC1883 and RFC2460.
 */
static int
ip6_rthdr0(struct mbuf *m, struct ip6_hdr *ip6, struct ip6_rthdr0 *rh0)
{
	int addrs, index;
	struct in6_addr *nextaddr, tmpaddr;

	if (rh0->ip6r0_segleft == 0)
		return (0);

	if (rh0->ip6r0_len % 2) {
		/*
		 * Type 0 routing header can't contain more than 23 addresses.
		 * RFC 2460: this limitation was removed since strict/loose
		 * bitmap field was deleted.
		 */
		ip6stat.ip6s_badoptions++;
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    (caddr_t)&rh0->ip6r0_len - (caddr_t)ip6);
		return (-1);
	}

	if ((addrs = rh0->ip6r0_len / 2) < rh0->ip6r0_segleft) {
		ip6stat.ip6s_badoptions++;
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    (caddr_t)&rh0->ip6r0_segleft - (caddr_t)ip6);
		return (-1);
	}

	index = addrs - rh0->ip6r0_segleft;
	rh0->ip6r0_segleft--;
	nextaddr = ((struct in6_addr *)(rh0 + 1)) + index;

	/*
	 * reject invalid addresses.  be proactive about malicious use of
	 * IPv4 mapped/compat address.
	 * XXX need more checks?
	 */
	if (IN6_IS_ADDR_MULTICAST(nextaddr) ||
	    IN6_IS_ADDR_UNSPECIFIED(nextaddr) ||
	    IN6_IS_ADDR_V4MAPPED(nextaddr) ||
	    IN6_IS_ADDR_V4COMPAT(nextaddr)) {
		ip6stat.ip6s_badoptions++;
		goto bad;
	}
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) {
		ip6stat.ip6s_badoptions++;
		goto bad;
	}

	/*
	 * Swap the IPv6 destination address and nextaddr. Forward the packet.
	 */
	tmpaddr = *nextaddr;
	*nextaddr = ip6->ip6_dst;
	if (IN6_IS_ADDR_LINKLOCAL(nextaddr))
		nextaddr->s6_addr16[1] = 0;
	ip6->ip6_dst = tmpaddr;
	if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

	ip6_forward(m, 1);

	return (-1);			/* m would be freed in ip6_forward() */

  bad:
	m_freem(m);
	return (-1);
}
#endif
@


1.16
log
@Sync comment regarding rthdr0 w/ kame tree.

from itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.15 2007/04/21 16:47:42 itojun Exp $	*/
d51 4
d56 1
a56 3
route6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;	/* proto is unused */
d132 1
a132 4
ip6_rthdr0(m, ip6, rh0)
	struct mbuf *m;
	struct ip6_hdr *ip6;
	struct ip6_rthdr0 *rh0;
@


1.15
log
@did you know that IPv6 packets are actually carried by turtles?
because turtles are slow but reliable and trustworthy, packets stays
on the net for a long period of time.  bigger turtles can stay much longer.
that is the hidden secret reason for the name of KAME project (i'm lying).

j> some IETFers need to be sent to bondage/SM club and spanked/whipped
j> by thousands of dominas and then chopped into million peaces by samurai
j> swords.
t> maybe that is what they actually want, and that is why they
t> fucked RFC1883 and put rosemary's baby into RFC2460.
j> I am king of IETF now, and tomorrow i may become beggar on the IETF venue
j> hotel corridor.

http://www.secdev.org/conf/IPv6_RH_security-csw07.pdf

ok by myself, deraadt@@, <samurais at kame.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.14 2006/12/27 05:12:13 itojun Exp $	*/
d70 15
@


1.14
log
@correct rhlen computation (if the "if" clause on the next line is taken,
we will use rhlen uninitialized).  checked with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.13 2006/12/09 01:12:28 itojun Exp $	*/
d47 1
d49 1
d69 1
d90 1
d107 1
d188 1
@


1.14.2.1
log
@IPv6 routing headers are a type of 'super source routing', and pose a
significant and serious risk to hosts and the internet.  That this
host-controlled routing even came into existance once again shows how
broken the IETF process is.  Disable this source routing, with
prejudice.
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.14 2006/12/27 05:12:13 itojun Exp $	*/
a46 1
#if 0
a47 1
#endif
a66 1
#if 0
a86 1
#endif
a102 1
#if 0
a182 1
#endif
@


1.13
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.12 2006/12/08 21:49:03 itojun Exp $	*/
d68 1
a70 1
		rhlen = (rh->ip6r_len + 1) << 3;
@


1.12
log
@typo in comment.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.11 2006/12/08 21:32:27 itojun Exp $	*/
d47 1
a47 2
static int ip6_rthdr0(struct mbuf *, struct ip6_hdr *,
    struct ip6_rthdr0 *);
d68 2
@


1.11
log
@unifdef -UCOMPAT_RFC1883 (ancient)
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.10 2003/06/11 02:54:02 itojun Exp $	*/
d123 1
a123 1
		 * RFC 2462: this limitation was removed since strict/loose
@


1.10
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.9 2003/05/14 14:24:44 itojun Exp $	*/
d120 1
a120 5
	if (rh0->ip6r0_len % 2
#ifdef COMPAT_RFC1883
	    || rh0->ip6r0_len > 46
#endif
		) {
a173 6
#ifdef COMPAT_RFC1883
	if (rh0->ip6r0_slmap[index / 8] & (1 << (7 - (index % 8))))
		ip6_forward(m, IPV6_SRCRT_NEIGHBOR);
	else
		ip6_forward(m, IPV6_SRCRT_NOTNEIGHBOR);
#else
a174 1
#endif
@


1.10.12.1
log
@IPv6 routing headers are a type of 'super source routing', and pose a
significant and serious risk to hosts and the internet.  That this
host-controlled routing even came into existance once again shows how
broken the IETF process is.  Disable this source routing, with
prejudice.
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.15 2007/04/21 16:47:42 itojun Exp $	*/
a46 1
#if 0
a48 1
#endif
a67 1
#if 0
a85 1
#endif
a101 1
#if 0
a192 1
#endif
@


1.10.14.1
log
@IPv6 routing headers are a type of 'super source routing', and pose a
significant and serious risk to hosts and the internet.  That this
host-controlled routing even came into existance once again shows how
broken the IETF process is.  Disable this source routing, with
prejudice.

(a fix for 3.9-stable and an errata will follow soon)
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.15 2007/04/21 16:47:42 itojun Exp $	*/
a46 1
#if 0
a48 1
#endif
a67 1
#if 0
a85 1
#endif
a101 1
#if 0
a192 1
#endif
@


1.9
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.8 2002/09/11 03:15:36 itojun Exp $	*/
d104 3
d145 1
a145 1
	nextaddr = rh0->ip6r0_addr + index;
d157 1
a157 2
		m_freem(m);
		return (-1);
d164 1
a164 2
		m_freem(m);
		return (-1);
d188 4
@


1.8
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.7 2002/06/08 00:08:40 itojun Exp $	*/
a59 5
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*rh), IPPROTO_DONE);
	ip6 = mtod(m, struct ip6_hdr *);
	rh = (struct ip6_rthdr *)((caddr_t)ip6 + off);
#else
a65 1
#endif
a69 8
#ifndef PULLDOWN_TEST
		/*
		 * note on option length:
		 * due to IP6_EXTHDR_CHECK assumption, we cannot handle
		 * very big routing header (max rhlen == 2048).
		 */
		IP6_EXTHDR_CHECK(m, off, rhlen, IPPROTO_DONE);
#else
a82 1
#endif
@


1.7
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.6 2002/03/14 01:27:12 millert Exp $	*/
d99 1
a99 1
			return(IPPROTO_DONE);
d110 1
a110 1
		return(IPPROTO_DONE);
d114 1
a114 1
	return(rh->ip6r_nxt);
d130 1
a130 1
		return(0);
d145 1
a145 1
		return(-1);
d152 1
a152 1
		return(-1);
d170 1
a170 1
		return(-1);
d178 1
a178 1
		return(-1);
d201 1
a201 1
	return(-1);			/* m would be freed in ip6_forward() */
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.5 2001/02/16 08:48:07 itojun Exp $	*/
d139 1
a139 1
		 * RFC 2462: this limitation was removed since stict/loose
@


1.5
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.4 2001/02/16 08:22:07 itojun Exp $	*/
d47 2
a48 2
static int ip6_rthdr0 __P((struct mbuf *, struct ip6_hdr *,
    struct ip6_rthdr0 *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.5 2001/02/16 08:48:07 itojun Exp $	*/
d47 2
a48 2
static int ip6_rthdr0(struct mbuf *, struct ip6_hdr *,
    struct ip6_rthdr0 *);
d139 1
a139 1
		 * RFC 2462: this limitation was removed since strict/loose
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.5.6.1 2002/06/11 03:31:38 art Exp $	*/
d99 1
a99 1
			return (IPPROTO_DONE);
d110 1
a110 1
		return (IPPROTO_DONE);
d114 1
a114 1
	return (rh->ip6r_nxt);
d130 1
a130 1
		return (0);
d145 1
a145 1
		return (-1);
d152 1
a152 1
		return (-1);
d170 1
a170 1
		return (-1);
d178 1
a178 1
		return (-1);
d201 1
a201 1
	return (-1);			/* m would be freed in ip6_forward() */
@


1.5.6.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 5
d71 1
d76 8
d97 1
@


1.4
log
@kill register declarations.  to sync with kame better.
@
text
@d1 2
a2 2
/*	$OpenBSD: route6.c,v 1.3 2000/10/02 04:44:08 itojun Exp $	*/
/*	$KAME: route6.c,v 1.21 2000/09/20 23:00:49 itojun Exp $	*/
d47 2
a48 1
static int ip6_rthdr0 __P((struct mbuf *, struct ip6_hdr *, struct ip6_rthdr0 *));
d73 3
a75 3
	switch(rh->ip6r_type) {
	 case IPV6_RTHDR_TYPE_0:
		 rhlen = (rh->ip6r_len + 1) << 3;
d77 6
a82 1
		 IP6_EXTHDR_CHECK(m, off, rhlen, IPPROTO_DONE);
d84 10
a93 2
		 IP6_EXTHDR_GET(rh, struct ip6_rthdr *, m, off, rhlen);
		 if (rh == NULL) {
d96 1
a96 1
		 }
d98 13
a110 13
		 if (ip6_rthdr0(m, ip6, (struct ip6_rthdr0 *)rh))
			 return(IPPROTO_DONE);
		 break;
	 default:
		 /* unknown routing type */
		 if (rh->ip6r_segleft == 0) {
			 rhlen = (rh->ip6r_len + 1) << 3;
			 break;	/* Final dst. Just ignore the header. */
		 }
		 ip6stat.ip6s_badoptions++;
		 icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			     (caddr_t)&rh->ip6r_type - (caddr_t)ip6);
		 return(IPPROTO_DONE);
@


1.3
log
@fix typo in routing header address validation.  from francis dupont
@
text
@d1 1
a1 1
/*	$OpenBSD: route6.c,v 1.2 2000/02/07 06:09:10 itojun Exp $	*/
d54 3
a56 3
	register struct ip6_hdr *ip6;
	register struct mbuf *m = *mp;
	register struct ip6_rthdr *rh;
@


1.2
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: route6.c,v 1.1 1999/12/08 06:50:24 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d145 5
d151 11
a161 1
	    IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
d186 1
a186 1
    
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: route6.c,v 1.5 2001/02/16 08:48:07 itojun Exp $	*/
/*	$KAME: route6.c,v 1.22 2000/12/03 00:54:00 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d46 1
a46 2
static int ip6_rthdr0 __P((struct mbuf *, struct ip6_hdr *,
    struct ip6_rthdr0 *));
d53 3
a55 3
	struct ip6_hdr *ip6;
	struct mbuf *m = *mp;
	struct ip6_rthdr *rh;
d71 3
a73 3
	switch (rh->ip6r_type) {
	case IPV6_RTHDR_TYPE_0:
		rhlen = (rh->ip6r_len + 1) << 3;
d75 1
a75 6
		/*
		 * note on option length:
		 * due to IP6_EXTHDR_CHECK assumption, we cannot handle
		 * very big routing header (max rhlen == 2048).
		 */
		IP6_EXTHDR_CHECK(m, off, rhlen, IPPROTO_DONE);
d77 2
a78 10
		/*
		 * note on option length:
		 * maximum rhlen: 2048
		 * max mbuf m_pulldown can handle: MCLBYTES == usually 2048
		 * so, here we are assuming that m_pulldown can handle
		 * rhlen == 2048 case.  this may not be a good thing to
		 * assume - we may want to avoid pulling it up altogether.
		 */
		IP6_EXTHDR_GET(rh, struct ip6_rthdr *, m, off, rhlen);
		if (rh == NULL) {
d81 1
a81 1
		}
d83 13
a95 13
		if (ip6_rthdr0(m, ip6, (struct ip6_rthdr0 *)rh))
			return(IPPROTO_DONE);
		break;
	default:
		/* unknown routing type */
		if (rh->ip6r_segleft == 0) {
			rhlen = (rh->ip6r_len + 1) << 3;
			break;	/* Final dst. Just ignore the header. */
		}
		ip6stat.ip6s_badoptions++;
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    (caddr_t)&rh->ip6r_type - (caddr_t)ip6);
		return(IPPROTO_DONE);
a143 5
	/*
	 * reject invalid addresses.  be proactive about malicious use of
	 * IPv4 mapped/compat address.
	 * XXX need more checks?
	 */
d145 1
a145 11
	    IN6_IS_ADDR_UNSPECIFIED(nextaddr) ||
	    IN6_IS_ADDR_V4MAPPED(nextaddr) ||
	    IN6_IS_ADDR_V4COMPAT(nextaddr)) {
		ip6stat.ip6s_badoptions++;
		m_freem(m);
		return(-1);
	}
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) {
d170 1
a170 1

@


1.2.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d47 2
a48 2
static int ip6_rthdr0(struct mbuf *, struct ip6_hdr *,
    struct ip6_rthdr0 *);
@


1.2.2.3
log
@Sync the SMP branch with 3.3
@
text
@d99 1
a99 1
			return (IPPROTO_DONE);
d110 1
a110 1
		return (IPPROTO_DONE);
d114 1
a114 1
	return (rh->ip6r_nxt);
d130 1
a130 1
		return (0);
d139 1
a139 1
		 * RFC 2462: this limitation was removed since strict/loose
d145 1
a145 1
		return (-1);
d152 1
a152 1
		return (-1);
d170 1
a170 1
		return (-1);
d178 1
a178 1
		return (-1);
d201 1
a201 1
	return (-1);			/* m would be freed in ip6_forward() */
@


1.2.2.4
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d60 5
d71 1
d76 8
d97 1
@


1.2.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a103 3
 *
 * RFC2292 backward compatibility warning: no support for strict/loose bitmap,
 * as it was dropped between RFC1883 and RFC2460.
d142 1
a142 1
	nextaddr = ((struct in6_addr *)(rh0 + 1)) + index;
d154 2
a155 1
		goto bad;
d162 2
a163 1
		goto bad;
a186 4

  bad:
	m_freem(m);
	return (-1);
@


1.2.4.1
log
@Pull in patch from current:
Fix (itojun):
fix typo in routing header address validation.  from francis dupont
@
text
@d1 1
a1 2
/*	$OpenBSD: route6.c,v 1.3 2000/10/02 04:44:08 itojun Exp $	*/
/*	$KAME: route6.c,v 1.21 2000/09/20 23:00:49 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a143 5
	/*
	 * reject invalid addresses.  be proactive about malicious use of
	 * IPv4 mapped/compat address.
	 * XXX need more checks?
	 */
d145 1
a145 11
	    IN6_IS_ADDR_UNSPECIFIED(nextaddr) ||
	    IN6_IS_ADDR_V4MAPPED(nextaddr) ||
	    IN6_IS_ADDR_V4COMPAT(nextaddr)) {
		ip6stat.ip6s_badoptions++;
		m_freem(m);
		return(-1);
	}
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) {
d170 1
a170 1

@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <netinet6/ip6.h>
@

