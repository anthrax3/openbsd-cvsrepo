head	1.183;
access;
symbols
	OPENBSD_6_1:1.181.0.4
	OPENBSD_6_1_BASE:1.181
	OPENBSD_6_0:1.167.0.2
	OPENBSD_6_0_BASE:1.167
	OPENBSD_5_9:1.154.0.2
	OPENBSD_5_9_BASE:1.154
	OPENBSD_5_8:1.144.0.4
	OPENBSD_5_8_BASE:1.144
	OPENBSD_5_7:1.139.0.2
	OPENBSD_5_7_BASE:1.139
	OPENBSD_5_6:1.128.0.4
	OPENBSD_5_6_BASE:1.128
	OPENBSD_5_5:1.123.0.4
	OPENBSD_5_5_BASE:1.123
	OPENBSD_5_4:1.114.0.2
	OPENBSD_5_4_BASE:1.114
	OPENBSD_5_3:1.105.0.2
	OPENBSD_5_3_BASE:1.105
	OPENBSD_5_2:1.103.0.2
	OPENBSD_5_2_BASE:1.103
	OPENBSD_5_1_BASE:1.102
	OPENBSD_5_1:1.102.0.4
	OPENBSD_5_0:1.102.0.2
	OPENBSD_5_0_BASE:1.102
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.97.0.2
	OPENBSD_4_8_BASE:1.97
	OPENBSD_4_7:1.95.0.2
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.91.0.4
	OPENBSD_4_6_BASE:1.91
	OPENBSD_4_5:1.90.0.2
	OPENBSD_4_5_BASE:1.90
	OPENBSD_4_4:1.86.0.2
	OPENBSD_4_4_BASE:1.86
	OPENBSD_4_3:1.82.0.2
	OPENBSD_4_3_BASE:1.82
	OPENBSD_4_2:1.78.0.2
	OPENBSD_4_2_BASE:1.78
	OPENBSD_4_1:1.74.0.2
	OPENBSD_4_1_BASE:1.74
	OPENBSD_4_0:1.68.0.2
	OPENBSD_4_0_BASE:1.68
	OPENBSD_3_9:1.62.0.4
	OPENBSD_3_9_BASE:1.62
	OPENBSD_3_8:1.62.0.2
	OPENBSD_3_8_BASE:1.62
	OPENBSD_3_7:1.61.0.2
	OPENBSD_3_7_BASE:1.61
	OPENBSD_3_6:1.59.0.2
	OPENBSD_3_6_BASE:1.59
	SMP_SYNC_A:1.58
	SMP_SYNC_B:1.58
	OPENBSD_3_5:1.57.0.2
	OPENBSD_3_5_BASE:1.57
	OPENBSD_3_4:1.53.0.2
	OPENBSD_3_4_BASE:1.53
	UBC_SYNC_A:1.50
	OPENBSD_3_3:1.47.0.2
	OPENBSD_3_3_BASE:1.47
	OPENBSD_3_2:1.46.0.2
	OPENBSD_3_2_BASE:1.46
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.46
	UBC:1.38.0.2
	UBC_BASE:1.38
	OPENBSD_3_0:1.33.0.2
	OPENBSD_3_0_BASE:1.33
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.183
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.182;
commitid	00hB28wQPwG5Ysk0;

1.182
date	2017.04.06.02.11.08;	author dhill;	state Exp;
branches;
next	1.181;
commitid	JAYHk1hxU6ZTMw2o;

1.181
date	2017.03.06.08.59.07;	author mpi;	state Exp;
branches;
next	1.180;
commitid	5F7mwVgpVaCdO0cW;

1.180
date	2017.02.28.09.59.34;	author mpi;	state Exp;
branches;
next	1.179;
commitid	T3PPWgqAoWqJuqmb;

1.179
date	2017.02.08.12.37.43;	author bluhm;	state Exp;
branches;
next	1.178;
commitid	h9Q88VpdY8UDaqEf;

1.178
date	2017.02.06.16.01.25;	author bluhm;	state Exp;
branches;
next	1.177;
commitid	81vQjVlp7XC3h1zu;

1.177
date	2017.02.05.16.23.38;	author jca;	state Exp;
branches;
next	1.176;
commitid	b4PzKhPOLWkSDY9t;

1.176
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.175;
commitid	2R0NOjEDy2jGtnjL;

1.175
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	3e3CkrbYekyVOcxy;

1.174
date	2016.12.27.18.45.01;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	iX6wHULmb2OvfsDR;

1.173
date	2016.12.26.21.30.10;	author jca;	state Exp;
branches;
next	1.172;
commitid	4EK5zByufjOPkoKe;

1.172
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.171;
commitid	xiXE7MGPpVXw2TS3;

1.171
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.170;
commitid	QqHqT2WhCBWqYgGJ;

1.170
date	2016.11.28.10.10.53;	author mpi;	state Exp;
branches;
next	1.169;
commitid	XSUEY8wPDNTRRslj;

1.169
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.168;
commitid	to0Je2i4V2FtpmS1;

1.168
date	2016.08.24.09.41.12;	author mpi;	state Exp;
branches;
next	1.167;
commitid	0Qtt2cJVj3irHniv;

1.167
date	2016.07.19.15.57.13;	author phessler;	state Exp;
branches;
next	1.166;
commitid	WanTQSIrbpyyLiLr;

1.166
date	2016.07.19.09.23.51;	author bluhm;	state Exp;
branches;
next	1.165;
commitid	hrmh5chuAecXUl9H;

1.165
date	2016.07.19.08.13.46;	author mpi;	state Exp;
branches;
next	1.164;
commitid	ECRL6QXqoTrZfqgd;

1.164
date	2016.07.18.19.50.49;	author bluhm;	state Exp;
branches;
next	1.163;
commitid	9tQuzz6pLgfezGSg;

1.163
date	2016.07.14.14.39.12;	author mpi;	state Exp;
branches;
next	1.162;
commitid	UnyCEt6Mi38C4mox;

1.162
date	2016.07.06.15.50.00;	author mpi;	state Exp;
branches;
next	1.161;
commitid	jbSVLpkDhV9F9lu9;

1.161
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.160;
commitid	LxUFHuffW7GZZ01f;

1.160
date	2016.05.19.11.34.40;	author jca;	state Exp;
branches;
next	1.159;
commitid	vkyQX2LT0UqUpZLs;

1.159
date	2016.05.07.09.58.06;	author mpi;	state Exp;
branches;
next	1.158;
commitid	P9Cl9b5NxK5TJ9ys;

1.158
date	2016.04.19.08.23.13;	author mpi;	state Exp;
branches;
next	1.157;
commitid	6aaC9jQAC2YWe333;

1.157
date	2016.04.11.13.02.35;	author mpi;	state Exp;
branches;
next	1.156;
commitid	rEyvYYsTMlP3UQCO;

1.156
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.155;
commitid	AZTNcVhJxOTcjeS6;

1.155
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.154;
commitid	kCz5QgxnxRMKOzNf;

1.154
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.153;
commitid	5qLGnZtXVLeqUvHc;

1.153
date	2016.01.06.10.02.42;	author sthen;	state Exp;
branches;
next	1.152;
commitid	ESGofpMzMmblLLK4;

1.152
date	2015.12.03.21.11.54;	author sashan;	state Exp;
branches;
next	1.151;
commitid	nhuzteWvIf6uiITt;

1.151
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.150;
commitid	HAbRB9Scbg3IhXig;

1.150
date	2015.10.29.16.04.10;	author tedu;	state Exp;
branches;
next	1.149;
commitid	T9Dafq4uwVrQzJzv;

1.149
date	2015.10.23.00.15.07;	author jsg;	state Exp;
branches;
next	1.148;
commitid	KMXmg3XSDdHKnZuW;

1.148
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.147;
commitid	aMzCQ7pRC6VLKZyx;

1.147
date	2015.10.13.10.29.16;	author mpi;	state Exp;
branches;
next	1.146;
commitid	gcclwYrgbQaeTvzE;

1.146
date	2015.09.11.09.54.46;	author claudio;	state Exp;
branches;
next	1.145;
commitid	HqycWR1uYyzbFULl;

1.145
date	2015.09.10.09.14.59;	author mpi;	state Exp;
branches;
next	1.144;
commitid	lAvOdkHyrVIrW5gv;

1.144
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.143;
commitid	VGPlklxThaST7mIm;

1.143
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.142;
commitid	h7z8lokZ0dFyuWpg;

1.142
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.141;
commitid	4Ro7ulidQXNcMvmM;

1.141
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.140;
commitid	c7ei8kPelCOOwHXy;

1.140
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.139;
commitid	p4LJxGKbi0BU2cG6;

1.139
date	2015.02.09.12.23.22;	author claudio;	state Exp;
branches;
next	1.138;
commitid	lhMJN7NMGgqb766x;

1.138
date	2015.02.09.12.04.27;	author dlg;	state Exp;
branches;
next	1.137;
commitid	UJ02iYJWktCf5Nwe;

1.137
date	2015.02.09.09.50.00;	author mpi;	state Exp;
branches;
next	1.136;
commitid	TaJpim0o1sNurXaT;

1.136
date	2015.02.05.01.10.57;	author mpi;	state Exp;
branches;
next	1.135;
commitid	Vt4pFgzpwezZJ2dA;

1.135
date	2015.01.19.13.53.55;	author mpi;	state Exp;
branches;
next	1.134;
commitid	QLR9BrkHZXJalVFJ;

1.134
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.133;
commitid	zhW8jJrfVCoAthrR;

1.133
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.132;
commitid	t9FBKDfc4VDxpEy2;

1.132
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.131;
commitid	F3Fu23ZZ8dwzir4r;

1.131
date	2014.11.20.11.05.19;	author mpi;	state Exp;
branches;
next	1.130;
commitid	uo0PiO5ELdW7V3PO;

1.130
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.129;
commitid	6AYfDT0Lpez1LFQp;

1.129
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.128;
commitid	HQcmytntiCJTHORs;

1.128
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.127;
commitid	DQakU8LLWV6Iwx84;

1.127
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.126;
commitid	EF98ch02VpFassUi;

1.126
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.125;
commitid	2Ufy37wyO5neufOK;

1.125
date	2014.05.13.09.30.27;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2014.02.13.11.20.54;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2014.02.05.08.44.21;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2013.11.15.16.15.42;	author bluhm;	state Exp;
branches;
next	1.120;

1.120
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2013.10.28.21.02.35;	author deraadt;	state Exp;
branches;
next	1.118;

1.118
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.117;

1.117
date	2013.10.21.12.27.16;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.19.21.25.15;	author bluhm;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.114;

1.114
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.113;

1.113
date	2013.06.13.12.17.23;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2013.03.28.23.10.06;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.109;

1.109
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.108;

1.108
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.106;

1.106
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.105;

1.105
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.104;

1.104
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.103;

1.103
date	2012.04.03.15.03.08;	author mikeb;	state Exp;
branches;
next	1.102;

1.102
date	2011.08.04.16.40.08;	author bluhm;	state Exp;
branches;
next	1.101;

1.101
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.100;

1.100
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2011.04.03.13.56.05;	author stsp;	state Exp;
branches;
next	1.98;

1.98
date	2010.09.09.09.46.13;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.96;

1.96
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.95;

1.95
date	2010.02.08.12.16.02;	author jsing;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.15.20.26.21;	author jasper;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.19.22.07.17;	author otto;	state Exp;
branches;
next	1.92;

1.92
date	2009.11.03.10.59.04;	author claudio;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.18.20.37.13;	author bluhm;	state Exp;
branches;
next	1.90;

1.90
date	2008.11.25.12.11.45;	author markus;	state Exp;
branches;
next	1.89;

1.89
date	2008.11.02.10.37.29;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.87;

1.87
date	2008.09.17.05.43.14;	author chl;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.84;

1.84
date	2008.05.15.19.40.38;	author markus;	state Exp;
branches;
next	1.83;

1.83
date	2008.04.24.11.36.39;	author dlg;	state Exp;
branches;
next	1.82;

1.82
date	2008.02.24.23.31.30;	author mcbride;	state Exp;
branches;
next	1.81;

1.81
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.80;

1.80
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.78;

1.78
date	2007.08.03.06.43.12;	author itojun;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2007.05.28.17.16.39;	author henning;	state Exp;
branches;
next	1.76;

1.76
date	2007.05.08.23.23.16;	author mcbride;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.74;

1.74
date	2006.12.28.20.08.15;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2006.12.19.06.33.49;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.71;

1.71
date	2006.12.08.21.57.54;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2006.11.27.12.27.45;	author henning;	state Exp;
branches;
next	1.69;

1.69
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.67;

1.67
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2006.05.27.20.00.37;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.24.18.43.10;	author thib;	state Exp;
branches;
next	1.64;

1.64
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2006.03.04.22.40.16;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.11.12.55.31;	author mpf;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.06.16.27.01;	author dhartmei;	state Exp;
branches;
next	1.60;

1.60
date	2004.10.18.03.59.34;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.21.19.26.02;	author mcbride;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2004.06.01.03.19.27;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2003.12.08.10.05.31;	author dhartmei;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.14.08.22.31;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.14.06.39.32;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.30.10.30.23;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.30.08.04.22;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.14.14.44.44;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.14.14.18.23;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2003.01.07.09.00.34;	author kjc;	state Exp;
branches;
next	1.46;

1.46
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.07.15.27.58;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.28.03.04.38;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.01.21.05.33.14;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.01.02.22.47.47;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2001.12.16.01.28.59;	author jasoni;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2001.11.02.09.01.29;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.32;

1.32
date	2001.06.27.05.50.07;	author kjc;	state Exp;
branches;
next	1.31;

1.31
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.30;

1.30
date	2001.05.11.17.20.12;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.30.11.09.01;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.16.12.20.52;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.16.16.38.15;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.16.16.00.57;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.16.14.58.12;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.16.08.48.05;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.16.08.22.06;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.08.14.51.22;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.07.11.43.53;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.06.00.22.23;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.31.08.39.56;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.06.10.11.25;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.07.02.10.10.55;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.18.06.27.15;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.18.06.24.45;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.18.04.33.03;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.13.14.50.33;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.19.20.12.10;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.17.04.44.50;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.22.03.50.35;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.08.04.49.22;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.06.02.52.51;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	99.12.30.17.28.20;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.09.13.59.57;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.12.09.00.40.06;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.12.09.00.34.13;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.8.2.1
date	2000.03.24.09.09.40;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.07.04.10.55.23;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.8.2.9;

1.8.2.9
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.8.2.10;

1.8.2.10
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.8.2.11;

1.8.2.11
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.8.2.12;

1.8.2.12
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.8.2.13;

1.8.2.13
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.38.2.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.57.2.1
date	2005.03.21.02.07.50;	author brad;	state Exp;
branches;
next	;

1.59.2.1
date	2005.03.21.02.06.36;	author brad;	state Exp;
branches;
next	;

1.78.2.1
date	2008.02.25.00.00.00;	author henning;	state Exp;
branches;
next	;


desc
@@


1.183
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: ip6_input.c,v 1.182 2017/04/06 02:11:08 dhill Exp $	*/
/*	$KAME: ip6_input.c,v 1.188 2001/03/29 05:34:31 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_input.c	8.2 (Berkeley) 1/4/94
 */

#include "pf.h"
#include "carp.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/sysctl.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/task.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/route.h>
#include <net/netisr.h>

#include <netinet/in.h>

#include <netinet/ip.h>

#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/nd6.h>

#include <netinet6/ip6protosw.h>

#include "gif.h"
#include "bpfilter.h"

#ifdef MROUTING
#include <netinet6/ip6_mroute.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

struct niqueue ip6intrq = NIQUEUE_INITIALIZER(IFQ_MAXLEN, NETISR_IPV6);

struct cpumem *ip6counters;

void ip6_ours(struct mbuf *);
int ip6_check_rh0hdr(struct mbuf *, int *);
int ip6_hbhchcheck(struct mbuf *, int *, int *, int *);
int ip6_hopopts_input(u_int32_t *, u_int32_t *, struct mbuf **, int *);
struct mbuf *ip6_pullexthdr(struct mbuf *, size_t, int);

static struct mbuf_queue	ip6send_mq;

static void ip6_send_dispatch(void *);
static struct task ip6send_task =
	TASK_INITIALIZER(ip6_send_dispatch, &ip6send_mq);

/*
 * IP6 initialization: fill in IP6 protocol switch table.
 * All protocols not implemented in kernel go to raw IP6 protocol handler.
 */
void
ip6_init(void)
{
	struct protosw *pr;
	int i;

	pr = pffindproto(PF_INET6, IPPROTO_RAW, SOCK_RAW);
	if (pr == NULL)
		panic("ip6_init");
	for (i = 0; i < IPPROTO_MAX; i++)
		ip6_protox[i] = pr - inet6sw;
	for (pr = inet6domain.dom_protosw;
	    pr < inet6domain.dom_protoswNPROTOSW; pr++)
		if (pr->pr_domain->dom_family == PF_INET6 &&
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW &&
		    pr->pr_protocol < IPPROTO_MAX)
			ip6_protox[pr->pr_protocol] = pr - inet6sw;
	ip6_randomid_init();
	nd6_init();
	frag6_init();

	mq_init(&ip6send_mq, 64, IPL_SOFTNET);

	ip6counters = counters_alloc(ip6s_ncounters);
}

/*
 * IP6 input interrupt handling. Just pass the packet to ip6_input.
 */
void
ip6intr(void)
{
	struct mbuf *m;

	while ((m = niq_dequeue(&ip6intrq)) != NULL)
		ip6_input(m);
}

void
ip6_input(struct mbuf *m)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6;
	struct sockaddr_in6 sin6;
	struct rtentry *rt = NULL;
	int off, nxt, ours = 0;
	u_int16_t src_scope, dst_scope;
#if NPF > 0
	struct in6_addr odst;
#endif
	int srcrt = 0;

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto bad;

	ip6stat_inc(ip6s_total);

	if (m->m_len < sizeof(struct ip6_hdr)) {
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {
			ip6stat_inc(ip6s_toosmall);
			goto out;
		}
	}

	ip6 = mtod(m, struct ip6_hdr *);

	if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
		ip6stat_inc(ip6s_badvers);
		goto bad;
	}

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ip6->ip6_nxt != IPPROTO_ICMPV6 &&
	    carp_lsdrop(m, AF_INET6, ip6->ip6_src.s6_addr32,
	    ip6->ip6_dst.s6_addr32))
		goto bad;
#endif
	ip6stat_inc(ip6s_nxthist + ip6->ip6_nxt);

	/*
	 * Check against address spoofing/corruption.
	 */
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_src) ||
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_dst)) {
		/*
		 * XXX: "badscope" is not very suitable for a multicast source.
		 */
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}
	if ((IN6_IS_ADDR_LOOPBACK(&ip6->ip6_src) ||
	    IN6_IS_ADDR_LOOPBACK(&ip6->ip6_dst)) &&
	    (ifp->if_flags & IFF_LOOPBACK) == 0) {
		    ip6stat_inc(ip6s_badscope);
		    goto bad;
	}
	/* Drop packets if interface ID portion is already filled. */
	if (((IN6_IS_SCOPE_EMBED(&ip6->ip6_src) && ip6->ip6_src.s6_addr16[1]) ||
	    (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst) && ip6->ip6_dst.s6_addr16[1])) &&
	    (ifp->if_flags & IFF_LOOPBACK) == 0) {
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}
	if (IN6_IS_ADDR_MC_INTFACELOCAL(&ip6->ip6_dst) &&
	    !(m->m_flags & M_LOOP)) {
		/*
		 * In this case, the packet should come from the loopback
		 * interface.  However, we cannot just check the if_flags,
		 * because ip6_mloopback() passes the "actual" interface
		 * as the outgoing/incoming interface.
		 */
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}

	/*
	 * The following check is not documented in specs.  A malicious
	 * party may be able to use IPv4 mapped addr to confuse tcp/udp stack
	 * and bypass security checks (act as if it was from 127.0.0.1 by using
	 * IPv6 src ::ffff:127.0.0.1).  Be cautious.
	 *
	 * This check chokes if we are in an SIIT cloud.  As none of BSDs
	 * support IPv4-less kernel compilation, we cannot support SIIT
	 * environment at all.  So, it makes more sense for us to reject any
	 * malicious packets for non-SIIT environment, than try to do a
	 * partial support for SIIT environment.
	 */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}

	/*
	 * Reject packets with IPv4 compatible addresses (auto tunnel).
	 *
	 * The code forbids automatic tunneling as per RFC4213.
	 */
	if (IN6_IS_ADDR_V4COMPAT(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) {
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}

	/*
	 * If the packet has been received on a loopback interface it
	 * can be destinated to any local address, not necessarily to
	 * an address configured on `ifp'.
	 */
	if (ifp->if_flags & IFF_LOOPBACK) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src)) {
			src_scope = ip6->ip6_src.s6_addr16[1];
			ip6->ip6_src.s6_addr16[1] = 0;
		}
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst)) {
			dst_scope = ip6->ip6_dst.s6_addr16[1];
			ip6->ip6_dst.s6_addr16[1] = 0;
		}
	}

#if NPF > 0
        /*
         * Packet filter
         */
	odst = ip6->ip6_dst;
	if (pf_test(AF_INET6, PF_IN, ifp, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		goto bad;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif

	/*
	 * Without embedded scope ID we cannot find link-local
	 * addresses in the routing table.
	 */
	if (ifp->if_flags & IFF_LOOPBACK) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = src_scope;
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = dst_scope;
	} else {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = htons(ifp->if_index);
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = htons(ifp->if_index);
	}

	/*
	 * Be more secure than RFC5095 and scan for type 0 routing headers.
	 * If pf has already scanned the header chain, do not do it twice.
	 */
	if (!(m->m_pkthdr.pf.flags & PF_TAG_PROCESSED) &&
	    ip6_check_rh0hdr(m, &off)) {
		ip6stat_inc(ip6s_badoptions);
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, off);
		goto out;
	}

	if (IN6_IS_ADDR_LOOPBACK(&ip6->ip6_src) ||
	    IN6_IS_ADDR_LOOPBACK(&ip6->ip6_dst)) {
		ip6_ours(m);
		goto out;
	}

#if NPF > 0
	if (pf_ouraddr(m) == 1) {
		ip6_ours(m);
		goto out;
	}
#endif

	/*
	 * Multicast check
	 */
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		/*
		 * Make sure M_MCAST is set.  It should theoretically
		 * already be there, but let's play safe because upper
		 * layers check for this flag.
		 */
		m->m_flags |= M_MCAST;

		/*
		 * See if we belong to the destination multicast group on the
		 * arrival interface.
		 */
		if (in6_hasmulti(&ip6->ip6_dst, ifp))
			ours = 1;

#ifdef MROUTING
		if (ip6_mforwarding && ip6_mrouter) {
			if (ip6_hbhchcheck(m, &off, &nxt, &ours))
				goto out;

			ip6 = mtod(m, struct ip6_hdr *);

			/*
			 * If we are acting as a multicast router, all
			 * incoming multicast packets are passed to the
			 * kernel-level multicast forwarding function.
			 * The packet is returned (relatively) intact; if
			 * ip6_mforward() returns a non-zero value, the packet
			 * must be discarded, else it may be accepted below.
			 */
			KERNEL_LOCK();
			if (ip6_mforward(ip6, ifp, m)) {
				ip6stat_inc(ip6s_cantforward);
				m_freem(m);
			} else if (ours) {
				ip6_local(m, off, nxt);
			} else {
				m_freem(m);
			}
			KERNEL_UNLOCK();
			goto out;
		}
#endif
		if (!ours) {
			ip6stat_inc(ip6s_notmember);
			if (!IN6_IS_ADDR_MC_LINKLOCAL(&ip6->ip6_dst))
				ip6stat_inc(ip6s_cantforward);
			goto bad;
		}
		ip6_ours(m);
		goto out;
	}


	/*
	 *  Unicast check
	 */
	memset(&sin6, 0, sizeof(struct sockaddr_in6));
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = ip6->ip6_dst;
	rt = rtalloc_mpath(sin6tosa(&sin6), &ip6->ip6_src.s6_addr32[0],
	    m->m_pkthdr.ph_rtableid);

	/*
	 * Accept the packet if the route to the destination is marked
	 * as local.
	 */
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL)) {
		struct in6_ifaddr *ia6 = ifatoia6(rt->rt_ifa);
		if (ia6->ia6_flags & IN6_IFF_ANYCAST)
			m->m_flags |= M_ACAST;
		/*
		 * packets to a tentative, duplicated, or somehow invalid
		 * address must not be accepted.
		 */
		if ((ia6->ia6_flags & (IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED))) {
			char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

			inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src));
			inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst));
			/* address is not ready, so discard the packet. */
			nd6log((LOG_INFO,
			    "ip6_input: packet to an unready address %s->%s\n",
			    src, dst));

			goto bad;
		} else {
			ip6_ours(m);
			goto out;
		}
	}

#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ip6->ip6_nxt == IPPROTO_ICMPV6 &&
	    carp_lsdrop(m, AF_INET6, ip6->ip6_src.s6_addr32,
	    ip6->ip6_dst.s6_addr32))
		goto bad;
#endif
	/*
	 * Now there is no reason to process the packet if it's not our own
	 * and we're not a router.
	 */
	if (!ip6_forwarding) {
		ip6stat_inc(ip6s_cantforward);
		goto bad;
	}

	if (ip6_hbhchcheck(m, &off, &nxt, &ours))
		goto out;

	if (ours) {
		KERNEL_LOCK();
		ip6_local(m, off, nxt);
		KERNEL_UNLOCK();
		goto out;
	}

	ip6_forward(m, rt, srcrt);
	if_put(ifp);
	return;
 bad:
	m_freem(m);
 out:
	rtfree(rt);
	if_put(ifp);
}

void
ip6_ours(struct mbuf *m)
{
	int off, nxt;

	if (ip6_hbhchcheck(m, &off, &nxt, NULL))
		return;

	ip6_local(m, off, nxt);
}

void
ip6_local(struct mbuf *m, int off, int nxt)
{
	int nest = 0;

	KERNEL_ASSERT_LOCKED();

	/* pf might have changed things */
	in6_proto_cksum_out(m, NULL);

	/*
	 * Tell launch routine the next header
	 */
	ip6stat_inc(ip6s_delivered);

	while (nxt != IPPROTO_DONE) {
		if (ip6_hdrnestlimit && (++nest > ip6_hdrnestlimit)) {
			ip6stat_inc(ip6s_toomanyhdr);
			goto bad;
		}

		/*
		 * protection against faulty packet - there should be
		 * more sanity checks in header chain processing.
		 */
		if (m->m_pkthdr.len < off) {
			ip6stat_inc(ip6s_tooshort);
			goto bad;
		}

		/* draft-itojun-ipv6-tcp-to-anycast */
		if (ISSET(m->m_flags, M_ACAST) && (nxt == IPPROTO_TCP)) {
			if (m->m_len >= sizeof(struct ip6_hdr)) {
				icmp6_error(m, ICMP6_DST_UNREACH,
					ICMP6_DST_UNREACH_ADDR,
					offsetof(struct ip6_hdr, ip6_dst));
				break;
			} else
				goto bad;
		}

		nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt,
		    AF_INET6);
	}
	return;
 bad:
	m_freem(m);
}

int
ip6_hbhchcheck(struct mbuf *m, int *offp, int *nxtp, int *oursp)
{
	struct ip6_hdr *ip6;
	u_int32_t plen, rtalert = ~0;

	ip6 = mtod(m, struct ip6_hdr *);

	/*
	 * Process Hop-by-Hop options header if it's contained.
	 * m may be modified in ip6_hopopts_input().
	 * If a JumboPayload option is included, plen will also be modified.
	 */
	plen = (u_int32_t)ntohs(ip6->ip6_plen);
	*offp = sizeof(struct ip6_hdr);
	if (ip6->ip6_nxt == IPPROTO_HOPOPTS) {
		struct ip6_hbh *hbh;

		if (ip6_hopopts_input(&plen, &rtalert, &m, offp)) {
			return (-1);	/* m have already been freed */
		}

		/* adjust pointer */
		ip6 = mtod(m, struct ip6_hdr *);

		/*
		 * if the payload length field is 0 and the next header field
		 * indicates Hop-by-Hop Options header, then a Jumbo Payload
		 * option MUST be included.
		 */
		if (ip6->ip6_plen == 0 && plen == 0) {
			/*
			 * Note that if a valid jumbo payload option is
			 * contained, ip6_hopopts_input() must set a valid
			 * (non-zero) payload length to the variable plen.
			 */
			ip6stat_inc(ip6s_badoptions);
			icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    (caddr_t)&ip6->ip6_plen - (caddr_t)ip6);
			return (-1);
		}
		IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m, sizeof(struct ip6_hdr),
			sizeof(struct ip6_hbh));
		if (hbh == NULL) {
			ip6stat_inc(ip6s_tooshort);
			return (-1);
		}
		*nxtp = hbh->ip6h_nxt;

		/*
		 * accept the packet if a router alert option is included
		 * and we act as an IPv6 router.
		 */
		if (rtalert != ~0 && ip6_forwarding && oursp != NULL)
			*oursp = 1;
	} else
		*nxtp = ip6->ip6_nxt;

	/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IPv6 header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */
	if (m->m_pkthdr.len - sizeof(struct ip6_hdr) < plen) {
		ip6stat_inc(ip6s_tooshort);
		m_freem(m);
		return (-1);
	}
	if (m->m_pkthdr.len > sizeof(struct ip6_hdr) + plen) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = sizeof(struct ip6_hdr) + plen;
			m->m_pkthdr.len = sizeof(struct ip6_hdr) + plen;
		} else {
			m_adj(m,
			    sizeof(struct ip6_hdr) + plen - m->m_pkthdr.len);
		}
	}

	return (0);
}

/* scan packet for RH0 routing header. Mostly stolen from pf.c:pf_test() */
int
ip6_check_rh0hdr(struct mbuf *m, int *offp)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct ip6_rthdr rthdr;
	struct ip6_ext opt6;
	u_int8_t proto = ip6->ip6_nxt;
	int done = 0, lim, off, rh_cnt = 0;

	off = ((caddr_t)ip6 - m->m_data) + sizeof(struct ip6_hdr);
	lim = min(m->m_pkthdr.len, ntohs(ip6->ip6_plen) + sizeof(*ip6));
	do {
		switch (proto) {
		case IPPROTO_ROUTING:
			*offp = off;
			if (rh_cnt++) {
				/* more than one rh header present */
				return (1);
			}

			if (off + sizeof(rthdr) > lim) {
				/* packet to short to make sense */
				return (1);
			}

			m_copydata(m, off, sizeof(rthdr), (caddr_t)&rthdr);

			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
				*offp += offsetof(struct ip6_rthdr, ip6r_type);
				return (1);
			}

			off += (rthdr.ip6r_len + 1) * 8;
			proto = rthdr.ip6r_nxt;
			break;
		case IPPROTO_AH:
		case IPPROTO_HOPOPTS:
		case IPPROTO_DSTOPTS:
			/* get next header and header length */
			if (off + sizeof(opt6) > lim) {
				/*
				 * Packet to short to make sense, we could
				 * reject the packet but as a router we
				 * should not do that so forward it.
				 */
				return (0);
			}

			m_copydata(m, off, sizeof(opt6), (caddr_t)&opt6);

			if (proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			proto = opt6.ip6e_nxt;
			break;
		case IPPROTO_FRAGMENT:
		default:
			/* end of header stack */
			done = 1;
			break;
		}
	} while (!done);

	return (0);
}

/*
 * Hop-by-Hop options header processing. If a valid jumbo payload option is
 * included, the real payload length will be stored in plenp.
 *
 * rtalertp - XXX: should be stored in a more smart way
 */
int
ip6_hopopts_input(u_int32_t *plenp, u_int32_t *rtalertp, struct mbuf **mp,
    int *offp)
{
	struct mbuf *m = *mp;
	int off = *offp, hbhlen;
	struct ip6_hbh *hbh;

	/* validation of the length of the header */
	IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m,
		sizeof(struct ip6_hdr), sizeof(struct ip6_hbh));
	if (hbh == NULL) {
		ip6stat_inc(ip6s_tooshort);
		return -1;
	}
	hbhlen = (hbh->ip6h_len + 1) << 3;
	IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m, sizeof(struct ip6_hdr),
		hbhlen);
	if (hbh == NULL) {
		ip6stat_inc(ip6s_tooshort);
		return -1;
	}
	off += hbhlen;
	hbhlen -= sizeof(struct ip6_hbh);

	if (ip6_process_hopopts(m, (u_int8_t *)hbh + sizeof(struct ip6_hbh),
				hbhlen, rtalertp, plenp) < 0)
		return (-1);

	*offp = off;
	*mp = m;
	return (0);
}

/*
 * Search header for all Hop-by-hop options and process each option.
 * This function is separate from ip6_hopopts_input() in order to
 * handle a case where the sending node itself process its hop-by-hop
 * options header. In such a case, the function is called from ip6_output().
 *
 * The function assumes that hbh header is located right after the IPv6 header
 * (RFC2460 p7), opthead is pointer into data content in m, and opthead to
 * opthead + hbhlen is located in continuous memory region.
 */
int
ip6_process_hopopts(struct mbuf *m, u_int8_t *opthead, int hbhlen,
    u_int32_t *rtalertp, u_int32_t *plenp)
{
	struct ip6_hdr *ip6;
	int optlen = 0;
	u_int8_t *opt = opthead;
	u_int16_t rtalert_val;
	u_int32_t jumboplen;
	const int erroff = sizeof(struct ip6_hdr) + sizeof(struct ip6_hbh);

	for (; hbhlen > 0; hbhlen -= optlen, opt += optlen) {
		switch (*opt) {
		case IP6OPT_PAD1:
			optlen = 1;
			break;
		case IP6OPT_PADN:
			if (hbhlen < IP6OPT_MINLEN) {
				ip6stat_inc(ip6s_toosmall);
				goto bad;
			}
			optlen = *(opt + 1) + 2;
			break;
		case IP6OPT_ROUTER_ALERT:
			/* XXX may need check for alignment */
			if (hbhlen < IP6OPT_RTALERT_LEN) {
				ip6stat_inc(ip6s_toosmall);
				goto bad;
			}
			if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
			optlen = IP6OPT_RTALERT_LEN;
			memcpy((caddr_t)&rtalert_val, (caddr_t)(opt + 2), 2);
			*rtalertp = ntohs(rtalert_val);
			break;
		case IP6OPT_JUMBO:
			/* XXX may need check for alignment */
			if (hbhlen < IP6OPT_JUMBO_LEN) {
				ip6stat_inc(ip6s_toosmall);
				goto bad;
			}
			if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
			optlen = IP6OPT_JUMBO_LEN;

			/*
			 * IPv6 packets that have non 0 payload length
			 * must not contain a jumbo payload option.
			 */
			ip6 = mtod(m, struct ip6_hdr *);
			if (ip6->ip6_plen) {
				ip6stat_inc(ip6s_badoptions);
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt - opthead);
				return (-1);
			}

			/*
			 * We may see jumbolen in unaligned location, so
			 * we'd need to perform memcpy().
			 */
			memcpy(&jumboplen, opt + 2, sizeof(jumboplen));
			jumboplen = (u_int32_t)htonl(jumboplen);

#if 1
			/*
			 * if there are multiple jumbo payload options,
			 * *plenp will be non-zero and the packet will be
			 * rejected.
			 * the behavior may need some debate in ipngwg -
			 * multiple options does not make sense, however,
			 * there's no explicit mention in specification.
			 */
			if (*plenp != 0) {
				ip6stat_inc(ip6s_badoptions);
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
			}
#endif

			/*
			 * jumbo payload length must be larger than 65535.
			 */
			if (jumboplen <= IPV6_MAXPACKET) {
				ip6stat_inc(ip6s_badoptions);
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
			}
			*plenp = jumboplen;

			break;
		default:		/* unknown option */
			if (hbhlen < IP6OPT_MINLEN) {
				ip6stat_inc(ip6s_toosmall);
				goto bad;
			}
			optlen = ip6_unknown_opt(opt, m,
			    erroff + opt - opthead);
			if (optlen == -1)
				return (-1);
			optlen += 2;
			break;
		}
	}

	return (0);

  bad:
	m_freem(m);
	return (-1);
}

/*
 * Unknown option processing.
 * The third argument `off' is the offset from the IPv6 header to the option,
 * which allows returning an ICMPv6 error even if the IPv6 header and the
 * option header are not continuous.
 */
int
ip6_unknown_opt(u_int8_t *optp, struct mbuf *m, int off)
{
	struct ip6_hdr *ip6;

	switch (IP6OPT_TYPE(*optp)) {
	case IP6OPT_TYPE_SKIP: /* ignore the option */
		return ((int)*(optp + 1));
	case IP6OPT_TYPE_DISCARD:	/* silently discard */
		m_freem(m);
		return (-1);
	case IP6OPT_TYPE_FORCEICMP: /* send ICMP even if multicasted */
		ip6stat_inc(ip6s_badoptions);
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, off);
		return (-1);
	case IP6OPT_TYPE_ICMP: /* send ICMP if not multicasted */
		ip6stat_inc(ip6s_badoptions);
		ip6 = mtod(m, struct ip6_hdr *);
		if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
		    (m->m_flags & (M_BCAST|M_MCAST)))
			m_freem(m);
		else
			icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_OPTION, off);
		return (-1);
	}

	m_freem(m);		/* XXX: NOTREACHED */
	return (-1);
}

/*
 * Create the "control" list for this pcb.
 *
 * The routine will be called from upper layer handlers like udp_input().
 * Thus the routine assumes that the caller (udp_input) have already
 * called IP6_EXTHDR_CHECK() and all the extension headers are located in the
 * very first mbuf on the mbuf chain.
 * We may want to add some infinite loop prevention or sanity checks for safety.
 * (This applies only when you are using KAME mbuf chain restriction, i.e.
 * you are using IP6_EXTHDR_CHECK() not m_pulldown())
 */
void
ip6_savecontrol(struct inpcb *in6p, struct mbuf *m, struct mbuf **mp)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);

#ifdef SO_TIMESTAMP
	if (in6p->inp_socket->so_options & SO_TIMESTAMP) {
		struct timeval tv;

		microtime(&tv);
		*mp = sbcreatecontrol((caddr_t) &tv, sizeof(tv),
		    SCM_TIMESTAMP, SOL_SOCKET);
		if (*mp)
			mp = &(*mp)->m_next;
	}
#endif

	/* RFC 2292 sec. 5 */
	if ((in6p->inp_flags & IN6P_PKTINFO) != 0) {
		struct in6_pktinfo pi6;
		memcpy(&pi6.ipi6_addr, &ip6->ip6_dst, sizeof(struct in6_addr));
		if (IN6_IS_SCOPE_EMBED(&pi6.ipi6_addr))
			pi6.ipi6_addr.s6_addr16[1] = 0;
		pi6.ipi6_ifindex = m ? m->m_pkthdr.ph_ifidx : 0;
		*mp = sbcreatecontrol((caddr_t) &pi6,
		    sizeof(struct in6_pktinfo),
		    IPV6_PKTINFO, IPPROTO_IPV6);
		if (*mp)
			mp = &(*mp)->m_next;
	}

	if ((in6p->inp_flags & IN6P_HOPLIMIT) != 0) {
		int hlim = ip6->ip6_hlim & 0xff;
		*mp = sbcreatecontrol((caddr_t) &hlim, sizeof(int),
		    IPV6_HOPLIMIT, IPPROTO_IPV6);
		if (*mp)
			mp = &(*mp)->m_next;
	}

	if ((in6p->inp_flags & IN6P_TCLASS) != 0) {
		u_int32_t flowinfo;
		int tclass;

		flowinfo = (u_int32_t)ntohl(ip6->ip6_flow & IPV6_FLOWINFO_MASK);
		flowinfo >>= 20;

		tclass = flowinfo & 0xff;
		*mp = sbcreatecontrol((caddr_t)&tclass, sizeof(tclass),
		    IPV6_TCLASS, IPPROTO_IPV6);
		if (*mp)
			mp = &(*mp)->m_next;
	}

	/*
	 * IPV6_HOPOPTS socket option.  Recall that we required super-user
	 * privilege for the option (see ip6_ctloutput), but it might be too
	 * strict, since there might be some hop-by-hop options which can be
	 * returned to normal user.
	 * See also RFC 2292 section 6 (or RFC 3542 section 8).
	 */
	if ((in6p->inp_flags & IN6P_HOPOPTS) != 0) {
		/*
		 * Check if a hop-by-hop options header is contained in the
		 * received packet, and if so, store the options as ancillary
		 * data. Note that a hop-by-hop options header must be
		 * just after the IPv6 header, which is assured through the
		 * IPv6 input processing.
		 */
		struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
		if (ip6->ip6_nxt == IPPROTO_HOPOPTS) {
			struct ip6_hbh *hbh;
			int hbhlen = 0;
			struct mbuf *ext;

			ext = ip6_pullexthdr(m, sizeof(struct ip6_hdr),
			    ip6->ip6_nxt);
			if (ext == NULL) {
				ip6stat_inc(ip6s_tooshort);
				return;
			}
			hbh = mtod(ext, struct ip6_hbh *);
			hbhlen = (hbh->ip6h_len + 1) << 3;
			if (hbhlen != ext->m_len) {
				m_freem(ext);
				ip6stat_inc(ip6s_tooshort);
				return;
			}

			/*
			 * XXX: We copy the whole header even if a
			 * jumbo payload option is included, the option which
			 * is to be removed before returning according to
			 * RFC2292.
			 * Note: this constraint is removed in RFC3542.
			 */
			*mp = sbcreatecontrol((caddr_t)hbh, hbhlen,
			    IPV6_HOPOPTS,
			    IPPROTO_IPV6);
			if (*mp)
				mp = &(*mp)->m_next;
			m_freem(ext);
		}
	}

	/* IPV6_DSTOPTS and IPV6_RTHDR socket options */
	if ((in6p->inp_flags & (IN6P_RTHDR | IN6P_DSTOPTS)) != 0) {
		struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
		int nxt = ip6->ip6_nxt, off = sizeof(struct ip6_hdr);

		/*
		 * Search for destination options headers or routing
		 * header(s) through the header chain, and stores each
		 * header as ancillary data.
		 * Note that the order of the headers remains in
		 * the chain of ancillary data.
		 */
		while (1) {	/* is explicit loop prevention necessary? */
			struct ip6_ext *ip6e = NULL;
			int elen;
			struct mbuf *ext = NULL;

			/*
			 * if it is not an extension header, don't try to
			 * pull it from the chain.
			 */
			switch (nxt) {
			case IPPROTO_DSTOPTS:
			case IPPROTO_ROUTING:
			case IPPROTO_HOPOPTS:
			case IPPROTO_AH: /* is it possible? */
				break;
			default:
				goto loopend;
			}

			ext = ip6_pullexthdr(m, off, nxt);
			if (ext == NULL) {
				ip6stat_inc(ip6s_tooshort);
				return;
			}
			ip6e = mtod(ext, struct ip6_ext *);
			if (nxt == IPPROTO_AH)
				elen = (ip6e->ip6e_len + 2) << 2;
			else
				elen = (ip6e->ip6e_len + 1) << 3;
			if (elen != ext->m_len) {
				m_freem(ext);
				ip6stat_inc(ip6s_tooshort);
				return;
			}

			switch (nxt) {
			case IPPROTO_DSTOPTS:
				if (!(in6p->inp_flags & IN6P_DSTOPTS))
					break;

				*mp = sbcreatecontrol((caddr_t)ip6e, elen,
				    IPV6_DSTOPTS,
				    IPPROTO_IPV6);
				if (*mp)
					mp = &(*mp)->m_next;
				break;

			case IPPROTO_ROUTING:
				if (!(in6p->inp_flags & IN6P_RTHDR))
					break;

				*mp = sbcreatecontrol((caddr_t)ip6e, elen,
				    IPV6_RTHDR,
				    IPPROTO_IPV6);
				if (*mp)
					mp = &(*mp)->m_next;
				break;

			case IPPROTO_HOPOPTS:
			case IPPROTO_AH: /* is it possible? */
				break;

			default:
				/*
				 * other cases have been filtered in the above.
				 * none will visit this case.  here we supply
				 * the code just in case (nxt overwritten or
				 * other cases).
				 */
				m_freem(ext);
				goto loopend;

			}

			/* proceed with the next header. */
			off += elen;
			nxt = ip6e->ip6e_nxt;
			ip6e = NULL;
			m_freem(ext);
			ext = NULL;
		}
loopend:
		;
	}
}

/*
 * pull single extension header from mbuf chain.  returns single mbuf that
 * contains the result, or NULL on error.
 */
struct mbuf *
ip6_pullexthdr(struct mbuf *m, size_t off, int nxt)
{
	struct ip6_ext ip6e;
	size_t elen;
	struct mbuf *n;

#ifdef DIAGNOSTIC
	switch (nxt) {
	case IPPROTO_DSTOPTS:
	case IPPROTO_ROUTING:
	case IPPROTO_HOPOPTS:
	case IPPROTO_AH: /* is it possible? */
		break;
	default:
		printf("ip6_pullexthdr: invalid nxt=%d\n", nxt);
	}
#endif

	m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
	if (nxt == IPPROTO_AH)
		elen = (ip6e.ip6e_len + 2) << 2;
	else
		elen = (ip6e.ip6e_len + 1) << 3;

	MGET(n, M_DONTWAIT, MT_DATA);
	if (n && elen >= MLEN) {
		MCLGET(n, M_DONTWAIT);
		if ((n->m_flags & M_EXT) == 0) {
			m_free(n);
			n = NULL;
		}
	}
	if (!n)
		return NULL;

	n->m_len = 0;
	if (elen >= M_TRAILINGSPACE(n)) {
		m_free(n);
		return NULL;
	}

	m_copydata(m, off, elen, mtod(n, caddr_t));
	n->m_len = elen;
	return n;
}

/*
 * Get pointer to the previous header followed by the header
 * currently processed.
 * XXX: This function supposes that
 *	M includes all headers,
 *	the next header field and the header length field of each header
 *	are valid, and
 *	the sum of each header length equals to OFF.
 * Because of these assumptions, this function must be called very
 * carefully. Moreover, it will not be used in the near future when
 * we develop `neater' mechanism to process extension headers.
 */
u_int8_t *
ip6_get_prevhdr(struct mbuf *m, int off)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);

	if (off == sizeof(struct ip6_hdr))
		return (&ip6->ip6_nxt);
	else {
		int len, nxt;
		struct ip6_ext *ip6e = NULL;

		nxt = ip6->ip6_nxt;
		len = sizeof(struct ip6_hdr);
		while (len < off) {
			ip6e = (struct ip6_ext *)(mtod(m, caddr_t) + len);

			switch (nxt) {
			case IPPROTO_FRAGMENT:
				len += sizeof(struct ip6_frag);
				break;
			case IPPROTO_AH:
				len += (ip6e->ip6e_len + 2) << 2;
				break;
			default:
				len += (ip6e->ip6e_len + 1) << 3;
				break;
			}
			nxt = ip6e->ip6e_nxt;
		}
		if (ip6e)
			return (&ip6e->ip6e_nxt);
		else
			return NULL;
	}
}

/*
 * get next header offset.  m will be retained.
 */
int
ip6_nexthdr(struct mbuf *m, int off, int proto, int *nxtp)
{
	struct ip6_hdr ip6;
	struct ip6_ext ip6e;
	struct ip6_frag fh;

	/* just in case */
	if (m == NULL)
		panic("ip6_nexthdr: m == NULL");
	if ((m->m_flags & M_PKTHDR) == 0 || m->m_pkthdr.len < off)
		return -1;

	switch (proto) {
	case IPPROTO_IPV6:
		if (m->m_pkthdr.len < off + sizeof(ip6))
			return -1;
		m_copydata(m, off, sizeof(ip6), (caddr_t)&ip6);
		if (nxtp)
			*nxtp = ip6.ip6_nxt;
		off += sizeof(ip6);
		return off;

	case IPPROTO_FRAGMENT:
		/*
		 * terminate parsing if it is not the first fragment,
		 * it does not make sense to parse through it.
		 */
		if (m->m_pkthdr.len < off + sizeof(fh))
			return -1;
		m_copydata(m, off, sizeof(fh), (caddr_t)&fh);
		if ((fh.ip6f_offlg & IP6F_OFF_MASK) != 0)
			return -1;
		if (nxtp)
			*nxtp = fh.ip6f_nxt;
		off += sizeof(struct ip6_frag);
		return off;

	case IPPROTO_AH:
		if (m->m_pkthdr.len < off + sizeof(ip6e))
			return -1;
		m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
		if (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 2) << 2;
		if (m->m_pkthdr.len < off)
			return -1;
		return off;

	case IPPROTO_HOPOPTS:
	case IPPROTO_ROUTING:
	case IPPROTO_DSTOPTS:
		if (m->m_pkthdr.len < off + sizeof(ip6e))
			return -1;
		m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
		if (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 1) << 3;
		if (m->m_pkthdr.len < off)
			return -1;
		return off;

	case IPPROTO_NONE:
	case IPPROTO_ESP:
	case IPPROTO_IPCOMP:
		/* give up */
		return -1;

	default:
		return -1;
	}

	return -1;
}

/*
 * get offset for the last header in the chain.  m will be kept untainted.
 */
int
ip6_lasthdr(struct mbuf *m, int off, int proto, int *nxtp)
{
	int newoff;
	int nxt;

	if (!nxtp) {
		nxt = -1;
		nxtp = &nxt;
	}
	while (1) {
		newoff = ip6_nexthdr(m, off, proto, nxtp);
		if (newoff < 0)
			return off;
		else if (newoff < off)
			return -1;	/* invalid */
		else if (newoff == off)
			return newoff;

		off = newoff;
		proto = *nxtp;
	}
}

/*
 * System control for IP6
 */

u_char	inet6ctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	EHOSTUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
};

int *ipv6ctl_vars[IPV6CTL_MAXID] = IPV6CTL_VARS;

int
ip6_sysctl_ip6stat(void *oldp, size_t *oldlenp, void *newp)
{
	struct ip6stat *ip6stat;
	int ret;

	CTASSERT(sizeof(*ip6stat) == (ip6s_ncounters * sizeof(uint64_t)));

	ip6stat = malloc(sizeof(*ip6stat), M_TEMP, M_WAITOK);
	counters_read(ip6counters, (uint64_t *)ip6stat, ip6s_ncounters);
	ret = sysctl_rdstruct(oldp, oldlenp, newp,
	    ip6stat, sizeof(*ip6stat));
	free(ip6stat, M_TEMP, sizeof(*ip6stat));

	return (ret);
}

int
ip6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
#ifdef MROUTING
	extern int ip6_mrtproto;
	extern struct mrt6stat mrt6stat;
#endif
	int error;

	NET_ASSERT_LOCKED();

	/* Almost all sysctl names at this level are terminal. */
	if (namelen != 1 && name[0] != IPV6CTL_IFQUEUE)
		return (ENOTDIR);

	switch (name[0]) {
	case IPV6CTL_DAD_PENDING:
		return sysctl_rdint(oldp, oldlenp, newp, ip6_dad_pending);
	case IPV6CTL_STATS:
		return (ip6_sysctl_ip6stat(oldp, oldlenp, newp));
#ifdef MROUTING
	case IPV6CTL_MRTSTATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &mrt6stat, sizeof(mrt6stat)));
	case IPV6CTL_MRTPROTO:
		return sysctl_rdint(oldp, oldlenp, newp, ip6_mrtproto);
	case IPV6CTL_MRTMIF:
		if (newp)
			return (EPERM);
		return mrt6_sysctl_mif(oldp, oldlenp);
	case IPV6CTL_MRTMFC:
		if (newp)
			return (EPERM);
		return mrt6_sysctl_mfc(oldp, oldlenp);
#else
	case IPV6CTL_MRTSTATS:
	case IPV6CTL_MRTPROTO:
	case IPV6CTL_MRTMIF:
	case IPV6CTL_MRTMFC:
		return (EOPNOTSUPP);
#endif
	case IPV6CTL_MTUDISCTIMEOUT:
		error = sysctl_int(oldp, oldlenp, newp, newlen,
		   &ip6_mtudisc_timeout);
		if (icmp6_mtudisc_timeout_q != NULL)
			rt_timer_queue_change(icmp6_mtudisc_timeout_q,
					      ip6_mtudisc_timeout);
		return (error);
	case IPV6CTL_IFQUEUE:
		return (sysctl_niq(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen, &ip6intrq));
	default:
		if (name[0] < IPV6CTL_MAXID)
			return (sysctl_int_arr(ipv6ctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
ip6_send_dispatch(void *xmq)
{
	struct mbuf_queue *mq = xmq;
	struct mbuf *m;
	struct mbuf_list ml;
	int s;

	mq_delist(mq, &ml);
	if (ml_empty(&ml))
		return;

	KERNEL_LOCK();
	NET_LOCK(s);
	while ((m = ml_dequeue(&ml)) != NULL) {
		ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, NULL);
	}
	NET_UNLOCK(s);
	KERNEL_UNLOCK();
}

void
ip6_send(struct mbuf *m)
{
	mq_enqueue(&ip6send_mq, m);
	task_add(softnettq, &ip6send_task);
}
@


1.182
log
@Convert bcopy to memcpy as the memory does not overlap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.181 2017/03/06 08:59:07 mpi Exp $	*/
d535 2
a536 1
		nxt = (*inet6sw[ip6_protox[nxt]].pr_input)(&m, &off, nxt);
@


1.181
log
@Kill global list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.180 2017/02/28 09:59:34 mpi Exp $	*/
d780 1
a780 1
			bcopy((caddr_t)(opt + 2), (caddr_t)&rtalert_val, 2);
d813 1
a813 1
			 * we'd need to perform bcopy().
d815 1
a815 1
			bcopy(opt + 2, &jumboplen, sizeof(jumboplen));
d938 1
a938 1
		bcopy(&ip6->ip6_dst, &pi6.ipi6_addr, sizeof(struct in6_addr));
@


1.180
log
@Some refactoring in ip6_input() needed to un-KERNEL_LOCK() the IPv6
forwarding path.

Rename ip6_ours() in ip6_local() as this function dispatches packets
to the upper layer.

Introduce ip6_ours() and get rid of 'goto hbhcheck'.  This function
will be later used to enqueue local packets.

As a bonus this reduces differences with IPv4.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.179 2017/02/08 12:37:43 bluhm Exp $	*/
a116 1
struct in6_ifaddrhead in6_ifaddr;
a153 1
	TAILQ_INIT(&in6_ifaddr);
@


1.179
log
@Remove the ipsec protocol callbacks which all do the same.  Implement
it in ipsec_common_input_cb() instead.  The code that was copied
to ah6_input_cb() is now in ip6_ours() so we can call it directly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.178 2017/02/06 16:01:25 bluhm Exp $	*/
d122 1
d343 2
a344 2
		ours = 1;
		goto hbhcheck;
d349 2
a350 2
		ours = 1;
		goto hbhcheck;
d387 1
d390 5
a394 1
				goto bad;
d396 1
a396 4

			if (!ours)
				goto bad;
			ip6_ours(m, off, nxt);
d406 2
a407 1
		goto hbhcheck;
d445 2
a446 3
			/* this address is ready */
			ours = 1;
			goto hbhcheck;
a464 2
  hbhcheck:

d469 3
a471 1
		ip6_ours(m, off, nxt);
a474 3
	/*
	 * Forward if desirable.
	 */
d486 12
a497 1
ip6_ours(struct mbuf *m, int off, int nxt)
d501 2
d598 1
a598 1
		if (rtalert != ~0 && ip6_forwarding)
@


1.178
log
@Make ip6_input() more like ipv4_input() and introduce ip6_ours().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.177 2017/02/05 16:23:38 jca Exp $	*/
a124 1
void ip6_ours(struct mbuf *, int, int);
@


1.177
log
@Always allocate counters memory using type M_COUNTERS.

This makes the API simpler, and is probably more useful than spreading
counters memory other several types, making it harder to track.

Prodded by mpi, ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.176 2017/02/05 16:04:14 jca Exp $	*/
a122 1

d125 1
d184 1
a184 1
	int off, nest;
a185 1
	int nxt, ours = 0;
d200 1
a200 2
			if_put(ifp);
			return;
d338 1
a338 3
		/* m is already freed */
		if_put(ifp);
		return;
d374 2
a375 5
			if (ip6_hbhchcheck(m, &off, &nxt, &ours)) {
				rtfree(rt);
				if_put(ifp);
				return;	/* m have already been freed */
			}
d387 1
a387 1
		    	if (ip6_mforward(ip6, ifp, m)) {
d394 2
a395 1
			goto ours;
d465 6
a470 4
	if (ip6_hbhchcheck(m, &off, &nxt, &ours)) {
		rtfree(rt);
		if_put(ifp);
		return;	/* m have already been freed */
a472 3
	/* adjust pointer */
	ip6 = mtod(m, struct ip6_hdr *);

d476 15
a490 8
	if (!ours) {
		ip6_forward(m, rt, srcrt);
		if_put(ifp);
		return;
	}
#ifdef MROUTING
  ours:
#endif
a493 2
	ip6 = mtod(m, struct ip6_hdr *);

a497 1
	nest = 0;
a526 2
	rtfree(rt);
	if_put(ifp);
a528 2
	rtfree(rt);
	if_put(ifp);
@


1.176
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.175 2017/01/29 19:58:47 bluhm Exp $	*/
d162 1
a162 1
	ip6counters = counters_alloc(ip6s_ncounters, M_COUNTERS);
@


1.175
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.174 2016/12/27 18:45:01 bluhm Exp $	*/
d120 1
a120 1
struct ip6stat ip6stat;
d161 2
d196 1
a196 19
	if (m->m_flags & M_EXT) {
		if (m->m_next)
			ip6stat.ip6s_mext2m++;
		else
			ip6stat.ip6s_mext1++;
	} else {
		if (m->m_next) {
			int ifidx = m->m_pkthdr.ph_ifidx;
			if (m->m_flags & M_LOOP)
				ifidx = rtable_loindex(m->m_pkthdr.ph_rtableid);
			if (ifidx < nitems(ip6stat.ip6s_m2m))
				ip6stat.ip6s_m2m[ifidx]++;
			else
				ip6stat.ip6s_m2m[0]++;
		} else
			ip6stat.ip6s_m1++;
	}

	ip6stat.ip6s_total++;
d200 1
a200 1
			ip6stat.ip6s_toosmall++;
d209 1
a209 1
		ip6stat.ip6s_badvers++;
d219 1
a219 1
	ip6stat.ip6s_nxthist[ip6->ip6_nxt]++;
d229 1
a229 1
		ip6stat.ip6s_badscope++;
d235 1
a235 1
		    ip6stat.ip6s_badscope++;
d242 1
a242 1
		ip6stat.ip6s_badscope++;
d253 1
a253 1
		ip6stat.ip6s_badscope++;
d271 1
a271 1
		ip6stat.ip6s_badscope++;
d282 1
a282 1
		ip6stat.ip6s_badscope++;
d338 1
a338 1
		ip6stat.ip6s_badoptions++;
d395 1
a395 1
				ip6stat.ip6s_cantforward++;
d405 1
a405 1
			ip6stat.ip6s_notmember++;
d407 1
a407 1
				ip6stat.ip6s_cantforward++;
d465 1
a465 1
		ip6stat.ip6s_cantforward++;
d499 1
a499 1
	ip6stat.ip6s_delivered++;
d504 1
a504 1
			ip6stat.ip6s_toomanyhdr++;
d513 1
a513 1
			ip6stat.ip6s_tooshort++;
d575 1
a575 1
			ip6stat.ip6s_badoptions++;
d584 1
a584 1
			ip6stat.ip6s_tooshort++;
d605 1
a605 1
		ip6stat.ip6s_tooshort++;
d708 1
a708 1
		ip6stat.ip6s_tooshort++;
d715 1
a715 1
		ip6stat.ip6s_tooshort++;
d758 1
a758 1
				ip6stat.ip6s_toosmall++;
d766 1
a766 1
				ip6stat.ip6s_toosmall++;
d783 1
a783 1
				ip6stat.ip6s_toosmall++;
d801 1
a801 1
				ip6stat.ip6s_badoptions++;
d825 1
a825 1
				ip6stat.ip6s_badoptions++;
d837 1
a837 1
				ip6stat.ip6s_badoptions++;
d848 1
a848 1
				ip6stat.ip6s_toosmall++;
d885 1
a885 1
		ip6stat.ip6s_badoptions++;
d889 1
a889 1
		ip6stat.ip6s_badoptions++;
d992 1
a992 1
				ip6stat.ip6s_tooshort++;
d999 1
a999 1
				ip6stat.ip6s_tooshort++;
d1052 1
a1052 1
				ip6stat.ip6s_tooshort++;
d1062 1
a1062 1
				ip6stat.ip6s_tooshort++;
d1337 17
d1373 1
a1373 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &ip6stat, sizeof(ip6stat)));
@


1.174
log
@Move nd6 timer initialisation to nd6_init() and call timeout_set()
only once during init.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.173 2016/12/26 21:30:10 jca Exp $	*/
d141 1
a141 1
	struct ip6protosw *pr;
d144 1
a144 1
	pr = (struct ip6protosw *)pffindproto(PF_INET6, IPPROTO_RAW, SOCK_RAW);
d149 2
a150 2
	for (pr = (struct ip6protosw *)inet6domain.dom_protosw;
	    pr < (struct ip6protosw *)inet6domain.dom_protoswNPROTOSW; pr++)
d923 2
a924 2
 * The routine will be called from upper layer handlers like tcp6_input().
 * Thus the routine assumes that the caller (tcp6_input) have already
@


1.173
log
@Typo, "more then" -> "more than"
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.172 2016/12/20 18:33:43 bluhm Exp $	*/
a121 1
void ip6_init2(void *);
a158 1
	ip6_init2(NULL);
a160 10
}

void
ip6_init2(void *dummy)
{

	/* nd6_timer_init */
	bzero(&nd6_timer_ch, sizeof(nd6_timer_ch));
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add_sec(&nd6_timer_ch, 1);
@


1.172
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.171 2016/12/19 08:36:50 mpi Exp $	*/
d667 1
a667 1
				/* more then one rh header present */
@


1.171
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.170 2016/11/28 10:10:53 mpi Exp $	*/
d1372 3
a1374 1
	int error, s;
d1414 1
a1414 2
		if (icmp6_mtudisc_timeout_q != NULL) {
			s = splsoftnet();
a1416 2
			splx(s);
		}
@


1.170
log
@Merge two "#ifdef MROUTING" blocks.

It's one more step towards splitting ip6_input() in two and it reduces
differences with v4.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.169 2016/11/14 10:32:46 mpi Exp $	*/
d1440 3
d1444 1
a1444 1
	s = splsoftnet();
d1448 1
a1448 1
	splx(s);
@


1.169
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.168 2016/08/24 09:41:12 mpi Exp $	*/
a389 1

d403 1
d405 26
a430 3
		else if (!ip6_mforwarding || !ip6_mrouter)
#else
		else
d432 1
a432 1
		{
d511 1
a511 19
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		/*
		 * If we are acting as a multicast router, all
		 * incoming multicast packets are passed to the
		 * kernel-level multicast forwarding function.
		 * The packet is returned (relatively) intact; if
		 * ip6_mforward() returns a non-zero value, the packet
		 * must be discarded, else it may be accepted below.
		 */
#ifdef MROUTING
		if (ip6_mforwarding && ip6_mrouter &&
		    ip6_mforward(ip6, ifp, m)) {
			ip6stat.ip6s_cantforward++;
			goto bad;
		}
#endif
		if (!ours)
			goto bad;
	} else if (!ours) {
d516 3
a518 1

@


1.168
log
@Kill ip6_forward_rt reducing differences between v4 and v6.

A single forwarding cache is not the answer.  The answer is 42... err PF!

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.167 2016/07/19 15:57:13 phessler Exp $	*/
d213 5
a217 4
			if (m->m_flags & M_LOOP) {
				ip6stat.ip6s_m2m[lo0ifidx]++;	/*XXX*/
			} else if (ifp->if_index < nitems(ip6stat.ip6s_m2m))
				ip6stat.ip6s_m2m[ifp->if_index]++;
@


1.167
log
@protect a pf specific function with the correct #if.  Fixes ramdisk building.
(we got lucky before, because the variable that used to be checked was
always available)

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.166 2016/07/19 09:23:51 bluhm Exp $	*/
a186 2
extern struct	route_in6 ip6_forward_rt;

d192 2
d417 1
d421 6
a426 25
	if (rtisvalid(ip6_forward_rt.ro_rt) &&
	    !ISSET(ip6_forward_rt.ro_rt->rt_flags, RTF_MPATH) &&
	    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
			       &ip6_forward_rt.ro_dst.sin6_addr) &&
	    m->m_pkthdr.ph_rtableid == ip6_forward_rt.ro_tableid)
		ip6stat.ip6s_forward_cachehit++;
	else {
		if (ip6_forward_rt.ro_rt) {
			/* route is down or destination is different */
			ip6stat.ip6s_forward_cachemiss++;
			rtfree(ip6_forward_rt.ro_rt);
			ip6_forward_rt.ro_rt = NULL;
		}

		bzero(&ip6_forward_rt.ro_dst, sizeof(struct sockaddr_in6));
		ip6_forward_rt.ro_dst.sin6_len = sizeof(struct sockaddr_in6);
		ip6_forward_rt.ro_dst.sin6_family = AF_INET6;
		ip6_forward_rt.ro_dst.sin6_addr = ip6->ip6_dst;
		ip6_forward_rt.ro_tableid = m->m_pkthdr.ph_rtableid;

		ip6_forward_rt.ro_rt = rtalloc_mpath(
		    sin6tosa(&ip6_forward_rt.ro_dst),
		    &ip6->ip6_src.s6_addr32[0],
		    ip6_forward_rt.ro_tableid);
	}
d432 2
a433 4
	if (rtisvalid(ip6_forward_rt.ro_rt) &&
	    ISSET(ip6_forward_rt.ro_rt->rt_flags, RTF_LOCAL)) {
		struct in6_ifaddr *ia6 =
			ifatoia6(ip6_forward_rt.ro_rt->rt_ifa);
d476 1
d506 1
a506 1
		ip6_forward(m, srcrt);
d550 1
d554 1
@


1.166
log
@In ip6_input() use a shortcut to detect our own address if the pf
state key is linked to a socket inp.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.165 2016/07/19 08:13:46 mpi Exp $	*/
d378 1
d383 1
@


1.165
log
@Use a flag to indicate that a packet has been received on an IPv6
anycast address.

This will allow us to split ip6_input() in two parts using a queue
in the middle.

ok jca@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.164 2016/07/18 19:50:49 bluhm Exp $	*/
d378 1
a378 1
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
@


1.164
log
@Kill the rtableid variable in ip6_input().  It does not make sense
to store a field in an extra variable that is only accessed twice.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.163 2016/07/14 14:39:12 mpi Exp $	*/
d200 1
a200 1
	int srcrt = 0, isanycast = 0;
d453 1
a453 1
			isanycast = 1;
d555 1
a555 1
		if (isanycast && nxt == IPPROTO_TCP) {
@


1.163
log
@Drop received packets with an IPv4-compatible address as source or
destination as per RFC4213.

We're not in 1999 anymore, what was earlier a "stronger check than
RFC1933" is now a best practice.  This matches the behavior of the
reject (R) routes added by default by netstart(8).

ok jca@@, florian@@, claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.162 2016/07/06 15:50:00 mpi Exp $	*/
a200 1
	u_int rtableid = 0;
a414 2
	rtableid = m->m_pkthdr.ph_rtableid;

d422 1
a422 1
	    rtableid == ip6_forward_rt.ro_tableid)
d436 1
a436 1
		ip6_forward_rt.ro_tableid = rtableid;
@


1.162
log
@Move Hop-by-Hop processing into its own function ip6_hbhchcheck().

This function will help splitting the IPv6 input path in two, in
order to run the first part without KERNEL_LOCK() held.

Tested by Hrvoje Popovski, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.161 2016/07/05 10:17:14 mpi Exp $	*/
d302 1
a302 1
#if 0
d306 1
a306 3
	 * The code forbids auto tunnel relay case in RFC1933 (the check is
	 * stronger than RFC1933).  We may want to re-enable it if mech-xx
	 * is revised to forbid relaying case.
a312 1
#endif
@


1.161
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.160 2016/05/19 11:34:40 jca Exp $	*/
d125 1
a195 1
	u_int32_t plen, rtalert = ~0;
a497 9
	/*
	 * Process Hop-by-Hop options header if it's contained.
	 * m may be modified in ip6_hopopts_input().
	 * If a JumboPayload option is included, plen will also be modified.
	 */
	plen = (u_int32_t)ntohs(ip6->ip6_plen);
	off = sizeof(struct ip6_hdr);
	if (ip6->ip6_nxt == IPPROTO_HOPOPTS) {
		struct ip6_hbh *hbh;
d499 4
a502 4
		if (ip6_hopopts_input(&plen, &rtalert, &m, &off)) {
			if_put(ifp);
			return;	/* m have already been freed */
		}
d504 2
a505 56
		/* adjust pointer */
		ip6 = mtod(m, struct ip6_hdr *);

		/*
		 * if the payload length field is 0 and the next header field
		 * indicates Hop-by-Hop Options header, then a Jumbo Payload
		 * option MUST be included.
		 */
		if (ip6->ip6_plen == 0 && plen == 0) {
			/*
			 * Note that if a valid jumbo payload option is
			 * contained, ip6_hopopts_input() must set a valid
			 * (non-zero) payload length to the variable plen.
			 */
			ip6stat.ip6s_badoptions++;
			icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    (caddr_t)&ip6->ip6_plen - (caddr_t)ip6);
			if_put(ifp);
			return;
		}
		IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m, sizeof(struct ip6_hdr),
			sizeof(struct ip6_hbh));
		if (hbh == NULL) {
			ip6stat.ip6s_tooshort++;
			if_put(ifp);
			return;
		}
		nxt = hbh->ip6h_nxt;

		/*
		 * accept the packet if a router alert option is included
		 * and we act as an IPv6 router.
		 */
		if (rtalert != ~0 && ip6_forwarding)
			ours = 1;
	} else
		nxt = ip6->ip6_nxt;

	/*
	 * Check that the amount of data in the buffers
	 * is as at least much as the IPv6 header would have us expect.
	 * Trim mbufs if longer than we expect.
	 * Drop packet if shorter than we expect.
	 */
	if (m->m_pkthdr.len - sizeof(struct ip6_hdr) < plen) {
		ip6stat.ip6s_tooshort++;
		goto bad;
	}
	if (m->m_pkthdr.len > sizeof(struct ip6_hdr) + plen) {
		if (m->m_len == m->m_pkthdr.len) {
			m->m_len = sizeof(struct ip6_hdr) + plen;
			m->m_pkthdr.len = sizeof(struct ip6_hdr) + plen;
		} else
			m_adj(m, sizeof(struct ip6_hdr) + plen - m->m_pkthdr.len);
	}
d578 83
@


1.160
log
@Remove sysctl net.inet6.ip6.v6only

This sysctl is a no-op, read-only since it was introduced.  There are no
plans to support IPv4-mapped addresses on OpenBSD, thus this sysctl is
meaningless.

Noticed by djm@@, ok claudio@@ mpi@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.159 2016/05/07 09:58:06 mpi Exp $	*/
d464 1
a464 5
		if (!(ia6->ia6_flags & IN6_IFF_NOTREADY)) {
			/* this address is ready */
			ours = 1;
			goto hbhcheck;
		} else {
d475 4
@


1.159
log
@Remove duplicate check.

ok sthen@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.158 2016/04/19 08:23:13 mpi Exp $	*/
a1371 2
	case IPV6CTL_V6ONLY:
		return sysctl_rdint(oldp, oldlenp, newp, ip6_v6only);
@


1.158
log
@Instead of freeing a cached RTF_MPATH route after using it, free it
when the next packet needs to be forwarded, just like if the route
was invalid.

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.157 2016/04/11 13:02:35 mpi Exp $	*/
a600 15

	/*
	 * Malicious party may be able to use IPv4 mapped addr to confuse
	 * tcp/udp stack and bypass security checks (act as if it was from
	 * 127.0.0.1 by using IPv6 src ::ffff:127.0.0.1).  Be cautious.
	 *
	 * For SIIT end node behavior, you may want to disable the check.
	 * However, you will  become vulnerable to attacks using IPv4 mapped
	 * source.
	 */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		ip6stat.ip6s_badscope++;
		goto bad;
	}
@


1.157
log
@Search in the correct routing table if NPF is not defined.

ok jca@@, phessler@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.156 2016/03/29 11:57:51 chl Exp $	*/
d425 1
@


1.156
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.155 2016/03/14 23:08:06 krw Exp $	*/
a418 1
#if NPF > 0
a419 1
#endif
@


1.155
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.154 2016/01/21 11:23:48 mpi Exp $	*/
a641 1
				ip6 = mtod(m, struct ip6_hdr *);
@


1.154
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.153 2016/01/06 10:02:42 sthen Exp $	*/
d159 1
a159 1
	ip6_init2((void *)0);
@


1.153
log
@fix comment typos
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.152 2015/12/03 21:11:54 sashan Exp $	*/
a390 1
		struct	in6_multi *in6m = NULL;
d403 1
a403 2
		IN6_LOOKUP_MULTI(ip6->ip6_dst, ifp, in6m);
		if (in6m)
@


1.152
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.151 2015/11/11 10:23:23 mpi Exp $	*/
d527 1
a527 1
			 * contained, ip6_hoptops_input() must set a valid
d1017 1
a1017 1
		 * Check if a hop-by-hop options header is contatined in the
@


1.151
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.150 2015/10/29 16:04:10 tedu Exp $	*/
d80 1
d93 1
d128 6
d160 2
d1443 25
@


1.150
log
@RFC 2292 API support was removed 9 years ago, but left in a binary compat
ABI form for the sake of existing programs. no programs from that era have
been able to run for quite some time. Kill it all.
ok deraadt florian millert mpi
(I believe this is my first IPv6 diff. Future, here I come!)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.149 2015/10/23 00:15:07 jsg Exp $	*/
d205 1
a205 1
				ip6stat.ip6s_m2m[lo0ifp->if_index]++;	/*XXX*/
@


1.149
log
@replace pointer arithmetic and casts with offsetof
ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.148 2015/10/19 12:11:28 mpi Exp $	*/
a947 1
#define IS2292(x, y)	((in6p->inp_flags & IN6P_RFC2292) ? (x) : (y))
d971 1
a971 1
		    IS2292(IPV6_2292PKTINFO, IPV6_PKTINFO), IPPROTO_IPV6);
d979 1
a979 1
		    IS2292(IPV6_2292HOPLIMIT, IPV6_HOPLIMIT), IPPROTO_IPV6);
d1041 1
a1041 1
			    IS2292(IPV6_2292HOPOPTS, IPV6_HOPOPTS),
d1102 1
a1102 1
				    IS2292(IPV6_2292DSTOPTS, IPV6_DSTOPTS),
d1113 1
a1113 1
				    IS2292(IPV6_2292RTHDR, IPV6_RTHDR),
@


1.148
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.147 2015/10/13 10:29:16 mpi Exp $	*/
d637 1
a637 1
					(caddr_t)&ip6->ip6_dst - (caddr_t)ip6);
@


1.147
log
@Make use of rtisvalid(9) to check if local route entries match existing
configured addressses.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.146 2015/09/11 09:54:46 claudio Exp $	*/
d418 1
a418 2
	if (ip6_forward_rt.ro_rt != NULL &&
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) != 0 &&
@


1.146
log
@if_put for ip6_input. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.145 2015/09/10 09:14:59 mpi Exp $	*/
d448 1
a448 1
	if (ip6_forward_rt.ro_rt &&
@


1.145
log
@Fewer in6_ifstat_inc()

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.144 2015/07/16 21:14:21 mpi Exp $	*/
a186 1
	struct ifnet *deliverifp = NULL;
d219 1
d331 1
a331 1
		return;
d362 1
a368 1
		deliverifp = ifp;
a373 1
		deliverifp = ifp;
a407 1
		deliverifp = ifp;
a460 1
			deliverifp = ia6->ia_ifp;	/* correct? */
d502 2
a503 1
		if (ip6_hopopts_input(&plen, &rtalert, &m, &off))
d505 1
d525 1
d532 1
d580 1
a580 2
			m_freem(m);
			return;
d583 2
a584 4
		if (!ours) {
			m_freem(m);
			return;
		}
d587 1
d646 1
d649 1
@


1.144
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.143 2015/06/16 11:09:40 mpi Exp $	*/
a214 1
	in6_ifstat_inc(ifp, ifs6_in_receive);
a219 1
			in6_ifstat_inc(ifp, ifs6_in_hdrerr);
a227 1
		in6_ifstat_inc(ifp, ifs6_in_hdrerr);
a247 1
		in6_ifstat_inc(ifp, ifs6_in_addrerr);
a253 1
		    in6_ifstat_inc(ifp, ifs6_in_addrerr);
a271 1
		in6_ifstat_inc(ifp, ifs6_in_addrerr);
a289 1
		in6_ifstat_inc(ifp, ifs6_in_addrerr);
a302 1
		in6_ifstat_inc(ifp, ifs6_in_addrerr);
a359 2
		in6_ifstat_inc(ifp, ifs6_in_discard);
		in6_ifstat_inc(ifp, ifs6_in_hdrerr);
a390 1
		in6_ifstat_inc(ifp, ifs6_in_mcast);
a406 1
			in6_ifstat_inc(ifp, ifs6_in_discard);
a490 1
		in6_ifstat_inc(ifp, ifs6_in_discard);
d505 1
a505 4
		if (ip6_hopopts_input(&plen, &rtalert, &m, &off)) {
#if 0	/*touches NULL pointer*/
			in6_ifstat_inc(ifp, ifs6_in_discard);
#endif
a506 1
		}
a522 2
			in6_ifstat_inc(ifp, ifs6_in_discard);
			in6_ifstat_inc(ifp, ifs6_in_hdrerr);
a552 1
		in6_ifstat_inc(ifp, ifs6_in_truncated);
a608 1
		in6_ifstat_inc(ifp, ifs6_in_addrerr);
a615 1
	in6_ifstat_inc(deliverifp, ifs6_in_deliver);
a629 1
			in6_ifstat_inc(ifp, ifs6_in_truncated);
@


1.143
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.142 2015/06/08 22:19:28 krw Exp $	*/
d336 1
a336 1
	if (pf_test(AF_INET6, PF_IN, ifp, &m, NULL) != PF_PASS)
@


1.142
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.141 2015/04/10 13:58:20 dlg Exp $	*/
d194 3
a196 1
	ifp = m->m_pkthdr.rcvif;
d992 1
a992 2
		pi6.ipi6_ifindex =
		    (m && m->m_pkthdr.rcvif) ? m->m_pkthdr.rcvif->if_index : 0;
@


1.141
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.140 2015/03/14 03:38:52 jsg Exp $	*/
d137 1
a137 1
	if (pr == 0)
d390 1
a390 1
	  	struct	in6_multi *in6m = 0;
d431 1
a431 1
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) != 0 && 
d535 1
a535 1
			 * (non-zero) payload length to the variable plen. 
d608 1
a608 1
	}	
d716 1
a716 1
				 * reject the packet but as a router we 
d792 1
a792 1
ip6_process_hopopts(struct mbuf *m, u_int8_t *opthead, int hbhlen, 
d1165 2
a1166 2
	  loopend:
	  	;
d1390 1
a1390 1
ip6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, 
@


1.140
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.139 2015/02/09 12:23:22 claudio Exp $	*/
d116 1
a116 1
struct ifqueue ip6intrq;
a146 1
	IFQ_SET_MAXLEN(&ip6intrq, IFQ_MAXLEN);
a169 1
	int s;
d172 1
a172 6
	for (;;) {
		s = splnet();
		IF_DEQUEUE(&ip6intrq, m);
		splx(s);
		if (m == NULL)
			return;
a173 1
	}
d1447 1
a1447 1
		return (sysctl_ifq(name + 1, namelen - 1,
@


1.139
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mf6c) and the
multicast interface table (mif6). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.138 2015/02/09 12:04:27 dlg Exp $	*/
a83 1
#include <net/if_dl.h>
@


1.138
log
@provide a net.inet6.ip6.ifq sysctl so people can see and fiddle
with the ip6intrq.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.137 2015/02/09 09:50:00 mpi Exp $	*/
d1422 1
a1423 1
#ifdef MROUTING
a1427 3
#else
		return (EOPNOTSUPP);
#endif
a1428 1
#ifdef MROUTING
d1430 8
d1439 4
@


1.137
log
@Remove a chunk missed in previous scope ID shuffling creating wrong
states for external traffic through a link-local address.

Found the hard way and fix tested by bluhm@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.136 2015/02/05 01:10:57 mpi Exp $	*/
d1408 3
a1410 3
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;
d1447 3
@


1.136
log
@Make sure pf(4) does not see embedded scopes.

Packets destinated to link-local addresses are looped back with embedded
scopes because we cannot restore them using the receiving interface (lo0).
Embedded scopes are needed by the routing table to match RTF_LOCAL routes,
but pf(4) never saw them and existing rules are likely to break without
teaching the rule engine about them, found by dlg@@ the hard way.

So save and restore embedded scopes around pf_test() for packets going
through loopback.

ok dlg@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.135 2015/01/19 13:53:55 mpi Exp $	*/
a335 12
	}

	/*
	 * If the packet has been received on a loopback interface it
	 * can be destinated to any local address, not necessarily to
	 * an address configured on `ifp'.
	 */
	if ((ifp->if_flags & IFF_LOOPBACK) == 0) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = htons(ifp->if_index);
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = htons(ifp->if_index);
@


1.135
log
@<netinet6/in6_ifattach.h> is not needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.134 2014/12/19 17:14:40 tedu Exp $	*/
d193 2
a194 2
	u_int32_t plen;
	u_int32_t rtalert = ~0;
d327 16
d363 16
@


1.134
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.133 2014/12/05 15:50:04 mpi Exp $	*/
a96 1
#include <netinet6/in6_ifattach.h>
@


1.133
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.132 2014/11/20 13:54:24 mpi Exp $	*/
a89 1
#ifdef INET
a90 1
#endif
@


1.132
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.131 2014/11/20 11:05:19 mpi Exp $	*/
d82 1
@


1.131
log
@In TCP and UDP layers do not (ab)use the receiving interface to check
for a multicast/broadcast destination address.

These checks have already been done in the Ethernet and IP layers and
the mbuf(9) should contain all the required information at this point.
But since we cannot trust this spaghetti stack, be paranoid and make
sure to set the flags in the IP input routines.

Use explicit comments, requested by deraadt@@.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.130 2014/10/14 09:52:26 mpi Exp $	*/
d270 7
d324 12
a370 37
	/* drop packets if interface ID portion is already filled */
	if ((IN6_IS_SCOPE_EMBED(&ip6->ip6_src) && ip6->ip6_src.s6_addr16[1]) ||
	    (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst) && ip6->ip6_dst.s6_addr16[1])) {
		if ((ifp->if_flags & IFF_LOOPBACK) == 0) {
			ip6stat.ip6s_badscope++;
			goto bad;
		}
	}

	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = htons(ifp->if_index);
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = htons(ifp->if_index);

	/*
	 * We use rt->rt_ifp to determine if the address is ours or not.
	 * If rt_ifp is lo0, the address is ours.
	 * The problem here is, rt->rt_ifp for fe80::%lo0/64 is set to lo0,
	 * so any address under fe80::%lo0/64 will be mistakenly considered
	 * local.  The special case is supplied to handle the case properly
	 * by actually looking at interface addresses
	 * (using in6ifa_ifpwithaddr).
	 */
	if ((ifp->if_flags & IFF_LOOPBACK) != 0 &&
	    IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst)) {
		if (!in6ifa_ifpwithaddr(ifp, &ip6->ip6_dst)) {
			icmp6_error(m, ICMP6_DST_UNREACH,
			    ICMP6_DST_UNREACH_ADDR, 0);
			/* m is already freed */
			return;
		}

		ours = 1;
		deliverifp = ifp;
		goto hbhcheck;
	}

d448 2
a449 7
	 * Accept the packet if the forwarding interface to the destination
	 * according to the routing table is the loopback interface,
	 * unless the associated route has a gateway.
	 * Note that this approach causes to accept a packet if there is a
	 * route to the loopback interface for the destination of the packet.
	 * But we think it's even useful in some situations, e.g. when using
	 * a special daemon which wants to intercept the packet.
d452 1
a452 3
	    (ip6_forward_rt.ro_rt->rt_flags &
	     (RTF_HOST|RTF_GATEWAY)) == RTF_HOST &&
	    ip6_forward_rt.ro_rt->rt_ifp->if_type == IFT_LOOP) {
@


1.130
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.129 2014/09/27 12:26:16 mpi Exp $	*/
d400 7
@


1.129
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.128 2014/07/22 11:06:10 mpi Exp $	*/
d442 2
a443 2
			RTFREE(ip6_forward_rt.ro_rt);
			ip6_forward_rt.ro_rt = 0;
@


1.128
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.127 2014/07/08 17:19:26 deraadt Exp $	*/
d452 4
a455 2
		rtalloc_mpath((struct route *)&ip6_forward_rt,
		    &ip6->ip6_src.s6_addr32[0]);
@


1.127
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.126 2014/06/03 13:32:24 mpi Exp $	*/
a87 1
#include <netinet/in_systm.h>
@


1.126
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.125 2014/05/13 09:30:27 mpi Exp $	*/
d71 1
a1393 3

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>
@


1.125
log
@Remove some m->m_pkthdr.rcvif dereference to help for upcoming
receiving pointer -> index conversion.  No functional change.

ok claudio@@, mikeb@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.124 2014/04/14 09:06:42 mpi Exp $	*/
a68 1
#include <sys/malloc.h>
@


1.124
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.123 2014/02/13 11:20:54 mpi Exp $	*/
d193 1
d206 2
a207 3
	/*
	 * mbuf statistics by kazu
	 */
d217 2
a218 2
			} else if (m->m_pkthdr.rcvif->if_index < nitems(ip6stat.ip6s_m2m))
				ip6stat.ip6s_m2m[m->m_pkthdr.rcvif->if_index]++;
d225 1
a225 1
	in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_receive);
a228 2
		struct ifnet *inifp;
		inifp = m->m_pkthdr.rcvif;
d231 1
a231 1
			in6_ifstat_inc(inifp, ifs6_in_hdrerr);
d240 1
a240 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
d245 1
a245 2
	if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
	    ip6->ip6_nxt != IPPROTO_ICMPV6 &&
d261 1
a261 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d266 1
a266 1
	    (m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
d268 1
a268 1
		    in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d280 1
a280 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d299 1
a299 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d313 1
a313 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d323 1
a323 1
	if (pf_test(AF_INET6, PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
d339 2
a340 2
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
d349 1
a349 1
		deliverifp = m->m_pkthdr.rcvif;
d356 1
a356 1
		if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
d363 1
a363 1
		ip6->ip6_src.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d365 1
a365 1
		ip6->ip6_dst.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d376 1
a376 1
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) != 0 &&
d378 1
a378 1
		if (!in6ifa_ifpwithaddr(m->m_pkthdr.rcvif, &ip6->ip6_dst)) {
d386 1
a386 1
		deliverifp = m->m_pkthdr.rcvif;
d392 1
a392 1
		deliverifp = m->m_pkthdr.rcvif;
d402 1
a402 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_mcast);
d407 1
a407 1
		IN6_LOOKUP_MULTI(ip6->ip6_dst, m->m_pkthdr.rcvif, in6m);
d419 1
a419 1
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
d422 1
a422 1
		deliverifp = m->m_pkthdr.rcvif;
d498 1
a498 2
	if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
	    ip6->ip6_nxt == IPPROTO_ICMPV6 &&
d509 1
a509 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
d526 1
a526 1
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
d546 2
a547 2
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
d578 1
a578 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
d603 1
a603 1
		    ip6_mforward(ip6, m->m_pkthdr.rcvif, m)) {
d635 1
a635 1
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
d658 1
a658 1
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_truncated);
@


1.123
log
@Another chunk of IPv6 dead code bites the dust.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.122 2014/02/05 08:44:21 mpi Exp $	*/
d430 1
a430 1
	rtableid = m->m_pkthdr.rdomain;
@


1.122
log
@Kill some dead code.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.121 2013/11/15 16:15:42 bluhm Exp $	*/
a498 22

#if 0
    {
	/*
	 * Last resort: check in6_ifaddr for incoming interface.
	 * The code is here until I update the "goto ours hack" code above
	 * working right.
	 */
	struct ifaddr *ifa;
	TAILQ_FOREACH(ifa, &m->m_pkthdr.rcvif->if_addrlist, ifa_list) {
		if (ifa->ifa_addr == NULL)
			continue;	/* just for safety */
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (IN6_ARE_ADDR_EQUAL(IFA_IN6(ifa), &ip6->ip6_dst)) {
			ours = 1;
			deliverifp = ifa->ifa_ifp;
			goto hbhcheck;
		}
	}
    }
#endif
@


1.121
log
@After discussion with deraadt@@ and Fernando Gont, it seems that the
stack should still scan for IPv6 type 0 routing headers.  There are
OpenBSD routers running without pf and there are plenty of legacy
implementations supporting RH0.

Bring back the function ip6_check_rh0hdr() that I removed a month
ago.  As an improvement to the prevoius solution, only scan the
header chain in ip6_input() if the packet has not been inspected
by pf.  Both implementations drop packets with RH0 anywhere in the
extension header chain.

OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.120 2013/11/11 09:15:35 mpi Exp $	*/
a459 2
#define rt6_key(r) ((struct sockaddr_in6 *)((r)->rt_nodes->rn_key))

a471 9
#if 0
	    /*
	     * The check below is redundant since the comparison of
	     * the destination and the key of the rtentry has
	     * already done through looking up the routing table.
	     */
	    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
	    &rt6_key(ip6_forward_rt.ro_rt)->sin6_addr) &&
#endif
@


1.120
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.119 2013/10/28 21:02:35 deraadt Exp $	*/
d125 1
d335 14
d716 68
@


1.119
log
@kill kame version symbols and sysctl
ports tree grep run by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.118 2013/10/23 19:57:50 deraadt Exp $	*/
d483 4
d490 1
a490 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst)));
@


1.118
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.117 2013/10/21 12:27:16 deraadt Exp $	*/
a1365 2
	case IPV6CTL_KAME_VERSION:
		return sysctl_rdstring(oldp, oldlenp, newp, __KAME_VERSION);
@


1.117
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.116 2013/10/19 21:25:15 bluhm Exp $	*/
d928 1
a928 2
#define IS2292(x, y)	((in6p->in6p_flags & IN6P_RFC2292) ? (x) : (y))
# define in6p_flags	inp_flags
d944 1
a944 1
	if ((in6p->in6p_flags & IN6P_PKTINFO) != 0) {
d958 1
a958 1
	if ((in6p->in6p_flags & IN6P_HOPLIMIT) != 0) {
d966 1
a966 1
	if ((in6p->in6p_flags & IN6P_TCLASS) != 0) {
d987 1
a987 1
	if ((in6p->in6p_flags & IN6P_HOPOPTS) != 0) {
d1032 1
a1032 1
	if ((in6p->in6p_flags & (IN6P_RTHDR | IN6P_DSTOPTS)) != 0) {
d1080 1
a1080 1
				if (!(in6p->in6p_flags & IN6P_DSTOPTS))
d1091 1
a1091 1
				if (!(in6p->in6p_flags & IN6P_RTHDR))
a1126 1
# undef in6p_flags
@


1.116
log
@Our IPv6 stack was scanning all extension headers for routing header
type 0 and dropped the packet if it found one.  RFC 5095 demands
to handle a routing header type 0 like an unrecognised routing type.
This is enough to protect the own machine.

To protect a network as a firewall, we have pf which does the same
full scan in pf_walk_header6().  As pf is enabled by default, nothing
changes for most users.  If you turn off pf on your router, you
should not expect extra protection.

Get rid of the double scanning in ip6_input() and and the older
disabled code in route6_input().  No more special treatment of
routing header type 0 in the IPv6 stack.

OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.115 2013/10/17 16:27:46 bluhm Exp $	*/
d1361 1
d1394 10
@


1.115
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.114 2013/06/26 09:12:40 henning Exp $	*/
a124 1
int ip6_check_rh0hdr(struct mbuf *, int *);
a319 9
	if (ip6_check_rh0hdr(m, &off)) {
		ip6stat.ip6s_badoptions++;
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, off);
		/* m is already freed */
		return;
	}

a697 68
}

/* scan packet for RH0 routing header. Mostly stolen from pf.c:pf_test() */
int
ip6_check_rh0hdr(struct mbuf *m, int *offp)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct ip6_rthdr rthdr;
	struct ip6_ext opt6;
	u_int8_t proto = ip6->ip6_nxt;
	int done = 0, lim, off, rh_cnt = 0;

	off = ((caddr_t)ip6 - m->m_data) + sizeof(struct ip6_hdr);
	lim = min(m->m_pkthdr.len, ntohs(ip6->ip6_plen) + sizeof(*ip6));
	do {
		switch (proto) {
		case IPPROTO_ROUTING:
			*offp = off;
			if (rh_cnt++) {
				/* more then one rh header present */
				return (1);
			}

			if (off + sizeof(rthdr) > lim) {
				/* packet to short to make sense */
				return (1);
			}

			m_copydata(m, off, sizeof(rthdr), (caddr_t)&rthdr);

			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0) {
				*offp += offsetof(struct ip6_rthdr, ip6r_type);
				return (1);
			}

			off += (rthdr.ip6r_len + 1) * 8;
			proto = rthdr.ip6r_nxt;
			break;
		case IPPROTO_AH:
		case IPPROTO_HOPOPTS:
		case IPPROTO_DSTOPTS:
			/* get next header and header length */
			if (off + sizeof(opt6) > lim) {
				/*
				 * Packet to short to make sense, we could
				 * reject the packet but as a router we 
				 * should not do that so forward it.
				 */
				return (0);
			}

			m_copydata(m, off, sizeof(opt6), (caddr_t)&opt6);

			if (proto == IPPROTO_AH)
				off += (opt6.ip6e_len + 2) * 4;
			else
				off += (opt6.ip6e_len + 1) * 8;
			proto = opt6.ip6e_nxt;
			break;
		case IPPROTO_FRAGMENT:
		default:
			/* end of header stack */
			done = 1;
			break;
		}
	} while (!done);

	return (0);
@


1.114
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.113 2013/06/13 12:17:23 mpi Exp $	*/
a115 1
#include <netinet/in_var.h>
@


1.113
log
@Merge two blocks where we drop the packet to reduce the differences with
ipv4_inpu(), no functional change.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.112 2013/04/24 10:17:08 mpi Exp $	*/
d647 3
@


1.112
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.111 2013/03/28 23:10:06 tedu Exp $	*/
d353 3
a355 8
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src) &&
		    ip6->ip6_src.s6_addr16[1]) {
			ip6stat.ip6s_badscope++;
			goto bad;
		}
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst) &&
		    ip6->ip6_dst.s6_addr16[1]) {
@


1.111
log
@code that calls timeout functions should include timeout.h
slipped by on i386, but the zaurus doesn't automagically pick it up.
spotted by patrick
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.110 2013/03/28 16:45:16 tedu Exp $	*/
a119 4
extern struct domain inet6domain;
extern struct ip6protosw inet6sw[];

u_char ip6_protox[IPPROTO_MAX];
@


1.110
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.109 2013/03/26 13:19:26 mpi Exp $	*/
d77 1
@


1.109
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.108 2013/03/25 14:40:57 mpi Exp $	*/
a78 1
#include <sys/proc.h>
@


1.108
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.107 2013/03/14 11:18:37 mpi Exp $	*/
a123 1
static int ip6qmaxlen = IFQ_MAXLEN;
d156 1
a156 1
	IFQ_SET_MAXLEN(&ip6intrq, ip6qmaxlen);
@


1.107
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.106 2013/03/04 14:42:25 bluhm Exp $	*/
d125 1
a125 1
struct in6_ifaddr *in6_ifaddr;
d158 1
@


1.106
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.105 2012/11/06 12:32:42 henning Exp $	*/
a103 1
#include "faith.h"
a511 15

	/*
	 * FAITH (Firewall Aided Internet Translator)
	 */
#if defined(NFAITH) && 0 < NFAITH
	if (ip6_keepfaith) {
		if (ip6_forward_rt.ro_rt && ip6_forward_rt.ro_rt->rt_ifp
		 && ip6_forward_rt.ro_rt->rt_ifp->if_type == IFT_FAITH) {
			/* XXX do we need more sanity checks? */
			ours = 1;
			deliverifp = ip6_forward_rt.ro_rt->rt_ifp; /*faith*/
			goto hbhcheck;
		}
	}
#endif
@


1.105
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.104 2012/11/01 07:55:56 henning Exp $	*/
d491 1
a491 1
			(struct in6_ifaddr *)ip6_forward_rt.ro_rt->rt_ifa;
@


1.104
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.102 2011/08/04 16:40:08 bluhm Exp $	*/
a671 3

	/* pf might have changed things */
	in6_proto_cksum_out(m, NULL);
@


1.103
log
@According to the RFC 2460 and RFC 5095, ICMP Parameter Problem, Code 0
should be sent in response to an IPv6 packet with RH0.  Improve this a
bit further by filling in an icmp error pointer.

With sperreault, ok sperreault, sthen
@
text
@d673 3
@


1.102
log
@Move the check that ::1 is not allowed from the wire before pf_test().
Otherwise pf could reroute or redirect such a packet.  KAME moved
it in rev 1.189 of their ip6_input.c.  This also allows rdr or nat
to ::1 in pf.
bug report and test camield@@
ok mikeb@@; go for it deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.101 2011/07/06 02:42:28 henning Exp $	*/
d132 1
a132 1
int ip6_check_rh0hdr(struct mbuf *);
d200 1
a200 1
	int off = sizeof(struct ip6_hdr), nest;
d327 1
a327 1
	if (ip6_check_rh0hdr(m)) {
d331 1
a331 1
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, 0);
d336 1
a336 1
#if NPF > 0 
d575 1
d735 1
a735 1
ip6_check_rh0hdr(struct mbuf *m)
d748 1
d761 2
a762 1
			if (rthdr.ip6r_type == IPV6_RTHDR_TYPE_0)
d764 1
@


1.101
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.100 2011/07/04 06:54:49 claudio Exp $	*/
d273 7
a279 1

d352 3
a354 9
		if (m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) {
			ours = 1;
			deliverifp = m->m_pkthdr.rcvif;
			goto hbhcheck;
		} else {
			ip6stat.ip6s_badscope++;
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
			goto bad;
		}
@


1.100
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.99 2011/04/03 13:56:05 stsp Exp $	*/
d158 1
a158 1
	ip6intrq.ifq_maxlen = ip6qmaxlen;
@


1.99
log
@fix typos in comments
ok deraadt henning sthen thib (though thib says he can't spell)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.98 2010/09/09 09:46:13 claudio Exp $	*/
d335 1
a335 1
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
d732 1
a732 1
/* scan packet for RH0 routing header. Mostly stolen from pf.c:pf_test6() */
@


1.98
log
@Why ip6_input.c includes netinet/ip_icmp.h is beyond my imagination.
Compiles fine without it so remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.97 2010/07/08 19:42:46 jsg Exp $	*/
d977 2
a978 2
 * which is necessary if the IPv6 header the and option header and IPv6 header
 * is not continuous in order to return an ICMPv6 error.
@


1.97
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.96 2010/05/07 13:33:17 claudio Exp $	*/
d92 1
a92 2
#include <netinet/ip_icmp.h>
#endif /*INET*/
@


1.96
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.95 2010/02/08 12:16:02 jsing Exp $	*/
a128 4

int ip6_forward_srcrt;			/* XXX */
int ip6_sourcecheck;			/* XXX */
int ip6_sourcecheck_interval;		/* XXX */
@


1.95
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.93 2009/11/19 22:07:17 otto Exp $	*/
a199 1
extern u_int	ip6_forward_rtableid;
d451 1
a451 1
	    rtableid == ip6_forward_rtableid)
d465 1
a465 1
		ip6_forward_rtableid = rtableid;
d468 1
a468 1
		    &ip6->ip6_src.s6_addr32[0], rtableid);
@


1.94
log
@- instead of rolling a macro that is functional equivalent to nitems(),
just use nitems(). (this leaves NENTS() alone for now)

ok deraadt@@ krw@@
@
text
@d136 1
a136 1
static void ip6_init2(void *);
d139 2
a140 2
static int ip6_hopopts_input(u_int32_t *, u_int32_t *, struct mbuf **, int *);
static struct mbuf *ip6_pullexthdr(struct mbuf *, size_t, int);
d147 1
a147 1
ip6_init()
d170 1
a170 1
static void
d184 1
a184 1
ip6intr()
d809 1
a809 1
static int
d811 1
a811 1
	int *offp)
d855 1
a855 1
	u_int32_t *rtalertp, u_int32_t *plenp)
d1238 1
a1238 1
static struct mbuf *
d1458 1
a1458 1
	void *newp, size_t newlen)
@


1.93
log
@avoid overflow since protos > IPPROTO_MAX exist. From FreeBSD with
a twist; ok millert@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.92 2009/11/03 10:59:04 claudio Exp $	*/
a225 1
#define M2MMAX	(sizeof(ip6stat.ip6s_m2m)/sizeof(ip6stat.ip6s_m2m[0]))
d229 1
a229 1
			} else if (m->m_pkthdr.rcvif->if_index < M2MMAX)
a234 1
#undef M2MMAX
@


1.92
log
@rtables are stacked on rdomains (it is possible to have multiple routing
tables on top of a rdomain) but until now our code was a crazy mix so that
it was impossible to correctly use rtables in that case. Additionally pf(4)
only knows about rtables and not about rdomains. This is especially bad when
tracking (possibly conflicting) states in various domains.
This diff fixes all or most of these issues. It adds a lookup function to
get the rdomain id based on a rtable id. Makes pf understand rdomains and
allows pf to move packets between rdomains (it is similar to NAT).
Because pf states now track the rdomain id as well it is necessary to modify
the pfsync wire format. So old and new systems will not sync up.
A lot of help by dlg@@, tested by sthen@@, jsg@@ and probably more
OK dlg@@, mpf@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.91 2009/05/18 20:37:13 bluhm Exp $	*/
d160 2
a161 1
		    pr->pr_protocol && pr->pr_protocol != IPPROTO_RAW)
@


1.91
log
@The routing table index rtableid has type unsigned int in the routing
code.  In pf rtableid == -1 means don't change the rtableid because
of this rule.  So it has to be signed int there.  Before the value
is passed from pf to route it is always checked to be >= 0.  Change
the type to int in pf and to u_int in netinet and netinet6 to make
the checks work.  Otherwise -1 may be used as an array index and
the kernel crashes.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.90 2008/11/25 12:11:45 markus Exp $	*/
d443 1
a443 1
	rtableid = m->m_pkthdr.pf.rtableid;
@


1.90
log
@delay /etc/netstart until IPv6-DAD (dup-address-detection) is completed.
ok fries, hshoexer, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.89 2008/11/02 10:37:29 claudio Exp $	*/
d199 1
a199 1
extern int	ip6_forward_rtableid;
d213 2
a214 1
	int srcrt = 0, rtableid = 0, isanycast = 0;
@


1.89
log
@Remove the M_ANYCAST6 mbuf flag by doing the detection all in ip6_input().
M_ANYCAST6 was only used to signal tcp6_input() that it should drop the
packet and send back icmp error. This can be done in ip6_input() without
the need for a mbuf flag. Gives us back one slot in m_flags for possible
future need. Looked at and some input by naddy@@ and henning@@. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.88 2008/10/15 19:12:18 blambert Exp $	*/
d1474 2
@


1.88
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.87 2008/09/17 05:43:14 chl Exp $	*/
d213 1
a213 1
	int srcrt = 0, rtableid = 0;
d499 1
a499 1
			m->m_flags |= M_ANYCAST6;
d719 12
a736 1

@


1.87
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.86 2008/06/11 19:00:50 mcbride Exp $	*/
d176 1
a176 1
	timeout_add(&nd6_timer_ch, hz);
@


1.86
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.85 2008/06/09 22:47:42 djm Exp $	*/
a804 1
	u_int8_t *opt;
a821 1
	opt = (u_int8_t *)hbh + sizeof(struct ip6_hbh);
@


1.85
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.84 2008/05/15 19:40:38 markus Exp $	*/
d170 1
a170 2
ip6_init2(dummy)
	void *dummy;
d202 1
a202 2
ip6_input(m)
	struct mbuf *m;
d795 2
d799 2
a800 5
ip6_hopopts_input(plenp, rtalertp, mp, offp)
	u_int32_t *plenp;
	u_int32_t *rtalertp;	/* XXX: should be stored more smart way */
	struct mbuf **mp;
	int *offp;
d845 2
a846 6
ip6_process_hopopts(m, opthead, hbhlen, rtalertp, plenp)
	struct mbuf *m;
	u_int8_t *opthead;
	int hbhlen;
	u_int32_t *rtalertp;
	u_int32_t *plenp;
d978 1
a978 4
ip6_unknown_opt(optp, m, off)
	u_int8_t *optp;
	struct mbuf *m;
	int off;
d1020 1
a1020 4
ip6_savecontrol(in6p, m, mp)
	struct inpcb *in6p;
	struct mbuf *m;
	struct mbuf **mp;
d1230 1
a1230 4
ip6_pullexthdr(m, off, nxt)
	struct mbuf *m;
	size_t off;
	int nxt;
d1289 1
a1289 3
ip6_get_prevhdr(m, off)
	struct mbuf *m;
	int off;
d1328 1
a1328 5
ip6_nexthdr(m, off, proto, nxtp)
	struct mbuf *m;
	int off;
	int proto;
	int *nxtp;
d1406 1
a1406 5
ip6_lasthdr(m, off, proto, nxtp)
	struct mbuf *m;
	int off;
	int proto;
	int *nxtp;
d1448 2
a1449 7
ip6_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
@


1.84
log
@divert for ipv6; ok henning, pyr
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.83 2008/04/24 11:36:39 dlg Exp $	*/
d163 1
@


1.83
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.82 2008/02/24 23:31:30 mcbride Exp $	*/
d401 6
@


1.82
log
@Correctly check that we have a complete rthdr before trying to do m_copydata() on it.

Bug report and fix from Todd Carson.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.81 2008/02/05 22:57:31 mpf Exp $	*/
d188 1
a188 1
	while (ip6intrq.ifq_head) {
d192 1
a192 1
		if (m == 0)
@


1.81
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.80 2007/12/14 18:33:41 deraadt Exp $	*/
d742 1
a742 1
			if (off + sizeof(opt6) > lim) {
@


1.80
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.79 2007/11/27 16:22:13 martynas Exp $	*/
a260 1
	    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
a553 1
	    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
@


1.79
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.78 2007/08/03 06:43:12 itojun Exp $	*/
d109 4
d1477 5
d1491 20
@


1.78
log
@curly brace issues:
- if we have curly braces within #if directive, we will have problem with
  matching using vi "%" command
- without curly braces it becomes ambiguous which statement is within which
  effect of which "if" statement

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.77 2007/05/28 17:16:39 henning Exp $	*/
d330 1
a330 1
		/* m is allready freed */
@


1.78.2.1
log
@MFC (mcbride)
Correctly check that we have a complete rthdr before trying to do m_copydata()
on it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.78 2007/08/03 06:43:12 itojun Exp $	*/
d740 1
a740 1
			if (off + sizeof(rthdr) > lim) {
@


1.77
log
@double pf performance.
boring details:
pf used to use an mbuf tag to keep track of route-to etc, altq, tags,
routing table IDs, packets redirected to localhost etc. so each and every
packet going through pf got an mbuf tag. mbuf tags use malloc'd memory,
and that is knda slow.
instead, stuff the information into the mbuf header directly.
bridging soekris with just "pass" as ruleset went from 29 MBit/s to
58 MBit/s with that (before ryan's randomness fix, now it is even betterer)
thanks to chris for the test setup!
ok ryan ryan ckuethe reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.76 2007/05/08 23:23:16 mcbride Exp $	*/
d418 1
a418 1
		else if (!ip6_mforwarding || !ip6_mrouter) {
d420 1
a420 1
		else {
d422 1
d735 1
a735 1
			if (rh_cnt++)
d738 1
d740 1
a740 1
			if (off + sizeof(opt6) > lim)
d743 1
d757 1
a757 1
			if (off + sizeof(opt6) > lim)
d764 1
@


1.76
log
@KILL all IPv6 packets with the rthdr0 extension header or multiple routing
headers, regardless of forwarding path. It's the sane thing to do.

ip6_check_rthdr0() function from claudio@@

ok deraadt@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.75 2007/03/18 23:23:17 mpf Exp $	*/
a208 1
	struct pf_mtag *pft;
d433 1
a433 2
	if ((pft = pf_find_mtag(m)) != NULL)
		rtableid = pft->rtableid;
@


1.75
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.74 2006/12/28 20:08:15 deraadt Exp $	*/
d133 1
d326 9
d718 63
@


1.74
log
@check if ifqueue has anything queued before doing the dance of
splnet/IF_DEQUEUE/splx; ok various people
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.73 2006/12/19 06:33:49 itojun Exp $	*/
d65 1
d113 5
d255 8
d540 8
@


1.73
log
@reject (potentially malicious) packets from outside,
with interface-local multicast addr in ip6_dst.  by jinmei@@kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.72 2006/12/09 01:12:28 itojun Exp $	*/
d177 1
a177 1
	for (;;) {
@


1.72
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.71 2006/12/08 21:57:54 itojun Exp $	*/
d263 14
@


1.71
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.70 2006/11/27 12:27:45 henning Exp $	*/
d754 1
a754 1
		case IP6OPT_RTALERT:
d910 1
a910 1
ip6_savecontrol(in6p, mp, ip6, m)
d912 1
a913 2
	struct ip6_hdr *ip6;
	struct mbuf *m;
d915 1
d917 1
a929 15
	if (in6p->in6p_flags & IN6P_RECVDSTADDR) {
		*mp = sbcreatecontrol((caddr_t) &ip6->ip6_dst,
		    sizeof(struct in6_addr), IPV6_RECVDSTADDR, IPPROTO_IPV6);
		if (*mp)
			mp = &(*mp)->m_next;
	}

#ifdef noyet
	/* options were tossed above */
	if (in6p->in6p_flags & IN6P_RECVOPTS)
		/* broken */
	/* ip6_srcroute doesn't do what we want here, need to fix */
	if (in6p->in6p_flags & IPV6P_RECVRETOPTS)
		/* broken */
#endif
d937 2
a938 3
		pi6.ipi6_ifindex = (m && m->m_pkthdr.rcvif)
					? m->m_pkthdr.rcvif->if_index
					: 0;
d940 2
a941 1
		    sizeof(struct in6_pktinfo), IPV6_PKTINFO, IPPROTO_IPV6);
d945 2
a946 1
	if (in6p->in6p_flags & IN6P_HOPLIMIT) {
d949 15
a963 1
		    IPV6_HOPLIMIT, IPPROTO_IPV6);
a966 1
	/* IN6P_NEXTHOP - for outgoing packet only */
d973 1
a973 1
	 * See also RFC 2292 section 6.
d980 2
a981 2
		 * just after the IPv6 header, which fact is assured through
		 * the IPv6 input processing.
d986 1
a986 1
			int hbhlen;
d1004 5
a1008 4
			 * XXX: We copy whole the header even if a jumbo
			 * payload option is included, which option is to
			 * be removed before returning in the RFC 2292.
			 * But it's too painful operation...
d1011 2
a1012 1
			    IPV6_HOPOPTS, IPPROTO_IPV6);
d1020 1
a1020 1
	if (in6p->in6p_flags & (IN6P_DSTOPTS | IN6P_RTHDR)) {
d1072 2
a1073 1
				    IPV6_DSTOPTS, IPPROTO_IPV6);
d1083 2
a1084 1
				    IPV6_RTHDR, IPPROTO_IPV6);
@


1.70
log
@make use of multiple routing tables.
hook up looking up routes in alternate tables to the packet forwarding path.
alternate routing tables are mintained with route(8), table selection via pf.
mostly hacked on a train ride with ryan some time ago, ok mcbride claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.69 2006/11/17 01:11:23 itojun Exp $	*/
d1091 1
a1091 1
			 	 * other cases have been filtered in the above.
@


1.69
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.68 2006/06/18 11:47:46 pascoe Exp $	*/
d188 1
d202 1
d204 1
a204 1
	int srcrt = 0;
d395 5
d406 2
a407 1
			       &ip6_forward_rt.ro_dst.sin6_addr))
d421 1
d424 1
a424 1
		    &ip6->ip6_src.s6_addr32[0], 0);
@


1.68
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.67 2006/05/27 23:40:27 claudio Exp $	*/
d324 1
a324 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src) &&
d329 1
a329 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst) &&
d336 4
a339 6
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1]
			= htons(m->m_pkthdr.rcvif->if_index);
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1]
			= htons(m->m_pkthdr.rcvif->if_index);
d940 1
a940 1
		if (IN6_IS_SCOPE_LINKLOCAL(&pi6.ipi6_addr))
@


1.67
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.66 2006/05/27 20:00:37 claudio Exp $	*/
d416 2
a417 1
		rtalloc((struct route *)&ip6_forward_rt);
@


1.66
log
@Fix obvious error in code that is currently not compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.65 2006/05/24 18:43:10 thib Exp $	*/
d380 5
a384 1
		else if (!ip6_mrouter) {
d601 3
a603 1
		if (ip6_mrouter && ip6_mforward(ip6, m->m_pkthdr.rcvif, m)) {
d608 1
@


1.65
log
@fix 2 !foo & bar

"why are you not committing?  into the tree, into the tree!"
and ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.64 2006/03/05 21:48:57 miod Exp $	*/
d904 1
a904 1
	if (in6p->in6p_socket->so_options & SO_TIMESTAMP) {
@


1.64
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.63 2006/03/04 22:40:16 brad Exp $	*/
d1051 1
a1051 1
				if (!in6p->in6p_flags & IN6P_DSTOPTS)
d1061 1
a1061 1
				if (!in6p->in6p_flags & IN6P_RTHDR)
@


1.63
log
@With the exception of two other small uncommited diffs this moves
the remainder of the network stack from splimp to splnet.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.62 2005/08/11 12:55:31 mpf Exp $	*/
d486 1
a486 3
	for (ifa = m->m_pkthdr.rcvif->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next) {
@


1.62
log
@New counter for not joined IPv4 multicast groups.
Don't count link local scope multicast as not forwardable.
This stops ips_cantforward growing on carp(4) networks.
tested and ok mcbride@@, ok markus@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.61 2005/03/06 16:27:01 dhartmei Exp $	*/
d178 1
a178 1
		s = splimp();
@


1.61
log
@move pf_test6() call slightly up, so pf gets called for incoming packets
on loopback interfaces, and IPv6 behaves like IPv4 in this regard. only
affects packets on loopback. ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.60 2004/10/18 03:59:34 itojun Exp $	*/
d382 2
a383 1
			ip6stat.ip6s_cantforward++;
@


1.60
log
@g/c ip6_flow_seq.  found by mcbride.  mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.59 2004/06/21 19:26:02 mcbride Exp $	*/
d295 14
a334 14

#if NPF > 0 
        /*
         * Packet filter
         */
	odst = ip6->ip6_dst;
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif
@


1.59
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.58 2004/06/01 03:19:27 itojun Exp $	*/
a153 1
	ip6_flow_seq = arc4random();
@


1.59.2.1
log
@MFC:
Fix by dhartmei@@

move pf_test6() call slightly up, so pf gets called for incoming packets
on loopback interfaces, and IPv6 behaves like IPv4 in this regard. only
affects packets on loopback.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.59 2004/06/21 19:26:02 mcbride Exp $	*/
a295 14
#if NPF > 0 
	/*
	 * Packet filter
	 */
	odst = ip6->ip6_dst;
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m, NULL) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif

d322 14
@


1.58
log
@there's no use in checking curproc privilege in input path.
equivalent to http://orange.kame.net/dev/cvsweb2.cgi/kame/kame/sys/netinet6/ip6_input.c.diff?r1=1.344&r2=1.345.  jinmei@@kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.57 2004/02/15 11:16:08 markus Exp $	*/
d328 1
a328 1
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
@


1.57
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.56 2003/12/08 10:05:31 dhartmei Exp $	*/
a903 4
	int privileged = 0;

	if ((in6p->inp_socket->so_state & SS_PRIV) != 0)
		privileged++;
d956 5
a960 4
	 * IPV6_HOPOPTS socket option. We require super-user privilege
	 * for the option, but it might be too strict, since there might
	 * be some hop-by-hop options which can be returned to normal user.
	 * See RFC 2292 section 6.
d962 1
a962 1
	if ((in6p->in6p_flags & IN6P_HOPOPTS) != 0 && privileged) {
a1053 8
					break;

				/*
				 * We also require super-user privilege for
				 * the option.
				 * See the comments on IN6_HOPOPTS.
				 */
				if (!privileged)
@


1.57.2.1
log
@MFC:
Fix by dhartmei@@

move pf_test6() call slightly up, so pf gets called for incoming packets
on loopback interfaces, and IPv6 behaves like IPv4 in this regard. only
affects packets on loopback.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.57 2004/02/15 11:16:08 markus Exp $	*/
a295 14
#if NPF > 0 
	/*
	 * Packet filter
	 */
	odst = ip6->ip6_dst;
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif

d322 14
@


1.56
log
@move pf_test6() call below loopback (and mapped-ipv4) tests, so rdr -> ::1
works without additional route-to lo0, just like for ipv4.
ok itojun@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.55 2003/10/14 08:22:31 itojun Exp $	*/
d1345 2
a1360 31

	case IPV6CTL_FORWARDING:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				  &ip6_forwarding);
	case IPV6CTL_SENDREDIRECTS:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_sendredirects);
	case IPV6CTL_DEFHLIM:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_defhlim);
	case IPV6CTL_MAXFRAGPACKETS:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_maxfragpackets);
	case IPV6CTL_ACCEPT_RTADV:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_accept_rtadv);
	case IPV6CTL_KEEPFAITH:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_keepfaith);
	case IPV6CTL_LOG_INTERVAL:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_log_interval);
	case IPV6CTL_HDRNESTLIMIT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_hdrnestlimit);
	case IPV6CTL_DAD_COUNT:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_dad_count);
	case IPV6CTL_AUTO_FLOWLABEL:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_auto_flowlabel);
	case IPV6CTL_DEFMCASTHLIM:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_defmcasthlim);
a1362 5
	case IPV6CTL_USE_DEPRECATED:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_use_deprecated);
	case IPV6CTL_RR_PRUNE:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_rr_prune);
a1364 2
	case IPV6CTL_MAXFRAGS:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_maxfrags);
d1366 4
a1369 1
		return EOPNOTSUPP;
@


1.55
log
@oops, i did not mean to commit this portion (IPSEC mod), sorry
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.53 2003/06/30 10:30:23 itojun Exp $	*/
a247 14
#if NPF > 0 
        /*
         * Packet filter
         */
	odst = ip6->ip6_dst;
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif

d322 14
@


1.54
log
@IP6F_OFF_MASK is already endian-flipped; sync w/ kame
@
text
@a653 41
#ifdef IPSEC
		/*
		 * IPsec policy check for local-delivery packets. Look at the
		 * inner-most SA that protected the packet. This is in fact
		 * a bit too restrictive (it could end up causing packets to
		 * be dropped that semantically follow the policy, e.g., in
		 * certain SA-bundle configurations); but the alternative is
		 * very complicated (and requires keeping track of what
		 * kinds of tunneling headers have been seen in-between the
		 * IPsec headers), and I don't think we lose much functionality
		 * that's needed in the real world (who uses bundles anyway ?).
		 */
		if ((inet6sw[ip6_protox[nxt]].pr_flags & PR_LASTHDR) != 0) {
			struct m_tag *mtag;
			struct tdb *tdb;
			struct tdb_ident *tdbi;
			int error;
			int s;

			mtag = m_tag_find(m, PACKET_TAG_IPSEC_IN_DONE, NULL);
			s = splnet();
			if (mtag) {
				tdbi = (struct tdb_ident *)(mtag + 1);
				tdb = gettdb(tdbi->spi, &tdbi->dst,
				    tdbi->proto);
			} else
				tdb = NULL;
			ipsp_spd_lookup(m, AF_INET6, off, &error,
			    IPSP_DIRECTION_IN, tdb, NULL);
			splx(s);

			/* Error or otherwise drop-packet indication. */
			if (error) {
				ip6stat.ip6s_cantforward++;
				in6_ifstat_inc(m->m_pkthdr.rcvif,
				    ifs6_in_discard);
				goto bad;
			}
		}
#endif

@


1.53
log
@initialize srcrt properly (so that it won't go mad when NPF==0).  cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.52 2003/06/30 08:04:22 itojun Exp $	*/
d654 41
d1295 1
a1295 1
		if ((ntohs(fh.ip6f_offlg) & IP6F_OFF_MASK) != 0)
@


1.52
log
@do not generate icmp6 redirect if PF rewrote the destination address.
requeested by cedric
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.51 2003/06/02 23:28:15 millert Exp $	*/
d200 1
d202 2
a203 1
	int srcrt;
@


1.51
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.50 2003/05/14 14:44:44 itojun Exp $	*/
d200 2
d250 1
d257 1
d607 1
a607 1
		ip6_forward(m, 0);
@


1.50
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.49 2003/05/14 14:24:44 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.49
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.48 2003/05/14 14:18:23 itojun Exp $	*/
d913 1
a913 1
			SCM_TIMESTAMP, SOL_SOCKET);
d920 1
a920 2
			sizeof(struct in6_addr), IPV6_RECVDSTADDR,
			IPPROTO_IPV6);
d944 1
a944 2
			sizeof(struct in6_pktinfo), IPV6_PKTINFO,
			IPPROTO_IPV6);
d950 2
a951 2
		*mp = sbcreatecontrol((caddr_t) &hlim,
			sizeof(int), IPV6_HOPLIMIT, IPPROTO_IPV6);
d998 1
a998 1
					      IPV6_HOPOPTS, IPPROTO_IPV6);
d1066 1
a1066 2
						      IPV6_DSTOPTS,
						      IPPROTO_IPV6);
d1076 1
a1076 2
						      IPV6_RTHDR,
						      IPPROTO_IPV6);
@


1.48
log
@remove obsolete comments
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.47 2003/01/07 09:00:34 kjc Exp $	*/
a132 1
#ifdef PULLDOWN_TEST
a133 1
#endif
a229 5
#ifndef PULLDOWN_TEST
	/* XXX is the line really necessary? */
	IP6_EXTHDR_CHECK(m, 0, sizeof(struct ip6_hdr), /*nothing*/);
#endif

a548 4
#ifndef PULLDOWN_TEST
		/* ip6_hopopts_input() ensures that mbuf is contiguous */
		hbh = (struct ip6_hbh *)(ip6 + 1);
#else
a554 1
#endif
a675 8
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*hbh), -1);
	hbh = (struct ip6_hbh *)(mtod(m, caddr_t) + off);
	hbhlen = (hbh->ip6h_len + 1) << 3;

	IP6_EXTHDR_CHECK(m, off, hbhlen, -1);
	hbh = (struct ip6_hbh *)(mtod(m, caddr_t) + off);
#else
a688 1
#endif
a976 1
#ifdef PULLDOWN_TEST
a977 1
#endif
a978 4
#ifndef PULLDOWN_TEST
			hbh = (struct ip6_hbh *)(ip6 + 1);
			hbhlen = (hbh->ip6h_len + 1) << 3;
#else
a991 1
#endif
a1002 1
#ifdef PULLDOWN_TEST
a1003 1
#endif
a1021 1
#ifdef PULLDOWN_TEST
a1022 1
#endif
a1037 11
#ifndef PULLDOWN_TEST
			if (off + sizeof(*ip6e) > m->m_len)
				goto loopend;
			ip6e = (struct ip6_ext *)(mtod(m, caddr_t) + off);
			if (nxt == IPPROTO_AH)
				elen = (ip6e->ip6e_len + 2) << 2;
			else
				elen = (ip6e->ip6e_len + 1) << 3;
			if (off + elen > m->m_len)
				goto loopend;
#else
a1052 1
#endif
a1095 1
#ifdef PULLDOWN_TEST
a1096 1
#endif
a1104 1
#ifdef PULLDOWN_TEST
a1106 1
#endif
a1113 1
#ifdef PULLDOWN_TEST
a1166 1
#endif
@


1.47
log
@remove the altq classifier code which is replaced by pf and no longer used.

ok henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.46 2002/09/11 03:27:30 itojun Exp $	*/
a1158 7
	if ((in6p->in6p_flags & IN6P_HOPOPTS) && privileged) {
		/* to be done */
	}
	if ((in6p->in6p_flags & IN6P_DSTOPTS) && privileged) {
		/* to be done */
	}
	/* IN6P_RTHDR - to be done */
@


1.46
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.45 2002/09/11 03:15:36 itojun Exp $	*/
a267 7

#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET6) == 0) {
		/* packet is dropped by traffic conditioner */
		return;
	}
#endif
@


1.45
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.44 2002/06/08 21:22:03 itojun Exp $	*/
d1244 1
a1244 1
char *
@


1.44
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.43 2002/06/07 15:27:58 itojun Exp $	*/
d723 1
a723 1
		return(-1);
d727 1
a727 1
	return(0);
d887 1
a887 1
		return((int)*(optp + 1));
d890 1
a890 1
		return(-1);
d894 1
a894 1
		return(-1);
d904 1
a904 1
		return(-1);
d908 1
a908 1
	return(-1);
d1252 1
a1252 1
		return(&ip6->ip6_nxt);
d1276 1
a1276 1
			return(&ip6e->ip6e_nxt);
@


1.43
log
@just for consistency/compatibility, have net.inet6.ip6.v6only sysctl MIB,
as well as set/getsockopt(IPV6_V6ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.42 2002/05/28 03:04:38 itojun Exp $	*/
a104 1
#include <netinet6/in6_prefix.h>
a168 10
#if 1
	/*
	 * to route local address of p2p link to loopback,
	 * assign loopback address first.
	 */
	in6_ifattach(lo0ifp, NULL);
#else
	/* you MUST bring lo0 up manually, in rc script. */
#endif

a172 5

	/* router renumbering prefix list maintenance */
	bzero(&in6_rr_timer_ch, sizeof(in6_rr_timer_ch));
	timeout_set(&in6_rr_timer_ch, in6_rr_timer, (caddr_t)0);
	timeout_add(&in6_rr_timer_ch, hz);
d298 1
a298 1
	 * partical support for SIIT environment.
d448 1
a448 1
			       &rt6_key(ip6_forward_rt.ro_rt)->sin6_addr) &&
d476 1
a476 1
	 * FAITH(Firewall Aided Internet Translator)
d735 4
d753 1
d773 7
a779 4
			if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2)
				/* XXX: should we discard the packet? */
				log(LOG_ERR, "length of router alert opt is inconsitent(%d)",
				    *(opt + 1));
d790 7
a796 5
			if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2)
				/* XXX: should we discard the packet? */
				log(LOG_ERR, "length of jumbopayload opt "
				    "is inconsistent(%d)\n",
				    *(opt + 1));
d807 3
a809 5
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt - opthead);
				return(-1);
d831 3
a833 5
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt + 2 - opthead);
				return(-1);
d843 3
a845 5
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt + 2 - opthead);
				return(-1);
d855 4
a858 5
			if ((optlen = ip6_unknown_opt(opt, m,
						      sizeof(struct ip6_hdr) +
						      sizeof(struct ip6_hbh) +
						      opt - opthead)) == -1)
				return(-1);
d864 1
a864 1
	return(0);
d868 1
a868 1
	return(-1);
@


1.42
log
@limit number of IPv6 fragments (not the fragment queue size) to
fight against lots-of-frags DoS attacks.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.41 2002/03/14 01:27:12 millert Exp $	*/
d1476 2
@


1.41
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.40 2002/01/21 05:33:14 itojun Exp $	*/
d1476 2
@


1.40
log
@remove couple of #if 0'ed portion we will never use
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.39 2002/01/02 22:47:47 deraadt Exp $	*/
d131 1
a131 1
static void ip6_init2 __P((void *));
d133 1
a133 1
static int ip6_hopopts_input __P((u_int32_t *, u_int32_t *, struct mbuf **, int *));
d135 1
a135 1
static struct mbuf *ip6_pullexthdr __P((struct mbuf *, size_t, int));
@


1.39
log
@at least ; required after label or case; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.38 2001/12/16 01:28:59 jasoni Exp $	*/
a221 11

#if 0 /* IPSEC */
	/*
	 * should the inner packet be considered authentic?
	 * see comment in ah4_input().
	 */
	if (m) {
		m->m_flags &= ~M_AUTHIPHDR;
		m->m_flags &= ~M_AUTHIPDGM;
	}
#endif
@


1.38
log
@- Call pf_test6() after we have checked header length and protocol version.
- If pf_test6 returns a NULL mbuf, just return.
- Reinitialize pointer to header after pf_test6().
ok frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.37 2001/12/07 09:16:07 itojun Exp $	*/
d1188 1
@


1.38.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.40 2002/01/21 05:33:14 itojun Exp $	*/
d223 11
a1187 1
	  	;
@


1.38.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.38.2.1 2002/01/31 22:55:46 niklas Exp $	*/
d105 1
d131 1
a131 1
static void ip6_init2(void *);
d133 1
a133 1
static int ip6_hopopts_input(u_int32_t *, u_int32_t *, struct mbuf **, int *);
d135 1
a135 1
static struct mbuf *ip6_pullexthdr(struct mbuf *, size_t, int);
d170 10
d184 5
d314 1
a314 1
	 * partial support for SIIT environment.
d464 1
a464 1
	    &rt6_key(ip6_forward_rt.ro_rt)->sin6_addr) &&
d492 1
a492 1
	 * FAITH (Firewall Aided Internet Translator)
a750 4
 *
 * The function assumes that hbh header is located right after the IPv6 header
 * (RFC2460 p7), opthead is pointer into data content in m, and opthead to
 * opthead + hbhlen is located in continuous memory region.
a764 1
	const int erroff = sizeof(struct ip6_hdr) + sizeof(struct ip6_hbh);
d784 4
a787 7
			if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
d798 5
a802 7
			if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
d813 5
a817 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt - opthead);
				return (-1);
d839 5
a843 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
d853 5
a857 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
d867 5
a871 4
			optlen = ip6_unknown_opt(opt, m,
			    erroff + opt - opthead);
			if (optlen == -1)
				return (-1);
d877 1
a877 1
	return (0);
d881 1
a881 1
	return (-1);
a1475 4
	case IPV6CTL_V6ONLY:
		return sysctl_rdint(oldp, oldlenp, newp, ip6_v6only);
	case IPV6CTL_MAXFRAGS:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_maxfrags);
@


1.38.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.38.2.2 2002/06/11 03:31:37 art Exp $	*/
d723 1
a723 1
		return (-1);
d727 1
a727 1
	return (0);
d887 1
a887 1
		return ((int)*(optp + 1));
d890 1
a890 1
		return (-1);
d894 1
a894 1
		return (-1);
d904 1
a904 1
		return (-1);
d908 1
a908 1
	return (-1);
d1244 1
a1244 1
u_int8_t *
d1252 1
a1252 1
		return (&ip6->ip6_nxt);
d1276 1
a1276 1
			return (&ip6e->ip6e_nxt);
@


1.38.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
d135 1
d232 5
d269 7
d563 4
d573 1
d695 8
d716 1
d941 1
a941 1
		    SCM_TIMESTAMP, SOL_SOCKET);
d948 2
a949 1
		    sizeof(struct in6_addr), IPV6_RECVDSTADDR, IPPROTO_IPV6);
d973 2
a974 1
		    sizeof(struct in6_pktinfo), IPV6_PKTINFO, IPPROTO_IPV6);
d980 2
a981 2
		*mp = sbcreatecontrol((caddr_t) &hlim, sizeof(int),
		    IPV6_HOPLIMIT, IPPROTO_IPV6);
d1005 1
d1007 1
d1009 4
d1026 1
d1035 1
a1035 1
			    IPV6_HOPOPTS, IPPROTO_IPV6);
d1038 1
d1040 1
d1059 1
d1061 1
d1077 11
d1103 1
d1119 2
a1120 1
				    IPV6_DSTOPTS, IPPROTO_IPV6);
d1130 2
a1131 1
				    IPV6_RTHDR, IPPROTO_IPV6);
d1147 1
d1149 1
d1158 1
d1161 1
d1166 7
d1176 1
d1230 1
@


1.37
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.36 2001/11/26 16:50:26 jasoni Exp $	*/
a263 10
#if NPF > 0 
        /*
         * Packet filter
         */
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		goto bad;
#endif

d281 12
@


1.36
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.35 2001/11/06 19:53:21 miod Exp $	*/
d302 1
a302 1
	 * Scope check
d306 3
d314 4
a317 4
	 * The following check is not documented in the spec.  Malicious party
	 * may be able to use IPv4 mapped addr to confuse tcp/udp stack and
	 * bypass security checks (act as if it was from 127.0.0.1 by using
	 * IPv6 src ::ffff:127.0.0.1).	Be cautious.
d319 5
a323 5
	 * This check chokes if we are in SIIT cloud.  As none of BSDs support
	 * IPv4-less kernel compilation, we cannot support SIIT environment
	 * at all.  So, it makes more sense for us to reject any malicious
	 * packets for non-SIIT environment, than try to do a partical support
	 * for SIIT environment.
d570 1
a570 1
		 * if the payload length field is 0 and the next header field  
@


1.35
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.34 2001/11/02 09:01:29 itojun Exp $	*/
d268 4
a271 2
        if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
                goto bad;
@


1.34
log
@do not return value that overruns mbuf length from ip6_nexthdr.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.33 2001/09/15 03:54:40 frantzen Exp $	*/
d1424 1
a1424 1
#include <vm/vm.h>
@


1.33
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.32 2001/06/27 05:50:07 kjc Exp $	*/
d1350 2
d1363 2
@


1.32
log
@ALTQ base modifications to the kernel.
 - ALTQ introduces a set of new queue macros that coexist with the
   traditional IF_XXX macros.
 - "struct ifaltq" replaces "struct ifqueue" in "struct ifnet".
 - assign cdev major 74 for i386 and 54 for alpha as ALTQ control interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.31 2001/06/09 06:43:38 angelos Exp $	*/
d68 2
d113 4
d262 8
@


1.31
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.30 2001/05/11 17:20:12 aaron Exp $	*/
d277 7
@


1.30
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.29 2001/03/30 11:09:01 itojun Exp $	*/
a109 2

#include <net/net_osdep.h>
@


1.29
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.28 2001/03/16 12:20:52 itojun Exp $	*/
d263 1
a263 1
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == 0) {
@


1.28
log
@drop packets with link-local addresses,
if (internally-used) interface ID portion is already filled.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.27 2001/02/16 16:38:15 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.176 2001/02/14 07:13:39 itojun Exp $	*/
d239 1
d243 1
a243 1
			} else if (m->m_pkthdr.rcvif->if_index <= 31)
d249 1
d322 1
d350 24
a373 13
#ifndef FAKE_LOOPBACK_IF
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0)
#else
	if (1)
#endif
	{
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1]
				= htons(m->m_pkthdr.rcvif->if_index);
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1]
				= htons(m->m_pkthdr.rcvif->if_index);
	}
d375 3
a377 12
	/*
	 * XXX we need this since we do not have "goto ours" hack route
	 * for some of our ifaddrs on loopback interface.
	 * we should correct it by changing in6_ifattach to install
	 * "goto ours" hack route.
	 */
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) != 0) {
		if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst)) {
			ours = 1;
			deliverifp = m->m_pkthdr.rcvif;
			goto hbhcheck;
		}
d655 1
@


1.27
log
@get rid of #ifdef IPV6FIREWALL (never used, will never be used)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.26 2001/02/16 16:00:57 itojun Exp $	*/
d329 14
@


1.26
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.25 2001/02/16 14:58:12 itojun Exp $	*/
a104 4
#ifdef IPV6FIREWALL
#include <netinet6/ip6_fw.h>
#endif

a124 6
#ifdef IPV6FIREWALL
/* firewall hooks */
ip6_fw_chk_t *ip6_fw_chk_ptr;
ip6_fw_ctl_t *ip6_fw_ctl_ptr;
#endif

a156 3
#ifdef IPV6FIREWALL
	ip6_fw_init();
#endif
a276 17

#ifdef IPV6FIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip6_fw_chk_ptr) {
		u_short port = 0;
		/* If ipfw says divert, we have to just drop packet */
		/* use port as a dummy argument */
		if ((*ip6_fw_chk_ptr)(&ip6, NULL, &port, &m)) {
			m_freem(m);
			m = NULL;
		}
		if (!m)
			return;
	}
#endif
@


1.25
log
@cosmetic/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.24 2001/02/16 08:48:05 itojun Exp $	*/
d973 1
a973 1
		struct in6_pktinfo pi6, *prevpi = NULL;
@


1.24
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.23 2001/02/16 08:22:06 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.172 2001/02/08 11:18:05 itojun Exp $	*/
a316 1
#if 1
d322 6
a334 1
#endif
d802 1
a802 1
			 * must not contain a jumbo paylod option.
d972 2
a973 2
	if (in6p->in6p_flags & IN6P_PKTINFO) {
		struct in6_pktinfo pi6;
d1001 1
a1001 1
	if ((in6p->in6p_flags & IN6P_HOPOPTS) && privileged) {
d1150 1
a1150 1
				 * other cases have been filtered in the above.
@


1.23
log
@kill register declarations.  to sync with kame better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.22 2001/02/08 14:51:22 itojun Exp $	*/
d758 26
a783 26
		switch(*opt) {
		 case IP6OPT_PAD1:
			 optlen = 1;
			 break;
		 case IP6OPT_PADN:
			 if (hbhlen < IP6OPT_MINLEN) {
				 ip6stat.ip6s_toosmall++;
				 goto bad;
			 }
			 optlen = *(opt + 1) + 2;
			 break;
		 case IP6OPT_RTALERT:
			 /* XXX may need check for alignment */
			 if (hbhlen < IP6OPT_RTALERT_LEN) {
				 ip6stat.ip6s_toosmall++;
				 goto bad;
			 }
			 if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2)
				  /* XXX: should we discard the packet? */
				 log(LOG_ERR, "length of router alert opt is inconsitent(%d)",
				     *(opt + 1));
			 optlen = IP6OPT_RTALERT_LEN;
			 bcopy((caddr_t)(opt + 2), (caddr_t)&rtalert_val, 2);
			 *rtalertp = ntohs(rtalert_val);
			 break;
		 case IP6OPT_JUMBO:
d790 1
a790 1
				 /* XXX: should we discard the packet? */
d853 12
a864 12
		 default:		/* unknown option */
			 if (hbhlen < IP6OPT_MINLEN) {
				 ip6stat.ip6s_toosmall++;
				 goto bad;
			 }
			 if ((optlen = ip6_unknown_opt(opt, m,
						       sizeof(struct ip6_hdr) +
						       sizeof(struct ip6_hbh) +
						       opt - opthead)) == -1)
				 return(-1);
			 optlen += 2;
			 break;
d889 20
a908 20
	switch(IP6OPT_TYPE(*optp)) {
	 case IP6OPT_TYPE_SKIP: /* ignore the option */
		 return((int)*(optp + 1));
	 case IP6OPT_TYPE_DISCARD:	/* silently discard */
		 m_freem(m);
		 return(-1);
	 case IP6OPT_TYPE_FORCEICMP: /* send ICMP even if multicasted */
		 ip6stat.ip6s_badoptions++;
		 icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, off);
		 return(-1);
	 case IP6OPT_TYPE_ICMP: /* send ICMP if not multicasted */
		 ip6stat.ip6s_badoptions++;
		 ip6 = mtod(m, struct ip6_hdr *);
		 if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
		     (m->m_flags & (M_BCAST|M_MCAST)))
			 m_freem(m);
		 else
			 icmp6_error(m, ICMP6_PARAM_PROB,
				     ICMP6_PARAMPROB_OPTION, off);
		 return(-1);
d1110 1
a1110 1
		        case IPPROTO_DSTOPTS:
d1146 1
a1146 1
			 	 * other cases have been filtered in the above.
@


1.22
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.21 2001/02/07 11:43:53 itojun Exp $	*/
d151 2
a152 2
	register struct ip6protosw *pr;
	register int i;
d696 1
a696 1
	register struct mbuf *m = *mp;
d928 4
a931 4
	register struct inpcb *in6p;
	register struct mbuf **mp;
	register struct ip6_hdr *ip6;
	register struct mbuf *m;
@


1.21
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.20 2001/02/06 00:22:23 mickey Exp $	*/
/*	$KAME: ip6_input.c,v 1.170 2001/02/07 07:50:02 itojun Exp $	*/
d190 4
a193 1
	timeout(nd6_timer, (caddr_t)0, hz);
d195 3
a197 1
	timeout(in6_rr_timer, (caddr_t)0, hz);
a214 18
#ifndef PULLDOWN_TEST
		/*
		 * KAME requirement: make sure mbuf is packed well
		 */

		if (m->m_next) {
			int l;
			if (m->m_pkthdr.len > MCLBYTES)
				l = MCLBYTES;
			else
				l = m->m_pkthdr.len;
			if (l > m->m_len) {
				m = m_pullup2(m, l);
				if (!m)
					continue;
			}
		}
#endif
d1265 1
a1265 1
			switch(nxt) {
@


1.20
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.19 2000/08/31 08:39:56 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.121 2000/08/31 06:07:29 itojun Exp $	*/
d487 1
a487 1
			log(LOG_INFO,
d490 1
a490 1
			    ip6_sprintf(&ip6->ip6_dst));
@


1.19
log
@add missing \n to log().  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.18 2000/07/06 10:11:25 itojun Exp $	*/
a110 2
/* we need it for NLOOP. */
#include "loop.h"
a124 1
extern struct ifnet loif[NLOOP];
d184 1
a184 1
	in6_ifattach(&loif[0], NULL);
d267 1
a267 1
				ip6stat.ip6s_m2m[loif[0].if_index]++;	/*XXX*/
@


1.18
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.17 2000/07/02 10:10:55 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.95 2000/07/02 07:49:37 jinmei Exp $	*/
d491 1
a491 1
			    "ip6_input: packet to an unready address %s->%s",
d808 1
a808 1
				    "is inconsistent(%d)",
@


1.17
log
@drop packet to tentative/duplicated interface address earlier.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.16 2000/06/18 06:27:15 itojun Exp $	*/
d431 1
a431 1
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) != 0 &&
d434 1
a434 1
		; /* cache hit */
d438 1
d569 1
a569 1
		 * if the payload length field is 0 and the next header field
d577 1
a577 1
			 * (non-zero) payload length to the variable plen.
d653 18
@


1.16
log
@try to avoid useless m_pullup2
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.15 2000/06/18 06:24:45 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.94 2000/06/13 10:06:19 jinmei Exp $	*/
a475 1
		/* packet to tentative address must not be received */
d478 4
d483 1
a483 1
			/* this interface is ready */
d488 7
a494 1
			/* this interface is not ready, fall through */
@


1.15
log
@move m_pullup2() equivalent for KAME requirement into ip6_input().
it was in looutput() to make KAME ipsec4 happy.
however, since we don't have KAME ipsec4 in openbsd, we don't need it
in looutput().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.14 2000/06/18 04:33:03 itojun Exp $	*/
d224 5
a228 3
			m = m_pullup2(m, l);
			if (!m)
				continue;
@


1.14
log
@less mbuf alignment change in extension header processing.
(so that we can be more PULLDONW_TEST friendly)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.13 2000/06/13 14:50:33 itojun Exp $	*/
d213 16
@


1.13
log
@do not use cached route if it goes !RTF_UP.
make validation of jumbo payload more strict.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.12 2000/05/25 01:22:00 itojun Exp $	*/
d143 3
d413 1
a413 1
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) != 0 && 
d541 1
a541 1
		 * if the payload length field is 0 and the next header field  
d549 1
a549 1
			 * (non-zero) payload length to the variable plen. 
d979 3
d987 3
a989 3
			IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m,
				sizeof(struct ip6_hdr), sizeof(struct ip6_hbh));
			if (hbh == NULL) {
d993 1
d995 2
a996 3
			IP6_EXTHDR_GET(hbh, struct ip6_hbh *, m,
				sizeof(struct ip6_hdr), hbhlen);
			if (hbh == NULL) {
d1012 3
d1021 1
a1021 1
		int nxt = ip6->ip6_nxt, off = sizeof(struct ip6_hdr);;
d1030 2
a1031 2
		while(1) {	/* is explicit loop prevention necessary? */
			struct ip6_ext *ip6e;
d1033 17
d1052 2
d1059 2
d1062 2
a1063 3
			IP6_EXTHDR_GET(ip6e, struct ip6_ext *, m, off,
				sizeof(struct ip6_ext));
			if (ip6e == NULL) {
d1067 1
d1072 2
a1073 2
			IP6_EXTHDR_GET(ip6e, struct ip6_ext *, m, off, elen);
			if (ip6e == NULL) {
d1079 47
a1125 44
			switch(nxt) {
		         case IPPROTO_DSTOPTS:
				 if (!in6p->in6p_flags & IN6P_DSTOPTS)
					 break;

				 /*
				  * We also require super-user privilege for
				  * the option.
				  * See the comments on IN6_HOPOPTS.
				  */
				 if (!privileged)
					 break;

				 *mp = sbcreatecontrol((caddr_t)ip6e, elen,
						       IPV6_DSTOPTS,
						       IPPROTO_IPV6);
				 if (*mp)
					 mp = &(*mp)->m_next;
				 break;

			 case IPPROTO_ROUTING:
				 if (!in6p->in6p_flags & IN6P_RTHDR)
					 break;

				 *mp = sbcreatecontrol((caddr_t)ip6e, elen,
						       IPV6_RTHDR,
						       IPPROTO_IPV6);
				 if (*mp)
					 mp = &(*mp)->m_next;
				 break;

			 case IPPROTO_UDP:
			 case IPPROTO_TCP:
			 case IPPROTO_ICMPV6:
			 default:
				 /*
				  * stop search if we encounter an upper
				  * layer protocol headers.
				  */
				 goto loopend;

			 case IPPROTO_HOPOPTS:
			 case IPPROTO_AH: /* is it possible? */
				 break;
d1131 5
d1148 56
@


1.12
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.11 2000/05/19 20:12:10 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.89 2000/05/19 19:59:05 itojun Exp $	*/
d250 1
a250 2
			}
			else if (m->m_pkthdr.rcvif->if_index <= 31)
d409 6
a414 3
	if (ip6_forward_rt.ro_rt == 0 ||
	    !IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
				&ip6_forward_rt.ro_dst.sin6_addr)) {
d416 1
d420 1
d533 1
d536 20
d618 1
a618 2
	}
	else if (!ours) {
d722 1
d751 33
a783 11
			 /* XXX may need check for alignment */
			 if (hbhlen < IP6OPT_JUMBO_LEN) {
				 ip6stat.ip6s_toosmall++;
				 goto bad;
			 }
			 if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2)
				  /* XXX: should we discard the packet? */
				 log(LOG_ERR, "length of jumbopayload opt "
				     "is inconsistent(%d)",
				     *(opt + 1));
			 optlen = IP6OPT_JUMBO_LEN;
d785 18
a802 9
			 /*
			  * We can simply cast because of the alignment
			  * requirement of the jumbo payload option.
			  */
#if 0
			 *plenp = ntohl(*(u_int32_t *)(opt + 2));
#else
			 bcopy(opt + 2, plenp, sizeof(*plenp));
			 *plenp = htonl(*plenp);
a803 13
			 if (*plenp <= IPV6_MAXPACKET) {
				 /*
				  * jumbo payload length must be larger
				  * than 65535
				  */
				 ip6stat.ip6s_badoptions++;
				 icmp6_error(m, ICMP6_PARAM_PROB,
					     ICMP6_PARAMPROB_HEADER,
					     sizeof(struct ip6_hdr) +
					     sizeof(struct ip6_hbh) +
					     opt + 2 - opthead);
				 return(-1);
			 }
d805 15
a819 15
			 ip6 = mtod(m, struct ip6_hdr *);
			 if (ip6->ip6_plen) {
				 /*
				  * IPv6 packets that have non 0 payload length
				  * must not contain a jumbo paylod option.
				  */
				 ip6stat.ip6s_badoptions++;
				 icmp6_error(m, ICMP6_PARAM_PROB,
					     ICMP6_PARAMPROB_HEADER,
					     sizeof(struct ip6_hdr) +
					     sizeof(struct ip6_hbh) +
					     opt - opthead);
				 return(-1);
			 }
			 break;
@


1.11
log
@correct "telnet fe80::1%lo0".
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.10 2000/04/17 04:44:50 itojun Exp $	*/
a1287 3
	case IPV6CTL_GIF_HLIM:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&ip6_gif_hlim);
@


1.10
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.9 2000/03/22 03:50:35 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.72 2000/03/21 09:23:19 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
a143 7
#if defined(PTR)
extern	int		ip6_protocol_tr;

int	ptr_in6		__P((struct mbuf *, struct mbuf **));
extern void ip_forward __P((struct mbuf *, int));
#endif

d182 1
a182 1
	 * assign loopback address first. 
d355 6
a360 7
	if (m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) {
		if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst)) {
			ours = 1;
			deliverifp = m->m_pkthdr.rcvif;
			goto hbhcheck;
		}
	} else {
a368 1
#if defined(PTR)
d370 4
a373 1
	 *
d375 6
a380 17
	if (ip6_protocol_tr)
	{
	    struct mbuf *m1 = NULL;

	    switch (ptr_in6(m, &m1))
	    {
	      case IPPROTO_IP:					goto mcastcheck;
	      case IPPROTO_IPV4:	ip_forward(m1, 0);	break;
	      case IPPROTO_IPV6:	ip6_forward(m1, 0);	break;
	      case IPPROTO_MAX:			/* discard this packet	*/
	      default:
	    }

	    if (m != m1)
		m_freem(m);

	    return;
a381 3

  mcastcheck:
#endif
@


1.9
log
@aintroduce ip6_{next,last}hdr which lets us parse IPv6 header chain correctly.
use it from icmp6 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.8 2000/02/07 06:09:10 itojun Exp $	*/
a184 4
	int ret;

	/* get EUI64 from somewhere */
	ret = in6_ifattach_getifid(NULL);
d191 1
a191 1
	in6_ifattach(&loif[0], IN6_IFT_LOOP, NULL, 0);
@


1.8
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_input.c,v 1.7 2000/01/08 04:49:22 deraadt Exp $	*/
d324 29
d1139 109
@


1.8.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: ip6_input.c,v 1.72 2000/03/21 09:23:19 itojun Exp $	*/
a322 29
#if 1
	/*
	 * The following check is not documented in the spec.  Malicious party
	 * may be able to use IPv4 mapped addr to confuse tcp/udp stack and
	 * bypass security checks (act as if it was from 127.0.0.1 by using
	 * IPv6 src ::ffff:127.0.0.1).	Be cautious.
	 */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
		goto bad;
	}
#endif
#if 0
	/*
	 * Reject packets with IPv4 compatible addresses (auto tunnel).
	 *
	 * The code forbids auto tunnel relay case in RFC1933 (the check is
	 * stronger than RFC1933).  We may want to re-enable it if mech-xx
	 * is revised to forbid relaying case.
	 */
	if (IN6_IS_ADDR_V4COMPAT(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4COMPAT(&ip6->ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
		goto bad;
	}
#endif
a1108 109
	}
}

/*
 * get next header offset.  m will be retained.
 */
int
ip6_nexthdr(m, off, proto, nxtp)
	struct mbuf *m;
	int off;
	int proto;
	int *nxtp;
{
	struct ip6_hdr ip6;
	struct ip6_ext ip6e;
	struct ip6_frag fh;

	/* just in case */
	if (m == NULL)
		panic("ip6_nexthdr: m == NULL");
	if ((m->m_flags & M_PKTHDR) == 0 || m->m_pkthdr.len < off)
		return -1;

	switch (proto) {
	case IPPROTO_IPV6:
		if (m->m_pkthdr.len < off + sizeof(ip6))
			return -1;
		m_copydata(m, off, sizeof(ip6), (caddr_t)&ip6);
		if (nxtp)
			*nxtp = ip6.ip6_nxt;
		off += sizeof(ip6);
		return off;

	case IPPROTO_FRAGMENT:
		/*
		 * terminate parsing if it is not the first fragment,
		 * it does not make sense to parse through it.
		 */
		if (m->m_pkthdr.len < off + sizeof(fh))
			return -1;
		m_copydata(m, off, sizeof(fh), (caddr_t)&fh);
		if ((ntohs(fh.ip6f_offlg) & IP6F_OFF_MASK) != 0)
			return -1;
		if (nxtp)
			*nxtp = fh.ip6f_nxt;
		off += sizeof(struct ip6_frag);
		return off;

	case IPPROTO_AH:
		if (m->m_pkthdr.len < off + sizeof(ip6e))
			return -1;
		m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
		if (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 2) << 2;
		return off;

	case IPPROTO_HOPOPTS:
	case IPPROTO_ROUTING:
	case IPPROTO_DSTOPTS:
		if (m->m_pkthdr.len < off + sizeof(ip6e))
			return -1;
		m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
		if (nxtp)
			*nxtp = ip6e.ip6e_nxt;
		off += (ip6e.ip6e_len + 1) << 3;
		return off;

	case IPPROTO_NONE:
	case IPPROTO_ESP:
	case IPPROTO_IPCOMP:
		/* give up */
		return -1;

	default:
		return -1;
	}

	return -1;
}

/*
 * get offset for the last header in the chain.  m will be kept untainted.
 */
int
ip6_lasthdr(m, off, proto, nxtp)
	struct mbuf *m;
	int off;
	int proto;
	int *nxtp;
{
	int newoff;
	int nxt;

	if (!nxtp) {
		nxt = -1;
		nxtp = &nxt;
	}
	while (1) {
		newoff = ip6_nexthdr(m, off, proto, nxtp);
		if (newoff < 0)
			return off;
		else if (newoff < off)
			return -1;	/* invalid */
		else if (newoff == off)
			return newoff;

		off = newoff;
		proto = *nxtp;
@


1.8.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_input.c,v 1.29 2001/03/30 11:09:01 itojun Exp $	*/
/*	$KAME: ip6_input.c,v 1.188 2001/03/29 05:34:31 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
d105 4
d111 2
d127 1
d132 6
d143 6
a148 2
#ifdef PULLDOWN_TEST
static struct mbuf *ip6_pullexthdr __P((struct mbuf *, size_t, int));
d158 2
a159 2
	struct ip6protosw *pr;
	int i;
d174 3
d185 4
d193 1
a193 1
	 * assign loopback address first.
d195 1
a195 1
	in6_ifattach(lo0ifp, NULL);
d201 1
a201 4
	bzero(&nd6_timer_ch, sizeof(nd6_timer_ch));
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add(&nd6_timer_ch, hz);

d203 1
a203 3
	bzero(&in6_rr_timer_ch, sizeof(in6_rr_timer_ch));
	timeout_set(&in6_rr_timer_ch, in6_rr_timer, (caddr_t)0);
	timeout_add(&in6_rr_timer_ch, hz);
a257 1
#define M2MMAX	(sizeof(ip6stat.ip6s_m2m)/sizeof(ip6stat.ip6s_m2m[0]))
d260 3
a262 2
				ip6stat.ip6s_m2m[lo0ifp->if_index]++;	/*XXX*/
			} else if (m->m_pkthdr.rcvif->if_index < M2MMAX)
a267 1
#undef M2MMAX
d298 17
d324 1
a329 6
	 *
	 * This check chokes if we are in SIIT cloud.  As none of BSDs support
	 * IPv4-less kernel compilation, we cannot support SIIT environment
	 * at all.  So, it makes more sense for us to reject any malicious
	 * packets for non-SIIT environment, than try to do a partical support
	 * for SIIT environment.
d337 1
a352 1

d366 5
a370 11
	/* drop packets if interface ID portion is already filled */
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) == 0) {
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src) &&
		    ip6->ip6_src.s6_addr16[1]) {
			ip6stat.ip6s_badscope++;
			goto bad;
		}
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst) &&
		    ip6->ip6_dst.s6_addr16[1]) {
			ip6stat.ip6s_badscope++;
			goto bad;
d372 7
d381 1
a381 7
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1]
			= htons(m->m_pkthdr.rcvif->if_index);
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1]
			= htons(m->m_pkthdr.rcvif->if_index);

d383 1
a383 7
	 * We use rt->rt_ifp to determine if the address is ours or not.
	 * If rt_ifp is lo0, the address is ours.
	 * The problem here is, rt->rt_ifp for fe80::%lo0/64 is set to lo0,
	 * so any address under fe80::%lo0/64 will be mistakenly considered
	 * local.  The special case is supplied to handle the case properly
	 * by actually looking at interface addresses
	 * (using in6ifa_ifpwithaddr).
d385 15
a399 8
	if ((m->m_pkthdr.rcvif->if_flags & IFF_LOOPBACK) != 0 &&
	    IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst)) {
		if (!in6ifa_ifpwithaddr(m->m_pkthdr.rcvif, &ip6->ip6_dst)) {
			icmp6_error(m, ICMP6_DST_UNREACH,
			    ICMP6_DST_UNREACH_ADDR, 0);
			/* m is already freed */
			return;
		}
d401 1
a401 3
		ours = 1;
		deliverifp = m->m_pkthdr.rcvif;
		goto hbhcheck;
d404 3
d434 3
a436 6
	if (ip6_forward_rt.ro_rt != NULL &&
	    (ip6_forward_rt.ro_rt->rt_flags & RTF_UP) != 0 && 
	    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
			       &ip6_forward_rt.ro_dst.sin6_addr))
		ip6stat.ip6s_forward_cachehit++;
	else {
a437 2
			/* route is down or destination is different */
			ip6stat.ip6s_forward_cachemiss++;
a440 1

d475 1
a477 4
		/*
		 * packets to a tentative, duplicated, or somehow invalid
		 * address must not be accepted.
		 */
d479 1
a479 1
			/* this address is ready */
d484 1
a484 7
			/* address is not ready, so discard the packet. */
			nd6log((LOG_INFO,
			    "ip6_input: packet to an unready address %s->%s\n",
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst)));

			goto bad;
a552 1

a554 20

		/*
		 * if the payload length field is 0 and the next header field  
		 * indicates Hop-by-Hop Options header, then a Jumbo Payload
		 * option MUST be included.
		 */
		if (ip6->ip6_plen == 0 && plen == 0) {
			/*
			 * Note that if a valid jumbo payload option is
			 * contained, ip6_hoptops_input() must set a valid
			 * (non-zero) payload length to the variable plen. 
			 */
			ip6stat.ip6s_badoptions++;
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_discard);
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_hdrerr);
			icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    (caddr_t)&ip6->ip6_plen - (caddr_t)ip6);
			return;
		}
d617 2
a618 1
	} else if (!ours) {
a622 18
	ip6 = mtod(m, struct ip6_hdr *);

	/*
	 * Malicious party may be able to use IPv4 mapped addr to confuse
	 * tcp/udp stack and bypass security checks (act as if it was from
	 * 127.0.0.1 by using IPv6 src ::ffff:127.0.0.1).  Be cautious.
	 *
	 * For SIIT end node behavior, you may want to disable the check.
	 * However, you will  become vulnerable to attacks using IPv4 mapped
	 * source.
	 */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		ip6stat.ip6s_badscope++;
		in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_addrerr);
		goto bad;
	}

a628 1

d663 1
a663 1
	struct mbuf *m = *mp;
a721 1
	u_int32_t jumboplen;
d724 47
a770 78
		switch (*opt) {
		case IP6OPT_PAD1:
			optlen = 1;
			break;
		case IP6OPT_PADN:
			if (hbhlen < IP6OPT_MINLEN) {
				ip6stat.ip6s_toosmall++;
				goto bad;
			}
			optlen = *(opt + 1) + 2;
			break;
		case IP6OPT_RTALERT:
			/* XXX may need check for alignment */
			if (hbhlen < IP6OPT_RTALERT_LEN) {
				ip6stat.ip6s_toosmall++;
				goto bad;
			}
			if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2)
				/* XXX: should we discard the packet? */
				log(LOG_ERR, "length of router alert opt is inconsitent(%d)",
				    *(opt + 1));
			optlen = IP6OPT_RTALERT_LEN;
			bcopy((caddr_t)(opt + 2), (caddr_t)&rtalert_val, 2);
			*rtalertp = ntohs(rtalert_val);
			break;
		case IP6OPT_JUMBO:
			/* XXX may need check for alignment */
			if (hbhlen < IP6OPT_JUMBO_LEN) {
				ip6stat.ip6s_toosmall++;
				goto bad;
			}
			if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2)
				/* XXX: should we discard the packet? */
				log(LOG_ERR, "length of jumbopayload opt "
				    "is inconsistent(%d)\n",
				    *(opt + 1));
			optlen = IP6OPT_JUMBO_LEN;

			/*
			 * IPv6 packets that have non 0 payload length
			 * must not contain a jumbo payload option.
			 */
			ip6 = mtod(m, struct ip6_hdr *);
			if (ip6->ip6_plen) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt - opthead);
				return(-1);
			}

			/*
			 * We may see jumbolen in unaligned location, so
			 * we'd need to perform bcopy().
			 */
			bcopy(opt + 2, &jumboplen, sizeof(jumboplen));
			jumboplen = (u_int32_t)htonl(jumboplen);

#if 1
			/*
			 * if there are multiple jumbo payload options,
			 * *plenp will be non-zero and the packet will be
			 * rejected.
			 * the behavior may need some debate in ipngwg -
			 * multiple options does not make sense, however,
			 * there's no explicit mention in specification.
			 */
			if (*plenp != 0) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt + 2 - opthead);
				return(-1);
			}
d772 41
a812 28

			/*
			 * jumbo payload length must be larger than 65535.
			 */
			if (jumboplen <= IPV6_MAXPACKET) {
				ip6stat.ip6s_badoptions++;
				icmp6_error(m, ICMP6_PARAM_PROB,
					    ICMP6_PARAMPROB_HEADER,
					    sizeof(struct ip6_hdr) +
					    sizeof(struct ip6_hbh) +
					    opt + 2 - opthead);
				return(-1);
			}
			*plenp = jumboplen;

			break;
		default:		/* unknown option */
			if (hbhlen < IP6OPT_MINLEN) {
				ip6stat.ip6s_toosmall++;
				goto bad;
			}
			if ((optlen = ip6_unknown_opt(opt, m,
						      sizeof(struct ip6_hdr) +
						      sizeof(struct ip6_hbh) +
						      opt - opthead)) == -1)
				return(-1);
			optlen += 2;
			break;
d837 20
a856 20
	switch (IP6OPT_TYPE(*optp)) {
	case IP6OPT_TYPE_SKIP: /* ignore the option */
		return((int)*(optp + 1));
	case IP6OPT_TYPE_DISCARD:	/* silently discard */
		m_freem(m);
		return(-1);
	case IP6OPT_TYPE_FORCEICMP: /* send ICMP even if multicasted */
		ip6stat.ip6s_badoptions++;
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION, off);
		return(-1);
	case IP6OPT_TYPE_ICMP: /* send ICMP if not multicasted */
		ip6stat.ip6s_badoptions++;
		ip6 = mtod(m, struct ip6_hdr *);
		if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) ||
		    (m->m_flags & (M_BCAST|M_MCAST)))
			m_freem(m);
		else
			icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_OPTION, off);
		return(-1);
d876 4
a879 4
	struct inpcb *in6p;
	struct mbuf **mp;
	struct ip6_hdr *ip6;
	struct mbuf *m;
d916 1
a916 1
	if ((in6p->in6p_flags & IN6P_PKTINFO) != 0) {
d945 1
a945 1
	if ((in6p->in6p_flags & IN6P_HOPOPTS) != 0 && privileged) {
a956 3
#ifdef PULLDOWN_TEST
			struct mbuf *ext;
#endif
d962 3
a964 3
			ext = ip6_pullexthdr(m, sizeof(struct ip6_hdr),
			    ip6->ip6_nxt);
			if (ext == NULL) {
a967 1
			hbh = mtod(ext, struct ip6_hbh *);
d969 3
a971 2
			if (hbhlen != ext->m_len) {
				m_freem(ext);
a986 3
#ifdef PULLDOWN_TEST
			m_freem(ext);
#endif
d993 1
a993 1
		int nxt = ip6->ip6_nxt, off = sizeof(struct ip6_hdr);
d1002 2
a1003 2
		while (1) {	/* is explicit loop prevention necessary? */
			struct ip6_ext *ip6e = NULL;
a1004 17
#ifdef PULLDOWN_TEST
			struct mbuf *ext = NULL;
#endif

			/*
			 * if it is not an extension header, don't try to
			 * pull it from the chain.
			 */
			switch (nxt) {
			case IPPROTO_DSTOPTS:
			case IPPROTO_ROUTING:
			case IPPROTO_HOPOPTS:
			case IPPROTO_AH: /* is it possible? */
				break;
			default:
				goto loopend;
			}
a1006 2
			if (off + sizeof(*ip6e) > m->m_len)
				goto loopend;
a1011 2
			if (off + elen > m->m_len)
				goto loopend;
d1013 3
a1015 2
			ext = ip6_pullexthdr(m, off, nxt);
			if (ext == NULL) {
a1018 1
			ip6e = mtod(ext, struct ip6_ext *);
d1023 2
a1024 2
			if (elen != ext->m_len) {
				m_freem(ext);
d1030 44
a1073 47
			switch (nxt) {
			case IPPROTO_DSTOPTS:
				if (!in6p->in6p_flags & IN6P_DSTOPTS)
					break;

				/*
				 * We also require super-user privilege for
				 * the option.
				 * See the comments on IN6_HOPOPTS.
				 */
				if (!privileged)
					break;

				*mp = sbcreatecontrol((caddr_t)ip6e, elen,
						      IPV6_DSTOPTS,
						      IPPROTO_IPV6);
				if (*mp)
					mp = &(*mp)->m_next;
				break;

			case IPPROTO_ROUTING:
				if (!in6p->in6p_flags & IN6P_RTHDR)
					break;

				*mp = sbcreatecontrol((caddr_t)ip6e, elen,
						      IPV6_RTHDR,
						      IPPROTO_IPV6);
				if (*mp)
					mp = &(*mp)->m_next;
				break;

			case IPPROTO_HOPOPTS:
			case IPPROTO_AH: /* is it possible? */
				break;

			default:
				/*
			 	 * other cases have been filtered in the above.
				 * none will visit this case.  here we supply
				 * the code just in case (nxt overwritten or
				 * other cases).
				 */
#ifdef PULLDOWN_TEST
				m_freem(ext);
#endif
				goto loopend;

a1078 5
			ip6e = NULL;
#ifdef PULLDOWN_TEST
			m_freem(ext);
			ext = NULL;
#endif
a1091 56
#ifdef PULLDOWN_TEST
/*
 * pull single extension header from mbuf chain.  returns single mbuf that
 * contains the result, or NULL on error.
 */
static struct mbuf *
ip6_pullexthdr(m, off, nxt)
	struct mbuf *m;
	size_t off;
	int nxt;
{
	struct ip6_ext ip6e;
	size_t elen;
	struct mbuf *n;

#ifdef DIAGNOSTIC
	switch (nxt) {
	case IPPROTO_DSTOPTS:
	case IPPROTO_ROUTING:
	case IPPROTO_HOPOPTS:
	case IPPROTO_AH: /* is it possible? */
		break;
	default:
		printf("ip6_pullexthdr: invalid nxt=%d\n", nxt);
	}
#endif

	m_copydata(m, off, sizeof(ip6e), (caddr_t)&ip6e);
	if (nxt == IPPROTO_AH)
		elen = (ip6e.ip6e_len + 2) << 2;
	else
		elen = (ip6e.ip6e_len + 1) << 3;

	MGET(n, M_DONTWAIT, MT_DATA);
	if (n && elen >= MLEN) {
		MCLGET(n, M_DONTWAIT);
		if ((n->m_flags & M_EXT) == 0) {
			m_free(n);
			n = NULL;
		}
	}
	if (!n)
		return NULL;

	n->m_len = 0;
	if (elen >= M_TRAILINGSPACE(n)) {
		m_free(n);
		return NULL;
	}

	m_copydata(m, off, elen, mtod(n, caddr_t));
	n->m_len = elen;
	return n;
}
#endif

d1122 1
a1122 1
			switch (nxt) {
d1312 3
@


1.8.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.8.2.2 2001/05/14 22:40:18 niklas Exp $	*/
d111 2
d263 1
a263 1
		if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {
a278 7

#ifdef ALTQ
	if (altq_input != NULL && (*altq_input)(m, AF_INET6) == 0) {
		/* packet is dropped by traffic conditioner */
		return;
	}
#endif
@


1.8.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.8.2.3 2001/07/04 10:55:23 niklas Exp $	*/
a67 2
#include "pf.h"

a110 4
#if NPF > 0
#include <net/pfvar.h>
#endif

a255 8
#endif

#if NPF > 0 
        /*
         * Packet filter
         */
        if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
                goto bad;
@


1.8.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a1349 2
		if (m->m_pkthdr.len < off)
			return -1;
a1360 2
		if (m->m_pkthdr.len < off)
			return -1;
d1420 1
a1420 1
#include <uvm/uvm_extern.h>
@


1.8.2.6
log
@Merge in -current
@
text
@d268 2
a269 4
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		goto bad;
@


1.8.2.7
log
@Merge in trunk
@
text
@d223 11
d264 10
a291 12
#if NPF > 0 
        /*
         * Packet filter
         */
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
#endif

d302 1
a302 1
	 * Check against address spoofing/corruption.
a305 3
		/*
		 * XXX: "badscope" is not very suitable for a multicast source.
		 */
d311 4
a314 4
	 * The following check is not documented in specs.  A malicious
	 * party may be able to use IPv4 mapped addr to confuse tcp/udp stack
	 * and bypass security checks (act as if it was from 127.0.0.1 by using
	 * IPv6 src ::ffff:127.0.0.1).  Be cautious.
d316 5
a320 5
	 * This check chokes if we are in an SIIT cloud.  As none of BSDs
	 * support IPv4-less kernel compilation, we cannot support SIIT
	 * environment at all.  So, it makes more sense for us to reject any
	 * malicious packets for non-SIIT environment, than try to do a
	 * partical support for SIIT environment.
d567 1
a567 1
		 * if the payload length field is 0 and the next header field
a1182 1
	  	;
@


1.8.2.8
log
@Merge in -current from roughly a week ago
@
text
@d131 1
a131 1
static void ip6_init2(void *);
d133 1
a133 1
static int ip6_hopopts_input(u_int32_t *, u_int32_t *, struct mbuf **, int *);
d135 1
a135 1
static struct mbuf *ip6_pullexthdr(struct mbuf *, size_t, int);
@


1.8.2.9
log
@Sync the SMP branch with 3.3
@
text
@d105 1
d170 10
d184 5
d285 7
d314 1
a314 1
	 * partial support for SIIT environment.
d464 1
a464 1
	    &rt6_key(ip6_forward_rt.ro_rt)->sin6_addr) &&
d492 1
a492 1
	 * FAITH (Firewall Aided Internet Translator)
d739 1
a739 1
		return (-1);
d743 1
a743 1
	return (0);
a750 4
 *
 * The function assumes that hbh header is located right after the IPv6 header
 * (RFC2460 p7), opthead is pointer into data content in m, and opthead to
 * opthead + hbhlen is located in continuous memory region.
a764 1
	const int erroff = sizeof(struct ip6_hdr) + sizeof(struct ip6_hbh);
d784 4
a787 7
			if (*(opt + 1) != IP6OPT_RTALERT_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
d798 5
a802 7
			if (*(opt + 1) != IP6OPT_JUMBO_LEN - 2) {
				/* XXX stat */
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 1 - opthead);
				return (-1);
			}
d813 5
a817 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt - opthead);
				return (-1);
d839 5
a843 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
d853 5
a857 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff + opt + 2 - opthead);
				return (-1);
d867 5
a871 4
			optlen = ip6_unknown_opt(opt, m,
			    erroff + opt - opthead);
			if (optlen == -1)
				return (-1);
d877 1
a877 1
	return (0);
d881 1
a881 1
	return (-1);
d900 1
a900 1
		return ((int)*(optp + 1));
d903 1
a903 1
		return (-1);
d907 1
a907 1
		return (-1);
d917 1
a917 1
		return (-1);
d921 1
a921 1
	return (-1);
d1257 1
a1257 1
u_int8_t *
d1265 1
a1265 1
		return (&ip6->ip6_nxt);
d1289 1
a1289 1
			return (&ip6e->ip6e_nxt);
a1475 4
	case IPV6CTL_V6ONLY:
		return sysctl_rdint(oldp, oldlenp, newp, ip6_v6only);
	case IPV6CTL_MAXFRAGS:
		return sysctl_int(oldp, oldlenp, newp, newlen, &ip6_maxfrags);
@


1.8.2.10
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d133 1
d135 1
d232 5
d556 4
d566 1
d688 8
d709 1
d934 1
a934 1
		    SCM_TIMESTAMP, SOL_SOCKET);
d941 2
a942 1
		    sizeof(struct in6_addr), IPV6_RECVDSTADDR, IPPROTO_IPV6);
d966 2
a967 1
		    sizeof(struct in6_pktinfo), IPV6_PKTINFO, IPPROTO_IPV6);
d973 2
a974 2
		*mp = sbcreatecontrol((caddr_t) &hlim, sizeof(int),
		    IPV6_HOPLIMIT, IPPROTO_IPV6);
d998 1
d1000 1
d1002 4
d1019 1
d1028 1
a1028 1
			    IPV6_HOPOPTS, IPPROTO_IPV6);
d1031 1
d1033 1
d1052 1
d1054 1
d1070 11
d1096 1
d1112 2
a1113 1
				    IPV6_DSTOPTS, IPPROTO_IPV6);
d1123 2
a1124 1
				    IPV6_RTHDR, IPPROTO_IPV6);
d1140 1
d1142 1
d1151 1
d1154 1
d1159 7
d1169 1
d1223 1
@


1.8.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.8.2.10 2003/05/16 00:29:44 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a199 4
#if NPF > 0
	struct in6_addr odst;
#endif
	int srcrt = 0;
d244 12
a330 14
#if NPF > 0 
        /*
         * Packet filter
         */
	odst = ip6->ip6_dst;
	if (pf_test6(PF_IN, m->m_pkthdr.rcvif, &m) != PF_PASS)
		goto bad;
	if (m == NULL)
		return;

	ip6 = mtod(m, struct ip6_hdr *);
	srcrt = !IN6_ARE_ADDR_EQUAL(&odst, &ip6->ip6_dst);
#endif

d603 1
a603 1
		ip6_forward(m, srcrt);
d1248 1
a1248 1
		if ((fh.ip6f_offlg & IP6F_OFF_MASK) != 0)
@


1.8.2.13
log
@Merge with the trunk
@
text
@d904 4
d960 4
a963 5
	 * IPV6_HOPOPTS socket option.  Recall that we required super-user
	 * privilege for the option (see ip6_ctloutput), but it might be too
	 * strict, since there might be some hop-by-hop options which can be
	 * returned to normal user.
	 * See also RFC 2292 section 6.
d965 1
a965 1
	if ((in6p->in6p_flags & IN6P_HOPOPTS) != 0) {
d1059 8
a1344 2
int *ipv6ctl_vars[IPV6CTL_MAXID] = IPV6CTL_VARS;

d1359 31
d1392 5
d1399 2
d1402 1
a1402 4
		if (name[0] < IPV6CTL_MAXID)
			return (sysctl_int_arr(ipv6ctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return (EOPNOTSUPP);
@


1.7
log
@use arc4random() instead of random for two reasons.
1) on some architectures, random() should only be used by the scheduler
   (ie. statintr() because it is uniformly distributed
2) arc4random() is actually strong, random() is not at all
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.6 2000/01/06 02:52:51 itojun Exp $	*/
d97 1
a97 1
#include <netinet6/ip6.h>
d99 1
a99 1
#include <netinet6/icmp6.h>
@


1.6
log
@add missing net.inet6.ip6.rr_prune case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.5 1999/12/30 17:28:20 itojun Exp $	*/
a158 1
	struct timeval tv;
d176 1
a176 7
	/*
	 * in many cases, random() here does NOT return random number
	 * as initialization during bootstrap time occur in fixed order.
	 */
	microtime(&tv);
	ip6_flow_seq = random() ^ tv.tv_usec;

@


1.5
log
@initialize lo0 automatically.  kame ipv6 code assumes that there's ::1,
for various reasons ("goto ours" speedup, multicast group mgmt, and others).
should fix PR1012.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.4 1999/12/09 13:59:57 itojun Exp $	*/
d1188 2
@


1.4
log
@do not perform IPv6 initialization for loopback interface.
MUST make lo0 up before any IPv6 operations.
it will be considered a pilot error if you don't.
(I prefer to have lo0 initialized automatically)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.3 1999/12/09 00:40:06 angelos Exp $	*/
d196 1
a196 1
#if 0
@


1.3
log
@Bogus include file crept in.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.2 1999/12/09 00:34:13 angelos Exp $	*/
d191 1
a191 1
	int i, ret;
d196 1
d201 4
a204 2
	for (i = 0; i < NLOOP; i++)
		in6_ifattach(&loif[i], IN6_IFT_LOOP, NULL, 0);
@


1.2
log
@Shrink...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_input.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
a97 1
#include <netinet6/in6_pcb.h>
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 10
#ifdef __FreeBSD__
#include "opt_ip6fw.h"
#endif
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a78 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a79 1
#endif
d89 1
d94 1
a94 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a95 1
#endif
a97 1
#if !((defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802))
a98 1
#endif
a111 1
#ifndef __bsdi__
a112 1
#endif
a113 1

a118 4
#ifdef __OpenBSD__ /*KAME IPSEC*/
#undef IPSEC
#endif

a120 7
#ifdef __bsdi__
#if _BSDI_VERSION < 199802
extern struct ifnet loif;
#else
extern struct ifnet *loifp;
#endif
#endif
a126 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a127 1
#endif
a184 1
#ifndef __FreeBSD__
a185 1
#endif
d192 1
a192 7
#ifndef __bsdi__
	int i;
#endif
	int ret;
#if defined(__bsdi__) && _BSDI_VERSION < 199802
	struct ifnet *loifp = &loif;
#endif
a200 3
#ifdef __bsdi__
	in6_ifattach(loifp, IN6_IFT_LOOP, NULL, 0);
#else
a202 1
#endif
a209 5
#ifdef __FreeBSD__
/* cheat */
SYSINIT(netinet6init2, SI_SUB_PROTO_DOMAIN, SI_ORDER_THIRD, ip6_init2, NULL);
#endif

a228 4
#ifdef __FreeBSD__
NETISR_SET(NETISR_IPV6, ip6intr);
#endif

a240 3
#if defined(__bsdi__) && _BSDI_VERSION < 199802
	struct ifnet *loifp = &loif;
#endif
d242 1
a242 1
#ifdef IPSEC
a263 3
#ifdef __bsdi__
				ip6stat.ip6s_m2m[loifp->if_index]++;	/*XXX*/
#else
a264 1
#endif
a420 3
#ifdef __FreeBSD__
		rtalloc_ign((struct route *)&ip6_forward_rt, RTF_PRCLONING);
#else
a421 1
#endif
a600 9
#if defined(__NetBSD__) && defined(IFA_STATS)
	if (IFA_STATS && deliverifp != NULL) {
		struct in6_ifaddr *ia6;
		ip6 = mtod(m, struct ip6_hdr *);
		ia6 = in6_ifawithifp(deliverifp, &ip6->ip6_dst);
		if (ia6)
			ia6->ia_ifa.ifa_data.ifad_inbytes += m->m_pkthdr.len;
	}
#endif
a850 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(HAVE_NRL_INPCB)
a851 3
#else
	register struct in6pcb *in6p;
#endif
a855 1
#ifdef HAVE_NRL_INPCB
d857 1
a857 8
#endif
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	struct proc *p = curproc;	/* XXX */
#endif
#ifdef __bsdi__
# define sbcreatecontrol	so_cmsg
#endif
	int privileged;
a858 6
	privileged = 0;
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	if (p && !suser(p->p_ucred, &p->p_acflag))
		privileged++;
#else
#ifdef HAVE_NRL_INPCB
a860 5
#else
	if ((in6p->in6p_socket->so_state & SS_PRIV) != 0)
		privileged++;
#endif
#endif
a1063 5

#ifdef __bsdi__
# undef sbcreatecontrol
#endif
#ifdef __OpenBSD__
a1064 1
#endif
a1129 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1190 29
#endif /* __NetBSD__ || __OpenBSD__ */

#ifdef __bsdi__
int *ip6_sysvars[] = IPV6CTL_VARS;

int
ip6_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int	*name;
	u_int	namelen;
	void	*oldp;
	size_t	*oldlenp;
	void	*newp;
	size_t	newlen;
{
	if (name[0] >= IPV6CTL_MAXID)
		return (EOPNOTSUPP);

	switch (name[0]) {
	case IPV6CTL_STATS:
		return sysctl_rdtrunc(oldp, oldlenp, newp, &ip6stat,
		    sizeof(ip6stat));
	case IPV6CTL_KAME_VERSION:
		return sysctl_rdstring(oldp, oldlenp, newp, __KAME_VERSION);
	default:
		return (sysctl_int_arr(ip6_sysvars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	}
}
#endif /* __bsdi__ */
@

