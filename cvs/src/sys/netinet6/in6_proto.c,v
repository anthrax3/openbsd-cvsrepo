head	1.91;
access;
symbols
	OPENBSD_6_1:1.91.0.2
	OPENBSD_6_1_BASE:1.91
	OPENBSD_6_0:1.86.0.2
	OPENBSD_6_0_BASE:1.86
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.78.0.4
	OPENBSD_5_8_BASE:1.78
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.73.0.4
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.64.0.2
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.4
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.60.0.2
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.59.0.2
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.58.0.2
	OPENBSD_4_7_BASE:1.58
	OPENBSD_4_6:1.57.0.6
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.57.0.2
	OPENBSD_4_5_BASE:1.57
	OPENBSD_4_4:1.56.0.2
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.53.0.2
	OPENBSD_4_3_BASE:1.53
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50
	OPENBSD_3_9:1.47.0.2
	OPENBSD_3_9_BASE:1.47
	OPENBSD_3_8:1.46.0.4
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.46.0.2
	OPENBSD_3_7_BASE:1.46
	OPENBSD_3_6:1.44.0.2
	OPENBSD_3_6_BASE:1.44
	SMP_SYNC_A:1.44
	SMP_SYNC_B:1.44
	OPENBSD_3_5:1.43.0.2
	OPENBSD_3_5_BASE:1.43
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.40
	OPENBSD_3_3:1.40.0.2
	OPENBSD_3_3_BASE:1.40
	OPENBSD_3_2:1.39.0.2
	OPENBSD_3_2_BASE:1.39
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.39
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.27
	OPENBSD_2_9:1.27.0.2
	OPENBSD_2_8:1.25.0.2
	OPENBSD_2_8_BASE:1.25
	OPENBSD_2_7:1.19.0.2
	OPENBSD_2_7_BASE:1.19
	SMP:1.17.0.2
	SMP_BASE:1.17
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.4
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.91
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.90;
commitid	ZsxSSZJSFxZH81LL;

1.90
date	2017.03.02.08.58.24;	author mpi;	state Exp;
branches;
next	1.89;
commitid	tz6lHk1OQ6UxADoY;

1.89
date	2017.02.22.19.34.42;	author dhill;	state Exp;
branches;
next	1.88;
commitid	8MQyAJVsE6ZNz4mh;

1.88
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.87;
commitid	3e3CkrbYekyVOcxy;

1.87
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.86;
commitid	T2qzeepA7r1EGy1x;

1.86
date	2016.06.01.11.11.44;	author jca;	state Exp;
branches;
next	1.85;
commitid	sy5Ke15K2mroYglc;

1.85
date	2016.05.19.11.34.40;	author jca;	state Exp;
branches;
next	1.84;
commitid	vkyQX2LT0UqUpZLs;

1.84
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.83;
commitid	nmbu8xP0zmz2PPN0;

1.83
date	2015.12.03.12.42.03;	author goda;	state Exp;
branches;
next	1.82;
commitid	FFhJyNTOYvvsqwUi;

1.82
date	2015.10.07.10.50.35;	author mpi;	state Exp;
branches;
next	1.81;
commitid	hPrd2a6fiZdlN2yP;

1.81
date	2015.09.28.08.32.05;	author mpi;	state Exp;
branches;
next	1.80;
commitid	MCjArMsyMPhqxF1g;

1.80
date	2015.09.04.08.43.39;	author mpi;	state Exp;
branches;
next	1.79;
commitid	qAevExm24QrBjVNL;

1.79
date	2015.08.30.10.39.16;	author mpi;	state Exp;
branches;
next	1.78;
commitid	avqdJydG8T8nvZhe;

1.78
date	2015.07.18.15.51.17;	author mpi;	state Exp;
branches;
next	1.77;
commitid	lwQKRpFyNEr7kjoF;

1.77
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.76;
commitid	zhW8jJrfVCoAthrR;

1.76
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.75;
commitid	t9FBKDfc4VDxpEy2;

1.75
date	2014.08.27.14.04.16;	author florian;	state Exp;
branches;
next	1.74;
commitid	JNq3mHDvq54quWei;

1.74
date	2014.08.19.12.28.03;	author mpi;	state Exp;
branches;
next	1.73;
commitid	FLUReMqhibXwzcGn;

1.73
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.72;
commitid	DQakU8LLWV6Iwx84;

1.72
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.71;
commitid	AGagL83SRBC6d7e7;

1.71
date	2014.07.11.12.20.26;	author benno;	state Exp;
branches;
next	1.70;
commitid	P8JppJvHVB5bPsqa;

1.70
date	2014.07.09.08.07.53;	author benno;	state Exp;
branches;
next	1.69;
commitid	EWCx4gaJXrAHloPl;

1.69
date	2013.10.21.12.27.15;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.17.16.27.45;	author bluhm;	state Exp;
branches;
next	1.67;

1.67
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.01.22.58.29;	author bluhm;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2013.01.17.16.30.10;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2012.03.15.14.11.57;	author mikeb;	state Exp;
branches;
next	1.62;

1.62
date	2011.03.31.10.36.42;	author jasper;	state Exp;
branches;
next	1.61;

1.61
date	2011.03.23.13.40.42;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.07.17.50.42;	author bluhm;	state Exp;
branches;
next	1.59;

1.59
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.58;

1.58
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.57;

1.57
date	2008.11.25.12.11.45;	author markus;	state Exp;
branches;
next	1.56;

1.56
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.55;

1.55
date	2008.05.24.19.48.32;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2008.05.06.08.47.36;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.03.15.47.47;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.11.21.05.37.32;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.16.15.18.42;	author pascoe;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2005.10.14.02.44.27;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.07.20.38.47;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2004.10.18.03.59.33;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2004.04.25.02.48.04;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.31.09.00.32;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.07.09.11.53;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.11.18.25.40;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2002.08.20.21.59.12;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2002.08.17.22.19.28;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.07.21.47.44;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.07.15.27.58;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.29.02.59.12;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.28.03.04.38;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.08.02.29.03;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2001.08.08.15.09.00;	author jjbg;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.07.05.16.49.45;	author jjbg;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.25.22.08.24;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.04.06.04.42.09;	author csapuntz;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.11.08.04.56;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2000.10.10.15.53.09;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.10.14.23.34;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.06.10.11.25;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.18.17.32.48;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.05.22.10.32.52;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.28.16.40.39;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.02.02.17.01.51;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.23.03.51.03;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.21.03.15.06;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.01.13.06.01.22;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.13.05.06.12;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.13.04.59.38;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.13.04.09.00;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.01.12.06.35.04;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.01.02.11.09.20;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.01.02.04.52.26;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.03.09.05.31.52;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.04.36.41;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.56;	author deraadt;	state Exp;
branches;
next	;

1.17.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2001.07.04.10.55.21;	author niklas;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.17.2.5;

1.17.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.17.2.6;

1.17.2.6
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.17.2.7;

1.17.2.7
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.17.2.8;

1.17.2.8
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.17.2.9;

1.17.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.31.4.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.31.4.4;

1.31.4.4
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.91
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@/*	$OpenBSD: in6_proto.c,v 1.90 2017/03/02 08:58:24 mpi Exp $	*/
/*	$KAME: in6_proto.c,v 1.66 2000/10/10 15:35:47 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_proto.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/domain.h>
#include <sys/mbuf.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/rtable.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>

#include <netinet/tcp.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/ip_ipip.h>

#include <netinet6/in6_var.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6protosw.h>

#include "gif.h"
#if NGIF > 0
#include <netinet/ip_ether.h>
#include <net/if_gif.h>
#endif

#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#include "pf.h"
#if NPF > 0
#include <netinet6/ip6_divert.h>
#endif

#include "etherip.h"
#if NETHERIP > 0
#include <net/if_etherip.h>
#endif

/*
 * TCP/IP protocol family: IP6, ICMP6, UDP, TCP.
 */
u_char ip6_protox[IPPROTO_MAX];

struct protosw inet6sw[] = {
{
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPV6,
  .pr_init	= ip6_init,
  .pr_slowtimo	= frag6_slowtimo,
  .pr_drain	= frag6_drain,
  .pr_sysctl	= ip6_sysctl
},
{
  .pr_type	= SOCK_DGRAM,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_UDP,
  .pr_flags	= PR_ATOMIC|PR_ADDR|PR_SPLICE,
  .pr_input	= udp_input,
  .pr_ctlinput	= udp6_ctlinput,
  .pr_ctloutput	= ip6_ctloutput,
  .pr_usrreq	= udp_usrreq,
  .pr_attach	= udp_attach,
  .pr_sysctl	= udp_sysctl
},
{
  .pr_type	= SOCK_STREAM,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_TCP,
  .pr_flags	= PR_CONNREQUIRED|PR_WANTRCVD|PR_ABRTACPTDIS|PR_SPLICE,
  .pr_input	= tcp_input,
  .pr_ctlinput	= tcp6_ctlinput,
  .pr_ctloutput	= tcp_ctloutput,
  .pr_usrreq	= tcp_usrreq,
  .pr_attach	= tcp_attach,
  .pr_sysctl	= tcp_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_RAW,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= rip6_input,
  .pr_output	= rip6_output,
  .pr_ctlinput	= rip6_ctlinput,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= rip6_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_ICMPV6,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= icmp6_input,
  .pr_output	= rip6_output,
  .pr_ctlinput	= rip6_ctlinput,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_init	= icmp6_init,
  .pr_fasttimo	= icmp6_fasttimo,
  .pr_sysctl	= icmp6_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_DSTOPTS,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= dest6_input
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_ROUTING,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= route6_input
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_FRAGMENT,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= frag6_input
},
#ifdef IPSEC
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_AH,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= ah6_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= ah_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_ESP,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= esp6_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= esp_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPCOMP,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= ipcomp6_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= ipcomp_sysctl
},
#endif /* IPSEC */
#if NGIF > 0
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_ETHERIP,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= etherip_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= etherip_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPV6,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= in6_gif_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,	/* XXX */
  .pr_attach	= rip6_attach
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPV4,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= in6_gif_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,	/* XXX */
  .pr_attach	= rip6_attach
},
#else /* NGIF */
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPV6,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= ip4_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,	/* XXX */
  .pr_attach	= rip6_attach,
  .pr_sysctl	= ipip_sysctl
},
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_IPV4,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= ip4_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,	/* XXX */
  .pr_attach	= rip6_attach
},
#endif /* GIF */
#if NCARP > 0
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_CARP,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= carp6_proto_input,
  .pr_output	= rip6_output,
  .pr_ctloutput = rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= carp_sysctl
},
#endif /* NCARP */
#if NPF > 0
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_DIVERT,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= divert6_usrreq,
  .pr_attach	= divert6_attach,
  .pr_init	= divert6_init,
  .pr_sysctl	= divert6_sysctl
},
#endif /* NPF > 0 */
#if NETHERIP > 0
{
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_protocol	= IPPROTO_ETHERIP,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= ip6_etherip_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_sysctl	= ip_etherip_sysctl
},
#endif /* NETHERIP */
{
  /* raw wildcard */
  .pr_type	= SOCK_RAW,
  .pr_domain	= &inet6domain,
  .pr_flags	= PR_ATOMIC|PR_ADDR,
  .pr_input	= rip6_input,
  .pr_output	= rip6_output,
  .pr_ctloutput	= rip6_ctloutput,
  .pr_usrreq	= rip6_usrreq,
  .pr_attach	= rip6_attach,
  .pr_init	= rip6_init
}
};

struct domain inet6domain = {
  .dom_family = AF_INET6,
  .dom_name = "internet6",
  .dom_protosw = inet6sw,
  .dom_protoswNPROTOSW = &inet6sw[nitems(inet6sw)],
  .dom_rtkeylen = sizeof(struct sockaddr_in6),
  .dom_rtoffset = offsetof(struct sockaddr_in6, sin6_addr),
  .dom_maxplen = 128,
  .dom_ifattach = in6_domifattach,
  .dom_ifdetach = in6_domifdetach
};

/*
 * Internet configuration info
 */
int	ip6_forwarding = 0;	/* no forwarding unless sysctl'd to enable */
int	ip6_mforwarding = 0;	/* no multicast forwarding unless ... */
int	ip6_multipath = 0;	/* no using multipath routes unless ... */
int	ip6_sendredirects = 1;
int	ip6_defhlim = IPV6_DEFHLIM;
int	ip6_defmcasthlim = IPV6_DEFAULT_MULTICAST_HOPS;
int	ip6_maxfragpackets = 200;
int	ip6_maxfrags = 200;
int	ip6_log_interval = 5;
int	ip6_hdrnestlimit = 10;	/* appropriate? */
int	ip6_dad_count = 1;	/* DupAddrDetectionTransmits */
int	ip6_dad_pending;	/* number of currently running DADs */
int	ip6_auto_flowlabel = 1;
int	ip6_use_deprecated = 1;	/* allow deprecated addr (RFC2462 5.5.4) */
int	ip6_mcast_pmtu = 0;	/* enable pMTU discovery for multicast? */
int	ip6_neighborgcthresh = 2048; /* Threshold # of NDP entries for GC */
int	ip6_maxifprefixes = 16; /* Max acceptable prefixes via RA per IF */
int	ip6_maxifdefrouters = 16; /* Max acceptable def routers via RA */
int	ip6_maxdynroutes = 4096; /* Max # of routes created via redirect */
time_t	ip6_log_time = (time_t)0L;

/* raw IP6 parameters */
/*
 * Nominal space allocated to a raw ip socket.
 */
#define	RIPV6SNDQ	8192
#define	RIPV6RCVQ	8192

u_long	rip6_sendspace = RIPV6SNDQ;
u_long	rip6_recvspace = RIPV6RCVQ;

/* ICMPV6 parameters */
int	icmp6_redirtimeout = 10 * 60;	/* 10 minutes */
int	icmp6errppslim = 100;		/* 100pps */
int	ip6_mtudisc_timeout = IPMTUDISCTIMEOUT;
@


1.90
log
@Convert domain declarations to C99 initializers.

ok dhill@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.89 2017/02/22 19:34:42 dhill Exp $	*/
d142 1
d154 1
d167 1
d180 1
d216 1
d228 1
d240 1
d254 1
d265 2
a266 1
  .pr_usrreq	= rip6_usrreq	/* XXX */
d276 2
a277 1
  .pr_usrreq	= rip6_usrreq	/* XXX */
d289 1
d300 2
a301 1
  .pr_usrreq	= rip6_usrreq	/* XXX */
d314 1
d326 1
d341 1
d354 1
@


1.89
log
@Use c99 struct initialization with protosw.

This makes it easier to grep for a member, such as .pr_usrreq, and know
which functions to review.

ok mpi@@ bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.88 2017/01/29 19:58:47 bluhm Exp $	*/
d343 11
a353 7
struct domain inet6domain =
    { AF_INET6, "internet6", 0, 0, 0,
      (struct protosw *)inet6sw,
      (struct protosw *)&inet6sw[nitems(inet6sw)],
      sizeof(struct sockaddr_in6),
      offsetof(struct sockaddr_in6, sin6_addr), 128,
      in6_domifattach, in6_domifdetach, };
@


1.88
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.87 2016/12/22 11:04:44 rzalamena Exp $	*/
d125 76
a200 43
{ 0,		&inet6domain,	IPPROTO_IPV6,	0,
  0,		0,		0,		0,
  0,
  ip6_init,	0,		frag6_slowtimo,	frag6_drain,
  ip6_sysctl,
},
{ SOCK_DGRAM,	&inet6domain,	IPPROTO_UDP,	PR_ATOMIC|PR_ADDR|PR_SPLICE,
  udp_input,	0,		udp6_ctlinput,	ip6_ctloutput,
  udp_usrreq,	0,
  0,		0,		0,
  udp_sysctl,
},
{ SOCK_STREAM,	&inet6domain,	IPPROTO_TCP,	PR_CONNREQUIRED|PR_WANTRCVD|PR_ABRTACPTDIS|PR_SPLICE,
  tcp_input,	0,		tcp6_ctlinput,	tcp_ctloutput,
  tcp_usrreq,
  0,		0,		0,		0,
  tcp_sysctl,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_RAW,	PR_ATOMIC|PR_ADDR,
  rip6_input,	rip6_output,	rip6_ctlinput,	rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		rip6_sysctl
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_ICMPV6,	PR_ATOMIC|PR_ADDR,
  icmp6_input,	rip6_output,	rip6_ctlinput,	rip6_ctloutput,
  rip6_usrreq,
  icmp6_init,	icmp6_fasttimo,	0,		0,
  icmp6_sysctl,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_DSTOPTS,PR_ATOMIC|PR_ADDR,
  dest6_input,	0,	 	0,		0,
  0,
  0,		0,		0,		0,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_ROUTING,PR_ATOMIC|PR_ADDR,
  route6_input,	0,	 	0,		0,
  0,
  0,		0,		0,		0,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_FRAGMENT,PR_ATOMIC|PR_ADDR,
  frag6_input,	0,	 	0,		0,
  0,
  0,		0,		0,		0,
d203 32
a234 17
{ SOCK_RAW,	&inet6domain,	IPPROTO_AH,	PR_ATOMIC|PR_ADDR,
  ah6_input,	rip6_output, 	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,
  ah_sysctl,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_ESP,	PR_ATOMIC|PR_ADDR,
  esp6_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,
  esp_sysctl,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPCOMP,	PR_ATOMIC|PR_ADDR,
  ipcomp6_input, rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,
  ipcomp_sysctl,
d238 30
a267 14
{ SOCK_RAW,	&inet6domain,	IPPROTO_ETHERIP,PR_ATOMIC|PR_ADDR,
  etherip_input, rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		etherip_sysctl
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV6,	PR_ATOMIC|PR_ADDR,
  in6_gif_input, rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  in6_gif_input, rip6_output, 	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,
d270 20
a289 9
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV6,	PR_ATOMIC|PR_ADDR,
  ip4_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,		ipip_sysctl
},
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  ip4_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,
d293 10
a302 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_CARP,	PR_ATOMIC|PR_ADDR,
  carp6_proto_input,	rip6_output,	0,	rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		carp_sysctl
d306 9
a314 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_DIVERT,	PR_ATOMIC|PR_ADDR,
  0,		0,		0,	rip6_ctloutput,
  divert6_usrreq,
  divert6_init,	0,		0,		0,		divert6_sysctl
d318 10
a327 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_ETHERIP,PR_ATOMIC|PR_ADDR,
  ip6_etherip_input, rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		ip_etherip_sysctl
d330 11
a340 6
/* raw wildcard */
{ SOCK_RAW,	&inet6domain,	0,		PR_ATOMIC|PR_ADDR,
  rip6_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	rip6_init,
  0,		0,		0,
},
@


1.87
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.86 2016/06/01 11:11:44 jca Exp $	*/
d124 1
a124 1
struct ip6protosw inet6sw[] = {
d132 1
a132 1
  udp6_input,	0,		udp6_ctlinput,	ip6_ctloutput,
d138 1
a138 1
  tcp6_input,	0,		tcp6_ctlinput,	tcp_ctloutput,
d191 1
a191 1
  etherip_input6, rip6_output,	0,		rip6_ctloutput,
d207 1
a207 1
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
d212 1
a212 1
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
d226 1
a226 1
  divert6_input,	0,		0,	rip6_ctloutput,
@


1.86
log
@Kill sysctl net.inet6.ip6.rr_prune

We don't support Router Renumbering and there are no plans to change
that.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.85 2016/05/19 11:34:40 jca Exp $	*/
a93 4
#ifdef PIM
#include <netinet6/pim6_var.h>
#endif

a216 7
#ifdef PIM
{ SOCK_RAW,	&inet6domain,	IPPROTO_PIM,	PR_ATOMIC|PR_ADDR,
  pim6_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		pim6_sysctl
},
#endif /* PIM */
@


1.85
log
@Remove sysctl net.inet6.ip6.v6only

This sysctl is a no-op, read-only since it was introduced.  There are no
plans to support IPv4-mapped addresses on OpenBSD, thus this sysctl is
meaningless.

Noticed by djm@@, ok claudio@@ mpi@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.84 2015/12/03 21:57:59 mpi Exp $	*/
a281 2
int	ip6_rr_prune = 5;	/* router renumbering prefix
				 * walk list every 5 sec.    */
@


1.84
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.83 2015/12/03 12:42:03 goda Exp $	*/
a284 1
const int ip6_v6only = 1;
@


1.83
log
@Implement etherip(4) driver

This commit is not removing the existing EtherIP part of gif(4) and
it keeps EtherIP of gif(4) working.

ok jbg@@ sthen@@ mpi@@ reyk@@ yasuoka@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.82 2015/10/07 10:50:35 mpi Exp $	*/
d262 1
a262 1
      offsetof(struct sockaddr_in6, sin6_addr),
@


1.82
log
@Initialize the routing table before domains.

The routing table is not an optional component of the network stack
and initializing it inside the "routing domain" requires some ugly
introspection in the domain interface.

This put the rtable* layer at the same level of the if* level.  These
two subsystem are organized around the two global data structure used
in the network stack:

- the global &ifnet list, to be used in process context only, and
- the routing table which can be read in interrupt context.

This change makes the rtable_* layer domain-aware and extends the
"struct domain" such that INET, INET6 and MPLS can specify the length
of the binary key used in lookups.  This allows us to keep, or move
towards, AF-free route and rtable layers.

While here stop the madness and pass the size of the maximum key length
in *byte* to rn_inithead0().

ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.81 2015/09/28 08:32:05 mpi Exp $	*/
d118 5
d242 7
@


1.81
log
@Merge gif(4)'s tentacles in a single file.

Tested by <mxb AT alumni DOT chalmers DOT se>.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.80 2015/09/04 08:43:39 mpi Exp $	*/
d249 2
a250 2
      rtable_attach,
      offsetof(struct sockaddr_in6, sin6_addr) << 3,
@


1.80
log
@Make every subsystem using a radix tree call rn_init() and pass the
length of the key as argument.

This way every consumer of the radix tree has a chance to explicitly
initialize the shared data structures and no longer rely on another
subsystem to do the initialization.

As a bonus ``dom_maxrtkey'' is no longer used an die.

ART kernels should now be fully usable because pf(4) and IPSEC properly
initialized the radix tree.

ok chris@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.79 2015/08/30 10:39:16 mpi Exp $	*/
d105 1
a105 1
#include <netinet6/in6_gif.h>
@


1.79
log
@Use a global table for domains instead of building a list at run time.

As a side effect there's no need to run if_attachdomain() after the
list of domains has been built.

ok claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.78 2015/07/18 15:51:17 mpi Exp $	*/
a250 1
      sizeof(struct sockaddr_in6),
@


1.78
log
@Abstract the routing table internals behind an rtable_* API.

Code abusing the radix internals for the routing table should now
includes <net/rtable.h> and only deal with "struct rtentry".

Code using a radix tree for another purpose can still include
<net/radix.h>.

Inputs from and ok claudio@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.77 2014/12/19 17:14:40 tedu Exp $	*/
d248 1
a248 1
      (struct protosw *)&inet6sw[nitems(inet6sw)], 0,
@


1.77
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.76 2014/12/05 15:50:04 mpi Exp $	*/
a72 4
#include <net/radix.h>
#ifndef SMALL_KERNEL
#include <net/radix_mpath.h>
#endif
d74 1
d249 1
a249 5
#ifndef SMALL_KERNEL
      rn_mpath_inithead,
#else
      rn_inithead,
#endif
@


1.76
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.75 2014/08/27 14:04:16 florian Exp $	*/
a141 1
#ifdef INET	/* don't call initialization and timeout routines twice */
a142 3
#else
  tcp_init,	tcp_fasttimo,	tcp_slowtimo,	0,
#endif
a201 1
#ifdef INET
a206 1
#endif /* INET */
a212 1
#ifdef INET
a217 1
#endif /* INET */
@


1.75
log
@Nuke net.inet6.icmp6.rediraccept and allow redirects on interfaces
with autoconf enabled.
If one is doing SLAAC one does already trust link local icmp6 so the
policy for icmp6 redirects should be the same.
pointed out by & OK bluhm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.74 2014/08/19 12:28:03 mpi Exp $	*/
d72 1
@


1.74
log
@Keep pim code under #ifdef PIM to be coherent with what's in netinet/.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.73 2014/07/22 11:06:10 mpi Exp $	*/
a305 1
int	icmp6_rediraccept = 0;		/* don't process redirects by default */
@


1.73
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.72 2014/07/11 16:39:06 henning Exp $	*/
d96 1
a96 1
#ifdef MROUTING
d226 1
a226 1
#ifdef MROUTING
d232 1
a232 1
#endif
@


1.72
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.70 2014/07/09 08:07:53 benno Exp $	*/
a78 1
#include <netinet/in_systm.h>
@


1.71
log
@Remove rfc 4620 Node Information Query support (from the kernel).

ok henning@@ stu@@, Yay! weerd@@
@
text
@a277 1
int	ip6_accept_rtadv = 0;	/* enabling forwarding and rtadv concurrently is dangerous */
@


1.70
log
@Set default of net.inet6.icmp6.nodeinfo to 0,
disables responses to RFC4620 IPv6 Node Information Queries.
ok florian henning bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.69 2013/10/21 12:27:15 deraadt Exp $	*/
a310 1
int	icmp6_nodeinfo = 0;		/* enable/disable NI response */
@


1.69
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.68 2013/10/17 16:27:45 bluhm Exp $	*/
d311 1
a311 1
int	icmp6_nodeinfo = 1;		/* enable/disable NI response */
@


1.68
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.67 2013/04/24 10:17:08 mpi Exp $	*/
a296 8
/* icmp6 */
/*
 * BSDI4 defines these variables in in_proto.c...
 * XXX: what if we don't define INET? Should we define pmtu6_expire
 * or so? (jinmei@@kame.net 19990310)
 */
int pmtu_expire = 60*10;

d312 1
@


1.67
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.66 2013/04/01 22:58:29 bluhm Exp $	*/
a79 1
#include <netinet/in_var.h>
d101 1
a102 1

@


1.66
log
@Allow raw IPv6 sockets for IPsec protocols.  IPv4 does the same.
Ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.65 2013/03/14 11:18:37 mpi Exp $	*/
d125 1
a125 2

extern	struct domain inet6domain;
@


1.65
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.64 2013/01/17 16:30:10 bluhm Exp $	*/
d179 2
a180 2
  ah6_input,	0,	 	0,		0,
  0,
d185 2
a186 2
  esp6_input,	0,	 	0,		0,
  0,
d191 2
a192 2
  ipcomp6_input, 0,	 	0,		0,
  0,
@


1.64
log
@Expand the socket splicing functionality from TCP to UDP.  Merge
the code relevant for UDP from sosend() and soreceive() into somove().
That allows the kernel to directly transfer the UDP data from one
socket to another.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.63 2012/03/15 14:11:57 mikeb Exp $	*/
a296 1
int	ip6_keepfaith = 0;
@


1.63
log
@Direct IPv6 packets with Ethernet encapsulation into the appropriate
input routine allowing us to bridge two IPv4 networks over an IPv6
link with gif(4).

ok henning, sthen, ok and tests phessler, "lets get this in!" todd
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.62 2011/03/31 10:36:42 jasper Exp $	*/
d135 1
a135 1
{ SOCK_DGRAM,	&inet6domain,	IPPROTO_UDP,	PR_ATOMIC|PR_ADDR,
@


1.62
log
@- use nitems(); no binary change

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.61 2011/03/23 13:40:42 claudio Exp $	*/
d108 1
d198 5
d204 1
a204 1
  in6_gif_input, rip6_output,	 	0,		rip6_ctloutput,
@


1.61
log
@Don't process ICMP6 redirects by default anymore. This is in line with
what we do for IPv4. rtsol will turn it back on if -F is used.
After discussion with bluhm@@, fgsch@@, sthen@@ and deraadt@@
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.60 2011/01/07 17:50:42 bluhm Exp $	*/
d255 1
a255 1
      (struct protosw *)&inet6sw[sizeof(inet6sw)/sizeof(inet6sw[0])], 0,
@


1.60
log
@Add socket option SO_SPLICE to splice together two TCP sockets.
The data received on the source socket will automatically be sent
on the drain socket.  This allows to write relay daemons with zero
data copy.
ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.59 2010/07/08 19:42:46 jsg Exp $	*/
d313 1
a313 1
int	icmp6_rediraccept = 1;		/* accept and process redirects */
@


1.59
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.58 2009/11/05 20:50:14 michele Exp $	*/
d140 1
a140 1
{ SOCK_STREAM,	&inet6domain,	IPPROTO_TCP,	PR_CONNREQUIRED|PR_WANTRCVD|PR_ABRTACPTDIS,
@


1.58
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.57 2008/11/25 12:11:45 markus Exp $	*/
a290 1
u_int32_t ip6_id = 0UL;
a314 1
struct timeval icmp6errratelim = { 0, 0 };	/* no ratelimit */
a316 5

/* UDP on IP6 parameters */
int	udp6_sendspace = 9216;		/* really max datagram size */
int	udp6_recvspace = 40 * (1024 + sizeof(struct sockaddr_in6));
					/* 40 1K datagrams */
@


1.57
log
@delay /etc/netstart until IPv6-DAD (dup-address-detection) is completed.
ok fries, hshoexer, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.56 2008/06/11 06:30:36 mcbride Exp $	*/
d116 5
d232 1
a232 1
  carp6_proto_input,	rip6_output,	0,		rip6_ctloutput,
d237 7
d247 1
a247 1
  rip6_usrreq, rip6_init,
@


1.56
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.55 2008/05/24 19:48:32 thib Exp $	*/
d268 1
@


1.55
log
@Remove {tcp/udp}6_usrreq(); Since the normal ones now
take a proc argument, theres no need for these, since
they are just wrappers.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.54 2008/05/06 08:47:36 markus Exp $	*/
d274 4
@


1.54
log
@remove tcp_drain code since it's not longer used; ok henning, feedback thib
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.53 2007/12/14 18:33:41 deraadt Exp $	*/
d131 1
a131 1
  udp6_usrreq,	0,
d137 1
a137 1
  tcp6_usrreq,
@


1.53
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.52 2007/05/03 15:47:47 claudio Exp $	*/
d139 1
a139 1
  0,		0,		0,		tcp_drain,
d141 1
a141 1
  tcp_init,	tcp_fasttimo,	tcp_slowtimo,	tcp_drain,
@


1.52
log
@Reduce ip6_hdrnestlimit from 50 to 10. Normal IPv6 packets should not have
more then 10 headers nested.
OK deraadt@@ henning@@ mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.51 2006/11/21 05:37:32 itojun Exp $	*/
d148 1
a148 1
  0,		0,		0,		0,
d222 1
a222 1
  0,		0,		0,		0,
@


1.51
log
@introduce sysctl net.inet6.ip6.multicast_mtudisc (for multicast routers).
deraadt ok.  manpage nit by jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.50 2006/06/18 11:47:46 pascoe Exp $	*/
d266 1
a266 1
int	ip6_hdrnestlimit = 50;	/* appropriate? */
@


1.50
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.49 2006/06/16 15:18:42 pascoe Exp $	*/
d272 1
@


1.49
log
@SZpelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.48 2006/05/27 23:40:27 claudio Exp $	*/
d258 1
@


1.48
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.47 2005/10/14 02:44:27 brad Exp $	*/
d257 1
a257 1
int	ip6_mforwarding = 0;	/* no mulitcast forwarding unless ... */
@


1.47
log
@bye bye more compile time knobs, use the sysctl to enable v6 forwarding.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.46 2004/12/07 20:38:47 mcbride Exp $	*/
d98 1
d100 1
d218 1
d224 1
d257 1
@


1.46
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.45 2004/10/18 03:59:33 itojun Exp $	*/
d252 1
a252 9
#ifndef	IPV6FORWARDING
#ifdef GATEWAY6
#define	IPV6FORWARDING	1	/* forward IP6 packets not for us */
#else
#define	IPV6FORWARDING	0	/* don't forward IP6 packets not for us */
#endif /* GATEWAY6 */
#endif /* !IPV6FORWARDING */

int	ip6_forwarding = IPV6FORWARDING;	/* act as router? */
d256 1
a256 1
int	ip6_accept_rtadv = 0;	/* "IPV6FORWARDING ? 0 : 1" is dangerous */
@


1.45
log
@g/c ip6_flow_seq.  found by mcbride.  mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.44 2004/04/25 02:48:04 itojun Exp $	*/
d223 1
a223 1
  carp6_input,	rip6_output,	0,		rip6_ctloutput,
@


1.44
log
@radix tree with multipath support.  from kame.  deraadt ok
user visible changes:
- you can add multiple routes with same key (route add A B then route add A C)
- you have to specify gateway address if there are multiple entries on the table
  (route delete A B, instead of route delete A)
kernel change:
- radix_node_head has an extra entry
- rnh_deladdr takes extra argument

TODO:
- actually take advantage of multipath (rtalloc -> rtalloc_mpath)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.43 2003/10/31 09:00:32 mcbride Exp $	*/
a269 1
u_int32_t ip6_flow_seq;
@


1.43
log
@Add IPv6 support to CARP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.42 2003/08/07 09:11:53 itojun Exp $	*/
d73 3
d240 3
d244 1
@


1.42
log
@make net.inet6.ip6.redirect actually work.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.41 2003/06/02 23:28:15 millert Exp $	*/
d106 5
d218 7
@


1.41
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.40 2002/11/11 18:25:40 itojun Exp $	*/
a240 4
#ifndef	IPV6_SENDREDIRECTS
#define	IPV6_SENDREDIRECTS	1
#endif

d242 1
a242 1
int	ip6_sendredirects = IPV6_SENDREDIRECTS;
@


1.40
log
@pmtu_probe is not used anywhere (it is used in KAME TCP6-only code).
From: Krister Walfridsson <cato@@df.lth.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.39 2002/08/20 21:59:12 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.39
log
@set use_deprecated back to 1.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.38 2002/08/17 22:19:28 itojun Exp $	*/
a275 1
int pmtu_probe = 60*2;
@


1.38
log
@set default value for use_deprecated to 0, to avoid consequences with ftpd.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.37 2002/06/09 14:38:39 itojun Exp $	*/
d261 1
a261 1
int	ip6_use_deprecated = 0;	/* allow deprecated addr (RFC2462 5.5.4) */
@


1.37
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.36 2002/06/07 21:47:44 itojun Exp $	*/
d261 1
a261 1
int	ip6_use_deprecated = 1;	/* allow deprecated addr (RFC2462 5.5.4) */
@


1.36
log
@move IPV6_CHECKSUM processing to ip6_raw_ctloutput().  bunch of KNFs.
rip6 stats.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.35 2002/06/07 15:27:58 itojun Exp $	*/
d152 1
a152 1
  0,	  
d157 1
a157 1
  0,	  
d162 1
a162 1
  0,	  
d168 1
a168 1
  0,	  
d174 1
a174 1
  0,	  
d180 1
a180 1
  0,	  
d213 1
a213 1
  pim6_input,	rip6_output,	0,		rip6_ctloutput, 
d226 1
a226 1
    { AF_INET6, "internet6", 0, 0, 0, 
@


1.35
log
@just for consistency/compatibility, have net.inet6.ip6.v6only sysctl MIB,
as well as set/getsockopt(IPV6_V6ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.34 2002/05/29 02:59:12 itojun Exp $	*/
d145 1
a145 1
  icmp6_input,	rip6_output,	0,		rip6_ctloutput,
@


1.34
log
@move per-interface ip6/icmp6 stat to ifnet->if_afdata.   sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.33 2002/05/28 03:04:38 itojun Exp $	*/
d264 1
@


1.33
log
@limit number of IPv6 fragments (not the fragment queue size) to
fight against lots-of-frags DoS attacks.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.32 2002/01/08 02:29:03 itojun Exp $	*/
d231 2
a232 1
      sizeof(struct sockaddr_in6) };
@


1.32
log
@correct behavior of IPv4 over IPv6 tunnel (using gif).

http://archives.neohapsis.com/archives/openbsd/2001-09/0165.html
From: Alexander Yurchenko <grange@@rt.mipt.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.31 2001/08/08 15:09:00 jjbg Exp $	*/
d254 1
@


1.31
log
@remove IPCOMP option. deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.30 2001/07/05 16:49:45 jjbg Exp $	*/
d187 2
a188 2
  in6_gif_input,0,	 	0,		0,
  0,	  
d192 3
a194 3
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV6,	PR_ATOMIC|PR_ADDR,
  in6_gif_input,0,	 	0,		0,
  0,	  
d199 4
a202 4
{ SOCK_RAW,     &inet6domain,    IPPROTO_IPV6,  PR_ATOMIC|PR_ADDR,
  ip4_input6,   rip6_output,     0,              rip6_ctloutput,
  rip6_usrreq,   /* XXX */
  0,            0,              0,              0,              ipip_sysctl
d205 4
a208 4
{ SOCK_RAW,     &inet6domain,    IPPROTO_IPV4,  PR_ATOMIC|PR_ADDR,
  ip4_input6,   rip6_output,     0,              rip6_ctloutput,
  0,   
  0,            0,              0,              0,
d212 2
a213 2
{ SOCK_RAW,     &inet6domain,	IPPROTO_PIM,	PR_ATOMIC|PR_ADDR,
  pim6_input,    rip6_output,	0,              rip6_ctloutput, 
d215 1
a215 1
  0,            0,              0,              0,
@


1.31.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.32 2002/01/08 02:29:03 itojun Exp $	*/
d187 2
a188 2
  in6_gif_input, rip6_output,	 	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
d192 3
a194 3
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  in6_gif_input, rip6_output, 	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
d199 4
a202 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV6,	PR_ATOMIC|PR_ADDR,
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,		ipip_sysctl
d205 4
a208 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,
d212 2
a213 2
{ SOCK_RAW,	&inet6domain,	IPPROTO_PIM,	PR_ATOMIC|PR_ADDR,
  pim6_input,	rip6_output,	0,		rip6_ctloutput, 
d215 1
a215 1
  0,		0,		0,		0,
@


1.31.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.31.4.1 2002/01/31 22:55:46 niklas Exp $	*/
d145 1
a145 1
  icmp6_input,	rip6_output,	rip6_ctlinput,	rip6_ctloutput,
d231 1
a231 2
      sizeof(struct sockaddr_in6),
      in6_domifattach, in6_domifdetach, };
a253 1
int	ip6_maxfrags = 200;
a261 1
const int ip6_v6only = 1;
@


1.31.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.31.4.2 2002/06/11 03:31:37 art Exp $	*/
d152 1
a152 1
  0,
d157 1
a157 1
  0,
d162 1
a162 1
  0,
d168 1
a168 1
  0,
d174 1
a174 1
  0,
d180 1
a180 1
  0,
d213 1
a213 1
  pim6_input,	rip6_output,	0,		rip6_ctloutput,
d226 1
a226 1
    { AF_INET6, "internet6", 0, 0, 0,
@


1.31.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d276 1
@


1.30
log
@IPComp support. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.29 2001/06/09 06:43:38 angelos Exp $	*/
a177 1
#ifdef IPCOMP
a183 1
#endif /* IPCOMP */
@


1.29
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.28 2001/05/25 22:08:24 itojun Exp $	*/
d178 1
a178 1
#if 0
d183 1
a183 1
  ipsec6_sysctl,
d185 1
a185 1
#endif /* 0 */
@


1.28
log
@recover old acecept(2) behavior (no ECONNABORTED) for unix domain socket.
it is to be friendly with postfix daemon-to-daemon communication
(not 100% sure if which behavior is correct, specwise).  patch similar to netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.27 2001/04/06 04:42:09 csapuntz Exp $	*/
a108 2

#include <net/net_osdep.h>
@


1.27
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.26 2000/12/11 08:04:56 itojun Exp $	*/
d125 1
a125 1
{ SOCK_DGRAM,	&inet6domain,	IPPROTO_UDP,	PR_ATOMIC | PR_ADDR,
d131 1
a131 1
{ SOCK_STREAM,	&inet6domain,	IPPROTO_TCP,	PR_CONNREQUIRED | PR_WANTRCVD,
d141 1
a141 1
{ SOCK_RAW,	&inet6domain,	IPPROTO_RAW,	PR_ATOMIC | PR_ADDR,
d146 1
a146 1
{ SOCK_RAW,	&inet6domain,	IPPROTO_ICMPV6,	PR_ATOMIC | PR_ADDR,
d222 1
a222 1
{ SOCK_RAW,	&inet6domain,	0,		PR_ATOMIC | PR_ADDR,
@


1.26
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.25 2000/10/10 15:53:09 itojun Exp $	*/
a110 2

#define	offsetof(type, member)	((size_t)(&((type *)0)->member))
@


1.25
log
@little bit of sync with kame ($KAME, s/u_char/u_int8_t/)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.24 2000/10/10 14:23:34 itojun Exp $	*/
a132 8
#ifdef TCP6
{ SOCK_STREAM,	&inet6domain,	IPPROTO_TCP,	PR_CONNREQUIRED | PR_WANTRCVD,
  tcp6_input,	0,		tcp6_ctlinput,	tcp6_ctloutput,
  tcp6_usrreq,
  tcp6_init,	tcp6_fasttimo,	tcp6_slowtimo,	tcp6_drain,
  tcp6_sysctl,
},
#else
a142 1
#endif /*TCP6*/
a296 75

#ifdef TCP6
/* TCP on IP6 parameters */
int	tcp6_sendspace = 1024 * 8;
int	tcp6_recvspace = 1024 * 8;
int 	tcp6_mssdflt = TCP6_MSS;
int 	tcp6_rttdflt = TCP6TV_SRTTDFLT / PR_SLOWHZ;
int	tcp6_do_rfc1323 = 1;
int	tcp6_conntimeo = TCP6TV_KEEP_INIT;	/* initial connection timeout */
int	tcp6_43maxseg = 0;
int	tcp6_pmtu = 0;

/*
 * Parameters for keepalive option.
 * Connections for which SO_KEEPALIVE is set will be probed
 * after being idle for a time of tcp6_keepidle (in units of PR_SLOWHZ).
 * Starting at that time, the connection is probed at intervals
 * of tcp6_keepintvl (same units) until a response is received
 * or until tcp6_keepcnt probes have been made, at which time
 * the connection is dropped.  Note that a tcp6_keepidle value
 * under 2 hours is nonconformant with RFC-1122, Internet Host Requirements.
 */
int	tcp6_keepidle = TCP6TV_KEEP_IDLE;	/* time before probing idle */
int	tcp6_keepintvl = TCP6TV_KEEPINTVL;	/* interval betwn idle probes */
int	tcp6_keepcnt = TCP6TV_KEEPCNT;		/* max idle probes */
int	tcp6_maxpersistidle = TCP6TV_KEEP_IDLE;	/* max idle time in persist */

#ifndef INET_SERVER
#define	TCP6_LISTEN_HASH_SIZE	17
#define	TCP6_CONN_HASH_SIZE	97
#define	TCP6_SYN_HASH_SIZE	293
#define	TCP6_SYN_BUCKET_SIZE	35
#else
#define	TCP6_LISTEN_HASH_SIZE	97
#define	TCP6_CONN_HASH_SIZE	9973
#define	TCP6_SYN_HASH_SIZE	997
#define	TCP6_SYN_BUCKET_SIZE	35
#endif
int	tcp6_listen_hash_size = TCP6_LISTEN_HASH_SIZE;
int	tcp6_conn_hash_size = TCP6_CONN_HASH_SIZE;
struct	tcp6_hash_list tcp6_listen_hash[TCP6_LISTEN_HASH_SIZE],
	tcp6_conn_hash[TCP6_CONN_HASH_SIZE];

int	tcp6_syn_cache_size = TCP6_SYN_HASH_SIZE;
int	tcp6_syn_cache_limit = TCP6_SYN_HASH_SIZE*TCP6_SYN_BUCKET_SIZE;
int	tcp6_syn_bucket_limit = 3*TCP6_SYN_BUCKET_SIZE;
struct	syn_cache_head6 tcp6_syn_cache[TCP6_SYN_HASH_SIZE];
struct	syn_cache_head6 *tcp6_syn_cache_first;
int	tcp6_syn_cache_interval = 8;	/* runs timer every 4 seconds */
int	tcp6_syn_cache_timeo = TCP6TV_KEEP_INIT;

/*
 * Parameters for computing a desirable data segment size
 * given an upper bound (either interface MTU, or peer's MSS option)_.
 * As applications tend to use a buffer size that is a multiple
 * of kilobytes, try for something that divides evenly. However,
 * do not round down too much.
 *
 * Round segment size down to a multiple of TCP6_ROUNDSIZE if this
 * does not result in lowering by more than (size/TCP6_ROUNDFRAC).
 * For example, round 536 to 512.  Older versions of the system
 * effectively used MCLBYTES (1K or 2K) as TCP6_ROUNDSIZE, with
 * a value of 1 for TCP6_ROUNDFRAC (eliminating its effect).
 * We round to a multiple of 256 for SLIP.
 */
#ifndef	TCP6_ROUNDSIZE
#define	TCP6_ROUNDSIZE	256	/* round to multiple of 256 */
#endif
#ifndef	TCP6_ROUNDFRAC
#define	TCP6_ROUNDFRAC	10	/* round down at most N/10, or 10% */
#endif

int	tcp6_roundsize = TCP6_ROUNDSIZE;
int	tcp6_roundfrac = TCP6_ROUNDFRAC;
#endif /*TCP6*/
@


1.24
log
@do not call tcp_init twice on dualstack machine
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_proto.c,v 1.23 2000/07/06 10:11:25 itojun Exp $	*/
/*	$KAME: in6_proto.c,v 1.64 2000/06/20 16:20:27 itojun Exp $	*/
@


1.23
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.22 2000/06/18 17:32:48 itojun Exp $	*/
d144 2
a145 2
#ifdef INET	/* don't call timeout routines twice */
  tcp_init,	0,		0,		tcp_drain,
@


1.22
log
@sync with KAME udp6_output().  udp output logic is very different between
IPv4/v6 so the separation should make more sense.

TODO: remove IPv6 case from udp_output()
TODO: remove/comment out/#if 0 IPv4 mapped address cases
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_proto.c,v 1.21 2000/05/25 01:22:00 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d303 2
a304 1
struct timeval icmp6errratelim = { 0, 1000 };	/* 1000usec = 1msec */
@


1.21
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.20 2000/05/22 10:32:52 itojun Exp $	*/
d128 1
a128 1
 udp6_usrreq,	0,
@


1.20
log
@use ratecheck(9) for ICMPv6 rate limitation.  sync with netbsd-current.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.19 2000/02/28 16:40:39 itojun Exp $	*/
a272 5
#if NGIF > 0
int	ip6_gif_hlim = GIF_HLIM;
#else
int	ip6_gif_hlim = 0;
#endif
@


1.19
log
@- check raw socket icmp6 filter only if the packet is icmp6.
- allow setting raw socket icmp6 filter only if it is IPPROTO_ICMPV6 socket.
	(cmetz may object about above two items...)
- add rip6_ctlinput, to flush cached router properly on redirects.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.18 2000/02/28 11:55:22 itojun Exp $	*/
d307 1
a307 1
u_int	icmp6errratelim = 1000;		/* 1000usec = 1msec */
@


1.18
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.17 2000/02/07 06:09:10 itojun Exp $	*/
d152 1
a152 1
  rip6_input,	rip6_output,	0,		rip6_ctloutput,
@


1.17
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.16 2000/02/02 17:01:51 itojun Exp $ */
@


1.17.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d152 1
a152 1
  rip6_input,	rip6_output,	rip6_ctlinput,	rip6_ctloutput,
@


1.17.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6_proto.c,v 1.27 2001/04/06 04:42:09 csapuntz Exp $	*/
/*	$KAME: in6_proto.c,v 1.66 2000/10/10 15:35:47 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d111 2
d128 1
a128 1
  udp6_usrreq,	0,
d132 8
d143 2
a144 2
#ifdef INET	/* don't call initialization and timeout routines twice */
  0,		0,		0,		tcp_drain,
d150 1
d273 5
d307 1
a307 2
struct timeval icmp6errratelim = { 0, 0 };	/* no ratelimit */
int	icmp6errppslim = 100;		/* 100pps */
d309 75
@


1.17.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.17.2.2 2001/05/14 22:40:18 niklas Exp $	*/
d110 2
d125 1
a125 1
{ SOCK_DGRAM,	&inet6domain,	IPPROTO_UDP,	PR_ATOMIC|PR_ADDR,
d131 1
a131 1
{ SOCK_STREAM,	&inet6domain,	IPPROTO_TCP,	PR_CONNREQUIRED|PR_WANTRCVD|PR_ABRTACPTDIS,
d141 1
a141 1
{ SOCK_RAW,	&inet6domain,	IPPROTO_RAW,	PR_ATOMIC|PR_ADDR,
d146 1
a146 1
{ SOCK_RAW,	&inet6domain,	IPPROTO_ICMPV6,	PR_ATOMIC|PR_ADDR,
d222 1
a222 1
{ SOCK_RAW,	&inet6domain,	0,		PR_ATOMIC|PR_ADDR,
@


1.17.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.17.2.3 2001/07/04 10:55:21 niklas Exp $	*/
d178 1
d183 1
a183 1
  ipcomp_sysctl,
d185 1
@


1.17.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d187 2
a188 2
  in6_gif_input, rip6_output,	 	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
d192 3
a194 3
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  in6_gif_input, rip6_output, 	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
d199 4
a202 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV6,	PR_ATOMIC|PR_ADDR,
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,		ipip_sysctl
d205 4
a208 4
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
  ip4_input6,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,	/* XXX */
  0,		0,		0,		0,
d212 2
a213 2
{ SOCK_RAW,	&inet6domain,	IPPROTO_PIM,	PR_ATOMIC|PR_ADDR,
  pim6_input,	rip6_output,	0,		rip6_ctloutput, 
d215 1
a215 1
  0,		0,		0,		0,
@


1.17.2.6
log
@Sync the SMP branch with 3.3
@
text
@d145 1
a145 1
  icmp6_input,	rip6_output,	rip6_ctlinput,	rip6_ctloutput,
d152 1
a152 1
  0,
d157 1
a157 1
  0,
d162 1
a162 1
  0,
d168 1
a168 1
  0,
d174 1
a174 1
  0,
d180 1
a180 1
  0,
d213 1
a213 1
  pim6_input,	rip6_output,	0,		rip6_ctloutput,
d226 1
a226 1
    { AF_INET6, "internet6", 0, 0, 0,
d231 1
a231 2
      sizeof(struct sockaddr_in6),
      in6_domifattach, in6_domifdetach, };
a253 1
int	ip6_maxfrags = 200;
a261 1
const int ip6_v6only = 1;
d273 1
@


1.17.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_proto.c,v 1.17.2.6 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.17.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a105 5
#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

a212 7
#if NCARP > 0
{ SOCK_RAW,	&inet6domain,	IPPROTO_CARP,	PR_ATOMIC|PR_ADDR,
  carp6_input,	rip6_output,	0,		rip6_ctloutput,
  rip6_usrreq,
  0,		0,		0,		0,		carp_sysctl
},
#endif /* NCARP */
d241 4
d246 1
a246 1
int	ip6_sendredirects = 1;
@


1.17.2.9
log
@Merge with the trunk
@
text
@a72 3
#ifndef SMALL_KERNEL
#include <net/radix_mpath.h>
#endif
a236 3
#ifndef SMALL_KERNEL
      rn_mpath_inithead,
#else
a237 1
#endif
@


1.16
log
@remove never-visited code (#ifdef MAPPED_ADDR_ENABLED)
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.15 2000/01/23 03:51:03 angelos Exp $ */
d84 1
a84 1
#include <netinet6/ip6.h>
d86 1
a86 1
#include <netinet6/icmp6.h>
@


1.15
log
@ip4_input -> ip4_input6, and fix typo in comment
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.14 2000/01/21 03:15:06 angelos Exp $ */
a280 4
#ifdef MAPPED_ADDR_ENABLED
int	ip6_mapped_addr_on = 1;
#endif /* MAPPED_ADDR_ENABLED */

@


1.14
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.13 2000/01/13 06:01:22 angelos Exp $ */
d212 1
a212 1
#else /* NFIG */
d220 1
a220 1
  ip4_input,   rip6_output,     0,              rip6_ctloutput,
@


1.13
log
@We do need netinet/ip_ip4.h after all...
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.12 2000/01/13 05:06:12 angelos Exp $ */
d96 1
a96 1
#include <netinet/ip_ip4.h>
d200 1
a200 1
{ SOCK_RAW,	&inet6domain,	IPPROTO_IPV4,	PR_ATOMIC|PR_ADDR,
d205 1
a205 1
#ifdef INET6
d211 1
a211 1
#endif /* INET6 */
d213 1
a213 1
{ SOCK_RAW,     &inet6domain,    IPPROTO_IPV4,  PR_ATOMIC|PR_ADDR,
d216 1
a216 1
  0,            0,              0,              0,              ip4_sysctl
d218 3
a220 3
#ifdef INET6
{ SOCK_RAW,     &inet6domain,    IPPROTO_IPV6,  PR_ATOMIC|PR_ADDR,
  ip4_input6,   rip6_output,     0,              rip6_ctloutput,
d224 1
a224 1
#endif /* INET6 */
@


1.12
log
@Align.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.11 2000/01/13 04:59:38 angelos Exp $ */
d96 1
@


1.11
log
@Introduce ip4_input6() with the correct prototype...
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.10 2000/01/13 04:09:00 angelos Exp $ */
d213 1
a213 1
  ip4_input6,    rip6_output,     0,              rip6_ctloutput,
d219 1
a219 1
  ip4_input6,    rip6_output,     0,              rip6_ctloutput,
@


1.10
log
@Add include file fixing non-gif inet6 kernels.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.9 2000/01/12 06:35:04 angelos Exp $ */
a92 3
#include <netinet/ip_ip4.h>

#ifdef IPSEC
a95 1
#endif /* IPSEC */
d213 1
a213 1
  ip4_input,    rip6_output,     0,              rip6_ctloutput,
d219 1
a219 1
  ip4_input,    rip6_output,     0,              rip6_ctloutput,
@


1.9
log
@Use netinet/ip_ip4.c routines.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.8 2000/01/02 11:09:20 angelos Exp $ */
d93 1
@


1.8
log
@Replace references to ipsec6_sysctl (code is not yet compiled in)
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.7 2000/01/02 04:52:26 itojun Exp $ */
d94 6
a103 2
#undef IPSEC

d212 13
@


1.7
log
@implement net.inet6.icmp6.nodeinfo sysctl, which disables
ICMPv6 node information query (and FQDN query - old variant).

kame repository has the change as well.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.6 1999/12/10 10:04:28 angelos Exp $ */
d180 1
a180 1
  ipsec6_sysctl,
d186 1
a186 1
  ipsec6_sysctl,
d188 1
d195 1
@


1.6
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/* $OpenBSD: in6_proto.c,v 1.5 1999/12/10 08:53:17 angelos Exp $ */
d295 1
@


1.5
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a66 7
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a68 3
#if defined(__FreeBSD__)
#include <sys/socketvar.h>
#endif
a72 4
#ifdef __FreeBSD__
#include <sys/systm.h>
#include <sys/sysctl.h>
#endif
a80 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || (defined(__NetBSD__) && !defined(TCP6)) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a82 2
#endif
#if (defined(__NetBSD__) && !defined(TCP6)) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a83 1
#endif
a86 3
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3) && !defined(__OpenBSD__) && !(defined(__bsdi__) && _BSDI_VERSION >= 199802)
#include <netinet6/in6_pcb.h>
#endif
a87 1
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
a92 22
#else
#if defined(__NetBSD__) && !defined(TCP6)
#include <netinet/tcp.h>
#include <netinet/tcp_fsm.h>
#include <netinet/tcp_seq.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/tcpip.h>
#include <netinet/tcp_debug.h>
#else
#include <netinet6/tcp6.h>
#include <netinet6/tcp6_fsm.h>
#include <netinet6/tcp6_seq.h>
#include <netinet6/tcp6_timer.h>
#include <netinet6/tcp6_var.h>
#endif
#endif

#if !defined(__OpenBSD__) && !(defined(__bsdi__) && _BSDI_VERSION >= 199802)
#include <netinet6/udp6.h>
#include <netinet6/udp6_var.h>
#endif
a96 3
#ifdef __FreeBSD__
#include <netinet6/in6_prefix.h>
#endif
a97 1
#ifdef __OpenBSD__ /*KAME IPSEC*/
a98 10
#endif

#ifdef IPSEC
#include <netinet6/ipsec.h>
#include <netinet6/ah.h>
#ifdef IPSEC_ESP
#include <netinet6/esp.h>
#endif
#include <netinet6/ipcomp.h>
#endif /*IPSEC*/
a115 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static struct pr_usrreqs nousrreqs;
#endif
a121 1
#ifndef __FreeBSD__
a122 5
#else
# if __FreeBSD__ >= 3
  &nousrreqs,
# endif
#endif
a125 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
 0, 0,
#elif defined(HAVE_NRL_INPCB)
a126 3
#else
 udp6_usrreq,	udp6_init,
#endif
a127 2
#ifndef __FreeBSD__
#ifdef HAVE_NRL_INPCB
a128 8
#else
  udp6_sysctl,
#endif
#else
# if __FreeBSD__ >= 3
  &udp6_usrreqs,
# endif
#endif
a134 1
#ifndef __FreeBSD__
a135 5
#else
# if __FreeBSD__ >= 3
  &tcp6_usrreqs,
# endif
#endif
a139 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  0,
#elif defined(HAVE_NRL_INPCB)
a140 3
#else
  tcp_usrreq,
#endif
a145 1
#ifndef __FreeBSD__
a146 5
#else
# if __FreeBSD__ >= 3
  &tcp6_usrreqs,
# endif
#endif
a150 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  0,
#else
a151 1
#endif
a152 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &rip6_usrreqs
#endif
a155 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  0,
#else
a156 1
#endif
a157 1
#ifndef __FreeBSD__
a158 5
#else
# if __FreeBSD__ >= 3
  &rip6_usrreqs
# endif
#endif
a163 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &nousrreqs
#endif
a168 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &nousrreqs
#endif
a173 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &nousrreqs
#endif
a179 1
#ifndef __FreeBSD__
a180 5
#else
# if __FreeBSD__ >= 3
  &nousrreqs,
# endif
#endif
a181 1
#ifdef IPSEC_ESP
a185 1
#ifndef __FreeBSD__
a186 5
#else
# if __FreeBSD__ >= 3
  &nousrreqs,
# endif
#endif
a187 1
#endif
a191 1
#ifndef __FreeBSD__
a192 5
#else
# if __FreeBSD__ >= 3
  &nousrreqs,
# endif
#endif
a199 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &nousrreqs
#endif
a205 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &nousrreqs
#endif
a210 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  0,
#else
a211 1
#endif
a212 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &rip6_usrreqs
# endif
a216 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  0, 0,
#else
a217 1
#endif
a218 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
  &rip6_usrreqs
#endif
a221 4
#ifdef __FreeBSD__
extern int in6_inithead __P((void **, int));
#endif

a225 3
#ifdef __FreeBSD__
      in6_inithead,
#else
a226 1
#endif
a229 4
#ifdef __FreeBSD__
DOMAIN_SET(inet6);
#endif

a272 1
#ifndef __bsdi__
a279 1
#endif
a374 162

#ifdef __FreeBSD__
/*
 * sysctl related items.
 */
SYSCTL_NODE(_net,	PF_INET6,	inet6,	CTLFLAG_RW,	0,
	"Internet6 Family");

/* net.inet6 */
SYSCTL_NODE(_net_inet6,	IPPROTO_IPV6,	ip6,	CTLFLAG_RW, 0,	"IP6");
SYSCTL_NODE(_net_inet6,	IPPROTO_ICMPV6,	icmp6,	CTLFLAG_RW, 0,	"ICMP6");
SYSCTL_NODE(_net_inet6,	IPPROTO_UDP,	udp6,	CTLFLAG_RW, 0,	"UDP6");
SYSCTL_NODE(_net_inet6,	IPPROTO_TCP,	tcp6,	CTLFLAG_RW, 0,	"TCP6");
#ifdef IPSEC
SYSCTL_NODE(_net_inet6,	IPPROTO_ESP,	ipsec6,	CTLFLAG_RW, 0,	"IPSEC6");
#endif /* IPSEC */

/* net.inet6.ip6 */
static int
sysctl_ip6_forwarding SYSCTL_HANDLER_ARGS
{
	int error = 0;
	int old_ip6_forwarding;
	int changed;

	error = SYSCTL_OUT(req, arg1, sizeof(int));
	if (error || !req->newptr)
		return (error);
	old_ip6_forwarding = ip6_forwarding;
	error = SYSCTL_IN(req, arg1, sizeof(int));
	if (error != 0)
		return (error);
	changed = (ip6_forwarding ? 1 : 0) ^ (old_ip6_forwarding ? 1 : 0);
	if (changed == 0)
		return (error);
	if (ip6_forwarding != 0) {	/* host becomes router */
		int s = splnet();
		struct nd_prefix *pr, *next;

		for (pr = nd_prefix.lh_first; pr; pr = next) {
			next = pr->ndpr_next;
			if (!IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
				in6_ifdel(pr->ndpr_ifp, &pr->ndpr_addr);
			prelist_remove(pr);
		}
		splx(s);
	} else {			/* router becomes host */
		struct socket so;

		/* XXX: init dummy so */
		bzero(&so, sizeof(so));
		while(!LIST_EMPTY(&rr_prefix))
			delete_each_prefix(&so, LIST_FIRST(&rr_prefix),
					   PR_ORIG_KERNEL);
	}

	return (error);
}

SYSCTL_OID(_net_inet6_ip6, IPV6CTL_FORWARDING, forwarding,
	   CTLTYPE_INT|CTLFLAG_RW, &ip6_forwarding, 0, sysctl_ip6_forwarding,
	   "I", "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_SENDREDIRECTS,
	redirect, CTLFLAG_RW,		&ip6_sendredirects,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_DEFHLIM,
	hlim, CTLFLAG_RW,		&ip6_defhlim,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_MAXFRAGPACKETS,
	maxfragpackets, CTLFLAG_RW,	&ip6_maxfragpackets,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_ACCEPT_RTADV,
	accept_rtadv, CTLFLAG_RW,	&ip6_accept_rtadv,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_KEEPFAITH,
	keepfaith, CTLFLAG_RW,		&ip6_keepfaith,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_LOG_INTERVAL,
	log_interval, CTLFLAG_RW,	&ip6_log_interval,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_HDRNESTLIMIT,
	hdrnestlimit, CTLFLAG_RW,	&ip6_hdrnestlimit,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_DAD_COUNT,
	dad_count, CTLFLAG_RW,	&ip6_dad_count,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_AUTO_FLOWLABEL,
	auto_flowlabel, CTLFLAG_RW,	&ip6_auto_flowlabel,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_DEFMCASTHLIM,
	defmcasthlim, CTLFLAG_RW,	&ip6_defmcasthlim,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_GIF_HLIM,
	gifhlim, CTLFLAG_RW,	&ip6_gif_hlim,			0, "");
SYSCTL_STRING(_net_inet6_ip6, IPV6CTL_KAME_VERSION,
	kame_version, CTLFLAG_RD,	__KAME_VERSION,		0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_USE_DEPRECATED,
	use_deprecated, CTLFLAG_RW,	&ip6_use_deprecated,	0, "");
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_RR_PRUNE,
	rr_prune, CTLFLAG_RW,	&ip6_rr_prune,			0, "");
#ifdef MAPPED_ADDR_ENABLED
SYSCTL_INT(_net_inet6_ip6, IPV6CTL_MAPPED_ADDR,
	mapped_addr, CTLFLAG_RW,	&ip6_mapped_addr_on,	0, "");
#endif /* MAPPED_ADDR_ENABLED */

/* net.inet6.icmp6 */
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_REDIRACCEPT,
	rediraccept, CTLFLAG_RW,	&icmp6_rediraccept,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_REDIRTIMEOUT,
	redirtimeout, CTLFLAG_RW,	&icmp6_redirtimeout,	0, "");
SYSCTL_STRUCT(_net_inet6_icmp6, ICMPV6CTL_STATS, stats, CTLFLAG_RD,
	&icmp6stat, icmp6stat, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ERRRATELIMIT,
	errratelimit, CTLFLAG_RW,	&icmp6errratelim,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_PRUNE,
	nd6_prune, CTLFLAG_RW,		&nd6_prune,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_DELAY,
	nd6_delay, CTLFLAG_RW,		&nd6_delay,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_UMAXTRIES,
	nd6_umaxtries, CTLFLAG_RW,	&nd6_umaxtries,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_MMAXTRIES,
	nd6_mmaxtries, CTLFLAG_RW,	&nd6_mmaxtries,	0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_USELOOPBACK,
	nd6_useloopback, CTLFLAG_RW,	&nd6_useloopback, 0, "");
SYSCTL_INT(_net_inet6_icmp6, ICMPV6CTL_ND6_PROXYALL,
	nd6_proxyall, CTLFLAG_RW,	&nd6_proxyall, 0, "");

#if __FreeBSD__ < 3
/* net.inet6.udp6 */
SYSCTL_INT(_net_inet6_udp6, UDP6CTL_SENDMAX,
	sendmax, CTLFLAG_RW,	&udp6_sendspace,	0, "");
SYSCTL_INT(_net_inet6_udp6, UDP6CTL_RECVSPACE,
	recvspace, CTLFLAG_RW,	&udp6_recvspace,	0, "");

/* net.inet6.tcp6 */
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_MSSDFLT,
	mssdflt, CTLFLAG_RW,	&tcp6_mssdflt, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_DO_RFC1323,
	do_rfc1323, CTLFLAG_RW,	&tcp6_do_rfc1323, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_KEEPIDLE,
	keepidle, CTLFLAG_RW,	&tcp6_keepidle, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_KEEPINTVL,
	keepintvl, CTLFLAG_RW,	&tcp6_keepintvl, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_KEEPCNT,
	keepcnt, CTLFLAG_RW,	&tcp6_keepcnt, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_MAXPERSISTIDLE,
	maxpersistidle, CTLFLAG_RW,	&tcp6_maxpersistidle, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_SENDSPACE,
	sendspace, CTLFLAG_RW,	&tcp6_sendspace, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_RECVSPACE,
	recvspace, CTLFLAG_RW,	&tcp6_recvspace, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_CONNTIMEO,
	conntimeo, CTLFLAG_RW,	&tcp6_conntimeo, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_PMTU,
	pmtu, CTLFLAG_RW,	&tcp6_pmtu, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_PMTU_EXPIRE,
	pmtu_expire, CTLFLAG_RW,	&pmtu_expire, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_PMTU_PROBE,
	pmtu_probe, CTLFLAG_RW,	&pmtu_probe, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_43MAXSEG,
	pmtu_43maxseg, CTLFLAG_RW,	&tcp6_43maxseg, 0, "");
SYSCTL_STRUCT(_net_inet6_tcp6, TCP6CTL_STATS, stats, CTLFLAG_RD,
	&tcp6stat, tcp6stat, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_SYN_CACHE_LIMIT,
	syn_cache_limit, CTLFLAG_RW,	&tcp6_syn_cache_limit, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_SYN_BUCKET_LIMIT,
	syn_bucket_limit, CTLFLAG_RW,	&tcp6_syn_bucket_limit, 0, "");
SYSCTL_INT(_net_inet6_tcp6, TCP6CTL_SYN_CACHE_INTER,
	syn_cache_interval, CTLFLAG_RW, &tcp6_syn_cache_interval, 0, "");
#endif /* !(defined(__FreeBSD__) && __FreeBSD__ >= 3) */

#endif /* __FreeBSD__ */
@


1.4
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 2
@


1.3
log
@Demangled the INET6 stuff so as not to require any extra options and not to
be mutually exclusive with the IPSEC option.
@
text
@d2 69
a70 8
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
a71 1
*/
d74 3
d81 4
d87 1
a88 1
#include <net/radix.h>
d92 2
d96 2
d99 12
d113 2
a114 1

a118 3
/* #include <netinet/tcpip.h> */
#if __FreeBSD__ && defined(_NETINET_IN_PCB_H_)
#undef _NETINET_IN_PCB_H_
a119 4
#define _NETINET_IN_PCB_H_
#else /* __FreeBSD__ */
#include <netinet/tcp_var.h>
#endif /* __FreeBSD__ */
d122 8
d131 4
a134 5
#include <netinet6/in6.h>
#include <netinet6/in6_var.h>
#include <netinet6/ipv6.h>
#include <netinet6/ipv6_var.h>
#include <netinet6/ipv6_icmp.h>
d136 8
a143 1
#if __OpenBSD__
d145 1
a145 4
#ifdef NRL_IPSEC
#define IPSEC 1
#endif /* NRL_IPSEC */
#endif /* __OpenBSD__ */
d148 14
a161 3
#include <sys/osdep.h>
#include <netsec/ipsec.h>
#endif /* IPSEC */
d163 1
a163 3
#if __FreeBSD__
#include <sys/sysctl.h>
#endif /* __FreeBSD__ */
d165 1
a165 1
extern struct domain inet6domain;
d167 3
a169 1
#define CAST (void *)
d171 4
a174 92
#if !__FreeBSD__
struct protosw inet6sw[] = {
/* normal protocol switch */
  {
    0, &inet6domain, 0, 0,    /* NOTE:  This 0 is the same as IPPROTO_HOPOPTS,
				 but we specially demux IPPROTO_HOPOPTS
				 in ipv6_input(). */
    CAST ipv6_hop, CAST ipv6_output, 0, 0, /* Watch for hop-by-hop input! */
    0,
    ipv6_init, 0, ipv6_slowtimo, ipv6_drain, ipv6_sysctl
  },

  /* ICMPv6 entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_ICMPV6, PR_ATOMIC|PR_ADDR,
    CAST ipv6_icmp_input, CAST ipv6_icmp_output, 0, ripv6_ctloutput,
    ipv6_icmp_usrreq,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, ipv6_icmp_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },

  /* IPv6-in-IPv6 tunnel entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_IPV6, PR_ATOMIC|PR_ADDR,
    CAST ipv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    ripv6_usrreq,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, ipv6_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },

  /* IPv4-in-IPv6 tunnel entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_IPV4, PR_ATOMIC|PR_ADDR,
    CAST ipv4_input, 0, 0, 0,
    0,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, ip_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },

  /* Fragment entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_FRAGMENT, PR_ATOMIC|PR_ADDR,
    CAST ipv6_reasm, 0, 0, 0,
    0,
    0, 0, 0, 0, 0
  },


  /* UDP entry */

  /*
   * Eventually, that ipv6_ctloutput() will have to be replaced with a
   * udp_ctloutput(), which knows whether or not to redirect things down to
   * IP or IPv6 appropriately.
   */

  {
    SOCK_DGRAM, &inet6domain, IPPROTO_UDP, PR_ATOMIC|PR_ADDR,
    CAST udp_input, 0, CAST udp_ctlinput, ipv6_ctloutput,
    udp_usrreq,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, udp_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },

  /* TCP entry */

  {
    SOCK_STREAM, &inet6domain, IPPROTO_TCP, PR_CONNREQUIRED|PR_WANTRCVD,
    CAST tcp_input, 0, CAST tcp_ctlinput, tcp_ctloutput,
    tcp_usrreq,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, tcp_sysctl /* init, fasttimo, etc. in v4 protosw already! */
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0  /* init, fasttimo, etc. in v4 protosw already! */
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },
d176 124
d301 12
a312 12
  /* IPv6 & IPv4 Authentication Header */
  {
    SOCK_RAW, &inet6domain, IPPROTO_AH, PR_ATOMIC|PR_ADDR,
    CAST ipsec_ah_input, 0, 0, 0,
    0,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, ipsec_ah_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },

d314 25
a338 12
  /* IPv6 & IPv4 Encapsulating Security Payload Header */
  {
    SOCK_RAW, &inet6domain, IPPROTO_ESP, PR_ATOMIC|PR_ADDR,
    CAST ipsec_esp_input, 0, 0, 0,
    0,
#if defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802
    0, 0, 0, 0, ipsec_esp_sysctl
#else /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
    0, 0, 0, 0, 0
#endif /* defined(_BSDI_VERSION) && _BSDI_VERSION >= 199802 */
  },
#endif /* IPSEC_ESP */
d340 50
d391 11
a401 1
  /* Unknown header. */
d403 3
a405 94
  {
    SOCK_RAW, &inet6domain, IPPROTO_RAW, PR_ATOMIC|PR_ADDR,
    CAST ripv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    ripv6_usrreq,
    0,0,0,0,0
  },

  /* Raw wildcard */
  {
    SOCK_RAW, &inet6domain, 0, PR_ATOMIC|PR_ADDR,
    CAST ripv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    ripv6_usrreq,
    ripv6_init,0,0,0,0
  },
};
#else /* !__FreeBSD__ */
extern struct pr_usrreqs nousrreqs;
struct protosw inet6sw[] = {
  {
    0, &inet6domain, 0, 0,    /* NOTE:  This 0 is the same as IPPROTO_HOPOPTS,
				 but we specially demux IPPROTO_HOPOPTS
				 in ipv6_input(). */
    CAST ipv6_hop, CAST ipv6_output, 0, 0, /* Watch for hop-by-hop input! */
    0,
    ipv6_init, 0, ipv6_slowtimo, ipv6_drain, 
    &nousrreqs
  },

  /* ICMPv6 entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_ICMPV6, PR_ATOMIC|PR_ADDR,
    CAST ipv6_icmp_input, CAST ipv6_icmp_output, 0, CAST ripv6_ctloutput,
    0,
    0, 0, 0, 0,
    &ipv6_icmp_usrreqs,
  },

  /* IPv6-in-IPv6 tunnel entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_IPV6, PR_ATOMIC|PR_ADDR,
    CAST ipv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    0,
    0, 0, 0, 0,
    &ripv6_usrreqs
  },

  /* IPv4-in-IPv6 tunnel entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_IPV4, PR_ATOMIC|PR_ADDR,
    CAST ipv4_input, 0, 0, 0,
    0,
    0, 0, 0, 0,
    &nousrreqs
  },

  /* Fragment entry */

  {
    SOCK_RAW, &inet6domain, IPPROTO_FRAGMENT, PR_ATOMIC|PR_ADDR,
    CAST ipv6_reasm, 0, 0, 0,
    0,
    0, 0, 0, 0,
    &nousrreqs
  },


  /* UDP entry */

  /*
   * Eventually, that ipv6_ctloutput() will have to be replaced with a
   * udp_ctloutput(), which knows whether or not to redirect things down to
   * IP or IPv6 appropriately.
   */

  {
    SOCK_DGRAM, &inet6domain, IPPROTO_UDP, PR_ATOMIC|PR_ADDR,
    CAST udp_input, 0, CAST udp_ctlinput, ipv6_ctloutput,
    0,
    udp_init, 0, 0, 0,
    &udp_usrreqs
  },

  /* TCP entry */

  {
    SOCK_STREAM, &inet6domain, IPPROTO_TCP, PR_CONNREQUIRED|PR_WANTRCVD,
    CAST tcp_input, 0, CAST tcp_ctlinput, tcp_ctloutput,
    0,
    tcp_init,	tcp_fasttimo,	tcp_slowtimo,	tcp_drain, 
    &tcp_usrreqs,
  },
d407 10
a416 9
#ifdef IPSEC
  /* IPv6 & IPv4 Authentication Header */
  {
    SOCK_RAW, &inet6domain, IPPROTO_AH, PR_ATOMIC|PR_ADDR,
    CAST ipsec_ah_input, 0, 0, 0,
    0,
    0, 0, 0, 0,
    &nousrreqs
  },
d418 3
a420 11
#ifdef IPSEC_ESP
  /* IPv6 & IPv4 Encapsulating Security Payload Header */
  {
    SOCK_RAW, &inet6domain, IPPROTO_ESP, PR_ATOMIC|PR_ADDR,
    CAST ipsec_esp_input, 0, 0, 0,
    0,
    0, 0, 0, 0,
    &nousrreqs
  },
#endif /* IPSEC_ESP */
#endif /* IPSEC */
d422 37
a458 1
  /* Unknown header. */
d460 85
a544 17
  {
    SOCK_RAW, &inet6domain, IPPROTO_RAW, PR_ATOMIC|PR_ADDR,
    CAST ripv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    0,
    0,0,0,0,
    &ripv6_usrreqs
  },

  /* Raw wildcard */
  {
    SOCK_RAW, &inet6domain, 0, PR_ATOMIC|PR_ADDR,
    CAST ripv6_input, CAST ripv6_output, 0, ripv6_ctloutput,
    0,
    ripv6_init,0,0,0,
    &ripv6_usrreqs,
  },
};
d546 24
a569 1
#endif /* !__FreeBSD__ */
d571 3
a573 2
#if !__FreeBSD__
struct domain inet6domain =
d575 139
a713 29
  PF_INET6, "IPv6", 0, 0, 0,
  inet6sw, &inet6sw[sizeof(inet6sw)/sizeof(inet6sw[0])], 0,
  /*
   * FreeBSD's IPv4 replaces rn_inithead() with an IPv4-specific function.
   * Our IPv6 uses the ifa->ifa_rtrequest() function pointer to intercept
   * rtrequest()s.  The consequence of this is that we use the generic
   * rn_inithead().
   */
  rn_inithead, 64, sizeof(struct sockaddr_in6)
};
#else /* !__FreeBSD__ */
struct domain inet6domain =
{
  PF_INET6, "IPv6", 0, 0, 0,
  inet6sw, &inet6sw[sizeof(inet6sw)/sizeof(inet6sw[0])], 0,
  /*
   * FreeBSD's IPv4 replaces rn_inithead() with an IPv4-specific function.
   * Our IPv6 uses the ifa->ifa_rtrequest() function pointer to intercept
   * rtrequest()s.  The consequence of this is that we use the generic
   * rn_inithead().
   */
  rn_inithead, 64, sizeof(struct sockaddr_in6)
};

DOMAIN_SET(inet6);
#endif /* !__FreeBSD__ */

/* Eventually, make these go away -- if you want to be a router, twiddle the
   sysctls before bringing up your interfaces */
a714 28
#ifndef IPV6FORWARDING
#ifdef IPV6GATEWAY
#define IPV6FORWARDING 1
#else
#define IPV6FORWARDING 0
#endif /* IPV6GATEWAY */
#endif /* IPV6FORWARDING */

#ifndef IPV6RSOLICIT
#if IPV6FORWARDING
#define IPV6RSOLICIT 0
#else /* IPV6FORWARDING */
#define IPV6RSOLICIT 1
#endif /* IPV6FORWARDING */
#endif /* IPV6RSOLICIT */

#ifndef	IFQMAXLEN
#define	IFQMAXLEN	IFQ_MAXLEN
#endif

int ipv6forwarding = IPV6FORWARDING;
int ipv6rsolicit = IPV6RSOLICIT;
int ipv6_defhoplmt = MAXHOPLIMIT;
int ipv6qmaxlen = IFQMAXLEN;

#if __FreeBSD__
SYSCTL_NODE(_net_inet, IPPROTO_IPV6,      ipv6,     CTLFLAG_RW, 0,  "IPV6");
SYSCTL_NODE(_net_inet, IPPROTO_ICMPV6,    icmpv6,   CTLFLAG_RW, 0,  "ICMPV6");
@


1.2
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d52 8
a59 1
#if defined(IPSEC) || defined(NRL_IPSEC)
d62 1
a62 1
#endif /* defined(IPSEC) || defined(NRL_IPSEC) */
d165 1
a165 1
#if defined(IPSEC) || defined(NRL_IPSEC)
d191 1
a191 1
#endif /* defined(IPSEC) || defined(NRL_IPSEC) */
d290 1
a290 1
#if defined(IPSEC) || defined(NRL_IPSEC)
d310 1
a310 1
#endif /* defined(IPSEC) || defined(NRL_IPSEC) */
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@d35 1
a35 1
#include <netinet/tcpip.h>
d53 1
@

