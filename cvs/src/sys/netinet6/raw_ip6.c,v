head	1.119;
access;
symbols
	OPENBSD_6_2:1.119.0.2
	OPENBSD_6_2_BASE:1.119
	OPENBSD_6_1:1.108.0.4
	OPENBSD_6_1_BASE:1.108
	OPENBSD_6_0:1.93.0.2
	OPENBSD_6_0_BASE:1.93
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.79.0.4
	OPENBSD_5_8_BASE:1.79
	OPENBSD_5_7:1.73.0.2
	OPENBSD_5_7_BASE:1.73
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.45.0.2
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.44.0.4
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.2
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.40.0.4
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.38.0.2
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.28.0.8
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.28.0.6
	OPENBSD_3_8_BASE:1.28
	OPENBSD_3_7:1.28.0.4
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.28.0.2
	OPENBSD_3_6_BASE:1.28
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.17
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2;
locks; strict;
comment	@ * @;


1.119
date	2017.09.05.07.59.11;	author mpi;	state Exp;
branches;
next	1.118;
commitid	fWUv1bxRFYaflFag;

1.118
date	2017.09.01.15.05.31;	author mpi;	state Exp;
branches;
next	1.117;
commitid	gLJLYG7mRiAwqMZc;

1.117
date	2017.08.15.17.47.15;	author bluhm;	state Exp;
branches;
next	1.116;
commitid	dSbcCL1yFsQLdA8Q;

1.116
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.115;
commitid	ZSLEQCt6cCaCd9uI;

1.115
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.114;
commitid	gZMpLuRopIsWa0cT;

1.114
date	2017.05.13.17.44.00;	author bluhm;	state Exp;
branches;
next	1.113;
commitid	LlinWyj25ZZK7F58;

1.113
date	2017.05.08.08.46.39;	author rzalamena;	state Exp;
branches;
next	1.112;
commitid	ffGuaP6j4fxaZcHM;

1.112
date	2017.05.06.16.35.59;	author bluhm;	state Exp;
branches;
next	1.111;
commitid	4joNA7ZeyQbD54QR;

1.111
date	2017.04.19.15.44.45;	author bluhm;	state Exp;
branches;
next	1.110;
commitid	vhVfmw1Ka999L46J;

1.110
date	2017.04.17.21.10.03;	author bluhm;	state Exp;
branches;
next	1.109;
commitid	IZDEH9AkzvBeFUK2;

1.109
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.108;
commitid	00hB28wQPwG5Ysk0;

1.108
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.107;
commitid	ZsxSSZJSFxZH81LL;

1.107
date	2017.03.03.15.48.02;	author bluhm;	state Exp;
branches;
next	1.106;
commitid	LtQeAWkATeJFPv2t;

1.106
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.105;
commitid	1ap8YFU49Zg4mM41;

1.105
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.104;
commitid	2R0NOjEDy2jGtnjL;

1.104
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.103;
commitid	UBL7uwpXqTP4EWIu;

1.103
date	2017.01.23.16.31.24;	author bluhm;	state Exp;
branches;
next	1.102;
commitid	9EAe7cRTLFNc3XTC;

1.102
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.101;
commitid	xP9gcRskiS0BKnO6;

1.101
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.100;
commitid	T2qzeepA7r1EGy1x;

1.100
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.99;
commitid	QqHqT2WhCBWqYgGJ;

1.99
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.98;
commitid	wuzpseLx3Ntn9R7b;

1.98
date	2016.10.25.19.40.57;	author florian;	state Exp;
branches;
next	1.97;
commitid	pasPFdWxigkoibtn;

1.97
date	2016.10.25.06.26.03;	author florian;	state Exp;
branches;
next	1.96;
commitid	wX0PQP0eAB4seb9f;

1.96
date	2016.09.19.18.09.09;	author tedu;	state Exp;
branches;
next	1.95;
commitid	3wAktwQDJ8hs7BVM;

1.95
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.94;
commitid	ZsKqEaqTKPu9hWk6;

1.94
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.93;
commitid	nbCHuHn2E9uBfKJT;

1.93
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.92;
commitid	Cm0qxR09oTCkXjXZ;

1.92
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.91;
commitid	jodmGXAB42f8N6nf;

1.91
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.90;
commitid	LxUFHuffW7GZZ01f;

1.90
date	2016.04.11.15.28.03;	author vgross;	state Exp;
branches;
next	1.89;
commitid	McqRgCKQHSyj2A4H;

1.89
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.88;
commitid	AZTNcVhJxOTcjeS6;

1.88
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.87;
commitid	Z6e4eqr6FuYFPnlL;

1.87
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.86;
commitid	djjKhPvMtRdFfuFJ;

1.86
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.85;
commitid	xFxvBxiFybIsZNMc;

1.85
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.84;
commitid	aMzCQ7pRC6VLKZyx;

1.84
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.83;
commitid	Cr0DVA7exR1t2zXg;

1.83
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.82;
commitid	sTEWfQrcV5GjIWc0;

1.82
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.81;
commitid	PcRGyy4jlpJbKkXz;

1.81
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.80;
commitid	MtXIH0WHmPXVgeDN;

1.80
date	2015.09.09.12.50.08;	author mpi;	state Exp;
branches;
next	1.79;
commitid	3dyjGr1P4z63tEd8;

1.79
date	2015.07.28.12.22.07;	author bluhm;	state Exp;
branches;
next	1.78;
commitid	HopFqP0BfcI2KM6j;

1.78
date	2015.07.28.11.44.51;	author bluhm;	state Exp;
branches;
next	1.77;
commitid	W3DYz4yMTVlERcN9;

1.77
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.76;
commitid	ncpqEGjDtSFuLAgn;

1.76
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.75;
commitid	J4OPNuggl4DOKGzM;

1.75
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.74;
commitid	h7z8lokZ0dFyuWpg;

1.74
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.73;
commitid	4Ro7ulidQXNcMvmM;

1.73
date	2015.03.04.11.10.55;	author mpi;	state Exp;
branches;
next	1.72;
commitid	qKIbFOrY1lWEYrPI;

1.72
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.71;
commitid	VK3ncyiP3NS1N4Sy;

1.71
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.70;
commitid	t9FBKDfc4VDxpEy2;

1.70
date	2014.11.09.22.05.08;	author bluhm;	state Exp;
branches;
next	1.69;
commitid	SqTYB83QZLRauhYQ;

1.69
date	2014.10.14.09.55.44;	author mpi;	state Exp;
branches;
next	1.68;
commitid	8H7cejP4S3KGbzuh;

1.68
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.67;
commitid	DQakU8LLWV6Iwx84;

1.67
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.66;
commitid	B4dZSbxas1X1IpXI;

1.66
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.65;

1.65
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2014.01.08.22.38.29;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2013.10.20.11.03.03;	author phessler;	state Exp;
branches;
next	1.59;

1.59
date	2013.10.17.16.27.47;	author bluhm;	state Exp;
branches;
next	1.58;

1.58
date	2013.06.04.19.11.52;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.31.15.04.25;	author bluhm;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.07.20.58.25;	author bluhm;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.01.22.51.39;	author bluhm;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.31.11.18.35;	author bluhm;	state Exp;
branches;
next	1.50;

1.50
date	2013.03.30.12.15.29;	author bluhm;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.44;

1.44
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.43;

1.43
date	2011.05.13.14.31.17;	author oga;	state Exp;
branches;
next	1.42;

1.42
date	2011.04.24.19.36.54;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.04.11.07.18;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.17.05.43.15;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.35;

1.35
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.29.16.19.24;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.01.00.52.39;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2004.08.23.01.30.30;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.12.04.58.48;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.11.14.27.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.11.08.09.29;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2004.04.22.18.01.15;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.03.14.08.54;	author espie;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2003.08.14.19.00.13;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.27.22.52.17;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.20.23.00.33;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.07.22.08.41;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.07.21.47.44;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.19.01.39.04;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.15.18.19.53;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.12.06.04.19.26;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.06.04.42.09;	author csapuntz;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.03.04.16.48.25;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.16.16.08.01;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.16.16.01.00;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.08.18.46.23;	author itojun;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.40.20;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.119
log
@Replace NET_ASSERT_LOCKED() by soassertlocked() in *_usrreq().

Not all of them need the NET_LOCK().

ok bluhm@@
@
text
@/*	$OpenBSD: raw_ip6.c,v 1.118 2017/09/01 15:05:31 mpi Exp $	*/
/*	$KAME: raw_ip6.c,v 1.69 2001/03/04 15:55:44 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)raw_ip.c	8.2 (Berkeley) 1/4/94
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/systm.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#ifdef MROUTING
#include <netinet6/ip6_mroute.h>
#endif
#include <netinet/icmp6.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6protosw.h>
#include <netinet6/raw_ip6.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#include <sys/stdarg.h>

/*
 * Raw interface to IP6 protocol.
 */

struct	inpcbtable rawin6pcbtable;

struct cpumem *rip6counters;

/*
 * Initialize raw connection block queue.
 */
void
rip6_init(void)
{
	in_pcbinit(&rawin6pcbtable, 1);
	rip6counters = counters_alloc(rip6s_ncounters);
}

int
rip6_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct inpcb *in6p;
	struct inpcb *last = NULL;
	struct sockaddr_in6 rip6src;
	struct mbuf *opts = NULL;

	KASSERT(af == AF_INET6);

	if (proto != IPPROTO_ICMPV6)
		rip6stat_inc(rip6s_ipackets);

	bzero(&rip6src, sizeof(rip6src));
	rip6src.sin6_len = sizeof(struct sockaddr_in6);
	rip6src.sin6_family = AF_INET6;
	/* KAME hack: recover scopeid */
	in6_recoverscope(&rip6src, &ip6->ip6_src);

	TAILQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
		if (in6p->inp_socket->so_state & SS_CANTRCVMORE)
			continue;
		if (!(in6p->inp_flags & INP_IPV6))
			continue;
		if ((in6p->inp_ipv6.ip6_nxt || proto == IPPROTO_ICMPV6) &&
		    in6p->inp_ipv6.ip6_nxt != proto)
			continue;
#if NPF > 0
		if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
			struct pf_divert *divert;

			/* XXX rdomain support */
			if ((divert = pf_find_divert(m)) == NULL)
				continue;
			if (IN6_IS_ADDR_UNSPECIFIED(&divert->addr.v6))
				goto divert_reply;
			if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6,
			    &divert->addr.v6))
				continue;
		} else
 divert_reply:
#endif
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_laddr6) &&
		    !IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, &ip6->ip6_dst))
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_faddr6) &&
		    !IN6_ARE_ADDR_EQUAL(&in6p->inp_faddr6, &ip6->ip6_src))
			continue;
		if (proto == IPPROTO_ICMPV6 && in6p->inp_icmp6filt) {
			struct icmp6_hdr *icmp6;

			IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, *offp,
			    sizeof(*icmp6));
			if (icmp6 == NULL)
				return IPPROTO_DONE;
			if (ICMP6_FILTER_WILLBLOCK(icmp6->icmp6_type,
			    in6p->inp_icmp6filt))
				continue;
		}
		if (proto != IPPROTO_ICMPV6 && in6p->inp_cksum6 != -1) {
			rip6stat_inc(rip6s_isum);
			if (in6_cksum(m, proto, *offp,
			    m->m_pkthdr.len - *offp)) {
				rip6stat_inc(rip6s_badsum);
				continue;
			}
		}
		if (last) {
			struct	mbuf *n;
			if ((n = m_copym(m, 0, M_COPYALL, M_NOWAIT)) != NULL) {
				if (last->inp_flags & IN6P_CONTROLOPTS)
					ip6_savecontrol(last, n, &opts);
				/* strip intermediate headers */
				m_adj(n, *offp);
				if (sbappendaddr(last->inp_socket,
				    &last->inp_socket->so_rcv,
				    sin6tosa(&rip6src), n, opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					m_freem(opts);
					rip6stat_inc(rip6s_fullsock);
				} else
					sorwakeup(last->inp_socket);
				opts = NULL;
			}
		}
		last = in6p;
	}
	if (last) {
		if (last->inp_flags & IN6P_CONTROLOPTS)
			ip6_savecontrol(last, m, &opts);
		/* strip intermediate headers */
		m_adj(m, *offp);
		if (sbappendaddr(last->inp_socket, &last->inp_socket->so_rcv,
		    sin6tosa(&rip6src), m, opts) == 0) {
			m_freem(m);
			m_freem(opts);
			rip6stat_inc(rip6s_fullsock);
		} else
			sorwakeup(last->inp_socket);
	} else {
		struct counters_ref ref;
		uint64_t *counters;

		if (proto != IPPROTO_ICMPV6) {
			rip6stat_inc(rip6s_nosock);
			if (m->m_flags & M_MCAST)
				rip6stat_inc(rip6s_nosockmcast);
		}
		if (proto == IPPROTO_NONE || proto == IPPROTO_ICMPV6) {
			m_freem(m);
		} else {
			u_int8_t *prvnxtp = ip6_get_prevhdr(m, *offp); /* XXX */
			icmp6_error(m, ICMP6_PARAM_PROB,
			    ICMP6_PARAMPROB_NEXTHEADER,
			    prvnxtp - mtod(m, u_int8_t *));
		}
		counters = counters_enter(&ref, ip6counters);
		counters[ip6s_delivered]--;
		counters_leave(&ref, ip6counters);
	}
	return IPPROTO_DONE;
}

void
rip6_ctlinput(int cmd, struct sockaddr *sa, u_int rdomain, void *d)
{
	struct ip6_hdr *ip6;
	struct ip6ctlparam *ip6cp = NULL;
	struct sockaddr_in6 *sa6 = satosin6(sa);
	const struct sockaddr_in6 *sa6_src = NULL;
	void *cmdarg;
	void (*notify)(struct inpcb *, int) = in_rtchange;
	int nxt;

	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (cmd == PRC_MSGSIZE)
		; /* special code is present, see below */
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		ip6cp = (struct ip6ctlparam *)d;
		ip6 = ip6cp->ip6c_ip6;
		cmdarg = ip6cp->ip6c_cmdarg;
		sa6_src = ip6cp->ip6c_src;
		nxt = ip6cp->ip6c_nxt;
	} else {
		ip6 = NULL;
		cmdarg = NULL;
		sa6_src = &sa6_any;
		nxt = -1;
	}

	if (ip6 && cmd == PRC_MSGSIZE) {
		int valid = 0;
		struct inpcb *in6p;

		/*
		 * Check to see if we have a valid raw IPv6 socket
		 * corresponding to the address in the ICMPv6 message
		 * payload, and the protocol (ip6_nxt) meets the socket.
		 * XXX chase extension headers, or pass final nxt value
		 * from icmp6_notify_error()
		 */
		in6p = in6_pcbhashlookup(&rawin6pcbtable, &sa6->sin6_addr, 0,
		    &sa6_src->sin6_addr, 0, rdomain);

		if (in6p && in6p->inp_ipv6.ip6_nxt &&
		    in6p->inp_ipv6.ip6_nxt == nxt)
			valid++;

		/*
		 * Depending on the value of "valid" and routing table
		 * size (mtudisc_{hi,lo}wat), we will:
		 * - recalculate the new MTU and create the
		 *   corresponding routing entry, or
		 * - ignore the MTU change notification.
		 */
		icmp6_mtudisc_update((struct ip6ctlparam *)d, valid);

		/*
		 * regardless of if we called icmp6_mtudisc_update(),
		 * we need to call in6_pcbnotify(), to notify path
		 * MTU change to the userland (2292bis-02), because
		 * some unconnected sockets may share the same
		 * destination and want to know the path MTU.
		 */
	}

	(void) in6_pcbnotify(&rawin6pcbtable, sa6, 0,
	    sa6_src, 0, rdomain, cmd, cmdarg, notify);
}

/*
 * Generate IPv6 header and pass packet to ip6_output.
 * Tack on options user may have setup with control call.
 */
int
rip6_output(struct mbuf *m, struct socket *so, struct sockaddr *dstaddr,
    struct mbuf *control)
{
	struct in6_addr *dst;
	struct ip6_hdr *ip6;
	struct inpcb *in6p;
	u_int	plen = m->m_pkthdr.len;
	int error = 0;
	struct ip6_pktopts opt, *optp = NULL, *origoptp;
	int type;		/* for ICMPv6 output statistics only */
	int priv = 0;
	int flags;

	in6p = sotoinpcb(so);

	priv = 0;
	if ((so->so_state & SS_PRIV) != 0)
		priv = 1;
	if (control) {
		if ((error = ip6_setpktopts(control, &opt,
		    in6p->inp_outputopts6,
		    priv, so->so_proto->pr_protocol)) != 0)
			goto bad;
		optp = &opt;
	} else
		optp = in6p->inp_outputopts6;

	if (dstaddr->sa_family != AF_INET6) {
		error = EAFNOSUPPORT;
		goto bad;
	}
	dst = &satosin6(dstaddr)->sin6_addr;
	if (IN6_IS_ADDR_V4MAPPED(dst)) {
		error = EADDRNOTAVAIL;
		goto bad;
	}

	/*
	 * For an ICMPv6 packet, we should know its type and code
	 * to update statistics.
	 */
	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
		struct icmp6_hdr *icmp6;
		if (m->m_len < sizeof(struct icmp6_hdr) &&
		    (m = m_pullup(m, sizeof(struct icmp6_hdr))) == NULL) {
			error = ENOBUFS;
			goto bad;
		}
		icmp6 = mtod(m, struct icmp6_hdr *);
		type = icmp6->icmp6_type;
	}

	M_PREPEND(m, sizeof(*ip6), M_DONTWAIT);
	if (!m) {
		error = ENOBUFS;
		goto bad;
	}
	ip6 = mtod(m, struct ip6_hdr *);

	/*
	 * Next header might not be ICMP6 but use its pseudo header anyway.
	 */
	ip6->ip6_dst = *dst;

	/* KAME hack: embed scopeid */
	origoptp = in6p->inp_outputopts6;
	in6p->inp_outputopts6 = optp;
	if (in6_embedscope(&ip6->ip6_dst, satosin6(dstaddr), in6p) != 0) {
		error = EINVAL;
		goto bad;
	}
	in6p->inp_outputopts6 = origoptp;

	/*
	 * Source address selection.
	 */
	{
		struct in6_addr *in6a;

		error = in6_pcbselsrc(&in6a, satosin6(dstaddr), in6p, optp);
		if (error)
			goto bad;

		ip6->ip6_src = *in6a;
	}

	ip6->ip6_flow = in6p->inp_flowinfo & IPV6_FLOWINFO_MASK;
	ip6->ip6_vfc  &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc  |= IPV6_VERSION;
#if 0				/* ip6_plen will be filled in ip6_output. */
	ip6->ip6_plen  = htons((u_short)plen);
#endif
	ip6->ip6_nxt   = in6p->inp_ipv6.ip6_nxt;
	ip6->ip6_hlim = in6_selecthlim(in6p);

	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6 ||
	    in6p->inp_cksum6 != -1) {
		struct mbuf *n;
		int off;
		u_int16_t *sump;
		int sumoff;

		/* compute checksum */
		if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
			off = offsetof(struct icmp6_hdr, icmp6_cksum);
		else
			off = in6p->inp_cksum6;
		if (plen < off + 1) {
			error = EINVAL;
			goto bad;
		}
		off += sizeof(struct ip6_hdr);

		n = m_pulldown(m, off, sizeof(*sump), &sumoff);
		if (n == NULL) {
			m = NULL;
			error = ENOBUFS;
			goto bad;
		}
		sump = (u_int16_t *)(mtod(n, caddr_t) + sumoff);
		*sump = 0;
		*sump = in6_cksum(m, ip6->ip6_nxt, sizeof(*ip6), plen);
	}

	flags = 0;
	if (in6p->inp_flags & IN6P_MINMTU)
		flags |= IPV6_MINMTU;

	/* force routing table */
	m->m_pkthdr.ph_rtableid = in6p->inp_rtableid;

#if NPF > 0
	if (in6p->inp_socket->so_state & SS_ISCONNECTED &&
	    so->so_proto->pr_protocol != IPPROTO_ICMPV6)
		m->m_pkthdr.pf.inp = in6p;
#endif

	error = ip6_output(m, optp, &in6p->inp_route6, flags,
	    in6p->inp_moptions6, in6p);
	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
		icmp6stat_inc(icp6s_outhist + type);
	} else
		rip6stat_inc(rip6s_opackets);

	goto freectl;

 bad:
	m_freem(m);

 freectl:
	if (control) {
		ip6_clearpktopts(&opt, -1);
		m_freem(control);
	}
	return (error);
}

/*
 * Raw IPv6 socket option processing.
 */
int
rip6_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;
	int dir;

	switch (level) {
	case IPPROTO_IPV6:
		switch (optname) {

		case IP_DIVERTFL:
			switch (op) {
			case PRCO_SETOPT:
				if (m == NULL || m->m_len < sizeof(int)) {
					error = EINVAL;
					break;
				}
				dir = *mtod(m, int *);
				if (inp->inp_divertfl > 0)
					error = ENOTSUP;
				else if ((dir & IPPROTO_DIVERT_RESP) ||
					   (dir & IPPROTO_DIVERT_INIT))
					inp->inp_divertfl = dir;
				else
					error = EINVAL;
				break;

			case PRCO_GETOPT:
				m->m_len = sizeof(int);
				*mtod(m, int *) = inp->inp_divertfl;
				break;

			default:
				error = EINVAL;
				break;
			}

			return (error);

#ifdef MROUTING
		case MRT6_INIT:
		case MRT6_DONE:
		case MRT6_ADD_MIF:
		case MRT6_DEL_MIF:
		case MRT6_ADD_MFC:
		case MRT6_DEL_MFC:
			if (op == PRCO_SETOPT) {
				error = ip6_mrouter_set(optname, so, m);
			} else if (op == PRCO_GETOPT)
				error = ip6_mrouter_get(optname, so, m);
			else
				error = EINVAL;
			return (error);
#endif
		case IPV6_CHECKSUM:
			return (ip6_raw_ctloutput(op, so, level, optname, m));
		default:
			return (ip6_ctloutput(op, so, level, optname, m));
		}

	case IPPROTO_ICMPV6:
		/*
		 * XXX: is it better to call icmp6_ctloutput() directly
		 * from protosw?
		 */
		return (icmp6_ctloutput(op, so, level, optname, m));

	default:
		return EINVAL;
	}
}

extern	u_long rip6_sendspace;
extern	u_long rip6_recvspace;

int
rip6_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
	struct mbuf *control, struct proc *p)
{
	struct inpcb *in6p = sotoinpcb(so);
	int error = 0;

	soassertlocked(so);

	if (req == PRU_CONTROL)
		return (in6_control(so, (u_long)m, (caddr_t)nam,
		    (struct ifnet *)control));

	switch (req) {
	case PRU_DISCONNECT:
		if ((so->so_state & SS_ISCONNECTED) == 0) {
			error = ENOTCONN;
			break;
		}
		in6p->inp_faddr6 = in6addr_any;
		so->so_state &= ~SS_ISCONNECTED;	/* XXX */
		break;

	case PRU_ABORT:
		soisdisconnected(so);
		/* FALLTHROUGH */
	case PRU_DETACH:
		if (in6p == NULL)
			panic("rip6_detach");
#ifdef MROUTING
		if (so == ip6_mrouter[in6p->inp_rtableid])
			ip6_mrouter_done(so);
#endif
		free(in6p->inp_icmp6filt, M_PCB, sizeof(struct icmp6_filter));
		in6p->inp_icmp6filt = NULL;

		in_pcbdetach(in6p);
		break;

	case PRU_BIND:
	    {
		struct sockaddr_in6 *addr;

		if ((error = in6_nam2sin6(nam, &addr)))
			break;
		/*
		 * Make sure to not enter in_pcblookup_local(), local ports
		 * are non-sensical for raw sockets.
		 */
		addr->sin6_port = 0;

		if ((error = in6_pcbaddrisavail(in6p, addr, 0, p)))
			break;

		in6p->inp_laddr6 = addr->sin6_addr;
		break;
	    }

	case PRU_CONNECT:
	{
		struct sockaddr_in6 *addr;
		struct in6_addr *in6a = NULL;

		if ((error = in6_nam2sin6(nam, &addr)))
			break;
		/* Source address selection. XXX: need pcblookup? */
		error = in6_pcbselsrc(&in6a, addr, in6p, in6p->inp_outputopts6);
		if (error)
			break;
		in6p->inp_laddr6 = *in6a;
		in6p->inp_faddr6 = addr->sin6_addr;
		soisconnected(so);
		break;
	}

	case PRU_CONNECT2:
		error = EOPNOTSUPP;
		break;

	/*
	 * Mark the connection as being incapable of futther input.
	 */
	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;
	/*
	 * Ship a packet out. The appropriate raw output
	 * routine handles any messaging necessary.
	 */
	case PRU_SEND:
	{
		struct sockaddr_in6 dst;

		/* always copy sockaddr to avoid overwrites */
		memset(&dst, 0, sizeof(dst));
		dst.sin6_family = AF_INET6;
		dst.sin6_len = sizeof(dst);
		if (so->so_state & SS_ISCONNECTED) {
			if (nam) {
				error = EISCONN;
				break;
			}
			dst.sin6_addr = in6p->inp_faddr6;
		} else {
			struct sockaddr_in6 *addr6;

			if (nam == NULL) {
				error = ENOTCONN;
				break;
			}
			if ((error = in6_nam2sin6(nam, &addr6)))
				break;
			dst.sin6_addr = addr6->sin6_addr;
			dst.sin6_scope_id = addr6->sin6_scope_id;
		}
		error = rip6_output(m, so, sin6tosa(&dst), control);
		m = NULL;
		break;
	}

	case PRU_SENSE:
		/*
		 * stat: don't bother with a blocksize
		 */
		return (0);
	/*
	 * Not supported.
	 */
	case PRU_RCVOOB:
	case PRU_RCVD:
	case PRU_LISTEN:
	case PRU_ACCEPT:
	case PRU_SENDOOB:
		error = EOPNOTSUPP;
		break;

	case PRU_SOCKADDR:
		in6_setsockaddr(in6p, nam);
		break;

	case PRU_PEERADDR:
		in6_setpeeraddr(in6p, nam);
		break;

	default:
		panic("rip6_usrreq");
	}
	m_freem(m);
	return (error);
}

int
rip6_attach(struct socket *so, int proto)
{
	struct inpcb *in6p;
	int error;

	if (so->so_pcb)
		panic("rip6_attach");
	if ((so->so_state & SS_PRIV) == 0)
		return (EACCES);
	if (proto < 0 || proto >= IPPROTO_MAX)
		return EPROTONOSUPPORT;

	if ((error = soreserve(so, rip6_sendspace, rip6_recvspace)) ||
	    (error = in_pcballoc(so, &rawin6pcbtable)))
		return error;

	in6p = sotoinpcb(so);
	in6p->inp_ipv6.ip6_nxt = proto;
	in6p->inp_cksum6 = -1;

	in6p->inp_icmp6filt = malloc(sizeof(struct icmp6_filter),
	    M_PCB, M_NOWAIT);
	if (in6p->inp_icmp6filt == NULL) {
		in_pcbdetach(in6p);
		return ENOMEM;
	}
	ICMP6_FILTER_SETPASSALL(in6p->inp_icmp6filt);
	return 0;
}

int
rip6_sysctl_rip6stat(void *oldp, size_t *oldplen, void *newp)
{
	struct rip6stat rip6stat;

	CTASSERT(sizeof(rip6stat) == rip6s_ncounters * sizeof(uint64_t));
	counters_read(ip6counters, (uint64_t *)&rip6stat, rip6s_ncounters);

	return (sysctl_rdstruct(oldp, oldplen, newp,
	    &rip6stat, sizeof(rip6stat)));
}

int
rip6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;

	switch (name[0]) {
	case RIPV6CTL_STATS:
		return (rip6_sysctl_rip6stat(oldp, oldlenp, newp));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
@


1.118
log
@Change sosetopt() to no longer free the mbuf it receives and change
all the callers to call m_freem(9).

Support from deraadt@@ and tedu@@, ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.117 2017/08/15 17:47:15 bluhm Exp $	*/
d573 1
a573 1
	NET_ASSERT_LOCKED();
@


1.117
log
@Convert hand rolled sockaddr checks to the nam2sin functions.
Especially in tcp_usrreq() connect detect the correct address family
based on the inp_flags instead of the sa_family user input.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.116 2017/08/11 19:53:02 bluhm Exp $	*/
a527 2
			if (op == PRCO_SETOPT)
				(void)m_free(m);
a538 1
				m_free(m);
a558 2
		if (op == PRCO_SETOPT)
			m_free(m);
@


1.116
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.115 2017/06/26 09:32:32 mpi Exp $	*/
d662 1
a662 2
		struct sockaddr_in6 tmp;
		struct sockaddr_in6 *dst;
d665 3
d673 1
a673 7
			/* XXX */
			bzero(&tmp, sizeof(tmp));
			tmp.sin6_family = AF_INET6;
			tmp.sin6_len = sizeof(struct sockaddr_in6);
			memcpy(&tmp.sin6_addr, &in6p->inp_faddr6,
			    sizeof(struct in6_addr));
			dst = &tmp;
d675 2
d681 1
a681 2
			if (nam->m_len != sizeof(tmp)) {
				error = EINVAL;
d683 2
a684 4
			}

			tmp = *mtod(nam, struct sockaddr_in6 *);
			dst = &tmp;
d686 1
a686 1
		error = rip6_output(m, so, sin6tosa(dst), control);
@


1.115
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.114 2017/05/13 17:44:00 bluhm Exp $	*/
d612 1
a612 1
		struct sockaddr_in6 *addr = mtod(nam, struct sockaddr_in6 *);
d614 1
a614 6
		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if (addr->sin6_family != AF_INET6) {
			error = EADDRNOTAVAIL;
a615 2
		}

d631 1
a631 1
		struct sockaddr_in6 *addr = mtod(nam, struct sockaddr_in6 *);
d634 1
a634 6
		if (nam->m_len != sizeof(*addr)) {
			error = EINVAL;
			break;
		}
		if (addr->sin6_family != AF_INET6) {
			error = EAFNOSUPPORT;
a635 2
		}

@


1.114
log
@Check for mapped addesses in rip6_output() like it is done in
udp6_output().  Move the EAFNOSUPPORT error from rip6_usrreq() to
rip6_output() like it is done for UDP.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.113 2017/05/08 08:46:39 rzalamena Exp $	*/
d194 2
a195 1
				if (sbappendaddr(&last->inp_socket->so_rcv,
d213 1
a213 1
		if (sbappendaddr(&last->inp_socket->so_rcv,
@


1.113
log
@Added initial IPv6 multicast routing support for multiple rdomains:

* don't share mifs (multicast interface) between rdomains
* allow multiple routing sockets connected at the same time if they are
  in different rdomains.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.112 2017/05/06 16:35:59 bluhm Exp $	*/
a345 1
	dst = &satosin6(dstaddr)->sin6_addr;
d355 10
a702 5

			if (dst->sin6_family != AF_INET6) {
				error = EAFNOSUPPORT;
				break;
			}
@


1.112
log
@Checking for IPv4 mapped addreses and dropping the packet is done
in ip6_input().  Do not check that again in the protocol input
functions.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.111 2017/04/19 15:44:45 bluhm Exp $	*/
d591 2
a592 2
		if (so == ip6_mrouter)
			ip6_mrouter_done();
@


1.111
log
@icmp6_rip6_input() was mostly duplicated code from rip6_input().
Merge these functions together and remove icmp6_rip6_input().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.110 2017/04/17 21:10:03 bluhm Exp $	*/
a131 8

	/* Be proactive about malicious use of IPv4 mapped address */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		/* XXX stat */
		m_freem(m);
		return IPPROTO_DONE;
	}
@


1.110
log
@The raw ip input functions are called from several places.  Use the
address family passed down with pr_input to check that the correct
one is used.
OK florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.109 2017/04/14 20:46:31 bluhm Exp $	*/
d130 2
a131 1
	rip6stat_inc(rip6s_ipackets);
d152 1
a152 1
		if (in6p->inp_ipv6.ip6_nxt &&
d176 12
a187 1
		if (in6p->inp_cksum6 != -1) {
d231 6
a236 4
		rip6stat_inc(rip6s_nosock);
		if (m->m_flags & M_MCAST)
			rip6stat_inc(rip6s_nosockmcast);
		if (proto == IPPROTO_NONE)
d238 1
a238 1
		else {
@


1.109
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.108 2017/03/13 20:18:21 claudio Exp $	*/
d127 2
@


1.108
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.107 2017/03/03 15:48:02 bluhm Exp $	*/
d119 1
a119 1
rip6_input(struct mbuf **mp, int *offp, int proto)
@


1.107
log
@Convert the variable argument list of the pr_output functions to
fixed parameters.
OK mpi@@ claudio@@ dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.106 2017/02/09 15:23:35 jca Exp $	*/
a558 1
	int priv;
a561 4
	priv = 0;
	if ((so->so_state & SS_PRIV) != 0)
		priv++;

a566 29
	case PRU_ATTACH:
		if (in6p)
			panic("rip6_attach");
		if (!priv) {
			error = EACCES;
			break;
		}
		if ((long)nam < 0 || (long)nam >= IPPROTO_MAX) {
			error = EPROTONOSUPPORT;
			break;
		}
		if ((error = soreserve(so, rip6_sendspace, rip6_recvspace)) ||
		    (error = in_pcballoc(so, &rawin6pcbtable))) {
			break;
		}
		in6p = sotoinpcb(so);
		in6p->inp_ipv6.ip6_nxt = (long)nam;
		in6p->inp_cksum6 = -1;

		in6p->inp_icmp6filt = malloc(sizeof(struct icmp6_filter),
		    M_PCB, M_NOWAIT);
		if (in6p->inp_icmp6filt == NULL) {
			in_pcbdetach(in6p);
			error = ENOMEM;
			break;
		}
		ICMP6_FILTER_SETPASSALL(in6p->inp_icmp6filt);
		break;

d726 31
@


1.106
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.105 2017/02/05 16:04:14 jca Exp $	*/
d320 2
a321 1
rip6_output(struct mbuf *m, ...)
a322 3
	struct socket *so;
	struct sockaddr_in6 *dstsock;
	struct mbuf *control;
a330 1
	va_list ap;
a332 6
	va_start(ap, m);
	so = va_arg(ap, struct socket *);
	dstsock = va_arg(ap, struct sockaddr_in6 *);
	control = va_arg(ap, struct mbuf *);
	va_end(ap);

d338 1
a338 1
	dst = &dstsock->sin6_addr;
d378 1
a378 1
	if (in6_embedscope(&ip6->ip6_dst, dstsock, in6p) != 0) {
d390 1
a390 1
		error = in6_pcbselsrc(&in6a, dstsock, in6p, optp);
d726 1
a726 1
		error = rip6_output(m, so, dst, control);
@


1.105
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.104 2017/02/01 20:59:47 dhill Exp $	*/
d106 1
a106 1
struct rip6stat rip6stat;
a113 1

d115 1
d128 1
a128 1
	rip6stat.rip6s_ipackets++;
d174 1
a174 1
			rip6stat.rip6s_isum++;
d177 1
a177 1
				rip6stat.rip6s_badsum++;
d193 1
a193 1
					rip6stat.rip6s_fullsock++;
d210 1
a210 1
			rip6stat.rip6s_fullsock++;
d217 1
a217 1
		rip6stat.rip6s_nosock++;
d219 1
a219 1
			rip6stat.rip6s_nosockmcast++;
d460 1
a460 1
		icmp6stat.icp6s_outhist[type]++;
d462 1
a462 1
		rip6stat.rip6s_opackets++;
d772 12
d793 1
a793 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &rip6stat, sizeof(rip6stat)));
@


1.104
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.103 2017/01/23 16:31:24 bluhm Exp $	*/
d214 3
d228 3
a230 1
		ip6stat.ip6s_delivered--;
@


1.103
log
@The function raw_input() has not been called since netiso has been
removed in 2004.  The comment about raw_input() above rip_input()
was added in 1981, but it is wrong since 1992.  After that it has
been copied to rip6_input().  (*pr_input)() is never called with
the parameters (mbuf, sockproto, sockaddr, sockaddr).
So retire raw_input().
OK guenther@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.102 2017/01/10 09:01:18 mpi Exp $	*/
d477 1
a477 1
	struct mbuf **mp)
d490 1
a490 1
				if (*mp == NULL || (*mp)->m_len < sizeof(int)) {
d494 1
a494 1
				dir = *mtod(*mp, int *);
d505 2
a506 3
				*mp = m_get(M_WAIT, M_SOOPTS);
				(*mp)->m_len = sizeof(int);
				*mtod(*mp, int *) = inp->inp_divertfl;
d515 1
a515 1
				(void)m_free(*mp);
d526 2
a527 2
				error = ip6_mrouter_set(optname, so, *mp);
				m_free(*mp);
d529 1
a529 1
				error = ip6_mrouter_get(optname, so, mp);
d535 1
a535 1
			return (ip6_raw_ctloutput(op, so, level, optname, mp));
d537 1
a537 1
			return (ip6_ctloutput(op, so, level, optname, mp));
d545 1
a545 1
		return (icmp6_ctloutput(op, so, level, optname, mp));
d549 1
a549 1
			m_free(*mp);
@


1.102
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.101 2016/12/22 11:04:44 rzalamena Exp $	*/
a117 5
/*
 * Setup generic address and protocol structures
 * for raw_input routine, then pass them along with
 * mbuf chain.
 */
@


1.101
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.100 2016/12/19 08:36:50 mpi Exp $	*/
d533 1
a533 2
				if (*mp)
					(void)m_free(*mp);
@


1.100
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.99 2016/11/21 09:09:06 mpi Exp $	*/
a530 1
		case MRT6_PIM:
@


1.99
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.98 2016/10/25 19:40:57 florian Exp $	*/
d573 1
a573 1
	splsoftassert(IPL_SOFTNET);
@


1.98
log
@bluhm@@ pointed out that addr->sin6_port should be forced to zero since
a port doesn't make sense for a raw socket.
I forgot to commit this hunk in the previous commit. Sorry about that.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.97 2016/10/25 06:26:03 florian Exp $	*/
a570 1
	int s;
d573 2
a594 1
		s = splsoftnet();
a596 1
			splx(s);
a598 1
		splx(s);
@


1.97
log
@Fix bind(2)ing link local addresses to raw sockets by calling
in6_pcbaddrisavail() which does all the checking for us instead of
hand rolling half of it.
Input & OK bluhm@@

bluhm@@ also points out that this relaxes the check for valid addresses
a bit, deprecated addresses become valid for raw sockets. This should
be fine, it brings raw sockets in line with udp/tcp sockets and it
might be particularly interesting for debugging purposes.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.96 2016/09/19 18:09:09 tedu Exp $	*/
d652 6
@


1.96
log
@convert bcopy to memcpy. from david hill. ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.95 2016/08/22 10:33:22 mpi Exp $	*/
a642 1
		struct ifaddr *ifa = NULL;
d652 2
a653 6
		/*
		 * we don't support mapped address here, it would confuse
		 * users so reject it
		 */
		if (IN6_IS_ADDR_V4MAPPED(&addr->sin6_addr)) {
			error = EADDRNOTAVAIL;
d655 1
a655 21
		}
		/*
		 * Currently, ifa_ifwithaddr tends to fail for a link-local
		 * address, since it implicitly expects that the link ID
		 * for the address is embedded in the sin6_addr part.
		 * For now, we'd rather keep this "as is". We'll eventually fix
		 * this in a more natural way.
		 */
		if (!IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr) &&
		    !(so->so_options & SO_BINDANY) &&
		    (ifa = ifa_ifwithaddr(sin6tosa(addr),
		    in6p->inp_rtableid)) == 0) {
			error = EADDRNOTAVAIL;
			break;
		}
		if (ifa && ifatoia6(ifa)->ia6_flags &
		    (IN6_IFF_ANYCAST|IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED|
		     IN6_IFF_DETACHED|IN6_IFF_DEPRECATED)) {
			error = EADDRNOTAVAIL;
			break;
		}
@


1.95
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.94 2016/08/04 20:46:24 vgross Exp $	*/
d738 1
a738 1
			bcopy(&in6p->inp_faddr6, &tmp.sin6_addr,
@


1.94
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.93 2016/07/22 11:14:41 mpi Exp $	*/
d634 3
a636 4
		if (in6p->inp_icmp6filt) {
			free(in6p->inp_icmp6filt, M_PCB, 0);
			in6p->inp_icmp6filt = NULL;
		}
@


1.93
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.91 2016/07/05 10:17:14 mpi Exp $	*/
d399 1
a399 3
		error = in6_selectsrc(&in6a, dstsock, optp,
		    in6p->inp_moptions6, &in6p->inp_route6, &in6p->inp_laddr6,
		    in6p->inp_rtableid);
d701 1
a701 3
		error = in6_selectsrc(&in6a, addr, in6p->inp_outputopts6,
		    in6p->inp_moptions6, &in6p->inp_route6,
		    &in6p->inp_laddr6, in6p->inp_rtableid);
@


1.92
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d399 3
a401 1
		error = in6_pcbselsrc(&in6a, dstsock, in6p, optp);
d703 3
a705 1
		error = in6_pcbselsrc(&in6a, addr, in6p, in6p->inp_outputopts6);
@


1.91
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.90 2016/04/11 15:28:03 vgross Exp $	*/
d399 1
a399 3
		error = in6_selectsrc(&in6a, dstsock, optp,
		    in6p->inp_moptions6, &in6p->inp_route6, &in6p->inp_laddr6,
		    in6p->inp_rtableid);
d701 1
a701 3
		error = in6_selectsrc(&in6a, addr, in6p->inp_outputopts6,
		    in6p->inp_moptions6, &in6p->inp_route6,
		    &in6p->inp_laddr6, in6p->inp_rtableid);
@


1.90
log
@This code chunk has been disabled since its import, and what is does is
quite unsafe. Juste delete it.

Ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.89 2016/03/29 11:57:51 chl Exp $	*/
d679 1
a679 1
		    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|
@


1.89
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.88 2016/03/07 18:44:00 naddy Exp $	*/
a287 15
#if 0
		if (!in6p) {
			/*
			 * As the use of sendto(2) is fairly popular,
			 * we may want to allow non-connected pcb too.
			 * But it could be too weak against attacks...
			 * We should at least check if the local
			 * address (= s) is really ours.
			 */
			in6p = in_pcblookup(&rawin6pcbtable, &sa6->sin6_addr, 0,
			    (struct in6_addr *)&sa6_src->sin6_addr, 0,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
			    rdomain);
		}
#endif
@


1.88
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.87 2015/11/24 13:37:16 mpi Exp $	*/
d346 1
a346 1
	int type, code;		/* for ICMPv6 output statistics only */
a384 1
		code = icmp6->icmp6_code;
@


1.87
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.86 2015/10/24 16:08:48 mpi Exp $	*/
d112 1
a112 1
rip6_init()
@


1.86
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.85 2015/10/19 12:11:28 mpi Exp $	*/
a78 1
#include <net/if_types.h>
@


1.85
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.84 2015/09/11 08:17:06 claudio Exp $	*/
a346 1
	struct ifnet *oifp = NULL;
a422 2
		if (rtisvalid(in6p->inp_route6.ro_rt))
			oifp = in6p->inp_route6.ro_rt->rt_ifp;
d432 1
a432 1
	ip6->ip6_hlim = in6_selecthlim(in6p, oifp);
@


1.84
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.83 2015/09/11 07:42:35 claudio Exp $	*/
d424 1
a424 2
		if (in6p->inp_route6.ro_rt &&
		    in6p->inp_route6.ro_rt->rt_flags & RTF_UP)
@


1.83
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.82 2015/09/10 17:52:05 claudio Exp $	*/
d481 1
a481 1
	    in6p->inp_moptions6, NULL, in6p);
@


1.82
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.81 2015/09/09 15:51:40 mpi Exp $	*/
d405 1
a405 1
	if (in6_embedscope(&ip6->ip6_dst, dstsock, in6p, &oifp) != 0) {
@


1.81
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.80 2015/09/09 12:50:08 mpi Exp $	*/
d148 1
a148 1
	(void)in6_recoverscope(&rip6src, &ip6->ip6_src, NULL);
@


1.80
log
@Kill a couple of if_get()s only needed to increment per-ifp IPv6 stats.

We do not export those per-ifp statistics and they will soon all die.

"We're putting inet6 on a diet" claudio@@

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.79 2015/07/28 12:22:07 bluhm Exp $	*/
d481 1
a481 1
	    in6p->inp_moptions6, &oifp, in6p);
a482 2
		if (oifp)
			icmp6_ifoutstat_inc(oifp, type, code);
@


1.79
log
@Implement pf divert-reply for raw sockets.  Note that an empty
divert->addr means that the rule has a divert-reply option.  With
divert-to the divert->addr is always set.  The divert-reply rules
should compare the original packet with the socket addresses.  So
skip the step that compares the inp->inp_laddr with the empty
divert->addr.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.78 2015/07/28 11:44:51 bluhm Exp $	*/
d227 3
a229 9
			struct ifnet *ifp;

			ifp = if_get(m->m_pkthdr.ph_ifidx);
			if (ifp != NULL) {
				in6_ifstat_inc(ifp, ifs6_in_protounknown);
				icmp6_error(m, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_NEXTHEADER,
				    prvnxtp - mtod(m, u_int8_t *));
			}
@


1.78
log
@iDo not link an ICMP6 socket to the pf state.  When multiple ICMP
packets with a different ICMP ID are sent over the same raw socket,
multiple states should be created.  Put a similar check into
rip6_output() like in the IPv4 case.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.77 2015/07/15 22:16:42 deraadt Exp $	*/
d165 2
d171 1
@


1.77
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.76 2015/06/30 15:30:17 mpi Exp $	*/
d478 2
a479 1
	if (in6p->inp_socket->so_state & SS_ISCONNECTED)
@


1.76
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.75 2015/06/16 11:09:40 mpi Exp $	*/
d195 1
a195 2
					if (opts)
						m_freem(opts);
d212 1
a212 2
			if (opts)
				m_freem(opts);
d494 1
a494 2
	if (m)
		m_freem(m);
d547 1
a547 1
			if (op == PRCO_SETOPT && *mp)
d583 1
a583 1
		if (op == PRCO_SETOPT && *mp)
d821 1
a821 2
	if (m != NULL)
		m_freem(m);
@


1.75
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.74 2015/06/08 22:19:28 krw Exp $	*/
d186 1
a186 1
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
@


1.74
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.73 2015/03/04 11:10:55 mpi Exp $	*/
d226 9
a234 4
			in6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_protounknown);
			icmp6_error(m, ICMP6_PARAM_PROB,
			    ICMP6_PARAMPROB_NEXTHEADER,
			    prvnxtp - mtod(m, u_int8_t *));
@


1.73
log
@Do not check if the interface index matches the scope when all we want
is to clear the damn embedded scope.

At this point the receiving interface should not matter and will in the
future be cleared to prevent such layer violations.

This prevent exporting addresses with embedded scope to userland.

Found the hardway by and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.72 2015/01/24 00:29:06 deraadt Exp $	*/
d506 1
a506 1
rip6_ctloutput(int op, struct socket *so, int level, int optname, 
d520 1
a520 1
				if (*mp == 0 || (*mp)->m_len < sizeof (int)) {
d527 1
a527 1
				else if ((dir & IPPROTO_DIVERT_RESP) || 
d530 1
a530 1
				else 
d591 1
a591 1
rip6_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam, 
d653 1
a653 1
		if (in6p == 0)
@


1.72
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.71 2014/12/05 15:50:04 mpi Exp $	*/
d148 1
a148 1
	(void)in6_recoverscope(&rip6src, &ip6->ip6_src, m->m_pkthdr.rcvif);
@


1.71
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.70 2014/11/09 22:05:08 bluhm Exp $	*/
a79 3
#if NPF > 0
#include <net/pfvar.h>
#endif
d94 4
@


1.70
log
@To implement transparent relays for connectionless protocols, the
pf the state has to vanish immediately when the relay closes the
socket.  To make this work reliably, the linkage between state and
socket must be established with the first packet.  This packet could
be incomming or outgoing.
Link the pf state in the socket layer earlier.  This makes all tests
in /usr/src/regress/sys/net/pf_divert pass.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.69 2014/10/14 09:55:44 mpi Exp $	*/
d77 1
@


1.69
log
@Don't check for an empty list of interfaces.  This is never true even if
you don't have a physical interface on your machine, so why rawip should
be more clever^Wparanoid than the others?

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.68 2014/07/22 11:06:10 mpi Exp $	*/
d471 5
@


1.68
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.67 2014/07/12 18:44:23 tedu Exp $	*/
d668 1
a668 1
		if (TAILQ_EMPTY(&ifnet) || (addr->sin6_family != AF_INET6)) {
a710 4
			break;
		}
		if (TAILQ_EMPTY(&ifnet)) {
			error = EADDRNOTAVAIL;
@


1.67
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.66 2014/04/18 10:48:30 jca Exp $	*/
a90 1
#include <netinet/in_systm.h>
@


1.66
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.65 2014/04/14 09:06:42 mpi Exp $	*/
d654 1
a654 1
			free(in6p->inp_icmp6filt, M_PCB);
@


1.65
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.64 2014/01/08 22:38:29 bluhm Exp $	*/
d416 4
a419 5
		if ((in6a = in6_selectsrc(dstsock, optp, in6p->inp_moptions6,
		    &in6p->inp_route6, &in6p->inp_laddr6, &error,
		    in6p->inp_rtableid)) == 0) {
			if (error == 0)
				error = EADDRNOTAVAIL;
d421 1
a421 1
		}
d724 1
a724 1
		in6a = in6_selectsrc(addr, in6p->inp_outputopts6,
d726 2
a727 4
		    &in6p->inp_laddr6, &error, in6p->inp_rtableid);
		if (in6a == NULL) {
			if (error == 0)
				error = EADDRNOTAVAIL;
a728 1
		}
@


1.64
log
@Name the local variables for struct ifaddr consistently "ifa".
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.63 2013/12/20 02:04:09 krw Exp $	*/
d471 2
a472 2
	/* force routing domain */
	m->m_pkthdr.rdomain = in6p->inp_rtableid;
@


1.63
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.62 2013/11/22 07:59:09 mpi Exp $	*/
d664 1
a664 1
		struct ifaddr *ia = NULL;
d691 1
a691 1
		    (ia = ifa_ifwithaddr(sin6tosa(addr),
d696 1
a696 1
		if (ia && ifatoia6(ia)->ia6_flags &
@


1.62
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.61 2013/10/23 19:57:50 deraadt Exp $	*/
d149 1
a149 1
	CIRCLEQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
@


1.61
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.60 2013/10/20 11:03:03 phessler Exp $	*/
d600 1
a600 1
		    (struct ifnet *)control, p));
@


1.60
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.59 2013/10/17 16:27:47 bluhm Exp $	*/
a102 20
/* inpcb members */
#define in6pcb		inpcb
#define in6p_laddr	inp_laddr6
#define in6p_faddr	inp_faddr6
#define in6p_icmp6filt	inp_icmp6filt
#define in6p_route	inp_route6
#define in6p_socket	inp_socket
#define in6p_flags	inp_flags
#define in6p_moptions	inp_moptions6
#define in6p_outputopts	inp_outputopts6
#define in6p_ip6	inp_ipv6
#define in6p_flowinfo	inp_flowinfo
#define in6p_sp		inp_sp
#define in6p_next	inp_next
#define in6p_prev	inp_prev
/* macro names */
#define sotoin6pcb	sotoinpcb
/* function names */
#define in6_pcbdetach	in_pcbdetach
#define in6_rtchange	in_rtchange
d128 2
a129 2
	struct in6pcb *in6p;
	struct in6pcb *last = NULL;
d150 1
a150 1
		if (in6p->in6p_socket->so_state & SS_CANTRCVMORE)
d152 1
a152 1
		if (!(in6p->in6p_flags & INP_IPV6))
d154 2
a155 2
		if (in6p->in6p_ip6.ip6_nxt &&
		    in6p->in6p_ip6.ip6_nxt != proto)
d164 1
a164 1
			if (!IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr,
d169 2
a170 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_laddr) &&
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
d172 2
a173 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr) &&
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
d175 1
a175 1
		if (in6p->in6p_cksum != -1) {
d186 1
a186 1
				if (last->in6p_flags & IN6P_CONTROLOPTS)
d190 1
a190 1
				if (sbappendaddr(&last->in6p_socket->so_rcv,
d198 1
a198 1
					sorwakeup(last->in6p_socket);
d205 1
a205 1
		if (last->in6p_flags & IN6P_CONTROLOPTS)
d209 1
a209 1
		if (sbappendaddr(&last->in6p_socket->so_rcv,
d216 1
a216 1
			sorwakeup(last->in6p_socket);
d243 1
a243 1
	void (*notify)(struct in6pcb *, int) = in6_rtchange;
d253 1
a253 1
		notify = in6_rtchange, d = NULL;
d277 1
a277 1
		struct in6pcb *in6p;
a285 1
		in6p = NULL;
d304 2
a305 2
		if (in6p && in6p->in6p_ip6.ip6_nxt &&
		    in6p->in6p_ip6.ip6_nxt == nxt)
d342 1
a342 1
	struct in6pcb *in6p;
d358 1
a358 1
	in6p = sotoin6pcb(so);
d366 1
a366 1
		    in6p->in6p_outputopts,
d371 1
a371 1
		optp = in6p->in6p_outputopts;
d402 2
a403 2
	origoptp = in6p->in6p_outputopts;
	in6p->in6p_outputopts = optp;
d408 1
a408 1
	in6p->in6p_outputopts = origoptp;
d416 2
a417 2
		if ((in6a = in6_selectsrc(dstsock, optp, in6p->in6p_moptions,
		    &in6p->in6p_route, &in6p->in6p_laddr, &error,
d424 3
a426 3
		if (in6p->in6p_route.ro_rt &&
		    in6p->in6p_route.ro_rt->rt_flags & RTF_UP)
			oifp = in6p->in6p_route.ro_rt->rt_ifp;
d429 1
a429 1
	ip6->ip6_flow = in6p->in6p_flowinfo & IPV6_FLOWINFO_MASK;
d435 1
a435 1
	ip6->ip6_nxt   = in6p->in6p_ip6.ip6_nxt;
d439 1
a439 1
	    in6p->in6p_cksum != -1) {
d449 1
a449 1
			off = in6p->in6p_cksum;
d468 1
a468 1
	if (in6p->in6p_flags & IN6P_MINMTU)
d474 2
a475 2
	error = ip6_output(m, optp, &in6p->in6p_route, flags,
	    in6p->in6p_moptions, &oifp, in6p);
d589 1
a589 1
	struct in6pcb *in6p = sotoin6pcb(so);
d621 3
a623 3
		in6p = sotoin6pcb(so);
		in6p->in6p_ip6.ip6_nxt = (long)nam;
		in6p->in6p_cksum = -1;
d625 1
a625 1
		in6p->in6p_icmp6filt = malloc(sizeof(struct icmp6_filter),
d627 2
a628 2
		if (in6p->in6p_icmp6filt == NULL) {
			in6_pcbdetach(in6p);
d632 1
a632 1
		ICMP6_FILTER_SETPASSALL(in6p->in6p_icmp6filt);
d640 1
a640 1
		in6p->in6p_faddr = in6addr_any;
d654 3
a656 3
		if (in6p->in6p_icmp6filt) {
			free(in6p->in6p_icmp6filt, M_PCB);
			in6p->in6p_icmp6filt = NULL;
d658 1
a658 1
		in6_pcbdetach(in6p);
d702 1
a702 1
		in6p->in6p_laddr = addr->sin6_addr;
d725 3
a727 3
		in6a = in6_selectsrc(addr, in6p->in6p_outputopts,
		    in6p->in6p_moptions, &in6p->in6p_route,
		    &in6p->in6p_laddr, &error, in6p->inp_rtableid);
d733 2
a734 2
		in6p->in6p_laddr = *in6a;
		in6p->in6p_faddr = addr->sin6_addr;
d768 1
a768 1
			bcopy(&in6p->in6p_faddr, &tmp.sin6_addr,
@


1.59
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.58 2013/06/04 19:11:52 bluhm Exp $	*/
d308 1
a308 1
		    &sa6_src->sin6_addr, 0);
d320 2
a321 1
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6);
d348 1
a348 1
	    sa6_src, 0, cmd, cmdarg, notify);
@


1.58
log
@Implement pf divert-to and divert-reply also for IPv6 raw sockets.
OK henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.57 2013/06/01 16:22:05 bluhm Exp $	*/
d84 1
a84 1
#include <netinet/in_var.h>
@


1.57
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.56 2013/05/31 15:04:25 bluhm Exp $	*/
d64 2
d79 3
d177 12
@


1.56
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.55 2013/05/31 13:15:53 bluhm Exp $	*/
d239 1
a239 1
rip6_ctlinput(int cmd, struct sockaddr *sa, void *d)
@


1.55
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.54 2013/05/02 11:54:10 mpi Exp $	*/
d194 1
a194 1
				    (struct sockaddr *)&rip6src, n, opts) == 0) {
d213 1
a213 1
		    (struct sockaddr *)&rip6src, m, opts) == 0) {
d694 1
a694 1
		    (ia = ifa_ifwithaddr((struct sockaddr *)addr,
@


1.54
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.53 2013/04/07 20:58:25 bluhm Exp $	*/
d243 1
a278 1
		struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)sa;
d291 1
a291 1
		    (struct in6_addr *)&sa6_src->sin6_addr, 0);
d329 2
a330 2
	(void) in6_pcbnotify(&rawin6pcbtable, sa, 0,
	    (struct sockaddr *)sa6_src, 0, cmd, cmdarg, notify);
@


1.53
log
@Make the SO_BINDANY socket option also work for raw IPv6 sockets.
OK markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.52 2013/04/01 22:51:39 bluhm Exp $	*/
a656 1
		/* xxx: RSVP */
@


1.52
log
@There is no IPv6 default scope in OpenBSD.  Remove leftovers.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.51 2013/03/31 11:18:35 bluhm Exp $	*/
d694 1
@


1.51
log
@The call to in_pcballoc() in user request attach was handled in
three different ways.  Use the same code in udp_usrreq() and
rip_usrreq() and rip6_usrreq(). This also fixes a pcb and socket
leak in udp_usrreq() in case soreserve() fails.  Put an splsoftassert()
into in_pcballoc() for safety.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.50 2013/03/30 12:15:29 bluhm Exp $	*/
a90 3
#ifdef ENABLE_DEFAULT_SCOPE
#include <netinet6/scope6_var.h>
#endif
a677 5
#ifdef ENABLE_DEFAULT_SCOPE
		if (addr->sin6_scope_id == 0)	/* not change if specified  */
			addr->sin6_scope_id =
			    scope6_addr2default(&addr->sin6_addr);
#endif
a712 3
#ifdef ENABLE_DEFAULT_SCOPE
		struct sockaddr_in6 sin6;
#endif
a726 10
#ifdef ENABLE_DEFAULT_SCOPE
		if (addr->sin6_scope_id == 0) {
			/* protect *addr */
			sin6 = *addr;
			addr = &sin6;
			addr->sin6_scope_id =
			    scope6_addr2default(&addr->sin6_addr);
		}
#endif

a791 6
#ifdef ENABLE_DEFAULT_SCOPE
		if (dst->sin6_scope_id == 0) {
			dst->sin6_scope_id =
			    scope6_addr2default(&dst->sin6_addr);
		}
#endif
@


1.50
log
@Restrict protocol numbers for raw sockets to the range from 0 to 255.
OK deraadt@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.49 2013/03/28 16:45:16 tedu Exp $	*/
d596 1
a597 1
	int error = 0;
d621 2
a622 6
		if ((error = soreserve(so, rip6_sendspace, rip6_recvspace)) != 0) {
			splx(s);
			break;
		}
		if ((error = in_pcballoc(so, &rawin6pcbtable)) != 0)
		{
@


1.49
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.48 2013/03/28 00:32:11 bluhm Exp $	*/
d614 4
@


1.48
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.47 2013/03/14 11:18:37 mpi Exp $	*/
a71 1
#include <sys/proc.h>
@


1.47
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.46 2013/03/04 14:42:25 bluhm Exp $	*/
a123 1
#define ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))
@


1.46
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.45 2012/10/21 13:06:03 benno Exp $	*/
a98 2
#include "faith.h"

a153 10

#if defined(NFAITH) && 0 < NFAITH
	if (m->m_pkthdr.rcvif) {
		if (m->m_pkthdr.rcvif->if_type == IFT_FAITH) {
			/* send icmp6 host unreach? */
			m_freem(m);
			return IPPROTO_DONE;
		}
	}
#endif
@


1.45
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.44 2011/11/24 17:39:55 sperreault Exp $	*/
d721 1
a721 1
		if (ia && ((struct in6_ifaddr *)ia)->ia6_flags &
@


1.44
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.43 2011/05/13 14:31:17 oga Exp $	*/
d524 1
a524 1
#ifdef MROUTING
d526 1
a526 1
#endif
d531 33
@


1.43
log
@Revert the pf->socket linking diff.

at least krw@@, pirofti@@ and todd@@ have been seeing panics (todd and krw
with xxxterm not sure about pirofti) involving pool corruption while
using this commit.

krw and todd confirm that this backout fixes the problem.

ok blambert@@ krw@@, todd@@ henning@@ and kettenis@@

	    Double link between pf states and sockets.  Henning has
	    already implemented half of it.  The additional part is: -
	    The pf state lookup for outgoing packets is optimized by
	    using mbuf->inp->state.
	    - For incomming tcp, udp, raw, raw6 packets the socket
	    lookup always is optimized by using mbuf->state->inp.
	    - All protocols establish the link for incomming packets.
	    - All protocols set the inp in the mbuf for outgoing packets.
	      This allows the linkage beginning with the first packet
	      for outgoing connections.
	    - In case of divert states, delete the state when the socket
	      closes.  Otherwise new connections could match on old
	      states instead of being diverted to the listen socket.
	    ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.42 2011/04/24 19:36:54 bluhm Exp $	*/
d437 2
a438 1
		    &in6p->in6p_route, &in6p->in6p_laddr, &error)) == 0) {
d491 3
d684 1
a684 1
		    /* XXX */ 0)) == 0) {
d732 1
a732 1
		    &in6p->in6p_laddr, &error);
@


1.42
log
@Double link between pf states and sockets.  Henning has already
implemented half of it.  The additional part is:
- The pf state lookup for outgoing packets is optimized by using
  mbuf->inp->state.
- For incomming tcp, udp, raw, raw6 packets the socket lookup always
  is optimized by using mbuf->state->inp.
- All protocols establish the link for incomming packets.
- All protocols set the inp in the mbuf for outgoing packets.
  This allows the linkage beginning with the first packet for
  outgoing connections.
- In case of divert states, delete the state when the socket closes.
  Otherwise new connections could match on old states instead of
  being diverted to the listen socket.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.41 2011/04/04 11:07:18 claudio Exp $	*/
a63 2
#include "pf.h"

a77 3
#if NPF > 0
#include <net/pfvar.h>
#endif
a202 10
#if NPF > 0
		if (m->m_pkthdr.pf.statekey && !in6p->inp_pf_sk &&
		    !((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp &&
		    (in6p->inp_socket->so_state & SS_ISCONNECTED) &&
		    proto != IPPROTO_ICMPV6) {
			((struct pf_state_key *)m->m_pkthdr.pf.statekey)->inp =
			    in6p;
			in6p->inp_pf_sk = m->m_pkthdr.pf.statekey;
		}
#endif
a489 5
#if NPF > 0
	if (in6p->inp_socket->so_state & SS_ISCONNECTED &&
	    so->so_proto->pr_protocol != IPPROTO_ICMPV6)
		m->m_pkthdr.pf.inp = in6p;
#endif
@


1.41
log
@Add the same SS_CANTRCVMORE check as was done in the other input
functions. OK blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.40 2010/04/20 22:05:44 tedu Exp $	*/
d64 2
d80 3
d208 10
d505 5
@


1.40
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.39 2009/06/05 00:05:22 claudio Exp $	*/
d182 2
@


1.39
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.38 2008/11/23 13:30:59 claudio Exp $	*/
d72 1
@


1.38
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.37 2008/09/17 05:43:15 chl Exp $	*/
d676 2
a677 1
		    (ia = ifa_ifwithaddr((struct sockaddr *)addr)) == 0) {
@


1.37
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.36 2008/06/11 19:00:50 mcbride Exp $	*/
d440 3
a442 4
		if (in6p->in6p_route.ro_rt) {
			/* what if oifp contradicts ? */
			oifp = ifindex2ifnet[in6p->in6p_route.ro_rt->rt_ifp->if_index];
		}
@


1.36
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.35 2007/12/14 18:33:41 deraadt Exp $	*/
a255 2
	struct mbuf *m;
	int off;
a279 1
		m = ip6cp->ip6c_m;
a280 1
		off = ip6cp->ip6c_off;
a284 1
		m = NULL;
@


1.35
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.34 2007/10/29 16:19:24 chl Exp $	*/
d145 1
a145 3
rip6_input(mp, offp, proto)
	struct	mbuf **mp;
	int	*offp, proto;
d253 1
a253 4
rip6_ctlinput(cmd, sa, d)
	int cmd;
	struct sockaddr *sa;
	void *d;
d520 2
a521 5
rip6_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d572 2
a573 5
rip6_usrreq(so, req, m, nam, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
	struct proc *p;
@


1.34
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.33 2007/06/01 00:52:39 henning Exp $	*/
d72 1
d844 20
@


1.33
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.32 2007/02/14 00:53:48 jsg Exp $	*/
d621 2
a622 2
		MALLOC(in6p->in6p_icmp6filt, struct icmp6_filter *,
		    sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
d652 1
a652 1
			FREE(in6p->in6p_icmp6filt, M_PCB);
@


1.32
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.31 2006/12/09 01:12:28 itojun Exp $	*/
d498 1
a498 1
	    in6p->in6p_moptions, &oifp);
@


1.31
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.30 2006/05/27 23:40:27 claudio Exp $	*/
d642 1
a642 1
		/* Fallthrough */
@


1.30
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.29 2006/03/05 21:48:57 miod Exp $	*/
d205 1
a205 1
					ip6_savecontrol(last, &opts, ip6, n);
d224 1
a224 1
			ip6_savecontrol(last, &opts, ip6, m);
d391 3
a393 1
		if ((error = ip6_setpktoptions(control, &opt, priv)) != 0)
d513 2
a514 3
	if (optp == &opt && optp->ip6po_rthdr && optp->ip6po_route.ro_rt)
		RTFREE(optp->ip6po_route.ro_rt);
	if (control)
d516 1
@


1.29
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.28 2004/08/23 01:30:30 itojun Exp $	*/
d81 1
d83 1
d528 1
d530 1
d535 1
d552 1
d644 1
d647 1
@


1.28
log
@make sure we do not overwrite checksum field on shared mbuf.
markus, henning, deraadt, mcbride ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.27 2004/06/12 04:58:48 itojun Exp $	*/
d657 1
a657 1
		if ((ifnet.tqh_first == 0) || (addr->sin6_family != AF_INET6)) {
d708 1
a708 2
		if (ifnet.tqh_first == 0)
		{
@


1.27
log
@support IPV6_USE_MIN_MTU, to make BIND9 better.
(sorry about the mess yesterday)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.26 2004/06/11 14:27:13 deraadt Exp $	*/
d462 1
d464 2
a465 1
		u_int16_t sum;
d478 9
a486 4
		sum = 0;
		m_copyback(m, off, sizeof(sum), &sum);
		sum = in6_cksum(m, ip6->ip6_nxt, sizeof(*ip6), plen);
		m_copyback(m, off, sizeof(sum), &sum);
@


1.26
log
@back out tree breakage.  Like, come on
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.24 2004/04/22 18:01:15 itojun Exp $	*/
a482 1
#ifdef IN6P_MINMTU
a484 1
#endif
@


1.25
log
@support IPV6_USE_MIN_MTU, which is needed to run BIND9 well.  from kame
markus ok
@
text
@d483 1
d486 1
@


1.24
log
@correct arg to in6_cksum.  keiichi@@kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.23 2004/01/03 14:08:54 espie Exp $	*/
a482 1
#ifdef IN6P_MINMTU
a484 1
#endif
@


1.23
log
@put an mi wrapper around stdarg.h/varargs.h. gcc3 moved stdarg/varargs macros
to built-ins, so eventually we will have one version of these files.
Special adjustments for the kernel to cope: machine/stdarg.h -> sys/stdarg.h
and machine/ansi.h needs to have a _BSD_VA_LIST_ for syslog* prototypes.
okay millert@@, drahn@@, miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.22 2003/12/21 14:57:19 markus Exp $	*/
d193 1
a193 1
			if (in6_cksum(m, ip6->ip6_nxt, *offp,
@


1.22
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.21 2003/10/01 21:41:05 itojun Exp $	*/
d93 1
a93 1
#include <machine/stdarg.h>
@


1.21
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.20 2003/08/14 19:00:13 jason Exp $	*/
d179 1
a179 4
	for (in6p = rawin6pcbtable.inpt_queue.cqh_first;
	     in6p != (struct inpcb *)&rawin6pcbtable.inpt_queue;
	     in6p = in6p->inp_queue.cqe_next)
	{
@


1.20
log
@m_copyback()'s 4th arg is const void *, nuke (caddr_t) casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.19 2003/06/02 23:28:16 millert Exp $	*/
a175 3
#if 0 /* XXX inbound flowlabel */
	rip6src.sin6_flowinfo = ip6->ip6_flow & IPV6_FLOWINFO_MASK;
#endif
@


1.19
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.18 2003/05/27 22:52:17 itojun Exp $	*/
d483 1
a483 1
		m_copyback(m, off, sizeof(sum), (caddr_t)&sum);
d485 1
a485 1
		m_copyback(m, off, sizeof(sum), (caddr_t)&sum);
@


1.18
log
@don't use M_WAIT here.  we could be in splnet, and caller may not be
xx_usrreq.  henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.17 2002/09/11 03:27:30 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.17
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.16 2002/09/11 03:15:36 itojun Exp $	*/
d421 5
a425 1
	M_PREPEND(m, sizeof(*ip6), M_WAIT);
@


1.16
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.15 2002/07/20 23:00:33 itojun Exp $	*/
d250 1
a250 1
			char *prvnxtp = ip6_get_prevhdr(m, *offp); /* XXX */
d254 1
a254 1
			    prvnxtp - mtod(m, char *));
@


1.15
log
@remove unused extern decl (commented out).  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.14 2002/06/09 14:38:39 itojun Exp $	*/
d514 1
a514 1
	return(error);
d809 1
a809 1
		return(0);
d834 1
a834 1
	return(error);
@


1.14
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.13 2002/06/08 21:51:08 itojun Exp $	*/
a580 1
/*	extern	struct socket *ip6_mrouter; */ /* xxx */
@


1.13
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.12 2002/06/07 22:08:41 itojun Exp $	*/
d493 1
a493 1
	
d614 1
a614 1
		
@


1.12
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.11 2002/06/07 21:47:44 itojun Exp $	*/
d600 1
a600 1
		s = splnet();
@


1.11
log
@move IPV6_CHECKSUM processing to ip6_raw_ctloutput().  bunch of KNFs.
rip6 stats.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.10 2002/03/19 01:39:04 itojun Exp $	*/
d444 2
a445 3
		if ((in6a = in6_selectsrc(dstsock, optp,
		    in6p->in6p_moptions, &in6p->in6p_route,
		    &in6p->in6p_laddr, &error)) == 0) {
@


1.10
log
@check sa_len/family strictly
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.9 2002/03/15 18:19:53 millert Exp $	*/
d95 1
d128 2
d157 2
d196 1
a196 1
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
d199 1
a199 6
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
			continue;
		if (in6p->in6p_cksum != -1
		 && in6_cksum(m, ip6->ip6_nxt, *offp, m->m_pkthdr.len - *offp))
		{
			/* XXX bark something */
d201 7
d217 1
a217 2
						(struct sockaddr *)&rip6src,
						 n, opts) == 0) {
d222 1
d236 1
a236 1
				(struct sockaddr *)&rip6src, m, opts) == 0) {
d240 1
d244 3
d253 2
a254 2
				    ICMP6_PARAMPROB_NEXTHEADER,
				    prvnxtp - mtod(m, char *));
d345 1
a345 1
		 * - recalcurate the new MTU and create the
d445 2
a446 4
					  in6p->in6p_moptions,
					  &in6p->in6p_route,
					  &in6p->in6p_laddr,
					  &error)) == 0) {
d501 2
a502 1
	}
d522 1
a522 1
rip6_ctloutput(op, so, level, optname, m)
d526 1
a526 1
	struct mbuf **m;
d541 6
a546 6
				error = ip6_mrouter_set(optname, so, *m);
				if (*m)
					(void)m_free(*m);
			} else if (op == PRCO_GETOPT) {
				error = ip6_mrouter_get(optname, so, m);
			} else
d549 4
a553 2
		return (ip6_ctloutput(op, so, level, optname, m));
		/* NOTREACHED */
d560 1
a560 1
		return(icmp6_ctloutput(op, so, level, optname, m));
d563 3
a565 3
		if (op == PRCO_SETOPT && *m)
			(void)m_free(*m);
		return(EINVAL);
d591 1
a591 1
				    (struct ifnet *)control, p));
d617 1
a617 1
			sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
d667 1
a667 1
				scope6_addr2default(&addr->sin6_addr);
d689 1
a689 2
		if (ia &&
		    ((struct in6_ifaddr *)ia)->ia6_flags &
d727 1
a727 1
				scope6_addr2default(&addr->sin6_addr);
d733 2
a734 4
				     in6p->in6p_moptions,
				     &in6p->in6p_route,
				     &in6p->in6p_laddr,
				     &error);
d776 1
a776 1
				sizeof(struct in6_addr));
d799 1
a799 1
				scope6_addr2default(&dst->sin6_addr);
@


1.9
log
@Kill #if __STDC__ used to do K&R vs. ANSI varargs/stdarg; just do things
the ANSI way.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.8 2002/03/14 01:27:12 millert Exp $	*/
d774 5
d781 5
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.7 2001/12/07 09:16:07 itojun Exp $	*/
a357 1
#if __STDC__
a358 5
#else
rip6_output(m, va_alist)
	struct mbuf *m;
	va_dcl
#endif
@


1.7
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.6 2001/12/06 04:19:26 itojun Exp $	*/
d262 1
a262 1
	void (*notify) __P((struct in6pcb *, int)) = in6_rtchange;
@


1.7.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.7 2001/12/07 09:16:07 itojun Exp $	*/
a94 1
#include <netinet6/raw_ip6.h>
a126 2
struct rip6stat rip6stat;

a153 2
	rip6stat.rip6s_ipackets++;

d191 1
a191 1
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
d194 6
a199 1
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
a200 7
		if (in6p->in6p_cksum != -1) {
			rip6stat.rip6s_isum++;
			if (in6_cksum(m, ip6->ip6_nxt, *offp,
			    m->m_pkthdr.len - *offp)) {
				rip6stat.rip6s_badsum++;
				continue;
			}
d210 2
a211 1
				    (struct sockaddr *)&rip6src, n, opts) == 0) {
a215 1
					rip6stat.rip6s_fullsock++;
d229 1
a229 1
		    (struct sockaddr *)&rip6src, m, opts) == 0) {
a232 1
			rip6stat.rip6s_fullsock++;
a235 3
		rip6stat.rip6s_nosock++;
		if (m->m_flags & M_MCAST)
			rip6stat.rip6s_nosockmcast++;
d242 2
a243 2
			    ICMP6_PARAMPROB_NEXTHEADER,
			    prvnxtp - mtod(m, char *));
d262 1
a262 1
	void (*notify)(struct in6pcb *, int) = in6_rtchange;
d334 1
a334 1
		 * - recalculate the new MTU and create the
d358 1
d360 5
d439 5
a443 2
		if ((in6a = in6_selectsrc(dstsock, optp, in6p->in6p_moptions,
		    &in6p->in6p_route, &in6p->in6p_laddr, &error)) == 0) {
d498 1
a498 2
	} else
		rip6stat.rip6s_opackets++;
d518 1
a518 1
rip6_ctloutput(op, so, level, optname, mp)
d522 1
a522 1
	struct mbuf **mp;
d537 6
a542 6
				error = ip6_mrouter_set(optname, so, *mp);
				if (*mp)
					(void)m_free(*mp);
			} else if (op == PRCO_GETOPT)
				error = ip6_mrouter_get(optname, so, mp);
			else
a544 4
		case IPV6_CHECKSUM:
			return (ip6_raw_ctloutput(op, so, level, optname, mp));
		default:
			return (ip6_ctloutput(op, so, level, optname, mp));
d546 2
d554 1
a554 1
		return (icmp6_ctloutput(op, so, level, optname, mp));
d557 3
a559 3
		if (op == PRCO_SETOPT && *mp)
			m_free(*mp);
		return EINVAL;
d585 1
a585 1
		    (struct ifnet *)control, p));
d595 1
a595 1
		s = splsoftnet();
d611 1
a611 1
		    sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
d661 1
a661 1
			    scope6_addr2default(&addr->sin6_addr);
d683 2
a684 1
		if (ia && ((struct in6_ifaddr *)ia)->ia6_flags &
d722 1
a722 1
			    scope6_addr2default(&addr->sin6_addr);
d728 4
a731 2
		    in6p->in6p_moptions, &in6p->in6p_route,
		    &in6p->in6p_laddr, &error);
d773 1
a773 1
			    sizeof(struct in6_addr));
a779 5
			if (nam->m_len != sizeof(tmp)) {
				error = EINVAL;
				break;
			}

a781 5

			if (dst->sin6_family != AF_INET6) {
				error = EAFNOSUPPORT;
				break;
			}
d786 1
a786 1
			    scope6_addr2default(&dst->sin6_addr);
@


1.7.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.7.2.1 2002/06/11 03:31:38 art Exp $	*/
d250 1
a250 1
			u_int8_t *prvnxtp = ip6_get_prevhdr(m, *offp); /* XXX */
d254 1
a254 1
			    prvnxtp - mtod(m, u_int8_t *));
d493 1
a493 1

d514 1
a514 1
	return (error);
d581 1
d614 1
a614 1

d810 1
a810 1
		return (0);
d835 1
a835 1
	return (error);
@


1.6
log
@remove kame IPSEC code within #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.5 2001/04/06 04:42:09 csapuntz Exp $	*/
d175 1
a175 1
#if 0 /*XXX inbound flowlabel */
d693 1
a693 1
		
d695 1
a695 1
	    {
d741 1
a741 1
	    }
d758 1
a758 1
	    {
d792 1
a792 1
	    }
@


1.5
log
@

Move offsetof define into sys/param.h
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.4 2001/03/04 16:48:25 itojun Exp $	*/
a95 8
#ifdef __OpenBSD__
#undef IPSEC
#endif

#ifdef IPSEC
#include <netinet6/ipsec.h>
#endif /*IPSEC*/

a485 7
#ifdef IPSEC
	if (ipsec_setsocket(m, so) != 0) {
		error = ENOBUFS;
		goto bad;
	}
#endif /*IPSEC*/

a608 7
#ifdef IPSEC
		error = ipsec_init_policy(so, &in6p->in6p_sp);
		if (error != 0) {
			in6_pcbdetach(in6p);
			break;
		}
#endif /*IPSEC*/
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.5 2001/04/06 04:42:09 csapuntz Exp $	*/
@


1.5.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 8
d183 1
a183 1
#if 0 /* XXX inbound flowlabel */
d494 7
d624 7
d715 1
a715 1

d717 1
a717 1
	{
d763 1
a763 1
	}
d780 1
a780 1
	{
d814 1
a814 1
	}
@


1.5.4.3
log
@Merge in -current from roughly a week ago
@
text
@d262 1
a262 1
	void (*notify)(struct in6pcb *, int) = in6_rtchange;
d358 1
d360 5
a779 5
			if (nam->m_len != sizeof(tmp)) {
				error = EINVAL;
				break;
			}

a781 5

			if (dst->sin6_family != AF_INET6) {
				error = EAFNOSUPPORT;
				break;
			}
@


1.5.4.4
log
@Sync the SMP branch with 3.3
@
text
@a94 1
#include <netinet6/raw_ip6.h>
a126 2
struct rip6stat rip6stat;

a153 2
	rip6stat.rip6s_ipackets++;

d191 1
a191 1
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
d194 6
a199 1
		    !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
a200 7
		if (in6p->in6p_cksum != -1) {
			rip6stat.rip6s_isum++;
			if (in6_cksum(m, ip6->ip6_nxt, *offp,
			    m->m_pkthdr.len - *offp)) {
				rip6stat.rip6s_badsum++;
				continue;
			}
d210 2
a211 1
				    (struct sockaddr *)&rip6src, n, opts) == 0) {
a215 1
					rip6stat.rip6s_fullsock++;
d229 1
a229 1
		    (struct sockaddr *)&rip6src, m, opts) == 0) {
a232 1
			rip6stat.rip6s_fullsock++;
a235 3
		rip6stat.rip6s_nosock++;
		if (m->m_flags & M_MCAST)
			rip6stat.rip6s_nosockmcast++;
d239 1
a239 1
			u_int8_t *prvnxtp = ip6_get_prevhdr(m, *offp); /* XXX */
d242 2
a243 2
			    ICMP6_PARAMPROB_NEXTHEADER,
			    prvnxtp - mtod(m, u_int8_t *));
d334 1
a334 1
		 * - recalculate the new MTU and create the
d433 5
a437 2
		if ((in6a = in6_selectsrc(dstsock, optp, in6p->in6p_moptions,
		    &in6p->in6p_route, &in6p->in6p_laddr, &error)) == 0) {
d485 1
a485 1

d492 1
a492 2
	} else
		rip6stat.rip6s_opackets++;
d505 1
a505 1
	return (error);
d512 1
a512 1
rip6_ctloutput(op, so, level, optname, mp)
d516 1
a516 1
	struct mbuf **mp;
d531 6
a536 6
				error = ip6_mrouter_set(optname, so, *mp);
				if (*mp)
					(void)m_free(*mp);
			} else if (op == PRCO_GETOPT)
				error = ip6_mrouter_get(optname, so, mp);
			else
a538 4
		case IPV6_CHECKSUM:
			return (ip6_raw_ctloutput(op, so, level, optname, mp));
		default:
			return (ip6_ctloutput(op, so, level, optname, mp));
d540 2
d548 1
a548 1
		return (icmp6_ctloutput(op, so, level, optname, mp));
d551 3
a553 3
		if (op == PRCO_SETOPT && *mp)
			m_free(*mp);
		return EINVAL;
d570 1
d579 1
a579 1
		    (struct ifnet *)control, p));
d589 1
a589 1
		s = splsoftnet();
d603 1
a603 1

d605 1
a605 1
		    sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
d655 1
a655 1
			    scope6_addr2default(&addr->sin6_addr);
d677 2
a678 1
		if (ia && ((struct in6_ifaddr *)ia)->ia6_flags &
d716 1
a716 1
			    scope6_addr2default(&addr->sin6_addr);
d722 4
a725 2
		    in6p->in6p_moptions, &in6p->in6p_route,
		    &in6p->in6p_laddr, &error);
d767 1
a767 1
			    sizeof(struct in6_addr));
d790 1
a790 1
			    scope6_addr2default(&dst->sin6_addr);
d802 1
a802 1
		return (0);
d827 1
a827 1
	return (error);
@


1.5.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.5.4.4 2003/03/28 00:41:30 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
d421 1
a421 5
	M_PREPEND(m, sizeof(*ip6), M_DONTWAIT);
	if (!m) {
		error = ENOBUFS;
		goto bad;
	}
@


1.5.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d93 1
a93 1
#include <sys/stdarg.h>
d176 3
d182 4
a185 1
	CIRCLEQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
d483 1
a483 1
		m_copyback(m, off, sizeof(sum), &sum);
d485 1
a485 1
		m_copyback(m, off, sizeof(sum), &sum);
@


1.5.4.7
log
@Merge with the trunk
@
text
@d193 1
a193 1
			if (in6_cksum(m, proto, *offp,
@


1.5.4.8
log
@sync to HEAD
@
text
@d483 1
d486 1
@


1.4
log
@avoid possible align issue.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.3 2001/02/16 16:08:01 itojun Exp $	*/
a475 2

#define	offsetof(type, member)	((size_t)(&((type *)0)->member)) /* XXX */
@


1.3
log
@oops, remove #ifdef __fooBSD__.
@
text
@d1 2
a2 2
/*	$OpenBSD: raw_ip6.c,v 1.2 2001/02/16 16:01:00 itojun Exp $	*/
/*	$KAME: raw_ip6.c,v 1.65 2001/02/08 18:36:17 itojun Exp $	*/
a473 1
		struct mbuf *n;
d475 1
a475 1
		u_int16_t *p;
d490 4
a493 10
		n = m;
		while (n && n->m_len <= off) {
			off -= n->m_len;
			n = n->m_next;
		}
		if (!n)
			goto bad;
		p = (u_int16_t *)(mtod(n, caddr_t) + off);
		*p = 0;
		*p = in6_cksum(m, ip6->ip6_nxt, sizeof(*ip6), plen);
@


1.2
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ip6.c,v 1.1 2001/02/08 18:46:23 itojun Exp $	*/
a282 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a284 1
#endif
a304 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a317 5
#ifdef __NetBSD__
		in6p = in6_pcblookup_connect(&rawin6pcb,
		    &sa6->sin6_addr, 0,
		    (struct in6_addr *)&sa6_src->sin6_addr, 0, 0);
#elif defined(__OpenBSD__)
a319 1
#endif
a328 4
#ifdef __NetBSD__
			in6p = in6_pcblookup_bind(&rawin6pcb,
			    &sa6->sin6_addr, 0, 0))
#elif defined(__OpenBSD__)
a331 1
#endif
a355 1
#endif
a356 1
#ifdef __OpenBSD__
a358 4
#else
	(void) in6_pcbnotify(&rawin6pcb, sa, 0,
	    (struct sockaddr *)sa6_src, 0, cmd, cmdarg, notify);
#endif
@


1.1
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a263 1
	struct sockaddr_in6 sa6;
d267 3
d271 1
d283 4
d292 1
a292 1
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
d296 3
d302 3
d307 5
a311 4
	/* translate addresses into internal form */
	sa6 = *(struct sockaddr_in6 *)sa;
	if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)
		sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
a312 1
	if (ip6) {
d314 5
a318 2
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
d320 32
a351 1
		struct in6_addr s;
d353 8
a360 4
		/* translate addresses into internal form */
		bcopy(&ip6->ip6_src, &s, sizeof(s));
		if (IN6_IS_ADDR_LINKLOCAL(&s))
			s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d362 7
a368 5
		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6,
					0, &s, 0, cmd, notify);
	} else {
		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6, 0,
					&zeroin6_addr, 0, cmd, notify);
d370 9
@

