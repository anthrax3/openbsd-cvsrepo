head	1.41;
access;
symbols
	OPENBSD_5_8:1.40.0.4
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.36.0.2
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.6
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.30.0.8
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.27.0.4
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.4
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.22.0.12
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.10
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.8
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.6
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.4
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.2
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.21.0.6
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.21
	OPENBSD_3_3:1.21.0.4
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.2
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.19.0.4
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.21
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.18.0.2
	OPENBSD_3_0_BASE:1.18
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.7.0.6
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.4
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.41
date	2015.09.28.08.32.05;	author mpi;	state dead;
branches;
next	1.40;
commitid	MCjArMsyMPhqxF1g;

1.40
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.39;
commitid	h7z8lokZ0dFyuWpg;

1.39
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.38;
commitid	4Ro7ulidQXNcMvmM;

1.38
date	2015.05.12.12.27.17;	author mpi;	state Exp;
branches;
next	1.37;
commitid	4yX3v2RRayuqFsNr;

1.37
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.36;
commitid	p4LJxGKbi0BU2cG6;

1.36
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	VK3ncyiP3NS1N4Sy;

1.35
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.34;
commitid	zhW8jJrfVCoAthrR;

1.34
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.33;
commitid	t9FBKDfc4VDxpEy2;

1.33
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.32;
commitid	ZqXwxwmeo3l29NOg;

1.32
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.31;
commitid	DQakU8LLWV6Iwx84;

1.31
date	2013.05.31.15.04.23;	author bluhm;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.03.13.54.21;	author stsp;	state Exp;
branches;
next	1.29;

1.29
date	2010.05.11.09.36.07;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.28.15.25.32;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.24;

1.24
date	2007.02.15.22.45.09;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.10.15.34.22;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.03.14.51.05;	author markus;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.30.04.19.44;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.29.23.38.58;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.08.19.06.31.56;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.07.27.15.48.38;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.08.10.39.37;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.05.30.12.31.09;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.11.17.20.12;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.16.08.48.05;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.31.17.23.35;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.12.30.21.51.00;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.30.19.03.44;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.07.06.18.44;	author itojun;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.21.03.15.06;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.12.06.35.04;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.15.07.08.00;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.27;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.55.19;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	;


desc
@@


1.41
log
@Merge gif(4)'s tentacles in a single file.

Tested by <mxb AT alumni DOT chalmers DOT se>.

ok dlg@@
@
text
@/*	$OpenBSD: in6_gif.c,v 1.40 2015/06/16 11:09:40 mpi Exp $	*/
/*	$KAME: in6_gif.c,v 1.43 2001/01/22 07:27:17 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/protosw.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet/ip_ipsp.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/in6_gif.h>

#include <netinet/ip_ecn.h>

#include <net/if_gif.h>

#include "bridge.h"
#if NBRIDGE > 0 || defined(MPLS)
#include <netinet/ip_ether.h>
#endif

/*
 * family - family of the packet to be encapsulate.
 */
int
in6_gif_output(struct ifnet *ifp, int family, struct mbuf **m0)
{
	struct gif_softc *sc = (struct gif_softc*)ifp;
	struct sockaddr_in6 *sin6_src = satosin6(sc->gif_psrc);
	struct sockaddr_in6 *sin6_dst = satosin6(sc->gif_pdst);
	struct tdb tdb;
	struct xformsw xfs;
	int error;
	struct mbuf *m = *m0;

	if (sin6_src == NULL || sin6_dst == NULL ||
	    sin6_src->sin6_family != AF_INET6 ||
	    sin6_dst->sin6_family != AF_INET6) {
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* setup dummy tdb.  it highly depends on ipip_output() code. */
	bzero(&tdb, sizeof(tdb));
	bzero(&xfs, sizeof(xfs));
	tdb.tdb_src.sin6.sin6_family = AF_INET6;
	tdb.tdb_src.sin6.sin6_len = sizeof(struct sockaddr_in6);
	tdb.tdb_src.sin6.sin6_addr = sin6_src->sin6_addr;
	tdb.tdb_dst.sin6.sin6_family = AF_INET6;
	tdb.tdb_dst.sin6.sin6_len = sizeof(struct sockaddr_in6);
	tdb.tdb_dst.sin6.sin6_addr = sin6_dst->sin6_addr;
	tdb.tdb_xform = &xfs;
	xfs.xf_type = -1;	/* not XF_IP4 */

	switch (family) {
	case AF_INET:
		break;
#ifdef INET6
	case AF_INET6:
		break;
#endif
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif
#ifdef MPLS
	case AF_MPLS:
		break;
#endif
	default:
#ifdef DEBUG
		printf("in6_gif_output: warning: unknown family %d passed\n",
			family);
#endif
		m_freem(m);
		return EAFNOSUPPORT;
	}

	/* encapsulate into IPv6 packet */
	*m0 = NULL;
#if NBRIDGE > 0
	if (family == AF_LINK)
		error = etherip_output(m, &tdb, m0, IPPROTO_ETHERIP);
	else
#endif /* NBRIDGE */
#if MPLS
	if (family == AF_MPLS)
		error = etherip_output(m, &tdb, m0, IPPROTO_MPLS);
	else
#endif
	error = ipip_output(m, &tdb, m0, 0, 0);
	if (error)
	        return error;
	else if (*m0 == NULL)
	        return EFAULT;

	m = *m0;

#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	return 0;
}

int in6_gif_input(struct mbuf **mp, int *offp, int proto)
{
	struct mbuf *m = *mp;
	struct gif_softc *sc;
	struct ifnet *gifp = NULL;
	struct ip6_hdr *ip6;

	/* XXX What if we run transport-mode IPsec to protect gif tunnel ? */
	if (m->m_flags & (M_AUTH | M_CONF))
	        goto inject;

	ip6 = mtod(m, struct ip6_hdr *);

#define satoin6(sa)	(satosin6(sa)->sin6_addr)
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
		    sc->gif_psrc->sa_family != AF_INET6 ||
		    sc->gif_pdst->sa_family != AF_INET6) {
			continue;
		}

		if ((sc->gif_if.if_flags & IFF_UP) == 0)
			continue;

		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst), &ip6->ip6_src)) {
			gifp = &sc->gif_if;
			break;
		}
	}

	if (gifp) {
	        m->m_pkthdr.ph_ifidx = gifp->if_index;
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
		ipip_input(m, *offp, gifp, proto);
		return IPPROTO_DONE;
	}

inject:
	/* No GIF tunnel configured */
	ip4_input6(&m, offp, proto);
	return IPPROTO_DONE;
}
@


1.40
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.39 2015/06/08 22:19:28 krw Exp $	*/
@


1.39
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.38 2015/05/12 12:27:17 mpi Exp $	*/
d182 1
a182 1
	        m->m_pkthdr.rcvif = gifp;
@


1.38
log
@MPLS also needs a definition for etherip_output(), fix build without
bridge.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.37 2015/03/14 03:38:52 jsg Exp $	*/
d123 1
a123 1
	
@


1.37
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.36 2015/01/24 00:29:06 deraadt Exp $	*/
d63 1
a63 1
#if NBRIDGE > 0
@


1.36
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.35 2014/12/19 17:14:40 tedu Exp $	*/
a52 2

#include <netinet/ip.h>
@


1.35
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.34 2014/12/05 15:50:04 mpi Exp $	*/
d47 3
a52 3

#include <netinet/in.h>
#include <netinet/ip_ipsp.h>
@


1.34
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.33 2014/09/08 06:24:13 jsg Exp $	*/
a53 1
#ifdef INET
a54 1
#endif
a102 1
#ifdef INET
a104 1
#endif
@


1.33
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.32 2014/07/22 11:06:10 mpi Exp $	*/
d45 1
@


1.32
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.31 2013/05/31 15:04:23 bluhm Exp $	*/
a44 1
#include <net/route.h>
@


1.31
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.30 2011/04/03 13:54:21 stsp Exp $	*/
a51 1
#include <netinet/in_systm.h>
@


1.30
log
@Kill redundant offsetof definitions; ok deraadt henning sthen thib
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.29 2010/05/11 09:36:07 claudio Exp $	*/
d79 2
a80 2
	struct sockaddr_in6 *sin6_src = (struct sockaddr_in6 *)sc->gif_psrc;
	struct sockaddr_in6 *sin6_dst = (struct sockaddr_in6 *)sc->gif_pdst;
d170 1
a170 1
#define satoin6(sa)	(((struct sockaddr_in6 *)(sa))->sin6_addr)
@


1.29
log
@Massiv cleanup of the gif(4) mess. Move encapsulation into gif_output()
where it is not necessary to guess protocols by looking at the first nibble.
in_gif_output() will encapsulate the packet but not send it. Because of
etherip support and the way the bridge works a minimal hack is needed in
gif_start() to ensure that the bridged packets are encapsulated as well.
This actually started with the idea to add MPLS support but that turned out
to be not as simple as in the gre(4) case.
Tested by myself (IP, IPv6, etherip, MPLS), sthen@@ (IP, IPv6), naddy (IPv6)
OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.28 2010/05/07 13:33:17 claudio Exp $	*/
a69 4
#endif

#ifndef offsetof
#define offsetof(s, e) ((int)&((s *)0)->e)
@


1.28
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.27 2008/09/28 15:25:32 jsing Exp $	*/
a62 4
#ifdef INET6
#include <netinet/ip6.h>
#endif

d68 3
d80 1
a80 1
in6_gif_output(struct ifnet *ifp, int family, struct mbuf *m)
a82 1
	struct sockaddr_in6 *dst = (struct sockaddr_in6 *)&sc->gif_ro6.ro_dst;
d88 1
a88 1
	struct mbuf *mp;
d121 5
a125 1
#endif /* NBRIDGE */
d136 1
a136 1
	mp = NULL;
d139 1
a139 1
		error = etherip_output(m, &tdb, &mp, 0, 0);
d142 6
a147 1
	error = ipip_output(m, &tdb, &mp, 0, 0);
d150 1
a150 1
	else if (mp == NULL)
d153 1
a153 17
	m = mp;

	/* See if out cached route remains the same */
	if (dst->sin6_family != sin6_dst->sin6_family ||
	     !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &sin6_dst->sin6_addr)) {
		/* cache route doesn't match */
		bzero(dst, sizeof(*dst));
		dst->sin6_family = sin6_dst->sin6_family;
		dst->sin6_len = sizeof(struct sockaddr_in6);
		dst->sin6_addr = sin6_dst->sin6_addr;
		/* XXX rdomain */
		sc->gif_ro6.ro_tableid = 0;
		if (sc->gif_ro6.ro_rt) {
			RTFREE(sc->gif_ro6.ro_rt);
			sc->gif_ro6.ro_rt = NULL;
		}
	}
a154 13
	if (sc->gif_ro6.ro_rt == NULL) {
		rtalloc((struct route *)&sc->gif_ro6);
		if (sc->gif_ro6.ro_rt == NULL) {
			m_freem(m);
			return ENETUNREACH;
		}
	}
	
	/*
	 * force fragmentation to minimum MTU, to avoid path MTU discovery.
	 * it is too painful to ask for resend of inner packet, to achieve
	 * path MTU discovery for encapsulated packets.
	 */
d158 1
a158 3
	error = ip6_output(m, 0, &sc->gif_ro6, IPV6_MINMTU, 0, NULL, NULL);

	return error;
d196 1
a196 1
		ipip_input(m, *offp, gifp);
d202 1
a202 1
	ip4_input6(&m, offp, 0); /* XXX last argument ignored */
@


1.27
log
@Clear the PF state key before an IP packet exits a gif(4) tunnel, in order
to prevent state key mismatches.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.25 2007/06/01 00:52:38 henning Exp $	*/
d156 2
@


1.26
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d33 2
d47 4
d84 1
a84 1
     struct sockaddr_in6 *dst = (struct sockaddr_in6 *)&sc->gif_ro6.ro_dst;
d175 3
@


1.25
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.24 2007/02/15 22:45:09 claudio Exp $	*/
d71 3
d75 1
a75 4
in6_gif_output(ifp, family, m)
	struct ifnet *ifp;
	int family; /* family of the packet to be encapsulate. */
	struct mbuf *m;
d78 1
a78 1
        struct sockaddr_in6 *dst = (struct sockaddr_in6 *)&sc->gif_ro6.ro_dst;
d174 1
a174 3
int in6_gif_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
@


1.24
log
@Simplify the #if NBRIDGE case as in in_gif.c:1.33.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.23 2007/02/10 15:34:22 claudio Exp $	*/
d169 1
a169 1
	error = ip6_output(m, 0, &sc->gif_ro6, IPV6_MINMTU, 0, NULL);
@


1.23
log
@Cleanup, kill dead code and unused arguments. Mostly stuff that is computed
and passed around but never used. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.22 2003/12/03 14:51:05 markus Exp $	*/
d127 2
d130 1
a130 2
	if (family == AF_LINK) {
	        mp = NULL;
d132 1
a132 8
		if (error)
		        return error;
		else if (mp == NULL)
		        return EFAULT;

		m = mp;
		goto sendit;
	}
a133 3

	/* encapsulate into IPv6 packet */
	mp = NULL;
a141 3
#if NBRIDGE > 0
 sendit:
#endif /* NBRIDGE */
@


1.22
log
@add support for ifconfig clone/destroy; ok henning deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.21 2002/05/30 04:19:44 itojun Exp $	*/
d72 1
a72 1
in6_gif_output(ifp, family, m, rt)
a75 1
	struct rtentry *rt;
a83 1
	int hlen, poff;
a107 8
	    {
		if (m->m_len < sizeof(struct ip)) {
			m = m_pullup(m, sizeof(struct ip));
			if (m == NULL)
				return ENOBUFS;
		}
		hlen = (mtod(m, struct ip *)->ip_hl) << 2;
		poff = offsetof(struct ip, ip_p);
a108 1
	    }
a111 3
	    {
		hlen = sizeof(struct ip6_hdr);
		poff = offsetof(struct ip6_hdr, ip6_nxt);
a112 1
	    }
d143 1
a143 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
@


1.21
log
@minor KNF.  nuke obsolete IFF_LINK0 support completely
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.20 2002/05/29 23:38:58 itojun Exp $	*/
a208 1
	int i;
d217 1
a217 1
	for (i = 0, sc = gif_softc; i < ngif; i++, sc++) {
@


1.20
log
@force fragment to minimum link MTU (1280) when needed (when PMTUD does
not take effect) - like icmp6 responses or foo-over-IPv6 tunnel.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.19 2001/12/07 09:16:07 itojun Exp $	*/
a94 6
	/* multi-destination mode is not supported */
	if (ifp->if_flags & IFF_LINK0) {
		m_freem(m);
		return ENETUNREACH;
	}

d219 1
a219 2
		if (sc->gif_psrc == NULL ||
		    sc->gif_pdst == NULL ||
d228 2
a229 12
		if ((sc->gif_if.if_flags & IFF_LINK0) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc),
				       &ip6->ip6_dst) &&
		    IN6_IS_ADDR_UNSPECIFIED(&satoin6(sc->gif_pdst))) {
			gifp = &sc->gif_if;
			continue;
		}

		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc),
				       &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst),
				       &ip6->ip6_src)) {
@


1.19
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.18 2001/08/19 06:31:56 angelos Exp $	*/
d197 8
a204 1
	return(ip6_output(m, 0, &sc->gif_ro6, 0, 0, NULL));
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.19 2001/12/07 09:16:07 itojun Exp $	*/
d95 6
d197 1
a197 8
	/*
	 * force fragmentation to minimum MTU, to avoid path MTU discovery.
	 * it is too painful to ask for resend of inner packet, to achieve
	 * path MTU discovery for encapsulated packets.
	 */
	error = ip6_output(m, 0, &sc->gif_ro6, IPV6_MINMTU, 0, NULL);

	return error;
d218 2
a219 1
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
d228 12
a239 2
		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst), &ip6->ip6_src)) {
@


1.18
log
@Pass the interface (if any) to ipip_input(), so it can be used in
BPF. Closes PR 2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.17 2001/07/27 15:48:38 itojun Exp $	*/
a30 4
 */

/*
 * in6_gif.c
@


1.17
log
@variable name "gif" is way too generic - use "gif_softc".  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.16 2001/06/09 06:43:37 angelos Exp $	*/
d253 1
a253 1
		ipip_input(m, *offp);
@


1.16
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.15 2001/06/08 10:39:37 art Exp $	*/
d221 1
a221 1
	for (i = 0, sc = gif; i < ngif; i++, sc++) {
@


1.15
log
@Update packet counters.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.14 2001/05/30 12:31:09 angelos Exp $	*/
a67 2

#include <net/net_osdep.h>
@


1.14
log
@Update for new prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.13 2001/05/11 17:20:12 aaron Exp $	*/
d253 2
@


1.13
log
@Check m_pullup() and m_pullup2() return for NULL, not 0; itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.12 2001/04/14 00:30:59 angelos Exp $	*/
d170 1
a170 1
	error = ipip_output(m, &tdb, &mp, hlen, poff, NULL);
@


1.12
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.11 2001/02/16 08:48:05 itojun Exp $	*/
d125 1
a125 1
			if (!m)
@


1.11
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.10 2000/12/31 17:23:35 angelos Exp $	*/
d170 1
a170 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
@


1.10
log
@Fix non-NBRIDGE case
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_gif.c,v 1.9 2000/12/30 21:51:00 angelos Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
@


1.9
log
@AF_LINK case
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.8 2000/12/30 19:03:44 angelos Exp $	*/
d177 1
d179 1
@


1.8
log
@Send AF_LINK to etherip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.7 2000/02/07 06:18:44 itojun Exp $	*/
d140 4
@


1.7
log
@s/DIAGNOSTIC/DEBUG/
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.6 2000/02/07 06:09:10 itojun Exp $	*/
d70 2
d149 14
d173 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6_gif.c,v 1.12 2001/04/14 00:30:59 angelos Exp $	*/
/*	$KAME: in6_gif.c,v 1.43 2001/01/22 07:27:17 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a69 2
#include "bridge.h"

a137 4
#if NBRIDGE > 0
	case AF_LINK:
		break;
#endif /* NBRIDGE */
a146 14
#if NBRIDGE > 0
	if (family == AF_LINK) {
	        mp = NULL;
		error = etherip_output(m, &tdb, &mp, 0, 0);
		if (error)
		        return error;
		else if (mp == NULL)
		        return EFAULT;

		m = mp;
		goto sendit;
	}
#endif /* NBRIDGE */

d149 1
a149 1
	error = ipip_output(m, &tdb, &mp, hlen, poff, NULL);
a156 3
#if NBRIDGE > 0
 sendit:
#endif /* NBRIDGE */
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.7.2.1 2001/05/14 22:40:17 niklas Exp $	*/
d69 2
d125 1
a125 1
			if (m == NULL)
d170 1
a170 1
	error = ipip_output(m, &tdb, &mp, hlen, poff);
a252 2
		gifp->if_ipackets++;
		gifp->if_ibytes += m->m_pkthdr.len;
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.7.2.2 2001/07/04 10:55:19 niklas Exp $	*/
d221 1
a221 1
	for (i = 0, sc = gif_softc; i < ngif; i++, sc++) {
d253 1
a253 1
		ipip_input(m, *offp, gifp);
@


1.7.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d31 4
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d95 6
d197 1
a197 8
	/*
	 * force fragmentation to minimum MTU, to avoid path MTU discovery.
	 * it is too painful to ask for resend of inner packet, to achieve
	 * path MTU discovery for encapsulated packets.
	 */
	error = ip6_output(m, 0, &sc->gif_ro6, IPV6_MINMTU, 0, NULL);

	return error;
d218 2
a219 1
		if (sc->gif_psrc == NULL || sc->gif_pdst == NULL ||
d228 12
a239 2
		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst), &ip6->ip6_src)) {
@


1.7.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d209 1
d218 1
a218 1
	LIST_FOREACH(sc, &gif_softc_list, gif_list) {
@


1.6
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.5 2000/01/21 03:15:06 angelos Exp $	*/
d139 1
a139 1
#ifdef DIAGNOSTIC
@


1.5
log
@Rename the ip4_* routines to ipip_*, make it so GIF tunnels are not
affected by net.inet.ipip.allow (the sysctl formerly known as
net.inet.ip4.allow), rename the VIF ipip_input to ipip_mroute_input.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.4 2000/01/12 06:35:04 angelos Exp $	*/
d56 1
a56 1
#include <netinet6/ip6.h>
d61 1
a61 1
#include <netinet6/ip6.h>
@


1.4
log
@Use netinet/ip_ip4.c routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.3 1999/12/15 07:08:00 itojun Exp $	*/
d104 1
a104 1
	/* setup dummy tdb.  it highly depends on ipe4_output() code. */
d149 1
a149 1
	error = ipe4_output(m, &tdb, &mp, hlen, poff);
d227 1
a227 1
	if (gifp && (m->m_flags & (M_AUTH | M_CONF)) == 0)
d229 3
d234 2
a235 1
	ip4_input(m, *offp);
@


1.3
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.2 1999/12/10 10:04:27 angelos Exp $	*/
d50 2
d55 1
d59 1
d63 1
d70 4
d82 1
a82 1
	struct sockaddr_in6 *dst = (struct sockaddr_in6 *)&sc->gif_ro6.ro_dst;
d85 5
a89 3
	struct ip6_hdr *ip6;
	int proto;
	u_int8_t itos, otos;
d98 18
d120 2
a121 5
		struct ip *ip;

		proto = IPPROTO_IPV4;
		if (m->m_len < sizeof(*ip)) {
			m = m_pullup(m, sizeof(*ip));
d125 2
a126 2
		ip = mtod(m, struct ip *);
		itos = ip->ip_tos;
d133 2
a134 9
		struct ip6_hdr *ip6;
		proto = IPPROTO_IPV6;
		if (m->m_len < sizeof(*ip6)) {
			m = m_pullup(m, sizeof(*ip6));
			if (!m)
				return ENOBUFS;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		itos = (ntohl(ip6->ip6_flow) >> 20) & 0xff;
d147 7
a153 8
	/* prepend new IP header */
	M_PREPEND(m, sizeof(struct ip6_hdr), M_DONTWAIT);
	if (m && m->m_len < sizeof(struct ip6_hdr))
		m = m_pullup(m, sizeof(struct ip6_hdr));
	if (m == NULL) {
		printf("ENOBUFS in in6_gif_output %d\n", __LINE__);
		return ENOBUFS;
	}
d155 1
a155 36
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow	= 0;
	ip6->ip6_vfc	&= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc	|= IPV6_VERSION;
	ip6->ip6_plen	= htons((u_short)m->m_pkthdr.len);
	ip6->ip6_nxt	= proto;
	ip6->ip6_hlim	= ip6_gif_hlim;
	ip6->ip6_src	= sin6_src->sin6_addr;
	if (ifp->if_flags & IFF_LINK0) {
		/* multi-destination mode */
		if (!IN6_IS_ADDR_UNSPECIFIED(&sin6_dst->sin6_addr))
			ip6->ip6_dst = sin6_dst->sin6_addr;
		else if (rt) {
			if (family != AF_INET6) {
				m_freem(m);
				return EINVAL;	/*XXX*/
			}
			ip6->ip6_dst = ((struct sockaddr_in6 *)(rt->rt_gateway))->sin6_addr;
		} else {
			m_freem(m);
			return ENETUNREACH;
		}
	} else {
		/* bidirectional configured tunnel mode */
		if (!IN6_IS_ADDR_UNSPECIFIED(&sin6_dst->sin6_addr))
			ip6->ip6_dst = sin6_dst->sin6_addr;
		else  {
			m_freem(m);
			return ENETUNREACH;
		}
	}
	if (ifp->if_flags & IFF_LINK1) {
		otos = 0;
		ip_ecn_ingress(ECN_ALLOWED, &otos, &itos);
		ip6->ip6_flow |= htonl((u_int32_t)otos << 20);
	}
d157 1
a168 3
#if 0
		sc->gif_if.if_mtu = GIF_MTU;
#endif
a176 4
#if 0
		ifp->if_mtu = sc->gif_ro6.ro_rt->rt_ifp->if_mtu
			- sizeof(struct ip6_hdr);
#endif
d191 4
a194 2
	int af = 0;
	u_int32_t otos;
d206 1
d209 1
d211 2
a212 1
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
d217 5
a221 2
		if (IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_psrc), &ip6->ip6_dst) &&
		    IN6_ARE_ADDR_EQUAL(&satoin6(sc->gif_pdst), &ip6->ip6_src)) {
d227 2
a228 8
	if (gifp == NULL) {
		m_freem(m);
		ip6stat.ip6s_nogif++;
		return IPPROTO_DONE;
	}
	
	otos = ip6->ip6_flow;
	m_adj(m, *offp);
d230 2
a231 42
	switch (proto) {
#ifdef INET
	case IPPROTO_IPV4:
	    {
		struct ip *ip;
		u_int8_t otos8;
		af = AF_INET;
		otos8 = (ntohl(otos) >> 20) & 0xff;
		if (m->m_len < sizeof(*ip)) {
			m = m_pullup(m, sizeof(*ip));
			if (!m)
				return IPPROTO_DONE;
		}
		ip = mtod(m, struct ip *);
		if (gifp->if_flags & IFF_LINK1)
			ip_ecn_egress(ECN_ALLOWED, &otos8, &ip->ip_tos);
		break;
	    }
#endif /* INET */
#ifdef INET6
	case IPPROTO_IPV6:
	    {
		struct ip6_hdr *ip6;
		af = AF_INET6;
		if (m->m_len < sizeof(*ip6)) {
			m = m_pullup(m, sizeof(*ip6));
			if (!m)
				return IPPROTO_DONE;
		}
		ip6 = mtod(m, struct ip6_hdr *);
		if (gifp->if_flags & IFF_LINK1)
			ip6_ecn_egress(ECN_ALLOWED, &otos, &ip6->ip6_flow);
		break;
	    }
#endif
	default:
		ip6stat.ip6s_nogif++;
		m_freem(m);
		return IPPROTO_DONE;
	}
		
	gif_input(m, af, gifp);
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_gif.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d139 2
a140 1
	ip6->ip6_vfc	= IPV6_VERSION;
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 7
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a41 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a42 1
#endif
a200 5
#ifdef IPSEC
#ifndef __OpenBSD__ /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif
#endif /*IPSEC*/
@

