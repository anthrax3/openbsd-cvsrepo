head	1.28;
access;
symbols
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	UBC_SYNC_A:1.28
	UBC_SYNC_B:1.28
	OPENBSD_2_8:1.27.0.2
	OPENBSD_2_8_BASE:1.27
	OPENBSD_2_7:1.17.0.2
	OPENBSD_2_7_BASE:1.17
	SMP:1.13.0.2
	SMP_BASE:1.13
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3;
locks; strict;
comment	@ * @;


1.28
date	2001.02.08.18.46.23;	author itojun;	state dead;
branches;
next	1.27;

1.27
date	2000.07.27.06.29.10;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.27.04.05.27;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.13.13.41.45;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.21.18.42.19;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.18.19.56.55;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.18.19.11.17;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.18.19.07.27;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.18.18.59.12;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.18.18.41.36;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.13.11.47.23;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.05.13.21.31.18;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.30.14.55.26;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.28.16.40.39;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.28.11.55.23;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.01.05.17.30.52;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	99.12.21.15.41.08;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	99.12.19.02.54.29;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	99.12.15.07.08.00;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	99.12.14.14.28.23;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.12.10.10.04.29;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.12.10.08.53.18;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.04.28.09.28.16;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.03.09.05.31.55;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.02.24.04.36.46;	author cmetz;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.58;	author deraadt;	state Exp;
branches;
next	;

1.13.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.05.14.22.40.21;	author niklas;	state dead;
branches;
next	;


desc
@@


1.28
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@/*	$OpenBSD: raw_ipv6.c,v 1.27 2000/07/27 06:29:10 itojun Exp $	*/

/*
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.

*/
/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)raw_ip.c	8.7 (Berkeley) 5/15/95
 *	$Id: raw_ipv6.c,v 1.27 2000/07/27 06:29:10 itojun Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <net/if.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/ip6_mroute.h>
#include <netinet6/ip6protosw.h>

#undef IPSEC

/*
 * Globals
 */

struct inpcbtable rawin6pcbtable;
struct sockaddr_in6 rip6src = { sizeof(struct sockaddr_in6), AF_INET6 };

/*
 * Nominal space allocated to a raw ip socket.
 */

#define	RIPV6SNDQ		8192
#define	RIPV6RCVQ		8192

#if 0
u_long rip6_sendspace = RIPV6SNDQ;
u_long rip6_recvspace = RIPV6RCVQ;
#else
extern u_long rip6_sendspace;
extern u_long rip6_recvspace;
#endif

/*
 * External globals
 */

#if 0
extern struct ip6_hdrstat ipv6stat;
#endif

/*
 * Raw IPv6 PCB initialization.
 */
void
rip6_init()
{
	in_pcbinit(&rawin6pcbtable, 1);
}

/*
 * At the point where this function gets called, we don't know the nexthdr of
 * the current header to be processed, only its offset. So we have to go find
 * it the hard way. In the case where there's no chained headers, this is not
 * really painful.
 *
 * The good news is that all fields have been sanity checked.
 *
 * Assumes m has already been pulled up by extra. -cmetz
 */
#if __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__
static __inline__ int
#else /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ */
static int
#endif /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ */
ipv6_findnexthdr(struct mbuf *m, size_t extra)
{
	caddr_t p = mtod(m, caddr_t);
	int nexthdr = IPPROTO_IPV6;
	unsigned int hl;

	do {
		switch (nexthdr) {
		case IPPROTO_IPV6:
			hl = sizeof(struct ip6_hdr);

			if ((extra -= hl) < 0)
				return -1;

			nexthdr = ((struct ip6_hdr *)p)->ip6_nxt;
			break;
		case IPPROTO_HOPOPTS:
		case IPPROTO_DSTOPTS:
			if (extra < sizeof(struct ip6_ext))
				return -1;

			hl = sizeof(struct ip6_ext) +
			    (((struct ip6_ext *)p)->ip6e_len << 3);

			if ((extra -= hl) < 0)
				return -1;

			nexthdr = ((struct ip6_ext *)p)->ip6e_nxt;
			break;
		case IPPROTO_ROUTING:
			if (extra < sizeof(struct ip6_rthdr0))
				return -1;

			hl = sizeof(struct ip6_rthdr0) +
			    (((struct ip6_rthdr0 *)p)->ip6r0_len << 3);

			if ((extra -= hl) < 0)
				return -1;

			nexthdr = ((struct ip6_rthdr0 *)p)->ip6r0_nxt;
			break;
#ifdef IPSEC
		case IPPROTO_AH:
			if (extra < sizeof(struct ip6_hdr_srcroute0))
				return -1;

			hl = sizeof(struct ip6_hdr_srcroute0) +
			((struct ip6_hdr_srcroute0 *)p)->i6sr_len << 3;

			if ((extra -= hl) < 0)
				return -1;

			nexthdr = ((struct ip6_hdr_srcroute0 *)p)->i6sr_nexthdr;
			break;
#endif /* IPSEC */
		default:
			return -1;
		}
		p += hl;
	} while (extra > 0);

	return nexthdr;
}

/*
 * If no HLP's are found for an IPv6 datagram, this routine is called.
 */
int
rip6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
{
	struct mbuf *m = *mp;
	/* Will have been pulled up by ipv6_input(). */
	register struct ip6_hdr *ip6;
	register struct inpcb *inp;
	int nexthdr, icmp6type;
	int foundone = 0;
	struct mbuf *m2 = NULL, *opts = NULL;
	struct sockaddr_in6 srcsa;
	int extra = *offp;

#ifdef DIAGNOSTIC
	if (m->m_len < sizeof(*ip6))
		panic("too short mbuf to rip6_input");
#endif
	ip6 = mtod(m, struct ip6_hdr *);

	/* Be proactive about malicious use of IPv4 mapped address */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		/* XXX stat */
		goto ret;
	}

	bzero(&opts, sizeof(opts));
	bzero(&srcsa, sizeof(struct sockaddr_in6));
	srcsa.sin6_family = AF_INET6;
	srcsa.sin6_len = sizeof(struct sockaddr_in6);
#if 0 /*XXX inbound flowinfo */
	srcsa.sin6_flowinfo = ip6->ip6_flow & IPV6_FLOWINFO_MASK;
#endif
	/* KAME hack: recover scopeid */
	(void)in6_recoverscope(&srcsa, &ip6->ip6_src, m->m_pkthdr.rcvif);

	if (m->m_len < extra) {
		if (!(m = m_pullup2(m, extra)))
			return IPPROTO_DONE;
		ip6 = mtod(m, struct ip6_hdr *);
	}

	if ((nexthdr = ipv6_findnexthdr(m, extra)) < 0)
		goto ret;

	if (nexthdr == IPPROTO_ICMPV6) {
		if (m->m_len < extra + sizeof(struct icmp6_hdr)) {
			m = m_pullup2(m, extra + sizeof(struct icmp6_hdr));
			if (!m)
				goto ret;

			ip6 = mtod(m, struct ip6_hdr *);
		}
		icmp6type = ((struct icmp6_hdr *)(mtod(m, caddr_t) + extra))->icmp6_type;
	} else
		icmp6type = -1;

	/*
	 * Locate raw PCB for incoming datagram.
	 */
	for (inp = rawin6pcbtable.inpt_queue.cqh_first;
	     inp != (struct inpcb *)&rawin6pcbtable.inpt_queue;
	     inp = inp->inp_queue.cqe_next) {
		if (!(inp->inp_flags & INP_IPV6))
			continue;
		if (inp->inp_ipv6.ip6_nxt && inp->inp_ipv6.ip6_nxt != nexthdr)
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) && 
		    !IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &ip6->ip6_dst))
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6) && 
		    !IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, &ip6->ip6_src))
			continue;
		/*
		 * inp_icmp6filt must not be NULL, but we add a check for
		 * safety
		 */
		if (icmp6type >= 0 && inp->inp_icmp6filt && 
		    ICMP6_FILTER_WILLBLOCK(icmp6type, inp->inp_icmp6filt))
			continue;

		foundone = 1;

		/*
		 * Note the inefficiency here; this is a consequence of the
		 * interfaces of the functions being used. The raw code is
		 * not performance critical enough to require an immediate fix.
		 * - cmetz
		 */
		if ((m2 = m_copym(m, 0, (int)M_COPYALL, M_DONTWAIT))) {
			m_adj(m2, extra);
			if (inp->inp_flags & IN6P_CONTROLOPTS)
				ip6_savecontrol(inp, &opts, ip6, m);
			else
				opts = NULL;
			if (sbappendaddr(&inp->inp_socket->so_rcv,
			    (struct sockaddr *)&srcsa, m2, opts)) {
				sorwakeup(inp->inp_socket);
			} else {
				m_freem(m2);
			}
		}
	}

	if (!foundone) {
		/*
		 * We should send an ICMPv6 protocol unreachable here,
		 * though original UCB 4.4-lite BSD's IPv4 does not do so.
		 */
#if 0
		ipv6stat.ips_noproto++;
		ipv6stat.ips_delivered--;
#endif
	}

ret:
	if (m)
		m_freem(m);

	return IPPROTO_DONE;
}

void
rip6_ctlinput(cmd, sa, d)
	int cmd;
	struct sockaddr *sa;
	void *d;
{
	struct sockaddr_in6 sa6;
	register struct ip6_hdr *ip6;
	struct mbuf *m;
	int off;
	void (*notify) __P((struct inpcb *, int)) = in_rtchange;

	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
		m = ip6cp->ip6c_m;
		ip6 = ip6cp->ip6c_ip6;
		off = ip6cp->ip6c_off;
	} else {
		m = NULL;
		ip6 = NULL;
	}

	/* translate addresses into internal form */
	sa6 = *(struct sockaddr_in6 *)sa;
	if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)
		sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

	if (ip6) {
		/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */
		struct in6_addr s;

		/* translate addresses into internal form */
		memcpy(&s, &ip6->ip6_src, sizeof(s));
		if (IN6_IS_ADDR_LINKLOCAL(&s))
			s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6,
					0, &s, 0, cmd, notify);
	} else {
		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6,
					0, &zeroin6_addr, 0, cmd, notify);
	}
}

/*
 * Output function for raw IPv6.  Called from rip6_usrreq(), and
 * ipv6_icmp_usrreq().
 */
int
rip6_output(struct mbuf *m, ...)
{
	register struct ip6_hdr *ip6;
	register struct inpcb *inp;
	int flags;
	int error = 0;
#if 0
	struct ifnet *forceif = NULL;
#endif
	struct ip6_pktopts opt, *optp = NULL, *origoptp;
	struct ifnet *oifp = NULL;
	va_list ap;
	struct socket *so;
	struct sockaddr_in6 *dst;
	struct mbuf *control;
	struct in6_addr *in6a;
	u_int8_t type, code;
	int plen = m->m_pkthdr.len;

	va_start(ap, m);
	so = va_arg(ap, struct socket *);
	dst = va_arg(ap, struct sockaddr_in6 *);
	control = va_arg(ap, struct mbuf *);
	va_end(ap);

	inp = sotoinpcb(so);
	flags = (so->so_options & SO_DONTROUTE);

	if (control) {
		error = ip6_setpktoptions(control, &opt,
		    so->so_state & SS_PRIV);
		if (error != 0)
			goto bad;
		optp = &opt;
	} else
		optp = NULL;

	/*
	 * For an ICMPv6 packet, we should know its type and code
	 * to update statistics.
	 */
	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
		struct icmp6_hdr *icmp6;
		if (m->m_len < sizeof(struct icmp6_hdr) &&
		    (m = m_pullup(m, sizeof(struct icmp6_hdr))) == NULL) {
			error = ENOBUFS;
			goto bad;
		}
		icmp6 = mtod(m, struct icmp6_hdr *);
		type = icmp6->icmp6_type;
		code = icmp6->icmp6_code;
	}

	M_PREPEND(m, sizeof(struct ip6_hdr), M_WAIT);
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = dst->sin6_flowinfo & IPV6_FLOWINFO_MASK;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	ip6->ip6_nxt = inp->inp_ipv6.ip6_nxt;
	/* ip6_src will be filled in later */

	/* KAME hack: embed scopeid */
	origoptp = inp->inp_outputopts6;
	inp->inp_outputopts6 = optp;
	if (in6_embedscope(&ip6->ip6_dst, dst, inp, &oifp) != 0) {
		error = EINVAL;
		goto bad;
	}
	inp->inp_outputopts6 = origoptp;

	/* source address selection */
	in6a = in6_selectsrc(dst, optp, inp->inp_moptions6, &inp->inp_route6,
	    &inp->inp_laddr6, &error);
	if (in6a == NULL) {
		if (error == 0)
			error = EADDRNOTAVAIL;
		goto bad;
	}
	ip6->ip6_src = *in6a;
	if (inp->inp_route6.ro_rt)	/* what if oifp contradicts ? */
		oifp = ifindex2ifnet[inp->inp_route6.ro_rt->rt_ifp->if_index];

	ip6->ip6_hlim = in6_selecthlim(inp, oifp);

	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6 ||
	    inp->inp_csumoffset != -1) {
		struct mbuf *n;
		int off;
		u_int16_t *p;

#define	offsetof(type, member)	((size_t)(&((type *)0)->member)) /* XXX */
		/* compute checksum */
		if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
			off = offsetof(struct icmp6_hdr, icmp6_cksum);
		else
			off = inp->inp_csumoffset;
		if (plen < off + 1) {
			error = EINVAL;
			goto bad;
		}
		off += sizeof(struct ip6_hdr);

		n = m;
		while (n && n->m_len <= off) {
			off -= n->m_len;
			n = n->m_next;
		}
		if (!n)
			goto bad;
		p = (u_int16_t *)(mtod(n, caddr_t) + off);
		*p = 0;
		*p = in6_cksum(m, ip6->ip6_nxt, sizeof(*ip6), plen);
	}

	error = ip6_output(m, optp, &inp->inp_route6, flags,
	    inp->inp_moptions6, &oifp);
	if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
		if (oifp)
			icmp6_ifoutstat_inc(oifp, type, code);
		icmp6stat.icp6s_outhist[type]++;
	}

	goto freectl;

bad:
	if (m)
		m_freem(m);

freectl:
	if (control)
		m_freem(control);
	return error;
}

/*
 * Handles [gs]etsockopt() calls.
 */
int
rip6_ctloutput(op, so, level, optname, m)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **m;
{
	register struct inpcb *inp = sotoinpcb(so);
	int error;

	if ((level != IPPROTO_IPV6) && (level != IPPROTO_ICMPV6)) {
		if (op == PRCO_SETOPT && *m)
			(void)m_free(*m);
		return(EINVAL);
	}

	switch (optname) {
	case MRT6_INIT:
	case MRT6_DONE:
	case MRT6_ADD_MIF:
	case MRT6_DEL_MIF:
	case MRT6_ADD_MFC:
	case MRT6_DEL_MFC:
	case MRT6_PIM:
		if (level != IPPROTO_IPV6) {
			if (op == PRCO_SETOPT && *m)
				(void)m_free(*m);
			return EINVAL;
		}

		if (op == PRCO_SETOPT) {
			error = ip6_mrouter_set(optname, so, *m);
			if (*m)
				(void)m_free(*m);
		} else if (op == PRCO_GETOPT)
			error = ip6_mrouter_get(optname, so, m);
		else
			error = EINVAL;
		return (error);

	case IPV6_CHECKSUM:
		if (op == PRCO_SETOPT || op == PRCO_GETOPT) {
			if (op == PRCO_SETOPT) {
				if (!m || !*m || (*m)->m_len != sizeof(int))
					return(EINVAL);
				inp->inp_csumoffset = *(mtod(*m, int *));
				m_freem(*m);
			} else {
				*m = m_get(M_WAIT, MT_SOOPTS);
				(*m)->m_len = sizeof(int);
				*(mtod(*m, int *)) = inp->inp_csumoffset;
			}
			return 0;
		}
		break;

	case ICMP6_FILTER:
		if (level != IPPROTO_ICMPV6) {
			if (op == PRCO_SETOPT && *m)
				(void)m_free(*m);
			return EINVAL;
		}

		if (op == PRCO_SETOPT || op == PRCO_GETOPT) {
			if (op == PRCO_SETOPT) {
				if (!m || !*m ||
				    (*m)->m_len != sizeof(struct icmp6_filter))
					return(EINVAL);
				bcopy(mtod(*m, struct icmp6_filter *),
				    inp->inp_icmp6filt,
				    sizeof(struct icmp6_filter));
				m_freem(*m);
			} else {
				*m = m_get(M_WAIT, MT_SOOPTS);
				(*m)->m_len = sizeof(struct icmp6_filter);
				*mtod(*m, struct icmp6_filter *) =
				    *inp->inp_icmp6filt;
			}
			return 0;
		}
		break;

	default:
		break;
	}
	return ip6_ctloutput(op, so, level, optname, m);
}

#if 1
#define MAYBESTATIC static
#define MAYBEINLINE __inline__
#else /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ */
#define MAYBESTATIC
#define MAYBEINLINE
#endif /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ */

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_attach(struct socket *so, int proto)
{
	register struct inpcb *inp = sotoinpcb(so);
	register int error = 0;

	if (inp)
		panic("rip6_attach - Already got PCB");

	if ((so->so_state & SS_PRIV) == 0) {
		error = EACCES;
		return error;
	}
	if ((error = soreserve(so, rip6_sendspace, rip6_recvspace)) ||
	    (error = in_pcballoc(so, &rawin6pcbtable))) {
		return error;
	}

	inp = sotoinpcb(so);
	/*nam;  Nam contains protocol type, apparently. */
#ifdef	__alpha__
	inp->inp_ipv6.ip6_nxt = (u_long)proto; 
#else
	inp->inp_ipv6.ip6_nxt = (int)proto;
#endif
	if (inp->inp_ipv6.ip6_nxt == IPPROTO_ICMPV6)
		inp->inp_csumoffset = 2;
	inp->inp_icmp6filt = (struct icmp6_filter *)
	malloc(sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
	ICMP6_FILTER_SETPASSALL(inp->inp_icmp6filt);
	return error;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_detach(struct socket *so)
{
	register struct inpcb *inp = sotoinpcb(so);

	if (inp == 0)
		panic("rip6_detach");
#ifdef MROUTING
	/* More MROUTING stuff. */
#endif
	if (inp->inp_icmp6filt) {
		free(inp->inp_icmp6filt, M_PCB);
		inp->inp_icmp6filt = NULL;
	}
	in_pcbdetach(inp);
	return 0;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_abort(struct socket *so)
{
	soisdisconnected(so);
	return rip6_usrreq_detach(so);
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_disconnect(struct socket *so)
{
	if ((so->so_state & SS_ISCONNECTED) == 0)
		return ENOTCONN;
	return rip6_usrreq_abort(so);
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_bind(struct socket *so, struct sockaddr *nam)
{
	register struct inpcb *inp = sotoinpcb(so);
	register struct sockaddr_in6 *addr = (struct sockaddr_in6 *)nam;

	/* 'ifnet' is declared in one of the net/ header files. */
	if ((ifnet.tqh_first == 0) || (addr->sin6_family != AF_INET6))
		return EADDRNOTAVAIL;

	/*
	 * Currently, ifa_ifwithaddr tends to fail for a link-local
	 * address, since it implicitly expects that the link identifier
	 * for the address is embedded in the sin6_addr part.
	 * For now, we'd rather keep this "as is". We'll eventually fix
	 * this in a more natural way.
	 */
	if (!IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr) &&
	     ifa_ifwithaddr((struct sockaddr *)addr) == 0) {
		return EADDRNOTAVAIL;
	}

	inp->inp_laddr6 = addr->sin6_addr;
	return 0;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_connect(struct socket *so, struct sockaddr *nam)
{
	register struct inpcb *inp = sotoinpcb(so);
	register struct sockaddr_in6 *addr = (struct sockaddr_in6 *) nam;
	int error;
	struct in6_addr *in6a;

	if (addr->sin6_family != AF_INET6)
		return EAFNOSUPPORT;

	in6a = in6_selectsrc(addr, inp->inp_outputopts6, inp->inp_moptions6,
	    &inp->inp_route6, &inp->inp_laddr6, &error);
	if (in6a == NULL) {
		if (error == 0)
			error = EADDRNOTAVAIL;
		return error;
	}
	inp->inp_laddr6 = *in6a;

	/* Will structure assignment work with this compiler? */
	inp->inp_faddr6 = addr->sin6_addr; 

	soisconnected(so);
	return 0;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_shutdown(struct socket *so)
{
	socantsendmore(so);
	return 0;
}

static int rip6_usrreq_send __P((struct socket *so, int flags, struct mbuf *m,
	struct sockaddr *addr, struct mbuf *control));

static int
rip6_usrreq_send(struct socket *so, int flags, struct mbuf *m,
		 struct sockaddr *addr, struct mbuf *control)
{
	register struct inpcb *inp = sotoinpcb(so);
	register int error = 0;
	struct sockaddr_in6 *dst, tmp;

	if (inp == 0) {
		m_freem(m);
		return EINVAL;
	}

	/*
	 * Check "connected" status, and if there is a supplied destination
	 * address.
	 */
	if (so->so_state & SS_ISCONNECTED) {
		if (addr)
			return EISCONN;

		bzero(&tmp, sizeof(tmp));
		tmp.sin6_family = AF_INET6;
		tmp.sin6_len = sizeof(tmp);
		tmp.sin6_addr = inp->inp_faddr6;
		dst = &tmp;
	} else {
		if (addr == NULL)
			return ENOTCONN;

		dst = (struct sockaddr_in6 *)addr;
	}

	error = rip6_output(m,so,dst,control);
	/* m = NULL; */
	return error;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_control(struct socket *so, u_long cmd, caddr_t data,
		    struct ifnet *ifp)
{
	/*
	 * Notice that IPv4 raw sockets don't pass PRU_CONTROL.  I wonder
	 * if they panic as well?
	 */
	return in6_control(so, cmd, data, ifp, 0);
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_sense(struct socket *so, struct stat *sb)
{
	/* services stat(2) call. */
	return 0;
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_sockaddr(struct socket *so, struct mbuf *nam)
{
	register struct inpcb *inp = sotoinpcb(so);
	return in6_setsockaddr(inp, nam);
}

MAYBESTATIC MAYBEINLINE int
rip6_usrreq_peeraddr(struct socket *so, struct mbuf *nam)
{
	register struct inpcb *inp = sotoinpcb(so);
	return in6_setpeeraddr(inp, nam);
}

/*
 * Handles PRU_* for raw IPv6 sockets.
 */
int
rip6_usrreq(so, req, m, nam, control, p)
	struct socket *so;
	int req;
	struct mbuf *m, *nam, *control;
	struct proc *p;
{
	register int error = 0;

#ifdef MROUTING
	/*
	 * Ummm, like, multicast routing stuff goes here, huh huh huh.
	 *
	 * Seriously, this would be for user-level multicast routing daemons.
	 * With multicast being a requirement for IPv6, code like what might go
	 * here may go away.
	 */
#endif

	switch (req) {
	case PRU_ATTACH:
		error = rip6_usrreq_attach(so, (long)nam);
		break;
	case PRU_DISCONNECT:
		error = rip6_usrreq_disconnect(so);
		break;
	case PRU_ABORT:
		error = rip6_usrreq_abort(so);
		break;
	case PRU_DETACH:
		error = rip6_usrreq_detach(so);
		break;
	case PRU_BIND:
		if (nam->m_len != sizeof(struct sockaddr_in6))
			return EINVAL;
		/*
		 * Be strict regarding sockaddr_in6 fields.
		 */
		error = rip6_usrreq_bind(so, mtod(nam, struct sockaddr *));
		break;
	case PRU_CONNECT:
		/*
		 * Be strict regarding sockaddr_in6 fields.
		 */
		if (nam->m_len != sizeof(struct sockaddr_in6))
			return EINVAL;
		error = rip6_usrreq_connect(so, mtod(nam, struct sockaddr *));
		break;
	case PRU_SHUTDOWN:
		error = rip6_usrreq_shutdown(so);
		break;
	case PRU_SEND:
		/*
		 * Be strict regarding sockaddr_in6 fields.
		 */
		if (nam->m_len != sizeof(struct sockaddr_in6))
			return EINVAL;
		error = rip6_usrreq_send(so, 0, m, mtod(nam, struct sockaddr *),
		    control);
		m = NULL;
		break;
	case PRU_CONTROL:
		return rip6_usrreq_control(so, (u_long)m, (caddr_t) nam,
		    (struct ifnet *) control);
	case PRU_SENSE:
		return rip6_usrreq_sense(so, NULL); /* XXX */
	case PRU_CONNECT2:
	case PRU_RCVOOB:
	case PRU_LISTEN:
	case PRU_SENDOOB:
	case PRU_RCVD:
	case PRU_ACCEPT:
		error = EOPNOTSUPP;
		break;
	case PRU_SOCKADDR:
		error = rip6_usrreq_sockaddr(so, nam);
		break;
	case PRU_PEERADDR:
		error = rip6_usrreq_peeraddr(so, nam);
		break;
	default:
		panic("rip6_usrreq - unknown req\n");
	}
	if (m != NULL)
		m_freem(m);
	return error;
}
@


1.27
log
@raw6/udp6 sockets are okay with :: in src.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.26 2000/07/27 04:05:27 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.26 2000/07/27 04:05:27 itojun Exp $
@


1.26
log
@be proactive about unspecified IPv6 source address.  pcb layer uses
unspecified address (::) to mean "unbounded" or "unconnected",
and can be confused by packets from outside.

use of :: as source is not documented well in IPv6 specification.

not sure if it presents a real threat.  the worst case scenario is a DoS
against TCP listening socket:
- outsider transmit TCP SYN with :: as IPv6 source
- receiving side creates TCP control block with:
	local address = my addres
	remote address = ::	(meaning "unconnected")
	state = SYN_RCVD
  note that SYN ACK will not be sent due to ip6_output() filter.
  this stays until it timeouts.
- the TCP control block prevents listening TCP control block from
  being contacted (DoS).
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.25 2000/07/13 13:41:45 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.25 2000/07/13 13:41:45 itojun Exp $
a222 15
		/* XXX stat */
		goto ret;
	}

	/*
	 * Be proactive about unspecified IPv6 address in source.
	 * As we use all-zero to indicate unbounded/unconnected pcb,
	 * unspecified IPv6 address can be used to confuse us.
	 *
	 * Note that packets with unspecified IPv6 destination is
	 * already dropped in ip6_input.
	 *
	 * XXX not sure if we want this for raw IPv6 socket...
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
@


1.25
log
@enable setsockopt related to IPv6 multicast routing.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.24 2000/06/21 18:42:19 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.24 2000/06/21 18:42:19 itojun Exp $
d227 16
@


1.24
log
@fix KAME PR 261.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.23 2000/06/18 19:56:55 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.23 2000/06/18 19:56:55 itojun Exp $
a64 1
#include <netinet/ip_mroute.h>
d73 1
d533 1
d542 23
d580 1
@


1.23
log
@more mbuf sanity check
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.22 2000/06/18 19:11:17 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.22 2000/06/18 19:11:17 itojun Exp $
d397 1
a397 1
	struct ip6_pktopts opt, *optp = NULL;
d450 2
d456 1
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.21 2000/06/18 19:07:27 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.18 2000/06/13 11:47:23 itojun Exp $
d206 1
a206 1
	register struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
d214 6
d236 1
a236 3
#if 0
	/* Will be done already by the previous input functions */
	if (m->m_len < extra)) {
d238 1
a238 1
			return;
a240 1
#endif /* 0 */
@


1.21
log
@remove remains from NRL ipsec code
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.20 2000/06/18 18:59:12 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.20 2000/06/18 18:59:12 itojun Exp $
d108 1
a108 1
/*----------------------------------------------------------------------
d110 1
a110 2
 ----------------------------------------------------------------------*/

d114 1
a114 1
  in_pcbinit(&rawin6pcbtable, 1);
d117 10
a126 9
/* At the point where this function gets called, we don't know the nexthdr of
   the current header to be processed, only its offset. So we have to go find
   it the hard way. In the case where there's no chained headers, this is not
   really painful.

   The good news is that all fields have been sanity checked.

   Assumes m has already been pulled up by extra. -cmetz
*/
d128 1
a128 1
static __inline__ int ipv6_findnexthdr(struct mbuf *m, size_t extra)
d130 1
a130 1
static int ipv6_findnexthdr(struct mbuf *m, size_t extra)
d132 1
d134 30
a163 30
  caddr_t p = mtod(m, caddr_t);
  int nexthdr = IPPROTO_IPV6;
  unsigned int hl;

  do {
    switch(nexthdr) {
      case IPPROTO_IPV6:
	hl = sizeof(struct ip6_hdr);

	if ((extra -= hl) < 0)
	  return -1;

	nexthdr = ((struct ip6_hdr *)p)->ip6_nxt;
	break;
      case IPPROTO_HOPOPTS:
      case IPPROTO_DSTOPTS:
	if (extra < sizeof(struct ip6_ext))
	  return -1;

	hl = sizeof(struct ip6_ext) +
	     (((struct ip6_ext *)p)->ip6e_len << 3);

	if ((extra -= hl) < 0)
	  return -1;

	nexthdr = ((struct ip6_ext *)p)->ip6e_nxt;
	break;
      case IPPROTO_ROUTING:
	if (extra < sizeof(struct ip6_rthdr0))
	  return -1;
d165 2
a166 2
	hl = sizeof(struct ip6_rthdr0) +
	     (((struct ip6_rthdr0 *)p)->ip6r0_len << 3);
d168 2
a169 2
	if ((extra -= hl) < 0)
	  return -1;
d171 2
a172 2
	nexthdr = ((struct ip6_rthdr0 *)p)->ip6r0_nxt;
	break;
d174 3
a176 3
      case IPPROTO_AH:
	if (extra < sizeof(struct ip6_hdr_srcroute0))
	  return -1;
d178 2
a179 2
	hl = sizeof(struct ip6_hdr_srcroute0) +
	     ((struct ip6_hdr_srcroute0 *)p)->i6sr_len << 3;
d181 2
a182 2
	if ((extra -= hl) < 0)
	  return -1;
d184 2
a185 2
	nexthdr = ((struct ip6_hdr_srcroute0 *)p)->i6sr_nexthdr;
	break;
d187 5
a191 5
      default:
	return -1;
    }
    p += hl;
  } while(extra > 0);
d193 1
a193 1
  return nexthdr;
d196 1
a196 1
/*----------------------------------------------------------------------
d198 1
a198 1
 ----------------------------------------------------------------------*/
d201 2
a202 2
     struct mbuf **mp;
     int *offp, proto;
d204 20
a223 21
  struct mbuf *m = *mp;
  register struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *); /* Will have been
							  pulled up by 
							  ipv6_input(). */
  register struct inpcb *inp;
  int nexthdr, icmp6type;
  int foundone = 0;
  struct mbuf *m2 = NULL, *opts = NULL;
  struct sockaddr_in6 srcsa;
  int extra = *offp;

  /* Be proactive about malicious use of IPv4 mapped address */
  if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
      IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
    /* XXX stat */
    goto ret;
  }

  bzero(&srcsa, sizeof(struct sockaddr_in6));
  srcsa.sin6_family = AF_INET6;
  srcsa.sin6_len = sizeof(struct sockaddr_in6);
d225 1
a225 1
  srcsa.sin6_flowinfo = ip6->ip6_flow & IPV6_FLOWINFO_MASK;
d227 2
a228 2
  /* KAME hack: recover scopeid */
  (void)in6_recoverscope(&srcsa, &ip6->ip6_src, m->m_pkthdr.rcvif);
d231 6
a236 6
  /* Will be done already by the previous input functions */
  if (m->m_len < extra)) {
	if (!(m = m_pullup2(m, extra)))
		return;
	ip6 = mtod(m, struct ip6_hdr *);
  }
d239 40
a278 2
  if ((nexthdr = ipv6_findnexthdr(m, extra)) < 0)
    goto ret;
d280 26
a305 59
  if (nexthdr == IPPROTO_ICMPV6) {
    if (m->m_len < extra + sizeof(struct icmp6_hdr)) {
      m = m_pullup2(m, extra + sizeof(struct icmp6_hdr));
      if (!m)
        goto ret;

      ip6 = mtod(m, struct ip6_hdr *);
    }
    icmp6type = ((struct icmp6_hdr *)(mtod(m, caddr_t) + extra))->icmp6_type;
  } else
    icmp6type = -1;

  /*
   * Locate raw PCB for incoming datagram.
   */
  for (inp = rawin6pcbtable.inpt_queue.cqh_first;
       inp != (struct inpcb *)&rawin6pcbtable.inpt_queue;
       inp = inp->inp_queue.cqe_next)
  {
    if (!(inp->inp_flags & INP_IPV6))
      continue;
    if (inp->inp_ipv6.ip6_nxt && inp->inp_ipv6.ip6_nxt != nexthdr)
      continue;
    if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) && 
	!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &ip6->ip6_dst))
      continue;
    if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_faddr6) && 
	!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, &ip6->ip6_src))
      continue;
    /* inp_icmp6filt must not be NULL, but we add a check for safety */
    if (icmp6type >= 0 && inp->inp_icmp6filt && 
	ICMP6_FILTER_WILLBLOCK(icmp6type, inp->inp_icmp6filt))
      continue;

    foundone = 1;

    /* Note the inefficiency here; this is a consequence of the interfaces of
       the functions being used. The raw code is not performance critical
       enough to require an immediate fix. - cmetz */
    if ((m2 = m_copym(m, 0, (int)M_COPYALL, M_DONTWAIT))) {
      m_adj(m2, extra);
      if (inp->inp_flags & IN6P_CONTROLOPTS)
	ip6_savecontrol(inp, &opts, ip6, m);
      else
        opts = NULL;
      if (sbappendaddr(&inp->inp_socket->so_rcv, (struct sockaddr *)&srcsa, m2,
                       opts)) {
        sorwakeup(inp->inp_socket);
      } else {
        m_freem(m2);
      };
    };
  };

  if (!foundone) {
    /*
     * We should send an ICMPv6 protocol unreachable here,
     * though original UCB 4.4-lite BSD's IPv4 does not do so.
     */
d307 2
a308 2
    ipv6stat.ips_noproto++;
    ipv6stat.ips_delivered--;
d310 1
a310 1
  }
d313 2
a314 2
  if (m)
    m_freem(m);
d316 1
a316 1
  return IPPROTO_DONE;
d380 1
a380 1
/*----------------------------------------------------------------------
d383 3
a385 3
 ----------------------------------------------------------------------*/

int rip6_output(struct mbuf *m, ...)
d387 4
a390 4
  register struct ip6_hdr *ip6;
  register struct inpcb *inp;
  int flags;
  int error = 0;
d392 1
a392 1
  struct ifnet *forceif = NULL;
d394 77
a470 76
  struct ip6_pktopts opt, *optp = NULL;
  struct ifnet *oifp = NULL;
  va_list ap;
  struct socket *so;
  struct sockaddr_in6 *dst;
  struct mbuf *control;
  struct in6_addr *in6a;
  u_int8_t type, code;
  int plen = m->m_pkthdr.len;

  va_start(ap, m);
  so = va_arg(ap, struct socket *);
  dst = va_arg(ap, struct sockaddr_in6 *);
  control = va_arg(ap, struct mbuf *);
  va_end(ap);

  inp = sotoinpcb(so);
  flags = (so->so_options & SO_DONTROUTE);

  if (control) {
    error = ip6_setpktoptions(control, &opt, so->so_state & SS_PRIV);
    if (error != 0)
      goto bad;
    optp = &opt;
  } else
    optp = NULL;

  /*
   * For an ICMPv6 packet, we should know its type and code
   * to update statistics.
   */
  if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
    struct icmp6_hdr *icmp6;
    if (m->m_len < sizeof(struct icmp6_hdr) &&
	(m = m_pullup(m, sizeof(struct icmp6_hdr))) == NULL) {
      error = ENOBUFS;
      goto bad;
    }
    icmp6 = mtod(m, struct icmp6_hdr *);
    type = icmp6->icmp6_type;
    code = icmp6->icmp6_code;
  }

  M_PREPEND(m, sizeof(struct ip6_hdr), M_WAIT);
  ip6 = mtod(m, struct ip6_hdr *);
  ip6->ip6_flow = dst->sin6_flowinfo & IPV6_FLOWINFO_MASK;
  ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
  ip6->ip6_vfc |= IPV6_VERSION;
  ip6->ip6_nxt = inp->inp_ipv6.ip6_nxt;
  /* ip6_src will be filled in later */

  /* KAME hack: embed scopeid */
  if (in6_embedscope(&ip6->ip6_dst, dst, inp, &oifp) != 0) {
    error = EINVAL;
    goto bad;
  }

  /* source address selection */
  in6a = in6_selectsrc(dst, optp, inp->inp_moptions6, &inp->inp_route6,
    &inp->inp_laddr6, &error);
  if (in6a == NULL) {
    if (error == 0)
      error = EADDRNOTAVAIL;
    goto bad;
  }
  ip6->ip6_src = *in6a;
  if (inp->inp_route6.ro_rt)	/* what if oifp contradicts ? */
    oifp = ifindex2ifnet[inp->inp_route6.ro_rt->rt_ifp->if_index];

  ip6->ip6_hlim = in6_selecthlim(inp, oifp);

  if (so->so_proto->pr_protocol == IPPROTO_ICMPV6 ||
      inp->inp_csumoffset != -1) {
    struct mbuf *n;
    int off;
    u_int16_t *p;
d473 22
a494 30
    /* compute checksum */
    if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
      off = offsetof(struct icmp6_hdr, icmp6_cksum);
    else
      off = inp->inp_csumoffset;
    if (plen < off + 1) {
      error = EINVAL;
      goto bad;
    }
    off += sizeof(struct ip6_hdr);

    n = m;
    while (n && n->m_len <= off) {
      off -= n->m_len;
      n = n->m_next;
    }
    if (!n)
      goto bad;
    p = (u_int16_t *)(mtod(n, caddr_t) + off);
    *p = 0;
    *p = in6_cksum(m, ip6->ip6_nxt, sizeof(*ip6), plen);
  }

  error = ip6_output(m, optp, &inp->inp_route6, flags,
		     inp->inp_moptions6, &oifp);
  if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
    if (oifp)
      icmp6_ifoutstat_inc(oifp, type, code);
    icmp6stat.icp6s_outhist[type]++;
  }
d496 9
a504 1
  goto freectl;
d507 2
a508 2
  if (m)
    m_freem(m);
d511 3
a513 3
  if (control)
    m_freem(control);
  return error;
d516 1
a516 1
/*----------------------------------------------------------------------
d518 15
a532 1
 ----------------------------------------------------------------------*/
d534 46
a579 58
int
rip6_ctloutput (op, so, level, optname, m)
     int op;
     struct socket *so;
     int level, optname;
     struct mbuf **m;
{
  register struct inpcb *inp = sotoinpcb(so);

  if ((level != IPPROTO_IPV6) && (level != IPPROTO_ICMPV6)) {
      if (op == PRCO_SETOPT && *m)
	(void)m_free(*m);
      return(EINVAL);
  }

  switch (optname) {
    case IPV6_CHECKSUM:
      if (op == PRCO_SETOPT || op == PRCO_GETOPT) {
        if (op == PRCO_SETOPT) {
          if (!m || !*m || (*m)->m_len != sizeof(int))
	    return(EINVAL);
          inp->inp_csumoffset = *(mtod(*m, int *));
          m_freem(*m);
        } else {
	  *m = m_get(M_WAIT, MT_SOOPTS);
          (*m)->m_len = sizeof(int);
          *(mtod(*m, int *)) = inp->inp_csumoffset;
        };
        return 0;
      };
      break;
    case ICMP6_FILTER:
      if (level != IPPROTO_ICMPV6) {
	if (op == PRCO_SETOPT && *m)
	  (void)m_free(*m);
	return EINVAL;
      }

      if (op == PRCO_SETOPT || op == PRCO_GETOPT) {
        if (op == PRCO_SETOPT) {
          if (!m || !*m || (*m)->m_len != sizeof(struct icmp6_filter))
	    return(EINVAL);
	  bcopy(mtod(*m, struct icmp6_filter *), inp->inp_icmp6filt,
		sizeof(struct icmp6_filter));
          m_freem(*m);
        } else {
	  *m = m_get(M_WAIT, MT_SOOPTS);
          (*m)->m_len = sizeof(struct icmp6_filter);
          *mtod(*m, struct icmp6_filter *) = *inp->inp_icmp6filt;
        };
        return 0;
      };
      break;

    default:
      break;
  }
  return ip6_ctloutput(op, so, level, optname, m);
d590 2
a591 1
MAYBESTATIC MAYBEINLINE int rip6_usrreq_attach(struct socket *so, int proto)
d593 5
a597 2
  register struct inpcb *inp = sotoinpcb(so);
  register int error = 0;
d599 8
a606 2
  if (inp)
     panic("rip6_attach - Already got PCB");
d608 2
a609 11
  if ((so->so_state & SS_PRIV) == 0)
  {
    error = EACCES;
    return error;
  }
  if ((error = soreserve(so, rip6_sendspace, rip6_recvspace)) ||
      (error = in_pcballoc(so, &rawin6pcbtable)))

     return error;
     
  inp = sotoinpcb(so);
d611 1
a611 2
  inp->inp_ipv6.ip6_nxt = (u_long)proto;     /*nam;  Nam contains protocol
						 type, apparently. */
d613 1
a613 2
  inp->inp_ipv6.ip6_nxt = (int)proto;     /*nam;   Nam contains protocol
						 type, apparently. */
d615 6
a620 6
  if (inp->inp_ipv6.ip6_nxt == IPPROTO_ICMPV6)
     inp->inp_csumoffset = 2;
  inp->inp_icmp6filt = (struct icmp6_filter *)
    malloc(sizeof(struct icmp6_filter), M_PCB, M_NOWAIT);
  ICMP6_FILTER_SETPASSALL(inp->inp_icmp6filt);
  return error;
d623 2
a624 1
MAYBESTATIC MAYBEINLINE int rip6_usrreq_detach(struct socket *so)
d626 1
a626 1
  register struct inpcb *inp = sotoinpcb(so);
d628 2
a629 2
  if (inp == 0)
     panic("rip6_detach");
d631 1
a631 1
      /* More MROUTING stuff. */
d633 6
a638 6
  if (inp->inp_icmp6filt) {
    free(inp->inp_icmp6filt, M_PCB);
    inp->inp_icmp6filt = NULL;
  }
  in_pcbdetach(inp);
  return 0;
d641 2
a642 1
MAYBESTATIC MAYBEINLINE int rip6_usrreq_abort(struct socket *so)
d644 2
a645 2
   soisdisconnected(so);
   return rip6_usrreq_detach(so);
d648 6
a653 5
static MAYBEINLINE int rip6_usrreq_disconnect(struct socket *so)
{ 
   if ((so->so_state & SS_ISCONNECTED) == 0)
      return ENOTCONN;
   return rip6_usrreq_abort(so);
d656 2
a657 2
MAYBESTATIC MAYBEINLINE int rip6_usrreq_bind(struct socket *so,
					      struct sockaddr *nam)
d659 2
a660 2
  register struct inpcb *inp = sotoinpcb(so);
  register struct sockaddr_in6 *addr = (struct sockaddr_in6 *)nam;
d662 3
a664 5
   /* 'ifnet' is declared in one of the net/ header files. */
   if ((ifnet.tqh_first == 0) ||
       (addr->sin6_family != AF_INET6)) {    /* I only allow AF_INET6 */
	  return EADDRNOTAVAIL;
   }
d666 11
a676 11
   /*
    * Currently, ifa_ifwithaddr tends to fail for a link-local
    * address, since it implicitly expects that the link identifier
    * for the address is embedded in the sin6_addr part.
    * For now, we'd rather keep this "as is". We'll eventually fix
    * this in a more natural way.
    */
   if (!IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr) &&
        ifa_ifwithaddr((struct sockaddr *)addr) == 0)

          return EADDRNOTAVAIL;
d678 2
a679 2
   inp->inp_laddr6 = addr->sin6_addr;
   return 0; 
d682 2
a683 2
MAYBESTATIC MAYBEINLINE int rip6_usrreq_connect(struct socket *so,
						 struct sockaddr *nam)
d685 4
a688 4
  register struct inpcb *inp = sotoinpcb(so);
  register struct sockaddr_in6 *addr = (struct sockaddr_in6 *) nam;
  int error;
  struct in6_addr *in6a;
d690 2
a691 2
   if (addr->sin6_family != AF_INET6)
       return EAFNOSUPPORT;
d693 2
a694 3
	in6a = in6_selectsrc(addr, inp->inp_outputopts6,
		inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
		&error);
d702 5
a706 4
   inp->inp_faddr6 = addr->sin6_addr;  /* Will structure assignment
				          work with this compiler? */
   soisconnected(so);
   return 0;
d709 5
a713 4
MAYBESTATIC MAYBEINLINE int rip6_usrreq_shutdown(struct socket *so)
{ 
  socantsendmore(so);
  return 0;
d717 1
a717 1
                      struct sockaddr *addr, struct mbuf *control));
d719 12
a730 6
static int rip6_usrreq_send(struct socket *so, int flags, struct mbuf *m,
                      struct sockaddr *addr, struct mbuf *control)
{
  register struct inpcb *inp = sotoinpcb(so);
  register int error = 0;
  struct sockaddr_in6 *dst, tmp;
d732 16
a747 4
   if (inp == 0) {
      m_freem(m);
      return EINVAL;
   }
d749 2
a750 22
   /*
    * Check "connected" status, and if there is a supplied destination
    * address.
    */
   if (so->so_state & SS_ISCONNECTED)
     {
       if (addr)
	   return EISCONN;

       bzero(&tmp, sizeof(tmp));
       tmp.sin6_family = AF_INET6;
       tmp.sin6_len = sizeof(tmp);
       tmp.sin6_addr = inp->inp_faddr6;
       dst = &tmp;
     }
   else
     {
       if (addr == NULL)
	   return ENOTCONN;

       dst = (struct sockaddr_in6 *)addr;
     }
d752 3
a754 3
   error = rip6_output(m,so,dst,control);
   /* m = NULL; */
   return error;
d757 9
a765 6
MAYBESTATIC MAYBEINLINE int rip6_usrreq_control(struct socket *so, u_long cmd,
                                               caddr_t data, struct ifnet *ifp)
{ 
/* Notice that IPv4 raw sockets don't pass PRU_CONTROL.  I wonder
   if they panic as well? */
      return in6_control(so, cmd, data, ifp, 0);
d768 5
a772 5
MAYBESTATIC MAYBEINLINE int rip6_usrreq_sense(struct socket *so,
                                               struct stat *sb)
{ 
  /* services stat(2) call. */
  return 0;
d775 2
a776 2
MAYBESTATIC MAYBEINLINE int rip6_usrreq_sockaddr(struct socket *so,
                                                  struct mbuf *nam)
d778 2
a779 2
  register struct inpcb *inp = sotoinpcb(so);
  return in6_setsockaddr(inp, nam);
d782 2
a783 2
MAYBESTATIC MAYBEINLINE int rip6_usrreq_peeraddr(struct socket *so,
                                                  struct mbuf *nam)
d785 2
a786 2
  register struct inpcb *inp = sotoinpcb(so);
  return in6_setpeeraddr(inp, nam);
d789 1
a789 1
/*----------------------------------------------------------------------
d791 1
a791 1
 ----------------------------------------------------------------------*/
d794 4
a797 4
     struct socket *so;
     int req;
     struct mbuf *m, *nam, *control;
     struct proc *p;
d799 1
a799 1
  register int error = 0;
d802 7
a808 7
  /*
   * Ummm, like, multicast routing stuff goes here, huh huh huh.
   *
   * Seriously, this would be for user-level multicast routing daemons.  With
   * multicast being a requirement for IPv6, code like what might go here
   * may go away.
   */
d811 67
a877 71
  switch (req)
    {
    case PRU_ATTACH:
      error = rip6_usrreq_attach(so, (long)nam);
      break;
    case PRU_DISCONNECT:
      error = rip6_usrreq_disconnect(so);
      break;
      /* NOT */
      /* FALLTHROUGH */
    case PRU_ABORT:
      error = rip6_usrreq_abort(so);
      break;
      /* NOT */
      /* FALLTHROUGH */
    case PRU_DETACH:
      error = rip6_usrreq_detach(so);
      break;
    case PRU_BIND:
      if (nam->m_len != sizeof(struct sockaddr_in6))
         return EINVAL;
      /*
       * Be strict regarding sockaddr_in6 fields.
       */
      error = rip6_usrreq_bind(so, mtod(nam, struct sockaddr *));
      break;
    case PRU_CONNECT:
      /*
       * Be strict regarding sockaddr_in6 fields.
       */
      if (nam->m_len != sizeof(struct sockaddr_in6))
          return EINVAL;
      error = rip6_usrreq_connect(so, mtod(nam, struct sockaddr *));
      break;
    case PRU_SHUTDOWN:
      error = rip6_usrreq_shutdown(so);
      break;
    case PRU_SEND:
      /*
       * Be strict regarding sockaddr_in6 fields.
       */
      if (nam->m_len != sizeof(struct sockaddr_in6))
          return EINVAL;
      error = rip6_usrreq_send(so, 0, m, mtod(nam, struct sockaddr *), control);
      m = NULL;
      break;
    case PRU_CONTROL:
      return rip6_usrreq_control(so, (u_long)m, (caddr_t) nam, 
                               (struct ifnet *) control);
    case PRU_SENSE:
      return rip6_usrreq_sense(so, NULL); /* XXX */
    case PRU_CONNECT2:
    case PRU_RCVOOB:
    case PRU_LISTEN:
    case PRU_SENDOOB:
    case PRU_RCVD:
    case PRU_ACCEPT:
      error = EOPNOTSUPP;
      break;
    case PRU_SOCKADDR:
      error = rip6_usrreq_sockaddr(so, nam);
      break;
    case PRU_PEERADDR:
      error = rip6_usrreq_peeraddr(so, nam);
      break;
    default:
      panic ("rip6_usrreq - unknown req\n");
    }
  if (m != NULL)
    m_freem(m);
  return error;
@


1.20
log
@split long "if" case (cosmetic; preparation for KNF)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.19 2000/06/18 18:41:36 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.19 2000/06/18 18:41:36 itojun Exp $
a276 11

#ifdef IPSEC
    /* Perform input-side policy check. Drop packet if policy says to drop it.

       Note: For ICMPv6 packets, we also checked policy in ipv6_icmp_input().

       XXX - state arg should NOT be NULL, it should be the netproc state
       carried up the stack - cmetz */
    if (!netproc_inputpolicy(NULL, (struct sockaddr *)&srcsa,
	 (struct sockaddr *)&dstsa, nexthdr, m, NULL, NULL))
#endif /* IPSEC */
@


1.19
log
@sync with more recent kame.
updates scoped address handling and checksum option.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.18 2000/06/13 11:47:23 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.18 2000/06/13 11:47:23 itojun Exp $
d244 2
a245 1
      if (!(m = m_pullup2(m, extra + sizeof(struct icmp6_hdr))))
d458 3
a460 3
  if ((in6a = in6_selectsrc(dst, optp, inp->inp_moptions6,
			     &inp->inp_route6, &inp->inp_laddr6,
			    &error)) == 0) {
@


1.18
log
@comment out flowinfo manipulation on inbound.  the spec is not very clear.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.17 2000/05/13 21:31:18 deraadt Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.17 2000/05/13 21:31:18 deraadt Exp $
a211 3
#ifdef IPSEC
  struct sockaddr_in6 dstsa;
#endif /* IPSEC */
d214 6
a219 6
	/* Be proactive about malicious use of IPv4 mapped address */
	if (IN6_IS_ADDR_V4MAPPED(&ip6->ip6_src) ||
	    IN6_IS_ADDR_V4MAPPED(&ip6->ip6_dst)) {
		/* XXX stat */
		goto ret;
	}
d227 2
a228 18
  srcsa.sin6_addr = ip6->ip6_src;

	if (IN6_IS_SCOPE_LINKLOCAL(&srcsa.sin6_addr))
		srcsa.sin6_addr.s6_addr16[1] = 0;
	if (m->m_pkthdr.rcvif) {
		if (IN6_IS_SCOPE_LINKLOCAL(&srcsa.sin6_addr))
			srcsa.sin6_scope_id = m->m_pkthdr.rcvif->if_index;
		else
			srcsa.sin6_scope_id = 0;
	} else
		srcsa.sin6_scope_id = 0;

#if IPSEC
  bzero(&dstsa, sizeof(struct sockaddr_in6));
  dstsa.sin6_family = AF_INET6;
  dstsa.sin6_len = sizeof(struct sockaddr_in6);
  dstsa.sin6_addr = ip6->ip6_dst;
#endif /* IPSEC */
d270 1
a292 1

a400 1

d405 3
d426 10
a435 7
#if 0
  if (inp->inp_flags & INP_HDRINCL)
    {
      flags |= IPV6_RAWOUTPUT;
      ipv6stat.ips_rawout++;
      /* Maybe m_pullup() ipv6 header here for ipv6_output(), which
	 expects it to be contiguous. */
d437 4
a440 4
  else
#endif
    {
      struct in6_addr *in6a;
d442 13
a454 7
      in6a = in6_selectsrc(dst, optp, inp->inp_moptions6,
		&inp->inp_route6, &inp->inp_laddr6, &error);
      if (in6a == NULL) {
	if (error == 0)
	  error = EADDRNOTAVAIL;
	goto bad;
      }
d456 29
a484 13
      M_PREPEND(m, sizeof(struct ip6_hdr), M_WAIT);
      ip6 = mtod(m, struct ip6_hdr *);
      ip6->ip6_flow = 0;  /* Or possibly user flow label, in host order. */
      ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
      ip6->ip6_vfc |= IPV6_VERSION;
      ip6->ip6_nxt = inp->inp_ipv6.ip6_nxt;
      bcopy(in6a, &ip6->ip6_src, sizeof(*in6a));
      ip6->ip6_dst = dst->sin6_addr;
      /*
       * Question:  How do I handle options?
       *
       * Answer:  I put them in here, but how?
       */
d486 1
d488 11
a498 9
	/*
	 * If the scope of the destination is link-local, embed the interface
	 * index in the address.
	 *
	 * XXX advanced-api value overrides sin6_scope_id 
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&ip6->ip6_dst)) {
		struct in6_pktinfo *pi;
d500 7
a506 48
		/*
		 * XXX Boundary check is assumed to be already done in
		 * ip6_setpktoptions().
		 */
		if (optp && (pi = optp->ip6po_pktinfo) && pi->ipi6_ifindex) {
			ip6->ip6_dst.s6_addr16[1] = htons(pi->ipi6_ifindex);
			oifp = ifindex2ifnet[pi->ipi6_ifindex];
		}
		else if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) &&
			 inp->inp_moptions6 &&
			 inp->inp_moptions6->im6o_multicast_ifp) {
			oifp = inp->inp_moptions6->im6o_multicast_ifp;
			ip6->ip6_dst.s6_addr16[1] = htons(oifp->if_index);
		} else if (dst->sin6_scope_id) {
			/* boundary check */
			if (dst->sin6_scope_id < 0 
			 || if_index < dst->sin6_scope_id) {
				error = ENXIO;  /* XXX EINVAL? */
				goto bad;
			}
			ip6->ip6_dst.s6_addr16[1]
				= htons(dst->sin6_scope_id & 0xffff);/*XXX*/
		}
	}

	ip6->ip6_hlim = in6_selecthlim(inp, oifp);

  {
    int payload = sizeof(struct ip6_hdr);
    int nexthdr = mtod(m, struct ip6_hdr *)->ip6_nxt;
#if 0
    int error;
#endif

    if (inp->inp_csumoffset >= 0) {
      uint16_t *csum;

      if (!(m = m_pullup2(m, payload + inp->inp_csumoffset))) {
	error = ENOBUFS;
	goto freectl;
      };

      csum = (uint16_t *)(mtod(m, uint8_t *) + payload + inp->inp_csumoffset);

      *csum = 0;
      *csum = in6_cksum(m, nexthdr, payload, m->m_pkthdr.len - payload);
    };
  };
a507 1
  ip6_output(m, optp, &inp->inp_route6, flags, inp->inp_moptions6, &oifp);
d664 13
a676 3
       (addr->sin6_family != AF_INET6) ||    /* I only allow AF_INET6 */
       (!IN6_IS_ADDR_UNSPECIFIED(&addr->sin6_addr) &&
        ifa_ifwithaddr((struct sockaddr *)addr) == 0 ) )
@


1.17
log
@plug an mbuf leak
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.16 2000/04/30 14:55:26 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.16 2000/04/30 14:55:26 itojun Exp $
d227 3
@


1.16
log
@allow compilation without -Ox.  we may want to simplify #ifdefs more,
after 2.7 is out.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.15 2000/02/28 16:40:39 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.15 2000/02/28 16:40:39 itojun Exp $
d524 2
a525 2
	m_freem(m);
	return ENOBUFS;
d535 2
a536 1
  return ip6_output(m, optp, &inp->inp_route6, flags, inp->inp_moptions6, &oifp);
d541 4
@


1.15
log
@- check raw socket icmp6 filter only if the packet is icmp6.
- allow setting raw socket icmp6 filter only if it is IPPROTO_ICMPV6 socket.
	(cmetz may object about above two items...)
- add rip6_ctlinput, to flush cached router properly on redirects.
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.14 2000/02/28 11:55:23 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.14 2000/02/28 11:55:23 itojun Exp $
d607 1
a607 1
#if __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__
@


1.14
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.13 2000/02/07 06:09:10 itojun Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.13 2000/02/07 06:09:10 itojun Exp $
d74 1
d286 1
a286 1
    if (inp->inp_icmp6filt && 
d340 61
d579 6
@


1.13
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/* $OpenBSD: raw_ipv6.c,v 1.12 2000/01/05 17:30:52 itojun Exp $ */
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.12 2000/01/05 17:30:52 itojun Exp $
@


1.13.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/

d46 1
a46 1
 *	$Id$
a72 1
#include <netinet6/ip6protosw.h>
d284 1
a284 1
    if (icmp6type >= 0 && inp->inp_icmp6filt && 
a337 61
void
rip6_ctlinput(cmd, sa, d)
	int cmd;
	struct sockaddr *sa;
	void *d;
{
	struct sockaddr_in6 sa6;
	register struct ip6_hdr *ip6;
	struct mbuf *m;
	int off;
	void (*notify) __P((struct inpcb *, int)) = in_rtchange;

	if (sa->sa_family != AF_INET6 ||
	    sa->sa_len != sizeof(struct sockaddr_in6))
		return;

	if ((unsigned)cmd >= PRC_NCMDS)
		return;
	if (PRC_IS_REDIRECT(cmd))
		notify = in_rtchange, d = NULL;
	else if (cmd == PRC_HOSTDEAD)
		d = NULL;
	else if (inet6ctlerrmap[cmd] == 0)
		return;

	/* if the parameter is from icmp6, decode it. */
	if (d != NULL) {
		struct ip6ctlparam *ip6cp = (struct ip6ctlparam *)d;
		m = ip6cp->ip6c_m;
		ip6 = ip6cp->ip6c_ip6;
		off = ip6cp->ip6c_off;
	} else {
		m = NULL;
		ip6 = NULL;
	}

	/* translate addresses into internal form */
	sa6 = *(struct sockaddr_in6 *)sa;
	if (IN6_IS_ADDR_LINKLOCAL(&sa6.sin6_addr) && m && m->m_pkthdr.rcvif)
		sa6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

	if (ip6) {
		/*
		 * XXX: We assume that when IPV6 is non NULL,
		 * M and OFF are valid.
		 */
		struct in6_addr s;

		/* translate addresses into internal form */
		memcpy(&s, &ip6->ip6_src, sizeof(s));
		if (IN6_IS_ADDR_LINKLOCAL(&s))
			s.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);

		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6,
					0, &s, 0, cmd, notify);
	} else {
		(void) in6_pcbnotify(&rawin6pcbtable, (struct sockaddr *)&sa6,
					0, &zeroin6_addr, 0, cmd, notify);
	}
}

a515 6
      if (level != IPPROTO_ICMPV6) {
	if (op == PRCO_SETOPT && *m)
	  (void)m_free(*m);
	return EINVAL;
      }

@


1.13.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: raw_ipv6.c,v 1.13.2.1 2000/03/02 07:04:46 niklas Exp $	*/
d47 1
a47 1
 *	$Id: raw_ipv6.c,v 1.13.2.1 2000/03/02 07:04:46 niklas Exp $
@


1.12
log
@clarify rip6_ctloutput().
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.11 1999/12/21 15:41:08 itojun Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.11 1999/12/21 15:41:08 itojun Exp $
d70 1
a70 1
#include <netinet6/ip6.h>
d72 1
a72 1
#include <netinet6/icmp6.h>
@


1.11
log
@be paranoid about malicious use of v4 mapped addr on v6 packet.
malicious party may try to use v4 mapped addr as source/dest to
confuse tcp/udp layer, or to bypass security checks,
for example, naive stack can mistakingly think a packet with
src = ::ffff:127.0.0.1 is from local node.

(sync with kame)
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.10 1999/12/19 02:54:29 itojun Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.10 1999/12/19 02:54:29 itojun Exp $
d493 1
a493 1
  if ((level != IPPROTO_IP) && (level != IPPROTO_IPV6) && (level != IPPROTO_ICMPV6)) {
a501 2
        if (!m || !*m || (*m)->m_len != sizeof(int))
	  return(EINVAL);
d503 2
d508 1
a516 2
        if (!m || !*m || (*m)->m_len != sizeof(struct icmp6_filter))
	  return(EINVAL);
d518 2
d524 1
d532 1
a532 20
/* Should this be obsoleted? */
    case IP_HDRINCL:
      if (op == PRCO_SETOPT || op == PRCO_GETOPT)
	{
	  if (m == 0 || *m == 0 || (*m)->m_len != sizeof(int))
	    return(EINVAL);
	  if (op == PRCO_SETOPT)
	    {
	      if (*mtod(*m, int *))
		inp->inp_flags |= INP_HDRINCL;
	      else inp->inp_flags &= ~INP_HDRINCL;
	      m_free(*m);
	    }
	  else
	    {
	      (*m)->m_len = sizeof(int);
	      *(mtod(*m, int *)) = (inp->inp_flags & INP_HDRINCL) ? 1 : 0;
	    }
	  return 0;
	}
a533 32

#ifdef MRT_INIT
    default:
      if (optname >= MRT_INIT) {
#else /* MRT_INIT */
    case DVMRP_INIT:
    case DVMRP_DONE:
    case DVMRP_ADD_VIF:
    case DVMRP_DEL_VIF:
    case DVMRP_ADD_LGRP:
    case DVMRP_DEL_LGRP:
    case DVMRP_ADD_MRT:
    case DVMRP_DEL_MRT:
      {
#endif /* MRT_INIT */
#ifdef MROUTING
/* Be careful here! */
/*      if (op == PRCO_SETOPT)
	{
	  error = ipv6_mrouter_cmd(optname, so, *m);
	  if (*m)
	    (void)m_free(*m);
	}
      else error = EINVAL;
      return (error);*/
	return(EOPNOTSUPP);
#else /* MROUTING */
      if (op == PRCO_SETOPT && *m)
	(void)m_free(*m);
      return(EOPNOTSUPP);
#endif /* MROUTING */
      };
a534 1

@


1.10
log
@disallow AF mismatch on inbound.
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.9 1999/12/15 07:08:00 itojun Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.9 1999/12/15 07:08:00 itojun Exp $
d214 7
@


1.9
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.8 1999/12/14 14:28:23 angelos Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.8 1999/12/14 14:28:23 angelos Exp $
d267 2
@


1.8
log
@Change cast (and argument declaration) from int to u_long so it
compiles on alpha (janjaap@@stack.nl)
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.7 1999/12/10 10:04:29 angelos Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.7 1999/12/10 10:04:29 angelos Exp $
d392 2
a393 1
      ip6->ip6_vfc = IPV6_VERSION;
@


1.7
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/* $OpenBSD: raw_ipv6.c,v 1.6 1999/12/10 08:53:18 angelos Exp $ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.6 1999/12/10 08:53:18 angelos Exp $
d744 1
a744 1
MAYBESTATIC MAYBEINLINE int rip6_usrreq_control(struct socket *so, int cmd,
d842 1
a842 1
      return rip6_usrreq_control(so, (int)m, (caddr_t) nam, 
@


1.6
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.5 1999/12/08 06:50:23 itojun Exp $
a73 1
#if __OpenBSD__
a74 1
#endif /* __OpenBSD__ */
d578 1
a578 1
#if __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ && !__FreeBSD__
d581 1
a581 1
#else /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ && !__FreeBSD__ */
d584 1
a584 1
#endif /* __GNUC__ && __GNUC__ >= 2 && __OPTIMIZE__ && !__FreeBSD__ */
@


1.5
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
d46 1
a46 1
 *	$Id: raw_ipv6.c,v 1.4 1999/04/28 09:28:16 art Exp $
a59 7
#if __NetBSD__ || __FreeBSD__
#include <sys/proc.h>
#endif /* __NetBSD__ || __FreeBSD__ */
#if __FreeBSD__
#include <vm/vm_zone.h>
#endif /* __FreeBSD__ */

a75 18
#ifdef NRL_IPSEC 
#define IPSEC 1
#endif /* NRL_IPSEC */
#endif /* __OpenBSD__ */

#ifdef IPSEC
#include <sys/osdep.h>
#include <net/netproc.h>
#include <net/netproc_var.h>
#endif /* IPSEC */

#ifdef DEBUG_NRL
#include <sys/debug.h>
#else /* DEBUG_NRL */
#if __OpenBSD__
#include <netinet6/debug.h>
#else /* __OpenBSD__ */
#include <sys/debug.h>
a76 1
#endif /* DEBUG_NRL */
a81 1
#if __NetBSD__ || __OpenBSD__
a82 3
#else /* __NetBSD__ || __OpenBSD__ */
struct inpcb rawin6pcb;
#endif /* __NetBSD__ || __OpenBSD__ */
d91 1
a102 4
#if __FreeBSD__
static struct inpcbhead ri6pcb;
static struct inpcbinfo ri6pcbinfo;
#endif /* __FreeBSD__ */
a107 9
#define RETURN_ERROR(x) { \
  DPRINTF(EVENT, ("%s: returning %s\n", DEBUG_STATUS, #x)); \
  return x; \
}
#define RETURN_VALUE(x) { \
  DPRINTF(EVENT, ("%s: returning %d\n", DEBUG_STATUS, x)); \
  return x; \
}

a114 17
#if __FreeBSD__
	LIST_INIT(&ri6pcb);
	ri6pcbinfo.listhead = &ri6pcb;
	/*
	 * XXX We don't use the hash list for raw IP, but it's easier
	 * to allocate a one entry hash list than it is to check all
	 * over the place for hashbase == NULL.
	 */
	ri6pcbinfo.hashbase = hashinit(1, M_PCB, M_WAITOK, &ri6pcbinfo.hashmask);
	ri6pcbinfo.porthashbase = hashinit(1, M_PCB, M_WAITOK, &ri6pcbinfo.porthashmask);
	ri6pcbinfo.ipi_zone = zinit("ri6pcb", sizeof(struct inpcb),
				   nmbclusters / 4, ZONE_INTERRUPT, 0);
#else /* __FreeBSD__ */
#if __NetBSD__
  in_pcbinit(&rawin6pcbtable, 1, 1);
#else /* __NetBSD__ */
#if __OpenBSD__
a115 5
#else /* __OpenBSD__ */
  rawin6pcb.inp_next = rawin6pcb.inp_prev = &rawin6pcb;
#endif /* __OpenBSD__ */
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */
a216 9
  DPRINTF(FINISHED, ("rip6_input(m=%08x, extra=%d)\n", OSDEP_PCAST(m), extra));
  DP(FINISHED, m->m_pkthdr.len, d);
  DDO(FINISHED,printf("In rip6_input(), header is:\n");dump_mchain(m));
  DPRINTF(EVENT, ("In rip6_input()\n"));
  DPRINTF(EVENT, ("Header is: "));
#if 0
  DDO(GROSSEVENT, dump_ipv6(ipv6));
#endif

d248 1
a248 2
  if ((nexthdr = ipv6_findnexthdr(m, extra)) < 0) {
    DPRINTF(ERROR, ("rip6_input: ipv6_findnexthdr failed\n"));
a249 3
  }

  DP(FINISHED, nexthdr, d);
d253 1
a253 2
      if (!(m = m_pullup2(m, extra + sizeof(struct icmp6_hdr)))) {
        DPRINTF(ERROR, ("rip6_input: m_pullup2 failed\n"));
d255 1
a255 1
      }
a264 4
#if __FreeBSD__
  for (inp = ri6pcb.lh_first; inp != NULL; inp = inp->inp_list.le_next) {
#else /* __FreeBSD__ */
#if __NetBSD__ || __OpenBSD__
a267 4
#else /* __NetBSD__ || __OpenBSD__ */
  for (inp = rawin6pcb.inp_next; inp != &rawin6pcb; inp = inp->inp_next)
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* __FreeBSD__ */
a280 1
    DPRINTF(IDL_EVENT, ("Found a raw pcb (>1)\n"));
a293 1
    DP(FINISHED, m->m_pkthdr.len, d);
d299 1
a299 1
      DP(FINISHED, m2->m_pkthdr.len, d);
a327 1
  DPRINTF(FINISHED, ("rip6_input\n"));
a335 1
#if __OpenBSD__
a336 8
#else /* __OpenBSD__ */
int
rip6_output(m, so, dst, control)
     struct mbuf *m;
     struct socket *so;
     struct in6_addr *dst;
     struct mbuf *control;
#endif /* __OpenBSD__ */
d347 1
a347 1
#if __OpenBSD__
a357 1
#endif /* __OpenBSD__ */
a452 1
	DPRINTF(IDL_ERROR, ("rip6_output: m_pullup2(m, %d) failed\n", payload + inp->inp_csumoffset));
a475 26
#if __FreeBSD__
int rip6_ctloutput(struct socket *so, struct sockopt *sopt)
{
  register struct inpcb *inp = sotoinpcb(so);
  int op;
  int level;
  int optname;
  int optval;

  DPRINTF(FINISHED, ("rip6_ctloutput(so=%08x, sopt=%08x)\n",
		       OSDEP_PCAST(so), OSDEP_PCAST(sopt)));

  switch(sopt->sopt_dir) {
    case SOPT_GET:
      op = PRCO_GETOPT;
      break;
    case SOPT_SET:
      op = PRCO_SETOPT;
      break;
    default:
      RETURN_ERROR(EINVAL);
  };

  level = sopt->sopt_level;
  optname = sopt->sopt_name;
#else /* __FreeBSD__ */
a484 3
  DPRINTF(FINISHED, ("rip6_ctloutput(op=%x,so,level=%x,optname=%x,m)\n", op, level, optname));
#endif /* __FreeBSD__ */

a485 1
#if !__FreeBSD__
d488 1
a488 2
#endif /* !__FreeBSD__ */
      RETURN_ERROR(EINVAL);
a493 13
#if __FreeBSD__
        if (!sopt->sopt_val || (sopt->sopt_valsize != sizeof(int)))
	  RETURN_ERROR(EINVAL);
        if (op == PRCO_SETOPT) {
          int error = sooptcopyin(sopt, &optval, sizeof(int), sizeof(int));
          if (error)
	    RETURN_VALUE(error);
          inp->inp_csumoffset = optval;

	  return 0;
        } else
          return sooptcopyout(sopt, &inp->inp_csumoffset, sizeof(int));
#else /* __FreeBSD__ */
d495 1
a495 1
	  RETURN_ERROR(EINVAL);
a502 1
#endif /* __FreeBSD__ */
a507 18
#if __FreeBSD__
        if (!sopt->sopt_val || (sopt->sopt_valsize !=
            sizeof(struct icmp6_filter)))
	  RETURN_ERROR(EINVAL);
        if (op == PRCO_SETOPT) {
          struct icmp6_filter icmp6_filter;
          int error = sooptcopyin(sopt, &icmp6_filter,
            sizeof(struct icmp6_filter), sizeof(struct icmp6_filter));
          if (error)
            return error;

          bcopy(&icmp6_filter, inp->inp_icmp6filt, sizeof(icmp6_filter));

          return 0;
        } else
          return sooptcopyout(sopt, inp->inp_icmp6filt,
            sizeof(struct icmp6_filter));
#else /* __FreeBSD__ */
d509 1
a509 1
	  RETURN_ERROR(EINVAL);
a518 1
#endif /* __FreeBSD__ */
a525 19
#if __FreeBSD__
        if (!sopt->sopt_val || (sopt->sopt_valsize != sizeof(int)))
	  RETURN_ERROR(EINVAL);
        if (op == PRCO_SETOPT) {
          int error = sooptcopyin(sopt, &optval, sizeof(int), sizeof(int));
          if (error)
            return error;

          if (optval)
            inp->inp_flags |= INP_HDRINCL;
          else
            inp->inp_flags &= ~INP_HDRINCL;

          return 0;
        } else {
          optval = (inp->inp_flags & INP_HDRINCL) ? 1 : 0;
          return sooptcopyout(sopt, &optval, sizeof(int));
        };
#else /* __FreeBSD__ */
d527 1
a527 1
	    RETURN_ERROR(EINVAL);
a540 1
#endif /* __FreeBSD__ */
d568 1
a568 1
	RETURN_ERROR(EOPNOTSUPP);
a569 1
#if !__FreeBSD__
d572 1
a572 2
#endif /* !__FreeBSD__ */
      RETURN_ERROR(EOPNOTSUPP);
d576 1
a576 3
#if __FreeBSD__
  return ip6_ctloutput(so, sopt);
#else /* __FreeBSD__ */
a577 1
#endif /* __FreeBSD__ */
a587 4
#if __NetBSD__ || __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_attach(struct socket *so, int proto,
                                                struct proc *p)
#else /* __NetBSD__ || __FreeBSD__ */
a588 1
#endif /* __NetBSD__ || __FreeBSD__ */
a595 3
#if __NetBSD__ || __FreeBSD__
  if (p == 0 || (error = suser(p->p_ucred, &p->p_acflag)))
#else /* __NetBSD__ || __FreeBSD__ */
a596 1
#endif /* __NetBSD__ || __FreeBSD__ */
d602 1
a602 10

#if __FreeBSD__
    (error = in_pcballoc(so, &ri6pcbinfo, p)))
#else /* __FreeBSD__ */
#if __NetBSD__ ||  __OpenBSD__
    (error = in_pcballoc(so, &rawin6pcbtable)))
#else /* __NetBSD__ || __OpenBSD__ */
    (error = in_pcballoc(so, &rawin6pcb)))
#endif /* __NetBSD__ || __OpenBSD__ */
#endif /* __FreeBSD__ */
a651 4
#if __NetBSD__ || __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_bind(struct socket *so,
				         struct sockaddr *nam, struct proc *p)
#else /* __NetBSD__ || __FreeBSD__ */
a653 1
#endif /* __NetBSD__ || __FreeBSD__ */
a658 1
#if __NetBSD__ || __OpenBSD__ || __FreeBSD__
a659 3
#else /* __NetBSD__ || __OpenBSD__ || __FreeBSD__ */
   if ((ifnet == 0) ||
#endif /* __NetBSD__ || __OpenBSD__ || __FreeBSD__ */
a669 4
#if __NetBSD__ || __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_connect(struct socket *so,
					 struct sockaddr *nam, struct proc *p)
#else /* __NetBSD__ || __FreeBSD__ */
a671 1
#endif /* __NetBSD__ || __FreeBSD__ */
a705 9
#if __NetBSD__ || __FreeBSD__
/*
 * Note that flags and p are not used, but required by protosw in 
 * FreeBSD.
 */
static int rip6_usrreq_send(struct socket *so, int flags, struct mbuf *m,
                      struct sockaddr *addr, struct mbuf *control,
		      struct proc *p)
#else /* __NetBSD__ || __FreeBSD__ */
a707 1
#endif /* __NetBSD__ || __FreeBSD__ */
a745 4
#if __NetBSD__ || __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_control(struct socket *so, u_long cmd,
                               caddr_t data, struct ifnet *ifp, struct proc *p)
#else /* __NetBSD__ || __FreeBSD__ */
a747 1
#endif /* __NetBSD__ || __FreeBSD__ */
a750 3
#if __NetBSD__ || __FreeBSD__
      return in6_control(so, cmd, data, ifp, 0, p);
#else /* __NetBSD__ || __FreeBSD__ */
a751 1
#endif /* __NetBSD__ || __FreeBSD__ */
a760 4
#if __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_sockaddr(struct socket *so,
                                                  struct sockaddr **nam)
#else /* __FreeBSD__ */
a762 1
#endif /* __FreeBSD__ */
a767 4
#if __FreeBSD__
MAYBESTATIC MAYBEINLINE int rip6_usrreq_peeraddr(struct socket *so,
                                                  struct sockaddr **nam)
#else /* __FreeBSD__ */
a769 1
#endif /* __FreeBSD__ */
a774 11
#if __FreeBSD__
struct pr_usrreqs rip6_usrreqs = {
  rip6_usrreq_abort, pru_accept_notsupp, rip6_usrreq_attach,
  rip6_usrreq_bind, rip6_usrreq_connect, pru_connect2_notsupp,
  rip6_usrreq_control, rip6_usrreq_detach, rip6_usrreq_detach,
  pru_listen_notsupp, rip6_usrreq_peeraddr, pru_rcvd_notsupp,
  pru_rcvoob_notsupp, rip6_usrreq_send, rip6_usrreq_sense,
  rip6_usrreq_shutdown, rip6_usrreq_sockaddr, sosend, soreceive, sopoll
};
#endif /* __FreeBSD__ */

a777 1
#if !__FreeBSD__
a786 2
  DPRINTF(IDL_EVENT, ("rip6_usrreq(so, req, m, nam, control)\n"));

a799 3
#if __NetBSD__
      error = rip6_usrreq_attach(so, (long)nam, p);
#else /* __NetBSD__ */
a800 1
#endif /* __NetBSD__ */
a820 3
#if __NetBSD__
      error = rip6_usrreq_bind(so, mtod(nam, struct sockaddr *), p);
#else /* __NetBSD__ */
a821 1
#endif /* __NetBSD__ */
a828 3
#if __NetBSD__
      error = rip6_usrreq_connect(so, mtod(nam, struct sockaddr *), p);
#else /* __NetBSD__ */
a829 1
#endif /* __NetBSD__ */
a839 3
#if __NetBSD__
      error = rip6_usrreq_send(so, 0, m, mtod(nam, struct sockaddr *), control, p);
#else /* __NetBSD__ */
a840 1
#endif /* __NetBSD__ */
a843 4
#if __NetBSD__
      return rip6_usrreq_control(so, (u_long)m, (caddr_t) nam, 
                               (struct ifnet *) control, p);
#else /* __NetBSD__ */
a845 1
#endif /* __NetBSD__ */
a868 1
#endif /* !__FreeBSD__ */
@


1.4
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d45 1
a45 1
 *	$Id: raw_ipv6.c,v 1.3 1999/03/09 05:31:55 cmetz Exp $
a74 1
#include <netinet6/in6.h>
d76 3
a78 3
#include <netinet6/ipv6.h>
#include <netinet6/ipv6_var.h>
#include <netinet6/icmpv6.h>
d112 1
a112 1
struct sockaddr_in6 ripv6src = { sizeof(struct sockaddr_in6), AF_INET6 };
d120 7
a126 2
u_long ripv6_sendspace = RIPV6SNDQ;
u_long ripv6_recvspace = RIPV6RCVQ;
d136 3
a138 1
extern struct ipv6stat ipv6stat;
d154 1
a154 1
ripv6_init()
d203 1
a203 1
	hl = sizeof(struct ipv6);
d208 1
a208 1
	nexthdr = ((struct ipv6 *)p)->ipv6_nexthdr;
d212 1
a212 1
	if (extra < sizeof(struct ipv6_opthdr))
d215 2
a216 2
	hl = sizeof(struct ipv6_opthdr) +
	     (((struct ipv6_opthdr *)p)->oh_extlen << 3);
d221 1
a221 1
	nexthdr = ((struct ipv6_opthdr *)p)->oh_nexthdr;
d224 1
a224 1
	if (extra < sizeof(struct ipv6_srcroute0))
d227 2
a228 2
	hl = sizeof(struct ipv6_srcroute0) +
	     (((struct ipv6_srcroute0 *)p)->i6sr_len << 3);
d233 1
a233 1
	nexthdr = ((struct ipv6_srcroute0 *)p)->i6sr_nexthdr;
d237 1
a237 1
	if (extra < sizeof(struct ipv6_srcroute0))
d240 2
a241 2
	hl = sizeof(struct ipv6_srcroute0) +
	     ((struct ipv6_srcroute0 *)p)->i6sr_len << 3;
d246 1
a246 1
	nexthdr = ((struct ipv6_srcroute0 *)p)->i6sr_nexthdr;
d261 4
a264 8
void
#if __OpenBSD__
ripv6_input(struct mbuf *m, ...)
#else /* __OpenBSD__ */
ripv6_input(m,extra)
     struct mbuf *m;
     int extra;
#endif /* __OpenBSD__ */
d266 2
a267 1
  register struct ipv6 *ipv6 = mtod(m, struct ipv6 *); /* Will have been
d271 1
a271 1
  int nexthdr, icmpv6type;
d278 1
a278 3
#if __OpenBSD__
  int extra;
  va_list ap;
d280 1
a280 6
  va_start(ap, m);
  extra = va_arg(ap, int);
  va_end(ap);
#endif /* __OpenBSD__ */

  DPRINTF(FINISHED, ("ripv6_input(m=%08x, extra=%d)\n", OSDEP_PCAST(m), extra));
d282 2
a283 2
  DDO(FINISHED,printf("In ripv6_input(), header is:\n");dump_mchain(m));
  DPRINTF(EVENT, ("In ripv6_input()\n"));
d285 1
d287 1
d292 11
a302 1
  srcsa.sin6_addr = ipv6->ipv6_src;
d308 1
a308 1
  dstsa.sin6_addr = ipv6->ipv6_dst;
d316 1
a316 1
	ipv6 = mtod(m, struct ipv6 *);
d321 1
a321 1
    DPRINTF(ERROR, ("ripv6_input: ipv6_findnexthdr failed\n"));
d328 3
a330 3
    if (m->m_len < extra + sizeof(struct icmpv6hdr)) {
      if (!(m = m_pullup2(m, extra + sizeof(struct icmpv6hdr)))) {
        DPRINTF(ERROR, ("ripv6_input: m_pullup2 failed\n"));
d333 1
a333 1
      ipv6 = mtod(m, struct ipv6 *);
d335 1
a335 1
    icmpv6type = ((struct icmpv6hdr *)(mtod(m, caddr_t) + extra))->icmpv6_type;
d337 1
a337 1
    icmpv6type = -1;
d348 1
a348 1
       inp = inp->inp_queue.cqe_next) {
d350 1
a350 1
  for (inp = rawin6pcb.inp_next; inp != &rawin6pcb; inp = inp->inp_next) {
d353 2
a354 1
    if (inp->inp_ipv6.ipv6_nexthdr && inp->inp_ipv6.ipv6_nexthdr != nexthdr)
d357 1
a357 1
	!IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &ipv6->ipv6_dst))
d360 1
a360 1
	!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, &ipv6->ipv6_src))
d362 2
a363 2
    if ((icmpv6type >= 0) && 
	ICMPV6_FILTER_WILLBLOCK(icmpv6type, &inp->inp_filter))
d387 2
a388 2
      if (inp->inp_flags & INP_CONTROLOPTS)
        opts = ipv6_headertocontrol(m, extra, inp->inp_flags);
d405 1
d408 1
d415 2
a416 1
  DPRINTF(FINISHED, ("ripv6_input\n"));
d420 1
a420 1
 * Output function for raw IPv6.  Called from ripv6_usrreq(), and
d425 1
a425 1
int ripv6_output(struct mbuf *m, ...)
d428 1
a428 1
ripv6_output(m, so, dst, control)
d435 1
a435 1
  register struct ipv6 *ipv6;
d438 2
d441 3
d447 1
a447 1
  struct in6_addr *dst;
d452 1
a452 1
  dst = va_arg(ap, struct in6_addr *);
d460 9
d477 1
d479 17
a495 7
      M_PREPEND(m, sizeof(struct ipv6), M_WAIT);
      ipv6 = mtod(m, struct ipv6 *);
      ipv6->ipv6_nexthdr = inp->inp_ipv6.ipv6_nexthdr;
      ipv6->ipv6_hoplimit = MAXHOPLIMIT;
      ipv6->ipv6_src = inp->inp_laddr6;
      ipv6->ipv6_dst = *dst;
      ipv6->ipv6_versfl = 0;  /* Or possibly user flow label, in host order. */
d503 37
d541 3
a543 2
    int payload = sizeof(struct ipv6);
    int nexthdr = mtod(m, struct ipv6 *)->ipv6_nexthdr;
d545 1
a545 6

    if (control)
      if ((error = ipv6_controltoheader(&m, control, &forceif, &payload))) {
        m_freem(m);
        return error;
      }
d551 1
a551 1
	DPRINTF(IDL_ERROR, ("ripv6_output: m_pullup2(m, %d) failed\n", payload + inp->inp_csumoffset));
d559 1
a559 1
      *csum = in6_cksum(m, nexthdr, m->m_pkthdr.len - payload, payload);
d563 6
a568 1
  return ipv6_output(m,&inp->inp_route6,flags,inp->inp_moptions6, forceif, so);
d576 1
a576 1
int ripv6_ctloutput(struct socket *so, struct sockopt *sopt)
d584 1
a584 1
  DPRINTF(FINISHED, ("ripv6_ctloutput(so=%08x, sopt=%08x)\n",
d602 1
a602 1
ripv6_ctloutput (op, so, level, optname, m)
d610 1
a610 1
  DPRINTF(FINISHED, ("ripv6_ctloutput(op=%x,so,level=%x,optname=%x,m)\n", op, level, optname));
d650 1
a650 1
    case ICMPV6_FILTER:
d654 1
a654 1
            sizeof(struct icmpv6_filter)))
d657 3
a659 3
          struct icmpv6_filter icmpv6_filter;
          int error = sooptcopyin(sopt, &icmpv6_filter,
            sizeof(struct icmpv6_filter), sizeof(struct icmpv6_filter));
d663 1
a663 1
          inp->inp_filter = icmpv6_filter;
d667 2
a668 2
          return sooptcopyout(sopt, &inp->inp_filter,
            sizeof(struct icmpv6_filter));
d670 1
a670 1
        if (!m || !*m || (*m)->m_len != sizeof(struct icmpv6_filter))
d673 2
a674 1
          inp->inp_filter = *mtod(*m, struct icmpv6_filter *);
d677 2
a678 2
          (*m)->m_len = sizeof(struct icmpv6_filter);
          *mtod(*m, struct icmpv6_filter *) = inp->inp_filter;
d762 1
a762 1
  return ipv6_ctloutput(so, sopt);
d764 1
a764 1
  return ipv6_ctloutput(op, so, level, optname, m);
d777 1
a777 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_attach(struct socket *so, int proto,
d780 1
a780 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_attach(struct socket *so, int proto)
d787 1
a787 1
     panic("ripv6_attach - Already got PCB");
d798 1
a798 1
  if ((error = soreserve(so, ripv6_sendspace, ripv6_recvspace)) ||
d814 1
a814 1
  inp->inp_ipv6.ipv6_nexthdr = (u_long)proto;     /*nam;  Nam contains protocol
d817 1
a817 1
  inp->inp_ipv6.ipv6_nexthdr = (int)proto;     /*nam;   Nam contains protocol
d820 1
a820 1
  if (inp->inp_ipv6.ipv6_nexthdr == IPPROTO_ICMPV6)
d822 3
d828 1
a828 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_detach(struct socket *so)
d833 1
a833 1
     panic("ripv6_detach");
d837 4
d845 1
a845 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_abort(struct socket *so)
d848 1
a848 1
   return ripv6_usrreq_detach(so);
d851 1
a851 1
static MAYBEINLINE int ripv6_usrreq_disconnect(struct socket *so)
d855 1
a855 1
   return ripv6_usrreq_abort(so);
d859 1
a859 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_bind(struct socket *so,
d862 1
a862 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_bind(struct socket *so,
d886 1
a886 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_connect(struct socket *so,
d889 1
a889 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_connect(struct socket *so,
d895 2
d901 9
a909 8
#if __NetBSD__ || __FreeBSD__ || __OpenBSD__
     if (ifnet.tqh_first == 0) {
#else /* __NetBSD__ || __FreeBSD__ || __OpenBSD__ */
     if (ifnet == 0) {
#endif /* __NetBSD__ || __FreeBSD__ || __OpenBSD__ */
       return EADDRNOTAVAIL;  /* This is a weird way to say there
			          are no interfaces, no? */
     }
d917 1
a917 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_shutdown(struct socket *so)
d923 3
d931 1
a931 1
int ripv6_usrreq_send(struct socket *so, int flags, struct mbuf *m,
d935 1
a935 1
int ripv6_usrreq_send(struct socket *so, int flags, struct mbuf *m,
d941 1
a941 1
  struct in6_addr *dst;
d957 5
a961 1
       dst = &(inp->inp_faddr6); 
d968 1
a968 1
       dst = &((struct sockaddr_in6 *)addr)->sin6_addr;
d971 1
a971 1
   error = ripv6_output(m,so,dst,control);
d977 1
a977 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_control(struct socket *so, u_long cmd,
d980 1
a980 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_control(struct socket *so, int cmd,
d993 1
a993 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_sense(struct socket *so,
d1001 1
a1001 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_sockaddr(struct socket *so,
d1004 1
a1004 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_sockaddr(struct socket *so,
d1013 1
a1013 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_peeraddr(struct socket *so,
d1016 1
a1016 1
MAYBESTATIC MAYBEINLINE int ripv6_usrreq_peeraddr(struct socket *so,
d1025 7
a1031 7
struct pr_usrreqs ripv6_usrreqs = {
  ripv6_usrreq_abort, pru_accept_notsupp, ripv6_usrreq_attach,
  ripv6_usrreq_bind, ripv6_usrreq_connect, pru_connect2_notsupp,
  ripv6_usrreq_control, ripv6_usrreq_detach, ripv6_usrreq_detach,
  pru_listen_notsupp, ripv6_usrreq_peeraddr, pru_rcvd_notsupp,
  pru_rcvoob_notsupp, ripv6_usrreq_send, ripv6_usrreq_sense,
  ripv6_usrreq_shutdown, ripv6_usrreq_sockaddr, sosend, soreceive, sopoll
d1040 1
a1040 5
#if __NetBSD__
ripv6_usrreq(so, req, m, nam, control, p)
#else /* __NetBSD__ */
ripv6_usrreq(so, req, m, nam, control)
#endif /* __NetBSD__ */
a1043 1
#if __NetBSD__
a1044 1
#endif /* __NetBSD__ */
d1048 1
a1048 1
  DPRINTF(IDL_EVENT, ("ripv6_usrreq(so, req, m, nam, control)\n"));
d1064 1
a1064 1
      error = ripv6_usrreq_attach(so, 0, p);  /* XXX */
d1066 1
a1066 1
      error = ripv6_usrreq_attach(so, 0);  /* XXX */
d1070 1
a1070 1
      error = ripv6_usrreq_disconnect(so);
d1075 1
a1075 1
      error = ripv6_usrreq_abort(so);
d1080 1
a1080 1
      error = ripv6_usrreq_detach(so);
d1089 1
a1089 1
      error = ripv6_usrreq_bind(so, mtod(nam, struct sockaddr *), p);
d1091 1
a1091 1
      error = ripv6_usrreq_bind(so, mtod(nam, struct sockaddr *));
d1101 1
a1101 1
      error = ripv6_usrreq_connect(so, mtod(nam, struct sockaddr *), p);
d1103 1
a1103 1
      error = ripv6_usrreq_connect(so, mtod(nam, struct sockaddr *));
d1107 1
a1107 1
      error = ripv6_usrreq_shutdown(so);
d1116 1
a1116 1
      error = ripv6_usrreq_send(so, 0, m, mtod(nam, struct sockaddr *), control, p);
d1118 1
a1118 1
      error = ripv6_usrreq_send(so, 0, m, mtod(nam, struct sockaddr *), control);
d1124 1
a1124 1
      return ripv6_usrreq_control(so, (u_long)m, (caddr_t) nam, 
d1127 1
a1127 1
      return ripv6_usrreq_control(so, (int)m, (caddr_t) nam, 
d1131 1
a1131 1
      return ripv6_usrreq_sense(so, NULL); /* XXX */
d1141 1
a1141 1
      error = ripv6_usrreq_sockaddr(so, nam);
d1144 1
a1144 1
      error = ripv6_usrreq_peeraddr(so, nam);
d1147 1
a1147 1
      panic ("ripv6_usrreq - unknown req\n");
@


1.3
log
@Demangled the INET6 stuff so as not to require any extra options and not to
be mutually exclusive with the IPSEC option.
@
text
@d45 1
a45 1
 *	$Id: raw_ipv6.c,v 1.2 1999/02/24 04:36:46 cmetz Exp $
d158 2
a159 2
	ri6pcbinfo.hashbase = hashinit(1, M_PCB, &ri6pcbinfo.hashmask);
	ri6pcbinfo.porthashbase = hashinit(1, M_PCB, &ri6pcbinfo.porthashmask);
@


1.2
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d45 1
a45 1
 *	$Id: raw_ipv6.c,v 1.54 1998/12/22 21:55:43 cmetz Exp $
d81 3
a83 1
#if __OpenBSD__ && defined(NRL_IPSEC)
d85 2
a86 1
#endif /* __OpenBSD__ && defined(NRL_IPSEC) */
d94 1
a94 1
#ifdef DEBUG_NRL_SYS
d96 2
a97 2
#endif /* DEBUG_NRL_SYS */
#ifdef DEBUG_NRL_NETINET6
d99 4
a102 1
#endif /* DEBUG_NRL_NETINET6 */
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@d91 1
d93 4
a127 3
struct mbuf *ipv6_headertocontrol(struct mbuf *m, size_t extra, int inp_flags);
int ipv6_controltoheader(struct mbuf **m, struct mbuf *control, struct ifnet **forceifp, int *);

d204 1
a204 1
	     ((struct ipv6_opthdr *)p)->oh_extlen << 3;
d216 1
a216 1
	     ((struct ipv6_srcroute0 *)p)->i6sr_len << 3;
a279 1

@

