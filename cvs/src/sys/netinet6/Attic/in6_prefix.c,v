head	1.14;
access;
symbols
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.14
date	2002.06.08.21.22.02;	author itojun;	state dead;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.24.16.57.33;	author brian;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.25.09.24.26;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.25.06.46.00;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.08.14.51.22;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.12.29.02.15.08;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.07.06.56.30;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.09.07.34.49;	author itojun;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.07.06.05.41;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.04.18.13.36;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.55.21;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.03.28.00.41.29;	author niklas;	state dead;
branches;
next	;

1.12.4.1
date	2002.06.11.03.31.37;	author art;	state dead;
branches;
next	;


desc
@@


1.14
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@/*	$OpenBSD: in6_prefix.c,v 1.13 2002/03/14 01:27:12 millert Exp $	*/
/*	$KAME: in6_prefix.c,v 1.47 2001/03/25 08:41:39 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in.c	8.2 (Berkeley) 11/15/93
 */

#include <sys/param.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sockio.h>
#include <sys/systm.h>
#include <sys/syslog.h>
#include <sys/proc.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/in_var.h>
#include <netinet/ip6.h>
#include <netinet6/in6_prefix.h>
#include <netinet6/ip6_var.h>

struct rr_prhead rr_prefix;

struct timeout in6_rr_timer_ch;

static void	add_each_addr(struct socket *so, struct rr_prefix *rpp,
				   struct rp_addr *rap);
static int create_ra_entry(struct rp_addr **rapp);
static int add_each_prefix(struct socket *so, struct rr_prefix *rpp);
static void free_rp_entries(struct rr_prefix *rpp);
static int link_stray_ia6s(struct rr_prefix *rpp);
static void	rp_remove(struct rr_prefix *rpp);

/*
 * Copy bits from src to tgt, from off bit for len bits.
 * Caller must specify collect tgtsize and srcsize.
 */
static void
bit_copy(char *tgt, u_int tgtsize, char *src, u_int srcsize,
	 u_int off, u_int len)
{
	char *sp, *tp;

	/* arg values check */
	if (srcsize < off || srcsize < (off + len) ||
	    tgtsize < off || tgtsize < (off + len)) {
		log(LOG_ERR,
		    "in6_prefix.c: bit_copy: invalid args: srcsize %d,\n"
		    "tgtsize %d, off %d, len %d\n", srcsize, tgtsize, off,
		    len);
		return;
	}

	/* search start point */
	for (sp = src, tp = tgt; off >= 8; sp++, tp++)
		off-=8;
	/* copy starting bits */
	if (off) {
		char setbit;
		int startbits;

		startbits = min((8 - off), len);

		for (setbit = (0x80 >> off); startbits;
		     setbit >>= 1, startbits--, len--)
				*tp  |= (setbit & *sp);
		tp++;
		sp++;
	}
	/* copy midium bits */
	for (; len >= 8; sp++, tp++) {
		*tp = *sp;
		len-=8;
	}
	/* copy ending bits */
	if (len) {
		char setbit;

		for (setbit = 0x80; len; setbit >>= 1, len--)
			*tp  |= (setbit & *sp);
	}
}

static struct ifprefix *
in6_prefixwithifp(struct ifnet *ifp, int plen, struct in6_addr *dst)
{
	struct ifprefix *ifpr;

	/* search matched prefix */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		if (plen <= in6_matchlen(dst, IFPR_IN6(ifpr)))
			break;
	}
	return (ifpr);
}

/*
 * Search prefix which matches arg prefix as specified in
 * draft-ietf-ipngwg-router-renum-08.txt
 */
static struct rr_prefix *
search_matched_prefix(struct ifnet *ifp, struct in6_prefixreq *ipr)
{
	struct ifprefix *ifpr;
	struct ifaddr *ifa;
	struct rr_prefix *rpp;

	/* search matched prefix */
	ifpr = in6_prefixwithifp(ifp, ipr->ipr_plen,
				 &ipr->ipr_prefix.sin6_addr);
	if (ifpr != NULL)
		return ifpr2rp(ifpr);

	/*
	 * search matched addr, and then search prefix
	 * which matches the addr
	 */

	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (ipr->ipr_plen <=
		    in6_matchlen(&ipr->ipr_prefix.sin6_addr, IFA_IN6(ifa)))
			break;
	}
	if (ifa == NULL)
		return NULL;

	rpp = ifpr2rp(((struct in6_ifaddr *)ifa)->ia6_ifpr);
	if (rpp != 0)
		return rpp;

	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
			continue;
		if (ifpr->ifpr_plen <= in6_matchlen(IFA_IN6(ifa),
						    IFPR_IN6(ifpr)))
			break;
	}
	if (ifpr != NULL)
		log(LOG_ERR,  "in6_prefix.c: search_matched_prefix: addr %s"
		    "has no pointer to prefix %s\n", ip6_sprintf(IFA_IN6(ifa)),
		    ip6_sprintf(IFPR_IN6(ifpr)));
	return ifpr2rp(ifpr);
}

/*
 * Search prefix which matches arg prefix as specified in
 * draft-ietf-ipngwg-router-renum-08.txt, and mark it if exists.
 * Return 1 if anything matched, and 0 if nothing matched.
 */
static int
mark_matched_prefixes(u_long cmd, struct ifnet *ifp, struct in6_rrenumreq *irr)
{
	struct ifprefix *ifpr;
	struct ifaddr *ifa;
	int matchlen, matched = 0;

	/* search matched prefixes */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
			continue;
		matchlen = in6_matchlen(&irr->irr_matchprefix.sin6_addr,
					IFPR_IN6(ifpr));
		if (irr->irr_m_minlen > ifpr->ifpr_plen ||
		    irr->irr_m_maxlen < ifpr->ifpr_plen ||
		    irr->irr_m_len > matchlen)
 			continue;
		matched = 1;
		ifpr2rp(ifpr)->rp_statef_addmark = 1;
		if (cmd == SIOCCIFPREFIX_IN6)
			ifpr2rp(ifpr)->rp_statef_delmark = 1;
	}

	/*
	 * search matched addr, and then search prefixes
	 * which matche the addr
	 */
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
	{
		struct rr_prefix *rpp;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		matchlen = in6_matchlen(&irr->irr_matchprefix.sin6_addr,
					IFA_IN6(ifa));
		if (irr->irr_m_minlen > matchlen ||
		    irr->irr_m_maxlen < matchlen || irr->irr_m_len > matchlen)
 			continue;
		rpp = ifpr2rp(((struct in6_ifaddr *)ifa)->ia6_ifpr);
		if (rpp != 0) {
			matched = 1;
			rpp->rp_statef_addmark = 1;
			if (cmd == SIOCCIFPREFIX_IN6)
				rpp->rp_statef_delmark = 1;
		} else
			log(LOG_WARNING, "in6_prefix.c: mark_matched_prefixes:"
			    "no back pointer to ifprefix for %s. "
			    "ND autoconfigured addr?\n",
			    ip6_sprintf(IFA_IN6(ifa)));
	}
	return matched;
}

/*
 * Mark global prefixes as to be deleted.
 */
static void
delmark_global_prefixes(struct ifnet *ifp, struct in6_rrenumreq *irr)
{
	struct ifprefix *ifpr;

	/* search matched prefixes */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
			continue;
		/* mark delete global prefix */
		if (in6_addrscope(RP_IN6(ifpr2rp(ifpr))) ==
		    IPV6_ADDR_SCOPE_GLOBAL)
			ifpr2rp(ifpr)->rp_statef_delmark = 1;
	}
}

/* Unmark prefixes */
static void
unmark_prefixes(struct ifnet *ifp)
{
	struct ifprefix *ifpr;

	/* unmark all prefix */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		/* unmark prefix */
		ifpr2rp(ifpr)->rp_statef_addmark = 0;
		ifpr2rp(ifpr)->rp_statef_delmark = 0;
	}
}

static void
init_prefix_ltimes(struct rr_prefix *rpp)
{
	long time_second = time.tv_sec;

	if (rpp->rp_pltime == RR_INFINITE_LIFETIME ||
	    rpp->rp_rrf_decrprefd == 0)
		rpp->rp_preferred = 0;
	else
		rpp->rp_preferred = time_second + rpp->rp_pltime;
	if (rpp->rp_vltime == RR_INFINITE_LIFETIME ||
	    rpp->rp_rrf_decrvalid == 0)
		rpp->rp_expire = 0;
	else
		rpp->rp_expire = time_second + rpp->rp_vltime;
}

static int
rr_are_ifid_equal(struct in6_addr *ii1, struct in6_addr *ii2, int ii_len)
{
	int ii_bytelen, ii_bitlen;
	int p_bytelen, p_bitlen;

	/* sanity check */
	if (1 > ii_len ||
	    ii_len > 124) { /* as RFC2373, prefix is at least 4 bit */
		log(LOG_ERR, "rr_are_ifid_equal: invalid ifid length(%d)\n",
		    ii_len);
		return(0);
	}

	ii_bytelen = ii_len / 8;
	ii_bitlen = ii_len % 8;

	p_bytelen = sizeof(struct in6_addr) - ii_bytelen - 1;
	p_bitlen = 8 - ii_bitlen;

	if (bcmp(ii1->s6_addr + p_bytelen + 1, ii2->s6_addr + p_bytelen + 1,
		 ii_bytelen))
		return(0);
	if (((ii1->s6_addr[p_bytelen] << p_bitlen) & 0xff) !=
	    ((ii2->s6_addr[p_bytelen] << p_bitlen) & 0xff))
		return(0);

	return(1);
}

static struct rp_addr *
search_ifidwithprefix(struct rr_prefix *rpp, struct in6_addr *ifid)
{
	struct rp_addr *rap;

	for (rap = rpp->rp_addrhead.lh_first; rap != NULL;
	     rap = rap->ra_entry.le_next)
	{
		if (rr_are_ifid_equal(ifid, &rap->ra_ifid,
				      (sizeof(struct in6_addr) << 3) -
				      rpp->rp_plen))
			break;
	}
	return rap;
}

static int
assign_ra_entry(struct rr_prefix *rpp, int iilen, struct in6_ifaddr *ia)
{
	int error = 0;
	struct rp_addr *rap;
	int s;

	if ((error = create_ra_entry(&rap)) != 0)
		return error;

	/* copy interface id part */
	bit_copy((caddr_t)&rap->ra_ifid, sizeof(rap->ra_ifid) << 3,
		 (caddr_t)IA6_IN6(ia),
		 sizeof(*IA6_IN6(ia)) << 3, rpp->rp_plen, iilen);
	/* link to ia, and put into list */
	rap->ra_addr = ia;
	rap->ra_addr->ia_ifa.ifa_refcnt++;
#if 0 /* Can't do this now, because rpp may be on th stack. should fix it? */
	ia->ia6_ifpr = rp2ifpr(rpp);
#endif
	s = splnet();
	LIST_INSERT_HEAD(&rpp->rp_addrhead, rap, ra_entry);
	splx(s);

	return 0;
}

/*
 * add a link-local address to an interface.  we will add new interface address
 * (prefix database + new interface id).
 */
static int
in6_prefix_add_llifid(int iilen, struct in6_ifaddr *ia)
{
	struct rr_prefix *rpp;
	struct rp_addr *rap;
	struct socket so;
	int error, s;

	if ((error = create_ra_entry(&rap)) != 0)
		return(error);
	/* copy interface id part */
	bit_copy((caddr_t)&rap->ra_ifid, sizeof(rap->ra_ifid) << 3,
		 (caddr_t)IA6_IN6(ia), sizeof(*IA6_IN6(ia)) << 3,
		 64, (sizeof(rap->ra_ifid) << 3) - 64);
	/* XXX: init dummy so */
	bzero(&so, sizeof(so));
	/* insert into list */
	for (rpp = LIST_FIRST(&rr_prefix); rpp; rpp = LIST_NEXT(rpp, rp_entry))
	{
		/*
		 * do not attempt to add an address, if ifp does not match
		 */
		if (rpp->rp_ifp != ia->ia_ifp)
			continue;

		s = splnet();
		LIST_INSERT_HEAD(&rpp->rp_addrhead, rap, ra_entry);
		splx(s);
		add_each_addr(&so, rpp, rap);
	}
	return 0;
}

/*
 * add an address to an interface.  if the interface id portion is new,
 * we will add new interface address (prefix database + new interface id).
 */
int
in6_prefix_add_ifid(int iilen, struct in6_ifaddr *ia)
{
	int plen = (sizeof(*IA6_IN6(ia)) << 3) - iilen;
	struct ifprefix *ifpr;
	struct rp_addr *rap;
	int error = 0;

	if (IN6_IS_ADDR_LINKLOCAL(IA6_IN6(ia)))
		return(in6_prefix_add_llifid(iilen, ia));
	ifpr = in6_prefixwithifp(ia->ia_ifp, plen, IA6_IN6(ia));
	if (ifpr == NULL) {
		struct rr_prefix rp;
		struct socket so;
		int pplen = (plen == 128) ? 64 : plen;

		/* allocate a prefix for ia, with default properties */

		/* init rp */
		bzero(&rp, sizeof(rp));
		rp.rp_type = IN6_PREFIX_RR;
		rp.rp_ifp = ia->ia_ifp;
		rp.rp_plen = pplen;
		rp.rp_prefix.sin6_len = sizeof(rp.rp_prefix);
		rp.rp_prefix.sin6_family = AF_INET6;
		bit_copy((char *)RP_IN6(&rp), sizeof(*RP_IN6(&rp)) << 3,
			 (char *)&ia->ia_addr.sin6_addr,
			 sizeof(ia->ia_addr.sin6_addr) << 3,
			 0, pplen);
		rp.rp_vltime = rp.rp_pltime = RR_INFINITE_LIFETIME;
		rp.rp_raf_onlink = 1;
		rp.rp_raf_auto = 1;
		/* Is some FlagMasks for rrf necessary? */
		rp.rp_rrf_decrvalid = rp.rp_rrf_decrprefd = 0;
		rp.rp_origin = PR_ORIG_RR; /* can be renumbered */

		/* create ra_entry */
		error = link_stray_ia6s(&rp);
		if (error != 0) {
			free_rp_entries(&rp);
			return error;
		}

		/* XXX: init dummy so */
		bzero(&so, sizeof(so));
		so.so_state |= SS_PRIV;

		error = add_each_prefix(&so, &rp);

		/* free each rp_addr entry */
		free_rp_entries(&rp);

		if (error != 0)
			return error;

		/* search again */
		ifpr = in6_prefixwithifp(ia->ia_ifp, pplen, IA6_IN6(ia));
		if (ifpr == NULL)
			return 0;
	}
	rap = search_ifidwithprefix(ifpr2rp(ifpr), IA6_IN6(ia));
	if (rap != NULL) {
		if (rap->ra_addr == NULL) {
			rap->ra_addr = ia;
			rap->ra_addr->ia_ifa.ifa_refcnt++;
		} else if (rap->ra_addr != ia) {
			/* There may be some inconsistencies between addrs. */
			log(LOG_ERR, "ip6_prefix.c: addr %s/%d matched prefix"
			    " already has another ia %p(%s) on its ifid list\n",
			    ip6_sprintf(IA6_IN6(ia)), plen,
			    rap->ra_addr,
			    ip6_sprintf(IA6_IN6(rap->ra_addr)));
			return EADDRINUSE /* XXX */;
		}
		ia->ia6_ifpr = ifpr;
		return 0;
	}
	error = assign_ra_entry(ifpr2rp(ifpr), iilen, ia);
	if (error == 0)
		ia->ia6_ifpr = ifpr;
	return (error);
}

void
in6_prefix_remove_ifid(int iilen, struct in6_ifaddr *ia)
{
	struct rp_addr *rap;

	if (ia->ia6_ifpr == NULL)
		return;
	rap = search_ifidwithprefix(ifpr2rp(ia->ia6_ifpr), IA6_IN6(ia));
	if (rap != NULL) {
		int s = splnet();
		LIST_REMOVE(rap, ra_entry);
		splx(s);
		if (rap->ra_addr)
			IFAFREE(&rap->ra_addr->ia_ifa);
		free(rap, M_RR_ADDR);
	}
	if (LIST_FIRST(&ifpr2rp(ia->ia6_ifpr)->rp_addrhead) == NULL)
		rp_remove(ifpr2rp(ia->ia6_ifpr));
}

void
in6_purgeprefix(ifp)
	struct ifnet *ifp;
{
	struct ifprefix *ifpr, *nextifpr;

	/* delete prefixes before ifnet goes away */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
		nextifpr = ifpr->ifpr_next;
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		(void)delete_each_prefix(ifpr2rp(ifpr), PR_ORIG_KERNEL);
	}
}

static void
add_each_addr(struct socket *so, struct rr_prefix *rpp, struct rp_addr *rap)
{
	struct in6_ifaddr *ia6;
	struct in6_aliasreq ifra;
	int error;

	/* init ifra */
	bzero(&ifra, sizeof(ifra));
	strncpy(ifra.ifra_name, rpp->rp_ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_addr.sin6_family = ifra.ifra_prefixmask.sin6_family =
		AF_INET6;
	ifra.ifra_addr.sin6_len = ifra.ifra_prefixmask.sin6_len =
		sizeof(ifra.ifra_addr);
	/* copy prefix part */
	bit_copy((char *)&ifra.ifra_addr.sin6_addr,
		 sizeof(ifra.ifra_addr.sin6_addr) << 3,
		 (char *)RP_IN6(rpp), sizeof(*RP_IN6(rpp)) << 3,
		 0, rpp->rp_plen);
	/* copy interface id part */
	bit_copy((char *)&ifra.ifra_addr.sin6_addr,
		 sizeof(ifra.ifra_addr.sin6_addr) << 3,
		 (char *)&rap->ra_ifid, sizeof(rap->ra_ifid) << 3,
		 rpp->rp_plen, (sizeof(rap->ra_ifid) << 3) - rpp->rp_plen);
	in6_prefixlen2mask(&ifra.ifra_prefixmask.sin6_addr, rpp->rp_plen);
	/* don't care ifra_flags for now */

	ia6 = in6ifa_ifpwithaddr(rpp->rp_ifp, &ifra.ifra_addr.sin6_addr);
	if (ia6 != NULL) {
		if (ia6->ia6_ifpr == NULL) {
			/* link this addr and the prefix each other */
			if (rap->ra_addr)
				IFAFREE(&rap->ra_addr->ia_ifa);
			rap->ra_addr = ia6;
			rap->ra_addr->ia_ifa.ifa_refcnt++;
			ia6->ia6_ifpr = rp2ifpr(rpp);
			return;
		}
		if (ia6->ia6_ifpr == rp2ifpr(rpp)) {
			if (rap->ra_addr)
				IFAFREE(&rap->ra_addr->ia_ifa);
			rap->ra_addr = ia6;
			rap->ra_addr->ia_ifa.ifa_refcnt++;
			return;
		}
		/*
		 * The addr is already assigned to other
		 * prefix.
		 * There may be some inconsistencies between
		 * prefixes.
		 * e.g. overraped prefixes with common starting
		 *      part and different plefixlen.
		 *      Or, completely duplicated prefixes?
		 * log it and return.
		 */
		log(LOG_ERR, "in6_prefix.c: add_each_addr: addition of an addr "
		    "%s/%d failed because there is already another addr %s/%d\n",
		    ip6_sprintf(&ifra.ifra_addr.sin6_addr), rpp->rp_plen,
		    ip6_sprintf(IA6_IN6(ia6)),
		    in6_mask2len(&ia6->ia_prefixmask.sin6_addr));
		return;
	}
	/* propagate ANYCAST flag if it is set for ancestor addr */
	if (rap->ra_flags.anycast != 0)
		ifra.ifra_flags |= IN6_IFF_ANYCAST;
	error = in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, rpp->rp_ifp
			    , curproc);
	if (error != 0) {
		log(LOG_ERR, "in6_prefix.c: add_each_addr: addition of an addr"
		    "%s/%d failed because in6_control failed for error %d\n",
		    ip6_sprintf(&ifra.ifra_addr.sin6_addr), rpp->rp_plen,
		    error);
		return;
	}

	/*
	 * link beween this addr and the prefix will be done
	 * in in6_prefix_add_ifid
	 */
}

static int
rrpr_update(struct socket *so, struct rr_prefix *new)
{
	struct rr_prefix *rpp;
	struct ifprefix *ifpr;
	struct rp_addr *rap;
	int s;

	/* search existing prefix */
	for (ifpr = new->rp_ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		if (ifpr->ifpr_plen == new->rp_plen &&
		    in6_are_prefix_equal(IFPR_IN6(ifpr), RP_IN6(new),
					 ifpr->ifpr_plen))
			break;
	}
	rpp = ifpr2rp(ifpr);
	if (rpp != NULL) {
		/*
		 * We got a prefix which we have seen in the past.
		 */
		/*
		 * If the origin of the already-installed prefix is more
		 * preferable than the new one, ignore installation request.
		 */
		if (rpp->rp_origin > new->rp_origin)
			return(EPERM);

		/* update prefix information */
		rpp->rp_flags.prf_ra = new->rp_flags.prf_ra;
		if (rpp->rp_origin >= PR_ORIG_RR)
			rpp->rp_flags.prf_rr = new->rp_flags.prf_rr;
		rpp->rp_vltime = new->rp_vltime;
		rpp->rp_pltime = new->rp_pltime;
		rpp->rp_expire = new->rp_expire;
		rpp->rp_preferred = new->rp_preferred;
		rpp->rp_statef_delmark = 0; /* cancel deletion */
		/*
		 * Interface id related update.
		 *  add rp_addr entries in new into rpp, if they have not
		 *  been already included in rpp.
		 */
		while (new->rp_addrhead.lh_first != NULL)
		{
			rap = LIST_FIRST(&new->rp_addrhead);
			LIST_REMOVE(rap, ra_entry);
			if (search_ifidwithprefix(rpp, &rap->ra_ifid)
			    != NULL) {
				if (rap->ra_addr)
					IFAFREE(&rap->ra_addr->ia_ifa);
				free(rap, M_RR_ADDR);
				continue;
			}
			s = splnet();
			LIST_INSERT_HEAD(&rpp->rp_addrhead, rap, ra_entry);
			splx(s);
		}
	} else {
		/*
		 * We got a fresh prefix.
		 */
		/* create new prefix */
		rpp = (struct rr_prefix *)malloc(sizeof(*rpp), M_IP6RR,
						 M_NOWAIT);
		if (rpp == NULL) {
			log(LOG_ERR, "in6_prefix.c: rrpr_update:%d"
			    ": ENOBUFS for rr_prefix\n", __LINE__);
			return(ENOBUFS);
		}
		/* initilization */
		*rpp = *new;
		LIST_INIT(&rpp->rp_addrhead);
		/*  move rp_addr entries of new to rpp */
		while (new->rp_addrhead.lh_first != NULL)
		{
			rap = LIST_FIRST(&new->rp_addrhead);
			LIST_REMOVE(rap, ra_entry);
			LIST_INSERT_HEAD(&rpp->rp_addrhead, rap, ra_entry);
		}

		/* let rp_ifpr.ifpr_prefix point rr_prefix. */
		rpp->rp_ifpr.ifpr_prefix = (struct sockaddr *)&rpp->rp_prefix;
		/* link rr_prefix entry to if_prefixlist */
		{
			struct ifnet *ifp = rpp->rp_ifp;
			struct ifprefix *ifpr;

			if ((ifpr = ifp->if_prefixlist) != NULL) {
				for ( ; ifpr->ifpr_next;
				      ifpr = ifpr->ifpr_next)
					continue;
				ifpr->ifpr_next = rp2ifpr(rpp);
			} else
				ifp->if_prefixlist = rp2ifpr(rpp);
			rp2ifpr(rpp)->ifpr_type = IN6_PREFIX_RR;
		}
		/* link rr_prefix entry to rr_prefix list */
		s = splnet();
		LIST_INSERT_HEAD(&rr_prefix, rpp, rp_entry);
		splx(s);
	}

	if (!new->rp_raf_auto)
		return 0;

	/*
	 * Add an address for each interface id, if it is not yet
	 * If it existed but not pointing to the prefix yet,
	 * init the prefix pointer.
	 */
	for (rap = rpp->rp_addrhead.lh_first; rap != NULL;
	     rap = rap->ra_entry.le_next)
	{
		if (rap->ra_addr != NULL) {
			if (rap->ra_addr->ia6_ifpr == NULL)
				rap->ra_addr->ia6_ifpr = rp2ifpr(rpp);
			continue;
		}
		add_each_addr(so, rpp, rap);
	}
	return 0;
}

static int
add_each_prefix(struct socket *so, struct rr_prefix *rpp)
{
	init_prefix_ltimes(rpp);
	return(rrpr_update(so, rpp));
}

static void
rp_remove(struct rr_prefix *rpp)
{
	int s;

	s = splnet();
	/* unlink rp_entry from if_prefixlist */
	{
		struct ifnet *ifp = rpp->rp_ifp;
		struct ifprefix *ifpr;

		if ((ifpr = ifp->if_prefixlist) == rp2ifpr(rpp))
			ifp->if_prefixlist = ifpr->ifpr_next;
		else {
			while (ifpr->ifpr_next &&
			       (ifpr->ifpr_next != rp2ifpr(rpp)))
				ifpr = ifpr->ifpr_next;
			if (ifpr->ifpr_next)
				ifpr->ifpr_next = rp2ifpr(rpp)->ifpr_next;
			else
				printf("Couldn't unlink rr_prefix from ifp\n");
		}
	}
	/* unlink rp_entry from rr_prefix list */
	LIST_REMOVE(rpp, rp_entry);
	splx(s);
	free(rpp, M_IP6RR);
}

static int
create_ra_entry(struct rp_addr **rapp)
{
	*rapp = (struct rp_addr *)malloc(sizeof(struct rp_addr), M_RR_ADDR,
					 M_NOWAIT);
	if (*rapp == NULL) {
		log(LOG_ERR, "in6_prefix.c: init_newprefix:%d: ENOBUFS"
		    "for rp_addr\n", __LINE__);
		return ENOBUFS;
	}
	bzero(*rapp, sizeof(*(*rapp)));

	return 0;
}

static int
init_newprefix(struct in6_rrenumreq *irr, struct ifprefix *ifpr,
	       struct rr_prefix *rpp)
{
	struct rp_addr *orap;

	/* init rp */
	bzero(rpp, sizeof(*rpp));
	rpp->rp_type = IN6_PREFIX_RR;
	rpp->rp_ifp = ifpr->ifpr_ifp;
	rpp->rp_plen = ifpr->ifpr_plen;
	rpp->rp_prefix.sin6_len = sizeof(rpp->rp_prefix);
	rpp->rp_prefix.sin6_family = AF_INET6;
	bit_copy((char *)RP_IN6(rpp), sizeof(*RP_IN6(rpp)) << 3,
		 (char *)&irr->irr_useprefix.sin6_addr,
		 sizeof(irr->irr_useprefix.sin6_addr) << 3,
		 0, irr->irr_u_uselen);
	/* copy keeplen part if necessary as necessary len */
	if (irr->irr_u_uselen < ifpr->ifpr_plen)
		bit_copy((char *)RP_IN6(rpp), sizeof(*RP_IN6(rpp)) << 3,
			 (char *)IFPR_IN6(ifpr), sizeof(*IFPR_IN6(ifpr)) << 3,
			 irr->irr_u_uselen,
			 min(ifpr->ifpr_plen - irr->irr_u_uselen,
			     irr->irr_u_keeplen));
	for (orap = (ifpr2rp(ifpr)->rp_addrhead).lh_first; orap != NULL;
	     orap = orap->ra_entry.le_next)
	{
		struct rp_addr *rap;
		int error = 0;

		if ((error = create_ra_entry(&rap)) != 0)
			return error;
		rap->ra_ifid = orap->ra_ifid;
		rap->ra_flags.anycast = (orap->ra_addr != NULL &&
					 (orap->ra_addr->ia6_flags &
					  IN6_IFF_ANYCAST) != 0) ? 1 : 0;
		LIST_INSERT_HEAD(&rpp->rp_addrhead, rap, ra_entry);
	}
	rpp->rp_vltime = irr->irr_vltime;
	rpp->rp_pltime = irr->irr_pltime;
	rpp->rp_raf_onlink = irr->irr_raf_mask_onlink ? irr->irr_raf_onlink :
		ifpr2rp(ifpr)->rp_raf_onlink;
	rpp->rp_raf_auto = irr->irr_raf_mask_auto ? irr->irr_raf_auto :
		ifpr2rp(ifpr)->rp_raf_auto;
	/* Is some FlagMasks for rrf necessary? */
	rpp->rp_rrf = irr->irr_rrf;
	rpp->rp_origin = irr->irr_origin;

	return 0;
}

static void
free_rp_entries(struct rr_prefix *rpp)
{
	/*
	 * This func is only called with rpp on stack(not on list).
	 * So no splnet() here
	 */
	while (rpp->rp_addrhead.lh_first != NULL)
	{
		struct rp_addr *rap;

		rap = LIST_FIRST(&rpp->rp_addrhead);
		LIST_REMOVE(rap, ra_entry);
		if (rap->ra_addr)
			IFAFREE(&rap->ra_addr->ia_ifa);
		free(rap, M_RR_ADDR);
	}
}

static int
add_useprefixes(struct socket *so, struct ifnet *ifp,
		struct in6_rrenumreq *irr)
{
	struct ifprefix *ifpr, *nextifpr;
	struct rr_prefix rp;
	int error = 0;

	/* add prefixes to each of marked prefix */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
		nextifpr = ifpr->ifpr_next;
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		if (ifpr2rp(ifpr)->rp_statef_addmark) {
			if ((error = init_newprefix(irr, ifpr, &rp)) != 0)
				break;
			error = add_each_prefix(so, &rp);
		}
	}
	/* free each rp_addr entry */
	free_rp_entries(&rp);

	return error;
}

static void
unprefer_prefix(struct rr_prefix *rpp)
{
	struct rp_addr *rap;
	long time_second = time.tv_sec;

	for (rap = rpp->rp_addrhead.lh_first; rap != NULL;
	     rap = rap->ra_entry.le_next) {
		if (rap->ra_addr == NULL)
			continue;
		rap->ra_addr->ia6_lifetime.ia6t_preferred = time_second;
		rap->ra_addr->ia6_lifetime.ia6t_pltime = 0;
	}
}

int
delete_each_prefix(struct rr_prefix *rpp, u_char origin)
{
	int error = 0;

	if (rpp->rp_origin > origin)
		return(EPERM);

	while (rpp->rp_addrhead.lh_first != NULL) {
		struct rp_addr *rap;
		int s;

		s = splnet();
		rap = LIST_FIRST(&rpp->rp_addrhead);
		if (rap == NULL) {
			splx(s);
			break;
		}
		LIST_REMOVE(rap, ra_entry);
		splx(s);
		if (rap->ra_addr == NULL) {
			free(rap, M_RR_ADDR);
			continue;
		}
		rap->ra_addr->ia6_ifpr = NULL;

		in6_purgeaddr(&rap->ra_addr->ia_ifa, rpp->rp_ifp);
		IFAFREE(&rap->ra_addr->ia_ifa);
		free(rap, M_RR_ADDR);
	}
	rp_remove(rpp);

	return error;
}

static void
delete_prefixes(struct ifnet *ifp, u_char origin)
{
	struct ifprefix *ifpr, *nextifpr;

	/* delete prefixes marked as tobe deleted */
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
		nextifpr = ifpr->ifpr_next;
		if (ifpr->ifpr_prefix->sa_family != AF_INET6 ||
		    ifpr->ifpr_type != IN6_PREFIX_RR)
 			continue;
		if (ifpr2rp(ifpr)->rp_statef_delmark)
			(void)delete_each_prefix(ifpr2rp(ifpr), origin);
	}
}

static int
link_stray_ia6s(struct rr_prefix *rpp)
{
	struct ifaddr *ifa;

	for (ifa = rpp->rp_ifp->if_addrlist.tqh_first; ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		struct rp_addr *rap;
		struct rr_prefix *orpp;
		int error = 0;

		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (rpp->rp_plen > in6_matchlen(RP_IN6(rpp), IFA_IN6(ifa)))
			continue;

		orpp = ifpr2rp(((struct in6_ifaddr *)ifa)->ia6_ifpr);
		if (orpp != NULL) {
			if (!in6_are_prefix_equal(RP_IN6(orpp), RP_IN6(rpp),
						  rpp->rp_plen))
				log(LOG_ERR, "in6_prefix.c: link_stray_ia6s:"
				    "addr %s/%d already linked to a prefix"
				    "and it matches also %s/%d\n",
				    ip6_sprintf(IFA_IN6(ifa)), orpp->rp_plen,
				    ip6_sprintf(RP_IN6(rpp)),
				    rpp->rp_plen);
			continue;
		}
		if ((error = assign_ra_entry(rpp,
					      (sizeof(rap->ra_ifid) << 3) -
					      rpp->rp_plen,
					      (struct in6_ifaddr *)ifa)) != 0)
			return error;
	}
	return 0;
}

/* XXX assumes that permission is already checked by the caller */
int
in6_prefix_ioctl(struct socket *so, u_long cmd, caddr_t data,
		 struct ifnet *ifp)
{
	struct rr_prefix *rpp, rp_tmp;
	struct rp_addr *rap;
	struct in6_prefixreq *ipr = (struct in6_prefixreq *)data;
	struct in6_rrenumreq *irr = (struct in6_rrenumreq *)data;
	struct ifaddr *ifa;
	int error = 0;

	/*
	 * Failsafe for errneous address config program.
	 * Let's hope rrenumd don't make a mistakes.
	 */
	if (ipr->ipr_origin <= PR_ORIG_RA)
		ipr->ipr_origin = PR_ORIG_STATIC;

	switch (cmd) {
	case SIOCSGIFPREFIX_IN6:
		delmark_global_prefixes(ifp, irr);
		/* FALL THROUGH */
	case SIOCAIFPREFIX_IN6:
	case SIOCCIFPREFIX_IN6:
		/* check if preferred lifetime > valid lifetime */
		if (irr->irr_pltime > irr->irr_vltime) {
			log(LOG_NOTICE,
			    "in6_prefix_ioctl: preferred lifetime"
			    "(%ld) is greater than valid lifetime(%ld)\n",
			    (u_long)irr->irr_pltime, (u_long)irr->irr_vltime);
			error = EINVAL;
			break;
		}
		if (mark_matched_prefixes(cmd, ifp, irr)) {
			if (irr->irr_u_uselen != 0)
				if ((error = add_useprefixes(so, ifp, irr))
				    != 0)
					goto failed;
			if (cmd != SIOCAIFPREFIX_IN6)
				delete_prefixes(ifp, irr->irr_origin);
		} else
			return (EADDRNOTAVAIL);
	failed:
		unmark_prefixes(ifp);
		break;
	case SIOCGIFPREFIX_IN6:
		rpp = search_matched_prefix(ifp, ipr);
		if (rpp == NULL || ifp != rpp->rp_ifp)
			return (EADDRNOTAVAIL);

		ipr->ipr_origin = rpp->rp_origin;
		ipr->ipr_plen = rpp->rp_plen;
		ipr->ipr_vltime = rpp->rp_vltime;
		ipr->ipr_pltime = rpp->rp_pltime;
		ipr->ipr_flags = rpp->rp_flags;
		ipr->ipr_prefix = rpp->rp_prefix;

		break;
	case SIOCSIFPREFIX_IN6:
		/* check if preferred lifetime > valid lifetime */
		if (ipr->ipr_pltime > ipr->ipr_vltime) {
			log(LOG_NOTICE,
			    "in6_prefix_ioctl: preferred lifetime"
			    "(%ld) is greater than valid lifetime(%ld)\n",
			    (u_long)ipr->ipr_pltime, (u_long)ipr->ipr_vltime);
			error = EINVAL;
			break;
		}

		/* init rp_tmp */
		bzero((caddr_t)&rp_tmp, sizeof(rp_tmp));
		rp_tmp.rp_ifp = ifp;
		rp_tmp.rp_plen = ipr->ipr_plen;
		rp_tmp.rp_prefix = ipr->ipr_prefix;
		rp_tmp.rp_vltime = ipr->ipr_vltime;
		rp_tmp.rp_pltime = ipr->ipr_pltime;
		rp_tmp.rp_flags = ipr->ipr_flags;
		rp_tmp.rp_origin = ipr->ipr_origin;

		/* create rp_addr entries, usually at least for lladdr */
		if ((error = link_stray_ia6s(&rp_tmp)) != 0) {
			free_rp_entries(&rp_tmp);
			break;
		}
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
			if (ifa->ifa_addr == NULL)
				continue;	/* just for safety */
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			if (IN6_IS_ADDR_LINKLOCAL(IFA_IN6(ifa)) == 0)
				continue;

			if ((error = create_ra_entry(&rap)) != 0) {
				free_rp_entries(&rp_tmp);
				goto bad;
			}
			/* copy interface id part */
			bit_copy((caddr_t)&rap->ra_ifid,
				 sizeof(rap->ra_ifid) << 3,
				 (caddr_t)IFA_IN6(ifa),
				 sizeof(*IFA_IN6(ifa)) << 3,
				 rp_tmp.rp_plen,
				 (sizeof(rap->ra_ifid) << 3) - rp_tmp.rp_plen);
			/* insert into list */
			LIST_INSERT_HEAD(&rp_tmp.rp_addrhead, rap, ra_entry);
		}

		error = add_each_prefix(so, &rp_tmp);

		/* free each rp_addr entry */
		free_rp_entries(&rp_tmp);

		break;
	case SIOCDIFPREFIX_IN6:
		rpp = search_matched_prefix(ifp, ipr);
		if (rpp == NULL || ifp != rpp->rp_ifp)
			return (EADDRNOTAVAIL);

		error = delete_each_prefix(rpp, ipr->ipr_origin);
		break;
	}
 bad:
	return error;
}

void
in6_rr_timer(void *ignored_arg)
{
	int s;
	struct rr_prefix *rpp;
	long time_second = time.tv_sec;

	timeout_set(&in6_rr_timer_ch, in6_rr_timer, NULL);
	timeout_add(&in6_rr_timer_ch, ip6_rr_prune * hz);

	s = splnet();
	/* expire */
	rpp = LIST_FIRST(&rr_prefix);
	while (rpp) {
		if (rpp->rp_expire && rpp->rp_expire < time_second) {
			struct rr_prefix *next_rpp;

			next_rpp = LIST_NEXT(rpp, rp_entry);
			delete_each_prefix(rpp, PR_ORIG_KERNEL);
			rpp = next_rpp;
			continue;
		}
		if (rpp->rp_preferred && rpp->rp_preferred < time_second)
			unprefer_prefix(rpp);
		rpp = LIST_NEXT(rpp, rp_entry);
	}
	splx(s);
}
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.12 2001/08/24 16:57:33 brian Exp $	*/
@


1.12
log
@Add a missing space
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.11 2001/06/09 06:43:37 angelos Exp $	*/
d91 7
a97 7
static void	add_each_addr __P((struct socket *so, struct rr_prefix *rpp,
				   struct rp_addr *rap));
static int create_ra_entry __P((struct rp_addr **rapp));
static int add_each_prefix __P((struct socket *so, struct rr_prefix *rpp));
static void free_rp_entries __P((struct rr_prefix *rpp));
static int link_stray_ia6s __P((struct rr_prefix *rpp));
static void	rp_remove __P((struct rr_prefix *rpp));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.12 2001/08/24 16:57:33 brian Exp $	*/
@


1.11
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.10 2001/03/25 09:24:26 itojun Exp $	*/
d624 1
a624 1
		log(LOG_ERR, "in6_prefix.c: add_each_addr: addition of an addr"
@


1.10
log
@sync $KAME$.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.9 2001/03/25 06:46:00 csapuntz Exp $	*/
a90 2
#include <net/net_osdep.h>

d578 1
a578 1
	strncpy(ifra.ifra_name, if_name(rpp->rp_ifp), sizeof(ifra.ifra_name));
@


1.9
log
@Missing splx. Thanks to dawson and team for finding this one
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_prefix.c,v 1.8 2001/02/08 14:51:22 itojun Exp $	*/
/*	$KAME: in6_prefix.c,v 1.45 2001/02/08 11:33:32 itojun Exp $	*/
@


1.8
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.7 2000/12/29 02:15:08 itojun Exp $	*/
d955 2
a956 1
		if (rap == NULL)
d958 1
@


1.7
log
@add missing null pointer check.  from IIJ SEIL team.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_prefix.c,v 1.6 2000/06/07 06:56:30 itojun Exp $	*/
/*	$KAME: in6_prefix.c,v 1.29 2000/06/07 05:59:38 itojun Exp $	*/
d89 2
d384 1
a384 1
assigne_ra_entry(struct rr_prefix *rpp, int iilen, struct in6_ifaddr *ia)
d519 1
a519 1
			    "has already another ia %p(%s) on its ifid list\n",
d528 1
a528 1
	error = assigne_ra_entry(ifpr2rp(ifpr), iilen, ia);
d638 1
a638 1
	if (error != 0)
d644 1
d1020 1
a1020 1
		if ((error = assigne_ra_entry(rpp,
d1165 2
a1166 1
	timeout(in6_rr_timer, (caddr_t)0, ip6_rr_prune * hz);
@


1.6
log
@fix anycast address determination.
correct interface address addition when link-local is added (check if ifp
matches).
make diff to kame repository easier (breaks some KNF)

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.5 2000/02/09 07:34:49 itojun Exp $	*/
d600 2
a601 1
			IFAFREE(&rap->ra_addr->ia_ifa);
d608 2
a609 1
			IFAFREE(&rap->ra_addr->ia_ifa);
@


1.5
log
@properly refcnt ifaddrs.
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_prefix.c,v 1.4 2000/02/07 06:05:41 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d155 2
a156 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d203 2
a204 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d232 2
a233 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d288 2
a289 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d307 2
a308 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d372 1
d377 1
d408 4
d431 6
d445 4
a448 1

d559 2
a560 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr) {
d656 2
a657 1
	for (ifpr = new->rp_ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next) {
d742 1
a742 2
			}
			else
d761 2
a762 1
	     rap = rap->ra_entry.le_next) {
d849 2
a850 1
	     orap = orap->ra_entry.le_next) {
d858 1
a858 1
					 (orap->ra_addr->ia_flags &
d872 1
a872 1
	return 0;   
d903 2
a904 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr) {
d975 2
a976 1
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr) {
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6_prefix.c,v 1.10 2001/03/25 09:24:26 itojun Exp $	*/
/*	$KAME: in6_prefix.c,v 1.47 2001/03/25 08:41:39 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a87 2
struct timeout in6_rr_timer_ch;

d154 1
a154 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
d201 1
a201 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
d229 1
a229 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
d284 1
a284 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
d302 1
a302 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
a365 1
	{
a369 1
	}
d374 1
a374 1
assign_ra_entry(struct rr_prefix *rpp, int iilen, struct in6_ifaddr *ia)
a399 4
/*
 * add a link-local address to an interface.  we will add new interface address
 * (prefix database + new interface id).
 */
a418 6
		/*
		 * do not attempt to add an address, if ifp does not match
		 */
		if (rpp->rp_ifp != ia->ia_ifp)
			continue;

d427 1
a427 4
/*
 * add an address to an interface.  if the interface id portion is new,
 * we will add new interface address (prefix database + new interface id).
 */
d496 1
a496 1
			    " already has another ia %p(%s) on its ifid list\n",
d505 1
a505 1
	error = assign_ra_entry(ifpr2rp(ifpr), iilen, ia);
d538 1
a538 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
d578 1
a578 2
			if (rap->ra_addr)
				IFAFREE(&rap->ra_addr->ia_ifa);
d585 1
a585 2
			if (rap->ra_addr)
				IFAFREE(&rap->ra_addr->ia_ifa);
d612 1
a612 1
	if (error != 0) {
a617 1
	}
d634 1
a634 2
	for (ifpr = new->rp_ifp->if_prefixlist; ifpr; ifpr = ifpr->ifpr_next)
	{
d719 2
a720 1
			} else
d739 1
a739 2
	     rap = rap->ra_entry.le_next)
	{
d826 1
a826 2
	     orap = orap->ra_entry.le_next)
	{
d834 1
a834 1
					 (orap->ra_addr->ia6_flags &
d848 1
a848 1
	return 0;
d879 1
a879 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
d925 1
a925 2
		if (rap == NULL) {
			splx(s);
a926 1
		}
d950 1
a950 2
	for (ifpr = ifp->if_prefixlist; ifpr; ifpr = nextifpr)
	{
d989 1
a989 1
		if ((error = assign_ra_entry(rpp,
d1134 1
a1134 2
	timeout_set(&in6_rr_timer_ch, in6_rr_timer, NULL);
	timeout_add(&in6_rr_timer_ch, ip6_rr_prune * hz);
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.5.2.1 2001/05/14 22:40:18 niklas Exp $	*/
d91 2
d580 1
a580 1
	strncpy(ifra.ifra_name, rpp->rp_ifp->if_xname, sizeof(ifra.ifra_name));
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.5.2.2 2001/07/04 10:55:21 niklas Exp $	*/
d624 1
a624 1
		log(LOG_ERR, "in6_prefix.c: add_each_addr: addition of an addr "
@


1.5.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 7
a97 7
static void	add_each_addr(struct socket *so, struct rr_prefix *rpp,
				   struct rp_addr *rap);
static int create_ra_entry(struct rp_addr **rapp);
static int add_each_prefix(struct socket *so, struct rr_prefix *rpp);
static void free_rp_entries(struct rr_prefix *rpp);
static int link_stray_ia6s(struct rr_prefix *rpp);
static void	rp_remove(struct rr_prefix *rpp);
@


1.5.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.5.2.4 2002/03/28 14:56:46 niklas Exp $	*/
@


1.4
log
@remove prefix information in the kernel when all matching in6_ifaddr are gone.
fix include file path.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.3 2000/02/04 18:13:36 itojun Exp $	*/
d389 1
d490 1
a490 1
		if (rap->ra_addr == NULL)
d492 2
a493 1
		else if (rap->ra_addr != ia) {
d523 2
d578 1
d580 1
d585 1
d587 1
d675 2
d864 2
d936 1
@


1.3
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d82 1
a82 1
#include <netinet6/ip6.h>
d90 2
d96 1
d399 28
d435 2
d523 2
d1070 11
a1080 2
		ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp);
		if (ifa != NULL) {
d1083 1
a1083 1
				break;
d1110 1
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_prefix.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d208 1
a208 1
		    "has no pointer to prefix %s", ip6_sprintf(IFA_IN6(ifa)),
d266 1
a266 1
			    "ND autoconfigured addr?",
d461 1
a461 1
			    "has already another ia %p(%s) on its ifid list",
d492 16
d558 1
a558 1
		    "%s/%d failed because there is already another addr %s/%d",
d567 2
a568 1
	error = in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, rpp->rp_ifp, curproc);
d571 1
a571 1
		    "%s/%d failed because in6_control failed for error %d",
d648 1
a648 1
			    ": ENOBUFS for rr_prefix", __LINE__);
d748 1
a748 1
		    "for rp_addr", __LINE__);
d865 1
a865 1
delete_each_prefix(struct socket *so, struct rr_prefix *rpp, u_char origin)
a866 1
	struct in6_aliasreq ifra;
d888 1
a888 16
		bzero(&ifra, sizeof(ifra));
		strncpy(ifra.ifra_name, if_name(rpp->rp_ifp),
			sizeof(ifra.ifra_name));
		ifra.ifra_addr = rap->ra_addr->ia_addr;
		ifra.ifra_dstaddr = rap->ra_addr->ia_dstaddr;
		ifra.ifra_prefixmask = rap->ra_addr->ia_prefixmask;

		error = in6_control(so, SIOCDIFADDR_IN6, (caddr_t)&ifra,
				    rpp->rp_ifp, curproc);
		if (error != 0)
			log(LOG_ERR, "in6_prefix.c: delete_each_prefix:"
			    "deletion of an addr %s/%d failed because"
			    "in6_control failed for error %d",
			    ip6_sprintf(&ifra.ifra_addr.sin6_addr),
			    rpp->rp_plen, error);

d897 1
a897 1
delete_prefixes(struct socket *so, struct ifnet *ifp, u_char origin)
d908 1
a908 1
			(void)delete_each_prefix(so, ifpr2rp(ifpr), origin);
d935 1
a935 1
				    "and it matches also %s/%d",
d950 1
d979 1
a979 1
			    "(%ld) is greater than valid lifetime(%ld)",
d990 1
a990 1
				delete_prefixes(so, ifp, irr->irr_origin);
d1014 1
a1014 1
			    "(%ld) is greater than valid lifetime(%ld)",
d1063 1
a1063 1
		error = delete_each_prefix(so, rpp, ipr->ipr_origin);
a1083 5
			struct socket so;

			/* XXX: init dummy so */
			bzero(&so, sizeof(so));
			so.so_state |= SS_PRIV;
d1086 1
a1086 1
			delete_each_prefix(&so, rpp, PR_ORIG_KERNEL);
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a67 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a68 1
#endif
a75 1
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
a76 1
#endif
a85 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static MALLOC_DEFINE(M_IP6RR, "ip6rr", "IPv6 Router Renumbering Prefix");
static MALLOC_DEFINE(M_RR_ADDR, "rp_addr", "IPv6 Router Renumbering Ifid");
#endif

a182 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a183 1
#endif
a245 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a246 1
#endif
a311 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a312 1
#endif
a438 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3) && !defined(__NetBSD__)
a439 1
#endif
d551 1
a551 5
	error = in6_control(so, SIOCAIFADDR_IN6, (caddr_t)&ifra, rpp->rp_ifp
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
			    , curproc
#endif
			    );
a608 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		while (!LIST_EMPTY(&new->rp_addrhead))
#else
a609 1
#endif
a637 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		while (!LIST_EMPTY(&new->rp_addrhead))
#else
a638 1
#endif
a795 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	while (!LIST_EMPTY(&rpp->rp_addrhead))
#else
a796 1
#endif
a835 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a836 1
#endif
d880 1
a880 5
				    rpp->rp_ifp
#if !defined(__bsdi__) && !(defined(__FreeBSD__) && __FreeBSD__ < 3)
				    , curproc
#endif
				    );
a915 3
#if (defined(__FreeBSD__) && __FreeBSD__ < 3) || defined(__bsdi__)
	for (ifa = rpp->rp_ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a917 1
#endif
a1071 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1072 1
#endif
a1085 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3) && !defined(__NetBSD__)
a1086 1
#endif
@

