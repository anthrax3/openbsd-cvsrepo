head	1.67;
access;
symbols
	OPENBSD_6_1:1.66.0.4
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.63.0.2
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.56.0.2
	OPENBSD_5_9_BASE:1.56
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.36.0.4
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.31.0.2
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.29.0.4
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.2
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.4
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.26.0.6
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.26.0.8
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.26.0.4
	OPENBSD_4_5_BASE:1.26
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.20
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.25.0.18
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.16
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.14
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.12
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.25.0.10
	OPENBSD_3_8_BASE:1.25
	OPENBSD_3_7:1.25.0.8
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.25.0.6
	OPENBSD_3_6_BASE:1.25
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.23
	UBC:1.14.0.6
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.67
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.66;
commitid	iTlWhLM2orYZnz27;

1.66
date	2016.12.27.18.45.01;	author bluhm;	state Exp;
branches;
next	1.65;
commitid	iX6wHULmb2OvfsDR;

1.65
date	2016.11.28.13.59.51;	author mpi;	state Exp;
branches;
next	1.64;
commitid	gDeAqDskWelvIYpy;

1.64
date	2016.11.21.10.52.08;	author mpi;	state Exp;
branches;
next	1.63;
commitid	KI2xKJXsc9yCGGDD;

1.63
date	2016.07.13.01.51.22;	author dlg;	state Exp;
branches;
next	1.62;
commitid	Kr2q4p4N1KP0TwKx;

1.62
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.61;
commitid	qWegq9wDcxofLjIV;

1.61
date	2016.06.08.12.57.58;	author mpi;	state Exp;
branches;
next	1.60;
commitid	3tTbgX0YOYAZziFF;

1.60
date	2016.06.01.23.45.19;	author dlg;	state Exp;
branches;
next	1.59;
commitid	FDsCC33tBdAholzy;

1.59
date	2016.05.30.23.37.37;	author dlg;	state Exp;
branches;
next	1.58;
commitid	v39nTE5MxW6gairp;

1.58
date	2016.03.30.10.13.14;	author mpi;	state Exp;
branches;
next	1.57;
commitid	xpsJgMCf9pVyesEt;

1.57
date	2016.03.03.12.57.15;	author jca;	state Exp;
branches;
next	1.56;
commitid	WUjfyeigg4TuFbFK;

1.56
date	2015.12.18.10.55.51;	author tb;	state Exp;
branches;
next	1.55;
commitid	YD52P9wG7KPDwKDg;

1.55
date	2015.11.06.11.20.56;	author mpi;	state Exp;
branches;
next	1.54;
commitid	oU39GoDixhmOhYXK;

1.54
date	2015.11.02.12.51.16;	author bluhm;	state Exp;
branches;
next	1.53;
commitid	Oukwozy6YPj2qdBN;

1.53
date	2015.11.02.07.24.08;	author mpi;	state Exp;
branches;
next	1.52;
commitid	j3heHwF6pc3KZsrO;

1.52
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.51;
commitid	Ajb0hNGeCqGFHjjg;

1.51
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.50;
commitid	G2nTzngqgXpQqcJB;

1.50
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.49;
commitid	xFxvBxiFybIsZNMc;

1.49
date	2015.08.31.10.03.47;	author mpi;	state Exp;
branches;
next	1.48;
commitid	8UHdQ4P9tiBrYUaa;

1.48
date	2015.08.24.23.28.27;	author mpi;	state Exp;
branches;
next	1.47;
commitid	P83XIQmNiVyg0aoD;

1.47
date	2015.08.24.23.26.43;	author mpi;	state Exp;
branches;
next	1.46;
commitid	RvboqW7afhR7jBgv;

1.46
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.45;
commitid	hOA5qIh5CrYvhG4e;

1.45
date	2015.08.18.08.52.25;	author mpi;	state Exp;
branches;
next	1.44;
commitid	uMSOhjeAvqfe36Ju;

1.44
date	2015.07.18.15.05.32;	author mpi;	state Exp;
branches;
next	1.43;
commitid	8XKIMnE4aOLeVqIl;

1.43
date	2015.07.16.15.31.35;	author mpi;	state Exp;
branches;
next	1.42;
commitid	syrAtzfOhwI3Ygjb;

1.42
date	2015.07.09.05.45.25;	author mpi;	state Exp;
branches;
next	1.41;
commitid	3lzuz5T7djZWDJfj;

1.41
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.40;
commitid	F3Fu23ZZ8dwzir4r;

1.40
date	2014.11.10.10.46.10;	author mpi;	state Exp;
branches;
next	1.39;
commitid	PygNV68Vq7F7osTf;

1.39
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.38;
commitid	fUNtd3qRJAn6fam0;

1.38
date	2014.07.11.15.03.17;	author blambert;	state Exp;
branches;
next	1.37;
commitid	HGjB9lpJfpqInwIy;

1.37
date	2014.05.07.08.14.59;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.25.02.54.42;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.26.07.15.58;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2013.08.11.22.13.32;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2013.07.01.14.22.20;	author bluhm;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.11.14.08.04;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2012.02.14.18.05.41;	author sthen;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.03.13.56.05;	author stsp;	state Exp;
branches;
next	1.27;

1.27
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2003.07.08.21.43.18;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.27.22.47.32;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.08.21.32.47;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.07.02.33.04;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.05.01.12.54;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.30.05.07.17;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.29.09.33.55;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.01.23.19.16.09;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.23.08.01.15;	author itojun;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2001.02.23.06.40.20;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.08.15.07.28;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.08.14.51.22;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.07.11.43.54;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.19.06.37.38;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.06.10.11.26;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.19.13.55.17;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.15.11.45.35;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.17.04.44.51;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.04.18.13.36;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.01.08.04.49.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.05.14.22.40.20;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.14.6.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.14.6.2;

1.14.6.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	;


desc
@@


1.67
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@/*	$OpenBSD: nd6.h,v 1.66 2016/12/27 18:45:01 bluhm Exp $	*/
/*	$KAME: nd6.h,v 1.95 2002/06/08 11:31:06 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _NETINET6_ND6_H_
#define _NETINET6_ND6_H_

#include <sys/task.h>

#define ND6_LLINFO_PURGE	-3
#define ND6_LLINFO_NOSTATE	-2
#define ND6_LLINFO_INCOMPLETE	0
#define ND6_LLINFO_REACHABLE	1
#define ND6_LLINFO_STALE	2
#define ND6_LLINFO_DELAY	3
#define ND6_LLINFO_PROBE	4

struct nd_ifinfo {
	u_int32_t basereachable;	/* BaseReachableTime */
	u_int32_t reachable;		/* Reachable Time */
	u_int32_t retrans;		/* Retrans Timer */
	u_int32_t flags;		/* Flags */
	int recalctm;			/* BaseReacable re-calculation timer */
	u_int8_t initialized; /* Flag to see the entry is initialized */
	/* the following 3 members are for privacy extension for addrconf */
	u_int8_t randomseed0[8]; /* upper 64 bits of MD5 digest */
	u_int8_t randomseed1[8]; /* lower 64 bits (usually the EUI64 IFID) */
	u_int8_t randomid[8];	/* current random ID */
};

#define ND6_IFF_PERFORMNUD	0x1
#define ND6_IFF_ACCEPT_RTADV	0x2

struct in6_nbrinfo {
	char ifname[IFNAMSIZ];	/* if name, e.g. "en0" */
	struct in6_addr addr;	/* IPv6 address of the neighbor */
	time_t	expire;		/* lifetime for NDP state transition */
	long	asked;		/* number of queries already sent for addr */
	int	isrouter;	/* if it acts as a router */
	int	state;		/* reachability state */
};

struct	in6_defrouter {
	struct	sockaddr_in6 rtaddr;
	time_t	expire;
	u_short	rtlifetime;
	u_short	if_index;
	u_char	flags;
};

struct prf_ra {
	u_int onlink : 1;
	u_int autonomous : 1;
	u_int router : 1;
	u_int reserved : 5;
};

struct in6_prefix {
	struct	sockaddr_in6 prefix;
	struct	prf_ra raflags;
	time_t	expire;
	u_int32_t vltime;
	u_int32_t pltime;
	u_int32_t flags;
	int	refcnt;
	u_short	if_index;
	u_short	advrtrs; /* number of advertisement routers */
	u_char	prefixlen;
	u_char	origin;
#define PR_ORIG_RA	0
#define PR_ORIG_RR	1
#define PR_ORIG_STATIC	2
#define PR_ORIG_KERNEL	3
	/* struct sockaddr_in6 advrtr[] */
};

struct	in6_ndireq {
	char ifname[IFNAMSIZ];
	struct nd_ifinfo ndi;
};

struct	in6_ndifreq {
	char ifname[IFNAMSIZ];
	u_long ifindex;
};

/* Prefix status */
#define NDPRF_ONLINK		0x1
#define NDPRF_DETACHED		0x2
#define NDPRF_HOME		0x4

/* protocol constants */
#define MAX_RTR_SOLICITATION_DELAY	1	/*1sec*/
#define RTR_SOLICITATION_INTERVAL	4	/*4sec*/
#define MAX_RTR_SOLICITATIONS		3

#define ND6_INFINITE_LIFETIME		0xffffffff

/* constants for RFC 4941 autoconf privacy extension */
#define ND6_PRIV_MAX_DESYNC_FACTOR	512	/* largest pow2 < 10 minutes */
#define ND6_PRIV_VALID_LIFETIME		604800	/* 1 week */
#define ND6_PRIV_PREFERRED_LIFETIME	86400	/* 1 day */

#ifdef _KERNEL

#include <sys/queue.h>
#include <sys/timeout.h>

#define ND_IFINFO(ifp) \
	(((struct in6_ifextra *)(ifp)->if_afdata[AF_INET6])->nd_ifinfo)

#define RS_LHCOOKIE(ifp) \
	((struct in6_ifextra *)(ifp)->if_afdata[AF_INET6])->rs_lhcookie

struct	llinfo_nd6 {
	TAILQ_ENTRY(llinfo_nd6)	ln_list;
	struct	rtentry *ln_rt;
	struct	mbuf *ln_hold;	/* last packet until resolved/timeout */
	long	ln_asked;	/* number of queries already sent for addr */
	int	ln_byhint;	/* # of times we made it reachable by UL hint */
	short	ln_state;	/* reachability state */
	short	ln_router;	/* 2^0: ND6 router bit */

	struct	timeout ln_timer_ch;
};

#define ND6_IS_LLINFO_PROBREACH(n) ((n)->ln_state > ND6_LLINFO_INCOMPLETE)
#define ND6_LLINFO_PERMANENT(n)	((n)->ln_rt->rt_expire == 0)

/* node constants */
#define MAX_REACHABLE_TIME		3600000	/* msec */
#define REACHABLE_TIME			30000	/* msec */
#define RETRANS_TIMER			1000	/* msec */
#define MIN_RANDOM_FACTOR		512	/* 1024 * 0.5 */
#define MAX_RANDOM_FACTOR		1536	/* 1024 * 1.5 */
#define ND_COMPUTE_RTIME(x) \
		(((MIN_RANDOM_FACTOR * (x >> 10)) + (arc4random() & \
		((MAX_RANDOM_FACTOR - MIN_RANDOM_FACTOR) * (x >> 10)))) /1000)

extern int nd6_prune;
extern int nd6_delay;
extern int nd6_umaxtries;
extern int nd6_mmaxtries;
extern int nd6_maxnudhint;
extern int nd6_gctimer;
extern int nd6_debug;

#define nd6log(x)	do { if (nd6_debug) log x; } while (0)

union nd_opts {
	struct nd_opt_hdr *nd_opt_array[9];
	struct {
		struct nd_opt_hdr *zero;
		struct nd_opt_hdr *src_lladdr;
		struct nd_opt_hdr *tgt_lladdr;
		struct nd_opt_prefix_info *pi_beg; /* multiple opts, start */
		struct nd_opt_rd_hdr *rh;
		struct nd_opt_mtu *mtu;
		struct nd_opt_hdr *search;	/* multiple opts */
		struct nd_opt_hdr *last;	/* multiple opts */
		int done;
		struct nd_opt_prefix_info *pi_end;/* multiple opts, end */
	} nd_opt_each;
};
#define nd_opts_src_lladdr	nd_opt_each.src_lladdr
#define nd_opts_tgt_lladdr	nd_opt_each.tgt_lladdr
#define nd_opts_pi		nd_opt_each.pi_beg
#define nd_opts_pi_end		nd_opt_each.pi_end
#define nd_opts_rh		nd_opt_each.rh
#define nd_opts_mtu		nd_opt_each.mtu
#define nd_opts_search		nd_opt_each.search
#define nd_opts_last		nd_opt_each.last
#define nd_opts_done		nd_opt_each.done

void nd6_init(void);
struct nd_ifinfo *nd6_ifattach(struct ifnet *);
void nd6_ifdetach(struct nd_ifinfo *);
int nd6_is_addr_neighbor(struct sockaddr_in6 *, struct ifnet *);
void nd6_option_init(void *, int, union nd_opts *);
struct nd_opt_hdr *nd6_option(union nd_opts *);
int nd6_options(union nd_opts *);
struct	rtentry *nd6_lookup(struct in6_addr *, int, struct ifnet *, u_int);
void nd6_setmtu(struct ifnet *);
void nd6_llinfo_settimer(struct llinfo_nd6 *, int);
void nd6_purge(struct ifnet *);
void nd6_nud_hint(struct rtentry *);
void nd6_rtrequest(struct ifnet *, int, struct rtentry *);
int nd6_ioctl(u_long, caddr_t, struct ifnet *);
void nd6_cache_lladdr(struct ifnet *, struct in6_addr *, char *, int, int, int);
int nd6_resolve(struct ifnet *, struct rtentry *, struct mbuf *,
	 struct sockaddr *, u_char *);
int nd6_sysctl(int, void *, size_t *, void *, size_t);
int nd6_need_cache(struct ifnet *);

void nd6_na_input(struct mbuf *, int, int);
void nd6_na_output(struct ifnet *, struct in6_addr *,
	struct in6_addr *, u_long, int, struct sockaddr *);
void nd6_ns_input(struct mbuf *, int, int);
void nd6_ns_output(struct ifnet *, struct in6_addr *,
	struct in6_addr *, struct llinfo_nd6 *, int);
caddr_t nd6_ifptomac(struct ifnet *);
void nd6_dad_start(struct ifaddr *);
void nd6_dad_stop(struct ifaddr *);
void nd6_ra_input(struct mbuf *, int, int);

void nd6_rs_input(struct mbuf *, int, int);

int in6_ifdel(struct ifnet *, struct in6_addr *);
void rt6_flush(struct in6_addr *, struct ifnet *);

#endif /* _KERNEL */

#endif /* _NETINET6_ND6_H_ */
@


1.66
log
@Move nd6 timer initialisation to nd6_init() and call timeout_set()
only once during init.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.65 2016/11/28 13:59:51 mpi Exp $	*/
a167 46
TAILQ_HEAD(nd_drhead, nd_defrouter);
struct	nd_defrouter {
	TAILQ_ENTRY(nd_defrouter) dr_entry;
	struct	in6_addr rtaddr;
	struct  ifnet *ifp;
	time_t	expire;
	int	installed;	/* is installed into kernel routing table */
	u_short	rtlifetime;
	u_char	flags;		/* flags on RA message */
};

struct nd_prefix {
	struct ifnet *ndpr_ifp;
	LIST_ENTRY(nd_prefix) ndpr_entry;
	struct sockaddr_in6 ndpr_prefix;	/* prefix */
	struct in6_addr ndpr_mask; /* netmask derived from the prefix */

	struct task ndpr_task;

	time_t ndpr_expire;	/* expiration time of the prefix */
	time_t ndpr_preferred;	/* preferred time of the prefix */
	time_t ndpr_lastupdate; /* reception time of last advertisement */

	u_int32_t ndpr_vltime;	/* advertised valid lifetime */
	u_int32_t ndpr_pltime;	/* advertised preferred lifetime */

	struct prf_ra ndpr_flags;
	u_int32_t ndpr_stateflags; /* actual state flags */
	/* list of routers that advertise the prefix: */
	LIST_HEAD(pr_rtrhead, nd_pfxrouter) ndpr_advrtrs;
	u_char	ndpr_plen;
	int	ndpr_refcnt;	/* reference counter from addresses */
};

#define ndpr_raf		ndpr_flags
#define ndpr_raf_onlink		ndpr_flags.onlink
#define ndpr_raf_auto		ndpr_flags.autonomous
#define ndpr_raf_router		ndpr_flags.router

struct nd_pfxrouter {
	LIST_ENTRY(nd_pfxrouter) pfr_entry;
	struct nd_defrouter *router;
};

LIST_HEAD(nd_prhead, nd_prefix);

a173 2
extern struct nd_drhead nd_defrouter;
extern struct nd_prhead nd_prefix;
a233 3
void nd6_rs_init(void);
void nd6_rs_attach(struct ifnet *);
void nd6_rs_detach(struct ifnet *);
a235 9
void prelist_del(struct nd_prefix *);
void defrouter_reset(void);
void defrouter_select(void);
void defrtrlist_del(struct nd_defrouter *);
void prelist_remove(struct nd_prefix *);
void pfxlist_onlink_check(void);
struct nd_defrouter *defrouter_lookup(struct in6_addr *, unsigned int);

struct nd_prefix *nd6_prefix_lookup(struct nd_prefix *);
a236 1
int in6_init_prefix_ltimes(struct nd_prefix *ndpr);
@


1.65
log
@Remove multiple recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.64 2016/11/21 10:52:08 mpi Exp $	*/
a225 2
extern struct timeout nd6_timer_ch;

a260 1
void nd6_timer(void *);
@


1.64
log
@Assert that prelist_update() is always called at IPL_SOFTNET.

While here use __func__ in debug strings to reduce noise when grepping.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.63 2016/07/13 01:51:22 dlg Exp $	*/
a290 1
void defrouter_addreq(struct nd_defrouter *);
a294 2
int nd6_prelist_add(struct nd_prefix *, struct nd_defrouter *,
	struct nd_prefix **);
@


1.63
log
@store nd6 expiries in the route, not separately in the llinfo struct.

this makes it more consistent with arp, and makes expiries visible
via route(8) get as well as ndp(8).

ok mpi@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.62 2016/06/15 11:49:34 mpi Exp $	*/
a295 1
int prelist_update(struct nd_prefix *, struct nd_defrouter *, struct mbuf *);
@


1.62
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.61 2016/06/08 12:57:58 mpi Exp $	*/
a146 1
	time_t	ln_expire;	/* lifetime for NDP state transition */
d156 1
a156 1
#define ND6_LLINFO_PERMANENT(n)	((n)->ln_expire == 0)
@


1.61
log
@Move ND resoluton logic from nd6_output() to nd6_storelladdr() and
rename it to nd6_resolve().

This allows us to get rid of non-Ethernet hacks by moving Ethernet
specific logic in the appropriate layer.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.60 2016/06/01 23:45:19 dlg Exp $	*/
a266 2
int nd6_resolve(struct ifnet *, struct rtentry *,
	struct mbuf *, struct sockaddr *, u_char *);
a269 2
int nd6_output(struct ifnet *, struct mbuf *, struct sockaddr_in6 *,
    struct rtentry *);
@


1.60
log
@make nd6_llinfo_settimer take seconds instead of ticks.

most callers are working in seconds, internally it uses seconds, and
you can call timeout_add_sec as easily as timeout_add.

this also fixes an issue with an nd_defrouter expire which was
incorrectly scaled with ticks in a comparison.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.59 2016/05/30 23:37:37 dlg Exp $	*/
d274 1
a274 1
int nd6_storelladdr(struct ifnet *, struct rtentry *, struct mbuf *,
@


1.59
log
@remove code compensating for the "short" range of timeouts.

the nd6 code for managing expiries is never asked to handle intervals
greater than what timeouts can handle, so we dont need to overcompensate.

the code was also incorrect by using a long, which isnt that long
on ILP32 machines.

ok mpi@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.58 2016/03/30 10:13:14 mpi Exp $	*/
d263 1
a263 1
void nd6_llinfo_settimer(struct llinfo_nd6 *, long);
@


1.58
log
@Implement proxy ARP for ART based on mpath support.

Since mpath is not enabled in RAMDISK, proxy ARP won't work there either.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.57 2016/03/03 12:57:15 jca Exp $	*/
a152 1
	long	ln_ntick;
@


1.57
log
@Kill IPv6 prefix and router renumbering ioctls.

Router renumbering was never supported, prefix ioctls were deprecated
~15 years ago.  Move some items in netinet6/nd6.h where they are still
used.

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.56 2015/12/18 10:55:51 tb Exp $	*/
a36 5

/* see net/route.h, or net/if_inarp.h */
#ifndef RTF_ANNOUNCE
#define RTF_ANNOUNCE	RTF_PROTO2
#endif
@


1.56
log
@Convert arc4random() to arc4random_uniorm().  Diff by Matthew Martin.

Ensure that arc4random_uniform() doesn't loop by redefining
ND6_MAX_DESYNC_FACTOR to be 512, the largest power of two smaller
than the RFC-specified 600 seconds.  Suggested by florian@@ and deraadt@@

ok florian@@, sthen@@ in this form, arc4random change ok djm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.55 2015/11/06 11:20:56 mpi Exp $	*/
d84 7
d103 4
@


1.55
log
@Change nd6_nud_hint() to no longer manipulate rt_ifp directly.

While here remove unused argument and convert the route check to
rtisvalid(9).

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.54 2015/11/02 12:51:16 bluhm Exp $	*/
d122 1
a122 1
#define ND6_PRIV_MAX_DESYNC_FACTOR	600	/* 10 minutes */
@


1.54
log
@Implement the list of nd6 llinfo entries with a TAILQ.
OK millert@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.53 2015/11/02 07:24:08 mpi Exp $	*/
d261 1
a261 1
void nd6_nud_hint(struct rtentry *, u_int);
@


1.53
log
@Prefer an existing refcounted ``ifp'' to rt_ifp when possible or use the
interface index directly.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.52 2015/10/28 12:14:25 florian Exp $	*/
d138 1
a138 2
	struct	llinfo_nd6 *ln_next;
	struct	llinfo_nd6 *ln_prev;
a215 1
extern struct llinfo_nd6 llinfo_nd6;
@


1.52
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.51 2015/10/25 11:58:11 mpi Exp $	*/
d302 1
a302 1
struct nd_defrouter *defrouter_lookup(struct in6_addr *, struct ifnet *);
@


1.51
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.50 2015/10/24 16:08:48 mpi Exp $	*/
a51 2
	u_int32_t linkmtu;		/* LinkMTU */
	u_int32_t maxmtu;		/* Upper bound of LinkMTU */
a135 7

#define IN6_LINKMTU(ifp) \
	((ND_IFINFO(ifp)->linkmtu && ND_IFINFO(ifp)->linkmtu < (ifp)->if_mtu) \
	    ? ND_IFINFO(ifp)->linkmtu \
	    : ((ND_IFINFO(ifp)->maxmtu && ND_IFINFO(ifp)->maxmtu < (ifp)->if_mtu) \
		? ND_IFINFO(ifp)->maxmtu : (ifp)->if_mtu))

@


1.50
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.49 2015/08/31 10:03:47 mpi Exp $	*/
d275 1
a275 1
void nd6_rtrequest(int, struct rtentry *);
@


1.49
log
@The return value of nd6_cache_lladdr() is never used so make it a void.

Fewer "struct rtentry" left in the wild!
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.48 2015/08/24 23:28:27 mpi Exp $	*/
a58 1
	u_int8_t chlim;			/* CurHopLimit */
@


1.48
log
@nd6_prefix_add() is no longer used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.47 2015/08/24 23:26:43 mpi Exp $	*/
d278 1
a278 2
struct rtentry *nd6_cache_lladdr(struct ifnet *, struct in6_addr *,
	char *, int, int, int);
@


1.47
log
@Start moving away from the global prefix list by limiting its usage to
AUTOCONF'd addresses.

This prevent the kernel from removing connected (/64) routes as soon as
it configures an AUTOCONF'd address based on a RA.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.46 2015/08/24 15:58:35 mpi Exp $	*/
a314 2
struct nd_prefix *nd6_prefix_add(struct ifnet *, struct sockaddr_in6 *,
    struct sockaddr_in6 *, struct in6_addrlifetime *);
@


1.46
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.45 2015/08/18 08:52:25 mpi Exp $	*/
d316 1
a316 1
    struct sockaddr_in6 *, struct in6_addrlifetime *, int);
@


1.45
log
@Call rtfree(9) when we no longer need the route entry rather than
decrementing rt_refcnt just after rtrequest1(9).

While here reduce the differences with rt_ifa_add(9).  There's still
an ambiguity about rtrequest1(9)'s return value, but bluhm@@ will
address that in a different diff.

Discussed with and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.44 2015/07/18 15:05:32 mpi Exp $	*/
d294 1
a294 1
void nd6_dad_start(struct ifaddr *, int *);
@


1.44
log
@Merge two identical chunks to add new prefixes to the global data
structures into a function.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.43 2015/07/16 15:31:35 mpi Exp $	*/
a311 2
int nd6_prefix_onlink(struct nd_prefix *);
int nd6_prefix_offlink(struct nd_prefix *);
@


1.43
log
@Properly layer Router Solicitation code.

Tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.42 2015/07/09 05:45:25 mpi Exp $	*/
d316 3
@


1.42
log
@Remove unused arguments and the associated code from nd6_nud_hint().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.41 2014/11/20 13:54:24 mpi Exp $	*/
a235 6
#define ND6_RS_OUTPUT_INTERVAL 60
#define ND6_RS_OUTPUT_QUICK_INTERVAL 1
extern struct timeout nd6_rs_output_timer;
extern int nd6_rs_output_timeout;
extern int nd6_rs_timeout_count;

d296 1
d298 3
d302 1
a302 4
void nd6_ra_input(struct mbuf *, int, int);
void nd6_rs_output_set_timo(int);
void nd6_rs_output(struct ifnet *, struct in6_ifaddr *);
void nd6_rs_dev_state(void *);
@


1.41
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.40 2014/11/10 10:46:10 mpi Exp $	*/
d279 1
a279 1
void nd6_nud_hint(struct rtentry *, struct in6_addr *, int, u_int);
@


1.40
log
@Do not pass an ifa pointer when we already have a DAD descriptor.

Tweaks and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.39 2014/08/25 14:00:34 florian Exp $	*/
d286 2
a287 2
int nd6_output(struct ifnet *, struct ifnet *, struct mbuf *,
	struct sockaddr_in6 *, struct rtentry *);
@


1.39
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.38 2014/07/11 15:03:17 blambert Exp $	*/
a301 1
void nd6_dad_duplicated(struct ifaddr *);
@


1.38
log
@move IPv6 prefix adding from workq to taskq; as a happy benefit, we
can delete 2 dozen or so lines that check to see if we've queued
up a prefix addition multiple times.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.37 2014/05/07 08:14:59 mpi Exp $	*/
d137 3
d236 6
d306 3
@


1.37
log
@Kill the {nd6_,}useloopback buttons, using the loopback interface for
local traffic is not optional.

ok mikeb@@, stsp@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.36 2014/01/07 17:07:46 mikeb Exp $	*/
d36 2
d188 2
@


1.36
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.35 2013/10/25 02:54:42 deraadt Exp $	*/
a217 1
extern int nd6_useloopback;
@


1.35
log
@More _KERNEL namespace cleanup, just in case something out there
includes this.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.34 2013/08/28 06:58:57 mpi Exp $	*/
d262 1
a262 1
struct	rtentry *nd6_lookup(struct in6_addr *, int, struct ifnet *);
d267 1
a267 1
void nd6_nud_hint(struct rtentry *, struct in6_addr *, int);
@


1.34
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.33 2013/08/26 07:15:58 bluhm Exp $	*/
a40 18
#include <sys/queue.h>
#include <sys/timeout.h>

struct	llinfo_nd6 {
	struct	llinfo_nd6 *ln_next;
	struct	llinfo_nd6 *ln_prev;
	struct	rtentry *ln_rt;
	struct	mbuf *ln_hold;	/* last packet until resolved/timeout */
	time_t	ln_expire;	/* lifetime for NDP state transition */
	long	ln_asked;	/* number of queries already sent for addr */
	int	ln_byhint;	/* # of times we made it reachable by UL hint */
	short	ln_state;	/* reachability state */
	short	ln_router;	/* 2^0: ND6 router bit */

	long	ln_ntick;
	struct	timeout ln_timer_ch;
};

a42 8
/*
 * We don't need the WAITDELETE state any more, but we keep the definition
 * in a comment line instead of removing it. This is necessary to avoid
 * unintentionally reusing the value for another purpose, which might
 * affect backward compatibility with old applications.
 * (20000711 jinmei@@kame.net)
 */
/* #define ND6_LLINFO_WAITDELETE	-1 */
a48 3
#define ND6_IS_LLINFO_PROBREACH(n) ((n)->ln_state > ND6_LLINFO_INCOMPLETE)
#define ND6_LLINFO_PERMANENT(n)	((n)->ln_expire == 0)

a67 10
#ifdef _KERNEL
#define ND_IFINFO(ifp) \
	(((struct in6_ifextra *)(ifp)->if_afdata[AF_INET6])->nd_ifinfo)
#define IN6_LINKMTU(ifp) \
	((ND_IFINFO(ifp)->linkmtu && ND_IFINFO(ifp)->linkmtu < (ifp)->if_mtu) \
	    ? ND_IFINFO(ifp)->linkmtu \
	    : ((ND_IFINFO(ifp)->maxmtu && ND_IFINFO(ifp)->maxmtu < (ifp)->if_mtu) \
		? ND_IFINFO(ifp)->maxmtu : (ifp)->if_mtu))
#endif

d128 32
a213 1
/* nd6.c */
a254 2
/* XXX: need nd6_var.h?? */
/* nd6.c */
a280 1
/* nd6_nbr.c */
a291 1
/* nd6_rtr.c */
@


1.33
log
@No one uses the obsolete IPv6 ioctls SIOCGDRLST_IN6, SIOCGPRLST_IN6,
OSIOCGIFINFO_IN6 anymore.  Remove them together with the structs
in6_drlist, in6_oprlist, in6_prlist, in6_ondireq and the kernel
implementation.
OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.32 2013/08/11 22:13:32 bluhm Exp $	*/
d280 1
a280 1
void nd6_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
@


1.32
log
@To control the lifetime of IPv6 addresses, prefixes and default
routers, the kernel and ndp use a bunch of expire fields.  Before
they were int or u_long, convert expire to time_t in all structs.
Move vltime and pltime to u_int32_t everywhere.  Sort struct fields
by size.  Struct inet6_ndpr_msghdr is not used at all, so remove
it.

Binary compatibility of rtsold and ndp break with this change as
rtsold uses in6_drlist and ndp uses in6_defrouter and in6_prefix
to interact with the kernel.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.31 2013/07/01 14:22:20 bluhm Exp $	*/
a115 13
#define DRLSTSIZ 10
#define PRLSTSIZ 10
struct	in6_drlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr rtaddr;
		time_t	expire;
		u_short	rtlifetime;
		u_short	if_index;
		u_char	flags;
	} defrouter[DRLSTSIZ];
};

a123 34
#ifdef _KERNEL
struct	in6_oprlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr prefix;
		struct	prf_ra raflags;
		time_t	expire;
		u_int32_t vltime;
		u_int32_t pltime;
		u_short	if_index;
		u_short	advrtrs; /* number of advertisement routers */
		u_char	prefixlen;
		u_char	origin;
		struct	in6_addr advrtr[DRLSTSIZ]; /* XXX: explicit limit */
	} prefix[PRLSTSIZ];
};
#endif

struct	in6_prlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr prefix;
		struct	prf_ra raflags;
		time_t	expire;
		u_int32_t vltime;
		u_int32_t pltime;
		u_short	if_index;
		u_short	advrtrs; /* number of advertisement routers */
		u_char	prefixlen;
		u_char	origin;
		struct	in6_addr advrtr[DRLSTSIZ]; /* XXX: explicit limit */
	} prefix[PRLSTSIZ];
};

a137 17

#ifdef _KERNEL
struct	in6_ondireq {
	char ifname[IFNAMSIZ];
	struct {
		u_int32_t linkmtu;	/* LinkMTU */
		u_int32_t maxmtu;	/* Upper bound of LinkMTU */
		u_int32_t basereachable; /* BaseReachableTime */
		u_int32_t reachable;	/* Reachable Time */
		u_int32_t retrans;	/* Retrans Timer */
		u_int32_t flags;	/* Flags */
		int recalctm;		/* BaseReacable re-calculation timer */
		u_int8_t chlim;		/* CurHopLimit */
		u_int8_t receivedra;
	} ndi;
};
#endif
@


1.31
log
@Do not access queue fields directly, use FOREACH() macro instead.
No binary change.
OK mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.30 2013/03/11 14:08:04 mpi Exp $	*/
d49 3
a51 2
	long	ln_asked;	/* number of queries already sent for this addr */
	u_long	ln_expire;	/* lifetime for NDP state transition */
a53 1
	int	ln_byhint;	/* # of times we made it reachable by UL hint */
d56 1
a56 1
	struct timeout ln_timer_ch;
d110 2
a111 1
	long	asked;		/* number of queries already sent for this addr */
a113 1
	int	expire;		/* lifetime for NDP state transition */
d122 3
a125 3
		u_short	rtlifetime;
		u_long	expire;
		u_short if_index;
d131 3
a134 3
	u_short	rtlifetime;
	u_long	expire;
	u_short if_index;
d142 6
a147 1
		struct prf_ra raflags;
a149 5
		u_long vltime;
		u_long pltime;
		u_long expire;
		u_short if_index;
		u_short advrtrs; /* number of advertisement routers */
d159 6
a164 1
		struct prf_ra raflags;
a166 5
		u_int32_t vltime;
		u_int32_t pltime;
		time_t expire;
		u_short if_index;
		u_short advrtrs; /* number of advertisement routers */
d173 2
a174 3
	struct prf_ra raflags;
	u_char	prefixlen;
	u_char	origin;
a176 1
	time_t expire;
d178 5
a182 3
	int refcnt;
	u_short if_index;
	u_short advrtrs; /* number of advertisement routers */
a244 3
	u_char	flags;		/* flags on RA message */
	u_short	rtlifetime;
	u_long	expire;
d246 1
d248 2
a257 3
	u_int32_t ndpr_vltime;	/* advertised valid lifetime */
	u_int32_t ndpr_pltime;	/* advertised preferred lifetime */

d262 3
a276 26

/*
 * Message format for use in obtaining information about prefixes
 * from inet6 sysctl function
 */
struct inet6_ndpr_msghdr {
	u_short	inpm_msglen;	/* to skip over non-understood messages */
	u_char	inpm_version;	/* future binary compatibility */
	u_char	inpm_type;	/* message type */
	struct in6_addr inpm_prefix;
	u_long	prm_vltim;
	u_long	prm_pltime;
	u_long	prm_expire;
	u_long	prm_preferred;
	struct in6_prflags prm_flags;
	u_short	prm_index;	/* index for associated ifp */
	u_char	prm_plen;	/* length of prefix in bits */
};

#define prm_raf_onlink		prm_flags.prf_ra.onlink
#define prm_raf_auto		prm_flags.prf_ra.autonomous

#define prm_statef_onlink	prm_flags.prf_state.onlink

#define prm_rrf_decrvalid	prm_flags.prf_rr.decrvalid
#define prm_rrf_decrprefd	prm_flags.prf_rr.decrprefd
@


1.30
log
@Remove unused code manipulating a default interface and its index,
This is a leftover from the on-link assumption behavior removal,
which has been deprecated by RFC4861 anyway.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.29 2012/02/14 18:05:41 sthen Exp $	*/
a272 2
#define ndpr_next		ndpr_entry.le_next

a305 1
#define pfr_next pfr_entry.le_next
@


1.29
log
@typo in comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.28 2011/04/03 13:56:05 stsp Exp $	*/
a330 3
/* nd6_rtr.c */
extern int nd6_defifindex;

a415 1
int nd6_setdefaultiface(int);
@


1.28
log
@fix typos in comments
ok deraadt henning sthen thib (though thib says he can't spell)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.27 2010/04/06 14:12:10 stsp Exp $	*/
d225 1
a225 1
/* contants for RFC 4941 autoconf privacy extension */
@


1.27
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.26 2008/06/11 06:30:36 mcbride Exp $	*/
d270 1
a270 1
	int	ndpr_refcnt;	/* reference couter from addresses */
@


1.26
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.25 2003/07/08 21:43:18 itojun Exp $	*/
d224 5
@


1.25
log
@unifdef -U__otherBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.24 2003/06/27 22:47:32 itojun Exp $	*/
d59 1
@


1.24
log
@split ND6 cache timer management to per-entry.  increased accuracy,
no O(N) loop.   sync w/ kame.  marc tested, daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.23 2002/06/08 21:32:47 itojun Exp $	*/
a55 3
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	struct callout ln_timer_ch;
#elif defined(__OpenBSD__)
a56 1
#endif
@


1.23
log
@gc
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.22 2002/06/08 21:22:03 itojun Exp $	*/
d54 7
d79 1
a79 6

/*
 * Since the granularity of our retransmission timer is seconds, we should
 * ensure that a positive timer value will be mapped to at least one second.
 */
#define ND6_RETRANS_SEC(r) (((r) + 999) / 1000)
d368 1
@


1.22
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.21 2002/06/07 02:33:04 itojun Exp $	*/
a371 1
void nd6_p2p_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
a374 1
/* for test */
@


1.21
log
@cope with cases where maxmtu == 0 (shouldn't happen)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.20 2002/06/05 01:12:54 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.93 2002/06/05 00:56:22 itojun Exp $	*/
d96 1
d130 26
d163 3
a165 3
		u_long	vltime;
		u_long	pltime;
		u_long	expire;
d172 15
d214 4
d241 1
a241 1
	u_char	flags;
d245 1
d253 1
a253 1
	struct in6_addr ndpr_addr; /* address that is derived from the prefix */
d256 1
d259 2
d262 1
d266 1
a266 4
	struct	ndpr_stateflags {
		/* if this prefix can be regarded as on-link */
		u_char onlink : 1;
	} ndpr_stateflags;
d274 1
a274 9

#define ndpr_statef_onlink	ndpr_stateflags.onlink
#define ndpr_statef_addmark	ndpr_stateflags.addmark

/*
 * We keep expired prefix for certain amount of time, for validation purposes.
 * 1800s = MaxRtrAdvInterval
 */
#define NDPR_KEEP_EXPIRED	(1800 * 2)
a301 3
#define ifpr2ndpr(ifpr)	((struct nd_prefix *)(ifpr))
#define ndpr2ifpr(ndpr)	((struct ifprefix *)(ndpr))

a327 1
extern struct ifnet *nd6_defifp;  /* XXXYYY */
a367 1
struct llinfo_nd6 *nd6_free(struct rtentry *);
d370 1
a370 1
		     struct mbuf *, struct sockaddr *, u_char *);
d378 1
a378 1
		    struct sockaddr_in6 *, struct rtentry *);
d380 3
a382 1
			 struct sockaddr *, u_char *);
d387 1
a387 1
 			struct in6_addr *, u_long, int, struct sockaddr *);
d390 1
a390 1
			struct in6_addr *, struct llinfo_nd6 *, int);
d401 1
a401 1
void defrouter_delreq(struct nd_defrouter *, int);
d405 5
a409 2
int prelist_update(struct nd_prefix *, struct nd_defrouter *,
	struct mbuf *);
d411 2
a412 2
struct nd_defrouter *defrouter_lookup(struct in6_addr *,
					   struct ifnet *);
@


1.20
log
@be sure to use L3 MTU, not L2 MTU, when specified in spec (affects FDDI/ARCnet)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.19 2002/05/30 05:07:17 itojun Exp $	*/
d103 1
a103 1
	    : ((ND_IFINFO(ifp)->maxmtu < (ifp)->if_mtu) \
@


1.19
log
@improve nd6_setmtu(), to warn too-small MTU on SIOCSIFMTU.  sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.18 2002/05/29 09:33:55 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.52 2001/02/19 04:40:37 itojun Exp $	*/
d102 3
a104 1
		? ND_IFINFO(ifp)->linkmtu : (ifp)->if_mtu)
@


1.18
log
@no need to supply obsolete field name "receivedra"
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.17 2002/05/29 07:54:59 itojun Exp $	*/
d327 1
a327 1
void nd6_setmtu(struct ifnet *, struct nd_ifinfo *);
@


1.17
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.16 2002/03/14 01:27:12 millert Exp $	*/
a88 1
#define receivedra initialized	/* obsoleted */
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.15 2002/01/23 19:16:09 fgsch Exp $	*/
d73 6
d88 6
a93 1
	u_int8_t receivedra;
d98 8
d144 17
a280 1
extern struct nd_ifinfo *nd_ifinfo;
d299 1
a299 1
		struct nd_opt_prefix_info *pi_beg;/* multiple opts, start */
d321 2
a322 1
void nd6_ifattach(struct ifnet *);
d328 1
a328 1
void nd6_setmtu(struct ifnet *);
@


1.15
log
@compatability -> compatibility.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.14 2001/02/23 08:01:15 itojun Exp $	*/
d285 19
a303 19
void nd6_init __P((void));
void nd6_ifattach __P((struct ifnet *));
int nd6_is_addr_neighbor __P((struct sockaddr_in6 *, struct ifnet *));
void nd6_option_init __P((void *, int, union nd_opts *));
struct nd_opt_hdr *nd6_option __P((union nd_opts *));
int nd6_options __P((union nd_opts *));
struct	rtentry *nd6_lookup __P((struct in6_addr *, int, struct ifnet *));
void nd6_setmtu __P((struct ifnet *));
void nd6_timer __P((void *));
void nd6_purge __P((struct ifnet *));
struct llinfo_nd6 *nd6_free __P((struct rtentry *));
void nd6_nud_hint __P((struct rtentry *, struct in6_addr *, int));
int nd6_resolve __P((struct ifnet *, struct rtentry *,
		     struct mbuf *, struct sockaddr *, u_char *));
void nd6_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
void nd6_p2p_rtrequest __P((int, struct rtentry *, struct rt_addrinfo *));
int nd6_ioctl __P((u_long, caddr_t, struct ifnet *));
struct rtentry *nd6_cache_lladdr __P((struct ifnet *, struct in6_addr *,
	char *, int, int, int));
d305 4
a308 4
int nd6_output __P((struct ifnet *, struct ifnet *, struct mbuf *,
		    struct sockaddr_in6 *, struct rtentry *));
int nd6_storelladdr __P((struct ifnet *, struct rtentry *, struct mbuf *,
			 struct sockaddr *, u_char *));
d311 10
a320 10
void nd6_na_input __P((struct mbuf *, int, int));
void nd6_na_output __P((struct ifnet *, struct in6_addr *,
 			struct in6_addr *, u_long, int, struct sockaddr *));
void nd6_ns_input __P((struct mbuf *, int, int));
void nd6_ns_output __P((struct ifnet *, struct in6_addr *,
			struct in6_addr *, struct llinfo_nd6 *, int));
caddr_t nd6_ifptomac __P((struct ifnet *));
void nd6_dad_start __P((struct ifaddr *, int *));
void nd6_dad_stop __P((struct ifaddr *));
void nd6_dad_duplicated __P((struct ifaddr *));
d323 17
a339 17
void nd6_rs_input __P((struct mbuf *, int, int));
void nd6_ra_input __P((struct mbuf *, int, int));
void prelist_del __P((struct nd_prefix *));
void defrouter_addreq __P((struct nd_defrouter *));
void defrouter_delreq __P((struct nd_defrouter *, int));
void defrouter_select __P((void));
void defrtrlist_del __P((struct nd_defrouter *));
void prelist_remove __P((struct nd_prefix *));
int prelist_update __P((struct nd_prefix *, struct nd_defrouter *,
	struct mbuf *));
void pfxlist_onlink_check __P((void));
struct nd_defrouter *defrouter_lookup __P((struct in6_addr *,
					   struct ifnet *));
int in6_ifdel __P((struct ifnet *, struct in6_addr *));
int in6_init_prefix_ltimes __P((struct nd_prefix *ndpr));
void rt6_flush __P((struct in6_addr *, struct ifnet *));
int nd6_setdefaultiface __P((int));
@


1.14
log
@garbage-collect stale ND entries (default: 1 day).
RFC 2461 5.3.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.13 2001/02/23 06:40:20 itojun Exp $	*/
d205 1
a205 1
	u_char	inpm_version;	/* future binary compatability */
@


1.14.6.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.15 2002/01/23 19:16:09 fgsch Exp $	*/
d205 1
a205 1
	u_char	inpm_version;	/* future binary compatibility */
@


1.14.6.2
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: nd6.h,v 1.95 2002/06/08 11:31:06 itojun Exp $	*/
a72 6
/*
 * Since the granularity of our retransmission timer is seconds, we should
 * ensure that a positive timer value will be mapped to at least one second.
 */
#define ND6_RETRANS_SEC(r) (((r) + 999) / 1000)

d82 1
a82 5
	u_int8_t initialized; /* Flag to see the entry is initialized */
	/* the following 3 members are for privacy extension for addrconf */
	u_int8_t randomseed0[8]; /* upper 64 bits of MD5 digest */
	u_int8_t randomseed1[8]; /* lower 64 bits (usually the EUI64 IFID) */
	u_int8_t randomid[8];	/* current random ID */
a85 11
#define ND6_IFF_ACCEPT_RTADV	0x2

#ifdef _KERNEL
#define ND_IFINFO(ifp) \
	(((struct in6_ifextra *)(ifp)->if_afdata[AF_INET6])->nd_ifinfo)
#define IN6_LINKMTU(ifp) \
	((ND_IFINFO(ifp)->linkmtu && ND_IFINFO(ifp)->linkmtu < (ifp)->if_mtu) \
	    ? ND_IFINFO(ifp)->linkmtu \
	    : ((ND_IFINFO(ifp)->maxmtu && ND_IFINFO(ifp)->maxmtu < (ifp)->if_mtu) \
		? ND_IFINFO(ifp)->maxmtu : (ifp)->if_mtu))
#endif
a108 26
struct	in6_defrouter {
	struct	sockaddr_in6 rtaddr;
	u_char	flags;
	u_short	rtlifetime;
	u_long	expire;
	u_short if_index;
};

#ifdef _KERNEL
struct	in6_oprlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr prefix;
		struct prf_ra raflags;
		u_char	prefixlen;
		u_char	origin;
		u_long vltime;
		u_long pltime;
		u_long expire;
		u_short if_index;
		u_short advrtrs; /* number of advertisement routers */
		struct	in6_addr advrtr[DRLSTSIZ]; /* XXX: explicit limit */
	} prefix[PRLSTSIZ];
};
#endif

d116 3
a118 3
		u_int32_t vltime;
		u_int32_t pltime;
		time_t expire;
a124 32
struct in6_prefix {
	struct	sockaddr_in6 prefix;
	struct prf_ra raflags;
	u_char	prefixlen;
	u_char	origin;
	u_int32_t vltime;
	u_int32_t pltime;
	time_t expire;
	u_int32_t flags;
	int refcnt;
	u_short if_index;
	u_short advrtrs; /* number of advertisement routers */
	/* struct sockaddr_in6 advrtr[] */
};

#ifdef _KERNEL
struct	in6_ondireq {
	char ifname[IFNAMSIZ];
	struct {
		u_int32_t linkmtu;	/* LinkMTU */
		u_int32_t maxmtu;	/* Upper bound of LinkMTU */
		u_int32_t basereachable; /* BaseReachableTime */
		u_int32_t reachable;	/* Reachable Time */
		u_int32_t retrans;	/* Retrans Timer */
		u_int32_t flags;	/* Flags */
		int recalctm;		/* BaseReacable re-calculation timer */
		u_int8_t chlim;		/* CurHopLimit */
		u_int8_t receivedra;
	} ndi;
};
#endif

a134 4
/* Prefix status */
#define NDPRF_ONLINK		0x1
#define NDPRF_DETACHED		0x2
#define NDPRF_HOME		0x4
d158 1
a158 1
	u_char	flags;		/* flags on RA message */
a161 1
	int	installed;	/* is installed into kernel routing table */
d169 1
a169 1

a171 1

a173 2
	time_t ndpr_lastupdate; /* reception time of last advertisement */

a174 1
	u_int32_t ndpr_stateflags; /* actual state flags */
d178 4
a181 1
	int	ndpr_refcnt;	/* reference couter from addresses */
d189 9
a197 1
#define ndpr_raf_router		ndpr_flags.router
d225 3
d245 1
d255 1
d264 1
a264 1
		struct nd_opt_prefix_info *pi_beg; /* multiple opts, start */
d285 24
a308 24
void nd6_init(void);
struct nd_ifinfo *nd6_ifattach(struct ifnet *);
void nd6_ifdetach(struct nd_ifinfo *);
int nd6_is_addr_neighbor(struct sockaddr_in6 *, struct ifnet *);
void nd6_option_init(void *, int, union nd_opts *);
struct nd_opt_hdr *nd6_option(union nd_opts *);
int nd6_options(union nd_opts *);
struct	rtentry *nd6_lookup(struct in6_addr *, int, struct ifnet *);
void nd6_setmtu(struct ifnet *);
void nd6_timer(void *);
void nd6_purge(struct ifnet *);
void nd6_nud_hint(struct rtentry *, struct in6_addr *, int);
int nd6_resolve(struct ifnet *, struct rtentry *,
	struct mbuf *, struct sockaddr *, u_char *);
void nd6_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
int nd6_ioctl(u_long, caddr_t, struct ifnet *);
struct rtentry *nd6_cache_lladdr(struct ifnet *, struct in6_addr *,
	char *, int, int, int);
int nd6_output(struct ifnet *, struct ifnet *, struct mbuf *,
	struct sockaddr_in6 *, struct rtentry *);
int nd6_storelladdr(struct ifnet *, struct rtentry *, struct mbuf *,
	 struct sockaddr *, u_char *);
int nd6_sysctl(int, void *, size_t *, void *, size_t);
int nd6_need_cache(struct ifnet *);
d311 10
a320 10
void nd6_na_input(struct mbuf *, int, int);
void nd6_na_output(struct ifnet *, struct in6_addr *,
	struct in6_addr *, u_long, int, struct sockaddr *);
void nd6_ns_input(struct mbuf *, int, int);
void nd6_ns_output(struct ifnet *, struct in6_addr *,
	struct in6_addr *, struct llinfo_nd6 *, int);
caddr_t nd6_ifptomac(struct ifnet *);
void nd6_dad_start(struct ifaddr *, int *);
void nd6_dad_stop(struct ifaddr *);
void nd6_dad_duplicated(struct ifaddr *);
d323 17
a339 20
void nd6_rs_input(struct mbuf *, int, int);
void nd6_ra_input(struct mbuf *, int, int);
void prelist_del(struct nd_prefix *);
void defrouter_addreq(struct nd_defrouter *);
void defrouter_reset(void);
void defrouter_select(void);
void defrtrlist_del(struct nd_defrouter *);
void prelist_remove(struct nd_prefix *);
int prelist_update(struct nd_prefix *, struct nd_defrouter *, struct mbuf *);
int nd6_prelist_add(struct nd_prefix *, struct nd_defrouter *,
	struct nd_prefix **);
int nd6_prefix_onlink(struct nd_prefix *);
int nd6_prefix_offlink(struct nd_prefix *);
void pfxlist_onlink_check(void);
struct nd_defrouter *defrouter_lookup(struct in6_addr *, struct ifnet *);
struct nd_prefix *nd6_prefix_lookup(struct nd_prefix *);
int in6_ifdel(struct ifnet *, struct in6_addr *);
int in6_init_prefix_ltimes(struct nd_prefix *ndpr);
void rt6_flush(struct in6_addr *, struct ifnet *);
int nd6_setdefaultiface(int);
@


1.13
log
@remove unnecessary state, ND6_LLINFO_WAITDELETE, from neighbor cache
state machine.
no need for RTF_REJECT on neighbor cache entires, they are leftover from
ARP code.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.12 2001/02/08 15:07:28 itojun Exp $	*/
d243 1
@


1.12
log
@when chasing nd6_llinfo chain, make sure we do not touch dangling
pointer (due to RTM_DELETE during default router list management).
from kame
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.11 2001/02/08 14:51:22 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.46 2001/02/08 10:57:00 itojun Exp $	*/
d57 8
a64 1
#define ND6_LLINFO_WAITDELETE	-1
@


1.11
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.10 2001/02/07 11:43:54 itojun Exp $	*/
d287 1
a287 1
void nd6_free __P((struct rtentry *));
@


1.10
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.9 2001/01/19 06:37:38 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.42 2001/02/06 09:14:39 jinmei Exp $	*/
d42 1
d243 2
@


1.9
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.8 2000/07/06 10:11:26 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.23 2000/06/04 12:54:57 itojun Exp $	*/
d239 3
d308 1
@


1.8
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.7 2000/05/19 13:55:17 itojun Exp $	*/
a284 1
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
a286 4
#else
void nd6_rtrequest __P((int, struct rtentry *, struct sockaddr *));
void nd6_p2p_rtrequest __P((int, struct rtentry *, struct sockaddr *));
#endif
@


1.7
log
@never forward packet with link-local address.
experimental support for new loopback packet handling (with FAKE_LOOPBACK_IF,
rcvif will be set to real outgoing interface, not the loopback, to honor scope)
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.6 2000/05/15 11:45:35 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.21 2000/05/17 12:35:59 jinmei Exp $	*/
d52 1
d234 1
d282 1
a282 1
void nd6_nud_hint __P((struct rtentry *, struct in6_addr *));
@


1.6
log
@perform NUD on p2p link, only if the destination/gateway is real neighbor.
this removes temporary workaround (no NUD on p2p link).  KAME PR 245.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.5 2000/04/17 04:44:51 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.20 2000/04/29 04:46:41 jinmei Exp $	*/
d294 2
a295 2
int nd6_output __P((struct ifnet *, struct mbuf *, struct sockaddr_in6 *,
		    struct rtentry *));
@


1.5
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.4 2000/02/28 11:55:22 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.19 2000/03/25 07:23:57 sumikawa Exp $	*/
d271 1
a271 1
int nd6_is_addr_neighbor __P((struct in6_addr *, struct ifnet *));
@


1.4
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.3 2000/02/04 18:13:36 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.16 2000/02/24 16:34:51 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d70 1
d75 2
@


1.3
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 2
a2 1
/*	$OpenBSD: nd6.h,v 1.2 2000/01/08 04:49:22 deraadt Exp $	*/
d36 5
d62 2
d103 1
d118 6
d142 1
d144 1
a144 2
	LIST_ENTRY(nd_defrouter) dr_entry;
#define dr_next dr_entry.le_next
a221 1
LIST_HEAD(nd_drhead, nd_defrouter);
a229 1
extern int nd6_proxyall;
d235 4
d299 1
a299 1
 			struct in6_addr *, u_long, int));
d313 1
d318 1
d324 1
@


1.3.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: nd6.h,v 1.16 2000/02/24 16:34:51 itojun Exp $	*/
a34 5
/* see net/route.h, or net/if_inarp.h */
#ifndef RTF_ANNOUNCE
#define RTF_ANNOUNCE	RTF_PROTO2
#endif

a55 2
#define ND6_IS_LLINFO_PROBREACH(n) ((n)->ln_state > ND6_LLINFO_INCOMPLETE)

a94 1
		u_char	origin;
a108 6
struct	in6_ndifreq {
	char ifname[IFNAMSIZ];
	u_long ifindex;
};


a126 1
TAILQ_HEAD(nd_drhead, nd_defrouter);
d128 2
a129 1
	TAILQ_ENTRY(nd_defrouter) dr_entry;
d207 1
d216 1
a221 4
/* nd6_rtr.c */
extern struct ifnet *nd6_defifp;  /* XXXYYY */
extern int nd6_defifindex;

d282 1
a282 1
 			struct in6_addr *, u_long, int, struct sockaddr *));
a295 1
void defrouter_select __P((void));
a299 1
void pfxlist_onlink_check __P((void));
a304 1
int nd6_setdefaultiface __P((int));
@


1.3.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.h,v 1.14 2001/02/23 08:01:15 itojun Exp $	*/
/*	$KAME: nd6.h,v 1.52 2001/02/19 04:40:37 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a41 1
#include <sys/timeout.h>
a51 1
	int	ln_byhint;	/* # of times we made it reachable by UL hint */
d55 1
a55 8
/*
 * We don't need the WAITDELETE state any more, but we keep the definition
 * in a comment line instead of removing it. This is necessary to avoid
 * unintentionally reusing the value for another purpose, which might
 * affect backward compatibility with old applications.
 * (20000711 jinmei@@kame.net)
 */
/* #define ND6_LLINFO_WAITDELETE	-1 */
a69 1
	u_int32_t flags;		/* Flags */
a74 2
#define ND6_IFF_PERFORMNUD	0x1

a229 2
extern int nd6_maxnudhint;
extern int nd6_gctimer;
a233 5
extern int nd6_debug;

#define nd6log(x)	do { if (nd6_debug) log x; } while (0)

extern struct timeout nd6_timer_ch;
d268 1
a268 1
int nd6_is_addr_neighbor __P((struct sockaddr_in6 *, struct ifnet *));
d276 2
a277 2
struct llinfo_nd6 *nd6_free __P((struct rtentry *));
void nd6_nud_hint __P((struct rtentry *, struct in6_addr *, int));
d280 1
d283 4
d291 2
a292 2
int nd6_output __P((struct ifnet *, struct ifnet *, struct mbuf *,
		    struct sockaddr_in6 *, struct rtentry *));
a304 1
void nd6_dad_stop __P((struct ifaddr *));
@


1.3.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d205 1
a205 1
	u_char	inpm_version;	/* future binary compatibility */
@


1.3.2.4
log
@Merge in -current from roughly a week ago
@
text
@d285 19
a303 19
void nd6_init(void);
void nd6_ifattach(struct ifnet *);
int nd6_is_addr_neighbor(struct sockaddr_in6 *, struct ifnet *);
void nd6_option_init(void *, int, union nd_opts *);
struct nd_opt_hdr *nd6_option(union nd_opts *);
int nd6_options(union nd_opts *);
struct	rtentry *nd6_lookup(struct in6_addr *, int, struct ifnet *);
void nd6_setmtu(struct ifnet *);
void nd6_timer(void *);
void nd6_purge(struct ifnet *);
struct llinfo_nd6 *nd6_free(struct rtentry *);
void nd6_nud_hint(struct rtentry *, struct in6_addr *, int);
int nd6_resolve(struct ifnet *, struct rtentry *,
		     struct mbuf *, struct sockaddr *, u_char *);
void nd6_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
void nd6_p2p_rtrequest(int, struct rtentry *, struct rt_addrinfo *);
int nd6_ioctl(u_long, caddr_t, struct ifnet *);
struct rtentry *nd6_cache_lladdr(struct ifnet *, struct in6_addr *,
	char *, int, int, int);
d305 4
a308 4
int nd6_output(struct ifnet *, struct ifnet *, struct mbuf *,
		    struct sockaddr_in6 *, struct rtentry *);
int nd6_storelladdr(struct ifnet *, struct rtentry *, struct mbuf *,
			 struct sockaddr *, u_char *);
d311 10
a320 10
void nd6_na_input(struct mbuf *, int, int);
void nd6_na_output(struct ifnet *, struct in6_addr *,
 			struct in6_addr *, u_long, int, struct sockaddr *);
void nd6_ns_input(struct mbuf *, int, int);
void nd6_ns_output(struct ifnet *, struct in6_addr *,
			struct in6_addr *, struct llinfo_nd6 *, int);
caddr_t nd6_ifptomac(struct ifnet *);
void nd6_dad_start(struct ifaddr *, int *);
void nd6_dad_stop(struct ifaddr *);
void nd6_dad_duplicated(struct ifaddr *);
d323 17
a339 17
void nd6_rs_input(struct mbuf *, int, int);
void nd6_ra_input(struct mbuf *, int, int);
void prelist_del(struct nd_prefix *);
void defrouter_addreq(struct nd_defrouter *);
void defrouter_delreq(struct nd_defrouter *, int);
void defrouter_select(void);
void defrtrlist_del(struct nd_defrouter *);
void prelist_remove(struct nd_prefix *);
int prelist_update(struct nd_prefix *, struct nd_defrouter *,
	struct mbuf *);
void pfxlist_onlink_check(void);
struct nd_defrouter *defrouter_lookup(struct in6_addr *,
					   struct ifnet *);
int in6_ifdel(struct ifnet *, struct in6_addr *);
int in6_init_prefix_ltimes(struct nd_prefix *ndpr);
void rt6_flush(struct in6_addr *, struct ifnet *);
int nd6_setdefaultiface(int);
@


1.3.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$KAME: nd6.h,v 1.95 2002/06/08 11:31:06 itojun Exp $	*/
a72 6
/*
 * Since the granularity of our retransmission timer is seconds, we should
 * ensure that a positive timer value will be mapped to at least one second.
 */
#define ND6_RETRANS_SEC(r) (((r) + 999) / 1000)

d82 1
a82 5
	u_int8_t initialized; /* Flag to see the entry is initialized */
	/* the following 3 members are for privacy extension for addrconf */
	u_int8_t randomseed0[8]; /* upper 64 bits of MD5 digest */
	u_int8_t randomseed1[8]; /* lower 64 bits (usually the EUI64 IFID) */
	u_int8_t randomid[8];	/* current random ID */
a85 11
#define ND6_IFF_ACCEPT_RTADV	0x2

#ifdef _KERNEL
#define ND_IFINFO(ifp) \
	(((struct in6_ifextra *)(ifp)->if_afdata[AF_INET6])->nd_ifinfo)
#define IN6_LINKMTU(ifp) \
	((ND_IFINFO(ifp)->linkmtu && ND_IFINFO(ifp)->linkmtu < (ifp)->if_mtu) \
	    ? ND_IFINFO(ifp)->linkmtu \
	    : ((ND_IFINFO(ifp)->maxmtu && ND_IFINFO(ifp)->maxmtu < (ifp)->if_mtu) \
		? ND_IFINFO(ifp)->maxmtu : (ifp)->if_mtu))
#endif
a108 26
struct	in6_defrouter {
	struct	sockaddr_in6 rtaddr;
	u_char	flags;
	u_short	rtlifetime;
	u_long	expire;
	u_short if_index;
};

#ifdef _KERNEL
struct	in6_oprlist {
	char ifname[IFNAMSIZ];
	struct {
		struct	in6_addr prefix;
		struct prf_ra raflags;
		u_char	prefixlen;
		u_char	origin;
		u_long vltime;
		u_long pltime;
		u_long expire;
		u_short if_index;
		u_short advrtrs; /* number of advertisement routers */
		struct	in6_addr advrtr[DRLSTSIZ]; /* XXX: explicit limit */
	} prefix[PRLSTSIZ];
};
#endif

d116 3
a118 3
		u_int32_t vltime;
		u_int32_t pltime;
		time_t expire;
a124 32
struct in6_prefix {
	struct	sockaddr_in6 prefix;
	struct prf_ra raflags;
	u_char	prefixlen;
	u_char	origin;
	u_int32_t vltime;
	u_int32_t pltime;
	time_t expire;
	u_int32_t flags;
	int refcnt;
	u_short if_index;
	u_short advrtrs; /* number of advertisement routers */
	/* struct sockaddr_in6 advrtr[] */
};

#ifdef _KERNEL
struct	in6_ondireq {
	char ifname[IFNAMSIZ];
	struct {
		u_int32_t linkmtu;	/* LinkMTU */
		u_int32_t maxmtu;	/* Upper bound of LinkMTU */
		u_int32_t basereachable; /* BaseReachableTime */
		u_int32_t reachable;	/* Reachable Time */
		u_int32_t retrans;	/* Retrans Timer */
		u_int32_t flags;	/* Flags */
		int recalctm;		/* BaseReacable re-calculation timer */
		u_int8_t chlim;		/* CurHopLimit */
		u_int8_t receivedra;
	} ndi;
};
#endif

a134 4
/* Prefix status */
#define NDPRF_ONLINK		0x1
#define NDPRF_DETACHED		0x2
#define NDPRF_HOME		0x4
d158 1
a158 1
	u_char	flags;		/* flags on RA message */
a161 1
	int	installed;	/* is installed into kernel routing table */
d169 1
a169 1

a171 1

a173 2
	time_t ndpr_lastupdate; /* reception time of last advertisement */

a174 1
	u_int32_t ndpr_stateflags; /* actual state flags */
d178 4
a181 1
	int	ndpr_refcnt;	/* reference couter from addresses */
d189 9
a197 1
#define ndpr_raf_router		ndpr_flags.router
d225 3
d245 1
d255 1
d264 1
a264 1
		struct nd_opt_prefix_info *pi_beg; /* multiple opts, start */
d286 1
a286 2
struct nd_ifinfo *nd6_ifattach(struct ifnet *);
void nd6_ifdetach(struct nd_ifinfo *);
d295 1
d298 1
a298 1
	struct mbuf *, struct sockaddr *, u_char *);
d300 1
d304 1
d306 1
a306 1
	struct sockaddr_in6 *, struct rtentry *);
d308 1
a308 3
	 struct sockaddr *, u_char *);
int nd6_sysctl(int, void *, size_t *, void *, size_t);
int nd6_need_cache(struct ifnet *);
d313 1
a313 1
	struct in6_addr *, u_long, int, struct sockaddr *);
d316 1
a316 1
	struct in6_addr *, struct llinfo_nd6 *, int);
d327 1
a327 1
void defrouter_reset(void);
d331 2
a332 5
int prelist_update(struct nd_prefix *, struct nd_defrouter *, struct mbuf *);
int nd6_prelist_add(struct nd_prefix *, struct nd_defrouter *,
	struct nd_prefix **);
int nd6_prefix_onlink(struct nd_prefix *);
int nd6_prefix_offlink(struct nd_prefix *);
d334 2
a335 2
struct nd_defrouter *defrouter_lookup(struct in6_addr *, struct ifnet *);
struct nd_prefix *nd6_prefix_lookup(struct nd_prefix *);
@


1.3.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a53 3

	long	ln_ntick;
	struct timeout ln_timer_ch;
d72 6
a77 1
#define ND6_LLINFO_PERMANENT(n)	((n)->ln_expire == 0)
a365 1
void nd6_llinfo_settimer(struct llinfo_nd6 *, long);
@


1.2
log
@use arc4random() instead of random for two reasons.
1) on some architectures, random() should only be used by the scheduler
   (ie. statintr() because it is uniformly distributed
2) arc4random() is actually strong, random() is not at all
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.h,v 1.1 1999/12/08 06:50:23 itojun Exp $	*/
d258 1
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 1
a124 1
		(((MIN_RANDOM_FACTOR * (x >> 10)) + (random() & \
@

