head	1.12;
access;
symbols
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.2
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.7.0.8
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.4
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.2
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.4
	OPENBSD_3_5_BASE:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.12
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.11;
commitid	ymldqUr8o0SRU6R6;

1.11
date	2015.12.04.12.10.26;	author tedu;	state Exp;
branches;
next	1.10;
commitid	fTBR3Cet0Ccp0CBz;

1.10
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.9;
commitid	p4LJxGKbi0BU2cG6;

1.9
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.8;
commitid	Z1vcFtHO8wRH0yRt;

1.8
date	2010.02.08.12.16.02;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.12.06.57.12;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.12.10.07.21.01;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@/*	$OpenBSD: ip6_id.c,v 1.11 2015/12/04 12:10:26 tedu Exp $	*/
/*	$NetBSD: ip6_id.c,v 1.7 2003/09/13 21:32:59 itojun Exp $	*/
/*	$KAME: ip6_id.c,v 1.8 2003/09/06 13:41:06 itojun Exp $	*/

/*
 * Copyright (C) 2003 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright 1998 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Theo de Raadt <deraadt@@openbsd.org> came up with the idea of using
 * such a mathematical system to generate more random (yet non-repeating)
 * ids to solve the resolver/named problem.  But Niels designed the
 * actual system based on the constraints.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * seed = random (bits - 1) bit
 * n = prime, g0 = generator to n,
 * j = random so that gcd(j,n-1) == 1
 * g = g0^j mod n will be a generator again.
 *
 * X[0] = random seed.
 * X[n] = a*X[n-1]+b mod m is a Linear Congruential Generator
 * with a = 7^(even random) mod m,
 *      b = random with gcd(b,m) == 1
 *      m = constant and a maximal period of m-1.
 *
 * The transaction id is determined by:
 * id[n] = seed xor (g^X[n] mod n)
 *
 * Effectivly the id is restricted to the lower (bits - 1) bits, thus
 * yielding two different cycles by toggling the msb on and off.
 * This avoids reuse issues caused by reseeding.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <netinet/in.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>

struct randomtab {
	const int	ru_bits; /* resulting bits */
	const long	ru_out;	/* Time after wich will be reseeded */
	const u_int32_t ru_max;	/* Uniq cycle, avoid blackjack prediction */
	const u_int32_t ru_gen;	/* Starting generator */
	const u_int32_t ru_n;	/* ru_n: prime, ru_n - 1: product of pfacts[] */
	const u_int32_t ru_agen; /* determine ru_a as ru_agen^(2*rand) */
	const u_int32_t ru_m;	/* ru_m = 2^x*3^y */
	const u_int32_t pfacts[4];	/* factors of ru_n */

	u_int32_t ru_counter;
	u_int32_t ru_msb;

	u_int32_t ru_x;
	u_int32_t ru_seed, ru_seed2;
	u_int32_t ru_a, ru_b;
	u_int32_t ru_g;
	long ru_reseed;
};

static struct randomtab randomtab_20 = {
	20,			/* resulting bits */
	180,			/* Time after wich will be reseeded */
	200000,			/* Uniq cycle, avoid blackjack prediction */
	2,			/* Starting generator */
	524269,			/* RU_N-1 = 2^2*3^2*14563 */
	7,			/* determine ru_a as RU_AGEN^(2*rand) */
	279936,			/* RU_M = 2^7*3^7 - don't change */
	{ 2, 3, 14563, 0 },	/* factors of ru_n */
};

u_int32_t ip6id_pmod(u_int32_t, u_int32_t, u_int32_t);
void ip6id_initid(struct randomtab *);
u_int32_t ip6id_randomid(struct randomtab *);

/*
 * Do a fast modular exponation, returned value will be in the range
 * of 0 - (mod-1)
 */

u_int32_t
ip6id_pmod(u_int32_t gen, u_int32_t expo, u_int32_t mod)
{
	u_int64_t s, t, u;

	s = 1;
	t = gen;
	u = expo;

	while (u) {
		if (u & 1)
			s = (s * t) % mod;
		u >>= 1;
		t = (t * t) % mod;
	}
	return (s);
}

/*
 * Initializes the seed and chooses a suitable generator. Also toggles
 * the msb flag. The msb flag is used to generate two distinct
 * cycles of random numbers and thus avoiding reuse of ids.
 *
 * This function is called from id_randomid() when needed, an
 * application does not have to worry about it.
 */
void
ip6id_initid(struct randomtab *p)
{
	u_int32_t j, i;
	int noprime = 1;

	p->ru_x = arc4random_uniform(p->ru_m);

	/* (bits - 1) bits of random seed */
	p->ru_seed = arc4random() & (~0U >> (32 - p->ru_bits + 1));
	p->ru_seed2 = arc4random() & (~0U >> (32 - p->ru_bits + 1));

	/* Determine the LCG we use */
	p->ru_b = (arc4random() & (~0U >> (32 - p->ru_bits))) | 1;
	p->ru_a = ip6id_pmod(p->ru_agen,
	    (arc4random() & (~0U >> (32 - p->ru_bits))) & (~1U), p->ru_m);
	while (p->ru_b % 3 == 0)
		p->ru_b += 2;

	j = arc4random_uniform(p->ru_n);

	/*
	 * Do a fast gcd(j, RU_N - 1), so we can find a j with
	 * gcd(j, RU_N - 1) == 1, giving a new generator for
	 * RU_GEN^j mod RU_N
	 */
	while (noprime) {
		for (i = 0; p->pfacts[i] > 0; i++)
			if (j % p->pfacts[i] == 0)
				break;

		if (p->pfacts[i] == 0)
			noprime = 0;
		else
			j = (j + 1) % p->ru_n;
	}

	p->ru_g = ip6id_pmod(p->ru_gen, j, p->ru_n);
	p->ru_counter = 0;

	p->ru_reseed = time_uptime + p->ru_out;
	p->ru_msb = p->ru_msb ? 0 : (1U << (p->ru_bits - 1));
}

u_int32_t
ip6id_randomid(struct randomtab *p)
{
	int i, n;

	if (p->ru_counter >= p->ru_max || time_uptime > p->ru_reseed)
		ip6id_initid(p);

	/* Skip a random number of ids */
	n = arc4random() & 0x3;
	if (p->ru_counter + n >= p->ru_max)
		ip6id_initid(p);

	for (i = 0; i <= n; i++) {
		/* Linear Congruential Generator */
		p->ru_x = (u_int32_t)((u_int64_t)p->ru_a * p->ru_x + p->ru_b) % p->ru_m;
	}

	p->ru_counter += i;

	return (p->ru_seed ^ ip6id_pmod(p->ru_g, p->ru_seed2 + p->ru_x, p->ru_n)) |
	    p->ru_msb;
}

u_int32_t
ip6_randomflowlabel(void)
{
	return ip6id_randomid(&randomtab_20) & 0xfffff;
}

@


1.11
log
@prefix function names like randomid and pmod to keep them out of global
namespace. the history of this file is that it was a modified version of
ip_id.c (with static functions to avoid clashes), then that file was
rewritten, then this file lost static.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.10 2015/03/14 03:38:52 jsg Exp $	*/
d200 1
a200 1
	p->ru_reseed = time_second + p->ru_out;
d209 1
a209 1
	if (p->ru_counter >= p->ru_max || time_second > p->ru_reseed)
@


1.10
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.9 2014/11/18 02:37:31 tedu Exp $	*/
d125 3
a127 3
u_int32_t pmod(u_int32_t, u_int32_t, u_int32_t);
void initid(struct randomtab *);
u_int32_t randomid(struct randomtab *);
d135 1
a135 1
pmod(u_int32_t gen, u_int32_t expo, u_int32_t mod)
d161 1
a161 1
initid(struct randomtab *p)
d174 1
a174 1
	p->ru_a = pmod(p->ru_agen,
d197 1
a197 1
	p->ru_g = pmod(p->ru_gen, j, p->ru_n);
d205 1
a205 1
randomid(struct randomtab *p)
d210 1
a210 1
		initid(p);
d215 1
a215 1
		initid(p);
d224 1
a224 1
	return (p->ru_seed ^ pmod(p->ru_g, p->ru_seed2 + p->ru_x, p->ru_n)) |
d231 1
a231 1
	return randomid(&randomtab_20) & 0xfffff;
@


1.9
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.8 2010/02/08 12:16:02 jsing Exp $	*/
a89 1
#include <net/if.h>
@


1.8
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.6 2008/04/18 06:42:20 djm Exp $	*/
d88 1
a93 2

#include <dev/rndvar.h>
@


1.7
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d127 3
a129 3
static u_int32_t pmod(u_int32_t, u_int32_t, u_int32_t);
static void initid(struct randomtab *);
static u_int32_t randomid(struct randomtab *);
d136 1
a136 1
static u_int32_t
d162 1
a162 1
static void
d206 1
a206 1
static u_int32_t
@


1.6
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.5 2007/11/26 09:28:33 martynas Exp $	*/
a115 11
static struct randomtab randomtab_32 = {
	32,			/* resulting bits */
	180,			/* Time after wich will be reseeded */
	1000000000,		/* Uniq cycle, avoid blackjack prediction */
	2,			/* Starting generator */
	2147483629,		/* RU_N-1 = 2^2*3^2*59652323 */
	7,			/* determine ru_a as RU_AGEN^(2*rand) */
	1836660096,		/* RU_M = 2^7*3^15 - don't change */
	{ 2, 3, 59652323, 0 },	/* factors of ru_n */
};

a230 7
ip6_randomid(void)
{

	return randomid(&randomtab_32);
}

u_int32_t
a232 1

d235 1
@


1.5
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.4 2004/06/21 23:50:37 tholo Exp $	*/
d179 1
a179 1
	p->ru_x = arc4random() % p->ru_m;
d192 1
a192 1
	j = arc4random() % p->ru_n;
@


1.4
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.3 2003/12/12 06:57:12 itojun Exp $	*/
d166 1
a166 1
 * Initalizes the seed and chooses a suitable generator. Also toggles
@


1.3
log
@niels kindly dropped clause 3/4 from the license.  tnx!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.2 2003/12/10 07:21:01 itojun Exp $	*/
d213 1
a213 1
	p->ru_reseed = time.tv_sec + p->ru_out;
d222 1
a222 1
	if (p->ru_counter >= p->ru_max || time.tv_sec > p->ru_reseed)
@


1.3.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@correct non-repetitive ID code, based on comments from niels provos.
- seed2 is necessary, but use it as "seed2 + x" not "seed2 ^ x".
- skipping number is not needed, so disable it for 16bit generator (makes
  the repetition period to 30000)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_id.c,v 1.1 2003/10/01 21:41:05 itojun Exp $	*/
a50 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.1
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_id.c,v 1.6 2002/03/15 18:19:52 millert Exp $	*/
a225 1
	u_int32_t tmp;
a229 2
	tmp = arc4random();

d231 1
a231 1
	n = tmp & 0x3; tmp = tmp >> 2;
d242 1
a242 1
	return (p->ru_seed ^ pmod(p->ru_g, p->ru_seed2 ^ p->ru_x, p->ru_n)) |
@

