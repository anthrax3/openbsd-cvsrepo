head	1.113;
access;
symbols
	OPENBSD_6_1:1.109.0.4
	OPENBSD_6_1_BASE:1.109
	OPENBSD_6_0:1.103.0.2
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.102.0.2
	OPENBSD_5_9_BASE:1.102
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.70.0.4
	OPENBSD_5_6_BASE:1.70
	OPENBSD_5_5:1.67.0.4
	OPENBSD_5_5_BASE:1.67
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.56.0.10
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.8
	OPENBSD_5_0:1.56.0.6
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.56.0.4
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.56.0.2
	OPENBSD_4_8_BASE:1.56
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.53.0.4
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.52.0.2
	OPENBSD_4_5_BASE:1.52
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.50.0.2
	OPENBSD_4_3_BASE:1.50
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.47.0.2
	OPENBSD_4_1_BASE:1.47
	OPENBSD_4_0:1.45.0.4
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.2
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.44.0.4
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.44.0.2
	OPENBSD_3_7_BASE:1.44
	OPENBSD_3_6:1.43.0.2
	OPENBSD_3_6_BASE:1.43
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.40.0.2
	OPENBSD_3_4_BASE:1.40
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.31.0.2
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.29
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.7.0.2
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.113
date	2017.05.17.13.25.27;	author rzalamena;	state Exp;
branches;
next	1.112;
commitid	XRF5bty7M3lN08lA;

1.112
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.111;
commitid	SAe3SQ48vKH6r5FL;

1.111
date	2017.05.16.08.50.18;	author rzalamena;	state Exp;
branches;
next	1.110;
commitid	bXAfw3BuF3iPYO7B;

1.110
date	2017.05.08.08.46.39;	author rzalamena;	state Exp;
branches;
next	1.109;
commitid	ffGuaP6j4fxaZcHM;

1.109
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.108;
commitid	2R0NOjEDy2jGtnjL;

1.108
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.107;
commitid	UBL7uwpXqTP4EWIu;

1.107
date	2017.01.06.10.02.57;	author mpi;	state Exp;
branches;
next	1.106;
commitid	pyTY0DbP5hokbnVn;

1.106
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.105;
commitid	T2qzeepA7r1EGy1x;

1.105
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.104;
commitid	ymldqUr8o0SRU6R6;

1.104
date	2016.08.23.11.01.16;	author mpi;	state Exp;
branches;
next	1.103;
commitid	8QcW64H7GGDXgbYs;

1.103
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.102;
commitid	qWegq9wDcxofLjIV;

1.102
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.101;
commitid	5qLGnZtXVLeqUvHc;

1.101
date	2015.12.03.13.13.42;	author tedu;	state Exp;
branches;
next	1.100;
commitid	B6mmJF8KPnwvL8eB;

1.100
date	2015.11.13.10.33.12;	author mpi;	state Exp;
branches;
next	1.99;
commitid	ikwDIrM8JnCJkuMQ;

1.99
date	2015.11.12.18.01.43;	author mpi;	state Exp;
branches;
next	1.98;
commitid	Pu74k5LnqSFxQZIb;

1.98
date	2015.11.12.17.46.27;	author mpi;	state Exp;
branches;
next	1.97;
commitid	fkpITfyUV3ZUzbSp;

1.97
date	2015.11.12.17.42.28;	author mpi;	state Exp;
branches;
next	1.96;
commitid	pE6huLyQE4pgj5Tp;

1.96
date	2015.11.12.17.30.51;	author mpi;	state Exp;
branches;
next	1.95;
commitid	YvQ7cm6jbh0CSKPE;

1.95
date	2015.11.12.16.58.45;	author mpi;	state Exp;
branches;
next	1.94;
commitid	uUnwnfhXZRPy2XRQ;

1.94
date	2015.11.12.16.34.14;	author mpi;	state Exp;
branches;
next	1.93;
commitid	qYqqFcQSli7CnKx0;

1.93
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.92;
commitid	Ajb0hNGeCqGFHjjg;

1.92
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.91;
commitid	zZXiESHR0g5lNO0l;

1.91
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.90;
commitid	UM7jfgLT8vWQUBm1;

1.90
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.89;
commitid	LU3jSOpFfLxcllFL;

1.89
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.88;
commitid	Cr0DVA7exR1t2zXg;

1.88
date	2015.09.10.09.09.03;	author claudio;	state Exp;
branches;
next	1.87;
commitid	j3aJw3YKzJzktiav;

1.87
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.86;
commitid	0LcoZC9QTu9wgpyX;

1.86
date	2015.07.15.17.56.05;	author deraadt;	state Exp;
branches;
next	1.85;
commitid	SRfPA9E5jttPpB3J;

1.85
date	2015.07.08.08.48.35;	author mpi;	state Exp;
branches;
next	1.84;
commitid	PeSgmtaVq0R4a133;

1.84
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.83;
commitid	J4OPNuggl4DOKGzM;

1.83
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.82;
commitid	h7z8lokZ0dFyuWpg;

1.82
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.81;
commitid	4Ro7ulidQXNcMvmM;

1.81
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.80;
commitid	p4LJxGKbi0BU2cG6;

1.80
date	2015.02.09.12.23.22;	author claudio;	state Exp;
branches;
next	1.79;
commitid	lhMJN7NMGgqb766x;

1.79
date	2015.02.09.04.49.16;	author dlg;	state Exp;
branches;
next	1.78;
commitid	01s4UfydGxzHyYj5;

1.78
date	2015.02.08.03.41.36;	author claudio;	state Exp;
branches;
next	1.77;
commitid	S1MAMktawAl21LLI;

1.77
date	2014.12.19.17.14.40;	author tedu;	state Exp;
branches;
next	1.76;
commitid	zhW8jJrfVCoAthrR;

1.76
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.75;
commitid	cYQY7jiay4SydLhD;

1.75
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.74;
commitid	Vq8oSnWLkf7dyy0N;

1.74
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.73;
commitid	t9FBKDfc4VDxpEy2;

1.73
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.72;
commitid	ZqXwxwmeo3l29NOg;

1.72
date	2014.08.19.12.28.03;	author mpi;	state Exp;
branches;
next	1.71;
commitid	FLUReMqhibXwzcGn;

1.71
date	2014.08.14.09.01.47;	author mpi;	state Exp;
branches;
next	1.70;
commitid	xAyitDa7xkItKbjR;

1.70
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.69;
commitid	B4dZSbxas1X1IpXI;

1.69
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.68;
commitid	2Ufy37wyO5neufOK;

1.68
date	2014.03.10.05.28.11;	author lteo;	state Exp;
branches;
next	1.67;

1.67
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.27.20.57.39;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2013.10.21.10.07.03;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.09.09.44.19;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.14.14.59.34;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.20.10.34.12;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.19.22.37.23;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2010.02.08.12.16.02;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2009.10.30.16.14.52;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2009.05.31.19.15.58;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.17.05.43.14;	author chl;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.50;

1.50
date	2008.01.02.03.33.18;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2007.12.14.18.33.41;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.21.05.37.32;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.14.02.48.12;	author brad;	state Exp;
branches;
next	1.44;

1.44
date	2004.11.10.03.38.52;	author mcbride;	state Exp;
branches;
next	1.43;

1.43
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.10.09.31.32;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.08.10.23.32;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.06.06.57.23;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.03.06.24.22;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.15.13.52.13;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.14.17.05.34;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.07.02.12.09;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.27.05.10.07;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.09.03.12.01;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.25.12.43.28;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.29.07.58.30;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.07.18.18.14;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.07.04.13.10;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.30.04.40.02;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.24.20.53.49;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.02.10.23.15.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.25.09.25.08;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.08.09.01.31;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.07.22.50.44;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.16.14.58.12;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.16.08.48.06;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.16.08.12.29;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.08.14.51.22;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.10.15.33.11;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.19.03.14.02;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.29.09.20.24;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.13.14.44.17;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.19.13.11.34;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.40.19;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.55.23;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.3.2.8;

1.3.2.8
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.3.2.9;

1.3.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.113
log
@Optimize multicast packet sending by using m_dup_pkt() instead of
m_copym() for cloning packets. m_dup_pkt() creates a new mbuf with the
whole packet content and also pre allocates the space for layer 2
headers (Ethernet/VLAN).

ok mikeb@@
@
text
@/*	$NetBSD: ip6_mroute.c,v 1.59 2003/12/10 09:28:38 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.45 2001/03/25 08:38:51 itojun Exp $	*/

/*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*	BSDI ip_mroute.c,v 2.10 1996/11/14 00:29:52 jch Exp	*/

/*
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ip_mroute.c 8.2 (Berkeley) 11/15/93
 */

/*
 * IP multicast forwarding procedures
 *
 * Written by David Waitzman, BBN Labs, August 1988.
 * Modified by Steve Deering, Stanford, February 1989.
 * Modified by Mark J. Steiglitz, Stanford, May, 1991
 * Modified by Van Jacobson, LBL, January 1993
 * Modified by Ajit Thyagarajan, PARC, August 1993
 * Modified by Bill Fenner, PARC, April 1994
 *
 * MROUTING Revision: 3.5.1.2
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/ip6_mroute.h>
#include <netinet/in_pcb.h>

/* #define MCAST_DEBUG */

#ifdef MCAST_DEBUG
int mcast6_debug = 1;
#define DPRINTF(fmt, args...)						\
	do {								\
		if (mcast6_debug)					\
			printf("%s:%d " fmt "\n",			\
			    __func__, __LINE__, ## args);		\
	} while (0)
#else
#define DPRINTF(fmt, args...)			\
	do { } while (0)
#endif

int ip6_mdq(struct mbuf *, struct ifnet *, struct rtentry *);
void phyint_send6(struct ifnet *, struct ip6_hdr *, struct mbuf *);

/*
 * Globals.  All but ip6_mrouter, ip6_mrtproto and mrt6stat could be static,
 * except for netstat or debugging purposes.
 */
struct socket  *ip6_mrouter[RT_TABLEID_MAX];
struct rttimer_queue *mrouter6q[RT_TABLEID_MAX];
int		ip6_mrouter_ver = 0;
int		ip6_mrtproto;    /* for netstat only */
struct mrt6stat	mrt6stat;

#define NO_RTE_FOUND	0x1
#define RTE_FOUND	0x2

#define		MCAST_EXPIRE_TIMEOUT 30		/* seconds */

/*
 * Macros to compute elapsed time efficiently
 * Borrowed from Van Jacobson's scheduling code
 */
#define TV_DELTA(a, b, delta) do { \
	    int xxs; \
		\
	    delta = (a).tv_usec - (b).tv_usec; \
	    if ((xxs = (a).tv_sec - (b).tv_sec)) { \
	       switch (xxs) { \
		      case 2: \
			  delta += 1000000; \
			      /* FALLTHROUGH */ \
		      case 1: \
			  delta += 1000000; \
			  break; \
		      default: \
			  delta += (1000000 * xxs); \
	       } \
	    } \
} while (0)

#define TV_LT(a, b) (((a).tv_usec < (b).tv_usec && \
	      (a).tv_sec <= (b).tv_sec) || (a).tv_sec < (b).tv_sec)

int get_sg6_cnt(struct sioc_sg_req6 *, unsigned int);
int get_mif6_cnt(struct sioc_mif_req6 *, unsigned int);
int ip6_mrouter_init(struct socket *, int, int);
int add_m6if(struct socket *, struct mif6ctl *);
int del_m6if(struct socket *, mifi_t *);
int add_m6fc(struct socket *, struct mf6cctl *);
int del_m6fc(struct socket *, struct mf6cctl *);
struct ifnet *mrt6_iflookupbymif(mifi_t, unsigned int);
struct rtentry *mf6c_find(struct ifnet *, struct in6_addr *,
    struct in6_addr *, unsigned int);
struct rtentry *mrt6_mcast6_add(struct ifnet *, struct sockaddr *,
    struct sockaddr *);
int mrt6_mcast6_del(struct rtentry *, unsigned int);
void mf6c_expire_route(struct rtentry *, struct rttimer *);

/*
 * Handle MRT setsockopt commands to modify the multicast routing tables.
 */
int
ip6_mrouter_set(int cmd, struct socket *so, struct mbuf *m)
{
	struct inpcb	*inp = sotoinpcb(so);

	if (cmd != MRT6_INIT && so != ip6_mrouter[inp->inp_rtableid])
		return (EPERM);

	switch (cmd) {
	case MRT6_INIT:
		if (m == NULL || m->m_len < sizeof(int))
			return (EINVAL);
		return (ip6_mrouter_init(so, *mtod(m, int *), cmd));
	case MRT6_DONE:
		return (ip6_mrouter_done(so));
	case MRT6_ADD_MIF:
		if (m == NULL || m->m_len < sizeof(struct mif6ctl))
			return (EINVAL);
		return (add_m6if(so, mtod(m, struct mif6ctl *)));
	case MRT6_DEL_MIF:
		if (m == NULL || m->m_len < sizeof(mifi_t))
			return (EINVAL);
		return (del_m6if(so, mtod(m, mifi_t *)));
	case MRT6_ADD_MFC:
		if (m == NULL || m->m_len < sizeof(struct mf6cctl))
			return (EINVAL);
		return (add_m6fc(so, mtod(m, struct mf6cctl *)));
	case MRT6_DEL_MFC:
		if (m == NULL || m->m_len < sizeof(struct mf6cctl))
			return (EINVAL);
		return (del_m6fc(so, mtod(m,  struct mf6cctl *)));
	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Handle MRT getsockopt commands
 */
int
ip6_mrouter_get(int cmd, struct socket *so, struct mbuf *m)
{
	struct inpcb	*inp = sotoinpcb(so);

	if (so != ip6_mrouter[inp->inp_rtableid])
		return (EPERM);

	switch (cmd) {
	default:
		return EOPNOTSUPP;
	}
}

/*
 * Handle ioctl commands to obtain information from the cache
 */
int
mrt6_ioctl(struct socket *so, u_long cmd, caddr_t data)
{
	struct inpcb *inp = sotoinpcb(so);

	switch (cmd) {
	case SIOCGETSGCNT_IN6:
		return (get_sg6_cnt((struct sioc_sg_req6 *)data,
		    inp->inp_rtableid));
	case SIOCGETMIFCNT_IN6:
		return (get_mif6_cnt((struct sioc_mif_req6 *)data,
		    inp->inp_rtableid));
	default:
		return (ENOTTY);
	}
}

/*
 * returns the packet, byte, rpf-failure count for the source group provided
 */
int
get_sg6_cnt(struct sioc_sg_req6 *req, unsigned int rtableid)
{
	struct rtentry *rt;
	struct mf6c *mf6c;

	rt = mf6c_find(NULL, &req->src.sin6_addr, &req->grp.sin6_addr,
	    rtableid);
	if (rt == NULL) {
		req->pktcnt = req->bytecnt = req->wrong_if = 0xffffffff;
		return EADDRNOTAVAIL;
	}

	req->pktcnt = req->bytecnt = req->wrong_if = 0;
	do {
		mf6c = (struct mf6c *)rt->rt_llinfo;
		if (mf6c == NULL)
			continue;

		req->pktcnt += mf6c->mf6c_pkt_cnt;
		req->bytecnt += mf6c->mf6c_byte_cnt;
		req->wrong_if += mf6c->mf6c_wrong_if;
	} while ((rt = rtable_iterate(rt)) != NULL);

	return 0;
}

/*
 * returns the input and output packet and byte counts on the mif provided
 */
int
get_mif6_cnt(struct sioc_mif_req6 *req, unsigned int rtableid)
{
	struct ifnet *ifp;
	struct mif6 *m6;

	if ((ifp = mrt6_iflookupbymif(req->mifi, rtableid)) == NULL)
		return EINVAL;

	m6 = (struct mif6 *)ifp->if_mcast6;
	req->icount = m6->m6_pkt_in;
	req->ocount = m6->m6_pkt_out;
	req->ibytes = m6->m6_bytes_in;
	req->obytes = m6->m6_bytes_out;

	return 0;
}

int
mrt6_sysctl_mif(void *oldp, size_t *oldlenp)
{
	struct ifnet *ifp;
	caddr_t where = oldp;
	size_t needed, given;
	struct mif6 *mifp;
	struct mif6info minfo;

	given = *oldlenp;
	needed = 0;
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if ((mifp = (struct mif6 *)ifp->if_mcast6) == NULL)
			continue;

		minfo.m6_mifi = mifp->m6_mifi;
		minfo.m6_flags = mifp->m6_flags;
		minfo.m6_lcl_addr = mifp->m6_lcl_addr;
		minfo.m6_ifindex = ifp->if_index;
		minfo.m6_pkt_in = mifp->m6_pkt_in;
		minfo.m6_pkt_out = mifp->m6_pkt_out;
		minfo.m6_bytes_in = mifp->m6_bytes_in;
		minfo.m6_bytes_out = mifp->m6_bytes_out;
		minfo.m6_rate_limit = mifp->m6_rate_limit;

		needed += sizeof(minfo);
		if (where && needed <= given) {
			int error;

			error = copyout(&minfo, where, sizeof(minfo));
			if (error)
				return (error);
			where += sizeof(minfo);
		}
	}
	if (where) {
		*oldlenp = needed;
		if (given < needed)
			return (ENOMEM);
	} else
		*oldlenp = (11 * needed) / 10;

	return (0);
}

struct mf6csysctlarg {
	struct mf6cinfo	*ms6a_minfos;
	size_t		 ms6a_len;
	size_t		 ms6a_needed;
};

int
mrt6_rtwalk_mf6csysctl(struct rtentry *rt, void *arg, unsigned int rtableid)
{
	struct mf6c		*mf6c = (struct mf6c *)rt->rt_llinfo;
	struct mf6csysctlarg	*msa = arg;
	struct ifnet		*ifp;
	struct mif6		*m6;
	struct mf6cinfo		*minfo;
	int			 new = 0;

	/* Skip entries being removed. */
	if (mf6c == NULL)
		return 0;

	/* Skip non-multicast routes. */
	if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
	    (RTF_HOST | RTF_MULTICAST))
		return 0;

	/* User just asked for the output size. */
	if (msa->ms6a_minfos == NULL) {
		msa->ms6a_needed += sizeof(*minfo);
		return 0;
	}

	/* Skip route with invalid interfaces. */
	if ((ifp = if_get(rt->rt_ifidx)) == NULL)
		return 0;
	if ((m6 = (struct mif6 *)ifp->if_mcast6) == NULL) {
		if_put(ifp);
		return 0;
	}

	for (minfo = msa->ms6a_minfos;
	     (uint8_t *)minfo < ((uint8_t *)msa->ms6a_minfos + msa->ms6a_len);
	     minfo++) {
		/* Find a new entry or update old entry. */
		if (!IN6_ARE_ADDR_EQUAL(&minfo->mf6c_origin.sin6_addr,
		    &satosin6(rt->rt_gateway)->sin6_addr) ||
		    !IN6_ARE_ADDR_EQUAL(&minfo->mf6c_mcastgrp.sin6_addr,
		    &satosin6(rt_key(rt))->sin6_addr)) {
			if (!IN6_IS_ADDR_UNSPECIFIED(
			    &minfo->mf6c_origin.sin6_addr) ||
			    !IN6_IS_ADDR_UNSPECIFIED(
			    &minfo->mf6c_mcastgrp.sin6_addr))
				continue;

			new = 1;
		}

		minfo->mf6c_origin = *satosin6(rt->rt_gateway);
		minfo->mf6c_mcastgrp = *satosin6(rt_key(rt));
		minfo->mf6c_parent = mf6c->mf6c_parent;
		minfo->mf6c_pkt_cnt += mf6c->mf6c_pkt_cnt;
		minfo->mf6c_byte_cnt += mf6c->mf6c_byte_cnt;
		IF_SET(m6->m6_mifi, &minfo->mf6c_ifset);
		break;
	}

	if (new != 0)
		msa->ms6a_needed += sizeof(*minfo);

	if_put(ifp);

	return 0;
}

int
mrt6_sysctl_mfc(void *oldp, size_t *oldlenp)
{
	unsigned int		 rtableid;
	int			 error;
	struct mf6csysctlarg	 msa;

	if (oldp != NULL && *oldlenp > MAXPHYS)
		return EINVAL;

	if (oldp != NULL)
		msa.ms6a_minfos = malloc(*oldlenp, M_TEMP, M_WAITOK | M_ZERO);
	else
		msa.ms6a_minfos = NULL;

	msa.ms6a_len = *oldlenp;
	msa.ms6a_needed = 0;

	for (rtableid = 0; rtableid < RT_TABLEID_MAX; rtableid++)
		rtable_walk(rtableid, AF_INET6, mrt6_rtwalk_mf6csysctl, &msa);

	if (msa.ms6a_minfos != NULL && msa.ms6a_needed > 0 &&
	    (error = copyout(msa.ms6a_minfos, oldp, msa.ms6a_needed)) != 0) {
		free(msa.ms6a_minfos, M_TEMP, *oldlenp);
		return error;
	}

	free(msa.ms6a_minfos, M_TEMP, *oldlenp);
	*oldlenp = msa.ms6a_needed;

	return 0;
}

/*
 * Enable multicast routing
 */
int
ip6_mrouter_init(struct socket *so, int v, int cmd)
{
	struct inpcb *inp = sotoinpcb(so);
	unsigned int rtableid = inp->inp_rtableid;

	if (so->so_type != SOCK_RAW ||
	    so->so_proto->pr_protocol != IPPROTO_ICMPV6)
		return (EOPNOTSUPP);

	if (v != 1)
		return (ENOPROTOOPT);

	if (ip6_mrouter[rtableid] != NULL)
		return (EADDRINUSE);

	ip6_mrouter[rtableid] = so;
	ip6_mrouter_ver = cmd;
	mrouter6q[rtableid] = rt_timer_queue_create(MCAST_EXPIRE_TIMEOUT);

	return (0);
}

int
mrouter6_rtwalk_delete(struct rtentry *rt, void *arg, unsigned int rtableid)
{
	/* Skip non-multicast routes. */
	if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
	    (RTF_HOST | RTF_MULTICAST))
		return 0;

	/* Remove all timers related to this route. */
	rt_timer_remove_all(rt);
	mrt6_mcast6_del(rt, rtableid);

	return 0;
}

/*
 * Disable multicast routing
 */
int
ip6_mrouter_done(struct socket *so)
{
	struct inpcb *inp = sotoinpcb(so);
	struct ifnet *ifp;
	unsigned int rtableid = inp->inp_rtableid;

	NET_ASSERT_LOCKED();

	/* Delete all remaining installed multicast routes. */
	rtable_walk(rtableid, AF_INET6, mrouter6_rtwalk_delete, NULL);

	/* Unregister all interfaces in the domain. */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;

		ip6_mrouter_detach(ifp);
	}

	rt_timer_queue_destroy(mrouter6q[rtableid]);
	ip6_mrouter[inp->inp_rtableid] = NULL;
	ip6_mrouter_ver = 0;
	mrouter6q[rtableid] = NULL;

	return 0;
}

void
ip6_mrouter_detach(struct ifnet *ifp)
{
	struct mif6 *m6 = (struct mif6 *)ifp->if_mcast6;
	struct in6_ifreq ifr;

	if (m6 == NULL)
		return;

	ifp->if_mcast6 = NULL;

	memset(&ifr, 0, sizeof(ifr));
	ifr.ifr_addr.sin6_family = AF_INET6;
	ifr.ifr_addr.sin6_addr = in6addr_any;
	(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);

	free(m6, M_MRTABLE, sizeof(*m6));
}

/*
 * Add a mif to the mif table
 */
int
add_m6if(struct socket *so, struct mif6ctl *mifcp)
{
	struct inpcb *inp = sotoinpcb(so);
	struct mif6 *mifp;
	struct ifnet *ifp;
	struct in6_ifreq ifr;
	int error;
	unsigned int rtableid = inp->inp_rtableid;

	NET_ASSERT_LOCKED();

	if (mifcp->mif6c_mifi >= MAXMIFS)
		return EINVAL;

	if (mrt6_iflookupbymif(mifcp->mif6c_mifi, rtableid) != NULL)
		return EADDRINUSE; /* XXX: is it appropriate? */

	{
		ifp = if_get(mifcp->mif6c_pifi);
		if (ifp == NULL)
			return ENXIO;

		/* Make sure the interface supports multicast */
		if ((ifp->if_flags & IFF_MULTICAST) == 0) {
			if_put(ifp);
			return EOPNOTSUPP;
		}

		/*
		 * Enable promiscuous reception of all IPv6 multicasts
		 * from the interface.
		 */
		memset(&ifr, 0, sizeof(ifr));
		ifr.ifr_addr.sin6_family = AF_INET6;
		ifr.ifr_addr.sin6_addr = in6addr_any;
		error = (*ifp->if_ioctl)(ifp, SIOCADDMULTI, (caddr_t)&ifr);

		if (error) {
			if_put(ifp);
			return error;
		}
	}

	mifp = malloc(sizeof(*mifp), M_MRTABLE, M_WAITOK | M_ZERO);
	ifp->if_mcast6	   = (caddr_t)mifp;
	mifp->m6_mifi	   = mifcp->mif6c_mifi;
	mifp->m6_flags     = mifcp->mif6c_flags;
#ifdef notyet
	/* scaling up here allows division by 1024 in critical code */
	mifp->m6_rate_limit = mifcp->mif6c_rate_limit * 1024 / 1000;
#endif

	if_put(ifp);

	return 0;
}

/*
 * Delete a mif from the mif table
 */
int
del_m6if(struct socket *so, mifi_t *mifip)
{
	struct inpcb *inp = sotoinpcb(so);
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	if (*mifip >= MAXMIFS)
		return EINVAL;
	if ((ifp = mrt6_iflookupbymif(*mifip, inp->inp_rtableid)) == NULL)
		return EINVAL;

	ip6_mrouter_detach(ifp);

	return 0;
}

int
mf6c_add_route(struct ifnet *ifp, struct sockaddr *origin,
    struct sockaddr *group, struct mf6cctl *mf6cc, int wait)
{
	struct rtentry *rt;
	struct mf6c *mf6c;
	unsigned int rtableid = ifp->if_rdomain;
#ifdef MCAST_DEBUG
	char bsrc[INET6_ADDRSTRLEN], bdst[INET6_ADDRSTRLEN];
#endif /* MCAST_DEBUG */

	rt = mrt6_mcast6_add(ifp, origin, group);
	if (rt == NULL)
		return ENOENT;

	mf6c = malloc(sizeof(*mf6c), M_MRTABLE, wait | M_ZERO);
	if (mf6c == NULL) {
		DPRINTF("origin %s group %s parent %d (%s) malloc failed",
		    inet_ntop(AF_INET6, origin, bsrc, sizeof(bsrc)),
		    inet_ntop(AF_INET6, group, bdst, sizeof(bdst)),
		    mf6cc->mf6cc_parent, ifp->if_xname);
		mrt6_mcast6_del(rt, rtableid);
		return ENOMEM;
	}

	rt->rt_llinfo = (caddr_t)mf6c;
	rt_timer_add(rt, mf6c_expire_route, mrouter6q[rtableid], rtableid);
	mf6c->mf6c_parent = mf6cc->mf6cc_parent;
	rtfree(rt);

	return 0;
}

void
mf6c_update(struct mf6cctl *mf6cc, int wait, unsigned int rtableid)
{
	struct rtentry *rt;
	struct mf6c *mf6c;
	struct ifnet *ifp;
	struct sockaddr_in6 osin6, gsin6;
	mifi_t mifi;
#ifdef MCAST_DEBUG
	char bdst[INET6_ADDRSTRLEN];
#endif /* MCAST_DEBUG */

	memset(&osin6, 0, sizeof(osin6));
	osin6.sin6_family = AF_INET6;
	osin6.sin6_len = sizeof(osin6);
	osin6.sin6_addr = mf6cc->mf6cc_origin.sin6_addr;

	memset(&gsin6, 0, sizeof(gsin6));
	gsin6.sin6_family = AF_INET6;
	gsin6.sin6_len = sizeof(gsin6);
	gsin6.sin6_addr = mf6cc->mf6cc_mcastgrp.sin6_addr;

	for (mifi = 0; mifi < MAXMIFS; mifi++) {
		if (mifi == mf6cc->mf6cc_parent)
			continue;

		/* Test for mif existence and then update the entry. */
		if ((ifp = mrt6_iflookupbymif(mifi, rtableid)) == NULL)
			continue;

		rt = mf6c_find(ifp, &mf6cc->mf6cc_origin.sin6_addr,
		    &mf6cc->mf6cc_mcastgrp.sin6_addr, rtableid);

		/* mif not configured or removed. */
		if (!IF_ISSET(mifi, &mf6cc->mf6cc_ifset)) {
			/* Route doesn't exist, nothing to do. */
			if (rt == NULL)
				continue;

			DPRINTF("del route (group %s) for mif %d (%s)",
			    inet_ntop(AF_INET6,
			    &mf6cc->mf6cc_mcastgrp.sin6_addr, bdst,
			    sizeof(bdst)), mifi, ifp->if_xname);

			rt_timer_remove_all(rt);
			mrt6_mcast6_del(rt, rtableid);
			continue;
		}

		/* Route exists, look for changes. */
		if (rt != NULL) {
			mf6c = (struct mf6c *)rt->rt_llinfo;
			/* Skip route being deleted. */
			if (mf6c == NULL) {
				rtfree(rt);
				continue;
			}

			/* No new changes to apply. */
			if (mf6cc->mf6cc_parent == mf6c->mf6c_parent) {
				rtfree(rt);
				continue;
			}

			DPRINTF("update route (group %s) for mif %d (%s)",
			    inet_ntop(AF_INET6,
			    &mf6cc->mf6cc_mcastgrp.sin6_addr, bdst,
			    sizeof(bdst)), mifi, ifp->if_xname);

			mf6c->mf6c_parent = mf6cc->mf6cc_parent;
			rtfree(rt);
			continue;
		}

		DPRINTF("add route (group %s) for mif %d (%s)",
		    inet_ntop(AF_INET6, &mf6cc->mf6cc_mcastgrp.sin6_addr,
		    bdst, sizeof(bdst)), mifi, ifp->if_xname);

		mf6c_add_route(ifp, sin6tosa(&osin6), sin6tosa(&gsin6),
		    mf6cc, wait);
	}

	/* Create route for the parent interface. */
	if ((ifp = mrt6_iflookupbymif(mf6cc->mf6cc_parent,
	    rtableid)) == NULL) {
		DPRINTF("failed to find upstream interface %d",
		    mf6cc->mf6cc_parent);
		return;
	}

	/* We already have a route, nothing to do here. */
	if ((rt = mf6c_find(ifp, &mf6cc->mf6cc_origin.sin6_addr,
	    &mf6cc->mf6cc_mcastgrp.sin6_addr, rtableid)) != NULL) {
		rtfree(rt);
		return;
	}

	DPRINTF("add upstream route (group %s) for if %s",
	    inet_ntop(AF_INET6, &mf6cc->mf6cc_mcastgrp.sin6_addr,
	    bdst, sizeof(bdst)), ifp->if_xname);
	mf6c_add_route(ifp, sin6tosa(&osin6), sin6tosa(&gsin6), mf6cc, wait);
}

int
mf6c_add(struct mf6cctl *mfccp, struct in6_addr *origin,
    struct in6_addr *group, int vidx, unsigned int rtableid, int wait)
{
	struct ifnet *ifp;
	struct mif6 *m6;
	struct mf6cctl mf6cc;

	ifp = mrt6_iflookupbymif(vidx, rtableid);
	if (ifp == NULL ||
	    (m6 = (struct mif6 *)ifp->if_mcast6) == NULL)
		return ENOENT;

	memset(&mf6cc, 0, sizeof(mf6cc));
	if (mfccp == NULL) {
		mf6cc.mf6cc_origin.sin6_family = AF_INET6;
		mf6cc.mf6cc_origin.sin6_len = sizeof(mf6cc.mf6cc_origin);
		mf6cc.mf6cc_origin.sin6_addr = *origin;
		mf6cc.mf6cc_mcastgrp.sin6_family = AF_INET6;
		mf6cc.mf6cc_mcastgrp.sin6_len = sizeof(mf6cc.mf6cc_mcastgrp);
		mf6cc.mf6cc_mcastgrp.sin6_addr = *group;
		mf6cc.mf6cc_parent = vidx;
	} else
		memcpy(&mf6cc, mfccp, sizeof(mf6cc));

	mf6c_update(&mf6cc, wait, rtableid);

	return 0;
}

int
add_m6fc(struct socket *so, struct mf6cctl *mfccp)
{
	struct inpcb *inp = sotoinpcb(so);
	unsigned int rtableid = inp->inp_rtableid;

	NET_ASSERT_LOCKED();

	return mf6c_add(mfccp, &mfccp->mf6cc_origin.sin6_addr,
	    &mfccp->mf6cc_mcastgrp.sin6_addr, mfccp->mf6cc_parent,
	    rtableid, M_WAITOK);
}

int
del_m6fc(struct socket *so, struct mf6cctl *mfccp)
{
	struct inpcb *inp = sotoinpcb(so);
	struct rtentry *rt;
	unsigned int rtableid = inp->inp_rtableid;

	NET_ASSERT_LOCKED();

	while ((rt = mf6c_find(NULL, &mfccp->mf6cc_origin.sin6_addr,
	    &mfccp->mf6cc_mcastgrp.sin6_addr, rtableid)) != NULL) {
		/* Remove all timers related to this route. */
		rt_timer_remove_all(rt);
		mrt6_mcast6_del(rt, rtableid);
	}

	return 0;
}

int
socket6_send(struct socket *s, struct mbuf *mm, struct sockaddr_in6 *src)
{
	if (s) {
		if (sbappendaddr(&s->so_rcv, sin6tosa(src), mm, NULL) != 0) {
			sorwakeup(s);
			return 0;
		}
	}
	m_freem(mm);
	return -1;
}

/*
 * IPv6 multicast forwarding function. This function assumes that the packet
 * pointed to by "ip6" has arrived on (or is about to be sent to) the interface
 * pointed to by "ifp", and the packet is to be relayed to other networks
 * that have members of the packet's destination IPv6 multicast group.
 *
 * The packet is returned unscathed to the caller, unless it is
 * erroneous, in which case a non-zero return value tells the caller to
 * discard it.
 */
int
ip6_mforward(struct ip6_hdr *ip6, struct ifnet *ifp, struct mbuf *m)
{
	struct rtentry *rt;
	struct mif6 *mifp;
	struct mbuf *mm;
	struct sockaddr_in6 sin6;
	unsigned int rtableid = ifp->if_rdomain;

	NET_ASSERT_LOCKED();

	/*
	 * Don't forward a packet with Hop limit of zero or one,
	 * or a packet destined to a local-only group.
	 */
	if (ip6->ip6_hlim <= 1 || IN6_IS_ADDR_MC_INTFACELOCAL(&ip6->ip6_dst) ||
	    IN6_IS_ADDR_MC_LINKLOCAL(&ip6->ip6_dst))
		return 0;
	ip6->ip6_hlim--;

	/*
	 * Source address check: do not forward packets with unspecified
	 * source. It was discussed in July 2000, on ipngwg mailing list.
	 * This is rather more serious than unicast cases, because some
	 * MLD packets can be sent with the unspecified source address
	 * (although such packets must normally set 1 to the hop limit field).
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
		ip6stat_inc(ip6s_cantforward);
		if (ip6_log_time + ip6_log_interval < time_uptime) {
			char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

			ip6_log_time = time_uptime;

			inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src));
			inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst));
			log(LOG_DEBUG, "cannot forward "
			    "from %s to %s nxt %d received on interface %u\n",
			    src, dst, ip6->ip6_nxt, m->m_pkthdr.ph_ifidx);
		}
		return 0;
	}

	/*
	 * Determine forwarding mifs from the forwarding cache table
	 */
	rt = mf6c_find(NULL, &ip6->ip6_src, &ip6->ip6_dst, rtableid);

	/* Entry exists, so forward if necessary */
	if (rt) {
		return (ip6_mdq(m, ifp, rt));
	} else {
		/*
		 * If we don't have a route for packet's origin,
		 * Make a copy of the packet &
		 * send message to routing daemon
		 */

		mrt6stat.mrt6s_no_route++;

		{
			struct mrt6msg *im;

			if ((mifp = (struct mif6 *)ifp->if_mcast6) == NULL)
				return EHOSTUNREACH;

			/*
			 * Make a copy of the header to send to the user
			 * level process
			 */
			mm = m_copym(m, 0, sizeof(struct ip6_hdr), M_NOWAIT);
			if (mm == NULL)
				return ENOBUFS;

			/*
			 * Send message to routing daemon
			 */
			(void)memset(&sin6, 0, sizeof(sin6));
			sin6.sin6_len = sizeof(sin6);
			sin6.sin6_family = AF_INET6;
			sin6.sin6_addr = ip6->ip6_src;

			im = NULL;
			switch (ip6_mrouter_ver) {
			case MRT6_INIT:
				im = mtod(mm, struct mrt6msg *);
				im->im6_msgtype = MRT6MSG_NOCACHE;
				im->im6_mbz = 0;
				im->im6_mif = mifp->m6_mifi;
				break;
			default:
				m_freem(mm);
				return EINVAL;
			}

			if (socket6_send(ip6_mrouter[rtableid], mm,
			    &sin6) < 0) {
				log(LOG_WARNING, "ip6_mforward: ip6_mrouter "
				    "socket queue full\n");
				mrt6stat.mrt6s_upq_sockfull++;
				return ENOBUFS;
			}

			mrt6stat.mrt6s_upcalls++;

			mf6c_add(NULL, &ip6->ip6_src, &ip6->ip6_dst,
			    mifp->m6_mifi, rtableid, M_NOWAIT);
		}

		return 0;
	}
}

void
mf6c_expire_route(struct rtentry *rt, struct rttimer *rtt)
{
	struct mf6c *mf6c = (struct mf6c *)rt->rt_llinfo;
	unsigned int rtableid = rtt->rtt_tableid;
#ifdef MCAST_DEBUG
	char bsrc[INET6_ADDRSTRLEN], bdst[INET6_ADDRSTRLEN];
#endif /* MCAST_DEBUG */

	/* Skip entry being deleted. */
	if (mf6c == NULL)
		return;

	DPRINTF("origin %s group %s interface %d expire %s",
	    inet_ntop(AF_INET6, &satosin6(rt->rt_gateway)->sin6_addr,
	    bsrc, sizeof(bsrc)),
	    inet_ntop(AF_INET6, &satosin6(rt_key(rt))->sin6_addr,
	    bdst, sizeof(bdst)), rt->rt_ifidx,
	    mf6c->mf6c_expire ? "yes" : "no");

	if (mf6c->mf6c_expire == 0) {
		mf6c->mf6c_expire = 1;
		rt_timer_add(rt, mf6c_expire_route, mrouter6q[rtableid],
		    rtableid);
		return;
	}

	rt_timer_remove_all(rt);
	mrt6_mcast6_del(rt, rtableid);
}

/*
 * Packet forwarding routine once entry in the cache is made
 */
int
ip6_mdq(struct mbuf *m, struct ifnet *ifp, struct rtentry *rt)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct mif6 *m6, *mifp = (struct mif6 *)ifp->if_mcast6;
	struct mf6c *mf6c = (struct mf6c *)rt->rt_llinfo;
	struct ifnet *ifn;
	int plen = m->m_pkthdr.len;

	if (mifp == NULL || mf6c == NULL) {
		rtfree(rt);
		return EHOSTUNREACH;
	}

	/*
	 * Don't forward if it didn't arrive from the parent mif
	 * for its origin.
	 */
	if (mifp->m6_mifi != mf6c->mf6c_parent) {
		/* came in the wrong interface */
		mrt6stat.mrt6s_wrong_if++;
		mf6c->mf6c_wrong_if++;
		rtfree(rt);
		return 0;
	}			/* if wrong iif */

	/* If I sourced this packet, it counts as output, else it was input. */
	if (m->m_pkthdr.ph_ifidx == 0) {
		/* XXX: is ph_ifidx really 0 when output?? */
		mifp->m6_pkt_out++;
		mifp->m6_bytes_out += plen;
	} else {
		mifp->m6_pkt_in++;
		mifp->m6_bytes_in += plen;
	}

	/*
	 * For each mif, forward a copy of the packet if there are group
	 * members downstream on the interface.
	 */
	do {
		/* Don't consider non multicast routes. */
		if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
		    (RTF_HOST | RTF_MULTICAST))
			continue;

		mf6c = (struct mf6c *)rt->rt_llinfo;
		if (mf6c == NULL)
			continue;

		mf6c->mf6c_pkt_cnt++;
		mf6c->mf6c_byte_cnt += m->m_pkthdr.len;

		/* Don't let this route expire. */
		mf6c->mf6c_expire = 0;

		if ((ifn = if_get(rt->rt_ifidx)) == NULL)
			continue;

		/* Sanity check: did we configure this? */
		if ((m6 = (struct mif6 *)ifn->if_mcast6) == NULL) {
			if_put(ifn);
			continue;
		}

		/* Don't send in the upstream interface. */
		if (mf6c->mf6c_parent == m6->m6_mifi) {
			if_put(ifn);
			continue;
		}

		/*
		 * check if the outgoing packet is going to break
		 * a scope boundary.
		 */
		if ((mifp->m6_flags & MIFF_REGISTER) == 0 &&
		    (m6->m6_flags & MIFF_REGISTER) == 0 &&
		    (in6_addr2scopeid(ifp->if_index, &ip6->ip6_dst) !=
		    in6_addr2scopeid(ifn->if_index, &ip6->ip6_dst) ||
		    in6_addr2scopeid(ifp->if_index, &ip6->ip6_src) !=
		    in6_addr2scopeid(ifn->if_index, &ip6->ip6_src))) {
			if_put(ifn);
			ip6stat_inc(ip6s_badscope);
			continue;
		}

		m6->m6_pkt_out++;
		m6->m6_bytes_out += plen;

		phyint_send6(ifn, ip6, m);
		if_put(ifn);
	} while ((rt = rtable_iterate(rt)) != NULL);

	return 0;
}

void
phyint_send6(struct ifnet *ifp, struct ip6_hdr *ip6, struct mbuf *m)
{
	struct mbuf *mb_copy;
	struct sockaddr_in6 *dst6, sin6;
	int error = 0;

	NET_ASSERT_LOCKED();

	/*
	 * Make a new reference to the packet; make sure that
	 * the IPv6 header is actually copied, not just referenced,
	 * so that ip6_output() only scribbles on the copy.
	 */
	mb_copy = m_dup_pkt(m, max_linkhdr, M_NOWAIT);
	if (mb_copy == NULL)
		return;
	/* set MCAST flag to the outgoing packet */
	mb_copy->m_flags |= M_MCAST;

	/*
	 * If we sourced the packet, call ip6_output since we may devide
	 * the packet into fragments when the packet is too big for the
	 * outgoing interface.
	 * Otherwise, we can simply send the packet to the interface
	 * sending queue.
	 */
	if (m->m_pkthdr.ph_ifidx == 0) {
		struct ip6_moptions im6o;

		im6o.im6o_ifidx = ifp->if_index;
		/* XXX: ip6_output will override ip6->ip6_hlim */
		im6o.im6o_hlim = ip6->ip6_hlim;
		im6o.im6o_loop = 1;
		error = ip6_output(mb_copy, NULL, NULL, IPV6_FORWARDING, &im6o,
		    NULL);
		return;
	}

	/*
	 * If we belong to the destination multicast group
	 * on the outgoing interface, loop back a copy.
	 */
	dst6 = &sin6;
	memset(&sin6, 0, sizeof(sin6));
	if (in6_hasmulti(&ip6->ip6_dst, ifp)) {
		dst6->sin6_len = sizeof(struct sockaddr_in6);
		dst6->sin6_family = AF_INET6;
		dst6->sin6_addr = ip6->ip6_dst;
		ip6_mloopback(ifp, m, dst6);
	}
	/*
	 * Put the packet into the sending queue of the outgoing interface
	 * if it would fit in the MTU of the interface.
	 */
	if (mb_copy->m_pkthdr.len <= ifp->if_mtu || ifp->if_mtu < IPV6_MMTU) {
		dst6->sin6_len = sizeof(struct sockaddr_in6);
		dst6->sin6_family = AF_INET6;
		dst6->sin6_addr = ip6->ip6_dst;
		error = ifp->if_output(ifp, mb_copy, sin6tosa(dst6), NULL);
	} else {
		if (ip6_mcast_pmtu)
			icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0,
			    ifp->if_mtu);
		else {
			m_freem(mb_copy); /* simply discard the packet */
		}
	}
}

struct ifnet *
mrt6_iflookupbymif(mifi_t mifi, unsigned int rtableid)
{
	struct mif6	*m6;
	struct ifnet	*ifp;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp->if_rdomain != rtableid)
			continue;
		if ((m6 = (struct mif6 *)ifp->if_mcast6) == NULL)
			continue;
		if (m6->m6_mifi != mifi)
			continue;

		return ifp;
	}

	return NULL;
}

struct rtentry *
mf6c_find(struct ifnet *ifp, struct in6_addr *origin, struct in6_addr *group,
    unsigned int rtableid)
{
	struct rtentry *rt;
	struct sockaddr_in6 msin6;

	memset(&msin6, 0, sizeof(msin6));
	msin6.sin6_family = AF_INET6;
	msin6.sin6_len = sizeof(msin6);
	msin6.sin6_addr = *group;

	rt = rtalloc(sin6tosa(&msin6), 0, rtableid);
	do {
		if (!rtisvalid(rt)) {
			rtfree(rt);
			return NULL;
		}
		if (ISSET(rt->rt_flags, RTF_HOST | RTF_MULTICAST) !=
		    (RTF_HOST | RTF_MULTICAST))
			continue;
		/* Return first occurrence if interface is not specified. */
		if (ifp == NULL)
			return rt;
		if (rt->rt_ifidx == ifp->if_index)
			return rt;
	} while ((rt = rtable_iterate(rt)) != NULL);

	return NULL;
}

struct rtentry *
mrt6_mcast6_add(struct ifnet *ifp, struct sockaddr *origin,
    struct sockaddr *group)
{
	struct ifaddr *ifa;
	int rv;
	unsigned int rtableid = ifp->if_rdomain;

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family == AF_INET6)
			break;
	}
	if (ifa == NULL) {
		DPRINTF("ifa == NULL");
		return NULL;
	}

	rv = rt_ifa_add(ifa, RTF_HOST | RTF_MULTICAST, group);
	if (rv != 0) {
		DPRINTF("rt_ifa_add failed %d", rv);
		return NULL;
	}

	return mf6c_find(ifp, NULL, &satosin6(group)->sin6_addr, rtableid);
}

int
mrt6_mcast6_del(struct rtentry *rt, unsigned int rtableid)
{
	struct ifnet *ifp;
	int rv;

	free(rt->rt_llinfo, M_MRTABLE, sizeof(struct mf6c));
	rt->rt_llinfo = NULL;

	if ((ifp = if_get(rt->rt_ifidx)) == NULL) {
		DPRINTF("if_get(%d) failed", rt->rt_ifidx);
		rtfree(rt);
		return ENOENT;
	}

	rv = rtdeletemsg(rt, ifp, rtableid);
	if_put(ifp);
	if (rv != 0) {
		DPRINTF("rtdeletemsg failed %d", rv);
		rtfree(rt);
		return rv;
	}

	return 0;
}
@


1.112
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1111 1
a1111 4
	mb_copy = m_copym(m, 0, M_COPYALL, M_NOWAIT);
	if (mb_copy &&
	    (M_READONLY(mb_copy) || mb_copy->m_len < sizeof(struct ip6_hdr)))
		mb_copy = m_pullup(mb_copy, sizeof(struct ip6_hdr));
@


1.111
log
@Make the IPv6 multicast routing code use the OpenBSD routing table
instead of implementing its own. This makes the IPv6 multicast routing
code look more like the IPv4 version.

ok bluhm@@, mpi@@
@
text
@d511 1
a511 1
	splsoftassert(IPL_SOFTNET);
d564 1
a564 1
	splsoftassert(IPL_SOFTNET);
d621 1
a621 1
	splsoftassert(IPL_SOFTNET);
d805 1
a805 1
	splsoftassert(IPL_SOFTNET);
d819 1
a819 1
	splsoftassert(IPL_SOFTNET);
d863 1
a863 1
	splsoftassert(IPL_SOFTNET);
d1104 1
a1104 1
	splsoftassert(IPL_SOFTNET);
@


1.110
log
@Added initial IPv6 multicast routing support for multiple rdomains:

* don't share mifs (multicast interface) between rdomains
* allow multiple routing sockets connected at the same time if they are
  in different rdomains.

ok bluhm@@
@
text
@a95 2
#include <crypto/siphash.h>

d109 16
a124 1
int ip6_mdq(struct mbuf *, struct ifnet *, struct mf6c *);
d132 1
d140 1
a140 35
struct mf6c	*mf6ctable[MF6CTBLSIZ];
SIPHASH_KEY	mf6chashkey;
u_char		n6expire[MF6CTBLSIZ];

void expire_upcalls6(void *);
#define		EXPIRE_TIMEOUT	(hz / 4)	/* 4x / second */
#define		UPCALL_EXPIRE	6		/* number of timeouts */

/*
 * Hash function for a source, group entry
 */
u_int32_t _mf6chash(const struct in6_addr *, const struct in6_addr *);
#define MF6CHASH(a, g) _mf6chash(&(a), &(g))

/*
 * Find a route for a given origin IPv6 address and Multicast group address.
 * Quality of service parameter to be added in the future!!!
 */
#define MF6CFIND(o, g, rt) do { \
	struct mf6c *_rt = mf6ctable[MF6CHASH(o,g)]; \
	rt = NULL; \
	mrt6stat.mrt6s_mfc_lookups++; \
	while (_rt) { \
		if (IN6_ARE_ADDR_EQUAL(&_rt->mf6c_origin.sin6_addr, &(o)) && \
		    IN6_ARE_ADDR_EQUAL(&_rt->mf6c_mcastgrp.sin6_addr, &(g)) && \
		    (_rt->mf6c_stall == NULL)) { \
			rt = _rt; \
			break; \
		} \
		_rt = _rt->mf6c_next; \
	} \
	if (rt == NULL) { \
		mrt6stat.mrt6s_mfc_misses++; \
	} \
} while (0)
d167 1
a167 1
int get_sg6_cnt(struct sioc_sg_req6 *);
d172 9
a180 5
int add_m6fc(struct mf6cctl *);
int del_m6fc(struct mf6cctl *);
struct ifnet *if_lookupbymif(mifi_t, unsigned int);

static struct timeout expire_upcalls6_ch;
d211 1
a211 1
		return (add_m6fc(mtod(m, struct mf6cctl *)));
d215 1
a215 1
		return (del_m6fc(mtod(m,  struct mf6cctl *)));
d248 2
a249 1
		return (get_sg6_cnt((struct sioc_sg_req6 *)data));
d262 1
a262 1
get_sg6_cnt(struct sioc_sg_req6 *req)
d264 2
a265 1
	struct mf6c *rt;
d267 3
a269 8
	MF6CFIND(req->src.sin6_addr, req->grp.sin6_addr, rt);
	if (rt != NULL) {
		req->pktcnt = rt->mf6c_pkt_cnt;
		req->bytecnt = rt->mf6c_byte_cnt;
		req->wrong_if = rt->mf6c_wrong_if;
	} else
		return (ESRCH);
#if 0
d271 13
a283 1
#endif
d297 1
a297 1
	if ((ifp = if_lookupbymif(req->mifi, rtableid)) == NULL)
d354 73
d430 17
a446 7
	caddr_t where = oldp;
	size_t needed, given;
	u_long i;
	u_int64_t waitings;
	struct mf6c *m;
	struct mf6cinfo minfo;
	struct rtdetq *r;
d448 4
a451 27
	given = *oldlenp;
	needed = 0;
	for (i = 0; i < MF6CTBLSIZ; ++i) {
		m = mf6ctable[i];
		while (m) {
			minfo.mf6c_origin = m->mf6c_origin;
			minfo.mf6c_mcastgrp = m->mf6c_mcastgrp;
			minfo.mf6c_parent = m->mf6c_parent;
			minfo.mf6c_ifset = m->mf6c_ifset;
			minfo.mf6c_pkt_cnt = m->mf6c_pkt_cnt;
			minfo.mf6c_byte_cnt = m->mf6c_byte_cnt;

			for (waitings = 0, r = m->mf6c_stall; r; r = r->next)
				waitings++;
			minfo.mf6c_stall_cnt = waitings;

			needed += sizeof(minfo);
			if (where && needed <= given) {
				int error;

				error = copyout(&minfo, where, sizeof(minfo));
				if (error)
					return (error);
				where += sizeof(minfo);
			}
			m = m->mf6c_next;
		}
a452 6
	if (where) {
		*oldlenp = needed;
		if (given < needed)
			return (ENOMEM);
	} else
		*oldlenp = (11 * needed) / 10;
d454 4
a457 1
	return (0);
d481 4
d486 7
a492 3
	bzero((caddr_t)mf6ctable, sizeof(mf6ctable));
	arc4random_buf(&mf6chashkey, sizeof(mf6chashkey));
	bzero((caddr_t)n6expire, sizeof(n6expire));
d494 3
a496 2
	timeout_set_proc(&expire_upcalls6_ch, expire_upcalls6, NULL);
	timeout_add(&expire_upcalls6_ch, EXPIRE_TIMEOUT);
a507 1
	int i;
a508 2
	struct mf6c *rt;
	struct rtdetq *rte;
d513 3
d524 1
a524 25
	timeout_del(&expire_upcalls6_ch);

	/*
	 * Free all multicast forwarding cache entries.
	 */
	for (i = 0; i < MF6CTBLSIZ; i++) {
		rt = mf6ctable[i];
		while (rt) {
			struct mf6c *frt;

			for (rte = rt->mf6c_stall; rte != NULL; ) {
				struct rtdetq *n = rte->next;

				m_freem(rte->m);
				free(rte, M_MRTABLE, sizeof(*rte));
				rte = n;
			}
			frt = rt;
			rt = rt->mf6c_next;
			free(frt, M_MRTABLE, sizeof(*frt));
		}
	}

	bzero((caddr_t)mf6ctable, sizeof(mf6ctable));

d527 1
a535 3
	struct rtdetq *rte;
	struct mf6c *mfc;
	int i;
a548 15

	/*
	 * Clear rte->ifp of cache entries received on ifp.
	 */
	for (i = 0; i < MF6CTBLSIZ; i++) {
		if (n6expire[i] == 0)
			continue;

		for (mfc = mf6ctable[i]; mfc != NULL; mfc = mfc->mf6c_next) {
			for (rte = mfc->mf6c_stall; rte != NULL; rte = rte->next) {
				if (rte->ifp == ifp)
					rte->ifp = NULL;
			}
		}
	}
d569 1
a569 1
	if (if_lookupbymif(mifcp->mif6c_mifi, rtableid) != NULL)
d625 1
a625 1
	if ((ifp = if_lookupbymif(*mifip, inp->inp_rtableid)) == NULL)
a632 3
/*
 * Add an mfc entry
 */
d634 34
a667 1
add_m6fc(struct mf6cctl *mfccp)
d669 26
a694 5
	struct mf6c *rt;
	u_long hash;
	struct rtdetq *rte;
	u_short nstl;
	char orig[INET6_ADDRSTRLEN], mcast[INET6_ADDRSTRLEN];
d696 8
a703 1
	splsoftassert(IPL_SOFTNET);
d705 4
a708 2
	MF6CFIND(mfccp->mf6cc_origin.sin6_addr,
		 mfccp->mf6cc_mcastgrp.sin6_addr, rt);
d710 4
a713 6
	/* If an entry already exists, just update the fields */
	if (rt) {
		rt->mf6c_parent = mfccp->mf6cc_parent;
		rt->mf6c_ifset = mfccp->mf6cc_ifset;
		return 0;
	}
d715 7
a721 23
	/*
	 * Find the entry for which the upcall was made and update
	 */
	hash = MF6CHASH(mfccp->mf6cc_origin.sin6_addr,
			mfccp->mf6cc_mcastgrp.sin6_addr);
	for (rt = mf6ctable[hash], nstl = 0; rt; rt = rt->mf6c_next) {
		if (IN6_ARE_ADDR_EQUAL(&rt->mf6c_origin.sin6_addr,
				       &mfccp->mf6cc_origin.sin6_addr) &&
		    IN6_ARE_ADDR_EQUAL(&rt->mf6c_mcastgrp.sin6_addr,
				       &mfccp->mf6cc_mcastgrp.sin6_addr) &&
		    (rt->mf6c_stall != NULL)) {

			if (nstl++) {
				log(LOG_ERR,
				    "add_m6fc: %s o %s g %s p %x dbx %p\n",
				    "multiple kernel entries",
				    inet_ntop(AF_INET6,
					&mfccp->mf6cc_origin.sin6_addr,
					orig, sizeof(orig)),
				    inet_ntop(AF_INET6,
					&mfccp->mf6cc_mcastgrp.sin6_addr,
					mcast, sizeof(mcast)),
				    mfccp->mf6cc_parent, rt->mf6c_stall);
d724 4
a727 21
			rt->mf6c_origin     = mfccp->mf6cc_origin;
			rt->mf6c_mcastgrp   = mfccp->mf6cc_mcastgrp;
			rt->mf6c_parent     = mfccp->mf6cc_parent;
			rt->mf6c_ifset	    = mfccp->mf6cc_ifset;
			/* initialize pkt counters per src-grp */
			rt->mf6c_pkt_cnt    = 0;
			rt->mf6c_byte_cnt   = 0;
			rt->mf6c_wrong_if   = 0;

			rt->mf6c_expire = 0;	/* Don't clean this guy up */
			n6expire[hash]--;

			/* free packets Qed at the end of this entry */
			for (rte = rt->mf6c_stall; rte != NULL; ) {
				struct rtdetq *n = rte->next;
				if (rte->ifp) {
					ip6_mdq(rte->m, rte->ifp, rt);
				}
				m_freem(rte->m);
				free(rte, M_MRTABLE, sizeof(*rte));
				rte = n;
d729 9
a737 1
			rt->mf6c_stall = NULL;
d739 15
d756 37
a792 5
	/*
	 * It is possible that an entry is being inserted without an upcall
	 */
	if (nstl == 0) {
		for (rt = mf6ctable[hash]; rt; rt = rt->mf6c_next) {
d794 1
a794 24
			if (IN6_ARE_ADDR_EQUAL(&rt->mf6c_origin.sin6_addr,
					       &mfccp->mf6cc_origin.sin6_addr)&&
			    IN6_ARE_ADDR_EQUAL(&rt->mf6c_mcastgrp.sin6_addr,
					       &mfccp->mf6cc_mcastgrp.sin6_addr)) {

				rt->mf6c_origin     = mfccp->mf6cc_origin;
				rt->mf6c_mcastgrp   = mfccp->mf6cc_mcastgrp;
				rt->mf6c_parent     = mfccp->mf6cc_parent;
				rt->mf6c_ifset	    = mfccp->mf6cc_ifset;
				/* initialize pkt counters per src-grp */
				rt->mf6c_pkt_cnt    = 0;
				rt->mf6c_byte_cnt   = 0;
				rt->mf6c_wrong_if   = 0;

				if (rt->mf6c_expire)
					n6expire[hash]--;
				rt->mf6c_expire	   = 0;
			}
		}
		if (rt == NULL) {
			/* no upcall, so make a new entry */
			rt = malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL)
				return ENOBUFS;
a795 17
			/* insert new entry at head of hash chain */
			rt->mf6c_origin     = mfccp->mf6cc_origin;
			rt->mf6c_mcastgrp   = mfccp->mf6cc_mcastgrp;
			rt->mf6c_parent     = mfccp->mf6cc_parent;
			rt->mf6c_ifset	    = mfccp->mf6cc_ifset;
			/* initialize pkt counters per src-grp */
			rt->mf6c_pkt_cnt    = 0;
			rt->mf6c_byte_cnt   = 0;
			rt->mf6c_wrong_if   = 0;
			rt->mf6c_expire     = 0;
			rt->mf6c_stall = NULL;

			/* link into table */
			rt->mf6c_next  = mf6ctable[hash];
			mf6ctable[hash] = rt;
		}
	}
a798 3
/*
 * Delete an mfc entry
 */
d800 1
a800 1
del_m6fc(struct mf6cctl *mfccp)
d802 2
a803 5
	struct sockaddr_in6	origin;
	struct sockaddr_in6	mcastgrp;
	struct mf6c		*rt;
	struct mf6c		**nptr;
	u_long			hash;
d807 13
a819 12
	origin = mfccp->mf6cc_origin;
	mcastgrp = mfccp->mf6cc_mcastgrp;
	hash = MF6CHASH(origin.sin6_addr, mcastgrp.sin6_addr);

	nptr = &mf6ctable[hash];
	while ((rt = *nptr) != NULL) {
		if (IN6_ARE_ADDR_EQUAL(&origin.sin6_addr,
				       &rt->mf6c_origin.sin6_addr) &&
		    IN6_ARE_ADDR_EQUAL(&mcastgrp.sin6_addr,
				       &rt->mf6c_mcastgrp.sin6_addr) &&
		    rt->mf6c_stall == NULL)
			break;
d821 5
a825 1
		nptr = &rt->mf6c_next;
a826 5
	if (rt == NULL)
		return EADDRNOTAVAIL;

	*nptr = rt->mf6c_next;
	free(rt, M_MRTABLE, sizeof(*rt));
d857 1
a857 1
	struct mf6c *rt;
d900 1
a900 1
	MF6CFIND(ip6->ip6_src, ip6->ip6_dst, rt);
a911 4
		struct mbuf *mb0;
		struct rtdetq *rte;
		u_long hash;

d914 1
a914 32
		/*
		 * Allocate mbufs early so that we don't do extra work if we
		 * are just going to fail anyway.
		 */
		rte = malloc(sizeof(*rte), M_MRTABLE, M_NOWAIT);
		if (rte == NULL)
			return ENOBUFS;
		mb0 = m_copym(m, 0, M_COPYALL, M_NOWAIT);
		/*
		 * Pullup packet header if needed before storing it,
		 * as other references may modify it in the meantime.
		 */
		if (mb0 &&
		    (M_READONLY(mb0) || mb0->m_len < sizeof(struct ip6_hdr)))
			mb0 = m_pullup(mb0, sizeof(struct ip6_hdr));
		if (mb0 == NULL) {
			free(rte, M_MRTABLE, sizeof(*rte));
			return ENOBUFS;
		}

		/* is there an upcall waiting for this packet? */
		hash = MF6CHASH(ip6->ip6_src, ip6->ip6_dst);
		for (rt = mf6ctable[hash]; rt; rt = rt->mf6c_next) {
			if (IN6_ARE_ADDR_EQUAL(&ip6->ip6_src,
					       &rt->mf6c_origin.sin6_addr) &&
			    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
					       &rt->mf6c_mcastgrp.sin6_addr) &&
			    (rt->mf6c_stall != NULL))
				break;
		}

		if (rt == NULL) {
d917 1
a917 3
			if ((mifp = (struct mif6 *)ifp->if_mcast6) == NULL) {
				free(rte, M_MRTABLE, sizeof(*rte));
				m_freem(mb0);
a918 1
			}
a919 7
			/* no upcall, so make a new entry */
			rt = malloc(sizeof(*rt), M_MRTABLE, M_NOWAIT);
			if (rt == NULL) {
				free(rte, M_MRTABLE, sizeof(*rte));
				m_freem(mb0);
				return ENOBUFS;
			}
d924 2
a925 6
			mm = m_copym(mb0, 0, sizeof(struct ip6_hdr), M_NOWAIT);

			if (mm == NULL) {
				free(rte, M_MRTABLE, sizeof(*rte));
				m_freem(mb0);
				free(rt, M_MRTABLE, sizeof(*rt));
a926 1
			}
d945 1
a945 3
				free(rte, M_MRTABLE, sizeof(*rte));
				m_freem(mb0);
				free(rt, M_MRTABLE, sizeof(*rt));
a953 3
				free(rte, M_MRTABLE, sizeof(*rte));
				m_freem(mb0);
				free(rt, M_MRTABLE, sizeof(*rt));
d959 2
a960 32
			/* insert new entry at head of hash chain */
			bzero(rt, sizeof(*rt));
			rt->mf6c_origin.sin6_family = AF_INET6;
			rt->mf6c_origin.sin6_len = sizeof(struct sockaddr_in6);
			rt->mf6c_origin.sin6_addr = ip6->ip6_src;
			rt->mf6c_mcastgrp.sin6_family = AF_INET6;
			rt->mf6c_mcastgrp.sin6_len = sizeof(struct sockaddr_in6);
			rt->mf6c_mcastgrp.sin6_addr = ip6->ip6_dst;
			rt->mf6c_expire = UPCALL_EXPIRE;
			n6expire[hash]++;
			rt->mf6c_parent = MF6C_INCOMPLETE_PARENT;

			/* link into table */
			rt->mf6c_next  = mf6ctable[hash];
			mf6ctable[hash] = rt;
			/* Add this entry to the end of the queue */
			rt->mf6c_stall = rte;
		} else {
			/* determine if q has overflowed */
			struct rtdetq **p;
			int npkts = 0;

			for (p = &rt->mf6c_stall; *p != NULL; p = &(*p)->next)
				if (++npkts > MAX_UPQ6) {
					mrt6stat.mrt6s_upq_ovflw++;
					free(rte, M_MRTABLE, sizeof(*rte));
					m_freem(mb0);
					return 0;
				}

			/* Add this entry to the end of the queue */
			*p = rte;
a962 4
		rte->next = NULL;
		rte->m = mb0;
		rte->ifp = ifp;

a966 4
/*
 * Clean up cache entries if upcalls are not serviced
 * Call from the Slow Timeout mechanism, every half second.
 */
d968 1
a968 1
expire_upcalls6(void *unused)
d970 22
a991 38
	struct rtdetq *rte;
	struct mf6c *mfc, **nptr;
	int i, s;

	NET_LOCK(s);
	for (i = 0; i < MF6CTBLSIZ; i++) {
		if (n6expire[i] == 0)
			continue;
		nptr = &mf6ctable[i];
		while ((mfc = *nptr) != NULL) {
			rte = mfc->mf6c_stall;
			/*
			 * Skip real cache entries
			 * Make sure it wasn't marked to not expire (shouldn't happen)
			 * If it expires now
			 */
			if (rte != NULL &&
			    mfc->mf6c_expire != 0 &&
			    --mfc->mf6c_expire == 0) {
				/*
				 * drop all the packets
				 * free the mbuf with the pkt, if, timing info
				 */
				do {
					struct rtdetq *n = rte->next;
					m_freem(rte->m);
					free(rte, M_MRTABLE, sizeof(*rte));
					rte = n;
				} while (rte != NULL);
				mrt6stat.mrt6s_cache_cleanups++;
				n6expire[i]--;

				*nptr = mfc->mf6c_next;
				free(mfc, M_MRTABLE, sizeof(*mfc));
			} else {
				nptr = &mfc->mf6c_next;
			}
		}
d993 3
a995 2
	timeout_add(&expire_upcalls6_ch, EXPIRE_TIMEOUT);
	NET_UNLOCK(s);
d1002 1
a1002 1
ip6_mdq(struct mbuf *m, struct ifnet *ifp, struct mf6c *rt)
d1006 1
a1007 1
	mifi_t mifi;
a1008 1
	unsigned int rtableid = ifp->if_rdomain;
d1010 4
a1013 2
	if (mifp == NULL)
		return -1;
d1019 1
a1019 1
	if (mifp->m6_mifi != rt->mf6c_parent) {
d1022 2
a1023 1
		rt->mf6c_wrong_if++;
a1035 2
	rt->mf6c_pkt_cnt++;
	rt->mf6c_byte_cnt += plen;
d1041 24
a1064 6
	for (mifi = 0; mifi < MAXMIFS; mifi++) {
		if (IF_ISSET(mifi, &rt->mf6c_ifset)) {
			if ((ifn = if_lookupbymif(mifi, rtableid)) == NULL)
				continue;
			if ((m6 = (struct mif6 *)ifn->if_mcast6) == NULL)
				continue;
d1066 5
a1070 13
			/*
			 * check if the outgoing packet is going to break
			 * a scope boundary.
			 */
			if ((mifp->m6_flags & MIFF_REGISTER) == 0 &&
			    (m6->m6_flags & MIFF_REGISTER) == 0 &&
			    (in6_addr2scopeid(ifp->if_index, &ip6->ip6_dst) !=
			     in6_addr2scopeid(ifn->if_index, &ip6->ip6_dst) ||
			     in6_addr2scopeid(ifp->if_index, &ip6->ip6_src) !=
			     in6_addr2scopeid(ifn->if_index, &ip6->ip6_src))) {
				ip6stat_inc(ip6s_badscope);
				continue;
			}
d1072 13
a1084 3
			m6->m6_pkt_out++;
			m6->m6_bytes_out += plen;
			phyint_send6(ifn, ip6, m);
d1086 8
a1093 1
	}
a1169 12
u_int32_t
_mf6chash(const struct in6_addr *a, const struct in6_addr *g)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &mf6chashkey);
	SipHash24_Update(&ctx, a, sizeof(*a));
	SipHash24_Update(&ctx, g, sizeof(*g));

	return (MF6CHASHMOD(SipHash24_End(&ctx)));
}

d1171 1
a1171 1
if_lookupbymif(mifi_t mifi, unsigned int rtableid)
d1188 83
@


1.109
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d100 1
d104 1
d109 1
d112 1
a112 1
void phyint_send6(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d118 1
a118 1
struct socket  *ip6_mrouter = NULL;
a128 1
struct mif6	mif6table[MAXMIFS];
a134 12
 * 'Interfaces' associated with decapsulator (so we can tell
 * packets that went through it from ones that get reflected
 * by a broken gateway).  These interfaces are never linked into
 * the system ifnet list & no routes point to them.  I.e., packets
 * can't be sent this way.  They only exist as a placeholder for
 * multicast source verification.
 */
static mifi_t nummifs = 0;
static mifi_t reg_mif_num = (mifi_t)-1;
unsigned int reg_mif_idx;

/*
d188 1
a188 1
int get_mif6_cnt(struct sioc_mif_req6 *);
d190 2
a191 2
int add_m6if(struct mif6ctl *);
int del_m6if(mifi_t *);
d194 1
d204 3
a206 1
	if (cmd != MRT6_INIT && so != ip6_mrouter)
d215 1
a215 1
		return (ip6_mrouter_done());
d219 1
a219 1
		return (add_m6if(mtod(m, struct mif6ctl *)));
d223 1
a223 1
		return (del_m6if(mtod(m, mifi_t *)));
d243 3
a245 1
	if (so != ip6_mrouter)
d258 1
a258 1
mrt6_ioctl(u_long cmd, caddr_t data)
d260 1
d266 2
a267 1
		return (get_mif6_cnt((struct sioc_mif_req6 *)data));
d299 1
a299 1
get_mif6_cnt(struct sioc_mif_req6 *req)
d301 2
a302 1
	mifi_t mifi = req->mifi;
d304 1
a304 1
	if (mifi >= nummifs)
d307 5
a311 4
	req->icount = mif6table[mifi].m6_pkt_in;
	req->ocount = mif6table[mifi].m6_pkt_out;
	req->ibytes = mif6table[mifi].m6_bytes_in;
	req->obytes = mif6table[mifi].m6_bytes_out;
d319 1
a322 1
	mifi_t mifi;
d327 2
a328 3
	for (mifi = 0; mifi < nummifs; mifi++) {
		mifp = &mif6table[mifi];
		if (mifp->m6_ifp == NULL)
d331 1
a331 1
		minfo.m6_mifi = mifi;
d334 1
a334 1
		minfo.m6_ifindex = mifp->m6_ifp->if_index;
d416 3
d426 1
a426 1
	if (ip6_mrouter != NULL)
d429 1
a429 1
	ip6_mrouter = so;
d446 1
a446 1
ip6_mrouter_done(void)
d448 1
a448 1
	mifi_t mifi;
a450 1
	struct in6_ifreq ifr;
d453 1
d457 3
a459 6
	/*
	 * For each phyint in use, disable promiscuous reception of all IPv6
	 * multicasts.
	 */
	for (mifi = 0; mifi < nummifs; mifi++) {
		if (mif6table[mifi].m6_ifp == NULL)
d462 1
a462 16
		if (!(mif6table[mifi].m6_flags & MIFF_REGISTER)) {
			memset(&ifr, 0, sizeof(ifr));
			ifr.ifr_addr.sin6_family = AF_INET6;
			ifr.ifr_addr.sin6_addr= in6addr_any;
			ifp = mif6table[mifi].m6_ifp;
			(*ifp->if_ioctl)(ifp, SIOCDELMULTI,
					 (caddr_t)&ifr);
		} else {
			/* Reset register interface */
			if (reg_mif_num != (mifi_t)-1) {
				if_detach(ifp);
				free(ifp, M_DEVBUF, sizeof(*ifp));
				reg_mif_num = (mifi_t)-1;
				reg_mif_idx = 0;
			}
		}
a463 2
	bzero((caddr_t)mif6table, sizeof(mif6table));
	nummifs = 0;
d490 1
a490 1
	ip6_mrouter = NULL;
d499 1
a501 1
	mifi_t mifi;
d503 4
d508 8
a515 6
	/*
	 * Delete a mif which points to ifp.
	 */
	for (mifi = 0; mifi < nummifs; mifi++)
		if (mif6table[mifi].m6_ifp == ifp)
			del_m6if(&mifi);
d537 1
a537 1
add_m6if(struct mif6ctl *mifcp)
d539 1
d544 1
d550 2
a551 2
	mifp = mif6table + mifcp->mif6c_mifi;
	if (mifp->m6_ifp)
d580 3
a583 1
	mifp->m6_ifp       = ifp;
a587 9
	/* initialize per mif pkt counters */
	mifp->m6_pkt_in    = 0;
	mifp->m6_pkt_out   = 0;
	mifp->m6_bytes_in  = 0;
	mifp->m6_bytes_out = 0;

	/* Adjust nummifs up if the mifi is higher than nummifs */
	if (nummifs <= mifcp->mif6c_mifi)
		nummifs = mifcp->mif6c_mifi + 1;
d598 1
a598 1
del_m6if(mifi_t *mifip)
d600 1
a600 2
	struct mif6 *mifp = mif6table + *mifip;
	mifi_t mifi;
a601 1
	struct in6_ifreq ifr;
d605 1
a605 1
	if (*mifip >= nummifs)
d607 1
a607 1
	if (mifp->m6_ifp == NULL)
d610 1
a610 27
	ifp = mifp->m6_ifp;

	if (!(mifp->m6_flags & MIFF_REGISTER)) {
		/*
		 * XXX: what if there is yet IPv4 multicast daemon
		 *      using the interface?
		 */
		memset(&ifr, 0, sizeof(ifr));
		ifr.ifr_addr.sin6_family = AF_INET6;
		ifr.ifr_addr.sin6_addr = in6addr_any;
		(*ifp->if_ioctl)(ifp, SIOCDELMULTI, (caddr_t)&ifr);
	} else {
		if (reg_mif_num != (mifi_t)-1) {
			if_detach(ifp);
			free(ifp, M_DEVBUF, sizeof(*ifp));
			reg_mif_num = (mifi_t)-1;
			reg_mif_idx = 0;
		}
	}

	bzero((caddr_t)mifp, sizeof (*mifp));

	/* Adjust nummifs down */
	for (mifi = nummifs; mifi > 0; mifi--)
		if (mif6table[mifi - 1].m6_ifp)
			break;
	nummifs = mifi;
a807 1
	mifi_t mifi;
d809 1
d900 6
d940 1
d949 2
a950 13

			for (mifp = mif6table, mifi = 0;
			     mifi < nummifs && mifp->m6_ifp != ifp;
			     mifp++, mifi++)
				;

			switch (ip6_mrouter_ver) {
			case MRT6_INIT:
				im->im6_mif = mifi;
				break;
			}

			if (socket6_send(ip6_mrouter, mm, &sin6) < 0) {
d1061 2
a1063 1
	struct mif6 *mifp;
d1065 4
d1074 1
a1074 2
	mifi = rt->mf6c_parent;
	if ((mifi >= nummifs) || (mif6table[mifi].m6_ifp != ifp)) {
d1084 2
a1085 2
		mif6table[mifi].m6_pkt_out++;
		mif6table[mifi].m6_bytes_out += plen;
d1087 2
a1088 2
		mif6table[mifi].m6_pkt_in++;
		mif6table[mifi].m6_bytes_in += plen;
d1097 1
a1097 1
	for (mifp = mif6table, mifi = 0; mifi < nummifs; mifp++, mifi++) {
d1099 3
a1101 1
			if (mif6table[mifi].m6_ifp == NULL)
d1108 2
a1109 3
			if ((mif6table[rt->mf6c_parent].m6_flags &
			     MIFF_REGISTER) == 0 &&
			    (mif6table[mifi].m6_flags & MIFF_REGISTER) == 0 &&
d1111 1
a1111 2
			     in6_addr2scopeid(mif6table[mifi].m6_ifp->if_index,
					      &ip6->ip6_dst) ||
d1113 1
a1113 2
			     in6_addr2scopeid(mif6table[mifi].m6_ifp->if_index,
					      &ip6->ip6_src))) {
d1118 3
a1120 3
			mifp->m6_pkt_out++;
			mifp->m6_bytes_out += plen;
			    phyint_send6(ip6, mifp, m);
d1127 1
a1127 1
phyint_send6(struct ip6_hdr *ip6, struct mif6 *mifp, struct mbuf *m)
a1129 1
	struct ifnet *ifp = mifp->m6_ifp;
d1209 20
@


1.108
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d876 1
a876 1
		ip6stat.ip6s_cantforward++;
d1161 1
a1161 1
				ip6stat.ip6s_badscope++;
@


1.107
log
@Kill various splsoftnet().

ok rzalamena@@, visa@@
@
text
@d248 1
a248 1
ip6_mrouter_get(int cmd, struct socket *so, struct mbuf **mp)
a251 2

	*mp = m_get(M_WAIT, MT_SOOPTS);
@


1.106
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@a284 1
	int s;
a285 1
	s = splsoftnet();
a286 1
	splx(s);
d437 1
a437 1
	timeout_set(&expire_upcalls6_ch, expire_upcalls6, NULL);
a454 1
	int s;
d456 1
a456 1
	s = splsoftnet();
a513 2
	splx(s);

d557 3
a559 1
	int error, s;
a577 2
		s = splsoftnet();

a586 1
		splx(s);
a592 2
	s = splsoftnet();

a603 1
	splx(s);
d624 2
a625 1
	int s;
a633 1
	s = splsoftnet();
a659 2
	splx(s);

d674 2
a675 1
	int s;
a681 1
		s = splsoftnet();
a683 1
		splx(s);
a689 2
	s = splsoftnet();

d766 1
a766 2
			if (rt == NULL) {
				splx(s);
a767 1
			}
a785 1
	splx(s);
d800 2
a801 1
	int s;
a806 2
	s = splsoftnet();

d818 1
a818 2
	if (rt == NULL) {
		splx(s);
a819 1
	}
a823 2
	splx(s);

a855 1
	int s;
d859 2
a895 1
	s = splsoftnet();
a899 1
		splx(s);
d919 1
a919 2
		if (rte == NULL) {
			splx(s);
a920 1
		}
a930 1
			splx(s);
a952 1
				splx(s);
a964 1
				splx(s);
a986 1
				splx(s);
a1008 1
				splx(s);
a1040 1
					splx(s);
a1050 1
		splx(s);
d1065 1
a1065 4
	int i;
	int s;

	s = splsoftnet();
d1067 1
a1101 2
	splx(s);
	timeout_set(&expire_upcalls6_ch, expire_upcalls6, NULL);
d1103 1
d1181 1
a1181 1
	int s, error = 0;
d1183 1
a1183 1
	s = splsoftnet();
d1194 1
a1194 2
	if (mb_copy == NULL) {
		splx(s);
a1195 1
	}
a1214 1
		splx(s);
a1246 2

	splx(s);
@


1.105
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d80 1
a80 1
 * MROUTING Revision: 3.5.1.2 + PIM-SMv2 (pimd) Support
a107 10
#ifdef PIM
#include <netinet/pim.h>
#include <netinet6/pim6_var.h>

int set_pim6(int *);
int get_pim6(struct mbuf *);
int socket6_send(struct socket *, struct mbuf *, struct sockaddr_in6 *);
int register_send(struct ip6_hdr *, struct mif6 *, struct mbuf *);
#endif

d117 1
a117 1
int		ip6_mrtproto = IPPROTO_PIM;    /* for netstat only */
a143 5
#ifdef PIM
struct pim6stat pim6stat;
static int pim6;
#endif

a238 6
#ifdef PIM
	case MRT6_PIM:
		if (m == NULL || m->m_len < sizeof(int))
			return (EINVAL);
		return (set_pim6(mtod(m, int *)));
#endif
a255 4
#ifdef PIM
	case MRT6_PIM:
		return get_pim6(*mp);
#endif
a416 28
#ifdef PIM
/*
 * Get PIM processiong global
 */
int
get_pim6(struct mbuf *m)
{
	int *i;

	i = mtod(m, int *);

	*i = pim6;

	return 0;
}

int
set_pim6(int *i)
{
	if ((*i != 1) && (*i != 0))
		return EINVAL;

	pim6 = *i;

	return 0;
}
#endif

a439 4
#ifdef PIM
	pim6 = 0;/* used for stubbing out/in pim stuff */
#endif

a489 4
#ifdef PIM
	pim6 = 0; /* used to stub out/in pim specific code */
#endif

a570 21
#ifdef PIM
	if (mifcp->mif6c_flags & MIFF_REGISTER) {
		if (reg_mif_num == (mifi_t)-1) {
			ifp = malloc(sizeof(*ifp), M_DEVBUF, M_NOWAIT|M_ZERO);
			if (ifp == NULL)
				return (ENOMEM);
			snprintf(ifp->if_xname, sizeof(ifp->if_xname),
			    "register_mif");
			ifp->if_flags |= IFF_LOOPBACK;
			if_attach(ifp);
			if_alloc_sadl(ifp);

			reg_mif_num = mifcp->mif6c_mifi;
			reg_mif_idx = ifp->if_index;
			mifcp->mif6c_pifi = ifp->if_index;
		}

		ifp = if_get(reg_mif_idx);
		KASSERT(ifp != NULL);
	} else
#endif
a1161 67
#ifdef PIM
		/*
		 * If we are doing PIM processing, and we are forwarding
		 * packets on this interface, send a message to the
		 * routing daemon.
		 */
		/* have to make sure this is a valid mif */
		if (mifi < nummifs && mif6table[mifi].m6_ifp) {
			mifi_t iif;

			if (pim6 && (m->m_flags & M_LOOP) == 0) {
				/*
				 * Check the M_LOOP flag to avoid an
				 * unnecessary PIM assert.
				 * XXX: M_LOOP is an ad-hoc hack...
				 */
				struct sockaddr_in6 sin6;

				struct mbuf *mm;
				struct mrt6msg *im;

				mm = m_copym(m, 0, sizeof(struct ip6_hdr),
				    M_NOWAIT);
				if (mm &&
				    (M_READONLY(mm) ||
				     mm->m_len < sizeof(struct ip6_hdr)))
					mm = m_pullup(mm, sizeof(struct ip6_hdr));
				if (mm == NULL)
					return ENOBUFS;

				im = NULL;
				switch (ip6_mrouter_ver) {
				case MRT6_INIT:
					im = mtod(mm, struct mrt6msg *);
					im->im6_msgtype = MRT6MSG_WRONGMIF;
					im->im6_mbz = 0;
					break;
				default:
					m_freem(mm);
					return EINVAL;
				}

				for (mifp = mif6table, iif = 0;
				     iif < nummifs && mifp &&
					     mifp->m6_ifp != ifp;
				     mifp++, iif++)
					;

				(void)memset(&sin6, 0, sizeof(sin6));
				sin6.sin6_len = sizeof(sin6);
				sin6.sin6_family = AF_INET6;
				switch (ip6_mrouter_ver) {
				case MRT6_INIT:
					im->im6_mif = iif;
					sin6.sin6_addr = im->im6_src;
					break;
				}

				mrt6stat.mrt6s_upcalls++;

				if (socket6_send(ip6_mrouter, mm, &sin6) < 0) {
					++mrt6stat.mrt6s_upq_sockfull;
					return ENOBUFS;
				}
			}
		}
#endif /* PIM */
a1188 2
			 * XXX For packets through PIM register tunnel
			 * interface, we believe a routing daemon.
a1204 5
#ifdef PIM
			if (mifp->m6_flags & MIFF_REGISTER)
			    register_send(ip6, mifp, m);
			else
#endif
a1288 240

#ifdef PIM
int
register_send(struct ip6_hdr *ip6, struct mif6 *mif, struct mbuf *m)
{
	struct mbuf *mm;
	int i, len = m->m_pkthdr.len;
	struct sockaddr_in6 sin6;
	struct mrt6msg *im6;

	++pim6stat.pim6s_snd_registers;

	/* Make a copy of the packet to send to the user level process */
	MGETHDR(mm, M_DONTWAIT, MT_HEADER);
	if (mm == NULL)
		return ENOBUFS;
	mm->m_data += max_linkhdr;
	mm->m_len = sizeof(struct ip6_hdr);

	if ((mm->m_next = m_copym(m, 0, M_COPYALL, M_NOWAIT)) == NULL) {
		m_freem(mm);
		return ENOBUFS;
	}
	i = MHLEN - M_LEADINGSPACE(mm);
	if (i > len)
		i = len;
	mm = m_pullup(mm, i);
	if (mm == NULL)
		return ENOBUFS;
/* TODO: check it! */
	mm->m_pkthdr.len = len + sizeof(struct ip6_hdr);

	/*
	 * Send message to routing daemon
	 */
	(void)memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_len = sizeof(sin6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = ip6->ip6_src;

	im6 = mtod(mm, struct mrt6msg *);
	im6->im6_msgtype      = MRT6MSG_WHOLEPKT;
	im6->im6_mbz          = 0;

	im6->im6_mif = mif - mif6table;

	/* iif info is not given for reg. encap.n */
	mrt6stat.mrt6s_upcalls++;

	if (socket6_send(ip6_mrouter, mm, &sin6) < 0) {
		++mrt6stat.mrt6s_upq_sockfull;
		return ENOBUFS;
	}
	return 0;
}

/*
 * PIM sparse mode hook
 * Receives the pim control messages, and passes them up to the listening
 * socket, using rip6_input.
 * The only message processed is the REGISTER pim message; the pim header
 * is stripped off, and the inner packet is passed to register_mforward.
 */
int
pim6_input(struct mbuf **mp, int *offp, int proto)
{
	struct pim *pim; /* pointer to a pim struct */
	struct ip6_hdr *ip6;
	int pimlen;
	struct mbuf *m = *mp;
	int minlen;
	int off = *offp;

	++pim6stat.pim6s_rcv_total;

	ip6 = mtod(m, struct ip6_hdr *);
	pimlen = m->m_pkthdr.len - *offp;

	/*
	 * Validate lengths
	 */
	if (pimlen < PIM_MINLEN) {
		++pim6stat.pim6s_rcv_tooshort;
		m_freem(m);
		return (IPPROTO_DONE);
	}

	/*
	 * if the packet is at least as big as a REGISTER, go ahead
	 * and grab the PIM REGISTER header size, to avoid another
	 * possible m_pullup() later.
	 *
	 * PIM_MINLEN       == pimhdr + u_int32 == 8
	 * PIM6_REG_MINLEN   == pimhdr + reghdr + eip6hdr == 4 + 4 + 40
	 */
	minlen = (pimlen >= PIM6_REG_MINLEN) ? PIM6_REG_MINLEN : PIM_MINLEN;

	/*
	 * Make sure that the IP6 and PIM headers in contiguous memory, and
	 * possibly the PIM REGISTER header
	 */
	IP6_EXTHDR_GET(pim, struct pim *, m, off, minlen);
	if (pim == NULL) {
		pim6stat.pim6s_rcv_tooshort++;
		return IPPROTO_DONE;
	}

	/* PIM version check */
	if (pim->pim_ver != PIM_VERSION) {
		++pim6stat.pim6s_rcv_badversion;
		m_freem(m);
		return (IPPROTO_DONE);
	}

#define PIM6_CHECKSUM
#ifdef PIM6_CHECKSUM
	{
		int cksumlen;

		/*
		 * Validate checksum.
		 * If PIM REGISTER, exclude the data packet
		 */
		if (pim->pim_type == PIM_REGISTER)
			cksumlen = PIM_MINLEN;
		else
			cksumlen = pimlen;

		if (in6_cksum(m, IPPROTO_PIM, off, cksumlen)) {
			++pim6stat.pim6s_rcv_badsum;
			m_freem(m);
			return (IPPROTO_DONE);
		}
	}
#endif /* PIM_CHECKSUM */

	if (pim->pim_type == PIM_REGISTER) {
		/*
		 * since this is a REGISTER, we'll make a copy of the register
		 * headers ip6+pim+u_int32_t+encap_ip6, to be passed up to the
		 * routing daemon.
		 */
		static struct sockaddr_in6 dst = { sizeof(dst), AF_INET6 };

		struct mbuf *mcp;
		struct ip6_hdr *eip6;
		u_int32_t *reghdr;

		++pim6stat.pim6s_rcv_registers;

		if ((reg_mif_num >= nummifs) || (reg_mif_num == (mifi_t) -1)) {
			m_freem(m);
			return (IPPROTO_DONE);
		}

		reghdr = (u_int32_t *)(pim + 1);

		if ((ntohl(*reghdr) & PIM_NULL_REGISTER))
			goto pim6_input_to_daemon;

		/*
		 * Validate length
		 */
		if (pimlen < PIM6_REG_MINLEN) {
			++pim6stat.pim6s_rcv_tooshort;
			++pim6stat.pim6s_rcv_badregisters;
			m_freem(m);
			return (IPPROTO_DONE);
		}

		eip6 = (struct ip6_hdr *) (reghdr + 1);
		/* verify the version number of the inner packet */
		if ((eip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
			++pim6stat.pim6s_rcv_badregisters;
			m_freem(m);
			return (IPPROTO_NONE);
		}

		/* verify the inner packet is destined to a mcast group */
		if (!IN6_IS_ADDR_MULTICAST(&eip6->ip6_dst)) {
			++pim6stat.pim6s_rcv_badregisters;
			m_freem(m);
			return (IPPROTO_DONE);
		}

		/*
		 * make a copy of the whole header to pass to the daemon later.
		 */
		mcp = m_copym(m, 0, off + PIM6_REG_MINLEN, M_NOWAIT);
		if (mcp == NULL) {
			m_freem(m);
			return (IPPROTO_DONE);
		}

		/*
		 * forward the inner ip6 packet; point m_data at the inner ip6.
		 */
		m_adj(m, off + PIM_MINLEN);
		if_input_local(mif6table[reg_mif_num].m6_ifp, m,
		    dst.sin6_family);

		/* prepare the register head to send to the mrouting daemon */
		m = mcp;
	}

	/*
	 * Pass the PIM message up to the daemon; if it is a register message
	 * pass the 'head' only up to the daemon. This includes the
	 * encapsulator ip6 header, pim header, register header and the
	 * encapsulated ip6 header.
	 */
  pim6_input_to_daemon:
	rip6_input(&m, offp, proto);
	return (IPPROTO_DONE);
}

/*
 * Sysctl for pim6 variables.
 */
int
pim6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case PIM6CTL_STATS:
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &pim6stat, sizeof(pim6stat)));

	default:
		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
#endif /* PIM */
@


1.104
log
@Do not use a single global struct route_in6 to cache route lookups.

This is a little step towards deprecating 'struct route{,_in6}'.

ok jca@@, claudio@@
@
text
@d983 1
a983 1
		if (ip6_log_time + ip6_log_interval < time_second) {
d986 1
a986 1
			ip6_log_time = time_second;
@


1.103
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1372 4
a1375 4
	int error = 0;
	int s = splsoftnet();
	static struct route_in6 ro;
	struct sockaddr_in6 *dst6;
d1407 1
a1407 1
		error = ip6_output(mb_copy, NULL, &ro, IPV6_FORWARDING, &im6o,
d1417 2
a1418 1
	dst6 = &ro.ro_dst;
d1423 1
a1423 1
		ip6_mloopback(ifp, m, &ro.ro_dst);
d1433 1
a1433 2
		error = ifp->if_output(ifp, mb_copy, sin6tosa(&ro.ro_dst),
		    NULL);
@


1.102
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@a1431 4
		/*
		 * We just call if_output instead of nd6_output here, since
		 * we need no ND for a multicast forwarded packet...right?
		 */
@


1.101
log
@add sizes to some free() calls. ok claudio
@
text
@a1374 1
	struct	in6_multi *in6m;
d1418 1
a1418 2
	IN6_LOOKUP_MULTI(ip6->ip6_dst, ifp, in6m);
	if (in6m != NULL) {
@


1.100
log
@Do not cast malloc(9) results.
@
text
@d565 1
a565 1
				free(rte, M_MRTABLE, 0);
d570 1
a570 1
			free(frt, M_MRTABLE, 0);
d828 1
a828 1
				free(rte, M_MRTABLE, 0);
d925 1
a925 1
	free(rt, M_MRTABLE, 0);
d1038 1
a1038 1
			free(rte, M_MRTABLE, 0);
d1060 1
a1060 1
				free(rte, M_MRTABLE, 0);
d1072 1
a1072 1
				free(rte, M_MRTABLE, 0);
d1074 1
a1074 1
				free(rt, M_MRTABLE, 0);
d1095 1
a1095 1
				free(rte, M_MRTABLE, 0);
d1097 1
a1097 1
				free(rt, M_MRTABLE, 0);
d1118 1
a1118 1
				free(rte, M_MRTABLE, 0);
d1120 1
a1120 1
				free(rt, M_MRTABLE, 0);
d1152 1
a1152 1
					free(rte, M_MRTABLE, 0);
d1206 1
a1206 1
					free(rte, M_MRTABLE, 0);
d1213 1
a1213 1
				free(mfc, M_MRTABLE, 0);
@


1.99
log
@Do not try to guess if there's still an IPv4 multicast routing daemon
using an interface based on the value of ``ip_mrouter''.

Calling SIOCDELMULTI on an interface is correct even if such daemon is
running because the Ethernet layer refcounts currently joined multicast
groups.
@
text
@d862 1
a862 2
			rt = (struct mf6c *)malloc(sizeof(*rt), M_MRTABLE,
						  M_NOWAIT);
d1024 1
a1024 2
		rte = (struct rtdetq *)malloc(sizeof(*rte), M_MRTABLE,
					      M_NOWAIT);
d1058 1
a1058 2
			rt = (struct mf6c *)malloc(sizeof(*rt), M_MRTABLE,
						  M_NOWAIT);
@


1.98
log
@Unbreak adding a MIFF_REGISTER interface.

Such interface is created on the fly so if_get() could return NULL because
mif6c_pifi doesn't mean what you think in this case.
@
text
@d136 1
a136 1
struct mif6 mif6table[MAXMIFS];
a141 2
extern struct socket *ip_mrouter;

d523 18
a540 26
	/*
	 * If there is still IPv4 multicast routing daemon,
	 * we remain interfaces to receive all muliticasted packets.
	 * XXX: there may be an interface in which the IPv4 multicast
	 * daemon is not interested...
	 */
	if (!ip_mrouter) {
		for (mifi = 0; mifi < nummifs; mifi++) {
			if (mif6table[mifi].m6_ifp == NULL)
				continue;

			if (!(mif6table[mifi].m6_flags & MIFF_REGISTER)) {
				memset(&ifr, 0, sizeof(ifr));
				ifr.ifr_addr.sin6_family = AF_INET6;
				ifr.ifr_addr.sin6_addr= in6addr_any;
				ifp = mif6table[mifi].m6_ifp;
				(*ifp->if_ioctl)(ifp, SIOCDELMULTI,
						 (caddr_t)&ifr);
			} else {
				/* Reset register interface */
				if (reg_mif_num != (mifi_t)-1) {
					if_detach(ifp);
					free(ifp, M_DEVBUF, sizeof(*ifp));
					reg_mif_num = (mifi_t)-1;
					reg_mif_idx = 0;
				}
@


1.97
log
@unidef MRT6DEBUG
@
text
@a640 3
	ifp = if_get(mifcp->mif6c_pifi);
	if (!ifp)
		return ENXIO;
a643 2
		if_put(ifp);

d664 4
@


1.96
log
@More PIM love.  Reduce differences with ip_mroute.c and dynamically
allocate the register ifp such that if_get() works.
@
text
@a136 9
#ifdef MRT6DEBUG
u_int		mrt6debug = 0;	  /* debug level	*/
#define		DEBUG_MFC	0x02
#define		DEBUG_FORWARD	0x04
#define		DEBUG_EXPIRE	0x08
#define		DEBUG_XMIT	0x10
#define         DEBUG_REG       0x20
#define         DEBUG_PIM       0x40
#endif
a170 1

a314 1

a477 7
#ifdef MRT6DEBUG
	if (mrt6debug)
		log(LOG_DEBUG,
		    "ip6_mrouter_init: so_type = %d, pr_protocol = %d\n",
		    so->so_type, so->so_proto->pr_protocol);
#endif

a501 5
#ifdef MRT6DEBUG
	if (mrt6debug)
		log(LOG_DEBUG, "ip6_mrouter_init\n");
#endif

a590 5
#ifdef MRT6DEBUG
	if (mrt6debug)
		log(LOG_DEBUG, "ip6_mrouter_done\n");
#endif

a711 8
#ifdef MRT6DEBUG
	if (mrt6debug)
		log(LOG_DEBUG,
		    "add_mif #%d, phyint %s\n",
		    mifcp->mif6c_mifi,
		    ifp->if_xname);
#endif

a764 5
#ifdef MRT6DEBUG
	if (mrt6debug)
		log(LOG_DEBUG, "del_m6if %d, nummifs %d\n", *mifip, nummifs);
#endif

a785 13
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_MFC) {
			log(LOG_DEBUG,"add_m6fc update o %s g %s p %x\n",
			    inet_ntop(AF_INET6,
				&mfccp->mf6cc_origin.sin6_addr,
				orig, sizeof(orig)),
			    inet_ntop(AF_INET6,
				&mfccp->mf6cc_mcastgrp.sin6_addr,
				mcast, sizeof(mcast)),
			    mfccp->mf6cc_parent);
		}
#endif

a786 1

d807 1
a807 1
			if (nstl++)
d818 1
a818 13

#ifdef MRT6DEBUG
			if (mrt6debug & DEBUG_MFC)
				log(LOG_DEBUG,
				    "add_m6fc o %s g %s p %x dbg %x\n",
				    inet_ntop(AF_INET6,
					&mfccp->mf6cc_origin.sin6_addr,
					orig, sizeof(orig)),
				    inet_ntop(AF_INET6,
					&mfccp->mf6cc_mcastgrp.sin6_addr,
					mcast, sizeof(mcast)),
				    mfccp->mf6cc_parent, rt->mf6c_stall);
#endif
a849 14
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_MFC)
			log(LOG_DEBUG,
			    "add_m6fc no upcall h %d o %s g %s p %x\n",
			    hash,
			    inet_ntop(AF_INET6,
				&mfccp->mf6cc_origin.sin6_addr,
				orig, sizeof(orig)),
			    inet_ntop(AF_INET6,
				&mfccp->mf6cc_mcastgrp.sin6_addr,
				mcast, sizeof(mcast)),
			    mfccp->mf6cc_parent);
#endif

a917 10
#ifdef MRT6DEBUG
	if (mrt6debug & DEBUG_MFC) {
		char orig[INET6_ADDRSTRLEN], mcast[INET6_ADDRSTRLEN];

		inet_ntop(AF_INET6, &origin.sin6_addr, orig, sizeof(orig));
		inet_ntop(AF_INET6, &mcastgrp.sin6_addr, mcast, sizeof(mcast));
		log(LOG_DEBUG,"del_m6fc orig %s mcastgrp %s\n", orig, mcast);
	}
#endif

a966 1

a975 9
	char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

	inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src));
	inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst));
#ifdef MRT6DEBUG
	if (mrt6debug & DEBUG_FORWARD)
		log(LOG_DEBUG, "ip6_mforward: src %s, dst %s, ifindex %d\n",
		    src, dst, ifp->if_index);
#endif
d996 2
d999 4
a1002 2
			log(LOG_DEBUG,
			    "cannot forward "
d1004 1
a1004 3
			    src, dst,
			    ip6->ip6_nxt,
			    m->m_pkthdr.ph_ifidx);
a1030 5
#ifdef MRT6DEBUG
		if (mrt6debug & (DEBUG_FORWARD | DEBUG_MFC))
			log(LOG_DEBUG, "ip6_mforward: no rte s %s g %s\n",
			    src, dst);
#endif
a1115 5
#ifdef MRT6DEBUG
			if (mrt6debug & DEBUG_FORWARD)
				log(LOG_DEBUG,
				    "getting the iif info in the kernel\n");
#endif
a1212 13
#ifdef MRT6DEBUG
				char orig[INET6_ADDRSTRLEN];
				char mcast[INET6_ADDRSTRLEN];

				if (mrt6debug & DEBUG_EXPIRE)
					log(LOG_DEBUG, "expire_upcalls6: expiring (%s %s)\n",
					    inet_ntop(AF_INET6,
						&mfc->mf6c_origin.sin6_addr,
						orig, sizeof(orig)),
					    inet_ntop(AF_INET6,
						&mfc->mf6c_mcastgrp.sin6_addr,
						mcast, sizeof(mcast)));
#endif
a1255 8
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_FORWARD)
			log(LOG_DEBUG,
			    "wrong if: ifid %d mifi %d mififid %x\n",
			    ifp->if_index, mifi,
			    mif6table[mifi].m6_ifp ?
			    mif6table[mifi].m6_ifp->if_index : -1);
#endif
a1318 4
#ifdef MRT6DEBUG
					if (mrt6debug)
						log(LOG_WARNING, "mdq, ip6_mrouter socket queue full\n");
#endif
d1321 2
a1322 2
				}	/* if socket Q full */
			}		/* if PIM */
a1423 6

#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_XMIT)
			log(LOG_DEBUG, "phyint_send6 on mif %d err %d\n",
			    mifp - mif6table, error);
#endif
a1453 5
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_XMIT)
			log(LOG_DEBUG, "phyint_send6 on mif %d err %d\n",
			    mifp - mif6table, error);
#endif
a1458 14
#ifdef MRT6DEBUG
			char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

			if (mrt6debug & DEBUG_XMIT)
				log(LOG_DEBUG,
				    "phyint_send6: packet too big on %s o %s g %s"
				    " size %d(discarded)\n",
				    ifp->if_xname,
				    inet_ntop(AF_INET6, &ip6->ip6_src,
					src, sizeof(src)),
				    inet_ntop(AF_INET6, &ip6->ip6_dst,
					dst, sizeof(dst)),
				    mb_copy->m_pkthdr.len);
#endif /* MRT6DEBUG */
a1474 9
#ifdef MRT6DEBUG
	char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

	inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src));
	inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst));
	if (mrt6debug)
		log(LOG_DEBUG, "** IPv6 register_send **\n src %s dst %s\n",
		    src, dst);
#endif
a1514 5
#ifdef MRT6DEBUG
		if (mrt6debug)
			log(LOG_WARNING,
			    "register_send: ip6_mrouter socket queue full\n");
#endif
a1547 4
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_PIM)
			log(LOG_DEBUG,"pim6_input: PIM packet too short\n");
#endif
a1574 5
#ifdef MRT6DEBUG
		log(LOG_ERR,
		    "pim6_input: incorrect version %d, expecting %d\n",
		    pim->pim_ver, PIM_VERSION);
#endif
a1594 5
#ifdef MRT6DEBUG
			if (mrt6debug & DEBUG_PIM)
				log(LOG_DEBUG,
				    "pim6_input: invalid checksum\n");
#endif
a1611 3
#ifdef MRT6DEBUG
		char asrc[INET6_ADDRSTRLEN], adst[INET6_ADDRSTRLEN];
#endif
a1615 6
#ifdef MRT6DEBUG
			if (mrt6debug & DEBUG_PIM)
				log(LOG_DEBUG,
				    "pim6_input: register mif not set: %d\n",
				    reg_mif_num);
#endif
a1630 8
#ifdef MRT6DEBUG
			log(LOG_ERR,
			    "pim6_input: register packet size too "
			    "small %d from %s\n",
			    pimlen,
			    inet_ntop(AF_INET6, &ip6->ip6_src,
				asrc, sizeof(asrc)));
#endif
a1635 12
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_PIM)
			log(LOG_DEBUG,
			    "pim6_input[register], eip6: %s -> %s, "
			    "eip6 plen %d\n",
			    inet_ntop(AF_INET6, &eip6->ip6_src,
				asrc, sizeof(asrc)),
			    inet_ntop(AF_INET6, &eip6->ip6_dst,
				adst, sizeof(adst)),
			    ntohs(eip6->ip6_plen));
#endif

a1638 5
#ifdef MRT6DEBUG
			log(LOG_DEBUG, "pim6_input: invalid IP version (%d) "
			    "of the inner packet\n",
			    (eip6->ip6_vfc & IPV6_VERSION));
#endif
a1645 8
#ifdef MRT6DEBUG
			if (mrt6debug & DEBUG_PIM)
				log(LOG_DEBUG,
				    "pim6_input: inner packet of register "
				    "is not multicast %s\n",
				    inet_ntop(AF_INET6, &eip6->ip6_dst,
					adst, sizeof(adst)));
#endif
a1654 5
#ifdef MRT6DEBUG
			log(LOG_ERR,
			    "pim6_input: pim register: "
			    "could not copy register head\n");
#endif
a1662 13
#ifdef MRT6DEBUG
		if (mrt6debug & DEBUG_PIM) {
			log(LOG_DEBUG,
			    "pim6_input: forwarding decapsulated register: "
			    "src %s, dst %s, mif %d\n",
			    inet_ntop(AF_INET6, &eip6->ip6_src,
				asrc, sizeof(asrc)),
			    inet_ntop(AF_INET6, &eip6->ip6_dst,
				adst, sizeof(adst)),
			    reg_mif_num);
		}
#endif

@


1.95
log
@Sync headers and get rid of #ifdef MROUTING.
@
text
@a110 4
#endif

int ip6_mdq(struct mbuf *, struct ifnet *, struct mf6c *);
void phyint_send6(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d116 4
a160 7
struct ifnet multicast_register_if;

#define ENCAP_HOPS 64

/*
 * Private variables.
 */
d163 1
d165 1
d168 1
d266 1
d271 1
d289 1
d292 1
d455 1
d481 1
d513 1
d515 1
d556 4
a559 2
			if (mif6table[mifi].m6_ifp &&
			    !(mif6table[mifi].m6_flags & MIFF_REGISTER)) {
d566 8
d580 1
d582 1
a608 5
	/*
	 * Reset de-encapsulation cache
	 */
	reg_mif_num = -1;

d673 1
d675 2
d678 9
a686 5
			strlcpy(multicast_register_if.if_xname,
			    "register_mif",
			    sizeof multicast_register_if.if_xname); /* XXX */
			multicast_register_if.if_flags |= IFF_LOOPBACK;
			multicast_register_if.if_index = mifcp->mif6c_mifi;
d688 2
d692 5
a696 5
		if_put(ifp);
		ifp = if_ref(&multicast_register_if);

	} /* if REGISTER */
	else {
d770 2
a772 1

a777 2
		ifp = mifp->m6_ifp;

d782 7
d1367 1
a1367 1
	mifi_t mifi, iif;
a1370 10
/*
 * Macro to send packet on mif.
 */
#define MC6_SEND(ip6, mifp, m) do {				\
		if ((mifp)->m6_flags & MIFF_REGISTER)		\
		    register_send((ip6), (mifp), (m));		\
		else						\
		    phyint_send6((ip6), (mifp), (m));		\
} while (0)

d1388 1
d1395 3
a1397 1
		if (mifi < nummifs && mif6table[mifi].m6_ifp)
d1457 2
d1478 1
a1478 1
	for (mifp = mif6table, mifi = 0; mifi < nummifs; mifp++, mifi++)
d1504 6
a1509 1
			MC6_SEND(ip6, mifp, m);
d1511 1
d1625 1
a1692 2

#ifdef PIM
@


1.94
log
@Fix PIM build.
@
text
@a89 1
#include <sys/sockio.h>
a90 2
#include <sys/errno.h>
#include <sys/time.h>
a101 1
#include <netinet/icmp6.h>
d104 1
a150 1
#ifdef MROUTING
a151 1
#endif
a543 1
#ifdef MROUTING
d550 1
a550 3
	if (!ip_mrouter)
#endif
	{
a562 4
#ifdef notyet
	bzero((caddr_t)qtable, sizeof(qtable));
	bzero((caddr_t)tbftable, sizeof(tbftable));
#endif
a651 3
#ifdef notyet
	struct tbf *m_tbf = tbftable + mifcp->mif6c_mifi;
#endif
a764 4
#ifdef notyet
	bzero((caddr_t)qtable[*mifip], sizeof(qtable[*mifip]));
	bzero((caddr_t)mifp->m6_tbf, sizeof(*(mifp->m6_tbf)));
#endif
@


1.93
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@a105 1

d110 3
d114 1
a114 1
#include <netinet6/nd6.h>
d1904 1
a1904 1
		    dst->sin6_family);
@


1.92
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@a1514 1
	u_long linkmtu;
d1574 1
a1574 2
	linkmtu = IN6_LINKMTU(ifp);
	if (mb_copy->m_pkthdr.len <= linkmtu || linkmtu < IPV6_MMTU) {
d1591 2
a1592 1
			icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0, linkmtu);
@


1.91
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1584 2
a1585 1
		error = if_output(ifp, mb_copy, sin6tosa(&ro.ro_dst), NULL);
@


1.90
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1584 1
a1584 2
		error = (*ifp->if_output)(ifp, mb_copy,
		    sin6tosa(&ro.ro_dst), NULL);
@


1.89
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1902 2
a1903 2
		looutput(mif6table[reg_mif_num].m6_ifp, m,
		    sin6tosa(&dst), NULL);
@


1.88
log
@More complicated if_put dance. Special handling for multicast_register_if
which is probably not even needed here but who knows for sure.
OK dlg@@
@
text
@d1548 1
a1548 1
		    NULL, NULL);
@


1.87
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d685 2
a686 1
		ifp = &multicast_register_if;
d691 2
a692 1
		if ((ifp->if_flags & IFF_MULTICAST) == 0)
d694 1
d708 2
a709 1
		if (error)
d711 1
d740 2
@


1.86
log
@rename mbuf ** parameter from m to mp, to match other similar code
@
text
@d560 1
d699 1
d765 1
@


1.85
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d286 1
a286 1
ip6_mrouter_get(int cmd, struct socket *so, struct mbuf **m)
d291 1
a291 1
	*m = m_get(M_WAIT, MT_SOOPTS);
d295 1
a295 1
		return get_pim6(*m);
@


1.84
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1478 2
a1479 2
			    (in6_addr2scopeid(ifp, &ip6->ip6_dst) !=
			     in6_addr2scopeid(mif6table[mifi].m6_ifp,
d1481 2
a1482 2
			     in6_addr2scopeid(ifp, &ip6->ip6_src) !=
			     in6_addr2scopeid(mif6table[mifi].m6_ifp,
@


1.83
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1127 1
a1127 1
		mb0 = m_copy(m, 0, M_COPYALL);
d1168 1
a1168 1
			mm = m_copy(mb0, 0, sizeof(struct ip6_hdr));
d1397 2
a1398 1
				mm = m_copy(m, 0, sizeof(struct ip6_hdr));
d1512 1
a1512 1
	mb_copy = m_copy(m, 0, M_COPYALL);
d1632 1
a1632 1
	if ((mm->m_next = m_copy(m, 0, M_COPYALL)) == NULL) {
d1864 1
a1864 1
		mcp = m_copy(m, 0, off + PIM6_REG_MINLEN);
@


1.82
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1081 1
a1081 1
			    "from %s to %s nxt %d received on %s\n",
d1084 1
a1084 1
			    m->m_pkthdr.rcvif->if_xname);
d1448 2
a1449 2
	if (m->m_pkthdr.rcvif == NULL) {
		/* XXX: is rcvif really NULL when output?? */
d1529 1
a1529 1
	if (m->m_pkthdr.rcvif == NULL) {
@


1.81
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d131 1
a131 1
#define NO_RTE_FOUND 	0x1
d139 1
a139 1
u_int		mrt6debug = 0;	  /* debug level 	*/
d377 1
a377 1
			continue;	
d390 1
a390 1
		if (where && needed <= given) { 
d437 1
a437 1
			if (where && needed <= given) { 
d913 1
a913 1
	
d941 1
a941 1
	
d953 1
a953 1
	
d969 5
a973 5
	struct sockaddr_in6 	origin;
	struct sockaddr_in6 	mcastgrp;
	struct mf6c 		*rt;
	struct mf6c	 	**nptr;
	u_long 		hash;
d1140 1
a1140 1
	
d1185 1
a1185 1
	
d1375 1
a1375 1
			    mif6table[mifi].m6_ifp->if_index : -1); 
d1404 1
a1404 1
	
d1796 1
a1796 1
	
d1798 1
a1798 1
	
d1819 1
a1819 1
	
d1821 1
a1821 1
#ifdef MRT6DEBUG	
d1844 1
a1844 1
	
d1859 1
a1859 1
	
d1873 1
a1873 1
	
d1893 1
a1893 1
	
@


1.80
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mf6c) and the
multicast interface table (mif6). Will be used by netstat soon.
Looked over by guenther@@
@
text
@a110 1
#include <netinet6/pim6.h>
@


1.79
log
@convert the multicast filter hash to use siphash, like i did for
ip_mroute.c

requested by and ok claudio@@
@
text
@d364 95
@


1.78
log
@Rename some of the functions by adding a 6 so they do not conflict with
the still static functions in ip_mroute.c
OK phessler, henning
@
text
@d99 2
d136 1
d181 2
a182 4
#define MF6CHASH(a, g) MF6CHASHMOD((a).s6_addr32[0] ^ (a).s6_addr32[1] ^ \
				   (a).s6_addr32[2] ^ (a).s6_addr32[3] ^ \
				   (g).s6_addr32[0] ^ (g).s6_addr32[1] ^ \
				   (g).s6_addr32[2] ^ (g).s6_addr32[3])
d417 1
d1839 12
@


1.77
log
@unifdef INET in net code as a precursor to removing the pretend option.
long live the one true internet.
ok henning mikeb
@
text
@d114 1
a114 1
void phyint_send(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d118 1
a118 1
int socket_send(struct socket *, struct mbuf *, struct sockaddr_in6 *);
d146 1
a146 1
void expire_upcalls(void *);
d231 1
a231 1
int get_sg_cnt(struct sioc_sg_req6 *);
d239 1
a239 1
static struct timeout expire_upcalls_ch;
d310 1
a310 1
		return (get_sg_cnt((struct sioc_sg_req6 *)data));
d322 1
a322 1
get_sg_cnt(struct sioc_sg_req6 *req)
d420 2
a421 2
	timeout_set(&expire_upcalls_ch, expire_upcalls, NULL);
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d481 1
a481 1
	timeout_del(&expire_upcalls_ch);
d921 1
a921 1
socket_send(struct socket *s, struct mbuf *mm, struct sockaddr_in6 *src)
d1122 1
a1122 1
			if (socket_send(ip6_mrouter, mm, &sin6) < 0) {
d1184 1
a1184 1
expire_upcalls(void *unused)
d1212 1
a1212 1
					log(LOG_DEBUG, "expire_upcalls: expiring (%s %s)\n",
d1241 2
a1242 2
	timeout_set(&expire_upcalls_ch, expire_upcalls, NULL);
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d1263 1
a1263 1
		    phyint_send((ip6), (mifp), (m));		\
d1339 1
a1339 1
				if (socket_send(ip6_mrouter, mm, &sin6) < 0) {
d1399 1
a1399 1
phyint_send(struct ip6_hdr *ip6, struct mif6 *mifp, struct mbuf *m)
d1445 1
a1445 1
			log(LOG_DEBUG, "phyint_send on mif %d err %d\n",
d1481 1
a1481 1
			log(LOG_DEBUG, "phyint_send on mif %d err %d\n",
d1493 1
a1493 1
				    "phyint_send: packet too big on %s o %s g %s"
d1565 1
a1565 1
	if (socket_send(ip6_mrouter, mm, &sin6) < 0) {
@


1.76
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@a149 1
#ifdef INET
a152 1
#endif
a450 1
#ifdef INET
a458 1
#endif
@


1.75
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1442 2
a1443 2
		im6o.im6o_multicast_hlim = ip6->ip6_hlim;
		im6o.im6o_multicast_loop = 1;
@


1.74
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1440 1
a1440 1
		im6o.im6o_multicast_ifp = ifp;
@


1.73
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d100 1
@


1.72
log
@Keep pim code under #ifdef PIM to be coherent with what's in netinet/.
@
text
@a99 1
#include <net/route.h>
@


1.71
log
@No need for raw_cb.h
@
text
@d1581 2
d1840 1
@


1.70
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@a100 1
#include <net/raw_cb.h>
@


1.69
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d500 1
a500 1
				free(rte, M_MRTABLE);
d505 1
a505 1
			free(frt, M_MRTABLE);
d796 1
a796 1
				free(rte, M_MRTABLE);
d918 1
a918 1
	free(rt, M_MRTABLE);
d1045 1
a1045 1
			free(rte, M_MRTABLE);
d1068 1
a1068 1
				free(rte, M_MRTABLE);
d1080 1
a1080 1
				free(rte, M_MRTABLE);
d1082 1
a1082 1
				free(rt, M_MRTABLE);
d1103 1
a1103 1
				free(rte, M_MRTABLE);
d1105 1
a1105 1
				free(rt, M_MRTABLE);
d1131 1
a1131 1
				free(rte, M_MRTABLE);
d1133 1
a1133 1
				free(rt, M_MRTABLE);
d1165 1
a1165 1
					free(rte, M_MRTABLE);
d1232 1
a1232 1
					free(rte, M_MRTABLE);
d1239 1
a1239 1
				free(mfc, M_MRTABLE);
@


1.68
log
@In ip6_mrouter_set() and ip6_mrouter_get(), change the error number
EACCES to EPERM.  EACCES is meant for file access permissions (as
documented on the errno(2) man page), so EPERM seems more appropriate.

Based on a similar change from FreeBSD via Loganaden Velvindron.
ok bluhm@@
@
text
@d84 1
@


1.67
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d250 1
a250 1
		return (EACCES);
d290 2
a291 1
	if (so != ip6_mrouter) return EACCES;
@


1.66
log
@delete UPCALL_TIMING debug code from a the dark ages
@
text
@d707 1
d716 1
a716 1
		if (mrt6debug & DEBUG_MFC)
d718 6
a723 2
			    ip6_sprintf(&mfccp->mf6cc_origin.sin6_addr),
			    ip6_sprintf(&mfccp->mf6cc_mcastgrp.sin6_addr),
d725 1
d754 6
a759 2
				    ip6_sprintf(&mfccp->mf6cc_origin.sin6_addr),
				    ip6_sprintf(&mfccp->mf6cc_mcastgrp.sin6_addr),
d766 6
a771 2
				    ip6_sprintf(&mfccp->mf6cc_origin.sin6_addr),
				    ip6_sprintf(&mfccp->mf6cc_mcastgrp.sin6_addr),
d810 6
a815 2
			    ip6_sprintf(&mfccp->mf6cc_origin.sin6_addr),
			    ip6_sprintf(&mfccp->mf6cc_mcastgrp.sin6_addr),
d888 7
a894 4
	if (mrt6debug & DEBUG_MFC)
		log(LOG_DEBUG,"del_m6fc orig %s mcastgrp %s\n",
		    ip6_sprintf(&origin.sin6_addr),
		    ip6_sprintf(&mcastgrp.sin6_addr));
d956 1
d958 2
d963 1
a963 2
		    ip6_sprintf(&ip6->ip6_src), ip6_sprintf(&ip6->ip6_dst),
		    ifp->if_index);
d989 1
a989 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
d1021 1
a1021 2
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst));
d1211 3
d1216 6
a1221 2
					    ip6_sprintf(&mfc->mf6c_origin.sin6_addr),
					    ip6_sprintf(&mfc->mf6c_mcastgrp.sin6_addr));
d1492 2
d1499 4
a1502 2
				    ip6_sprintf(&ip6->ip6_src),
				    ip6_sprintf(&ip6->ip6_dst),
d1521 4
d1527 1
a1527 1
		    ip6_sprintf(&ip6->ip6_src), ip6_sprintf(&ip6->ip6_dst));
d1685 3
d1717 3
a1719 1
			    pimlen, ip6_sprintf(&ip6->ip6_src));
d1731 4
a1734 2
			    ip6_sprintf(&eip6->ip6_src),
			    ip6_sprintf(&eip6->ip6_dst),
d1758 2
a1759 1
				    ip6_sprintf(&eip6->ip6_dst));
d1788 4
a1791 2
			    ip6_sprintf(&eip6->ip6_src),
			    ip6_sprintf(&eip6->ip6_dst),
@


1.65
log
@remove GET_TIME() wrapper
@
text
@a232 6
#ifdef UPCALL_TIMING
#define UPCALL_MAX	50
u_long upcall_data[UPCALL_MAX + 1];
static void collate();
#endif /* UPCALL_TIMING */

a252 3
#ifdef MRT6_OINIT
	case MRT6_OINIT:
#endif
a779 3
#ifdef UPCALL_TIMING
				collate(&(rte->t));
#endif /* UPCALL_TIMING */
a851 26
#ifdef UPCALL_TIMING
/*
 * collect delay statistics on the upcalls
 */
static void
collate(struct timeval *t)
{
	u_long d;
	struct timeval tp;
	u_long delta;

	microtime(&tp);

	if (TV_LT(*t, tp))
	{
		TV_DELTA(tp, *t, delta);
	
		d = delta >> 10;
		if (d > UPCALL_MAX)
			d = UPCALL_MAX;
	
		++upcall_data[d];
	}
}
#endif /* UPCALL_TIMING */

a993 6
/*		int i, npkts;*/
#ifdef UPCALL_TIMING
		struct timeval tp;

		microtime(&tp);
#endif /* UPCALL_TIMING */
a1039 3
#ifdef MRT6_OINIT
			struct omrt6msg *oim;
#endif
a1072 3
#ifdef MRT6_OINIT
			oim = NULL;
#endif
a1073 7
#ifdef MRT6_OINIT
			case MRT6_OINIT:
				oim = mtod(mm, struct omrt6msg *);
				oim->im6_msgtype = MRT6MSG_NOCACHE;
				oim->im6_mbz = 0;
				break;
#endif
a1098 5
#ifdef MRT6_OINIT
			case MRT6_OINIT:
				oim->im6_mif = mifi;
				break;
#endif
a1154 4
#ifdef UPCALL_TIMING
		rte->t = tp;
#endif /* UPCALL_TIMING */

a1274 3
#ifdef MRT6_OINIT
				struct omrt6msg *oim;
#endif
a1283 3
#ifdef MRT6_OINIT
				oim = NULL;
#endif
a1285 7
#ifdef MRT6_OINIT
				case MRT6_OINIT:
					oim = mtod(mm, struct omrt6msg *);
					oim->im6_msgtype = MRT6MSG_WRONGMIF;
					oim->im6_mbz = 0;
					break;
#endif
a1305 6
#ifdef MRT6_OINIT
				case MRT6_OINIT:
					oim->im6_mif = iif;
					sin6.sin6_addr = oim->im6_src;
					break;
#endif
@


1.64
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d875 1
a875 1
	GET_TIME(tp);
d1036 1
a1036 1
		GET_TIME(tp);
@


1.63
log
@Fix a possible mbuf leak, from NetBSD via Loganaden Velvindron.

ok claudio@@, henning@@
@
text
@a102 1
#include <netinet/in_var.h>
d105 1
@


1.62
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d506 1
a506 1
				m_free(rte->m);
@


1.61
log
@Fix build with MRT6DEBUG defined.
@
text
@d944 1
a944 3
		if (sbappendaddr(&s->so_rcv,
				 (struct sockaddr *)src,
				 mm, (struct mbuf *)0) != 0) {
d1516 1
a1516 1
	dst6 = (struct sockaddr_in6 *)&ro.ro_dst;
d1522 1
a1522 1
		ip6_mloopback(ifp, m, (struct sockaddr_in6 *)&ro.ro_dst);
d1538 1
a1538 1
		    (struct sockaddr *)&ro.ro_dst, NULL);
d1836 1
a1836 2
			      (struct sockaddr *) &dst,
			      (struct rtentry *) NULL);
@


1.60
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d645 1
a645 1
		    "add_mif #%d, phyint %s%d\n",
d647 1
a647 1
		    ifp->if_name, ifp->if_unit);
@


1.59
log
@no need for a lot of code to include proc.h
@
text
@d1300 1
a1300 3
 * Macro to send packet on mif.  Since RSVP packets don't get counted on
 * input, they shouldn't get counted on output, so statistics keeping is
 * separate.
a1301 1

@


1.58
log
@Introduce if_get() to retrieve an interface descriptor pointer given
an interface index and replace all the redondant checks and accesses
to a global array by a call to this function.

With imputs from and ok bluhm@@, mikeb@@
@
text
@a95 1
#include <sys/proc.h>
@


1.57
log
@ioctl requests are u_long not int, spotted via clang
ok deraadt@@ miod@@
@
text
@d587 1
a587 3
	if (mifcp->mif6c_pifi == 0 || mifcp->mif6c_pifi >= if_indexlim)
		return ENXIO;
	ifp = ifindex2ifnet[mifcp->mif6c_pifi];
@


1.56
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d316 1
a316 1
mrt6_ioctl(int cmd, caddr_t data)
@


1.55
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d96 1
@


1.54
log
@Don't do a double free, sys_getsockopt() will take care of freeing the
mbuf allocated by the subroutines. OK kettenis@@
@
text
@d113 2
a114 2
static int ip6_mdq(struct mbuf *, struct ifnet *, struct mf6c *);
static void phyint_send(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d116 4
a119 6
static int set_pim6(int *);
static int get_pim6(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in6 *);
static int register_send(struct ip6_hdr *, struct mif6 *,
			      struct mbuf *);
d146 1
a146 1
static void	expire_upcalls(void *);
d239 7
a245 7
static int get_sg_cnt(struct sioc_sg_req6 *);
static int get_mif6_cnt(struct sioc_mif_req6 *);
static int ip6_mrouter_init(struct socket *, int, int);
static int add_m6if(struct mif6ctl *);
static int del_m6if(mifi_t *);
static int add_m6fc(struct mf6cctl *);
static int del_m6fc(struct mf6cctl *);
d331 1
a331 1
static int
d357 1
a357 1
static int
d376 1
a376 1
static int
d388 1
a388 1
static int
d402 1
a402 1
static int
d445 1
a445 1
ip6_mrouter_done()
d570 1
a570 1
static int
d658 1
a658 1
static int
d711 1
a711 1
static int
d895 1
a895 1
static int
d942 1
a942 1
static int
d1235 1
a1235 1
static void
d1293 1
a1293 1
static int
d1465 1
a1465 1
static void
d1572 1
a1572 1
static int
@


1.53
log
@Remove _KERNEL goo from kernel files because we're setting _KERNEL correctly.
OK deraadt@@, miod@@
@
text
@a300 2
	struct mbuf *mb;

d303 1
a303 1
	*m = mb = m_get(M_WAIT, MT_SOOPTS);
d307 1
a307 1
		return get_pim6(mb);
a308 1
		m_free(mb);
@


1.52
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@a82 6
#ifndef _KERNEL
# ifdef KERNEL
#  define _KERNEL
# endif
#endif

@


1.51
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1752 1
a1752 2
		int rc;
	
d1853 1
a1853 1
		rc = looutput(mif6table[reg_mif_num].m6_ifp, m,
@


1.50
log
@return with ENOTTY instead of EINVAL for unknown ioctl requests.

ok claudio@@ krw@@ dlg@@
@
text
@d261 1
a261 4
ip6_mrouter_set(cmd, so, m)
	int cmd;
	struct socket *so;
	struct mbuf *m;
d305 1
a305 4
ip6_mrouter_get(cmd, so, m)
	int cmd;
	struct socket *so;
	struct mbuf **m;
d326 1
a326 3
mrt6_ioctl(cmd, data)
	int cmd;
	caddr_t data;
d343 1
a343 2
get_sg_cnt(req)
	struct sioc_sg_req6 *req;
d369 1
a369 2
get_mif6_cnt(req)
	struct sioc_mif_req6 *req;
d388 1
a388 2
get_pim6(m)
	struct mbuf *m;
d400 1
a400 2
set_pim6(i)
	int *i;
d414 1
a414 4
ip6_mrouter_init(so, v, cmd)
	struct socket *so;
	int v;
	int cmd;
d548 1
a548 2
ip6_mrouter_detach(ifp)
	struct ifnet *ifp;
d582 1
a582 2
add_m6if(mifcp)
	struct mif6ctl *mifcp;
d670 1
a670 2
del_m6if(mifip)
	mifi_t *mifip;
d723 1
a723 2
add_m6fc(mfccp)
	struct mf6cctl *mfccp;
d882 1
a882 2
collate(t)
	struct timeval *t;
d907 1
a907 2
del_m6fc(mfccp)
	struct mf6cctl *mfccp;
d954 1
a954 4
socket_send(s, mm, src)
	struct socket *s;
	struct mbuf *mm;
	struct sockaddr_in6 *src;
d980 1
a980 4
ip6_mforward(ip6, ifp, m)
	struct ip6_hdr *ip6;
	struct ifnet *ifp;
	struct mbuf *m;
d1247 1
a1247 2
expire_upcalls(unused)
	void *unused;
d1305 1
a1305 4
ip6_mdq(m, ifp, rt)
	struct mbuf *m;
	struct ifnet *ifp;
	struct mf6c *rt;
d1477 1
a1477 4
phyint_send(ip6, mifp, m)
	struct ip6_hdr *ip6;
	struct mif6 *mifp;
	struct mbuf *m;
d1584 1
a1584 4
register_send(ip6, mif, m)
	struct ip6_hdr *ip6;
	struct mif6 *mif;
	struct mbuf *m;
d1655 1
a1655 3
pim6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
@


1.49
log
@add sysctl entry points into various network layers, in particular to
provide netstat(1) with data it needs;  ok claudio reyk
@
text
@d343 1
a343 1
		return (EINVAL);
@


1.48
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d102 1
d1910 24
@


1.47
log
@introduce sysctl net.inet6.ip6.multicast_mtudisc (for multicast routers).
deraadt ok.  manpage nit by jmc.
@
text
@d1551 2
a1552 2
		error = ip6_output(mb_copy, NULL, &ro,
				   IPV6_FORWARDING, &im6o, NULL);
@


1.46
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@a108 1
#ifdef MULTICAST_PMTUD
a109 1
#endif
d1596 3
a1598 3
#ifdef MULTICAST_PMTUD
		icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0, linkmtu);
#else
d1600 8
a1607 8
		if (mrt6debug & DEBUG_XMIT)
			log(LOG_DEBUG,
			    "phyint_send: packet too big on %s o %s g %s"
			    " size %d(discarded)\n",
			    ifp->if_xname,
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    mb_copy->m_pkthdr.len);
d1609 2
a1610 2
		m_freem(mb_copy); /* simply discard the packet */
#endif
@


1.45
log
@avoid silly static variables that even caused nesting issues,
not to mention reentrancy concerns.

From christos NetBSD

ok deraadt@@
@
text
@d1028 1
a1028 1
	if (ip6->ip6_hlim <= 1 || IN6_IS_ADDR_MC_NODELOCAL(&ip6->ip6_dst) ||
@


1.44
log
@Fix 'netstat -sp pim6'

From Pavlin Radoslavov
@
text
@a594 2
static struct sockaddr_in6 sin6 = { sizeof(sin6), AF_INET6 };

d1015 1
d1157 3
d1387 1
a1387 2
				static struct sockaddr_in6 sin6 =
				{ sizeof(sin6), AF_INET6 };
d1431 3
d1626 1
a1626 1
	static struct sockaddr_in6 sin6 = { sizeof(sin6), AF_INET6 };
d1659 3
@


1.43
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d183 1
a183 1
static struct pim6stat pim6stat;
@


1.42
log
@validate set/getsockopt arg more strictly.  local privileged user could cause
a kernel panic with previous code.  from kame
@
text
@d1043 2
a1044 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
@


1.41
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.40 2003/07/08 10:23:32 itojun Exp $	*/
d250 1
a250 1
static int ip6_mrouter_init(struct socket *, struct mbuf *, int);
d268 1
a268 1
		return EACCES;
d272 1
a272 1
	case MRT6_OINIT:	return ip6_mrouter_init(so, m, cmd);
d274 28
a301 8
	case MRT6_INIT:		return ip6_mrouter_init(so, m, cmd);
	case MRT6_DONE:		return ip6_mrouter_done();
	case MRT6_ADD_MIF:	return add_m6if(mtod(m, struct mif6ctl *));
	case MRT6_DEL_MIF:	return del_m6if(mtod(m, mifi_t *));
	case MRT6_ADD_MFC:	return add_m6fc(mtod(m, struct mf6cctl *));
	case MRT6_DEL_MFC:	return del_m6fc(mtod(m, struct mf6cctl *));
	case MRT6_PIM:		return set_pim6(mtod(m, int *));
	default:		return EOPNOTSUPP;
d427 1
a427 1
ip6_mrouter_init(so, m, cmd)
d429 1
a429 1
	struct mbuf *m;
a431 2
	int *v;

d441 1
a441 4
		return EOPNOTSUPP;

	if (!m || (m->m_len != sizeof(int *)))
		return ENOPROTOOPT;
d443 2
a444 3
	v = mtod(m, int *);
	if (*v != 1)
		return ENOPROTOOPT;
d446 2
a447 1
	if (ip6_mrouter != NULL) return EADDRINUSE;
@


1.40
log
@on interface removal, clear multicast forwarding stuff.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.39 2003/06/24 07:47:54 itojun Exp $	*/
d602 1
a602 1
	if (mifcp->mif6c_pifi == 0 || mifcp->mif6c_pifi > if_index)
d605 2
@


1.39
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.38 2003/06/06 06:57:23 itojun Exp $	*/
d548 32
d803 3
a805 1
				ip6_mdq(rte->m, rte->ifp, rt);
d1350 2
a1351 1
			    mif6table[mifi].m6_ifp->if_index);
@


1.38
log
@don't try to forward multicast packet to mif that went away; kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.37 2003/06/03 06:24:22 itojun Exp $	*/
a965 1
	long time_second = time.tv_sec;
d992 2
a993 2
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
@


1.37
log
@remove unneeded break after return.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.36 2003/06/02 23:28:15 millert Exp $	*/
d1424 3
@


1.36
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.35 2003/05/15 13:52:13 itojun Exp $	*/
a316 1
	int error = 0;
a320 1
		break;		/* for safety */
a322 1
		break;		/* for safety */
a324 1
		break;
a325 1
	return error;
@


1.35
log
@check pim version before checksum.  version check is cheaper.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.34 2003/05/14 17:05:34 itojun Exp $	*/
d51 1
a51 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.34
log
@KNF; sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.33 2003/05/14 14:24:44 itojun Exp $	*/
d1690 12
a1727 12

	/* PIM version check */
	if (pim->pim_ver != PIM_VERSION) {
		++pim6stat.pim6s_rcv_badversion;
#ifdef MRT6DEBUG
		log(LOG_ERR,
		    "pim6_input: incorrect version %d, expecting %d\n",
		    pim->pim_ver, PIM_VERSION);
#endif
		m_freem(m);
		return (IPPROTO_DONE);
	}
@


1.33
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.32 2003/05/07 02:12:09 deraadt Exp $	*/
d1461 3
a1463 3
    struct ip6_hdr *ip6;
    struct mif6 *mifp;
    struct mbuf *m;
@


1.32
log
@use strlcpy; itojun ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.31 2002/11/27 05:10:07 itojun Exp $	*/
a1683 8
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, minlen, IPPROTO_DONE);
	/* adjust pointer */
	ip6 = mtod(m, struct ip6_hdr *);

	/* adjust mbuf to point to the PIM header */
	pim = (struct pim *)((caddr_t)ip6 + off);
#else
a1688 1
#endif
@


1.31
log
@recover original stanford copyright.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.30 2002/11/09 03:12:01 itojun Exp $	*/
d585 3
a587 2
			strcpy(multicast_register_if.if_xname,
			       "register_mif"); /* XXX */
@


1.30
log
@need icmp6.h for MULTICAST_PMTUD case.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.29 2002/09/11 03:15:36 itojun Exp $	*/
d34 39
@


1.29
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.28 2002/07/25 12:43:28 itojun Exp $	*/
d74 3
@


1.28
log
@correct MTU check.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.27 2002/06/29 07:58:30 deraadt Exp $	*/
d283 1
a283 1
		return(get_sg_cnt((struct sioc_sg_req6 *)data));
d286 1
a286 1
		return(get_mif6_cnt((struct sioc_mif_req6 *)data));
d314 1
a314 1
		return(ESRCH);
d1624 1
a1624 1
		return(IPPROTO_DONE);
d1678 1
a1678 1
			return(IPPROTO_DONE);
d1692 1
a1692 1
		return(IPPROTO_DONE);
d1718 1
a1718 1
			return(IPPROTO_DONE);
d1739 1
a1739 1
			return(IPPROTO_DONE);
d1762 1
a1762 1
			return(IPPROTO_NONE);
d1776 1
a1776 1
			return(IPPROTO_DONE);
d1790 1
a1790 1
			return(IPPROTO_DONE);
d1824 1
a1824 1
	return(IPPROTO_DONE);
@


1.27
log
@We know noone called Bill Fenenr
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.26 2002/06/09 14:38:39 itojun Exp $	*/
d1490 1
a1490 1
	if (mb_copy->m_pkthdr.len < linkmtu || linkmtu < IPV6_MMTU) {
@


1.26
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.25 2002/06/08 21:51:08 itojun Exp $	*/
d43 1
a43 1
 * Modified by Bill Fenenr, PARC, April 1994
@


1.25
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.24 2002/06/07 18:18:14 itojun Exp $	*/
d1808 1
a1808 1
 		rc = looutput(mif6table[reg_mif_num].m6_ifp, m,
@


1.24
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.23 2002/06/07 04:13:10 itojun Exp $	*/
d305 1
a305 1
	s = splnet();
d434 1
a434 1
	s = splnet();
d558 1
a558 1
		s = splnet();
d573 1
a573 1
	s = splnet();
d621 1
a621 1
	s = splnet();
d683 1
a683 1
		s = splnet();
d694 1
a694 1
	s = splnet();
d866 1
a866 1
	s = splnet();
d975 1
a975 1
	s = splnet();
d1197 1
a1197 1
	s = splnet();
d1425 1
a1425 1
	int s = splnet();
@


1.23
log
@'fall through' is not a valid LINT keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.22 2002/05/30 04:40:02 itojun Exp $	*/
d1582 1
a1582 1
			    "register_send: ip_mrouter socket queue full\n");
@


1.22
log
@use M_READONLY where possible.  minor cleanup/sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.21 2002/05/29 07:54:59 itojun Exp $	*/
d191 1
a191 1
			      /* fall through */ \
@


1.21
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.20 2002/03/24 20:53:49 itojun Exp $	*/
a81 2
#define M_HASCL(m) ((m)->m_flags & M_EXT)

d96 1
a96 1
struct socket  *ip6_mrouter  = NULL;
d105 1
a105 1
u_char		nexpire[MF6CTBLSIZ];
d405 1
a405 1
	bzero((caddr_t)nexpire, sizeof(nexpire));
d732 1
a732 1
			nexpire[hash]--;
d780 1
a780 1
					nexpire[hash]--;
d1023 1
a1023 1
		    (M_HASCL(mb0) || mb0->m_len < sizeof(struct ip6_hdr)))
d1145 1
a1145 1
			nexpire[hash]++;
d1200 1
a1200 1
		if (nexpire[i] == 0)
d1230 1
a1230 1
				nexpire[i]--;
d1311 1
a1311 1
				    (M_HASCL(mm) ||
d1438 1
a1438 1
	    (M_HASCL(mb_copy) || mb_copy->m_len < sizeof(struct ip6_hdr)))
@


1.20
log
@double m_free() - niklas@@openbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.19 2002/03/14 01:27:12 millert Exp $	*/
d80 1
d1431 1
d1491 2
a1492 1
	if (mb_copy->m_pkthdr.len < ifp->if_mtu || ifp->if_mtu < IPV6_MMTU) {
d1509 1
a1509 1
		icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0, ifp->if_mtu);
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.18 2002/02/10 23:15:05 deraadt Exp $	*/
d1558 1
a1558 2
	if (mm == NULL){
		m_freem(mm);
a1559 1
	}
@


1.18
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.17 2001/12/07 09:16:07 itojun Exp $	*/
d83 2
a84 2
static int ip6_mdq __P((struct mbuf *, struct ifnet *, struct mf6c *));
static void phyint_send __P((struct ip6_hdr *, struct mif6 *, struct mbuf *));
d86 6
a91 6
static int set_pim6 __P((int *));
static int get_pim6 __P((struct mbuf *));
static int socket_send __P((struct socket *, struct mbuf *,
			    struct sockaddr_in6 *));
static int register_send __P((struct ip6_hdr *, struct mif6 *,
			      struct mbuf *));
d118 1
a118 1
static void	expire_upcalls __P((void *));
d211 7
a217 7
static int get_sg_cnt __P((struct sioc_sg_req6 *));
static int get_mif6_cnt __P((struct sioc_mif_req6 *));
static int ip6_mrouter_init __P((struct socket *, struct mbuf *, int));
static int add_m6if __P((struct mif6ctl *));
static int del_m6if __P((mifi_t *));
static int add_m6fc __P((struct mf6cctl *));
static int del_m6fc __P((struct mf6cctl *));
@


1.17
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.16 2001/06/09 06:43:38 angelos Exp $	*/
d1262 1
a1262 1
 * seperate.
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.17 2001/12/07 09:16:07 itojun Exp $	*/
a79 1
#include <netinet6/nd6.h>
d81 1
a81 2
static int ip6_mdq(struct mbuf *, struct ifnet *, struct mf6c *);
static void phyint_send(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d83 9
a91 6
static int set_pim6(int *);
static int get_pim6(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in6 *);
static int register_send(struct ip6_hdr *, struct mif6 *,
			      struct mbuf *);
d97 1
a97 1
struct socket  *ip6_mrouter = NULL;
d106 1
a106 1
u_char		n6expire[MF6CTBLSIZ];
d118 1
a118 1
static void	expire_upcalls(void *);
d192 1
a192 1
			      /* FALLTHROUGH */ \
d211 7
a217 7
static int get_sg_cnt(struct sioc_sg_req6 *);
static int get_mif6_cnt(struct sioc_mif_req6 *);
static int ip6_mrouter_init(struct socket *, struct mbuf *, int);
static int add_m6if(struct mif6ctl *);
static int del_m6if(mifi_t *);
static int add_m6fc(struct mf6cctl *);
static int del_m6fc(struct mf6cctl *);
d306 1
a306 1
	s = splsoftnet();
d406 1
a406 1
	bzero((caddr_t)n6expire, sizeof(n6expire));
d435 1
a435 1
	s = splsoftnet();
d559 1
a559 1
		s = splsoftnet();
d574 1
a574 1
	s = splsoftnet();
d622 1
a622 1
	s = splsoftnet();
d684 1
a684 1
		s = splsoftnet();
d695 1
a695 1
	s = splsoftnet();
d733 1
a733 1
			n6expire[hash]--;
d781 1
a781 1
					n6expire[hash]--;
d867 1
a867 1
	s = splsoftnet();
d976 1
a976 1
	s = splsoftnet();
d1024 1
a1024 1
		    (M_READONLY(mb0) || mb0->m_len < sizeof(struct ip6_hdr)))
d1146 1
a1146 1
			n6expire[hash]++;
d1198 1
a1198 1
	s = splsoftnet();
d1201 1
a1201 1
		if (n6expire[i] == 0)
d1231 1
a1231 1
				n6expire[i]--;
d1262 1
a1262 1
 * separate.
d1312 1
a1312 1
				    (M_READONLY(mm) ||
d1426 1
a1426 1
	int s = splsoftnet();
a1429 1
	u_long linkmtu;
d1438 1
a1438 1
	    (M_READONLY(mb_copy) || mb_copy->m_len < sizeof(struct ip6_hdr)))
d1489 1
a1489 2
	linkmtu = IN6_LINKMTU(ifp);
	if (mb_copy->m_pkthdr.len < linkmtu || linkmtu < IPV6_MMTU) {
d1506 1
a1506 1
		icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0, linkmtu);
d1558 2
a1559 1
	if (mm == NULL)
d1561 1
d1583 1
a1583 1
			    "register_send: ip6_mrouter socket queue full\n");
@


1.17.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.17.2.1 2002/06/11 03:31:37 art Exp $	*/
d43 1
a43 1
 * Modified by Bill Fenner, PARC, April 1994
d283 1
a283 1
		return (get_sg_cnt((struct sioc_sg_req6 *)data));
d286 1
a286 1
		return (get_mif6_cnt((struct sioc_mif_req6 *)data));
d314 1
a314 1
		return (ESRCH);
d1490 1
a1490 1
	if (mb_copy->m_pkthdr.len <= linkmtu || linkmtu < IPV6_MMTU) {
d1624 1
a1624 1
		return (IPPROTO_DONE);
d1678 1
a1678 1
			return (IPPROTO_DONE);
d1692 1
a1692 1
		return (IPPROTO_DONE);
d1718 1
a1718 1
			return (IPPROTO_DONE);
d1739 1
a1739 1
			return (IPPROTO_DONE);
d1762 1
a1762 1
			return (IPPROTO_NONE);
d1776 1
a1776 1
			return (IPPROTO_DONE);
d1790 1
a1790 1
			return (IPPROTO_DONE);
d1808 1
a1808 1
		rc = looutput(mif6table[reg_mif_num].m6_ifp, m,
d1824 1
a1824 1
	return (IPPROTO_DONE);
@


1.17.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a35 39
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ip_mroute.c 8.2 (Berkeley) 11/15/93
 */

/*
a73 3
#ifdef MULTICAST_PMTUD
#include <netinet/icmp6.h>
#endif
d543 2
a544 3
			strlcpy(multicast_register_if.if_xname,
			    "register_mif",
			    sizeof multicast_register_if.if_xname); /* XXX */
d1418 3
a1420 3
	struct ip6_hdr *ip6;
	struct mif6 *mifp;
	struct mbuf *m;
d1641 8
a1653 8

	/* PIM version check */
	if (pim->pim_ver != PIM_VERSION) {
		++pim6stat.pim6s_rcv_badversion;
#ifdef MRT6DEBUG
		log(LOG_ERR,
		    "pim6_input: incorrect version %d, expecting %d\n",
		    pim->pim_ver, PIM_VERSION);
a1654 3
		m_freem(m);
		return (IPPROTO_DONE);
	}
d1682 12
@


1.16
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.15 2001/03/25 09:25:08 itojun Exp $	*/
a146 5

/*
 * one-back cache used by ipip_input to locate a tunnel's mif
 * given a datagram's src ip address.
 */
d756 2
a757 1
			log(LOG_DEBUG,"add_mfc no upcall h %d o %s g %s p %x\n",
@


1.15
log
@missing splx.  sync with kame.
From: csapuntz@@play-doh.stanford.edu (Constantine Sapuntzakis)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.14 2001/03/08 09:01:31 itojun Exp $	*/
a80 2
#include <net/net_osdep.h>

d972 1
a972 1
			    if_name(m->m_pkthdr.rcvif));
d1517 1
a1517 1
			    if_name(ifp),
@


1.14
log
@more missing splx.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.13 2001/03/07 22:50:44 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.43 2001/03/08 08:47:33 itojun Exp $	*/
d1510 1
a1510 2
	}
	else {
a1512 2
		splx(s);
		return;
a1524 2
		splx(s);
		return;
d1527 2
@


1.13
log
@missing splx.  from aaron.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.12 2001/02/16 14:58:12 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.41 2001/03/07 22:47:22 itojun Exp $	*/
d1514 1
d1520 1
a1520 1
			    "phyint_send: packet too big on %s%u o %s g %s"
d1522 1
a1522 1
			    ifp->if_name, ifp->if_unit,
d1528 1
@


1.12
log
@cosmetic/comment sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.11 2001/02/16 08:48:06 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.40 2001/02/16 08:37:03 itojun Exp $	*/
d1446 2
a1447 1
	if (mb_copy == NULL)
d1449 1
@


1.11
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.10 2001/02/16 08:12:29 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.39 2001/02/10 02:13:13 itojun Exp $	*/
@


1.10
log
@fix multicast API for sizeof(long) != 4.  (IF_SET and family will not
overrun, it will compute values too little, so old code will not
overrun buffers. (we don't include any multicast daemons in openbsd tree)

sync better with kame.  remove register variable declarations, styles
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.9 2001/02/08 14:51:22 itojun Exp $	*/
d242 1
a242 1
	 case MRT6_OINIT:     return ip6_mrouter_init(so, m, cmd);
d244 8
a251 8
	 case MRT6_INIT:      return ip6_mrouter_init(so, m, cmd);
	 case MRT6_DONE:      return ip6_mrouter_done();
	 case MRT6_ADD_MIF:   return add_m6if(mtod(m, struct mif6ctl *));
	 case MRT6_DEL_MIF:   return del_m6if(mtod(m, mifi_t *));
	 case MRT6_ADD_MFC:   return add_m6fc(mtod(m, struct mf6cctl *));
	 case MRT6_DEL_MFC:   return del_m6fc(mtod(m, struct mf6cctl *));
	 case MRT6_PIM:       return set_pim6(mtod(m, int *));
	 default:            return EOPNOTSUPP;
d271 5
a275 4
	 case MRT6_PIM:       return get_pim6(mb);
	 default:
		 m_free(mb);
		 return EOPNOTSUPP;
d287 1
a287 1
    int error = 0;
d289 12
a300 12
    switch (cmd) {
     case SIOCGETSGCNT_IN6:
	     return(get_sg_cnt((struct sioc_sg_req6 *)data));
	     break;		/* for safety */
     case SIOCGETMIFCNT_IN6:
	     return(get_mif6_cnt((struct sioc_mif_req6 *)data));
	     break;		/* for safety */
     default:
	     return (EINVAL);
	     break;
    }
    return error;
@


1.9
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.8 2000/11/10 15:33:11 provos Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.37 2001/02/08 10:57:00 itojun Exp $	*/
d170 1
a170 1
	register struct mf6c *_rt = mf6ctable[MF6CHASH(o,g)]; \
d192 1
a192 1
	    register int xxs; \
d307 1
a307 1
	register struct sioc_sg_req6 *req;
d309 1
a309 1
	register struct mf6c *rt;
d334 1
a334 1
	register struct sioc_mif_req6 *req;
d336 1
a336 1
	register mifi_t mifi = req->mifi;
d529 1
a529 1
	register struct mif6ctl *mifcp;
d531 1
a531 1
	register struct mif6 *mifp;
d617 2
a618 2
	register struct mif6 *mifp = mif6table + *mifip;
	register mifi_t mifi;
d674 1
a674 1
	register u_short nstl;
d826 1
a826 1
	register struct timeval *t;
d828 3
a830 3
	register u_long d;
	register struct timeval tp;
	register u_long delta;
d929 1
a929 1
	register struct ip6_hdr *ip6;
d933 3
a935 3
	register struct mf6c *rt;
	register struct mif6 *mifp;
	register struct mbuf *mm;
d995 4
a998 4
		register struct mbuf *mb0;
		register struct rtdetq *rte;
		register u_long hash;
/*	register int i, npkts;*/
d1162 1
a1162 1
			register int npkts = 0;
d1255 8
a1262 8
	register struct mbuf *m;
	register struct ifnet *ifp;
	register struct mf6c *rt;
{
	register struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	register mifi_t mifi, iif;
	register struct mif6 *mifp;
	register int plen = m->m_pkthdr.len;
d1267 1
a1267 1
 * separate.
d1309 1
a1309 1
				register struct mbuf *mm;
d1338 1
d1428 1
a1428 1
	register struct mbuf *mb_copy;
d1432 1
a1432 1
	static struct route_in6 ro6;
d1434 1
d1464 1
a1464 1
		error = ip6_output(mb_copy, NULL, &ro6,
d1480 1
d1483 4
a1486 4
		ro6.ro_dst.sin6_len = sizeof(struct sockaddr_in6);
		ro6.ro_dst.sin6_family = AF_INET6;
		ro6.ro_dst.sin6_addr = ip6->ip6_dst;
		ip6_mloopback(ifp, m, &ro6.ro_dst);
d1493 3
a1495 3
		ro6.ro_dst.sin6_len = sizeof(struct sockaddr_in6);
		ro6.ro_dst.sin6_family = AF_INET6;
		ro6.ro_dst.sin6_addr = ip6->ip6_dst;
d1501 1
a1501 2
					  (struct sockaddr *)&ro6.ro_dst,
					  NULL);
d1531 1
a1531 1
	register struct ip6_hdr *ip6;
d1533 1
a1533 1
	register struct mbuf *m;
d1535 2
a1536 2
	register struct mbuf *mm;
	register int i, len = m->m_pkthdr.len;
d1589 2
a1590 2
                ++mrt6stat.mrt6s_upq_sockfull;
                return ENOBUFS;
d1607 3
a1609 3
        register struct pim *pim; /* pointer to a pim struct */
        register struct ip6_hdr *ip6;
        register int pimlen;
d1611 1
a1611 1
        int minlen;
d1616 2
a1617 2
        ip6 = mtod(m, struct ip6_hdr *);
        pimlen = m->m_pkthdr.len - *offp;
d1619 3
a1621 3
        /*
         * Validate lengths
         */
@


1.8
log
@seperate -> separate, okay aaron@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.7 2000/10/19 03:14:02 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.33 2000/10/19 02:23:43 jinmei Exp $	*/
d56 1
d226 2
d416 2
a417 1
	timeout(expire_upcalls, (caddr_t)NULL, EXPIRE_TIMEOUT);
d479 1
a479 1
	untimeout(expire_upcalls, (caddr_t)NULL);
d1246 2
a1247 1
	timeout(expire_upcalls, (caddr_t)NULL, EXPIRE_TIMEOUT);
@


1.7
log
@kame 1.31 -> 1.32
in add_m6fc(), set interface list for all cases.
in response to a report from Hoerdt Mickael.

kame 1.30 -> 1.31
discard PIM register if the version of the inner packet is incorrect (i.e. IPv6)
(according to clarfication of recent discussion in the IETF pim ML)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.6 2000/08/29 09:20:24 itojun Exp $	*/
d1262 1
a1262 1
 * seperate.
@


1.6
log
@do not forward packets with unspecified source (::).
this is clarification made to rfc2460 recently.  sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.5 2000/07/13 14:44:17 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.31 2000/08/23 03:20:05 itojun Exp $	*/
d775 1
d799 1
d1750 12
@


1.5
log
@on openbsd, static symbols are not visible from the userland.
make mif6table global variable.  (sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.c,v 1.4 2000/05/19 13:11:34 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.24 2000/05/19 07:37:05 jinmei Exp $	*/
d80 2
d932 1
d951 22
a975 1

@


1.4
log
@update multicast routing message (struct mrt6msg) to the latest kame.
structure overlaying is corrected to meet IPv6 raw socket spec.

just to be sure, binary backward compatiblity is provided since we shipped
old message handling with openbsd 2.7.  no openbsd 2.7 userland code have
used the API, though, because we did not merge kame pim6[sd]d to openbsd due to
mrouted license issue.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.3 2000/02/07 06:09:10 itojun Exp $	*/
d106 1
a106 1
static struct mif6 mif6table[MAXMIFS];
@


1.3
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_mroute.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d97 1
d125 1
a125 1
#endif 
d166 1
a166 1
#define MF6CFIND(o, g, rt) { \
d182 1
a182 1
}
d188 1
a188 1
#define TV_DELTA(a, b, delta) { \
d204 1
a204 1
}
d217 1
a217 1
static int ip6_mrouter_init __P((struct socket *, struct mbuf *));
d236 4
a239 1
	 case MRT6_INIT:      return ip6_mrouter_init(so, m);
d319 1
a319 1
#endif 
d376 1
a376 1
ip6_mrouter_init(so, m)
d379 1
d404 1
d451 1
a451 1
#endif 
d467 1
a467 1
#endif 
d502 1
a502 1
 
d504 1
d531 1
a531 1
#endif 
d581 1
a581 1
#endif 
d639 1
a639 1
#endif 
d692 1
a692 1
	/* 
d764 1
a764 1
	    
d791 1
a791 1
	    
d802 1
a802 1
	    
d814 1
a814 1
 * collect delay statistics on the upcalls 
d823 1
a823 1
    
d825 1
a825 1
    
d1006 1
a1006 1
	    
d1020 3
d1047 1
a1047 1
			/* 
d1051 25
a1075 4
	    
			im = mtod(mm, struct mrt6msg *);
			im->im6_msgtype	= MRT6MSG_NOCACHE;
			im->im6_mbz		= 0;
d1088 10
a1097 1
			im->im6_mif = mifi;
d1239 6
a1244 6
#define MC6_SEND(ip6,mifp,m) {                             	\
		if ((mifp)->m6_flags & MIFF_REGISTER) 		\
		    register_send((ip6), (mifp), (m));	 	\
                else                                     	\
                    phyint_send((ip6), (mifp), (m));      	\
}
d1258 1
a1258 1
			    mif6table[mifi].m6_ifp->if_index); 
d1267 10
a1276 2
		if(mifi < nummifs) /* have to make sure this is a valid mif */
			if(mif6table[mifi].m6_ifp)
d1278 27
a1304 21
				if (pim6 && (m->m_flags & M_LOOP) == 0) {
					/*
					 * Check the M_LOOP flag to avoid an
					 * unnecessary PIM assert.
					 * XXX: M_LOOP is an ad-hoc hack...
					 */
					static struct sockaddr_in6 sin6 =
					{ sizeof(sin6), AF_INET6 };

					register struct mbuf *mm;
					struct mrt6msg *im;

					mm = m_copy(m, 0,
						    sizeof(struct ip6_hdr));
					if (mm &&
					    (M_HASCL(mm) ||
					     mm->m_len < sizeof(struct ip6_hdr)))
						mm = m_pullup(mm, sizeof(struct ip6_hdr));
					if (mm == NULL)
						return ENOBUFS;
		
d1306 6
a1311 9
					im->im6_msgtype	= MRT6MSG_WRONGMIF;
					im->im6_mbz	= 0;

					for (mifp = mif6table, iif = 0;
					     iif < nummifs && mifp &&
						     mifp->m6_ifp != ifp;
					     mifp++, iif++);

					im->im6_mif	= iif;
d1313 15
d1329 2
d1332 1
a1332 1
					mrt6stat.mrt6s_upcalls++;
d1334 1
a1334 2
					if (socket_send(ip6_mrouter, mm,
							&sin6) < 0) {
d1336 2
a1337 2
						if (mrt6debug)
							log(LOG_WARNING, "mdq, ip6_mrouter socket queue full\n");
d1339 4
a1342 4
						++mrt6stat.mrt6s_upq_sockfull;
						return ENOBUFS;
					}	/* if socket Q full */
				}		/* if PIM */
d1364 19
d1455 1
a1455 1
	 * Put the packet into the sending queue of the outgoing interface 
d1492 1
a1492 1
#endif 
d1496 1
a1496 1
static int 
d1536 1
a1536 1
	/* 
d1561 1
a1561 1
 
d1603 1
a1603 1
	 * 
d1608 1
a1608 1
    
d1617 1
a1617 1
    
d1648 1
a1648 1
#endif 
d1662 1
a1662 1
#endif 
d1709 1
a1709 1
#endif 
d1723 1
a1723 1
#endif 
d1734 1
a1734 1
#endif 
d1748 1
a1748 1
#endif 
d1775 1
a1775 1
    
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: ip6_mroute.c,v 1.15 2001/03/25 09:25:08 itojun Exp $	*/
/*	$KAME: ip6_mroute.c,v 1.45 2001/03/25 08:38:51 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
a54 1
#include <sys/timeout.h>
a78 2
#include <net/net_osdep.h>

a95 1
int		ip6_mrouter_ver = 0;
d104 1
a104 1
struct mif6 mif6table[MAXMIFS];
d123 1
a123 1
#endif
d164 2
a165 2
#define MF6CFIND(o, g, rt) do { \
	struct mf6c *_rt = mf6ctable[MF6CHASH(o,g)]; \
d180 1
a180 1
} while (0)
d186 2
a187 2
#define TV_DELTA(a, b, delta) do { \
	    int xxs; \
d202 1
a202 1
} while (0)
d215 1
a215 1
static int ip6_mrouter_init __P((struct socket *, struct mbuf *, int));
a220 2
static struct timeout expire_upcalls_ch;

d234 8
a241 11
#ifdef MRT6_OINIT
	case MRT6_OINIT:	return ip6_mrouter_init(so, m, cmd);
#endif
	case MRT6_INIT:		return ip6_mrouter_init(so, m, cmd);
	case MRT6_DONE:		return ip6_mrouter_done();
	case MRT6_ADD_MIF:	return add_m6if(mtod(m, struct mif6ctl *));
	case MRT6_DEL_MIF:	return del_m6if(mtod(m, mifi_t *));
	case MRT6_ADD_MFC:	return add_m6fc(mtod(m, struct mf6cctl *));
	case MRT6_DEL_MFC:	return del_m6fc(mtod(m, struct mf6cctl *));
	case MRT6_PIM:		return set_pim6(mtod(m, int *));
	default:		return EOPNOTSUPP;
d261 4
a264 5
	case MRT6_PIM:
		return get_pim6(mb);
	default:
		m_free(mb);
		return EOPNOTSUPP;
d276 1
a276 1
	int error = 0;
d278 12
a289 12
	switch (cmd) {
	case SIOCGETSGCNT_IN6:
		return(get_sg_cnt((struct sioc_sg_req6 *)data));
		break;		/* for safety */
	case SIOCGETMIFCNT_IN6:
		return(get_mif6_cnt((struct sioc_mif_req6 *)data));
		break;		/* for safety */
	default:
		return (EINVAL);
		break;
	}
	return error;
d297 1
a297 1
	struct sioc_sg_req6 *req;
d299 1
a299 1
	struct mf6c *rt;
d314 1
a314 1
#endif
d324 1
a324 1
	struct sioc_mif_req6 *req;
d326 1
a326 1
	mifi_t mifi = req->mifi;
d371 1
a371 1
ip6_mrouter_init(so, m, cmd)
a373 1
	int cmd;
a397 1
	ip6_mrouter_ver = cmd;
d404 1
a404 2
	timeout_set(&expire_upcalls_ch, expire_upcalls, NULL);
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d444 1
a444 1
#endif
d460 1
a460 1
#endif
d466 1
a466 1
	timeout_del(&expire_upcalls_ch);
d495 1
a495 1

a496 1
	ip6_mrouter_ver = 0;
d515 1
a515 1
	struct mif6ctl *mifcp;
d517 1
a517 1
	struct mif6 *mifp;
d523 1
a523 1
#endif
d573 1
a573 1
#endif
d603 2
a604 2
	struct mif6 *mifp = mif6table + *mifip;
	mifi_t mifi;
d631 1
a631 1
#endif
d660 1
a660 1
	u_short nstl;
d684 1
a684 1
	/*
d756 1
a756 1
	
a764 1
				rt->mf6c_ifset	    = mfccp->mf6cc_ifset;
d783 1
a783 1
	
a787 1
			rt->mf6c_ifset	    = mfccp->mf6cc_ifset;
d794 1
a794 1
	
d806 1
a806 1
 * collect delay statistics on the upcalls
d810 1
a810 1
	struct timeval *t;
d812 4
a815 4
	u_long d;
	struct timeval tp;
	u_long delta;

d817 1
a817 1

d913 1
a913 1
	struct ip6_hdr *ip6;
d917 3
a919 3
	struct mf6c *rt;
	struct mif6 *mifp;
	struct mbuf *mm;
a921 1
	long time_second = time.tv_sec;
a939 22
	 * Source address check: do not forward packets with unspecified
	 * source. It was discussed in July 2000, on ipngwg mailing list.
	 * This is rather more serious than unicast cases, because some
	 * MLD packets can be sent with the unspecified source address
	 * (although such packets must normally set 1 to the hop limit field).
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
		ip6stat.ip6s_cantforward++;
		if (ip6_log_time + ip6_log_interval < time_second) {
			ip6_log_time = time_second;
			log(LOG_DEBUG,
			    "cannot forward "
			    "from %s to %s nxt %d received on %s\n",
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    ip6->ip6_nxt,
			    if_name(m->m_pkthdr.rcvif));
		}
		return 0;
	}

	/*
d943 1
d957 4
a960 4
		struct mbuf *mb0;
		struct rtdetq *rte;
		u_long hash;
/*		int i, npkts;*/
d998 1
a998 1
	
a1011 3
#ifdef MRT6_OINIT
			struct omrt6msg *oim;
#endif
d1036 1
a1036 1
			/*
d1040 4
a1043 25
	
			im = NULL;
#ifdef MRT6_OINIT
			oim = NULL;
#endif
			switch (ip6_mrouter_ver) {
#ifdef MRT6_OINIT
			case MRT6_OINIT:
				oim = mtod(mm, struct omrt6msg *);
				oim->im6_msgtype = MRT6MSG_NOCACHE;
				oim->im6_mbz = 0;
				break;
#endif
			case MRT6_INIT:
				im = mtod(mm, struct mrt6msg *);
				im->im6_msgtype = MRT6MSG_NOCACHE;
				im->im6_mbz = 0;
				break;
			default:
				free(rte, M_MRTABLE);
				m_freem(mb0);
				free(rt, M_MRTABLE);
				splx(s);
				return EINVAL;
			}
d1056 1
a1056 10
			switch (ip6_mrouter_ver) {
#ifdef MRT6_OINIT
			case MRT6_OINIT:
				oim->im6_mif = mifi;
				break;
#endif
			case MRT6_INIT:
				im->im6_mif = mifi;
				break;
			}
d1091 1
a1091 1
			int npkts = 0;
d1175 1
a1175 2
	timeout_set(&expire_upcalls_ch, expire_upcalls, NULL);
	timeout_add(&expire_upcalls_ch, EXPIRE_TIMEOUT);
d1183 8
a1190 8
	struct mbuf *m;
	struct ifnet *ifp;
	struct mf6c *rt;
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	mifi_t mifi, iif;
	struct mif6 *mifp;
	int plen = m->m_pkthdr.len;
d1198 6
a1203 6
#define MC6_SEND(ip6, mifp, m) do {				\
		if ((mifp)->m6_flags & MIFF_REGISTER)		\
		    register_send((ip6), (mifp), (m));		\
		else						\
		    phyint_send((ip6), (mifp), (m));		\
} while (0)
d1217 1
a1217 1
			    mif6table[mifi].m6_ifp->if_index);
d1226 2
a1227 10
		/* have to make sure this is a valid mif */
		if (mifi < nummifs && mif6table[mifi].m6_ifp)
			if (pim6 && (m->m_flags & M_LOOP) == 0) {
				/*
				 * Check the M_LOOP flag to avoid an
				 * unnecessary PIM assert.
				 * XXX: M_LOOP is an ad-hoc hack...
				 */
				static struct sockaddr_in6 sin6 =
				{ sizeof(sin6), AF_INET6 };
d1229 21
a1249 27
				struct mbuf *mm;
				struct mrt6msg *im;
#ifdef MRT6_OINIT
				struct omrt6msg *oim;
#endif

				mm = m_copy(m, 0, sizeof(struct ip6_hdr));
				if (mm &&
				    (M_HASCL(mm) ||
				     mm->m_len < sizeof(struct ip6_hdr)))
					mm = m_pullup(mm, sizeof(struct ip6_hdr));
				if (mm == NULL)
					return ENOBUFS;
	
#ifdef MRT6_OINIT
				oim = NULL;
#endif
				im = NULL;
				switch (ip6_mrouter_ver) {
#ifdef MRT6_OINIT
				case MRT6_OINIT:
					oim = mtod(mm, struct omrt6msg *);
					oim->im6_msgtype = MRT6MSG_WRONGMIF;
					oim->im6_mbz = 0;
					break;
#endif
				case MRT6_INIT:
d1251 9
a1259 7
					im->im6_msgtype = MRT6MSG_WRONGMIF;
					im->im6_mbz = 0;
					break;
				default:
					m_freem(mm);
					return EINVAL;
				}
a1260 15
				for (mifp = mif6table, iif = 0;
				     iif < nummifs && mifp &&
					     mifp->m6_ifp != ifp;
				     mifp++, iif++)
					;

				switch (ip6_mrouter_ver) {
#ifdef MRT6_OINIT
				case MRT6_OINIT:
					oim->im6_mif = iif;
					sin6.sin6_addr = oim->im6_src;
					break;
#endif
				case MRT6_INIT:
					im->im6_mif = iif;
a1261 2
					break;
				}
d1263 1
a1263 1
				mrt6stat.mrt6s_upcalls++;
d1265 2
a1266 1
				if (socket_send(ip6_mrouter, mm, &sin6) < 0) {
d1268 2
a1269 2
					if (mrt6debug)
						log(LOG_WARNING, "mdq, ip6_mrouter socket queue full\n");
d1271 4
a1274 4
					++mrt6stat.mrt6s_upq_sockfull;
					return ENOBUFS;
				}	/* if socket Q full */
			}		/* if PIM */
a1295 19
			/*
			 * check if the outgoing packet is going to break
			 * a scope boundary.
			 * XXX For packets through PIM register tunnel
			 * interface, we believe a routing daemon.
			 */
			if ((mif6table[rt->mf6c_parent].m6_flags &
			     MIFF_REGISTER) == 0 &&
			    (mif6table[mifi].m6_flags & MIFF_REGISTER) == 0 &&
			    (in6_addr2scopeid(ifp, &ip6->ip6_dst) !=
			     in6_addr2scopeid(mif6table[mifi].m6_ifp,
					      &ip6->ip6_dst) ||
			     in6_addr2scopeid(ifp, &ip6->ip6_src) !=
			     in6_addr2scopeid(mif6table[mifi].m6_ifp,
					      &ip6->ip6_src))) {
				ip6stat.ip6s_badscope++;
				continue;
			}

d1309 1
a1309 1
	struct mbuf *mb_copy;
d1313 1
a1313 1
	static struct route_in6 ro;
a1314 1
	struct sockaddr_in6 *dst6;
d1325 1
a1325 2
	if (mb_copy == NULL) {
		splx(s);
a1326 1
	}
d1344 1
a1344 1
		error = ip6_output(mb_copy, NULL, &ro,
a1359 1
	dst6 = (struct sockaddr_in6 *)&ro.ro_dst;
d1362 4
a1365 4
		dst6->sin6_len = sizeof(struct sockaddr_in6);
		dst6->sin6_family = AF_INET6;
		dst6->sin6_addr = ip6->ip6_dst;
		ip6_mloopback(ifp, m, (struct sockaddr_in6 *)&ro.ro_dst);
d1368 1
a1368 1
	 * Put the packet into the sending queue of the outgoing interface
d1372 3
a1374 3
		dst6->sin6_len = sizeof(struct sockaddr_in6);
		dst6->sin6_family = AF_INET6;
		dst6->sin6_addr = ip6->ip6_dst;
d1380 2
a1381 1
		    (struct sockaddr *)&ro.ro_dst, NULL);
d1387 2
a1388 1
	} else {
d1391 1
d1396 1
a1396 1
			    "phyint_send: packet too big on %s o %s g %s"
d1398 1
a1398 1
			    if_name(ifp),
d1404 2
a1405 1
#endif
a1406 2

	splx(s);
d1409 1
a1409 1
static int
d1411 1
a1411 1
	struct ip6_hdr *ip6;
d1413 1
a1413 1
	struct mbuf *m;
d1415 2
a1416 2
	struct mbuf *mm;
	int i, len = m->m_pkthdr.len;
d1449 1
a1449 1
	/*
d1469 2
a1470 2
		++mrt6stat.mrt6s_upq_sockfull;
		return ENOBUFS;
d1474 1
a1474 1

d1487 3
a1489 3
	struct pim *pim; /* pointer to a pim struct */
	struct ip6_hdr *ip6;
	int pimlen;
d1491 1
a1491 1
	int minlen;
d1496 2
a1497 2
	ip6 = mtod(m, struct ip6_hdr *);
	pimlen = m->m_pkthdr.len - *offp;
d1499 3
a1501 3
	/*
	 * Validate lengths
	 */
d1516 1
a1516 1
	 *
d1521 1
a1521 1

d1530 1
a1530 1

d1561 1
a1561 1
#endif
d1575 1
a1575 1
#endif
d1622 1
a1622 1
#endif
d1636 1
a1636 13
#endif

		/* verify the version number of the inner packet */
		if ((eip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION) {
			++pim6stat.pim6s_rcv_badregisters;
#ifdef MRT6DEBUG
			log(LOG_DEBUG, "pim6_input: invalid IP version (%d) "
			    "of the inner packet\n",
			    (eip6->ip6_vfc & IPV6_VERSION));
#endif
			m_freem(m);
			return(IPPROTO_NONE);
		}
d1647 1
a1647 1
#endif
d1661 1
a1661 1
#endif
d1688 1
a1688 1

@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.3.2.1 2001/05/14 22:40:19 niklas Exp $	*/
d81 2
d974 1
a974 1
			    m->m_pkthdr.rcvif->if_xname);
d1519 1
a1519 1
			    ifp->if_xname,
@


1.3.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d147 5
d761 1
a761 2
			log(LOG_DEBUG,
			    "add_m6fc no upcall h %d o %s g %s p %x\n",
d1266 1
a1266 1
 * separate.
@


1.3.2.4
log
@Merge in -current from roughly a week ago
@
text
@d83 2
a84 2
static int ip6_mdq(struct mbuf *, struct ifnet *, struct mf6c *);
static void phyint_send(struct ip6_hdr *, struct mif6 *, struct mbuf *);
d86 6
a91 6
static int set_pim6(int *);
static int get_pim6(struct mbuf *);
static int socket_send(struct socket *, struct mbuf *,
			    struct sockaddr_in6 *);
static int register_send(struct ip6_hdr *, struct mif6 *,
			      struct mbuf *);
d118 1
a118 1
static void	expire_upcalls(void *);
d211 7
a217 7
static int get_sg_cnt(struct sioc_sg_req6 *);
static int get_mif6_cnt(struct sioc_mif_req6 *);
static int ip6_mrouter_init(struct socket *, struct mbuf *, int);
static int add_m6if(struct mif6ctl *);
static int del_m6if(mifi_t *);
static int add_m6fc(struct mf6cctl *);
static int del_m6fc(struct mf6cctl *);
@


1.3.2.5
log
@Sync the SMP branch with 3.3
@
text
@a35 39
 * Copyright (c) 1989 Stephen Deering
 * Copyright (c) 1992, 1993
 *      The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)ip_mroute.c 8.2 (Berkeley) 11/15/93
 */

/*
d43 1
a43 1
 * Modified by Bill Fenner, PARC, April 1994
a73 3
#ifdef MULTICAST_PMTUD
#include <netinet/icmp6.h>
#endif
d80 2
a81 1
#include <netinet6/nd6.h>
d97 1
a97 1
struct socket  *ip6_mrouter = NULL;
d106 1
a106 1
u_char		n6expire[MF6CTBLSIZ];
d192 1
a192 1
			      /* FALLTHROUGH */ \
d284 1
a284 1
		return (get_sg_cnt((struct sioc_sg_req6 *)data));
d287 1
a287 1
		return (get_mif6_cnt((struct sioc_mif_req6 *)data));
d306 1
a306 1
	s = splsoftnet();
d315 1
a315 1
		return (ESRCH);
d406 1
a406 1
	bzero((caddr_t)n6expire, sizeof(n6expire));
d435 1
a435 1
	s = splsoftnet();
d559 1
a559 1
		s = splsoftnet();
d574 1
a574 1
	s = splsoftnet();
d622 1
a622 1
	s = splsoftnet();
d684 1
a684 1
		s = splsoftnet();
d695 1
a695 1
	s = splsoftnet();
d733 1
a733 1
			n6expire[hash]--;
d781 1
a781 1
					n6expire[hash]--;
d867 1
a867 1
	s = splsoftnet();
d976 1
a976 1
	s = splsoftnet();
d1024 1
a1024 1
		    (M_READONLY(mb0) || mb0->m_len < sizeof(struct ip6_hdr)))
d1146 1
a1146 1
			n6expire[hash]++;
d1198 1
a1198 1
	s = splsoftnet();
d1201 1
a1201 1
		if (n6expire[i] == 0)
d1231 1
a1231 1
				n6expire[i]--;
d1312 1
a1312 1
				    (M_READONLY(mm) ||
d1426 1
a1426 1
	int s = splsoftnet();
a1429 1
	u_long linkmtu;
d1438 1
a1438 1
	    (M_READONLY(mb_copy) || mb_copy->m_len < sizeof(struct ip6_hdr)))
d1489 1
a1489 2
	linkmtu = IN6_LINKMTU(ifp);
	if (mb_copy->m_pkthdr.len <= linkmtu || linkmtu < IPV6_MMTU) {
d1506 1
a1506 1
		icmp6_error(mb_copy, ICMP6_PACKET_TOO_BIG, 0, linkmtu);
d1558 2
a1559 1
	if (mm == NULL)
d1561 1
d1583 1
a1583 1
			    "register_send: ip6_mrouter socket queue full\n");
d1625 1
a1625 1
		return (IPPROTO_DONE);
d1679 1
a1679 1
			return (IPPROTO_DONE);
d1693 1
a1693 1
		return (IPPROTO_DONE);
d1719 1
a1719 1
			return (IPPROTO_DONE);
d1740 1
a1740 1
			return (IPPROTO_DONE);
d1763 1
a1763 1
			return (IPPROTO_NONE);
d1777 1
a1777 1
			return (IPPROTO_DONE);
d1791 1
a1791 1
			return (IPPROTO_DONE);
d1809 1
a1809 1
		rc = looutput(mif6table[reg_mif_num].m6_ifp, m,
d1825 1
a1825 1
	return (IPPROTO_DONE);
@


1.3.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.3.2.5 2003/03/28 00:41:29 niklas Exp $	*/
d585 2
a586 3
			strlcpy(multicast_register_if.if_xname,
			    "register_mif",
			    sizeof multicast_register_if.if_xname); /* XXX */
@


1.3.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1461 3
a1463 3
	struct ip6_hdr *ip6;
	struct mif6 *mifp;
	struct mbuf *m;
d1684 8
a1696 8

	/* PIM version check */
	if (pim->pim_ver != PIM_VERSION) {
		++pim6stat.pim6s_rcv_badversion;
#ifdef MRT6DEBUG
		log(LOG_ERR,
		    "pim6_input: incorrect version %d, expecting %d\n",
		    pim->pim_ver, PIM_VERSION);
a1697 3
		m_freem(m);
		return (IPPROTO_DONE);
	}
d1725 12
@


1.3.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.3.2.7 2003/05/16 00:29:44 niklas Exp $	*/
d51 5
a55 1
 * 3. Neither the name of the University nor the names of its contributors
d321 1
d326 1
d329 1
d332 1
d334 1
a1432 3
			if (mif6table[mifi].m6_ifp == NULL)
				continue;

@


1.3.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$NetBSD: ip6_mroute.c,v 1.59 2003/12/10 09:28:38 itojun Exp $	*/
d250 1
a250 1
static int ip6_mrouter_init(struct socket *, int, int);
d268 1
a268 1
		return (EACCES);
d272 1
a272 1
	case MRT6_OINIT:
d274 8
a281 28
	case MRT6_INIT:
		if (m == NULL || m->m_len < sizeof(int))
			return (EINVAL);
		return (ip6_mrouter_init(so, *mtod(m, int *), cmd));
	case MRT6_DONE:
		return (ip6_mrouter_done());
	case MRT6_ADD_MIF:
		if (m == NULL || m->m_len < sizeof(struct mif6ctl))
			return (EINVAL);
		return (add_m6if(mtod(m, struct mif6ctl *)));
	case MRT6_DEL_MIF:
		if (m == NULL || m->m_len < sizeof(mifi_t))
			return (EINVAL);
		return (del_m6if(mtod(m, mifi_t *)));
	case MRT6_ADD_MFC:
		if (m == NULL || m->m_len < sizeof(struct mf6cctl))
			return (EINVAL);
		return (add_m6fc(mtod(m, struct mf6cctl *)));
	case MRT6_DEL_MFC:
		if (m == NULL || m->m_len < sizeof(struct mf6cctl))
			return (EINVAL);
		return (del_m6fc(mtod(m,  struct mf6cctl *)));
	case MRT6_PIM:
		if (m == NULL || m->m_len < sizeof(int))
			return (EINVAL);
		return (set_pim6(mtod(m, int *)));
	default:
		return (EOPNOTSUPP);
d407 1
a407 1
ip6_mrouter_init(so, v, cmd)
d409 1
a409 1
	int v;
d412 2
d423 4
a426 1
		return (EOPNOTSUPP);
d428 3
a430 2
	if (v != 1)
		return (ENOPROTOOPT);
d432 1
a432 2
	if (ip6_mrouter != NULL)
		return (EADDRINUSE);
a547 32
void
ip6_mrouter_detach(ifp)
	struct ifnet *ifp;
{
	struct rtdetq *rte;
	struct mf6c *mfc;
	mifi_t mifi;
	int i;

	/*
	 * Delete a mif which points to ifp.
	 */
	for (mifi = 0; mifi < nummifs; mifi++)
		if (mif6table[mifi].m6_ifp == ifp)
			del_m6if(&mifi);

	/*
	 * Clear rte->ifp of cache entries received on ifp.
	 */
	for (i = 0; i < MF6CTBLSIZ; i++) {
		if (n6expire[i] == 0)
			continue;

		for (mfc = mf6ctable[i]; mfc != NULL; mfc = mfc->mf6c_next) {
			for (rte = mfc->mf6c_stall; rte != NULL; rte = rte->next) {
				if (rte->ifp == ifp)
					rte->ifp = NULL;
			}
		}
	}
}

d570 1
a570 1
	if (mifcp->mif6c_pifi == 0 || mifcp->mif6c_pifi >= if_indexlim)
a572 2
	if (!ifp)
		return ENXIO;
d771 1
a771 3
				if (rte->ifp) {
					ip6_mdq(rte->m, rte->ifp, rt);
				}
d966 1
d993 2
a994 2
		if (ip6_log_time + ip6_log_interval < time.tv_sec) {
			ip6_log_time = time.tv_sec;
d1317 1
a1317 2
			    mif6table[mifi].m6_ifp ?
			    mif6table[mifi].m6_ifp->if_index : -1); 
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d73 1
a73 1
#include <netinet6/ip6.h>
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 4
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#endif

a54 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#include <sys/malloc.h>
#endif
a62 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a63 1
#endif
a78 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static MALLOC_DEFINE(M_MRTABLE, "mf6c", "multicast forwarding cache entry");
#endif

a84 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a85 1
#endif
a144 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static struct callout_handle expire_upcalls_ch;
#endif

a223 48
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int
ip6_mrouter_set(so, sopt)
	struct socket *so;
	struct sockopt *sopt;
{
	int	error = 0;
	struct mbuf *m;

	if (so != ip6_mrouter && sopt->sopt_name != MRT6_INIT)
		return (EACCES);

	if (error = soopt_getm(sopt, &m)) /* XXX */
		return (error);
	if (error = soopt_mcopyin(sopt, m)) /* XXX */
		return (error);

	switch (sopt->sopt_name) {
	 case MRT6_INIT:
		 error = ip6_mrouter_init(so, m);
		 break;
	 case MRT6_DONE:
		 error = ip6_mrouter_done();
		 break;
	 case MRT6_ADD_MIF:
		 error = add_m6if(mtod(m, struct mif6ctl *));
		 break;
	 case MRT6_DEL_MIF:
		 error = del_m6if(mtod(m, mifi_t *));
		 break;
	 case MRT6_ADD_MFC:
		 error = add_m6fc(mtod(m, struct mf6cctl *));
		 break;
	 case MRT6_DEL_MFC:
		 error = del_m6fc(mtod(m, struct mf6cctl *));
		 break;
	 case MRT6_PIM:
		 error = set_pim6(mtod(m, int *));
		 break;
	 default:
		 error = EOPNOTSUPP;
		 break;
	}

	(void)m_freem(m);
	return(error);
}
#else
a243 1
#endif
a247 18
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int
ip6_mrouter_get(so, sopt)
	struct socket *so;
	struct sockopt *sopt;
{
	int error = 0;

	if (so != ip6_mrouter) return EACCES;

	switch (sopt->sopt_name) {
		case MRT6_PIM:
			error = sooptcopyout(sopt, &pim6, sizeof(pim6));
			break;
	}
	return (error);
}
#else
a266 1
#endif
a301 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d303 1
a303 1
#endif
a338 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >=3)
a353 1
#endif
a403 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	expire_upcalls_ch =
#endif
a427 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
a428 1
#endif
d466 1
a466 5
	untimeout(expire_upcalls, (caddr_t)NULL
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		  , expire_upcalls_ch
#endif
		  );
a518 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a519 1
#endif 
a535 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a537 3
#else
			multicast_register_if.if_name = "register_mif";
#endif 
a550 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d552 1
a552 4
#endif
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3)
		error = if_allmulti(ifp, 1);
#else
d560 1
a560 1
#endif
a565 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d567 1
a567 1
#endif
a605 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a606 1
#endif
a613 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
a614 1
#endif
a622 3
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3)
		if_allmulti(ifp, 0);
#else
a625 1
#endif 
a675 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d677 1
a677 1
#endif
a686 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d688 1
a688 1
#endif
a855 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
a856 1
#endif
a941 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d943 1
a943 1
#endif
a1131 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d1133 1
a1133 1
#endif
a1174 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	expire_upcalls_ch =
#endif
a1311 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
a1312 1
#endif
a1393 10
#ifdef __NetBSD__
		if (mrt6debug & DEBUG_DEBUG_XMIT)
			log(LOG_DEBUG,
			    "phyint_send: packet too big on %s o %s g %s"
			    " size %d(discarded)\n",
			    ifp->if_xname,
			    ip6_sprintf(&ip6->ip6_src),
			    ip6_sprintf(&ip6->ip6_dst),
			    mb_copy->m_pkthdr.len);
#else
a1401 1
#endif /* __NetBSD__ */
a1680 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
 		rc = if_simloop(mif6table[reg_mif_num].m6_ifp, m,
			      (struct sockaddr *) &dst, NULL);
#else
a1683 1
#endif
@

