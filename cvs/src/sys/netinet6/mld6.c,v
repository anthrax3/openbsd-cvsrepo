head	1.50;
access;
symbols
	OPENBSD_6_1:1.50.0.2
	OPENBSD_6_1_BASE:1.50
	OPENBSD_6_0:1.48.0.2
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.41.0.2
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.28.0.8
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.6
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.4
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.4
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.26.0.2
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.4
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.19.0.12
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.10
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.8
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.6
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.16.0.4
	OPENBSD_3_3_BASE:1.16
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.16
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.50
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.49;
commitid	1ap8YFU49Zg4mM41;

1.49
date	2016.12.21.12.12.13;	author mpi;	state Exp;
branches;
next	1.48;
commitid	QgmYePjvoqRMYgZx;

1.48
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.47;
commitid	LxUFHuffW7GZZ01f;

1.47
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.46;
commitid	Z6e4eqr6FuYFPnlL;

1.46
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.45;
commitid	LU3jSOpFfLxcllFL;

1.45
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.44;
commitid	Cr0DVA7exR1t2zXg;

1.44
date	2015.09.10.09.10.42;	author claudio;	state Exp;
branches;
next	1.43;
commitid	WTqKN006TxFxeYKA;

1.43
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.42;
commitid	MtXIH0WHmPXVgeDN;

1.42
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.41;
commitid	h7z8lokZ0dFyuWpg;

1.41
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.40;
commitid	cYQY7jiay4SydLhD;

1.40
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.39;
commitid	Vq8oSnWLkf7dyy0N;

1.39
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.38;
commitid	Z1vcFtHO8wRH0yRt;

1.38
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.24.12.20.22;	author naddy;	state Exp;
branches;
next	1.36;

1.36
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.11.14.23.30.23;	author patrick;	state Exp;
branches;
next	1.32;

1.32
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.14.11.07.42;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.15.15.14.44;	author chl;	state Exp;
branches;
next	1.26;

1.26
date	2010.03.22.12.23.32;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.08.04.29.21;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.16.16.00.58;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.16.08.48.06;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.16.08.22.06;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.01.08.05.49.40;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.15.07.08.00;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	;

1.5.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.05.14.22.40.19;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.07.04.10.55.25;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.5.2.8;

1.5.2.8
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.5.2.9;

1.5.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.50
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@/*	$OpenBSD: mld6.c,v 1.49 2016/12/21 12:12:13 mpi Exp $	*/
/*	$KAME: mld6.c,v 1.26 2001/02/16 14:50:35 itojun Exp $	*/

/*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988 Stephen Deering.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Stephen Deering of Stanford University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)igmp.c	8.1 (Berkeley) 7/19/93
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/protosw.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/mld6.h>
#include <netinet6/mld6_var.h>

static struct ip6_pktopts ip6_opts;
static int mld_timers_are_running;
/* XXX: These are necessary for KAME's link-local hack */
static struct in6_addr mld_all_nodes_linklocal = IN6ADDR_LINKLOCAL_ALLNODES_INIT;
static struct in6_addr mld_all_routers_linklocal = IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;

void mld6_checktimer(struct ifnet *);
static void mld6_sendpkt(struct in6_multi *, int, const struct in6_addr *);

void
mld6_init(void)
{
	static u_int8_t hbh_buf[8];
	struct ip6_hbh *hbh = (struct ip6_hbh *)hbh_buf;
	u_int16_t rtalert_code = htons((u_int16_t)IP6OPT_RTALERT_MLD);

	mld_timers_are_running = 0;

	/* ip6h_nxt will be fill in later */
	hbh->ip6h_len = 0;	/* (8 >> 3) - 1 */

	/* XXX: grotty hard coding... */
	hbh_buf[2] = IP6OPT_PADN;	/* 2 byte padding */
	hbh_buf[3] = 0;
	hbh_buf[4] = IP6OPT_ROUTER_ALERT;
	hbh_buf[5] = IP6OPT_RTALERT_LEN - 2;
	bcopy((caddr_t)&rtalert_code, &hbh_buf[6], sizeof(u_int16_t));

	ip6_opts.ip6po_hbh = hbh;
}

void
mld6_start_listening(struct in6_multi *in6m)
{
	/*
	 * RFC2710 page 10:
	 * The node never sends a Report or Done for the link-scope all-nodes
	 * address.
	 * MLD messages are never sent for multicast addresses whose scope is 0
	 * (reserved) or 1 (node-local).
	 */
	mld_all_nodes_linklocal.s6_addr16[1] = htons(in6m->in6m_ifidx);/* XXX */
	if (IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld_all_nodes_linklocal) ||
	    __IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) < __IPV6_ADDR_SCOPE_LINKLOCAL) {
		in6m->in6m_timer = 0;
		in6m->in6m_state = MLD_OTHERLISTENER;
	} else {
		mld6_sendpkt(in6m, MLD_LISTENER_REPORT, NULL);
		in6m->in6m_timer =
		    MLD_RANDOM_DELAY(MLD_V1_MAX_RI *
		    PR_FASTHZ);
		in6m->in6m_state = MLD_IREPORTEDLAST;
		mld_timers_are_running = 1;
	}
}

void
mld6_stop_listening(struct in6_multi *in6m)
{
	mld_all_nodes_linklocal.s6_addr16[1] = htons(in6m->in6m_ifidx);/* XXX */
	mld_all_routers_linklocal.s6_addr16[1] =
	    htons(in6m->in6m_ifidx); /* XXX: necessary when mrouting */

	if (in6m->in6m_state == MLD_IREPORTEDLAST &&
	    (!IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld_all_nodes_linklocal)) &&
	    __IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) > __IPV6_ADDR_SCOPE_INTFACELOCAL)
		mld6_sendpkt(in6m, MLD_LISTENER_DONE,
		    &mld_all_routers_linklocal);
}

void
mld6_input(struct mbuf *m, int off)
{
	struct ip6_hdr *ip6;
	struct mld_hdr *mldh;
	struct ifnet *ifp;
	struct in6_multi *in6m;
	struct ifmaddr *ifma;
	int timer;		/* timer value in the MLD query header */

	IP6_EXTHDR_GET(mldh, struct mld_hdr *, m, off, sizeof(*mldh));
	if (mldh == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		return;
	}

	/* source address validation */
	ip6 = mtod(m, struct ip6_hdr *);/* in case mpullup */
	if (!IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_src)) {
#if 0
		char src[INET6_ADDRSTRLEN], grp[INET6_ADDRSTRLEN];

		log(LOG_ERR,
		    "mld_input: src %s is not link-local (grp=%s)\n",
		    inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src)),
		    inet_ntop(AF_INET6, &mldh->mld_addr, grp, sizeof(grp)));
#endif
		/*
		 * spec (RFC2710) does not explicitly
		 * specify to discard the packet from a non link-local
		 * source address. But we believe it's expected to do so.
		 */
		m_freem(m);
		return;
	}

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(m);
		return;
	}

	/*
	 * In the MLD6 specification, there are 3 states and a flag.
	 *
	 * In Non-Listener state, we simply don't have a membership record.
	 * In Delaying Listener state, our timer is running (in6m->in6m_timer)
	 * In Idle Listener state, our timer is not running (in6m->in6m_timer==0)
	 *
	 * The flag is in6m->in6m_state, it is set to MLD_OTHERLISTENER if
	 * we have heard a report from another member, or MLD_IREPORTEDLAST
	 * if we sent the last report.
	 */
	switch(mldh->mld_type) {
	case MLD_LISTENER_QUERY:
		if (ifp->if_flags & IFF_LOOPBACK)
			break;

		if (!IN6_IS_ADDR_UNSPECIFIED(&mldh->mld_addr) &&
		    !IN6_IS_ADDR_MULTICAST(&mldh->mld_addr))
			break;	/* print error or log stat? */
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] =
			    htons(ifp->if_index); /* XXX */

		/*
		 * - Start the timers in all of our membership records
		 *   that the query applies to for the interface on
		 *   which the query arrived excl. those that belong
		 *   to the "all-nodes" group (ff02::1).
		 * - Restart any timer that is already running but has
		 *   A value longer than the requested timeout.
		 * - Use the value specified in the query message as
		 *   the maximum timeout.
		 */

		/*
		 * XXX: System timer resolution is too low to handle Max
		 * Response Delay, so set 1 to the internal timer even if
		 * the calculated value equals to zero when Max Response
		 * Delay is positive.
		 */
		timer = ntohs(mldh->mld_maxdelay)*PR_FASTHZ/MLD_TIMER_SCALE;
		if (timer == 0 && mldh->mld_maxdelay)
			timer = 1;
		mld_all_nodes_linklocal.s6_addr16[1] =
			htons(ifp->if_index); /* XXX */

		TAILQ_FOREACH(ifma, &ifp->if_maddrlist, ifma_list) {
			if (ifma->ifma_addr->sa_family != AF_INET6)
				continue;
			in6m = ifmatoin6m(ifma);
			if (IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr,
						&mld_all_nodes_linklocal) ||
			    __IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) <
			    __IPV6_ADDR_SCOPE_LINKLOCAL)
				continue;

			if (IN6_IS_ADDR_UNSPECIFIED(&mldh->mld_addr) ||
			    IN6_ARE_ADDR_EQUAL(&mldh->mld_addr,
						&in6m->in6m_addr))
			{
				if (timer == 0) {
					/* send a report immediately */
					mld6_sendpkt(in6m, MLD_LISTENER_REPORT,
					    NULL);
					in6m->in6m_timer = 0; /* reset timer */
					in6m->in6m_state = MLD_IREPORTEDLAST;
				} else if (in6m->in6m_timer == 0 || /* idle */
					in6m->in6m_timer > timer) {
					in6m->in6m_timer =
					    MLD_RANDOM_DELAY(timer);
					mld_timers_are_running = 1;
				}
			}
		}

		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
		break;
	case MLD_LISTENER_REPORT:
		/*
		 * For fast leave to work, we have to know that we are the
		 * last person to send a report for this group.  Reports
		 * can potentially get looped back if we are a multicast
		 * router, so discard reports sourced by me.
		 * Note that it is impossible to check IFF_LOOPBACK flag of
		 * ifp for this purpose, since ip6_mloopback pass the physical
		 * interface to if_input_local().
		 */
		if (m->m_flags & M_LOOP) /* XXX: grotty flag, but efficient */
			break;

		if (!IN6_IS_ADDR_MULTICAST(&mldh->mld_addr))
			break;

		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] =
				htons(ifp->if_index); /* XXX */
		/*
		 * If we belong to the group being reported, stop
		 * our timer for that group.
		 */
		IN6_LOOKUP_MULTI(mldh->mld_addr, ifp, in6m);
		if (in6m) {
			in6m->in6m_timer = 0; /* transit to idle state */
			in6m->in6m_state = MLD_OTHERLISTENER; /* clear flag */
		}

		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
		break;
	default:		/* this is impossible */
#if 0
		/*
		 * this case should be impossible because of filtering in
		 * icmp6_input().  But we explicitly disabled this part
		 * just in case.
		 */
		log(LOG_ERR, "mld_input: illegal type(%d)", mldh->mld_type);
#endif
		break;
	}
	if_put(ifp);

	m_freem(m);
}

void
mld6_fasttimeo(void)
{
	struct ifnet *ifp;

	/*
	 * Quick check to see if any work needs to be done, in order
	 * to minimize the overhead of fasttimo processing.
	 */
	if (!mld_timers_are_running)
		return;

	mld_timers_are_running = 0;
	TAILQ_FOREACH(ifp, &ifnet, if_list)
		mld6_checktimer(ifp);
}

void
mld6_checktimer(struct ifnet *ifp)
{
	struct in6_multi *in6m;
	struct ifmaddr *ifma;

	splsoftassert(IPL_SOFTNET);

	TAILQ_FOREACH(ifma, &ifp->if_maddrlist, ifma_list) {
		if (ifma->ifma_addr->sa_family != AF_INET6)
			continue;
		in6m = ifmatoin6m(ifma);
		if (in6m->in6m_timer == 0) {
			/* do nothing */
		} else if (--in6m->in6m_timer == 0) {
			mld6_sendpkt(in6m, MLD_LISTENER_REPORT, NULL);
			in6m->in6m_state = MLD_IREPORTEDLAST;
		} else {
			mld_timers_are_running = 1;
		}
	}
}

static void
mld6_sendpkt(struct in6_multi *in6m, int type, const struct in6_addr *dst)
{
	struct mbuf *mh, *md;
	struct mld_hdr *mldh;
	struct ip6_hdr *ip6;
	struct ip6_moptions im6o;
	struct in6_ifaddr *ia6;
	struct ifnet *ifp;
	int ignflags;

	ifp = if_get(in6m->in6m_ifidx);
	if (ifp == NULL)
		return;

	/*
	 * At first, find a link local address on the outgoing interface
	 * to use as the source address of the MLD packet.
	 * We do not reject tentative addresses for MLD report to deal with
	 * the case where we first join a link-local address.
	 */
	ignflags = IN6_IFF_DUPLICATED|IN6_IFF_ANYCAST;
	if ((ia6 = in6ifa_ifpforlinklocal(ifp, ignflags)) == NULL) {
		if_put(ifp);
		return;
	}
	if ((ia6->ia6_flags & IN6_IFF_TENTATIVE))
		ia6 = NULL;

	/*
	 * Allocate mbufs to store ip6 header and MLD header.
	 * We allocate 2 mbufs and make chain in advance because
	 * it is more convenient when inserting the hop-by-hop option later.
	 */
	MGETHDR(mh, M_DONTWAIT, MT_HEADER);
	if (mh == NULL) {
		if_put(ifp);
		return;
	}
	MGET(md, M_DONTWAIT, MT_DATA);
	if (md == NULL) {
		m_free(mh);
		if_put(ifp);
		return;
	}
	mh->m_next = md;

	mh->m_pkthdr.ph_ifidx = 0;
	mh->m_pkthdr.ph_rtableid = ifp->if_rdomain;
	mh->m_pkthdr.len = sizeof(struct ip6_hdr) + sizeof(struct mld_hdr);
	mh->m_len = sizeof(struct ip6_hdr);
	MH_ALIGN(mh, sizeof(struct ip6_hdr));

	/* fill in the ip6 header */
	ip6 = mtod(mh, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	/* ip6_plen will be set later */
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	/* ip6_hlim will be set by im6o.im6o_hlim */
	ip6->ip6_src = ia6 ? ia6->ia_addr.sin6_addr : in6addr_any;
	ip6->ip6_dst = dst ? *dst : in6m->in6m_addr;

	/* fill in the MLD header */
	md->m_len = sizeof(struct mld_hdr);
	mldh = mtod(md, struct mld_hdr *);
	mldh->mld_type = type;
	mldh->mld_code = 0;
	mldh->mld_cksum = 0;
	/* XXX: we assume the function will not be called for query messages */
	mldh->mld_maxdelay = 0;
	mldh->mld_reserved = 0;
	mldh->mld_addr = in6m->in6m_addr;
	if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
		mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
	mh->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;

	/* construct multicast option */
	bzero(&im6o, sizeof(im6o));
	im6o.im6o_ifidx = ifp->if_index;
	im6o.im6o_hlim = 1;

	if_put(ifp);

	/*
	 * Request loopback of the report if we are acting as a multicast
	 * router, so that the process-level routing daemon can hear it.
	 */
#ifdef MROUTING
	im6o.im6o_loop = (ip6_mrouter != NULL);
#endif

	icmp6stat_inc(icp6s_outhist + type);
	ip6_output(mh, &ip6_opts, NULL, ia6 ? 0 : IPV6_UNSPECSRC, &im6o,
	    NULL);
}
@


1.49
log
@Remove recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.48 2016/07/05 10:17:14 mpi Exp $	*/
d168 1
a168 1
		icmp6stat.icp6s_tooshort++;
d457 1
a457 1
	icmp6stat.icp6s_outhist[type]++;
@


1.48
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.47 2016/03/07 18:44:00 naddy Exp $	*/
a119 2
	int s = splsoftnet();

a139 1
	splx(s);
a144 2
	int s = splsoftnet();

a153 1
	splx(s);
a327 1
	int s;
a335 1
	s = splsoftnet();
a338 1
	splx(s);
@


1.47
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.46 2015/09/12 13:34:12 mpi Exp $	*/
d394 1
a394 1
	ignflags = (IN6_IFF_NOTREADY|IN6_IFF_ANYCAST) & ~IN6_IFF_TENTATIVE;
@


1.46
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.45 2015/09/11 08:17:06 claudio Exp $	*/
d96 1
a96 1
mld6_init()
@


1.45
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.44 2015/09/10 09:10:42 claudio Exp $	*/
d290 1
a290 1
		 * interface to looutput.
@


1.44
log
@More if_put suffling. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.43 2015/09/09 15:51:40 mpi Exp $	*/
d467 1
a467 1
	ip6_output(mh, &ip6_opts, NULL, ia6 ? 0 : IPV6_UNSPECSRC, &im6o, NULL,
@


1.43
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.42 2015/06/16 11:09:40 mpi Exp $	*/
a171 6
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL) {
		m_freem(m);
		return;
	}

d198 6
d325 1
d395 2
a396 1
	if ((ia6 = in6ifa_ifpforlinklocal(ifp, ignflags)) == NULL)
d398 1
d408 2
a409 1
	if (mh == NULL)
d411 1
d415 1
d455 2
@


1.42
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.41 2014/12/17 09:57:13 mpi Exp $	*/
a457 1
	/* increment output statictics */
a458 13
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	switch (type) {
	case MLD_LISTENER_QUERY:
		icmp6_ifstat_inc(ifp, ifs6_out_mldquery);
		break;
	case MLD_LISTENER_REPORT:
		icmp6_ifstat_inc(ifp, ifs6_out_mldreport);
		break;
	case MLD_LISTENER_DONE:
		icmp6_ifstat_inc(ifp, ifs6_out_mlddone);
		break;
	}

@


1.41
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.40 2014/12/17 09:45:59 mpi Exp $	*/
d167 1
a167 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d172 6
d414 1
a414 1
	mh->m_pkthdr.rcvif = NULL;
@


1.40
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.39 2014/11/18 02:37:31 tedu Exp $	*/
d421 1
a421 1
	/* ip6_hlim will be set by im6o.im6o_multicast_hlim */
d442 1
a442 1
	im6o.im6o_multicast_hlim = 1;
d449 1
a449 1
	im6o.im6o_multicast_loop = (ip6_mrouter != NULL);
@


1.39
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.38 2014/04/14 09:06:42 mpi Exp $	*/
d441 1
a441 1
	im6o.im6o_multicast_ifp = ifp;
@


1.38
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.37 2014/01/24 12:20:22 naddy Exp $	*/
a73 1
#include <dev/rndvar.h>
@


1.37
log
@Instead of calculating the ICMPv6 checksum here, just set the flag that
is needed and the lower parts of the stack will take care of it.
ok henning@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.36 2014/01/21 10:18:26 mpi Exp $	*/
d410 1
a410 1
	mh->m_pkthdr.rdomain = ifp->if_rdomain;
@


1.36
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.35 2014/01/13 23:03:52 bluhm Exp $	*/
d438 1
a438 2
	mldh->mld_cksum = in6_cksum(mh, IPPROTO_ICMPV6, sizeof(struct ip6_hdr),
	    sizeof(struct mld_hdr));
@


1.35
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.34 2013/11/28 10:16:44 mpi Exp $	*/
d130 1
a130 2
	mld_all_nodes_linklocal.s6_addr16[1] =
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d151 1
a151 2
	mld_all_nodes_linklocal.s6_addr16[1] =
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d153 1
a153 1
	    htons(in6m->in6m_ifp->if_index); /* XXX: necessary when mrouting */
d375 1
a375 1
	struct ifnet *ifp = in6m->in6m_ifp;
d377 4
@


1.34
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.33 2013/11/14 23:30:23 patrick Exp $	*/
d376 1
a376 1
	struct in6_ifaddr *ia;
d387 1
a387 1
	if ((ia = in6ifa_ifpforlinklocal(ifp, ignflags)) == NULL)
d389 2
a390 2
	if ((ia->ia6_flags & IN6_IFF_TENTATIVE))
		ia = NULL;
d421 1
a421 1
	ip6->ip6_src = ia ? ia->ia_addr.sin6_addr : in6addr_any;
d467 1
a467 1
	ip6_output(mh, &ip6_opts, NULL, ia ? 0 : IPV6_UNSPECSRC, &im6o, NULL,
@


1.33
log
@Clean up tabs and a backslash which seemed to have sneeked in in r1.29.

"clean that little thingy up" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.32 2013/11/11 09:15:35 mpi Exp $	*/
d77 1
d150 2
d162 1
d172 1
a172 1
	struct in6_ifaddr *ia;
a233 3
		IFP_TO_IA6(ifp, ia);
		if (ia == NULL)
			break;
d247 4
a250 1
		LIST_FOREACH(in6m, &ia->ia6_multiaddrs, in6m_entry) {
d350 1
a350 1
	struct in6_ifaddr *ia;
d354 4
a357 1
	IN6_FOREACH_MULTI(ia, ifp, in6m) {
@


1.32
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.31 2013/10/24 11:20:18 deraadt Exp $	*/
d346 1
a346 1
	struct in6_ifaddr *ia;					\
@


1.31
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.30 2013/10/17 16:27:46 bluhm Exp $	*/
d181 2
d185 2
a186 2
		    ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&mldh->mld_addr));
@


1.30
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.29 2013/10/14 11:07:42 mpi Exp $	*/
d132 1
a132 1
	    IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) < IPV6_ADDR_SCOPE_LINKLOCAL) {
d156 1
a156 1
	    IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) > IPV6_ADDR_SCOPE_INTFACELOCAL)
d247 2
a248 2
			    IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) <
			    IPV6_ADDR_SCOPE_LINKLOCAL)
@


1.29
log
@Change the macros used to iterate over the multicast records of an
interface to not depend on the global list of addresses.

For IPv4 the IP_TO_IA() macro still depends on the global list of
addresses because we want to be sure to grab the first configured
address of an interface, where the records are linked.

Tested by sthen@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.28 2011/11/24 17:39:55 sperreault Exp $	*/
d79 1
a79 1
#include <netinet/in_var.h>
@


1.28
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.27 2011/04/15 15:14:44 chl Exp $	*/
d92 1
d321 1
a321 1
mld6_fasttimeo()
d323 1
a323 2
	struct in6_multi *in6m;
	struct in6_multistep step;
d335 14
a348 2
	IN6_FIRST_MULTI(step, in6m);
	while (in6m != NULL) {
a356 1
		IN6_NEXT_MULTI(step, in6m);
a357 1
	splx(s);
@


1.27
log
@Remove dead assignment.

Found by LLVM/Clang Static Analyzer.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.26 2010/03/22 12:23:32 jsg Exp $	*/
d389 1
@


1.26
log
@Add some MLDv2 definitions from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.25 2008/06/11 19:00:50 mcbride Exp $	*/
d163 1
a163 1
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
@


1.25
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.24 2007/06/01 00:52:38 henning Exp $	*/
d83 1
a85 12
/*
 * Protocol constants
 */

/* denotes that the MLD max response delay field specifies time in milliseconds */
#define MLD_TIMER_SCALE	1000
/*
 * time between repetitions of a node's initial report of interest in a
 * multicast address(in seconds)
 */
#define MLD_UNSOLICITED_REPORT_INTERVAL	10

d137 1
a137 1
		    MLD_RANDOM_DELAY(MLD_UNSOLICITED_REPORT_INTERVAL *
@


1.24
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.23 2006/12/09 01:12:28 itojun Exp $	*/
d128 1
a128 2
mld6_start_listening(in6m)
	struct in6_multi *in6m;
d157 1
a157 2
mld6_stop_listening(in6m)
	struct in6_multi *in6m;
d172 1
a172 3
mld6_input(m, off)
	struct mbuf *m;
	int off;
d362 1
a362 4
mld6_sendpkt(in6m, type, dst)
	struct in6_multi *in6m;
	int type;
	const struct in6_addr *dst;
@


1.23
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.22 2006/11/17 01:11:23 itojun Exp $	*/
d465 2
a466 1
	ip6_output(mh, &ip6_opts, NULL, ia ? 0 : IPV6_UNSPECSRC, &im6o, NULL);
@


1.22
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.21 2006/05/27 23:40:27 claudio Exp $	*/
d120 1
a120 1
	hbh_buf[4] = IP6OPT_RTALERT;
a124 2
	/* We will specify the hoplimit by a multicast option. */
	ip6_opts.ip6po_hlim = -1;
@


1.21
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.20 2006/03/05 21:48:57 miod Exp $	*/
d170 1
a170 1
	    IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) > IPV6_ADDR_SCOPE_NODELOCAL)
@


1.20
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.19 2003/06/11 02:54:02 itojun Exp $	*/
d448 1
d450 1
@


1.19
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.18 2003/06/02 23:28:16 millert Exp $	*/
d260 1
a260 4
		for (in6m = ia->ia6_multiaddrs.lh_first;
		     in6m;
		     in6m = in6m->in6m_entry.le_next)
		{
@


1.18
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.17 2003/05/14 14:24:44 itojun Exp $	*/
d90 1
a90 1
#define MLD6_TIMER_SCALE	1000
d95 1
a95 1
#define MLD6_UNSOLICITED_REPORT_INTERVAL	10
d98 1
a98 1
static int mld6_timers_are_running;
d100 2
a101 2
static struct in6_addr mld6_all_nodes_linklocal = IN6ADDR_LINKLOCAL_ALLNODES_INIT;
static struct in6_addr mld6_all_routers_linklocal = IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;
d112 1
a112 1
	mld6_timers_are_running = 0;
d142 1
a142 1
	mld6_all_nodes_linklocal.s6_addr16[1] =
d144 1
a144 1
	if (IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld6_all_nodes_linklocal) ||
d147 1
a147 1
		in6m->in6m_state = MLD6_OTHERLISTENER;
d149 1
a149 1
		mld6_sendpkt(in6m, MLD6_LISTENER_REPORT, NULL);
d151 1
a151 1
		    MLD6_RANDOM_DELAY(MLD6_UNSOLICITED_REPORT_INTERVAL *
d153 2
a154 2
		in6m->in6m_state = MLD6_IREPORTEDLAST;
		mld6_timers_are_running = 1;
d163 1
a163 1
	mld6_all_nodes_linklocal.s6_addr16[1] =
d165 1
a165 1
	mld6_all_routers_linklocal.s6_addr16[1] =
d168 2
a169 2
	if (in6m->in6m_state == MLD6_IREPORTEDLAST &&
	    (!IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld6_all_nodes_linklocal)) &&
d171 2
a172 2
		mld6_sendpkt(in6m, MLD6_LISTENER_DONE,
		    &mld6_all_routers_linklocal);
d181 1
a181 1
	struct mld6_hdr *mldh;
d187 1
a187 1
	IP6_EXTHDR_GET(mldh, struct mld6_hdr *, m, off, sizeof(*mldh));
d198 1
a198 1
		    "mld6_input: src %s is not link-local (grp=%s)\n",
d200 1
a200 1
		    ip6_sprintf(&mldh->mld6_addr));
d218 2
a219 2
	 * The flag is in6m->in6m_state, it is set to MLD6_OTHERLISTENER if
	 * we have heard a report from another member, or MLD6_IREPORTEDLAST
d222 2
a223 2
	switch(mldh->mld6_type) {
	case MLD6_LISTENER_QUERY:
d227 2
a228 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&mldh->mld6_addr) &&
		    !IN6_IS_ADDR_MULTICAST(&mldh->mld6_addr))
d230 2
a231 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld6_addr))
			mldh->mld6_addr.s6_addr16[1] =
d254 2
a255 2
		timer = ntohs(mldh->mld6_maxdelay)*PR_FASTHZ/MLD6_TIMER_SCALE;
		if (timer == 0 && mldh->mld6_maxdelay)
d257 1
a257 1
		mld6_all_nodes_linklocal.s6_addr16[1] =
d265 1
a265 1
						&mld6_all_nodes_linklocal) ||
d270 2
a271 2
			if (IN6_IS_ADDR_UNSPECIFIED(&mldh->mld6_addr) ||
			    IN6_ARE_ADDR_EQUAL(&mldh->mld6_addr,
d276 1
a276 1
					mld6_sendpkt(in6m, MLD6_LISTENER_REPORT,
d279 1
a279 1
					in6m->in6m_state = MLD6_IREPORTEDLAST;
d283 2
a284 2
					    MLD6_RANDOM_DELAY(timer);
					mld6_timers_are_running = 1;
d289 2
a290 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld6_addr))
			mldh->mld6_addr.s6_addr16[1] = 0; /* XXX */
d292 1
a292 1
	case MLD6_LISTENER_REPORT:
d305 1
a305 1
		if (!IN6_IS_ADDR_MULTICAST(&mldh->mld6_addr))
d308 2
a309 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld6_addr))
			mldh->mld6_addr.s6_addr16[1] =
d315 1
a315 1
		IN6_LOOKUP_MULTI(mldh->mld6_addr, ifp, in6m);
d318 1
a318 1
			in6m->in6m_state = MLD6_OTHERLISTENER; /* clear flag */
d321 2
a322 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld6_addr))
			mldh->mld6_addr.s6_addr16[1] = 0; /* XXX */
d331 1
a331 1
		log(LOG_ERR, "mld6_input: illegal type(%d)", mldh->mld6_type);
d350 1
a350 1
	if (!mld6_timers_are_running)
d354 1
a354 1
	mld6_timers_are_running = 0;
d360 2
a361 2
			mld6_sendpkt(in6m, MLD6_LISTENER_REPORT, NULL);
			in6m->in6m_state = MLD6_IREPORTEDLAST;
d363 1
a363 1
			mld6_timers_are_running = 1;
d377 1
a377 1
	struct mld6_hdr *mldh;
d412 1
a412 1
	mh->m_pkthdr.len = sizeof(struct ip6_hdr) + sizeof(struct mld6_hdr);
d428 5
a432 5
	md->m_len = sizeof(struct mld6_hdr);
	mldh = mtod(md, struct mld6_hdr *);
	mldh->mld6_type = type;
	mldh->mld6_code = 0;
	mldh->mld6_cksum = 0;
d434 7
a440 7
	mldh->mld6_maxdelay = 0;
	mldh->mld6_reserved = 0;
	mldh->mld6_addr = in6m->in6m_addr;
	if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld6_addr))
		mldh->mld6_addr.s6_addr16[1] = 0; /* XXX */
	mldh->mld6_cksum = in6_cksum(mh, IPPROTO_ICMPV6, sizeof(struct ip6_hdr),
	    sizeof(struct mld6_hdr));
d457 1
a457 1
	case MLD6_LISTENER_QUERY:
d460 1
a460 1
	case MLD6_LISTENER_REPORT:
d463 1
a463 1
	case MLD6_LISTENER_DONE:
@


1.17
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.16 2002/06/09 14:38:39 itojun Exp $	*/
d49 1
a49 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.16
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.15 2002/06/08 21:51:08 itojun Exp $	*/
a190 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*mldh),);
	mldh = (struct mld6_hdr *)(mtod(m, caddr_t) + off);
#else
a195 1
#endif
@


1.15
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.14 2002/06/08 21:22:03 itojun Exp $	*/
d268 1
a268 1
		
@


1.14
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.13 2002/03/14 01:27:12 millert Exp $	*/
d137 1
a137 1
	int s = splnet();
d362 1
a362 1
	s = splnet();
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.12 2002/01/08 04:29:21 itojun Exp $	*/
d147 1
a147 1
		htons(in6m->in6m_ifp->if_index); /* XXX */
d154 3
a156 2
		in6m->in6m_timer = MLD6_RANDOM_DELAY(
			MLD6_UNSOLICITED_REPORT_INTERVAL * PR_FASTHZ);
d168 1
a168 1
		htons(in6m->in6m_ifp->if_index); /* XXX */
d170 1
a170 1
		htons(in6m->in6m_ifp->if_index); /* XXX: necessary when mrouting */
d176 1
a176 1
			     &mld6_all_routers_linklocal);
d241 1
a241 1
				htons(ifp->if_index); /* XXX */
d286 1
a286 1
						NULL);
d289 1
a289 2
				}
				else if (in6m->in6m_timer == 0 || /* idle */
d292 1
a292 1
						MLD6_RANDOM_DELAY(timer);
d335 5
a362 1

d391 1
a391 1
	struct ifnet *outif = NULL;
d396 2
d399 2
a400 2
	if ((ia = in6ifa_ifpforlinklocal(ifp, IN6_IFF_NOTREADY|IN6_IFF_ANYCAST))
	    == NULL)
d402 2
d420 1
d433 1
a433 1
	ip6->ip6_src = ia->ia_addr.sin6_addr;
d449 1
a449 1
				     sizeof(struct mld6_hdr));
d464 12
d477 1
a477 15
	ip6_output(mh, &ip6_opts, NULL, 0, &im6o, &outif);
	if (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		switch (type) {
		case MLD6_LISTENER_QUERY:
			icmp6_ifstat_inc(outif, ifs6_out_mldquery);
			break;
		case MLD6_LISTENER_REPORT:
			icmp6_ifstat_inc(outif, ifs6_out_mldreport);
			break;
		case MLD6_LISTENER_DONE:
			icmp6_ifstat_inc(outif, ifs6_out_mlddone);
			break;
		}
	}
@


1.12
log
@do not log() in per-packet input path.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.11 2001/12/07 09:16:07 itojun Exp $	*/
d107 1
a107 1
static void mld6_sendpkt __P((struct in6_multi *, int, const struct in6_addr *));
@


1.11
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.10 2001/06/09 06:43:38 angelos Exp $	*/
d204 1
d209 1
d334 1
d336 1
@


1.11.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.12 2002/01/08 04:29:21 itojun Exp $	*/
a203 1
#if 0
a207 1
#endif
a331 1
#if 0
a332 1
#endif
@


1.11.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.11.2.1 2002/01/31 22:55:46 niklas Exp $	*/
d107 1
a107 1
static void mld6_sendpkt(struct in6_multi *, int, const struct in6_addr *);
d137 1
a137 1
	int s = splsoftnet();
d147 1
a147 1
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d154 2
a155 3
		in6m->in6m_timer =
		    MLD6_RANDOM_DELAY(MLD6_UNSOLICITED_REPORT_INTERVAL *
		    PR_FASTHZ);
d167 1
a167 1
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d169 1
a169 1
	    htons(in6m->in6m_ifp->if_index); /* XXX: necessary when mrouting */
d175 1
a175 1
		    &mld6_all_routers_linklocal);
d240 1
a240 1
			    htons(ifp->if_index); /* XXX */
d285 1
a285 1
					    NULL);
d288 2
a289 1
				} else if (in6m->in6m_timer == 0 || /* idle */
d292 1
a292 1
					    MLD6_RANDOM_DELAY(timer);
a334 5
		/*
		 * this case should be impossible because of filtering in
		 * icmp6_input().  But we explicitly disabled this part
		 * just in case.
		 */
d357 2
a358 1
	s = splsoftnet();
d387 1
a387 1
	int ignflags;
a391 2
	 * We do not reject tentative addresses for MLD report to deal with
	 * the case where we first join a link-local address.
d393 2
a394 2
	ignflags = (IN6_IFF_NOTREADY|IN6_IFF_ANYCAST) & ~IN6_IFF_TENTATIVE;
	if ((ia = in6ifa_ifpforlinklocal(ifp, ignflags)) == NULL)
a395 2
	if ((ia->ia6_flags & IN6_IFF_TENTATIVE))
		ia = NULL;
a411 1
	mh->m_pkthdr.rcvif = NULL;
d424 1
a424 1
	ip6->ip6_src = ia ? ia->ia_addr.sin6_addr : in6addr_any;
d440 1
a440 1
	    sizeof(struct mld6_hdr));
d455 15
a469 11
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	switch (type) {
	case MLD6_LISTENER_QUERY:
		icmp6_ifstat_inc(ifp, ifs6_out_mldquery);
		break;
	case MLD6_LISTENER_REPORT:
		icmp6_ifstat_inc(ifp, ifs6_out_mldreport);
		break;
	case MLD6_LISTENER_DONE:
		icmp6_ifstat_inc(ifp, ifs6_out_mlddone);
		break;
a470 2

	ip6_output(mh, &ip6_opts, NULL, ia ? 0 : IPV6_UNSPECSRC, &im6o, NULL);
@


1.11.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.11.2.2 2002/06/11 03:31:37 art Exp $	*/
d268 1
a268 1

@


1.11.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d191 4
d200 1
@


1.10
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.9 2001/02/16 16:00:58 itojun Exp $	*/
a211 1
		 * XXX: do we have to allow :: as source?
d287 1
a287 1
				else if (in6m->in6m_timer == 0 || /*idle state*/
@


1.9
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.8 2001/02/16 08:48:06 itojun Exp $	*/
a87 2

#include <net/net_osdep.h>
@


1.8
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 2
a2 2
/*	$OpenBSD: mld6.c,v 1.7 2001/02/16 08:22:06 itojun Exp $	*/
/*	$KAME: mld6.c,v 1.25 2001/01/16 14:14:18 itojun Exp $	*/
d192 11
d204 1
d207 3
a209 2
		    "mld6_input: src %s is not link-local\n",
		    ip6_sprintf(&ip6->ip6_src));
d214 1
a219 11
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*mldh),);
	mldh = (struct mld6_hdr *)(mtod(m, caddr_t) + off);
#else
	IP6_EXTHDR_GET(mldh, struct mld6_hdr *, m, off, sizeof(*mldh));
	if (mldh == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif

d237 1
a237 1
		!IN6_IS_ADDR_MULTICAST(&mldh->mld6_addr))
@


1.7
log
@kill register declarations.  to sync with kame better.
@
text
@d1 2
a2 2
/*	$OpenBSD: mld6.c,v 1.6 2000/02/28 11:55:22 itojun Exp $	*/
/*	$KAME: mld6.c,v 1.16 2000/02/22 14:04:27 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d455 10
a464 10
		switch(type) {
		 case MLD6_LISTENER_QUERY:
			 icmp6_ifstat_inc(outif, ifs6_out_mldquery);
			 break;
		 case MLD6_LISTENER_REPORT:
			 icmp6_ifstat_inc(outif, ifs6_out_mldreport);
			 break;
		 case MLD6_LISTENER_DONE:
			 icmp6_ifstat_inc(outif, ifs6_out_mlddone);
			 break;
@


1.6
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.5 2000/02/07 06:09:10 itojun Exp $	*/
d342 1
a342 1
	register struct in6_multi *in6m;
@


1.5
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: mld6.c,v 1.4 2000/01/08 05:49:40 angelos Exp $	*/
d121 1
a121 1
	hbh->ip6h_len = 0;	/* (8 >> 3) - 1*/
d142 1
a142 1
	 * (draft-ietf-ipngwg-mld, page 10)
d186 1
a186 1
	struct mld6_hdr *mldh = (struct mld6_hdr *)(mtod(m, caddr_t) + off);
d198 1
a198 1
		 * spec(draft-ietf-ipngwg-mld) does not explicitly
d202 1
d206 11
d241 9
a249 9
		* - Start the timers in all of our membership records
		*   that the query applies to for the interface on
		*   which the query arrived excl. those that belong
		*   to the "all-nodes" group (ff02::1).
		* - Restart any timer that is already running but has
		*   A value longer than the requested timeout.
		* - Use the value specified in the query message as
		*   the maximum timeout.
		*/
d255 5
a259 5
		* XXX: System timer resolution is too low to handle Max
		* Response Delay, so set 1 to the internal timer even if
		* the calculated value equals to zero when Max Response
		* Delay is positive.
		*/
d301 8
a308 8
		* For fast leave to work, we have to know that we are the
		* last person to send a report for this group.  Reports
		* can potentially get looped back if we are a multicast
		* router, so discard reports sourced by me.
		* Note that it is impossible to check IFF_LOOPBACK flag of
		* ifp for this purpose, since ip6_mloopback pass the physical
		* interface to looutput.
		*/
d319 3
a321 3
		* If we belong to the group being reported, stop
		* our timer for that group.
		*/
d335 2
d389 2
a390 1
	if ((ia = in6ifa_ifpforlinklocal(ifp)) == NULL)
@


1.5.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: mld6.c,v 1.16 2000/02/22 14:04:27 itojun Exp $	*/
d120 1
a120 1
	hbh->ip6h_len = 0;	/* (8 >> 3) - 1 */
d141 1
a141 1
	 * RFC2710 page 10:
d185 1
a185 1
	struct mld6_hdr *mldh;
d197 1
a197 1
		 * spec (RFC2710) does not explicitly
a200 1
		m_freem(m);
a203 11
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*mldh),);
	mldh = (struct mld6_hdr *)(mtod(m, caddr_t) + off);
#else
	IP6_EXTHDR_GET(mldh, struct mld6_hdr *, m, off, sizeof(*mldh));
	if (mldh == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif

d228 9
a236 9
		 * - Start the timers in all of our membership records
		 *   that the query applies to for the interface on
		 *   which the query arrived excl. those that belong
		 *   to the "all-nodes" group (ff02::1).
		 * - Restart any timer that is already running but has
		 *   A value longer than the requested timeout.
		 * - Use the value specified in the query message as
		 *   the maximum timeout.
		 */
d242 5
a246 5
		 * XXX: System timer resolution is too low to handle Max
		 * Response Delay, so set 1 to the internal timer even if
		 * the calculated value equals to zero when Max Response
		 * Delay is positive.
		 */
d288 8
a295 8
		 * For fast leave to work, we have to know that we are the
		 * last person to send a report for this group.  Reports
		 * can potentially get looped back if we are a multicast
		 * router, so discard reports sourced by me.
		 * Note that it is impossible to check IFF_LOOPBACK flag of
		 * ifp for this purpose, since ip6_mloopback pass the physical
		 * interface to looutput.
		 */
d306 3
a308 3
		 * If we belong to the group being reported, stop
		 * our timer for that group.
		 */
a321 2

	m_freem(m);
d374 1
a374 2
	if ((ia = in6ifa_ifpforlinklocal(ifp, IN6_IFF_NOTREADY|IN6_IFF_ANYCAST))
	    == NULL)
@


1.5.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: mld6.c,v 1.9 2001/02/16 16:00:58 itojun Exp $	*/
/*	$KAME: mld6.c,v 1.26 2001/02/16 14:50:35 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a191 11
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(*mldh),);
	mldh = (struct mld6_hdr *)(mtod(m, caddr_t) + off);
#else
	IP6_EXTHDR_GET(mldh, struct mld6_hdr *, m, off, sizeof(*mldh));
	if (mldh == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif

a192 1
	ip6 = mtod(m, struct ip6_hdr *);/* in case mpullup */
d195 2
a196 3
		    "mld6_input: src %s is not link-local (grp=%s)\n",
		    ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&mldh->mld6_addr));
a200 1
		 * XXX: do we have to allow :: as source?
d206 11
d234 1
a234 1
		    !IN6_IS_ADDR_MULTICAST(&mldh->mld6_addr))
d342 1
a342 1
	struct in6_multi *in6m;
d455 10
a464 10
		switch (type) {
		case MLD6_LISTENER_QUERY:
			icmp6_ifstat_inc(outif, ifs6_out_mldquery);
			break;
		case MLD6_LISTENER_REPORT:
			icmp6_ifstat_inc(outif, ifs6_out_mldreport);
			break;
		case MLD6_LISTENER_DONE:
			icmp6_ifstat_inc(outif, ifs6_out_mlddone);
			break;
@


1.5.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.5.2.2 2001/05/14 22:40:19 niklas Exp $	*/
d88 2
@


1.5.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a203 1
#if 0
a207 1
#endif
d212 1
d288 1
a288 1
				else if (in6m->in6m_timer == 0 || /* idle */
a332 1
#if 0
a333 1
#endif
@


1.5.2.5
log
@Merge in -current from roughly a week ago
@
text
@d107 1
a107 1
static void mld6_sendpkt(struct in6_multi *, int, const struct in6_addr *);
@


1.5.2.6
log
@Sync the SMP branch with 3.3
@
text
@d137 1
a137 1
	int s = splsoftnet();
d147 1
a147 1
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d154 2
a155 3
		in6m->in6m_timer =
		    MLD6_RANDOM_DELAY(MLD6_UNSOLICITED_REPORT_INTERVAL *
		    PR_FASTHZ);
d167 1
a167 1
	    htons(in6m->in6m_ifp->if_index); /* XXX */
d169 1
a169 1
	    htons(in6m->in6m_ifp->if_index); /* XXX: necessary when mrouting */
d175 1
a175 1
		    &mld6_all_routers_linklocal);
d240 1
a240 1
			    htons(ifp->if_index); /* XXX */
d267 1
a267 1

d285 1
a285 1
					    NULL);
d288 2
a289 1
				} else if (in6m->in6m_timer == 0 || /* idle */
d292 1
a292 1
					    MLD6_RANDOM_DELAY(timer);
a334 5
		/*
		 * this case should be impossible because of filtering in
		 * icmp6_input().  But we explicitly disabled this part
		 * just in case.
		 */
d357 2
a358 1
	s = splsoftnet();
d387 1
a387 1
	int ignflags;
a391 2
	 * We do not reject tentative addresses for MLD report to deal with
	 * the case where we first join a link-local address.
d393 2
a394 2
	ignflags = (IN6_IFF_NOTREADY|IN6_IFF_ANYCAST) & ~IN6_IFF_TENTATIVE;
	if ((ia = in6ifa_ifpforlinklocal(ifp, ignflags)) == NULL)
a395 2
	if ((ia->ia6_flags & IN6_IFF_TENTATIVE))
		ia = NULL;
a411 1
	mh->m_pkthdr.rcvif = NULL;
d424 1
a424 1
	ip6->ip6_src = ia ? ia->ia_addr.sin6_addr : in6addr_any;
d440 1
a440 1
	    sizeof(struct mld6_hdr));
d455 15
a469 11
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	switch (type) {
	case MLD6_LISTENER_QUERY:
		icmp6_ifstat_inc(ifp, ifs6_out_mldquery);
		break;
	case MLD6_LISTENER_REPORT:
		icmp6_ifstat_inc(ifp, ifs6_out_mldreport);
		break;
	case MLD6_LISTENER_DONE:
		icmp6_ifstat_inc(ifp, ifs6_out_mlddone);
		break;
a470 2

	ip6_output(mh, &ip6_opts, NULL, ia ? 0 : IPV6_UNSPECSRC, &im6o, NULL);
@


1.5.2.7
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d191 4
d200 1
@


1.5.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.5.2.7 2003/05/16 00:29:44 niklas Exp $	*/
d49 5
a53 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.5.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d90 1
a90 1
#define MLD_TIMER_SCALE	1000
d95 1
a95 1
#define MLD_UNSOLICITED_REPORT_INTERVAL	10
d98 1
a98 1
static int mld_timers_are_running;
d100 2
a101 2
static struct in6_addr mld_all_nodes_linklocal = IN6ADDR_LINKLOCAL_ALLNODES_INIT;
static struct in6_addr mld_all_routers_linklocal = IN6ADDR_LINKLOCAL_ALLROUTERS_INIT;
d112 1
a112 1
	mld_timers_are_running = 0;
d142 1
a142 1
	mld_all_nodes_linklocal.s6_addr16[1] =
d144 1
a144 1
	if (IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld_all_nodes_linklocal) ||
d147 1
a147 1
		in6m->in6m_state = MLD_OTHERLISTENER;
d149 1
a149 1
		mld6_sendpkt(in6m, MLD_LISTENER_REPORT, NULL);
d151 1
a151 1
		    MLD_RANDOM_DELAY(MLD_UNSOLICITED_REPORT_INTERVAL *
d153 2
a154 2
		in6m->in6m_state = MLD_IREPORTEDLAST;
		mld_timers_are_running = 1;
d163 1
a163 1
	mld_all_nodes_linklocal.s6_addr16[1] =
d165 1
a165 1
	mld_all_routers_linklocal.s6_addr16[1] =
d168 2
a169 2
	if (in6m->in6m_state == MLD_IREPORTEDLAST &&
	    (!IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr, &mld_all_nodes_linklocal)) &&
d171 2
a172 2
		mld6_sendpkt(in6m, MLD_LISTENER_DONE,
		    &mld_all_routers_linklocal);
d181 1
a181 1
	struct mld_hdr *mldh;
d187 1
a187 1
	IP6_EXTHDR_GET(mldh, struct mld_hdr *, m, off, sizeof(*mldh));
d198 1
a198 1
		    "mld_input: src %s is not link-local (grp=%s)\n",
d200 1
a200 1
		    ip6_sprintf(&mldh->mld_addr));
d218 2
a219 2
	 * The flag is in6m->in6m_state, it is set to MLD_OTHERLISTENER if
	 * we have heard a report from another member, or MLD_IREPORTEDLAST
d222 2
a223 2
	switch(mldh->mld_type) {
	case MLD_LISTENER_QUERY:
d227 2
a228 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&mldh->mld_addr) &&
		    !IN6_IS_ADDR_MULTICAST(&mldh->mld_addr))
d230 2
a231 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] =
d254 2
a255 2
		timer = ntohs(mldh->mld_maxdelay)*PR_FASTHZ/MLD_TIMER_SCALE;
		if (timer == 0 && mldh->mld_maxdelay)
d257 1
a257 1
		mld_all_nodes_linklocal.s6_addr16[1] =
d265 1
a265 1
						&mld_all_nodes_linklocal) ||
d270 2
a271 2
			if (IN6_IS_ADDR_UNSPECIFIED(&mldh->mld_addr) ||
			    IN6_ARE_ADDR_EQUAL(&mldh->mld_addr,
d276 1
a276 1
					mld6_sendpkt(in6m, MLD_LISTENER_REPORT,
d279 1
a279 1
					in6m->in6m_state = MLD_IREPORTEDLAST;
d283 2
a284 2
					    MLD_RANDOM_DELAY(timer);
					mld_timers_are_running = 1;
d289 2
a290 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
d292 1
a292 1
	case MLD_LISTENER_REPORT:
d305 1
a305 1
		if (!IN6_IS_ADDR_MULTICAST(&mldh->mld_addr))
d308 2
a309 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] =
d315 1
a315 1
		IN6_LOOKUP_MULTI(mldh->mld_addr, ifp, in6m);
d318 1
a318 1
			in6m->in6m_state = MLD_OTHERLISTENER; /* clear flag */
d321 2
a322 2
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
			mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
d331 1
a331 1
		log(LOG_ERR, "mld_input: illegal type(%d)", mldh->mld_type);
d350 1
a350 1
	if (!mld_timers_are_running)
d354 1
a354 1
	mld_timers_are_running = 0;
d360 2
a361 2
			mld6_sendpkt(in6m, MLD_LISTENER_REPORT, NULL);
			in6m->in6m_state = MLD_IREPORTEDLAST;
d363 1
a363 1
			mld_timers_are_running = 1;
d377 1
a377 1
	struct mld_hdr *mldh;
d412 1
a412 1
	mh->m_pkthdr.len = sizeof(struct ip6_hdr) + sizeof(struct mld_hdr);
d428 5
a432 5
	md->m_len = sizeof(struct mld_hdr);
	mldh = mtod(md, struct mld_hdr *);
	mldh->mld_type = type;
	mldh->mld_code = 0;
	mldh->mld_cksum = 0;
d434 7
a440 7
	mldh->mld_maxdelay = 0;
	mldh->mld_reserved = 0;
	mldh->mld_addr = in6m->in6m_addr;
	if (IN6_IS_ADDR_MC_LINKLOCAL(&mldh->mld_addr))
		mldh->mld_addr.s6_addr16[1] = 0; /* XXX */
	mldh->mld_cksum = in6_cksum(mh, IPPROTO_ICMPV6, sizeof(struct ip6_hdr),
	    sizeof(struct mld_hdr));
d457 1
a457 1
	case MLD_LISTENER_QUERY:
d460 1
a460 1
	case MLD_LISTENER_REPORT:
d463 1
a463 1
	case MLD_LISTENER_DONE:
@


1.4
log
@Missing rndvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.3 1999/12/15 07:08:00 itojun Exp $	*/
d83 1
a83 1
#include <netinet6/ip6.h>
d85 1
a85 1
#include <netinet6/icmp6.h>
@


1.3
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d77 1
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: mld6.c,v 1.1 1999/12/08 06:50:23 itojun Exp $	*/
d398 2
a399 1
	ip6->ip6_vfc = IPV6_VERSION;
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a70 7
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a136 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
a137 1
#endif
a187 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	struct ifmultiaddr *ifma;
#endif
a251 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		LIST_FOREACH(ifma, &ifp->if_multiaddrs, ifma_link)
#else
a254 1
#endif
a255 10
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			if (ifma->ifma_addr->sa_family != AF_INET6)
				continue;
			in6m = (struct in6_multi *)ifma->ifma_protospec;
			if (IN6_ARE_ADDR_EQUAL(&in6m->in6m_addr,
					&mld6_all_nodes_linklocal) ||
			    IPV6_ADDR_MC_SCOPE(&in6m->in6m_addr) <
			    IPV6_ADDR_SCOPE_LINKLOCAL)
				continue;
#else
a260 1
#endif
a336 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d338 1
a338 1
#endif
a390 5
#ifdef IPSEC
#ifndef __OpenBSD__ /*KAME IPSEC*/
	mh->m_pkthdr.rcvif = NULL;
#endif
#endif 
@

