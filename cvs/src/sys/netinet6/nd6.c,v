head	1.213;
access;
symbols
	OPENBSD_6_1:1.207.0.4
	OPENBSD_6_1_BASE:1.207
	OPENBSD_6_0:1.188.0.2
	OPENBSD_6_0_BASE:1.188
	OPENBSD_5_9:1.176.0.2
	OPENBSD_5_9_BASE:1.176
	OPENBSD_5_8:1.143.0.4
	OPENBSD_5_8_BASE:1.143
	OPENBSD_5_7:1.131.0.2
	OPENBSD_5_7_BASE:1.131
	OPENBSD_5_6:1.120.0.4
	OPENBSD_5_6_BASE:1.120
	OPENBSD_5_5:1.111.0.4
	OPENBSD_5_5_BASE:1.111
	OPENBSD_5_4:1.99.0.2
	OPENBSD_5_4_BASE:1.99
	OPENBSD_5_3:1.93.0.2
	OPENBSD_5_3_BASE:1.93
	OPENBSD_5_2:1.91.0.4
	OPENBSD_5_2_BASE:1.91
	OPENBSD_5_1_BASE:1.91
	OPENBSD_5_1:1.91.0.2
	OPENBSD_5_0:1.87.0.2
	OPENBSD_5_0_BASE:1.87
	OPENBSD_4_9:1.85.0.4
	OPENBSD_4_9_BASE:1.85
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.82.0.6
	OPENBSD_4_6_BASE:1.82
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.79.0.2
	OPENBSD_4_4_BASE:1.79
	OPENBSD_4_3:1.75.0.2
	OPENBSD_4_3_BASE:1.75
	OPENBSD_4_2:1.74.0.2
	OPENBSD_4_2_BASE:1.74
	OPENBSD_4_1:1.72.0.4
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.72.0.2
	OPENBSD_4_0_BASE:1.72
	OPENBSD_3_9:1.70.0.2
	OPENBSD_3_9_BASE:1.70
	OPENBSD_3_8:1.69.0.2
	OPENBSD_3_8_BASE:1.69
	OPENBSD_3_7:1.68.0.2
	OPENBSD_3_7_BASE:1.68
	OPENBSD_3_6:1.67.0.2
	OPENBSD_3_6_BASE:1.67
	SMP_SYNC_A:1.66
	SMP_SYNC_B:1.66
	OPENBSD_3_5:1.65.0.4
	OPENBSD_3_5_BASE:1.65
	OPENBSD_3_4:1.65.0.2
	OPENBSD_3_4_BASE:1.65
	UBC_SYNC_A:1.60
	OPENBSD_3_3:1.60.0.2
	OPENBSD_3_3_BASE:1.60
	OPENBSD_3_2:1.58.0.2
	OPENBSD_3_2_BASE:1.58
	OPENBSD_3_1:1.41.0.2
	OPENBSD_3_1_BASE:1.41
	UBC_SYNC_B:1.60
	UBC:1.39.0.2
	UBC_BASE:1.39
	OPENBSD_3_0:1.37.0.2
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.19.0.2
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.13.0.2
	OPENBSD_2_7_BASE:1.13
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.213
date	2017.08.06.12.53.30;	author mpi;	state Exp;
branches;
next	1.212;
commitid	YPSh8d6aoigAuhTc;

1.212
date	2017.08.04.21.33.09;	author bluhm;	state Exp;
branches;
next	1.211;
commitid	TWwEuiAxf1Ip7iAE;

1.211
date	2017.07.12.16.53.58;	author florian;	state Exp;
branches;
next	1.210;
commitid	P3S1WvuGoZI0WHQU;

1.210
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.209;
commitid	iTlWhLM2orYZnz27;

1.209
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.208;
commitid	SAe3SQ48vKH6r5FL;

1.208
date	2017.05.09.09.32.21;	author mpi;	state Exp;
branches;
next	1.207;
commitid	q3npONWGmkKWDryz;

1.207
date	2017.03.26.08.49.22;	author mpi;	state Exp;
branches;
next	1.206;
commitid	zbLkYjYt5FKTVVKi;

1.206
date	2017.03.08.09.34.43;	author mpi;	state Exp;
branches;
next	1.205;
commitid	4uQg3AXbzco1aSbd;

1.205
date	2017.03.03.08.01.59;	author mpi;	state Exp;
branches;
next	1.204;
commitid	Ud1lzGLP6pF8MV5k;

1.204
date	2017.03.02.09.24.02;	author mpi;	state Exp;
branches;
next	1.203;
commitid	61C3ZsdwfhYDTHad;

1.203
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.202;
commitid	1ap8YFU49Zg4mM41;

1.202
date	2016.12.27.18.45.01;	author bluhm;	state Exp;
branches;
next	1.201;
commitid	iX6wHULmb2OvfsDR;

1.201
date	2016.12.23.15.08.54;	author mpi;	state Exp;
branches;
next	1.200;
commitid	V6BHBxnI4mL3Stov;

1.200
date	2016.12.22.13.39.32;	author mpi;	state Exp;
branches;
next	1.199;
commitid	nLPA84mESw8iBVkC;

1.199
date	2016.12.20.18.33.43;	author bluhm;	state Exp;
branches;
next	1.198;
commitid	xiXE7MGPpVXw2TS3;

1.198
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.197;
commitid	QqHqT2WhCBWqYgGJ;

1.197
date	2016.11.28.14.14.39;	author mpi;	state Exp;
branches;
next	1.196;
commitid	6k4TK07Jp4xe3PKg;

1.196
date	2016.11.28.13.59.51;	author mpi;	state Exp;
branches;
next	1.195;
commitid	gDeAqDskWelvIYpy;

1.195
date	2016.11.15.13.12.24;	author mpi;	state Exp;
branches;
next	1.194;
commitid	SCLErSMVUhSEzpgl;

1.194
date	2016.11.07.09.19.46;	author mpi;	state Exp;
branches;
next	1.193;
commitid	8MXPiDh6e0wDQBK2;

1.193
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.192;
commitid	ymldqUr8o0SRU6R6;

1.192
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.191;
commitid	RlO92XR575sygHqm;

1.191
date	2016.09.06.00.04.15;	author dlg;	state Exp;
branches;
next	1.190;
commitid	UqrCCAsrdk9XuY5o;

1.190
date	2016.08.22.16.01.52;	author mpi;	state Exp;
branches;
next	1.189;
commitid	Jx7agqiuXqs8RRGd;

1.189
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.188;
commitid	ZsKqEaqTKPu9hWk6;

1.188
date	2016.07.13.08.40.46;	author mpi;	state Exp;
branches;
next	1.187;
commitid	VkTTZG0LgjCK3eLa;

1.187
date	2016.07.13.01.51.22;	author dlg;	state Exp;
branches;
next	1.186;
commitid	Kr2q4p4N1KP0TwKx;

1.186
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.185;
commitid	qWegq9wDcxofLjIV;

1.185
date	2016.06.08.12.57.58;	author mpi;	state Exp;
branches;
next	1.184;
commitid	3tTbgX0YOYAZziFF;

1.184
date	2016.06.06.10.16.23;	author sthen;	state Exp;
branches;
next	1.183;
commitid	sykty0muT7cvktJh;

1.183
date	2016.06.03.02.08.15;	author dlg;	state Exp;
branches;
next	1.182;
commitid	BkKESDeTKSsG43Rr;

1.182
date	2016.06.01.23.45.19;	author dlg;	state Exp;
branches;
next	1.181;
commitid	FDsCC33tBdAholzy;

1.181
date	2016.05.31.07.50.34;	author mpi;	state Exp;
branches;
next	1.180;
commitid	JZitDEJ6k3XYEJzU;

1.180
date	2016.05.30.23.37.37;	author dlg;	state Exp;
branches;
next	1.179;
commitid	v39nTE5MxW6gairp;

1.179
date	2016.05.17.08.29.14;	author mpi;	state Exp;
branches;
next	1.178;
commitid	sGeRPBaMaAB3Medz;

1.178
date	2016.04.27.14.47.27;	author mpi;	state Exp;
branches;
next	1.177;
commitid	ZVQDfnkyjDaQ3PD4;

1.177
date	2016.03.07.11.00.36;	author mpi;	state Exp;
branches;
next	1.176;
commitid	Uq5gx2J1EnNGXZCu;

1.176
date	2015.12.03.21.57.59;	author mpi;	state Exp;
branches;
next	1.175;
commitid	nmbu8xP0zmz2PPN0;

1.175
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.174;
commitid	i3XNpYhaQ8QndxLo;

1.174
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.173;
commitid	Hf3C2AvfIXmCAmHE;

1.173
date	2015.12.01.12.22.18;	author mpi;	state Exp;
branches;
next	1.172;
commitid	GDLfKcd5eCBWNroc;

1.172
date	2015.11.06.11.20.56;	author mpi;	state Exp;
branches;
next	1.171;
commitid	oU39GoDixhmOhYXK;

1.171
date	2015.11.02.12.51.16;	author bluhm;	state Exp;
branches;
next	1.170;
commitid	Oukwozy6YPj2qdBN;

1.170
date	2015.11.02.07.24.08;	author mpi;	state Exp;
branches;
next	1.169;
commitid	j3heHwF6pc3KZsrO;

1.169
date	2015.11.01.22.53.34;	author bluhm;	state Exp;
branches;
next	1.168;
commitid	SPUVPLtJBuItBhCm;

1.168
date	2015.11.01.17.02.44;	author bluhm;	state Exp;
branches;
next	1.167;
commitid	YgeBnklLfVXYQQ6A;

1.167
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.166;
commitid	7wrRch1SS813fOcY;

1.166
date	2015.10.29.14.28.34;	author mpi;	state Exp;
branches;
next	1.165;
commitid	yFUHhXZI9PasRfkP;

1.165
date	2015.10.28.12.45.44;	author jsg;	state Exp;
branches;
next	1.164;
commitid	2XLmuAwI70rmUnnr;

1.164
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.163;
commitid	Ajb0hNGeCqGFHjjg;

1.163
date	2015.10.27.10.52.18;	author mpi;	state Exp;
branches;
next	1.162;
commitid	pUxjPEbAeKZSbuEi;

1.162
date	2015.10.25.15.11.52;	author deraadt;	state Exp;
branches;
next	1.161;
commitid	QgLg6oK4tAFgz474;

1.161
date	2015.10.25.15.01.59;	author mpi;	state Exp;
branches;
next	1.160;
commitid	y7UrrAmR7zcM69wb;

1.160
date	2015.10.25.11.58.11;	author mpi;	state Exp;
branches;
next	1.159;
commitid	G2nTzngqgXpQqcJB;

1.159
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.158;
commitid	xFxvBxiFybIsZNMc;

1.158
date	2015.10.22.16.44.54;	author mpi;	state Exp;
branches;
next	1.157;
commitid	jjvpHaNPWhqZPQGN;

1.157
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.156;
commitid	tp9bS9eCrwvRYjyO;

1.156
date	2015.10.22.10.27.22;	author mpi;	state Exp;
branches;
next	1.155;
commitid	8DZsNU5XzTi2Xq5W;

1.155
date	2015.10.01.09.10.22;	author mpi;	state Exp;
branches;
next	1.154;
commitid	sQ37WCwkRCa5qbhr;

1.154
date	2015.09.18.14.26.22;	author mpi;	state Exp;
branches;
next	1.153;
commitid	hGprk1rxxzKhgpj5;

1.153
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.152;
commitid	zZXiESHR0g5lNO0l;

1.152
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.151;
commitid	L7FukNYlBzoQuXvw;

1.151
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.150;
commitid	UM7jfgLT8vWQUBm1;

1.150
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.149;
commitid	PcRGyy4jlpJbKkXz;

1.149
date	2015.08.31.10.03.47;	author mpi;	state Exp;
branches;
next	1.148;
commitid	8UHdQ4P9tiBrYUaa;

1.148
date	2015.08.24.23.26.43;	author mpi;	state Exp;
branches;
next	1.147;
commitid	RvboqW7afhR7jBgv;

1.147
date	2015.08.24.14.00.29;	author bluhm;	state Exp;
branches;
next	1.146;
commitid	0LcoZC9QTu9wgpyX;

1.146
date	2015.08.23.14.12.05;	author naddy;	state Exp;
branches;
next	1.145;
commitid	7ZJGrCYKkPxvwAk3;

1.145
date	2015.08.19.13.27.38;	author bluhm;	state Exp;
branches;
next	1.144;
commitid	t09qBDKQRv4jxgp3;

1.144
date	2015.08.17.09.58.10;	author mpi;	state Exp;
branches;
next	1.143;
commitid	MqJQ3OEAaT3r4fe4;

1.143
date	2015.07.16.15.31.35;	author mpi;	state Exp;
branches;
next	1.142;
commitid	syrAtzfOhwI3Ygjb;

1.142
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.141;
commitid	ncpqEGjDtSFuLAgn;

1.141
date	2015.07.15.21.37.06;	author mpi;	state Exp;
branches;
next	1.140;
commitid	yCn141ng1kj3HhnZ;

1.140
date	2015.07.09.05.45.25;	author mpi;	state Exp;
branches;
next	1.139;
commitid	3lzuz5T7djZWDJfj;

1.139
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.138;
commitid	h7z8lokZ0dFyuWpg;

1.138
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.137;
commitid	4Ro7ulidQXNcMvmM;

1.137
date	2015.06.06.09.31.53;	author mpi;	state Exp;
branches;
next	1.136;
commitid	s2reBV7hfZ6x326r;

1.136
date	2015.05.15.12.00.57;	author claudio;	state Exp;
branches;
next	1.135;
commitid	Gl6pqKOqk2n9Lwhq;

1.135
date	2015.04.27.14.51.44;	author mpi;	state Exp;
branches;
next	1.134;
commitid	h3YrO0fhNQbIyJUl;

1.134
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.133;
commitid	6glXvFR7NxzCcdRd;

1.133
date	2015.03.25.17.39.33;	author florian;	state Exp;
branches;
next	1.132;
commitid	pQamb99i6SEFuStR;

1.132
date	2015.03.14.17.13.44;	author mpi;	state Exp;
branches;
next	1.131;
commitid	UCbOr3TpgfoUkbPj;

1.131
date	2015.02.11.23.34.43;	author mpi;	state Exp;
branches;
next	1.130;
commitid	LEl6vk7rMjn9Mb2M;

1.130
date	2015.01.27.03.17.36;	author dlg;	state Exp;
branches;
next	1.129;
commitid	MyKPm9Q3dQu92BiX;

1.129
date	2015.01.08.14.29.18;	author mpi;	state Exp;
branches;
next	1.128;
commitid	WNXddVtZkuvCWdN4;

1.128
date	2014.12.22.11.05.53;	author mpi;	state Exp;
branches;
next	1.127;
commitid	ZiNnf658AJiR4Tll;

1.127
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.126;
commitid	F3Fu23ZZ8dwzir4r;

1.126
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.125;
commitid	StxeqV93bwujMj7n;

1.125
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.124;
commitid	Z1vcFtHO8wRH0yRt;

1.124
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.123;
commitid	w0MRp28dmfD1ZzO8;

1.123
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.122;
commitid	6AYfDT0Lpez1LFQp;

1.122
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.121;
commitid	fUNtd3qRJAn6fam0;

1.121
date	2014.08.11.13.51.07;	author mpi;	state Exp;
branches;
next	1.120;
commitid	a2PeiXPSryHFEtwq;

1.120
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.119;
commitid	B4dZSbxas1X1IpXI;

1.119
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.118;
commitid	AGagL83SRBC6d7e7;

1.118
date	2014.06.07.11.04.14;	author henning;	state Exp;
branches;
next	1.117;
commitid	3AS3WOjnaTtfOf9y;

1.117
date	2014.05.15.09.05.13;	author mpi;	state Exp;
branches;
next	1.116;

1.116
date	2014.05.07.08.14.59;	author mpi;	state Exp;
branches;
next	1.115;

1.115
date	2014.05.05.11.44.33;	author mpi;	state Exp;
branches;
next	1.114;

1.114
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.113;

1.113
date	2014.03.27.10.39.23;	author mpi;	state Exp;
branches;
next	1.112;

1.112
date	2014.03.11.10.31.29;	author mpi;	state Exp;
branches;
next	1.111;

1.111
date	2014.02.17.21.36.05;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2014.01.22.13.19.12;	author mpi;	state Exp;
branches;
next	1.109;

1.109
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.108;

1.108
date	2014.01.10.14.29.08;	author tedu;	state Exp;
branches;
next	1.107;

1.107
date	2014.01.09.21.57.52;	author tedu;	state Exp;
branches;
next	1.106;

1.106
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.105;

1.105
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.10.28.12.33.32;	author mpi;	state Exp;
branches;
next	1.103;

1.103
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.102;

1.102
date	2013.08.28.06.58.57;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.08.26.07.15.58;	author bluhm;	state Exp;
branches;
next	1.100;

1.100
date	2013.08.13.05.52.25;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.98;

1.98
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.96;

1.96
date	2013.03.22.00.59.25;	author bluhm;	state Exp;
branches;
next	1.95;

1.95
date	2013.03.11.14.08.04;	author mpi;	state Exp;
branches;
next	1.94;

1.94
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.93;

1.93
date	2013.01.15.10.15.19;	author bluhm;	state Exp;
branches;
next	1.92;

1.92
date	2012.09.19.09.47.25;	author bluhm;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.90;

1.90
date	2011.12.27.17.20.04;	author bluhm;	state Exp;
branches;
next	1.89;

1.89
date	2011.12.02.03.15.31;	author haesbaert;	state Exp;
branches;
next	1.88;

1.88
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.87;

1.87
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.86;

1.86
date	2011.03.09.23.31.24;	author bluhm;	state Exp;
branches;
next	1.85;

1.85
date	2010.06.28.16.48.15;	author bluhm;	state Exp;
branches;
next	1.84;

1.84
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.83;

1.83
date	2010.02.08.11.56.09;	author jsing;	state Exp;
branches;
next	1.82;

1.82
date	2009.01.30.11.56.59;	author rainer;	state Exp;
branches;
next	1.81;

1.81
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.80;

1.80
date	2008.09.17.05.43.14;	author chl;	state Exp;
branches;
next	1.79;

1.79
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.78;

1.78
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.77;

1.77
date	2008.05.11.08.13.02;	author claudio;	state Exp;
branches;
next	1.76;

1.76
date	2008.05.11.03.50.23;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2007.10.01.16.39.30;	author krw;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.08.09.31.38;	author henning;	state Exp;
branches;
next	1.73;

1.73
date	2007.05.28.22.17.21;	author pyr;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.16.15.41.19;	author pascoe;	state Exp;
branches;
next	1.70;

1.70
date	2006.02.21.10.23.25;	author markus;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.09.05.37.36;	author brad;	state Exp;
branches;
next	1.68;

1.68
date	2004.10.28.20.34.57;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.19.17.48.19;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.27.22.47.32;	author itojun;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.24.07.55.12;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.24.07.48.51;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.24.07.31.50;	author itojun;	state Exp;
branches;
next	1.60;

1.60
date	2002.10.12.01.09.45;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2002.10.09.20.25.32;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2002.09.23.23.28.15;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2002.09.04.07.30.51;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2002.09.04.07.24.59;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.19.23.23.39;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.19.07.24.47;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.19.06.45.00;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.14.21.35.00;	author todd;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.08.21.22.41;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.07.17.04.19;	author itojun;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.03.00.59.08;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.30.05.07.17;	author itojun;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.29.13.57.57;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.29.13.56.37;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.20.22.54.27;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2001.06.29.16.10.36;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2001.06.27.17.51.39;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2001.06.22.14.12.36;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.29.01.08.15;	author angelos;	state Exp;
branches;
next	1.32;

1.32
date	2001.03.30.11.09.03;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2001.03.21.21.57.10;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.08.09.03.06;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2001.02.23.08.01.14;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.02.23.06.40.20;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.02.21.17.22.05;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.16.16.00.00;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.16.08.48.06;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.08.15.07.27;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.08.14.51.22;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.07.11.43.54;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.06.00.22.23;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.19.06.37.38;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.10.15.15.55.03;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.06.10.11.26;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.16.21.47.17;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	2000.05.19.13.55.17;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.15.11.45.35;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.15.11.29.14;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.27.10.46.17;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.19.07.38.49;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.17.04.44.51;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.13.16.27.26;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.13.14.34.10;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.13.14.11.17;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.02.04.18.13.36;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.08.05.49.41;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.10.17.53.15;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	;

1.6.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.40.20;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.07.04.10.55.26;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.39.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.213
log
@Reduce contention on the NET_LOCK() by moving the nd6 address expiration
task to the `softnettq`.

While here update comments and names to reflect reality after the removal
of router and prefix lists.

ok florian@@, bluhm@@
@
text
@/*	$OpenBSD: nd6.c,v 1.212 2017/08/04 21:33:09 bluhm Exp $	*/
/*	$KAME: nd6.c,v 1.280 2002/06/08 19:52:07 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/pool.h>
#include <sys/protosw.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/task.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet/ip_ipsp.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet/icmp6.h>

#define ND6_SLOWTIMER_INTERVAL (60 * 60) /* 1 hour */
#define ND6_RECALC_REACHTM_INTERVAL (60 * 120) /* 2 hours */

/* timer values */
int	nd6_prune	= 1;	/* walk list every 1 seconds */
int	nd6_delay	= 5;	/* delay first probe time 5 second */
int	nd6_umaxtries	= 3;	/* maximum unicast query */
int	nd6_mmaxtries	= 3;	/* maximum multicast query */
int	nd6_gctimer	= (60 * 60 * 24); /* 1 day: garbage collection timer */

/* preventing too many loops in ND option parsing */
int nd6_maxndopt = 10;	/* max # of ND options allowed */

int nd6_maxnudhint = 0;	/* max # of subsequent upper layer hints */

#ifdef ND6_DEBUG
int nd6_debug = 1;
#else
int nd6_debug = 0;
#endif

TAILQ_HEAD(llinfo_nd6_head, llinfo_nd6) nd6_list;
struct	pool nd6_pool;		/* pool for llinfo_nd6 structures */
int	nd6_inuse, nd6_allocated;

int nd6_recalc_reachtm_interval = ND6_RECALC_REACHTM_INTERVAL;

void nd6_slowtimo(void *);
void nd6_expire(void *);
void nd6_expire_timer(void *);
void nd6_invalidate(struct rtentry *);
void nd6_free(struct rtentry *);
void nd6_llinfo_timer(void *);

struct timeout nd6_slowtimo_ch;
struct timeout nd6_expire_timeout;
struct task nd6_expire_task;

void
nd6_init(void)
{
	static int nd6_init_done = 0;

	if (nd6_init_done) {
		log(LOG_NOTICE, "%s called more than once\n", __func__);
		return;
	}

	TAILQ_INIT(&nd6_list);
	pool_init(&nd6_pool, sizeof(struct llinfo_nd6), 0,
	    IPL_SOFTNET, 0, "nd6", NULL);

	task_set(&nd6_expire_task, nd6_expire, NULL);

	nd6_init_done = 1;

	/* start timer */
	timeout_set_proc(&nd6_slowtimo_ch, nd6_slowtimo, NULL);
	timeout_add_sec(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL);
	timeout_set(&nd6_expire_timeout, nd6_expire_timer, NULL);
	timeout_add_sec(&nd6_expire_timeout, nd6_prune);

}

struct nd_ifinfo *
nd6_ifattach(struct ifnet *ifp)
{
	struct nd_ifinfo *nd;

	nd = malloc(sizeof(*nd), M_IP6NDP, M_WAITOK | M_ZERO);

	nd->initialized = 1;

	nd->basereachable = REACHABLE_TIME;
	nd->reachable = ND_COMPUTE_RTIME(nd->basereachable);
	nd->retrans = RETRANS_TIMER;
	/* per-interface IFXF_AUTOCONF6 needs to be set too to accept RAs */
	nd->flags = (ND6_IFF_PERFORMNUD | ND6_IFF_ACCEPT_RTADV);

	return nd;
}

void
nd6_ifdetach(struct nd_ifinfo *nd)
{

	free(nd, M_IP6NDP, sizeof(*nd));
}

void
nd6_option_init(void *opt, int icmp6len, union nd_opts *ndopts)
{
	bzero(ndopts, sizeof(*ndopts));
	ndopts->nd_opts_search = (struct nd_opt_hdr *)opt;
	ndopts->nd_opts_last
		= (struct nd_opt_hdr *)(((u_char *)opt) + icmp6len);

	if (icmp6len == 0) {
		ndopts->nd_opts_done = 1;
		ndopts->nd_opts_search = NULL;
	}
}

/*
 * Take one ND option.
 */
struct nd_opt_hdr *
nd6_option(union nd_opts *ndopts)
{
	struct nd_opt_hdr *nd_opt;
	int olen;

	if (!ndopts)
		panic("ndopts == NULL in nd6_option");
	if (!ndopts->nd_opts_last)
		panic("uninitialized ndopts in nd6_option");
	if (!ndopts->nd_opts_search)
		return NULL;
	if (ndopts->nd_opts_done)
		return NULL;

	nd_opt = ndopts->nd_opts_search;

	/* make sure nd_opt_len is inside the buffer */
	if ((caddr_t)&nd_opt->nd_opt_len >= (caddr_t)ndopts->nd_opts_last) {
		bzero(ndopts, sizeof(*ndopts));
		return NULL;
	}

	olen = nd_opt->nd_opt_len << 3;
	if (olen == 0) {
		/*
		 * Message validation requires that all included
		 * options have a length that is greater than zero.
		 */
		bzero(ndopts, sizeof(*ndopts));
		return NULL;
	}

	ndopts->nd_opts_search = (struct nd_opt_hdr *)((caddr_t)nd_opt + olen);
	if (ndopts->nd_opts_search > ndopts->nd_opts_last) {
		/* option overruns the end of buffer, invalid */
		bzero(ndopts, sizeof(*ndopts));
		return NULL;
	} else if (ndopts->nd_opts_search == ndopts->nd_opts_last) {
		/* reached the end of options chain */
		ndopts->nd_opts_done = 1;
		ndopts->nd_opts_search = NULL;
	}
	return nd_opt;
}

/*
 * Parse multiple ND options.
 * This function is much easier to use, for ND routines that do not need
 * multiple options of the same type.
 */
int
nd6_options(union nd_opts *ndopts)
{
	struct nd_opt_hdr *nd_opt;
	int i = 0;

	if (!ndopts)
		panic("ndopts == NULL in nd6_options");
	if (!ndopts->nd_opts_last)
		panic("uninitialized ndopts in nd6_options");
	if (!ndopts->nd_opts_search)
		return 0;

	while (1) {
		nd_opt = nd6_option(ndopts);
		if (!nd_opt && !ndopts->nd_opts_last) {
			/*
			 * Message validation requires that all included
			 * options have a length that is greater than zero.
			 */
			icmp6stat_inc(icp6s_nd_badopt);
			bzero(ndopts, sizeof(*ndopts));
			return -1;
		}

		if (!nd_opt)
			goto skip1;

		switch (nd_opt->nd_opt_type) {
		case ND_OPT_SOURCE_LINKADDR:
		case ND_OPT_TARGET_LINKADDR:
		case ND_OPT_MTU:
		case ND_OPT_REDIRECTED_HEADER:
			if (ndopts->nd_opt_array[nd_opt->nd_opt_type]) {
				nd6log((LOG_INFO,
				    "duplicated ND6 option found (type=%d)\n",
				    nd_opt->nd_opt_type));
				/* XXX bark? */
			} else {
				ndopts->nd_opt_array[nd_opt->nd_opt_type]
					= nd_opt;
			}
			break;
		case ND_OPT_PREFIX_INFORMATION:
			if (ndopts->nd_opt_array[nd_opt->nd_opt_type] == 0) {
				ndopts->nd_opt_array[nd_opt->nd_opt_type]
					= nd_opt;
			}
			ndopts->nd_opts_pi_end =
				(struct nd_opt_prefix_info *)nd_opt;
			break;
		default:
			/*
			 * Unknown options must be silently ignored,
			 * to accommodate future extension to the protocol.
			 */
			nd6log((LOG_DEBUG,
			    "nd6_options: unsupported option %d - "
			    "option ignored\n", nd_opt->nd_opt_type));
		}

skip1:
		i++;
		if (i > nd6_maxndopt) {
			icmp6stat_inc(icp6s_nd_toomanyopt);
			nd6log((LOG_INFO, "too many loop in nd opt\n"));
			break;
		}

		if (ndopts->nd_opts_done)
			break;
	}

	return 0;
}

/*
 * ND6 timer routine to handle ND6 entries
 */
void
nd6_llinfo_settimer(struct llinfo_nd6 *ln, int secs)
{
	if (secs < 0) {
		ln->ln_rt->rt_expire = 0;
		timeout_del(&ln->ln_timer_ch);
	} else {
		ln->ln_rt->rt_expire = time_uptime + secs;
		timeout_add_sec(&ln->ln_timer_ch, secs);
	}
}

void
nd6_llinfo_timer(void *arg)
{
	int s;
	struct llinfo_nd6 *ln;
	struct rtentry *rt;
	struct sockaddr_in6 *dst;
	struct ifnet *ifp;
	struct nd_ifinfo *ndi = NULL;

	NET_LOCK(s);

	ln = (struct llinfo_nd6 *)arg;

	if ((rt = ln->ln_rt) == NULL)
		panic("ln->ln_rt == NULL");
	if ((ifp = if_get(rt->rt_ifidx)) == NULL) {
		NET_UNLOCK(s);
		return;
	}
	ndi = ND_IFINFO(ifp);
	dst = satosin6(rt_key(rt));

	/* sanity check */
	if (rt->rt_llinfo != NULL && (struct llinfo_nd6 *)rt->rt_llinfo != ln)
		panic("rt_llinfo(%p) is not equal to ln(%p)",
		      rt->rt_llinfo, ln);
	if (!dst)
		panic("dst=0 in nd6_timer(ln=%p)", ln);

	switch (ln->ln_state) {
	case ND6_LLINFO_INCOMPLETE:
		if (ln->ln_asked < nd6_mmaxtries) {
			ln->ln_asked++;
			nd6_llinfo_settimer(ln, ndi->retrans / 1000);
			nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
		} else {
			struct mbuf *m = ln->ln_hold;
			if (m) {
				ln->ln_hold = NULL;
				/*
				 * Fake rcvif to make the ICMP error
				 * more helpful in diagnosing for the
				 * receiver.
				 * XXX: should we consider
				 * older rcvif?
				 */
				m->m_pkthdr.ph_ifidx = rt->rt_ifidx;

				icmp6_error(m, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_ADDR, 0);
				if (ln->ln_hold == m) {
					/* m is back in ln_hold. Discard. */
					m_freem(ln->ln_hold);
					ln->ln_hold = NULL;
				}
			}
			nd6_free(rt);
			ln = NULL;
		}
		break;
	case ND6_LLINFO_REACHABLE:
		if (!ND6_LLINFO_PERMANENT(ln)) {
			ln->ln_state = ND6_LLINFO_STALE;
			nd6_llinfo_settimer(ln, nd6_gctimer);
		}
		break;

	case ND6_LLINFO_STALE:
	case ND6_LLINFO_PURGE:
		/* Garbage Collection(RFC 2461 5.3) */
		if (!ND6_LLINFO_PERMANENT(ln)) {
			nd6_free(rt);
			ln = NULL;
		}
		break;

	case ND6_LLINFO_DELAY:
		if (ndi && (ndi->flags & ND6_IFF_PERFORMNUD) != 0) {
			/* We need NUD */
			ln->ln_asked = 1;
			ln->ln_state = ND6_LLINFO_PROBE;
			nd6_llinfo_settimer(ln, ndi->retrans / 1000);
			nd6_ns_output(ifp, &dst->sin6_addr,
			    &dst->sin6_addr, ln, 0);
		} else {
			ln->ln_state = ND6_LLINFO_STALE; /* XXX */
			nd6_llinfo_settimer(ln, nd6_gctimer);
		}
		break;
	case ND6_LLINFO_PROBE:
		if (ln->ln_asked < nd6_umaxtries) {
			ln->ln_asked++;
			nd6_llinfo_settimer(ln, ndi->retrans / 1000);
			nd6_ns_output(ifp, &dst->sin6_addr,
			    &dst->sin6_addr, ln, 0);
		} else {
			nd6_free(rt);
			ln = NULL;
		}
		break;
	}

	if_put(ifp);
	NET_UNLOCK(s);
}

/*
 * Expire interface addresses.
 */
void
nd6_expire(void *unused)
{
	struct ifnet *ifp;
	int s;

	KERNEL_LOCK();
	NET_LOCK(s);

	timeout_add_sec(&nd6_expire_timeout, nd6_prune);

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		struct ifaddr *ifa, *nifa;
		struct in6_ifaddr *ia6;

		TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list, nifa) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			ia6 = ifatoia6(ifa);
			/* check address lifetime */
			if (IFA6_IS_INVALID(ia6)) {
				in6_purgeaddr(&ia6->ia_ifa);
			} else if (IFA6_IS_DEPRECATED(ia6)) {
				ia6->ia6_flags |= IN6_IFF_DEPRECATED;
			} else {
				/*
				 * A new RA might have made a deprecated address
				 * preferred.
				 */
				ia6->ia6_flags &= ~IN6_IFF_DEPRECATED;
			}
		}
	}

	NET_UNLOCK(s);
	KERNEL_UNLOCK();
}

void
nd6_expire_timer(void *unused)
{
	task_add(softnettq, &nd6_expire_task);
}

/*
 * Nuke neighbor cache/prefix/default router management table, right before
 * ifp goes away.
 */
void
nd6_purge(struct ifnet *ifp)
{
	struct llinfo_nd6 *ln, *nln;

	NET_ASSERT_LOCKED();

	/*
	 * Nuke neighbor cache entries for the ifp.
	 */
	TAILQ_FOREACH_SAFE(ln, &nd6_list, ln_list, nln) {
		struct rtentry *rt;
		struct sockaddr_dl *sdl;

		rt = ln->ln_rt;
		if (rt != NULL && rt->rt_gateway != NULL &&
		    rt->rt_gateway->sa_family == AF_LINK) {
			sdl = satosdl(rt->rt_gateway);
			if (sdl->sdl_index == ifp->if_index)
				nd6_free(rt);
		}
	}
}

struct rtentry *
nd6_lookup(struct in6_addr *addr6, int create, struct ifnet *ifp,
    u_int rtableid)
{
	struct rtentry *rt;
	struct sockaddr_in6 sin6;
	int flags;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = *addr6;
	flags = (create) ? RT_RESOLVE : 0;

	rt = rtalloc(sin6tosa(&sin6), flags, rtableid);
	if (rt != NULL && (rt->rt_flags & RTF_LLINFO) == 0) {
		/*
		 * This is the case for the default route.
		 * If we want to create a neighbor cache for the address, we
		 * should free the route for the destination and allocate an
		 * interface route.
		 */
		if (create) {
			rtfree(rt);
			rt = NULL;
		}
	}
	if (rt == NULL) {
		if (create && ifp) {
			struct rt_addrinfo info;
			struct ifaddr *ifa;
			int error;

			/*
			 * If no route is available and create is set,
			 * we allocate a host route for the destination
			 * and treat it like an interface route.
			 * This hack is necessary for a neighbor which can't
			 * be covered by our own prefix.
			 */
			ifa = ifaof_ifpforaddr(sin6tosa(&sin6), ifp);
			if (ifa == NULL)
				return (NULL);

			/*
			 * Create a new route.  RTF_LLINFO is necessary
			 * to create a Neighbor Cache entry for the
			 * destination in nd6_rtrequest which will be
			 * called in rtrequest.
			 */
			bzero(&info, sizeof(info));
			info.rti_ifa = ifa;
			info.rti_flags = RTF_HOST | RTF_LLINFO;
			info.rti_info[RTAX_DST] = sin6tosa(&sin6);
			info.rti_info[RTAX_GATEWAY] = sdltosa(ifp->if_sadl);
			error = rtrequest(RTM_ADD, &info, RTP_CONNECTED, &rt,
			    rtableid);
			if (error)
				return (NULL);
			if (rt->rt_llinfo != NULL) {
				struct llinfo_nd6 *ln =
				    (struct llinfo_nd6 *)rt->rt_llinfo;
				ln->ln_state = ND6_LLINFO_NOSTATE;
			}
		} else
			return (NULL);
	}
	/*
	 * Validation for the entry.
	 * Note that the check for rt_llinfo is necessary because a cloned
	 * route from a parent route that has the L flag (e.g. the default
	 * route to a p2p interface) may have the flag, too, while the
	 * destination is not actually a neighbor.
	 */
	if ((rt->rt_flags & RTF_GATEWAY) || (rt->rt_flags & RTF_LLINFO) == 0 ||
	    rt->rt_gateway->sa_family != AF_LINK || rt->rt_llinfo == NULL ||
	    (ifp != NULL && rt->rt_ifidx != ifp->if_index)) {
		if (create) {
			char addr[INET6_ADDRSTRLEN];
			nd6log((LOG_DEBUG, "%s: failed to lookup %s (if=%s)\n",
			    __func__,
			    inet_ntop(AF_INET6, addr6, addr, sizeof(addr)),
			    ifp ? ifp->if_xname : "unspec"));
		}
		rtfree(rt);
		return (NULL);
	}
	return (rt);
}

/*
 * Detect if a given IPv6 address identifies a neighbor on a given link.
 * XXX: should take care of the destination of a p2p link?
 */
int
nd6_is_addr_neighbor(struct sockaddr_in6 *addr, struct ifnet *ifp)
{
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa;
	struct rtentry *rt;

	/*
	 * A link-local address is always a neighbor.
	 * XXX: we should use the sin6_scope_id field rather than the embedded
	 * interface index.
	 * XXX: a link does not necessarily specify a single interface.
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&addr->sin6_addr) &&
	    ntohs(*(u_int16_t *)&addr->sin6_addr.s6_addr[2]) == ifp->if_index)
		return (1);

	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;

		ia6 = ifatoia6(ifa);

		/* Prefix check down below. */
		if (ia6->ia6_flags & IN6_IFF_AUTOCONF)
			continue;

		if (IN6_ARE_MASKED_ADDR_EQUAL(&addr->sin6_addr,
		    &ia6->ia_addr.sin6_addr,
		    &ia6->ia_prefixmask.sin6_addr))
			return (1);
	}

	/*
	 * Even if the address matches none of our addresses, it might be
	 * in the neighbor cache.
	 */
	rt = nd6_lookup(&addr->sin6_addr, 0, ifp, ifp->if_rdomain);
	if (rt != NULL) {
		rtfree(rt);
		return (1);
	}

	return (0);
}

void
nd6_invalidate(struct rtentry *rt)
{
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo;

	m_freem(ln->ln_hold);
	ln->ln_hold = NULL;
	ln->ln_state = ND6_LLINFO_INCOMPLETE;
	ln->ln_asked = 0;
}

/*
 * Free an nd6 llinfo entry.
 * Since the function would cause significant changes in the kernel, DO NOT
 * make it global, unless you have a strong reason for the change, and are sure
 * that the change is safe.
 */
void
nd6_free(struct rtentry *rt)
{
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	struct in6_addr in6 = satosin6(rt_key(rt))->sin6_addr;
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	ifp = if_get(rt->rt_ifidx);

	if (!ip6_forwarding) {
		if (ln->ln_router) {
			/*
			 * rt6_flush must be called whether or not the neighbor
			 * is in the Default Router List.
			 * See a corresponding comment in nd6_na_input().
			 */
			rt6_flush(&in6, ifp);
		}
	}

	nd6_invalidate(rt);

	/*
	 * Detach the route from the routing tree and the list of neighbor
	 * caches, and disable the route entry not to be used in already
	 * cached routes.
	 */
	if (!ISSET(rt->rt_flags, RTF_STATIC|RTF_CACHED))
		rtdeletemsg(rt, ifp, ifp->if_rdomain);

	if_put(ifp);
}

/*
 * Upper-layer reachability hint for Neighbor Unreachability Detection.
 *
 * XXX cost-effective methods?
 */
void
nd6_nud_hint(struct rtentry *rt)
{
	struct llinfo_nd6 *ln;
	struct ifnet *ifp;

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		return;

	if ((rt->rt_flags & RTF_GATEWAY) != 0 ||
	    (rt->rt_flags & RTF_LLINFO) == 0 ||
	    rt->rt_llinfo == NULL || rt->rt_gateway == NULL ||
	    rt->rt_gateway->sa_family != AF_LINK) {
		/* This is not a host route. */
		goto out;
	}

	ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	if (ln->ln_state < ND6_LLINFO_REACHABLE)
		goto out;

	/*
	 * if we get upper-layer reachability confirmation many times,
	 * it is possible we have false information.
	 */
	ln->ln_byhint++;
	if (ln->ln_byhint > nd6_maxnudhint)
		goto out;

	ln->ln_state = ND6_LLINFO_REACHABLE;
	if (!ND6_LLINFO_PERMANENT(ln))
		nd6_llinfo_settimer(ln, ND_IFINFO(ifp)->reachable);
out:
	if_put(ifp);
}

void
nd6_rtrequest(struct ifnet *ifp, int req, struct rtentry *rt)
{
	struct sockaddr *gate = rt->rt_gateway;
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	struct ifaddr *ifa;

	if (ISSET(rt->rt_flags, RTF_GATEWAY|RTF_MULTICAST))
		return;

	if (nd6_need_cache(ifp) == 0 && (rt->rt_flags & RTF_HOST) == 0) {
		/*
		 * This is probably an interface direct route for a link
		 * which does not need neighbor caches (e.g. fe80::%lo0/64).
		 * We do not need special treatment below for such a route.
		 * Moreover, the RTF_LLINFO flag which would be set below
		 * would annoy the ndp(8) command.
		 */
		return;
	}

	if (req == RTM_RESOLVE && nd6_need_cache(ifp) == 0) {
		/*
		 * For routing daemons like ospf6d we allow neighbor discovery
		 * based on the cloning route only.  This allows us to sent
		 * packets directly into a network without having an address
		 * with matching prefix on the interface.  If the cloning
		 * route is used for an stf interface, we would mistakenly
		 * make a neighbor cache for the host route, and would see
		 * strange neighbor solicitation for the corresponding
		 * destination.  In order to avoid confusion, we check if the
		 * interface is suitable for neighbor discovery, and stop the
		 * process if not.  Additionally, we remove the LLINFO flag
		 * so that ndp(8) will not try to get the neighbor information
		 * of the destination.
		 */
		rt->rt_flags &= ~RTF_LLINFO;
		return;
	}

	switch (req) {
	case RTM_ADD:
		if ((rt->rt_flags & RTF_CLONING) ||
		    ((rt->rt_flags & (RTF_LLINFO | RTF_LOCAL)) && ln == NULL)) {
			if (ln != NULL)
				nd6_llinfo_settimer(ln, 0);
			if ((rt->rt_flags & RTF_CLONING) != 0)
				break;
		}
		/*
		 * In IPv4 code, we try to announce new RTF_ANNOUNCE entry here.
		 * We don't do that here since llinfo is not ready yet.
		 *
		 * There are also couple of other things to be discussed:
		 * - unsolicited NA code needs improvement beforehand
		 * - RFC2461 says we MAY send multicast unsolicited NA
		 *   (7.2.6 paragraph 4), however, it also says that we
		 *   SHOULD provide a mechanism to prevent multicast NA storm.
		 *   we don't have anything like it right now.
		 *   note that the mechanism needs a mutual agreement
		 *   between proxies, which means that we need to implement
		 *   a new protocol, or a new kludge.
		 * - from RFC2461 6.2.4, host MUST NOT send an unsolicited NA.
		 *   we need to check ip6forwarding before sending it.
		 *   (or should we allow proxy ND configuration only for
		 *   routers?  there's no mention about proxy ND from hosts)
		 */
#if 0
		/* XXX it does not work */
		if (rt->rt_flags & RTF_ANNOUNCE)
			nd6_na_output(ifp,
			      &satosin6(rt_key(rt))->sin6_addr,
			      &satosin6(rt_key(rt))->sin6_addr,
			      ip6_forwarding ? ND_NA_FLAG_ROUTER : 0,
			      1, NULL);
#endif
		/* FALLTHROUGH */
	case RTM_RESOLVE:
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(struct sockaddr_dl)) {
			log(LOG_DEBUG, "%s: bad gateway value: %s\n",
			    __func__, ifp->if_xname);
			break;
		}
		satosdl(gate)->sdl_type = ifp->if_type;
		satosdl(gate)->sdl_index = ifp->if_index;
		if (ln != NULL)
			break;	/* This happens on a route change */
		/*
		 * Case 2: This route may come from cloning, or a manual route
		 * add with a LL address.
		 */
		ln = pool_get(&nd6_pool, PR_NOWAIT | PR_ZERO);
		rt->rt_llinfo = (caddr_t)ln;
		if (ln == NULL) {
			log(LOG_DEBUG, "%s: pool get failed\n", __func__);
			break;
		}
		nd6_inuse++;
		nd6_allocated++;
		ln->ln_rt = rt;
		timeout_set_proc(&ln->ln_timer_ch, nd6_llinfo_timer, ln);
		/* this is required for "ndp" command. - shin */
		if (req == RTM_ADD) {
		        /*
			 * gate should have some valid AF_LINK entry,
			 * and ln expire should have some lifetime
			 * which is specified by ndp command.
			 */
			ln->ln_state = ND6_LLINFO_REACHABLE;
			ln->ln_byhint = 0;
		} else {
		        /*
			 * When req == RTM_RESOLVE, rt is created and
			 * initialized in rtrequest(), so rt_expire is 0.
			 */
			ln->ln_state = ND6_LLINFO_NOSTATE;
			nd6_llinfo_settimer(ln, 0);
		}
		rt->rt_flags |= RTF_LLINFO;
		TAILQ_INSERT_HEAD(&nd6_list, ln, ln_list);

		/*
		 * If we have too many cache entries, initiate immediate
		 * purging for some "less recently used" entries.  Note that
		 * we cannot directly call nd6_free() here because it would
		 * cause re-entering rtable related routines triggering an LOR
		 * problem for FreeBSD.
		 */
		if (ip6_neighborgcthresh >= 0 &&
		    nd6_inuse >= ip6_neighborgcthresh) {
			int i;

			for (i = 0; i < 10; i++) {
				struct llinfo_nd6 *ln_end;

				ln_end = TAILQ_LAST(&nd6_list, llinfo_nd6_head);
				if (ln_end == ln)
					break;

				/* Move this entry to the head */
				TAILQ_REMOVE(&nd6_list, ln_end, ln_list);
				TAILQ_INSERT_HEAD(&nd6_list, ln_end, ln_list);

				if (ND6_LLINFO_PERMANENT(ln_end))
					continue;

				if (ln_end->ln_state > ND6_LLINFO_INCOMPLETE)
					ln_end->ln_state = ND6_LLINFO_STALE;
				else
					ln_end->ln_state = ND6_LLINFO_PURGE;
				nd6_llinfo_settimer(ln_end, 0);
			}
		}

		/*
		 * check if rt_key(rt) is one of my address assigned
		 * to the interface.
		 */
		ifa = &in6ifa_ifpwithaddr(ifp,
		    &satosin6(rt_key(rt))->sin6_addr)->ia_ifa;
		if (ifa) {
			nd6_llinfo_settimer(ln, -1);
			ln->ln_state = ND6_LLINFO_REACHABLE;
			ln->ln_byhint = 0;
			KASSERT(ifa == rt->rt_ifa);
		} else if (rt->rt_flags & RTF_ANNOUNCE) {
			nd6_llinfo_settimer(ln, -1);
			ln->ln_state = ND6_LLINFO_REACHABLE;
			ln->ln_byhint = 0;

			/* join solicited node multicast for proxy ND */
			if (ifp->if_flags & IFF_MULTICAST) {
				struct in6_addr llsol;
				int error;

				llsol = satosin6(rt_key(rt))->sin6_addr;
				llsol.s6_addr16[0] = htons(0xff02);
				llsol.s6_addr16[1] = htons(ifp->if_index);
				llsol.s6_addr32[1] = 0;
				llsol.s6_addr32[2] = htonl(1);
				llsol.s6_addr8[12] = 0xff;

				if (in6_addmulti(&llsol, ifp, &error)) {
					char addr[INET6_ADDRSTRLEN];
					nd6log((LOG_ERR, "%s: failed to join "
					    "%s (errno=%d)\n", ifp->if_xname,
					    inet_ntop(AF_INET6, &llsol,
						addr, sizeof(addr)),
					    error));
				}
			}
		}
		break;

	case RTM_DELETE:
		if (ln == NULL)
			break;
		/* leave from solicited node multicast for proxy ND */
		if ((rt->rt_flags & RTF_ANNOUNCE) != 0 &&
		    (ifp->if_flags & IFF_MULTICAST) != 0) {
			struct in6_addr llsol;
			struct in6_multi *in6m;

			llsol = satosin6(rt_key(rt))->sin6_addr;
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr8[12] = 0xff;

			IN6_LOOKUP_MULTI(llsol, ifp, in6m);
			if (in6m)
				in6_delmulti(in6m);
		}
		nd6_inuse--;
		TAILQ_REMOVE(&nd6_list, ln, ln_list);
		nd6_llinfo_settimer(ln, -1);
		rt->rt_llinfo = NULL;
		rt->rt_flags &= ~RTF_LLINFO;
		m_freem(ln->ln_hold);
		pool_put(&nd6_pool, ln);
		break;

	case RTM_INVALIDATE:
		nd6_invalidate(rt);
		break;
	}
}

int
nd6_ioctl(u_long cmd, caddr_t data, struct ifnet *ifp)
{
	struct in6_ndireq *ndi = (struct in6_ndireq *)data;
	struct in6_nbrinfo *nbi = (struct in6_nbrinfo *)data;
	struct rtentry *rt;
	int error = 0;

	NET_ASSERT_LOCKED();

	switch (cmd) {
	case SIOCGIFINFO_IN6:
		ndi->ndi = *ND_IFINFO(ifp);
		memset(&ndi->ndi.randomseed0, 0, sizeof ndi->ndi.randomseed0);
		memset(&ndi->ndi.randomseed1, 0, sizeof ndi->ndi.randomseed1);
		memset(&ndi->ndi.randomid, 0, sizeof ndi->ndi.randomid);
		break;
	case SIOCSIFINFO_FLAGS:
		ND_IFINFO(ifp)->flags = ndi->ndi.flags;
		break;
	case SIOCSNDFLUSH_IN6:	/* XXX: the ioctl name is confusing... */
		/* sync kernel routing table with the default router list */
		error = ENOTSUP;
		break;
	case SIOCSPFXFLUSH_IN6:
	{
		/* flush all the prefix advertised by routers */
		error = ENOTSUP;
		break;
	}
	case SIOCSRTRFLUSH_IN6:
	{
		/* flush all the default routers */
		error = ENOTSUP;
		break;
	}
	case SIOCGNBRINFO_IN6:
	{
		struct llinfo_nd6 *ln;
		struct in6_addr nb_addr = nbi->addr; /* make local for safety */
		time_t expire;

		/*
		 * XXX: KAME specific hack for scoped addresses
		 *      XXXX: for other scopes than link-local?
		 */
		if (IN6_IS_ADDR_LINKLOCAL(&nbi->addr) ||
		    IN6_IS_ADDR_MC_LINKLOCAL(&nbi->addr)) {
			u_int16_t *idp = (u_int16_t *)&nb_addr.s6_addr[2];

			if (*idp == 0)
				*idp = htons(ifp->if_index);
		}

		rt = nd6_lookup(&nb_addr, 0, ifp, ifp->if_rdomain);
		if (rt == NULL ||
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) == NULL) {
			error = EINVAL;
			rtfree(rt);
			break;
		}
		expire = ln->ln_rt->rt_expire;
		if (expire != 0) {
			expire -= time_uptime;
			expire += time_second;
		}

		nbi->state = ln->ln_state;
		nbi->asked = ln->ln_asked;
		nbi->isrouter = ln->ln_router;
		nbi->expire = expire;
		rtfree(rt);

		break;
	}
	}
	return (error);
}

/*
 * Create neighbor cache entry and cache link-layer address,
 * on reception of inbound ND6 packets.  (RS/RA/NS/redirect)
 *
 * type - ICMP6 type
 * code - type dependent information
 */
void
nd6_cache_lladdr(struct ifnet *ifp, struct in6_addr *from, char *lladdr,
    int lladdrlen, int type, int code)
{
	struct rtentry *rt = NULL;
	struct llinfo_nd6 *ln = NULL;
	int is_newentry;
	struct sockaddr_dl *sdl = NULL;
	int do_update;
	int olladdr;
	int llchange;
	int newstate = 0;

	if (!ifp)
		panic("ifp == NULL in nd6_cache_lladdr");
	if (!from)
		panic("from == NULL in nd6_cache_lladdr");

	/* nothing must be updated for unspecified address */
	if (IN6_IS_ADDR_UNSPECIFIED(from))
		return;

	/*
	 * Validation about ifp->if_addrlen and lladdrlen must be done in
	 * the caller.
	 *
	 * XXX If the link does not have link-layer address, what should
	 * we do? (ifp->if_addrlen == 0)
	 * Spec says nothing in sections for RA, RS and NA.  There's small
	 * description on it in NS section (RFC 2461 7.2.3).
	 */

	rt = nd6_lookup(from, 0, ifp, ifp->if_rdomain);
	if (rt == NULL) {
#if 0
		/* nothing must be done if there's no lladdr */
		if (!lladdr || !lladdrlen)
			return NULL;
#endif

		rt = nd6_lookup(from, 1, ifp, ifp->if_rdomain);
		is_newentry = 1;
	} else {
		/* do nothing if static ndp is set */
		if (rt->rt_flags & RTF_STATIC) {
			rtfree(rt);
			return;
		}
		is_newentry = 0;
	}

	if (!rt)
		return;
	if ((rt->rt_flags & (RTF_GATEWAY | RTF_LLINFO)) != RTF_LLINFO) {
fail:
		nd6_free(rt);
		rtfree(rt);
		return;
	}
	ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	if (ln == NULL)
		goto fail;
	if (rt->rt_gateway == NULL)
		goto fail;
	if (rt->rt_gateway->sa_family != AF_LINK)
		goto fail;
	sdl = satosdl(rt->rt_gateway);

	olladdr = (sdl->sdl_alen) ? 1 : 0;
	if (olladdr && lladdr) {
		if (bcmp(lladdr, LLADDR(sdl), ifp->if_addrlen))
			llchange = 1;
		else
			llchange = 0;
	} else
		llchange = 0;

	/*
	 * newentry olladdr  lladdr  llchange	(*=record)
	 *	0	n	n	--	(1)
	 *	0	y	n	--	(2)
	 *	0	n	y	--	(3) * STALE
	 *	0	y	y	n	(4) *
	 *	0	y	y	y	(5) * STALE
	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE)
	 *	1	--	y	--	(7) * STALE
	 */

	if (llchange) {
		char addr[INET6_ADDRSTRLEN];
		log(LOG_INFO, "ndp info overwritten for %s by %s on %s\n",
		    inet_ntop(AF_INET6, from, addr, sizeof(addr)),
		    ether_sprintf(lladdr), ifp->if_xname);
	}
	if (lladdr) {		/* (3-5) and (7) */
		/*
		 * Record source link-layer address
		 * XXX is it dependent to ifp->if_type?
		 */
		sdl->sdl_alen = ifp->if_addrlen;
		bcopy(lladdr, LLADDR(sdl), ifp->if_addrlen);
	}

	if (!is_newentry) {
		if ((!olladdr && lladdr) ||		/* (3) */
		    (olladdr && lladdr && llchange)) {	/* (5) */
			do_update = 1;
			newstate = ND6_LLINFO_STALE;
		} else					/* (1-2,4) */
			do_update = 0;
	} else {
		do_update = 1;
		if (!lladdr)				/* (6) */
			newstate = ND6_LLINFO_NOSTATE;
		else					/* (7) */
			newstate = ND6_LLINFO_STALE;
	}

	if (do_update) {
		/*
		 * Update the state of the neighbor cache.
		 */
		ln->ln_state = newstate;

		if (ln->ln_state == ND6_LLINFO_STALE) {
			/*
			 * Since nd6_resolve() in ifp->if_output() will cause
			 * state transition to DELAY and reset the timer,
			 * we must set the timer now, although it is actually
			 * meaningless.
			 */
			nd6_llinfo_settimer(ln, nd6_gctimer);

			if (ln->ln_hold) {
				struct mbuf *n = ln->ln_hold;
				ln->ln_hold = NULL;
				/*
				 * we assume ifp is not a p2p here, so just
				 * set the 2nd argument as the 1st one.
				 */
				ifp->if_output(ifp, n, rt_key(rt), rt);
				if (ln->ln_hold == n) {
					/* n is back in ln_hold. Discard. */
					m_freem(ln->ln_hold);
					ln->ln_hold = NULL;
				}
			}
		} else if (ln->ln_state == ND6_LLINFO_INCOMPLETE) {
			/* probe right away */
			nd6_llinfo_settimer((void *)ln, 0);
		}
	}

	/*
	 * ICMP6 type dependent behavior.
	 *
	 * NS: clear IsRouter if new entry
	 * RS: clear IsRouter
	 * RA: set IsRouter if there's lladdr
	 * redir: clear IsRouter if new entry
	 *
	 * RA case, (1):
	 * The spec says that we must set IsRouter in the following cases:
	 * - If lladdr exist, set IsRouter.  This means (1-5).
	 * - If it is old entry (!newentry), set IsRouter.  This means (7).
	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter.
	 * A question arises for (1) case.  (1) case has no lladdr in the
	 * neighbor cache, this is similar to (6).
	 * This case is rare but we figured that we MUST NOT set IsRouter.
	 *
	 * newentry olladdr  lladdr  llchange	    NS  RS  RA	redir
	 *							D R
	 *	0	n	n	--	(1)	c   ?     s
	 *	0	y	n	--	(2)	c   s     s
	 *	0	n	y	--	(3)	c   s     s
	 *	0	y	y	n	(4)	c   s     s
	 *	0	y	y	y	(5)	c   s     s
	 *	1	--	n	--	(6) c	c	c s
	 *	1	--	y	--	(7) c	c   s	c s
	 *
	 *					(c=clear s=set)
	 */
	switch (type & 0xff) {
	case ND_NEIGHBOR_SOLICIT:
		/*
		 * New entry must have is_router flag cleared.
		 */
		if (is_newentry)	/* (6-7) */
			ln->ln_router = 0;
		break;
	case ND_REDIRECT:
		/*
		 * If the icmp is a redirect to a better router, always set the
		 * is_router flag.  Otherwise, if the entry is newly created,
		 * clear the flag.  [RFC 2461, sec 8.3]
		 */
		if (code == ND_REDIRECT_ROUTER)
			ln->ln_router = 1;
		else if (is_newentry) /* (6-7) */
			ln->ln_router = 0;
		break;
	case ND_ROUTER_SOLICIT:
		/*
		 * is_router flag must always be cleared.
		 */
		ln->ln_router = 0;
		break;
	case ND_ROUTER_ADVERT:
		/*
		 * Mark an entry with lladdr as a router.
		 */
		if ((!is_newentry && (olladdr || lladdr)) ||	/* (2-5) */
		    (is_newentry && lladdr)) {			/* (7) */
			ln->ln_router = 1;
		}
		break;
	}

	rtfree(rt);
}

void
nd6_slowtimo(void *ignored_arg)
{
	struct nd_ifinfo *nd6if;
	struct ifnet *ifp;
	int s;

	NET_LOCK(s);

	timeout_add_sec(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL);

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		nd6if = ND_IFINFO(ifp);
		if (nd6if->basereachable && /* already initialized */
		    (nd6if->recalctm -= ND6_SLOWTIMER_INTERVAL) <= 0) {
			/*
			 * Since reachable time rarely changes by router
			 * advertisements, we SHOULD insure that a new random
			 * value gets recomputed at least once every few hours.
			 * (RFC 2461, 6.3.4)
			 */
			nd6if->recalctm = nd6_recalc_reachtm_interval;
			nd6if->reachable = ND_COMPUTE_RTIME(nd6if->basereachable);
		}
	}
	NET_UNLOCK(s);
}

int
nd6_resolve(struct ifnet *ifp, struct rtentry *rt0, struct mbuf *m,
    struct sockaddr *dst, u_char *desten)
{
	struct sockaddr_dl *sdl;
	struct rtentry *rt;
	struct llinfo_nd6 *ln = NULL;

	if (m->m_flags & M_MCAST) {
		ETHER_MAP_IPV6_MULTICAST(&satosin6(dst)->sin6_addr, desten);
		return (0);
	}

	rt = rt_getll(rt0);

	if (ISSET(rt->rt_flags, RTF_REJECT) &&
	    (rt->rt_expire == 0 || time_uptime < rt->rt_expire)) {
		m_freem(m);
		return (rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
	}

	/*
	 * Address resolution or Neighbor Unreachability Detection
	 * for the next hop.
	 * At this point, the destination of the packet must be a unicast
	 * or an anycast address(i.e. not a multicast).
	 */
	if (!ISSET(rt->rt_flags, RTF_LLINFO)) {
		char addr[INET6_ADDRSTRLEN];
		log(LOG_DEBUG, "%s: %s: route contains no ND information\n",
		    __func__, inet_ntop(AF_INET6,
		    &satosin6(rt_key(rt))->sin6_addr, addr, sizeof(addr)));
		m_freem(m);
		return (EINVAL);
	}

	if (rt->rt_gateway->sa_family != AF_LINK) {
		printf("%s: something odd happens\n", __func__);
		m_freem(m);
		return (EINVAL);
	}

	ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	KASSERT(ln != NULL);

	/*
	 * Move this entry to the head of the queue so that it is less likely
	 * for this entry to be a target of forced garbage collection (see
	 * nd6_rtrequest()).
	 */
	TAILQ_REMOVE(&nd6_list, ln, ln_list);
	TAILQ_INSERT_HEAD(&nd6_list, ln, ln_list);

	/*
	 * The first time we send a packet to a neighbor whose entry is
	 * STALE, we have to change the state to DELAY and a sets a timer to
	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do
	 * neighbor unreachability detection on expiration.
	 * (RFC 2461 7.3.3)
	 */
	if (ln->ln_state == ND6_LLINFO_STALE) {
		ln->ln_asked = 0;
		ln->ln_state = ND6_LLINFO_DELAY;
		nd6_llinfo_settimer(ln, nd6_delay);
	}

	/*
	 * If the neighbor cache entry has a state other than INCOMPLETE
	 * (i.e. its link-layer address is already resolved), just
	 * send the packet.
	 */
	if (ln->ln_state > ND6_LLINFO_INCOMPLETE) {
		sdl = satosdl(rt->rt_gateway);
		if (sdl->sdl_alen != ETHER_ADDR_LEN) {
			char addr[INET6_ADDRSTRLEN];
			log(LOG_DEBUG, "%s: %s: incorrect nd6 information\n",
			    __func__,
			    inet_ntop(AF_INET6, &satosin6(dst)->sin6_addr,
				addr, sizeof(addr)));
			m_freem(m);
			return (EINVAL);
		}

		bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
		return (0);
	}

	/*
	 * There is a neighbor cache entry, but no ethernet address
	 * response yet.  Replace the held mbuf (if any) with this
	 * latest one.
	 */
	if (ln->ln_state == ND6_LLINFO_NOSTATE)
		ln->ln_state = ND6_LLINFO_INCOMPLETE;
	m_freem(ln->ln_hold);
	ln->ln_hold = m;

	/*
	 * If there has been no NS for the neighbor after entering the
	 * INCOMPLETE state, send the first solicitation.
	 */
	if (!ND6_LLINFO_PERMANENT(ln) && ln->ln_asked == 0) {
		ln->ln_asked++;
		nd6_llinfo_settimer(ln, ND_IFINFO(ifp)->retrans / 1000);
		nd6_ns_output(ifp, NULL, &satosin6(dst)->sin6_addr, ln, 0);
	}
	return (EAGAIN);
}

int
nd6_need_cache(struct ifnet *ifp)
{
	/*
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
	 */
	switch (ifp->if_type) {
	case IFT_ETHER:
	case IFT_IEEE80211:
	case IFT_CARP:
		return (1);
	default:
		return (0);
	}
}
@


1.212
log
@Since we have TAILQ_FOREACH_SAFE in nd6_purge() it is not necessary
that nd6_free() advances the next pointer itself.  Make nd6_free()
a void function and remove unused parameter gc.
OK florian@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.211 2017/07/12 16:53:58 florian Exp $	*/
d93 2
a94 2
void nd6_timer_work(void *);
void nd6_timer(void *);
d100 2
a101 2
struct timeout nd6_timer_ch;
struct task nd6_timer_task;
d117 1
a117 3
	/* initialization of the default router list */

	task_set(&nd6_timer_task, nd6_timer_work, NULL);
d124 2
a125 2
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add_sec(&nd6_timer_ch, nd6_prune);
d421 1
a421 1
 * ND6 timer routine to expire default route list and prefix list
d424 1
a424 1
nd6_timer_work(void *null)
d429 1
d432 1
a432 1
	timeout_add_sec(&nd6_timer_ch, nd6_prune);
a433 6
	/*
	 * expire interface addresses.
	 * in the past the loop was inside prefix expiry processing.
	 * However, from a stricter spec-conformance standpoint, we should
	 * rather separate address lifetimes and prefix lifetimes.
	 */
d458 1
d462 1
a462 1
nd6_timer(void *ignored_arg)
d464 1
a464 1
	task_add(systq, &nd6_timer_task);
@


1.211
log
@Get rid of ICMPV6CTL_ND6_DRLIST and ICMPV6CTL_ND6_PRLIST sysctls
With this we can also get rid of in6_prefix and in6_defrouter. They
are meaningless, the kernel no longer tracks this information.

Pointed out by & OK mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.210 2017/07/11 12:51:05 florian Exp $	*/
d96 1
a96 1
struct llinfo_nd6 *nd6_free(struct rtentry *, int);
d372 1
a372 1
			(void)nd6_free(rt, 0);
d387 1
a387 1
			(void)nd6_free(rt, 1);
d412 1
a412 1
			(void)nd6_free(rt, 0);
d496 1
a496 1
				nln = nd6_free(rt, 0);
d658 2
a659 2
struct llinfo_nd6 *
nd6_free(struct rtentry *rt, int gc)
d661 1
a661 1
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo, *next;
a679 6
	/*
	 * Before deleting the entry, remember the next entry as the
	 * return value.
	 */
	next = TAILQ_NEXT(ln, ln_list);

a690 2

	return (next);
d1106 1
a1106 1
		(void)nd6_free(rt, 0);
@


1.210
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.209 2017/05/16 12:24:02 mpi Exp $	*/
a1431 46
}

/*
 * oldp - syscall arg, need copyout
 * newp - syscall arg, need copyin
 */
/* XXXDEL? */
int
nd6_sysctl(int name, void *oldp, size_t *oldlenp, void *newp, size_t newlen)
{
	void *p;
	size_t ol;
	int error;

	NET_ASSERT_LOCKED();

	error = 0;

	if (newp)
		return EPERM;
	if (oldp && !oldlenp)
		return EINVAL;
	ol = oldlenp ? *oldlenp : 0;

	if (oldp) {
		p = malloc(ol, M_TEMP, M_WAITOK | M_CANFAIL);
		if (!p)
			return ENOMEM;
	} else
		p = NULL;
	switch (name) {
	case ICMPV6CTL_ND6_DRLIST:
		error = ENOTSUP; /* XXXDEL? can we delete more? */
		break;

	case ICMPV6CTL_ND6_PRLIST:
		error = ENOTSUP; /* XXXDEL? can we delete more? */
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}
	free(p, M_TEMP, ol);

	return (error);
@


1.209
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.208 2017/05/09 09:32:21 mpi Exp $	*/
a89 3
struct nd_drhead nd_defrouter;
struct nd_prhead nd_prefix = { 0 };

a102 3
int fill_drlist(void *, size_t *, size_t);
int fill_prlist(void *, size_t *, size_t);

a117 1
	TAILQ_INIT(&nd_defrouter);
a128 1
	nd6_rs_init();
a427 2
	struct nd_defrouter *dr, *ndr;
	struct nd_prefix *pr, *npr;
a434 5
	/* expire default router list */
	TAILQ_FOREACH_SAFE(dr, &nd_defrouter, dr_entry, ndr)
		if (dr->expire && dr->expire < time_uptime)
			defrtrlist_del(dr);

a463 17
	/* expire prefix list */
	LIST_FOREACH_SAFE(pr, &nd_prefix, ndpr_entry, npr) {
		/*
		 * check prefix lifetime.
		 * since pltime is just for autoconf, pltime processing for
		 * prefix is not necessary.
		 */
		if (pr->ndpr_vltime != ND6_INFINITE_LIFETIME &&
		    time_uptime - pr->ndpr_lastupdate > pr->ndpr_vltime) {
			/*
			 * address expiration and prefix expiration are
			 * separate.  NEVER perform in6_purgeaddr here.
			 */

			prelist_remove(pr);
		}
	}
a480 2
	struct nd_defrouter *dr, *ndr;
	struct nd_prefix *pr, *npr;
a484 32
	 * Nuke default router list entries toward ifp.
	 * We defer removal of default router list entries that is installed
	 * in the routing table, in order to keep additional side effects as
	 * small as possible.
	 */
	TAILQ_FOREACH_SAFE(dr, &nd_defrouter, dr_entry, ndr) {
		if (dr->installed)
			continue;

		if (dr->ifp == ifp)
			defrtrlist_del(dr);
	}
	TAILQ_FOREACH_SAFE(dr, &nd_defrouter, dr_entry, ndr) {
		if (!dr->installed)
			continue;

		if (dr->ifp == ifp)
			defrtrlist_del(dr);
	}

	/* Nuke prefix list entries toward ifp */
	LIST_FOREACH_SAFE(pr, &nd_prefix, ndpr_entry, npr) {
		if (pr->ndpr_ifp == ifp)
			prelist_remove(pr);
	}

	if (ifp->if_xflags & IFXF_AUTOCONF6) {
		/* refresh default router list */
		defrouter_select();
	}

	/*
a597 1
	struct nd_prefix *pr;
a628 16
	 * If the address matches one of our on-link prefixes, it should be a
	 * neighbor.
	 */
	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
		if (pr->ndpr_ifp != ifp)
			continue;

		if (!(pr->ndpr_stateflags & NDPRF_ONLINK))
			continue;

		if (IN6_ARE_MASKED_ADDR_EQUAL(&pr->ndpr_prefix.sin6_addr,
		    &addr->sin6_addr, &pr->ndpr_mask))
			return (1);
	}

	/*
a662 1
	struct nd_defrouter *dr;
d670 1
a670 27
		dr = defrouter_lookup(&satosin6(rt_key(rt))->sin6_addr,
		    rt->rt_ifidx);

		if (dr != NULL && dr->expire &&
		    ln->ln_state == ND6_LLINFO_STALE && gc) {
			/*
			 * If the reason for the deletion is just garbage
			 * collection, and the neighbor is an active default
			 * router, do not delete it.  Instead, reset the GC
			 * timer using the router's lifetime.
			 * Simply deleting the entry would affect default
			 * router selection, which is not necessarily a good
			 * thing, especially when we're using router preference
			 * values.
			 * XXX: the check for ln_state would be redundant,
			 *      but we intentionally keep it just in case.
			 */
			if (dr->expire > time_uptime) {
				nd6_llinfo_settimer(ln,
				    dr->expire - time_uptime);
			} else
				nd6_llinfo_settimer(ln, nd6_gctimer);
			if_put(ifp);
			return (TAILQ_NEXT(ln, ln_list));
		}

		if (ln->ln_router || dr) {
a677 30

		if (dr) {
			/*
			 * Unreachability of a router might affect the default
			 * router selection and on-link detection of advertised
			 * prefixes.
			 */

			/*
			 * Temporarily fake the state to choose a new default
			 * router and to perform on-link determination of
			 * prefixes correctly.
			 * Below the state will be set correctly,
			 * or the entry itself will be deleted.
			 */
			ln->ln_state = ND6_LLINFO_INCOMPLETE;

			/*
			 * Since defrouter_select() does not affect the
			 * on-link determination and MIP6 needs the check
			 * before the default router selection, we perform
			 * the check now.
			 */
			pfxlist_onlink_check();

			/*
			 * refresh default router list
			 */
			defrouter_select();
		}
d682 1
a682 3
	 * return value.  We need this because pfxlist_onlink_check() above
	 * might have freed other entries (particularly the old next entry) as
	 * a side effect (XXX).
a748 10
	struct nd_defrouter *dr;

	if (req == RTM_DELETE && (rt->rt_flags & RTF_GATEWAY) &&
	    (IN6_ARE_ADDR_EQUAL(&(satosin6(rt_key(rt)))->sin6_addr,
	    &in6addr_any) && rt_plen(rt) == 0)) {
		dr = defrouter_lookup(&satosin6(gate)->sin6_addr,
		    ifp->if_index);
		if (dr)
			dr->installed = 0;
	}
d995 1
a995 2
		defrouter_reset();
		defrouter_select();
d1000 1
a1000 40
		struct nd_prefix *pr, *npr;

		/* First purge the addresses referenced by a prefix. */
		LIST_FOREACH_SAFE(pr, &nd_prefix, ndpr_entry, npr) {
			struct ifnet *ifp;
			struct ifaddr *ifa, *nifa;
			struct in6_ifaddr *ia6;

			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue; /* XXX */

			/* do we really have to remove addresses as well? */
			TAILQ_FOREACH(ifp, &ifnet, if_list) {
				TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist,
				    ifa_list, nifa) {
					if (ifa->ifa_addr->sa_family !=
					    AF_INET6)
						continue;

					ia6 = ifatoia6(ifa);
					if ((ia6->ia6_flags & IN6_IFF_AUTOCONF)
					    == 0)
						continue;

					if (ia6->ia6_ndpr == pr)
						in6_purgeaddr(&ia6->ia_ifa);
				}
			}
		}
		/*
		 * Purging the addresses might remove the prefix as well.
		 * So run the loop again to access only prefixes that have
		 * not been freed already.
		 */
		LIST_FOREACH_SAFE(pr, &nd_prefix, ndpr_entry, npr) {
			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue; /* XXX */

			prelist_remove(pr);
		}
d1006 1
a1006 6
		struct nd_defrouter *dr, *ndr;

		defrouter_reset();
		TAILQ_FOREACH_SAFE(dr, &nd_defrouter, dr_entry, ndr)
			defrtrlist_del(dr);
		defrouter_select();
a1276 15
	/*
	 * When the link-layer address of a router changes, select the
	 * best router again.  In particular, when the neighbor entry is newly
	 * created, it might affect the selection policy.
	 * Question: can we restrict the first condition to the "is_newentry"
	 * case?
	 * XXX: when we hear an RA from a new router with the link-layer
	 * address option, defrouter_select() is called twice, since
	 * defrtrlist_update called the function as well.  However, I believe
	 * we can compromise the overhead, since it only happens the first
	 * time.
	 */
	if (do_update && ln->ln_router && (ifp->if_xflags & IFXF_AUTOCONF6))
		defrouter_select();

d1438 1
a1438 1

d1464 1
a1464 3
		error = fill_drlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
d1468 1
a1468 3
		error = fill_prlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
a1475 139

	return (error);
}

int
fill_drlist(void *oldp, size_t *oldlenp, size_t ol)
{
	int error = 0;
	struct in6_defrouter *d = NULL, *de = NULL;
	struct nd_defrouter *dr;
	time_t expire;
	size_t l;

	if (oldp) {
		d = (struct in6_defrouter *)oldp;
		de = (struct in6_defrouter *)((caddr_t)oldp + *oldlenp);
	}
	l = 0;

	TAILQ_FOREACH(dr, &nd_defrouter, dr_entry) {
		if (oldp && d + 1 <= de) {
			bzero(d, sizeof(*d));
			d->rtaddr.sin6_family = AF_INET6;
			d->rtaddr.sin6_len = sizeof(struct sockaddr_in6);
			in6_recoverscope(&d->rtaddr, &dr->rtaddr);
			d->flags = dr->flags;
			d->rtlifetime = dr->rtlifetime;
			expire = dr->expire;
			if (expire != 0) {
				expire -= time_uptime;
				expire += time_second;
			}
			d->expire = expire;
			d->if_index = dr->ifp->if_index;
		}

		l += sizeof(*d);
		if (d)
			d++;
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;

	return (error);
}

int
fill_prlist(void *oldp, size_t *oldlenp, size_t ol)
{
	int error = 0;
	struct nd_prefix *pr;
	char *p = NULL, *ps = NULL;
	char *pe = NULL;
	size_t l;

	if (oldp) {
		ps = p = (char *)oldp;
		pe = (char *)oldp + *oldlenp;
	}
	l = 0;

	LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
		u_short advrtrs;
		struct sockaddr_in6 sin6;
		struct nd_pfxrouter *pfr;
		struct in6_prefix pfx;

		if (oldp && p + sizeof(struct in6_prefix) <= pe) {
			memset(&pfx, 0, sizeof(pfx));
			ps = p;

			pfx.prefix = pr->ndpr_prefix;
			in6_recoverscope(&pfx.prefix,
			    &pfx.prefix.sin6_addr);
			pfx.raflags = pr->ndpr_raf;
			pfx.prefixlen = pr->ndpr_plen;
			pfx.vltime = pr->ndpr_vltime;
			pfx.pltime = pr->ndpr_pltime;
			pfx.if_index = pr->ndpr_ifp->if_index;
			if (pr->ndpr_vltime == ND6_INFINITE_LIFETIME)
				pfx.expire = 0;
			else {
				time_t maxexpire;

				/* XXX: we assume time_t is signed. */
				maxexpire = (time_t)~(1ULL <<
				    ((sizeof(maxexpire) * 8) - 1));
				if (pr->ndpr_vltime <
				    maxexpire - pr->ndpr_lastupdate) {
					pfx.expire = pr->ndpr_lastupdate +
						pr->ndpr_vltime;
				} else
					pfx.expire = maxexpire;
			}
			pfx.refcnt = pr->ndpr_refcnt;
			pfx.flags = pr->ndpr_stateflags;
			pfx.origin = PR_ORIG_RA;

			p += sizeof(pfx); l += sizeof(pfx);

			advrtrs = 0;
			LIST_FOREACH(pfr, &pr->ndpr_advrtrs, pfr_entry) {
				if (p + sizeof(sin6) > pe) {
					advrtrs++;
					continue;
				}
				bzero(&sin6, sizeof(sin6));
				sin6.sin6_family = AF_INET6;
				sin6.sin6_len = sizeof(struct sockaddr_in6);
				in6_recoverscope(&sin6, &pfr->router->rtaddr);
				advrtrs++;
				memcpy(p, &sin6, sizeof(sin6));
				p += sizeof(sin6);
				l += sizeof(sin6);
			}
			pfx.advrtrs = advrtrs;
			memcpy(ps, &pfx, sizeof(pfx));
		}
		else {
			l += sizeof(pfx);
			advrtrs = 0;
			LIST_FOREACH(pfr, &pr->ndpr_advrtrs, pfr_entry) {
				advrtrs++;
				l += sizeof(sin6);
			}
		}
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;
@


1.208
log
@Kill commented out code referencing pfctlinput2() and a wrong comment
about pfctlinput(PRC_HOSTDEAD).

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.207 2017/03/26 08:49:22 mpi Exp $	*/
d516 1
a516 1
	splsoftassert(IPL_SOFTNET);
d749 1
a749 1
	splsoftassert(IPL_SOFTNET);
d1133 1
a1133 1
	splsoftassert(IPL_SOFTNET);
@


1.207
log
@Do not invalidate a ND cache at the begining of nd6_free().

We should not change the state of a cache entry at this point since
the default router selection logic looks at it.  Instead, invalidate
the cache just before deleting the corresponding route entry, if it
applies.

Fixes a regression reported by semarie@@

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.206 2017/03/08 09:34:43 mpi Exp $	*/
a750 4
	/*
	 * we used to have pfctlinput(PRC_HOSTDEAD) here.
	 * even though it is not harmful, it was not really necessary.
	 */
@


1.206
log
@Always invalidate ND entries in nd6_free().

This way RTF_CACHED entries are properly flushed.  Fix a regression
reported by weerd@@ and also tested by matthieu@@.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.205 2017/03/03 08:01:59 mpi Exp $	*/
a750 2
	nd6_invalidate(rt);

d831 2
@


1.205
log
@Iterate over the global list of interfaces instead of using the global
list of IPv6 addresses.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.204 2017/03/02 09:24:02 mpi Exp $	*/
d750 2
@


1.204
log
@Prefer the global list of interfaces to the dying global list of IPv6
addresses in nd6_timer().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.203 2017/02/09 15:23:35 jca Exp $	*/
d1159 3
a1161 1
			struct in6_ifaddr *ia6, *ia6_next;
d1167 11
a1177 3
			TAILQ_FOREACH_SAFE(ia6, &in6_ifaddr, ia_list, ia6_next) {
				if ((ia6->ia6_flags & IN6_IFF_AUTOCONF) == 0)
					continue;
d1179 3
a1181 2
				if (ia6->ia6_ndpr == pr)
					in6_purgeaddr(&ia6->ia_ifa);
@


1.203
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.202 2016/12/27 18:45:01 bluhm Exp $	*/
d438 1
a438 1
	struct in6_ifaddr *ia6, *nia6;
d456 20
a475 12
	TAILQ_FOREACH_SAFE(ia6, &in6_ifaddr, ia_list, nia6) {
		/* check address lifetime */
		if (IFA6_IS_INVALID(ia6)) {
			in6_purgeaddr(&ia6->ia_ifa);
		} else if (IFA6_IS_DEPRECATED(ia6)) {
			ia6->ia6_flags |= IN6_IFF_DEPRECATED;
		} else {
			/*
			 * A new RA might have made a deprecated address
			 * preferred.
			 */
			ia6->ia6_flags &= ~IN6_IFF_DEPRECATED;
@


1.202
log
@Move nd6 timer initialisation to nd6_init() and call timeout_set()
only once during init.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.201 2016/12/23 15:08:54 mpi Exp $	*/
d252 1
a252 1
			icmp6stat.icp6s_nd_badopt++;
d296 1
a296 1
			icmp6stat.icp6s_nd_toomanyopt++;
@


1.201
log
@Do not call timeout_set(9) multiple times for nd6_slowtimo(), especially
whem timeout_set_proc(9) is what we need.

Found the hardway by and ok visa@@, ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.200 2016/12/22 13:39:32 mpi Exp $	*/
d96 2
a104 1
void nd6_timer_work(void *);
d133 2
a442 1
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
@


1.200
log
@Remove all splsoftnet() from ND6 converting the non-recrusive ones to
NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.199 2016/12/20 18:33:43 bluhm Exp $	*/
a1481 1
	timeout_set(&nd6_slowtimo_ch, nd6_slowtimo, NULL);
@


1.199
log
@A NET_LOCK() was is missing in tcp_sysctl() which shows up as spl
softnet assert failures.  It is better to place the lock into
net_sysctl() where all the protocol sysctls are called via pr_sysctl.
As calling sysctl(2) is in the slow path, doing fine grained locking
has no benefit.  Many sysctl cases copy out a struct.  Having a
lock around that keeps the struct consistent.  Put assertions in
the protocol sysctls that need it.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.198 2016/12/19 08:36:50 mpi Exp $	*/
d130 1
a130 1
	timeout_set(&nd6_slowtimo_ch, nd6_slowtimo, NULL);
a432 1
	int s;
d436 3
a439 1
	s = splsoftnet();
d486 1
a486 1
	splx(s);
d1124 2
a1125 1
	int s;
a1146 1
		s = splsoftnet();
a1173 1
		splx(s);
a1180 1
		s = splsoftnet();
a1184 1
		splx(s);
a1204 1
		s = splsoftnet();
a1209 1
			splx(s);
a1222 1
		splx(s);
a1475 1
	int s = splsoftnet();
d1478 3
d1484 1
d1499 1
a1499 1
	splx(s);
@


1.198
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.197 2016/11/28 14:14:39 mpi Exp $	*/
d1642 2
d1683 1
a1683 1
	int error = 0, s;
a1688 2
	s = splsoftnet();

a1723 2
	splx(s);

d1730 1
a1730 1
	int error = 0, s;
a1735 2
	s = splsoftnet();

a1814 2

	splx(s);
@


1.197
log
@Explicitly initialize rti_ifa when automagically adding a route.

This will allow to strengthen checks when userland adds a route.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.196 2016/11/28 13:59:51 mpi Exp $	*/
d330 1
a330 1
	s = splsoftnet();
d337 1
a337 1
		splx(s);
d424 1
a424 1
	splx(s);
@


1.196
log
@Remove multiple recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.195 2016/11/15 13:12:24 mpi Exp $	*/
d586 1
d596 1
a596 2
			struct ifaddr *ifa =
			    ifaof_ifpforaddr(sin6tosa(&sin6), ifp);
d607 1
@


1.195
log
@Kill recursive splsoftnet().

ok phessler@@, bluhm@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.194 2016/11/07 09:19:46 mpi Exp $	*/
d505 2
d736 2
a737 1
	int s;
a744 1
	s = splsoftnet();
a767 1
			splx(s);
a826 1
	splx(s);
@


1.194
log
@ARP and NDP timeouts mess with the routing table, so they need a process
context.

Convert them to timeout_set_proc(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.193 2016/10/03 12:33:21 mpi Exp $	*/
a310 4
	int s;

	s = splsoftnet();

a317 2

	splx(s);
@


1.193
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.192 2016/09/15 02:00:18 dlg Exp $	*/
d992 1
a992 1
		timeout_set(&ln->ln_timer_ch, nd6_llinfo_timer, ln);
@


1.192
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.191 2016/09/06 00:04:15 dlg Exp $	*/
d450 1
a450 1
		if (dr->expire && dr->expire < time_second)
d482 1
a482 1
		    time_second - pr->ndpr_lastupdate > pr->ndpr_vltime) {
d767 1
a767 1
			if (dr->expire > time_second) {
d769 1
a769 1
				    dr->expire - time_second);
d1689 1
d1708 6
a1713 1
			d->expire = dr->expire;
@


1.191
log
@pool_setipl for various netinet and netinet6 bits

thank you to everyone who helped reviewed these diffs

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.190 2016/08/22 16:01:52 mpi Exp $	*/
d119 2
a120 2
	pool_init(&nd6_pool, sizeof(struct llinfo_nd6), 0, 0, 0, "nd6", NULL);
	pool_setipl(&nd6_pool, IPL_SOFTNET);
@


1.190
log
@Make the ``rt_gwroute'' pointer of RTF_GATEWAY entries immutable.

This means that no protection is needed to guarantee that the next hop
route wont be modified by CPU1 while CPU0 is dereferencing it in a L2
resolution functions.

While here also fix an ``ifa'' leak resulting in RTF_GATEWAY being always
invalid.

dlg@@ likes it, inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.189 2016/08/22 10:33:22 mpi Exp $	*/
d120 1
@


1.189
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.188 2016/07/13 08:40:46 mpi Exp $	*/
d96 1
d715 11
d829 1
a829 1
	if (!ISSET(rt->rt_flags, RTF_STATIC))
d1112 5
a1514 1
	int error;
d1521 4
a1524 2
	error = rt_checkgate(rt0, &rt);
	if (error) {
d1526 1
a1526 1
		return (error);
@


1.188
log
@Introduce RTF_MULTICAST and flag corresponding IPv6 routes as such
instead of abusing RTF_CLONING.

Fix a leak reporeted by Aaron Riekenberg on misc@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.187 2016/07/13 01:51:22 dlg Exp $	*/
d156 1
a156 1
	free(nd, M_IP6NDP, 0);
d1637 1
a1637 1
		p = malloc(*oldlenp, M_TEMP, M_WAITOK | M_CANFAIL);
d1659 1
a1659 2
	if (p)
		free(p, M_TEMP, 0);
@


1.187
log
@store nd6 expiries in the route, not separately in the llinfo struct.

this makes it more consistent with arp, and makes expiries visible
via route(8) get as well as ndp(8).

ok mpi@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.186 2016/06/15 11:49:34 mpi Exp $	*/
d885 1
a885 1
	if ((rt->rt_flags & RTF_GATEWAY) != 0)
@


1.186
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.185 2016/06/08 12:57:58 mpi Exp $	*/
d314 1
a314 1
		ln->ln_expire = 0;
d317 1
a317 1
		ln->ln_expire = time_uptime + secs;
d984 1
a984 1
			 * and ln->ln_expire should have some lifetime
d1203 1
a1203 1
		expire = ln->ln_expire;
@


1.185
log
@Move ND resoluton logic from nd6_output() to nd6_storelladdr() and
rename it to nd6_resolve().

This allows us to get rid of non-Ethernet hacks by moving Ethernet
specific logic in the appropriate layer.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.184 2016/06/06 10:16:23 sthen Exp $	*/
d1355 1
a1355 1
			 * XXX: since nd6_output() below will cause
d1369 1
a1369 1
				nd6_output(ifp, n, satosin6(rt_key(rt)), rt);
a1488 7
}

int
nd6_output(struct ifnet *ifp, struct mbuf *m0, struct sockaddr_in6 *dst,
    struct rtentry *rt0)
{
	return (ifp->if_output(ifp, m0, sin6tosa(dst), rt0));
@


1.184
log
@Move nd6_output()'s "short-circuiting" for non-lladdr interface types earlier.

nd6.c's nd6_output() decides whether link-layer address resolution is needed
before sending the packet. Up to r1.178 packets for many non-ethernet interface
types were sent directly without checking the gateway or determining if link-
layer address resolution was needed. In r1.179 this was changed to skip some
decision making for gif(4) but moved the short-circuiting for those interface
types to *after* the gateway was checked. In my v6 pppoe setup, rt_checkgate
is returning EHOSTUNREACH so this move prevented it from working.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.183 2016/06/03 02:08:15 dlg Exp $	*/
d1495 9
a1503 2
	struct mbuf *m = m0;
	struct rtentry *rt = rt0;
d1505 1
a1505 1
	int error = 0;
d1507 4
a1510 5
	if (IN6_IS_ADDR_MULTICAST(&dst->sin6_addr))
		goto sendpkt;

	if (nd6_need_cache(ifp) == 0)
		goto sendpkt;
d1533 6
d1568 15
a1582 2
	if (ln->ln_state > ND6_LLINFO_INCOMPLETE)
		goto sendpkt;
d1593 1
d1601 1
a1601 1
		nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
d1603 1
a1603 5
	return (0);

  sendpkt:
	error = ifp->if_output(ifp, m, sin6tosa(dst), rt);
	return (error);
a1620 47
}

int
nd6_storelladdr(struct ifnet *ifp, struct rtentry *rt0, struct mbuf *m,
    struct sockaddr *dst, u_char *desten)
{
	struct sockaddr_dl *sdl;
	struct rtentry *rt;
	int error;

	if (m->m_flags & M_MCAST) {
		switch (ifp->if_type) {
		case IFT_ETHER:
		case IFT_CARP:
			ETHER_MAP_IPV6_MULTICAST(&satosin6(dst)->sin6_addr,
						 desten);
			return (0);
			break;
		default:
			m_freem(m);
			return (EINVAL);
		}
	}

	error = rt_checkgate(rt0, &rt);
	if (error) {
		m_freem(m);
		return (error);
	}

	if (rt->rt_gateway->sa_family != AF_LINK) {
		printf("%s: something odd happens\n", __func__);
		m_freem(m);
		return (EINVAL);
	}
	sdl = satosdl(rt->rt_gateway);
	if (sdl->sdl_alen != ETHER_ADDR_LEN) {
		char addr[INET6_ADDRSTRLEN];
		log(LOG_DEBUG, "%s: %s: incorrect nd6 information\n", __func__,
		    inet_ntop(AF_INET6, &satosin6(dst)->sin6_addr,
			addr, sizeof(addr)));
		m_freem(m);
		return (EINVAL);
	}

	bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
	return (0);
@


1.183
log
@measure nd expiry times against time_uptime, not time_second.

time_second can be jumped by clock changes, while time_uptime will
always progress monotonically.

it is still translated to time_seconds for export to userland though.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.182 2016/06/01 23:45:19 dlg Exp $	*/
d1503 3
a1510 3

	if (nd6_need_cache(ifp) == 0)
		goto sendpkt;
@


1.182
log
@make nd6_llinfo_settimer take seconds instead of ticks.

most callers are working in seconds, internally it uses seconds, and
you can call timeout_add_sec as easily as timeout_add.

this also fixes an issue with an nd_defrouter expire which was
incorrectly scaled with ticks in a comparison.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.181 2016/05/31 07:50:34 mpi Exp $	*/
d317 1
a317 1
		ln->ln_expire = time_second + secs;
d1180 1
d1203 6
d1212 1
a1212 1
		nbi->expire = ln->ln_expire;
@


1.181
log
@Stop creating and inserting a route entry for ARP and ND automagically.

Callers MUST do a route lookup before sending a packet.

Tested by Hrvoje Popovski, ok visa@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.180 2016/05/30 23:37:37 dlg Exp $	*/
d307 1
a307 1
nd6_llinfo_settimer(struct llinfo_nd6 *ln, long tick)
d313 1
a313 1
	if (tick < 0) {
d317 2
a318 2
		ln->ln_expire = time_second + tick / hz;
		timeout_add(&ln->ln_timer_ch, tick);
d358 1
a358 1
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
d388 1
a388 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d406 1
a406 1
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
d411 1
a411 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d417 1
a417 1
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
d754 1
a754 1
			if (dr->expire > time_second * hz) {
d756 1
a756 1
				    dr->expire - time_second * hz);
d758 1
a758 1
				nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d863 1
a863 1
		nd6_llinfo_settimer(ln, (long)ND_IFINFO(ifp)->reachable * hz);
d1353 1
a1353 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d1541 1
a1541 1
		nd6_llinfo_settimer(ln, nd6_delay * hz);
d1567 1
a1567 2
		nd6_llinfo_settimer(ln,
		    (long)ND_IFINFO(ifp)->retrans * hz / 1000);
@


1.180
log
@remove code compensating for the "short" range of timeouts.

the nd6 code for managing expiries is never asked to handle intervals
greater than what timeouts can handle, so we dont need to overcompensate.

the code was also incorrect by using a long, which isnt that long
on ILP32 machines.

ok mpi@@ millert@@ benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.179 2016/05/17 08:29:14 mpi Exp $	*/
d1491 1
a1491 1
	int created = 0, error = 0;
d1496 4
a1499 9
	/*
	 * next hop determination.
	 */
	if (rt0 != NULL) {
		error = rt_checkgate(rt0, &rt);
		if (error) {
			m_freem(m);
			return (error);
		}
d1511 7
a1517 18

	/* Look up the neighbor cache for the nexthop */
	if (rt != NULL && (rt->rt_flags & RTF_LLINFO) != 0)
		ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	else {
		/*
		 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(),
		 * the condition below is not very efficient.  But we believe
		 * it is tolerable, because this should be a rare case.
		 */
		if (nd6_is_addr_neighbor(dst, ifp)) {
			rt = nd6_lookup(&dst->sin6_addr, 1, ifp,
			    ifp->if_rdomain);
			if (rt != NULL) {
				created = 1;
				ln = (struct llinfo_nd6 *)rt->rt_llinfo;
			}
		}
a1518 3
	if (ln == NULL || rt == NULL) {
		if ((ND_IFINFO(ifp)->flags & ND6_IFF_PERFORMNUD) == 0) {
			char addr[INET6_ADDRSTRLEN];
d1520 2
a1521 13
			log(LOG_DEBUG, "%s: can't allocate llinfo for %s "
			    "(ln=%p, rt=%p)\n", __func__,
			    inet_ntop(AF_INET6, &dst->sin6_addr,
				addr, sizeof(addr)),
			    ln, rt);
			m_freem(m);
			if (created)
				rtfree(rt);
			return (EIO);	/* XXX: good error? */
		}

		goto sendpkt;	/* send anyway */
	}
a1570 2
	if (created)
		rtfree(rt);
a1574 2
	if (created)
		rtfree(rt);
a1614 6
	}

	if (rt0 == NULL) {
		/* this could happen, if we could not allocate memory */
		m_freem(m);
		return (ENOMEM);
@


1.179
log
@Completely skip link-layer address resolution and NUD on gif(4).

Tested by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.178 2016/04/27 14:47:27 mpi Exp $	*/
a314 1
		ln->ln_ntick = 0;
d318 1
a318 7
		if (tick > INT_MAX) {
			ln->ln_ntick = tick - INT_MAX;
			timeout_add(&ln->ln_timer_ch, INT_MAX);
		} else {
			ln->ln_ntick = 0;
			timeout_add(&ln->ln_timer_ch, tick);
		}
a336 12

	if (ln->ln_ntick > 0) {
		if (ln->ln_ntick > INT_MAX) {
			ln->ln_ntick -= INT_MAX;
			nd6_llinfo_settimer(ln, INT_MAX);
		} else {
			ln->ln_ntick = 0;
			nd6_llinfo_settimer(ln, ln->ln_ntick);
		}
		splx(s);
		return;
	}
@


1.178
log
@Remove unused arguments from rt_checkgate().

Since the rtalloc(9) rewrite no route lookup is done in this function so
there's no need for a destination or a rtable ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.177 2016/03/07 11:00:36 mpi Exp $	*/
a1514 3
	if (nd6_need_cache(ifp) == 0)
		goto sendpkt;

d1524 1
d1526 2
a1527 13
		/*
		 * We skip link-layer address resolution and NUD
		 * if the gateway is not a neighbor from ND point
		 * of view, regardless of the value of nd_ifinfo.flags.
		 * The second condition is a bit tricky; we skip
		 * if the gateway is our own address, which is
		 * sometimes used to install a route to a p2p link.
		 */
		if ((ifp->if_flags & IFF_POINTOPOINT) &&
		    ((nd6_is_addr_neighbor(satosin6(rt_key(rt)), ifp) == 0) ||
		    in6ifa_ifpwithaddr(ifp, &satosin6(rt_key(rt))->sin6_addr)))
			goto sendpkt;
	}
d1555 1
a1555 2
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0 &&
		    !(ND_IFINFO(ifp)->flags & ND6_IFF_PERFORMNUD)) {
a1579 7
	/* We don't have to do link-layer address resolution on a p2p link. */
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    ln->ln_state < ND6_LLINFO_REACHABLE) {
		ln->ln_state = ND6_LLINFO_STALE;
		nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
	}

a1639 2
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
a1641 1
	case IFT_GIF:		/* XXX need more cases? */
@


1.177
log
@Do not remove RTF_STATIC L2 entries from the routing table.

This restore the previous behavior without looking at the reference
counter of route entries.

Static entries might not have a cloning route to re-create them and
when their timer expires they were completly gone as found the hardway
by matthieu@@.

ok matthieu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.176 2015/12/03 21:57:59 mpi Exp $	*/
d1522 1
a1522 2
		error = rt_checkgate(ifp, rt0, sin6tosa(dst),
		    m->m_pkthdr.ph_rtableid, &rt);
d1700 1
a1700 1
	error = rt_checkgate(ifp, rt0, dst, m->m_pkthdr.ph_rtableid, &rt);
@


1.176
log
@Get rid of rt_mask() and stop allocating a "struct sockaddr" for every
route entry in ART.

rt_plen() now represents the prefix length of a route entry and should
be used instead.

For now use a "struct sockaddr_in6" to represent the mask when needed,
this should be then replaced by the prefix length and RTA_NETMASK only
used for compatibility with userland.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.175 2015/12/02 16:35:53 bluhm Exp $	*/
d836 2
a837 1
	rtdeletemsg(rt, ifp, ifp->if_rdomain);
@


1.175
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.174 2015/12/02 13:29:26 claudio Exp $	*/
d896 1
a896 3
	    &in6addr_any) && rt_mask(rt) && (rt_mask(rt)->sa_len == 0 ||
	    IN6_ARE_ADDR_EQUAL(&(satosin6(rt_mask(rt)))->sin6_addr,
	    &in6addr_any)))) {
@


1.174
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.173 2015/12/01 12:22:18 mpi Exp $	*/
d836 1
a836 1
	rtdeletemsg(rt, ifp->if_rdomain);
@


1.173
log
@Remove backward compatibility for "older version of routed and gated".

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.172 2015/11/06 11:20:56 mpi Exp $	*/
d589 1
a589 1
	flags = (create) ? (RT_REPORT|RT_RESOLVE) : 0;
@


1.172
log
@Change nd6_nud_hint() to no longer manipulate rt_ifp directly.

While here remove unused argument and convert the route check to
rtisvalid(9).

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.171 2015/11/02 12:51:16 bluhm Exp $	*/
a939 7
		/*
		 * There is no backward compatibility :)
		 *
		 * if ((rt->rt_flags & RTF_HOST) == 0 &&
		 *     SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
		 *	   rt->rt_flags |= RTF_CLONING;
		 */
@


1.171
log
@Implement the list of nd6 llinfo entries with a TAILQ.
OK millert@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.170 2015/11/02 07:24:08 mpi Exp $	*/
d850 1
a850 1
nd6_nud_hint(struct rtentry *rt, u_int rtableid)
d853 1
d855 2
a856 1
	if (rt == NULL) {
a857 1
	}
d864 1
a864 1
		return;
d869 1
a869 1
		return;
d877 1
a877 1
		return;
d880 4
a883 4
	if (!ND6_LLINFO_PERMANENT(ln)) {
		nd6_llinfo_settimer(ln,
		    (long)ND_IFINFO(rt->rt_ifp)->reachable * hz);
	}
@


1.170
log
@Prefer an existing refcounted ``ifp'' to rt_ifp when possible or use the
interface index directly.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.169 2015/11/01 22:53:34 bluhm Exp $	*/
d86 1
d88 1
a88 1
static int nd6_inuse, nd6_allocated;
a89 1
struct llinfo_nd6 llinfo_nd6 = {&llinfo_nd6, &llinfo_nd6};
a106 11
#define LN_DEQUEUE(ln) do { \
	(ln)->ln_next->ln_prev = (ln)->ln_prev; \
	(ln)->ln_prev->ln_next = (ln)->ln_next; \
	} while (0)
#define LN_INSERTHEAD(ln) do { \
	(ln)->ln_next = llinfo_nd6.ln_next; \
	llinfo_nd6.ln_next = (ln); \
	(ln)->ln_prev = &llinfo_nd6; \
	(ln)->ln_next->ln_prev = (ln); \
	} while (0)

d117 1
d563 1
a563 2
	ln = llinfo_nd6.ln_next;
	while (ln && ln != &llinfo_nd6) {
a566 1
		nln = ln->ln_next;
d568 1
a568 1
		if (rt && rt->rt_gateway &&
a573 1
		ln = nln;
d780 1
a780 1
			return (ln->ln_next);
d829 1
a829 1
	next = ln->ln_next;
d1024 1
a1024 4
		ln->ln_next = llinfo_nd6.ln_next;
		llinfo_nd6.ln_next = ln;
		ln->ln_prev = &llinfo_nd6;
		ln->ln_next->ln_prev = ln;
d1037 6
a1042 2
			for (i = 0; i < 10 && llinfo_nd6.ln_prev != ln; i++) {
				struct llinfo_nd6 *ln_end = llinfo_nd6.ln_prev;
d1045 2
a1046 2
				LN_DEQUEUE(ln_end);
				LN_INSERTHEAD(ln_end);
d1120 1
a1120 3
		ln->ln_next->ln_prev = ln->ln_prev;
		ln->ln_prev->ln_next = ln->ln_next;
		ln->ln_prev = NULL;
d1599 2
a1600 2
	LN_DEQUEUE(ln);
	LN_INSERTHEAD(ln);
@


1.169
log
@Replace the nd6 llinfo malloc(9) with pool_get(9) like arp does.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.168 2015/11/01 17:02:44 bluhm Exp $	*/
d665 1
a665 1
	    (ifp != NULL && rt->rt_ifp != ifp)) {
d758 1
d765 1
d770 1
a770 1
		    rt->rt_ifp);
d792 1
d802 1
a802 1
			rt6_flush(&in6, rt->rt_ifp);
d849 1
a849 1
	rtdeletemsg(rt, rt->rt_ifp->if_rdomain);
d852 2
d911 2
a912 1
		dr = defrouter_lookup(&satosin6(gate)->sin6_addr, ifp);
@


1.168
log
@Compare nd6 llinfo pointer with NULL.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.167 2015/10/30 09:39:42 bluhm Exp $	*/
d42 1
d86 1
d128 2
d1003 1
a1003 1
		ln = malloc(sizeof(*ln), M_RTABLE, M_NOWAIT | M_ZERO);
d1006 1
a1006 1
			log(LOG_DEBUG, "%s: malloc failed\n", __func__);
d1133 1
a1133 1
		free(ln, M_RTABLE, 0);
@


1.167
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.166 2015/10/29 14:28:34 mpi Exp $	*/
d373 1
a373 1
	if (rt->rt_llinfo && (struct llinfo_nd6 *)rt->rt_llinfo != ln)
d644 1
a644 1
			if (rt->rt_llinfo) {
d864 1
a864 1
	    !rt->rt_llinfo || !rt->rt_gateway ||
d950 2
a951 2
		    ((rt->rt_flags & (RTF_LLINFO | RTF_LOCAL)) && !ln)) {
			if (ln)
d1001 1
a1001 1
		if (!ln) {
d1102 1
a1102 1
		if (!ln)
d1126 1
a1126 1
		rt->rt_llinfo = 0;
d1312 1
a1312 1
	if (!ln)
d1314 1
a1314 1
	if (!rt->rt_gateway)
d1562 1
a1562 1
	if (rt && (rt->rt_flags & RTF_LLINFO) != 0)
d1579 1
a1579 1
	if (!ln || !rt) {
@


1.166
log
@Kill a comment saying that rt_ifp may not be the same as ifp, that's no
longer true.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.165 2015/10/28 12:45:44 jsg Exp $	*/
d634 1
a634 1
			 * called in rtrequest1.
d640 1
a640 1
			error = rtrequest1(RTM_ADD, &info, RTP_CONNECTED, &rt,
@


1.165
log
@Add a missing splx for a return path introduced in rev 1.163
ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.164 2015/10/28 12:14:25 florian Exp $	*/
a567 3
	 * Note that rt->rt_ifp may not be the same as ifp,
	 * due to KAME goto ours hack.  See RTM_RESOLVE case in
	 * nd6_rtrequest(), and ip6_input().
@


1.164
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.163 2015/10/27 10:52:18 mpi Exp $	*/
d365 2
a366 1
	if ((ifp = if_get(rt->rt_ifidx)) == NULL)
d368 1
@


1.163
log
@Use rt_ifidx rather than rt_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.162 2015/10/25 15:11:52 deraadt Exp $	*/
a92 1
void nd6_setmtu0(struct ifnet *, struct nd_ifinfo *);
a154 3
	/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
	nd6_setmtu0(ifp, nd);

a162 26
}

void
nd6_setmtu(struct ifnet *ifp)
{
	nd6_setmtu0(ifp, ND_IFINFO(ifp));
}

void
nd6_setmtu0(struct ifnet *ifp, struct nd_ifinfo *ndi)
{
	u_int32_t omaxmtu;

	omaxmtu = ndi->maxmtu;
	ndi->maxmtu = ifp->if_mtu;

	/*
	 * Decreasing the interface MTU under IPV6 minimum MTU may cause
	 * undesirable situation.  We thus notify the operator of the change
	 * explicitly.  The check for omaxmtu is necessary to restrict the
	 * log to the case of changing the MTU, not initializing it.
	 */
	if (omaxmtu >= IPV6_MMTU && ndi->maxmtu < IPV6_MMTU) {
		log(LOG_NOTICE, "%s: link MTU on %s (%lu) too small for IPv6\n",
		    __func__, ifp->if_xname, (unsigned long)ndi->maxmtu);
	}
@


1.162
log
@do not expose nd6 randomid's to userland via ioctl.
ok claudio mpi florian
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.161 2015/10/25 15:01:59 mpi Exp $	*/
d395 2
a396 2
	if ((ifp = rt->rt_ifp) == NULL)
		panic("ln->ln_rt->rt_ifp == NULL");
d480 1
@


1.161
log
@Trivial rt_ifp->if_index -> rt_ifidx conversions.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.160 2015/10/25 11:58:11 mpi Exp $	*/
d1175 3
@


1.160
log
@Introduce if_rtrequest() the successor of ifa_rtrequest().

L2 resolution depends on the protocol (encoded in the route entry) and
an ``ifp''.  Not having to care about an ``ifa'' makes our life easier
in our MP effort.  Fewer dependencies between data structures implies
fewer headaches.

Discussed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.159 2015/10/24 16:08:48 mpi Exp $	*/
d424 1
a424 1
				m->m_pkthdr.ph_ifidx = rt->rt_ifp->if_index;
@


1.159
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.158 2015/10/22 16:44:54 mpi Exp $	*/
d664 1
a664 1
			 * called in rtrequest1 via ifa->ifa_rtrequest.
d920 1
a920 1
nd6_rtrequest(int req, struct rtentry *rt)
a923 1
	struct ifnet *ifp = rt->rt_ifp;
@


1.158
log
@Make sure that the address matching the key (destination) of a route
entry is attached to this entry.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.157 2015/10/22 15:37:47 bluhm Exp $	*/
a149 1
	nd->chlim = IPV6_DEFHLIM;
@


1.157
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.156 2015/10/22 10:27:22 mpi Exp $	*/
d1103 1
a1103 14

			/*
			 * Make sure rt_ifa be equal to the ifaddr
			 * corresponding to the address.
			 * We need this because when we refer
			 * rt_ifa->ia6_flags in ip6_input, we assume
			 * that the rt_ifa points to the address instead
			 * of the loopback address.
			 */
			if (ifa != rt->rt_ifa) {
				ifafree(rt->rt_ifa);
				ifa->ifa_refcnt++;
				rt->rt_ifa = ifa;
			}
@


1.156
log
@Use rt_ifp as intended.

During s2k15 we fixed this ugly 20+ years loopback hack of having a
rt_ifp different than rt_ifa->ifa_ifp.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.155 2015/10/01 09:10:22 mpi Exp $	*/
a66 2
#define SDL(s) ((struct sockaddr_dl *)s)

d609 1
a609 1
			sdl = (struct sockaddr_dl *)rt->rt_gateway;
d670 1
a670 2
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)ifp->if_sadl;
d1023 2
a1024 2
		SDL(gate)->sdl_type = ifp->if_type;
		SDL(gate)->sdl_index = ifp->if_index;
d1360 1
a1360 1
	sdl = SDL(rt->rt_gateway);
d1765 1
a1765 1
	sdl = SDL(rt->rt_gateway);
@


1.155
log
@Use rtdeletemsg() in nd6_free() to align it with arptfree().

This gives us userland notification for free and get rid of a
rtrequest1(9) call.

ok phessler@@, mikeb@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.154 2015/09/18 14:26:22 mpi Exp $	*/
a691 5
	 * XXX: we can't use rt->rt_ifp to check for the interface, since
	 *      it might be the loopback interface if the entry is for our
	 *      own address on a non-loopback interface. Instead, we should
	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL
	 *	interface.
d695 1
a695 1
	    (ifp && rt->rt_ifa->ifa_ifp != ifp)) {
@


1.154
log
@Do not manually decrement rt's refcounter in nd6_lookup() and let the
callers rtfree(9) it.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.153 2015/09/13 17:53:44 mpi Exp $	*/
a789 1
	struct rt_addrinfo info;
d881 1
a881 5
	bzero(&info, sizeof(info));
	info.rti_info[RTAX_DST] = rt_key(rt);
	info.rti_info[RTAX_NETMASK] = rt_mask(rt);
	rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
	    rt->rt_ifp->if_rdomain);
@


1.153
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.152 2015/09/12 20:50:17 mpi Exp $	*/
d634 1
a634 1
	if (rt && (rt->rt_flags & RTF_LLINFO) == 0) {
d646 1
a646 1
	if (!rt) {
a685 1
	rt->rt_refcnt--;
d708 1
d772 3
a774 2
	if ((rt = nd6_lookup(&addr->sin6_addr, 0, ifp,
	    ifp->if_rdomain)) != NULL)
d776 1
d1279 2
a1280 1
		if ((rt = nd6_lookup(&nb_addr, 0, ifp, ifp->if_rdomain)) == NULL ||
d1283 1
d1291 1
d1340 1
a1340 1
	if (!rt) {
d1351 2
a1352 1
		if (rt->rt_flags & RTF_STATIC)
d1354 1
d1363 1
d1539 2
a1568 1
#define senderr(e) { error = (e); goto bad;}
d1576 1
a1576 1
	int error = 0;
d1625 8
a1632 4
		if (nd6_is_addr_neighbor(dst, ifp) &&
		    (rt = nd6_lookup(&dst->sin6_addr, 1, ifp,
		     ifp->if_rdomain)) != NULL)
			ln = (struct llinfo_nd6 *)rt->rt_llinfo;
d1644 4
a1647 1
			senderr(EIO);	/* XXX: good error? */
d1708 2
d1713 3
a1715 4
	return (ifp->if_output(ifp, m, sin6tosa(dst), rt));

  bad:
	m_freem(m);
a1717 1
#undef senderr
@


1.152
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.151 2015/09/12 20:26:07 mpi Exp $	*/
d1695 1
a1695 1
	return (if_output(ifp, m, sin6tosa(dst), rt));
@


1.151
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.150 2015/09/10 17:52:05 claudio Exp $	*/
d670 1
a670 1
			info.rti_flags = RTF_UP | RTF_HOST | RTF_LLINFO;
@


1.150
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.149 2015/08/31 10:03:47 mpi Exp $	*/
a1115 7
			 * XXX Since lo0 is in the default rdomain we
			 * should not (ab)use it for any route related
			 * to an interface of a different rdomain.
			 */
			rt->rt_ifp = lo0ifp;

			/*
d1695 1
a1695 1
	return ((*ifp->if_output)(ifp, m, sin6tosa(dst), rt));
@


1.149
log
@The return value of nd6_cache_lladdr() is never used so make it a void.

Fewer "struct rtentry" left in the wild!
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.148 2015/08/24 23:26:43 mpi Exp $	*/
d1853 1
a1853 1
			in6_recoverscope(&d->rtaddr, &dr->rtaddr, dr->ifp);
a1898 1
		char addr[INET6_ADDRSTRLEN];
d1905 2
a1906 6
			if (in6_recoverscope(&pfx.prefix,
			    &pfx.prefix.sin6_addr, pr->ndpr_ifp) != 0)
				log(LOG_ERR,
				    "scope error in prefix list (%s)\n",
				    inet_ntop(AF_INET6, &pfx.prefix.sin6_addr,
					addr, sizeof(addr)));
d1942 1
a1942 2
				in6_recoverscope(&sin6, &pfr->router->rtaddr,
				    pfr->router->ifp);
@


1.148
log
@Start moving away from the global prefix list by limiting its usage to
AUTOCONF'd addresses.

This prevent the kernel from removing connected (/64) routes as soon as
it configures an AUTOCONF'd address based on a RA.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.147 2015/08/24 14:00:29 bluhm Exp $	*/
d1309 1
a1309 1
struct rtentry *
d1329 1
a1329 1
		return NULL;
d1354 1
a1354 1
			return NULL;
d1359 1
a1359 1
		return NULL;
d1363 1
a1363 1
		return NULL;
a1537 2

	return rt;
@


1.147
log
@In kernel initialize struct sockaddr_in and sockaddr_in6 to zero
everywhere to avoid passing around pointers to uninitialized stack
memory.  While there, fix the call to in6_recoverscope() in
fill_drlist().
OK deraadt@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.146 2015/08/23 14:12:05 naddy Exp $	*/
d722 2
d735 16
@


1.146
log
@Use simple byte pointer arithmetic and memcpy from/to aligned stack
variables to handle the "packed" binary format passed out to userland
when querying the prefix/router list.  From NetBSD (Martin Husemann).
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.145 2015/08/19 13:27:38 bluhm Exp $	*/
d1837 1
a1837 3
			d->rtaddr.sin6_addr = dr->rtaddr;
			in6_recoverscope(&d->rtaddr, &d->rtaddr.sin6_addr,
			    dr->ifp);
d1928 1
a1930 1
				sin6.sin6_addr = pfr->router->rtaddr;
@


1.145
log
@Convert all calls to rtrequest1() and the following error check
into a common pattern.  In the man page clarify the usage of the
returned route.
OK mpi@@ mikeb@@ jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.144 2015/08/17 09:58:10 mpi Exp $	*/
d1868 2
a1869 2
	struct in6_prefix *p = NULL;
	struct in6_prefix *pe = NULL;
d1875 2
a1876 2
		p = (struct in6_prefix *)oldp;
		pe = (struct in6_prefix *)((caddr_t)oldp + *oldlenp);
d1882 1
a1882 3
		size_t advance;
		struct sockaddr_in6 *sin6;
		struct sockaddr_in6 *s6;
d1884 1
d1887 7
a1893 8
		if (oldp && p + 1 <= pe)
		{
			bzero(p, sizeof(*p));
			sin6 = (struct sockaddr_in6 *)(p + 1);

			p->prefix = pr->ndpr_prefix;
			if (in6_recoverscope(&p->prefix,
			    &p->prefix.sin6_addr, pr->ndpr_ifp) != 0)
d1896 1
a1896 1
				    inet_ntop(AF_INET6, &p->prefix.sin6_addr,
d1898 5
a1902 5
			p->raflags = pr->ndpr_raf;
			p->prefixlen = pr->ndpr_plen;
			p->vltime = pr->ndpr_vltime;
			p->pltime = pr->ndpr_pltime;
			p->if_index = pr->ndpr_ifp->if_index;
d1904 1
a1904 1
				p->expire = 0;
d1913 1
a1913 1
					p->expire = pr->ndpr_lastupdate +
d1916 1
a1916 1
					p->expire = maxexpire;
d1918 6
a1923 3
			p->refcnt = pr->ndpr_refcnt;
			p->flags = pr->ndpr_stateflags;
			p->origin = PR_ORIG_RA;
d1926 1
a1926 1
				if ((void *)&sin6[advrtrs + 1] > (void *)pe) {
d1930 4
a1933 5
				s6 = &sin6[advrtrs];
				s6->sin6_family = AF_INET6;
				s6->sin6_len = sizeof(struct sockaddr_in6);
				s6->sin6_addr = pfr->router->rtaddr;
				in6_recoverscope(s6, &pfr->router->rtaddr,
d1936 3
d1940 2
a1941 1
			p->advrtrs = advrtrs;
d1944 1
d1946 1
a1946 1
			LIST_FOREACH(pfr, &pr->ndpr_advrtrs, pfr_entry)
d1948 2
a1950 5

		advance = sizeof(*p) + sizeof(*sin6) * advrtrs;
		l += advance;
		if (p)
			p = (struct in6_prefix *)((caddr_t)p + advance);
@


1.144
log
@Use __func__ rather than the function name in log(9) calls to remove
some grep output noise.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.143 2015/07/16 15:31:35 mpi Exp $	*/
d649 1
a649 1
			int e;
d674 3
a676 12
			if ((e = rtrequest1(RTM_ADD, &info, RTP_CONNECTED,
			    &rt, rtableid)) != 0) {
#if 0
				char ip[INET6_ADDRSTRLEN];
				log(LOG_ERR, "%s: failed to add route for a "
				    "neighbor(%s), errno=%d\n", __func__,
				    inet_ntop(AF_INET6, addr6, ip, sizeof(ip)),
				    e);
#endif
				return (NULL);
			}
			if (rt == NULL)
@


1.143
log
@Properly layer Router Solicitation code.

Tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.142 2015/07/15 22:16:42 deraadt Exp $	*/
d125 1
a125 1
		log(LOG_NOTICE, "nd6_init called more than once(ignored)\n");
d193 2
a194 3
		log(LOG_NOTICE, "nd6_setmtu0: "
		    "new link MTU on %s (%lu) is too small for IPv6\n",
		    ifp->if_xname, (unsigned long)ndi->maxmtu);
d678 2
a679 3
				log(LOG_ERR,
				    "nd6_lookup: failed to add route for a "
				    "neighbor(%s), errno=%d\n",
d713 2
a714 2
			nd6log((LOG_DEBUG,
			    "nd6_lookup: failed to lookup %s (if = %s)\n",
d1626 2
a1627 3
			log(LOG_DEBUG,
			    "nd6_output: can't allocate llinfo for %s "
			    "(ln=%p, rt=%p)\n",
d1758 1
a1758 1
		printf("nd6_storelladdr: something odd happens\n");
@


1.142
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.141 2015/07/15 21:37:06 mpi Exp $	*/
a104 5
struct timeout nd6_rs_output_timer;
int nd6_rs_output_timeout = ND6_RS_OUTPUT_INTERVAL;
int nd6_rs_timeout_count = 0;
void nd6_rs_output_timo(void *);

d140 1
a140 1
	timeout_set(&nd6_rs_output_timer, nd6_rs_output_timo, NULL);
a1558 33
}

void
nd6_rs_output_set_timo(int timeout)
{
	nd6_rs_output_timeout = timeout;
	timeout_add_sec(&nd6_rs_output_timer, nd6_rs_output_timeout);
}

void
nd6_rs_output_timo(void *ignored_arg)
{
	struct ifnet *ifp;
	struct in6_ifaddr *ia6;

	if (nd6_rs_timeout_count == 0)
		return;

	if (nd6_rs_output_timeout < ND6_RS_OUTPUT_INTERVAL)
		/* exponential backoff if running quick timeouts */
		nd6_rs_output_timeout *= 2;
	if (nd6_rs_output_timeout > ND6_RS_OUTPUT_INTERVAL)
		nd6_rs_output_timeout = ND6_RS_OUTPUT_INTERVAL;

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ISSET(ifp->if_flags, IFF_RUNNING) &&
		    ISSET(ifp->if_xflags, IFXF_AUTOCONF6)) {
			ia6 = in6ifa_ifpforlinklocal(ifp, IN6_IFF_TENTATIVE);
			if (ia6 != NULL)
				nd6_rs_output(ifp, ia6);
		}
	}
	timeout_add_sec(&nd6_rs_output_timer, nd6_rs_output_timeout);
@


1.141
log
@Recognize CARP interfaces when sending packet to a multicast address.

Fix a regression introduced when carp(4) left ether_output() found the
hardway by florian@@ and phessler@@.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.140 2015/07/09 05:45:25 mpi Exp $	*/
d1189 1
a1189 2
		if (ln->ln_hold)
			m_freem(ln->ln_hold);
d1721 1
a1721 2
	if (ln->ln_hold)
		m_freem(ln->ln_hold);
d1739 1
a1739 2
	if (m)
		m_freem(m);
@


1.140
log
@Remove unused arguments and the associated code from nd6_nud_hint().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.139 2015/06/16 11:09:40 mpi Exp $	*/
d1778 1
@


1.139
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.138 2015/06/08 22:19:28 krw Exp $	*/
d894 1
a894 2
nd6_nud_hint(struct rtentry *rt, struct in6_addr *dst6, int force,
    u_int rtableid)
d898 2
a899 9
	/*
	 * If the caller specified "rt", use that.  Otherwise, resolve the
	 * routing table by supplied "dst6".
	 */
	if (!rt) {
		if (!dst6)
			return;
		if (!(rt = nd6_lookup(dst6, 0, NULL, rtableid)))
			return;
d918 3
a920 5
	if (!force) {
		ln->ln_byhint++;
		if (ln->ln_byhint > nd6_maxnudhint)
			return;
	}
@


1.138
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.137 2015/06/06 09:31:53 mpi Exp $	*/
d433 1
a433 1
				m->m_pkthdr.rcvif = rt->rt_ifp;
@


1.137
log
@Put the link-layer address back into the gateway field of RTF_LOCAL
routes.

Since such routes are also flagged with RTF_LLINFO various code path
assume correctly that they contain valid ARP or ND information.

This fixes the "arpresolve: unresolved and rt_expire == 0" issue
reported on tech@@ by mxb <mxb AT alumni DOT chalmers DOT se>.

ok claudio@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.136 2015/05/15 12:00:57 claudio Exp $	*/
d1319 1
a1319 1
nd6_cache_lladdr(struct ifnet *ifp, struct in6_addr *from, char *lladdr, 
d1492 1
a1492 1
	 *	1	--	n	--	(6) c	c 	c s
@


1.136
log
@Allow multiple connected/interface routes to exist at the same time.
Use the existing multipath code. Switch away from using the ifa address
when making the cloning route and instead put a dummy sockaddr_dl route
in. With this it is possible to use the same network on multiple interfaces
at the same time. So if wireless and ethernet share the same network
the system will use the wired connection as long as there is link.
Still missing is builtin proxy-arp for the other interface IPs to allow
hitless failover.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.135 2015/04/27 14:51:44 mpi Exp $	*/
a653 1
			struct sockaddr_dl sa_dl = { sizeof(sa_dl), AF_LINK };
a668 3
			sa_dl.sdl_type = ifp->if_type;
			sa_dl.sdl_index = ifp->if_index;

d678 2
a679 1
			info.rti_info[RTAX_GATEWAY] = (struct sockaddr *)&sa_dl;
@


1.135
log
@Do not call nd6_purge() before purging the IPv6 addresses of a detached
interface.

Fix a use after free introduced in r1.98 of netinet6/in6.c and recently
exposed by a crazy pool/malloc damage finder being currently refined by
dlg@@ and deraadt@@.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.134 2015/04/17 11:04:02 mikeb Exp $	*/
d654 1
d670 3
d682 1
a682 1
			info.rti_info[RTAX_GATEWAY] = ifa->ifa_addr;
a946 1
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};
a1004 11
			/*
			 * Case 1: This route should come from a route to
			 * interface (RTF_CLONING case) or the route should be
			 * treated as on-link but is currently not
			 * (RTF_LLINFO && !ln case).
			 */
			rt_setgate(rt, (struct sockaddr *)&null_sdl,
			    ifp->if_rdomain);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = ifp->if_type;
			SDL(gate)->sdl_index = ifp->if_index;
d1040 1
a1040 1
		    gate->sa_len < sizeof(null_sdl)) {
a1121 1
			caddr_t macp = nd6_ifptomac(ifp);
a1124 4
			if (macp) {
				memcpy(LLADDR(SDL(gate)), macp, ifp->if_addrlen);
				SDL(gate)->sdl_alen = ifp->if_addrlen;
			}
@


1.134
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.133 2015/03/25 17:39:33 florian Exp $	*/
d593 1
a593 16
		if (pr->ndpr_ifp == ifp) {
			/*
			 * Because if_detach() does *not* release prefixes
			 * while purging addresses the reference count will
			 * still be above zero. We therefore reset it to
			 * make sure that the prefix really gets purged.
			 */
			pr->ndpr_refcnt = 0;
			/*
			 * Previously, pr->ndpr_addr is removed as well,
			 * but I strongly believe we don't have to do it.
			 * nd6_purge() is only called from in6_ifdetach(),
			 * which removes all the associated interface addresses
			 * by itself.
			 * (jinmei@@kame.net 20010129)
			 */
a594 1
		}
@


1.133
log
@With a per interface IPv6 stateless adress auto configuration flag it
is possible to allow IPv6 forwarding and SLAAC at the same time. This
is needed for RFC 7084.
Thanks to henning@@ for marking places that needed looking at in
Ljubljana.
OK phessler@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.132 2015/03/14 17:13:44 mpi Exp $	*/
a1650 3
#ifdef IPSEC
	struct m_tag *mtag;
#endif /* IPSEC */
a1779 15
#ifdef IPSEC
	/*
	 * If we got here and IPsec crypto processing didn't happen, drop it.
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL);
#endif /* IPSEC */

#ifdef IPSEC
	if (mtag != NULL) {
		/* Tell IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		error = EACCES;
		goto bad;
	}
#endif /* IPSEC */
@


1.132
log
@Check for the size of the supposed destination address when constructing
the Ethernet frame.  Prevent an overflow reported by Henk Jan Agteresch
on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.131 2015/02/11 23:34:43 mpi Exp $	*/
d613 1
a613 2
	/* XXX: too restrictive? */
	if (!ip6_forwarding && (ifp->if_xflags & IFXF_AUTOCONF6)) {
a1575 3
	 * XXX: although defrouter_select() should not have a bad effect
	 * for those are not autoconfigured hosts, we explicitly avoid such
	 * cases for safety.
d1577 1
a1577 2
	if (do_update && ln->ln_router && !ip6_forwarding &&
	    (ifp->if_xflags & IFXF_AUTOCONF6))
@


1.131
log
@Do not store the key and the gateway of a route entry in the same chunk
of memory.

The key (destination) is only set once, when the route is inserted in
the routing table, and does not need to change afterward.  The gateway
might change and rt_setgate() will do all the checks for you.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.130 2015/01/27 03:17:36 dlg Exp $	*/
d1871 1
a1871 1
	if (sdl->sdl_alen == 0) {
d1873 1
a1873 2
		/* this should be impossible, but we bark here for debugging */
		printf("nd6_storelladdr: sdl_alen == 0, dst=%s, if=%s\n",
d1875 1
a1875 2
			addr, sizeof(addr)),
		    ifp->if_xname);
@


1.130
log
@remove the second void * argument on tasks.

when workqs were introduced, we provided a second argument so you
could pass a thing and some context to work on it in. there were
very few things that took advantage of the second argument, so when
i introduced pools i suggested removing it. since tasks were meant
to replace workqs, it was requested that we keep the second argument
to make porting from workqs to tasks easier.

now that workqs are gone, i had a look at the use of the second
argument again and found only one good use of it (vdsp(4) on sparc64
if you're interested) and a tiny handful of questionable uses. the
vast majority of tasks only used a single argument. i have since
modified all tasks that used two args to only use one, so now we
can remove the second argument.

so this is a mechanical change. all tasks only passed NULL as their
second argument, so we can just remove it.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.129 2015/01/08 14:29:18 mpi Exp $	*/
d1025 1
a1025 1
			rt_setgate(rt, rt_key(rt), (struct sockaddr *)&null_sdl,
@


1.129
log
@Factorize various duplicated chunks of (old and horrible) code, checking
for the validity of a given outgoing route entry into a single function.

This change is inspired from FreeBSD r111767.  The function introduced
here, rt_checkgate(), should hopefully die in a near future.  Why should
it die?  Well, it is way too late to do such validity checks: if your
kernel can ends up in ether_output() with an invalid route, please do
not let it try to find a new one that might do the job.

Go read this function if you're wondering why you're getting messages
like:

"arpresolve: X.X.X.X: route without link local address"

Since this horrible logic has survived 20 years of copy & past and small
modifications for workarounds without a single clear commit message, let's
assume it is full of dragons and try to play safe.  This factorization is
not intended to change any behavior.

With much inputs from bluhm@@, tested by weerd@@ and florian@@ on setups
with p2p IPv6 interfaces.

ok bluhm@@, benno@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.128 2014/12/22 11:05:53 mpi Exp $	*/
d103 1
a103 1
void nd6_timer_work(void *, void *);
d137 1
a137 1
	task_set(&nd6_timer_task, nd6_timer_work, NULL, NULL);
d496 1
a496 1
nd6_timer_work(void *ignored_arg1, void *ignored_arg2)
@


1.128
log
@Make sure rtrequest1(9) is called under splsoftnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.127 2014/11/20 13:54:24 mpi Exp $	*/
a1653 1
	struct sockaddr_in6 *gw6 = NULL;
d1667 1
a1667 1
	 * next hop determination.  This routine is derived from ether_output.
d1669 6
a1674 11
	if (rt) {
		if ((rt->rt_flags & RTF_UP) == 0) {
			if ((rt0 = rt = rtalloc(sin6tosa(dst),
			    RT_REPORT|RT_RESOLVE,
			    m->m_pkthdr.ph_rtableid)) != NULL)
			{
				rt->rt_refcnt--;
				if (rt->rt_ifp != ifp)
					senderr(EHOSTUNREACH);
			} else
				senderr(EHOSTUNREACH);
d1677 12
a1688 36
		if (rt->rt_flags & RTF_GATEWAY) {
			gw6 = satosin6(rt->rt_gateway);

			/*
			 * We skip link-layer address resolution and NUD
			 * if the gateway is not a neighbor from ND point
			 * of view, regardless of the value of nd_ifinfo.flags.
			 * The second condition is a bit tricky; we skip
			 * if the gateway is our own address, which is
			 * sometimes used to install a route to a p2p link.
			 */
			if (!nd6_is_addr_neighbor(gw6, ifp) ||
			    in6ifa_ifpwithaddr(ifp, &gw6->sin6_addr)) {
				/*
				 * We allow this kind of tricky route only
				 * when the outgoing interface is p2p.
				 * XXX: we may need a more generic rule here.
				 */
				if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
					senderr(EHOSTUNREACH);

				goto sendpkt;
			}

			if (rt->rt_gwroute == 0)
				goto lookup;
			if (((rt = rt->rt_gwroute)->rt_flags & RTF_UP) == 0) {
				rtfree(rt); rt = rt0;
			lookup:
				rt->rt_gwroute = rtalloc(rt->rt_gateway,
				    RT_REPORT|RT_RESOLVE,
				    m->m_pkthdr.ph_rtableid);
				if ((rt = rt->rt_gwroute) == 0)
					senderr(EHOSTUNREACH);
			}
		}
d1833 1
a1833 1
nd6_storelladdr(struct ifnet *ifp, struct rtentry *rt, struct mbuf *m, 
d1837 2
d1845 1
a1845 1
			return (1);
d1849 1
a1849 1
			return (0);
d1853 1
a1853 1
	if (rt == NULL) {
d1856 7
a1862 1
		return (0);
d1864 1
d1868 1
a1868 1
		return (0);
d1879 1
a1879 1
		return (0);
d1883 1
a1883 1
	return (1);
@


1.127
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.126 2014/11/20 09:55:57 mpi Exp $	*/
d806 1
d813 1
a814 2
		int s;
		s = splsoftnet();
a878 1
		splx(s);
d899 1
@


1.126
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.125 2014/11/18 02:37:31 tedu Exp $	*/
d1488 1
a1488 2
				nd6_output(ifp, ifp, n,
				    satosin6(rt_key(rt)), rt);
d1649 2
a1650 2
nd6_output(struct ifnet *ifp, struct ifnet *origifp, struct mbuf *m0, 
    struct sockaddr_in6 *dst, struct rtentry *rt0)
a1824 11
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
#ifdef IPSEC
		if (mtag != NULL) {
			/* Tell IPsec to do its own crypto. */
			ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
			error = EACCES;
			goto bad;
		}
#endif /* IPSEC */
		return ((*ifp->if_output)(origifp, m, sin6tosa(dst), rt));
	}
@


1.125
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.124 2014/11/01 21:40:39 mpi Exp $	*/
a201 3

	if (ndi->maxmtu > in6_maxmtu)
		in6_setmaxmtu(); /* check all interfaces just in case */
@


1.124
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.123 2014/10/14 09:52:26 mpi Exp $	*/
a47 1
#include <dev/rndvar.h>
@


1.123
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.122 2014/08/25 14:00:34 florian Exp $	*/
d652 1
d658 1
d660 1
a660 1
	rt = rtalloc1(sin6tosa(&sin6), create, rtableid);
d1395 1
a1395 1
		rt = nd6_lookup(from, RT_REPORT, ifp, ifp->if_rdomain);
d1677 3
a1679 2
			if ((rt0 = rt = rtalloc1(sin6tosa(dst),
			    RT_REPORT, m->m_pkthdr.ph_rtableid)) != NULL)
d1717 3
a1719 2
				rt->rt_gwroute = rtalloc1(rt->rt_gateway,
				    RT_REPORT, m->m_pkthdr.ph_rtableid);
d1743 1
a1743 1
		    (rt = nd6_lookup(&dst->sin6_addr, RT_REPORT, ifp,
@


1.122
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.121 2014/08/11 13:51:07 mpi Exp $	*/
d667 2
a668 2
			RTFREE(rt);
			rt = 0;
@


1.121
log
@Use the RTF_LOCAL flag instead of abusing the RTF_LLINFO flag when
adding local route entries.

This hack made sense when we didn't have the RTF_LOCAL flag, but since
some months it is set on every local route.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.120 2014/07/12 18:44:23 tedu Exp $	*/
d106 5
d145 2
d1615 33
@


1.120
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.119 2014/07/11 16:39:06 henning Exp $	*/
d1013 1
a1013 1
		    ((rt->rt_flags & RTF_LLINFO) && !ln)) {
@


1.119
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.116 2014/05/07 08:14:59 mpi Exp $	*/
d168 1
a168 1
	free(nd, M_IP6NDP);
d1229 1
a1229 1
		free(ln, M_RTABLE);
d1923 1
a1923 1
		free(p, M_TEMP);
@


1.118
log
@g/c unused IFT_L2VLAN, ok reyk bluhm
the #define stays since it's userland visible and who knows what uses it
@
text
@d155 1
a155 5
	/*
	 * Note that the default value of ip6_accept_rtadv is 0, which means
	 * we won't accept RAs by default even if we set ND6_IFF_ACCEPT_RTADV
	 * here.
	 */
d610 2
a611 1
	if (!ip6_forwarding && ip6_accept_rtadv) { /* XXX: too restrictive? */
d1577 2
a1578 1
	if (do_update && ln->ln_router && !ip6_forwarding && ip6_accept_rtadv)
@


1.117
log
@Do not use nd6_rtrequest() for addresses configured on loopback
interfaces.

ok mikeb@@
@
text
@a1826 1
	case IFT_L2VLAN:
@


1.116
log
@Kill the {nd6_,}useloopback buttons, using the loopback interface for
local traffic is not optional.

ok mikeb@@, stsp@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.115 2014/05/05 11:44:33 mpi Exp $	*/
d1062 5
a1066 13
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) == 0) {
			/*
			 * Address resolution isn't necessary for a point to
			 * point link, so we can skip this test for a p2p link.
			 */
			if (gate->sa_family != AF_LINK ||
			    gate->sa_len < sizeof(null_sdl)) {
				log(LOG_DEBUG, "%s: bad gateway value: %s\n",
				    __func__, ifp->if_xname);
				break;
			}
			SDL(gate)->sdl_type = ifp->if_type;
			SDL(gate)->sdl_index = ifp->if_index;
d1068 2
@


1.115
log
@Use a custom ifa_rtrequest function for point-to-point interfaces
instead of relying on hacks in nd6_rtrequest() to add a route to
loopback for each address configured on such interfaces.

While here document that abusing lo0 for local traffic is not safe
for interfaces in a non-default rdomain.

Tested by claudio@@, jca@@ and sthen@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.114 2014/04/14 09:06:42 mpi Exp $	*/
a74 1
int	nd6_useloopback = 1;	/* use loopback interface for local traffic */
d1165 14
a1178 15
			if (nd6_useloopback) {
				rt->rt_ifp = lo0ifp;
				/*
				 * Make sure rt_ifa be equal to the ifaddr
				 * corresponding to the address.
				 * We need this because when we refer
				 * rt_ifa->ia6_flags in ip6_input, we assume
				 * that the rt_ifa points to the address instead
				 * of the loopback address.
				 */
				if (ifa != rt->rt_ifa) {
					ifafree(rt->rt_ifa);
					ifa->ifa_refcnt++;
					rt->rt_ifa = ifa;
				}
@


1.114
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.113 2014/03/27 10:39:23 mpi Exp $	*/
d1160 6
d1167 1
a1167 1
				rt->rt_ifp = lo0ifp;	/*XXX*/
@


1.113
log
@Stop mixing interface address flags with routing entry ones.

Instead of always copying ifa_flags to the routing entry flags when
creating a route by calling rtinit(), explicitly pass the RTF_CLONING
flag when required.  This means ifa_flags are now *only* used to check
if an address has an associated route that was created by the kernel
auto-magically.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.112 2014/03/11 10:31:29 mpi Exp $	*/
d1640 1
a1640 1
			    RT_REPORT, m->m_pkthdr.rdomain)) != NULL)
d1679 1
a1679 1
				    RT_REPORT, m->m_pkthdr.rdomain);
@


1.112
log
@Remove gratuitous differences between arp and nd6 rtrequests,
no functional change.

ok jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.111 2014/02/17 21:36:05 kettenis Exp $	*/
d692 1
a692 2
			info.rti_flags = (ifa->ifa_flags | RTF_HOST |
			    RTF_LLINFO) & ~RTF_CLONING;
@


1.111
log
@The device driver ioctl code can sleep, so calling it from a timeout is *not*
a good idea.  Instead hand the work off expiring interface addresses off
to a taskq.  Fixes the "p->p_wchan == NULL" panics seen with usb ethernet
adapters.

tested by matthieu@@
ok mpi@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.110 2014/01/22 13:19:12 mpi Exp $	*/
d974 1
a974 1
	
d1025 2
a1026 3
			rt_setgate(rt, rt_key(rt),
			    (struct sockaddr *)&null_sdl,
			    rt->rt_ifp->if_rdomain);
d1071 2
a1072 3
				log(LOG_DEBUG,
				    "nd6_rtrequest: bad gateway value: %s\n",
				    ifp->if_xname);
d1087 1
a1087 1
			log(LOG_DEBUG, "nd6_rtrequest: malloc failed\n");
d1150 1
a1150 1
		ifa = &in6ifa_ifpwithaddr(rt->rt_ifp,
@


1.110
log
@There's no reason to pass a netmask argument when doing a RTF_HOST
request, so kill it along with the associated global variable.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.109 2014/01/13 23:03:52 bluhm Exp $	*/
d47 1
d104 2
d134 2
d498 1
a498 1
nd6_timer(void *ignored_arg)
d553 6
@


1.109
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.108 2014/01/10 14:29:08 tedu Exp $	*/
a94 1
static struct sockaddr_in6 all1_sa;
a121 1
	int i;
a127 5
	all1_sa.sin6_family = AF_INET6;
	all1_sa.sin6_len = sizeof(struct sockaddr_in6);
	for (i = 0; i < sizeof(all1_sa.sin6_addr); i++)
		all1_sa.sin6_addr.s6_addr[i] = 0xff;

a684 1
			info.rti_info[RTAX_NETMASK] = sin6tosa(&all1_sa);
@


1.108
log
@replace the rest of the obsolete radix macros
sprinkle 0 -> NULL where obvious
ok millert mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.107 2014/01/09 21:57:52 tedu Exp $	*/
d1267 1
a1267 1
			struct in6_ifaddr *ia, *ia_next;
d1273 2
a1274 2
			TAILQ_FOREACH_SAFE(ia, &in6_ifaddr, ia_list, ia_next) {
				if ((ia->ia6_flags & IN6_IFF_AUTOCONF) == 0)
d1277 2
a1278 2
				if (ia->ia6_ndpr == pr)
					in6_purgeaddr(&ia->ia_ifa);
@


1.107
log
@replace Bcopy macro with memmove and memcpy. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.106 2014/01/07 17:07:46 mikeb Exp $	*/
d1083 1
a1083 1
		R_Malloc(ln, struct llinfo_nd6 *, sizeof(*ln));
a1090 1
		Bzero(ln, sizeof(*ln));
d1234 1
a1234 1
		Free((caddr_t)ln);
@


1.106
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.105 2013/11/11 09:15:35 mpi Exp $	*/
d1158 1
a1158 1
				Bcopy(macp, LLADDR(SDL(gate)), ifp->if_addrlen);
@


1.105
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.104 2013/10/28 12:33:32 mpi Exp $	*/
d640 2
a641 1
nd6_lookup(struct in6_addr *addr6, int create, struct ifnet *ifp)
d651 1
a651 1
	rt = rtalloc1(sin6tosa(&sin6), create, ifp->if_rdomain);
d694 1
a694 1
			    &rt, ifp->if_rdomain)) != 0) {
d783 2
a784 1
	if ((rt = nd6_lookup(&addr->sin6_addr, 0, ifp)) != NULL)
d907 2
a908 1
nd6_nud_hint(struct rtentry *rt, struct in6_addr *dst6, int force)
d919 1
a919 1
		if (!(rt = nd6_lookup(dst6, 0, NULL)))
d1327 1
a1327 1
		if ((rt = nd6_lookup(&nb_addr, 0, ifp)) == NULL ||
d1384 1
a1384 1
	rt = nd6_lookup(from, 0, ifp);
d1392 1
a1392 1
		rt = nd6_lookup(from, RT_REPORT, ifp);
d1704 2
a1705 1
		    (rt = nd6_lookup(&dst->sin6_addr, RT_REPORT, ifp)) != NULL)
@


1.104
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.103 2013/10/20 11:03:02 phessler Exp $	*/
d695 1
d699 2
a700 1
				    ip6_sprintf(addr6), e);
d731 1
d734 1
a734 1
			    ip6_sprintf(addr6),
d1192 1
d1195 3
a1197 1
					    ip6_sprintf(&llsol), error));
d1435 1
d1437 2
a1438 1
		    ip6_sprintf(from), ether_sprintf(lladdr), ifp->if_xname);
d1707 2
d1712 3
a1714 1
			    ip6_sprintf(&dst->sin6_addr), ln, rt);
d1867 1
d1870 3
a1872 1
		    ip6_sprintf(&satosin6(dst)->sin6_addr), ifp->if_xname);
d2000 1
d2012 2
a2013 1
				    ip6_sprintf(&p->prefix.sin6_addr));
@


1.103
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.102 2013/08/28 06:58:57 mpi Exp $	*/
a51 1
#include <net/if_fddi.h>
d190 1
a190 5

	if (ifp->if_type == IFT_FDDI)
		ndi->maxmtu = MIN(FDDIMTU, ifp->if_mtu);
	else
		ndi->maxmtu = ifp->if_mtu;
a1806 3
	 * XXX: we currently do not make neighbor cache on any interface
	 * other than Ethernet, FDDI and GIF.
	 *
a1811 1
	case IFT_FDDI:
a1832 1
		case IFT_FDDI:
@


1.102
log
@Remove unused argument from *rtrequest()

ok krw@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.101 2013/08/26 07:15:58 bluhm Exp $	*/
a950 4
/*
 * info - XXX: unused
 */

d1022 2
a1023 1
				   (struct sockaddr *)&null_sdl, 0);
@


1.101
log
@No one uses the obsolete IPv6 ioctls SIOCGDRLST_IN6, SIOCGPRLST_IN6,
OSIOCGIFINFO_IN6 anymore.  Remove them together with the structs
in6_drlist, in6_oprlist, in6_prlist, in6_ondireq and the kernel
implementation.
OK mikeb@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.100 2013/08/13 05:52:25 guenther Exp $	*/
d956 1
a956 1
nd6_rtrequest(int req, struct rtentry *rt, struct rt_addrinfo *info)
@


1.100
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.99 2013/05/31 15:04:24 bluhm Exp $	*/
a1240 2
	struct in6_drlist *drl = (struct in6_drlist *)data;
	struct in6_oprlist *oprl = (struct in6_oprlist *)data;
a1242 2
	struct nd_defrouter *dr;
	struct nd_prefix *pr;
d1244 1
a1244 1
	int i = 0, error = 0;
a1247 94
	case SIOCGDRLST_IN6:
		/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 */
		bzero(drl, sizeof(*drl));
		s = splsoftnet();
		TAILQ_FOREACH(dr, &nd_defrouter, dr_entry) {
			if (i >= DRLSTSIZ)
				break;
			drl->defrouter[i].rtaddr = dr->rtaddr;
			if (IN6_IS_ADDR_LINKLOCAL(&drl->defrouter[i].rtaddr)) {
				/* XXX: need to this hack for KAME stack */
				drl->defrouter[i].rtaddr.s6_addr16[1] = 0;
			} else
				log(LOG_ERR,
				    "default router list contains a "
				    "non-linklocal address(%s)\n",
				    ip6_sprintf(&drl->defrouter[i].rtaddr));

			drl->defrouter[i].flags = dr->flags;
			drl->defrouter[i].rtlifetime = dr->rtlifetime;
			drl->defrouter[i].expire = dr->expire;
			drl->defrouter[i].if_index = dr->ifp->if_index;
			i++;
		}
		splx(s);
		break;
	case SIOCGPRLST_IN6:
		/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 *
		 * XXX the structure in6_prlist was changed in backward-
		 * incompatible manner.  in6_oprlist is used for SIOCGPRLST_IN6,
		 * in6_prlist is used for nd6_sysctl() - fill_prlist().
		 */
		/*
		 * XXX meaning of fields, especially "raflags", is very
		 * different between RA prefix list and RR/static prefix list.
		 * how about separating ioctls into two?
		 */
		bzero(oprl, sizeof(*oprl));
		s = splsoftnet();
		LIST_FOREACH(pr, &nd_prefix, ndpr_entry) {
			struct nd_pfxrouter *pfr;
			int j;

			if (i >= PRLSTSIZ)
				break;
			oprl->prefix[i].prefix = pr->ndpr_prefix.sin6_addr;
			oprl->prefix[i].raflags = pr->ndpr_raf;
			oprl->prefix[i].prefixlen = pr->ndpr_plen;
			oprl->prefix[i].vltime = pr->ndpr_vltime;
			oprl->prefix[i].pltime = pr->ndpr_pltime;
			oprl->prefix[i].if_index = pr->ndpr_ifp->if_index;
			oprl->prefix[i].expire = pr->ndpr_expire;

			j = 0;
			LIST_FOREACH(pfr, &pr->ndpr_advrtrs, pfr_entry) {
				if (j < DRLSTSIZ) {
#define RTRADDR oprl->prefix[i].advrtr[j]
					RTRADDR = pfr->router->rtaddr;
					if (IN6_IS_ADDR_LINKLOCAL(&RTRADDR)) {
						/* XXX: hack for KAME */
						RTRADDR.s6_addr16[1] = 0;
					} else
						log(LOG_ERR,
						    "a router(%s) advertises "
						    "a prefix with "
						    "non-link local address\n",
						    ip6_sprintf(&RTRADDR));
#undef RTRADDR
				}
				j++;
			}
			oprl->prefix[i].advrtrs = j;
			oprl->prefix[i].origin = PR_ORIG_RA;

			i++;
		}
		splx(s);

		break;
	case OSIOCGIFINFO_IN6:
		/* XXX: old ndp(8) assumes a positive value for linkmtu. */
		bzero(&ndi->ndi, sizeof(ndi->ndi));
		ndi->ndi.linkmtu = IN6_LINKMTU(ifp);
		ndi->ndi.maxmtu = ND_IFINFO(ifp)->maxmtu;
		ndi->ndi.basereachable = ND_IFINFO(ifp)->basereachable;
		ndi->ndi.reachable = ND_IFINFO(ifp)->reachable;
		ndi->ndi.retrans = ND_IFINFO(ifp)->retrans;
		ndi->ndi.flags = ND_IFINFO(ifp)->flags;
		ndi->ndi.recalctm = ND_IFINFO(ifp)->recalctm;
		ndi->ndi.chlim = ND_IFINFO(ifp)->chlim;
		break;
@


1.99
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.98 2013/04/10 08:50:59 mpi Exp $	*/
d2119 2
a2120 2
				maxexpire = (-1) &
					~(1 << ((sizeof(maxexpire) * 8) - 1));
@


1.98
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.97 2013/03/25 14:40:57 mpi Exp $	*/
a67 1
#define SIN6(s) ((struct sockaddr_in6 *)s)
d416 1
a416 1
	dst = (struct sockaddr_in6 *)rt_key(rt);
d655 1
a655 1
	rt = rtalloc1((struct sockaddr *)&sin6, create, ifp->if_rdomain);
d681 1
a681 1
			    ifaof_ifpforaddr((struct sockaddr *)&sin6, ifp);
d694 1
a694 1
			info.rti_info[RTAX_DST] = (struct sockaddr *)&sin6;
d696 1
a696 2
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&all1_sa;
d801 1
a801 1
	struct in6_addr in6 = ((struct sockaddr_in6 *)rt_key(rt))->sin6_addr;
d812 1
a812 1
		dr = defrouter_lookup(&((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
d970 1
a970 1
		dr = defrouter_lookup(&SIN6(gate)->sin6_addr, ifp);
d1057 2
a1058 2
			      &SIN6(rt_key(rt))->sin6_addr,
			      &SIN6(rt_key(rt))->sin6_addr,
d1153 1
a1153 1
		    &SIN6(rt_key(rt))->sin6_addr)->ia_ifa;
d1189 1
a1189 1
				llsol = SIN6(rt_key(rt))->sin6_addr;
d1214 1
a1214 1
			llsol = SIN6(rt_key(rt))->sin6_addr;
d1585 1
a1585 1
				    (struct sockaddr_in6 *)rt_key(rt), rt);
d1735 1
a1735 1
			if ((rt0 = rt = rtalloc1((struct sockaddr *)dst,
d1746 1
a1746 1
			gw6 = (struct sockaddr_in6 *)rt->rt_gateway;
d1890 1
a1890 2
		return ((*ifp->if_output)(origifp, m, (struct sockaddr *)dst,
		    rt));
d1900 1
a1900 1
	return ((*ifp->if_output)(ifp, m, (struct sockaddr *)dst, rt));
d1944 1
a1944 1
			ETHER_MAP_IPV6_MULTICAST(&SIN6(dst)->sin6_addr,
d1968 1
a1968 1
		    ip6_sprintf(&SIN6(dst)->sin6_addr), ifp->if_xname);
@


1.97
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.96 2013/03/22 00:59:25 bluhm Exp $	*/
a105 1
extern struct timeout in6_tmpaddrtimer_ch;
@


1.96
log
@Replace hand-crafted nd_prefix loops with LIST_FOREACH macros.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.95 2013/03/11 14:08:04 mpi Exp $	*/
d529 1
a529 2
	for (ia6 = in6_ifaddr; ia6; ia6 = nia6) {
		nia6 = ia6->ia_next;
d1374 1
a1374 4
			for (ia = in6_ifaddr; ia; ia = ia_next) {
				/* ia might be removed.  keep the next ptr. */
				ia_next = ia->ia_next;

@


1.95
log
@Remove unused code manipulating a default interface and its index,
This is a leftover from the on-link assumption behavior removal,
which has been deprecated by RFC4861 anyway.

ok mikeb@@, bluhm@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.94 2013/03/07 09:03:16 mpi Exp $	*/
d511 1
a511 1
	struct nd_prefix *pr;
d546 1
a546 2
	pr = LIST_FIRST(&nd_prefix);
	while (pr != NULL) {
a553 3
			struct nd_prefix *t;
			t = LIST_NEXT(pr, ndpr_entry);

d560 1
a560 3
			pr = t;
		} else
			pr = LIST_NEXT(pr, ndpr_entry);
d598 1
a598 2
	for (pr = LIST_FIRST(&nd_prefix); pr != NULL; pr = npr) {
		npr = LIST_NEXT(pr, ndpr_entry);
d1298 1
a1298 2
		pr = LIST_FIRST(&nd_prefix);
		while (pr && i < PRLSTSIZ) {
d1302 2
a1311 1
			pfr = LIST_FIRST(&pr->ndpr_advrtrs);
d1313 1
a1313 1
			while(pfr) {
a1328 1
				pfr = LIST_NEXT(pfr, pfr_entry);
a1333 1
			pr = LIST_NEXT(pr, ndpr_entry);
d1364 1
a1364 1
		struct nd_prefix *pr, *next;
d1368 1
a1368 1
		for (pr = LIST_FIRST(&nd_prefix); pr; pr = next) {
a1370 2
			next = LIST_NEXT(pr, ndpr_entry);

d1391 1
a1391 3
		for (pr = LIST_FIRST(&nd_prefix); pr; pr = next) {
			next = LIST_NEXT(pr, ndpr_entry);

@


1.94
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.93 2013/01/15 10:15:19 bluhm Exp $	*/
a625 4
	/* cancel default outgoing interface setting */
	if (nd6_defifindex == ifp->if_index)
		nd6_setdefaultiface(0);

a791 11
	 * If the default router list is empty, all addresses are regarded
	 * as on-link, and thus, as a neighbor.
	 * XXX: we restrict the condition to hosts, because routers usually do
	 * not have the "default router list".
	 */
	if (!ip6_forwarding && TAILQ_EMPTY(&nd_defrouter) &&
	    nd6_defifindex == ifp->if_index) {
		return (1);
	}

	/*
a1255 1
	struct in6_ndifreq *ndif = (struct in6_ndifreq *)data;
a1457 6
	case SIOCGDEFIFACE_IN6:	/* XXX: should be implemented as a sysctl? */
		ndif->ifindex = nd6_defifindex;
		break;
	case SIOCSDEFIFACE_IN6:	/* XXX: should be implemented as a sysctl? */
		return (nd6_setdefaultiface(ndif->ifindex));
		break;
@


1.93
log
@Flushing prefixes of autoconfigured IPv6 addresses with ndp -P
caused an uvm fault.  The function in6_purgeaddr() might already
free the prefix before prelist_remove() is called.  So call
in6_purgeaddr() for all addresses first and then loop over the
remaining prefixes and call prelist_remove().
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.92 2012/09/19 09:47:25 bluhm Exp $	*/
d1200 1
a1200 1
					IFAFREE(rt->rt_ifa);
@


1.92
log
@Use TAILQ_FOREACH macro for loops.  No binary diff.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.91 2012/01/03 23:41:51 bluhm Exp $	*/
d1392 1
d1412 12
@


1.91
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.90 2011/12/27 17:20:04 bluhm Exp $	*/
d1722 1
a1722 2
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
@


1.90
log
@Instead of hand crafted code, use the macros TAILQ_FOREACH(_SAFE)
and TAILQ_EMPTY for accessing the nd_defrouter list.  No funtional
change.
ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.89 2011/12/02 03:15:31 haesbaert Exp $	*/
d1178 2
a1179 2
		ifa = (struct ifaddr *)in6ifa_ifpwithaddr(rt->rt_ifp,
		    &SIN6(rt_key(rt))->sin6_addr);
@


1.89
log
@Kill unused IFCAP_IPSEC and IFCAP_IPCOMP.

ok claudio@@ henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.88 2011/11/24 17:39:55 sperreault Exp $	*/
d510 1
a510 1
	struct nd_defrouter *dr;
d519 2
a520 5
	dr = TAILQ_FIRST(&nd_defrouter);
	while (dr) {
		if (dr->expire && dr->expire < time_second) {
			struct nd_defrouter *t;
			t = TAILQ_NEXT(dr, dr_entry);
a521 5
			dr = t;
		} else {
			dr = TAILQ_NEXT(dr, dr_entry);
		}
	}
d588 1
a588 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
d595 1
a595 2
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
d801 1
a801 1
	if (!ip6_forwarding && TAILQ_FIRST(&nd_defrouter) == NULL &&
d1285 3
a1287 2
		dr = TAILQ_FIRST(&nd_defrouter);
		while (dr && i < DRLSTSIZ) {
a1302 1
			dr = TAILQ_NEXT(dr, dr_entry);
d1419 1
a1419 1
		struct nd_defrouter *dr, *next;
d1423 1
a1423 2
		for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = next) {
			next = TAILQ_NEXT(dr, dr_entry);
a1424 1
		}
d2073 1
a2073 3
	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {

@


1.88
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.87 2011/06/17 07:06:47 mk Exp $	*/
d1918 1
a1918 2
	 * If the packet needs outgoing IPsec crypto processing and the
	 * interface doesn't support it, drop it.
d1925 1
a1925 2
		if (mtag != NULL &&
		    (origifp->if_capabilities & IFCAP_IPSEC) == 0) {
d1936 1
a1936 2
	if (mtag != NULL &&
	    (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
@


1.87
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.86 2011/03/09 23:31:24 bluhm Exp $	*/
d679 1
a679 1
	rt = rtalloc1((struct sockaddr *)&sin6, create, 0);
d723 1
a723 1
			    &rt, 0)) != 0) {
d931 2
a932 1
	rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
d1778 1
a1778 1
			    RT_REPORT, 0)) != NULL)
d1817 1
a1817 1
				    RT_REPORT, 0);
@


1.86
log
@Log MAC address changes in the IPv6 neighbor discovery protocol
cache as "ndp info overwritten".  This makes the behavior similar
to ARP.
ok todd@@, deraadt@@, henning@@, giovanni@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.85 2010/06/28 16:48:15 bluhm Exp $	*/
d2043 1
a2043 1
		p = malloc(*oldlenp, M_TEMP, M_WAITOK);
@


1.85
log
@Allow neighbor discovery for prefixes on interfaces without matching
address.  This is necessary when ospf6d has learned a prefix for a
directly connected link which is not configured localy.  Now neighbor
discovery is solely based on the cloning route and not on the address
neigborship anymore.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.84 2010/05/07 13:33:17 claudio Exp $	*/
d1574 4
@


1.84
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.83 2010/02/08 11:56:09 jsing Exp $	*/
d1024 1
a1024 3
	if (req == RTM_RESOLVE &&
	    (nd6_need_cache(ifp) == 0 || /* stf case */
	     !nd6_is_addr_neighbor((struct sockaddr_in6 *)rt_key(rt), ifp))) {
d1026 9
a1034 9
		 * FreeBSD and BSD/OS often make a cloned host route based
		 * on a less-specific route (e.g. the default route).
		 * If the less specific route does not have a "gateway"
		 * (this is the case when the route just goes to a p2p or an
		 * stf interface), we'll mistakenly make a neighbor cache for
		 * the host route, and will see strange neighbor solicitation
		 * for the corresponding destination.  In order to avoid the
		 * confusion, we check if the destination of the route is
		 * a neighbor in terms of neighbor discovery, and stop the
@


1.83
log
@Destatic and ansify.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.81 2008/10/15 19:12:18 blambert Exp $	*/
d1531 1
a1531 1
		rt = nd6_lookup(from, 1, ifp);
d1775 1
a1775 1
			    1, 0)) != NULL)
d1813 2
a1814 1
				rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1, 0);
d1838 1
a1838 1
		    (rt = nd6_lookup(&dst->sin6_addr, 1, ifp)) != NULL)
@


1.82
log
@Mark routers internal as uninstalled after deleting the default route.
This makes it possible to get a new default route by router advertisement
after the old one got deleted (or timed out).

Ok henning@@, claudio@@, mcbride@@
@
text
@d99 4
a102 4
static void nd6_setmtu0(struct ifnet *, struct nd_ifinfo *);
static void nd6_slowtimo(void *);
static struct llinfo_nd6 *nd6_free(struct rtentry *, int);
static void nd6_llinfo_timer(void *);
d108 2
a109 2
static int fill_drlist(void *, size_t *, size_t);
static int fill_prlist(void *, size_t *, size_t);
d123 1
a123 1
nd6_init()
d387 1
a387 1
static void
d832 1
a832 1
static struct llinfo_nd6 *
d1493 1
a1493 1
	int lladdrlen, int type, int code)
d1722 1
a1722 1
static void
d1752 1
a1752 1
	struct sockaddr_in6 *dst, struct rtentry *rt0)
d1978 1
a1978 1
	struct sockaddr *dst, u_char *desten)
d2025 1
a2025 2
nd6_sysctl(int name, void *oldp, size_t *oldlenp, void *newp, 
	size_t newlen)
d2068 1
a2068 1
static int
d2117 1
a2117 1
static int
@


1.81
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.80 2008/09/17 05:43:14 chl Exp $	*/
d998 1
d1000 10
@


1.80
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.79 2008/06/11 19:00:50 mcbride Exp $	*/
d145 1
a145 1
	timeout_add(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL * hz);
d516 1
a516 1
	timeout_add(&nd6_timer_ch, nd6_prune * hz);
d1719 1
a1719 1
	timeout_add(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL * hz);
@


1.79
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.78 2008/06/11 06:30:36 mcbride Exp $	*/
a512 1
	struct in6_addrlifetime *lt6;
a539 1
		lt6 = &ia6->ia6_lifetime;
a997 1
	int mine = 0;
a1184 1
			mine = 1;
d2018 1
a2018 1
	size_t ol, l;
a2021 1
	l = 0;
@


1.78
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.77 2008/05/11 08:13:02 claudio Exp $	*/
d149 1
a149 2
nd6_ifattach(ifp)
	struct ifnet *ifp;
d175 1
a175 2
nd6_ifdetach(nd)
	struct nd_ifinfo *nd;
d182 1
a182 2
nd6_setmtu(ifp)
	struct ifnet *ifp;
d188 1
a188 3
nd6_setmtu0(ifp, ndi)
	struct ifnet *ifp;
	struct nd_ifinfo *ndi;
d216 1
a216 4
nd6_option_init(opt, icmp6len, ndopts)
	void *opt;
	int icmp6len;
	union nd_opts *ndopts;
a217 1

d233 1
a233 2
nd6_option(ndopts)
	union nd_opts *ndopts;
d284 1
a284 2
nd6_options(ndopts)
	union nd_opts *ndopts;
d507 1
a507 2
nd6_timer(ignored_arg)
	void	*ignored_arg;
d586 1
a586 2
nd6_purge(ifp)
	struct ifnet *ifp;
d671 1
a671 4
nd6_lookup(addr6, create, ifp)
	struct in6_addr *addr6;
	int create;
	struct ifnet *ifp;
d776 1
a776 3
nd6_is_addr_neighbor(addr, ifp)
	struct sockaddr_in6 *addr;
	struct ifnet *ifp;
d835 1
a835 3
nd6_free(rt, gc)
	struct rtentry *rt;
	int gc;
d944 1
a944 4
nd6_nud_hint(rt, dst6, force)
	struct rtentry *rt;
	struct in6_addr *dst6;
	int force;
d988 4
d993 1
a993 4
nd6_rtrequest(req, rt, info)
	int	req;
	struct rtentry *rt;
	struct rt_addrinfo *info; /* xxx unused */
d1269 1
a1269 4
nd6_ioctl(cmd, data, ifp)
	u_long cmd;
	caddr_t	data;
	struct ifnet *ifp;
d1480 3
d1485 2
a1486 7
nd6_cache_lladdr(ifp, from, lladdr, lladdrlen, type, code)
	struct ifnet *ifp;
	struct in6_addr *from;
	char *lladdr;
	int lladdrlen;
	int type;	/* ICMP6 type */
	int code;	/* type dependent information */
d1716 1
a1716 2
nd6_slowtimo(ignored_arg)
    void *ignored_arg;
d1744 2
a1745 6
nd6_output(ifp, origifp, m0, dst, rt0)
	struct ifnet *ifp;
	struct ifnet *origifp;
	struct mbuf *m0;
	struct sockaddr_in6 *dst;
	struct rtentry *rt0;
d1945 1
a1945 2
nd6_need_cache(ifp)
	struct ifnet *ifp;
d1970 2
a1971 6
nd6_storelladdr(ifp, rt, m, dst, desten)
	struct ifnet *ifp;
	struct rtentry *rt;
	struct mbuf *m;
	struct sockaddr *dst;
	u_char *desten;
d2012 5
d2018 2
a2019 6
nd6_sysctl(name, oldp, oldlenp, newp, newlen)
	int name;
	void *oldp;	/* syscall arg, need copyout */
	size_t *oldlenp;
	void *newp;	/* syscall arg, need copyin */
	size_t newlen;
d2064 1
a2064 3
fill_drlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
d2113 1
a2113 3
fill_prlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
@


1.77
log
@rtrequest to rtrequest1 conversion in inet6. With that no rtrequest should
be left over. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.76 2008/05/11 03:50:23 krw Exp $	*/
a89 1
/* for debugging? */
d111 11
d477 1
d1171 29
d1877 8
@


1.76
log
@Try harder to avoid corrupting the mbuf pool. Stuff any mbuf chain in
ln_hold or la_hold into temporary storage and null ln_hold or
la_hold before manually processing the mbuf chain. Discard the mbuf chain
if it is put back in the hold area.

ok claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.75 2007/10/01 16:39:30 krw Exp $	*/
d701 1
d720 1
a720 1
			 * called in rtrequest via ifa->ifa_rtrequest.
d722 9
a730 4
			if ((e = rtrequest(RTM_ADD, (struct sockaddr *)&sin6,
			    ifa->ifa_addr, (struct sockaddr *)&all1_sa,
			    (ifa->ifa_flags | RTF_HOST | RTF_LLINFO) &
			    ~RTF_CLONING, &rt, 0)) != 0) {
d846 1
d939 4
a942 2
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0,
	    rt_mask(rt), 0, (struct rtentry **)0, 0);
@


1.75
log
@Last of the really easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'
where obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.74 2007/06/08 09:31:38 henning Exp $	*/
d449 5
d1587 2
d1593 1
a1593 1
				nd6_output(ifp, ifp, ln->ln_hold,
d1595 5
a1599 1
				ln->ln_hold = NULL;
@


1.74
log
@kill arcnet leftovers, some pt out by Mike Belopuhov <mkb@@crypt.org.ru>,
some I found afterwards, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.73 2007/05/28 22:17:21 pyr Exp $	*/
d144 1
a144 2
	nd = (struct nd_ifinfo *)malloc(sizeof(*nd), M_IP6NDP, M_WAITOK);
	bzero(nd, sizeof(*nd));
@


1.73
log
@avoid bypassing sys/queue.h in many places in the kernel.
many assumptions were made about the way the various list types are
implemented.

lots of suggestions and help from otto and miod.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.72 2006/06/16 16:49:40 henning Exp $	*/
d190 1
a190 5
	switch (ifp->if_type) {
	case IFT_ARCNET:
		ndi->maxmtu = MIN(60480, ifp->if_mtu); /* RFC2497 */
		break;
	case IFT_FDDI:
d192 1
a192 2
		break;
	default:
a193 2
		break;
	}
d1915 1
a1915 1
	 * other than ARCnet, Ethernet, FDDI and GIF.
a1920 1
	case IFT_ARCNET:
a1952 3
		case IFT_ARCNET:
			*desten = 0;
			return (1);
@


1.72
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.71 2006/06/16 15:41:19 pascoe Exp $	*/
d560 2
a561 2
	pr = nd_prefix.lh_first;
	while (pr) {
d570 1
a570 1
			t = pr->ndpr_next;
d580 1
a580 1
			pr = pr->ndpr_next;
d621 2
a622 2
	for (pr = nd_prefix.lh_first; pr; pr = npr) {
		npr = pr->ndpr_next;
d799 1
a799 1
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d1304 1
a1304 1
		pr = nd_prefix.lh_first;
d1317 1
a1317 1
			pfr = pr->ndpr_advrtrs.lh_first;
d1335 1
a1335 1
				pfr = pfr->pfr_next;
d1341 1
a1341 1
			pr = pr->ndpr_next;
d1375 1
a1375 1
		for (pr = nd_prefix.lh_first; pr; pr = next) {
d1378 1
a1378 1
			next = pr->ndpr_next;
d2113 1
a2113 1
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
d2155 1
a2155 2
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next) {
d2172 1
a2172 2
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next)
@


1.71
log
@Spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.70 2006/02/21 10:23:25 markus Exp $	*/
d689 1
a689 1
	rt = rtalloc1((struct sockaddr *)&sin6, create);
d727 1
a727 1
			    ~RTF_CLONING, &rt)) != 0) {
d936 1
a936 1
	    rt_mask(rt), 0, (struct rtentry **)0);
d1060 1
a1060 1
				   (struct sockaddr *)&null_sdl);
d1748 1
a1748 1
			    1)) != NULL)
d1786 1
a1786 1
				rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
@


1.70
log
@use after free; from itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.69 2005/05/09 05:37:36 brad Exp $	*/
d539 1
a539 1
	 * However, from a stricter speci-confrmance standpoint, we should
d892 1
a892 1
			 * Unreachablity of a router might affect the default
d944 1
a944 1
 * XXX cost-effective metods?
d1070 1
a1070 1
		 * In IPv4 code, we try to annonuce new RTF_ANNOUNCE entry here.
d1298 2
a1299 2
		 * XXX meaning of fields, especialy "raflags", is very
		 * differnet between RA prefix list and RR/static prefix list.
d1491 1
a1491 1
	 * XXX If the link does not have link-layer adderss, what should
d1583 1
a1583 1
			 * state tansition to DELAY and reset the timer,
d1617 1
a1617 1
	 * A quetion arises for (1) case.  (1) case has no lladdr in the
d1743 1
a1743 1
	 * next hop determination.  This routine is derived from ether_outpout.
@


1.69
log
@Make sure that prefixes get purged.

Fixes PR 3939.

From NetBSD

ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.68 2004/10/28 20:34:57 henning Exp $	*/
d548 1
a548 2
		}
		if (IFA6_IS_DEPRECATED(ia6)) {
@


1.68
log
@treat IFT_CARP like IFT_PROPVIRTUAL, ryan daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.67 2004/06/21 23:50:37 tholo Exp $	*/
d625 7
@


1.67
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.66 2004/05/19 17:48:19 itojun Exp $	*/
d1929 1
@


1.66
log
@do not loop on nd6_output() when transmission fails.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.65 2003/06/27 22:47:32 itojun Exp $	*/
d383 1
a383 1
		ln->ln_expire = time.tv_sec + tick / hz;
d526 1
a526 1
		if (dr->expire && dr->expire < time.tv_sec) {
d569 1
a569 1
		    time.tv_sec - pr->ndpr_lastupdate > pr->ndpr_vltime) {
d866 1
a866 1
			if (dr->expire > time.tv_sec * hz) {
d868 1
a868 1
				    dr->expire - time.tv_sec * hz);
@


1.65
log
@split ND6 cache timer management to per-entry.  increased accuracy,
no O(N) loop.   sync w/ kame.  marc tested, daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.64 2003/06/24 07:55:12 itojun Exp $	*/
d1745 2
a1746 5
				if (rt->rt_ifp != ifp) {
					/* XXX: loop care? */
					return nd6_output(ifp, origifp, m0,
					    dst, rt);
				}
@


1.64
log
@remove unneeded checks of accept_rtadv.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.63 2003/06/24 07:48:51 itojun Exp $	*/
d103 1
d369 1
a369 1
 * ND6 timer routine to expire default route list and prefix list
d372 26
a397 2
nd6_timer(ignored_arg)
	void	*ignored_arg;
d401 2
a402 2
	struct nd_defrouter *dr;
	struct nd_prefix *pr;
d404 1
a404 2
	struct in6_ifaddr *ia6, *nia6;
	struct in6_addrlifetime *lt6;
a406 2
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add(&nd6_timer_ch, nd6_prune * hz);
d408 46
a453 7
	ln = llinfo_nd6.ln_next;
	while (ln && ln != &llinfo_nd6) {
		struct rtentry *rt;
		struct sockaddr_in6 *dst;
		struct llinfo_nd6 *next = ln->ln_next;
		/* XXX: used for the DELAY case only: */
		struct nd_ifinfo *ndi = NULL;
d455 5
a459 3
		if ((rt = ln->ln_rt) == NULL) {
			ln = next;
			continue;
d461 5
a465 3
		if ((ifp = rt->rt_ifp) == NULL) {
			ln = next;
			continue;
d467 1
a467 2
		ndi = ND_IFINFO(ifp);
		dst = (struct sockaddr_in6 *)rt_key(rt);
d469 5
a473 3
		if (ln->ln_expire > time.tv_sec) {
			ln = next;
			continue;
d475 1
d477 25
a501 29
		/* sanity check */
		if (!rt)
			panic("rt=0 in nd6_timer(ln=%p)", ln);
		if (rt->rt_llinfo && (struct llinfo_nd6 *)rt->rt_llinfo != ln)
			panic("rt_llinfo(%p) is not equal to ln(%p)",
			      rt->rt_llinfo, ln);
		if (!dst)
			panic("dst=0 in nd6_timer(ln=%p)", ln);

		switch (ln->ln_state) {
		case ND6_LLINFO_INCOMPLETE:
			if (ln->ln_asked < nd6_mmaxtries) {
				ln->ln_asked++;
				ln->ln_expire = time.tv_sec +
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
				nd6_ns_output(ifp, NULL, &dst->sin6_addr,
				    ln, 0);
			} else {
				struct mbuf *m = ln->ln_hold;
				if (m) {
					ln->ln_hold = NULL;
					/*
					 * Fake rcvif to make the ICMP error
					 * more helpful in diagnosing for the
					 * receiver.
					 * XXX: should we consider
					 * older rcvif?
					 */
					m->m_pkthdr.rcvif = rt->rt_ifp;
d503 2
a504 12
					icmp6_error(m, ICMP6_DST_UNREACH,
						    ICMP6_DST_UNREACH_ADDR, 0);
				}
				next = nd6_free(rt, 0);
			}
			break;
		case ND6_LLINFO_REACHABLE:
			if (ln->ln_expire) {
				ln->ln_state = ND6_LLINFO_STALE;
				ln->ln_expire = time.tv_sec + nd6_gctimer;
			}
			break;
d506 12
a517 5
		case ND6_LLINFO_STALE:
			/* Garbage Collection(RFC 2461 5.3) */
			if (ln->ln_expire)
				next = nd6_free(rt, 1);
			break;
d519 3
a521 28
		case ND6_LLINFO_DELAY:
			if (ndi && (ndi->flags & ND6_IFF_PERFORMNUD) != 0) {
				/* We need NUD */
				ln->ln_asked = 1;
				ln->ln_state = ND6_LLINFO_PROBE;
				ln->ln_expire = time.tv_sec +
					ND6_RETRANS_SEC(ndi->retrans);
				nd6_ns_output(ifp, &dst->sin6_addr,
				    &dst->sin6_addr, ln, 0);
			} else {
				ln->ln_state = ND6_LLINFO_STALE; /* XXX */
				ln->ln_expire = time.tv_sec + nd6_gctimer;
			}
			break;
		case ND6_LLINFO_PROBE:
			if (ln->ln_asked < nd6_umaxtries) {
				ln->ln_asked++;
				ln->ln_expire = time.tv_sec +
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
				nd6_ns_output(ifp, &dst->sin6_addr,
				    &dst->sin6_addr, ln, 0);
			} else {
				next = nd6_free(rt, 0);
			}
			break;
		}
		ln = next;
	}
d866 5
a870 1
			ln->ln_expire = dr->expire;
d982 4
a985 2
	if (ln->ln_expire)
		ln->ln_expire = time.tv_sec + ND_IFINFO(rt->rt_ifp)->reachable;
d1059 1
a1059 11
				ln->ln_expire = time.tv_sec;
#if 1
			if (ln && ln->ln_expire == 0) {
				/* kludge for desktops */
#if 0
				printf("nd6_rtrequest: time.tv_sec is zero; "
				       "treat it as 1\n");
#endif
				ln->ln_expire = 1;
			}
#endif
d1123 1
d1139 1
a1139 1
			ln->ln_expire = time.tv_sec;
d1155 1
a1155 1
			ln->ln_expire = 0;
d1180 1
a1180 1
			ln->ln_expire = 0;
d1229 1
d1581 1
a1581 1
			ln->ln_expire = time.tv_sec + nd6_gctimer;
d1594 1
a1594 1
			ln->ln_expire = time.tv_sec;
d1827 1
a1827 1
		ln->ln_expire = time.tv_sec + nd6_gctimer;
d1840 1
a1840 1
		ln->ln_expire = time.tv_sec + nd6_delay;
a1863 6
	 * Technically this can be against the rate-limiting rule described in
	 * Section 7.2.2 of RFC 2461 because the interval to the next scheduled
	 * solicitation issued in nd6_timer() may be less than the specified
	 * retransmission time.  This should not be a problem from a practical
	 * point of view, because we'll typically see an immediate response
	 * from the neighbor, which suppresses the succeeding solicitations.
d1865 1
a1865 1
	if (ln->ln_expire && ln->ln_asked == 0) {
d1867 2
a1868 2
		ln->ln_expire = time.tv_sec +
		    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
d1893 1
a1893 1
					 rt));
@


1.63
log
@* kame/sys/netinet6/nd6.c (nd6_rtrequest): changed a condition to
decide whether to create an empty llinfo stricter so that a user
can manually change the link-layer address of an existing neighbor
cache.
Pointed out by: KIU Shueng Chuan

from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.62 2003/06/24 07:47:54 itojun Exp $	*/
d811 1
a811 1
	if (!ip6_forwarding && ip6_accept_rtadv) { /* XXX: too restrictive? */
@


1.62
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.61 2003/06/24 07:31:50 itojun Exp $	*/
d1004 2
a1005 1
		if (rt->rt_flags & (RTF_CLONING | RTF_LLINFO)) {
d1007 4
a1010 4
			 * Case 1: This route should come from
			 * a route to interface.  RTF_LLINFO flag is set
			 * for a host route whose destination should be
			 * treated as on-link.
@


1.61
log
@clear ln_hold earlier.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.60 2002/10/12 01:09:45 krw Exp $	*/
a377 1
	long time_second = time.tv_sec;
d405 1
a405 1
		if (ln->ln_expire > time_second) {
d423 1
a423 1
				ln->ln_expire = time_second +
d449 1
a449 1
				ln->ln_expire = time_second + nd6_gctimer;
d464 1
a464 1
				ln->ln_expire = time_second +
d470 1
a470 1
				ln->ln_expire = time_second + nd6_gctimer;
d476 1
a476 1
				ln->ln_expire = time_second +
d491 1
a491 1
		if (dr->expire && dr->expire < time_second) {
d534 1
a534 1
		    time_second - pr->ndpr_lastupdate > pr->ndpr_vltime) {
a907 1
	long time_second = time.tv_sec;
d944 1
a944 1
		ln->ln_expire = time_second + ND_IFINFO(rt->rt_ifp)->reachable;
a957 1
	long time_second = time.tv_sec;
d1017 1
a1017 1
				ln->ln_expire = time_second;
d1106 1
a1106 1
			ln->ln_expire = time_second;
a1436 1
	long time_second = time.tv_sec;
d1547 1
a1547 1
			ln->ln_expire = time_second + nd6_gctimer;
d1560 1
a1560 1
			ln->ln_expire = time_second;
a1691 1
	long time_second = time.tv_sec;
d1793 1
a1793 1
		ln->ln_expire = time_second + nd6_gctimer;
d1806 1
a1806 1
		ln->ln_expire = time_second + nd6_delay;
d1839 1
a1839 1
		ln->ln_expire = time_second +
@


1.60
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.59 2002/10/09 20:25:32 itojun Exp $	*/
d431 1
a442 1
					ln->ln_hold = NULL;
@


1.59
log
@supress too noisy log - can be re-enabled by sysctl.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.58 2002/09/23 23:28:15 itojun Exp $	*/
d246 1
a246 1
		panic("ndopts == NULL in nd6_option\n");
d248 1
a248 1
		panic("uninitialized ndopts in nd6_option\n");
d298 1
a298 1
		panic("ndopts == NULL in nd6_options\n");
d300 1
a300 1
		panic("uninitialized ndopts in nd6_options\n");
d413 1
a413 1
			panic("rt=0 in nd6_timer(ln=%p)\n", ln);
d415 1
a415 1
			panic("rt_llinfo(%p) is not equal to ln(%p)\n",
d418 1
a418 1
			panic("dst=0 in nd6_timer(ln=%p)\n", ln);
@


1.58
log
@better "ifconfig ipv6addr deprecated" flag handling.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.57 2002/09/11 03:15:36 itojun Exp $	*/
d723 1
a723 1
			log(LOG_DEBUG,
d725 2
a726 1
			    ip6_sprintf(addr6), ifp ? ifp->if_xname : "unspec");
@


1.57
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.56 2002/09/04 07:30:51 itojun Exp $	*/
d515 1
a515 2
		if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) != 0 ||
		    IFA6_IS_DEPRECATED(ia6)) {
@


1.56
log
@allow deprecated bit to be set from userland by ifconfig.  NetBSD PR 18163
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.55 2002/09/04 07:24:59 itojun Exp $	*/
d677 1
a677 1
				return(NULL);
d695 1
a695 1
				return(NULL);
d698 1
a698 1
				return(NULL);
d705 1
a705 1
			return(NULL);
d728 1
a728 1
		return(NULL);
d730 1
a730 1
	return(rt);
d753 1
a753 1
		return(1);
d779 1
a779 1
		return(1);
d787 1
a787 1
		return(1);
d789 1
a789 1
	return(0);
d834 1
a834 1
			return(ln->ln_next);
d894 1
a894 1
	return(next);
d1413 1
a1413 1
		return(nd6_setdefaultiface(ndif->ifindex));
d1416 1
a1416 1
	return(error);
d1848 1
a1848 1
	return(0);
d1869 1
a1869 1
		return((*ifp->if_output)(origifp, m, (struct sockaddr *)dst,
d1881 1
a1881 1
	return((*ifp->if_output)(ifp, m, (struct sockaddr *)dst, rt));
d1910 1
a1910 1
		return(1);
d1912 1
a1912 1
		return(0);
d1932 1
a1932 1
			return(1);
d1936 1
a1936 1
			return(1);
d1939 1
a1939 1
			return(0);
d1946 1
a1946 1
		return(0);
d1951 1
a1951 1
		return(0);
d1959 1
a1959 1
		return(0);
d1963 1
a1963 1
	return(1);
d2013 1
a2013 1
	return(error);
d2064 1
a2064 1
	return(error);
d2166 1
a2166 1
	return(error);
@


1.55
log
@handle error from copyout
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.54 2002/08/19 23:23:39 itojun Exp $	*/
d515 2
a516 1
		if (IFA6_IS_DEPRECATED(ia6)) {
@


1.54
log
@correct copyout logic.  better fix to be made in kame tree
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.53 2002/08/19 07:24:47 itojun Exp $	*/
d1996 1
a1996 1
			copyout(p, oldp, *oldlenp);
d2002 1
a2002 1
			copyout(p, oldp, *oldlenp);
@


1.53
log
@copyout only if oldp is non-null
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.52 2002/08/19 06:45:00 itojun Exp $	*/
d1968 1
a1968 1
	void *oldp;
d1970 1
a1970 1
	void *newp;
d1973 1
d1986 6
d1994 3
a1996 3
		error = fill_drlist(oldp, oldlenp, ol);
		if (!error && oldp)
			copyout(oldp, oldp, *oldlenp);
d2000 3
a2002 3
		error = fill_prlist(oldp, oldlenp, ol);
		if (!error && oldp)
			copyout(oldp, oldp, *oldlenp);
d2009 2
@


1.52
log
@need explicit copyout().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.51 2002/06/14 21:35:00 todd Exp $	*/
d1988 1
a1988 1
		if (!error)
d1994 1
a1994 1
		if (!error)
@


1.51
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.50 2002/06/08 21:51:08 itojun Exp $	*/
d1988 2
d1994 2
@


1.50
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.49 2002/06/08 21:22:41 itojun Exp $	*/
d345 1
a345 1
			 * to accomodate future extension to the protocol.
@


1.49
log
@remove #ifdef __NetBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.48 2002/06/08 21:22:03 itojun Exp $	*/
d383 1
a383 1
	s = splnet();
d813 1
a813 1
		s = splnet();
d1229 1
a1229 1
		s = splnet();
d1265 1
a1265 1
		s = splnet();
d1336 1
a1336 1
		s = splnet();
d1366 1
a1366 1
		s = splnet();
d1393 1
a1393 1
		s = splnet();
d1657 1
a1657 1
	int s = splnet();
d2012 1
a2012 1
	s = splnet();
d2064 1
a2064 1
	s = splnet();
@


1.48
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.47 2002/06/07 17:04:19 itojun Exp $	*/
a1335 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
a1336 1
#endif
@


1.47
log
@If there has been no NS for the neighbor after entering the
INCOMPLETE state, send the first solicitation in nd6_output(), regardless
of the timer value.
revised comments about rate-limiting accordingly.

sync w/kame
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.46 2002/06/03 00:59:08 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.151 2001/06/19 14:24:41 sumikawa Exp $	*/
a62 1
#include <netinet6/in6_prefix.h>
d102 1
d108 3
d152 6
a157 1
	nd->flags = ND6_IFF_PERFORMNUD;
d205 1
a205 1
	 * log to the case of changing the MTU, not initializing it. 
d379 4
a382 1
	
a383 1

a387 1
	/* XXX BSD/OS separates this code -- itojun */
a389 1
		struct ifnet *ifp;
d427 1
a427 1
					ln, 0);
d431 9
a439 10
					if (rt->rt_ifp) {
						/*
						 * Fake rcvif to make ICMP error
						 * more helpful in diagnosing
						 * for the receiver.
						 * XXX: should we consider
						 * older rcvif?
						 */
						m->m_pkthdr.rcvif = rt->rt_ifp;
					}
d444 1
a444 1
				next = nd6_free(rt);
d457 1
a457 1
				next = nd6_free(rt);
d468 1
a468 2
					      &dst->sin6_addr,
					      ln, 0);
d480 4
a483 3
					       &dst->sin6_addr, ln, 0);
			} else
				next = nd6_free(rt);
d488 1
a488 1
	
d497 1
a497 1
		} else
d499 1
a500 4
	pr = nd_prefix.lh_first;
	while (pr) {
		struct in6_ifaddr *ia6;
		struct in6_addrlifetime *lt6;
d502 21
a522 15
		if (IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
			ia6 = NULL;
		else
			ia6 = in6ifa_ifpwithaddr(pr->ndpr_ifp, &pr->ndpr_addr);

		if (ia6) {
			/* check address lifetime */
			lt6 = &ia6->ia6_lifetime;
			if (lt6->ia6t_preferred && lt6->ia6t_preferred < time_second)
				ia6->ia6_flags |= IN6_IFF_DEPRECATED;
			if (lt6->ia6t_expire && lt6->ia6t_expire < time_second) {
				if (!IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
					in6_ifdel(pr->ndpr_ifp, &pr->ndpr_addr);
				/* xxx ND_OPT_PI_FLAG_ONLINK processing */
			}
d524 1
d526 3
a532 5
		 *
		 * we offset expire time by NDPR_KEEP_EXPIRE, so that we
		 * can use the old prefix information to validate the
		 * next prefix information to come.  See prelist_update()
		 * for actual validation.
d534 2
a535 2
		if (pr->ndpr_expire
		 && pr->ndpr_expire + NDPR_KEEP_EXPIRED < time_second) {
d541 1
a541 1
			 * separate.  NEVER perform in6_ifdel here.
d561 1
a561 1
	struct nd_defrouter *dr, *ndr, drany;
d564 19
a582 12
	/* Nuke default router list entries toward ifp */
	if ((dr = TAILQ_FIRST(&nd_defrouter)) != NULL) {
		/*
		 * The first entry of the list may be stored in
		 * the routing table, so we'll delete it later.
		 */
		for (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = ndr) {
			ndr = TAILQ_NEXT(dr, dr_entry);
			if (dr->ifp == ifp)
				defrtrlist_del(dr);
		}
		dr = TAILQ_FIRST(&nd_defrouter);
d591 8
a598 2
			if (!IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
				in6_ifdel(pr->ndpr_ifp, &pr->ndpr_addr);
a608 2
		bzero(&drany, sizeof(drany));
		defrouter_delreq(&drany, 0);
d629 1
a629 1
				nln = nd6_free(rt);
d648 1
d674 1
a674 1
				ifaof_ifpforaddr((struct sockaddr *)&sin6, ifp);
d685 4
a688 6
					   ifa->ifa_addr,
					   (struct sockaddr *)&all1_sa,
					   (ifa->ifa_flags |
					    RTF_HOST | RTF_LLINFO) &
					   ~RTF_CLONING,
					   &rt)) != 0)
d693 3
d700 1
a700 1
					(struct llinfo_nd6 *)rt->rt_llinfo;
d709 4
d716 2
a717 1
	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL interface.
d720 1
a720 1
	    rt->rt_gateway->sa_family != AF_LINK ||
d723 2
a724 1
			log(LOG_DEBUG, "nd6_lookup: failed to lookup %s (if = %s)\n",
a725 1
			/* xxx more logs... kazu */
d727 1
a727 1
		return(0);
d741 2
a742 5
	struct ifaddr *ifa;
	int i;

#define IFADDR6(a) ((((struct in6_ifaddr *)(a))->ia_addr).sin6_addr)
#define IFMASK6(a) ((((struct in6_ifaddr *)(a))->ia_prefixmask).sin6_addr)
d748 1
d755 2
a756 2
	 * If the address matches one of our addresses,
	 * it should be a neighbor.
d758 11
a768 6
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr->sa_family != AF_INET6)
			next: continue;
d770 8
a777 6
		for (i = 0; i < 4; i++) {
			if ((IFADDR6(ifa).s6_addr32[i] ^
			     addr->sin6_addr.s6_addr32[i]) &
			    IFMASK6(ifa).s6_addr32[i])
				goto next;
		}
d785 1
a785 1
	if (nd6_lookup(&addr->sin6_addr, 0, ifp))
a788 2
#undef IFADDR6
#undef IFMASK6
d793 3
d797 2
a798 2
struct llinfo_nd6 *
nd6_free(rt)
d800 1
d807 2
a808 2
	 * Clear all destination cache entries for the neighbor.
	 * XXX: is it better to restrict this to hosts?
a809 1
	pfctlinput(PRC_HOSTDEAD, rt_key(rt));
d815 21
a835 1
				      rt->rt_ifp);
d861 7
a867 10
			if (dr == TAILQ_FIRST(&nd_defrouter)) {
				/*
				 * It is used as the current default router,
				 * so we have to move it to the end of the
				 * list and choose a new one.
				 * XXX: it is not very efficient if this is
				 *      the only router.
				 */
				TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
				TAILQ_INSERT_TAIL(&nd_defrouter, dr, dr_entry);
d869 4
a872 3
				defrouter_select();
			}
			pfxlist_onlink_check();
d891 1
a891 1
		  rt_mask(rt), 0, (struct rtentry **)0);
d960 4
d965 29
a993 1
	if (rt->rt_flags & RTF_GATEWAY)
d995 1
d1024 1
a1024 1
				printf("nd6_request: time.tv_sec is zero; "
d1030 1
a1030 1
			if (rt->rt_flags & RTF_CLONING)
d1062 1
a1062 1
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0) {
d1121 1
a1121 1
					  &SIN6(rt_key(rt))->sin6_addr);
d1127 1
d1165 5
a1169 4
				(void)in6_addmulti(&llsol, ifp, &error);
				if (error)
					printf(
"nd6_rtrequest: could not join solicited node multicast (errno=%d)\n", error);
a1205 59
void
nd6_p2p_rtrequest(req, rt, info)
	int	req;
	struct rtentry *rt;
	struct rt_addrinfo *info; /* xxx unused */
{
	struct sockaddr *gate = rt->rt_gateway;
	static struct sockaddr_dl null_sdl = {sizeof(null_sdl), AF_LINK};
	struct ifnet *ifp = rt->rt_ifp;
	struct ifaddr *ifa;

	if (rt->rt_flags & RTF_GATEWAY)
		return;

	switch (req) {
	case RTM_ADD:
		/*
		 * There is no backward compatibility :)
		 *
		 * if ((rt->rt_flags & RTF_HOST) == 0 &&
		 *     SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff)
		 *	   rt->rt_flags |= RTF_CLONING;
		 */
		if (rt->rt_flags & RTF_CLONING) {
			/*
			 * Case 1: This route should come from
			 * a route to interface.
			 */
			rt_setgate(rt, rt_key(rt),
				   (struct sockaddr *)&null_sdl);
			gate = rt->rt_gateway;
			SDL(gate)->sdl_type = ifp->if_type;
			SDL(gate)->sdl_index = ifp->if_index;
			break;
		}
		/* Announce a new entry if requested. */
		if (rt->rt_flags & RTF_ANNOUNCE)
			nd6_na_output(ifp,
				      &SIN6(rt_key(rt))->sin6_addr,
				      &SIN6(rt_key(rt))->sin6_addr,
				      ip6_forwarding ? ND_NA_FLAG_ROUTER : 0,
				      1, NULL);
		/* FALLTHROUGH */
	case RTM_RESOLVE:
		/*
		 * check if rt_key(rt) is one of my address assigned
		 * to the interface.
		 */
 		ifa = (struct ifaddr *)in6ifa_ifpwithaddr(rt->rt_ifp,
					  &SIN6(rt_key(rt))->sin6_addr);
		if (ifa) {
			if (nd6_useloopback) {
				rt->rt_ifp = lo0ifp;	/*XXX*/
			}
		}
		break;
	}
}

d1213 1
a1213 1
	struct in6_prlist *prl = (struct in6_prlist *)data;
d1217 1
a1217 1
	struct nd_defrouter *dr, any;
d1225 3
d1253 7
d1264 1
a1264 1
		bzero(prl, sizeof(*prl));
d1271 7
a1277 7
			prl->prefix[i].prefix = pr->ndpr_prefix.sin6_addr;
			prl->prefix[i].raflags = pr->ndpr_raf;
			prl->prefix[i].prefixlen = pr->ndpr_plen;
			prl->prefix[i].vltime = pr->ndpr_vltime;
			prl->prefix[i].pltime = pr->ndpr_pltime;
			prl->prefix[i].if_index = pr->ndpr_ifp->if_index;
			prl->prefix[i].expire = pr->ndpr_expire;
d1283 1
a1283 1
#define RTRADDR prl->prefix[i].advrtr[j]
d1299 2
a1300 2
			prl->prefix[i].advrtrs = j;
			prl->prefix[i].origin = PR_ORIG_RA;
a1304 19
	      {
		struct rr_prefix *rpp;

		for (rpp = LIST_FIRST(&rr_prefix); rpp;
		     rpp = LIST_NEXT(rpp, rp_entry)) {
			if (i >= PRLSTSIZ)
				break;
			prl->prefix[i].prefix = rpp->rp_prefix.sin6_addr;
			prl->prefix[i].raflags = rpp->rp_raf;
			prl->prefix[i].prefixlen = rpp->rp_plen;
			prl->prefix[i].vltime = rpp->rp_vltime;
			prl->prefix[i].pltime = rpp->rp_pltime;
			prl->prefix[i].if_index = rpp->rp_ifp->if_index;
			prl->prefix[i].expire = rpp->rp_expire;
			prl->prefix[i].advrtrs = 0;
			prl->prefix[i].origin = rpp->rp_origin;
			i++;
		}
	      }
d1327 2
a1328 7
		/* flush default router list */
		/*
		 * xxx sumikawa: should not delete route if default
		 * route equals to the top of default router list
		 */
		bzero(&any, sizeof(any));
		defrouter_delreq(&any, 0);
a1329 1
		/* xxx sumikawa: flush prefix list */
d1332 1
a1332 1
	    {
d1336 3
d1340 3
a1343 1
		for (pr = nd_prefix.lh_first; pr; pr = next) {
d1345 15
a1359 2
			if (!IN6_IS_ADDR_UNSPECIFIED(&pr->ndpr_addr))
				in6_ifdel(pr->ndpr_ifp, &pr->ndpr_addr);
d1364 1
a1364 1
	    }
d1366 1
a1366 1
	    {
d1371 4
a1374 10
		if ((dr = TAILQ_FIRST(&nd_defrouter)) != NULL) {
			/*
			 * The first entry of the list may be stored in
			 * the routing table, so we'll delete it later.
			 */
			for (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = next) {
				next = TAILQ_NEXT(dr, dr_entry);
				defrtrlist_del(dr);
			}
			defrtrlist_del(TAILQ_FIRST(&nd_defrouter));
d1376 1
d1379 1
a1379 1
	    }
d1381 1
a1381 1
	    {
d1398 2
a1399 2

		if ((rt = nd6_lookup(&nb_addr, 0, ifp)) == NULL) {
a1403 1
		ln = (struct llinfo_nd6 *)rt->rt_llinfo;
d1409 1
a1409 1
		
d1411 1
a1411 1
	    }
d1485 1
a1485 1
		(void)nd6_free(rt);
d1527 2
a1528 2
		if ((!olladdr && lladdr)		/* (3) */
		 || (olladdr && lladdr && llchange)) {	/* (5) */
d1562 1
a1562 2
					   (struct sockaddr_in6 *)rt_key(rt),
					   rt);
d1629 2
a1630 2
		if ((!is_newentry && (olladdr || lladdr))	/* (2-5) */
		 || (is_newentry && lladdr)) {			/* (7) */
d1647 3
d1707 1
a1707 14
	/*
	 * XXX: we currently do not make neighbor cache on any interface
	 * other than ARCnet, Ethernet, FDDI and GIF.
	 *
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
	 */
	switch (ifp->if_type) {
	case IFT_ARCNET:
	case IFT_ETHER:
	case IFT_FDDI:
	case IFT_GIF:		/* XXX need more cases? */
		break;
	default:
a1708 1
	}
d1715 2
a1716 2
			if ((rt0 = rt = rtalloc1((struct sockaddr *)dst, 1)) !=
				NULL)
d1722 1
a1722 1
							  dst, rt);
d1734 1
a1734 1
			 * of view, regardless the value of nd_ifinfo.flags.
d1756 2
a1757 1
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
d1843 1
a1843 1
	 * from the neighbor, which suppresses the succeeding solicitations. 
d1852 1
a1852 1
	
d1890 1
a1890 1
}	
d1894 26
d1932 1
a1932 1
		case IFT_FDDI:			
d1959 2
a1960 1
		printf("nd6_storelladdr: sdl_alen == 0\n");
d1967 190
@


1.46
log
@remove hardcoded assumptions on if_mtu.  leave it to sys/net.
makes it possible to take advantage of 9K ethernet.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.45 2002/05/30 05:07:17 itojun Exp $	*/
d459 1
a459 1
					ndi->retrans / 1000;
a1815 3
	 *
	 * XXX Does the code conform to rate-limiting rule?
	 * (RFC 2461 7.2.2)
d1822 15
a1836 8
	if (ln->ln_expire) {
		if (ln->ln_asked < nd6_mmaxtries &&
		    ln->ln_expire < time_second) {
			ln->ln_asked++;
			ln->ln_expire = time_second +
			    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
			nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
		}
@


1.45
log
@improve nd6_setmtu(), to warn too-small MTU on SIOCSIFMTU.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.44 2002/05/29 13:57:57 itojun Exp $	*/
a51 1
#include <net/if_atm.h>
d182 2
a183 5
	case IFT_ARCNET:	/* XXX MTU handling needs more work */
		ndi->maxmtu = MIN(60480, ifp->if_mtu);
		break;
	case IFT_ETHER:
		ndi->maxmtu = MIN(ETHERMTU, ifp->if_mtu);
a186 3
		break;
	case IFT_ATM:
		ndi->maxmtu = MIN(ATMMTU, ifp->if_mtu);
@


1.44
log
@bzero before setting
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.43 2002/05/29 13:56:37 itojun Exp $	*/
d102 1
d151 3
a153 1
	nd6_setmtu(ifp, nd);
d165 8
a172 5
  
/*
 * Reset ND level link MTU. This function is called when the physical MTU
 * changes, which means we might have to adjust the ND level MTU.
 */
d174 1
a174 1
nd6_setmtu(ifp, ndi)
d178 3
d200 10
a209 4
	if (ndi->maxmtu < IPV6_MMTU) {
		nd6log((LOG_INFO, "nd6_setmtu: "
		    "link MTU on %s (%lu) is too small for IPv6\n",
		    ifp->if_xname, (unsigned long)ndi->maxmtu));
@


1.43
log
@receivedra field is gone
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.42 2002/05/29 07:54:59 itojun Exp $	*/
d1284 1
@


1.42
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.41 2002/03/20 22:54:27 itojun Exp $	*/
a1291 1
		ndi->ndi.receivedra = ND_IFINFO(ifp)->receivedra;
@


1.41
log
@remove obsolete comment
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.40 2002/03/14 01:27:12 millert Exp $	*/
d53 1
a95 2
static size_t nd_ifinfo_indexlim = 8;
struct nd_ifinfo *nd_ifinfo = NULL;
d134 1
a134 1
void
d138 1
d140 2
a141 7
	/*
	 * We have some arrays that should be indexed by if_index.
	 * since if_index will grow dynamically, they should grow too.
	 */
	if (nd_ifinfo == NULL || if_index >= nd_ifinfo_indexlim) {
		size_t n;
		caddr_t q;
d143 1
a143 2
		while (if_index >= nd_ifinfo_indexlim)
			nd_ifinfo_indexlim <<= 1;
d145 6
a150 10
		/* grow nd_ifinfo */
		n = nd_ifinfo_indexlim * sizeof(struct nd_ifinfo);
		q = (caddr_t)malloc(n, M_IP6NDP, M_WAITOK);
		bzero(q, n);
		if (nd_ifinfo) {
			bcopy((caddr_t)nd_ifinfo, q, n/2);
			free((caddr_t)nd_ifinfo, M_IP6NDP);
		}
		nd_ifinfo = (struct nd_ifinfo *)q;
	}
d152 2
a153 1
#define ND nd_ifinfo[ifp->if_index]
d155 4
a158 9
	/*
	 * Don't initialize if called twice.
	 * XXX: to detect this, we should choose a member that is never set
	 * before initialization of the ND structure itself.  We formaly used
	 * the linkmtu member, which was not suitable because it could be 
	 * initialized via "ifconfig mtu".
	 */
	if (ND.basereachable)
		return;
d160 1
a160 9
	ND.linkmtu = ifindex2ifnet[ifp->if_index]->if_mtu;
	ND.chlim = IPV6_DEFHLIM;
	ND.basereachable = REACHABLE_TIME;
	ND.reachable = ND_COMPUTE_RTIME(ND.basereachable);
	ND.retrans = RETRANS_TIMER;
	ND.receivedra = 0;
	ND.flags = ND6_IFF_PERFORMNUD;
	nd6_setmtu(ifp);
#undef ND
d162 1
a162 1

d168 1
a168 1
nd6_setmtu(ifp)
d170 1
a171 3
	struct nd_ifinfo *ndi = &nd_ifinfo[ifp->if_index];
	u_long oldmaxmtu = ndi->maxmtu;
	u_long oldlinkmtu = ndi->linkmtu;
d180 3
d191 4
a194 22
	if (oldmaxmtu != ndi->maxmtu) {
		/*
		 * If the ND level MTU is not set yet, or if the maxmtu
		 * is reset to a smaller value than the ND level MTU,
		 * also reset the ND level MTU.
		 */
		if (ndi->linkmtu == 0 ||
		    ndi->maxmtu < ndi->linkmtu) {
			ndi->linkmtu = ndi->maxmtu;
			/* also adjust in6_maxmtu if necessary. */
			if (oldlinkmtu == 0) {
				/*
				 * XXX: the case analysis is grotty, but
				 * it is not efficient to call in6_setmaxmtu()
				 * here when we are during the initialization
				 * procedure.
				 */
				if (in6_maxmtu < ndi->linkmtu)
					in6_maxmtu = ndi->linkmtu;
			} else
				in6_setmaxmtu();
		}
d196 3
a198 1
#undef MIN
d207 1
d387 1
a387 1
		ndi = &nd_ifinfo[ifp->if_index];
d409 1
a409 1
					nd_ifinfo[ifp->if_index].retrans / 1000;
d464 1
a464 1
					nd_ifinfo[ifp->if_index].retrans / 1000;
d886 1
a886 2
		ln->ln_expire = time_second +
			nd_ifinfo[rt->rt_ifp->if_index].reachable;
d1282 12
d1295 1
a1295 5
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim) {
			error = EINVAL;
			break;
		}
		ndi->ndi = nd_ifinfo[ifp->if_index];
d1298 1
a1298 6
		/* XXX: almost all other fields of ndi->ndi is unused */
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim) {
			error = EINVAL;
			break;
		}
		nd_ifinfo[ifp->if_index].flags = ndi->ndi.flags;
a1627 1
	int i;
d1629 1
d1633 3
a1635 4
	for (i = 1; i < if_index + 1; i++) {
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim)
			continue;
		nd6if = &nd_ifinfo[i];
d1765 1
a1765 1
		    !(nd_ifinfo[ifp->if_index].flags & ND6_IFF_PERFORMNUD)) {
d1822 1
a1822 1
				nd_ifinfo[ifp->if_index].retrans / 1000;
@


1.40
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.39 2001/12/07 09:16:07 itojun Exp $	*/
a30 8
 */

/*
 * XXX
 * KAME 970409 note:
 * BSD/OS version heavily modifies this code, related to llinfo.
 * Since we don't have BSD/OS version of net/route.c in our hand,
 * I left the code mostly as it was in 970310.  -- itojun
@


1.39
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.38 2001/11/30 07:59:17 itojun Exp $	*/
d111 1
a111 1
static void nd6_slowtimo __P((void *));
@


1.39.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: nd6.c,v 1.280 2002/06/08 19:52:07 itojun Exp $	*/
d33 8
d60 1
a60 1
#include <net/if_fddi.h>
d71 1
d103 2
d111 1
a111 3
static void nd6_setmtu0(struct ifnet *, struct nd_ifinfo *);
static void nd6_slowtimo(void *);
static struct llinfo_nd6 *nd6_free(struct rtentry *, int);
a116 3
static int fill_drlist(void *, size_t *, size_t);
static int fill_prlist(void *, size_t *, size_t);

d143 1
a143 1
struct nd_ifinfo *
a146 1
	struct nd_ifinfo *nd;
a147 9
	nd = (struct nd_ifinfo *)malloc(sizeof(*nd), M_IP6NDP, M_WAITOK);
	bzero(nd, sizeof(*nd));

	nd->initialized = 1;

	nd->chlim = IPV6_DEFHLIM;
	nd->basereachable = REACHABLE_TIME;
	nd->reachable = ND_COMPUTE_RTIME(nd->basereachable);
	nd->retrans = RETRANS_TIMER;
d149 2
a150 3
	 * Note that the default value of ip6_accept_rtadv is 0, which means
	 * we won't accept RAs by default even if we set ND6_IFF_ACCEPT_RTADV
	 * here.
d152 6
a157 1
	nd->flags = (ND6_IFF_PERFORMNUD | ND6_IFF_ACCEPT_RTADV);
d159 10
a168 2
	/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
	nd6_setmtu0(ifp, nd);
d170 1
a170 2
	return nd;
}
d172 9
a180 4
void
nd6_ifdetach(nd)
	struct nd_ifinfo *nd;
{
d182 9
a190 1
	free(nd, M_IP6NDP);
d193 4
d201 3
a203 11
	nd6_setmtu0(ifp, ND_IFINFO(ifp));
}

void
nd6_setmtu0(ifp, ndi)
	struct ifnet *ifp;
	struct nd_ifinfo *ndi;
{
	u_int32_t omaxmtu;

	omaxmtu = ndi->maxmtu;
d206 5
a210 2
	case IFT_ARCNET:
		ndi->maxmtu = MIN(60480, ifp->if_mtu); /* RFC2497 */
d212 2
a213 2
	case IFT_FDDI:
		ndi->maxmtu = MIN(FDDIMTU, ifp->if_mtu);
d220 22
a241 10
	/*
	 * Decreasing the interface MTU under IPV6 minimum MTU may cause
	 * undesirable situation.  We thus notify the operator of the change
	 * explicitly.  The check for omaxmtu is necessary to restrict the
	 * log to the case of changing the MTU, not initializing it.
	 */
	if (omaxmtu >= IPV6_MMTU && ndi->maxmtu < IPV6_MMTU) {
		log(LOG_NOTICE, "nd6_setmtu0: "
		    "new link MTU on %s (%lu) is too small for IPv6\n",
		    ifp->if_xname, (unsigned long)ndi->maxmtu);
d243 1
a243 3

	if (ndi->maxmtu > in6_maxmtu)
		in6_setmaxmtu(); /* check all interfaces just in case */
a251 1

d407 2
a408 3
	struct ifnet *ifp;
	struct in6_ifaddr *ia6, *nia6;
	struct in6_addrlifetime *lt6;
a409 1
	s = splsoftnet();
d414 1
d417 1
d431 1
a431 1
		ndi = ND_IFINFO(ifp);
d453 1
a453 1
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
d455 1
a455 1
				    ln, 0);
d459 10
a468 9
					/*
					 * Fake rcvif to make the ICMP error
					 * more helpful in diagnosing for the
					 * receiver.
					 * XXX: should we consider
					 * older rcvif?
					 */
					m->m_pkthdr.rcvif = rt->rt_ifp;

d473 1
a473 1
				next = nd6_free(rt, 0);
d486 1
a486 1
				next = nd6_free(rt, 1);
d495 1
a495 1
					ND6_RETRANS_SEC(ndi->retrans);
d497 2
a498 1
				    &dst->sin6_addr, ln, 0);
d508 1
a508 1
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
d510 3
a512 4
				    &dst->sin6_addr, ln, 0);
			} else {
				next = nd6_free(rt, 0);
			}
d517 1
a517 1

d526 1
a526 1
		} else {
a527 1
		}
d529 9
d539 10
a548 21
	/*
	 * expire interface addresses.
	 * in the past the loop was inside prefix expiry processing.
	 * However, from a stricter speci-confrmance standpoint, we should
	 * rather separate address lifetimes and prefix lifetimes.
	 */
	for (ia6 = in6_ifaddr; ia6; ia6 = nia6) {
		nia6 = ia6->ia_next;
		/* check address lifetime */
		lt6 = &ia6->ia6_lifetime;
		if (IFA6_IS_INVALID(ia6)) {
			in6_purgeaddr(&ia6->ia_ifa);
		}
		if (IFA6_IS_DEPRECATED(ia6)) {
			ia6->ia6_flags |= IN6_IFF_DEPRECATED;
		} else {
			/*
			 * A new RA might have made a deprecated address
			 * preferred.
			 */
			ia6->ia6_flags &= ~IN6_IFF_DEPRECATED;
a549 1
	}
a550 3
	/* expire prefix list */
	pr = nd_prefix.lh_first;
	while (pr) {
d555 5
d561 2
a562 2
		if (pr->ndpr_vltime != ND6_INFINITE_LIFETIME &&
		    time_second - pr->ndpr_lastupdate > pr->ndpr_vltime) {
d568 1
a568 1
			 * separate.  NEVER perform in6_purgeaddr here.
d588 1
a588 1
	struct nd_defrouter *dr, *ndr;
d591 12
a602 19
	/*
	 * Nuke default router list entries toward ifp.
	 * We defer removal of default router list entries that is installed
	 * in the routing table, in order to keep additional side effects as
	 * small as possible.
	 */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
		if (dr->installed)
			continue;

		if (dr->ifp == ifp)
			defrtrlist_del(dr);
	}
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
		if (!dr->installed)
			continue;

d611 2
a612 8
			/*
			 * Previously, pr->ndpr_addr is removed as well,
			 * but I strongly believe we don't have to do it.
			 * nd6_purge() is only called from in6_ifdetach(),
			 * which removes all the associated interface addresses
			 * by itself.
			 * (jinmei@@kame.net 20010129)
			 */
d623 2
d645 1
a645 1
				nln = nd6_free(rt, 0);
a663 1

d689 1
a689 1
			    ifaof_ifpforaddr((struct sockaddr *)&sin6, ifp);
d700 6
a705 4
			    ifa->ifa_addr, (struct sockaddr *)&all1_sa,
			    (ifa->ifa_flags | RTF_HOST | RTF_LLINFO) &
			    ~RTF_CLONING, &rt)) != 0) {
#if 0
a709 3
#endif
				return(NULL);
			}
d714 1
a714 1
				    (struct llinfo_nd6 *)rt->rt_llinfo;
a722 4
	 * Note that the check for rt_llinfo is necessary because a cloned
	 * route from a parent route that has the L flag (e.g. the default
	 * route to a p2p interface) may have the flag, too, while the
	 * destination is not actually a neighbor.
d726 1
a726 2
	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL
	 *	interface.
d729 1
a729 1
	    rt->rt_gateway->sa_family != AF_LINK || rt->rt_llinfo == NULL ||
d732 1
a732 2
			log(LOG_DEBUG,
			    "nd6_lookup: failed to lookup %s (if = %s)\n",
d734 1
d736 1
a736 1
		return(NULL);
d750 5
a754 2
	struct nd_prefix *pr;
	struct rtentry *rt;
a759 1
	 * XXX: a link does not necessarily specify a single interface.
d766 2
a767 2
	 * If the address matches one of our on-link prefixes, it should be a
	 * neighbor.
d769 6
a774 3
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		if (pr->ndpr_ifp != ifp)
			continue;
d776 6
a781 16
		if (!(pr->ndpr_stateflags & NDPRF_ONLINK))
			continue;

		if (IN6_ARE_MASKED_ADDR_EQUAL(&pr->ndpr_prefix.sin6_addr,
		    &addr->sin6_addr, &pr->ndpr_mask))
			return (1);
	}

	/*
	 * If the default router list is empty, all addresses are regarded
	 * as on-link, and thus, as a neighbor.
	 * XXX: we restrict the condition to hosts, because routers usually do
	 * not have the "default router list".
	 */
	if (!ip6_forwarding && TAILQ_FIRST(&nd_defrouter) == NULL &&
	    nd6_defifindex == ifp->if_index) {
d789 1
a789 1
	if ((rt = nd6_lookup(&addr->sin6_addr, 0, ifp)) != NULL)
d793 2
a798 3
 * Since the function would cause significant changes in the kernel, DO NOT
 * make it global, unless you have a strong reason for the change, and are sure
 * that the change is safe.
d800 2
a801 2
static struct llinfo_nd6 *
nd6_free(rt, gc)
a802 1
	int gc;
d809 2
a810 2
	 * we used to have pfctlinput(PRC_HOSTDEAD) here.
	 * even though it is not harmful, it was not really necessary.
d812 1
d816 1
a816 1
		s = splsoftnet();
d818 1
a818 21
		    rt->rt_ifp);

		if (dr != NULL && dr->expire &&
		    ln->ln_state == ND6_LLINFO_STALE && gc) {
			/*
			 * If the reason for the deletion is just garbage
			 * collection, and the neighbor is an active default
			 * router, do not delete it.  Instead, reset the GC
			 * timer using the router's lifetime.
			 * Simply deleting the entry would affect default
			 * router selection, which is not necessarily a good
			 * thing, especially when we're using router preference
			 * values.
			 * XXX: the check for ln_state would be redundant,
			 *      but we intentionally keep it just in case.
			 */
			ln->ln_expire = dr->expire;
			splx(s);
			return(ln->ln_next);
		}

d844 13
a856 6
			/*
			 * Since defrouter_select() does not affect the
			 * on-link determination and MIP6 needs the check
			 * before the default router selection, we perform
			 * the check now.
			 */
a857 5

			/*
			 * refresh default router list
			 */
			defrouter_select();
d876 1
a876 1
	    rt_mask(rt), 0, (struct rtentry **)0);
d930 2
a931 1
		ln->ln_expire = time_second + ND_IFINFO(rt->rt_ifp)->reachable;
a945 1
	int mine = 0;
d947 1
a947 1
	if ((rt->rt_flags & RTF_GATEWAY) != 0)
a949 32
	if (nd6_need_cache(ifp) == 0 && (rt->rt_flags & RTF_HOST) == 0) {
		/*
		 * This is probably an interface direct route for a link
		 * which does not need neighbor caches (e.g. fe80::%lo0/64).
		 * We do not need special treatment below for such a route.
		 * Moreover, the RTF_LLINFO flag which would be set below
		 * would annoy the ndp(8) command.
		 */
		return;
	}

	if (req == RTM_RESOLVE &&
	    (nd6_need_cache(ifp) == 0 || /* stf case */
	     !nd6_is_addr_neighbor((struct sockaddr_in6 *)rt_key(rt), ifp))) {
		/*
		 * FreeBSD and BSD/OS often make a cloned host route based
		 * on a less-specific route (e.g. the default route).
		 * If the less specific route does not have a "gateway"
		 * (this is the case when the route just goes to a p2p or an
		 * stf interface), we'll mistakenly make a neighbor cache for
		 * the host route, and will see strange neighbor solicitation
		 * for the corresponding destination.  In order to avoid the
		 * confusion, we check if the destination of the route is
		 * a neighbor in terms of neighbor discovery, and stop the
		 * process if not.  Additionally, we remove the LLINFO flag
		 * so that ndp(8) will not try to get the neighbor information
		 * of the destination.
		 */
		rt->rt_flags &= ~RTF_LLINFO;
		return;
	}

d977 1
a977 1
				printf("nd6_rtrequest: time.tv_sec is zero; "
d983 1
a983 1
			if ((rt->rt_flags & RTF_CLONING) != 0)
d1015 1
a1015 1
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) == 0) {
d1074 1
a1074 1
		    &SIN6(rt_key(rt))->sin6_addr);
a1079 1
			mine = 1;
d1117 4
a1120 5
				if (in6_addmulti(&llsol, ifp, &error)) {
					nd6log((LOG_ERR, "%s: failed to join "
					    "%s (errno=%d)\n", ifp->if_xname,
					    ip6_sprintf(&llsol), error));
				}
d1157 59
d1223 1
a1223 1
	struct in6_oprlist *oprl = (struct in6_oprlist *)data;
d1227 1
a1227 1
	struct nd_defrouter *dr;
a1234 3
		/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 */
d1236 1
a1236 1
		s = splsoftnet();
a1259 7
		 * obsolete API, use sysctl under net.inet6.icmp6
		 *
		 * XXX the structure in6_prlist was changed in backward-
		 * incompatible manner.  in6_oprlist is used for SIOCGPRLST_IN6,
		 * in6_prlist is used for nd6_sysctl() - fill_prlist().
		 */
		/*
d1264 2
a1265 2
		bzero(oprl, sizeof(*oprl));
		s = splsoftnet();
d1271 7
a1277 7
			oprl->prefix[i].prefix = pr->ndpr_prefix.sin6_addr;
			oprl->prefix[i].raflags = pr->ndpr_raf;
			oprl->prefix[i].prefixlen = pr->ndpr_plen;
			oprl->prefix[i].vltime = pr->ndpr_vltime;
			oprl->prefix[i].pltime = pr->ndpr_pltime;
			oprl->prefix[i].if_index = pr->ndpr_ifp->if_index;
			oprl->prefix[i].expire = pr->ndpr_expire;
d1283 1
a1283 1
#define RTRADDR oprl->prefix[i].advrtr[j]
d1299 2
a1300 2
			oprl->prefix[i].advrtrs = j;
			oprl->prefix[i].origin = PR_ORIG_RA;
d1305 19
a1326 12
	case OSIOCGIFINFO_IN6:
		/* XXX: old ndp(8) assumes a positive value for linkmtu. */
		bzero(&ndi->ndi, sizeof(ndi->ndi));
		ndi->ndi.linkmtu = IN6_LINKMTU(ifp);
		ndi->ndi.maxmtu = ND_IFINFO(ifp)->maxmtu;
		ndi->ndi.basereachable = ND_IFINFO(ifp)->basereachable;
		ndi->ndi.reachable = ND_IFINFO(ifp)->reachable;
		ndi->ndi.retrans = ND_IFINFO(ifp)->retrans;
		ndi->ndi.flags = ND_IFINFO(ifp)->flags;
		ndi->ndi.recalctm = ND_IFINFO(ifp)->recalctm;
		ndi->ndi.chlim = ND_IFINFO(ifp)->chlim;
		break;
d1328 5
a1332 1
		ndi->ndi = *ND_IFINFO(ifp);
d1335 6
a1340 1
		ND_IFINFO(ifp)->flags = ndi->ndi.flags;
d1343 7
a1349 2
		/* sync kernel routing table with the default router list */
		defrouter_reset();
d1351 1
d1354 1
a1354 1
	{
d1358 2
a1359 1
		s = splsoftnet();
a1360 2
			struct in6_ifaddr *ia, *ia_next;

d1362 2
a1363 15

			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue; /* XXX */

			/* do we really have to remove addresses as well? */
			for (ia = in6_ifaddr; ia; ia = ia_next) {
				/* ia might be removed.  keep the next ptr. */
				ia_next = ia->ia_next;

				if ((ia->ia6_flags & IN6_IFF_AUTOCONF) == 0)
					continue;

				if (ia->ia6_ndpr == pr)
					in6_purgeaddr(&ia->ia_ifa);
			}
d1368 1
a1368 1
	}
d1370 1
a1370 1
	{
d1374 11
a1384 5
		s = splsoftnet();
		defrouter_reset();
		for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = next) {
			next = TAILQ_NEXT(dr, dr_entry);
			defrtrlist_del(dr);
a1385 1
		defrouter_select();
d1388 1
a1388 1
	}
d1390 1
a1390 1
	{
d1406 3
a1408 3
		s = splsoftnet();
		if ((rt = nd6_lookup(&nb_addr, 0, ifp)) == NULL ||
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) == NULL) {
d1413 1
d1419 1
a1419 1

d1421 1
a1421 1
	}
d1495 1
a1495 1
		(void)nd6_free(rt, 0);
d1537 2
a1538 2
		if ((!olladdr && lladdr) ||		/* (3) */
		    (olladdr && lladdr && llchange)) {	/* (5) */
d1572 2
a1573 1
				    (struct sockaddr_in6 *)rt_key(rt), rt);
d1640 2
a1641 2
		if ((!is_newentry && (olladdr || lladdr)) ||	/* (2-5) */
		    (is_newentry && lladdr)) {			/* (7) */
a1657 3
	 * XXX: although defrouter_select() should not have a bad effect
	 * for those are not autoconfigured hosts, we explicitly avoid such
	 * cases for safety.
d1669 2
a1670 1
	int s = splsoftnet();
a1671 1
	struct ifnet *ifp;
d1675 4
a1678 3
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
		nd6if = ND_IFINFO(ifp);
d1716 14
a1729 1
	if (nd6_need_cache(ifp) == 0)
d1731 1
d1738 2
a1739 2
			if ((rt0 = rt = rtalloc1((struct sockaddr *)dst,
			    1)) != NULL)
d1745 1
a1745 1
					    dst, rt);
d1757 1
a1757 1
			 * of view, regardless of the value of nd_ifinfo.flags.
d1779 1
a1779 2
			lookup:
				rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
d1808 1
a1808 1
		    !(ND_IFINFO(ifp)->flags & ND6_IFF_PERFORMNUD)) {
d1851 3
d1860 8
a1867 15
	/*
	 * If there has been no NS for the neighbor after entering the
	 * INCOMPLETE state, send the first solicitation.
	 * Technically this can be against the rate-limiting rule described in
	 * Section 7.2.2 of RFC 2461 because the interval to the next scheduled
	 * solicitation issued in nd6_timer() may be less than the specified
	 * retransmission time.  This should not be a problem from a practical
	 * point of view, because we'll typically see an immediate response
	 * from the neighbor, which suppresses the succeeding solicitations.
	 */
	if (ln->ln_expire && ln->ln_asked == 0) {
		ln->ln_asked++;
		ln->ln_expire = time_second +
		    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
		nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
d1870 1
a1870 1

d1908 1
a1908 1
}
a1911 26
nd6_need_cache(ifp)
	struct ifnet *ifp;
{
	/*
	 * XXX: we currently do not make neighbor cache on any interface
	 * other than ARCnet, Ethernet, FDDI and GIF.
	 *
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
	 */
	switch (ifp->if_type) {
	case IFT_ARCNET:
	case IFT_ETHER:
	case IFT_FDDI:
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
	case IFT_L2VLAN:
	case IFT_IEEE80211:
	case IFT_GIF:		/* XXX need more cases? */
		return(1);
	default:
		return(0);
	}
}

int
d1924 1
a1924 1
		case IFT_FDDI:
d1951 1
a1951 2
		printf("nd6_storelladdr: sdl_alen == 0, dst=%s, if=%s\n",
		    ip6_sprintf(&SIN6(dst)->sin6_addr), ifp->if_xname);
a1957 190
}

int
nd6_sysctl(name, oldp, oldlenp, newp, newlen)
	int name;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	size_t ol, l;
	int error;

	error = 0;
	l = 0;

	if (newp)
		return EPERM;
	if (oldp && !oldlenp)
		return EINVAL;
	ol = oldlenp ? *oldlenp : 0;

	switch (name) {
	case ICMPV6CTL_ND6_DRLIST:
		error = fill_drlist(oldp, oldlenp, ol);
		break;

	case ICMPV6CTL_ND6_PRLIST:
		error = fill_prlist(oldp, oldlenp, ol);
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}

	return(error);
}

static int
fill_drlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
{
	int error = 0, s;
	struct in6_defrouter *d = NULL, *de = NULL;
	struct nd_defrouter *dr;
	size_t l;

	s = splsoftnet();

	if (oldp) {
		d = (struct in6_defrouter *)oldp;
		de = (struct in6_defrouter *)((caddr_t)oldp + *oldlenp);
	}
	l = 0;

	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {

		if (oldp && d + 1 <= de) {
			bzero(d, sizeof(*d));
			d->rtaddr.sin6_family = AF_INET6;
			d->rtaddr.sin6_len = sizeof(struct sockaddr_in6);
			d->rtaddr.sin6_addr = dr->rtaddr;
			in6_recoverscope(&d->rtaddr, &d->rtaddr.sin6_addr,
			    dr->ifp);
			d->flags = dr->flags;
			d->rtlifetime = dr->rtlifetime;
			d->expire = dr->expire;
			d->if_index = dr->ifp->if_index;
		}

		l += sizeof(*d);
		if (d)
			d++;
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;

	splx(s);

	return(error);
}

static int
fill_prlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
{
	int error = 0, s;
	struct nd_prefix *pr;
	struct in6_prefix *p = NULL;
	struct in6_prefix *pe = NULL;
	size_t l;

	s = splsoftnet();

	if (oldp) {
		p = (struct in6_prefix *)oldp;
		pe = (struct in6_prefix *)((caddr_t)oldp + *oldlenp);
	}
	l = 0;

	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		u_short advrtrs;
		size_t advance;
		struct sockaddr_in6 *sin6;
		struct sockaddr_in6 *s6;
		struct nd_pfxrouter *pfr;

		if (oldp && p + 1 <= pe)
		{
			bzero(p, sizeof(*p));
			sin6 = (struct sockaddr_in6 *)(p + 1);

			p->prefix = pr->ndpr_prefix;
			if (in6_recoverscope(&p->prefix,
			    &p->prefix.sin6_addr, pr->ndpr_ifp) != 0)
				log(LOG_ERR,
				    "scope error in prefix list (%s)\n",
				    ip6_sprintf(&p->prefix.sin6_addr));
			p->raflags = pr->ndpr_raf;
			p->prefixlen = pr->ndpr_plen;
			p->vltime = pr->ndpr_vltime;
			p->pltime = pr->ndpr_pltime;
			p->if_index = pr->ndpr_ifp->if_index;
			if (pr->ndpr_vltime == ND6_INFINITE_LIFETIME)
				p->expire = 0;
			else {
				time_t maxexpire;

				/* XXX: we assume time_t is signed. */
				maxexpire = (-1) &
					~(1 << ((sizeof(maxexpire) * 8) - 1));
				if (pr->ndpr_vltime <
				    maxexpire - pr->ndpr_lastupdate) {
					p->expire = pr->ndpr_lastupdate +
						pr->ndpr_vltime;
				} else
					p->expire = maxexpire;
			}
			p->refcnt = pr->ndpr_refcnt;
			p->flags = pr->ndpr_stateflags;
			p->origin = PR_ORIG_RA;
			advrtrs = 0;
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next) {
				if ((void *)&sin6[advrtrs + 1] > (void *)pe) {
					advrtrs++;
					continue;
				}
				s6 = &sin6[advrtrs];
				s6->sin6_family = AF_INET6;
				s6->sin6_len = sizeof(struct sockaddr_in6);
				s6->sin6_addr = pfr->router->rtaddr;
				in6_recoverscope(s6, &pfr->router->rtaddr,
				    pfr->router->ifp);
				advrtrs++;
			}
			p->advrtrs = advrtrs;
		}
		else {
			advrtrs = 0;
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next)
				advrtrs++;
		}

		advance = sizeof(*p) + sizeof(*sin6) * advrtrs;
		l += advance;
		if (p)
			p = (struct in6_prefix *)((caddr_t)p + advance);
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;

	splx(s);

	return(error);
@


1.39.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.39.2.1 2002/06/11 03:31:37 art Exp $	*/
d246 1
a246 1
		panic("ndopts == NULL in nd6_option");
d248 1
a248 1
		panic("uninitialized ndopts in nd6_option");
d298 1
a298 1
		panic("ndopts == NULL in nd6_options");
d300 1
a300 1
		panic("uninitialized ndopts in nd6_options");
d345 1
a345 1
			 * to accommodate future extension to the protocol.
d413 1
a413 1
			panic("rt=0 in nd6_timer(ln=%p)", ln);
d415 1
a415 1
			panic("rt_llinfo(%p) is not equal to ln(%p)",
d418 1
a418 1
			panic("dst=0 in nd6_timer(ln=%p)", ln);
d676 1
a676 1
				return (NULL);
d694 1
a694 1
				return (NULL);
d697 1
a697 1
				return (NULL);
d704 1
a704 1
			return (NULL);
d723 1
a723 1
			nd6log((LOG_DEBUG,
d725 1
a725 2
			    ip6_sprintf(addr6),
			    ifp ? ifp->if_xname : "unspec"));
d727 1
a727 1
		return (NULL);
d729 1
a729 1
	return (rt);
d752 1
a752 1
		return (1);
d778 1
a778 1
		return (1);
d786 1
a786 1
		return (1);
d788 1
a788 1
	return (0);
d833 1
a833 1
			return (ln->ln_next);
d893 1
a893 1
	return (next);
d1412 1
a1412 1
		return (nd6_setdefaultiface(ndif->ifindex));
d1415 1
a1415 1
	return (error);
d1847 1
a1847 1
	return (0);
d1868 1
a1868 1
		return ((*ifp->if_output)(origifp, m, (struct sockaddr *)dst,
d1880 1
a1880 1
	return ((*ifp->if_output)(ifp, m, (struct sockaddr *)dst, rt));
d1909 1
a1909 1
		return (1);
d1911 1
a1911 1
		return (0);
d1931 1
a1931 1
			return (1);
d1935 1
a1935 1
			return (1);
d1938 1
a1938 1
			return (0);
d1945 1
a1945 1
		return (0);
d1950 1
a1950 1
		return (0);
d1958 1
a1958 1
		return (0);
d1962 1
a1962 1
	return (1);
d1968 1
a1968 1
	void *oldp;	/* syscall arg, need copyout */
d1970 1
a1970 1
	void *newp;	/* syscall arg, need copyin */
a1972 1
	void *p;
a1984 6
	if (oldp) {
		p = malloc(*oldlenp, M_TEMP, M_WAITOK);
		if (!p)
			return ENOMEM;
	} else
		p = NULL;
d1987 1
a1987 3
		error = fill_drlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
d1991 1
a1991 3
		error = fill_prlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
a1997 2
	if (p)
		free(p, M_TEMP);
d1999 1
a1999 1
	return (error);
d2050 1
a2050 1
	return (error);
d2152 1
a2152 1
	return (error);
@


1.38
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.37 2001/06/29 16:10:36 itojun Exp $	*/
d438 1
a438 1
		
d694 1
a694 1
			 * Create a new route. RTF_LLINFO is necessary
d697 1
a697 1
			 * called in rtequest via ifa->ifa_rtrequest.
d838 1
a838 1
			 * prefixes coreectly.
d866 1
a866 1
	 * a side effect (XXX). 
d962 1
a962 1
			 * a route to interface. RTF_LLINFO flag is set
d1434 1
a1434 1
 * on reception of inbound ND6 packets. (RS/RA/NS/redirect)
d1527 1
a1527 1
	if (lladdr) {		/*(3-5) and (7)*/
d1537 2
a1538 2
		if ((!olladdr && lladdr)		/*(3)*/
		 || (olladdr && lladdr && llchange)) {	/*(5)*/
d1541 1
a1541 1
		} else					/*(1-2,4)*/
d1545 1
a1545 1
		if (!lladdr)				/*(6)*/
d1547 1
a1547 1
		else					/*(7)*/
d1616 1
a1616 1
		if (is_newentry)	/*(6-7)*/
d1622 2
a1623 2
		 * is_router flag. Otherwise, if the entry is newly created,
		 * clear the flag. [RFC 2461, sec 8.3]
d1627 1
a1627 1
		else if (is_newentry) /*(6-7)*/
d1640 2
a1641 2
		if ((!is_newentry && (olladdr || lladdr))	/*(2-5)*/
		 || (is_newentry && lladdr)) {			/*(7)*/
d1734 1
a1734 1
	 * next hop determination. This routine is derived from ether_outpout.
d1757 2
a1758 3
			 * of view, regardless the value of the
			 * nd_ifinfo.flags.
			 * The second condition is a bit tricky: we skip
d1799 1
a1799 1
		 * the condition below is not very efficient. But we believe
d1841 1
a1841 1
	 * (i.e. its link-layer address is already reloved), just
d1849 1
a1849 1
	 * response yet. Replace the held mbuf (if any) with this
@


1.37
log
@call defrouter_select() only if i am autoconfigured host
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.36 2001/06/27 17:51:39 itojun Exp $	*/
a933 95
#ifdef OLDIP6OUTPUT
/*
 * Resolve an IP6 address into an ethernet address. If success,
 * desten is filled in. If there is no entry in ndptab,
 * set one up and multicast a solicitation for the IP6 address.
 * Hold onto this mbuf and resend it once the address
 * is finally resolved. A return value of 1 indicates
 * that desten has been filled in and the packet should be sent
 * normally; a 0 return indicates that the packet has been
 * taken over here, either now or for later transmission.
 */
int
nd6_resolve(ifp, rt, m, dst, desten)
	struct ifnet *ifp;
	struct rtentry *rt;
	struct mbuf *m;
	struct sockaddr *dst;
	u_char *desten;
{
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)NULL;
	struct sockaddr_dl *sdl;
	long time_second = time.tv_sec;

	if (m->m_flags & M_MCAST) {
		switch (ifp->if_type) {
		case IFT_ETHER:
		case IFT_FDDI:			
			ETHER_MAP_IPV6_MULTICAST(&SIN6(dst)->sin6_addr,
						 desten);
			return(1);
			break;
		case IFT_ARCNET:
			*desten = 0;
			return(1);
		default:
			m_freem(m);
			return(0);
		}
	}
	if (rt && (rt->rt_flags & RTF_LLINFO) != 0)
		ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	else {
		if ((rt = nd6_lookup(&(SIN6(dst)->sin6_addr), 1, ifp)) != NULL)
			ln = (struct llinfo_nd6 *)rt->rt_llinfo;
	}
	if (!ln || !rt) {
		log(LOG_DEBUG, "nd6_resolve: can't allocate llinfo for %s\n",
			ip6_sprintf(&(SIN6(dst)->sin6_addr)));
		m_freem(m);
		return(0);
	}
	sdl = SDL(rt->rt_gateway);
	/*
	 * Ckeck the address family and length is valid, the address
	 * is resolved; otherwise, try to resolve.
	 */
	if (ln->ln_state >= ND6_LLINFO_REACHABLE
	   && sdl->sdl_family == AF_LINK
	   && sdl->sdl_alen != 0) {
		bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
		if (ln->ln_state == ND6_LLINFO_STALE) {
			ln->ln_asked = 0;
			ln->ln_state = ND6_LLINFO_DELAY;
			ln->ln_expire = time_second + nd6_delay;
		}
		return(1);
	}
	/*
	 * There is an ndp entry, but no ethernet address
	 * response yet. Replace the held mbuf with this
	 * latest one.
	 *
	 * XXX Does the code conform to rate-limiting rule?
	 * (RFC 2461 7.2.2)
	 */
	if (ln->ln_state == ND6_LLINFO_NOSTATE)
		ln->ln_state = ND6_LLINFO_INCOMPLETE;
	if (ln->ln_hold)
		m_freem(ln->ln_hold);
	ln->ln_hold = m;
	if (ln->ln_expire) {
		if (ln->ln_asked < nd6_mmaxtries &&
		    ln->ln_expire < time_second) {
			ln->ln_asked++;
			ln->ln_expire = time_second +
				nd_ifinfo[ifp->if_index].retrans / 1000;
			nd6_ns_output(ifp, NULL, &(SIN6(dst)->sin6_addr),
				ln, 0);
		}
	}
	/* do not free mbuf here, it is queued into llinfo_nd6 */
	return(0);
}
#endif /* OLDIP6OUTPUT */

a1566 7
#ifdef OLDIP6OUTPUT
				ln->ln_asked = 0;
				ln->ln_state = ND6_LLINFO_DELAY;
				ln->ln_expire = time_second + nd6_delay;
				(*ifp->if_output)(ifp, ln->ln_hold,
						  rt_key(rt), rt);
#else
a1573 1
#endif
@


1.36
log
@do not try to update ipv6 default route if i'm not an autoconfigured host,
on nd6_detach (= interface removal).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.35 2001/06/22 14:12:36 itojun Exp $	*/
d1762 1
a1762 1
	if (do_update && ln->ln_router)
@


1.35
log
@re-select default router on linklayer addrss changes.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.34 2001/06/09 06:43:38 angelos Exp $	*/
d621 6
a626 4
	/* refresh default router list */
	bzero(&drany, sizeof(drany));
	defrouter_delreq(&drany, 0);
	defrouter_select();
@


1.34
log
@No need for net/net_osdep.h
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.33 2001/05/29 01:08:15 angelos Exp $	*/
/*	$KAME: nd6.c,v 1.137 2001/03/21 21:52:06 jinmei Exp $	*/
d1747 15
@


1.33
log
@Verify that packets that haven't had crypto applied to them don't make
it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.32 2001/03/30 11:09:03 itojun Exp $	*/
a73 2
#include <net/net_osdep.h>

d731 1
a731 1
			    ip6_sprintf(addr6), ifp ? if_name(ifp) : "unspec");
d1117 1
a1117 1
				    if_name(ifp));
@


1.32
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.31 2001/03/21 21:57:10 itojun Exp $	*/
d65 1
d1797 3
d1961 7
d1970 9
d1982 9
@


1.31
log
@in nd6_cache_lladdr(), set nd6_gctimer to ln_expire just after the state
transition to STALE.  fixes tahi test breakage.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.30 2001/03/08 09:03:06 itojun Exp $	*/
a1957 1
#ifdef FAKE_LOOPBACK_IF
a1961 1
#endif
@


1.30
log
@make nd6_storelladdr()'s behavior consistent about mbuf freeing on errors.
do not touch static ND entry on ND cache entry updates.
couple of costmetic sync.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.29 2001/02/23 08:01:14 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.136 2001/03/06 12:26:07 itojun Exp $	*/
d1652 8
d1662 3
d1676 1
a1676 1
				ln->ln_hold = 0;
a1677 1
			ln->ln_expire = time_second + nd6_gctimer;
@


1.29
log
@garbage-collect stale ND entries (default: 1 day).
RFC 2461 5.3.  sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.28 2001/02/23 06:40:20 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.131 2001/02/21 16:28:18 itojun Exp $	*/
d519 1
a519 1
	/* expire */
d877 1
a877 1
	return next;
a966 1
			break;
d968 1
d1023 1
d1069 1
a1069 1
				/* cludge for desktops */
d1117 2
a1118 1
				    "nd6_rtrequest: bad gateway value\n");
d1578 4
a1581 1
	} else
d1583 1
d1949 1
a1949 1
	if (ifp->if_flags & IFF_LOOPBACK) {
d1985 1
d1992 1
d1997 1
d2004 1
@


1.28
log
@remove unnecessary state, ND6_LLINFO_WAITDELETE, from neighbor cache
state machine.
no need for RTF_REJECT on neighbor cache entires, they are leftover from
ARP code.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.27 2001/02/21 17:22:05 itojun Exp $	*/
d87 1
d478 8
d487 1
a487 1
				ln->ln_state = ND6_LLINFO_STALE;
d489 1
a489 4
		/*
		 * ND6_LLINFO_STALE state requires nothing for timer
		 * routine.
		 */
d500 1
a500 1
			} else
d502 2
d1661 1
d1890 1
a1890 1
	    ln->ln_state < ND6_LLINFO_REACHABLE)
d1892 2
@


1.27
log
@make validation code more strict for ND6/dest6 variable length headers.
check duplicated nd6_ifinfo table initialization in a better way.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.26 2001/02/16 16:00:00 itojun Exp $	*/
a506 3
		case ND6_LLINFO_WAITDELETE:
			next = nd6_free(rt);
			break;
a639 23

	/*
	 * Neighbor cache entry for interface route will be retained
	 * with ND6_LLINFO_WAITDELETE state, by nd6_free().  Nuke it.
	 */
	ln = llinfo_nd6.ln_next;
	while (ln && ln != &llinfo_nd6) {
		struct rtentry *rt;
		struct sockaddr_dl *sdl;

		nln = ln->ln_next;
		rt = ln->ln_rt;
		if (rt && rt->rt_gateway &&
		    rt->rt_gateway->sa_family == AF_LINK) {
			sdl = (struct sockaddr_dl *)rt->rt_gateway;
			if (sdl->sdl_index == ifp->if_index) {
				rtrequest(RTM_DELETE, rt_key(rt),
				    (struct sockaddr *)0, rt_mask(rt), 0,
				    (struct rtentry **)0);
			}
		}
		ln = nln;
	}
a795 1
	struct sockaddr_dl *sdl;
a852 9
	if (rt->rt_refcnt > 0 && (sdl = SDL(rt->rt_gateway)) &&
	    sdl->sdl_family == AF_LINK) {
		sdl->sdl_alen = 0;
		ln->ln_state = ND6_LLINFO_WAITDELETE;
		ln->ln_asked = 0;
		rt->rt_flags &= ~RTF_REJECT;
		return ln->ln_next;
	}

d1000 1
a1000 2
	if (ln->ln_state == ND6_LLINFO_WAITDELETE ||
	    ln->ln_state == ND6_LLINFO_NOSTATE)
a1005 1
		rt->rt_flags &= ~RTF_REJECT;
a1637 1
			rt->rt_flags &= ~RTF_REJECT;
a1823 3
				if (rt->rt_flags & RTF_REJECT)
					senderr(EHOSTDOWN);

a1843 2
		if (rt->rt_flags & RTF_REJECT)
			senderr(rt == rt0 ? EHOSTDOWN : EHOSTUNREACH);
d1913 1
a1913 2
	if (ln->ln_state == ND6_LLINFO_WAITDELETE ||
	    ln->ln_state == ND6_LLINFO_NOSTATE)
a1918 1
		rt->rt_flags &= ~RTF_REJECT;
@


1.26
log
@cosmetic sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.25 2001/02/16 08:48:06 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.126 2001/02/16 12:49:45 itojun Exp $	*/
d172 8
a179 2
	/* don't initialize if called twice */
	if (ND.linkmtu)
d284 6
d301 6
a306 1
	if (!(ndopts->nd_opts_search < ndopts->nd_opts_last)) {
d353 3
a355 2
				printf("duplicated ND6 option found "
					"(type=%d)\n", nd_opt->nd_opt_type);
@


1.25
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.24 2001/02/08 15:07:27 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.114 2001/02/08 10:57:00 itojun Exp $	*/
d1800 1
a1800 1
	 * draft-ietf-ngtrans-mech-06.txt says:
d1837 1
a1837 1
			 * of view, regardless the value of the value of
@


1.24
log
@when chasing nd6_llinfo chain, make sure we do not touch dangling
pointer (due to RTM_DELETE during default router list management).
from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.23 2001/02/08 14:51:22 itojun Exp $	*/
d199 13
a211 13
	switch(ifp->if_type) {
	 case IFT_ARCNET:	/* XXX MTU handling needs more work */
		 ndi->maxmtu = MIN(60480, ifp->if_mtu);
		 break;
	 case IFT_ETHER:
		 ndi->maxmtu = MIN(ETHERMTU, ifp->if_mtu);
		 break;
	 case IFT_ATM:
		 ndi->maxmtu = MIN(ATMMTU, ifp->if_mtu);
		 break;
	 default:
		 ndi->maxmtu = ifp->if_mtu;
		 break;
d1101 1
a1101 1
		 *   note that the mechanism need a mutual agreement
d1103 2
a1104 2
		 *   a new protocol, or new kludge.
		 * - from RFC2461 6.2.4, host MUST NOT send unsolicited NA.
@


1.23
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.22 2001/02/07 11:43:54 itojun Exp $	*/
d455 1
a455 1
				nd6_free(rt);
d486 2
a487 3
			} else {
				nd6_free(rt);
			}
d490 1
a490 1
			nd6_free(rt);
d621 1
a621 1
				nd6_free(rt);
d799 1
a799 1
void
d803 1
a803 1
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo;
d868 1
a868 1
		return;
d871 13
d886 2
d1595 1
a1595 1
		nd6_free(rt);
@


1.22
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.21 2001/02/06 00:22:23 mickey Exp $	*/
/*	$KAME: nd6.c,v 1.110 2001/02/06 09:14:38 jinmei Exp $	*/
d43 1
d113 4
d139 2
a140 1
	timeout(nd6_slowtimo, (caddr_t)0, ND6_SLOWTIMER_INTERVAL * hz);
d385 3
a387 3
	register struct llinfo_nd6 *ln;
	register struct nd_defrouter *dr;
	register struct nd_prefix *pr;
d392 2
a393 1
	timeout(nd6_timer, (caddr_t)0, nd6_prune * hz);
d750 1
a750 1
	register struct ifaddr *ifa;
d1739 2
a1740 2
	register int i;
	register struct nd_ifinfo *nd6if;
d1742 2
a1743 1
	timeout(nd6_slowtimo, (caddr_t)0, ND6_SLOWTIMER_INTERVAL * hz);
d1766 1
a1766 1
	register struct ifnet *ifp;
d1772 2
a1773 2
	register struct mbuf *m = m0;
	register struct rtentry *rt = rt0;
@


1.21
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.20 2001/01/19 06:37:38 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.75 2000/10/15 15:23:11 itojun Exp $	*/
d92 6
d316 1
d351 1
a351 1
			log(LOG_DEBUG,
d353 1
a353 1
			    "option ignored\n", nd_opt->nd_opt_type);
d360 1
a360 1
			printf("too many loop in nd opt\n");
@


1.20
log
@pull post-4.4BSD change to sys/net/route.c from BSD/OS 4.2 (UCB copyrighted).

have sys/net/route.c:rtrequest1(), which takes rt_addrinfo * as the argument.
pass rt_addrinfo all the way down to rtrequest, and ifa->ifa_rtrequest.
3rd arg of ifa->ifa_rtrequest is now rt_addrinfo * instead of sockaddr *
(almost noone is using it anyways).

benefit: the follwoing command now works.  previously we need two route(8)
invocations, "add" then "change".
# route add -inet6 default ::1 -ifp gif0

remove unsafe typecast in rtrequest(), from rtentry * to sockaddr *.  it was
introduced by 4.3BSD-reno and never corrected.

XXX is eon_rtrequest() change correct regarding to 3rd arg?
eon_rtrequest() and rtrequest() were incorrect since 4.3BSD-reno,
so i do not have correct answer in the source code.
someone with more clue about netiso-over-ip, please help.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.19 2000/10/15 15:55:03 itojun Exp $	*/
a71 4
#include "loop.h"

extern struct ifnet loif[NLOOP];

d1161 1
a1161 1
				rt->rt_ifp = &loif[0];	/*XXX*/
d1285 1
a1285 1
				rt->rt_ifp = &loif[0];	/*XXX*/
@


1.19
log
@suppress warning on routing table overflow.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.18 2000/07/06 10:11:26 itojun Exp $	*/
d1016 1
a1016 1
nd6_rtrequest(req, rt, sa)
d1019 1
a1019 1
	struct sockaddr *sa; /* xxx unused */
d1238 1
a1238 1
nd6_p2p_rtrequest(req, rt, sa)
d1241 1
a1241 1
	struct sockaddr *sa; /* xxx unused */
@


1.18
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.17 2000/06/16 21:47:17 provos Exp $	*/
/*	$KAME: nd6.c,v 1.68 2000/07/02 14:48:02 itojun Exp $	*/
d1975 5
a1979 2
	if (rt == NULL ||
	    rt->rt_gateway->sa_family != AF_LINK) {
@


1.17
log
@take MIN/MAX from param.h, okay theo@@
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.16 2000/05/19 13:55:17 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.63 2000/05/17 12:35:59 jinmei Exp $	*/
d94 2
d225 1
a225 2
			}
			else
d466 1
a466 2
			}
			else
d707 1
a707 2
		}
		else
d872 1
a872 1
nd6_nud_hint(rt, dst6)
d875 1
d891 4
a894 5
	if ((rt->rt_flags & RTF_GATEWAY)
	 || (rt->rt_flags & RTF_LLINFO) == 0
	 || !rt->rt_llinfo
	 || !rt->rt_gateway
	 || rt->rt_gateway->sa_family != AF_LINK) {
d903 10
d1134 1
d1159 1
d1183 1
d1323 1
a1323 2
			}
			else
d1368 1
a1368 2
					}
					else
@


1.16
log
@never forward packet with link-local address.
experimental support for new loopback packet handling (with FAKE_LOOPBACK_IF,
rcvif will be set to real outgoing interface, not the loopback, to honor scope)
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.15 2000/05/15 11:45:35 itojun Exp $	*/
a184 1
#define MIN(a,b) ((a) < (b) ? (a) : (b))
@


1.15
log
@perform NUD on p2p link, only if the destination/gateway is real neighbor.
this removes temporary workaround (no NUD on p2p link).  KAME PR 245.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.14 2000/05/15 11:29:14 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.62 2000/05/09 11:35:55 itojun Exp $	*/
d1631 5
a1635 1
				nd6_output(ifp, ln->ln_hold,
d1745 1
a1745 1
nd6_output(ifp, m0, dst, rt0)
d1747 1
d1788 5
a1792 2
				if (rt->rt_ifp != ifp)
					return nd6_output(ifp, m0, dst, rt); /* XXX: loop care? */
d1924 7
@


1.14
log
@use IFAFREE, not ifa_refcnt--.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.13 2000/04/27 10:46:17 itojun Exp $	*/
a171 7
#if 1
	/* XXX temporary workaround */
	if (ifp->if_flags & IFF_POINTOPOINT)
		ND.flags = 0;
	else
		ND.flags = ND6_IFF_PERFORMNUD;
#else
a172 1
#endif
d739 1
a739 1
	struct in6_addr *addr;
d748 7
a754 2
	/* A link-local address is always a neighbor. */
	if (IN6_IS_ADDR_LINKLOCAL(addr))
d769 2
a770 1
			if ((IFADDR6(ifa).s6_addr32[i] ^ addr->s6_addr32[i]) &
d781 1
a781 1
	if (nd6_lookup(addr, 0, ifp))
d1749 1
d1761 1
a1761 1
	 * draft-ietf-ngtrans-mech-04.txt says:
a1773 4
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    (nd_ifinfo[ifp->if_index].flags & ND6_IFF_PERFORMNUD) == 0)
		goto sendpkt;

d1788 1
d1790 27
d1841 7
a1847 1
		if ((rt = nd6_lookup(&dst->sin6_addr, 1, ifp)) != NULL)
d1851 10
a1860 4
		log(LOG_DEBUG, "nd6_output: can't allocate llinfo for %s "
		    "(ln=%p, rt=%p)\n",
		    ip6_sprintf(&dst->sin6_addr), ln, rt);
		senderr(EIO);	/* XXX: good error? */
@


1.13
log
@disable NUD for point-to-point devices.  KAME PR 245 (temporary workaround)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.12 2000/04/19 07:38:49 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.56 2000/04/19 06:17:43 itojun Exp $	*/
d1167 1
a1167 1
					rt->rt_ifa->ifa_refcnt--;
@


1.12
log
@add boundary check for nd_ifinfo[].  (sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.11 2000/04/17 04:44:51 itojun Exp $	*/
d172 7
d180 1
@


1.11
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.10 2000/04/13 16:27:26 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.55 2000/04/16 14:08:30 itojun Exp $	*/
d98 1
a136 1
	static size_t if_indexlim = 8;
d142 1
a142 1
	if (nd_ifinfo == NULL || if_index >= if_indexlim) {
d146 2
a147 2
		while (if_index >= if_indexlim)
			if_indexlim <<= 1;
d150 1
a150 1
		n = if_indexlim * sizeof(struct nd_ifinfo);
d1393 4
d1401 4
d1715 2
@


1.10
log
@add comment on sanity check
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.9 2000/04/13 14:34:10 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.41 2000/02/24 16:34:50 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d161 5
d172 1
d348 1
a348 1
			log(LOG_INFO,
d392 2
d403 1
d414 3
d452 1
a452 1
		/* 
d457 12
a468 6
			ln->ln_asked = 1;
			ln->ln_state = ND6_LLINFO_PROBE;
			ln->ln_expire = time_second +
				nd_ifinfo[ifp->if_index].retrans / 1000;
			nd6_ns_output(ifp, &dst->sin6_addr, &dst->sin6_addr,
				ln, 0);
a469 1

d659 1
a659 1
		 * If we want to create a neighbor cache for the address, we 
d670 2
d688 1
a688 1
			 * called in rtequest via ifa->ifa_rtrequest. 
d690 7
a696 6
			if (rtrequest(RTM_ADD, (struct sockaddr *)&sin6,
				      ifa->ifa_addr,
				      (struct sockaddr *)&all1_sa,
				      (ifa->ifa_flags |
				       RTF_HOST | RTF_LLINFO) & ~RTF_CLONING,
				      &rt))
d699 2
a700 1
				    "neighbor(%s)\n", ip6_sprintf(addr6));
d735 1
a735 1
 * XXX: should take care of the destination of a p2p link? 
d1082 13
a1094 4
		if (gate->sa_family != AF_LINK ||
		    gate->sa_len < sizeof(null_sdl)) {
			log(LOG_DEBUG, "nd6_rtrequest: bad gateway value\n");
			break;
d1096 1
a1096 3
		SDL(gate)->sdl_type = ifp->if_type;
		SDL(gate)->sdl_index = ifp->if_index;
		if (ln != 0)
d1121 1
a1121 1
		        /* 
d1395 4
d1620 1
a1620 1
#endif 
d1669 1
a1669 1
		 * is_router flag. Otherwise, if the entry is newly created, 
a1670 1
		 * 
d1742 4
a1745 1
	 * other than ARCnet, Ethernet and FDDI.
d1751 1
d1757 4
d1762 1
a1762 1
	 * next hop determination. This routine is derived from ether_outpout. 
d1772 1
a1772 1
			} else 
d1810 4
d1864 1
a1864 1
	
@


1.9
log
@bark if sdl_alen == 0.  test code for KAME PR 235.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.8 2000/04/13 14:11:17 itojun Exp $	*/
d1862 1
@


1.8
log
@even if nd6_nud_hint is called, do not change a neighbor's status
unless the old status is probably reachable (i.e. the link-layer address
has already been resolved).
KAME PR 235.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.7 2000/02/28 11:55:22 itojun Exp $	*/
d1861 4
a1864 2
	if (sdl->sdl_alen != 0)
		bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
d1866 1
@


1.7
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.6 2000/02/07 06:09:10 itojun Exp $	*/
d875 1
a875 1
	if (ln->ln_state == ND6_LLINFO_INCOMPLETE)
@


1.6
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: nd6.c,v 1.5 2000/02/04 18:13:36 itojun Exp $	*/
d49 1
a89 1
int	nd6_proxyall	= 0;	/* enable Proxy Neighbor Advertisement */
d99 1
a99 1
struct nd_drhead nd_defrouter = { 0 };
a102 3
#if 0
extern	int ip6_forwarding;
#endif
d123 3
d437 1
a437 1
			if (ln->ln_expire) {
a438 1
			}
d472 1
a472 1
	dr = nd_defrouter.lh_first;
d476 1
a476 1
			t = dr->dr_next;
d480 1
a480 1
			dr = dr->dr_next;
d545 1
a545 1
	if ((dr = nd_defrouter.lh_first) != NULL) {
d550 2
a551 2
		for (dr = dr->dr_next; dr; dr = ndr) {
			ndr = dr->dr_next;
d555 1
a555 1
		dr = nd_defrouter.lh_first;
d570 4
d577 1
d771 2
d774 7
a780 4
	if (ln->ln_router) {
		/* remove from default router list */
		struct nd_defrouter *dr;
		struct in6_addr *in6;
d782 11
a792 1
		in6 = &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr;
d794 6
a799 1
		s = splnet();
a800 6
		dr = defrouter_lookup(&((struct sockaddr_in6 *)rt_key(rt))->
				      sin6_addr,
				      rt->rt_ifp);
		if (dr)
			defrtrlist_del(dr);
		else if (!ip6_forwarding && ip6_accept_rtadv) {
d802 5
a806 2
			 * rt6_flush must be called in any case.
			 * see the comment in nd6_na_input().
d808 16
a823 1
			rt6_flush(in6, rt->rt_ifp);
d827 1
a827 1
	
d829 1
a829 1
	   sdl->sdl_family == AF_LINK) {
d836 3
a838 2
	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0, rt_mask(rt),
		  0, (struct rtentry **)0);
d1005 1
a1005 1
		if (rt->rt_flags & RTF_CLONING || rt->rt_flags & RTF_LLINFO) {
d1032 20
a1051 1
		/* Announce a new entry if requested. */
d1054 5
a1058 4
				      &SIN6(rt_key(rt))->sin6_addr,
				      &SIN6(rt_key(rt))->sin6_addr,
				      ip6_forwarding ? ND_NA_FLAG_ROUTER : 0,
				      1);
d1062 1
a1062 1
		   gate->sa_len < sizeof(null_sdl)) {
d1136 21
d1163 17
d1233 1
a1233 1
				      1);
d1261 1
a1270 1

d1272 1
a1272 2

		dr = nd_defrouter.lh_first;
d1290 1
a1290 1
			dr = dr->dr_next;
d1295 5
a1300 1

a1301 1

d1337 1
a1341 1
		splx(s);
d1357 1
d1361 1
d1367 1
a1367 1
	case SIOCSNDFLUSH_IN6:
d1375 1
d1400 1
a1400 2

		if ((dr = nd_defrouter.lh_first) != NULL) {
d1405 2
a1406 2
			for (dr = dr->dr_next; dr; dr = next) {
				next = dr->dr_next;
d1409 1
a1409 1
			defrtrlist_del(nd_defrouter.lh_first);
d1447 6
@


1.6.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: nd6.c,v 1.41 2000/02/24 16:34:50 itojun Exp $	*/
a47 1
#include <sys/protosw.h>
d88 1
d98 1
a98 1
struct nd_drhead nd_defrouter;
d102 3
a124 3
	/* initialization of the default router list */
	TAILQ_INIT(&nd_defrouter);

d436 1
a436 1
			if (ln->ln_expire)
d438 1
d472 1
a472 1
	dr = TAILQ_FIRST(&nd_defrouter);
d476 1
a476 1
			t = TAILQ_NEXT(dr, dr_entry);
d480 1
a480 1
			dr = TAILQ_NEXT(dr, dr_entry);
d545 1
a545 1
	if ((dr = TAILQ_FIRST(&nd_defrouter)) != NULL) {
d550 2
a551 2
		for (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = ndr) {
			ndr = TAILQ_NEXT(dr, dr_entry);
d555 1
a555 1
		dr = TAILQ_FIRST(&nd_defrouter);
a569 4
	/* cancel default outgoing interface setting */
	if (nd6_defifindex == ifp->if_index)
		nd6_setdefaultiface(0);

a572 1
	defrouter_select();
a765 2
	struct in6_addr in6 = ((struct sockaddr_in6 *)rt_key(rt))->sin6_addr;
	struct nd_defrouter *dr;
d767 6
a772 5
	/*
	 * Clear all destination cache entries for the neighbor.
	 * XXX: is it better to restrict this to hosts?
	 */
	pfctlinput(PRC_HOSTDEAD, rt_key(rt));
a773 2
	if (!ip6_forwarding && ip6_accept_rtadv) { /* XXX: too restrictive? */
		int s;
d775 3
a777 1
		dr = defrouter_lookup(&((struct sockaddr_in6 *)rt_key(rt))->sin6_addr,
d779 3
a781 10
		if (ln->ln_router || dr) {
			/*
			 * rt6_flush must be called whether or not the neighbor
			 * is in the Default Router List.
			 * See a corresponding comment in nd6_na_input().
			 */
			rt6_flush(&in6, rt->rt_ifp);
		}

		if (dr) {
d783 2
a784 3
			 * Unreachablity of a router might affect the default
			 * router selection and on-link detection of advertised
			 * prefixes.
d786 1
a786 24

			/*
			 * Temporarily fake the state to choose a new default
			 * router and to perform on-link determination of
			 * prefixes coreectly.
			 * Below the state will be set correctly,
			 * or the entry itself will be deleted.
			 */
			ln->ln_state = ND6_LLINFO_INCOMPLETE;

			if (dr == TAILQ_FIRST(&nd_defrouter)) {
				/*
				 * It is used as the current default router,
				 * so we have to move it to the end of the
				 * list and choose a new one.
				 * XXX: it is not very efficient if this is
				 *      the only router.
				 */
				TAILQ_REMOVE(&nd_defrouter, dr, dr_entry);
				TAILQ_INSERT_TAIL(&nd_defrouter, dr, dr_entry);

				defrouter_select();
			}
			pfxlist_onlink_check();
d790 1
a790 1

d792 1
a792 1
	    sdl->sdl_family == AF_LINK) {
d799 2
a800 3

	rtrequest(RTM_DELETE, rt_key(rt), (struct sockaddr *)0,
		  rt_mask(rt), 0, (struct rtentry **)0);
d967 1
a967 1
		if (rt->rt_flags & (RTF_CLONING | RTF_LLINFO)) {
d994 1
a994 20
		/*
		 * In IPv4 code, we try to annonuce new RTF_ANNOUNCE entry here.
		 * We don't do that here since llinfo is not ready yet.
		 *
		 * There are also couple of other things to be discussed:
		 * - unsolicited NA code needs improvement beforehand
		 * - RFC2461 says we MAY send multicast unsolicited NA
		 *   (7.2.6 paragraph 4), however, it also says that we
		 *   SHOULD provide a mechanism to prevent multicast NA storm.
		 *   we don't have anything like it right now.
		 *   note that the mechanism need a mutual agreement
		 *   between proxies, which means that we need to implement
		 *   a new protocol, or new kludge.
		 * - from RFC2461 6.2.4, host MUST NOT send unsolicited NA.
		 *   we need to check ip6forwarding before sending it.
		 *   (or should we allow proxy ND configuration only for
		 *   routers?  there's no mention about proxy ND from hosts)
		 */
#if 0
		/* XXX it does not work */
d997 4
a1000 5
			      &SIN6(rt_key(rt))->sin6_addr,
			      &SIN6(rt_key(rt))->sin6_addr,
			      ip6_forwarding ? ND_NA_FLAG_ROUTER : 0,
			      1, NULL);
#endif
d1004 1
a1004 1
		    gate->sa_len < sizeof(null_sdl)) {
a1077 21
		} else if (rt->rt_flags & RTF_ANNOUNCE) {
			ln->ln_expire = 0;
			ln->ln_state = ND6_LLINFO_REACHABLE;

			/* join solicited node multicast for proxy ND */
			if (ifp->if_flags & IFF_MULTICAST) {
				struct in6_addr llsol;
				int error;

				llsol = SIN6(rt_key(rt))->sin6_addr;
				llsol.s6_addr16[0] = htons(0xff02);
				llsol.s6_addr16[1] = htons(ifp->if_index);
				llsol.s6_addr32[1] = 0;
				llsol.s6_addr32[2] = htonl(1);
				llsol.s6_addr8[12] = 0xff;

				(void)in6_addmulti(&llsol, ifp, &error);
				if (error)
					printf(
"nd6_rtrequest: could not join solicited node multicast (errno=%d)\n", error);
			}
a1083 17
		/* leave from solicited node multicast for proxy ND */
		if ((rt->rt_flags & RTF_ANNOUNCE) != 0 &&
		    (ifp->if_flags & IFF_MULTICAST) != 0) {
			struct in6_addr llsol;
			struct in6_multi *in6m;

			llsol = SIN6(rt_key(rt))->sin6_addr;
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr8[12] = 0xff;

			IN6_LOOKUP_MULTI(llsol, ifp, in6m);
			if (in6m)
				in6_delmulti(in6m);
		}
d1137 1
a1137 1
				      1, NULL);
a1164 1
	struct in6_ndifreq *ndif = (struct in6_ndifreq *)data;
d1174 1
d1176 2
a1177 1
		dr = TAILQ_FIRST(&nd_defrouter);
d1195 1
a1195 1
			dr = TAILQ_NEXT(dr, dr_entry);
a1199 5
		/*
		 * XXX meaning of fields, especialy "raflags", is very
		 * differnet between RA prefix list and RR/static prefix list.
		 * how about separating ioctls into two?
		 */
d1201 1
d1203 1
a1238 1
			prl->prefix[i].origin = PR_ORIG_RA;
d1243 1
a1258 1
			prl->prefix[i].origin = rpp->rp_origin;
a1261 1
		splx(s);
d1267 1
a1267 1
	case SIOCSNDFLUSH_IN6:	/* XXX: the ioctl name is confusing... */
a1274 1
		defrouter_select();
d1299 2
a1300 1
		if ((dr = TAILQ_FIRST(&nd_defrouter)) != NULL) {
d1305 2
a1306 2
			for (dr = TAILQ_NEXT(dr, dr_entry); dr; dr = next) {
				next = TAILQ_NEXT(dr, dr_entry);
d1309 1
a1309 1
			defrtrlist_del(TAILQ_FIRST(&nd_defrouter));
a1346 6
	case SIOCGDEFIFACE_IN6:	/* XXX: should be implemented as a sysctl? */
		ndif->ifindex = nd6_defifindex;
		break;
	case SIOCSDEFIFACE_IN6:	/* XXX: should be implemented as a sysctl? */
		return(nd6_setdefaultiface(ndif->ifindex));
		break;
@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6.c,v 1.32 2001/03/30 11:09:03 itojun Exp $	*/
/*	$KAME: nd6.c,v 1.137 2001/03/21 21:52:06 jinmei Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a42 1
#include <sys/timeout.h>
d72 4
a89 1
int	nd6_gctimer	= (60 * 60 * 24); /* 1 day: garbage collection timer */
a93 8
int nd6_maxnudhint = 0;	/* max # of subsequent upper layer hints */

#ifdef ND6_DEBUG
int nd6_debug = 1;
#else
int nd6_debug = 0;
#endif

a97 1
static size_t nd_ifinfo_indexlim = 8;
a106 4
struct timeout nd6_slowtimo_ch;
struct timeout nd6_timer_ch;
extern struct timeout in6_tmpaddrtimer_ch;

d129 1
a129 2
	timeout_set(&nd6_slowtimo_ch, nd6_slowtimo, NULL);
	timeout_add(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL * hz);
d136 1
d142 1
a142 1
	if (nd_ifinfo == NULL || if_index >= nd_ifinfo_indexlim) {
d146 2
a147 2
		while (if_index >= nd_ifinfo_indexlim)
			nd_ifinfo_indexlim <<= 1;
d150 1
a150 1
		n = nd_ifinfo_indexlim * sizeof(struct nd_ifinfo);
a160 11

	/*
	 * Don't initialize if called twice.
	 * XXX: to detect this, we should choose a member that is never set
	 * before initialization of the ND structure itself.  We formaly used
	 * the linkmtu member, which was not suitable because it could be 
	 * initialized via "ifconfig mtu".
	 */
	if (ND.basereachable)
		return;

a166 1
	ND.flags = ND6_IFF_PERFORMNUD;
d179 1
d184 13
a196 13
	switch (ifp->if_type) {
	case IFT_ARCNET:	/* XXX MTU handling needs more work */
		ndi->maxmtu = MIN(60480, ifp->if_mtu);
		break;
	case IFT_ETHER:
		ndi->maxmtu = MIN(ETHERMTU, ifp->if_mtu);
		break;
	case IFT_ATM:
		ndi->maxmtu = MIN(ATMMTU, ifp->if_mtu);
		break;
	default:
		ndi->maxmtu = ifp->if_mtu;
		break;
d218 2
a219 1
			} else
a263 6
	/* make sure nd_opt_len is inside the buffer */
	if ((caddr_t)&nd_opt->nd_opt_len >= (caddr_t)ndopts->nd_opts_last) {
		bzero(ndopts, sizeof(*ndopts));
		return NULL;
	}

d275 1
a275 6
	if (ndopts->nd_opts_search > ndopts->nd_opts_last) {
		/* option overruns the end of buffer, invalid */
		bzero(ndopts, sizeof(*ndopts));
		return NULL;
	} else if (ndopts->nd_opts_search == ndopts->nd_opts_last) {
		/* reached the end of options chain */
a307 1
			icmp6stat.icp6s_nd_badopt++;
d321 2
a322 3
				nd6log((LOG_INFO,
				    "duplicated ND6 option found (type=%d)\n",
				    nd_opt->nd_opt_type));
d342 1
a342 1
			nd6log((LOG_DEBUG,
d344 1
a344 1
			    "option ignored\n", nd_opt->nd_opt_type));
d351 1
a351 1
			nd6log((LOG_INFO, "too many loop in nd opt\n"));
d370 3
a372 3
	struct llinfo_nd6 *ln;
	struct nd_defrouter *dr;
	struct nd_prefix *pr;
d377 1
a377 2
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add(&nd6_timer_ch, nd6_prune * hz);
a385 2
		/* XXX: used for the DELAY case only: */
		struct nd_ifinfo *ndi = NULL;
a394 1
		ndi = &nd_ifinfo[ifp->if_index];
a404 3
		if (rt->rt_llinfo && (struct llinfo_nd6 *)rt->rt_llinfo != ln)
			panic("rt_llinfo(%p) is not equal to ln(%p)\n",
			      rt->rt_llinfo, ln);
d433 1
a433 1
				next = nd6_free(rt);
d437 1
a437 1
			if (ln->ln_expire) {
a438 2
				ln->ln_expire = time_second + nd6_gctimer;
			}
d440 11
a450 5

		case ND6_LLINFO_STALE:
			/* Garbage Collection(RFC 2461 5.3) */
			if (ln->ln_expire)
				next = nd6_free(rt);
a452 15
		case ND6_LLINFO_DELAY:
			if (ndi && (ndi->flags & ND6_IFF_PERFORMNUD) != 0) {
				/* We need NUD */
				ln->ln_asked = 1;
				ln->ln_state = ND6_LLINFO_PROBE;
				ln->ln_expire = time_second +
					ndi->retrans / 1000;
				nd6_ns_output(ifp, &dst->sin6_addr,
					      &dst->sin6_addr,
					      ln, 0);
			} else {
				ln->ln_state = ND6_LLINFO_STALE; /* XXX */
				ln->ln_expire = time_second + nd6_gctimer;
			}
			break;
d460 6
a465 2
			} else
				next = nd6_free(rt);
d471 1
a471 1
	/* expire default router list */
d596 24
a619 1
				nln = nd6_free(rt);
d642 1
a642 1
		 * If we want to create a neighbor cache for the address, we
a652 2
			int e;

d669 1
a669 1
			 * called in rtequest via ifa->ifa_rtrequest.
d671 6
a676 7
			if ((e = rtrequest(RTM_ADD, (struct sockaddr *)&sin6,
					   ifa->ifa_addr,
					   (struct sockaddr *)&all1_sa,
					   (ifa->ifa_flags |
					    RTF_HOST | RTF_LLINFO) &
					   ~RTF_CLONING,
					   &rt)) != 0)
d679 1
a679 2
				    "neighbor(%s), errno=%d\n",
				    ip6_sprintf(addr6), e);
d687 2
a688 1
		} else
d714 1
a714 1
 * XXX: should take care of the destination of a p2p link?
d718 1
a718 1
	struct sockaddr_in6 *addr;
d721 1
a721 1
	struct ifaddr *ifa;
d727 2
a728 7
	/*
	 * A link-local address is always a neighbor.
	 * XXX: we should use the sin6_scope_id field rather than the embedded
	 * interface index.
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&addr->sin6_addr) &&
	    ntohs(*(u_int16_t *)&addr->sin6_addr.s6_addr[2]) == ifp->if_index)
d743 1
a743 2
			if ((IFADDR6(ifa).s6_addr32[i] ^
			     addr->sin6_addr.s6_addr32[i]) &
d754 1
a754 1
	if (nd6_lookup(&addr->sin6_addr, 0, ifp))
d765 1
a765 1
struct llinfo_nd6 *
d769 2
a770 1
	struct llinfo_nd6 *ln = (struct llinfo_nd6 *)rt->rt_llinfo, *next;
d828 8
a835 7
	/*
	 * Before deleting the entry, remember the next entry as the
	 * return value.  We need this because pfxlist_onlink_check() above
	 * might have freed other entries (particularly the old next entry) as
	 * a side effect (XXX). 
	 */
	next = ln->ln_next;
a836 5
	/*
	 * Detach the route from the routing tree and the list of neighbor
	 * caches, and disable the route entry not to be used in already
	 * cached routes.
	 */
a838 2

	return(next);
d847 1
a847 1
nd6_nud_hint(rt, dst6, force)
a849 1
	int force;
d865 5
a869 4
	if ((rt->rt_flags & RTF_GATEWAY) != 0 ||
	    (rt->rt_flags & RTF_LLINFO) == 0 ||
	    !rt->rt_llinfo || !rt->rt_gateway ||
	    rt->rt_gateway->sa_family != AF_LINK) {
d875 1
a875 1
	if (ln->ln_state < ND6_LLINFO_REACHABLE)
a877 10
	/*
	 * if we get upper-layer reachability confirmation many times,
	 * it is possible we have false information.
	 */
	if (!force) {
		ln->ln_byhint++;
		if (ln->ln_byhint > nd6_maxnudhint)
			return;
	}

d918 1
a919 1
			m_freem(m);
d959 2
a960 1
	if (ln->ln_state == ND6_LLINFO_NOSTATE)
d966 1
a975 1
	/* do not free mbuf here, it is queued into llinfo_nd6 */
d981 1
a981 1
nd6_rtrequest(req, rt, info)
d984 1
a984 1
	struct rt_addrinfo *info; /* xxx unused */
d1021 1
a1021 1
				/* kludge for desktops */
d1042 1
a1042 1
		 *   note that the mechanism needs a mutual agreement
d1044 2
a1045 2
		 *   a new protocol, or a new kludge.
		 * - from RFC2461 6.2.4, host MUST NOT send an unsolicited NA.
d1061 4
a1064 14
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0) {
			/*
			 * Address resolution isn't necessary for a point to
			 * point link, so we can skip this test for a p2p link.
			 */
			if (gate->sa_family != AF_LINK ||
			    gate->sa_len < sizeof(null_sdl)) {
				log(LOG_DEBUG,
				    "nd6_rtrequest: bad gateway value: %s\n",
				    if_name(ifp));
				break;
			}
			SDL(gate)->sdl_type = ifp->if_type;
			SDL(gate)->sdl_index = ifp->if_index;
d1066 3
a1068 1
		if (ln != NULL)
a1091 1
			ln->ln_byhint = 0;
d1093 1
a1093 1
		        /*
a1115 1
			ln->ln_byhint = 0;
d1121 1
a1121 1
				rt->rt_ifp = lo0ifp;	/*XXX*/
d1131 1
a1131 1
					IFAFREE(rt->rt_ifa);
a1138 1
			ln->ln_byhint = 0;
d1193 1
a1193 1
nd6_p2p_rtrequest(req, rt, info)
d1196 1
a1196 1
	struct rt_addrinfo *info; /* xxx unused */
d1244 1
a1244 1
				rt->rt_ifp = lo0ifp;	/*XXX*/
d1278 2
a1279 1
			} else
d1324 2
a1325 1
					} else
a1364 4
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim) {
			error = EINVAL;
			break;
		}
a1366 8
	case SIOCSIFINFO_FLAGS:
		/* XXX: almost all other fields of ndi->ndi is unused */
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim) {
			error = EINVAL;
			break;
		}
		nd_ifinfo[ifp->if_index].flags = ndi->ndi.flags;
		break;
d1509 1
a1509 4
	} else {
		/* do nothing if static ndp is set */
		if (rt->rt_flags & RTF_STATIC)
			return NULL;
a1510 1
	}
d1516 1
a1516 1
		(void)nd6_free(rt);
d1579 1
a1579 8
			/*
			 * XXX: since nd6_output() below will cause
			 * state tansition to DELAY and reset the timer,
			 * we must set the timer now, although it is actually
			 * meaningless.
			 */
			ln->ln_expire = time_second + nd6_gctimer;

a1581 3
				ln->ln_asked = 0;
				ln->ln_state = ND6_LLINFO_DELAY;
				ln->ln_expire = time_second + nd6_delay;
d1585 1
a1585 5
				/*
				 * we assume ifp is not a p2p here, so just
				 * set the 2nd argument as the 1st one.
				 */
				nd6_output(ifp, ifp, ln->ln_hold,
d1588 2
a1589 2
#endif
				ln->ln_hold = NULL;
d1637 1
a1637 1
		 * is_router flag. Otherwise, if the entry is newly created,
d1639 1
d1671 2
a1672 2
	int i;
	struct nd_ifinfo *nd6if;
d1674 1
a1674 2
	timeout_set(&nd6_slowtimo_ch, nd6_slowtimo, NULL);
	timeout_add(&nd6_slowtimo_ch, ND6_SLOWTIMER_INTERVAL * hz);
a1675 2
		if (!nd_ifinfo || i >= nd_ifinfo_indexlim)
			continue;
d1694 2
a1695 3
nd6_output(ifp, origifp, m0, dst, rt0)
	struct ifnet *ifp;
	struct ifnet *origifp;
d1700 2
a1701 3
	struct mbuf *m = m0;
	struct rtentry *rt = rt0;
	struct sockaddr_in6 *gw6 = NULL;
d1711 1
a1711 4
	 * other than ARCnet, Ethernet, FDDI and GIF.
	 *
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
a1716 1
	case IFT_GIF:		/* XXX need more cases? */
d1723 1
a1723 1
	 * next hop determination. This routine is derived from ether_outpout.
d1731 3
a1733 6
				if (rt->rt_ifp != ifp) {
					/* XXX: loop care? */
					return nd6_output(ifp, origifp, m0,
							  dst, rt);
				}
			} else
a1735 1

a1736 24
			gw6 = (struct sockaddr_in6 *)rt->rt_gateway;

			/*
			 * We skip link-layer address resolution and NUD
			 * if the gateway is not a neighbor from ND point
			 * of view, regardless the value of the
			 * nd_ifinfo.flags.
			 * The second condition is a bit tricky: we skip
			 * if the gateway is our own address, which is
			 * sometimes used to install a route to a p2p link.
			 */
			if (!nd6_is_addr_neighbor(gw6, ifp) ||
			    in6ifa_ifpwithaddr(ifp, &gw6->sin6_addr)) {
				/*
				 * We allow this kind of tricky route only
				 * when the outgoing interface is p2p.
				 * XXX: we may need a more generic rule here.
				 */
				if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
					senderr(EHOSTUNREACH);

				goto sendpkt;
			}

d1746 2
d1761 1
a1761 7
		/*
		 * Since nd6_is_addr_neighbor() internally calls nd6_lookup(),
		 * the condition below is not very efficient. But we believe
		 * it is tolerable, because this should be a rare case.
		 */
		if (nd6_is_addr_neighbor(dst, ifp) &&
		    (rt = nd6_lookup(&dst->sin6_addr, 1, ifp)) != NULL)
d1765 4
a1768 17
		if ((ifp->if_flags & IFF_POINTOPOINT) == 0 &&
		    !(nd_ifinfo[ifp->if_index].flags & ND6_IFF_PERFORMNUD)) {
			log(LOG_DEBUG,
			    "nd6_output: can't allocate llinfo for %s "
			    "(ln=%p, rt=%p)\n",
			    ip6_sprintf(&dst->sin6_addr), ln, rt);
			senderr(EIO);	/* XXX: good error? */
		}

		goto sendpkt;	/* send anyway */
	}

	/* We don't have to do link-layer address resolution on a p2p link. */
	if ((ifp->if_flags & IFF_POINTOPOINT) != 0 &&
	    ln->ln_state < ND6_LLINFO_REACHABLE) {
		ln->ln_state = ND6_LLINFO_STALE;
		ln->ln_expire = time_second + nd6_gctimer;
d1771 1
d1801 2
a1802 1
	if (ln->ln_state == ND6_LLINFO_NOSTATE)
d1808 1
a1819 5

	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		return((*ifp->if_output)(origifp, m, (struct sockaddr *)dst,
					 rt));
	}
d1821 1
a1821 1

a1850 1
			m_freem(m);
d1855 2
a1856 6
	if (rt == NULL) {
		/* this could happen, if we could not allocate memory */
		m_freem(m);
		return(0);
	}
	if (rt->rt_gateway->sa_family != AF_LINK) {
a1857 1
		m_freem(m);
d1861 2
a1862 6
	if (sdl->sdl_alen == 0) {
		/* this should be impossible, but we bark here for debugging */
		printf("nd6_storelladdr: sdl_alen == 0\n");
		m_freem(m);
		return(0);
	}
a1863 1
	bcopy(LLADDR(sdl), desten, sdl->sdl_alen);
@


1.6.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: nd6.c,v 1.151 2001/06/19 14:24:41 sumikawa Exp $	*/
a64 1
#include <netinet/ip_ipsp.h>
d73 2
d622 4
a625 6
	if (!ip6_forwarding && ip6_accept_rtadv) { /* XXX: too restrictive? */
		/* refresh default router list */
		bzero(&drany, sizeof(drany));
		defrouter_delreq(&drany, 0);
		defrouter_select();
	}
d732 1
a732 1
			    ip6_sprintf(addr6), ifp ? ifp->if_xname : "unspec");
d1118 1
a1118 1
				    ifp->if_xname);
a1748 15
	/*
	 * When the link-layer address of a router changes, select the
	 * best router again.  In particular, when the neighbor entry is newly
	 * created, it might affect the selection policy.
	 * Question: can we restrict the first condition to the "is_newentry"
	 * case?
	 * XXX: when we hear an RA from a new router with the link-layer
	 * address option, defrouter_select() is called twice, since
	 * defrtrlist_update called the function as well.  However, I believe
	 * we can compromise the overhead, since it only happens the first
	 * time.
	 */
	if (do_update && ln->ln_router && !ip6_forwarding && ip6_accept_rtadv)
		defrouter_select();

a1795 3
#ifdef IPSEC
	struct m_tag *mtag;
#endif /* IPSEC */
a1956 7
#ifdef IPSEC
	/*
	 * If the packet needs outgoing IPsec crypto processing and the
	 * interface doesn't support it, drop it.
	 */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED, NULL);
#endif /* IPSEC */
a1958 9
#ifdef IPSEC
		if (mtag != NULL &&
		    (origifp->if_capabilities & IFCAP_IPSEC) == 0) {
			/* Tell IPsec to do its own crypto. */
			ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
			error = EACCES;
			goto bad;
		}
#endif /* IPSEC */
a1961 9
#ifdef IPSEC
	if (mtag != NULL &&
	    (ifp->if_capabilities & IFCAP_IPSEC) == 0) {
		/* Tell IPsec to do its own crypto. */
		ipsp_skipcrypto_unmark((struct tdb_ident *)(mtag + 1));
		error = EACCES;
		goto bad;
	}
#endif /* IPSEC */
@


1.6.2.4
log
@Merge in -current
@
text
@d934 95
d1662 7
d1676 1
@


1.6.2.5
log
@Merge in trunk
@
text
@d438 1
a438 1

d694 1
a694 1
			 * Create a new route.  RTF_LLINFO is necessary
d697 1
a697 1
			 * called in rtrequest via ifa->ifa_rtrequest.
d838 1
a838 1
			 * prefixes correctly.
d866 1
a866 1
	 * a side effect (XXX).
d962 1
a962 1
			 * a route to interface.  RTF_LLINFO flag is set
d1434 1
a1434 1
 * on reception of inbound ND6 packets.  (RS/RA/NS/redirect)
d1527 1
a1527 1
	if (lladdr) {		/* (3-5) and (7) */
d1537 2
a1538 2
		if ((!olladdr && lladdr)		/* (3) */
		 || (olladdr && lladdr && llchange)) {	/* (5) */
d1541 1
a1541 1
		} else					/* (1-2,4) */
d1545 1
a1545 1
		if (!lladdr)				/* (6) */
d1547 1
a1547 1
		else					/* (7) */
d1616 1
a1616 1
		if (is_newentry)	/* (6-7) */
d1622 2
a1623 2
		 * is_router flag.  Otherwise, if the entry is newly created,
		 * clear the flag.  [RFC 2461, sec 8.3]
d1627 1
a1627 1
		else if (is_newentry) /* (6-7) */
d1640 2
a1641 2
		if ((!is_newentry && (olladdr || lladdr))	/* (2-5) */
		 || (is_newentry && lladdr)) {			/* (7) */
d1734 1
a1734 1
	 * next hop determination.  This routine is derived from ether_outpout.
d1757 3
a1759 2
			 * of view, regardless the value of nd_ifinfo.flags.
			 * The second condition is a bit tricky; we skip
d1800 1
a1800 1
		 * the condition below is not very efficient.  But we believe
d1842 1
a1842 1
	 * (i.e. its link-layer address is already resolved), just
d1850 1
a1850 1
	 * response yet.  Replace the held mbuf (if any) with this
@


1.6.2.6
log
@Merge in -current from roughly a week ago
@
text
@d33 8
d111 1
a111 1
static void nd6_slowtimo(void *);
@


1.6.2.7
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$KAME: nd6.c,v 1.280 2002/06/08 19:52:07 itojun Exp $	*/
d52 1
a52 1
#include <net/if_fddi.h>
d63 1
d95 2
a102 1
static void nd6_setmtu0(struct ifnet *, struct nd_ifinfo *);
a103 1
static struct llinfo_nd6 *nd6_free(struct rtentry *, int);
a108 3
static int fill_drlist(void *, size_t *, size_t);
static int fill_prlist(void *, size_t *, size_t);

d135 1
a135 1
struct nd_ifinfo *
a138 4
	struct nd_ifinfo *nd;

	nd = (struct nd_ifinfo *)malloc(sizeof(*nd), M_IP6NDP, M_WAITOK);
	bzero(nd, sizeof(*nd));
a139 6
	nd->initialized = 1;

	nd->chlim = IPV6_DEFHLIM;
	nd->basereachable = REACHABLE_TIME;
	nd->reachable = ND_COMPUTE_RTIME(nd->basereachable);
	nd->retrans = RETRANS_TIMER;
d141 2
a142 3
	 * Note that the default value of ip6_accept_rtadv is 0, which means
	 * we won't accept RAs by default even if we set ND6_IFF_ACCEPT_RTADV
	 * here.
d144 6
a149 1
	nd->flags = (ND6_IFF_PERFORMNUD | ND6_IFF_ACCEPT_RTADV);
d151 10
a160 2
	/* XXX: we cannot call nd6_setmtu since ifp is not fully initialized */
	nd6_setmtu0(ifp, nd);
d162 1
a162 2
	return nd;
}
d164 9
a172 4
void
nd6_ifdetach(nd)
	struct nd_ifinfo *nd;
{
d174 9
a182 1
	free(nd, M_IP6NDP);
d185 4
d193 3
a195 11
	nd6_setmtu0(ifp, ND_IFINFO(ifp));
}

void
nd6_setmtu0(ifp, ndi)
	struct ifnet *ifp;
	struct nd_ifinfo *ndi;
{
	u_int32_t omaxmtu;

	omaxmtu = ndi->maxmtu;
d198 5
a202 2
	case IFT_ARCNET:
		ndi->maxmtu = MIN(60480, ifp->if_mtu); /* RFC2497 */
d204 2
a205 2
	case IFT_FDDI:
		ndi->maxmtu = MIN(FDDIMTU, ifp->if_mtu);
d212 22
a233 10
	/*
	 * Decreasing the interface MTU under IPV6 minimum MTU may cause
	 * undesirable situation.  We thus notify the operator of the change
	 * explicitly.  The check for omaxmtu is necessary to restrict the
	 * log to the case of changing the MTU, not initializing it.
	 */
	if (omaxmtu >= IPV6_MMTU && ndi->maxmtu < IPV6_MMTU) {
		log(LOG_NOTICE, "nd6_setmtu0: "
		    "new link MTU on %s (%lu) is too small for IPv6\n",
		    ifp->if_xname, (unsigned long)ndi->maxmtu);
d235 1
a235 3

	if (ndi->maxmtu > in6_maxmtu)
		in6_setmaxmtu(); /* check all interfaces just in case */
a243 1

d266 1
a266 1
		panic("ndopts == NULL in nd6_option");
d268 1
a268 1
		panic("uninitialized ndopts in nd6_option");
d318 1
a318 1
		panic("ndopts == NULL in nd6_options");
d320 1
a320 1
		panic("uninitialized ndopts in nd6_options");
d365 1
a365 1
			 * to accommodate future extension to the protocol.
d399 2
a400 3
	struct ifnet *ifp;
	struct in6_ifaddr *ia6, *nia6;
	struct in6_addrlifetime *lt6;
a401 1
	s = splsoftnet();
d406 1
d409 1
d423 1
a423 1
		ndi = ND_IFINFO(ifp);
d433 1
a433 1
			panic("rt=0 in nd6_timer(ln=%p)", ln);
d435 1
a435 1
			panic("rt_llinfo(%p) is not equal to ln(%p)",
d438 1
a438 1
			panic("dst=0 in nd6_timer(ln=%p)", ln);
d445 1
a445 1
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
d447 1
a447 1
				    ln, 0);
d451 10
a460 9
					/*
					 * Fake rcvif to make the ICMP error
					 * more helpful in diagnosing for the
					 * receiver.
					 * XXX: should we consider
					 * older rcvif?
					 */
					m->m_pkthdr.rcvif = rt->rt_ifp;

d465 1
a465 1
				next = nd6_free(rt, 0);
d478 1
a478 1
				next = nd6_free(rt, 1);
d487 1
a487 1
					ND6_RETRANS_SEC(ndi->retrans);
d489 2
a490 1
				    &dst->sin6_addr, ln, 0);
d500 1
a500 1
				    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
d502 3
a504 4
				    &dst->sin6_addr, ln, 0);
			} else {
				next = nd6_free(rt, 0);
			}
d509 1
a509 1

d518 1
a518 1
		} else {
a519 1
		}
d521 4
d526 15
a540 21
	/*
	 * expire interface addresses.
	 * in the past the loop was inside prefix expiry processing.
	 * However, from a stricter speci-confrmance standpoint, we should
	 * rather separate address lifetimes and prefix lifetimes.
	 */
	for (ia6 = in6_ifaddr; ia6; ia6 = nia6) {
		nia6 = ia6->ia_next;
		/* check address lifetime */
		lt6 = &ia6->ia6_lifetime;
		if (IFA6_IS_INVALID(ia6)) {
			in6_purgeaddr(&ia6->ia_ifa);
		}
		if (IFA6_IS_DEPRECATED(ia6)) {
			ia6->ia6_flags |= IN6_IFF_DEPRECATED;
		} else {
			/*
			 * A new RA might have made a deprecated address
			 * preferred.
			 */
			ia6->ia6_flags &= ~IN6_IFF_DEPRECATED;
a541 1
	}
a542 3
	/* expire prefix list */
	pr = nd_prefix.lh_first;
	while (pr) {
d547 5
d553 2
a554 2
		if (pr->ndpr_vltime != ND6_INFINITE_LIFETIME &&
		    time_second - pr->ndpr_lastupdate > pr->ndpr_vltime) {
d560 1
a560 1
			 * separate.  NEVER perform in6_purgeaddr here.
d580 1
a580 1
	struct nd_defrouter *dr, *ndr;
d583 12
a594 19
	/*
	 * Nuke default router list entries toward ifp.
	 * We defer removal of default router list entries that is installed
	 * in the routing table, in order to keep additional side effects as
	 * small as possible.
	 */
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
		if (dr->installed)
			continue;

		if (dr->ifp == ifp)
			defrtrlist_del(dr);
	}
	for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = ndr) {
		ndr = TAILQ_NEXT(dr, dr_entry);
		if (!dr->installed)
			continue;

d603 2
a604 8
			/*
			 * Previously, pr->ndpr_addr is removed as well,
			 * but I strongly believe we don't have to do it.
			 * nd6_purge() is only called from in6_ifdetach(),
			 * which removes all the associated interface addresses
			 * by itself.
			 * (jinmei@@kame.net 20010129)
			 */
d615 2
d637 1
a637 1
				nln = nd6_free(rt, 0);
a655 1

d681 1
a681 1
			    ifaof_ifpforaddr((struct sockaddr *)&sin6, ifp);
d683 1
a683 1
				return (NULL);
d692 6
a697 4
			    ifa->ifa_addr, (struct sockaddr *)&all1_sa,
			    (ifa->ifa_flags | RTF_HOST | RTF_LLINFO) &
			    ~RTF_CLONING, &rt)) != 0) {
#if 0
a701 3
#endif
				return (NULL);
			}
d703 1
a703 1
				return (NULL);
d706 1
a706 1
				    (struct llinfo_nd6 *)rt->rt_llinfo;
d710 1
a710 1
			return (NULL);
a714 4
	 * Note that the check for rt_llinfo is necessary because a cloned
	 * route from a parent route that has the L flag (e.g. the default
	 * route to a p2p interface) may have the flag, too, while the
	 * destination is not actually a neighbor.
d718 1
a718 2
	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL
	 *	interface.
d721 1
a721 1
	    rt->rt_gateway->sa_family != AF_LINK || rt->rt_llinfo == NULL ||
d724 3
a726 4
			nd6log((LOG_DEBUG,
			    "nd6_lookup: failed to lookup %s (if = %s)\n",
			    ip6_sprintf(addr6),
			    ifp ? ifp->if_xname : "unspec"));
d728 1
a728 1
		return (NULL);
d730 1
a730 1
	return (rt);
d742 5
a746 2
	struct nd_prefix *pr;
	struct rtentry *rt;
a751 1
	 * XXX: a link does not necessarily specify a single interface.
d755 1
a755 1
		return (1);
d758 2
a759 2
	 * If the address matches one of our on-link prefixes, it should be a
	 * neighbor.
d761 6
a766 3
	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		if (pr->ndpr_ifp != ifp)
			continue;
d768 7
a774 17
		if (!(pr->ndpr_stateflags & NDPRF_ONLINK))
			continue;

		if (IN6_ARE_MASKED_ADDR_EQUAL(&pr->ndpr_prefix.sin6_addr,
		    &addr->sin6_addr, &pr->ndpr_mask))
			return (1);
	}

	/*
	 * If the default router list is empty, all addresses are regarded
	 * as on-link, and thus, as a neighbor.
	 * XXX: we restrict the condition to hosts, because routers usually do
	 * not have the "default router list".
	 */
	if (!ip6_forwarding && TAILQ_FIRST(&nd_defrouter) == NULL &&
	    nd6_defifindex == ifp->if_index) {
		return (1);
d781 2
a782 2
	if ((rt = nd6_lookup(&addr->sin6_addr, 0, ifp)) != NULL)
		return (1);
d784 3
a786 1
	return (0);
a790 3
 * Since the function would cause significant changes in the kernel, DO NOT
 * make it global, unless you have a strong reason for the change, and are sure
 * that the change is safe.
d792 2
a793 2
static struct llinfo_nd6 *
nd6_free(rt, gc)
a794 1
	int gc;
d801 2
a802 2
	 * we used to have pfctlinput(PRC_HOSTDEAD) here.
	 * even though it is not harmful, it was not really necessary.
d804 1
d808 1
a808 1
		s = splsoftnet();
d810 1
a810 21
		    rt->rt_ifp);

		if (dr != NULL && dr->expire &&
		    ln->ln_state == ND6_LLINFO_STALE && gc) {
			/*
			 * If the reason for the deletion is just garbage
			 * collection, and the neighbor is an active default
			 * router, do not delete it.  Instead, reset the GC
			 * timer using the router's lifetime.
			 * Simply deleting the entry would affect default
			 * router selection, which is not necessarily a good
			 * thing, especially when we're using router preference
			 * values.
			 * XXX: the check for ln_state would be redundant,
			 *      but we intentionally keep it just in case.
			 */
			ln->ln_expire = dr->expire;
			splx(s);
			return (ln->ln_next);
		}

d836 13
a848 6
			/*
			 * Since defrouter_select() does not affect the
			 * on-link determination and MIP6 needs the check
			 * before the default router selection, we perform
			 * the check now.
			 */
a849 5

			/*
			 * refresh default router list
			 */
			defrouter_select();
d868 1
a868 1
	    rt_mask(rt), 0, (struct rtentry **)0);
d870 1
a870 1
	return (next);
d922 2
a923 1
		ln->ln_expire = time_second + ND_IFINFO(rt->rt_ifp)->reachable;
a937 1
	int mine = 0;
d939 1
a939 1
	if ((rt->rt_flags & RTF_GATEWAY) != 0)
a941 32
	if (nd6_need_cache(ifp) == 0 && (rt->rt_flags & RTF_HOST) == 0) {
		/*
		 * This is probably an interface direct route for a link
		 * which does not need neighbor caches (e.g. fe80::%lo0/64).
		 * We do not need special treatment below for such a route.
		 * Moreover, the RTF_LLINFO flag which would be set below
		 * would annoy the ndp(8) command.
		 */
		return;
	}

	if (req == RTM_RESOLVE &&
	    (nd6_need_cache(ifp) == 0 || /* stf case */
	     !nd6_is_addr_neighbor((struct sockaddr_in6 *)rt_key(rt), ifp))) {
		/*
		 * FreeBSD and BSD/OS often make a cloned host route based
		 * on a less-specific route (e.g. the default route).
		 * If the less specific route does not have a "gateway"
		 * (this is the case when the route just goes to a p2p or an
		 * stf interface), we'll mistakenly make a neighbor cache for
		 * the host route, and will see strange neighbor solicitation
		 * for the corresponding destination.  In order to avoid the
		 * confusion, we check if the destination of the route is
		 * a neighbor in terms of neighbor discovery, and stop the
		 * process if not.  Additionally, we remove the LLINFO flag
		 * so that ndp(8) will not try to get the neighbor information
		 * of the destination.
		 */
		rt->rt_flags &= ~RTF_LLINFO;
		return;
	}

d969 1
a969 1
				printf("nd6_rtrequest: time.tv_sec is zero; "
d975 1
a975 1
			if ((rt->rt_flags & RTF_CLONING) != 0)
d1007 1
a1007 1
		if ((ifp->if_flags & (IFF_POINTOPOINT | IFF_LOOPBACK)) == 0) {
d1066 1
a1066 1
		    &SIN6(rt_key(rt))->sin6_addr);
a1071 1
			mine = 1;
d1109 4
a1112 5
				if (in6_addmulti(&llsol, ifp, &error)) {
					nd6log((LOG_ERR, "%s: failed to join "
					    "%s (errno=%d)\n", ifp->if_xname,
					    ip6_sprintf(&llsol), error));
				}
d1149 59
d1215 1
a1215 1
	struct in6_oprlist *oprl = (struct in6_oprlist *)data;
d1219 1
a1219 1
	struct nd_defrouter *dr;
a1226 3
		/*
		 * obsolete API, use sysctl under net.inet6.icmp6
		 */
d1228 1
a1228 1
		s = splsoftnet();
a1251 7
		 * obsolete API, use sysctl under net.inet6.icmp6
		 *
		 * XXX the structure in6_prlist was changed in backward-
		 * incompatible manner.  in6_oprlist is used for SIOCGPRLST_IN6,
		 * in6_prlist is used for nd6_sysctl() - fill_prlist().
		 */
		/*
d1256 2
a1257 2
		bzero(oprl, sizeof(*oprl));
		s = splsoftnet();
d1263 7
a1269 7
			oprl->prefix[i].prefix = pr->ndpr_prefix.sin6_addr;
			oprl->prefix[i].raflags = pr->ndpr_raf;
			oprl->prefix[i].prefixlen = pr->ndpr_plen;
			oprl->prefix[i].vltime = pr->ndpr_vltime;
			oprl->prefix[i].pltime = pr->ndpr_pltime;
			oprl->prefix[i].if_index = pr->ndpr_ifp->if_index;
			oprl->prefix[i].expire = pr->ndpr_expire;
d1275 1
a1275 1
#define RTRADDR oprl->prefix[i].advrtr[j]
d1291 2
a1292 2
			oprl->prefix[i].advrtrs = j;
			oprl->prefix[i].origin = PR_ORIG_RA;
d1297 19
a1318 12
	case OSIOCGIFINFO_IN6:
		/* XXX: old ndp(8) assumes a positive value for linkmtu. */
		bzero(&ndi->ndi, sizeof(ndi->ndi));
		ndi->ndi.linkmtu = IN6_LINKMTU(ifp);
		ndi->ndi.maxmtu = ND_IFINFO(ifp)->maxmtu;
		ndi->ndi.basereachable = ND_IFINFO(ifp)->basereachable;
		ndi->ndi.reachable = ND_IFINFO(ifp)->reachable;
		ndi->ndi.retrans = ND_IFINFO(ifp)->retrans;
		ndi->ndi.flags = ND_IFINFO(ifp)->flags;
		ndi->ndi.recalctm = ND_IFINFO(ifp)->recalctm;
		ndi->ndi.chlim = ND_IFINFO(ifp)->chlim;
		break;
d1320 5
a1324 1
		ndi->ndi = *ND_IFINFO(ifp);
d1327 6
a1332 1
		ND_IFINFO(ifp)->flags = ndi->ndi.flags;
d1335 7
a1341 2
		/* sync kernel routing table with the default router list */
		defrouter_reset();
d1343 1
d1346 1
a1346 1
	{
d1350 2
a1351 1
		s = splsoftnet();
a1352 2
			struct in6_ifaddr *ia, *ia_next;

d1354 2
a1355 15

			if (IN6_IS_ADDR_LINKLOCAL(&pr->ndpr_prefix.sin6_addr))
				continue; /* XXX */

			/* do we really have to remove addresses as well? */
			for (ia = in6_ifaddr; ia; ia = ia_next) {
				/* ia might be removed.  keep the next ptr. */
				ia_next = ia->ia_next;

				if ((ia->ia6_flags & IN6_IFF_AUTOCONF) == 0)
					continue;

				if (ia->ia6_ndpr == pr)
					in6_purgeaddr(&ia->ia_ifa);
			}
d1360 1
a1360 1
	}
d1362 1
a1362 1
	{
d1366 11
a1376 5
		s = splsoftnet();
		defrouter_reset();
		for (dr = TAILQ_FIRST(&nd_defrouter); dr; dr = next) {
			next = TAILQ_NEXT(dr, dr_entry);
			defrtrlist_del(dr);
a1377 1
		defrouter_select();
d1380 1
a1380 1
	}
d1382 1
a1382 1
	{
d1398 3
a1400 3
		s = splsoftnet();
		if ((rt = nd6_lookup(&nb_addr, 0, ifp)) == NULL ||
		    (ln = (struct llinfo_nd6 *)rt->rt_llinfo) == NULL) {
d1405 1
d1411 1
a1411 1

d1413 1
a1413 1
	}
d1418 1
a1418 1
		return (nd6_setdefaultiface(ndif->ifindex));
d1421 1
a1421 1
	return (error);
d1487 1
a1487 1
		(void)nd6_free(rt, 0);
d1529 2
a1530 2
		if ((!olladdr && lladdr) ||		/* (3) */
		    (olladdr && lladdr && llchange)) {	/* (5) */
d1564 2
a1565 1
				    (struct sockaddr_in6 *)rt_key(rt), rt);
d1632 2
a1633 2
		if ((!is_newentry && (olladdr || lladdr)) ||	/* (2-5) */
		    (is_newentry && lladdr)) {			/* (7) */
a1649 3
	 * XXX: although defrouter_select() should not have a bad effect
	 * for those are not autoconfigured hosts, we explicitly avoid such
	 * cases for safety.
d1661 2
a1662 1
	int s = splsoftnet();
a1663 1
	struct ifnet *ifp;
d1667 4
a1670 3
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
		nd6if = ND_IFINFO(ifp);
d1708 14
a1721 1
	if (nd6_need_cache(ifp) == 0)
d1723 1
d1730 2
a1731 2
			if ((rt0 = rt = rtalloc1((struct sockaddr *)dst,
			    1)) != NULL)
d1737 1
a1737 1
					    dst, rt);
d1749 1
a1749 1
			 * of view, regardless of the value of nd_ifinfo.flags.
d1771 1
a1771 2
			lookup:
				rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1);
d1800 1
a1800 1
		    !(ND_IFINFO(ifp)->flags & ND6_IFF_PERFORMNUD)) {
d1843 3
d1852 8
a1859 15
	/*
	 * If there has been no NS for the neighbor after entering the
	 * INCOMPLETE state, send the first solicitation.
	 * Technically this can be against the rate-limiting rule described in
	 * Section 7.2.2 of RFC 2461 because the interval to the next scheduled
	 * solicitation issued in nd6_timer() may be less than the specified
	 * retransmission time.  This should not be a problem from a practical
	 * point of view, because we'll typically see an immediate response
	 * from the neighbor, which suppresses the succeeding solicitations.
	 */
	if (ln->ln_expire && ln->ln_asked == 0) {
		ln->ln_asked++;
		ln->ln_expire = time_second +
		    ND6_RETRANS_SEC(ND_IFINFO(ifp)->retrans);
		nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
d1861 2
a1862 2
	return (0);

d1882 1
a1882 1
		return ((*ifp->if_output)(origifp, m, (struct sockaddr *)dst,
d1894 1
a1894 1
	return ((*ifp->if_output)(ifp, m, (struct sockaddr *)dst, rt));
d1900 1
a1900 1
}
a1903 26
nd6_need_cache(ifp)
	struct ifnet *ifp;
{
	/*
	 * XXX: we currently do not make neighbor cache on any interface
	 * other than ARCnet, Ethernet, FDDI and GIF.
	 *
	 * RFC2893 says:
	 * - unidirectional tunnels needs no ND
	 */
	switch (ifp->if_type) {
	case IFT_ARCNET:
	case IFT_ETHER:
	case IFT_FDDI:
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
	case IFT_L2VLAN:
	case IFT_IEEE80211:
	case IFT_GIF:		/* XXX need more cases? */
		return (1);
	default:
		return (0);
	}
}

int
d1916 1
a1916 1
		case IFT_FDDI:
d1919 1
a1919 1
			return (1);
d1923 1
a1923 1
			return (1);
d1926 1
a1926 1
			return (0);
d1933 1
a1933 1
		return (0);
d1938 1
a1938 1
		return (0);
d1943 1
a1943 2
		printf("nd6_storelladdr: sdl_alen == 0, dst=%s, if=%s\n",
		    ip6_sprintf(&SIN6(dst)->sin6_addr), ifp->if_xname);
d1945 1
a1945 1
		return (0);
d1949 1
a1949 204
	return (1);
}

int
nd6_sysctl(name, oldp, oldlenp, newp, newlen)
	int name;
	void *oldp;	/* syscall arg, need copyout */
	size_t *oldlenp;
	void *newp;	/* syscall arg, need copyin */
	size_t newlen;
{
	void *p;
	size_t ol, l;
	int error;

	error = 0;
	l = 0;

	if (newp)
		return EPERM;
	if (oldp && !oldlenp)
		return EINVAL;
	ol = oldlenp ? *oldlenp : 0;

	if (oldp) {
		p = malloc(*oldlenp, M_TEMP, M_WAITOK);
		if (!p)
			return ENOMEM;
	} else
		p = NULL;
	switch (name) {
	case ICMPV6CTL_ND6_DRLIST:
		error = fill_drlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
		break;

	case ICMPV6CTL_ND6_PRLIST:
		error = fill_prlist(p, oldlenp, ol);
		if (!error && p && oldp)
			error = copyout(p, oldp, *oldlenp);
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}
	if (p)
		free(p, M_TEMP);

	return (error);
}

static int
fill_drlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
{
	int error = 0, s;
	struct in6_defrouter *d = NULL, *de = NULL;
	struct nd_defrouter *dr;
	size_t l;

	s = splsoftnet();

	if (oldp) {
		d = (struct in6_defrouter *)oldp;
		de = (struct in6_defrouter *)((caddr_t)oldp + *oldlenp);
	}
	l = 0;

	for (dr = TAILQ_FIRST(&nd_defrouter); dr;
	     dr = TAILQ_NEXT(dr, dr_entry)) {

		if (oldp && d + 1 <= de) {
			bzero(d, sizeof(*d));
			d->rtaddr.sin6_family = AF_INET6;
			d->rtaddr.sin6_len = sizeof(struct sockaddr_in6);
			d->rtaddr.sin6_addr = dr->rtaddr;
			in6_recoverscope(&d->rtaddr, &d->rtaddr.sin6_addr,
			    dr->ifp);
			d->flags = dr->flags;
			d->rtlifetime = dr->rtlifetime;
			d->expire = dr->expire;
			d->if_index = dr->ifp->if_index;
		}

		l += sizeof(*d);
		if (d)
			d++;
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;

	splx(s);

	return (error);
}

static int
fill_prlist(oldp, oldlenp, ol)
	void *oldp;
	size_t *oldlenp, ol;
{
	int error = 0, s;
	struct nd_prefix *pr;
	struct in6_prefix *p = NULL;
	struct in6_prefix *pe = NULL;
	size_t l;

	s = splsoftnet();

	if (oldp) {
		p = (struct in6_prefix *)oldp;
		pe = (struct in6_prefix *)((caddr_t)oldp + *oldlenp);
	}
	l = 0;

	for (pr = nd_prefix.lh_first; pr; pr = pr->ndpr_next) {
		u_short advrtrs;
		size_t advance;
		struct sockaddr_in6 *sin6;
		struct sockaddr_in6 *s6;
		struct nd_pfxrouter *pfr;

		if (oldp && p + 1 <= pe)
		{
			bzero(p, sizeof(*p));
			sin6 = (struct sockaddr_in6 *)(p + 1);

			p->prefix = pr->ndpr_prefix;
			if (in6_recoverscope(&p->prefix,
			    &p->prefix.sin6_addr, pr->ndpr_ifp) != 0)
				log(LOG_ERR,
				    "scope error in prefix list (%s)\n",
				    ip6_sprintf(&p->prefix.sin6_addr));
			p->raflags = pr->ndpr_raf;
			p->prefixlen = pr->ndpr_plen;
			p->vltime = pr->ndpr_vltime;
			p->pltime = pr->ndpr_pltime;
			p->if_index = pr->ndpr_ifp->if_index;
			if (pr->ndpr_vltime == ND6_INFINITE_LIFETIME)
				p->expire = 0;
			else {
				time_t maxexpire;

				/* XXX: we assume time_t is signed. */
				maxexpire = (-1) &
					~(1 << ((sizeof(maxexpire) * 8) - 1));
				if (pr->ndpr_vltime <
				    maxexpire - pr->ndpr_lastupdate) {
					p->expire = pr->ndpr_lastupdate +
						pr->ndpr_vltime;
				} else
					p->expire = maxexpire;
			}
			p->refcnt = pr->ndpr_refcnt;
			p->flags = pr->ndpr_stateflags;
			p->origin = PR_ORIG_RA;
			advrtrs = 0;
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next) {
				if ((void *)&sin6[advrtrs + 1] > (void *)pe) {
					advrtrs++;
					continue;
				}
				s6 = &sin6[advrtrs];
				s6->sin6_family = AF_INET6;
				s6->sin6_len = sizeof(struct sockaddr_in6);
				s6->sin6_addr = pfr->router->rtaddr;
				in6_recoverscope(s6, &pfr->router->rtaddr,
				    pfr->router->ifp);
				advrtrs++;
			}
			p->advrtrs = advrtrs;
		}
		else {
			advrtrs = 0;
			for (pfr = pr->ndpr_advrtrs.lh_first; pfr;
			     pfr = pfr->pfr_next)
				advrtrs++;
		}

		advance = sizeof(*p) + sizeof(*sin6) * advrtrs;
		l += advance;
		if (p)
			p = (struct in6_prefix *)((caddr_t)p + advance);
	}

	if (oldp) {
		*oldlenp = l;	/* (caddr_t)d - (caddr_t)oldp */
		if (l > ol)
			error = ENOMEM;
	} else
		*oldlenp = l;

	splx(s);

	return (error);
@


1.6.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a102 1
static void nd6_llinfo_timer(void *);
d368 1
a368 1
 * ND6 timer routine to handle ND6 entries
d371 2
a372 26
nd6_llinfo_settimer(struct llinfo_nd6 *ln, long tick)
{
	int s;

	s = splsoftnet();

	if (tick < 0) {
		ln->ln_expire = 0;
		ln->ln_ntick = 0;
		timeout_del(&ln->ln_timer_ch);
	} else {
		ln->ln_expire = time.tv_sec + tick / hz;
		if (tick > INT_MAX) {
			ln->ln_ntick = tick - INT_MAX;
			timeout_add(&ln->ln_timer_ch, INT_MAX);
		} else {
			ln->ln_ntick = 0;
			timeout_add(&ln->ln_timer_ch, tick);
		}
	}

	splx(s);
}

static void
nd6_llinfo_timer(void *arg)
d376 3
a378 2
	struct rtentry *rt;
	struct sockaddr_in6 *dst;
d380 2
a381 1
	struct nd_ifinfo *ndi = NULL;
d384 2
d387 7
a393 1
	ln = (struct llinfo_nd6 *)arg;
d395 7
a401 7
	if (ln->ln_ntick > 0) {
		if (ln->ln_ntick > INT_MAX) {
			ln->ln_ntick -= INT_MAX;
			nd6_llinfo_settimer(ln, INT_MAX);
		} else {
			ln->ln_ntick = 0;
			nd6_llinfo_settimer(ln, ln->ln_ntick);
d403 2
a404 3
		splx(s);
		return;
	}
d406 4
a409 32
	if ((rt = ln->ln_rt) == NULL)
		panic("ln->ln_rt == NULL");
	if ((ifp = rt->rt_ifp) == NULL)
		panic("ln->ln_rt->rt_ifp == NULL");
	ndi = ND_IFINFO(ifp);
	dst = (struct sockaddr_in6 *)rt_key(rt);

	/* sanity check */
	if (rt->rt_llinfo && (struct llinfo_nd6 *)rt->rt_llinfo != ln)
		panic("rt_llinfo(%p) is not equal to ln(%p)",
		      rt->rt_llinfo, ln);
	if (!dst)
		panic("dst=0 in nd6_timer(ln=%p)", ln);

	switch (ln->ln_state) {
	case ND6_LLINFO_INCOMPLETE:
		if (ln->ln_asked < nd6_mmaxtries) {
			ln->ln_asked++;
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
			nd6_ns_output(ifp, NULL, &dst->sin6_addr, ln, 0);
		} else {
			struct mbuf *m = ln->ln_hold;
			if (m) {
				ln->ln_hold = NULL;
				/*
				 * Fake rcvif to make the ICMP error
				 * more helpful in diagnosing for the
				 * receiver.
				 * XXX: should we consider
				 * older rcvif?
				 */
				m->m_pkthdr.rcvif = rt->rt_ifp;
d411 34
a444 2
				icmp6_error(m, ICMP6_DST_UNREACH,
				    ICMP6_DST_UNREACH_ADDR, 0);
d446 7
a452 10
			(void)nd6_free(rt, 0);
			ln = NULL;
		}
		break;
	case ND6_LLINFO_REACHABLE:
		if (!ND6_LLINFO_PERMANENT(ln)) {
			ln->ln_state = ND6_LLINFO_STALE;
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
		}
		break;
d454 5
a458 7
	case ND6_LLINFO_STALE:
		/* Garbage Collection(RFC 2461 5.3) */
		if (!ND6_LLINFO_PERMANENT(ln)) {
			(void)nd6_free(rt, 1);
			ln = NULL;
		}
		break;
d460 25
a484 22
	case ND6_LLINFO_DELAY:
		if (ndi && (ndi->flags & ND6_IFF_PERFORMNUD) != 0) {
			/* We need NUD */
			ln->ln_asked = 1;
			ln->ln_state = ND6_LLINFO_PROBE;
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
			nd6_ns_output(ifp, &dst->sin6_addr,
			    &dst->sin6_addr, ln, 0);
		} else {
			ln->ln_state = ND6_LLINFO_STALE; /* XXX */
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
		}
		break;
	case ND6_LLINFO_PROBE:
		if (ln->ln_asked < nd6_umaxtries) {
			ln->ln_asked++;
			nd6_llinfo_settimer(ln, (long)ndi->retrans * hz / 1000);
			nd6_ns_output(ifp, &dst->sin6_addr,
			    &dst->sin6_addr, ln, 0);
		} else {
			(void)nd6_free(rt, 0);
			ln = NULL;
d486 1
a486 1
		break;
a488 20
	splx(s);
}

/*
 * ND6 timer routine to expire default route list and prefix list
 */
void
nd6_timer(ignored_arg)
	void	*ignored_arg;
{
	int s;
	struct nd_defrouter *dr;
	struct nd_prefix *pr;
	struct in6_ifaddr *ia6, *nia6;
	struct in6_addrlifetime *lt6;

	s = splsoftnet();
	timeout_set(&nd6_timer_ch, nd6_timer, NULL);
	timeout_add(&nd6_timer_ch, nd6_prune * hz);

d492 1
a492 1
		if (dr->expire && dr->expire < time.tv_sec) {
d535 1
a535 1
		    time.tv_sec - pr->ndpr_lastupdate > pr->ndpr_vltime) {
d812 1
a812 1
	if (!ip6_forwarding) {
d832 1
a832 5
			if (dr->expire > time.tv_sec * hz) {
				nd6_llinfo_settimer(ln,
				    dr->expire - time.tv_sec * hz);
			} else
				nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d909 1
d945 2
a946 4
	if (!ND6_LLINFO_PERMANENT(ln)) {
		nd6_llinfo_settimer(ln,
		    (long)ND_IFINFO(rt->rt_ifp)->reachable * hz);
	}
d960 1
d1007 1
a1007 2
		if ((rt->rt_flags & RTF_CLONING) ||
		    ((rt->rt_flags & RTF_LLINFO) && !ln)) {
d1009 4
a1012 4
			 * Case 1: This route should come from a route to
			 * interface (RTF_CLONING case) or the route should be
			 * treated as on-link but is currently not
			 * (RTF_LLINFO && !ln case).
d1020 11
a1030 1
				nd6_llinfo_settimer(ln, 0);
a1093 1
		timeout_set(&ln->ln_timer_ch, nd6_llinfo_timer, ln);
d1109 1
a1109 1
			nd6_llinfo_settimer(ln, 0);
d1125 1
a1125 1
			nd6_llinfo_settimer(ln, -1);
d1150 1
a1150 1
			nd6_llinfo_settimer(ln, -1);
a1198 1
		nd6_llinfo_settimer(ln, -1);
d1440 1
d1551 1
a1551 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d1564 1
a1564 1
			nd6_llinfo_settimer((void *)ln, 0);
d1696 1
d1798 1
a1798 1
		nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d1811 1
a1811 1
		nd6_llinfo_settimer(ln, nd6_delay * hz);
d1835 6
d1842 1
a1842 1
	if (!ND6_LLINFO_PERMANENT(ln) && ln->ln_asked == 0) {
d1844 2
a1845 2
		nd6_llinfo_settimer(ln,
		    (long)ND_IFINFO(ifp)->retrans * hz / 1000);
d1870 1
a1870 1
		    rt));
@


1.6.2.9
log
@Merge with the trunk
@
text
@d1745 5
a1749 2
				if (rt->rt_ifp != ifp)
					senderr(EHOSTUNREACH);
@


1.5
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.4 2000/01/08 05:49:41 angelos Exp $	*/
d64 1
a64 1
#include <netinet6/ip6.h>
d68 1
a68 1
#include <netinet6/icmp6.h>
@


1.4
log
@Missing rndvar.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.3 1999/12/10 17:53:15 itojun Exp $	*/
d532 88
a1042 3
#if 0
		insque(ln, &llinfo_nd6);
#else
a1046 1
#endif
a1084 3
#if 0
		remque(ln);
#else
a1087 1
#endif
a1564 1

@


1.3
log
@a critical fix from kame: add missing splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d52 1
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6.c,v 1.1 1999/12/08 06:50:23 itojun Exp $	*/
d1254 1
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a49 1
#endif
a55 1
#if !(defined(__bsdi__) && _BSDI_VERSION >= 199802)
a56 1
#endif
a59 1
#ifndef __NetBSD__
d61 1
a61 11
#ifdef __FreeBSD__
#include <netinet/if_fddi.h>
#endif
#ifdef __bsdi__
#include <net/if_fddi.h>
#endif
#else /* __NetBSD__ */
#include <net/if_ether.h>
#include <netinet/if_inarp.h>
#include <net/if_fddi.h>
#endif /* __NetBSD__ */
a68 1
#ifndef __bsdi__
d70 1
a70 2
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
a71 1
#endif
a188 10
#if defined(__FreeBSD__) || defined(__bsdi__)
	 case IFT_FDDI:
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
		 ndi->maxmtu = MIN(FDDIMTU, ifp->if_mtu);
#else
		 ndi->maxmtu = MIN(FDDIIPMTU, ifp->if_mtu);
#endif
		 break;
#endif
#if !(defined(__bsdi__) && _BSDI_VERSION >= 199802)
a191 1
#endif
a370 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a371 1
#endif
a372 3
#ifdef __NetBSD__
	s = splsoftnet();
#else
d374 1
a374 1
#endif
d544 1
a544 5
	rt = rtalloc1((struct sockaddr *)&sin6, create
#ifdef __FreeBSD__
		      , 0UL
#endif /*__FreeBSD__*/
		      );
a640 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a643 1
#endif
a684 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d686 1
a686 1
#endif
a724 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a725 1
#endif
a777 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a778 1
#endif
a853 6
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
nd6_rtrequest(req, rt, info)
	int	req;
	struct rtentry *rt;
	struct rt_addrinfo *info; /* xxx unused */
#else
a857 1
#endif
a863 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a864 1
#endif
a977 9
#ifdef __bsdi__
#if _BSDI_VERSION >= 199802
				extern struct ifnet *loifp;
				rt->rt_ifp = loifp;	/*XXX*/
#else
				extern struct ifnet loif;
				rt->rt_ifp = &loif;	/*XXX*/
#endif
#else /* non-bsdi */
a978 1
#endif
a1015 6
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
nd6_p2p_rtrequest(req, rt, info)
	int	req;
	struct rtentry *rt;
	struct rt_addrinfo *info; /* xxx unused */
#else
a1019 1
#endif
a1066 9
#ifdef __bsdi__
#if _BSDI_VERSION >= 199802
				extern struct ifnet *loifp;
				rt->rt_ifp = loifp;	/*XXX*/
#else
				extern struct ifnet loif;
				rt->rt_ifp = &loif;	/*XXX*/
#endif
#else
a1067 1
#endif /*__bsdi__*/
d1093 1
a1093 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d1095 1
a1095 1
#endif
d1120 1
a1120 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d1122 1
a1122 1
#endif
a1200 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d1202 1
a1202 1
#endif
a1216 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d1218 1
a1218 1
#endif
a1249 3
#ifdef __NetBSD__
		s = splsoftnet();
#else
d1251 1
a1251 1
#endif
a1289 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1290 1
#endif
a1481 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
d1483 1
a1483 1
#endif
a1516 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1517 1
#endif
a1539 4
#ifdef __FreeBSD__
			if ((rt0 = rt = rtalloc1((struct sockaddr *)dst, 1, 0UL)) !=
				NULL)
#else
a1541 1
#endif 
a1553 3
#ifdef __FreeBSD__
			lookup: rt->rt_gwroute = rtalloc1(rt->rt_gateway, 1, 0UL);
#else
a1554 1
#endif 
a1556 9
#ifdef __bsdi__
				/* the "G" test below also prevents rt == rt0 */
				if ((rt->rt_flags & RTF_GATEWAY) ||
				    (rt->rt_ifp != ifp)) {
					rt->rt_refcnt--;
					rt0->rt_gwroute = 0;
					senderr(EHOSTUNREACH);
				}
#endif 
@

