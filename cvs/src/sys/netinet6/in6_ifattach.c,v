head	1.104;
access;
symbols
	OPENBSD_6_2:1.104.0.2
	OPENBSD_6_2_BASE:1.104
	OPENBSD_6_1:1.101.0.4
	OPENBSD_6_1_BASE:1.101
	OPENBSD_6_0:1.100.0.2
	OPENBSD_6_0_BASE:1.100
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.90.0.4
	OPENBSD_5_8_BASE:1.90
	OPENBSD_5_7:1.85.0.2
	OPENBSD_5_7_BASE:1.85
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.68.0.4
	OPENBSD_5_5_BASE:1.68
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.56.0.2
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.53.0.4
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.2
	OPENBSD_5_0:1.51.0.6
	OPENBSD_5_0_BASE:1.51
	OPENBSD_4_9:1.51.0.4
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.50.0.2
	OPENBSD_4_7_BASE:1.50
	OPENBSD_4_6:1.48.0.6
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.45.0.4
	OPENBSD_4_3_BASE:1.45
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.43.0.2
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.39.0.4
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.2
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.36
	SMP_SYNC_B:1.36
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.32
	UBC:1.21.0.2
	UBC_BASE:1.21
	OPENBSD_3_0:1.20.0.2
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.104
date	2017.09.01.16.48.27;	author florian;	state Exp;
branches;
next	1.103;
commitid	jiXDUeOdnOUwOn8F;

1.103
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.102;
commitid	iTlWhLM2orYZnz27;

1.102
date	2017.05.16.12.24.02;	author mpi;	state Exp;
branches;
next	1.101;
commitid	SAe3SQ48vKH6r5FL;

1.101
date	2016.12.29.12.17.22;	author mpi;	state Exp;
branches;
next	1.100;
commitid	dXmj0FYDjs6byZcO;

1.100
date	2016.06.30.08.19.03;	author mpi;	state Exp;
branches;
next	1.99;
commitid	hkgTNgjkGTFI4ET0;

1.99
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.98;
commitid	i3XNpYhaQ8QndxLo;

1.98
date	2015.10.24.16.24.21;	author mpi;	state Exp;
branches;
next	1.97;
commitid	riSdjbxlnretrUTt;

1.97
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.96;
commitid	tp9bS9eCrwvRYjyO;

1.96
date	2015.09.12.20.50.17;	author mpi;	state Exp;
branches;
next	1.95;
commitid	L7FukNYlBzoQuXvw;

1.95
date	2015.09.03.16.42.01;	author mpi;	state Exp;
branches;
next	1.94;
commitid	KeIm6kblgxTOdQu0;

1.94
date	2015.08.31.08.33.01;	author mpi;	state Exp;
branches;
next	1.93;
commitid	872UGCRTS8S2bBua;

1.93
date	2015.08.24.23.26.43;	author mpi;	state Exp;
branches;
next	1.92;
commitid	RvboqW7afhR7jBgv;

1.92
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.91;
commitid	hOA5qIh5CrYvhG4e;

1.91
date	2015.08.17.10.57.24;	author mpi;	state Exp;
branches;
next	1.90;
commitid	piv3mqqACFeWYcad;

1.90
date	2015.07.18.15.05.32;	author mpi;	state Exp;
branches;
next	1.89;
commitid	8XKIMnE4aOLeVqIl;

1.89
date	2015.07.16.15.31.35;	author mpi;	state Exp;
branches;
next	1.88;
commitid	syrAtzfOhwI3Ygjb;

1.88
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.87;
commitid	4Ro7ulidQXNcMvmM;

1.87
date	2015.04.27.14.51.44;	author mpi;	state Exp;
branches;
next	1.86;
commitid	h3YrO0fhNQbIyJUl;

1.86
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.85;
commitid	p4LJxGKbi0BU2cG6;

1.85
date	2015.02.05.03.01.03;	author mpi;	state Exp;
branches;
next	1.84;
commitid	DhkSbioeq059UWqq;

1.84
date	2015.01.28.22.10.13;	author mpi;	state Exp;
branches;
next	1.83;
commitid	qWMiETGHDs7AwODS;

1.83
date	2015.01.27.10.31.19;	author mpi;	state Exp;
branches;
next	1.82;
commitid	5QOPq50YTGxsLtYH;

1.82
date	2015.01.26.11.38.37;	author mpi;	state Exp;
branches;
next	1.81;
commitid	4QI0UcDYcdBMTh1W;

1.81
date	2015.01.10.11.43.37;	author mpi;	state Exp;
branches;
next	1.80;
commitid	wic8NM5ErVdwMnNC;

1.80
date	2015.01.08.17.21.01;	author florian;	state Exp;
branches;
next	1.79;
commitid	wkRL6v2AweQJcGJV;

1.79
date	2015.01.06.21.26.46;	author stsp;	state Exp;
branches;
next	1.78;
commitid	jH0HZyR3DaPVl7Rm;

1.78
date	2014.12.04.00.02.15;	author tedu;	state Exp;
branches;
next	1.77;
commitid	KWrHkkyZcuPci9rF;

1.77
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.76;
commitid	StxeqV93bwujMj7n;

1.76
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.75;
commitid	Qb045HZ5OhQfU69H;

1.75
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.74;
commitid	Z1vcFtHO8wRH0yRt;

1.74
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.73;
commitid	w0MRp28dmfD1ZzO8;

1.73
date	2014.08.25.14.00.34;	author florian;	state Exp;
branches;
next	1.72;
commitid	fUNtd3qRJAn6fam0;

1.72
date	2014.07.01.19.37.07;	author benno;	state Exp;
branches;
next	1.71;
commitid	vmONFS3P5TyJwr1p;

1.71
date	2014.06.26.13.08.25;	author mpi;	state Exp;
branches;
next	1.70;
commitid	8i8VaO1EEFXK0ftu;

1.70
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.69;
commitid	2Ufy37wyO5neufOK;

1.69
date	2014.05.20.10.29.01;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.66;

1.66
date	2014.01.07.16.34.05;	author stsp;	state Exp;
branches;
next	1.65;

1.65
date	2014.01.06.13.01.20;	author stsp;	state Exp;
branches;
next	1.64;

1.64
date	2013.11.28.10.16.44;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2013.11.19.09.00.43;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.10.17.16.27.45;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2013.05.31.15.04.23;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.26.00.14.18;	author bluhm;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.56;

1.56
date	2012.09.19.09.47.25;	author bluhm;	state Exp;
branches;
next	1.55;

1.55
date	2012.08.21.19.50.39;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2012.08.15.14.00.32;	author sperreault;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.52;

1.52
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.50;

1.50
date	2010.02.08.12.04.35;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.13.02.13.12;	author henning;	state Exp;
branches;
next	1.48;

1.48
date	2009.01.30.10.47.46;	author mcbride;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2008.05.11.08.13.02;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.08.09.31.38;	author henning;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.15.03.07.44;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.31.12.37.31;	author mcbride;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.41;

1.41
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.23.20.10.14;	author mpf;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.21.23.34.01;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.07.20.38.47;	author mcbride;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.07.14.42.27;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.08.10.23.32;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.28.14.42.16;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.14.05.23.37;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.12.01.11.54;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.11.07.36.00;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.11.07.04.07;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.07.04.34.45;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.05.29.02.59.12;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.23.06.56.16;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2001.08.23.14.10.33;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.08.23.02.42.25;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2001.07.18.12.50.44;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.16.15.59.38;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.07.11.43.53;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.18.06.48.25;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.25.22.01.02;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2000.10.18.18.49.39;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.10.02.04.45.03;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.05.07.58.15;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.27.15.40.37;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.17.04.44.50;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.02.09.44.28;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.02.04.18.13.36;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.02.17.16.52;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.12.10.12.34.45;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.27;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.6.2.1
date	2000.03.24.09.09.40;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.07.04.10.55.20;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.21.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.104
log
@Use in6_get_rand_ifid() instead of get_last_resort_ifid() and delete the
get_last_resort_ifid() function because eww.
Also if your system is so constraint that you end up in
in6_get_rand_ifid() you don't deserve a random ifid that stays
stable over reboots.
Simplify code a bit since get_ifid() can no longer fail. It couldn't
fail before either because that code path was #if 0'ed.
While here sprinkle in some in6_ prefixes, pointed out by stsp.
OK stsp
@
text
@/*	$OpenBSD: in6_ifattach.c,v 1.103 2017/07/11 12:51:05 florian Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.124 2001/07/18 08:32:51 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <crypto/sha2.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netinet/in.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/in6_ifattach.h>
#include <netinet6/nd6.h>
#ifdef MROUTING
#include <netinet6/ip6_mroute.h>
#endif

void	in6_get_rand_ifid(struct ifnet *, struct in6_addr *);
int	in6_get_hw_ifid(struct ifnet *, struct in6_addr *);
void	in6_get_ifid(struct ifnet *, struct in6_addr *);
int	in6_ifattach_loopback(struct ifnet *);

#define EUI64_GBIT	0x01
#define EUI64_UBIT	0x02
#define EUI64_TO_IFID(in6)	do {(in6)->s6_addr[8] ^= EUI64_UBIT; } while (0)
#define EUI64_GROUP(in6)	((in6)->s6_addr[8] & EUI64_GBIT)
#define EUI64_INDIVIDUAL(in6)	(!EUI64_GROUP(in6))
#define EUI64_LOCAL(in6)	((in6)->s6_addr[8] & EUI64_UBIT)
#define EUI64_UNIVERSAL(in6)	(!EUI64_LOCAL(in6))

#define IFID_LOCAL(in6)		(!EUI64_LOCAL(in6))
#define IFID_UNIVERSAL(in6)	(!EUI64_UNIVERSAL(in6))

/*
 * Generate a random interface identifier.
 *
 * in6 - upper 64bits are preserved
 */
void
in6_get_rand_ifid(struct ifnet *ifp, struct in6_addr *in6)
{
	arc4random_buf(&in6->s6_addr32[2], 8);

	/* make sure to set "u" bit to local, and "g" bit to individual. */
	in6->s6_addr[8] &= ~EUI64_GBIT;	/* g bit to "individual" */
	in6->s6_addr[8] |= EUI64_UBIT;	/* u bit to "local" */

	/* convert EUI64 into IPv6 interface identifier */
	EUI64_TO_IFID(in6);
}

/*
 * Get interface identifier for the specified interface.
 *
 * in6 - upper 64bits are preserved
 */
int
in6_get_hw_ifid(struct ifnet *ifp, struct in6_addr *in6)
{
	struct sockaddr_dl *sdl;
	char *addr;
	size_t addrlen;
	static u_int8_t allzero[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	static u_int8_t allone[8] =
		{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

	sdl = ifp->if_sadl;
	if (sdl == NULL || sdl->sdl_alen == 0)
		return -1;

	addr = LLADDR(sdl);
	addrlen = sdl->sdl_alen;

	switch (ifp->if_type) {
	case IFT_IEEE1394:
	case IFT_IEEE80211:
		/* IEEE1394 uses 16byte length address starting with EUI64 */
		if (addrlen > 8)
			addrlen = 8;
		break;
	default:
		break;
	}

	/* get EUI64 */
	switch (ifp->if_type) {
	/* IEEE802/EUI64 cases - what others? */
	case IFT_ETHER:
	case IFT_CARP:
	case IFT_IEEE1394:
	case IFT_IEEE80211:
		/* look at IEEE802/EUI64 only */
		if (addrlen != 8 && addrlen != 6)
			return -1;

		/*
		 * check for invalid MAC address - on bsdi, we see it a lot
		 * since wildboar configures all-zero MAC on pccard before
		 * card insertion.
		 */
		if (bcmp(addr, allzero, addrlen) == 0)
			return -1;
		if (bcmp(addr, allone, addrlen) == 0)
			return -1;

		/* make EUI64 address */
		if (addrlen == 8)
			bcopy(addr, &in6->s6_addr[8], 8);
		else if (addrlen == 6) {
			in6->s6_addr[8] = addr[0];
			in6->s6_addr[9] = addr[1];
			in6->s6_addr[10] = addr[2];
			in6->s6_addr[11] = 0xff;
			in6->s6_addr[12] = 0xfe;
			in6->s6_addr[13] = addr[3];
			in6->s6_addr[14] = addr[4];
			in6->s6_addr[15] = addr[5];
		}
		break;

	case IFT_GIF:
		/*
		 * RFC2893 says: "SHOULD use IPv4 address as ifid source".
		 * however, IPv4 address is not very suitable as unique
		 * identifier source (can be renumbered).
		 * we don't do this.
		 */
		return -1;

	default:
		return -1;
	}

	/* sanity check: g bit must not indicate "group" */
	if (EUI64_GROUP(in6))
		return -1;

	/* convert EUI64 into IPv6 interface identifier */
	EUI64_TO_IFID(in6);

	/*
	 * sanity check: ifid must not be all zero, avoid conflict with
	 * subnet router anycast
	 */
	if ((in6->s6_addr[8] & ~(EUI64_GBIT | EUI64_UBIT)) == 0x00 &&
	    bcmp(&in6->s6_addr[9], allzero, 7) == 0) {
		return -1;
	}

	return 0;
}

/*
 * Get interface identifier for the specified interface.  If it is not
 * available on ifp0, borrow interface identifier from other information
 * sources.
 */
void
in6_get_ifid(struct ifnet *ifp0, struct in6_addr *in6)
{
	struct ifnet *ifp;

	/* first, try to get it from the interface itself */
	if (in6_get_hw_ifid(ifp0, in6) == 0) {
		nd6log((LOG_DEBUG, "%s: got interface identifier from itself\n",
		    ifp0->if_xname));
		goto success;
	}

	/* next, try to get it from some other hardware interface */
	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		if (ifp == ifp0)
			continue;
		if (in6_get_hw_ifid(ifp, in6) != 0)
			continue;

		/*
		 * to borrow ifid from other interface, ifid needs to be
		 * globally unique
		 */
		if (IFID_UNIVERSAL(in6)) {
			nd6log((LOG_DEBUG,
			    "%s: borrow interface identifier from %s\n",
			    ifp0->if_xname, ifp->if_xname));
			goto success;
		}
	}

	/* last resort: get from random number source */
	in6_get_rand_ifid(ifp, in6);
	nd6log((LOG_DEBUG,
	    "%s: interface identifier generated by random number\n",
	    ifp0->if_xname));
success:
	nd6log((LOG_INFO, "%s: ifid: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    ifp0->if_xname, in6->s6_addr[8], in6->s6_addr[9], in6->s6_addr[10],
	    in6->s6_addr[11], in6->s6_addr[12], in6->s6_addr[13],
	    in6->s6_addr[14], in6->s6_addr[15]));
}

/*
 * ifid - used as EUI64 if not NULL, overrides other EUI64 sources
 */

int
in6_ifattach_linklocal(struct ifnet *ifp, struct in6_addr *ifid)
{
	struct in6_aliasreq ifra;
	struct in6_ifaddr *ia6;
	int error, flags;

	NET_ASSERT_LOCKED();

	/*
	 * configure link-local address.
	 */
	bzero(&ifra, sizeof(ifra));
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ifra.ifra_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] = 0;
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		ifra.ifra_addr.sin6_addr.s6_addr32[2] = 0;
		ifra.ifra_addr.sin6_addr.s6_addr32[3] = htonl(1);
	} else if (ifid) {
		ifra.ifra_addr.sin6_addr = *ifid;
		ifra.ifra_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
		ifra.ifra_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		ifra.ifra_addr.sin6_addr.s6_addr32[1] = 0;
		ifra.ifra_addr.sin6_addr.s6_addr[8] &= ~EUI64_GBIT;
		ifra.ifra_addr.sin6_addr.s6_addr[8] |= EUI64_UBIT;
	} else
		in6_get_ifid(ifp, &ifra.ifra_addr.sin6_addr);

	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask64;
	/* link-local addresses should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;

	/*
	 * XXX: Some P2P interfaces seem not to send packets just after
	 * becoming up, so we skip p2p interfaces for safety.
	 */
	if (in6if_do_dad(ifp) && ((ifp->if_flags & IFF_POINTOPOINT) == 0))
		ifra.ifra_flags |= IN6_IFF_TENTATIVE;

	error = in6_update_ifa(ifp, &ifra, in6ifa_ifpforlinklocal(ifp, 0));
	if (error != 0)
		return (error);

	ia6 = in6ifa_ifpforlinklocal(ifp, 0);

	/* Perform DAD, if needed. */
	if (ia6->ia6_flags & IN6_IFF_TENTATIVE)
		nd6_dad_start(&ia6->ia_ifa);

	if (ifp->if_flags & IFF_LOOPBACK) {
		dohooks(ifp->if_addrhooks, 0);
		return (0); /* No need to install a connected route. */
	}

	flags = RTF_CONNECTED;
	if ((ifp->if_flags & IFF_POINTOPOINT) == 0)
		flags |= RTF_CLONING;

	error = rt_ifa_add(&ia6->ia_ifa, flags, ia6->ia_ifa.ifa_addr);
	if (error) {
		in6_purgeaddr(&ia6->ia_ifa);
		return (error);
	}
	dohooks(ifp->if_addrhooks, 0);

	return (0);
}

int
in6_ifattach_loopback(struct ifnet *ifp)
{
	struct in6_aliasreq ifra;

	KASSERT(ifp->if_flags & IFF_LOOPBACK);

	bzero(&ifra, sizeof(ifra));
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask128;

	/*
	 * Always initialize ia_dstaddr (= broadcast address) to loopback
	 * address.  Follows IPv4 practice - see in_ifinit().
	 */
	ifra.ifra_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_dstaddr.sin6_family = AF_INET6;
	ifra.ifra_dstaddr.sin6_addr = in6addr_loopback;

	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_addr = in6addr_loopback;

	/* the loopback  address should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;

	/*
	 * We are sure that this is a newly assigned address, so we can set
	 * NULL to the 3rd arg.
	 */
	return (in6_update_ifa(ifp, &ifra, NULL));
}

/*
 * compute NI group address, based on the current hostname setting.
 * see draft-ietf-ipngwg-icmp-name-lookup-* (04 and later).
 *
 * when ifp == NULL, the caller is responsible for filling scopeid.
 */
int
in6_nigroup(struct ifnet *ifp, const char *name, int namelen,
    struct sockaddr_in6 *sa6)
{
	const char *p;
	u_int8_t *q;
	SHA2_CTX ctx;
	u_int8_t digest[SHA512_DIGEST_LENGTH];
	u_int8_t l;
	u_int8_t n[64];	/* a single label must not exceed 63 chars */

	if (!namelen || !name)
		return -1;

	p = name;
	while (p && *p && *p != '.' && p - name < namelen)
		p++;
	if (p - name > sizeof(n) - 1)
		return -1;	/* label too long */
	l = p - name;
	strncpy((char *)n, name, l);
	n[(int)l] = '\0';
	for (q = n; *q; q++) {
		if ('A' <= *q && *q <= 'Z')
			*q = *q - 'A' + 'a';
	}

	/* generate 8 bytes of pseudo-random value. */
	SHA512Init(&ctx);
	SHA512Update(&ctx, &l, sizeof(l));
	SHA512Update(&ctx, n, l);
	SHA512Final(digest, &ctx);

	bzero(sa6, sizeof(*sa6));
	sa6->sin6_family = AF_INET6;
	sa6->sin6_len = sizeof(*sa6);
	sa6->sin6_addr.s6_addr16[0] = htons(0xff02);
	sa6->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	sa6->sin6_addr.s6_addr8[11] = 2;
	bcopy(digest, &sa6->sin6_addr.s6_addr32[3],
	    sizeof(sa6->sin6_addr.s6_addr32[3]));

	return 0;
}

/*
 * XXX multiple loopback interface needs more care.  for instance,
 * nodelocal address needs to be configured onto only one of them.
 * XXX multiple link-local address case
 */
int
in6_ifattach(struct ifnet *ifp)
{
	/* some of the interfaces are inherently not IPv6 capable */
	switch (ifp->if_type) {
	case IFT_BRIDGE:
	case IFT_ENC:
	case IFT_PFLOG:
	case IFT_PFSYNC:
		return (0);
	}

	/*
	 * if link mtu is too small, don't try to configure IPv6.
	 * remember there could be some link-layer that has special
	 * fragmentation logic.
	 */
	if (ifp->if_mtu < IPV6_MMTU)
		return (EINVAL);

	if ((ifp->if_flags & IFF_MULTICAST) == 0)
		return (EINVAL);

	/* Assign loopback address, if there's none. */
	if (ifp->if_flags & IFF_LOOPBACK) {
		struct in6_addr in6 = in6addr_loopback;
		int error;

		if (in6ifa_ifpwithaddr(ifp, &in6) != NULL)
			return (0);

		error = in6_ifattach_loopback(ifp);
		if (error)
			return (error);
	}

	/* Assign a link-local address, if there's none. */
	if (in6ifa_ifpforlinklocal(ifp, 0) == NULL) {
		if (in6_ifattach_linklocal(ifp, NULL) != 0) {
			/* failed to assign linklocal address. bark? */
		}
	}

	return (0);
}

/*
 * NOTE: in6_ifdetach() does not support loopback if at this moment.
 */
void
in6_ifdetach(struct ifnet *ifp)
{
	struct ifaddr *ifa, *next;
	struct rtentry *rt;
	struct sockaddr_in6 sin6;

#ifdef MROUTING
	/* remove ip6_mrouter stuff */
	ip6_mrouter_detach(ifp);
#endif

	/* nuke any of IPv6 addresses we have */
	TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list, next) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		in6_purgeaddr(ifa);
		dohooks(ifp->if_addrhooks, 0);
	}

	/*
	 * Remove neighbor management table.  Must be called after
	 * purging addresses.
	 */
	nd6_purge(ifp);

	/* remove route to interface local allnodes multicast (ff01::1) */
	bzero(&sin6, sizeof(sin6));
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = in6addr_intfacelocal_allnodes;
	sin6.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	rt = rtalloc(sin6tosa(&sin6), 0, ifp->if_rdomain);
	if (rt && rt->rt_ifidx == ifp->if_index) {
		rtdeletemsg(rt, ifp, ifp->if_rdomain);
		rtfree(rt);
	}

	/* remove route to link-local allnodes multicast (ff02::1) */
	bzero(&sin6, sizeof(sin6));
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = in6addr_linklocal_allnodes;
	sin6.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	rt = rtalloc(sin6tosa(&sin6), 0, ifp->if_rdomain);
	if (rt && rt->rt_ifidx == ifp->if_index) {
		rtdeletemsg(rt, ifp, ifp->if_rdomain);
		rtfree(rt);
	}

	if (ifp->if_xflags & IFXF_AUTOCONF6)
		ifp->if_xflags &= ~IFXF_AUTOCONF6;
}
@


1.103
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.102 2017/05/16 12:24:02 mpi Exp $	*/
d59 4
a62 4
int get_last_resort_ifid(struct ifnet *, struct in6_addr *);
int get_hw_ifid(struct ifnet *, struct in6_addr *);
int get_ifid(struct ifnet *, struct in6_addr *);
int in6_ifattach_loopback(struct ifnet *);
a75 39
 * Generate a last-resort interface identifier, when the machine has no
 * IEEE802/EUI64 address sources.
 * The goal here is to get an interface identifier that is
 * (1) random enough and (2) does not change across reboot.
 * We currently use SHA512(hostname) for it.
 *
 * in6 - upper 64bits are preserved
 */
int
get_last_resort_ifid(struct ifnet *ifp, struct in6_addr *in6)
{
	SHA2_CTX ctx;
	u_int8_t digest[SHA512_DIGEST_LENGTH];

#if 0
	/* we need at least several letters as seed for ifid */
	if (hostnamelen < 3)
		return -1;
#endif

	/* generate 8 bytes of pseudo-random value. */
	SHA512Init(&ctx);
	SHA512Update(&ctx, hostname, hostnamelen);
	SHA512Final(digest, &ctx);

	/* assumes sizeof(digest) > sizeof(ifid) */
	bcopy(digest, &in6->s6_addr[8], 8);

	/* make sure to set "u" bit to local, and "g" bit to individual. */
	in6->s6_addr[8] &= ~EUI64_GBIT;	/* g bit to "individual" */
	in6->s6_addr[8] |= EUI64_UBIT;	/* u bit to "local" */

	/* convert EUI64 into IPv6 interface identifier */
	EUI64_TO_IFID(in6);

	return 0;
}

/*
d99 1
a99 1
get_hw_ifid(struct ifnet *ifp, struct in6_addr *in6)
d199 2
a200 2
int
get_ifid(struct ifnet *ifp0, struct in6_addr *in6)
d205 1
a205 1
	if (get_hw_ifid(ifp0, in6) == 0) {
d215 1
a215 1
		if (get_hw_ifid(ifp, in6) != 0)
d231 4
a234 10
	if (get_last_resort_ifid(ifp, in6) == 0) {
		nd6log((LOG_DEBUG,
		    "%s: interface identifier generated by random number\n",
		    ifp0->if_xname));
		goto success;
	}

	printf("%s: failed to get interface identifier\n", ifp0->if_xname);
	return -1;

a239 1
	return 0;
d275 2
a276 7
	} else {
		if (get_ifid(ifp, &ifra.ifra_addr.sin6_addr) != 0) {
			nd6log((LOG_ERR,
			    "%s: no ifid available\n", ifp->if_xname));
			return (-1);
		}
	}
@


1.102
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.101 2016/12/29 12:17:22 mpi Exp $	*/
a506 3
	if (ifp->if_xflags & IFXF_AUTOCONF6)
		nd6_rs_attach(ifp);

d563 1
a563 2
	if (ifp->if_xflags & IFXF_AUTOCONF6) {
		nd6_rs_detach(ifp);
a564 1
	}
@


1.101
log
@Get rid of recursive splsoftnet() in in6_ifattach_linklocal().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.100 2016/06/30 08:19:03 mpi Exp $	*/
d299 1
a299 1
	splsoftassert(IPL_SOFTNET);
@


1.100
log
@Restore the automagically added /64 route on p2p interfaces in order to
send traffic to link-local addresses without default route.

Fix a regression reported by Michael Lechtermann, ok stsp@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.99 2015/12/02 16:35:53 bluhm Exp $	*/
d297 3
a299 1
	int s, error, flags;
a342 1
	s = splsoftnet();
a343 1
	splx(s);
a361 1
	s = splsoftnet();
a364 1
		splx(s);
a367 1
	splx(s);
@


1.99
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.98 2015/10/24 16:24:21 mpi Exp $	*/
d297 1
a297 1
	int s, error;
d353 1
a353 1
	if (ifp->if_flags & (IFF_POINTOPOINT|IFF_LOOPBACK)) {
d358 4
d363 1
a363 2
	error = rt_ifa_add(&ia6->ia_ifa, RTF_CLONING | RTF_CONNECTED,
	    ia6->ia_ifa.ifa_addr);
@


1.98
log
@Convert to rt_ifidx.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.97 2015/10/22 15:37:47 bluhm Exp $	*/
d550 1
a550 1
		rtdeletemsg(rt, ifp->if_rdomain);
d562 1
a562 1
		rtdeletemsg(rt, ifp->if_rdomain);
@


1.97
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.96 2015/09/12 20:50:17 mpi Exp $	*/
d549 1
a549 1
	if (rt && rt->rt_ifp == ifp) {
d561 1
a561 1
	if (rt && rt->rt_ifp == ifp) {
@


1.96
log
@Now that rtrequest1(9) properly sets RTF_UP for newly added route,
stop passing it in every rt_ifa_add(9) calls.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.95 2015/09/03 16:42:01 mpi Exp $	*/
d147 1
a147 1
	sdl = (struct sockaddr_dl *)ifp->if_sadl;
@


1.95
log
@Change the order of operations for loopback interfaces to have
::1 configured before fe80::1.

(lo0:0) in pf should resolve to 127.0.0.1 ::1.

reported by and ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.94 2015/08/31 08:33:01 mpi Exp $	*/
d359 1
a359 1
	error = rt_ifa_add(&ia6->ia_ifa, RTF_UP|RTF_CLONING|RTF_CONNECTED,
@


1.94
log
@Do not install connected routes on loopback interfaces.

Previously loopback connected routes were managed via the global list
of prefixes, which mean that systems with AUTOCONF'd addresses did not
see them in the routing table.

This also makes inet6 route creation coherent with inet.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.93 2015/08/24 23:26:43 mpi Exp $	*/
a486 7
	/* Assign a link-local address, if there's none. */
	if (in6ifa_ifpforlinklocal(ifp, 0) == NULL) {
		if (in6_ifattach_linklocal(ifp, NULL) != 0) {
			/* failed to assign linklocal address. bark? */
		}
	}

d490 2
d495 10
a504 1
		return (in6_ifattach_loopback(ifp));
@


1.93
log
@Start moving away from the global prefix list by limiting its usage to
AUTOCONF'd addresses.

This prevent the kernel from removing connected (/64) routes as soon as
it configures an AUTOCONF'd address based on a RA.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.92 2015/08/24 15:58:35 mpi Exp $	*/
d335 2
a336 4
	 * Now call in6_update_ifa() to do a bunch of procedures to configure
	 * a link-local address. In the case of CARP, we may be called after
	 * one has already been configured, so check if it's already there
	 * with in6ifa_ifpforlinklocal() and clobber it if it exists.
d338 3
d344 2
a345 15

	if (error != 0) {
		/*
		 * XXX: When the interface does not support IPv6, this call
		 * would fail in the SIOCSIFADDR ioctl.  I believe the
		 * notification is rather confusing in this case, so just
		 * suppress it.  (jinmei@@kame.net 20010130)
		 */
		if (error != EAFNOSUPPORT)
			nd6log((LOG_NOTICE, "in6_ifattach_linklocal: failed to "
			    "configure a link-local address on %s "
			    "(errno=%d)\n",
			    ifp->if_xname, error));
		return (-1);
	}
d349 2
a350 8
	/*
	 * Perform DAD.
	 *
	 * XXX: Some P2P interfaces seem not to send packets just after
	 * becoming up, so we skip p2p interfaces for safety.
	 */
	if (in6if_do_dad(ifp) && ((ifp->if_flags & IFF_POINTOPOINT) == 0)) {
		ia6->ia6_flags |= IN6_IFF_TENTATIVE;
d352 4
d358 1
d361 7
d369 1
a369 1
	return (error);
@


1.92
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.91 2015/08/17 10:57:24 mpi Exp $	*/
d296 2
a297 1
	int  s, error;
d359 2
d367 1
a367 4
	if (in6if_do_dad(ifp) && ((ifp->if_flags & IFF_POINTOPOINT) ||
	    (ifp->if_type == IFT_CARP)) == 0) {
		struct in6_ifaddr *ia6;
		ia6 = in6ifa_ifpforlinklocal(ifp, 0);
d372 2
a373 10
	/*
	 * Make the link-local prefix (fe80::/64%link) as on-link.
	 * Since we'd like to manage prefixes separately from addresses,
	 * we make an ND6 prefix structure for the link-local prefix,
	 * and add it to the prefix list as a never-expire prefix.
	 * XXX: this change might affect some existing code base...
	 */
	if (nd6_prefix_add(ifp, &ifra.ifra_addr, &ifra.ifra_prefixmask,
		&ifra.ifra_lifetime, 1) == NULL)
		return (EINVAL);
d375 1
a375 1
	return (0);
@


1.91
log
@Remove anoying comment about in6_update_ifa().
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.90 2015/07/18 15:05:32 mpi Exp $	*/
a294 1
	struct in6_ifaddr *ia6;
a333 6
	 * Do not let in6_update_ifa() do DAD, since we need a random delay
	 * before sending an NS at the first time the interface becomes up.
	 */
	ifra.ifra_flags |= IN6_IFF_NODAD;

	/*
d359 2
a360 1
	 * Adjust ia6_flags so that in6_ifattach() will perform DAD.
a363 7
	ia6 = in6ifa_ifpforlinklocal(ifp, 0); /* ia6 must not be NULL */
#ifdef DIAGNOSTIC
	if (!ia6) {
		panic("ia6 == NULL in in6_ifattach_linklocal");
		/* NOTREACHED */
	}
#endif
d366 2
a367 1
		ia6->ia6_flags &= ~IN6_IFF_NODAD;
d369 1
a414 3
	/* we don't need to perform DAD on loopback interfaces. */
	ifra.ifra_flags |= IN6_IFF_NODAD;

a480 3
	struct ifaddr *ifa;
	int dad_delay = 0;		/* delay ticks before DAD output */

a514 8
	}

	/* Perform DAD. */
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		if (ifatoia6(ifa)->ia6_flags & IN6_IFF_TENTATIVE)
			nd6_dad_start(ifa, &dad_delay);
@


1.90
log
@Merge two identical chunks to add new prefixes to the global data
structures into a function.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.89 2015/07/16 15:31:35 mpi Exp $	*/
a302 5

	/*
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
	 */
a303 1

a404 5

	/*
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
	 */
a405 1

@


1.89
log
@Properly layer Router Solicitation code.

Tweak and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.88 2015/06/08 22:19:28 krw Exp $	*/
d297 1
a297 2
	struct nd_prefix pr0;
	int i, s, error;
d396 3
a398 30
	bzero(&pr0, sizeof(pr0));
	pr0.ndpr_ifp = ifp;
	/* this should be 64 at this moment. */
	pr0.ndpr_plen = in6_mask2len(&ifra.ifra_prefixmask.sin6_addr, NULL);
	pr0.ndpr_mask = ifra.ifra_prefixmask.sin6_addr;
	pr0.ndpr_prefix = ifra.ifra_addr;
	/* apply the mask for safety. (nd6_prelist_add will apply it again) */
	for (i = 0; i < 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
		    in6mask64.s6_addr32[i];
	}
	/*
	 * Initialize parameters.  The link-local prefix must always be
	 * on-link, and its lifetimes never expire.
	 */
	pr0.ndpr_raf_onlink = 1;
	pr0.ndpr_raf_auto = 1;	/* probably meaningless */
	pr0.ndpr_vltime = ND6_INFINITE_LIFETIME;
	pr0.ndpr_pltime = ND6_INFINITE_LIFETIME;
	/*
	 * Since there is no other link-local addresses, nd6_prefix_lookup()
	 * probably returns NULL.  However, we cannot always expect the result.
	 * For example, if we first remove the (only) existing link-local
	 * address, and then reconfigure another one, the prefix is still
	 * valid with referring to the old link-local address.
	 */
	if (nd6_prefix_lookup(&pr0) == NULL) {
		if ((error = nd6_prelist_add(&pr0, NULL, NULL)) != 0)
			return (error);
	}
d400 1
a400 1
	return 0;
@


1.88
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.87 2015/04/27 14:51:44 mpi Exp $	*/
d583 1
a583 1
		nd6_rs_output_set_timo(ND6_RS_OUTPUT_QUICK_INTERVAL);
d642 1
a642 6
		nd6_rs_timeout_count--;
		if (nd6_rs_timeout_count == 0)
			timeout_del(&nd6_rs_output_timer);
		if (RS_LHCOOKIE(ifp) != NULL)
			hook_disestablish(ifp->if_linkstatehooks,
			    RS_LHCOOKIE(ifp));
@


1.87
log
@Do not call nd6_purge() before purging the IPv6 addresses of a detached
interface.

Fix a use after free introduced in r1.98 of netinet6/in6.c and recently
exposed by a crazy pool/malloc damage finder being currently refined by
dlg@@ and deraadt@@.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.86 2015/03/14 03:38:52 jsg Exp $	*/
d483 1
a483 1
in6_nigroup(struct ifnet *ifp, const char *name, int namelen, 
@


1.86
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.85 2015/02/05 03:01:03 mpi Exp $	*/
a602 3
	/* remove neighbor management table */
	nd6_purge(ifp);

d612 2
a613 6
	 * remove neighbor management table.  we call it twice just to make
	 * sure we nuke everything.  maybe we need just one call.
	 * XXX: since the first call did not release addresses, some prefixes
	 * might remain.  We should call nd6_purge() again to release the
	 * prefixes after removing all addresses above.
	 * (Or can we just delay calling nd6_purge until at this point?)
@


1.85
log
@Convert various rtrequest1(RTM_DELETE,...) calls to rtdeletemsg(9).

This unify some code and notify userland for free.

blambert@@ agrees, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.84 2015/01/28 22:10:13 mpi Exp $	*/
a48 1
#include <netinet/if_ether.h>
@


1.84
log
@Revert rtdeletemsg conversion.  It was not ok'd, I misunderstood bluhm@@'s
email.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.83 2015/01/27 10:31:19 mpi Exp $	*/
d633 1
a633 9
		struct rt_addrinfo info;

		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    ifp->if_rdomain);
d645 1
a645 9
		struct rt_addrinfo info;

		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    ifp->if_rdomain);
@


1.83
log
@Ensure that link-local addresses are correctly configured on loopback
interfaces.

When the kernel automagically configures IPv6 addresses on loopback
interfaces, start by assigning a link-local address and then try to
assign "::1".

Only the first configured loopback interface per rdomain can have the
"::1" address.  But even if other loopback interfaces failed to get
this address, because it is already taken, give them a chance to have
a link-local address.

While here change in6_ifattach() to return an error value and remove
duplicated code.

Fix a regression introduced by the NOINET6 flag removal.

ok henning@@, stsp@@, florian@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.82 2015/01/26 11:38:37 mpi Exp $	*/
d633 9
a641 1
		rtdeletemsg(rt, ifp->if_rdomain);
d653 9
a661 1
		rtdeletemsg(rt, ifp->if_rdomain);
@


1.82
log
@Call rtdeletemsg(9) instead of rerolling its code.  As a bonus you'll
get userland notification for free.

ok blambert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.81 2015/01/10 11:43:37 mpi Exp $	*/
a59 2
int ip6_auto_linklocal = 1;	/* enable by default */

a431 4
/*
 * ifp - must be IFT_LOOP
 */

d436 2
a437 1
	int error;
d474 1
a474 8
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
		nd6log((LOG_ERR, "in6_ifattach_loopback: failed to configure "
		    "the loopback address on %s (errno=%d)\n",
		    ifp->if_xname, error));
		return (-1);
	}

	return 0;
d533 1
a533 1
void
d537 1
a537 2
	struct in6_ifaddr *ia6;
	int dad_delay;		/* delay ticks before DAD output */
d545 1
a545 1
		return;
d553 5
a557 6
	if (ifp->if_mtu < IPV6_MMTU) {
		nd6log((LOG_INFO, "in6_ifattach: "
		    "%s has too small MTU, IPv6 not enabled\n",
		    ifp->if_xname));
		return;
	}
d559 5
a563 8
	/*
	 * usually, we require multicast capability to the interface
	 */
	if ((ifp->if_flags & IFF_MULTICAST) == 0) {
		nd6log((LOG_INFO, "in6_ifattach: "
		    "%s is not multicast capable, IPv6 not enabled\n",
		    ifp->if_xname));
		return;
d566 2
a567 5
	/*
	 * assign loopback address for loopback interface.
	 * XXX multiple loopback interface case.
	 */
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
d569 2
a570 5
		if (in6ifa_ifpwithaddr(ifp, &in6) == NULL) {
			if (in6_ifattach_loopback(ifp) != 0)
				return;
		}
	}
d572 1
a572 12
	/*
	 * assign a link-local address, if there's none.
	 */
	if (ip6_auto_linklocal) {
		ia6 = in6ifa_ifpforlinklocal(ifp, 0);
		if (ia6 == NULL) {
			if (in6_ifattach_linklocal(ifp, NULL) == 0) {
				/* linklocal address assigned */
			} else {
				/* failed to assign linklocal address. bark? */
			}
		}
d575 1
a575 4
	/*
	 * perform DAD.
	 */
	dad_delay = 0;
d579 1
a579 2
		ia6 = ifatoia6(ifa);
		if (ia6->ia6_flags & IN6_IFF_TENTATIVE)
d585 2
@


1.81
log
@Correct some comments and merge in6_if_up() into in6_ifattach() to
reflect that IPv6 link-local addresses are no longer automagically
configured the first time an interface is brought up.

ok henning@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.80 2015/01/08 17:21:01 florian Exp $	*/
d669 1
a669 9
		struct rt_addrinfo info;

		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    ifp->if_rdomain);
d681 1
a681 9
		struct rt_addrinfo info;

		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    ifp->if_rdomain);
@


1.80
log
@Clear autoconf6 flag after autoconf6 cleanup happened, not before.
Otherwise clean up code will never run.
OK mpi@@, benno@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.79 2015/01/06 21:26:46 stsp Exp $	*/
a346 1
	 * Instead, in6_if_up() will start DAD with a proper random delay.
d376 1
a376 1
	 * Adjust ia6_flags so that in6_if_up will perform DAD.
d548 1
d550 1
a550 1
	struct in6_addr in6;
d588 1
a588 1
		in6 = in6addr_loopback;
d608 15
@


1.79
log
@Remove the NOINET6 interface flag, a left-over from the times when IPv6
was enabled by default. Add AFATTACH/AFDETACH ioctls which enable/disable
an address family for an interface (currently used for IPv6 only).

New kernel needs new ifconfig for IPv6 configuration (address assignment
still works with old ifconfig making this easy to cross over).

Committing on behalf of henning@@ who is currently lebensmittelvergiftet.
ok stsp, benno, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.78 2014/12/04 00:02:15 tedu Exp $	*/
a619 2
	ifp->if_xflags &= ~IFXF_AUTOCONF6;

d693 1
@


1.78
log
@replace md5 with sha512. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.77 2014/11/20 09:55:57 mpi Exp $	*/
d619 2
@


1.77
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.76 2014/11/18 23:55:01 krw Exp $	*/
d40 1
a40 1
#include <crypto/md5.h>
d83 1
a83 1
 * We currently use MD5(hostname) for it.
d90 2
a91 2
	MD5_CTX ctxt;
	u_int8_t digest[16];
d100 3
a102 4
	bzero(&ctxt, sizeof(ctxt));
	MD5Init(&ctxt);
	MD5Update(&ctxt, hostname, hostnamelen);
	MD5Final(digest, &ctxt);
d502 2
a503 2
	MD5_CTX ctxt;
	u_int8_t digest[16];
d524 4
a527 5
	bzero(&ctxt, sizeof(ctxt));
	MD5Init(&ctxt);
	MD5Update(&ctxt, &l, sizeof(l));
	MD5Update(&ctxt, n, l);
	MD5Final(digest, &ctxt);
@


1.76
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.75 2014/11/18 02:37:31 tedu Exp $	*/
a58 2

unsigned long in6_maxmtu = 0;
@


1.75
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.74 2014/11/01 21:40:39 mpi Exp $	*/
a54 1
#include <netinet6/ip6_var.h>
@


1.74
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.73 2014/08/25 14:00:34 florian Exp $	*/
a59 2

#include <dev/rndvar.h>
@


1.73
log
@Move sending of router solicitations to the kernel; receiving and
processing of router advertisements was already in the kernel.
With this rtsol{,d}(8) is no longer necessary.

The kernel starts sending solicitations with
# ifconfig $IF inet6 autoconf
or
inet6 autoconf
in /etc/hostname.$IF.

input stsp@@
much help & OK mpi@@
tweaks & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.72 2014/07/01 19:37:07 benno Exp $	*/
d659 1
a659 1
	rt = rtalloc1(sin6tosa(&sin6), 0, ifp->if_rdomain);
d679 1
a679 1
	rt = rtalloc1(sin6tosa(&sin6), 0, ifp->if_rdomain);
@


1.72
log
@When a carp interface is created with IFXF_NOINET6 flag, no link-local
address will be created when the vhid (and MAC) is set.  Depending on
the order of the configuration the interface can end up with a ipv6
address, but no v6 link-local and no working neigbor discovery.

Removing this case statement will result in the link-local address
being configured by "ifconfig up" if the inet6 address was configured
before. If you are using inet6 on carp, put an "up" at the end of your
hostname.if. I will work on a better solution at g2k14.

ok henning, mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.71 2014/06/26 13:08:25 mpi Exp $	*/
d691 9
@


1.71
log
@Calling in{6,}_purgeaddr() is not enough to remove an address from
an interface.  Two other operations are performed when issuing a
SIOCDIFADDR{_IN6,} ioctl: call the address hook and the per-driver
ioctl function.

Since carp(4) relies on an address hook to recalculate its hash, make
sure to call this hook when IFXF_NOINET6 is set or when the rdomain is
changed.

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.70 2014/06/03 13:32:24 mpi Exp $	*/
a577 11
	}

	/*
	 * quirks based on interface type
	 */
	switch (ifp->if_type) {
	/* we attach a link-local address when a vhid is assigned */
	case IFT_CARP:
		return;
	default:
		break;
@


1.70
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.69 2014/05/20 10:29:01 mpi Exp $	*/
d651 1
@


1.69
log
@Fix eui64 address generation, broken since the removal of the link-layer
address from the per-ifp list.

Found the hard way by weerd@@, florian@@ and stsp@@, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.68 2014/01/21 10:18:26 mpi Exp $	*/
a34 1
#include <sys/malloc.h>
@


1.68
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.67 2014/01/13 23:03:52 bluhm Exp $	*/
a143 1
 * XXX assumes single sockaddr_dl (AF_LINK address) per an interface
a149 1
	struct ifaddr *ifa;
d157 3
a159 13
	TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl == NULL)
			continue;
		if (sdl->sdl_alen == 0)
			continue;

		goto found;
	}

	return -1;
a160 1
found:
@


1.67
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.66 2014/01/07 16:34:05 stsp Exp $	*/
a648 1
	struct ifmaddr *ifma, *mnext;
a664 9
	}


	TAILQ_FOREACH_SAFE(ifma, &ifp->if_maddrlist, ifma_list, mnext) {
		if (ifma->ifma_addr->sa_family != AF_INET6)
			continue;

		ifma->ifma_refcnt = 1;
		in6_delmulti(ifmatoin6m(ifma));
@


1.66
log
@Some follow-up fixes for IFID collision handling in IPv6CP.

Really change the link-local address in the unlikely event of an IFID
collision, instead of going into an infinite conf-nak loop with the peer.

To make the netinet6 code use the IPv6CP IFID in a new link-local address,
in6_ifattach_linklocal() must accept a provided IFID.  Replace the unused
'altifp' parameter with a new 'ifid' parameter for this purpose.

Always use the latest suggested address in IPv6CP replies, even if
the task to update the interface's address hasn't run yet.
Also, clear the ifindex (KAME hack) in addresses sent during IPv6CP.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.65 2014/01/06 13:01:20 stsp Exp $	*/
d318 1
a318 1
	struct in6_ifaddr *ia;
d401 1
a401 1
	ia = in6ifa_ifpforlinklocal(ifp, 0); /* ia must not be NULL */
d403 2
a404 2
	if (!ia) {
		panic("ia == NULL in in6_ifattach_linklocal");
d410 2
a411 2
		ia->ia6_flags &= ~IN6_IFF_NODAD;
		ia->ia6_flags |= IN6_IFF_TENTATIVE;
d570 1
a570 1
	struct in6_ifaddr *ia;
d631 2
a632 2
		ia = in6ifa_ifpforlinklocal(ifp, 0);
		if (ia == NULL) {
@


1.65
log
@Make in6_ifdetach() remove the ff01::1 route for the detaching interface, too.
The route used to linger after an interface detached from IPv6.
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.64 2013/11/28 10:16:44 mpi Exp $	*/
d70 1
a70 1
int get_ifid(struct ifnet *, struct ifnet *, struct in6_addr *);
a259 2
 *
 * altifp - secondary EUI64 source
d262 1
a262 1
get_ifid(struct ifnet *ifp0, struct ifnet *altifp, struct in6_addr *in6)
a272 7
	/* try secondary EUI64 source. this basically is for ATM PVC */
	if (altifp && get_hw_ifid(altifp, in6) == 0) {
		nd6log((LOG_DEBUG, "%s: got interface identifier from %s\n",
		    ifp0->if_xname, altifp->if_xname));
		goto success;
	}

d312 1
a312 1
 * altifp - secondary EUI64 source
d316 1
a316 1
in6_ifattach_linklocal(struct ifnet *ifp, struct ifnet *altifp)
d342 7
d350 1
a350 1
		if (get_ifid(ifp, altifp, &ifra.ifra_addr.sin6_addr) != 0) {
a565 2
 *
 * altifp - secondary EUI64 source
d568 1
a568 1
in6_ifattach(struct ifnet *ifp, struct ifnet *altifp)
d633 1
a633 1
			if (in6_ifattach_linklocal(ifp, altifp) == 0) {
@


1.64
log
@Change the way protocol multicast addresses are linked to an interface.

Instead of linking multicast records to the first configured address of
the corresponding protocol, making this address and its position in the
global list special, add them to a new list directly linked to the
interface descriptor.

This new multicast address list is similar to the address list, all its
elements contain a protocol agnostic part.  This design allows us to
be able to join a multicast group without necessarily having a configured
address.  That means IPv6 multicast kludges are no longer needed.

Another benefit is to be able to add and remove an IP address from an
interface without worrying about multicast records.  That means that the
global IPv4 list is no longer needed since the first configured address
of an interface is no longer special.

This new list might also be extended in the future to contain the
link-layer addresses used to configure hardware filters.

Tested by sthen@@ and weerd@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.63 2013/11/19 09:00:43 mpi Exp $	*/
d690 20
@


1.63
log
@Remove some FDDI/ATM leftovers.

ok mikeb@@, henning@@, deraadt@@, brad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.62 2013/10/17 16:27:45 bluhm Exp $	*/
d44 1
a597 3
	/* create a multicast kludge storage (if we have not had one) */
	in6_createmkludge(ifp);

d653 1
d672 8
a679 2
	/* cleanup multicast address kludge table, if there is any */
	in6_purgemkludge(ifp);
@


1.62
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.61 2013/05/31 15:04:23 bluhm Exp $	*/
a191 2
	case IFT_FDDI:
	case IFT_ATM:
@


1.61
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.60 2013/03/26 00:14:18 bluhm Exp $	*/
a48 1
#include <netinet/in_var.h>
d51 1
@


1.60
log
@Remove a block of dead code in in6_ifdetach().  It was never executed
due to the wrong & in satosin6(&ifa->ifa_addr).  The link local
prefix fe80 was not checked within the IPv6 address, but within
some pointers of the interface address struct.  The whole loop
around this was also never executed as all IPv6 addresses had already
been purged.
OK sperreault@@ mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.59 2013/03/25 14:40:57 mpi Exp $	*/
d694 1
a694 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0, ifp->if_rdomain);
@


1.59
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.58 2013/03/07 09:03:16 mpi Exp $	*/
a655 1
	struct in6_ifaddr *ia;
a658 1
	struct in6_multi_mship *imm;
a672 48
	}

	/* undo everything done by in6_ifattach(), just in case */
	TAILQ_FOREACH_SAFE(ifa, &ifp->if_addrlist, ifa_list, next) {
		if (ifa->ifa_addr->sa_family != AF_INET6
		 || !IN6_IS_ADDR_LINKLOCAL(&satosin6(&ifa->ifa_addr)->sin6_addr)) {
			continue;
		}

		ia = ifatoia6(ifa);

		/*
		 * leave from multicast groups we have joined for the interface
		 */
		while (!LIST_EMPTY(&ia->ia6_memberships)) {
			imm = LIST_FIRST(&ia->ia6_memberships);
			LIST_REMOVE(imm, i6mm_chain);
			in6_leavegroup(imm);
		}

		/* remove from the routing table */
		if ((ia->ia_flags & IFA_ROUTE) &&
		    (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0,
		    ifp->if_rdomain))) {
			struct rt_addrinfo info;
			u_int8_t prio;

			bzero(&info, sizeof(info));
			info.rti_flags = rt->rt_flags;
			prio = rt->rt_priority;
			info.rti_info[RTAX_DST] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_GATEWAY] =
			    (struct sockaddr *)&ia->ia_addr;
			info.rti_info[RTAX_NETMASK] =
			    (struct sockaddr *)&ia->ia_prefixmask;
			rtfree(rt);
			rtrequest1(RTM_DELETE, &info, prio, NULL,
			    ifp->if_rdomain);
		}

		/* remove from the linked list */
		ifa_del(ifp, &ia->ia_ifa);
		ifafree(&ia->ia_ifa);

		/* also remove from the IPv6 address list */
		TAILQ_REMOVE(&in6_ifaddr, ia, ia_list);
		ifafree(&ia->ia_ifa);
@


1.58
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.57 2013/03/04 14:42:25 bluhm Exp $	*/
d656 1
a656 1
	struct in6_ifaddr *ia, *oia;
d720 3
a722 17
		/* also remove from the IPv6 address chain(itojun&jinmei) */
		oia = ia;
		if (oia == (ia = in6_ifaddr))
			in6_ifaddr = ia->ia_next;
		else {
			while (ia->ia_next && (ia->ia_next != oia))
				ia = ia->ia_next;
			if (ia->ia_next)
				ia->ia_next = oia->ia_next;
			else {
				nd6log((LOG_ERR,
				    "%s: didn't unlink in6ifaddr from list\n",
				    ifp->if_xname));
			}
		}

		ifafree(&oia->ia_ifa);
@


1.57
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.56 2012/09/19 09:47:25 bluhm Exp $	*/
d718 1
a718 1
		IFAFREE(&ia->ia_ifa);
d736 1
a736 1
		IFAFREE(&oia->ia_ifa);
@


1.56
log
@Use TAILQ_FOREACH macro for loops.  No binary diff.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.55 2012/08/21 19:50:39 bluhm Exp $	*/
d684 1
a684 1
		ia = (struct in6_ifaddr *)ifa;
@


1.55
log
@Reverse the name and meaning of the IFXF_INET6_PRIVACY interface
flag.  It is now called IFXF_INET6_NOPRIVACY.  So IPv6 privacy
addresses are on by default without resetting the flag during
ifconfig down/up.
OK stsp@@, sperreault@@ (who wrote the same diff)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.54 2012/08/15 14:00:32 sperreault Exp $	*/
d671 1
a671 3
	for (ifa = TAILQ_FIRST(&ifp->if_addrlist);
	    ifa != TAILQ_END(&ifp->if_addrlist); ifa = next) {
		next = TAILQ_NEXT(ifa, ifa_list);
d678 1
a678 4
	for (ifa = TAILQ_FIRST(&ifp->if_addrlist);
	    ifa != TAILQ_END(&ifp->if_addrlist); ifa = next) {
		next = TAILQ_NEXT(ifa, ifa_list);

@


1.54
log
@Enable IPv6 autoconfprivacy by default

diff originally by stsp@@
"please commit it" deraadt@@
"don't care" stsp@@
"don't like" bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.53 2012/01/03 23:41:51 bluhm Exp $	*/
a647 3

	/* Enable autoconf privacy addresses. */
	ifp->if_xflags |= IFXF_INET6_PRIVACY;
@


1.53
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.52 2011/11/24 17:39:55 sperreault Exp $	*/
d648 3
@


1.52
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.51 2010/04/06 14:12:10 stsp Exp $	*/
d722 1
a722 1
		ifa_del(ifp, (struct ifaddr *)ia);
@


1.51
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.50 2010/02/08 12:04:35 jsing Exp $	*/
d702 2
a703 1
		    (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0, 0))) {
d717 2
a718 1
			rtrequest1(RTM_DELETE, &info, prio, NULL, 0);
d763 1
a763 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0, 0);
d772 2
a773 1
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
@


1.50
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.48 2009/01/30 10:47:46 mcbride Exp $	*/
d61 2
d67 1
a67 1
int get_rand_ifid(struct ifnet *, struct in6_addr *);
d93 1
a93 1
get_rand_ifid(struct ifnet *ifp, struct in6_addr *in6)
d124 18
d303 1
a303 1
	if (get_rand_ifid(ifp, in6) == 0) {
@


1.49
log
@instead of fiddling with the per-interface address lists directly in
many places create a proper API (ifa_add / ifa_del) and use it.
ok theo ryan dlg
@
text
@d65 4
a68 4
static int get_rand_ifid(struct ifnet *, struct in6_addr *);
static int get_hw_ifid(struct ifnet *, struct in6_addr *);
static int get_ifid(struct ifnet *, struct ifnet *, struct in6_addr *);
static int in6_ifattach_loopback(struct ifnet *);
d90 1
a90 1
static int
d127 1
a127 1
static int
d244 1
a244 1
static int
d442 1
a442 1
static int
d501 1
a501 1
	struct sockaddr_in6 *sa6)
@


1.48
log
@"XXX: should this be performed under splnet()?"... Yes, yes it should.
Interface configuration causes neighbour discoverery, which runs packets
through parts of the stack that require at least splsoftnet(), like pf and
pfsync.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.47 2008/06/11 19:00:50 mcbride Exp $	*/
d700 1
a700 1
		TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
@


1.47
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.46 2008/05/11 08:13:02 claudio Exp $	*/
d311 1
a311 1
	int i, error;
d360 5
a364 2
	if ((error = in6_update_ifa(ifp, &ifra,
	     in6ifa_ifpforlinklocal(ifp, 0))) != 0) {
@


1.46
log
@rtrequest to rtrequest1 conversion in inet6. With that no rtrequest should
be left over. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.45 2007/06/08 09:31:38 henning Exp $	*/
d87 2
d91 1
a91 3
get_rand_ifid(ifp, in6)
	struct ifnet *ifp;
	struct in6_addr *in6;	/* upper 64bits are preserved */
d124 2
d128 1
a128 3
get_hw_ifid(ifp, in6)
	struct ifnet *ifp;
	struct in6_addr *in6;	/* upper 64bits are preserved */
d241 2
d245 1
a245 4
get_ifid(ifp0, altifp, in6)
	struct ifnet *ifp0;
	struct ifnet *altifp;	/* secondary EUI64 source */
	struct in6_addr *in6;
d301 4
d306 1
a306 3
in6_ifattach_linklocal(ifp, altifp)
	struct ifnet *ifp;
	struct ifnet *altifp;	/*secondary EUI64 source*/
d435 4
d440 1
a440 2
in6_ifattach_loopback(ifp)
	struct ifnet *ifp;	/* must be IFT_LOOP */
d497 2
a498 5
in6_nigroup(ifp, name, namelen, sa6)
	struct ifnet *ifp;
	const char *name;
	int namelen;
	struct sockaddr_in6 *sa6;
d546 2
d550 1
a550 3
in6_ifattach(ifp, altifp)
	struct ifnet *ifp;
	struct ifnet *altifp;	/* secondary EUI64 source */
d631 1
a631 2
in6_ifdetach(ifp)
	struct ifnet *ifp;
@


1.45
log
@kill arcnet leftovers, some pt out by Mike Belopuhov <mkb@@crypt.org.ru>,
some I found afterwards, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.44 2006/11/15 03:07:44 itojun Exp $	*/
a635 1
	short rtflags;
d680 12
a691 1
			rtflags = rt->rt_flags;
d693 1
a693 4
			rtrequest(RTM_DELETE, (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_prefixmask,
			    rtflags, (struct rtentry **)0, 0);
d740 8
a747 2
		rtrequest(RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0, 0);
@


1.44
log
@unifdef -USCOPEDROUTING
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.43 2006/08/31 12:37:31 mcbride Exp $	*/
a202 16
		break;

	case IFT_ARCNET:
		if (addrlen != 1)
			return -1;
		if (!addr[0])
			return -1;

		bzero(&in6->s6_addr[8], 8);
		in6->s6_addr[15] = addr[0];

		/*
		 * due to insufficient bitwidth, we mark it local.
		 */
		in6->s6_addr[8] &= ~EUI64_GBIT;	/* g bit to "individual" */
		in6->s6_addr[8] |= EUI64_UBIT;	/* u bit to "local" */
@


1.43
log
@Automatically add a IPv6 link-local address to carp interfaces when the
virtual MAC address is set. Among other things, this makes route6d work
correctly on systems with carp interfaces.

In order to ensure backwards compatibility, we do not include IPv6
link-local addresses in generating the HMAC, but we accept HMACs with AND
without the link-local addresses. They will be added to the HMAC in a future
release.

In short: this change should only affect backwards compatibility for
IPv6 users who are manually adding link-local addresses on carp interfaces.

testing mtu@@ todd@@
ok mpf@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.42 2006/06/16 16:49:40 henning Exp $	*/
a357 4
#ifdef SCOPEDROUTING
	/* take into account the sin6_scope_id field for routing */
	ifra.ifra_prefixmask.sin6_scope_id = 0xffffffff;
#endif
@


1.42
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.41 2006/05/27 23:40:27 claudio Exp $	*/
a67 1
static int in6_ifattach_linklocal(struct ifnet *, struct ifnet *);
d171 1
d318 1
a318 1
static int
d375 3
a377 3
	 * a link-local address. We can set NULL to the 3rd argument, because
	 * we know there's no other link-local address on the interface
	 * and therefore we are adding one (instead of updating one).
d379 2
a380 1
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
d407 2
a408 1
	if (in6if_do_dad(ifp) && (ifp->if_flags & IFF_POINTOPOINT) == 0) {
d602 1
@


1.41
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.40 2006/03/05 21:48:57 miod Exp $	*/
d697 1
a697 1
		    (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0))) {
d703 1
a703 1
			    rtflags, (struct rtentry **)0);
d748 1
a748 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0);
d751 1
a751 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.40
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.39 2005/05/23 20:10:14 mpf Exp $	*/
d57 1
d59 1
d657 1
d660 1
@


1.39
log
@carp needs a multicast kludge storage.
Fixes PR 4211.
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.38 2005/04/21 23:34:01 itojun Exp $	*/
d137 1
a137 4
	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
d279 1
a279 2
	for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next)
	{
d662 3
a664 3
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = next)
	{
		next = ifa->ifa_list.tqe_next;
d671 3
a673 3
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = next)
	{
		next = ifa->ifa_list.tqe_next;
d685 2
a686 1
		while ((imm = ia->ia6_memberships.lh_first) != NULL) {
@


1.38
log
@remove (now obsolete) handling of IFT_PROPVIRTUAL/bridge*.  tested by camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.37 2004/12/07 20:38:47 mcbride Exp $	*/
a579 1
	case IFT_CARP:
d602 2
@


1.37
log
@Convert carp(4) to behave more like a regular interface, much in the same
style as vlan(4). carp interfaces no longer require the physical interface
to be on the same subnet as the carp interface, or even that the physical
interface has an adress at all, so CARP can now be used on /30 networks.

ok deraadt@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.36 2004/05/07 14:42:27 millert Exp $	*/
a581 6
	case IFT_PROPVIRTUAL:
		if (strncmp("bridge", ifp->if_xname, sizeof("bridge")) == 0 &&
		    '0' <= ifp->if_xname[sizeof("bridge")] &&
		    ifp->if_xname[sizeof("bridge")] <= '9')
			return;
		break;
@


1.36
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.35 2003/07/08 10:23:32 itojun Exp $	*/
d580 1
@


1.35
log
@on interface removal, clear multicast forwarding stuff.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.34 2003/06/28 14:42:16 itojun Exp $	*/
d40 2
a41 1
#include <sys/md5k.h>
@


1.34
log
@i don't think pfsync needs a link-local addr.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.33 2003/05/14 05:23:37 itojun Exp $	*/
d56 1
d661 3
@


1.33
log
@it is unlikely that we introduce 6to4 interface (IFT_STF) to openbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.32 2002/09/12 01:11:54 itojun Exp $	*/
d577 1
@


1.32
log
@configure "next" pointer correctly.  from j@@pureftpd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.31 2002/09/11 03:27:30 itojun Exp $	*/
a220 3
#ifdef IFT_STF
	case IFT_STF:
#endif
a604 10
#ifdef IFT_STF
	case IFT_STF:
		/*
		 * 6to4 interface is a very special kind of beast.
		 * no multicast, no linklocal.  RFC2529 specifies how to make
		 * linklocals for 6to4 interface, but there's no use and
		 * it is rather harmful to have one.
		 */
		return;
#endif
@


1.31
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.30 2002/09/11 03:15:36 itojun Exp $	*/
d688 2
@


1.30
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.29 2002/06/11 07:36:00 itojun Exp $	*/
d129 1
a129 1
	u_int8_t *addr;
d521 1
a521 1
	u_char *q;
d524 2
a525 2
	char l;
	char n[64];	/* a single label must not exceed 63 chars */
d536 1
a536 1
	strncpy(n, name, l);
@


1.29
log
@silence some of log(), as the codepath will be visited for IPv6-non-capable
interfaces too and can be annoying.  net.inet6.icmp6.nd6_debug will
re-enable them.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.28 2002/06/11 07:04:07 itojun Exp $	*/
d354 1
a354 1
			return(-1);
d394 1
a394 1
		return(-1);
d449 1
a449 1
			return(error);
d501 1
a501 1
		return(-1);
@


1.28
log
@whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.27 2002/06/08 21:22:02 itojun Exp $	*/
d390 1
a390 1
			log(LOG_NOTICE, "in6_ifattach_linklocal: failed to "
d393 1
a393 1
			    ifp->if_xname, error);
d498 1
a498 1
		log(LOG_ERR, "in6_ifattach_loopback: failed to configure "
d500 1
a500 1
		    ifp->if_xname, error);
d594 4
a597 1
	if (ifp->if_mtu < IPV6_MMTU)
d599 1
d626 1
a626 1
		log(LOG_INFO, "in6_ifattach: "
d628 1
a628 1
		    ifp->if_xname);
d633 2
a634 2
	 * assign loopback address for loopback interface
	 * XXX multiple loopback interface case
d759 1
a759 1
			rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.27
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.26 2002/06/07 04:34:45 itojun Exp $	*/
d641 1
a641 1
	 * assign a link-local address, if there's none. 
d724 1
a724 1
				nd6log((LOG_ERR, 
@


1.26
log
@whitespace sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.25 2002/05/29 07:54:59 itojun Exp $	*/
d59 2
a63 1
static int in6_ifattach_addaddr(struct ifnet *, struct in6_ifaddr *);
d156 11
d169 1
d173 2
a174 2
		/* IEEE802/EUI64 cases - what others? */

a320 3
/*
 * configure IPv6 interface address.  XXX code duplicated with in.c
 */
d322 1
a322 1
in6_ifattach_addaddr(ifp, ia)
d324 2
d327 3
a329 6
{
	struct in6_ifaddr *oia;
	struct ifaddr *ifa;
	int error;
	int rtflag;
	struct in6_addr llsol;
d332 1
a332 1
	 * initialize if_addrlist, if we are the very first one
d334 1
a334 4
	ifa = TAILQ_FIRST(&ifp->if_addrlist);
	if (ifa == NULL) {
		TAILQ_INIT(&ifp->if_addrlist);
	}
d337 2
a338 1
	 * link the interface address to global list
d340 1
a340 2
	TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	ia->ia_ifa.ifa_refcnt++;
d342 13
a354 32
	/*
	 * Also link into the IPv6 address chain beginning with in6_ifaddr.
	 * kazu opposed it, but itojun & jinmei wanted.
	 */
	if ((oia = in6_ifaddr) != NULL) {
		for (; oia->ia_next; oia = oia->ia_next)
			continue;
		oia->ia_next = ia;
	} else
		in6_ifaddr = ia;
	ia->ia_ifa.ifa_refcnt++;

	/*
	 * give the interface a chance to initialize, in case this
	 * is the first address to be added.
	 */
	if (ifp->if_ioctl != NULL) {
		int s;
		s = splimp();
		error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia);
		splx(s);
	} else
		error = 0;
	if (error) {
		switch (error) {
		case EAFNOSUPPORT:
			printf("%s: IPv6 not supported\n", ifp->if_xname);
			break;
		default:
			printf("%s: SIOCSIFADDR error %d\n", ifp->if_xname,
			    error);
			break;
a355 10

		/* undo changes */
		TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
		IFAFREE(&ia->ia_ifa);
		if (oia)
			oia->ia_next = ia->ia_next;
		else
			in6_ifaddr = ia->ia_next;
		IFAFREE(&ia->ia_ifa);
		return -1;
d358 6
a363 9
	/* configure link-layer address resolution */
	rtflag = 0;
	if (IN6_ARE_ADDR_EQUAL(&ia->ia_prefixmask.sin6_addr, &in6mask128))
		rtflag = RTF_HOST;
	else {
		switch (ifp->if_type) {
		case IFT_LOOP:
#ifdef IFT_STF
		case IFT_STF:
d365 3
a367 9
			rtflag = 0;
			break;
		default:
			ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
			ia->ia_ifa.ifa_flags |= RTF_CLONING;
			rtflag = RTF_CLONING;
			break;
		}
	}
d369 6
a374 13
	/* add route to the interface. */
	rtrequest(RTM_ADD,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)&ia->ia_prefixmask,
		  RTF_UP | rtflag,
		  (struct rtentry **)0);
	ia->ia_flags |= IFA_ROUTE;

	if ((rtflag & RTF_CLONING) != 0 &&
	    (ifp->if_flags & IFF_MULTICAST) != 0) {
		/* Restore saved multicast addresses (if any). */
		in6_restoremkludge(ia, ifp);
d376 7
d384 4
a387 1
		 * join solicited multicast address
d389 6
a394 15
		bzero(&llsol, sizeof(llsol));
		llsol.s6_addr16[0] = htons(0xff02);
		llsol.s6_addr16[1] = htons(ifp->if_index);
		llsol.s6_addr32[1] = 0;
		llsol.s6_addr32[2] = htonl(1);
		llsol.s6_addr32[3] = ia->ia_addr.sin6_addr.s6_addr32[3];
		llsol.s6_addr8[12] = 0xff;
		(void)in6_addmulti(&llsol, ifp, &error);

		/* XXX should we run DAD on other interface types? */
		if (in6if_do_dad(ifp)) {
			/* mark the address TENTATIVE, if needed. */
			ia->ia6_flags |= IN6_IFF_TENTATIVE;
			/* nd6_dad_start() will be called in in6_if_up */
		}
a396 10
	return 0;
}

static int
in6_ifattach_linklocal(ifp, altifp)
	struct ifnet *ifp;
	struct ifnet *altifp;	/*secondary EUI64 source*/
{
	struct in6_ifaddr *ia;

d398 3
a400 1
	 * configure link-local address
d402 10
a411 36
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;

	bzero(&ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	ia->ia_prefixmask.sin6_addr = in6mask64;

	/* just in case */
	bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
	ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_dstaddr.sin6_family = AF_INET6;

	bzero(&ia->ia_addr, sizeof(ia->ia_addr));
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	ia->ia_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ia->ia_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ia->ia_addr.sin6_addr.s6_addr32[1] = 0;
	if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_addr.sin6_addr.s6_addr32[2] = 0;
		ia->ia_addr.sin6_addr.s6_addr32[3] = htonl(1);
	} else {
		if (get_ifid(ifp, altifp, &ia->ia_addr.sin6_addr) != 0) {
			nd6log((LOG_ERR,
			    "%s: no ifid available\n", ifp->if_xname));
			free(ia, M_IFADDR);
			return -1;
		}
d414 36
a449 5
	ia->ia_ifa.ifa_metric = ifp->if_metric;

	if (in6_ifattach_addaddr(ifp, ia) != 0) {
		/* ia will be freed on failure */
		return -1;
d459 4
a462 1
	struct in6_ifaddr *ia;
d465 2
a466 1
	 * configure link-local address
d468 5
a472 11
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;

	bzero(&ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	ia->ia_prefixmask.sin6_addr = in6mask128;
d476 13
a488 16
	 * address, to make getifaddr happier.
	 *
	 * For BSDI, it is mandatory.  The BSDI version of
	 * ifa_ifwithroute() rejects to add a route to the loopback
	 * interface.  Even for other systems, loopback looks somewhat
	 * special.
	 */
	bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
	ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_dstaddr.sin6_family = AF_INET6;
	ia->ia_dstaddr.sin6_addr = in6addr_loopback;

	bzero(&ia->ia_addr, sizeof(ia->ia_addr));
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	ia->ia_addr.sin6_addr = in6addr_loopback;
d490 13
a502 1
	ia->ia_ifa.ifa_metric = ifp->if_metric;
d504 24
a527 2
	if (in6_ifattach_addaddr(ifp, ia) != 0) {
		/* ia will be freed on failure */
d529 12
d543 16
a571 4
	struct sockaddr_in6 mltaddr;
	struct sockaddr_in6 mltmask;
	struct sockaddr_in6 gate;
	struct sockaddr_in6 mask;
a628 38
	 * assign link-local address, if there's none 
	 */
	ia = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia == NULL) {
		if (in6_ifattach_linklocal(ifp, altifp) != 0)
			return;
		ia = in6ifa_ifpforlinklocal(ifp, 0);

		if (ia == NULL) {
			printf("%s: failed to add link-local address\n",
			    ifp->if_xname);

			/* we can't initialize multicasts without link-local */
			return;
		}
	}

	if (ifp->if_flags & IFF_POINTOPOINT) {
		/*
		 * route local address to loopback
		 */
		bzero(&gate, sizeof(gate));
		gate.sin6_len = sizeof(struct sockaddr_in6);
		gate.sin6_family = AF_INET6;
		gate.sin6_addr = in6addr_loopback;
		bzero(&mask, sizeof(mask));
		mask.sin6_len = sizeof(struct sockaddr_in6);
		mask.sin6_family = AF_INET6;
		mask.sin6_addr = in6mask64;
		rtrequest(RTM_ADD,
			  (struct sockaddr *)&ia->ia_addr,
			  (struct sockaddr *)&gate,
			  (struct sockaddr *)&mask,
			  RTF_UP|RTF_HOST,
			  (struct rtentry **)0);
	}

	/*
d632 2
a633 2
	in6 = in6addr_loopback;
	if (ifp->if_flags & IFF_LOOPBACK) {
a639 7
#ifdef DIAGNOSTIC
	if (!ia) {
		panic("ia == NULL in in6_ifattach");
		/*NOTREACHED*/
	}
#endif

d641 1
a641 1
	 * join multicast
d643 7
a649 49
	if (ifp->if_flags & IFF_MULTICAST) {
		int error;	/* not used */
		struct in6_multi *in6m;

		/* Restore saved multicast addresses(if any). */
		in6_restoremkludge(ia, ifp);

		bzero(&mltmask, sizeof(mltmask));
		mltmask.sin6_len = sizeof(struct sockaddr_in6);
		mltmask.sin6_family = AF_INET6;
		mltmask.sin6_addr = in6mask32;

		/*
		 * join link-local all-nodes address
		 */
		bzero(&mltaddr, sizeof(mltaddr));
		mltaddr.sin6_len = sizeof(struct sockaddr_in6);
		mltaddr.sin6_family = AF_INET6;
		mltaddr.sin6_addr = in6addr_linklocal_allnodes;
		mltaddr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);

		IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
		if (in6m == NULL) {
			rtrequest(RTM_ADD,
				  (struct sockaddr *)&mltaddr,
				  (struct sockaddr *)&ia->ia_addr,
				  (struct sockaddr *)&mltmask,
				  RTF_UP|RTF_CLONING,  /* xxx */
				  (struct rtentry **)0);
			(void)in6_addmulti(&mltaddr.sin6_addr, ifp, &error);
		}

		if (ifp->if_flags & IFF_LOOPBACK) {
			in6 = in6addr_loopback;
			ia = in6ifa_ifpwithaddr(ifp, &in6);
			/*
			 * join node-local all-nodes address, on loopback
			 */
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;

			IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
			if (in6m == NULL && ia != NULL) {
				rtrequest(RTM_ADD,
					  (struct sockaddr *)&mltaddr,
					  (struct sockaddr *)&ia->ia_addr,
					  (struct sockaddr *)&mltmask,
					  RTF_UP,
					  (struct rtentry **)0);
				(void)in6_addmulti(&mltaddr.sin6_addr, ifp, &error);
d667 1
a667 4
	struct in6_multi *in6m;

	/* nuke prefix list.  this may try to remove some of ifaddrs as well */
	in6_purgeprefix(ifp);
d678 1
a678 1
		in6_purgeaddr(ifa, ifp);
d691 7
a697 3
		/* leave from all multicast groups joined */
		while ((in6m = LIST_FIRST(&ia->ia6_multiaddrs)) != NULL)
			in6_delmulti(in6m);
d700 2
a701 2
		if ((ia->ia_flags & IFA_ROUTE)
		 && (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0))) {
d704 4
a707 5
			rtrequest(RTM_DELETE,
				(struct sockaddr *)&ia->ia_addr,
				(struct sockaddr *)&ia->ia_addr,
				(struct sockaddr *)&ia->ia_prefixmask,
				rtflags, (struct rtentry **)0);
@


1.25
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.24 2002/05/29 02:59:12 itojun Exp $	*/
d257 1
a257 2
		nd6log((LOG_DEBUG,
		    "%s: got interface identifier from itself\n",
d301 4
a304 7
	nd6log((LOG_INFO, "%s: ifid: "
		"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
		ifp0->if_xname,
		in6->s6_addr[8], in6->s6_addr[9],
		in6->s6_addr[10], in6->s6_addr[11],
		in6->s6_addr[12], in6->s6_addr[13],
		in6->s6_addr[14], in6->s6_addr[15]));
d800 2
a801 2
				    "%s: didn't unlink in6ifaddr from "
				    "list\n", ifp->if_xname));
@


1.24
log
@move per-interface ip6/icmp6 stat to ifnet->if_afdata.   sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.23 2002/05/23 06:56:16 itojun Exp $	*/
d581 8
d604 1
a604 1
		goto statinit;
d634 1
a634 1
			goto statinit;
a731 9

statinit:;

	/* update dynamically. */
	if (in6_maxmtu < ifp->if_mtu)
		in6_maxmtu = ifp->if_mtu;

	/* initialize NDP variables */
	nd6_ifattach(ifp);
@


1.23
log
@simplify condition to perform DAD.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.22 2002/03/14 01:27:11 millert Exp $	*/
a56 4
struct in6_ifstat **in6_ifstat = NULL;
struct icmp6_ifstat **icmp6_ifstat = NULL;
size_t in6_ifstatmax = 0;
size_t icmp6_ifstatmax = 0;
a559 1
	static size_t if_indexlim = 8;
a580 41
	/*
	 * We have some arrays that should be indexed by if_index.
	 * since if_index will grow dynamically, they should grow too.
	 *	struct in6_ifstat **in6_ifstat
	 *	struct icmp6_ifstat **icmp6_ifstat
	 */
	if (in6_ifstat == NULL || icmp6_ifstat == NULL ||
	    if_index >= if_indexlim) {
		size_t n;
		caddr_t q;
		size_t olim;

		olim = if_indexlim;
		while (if_index >= if_indexlim)
			if_indexlim <<= 1;

		/* grow in6_ifstat */
		n = if_indexlim * sizeof(struct in6_ifstat *);
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK);
		bzero(q, n);
		if (in6_ifstat) {
			bcopy((caddr_t)in6_ifstat, q,
				olim * sizeof(struct in6_ifstat *));
			free((caddr_t)in6_ifstat, M_IFADDR);
		}
		in6_ifstat = (struct in6_ifstat **)q;
		in6_ifstatmax = if_indexlim;

		/* grow icmp6_ifstat */
		n = if_indexlim * sizeof(struct icmp6_ifstat *);
		q = (caddr_t)malloc(n, M_IFADDR, M_WAITOK);
		bzero(q, n);
		if (icmp6_ifstat) {
			bcopy((caddr_t)icmp6_ifstat, q,
				olim * sizeof(struct icmp6_ifstat *));
			free((caddr_t)icmp6_ifstat, M_IFADDR);
		}
		icmp6_ifstat = (struct icmp6_ifstat **)q;
		icmp6_ifstatmax = if_indexlim;
	}

a729 11

	if (in6_ifstat[ifp->if_index] == NULL) {
		in6_ifstat[ifp->if_index] = (struct in6_ifstat *)
			malloc(sizeof(struct in6_ifstat), M_IFADDR, M_WAITOK);
		bzero(in6_ifstat[ifp->if_index], sizeof(struct in6_ifstat));
	}
	if (icmp6_ifstat[ifp->if_index] == NULL) {
		icmp6_ifstat[ifp->if_index] = (struct icmp6_ifstat *)
			malloc(sizeof(struct icmp6_ifstat), M_IFADDR, M_WAITOK);
		bzero(icmp6_ifstat[ifp->if_index], sizeof(struct icmp6_ifstat));
	}
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.21 2001/12/07 09:16:07 itojun Exp $	*/
d436 1
a436 8
		switch (ifp->if_type) {
#if 1
		case IFT_ARCNET:
		case IFT_ETHER:
		case IFT_FDDI:
#else
		default:
#endif
@


1.21
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.20 2001/08/23 14:10:33 itojun Exp $	*/
d63 6
a68 6
static int get_rand_ifid __P((struct ifnet *, struct in6_addr *));
static int get_hw_ifid __P((struct ifnet *, struct in6_addr *));
static int get_ifid __P((struct ifnet *, struct ifnet *, struct in6_addr *));
static int in6_ifattach_addaddr __P((struct ifnet *, struct in6_ifaddr *));
static int in6_ifattach_linklocal __P((struct ifnet *, struct ifnet *));
static int in6_ifattach_loopback __P((struct ifnet *));
@


1.21.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.21 2001/12/07 09:16:07 itojun Exp $	*/
d57 4
d63 6
a68 7
int ip6_auto_linklocal = 1;	/* enable by default */

static int get_rand_ifid(struct ifnet *, struct in6_addr *);
static int get_hw_ifid(struct ifnet *, struct in6_addr *);
static int get_ifid(struct ifnet *, struct ifnet *, struct in6_addr *);
static int in6_ifattach_linklocal(struct ifnet *, struct ifnet *);
static int in6_ifattach_loopback(struct ifnet *);
a158 11
	switch (ifp->if_type) {
	case IFT_IEEE1394:
	case IFT_IEEE80211:
		/* IEEE1394 uses 16byte length address starting with EUI64 */
		if (addrlen > 8)
			addrlen = 8;
		break;
	default:
		break;
	}

a160 1
	/* IEEE802/EUI64 cases - what others? */
d164 2
a165 2
	case IFT_IEEE1394:
	case IFT_IEEE80211:
d261 2
a262 1
		nd6log((LOG_DEBUG, "%s: got interface identifier from itself\n",
d306 7
a312 4
	nd6log((LOG_INFO, "%s: ifid: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    ifp0->if_xname, in6->s6_addr[8], in6->s6_addr[9], in6->s6_addr[10],
	    in6->s6_addr[11], in6->s6_addr[12], in6->s6_addr[13],
	    in6->s6_addr[14], in6->s6_addr[15]));
d316 3
d320 1
a320 1
in6_ifattach_linklocal(ifp, altifp)
d322 1
a322 1
	struct ifnet *altifp;	/*secondary EUI64 source*/
d324 5
a328 4
	struct in6_ifaddr *ia;
	struct in6_aliasreq ifra;
	struct nd_prefix pr0;
	int i, error;
d331 1
a331 1
	 * configure link-local address.
d333 4
a336 1
	bzero(&ifra, sizeof(ifra));
d339 1
a339 2
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
d341 2
a342 1
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
d344 32
a375 13
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ifra.ifra_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] = 0;
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		ifra.ifra_addr.sin6_addr.s6_addr32[2] = 0;
		ifra.ifra_addr.sin6_addr.s6_addr32[3] = htonl(1);
	} else {
		if (get_ifid(ifp, altifp, &ifra.ifra_addr.sin6_addr) != 0) {
			nd6log((LOG_ERR,
			    "%s: no ifid available\n", ifp->if_xname));
			return(-1);
d377 10
d389 9
a397 6
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask64;
#ifdef SCOPEDROUTING
	/* take into account the sin6_scope_id field for routing */
	ifra.ifra_prefixmask.sin6_scope_id = 0xffffffff;
d399 9
a407 3
	/* link-local addresses should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;
d409 13
a421 6
	/*
	 * Do not let in6_update_ifa() do DAD, since we need a random delay
	 * before sending an NS at the first time the interface becomes up.
	 * Instead, in6_if_up() will start DAD with a proper random delay.
	 */
	ifra.ifra_flags |= IN6_IFF_NODAD;
a422 7
	/*
	 * Now call in6_update_ifa() to do a bunch of procedures to configure
	 * a link-local address. We can set NULL to the 3rd argument, because
	 * we know there's no other link-local address on the interface
	 * and therefore we are adding one (instead of updating one).
	 */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
d424 1
a424 4
		 * XXX: When the interface does not support IPv6, this call
		 * would fail in the SIOCSIFADDR ioctl.  I believe the
		 * notification is rather confusing in this case, so just
		 * suppress it.  (jinmei@@kame.net 20010130)
d426 22
a447 6
		if (error != EAFNOSUPPORT)
			log(LOG_NOTICE, "in6_ifattach_linklocal: failed to "
			    "configure a link-local address on %s "
			    "(errno=%d)\n",
			    ifp->if_xname, error);
		return(-1);
d450 10
d461 1
a461 3
	 * Adjust ia6_flags so that in6_if_up will perform DAD.
	 * XXX: Some P2P interfaces seem not to send packets just after
	 * becoming up, so we skip p2p interfaces for safety.
d463 36
a498 10
	ia = in6ifa_ifpforlinklocal(ifp, 0); /* ia must not be NULL */
#ifdef DIAGNOSTIC
	if (!ia) {
		panic("ia == NULL in in6_ifattach_linklocal");
		/* NOTREACHED */
	}
#endif
	if (in6if_do_dad(ifp) && (ifp->if_flags & IFF_POINTOPOINT) == 0) {
		ia->ia6_flags &= ~IN6_IFF_NODAD;
		ia->ia6_flags |= IN6_IFF_TENTATIVE;
d501 5
a505 36
	/*
	 * Make the link-local prefix (fe80::/64%link) as on-link.
	 * Since we'd like to manage prefixes separately from addresses,
	 * we make an ND6 prefix structure for the link-local prefix,
	 * and add it to the prefix list as a never-expire prefix.
	 * XXX: this change might affect some existing code base...
	 */
	bzero(&pr0, sizeof(pr0));
	pr0.ndpr_ifp = ifp;
	/* this should be 64 at this moment. */
	pr0.ndpr_plen = in6_mask2len(&ifra.ifra_prefixmask.sin6_addr, NULL);
	pr0.ndpr_mask = ifra.ifra_prefixmask.sin6_addr;
	pr0.ndpr_prefix = ifra.ifra_addr;
	/* apply the mask for safety. (nd6_prelist_add will apply it again) */
	for (i = 0; i < 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
		    in6mask64.s6_addr32[i];
	}
	/*
	 * Initialize parameters.  The link-local prefix must always be
	 * on-link, and its lifetimes never expire.
	 */
	pr0.ndpr_raf_onlink = 1;
	pr0.ndpr_raf_auto = 1;	/* probably meaningless */
	pr0.ndpr_vltime = ND6_INFINITE_LIFETIME;
	pr0.ndpr_pltime = ND6_INFINITE_LIFETIME;
	/*
	 * Since there is no other link-local addresses, nd6_prefix_lookup()
	 * probably returns NULL.  However, we cannot always expect the result.
	 * For example, if we first remove the (only) existing link-local
	 * address, and then reconfigure another one, the prefix is still
	 * valid with referring to the old link-local address.
	 */
	if (nd6_prefix_lookup(&pr0) == NULL) {
		if ((error = nd6_prelist_add(&pr0, NULL, NULL)) != 0)
			return(error);
d515 1
a515 4
	struct in6_aliasreq ifra;
	int error;

	bzero(&ifra, sizeof(ifra));
d518 1
a518 2
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
d520 11
a530 5
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));

	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask128;
d534 16
a549 9
	 * address.  Follows IPv4 practice - see in_ifinit().
	 */
	ifra.ifra_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_dstaddr.sin6_family = AF_INET6;
	ifra.ifra_dstaddr.sin6_addr = in6addr_loopback;

	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_addr = in6addr_loopback;
d551 1
a551 3
	/* the loopback  address should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;
d553 2
a554 38
	/* we don't need to perform DAD on loopback interfaces. */
	ifra.ifra_flags |= IN6_IFF_NODAD;

	/*
	 * We are sure that this is a newly assigned address, so we can set
	 * NULL to the 3rd arg.
	 */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
		log(LOG_ERR, "in6_ifattach_loopback: failed to configure "
		    "the loopback address on %s (errno=%d)\n",
		    ifp->if_xname, error);
		return(-1);
	}

	return 0;
}

/*
 * compute NI group address, based on the current hostname setting.
 * see draft-ietf-ipngwg-icmp-name-lookup-* (04 and later).
 *
 * when ifp == NULL, the caller is responsible for filling scopeid.
 */
int
in6_nigroup(ifp, name, namelen, sa6)
	struct ifnet *ifp;
	const char *name;
	int namelen;
	struct sockaddr_in6 *sa6;
{
	const char *p;
	u_char *q;
	MD5_CTX ctxt;
	u_int8_t digest[16];
	char l;
	char n[64];	/* a single label must not exceed 63 chars */

	if (!namelen || !name)
a555 12

	p = name;
	while (p && *p && *p != '.' && p - name < namelen)
		p++;
	if (p - name > sizeof(n) - 1)
		return -1;	/* label too long */
	l = p - name;
	strncpy(n, name, l);
	n[(int)l] = '\0';
	for (q = n; *q; q++) {
		if ('A' <= *q && *q <= 'Z')
			*q = *q - 'A' + 'a';
a557 16
	/* generate 8 bytes of pseudo-random value. */
	bzero(&ctxt, sizeof(ctxt));
	MD5Init(&ctxt);
	MD5Update(&ctxt, &l, sizeof(l));
	MD5Update(&ctxt, n, l);
	MD5Final(digest, &ctxt);

	bzero(sa6, sizeof(*sa6));
	sa6->sin6_family = AF_INET6;
	sa6->sin6_len = sizeof(*sa6);
	sa6->sin6_addr.s6_addr16[0] = htons(0xff02);
	sa6->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	sa6->sin6_addr.s6_addr8[11] = 2;
	bcopy(digest, &sa6->sin6_addr.s6_addr32[3],
	    sizeof(sa6->sin6_addr.s6_addr32[3]));

d571 5
d594 39
a632 6
	 * if link mtu is too small, don't try to configure IPv6.
	 * remember there could be some link-layer that has special
	 * fragmentation logic.
	 */
	if (ifp->if_mtu < IPV6_MMTU)
		return;
d649 1
a649 1
		return;
d666 38
d707 2
a708 2
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		in6 = in6addr_loopback;
d715 7
d723 1
a723 1
	 * assign a link-local address, if there's none. 
d725 49
a773 7
	if (ip6_auto_linklocal) {
		ia = in6ifa_ifpforlinklocal(ifp, 0);
		if (ia == NULL) {
			if (in6_ifattach_linklocal(ifp, altifp) == 0) {
				/* linklocal address assigned */
			} else {
				/* failed to assign linklocal address. bark? */
d777 20
d811 4
a814 1
	struct in6_multi_mship *imm;
d825 1
a825 1
		in6_purgeaddr(ifa);
d838 3
a840 7
		/*
		 * leave from multicast groups we have joined for the interface
		 */
		while ((imm = ia->ia6_memberships.lh_first) != NULL) {
			LIST_REMOVE(imm, i6mm_chain);
			in6_leavegroup(imm);
		}
d843 2
a844 2
		if ((ia->ia_flags & IFA_ROUTE) &&
		    (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0))) {
d847 5
a851 4
			rtrequest(RTM_DELETE, (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_prefixmask,
			    rtflags, (struct rtentry **)0);
d869 2
a870 2
				    "%s: didn't unlink in6ifaddr from list\n",
				    ifp->if_xname));
@


1.21.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.21.2.1 2002/06/11 03:31:37 art Exp $	*/
d129 1
a129 1
	char *addr;
d354 1
a354 1
			return (-1);
d390 1
a390 1
			nd6log((LOG_NOTICE, "in6_ifattach_linklocal: failed to "
d393 2
a394 2
			    ifp->if_xname, error));
		return (-1);
d449 1
a449 1
			return (error);
d498 1
a498 1
		nd6log((LOG_ERR, "in6_ifattach_loopback: failed to configure "
d500 2
a501 2
		    ifp->if_xname, error));
		return (-1);
d521 1
a521 1
	u_int8_t *q;
d524 2
a525 2
	u_int8_t l;
	u_int8_t n[64];	/* a single label must not exceed 63 chars */
d536 1
a536 1
	strncpy((char *)n, name, l);
d594 1
a594 4
	if (ifp->if_mtu < IPV6_MMTU) {
		nd6log((LOG_INFO, "in6_ifattach: "
		    "%s has too small MTU, IPv6 not enabled\n",
		    ifp->if_xname));
a595 1
	}
d622 1
a622 1
		nd6log((LOG_INFO, "in6_ifattach: "
d624 1
a624 1
		    ifp->if_xname));
d629 2
a630 2
	 * assign loopback address for loopback interface.
	 * XXX multiple loopback interface case.
d641 1
a641 1
	 * assign a link-local address, if there's none.
a683 2
		next = ifa->ifa_list.tqe_next;

d724 1
a724 1
				nd6log((LOG_ERR,
d755 1
a755 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.21.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d221 3
d608 10
@


1.20
log
@suppress printf() on non-multicast interface.
suppress ipv6 initialization for IFT_PFLOG.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.19 2001/08/23 02:42:25 itojun Exp $	*/
d91 1
a91 1
	struct in6_addr *in6;	/*upper 64bits are preserved */
d128 1
a128 1
	struct in6_addr *in6;	/*upper 64bits are preserved */
d254 1
a254 1
	struct ifnet *altifp;	/*secondary EUI64 source*/
@


1.19
log
@don't try to enable IPv6 on IFT_PFLOG.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.18 2001/07/18 12:50:44 itojun Exp $	*/
d644 4
a647 2
		 * 6to4 interface is a very speical kind of beast.
		 * no multicast, no linklocal (based on 03 draft).
d659 2
a660 1
		printf("%s: not multicast capable, IPv6 not enabled\n",
@


1.18
log
@avoid using malloc() during interupt context for multicast kludge entry.
allocate it on interface initialization.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.17 2001/06/09 06:43:37 angelos Exp $	*/
d583 1
@


1.17
log
@No need for net/net_osdep.h
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.16 2001/02/16 15:59:38 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.112 2001/02/10 15:44:59 jinmei Exp $	*/
d632 3
@


1.16
log
@cosmetic sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.15 2001/02/07 11:43:53 itojun Exp $	*/
a56 2
#include <net/net_osdep.h>

d261 3
a263 2
		nd6log((LOG_DEBUG, "%s: got interface identifier from itself\n",
		    if_name(ifp0)));
d270 1
a270 1
		    if_name(ifp0), if_name(altifp)));
d289 1
a289 1
			    if_name(ifp0), if_name(ifp)));
d298 1
a298 1
		    if_name(ifp0)));
d302 1
a302 1
	printf("%s: failed to get interface identifier\n", if_name(ifp0));
d308 1
a308 1
		if_name(ifp0),
d370 1
a370 1
			printf("%s: IPv6 not supported\n", if_name(ifp));
d373 1
a373 1
			printf("%s: SIOCSIFADDR error %d\n", if_name(ifp),
d495 1
a495 1
			    "%s: no ifid available\n", if_name(ifp)));
d654 1
a654 1
		    if_name(ifp));
d669 1
a669 1
			    if_name(ifp));
d863 1
a863 1
				    "list\n", if_name(ifp)));
@


1.15
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.14 2001/01/18 06:48:25 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.102 2001/02/07 11:01:29 itojun Exp $	*/
d874 8
a881 1
	/* remove neighbor management table */
@


1.14
log
@do not remove default route by mistake, on interface removal.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.13 2000/10/25 22:01:02 jason Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.68 2000/10/18 18:44:24 itojun Exp $	*/
d39 1
d218 1
a218 1
		 * mech-06 says: "SHOULD use IPv4 address as ifid source".
d263 2
a264 4
#ifdef ND6_DEBUG
		printf("%s: got interface identifier from itself\n",
		    if_name(ifp0));
#endif
d270 2
a271 4
#ifdef ND6_DEBUG
		printf("%s: got interface identifier from %s\n",
		    if_name(ifp0), if_name(altifp));
#endif
d288 3
a290 5

#ifdef ND6_DEBUG
			printf("%s: borrow interface identifier from %s\n",
			    if_name(ifp0), if_name(ifp));
#endif
d297 3
a299 4
#ifdef ND6_DEBUG
		printf("%s: interface identifier generated by random number\n",
		    if_name(ifp0));
#endif
d307 1
a307 2
#ifdef ND6_DEBUG
	printf("%s: ifid: "
d313 1
a313 2
		in6->s6_addr[14], in6->s6_addr[15]);
#endif
d495 2
a496 3
#ifdef ND6_DEBUG
			printf("%s: no ifid available\n", if_name(ifp));
#endif
d861 5
a865 5
#ifdef ND6_DEBUG
			else
				printf("%s: didn't unlink in6ifaddr from "
				    "list\n", if_name(ifp));
#endif
@


1.13
log
@silence the "no multicast" warning for IFT_ENC, too
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.12 2000/10/18 18:49:39 itojun Exp $	*/
d892 2
a893 1
	if ((rt = rtalloc1((struct sockaddr *)&sin6, 0)) != NULL) {
@


1.12
log
@don't try to configure IPv6 on bridge*.  comment from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.11 2000/10/02 04:45:03 itojun Exp $	*/
d592 1
@


1.11
log
@fix missing \n.  from doug@@freebsd (sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.10 2000/05/05 07:58:15 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.67 2000/10/01 10:51:54 itojun Exp $	*/
d588 12
@


1.10
log
@cope with interface detach (like pcmcia card removal).  remove any
IPv6 addresses assigned to the interface.  reported by ho, bunch of
help from niklas.   KAME PR 231.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.9 2000/04/27 15:40:37 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.53 2000/04/16 14:01:42 itojun Exp $	*/
d273 1
a273 1
		    if_name(ifp0), ifname(altifp));
d309 1
a309 1
	printf("%s: failed to get interface identifier", if_name(ifp0));
d665 1
a665 1
			printf("%s: failed to add link-local address",
@


1.9
log
@correct in6_ifdetach().  free oia, not ia.
Lennart says there are more problems to go (I don't own openbsd-current laptop).
From: Lennart Augustsson <augustss@@augustsson.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.8 2000/04/17 04:44:50 itojun Exp $	*/
d797 1
a797 1
	struct ifaddr *ifa;
d809 11
a819 1
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = ifa->ifa_list.tqe_next)
d829 1
a829 1
		while ((in6m = LIST_FIRST(&oia->ia6_multiaddrs)) != NULL)
d846 1
d864 1
a864 1
		free(oia, M_IFADDR);
@


1.8
log
@revisit in6_ifattach().  (1) make it more persistent about initializaing an
interface (2) cleanup interface id selection.
run NUD on p2p interface (required by spec for bidir p2p interface).
add "ndp -i interface" (can tweak per-interface ND flag).
(sync with more recent kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.7 2000/03/02 09:44:28 itojun Exp $	*/
d853 1
a853 1
		free(ia, M_IFADDR);
@


1.7
log
@do not add ifa_dstaddr for non-pointopoint interface.  IPv6 has no
concept for "broadcast".
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.6 2000/02/07 06:09:10 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.39 2000/03/02 09:24:45 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
a57 2
static	struct in6_addr llsol;

d64 54
a117 3
int found_first_ifid = 0;
#define IFID_LEN 8
static u_int8_t first_ifid[IFID_LEN];
d119 2
a120 2
static int laddr_to_eui64 __P((u_int8_t *, u_int8_t *, size_t));
static int gen_rand_eui64 __P((u_int8_t *));
d122 4
d127 3
a129 4
laddr_to_eui64(dst, src, len)
	u_int8_t *dst;
	u_int8_t *src;
	size_t len;
d131 35
a165 1
	static u_int8_t zero[8];
d167 3
a169 1
	bzero(zero, sizeof(zero));
d171 23
a193 12
	switch (len) {
	case 6:
		if (bcmp(zero, src, 6) == 0)
			return EINVAL;
		dst[0] = src[0];
		dst[1] = src[1];
		dst[2] = src[2];
		dst[3] = 0xff;
		dst[4] = 0xfe;
		dst[5] = src[3];
		dst[6] = src[4];
		dst[7] = src[5];
d195 15
a209 4
	case 8:
		if (bcmp(zero, src, 8) == 0)
			return EINVAL;
		bcopy(src, dst, len);
d211 13
d225 17
a241 1
		return EINVAL;
d248 3
a250 3
 * Generate a last-resort interface identifier, when the machine has no
 * IEEE802/EUI64 address sources.
 * The address should be random, and should not change across reboot.
d253 4
a256 2
gen_rand_eui64(dst)
	u_int8_t *dst;
d258 33
a290 2
	MD5_CTX ctxt;
	u_int8_t digest[16];
d292 7
a298 5
	/* generate 8bytes of pseudo-random value. */
	bzero(&ctxt, sizeof(ctxt));
	MD5Init(&ctxt);
	MD5Update(&ctxt, hostname, hostnamelen);
	MD5Final(digest, &ctxt);
d300 8
a307 2
	/* assumes sizeof(digest) > sizeof(first_ifid) */
	bcopy(digest, dst, 8);
d309 2
a310 3
	/* make sure to set "u" bit to local, and "g" bit to individual. */
	dst[0] &= 0xfe;
	dst[0] |= 0x02;		/* EUI64 "local" */
d312 10
d326 1
a326 3
 * Find first ifid on list of interfaces.
 * This is assumed that ifp0's interface token (for example, IEEE802 MAC)
 * is globally unique.  We may need to have a flag parameter in the future.
d328 4
a331 3
int
in6_ifattach_getifid(ifp0)
	struct ifnet *ifp0;
d333 1
a333 1
	struct ifnet *ifp;
d335 11
a345 3
	u_int8_t *addr = NULL;
	int addrlen = 0;
	struct sockaddr_dl *sdl;
d347 5
a351 2
	if (found_first_ifid)
		return 0;
d353 6
a358 3
	for (ifp = ifnet.tqh_first; ifp; ifp = ifp->if_list.tqe_next)
	{
		if (ifp0 != NULL && ifp0 != ifp)
d360 55
a414 35
		for (ifa = ifp->if_addrlist.tqh_first;
		     ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
			if (ifa->ifa_addr->sa_family != AF_LINK)
				continue;
			sdl = (struct sockaddr_dl *)ifa->ifa_addr;
			if (sdl == NULL)
				continue;
			if (sdl->sdl_alen == 0)
				continue;
			switch (ifp->if_type) {
			case IFT_ETHER:
			case IFT_FDDI:
			case IFT_ATM:
				/* IEEE802/EUI64 cases - what others? */
				addr = LLADDR(sdl);
				addrlen = sdl->sdl_alen;
				/*
				 * to copy ifid from IEEE802/EUI64 interface,
				 * u bit of the source needs to be 0.
				 */
				if ((addr[0] & 0x02) != 0)
					break;
				goto found;
			case IFT_ARCNET:
				/*
				 * ARCnet interface token cannot be used as
				 * globally unique identifier due to its 
				 * small bitwidth.
				 */
				break;
			default:
				break;
			}
d417 35
a451 2
#ifdef DEBUG
	printf("in6_ifattach_getifid: failed to get EUI64");
d453 15
a467 1
	return EADDRNOTAVAIL;
d469 12
a480 3
found:
	if (laddr_to_eui64(first_ifid, addr, addrlen) == 0)
		found_first_ifid = 1;
d482 4
a485 8
	if (found_first_ifid) {
		printf("%s: supplying EUI64: "
			"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
			if_name(ifp),
			first_ifid[0], first_ifid[1],
			first_ifid[2], first_ifid[3],
			first_ifid[4], first_ifid[5],
			first_ifid[6], first_ifid[7]);
d487 4
a490 2
		/* invert u bit to convert EUI64 to RFC2373 interface ID. */
		first_ifid[0] ^= 0x02;
d492 9
a500 1
		return 0;
d502 3
a504 2
#ifdef DEBUG
		printf("in6_ifattach_getifid: failed to get EUI64");
d506 60
a565 1
		return EADDRNOTAVAIL;
d567 2
d574 1
d577 1
a577 1
in6_ifattach(ifp, type, laddr, noloop)
d579 1
a579 4
	u_int type;
	caddr_t laddr;
	/* size_t laddrlen; */
	int noloop;
d586 2
a587 35
	struct in6_ifaddr *ia, *ib, *oia;
	struct ifaddr *ifa;
	int rtflag = 0;

	if (type == IN6_IFT_P2P && found_first_ifid == 0) {
		printf("%s: no ifid available for IPv6 link-local address\n",
			if_name(ifp));
#if 0
		return;
#else
		/* last resort */
		if (gen_rand_eui64(first_ifid) == 0) {
			printf("%s: using random value as EUI64: "
				"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
				if_name(ifp),
				first_ifid[0], first_ifid[1],
				first_ifid[2], first_ifid[3],
				first_ifid[4], first_ifid[5],
				first_ifid[6], first_ifid[7]);
			/*
			 * invert u bit to convert EUI64 to RFC2373 interface
			 * ID.
			 */
			first_ifid[0] ^= 0x02;

			found_first_ifid = 1;
		}
#endif
	}

	if ((ifp->if_flags & IFF_MULTICAST) == 0) {
		printf("%s: not multicast capable, IPv6 not enabled\n",
			if_name(ifp));
		return;
	}
d595 2
a596 2
	if (in6_ifstat == NULL || icmp6_ifstat == NULL
	 || if_index >= if_indexlim) {
d631 1
a631 3
	 * To prevent to assign link-local address to PnP network
	 * cards multiple times. 
	 * This is lengthy for P2P and LOOP but works.
d633 11
a643 10
	ifa = TAILQ_FIRST(&ifp->if_addrlist);
	if (ifa != NULL) {
		for ( ; ifa; ifa = TAILQ_NEXT(ifa, ifa_list)) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			if (IN6_IS_ADDR_LINKLOCAL(&satosin6(ifa->ifa_addr)->sin6_addr))
				return;
		}
	} else {
		TAILQ_INIT(&ifp->if_addrlist);
d647 1
a647 1
	 * link-local address
d649 5
a653 12
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr =    (struct sockaddr *)&ia->ia_addr;
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;

	TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	ia->ia_ifa.ifa_refcnt++;
d656 1
a656 2
	 * Also link into the IPv6 address chain beginning with in6_ifaddr.
	 * kazu opposed it, but itojun & jinmei wanted.
d658 5
a662 66
	if ((oia = in6_ifaddr) != NULL) {
		for (; oia->ia_next; oia = oia->ia_next)
			continue;
		oia->ia_next = ia;
	} else
		in6_ifaddr = ia;
	ia->ia_ifa.ifa_refcnt++;

	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	ia->ia_prefixmask.sin6_addr = in6mask64;

	bzero(&ia->ia_addr, sizeof(struct sockaddr_in6));
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	ia->ia_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ia->ia_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ia->ia_addr.sin6_addr.s6_addr32[1] = 0;

	switch (type) {
	case IN6_IFT_LOOP:
		ia->ia_addr.sin6_addr.s6_addr32[2] = 0;
		ia->ia_addr.sin6_addr.s6_addr32[3] = htonl(1);
		break;
	case IN6_IFT_802:
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		ia->ia_ifa.ifa_flags |= RTF_CLONING;
		rtflag = RTF_CLONING;
		/* fall through */
	case IN6_IFT_P2P802:
		if (laddr == NULL)
			break;
		/* XXX use laddrlen */
		if (laddr_to_eui64(&ia->ia_addr.sin6_addr.s6_addr8[8],
				laddr, 6) != 0) {
			break;
		}
		/* invert u bit to convert EUI64 to RFC2373 interface ID. */
		ia->ia_addr.sin6_addr.s6_addr8[8] ^= 0x02;
		if (found_first_ifid == 0)
			in6_ifattach_getifid(ifp);
		bzero(&ia->ia_dstaddr, sizeof(struct sockaddr_in6));
		ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ia->ia_dstaddr.sin6_family = AF_INET6;
		break;
	case IN6_IFT_P2P:
		bcopy((caddr_t)first_ifid,
		      (caddr_t)&ia->ia_addr.sin6_addr.s6_addr8[8],
		      IFID_LEN);
		bzero(&ia->ia_dstaddr, sizeof(struct sockaddr_in6));
		ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ia->ia_dstaddr.sin6_family = AF_INET6;
		break;
	case IN6_IFT_ARCNET:
		ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
		ia->ia_ifa.ifa_flags |= RTF_CLONING;
		rtflag = RTF_CLONING;
		if (laddr == NULL)
			break;

		/* make non-global IF id out of link-level address */
		bzero(&ia->ia_addr.sin6_addr.s6_addr8[8], 7);
		ia->ia_addr.sin6_addr.s6_addr8[15] = *laddr;
	}

	ia->ia_ifa.ifa_metric = ifp->if_metric;
d664 3
a666 3
	if (ifp->if_ioctl != NULL) {
		int s;
		int error;
d668 2
a669 29
		/*
		 * give the interface a chance to initialize, in case this
		 * is the first address to be added.
		 */
		s = splimp();
		error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia);
		splx(s);

		if (error) {
			switch (error) {
			case EAFNOSUPPORT:
				printf("%s: IPv6 not supported\n",
					if_name(ifp));
				break;
			default:
				printf("%s: SIOCSIFADDR error %d\n",
					if_name(ifp), error);
				break;
			}

			/* undo changes */
			TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
			IFAFREE(&ia->ia_ifa);
			if (oia)
				oia->ia_next = ia->ia_next;
			else
				in6_ifaddr = ia->ia_next;
			IFAFREE(&ia->ia_ifa);
			return;
d673 1
a673 10
	/* add route to the interface. */
	rtrequest(RTM_ADD,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)&ia->ia_addr, 
		  (struct sockaddr *)&ia->ia_prefixmask,
		  RTF_UP|rtflag,
		  (struct rtentry **)0);
	ia->ia_flags |= IFA_ROUTE;

	if (type == IN6_IFT_P2P || type == IN6_IFT_P2P802) {
d694 2
a695 1
	 * loopback address
d697 7
a703 36
	ib = (struct in6_ifaddr *)NULL;
	if (type == IN6_IFT_LOOP) {
		ib = (struct in6_ifaddr *)
			malloc(sizeof(*ib), M_IFADDR, M_WAITOK);
		bzero((caddr_t)ib, sizeof(*ib));
		ib->ia_ifa.ifa_addr = (struct sockaddr *)&ib->ia_addr;
		ib->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ib->ia_dstaddr;
		ib->ia_ifa.ifa_netmask = (struct sockaddr *)&ib->ia_prefixmask;
		ib->ia_ifp = ifp;

		ia->ia_next = ib;
		TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ib,
			ifa_list);
		ib->ia_ifa.ifa_refcnt++;

		ib->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
		ib->ia_prefixmask.sin6_family = AF_INET6;
		ib->ia_prefixmask.sin6_addr = in6mask128;
		ib->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
		ib->ia_addr.sin6_family = AF_INET6;
		ib->ia_addr.sin6_addr = in6addr_loopback;

		/*
		 * Always initialize ia_dstaddr (= broadcast address)
		 * to loopback address, to make getifaddr happier.
		 *
		 * For BSDI, it is mandatory.  The BSDI version of
		 * ifa_ifwithroute() rejects to add a route to the loopback
		 * interface.  Even for other systems, loopback looks somewhat
		 * special.
		 */
		ib->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ib->ia_dstaddr.sin6_family = AF_INET6;
		ib->ia_dstaddr.sin6_addr = in6addr_loopback;

		ib->ia_ifa.ifa_metric = ifp->if_metric;
d705 4
a708 8
		rtrequest(RTM_ADD,
			  (struct sockaddr *)&ib->ia_addr,
			  (struct sockaddr *)&ib->ia_addr, 
			  (struct sockaddr *)&ib->ia_prefixmask,
			  RTF_UP|RTF_HOST,
			  (struct rtentry **)0);

		ib->ia_flags |= IFA_ROUTE;
d710 1
d717 1
a734 7
		rtrequest(RTM_ADD,
			  (struct sockaddr *)&mltaddr,
			  (struct sockaddr *)&ia->ia_addr, 
			  (struct sockaddr *)&mltmask,
			  RTF_UP|RTF_CLONING,  /* xxx */
			  (struct rtentry **)0);
		(void)in6_addmulti(&mltaddr.sin6_addr, ifp, &error);
d736 2
a737 5
		if (type == IN6_IFT_LOOP) {
			/*
			 * join node-local all-nodes address
			 */
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;
d740 1
a740 1
				  (struct sockaddr *)&ib->ia_addr, 
d742 1
a742 1
				  RTF_UP,
d745 5
a749 1
		} else {
d751 1
a751 1
			 * join solicited multicast address
d753 12
a764 8
			bzero(&llsol, sizeof(llsol));
			llsol.s6_addr16[0] = htons(0xff02);
			llsol.s6_addr16[1] = htons(ifp->if_index);
			llsol.s6_addr32[1] = 0;
			llsol.s6_addr32[2] = htonl(1);
			llsol.s6_addr32[3] = ia->ia_addr.sin6_addr.s6_addr32[3];
			llsol.s6_addr8[12] = 0xff;
			(void)in6_addmulti(&llsol, ifp, &error);
d768 2
a786 23

	/* mark the address TENTATIVE, if needed. */
	switch (ifp->if_type) {
	case IFT_ARCNET:
	case IFT_ETHER:
	case IFT_FDDI:
#if 0
	case IFT_ATM:
	case IFT_SLIP:
	case IFT_PPP:
#endif
		ia->ia6_flags |= IN6_IFF_TENTATIVE;
		/* nd6_dad_start() will be called in in6_if_up */
		break;
	case IFT_DUMMY:
	case IFT_GIF:	/*XXX*/
	case IFT_LOOP:
	case IFT_FAITH:
	default:
		break;
	}

	return;
d829 1
a829 1
				(struct sockaddr *)&ia->ia_addr, 
d846 1
a846 1
#ifdef DEBUG
@


1.6
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_ifattach.c,v 1.5 2000/02/04 18:13:36 itojun Exp $	*/
a52 1
#include <netinet/ip6.h>
d342 4
a345 1
	ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
d350 1
d362 1
d449 1
d454 1
a454 1
			free(ia, M_IFADDR);
d504 1
d512 14
@


1.6.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: in6_ifattach.c,v 1.39 2000/03/02 09:24:45 itojun Exp $	*/
d52 1
d342 1
a342 4
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
a346 1
	ia->ia_ifa.ifa_refcnt++;
a357 1
	ia->ia_ifa.ifa_refcnt++;
a443 1
			IFAFREE(&ia->ia_ifa);
d448 1
a448 1
			IFAFREE(&ia->ia_ifa);
a497 1
		ib->ia_ifa.ifa_refcnt++;
a504 14

		/*
		 * Always initialize ia_dstaddr (= broadcast address)
		 * to loopback address, to make getifaddr happier.
		 *
		 * For BSDI, it is mandatory.  The BSDI version of
		 * ifa_ifwithroute() rejects to add a route to the loopback
		 * interface.  Even for other systems, loopback looks somewhat
		 * special.
		 */
		ib->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ib->ia_dstaddr.sin6_family = AF_INET6;
		ib->ia_dstaddr.sin6_addr = in6addr_loopback;

@


1.6.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.16 2001/02/16 15:59:38 itojun Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.112 2001/02/10 15:44:59 jinmei Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a38 1
#include <sys/syslog.h>
d58 2
d66 16
a81 14
static int get_rand_ifid __P((struct ifnet *, struct in6_addr *));
static int get_hw_ifid __P((struct ifnet *, struct in6_addr *));
static int get_ifid __P((struct ifnet *, struct ifnet *, struct in6_addr *));
static int in6_ifattach_addaddr __P((struct ifnet *, struct in6_ifaddr *));
static int in6_ifattach_linklocal __P((struct ifnet *, struct ifnet *));
static int in6_ifattach_loopback __P((struct ifnet *));

#define EUI64_GBIT	0x01
#define EUI64_UBIT	0x02
#define EUI64_TO_IFID(in6)	do {(in6)->s6_addr[8] ^= EUI64_UBIT; } while (0)
#define EUI64_GROUP(in6)	((in6)->s6_addr[8] & EUI64_GBIT)
#define EUI64_INDIVIDUAL(in6)	(!EUI64_GROUP(in6))
#define EUI64_LOCAL(in6)	((in6)->s6_addr[8] & EUI64_UBIT)
#define EUI64_UNIVERSAL(in6)	(!EUI64_LOCAL(in6))
d83 24
a106 2
#define IFID_LOCAL(in6)		(!EUI64_LOCAL(in6))
#define IFID_UNIVERSAL(in6)	(!EUI64_UNIVERSAL(in6))
d111 1
a111 3
 * The goal here is to get an interface identifier that is
 * (1) random enough and (2) does not change across reboot.
 * We currently use MD5(hostname) for it.
d114 2
a115 3
get_rand_ifid(ifp, in6)
	struct ifnet *ifp;
	struct in6_addr *in6;	/*upper 64bits are preserved */
d120 1
a120 7
#if 0
	/* we need at least several letters as seed for ifid */
	if (hostnamelen < 3)
		return -1;
#endif

	/* generate 8 bytes of pseudo-random value. */
d126 2
a127 2
	/* assumes sizeof(digest) > sizeof(ifid) */
	bcopy(digest, &in6->s6_addr[8], 8);
d130 2
a131 5
	in6->s6_addr[8] &= ~EUI64_GBIT;	/* g bit to "individual" */
	in6->s6_addr[8] |= EUI64_UBIT;	/* u bit to "local" */

	/* convert EUI64 into IPv6 interface identifier */
	EUI64_TO_IFID(in6);
d137 3
a139 2
 * Get interface identifier for the specified interface.
 * XXX assumes single sockaddr_dl (AF_LINK address) per an interface
d141 4
a144 2
static int
get_hw_ifid(ifp, in6)
a145 2
	struct in6_addr *in6;	/*upper 64bits are preserved */
{
d147 2
a149 33
	u_int8_t *addr;
	size_t addrlen;
	static u_int8_t allzero[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	static u_int8_t allone[8] =
		{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

	for (ifa = ifp->if_addrlist.tqh_first;
	     ifa;
	     ifa = ifa->ifa_list.tqe_next)
	{
		if (ifa->ifa_addr->sa_family != AF_LINK)
			continue;
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		if (sdl == NULL)
			continue;
		if (sdl->sdl_alen == 0)
			continue;

		goto found;
	}

	return -1;

found:
	addr = LLADDR(sdl);
	addrlen = sdl->sdl_alen;

	/* get EUI64 */
	switch (ifp->if_type) {
	case IFT_ETHER:
	case IFT_FDDI:
	case IFT_ATM:
		/* IEEE802/EUI64 cases - what others? */
d151 2
a152 3
		/* look at IEEE802/EUI64 only */
		if (addrlen != 8 && addrlen != 6)
			return -1;
a153 104
		/*
		 * check for invalid MAC address - on bsdi, we see it a lot
		 * since wildboar configures all-zero MAC on pccard before
		 * card insertion.
		 */
		if (bcmp(addr, allzero, addrlen) == 0)
			return -1;
		if (bcmp(addr, allone, addrlen) == 0)
			return -1;

		/* make EUI64 address */
		if (addrlen == 8)
			bcopy(addr, &in6->s6_addr[8], 8);
		else if (addrlen == 6) {
			in6->s6_addr[8] = addr[0];
			in6->s6_addr[9] = addr[1];
			in6->s6_addr[10] = addr[2];
			in6->s6_addr[11] = 0xff;
			in6->s6_addr[12] = 0xfe;
			in6->s6_addr[13] = addr[3];
			in6->s6_addr[14] = addr[4];
			in6->s6_addr[15] = addr[5];
		}
		break;

	case IFT_ARCNET:
		if (addrlen != 1)
			return -1;
		if (!addr[0])
			return -1;

		bzero(&in6->s6_addr[8], 8);
		in6->s6_addr[15] = addr[0];

		/*
		 * due to insufficient bitwidth, we mark it local.
		 */
		in6->s6_addr[8] &= ~EUI64_GBIT;	/* g bit to "individual" */
		in6->s6_addr[8] |= EUI64_UBIT;	/* u bit to "local" */
		break;

	case IFT_GIF:
#ifdef IFT_STF
	case IFT_STF:
#endif
		/*
		 * RFC2893 says: "SHOULD use IPv4 address as ifid source".
		 * however, IPv4 address is not very suitable as unique
		 * identifier source (can be renumbered).
		 * we don't do this.
		 */
		return -1;

	default:
		return -1;
	}

	/* sanity check: g bit must not indicate "group" */
	if (EUI64_GROUP(in6))
		return -1;

	/* convert EUI64 into IPv6 interface identifier */
	EUI64_TO_IFID(in6);

	/*
	 * sanity check: ifid must not be all zero, avoid conflict with
	 * subnet router anycast
	 */
	if ((in6->s6_addr[8] & ~(EUI64_GBIT | EUI64_UBIT)) == 0x00 &&
	    bcmp(&in6->s6_addr[9], allzero, 7) == 0) {
		return -1;
	}

	return 0;
}

/*
 * Get interface identifier for the specified interface.  If it is not
 * available on ifp0, borrow interface identifier from other information
 * sources.
 */
static int
get_ifid(ifp0, altifp, in6)
	struct ifnet *ifp0;
	struct ifnet *altifp;	/*secondary EUI64 source*/
	struct in6_addr *in6;
{
	struct ifnet *ifp;

	/* first, try to get it from the interface itself */
	if (get_hw_ifid(ifp0, in6) == 0) {
		nd6log((LOG_DEBUG, "%s: got interface identifier from itself\n",
		    if_name(ifp0)));
		goto success;
	}

	/* try secondary EUI64 source. this basically is for ATM PVC */
	if (altifp && get_hw_ifid(altifp, in6) == 0) {
		nd6log((LOG_DEBUG, "%s: got interface identifier from %s\n",
		    if_name(ifp0), if_name(altifp)));
		goto success;
	}

	/* next, try to get it from some other hardware interface */
d156 1
a156 1
		if (ifp == ifp0)
d158 35
a192 12
		if (get_hw_ifid(ifp, in6) != 0)
			continue;

		/*
		 * to borrow ifid from other interface, ifid needs to be
		 * globally unique
		 */
		if (IFID_UNIVERSAL(in6)) {
			nd6log((LOG_DEBUG,
			    "%s: borrow interface identifier from %s\n",
			    if_name(ifp0), if_name(ifp)));
			goto success;
d195 2
a196 150

	/* last resort: get from random number source */
	if (get_rand_ifid(ifp, in6) == 0) {
		nd6log((LOG_DEBUG,
		    "%s: interface identifier generated by random number\n",
		    if_name(ifp0)));
		goto success;
	}

	printf("%s: failed to get interface identifier\n", if_name(ifp0));
	return -1;

success:
	nd6log((LOG_INFO, "%s: ifid: "
		"%02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
		if_name(ifp0),
		in6->s6_addr[8], in6->s6_addr[9],
		in6->s6_addr[10], in6->s6_addr[11],
		in6->s6_addr[12], in6->s6_addr[13],
		in6->s6_addr[14], in6->s6_addr[15]));
	return 0;
}

/*
 * configure IPv6 interface address.  XXX code duplicated with in.c
 */
static int
in6_ifattach_addaddr(ifp, ia)
	struct ifnet *ifp;
	struct in6_ifaddr *ia;
{
	struct in6_ifaddr *oia;
	struct ifaddr *ifa;
	int error;
	int rtflag;
	struct in6_addr llsol;

	/*
	 * initialize if_addrlist, if we are the very first one
	 */
	ifa = TAILQ_FIRST(&ifp->if_addrlist);
	if (ifa == NULL) {
		TAILQ_INIT(&ifp->if_addrlist);
	}

	/*
	 * link the interface address to global list
	 */
	TAILQ_INSERT_TAIL(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
	ia->ia_ifa.ifa_refcnt++;

	/*
	 * Also link into the IPv6 address chain beginning with in6_ifaddr.
	 * kazu opposed it, but itojun & jinmei wanted.
	 */
	if ((oia = in6_ifaddr) != NULL) {
		for (; oia->ia_next; oia = oia->ia_next)
			continue;
		oia->ia_next = ia;
	} else
		in6_ifaddr = ia;
	ia->ia_ifa.ifa_refcnt++;

	/*
	 * give the interface a chance to initialize, in case this
	 * is the first address to be added.
	 */
	if (ifp->if_ioctl != NULL) {
		int s;
		s = splimp();
		error = (*ifp->if_ioctl)(ifp, SIOCSIFADDR, (caddr_t)ia);
		splx(s);
	} else
		error = 0;
	if (error) {
		switch (error) {
		case EAFNOSUPPORT:
			printf("%s: IPv6 not supported\n", if_name(ifp));
			break;
		default:
			printf("%s: SIOCSIFADDR error %d\n", if_name(ifp),
			    error);
			break;
		}

		/* undo changes */
		TAILQ_REMOVE(&ifp->if_addrlist, (struct ifaddr *)ia, ifa_list);
		IFAFREE(&ia->ia_ifa);
		if (oia)
			oia->ia_next = ia->ia_next;
		else
			in6_ifaddr = ia->ia_next;
		IFAFREE(&ia->ia_ifa);
		return -1;
	}

	/* configure link-layer address resolution */
	rtflag = 0;
	if (IN6_ARE_ADDR_EQUAL(&ia->ia_prefixmask.sin6_addr, &in6mask128))
		rtflag = RTF_HOST;
	else {
		switch (ifp->if_type) {
		case IFT_LOOP:
#ifdef IFT_STF
		case IFT_STF:
#endif
			rtflag = 0;
			break;
		default:
			ia->ia_ifa.ifa_rtrequest = nd6_rtrequest;
			ia->ia_ifa.ifa_flags |= RTF_CLONING;
			rtflag = RTF_CLONING;
			break;
		}
	}

	/* add route to the interface. */
	rtrequest(RTM_ADD,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)&ia->ia_addr,
		  (struct sockaddr *)&ia->ia_prefixmask,
		  RTF_UP | rtflag,
		  (struct rtentry **)0);
	ia->ia_flags |= IFA_ROUTE;

	if ((rtflag & RTF_CLONING) != 0 &&
	    (ifp->if_flags & IFF_MULTICAST) != 0) {
		/* Restore saved multicast addresses (if any). */
		in6_restoremkludge(ia, ifp);

		/*
		 * join solicited multicast address
		 */
		bzero(&llsol, sizeof(llsol));
		llsol.s6_addr16[0] = htons(0xff02);
		llsol.s6_addr16[1] = htons(ifp->if_index);
		llsol.s6_addr32[1] = 0;
		llsol.s6_addr32[2] = htonl(1);
		llsol.s6_addr32[3] = ia->ia_addr.sin6_addr.s6_addr32[3];
		llsol.s6_addr8[12] = 0xff;
		(void)in6_addmulti(&llsol, ifp, &error);

		/* XXX should we run DAD on other interface types? */
		switch (ifp->if_type) {
#if 1
		case IFT_ARCNET:
		case IFT_ETHER:
		case IFT_FDDI:
#else
		default:
d198 1
a198 5
			/* mark the address TENTATIVE, if needed. */
			ia->ia6_flags |= IN6_IFF_TENTATIVE;
			/* nd6_dad_start() will be called in in6_if_up */
		}
	}
d200 3
a202 22
	return 0;
}

static int
in6_ifattach_linklocal(ifp, altifp)
	struct ifnet *ifp;
	struct ifnet *altifp;	/*secondary EUI64 source*/
{
	struct in6_ifaddr *ia;

	/*
	 * configure link-local address
	 */
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	if (ifp->if_flags & IFF_POINTOPOINT)
		ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	else
		ia->ia_ifa.ifa_dstaddr = NULL;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;
d204 8
a211 4
	bzero(&ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	ia->ia_prefixmask.sin6_addr = in6mask64;
d213 2
a214 4
	/* just in case */
	bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
	ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_dstaddr.sin6_family = AF_INET6;
d216 1
a216 9
	bzero(&ia->ia_addr, sizeof(ia->ia_addr));
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	ia->ia_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ia->ia_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ia->ia_addr.sin6_addr.s6_addr32[1] = 0;
	if (ifp->if_flags & IFF_LOOPBACK) {
		ia->ia_addr.sin6_addr.s6_addr32[2] = 0;
		ia->ia_addr.sin6_addr.s6_addr32[3] = htonl(1);
d218 4
a221 13
		if (get_ifid(ifp, altifp, &ia->ia_addr.sin6_addr) != 0) {
			nd6log((LOG_ERR,
			    "%s: no ifid available\n", if_name(ifp)));
			free(ia, M_IFADDR);
			return -1;
		}
	}

	ia->ia_ifa.ifa_metric = ifp->if_metric;

	if (in6_ifattach_addaddr(ifp, ia) != 0) {
		/* ia will be freed on failure */
		return -1;
a222 52

	return 0;
}

static int
in6_ifattach_loopback(ifp)
	struct ifnet *ifp;	/* must be IFT_LOOP */
{
	struct in6_ifaddr *ia;

	/*
	 * configure link-local address
	 */
	ia = (struct in6_ifaddr *)malloc(sizeof(*ia), M_IFADDR, M_WAITOK);
	bzero((caddr_t)ia, sizeof(*ia));
	ia->ia_ifa.ifa_addr = (struct sockaddr *)&ia->ia_addr;
	ia->ia_ifa.ifa_dstaddr = (struct sockaddr *)&ia->ia_dstaddr;
	ia->ia_ifa.ifa_netmask = (struct sockaddr *)&ia->ia_prefixmask;
	ia->ia_ifp = ifp;

	bzero(&ia->ia_prefixmask, sizeof(ia->ia_prefixmask));
	ia->ia_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_prefixmask.sin6_family = AF_INET6;
	ia->ia_prefixmask.sin6_addr = in6mask128;

	/*
	 * Always initialize ia_dstaddr (= broadcast address) to loopback
	 * address, to make getifaddr happier.
	 *
	 * For BSDI, it is mandatory.  The BSDI version of
	 * ifa_ifwithroute() rejects to add a route to the loopback
	 * interface.  Even for other systems, loopback looks somewhat
	 * special.
	 */
	bzero(&ia->ia_dstaddr, sizeof(ia->ia_dstaddr));
	ia->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_dstaddr.sin6_family = AF_INET6;
	ia->ia_dstaddr.sin6_addr = in6addr_loopback;

	bzero(&ia->ia_addr, sizeof(ia->ia_addr));
	ia->ia_addr.sin6_len = sizeof(struct sockaddr_in6);
	ia->ia_addr.sin6_family = AF_INET6;
	ia->ia_addr.sin6_addr = in6addr_loopback;

	ia->ia_ifa.ifa_metric = ifp->if_metric;

	if (in6_ifattach_addaddr(ifp, ia) != 0) {
		/* ia will be freed on failure */
		return -1;
	}

	return 0;
a227 1
 * XXX multiple link-local address case
d230 1
a230 1
in6_ifattach(ifp, altifp)
d232 4
a235 1
	struct ifnet *altifp;	/* secondary EUI64 source */
d242 3
a244 2
	struct in6_ifaddr *ia;
	struct in6_addr in6;
d246 29
a274 4
	/* some of the interfaces are inherently not IPv6 capable */
	switch (ifp->if_type) {
	case IFT_BRIDGE:
	case IFT_ENC:
a275 6
	case IFT_PROPVIRTUAL:
		if (strncmp("bridge", ifp->if_xname, sizeof("bridge")) == 0 &&
		    '0' <= ifp->if_xname[sizeof("bridge")] &&
		    ifp->if_xname[sizeof("bridge")] <= '9')
			return;
		break;
d284 2
a285 2
	if (in6_ifstat == NULL || icmp6_ifstat == NULL ||
	    if_index >= if_indexlim) {
d320 3
a322 1
	 * quirks based on interface type
d324 10
a333 11
	switch (ifp->if_type) {
#ifdef IFT_STF
	case IFT_STF:
		/*
		 * 6to4 interface is a very speical kind of beast.
		 * no multicast, no linklocal (based on 03 draft).
		 */
		goto statinit;
#endif
	default:
		break;
d337 1
a337 1
	 * usually, we require multicast capability to the interface
d339 12
a350 5
	if ((ifp->if_flags & IFF_MULTICAST) == 0) {
		printf("%s: not multicast capable, IPv6 not enabled\n",
		    if_name(ifp));
		return;
	}
d353 2
a354 1
	 * assign link-local address, if there's none 
d356 78
a433 5
	ia = in6ifa_ifpforlinklocal(ifp, 0);
	if (ia == NULL) {
		if (in6_ifattach_linklocal(ifp, altifp) != 0)
			return;
		ia = in6ifa_ifpforlinklocal(ifp, 0);
d435 11
a445 3
		if (ia == NULL) {
			printf("%s: failed to add link-local address\n",
			    if_name(ifp));
d447 9
a455 2
			/* we can't initialize multicasts without link-local */
			goto statinit;
d459 10
a468 1
	if (ifp->if_flags & IFF_POINTOPOINT) {
d489 1
a489 2
	 * assign loopback address for loopback interface
	 * XXX multiple loopback interface case
d491 43
a533 7
	in6 = in6addr_loopback;
	if (ifp->if_flags & IFF_LOOPBACK) {
		if (in6ifa_ifpwithaddr(ifp, &in6) == NULL) {
			if (in6_ifattach_loopback(ifp) != 0)
				return;
		}
	}
d535 1
a535 4
#ifdef DIAGNOSTIC
	if (!ia) {
		panic("ia == NULL in in6_ifattach");
		/*NOTREACHED*/
a536 1
#endif
a542 1
		struct in6_multi *in6m;
d560 7
d568 5
a572 2
		IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
		if (in6m == NULL) {
d575 1
a575 1
				  (struct sockaddr *)&ia->ia_addr,
d577 1
a577 1
				  RTF_UP|RTF_CLONING,  /* xxx */
d580 1
a580 5
		}

		if (ifp->if_flags & IFF_LOOPBACK) {
			in6 = in6addr_loopback;
			ia = in6ifa_ifpwithaddr(ifp, &in6);
d582 1
a582 1
			 * join node-local all-nodes address, on loopback
d584 8
a591 12
			mltaddr.sin6_addr = in6addr_nodelocal_allnodes;

			IN6_LOOKUP_MULTI(mltaddr.sin6_addr, ifp, in6m);
			if (in6m == NULL && ia != NULL) {
				rtrequest(RTM_ADD,
					  (struct sockaddr *)&mltaddr,
					  (struct sockaddr *)&ia->ia_addr,
					  (struct sockaddr *)&mltmask,
					  RTF_UP,
					  (struct rtentry **)0);
				(void)in6_addmulti(&mltaddr.sin6_addr, ifp, &error);
			}
a594 2
statinit:;

d612 23
d645 1
a645 1
	struct ifaddr *ifa, *next;
d657 1
a657 11
	/* nuke any of IPv6 addresses we have */
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = next)
	{
		next = ifa->ifa_list.tqe_next;
		if (ifa->ifa_addr->sa_family != AF_INET6)
			continue;
		in6_purgeaddr(ifa, ifp);
	}

	/* undo everything done by in6_ifattach(), just in case */
	for (ifa = ifp->if_addrlist.tqh_first; ifa; ifa = next)
d667 1
a667 1
		while ((in6m = LIST_FIRST(&ia->ia6_multiaddrs)) != NULL)
d677 1
a677 1
				(struct sockaddr *)&ia->ia_addr,
a683 1
		IFAFREE(&ia->ia_ifa);
d694 5
a698 5
			else {
				nd6log((LOG_ERR, 
				    "%s: didn't unlink in6ifaddr from "
				    "list\n", if_name(ifp)));
			}
d701 1
a701 1
		IFAFREE(&oia->ia_ifa);
d707 1
a707 8
	/*
	 * remove neighbor management table.  we call it twice just to make
	 * sure we nuke everything.  maybe we need just one call.
	 * XXX: since the first call did not release addresses, some prefixes
	 * might remain.  We should call nd6_purge() again to release the
	 * prefixes after removing all addresses above.
	 * (Or can we just delay calling nd6_purge until at this point?)
	 */
d716 1
a716 2
	rt = rtalloc1((struct sockaddr *)&sin6, 0);
	if (rt && rt->rt_ifp == ifp) {
@


1.6.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.6.2.2 2001/05/14 22:40:17 niklas Exp $	*/
d57 2
d263 2
a264 3
		nd6log((LOG_DEBUG,
		    "%s: got interface identifier from itself\n",
		    ifp0->if_xname));
d271 1
a271 1
		    ifp0->if_xname, altifp->if_xname));
d290 1
a290 1
			    ifp0->if_xname, ifp->if_xname));
d299 1
a299 1
		    ifp0->if_xname));
d303 1
a303 1
	printf("%s: failed to get interface identifier\n", ifp0->if_xname);
d309 1
a309 1
		ifp0->if_xname,
d371 1
a371 1
			printf("%s: IPv6 not supported\n", ifp->if_xname);
d374 1
a374 1
			printf("%s: SIOCSIFADDR error %d\n", ifp->if_xname,
d496 1
a496 1
			    "%s: no ifid available\n", ifp->if_xname));
d655 1
a655 1
		    ifp->if_xname);
d670 1
a670 1
			    ifp->if_xname);
d864 1
a864 1
				    "list\n", ifp->if_xname));
@


1.6.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_ifattach.c,v 1.6.2.3 2001/07/04 10:55:20 niklas Exp $	*/
/*	$KAME: in6_ifattach.c,v 1.124 2001/07/18 08:32:51 jinmei Exp $	*/
a582 1
	case IFT_PFLOG:
a632 3
	/* create a multicast kludge storage (if we have not had one) */
	in6_createmkludge(ifp);

d640 2
a641 4
		 * 6to4 interface is a very special kind of beast.
		 * no multicast, no linklocal.  RFC2529 specifies how to make
		 * linklocals for 6to4 interface, but there's no use and
		 * it is rather harmful to have one.
d653 1
a653 2
		log(LOG_INFO, "in6_ifattach: "
		    "%s is not multicast capable, IPv6 not enabled\n",
@


1.6.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 1
a91 1
	struct in6_addr *in6;	/* upper 64bits are preserved */
d128 1
a128 1
	struct in6_addr *in6;	/* upper 64bits are preserved */
d254 1
a254 1
	struct ifnet *altifp;	/* secondary EUI64 source */
@


1.6.2.6
log
@Merge in -current from roughly a week ago
@
text
@d63 6
a68 6
static int get_rand_ifid(struct ifnet *, struct in6_addr *);
static int get_hw_ifid(struct ifnet *, struct in6_addr *);
static int get_ifid(struct ifnet *, struct ifnet *, struct in6_addr *);
static int in6_ifattach_addaddr(struct ifnet *, struct in6_ifaddr *);
static int in6_ifattach_linklocal(struct ifnet *, struct ifnet *);
static int in6_ifattach_loopback(struct ifnet *);
@


1.6.2.7
log
@Sync the SMP branch with 3.3
@
text
@d57 4
a62 2
int ip6_auto_linklocal = 1;	/* enable by default */

d66 1
d132 1
a132 1
	char *addr;
a158 11
	switch (ifp->if_type) {
	case IFT_IEEE1394:
	case IFT_IEEE80211:
		/* IEEE1394 uses 16byte length address starting with EUI64 */
		if (addrlen > 8)
			addrlen = 8;
		break;
	default:
		break;
	}

a160 1
	/* IEEE802/EUI64 cases - what others? */
d164 2
a165 2
	case IFT_IEEE1394:
	case IFT_IEEE80211:
d261 2
a262 1
		nd6log((LOG_DEBUG, "%s: got interface identifier from itself\n",
d306 7
a312 4
	nd6log((LOG_INFO, "%s: ifid: %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    ifp0->if_xname, in6->s6_addr[8], in6->s6_addr[9], in6->s6_addr[10],
	    in6->s6_addr[11], in6->s6_addr[12], in6->s6_addr[13],
	    in6->s6_addr[14], in6->s6_addr[15]));
d316 3
d320 1
a320 1
in6_ifattach_linklocal(ifp, altifp)
d322 1
a322 1
	struct ifnet *altifp;	/*secondary EUI64 source*/
d324 5
a328 4
	struct in6_ifaddr *ia;
	struct in6_aliasreq ifra;
	struct nd_prefix pr0;
	int i, error;
d331 1
a331 1
	 * configure link-local address.
d333 4
a336 1
	bzero(&ifra, sizeof(ifra));
d339 1
a339 2
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
d341 2
a342 1
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));
d344 32
a375 13
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_addr.s6_addr16[0] = htons(0xfe80);
	ifra.ifra_addr.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	ifra.ifra_addr.sin6_addr.s6_addr32[1] = 0;
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		ifra.ifra_addr.sin6_addr.s6_addr32[2] = 0;
		ifra.ifra_addr.sin6_addr.s6_addr32[3] = htonl(1);
	} else {
		if (get_ifid(ifp, altifp, &ifra.ifra_addr.sin6_addr) != 0) {
			nd6log((LOG_ERR,
			    "%s: no ifid available\n", ifp->if_xname));
			return (-1);
d377 10
d389 9
a397 6
	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask64;
#ifdef SCOPEDROUTING
	/* take into account the sin6_scope_id field for routing */
	ifra.ifra_prefixmask.sin6_scope_id = 0xffffffff;
d399 9
a407 3
	/* link-local addresses should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;
d409 13
a421 6
	/*
	 * Do not let in6_update_ifa() do DAD, since we need a random delay
	 * before sending an NS at the first time the interface becomes up.
	 * Instead, in6_if_up() will start DAD with a proper random delay.
	 */
	ifra.ifra_flags |= IN6_IFF_NODAD;
a422 7
	/*
	 * Now call in6_update_ifa() to do a bunch of procedures to configure
	 * a link-local address. We can set NULL to the 3rd argument, because
	 * we know there's no other link-local address on the interface
	 * and therefore we are adding one (instead of updating one).
	 */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
d424 1
a424 4
		 * XXX: When the interface does not support IPv6, this call
		 * would fail in the SIOCSIFADDR ioctl.  I believe the
		 * notification is rather confusing in this case, so just
		 * suppress it.  (jinmei@@kame.net 20010130)
d426 22
a447 6
		if (error != EAFNOSUPPORT)
			nd6log((LOG_NOTICE, "in6_ifattach_linklocal: failed to "
			    "configure a link-local address on %s "
			    "(errno=%d)\n",
			    ifp->if_xname, error));
		return (-1);
d450 10
d461 1
a461 3
	 * Adjust ia6_flags so that in6_if_up will perform DAD.
	 * XXX: Some P2P interfaces seem not to send packets just after
	 * becoming up, so we skip p2p interfaces for safety.
d463 36
a498 10
	ia = in6ifa_ifpforlinklocal(ifp, 0); /* ia must not be NULL */
#ifdef DIAGNOSTIC
	if (!ia) {
		panic("ia == NULL in in6_ifattach_linklocal");
		/* NOTREACHED */
	}
#endif
	if (in6if_do_dad(ifp) && (ifp->if_flags & IFF_POINTOPOINT) == 0) {
		ia->ia6_flags &= ~IN6_IFF_NODAD;
		ia->ia6_flags |= IN6_IFF_TENTATIVE;
d501 5
a505 36
	/*
	 * Make the link-local prefix (fe80::/64%link) as on-link.
	 * Since we'd like to manage prefixes separately from addresses,
	 * we make an ND6 prefix structure for the link-local prefix,
	 * and add it to the prefix list as a never-expire prefix.
	 * XXX: this change might affect some existing code base...
	 */
	bzero(&pr0, sizeof(pr0));
	pr0.ndpr_ifp = ifp;
	/* this should be 64 at this moment. */
	pr0.ndpr_plen = in6_mask2len(&ifra.ifra_prefixmask.sin6_addr, NULL);
	pr0.ndpr_mask = ifra.ifra_prefixmask.sin6_addr;
	pr0.ndpr_prefix = ifra.ifra_addr;
	/* apply the mask for safety. (nd6_prelist_add will apply it again) */
	for (i = 0; i < 4; i++) {
		pr0.ndpr_prefix.sin6_addr.s6_addr32[i] &=
		    in6mask64.s6_addr32[i];
	}
	/*
	 * Initialize parameters.  The link-local prefix must always be
	 * on-link, and its lifetimes never expire.
	 */
	pr0.ndpr_raf_onlink = 1;
	pr0.ndpr_raf_auto = 1;	/* probably meaningless */
	pr0.ndpr_vltime = ND6_INFINITE_LIFETIME;
	pr0.ndpr_pltime = ND6_INFINITE_LIFETIME;
	/*
	 * Since there is no other link-local addresses, nd6_prefix_lookup()
	 * probably returns NULL.  However, we cannot always expect the result.
	 * For example, if we first remove the (only) existing link-local
	 * address, and then reconfigure another one, the prefix is still
	 * valid with referring to the old link-local address.
	 */
	if (nd6_prefix_lookup(&pr0) == NULL) {
		if ((error = nd6_prelist_add(&pr0, NULL, NULL)) != 0)
			return (error);
d515 1
a515 4
	struct in6_aliasreq ifra;
	int error;

	bzero(&ifra, sizeof(ifra));
d518 1
a518 2
	 * in6_update_ifa() does not use ifra_name, but we accurately set it
	 * for safety.
d520 11
a530 5
	strncpy(ifra.ifra_name, ifp->if_xname, sizeof(ifra.ifra_name));

	ifra.ifra_prefixmask.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_prefixmask.sin6_family = AF_INET6;
	ifra.ifra_prefixmask.sin6_addr = in6mask128;
d534 16
a549 5
	 * address.  Follows IPv4 practice - see in_ifinit().
	 */
	ifra.ifra_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_dstaddr.sin6_family = AF_INET6;
	ifra.ifra_dstaddr.sin6_addr = in6addr_loopback;
d551 1
a551 3
	ifra.ifra_addr.sin6_len = sizeof(struct sockaddr_in6);
	ifra.ifra_addr.sin6_family = AF_INET6;
	ifra.ifra_addr.sin6_addr = in6addr_loopback;
d553 2
a554 42
	/* the loopback  address should NEVER expire. */
	ifra.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME;
	ifra.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME;

	/* we don't need to perform DAD on loopback interfaces. */
	ifra.ifra_flags |= IN6_IFF_NODAD;

	/*
	 * We are sure that this is a newly assigned address, so we can set
	 * NULL to the 3rd arg.
	 */
	if ((error = in6_update_ifa(ifp, &ifra, NULL)) != 0) {
		nd6log((LOG_ERR, "in6_ifattach_loopback: failed to configure "
		    "the loopback address on %s (errno=%d)\n",
		    ifp->if_xname, error));
		return (-1);
	}

	return 0;
}

/*
 * compute NI group address, based on the current hostname setting.
 * see draft-ietf-ipngwg-icmp-name-lookup-* (04 and later).
 *
 * when ifp == NULL, the caller is responsible for filling scopeid.
 */
int
in6_nigroup(ifp, name, namelen, sa6)
	struct ifnet *ifp;
	const char *name;
	int namelen;
	struct sockaddr_in6 *sa6;
{
	const char *p;
	u_int8_t *q;
	MD5_CTX ctxt;
	u_int8_t digest[16];
	u_int8_t l;
	u_int8_t n[64];	/* a single label must not exceed 63 chars */

	if (!namelen || !name)
a555 12

	p = name;
	while (p && *p && *p != '.' && p - name < namelen)
		p++;
	if (p - name > sizeof(n) - 1)
		return -1;	/* label too long */
	l = p - name;
	strncpy((char *)n, name, l);
	n[(int)l] = '\0';
	for (q = n; *q; q++) {
		if ('A' <= *q && *q <= 'Z')
			*q = *q - 'A' + 'a';
a557 16
	/* generate 8 bytes of pseudo-random value. */
	bzero(&ctxt, sizeof(ctxt));
	MD5Init(&ctxt);
	MD5Update(&ctxt, &l, sizeof(l));
	MD5Update(&ctxt, n, l);
	MD5Final(digest, &ctxt);

	bzero(sa6, sizeof(*sa6));
	sa6->sin6_family = AF_INET6;
	sa6->sin6_len = sizeof(*sa6);
	sa6->sin6_addr.s6_addr16[0] = htons(0xff02);
	sa6->sin6_addr.s6_addr16[1] = htons(ifp->if_index);
	sa6->sin6_addr.s6_addr8[11] = 2;
	bcopy(digest, &sa6->sin6_addr.s6_addr32[3],
	    sizeof(sa6->sin6_addr.s6_addr32[3]));

d571 5
d594 38
a631 9
	 * if link mtu is too small, don't try to configure IPv6.
	 * remember there could be some link-layer that has special
	 * fragmentation logic.
	 */
	if (ifp->if_mtu < IPV6_MMTU) {
		nd6log((LOG_INFO, "in6_ifattach: "
		    "%s has too small MTU, IPv6 not enabled\n",
		    ifp->if_xname));
		return;
d649 1
a649 1
		return;
d659 1
a659 1
		nd6log((LOG_INFO, "in6_ifattach: "
d661 1
a661 1
		    ifp->if_xname));
d666 40
a705 2
	 * assign loopback address for loopback interface.
	 * XXX multiple loopback interface case.
d707 2
a708 2
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		in6 = in6addr_loopback;
d715 7
d723 1
a723 1
	 * assign a link-local address, if there's none.
d725 49
a773 7
	if (ip6_auto_linklocal) {
		ia = in6ifa_ifpforlinklocal(ifp, 0);
		if (ia == NULL) {
			if (in6_ifattach_linklocal(ifp, altifp) == 0) {
				/* linklocal address assigned */
			} else {
				/* failed to assign linklocal address. bark? */
d777 20
d811 4
a814 1
	struct in6_multi_mship *imm;
d825 1
a825 1
		in6_purgeaddr(ifa);
a830 2
		next = ifa->ifa_list.tqe_next;

d838 3
a840 7
		/*
		 * leave from multicast groups we have joined for the interface
		 */
		while ((imm = ia->ia6_memberships.lh_first) != NULL) {
			LIST_REMOVE(imm, i6mm_chain);
			in6_leavegroup(imm);
		}
d843 2
a844 2
		if ((ia->ia_flags & IFA_ROUTE) &&
		    (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0))) {
d847 5
a851 4
			rtrequest(RTM_DELETE, (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_addr,
			    (struct sockaddr *)&ia->ia_prefixmask,
			    rtflags, (struct rtentry **)0);
d868 3
a870 3
				nd6log((LOG_ERR,
				    "%s: didn't unlink in6ifaddr from list\n",
				    ifp->if_xname));
d899 1
a899 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.6.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d221 3
d608 10
@


1.6.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a55 1
#include <netinet6/ip6_mroute.h>
a576 1
	case IFT_PFSYNC:
a658 3

	/* remove ip6_mrouter stuff */
	ip6_mrouter_detach(ifp);
@


1.6.2.10
log
@Merge with the trunk
@
text
@d40 1
a40 2

#include <crypto/md5.h>
@


1.5
log
@more coverage of in6_ifdetach()'s cleanup process.
bug fix in SIOCGIFADDR_IN6 (point to point case).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.4 2000/02/02 17:16:52 itojun Exp $	*/
d49 1
a49 1
#include <netinet6/ip6.h>
d52 1
a52 1
#include <netinet6/ip6.h>
@


1.4
log
@- improve in6_ifdetach to remove (1) multicast kludge list (2) route to
  link-local allnode multicast (ff02:x::/32)
- fix ifnet refcnt'ing in multicast kludge list management.
- avoid dangling pointer in multicast kludge management.

(angelos, try this version of in6_ifdetach() - it should be better)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.3 1999/12/10 12:34:45 itojun Exp $	*/
d628 7
d645 4
d685 3
@


1.3
log
@use proper type for in6_first_ifid (char -> u_int8_t)
suggested by: deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.2 1999/12/10 10:04:27 angelos Exp $	*/
d225 4
d616 3
d627 1
d670 15
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_ifattach.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d68 1
a68 1
static char first_ifid[IFID_LEN];
d208 4
a211 4
			first_ifid[0] & 0xff, first_ifid[1] & 0xff,
			first_ifid[2] & 0xff, first_ifid[3] & 0xff,
			first_ifid[4] & 0xff, first_ifid[5] & 0xff,
			first_ifid[6] & 0xff, first_ifid[7] & 0xff);
d253 4
a256 4
				first_ifid[0] & 0xff, first_ifid[1] & 0xff,
				first_ifid[2] & 0xff, first_ifid[3] & 0xff,
				first_ifid[4] & 0xff, first_ifid[5] & 0xff,
				first_ifid[6] & 0xff, first_ifid[7] & 0xff);
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 3
#ifdef __bsdi__
#include <crypto/md5.h>
#elif defined(__OpenBSD__)
a38 3
#else
#include <sys/md5.h>
#endif
a46 1
#ifndef __NetBSD__
a47 1
#endif
a118 3
#ifdef __FreeBSD__
	int hostnamelen	= strlen(hostname);
#endif
a153 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
#else
a154 1
#endif
a157 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a160 1
#endif
a237 4
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	struct ifaddr **ifap;
#endif 

a319 13
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	ifa = ifp->if_addrlist;
	if (ifa != NULL) {
		for ( ; ifa; ifa = ifa->ifa_next) {
			ifap = &ifa->ifa_next;
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			if (IN6_IS_ADDR_LINKLOCAL(&satosin6(ifa->ifa_addr)->sin6_addr))
				return;
		}
	} else
		ifap = &ifp->if_addrlist;
#else
a330 1
#endif
d341 1
a341 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	*ifap = (struct ifaddr *)ia;
#else
d343 1
a343 1
#endif
a438 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
			*ifap = NULL;
#else
a439 1
#endif
a491 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		ia->ia_ifa.ifa_next = (struct ifaddr *)ib;
#else
a493 1
#endif
a500 12
#ifdef __bsdi__
		/*
		 * It is necessary to set the loopback address to the dstaddr
		 * field at least for BSDI. Without this setting, the BSDI
		 * version of ifa_ifwithroute() rejects to add a route
		 * to the loopback interface. 
		 */
		ib->ia_dstaddr.sin6_len = sizeof(struct sockaddr_in6);
		ib->ia_dstaddr.sin6_family = AF_INET6;
		ib->ia_dstaddr.sin6_addr = in6addr_loopback;
#endif

a518 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a520 1
#endif
a617 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	struct ifaddr *ifaprev = NULL;
#endif 
a620 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a621 1
#endif
a624 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
			ifaprev = ifa;
#endif
d632 1
a632 5
		 && (rt = rtalloc1((struct sockaddr *)&ia->ia_addr, 0
#ifdef __FreeBSD__
				, 0UL
#endif
				))) {
a642 6
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		if (ifaprev)
			ifaprev->ifa_next = ifa->ifa_next;
		else
			ifp->if_addrlist = ifa->ifa_next;
#else
a643 1
#endif
@

