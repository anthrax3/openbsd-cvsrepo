head	1.99;
access;
symbols
	OPENBSD_6_2_BASE:1.99
	OPENBSD_6_1:1.93.0.4
	OPENBSD_6_1_BASE:1.93
	OPENBSD_6_0:1.90.0.2
	OPENBSD_6_0_BASE:1.90
	OPENBSD_5_9:1.87.0.2
	OPENBSD_5_9_BASE:1.87
	OPENBSD_5_8:1.83.0.4
	OPENBSD_5_8_BASE:1.83
	OPENBSD_5_7:1.80.0.2
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.73.0.4
	OPENBSD_5_6_BASE:1.73
	OPENBSD_5_5:1.70.0.4
	OPENBSD_5_5_BASE:1.70
	OPENBSD_5_4:1.65.0.2
	OPENBSD_5_4_BASE:1.65
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.57.0.2
	OPENBSD_5_2_BASE:1.57
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.47.0.6
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.44.0.6
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.44.0.4
	OPENBSD_4_2_BASE:1.44
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.39.0.2
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.36.0.6
	OPENBSD_3_8_BASE:1.36
	OPENBSD_3_7:1.36.0.4
	OPENBSD_3_7_BASE:1.36
	OPENBSD_3_6:1.36.0.2
	OPENBSD_3_6_BASE:1.36
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.30.0.4
	OPENBSD_3_3_BASE:1.30
	OPENBSD_3_2:1.30.0.2
	OPENBSD_3_2_BASE:1.30
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.30
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.2
	OPENBSD_2_8:1.18.0.2
	OPENBSD_2_8_BASE:1.18
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.10.0.2
	SMP_BASE:1.10
	kame_19991208:1.8
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7;
locks; strict;
comment	@ * @;


1.99
date	2017.09.01.16.48.27;	author florian;	state Exp;
branches;
next	1.98;
commitid	jiXDUeOdnOUwOn8F;

1.98
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.97;
commitid	ZSLEQCt6cCaCd9uI;

1.97
date	2017.07.13.17.17.27;	author florian;	state Exp;
branches;
next	1.96;
commitid	Kfkb0IEhfQMavn7l;

1.96
date	2017.05.30.09.10.49;	author mpi;	state Exp;
branches;
next	1.95;
commitid	Q5fDrBTZQAJBvCQw;

1.95
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.94;
commitid	p51F2KIwIJB1dU8P;

1.94
date	2017.05.04.15.00.24;	author bluhm;	state Exp;
branches;
next	1.93;
commitid	Gef6NNDxonzfVaq2;

1.93
date	2017.02.22.13.46.53;	author renato;	state Exp;
branches;
next	1.92;
commitid	uEO5dkHTARXotdN6;

1.92
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.91;
commitid	T2qzeepA7r1EGy1x;

1.91
date	2016.10.03.12.33.21;	author mpi;	state Exp;
branches;
next	1.90;
commitid	ymldqUr8o0SRU6R6;

1.90
date	2016.06.27.16.33.48;	author jca;	state Exp;
branches;
next	1.89;
commitid	s8BpQvqrMutiVjd6;

1.89
date	2016.06.01.11.11.44;	author jca;	state Exp;
branches;
next	1.88;
commitid	sy5Ke15K2mroYglc;

1.88
date	2016.05.19.11.34.39;	author jca;	state Exp;
branches;
next	1.87;
commitid	vkyQX2LT0UqUpZLs;

1.87
date	2015.12.03.10.34.24;	author tedu;	state Exp;
branches;
next	1.86;
commitid	gajQhAV7FbVEB3lm;

1.86
date	2015.10.29.16.04.10;	author tedu;	state Exp;
branches;
next	1.85;
commitid	T9Dafq4uwVrQzJzv;

1.85
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.84;
commitid	sTEWfQrcV5GjIWc0;

1.84
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.83;
commitid	PcRGyy4jlpJbKkXz;

1.83
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.82;
commitid	4Ro7ulidQXNcMvmM;

1.82
date	2015.04.14.14.18.37;	author mikeb;	state Exp;
branches;
next	1.81;
commitid	UfC3b25UFWsHgffN;

1.81
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.80;
commitid	c7ei8kPelCOOwHXy;

1.80
date	2015.02.09.12.23.22;	author claudio;	state Exp;
branches;
next	1.79;
commitid	lhMJN7NMGgqb766x;

1.79
date	2015.02.09.12.04.27;	author dlg;	state Exp;
branches;
next	1.78;
commitid	UJ02iYJWktCf5Nwe;

1.78
date	2015.01.10.11.43.37;	author mpi;	state Exp;
branches;
next	1.77;
commitid	wic8NM5ErVdwMnNC;

1.77
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.76;
commitid	t9FBKDfc4VDxpEy2;

1.76
date	2014.11.20.09.55.57;	author mpi;	state Exp;
branches;
next	1.75;
commitid	StxeqV93bwujMj7n;

1.75
date	2014.08.31.19.20.44;	author bluhm;	state Exp;
branches;
next	1.74;
commitid	TFx96q904DItsf0v;

1.74
date	2014.08.26.21.44.29;	author florian;	state Exp;
branches;
next	1.73;
commitid	yPNaXDJAsGXelPnV;

1.73
date	2014.07.11.16.39.06;	author henning;	state Exp;
branches;
next	1.72;
commitid	AGagL83SRBC6d7e7;

1.72
date	2014.06.13.15.41.06;	author chrisz;	state Exp;
branches;
next	1.71;
commitid	2pcnaP7uM5ZWrvRB;

1.71
date	2014.04.20.16.48.22;	author naddy;	state Exp;
branches;
next	1.70;

1.70
date	2014.01.22.14.27.20;	author naddy;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.28.21.02.35;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.67;

1.67
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.21.12.27.15;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.28.15.05.32;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2013.03.14.14.28.38;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.60;

1.60
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.59;

1.59
date	2012.09.17.20.01.26;	author yasuoka;	state Exp;
branches;
next	1.58;

1.58
date	2012.09.15.00.47.08;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2012.07.10.11.49.42;	author guenther;	state Exp;
branches;
next	1.56;

1.56
date	2012.06.26.06.39.27;	author guenther;	state Exp;
branches;
next	1.55;

1.55
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.54;

1.54
date	2011.10.13.18.23.40;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.02.13.48.38;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.23.04.45.15;	author yasuoka;	state Exp;
branches;
next	1.51;

1.51
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.06.14.12.10;	author stsp;	state Exp;
branches;
next	1.48;

1.48
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	1.47;

1.47
date	2008.11.25.12.11.44;	author markus;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.45;

1.45
date	2008.03.09.12.03.03;	author sobrado;	state Exp;
branches;
next	1.44;

1.44
date	2007.01.22.06.12.18;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.21.05.37.32;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.17.02.00.21;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.13.00.35.23;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.12.04.58.48;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.11.14.27.13;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.11.08.09.29;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.07.15.32.42;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.07.15.27.58;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.28.03.04.38;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.09.19.10.59.21;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.22.06.52.01;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.30.02.43.52;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2001.03.02.04.55.12;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.16.16.38.14;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.16.16.00.56;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.10.17.21.46.19;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.27.01.43.26;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.07.16.08.18.43;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.25.17.15.51;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.18.17.31.11;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.25.01.22.00;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.19.17.31.40;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.09.07.37.15;	author itojun;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	99.03.24.02.28.22;	author cmetz;	state Exp;
branches;
next	1.6;

1.6
date	99.03.09.05.31.52;	author cmetz;	state Exp;
branches;
next	1.5;

1.5
date	99.02.24.04.36.40;	author cmetz;	state Exp;
branches;
next	1.4;

1.4
date	99.01.11.00.45.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.01.10.02.37.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.01.08.00.50.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.01.07.05.38.13;	author deraadt;	state Exp;
branches;
next	;

1.10.2.1
date	2000.02.20.11.57.31;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	;


desc
@@


1.99
log
@Use in6_get_rand_ifid() instead of get_last_resort_ifid() and delete the
get_last_resort_ifid() function because eww.
Also if your system is so constraint that you end up in
in6_get_rand_ifid() you don't deserve a random ifid that stays
stable over reboots.
Simplify code a bit since get_ifid() can no longer fail. It couldn't
fail before either because that code path was #if 0'ed.
While here sprinkle in some in6_ prefixes, pointed out by stsp.
OK stsp
@
text
@/*	$OpenBSD: in6.h,v 1.98 2017/08/11 19:53:02 bluhm Exp $	*/
/*	$KAME: in6.h,v 1.83 2001/03/29 02:55:07 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in.h	8.3 (Berkeley) 1/3/94
 */

#ifndef __KAME_NETINET_IN_H_INCLUDED_
#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
#endif

#ifndef _NETINET6_IN6_H_
#define _NETINET6_IN6_H_

/*
 * Identification of the network protocol stack
 * for *BSD-current/release: http://www.kame.net/dev/cvsweb2.cgi/kame/COVERAGE
 * has the table of implementation/integration differences.
 */
#define __KAME__

/*
 * IPv6 address
 */
struct in6_addr {
	union {
		u_int8_t   __u6_addr8[16];
		u_int16_t  __u6_addr16[8];
		u_int32_t  __u6_addr32[4];
	} __u6_addr;			/* 128-bit IP6 address */
};

#define s6_addr   __u6_addr.__u6_addr8
#ifdef _KERNEL	/* XXX nonstandard */
#define s6_addr8  __u6_addr.__u6_addr8
#define s6_addr16 __u6_addr.__u6_addr16
#define s6_addr32 __u6_addr.__u6_addr32
#endif

#ifndef INET6_ADDRSTRLEN
#define INET6_ADDRSTRLEN	46
#endif

/*
 * Socket address for IPv6
 */
#if __BSD_VISIBLE
#define SIN6_LEN	/* Indicates sockaddr_in6 has a sin6_len field */
#endif /* __BSD_VISIBLE */
struct sockaddr_in6 {
	u_int8_t	sin6_len;	/* length of this struct(sa_family_t)*/
	sa_family_t	sin6_family;	/* AF_INET6 (sa_family_t) */
	in_port_t	sin6_port;	/* Transport layer port # (in_port_t)*/
	u_int32_t	sin6_flowinfo;	/* IP6 flow information */
	struct in6_addr	sin6_addr;	/* IP6 address */
	u_int32_t	sin6_scope_id;	/* intface scope id */
};


/*
 * Local definition for masks
 */
#ifdef _KERNEL	/* XXX nonstandard */
#define IN6MASK0	{{{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }}}
#define IN6MASK32	{{{ 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, \
			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK64	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK96	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6MASK128	{{{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, \
			    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff }}}

extern const struct sockaddr_in6 sa6_any;

extern const struct in6_addr in6mask0;
extern const struct in6_addr in6mask32;
extern const struct in6_addr in6mask64;
extern const struct in6_addr in6mask96;
extern const struct in6_addr in6mask128;
#endif /* _KERNEL */

/* Both kernel and libc define these for use */
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
extern const struct in6_addr in6addr_intfacelocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allrouters;

#if __BSD_VISIBLE
/*
 * IPv6 route structure
 */
struct route_in6 {
	struct	rtentry *ro_rt;
	u_long		 ro_tableid;	/* padded to long for alignment */
	struct	sockaddr_in6 ro_dst;
};

/*
 * Definition of some useful macros to handle IP6 addresses
 */
#define IN6ADDR_ANY_INIT \
	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
#define IN6ADDR_LOOPBACK_INIT \
	{{{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_NODELOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_INTFACELOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_LINKLOCAL_ALLNODES_INIT \
	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }}}
#define IN6ADDR_LINKLOCAL_ALLROUTERS_INIT \
	{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02 }}}

#define IN6_ARE_ADDR_EQUAL(a, b)			\
    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)

#endif /* __BSD_VISIBLE */

/*
 * Macros started with IPV6_ADDR is KAME local
 */
#define __IPV6_ADDR_INT32_ONE	htonl(1)
#define __IPV6_ADDR_INT32_TWO	htonl(2)
#define __IPV6_ADDR_INT32_MNL	htonl(0xff010000)
#define __IPV6_ADDR_INT32_MLL	htonl(0xff020000)
#define __IPV6_ADDR_INT32_SMP	htonl(0x0000ffff)
#define __IPV6_ADDR_INT16_ULL	htons(0xfe80)
#define __IPV6_ADDR_INT16_USL	htons(0xfec0)
#define __IPV6_ADDR_INT16_MLL	htons(0xff02)

/*
 * Unspecified
 */
#define IN6_IS_ADDR_UNSPECIFIED(a)	\
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) == 0))

/*
 * Loopback
 */
#define IN6_IS_ADDR_LOOPBACK(a)		\
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) == __IPV6_ADDR_INT32_ONE))

/*
 * IPv4 compatible
 */
#define IN6_IS_ADDR_V4COMPAT(a)		\
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) != 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) != __IPV6_ADDR_INT32_ONE))

/*
 * Mapped
 */
#define IN6_IS_ADDR_V4MAPPED(a)		      \
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == __IPV6_ADDR_INT32_SMP))

/*
 * Unicast Scope
 * Note that we must check topmost 10 bits only, not 16 bits (see RFC2373).
 */
#define IN6_IS_ADDR_LINKLOCAL(a)	\
	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0x80))
#define IN6_IS_ADDR_SITELOCAL(a)	\
	(((a)->s6_addr[0] == 0xfe) && (((a)->s6_addr[1] & 0xc0) == 0xc0))

/*
 * Multicast
 */
#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
#define IN6_IS_ADDR_MULTICAST(a)	((a)->s6_addr[0] == 0xff)

#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
#define __IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e

#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_NODELOCAL))
#define IN6_IS_ADDR_MC_INTFACELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_INTFACELOCAL))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_LINKLOCAL))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_SITELOCAL))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_ORGLOCAL))
#define IN6_IS_ADDR_MC_GLOBAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (__IPV6_ADDR_MC_SCOPE(a) == __IPV6_ADDR_SCOPE_GLOBAL))

#ifdef _KERNEL
#define IN6_IS_SCOPE_LINKLOCAL(a)	\
	((IN6_IS_ADDR_LINKLOCAL(a)) ||	\
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)))
#define IN6_IS_SCOPE_EMBED(a)	\
	((IN6_IS_ADDR_LINKLOCAL(a)) ||	\
	 (IN6_IS_ADDR_MC_LINKLOCAL(a)) || \
	 (IN6_IS_ADDR_MC_INTFACELOCAL(a)))

#define IFA6_IS_DEPRECATED(a) \
	((a)->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time_uptime - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_pltime)
#define IFA6_IS_INVALID(a) \
	((a)->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time_uptime - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_vltime)

#endif /* _KERNEL */

/*
 * Options for use with [gs]etsockopt at the IPV6 level.
 * First word of comment is data type; bool is stored in int.
 */
#define IPV6_UNICAST_HOPS	4  /* int; IP6 hops */
#define IPV6_MULTICAST_IF	9  /* u_int; set/get IP6 multicast i/f */
#define IPV6_MULTICAST_HOPS	10 /* u_int; set/get IP6 multicast hops */
#define IPV6_MULTICAST_LOOP	11 /* u_int; set/get IP6 multicast loopback */
#define IPV6_JOIN_GROUP		12 /* ip6_mreq; join a group membership */
#define IPV6_LEAVE_GROUP	13 /* ip6_mreq; leave a group membership */
#define IPV6_PORTRANGE		14 /* int; range to choose for unspec port */
#if __BSD_VISIBLE
#define ICMP6_FILTER		18 /* icmp6_filter; icmp6 filter */
#endif

#define IPV6_CHECKSUM		26 /* int; checksum offset for raw socket */
#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */

/* new socket options introduced in RFC3542 */
#define IPV6_RTHDRDSTOPTS	35 /* ip6_dest; send dst option before rthdr */

#define IPV6_RECVPKTINFO	36 /* bool; recv if, dst addr */
#define IPV6_RECVHOPLIMIT	37 /* bool; recv hop limit */
#define IPV6_RECVRTHDR		38 /* bool; recv routing header */
#define IPV6_RECVHOPOPTS	39 /* bool; recv hop-by-hop option */
#define IPV6_RECVDSTOPTS	40 /* bool; recv dst option after rthdr */

#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */
#define IPV6_RECVPATHMTU	43 /* bool; notify an according MTU */

#define IPV6_PATHMTU		44 /* mtuinfo; get the current path MTU (sopt),
				      4 bytes int; MTU notification (cmsg) */

/* More new socket options introduced in RFC3542 */
#define IPV6_PKTINFO		46 /* in6_pktinfo; send if, src addr */
#define IPV6_HOPLIMIT		47 /* int; send hop limit */
#define IPV6_NEXTHOP		48 /* sockaddr; next hop addr */
#define IPV6_HOPOPTS		49 /* ip6_hbh; send hop-by-hop option */
#define IPV6_DSTOPTS		50 /* ip6_dest; send dst option befor rthdr */
#define IPV6_RTHDR		51 /* ip6_rthdr; send routing header */

#define IPV6_AUTH_LEVEL		53   /* int; authentication used */
#define IPV6_ESP_TRANS_LEVEL	54   /* int; transport encryption */
#define IPV6_ESP_NETWORK_LEVEL	55   /* int; full-packet encryption */
#if __BSD_VISIBLE
#define IPSEC6_OUTSA		56   /* set the outbound SA for a socket */
#endif
#define IPV6_RECVTCLASS		57   /* bool; recv traffic class values */

#define IPV6_AUTOFLOWLABEL	59   /* bool; attach flowlabel automagically */
#define IPV6_IPCOMP_LEVEL	60   /* int; compression */

#define IPV6_TCLASS		61   /* int; send traffic class value */
#define IPV6_DONTFRAG		62   /* bool; disable IPv6 fragmentation */
#define IPV6_PIPEX		63   /* bool; using PIPEX */

#define IPV6_RECVDSTPORT	64   /* bool; receive IP dst port w/dgram */
#define IPV6_MINHOPCOUNT	65   /* int; minimum recv hop limit */

#define IPV6_RTABLE		0x1021	/* int; routing table, see SO_RTABLE */

/* to define items, should talk with KAME guys first, for *BSD compatibility */
#define IPV6_RTHDR_LOOSE	0	/* this hop need not be a neighbor */
#define IPV6_RTHDR_TYPE_0	0	/* IPv6 routing header type 0 */

/*
 * Defaults and limits for options
 */
#define IPV6_DEFAULT_MULTICAST_HOPS 1	/* normally limit m'casts to 1 hop */
#define IPV6_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member */

/*
 * Argument structure for IPV6_JOIN_GROUP and IPV6_LEAVE_GROUP.
 */
struct ipv6_mreq {
	struct in6_addr	ipv6mr_multiaddr;
	unsigned int	ipv6mr_interface;
};

/*
 * IPV6_PKTINFO: Packet information(RFC3542 sec 6)
 */
struct in6_pktinfo {
	struct in6_addr	ipi6_addr;	/* src/dst IPv6 address */
	unsigned int	ipi6_ifindex;	/* send/recv interface index */
};

/*
 * Control structure for IPV6_RECVPATHMTU socket option.
 * XXX Not allowed here by POSIX, but required by RFC 3542, so go
 * XXX with the code on the pavement.
 */
struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;	/* or sockaddr_storage? */
	u_int32_t ip6m_mtu;
};

/*
 * Argument for IPV6_PORTRANGE:
 * - which range to search when port is unspecified at bind() or connect()
 */
#define	IPV6_PORTRANGE_DEFAULT	0	/* default range */
#define	IPV6_PORTRANGE_HIGH	1	/* "high" - request firewall bypass */
#define	IPV6_PORTRANGE_LOW	2	/* "low" - vouchsafe security */

#ifdef __BSD_VISIBLE

#ifndef	_SOCKLEN_T_DEFINED_
#define	_SOCKLEN_T_DEFINED_
typedef	__socklen_t	socklen_t;	/* length type for network syscalls */
#endif

#endif /* __BSD_VISIBLE */

#ifdef _KERNEL
extern	u_char inet6ctlerrmap[];
extern	struct in6_addr zeroin6_addr;

struct mbuf;
struct ifnet;
struct cmsghdr;

void	ipv6_input(struct ifnet *, struct mbuf *);

int	in6_cksum(struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
void	in6_proto_cksum_out(struct mbuf *, struct ifnet *);
int	in6_localaddr(struct in6_addr *);
int	in6_addrscope(struct in6_addr *);
struct	in6_ifaddr *in6_ifawithscope(struct ifnet *, struct in6_addr *, u_int);
int	in6_mask2len(struct in6_addr *, u_char *);
int	in6_nam2sin6(const struct mbuf *, struct sockaddr_in6 **);

struct inpcb;

int	in6_embedscope(struct in6_addr *, const struct sockaddr_in6 *,
	    struct inpcb *);
void	in6_recoverscope(struct sockaddr_in6 *, const struct in6_addr *);
void	in6_clearscope(struct in6_addr *);

struct sockaddr;
struct sockaddr_in6;
struct ifaddr;
struct in6_ifaddr;

/*
 * Convert between address family specific and general structs.
 * Inline functions check the source type and are stricter than
 * casts or defines.
 */

static inline struct sockaddr_in6 *
satosin6(struct sockaddr *sa)
{
	return ((struct sockaddr_in6 *)(sa));
}

static inline struct sockaddr *
sin6tosa(struct sockaddr_in6 *sin6)
{
	return ((struct sockaddr *)(sin6));
}

static inline struct in6_ifaddr *
ifatoia6(struct ifaddr *ifa)
{
	return ((struct in6_ifaddr *)(ifa));
}

#endif /* _KERNEL */

#if __BSD_VISIBLE
/*
 * Definitions for inet6 sysctl operations.
 *
 * Third level is protocol number.
 * Fourth level is desired variable within that protocol.
 */
#define IPV6PROTO_MAXID	(IPPROTO_DIVERT + 1)	/* don't list to IPV6PROTO_MAX */

#define CTL_IPV6PROTO_NAMES { \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, \
	{ "tcp6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "udp6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, \
	{ "ip6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, \
	{ "ipsec6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "icmp6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
/*110*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*120*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*130*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*140*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*150*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*160*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*170*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*180*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*190*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*200*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*210*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*220*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*230*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*240*/	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
	{ 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, { 0, 0 }, \
/*250*/	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "divert", CTLTYPE_NODE }, \
}

/*
 * Names for IP sysctl objects
 */
#define IPV6CTL_FORWARDING	1	/* act as router */
#define IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding*/
#define IPV6CTL_DEFHLIM		3	/* default Hop-Limit */
#define IPV6CTL_FORWSRCRT	5	/* forward source-routed dgrams */
#define IPV6CTL_STATS		6	/* stats */
#define IPV6CTL_MRTSTATS	7	/* multicast forwarding stats */
#define IPV6CTL_MRTPROTO	8	/* multicast routing protocol */
#define IPV6CTL_MAXFRAGPACKETS	9	/* max packets reassembly queue */
#define IPV6CTL_SOURCECHECK	10	/* verify source route and intf */
#define IPV6CTL_SOURCECHECK_LOGINT 11	/* minimume logging interval */
#define IPV6CTL_ACCEPT_RTADV	12
#define IPV6CTL_LOG_INTERVAL	14
#define IPV6CTL_HDRNESTLIMIT	15
#define IPV6CTL_DAD_COUNT	16
#define IPV6CTL_AUTO_FLOWLABEL	17
#define IPV6CTL_DEFMCASTHLIM	18
#define IPV6CTL_USE_DEPRECATED	21	/* use deprecated addr (RFC2462 5.5.4) */
/* 24 to 40: reserved */
#define IPV6CTL_MAXFRAGS	41	/* max fragments */
#define IPV6CTL_MFORWARDING	42
#define IPV6CTL_MULTIPATH	43
#define IPV6CTL_MCAST_PMTU	44	/* path MTU discovery for multicast */
#define IPV6CTL_NEIGHBORGCTHRESH 45
#define IPV6CTL_MAXDYNROUTES	48
#define IPV6CTL_DAD_PENDING	49
#define IPV6CTL_MTUDISCTIMEOUT	50
#define IPV6CTL_IFQUEUE		51
#define IPV6CTL_MRTMIF		52
#define IPV6CTL_MRTMFC		53
#define IPV6CTL_MAXID		54

/* New entries should be added here from current IPV6CTL_MAXID value. */
/* to define items, should talk with KAME guys first, for *BSD compatibility */

#define IPV6CTL_NAMES { \
	{ 0, 0 }, \
	{ "forwarding", CTLTYPE_INT }, \
	{ "redirect", CTLTYPE_INT }, \
	{ "hlim", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ "forwsrcrt", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "mrtproto", CTLTYPE_INT }, \
	{ "maxfragpackets", CTLTYPE_INT }, \
	{ "sourcecheck", CTLTYPE_INT }, \
	{ "sourcecheck_logint", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "log_interval", CTLTYPE_INT }, \
	{ "hdrnestlimit", CTLTYPE_INT }, \
	{ "dad_count", CTLTYPE_INT }, \
	{ "auto_flowlabel", CTLTYPE_INT }, \
	{ "defmcasthlim", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "use_deprecated", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "maxfrags", CTLTYPE_INT }, \
	{ "mforwarding", CTLTYPE_INT }, \
	{ "multipath", CTLTYPE_INT }, \
	{ "multicast_mtudisc", CTLTYPE_INT }, \
	{ "neighborgcthresh", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "maxdynroutes", CTLTYPE_INT }, \
	{ "dad_pending", CTLTYPE_INT }, \
	{ "mtudisctimeout", CTLTYPE_INT }, \
	{ "ifq", CTLTYPE_NODE }, \
	{ "mrtmif", CTLTYPE_STRUCT }, \
	{ "mrtmfc", CTLTYPE_STRUCT }, \
}

#define IPV6CTL_VARS { \
	NULL, \
	&ip6_forwarding, \
	&ip6_sendredirects, \
	&ip6_defhlim, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ip6_maxfragpackets, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ip6_log_interval, \
	&ip6_hdrnestlimit, \
	&ip6_dad_count, \
	&ip6_auto_flowlabel, \
	&ip6_defmcasthlim, \
	NULL, \
	NULL, \
	&ip6_use_deprecated, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ip6_maxfrags, \
	&ip6_mforwarding, \
	&ip6_multipath, \
	&ip6_mcast_pmtu, \
	&ip6_neighborgcthresh, \
	NULL, \
	NULL, \
	&ip6_maxdynroutes, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
}

__BEGIN_DECLS
struct cmsghdr;

extern int inet6_opt_init(void *, socklen_t);
extern int inet6_opt_append(void *, socklen_t, int, u_int8_t,
		socklen_t, u_int8_t, void **);
extern int inet6_opt_finish(void *, socklen_t, int);
extern int inet6_opt_set_val(void *, int, void *, socklen_t);

extern int inet6_opt_next(void *, socklen_t, int, u_int8_t *,
		socklen_t *, void **);
extern int inet6_opt_find(void *, socklen_t, int, u_int8_t,
		socklen_t *, void **);
extern int inet6_opt_get_val(void *, int, void *, socklen_t);

extern socklen_t inet6_rth_space(int, int);
extern void *inet6_rth_init(void *, socklen_t, int, int);
extern int inet6_rth_add(void *, const struct in6_addr *);
extern int inet6_rth_reverse(const void *, void *);
extern int inet6_rth_segments(const void *);
extern struct in6_addr *inet6_rth_getaddr(const void *, int);
__END_DECLS
#endif /* __BSD_VISIBLE */

#endif /* !_NETINET6_IN6_H_ */
@


1.98
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.97 2017/07/13 17:17:27 florian Exp $	*/
a420 1
void 	in6_get_rand_ifid(struct ifnet *, struct in6_addr *);
@


1.97
log
@Get rid of ip6.maxifprefixes and ip6.maxifdefrouters, the kernel no
longer tracks prefixes or default routers from router advertisements.
Pointed out by jmc.
ports tree grepping sthen, who only found nsh
OK mpi, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.96 2017/05/30 09:10:49 mpi Exp $	*/
d423 1
@


1.96
log
@Keep ipv6_input() definition inside _KERNEL.

Unbreak userland, found the hardway by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.95 2017/05/30 07:50:37 mpi Exp $	*/
a586 2
#define IPV6CTL_MAXIFPREFIXES	46
#define IPV6CTL_MAXIFDEFROUTERS 47
d645 2
a646 2
	{ "maxifprefixes", CTLTYPE_INT }, \
	{ "maxifdefrouters", CTLTYPE_INT }, \
d702 2
a703 2
	&ip6_maxifprefixes, \
	&ip6_maxifdefrouters, \
@


1.95
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.94 2017/05/04 15:00:24 bluhm Exp $	*/
d414 2
a715 2

void	   ipv6_input(struct ifnet *, struct mbuf *);
@


1.94
log
@Introduce sstosa() for converting sockaddr_storage with a type safe
inline function instead of casting it to sockaddr.  While there,
use inline instead of __inline for all these conversions.  Some
struct sockaddr casts can be avoided completely.
OK dhill@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.93 2017/02/22 13:46:53 renato Exp $	*/
a407 1
extern	struct niqueue ip6intrq;	/* IP6 packet input queue */
d714 2
@


1.93
log
@Fix comments about a few ipv6 sockoptions

OK millert@@ florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.92 2016/12/22 11:04:44 rzalamena Exp $	*/
d441 1
a441 1
static __inline struct sockaddr_in6 *
d447 1
a447 1
static __inline struct sockaddr *
d453 1
a453 1
static __inline struct in6_ifaddr *
@


1.92
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.91 2016/10/03 12:33:21 mpi Exp $	*/
d297 3
a299 3
#define IPV6_MULTICAST_IF	9  /* u_char; set/get IP6 multicast i/f */
#define IPV6_MULTICAST_HOPS	10 /* u_char; set/get IP6 multicast hops */
#define IPV6_MULTICAST_LOOP	11 /* u_char; set/get IP6 multicast loopback */
@


1.91
log
@Convert some of the remaining usages of time_second to time_uptime.

time_second is unix time so it can be affected by clock changes.
time_uptime is monotonic so it isnt affected by clock changes. that
in turn means route expiries wont jump with clock changes if set
against time_uptime.

the expiry is translated into unix time for export to userland though.

Should fix mismatch between route timers that were already converted
and ND default routers that were still using time_second.

Tested by matthieu@@ and sthen@@

ok sthen@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.90 2016/06/27 16:33:48 jca Exp $	*/
d514 1
a514 1
	{ "pim6", CTLTYPE_NODE }, \
@


1.90
log
@Implement IPV6_MINHOPCOUNT support.

Useful to implement GTSM support in daemons such as bgpd(8). Diff from
2013 revived by renato@@.  Input from bluhm@@, ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.89 2016/06/01 11:11:44 jca Exp $	*/
d283 1
a283 1
	 (u_int32_t)((time_second - (a)->ia6_updatetime)) > \
d287 1
a287 1
	 (u_int32_t)((time_second - (a)->ia6_updatetime)) > \
@


1.89
log
@Kill sysctl net.inet6.ip6.rr_prune

We don't support Router Renumbering and there are no plans to change
that.  ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.88 2016/05/19 11:34:39 jca Exp $	*/
d349 1
@


1.88
log
@Remove sysctl net.inet6.ip6.v6only

This sysctl is a no-op, read-only since it was introduced.  There are no
plans to support IPv4-mapped addresses on OpenBSD, thus this sysctl is
meaningless.

Noticed by djm@@, ok claudio@@ mpi@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.87 2015/12/03 10:34:24 tedu Exp $	*/
a578 1
#define IPV6CTL_RR_PRUNE	22	/* walk timer for router renumbering */
d621 1
a621 1
	{ "rr_prune", CTLTYPE_INT }, \
d678 1
a678 1
	&ip6_rr_prune, \
@


1.87
log
@rm unused kernel only IPV6_RECVRTHDRDSTOPTS sockopt. ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.86 2015/10/29 16:04:10 tedu Exp $	*/
d580 1
a580 2
#define IPV6CTL_V6ONLY		24
/* 25 to 40: resrved */
d624 1
a624 1
	{ "v6only", CTLTYPE_INT }, \
@


1.86
log
@RFC 2292 API support was removed 9 years ago, but left in a binary compat
ABI form for the sake of existing programs. no programs from that era have
been able to run for quite some time. Kill it all.
ok deraadt florian millert mpi
(I believe this is my first IPv6 diff. Future, here I come!)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.85 2015/09/11 07:42:35 claudio Exp $	*/
a317 3
#ifdef _KERNEL
#define IPV6_RECVRTHDRDSTOPTS	41 /* bool; recv dst option before rthdr */
#endif
@


1.85
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.84 2015/09/10 17:52:05 claudio Exp $	*/
a304 11
#endif

/* RFC2292 options */
#ifdef _KERNEL
#define IPV6_2292PKTINFO	19 /* bool; send/rcv if, src/dst addr */
#define IPV6_2292HOPLIMIT	20 /* bool; hop limit */
#define IPV6_2292NEXTHOP	21 /* bool; next hop addr */
#define IPV6_2292HOPOPTS	22 /* bool; hop-by-hop option */
#define IPV6_2292DSTOPTS	23 /* bool; destination option */
#define IPV6_2292RTHDR		24 /* bool; routing header */
#define IPV6_2292PKTOPTIONS	25 /* buf/cmsghdr; set/get IPv6 options */
@


1.84
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.83 2015/06/08 22:19:28 krw Exp $	*/
d439 1
a439 1
	    struct inpcb *, struct ifnet **);
@


1.83
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.82 2015/04/14 14:18:37 mikeb Exp $	*/
d440 1
a440 2
int	in6_recoverscope(struct sockaddr_in6 *, const struct in6_addr *,
	    struct ifnet *);
@


1.82
log
@ip6_sprintf is long gone;  noticed by blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.81 2015/04/10 13:58:20 dlg Exp $	*/
d263 1
a263 1
	(IN6_IS_ADDR_MULTICAST(a) && 	\
@


1.81
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.80 2015/02/09 12:23:22 claudio Exp $	*/
a434 2

char	*ip6_sprintf(struct in6_addr *);
@


1.80
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mf6c) and the
multicast interface table (mif6). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.79 2015/02/09 12:04:27 dlg Exp $	*/
d421 1
a421 1
extern	struct ifqueue ip6intrq;	/* IP6 packet input queue */
@


1.79
log
@provide a net.inet6.ip6.ifq sysctl so people can see and fiddle
with the ip6intrq.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.78 2015/01/10 11:43:37 mpi Exp $	*/
d610 3
a612 1
#define IPV6CTL_MAXID		52
d670 2
d724 3
@


1.78
log
@Correct some comments and merge in6_if_up() into in6_ifattach() to
reflect that IPv6 link-local addresses are no longer automagically
configured the first time an interface is brought up.

ok henning@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.77 2014/12/05 15:50:04 mpi Exp $	*/
d609 2
a610 1
#define IPV6CTL_MAXID		51
d667 1
@


1.77
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.76 2014/11/20 09:55:57 mpi Exp $	*/
a432 1
void	in6_if_up(struct ifnet *);
@


1.76
log
@What have no need for a variable that holds the maximum MTU size of
interfaces with an IPv6 address.

ok henning@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.75 2014/08/31 19:20:44 bluhm Exp $	*/
d424 2
@


1.75
log
@Make the in6addr constant declarations and definitions consistent
in kernel and user land.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.74 2014/08/26 21:44:29 florian Exp $	*/
a422 1
extern	unsigned long in6_maxmtu;
@


1.74
log
@Do not hand-roll all routers link local address.
pointed out & OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.73 2014/07/11 16:39:06 henning Exp $	*/
a136 1
extern const struct in6_addr in6addr_linklocal_allrouters;
d144 1
@


1.73
log
@introduce the IFXF_AUTOCONF6 interface flag which controls wether we
accept rtadvs on that interface. the global net.inet6.ip6.accept_rtadv
sysctl just doesn't cut it, even tho the spec wants that - but in their
little absurd world, a host just has one interface by definition anyway...
the sysctlgoes away.
lots of head scratching, brain cell elemination etc from bluhm benno stsp
florian, excitement from simon and todd, ok bluhm stsp benno florian
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.71 2014/04/20 16:48:22 naddy Exp $	*/
d137 1
@


1.72
log
@Remove deprecated RFC2292 ancillary data convenience functions.
They are obsoleted by the RFC3542 api.

ok mpi@@
@
text
@d626 1
a626 1
	{ "accept_rtadv", CTLTYPE_INT }, \
d680 1
a680 1
	&ip6_accept_rtadv, \
@


1.71
log
@move in6_cksum_phdr from in6.h to ip6_output.c to mirror in_cksum_phdr
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.70 2014/01/22 14:27:20 naddy Exp $	*/
d384 1
a384 1
 * IPV6_PKTINFO: Packet information(RFC2292 sec 5)
a722 17

extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, const u_int8_t *,
	int, int);
extern u_int8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(const struct cmsghdr *, u_int8_t **);
extern int inet6_option_find(const struct cmsghdr *, u_int8_t **, int);

extern size_t inet6_rthdr_space(int, int);
extern struct cmsghdr *inet6_rthdr_init(void *, int);
extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *,
		unsigned int);
extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int);
extern int inet6_rthdr_segments(const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int);
extern int inet6_rthdr_getflags(const struct cmsghdr *, int);
@


1.70
log
@Split the checksum calculation for IPv6 like for IPv4:
Always calculate the pseudo-header checksum.
Complete the checksum if hardware offload is not available.

Parts originally from NetBSD; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.69 2013/10/28 21:02:35 deraadt Exp $	*/
a418 49
/*
 * in6_cksum_phdr:
 *
 *	Compute significant parts of the IPv6 checksum pseudo-header
 *	for use in a delayed TCP/UDP checksum calculation.
 *
 *	Args:
 *
 *		src		Source IPv6 address
 *		dst		Destination IPv6 address
 *		len		htonl(proto-hdr-len)
 *		nxt		htonl(next-proto-number)
 *
 *	NOTE: We expect the src and dst addresses to be 16-bit
 *	aligned!
 */
static __inline u_int16_t __attribute__((__unused__))
in6_cksum_phdr(const struct in6_addr *src, const struct in6_addr *dst,
    u_int32_t len, u_int32_t nxt)
{
	u_int32_t sum = 0;
	const u_int16_t *w;

	w = (const u_int16_t *) src;
	sum += w[0];
	if (!IN6_IS_SCOPE_EMBED(src))
		sum += w[1];
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
	sum += w[6]; sum += w[7];

	w = (const u_int16_t *) dst;
	sum += w[0];
	if (!IN6_IS_SCOPE_EMBED(dst))
		sum += w[1];
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
	sum += w[6]; sum += w[7];

	sum += (u_int16_t)(len >> 16) + (u_int16_t)(len /*& 0xffff*/);

	sum += (u_int16_t)(nxt >> 16) + (u_int16_t)(nxt /*& 0xffff*/);

	sum = (u_int16_t)(sum >> 16) + (u_int16_t)(sum /*& 0xffff*/);

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

@


1.69
log
@kill kame version symbols and sysctl
ports tree grep run by sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.68 2013/10/24 11:31:43 mpi Exp $	*/
d419 48
@


1.68
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.67 2013/10/24 11:20:18 deraadt Exp $	*/
a76 1
#define __KAME_VERSION		"OpenBSD-current"
a594 1
#define IPV6CTL_KAME_VERSION	20
d635 1
a635 1
	{ "kame_version", CTLTYPE_STRING }, \
@


1.67
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.66 2013/10/21 12:27:15 deraadt Exp $	*/
d420 6
d429 1
a429 1
extern void in6_proto_cksum_out(struct mbuf *, struct ifnet *);
d433 1
a433 1
extern void in6_if_up(struct ifnet *);
d436 10
@


1.66
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.65 2013/06/26 09:12:40 henning Exp $	*/
d105 2
a106 2
#define SIN6_LEN
#endif
d116 1
a129 1
#endif
a130 1
#ifdef _KERNEL
d140 7
d148 1
a148 1
 * Macros started with IPV6_ADDR is KAME local
d150 5
a154 21
#ifdef _KERNEL	/* XXX nonstandard */
#if BYTE_ORDER == BIG_ENDIAN
#define IPV6_ADDR_INT32_ONE	1
#define IPV6_ADDR_INT32_TWO	2
#define IPV6_ADDR_INT32_MNL	0xff010000
#define IPV6_ADDR_INT32_MLL	0xff020000
#define IPV6_ADDR_INT32_SMP	0x0000ffff
#define IPV6_ADDR_INT16_ULL	0xfe80
#define IPV6_ADDR_INT16_USL	0xfec0
#define IPV6_ADDR_INT16_MLL	0xff02
#elif BYTE_ORDER == LITTLE_ENDIAN
#define IPV6_ADDR_INT32_ONE	0x01000000
#define IPV6_ADDR_INT32_TWO	0x02000000
#define IPV6_ADDR_INT32_MNL	0x000001ff
#define IPV6_ADDR_INT32_MLL	0x000002ff
#define IPV6_ADDR_INT32_SMP	0xffff0000
#define IPV6_ADDR_INT16_ULL	0x80fe
#define IPV6_ADDR_INT16_USL	0xc0fe
#define IPV6_ADDR_INT16_MLL	0x02ff
#endif
#endif
a158 1
#if __BSD_VISIBLE
a176 1
#endif
d178 4
a181 6
extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
#if __BSD_VISIBLE
extern const struct in6_addr in6addr_intfacelocal_allnodes;
extern const struct in6_addr in6addr_linklocal_allnodes;
#endif
d184 1
a184 4
 * Equality
 * NOTE: Some of kernel programming environment (for example, OpenBSD/sparc)
 * does not supply memcmp().  For userland memcmp() is preferred as it is
 * in ANSI standard.
d186 8
a193 9
#ifdef _KERNEL
#define IN6_ARE_ADDR_EQUAL(a, b)			\
    (bcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
#else
#if __BSD_VISIBLE
#define IN6_ARE_ADDR_EQUAL(a, b)			\
    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
#endif
#endif
d211 1
a211 1
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) == ntohl(1)))
d221 1
a221 1
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) != ntohl(1)))
d229 1
a229 21
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))

/*
 * KAME Scope Values
 */

#ifdef _KERNEL	/* XXX nonstandard */
#define IPV6_ADDR_SCOPE_NODELOCAL	0x01
#define IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
#define IPV6_ADDR_SCOPE_LINKLOCAL	0x02
#define IPV6_ADDR_SCOPE_SITELOCAL	0x05
#define IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
#define IPV6_ADDR_SCOPE_GLOBAL		0x0e
#else
#define __IPV6_ADDR_SCOPE_NODELOCAL	0x01
#define __IPV6_ADDR_SCOPE_INTFACELOCAL	0x01
#define __IPV6_ADDR_SCOPE_LINKLOCAL	0x02
#define __IPV6_ADDR_SCOPE_SITELOCAL	0x05
#define __IPV6_ADDR_SCOPE_ORGLOCAL	0x08	/* just used in this file */
#define __IPV6_ADDR_SCOPE_GLOBAL	0x0e
#endif
d243 1
d246 6
a251 5
#ifdef _KERNEL	/* XXX nonstandard */
#define IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
#else
#define __IPV6_ADDR_MC_SCOPE(a)		((a)->s6_addr[1] & 0x0f)
#endif
a252 23
/*
 * Multicast Scope
 */
#ifdef _KERNEL	/* refers nonstandard items */
#define IN6_IS_ADDR_MC_NODELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_NODELOCAL))
#define IN6_IS_ADDR_MC_INTFACELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_INTFACELOCAL))
#define IN6_IS_ADDR_MC_LINKLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_LINKLOCAL))
#define IN6_IS_ADDR_MC_SITELOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) && 	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_SITELOCAL))
#define IN6_IS_ADDR_MC_ORGLOCAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_ORGLOCAL))
#define IN6_IS_ADDR_MC_GLOBAL(a)	\
	(IN6_IS_ADDR_MULTICAST(a) &&	\
	 (IPV6_ADDR_MC_SCOPE(a) == IPV6_ADDR_SCOPE_GLOBAL))
#else
a270 1
#endif
d272 1
a272 4
#ifdef _KERNEL	/* nonstandard */
/*
 * KAME Scope
 */
a288 1
#endif
d290 1
a290 10
/*
 * IP6 route structure
 */
#if __BSD_VISIBLE
struct route_in6 {
	struct	rtentry *ro_rt;
	u_long		 ro_tableid;	/* padded to long for alignment */
	struct	sockaddr_in6 ro_dst;
};
#endif
a295 3
#define IPV6_OPTIONS		1  /* buf/ip6_opts; set/get IP6 options */
/* no hdrincl */
#define IPV6_SOCKOPT_RESERVED1	3  /* reserved for future use */
a296 6
#if 0 /* the followings are relic in IPv4 and hence are disabled */
#define IPV6_RECVOPTS		5  /* bool; receive all IP6 opts w/dgram */
#define IPV6_RECVRETOPTS	6  /* bool; receive IP6 opts for response */
#define IPV6_RECVDSTADDR	7  /* bool; receive IP6 dst addr w/dgram */
#define IPV6_RETOPTS		8  /* ip6_opts; set/get IP6 options */
#endif
a320 7
#if 0 /*KAME IPSEC*/
#define IPV6_IPSEC_POLICY	28 /* struct; get/set security policy */
#endif
#define IPV6_FAITH		29 /* bool; accept FAITH'ed connections */

/* 30-34: reserved */

d339 1
a339 3
/* 45: reserved */

/* more new socket options introduced in RFC3542 */
a346 1
/* 52: reserved */
d354 1
a354 1
/* 58: reserved */
d367 2
a368 4

#define IPV6_RTHDR_LOOSE     0 /* this hop need not be a neighbor. XXX old spec */
#define IPV6_RTHDR_STRICT    1 /* this hop must be a neighbor. XXX old spec */
#define IPV6_RTHDR_TYPE_0    0 /* IPv6 routing header type 0 */
d410 52
a566 3
#ifdef notyet
#define IPV6CTL_DEFMTU		4	/* default MTU */
#endif
a579 3
#ifdef notdef	/* obsolete */
#define IPV6CTL_GIF_HLIM	19	/* default HLIM for gif encap packet */
#endif
a582 1
/*#define IPV6CTL_MAPPED_ADDR	23	not for OpenBSD */
d605 1
a605 1
	{ "mtu", CTLTYPE_INT }, \
a707 51
#endif /* __BSD_VISIBLE */

#ifdef _KERNEL
struct cmsghdr;

int	in6_cksum(struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
extern void in6_proto_cksum_out(struct mbuf *, struct ifnet *);
int	in6_localaddr(struct in6_addr *);
int	in6_addrscope(struct in6_addr *);
struct	in6_ifaddr *in6_ifawithscope(struct ifnet *, struct in6_addr *, u_int);
extern void in6_if_up(struct ifnet *);
void 	in6_get_rand_ifid(struct ifnet *, struct in6_addr *);
int	in6_mask2len(struct in6_addr *, u_char *);

struct sockaddr;
struct sockaddr_in6;
struct ifaddr;
struct in6_ifaddr;

/*
 * Convert between address family specific and general structs.
 * Inline functions check the source type and are stricter than
 * casts or defines.
 */

static __inline struct sockaddr_in6 *
satosin6(struct sockaddr *sa)
{
	return ((struct sockaddr_in6 *)(sa));
}

static __inline struct sockaddr *
sin6tosa(struct sockaddr_in6 *sin6)
{
	return ((struct sockaddr *)(sin6));
}

static __inline struct in6_ifaddr *
ifatoia6(struct ifaddr *ifa)
{
	return ((struct in6_ifaddr *)(ifa));
}
#endif /* _KERNEL */

#if __BSD_VISIBLE

#ifndef	_SOCKLEN_T_DEFINED_
#define	_SOCKLEN_T_DEFINED_
typedef	__socklen_t	socklen_t;	/* length type for network syscalls */
#endif

a723 3
#if 0 /* not implemented yet */
extern int inet6_rthdr_reverse(const struct cmsghdr *, struct cmsghdr *);
#endif
@


1.65
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.64 2013/03/28 15:05:32 bluhm Exp $	*/
d643 2
a644 1
#define IPV6CTL_MAXID		50
d700 1
d753 1
@


1.64
log
@Convert the satosin, sintosa, ifatoia, satosin6, sin6tosa, ifatoia6
defines into static inline functions.  This allows the compiler to
check the source type before casting.
liked by many;  OK mpi@@ haesbaert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.63 2013/03/14 14:28:38 mpi Exp $	*/
d760 1
@


1.63
log
@My lack of faith... These lines should stay, reported by ajacoutot@@.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.62 2013/03/14 11:18:37 mpi Exp $	*/
d767 28
a794 3
#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
#define	sin6tosa(sin6)	((struct sockaddr *)(sin6))
#define	ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))
@


1.62
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.61 2012/11/06 12:32:42 henning Exp $	*/
d662 1
d715 1
@


1.61
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.60 2012/11/01 07:55:56 henning Exp $	*/
a619 1
#define IPV6CTL_KEEPFAITH	13
a661 1
	{ "keepfaith", CTLTYPE_INT }, \
a713 1
	&ip6_keepfaith, \
@


1.60
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.58 2012/09/15 00:47:08 guenther Exp $	*/
a760 1
extern void in6_proto_cksum_out(struct mbuf *, struct ifnet *);
@


1.59
log
@add IPV6_RECVDSTPORT socket option, which enables us to get original
(= before divert) destination port of a UDP packet.  The way to use
this option is same as IP_RECVDSTPORT.

from UMEZAWA Takeshi
tweaks from jmc; ok henning bluhm
@
text
@d761 1
@


1.58
log
@Improve POSIX/SUS compliance of <netdb.h>, <sys/socket.h>, and <sys/un.h>.

Much ports testing of various versions by naddy@@ and jasper@@
ok matthew@@, miller@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.57 2012/07/10 11:49:42 guenther Exp $	*/
d453 2
@


1.57
log
@Instead of <arpa/inet.h> pulling in <netinet/in.h>, just copy in the
three things that it needed from there: INET_ADDRSTRLEN, INET6_ADDRSTRLEN,
and struct in_addr.  Add protecting #ifndefs to netinet6?/in6?.h for those.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.56 2012/06/26 06:39:27 guenther Exp $	*/
d772 6
@


1.56
log
@Improve compliance for <arpa/inet.h> and <netinet/in.h> to define/declare
all the symbols that POSIX says they must and fewer that they can't and,
most importantly, to not require a specific ordering of headers.

ports testing by naddy@@
ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.55 2011/11/24 17:39:55 sperreault Exp $	*/
d97 1
d99 1
@


1.55
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.54 2011/10/13 18:23:40 claudio Exp $	*/
a79 34
 * Local port number conventions:
 *
 * Ports < IPPORT_RESERVED are reserved for privileged processes (e.g. root),
 * unless a kernel is compiled with IPNOPRIVPORTS defined.
 *
 * When a user does a bind(2) or connect(2) with a port number of zero,
 * a non-conflicting local port address is chosen.
 *
 * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
 * that is settable by sysctl(3); net.inet.ip.anonportmin and
 * net.inet.ip.anonportmax respectively.
 *
 * A user may set the IPPROTO_IP option IP_PORTRANGE to change this
 * default assignment range.
 *
 * The value IP_PORTRANGE_DEFAULT causes the default behavior.
 *
 * The value IP_PORTRANGE_HIGH is the same as IP_PORTRANGE_DEFAULT,
 * and exists only for FreeBSD compatibility purposes.
 *
 * The value IP_PORTRANGE_LOW changes the range to the "low" are
 * that is (by convention) restricted to privileged processes.
 * This convention is based on "vouchsafe" principles only.
 * It is only secure if you trust the remote host to restrict these ports.
 * The range is IPPORT_RESERVEDMIN to IPPORT_RESERVEDMAX.
 */

#define	IPV6PORT_RESERVED	1024
#define	IPV6PORT_ANONMIN	49152
#define	IPV6PORT_ANONMAX	65535
#define	IPV6PORT_RESERVEDMIN	600
#define	IPV6PORT_RESERVEDMAX	(IPV6PORT_RESERVED-1)

/*
d383 1
d385 1
d440 1
d442 1
d484 2
d769 1
d812 1
@


1.54
log
@Since the IPv6 madness is not enough introduce NAT64 -- which is actually
"af-to" a generic IP version translator for pf(4).
Not everything perfect yet but lets fix these things in the tree.
Insane amount of work done by sperreault@@, mikeb@@ and reyk@@.
Looked over by mcbride@@ henning@@ and myself at eurobsdcon.
OK mcbride@@ and general put it in from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.53 2011/05/02 13:48:38 mikeb Exp $	*/
d787 1
a787 1
struct	in6_ifaddr *in6_ifawithscope(struct ifnet *, struct in6_addr *);
@


1.53
log
@recognize SO_RTABLE socket option at the SOL_SOCKET level;
discussed with and ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.52 2010/09/23 04:45:15 yasuoka Exp $	*/
d790 1
@


1.52
log
@add a new IP level socket option IP_PIPEX.  This option is used for L2TP
support by pipex.
OK henning@@, "Carry on" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.51 2010/07/08 19:42:46 jsg Exp $	*/
d481 2
@


1.51
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.50 2010/05/07 13:33:17 claudio Exp $	*/
d480 1
@


1.50
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.49 2010/04/06 14:12:10 stsp Exp $	*/
a226 1
extern const struct in6_addr in6addr_linklocal_allrouters;
a784 1
struct	in6_ifaddr *in6_ifawithifp(struct ifnet *, struct in6_addr *);
@


1.49
log
@Simple implementation of RFC4941, "Privacy Extensions for Stateless
Address Autoconfiguration in IPv6". For those among us who are paranoid
about broadcasting their MAC address to the IPv6 internet.

Man page help from jmc, testing by weerd, arc4random API hints from djm.

ok deraadt, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.48 2009/11/05 20:50:14 michele Exp $	*/
d393 1
@


1.48
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.47 2008/11/25 12:11:44 markus Exp $	*/
d787 1
@


1.47
log
@delay /etc/netstart until IPv6-DAD (dup-address-detection) is completed.
ok fries, hshoexer, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.46 2008/06/11 06:30:36 mcbride Exp $	*/
d532 1
a532 1
#define IPV6PROTO_MAXID	(IPPROTO_PIM + 1)	/* don't list to IPV6PROTO_MAX */
d579 43
@


1.46
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.45 2008/03/09 12:03:03 sobrado Exp $	*/
d621 2
a622 1
#define IPV6CTL_MAXID		49
d677 1
d730 1
@


1.45
log
@use the right capitalization for platform names

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.44 2007/01/22 06:12:18 miod Exp $	*/
d617 6
a622 1
#define IPV6CTL_MAXID		45
d672 4
d724 4
@


1.44
log
@Fix KAME cvsweb urls
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.43 2006/12/09 01:12:28 itojun Exp $	*/
d232 1
a232 1
 * NOTE: Some of kernel programming environment (for example, openbsd/sparc)
d610 1
a610 1
/*#define IPV6CTL_MAPPED_ADDR	23	not for openbsd */
@


1.43
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.42 2006/11/21 05:37:32 itojun Exp $	*/
d73 1
a73 1
 * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
@


1.42
log
@introduce sysctl net.inet6.ip6.multicast_mtudisc (for multicast routers).
deraadt ok.  manpage nit by jmc.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.41 2006/11/17 02:00:21 itojun Exp $	*/
d405 1
d410 2
a411 1
#define IPV6_MULTICAST_IF	9  /* u_char; set/get IP6 multicast i/f  */
d418 12
a429 7
#define IPV6_PKTINFO		19 /* bool; send/rcv if, src/dst addr */
#define IPV6_HOPLIMIT		20 /* bool; hop limit */
#define IPV6_NEXTHOP		21 /* bool; next hop addr */
#define IPV6_HOPOPTS		22 /* bool; hop-by-hop option */
#define IPV6_DSTOPTS		23 /* bool; destination option */
#define IPV6_RTHDR		24 /* bool; routing header */
#define IPV6_PKTOPTIONS		25 /* buf/cmsghdr; set/get IPv6 options */
d438 14
a451 1
/* 30-41: reserved */
d453 1
d455 14
a468 1
/* 43-52, 57-59: reserved */
d473 3
d478 3
d490 2
a491 2
#define IPV6_DEFAULT_MULTICAST_HOPS 1	/* normally limit m'casts to 1 hop  */
#define IPV6_DEFAULT_MULTICAST_LOOP 1	/* normally hear sends if a member  */
d510 8
d756 19
@


1.41
log
@move comment to a line where it makes more sense
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.40 2006/11/17 01:11:23 itojun Exp $	*/
d568 2
a569 1
#define IPV6CTL_MAXID		44
d618 1
d666 1
@


1.40
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.39 2006/06/18 11:47:46 pascoe Exp $	*/
a565 2
/* New entries should be added here from current IPV6CTL_MAXID value. */
/* to define items, should talk with KAME guys first, for *BSD compatibility */
d569 2
@


1.39
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.38 2006/05/27 23:40:27 claudio Exp $	*/
d211 3
d225 1
a225 1
extern const struct in6_addr in6addr_nodelocal_allnodes;
d288 1
d295 1
d329 3
d348 3
d372 4
@


1.38
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.37 2005/12/13 00:35:23 millert Exp $	*/
d554 2
a555 1
#define IPV6CTL_MAXID		43
d601 1
d648 1
@


1.37
log
@First step in include files overhaul.  Use __FOO_VISIBLE (as defined
in sys/cdefs.h) instead of _FOO_SOURCE.  Also fix several namespace
pollution issues, including the byte order defines.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.36 2004/06/21 23:50:37 tholo Exp $	*/
d553 2
a554 1
#define IPV6CTL_MAXID		42
d599 1
d645 1
@


1.36
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.35 2004/06/12 04:58:48 itojun Exp $	*/
d136 1
a136 1
#ifndef _XOPEN_SOURCE
d201 1
d217 1
d221 1
d225 1
d237 1
d241 1
d375 1
a375 1
#ifndef _XOPEN_SOURCE
d462 1
a462 1
#ifndef _XOPEN_SOURCE
d645 1
a645 1
#endif /* !_XOPEN_SOURCE */
@


1.35
log
@support IPV6_USE_MIN_MTU, to make BIND9 better.
(sorry about the mess yesterday)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.34 2004/06/11 14:27:13 deraadt Exp $	*/
d358 1
a358 1
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
d362 1
a362 1
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
@


1.34
log
@back out tree breakage.  Like, come on
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.32 2004/02/15 11:16:08 markus Exp $	*/
d410 4
a413 1
/* 30-52, 57-59: reserved */
@


1.33
log
@support IPV6_USE_MIN_MTU, which is needed to run BIND9 well.  from kame
markus ok
@
text
@d410 1
a410 4
/* 30-41: reserved */
#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */

/* 43-52, 57-59: reserved */
@


1.32
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.31 2003/06/02 23:28:15 millert Exp $	*/
d410 4
a413 1
/* 30-52, 57-59: reserved */
@


1.31
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.30 2002/06/08 21:22:02 itojun Exp $	*/
d589 45
@


1.30
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.29 2002/06/07 15:32:42 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.29
log
@mistake in sysctl table
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.28 2002/06/07 15:27:58 itojun Exp $	*/
d359 9
@


1.28
log
@just for consistency/compatibility, have net.inet6.ip6.v6only sysctl MIB,
as well as set/getsockopt(IPV6_V6ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.27 2002/05/28 03:04:38 itojun Exp $	*/
d567 1
@


1.27
log
@limit number of IPv6 fragments (not the fragment queue size) to
fight against lots-of-frags DoS attacks.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.26 2002/03/14 01:27:11 millert Exp $	*/
d398 1
a398 1
#define IPV6_BINDV6ONLY		27 /* bool; only bind INET6 at null bind */
d534 2
a535 1
/* 24 to 40: resrved */
d566 1
a566 1
	{ 0, 0 }, \
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.25 2001/12/07 09:16:07 itojun Exp $	*/
d534 2
d538 1
a538 1
#define IPV6CTL_MAXID		24
d565 17
@


1.25
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.24 2001/09/19 10:59:21 itojun Exp $	*/
d570 6
a575 6
int	in6_cksum __P((struct mbuf *, u_int8_t, u_int32_t, u_int32_t));
int	in6_localaddr __P((struct in6_addr *));
int	in6_addrscope __P((struct in6_addr *));
struct	in6_ifaddr *in6_ifawithscope __P((struct ifnet *, struct in6_addr *));
struct	in6_ifaddr *in6_ifawithifp __P((struct ifnet *, struct in6_addr *));
extern void in6_if_up __P((struct ifnet *));
d585 13
a597 13
extern int inet6_option_space __P((int));
extern int inet6_option_init __P((void *, struct cmsghdr **, int));
extern int inet6_option_append __P((struct cmsghdr *, const u_int8_t *,
	int, int));
extern u_int8_t *inet6_option_alloc __P((struct cmsghdr *, int, int, int));
extern int inet6_option_next __P((const struct cmsghdr *, u_int8_t **));
extern int inet6_option_find __P((const struct cmsghdr *, u_int8_t **, int));

extern size_t inet6_rthdr_space __P((int, int));
extern struct cmsghdr *inet6_rthdr_init __P((void *, int));
extern int inet6_rthdr_add __P((struct cmsghdr *, const struct in6_addr *,
		unsigned int));
extern int inet6_rthdr_lasthop __P((struct cmsghdr *, unsigned int));
d599 1
a599 1
extern int inet6_rthdr_reverse __P((const struct cmsghdr *, struct cmsghdr *));
d601 3
a603 3
extern int inet6_rthdr_segments __P((const struct cmsghdr *));
extern struct in6_addr *inet6_rthdr_getaddr __P((struct cmsghdr *, int));
extern int inet6_rthdr_getflags __P((const struct cmsghdr *, int));
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.25 2001/12/07 09:16:07 itojun Exp $	*/
a358 9

#define IFA6_IS_DEPRECATED(a) \
	((a)->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_pltime)
#define IFA6_IS_INVALID(a) \
	((a)->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_vltime)
d398 1
a398 1
#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
a533 3
#define IPV6CTL_V6ONLY		24
/* 25 to 40: resrved */
#define IPV6CTL_MAXFRAGS	41	/* max fragments */
d536 1
a536 1
#define IPV6CTL_MAXID		42
a562 18
	{ "v6only", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "maxfrags", CTLTYPE_INT }, \
d570 6
a575 6
int	in6_cksum(struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
int	in6_localaddr(struct in6_addr *);
int	in6_addrscope(struct in6_addr *);
struct	in6_ifaddr *in6_ifawithscope(struct ifnet *, struct in6_addr *);
struct	in6_ifaddr *in6_ifawithifp(struct ifnet *, struct in6_addr *);
extern void in6_if_up(struct ifnet *);
d585 13
a597 13
extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, const u_int8_t *,
	int, int);
extern u_int8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(const struct cmsghdr *, u_int8_t **);
extern int inet6_option_find(const struct cmsghdr *, u_int8_t **, int);

extern size_t inet6_rthdr_space(int, int);
extern struct cmsghdr *inet6_rthdr_init(void *, int);
extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *,
		unsigned int);
extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int);
d599 1
a599 1
extern int inet6_rthdr_reverse(const struct cmsghdr *, struct cmsghdr *);
d601 3
a603 3
extern int inet6_rthdr_segments(const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int);
extern int inet6_rthdr_getflags(const struct cmsghdr *, int);
@


1.24
log
@comment; sockopt # 57-59 are also reserved
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.23 2001/08/22 06:52:01 niklas Exp $	*/
d129 1
a129 1
#ifdef _KERNEL	/*XXX nonstandard*/
d155 1
a155 1
#ifdef _KERNEL	/*XXX nonstandard*/
d180 1
a180 1
#ifdef _KERNEL	/*XXX nonstandard*/
d281 1
a281 1
#ifdef _KERNEL	/*XXX nonstandard*/
d309 1
a309 1
#ifdef _KERNEL	/*XXX nonstandard*/
d318 1
a318 1
#ifdef _KERNEL	/*refers nonstandard items */
d352 1
a352 7
/*
 * Wildcard Socket
 */
#if 0	/*pre-RFC2553*/
#define IN6_IS_ADDR_ANY(a)	IN6_IS_ADDR_UNSPECIFIED(a)
#endif

a355 1
#ifdef _KERNEL	/*nonstandard*/
d527 1
a527 1
#ifdef notdef	/*obsolete*/
@


1.23
log
@Add IPCOMP setsockopt policy controls.  While here fix the other policies too
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.22 2001/03/30 02:43:52 itojun Exp $	*/
d412 1
a412 1
/* 30-52: reserved */
@


1.22
log
@fix constness of IN6_{IS,ARE}_xx macros to conform to RFC2553.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.21 2001/03/02 04:55:12 itojun Exp $	*/
d416 2
a418 1
#define IPSEC6_OUTSA		56   /* set the outbound SA for a socket */
@


1.21
log
@remove date string from KAME version identification, it is getting meaningless
as we merge random items daily.  have comment that refers to kame COVERAGE
document.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.h,v 1.20 2001/02/16 16:38:14 itojun Exp $	*/
/*	$KAME: in6.h,v 1.81 2001/03/02 04:54:45 itojun Exp $	*/
d69 1
a69 1
#error "do not include netinet6/in6.h directly, include netinet/in.h"
d245 4
a248 4
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[12]) == 0))
d254 4
a257 4
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[12]) == ntohl(1)))
d263 5
a267 5
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[12]) != 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[12]) != ntohl(1)))
d273 3
a275 3
	((*(u_int32_t *)(void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(void *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))
@


1.20
log
@get rid of #ifdef IPV6FIREWALL (never used, will never be used)
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.h,v 1.19 2001/02/16 16:00:56 itojun Exp $	*/
/*	$KAME: in6.h,v 1.77 2001/02/09 06:17:40 jinmei Exp $	*/
d77 2
d81 1
a81 1
#define __KAME_VERSION		"19991208/OpenBSD-current"
@


1.19
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.18 2000/10/17 21:46:19 itojun Exp $	*/
d410 1
a410 8
#if 1 /*IPV6FIREWALL*/
#define IPV6_FW_ADD		30 /* add a firewall rule to chain */
#define IPV6_FW_DEL		31 /* delete a firewall rule from chain */
#define IPV6_FW_FLUSH		32 /* flush firewall rule chain */
#define IPV6_FW_ZERO		33 /* clear single/all firewall counter(s) */
#define IPV6_FW_GET		34 /* get entire firewall rule chain */
#endif
/* 35-52: reserved */
@


1.18
log
@use __P() in prototype for non-ansi compilers.
From: Michael Shalayeff <mickey@@lucifier.remote.dti.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.h,v 1.17 2000/08/27 01:43:26 itojun Exp $	*/
/*	$KAME: in6.h,v 1.52 2000/07/15 15:28:02 itojun Exp $	*/
d166 2
@


1.17
log
@move IPv6 IPsec sysctl # downward, to avoid number conflict in *BSD.
angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.16 2000/07/16 08:18:43 itojun Exp $	*/
d594 7
a600 6
extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, const u_int8_t *, int, int);
extern u_int8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(const struct cmsghdr *, u_int8_t **);
extern int inet6_option_find(const struct cmsghdr *, u_int8_t **, int);
@


1.16
log
@don't pull sys/queue.h in.  sync better with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.15 2000/06/25 17:15:51 aaron Exp $	*/
d415 4
d420 2
a421 5
#define IPV6_AUTH_LEVEL		35   /* int; authentication used */
#define IPV6_ESP_TRANS_LEVEL	36   /* int; transport encryption */
#define IPV6_ESP_NETWORK_LEVEL	37   /* int; full-packet encryption */

#define IPSEC6_OUTSA		38   /* set the outbound SA for a socket */
d544 1
@


1.15
log
@Fix typo; ds@@ds.primasoft.bg
@
text
@d1 2
a2 2
/*	$OpenBSD: in6.h,v 1.14 2000/06/18 17:31:11 itojun Exp $	*/
/*	$KAME: in6.h,v 1.44 2000/05/24 08:50:17 itojun Exp $	*/
a74 4
#if !defined(_XOPEN_SOURCE)
#include <sys/queue.h>
#endif

d138 1
a138 1
#if !defined(_XOPEN_SOURCE)
d241 4
a244 4
	((*(u_int32_t *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[12]) == 0))
d250 4
a253 4
	((*(u_int32_t *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[12]) == ntohl(1)))
d259 5
a263 5
	((*(u_int32_t *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[12]) != 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[12]) != ntohl(1)))
d269 3
a271 3
	((*(u_int32_t *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(u_int32_t *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))
d367 1
a367 1
#if !defined(_XOPEN_SOURCE)
d437 1
a437 1
	u_int		ipv6mr_interface;
d444 2
a445 2
	struct in6_addr ipi6_addr;	/* src/dst IPv6 address */
	u_int ipi6_ifindex;		/* send/recv interface index */
d456 1
a456 1
#if !defined(_XOPEN_SOURCE)
a582 10
#ifdef MAPPED_ADDR_ENABLED
struct sockaddr;

void	in6_sin6_2_sin __P((struct sockaddr_in *sin,
			    struct sockaddr_in6 *sin6));
void	in6_sin_2_v4mapsin6 __P((struct sockaddr_in *sin,
				 struct sockaddr_in6 *sin6));
void	in6_sin6_2_sin_in_sock __P((struct sockaddr *nam));
void	in6_sin_2_v4mapsin6_in_sock __P((struct sockaddr **nam));
#endif /* MAPPED_ADDR_ENABLED */
@


1.14
log
@allow IPsec-related get/setsockopt on IPv6 socket.  due to number conflict
they must be IPV6_xx instead of IP_xx.

actually, since in_ctloutput() does not check address family of inpcb,
getsockopt(IPPROTO_IP, IP_xx) may work - never tested this.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.13 2000/05/25 01:22:00 itojun Exp $	*/
d94 1
a94 1
 * The default range is IPPORT_ANONMIX to IPPORT_ANONMAX, although
@


1.13
log
@net.inet.ip.gif_ttl (and IPv6 counterpart) is never used.
enforce type checking on IN6_ARE_ADDR_EQUAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.12 2000/02/28 11:55:22 itojun Exp $	*/
d407 1
a407 1
#if 1 /*IPSEC*/
d419 6
@


1.12
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 1
/*	$OpenBSD: in6.h,v 1.11 2000/02/19 17:31:40 deraadt Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d235 1
a235 1
	(bcmp((a), (b), sizeof(struct in6_addr)) == 0)
d238 1
a238 1
	(memcmp((a), (b), sizeof(struct in6_addr)) == 0)
d533 1
d535 1
d563 1
a563 1
	{ "gifhlim", CTLTYPE_INT }, \
@


1.11
log
@use more modern types
@
text
@d1 2
a2 1
/* $OpenBSD: in6.h,v 1.10 2000/02/09 07:37:15 itojun Exp $ */
d536 1
a536 3
#ifdef MAPPED_ADDR_ENABLED
#define IPV6CTL_MAPPED_ADDR	23
#endif /* MAPPED_ADDR_ENABLED */
a539 10
#ifdef MAPPED_ADDR_ENABLED
#define IPV6CTL_NAMES_MAPPED_ADDR	"mapped_addr"
#define IPV6CTL_TYPE_MAPPED_ADDR	CTLTYPE_INT
#define IPV6CTL_VARS_MAPPED_ADDR	&ip6_mapped_addr_on
#else  /* MAPPED_ADDR_ENABLED */
#define IPV6CTL_NAMES_MAPPED_ADDR	0
#define IPV6CTL_TYPE_MAPPED_ADDR	0
#define IPV6CTL_VARS_MAPPED_ADDR	0
#endif /* MAPPED_ADDR_ENABLED */

d564 1
a564 1
	{ IPV6CTL_NAMES_MAPPED_ADDR, IPV6CTL_TYPE_MAPPED_ADDR }, \
a566 26
#define IPV6CTL_VARS { \
	0, \
	&ip6_forwarding, \
	&ip6_sendredirects, \
	&ip6_defhlim, \
	0, \
	&ip6_forward_srcrt, \
	0, \
	0, \
	0, \
	&ip6_maxfragpackets, \
	&ip6_sourcecheck, \
	&ip6_sourcecheck_interval, \
	&ip6_accept_rtadv, \
	&ip6_keepfaith, \
	&ip6_log_interval, \
	&ip6_hdrnestlimit, \
	&ip6_dad_count, \
	&ip6_auto_flowlabel, \
	&ip6_defmcasthlim, \
	&ip6_gif_hlim, \
	0, \
	&ip6_use_deprecated, \
	&ip6_rr_prune, \
	IPV6CTL_VARS_MAPPED_ADDR, \
}
a571 1
int	in6_canforward __P((struct in6_addr *, struct in6_addr *));
@


1.10
log
@improve RFC2553/2292 conformance.  netinet6/{ip6,icmp6,in6}.h should not
be included.
neitnet6/{ip6,icmp6}.h includes #error statements only - i'll remove them
couple of days later.
@
text
@d1 1
a1 1
/* $OpenBSD: in6.h,v 1.9 1999/12/10 08:53:17 angelos Exp $ */
d144 3
a146 3
	u_char		sin6_len;	/* length of this struct(sa_family_t)*/
	u_char		sin6_family;	/* AF_INET6 (sa_family_t) */
	u_int16_t	sin6_port;	/* Transport layer port # (in_port_t)*/
@


1.10.2.1
log
@Merge in recent code from the trunk
@
text
@d1 1
a1 1
/* $OpenBSD: in6.h,v 1.11 2000/02/19 17:31:40 deraadt Exp $ */
d144 3
a146 3
	u_int8_t	sin6_len;	/* length of this struct(sa_family_t)*/
	sa_family_t	sin6_family;	/* AF_INET6 (sa_family_t) */
	in_port_t	sin6_port;	/* Transport layer port # (in_port_t)*/
@


1.10.2.2
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/

d535 3
a537 1
/*#define IPV6CTL_MAPPED_ADDR	23	not for openbsd */
d541 10
d575 1
a575 1
	{ 0, 0 }, \
d578 26
d609 1
@


1.10.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6.h,v 1.22 2001/03/30 02:43:52 itojun Exp $	*/
/*	$KAME: in6.h,v 1.83 2001/03/29 02:55:07 jinmei Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d68 1
a68 1
#error "do not include netinet6/in6.h directly, include netinet/in.h.  see RFC2553"
d74 4
a79 2
 * for *BSD-current/release: http://www.kame.net/dev/cvsweb.cgi/kame/COVERAGE
 * has the table of implementation/integration differences.
d82 1
a82 1
#define __KAME_VERSION		"OpenBSD-current"
d93 1
a93 1
 * The default range is IPPORT_ANONMIN to IPPORT_ANONMAX, although
d141 1
a141 1
#ifndef _XOPEN_SOURCE
a168 2
extern const struct sockaddr_in6 sa6_any;

d234 1
a234 1
    (bcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
d237 1
a237 1
    (memcmp(&(a)->s6_addr[0], &(b)->s6_addr[0], sizeof(struct in6_addr)) == 0)
d244 4
a247 4
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) == 0))
d253 4
a256 4
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) == ntohl(1)))
d262 5
a266 5
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) != 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[12]) != ntohl(1)))
d272 3
a274 3
	((*(const u_int32_t *)(const void *)(&(a)->s6_addr[0]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[4]) == 0) &&	\
	 (*(const u_int32_t *)(const void *)(&(a)->s6_addr[8]) == ntohl(0x0000ffff)))
d370 1
a370 1
#ifndef _XOPEN_SOURCE
d406 1
a406 1
#if 0 /*KAME IPSEC*/
d411 7
a417 7
/* 30-52: reserved */
#define IPV6_AUTH_LEVEL		53   /* int; authentication used */
#define IPV6_ESP_TRANS_LEVEL	54   /* int; transport encryption */
#define IPV6_ESP_NETWORK_LEVEL	55   /* int; full-packet encryption */

#define IPSEC6_OUTSA		56   /* set the outbound SA for a socket */
/* to define items, should talk with KAME guys first, for *BSD compatibility */
d434 1
a434 1
	unsigned int	ipv6mr_interface;
d441 2
a442 2
	struct in6_addr	ipi6_addr;	/* src/dst IPv6 address */
	unsigned int	ipi6_ifindex;	/* send/recv interface index */
d453 1
a453 1
#ifndef _XOPEN_SOURCE
a531 1
#ifdef notdef	/*obsolete*/
a532 1
#endif
a537 1
/* to define items, should talk with KAME guys first, for *BSD compatibility */
d560 1
a560 1
	{ 0, 0 }, \
d578 10
d597 6
a602 7
extern int inet6_option_space __P((int));
extern int inet6_option_init __P((void *, struct cmsghdr **, int));
extern int inet6_option_append __P((struct cmsghdr *, const u_int8_t *,
	int, int));
extern u_int8_t *inet6_option_alloc __P((struct cmsghdr *, int, int, int));
extern int inet6_option_next __P((const struct cmsghdr *, u_int8_t **));
extern int inet6_option_find __P((const struct cmsghdr *, u_int8_t **, int));
@


1.10.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.10.2.3 2001/05/14 22:40:17 niklas Exp $	*/
d412 1
a412 1
/* 30-52, 57-59: reserved */
d416 1
a417 2
#define IPV6_IPCOMP_LEVEL	60   /* int; compression */

@


1.10.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d129 1
a129 1
#ifdef _KERNEL	/* XXX nonstandard */
d155 1
a155 1
#ifdef _KERNEL	/* XXX nonstandard */
d180 1
a180 1
#ifdef _KERNEL	/* XXX nonstandard */
d281 1
a281 1
#ifdef _KERNEL	/* XXX nonstandard */
d309 1
a309 1
#ifdef _KERNEL	/* XXX nonstandard */
d318 1
a318 1
#ifdef _KERNEL	/* refers nonstandard items */
d352 7
a358 1
#ifdef _KERNEL	/* nonstandard */
d362 1
d534 1
a534 1
#ifdef notdef	/* obsolete */
@


1.10.2.6
log
@Merge in -current from roughly a week ago
@
text
@d570 6
a575 6
int	in6_cksum(struct mbuf *, u_int8_t, u_int32_t, u_int32_t);
int	in6_localaddr(struct in6_addr *);
int	in6_addrscope(struct in6_addr *);
struct	in6_ifaddr *in6_ifawithscope(struct ifnet *, struct in6_addr *);
struct	in6_ifaddr *in6_ifawithifp(struct ifnet *, struct in6_addr *);
extern void in6_if_up(struct ifnet *);
d585 7
a591 7
extern int inet6_option_space(int);
extern int inet6_option_init(void *, struct cmsghdr **, int);
extern int inet6_option_append(struct cmsghdr *, const u_int8_t *,
	int, int);
extern u_int8_t *inet6_option_alloc(struct cmsghdr *, int, int, int);
extern int inet6_option_next(const struct cmsghdr *, u_int8_t **);
extern int inet6_option_find(const struct cmsghdr *, u_int8_t **, int);
d593 5
a597 5
extern size_t inet6_rthdr_space(int, int);
extern struct cmsghdr *inet6_rthdr_init(void *, int);
extern int inet6_rthdr_add(struct cmsghdr *, const struct in6_addr *,
		unsigned int);
extern int inet6_rthdr_lasthop(struct cmsghdr *, unsigned int);
d599 1
a599 1
extern int inet6_rthdr_reverse(const struct cmsghdr *, struct cmsghdr *);
d601 3
a603 3
extern int inet6_rthdr_segments(const struct cmsghdr *);
extern struct in6_addr *inet6_rthdr_getaddr(struct cmsghdr *, int);
extern int inet6_rthdr_getflags(const struct cmsghdr *, int);
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@a358 9

#define IFA6_IS_DEPRECATED(a) \
	((a)->ia6_lifetime.ia6t_pltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_pltime)
#define IFA6_IS_INVALID(a) \
	((a)->ia6_lifetime.ia6t_vltime != ND6_INFINITE_LIFETIME && \
	 (u_int32_t)((time.tv_sec - (a)->ia6_updatetime)) > \
	 (a)->ia6_lifetime.ia6t_vltime)
d398 1
a398 1
#define IPV6_V6ONLY		27 /* bool; make AF_INET6 sockets v6 only */
a533 3
#define IPV6CTL_V6ONLY		24
/* 25 to 40: resrved */
#define IPV6CTL_MAXFRAGS	41	/* max fragments */
d536 1
a536 1
#define IPV6CTL_MAXID		42
a562 18
	{ "v6only", CTLTYPE_INT }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "maxfrags", CTLTYPE_INT }, \
@


1.10.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6.h,v 1.10.2.7 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.10.2.9
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a588 45
}

#define IPV6CTL_VARS { \
	NULL, \
	&ip6_forwarding, \
	&ip6_sendredirects, \
	&ip6_defhlim, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ip6_maxfragpackets, \
	NULL, \
	NULL, \
	&ip6_accept_rtadv, \
	&ip6_keepfaith, \
	&ip6_log_interval, \
	&ip6_hdrnestlimit, \
	&ip6_dad_count, \
	&ip6_auto_flowlabel, \
	&ip6_defmcasthlim, \
	NULL, \
	NULL, \
	&ip6_use_deprecated, \
	&ip6_rr_prune, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	NULL, \
	&ip6_maxfrags, \
@


1.10.2.10
log
@sync to HEAD
@
text
@d410 1
a410 4
/* 30-41: reserved */
#define IPV6_USE_MIN_MTU	42 /* bool; send packets at the minimum MTU */

/* 43-52, 57-59: reserved */
@


1.9
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d65 4
@


1.8
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
@


1.7
log
@Replace 'in6a_words' (old NRL convention) with 's6_addr32' (new BSDI et al.
convention that is more common and more specific as to the access size)
@
text
@d2 285
a286 8
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
d288 8
a295 1
*/
d297 4
a300 2
#ifndef _NETINET6_IN6_H
#define _NETINET6_IN6_H 1
d302 5
a306 6
#if !defined(_NETINET_IN_H) && !defined(_NETINET_IN_H_)
#error in6.h should no longer be included directly; include <netinet/in.h>
#endif /* !defined(_NETINET_IN_H) && !defined(_NETINET_IN_H_) */
#if __bsdi__ && !defined(_BSDI_VERSION)
#include <sys/param.h>
#endif /* __bsdi__ && !defined(_BSDI_VERSION) */
d308 36
a343 1
/* IPPROTO type macros. */
d345 6
a350 4
#define IS_PREFRAG(x)   ( (x)==IPPROTO_HOPOPTS || (x)==IPPROTO_ROUTING || \
			 (x) == IPPROTO_DSTOPTS)
#define IS_IPV6OPT(x)   ( (x)==IPPROTO_FRAGMENT || (x) == IPPROTO_AH || \
			 IS_PRFRAG(x) )
d352 8
a359 5
#define CREATE_IPV6_MAPPED(v6, v4) { \
	v6.s6_addr32[0] = 0; \
	v6.s6_addr32[1] = 0; \
	v6.s6_addr32[2] = htonl(0xffff); \
	v6.s6_addr32[3] = v4; }
d361 9
a369 1
#if BYTE_ORDER ==  BIG_ENDIAN
d371 28
a398 4
#define SET_IN6_ALLNODES(a)  {(a).s6_addr32[0]=0xff000000;(a).s6_addr32[3]=1;\
                              (a).s6_addr32[1]=0;(a).s6_addr32[2]=0;}
#define SET_IN6_ALLROUTERS(a)  {(a).s6_addr32[0]=0xff000000;(a).s6_addr32[3]=2;\
                              (a).s6_addr32[1]=0;(a).s6_addr32[2]=0;}
d400 4
a403 3
#define SET_IN6_MCASTSCOPE(a,bits) {(a).s6_addr32[0]&=0xfff0ffff;\
                                    (a).s6_addr32[0]|=(bits<<16);}
#define GET_IN6_MCASTSCOPE(a) ( ((a).s6_addr32[0] & 0x000f0000) >> 16  )
d405 7
a411 1
#else   /* BYTE_ORDER == LITTLE_ENDIAN */
d413 3
a415 4
#define SET_IN6_ALLNODES(a)  {(a).s6_addr32[0]=0xff;(a).s6_addr32[3]=0x01000000;\
                              (a).s6_addr32[1] = 0; (a).s6_addr32[2] = 0;}
#define SET_IN6_ALLROUTERS(a)  {(a).s6_addr32[0]=0xff;(a).s6_addr32[3]=0x02000000;\
                              (a).s6_addr32[1] = 0; (a).s6_addr32[2] = 0;}
d417 5
a421 3
#define SET_IN6_MCASTSCOPE(a,bits) {(a).s6_addr32[0]&=0xfffff0ff;\
                                    (a).s6_addr32[0]|=(bits<<8);}
#define GET_IN6_MCASTSCOPE(a)  ( ((a).s6_addr32[0] & 0x00000f00) >>8)
d423 7
a429 1
#endif  /* BYTE_ORDER == {BIG,LITTLE}_ENDIAN */
d432 1
a432 3
 * IP options for IPv6.  Note I use the IPV6_* semantics for IPv6-
 * specific options.  Another reason for the inclusion of <netinet/in.h> is
 * for the options that are common between IPv6 and IPv4.
d434 4
d439 7
a445 3
#define IN6_MAX_MEMBERSHIPS 20  /* Maximum number of multicast memberships. */
#define IPV6_DEFAULT_MCAST_HOPS 1
#define IPV6_DEFAULT_MCAST_LOOP 1
d447 1
d454 1
d456 2
a457 10
#define	IPV6PROTO_MAXID	(IPPROTO_ICMPV6 + 1)	/* don't list to IPPROTO_MAX. */

#define	CTL_IPV6PROTO_NAMES { \
	{ "ipv6", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "ipv4", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ "tcp", CTLTYPE_NODE }, \
d459 1
d463 1
d466 1
d469 4
d474 1
a475 1
	{ "udp", CTLTYPE_NODE }, \
d478 1
d480 1
d487 1
d489 8
d500 1
a500 28
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "esp", CTLTYPE_NODE }, \
	{ "ah", CTLTYPE_NODE }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ 0, 0 }, \
	{ "icmpv6", CTLTYPE_NODE }, \
d502 1
a502 1
 
d504 1
a504 1
 * Names for IPv6 sysctl objects
d506 3
a508 4

#define	IPV6CTL_FORWARDING	1	/* act as router */
#define	IPV6CTL_SENDREDIRECTS	2	/* may send redirects when forwarding */
#define	IPV6CTL_DEFTTL		3	/* default TTL */
d510 1
a510 1
#define	IPV6CTL_DEFMTU		4	/* default MTU */
d512 33
a544 3
#define	IPV6CTL_STATS		5
#define	IPV6CTL_ROUTERSOLICIT	6
#define	IPV6CTL_MAXID		7
d546 1
a546 1
#define	IPV6CTL_NAMES { \
d550 1
a550 1
	{ "ttl", CTLTYPE_INT }, \
d552 1
a552 2
	{ "stats", CTLTYPE_STRUCT }, \
	{ "routersolicit", CTLTYPE_INT }, \
d554 17
d575 7
a581 1
	&ipv6forwarding, \
d583 11
a593 1
	&ipv6_defhoplmt, \
d595 3
a597 1
	&ipv6rsolicit \
d599 1
d601 48
a648 12
/* Cheesy hack for if net/route.h included... */
#ifdef RTM_VERSION 
/*
 * sizeof(struct sockaddr_in6) > sizeof(struct sockaddr), therefore, I
 * need to define... 
 */ 
struct route6
{
  struct  rtentry *ro_rt;
  struct  sockaddr_in6 ro_dst;
};
#endif RTM_VERSION 
d650 1
a650 5
#if defined(_KERNEL) || defined(KERNEL)
/* Function prototypes go here. */
int in6_cksum __P((struct mbuf *,int, u_int, u_int));
#endif /* defined(_KERNEL) || defined(KERNEL) */
#endif /* _NETINET6_IN6_H */
@


1.6
log
@Demangled the INET6 stuff so as not to require any extra options and not to
be mutually exclusive with the IPSEC option.
@
text
@d31 4
a34 4
	v6.in6a_words[0] = 0; \
	v6.in6a_words[1] = 0; \
	v6.in6a_words[2] = htonl(0xffff); \
	v6.in6a_words[3] = v4; }
d38 8
a45 8
#define SET_IN6_ALLNODES(a)  {(a).in6a_words[0]=0xff000000;(a).in6a_words[3]=1;\
                              (a).in6a_words[1]=0;(a).in6a_words[2]=0;}
#define SET_IN6_ALLROUTERS(a)  {(a).in6a_words[0]=0xff000000;(a).in6a_words[3]=2;\
                              (a).in6a_words[1]=0;(a).in6a_words[2]=0;}

#define SET_IN6_MCASTSCOPE(a,bits) {(a).in6a_words[0]&=0xfff0ffff;\
                                    (a).in6a_words[0]|=(bits<<16);}
#define GET_IN6_MCASTSCOPE(a) ( ((a).in6a_words[0] & 0x000f0000) >> 16  )
d49 8
a56 8
#define SET_IN6_ALLNODES(a)  {(a).in6a_words[0]=0xff;(a).in6a_words[3]=0x01000000;\
                              (a).in6a_words[1] = 0; (a).in6a_words[2] = 0;}
#define SET_IN6_ALLROUTERS(a)  {(a).in6a_words[0]=0xff;(a).in6a_words[3]=0x02000000;\
                              (a).in6a_words[1] = 0; (a).in6a_words[2] = 0;}

#define SET_IN6_MCASTSCOPE(a,bits) {(a).in6a_words[0]&=0xfffff0ff;\
                                    (a).in6a_words[0]|=(bits<<8);}
#define GET_IN6_MCASTSCOPE(a)  ( ((a).in6a_words[0] & 0x00000f00) >>8)
@


1.5
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d188 1
a188 1
#ifdef _KERNEL
d191 1
a191 1
#endif /* _KERNEL */
@


1.4
log
@_KERNEL, and other cleanup
@
text
@a29 28
#if !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802)
struct in6_addr
{
  union 
    {
      uint8_t bytes[16];
      uint32_t words[4];
    } in6a_u;
#define in6a_words in6a_u.words
#define s6_addr in6a_u.bytes
};
#endif /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */

#if !defined(SIN6_LEN)
struct sockaddr_in6 {
#if __linux__
  uint16_t sin6_family;
#else /* __linux__ */
#define SIN6_LEN
  uint8_t sin6_len;
  uint8_t sin6_family;
#endif /* __linux__ */
  uint16_t sin6_port;
  uint32_t sin6_flowinfo;
  struct in6_addr sin6_addr;
};
#endif /* !defined(SIN6_LEN) */

a35 88
#if 0 /* defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) */
#define IN6_ARE_ADDR_EQUAL(x, y) memcmp((x), (y), sizeof(struct in6_addr))
#else /* defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) */
#define IN6_ARE_ADDR_EQUAL(x, y) ( \
        (x)->in6a_words[0] == (y)->in6a_words[0] && \
        (x)->in6a_words[1] == (y)->in6a_words[1] && \
        (x)->in6a_words[2] == (y)->in6a_words[2] && \
        (x)->in6a_words[3] == (y)->in6a_words[3])
#endif /* defined(__GNUC__) && (__GNUC__ >= 2) && defined(__OPTIMIZE__) */

#ifndef IN6_IS_ADDR_UNSPECIFIED
#define IN6_IS_ADDR_UNSPECIFIED(a) ( \
        ((a)->in6a_words[0] == 0) && \
        ((a)->in6a_words[1] == 0) && \
        ((a)->in6a_words[2] == 0) && \
        ((a)->in6a_words[3] == 0))

#define IN6_IS_ADDR_LOOPBACK(a) ( \
        ((a)->in6a_words[0] == 0) && \
        ((a)->in6a_words[1] == 0) && \
        ((a)->in6a_words[2] == 0) && \
        ((a)->in6a_words[3] == htonl(1)))

#define IN6_IS_ADDR_MULTICAST(a) ((a)->s6_addr[0] == 0xff)

#define IN6_IS_ADDR_LINKLOCAL(a) \
        (((a)->in6a_words[0] & htonl(0xffc00000)) == htonl(0xfe800000))

#define IN6_IS_ADDR_SITELOCAL(a) \
        (((a)->in6a_words[0] & htonl(0xffc00000)) == htonl(0xfec00000))

#define IN6_IS_ADDR_V4MAPPED(a) ( \
        ((a)->in6a_words[0] == 0) && \
        ((a)->in6a_words[1] == 0) && \
        ((a)->in6a_words[2] == htonl(0xffff)))

#define IN6_IS_ADDR_V4COMPAT(a) ( \
        ((a)->in6a_words[0] == 0) && \
        ((a)->in6a_words[1] == 0) && \
        ((a)->in6a_words[2] == 0) && \
        ((a)->in6a_words[3] & htonl(0xfffffffe)))

#define IN6_IS_ADDR_MC_NODELOCAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_INTRA_NODE)

#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_INTRA_LINK)

#define IN6_IS_ADDR_MC_SITELOCAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_INTRA_SITE)

#define IN6_IS_ADDR_MC_ORGLOCAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_INTRA_ORG)

#define IN6_IS_ADDR_MC_COMMLOCAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_INTRA_COMM)

#define IN6_IS_ADDR_MC_GLOBAL(a) \
        (GET_IN6_MCASTSCOPE(*a) == IN6_GLOBAL)
#endif /* IN6_IS_ADDR_UNSPECIFIED */

/* NOTE:  IS_IN6_ALL* macros only check the 0x1 and 0x2 scoping levels.
          The IN6 ROAD document doesn't say those are good for higher
          scoping levels.
*/

#define IN6_INTRA_NODE 1  /*  intra-node scope */
#define IN6_INTRA_LINK 2  /*  intra-link scope */
/*            3  (unassigned)
            4  (unassigned)
*/
#define IN6_INTRA_SITE 5  /* intra-site scope */
/*            6  (unassigned)
            7  (unassigned)
*/
#define IN6_INTRA_ORG  8  /* intra-organization scope */
/*            9  (unassigned)
            A  (unassigned)
*/
#define IN6_INTRA_COMM 0xB/*  intra-community scope */
/*            C  (unassigned)
            D  (unassigned)
*/

#define IN6_GLOBAL   0xE  /* global scope*/
/*            F  reserved
*/

a60 12
 * Additonal type information.
 */

#if !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802)
struct ipv6_mreq
{
  struct in6_addr ipv6mr_multiaddr;     /* Group addr. to join/leave. */
  unsigned int ipv6mr_interface;     /* Interface on which to do it. */
};
#endif /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */

/*
a65 36
#ifdef __linux__
#define IPV6_ADDRFORM           1
#define IPV6_PKTINFO            2
#define IPV6_HOPOPTS            3
#define IPV6_DSTOPTS            4
#define IPV6_RTHDR              5
#define IPV6_PKTOPTIONS         6
#define IPV6_CHECKSUM           7
#define IPV6_HOPLIMIT           8

#define IPV6_UNICAST_HOPS       16
#define IPV6_MULTICAST_IF       17
#define IPV6_MULTICAST_HOPS     18
#define IPV6_MULTICAST_LOOP     19
#define IPV6_ADD_MEMBERSHIP     20
#define IPV6_DROP_MEMBERSHIP    21
#else /* __linux__ */
#define	IPV6_OPTIONS		1    /* buf/ipv6_opts; set/get IP options */
#define	IPV6_HDRINCL		2    /* int; header is included with data */
#define	IPV6_TOS		3    /* int; IP type of service and preced. */
#define	IPV6_UNICAST_HOPS	4    /* int; IPv6 unicast hop limit */
#define IPV6_PKTINFO            5    /* struct in6_pktinfo: if. and addr */
#define IPV6_HOPLIMIT		6    /* int; hop limit */
#define IPV6_CHECKSUM		7    /* int: checksum offset */
#define ICMPV6_FILTER		8    /* struct icmpv6_filter: type filter */
#define	IPV6_MULTICAST_IF	9    /* u_int; set/get multicast interface */
#define	IPV6_MULTICAST_HOPS	10   /* int; set/get multicast hop limit */
#define	IPV6_MULTICAST_LOOP	11   /* u_int; set/get multicast loopback */
#define	IPV6_ADD_MEMBERSHIP	12   /* ipv6_mreq; add group membership */
#define	IPV6_DROP_MEMBERSHIP	13   /* ipv6_mreq; drop group membership */

#define IPV6_ADDRFORM         0x16   /* int; get/set form of returned addrs */
#define IPV6_HOPOPTS          0x19   /* int; receive hop-by-hop options */
#define IPV6_DSTOPTS          0x1a   /* int; receive destination options */
#define IPV6_RTHDR            0x1b   /* int; receive routing header */

a191 16
#endif /* __linux__ */

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;

#define IN6ADDR_ANY_INIT {{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }}}
#define IN6ADDR_LOOPBACK_INIT {{{ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }}}

struct in6_pktinfo {
  struct in6_addr ipi6_addr;
  unsigned int ipi6_ifindex;
};

#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46

@


1.3
log
@merge INPROTO_* tables
@
text
@d352 1
a352 1
#ifdef KERNEL
d355 1
a355 1
#endif /* KERNEL */
@


1.2
log
@use _KERNEL, add ipv6intrq decl
@
text
@a22 21
/*
 * Next header types (called Protocols in netinet/in.h).
 */

#define IPPROTO_HOPOPTS		0	/* Hop-by-hop option header. */
#define IPPROTO_IPV4		4	/* IPv4 in IPv6 (?!?) */
/* BAD PLACE #define IPPROTO_IPV6		41	 IPv6 in IPv6 */
#define IPPROTO_ROUTING		43	/* Routing header. */
#define IPPROTO_FRAGMENT	44	/* Fragmentation/reassembly header. */
#define IPPROTO_ESP		50	/* Encapsulating security payload. */
#define IPPROTO_AH		51	/* Authentication header. */
#define IPPROTO_ICMPV6		58      /* ICMP for IPv6 */
#define IPPROTO_NONE		59	/* No next header */
#define IPPROTO_DSTOPTS		60	/* Destination options header. */

/*
 * Following are TBD, and subject to change rapidly
 */
#define IPPROTO_RAW		255	/* Payload of unknown type? */
#define IPPROTO_MAX		256	/* Upper bound for next header type. */

@


1.1
log
@missed file
@
text
@d29 1
a29 1
#define IPPROTO_IPV6		41	/* IPv6 in IPv6 */
@

