head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.12
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.10
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.6
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.17.0.2
	OPENBSD_5_9_BASE:1.17
	OPENBSD_5_8:1.17.0.4
	OPENBSD_5_8_BASE:1.17
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.22
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.20
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.18
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.16
	OPENBSD_5_0:1.15.0.14
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.15.0.12
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.10
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.6
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.8
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.4
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.6
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.12
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.10
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.8
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.6
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.2
	OPENBSD_2_6:1.1.0.4
	OPENBSD_2_6_BASE:1.1
	OPENBSD_2_5:1.1.0.2
	OPENBSD_2_5_BASE:1.1;
locks; strict;
comment	@ * @;


1.17
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.16;
commitid	4Ro7ulidQXNcMvmM;

1.16
date	2014.01.22.14.27.20;	author naddy;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.16.20.30.07;	author avsm;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.18.06.48.05;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.12.01.09.45;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.02.16.15.59.38;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.16.08.22.05;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.09.16.13.34;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.55;	author deraadt;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.07.04.10.55.19;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@More damned eye searing whitespace. No change to .o files.
@
text
@/*	$OpenBSD: in6_cksum.c,v 1.16 2014/01/22 14:27:20 naddy Exp $	*/
/*	$KAME: in6_cksum.c,v 1.10 2000/12/03 00:53:59 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1988, 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_cksum.c	8.1 (Berkeley) 6/10/93
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <netinet/in.h>
#include <netinet/ip6.h>

/*
 * Checksum routine for Internet Protocol family headers (Portable Version).
 *
 * This routine is very heavily used in the network
 * code and should be modified for each CPU to be as fast as possible.
 */

#define ADDCARRY(x)  (x > 65535 ? x -= 65535 : x)
#define REDUCE {l_util.l = sum; sum = l_util.s[0] + l_util.s[1]; ADDCARRY(sum);}

/*
 * m MUST contain a continuous IP6 header.
 * off is a offset where TCP/UDP/ICMP6 header starts.
 * len is a total length of a transport segment.
 * (e.g. TCP header + TCP payload)
 */

int
in6_cksum(struct mbuf *m, u_int8_t nxt, u_int32_t off, u_int32_t len)
{
	u_int16_t *w;
	int sum = 0;
	int mlen = 0;
	int byte_swapped = 0;
	struct ip6_hdr *ip6;
	union {
		u_int16_t phs[4];
		struct {
			u_int32_t	ph_len;
			u_int8_t	ph_zero[3];
			u_int8_t	ph_nxt;
		} ph __packed;
	} uph;
	union {
		u_int8_t	c[2];
		u_int16_t	s;
	} s_util;
	union {
		u_int16_t s[2];
		u_int32_t l;
	} l_util;

	/* sanity check */
	if (m->m_pkthdr.len < off + len) {
		panic("in6_cksum: mbuf len (%d) < off+len (%d+%d)",
			m->m_pkthdr.len, off, len);
	}

	/* Skip pseudo-header if nxt == 0. */
	if (nxt == 0)
		 goto skip_phdr;

	bzero(&uph, sizeof(uph));

	/*
	 * First create IP6 pseudo header and calculate a summary.
	 */
	ip6 = mtod(m, struct ip6_hdr *);
	w = (u_int16_t *)&ip6->ip6_src;
	uph.ph.ph_len = htonl(len);
	uph.ph.ph_nxt = nxt;

	/* IPv6 source address */
	sum += w[0];
	if (!IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
		sum += w[1];
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
	sum += w[6]; sum += w[7];
	/* IPv6 destination address */
	sum += w[8];
	if (!IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
		sum += w[9];
	sum += w[10]; sum += w[11]; sum += w[12]; sum += w[13];
	sum += w[14]; sum += w[15];
	/* Payload length and upper layer identifier */
	sum += uph.phs[0];  sum += uph.phs[1];
	sum += uph.phs[2];  sum += uph.phs[3];

skip_phdr:
	/*
	 * Secondly calculate a summary of the first mbuf excluding offset.
	 */
	while (m != NULL && off > 0) {
		if (m->m_len <= off)
			off -= m->m_len;
		else
			break;
		m = m->m_next;
	}
	w = (u_int16_t *)(mtod(m, u_char *) + off);
	mlen = m->m_len - off;
	if (len < mlen)
		mlen = len;
	len -= mlen;
	/*
	 * Force to even boundary.
	 */
	if ((1 & (long) w) && (mlen > 0)) {
		REDUCE;
		sum <<= 8;
		s_util.c[0] = *(u_char *)w;
		w = (u_int16_t *)((char *)w + 1);
		mlen--;
		byte_swapped = 1;
	}
	/*
	 * Unroll the loop to make overhead from
	 * branches &c small.
	 */
	while ((mlen -= 32) >= 0) {
		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
		sum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];
		sum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];
		sum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];
		w += 16;
	}
	mlen += 32;
	while ((mlen -= 8) >= 0) {
		sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
		w += 4;
	}
	mlen += 8;
	if (mlen == 0 && byte_swapped == 0)
		goto next;
	REDUCE;
	while ((mlen -= 2) >= 0) {
		sum += *w++;
	}
	if (byte_swapped) {
		REDUCE;
		sum <<= 8;
		byte_swapped = 0;
		if (mlen == -1) {
			s_util.c[1] = *(char *)w;
			sum += s_util.s;
			mlen = 0;
		} else
			mlen = -1;
	} else if (mlen == -1)
		s_util.c[0] = *(char *)w;
 next:
	m = m->m_next;

	/*
	 * Lastly calculate a summary of the rest of mbufs.
	 */

	for (;m && len; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		w = mtod(m, u_int16_t *);
		if (mlen == -1) {
			/*
			 * The first byte of this mbuf is the continuation
			 * of a word spanning between this mbuf and the
			 * last mbuf.
			 *
			 * s_util.c[0] is already saved when scanning previous
			 * mbuf.
			 */
			s_util.c[1] = *(char *)w;
			sum += s_util.s;
			w = (u_int16_t *)((char *)w + 1);
			mlen = m->m_len - 1;
			len--;
		} else
			mlen = m->m_len;
		if (len < mlen)
			mlen = len;
		len -= mlen;
		/*
		 * Force to even boundary.
		 */
		if ((1 & (long) w) && (mlen > 0)) {
			REDUCE;
			sum <<= 8;
			s_util.c[0] = *(u_char *)w;
			w = (u_int16_t *)((char *)w + 1);
			mlen--;
			byte_swapped = 1;
		}
		/*
		 * Unroll the loop to make overhead from
		 * branches &c small.
		 */
		while ((mlen -= 32) >= 0) {
			sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
			sum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];
			sum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];
			sum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];
			w += 16;
		}
		mlen += 32;
		while ((mlen -= 8) >= 0) {
			sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
			w += 4;
		}
		mlen += 8;
		if (mlen == 0 && byte_swapped == 0)
			continue;
		REDUCE;
		while ((mlen -= 2) >= 0) {
			sum += *w++;
		}
		if (byte_swapped) {
			REDUCE;
			sum <<= 8;
			byte_swapped = 0;
			if (mlen == -1) {
				s_util.c[1] = *(char *)w;
				sum += s_util.s;
				mlen = 0;
			} else
				mlen = -1;
		} else if (mlen == -1)
			s_util.c[0] = *(char *)w;
	}
	if (len)
		panic("in6_cksum: out of data");
	if (mlen == -1) {
		/* The last mbuf has odd # of bytes. Follow the
		   standard (the odd byte may be shifted left by 8 bits
		   or not as determined by endian-ness of the machine) */
		s_util.c[1] = 0;
		sum += s_util.s;
	}
	REDUCE;
	return (~sum & 0xffff);
}
@


1.16
log
@Split the checksum calculation for IPv6 like for IPv4:
Always calculate the pseudo-header checksum.
Complete the checksum if hardware offload is not available.

Parts originally from NetBSD; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.15 2008/06/11 19:00:50 mcbride Exp $	*/
d94 1
a94 1
	struct ip6_hdr *ip6;	
d216 1
a216 1
	
@


1.15
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.14 2006/11/17 01:11:23 itojun Exp $	*/
d118 4
d148 1
@


1.14
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.13 2003/11/16 20:30:07 avsm Exp $	*/
d88 1
a88 4
in6_cksum(m, nxt, off, len)
	struct mbuf *m;
	u_int8_t nxt;
	u_int32_t off, len;
@


1.13
log
@convert __attribute__((__packed__)) to __packed so that parsers unaware
of gcc extensions have more of a chance.
ok mcbride@@, no objections from millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.12 2003/07/18 06:48:05 itojun Exp $	*/
d133 1
a133 1
	if (!IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d139 1
a139 1
	if (!IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
@


1.12
log
@remove #if 0 portion
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.11 2003/06/02 23:28:15 millert Exp $	*/
d104 1
a104 1
		} ph __attribute__((__packed__));
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.10 2002/10/12 01:09:45 krw Exp $	*/
a96 3
#if 0
	int srcifid = 0, dstifid = 0;
#endif
a126 10
#if 0
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src)) {
		srcifid = ip6->ip6_src.s6_addr16[1];
		ip6->ip6_src.s6_addr16[1] = 0;
	}
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst)) {
		dstifid = ip6->ip6_dst.s6_addr16[1];
		ip6->ip6_dst.s6_addr16[1] = 0;
	}
#endif
a146 6
#if 0
	if (srcifid)
		ip6->ip6_src.s6_addr16[1] = srcifid;
	if (dstifid)
		ip6->ip6_dst.s6_addr16[1] = dstifid;
#endif
@


1.10
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.9 2001/06/09 06:43:37 angelos Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.8 2001/02/16 15:59:38 itojun Exp $	*/
d124 1
a124 1
		panic("in6_cksum: mbuf len (%d) < off+len (%d+%d)\n",
d309 1
a309 1
		panic("in6_cksum: out of data\n");
@


1.9.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.9 2001/06/09 06:43:37 angelos Exp $	*/
d124 1
a124 1
		panic("in6_cksum: mbuf len (%d) < off+len (%d+%d)",
d309 1
a309 1
		panic("in6_cksum: out of data");
@


1.8
log
@cosmetic sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.7 2001/02/16 08:22:05 itojun Exp $	*/
a72 2

#include <net/net_osdep.h>
@


1.7
log
@kill register declarations.  to sync with kame better.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_cksum.c,v 1.6 2000/09/09 16:13:34 itojun Exp $	*/
/*	$KAME: in6_cksum.c,v 1.9 2000/09/09 15:33:31 itojun Exp $	*/
@


1.6
log
@add attribute(packed) for alignment constraint on a union.
get rid of file static variable, make it an auto variable.
(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.5 2000/02/28 11:55:22 itojun Exp $	*/
d95 1
a95 1
	register struct mbuf *m;
d99 3
a101 3
	register u_int16_t *w;
	register int sum = 0;
	register int mlen = 0;
@


1.5
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_cksum.c,v 1.4 2000/02/07 06:09:09 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
a85 9
static union {
	u_int16_t phs[4];
	struct {
		u_int32_t	ph_len;
		u_int8_t	ph_zero[3];
		u_int8_t	ph_nxt;
	} ph;
} uph;

d107 8
a114 1
	
d130 2
d154 1
a154 1
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5]; 
d250 1
a250 1
			 * s_util.c[0] is already saved when scanning previous 
@


1.4
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_cksum.c,v 1.3 1999/12/10 08:53:17 angelos Exp $ */
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.4.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6_cksum.c,v 1.8 2001/02/16 15:59:38 itojun Exp $	*/
/*	$KAME: in6_cksum.c,v 1.10 2000/12/03 00:53:59 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d85 9
d103 1
a103 1
	struct mbuf *m;
d107 3
a109 3
	u_int16_t *w;
	int sum = 0;
	int mlen = 0;
d115 1
a115 8
	union {
		u_int16_t phs[4];
		struct {
			u_int32_t	ph_len;
			u_int8_t	ph_zero[3];
			u_int8_t	ph_nxt;
		} ph __attribute__((__packed__));
	} uph;
a130 2
	bzero(&uph, sizeof(uph));

d153 1
a153 1
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
d249 1
a249 1
			 * s_util.c[0] is already saved when scanning previous
@


1.4.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.4.2.2 2001/05/14 22:40:17 niklas Exp $	*/
d73 2
@


1.4.2.4
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d124 1
a124 1
		panic("in6_cksum: mbuf len (%d) < off+len (%d+%d)",
d309 1
a309 1
		panic("in6_cksum: out of data");
@


1.4.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_cksum.c,v 1.4.2.4 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 3
d107 1
a107 1
		} ph __packed;
d130 10
d160 6
@


1.3
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d71 1
a71 1
#include <netinet6/ip6.h>
@


1.2
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 2
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@d2 27
a28 8
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
a29 1
*/
d31 2
a32 2
 * Copyright (c) 1988 Regents of the University of California.
 * All rights reserved.
d62 1
a62 1
 * (Originally from)	@@(#)in_cksum.c	7.3 (Berkeley) 6/28/90
a65 1
#include <sys/types.h>
d68 2
d71 8
a78 3
#include <netinet/in.h>
#include <netinet6/in6.h>
#include <netinet6/ipv6.h>
d81 10
a90 2
#define REDUCE \
{l_util.l = sum; sum = l_util.s[0] + l_util.s[1]; ADDCARRY(sum);}
d92 6
a97 8
/*----------------------------------------------------------------------
 * in6_cksum() takes an mbuf chain (with a IPv6 header at the beginning), and
 * computes the checksum.   This also assumes that the IPv6 header is pulled 
 * up into the first mbuf in the chain, and that said header has valid
 * source and destination fields.  I do the pseudo-header first, then
 * I do the rest.  Unlike v4, I treat the pseudo-header separately, so
 * transports don't have to do funky gymnastics with zeroing out headers.
 ----------------------------------------------------------------------*/
d100 4
a103 10
in6_cksum(m, proto, len, start)
     struct mbuf *m;	/* Chain, complete with IPv6 header. */
     int proto;		/* Protocol number of HLP that needs sum. */
     uint len;		/* Length of stuff to checksum.   Note that len
			   and proto are what get computed in the pseudo-
			   header.  Len is a uint because of potential
			   jumbograms. */
     uint start;	/* How far (in bytes) into chain's data to
			   start remainder of computation.  (e.g. Where
			   the TCP segment begins. */
d105 126
a230 53
  u_short *w;
  int sum = 0;
  int mlen = 0;
  int byte_swapped = 0;
  struct ipv6 *header;
  short done = 0;
  union 
    {
      uint8_t	c[2];
      uint16_t	s;
    } s_util;
  union
    {
      uint16_t	s[2];
      uint32_t	l;
    } l_util;

  /*
   * Get pseudo-header summed up.  Assume ipv6 is first.
   * I do pseudo-header here because it'll save bletch in both TCP and
   * UDP.
   */
  
  header = mtod(m,struct ipv6 *);

  w = (u_short *)&(header->ipv6_src);
  /* Source address */
  sum+=w[0]; sum+=w[1]; sum+=w[2]; sum+=w[3];
  sum+=w[4]; sum+=w[5]; sum+=w[6]; sum+=w[7];

  /* Destination address */
  sum+=w[8]; sum+=w[9]; sum+=w[10]; sum+=w[11];
  sum+=w[12]; sum+=w[13]; sum+=w[14]; sum+=w[15];

  /* Next header value for transport layer. */
  sum += htons(proto);

  /* Length of transport header and transport data. */
  l_util.l = htonl(len);
  sum+=l_util.s[0];
  sum+=l_util.s[1];

  /* Find starting point for rest of data.. */
  
  while (!done)
    if (m->m_len >start)
      {
	done = 1;
	mlen = m->m_len - start;
      }
    else
      {
	start -= m->m_len;
a231 5
      }

  for (;m && len; m = m->m_next) {
    if (m->m_len == 0)
      continue;
a232 4
    w = (u_short *)(m->m_data + (done ? start : 0));

    if (mlen == -1) 
      {
d234 1
a234 6
	 * The first byte of this mbuf is the continuation
	 * of a word spanning between this mbuf and the
	 * last mbuf.
	 *
	 * s_util.c[0] is already saved when scanning previous 
	 * mbuf.
d236 82
a317 79
	s_util.c[1] = *(char *)w;
	sum += s_util.s;
	w = (u_short *)((char *)w + 1);
	mlen = m->m_len - 1;
	len--;
      }
    else 
      if (!done)
	mlen = m->m_len;
      else done=0;
    
    if (len < mlen)
      mlen = len;
    len -= mlen;

    /*
     * Force to even boundary.
     */
#ifdef	__alpha__
    if ((1 & (long) w) && (mlen > 0)) {
#else
    if ((1 & (int) w) && (mlen > 0)) {
#endif
      REDUCE;
      sum <<= 8;
      s_util.c[0] = *(u_char *)w;
      w = (u_short *)((char *)w + 1);
      mlen--;
      byte_swapped = 1;
    }
    /*
     * Unroll the loop to make overhead from
     * branches small.
     */
    while ((mlen -= 32) >= 0) {
      sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
      sum += w[4]; sum += w[5]; sum += w[6]; sum += w[7];
      sum += w[8]; sum += w[9]; sum += w[10]; sum += w[11];
      sum += w[12]; sum += w[13]; sum += w[14]; sum += w[15];
      w += 16;
    }
    mlen += 32;
    while ((mlen -= 8) >= 0) {
      sum += w[0]; sum += w[1]; sum += w[2]; sum += w[3];
      w += 4;
    }
    mlen += 8;
    if (mlen == 0 && byte_swapped == 0)
      continue;
    REDUCE;
    while ((mlen -= 2) >= 0) {
      sum += *w++;
    }
    if (byte_swapped) {
      REDUCE;
      sum <<= 8;
      byte_swapped = 0;
      if (mlen == -1) {
	s_util.c[1] = *(char *)w;
	sum += s_util.s;
	mlen = 0;
      } else
	mlen = -1;
    } else if (mlen == -1)
      s_util.c[0] = *(char *)w;
  }
  if (len)
    printf("in6_cksum: out of data\n");
  if (mlen == -1) {
    /*
     * The last mbuf has odd # of bytes. Follow the
     * standard (the odd byte may be shifted left by 8 bits
     * or not as determined by endian-ness of the machine)
     */
    s_util.c[1] = 0;
    sum += s_util.s;
  }
  REDUCE;
  return(~sum & 0xffff);
@

