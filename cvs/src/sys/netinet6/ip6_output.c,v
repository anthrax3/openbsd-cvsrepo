head	1.226;
access;
symbols
	OPENBSD_6_1:1.226.0.2
	OPENBSD_6_1_BASE:1.226
	OPENBSD_6_0:1.211.0.2
	OPENBSD_6_0_BASE:1.211
	OPENBSD_5_9:1.204.0.2
	OPENBSD_5_9_BASE:1.204
	OPENBSD_5_8:1.177.0.4
	OPENBSD_5_8_BASE:1.177
	OPENBSD_5_7:1.167.0.2
	OPENBSD_5_7_BASE:1.167
	OPENBSD_5_6:1.158.0.4
	OPENBSD_5_6_BASE:1.158
	OPENBSD_5_5:1.153.0.4
	OPENBSD_5_5_BASE:1.153
	OPENBSD_5_4:1.142.0.2
	OPENBSD_5_4_BASE:1.142
	OPENBSD_5_3:1.132.0.2
	OPENBSD_5_3_BASE:1.132
	OPENBSD_5_2:1.125.0.2
	OPENBSD_5_2_BASE:1.125
	OPENBSD_5_1_BASE:1.123
	OPENBSD_5_1:1.123.0.2
	OPENBSD_5_0:1.122.0.2
	OPENBSD_5_0_BASE:1.122
	OPENBSD_4_9:1.118.0.2
	OPENBSD_4_9_BASE:1.118
	OPENBSD_4_8:1.117.0.2
	OPENBSD_4_8_BASE:1.117
	OPENBSD_4_7:1.111.0.2
	OPENBSD_4_7_BASE:1.111
	OPENBSD_4_6:1.106.0.6
	OPENBSD_4_6_BASE:1.106
	OPENBSD_4_5:1.106.0.2
	OPENBSD_4_5_BASE:1.106
	OPENBSD_4_4:1.103.0.2
	OPENBSD_4_4_BASE:1.103
	OPENBSD_4_3:1.99.0.4
	OPENBSD_4_3_BASE:1.99
	OPENBSD_4_2:1.99.0.2
	OPENBSD_4_2_BASE:1.99
	OPENBSD_4_1:1.98.0.2
	OPENBSD_4_1_BASE:1.98
	OPENBSD_4_0:1.93.0.2
	OPENBSD_4_0_BASE:1.93
	OPENBSD_3_9:1.87.0.6
	OPENBSD_3_9_BASE:1.87
	OPENBSD_3_8:1.87.0.4
	OPENBSD_3_8_BASE:1.87
	OPENBSD_3_7:1.87.0.2
	OPENBSD_3_7_BASE:1.87
	OPENBSD_3_6:1.86.0.2
	OPENBSD_3_6_BASE:1.86
	SMP_SYNC_A:1.85
	SMP_SYNC_B:1.82
	OPENBSD_3_5:1.82.0.2
	OPENBSD_3_5_BASE:1.82
	OPENBSD_3_4:1.76.0.2
	OPENBSD_3_4_BASE:1.76
	UBC_SYNC_A:1.73
	OPENBSD_3_3:1.73.0.2
	OPENBSD_3_3_BASE:1.73
	OPENBSD_3_2:1.72.0.2
	OPENBSD_3_2_BASE:1.72
	OPENBSD_3_1:1.58.0.2
	OPENBSD_3_1_BASE:1.58
	UBC_SYNC_B:1.72
	UBC:1.56.0.2
	UBC_BASE:1.56
	OPENBSD_3_0:1.52.0.2
	OPENBSD_3_0_BASE:1.52
	OPENBSD_2_9_BASE:1.32
	OPENBSD_2_9:1.32.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.4.0.4
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.226
date	2017.02.21.15.33.52;	author dhill;	state Exp;
branches;
next	1.225;
commitid	ebxzw3U0Ccq6yjvl;

1.225
date	2017.02.09.15.19.32;	author jca;	state Exp;
branches;
next	1.224;
commitid	Hew5AYIxyEp5lNbI;

1.224
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.223;
commitid	2R0NOjEDy2jGtnjL;

1.223
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.222;
commitid	UBL7uwpXqTP4EWIu;

1.222
date	2017.01.27.02.55.36;	author dhill;	state Exp;
branches;
next	1.221;
commitid	jnWCo5Y1LJ4Ja5pe;

1.221
date	2017.01.19.14.49.19;	author bluhm;	state Exp;
branches;
next	1.220;
commitid	15IMDG7eAMZX5Azd;

1.220
date	2017.01.10.09.04.19;	author mpi;	state Exp;
branches;
next	1.219;
commitid	pAsrayiMacyBYusm;

1.219
date	2017.01.10.09.01.18;	author mpi;	state Exp;
branches;
next	1.218;
commitid	xP9gcRskiS0BKnO6;

1.218
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.217;
commitid	VkivwyRVzetroSYM;

1.217
date	2016.11.14.10.32.46;	author mpi;	state Exp;
branches;
next	1.216;
commitid	to0Je2i4V2FtpmS1;

1.216
date	2016.09.19.18.09.09;	author tedu;	state Exp;
branches;
next	1.215;
commitid	3wAktwQDJ8hs7BVM;

1.215
date	2016.09.14.16.59.28;	author jca;	state Exp;
branches;
next	1.214;
commitid	lUbTtI9t5ndiHSyX;

1.214
date	2016.09.14.15.26.05;	author jca;	state Exp;
branches;
next	1.213;
commitid	ZDxMUEcQaT1GTKHC;

1.213
date	2016.08.25.12.30.16;	author mpi;	state Exp;
branches;
next	1.212;
commitid	SqeAaz5n46GoUBiy;

1.212
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.211;
commitid	ZsKqEaqTKPu9hWk6;

1.211
date	2016.07.01.18.18.57;	author jca;	state Exp;
branches;
next	1.210;
commitid	BNDooYyS3pjisYiY;

1.210
date	2016.06.27.16.33.48;	author jca;	state Exp;
branches;
next	1.209;
commitid	s8BpQvqrMutiVjd6;

1.209
date	2016.06.15.13.49.43;	author florian;	state Exp;
branches;
next	1.208;
commitid	lROdGDdbb5OMjJWw;

1.208
date	2016.06.15.11.49.34;	author mpi;	state Exp;
branches;
next	1.207;
commitid	qWegq9wDcxofLjIV;

1.207
date	2016.05.19.11.34.40;	author jca;	state Exp;
branches;
next	1.206;
commitid	vkyQX2LT0UqUpZLs;

1.206
date	2016.04.29.11.40.27;	author bluhm;	state Exp;
branches;
next	1.205;
commitid	AssGqte7zoGfKhWv;

1.205
date	2016.04.27.21.14.29;	author markus;	state Exp;
branches;
next	1.204;
commitid	nWBKWy8IKn6P3HG1;

1.204
date	2016.01.21.11.23.48;	author mpi;	state Exp;
branches;
next	1.203;
commitid	5qLGnZtXVLeqUvHc;

1.203
date	2016.01.13.09.38.37;	author mpi;	state Exp;
branches;
next	1.202;
commitid	VcTQSOywv2kbh0dq;

1.202
date	2015.12.03.10.34.24;	author tedu;	state Exp;
branches;
next	1.201;
commitid	gajQhAV7FbVEB3lm;

1.201
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.200;
commitid	Hf3C2AvfIXmCAmHE;

1.200
date	2015.11.29.15.12.36;	author mpi;	state Exp;
branches;
next	1.199;
commitid	Y1XF52H4czcWU2Lu;

1.199
date	2015.11.11.10.23.23;	author mpi;	state Exp;
branches;
next	1.198;
commitid	HAbRB9Scbg3IhXig;

1.198
date	2015.11.03.21.39.34;	author chl;	state Exp;
branches;
next	1.197;
commitid	iKw3fv7fbm1Ty7ms;

1.197
date	2015.11.03.21.11.48;	author naddy;	state Exp;
branches;
next	1.196;
commitid	1HYJIt80GJiehNdy;

1.196
date	2015.10.29.16.27.45;	author tedu;	state Exp;
branches;
next	1.195;
commitid	TgvAHDJ1Z6iBjdXu;

1.195
date	2015.10.29.16.22.45;	author tedu;	state Exp;
branches;
next	1.194;
commitid	s55neCfPC6pThHnq;

1.194
date	2015.10.29.16.04.10;	author tedu;	state Exp;
branches;
next	1.193;
commitid	T9Dafq4uwVrQzJzv;

1.193
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.192;
commitid	Ajb0hNGeCqGFHjjg;

1.192
date	2015.10.25.14.43.06;	author florian;	state Exp;
branches;
next	1.191;
commitid	YdNR4Tx8Af0XRTgT;

1.191
date	2015.10.24.12.33.16;	author mpi;	state Exp;
branches;
next	1.190;
commitid	FKjowUWiF07inZqL;

1.190
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.189;
commitid	aMzCQ7pRC6VLKZyx;

1.189
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.188;
commitid	24xqlqpNt9NPeWH3;

1.188
date	2015.09.13.13.57.07;	author mpi;	state Exp;
branches;
next	1.187;
commitid	MPWO7hyiGcG1NP0J;

1.187
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.186;
commitid	UM7jfgLT8vWQUBm1;

1.186
date	2015.09.12.13.34.12;	author mpi;	state Exp;
branches;
next	1.185;
commitid	LU3jSOpFfLxcllFL;

1.185
date	2015.09.11.20.16.03;	author claudio;	state Exp;
branches;
next	1.184;
commitid	FB0cvtO9tSu02Aw9;

1.184
date	2015.09.11.19.23.00;	author mpi;	state Exp;
branches;
next	1.183;
commitid	ZcCSlMJqT7JT7yQD;

1.183
date	2015.09.11.13.53.04;	author mpi;	state Exp;
branches;
next	1.182;
commitid	PQQVxswGql4gzKJa;

1.182
date	2015.09.11.09.58.33;	author mpi;	state Exp;
branches;
next	1.181;
commitid	QtNDimZdovXpU3uh;

1.181
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.180;
commitid	Cr0DVA7exR1t2zXg;

1.180
date	2015.09.10.09.11.11;	author mpi;	state Exp;
branches;
next	1.179;
commitid	oAGvaWMHG4vrTCJP;

1.179
date	2015.08.31.07.27.48;	author mpi;	state Exp;
branches;
next	1.178;
commitid	6p61V7DpTdZ4HIcj;

1.178
date	2015.08.31.07.17.12;	author mpi;	state Exp;
branches;
next	1.177;
commitid	cniCJ6rbTz2M0Mvg;

1.177
date	2015.07.16.21.14.21;	author mpi;	state Exp;
branches;
next	1.176;
commitid	VGPlklxThaST7mIm;

1.176
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.175;
commitid	ncpqEGjDtSFuLAgn;

1.175
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.174;
commitid	J4OPNuggl4DOKGzM;

1.174
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.173;
commitid	h7z8lokZ0dFyuWpg;

1.173
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.172;
commitid	4Ro7ulidQXNcMvmM;

1.172
date	2015.05.23.12.52.59;	author markus;	state Exp;
branches;
next	1.171;
commitid	XxDCtGxlGi1shqAt;

1.171
date	2015.05.13.10.42.47;	author jsg;	state Exp;
branches;
next	1.170;
commitid	hN5bFCE56DrAjl99;

1.170
date	2015.04.17.11.04.02;	author mikeb;	state Exp;
branches;
next	1.169;
commitid	6glXvFR7NxzCcdRd;

1.169
date	2015.04.16.19.24.13;	author markus;	state Exp;
branches;
next	1.168;
commitid	2c41FFL8044mZVko;

1.168
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.167;
commitid	p4LJxGKbi0BU2cG6;

1.167
date	2015.02.12.12.12.45;	author mpi;	state Exp;
branches;
next	1.166;
commitid	VChNawKb235dL5ib;

1.166
date	2015.02.05.01.10.57;	author mpi;	state Exp;
branches;
next	1.165;
commitid	Vt4pFgzpwezZJ2dA;

1.165
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.164;
commitid	cYQY7jiay4SydLhD;

1.164
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.163;
commitid	Vq8oSnWLkf7dyy0N;

1.163
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.162;
commitid	t9FBKDfc4VDxpEy2;

1.162
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.161;
commitid	F3Fu23ZZ8dwzir4r;

1.161
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.160;
commitid	w0MRp28dmfD1ZzO8;

1.160
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.159;
commitid	6AYfDT0Lpez1LFQp;

1.159
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.158;
commitid	HQcmytntiCJTHORs;

1.158
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.157;
commitid	DQakU8LLWV6Iwx84;

1.157
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.156;
commitid	B4dZSbxas1X1IpXI;

1.156
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.155;

1.155
date	2014.04.20.16.48.22;	author naddy;	state Exp;
branches;
next	1.154;

1.154
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2014.01.23.23.51.29;	author henning;	state Exp;
branches;
next	1.152;

1.152
date	2014.01.23.01.10.42;	author naddy;	state Exp;
branches;
next	1.151;

1.151
date	2014.01.22.14.27.20;	author naddy;	state Exp;
branches;
next	1.150;

1.150
date	2014.01.21.10.18.26;	author mpi;	state Exp;
branches;
next	1.149;

1.149
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.148;

1.148
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.147;

1.147
date	2013.10.21.12.40.39;	author deraadt;	state Exp;
branches;
next	1.146;

1.146
date	2013.10.21.08.44.13;	author phessler;	state Exp;
branches;
next	1.145;

1.145
date	2013.10.20.13.44.24;	author henning;	state Exp;
branches;
next	1.144;

1.144
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.143;

1.143
date	2013.07.31.15.41.52;	author mikeb;	state Exp;
branches;
next	1.142;

1.142
date	2013.07.04.19.10.41;	author sf;	state Exp;
branches;
next	1.141;

1.141
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.140;

1.140
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.139;

1.139
date	2013.04.11.12.06.25;	author mpi;	state Exp;
branches;
next	1.138;

1.138
date	2013.04.09.08.35.38;	author mpi;	state Exp;
branches;
next	1.137;

1.137
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.136;

1.136
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.135;

1.135
date	2013.03.20.10.34.12;	author mpi;	state Exp;
branches;
next	1.134;

1.134
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.133;

1.133
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.132;

1.132
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.131;

1.131
date	2012.11.05.21.49.15;	author claudio;	state Exp;
branches;
next	1.130;

1.130
date	2012.11.02.13.14.05;	author henning;	state Exp;
branches;
next	1.129;

1.129
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.128;

1.128
date	2012.10.16.08.09.09;	author bluhm;	state Exp;
branches;
next	1.127;

1.127
date	2012.09.20.10.25.03;	author blambert;	state Exp;
branches;
next	1.126;

1.126
date	2012.09.17.20.01.26;	author yasuoka;	state Exp;
branches;
next	1.125;

1.125
date	2012.07.16.18.05.36;	author markus;	state Exp;
branches
	1.125.2.1;
next	1.124;

1.124
date	2012.04.13.09.38.32;	author deraadt;	state Exp;
branches;
next	1.123;

1.123
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2011.07.04.06.54.49;	author claudio;	state Exp;
branches;
next	1.121;

1.121
date	2011.05.02.22.17.28;	author chl;	state Exp;
branches;
next	1.120;

1.120
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.119;

1.119
date	2011.03.22.23.13.01;	author bluhm;	state Exp;
branches;
next	1.118;

1.118
date	2010.09.23.04.45.15;	author yasuoka;	state Exp;
branches;
next	1.117;

1.117
date	2010.08.07.03.50.02;	author krw;	state Exp;
branches;
next	1.116;

1.116
date	2010.07.09.16.58.06;	author reyk;	state Exp;
branches;
next	1.115;

1.115
date	2010.07.08.19.42.46;	author jsg;	state Exp;
branches;
next	1.114;

1.114
date	2010.07.01.02.09.45;	author reyk;	state Exp;
branches;
next	1.113;

1.113
date	2010.06.29.21.28.38;	author reyk;	state Exp;
branches;
next	1.112;

1.112
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.02.08.12.16.02;	author jsing;	state Exp;
branches;
next	1.110;

1.110
date	2009.11.25.07.37.29;	author mpf;	state Exp;
branches;
next	1.109;

1.109
date	2009.11.20.09.02.21;	author guenther;	state Exp;
branches;
next	1.108;

1.108
date	2009.10.28.21.03.17;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2009.10.06.21.21.48;	author claudio;	state Exp;
branches;
next	1.106;

1.106
date	2008.10.22.14.36.08;	author markus;	state Exp;
branches
	1.106.2.1
	1.106.6.1;
next	1.105;

1.105
date	2008.09.03.08.41.57;	author mpf;	state Exp;
branches;
next	1.104;

1.104
date	2008.08.08.17.49.21;	author bluhm;	state Exp;
branches;
next	1.103;

1.103
date	2008.07.30.15.07.40;	author canacar;	state Exp;
branches
	1.103.2.1;
next	1.102;

1.102
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.101;

1.101
date	2008.06.09.22.47.42;	author djm;	state Exp;
branches;
next	1.100;

1.100
date	2008.03.31.21.15.20;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.98;

1.98
date	2007.02.08.15.25.30;	author itojun;	state Exp;
branches;
next	1.97;

1.97
date	2006.12.10.10.16.12;	author miod;	state Exp;
branches;
next	1.96;

1.96
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.95;

1.95
date	2006.12.08.21.32.12;	author itojun;	state Exp;
branches;
next	1.94;

1.94
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.93;

1.93
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.92;

1.92
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.91;

1.91
date	2006.06.16.15.31.08;	author pascoe;	state Exp;
branches;
next	1.90;

1.90
date	2006.06.16.15.16.41;	author pascoe;	state Exp;
branches;
next	1.89;

1.89
date	2006.05.27.23.40.27;	author claudio;	state Exp;
branches;
next	1.88;

1.88
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.11.08.57.24;	author djm;	state Exp;
branches;
next	1.86;

1.86
date	2004.06.21.19.26.02;	author mcbride;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.12.04.58.48;	author itojun;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.11.14.27.13;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.11.08.09.29;	author itojun;	state Exp;
branches;
next	1.82;

1.82
date	2004.02.04.08.47.41;	author itojun;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.02.20.13.01;	author cedric;	state Exp;
branches;
next	1.80;

1.80
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.07.22.32.47;	author itojun;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.01.21.35.50;	author itojun;	state Exp;
branches;
next	1.76;

1.76
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.73;

1.73
date	2002.10.31.18.02.27;	author itojun;	state Exp;
branches
	1.73.2.1;
next	1.72;

1.72
date	2002.09.23.23.03.31;	author itojun;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.69;

1.69
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.68;

1.68
date	2002.06.08.21.52.07;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2002.06.07.21.47.44;	author itojun;	state Exp;
branches;
next	1.64;

1.64
date	2002.06.07.15.27.58;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2002.06.07.15.00.55;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2002.06.07.04.13.10;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.05.31.03.20.01;	author itojun;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.29.23.38.58;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.57;

1.57
date	2002.01.21.05.33.14;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2001.11.28.10.48.13;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2001.11.26.16.50.26;	author jasoni;	state Exp;
branches;
next	1.52;

1.52
date	2001.10.01.16.03.09;	author jasoni;	state Exp;
branches;
next	1.51;

1.51
date	2001.09.25.14.54.31;	author jasoni;	state Exp;
branches;
next	1.50;

1.50
date	2001.09.15.03.54.40;	author frantzen;	state Exp;
branches;
next	1.49;

1.49
date	2001.08.22.14.18.36;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	2001.08.22.06.52.01;	author niklas;	state Exp;
branches;
next	1.47;

1.47
date	2001.08.21.06.53.36;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.27.03.49.54;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.27.01.36.02;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.25.17.16.27;	author angelos;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.25.06.14.18;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.25.02.59.02;	author angelos;	state Exp;
branches;
next	1.41;

1.41
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.30.12.31.09;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.28.06.45.32;	author angelos;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.28.05.28.22;	author angelos;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.28.05.27.30;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.28.05.26.53;	author angelos;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.26.06.57.20;	author angelos;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.20.08.36.01;	author angelos;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.16.12.53.36;	author ho;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.14.00.30.59;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.11.04.49.23;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.30.11.09.02;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.28.20.03.08;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.25.09.56.00;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.21.15.01.09;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.13.03.35.15;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2001.02.16.16.38.15;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.16.14.58.13;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.16.08.48.06;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.02.16.08.22.06;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.08.18.46.23;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.06.01.26.58;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2001.02.06.00.22.23;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.02.15.55.18;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.11.09.14.15;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.19.03.23.16;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.16.13.58.23;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.19.09.17.36;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.20.20.51.26;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.20.01.27.24;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.19.03.43.17;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.18.17.31.14;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.18.02.00.20;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.03.13.43.45;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.19.20.12.10;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.19.13.55.17;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.19.05.14.45;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	99.12.20.07.49.06;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.40.19;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.07.04.10.55.23;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.10.31.03.29.04;	author nate;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.4.4.1
date	2000.09.18.16.45.18;	author jason;	state Exp;
branches;
next	;

1.56.2.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.56.2.2;

1.56.2.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.56.2.3;

1.56.2.3
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.56.2.4;

1.56.2.4
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.73.2.1
date	2004.02.07.22.11.34;	author brad;	state Exp;
branches;
next	;

1.76.2.1
date	2004.02.07.22.08.00;	author brad;	state Exp;
branches;
next	;

1.103.2.1
date	2009.10.28.21.20.39;	author claudio;	state Exp;
branches;
next	;

1.106.2.1
date	2009.10.28.21.20.16;	author claudio;	state Exp;
branches;
next	;

1.106.6.1
date	2009.10.28.21.19.18;	author claudio;	state Exp;
branches;
next	;

1.123.2.1
date	2012.10.17.11.36.29;	author ajacoutot;	state Exp;
branches;
next	;

1.125.2.1
date	2012.10.17.11.37.05;	author ajacoutot;	state Exp;
branches;
next	;


desc
@@


1.226
log
@In ip6_ctloutput, check for an invalid level early like the other
*ctloutput functions.  This also reduces a level of indentation.

ok mpi@@
@
text
@/*	$OpenBSD: ip6_output.c,v 1.225 2017/02/09 15:19:32 jca Exp $	*/
/*	$KAME: ip6_output.c,v 1.172 2001/03/25 09:55:56 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1988, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_output.c	8.3 (Berkeley) 1/21/94
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_enc.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>

#include <netinet/ip_var.h>
#include <netinet/tcp_timer.h>
#include <netinet/tcp_var.h>
#include <netinet/udp_var.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet/icmp6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6protosw.h>

#include <crypto/idgen.h>

#if NPF > 0
#include <net/pfvar.h>
#endif

#ifdef IPSEC
#include <netinet/ip_ipsp.h>
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#endif /* IPSEC */

struct ip6_exthdrs {
	struct mbuf *ip6e_ip6;
	struct mbuf *ip6e_hbh;
	struct mbuf *ip6e_dest1;
	struct mbuf *ip6e_rthdr;
	struct mbuf *ip6e_dest2;
};

int ip6_pcbopt(int, u_char *, int, struct ip6_pktopts **, int, int);
int ip6_getpcbopt(struct ip6_pktopts *, int, struct mbuf *);
int ip6_setpktopt(int, u_char *, int, struct ip6_pktopts *, int, int, int);
int ip6_setmoptions(int, struct ip6_moptions **, struct mbuf *);
int ip6_getmoptions(int, struct ip6_moptions *, struct mbuf *);
int ip6_copyexthdr(struct mbuf **, caddr_t, int);
int ip6_insertfraghdr(struct mbuf *, struct mbuf *, int,
	struct ip6_frag **);
int ip6_insert_jumboopt(struct ip6_exthdrs *, u_int32_t);
int ip6_splithdr(struct mbuf *, struct ip6_exthdrs *);
int ip6_getpmtu(struct rtentry *, struct ifnet *, u_long *);
int copypktopts(struct ip6_pktopts *, struct ip6_pktopts *);
static __inline u_int16_t __attribute__((__unused__))
    in6_cksum_phdr(const struct in6_addr *, const struct in6_addr *,
    u_int32_t, u_int32_t);
void in6_delayed_cksum(struct mbuf *, u_int8_t);

/* Context for non-repeating IDs */
struct idgen32_ctx ip6_id_ctx;

/*
 * IP6 output. The packet in mbuf chain m contains a skeletal IP6
 * header (with pri, len, nxt, hlim, src, dst).
 * This function may modify ver and hlim only.
 * The mbuf chain containing the packet will be freed.
 * The mbuf opt, if present, will not be freed.
 *
 * type of "mtu": rt_rmx.rmx_mtu is u_long, ifnet.ifr_mtu is int, and
 * nd_ifinfo.linkmtu is u_int32_t.  so we use u_long to hold largest one,
 * which is rt_rmx.rmx_mtu.
 */
int
ip6_output(struct mbuf *m0, struct ip6_pktopts *opt, struct route_in6 *ro,
    int flags, struct ip6_moptions *im6o, struct inpcb *inp)
{
	struct ip6_hdr *ip6;
	struct ifnet *ifp = NULL;
	struct mbuf *m = m0;
	int hlen, tlen;
	struct route_in6 ip6route;
	struct rtentry *rt = NULL;
	struct sockaddr_in6 *dst, dstsock;
	int error = 0;
	u_long mtu;
	int dontfrag;
	u_int16_t src_scope, dst_scope;
	u_int32_t optlen = 0, plen = 0, unfragpartlen = 0;
	struct ip6_exthdrs exthdrs;
	struct in6_addr finaldst;
	struct route_in6 *ro_pmtu = NULL;
	int hdrsplit = 0;
	u_int8_t sproto = 0;
#ifdef IPSEC
	struct tdb *tdb = NULL;
#endif /* IPSEC */

#ifdef IPSEC
	if (inp && (inp->inp_flags & INP_IPV6) == 0)
		panic("ip6_output: IPv4 pcb is passed");
#endif /* IPSEC */

	ip6 = mtod(m, struct ip6_hdr *);
	finaldst = ip6->ip6_dst;

#define MAKE_EXTHDR(hp, mp)						\
    do {								\
	if (hp) {							\
		struct ip6_ext *eh = (struct ip6_ext *)(hp);		\
		error = ip6_copyexthdr((mp), (caddr_t)(hp),		\
		    ((eh)->ip6e_len + 1) << 3);				\
		if (error)						\
			goto freehdrs;					\
	}								\
    } while (0)

	bzero(&exthdrs, sizeof(exthdrs));

	if (opt) {
		/* Hop-by-Hop options header */
		MAKE_EXTHDR(opt->ip6po_hbh, &exthdrs.ip6e_hbh);
		/* Destination options header(1st part) */
		MAKE_EXTHDR(opt->ip6po_dest1, &exthdrs.ip6e_dest1);
		/* Routing header */
		MAKE_EXTHDR(opt->ip6po_rthdr, &exthdrs.ip6e_rthdr);
		/* Destination options header(2nd part) */
		MAKE_EXTHDR(opt->ip6po_dest2, &exthdrs.ip6e_dest2);
	}

#ifdef IPSEC
	if (ipsec_in_use || inp) {
		tdb = ip6_output_ipsec_lookup(m, &error, inp);
		if (error != 0) {
		        /*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
		        if (error == -EINVAL) /* Should silently drop packet */
				error = 0;

			goto freehdrs;
		}
	}
#endif /* IPSEC */

	/*
	 * Calculate the total length of the extension header chain.
	 * Keep the length of the unfragmentable part for fragmentation.
	 */
	optlen = 0;
	if (exthdrs.ip6e_hbh) optlen += exthdrs.ip6e_hbh->m_len;
	if (exthdrs.ip6e_dest1) optlen += exthdrs.ip6e_dest1->m_len;
	if (exthdrs.ip6e_rthdr) optlen += exthdrs.ip6e_rthdr->m_len;
	unfragpartlen = optlen + sizeof(struct ip6_hdr);
	/* NOTE: we don't add AH/ESP length here. do that later. */
	if (exthdrs.ip6e_dest2) optlen += exthdrs.ip6e_dest2->m_len;

	/*
	 * If we need IPsec, or there is at least one extension header,
	 * separate IP6 header from the payload.
	 */
	if ((sproto || optlen) && !hdrsplit) {
		if ((error = ip6_splithdr(m, &exthdrs)) != 0) {
			m = NULL;
			goto freehdrs;
		}
		m = exthdrs.ip6e_ip6;
		hdrsplit++;
	}

	/* adjust pointer */
	ip6 = mtod(m, struct ip6_hdr *);

	/* adjust mbuf packet header length */
	m->m_pkthdr.len += optlen;
	plen = m->m_pkthdr.len - sizeof(*ip6);

	/* If this is a jumbo payload, insert a jumbo payload option. */
	if (plen > IPV6_MAXPACKET) {
		if (!hdrsplit) {
			if ((error = ip6_splithdr(m, &exthdrs)) != 0) {
				m = NULL;
				goto freehdrs;
			}
			m = exthdrs.ip6e_ip6;
			hdrsplit++;
		}
		/* adjust pointer */
		ip6 = mtod(m, struct ip6_hdr *);
		if ((error = ip6_insert_jumboopt(&exthdrs, plen)) != 0)
			goto freehdrs;
		ip6->ip6_plen = 0;
	} else
		ip6->ip6_plen = htons(plen);

	/*
	 * Concatenate headers and fill in next header fields.
	 * Here we have, on "m"
	 *	IPv6 payload
	 * and we insert headers accordingly.  Finally, we should be getting:
	 *	IPv6 hbh dest1 rthdr ah* [esp* dest2 payload]
	 *
	 * during the header composing process, "m" points to IPv6 header.
	 * "mprev" points to an extension header prior to esp.
	 */
	{
		u_char *nexthdrp = &ip6->ip6_nxt;
		struct mbuf *mprev = m;

		/*
		 * we treat dest2 specially.  this makes IPsec processing
		 * much easier.  the goal here is to make mprev point the
		 * mbuf prior to dest2.
		 *
		 * result: IPv6 dest2 payload
		 * m and mprev will point to IPv6 header.
		 */
		if (exthdrs.ip6e_dest2) {
			if (!hdrsplit)
				panic("assumption failed: hdr not split");
			exthdrs.ip6e_dest2->m_next = m->m_next;
			m->m_next = exthdrs.ip6e_dest2;
			*mtod(exthdrs.ip6e_dest2, u_char *) = ip6->ip6_nxt;
			ip6->ip6_nxt = IPPROTO_DSTOPTS;
		}

#define MAKE_CHAIN(m, mp, p, i)\
    do {\
	if (m) {\
		if (!hdrsplit) \
			panic("assumption failed: hdr not split"); \
		*mtod((m), u_char *) = *(p);\
		*(p) = (i);\
		p = mtod((m), u_char *);\
		(m)->m_next = (mp)->m_next;\
		(mp)->m_next = (m);\
		(mp) = (m);\
	}\
    } while (0)
		/*
		 * result: IPv6 hbh dest1 rthdr dest2 payload
		 * m will point to IPv6 header.  mprev will point to the
		 * extension header prior to dest2 (rthdr in the above case).
		 */
		MAKE_CHAIN(exthdrs.ip6e_hbh, mprev, nexthdrp, IPPROTO_HOPOPTS);
		MAKE_CHAIN(exthdrs.ip6e_dest1, mprev, nexthdrp,
		    IPPROTO_DSTOPTS);
		MAKE_CHAIN(exthdrs.ip6e_rthdr, mprev, nexthdrp,
		    IPPROTO_ROUTING);
	}

	/*
	 * If there is a routing header, replace the destination address field
	 * with the first hop of the routing header.
	 */
	if (exthdrs.ip6e_rthdr) {
		struct ip6_rthdr *rh;
		struct ip6_rthdr0 *rh0;
		struct in6_addr *addr;

		rh = (struct ip6_rthdr *)(mtod(exthdrs.ip6e_rthdr,
		    struct ip6_rthdr *));
		switch (rh->ip6r_type) {
		case IPV6_RTHDR_TYPE_0:
			 rh0 = (struct ip6_rthdr0 *)rh;
			 addr = (struct in6_addr *)(rh0 + 1);
			 ip6->ip6_dst = addr[0];
			 bcopy(&addr[1], &addr[0],
			     sizeof(struct in6_addr) * (rh0->ip6r0_segleft - 1));
			 addr[rh0->ip6r0_segleft - 1] = finaldst;
			 break;
		default:	/* is it possible? */
			 error = EINVAL;
			 goto bad;
		}
	}

	/* Source address validation */
	if (!(flags & IPV6_UNSPECSRC) &&
	    IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src)) {
		/*
		 * XXX: we can probably assume validation in the caller, but
		 * we explicitly check the address here for safety.
		 */
		error = EOPNOTSUPP;
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}
	if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_src)) {
		error = EOPNOTSUPP;
		ip6stat_inc(ip6s_badscope);
		goto bad;
	}

	ip6stat_inc(ip6s_localout);

	/*
	 * Route packet.
	 */
#if NPF > 0
reroute:
#endif

	/* initialize cached route */
	if (ro == NULL) {
		ro = &ip6route;
		bzero((caddr_t)ro, sizeof(*ro));
	}
	ro_pmtu = ro;
	if (opt && opt->ip6po_rthdr)
		ro = &opt->ip6po_route;
	dst = &ro->ro_dst;

	/*
	 * if specified, try to fill in the traffic class field.
	 * do not override if a non-zero value is already set.
	 * we check the diffserv field and the ecn field separately.
	 */
	if (opt && opt->ip6po_tclass >= 0) {
		int mask = 0;

		if ((ip6->ip6_flow & htonl(0xfc << 20)) == 0)
			mask |= 0xfc;
		if ((ip6->ip6_flow & htonl(0x03 << 20)) == 0)
			mask |= 0x03;
		if (mask != 0)
			ip6->ip6_flow |= htonl((opt->ip6po_tclass & mask) << 20);
	}

	/* fill in or override the hop limit field, if necessary. */
	if (opt && opt->ip6po_hlim != -1)
		ip6->ip6_hlim = opt->ip6po_hlim & 0xff;
	else if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		if (im6o != NULL)
			ip6->ip6_hlim = im6o->im6o_hlim;
		else
			ip6->ip6_hlim = ip6_defmcasthlim;
	}

#ifdef IPSEC
	if (tdb) {
		/*
		 * XXX what should we do if ip6_hlim == 0 and the
		 * packet gets tunneled?
		 */
		/*
		 * if we are source-routing, do not attempt to tunnel the
		 * packet just because ip6_dst is different from what tdb has.
		 * XXX
		 */
		error = ip6_output_ipsec_send(tdb, m,
		    exthdrs.ip6e_rthdr ? 1 : 0, 0);
		goto done;
	}
#endif /* IPSEC */

	bzero(&dstsock, sizeof(dstsock));
	dstsock.sin6_family = AF_INET6;
	dstsock.sin6_addr = ip6->ip6_dst;
	dstsock.sin6_len = sizeof(dstsock);
	ro->ro_tableid = m->m_pkthdr.ph_rtableid;

	if (IN6_IS_ADDR_MULTICAST(&dstsock.sin6_addr)) {
		struct in6_pktinfo *pi = NULL;

		/*
		 * If the caller specify the outgoing interface
		 * explicitly, use it.
		 */
		if (opt != NULL && (pi = opt->ip6po_pktinfo) != NULL)
			ifp = if_get(pi->ipi6_ifindex);

		if (ifp == NULL && im6o != NULL)
			ifp = if_get(im6o->im6o_ifidx);
	}

	if (ifp == NULL) {
		rt = in6_selectroute(&dstsock, opt, ro, ro->ro_tableid);
		if (rt == NULL) {
			ip6stat_inc(ip6s_noroute);
			error = EHOSTUNREACH;
			goto bad;
		}
		if (ISSET(rt->rt_flags, RTF_LOCAL))
			ifp = if_get(rtable_loindex(m->m_pkthdr.ph_rtableid));
		else
			ifp = if_get(rt->rt_ifidx);
	} else {
		*dst = dstsock;
	}

	if (rt && (rt->rt_flags & RTF_GATEWAY) &&
	    !IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst))
		dst = satosin6(rt->rt_gateway);

	if (!IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		/* Unicast */

		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */
	} else {
		/* Multicast */

		m->m_flags = (m->m_flags & ~M_BCAST) | M_MCAST;

		/*
		 * Confirm that the outgoing interface supports multicast.
		 */
		if ((ifp->if_flags & IFF_MULTICAST) == 0) {
			ip6stat_inc(ip6s_noroute);
			error = ENETUNREACH;
			goto bad;
		}

		if ((im6o == NULL || im6o->im6o_loop) &&
		    in6_hasmulti(&ip6->ip6_dst, ifp)) {
			/*
			 * If we belong to the destination multicast group
			 * on the outgoing interface, and the caller did not
			 * forbid loopback, loop back a copy.
			 * Can't defer TCP/UDP checksumming, do the
			 * computation now.
			 */
			in6_proto_cksum_out(m, NULL);
			ip6_mloopback(ifp, m, dst);
		}
#ifdef MROUTING
		else {
			/*
			 * If we are acting as a multicast router, perform
			 * multicast forwarding as if the packet had just
			 * arrived on the interface to which we are about
			 * to send.  The multicast forwarding function
			 * recursively calls this function, using the
			 * IPV6_FORWARDING flag to prevent infinite recursion.
			 *
			 * Multicasts that are looped back by ip6_mloopback(),
			 * above, will be forwarded by the ip6_input() routine,
			 * if necessary.
			 */
			if (ip6_mforwarding && ip6_mrouter &&
			    (flags & IPV6_FORWARDING) == 0) {
				if (ip6_mforward(ip6, ifp, m) != 0) {
					m_freem(m);
					goto done;
				}
			}
		}
#endif
		/*
		 * Multicasts with a hoplimit of zero may be looped back,
		 * above, but must not be transmitted on a network.
		 * Also, multicasts addressed to the loopback interface
		 * are not sent -- the above call to ip6_mloopback() will
		 * loop back a copy if this host actually belongs to the
		 * destination group on the loopback interface.
		 */
		if (ip6->ip6_hlim == 0 || (ifp->if_flags & IFF_LOOPBACK) ||
		    IN6_IS_ADDR_MC_INTFACELOCAL(&ip6->ip6_dst)) {
			m_freem(m);
			goto done;
		}
	}

	/*
	 * If this packet is going trough a loopback interface we wont
	 * be able to restore its scope ID using the interface index.
	 */
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src)) {
		if (ifp->if_flags & IFF_LOOPBACK)
			src_scope = ip6->ip6_src.s6_addr16[1];
		ip6->ip6_src.s6_addr16[1] = 0;
	}
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst)) {
		if (ifp->if_flags & IFF_LOOPBACK)
			dst_scope = ip6->ip6_dst.s6_addr16[1];
		ip6->ip6_dst.s6_addr16[1] = 0;
	}

	/* Determine path MTU. */
	if ((error = ip6_getpmtu(ro_pmtu->ro_rt, ifp, &mtu)) != 0)
		goto bad;

	/*
	 * The caller of this function may specify to use the minimum MTU
	 * in some cases.
	 * An advanced API option (IPV6_USE_MIN_MTU) can also override MTU
	 * setting.  The logic is a bit complicated; by default, unicast
	 * packets will follow path MTU while multicast packets will be sent at
	 * the minimum MTU.  If IP6PO_MINMTU_ALL is specified, all packets
	 * including unicast ones will be sent at the minimum MTU.  Multicast
	 * packets will always be sent at the minimum MTU unless
	 * IP6PO_MINMTU_DISABLE is explicitly specified.
	 * See RFC 3542 for more details.
	 */
	if (mtu > IPV6_MMTU) {
		if ((flags & IPV6_MINMTU))
			mtu = IPV6_MMTU;
		else if (opt && opt->ip6po_minmtu == IP6PO_MINMTU_ALL)
			mtu = IPV6_MMTU;
		else if (IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst) &&
			 (opt == NULL ||
			  opt->ip6po_minmtu != IP6PO_MINMTU_DISABLE)) {
			mtu = IPV6_MMTU;
		}
	}

	/*
	 * If the outgoing packet contains a hop-by-hop options header,
	 * it must be examined and processed even by the source node.
	 * (RFC 2460, section 4.)
	 */
	if (exthdrs.ip6e_hbh) {
		struct ip6_hbh *hbh = mtod(exthdrs.ip6e_hbh, struct ip6_hbh *);
		u_int32_t dummy1; /* XXX unused */
		u_int32_t dummy2; /* XXX unused */

		/*
		 *  XXX: if we have to send an ICMPv6 error to the sender,
		 *       we need the M_LOOP flag since icmp6_error() expects
		 *       the IPv6 and the hop-by-hop options header are
		 *       continuous unless the flag is set.
		 */
		m->m_flags |= M_LOOP;
		m->m_pkthdr.ph_ifidx = ifp->if_index;
		if (ip6_process_hopopts(m, (u_int8_t *)(hbh + 1),
		    ((hbh->ip6h_len + 1) << 3) - sizeof(struct ip6_hbh),
		    &dummy1, &dummy2) < 0) {
			/* m was already freed at this point */
			error = EINVAL;/* better error? */
			goto done;
		}
		m->m_flags &= ~M_LOOP; /* XXX */
		m->m_pkthdr.ph_ifidx = 0;
	}

#if NPF > 0
	if (pf_test(AF_INET6, PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
		m_freem(m);
		goto done;
	}
	if (m == NULL)
		goto done;
	ip6 = mtod(m, struct ip6_hdr *);
	if ((m->m_pkthdr.pf.flags & (PF_TAG_REROUTE | PF_TAG_GENERATED)) ==
	    (PF_TAG_REROUTE | PF_TAG_GENERATED)) {
		/* already rerun the route lookup, go on */
		m->m_pkthdr.pf.flags &= ~(PF_TAG_GENERATED | PF_TAG_REROUTE);
	} else if (m->m_pkthdr.pf.flags & PF_TAG_REROUTE) {
		/* tag as generated to skip over pf_test on rerun */
		m->m_pkthdr.pf.flags |= PF_TAG_GENERATED;
		finaldst = ip6->ip6_dst;
		ro = NULL;
		if_put(ifp); /* drop reference since destination changed */
		ifp = NULL;
		goto reroute;
	}
#endif

	/*
	 * If the packet is not going on the wire it can be destinated
	 * to any local address.  In this case do not clear its scopes
	 * to let ip6_input() find a matching local route.
	 */
	if (ifp->if_flags & IFF_LOOPBACK) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = src_scope;
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = dst_scope;
	}

	in6_proto_cksum_out(m, ifp);

	/*
	 * Send the packet to the outgoing interface.
	 * If necessary, do IPv6 fragmentation before sending.
	 *
	 * the logic here is rather complex:
	 * 1: normal case (dontfrag == 0)
	 * 1-a: send as is if tlen <= path mtu
	 * 1-b: fragment if tlen > path mtu
	 *
	 * 2: if user asks us not to fragment (dontfrag == 1)
	 * 2-a: send as is if tlen <= interface mtu
	 * 2-b: error if tlen > interface mtu
	 */
	tlen = m->m_pkthdr.len;

	if (opt && (opt->ip6po_flags & IP6PO_DONTFRAG))
		dontfrag = 1;
	else
		dontfrag = 0;
	if (dontfrag && tlen > ifp->if_mtu) {	/* case 2-b */
		error = EMSGSIZE;
		goto bad;
	}

	/*
	 * transmit packet without fragmentation
	 */
	if (dontfrag || (tlen <= mtu)) {	/* case 1-a and 2-a */
		error = ifp->if_output(ifp, m, sin6tosa(dst), ro->ro_rt);
		goto done;
	}

	/*
	 * try to fragment the packet.  case 1-b
	 */
	if (mtu < IPV6_MMTU) {
		/* path MTU cannot be less than IPV6_MMTU */
		error = EMSGSIZE;
		goto bad;
	} else if (ip6->ip6_plen == 0) {
		/* jumbo payload cannot be fragmented */
		error = EMSGSIZE;
		goto bad;
	} else {
		u_char nextproto;
#if 0
		struct ip6ctlparam ip6cp;
		u_int32_t mtu32;
#endif

		/*
		 * Too large for the destination or interface;
		 * fragment if possible.
		 * Must be able to put at least 8 bytes per fragment.
		 */
		hlen = unfragpartlen;
		if (mtu > IPV6_MAXPACKET)
			mtu = IPV6_MAXPACKET;

#if 0
		/* Notify a proper path MTU to applications. */
		mtu32 = (u_int32_t)mtu;
		bzero(&ip6cp, sizeof(ip6cp));
		ip6cp.ip6c_cmdarg = (void *)&mtu32;
		pfctlinput2(PRC_MSGSIZE, sin6tosa(&ro_pmtu->ro_dst),
		    (void *)&ip6cp);
#endif

		/*
		 * Change the next header field of the last header in the
		 * unfragmentable part.
		 */
		if (exthdrs.ip6e_rthdr) {
			nextproto = *mtod(exthdrs.ip6e_rthdr, u_char *);
			*mtod(exthdrs.ip6e_rthdr, u_char *) = IPPROTO_FRAGMENT;
		} else if (exthdrs.ip6e_dest1) {
			nextproto = *mtod(exthdrs.ip6e_dest1, u_char *);
			*mtod(exthdrs.ip6e_dest1, u_char *) = IPPROTO_FRAGMENT;
		} else if (exthdrs.ip6e_hbh) {
			nextproto = *mtod(exthdrs.ip6e_hbh, u_char *);
			*mtod(exthdrs.ip6e_hbh, u_char *) = IPPROTO_FRAGMENT;
		} else {
			nextproto = ip6->ip6_nxt;
			ip6->ip6_nxt = IPPROTO_FRAGMENT;
		}

		m0 = m;
		error = ip6_fragment(m0, hlen, nextproto, mtu);
		if (error)
			ip6stat_inc(ip6s_odropped);
	}

	/*
	 * Remove leading garbages.
	 */
	m = m0->m_nextpkt;
	m0->m_nextpkt = 0;
	m_freem(m0);
	for (m0 = m; m; m = m0) {
		m0 = m->m_nextpkt;
		m->m_nextpkt = 0;
		if (error == 0) {
			ip6stat_inc(ip6s_ofragments);
			error = ifp->if_output(ifp, m, sin6tosa(dst),
			    ro->ro_rt);
		} else
			m_freem(m);
	}

	if (error == 0)
		ip6stat_inc(ip6s_fragmented);

done:
	if_put(ifp);
	if (ro == &ip6route && ro->ro_rt) {
		rtfree(ro->ro_rt);
	} else if (ro_pmtu == &ip6route && ro_pmtu->ro_rt) {
		rtfree(ro_pmtu->ro_rt);
	}

	return (error);

freehdrs:
	m_freem(exthdrs.ip6e_hbh);	/* m_freem will check if mbuf is 0 */
	m_freem(exthdrs.ip6e_dest1);
	m_freem(exthdrs.ip6e_rthdr);
	m_freem(exthdrs.ip6e_dest2);
	/* FALLTHROUGH */
bad:
	m_freem(m);
	goto done;
}

int
ip6_fragment(struct mbuf *m0, int hlen, u_char nextproto, u_long mtu)
{
	struct mbuf	*m, **mnext, *m_frgpart;
	struct ip6_hdr	*mhip6;
	struct ip6_frag	*ip6f;
	u_int32_t	 id;
	int		 tlen, len, off;
	int		 error;

	id = htonl(ip6_randomid());

	mnext = &m0->m_nextpkt;
	*mnext = NULL;

	tlen = m0->m_pkthdr.len;
	len = (mtu - hlen - sizeof(struct ip6_frag)) & ~7;
	if (len < 8)
		return (EMSGSIZE);

	/*
	 * Loop through length of segment after first fragment,
	 * make new header and copy data of each part and link onto
	 * chain.
	 */
	for (off = hlen; off < tlen; off += len) {
		struct mbuf *mlast;

		if ((m = m_gethdr(M_DONTWAIT, MT_HEADER)) == NULL)
			return (ENOBUFS);
		*mnext = m;
		mnext = &m->m_nextpkt;
		if ((error = m_dup_pkthdr(m, m0, M_DONTWAIT)) != 0)
			return (error);
		m->m_data += max_linkhdr;
		mhip6 = mtod(m, struct ip6_hdr *);
		*mhip6 = *mtod(m0, struct ip6_hdr *);
		m->m_len = sizeof(*mhip6);
		if ((error = ip6_insertfraghdr(m0, m, hlen, &ip6f)) != 0)
			return (error);
		ip6f->ip6f_offlg = htons((u_int16_t)((off - hlen) & ~7));
		if (off + len >= tlen)
			len = tlen - off;
		else
			ip6f->ip6f_offlg |= IP6F_MORE_FRAG;
		mhip6->ip6_plen = htons((u_int16_t)(len + hlen +
		    sizeof(*ip6f) - sizeof(struct ip6_hdr)));
		if ((m_frgpart = m_copym(m0, off, len, M_DONTWAIT)) == NULL)
			return (ENOBUFS);
		for (mlast = m; mlast->m_next; mlast = mlast->m_next)
			;
		mlast->m_next = m_frgpart;
		m->m_pkthdr.len = len + hlen + sizeof(*ip6f);
		ip6f->ip6f_reserved = 0;
		ip6f->ip6f_ident = id;
		ip6f->ip6f_nxt = nextproto;
	}

	return (0);
}

int
ip6_copyexthdr(struct mbuf **mp, caddr_t hdr, int hlen)
{
	struct mbuf *m;

	if (hlen > MCLBYTES)
		return (ENOBUFS); /* XXX */

	MGET(m, M_DONTWAIT, MT_DATA);
	if (!m)
		return (ENOBUFS);

	if (hlen > MLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			return (ENOBUFS);
		}
	}
	m->m_len = hlen;
	if (hdr)
		bcopy(hdr, mtod(m, caddr_t), hlen);

	*mp = m;
	return (0);
}

/*
 * Insert jumbo payload option.
 */
int
ip6_insert_jumboopt(struct ip6_exthdrs *exthdrs, u_int32_t plen)
{
	struct mbuf *mopt;
	u_int8_t *optbuf;
	u_int32_t v;

#define JUMBOOPTLEN	8	/* length of jumbo payload option and padding */

	/*
	 * If there is no hop-by-hop options header, allocate new one.
	 * If there is one but it doesn't have enough space to store the
	 * jumbo payload option, allocate a cluster to store the whole options.
	 * Otherwise, use it to store the options.
	 */
	if (exthdrs->ip6e_hbh == 0) {
		MGET(mopt, M_DONTWAIT, MT_DATA);
		if (mopt == NULL)
			return (ENOBUFS);
		mopt->m_len = JUMBOOPTLEN;
		optbuf = mtod(mopt, u_int8_t *);
		optbuf[1] = 0;	/* = ((JUMBOOPTLEN) >> 3) - 1 */
		exthdrs->ip6e_hbh = mopt;
	} else {
		struct ip6_hbh *hbh;

		mopt = exthdrs->ip6e_hbh;
		if (M_TRAILINGSPACE(mopt) < JUMBOOPTLEN) {
			/*
			 * XXX assumption:
			 * - exthdrs->ip6e_hbh is not referenced from places
			 *   other than exthdrs.
			 * - exthdrs->ip6e_hbh is not an mbuf chain.
			 */
			int oldoptlen = mopt->m_len;
			struct mbuf *n;

			/*
			 * XXX: give up if the whole (new) hbh header does
			 * not fit even in an mbuf cluster.
			 */
			if (oldoptlen + JUMBOOPTLEN > MCLBYTES)
				return (ENOBUFS);

			/*
			 * As a consequence, we must always prepare a cluster
			 * at this point.
			 */
			MGET(n, M_DONTWAIT, MT_DATA);
			if (n) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_freem(n);
					n = NULL;
				}
			}
			if (!n)
				return (ENOBUFS);
			n->m_len = oldoptlen + JUMBOOPTLEN;
			bcopy(mtod(mopt, caddr_t), mtod(n, caddr_t),
			      oldoptlen);
			optbuf = mtod(n, u_int8_t *) + oldoptlen;
			m_freem(mopt);
			mopt = exthdrs->ip6e_hbh = n;
		} else {
			optbuf = mtod(mopt, u_int8_t *) + mopt->m_len;
			mopt->m_len += JUMBOOPTLEN;
		}
		optbuf[0] = IP6OPT_PADN;
		optbuf[1] = 0;

		/*
		 * Adjust the header length according to the pad and
		 * the jumbo payload option.
		 */
		hbh = mtod(mopt, struct ip6_hbh *);
		hbh->ip6h_len += (JUMBOOPTLEN >> 3);
	}

	/* fill in the option. */
	optbuf[2] = IP6OPT_JUMBO;
	optbuf[3] = 4;
	v = (u_int32_t)htonl(plen + JUMBOOPTLEN);
	memcpy(&optbuf[4], &v, sizeof(u_int32_t));

	/* finally, adjust the packet header length */
	exthdrs->ip6e_ip6->m_pkthdr.len += JUMBOOPTLEN;

	return (0);
#undef JUMBOOPTLEN
}

/*
 * Insert fragment header and copy unfragmentable header portions.
 */
int
ip6_insertfraghdr(struct mbuf *m0, struct mbuf *m, int hlen,
    struct ip6_frag **frghdrp)
{
	struct mbuf *n, *mlast;

	if (hlen > sizeof(struct ip6_hdr)) {
		n = m_copym(m0, sizeof(struct ip6_hdr),
		    hlen - sizeof(struct ip6_hdr), M_DONTWAIT);
		if (n == NULL)
			return (ENOBUFS);
		m->m_next = n;
	} else
		n = m;

	/* Search for the last mbuf of unfragmentable part. */
	for (mlast = n; mlast->m_next; mlast = mlast->m_next)
		;

	if ((mlast->m_flags & M_EXT) == 0 &&
	    M_TRAILINGSPACE(mlast) >= sizeof(struct ip6_frag)) {
		/* use the trailing space of the last mbuf for the fragment hdr */
		*frghdrp = (struct ip6_frag *)(mtod(mlast, caddr_t) +
		    mlast->m_len);
		mlast->m_len += sizeof(struct ip6_frag);
		m->m_pkthdr.len += sizeof(struct ip6_frag);
	} else {
		/* allocate a new mbuf for the fragment header */
		struct mbuf *mfrg;

		MGET(mfrg, M_DONTWAIT, MT_DATA);
		if (mfrg == NULL)
			return (ENOBUFS);
		mfrg->m_len = sizeof(struct ip6_frag);
		*frghdrp = mtod(mfrg, struct ip6_frag *);
		mlast->m_next = mfrg;
	}

	return (0);
}

int
ip6_getpmtu(struct rtentry *rt, struct ifnet *ifp, u_long *mtup)
{
	u_int32_t mtu = 0;
	int error = 0;

	if (rt != NULL) {
		mtu = rt->rt_rmx.rmx_mtu;
		if (mtu == 0)
			mtu = ifp->if_mtu;
		else if (mtu < IPV6_MMTU) {
			/* RFC8021 IPv6 Atomic Fragments Considered Harmful */
			mtu = IPV6_MMTU;
		} else if (mtu > ifp->if_mtu) {
			/*
			 * The MTU on the route is larger than the MTU on
			 * the interface!  This shouldn't happen, unless the
			 * MTU of the interface has been changed after the
			 * interface was brought up.  Change the MTU in the
			 * route to match the interface MTU (as long as the
			 * field isn't locked).
			 */
			mtu = ifp->if_mtu;
			if (!(rt->rt_rmx.rmx_locks & RTV_MTU))
				rt->rt_rmx.rmx_mtu = mtu;
		}
	} else {
		mtu = ifp->if_mtu;
	}

	*mtup = mtu;
	return (error);
}

/*
 * IP6 socket option processing.
 */
int
ip6_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	int privileged, optdatalen, uproto;
	void *optdata;
	struct inpcb *inp = sotoinpcb(so);
	int error, optval;
	struct proc *p = curproc; /* For IPSec and rdomain */
	u_int rtid = 0;

	error = optval = 0;

	privileged = (inp->inp_socket->so_state & SS_PRIV);
	uproto = (int)so->so_proto->pr_protocol;

	if (level != IPPROTO_IPV6) {
		if (op == PRCO_SETOPT)
			m_free(m);
		return (EINVAL);
	}

	switch (op) {
	case PRCO_SETOPT:
		switch (optname) {
		/*
		 * Use of some Hop-by-Hop options or some
		 * Destination options, might require special
		 * privilege.  That is, normal applications
		 * (without special privilege) might be forbidden
		 * from setting certain options in outgoing packets,
		 * and might never see certain options in received
		 * packets. [RFC 2292 Section 6]
		 * KAME specific note:
		 *  KAME prevents non-privileged users from sending or
		 *  receiving ANY hbh/dst options in order to avoid
		 *  overhead of parsing options in the kernel.
		 */
		case IPV6_RECVHOPOPTS:
		case IPV6_RECVDSTOPTS:
			if (!privileged) {
				error = EPERM;
				break;
			}
			/* FALLTHROUGH */
		case IPV6_UNICAST_HOPS:
		case IPV6_MINHOPCOUNT:
		case IPV6_HOPLIMIT:

		case IPV6_RECVPKTINFO:
		case IPV6_RECVHOPLIMIT:
		case IPV6_RECVRTHDR:
		case IPV6_RECVPATHMTU:
		case IPV6_RECVTCLASS:
		case IPV6_V6ONLY:
		case IPV6_AUTOFLOWLABEL:
		case IPV6_RECVDSTPORT:
			if (m == NULL || m->m_len != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);
			switch (optname) {

			case IPV6_UNICAST_HOPS:
				if (optval < -1 || optval >= 256)
					error = EINVAL;
				else {
					/* -1 = kernel default */
					inp->inp_hops = optval;
				}
				break;

			case IPV6_MINHOPCOUNT:
				if (optval < 0 || optval > 255)
					error = EINVAL;
				else
					inp->inp_ip6_minhlim = optval;
				break;

#define OPTSET(bit) \
do { \
	if (optval) \
		inp->inp_flags |= (bit); \
	else \
		inp->inp_flags &= ~(bit); \
} while (/*CONSTCOND*/ 0)
#define OPTBIT(bit) (inp->inp_flags & (bit) ? 1 : 0)

			case IPV6_RECVPKTINFO:
				OPTSET(IN6P_PKTINFO);
				break;

			case IPV6_HOPLIMIT:
			{
				struct ip6_pktopts **optp;

				optp = &inp->inp_outputopts6;
				error = ip6_pcbopt(IPV6_HOPLIMIT,
						   (u_char *)&optval,
						   sizeof(optval),
						   optp,
						   privileged, uproto);
				break;
			}

			case IPV6_RECVHOPLIMIT:
				OPTSET(IN6P_HOPLIMIT);
				break;

			case IPV6_RECVHOPOPTS:
				OPTSET(IN6P_HOPOPTS);
				break;

			case IPV6_RECVDSTOPTS:
				OPTSET(IN6P_DSTOPTS);
				break;

			case IPV6_RECVRTHDR:
				OPTSET(IN6P_RTHDR);
				break;

			case IPV6_RECVPATHMTU:
				/*
				 * We ignore this option for TCP
				 * sockets.
				 * (RFC3542 leaves this case
				 * unspecified.)
				 */
				if (uproto != IPPROTO_TCP)
					OPTSET(IN6P_MTU);
				break;

			case IPV6_V6ONLY:
				/*
				 * make setsockopt(IPV6_V6ONLY)
				 * available only prior to bind(2).
				 * see ipng mailing list, Jun 22 2001.
				 */
				if (inp->inp_lport ||
				    !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) {
					error = EINVAL;
					break;
				}
				/* No support for IPv4-mapped addresses. */
				if (!optval)
					error = EINVAL;
				else
					error = 0;
				break;
			case IPV6_RECVTCLASS:
				OPTSET(IN6P_TCLASS);
				break;
			case IPV6_AUTOFLOWLABEL:
				OPTSET(IN6P_AUTOFLOWLABEL);
				break;

			case IPV6_RECVDSTPORT:
				OPTSET(IN6P_RECVDSTPORT);
				break;
			}
			break;

		case IPV6_TCLASS:
		case IPV6_DONTFRAG:
		case IPV6_USE_MIN_MTU:
			if (m == NULL || m->m_len != sizeof(optval)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);
			{
				struct ip6_pktopts **optp;
				optp = &inp->inp_outputopts6;
				error = ip6_pcbopt(optname,
						   (u_char *)&optval,
						   sizeof(optval),
						   optp,
						   privileged, uproto);
				break;
			}

		case IPV6_PKTINFO:
		case IPV6_HOPOPTS:
		case IPV6_RTHDR:
		case IPV6_DSTOPTS:
		case IPV6_RTHDRDSTOPTS:
		{
			/* new advanced API (RFC3542) */
			u_char *optbuf;
			int optbuflen;
			struct ip6_pktopts **optp;

			if (m && m->m_next) {
				error = EINVAL;	/* XXX */
				break;
			}
			if (m) {
				optbuf = mtod(m, u_char *);
				optbuflen = m->m_len;
			} else {
				optbuf = NULL;
				optbuflen = 0;
			}
			optp = &inp->inp_outputopts6;
			error = ip6_pcbopt(optname,
					   optbuf, optbuflen,
					   optp, privileged, uproto);
			break;
		}
#undef OPTSET

		case IPV6_MULTICAST_IF:
		case IPV6_MULTICAST_HOPS:
		case IPV6_MULTICAST_LOOP:
		case IPV6_JOIN_GROUP:
		case IPV6_LEAVE_GROUP:
			error =	ip6_setmoptions(optname,
						&inp->inp_moptions6,
						m);
			break;

		case IPV6_PORTRANGE:
			if (m == NULL || m->m_len != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);

			switch (optval) {
			case IPV6_PORTRANGE_DEFAULT:
				inp->inp_flags &= ~(IN6P_LOWPORT);
				inp->inp_flags &= ~(IN6P_HIGHPORT);
				break;

			case IPV6_PORTRANGE_HIGH:
				inp->inp_flags &= ~(IN6P_LOWPORT);
				inp->inp_flags |= IN6P_HIGHPORT;
				break;

			case IPV6_PORTRANGE_LOW:
				inp->inp_flags &= ~(IN6P_HIGHPORT);
				inp->inp_flags |= IN6P_LOWPORT;
				break;

			default:
				error = EINVAL;
				break;
			}
			break;

		case IPSEC6_OUTSA:
			error = EINVAL;
			break;

		case IPV6_AUTH_LEVEL:
		case IPV6_ESP_TRANS_LEVEL:
		case IPV6_ESP_NETWORK_LEVEL:
		case IPV6_IPCOMP_LEVEL:
#ifndef IPSEC
			error = EINVAL;
#else
			if (m == NULL || m->m_len != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);

			if (optval < IPSEC_LEVEL_BYPASS ||
			    optval > IPSEC_LEVEL_UNIQUE) {
				error = EINVAL;
				break;
			}

			switch (optname) {
			case IPV6_AUTH_LEVEL:
			        if (optval < IPSEC_AUTH_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_AUTH] = optval;
				break;

			case IPV6_ESP_TRANS_LEVEL:
			        if (optval < IPSEC_ESP_TRANS_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_ESP_TRANS] = optval;
				break;

			case IPV6_ESP_NETWORK_LEVEL:
			        if (optval < IPSEC_ESP_NETWORK_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_ESP_NETWORK] = optval;
				break;

			case IPV6_IPCOMP_LEVEL:
			        if (optval < IPSEC_IPCOMP_LEVEL_DEFAULT &&
				    suser(p, 0)) {
					error = EACCES;
					break;
				}
				inp->inp_seclevel[SL_IPCOMP] = optval;
				break;
			}
#endif
			break;
		case SO_RTABLE:
			if (m == NULL || m->m_len < sizeof(u_int)) {
				error = EINVAL;
				break;
			}
			rtid = *mtod(m, u_int *);
			if (inp->inp_rtableid == rtid)
				break;
			/* needs privileges to switch when already set */
			if (p->p_p->ps_rtableid != rtid &&
			    p->p_p->ps_rtableid != 0 &&
			    (error = suser(p, 0)) != 0)
				break;
			/* table must exist */
			if (!rtable_exists(rtid)) {
				error = EINVAL;
				break;
			}
			if (inp->inp_lport) {
				error = EBUSY;
				break;
			}
			inp->inp_rtableid = rtid;
			in_pcbrehash(inp);
			break;
		case IPV6_PIPEX:
			if (m != NULL && m->m_len == sizeof(int))
				inp->inp_pipex = *mtod(m, int *);
			else
				error = EINVAL;
			break;

		default:
			error = ENOPROTOOPT;
			break;
		}
		m_free(m);
		break;

	case PRCO_GETOPT:
		switch (optname) {

		case IPV6_RECVHOPOPTS:
		case IPV6_RECVDSTOPTS:
		case IPV6_UNICAST_HOPS:
		case IPV6_MINHOPCOUNT:
		case IPV6_RECVPKTINFO:
		case IPV6_RECVHOPLIMIT:
		case IPV6_RECVRTHDR:
		case IPV6_RECVPATHMTU:

		case IPV6_V6ONLY:
		case IPV6_PORTRANGE:
		case IPV6_RECVTCLASS:
		case IPV6_AUTOFLOWLABEL:
		case IPV6_RECVDSTPORT:
			switch (optname) {

			case IPV6_RECVHOPOPTS:
				optval = OPTBIT(IN6P_HOPOPTS);
				break;

			case IPV6_RECVDSTOPTS:
				optval = OPTBIT(IN6P_DSTOPTS);
				break;

			case IPV6_UNICAST_HOPS:
				optval = inp->inp_hops;
				break;

			case IPV6_MINHOPCOUNT:
				optval = inp->inp_ip6_minhlim;
				break;

			case IPV6_RECVPKTINFO:
				optval = OPTBIT(IN6P_PKTINFO);
				break;

			case IPV6_RECVHOPLIMIT:
				optval = OPTBIT(IN6P_HOPLIMIT);
				break;

			case IPV6_RECVRTHDR:
				optval = OPTBIT(IN6P_RTHDR);
				break;

			case IPV6_RECVPATHMTU:
				optval = OPTBIT(IN6P_MTU);
				break;

			case IPV6_V6ONLY:
				optval = 1;
				break;

			case IPV6_PORTRANGE:
			    {
				int flags;
				flags = inp->inp_flags;
				if (flags & IN6P_HIGHPORT)
					optval = IPV6_PORTRANGE_HIGH;
				else if (flags & IN6P_LOWPORT)
					optval = IPV6_PORTRANGE_LOW;
				else
					optval = 0;
				break;
			    }
			case IPV6_RECVTCLASS:
				optval = OPTBIT(IN6P_TCLASS);
				break;

			case IPV6_AUTOFLOWLABEL:
				optval = OPTBIT(IN6P_AUTOFLOWLABEL);
				break;

			case IPV6_RECVDSTPORT:
				optval = OPTBIT(IN6P_RECVDSTPORT);
				break;
			}
			if (error)
				break;
			m->m_len = sizeof(int);
			*mtod(m, int *) = optval;
			break;

		case IPV6_PATHMTU:
		{
			u_long pmtu = 0;
			struct ip6_mtuinfo mtuinfo;
			struct ifnet *ifp;
			struct rtentry *rt;

			if (!(so->so_state & SS_ISCONNECTED))
				return (ENOTCONN);

			rt = in_pcbrtentry(inp);
			if (!rtisvalid(rt))
				return (EHOSTUNREACH);

			ifp = if_get(rt->rt_ifidx);
			if (ifp == NULL)
				return (EHOSTUNREACH);
			/*
			 * XXX: we dot not consider the case of source
			 * routing, or optional information to specify
			 * the outgoing interface.
			 */
			error = ip6_getpmtu(rt, ifp, &pmtu);
			if_put(ifp);
			if (error)
				break;
			if (pmtu > IPV6_MAXPACKET)
				pmtu = IPV6_MAXPACKET;

			bzero(&mtuinfo, sizeof(mtuinfo));
			mtuinfo.ip6m_mtu = (u_int32_t)pmtu;
			optdata = (void *)&mtuinfo;
			optdatalen = sizeof(mtuinfo);
			if (optdatalen > MCLBYTES)
				return (EMSGSIZE); /* XXX */
			if (optdatalen > MLEN)
				MCLGET(m, M_WAIT);
			m->m_len = optdatalen;
			bcopy(optdata, mtod(m, void *), optdatalen);
			break;
		}

		case IPV6_PKTINFO:
		case IPV6_HOPOPTS:
		case IPV6_RTHDR:
		case IPV6_DSTOPTS:
		case IPV6_RTHDRDSTOPTS:
		case IPV6_TCLASS:
		case IPV6_DONTFRAG:
		case IPV6_USE_MIN_MTU:
			error = ip6_getpcbopt(inp->inp_outputopts6,
			    optname, m);
			break;

		case IPV6_MULTICAST_IF:
		case IPV6_MULTICAST_HOPS:
		case IPV6_MULTICAST_LOOP:
		case IPV6_JOIN_GROUP:
		case IPV6_LEAVE_GROUP:
			error = ip6_getmoptions(optname,
			    inp->inp_moptions6, m);
			break;

		case IPSEC6_OUTSA:
			error = EINVAL;
			break;

		case IPV6_AUTH_LEVEL:
		case IPV6_ESP_TRANS_LEVEL:
		case IPV6_ESP_NETWORK_LEVEL:
		case IPV6_IPCOMP_LEVEL:
#ifndef IPSEC
			m->m_len = sizeof(int);
			*mtod(m, int *) = IPSEC_LEVEL_NONE;
#else
			m->m_len = sizeof(int);
			switch (optname) {
			case IPV6_AUTH_LEVEL:
				optval = inp->inp_seclevel[SL_AUTH];
				break;

			case IPV6_ESP_TRANS_LEVEL:
				optval =
				    inp->inp_seclevel[SL_ESP_TRANS];
				break;

			case IPV6_ESP_NETWORK_LEVEL:
				optval =
				    inp->inp_seclevel[SL_ESP_NETWORK];
				break;

			case IPV6_IPCOMP_LEVEL:
				optval = inp->inp_seclevel[SL_IPCOMP];
				break;
			}
			*mtod(m, int *) = optval;
#endif
			break;
		case SO_RTABLE:
			m->m_len = sizeof(u_int);
			*mtod(m, u_int *) = optval;
			break;
		case IPV6_PIPEX:
			m->m_len = sizeof(int);
			*mtod(m, int *) = optval;
			break;

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}
	return (error);
}

int
ip6_raw_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	int error = 0, optval;
	const int icmp6off = offsetof(struct icmp6_hdr, icmp6_cksum);
	struct inpcb *inp = sotoinpcb(so);

	if (level != IPPROTO_IPV6) {
		if (op == PRCO_SETOPT)
			(void)m_free(m);
		return (EINVAL);
	}

	switch (optname) {
	case IPV6_CHECKSUM:
		/*
		 * For ICMPv6 sockets, no modification allowed for checksum
		 * offset, permit "no change" values to help existing apps.
		 *
		 * RFC3542 says: "An attempt to set IPV6_CHECKSUM
		 * for an ICMPv6 socket will fail."
		 * The current behavior does not meet RFC3542.
		 */
		switch (op) {
		case PRCO_SETOPT:
			if (m == NULL || m->m_len != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);
			if ((optval % 2) != 0) {
				/* the API assumes even offset values */
				error = EINVAL;
			} else if (so->so_proto->pr_protocol == IPPROTO_ICMPV6) {
				if (optval != icmp6off)
					error = EINVAL;
			} else
				inp->inp_cksum6 = optval;
			break;

		case PRCO_GETOPT:
			if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
				optval = icmp6off;
			else
				optval = inp->inp_cksum6;

			m->m_len = sizeof(int);
			*mtod(m, int *) = optval;
			break;

		default:
			error = EINVAL;
			break;
		}
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}

	if (op == PRCO_SETOPT)
		(void)m_free(m);

	return (error);
}

/*
 * initialize ip6_pktopts.  beware that there are non-zero default values in
 * the struct.
 */
void
ip6_initpktopts(struct ip6_pktopts *opt)
{
	bzero(opt, sizeof(*opt));
	opt->ip6po_hlim = -1;	/* -1 means default hop limit */
	opt->ip6po_tclass = -1;	/* -1 means default traffic class */
	opt->ip6po_minmtu = IP6PO_MINMTU_MCASTONLY;
}

int
ip6_pcbopt(int optname, u_char *buf, int len, struct ip6_pktopts **pktopt,
    int priv, int uproto)
{
	struct ip6_pktopts *opt;

	if (*pktopt == NULL) {
		*pktopt = malloc(sizeof(struct ip6_pktopts), M_IP6OPT,
		    M_WAITOK);
		ip6_initpktopts(*pktopt);
	}
	opt = *pktopt;

	return (ip6_setpktopt(optname, buf, len, opt, priv, 1, uproto));
}

int
ip6_getpcbopt(struct ip6_pktopts *pktopt, int optname, struct mbuf *m)
{
	void *optdata = NULL;
	int optdatalen = 0;
	struct ip6_ext *ip6e;
	int error = 0;
	struct in6_pktinfo null_pktinfo;
	int deftclass = 0, on;
	int defminmtu = IP6PO_MINMTU_MCASTONLY;

	switch (optname) {
	case IPV6_PKTINFO:
		if (pktopt && pktopt->ip6po_pktinfo)
			optdata = (void *)pktopt->ip6po_pktinfo;
		else {
			/* XXX: we don't have to do this every time... */
			bzero(&null_pktinfo, sizeof(null_pktinfo));
			optdata = (void *)&null_pktinfo;
		}
		optdatalen = sizeof(struct in6_pktinfo);
		break;
	case IPV6_TCLASS:
		if (pktopt && pktopt->ip6po_tclass >= 0)
			optdata = (void *)&pktopt->ip6po_tclass;
		else
			optdata = (void *)&deftclass;
		optdatalen = sizeof(int);
		break;
	case IPV6_HOPOPTS:
		if (pktopt && pktopt->ip6po_hbh) {
			optdata = (void *)pktopt->ip6po_hbh;
			ip6e = (struct ip6_ext *)pktopt->ip6po_hbh;
			optdatalen = (ip6e->ip6e_len + 1) << 3;
		}
		break;
	case IPV6_RTHDR:
		if (pktopt && pktopt->ip6po_rthdr) {
			optdata = (void *)pktopt->ip6po_rthdr;
			ip6e = (struct ip6_ext *)pktopt->ip6po_rthdr;
			optdatalen = (ip6e->ip6e_len + 1) << 3;
		}
		break;
	case IPV6_RTHDRDSTOPTS:
		if (pktopt && pktopt->ip6po_dest1) {
			optdata = (void *)pktopt->ip6po_dest1;
			ip6e = (struct ip6_ext *)pktopt->ip6po_dest1;
			optdatalen = (ip6e->ip6e_len + 1) << 3;
		}
		break;
	case IPV6_DSTOPTS:
		if (pktopt && pktopt->ip6po_dest2) {
			optdata = (void *)pktopt->ip6po_dest2;
			ip6e = (struct ip6_ext *)pktopt->ip6po_dest2;
			optdatalen = (ip6e->ip6e_len + 1) << 3;
		}
		break;
	case IPV6_USE_MIN_MTU:
		if (pktopt)
			optdata = (void *)&pktopt->ip6po_minmtu;
		else
			optdata = (void *)&defminmtu;
		optdatalen = sizeof(int);
		break;
	case IPV6_DONTFRAG:
		if (pktopt && ((pktopt->ip6po_flags) & IP6PO_DONTFRAG))
			on = 1;
		else
			on = 0;
		optdata = (void *)&on;
		optdatalen = sizeof(on);
		break;
	default:		/* should not happen */
#ifdef DIAGNOSTIC
		panic("ip6_getpcbopt: unexpected option");
#endif
		return (ENOPROTOOPT);
	}

	if (optdatalen > MCLBYTES)
		return (EMSGSIZE); /* XXX */
	if (optdatalen > MLEN)
		MCLGET(m, M_WAIT);
	m->m_len = optdatalen;
	if (optdatalen)
		bcopy(optdata, mtod(m, void *), optdatalen);

	return (error);
}

void
ip6_clearpktopts(struct ip6_pktopts *pktopt, int optname)
{
	if (optname == -1 || optname == IPV6_PKTINFO) {
		if (pktopt->ip6po_pktinfo)
			free(pktopt->ip6po_pktinfo, M_IP6OPT, 0);
		pktopt->ip6po_pktinfo = NULL;
	}
	if (optname == -1 || optname == IPV6_HOPLIMIT)
		pktopt->ip6po_hlim = -1;
	if (optname == -1 || optname == IPV6_TCLASS)
		pktopt->ip6po_tclass = -1;
	if (optname == -1 || optname == IPV6_HOPOPTS) {
		if (pktopt->ip6po_hbh)
			free(pktopt->ip6po_hbh, M_IP6OPT, 0);
		pktopt->ip6po_hbh = NULL;
	}
	if (optname == -1 || optname == IPV6_RTHDRDSTOPTS) {
		if (pktopt->ip6po_dest1)
			free(pktopt->ip6po_dest1, M_IP6OPT, 0);
		pktopt->ip6po_dest1 = NULL;
	}
	if (optname == -1 || optname == IPV6_RTHDR) {
		if (pktopt->ip6po_rhinfo.ip6po_rhi_rthdr)
			free(pktopt->ip6po_rhinfo.ip6po_rhi_rthdr, M_IP6OPT, 0);
		pktopt->ip6po_rhinfo.ip6po_rhi_rthdr = NULL;
		if (pktopt->ip6po_route.ro_rt) {
			rtfree(pktopt->ip6po_route.ro_rt);
			pktopt->ip6po_route.ro_rt = NULL;
		}
	}
	if (optname == -1 || optname == IPV6_DSTOPTS) {
		if (pktopt->ip6po_dest2)
			free(pktopt->ip6po_dest2, M_IP6OPT, 0);
		pktopt->ip6po_dest2 = NULL;
	}
}

#define PKTOPT_EXTHDRCPY(type) \
do {\
	if (src->type) {\
		size_t hlen = (((struct ip6_ext *)src->type)->ip6e_len + 1) << 3;\
		dst->type = malloc(hlen, M_IP6OPT, M_NOWAIT);\
		if (dst->type == NULL)\
			goto bad;\
		memcpy(dst->type, src->type, hlen);\
	}\
} while (/*CONSTCOND*/ 0)

int
copypktopts(struct ip6_pktopts *dst, struct ip6_pktopts *src)
{
	dst->ip6po_hlim = src->ip6po_hlim;
	dst->ip6po_tclass = src->ip6po_tclass;
	dst->ip6po_flags = src->ip6po_flags;
	if (src->ip6po_pktinfo) {
		dst->ip6po_pktinfo = malloc(sizeof(*dst->ip6po_pktinfo),
		    M_IP6OPT, M_NOWAIT);
		if (dst->ip6po_pktinfo == NULL)
			goto bad;
		*dst->ip6po_pktinfo = *src->ip6po_pktinfo;
	}
	PKTOPT_EXTHDRCPY(ip6po_hbh);
	PKTOPT_EXTHDRCPY(ip6po_dest1);
	PKTOPT_EXTHDRCPY(ip6po_dest2);
	PKTOPT_EXTHDRCPY(ip6po_rthdr); /* not copy the cached route */
	return (0);

  bad:
	ip6_clearpktopts(dst, -1);
	return (ENOBUFS);
}
#undef PKTOPT_EXTHDRCPY

void
ip6_freepcbopts(struct ip6_pktopts *pktopt)
{
	if (pktopt == NULL)
		return;

	ip6_clearpktopts(pktopt, -1);

	free(pktopt, M_IP6OPT, 0);
}

/*
 * Set the IP6 multicast options in response to user setsockopt().
 */
int
ip6_setmoptions(int optname, struct ip6_moptions **im6op, struct mbuf *m)
{
	int error = 0;
	u_int loop, ifindex;
	struct ipv6_mreq *mreq;
	struct ifnet *ifp;
	struct ip6_moptions *im6o = *im6op;
	struct in6_multi_mship *imm;
	struct proc *p = curproc;	/* XXX */

	if (im6o == NULL) {
		/*
		 * No multicast option buffer attached to the pcb;
		 * allocate one and initialize to default values.
		 */
		im6o = (struct ip6_moptions *)
			malloc(sizeof(*im6o), M_IPMOPTS, M_WAITOK);

		if (im6o == NULL)
			return (ENOBUFS);
		*im6op = im6o;
		im6o->im6o_ifidx = 0;
		im6o->im6o_hlim = ip6_defmcasthlim;
		im6o->im6o_loop = IPV6_DEFAULT_MULTICAST_LOOP;
		LIST_INIT(&im6o->im6o_memberships);
	}

	switch (optname) {

	case IPV6_MULTICAST_IF:
		/*
		 * Select the interface for outgoing multicast packets.
		 */
		if (m == NULL || m->m_len != sizeof(u_int)) {
			error = EINVAL;
			break;
		}
		memcpy(&ifindex, mtod(m, u_int *), sizeof(ifindex));
		if (ifindex != 0) {
			ifp = if_get(ifindex);
			if (ifp == NULL) {
				error = ENXIO;	/* XXX EINVAL? */
				break;
			}
			if ((ifp->if_flags & IFF_MULTICAST) == 0) {
				error = EADDRNOTAVAIL;
				if_put(ifp);
				break;
			}
			if_put(ifp);
		}
		im6o->im6o_ifidx = ifindex;
		break;

	case IPV6_MULTICAST_HOPS:
	    {
		/*
		 * Set the IP6 hoplimit for outgoing multicast packets.
		 */
		int optval;
		if (m == NULL || m->m_len != sizeof(int)) {
			error = EINVAL;
			break;
		}
		memcpy(&optval, mtod(m, u_int *), sizeof(optval));
		if (optval < -1 || optval >= 256)
			error = EINVAL;
		else if (optval == -1)
			im6o->im6o_hlim = ip6_defmcasthlim;
		else
			im6o->im6o_hlim = optval;
		break;
	    }

	case IPV6_MULTICAST_LOOP:
		/*
		 * Set the loopback flag for outgoing multicast packets.
		 * Must be zero or one.
		 */
		if (m == NULL || m->m_len != sizeof(u_int)) {
			error = EINVAL;
			break;
		}
		memcpy(&loop, mtod(m, u_int *), sizeof(loop));
		if (loop > 1) {
			error = EINVAL;
			break;
		}
		im6o->im6o_loop = loop;
		break;

	case IPV6_JOIN_GROUP:
		/*
		 * Add a multicast group membership.
		 * Group must be a valid IP6 multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ipv6_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ipv6_mreq *);
		if (IN6_IS_ADDR_UNSPECIFIED(&mreq->ipv6mr_multiaddr)) {
			/*
			 * We use the unspecified address to specify to accept
			 * all multicast addresses. Only super user is allowed
			 * to do this.
			 */
			if (suser(p, 0))
			{
				error = EACCES;
				break;
			}
		} else if (!IN6_IS_ADDR_MULTICAST(&mreq->ipv6mr_multiaddr)) {
			error = EINVAL;
			break;
		}

		/*
		 * If no interface was explicitly specified, choose an
		 * appropriate one according to the given multicast address.
		 */
		if (mreq->ipv6mr_interface == 0) {
			struct rtentry *rt;
			struct sockaddr_in6 dst;

			memset(&dst, 0, sizeof(dst));
			dst.sin6_len = sizeof(dst);
			dst.sin6_family = AF_INET6;
			dst.sin6_addr = mreq->ipv6mr_multiaddr;
			rt = rtalloc(sin6tosa(&dst), RT_RESOLVE,
			    m->m_pkthdr.ph_rtableid);
			if (rt == NULL) {
				error = EADDRNOTAVAIL;
				break;
			}
			ifp = if_get(rt->rt_ifidx);
			rtfree(rt);
		} else {
			/*
			 * If the interface is specified, validate it.
			 */
			ifp = if_get(mreq->ipv6mr_interface);
			if (ifp == NULL) {
				error = ENXIO;	/* XXX EINVAL? */
				break;
			}
		}

		/*
		 * See if we found an interface, and confirm that it
		 * supports multicast
		 */
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			if_put(ifp);
			error = EADDRNOTAVAIL;
			break;
		}
		/*
		 * Put interface index into the multicast address,
		 * if the address has link/interface-local scope.
		 */
		if (IN6_IS_SCOPE_EMBED(&mreq->ipv6mr_multiaddr)) {
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(ifp->if_index);
		}
		/*
		 * See if the membership already exists.
		 */
		LIST_FOREACH(imm, &im6o->im6o_memberships, i6mm_chain)
			if (imm->i6mm_maddr->in6m_ifidx == ifp->if_index &&
			    IN6_ARE_ADDR_EQUAL(&imm->i6mm_maddr->in6m_addr,
			    &mreq->ipv6mr_multiaddr))
				break;
		if (imm != NULL) {
			if_put(ifp);
			error = EADDRINUSE;
			break;
		}
		/*
		 * Everything looks good; add a new record to the multicast
		 * address list for the given interface.
		 */
		imm = in6_joingroup(ifp, &mreq->ipv6mr_multiaddr, &error);
		if_put(ifp);
		if (!imm)
			break;
		LIST_INSERT_HEAD(&im6o->im6o_memberships, imm, i6mm_chain);
		break;

	case IPV6_LEAVE_GROUP:
		/*
		 * Drop a multicast group membership.
		 * Group must be a valid IP6 multicast address.
		 */
		if (m == NULL || m->m_len != sizeof(struct ipv6_mreq)) {
			error = EINVAL;
			break;
		}
		mreq = mtod(m, struct ipv6_mreq *);
		if (IN6_IS_ADDR_UNSPECIFIED(&mreq->ipv6mr_multiaddr)) {
			if (suser(p, 0))
			{
				error = EACCES;
				break;
			}
		} else if (!IN6_IS_ADDR_MULTICAST(&mreq->ipv6mr_multiaddr)) {
			error = EINVAL;
			break;
		}

		/*
		 * Put interface index into the multicast address,
		 * if the address has link-local scope.
		 */
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mreq->ipv6mr_multiaddr)) {
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
		}

		/*
		 * If an interface address was specified, get a pointer
		 * to its ifnet structure.
		 */
		if (mreq->ipv6mr_interface == 0)
			ifp = NULL;
		else {
			ifp = if_get(mreq->ipv6mr_interface);
			if (ifp == NULL) {
				error = ENXIO;	/* XXX EINVAL? */
				break;
			}
		}

		/*
		 * Find the membership in the membership list.
		 */
		LIST_FOREACH(imm, &im6o->im6o_memberships, i6mm_chain) {
			if ((ifp == NULL ||
			    imm->i6mm_maddr->in6m_ifidx == ifp->if_index) &&
			    IN6_ARE_ADDR_EQUAL(&imm->i6mm_maddr->in6m_addr,
			    &mreq->ipv6mr_multiaddr))
				break;
		}

		if_put(ifp);

		if (imm == NULL) {
			/* Unable to resolve interface */
			error = EADDRNOTAVAIL;
			break;
		}
		/*
		 * Give up the multicast address record to which the
		 * membership points.
		 */
		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
		break;

	default:
		error = EOPNOTSUPP;
		break;
	}

	/*
	 * If all options have default values, no need to keep the option
	 * structure.
	 */
	if (im6o->im6o_ifidx == 0 &&
	    im6o->im6o_hlim == ip6_defmcasthlim &&
	    im6o->im6o_loop == IPV6_DEFAULT_MULTICAST_LOOP &&
	    LIST_EMPTY(&im6o->im6o_memberships)) {
		free(*im6op, M_IPMOPTS, 0);
		*im6op = NULL;
	}

	return (error);
}

/*
 * Return the IP6 multicast options in response to user getsockopt().
 */
int
ip6_getmoptions(int optname, struct ip6_moptions *im6o, struct mbuf *m)
{
	u_int *hlim, *loop, *ifindex;

	switch (optname) {
	case IPV6_MULTICAST_IF:
		ifindex = mtod(m, u_int *);
		m->m_len = sizeof(u_int);
		if (im6o == NULL || im6o->im6o_ifidx == 0)
			*ifindex = 0;
		else
			*ifindex = im6o->im6o_ifidx;
		return (0);

	case IPV6_MULTICAST_HOPS:
		hlim = mtod(m, u_int *);
		m->m_len = sizeof(u_int);
		if (im6o == NULL)
			*hlim = ip6_defmcasthlim;
		else
			*hlim = im6o->im6o_hlim;
		return (0);

	case IPV6_MULTICAST_LOOP:
		loop = mtod(m, u_int *);
		m->m_len = sizeof(u_int);
		if (im6o == NULL)
			*loop = ip6_defmcasthlim;
		else
			*loop = im6o->im6o_loop;
		return (0);

	default:
		return (EOPNOTSUPP);
	}
}

/*
 * Discard the IP6 multicast options.
 */
void
ip6_freemoptions(struct ip6_moptions *im6o)
{
	struct in6_multi_mship *imm;

	if (im6o == NULL)
		return;

	while (!LIST_EMPTY(&im6o->im6o_memberships)) {
		imm = LIST_FIRST(&im6o->im6o_memberships);
		LIST_REMOVE(imm, i6mm_chain);
		in6_leavegroup(imm);
	}
	free(im6o, M_IPMOPTS, 0);
}

/*
 * Set IPv6 outgoing packet options based on advanced API.
 */
int
ip6_setpktopts(struct mbuf *control, struct ip6_pktopts *opt,
    struct ip6_pktopts *stickyopt, int priv, int uproto)
{
	u_int clen;
	struct cmsghdr *cm = 0;
	caddr_t cmsgs;
	int error;

	if (control == NULL || opt == NULL)
		return (EINVAL);

	ip6_initpktopts(opt);
	if (stickyopt) {
		int error;

		/*
		 * If stickyopt is provided, make a local copy of the options
		 * for this particular packet, then override them by ancillary
		 * objects.
		 * XXX: copypktopts() does not copy the cached route to a next
		 * hop (if any).  This is not very good in terms of efficiency,
		 * but we can allow this since this option should be rarely
		 * used.
		 */
		if ((error = copypktopts(opt, stickyopt)) != 0)
			return (error);
	}

	/*
	 * XXX: Currently, we assume all the optional information is stored
	 * in a single mbuf.
	 */
	if (control->m_next)
		return (EINVAL);

	clen = control->m_len;
	cmsgs = mtod(control, caddr_t);
	do {
		if (clen < CMSG_LEN(0))
			return (EINVAL);
		cm = (struct cmsghdr *)cmsgs;
		if (cm->cmsg_len < CMSG_LEN(0) || cm->cmsg_len > clen ||
		    CMSG_ALIGN(cm->cmsg_len) > clen)
			return (EINVAL);
		if (cm->cmsg_level == IPPROTO_IPV6) {
			error = ip6_setpktopt(cm->cmsg_type, CMSG_DATA(cm),
			    cm->cmsg_len - CMSG_LEN(0), opt, priv, 0, uproto);
			if (error)
				return (error);
		}

		clen -= CMSG_ALIGN(cm->cmsg_len);
		cmsgs += CMSG_ALIGN(cm->cmsg_len);
	} while (clen);

	return (0);
}

/*
 * Set a particular packet option, as a sticky option or an ancillary data
 * item.  "len" can be 0 only when it's a sticky option.
 */
int
ip6_setpktopt(int optname, u_char *buf, int len, struct ip6_pktopts *opt,
    int priv, int sticky, int uproto)
{
	int minmtupolicy;

	switch (optname) {
	case IPV6_PKTINFO:
	{
		struct ifnet *ifp = NULL;
		struct in6_pktinfo *pktinfo;

		if (len != sizeof(struct in6_pktinfo))
			return (EINVAL);

		pktinfo = (struct in6_pktinfo *)buf;

		/*
		 * An application can clear any sticky IPV6_PKTINFO option by
		 * doing a "regular" setsockopt with ipi6_addr being
		 * in6addr_any and ipi6_ifindex being zero.
		 * [RFC 3542, Section 6]
		 */
		if (opt->ip6po_pktinfo &&
		    pktinfo->ipi6_ifindex == 0 &&
		    IN6_IS_ADDR_UNSPECIFIED(&pktinfo->ipi6_addr)) {
			ip6_clearpktopts(opt, optname);
			break;
		}

		if (uproto == IPPROTO_TCP &&
		    sticky && !IN6_IS_ADDR_UNSPECIFIED(&pktinfo->ipi6_addr)) {
			return (EINVAL);
		}

		if (pktinfo->ipi6_ifindex) {
			ifp = if_get(pktinfo->ipi6_ifindex);
			if (ifp == NULL)
				return (ENXIO);
			if_put(ifp);
		}

		/*
		 * We store the address anyway, and let in6_selectsrc()
		 * validate the specified address.  This is because ipi6_addr
		 * may not have enough information about its scope zone, and
		 * we may need additional information (such as outgoing
		 * interface or the scope zone of a destination address) to
		 * disambiguate the scope.
		 * XXX: the delay of the validation may confuse the
		 * application when it is used as a sticky option.
		 */
		if (opt->ip6po_pktinfo == NULL) {
			opt->ip6po_pktinfo = malloc(sizeof(*pktinfo),
			    M_IP6OPT, M_NOWAIT);
			if (opt->ip6po_pktinfo == NULL)
				return (ENOBUFS);
		}
		bcopy(pktinfo, opt->ip6po_pktinfo, sizeof(*pktinfo));
		break;
	}

	case IPV6_HOPLIMIT:
	{
		int *hlimp;

		/*
		 * RFC 3542 deprecated the usage of sticky IPV6_HOPLIMIT
		 * to simplify the ordering among hoplimit options.
		 */
		if (sticky)
			return (ENOPROTOOPT);

		if (len != sizeof(int))
			return (EINVAL);
		hlimp = (int *)buf;
		if (*hlimp < -1 || *hlimp > 255)
			return (EINVAL);

		opt->ip6po_hlim = *hlimp;
		break;
	}

	case IPV6_TCLASS:
	{
		int tclass;

		if (len != sizeof(int))
			return (EINVAL);
		tclass = *(int *)buf;
		if (tclass < -1 || tclass > 255)
			return (EINVAL);

		opt->ip6po_tclass = tclass;
		break;
	}
	case IPV6_HOPOPTS:
	{
		struct ip6_hbh *hbh;
		int hbhlen;

		/*
		 * XXX: We don't allow a non-privileged user to set ANY HbH
		 * options, since per-option restriction has too much
		 * overhead.
		 */
		if (!priv)
			return (EPERM);

		if (len == 0) {
			ip6_clearpktopts(opt, IPV6_HOPOPTS);
			break;	/* just remove the option */
		}

		/* message length validation */
		if (len < sizeof(struct ip6_hbh))
			return (EINVAL);
		hbh = (struct ip6_hbh *)buf;
		hbhlen = (hbh->ip6h_len + 1) << 3;
		if (len != hbhlen)
			return (EINVAL);

		/* turn off the previous option, then set the new option. */
		ip6_clearpktopts(opt, IPV6_HOPOPTS);
		opt->ip6po_hbh = malloc(hbhlen, M_IP6OPT, M_NOWAIT);
		if (opt->ip6po_hbh == NULL)
			return (ENOBUFS);
		memcpy(opt->ip6po_hbh, hbh, hbhlen);

		break;
	}

	case IPV6_DSTOPTS:
	case IPV6_RTHDRDSTOPTS:
	{
		struct ip6_dest *dest, **newdest = NULL;
		int destlen;

		if (!priv)	/* XXX: see the comment for IPV6_HOPOPTS */
			return (EPERM);

		if (len == 0) {
			ip6_clearpktopts(opt, optname);
			break;	/* just remove the option */
		}

		/* message length validation */
		if (len < sizeof(struct ip6_dest))
			return (EINVAL);
		dest = (struct ip6_dest *)buf;
		destlen = (dest->ip6d_len + 1) << 3;
		if (len != destlen)
			return (EINVAL);
		/*
		 * Determine the position that the destination options header
		 * should be inserted; before or after the routing header.
		 */
		switch (optname) {
		case IPV6_RTHDRDSTOPTS:
			newdest = &opt->ip6po_dest1;
			break;
		case IPV6_DSTOPTS:
			newdest = &opt->ip6po_dest2;
			break;
		}

		/* turn off the previous option, then set the new option. */
		ip6_clearpktopts(opt, optname);
		*newdest = malloc(destlen, M_IP6OPT, M_NOWAIT);
		if (*newdest == NULL)
			return (ENOBUFS);
		memcpy(*newdest, dest, destlen);

		break;
	}

	case IPV6_RTHDR:
	{
		struct ip6_rthdr *rth;
		int rthlen;

		if (len == 0) {
			ip6_clearpktopts(opt, IPV6_RTHDR);
			break;	/* just remove the option */
		}

		/* message length validation */
		if (len < sizeof(struct ip6_rthdr))
			return (EINVAL);
		rth = (struct ip6_rthdr *)buf;
		rthlen = (rth->ip6r_len + 1) << 3;
		if (len != rthlen)
			return (EINVAL);

		switch (rth->ip6r_type) {
		case IPV6_RTHDR_TYPE_0:
			if (rth->ip6r_len == 0)	/* must contain one addr */
				return (EINVAL);
			if (rth->ip6r_len % 2) /* length must be even */
				return (EINVAL);
			if (rth->ip6r_len / 2 != rth->ip6r_segleft)
				return (EINVAL);
			break;
		default:
			return (EINVAL);	/* not supported */
		}
		/* turn off the previous option */
		ip6_clearpktopts(opt, IPV6_RTHDR);
		opt->ip6po_rthdr = malloc(rthlen, M_IP6OPT, M_NOWAIT);
		if (opt->ip6po_rthdr == NULL)
			return (ENOBUFS);
		memcpy(opt->ip6po_rthdr, rth, rthlen);
		break;
	}

	case IPV6_USE_MIN_MTU:
		if (len != sizeof(int))
			return (EINVAL);
		minmtupolicy = *(int *)buf;
		if (minmtupolicy != IP6PO_MINMTU_MCASTONLY &&
		    minmtupolicy != IP6PO_MINMTU_DISABLE &&
		    minmtupolicy != IP6PO_MINMTU_ALL) {
			return (EINVAL);
		}
		opt->ip6po_minmtu = minmtupolicy;
		break;

	case IPV6_DONTFRAG:
		if (len != sizeof(int))
			return (EINVAL);

		if (uproto == IPPROTO_TCP || *(int *)buf == 0) {
			/*
			 * we ignore this option for TCP sockets.
			 * (RFC3542 leaves this case unspecified.)
			 */
			opt->ip6po_flags &= ~IP6PO_DONTFRAG;
		} else
			opt->ip6po_flags |= IP6PO_DONTFRAG;
		break;

	default:
		return (ENOPROTOOPT);
	} /* end of switch */

	return (0);
}

/*
 * Routine called from ip6_output() to loop back a copy of an IP6 multicast
 * packet to the input queue of a specified interface.
 */
void
ip6_mloopback(struct ifnet *ifp, struct mbuf *m, struct sockaddr_in6 *dst)
{
	struct mbuf *copym;
	struct ip6_hdr *ip6;

	/*
	 * Duplicate the packet.
	 */
	copym = m_copym(m, 0, M_COPYALL, M_NOWAIT);
	if (copym == NULL)
		return;

	/*
	 * Make sure to deep-copy IPv6 header portion in case the data
	 * is in an mbuf cluster, so that we can safely override the IPv6
	 * header portion later.
	 */
	if ((copym->m_flags & M_EXT) != 0 ||
	    copym->m_len < sizeof(struct ip6_hdr)) {
		copym = m_pullup(copym, sizeof(struct ip6_hdr));
		if (copym == NULL)
			return;
	}

#ifdef DIAGNOSTIC
	if (copym->m_len < sizeof(*ip6)) {
		m_freem(copym);
		return;
	}
#endif

	ip6 = mtod(copym, struct ip6_hdr *);
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;

	if_input_local(ifp, copym, dst->sin6_family);
}

/*
 * Chop IPv6 header off from the payload.
 */
int
ip6_splithdr(struct mbuf *m, struct ip6_exthdrs *exthdrs)
{
	struct mbuf *mh;
	struct ip6_hdr *ip6;

	ip6 = mtod(m, struct ip6_hdr *);
	if (m->m_len > sizeof(*ip6)) {
		MGETHDR(mh, M_DONTWAIT, MT_HEADER);
		if (mh == NULL) {
			m_freem(m);
			return ENOBUFS;
		}
		M_MOVE_PKTHDR(mh, m);
		MH_ALIGN(mh, sizeof(*ip6));
		m->m_len -= sizeof(*ip6);
		m->m_data += sizeof(*ip6);
		mh->m_next = m;
		m = mh;
		m->m_len = sizeof(*ip6);
		bcopy((caddr_t)ip6, mtod(m, caddr_t), sizeof(*ip6));
	}
	exthdrs->ip6e_ip6 = m;
	return 0;
}

u_int32_t
ip6_randomid(void)
{
	return idgen32(&ip6_id_ctx);
}

void
ip6_randomid_init(void)
{
	idgen32_init(&ip6_id_ctx);
}

/*
 *	Compute significant parts of the IPv6 checksum pseudo-header
 *	for use in a delayed TCP/UDP checksum calculation.
 */
static __inline u_int16_t __attribute__((__unused__))
in6_cksum_phdr(const struct in6_addr *src, const struct in6_addr *dst,
    u_int32_t len, u_int32_t nxt)
{
	u_int32_t sum = 0;
	const u_int16_t *w;

	w = (const u_int16_t *) src;
	sum += w[0];
	if (!IN6_IS_SCOPE_EMBED(src))
		sum += w[1];
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
	sum += w[6]; sum += w[7];

	w = (const u_int16_t *) dst;
	sum += w[0];
	if (!IN6_IS_SCOPE_EMBED(dst))
		sum += w[1];
	sum += w[2]; sum += w[3]; sum += w[4]; sum += w[5];
	sum += w[6]; sum += w[7];

	sum += (u_int16_t)(len >> 16) + (u_int16_t)(len /*& 0xffff*/);

	sum += (u_int16_t)(nxt >> 16) + (u_int16_t)(nxt /*& 0xffff*/);

	sum = (u_int16_t)(sum >> 16) + (u_int16_t)(sum /*& 0xffff*/);

	if (sum > 0xffff)
		sum -= 0xffff;

	return (sum);
}

/*
 * Process a delayed payload checksum calculation.
 */
void
in6_delayed_cksum(struct mbuf *m, u_int8_t nxt)
{
	int nxtp, offset;
	u_int16_t csum;

	offset = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxtp);
	if (offset <= 0 || nxtp != nxt)
		/* If the desired next protocol isn't found, punt. */
		return;
	csum = (u_int16_t)(in6_cksum(m, 0, offset, m->m_pkthdr.len - offset));

	switch (nxt) {
	case IPPROTO_TCP:
		offset += offsetof(struct tcphdr, th_sum);
		break;

	case IPPROTO_UDP:
		offset += offsetof(struct udphdr, uh_sum);
		if (csum == 0)
			csum = 0xffff;
		break;

	case IPPROTO_ICMPV6:
		offset += offsetof(struct icmp6_hdr, icmp6_cksum);
		break;
	}

	if ((offset + sizeof(u_int16_t)) > m->m_len)
		m_copyback(m, offset, sizeof(csum), &csum, M_NOWAIT);
	else
		*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
}

void
in6_proto_cksum_out(struct mbuf *m, struct ifnet *ifp)
{
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);

	/* some hw and in6_delayed_cksum need the pseudo header cksum */
	if (m->m_pkthdr.csum_flags &
	    (M_TCP_CSUM_OUT|M_UDP_CSUM_OUT|M_ICMP_CSUM_OUT)) {
		int nxt, offset;
		u_int16_t csum;

		offset = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxt);
		csum = in6_cksum_phdr(&ip6->ip6_src, &ip6->ip6_dst,
		    htonl(m->m_pkthdr.len - offset), htonl(nxt));
		if (nxt == IPPROTO_TCP)
			offset += offsetof(struct tcphdr, th_sum);
		else if (nxt == IPPROTO_UDP)
			offset += offsetof(struct udphdr, uh_sum);
		else if (nxt == IPPROTO_ICMPV6)
			offset += offsetof(struct icmp6_hdr, icmp6_cksum);
		if ((offset + sizeof(u_int16_t)) > m->m_len)
			m_copyback(m, offset, sizeof(csum), &csum, M_NOWAIT);
		else
			*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
	}

	if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_TCPv6) ||
		    ip6->ip6_nxt != IPPROTO_TCP ||
		    ifp->if_bridgeport != NULL) {
			tcpstat_inc(tcps_outswcsum);
			in6_delayed_cksum(m, IPPROTO_TCP);
			m->m_pkthdr.csum_flags &= ~M_TCP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_UDPv6) ||
		    ip6->ip6_nxt != IPPROTO_UDP ||
		    ifp->if_bridgeport != NULL) {
			udpstat_inc(udps_outswcsum);
			in6_delayed_cksum(m, IPPROTO_UDP);
			m->m_pkthdr.csum_flags &= ~M_UDP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_ICMP_CSUM_OUT) {
		in6_delayed_cksum(m, IPPROTO_ICMPV6);
		m->m_pkthdr.csum_flags &= ~M_ICMP_CSUM_OUT; /* Clear */
	}
}

#ifdef IPSEC
struct tdb *
ip6_output_ipsec_lookup(struct mbuf *m, int *error, struct inpcb *inp)
{
	struct tdb *tdb;
	struct m_tag *mtag;
	struct tdb_ident *tdbi;

	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */

	/* Do we have any pending SAs to apply ? */
	tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
	    error, IPSP_DIRECTION_OUT, NULL, inp, 0);

	if (tdb == NULL)
		return NULL;
	/* Loop detection */
	for (mtag = m_tag_first(m); mtag != NULL; mtag = m_tag_next(m, mtag)) {
		if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
			continue;
		tdbi = (struct tdb_ident *)(mtag + 1);
		if (tdbi->spi == tdb->tdb_spi &&
		    tdbi->proto == tdb->tdb_sproto &&
		    tdbi->rdomain == tdb->tdb_rdomain &&
		    !memcmp(&tdbi->dst, &tdb->tdb_dst,
		    sizeof(union sockaddr_union))) {
			/* no IPsec needed */
			return NULL;
		}
	}
	return tdb;
}

int
ip6_output_ipsec_send(struct tdb *tdb, struct mbuf *m, int tunalready, int fwd)
{
#if NPF > 0
	struct ifnet *encif;
#endif

#if NPF > 0
	if ((encif = enc_getif(tdb->tdb_rdomain, tdb->tdb_tap)) == NULL ||
	    pf_test(AF_INET6, fwd ? PF_FWD : PF_OUT, encif, &m) != PF_PASS) {
		m_freem(m);
		return EHOSTUNREACH;
	}
	if (m == NULL)
		return 0;
	/*
	 * PF_TAG_REROUTE handling or not...
	 * Packet is entering IPsec so the routing is
	 * already overruled by the IPsec policy.
	 * Until now the change was not reconsidered.
	 * What's the behaviour?
	 */
	in6_proto_cksum_out(m, encif);
#endif
	m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

	/* Callee frees mbuf */
	return ipsp_process_packet(m, tdb, AF_INET6, tunalready);
}
#endif /* IPSEC */
@


1.225
log
@percpu counters for TCP stats

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.224 2017/02/05 16:04:14 jca Exp $	*/
d1065 46
a1110 3
	if (level == IPPROTO_IPV6) {
		switch (op) {
		case PRCO_SETOPT:
d1112 1
a1112 20
			/*
			 * Use of some Hop-by-Hop options or some
			 * Destination options, might require special
			 * privilege.  That is, normal applications
			 * (without special privilege) might be forbidden
			 * from setting certain options in outgoing packets,
			 * and might never see certain options in received
			 * packets. [RFC 2292 Section 6]
			 * KAME specific note:
			 *  KAME prevents non-privileged users from sending or
			 *  receiving ANY hbh/dst options in order to avoid
			 *  overhead of parsing options in the kernel.
			 */
			case IPV6_RECVHOPOPTS:
			case IPV6_RECVDSTOPTS:
				if (!privileged) {
					error = EPERM;
					break;
				}
				/* FALLTHROUGH */
d1114 1
a1114 12
			case IPV6_MINHOPCOUNT:
			case IPV6_HOPLIMIT:

			case IPV6_RECVPKTINFO:
			case IPV6_RECVHOPLIMIT:
			case IPV6_RECVRTHDR:
			case IPV6_RECVPATHMTU:
			case IPV6_RECVTCLASS:
			case IPV6_V6ONLY:
			case IPV6_AUTOFLOWLABEL:
			case IPV6_RECVDSTPORT:
				if (m == NULL || m->m_len != sizeof(int)) {
d1116 3
a1118 1
					break;
d1120 1
a1120 2
				optval = *mtod(m, int *);
				switch (optname) {
d1122 6
a1127 15
				case IPV6_UNICAST_HOPS:
					if (optval < -1 || optval >= 256)
						error = EINVAL;
					else {
						/* -1 = kernel default */
						inp->inp_hops = optval;
					}
					break;

				case IPV6_MINHOPCOUNT:
					if (optval < 0 || optval > 255)
						error = EINVAL;
					else
						inp->inp_ip6_minhlim = optval;
					break;
d1138 3
a1140 3
				case IPV6_RECVPKTINFO:
					OPTSET(IN6P_PKTINFO);
					break;
d1142 3
a1144 12
				case IPV6_HOPLIMIT:
				{
					struct ip6_pktopts **optp;

					optp = &inp->inp_outputopts6;
					error = ip6_pcbopt(IPV6_HOPLIMIT,
							   (u_char *)&optval,
							   sizeof(optval),
							   optp,
							   privileged, uproto);
					break;
				}
d1146 8
a1153 3
				case IPV6_RECVHOPLIMIT:
					OPTSET(IN6P_HOPLIMIT);
					break;
d1155 3
a1157 3
				case IPV6_RECVHOPOPTS:
					OPTSET(IN6P_HOPOPTS);
					break;
d1159 3
a1161 3
				case IPV6_RECVDSTOPTS:
					OPTSET(IN6P_DSTOPTS);
					break;
d1163 3
a1165 3
				case IPV6_RECVRTHDR:
					OPTSET(IN6P_RTHDR);
					break;
d1167 3
a1169 10
				case IPV6_RECVPATHMTU:
					/*
					 * We ignore this option for TCP
					 * sockets.
					 * (RFC3542 leaves this case
					 * unspecified.)
					 */
					if (uproto != IPPROTO_TCP)
						OPTSET(IN6P_MTU);
					break;
d1171 10
a1180 23
				case IPV6_V6ONLY:
					/*
					 * make setsockopt(IPV6_V6ONLY)
					 * available only prior to bind(2).
					 * see ipng mailing list, Jun 22 2001.
					 */
					if (inp->inp_lport ||
					    !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) {
						error = EINVAL;
						break;
					}
					/* No support for IPv4-mapped addresses. */
					if (!optval)
						error = EINVAL;
					else
						error = 0;
					break;
				case IPV6_RECVTCLASS:
					OPTSET(IN6P_TCLASS);
					break;
				case IPV6_AUTOFLOWLABEL:
					OPTSET(IN6P_AUTOFLOWLABEL);
					break;
d1182 9
a1190 2
				case IPV6_RECVDSTPORT:
					OPTSET(IN6P_RECVDSTPORT);
d1193 11
d1206 5
a1210 18
			case IPV6_TCLASS:
			case IPV6_DONTFRAG:
			case IPV6_USE_MIN_MTU:
				if (m == NULL || m->m_len != sizeof(optval)) {
					error = EINVAL;
					break;
				}
				optval = *mtod(m, int *);
				{
					struct ip6_pktopts **optp;
					optp = &inp->inp_outputopts6;
					error = ip6_pcbopt(optname,
							   (u_char *)&optval,
							   sizeof(optval),
							   optp,
							   privileged, uproto);
					break;
				}
d1212 8
a1219 5
			case IPV6_PKTINFO:
			case IPV6_HOPOPTS:
			case IPV6_RTHDR:
			case IPV6_DSTOPTS:
			case IPV6_RTHDRDSTOPTS:
a1220 3
				/* new advanced API (RFC3542) */
				u_char *optbuf;
				int optbuflen;
a1221 12

				if (m && m->m_next) {
					error = EINVAL;	/* XXX */
					break;
				}
				if (m) {
					optbuf = mtod(m, u_char *);
					optbuflen = m->m_len;
				} else {
					optbuf = NULL;
					optbuflen = 0;
				}
d1224 4
a1227 2
						   optbuf, optbuflen,
						   optp, privileged, uproto);
d1230 29
d1261 13
a1273 8
			case IPV6_MULTICAST_IF:
			case IPV6_MULTICAST_HOPS:
			case IPV6_MULTICAST_LOOP:
			case IPV6_JOIN_GROUP:
			case IPV6_LEAVE_GROUP:
				error =	ip6_setmoptions(optname,
							&inp->inp_moptions6,
							m);
d1275 2
d1278 10
a1287 6
			case IPV6_PORTRANGE:
				if (m == NULL || m->m_len != sizeof(int)) {
					error = EINVAL;
					break;
				}
				optval = *mtod(m, int *);
d1289 4
a1292 5
				switch (optval) {
				case IPV6_PORTRANGE_DEFAULT:
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags &= ~(IN6P_HIGHPORT);
					break;
d1294 5
a1298 4
				case IPV6_PORTRANGE_HIGH:
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags |= IN6P_HIGHPORT;
					break;
d1300 3
a1302 4
				case IPV6_PORTRANGE_LOW:
					inp->inp_flags &= ~(IN6P_HIGHPORT);
					inp->inp_flags |= IN6P_LOWPORT;
					break;
d1304 9
a1312 4
				default:
					error = EINVAL;
					break;
				}
d1314 2
d1317 2
a1318 1
			case IPSEC6_OUTSA:
d1321 1
d1323 1
d1325 3
a1327 8
			case IPV6_ESP_TRANS_LEVEL:
			case IPV6_ESP_NETWORK_LEVEL:
			case IPV6_IPCOMP_LEVEL:
#ifndef IPSEC
				error = EINVAL;
#else
				if (m == NULL || m->m_len != sizeof(int)) {
					error = EINVAL;
d1330 2
a1331 1
				optval = *mtod(m, int *);
d1333 4
a1336 3
				if (optval < IPSEC_LEVEL_BYPASS ||
				    optval > IPSEC_LEVEL_UNIQUE) {
					error = EINVAL;
d1339 2
d1342 4
a1345 8
				switch (optname) {
				case IPV6_AUTH_LEVEL:
				        if (optval < IPSEC_AUTH_LEVEL_DEFAULT &&
					    suser(p, 0)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_AUTH] = optval;
d1347 3
d1351 4
a1354 25
				case IPV6_ESP_TRANS_LEVEL:
				        if (optval < IPSEC_ESP_TRANS_LEVEL_DEFAULT &&
					    suser(p, 0)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_ESP_TRANS] = optval;
					break;

				case IPV6_ESP_NETWORK_LEVEL:
				        if (optval < IPSEC_ESP_NETWORK_LEVEL_DEFAULT &&
					    suser(p, 0)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_ESP_NETWORK] = optval;
					break;

				case IPV6_IPCOMP_LEVEL:
				        if (optval < IPSEC_IPCOMP_LEVEL_DEFAULT &&
					    suser(p, 0)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_IPCOMP] = optval;
d1357 3
d1361 4
d1366 8
a1373 24
			case SO_RTABLE:
				if (m == NULL || m->m_len < sizeof(u_int)) {
					error = EINVAL;
					break;
				}
				rtid = *mtod(m, u_int *);
				if (inp->inp_rtableid == rtid)
					break;
				/* needs privileges to switch when already set */
				if (p->p_p->ps_rtableid != rtid &&
				    p->p_p->ps_rtableid != 0 &&
				    (error = suser(p, 0)) != 0)
					break;
				/* table must exist */
				if (!rtable_exists(rtid)) {
					error = EINVAL;
					break;
				}
				if (inp->inp_lport) {
					error = EBUSY;
					break;
				}
				inp->inp_rtableid = rtid;
				in_pcbrehash(inp);
d1375 3
a1377 5
			case IPV6_PIPEX:
				if (m != NULL && m->m_len == sizeof(int))
					inp->inp_pipex = *mtod(m, int *);
				else
					error = EINVAL;
d1379 3
a1381 3

			default:
				error = ENOPROTOOPT;
d1384 8
a1391 1
			m_free(m);
d1394 24
a1417 1
		case PRCO_GETOPT:
d1421 3
d1425 3
d1429 3
d1433 3
d1437 3
d1441 3
d1445 3
d1449 2
d1453 3
d1457 11
d1469 3
d1473 3
d1477 8
a1484 1
				switch (optname) {
d1486 13
a1498 3
				case IPV6_RECVHOPOPTS:
					optval = OPTBIT(IN6P_HOPOPTS);
					break;
d1500 14
a1513 3
				case IPV6_RECVDSTOPTS:
					optval = OPTBIT(IN6P_DSTOPTS);
					break;
d1515 12
a1526 3
				case IPV6_UNICAST_HOPS:
					optval = inp->inp_hops;
					break;
d1528 11
a1538 3
				case IPV6_MINHOPCOUNT:
					optval = inp->inp_ip6_minhlim;
					break;
d1540 8
a1547 3
				case IPV6_RECVPKTINFO:
					optval = OPTBIT(IN6P_PKTINFO);
					break;
d1549 3
a1551 3
				case IPV6_RECVHOPLIMIT:
					optval = OPTBIT(IN6P_HOPLIMIT);
					break;
d1553 12
a1564 40
				case IPV6_RECVRTHDR:
					optval = OPTBIT(IN6P_RTHDR);
					break;

				case IPV6_RECVPATHMTU:
					optval = OPTBIT(IN6P_MTU);
					break;

				case IPV6_V6ONLY:
					optval = 1;
					break;

				case IPV6_PORTRANGE:
				    {
					int flags;
					flags = inp->inp_flags;
					if (flags & IN6P_HIGHPORT)
						optval = IPV6_PORTRANGE_HIGH;
					else if (flags & IN6P_LOWPORT)
						optval = IPV6_PORTRANGE_LOW;
					else
						optval = 0;
					break;
				    }
				case IPV6_RECVTCLASS:
					optval = OPTBIT(IN6P_TCLASS);
					break;

				case IPV6_AUTOFLOWLABEL:
					optval = OPTBIT(IN6P_AUTOFLOWLABEL);
					break;

				case IPV6_RECVDSTPORT:
					optval = OPTBIT(IN6P_RECVDSTPORT);
					break;
				}
				if (error)
					break;
				m->m_len = sizeof(int);
				*mtod(m, int *) = optval;
d1567 3
a1569 39
			case IPV6_PATHMTU:
			{
				u_long pmtu = 0;
				struct ip6_mtuinfo mtuinfo;
				struct ifnet *ifp;
				struct rtentry *rt;

				if (!(so->so_state & SS_ISCONNECTED))
					return (ENOTCONN);

				rt = in_pcbrtentry(inp);
				if (!rtisvalid(rt))
					return (EHOSTUNREACH);

				ifp = if_get(rt->rt_ifidx);
				if (ifp == NULL)
					return (EHOSTUNREACH);
				/*
				 * XXX: we dot not consider the case of source
				 * routing, or optional information to specify
				 * the outgoing interface.
				 */
				error = ip6_getpmtu(rt, ifp, &pmtu);
				if_put(ifp);
				if (error)
					break;
				if (pmtu > IPV6_MAXPACKET)
					pmtu = IPV6_MAXPACKET;

				bzero(&mtuinfo, sizeof(mtuinfo));
				mtuinfo.ip6m_mtu = (u_int32_t)pmtu;
				optdata = (void *)&mtuinfo;
				optdatalen = sizeof(mtuinfo);
				if (optdatalen > MCLBYTES)
					return (EMSGSIZE); /* XXX */
				if (optdatalen > MLEN)
					MCLGET(m, M_WAIT);
				m->m_len = optdatalen;
				bcopy(optdata, mtod(m, void *), optdatalen);
a1570 1
			}
d1572 3
a1574 19
			case IPV6_PKTINFO:
			case IPV6_HOPOPTS:
			case IPV6_RTHDR:
			case IPV6_DSTOPTS:
			case IPV6_RTHDRDSTOPTS:
			case IPV6_TCLASS:
			case IPV6_DONTFRAG:
			case IPV6_USE_MIN_MTU:
				error = ip6_getpcbopt(inp->inp_outputopts6,
				    optname, m);
				break;

			case IPV6_MULTICAST_IF:
			case IPV6_MULTICAST_HOPS:
			case IPV6_MULTICAST_LOOP:
			case IPV6_JOIN_GROUP:
			case IPV6_LEAVE_GROUP:
				error = ip6_getmoptions(optname,
				    inp->inp_moptions6, m);
d1577 2
a1578 2
			case IPSEC6_OUTSA:
				error = EINVAL;
d1580 2
a1581 30

			case IPV6_AUTH_LEVEL:
			case IPV6_ESP_TRANS_LEVEL:
			case IPV6_ESP_NETWORK_LEVEL:
			case IPV6_IPCOMP_LEVEL:
#ifndef IPSEC
				m->m_len = sizeof(int);
				*mtod(m, int *) = IPSEC_LEVEL_NONE;
#else
				m->m_len = sizeof(int);
				switch (optname) {
				case IPV6_AUTH_LEVEL:
					optval = inp->inp_seclevel[SL_AUTH];
					break;

				case IPV6_ESP_TRANS_LEVEL:
					optval =
					    inp->inp_seclevel[SL_ESP_TRANS];
					break;

				case IPV6_ESP_NETWORK_LEVEL:
					optval =
					    inp->inp_seclevel[SL_ESP_NETWORK];
					break;

				case IPV6_IPCOMP_LEVEL:
					optval = inp->inp_seclevel[SL_IPCOMP];
					break;
				}
				*mtod(m, int *) = optval;
d1583 9
a1591 9
				break;
			case SO_RTABLE:
				m->m_len = sizeof(u_int);
				*mtod(m, u_int *) = optval;
				break;
			case IPV6_PIPEX:
				m->m_len = sizeof(int);
				*mtod(m, int *) = optval;
				break;
d1593 2
a1594 4
			default:
				error = ENOPROTOOPT;
				break;
			}
d1597 1
a1597 4
	} else {
		error = EINVAL;
		if (op == PRCO_SETOPT)
			(void)m_free(m);
@


1.224
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.223 2017/02/01 20:59:47 dhill Exp $	*/
d2721 1
a2721 1
			tcpstat.tcps_outswcsum++;
@


1.223
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.222 2017/01/27 02:55:36 dhill Exp $	*/
d364 1
a364 1
		ip6stat.ip6s_badscope++;
d369 1
a369 1
		ip6stat.ip6s_badscope++;
d373 1
a373 1
	ip6stat.ip6s_localout++;
d458 1
a458 1
			ip6stat.ip6s_noroute++;
d487 1
a487 1
			ip6stat.ip6s_noroute++;
d741 1
a741 1
			ip6stat.ip6s_odropped++;
d754 1
a754 1
			ip6stat.ip6s_ofragments++;
d762 1
a762 1
		ip6stat.ip6s_fragmented++;
@


1.222
log
@copypktopts is only called by ip6_setpktopts using M_NOWAIT.  Drop
canwait as it is unneeded.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.221 2017/01/19 14:49:19 bluhm Exp $	*/
d120 1
a120 1
int ip6_getpcbopt(struct ip6_pktopts *, int, struct mbuf **);
d123 1
a123 1
int ip6_getmoptions(int, struct ip6_moptions *, struct mbuf **);
d1051 1
a1051 1
    struct mbuf **mp)
a1055 1
	struct mbuf *m = *mp;
a1476 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1515 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
d1532 1
a1532 1
				    optname, mp);
d1541 1
a1541 1
				    inp->inp_moptions6, mp);
a1551 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1579 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1583 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
d1597 1
a1597 1
			(void)m_free(*mp);
d1604 1
a1604 1
    struct mbuf **mp)
a1608 1
	struct mbuf *m = *mp;
d1612 1
a1612 1
			(void)m_free(*mp);
a1648 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
a1676 1

d1700 1
a1700 1
ip6_getpcbopt(struct ip6_pktopts *pktopt, int optname, struct mbuf **mp)
a1708 1
	struct mbuf *m;
a1779 1
	*mp = m = m_get(M_WAIT, MT_SOOPTS);
d2161 1
a2161 1
ip6_getmoptions(int optname, struct ip6_moptions *im6o, struct mbuf **mp)
a2164 2
	*mp = m_get(M_WAIT, MT_SOOPTS);

a2165 1

d2167 2
a2168 2
		ifindex = mtod(*mp, u_int *);
		(*mp)->m_len = sizeof(u_int);
d2176 2
a2177 2
		hlim = mtod(*mp, u_int *);
		(*mp)->m_len = sizeof(u_int);
d2185 2
a2186 2
		loop = mtod(*mp, u_int *);
		(*mp)->m_len = sizeof(u_int);
@


1.221
log
@RFC 8021 "IPv6 Atomic Fragments Considered Harmful" deprecates
generating atomic fragments.  So remove the code that sends them.
CVE-2016-10142 has been assigned to that issue.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.220 2017/01/10 09:04:19 mpi Exp $	*/
d130 1
a130 1
int copypktopts(struct ip6_pktopts *, struct ip6_pktopts *, int);
d1842 2
a1843 2
		dst->type = malloc(hlen, M_IP6OPT, canwait);\
		if (dst->type == NULL && canwait == M_NOWAIT)\
d1850 1
a1850 1
copypktopts(struct ip6_pktopts *dst, struct ip6_pktopts *src, int canwait)
d1857 1
a1857 1
		    M_IP6OPT, canwait);
d2259 1
a2259 1
		if ((error = copypktopts(opt, stickyopt, M_NOWAIT)) != 0)
@


1.220
log
@Do not use a 'struct route_in6' when there's no need to cache the result
of rtalloc(9).

ok benno@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.219 2017/01/10 09:01:18 mpi Exp $	*/
d129 1
a129 1
int ip6_getpmtu(struct rtentry *, struct ifnet *, u_long *, int *);
d163 1
a163 1
	int alwaysfrag, dontfrag;
d558 1
a558 1
	if ((error = ip6_getpmtu(ro_pmtu->ro_rt, ifp, &mtu, &alwaysfrag)) != 0)
d657 1
a657 1
	 * 1: normal case (dontfrag == 0, alwaysfrag == 0)
a663 6
	 *
	 * 3: if we always need to attach fragment header (alwaysfrag == 1)
	 *      always fragment
	 *
	 * 4: if dontfrag == 1 && alwaysfrag == 1
	 *      error, as we cannot handle this conflicting request
a670 5
	if (dontfrag && alwaysfrag) {	/* case 4 */
		/* conflicting request - can't transmit */
		error = EMSGSIZE;
		goto bad;
	}
d679 1
a679 1
	if (dontfrag || (!alwaysfrag && tlen <= mtu)) {	/* case 1-a and 2-a */
d685 1
a685 1
	 * try to fragment the packet.  case 1-b and 3
d1013 1
a1013 2
ip6_getpmtu(struct rtentry *rt, struct ifnet *ifp, u_long *mtup,
    int *alwaysfragp)
a1015 1
	int alwaysfrag = 0;
d1023 1
a1023 9
			/*
			 * RFC2460 section 5, last paragraph:
			 * if we record ICMPv6 too big message with
			 * mtu < IPV6_MMTU, transmit packets sized IPV6_MMTU
			 * or smaller, with fragment header attached.
			 * (fragment header is needed regardless from the
			 * packet size, for translators to identify packets)
			 */
			alwaysfrag = 1;
a1042 2
	if (alwaysfragp)
		*alwaysfragp = alwaysfrag;
d1505 1
a1505 1
				error = ip6_getpmtu(rt, ifp, &pmtu, NULL);
@


1.219
log
@Remove NULL checks before m_free(9), it deals with it.

ok bluhm@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.218 2016/11/18 02:53:47 dlg Exp $	*/
a1918 2
	struct route_in6 ro;
	struct sockaddr_in6 *dst;
d2034 10
a2043 14
			/*
			 * Look up the routing table for the
			 * address, and choose the outgoing interface.
			 *   XXX: is it a good approach?
			 */
			bzero(&ro, sizeof(ro));
			ro.ro_tableid = m->m_pkthdr.ph_rtableid;
			dst = &ro.ro_dst;
			dst->sin6_len = sizeof(struct sockaddr_in6);
			dst->sin6_family = AF_INET6;
			dst->sin6_addr = mreq->ipv6mr_multiaddr;
			ro.ro_rt = rtalloc(sin6tosa(&ro.ro_dst),
			    RT_RESOLVE, ro.ro_tableid);
			if (ro.ro_rt == NULL) {
d2047 2
a2048 2
			ifp = if_get(ro.ro_rt->rt_ifidx);
			rtfree(ro.ro_rt);
@


1.218
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.217 2016/11/14 10:32:46 mpi Exp $	*/
d1417 1
a1417 2
			if (m)
				(void)m_free(m);
@


1.217
log
@Automatically create a default lo(4) interface per rdomain.

In order to stop abusing lo0 for all rdomains, a new loopback interface
will be created every time a rdomain is created.  The unit number will
be the same as the rdomain, i.e. lo1 will be attached to rdomain 1.

If this loopback interface is already in use it wont be possible to create
the corresponding rdomain.

In order to know which lo(4) interface is attached to a rdomain, its index
is stored in the rtable/rdomain map.

This is a long overdue since the introduction of rtable/rdomain.  It also
fixes a recent regression due to resetting the rdomain of an incoming
packet reported by semarie@@, Andreas Bartelt and Nils Frohberg.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.216 2016/09/19 18:09:09 tedu Exp $	*/
d2773 1
a2773 1
			udpstat.udps_outswcsum++;
@


1.216
log
@convert bcopy to memcpy. from david hill. ok jca
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.215 2016/09/14 16:59:28 jca Exp $	*/
d463 1
a463 1
			ifp = if_get(lo0ifidx);
@


1.215
log
@Kill ip6_pcbopts, unused since the removal of IPV6_PKTOPTIONS

ok mikeb@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.214 2016/09/14 15:26:05 jca Exp $	*/
d970 1
a970 1
	bcopy(&v, &optbuf[4], sizeof(u_int32_t));
d1865 1
a1865 1
		int hlen = (((struct ip6_ext *)src->type)->ip6e_len + 1) << 3;\
d1869 1
a1869 1
		bcopy(src->type, dst->type, hlen);\
d1952 1
a1952 1
		bcopy(mtod(m, u_int *), &ifindex, sizeof(ifindex));
d1979 1
a1979 1
		bcopy(mtod(m, u_int *), &optval, sizeof(optval));
d1998 1
a1998 1
		bcopy(mtod(m, u_int *), &loop, sizeof(loop));
d2454 1
a2454 1
		bcopy(hbh, opt->ip6po_hbh, hbhlen);
d2498 1
a2498 1
		bcopy(dest, *newdest, destlen);
d2538 1
a2538 1
		bcopy(rth, opt->ip6po_rthdr, rthlen);
@


1.214
log
@Delete dead code and useless parameter.

ok vgross@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.213 2016/08/25 12:30:16 mpi Exp $	*/
a119 1
int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *, struct socket *);
a1699 42
}

/*
 * Set up IP6 options in pcb for insertion in output packets.
 * Store in mbuf with pointer in pcbopt, adding pseudo-option
 * with destination address if source routed.
 */
int
ip6_pcbopts(struct ip6_pktopts **pktopt, struct mbuf *m, struct socket *so)
{
	struct ip6_pktopts *opt = *pktopt;
	int error = 0;
	struct proc *p = curproc;	/* XXX */
	int priv = 0;

	/* turn off any old options. */
	if (opt)
		ip6_clearpktopts(opt, -1);
	else
		opt = malloc(sizeof(*opt), M_IP6OPT, M_WAITOK);
	*pktopt = 0;

	if (!m || m->m_len == 0) {
		/*
		 * Only turning off any previous options, regardless of
		 * whether the opt is just created or given.
		 */
		free(opt, M_IP6OPT, sizeof(*opt));
		return (0);
	}

	/*  set options specified by user. */
	if (p && !suser(p, 0))
		priv = 1;
	if ((error = ip6_setpktopts(m, opt, NULL, priv,
	    so->so_proto->pr_protocol)) != 0) {
		ip6_clearpktopts(opt, -1);	/* XXX discard all options */
		free(opt, M_IP6OPT, sizeof(*opt));
		return (error);
	}
	*pktopt = opt;
	return (0);
@


1.213
log
@Simplify ip6_getpmtu() to use a 'struct rtentry *' instead of two
'struct route_in6 *'.

This is another little step towards deprecating 'struct route{,_in6}'

Inputs from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.212 2016/08/22 10:33:22 mpi Exp $	*/
d122 1
a122 2
int ip6_setpktopt(int, u_char *, int, struct ip6_pktopts *, int, int,
	int, int);
d1772 1
a1772 1
	return (ip6_setpktopt(optname, buf, len, opt, priv, 1, 0, uproto));
d2354 1
a2354 1
			    cm->cmsg_len - CMSG_LEN(0), opt, priv, 0, 1, uproto);
a2368 5
 * We have 4 cases of combination of "sticky" and "cmsg":
 * "sticky=0, cmsg=0": impossible
 * "sticky=0, cmsg=1": RFC2292 or RFC3542 ancillary data
 * "sticky=1, cmsg=0": RFC3542 socket option
 * "sticky=1, cmsg=1": RFC2292 socket option
d2372 1
a2372 1
    int priv, int sticky, int cmsg, int uproto)
a2374 22

	if (!sticky && !cmsg) {
#ifdef DIAGNOSTIC
		printf("ip6_setpktopt: impossible case\n");
#endif
		return (EINVAL);
	}

	if (sticky && cmsg) {
		switch (optname) {
		case IPV6_PKTINFO:
		case IPV6_HOPLIMIT:
		case IPV6_HOPOPTS:
		case IPV6_DSTOPTS:
		case IPV6_RTHDRDSTOPTS:
		case IPV6_RTHDR:
		case IPV6_USE_MIN_MTU:
		case IPV6_DONTFRAG:
		case IPV6_TCLASS:
			return (ENOPROTOOPT);
		}
	}
@


1.212
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.211 2016/07/01 18:18:57 jca Exp $	*/
d131 1
a131 2
int ip6_getpmtu(struct route_in6 *, struct route_in6 *, struct ifnet *,
    unsigned int, struct in6_addr *, u_long *, int *);
d560 1
a560 2
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, ro->ro_tableid, &finaldst,
	    &mtu, &alwaysfrag)) != 0)
d1026 2
a1027 2
ip6_getpmtu(struct route_in6 *ro_pmtu, struct route_in6 *ro, struct ifnet *ifp0,
    unsigned int rtableid, struct in6_addr *dst, u_long *mtup, int *alwaysfragp)
d1033 2
a1034 32
	if (ro_pmtu != ro) {
		/* The first hop and the final destination may differ. */
		struct sockaddr_in6 *sa6_dst = &ro_pmtu->ro_dst;

		if (!rtisvalid(ro_pmtu->ro_rt) ||
		    (ro_pmtu->ro_tableid != rtableid) ||
		     !IN6_ARE_ADDR_EQUAL(&sa6_dst->sin6_addr, dst)) {
			rtfree(ro_pmtu->ro_rt);
			ro_pmtu->ro_rt = NULL;
		}
		if (ro_pmtu->ro_rt == NULL) {
			bzero(ro_pmtu, sizeof(*ro_pmtu));
			ro_pmtu->ro_tableid = rtableid;
			sa6_dst->sin6_family = AF_INET6;
			sa6_dst->sin6_len = sizeof(struct sockaddr_in6);
			sa6_dst->sin6_addr = *dst;

			ro_pmtu->ro_rt = rtalloc(sin6tosa(&ro_pmtu->ro_dst),
			    RT_RESOLVE, ro_pmtu->ro_tableid);
		}
	}
	if (ro_pmtu->ro_rt) {
		struct ifnet *ifp;

		if (ifp0 == NULL) {
			ifp = if_get(ro_pmtu->ro_rt->rt_ifidx);
			if (ifp == NULL)
				return (EHOSTUNREACH);
		} else
			ifp = ifp0;

		mtu = ro_pmtu->ro_rt->rt_rmx.rmx_mtu;
d1058 2
a1059 2
			if (!(ro_pmtu->ro_rt->rt_rmx.rmx_locks & RTV_MTU))
				ro_pmtu->ro_rt->rt_rmx.rmx_mtu = mtu;
d1061 3
a1063 7

		if (ifp0 == NULL)
			if_put(ifp);
	} else if (ifp0) {
		mtu = ifp0->if_mtu;
	} else
		error = EHOSTUNREACH; /* XXX */
d1513 2
a1514 1
				struct route_in6 *ro = (struct route_in6 *)&inp->inp_route6;
d1518 8
d1531 2
a1532 3
				error = ip6_getpmtu(ro, NULL, NULL,
				    inp->inp_rtableid, &inp->inp_faddr6, &pmtu,
				    NULL);
@


1.211
log
@Unbreak getsockopt(IPV6_MINHOPCOUNT)

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.210 2016/06/27 16:33:48 jca Exp $	*/
d1757 1
a1757 1
		free(opt, M_IP6OPT, 0);
d1767 1
a1767 1
		free(opt, M_IP6OPT, 0);
@


1.210
log
@Implement IPV6_MINHOPCOUNT support.

Useful to implement GTSM support in daemons such as bgpd(8). Diff from
2013 revived by renato@@.  Input from bluhm@@, ok bluhm@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.209 2016/06/15 13:49:43 florian Exp $	*/
d1465 1
@


1.209
log
@With the introduction of ip6_output_ipsec_lookup() we didn't exit the
loop when we worked out that no IPsec is needed which led to a NULL
de-ref on the next iteration.
Fix this by making the code more similar to the IPv4 case.

Found the hard way by me, OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.208 2016/06/15 11:49:34 mpi Exp $	*/
d1152 1
d1178 8
d1487 4
@


1.208
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.207 2016/05/19 11:34:40 jca Exp $	*/
d2885 14
a2898 13
	if (tdb != NULL) {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    tdbi->rdomain == tdb->tdb_rdomain &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union)))
				tdb = NULL;
a2899 1
		/* We need to do IPsec */
@


1.207
log
@Remove sysctl net.inet6.ip6.v6only

This sysctl is a no-op, read-only since it was introduced.  There are no
plans to support IPv4-mapped addresses on OpenBSD, thus this sysctl is
meaningless.

Noticed by djm@@, ok claudio@@ mpi@@ sthen@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.206 2016/04/29 11:40:27 bluhm Exp $	*/
d695 1
a695 1
		error = nd6_output(ifp, m, dst, ro->ro_rt);
d770 2
a771 1
			error = nd6_output(ifp, m, dst, ro->ro_rt);
@


1.206
log
@Do not allow to change the routing table of a bound socket.  This
is not intended and will behave unexpectedly if the address is
already used in another domain.  It did not work anyway, as the PCB
ended in the wrong hash bucket after changing the rtable.  Fail
with EBUSY if the socket is already bound and rehash the PCB if its
rtable changes.
input claudio@@; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.205 2016/04/27 21:14:29 markus Exp $	*/
d1240 4
a1243 2
					if ((ip6_v6only && optval) ||
					    (!ip6_v6only && !optval))
a1244 2
					else
						error = EINVAL;
d1496 1
a1496 1
					optval = (ip6_v6only != 0); /* XXX */
@


1.205
log
@factor out ipsec into ip6_output_ipsec_{lookup,send}(); ok mpi@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.204 2016/01/21 11:23:48 mpi Exp $	*/
d1427 4
d1432 1
@


1.204
log
@Introduce in{,6}_hasmulti(), two functions to check in the hot path if
an interface joined a specific multicast group.

ok phessler@@, visa@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.203 2016/01/13 09:38:37 mpi Exp $	*/
d175 1
a175 8
	struct m_tag *mtag;
	union sockaddr_union sdst;
	struct tdb_ident *tdbi;
	u_int32_t sspi;
	struct tdb *tdb;
#if NPF > 0
	struct ifnet *encif;
#endif
d211 3
a213 22
	if (!ipsec_in_use && !inp)
		goto done_spd;

	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */

	/* Do we have any pending SAs to apply ? */
	tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
	    &error, IPSP_DIRECTION_OUT, NULL, inp, 0);

	if (tdb == NULL) {
		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;

			/* Fall through to routing/multicast handling */
		} else {
a223 21
	} else {
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    tdbi->rdomain == tdb->tdb_rdomain &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
			}
		}

	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
a224 3

	/* Fall through to the routing/multicast handling code */
 done_spd:
d422 1
a422 5
	/*
	 * Check if the packet needs encapsulation.
	 * ipsp_process_packet will never come back to here.
	 */
	if (sproto != 0) {
a426 31

		tdb = gettdb(rtable_l2(m->m_pkthdr.ph_rtableid),
		    sspi, &sdst, sproto);
		if (tdb == NULL) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}

#if NPF > 0
		if ((encif = enc_getif(tdb->tdb_rdomain,
		    tdb->tdb_tap)) == NULL ||
		    pf_test(AF_INET6, PF_OUT, encif, &m) != PF_PASS) {
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}
		if (m == NULL)
			goto done;
		/*
		 * PF_TAG_REROUTE handling or not...
		 * Packet is entering IPsec so the routing is
		 * already overruled by the IPsec policy.
		 * Until now the change was not reconsidered.
		 * What's the behaviour?
		 */
		in6_proto_cksum_out(m, encif);
#endif
		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

		/* Callee frees mbuf */
d432 3
a434 4
		error = ipsp_process_packet(m, tdb, AF_INET6,
		    exthdrs.ip6e_rthdr ? 1 : 0);

		return error;  /* Nothing more to be done */
d2861 67
@


1.203
log
@Prevent a double if_put().

ok mikeb@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.202 2015/12/03 10:34:24 tedu Exp $	*/
a568 1
		struct	in6_multi *in6m;
d581 2
a582 3
		IN6_LOOKUP_MULTI(ip6->ip6_dst, ifp, in6m);
		if (in6m != NULL &&
		    (im6o == NULL || im6o->im6o_loop)) {
@


1.202
log
@rm unused kernel only IPV6_RECVRTHDRDSTOPTS sockopt. ok deraadt sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.201 2015/12/02 13:29:26 claudio Exp $	*/
d725 1
@


1.201
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.200 2015/11/29 15:12:36 mpi Exp $	*/
a1231 1
			case IPV6_RECVRTHDRDSTOPTS:
a1300 4
				case IPV6_RECVRTHDRDSTOPTS:
					OPTSET(IN6P_RTHDRDSTOPTS);
					break;

a1535 1
			case IPV6_RECVRTHDRDSTOPTS:
a1554 4
					break;

				case IPV6_RECVRTHDRDSTOPTS:
					optval = OPTBIT(IN6P_RTHDRDSTOPTS);
@


1.200
log
@Use if_get() rather than dereferencing rt_ifp in ip6_getpmtu().

While here fix a NULL dereference introduced by the support for
multiple rdomains.  It seems that this code path is never run...

With input from David Hill, ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.199 2015/11/11 10:23:23 mpi Exp $	*/
d1139 1
a1139 1
			    RT_REPORT|RT_RESOLVE, ro_pmtu->ro_tableid);
d2198 1
a2198 1
			    RT_REPORT|RT_RESOLVE, ro.ro_tableid);
@


1.199
log
@Store the index of the lo0 interface instead of a pointer to its
descriptor.

Allow to get rid of two if_ref() in the output paths.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.198 2015/11/03 21:39:34 chl Exp $	*/
d131 2
a132 2
int ip6_getpmtu(struct route_in6 *, struct route_in6 *,
	struct ifnet *, struct in6_addr *, u_long *, int *);
d649 2
a650 2
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu,
	    &alwaysfrag)) != 0)
d1114 2
a1115 2
ip6_getpmtu(struct route_in6 *ro_pmtu, struct route_in6 *ro,
    struct ifnet *ifp, struct in6_addr *dst, u_long *mtup, int *alwaysfragp)
d1126 1
a1126 1
		    (ro_pmtu->ro_tableid != ifp->if_rdomain) ||
d1133 1
a1133 1
			ro_pmtu->ro_tableid = ifp->if_rdomain;
d1143 9
a1151 2
		if (ifp == NULL)
			ifp = ro_pmtu->ro_rt->rt_ifp;
d1179 5
a1183 2
	} else if (ifp) {
		mtu = ifp->if_mtu;
d1636 2
a1637 1
				    &inp->inp_faddr6, &pmtu, NULL);
@


1.198
log
@Remove dead assignments.

Found by LLVM/Clang Static Analyzer.

ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.197 2015/11/03 21:11:48 naddy Exp $	*/
d552 1
a552 1
			ifp = if_ref(lo0ifp);
@


1.197
log
@Disable TCP/UDP TX hardware checksumming if an IPv4 packet contains
IP options or if an IPv6 packet contains header extensions.
Required by cnmac(4) and a sensible precautionary measure in general.
ok visa@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.196 2015/10/29 16:27:45 tedu Exp $	*/
a224 1
	ip6 = mtod(m, struct ip6_hdr *);
a499 1
		ip6 = mtod(m, struct ip6_hdr *);
@


1.196
log
@a few redundant tests can be deleted now that switch cases are only for
a single value
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.195 2015/10/29 16:22:45 tedu Exp $	*/
d2905 2
a2909 1
		struct ip6_hdr *ip6;
a2912 1
		ip6 = mtod(m, struct ip6_hdr *);
d2930 1
d2938 1
@


1.195
log
@oops, one firebomb went off course. put back some code that's still used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.194 2015/10/29 16:04:10 tedu Exp $	*/
d2517 1
a2517 1
		if (optname == IPV6_PKTINFO && opt->ip6po_pktinfo &&
d2524 1
a2524 1
		if (uproto == IPPROTO_TCP && optname == IPV6_PKTINFO &&
d2564 1
a2564 1
		if (optname == IPV6_HOPLIMIT && sticky)
@


1.194
log
@RFC 2292 API support was removed 9 years ago, but left in a binary compat
ABI form for the sake of existing programs. no programs from that era have
been able to run for quite some time. Kill it all.
ok deraadt florian millert mpi
(I believe this is my first IPv6 diff. Future, here I come!)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.193 2015/10/28 12:14:25 florian Exp $	*/
d2501 55
@


1.193
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.192 2015/10/25 14:43:06 florian Exp $	*/
a1208 5
			case IPV6_2292PKTOPTIONS:
				error = ip6_pcbopts(&inp->inp_outputopts6,
				    m, so);
				break;

a1262 8
#define OPTSET2292(bit) \
do { \
	inp->inp_flags |= IN6P_RFC2292; \
	if (optval) \
		inp->inp_flags |= (bit); \
	else \
		inp->inp_flags &= ~(bit); \
} while (/*CONSTCOND*/ 0)
a1265 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1272 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1282 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1286 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1290 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1294 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1298 5
					/* cannot mix with RFC2292 */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1330 5
					/* cannot mix with RFC2292 XXX */
					if (OPTBIT(IN6P_RFC2292)) {
						error = EINVAL;
						break;
					}
a1361 37
			case IPV6_2292PKTINFO:
			case IPV6_2292HOPLIMIT:
			case IPV6_2292HOPOPTS:
			case IPV6_2292DSTOPTS:
			case IPV6_2292RTHDR:
				/* RFC 2292 */
				if (m == NULL || m->m_len != sizeof(int)) {
					error = EINVAL;
					break;
				}
				optval = *mtod(m, int *);
				switch (optname) {
				case IPV6_2292PKTINFO:
					OPTSET2292(IN6P_PKTINFO);
					break;
				case IPV6_2292HOPLIMIT:
					OPTSET2292(IN6P_HOPLIMIT);
					break;
				case IPV6_2292HOPOPTS:
					/*
					 * Check super-user privilege.
					 * See comments for IPV6_RECVHOPOPTS.
					 */
					if (!privileged)
						return (EPERM);
					OPTSET2292(IN6P_HOPOPTS);
					break;
				case IPV6_2292DSTOPTS:
					if (!privileged)
						return (EPERM);
					OPTSET2292(IN6P_DSTOPTS|IN6P_RTHDRDSTOPTS); /* XXX */
					break;
				case IPV6_2292RTHDR:
					OPTSET2292(IN6P_RTHDR);
					break;
				}
				break;
a1372 6
				/* cannot mix with RFC2292 */
				if (OPTBIT(IN6P_RFC2292)) {
					error = EINVAL;
					break;
				}

a1530 14
			case IPV6_2292PKTOPTIONS:
				/*
				 * RFC3542 (effectively) deprecated the
				 * semantics of the 2292-style pktoptions.
				 * Since it was not reliable in nature (i.e.,
				 * applications had to expect the lack of some
				 * information after all), it would make sense
				 * to simplify this part by always returning
				 * empty data.
				 */
				*mp = m_get(M_WAIT, MT_SOOPTS);
				(*mp)->m_len = 0;
				break;

a1647 26
			case IPV6_2292PKTINFO:
			case IPV6_2292HOPLIMIT:
			case IPV6_2292HOPOPTS:
			case IPV6_2292RTHDR:
			case IPV6_2292DSTOPTS:
				switch (optname) {
				case IPV6_2292PKTINFO:
					optval = OPTBIT(IN6P_PKTINFO);
					break;
				case IPV6_2292HOPLIMIT:
					optval = OPTBIT(IN6P_HOPLIMIT);
					break;
				case IPV6_2292HOPOPTS:
					optval = OPTBIT(IN6P_HOPOPTS);
					break;
				case IPV6_2292RTHDR:
					optval = OPTBIT(IN6P_RTHDR);
					break;
				case IPV6_2292DSTOPTS:
					optval = OPTBIT(IN6P_DSTOPTS|IN6P_RTHDRDSTOPTS);
					break;
				}
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
				m->m_len = sizeof(int);
				*mtod(m, int *) = optval;
				break;
a2484 16
	/*
	 * IPV6_2292xxx is for backward compatibility to RFC2292, and should
	 * not be specified in the context of RFC3542.  Conversely,
	 * RFC3542 types should not be specified in the context of RFC2292.
	 */
	if (!cmsg) {
		switch (optname) {
		case IPV6_2292PKTINFO:
		case IPV6_2292HOPLIMIT:
		case IPV6_2292HOPOPTS:
		case IPV6_2292DSTOPTS:
		case IPV6_2292RTHDR:
		case IPV6_2292PKTOPTIONS:
			return (ENOPROTOOPT);
		}
	}
a2500 57
	case IPV6_2292PKTINFO:
	case IPV6_PKTINFO:
	{
		struct ifnet *ifp = NULL;
		struct in6_pktinfo *pktinfo;

		if (len != sizeof(struct in6_pktinfo))
			return (EINVAL);

		pktinfo = (struct in6_pktinfo *)buf;

		/*
		 * An application can clear any sticky IPV6_PKTINFO option by
		 * doing a "regular" setsockopt with ipi6_addr being
		 * in6addr_any and ipi6_ifindex being zero.
		 * [RFC 3542, Section 6]
		 */
		if (optname == IPV6_PKTINFO && opt->ip6po_pktinfo &&
		    pktinfo->ipi6_ifindex == 0 &&
		    IN6_IS_ADDR_UNSPECIFIED(&pktinfo->ipi6_addr)) {
			ip6_clearpktopts(opt, optname);
			break;
		}

		if (uproto == IPPROTO_TCP && optname == IPV6_PKTINFO &&
		    sticky && !IN6_IS_ADDR_UNSPECIFIED(&pktinfo->ipi6_addr)) {
			return (EINVAL);
		}

		if (pktinfo->ipi6_ifindex) {
			ifp = if_get(pktinfo->ipi6_ifindex);
			if (ifp == NULL)
				return (ENXIO);
			if_put(ifp);
		}

		/*
		 * We store the address anyway, and let in6_selectsrc()
		 * validate the specified address.  This is because ipi6_addr
		 * may not have enough information about its scope zone, and
		 * we may need additional information (such as outgoing
		 * interface or the scope zone of a destination address) to
		 * disambiguate the scope.
		 * XXX: the delay of the validation may confuse the
		 * application when it is used as a sticky option.
		 */
		if (opt->ip6po_pktinfo == NULL) {
			opt->ip6po_pktinfo = malloc(sizeof(*pktinfo),
			    M_IP6OPT, M_NOWAIT);
			if (opt->ip6po_pktinfo == NULL)
				return (ENOBUFS);
		}
		bcopy(pktinfo, opt->ip6po_pktinfo, sizeof(*pktinfo));
		break;
	}

	case IPV6_2292HOPLIMIT:
a2534 1
	case IPV6_2292HOPOPTS:
a2570 1
	case IPV6_2292DSTOPTS:
a2596 18
		case IPV6_2292DSTOPTS:
			/*
			 * The old advanced API is ambiguous on this point.
			 * Our approach is to determine the position based
			 * according to the existence of a routing header.
			 * Note, however, that this depends on the order of the
			 * extension headers in the ancillary data; the 1st
			 * part of the destination options header must appear
			 * before the routing header in the ancillary data,
			 * too.
			 * RFC3542 solved the ambiguity by introducing
			 * separate ancillary data or option types.
			 */
			if (opt->ip6po_rthdr == NULL)
				newdest = &opt->ip6po_dest1;
			else
				newdest = &opt->ip6po_dest2;
			break;
a2614 1
	case IPV6_2292RTHDR:
@


1.192
log
@Remove IPV6_NEXTHOP implementation. Source routing is considered to be
a bad idea these days.
kill it mpi@@
general agreement in the network hackers room at u2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.191 2015/10/24 12:33:16 mpi Exp $	*/
d775 1
a775 20
	if (dontfrag && tlen > IN6_LINKMTU(ifp)) {	/* case 2-b */
		/*
		 * Even if the DONTFRAG option is specified, we cannot send the
		 * packet when the data length is larger than the MTU of the
		 * outgoing interface.
		 * Notify the error by sending IPV6_PATHMTU ancillary data as
		 * well as returning an error code (the latter is not described
		 * in the API spec.)
		 */
#if 0
		u_int32_t mtu32;
		struct ip6ctlparam ip6cp;

		mtu32 = (u_int32_t)mtu;
		bzero(&ip6cp, sizeof(ip6cp));
		ip6cp.ip6c_cmdarg = (void *)&mtu32;
		pfctlinput2(PRC_MSGSIZE, sin6tosa(&ro_pmtu->ro_dst),
		    (void *)&ip6cp);
#endif

a1144 2
		u_int32_t ifmtu;

a1146 1
		ifmtu = IN6_LINKMTU(ifp);
d1149 1
a1149 1
			mtu = ifmtu;
d1161 1
a1161 1
		} else if (mtu > ifmtu) {
d1170 1
a1170 1
			mtu = ifmtu;
d1175 1
a1175 1
		mtu = IN6_LINKMTU(ifp);
@


1.191
log
@Convert some if_ref() to if_get().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.190 2015/10/19 12:11:28 mpi Exp $	*/
d561 3
a563 11
	if (rt && !IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		if (opt && opt->ip6po_nextroute.ro_rt) {
			/*
			 * The nexthop is explicitly specified by the
			 * application.  We assume the next hop is an IPv6
			 * address.
			 */
			dst = satosin6(opt->ip6po_nexthop);
		} else if ((rt->rt_flags & RTF_GATEWAY))
			dst = satosin6(rt->rt_gateway);
	}
a1478 1
			case IPV6_NEXTHOP:
a1810 1
			case IPV6_NEXTHOP:
a2087 6
	case IPV6_NEXTHOP:
		if (pktopt && pktopt->ip6po_nexthop) {
			optdata = (void *)pktopt->ip6po_nexthop;
			optdatalen = pktopt->ip6po_nexthop->sa_len;
		}
		break;
a2133 9
	if (optname == -1 || optname == IPV6_NEXTHOP) {
		if (pktopt->ip6po_nextroute.ro_rt) {
			rtfree(pktopt->ip6po_nextroute.ro_rt);
			pktopt->ip6po_nextroute.ro_rt = NULL;
		}
		if (pktopt->ip6po_nexthop)
			free(pktopt->ip6po_nexthop, M_IP6OPT, 0);
		pktopt->ip6po_nexthop = NULL;
	}
a2183 8
	if (src->ip6po_nexthop) {
		dst->ip6po_nexthop = malloc(src->ip6po_nexthop->sa_len,
		    M_IP6OPT, canwait);
		if (dst->ip6po_nexthop == NULL)
			goto bad;
		bcopy(src->ip6po_nexthop, dst->ip6po_nexthop,
		    src->ip6po_nexthop->sa_len);
	}
a2651 1
		case IPV6_2292NEXTHOP:
a2662 1
		case IPV6_NEXTHOP:
a2765 52

	case IPV6_2292NEXTHOP:
	case IPV6_NEXTHOP:
		if (!priv)
			return (EPERM);

		if (len == 0) {	/* just remove the option */
			ip6_clearpktopts(opt, IPV6_NEXTHOP);
			break;
		}

		/* check if cmsg_len is large enough for sa_len */
		if (len < sizeof(struct sockaddr) || len < *buf)
			return (EINVAL);

		switch (((struct sockaddr *)buf)->sa_family) {
		case AF_INET6:
		{
			struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)buf;

			if (sa6->sin6_len != sizeof(struct sockaddr_in6))
				return (EINVAL);

			if (IN6_IS_ADDR_UNSPECIFIED(&sa6->sin6_addr) ||
			    IN6_IS_ADDR_MULTICAST(&sa6->sin6_addr)) {
				return (EINVAL);
			}
			if (IN6_IS_SCOPE_EMBED(&sa6->sin6_addr)) {
				struct ifnet *ifp;
				ifp = if_get(sa6->sin6_scope_id);
				if (ifp == NULL)
					return (EINVAL);
				if_put(ifp);
				sa6->sin6_addr.s6_addr16[1] =
				    htonl(sa6->sin6_scope_id);
			} else if (sa6->sin6_scope_id)
				return (EINVAL);
			break;
		}
		case AF_LINK:	/* eventually be supported? */
		default:
			return (EAFNOSUPPORT);
		}

		/* turn off the previous option, then set the new option. */
		ip6_clearpktopts(opt, IPV6_NEXTHOP);
		opt->ip6po_nexthop = malloc(*buf, M_IP6OPT, M_NOWAIT);
		if (opt->ip6po_nexthop == NULL)
			return (ENOBUFS);
		bcopy(buf, opt->ip6po_nexthop, *buf);
		break;

@


1.190
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.189 2015/09/23 08:49:46 mpi Exp $	*/
d556 1
a556 1
			ifp = if_ref(rt->rt_ifp);
d2385 1
a2385 1
			ifp = if_ref(ro.ro_rt->rt_ifp);
@


1.189
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.188 2015/09/13 13:57:07 mpi Exp $	*/
d1154 3
a1156 3
		if (ro_pmtu->ro_rt &&
		    ((ro_pmtu->ro_rt->rt_flags & RTF_UP) == 0 ||
		     !IN6_ARE_ADDR_EQUAL(&sa6_dst->sin6_addr, dst))) {
@


1.188
log
@Get the default loopback interface pointer just after doing a route
lookup to ensure pf_test() is called with the same interface in the
input annd output path for local traffic.

Fix a regression reported by Heiko Zimmermann on bugs@@, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.187 2015/09/12 20:26:07 mpi Exp $	*/
a559 6

	/*
	 * then rt (for unicast) and ifp must be non-NULL valid values.
	 */
	if (rt)
		rt->rt_use++;
@


1.187
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.186 2015/09/12 13:34:12 mpi Exp $	*/
d553 4
a556 1
		ifp = if_ref(rt->rt_ifp);
@


1.186
log
@Introduce if_input_local() a function to feed local traffic back to
the protocol queues.

It basically does what looutput() was doing but having a generic
function will allow us to get rid of the loopback hack overwwritting
the rt_ifp field of RTF_LOCAL routes.

ok mikeb@@, dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.185 2015/09/11 20:16:03 claudio Exp $	*/
d3031 1
a3031 3
 * packet to the input queue of a specified interface.  Note that this
 * calls the output routine of the loopback "driver", but with an interface
 * pointer that might NOT be lo0ifp -- easier than replicating that code here.
@


1.185
log
@if_put after if_get for in6_src and ip6_output which got a lot easier after
all the cleanup by mpi@@ since we no longer overwrite ifps, etc. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.184 2015/09/11 19:23:00 mpi Exp $	*/
d3073 1
a3073 1
	(void)looutput(ifp, copym, sin6tosa(dst), NULL);
@


1.184
log
@Rewrite in6_selectroute() to no longer return an ifp.

The returned "struct rtentry" is either the cached one or the one passed
in options.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.183 2015/09/11 13:53:04 mpi Exp $	*/
d553 1
a553 1
		ifp = rt->rt_ifp;
d737 1
d898 1
d2287 1
a2287 3
		if (ifindex == 0)
			ifp = NULL;
		else {
d2295 1
d2298 1
d2388 1
a2388 1
			ifp = ro.ro_rt->rt_ifp;
d2406 1
d2427 1
d2436 1
d2462 10
a2486 8
		 * Put interface index into the multicast address,
		 * if the address has link-local scope.
		 */
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mreq->ipv6mr_multiaddr)) {
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
		}
		/*
d2496 3
d2746 1
d2832 3
a2834 1
				if (if_get(sa6->sin6_scope_id) == NULL)
d2836 1
@


1.183
log
@Move the multicast option parsing out of in6_selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.182 2015/09/11 09:58:33 mpi Exp $	*/
d547 2
a548 2
		if ((error = in6_selectroute(&dstsock, opt, ro, &ifp,
		    &rt, m->m_pkthdr.ph_rtableid)) != 0) {
d550 1
d553 3
a555 7
	}
	if (rt == NULL) {
		/*
		 * If in6_selectroute() does not return a route entry,
		 * dst may not have been updated.
		 */
		*dst = dstsock;	/* XXX */
@


1.182
log
@Kill selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.181 2015/09/11 08:17:06 claudio Exp $	*/
d158 1
a158 1
	struct ifnet *ifp;
d531 18
a548 4
	if ((error = in6_selectroute(&dstsock, opt, im6o, ro, &ifp,
	    &rt, 0, m->m_pkthdr.ph_rtableid)) != 0) {
		switch (error) {
		case EHOSTUNREACH:
d550 1
a550 4
			break;
		case EADDRNOTAVAIL:
		default:
			break;	/* XXX statistics? */
a551 1
		goto bad;
@


1.181
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.180 2015/09/10 09:11:11 mpi Exp $	*/
d532 1
a532 1
	    &rt, m->m_pkthdr.ph_rtableid)) != 0) {
@


1.180
log
@Stop using in6_ifstat_inc().

ok dlg@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.179 2015/08/31 07:27:48 mpi Exp $	*/
a151 2
 *
 * ifpp - XXX: just for statistics
d155 1
a155 2
    int flags, struct ip6_moptions *im6o, struct ifnet **ifpp,
    struct inpcb *inp)
a652 7

	/*
	 * Fill the outgoing interface to tell the upper layer
	 * to increment per-interface statistics.
	 */
	if (ifpp)
		*ifpp = ifp;
@


1.179
log
@Compute the checksum before looping back the copy of a multicast packet.

Found while comparing IPv4 and IPv6 versions.

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.178 2015/08/31 07:17:12 mpi Exp $	*/
a543 2
		if (ifp != NULL)
			in6_ifstat_inc(ifp, ifs6_out_discard);
a559 5
	if ((flags & IPV6_FORWARDING) == 0) {
		/* XXX: the FORWARDING flag can be set for mrouting. */
		in6_ifstat_inc(ifp, ifs6_out_request);
	}

a581 2
		in6_ifstat_inc(ifp, ifs6_out_mcast);

a586 1
			in6_ifstat_inc(ifp, ifs6_out_discard);
a825 1
		in6_ifstat_inc(ifp, ifs6_out_fragfail);
a829 1
		in6_ifstat_inc(ifp, ifs6_out_fragfail);
d876 1
a876 9

		switch (error) {
		case 0:
			in6_ifstat_inc(ifp, ifs6_out_fragok);
			break;
		case EMSGSIZE:
			in6_ifstat_inc(ifp, ifs6_out_fragfail);
			break;
		default:
a877 2
			break;
		}
a890 1
			in6_ifstat_inc(ifp, ifs6_out_fragcreat);
@


1.178
log
@`encif' should only be used under #ifdef NPF.

Reported by jsg@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.177 2015/07/16 21:14:21 mpi Exp $	*/
d600 1
d608 2
d611 1
d613 3
a615 1
		} else {
a627 1
#ifdef MROUTING
d635 1
a636 1
		}
@


1.177
log
@Kill IP_ROUTETOETHER.

This pseudo-option is a hack to support return-rst on bridge(4).  It
passes Ethernet information via a "struct route" through ip_output().

"struct route" is slowly dying...

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.176 2015/07/15 22:16:42 deraadt Exp $	*/
d512 1
a513 2
		in6_proto_cksum_out(m, encif);

@


1.176
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.175 2015/06/30 15:30:17 mpi Exp $	*/
d497 1
a497 1
		    pf_test(AF_INET6, PF_OUT, encif, &m, NULL) != PF_PASS) {
d729 1
a729 1
	if (pf_test(AF_INET6, PF_OUT, ifp, &m, NULL) != PF_PASS) {
@


1.175
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.174 2015/06/16 11:09:40 mpi Exp $	*/
d1915 1
a1915 1
		if (op == PRCO_SETOPT && *mp)
d1931 1
a1931 1
		if (op == PRCO_SETOPT && *mp)
d1985 1
a1985 1
	if (op == PRCO_SETOPT && m)
@


1.174
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.173 2015/06/08 22:19:28 krw Exp $	*/
d3052 1
a3052 1
	copym = m_copy(m, 0, M_COPYALL);
@


1.173
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.172 2015/05/23 12:52:59 markus Exp $	*/
d716 1
a716 1
		m->m_pkthdr.rcvif = ifp;
d725 1
a725 1
		m->m_pkthdr.rcvif = NULL;
@


1.172
log
@remove PACKET_TAG_IPSEC_PENDING_TDB, it is never set; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.171 2015/05/13 10:42:47 jsg Exp $	*/
d157 1
a157 1
    int flags, struct ip6_moptions *im6o, struct ifnet **ifpp, 
d200 1
a200 1
		error = ip6_copyexthdr((mp), (caddr_t)(hp), 		\
d440 1
a440 1
	if (ro == 0) {
d1125 1
a1125 1
ip6_insertfraghdr(struct mbuf *m0, struct mbuf *m, int hlen, 
d1133 1
a1133 1
		if (n == 0)
d1166 1
a1166 1
ip6_getpmtu(struct route_in6 *ro_pmtu, struct route_in6 *ro, 
d1183 1
a1183 1
		if (ro_pmtu->ro_rt == 0) {
d1242 1
a1242 1
ip6_ctloutput(int op, struct socket *so, int level, int optname, 
d1922 1
a1922 1
ip6_raw_ctloutput(int op, struct socket *so, int level, int optname, 
d2611 1
a2611 1
ip6_setpktopts(struct mbuf *control, struct ip6_pktopts *opt, 
d3171 1
a3171 1
	offset = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxtp); 
@


1.171
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.170 2015/04/17 11:04:02 mikeb Exp $	*/
d231 2
a232 15
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip6_output: tag of length %hu (should be %zu",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
#endif
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->rdomain, tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
	} else
		tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
		    &error, IPSP_DIRECTION_OUT, NULL, inp, 0);
@


1.170
log
@Stubs and support code for NIC-enabled IPsec bite the dust.
No objection from reyk@@, OK markus, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.169 2015/04/16 19:24:13 markus Exp $	*/
d1059 1
a1059 1
		if (mopt == 0)
d1168 1
a1168 1
		if (mfrg == 0)
d1605 1
a1605 1
				if (m == 0 || m->m_len != sizeof(int)) {
d3109 1
a3109 1
		if (mh == 0) {
@


1.169
log
@remove unfinished/unused support for socket-attached ipsec-policies
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.168 2015/03/14 03:38:52 jsg Exp $	*/
d271 1
a271 3
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
@


1.168
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.167 2015/02/12 12:12:45 mpi Exp $	*/
a1265 5
#ifdef IPSEC
	struct tdb *tdb;
	struct tdb_ident *tdbip, tdbi;
	int s;
#endif
a1596 1
#ifndef IPSEC
a1597 16
#else
				if (m == NULL ||
				    m->m_len != sizeof(struct tdb_ident)) {
					error = EINVAL;
					break;
				}
				tdbip = mtod(m, struct tdb_ident *);
				s = splsoftnet();
				tdb = gettdb(tdbip->rdomain, tdbip->spi,
				    &tdbip->dst, tdbip->proto);
				if (tdb == NULL)
					error = ESRCH;
				else
					tdb_add_inp(tdb, inp, 0);
				splx(s);
#endif
a1655 2
				if (!error)
					inp->inp_secrequire = get_sa_require(inp);
a1875 1
#ifndef IPSEC
a1876 17
#else
				s = splsoftnet();
				if (inp->inp_tdb_out == NULL) {
					error = ENOENT;
				} else {
					tdbi.spi = inp->inp_tdb_out->tdb_spi;
					tdbi.dst = inp->inp_tdb_out->tdb_dst;
					tdbi.proto = inp->inp_tdb_out->tdb_sproto;
					tdbi.rdomain =
					    inp->inp_tdb_out->tdb_rdomain;
					*mp = m = m_get(M_WAIT, MT_SOOPTS);
					m->m_len = sizeof(tdbi);
					bcopy((caddr_t)&tdbi, mtod(m, caddr_t),
					    m->m_len);
				}
				splx(s);
#endif
@


1.167
log
@Remove a chunk that should have been deleted in r1.166, this was safe
because clearing fields twice is not a problem.

Yeah, I suck at applying diff.

ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.166 2015/02/05 01:10:57 mpi Exp $	*/
a108 1
#include <net/pfkeyv2.h>
@


1.166
log
@Make sure pf(4) does not see embedded scopes.

Packets destinated to link-local addresses are looped back with embedded
scopes because we cannot restore them using the receiving interface (lo0).
Embedded scopes are needed by the routing table to match RTF_LOCAL routes,
but pf(4) never saw them and existing rules are likely to break without
teaching the rule engine about them, found by dlg@@ the hard way.

So save and restore embedded scopes around pf_test() for packets going
through loopback.

ok dlg@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.165 2014/12/17 09:57:13 mpi Exp $	*/
a764 12

	/*
	 * If the packet is not going on the wire it can be destinated
	 * to any local address.  In this case do not clear its scopes
	 * to let ip6_input() find a matching local route.
	 */
	if ((ifp->if_flags & IFF_LOOPBACK) == 0) {
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;
	}
@


1.165
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.164 2014/12/17 09:45:59 mpi Exp $	*/
d171 1
d665 15
d776 12
@


1.164
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.163 2014/12/05 15:50:04 mpi Exp $	*/
d485 1
a485 1
			ip6->ip6_hlim = im6o->im6o_multicast_hlim;
d618 1
a618 1
		    (im6o == NULL || im6o->im6o_multicast_loop)) {
d2333 2
a2334 2
		im6o->im6o_multicast_hlim = ip6_defmcasthlim;
		im6o->im6o_multicast_loop = IPV6_DEFAULT_MULTICAST_LOOP;
d2379 1
a2379 1
			im6o->im6o_multicast_hlim = ip6_defmcasthlim;
d2381 1
a2381 1
			im6o->im6o_multicast_hlim = optval;
d2399 1
a2399 1
		im6o->im6o_multicast_loop = loop;
d2576 2
a2577 2
	    im6o->im6o_multicast_hlim == ip6_defmcasthlim &&
	    im6o->im6o_multicast_loop == IPV6_DEFAULT_MULTICAST_LOOP &&
d2613 1
a2613 1
			*hlim = im6o->im6o_multicast_hlim;
d2622 1
a2622 1
			*loop = im6o->im6o_multicast_loop;
@


1.163
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.162 2014/11/20 13:54:24 mpi Exp $	*/
d2332 1
a2332 1
		im6o->im6o_multicast_ifp = NULL;
d2362 1
a2362 1
		im6o->im6o_multicast_ifp = ifp;
d2575 1
a2575 1
	if (im6o->im6o_multicast_ifp == NULL &&
d2601 1
a2601 1
		if (im6o == NULL || im6o->im6o_multicast_ifp == NULL)
d2604 1
a2604 1
			*ifindex = im6o->im6o_multicast_ifp->if_index;
@


1.162
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.161 2014/11/01 21:40:39 mpi Exp $	*/
d77 1
@


1.161
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.160 2014/10/14 09:52:26 mpi Exp $	*/
d161 1
a161 1
	struct ifnet *ifp, *origifp = NULL;
a167 1
	struct in6_ifaddr *ia6 = NULL;
d574 1
a574 2
	if (rt) {
		ia6 = ifatoia6(rt->rt_ifa);
a575 1
	}
a581 10
	/*
	 * The outgoing interface must be in the zone of source and
	 * destination addresses.  We should use ia_ifp to support the
	 * case of sending packets to an address of our own.
	 */
	if (ia6 != NULL && ia6->ia_ifp)
		origifp = ia6->ia_ifp;
	else
		origifp = ifp;

a697 43
	/* Fake scoped addresses */
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		/*
		 * If source or destination address is a scoped address, and
		 * the packet is going to be sent to a loopback interface,
		 * we should keep the original interface.
		 */

		/*
		 * XXX: this is a very experimental and temporary solution.
		 * We eventually have sockaddr_in6 and use the sin6_scope_id
		 * field of the structure here.
		 * We rely on the consistency between two scope zone ids
		 * of source add destination, which should already be assured
		 * Larger scopes than link will be supported in the near
		 * future.
		 */
		origifp = NULL;
		if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
			origifp = if_get(ntohs(ip6->ip6_src.s6_addr16[1]));
		else if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
			origifp = if_get(ntohs(ip6->ip6_dst.s6_addr16[1]));
		/*
		 * XXX: origifp can be NULL even in those two cases above.
		 * For example, if we remove the (only) link-local address
		 * from the loopback interface, and try to send a link-local
		 * address without link-id information.  Then the source
		 * address is ::1, and the destination address is the
		 * link-local address with its s6_addr16[1] being zero.
		 * What is worse, if the packet goes to the loopback interface
		 * by a default rejected route, the null pointer would be
		 * passed to looutput, and the kernel would hang.
		 * The following last resort would prevent such disaster.
		 */
		if (origifp == NULL)
			origifp = ifp;
	} else
		origifp = ifp;
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_EMBED(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;

d748 13
d821 1
a821 1
		error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
d909 1
a909 1
			error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
@


1.160
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.159 2014/09/27 12:26:16 mpi Exp $	*/
d1232 2
a1233 2
			ro_pmtu->ro_rt = rtalloc1(sin6tosa(&ro_pmtu->ro_dst),
			    RT_REPORT, ro_pmtu->ro_tableid);
d2486 2
a2487 2
			ro.ro_rt = rtalloc1(sin6tosa(&ro.ro_dst),
			    RT_REPORT, ro.ro_tableid);
@


1.159
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.158 2014/07/22 11:06:10 mpi Exp $	*/
d961 2
a962 2
	if (ro == &ip6route && ro->ro_rt) { /* brace necessary for RTFREE */
		RTFREE(ro->ro_rt);
d964 1
a964 1
		RTFREE(ro_pmtu->ro_rt);
d1222 1
a1222 1
			RTFREE(ro_pmtu->ro_rt);
d2259 1
a2259 1
			RTFREE(pktopt->ip6po_nextroute.ro_rt);
d2281 1
a2281 1
			RTFREE(pktopt->ip6po_route.ro_rt);
@


1.158
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.157 2014/07/12 18:44:23 tedu Exp $	*/
d1232 2
a1233 1
			rtalloc((struct route *)ro_pmtu);
d2486 2
a2487 1
			rtalloc((struct route *)&ro);
@


1.157
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.156 2014/04/21 11:10:54 henning Exp $	*/
a80 1
#include <netinet/in_systm.h>
@


1.156
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.155 2014/04/20 16:48:22 naddy Exp $	*/
d2100 1
a2100 1
		free(opt, M_IP6OPT);
d2110 1
a2110 1
		free(opt, M_IP6OPT);
d2250 1
a2250 1
			free(pktopt->ip6po_pktinfo, M_IP6OPT);
d2263 1
a2263 1
			free(pktopt->ip6po_nexthop, M_IP6OPT);
d2268 1
a2268 1
			free(pktopt->ip6po_hbh, M_IP6OPT);
d2273 1
a2273 1
			free(pktopt->ip6po_dest1, M_IP6OPT);
d2278 1
a2278 1
			free(pktopt->ip6po_rhinfo.ip6po_rhi_rthdr, M_IP6OPT);
d2287 1
a2287 1
			free(pktopt->ip6po_dest2, M_IP6OPT);
d2344 1
a2344 1
	free(pktopt, M_IP6OPT);
d2620 1
a2620 1
		free(*im6op, M_IPMOPTS);
d2687 1
a2687 1
	free(im6o, M_IPMOPTS);
@


1.155
log
@move in6_cksum_phdr from in6.h to ip6_output.c to mirror in_cksum_phdr
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.154 2014/04/14 09:06:42 mpi Exp $	*/
d1224 1
a1224 1
			ro_pmtu->ro_rt = (struct rtentry *)NULL;
@


1.154
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.153 2014/01/23 23:51:29 henning Exp $	*/
d135 3
d3206 37
@


1.153
log
@since the cksum rewrite the counters for hardware checksummed packets
are are lie, since the software engine emulates hardware offloading
and that is later indistinguishable. so kill the hw cksummed counters.
introduce software checksummed packet counters instead.
tcp/udp handles ip & ipvshit, ip cksum covered, 6 has no ip layer cksum.
as before we still have a miscounting bug for inbound with pf on, to be
fixed in the next step.
found by, prodding & ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.151 2014/01/22 14:27:20 naddy Exp $	*/
d499 1
a499 1
		tdb = gettdb(rtable_l2(m->m_pkthdr.rdomain),
d547 1
a547 1
	ro->ro_tableid = m->m_pkthdr.rdomain;
d549 1
a549 1
	    &rt, m->m_pkthdr.rdomain)) != 0) {
d2478 1
a2478 1
			ro.ro_tableid = m->m_pkthdr.rdomain;
@


1.152
log
@put the in{,6}_delayed_cksum() and in{,6}_proto_cksum_out() prototypes
into consistent locations; ok henning@@
@
text
@d87 5
d3271 1
d3278 1
@


1.151
log
@Split the checksum calculation for IPv6 like for IPv4:
Always calculate the pseudo-header checksum.
Complete the checksum if hardware offload is not available.

Parts originally from NetBSD; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.150 2014/01/21 10:18:26 mpi Exp $	*/
a130 1
void in6_proto_cksum_out(struct mbuf *, struct ifnet *);
@


1.150
log
@Do not clean the multicast records of an interface when it is destroyed
(unplugged).  Even if it makes no sense to keep them around if the
interface is no more, we cannot safely remove them since pcb multicast
options might keep a pointer to them.

Fixes a user after free introduced by the multicast address linking
rewrite and reported by Alexey Suslikov, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.149 2014/01/13 23:03:52 bluhm Exp $	*/
d3214 1
a3214 1
	csum = (u_int16_t)(in6_cksum(m, nxt, offset, m->m_pkthdr.len - offset));
d3241 23
@


1.149
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.148 2013/10/23 19:57:50 deraadt Exp $	*/
d2517 1
a2517 1
			if (imm->i6mm_maddr->in6m_ifp == ifp &&
d2581 2
a2582 1
			if ((ifp == NULL || imm->i6mm_maddr->in6m_ifp == ifp) &&
@


1.148
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.147 2013/10/21 12:40:39 deraadt Exp $	*/
d162 1
a162 1
	struct in6_ifaddr *ia = NULL;
d570 1
a570 1
		ia = ifatoia6(rt->rt_ifa);
d584 2
a585 2
	if (ia != NULL && ia->ia_ifp)
		origifp = ia->ia_ifp;
@


1.147
log
@pretty up a disgusting chunk
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.146 2013/10/21 08:44:13 phessler Exp $	*/
d2037 1
a2037 1
				inp->in6p_cksum = optval;
d2044 1
a2044 1
				optval = inp->in6p_cksum;
@


1.146
log
@Enable IPv6 routing domain support

Started by claudio@@ for IPv4, lots of heavy work by sperreault@@

My part started at s2k11, continued at n2k12, g2k12, c2k12 and n2k13.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.145 2013/10/20 13:44:24 henning Exp $	*/
a1302 1
			{
d1304 1
a1304 1
						    m, so);
a1305 1
			}
@


1.145
log
@no need to make the icmp cksum "offloading" case special insofar that the
cksum needs to be 0'd before, pf does that now (just like in the tcp/udp
case) and nothing else uses the icmp "offloading" yet.
with & ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.143 2013/07/31 15:41:52 mikeb Exp $	*/
d73 1
d543 1
d1221 1
d1285 1
a1286 1
	struct proc *p = curproc; /* XXX */
d1291 1
d1704 20
d1975 5
d2476 1
@


1.144
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@a3184 7

	if (nxt == IPPROTO_ICMPV6) {
		struct icmp6_hdr *icmp6;
		icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + offset);
		icmp6->icmp6_cksum = 0;
	}

@


1.143
log
@Move bridge_broadcast and subsequently all IPsec SPD lookup code out
of the IPL_NET.  pf_test should be no longer called under IPL_NET as
well.  The problem became evident after the related issue was brought
up by David Hill <dhill at mindcry ! org>.

With input from and OK mpi.  Tested by David and me.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.142 2013/07/04 19:10:41 sf Exp $	*/
a79 1
#include <netinet/in_var.h>
d86 1
@


1.142
log
@format string fixes: size_t and uint16_t

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.141 2013/06/26 09:12:40 henning Exp $	*/
a175 1
	int s;
a217 6
	 * splnet is chosen over splsoftnet because we are not allowed to
	 * lower the level, and udp6_output calls us in splnet(). XXX check
	 */
	s = splnet();

	/*
a240 2
	        splx(s);

a273 1
				splx(s);
a282 1
	        splx(s);
a488 2
	        s = splnet();

a496 1
			splx(s);
a505 1
			splx(s);
d510 1
a510 2
		if (m == NULL) {
			splx(s);
a511 1
		}
a532 1
		splx(s);
@


1.141
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.140 2013/05/31 15:04:24 bluhm Exp $	*/
d235 1
a235 1
			panic("ip6_output: tag of length %d (should be %d",
@


1.140
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.139 2013/04/11 12:06:25 mpi Exp $	*/
d129 2
d538 1
d814 1
d3188 65
@


1.139
log
@Remove the extern keyword from function declarations, document
sysctl declarations, move variables and functions used in only
one place in their corresponding file. No functional change.

No objection from markus@@, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.138 2013/04/09 08:35:38 mpi Exp $	*/
d464 1
a464 1
	dst = (struct sockaddr_in6 *)&ro->ro_dst;
d609 1
a609 1
			dst = (struct sockaddr_in6 *)opt->ip6po_nexthop;
d611 1
a611 1
			dst = (struct sockaddr_in6 *)rt->rt_gateway;
d858 1
a858 1
		pfctlinput2(PRC_MSGSIZE, (struct sockaddr *)&ro_pmtu->ro_dst,
d908 1
a908 1
		pfctlinput2(PRC_MSGSIZE, (struct sockaddr *)&ro_pmtu->ro_dst,
d1223 2
a1224 2
		struct sockaddr_in6 *sa6_dst =
		    (struct sockaddr_in6 *)&ro_pmtu->ro_dst;
d2461 1
a2461 1
			dst = (struct sockaddr_in6 *)&ro.ro_dst;
d3142 1
a3142 1
	(void)looutput(ifp, copym, (struct sockaddr *)dst, NULL);
@


1.138
log
@Remove read-only ipsec variables and directly use defines instead.

ok mikeb@@, markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.137 2013/03/28 16:45:16 tedu Exp $	*/
a103 2

extern u_int8_t get_sa_require(struct inpcb *);
@


1.137
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.136 2013/03/28 00:32:11 bluhm Exp $	*/
a105 5

extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
extern int ipsec_ipcomp_default_level;
d1677 1
a1677 1
				        if (optval < ipsec_auth_default_level &&
d1686 1
a1686 1
				        if (optval < ipsec_esp_trans_default_level &&
d1695 1
a1695 1
				        if (optval < ipsec_esp_network_default_level &&
d1704 1
a1704 1
				        if (optval < ipsec_ipcomp_default_level &&
@


1.136
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.135 2013/03/20 10:34:12 mpi Exp $	*/
a73 1
#include <sys/proc.h>
@


1.135
log
@Introduce if_get() to retrieve an interface descriptor pointer given
an interface index and replace all the redondant checks and accesses
to a global array by a call to this function.

With imputs from and ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.134 2013/03/14 11:18:37 mpi Exp $	*/
a2118 1
#define sin6tosa(sin6)	((struct sockaddr *)(sin6)) /* XXX */
@


1.134
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.133 2013/03/04 14:42:25 bluhm Exp $	*/
d745 1
a745 1
			origifp = ifindex2ifnet[ntohs(ip6->ip6_src.s6_addr16[1])];
d747 1
a747 1
			origifp = ifindex2ifnet[ntohs(ip6->ip6_dst.s6_addr16[1])];
d2383 2
a2384 2
			if (ifindex < 0 || if_indexlim <= ifindex ||
			    !ifindex2ifnet[ifindex]) {
d2388 1
a2388 3
			ifp = ifindex2ifnet[ifindex];
			if (ifp == NULL ||
			    (ifp->if_flags & IFF_MULTICAST) == 0) {
d2485 2
a2486 3
			if (mreq->ipv6mr_interface < 0 ||
			    if_indexlim <= mreq->ipv6mr_interface ||
			    !ifindex2ifnet[mreq->ipv6mr_interface]) {
a2489 1
			ifp = ifindex2ifnet[mreq->ipv6mr_interface];
d2557 2
a2558 3
			if (mreq->ipv6mr_interface < 0 ||
			    if_indexlim <= mreq->ipv6mr_interface ||
			    !ifindex2ifnet[mreq->ipv6mr_interface]) {
a2561 1
			ifp = ifindex2ifnet[mreq->ipv6mr_interface];
a2823 5
		/* validate the interface index if specified. */
		if (pktinfo->ipi6_ifindex >= if_indexlim ||
		    pktinfo->ipi6_ifindex < 0) {
			 return (ENXIO);
		}
d2825 1
a2825 1
			ifp = ifindex2ifnet[pktinfo->ipi6_ifindex];
d2913 1
a2913 3
				if (sa6->sin6_scope_id < 0 ||
				    if_indexlim <= sa6->sin6_scope_id ||
				    !ifindex2ifnet[sa6->sin6_scope_id])
@


1.133
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.132 2012/11/06 12:32:42 henning Exp $	*/
a1349 1
			case IPV6_FAITH:
a1462 4
				case IPV6_FAITH:
					OPTSET(IN6P_FAITH);
					break;

a1762 1
			case IPV6_FAITH:
a1799 4
					break;

				case IPV6_FAITH:
					optval = OPTBIT(IN6P_FAITH);
@


1.132
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.131 2012/11/05 21:49:15 claudio Exp $	*/
d591 1
a591 1
		ia = (struct in6_ifaddr *)(rt->rt_ifa);
@


1.131
log
@Make sure that in[6]_proto_cksum_out() is called unconditinally and not
inside the NPF block. Fixes checksum issues seen on ramdisk kernels.
Initial diff by naddy@@, tested and OK by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.130 2012/11/02 13:14:05 henning Exp $	*/
a136 2
void in6_delayed_cksum(struct mbuf *, u_int8_t);
void in6_proto_cksum_out(struct mbuf *, struct ifnet *);
a543 1
		in6_proto_cksum_out(m, encif);
a818 1
	in6_proto_cksum_out(m, ifp);
a3215 59
}

/*
 * Process a delayed payload checksum calculation.
 */
void
in6_delayed_cksum(struct mbuf *m, u_int8_t nxt)
{
	int nxtp, offset;
	u_int16_t csum;

	offset = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxtp); 
	if (offset <= 0 || nxtp != nxt)
		/* If the desired next protocol isn't found, punt. */
		return;

	csum = (u_int16_t)(in6_cksum(m, nxt, offset, m->m_pkthdr.len - offset));

	switch (nxt) {
	case IPPROTO_TCP:
		offset += offsetof(struct tcphdr, th_sum);
		break;

	case IPPROTO_UDP:
		offset += offsetof(struct udphdr, uh_sum);
		if (csum == 0)
			csum = 0xffff;
		break;

	case IPPROTO_ICMPV6:
		offset += offsetof(struct icmp6_hdr, icmp6_cksum);
		break;
	}

	if ((offset + sizeof(u_int16_t)) > m->m_len)
		m_copyback(m, offset, sizeof(csum), &csum, M_NOWAIT);
	else
		*(u_int16_t *)(mtod(m, caddr_t) + offset) = csum;
}

void
in6_proto_cksum_out(struct mbuf *m, struct ifnet *ifp)
{
	if (m->m_pkthdr.csum_flags & M_TCP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_TCPv6) ||
		    ifp->if_bridgeport != NULL) {
			in6_delayed_cksum(m, IPPROTO_TCP);
			m->m_pkthdr.csum_flags &= ~M_TCP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_UDP_CSUM_OUT) {
		if (!ifp || !(ifp->if_capabilities & IFCAP_CSUM_UDPv6) ||
		    ifp->if_bridgeport != NULL) {
			in6_delayed_cksum(m, IPPROTO_UDP);
			m->m_pkthdr.csum_flags &= ~M_UDP_CSUM_OUT; /* Clear */
		}
	} else if (m->m_pkthdr.csum_flags & M_ICMP_CSUM_OUT) {
		in6_delayed_cksum(m, IPPROTO_ICMPV6);
		m->m_pkthdr.csum_flags &= ~M_ICMP_CSUM_OUT; /* Clear */
	}
@


1.130
log
@unbreak ramdisks, we need to include tcp/udp.h unconditionally now and not
dependent on ipsec.
puzzled how this went by since I did run full mkrs... pbly lost in my forest
of trees :(
report Amit Kulkarni <amitkulz at gmail.com>, fix me, ok kettenis beck krw
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.129 2012/11/01 07:55:56 henning Exp $	*/
a536 1
		in6_proto_cksum_out(m, encif);
d546 1
a808 1
	in6_proto_cksum_out(m, ifp);
d822 1
@


1.129
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.127 2012/09/20 10:25:03 blambert Exp $	*/
d85 2
a103 2
#include <netinet/udp.h>
#include <netinet/tcp.h>
@


1.128
log
@As CMSG_ALIGN() can overflow the integer value, do the length check
with and without alignment.
Bug found by Clement Lecigne <clemun AT gmail DOT com>
OK claudio@@
@
text
@d137 2
d537 1
d809 1
d3220 59
@


1.127
log
@spltdb() was really just #define'd to be splsoftnet(); replace the former
with the latter

no change in md5 checksum of generated files

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.126 2012/09/17 20:01:26 yasuoka Exp $	*/
d2738 1
a2738 1
		if (cm->cmsg_len < CMSG_LEN(0) ||
@


1.126
log
@add IPV6_RECVDSTPORT socket option, which enables us to get original
(= before divert) destination port of a UDP packet.  The way to use
this option is same as IP_RECVDSTPORT.

from UMEZAWA Takeshi
tweaks from jmc; ok henning bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.125 2012/07/16 18:05:36 markus Exp $	*/
d225 1
a225 1
	 * splnet is chosen over spltdb because we are not allowed to
d1656 1
a1656 1
				s = spltdb();
d1933 1
a1933 1
				s = spltdb();
@


1.125
log
@add IP_IPSECFLOWINFO option to sendmsg() and recvmsg(), so npppd(4)
can use this to select the IPsec tunnel for sending L2TP packets.
this fixes Windows (always binding to 1701) and Android clients
(negotiating wildcard flows); feedback mpf@@ and yasuoka@@;
ok henning@@ and yasuoka@@; ok jmc@@ for the manpage
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.124 2012/04/13 09:38:32 deraadt Exp $	*/
d1359 1
d1508 3
d1773 1
d1834 4
@


1.125.2.1
log
@MFC:
As CMSG_ALIGN() can overflow the integer value, do the length check
with and without alignment.
Bug found by Clement Lecigne <clemun AT gmail DOT com>
OK claudio@@

prodded by bluhm@@
ok jasper@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.125 2012/07/16 18:05:36 markus Exp $	*/
d2729 1
a2729 1
		if (cm->cmsg_len < CMSG_LEN(0) || cm->cmsg_len > clen ||
@


1.124
log
@unneccessary casts to unsigned; ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.123 2011/11/24 17:39:55 sperreault Exp $	*/
d251 1
a251 1
		    &error, IPSP_DIRECTION_OUT, NULL, inp);
@


1.123
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.122 2011/07/04 06:54:49 claudio Exp $	*/
d1936 1
a1936 1
					    (unsigned)m->m_len);
@


1.123.2.1
log
@MFC:
As CMSG_ALIGN() can overflow the integer value, do the length check
with and without alignment.
Bug found by Clement Lecigne <clemun AT gmail DOT com>
OK claudio@@

prodded by bluhm@@
ok jasper@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.123 2011/11/24 17:39:55 sperreault Exp $	*/
d2729 1
a2729 1
		if (cm->cmsg_len < CMSG_LEN(0) || cm->cmsg_len > clen ||
@


1.122
log
@Bye bye pf_test6(). Only one pf_test function for both IPv4 and v6.
The functions were 95% identical anyway. While there use struct pf_addr
in struct pf_divert instead of some union which is the same.
OK bluhm@@ mcbride@@ and most probably henning@@ as well
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.121 2011/05/02 22:17:28 chl Exp $	*/
d566 1
a566 1
	    &rt)) != 0) {
@


1.121
log
@Fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok henning@@ claudio@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.120 2011/04/05 11:48:28 blambert Exp $	*/
d525 1
a525 1
		    pf_test6(PF_OUT, encif, &m, NULL) != PF_PASS) {
d799 1
a799 1
	if (pf_test6(PF_OUT, ifp, &m, NULL) != PF_PASS) {
@


1.120
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.119 2011/03/22 23:13:01 bluhm Exp $	*/
d2302 1
a2302 1
		if (dst->ip6po_pktinfo == NULL && canwait == M_NOWAIT)
d2309 1
a2309 1
		if (dst->ip6po_nexthop == NULL && canwait == M_NOWAIT)
@


1.119
log
@Extract the new function ip6_fragment() from ip6_output() to make
it reusable by pf.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.118 2010/09/23 04:45:15 yasuoka Exp $	*/
d1026 1
a1026 1
		if ((error = m_dup_pkthdr(m, m0)) != 0)
@


1.118
log
@add a new IP level socket option IP_PIPEX.  This option is used for L2TP
support by pipex.
OK henning@@, "Carry on" blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.117 2010/08/07 03:50:02 krw Exp $	*/
d159 1
a159 1
	struct ip6_hdr *ip6, *mhip6;
d162 1
a162 1
	int hlen, tlen, len, off;
a895 3
		struct mbuf **mnext, *m_frgpart;
		struct ip6_frag *ip6f;
		u_int32_t id = htonl(ip6_randomid());
a919 9
		len = (mtu - hlen - sizeof(struct ip6_frag)) & ~7;
		if (len < 8) {
			error = EMSGSIZE;
			in6_ifstat_inc(ifp, ifs6_out_fragfail);
			goto bad;
		}

		mnext = &m->m_nextpkt;

a937 5
		/*
		 * Loop through length of segment after first fragment,
		 * make new header and copy data of each part and link onto
		 * chain.
		 */
d939 1
a939 2
		for (off = hlen; off < tlen; off += len) {
			struct mbuf *mlast;
d941 10
a950 41
			MGETHDR(m, M_DONTWAIT, MT_HEADER);
			if (!m) {
				error = ENOBUFS;
				ip6stat.ip6s_odropped++;
				goto sendorfree;
			}
			m->m_pkthdr.rcvif = NULL;
			m->m_flags = m0->m_flags & M_COPYFLAGS;
			*mnext = m;
			mnext = &m->m_nextpkt;
			m->m_data += max_linkhdr;
			mhip6 = mtod(m, struct ip6_hdr *);
			*mhip6 = *ip6;
			m->m_len = sizeof(*mhip6);
			error = ip6_insertfraghdr(m0, m, hlen, &ip6f);
			if (error) {
				ip6stat.ip6s_odropped++;
				goto sendorfree;
			}
			ip6f->ip6f_offlg = htons((u_int16_t)((off - hlen) & ~7));
			if (off + len >= tlen)
				len = tlen - off;
			else
				ip6f->ip6f_offlg |= IP6F_MORE_FRAG;
			mhip6->ip6_plen = htons((u_int16_t)(len + hlen +
			    sizeof(*ip6f) - sizeof(struct ip6_hdr)));
			if ((m_frgpart = m_copy(m0, off, len)) == 0) {
				error = ENOBUFS;
				ip6stat.ip6s_odropped++;
				goto sendorfree;
			}
			for (mlast = m; mlast->m_next; mlast = mlast->m_next)
				;
			mlast->m_next = m_frgpart;
			m->m_pkthdr.len = len + hlen + sizeof(*ip6f);
			m->m_pkthdr.rcvif = (struct ifnet *)0;
			ip6f->ip6f_reserved = 0;
			ip6f->ip6f_ident = id;
			ip6f->ip6f_nxt = nextproto;
			ip6stat.ip6s_ofragments++;
			in6_ifstat_inc(ifp, ifs6_out_fragcreat);
a951 2

		in6_ifstat_inc(ifp, ifs6_out_fragok);
a956 1
sendorfree:
d964 2
d992 61
@


1.117
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.116 2010/07/09 16:58:06 reyk Exp $	*/
d1712 6
d1962 5
@


1.116
log
@Add support for using IPsec in multiple rdomains.

This allows to run isakmpd/iked/ipsecctl in multiple rdomains
independently (with "route exec"); the kernel will pickup the rdomain
from the process context of the pfkey socket and load the flows and
SAs into the matching rdomain encap routing table.  The network stack
also needs to pass the rdomain to the ipsec stack to lookup the
correct rdomain that belongs to an interface/mbuf/... You can now run
individual IPsec configs per rdomain or create IPsec VPNs between
multiple rdomains on the same machine ;).  Note that a primary enc(4)
in addition to enc0 interface is required per rdomain, eg. enc1 rdomain 1.

Test by some people, mostly on existing "rdomain 0" setups.  Was in
snaps for some days and people didn't complain.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.115 2010/07/08 19:42:46 jsg Exp $	*/
d2196 1
a2196 1
		panic("ip6_getpcbopt: unexpected option\n");
@


1.115
log
@remove some unused netinet6 code
ok stsp@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.114 2010/07/01 02:09:45 reyk Exp $	*/
d245 1
a245 1
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
d286 1
d513 2
a514 1
		tdb = gettdb(sspi, &sdst, sproto);
d523 2
a524 1
		if ((encif = enc_getif(0, tdb->tdb_tap)) == NULL ||
d1642 2
a1643 2
				tdb = gettdb(tdbip->spi, &tdbip->dst,
				    tdbip->proto);
d1914 2
@


1.114
log
@Allow to specify an alternative enc(4) interface for an SA.  All
traffic for this SA will appear on the specified enc interface instead
of enc0 and can be filtered and monitored separately. This will allow
to group individual ipsec policies to virtual interfaces and
simplifies monitoring and pf filtering with many ipsec policies a lot.

This diff includes the following changes:
- Store the enc interface unit (default 0) in the TDB of an SA and pass
it to the enc_getif() lookup when running the bpf or pf_test() handlers.
- Add the pfkey SADB_X_EXT_TAP extension to communicate the encX
interface unit for a specified SA between userland and kernel.
- Update enc(4) again to use an allocate array instead of the TAILQ to
lookup the matching enc interface in enc_getif() quickly.

Discussed with many, tested by a few, will need more testing & review.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.113 2010/06/29 21:28:38 reyk Exp $	*/
a3167 23
}

/*
 * Compute IPv6 extension header length.
 */
int
ip6_optlen(struct inpcb *inp)
{
	int len;

	if (!inp->inp_outputopts6)
		return 0;

	len = 0;
#define elen(x) \
    (((struct ip6_ext *)(x)) ? (((struct ip6_ext *)(x))->ip6e_len + 1) << 3 : 0)

	len += elen(inp->inp_outputopts6->ip6po_hbh);
	len += elen(inp->inp_outputopts6->ip6po_dest1);
	len += elen(inp->inp_outputopts6->ip6po_rthdr);
	len += elen(inp->inp_outputopts6->ip6po_dest2);
	return len;
#undef elen
@


1.113
log
@Replace enc(4) with a new implementation as a cloner device.  We still
create enc0 by default, but it is possible to add additional enc
interfaces.  This will be used later to allow alternative encs per
policy or to have an enc per rdomain when IPsec becomes rdomain-aware.

manpage bits ok jmc@@
input from henning@@ deraadt@@ toby@@ naddy@@
ok henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.111 2010/02/08 12:16:02 jsing Exp $	*/
d507 13
d521 1
a521 1
		if ((encif = enc_getif(0)) == NULL ||
a540 12
		/*
		 * XXX what should we do if ip6_hlim == 0 and the
		 * packet gets tunneled?
		 */

		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			splx(s);
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}
@


1.112
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d183 3
d508 2
a509 1
		if (pf_test6(PF_OUT, &encif[0].sc_if, &m, NULL) != PF_PASS) {
@


1.111
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.110 2009/11/25 07:37:29 mpf Exp $	*/
d1221 1
a1221 1
			bzero(sa6_dst, sizeof(*sa6_dst));
d2440 1
a2440 1
			ro.ro_rt = NULL;
a2441 1
			bzero(dst, sizeof(*dst));
@


1.110
log
@Small cleanup for setsockopt IPSEC6_OUTSA:
No need to wrap input validation inside spltdb().
Simplify code by using a break instead of an else-block.
OK guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.109 2009/11/20 09:02:21 guenther Exp $	*/
d122 4
a125 4
static int ip6_pcbopt(int, u_char *, int, struct ip6_pktopts **, int, int);
static int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *, struct socket *);
static int ip6_getpcbopt(struct ip6_pktopts *, int, struct mbuf **);
static int ip6_setpktopt(int, u_char *, int, struct ip6_pktopts *, int, int,
d127 4
a130 4
static int ip6_setmoptions(int, struct ip6_moptions **, struct mbuf *);
static int ip6_getmoptions(int, struct ip6_moptions *, struct mbuf **);
static int ip6_copyexthdr(struct mbuf **, caddr_t, int);
static int ip6_insertfraghdr(struct mbuf *, struct mbuf *, int,
d132 3
a134 3
static int ip6_insert_jumboopt(struct ip6_exthdrs *, u_int32_t);
static int ip6_splithdr(struct mbuf *, struct ip6_exthdrs *);
static int ip6_getpmtu(struct route_in6 *, struct route_in6 *,
d136 1
a136 1
static int copypktopts(struct ip6_pktopts *, struct ip6_pktopts *, int);
d156 2
a157 2
	int flags, struct ip6_moptions *im6o, struct ifnet **ifpp, 
	struct inpcb *inp)
d1036 1
a1036 1
static int
d1066 1
a1066 1
static int
d1161 1
a1161 1
static int
d1163 1
a1163 1
	struct ip6_frag **frghdrp)
d1202 1
a1202 1
static int
d1204 1
a1204 2
	struct ifnet *ifp, struct in6_addr *dst, u_long *mtup, 
	int *alwaysfragp)
d1278 1
a1278 1
	struct mbuf **mp)
d1964 1
a1964 1
	struct mbuf **mp)
d2037 1
a2037 1
static int
d2089 1
a2089 1
static int
d2091 1
a2091 1
	int priv, int uproto)
d2105 1
a2105 1
static int
d2261 1
a2261 1
static int
d2308 1
a2308 1
static int
d2593 1
a2593 1
static int
d2658 1
a2658 1
	struct ip6_pktopts *stickyopt, int priv, int uproto)
d2724 1
a2724 1
static int
d2726 1
a2726 1
	int priv, int sticky, int cmsg, int uproto)
d3140 1
a3140 1
static int
@


1.109
log
@NULL dereference in IPV6_PORTRANGE and IP_IPSEC_*, found by Clement LECIGNE,
localhost DoS everywhere.  To help minimize further issues, make the
mbuf != NULL test explicit instead of implicit in a length test.
Suggestions and initial work by mpf@@ and miod@@
ok henning@@, mpf@@, claudio@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.108 2009/10/28 21:03:17 deraadt Exp $	*/
d1628 2
a1629 2
				s = spltdb();
				if (m == 0 || m->m_len != sizeof(struct tdb_ident)) {
d1631 1
a1631 8
				} else {
					tdbip = mtod(m, struct tdb_ident *);
					tdb = gettdb(tdbip->spi, &tdbip->dst,
					    tdbip->proto);
					if (tdb == NULL)
						error = ESRCH;
					else
						tdb_add_inp(tdb, inp, 0);
d1633 8
@


1.108
log
@*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
copy of the ipv4 bug, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.107 2009/10/06 21:21:48 claudio Exp $	*/
a1285 1
	int optlen;
a1292 1
	optlen = m ? m->m_len : 0;
d1341 1
a1341 1
				if (optlen != sizeof(int)) {
d1495 1
a1495 1
				if (optlen != sizeof(optval)) {
d1517 1
a1517 1
				if (optlen != sizeof(int)) {
d1596 4
d1966 1
a1966 1
	int error = 0, optval, optlen;
a1970 2
	optlen = m ? m->m_len : 0;

d1989 1
a1989 1
			if (optlen != sizeof(int)) {
@


1.107
log
@Redo the route lookup in the output (and IPv6 forwarding) path if the
destination of a packet was changed by pf. This allows for some evil
games with rdr-to or nat-to but is mostly needed for better rdomain/rtable
support. This is a first step and more work and cleanup is needed.

Here a list of what works and what does not (needs a patched pfctl):
pass out rdr-to:
from local rdr-to local addr works (if state tracking on lo0 is done)
from remote rdr-to local addr does NOT work
from local rdr-to remote works
from remote rdr-to remote works

pass in nat-to:
from remote nat-to local addr does NOT work
from remote nat-to non-local addr works
non-local is an IP that is routed to the FW but is not assigned on the FW.
The non working cases need some magic to correctly rewrite the incomming
packet since the rewriting would happen outbound which is too late.

"time to get it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.106 2008/10/22 14:36:08 markus Exp $	*/
d1917 1
@


1.106
log
@filter ipv6 ipsec packets on enc0 (in and out), similar to ipv4;
ok bluhm, fries, mpf; fixes pr 4188
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.105 2008/09/03 08:41:57 mpf Exp $	*/
d456 4
d516 7
d799 11
a3198 1

@


1.106.2.1
log
@MFC rev. 1.108 of ip6_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
copy of the ipv4 bug, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.106 2008/10/22 14:36:08 markus Exp $	*/
a1894 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.106.6.1
log
@MFC rev. 1.108 of ip6_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
copy of the ipv4 bug, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.106 2008/10/22 14:36:08 markus Exp $	*/
a1894 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.105
log
@Remove dead code: ip6_copypktopts() is not used anywhere.
OK deraadt@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.104 2008/08/08 17:49:21 bluhm Exp $	*/
d77 1
d500 13
@


1.104
log
@Do not latch the IPSec tdb to the inpcb unconditionally.  This has
been moved to the protocol layer from ip_output at 2002/05/31.  The
IPv6 part has been forgotten so packets could get encrypted
unintentionally.
ok hshoexer markus
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.103 2008/07/30 15:07:40 canacar Exp $	*/
a2255 19

struct ip6_pktopts *
ip6_copypktopts(struct ip6_pktopts *src, int canwait)
{
	int error;
	struct ip6_pktopts *dst;

	dst = malloc(sizeof(*dst), M_IP6OPT, canwait);
	if (dst == NULL && canwait == M_NOWAIT)
		return (NULL);
	ip6_initpktopts(dst);

	if ((error = copypktopts(dst, src, canwait)) != 0) {
		free(dst, M_IP6OPT);
		return (NULL);
	}

	return (dst);
}
@


1.103
log
@Call ip6_clearpktopts() on error in copypktopts() instead of freeing
every field individually.
ok claudio@@ markus@@ henning@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.102 2008/06/11 19:00:50 mcbride Exp $	*/
a510 4

		/* Latch to PCB */
		if (inp)
			tdb_add_inp(tdb, inp, 0);
@


1.103.2.1
log
@MFC rev. 1.108 of ip6_output.c by deraadt@@:

*NULL store in IP_AUTH_LEVEL, IP_ESP_TRANS_LEVEL, IP_ESP_NETWORK_LEVEL,
IP_IPCOMP_LEVEL found by Clement LECIGNE, localhost root exploitable on
userland/kernel shared vm machines (ie. i386, amd64, arm, sparc (but not
sparc64), sh, ...) on OpenBSD 4.3 or older
copy of the ipv4 bug, spotted by claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.103 2008/07/30 15:07:40 canacar Exp $	*/
a1884 1
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.102
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.101 2008/06/09 22:47:42 djm Exp $	*/
d2256 1
a2256 7
	if (dst->ip6po_pktinfo) free(dst->ip6po_pktinfo, M_IP6OPT);
	if (dst->ip6po_nexthop) free(dst->ip6po_nexthop, M_IP6OPT);
	if (dst->ip6po_hbh) free(dst->ip6po_hbh, M_IP6OPT);
	if (dst->ip6po_dest1) free(dst->ip6po_dest1, M_IP6OPT);
	if (dst->ip6po_dest2) free(dst->ip6po_dest2, M_IP6OPT);
	if (dst->ip6po_rthdr) free(dst->ip6po_rthdr, M_IP6OPT);

@


1.101
log
@Introduce a facility to generate unpredictable 32 bit numbers with
near maximal (2^32) cycle times. These are useful for network
IDs in cases where there are negative consequences to ID prediction
and/or reuse.

Use the idgen32() functions to generate IPv6 IDs and NFS client/server
XIDs.

Pseudorandom permutation code in crypto/idgen.c based on public
domain skip32.c from Greg Rose.

feedback & ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.100 2008/03/31 21:15:20 deraadt Exp $	*/
d150 2
d154 3
a156 8
ip6_output(m0, opt, ro, flags, im6o, ifpp, inp)
	struct mbuf *m0;
	struct ip6_pktopts *opt;
	struct route_in6 *ro;
	int flags;
	struct ip6_moptions *im6o;
	struct ifnet **ifpp;		/* XXX: just for statistics */
	struct inpcb *inp;
d1005 1
a1005 4
ip6_copyexthdr(mp, hdr, hlen)
	struct mbuf **mp;
	caddr_t hdr;
	int hlen;
d1035 1
a1035 3
ip6_insert_jumboopt(exthdrs, plen)
	struct ip6_exthdrs *exthdrs;
	u_int32_t plen;
d1130 2
a1131 4
ip6_insertfraghdr(m0, m, hlen, frghdrp)
	struct mbuf *m0, *m;
	int hlen;
	struct ip6_frag **frghdrp;
d1171 3
a1173 6
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup, alwaysfragp)
	struct route_in6 *ro_pmtu, *ro;
	struct ifnet *ifp;
	struct in6_addr *dst;
	u_long *mtup;
	int *alwaysfragp;
d1246 2
a1247 5
ip6_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d1928 2
a1929 5
ip6_raw_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d2005 1
a2005 4
ip6_pcbopts(pktopt, m, so)
	struct ip6_pktopts **pktopt;
	struct mbuf *m;
	struct socket *so;
d2046 1
a2046 2
ip6_initpktopts(opt)
	struct ip6_pktopts *opt;
d2057 2
a2058 5
ip6_pcbopt(optname, buf, len, pktopt, priv, uproto)
	int optname, len, priv;
	u_char *buf;
	struct ip6_pktopts **pktopt;
	int uproto;
d2073 1
a2073 4
ip6_getpcbopt(pktopt, optname, mp)
	struct ip6_pktopts *pktopt;
	int optname;
	struct mbuf **mp;
d2171 1
a2171 3
ip6_clearpktopts(pktopt, optname)
	struct ip6_pktopts *pktopt;
	int optname;
d2229 1
a2229 3
copypktopts(dst, src, canwait)
	struct ip6_pktopts *dst, *src;
	int canwait;
d2268 1
a2268 3
ip6_copypktopts(src, canwait)
	struct ip6_pktopts *src;
	int canwait;
d2287 1
a2287 2
ip6_freepcbopts(pktopt)
	struct ip6_pktopts *pktopt;
d2301 1
a2301 4
ip6_setmoptions(optname, im6op, m)
	int optname;
	struct ip6_moptions **im6op;
	struct mbuf *m;
d2586 1
a2586 4
ip6_getmoptions(optname, im6o, mp)
	int optname;
	struct ip6_moptions *im6o;
	struct mbuf **mp;
d2630 1
a2630 2
ip6_freemoptions(im6o)
	struct ip6_moptions *im6o;
d2649 2
a2650 4
ip6_setpktopts(control, opt, stickyopt, priv, uproto)
	struct mbuf *control;
	struct ip6_pktopts *opt, *stickyopt;
	int priv, uproto;
d2717 2
a2718 4
ip6_setpktopt(optname, buf, len, opt, priv, sticky, cmsg, uproto)
	int optname, len, priv, sticky, cmsg, uproto;
	u_char *buf;
	struct ip6_pktopts *opt;
d3089 1
a3089 4
ip6_mloopback(ifp, m, dst)
	struct ifnet *ifp;
	struct mbuf *m;
	struct sockaddr_in6 *dst;
d3133 1
a3133 3
ip6_splithdr(m, exthdrs)
	struct mbuf *m;
	struct ip6_exthdrs *exthdrs;
d3162 1
a3162 2
ip6_optlen(inp)
	struct inpcb *inp;
@


1.100
log
@strictly interpret msg_controllen to be the exact total length of the
cmsg's, including alignments, ie. the sum of CMSG_SPACE()'s. any other
interpretation would be in violation of various unix specifications.
RFC3542 section 20.2 is totally and completely wrong -- it is not
allowed to over-ride the specification of msg_controllen, since the
intent is that one could mix-and-match various types of cmsg's and an
exact match is therefore required.  ok kettenis, tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.99 2007/06/01 00:52:38 henning Exp $	*/
d91 2
d137 3
d3233 13
@


1.99
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.98 2007/02/08 15:25:30 itojun Exp $	*/
d2692 1
d2694 2
d2724 4
a2727 5
	for (; control->m_len; control->m_data += CMSG_ALIGN(cm->cmsg_len),
	    control->m_len -= CMSG_ALIGN(cm->cmsg_len)) {
		int error;

		if (control->m_len < CMSG_LEN(0))
d2729 3
a2731 3

		cm = mtod(control, struct cmsghdr *);
		if (cm->cmsg_len == 0 || cm->cmsg_len > control->m_len)
d2733 6
a2738 2
		if (cm->cmsg_level != IPPROTO_IPV6)
			continue;
d2740 3
a2742 5
		error = ip6_setpktopt(cm->cmsg_type, CMSG_DATA(cm),
		    cm->cmsg_len - CMSG_LEN(0), opt, priv, 0, 1, uproto);
		if (error)
			return (error);
	}
@


1.98
log
@- AH: when computing crypto checksum for output, massage source-routing
  header.
- ipsec_input: fix mistake in IPv6 next-header chasing.
- ipsec_output: look for the position to insert AH more carefully.
- ip6_output: enable use of AH with extension headers.
  avoid tunnellinng when source-routing header is present.

ok by deraad, naddy, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.97 2006/12/10 10:16:12 miod Exp $	*/
d147 1
a147 1
ip6_output(m0, opt, ro, flags, im6o, ifpp)
d154 1
a177 1
	struct inpcb *inp;
a182 1
	inp = NULL;	/*XXX*/
d215 3
@


1.97
log
@In ip6_output(), make sure ia is initialized before it is used.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.96 2006/12/09 01:12:28 itojun Exp $	*/
a290 9

#if 1 /* XXX */
		/* if we have any extension header, we cannot perform IPsec */
		if (exthdrs.ip6e_hbh || exthdrs.ip6e_dest1 ||
		    exthdrs.ip6e_rthdr || exthdrs.ip6e_dest2) {
			error = EHOSTUNREACH;
			goto freehdrs;
		}
#endif
d515 7
a521 1
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
@


1.96
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.95 2006/12/08 21:32:12 itojun Exp $	*/
d163 1
a163 1
	struct in6_ifaddr *ia;
@


1.95
log
@leftover from interface-local multicast change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.94 2006/11/17 01:11:23 itojun Exp $	*/
d119 1
d121 3
d133 1
d156 1
a156 1
	struct ifnet *ifp, *origifp;
d160 2
a161 1
	struct sockaddr_in6 *dst;
d188 3
d203 1
d372 2
a373 1
		 * much easier.
d413 1
a413 1
	 * If there is a routing header, replace destination address field
a422 1
		finaldst = ip6->ip6_dst;
d439 6
a444 2
	if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src) &&
	    (flags & IPV6_UNSPECSRC) == 0) {
d460 1
d469 1
d471 23
a493 15
	 * If there is a cached route,
	 * check that it is to the same destination
	 * and is still up. If not, free it and try again.
	 */
	if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
	    dst->sin6_family != AF_INET6 ||
	    !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &ip6->ip6_dst))) {
		RTFREE(ro->ro_rt);
		ro->ro_rt = (struct rtentry *)0;
	}
	if (ro->ro_rt == 0) {
		bzero(dst, sizeof(*dst));
		dst->sin6_family = AF_INET6;
		dst->sin6_len = sizeof(struct sockaddr_in6);
		dst->sin6_addr = ip6->ip6_dst;
d495 1
d504 4
a507 17
		/* fill in IPv6 header which would be filled later */
		if (!IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
			if (opt && opt->ip6po_hlim != -1)
				ip6->ip6_hlim = opt->ip6po_hlim & 0xff;
		} else {
			if (im6o != NULL)
				ip6->ip6_hlim = im6o->im6o_multicast_hlim;
			else
				ip6->ip6_hlim = ip6_defmcasthlim;
			if (opt && opt->ip6po_hlim != -1)
				ip6->ip6_hlim = opt->ip6po_hlim & 0xff;

			/*
			 * XXX what should we do if ip6_hlim == 0 and the
			 * packet gets tunneled?
			 */
		}
d526 1
d531 8
a538 18
	if (!IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
		/* Unicast */

#define ifatoia6(ifa)	((struct in6_ifaddr *)(ifa))
#define sin6tosa(sin6)	((struct sockaddr *)(sin6))
		/* xxx
		 * interface selection comes here
		 * if an interface is specified from an upper layer,
		 * ifp must point it.
		 */
		if (ro->ro_rt == 0) {
			/*
			 * non-bsdi always clone routes, if parent is
			 * PRF_CLONING.
			 */
			rtalloc_mpath((struct route *)ro, NULL, 0);
		}
		if (ro->ro_rt == 0) {
d540 4
a543 3
			error = EHOSTUNREACH;
			/* XXX in6_ifstat_inc(ifp, ifs6_out_discard); */
			goto bad;
d545 19
a563 6
		ia = ifatoia6(ro->ro_rt->rt_ifa);
		ifp = ro->ro_rt->rt_ifp;
		ro->ro_rt->rt_use++;
		if (ro->ro_rt->rt_flags & RTF_GATEWAY)
			dst = (struct sockaddr_in6 *)ro->ro_rt->rt_gateway;
		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */
d565 2
d568 23
d592 2
a593 17
		/*
		 * Check if the outgoing interface conflicts with
		 * the interface specified by ifi6_ifindex (if specified).
		 * Note that loopback interface is always okay.
		 * (this may happen when we are sending a packet to one of
		 *  our own addresses.)
		 */
		if (opt && opt->ip6po_pktinfo &&
		    opt->ip6po_pktinfo->ipi6_ifindex) {
			if (!(ifp->if_flags & IFF_LOOPBACK) &&
			    ifp->if_index != opt->ip6po_pktinfo->ipi6_ifindex) {
				ip6stat.ip6s_noroute++;
				in6_ifstat_inc(ifp, ifs6_out_discard);
				error = EHOSTUNREACH;
				goto bad;
			}
		}
d595 1
a595 2
		if (opt && opt->ip6po_hlim != -1)
			ip6->ip6_hlim = opt->ip6po_hlim & 0xff;
a601 47
		/*
		 * See if the caller provided any multicast options
		 */
		ifp = NULL;
		if (im6o != NULL) {
			ip6->ip6_hlim = im6o->im6o_multicast_hlim;
			if (im6o->im6o_multicast_ifp != NULL)
				ifp = im6o->im6o_multicast_ifp;
		} else
			ip6->ip6_hlim = ip6_defmcasthlim;

		/*
		 * See if the caller provided the outgoing interface
		 * as an ancillary data.
		 * Boundary check for ifindex is assumed to be already done.
		 */
		if (opt && opt->ip6po_pktinfo && opt->ip6po_pktinfo->ipi6_ifindex)
			ifp = ifindex2ifnet[opt->ip6po_pktinfo->ipi6_ifindex];

		if (opt && opt->ip6po_hlim != -1)
			ip6->ip6_hlim = opt->ip6po_hlim & 0xff;

		/*
		 * If caller did not provide an interface lookup a
		 * default in the routing table.  This is either a
		 * default for the specified group (i.e. a host
		 * route), or a multicast default (a route for the
		 * ``net'' ff00::/8).
		 */
		if (ifp == NULL) {
			if (ro->ro_rt == 0) {
				ro->ro_rt = rtalloc1((struct sockaddr *)
				    &ro->ro_dst, 0, 0);
			}
			if (ro->ro_rt == 0) {
				ip6stat.ip6s_noroute++;
				error = EHOSTUNREACH;
				/* XXX in6_ifstat_inc(ifp, ifs6_out_discard) */
				goto bad;
			}
			ia = ifatoia6(ro->ro_rt->rt_ifa);
			ifp = ro->ro_rt->rt_ifp;
			ro->ro_rt->rt_use++;
		}

		if ((flags & IPV6_FORWARDING) == 0)
			in6_ifstat_inc(ifp, ifs6_out_request);
d615 1
a615 1
		   (im6o == NULL || im6o->im6o_multicast_loop)) {
d675 8
d687 7
d800 4
a803 1
	dontfrag = 0;
d1261 2
a1262 1
	int privileged;
d1278 1
d1284 23
a1306 6
			case IPV6_PKTOPTIONS:
				/* m is freed in ip6_pcbopts */
				return (ip6_pcbopts(&inp->inp_outputopts6,
				    m, so));
			case IPV6_HOPOPTS:
			case IPV6_DSTOPTS:
a1312 4
			case IPV6_RECVOPTS:
			case IPV6_RECVRETOPTS:
			case IPV6_RECVDSTADDR:
			case IPV6_PKTINFO:
a1313 1
			case IPV6_RTHDR:
d1315 6
d1322 1
a1322 1
			case IPV6_USE_MIN_MTU:
d1344 10
a1353 4
} while (0)
				case IPV6_RECVOPTS:
					OPTSET(IN6P_RECVOPTS);
					break;
d1355 7
a1361 2
				case IPV6_RECVRETOPTS:
					OPTSET(IN6P_RECVRETOPTS);
d1364 3
a1366 3
				case IPV6_RECVDSTADDR:
					OPTSET(IN6P_RECVDSTADDR);
					break;
d1368 11
a1378 2
				case IPV6_PKTINFO:
					OPTSET(IN6P_PKTINFO);
d1380 1
d1382 6
a1387 1
				case IPV6_HOPLIMIT:
d1391 6
a1396 1
				case IPV6_HOPOPTS:
d1400 6
a1405 1
				case IPV6_DSTOPTS:
d1409 15
a1423 1
				case IPV6_RTHDR:
d1431 9
a1439 2
				case IPV6_USE_MIN_MTU:
					OPTSET(IN6P_MINMTU);
d1443 19
a1461 1
					if (!optval)
d1463 82
d1547 16
d1564 1
d1573 2
a1574 1
					&inp->inp_moptions6, m);
d1612 1
a1612 1
						     tdbip->proto);
d1619 1
a1619 1
#endif /* IPSEC */
a1682 1

d1694 12
a1705 3
			case IPV6_OPTIONS:
			case IPV6_RETOPTS:
				error = ENOPROTOOPT;
d1708 8
a1715 9
			case IPV6_PKTOPTIONS:
				if (inp->inp_options) {
					*mp = m_copym(inp->inp_options, 0,
					    M_COPYALL, M_WAIT);
				} else {
					*mp = m_get(M_WAIT, MT_SOOPTS);
					(*mp)->m_len = 0;
				}
				break;
a1716 14
			case IPV6_HOPOPTS:
			case IPV6_DSTOPTS:
				if (!privileged) {
					error = EPERM;
					break;
				}
				/* FALLTHROUGH */
			case IPV6_UNICAST_HOPS:
			case IPV6_RECVOPTS:
			case IPV6_RECVRETOPTS:
			case IPV6_RECVDSTADDR:
			case IPV6_PKTINFO:
			case IPV6_HOPLIMIT:
			case IPV6_RTHDR:
d1720 2
a1721 1
			case IPV6_USE_MIN_MTU:
d1724 2
a1725 2
				case IPV6_UNICAST_HOPS:
					optval = inp->inp_hops;
d1728 2
a1729 4
#define OPTBIT(bit) (inp->inp_flags & bit ? 1 : 0)

				case IPV6_RECVOPTS:
					optval = OPTBIT(IN6P_RECVOPTS);
d1732 2
a1733 2
				case IPV6_RECVRETOPTS:
					optval = OPTBIT(IN6P_RECVRETOPTS);
d1736 2
a1737 2
				case IPV6_RECVDSTADDR:
					optval = OPTBIT(IN6P_RECVDSTADDR);
d1740 1
a1740 1
				case IPV6_PKTINFO:
d1744 1
a1744 1
				case IPV6_HOPLIMIT:
d1748 2
a1749 6
				case IPV6_HOPOPTS:
					optval = OPTBIT(IN6P_HOPOPTS);
					break;

				case IPV6_DSTOPTS:
					optval = OPTBIT(IN6P_DSTOPTS);
d1752 2
a1753 2
				case IPV6_RTHDR:
					optval = OPTBIT(IN6P_RTHDR);
a1766 1

d1776 48
d1825 20
a1844 2
				case IPV6_USE_MIN_MTU:
					optval = OPTBIT(IN6P_MINMTU);
d1851 12
d1869 2
a1870 1
				error = ip6_getmoptions(optname, inp->inp_moptions6, mp);
d1890 1
a1890 1
#endif /* IPSEC */
d1965 1
a1965 1
		 * XXX 2292bis says: "An attempt to set IPV6_CHECKSUM
d1967 1
a1967 1
		 * The current behavior does not meet 2292bis.
d1979 1
a1979 2
			} else if (so->so_proto->pr_protocol ==
			    IPPROTO_ICMPV6) {
d2031 3
a2033 4
	if (opt) {
		if (opt->ip6po_m)
			(void)m_free(opt->ip6po_m);
	} else
d2039 2
a2040 1
		 * Only turning off any previous options.
a2042 2
		if (m)
			(void)m_free(m);
d2049 3
a2051 2
	if ((error = ip6_setpktoptions(m, opt, priv)) != 0) {
		(void)m_free(m);
d2060 270
d2688 1
a2688 1
ip6_setpktoptions(control, opt, priv)
d2690 2
a2691 2
	struct ip6_pktopts *opt;
	int priv;
d2695 1
a2695 1
	if (control == 0 || opt == 0)
d2698 16
a2713 2
	bzero(opt, sizeof(*opt));
	opt->ip6po_hlim = -1; /* -1 means to use default hop limit */
a2721 2
	opt->ip6po_m = control;

d2724 5
d2735 52
a2786 1
		switch (cm->cmsg_type) {
d2788 42
a2829 7
			if (cm->cmsg_len != CMSG_LEN(sizeof(struct in6_pktinfo)))
				return (EINVAL);
			opt->ip6po_pktinfo = (struct in6_pktinfo *)CMSG_DATA(cm);
			if (opt->ip6po_pktinfo->ipi6_ifindex &&
			    IN6_IS_ADDR_LINKLOCAL(&opt->ip6po_pktinfo->ipi6_addr))
				opt->ip6po_pktinfo->ipi6_addr.s6_addr16[1] =
					htons(opt->ip6po_pktinfo->ipi6_ifindex);
d2831 8
a2838 2
			if (opt->ip6po_pktinfo->ipi6_ifindex >= if_indexlim ||
			    opt->ip6po_pktinfo->ipi6_ifindex < 0) {
d2840 57
a2896 5
			}
			if (opt->ip6po_pktinfo->ipi6_ifindex > 0 &&
			    !ifindex2ifnet[opt->ip6po_pktinfo->ipi6_ifindex]) {
				return (ENXIO);
			}
d2898 4
a2901 26
			/*
			 * Check if the requested source address is indeed a
			 * unicast address assigned to the node, and can be
			 * used as the packet's source address.
			 */
			if (!IN6_IS_ADDR_UNSPECIFIED(&opt->ip6po_pktinfo->ipi6_addr)) {
				struct ifaddr *ia;
				struct in6_ifaddr *ia6;
				struct sockaddr_in6 sin6;

				bzero(&sin6, sizeof(sin6));
				sin6.sin6_len = sizeof(sin6);
				sin6.sin6_family = AF_INET6;
				sin6.sin6_addr =
					opt->ip6po_pktinfo->ipi6_addr;
				ia = ifa_ifwithaddr(sin6tosa(&sin6));
				if (ia == NULL ||
				    (opt->ip6po_pktinfo->ipi6_ifindex &&
				     (ia->ifa_ifp->if_index !=
				      opt->ip6po_pktinfo->ipi6_ifindex))) {
					return (EADDRNOTAVAIL);
				}
				ia6 = (struct in6_ifaddr *)ia;
				if ((ia6->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) != 0) {
					return (EADDRNOTAVAIL);
				}
d2903 2
a2904 8
				/*
				 * Check if the requested source address is
				 * indeed a unicast address assigned to the
				 * node.
				 */
				if (IN6_IS_ADDR_MULTICAST(&opt->ip6po_pktinfo->ipi6_addr))
					return (EADDRNOTAVAIL);
			}
d2906 10
d2917 1
a2917 2
		case IPV6_HOPLIMIT:
			if (cm->cmsg_len != CMSG_LEN(sizeof(int)))
d2920 12
a2931 3
			bcopy(CMSG_DATA(cm), &opt->ip6po_hlim,
			    sizeof(opt->ip6po_hlim));
			if (opt->ip6po_hlim < -1 || opt->ip6po_hlim > 255)
d2934 27
d2962 12
a2973 3
		case IPV6_NEXTHOP:
			if (!priv)
				return (EPERM);
d2975 6
a2980 4
			/* check if cmsg_len is large enough for sa_len */
			if (cm->cmsg_len < sizeof(u_char) ||
			    cm->cmsg_len < CMSG_LEN(*CMSG_DATA(cm)))
				return (EINVAL);
d2982 2
a2983 1
			opt->ip6po_nexthop = (struct sockaddr *)CMSG_DATA(cm);
d2985 6
a2990 1
			break;
d2992 2
a2993 8
		case IPV6_HOPOPTS:
			if (cm->cmsg_len < CMSG_LEN(sizeof(struct ip6_hbh)))
				return (EINVAL);
			opt->ip6po_hbh = (struct ip6_hbh *)CMSG_DATA(cm);
			if (cm->cmsg_len !=
			    CMSG_LEN((opt->ip6po_hbh->ip6h_len + 1) << 3))
				return (EINVAL);
			break;
d2995 4
a2998 3
		case IPV6_DSTOPTS:
			if (cm->cmsg_len < CMSG_LEN(sizeof(struct ip6_dest)))
				return (EINVAL);
d3000 13
d3014 10
a3023 4
			 * If there is no routing header yet, the destination
			 * options header should be put on the 1st part.
			 * Otherwise, the header should be on the 2nd part.
			 * (See RFC 2460, section 4.1)
d3025 10
a3034 14
			if (opt->ip6po_rthdr == NULL) {
				opt->ip6po_dest1 =
				    (struct ip6_dest *)CMSG_DATA(cm);
				if (cm->cmsg_len !=
				    CMSG_LEN((opt->ip6po_dest1->ip6d_len + 1) << 3));
					return (EINVAL);
			}
			else {
				opt->ip6po_dest2 =
				    (struct ip6_dest *)CMSG_DATA(cm);
				if (cm->cmsg_len !=
				    CMSG_LEN((opt->ip6po_dest2->ip6d_len + 1) << 3))
					return (EINVAL);
			}
d3036 11
d3048 22
a3069 2
		case IPV6_RTHDR:
			if (cm->cmsg_len < CMSG_LEN(sizeof(struct ip6_rthdr)))
d3071 1
a3071 3
			opt->ip6po_rthdr = (struct ip6_rthdr *)CMSG_DATA(cm);
			if (cm->cmsg_len !=
			    CMSG_LEN((opt->ip6po_rthdr->ip6r_len + 1) << 3))
d3073 1
a3073 6
			switch (opt->ip6po_rthdr->ip6r_type) {
			case IPV6_RTHDR_TYPE_0:
				if (opt->ip6po_rthdr->ip6r_segleft == 0)
					return (EINVAL);
				break;
			default:
a3074 1
			}
a3075 1

d3077 1
a3077 1
			return (ENOPROTOOPT);
d3079 7
d3087 30
@


1.94
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.93 2006/06/18 11:47:46 pascoe Exp $	*/
d1977 1
a1977 1
		 * if the address has link-local scope.
d1979 1
a1979 1
		if (IN6_IS_ADDR_MC_LINKLOCAL(&mreq->ipv6mr_multiaddr)) {
d2077 2
a2078 1
	 * If all options have default values, no need to keep the mbuf.
d2346 3
@


1.93
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.92 2006/06/16 16:49:40 henning Exp $	*/
a594 20
		/*
		 * If the destination is a node-local scope multicast,
		 * the packet should be loop-backed only.
		 */
		if (IN6_IS_ADDR_MC_NODELOCAL(&ip6->ip6_dst)) {
			/*
			 * If the outgoing interface is already specified,
			 * it should be a loopback interface.
			 */
			if (ifp && (ifp->if_flags & IFF_LOOPBACK) == 0) {
				ip6stat.ip6s_badscope++;
				error = ENETUNREACH; /* XXX: better error? */
				/* XXX correct ifp? */
				in6_ifstat_inc(ifp, ifs6_out_discard);
				goto bad;
			} else {
				ifp = lo0ifp;
			}
		}

d674 2
a675 1
		if (ip6->ip6_hlim == 0 || (ifp->if_flags & IFF_LOOPBACK)) {
d720 1
a720 1
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d722 1
a722 1
		else if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
d740 1
a740 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d742 1
a742 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
d1937 1
a1937 3
			 * If the multicast address is in node-local scope,
			 * the interface should be a loopback interface.
			 * Otherwise, look up the routing table for the
d1941 10
a1950 16
			if (IN6_IS_ADDR_MC_NODELOCAL(&mreq->ipv6mr_multiaddr)) {
				ifp = lo0ifp;
			} else {
				ro.ro_rt = NULL;
				dst = (struct sockaddr_in6 *)&ro.ro_dst;
				bzero(dst, sizeof(*dst));
				dst->sin6_len = sizeof(struct sockaddr_in6);
				dst->sin6_family = AF_INET6;
				dst->sin6_addr = mreq->ipv6mr_multiaddr;
				rtalloc((struct route *)&ro);
				if (ro.ro_rt == NULL) {
					error = EADDRNOTAVAIL;
					break;
				}
				ifp = ro.ro_rt->rt_ifp;
				rtfree(ro.ro_rt);
d1952 2
d2369 1
a2369 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
d2371 1
a2371 1
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
@


1.92
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.91 2006/06/16 15:31:08 pascoe Exp $	*/
d533 1
a533 1
			rtalloc((struct route *)ro);
@


1.91
log
@More spelling fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.90 2006/06/16 15:16:41 pascoe Exp $	*/
d628 1
a628 1
				    &ro->ro_dst, 0);
@


1.90
log
@Spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.89 2006/05/27 23:40:27 claudio Exp $	*/
d493 1
a493 1
			 * packet gets tunnelled?
d621 1
a621 1
		 * default for the speicfied group (i.e. a host
@


1.89
log
@Do the same thing as for IPv4. Use a sysctl to enable/disable mfrowarding
and additionaly make the code part of the MROUTING option. Put it in deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.88 2006/03/05 21:48:57 miod Exp $	*/
d701 1
a701 1
	 * Fill the outgoing inteface to tell the upper layer
@


1.88
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.87 2005/01/11 08:57:24 djm Exp $	*/
d676 3
a678 1
			if (ip6_mrouter && (flags & IPV6_FORWARDING) == 0) {
d684 1
@


1.87
log
@correctly deal with unspecified (zero) interface number in IPV6_MULTICAST_IF,
IPV6_{JOIN,LEAVE}_GROUP ioctls; ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.86 2004/06/21 19:26:02 mcbride Exp $	*/
d2008 1
a2008 2
		for (imm = im6o->im6o_memberships.lh_first;
		     imm != NULL; imm = imm->i6mm_chain.le_next)
d2074 1
a2074 2
		for (imm = im6o->im6o_memberships.lh_first;
		     imm != NULL; imm = imm->i6mm_chain.le_next) {
d2104 1
a2104 1
	    im6o->im6o_memberships.lh_first == NULL) {
d2171 2
a2172 1
	while ((imm = im6o->im6o_memberships.lh_first) != NULL) {
@


1.86
log
@Get rid of pf_test_eh() wrapper.

ok cedric@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.85 2004/06/12 04:58:48 itojun Exp $	*/
d1866 14
a1879 9
		if (ifindex < 0 || if_indexlim <= ifindex ||
		    !ifindex2ifnet[ifindex]) {
			error = ENXIO;	/* XXX EINVAL? */
			break;
		}
		ifp = ifindex2ifnet[ifindex];
		if (ifp == NULL || (ifp->if_flags & IFF_MULTICAST) == 0) {
			error = EADDRNOTAVAIL;
			break;
a1947 9
		 * If the interface is specified, validate it.
		 */
		if (mreq->ipv6mr_interface < 0 ||
		    if_indexlim <= mreq->ipv6mr_interface ||
		    !ifindex2ifnet[mreq->ipv6mr_interface]) {
			error = ENXIO;	/* XXX EINVAL? */
			break;
		}
		/*
d1976 10
a1985 1
		} else
d1987 1
d2052 10
a2061 5
		if (mreq->ipv6mr_interface < 0 ||
		    if_indexlim <= mreq->ipv6mr_interface ||
		    !ifindex2ifnet[mreq->ipv6mr_interface]) {
			error = ENXIO;	/* XXX EINVAL? */
			break;
d2063 1
a2063 1
		ifp = ifindex2ifnet[mreq->ipv6mr_interface];
@


1.85
log
@support IPV6_USE_MIN_MTU, to make BIND9 better.
(sorry about the mess yesterday)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.84 2004/06/11 14:27:13 deraadt Exp $	*/
d791 1
a791 1
	if (pf_test6(PF_OUT, ifp, &m) != PF_PASS) {
@


1.84
log
@back out tree breakage.  Like, come on
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.82 2004/02/04 08:47:41 itojun Exp $	*/
d1321 1
d1380 4
d1551 1
d1613 4
@


1.83
log
@support IPV6_USE_MIN_MTU, which is needed to run BIND9 well.  from kame
markus ok
@
text
@a1320 1
			case IPV6_USE_MIN_MTU:
a1378 4
				case IPV6_USE_MIN_MTU:
					OPTSET(IN6P_MINMTU);
					break;

a1545 1
			case IPV6_USE_MIN_MTU:
a1606 4

				case IPV6_USE_MIN_MTU:
					optval = OPTBIT(IN6P_MINMTU);
					break;
@


1.82
log
@strictly follow RFC2460 section 5, last paragraph (sender behavior when
path MTU < 1280).  bug found by Georgi Guninski.  ok dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.81 2004/02/02 20:13:01 cedric Exp $	*/
d1321 1
d1380 4
d1551 1
d1613 4
@


1.81
log
@make the stack compile if NPF=0. ok deraadt@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.80 2003/12/10 03:30:21 itojun Exp $	*/
d89 1
d128 1
a128 1
	struct ifnet *, struct in6_addr *, u_long *);
d159 1
d705 2
a706 1
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu)) != 0)
d804 15
d821 35
a855 1
	if (tlen <= mtu) {
d858 7
a864 5
	} else if (mtu < IPV6_MMTU) {
		/*
		 * note that path MTU is never less than IPV6_MMTU
		 * (see icmp6_input).
		 */
d868 2
a869 1
	} else if (ip6->ip6_plen == 0) { /* jumbo payload cannot be fragmented */
d878 4
d891 10
d943 1
d956 1
a956 1
			ip6f->ip6f_offlg = htons((u_short)((off - hlen) & ~7));
d961 1
a961 1
			mhip6->ip6_plen = htons((u_short)(len + hlen +
d1196 1
a1196 1
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup)
d1201 1
d1204 1
d1215 1
a1215 1
			ro_pmtu->ro_rt = (struct rtentry *)0;
d1235 12
a1246 1
		else if (mtu > ifmtu) {
a1253 3
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
d1265 2
@


1.80
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.79 2003/11/07 22:32:47 itojun Exp $	*/
d95 1
@


1.79
log
@fix behavior when ipv6mr_interface is 0.  reported on netbsd list
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.78 2003/10/01 21:41:05 itojun Exp $	*/
d554 4
a557 4
		if (opt && opt->ip6po_pktinfo
		 && opt->ip6po_pktinfo->ipi6_ifindex) {
			if (!(ifp->if_flags & IFF_LOOPBACK)
			 && ifp->if_index != opt->ip6po_pktinfo->ipi6_ifindex) {
d1773 2
a1774 1
		if (ifindex < 0 || if_index < ifindex) {
d1853 2
a1854 1
		    if_index < mreq->ipv6mr_interface) {
d1953 3
a1955 2
		if (mreq->ipv6mr_interface < 0
		 || if_index < mreq->ipv6mr_interface) {
d2120 1
a2120 1
			if (opt->ip6po_pktinfo->ipi6_ifindex > if_index ||
d2122 4
@


1.78
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.77 2003/10/01 21:35:50 itojun Exp $	*/
d1851 2
a1852 2
		if (mreq->ipv6mr_interface < 0
		 || if_index < mreq->ipv6mr_interface) {
d1902 1
a1902 1
			    htons(mreq->ipv6mr_interface);
@


1.77
log
@correct m_cat misuse.  i remember it was ok'ed by someone but don't remember who...
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.76 2003/08/15 20:32:20 tedu Exp $	*/
d820 1
a820 1
		u_int32_t id = htonl(ip6_id++);
@


1.76
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.75 2003/06/11 02:54:02 itojun Exp $	*/
d865 2
d897 3
a899 1
			m_cat(m, m_frgpart);
@


1.76.2.1
log
@MFC:
Fix by itojun@@

strictly follow RFC2460 section 5, last paragraph (sender behavior when
path MTU < 1280).  bug found by Georgi Guninski.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.76 2003/08/15 20:32:20 tedu Exp $	*/
a88 1
#include <netinet6/ip6protosw.h>
d126 1
a126 1
	struct ifnet *, struct in6_addr *, u_long *, int *);
a156 1
	int alwaysfrag, dontfrag;
d702 1
a702 2
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu,
	    &alwaysfrag)) != 0)
a799 15
	 *
	 * the logic here is rather complex:
	 * 1: normal case (dontfrag == 0, alwaysfrag == 0)
	 * 1-a: send as is if tlen <= path mtu
	 * 1-b: fragment if tlen > path mtu
	 *
	 * 2: if user asks us not to fragment (dontfrag == 1)
	 * 2-a: send as is if tlen <= interface mtu
	 * 2-b: error if tlen > interface mtu
	 *
	 * 3: if we always need to attach fragment header (alwaysfrag == 1)
	 *      always fragment
	 *
	 * 4: if dontfrag == 1 && alwaysfrag == 1
	 *      error, as we cannot handle this conflicting request
d802 4
a805 8

	dontfrag = 0;
	if (dontfrag && alwaysfrag) {	/* case 4 */
		/* conflicting request - can't transmit */
		error = EMSGSIZE;
		goto bad;
	}
	if (dontfrag && tlen > IN6_LINKMTU(ifp)) {	/* case 2-b */
d807 2
a808 6
		 * Even if the DONTFRAG option is specified, we cannot send the
		 * packet when the data length is larger than the MTU of the
		 * outgoing interface.
		 * Notify the error by sending IPV6_PATHMTU ancillary data as
		 * well as returning an error code (the latter is not described
		 * in the API spec.)
a810 17
		goto bad;
	}

	/*
	 * transmit packet without fragmentation
	 */
	if (dontfrag || (!alwaysfrag && tlen <= mtu)) {	/* case 1-a and 2-a */
		error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
		goto done;
	}

	/*
	 * try to fragment the packet.  case 1-b and 3
	 */
	if (mtu < IPV6_MMTU) {
		/* path MTU cannot be less than IPV6_MMTU */
		error = EMSGSIZE;
d813 1
a813 2
	} else if (ip6->ip6_plen == 0) {
		/* jumbo payload cannot be fragmented */
a870 1
			m->m_pkthdr.rcvif = NULL;
d883 1
a883 1
			ip6f->ip6f_offlg = htons((u_int16_t)((off - hlen) & ~7));
d888 1
a888 1
			mhip6->ip6_plen = htons((u_int16_t)(len + hlen +
d1121 1
a1121 1
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup, alwaysfragp)
a1125 1
	int *alwaysfragp;
a1127 1
	int alwaysfrag = 0;
d1138 1
a1138 1
			ro_pmtu->ro_rt = (struct rtentry *)NULL;
d1158 1
a1158 12
		else if (mtu < IPV6_MMTU) {
			/*
			 * RFC2460 section 5, last paragraph:
			 * if we record ICMPv6 too big message with
			 * mtu < IPV6_MMTU, transmit packets sized IPV6_MMTU
			 * or smaller, with fragment header attached.
			 * (fragment header is needed regardless from the
			 * packet size, for translators to identify packets)
			 */
			alwaysfrag = 1;
			mtu = IPV6_MMTU;
		} else if (mtu > ifmtu) {
d1166 3
a1179 2
	if (alwaysfragp)
		*alwaysfragp = alwaysfrag;
@


1.75
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.74 2003/06/02 23:28:15 millert Exp $	*/
d1376 1
a1376 1
					    suser(p->p_ucred, &p->p_acflag)) {
d1385 1
a1385 1
					    suser(p->p_ucred, &p->p_acflag)) {
d1394 1
a1394 1
					    suser(p->p_ucred, &p->p_acflag)) {
d1403 1
a1403 1
					    suser(p->p_ucred, &p->p_acflag)) {
d1711 1
a1711 1
	if (p && !suser(p->p_ucred, &p->p_acflag))
d1834 1
a1834 1
			if (suser(p->p_ucred, &p->p_acflag))
d1934 1
a1934 1
			if (suser(p->p_ucred, &p->p_acflag))
@


1.74
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.73 2002/10/31 18:02:27 itojun Exp $	*/
d405 1
d413 3
a415 3
			 ip6->ip6_dst = rh0->ip6r0_addr[0];
			 bcopy((caddr_t)&rh0->ip6r0_addr[1],
			     (caddr_t)&rh0->ip6r0_addr[0],
d417 1
a417 1
			 rh0->ip6r0_addr[rh0->ip6r0_segleft - 1] = finaldst;
@


1.73
log
@plug memory leak.  from sam leffler.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.72 2002/09/23 23:03:31 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.73.2.1
log
@MFC:
Fix by itojun@@

strictly follow RFC2460 section 5, last paragraph (sender behavior when
path MTU < 1280).  bug found by Georgi Guninski.

ok deraadt@@ dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.73 2002/10/31 18:02:27 itojun Exp $	*/
a92 1
#include <netinet6/ip6protosw.h>
d130 1
a130 1
	struct ifnet *, struct in6_addr *, u_long *, int *);
a160 1
	int alwaysfrag, dontfrag;
d705 1
a705 2
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu,
	    &alwaysfrag)) != 0)
a802 15
	 *
	 * the logic here is rather complex:
	 * 1: normal case (dontfrag == 0, alwaysfrag == 0)
	 * 1-a: send as is if tlen <= path mtu
	 * 1-b: fragment if tlen > path mtu
	 *
	 * 2: if user asks us not to fragment (dontfrag == 1)
	 * 2-a: send as is if tlen <= interface mtu
	 * 2-b: error if tlen > interface mtu
	 *
	 * 3: if we always need to attach fragment header (alwaysfrag == 1)
	 *      always fragment
	 *
	 * 4: if dontfrag == 1 && alwaysfrag == 1
	 *      error, as we cannot handle this conflicting request
d805 4
a808 8

	dontfrag = 0;
	if (dontfrag && alwaysfrag) {	/* case 4 */
		/* conflicting request - can't transmit */
		error = EMSGSIZE;
		goto bad;
	}
	if (dontfrag && tlen > IN6_LINKMTU(ifp)) {	/* case 2-b */
d810 2
a811 6
		 * Even if the DONTFRAG option is specified, we cannot send the
		 * packet when the data length is larger than the MTU of the
		 * outgoing interface.
		 * Notify the error by sending IPV6_PATHMTU ancillary data as
		 * well as returning an error code (the latter is not described
		 * in the API spec.)
a813 17
		goto bad;
	}

	/*
	 * transmit packet without fragmentation
	 */
	if (dontfrag || (!alwaysfrag && tlen <= mtu)) {	/* case 1-a and 2-a */
		error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
		goto done;
	}

	/*
	 * try to fragment the packet.  case 1-b and 3
	 */
	if (mtu < IPV6_MMTU) {
		/* path MTU cannot be less than IPV6_MMTU */
		error = EMSGSIZE;
d816 1
a816 2
	} else if (ip6->ip6_plen == 0) {
		/* jumbo payload cannot be fragmented */
a873 1
			m->m_pkthdr.rcvif = NULL;
d886 1
a886 1
			ip6f->ip6f_offlg = htons((u_int16_t)((off - hlen) & ~7));
d891 1
a891 1
			mhip6->ip6_plen = htons((u_int16_t)(len + hlen +
d1124 1
a1124 1
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup, alwaysfragp)
a1128 1
	int *alwaysfragp;
a1130 1
	int alwaysfrag = 0;
d1141 1
a1141 1
			ro_pmtu->ro_rt = (struct rtentry *)NULL;
d1161 1
a1161 12
		else if (mtu < IPV6_MMTU) {
			/*
			 * RFC2460 section 5, last paragraph:
			 * if we record ICMPv6 too big message with
			 * mtu < IPV6_MMTU, transmit packets sized IPV6_MMTU
			 * or smaller, with fragment header attached.
			 * (fragment header is needed regardless from the
			 * packet size, for translators to identify packets)
			 */
			alwaysfrag = 1;
			mtu = IPV6_MMTU;
		} else if (mtu > ifmtu) {
d1169 3
a1182 2
	if (alwaysfragp)
		*alwaysfragp = alwaysfrag;
@


1.72
log
@correct length of PADN option before jumbo payload option.  sync w/kame
deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.71 2002/09/11 03:27:30 itojun Exp $	*/
d1707 1
a1707 2
		if (opt)
			free(opt, M_IP6OPT);
d1718 1
@


1.71
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.70 2002/09/11 03:15:36 itojun Exp $	*/
d1054 1
a1054 1
		optbuf[1] = 1;
@


1.70
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.69 2002/06/09 14:38:39 itojun Exp $	*/
d989 1
a989 1
	u_char *optbuf;
d1005 1
a1005 1
		optbuf = mtod(mopt, u_char *);
d1046 1
a1046 1
			optbuf = mtod(n, caddr_t) + oldoptlen;
d1050 1
a1050 1
			optbuf = mtod(mopt, u_char *) + mopt->m_len;
@


1.69
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.68 2002/06/08 21:52:07 itojun Exp $	*/
d937 1
a937 1
	return(error);
d959 1
a959 1
		return(ENOBUFS); /* XXX */
d963 1
a963 1
		return(ENOBUFS);
d969 1
a969 1
			return(ENOBUFS);
d977 1
a977 1
	return(0);
d1003 1
a1003 1
			return(ENOBUFS);
d1027 1
a1027 1
				return(ENOBUFS);
d1042 1
a1042 1
				return(ENOBUFS);
d1073 1
a1073 1
	return(0);
d1092 1
a1092 1
			return(ENOBUFS);
d1114 1
a1114 1
			return(ENOBUFS);
d1120 1
a1120 1
	return(0);
d1183 1
a1183 1
	return(error);
d1219 1
a1219 1
				return(ip6_pcbopts(&inp->inp_outputopts6,
d1600 1
a1600 1
	return(error);
d1620 1
a1620 1
		return(EINVAL);
d1676 1
a1676 1
	return(error);
d1711 1
a1711 1
		return(0);
d1719 1
a1719 1
		return(error);
d1722 1
a1722 1
	return(0);
d1753 1
a1753 1
			return(ENOBUFS);
d2003 1
a2003 1
	return(error);
d2028 1
a2028 1
		return(0);
d2037 1
a2037 1
		return(0);
d2046 1
a2046 1
		return(0);
d2049 1
a2049 1
		return(EOPNOTSUPP);
d2084 1
a2084 1
		return(EINVAL);
d2094 1
a2094 1
		return(EINVAL);
d2102 1
a2102 1
			return(EINVAL);
d2109 1
a2109 1
				return(EINVAL);
d2118 1
a2118 1
				return(ENXIO);
d2141 1
a2141 1
					return(EADDRNOTAVAIL);
d2145 1
a2145 1
					return(EADDRNOTAVAIL);
d2154 1
a2154 1
					return(EADDRNOTAVAIL);
d2160 1
a2160 1
				return(EINVAL);
d2165 1
a2165 1
				return(EINVAL);
d2170 1
a2170 1
				return(EPERM);
d2175 1
a2175 1
				return(EINVAL);
d2183 1
a2183 1
				return(EINVAL);
d2187 1
a2187 1
				return(EINVAL);
d2192 1
a2192 1
				return(EINVAL);
d2205 1
a2205 1
					return(EINVAL);
d2212 1
a2212 1
					return(EINVAL);
d2218 1
a2218 1
				return(EINVAL);
d2222 1
a2222 1
				return(EINVAL);
d2226 1
a2226 1
					return(EINVAL);
d2229 1
a2229 1
				return(EINVAL);
d2234 1
a2234 1
			return(ENOPROTOOPT);
d2238 1
a2238 1
	return(0);
@


1.68
log
@use splnet for ipsec
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.67 2002/06/08 21:51:08 itojun Exp $	*/
d789 1
a789 1
#if NPF > 0 
d798 1
a798 1
#endif 
d1370 1
a1370 1
				if (optval < IPSEC_LEVEL_BYPASS || 
d1375 1
a1375 1
					
d1622 1
a1622 1
		
@


1.67
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.66 2002/06/08 21:22:03 itojun Exp $	*/
d208 2
a209 2
	 * splsoftnet is chosen over spltdb because we are not allowed to
	 * lower the level, and udp6_output calls us in splsoftnet(). XXX check
d211 1
a211 1
	s = splsoftnet();
@


1.66
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.65 2002/06/07 21:47:44 itojun Exp $	*/
d208 2
a209 2
	 * splnet is chosen over spltdb because we are not allowed to
	 * lower the level, and udp6_output calls us in splnet(). XXX check
d211 1
a211 1
	s = splnet();
@


1.65
log
@move IPV6_CHECKSUM processing to ip6_raw_ctloutput().  bunch of KNFs.
rip6 stats.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.64 2002/06/07 15:27:58 itojun Exp $	*/
d430 1
a430 1
	    (flags & IPV6_DADOUTPUT) == 0) {
@


1.64
log
@just for consistency/compatibility, have net.inet6.ip6.v6only sysctl MIB,
as well as set/getsockopt(IPV6_V6ONLY).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.63 2002/06/07 15:00:55 itojun Exp $	*/
a1234 1
			case IPV6_CHECKSUM:
a1290 4
				case IPV6_CHECKSUM:
					inp->in6p_cksum = optval;
					break;

a1458 1
			case IPV6_CHECKSUM:
a1501 4
				case IPV6_CHECKSUM:
					optval = inp->in6p_cksum;
					break;

d1603 76
a2321 2
# define in6pcb	inpcb
# define in6p_outputopts	inp_outputopts6
d2323 2
a2324 2
ip6_optlen(in6p)
	struct in6pcb *in6p;
d2328 1
a2328 1
	if (!in6p->in6p_outputopts)
d2335 4
a2338 4
	len += elen(in6p->in6p_outputopts->ip6po_hbh);
	len += elen(in6p->in6p_outputopts->ip6po_dest1);
	len += elen(in6p->in6p_outputopts->ip6po_rthdr);
	len += elen(in6p->in6p_outputopts->ip6po_dest2);
a2341 2
# undef in6pcb
# undef in6p_outputopts
@


1.63
log
@style
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.62 2002/06/07 04:13:10 itojun Exp $	*/
d1237 1
d1299 5
a1319 2
# define in6p		inp
# define in6p_flags	inp_flags
d1322 2
a1323 2
					in6p->in6p_flags &= ~(IN6P_LOWPORT);
					in6p->in6p_flags &= ~(IN6P_HIGHPORT);
d1327 2
a1328 2
					in6p->in6p_flags &= ~(IN6P_LOWPORT);
					in6p->in6p_flags |= IN6P_HIGHPORT;
d1332 2
a1333 2
					in6p->in6p_flags &= ~(IN6P_HIGHPORT);
					in6p->in6p_flags |= IN6P_LOWPORT;
a1339 2
# undef in6p
# undef in6p_flags
d1466 1
d1514 4
@


1.62
log
@'fall through' is not a valid LINT keyword.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.61 2002/05/31 03:20:01 itojun Exp $	*/
d121 1
a121 2
static int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *,
			    struct socket *);
d126 1
a126 1
				  struct ip6_frag **);
d188 1
a188 1
				       ((eh)->ip6e_len + 1) << 3);	\
d232 1
a232 2
	}
	else
d395 5
a399 6
		MAKE_CHAIN(exthdrs.ip6e_hbh, mprev,
			   nexthdrp, IPPROTO_HOPOPTS);
		MAKE_CHAIN(exthdrs.ip6e_dest1, mprev,
			   nexthdrp, IPPROTO_DSTOPTS);
		MAKE_CHAIN(exthdrs.ip6e_rthdr, mprev,
			   nexthdrp, IPPROTO_ROUTING);
d407 1
a407 3
		struct ip6_rthdr *rh =
			(struct ip6_rthdr *)(mtod(exthdrs.ip6e_rthdr,
						  struct ip6_rthdr *));
d410 2
d413 1
a413 1
		switch(rh->ip6r_type) {
d418 2
a419 3
				 (caddr_t)&rh0->ip6r0_addr[0],
				 sizeof(struct in6_addr)*(rh0->ip6r0_segleft - 1)
				 );
d460 2
a461 1
			 !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &ip6->ip6_dst))) {
d610 1
a610 2
			}
			else {
d628 1
a628 1
						&ro->ro_dst, 0);
d730 3
a732 2
		 * of source and destination, which should already be assured.
		 * Larger scopes than link will be supported in the future. 
d753 1
a753 2
	}
	else
d766 1
a766 2
		struct ip6_hbh *hbh = mtod(exthdrs.ip6e_hbh,
					   struct ip6_hbh *);
d778 3
a780 5
		if (ip6_process_hopopts(m,
					(u_int8_t *)(hbh + 1),
					((hbh->ip6h_len + 1) << 3) -
					sizeof(struct ip6_hbh),
					&dummy1, &dummy2) < 0) {
d805 1
a805 16
	if (tlen <= mtu
#ifdef notyet
	    /*
	     * On any link that cannot convey a 1280-octet packet in one piece,
	     * link-specific fragmentation and reassembly must be provided at
	     * a layer below IPv6. [RFC 2460, sec.5]
	     * Thus if the interface has ability of link-level fragmentation,
	     * we can just send the packet even if the packet size is
	     * larger than the link's MTU.
	     * XXX: IFF_FRAGMENTABLE (or such) flag has not been defined yet...
	     */
	
	    || ifp->if_flags & IFF_FRAGMENTABLE
#endif
	    )
	{
d881 2
a882 2
 			error = ip6_insertfraghdr(m0, m, hlen, &ip6f);
 			if (error) {
d892 1
a892 2
							  sizeof(*ip6f) -
							  sizeof(struct ip6_hdr)));
d1090 1
a1090 1
			    hlen - sizeof(struct ip6_hdr), M_DONTWAIT);
d1104 2
a1105 2
		*frghdrp =
			(struct ip6_frag *)(mtod(mlast, caddr_t) + mlast->m_len);
d1220 1
a1220 1
						   m, so));
d1237 1
a1237 1
				if (optlen != sizeof(int))
d1239 13
a1251 12
				else {
					optval = *mtod(m, int *);
					switch (optname) {

					case IPV6_UNICAST_HOPS:
						if (optval < -1 || optval >= 256)
							error = EINVAL;
						else {
							/* -1 = kernel default */
							inp->inp_hops = optval;
						}
						break;
d1253 1
d1255 1
a1255 1
		inp->inp_flags |= bit; \
d1257 5
a1261 4
		inp->inp_flags &= ~bit;
					case IPV6_RECVOPTS:
						OPTSET(IN6P_RECVOPTS);
						break;
d1263 3
a1265 3
					case IPV6_RECVRETOPTS:
						OPTSET(IN6P_RECVRETOPTS);
						break;
d1267 3
a1269 3
					case IPV6_RECVDSTADDR:
						OPTSET(IN6P_RECVDSTADDR);
						break;
d1271 3
a1273 3
					case IPV6_PKTINFO:
						OPTSET(IN6P_PKTINFO);
						break;
d1275 3
a1277 3
					case IPV6_HOPLIMIT:
						OPTSET(IN6P_HOPLIMIT);
						break;
d1279 3
a1281 3
					case IPV6_HOPOPTS:
						OPTSET(IN6P_HOPOPTS);
						break;
d1283 3
a1285 3
					case IPV6_DSTOPTS:
						OPTSET(IN6P_DSTOPTS);
						break;
d1287 3
a1289 3
					case IPV6_RTHDR:
						OPTSET(IN6P_RTHDR);
						break;
d1291 3
a1293 3
					case IPV6_CHECKSUM:
						inp->in6p_cksum = optval;
						break;
d1295 3
a1297 4
					case IPV6_FAITH:
						OPTSET(IN6P_FAITH);
						break;
					}
a1434 11
#if 0
				*mp = m = m_get(M_WAIT, MT_SOOPTS);
				if (in6p->in6p_options) {
					m->m_len = in6p->in6p_options->m_len;
					bcopy(mtod(in6p->in6p_options, caddr_t),
					      mtod(m, caddr_t),
					      (unsigned)m->m_len);
				} else
					m->m_len = 0;
				break;
#else
a1436 1
#endif
d1441 1
a1441 1
						      M_COPYALL, M_WAIT);
d1626 1
a1626 2
	}
	else
d1679 2
d1698 1
a1698 1
		ifindex = *(mtod(m, u_int *));
d1721 1
a1721 1
		optval = *(mtod(m, u_int *));
d1736 6
a1741 2
		if (m == NULL || m->m_len != sizeof(u_int) ||
		   (loop = *(mtod(m, u_int *))) > 1) {
d1796 1
a1796 2
			}
			else {
d1827 2
a1828 2
			mreq->ipv6mr_multiaddr.s6_addr16[1]
				= htons(mreq->ipv6mr_interface);
d1837 1
a1837 1
					       &mreq->ipv6mr_multiaddr))
d1847 2
a1848 5
		imm = malloc(sizeof(*imm), M_IPMADDR, M_WAITOK);

		if ((imm->i6mm_maddr =
		     in6_addmulti(&mreq->ipv6mr_multiaddr, ifp, &error)) == NULL) {
			free(imm, M_IPMADDR);
a1849 1
		}
d1888 2
a1889 2
			mreq->ipv6mr_multiaddr.s6_addr16[1]
				= htons(mreq->ipv6mr_interface);
d1896 1
a1896 2
			if ((ifp == NULL ||
			     imm->i6mm_maddr->in6m_ifp == ifp) &&
d1898 1
a1898 1
					       &mreq->ipv6mr_multiaddr))
d1911 1
a1911 2
		in6_delmulti(imm->i6mm_maddr);
		free(imm, M_IPMADDR);
d1994 1
a1994 3
		if (imm->i6mm_maddr)
			in6_delmulti(imm->i6mm_maddr);
		free(imm, M_IPMADDR);
d2026 1
a2026 1
		     control->m_len -= CMSG_ALIGN(cm->cmsg_len)) {
d2033 1
a2033 1
		switch(cm->cmsg_type) {
d2043 2
a2044 2
			if (opt->ip6po_pktinfo->ipi6_ifindex > if_index
			 || opt->ip6po_pktinfo->ipi6_ifindex < 0) {
d2089 2
a2090 1
			opt->ip6po_hlim = *(int *)CMSG_DATA(cm);
d2098 2
a2099 1
			
a2100 1
			    /* check if cmsg_len is large enough for sa_len */
d2129 1
a2129 1
					(struct ip6_dest *)CMSG_DATA(cm);
d2131 1
a2131 2
				    CMSG_LEN((opt->ip6po_dest1->ip6d_len + 1)
					     << 3))
d2136 1
a2136 1
					(struct ip6_dest *)CMSG_DATA(cm);
d2138 1
a2138 2
				    CMSG_LEN((opt->ip6po_dest2->ip6d_len + 1)
					     << 3))
d2150 1
a2150 1
			switch(opt->ip6po_rthdr->ip6r_type) {
@


1.61
log
@do not try to update rmx_mtu if rmx_mtu == 0 (obey ifmtu)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.60 2002/05/29 23:38:58 itojun Exp $	*/
d967 1
a967 1
	/* fall through */
d1250 1
a1250 1
				/* fall through */
d1487 1
a1487 1
				/* fall through */
@


1.60
log
@force fragment to minimum link MTU (1280) when needed (when PMTUD does
not take effect) - like icmp6 responses or foo-over-IPv6 tunnel.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.59 2002/05/29 07:54:59 itojun Exp $	*/
d1182 3
a1184 1
		if (mtu > ifmtu || mtu == 0) {
d1197 1
a1197 2
			if (!(ro_pmtu->ro_rt->rt_rmx.rmx_locks & RTV_MTU)) {
				/* XXX */
a1198 1
			}
@


1.59
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.58 2002/03/14 01:27:12 millert Exp $	*/
a715 1
#ifdef IPV6_MINMTU
a719 1
#endif
@


1.58
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.57 2002/01/21 05:33:14 itojun Exp $	*/
d130 2
d708 4
d713 2
a714 1
	 * Determine path MTU.
d716 4
a719 41
	if (ro_pmtu != ro) {
		/* The first hop and the final destination may differ. */
		struct sockaddr_in6 *sin6_fin =
			(struct sockaddr_in6 *)&ro_pmtu->ro_dst;
		if (ro_pmtu->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
				       !IN6_ARE_ADDR_EQUAL(&sin6_fin->sin6_addr,
							   &finaldst))) {
			RTFREE(ro_pmtu->ro_rt);
			ro_pmtu->ro_rt = (struct rtentry *)0;
		}
		if (ro_pmtu->ro_rt == 0) {
			bzero(sin6_fin, sizeof(*sin6_fin));
			sin6_fin->sin6_family = AF_INET6;
			sin6_fin->sin6_len = sizeof(struct sockaddr_in6);
			sin6_fin->sin6_addr = finaldst;

			rtalloc((struct route *)ro_pmtu);
		}
	}
	if (ro_pmtu->ro_rt != NULL) {
		u_int32_t ifmtu = nd_ifinfo[ifp->if_index].linkmtu;

		mtu = ro_pmtu->ro_rt->rt_rmx.rmx_mtu;
		if (mtu > ifmtu || mtu == 0) {
			/*
			 * The MTU on the route is larger than the MTU on
			 * the interface!  This shouldn't happen, unless the
			 * MTU of the interface has been changed after the
			 * interface was brought up.  Change the MTU in the
			 * route to match the interface MTU (as long as the
			 * field isn't locked).
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
			 */
			 mtu = ifmtu;
			 if ((ro_pmtu->ro_rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
				 ro_pmtu->ro_rt->rt_rmx.rmx_mtu = mtu; /* XXX */
		}
	} else {
		mtu = nd_ifinfo[ifp->if_index].linkmtu;
d721 1
d1146 63
@


1.57
log
@remove couple of #if 0'ed portion we will never use
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.56 2001/12/07 09:16:07 itojun Exp $	*/
d105 1
a105 1
extern u_int8_t get_sa_require  __P((struct inpcb *));
d121 9
a129 9
static int ip6_pcbopts __P((struct ip6_pktopts **, struct mbuf *,
			    struct socket *));
static int ip6_setmoptions __P((int, struct ip6_moptions **, struct mbuf *));
static int ip6_getmoptions __P((int, struct ip6_moptions *, struct mbuf **));
static int ip6_copyexthdr __P((struct mbuf **, caddr_t, int));
static int ip6_insertfraghdr __P((struct mbuf *, struct mbuf *, int,
				  struct ip6_frag **));
static int ip6_insert_jumboopt __P((struct ip6_exthdrs *, u_int32_t));
static int ip6_splithdr __P((struct mbuf *, struct ip6_exthdrs *));
@


1.56
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.55 2001/11/30 07:59:17 itojun Exp $	*/
a400 55

#if 0 /*KAME IPSEC*/
		if (!needipsec)
			goto skip_ipsec2;

		/*
		 * pointers after IPsec headers are not valid any more.
		 * other pointers need a great care too.
		 * (IPsec routines should not mangle mbufs prior to AH/ESP)
		 */
		exthdrs.ip6e_dest2 = NULL;

	    {
		struct ip6_rthdr *rh = NULL;
		int segleft_org = 0;
		struct ipsec_output_state state;

		if (exthdrs.ip6e_rthdr) {
			rh = mtod(exthdrs.ip6e_rthdr, struct ip6_rthdr *);
			segleft_org = rh->ip6r_segleft;
			rh->ip6r_segleft = 0;
		}

		bzero(&state, sizeof(state));
		state.m = m;
		error = ipsec6_output_trans(&state, nexthdrp, mprev, sp, flags,
			&needipsectun);
		m = state.m;
		if (error) {
			/* mbuf is already reclaimed in ipsec6_output_trans. */
			m = NULL;
			switch (error) {
			case EHOSTUNREACH:
			case ENETUNREACH:
			case EMSGSIZE:
			case ENOBUFS:
			case ENOMEM:
				break;
			default:
				printf("ip6_output (ipsec): error code %d\n", error);
				/*fall through*/
			case ENOENT:
				/* don't show these error codes to the user */
				error = 0;
				break;
			}
			goto bad;
		}
		if (exthdrs.ip6e_rthdr) {
			/* ah6_output doesn't modify mbuf chain */
			rh->ip6r_segleft = segleft_org;
		}
	    }
skip_ipsec2:;
#endif
a1328 12
#if 0 /*KAME IPSEC*/
			case IPV6_IPSEC_POLICY:
			    {
				caddr_t req = NULL;
				if (m != 0)
					req = mtod(m, caddr_t);
				error = ipsec6_set_policy(in6p, optname, req,
				                          privileged);
			    }
				break;
#endif /* IPSEC */

a1539 15

#if 0 /*KAME IPSEC*/
			case IPV6_IPSEC_POLICY:
			  {
				caddr_t req = NULL;
				int len = 0;

				if (m != 0) {
					req = mtod(m, caddr_t);
					len = m->m_len;
				}
				error = ipsec6_get_policy(in6p, req, mp);
				break;
			  }
#endif /* IPSEC */
@


1.56.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.57 2002/01/21 05:33:14 itojun Exp $	*/
d401 55
d1384 12
d1607 15
@


1.56.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.56.2.1 2002/01/31 22:55:46 niklas Exp $	*/
d105 1
a105 1
extern u_int8_t get_sa_require(struct inpcb *);
d121 9
a129 10
static int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *, struct socket *);
static int ip6_setmoptions(int, struct ip6_moptions **, struct mbuf *);
static int ip6_getmoptions(int, struct ip6_moptions *, struct mbuf **);
static int ip6_copyexthdr(struct mbuf **, caddr_t, int);
static int ip6_insertfraghdr(struct mbuf *, struct mbuf *, int,
	struct ip6_frag **);
static int ip6_insert_jumboopt(struct ip6_exthdrs *, u_int32_t);
static int ip6_splithdr(struct mbuf *, struct ip6_exthdrs *);
static int ip6_getpmtu(struct route_in6 *, struct route_in6 *,
	struct ifnet *, struct in6_addr *, u_long *);
d187 1
a187 1
		    ((eh)->ip6e_len + 1) << 3);				\
d231 2
a232 1
	} else
d395 6
a400 5
		MAKE_CHAIN(exthdrs.ip6e_hbh, mprev, nexthdrp, IPPROTO_HOPOPTS);
		MAKE_CHAIN(exthdrs.ip6e_dest1, mprev, nexthdrp,
		    IPPROTO_DSTOPTS);
		MAKE_CHAIN(exthdrs.ip6e_rthdr, mprev, nexthdrp,
		    IPPROTO_ROUTING);
d408 3
a410 1
		struct ip6_rthdr *rh;
a412 2
		rh = (struct ip6_rthdr *)(mtod(exthdrs.ip6e_rthdr,
		    struct ip6_rthdr *));
d414 1
a414 1
		switch (rh->ip6r_type) {
d419 3
a421 2
			     (caddr_t)&rh0->ip6r0_addr[0],
			     sizeof(struct in6_addr) * (rh0->ip6r0_segleft - 1));
d432 1
a432 1
	    (flags & IPV6_UNSPECSRC) == 0) {
d462 1
a462 2
	    dst->sin6_family != AF_INET6 ||
	    !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &ip6->ip6_dst))) {
d611 2
a612 1
			} else {
d630 1
a630 1
				    &ro->ro_dst, 0);
a705 4
	/* Determine path MTU. */
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu)) != 0)
		goto bad;

d707 1
a707 2
	 * The caller of this function may specify to use the minimum MTU
	 * in some cases.
d709 41
a749 3
	if (mtu > IPV6_MMTU) {
		if ((flags & IPV6_MINMTU))
			mtu = IPV6_MMTU;
d765 2
a766 3
		 * of source add destination, which should already be assured
		 * Larger scopes than link will be supported in the near
		 * future.
d787 2
a788 1
	} else
d801 2
a802 1
		struct ip6_hbh *hbh = mtod(exthdrs.ip6e_hbh, struct ip6_hbh *);
d814 5
a818 3
		if (ip6_process_hopopts(m, (u_int8_t *)(hbh + 1),
		    ((hbh->ip6h_len + 1) << 3) - sizeof(struct ip6_hbh),
		    &dummy1, &dummy2) < 0) {
d843 16
a858 1
	if (tlen <= mtu) {
d934 2
a935 2
			error = ip6_insertfraghdr(m0, m, hlen, &ip6f);
			if (error) {
d945 2
a946 1
			    sizeof(*ip6f) - sizeof(struct ip6_hdr)));
d998 1
a998 1
	/* FALLTHROUGH */
d1144 1
a1144 1
		    hlen - sizeof(struct ip6_hdr), M_DONTWAIT);
d1158 2
a1159 2
		*frghdrp = (struct ip6_frag *)(mtod(mlast, caddr_t) +
		    mlast->m_len);
a1176 63
static int
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup)
	struct route_in6 *ro_pmtu, *ro;
	struct ifnet *ifp;
	struct in6_addr *dst;
	u_long *mtup;
{
	u_int32_t mtu = 0;
	int error = 0;

	if (ro_pmtu != ro) {
		/* The first hop and the final destination may differ. */
		struct sockaddr_in6 *sa6_dst =
		    (struct sockaddr_in6 *)&ro_pmtu->ro_dst;
		if (ro_pmtu->ro_rt &&
		    ((ro_pmtu->ro_rt->rt_flags & RTF_UP) == 0 ||
		     !IN6_ARE_ADDR_EQUAL(&sa6_dst->sin6_addr, dst))) {
			RTFREE(ro_pmtu->ro_rt);
			ro_pmtu->ro_rt = (struct rtentry *)0;
		}
		if (ro_pmtu->ro_rt == 0) {
			bzero(sa6_dst, sizeof(*sa6_dst));
			sa6_dst->sin6_family = AF_INET6;
			sa6_dst->sin6_len = sizeof(struct sockaddr_in6);
			sa6_dst->sin6_addr = *dst;

			rtalloc((struct route *)ro_pmtu);
		}
	}
	if (ro_pmtu->ro_rt) {
		u_int32_t ifmtu;

		if (ifp == NULL)
			ifp = ro_pmtu->ro_rt->rt_ifp;
		ifmtu = IN6_LINKMTU(ifp);
		mtu = ro_pmtu->ro_rt->rt_rmx.rmx_mtu;
		if (mtu == 0)
			mtu = ifmtu;
		else if (mtu > ifmtu) {
			/*
			 * The MTU on the route is larger than the MTU on
			 * the interface!  This shouldn't happen, unless the
			 * MTU of the interface has been changed after the
			 * interface was brought up.  Change the MTU in the
			 * route to match the interface MTU (as long as the
			 * field isn't locked).
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
			 */
			mtu = ifmtu;
			if (!(ro_pmtu->ro_rt->rt_rmx.rmx_locks & RTV_MTU))
				ro_pmtu->ro_rt->rt_rmx.rmx_mtu = mtu;
		}
	} else if (ifp) {
		mtu = IN6_LINKMTU(ifp);
	} else
		error = EHOSTUNREACH; /* XXX */

	*mtup = mtu;
	return(error);
}

d1211 1
a1211 1
				    m, so));
d1218 1
a1218 1
				/* FALLTHROUGH */
d1226 1
d1228 1
a1228 2
			case IPV6_V6ONLY:
				if (optlen != sizeof(int)) {
d1230 12
a1241 13
					break;
				}
				optval = *mtod(m, int *);
				switch (optname) {

				case IPV6_UNICAST_HOPS:
					if (optval < -1 || optval >= 256)
						error = EINVAL;
					else {
						/* -1 = kernel default */
						inp->inp_hops = optval;
					}
					break;
a1242 1
do { \
d1244 1
a1244 1
		inp->inp_flags |= (bit); \
d1246 4
a1249 5
		inp->inp_flags &= ~(bit); \
} while (0)
				case IPV6_RECVOPTS:
					OPTSET(IN6P_RECVOPTS);
					break;
d1251 3
a1253 3
				case IPV6_RECVRETOPTS:
					OPTSET(IN6P_RECVRETOPTS);
					break;
d1255 3
a1257 3
				case IPV6_RECVDSTADDR:
					OPTSET(IN6P_RECVDSTADDR);
					break;
d1259 3
a1261 3
				case IPV6_PKTINFO:
					OPTSET(IN6P_PKTINFO);
					break;
d1263 3
a1265 3
				case IPV6_HOPLIMIT:
					OPTSET(IN6P_HOPLIMIT);
					break;
d1267 3
a1269 3
				case IPV6_HOPOPTS:
					OPTSET(IN6P_HOPOPTS);
					break;
d1271 3
a1273 3
				case IPV6_DSTOPTS:
					OPTSET(IN6P_DSTOPTS);
					break;
d1275 3
a1277 3
				case IPV6_RTHDR:
					OPTSET(IN6P_RTHDR);
					break;
d1279 3
a1281 3
				case IPV6_FAITH:
					OPTSET(IN6P_FAITH);
					break;
d1283 4
a1286 4
				case IPV6_V6ONLY:
					if (!optval)
						error = EINVAL;
					break;
d1303 2
d1307 2
a1308 2
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags &= ~(IN6P_HIGHPORT);
d1312 2
a1313 2
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags |= IN6P_HIGHPORT;
d1317 2
a1318 2
					inp->inp_flags &= ~(IN6P_HIGHPORT);
					inp->inp_flags |= IN6P_LOWPORT;
d1325 2
d1424 11
d1437 1
d1442 1
a1442 1
					    M_COPYALL, M_WAIT);
d1455 1
a1455 1
				/* FALLTHROUGH */
d1463 1
a1464 1
			case IPV6_V6ONLY:
d1506 4
a1513 4
				case IPV6_V6ONLY:
					optval = (ip6_v6only != 0); /* XXX */
					break;

a1606 76
int
ip6_raw_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	int error = 0, optval, optlen;
	const int icmp6off = offsetof(struct icmp6_hdr, icmp6_cksum);
	struct inpcb *inp = sotoinpcb(so);
	struct mbuf *m = *mp;

	optlen = m ? m->m_len : 0;

	if (level != IPPROTO_IPV6) {
		if (op == PRCO_SETOPT && *mp)
			(void)m_free(*mp);
		return(EINVAL);
	}
		
	switch (optname) {
	case IPV6_CHECKSUM:
		/*
		 * For ICMPv6 sockets, no modification allowed for checksum
		 * offset, permit "no change" values to help existing apps.
		 *
		 * XXX 2292bis says: "An attempt to set IPV6_CHECKSUM
		 * for an ICMPv6 socket will fail."
		 * The current behavior does not meet 2292bis.
		 */
		switch (op) {
		case PRCO_SETOPT:
			if (optlen != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);
			if ((optval % 2) != 0) {
				/* the API assumes even offset values */
				error = EINVAL;
			} else if (so->so_proto->pr_protocol ==
			    IPPROTO_ICMPV6) {
				if (optval != icmp6off)
					error = EINVAL;
			} else
				inp->in6p_cksum = optval;
			break;

		case PRCO_GETOPT:
			if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
				optval = icmp6off;
			else
				optval = inp->in6p_cksum;

			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(int);
			*mtod(m, int *) = optval;
			break;

		default:
			error = EINVAL;
			break;
		}
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}

	if (op == PRCO_SETOPT && m)
		(void)m_free(m);

	return(error);
}

d1627 2
a1628 1
	} else
a1680 2
		if (im6o == NULL)
			return(ENOBUFS);
d1698 1
a1698 1
		bcopy(mtod(m, u_int *), &ifindex, sizeof(ifindex));
d1721 1
a1721 1
		bcopy(mtod(m, u_int *), &optval, sizeof(optval));
d1736 2
a1737 6
		if (m == NULL || m->m_len != sizeof(u_int)) {
			error = EINVAL;
			break;
		}
		bcopy(mtod(m, u_int *), &loop, sizeof(loop));
		if (loop > 1) {
d1792 2
a1793 1
			} else {
d1824 2
a1825 2
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
d1834 1
a1834 1
			    &mreq->ipv6mr_multiaddr))
d1844 5
a1848 2
		imm = in6_joingroup(ifp, &mreq->ipv6mr_multiaddr, &error);
		if (!imm)
d1850 1
d1889 2
a1890 2
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
d1897 2
a1898 1
			if ((ifp == NULL || imm->i6mm_maddr->in6m_ifp == ifp) &&
d1900 1
a1900 1
			    &mreq->ipv6mr_multiaddr))
d1913 2
a1914 1
		in6_leavegroup(imm);
d1997 3
a1999 1
		in6_leavegroup(imm);
d2031 1
a2031 1
	    control->m_len -= CMSG_ALIGN(cm->cmsg_len)) {
d2038 1
a2038 1
		switch (cm->cmsg_type) {
d2048 2
a2049 2
			if (opt->ip6po_pktinfo->ipi6_ifindex > if_index ||
			    opt->ip6po_pktinfo->ipi6_ifindex < 0) {
d2094 1
a2094 2
			bcopy(CMSG_DATA(cm), &opt->ip6po_hlim,
			    sizeof(opt->ip6po_hlim));
d2102 1
a2102 2

			/* check if cmsg_len is large enough for sa_len */
d2104 1
d2133 1
a2133 1
				    (struct ip6_dest *)CMSG_DATA(cm);
d2135 2
a2136 1
				    CMSG_LEN((opt->ip6po_dest1->ip6d_len + 1) << 3));
d2141 1
a2141 1
				    (struct ip6_dest *)CMSG_DATA(cm);
d2143 2
a2144 1
				    CMSG_LEN((opt->ip6po_dest2->ip6d_len + 1) << 3))
d2156 1
a2156 1
			switch (opt->ip6po_rthdr->ip6r_type) {
d2255 2
d2258 2
a2259 2
ip6_optlen(inp)
	struct inpcb *inp;
d2263 1
a2263 1
	if (!inp->inp_outputopts6)
d2270 4
a2273 4
	len += elen(inp->inp_outputopts6->ip6po_hbh);
	len += elen(inp->inp_outputopts6->ip6po_dest1);
	len += elen(inp->inp_outputopts6->ip6po_rthdr);
	len += elen(inp->inp_outputopts6->ip6po_dest2);
d2277 2
@


1.56.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.56.2.2 2002/06/11 03:31:37 art Exp $	*/
d789 1
a789 1
#if NPF > 0
d798 1
a798 1
#endif
d937 1
a937 1
	return (error);
d959 1
a959 1
		return (ENOBUFS); /* XXX */
d963 1
a963 1
		return (ENOBUFS);
d969 1
a969 1
			return (ENOBUFS);
d977 1
a977 1
	return (0);
d989 1
a989 1
	u_int8_t *optbuf;
d1003 1
a1003 1
			return (ENOBUFS);
d1005 1
a1005 1
		optbuf = mtod(mopt, u_int8_t *);
d1027 1
a1027 1
				return (ENOBUFS);
d1042 1
a1042 1
				return (ENOBUFS);
d1046 1
a1046 1
			optbuf = mtod(n, u_int8_t *) + oldoptlen;
d1050 1
a1050 1
			optbuf = mtod(mopt, u_int8_t *) + mopt->m_len;
d1054 1
a1054 1
		optbuf[1] = 0;
d1073 1
a1073 1
	return (0);
d1092 1
a1092 1
			return (ENOBUFS);
d1114 1
a1114 1
			return (ENOBUFS);
d1120 1
a1120 1
	return (0);
d1183 1
a1183 1
	return (error);
d1219 1
a1219 1
				return (ip6_pcbopts(&inp->inp_outputopts6,
d1370 1
a1370 1
				if (optval < IPSEC_LEVEL_BYPASS ||
d1375 1
a1375 1

d1600 1
a1600 1
	return (error);
d1620 1
a1620 1
		return (EINVAL);
d1622 1
a1622 1

d1676 1
a1676 1
	return (error);
d1711 1
a1711 1
		return (0);
d1719 1
a1719 1
		return (error);
d1722 1
a1722 1
	return (0);
d1753 1
a1753 1
			return (ENOBUFS);
d2003 1
a2003 1
	return (error);
d2028 1
a2028 1
		return (0);
d2037 1
a2037 1
		return (0);
d2046 1
a2046 1
		return (0);
d2049 1
a2049 1
		return (EOPNOTSUPP);
d2084 1
a2084 1
		return (EINVAL);
d2094 1
a2094 1
		return (EINVAL);
d2102 1
a2102 1
			return (EINVAL);
d2109 1
a2109 1
				return (EINVAL);
d2118 1
a2118 1
				return (ENXIO);
d2141 1
a2141 1
					return (EADDRNOTAVAIL);
d2145 1
a2145 1
					return (EADDRNOTAVAIL);
d2154 1
a2154 1
					return (EADDRNOTAVAIL);
d2160 1
a2160 1
				return (EINVAL);
d2165 1
a2165 1
				return (EINVAL);
d2170 1
a2170 1
				return (EPERM);
d2175 1
a2175 1
				return (EINVAL);
d2183 1
a2183 1
				return (EINVAL);
d2187 1
a2187 1
				return (EINVAL);
d2192 1
a2192 1
				return (EINVAL);
d2205 1
a2205 1
					return (EINVAL);
d2212 1
a2212 1
					return (EINVAL);
d2218 1
a2218 1
				return (EINVAL);
d2222 1
a2222 1
				return (EINVAL);
d2226 1
a2226 1
					return (EINVAL);
d2229 1
a2229 1
				return (EINVAL);
d2234 1
a2234 1
			return (ENOPROTOOPT);
d2238 1
a2238 1
	return (0);
@


1.56.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1707 2
a1708 1
		free(opt, M_IP6OPT);
a1718 1
		free(opt, M_IP6OPT);
@


1.55
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.54 2001/11/28 10:48:13 itojun Exp $	*/
d563 1
a563 1
		        tdb_add_inp(tdb, inp, 0);
d820 2
a821 3
		 * of source add destination, which should already be assured
		 * Larger scopes than link will be supported in the near
		 * future.
d971 2
a972 1
		 * make new header and copy data of each part and link onto chain.
d1842 2
a1843 1
			if (suser(p->p_ucred, &p->p_acflag)) {
d1947 2
a1948 1
			if (suser(p->p_ucred, &p->p_acflag)) {
@


1.54
log
@typo in sockopt level name (ipsec6 related)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.53 2001/11/26 16:50:26 jasoni Exp $	*/
a914 4
#ifdef OLDIP6OUTPUT
		error = (*ifp->if_output)(ifp, m, (struct sockaddr *)dst,
					  ro->ro_rt);
#else
a915 1
#endif
a1030 5
#ifdef OLDIP6OUTPUT
			error = (*ifp->if_output)(ifp, m,
						  (struct sockaddr *)dst,
						  ro->ro_rt);
#else
a1031 1
#endif
@


1.53
log
@add fastroute options similar to what is found in ipf
ok dhartmei@@, frantzen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.52 2001/10/01 16:03:09 jasoni Exp $	*/
d1664 1
a1664 1
				case IP_AUTH_LEVEL:
d1668 1
a1668 1
				case IP_ESP_TRANS_LEVEL:
d1673 1
a1673 1
				case IP_ESP_NETWORK_LEVEL:
d1678 1
a1678 1
				case IP_IPCOMP_LEVEL:
@


1.52
log
@reinitialize ip6_hdr pointer after pf_test; ok dhartmei@@ (noticed after
discussion with itojun on ip6_forward)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.51 2001/09/25 14:54:31 jasoni Exp $	*/
d884 2
a885 2
        if (pf_test6(PF_OUT, ifp, &m) != PF_PASS) {
                error = EHOSTUNREACH;
d887 4
a890 2
                goto done;
        }
@


1.51
log
@free mbuf when dropping a packet. ok dhartmei@@ (also checked by
mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.50 2001/09/15 03:54:40 frantzen Exp $	*/
d889 1
@


1.50
log
@IPv6 support from Ryan McBride (mcbride@@countersiege.com)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.49 2001/08/22 14:18:36 niklas Exp $	*/
d886 1
@


1.49
log
@IPCOMP policy stuff missed the last time round
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.48 2001/08/22 06:52:01 niklas Exp $	*/
d68 2
d94 4
d882 7
@


1.48
log
@Add IPCOMP setsockopt policy controls.  While here fix the other policies too
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.47 2001/08/21 06:53:36 angelos Exp $	*/
d1640 1
d1659 4
@


1.47
log
@Don't check for BYPASS options in PCB on ip_output/ip6_output --- this
is already done in ip_spd_lookup()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.46 2001/06/27 03:49:54 angelos Exp $	*/
d104 1
d1413 1
d1430 1
a1430 1
				case IP_AUTH_LEVEL:
d1439 1
a1439 1
				case IP_ESP_TRANS_LEVEL:
d1448 1
a1448 1
				case IP_ESP_NETWORK_LEVEL:
d1455 9
@


1.46
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.45 2001/06/27 01:36:02 angelos Exp $	*/
a251 16
		/*
		 * If the socket has set the bypass flags and SA destination
		 * matches the IP destination, skip IPsec. This allows
		 * IKE packets to travel through IPsec tunnels.
		 */
		if (inp != NULL && 
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS &&
		    sdst.sa.sa_family == AF_INET6 &&
		    IN6_ARE_ADDR_EQUAL(&sdst.sin6.sin6_addr, &ip6->ip6_dst)) {
			splx(s);
		        sproto = 0; /* mark as no-IPsec-needed */
			goto done_spd;
		}

@


1.45
log
@Don't check cached TDBs on the PCB -- always call ipsp_spd_lookup();
this simplifies the logic a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.44 2001/06/25 17:16:27 angelos Exp $	*/
d2313 1
a2313 1
		M_COPY_PKTHDR(mh, m);
@


1.44
log
@If a PENDING_TDB tag is attached but no TDB is found, drop the packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.43 2001/06/25 06:14:18 angelos Exp $	*/
d210 4
a213 9
	if (inp && inp->inp_tdb_out &&
	    inp->inp_tdb_out->tdb_dst.sa.sa_family == AF_INET6 &&
	    IN6_ARE_ADDR_EQUAL(&inp->inp_tdb_out->tdb_dst.sin6.sin6_addr,
		  &ip6->ip6_dst)) {
	        tdb = inp->inp_tdb_out;
	} else {
		/* Do we have any pending SAs to apply ? */
		mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
		if (mtag != NULL) {
d215 3
a217 4
			if (mtag->m_tag_len != sizeof (struct tdb_ident))
				panic("ip6_output: tag of length %d (should "
				    "be %d", mtag->m_tag_len,
				    sizeof (struct tdb_ident));
d219 5
a223 10
			tdbi = (struct tdb_ident *)(mtag + 1);
			tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
			if (tdb == NULL)
				error = -EINVAL;
			m_tag_delete(m, mtag);
		}
		else
			tdb = ipsp_spd_lookup(m, AF_INET6,
			    sizeof(struct ip6_hdr), &error,
			    IPSP_DIRECTION_OUT, NULL, inp);
d225 3
@


1.43
log
@PENDING_TDB tag handling (same as ip_output)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.42 2001/06/25 02:59:02 angelos Exp $	*/
d227 2
@


1.42
log
@Don't double-clear M_PKTHDR/tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.41 2001/06/09 06:43:38 angelos Exp $	*/
d216 17
a232 2
	        tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
	            &error, IPSP_DIRECTION_OUT, NULL, NULL);
@


1.41
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.40 2001/05/30 12:31:09 angelos Exp $	*/
a2305 2
		m->m_flags &= ~M_PKTHDR;
		m_tag_init(m);
@


1.40
log
@Update for new prototypes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.39 2001/05/28 06:45:32 angelos Exp $	*/
a104 2

#include <net/net_osdep.h>
@


1.39
log
@Remove unused code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.38 2001/05/28 05:28:22 angelos Exp $	*/
d570 1
a570 2
		/* XXX Should use last argument */
		error = ipsp_process_packet(m, tdb, AF_INET6, 0, NULL);
@


1.38
log
@Don't check for IPV6_ENCAPSULATED, no longer needed since we have the tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.37 2001/05/28 05:27:30 angelos Exp $	*/
a528 42
#if 0 /*KAME IPSEC*/
	if (needipsec && needipsectun) {
		struct ipsec_output_state state;

		bzero(&exthdrs, sizeof(exthdrs));
		exthdrs.ip6e_ip6 = m;

		bzero(&state, sizeof(state));
		state.m = m;
		state.ro = (struct route *)ro;
		state.dst = (struct sockaddr *)dst;

		error = ipsec6_output_tunnel(&state, sp, flags);

		m = state.m;
		ro = (struct route_in6 *)state.ro;
		dst = (struct sockaddr_in6 *)state.dst;
		if (error) {
			/* mbuf is already reclaimed in ipsec6_output_tunnel. */
			m0 = m = NULL;
			m = NULL;
			switch (error) {
			case EHOSTUNREACH:
			case ENETUNREACH:
			case EMSGSIZE:
			case ENOBUFS:
			case ENOMEM:
				break;
			default:
				printf("ip6_output (ipsec): error code %d\n", error);
				/*fall through*/
			case ENOENT:
				/* don't show these error codes to the user */
				error = 0;
				break;
			}
			goto bad;
		}

		exthdrs.ip6e_ip6 = m;
	}
#endif /*IPSEC*/
d550 2
a551 2
			 * XXX what should we do if ip6_hlim == 0 and the packet
			 * gets tunnelled?
@


1.37
log
@Missed a DPRINTF().
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.36 2001/05/28 05:26:53 angelos Exp $	*/
a200 4
	/* This is kept mostly for historical reasons */
	if (flags & IPV6_ENCAPSULATED)
		goto done_spd;

@


1.36
log
@Use packet tags to detect loops, same as ip_output()
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.35 2001/05/26 06:57:20 angelos Exp $	*/
a278 1
				DPRINTF(("ip6_output: IPsec loop detected, skipping further IPsec processing for this packet.\n"));
@


1.35
log
@Use m_tag_init() to initialize new mbuf m_pkthdr fields, rather than
having to change it every time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.34 2001/05/20 08:36:01 angelos Exp $	*/
d162 1
d164 1
d201 1
a201 1
	/* Disallow nested IPsec for now */
a248 6
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
	        splx(s);

d260 1
d265 24
a288 1
		/* XXX Take into consideration socket requirements ? */
@


1.34
log
@Convert from tdbi to packet tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.33 2001/05/16 12:53:36 ho Exp $	*/
d2337 1
a2337 1
		TAILQ_INIT(&m->m_pkthdr.tags);
@


1.33
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.32 2001/04/14 00:30:59 angelos Exp $	*/
d2337 1
a2337 1
		m->m_pkthdr.tdbi = NULL;
@


1.32
log
@Minor changes, preparing for real socket-attached TDBs; also, more
information will be stored in the TDB. ok ho@@ provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.31 2001/04/11 04:49:23 itojun Exp $	*/
a1777 2
		if (im6o == NULL)
			return(ENOBUFS);
d1941 1
a1941 4
		if (imm == NULL) {
			error = ENOBUFS;
			break;
		}
@


1.31
log
@disallow userland programs from specifying addresses with IPV6_PKTINFO
setsockopt, if:
- the address is not verified by DAD (= not ready)
- the address is an anycast address (= not permitted as source)
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.30 2001/03/30 11:09:02 itojun Exp $	*/
d597 2
a598 1
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
@


1.30
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.29 2001/03/28 20:03:08 angelos Exp $	*/
d2154 2
a2155 1
			 * unicast address assigned to the node.
d2159 1
d2174 5
@


1.29
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.28 2001/03/25 09:56:00 itojun Exp $	*/
d875 4
a878 11
#ifndef FAKE_LOOPBACK_IF
	if ((ifp->if_flags & IFF_LOOPBACK) == 0)
#else
	if (1)
#endif
	{
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;
	}
d2304 5
a2308 12
#ifndef FAKE_LOOPBACK_IF
	if ((ifp->if_flags & IFF_LOOPBACK) == 0)
#else
	if (1)
#endif
	{
		ip6 = mtod(copym, struct ip6_hdr *);
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			ip6->ip6_src.s6_addr16[1] = 0;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			ip6->ip6_dst.s6_addr16[1] = 0;
	}
@


1.28
log
@re-initialize mopt in ip6_insert_jumboopt().  sync with kame
From: csapuntz@@stanford.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.27 2001/03/21 15:01:09 itojun Exp $	*/
d214 3
a216 3
	if (inp && inp->inp_tdb &&
	    inp->inp_tdb->tdb_dst.sa.sa_family == AF_INET6 &&
	    IN6_ARE_ADDR_EQUAL(&inp->inp_tdb->tdb_dst.sin6.sin6_addr,
d218 1
a218 1
	        tdb = inp->inp_tdb;
d590 4
d1442 1
a1442 1
					    tdbip->proto);
d1446 1
a1446 1
						tdb_add_inp(tdb, inp);
d1654 1
a1654 1
				if (inp->inp_tdb == NULL) {
d1657 3
a1659 3
					tdbi.spi = inp->inp_tdb->tdb_spi;
					tdbi.dst = inp->inp_tdb->tdb_dst;
					tdbi.proto = inp->inp_tdb->tdb_sproto;
d2348 1
@


1.27
log
@set rmx_mtu to L2 interface mtu, instead of 0, on mtudisc timeout.
ip6_output() change is for safety.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.26 2001/03/13 03:35:15 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.171 2001/03/21 07:30:48 itojun Exp $	*/
d1189 1
a1189 1
			exthdrs->ip6e_hbh = n;
@


1.26
log
@add/clearify spl for ipsec6.  sync with kame.  reviewed by angelos.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.25 2001/02/16 16:38:15 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.169 2001/03/13 03:10:12 itojun Exp $	*/
d812 1
a812 1
		if (mtu > ifmtu) {
d820 3
@


1.25
log
@get rid of #ifdef IPV6FIREWALL (never used, will never be used)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.24 2001/02/16 14:58:13 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.164 2001/02/10 05:05:15 itojun Exp $	*/
d251 1
a263 1
		        splx(s);
d584 1
@


1.24
log
@cosmetic/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.23 2001/02/16 08:48:06 itojun Exp $	*/
a107 4
#ifdef IPV6FIREWALL
#include <netinet6/ip6_fw.h>
#endif

a878 19
#ifdef IPV6FIREWALL
	/*
	 * Check with the firewall...
	 */
	if (ip6_fw_chk_ptr) {
		u_short port = 0;
		m->m_pkthdr.rcvif = NULL;	/*XXX*/
		/* If ipfw says divert, we have to just drop packet */
		if ((*ip6_fw_chk_ptr)(&ip6, ifp, &port, &m)) {
			m_freem(m);
			goto done;
		}
		if (!m) {
			error = EACCES;
			goto done;
		}
	}
#endif

a1423 15
#ifdef IPV6FIREWALL
			case IPV6_FW_ADD:
			case IPV6_FW_DEL:
			case IPV6_FW_FLUSH:
			case IPV6_FW_ZERO:
			    {
				if (ip6_fw_ctl_ptr == NULL) {
					if (m) (void)m_free(m);
					return EINVAL;
				}
				error = (*ip6_fw_ctl_ptr)(optname, mp);
				m = *mp;
			    }
				break;
#endif
a1639 14

#ifdef IPV6FIREWALL
			case IPV6_FW_GET:
			  {
				if (ip6_fw_ctl_ptr == NULL)
			        {
					if (m)
						(void)m_free(m);
					return EINVAL;
				}
				error = (*ip6_fw_ctl_ptr)(optname, mp);
			  }
				break;
#endif
@


1.23
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.22 2001/02/16 08:22:06 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.152 2001/02/02 15:36:33 jinmei Exp $	*/
a2407 1

@


1.22
log
@kill register declarations.  to sync with kame better.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.21 2001/02/08 18:46:23 itojun Exp $	*/
d136 4
@


1.21
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.20 2001/02/06 01:26:58 itojun Exp $	*/
d1290 2
a1291 2
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;
d1758 1
a1758 1
	register struct mbuf *m;
d1761 1
a1761 1
	register struct ip6_pktopts *opt = *pktopt;
d2088 2
a2089 2
	register struct ip6_moptions *im6o;
	register struct mbuf **mp;
d2134 1
a2134 1
	register struct ip6_moptions *im6o;
d2159 1
a2159 1
	register struct cmsghdr *cm = 0;
d2322 2
a2323 2
	register struct mbuf *m;
	register struct sockaddr_in6 *dst;
@


1.20
log
@bad semicolon after "if" conditional.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.19 2001/02/06 00:22:23 mickey Exp $	*/
d1382 1
a1382 1
						inp->inp_csumoffset = optval;
d1626 1
a1626 1
					optval = inp->inp_csumoffset;
@


1.19
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.18 2001/02/02 15:55:18 itojun Exp $	*/
d862 1
a862 1
		if (origifp == NULL);
@


1.18
log
@avoid panic when packet to nonexistent link-local address is issued.
kame 1.151 -> 1.152.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.17 2000/10/11 09:14:15 itojun Exp $	*/
a105 2
#include "loop.h"

a128 2
extern struct ifnet *loifp;
extern struct ifnet loif[NLOOP];
d692 1
a692 1
				ifp = &loif[0];
d1935 1
a1935 1
				ifp = &loif[0];
d2317 1
a2317 1
 * pointer that might NOT be &loif -- easier than replicating that code here.
@


1.17
log
@nuke inp_flags bits for controlling IPv4 mapped address.
we don't support IPv4 mapped address,
and there are inconsistent bit manipulation code so it's safer to nuke them.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.16 2000/09/19 03:23:16 angelos Exp $	*/
/*	$KAME: ip6_output.c,v 1.122 2000/08/19 02:12:02 jinmei Exp $	*/
d849 1
d854 13
a866 1
		else
@


1.16
log
@Added files, and IPv6-IPsec update.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.15 2000/09/16 13:58:23 itojun Exp $	*/
a1390 11
				/*
				 * XXX: setting the flag would be redundant
				 *      except at the first time. Also, we
				 *      actually don't have to reset the flag,
				 *      since ip6_freemoptions() would simply
				 *      return when the inp_moptions6 is NULL.
				 */
				if (inp->inp_moptions6)
					inp->inp_flags |= INP_IPV6_MCAST;
				else
					inp->inp_flags &= ~INP_IPV6_MCAST;
@


1.15
log
@repair IPv6 multicasting.  INP_IPV6_MCAST is necessary.
(i will try to remove this flag bit later)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.14 2000/08/19 09:17:36 itojun Exp $	*/
a167 1
	u_int8_t sa_require = 0, sa_have = 0;
d225 1
a225 1
	            &error);
d272 1
a272 5
		/* What are the socket (or default) security requirements ? */
		if (inp == NULL)
		        sa_require = get_sa_require(NULL);
		else
		        sa_require = inp->inp_secrequire;
d274 1
a274 12
		/*
		 * Now we check if this tdb has all the transforms which
		 * are required by the socket or our default policy.
		 */
		SPI_CHAIN_ATTRIB(sa_have, tdb_onext, tdb);
		splx(s);
		if (sa_require & ~sa_have) {
			error = EHOSTUNREACH;
			goto freehdrs;
		}

#if 1
@


1.14
log
@- upgrade icmp6 node information query support to 06 draft.
- pedant: possible alignment issue in ALIGN > 8 arch (should be okay for now)
(sync with kame)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.13 2000/06/20 20:51:26 itojun Exp $	*/
d1407 11
@


1.13
log
@confirmed interop of IPv6 AH with KAME (both global and scoped addr).
remove restriction on scoped IPv6 address.

TODO: confirm it with other IPv6 AH implementation.  since we use very
similar logic between KAME IPv6 AH and OpenBSD IPv6 AH, it is possible that
both side is making the same mistake or whatever
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.12 2000/06/20 01:27:24 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.112 2000/06/18 01:50:39 itojun Exp $	*/
d1153 1
d1176 6
a1181 1
			caddr_t oldoptp = mtod(mopt, caddr_t);
d1183 1
d1185 5
a1189 4
			if (mopt->m_flags & M_EXT)
				return(ENOBUFS); /* XXX */
			MCLGET(mopt, M_DONTWAIT);
			if ((mopt->m_flags & M_EXT) == 0)
d1192 20
a1211 3
			bcopy(oldoptp, mtod(mopt, caddr_t), oldoptlen);
			optbuf = mtod(mopt, caddr_t) + oldoptlen;
			mopt->m_len = oldoptlen + JUMBOOPTLEN;
d1230 2
a1231 1
	*(u_int32_t *)&optbuf[4] = htonl(plen + JUMBOOPTLEN);
@


1.12
log
@initialize hoplimit field properly on ipsec6 case
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.11 2000/06/19 03:43:17 itojun Exp $	*/
a293 7
			error = EHOSTUNREACH;
			goto freehdrs;
		}

		/* scoped address is not supported */
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src) || 
		    IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst)) {
@


1.11
log
@IPv6 IPsec, outbound direction.

restriction: if there's any extension header (except fragment)
and outbound packet matches tdb, we can't encrypt it.
packet will not go out of the node (dropped).
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.10 2000/06/18 17:31:14 itojun Exp $	*/
d297 7
d590 18
@


1.10
log
@allow IPsec-related get/setsockopt on IPv6 socket.  due to number conflict
they must be IPV6_xx instead of IP_xx.

actually, since in_ctloutput() does not check address family of inpcb,
getsockopt(IPPROTO_IP, IP_xx) may work - never tested this.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.9 2000/06/18 02:00:20 itojun Exp $	*/
d92 13
a104 1
#undef IPSEC
d164 1
a164 1
	int needipsec = 0;
a165 1
	u_int8_t sproto = 0;
d204 8
d215 2
a216 2
	 * If the higher-level protocol has cached the SA to use, we
	 * can avoid the routing lookup if the source address is zero.
d218 9
a226 7
	if (inp != NULL && inp->inp_tdb != NULL &&
	    ip->ip_src.s_addr == INADDR_ANY &&
	    tdb->tdb_dst.sa.sa_family == AF_INET &&
	    tdb->tdb_dst.sin.sin_addr.s_addr != AF_INET) {
	        ip->ip_src.s_addr = tdb->tdb_dst.sin.sin_addr.s_addr;
		splx(s);
		goto skip_routing;
d229 2
a230 2
	splx(s);
#endif /* IPSEC */
d232 6
a237 6
#ifdef IPSEC
	/* get a security policy for this packet */
	if (so == NULL)
		sp = ipsec6_getpolicybyaddr(m, IPSEC_DIR_OUTBOUND, 0, &error);
	else
		sp = ipsec6_getpolicybysock(m, IPSEC_DIR_OUTBOUND, so, &error);
d239 9
a247 4
	if (sp == NULL) {
		ipsec6stat.out_inval++;
		goto bad;
	}
d249 7
a255 1
	error = 0;
a256 3
	/* check policy */
	switch (sp->policy) {
	case IPSEC_POLICY_DISCARD:
d258 3
a260 1
		 * This packet is just discarded.
d262 16
a277 2
		ipsec6stat.out_polvio++;
		goto bad;
d279 9
a287 12
	case IPSEC_POLICY_BYPASS:
	case IPSEC_POLICY_NONE:
		/* no need to do IPsec. */
		needipsec = 0;
		break;
	
	case IPSEC_POLICY_IPSEC:
		if (sp->req == NULL) {
			/* XXX should be panic ? */
			printf("ip6_output: No IPsec request specified.\n");
			error = EINVAL;
			goto bad;
a288 2
		needipsec = 1;
		break;
d290 8
a297 3
	case IPSEC_POLICY_ENTRUST:
	default:
		printf("ip6_output: Invalid policy found. %d\n", sp->policy);
d299 3
d320 1
a320 1
	if ((needipsec || optlen) && !hdrsplit) {
d1687 1
a1687 1
					    np->inp_seclevel[SL_ESP_TRANS];
@


1.9
log
@correct indentation for IPV6_PORTRANGE
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.8 2000/06/03 13:43:45 itojun Exp $	*/
d153 9
d164 3
a166 8
	int needipsectun = 0;
	struct socket *so;
	struct secpolicy *sp = NULL;

	/* for AH processing. stupid to have "socket" variable in IP layer... */
	so = (struct socket *)m->m_pkthdr.rcvif;
	m->m_pkthdr.rcvif = NULL;
	ip6 = mtod(m, struct ip6_hdr *);
d193 19
d361 1
a361 1
#ifdef IPSEC
d486 1
a486 1
#ifdef IPSEC
a489 8
		/*
		 * All the extension headers will become inaccessible
		 * (since they can be encrypted).
		 * Don't panic, we need no more updates to extension headers
		 * on inner IPv6 packet (since they are now encapsulated).
		 *
		 * IPv6 [ESP|AH] IPv6 [extension headers] payload
		 */
d528 23
a1033 5
#ifdef IPSEC
	if (sp != NULL)
		key_freesp(sp);
#endif /* IPSEC */

d1209 6
d1346 1
a1346 1
#ifdef IPSEC
d1373 71
d1575 1
a1575 1
#ifdef IPSEC
d1603 47
@


1.8
log
@deep-copy ip6 header on ip6_mloopback, to avoid overwriting cluster mbuf.
correct frag header append operation.
some cosmetic (like do {} while (0) to multiline macro)
(sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.7 2000/05/19 20:12:10 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.110 2000/06/03 12:43:49 itojun Exp $	*/
d1278 2
a1279 2
		case IPV6_PORTRANGE:
			optval = *mtod(m, int *);
d1283 5
a1287 5
			switch (optval) {
			case IPV6_PORTRANGE_DEFAULT:
				in6p->in6p_flags &= ~(IN6P_LOWPORT);
				in6p->in6p_flags &= ~(IN6P_HIGHPORT);
				break;
d1289 4
a1292 4
			case IPV6_PORTRANGE_HIGH:
				in6p->in6p_flags &= ~(IN6P_LOWPORT);
				in6p->in6p_flags |= IN6P_HIGHPORT;
				break;
d1294 4
a1297 4
			case IPV6_PORTRANGE_LOW:
				in6p->in6p_flags &= ~(IN6P_HIGHPORT);
				in6p->in6p_flags |= IN6P_LOWPORT;
				break;
d1299 4
a1302 4
			default:
				error = EINVAL;
				break;
			}
d1305 1
a1305 1
			break;
@


1.7
log
@correct "telnet fe80::1%lo0".
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.6 2000/05/19 13:55:17 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.104 2000/05/19 19:10:07 itojun Exp $	*/
d165 2
a166 2
#define MAKE_EXTHDR(hp,mp)						\
    {									\
d174 1
a174 1
    }
d313 2
a314 2
#define MAKE_CHAIN(m,mp,p,i)\
    {\
d325 1
a325 1
    }
d1140 1
a1140 1
	    M_TRAILINGSPACE(mlast) < sizeof(struct ip6_frag)) {
d1187 1
d2083 2
a2084 1
	struct	mbuf *copym;
d2087 13
a2099 2
	if (copym != NULL) {
		(void)looutput(ifp, copym, (struct sockaddr *)dst, NULL);
d2101 22
@


1.6
log
@never forward packet with link-local address.
experimental support for new loopback packet handling (with FAKE_LOOPBACK_IF,
rcvif will be set to real outgoing interface, not the loopback, to honor scope)
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_output.c,v 1.5 2000/05/19 05:14:45 itojun Exp $	*/
/*	$KAME: ip6_output.c,v 1.103 2000/05/19 05:13:21 itojun Exp $	*/
d771 1
a771 1
	if ((ifp->if_flags & IFF_LOOPBACK) != 0)
@


1.5
log
@NULL != 0.  from netbsd-current.
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_output.c,v 1.4 2000/02/07 06:09:10 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d139 1
a139 1
	struct ifnet *ifp;
d512 1
a512 1
#endif /*IPESC*/
d526 1
a526 1
			 * NetBSD/OpenBSD always clones routes, if parent is
d547 2
a548 2
		 * Check if there is the outgoing interface conflicts with
		 * the interface specified by ifi6_ifindex(if specified).
d550 2
a551 2
		 * (this happens when we are sending packet toward my
		 * interface)
d744 32
a775 4
	/*
	 * Fake link-local scope-class addresses
	 */
	if ((ifp->if_flags & IFF_LOOPBACK) == 0) {
d788 1
d835 1
a835 1
	 * If necessary, do IPv6 fragmentation before sending. 
d849 1
a849 1
	    
d858 1
a858 1
		error = nd6_output(ifp, m, dst, ro->ro_rt);
d903 1
a903 2
		}
		else if (exthdrs.ip6e_dest1) {
d906 1
a906 2
		}
		else if (exthdrs.ip6e_hbh) {
d909 1
a909 2
		}
		else {
d980 1
a980 1
			error = nd6_output(ifp, m, dst, ro->ro_rt);
d982 1
a982 2
		}
		else
d1045 1
a1045 1
 * Insert jumbo payload option. 
d1071 1
a1071 2
	}
	else {
d1088 1
a1088 2
		}
		else {
d1132 1
a1132 2
	}
	else
d1146 1
a1146 2
	}
	else {
d1956 4
d1998 1
d2000 1
@


1.4
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.3 1999/12/20 07:49:06 itojun Exp $	*/
d673 1
a673 1
				if (ip6_mforward(ip6, ifp, m) != NULL) {
@


1.4.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: ip6_output.c,v 1.32 2001/04/14 00:30:59 angelos Exp $	*/
/*	$KAME: ip6_output.c,v 1.172 2001/03/25 09:55:56 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d91 3
a93 13
#ifdef IPSEC
#include <netinet/ip_ah.h>
#include <netinet/ip_esp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <net/pfkeyv2.h>

extern u_int8_t get_sa_require  __P((struct inpcb *));

extern int ipsec_auth_default_level;
extern int ipsec_esp_trans_default_level;
extern int ipsec_esp_network_default_level;
#endif /* IPSEC */
d97 4
d118 2
a126 4
 *
 * type of "mtu": rt_rmx.rmx_mtu is u_long, ifnet.ifr_mtu is int, and
 * nd_ifinfo.linkmtu is u_int32_t.  so we use u_long to hold largest one,
 * which is rt_rmx.rmx_mtu.
d138 1
a138 1
	struct ifnet *ifp, *origifp;
d151 2
a152 1
	u_int8_t sproto = 0;
d154 3
a156 6
	union sockaddr_union sdst;
	u_int32_t sspi;
	struct inpcb *inp;
	struct tdb *tdb;
	int s;
#endif /* IPSEC */
d158 4
a161 4
#ifdef IPSEC
	inp = NULL;	/*XXX*/
	if (inp && (inp->inp_flags & INP_IPV6) == 0)
		panic("ip6_output: IPv4 pcb is passed");
d164 2
a165 2
#define MAKE_EXTHDR(hp, mp)						\
    do {								\
d173 1
a173 1
    } while (0)
d188 5
a192 3
	/* Disallow nested IPsec for now */
	if (flags & IPV6_ENCAPSULATED)
		goto done_spd;
d194 3
a196 19
	/*
	 * splnet is chosen over spltdb because we are not allowed to
	 * lower the level, and udp6_output calls us in splnet(). XXX check
	 */
	s = splnet();

	/*
	 * Check if there was an outgoing SA bound to the flow
	 * from a transport protocol.
	 */
	ip6 = mtod(m, struct ip6_hdr *);
	if (inp && inp->inp_tdb_out &&
	    inp->inp_tdb_out->tdb_dst.sa.sa_family == AF_INET6 &&
	    IN6_ARE_ADDR_EQUAL(&inp->inp_tdb_out->tdb_dst.sin6.sin6_addr,
		  &ip6->ip6_dst)) {
	        tdb = inp->inp_tdb_out;
	} else {
	        tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
	            &error, IPSP_DIRECTION_OUT, NULL, NULL);
d199 1
a199 2
	if (tdb == NULL) {
	        splx(s);
d201 8
a208 6
		if (error == 0) {
		        /*
			 * No IPsec processing required, we'll just send the
			 * packet out.
			 */
		        sproto = 0;
d210 15
a224 9
			/* Fall through to routing/multicast handling */
		} else {
		        /*
			 * -EINVAL is used to indicate that the packet should
			 * be silently dropped, typically because we've asked
			 * key management for an SA.
			 */
		        if (error == -EINVAL) /* Should silently drop packet */
				error = 0;
d226 3
a228 34
			goto freehdrs;
		}
	} else {
	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
	        splx(s);

		/*
		 * If the socket has set the bypass flags and SA destination
		 * matches the IP destination, skip IPsec. This allows
		 * IKE packets to travel through IPsec tunnels.
		 */
		if (inp != NULL && 
		    inp->inp_seclevel[SL_AUTH] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_TRANS] == IPSEC_LEVEL_BYPASS &&
		    inp->inp_seclevel[SL_ESP_NETWORK] == IPSEC_LEVEL_BYPASS &&
		    sdst.sa.sa_family == AF_INET6 &&
		    IN6_ARE_ADDR_EQUAL(&sdst.sin6.sin6_addr, &ip6->ip6_dst)) {
		        sproto = 0; /* mark as no-IPsec-needed */
			goto done_spd;
		}

		/* XXX Take into consideration socket requirements ? */

#if 1 /* XXX */
		/* if we have any extension header, we cannot perform IPsec */
		if (exthdrs.ip6e_hbh || exthdrs.ip6e_dest1 ||
		    exthdrs.ip6e_rthdr || exthdrs.ip6e_dest2) {
			error = EHOSTUNREACH;
			goto freehdrs;
		}
#endif
a229 3

	/* Fall through to the routing/multicast handling code */
 done_spd:
d248 1
a248 1
	if ((sproto || optlen) && !hdrsplit) {
d312 2
a313 2
#define MAKE_CHAIN(m, mp, p, i)\
    do {\
d324 1
a324 1
    } while (0)
d337 1
a337 1
#if 0 /*KAME IPSEC*/
d462 1
a462 1
#if 0 /*KAME IPSEC*/
d466 8
d511 1
a511 48
#endif /*IPSEC*/
#ifdef IPSEC
	/*
	 * Check if the packet needs encapsulation.
	 * ipsp_process_packet will never come back to here.
	 */
	if (sproto != 0) {
	        s = splnet();

		/* fill in IPv6 header which would be filled later */
		if (!IN6_IS_ADDR_MULTICAST(&ip6->ip6_dst)) {
			if (opt && opt->ip6po_hlim != -1)
				ip6->ip6_hlim = opt->ip6po_hlim & 0xff;
		} else {
			if (im6o != NULL)
				ip6->ip6_hlim = im6o->im6o_multicast_hlim;
			else
				ip6->ip6_hlim = ip6_defmcasthlim;
			if (opt && opt->ip6po_hlim != -1)
				ip6->ip6_hlim = opt->ip6po_hlim & 0xff;

			/*
			 * XXX what should we do if ip6_hlim == 0 and the packet
			 * gets tunnelled?
			 */
		}

		tdb = gettdb(sspi, &sdst, sproto);
		if (tdb == NULL) {
			splx(s);
			error = EHOSTUNREACH;
			m_freem(m);
			goto done;
		}

		/* Latch to PCB */
		if (inp)
		        tdb_add_inp(tdb, inp, 0);

		m->m_flags &= ~(M_BCAST | M_MCAST);	/* just in case */

		/* Callee frees mbuf */
		/* XXX Should use last argument */
		error = ipsp_process_packet(m, tdb, AF_INET6, 0, NULL);
		splx(s);
		return error;  /* Nothing more to be done */
	}
#endif /* IPSEC */
d525 1
a525 1
			 * non-bsdi always clone routes, if parent is
d546 2
a547 2
		 * Check if the outgoing interface conflicts with
		 * the interface specified by ifi6_ifindex (if specified).
d549 2
a550 2
		 * (this may happen when we are sending a packet to one of
		 *  our own addresses.)
d607 1
a607 1
				ifp = lo0ifp;
d673 1
a673 1
				if (ip6_mforward(ip6, ifp, m) != 0) {
d726 1
a726 1
		if (mtu > ifmtu || mtu == 0) {
a733 3
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
d743 9
a751 7
	/* Fake scoped addresses */
	if ((ifp->if_flags & IFF_LOOPBACK) != 0) {
		/*
		 * If source or destination address is a scoped address, and
		 * the packet is going to be sent to a loopback interface,
		 * we should keep the original interface.
		 */
d753 15
a767 28
		/*
		 * XXX: this is a very experimental and temporary solution.
		 * We eventually have sockaddr_in6 and use the sin6_scope_id
		 * field of the structure here.
		 * We rely on the consistency between two scope zone ids
		 * of source add destination, which should already be assured
		 * Larger scopes than link will be supported in the near
		 * future.
		 */
		origifp = NULL;
		if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
			origifp = ifindex2ifnet[ntohs(ip6->ip6_src.s6_addr16[1])];
		else if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
			origifp = ifindex2ifnet[ntohs(ip6->ip6_dst.s6_addr16[1])];
		/*
		 * XXX: origifp can be NULL even in those two cases above.
		 * For example, if we remove the (only) link-local address
		 * from the loopback interface, and try to send a link-local
		 * address without link-id information.  Then the source
		 * address is ::1, and the destination address is the
		 * link-local address with its s6_addr16[1] being zero.
		 * What is worse, if the packet goes to the loopback interface
		 * by a default rejected route, the null pointer would be
		 * passed to looutput, and the kernel would hang.
		 * The following last resort would prevent such disaster.
		 */
		if (origifp == NULL)
			origifp = ifp;
d769 1
a769 6
	else
		origifp = ifp;
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;
d805 1
a805 1
	 * If necessary, do IPv6 fragmentation before sending.
d819 1
a819 1
	
d828 1
a828 1
		error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
d873 2
a874 1
		} else if (exthdrs.ip6e_dest1) {
d877 2
a878 1
		} else if (exthdrs.ip6e_hbh) {
d881 2
a882 1
		} else {
d953 1
a953 1
			error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
d955 2
a956 1
		} else
d970 5
d1019 1
a1019 1
 * Insert jumbo payload option.
a1027 1
	u_int32_t v;
d1045 2
a1046 1
	} else {
d1051 1
a1051 6
			/*
			 * XXX assumption:
			 * - exthdrs->ip6e_hbh is not referenced from places
			 *   other than exthdrs.
			 * - exthdrs->ip6e_hbh is not an mbuf chain.
			 */
a1052 1
			struct mbuf *n;
d1054 4
a1057 5
			/*
			 * XXX: give up if the whole (new) hbh header does
			 * not fit even in an mbuf cluster.
			 */
			if (oldoptlen + JUMBOOPTLEN > MCLBYTES)
d1060 5
a1064 21
			/*
			 * As a consequence, we must always prepare a cluster
			 * at this point.
			 */
			MGET(n, M_DONTWAIT, MT_DATA);
			if (n) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_freem(n);
					n = NULL;
				}
			}
			if (!n)
				return(ENOBUFS);
			n->m_len = oldoptlen + JUMBOOPTLEN;
			bcopy(mtod(mopt, caddr_t), mtod(n, caddr_t),
			      oldoptlen);
			optbuf = mtod(n, caddr_t) + oldoptlen;
			m_freem(mopt);
			mopt = exthdrs->ip6e_hbh = n;
		} else {
d1082 1
a1082 2
	v = (u_int32_t)htonl(plen + JUMBOOPTLEN);
	bcopy(&v, &optbuf[4], sizeof(u_int32_t));
d1108 2
a1109 1
	} else
d1117 1
a1117 1
	    M_TRAILINGSPACE(mlast) >= sizeof(struct ip6_frag)) {
d1123 2
a1124 1
	} else {
d1150 2
a1151 2
	struct inpcb *inp = sotoinpcb(so);
	struct mbuf *m = *mp;
a1153 6
#ifdef IPSEC
	struct proc *p = curproc; /* XXX */
	struct tdb *tdb;
	struct tdb_ident *tdbip, tdbi;
	int s;
#endif
a1164 1
				/* m is freed in ip6_pcbopts */
d1235 1
a1235 1
						inp->in6p_cksum = optval;
d1255 2
a1256 2
			case IPV6_PORTRANGE:
				optval = *mtod(m, int *);
d1260 5
a1264 5
				switch (optval) {
				case IPV6_PORTRANGE_DEFAULT:
					in6p->in6p_flags &= ~(IN6P_LOWPORT);
					in6p->in6p_flags &= ~(IN6P_HIGHPORT);
					break;
d1266 4
a1269 4
				case IPV6_PORTRANGE_HIGH:
					in6p->in6p_flags &= ~(IN6P_LOWPORT);
					in6p->in6p_flags |= IN6P_HIGHPORT;
					break;
d1271 4
a1274 4
				case IPV6_PORTRANGE_LOW:
					in6p->in6p_flags &= ~(IN6P_HIGHPORT);
					in6p->in6p_flags |= IN6P_LOWPORT;
					break;
d1276 4
a1279 4
				default:
					error = EINVAL;
					break;
				}
d1282 1
a1282 1
				break;
d1284 1
a1284 1
#if 0 /*KAME IPSEC*/
d1296 9
a1304 15
			case IPSEC6_OUTSA:
#ifndef IPSEC
				error = EINVAL;
#else
				s = spltdb();
				if (m == 0 || m->m_len != sizeof(struct tdb_ident)) {
					error = EINVAL;
				} else {
					tdbip = mtod(m, struct tdb_ident *);
					tdb = gettdb(tdbip->spi, &tdbip->dst,
						     tdbip->proto);
					if (tdb == NULL)
						error = ESRCH;
					else
						tdb_add_inp(tdb, inp, 0);
d1306 3
a1308 2
				splx(s);
#endif /* IPSEC */
a1309 49

			case IPV6_AUTH_LEVEL:
			case IPV6_ESP_TRANS_LEVEL:
			case IPV6_ESP_NETWORK_LEVEL:
#ifndef IPSEC
				error = EINVAL;
#else
				if (m == 0 || m->m_len != sizeof(int)) {
					error = EINVAL;
					break;
				}
				optval = *mtod(m, int *);

				if (optval < IPSEC_LEVEL_BYPASS || 
				    optval > IPSEC_LEVEL_UNIQUE) {
					error = EINVAL;
					break;
				}
					
				switch (optname) {
				case IP_AUTH_LEVEL:
				        if (optval < ipsec_auth_default_level &&
					    suser(p->p_ucred, &p->p_acflag)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_AUTH] = optval;
					break;

				case IP_ESP_TRANS_LEVEL:
				        if (optval < ipsec_esp_trans_default_level &&
					    suser(p->p_ucred, &p->p_acflag)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_ESP_TRANS] = optval;
					break;

				case IP_ESP_NETWORK_LEVEL:
				        if (optval < ipsec_esp_network_default_level &&
					    suser(p->p_ucred, &p->p_acflag)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_ESP_NETWORK] = optval;
					break;
				}
				if (!error)
					inp->inp_secrequire = get_sa_require(inp);
a1310 2
				break;

d1408 1
a1408 1
					optval = inp->in6p_cksum;
d1442 1
a1442 1
#if 0 /*KAME IPSEC*/
d1457 8
a1464 15
			case IPSEC6_OUTSA:
#ifndef IPSEC
				error = EINVAL;
#else
				s = spltdb();
				if (inp->inp_tdb_out == NULL) {
					error = ENOENT;
				} else {
					tdbi.spi = inp->inp_tdb_out->tdb_spi;
					tdbi.dst = inp->inp_tdb_out->tdb_dst;
					tdbi.proto = inp->inp_tdb_out->tdb_sproto;
					*mp = m = m_get(M_WAIT, MT_SOOPTS);
					m->m_len = sizeof(tdbi);
					bcopy((caddr_t)&tdbi, mtod(m, caddr_t),
					    (unsigned)m->m_len);
d1466 2
a1467 2
				splx(s);
#endif /* IPSEC */
a1468 25

			case IPV6_AUTH_LEVEL:
			case IPV6_ESP_TRANS_LEVEL:
			case IPV6_ESP_NETWORK_LEVEL:
#ifndef IPSEC
				m->m_len = sizeof(int);
				*mtod(m, int *) = IPSEC_LEVEL_NONE;
#else
				m->m_len = sizeof(int);
				switch (optname) {
				case IP_AUTH_LEVEL:
					optval = inp->inp_seclevel[SL_AUTH];
					break;

				case IP_ESP_TRANS_LEVEL:
					optval =
					    inp->inp_seclevel[SL_ESP_TRANS];
					break;

				case IP_ESP_NETWORK_LEVEL:
					optval =
					    inp->inp_seclevel[SL_ESP_NETWORK];
					break;
				}
				*mtod(m, int *) = optval;
a1469 1
				break;
d1493 1
a1493 1
	struct mbuf *m;
d1496 1
a1496 1
	struct ip6_pktopts *opt = *pktopt;
d1670 1
a1670 1
				ifp = lo0ifp;
d1823 2
a1824 2
	struct ip6_moptions *im6o;
	struct mbuf **mp;
d1869 1
a1869 1
	struct ip6_moptions *im6o;
d1894 1
a1894 1
	struct cmsghdr *cm = 0;
a1933 5
			/*
			 * Check if the requested source address is indeed a
			 * unicast address assigned to the node, and can be
			 * used as the packet's source address.
			 */
a1935 1
				struct in6_ifaddr *ia6;
a1949 5
				ia6 = (struct in6_ifaddr *)ia;
				if ((ia6->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) != 0) {
					return(EADDRNOTAVAIL);
				}

a1971 1
			
a1972 1
			    /* check if cmsg_len is large enough for sa_len */
d2046 1
a2046 1
 * pointer that might NOT be lo0ifp -- easier than replicating that code here.
d2051 2
a2052 2
	struct mbuf *m;
	struct sockaddr_in6 *dst;
d2054 1
a2054 2
	struct mbuf *copym;
	struct ip6_hdr *ip6;
d2057 2
a2058 13
	if (copym == NULL)
		return;

	/*
	 * Make sure to deep-copy IPv6 header portion in case the data
	 * is in an mbuf cluster, so that we can safely override the IPv6
	 * header portion later.
	 */
	if ((copym->m_flags & M_EXT) != 0 ||
	    copym->m_len < sizeof(struct ip6_hdr)) {
		copym = m_pullup(copym, sizeof(struct ip6_hdr));
		if (copym == NULL)
			return;
a2059 15

#ifdef DIAGNOSTIC
	if (copym->m_len < sizeof(*ip6)) {
		m_freem(copym);
		return;
	}
#endif

	ip6 = mtod(copym, struct ip6_hdr *);
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;

	(void)looutput(ifp, copym, (struct sockaddr *)dst, NULL);
a2082 1
		m->m_pkthdr.tdbi = NULL;
d2099 1
@


1.4.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.4.2.1 2001/05/14 22:40:19 niklas Exp $	*/
d106 2
a161 1
	struct m_tag *mtag;
a162 1
	struct tdb_ident *tdbi;
d199 4
d214 8
a221 14

	/* Do we have any pending SAs to apply ? */
	mtag = m_tag_find(m, PACKET_TAG_IPSEC_PENDING_TDB, NULL);
	if (mtag != NULL) {
#ifdef DIAGNOSTIC
		if (mtag->m_tag_len != sizeof (struct tdb_ident))
			panic("ip6_output: tag of length %d (should be %d",
			    mtag->m_tag_len, sizeof (struct tdb_ident));
#endif
		tdbi = (struct tdb_ident *)(mtag + 1);
		tdb = gettdb(tdbi->spi, &tdbi->dst, tdbi->proto);
		if (tdb == NULL)
			error = -EINVAL;
		m_tag_delete(m, mtag);
a222 3
	else
		tdb = ipsp_spd_lookup(m, AF_INET6, sizeof(struct ip6_hdr),
		    &error, IPSP_DIRECTION_OUT, NULL, inp);
d247 6
a263 1
			splx(s);
d268 1
a268 23
		/* Loop detection */
		for (mtag = m_tag_first(m); mtag != NULL;
		    mtag = m_tag_next(m, mtag)) {
			if (mtag->m_tag_id != PACKET_TAG_IPSEC_OUT_DONE &&
			    mtag->m_tag_id !=
			    PACKET_TAG_IPSEC_OUT_CRYPTO_NEEDED)
				continue;
			tdbi = (struct tdb_ident *)(mtag + 1);
			if (tdbi->spi == tdb->tdb_spi &&
			    tdbi->proto == tdb->tdb_sproto &&
			    !bcmp(&tdbi->dst, &tdb->tdb_dst,
			    sizeof(union sockaddr_union))) {
				splx(s);
				sproto = 0; /* mark as no-IPsec-needed */
				goto done_spd;
			}
		}

	        /* We need to do IPsec */
	        bcopy(&tdb->tdb_dst, &sdst, sizeof(sdst));
		sspi = tdb->tdb_spi;
		sproto = tdb->tdb_sproto;
	        splx(s);
d514 42
d577 2
a578 2
			 * XXX what should we do if ip6_hlim == 0 and the
			 * packet gets tunnelled?
d597 2
a598 1
		error = ipsp_process_packet(m, tdb, AF_INET6, 0);
d1778 2
d1943 4
a1946 1

d2339 1
a2339 1
		M_MOVE_PKTHDR(mh, m);
d2341 2
@


1.4.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.4.2.2 2001/07/04 10:55:23 niklas Exp $	*/
a67 2
#include "pf.h"

a91 4
#if NPF > 0
#include <net/pfvar.h>
#endif

a103 1
extern int ipsec_ipcomp_default_level;
d252 16
a891 9
#if NPF > 0 
        if (pf_test6(PF_OUT, ifp, &m) != PF_PASS) {
                error = EHOSTUNREACH;
		m_freem(m);
                goto done;
        }
	ip6 = mtod(m, struct ip6_hdr *);
#endif 

a1427 1
			case IPV6_IPCOMP_LEVEL:
d1444 1
a1444 1
				case IPV6_AUTH_LEVEL:
d1453 1
a1453 1
				case IPV6_ESP_TRANS_LEVEL:
d1462 1
a1462 1
				case IPV6_ESP_NETWORK_LEVEL:
a1469 9

				case IPV6_IPCOMP_LEVEL:
				        if (optval < ipsec_ipcomp_default_level &&
					    suser(p->p_ucred, &p->p_acflag)) {
						error = EACCES;
						break;
					}
					inp->inp_seclevel[SL_IPCOMP] = optval;
					break;
a1644 1
			case IPV6_IPCOMP_LEVEL:
a1662 4
					break;

				case IP_IPCOMP_LEVEL:
					optval = inp->inp_seclevel[SL_IPCOMP];
@


1.4.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d884 2
a885 2
	if (pf_test6(PF_OUT, ifp, &m) != PF_PASS) {
		error = EHOSTUNREACH;
d887 2
a888 4
		goto done;
	}
	if (m == NULL)
		goto done;
d913 4
d918 1
d1034 5
d1040 1
d1662 1
a1662 1
				case IPV6_AUTH_LEVEL:
d1666 1
a1666 1
				case IPV6_ESP_TRANS_LEVEL:
d1671 1
a1671 1
				case IPV6_ESP_NETWORK_LEVEL:
d1676 1
a1676 1
				case IPV6_IPCOMP_LEVEL:
@


1.4.2.5
log
@Merge in trunk
@
text
@d401 55
d563 1
a563 1
			tdb_add_inp(tdb, inp, 0);
d820 3
a822 2
		 * of source and destination, which should already be assured.
		 * Larger scopes than link will be supported in the future. 
d972 1
a972 2
		 * make new header and copy data of each part and link onto
		 * chain.
d1384 12
d1608 15
d1842 1
a1842 2
			if (suser(p->p_ucred, &p->p_acflag))
			{
d1946 1
a1946 2
			if (suser(p->p_ucred, &p->p_acflag))
			{
@


1.4.2.6
log
@Merge in -current from roughly a week ago
@
text
@d105 1
a105 1
extern u_int8_t get_sa_require(struct inpcb *);
d121 9
a129 9
static int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *,
			    struct socket *);
static int ip6_setmoptions(int, struct ip6_moptions **, struct mbuf *);
static int ip6_getmoptions(int, struct ip6_moptions *, struct mbuf **);
static int ip6_copyexthdr(struct mbuf **, caddr_t, int);
static int ip6_insertfraghdr(struct mbuf *, struct mbuf *, int,
				  struct ip6_frag **);
static int ip6_insert_jumboopt(struct ip6_exthdrs *, u_int32_t);
static int ip6_splithdr(struct mbuf *, struct ip6_exthdrs *);
@


1.4.2.7
log
@Sync the SMP branch with 3.3
@
text
@d121 2
a122 1
static int ip6_pcbopts(struct ip6_pktopts **, struct mbuf *, struct socket *);
d127 1
a127 1
	struct ip6_frag **);
a129 2
static int ip6_getpmtu(struct route_in6 *, struct route_in6 *,
	struct ifnet *, struct in6_addr *, u_long *);
d187 1
a187 1
		    ((eh)->ip6e_len + 1) << 3);				\
d231 2
a232 1
	} else
d395 6
a400 5
		MAKE_CHAIN(exthdrs.ip6e_hbh, mprev, nexthdrp, IPPROTO_HOPOPTS);
		MAKE_CHAIN(exthdrs.ip6e_dest1, mprev, nexthdrp,
		    IPPROTO_DSTOPTS);
		MAKE_CHAIN(exthdrs.ip6e_rthdr, mprev, nexthdrp,
		    IPPROTO_ROUTING);
d408 3
a410 1
		struct ip6_rthdr *rh;
a412 2
		rh = (struct ip6_rthdr *)(mtod(exthdrs.ip6e_rthdr,
		    struct ip6_rthdr *));
d414 1
a414 1
		switch (rh->ip6r_type) {
d419 3
a421 2
			     (caddr_t)&rh0->ip6r0_addr[0],
			     sizeof(struct in6_addr) * (rh0->ip6r0_segleft - 1));
d432 1
a432 1
	    (flags & IPV6_UNSPECSRC) == 0) {
d462 1
a462 2
	    dst->sin6_family != AF_INET6 ||
	    !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &ip6->ip6_dst))) {
d611 2
a612 1
			} else {
d630 1
a630 1
				    &ro->ro_dst, 0);
a705 4
	/* Determine path MTU. */
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu)) != 0)
		goto bad;

d707 1
a707 2
	 * The caller of this function may specify to use the minimum MTU
	 * in some cases.
d709 41
a749 3
	if (mtu > IPV6_MMTU) {
		if ((flags & IPV6_MINMTU))
			mtu = IPV6_MMTU;
d765 2
a766 3
		 * of source add destination, which should already be assured
		 * Larger scopes than link will be supported in the near
		 * future.
d787 2
a788 1
	} else
d801 2
a802 1
		struct ip6_hbh *hbh = mtod(exthdrs.ip6e_hbh, struct ip6_hbh *);
d814 5
a818 3
		if (ip6_process_hopopts(m, (u_int8_t *)(hbh + 1),
		    ((hbh->ip6h_len + 1) << 3) - sizeof(struct ip6_hbh),
		    &dummy1, &dummy2) < 0) {
d827 1
a827 1
#if NPF > 0
d836 1
a836 1
#endif
d843 16
a858 1
	if (tlen <= mtu) {
d934 2
a935 2
			error = ip6_insertfraghdr(m0, m, hlen, &ip6f);
			if (error) {
d945 2
a946 1
			    sizeof(*ip6f) - sizeof(struct ip6_hdr)));
d991 1
a991 1
	return (error);
d998 1
a998 1
	/* FALLTHROUGH */
d1013 1
a1013 1
		return (ENOBUFS); /* XXX */
d1017 1
a1017 1
		return (ENOBUFS);
d1023 1
a1023 1
			return (ENOBUFS);
d1031 1
a1031 1
	return (0);
d1043 1
a1043 1
	u_int8_t *optbuf;
d1057 1
a1057 1
			return (ENOBUFS);
d1059 1
a1059 1
		optbuf = mtod(mopt, u_int8_t *);
d1081 1
a1081 1
				return (ENOBUFS);
d1096 1
a1096 1
				return (ENOBUFS);
d1100 1
a1100 1
			optbuf = mtod(n, u_int8_t *) + oldoptlen;
d1104 1
a1104 1
			optbuf = mtod(mopt, u_int8_t *) + mopt->m_len;
d1108 1
a1108 1
		optbuf[1] = 0;
d1127 1
a1127 1
	return (0);
d1144 1
a1144 1
		    hlen - sizeof(struct ip6_hdr), M_DONTWAIT);
d1146 1
a1146 1
			return (ENOBUFS);
d1158 2
a1159 2
		*frghdrp = (struct ip6_frag *)(mtod(mlast, caddr_t) +
		    mlast->m_len);
d1168 1
a1168 1
			return (ENOBUFS);
d1174 1
a1174 64
	return (0);
}

static int
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup)
	struct route_in6 *ro_pmtu, *ro;
	struct ifnet *ifp;
	struct in6_addr *dst;
	u_long *mtup;
{
	u_int32_t mtu = 0;
	int error = 0;

	if (ro_pmtu != ro) {
		/* The first hop and the final destination may differ. */
		struct sockaddr_in6 *sa6_dst =
		    (struct sockaddr_in6 *)&ro_pmtu->ro_dst;
		if (ro_pmtu->ro_rt &&
		    ((ro_pmtu->ro_rt->rt_flags & RTF_UP) == 0 ||
		     !IN6_ARE_ADDR_EQUAL(&sa6_dst->sin6_addr, dst))) {
			RTFREE(ro_pmtu->ro_rt);
			ro_pmtu->ro_rt = (struct rtentry *)0;
		}
		if (ro_pmtu->ro_rt == 0) {
			bzero(sa6_dst, sizeof(*sa6_dst));
			sa6_dst->sin6_family = AF_INET6;
			sa6_dst->sin6_len = sizeof(struct sockaddr_in6);
			sa6_dst->sin6_addr = *dst;

			rtalloc((struct route *)ro_pmtu);
		}
	}
	if (ro_pmtu->ro_rt) {
		u_int32_t ifmtu;

		if (ifp == NULL)
			ifp = ro_pmtu->ro_rt->rt_ifp;
		ifmtu = IN6_LINKMTU(ifp);
		mtu = ro_pmtu->ro_rt->rt_rmx.rmx_mtu;
		if (mtu == 0)
			mtu = ifmtu;
		else if (mtu > ifmtu) {
			/*
			 * The MTU on the route is larger than the MTU on
			 * the interface!  This shouldn't happen, unless the
			 * MTU of the interface has been changed after the
			 * interface was brought up.  Change the MTU in the
			 * route to match the interface MTU (as long as the
			 * field isn't locked).
			 *
			 * if MTU on the route is 0, we need to fix the MTU.
			 * this case happens with path MTU discovery timeouts.
			 */
			mtu = ifmtu;
			if (!(ro_pmtu->ro_rt->rt_rmx.rmx_locks & RTV_MTU))
				ro_pmtu->ro_rt->rt_rmx.rmx_mtu = mtu;
		}
	} else if (ifp) {
		mtu = IN6_LINKMTU(ifp);
	} else
		error = EHOSTUNREACH; /* XXX */

	*mtup = mtu;
	return (error);
d1210 2
a1211 2
				return (ip6_pcbopts(&inp->inp_outputopts6,
				    m, so));
d1218 1
a1218 1
				/* FALLTHROUGH */
d1226 1
d1228 1
a1228 2
			case IPV6_V6ONLY:
				if (optlen != sizeof(int)) {
d1230 12
a1241 13
					break;
				}
				optval = *mtod(m, int *);
				switch (optname) {

				case IPV6_UNICAST_HOPS:
					if (optval < -1 || optval >= 256)
						error = EINVAL;
					else {
						/* -1 = kernel default */
						inp->inp_hops = optval;
					}
					break;
a1242 1
do { \
d1244 1
a1244 1
		inp->inp_flags |= (bit); \
d1246 4
a1249 5
		inp->inp_flags &= ~(bit); \
} while (0)
				case IPV6_RECVOPTS:
					OPTSET(IN6P_RECVOPTS);
					break;
d1251 3
a1253 3
				case IPV6_RECVRETOPTS:
					OPTSET(IN6P_RECVRETOPTS);
					break;
d1255 3
a1257 3
				case IPV6_RECVDSTADDR:
					OPTSET(IN6P_RECVDSTADDR);
					break;
d1259 3
a1261 3
				case IPV6_PKTINFO:
					OPTSET(IN6P_PKTINFO);
					break;
d1263 3
a1265 3
				case IPV6_HOPLIMIT:
					OPTSET(IN6P_HOPLIMIT);
					break;
d1267 3
a1269 3
				case IPV6_HOPOPTS:
					OPTSET(IN6P_HOPOPTS);
					break;
d1271 3
a1273 3
				case IPV6_DSTOPTS:
					OPTSET(IN6P_DSTOPTS);
					break;
d1275 3
a1277 3
				case IPV6_RTHDR:
					OPTSET(IN6P_RTHDR);
					break;
d1279 3
a1281 3
				case IPV6_FAITH:
					OPTSET(IN6P_FAITH);
					break;
d1283 4
a1286 4
				case IPV6_V6ONLY:
					if (!optval)
						error = EINVAL;
					break;
d1303 2
d1307 2
a1308 2
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags &= ~(IN6P_HIGHPORT);
d1312 2
a1313 2
					inp->inp_flags &= ~(IN6P_LOWPORT);
					inp->inp_flags |= IN6P_HIGHPORT;
d1317 2
a1318 2
					inp->inp_flags &= ~(IN6P_HIGHPORT);
					inp->inp_flags |= IN6P_LOWPORT;
d1325 2
d1362 1
a1362 1
				if (optval < IPSEC_LEVEL_BYPASS ||
d1367 1
a1367 1

d1424 11
d1437 1
d1442 1
a1442 1
					    M_COPYALL, M_WAIT);
d1455 1
a1455 1
				/* FALLTHROUGH */
d1463 1
a1464 1
			case IPV6_V6ONLY:
d1506 4
a1513 4
				case IPV6_V6ONLY:
					optval = (ip6_v6only != 0); /* XXX */
					break;

d1604 1
a1604 77
	return (error);
}

int
ip6_raw_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	int error = 0, optval, optlen;
	const int icmp6off = offsetof(struct icmp6_hdr, icmp6_cksum);
	struct inpcb *inp = sotoinpcb(so);
	struct mbuf *m = *mp;

	optlen = m ? m->m_len : 0;

	if (level != IPPROTO_IPV6) {
		if (op == PRCO_SETOPT && *mp)
			(void)m_free(*mp);
		return (EINVAL);
	}

	switch (optname) {
	case IPV6_CHECKSUM:
		/*
		 * For ICMPv6 sockets, no modification allowed for checksum
		 * offset, permit "no change" values to help existing apps.
		 *
		 * XXX 2292bis says: "An attempt to set IPV6_CHECKSUM
		 * for an ICMPv6 socket will fail."
		 * The current behavior does not meet 2292bis.
		 */
		switch (op) {
		case PRCO_SETOPT:
			if (optlen != sizeof(int)) {
				error = EINVAL;
				break;
			}
			optval = *mtod(m, int *);
			if ((optval % 2) != 0) {
				/* the API assumes even offset values */
				error = EINVAL;
			} else if (so->so_proto->pr_protocol ==
			    IPPROTO_ICMPV6) {
				if (optval != icmp6off)
					error = EINVAL;
			} else
				inp->in6p_cksum = optval;
			break;

		case PRCO_GETOPT:
			if (so->so_proto->pr_protocol == IPPROTO_ICMPV6)
				optval = icmp6off;
			else
				optval = inp->in6p_cksum;

			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(int);
			*mtod(m, int *) = optval;
			break;

		default:
			error = EINVAL;
			break;
		}
		break;

	default:
		error = ENOPROTOOPT;
		break;
	}

	if (op == PRCO_SETOPT && m)
		(void)m_free(m);

	return (error);
d1627 2
a1628 1
	} else
d1636 2
a1637 1
		free(opt, M_IP6OPT);
d1640 1
a1640 1
		return (0);
d1648 1
a1648 2
		free(opt, M_IP6OPT);
		return (error);
d1651 1
a1651 1
	return (0);
a1680 2
		if (im6o == NULL)
			return (ENOBUFS);
d1698 1
a1698 1
		bcopy(mtod(m, u_int *), &ifindex, sizeof(ifindex));
d1721 1
a1721 1
		bcopy(mtod(m, u_int *), &optval, sizeof(optval));
d1736 2
a1737 6
		if (m == NULL || m->m_len != sizeof(u_int)) {
			error = EINVAL;
			break;
		}
		bcopy(mtod(m, u_int *), &loop, sizeof(loop));
		if (loop > 1) {
d1792 2
a1793 1
			} else {
d1824 2
a1825 2
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
d1834 1
a1834 1
			    &mreq->ipv6mr_multiaddr))
d1844 5
a1848 2
		imm = in6_joingroup(ifp, &mreq->ipv6mr_multiaddr, &error);
		if (!imm)
d1850 1
d1889 2
a1890 2
			mreq->ipv6mr_multiaddr.s6_addr16[1] =
			    htons(mreq->ipv6mr_interface);
d1897 2
a1898 1
			if ((ifp == NULL || imm->i6mm_maddr->in6m_ifp == ifp) &&
d1900 1
a1900 1
			    &mreq->ipv6mr_multiaddr))
d1913 2
a1914 1
		in6_leavegroup(imm);
d1933 1
a1933 1
	return (error);
d1958 1
a1958 1
		return (0);
d1967 1
a1967 1
		return (0);
d1976 1
a1976 1
		return (0);
d1979 1
a1979 1
		return (EOPNOTSUPP);
d1997 3
a1999 1
		in6_leavegroup(imm);
d2016 1
a2016 1
		return (EINVAL);
d2026 1
a2026 1
		return (EINVAL);
d2031 1
a2031 1
	    control->m_len -= CMSG_ALIGN(cm->cmsg_len)) {
d2034 1
a2034 1
			return (EINVAL);
d2038 1
a2038 1
		switch (cm->cmsg_type) {
d2041 1
a2041 1
				return (EINVAL);
d2048 3
a2050 3
			if (opt->ip6po_pktinfo->ipi6_ifindex > if_index ||
			    opt->ip6po_pktinfo->ipi6_ifindex < 0) {
				return (ENXIO);
d2073 1
a2073 1
					return (EADDRNOTAVAIL);
d2077 1
a2077 1
					return (EADDRNOTAVAIL);
d2086 1
a2086 1
					return (EADDRNOTAVAIL);
d2092 1
a2092 1
				return (EINVAL);
d2094 1
a2094 2
			bcopy(CMSG_DATA(cm), &opt->ip6po_hlim,
			    sizeof(opt->ip6po_hlim));
d2096 1
a2096 1
				return (EINVAL);
d2101 2
a2102 3
				return (EPERM);

			/* check if cmsg_len is large enough for sa_len */
d2104 1
d2106 1
a2106 1
				return (EINVAL);
d2114 1
a2114 1
				return (EINVAL);
d2118 1
a2118 1
				return (EINVAL);
d2123 1
a2123 1
				return (EINVAL);
d2133 1
a2133 1
				    (struct ip6_dest *)CMSG_DATA(cm);
d2135 3
a2137 2
				    CMSG_LEN((opt->ip6po_dest1->ip6d_len + 1) << 3));
					return (EINVAL);
d2141 1
a2141 1
				    (struct ip6_dest *)CMSG_DATA(cm);
d2143 3
a2145 2
				    CMSG_LEN((opt->ip6po_dest2->ip6d_len + 1) << 3))
					return (EINVAL);
d2151 1
a2151 1
				return (EINVAL);
d2155 2
a2156 2
				return (EINVAL);
			switch (opt->ip6po_rthdr->ip6r_type) {
d2159 1
a2159 1
					return (EINVAL);
d2162 1
a2162 1
				return (EINVAL);
d2167 1
a2167 1
			return (ENOPROTOOPT);
d2171 1
a2171 1
	return (0);
d2255 2
d2258 2
a2259 2
ip6_optlen(inp)
	struct inpcb *inp;
d2263 1
a2263 1
	if (!inp->inp_outputopts6)
d2270 4
a2273 4
	len += elen(inp->inp_outputopts6->ip6po_hbh);
	len += elen(inp->inp_outputopts6->ip6po_dest1);
	len += elen(inp->inp_outputopts6->ip6po_rthdr);
	len += elen(inp->inp_outputopts6->ip6po_dest2);
d2277 2
@


1.4.2.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.4.2.7 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a94 1
#include <netinet/ip_ipsp.h>
a404 1
		struct in6_addr *addr;
d412 3
a414 3
			 addr = (struct in6_addr *)(rh0 + 1);
			 ip6->ip6_dst = addr[0];
			 bcopy(&addr[1], &addr[0],
d416 1
a416 1
			 addr[rh0->ip6r0_segleft - 1] = finaldst;
d553 4
a556 4
		if (opt && opt->ip6po_pktinfo &&
		    opt->ip6po_pktinfo->ipi6_ifindex) {
			if (!(ifp->if_flags & IFF_LOOPBACK) &&
			    ifp->if_index != opt->ip6po_pktinfo->ipi6_ifindex) {
d819 1
a819 1
		u_int32_t id = htonl(ip6_randomid());
a863 2
			struct mbuf *mlast;

d894 1
a894 3
			for (mlast = m; mlast->m_next; mlast = mlast->m_next)
				;
			mlast->m_next = m_frgpart;
d1375 1
a1375 1
					    suser(p, 0)) {
d1384 1
a1384 1
					    suser(p, 0)) {
d1393 1
a1393 1
					    suser(p, 0)) {
d1402 1
a1402 1
					    suser(p, 0)) {
d1710 1
a1710 1
	if (p && !suser(p, 0))
d1768 1
a1768 2
		if (ifindex < 0 || if_indexlim <= ifindex ||
		    !ifindex2ifnet[ifindex]) {
d1833 1
a1833 1
			if (suser(p, 0))
d1846 2
a1847 3
		if (mreq->ipv6mr_interface < 0 ||
		    if_indexlim <= mreq->ipv6mr_interface ||
		    !ifindex2ifnet[mreq->ipv6mr_interface]) {
d1897 1
a1897 1
			    htons(ifp->if_index);
d1933 1
a1933 1
			if (suser(p, 0))
d1946 2
a1947 3
		if (mreq->ipv6mr_interface < 0 ||
		    if_indexlim <= mreq->ipv6mr_interface ||
		    !ifindex2ifnet[mreq->ipv6mr_interface]) {
d2112 1
a2112 1
			if (opt->ip6po_pktinfo->ipi6_ifindex >= if_indexlim ||
a2113 4
				return (ENXIO);
			}
			if (opt->ip6po_pktinfo->ipi6_ifindex > 0 &&
			    !ifindex2ifnet[opt->ip6po_pktinfo->ipi6_ifindex]) {
@


1.4.2.10
log
@Merge with the trunk
@
text
@a88 1
#include <netinet6/ip6protosw.h>
d127 1
a127 1
	struct ifnet *, struct in6_addr *, u_long *, int *);
a157 1
	int alwaysfrag, dontfrag;
d703 1
a703 2
	if ((error = ip6_getpmtu(ro_pmtu, ro, ifp, &finaldst, &mtu,
	    &alwaysfrag)) != 0)
a800 15
	 *
	 * the logic here is rather complex:
	 * 1: normal case (dontfrag == 0, alwaysfrag == 0)
	 * 1-a: send as is if tlen <= path mtu
	 * 1-b: fragment if tlen > path mtu
	 *
	 * 2: if user asks us not to fragment (dontfrag == 1)
	 * 2-a: send as is if tlen <= interface mtu
	 * 2-b: error if tlen > interface mtu
	 *
	 * 3: if we always need to attach fragment header (alwaysfrag == 1)
	 *      always fragment
	 *
	 * 4: if dontfrag == 1 && alwaysfrag == 1
	 *      error, as we cannot handle this conflicting request
d803 4
a806 8

	dontfrag = 0;
	if (dontfrag && alwaysfrag) {	/* case 4 */
		/* conflicting request - can't transmit */
		error = EMSGSIZE;
		goto bad;
	}
	if (dontfrag && tlen > IN6_LINKMTU(ifp)) {	/* case 2-b */
d808 2
a809 6
		 * Even if the DONTFRAG option is specified, we cannot send the
		 * packet when the data length is larger than the MTU of the
		 * outgoing interface.
		 * Notify the error by sending IPV6_PATHMTU ancillary data as
		 * well as returning an error code (the latter is not described
		 * in the API spec.)
a810 28
#if 0
		u_int32_t mtu32;
		struct ip6ctlparam ip6cp;

		mtu32 = (u_int32_t)mtu;
		bzero(&ip6cp, sizeof(ip6cp));
		ip6cp.ip6c_cmdarg = (void *)&mtu32;
		pfctlinput2(PRC_MSGSIZE, (struct sockaddr *)&ro_pmtu->ro_dst,
		    (void *)&ip6cp);
#endif

		error = EMSGSIZE;
		goto bad;
	}

	/*
	 * transmit packet without fragmentation
	 */
	if (dontfrag || (!alwaysfrag && tlen <= mtu)) {	/* case 1-a and 2-a */
		error = nd6_output(ifp, origifp, m, dst, ro->ro_rt);
		goto done;
	}

	/*
	 * try to fragment the packet.  case 1-b and 3
	 */
	if (mtu < IPV6_MMTU) {
		/* path MTU cannot be less than IPV6_MMTU */
d814 1
a814 2
	} else if (ip6->ip6_plen == 0) {
		/* jumbo payload cannot be fragmented */
a822 4
#if 0
		struct ip6ctlparam ip6cp;
		u_int32_t mtu32;
#endif
a831 10

#if 0
		/* Notify a proper path MTU to applications. */
		mtu32 = (u_int32_t)mtu;
		bzero(&ip6cp, sizeof(ip6cp));
		ip6cp.ip6c_cmdarg = (void *)&mtu32;
		pfctlinput2(PRC_MSGSIZE, (struct sockaddr *)&ro_pmtu->ro_dst,
		    (void *)&ip6cp);
#endif

a873 1
			m->m_pkthdr.rcvif = NULL;
d886 1
a886 1
			ip6f->ip6f_offlg = htons((u_int16_t)((off - hlen) & ~7));
d891 1
a891 1
			mhip6->ip6_plen = htons((u_int16_t)(len + hlen +
d1126 1
a1126 1
ip6_getpmtu(ro_pmtu, ro, ifp, dst, mtup, alwaysfragp)
a1130 1
	int *alwaysfragp;
a1132 1
	int alwaysfrag = 0;
d1143 1
a1143 1
			ro_pmtu->ro_rt = (struct rtentry *)NULL;
d1163 1
a1163 12
		else if (mtu < IPV6_MMTU) {
			/*
			 * RFC2460 section 5, last paragraph:
			 * if we record ICMPv6 too big message with
			 * mtu < IPV6_MMTU, transmit packets sized IPV6_MMTU
			 * or smaller, with fragment header attached.
			 * (fragment header is needed regardless from the
			 * packet size, for translators to identify packets)
			 */
			alwaysfrag = 1;
			mtu = IPV6_MMTU;
		} else if (mtu > ifmtu) {
d1171 3
a1184 2
	if (alwaysfragp)
		*alwaysfragp = alwaysfrag;
@


1.4.2.11
log
@sync to HEAD
@
text
@a1320 1
			case IPV6_USE_MIN_MTU:
a1378 4
				case IPV6_USE_MIN_MTU:
					OPTSET(IN6P_MINMTU);
					break;

a1545 1
			case IPV6_USE_MIN_MTU:
a1606 4

				case IPV6_USE_MIN_MTU:
					optval = OPTBIT(IN6P_MINMTU);
					break;
@


1.4.4.1
log
@Pull in patch from current:
Fix (itojun):
repair IPv6 multicasting.  INP_IPV6_MCAST is necessary.
(i will try to remove this flag bit later)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.15 2000/09/16 13:58:23 itojun Exp $	*/
a1252 11
				/*
				 * XXX: setting the flag would be redundant
				 *      except at the first time. Also, we
				 *      actually don't have to reset the flag,
				 *      since ip6_freemoptions() would simply
				 *      return when the inp_moptions6 is NULL.
				 */
				if (inp->inp_moptions6)
					inp->inp_flags |= INP_IPV6_MCAST;
				else
					inp->inp_flags &= ~INP_IPV6_MCAST;
@


1.3
log
@add missing IPV6_PORTRANGE case.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
d86 2
a87 2
#include <netinet6/ip6.h>
#include <netinet6/icmp6.h>
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_output.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d1366 1
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 10
#ifdef __FreeBSD__
#include "opt_ip6fw.h"
#endif
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a74 6
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3)
#include <sys/kernel.h>
#endif
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
#include <machine/pcpu.h>
#endif
a81 1
#if defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
d84 2
a85 1
#endif
a87 5
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__OpenBSD__) || (defined(__bsdi__) && _BSDI_VERSION >= 199802)
#include <netinet/in_pcb.h>
#else
#include <netinet6/in6_pcb.h>
#endif
a90 1
#ifdef __OpenBSD__ /*KAME IPSEC*/
a91 1
#endif
a92 7
#ifdef IPSEC
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif /* IPSEC */

#ifndef __bsdi__
a93 1
#endif
a100 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static MALLOC_DEFINE(M_IPMOPTS, "ip6_moptions", "internet multicast options");
#endif

a108 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
static int ip6_pcbopts __P((struct ip6_pktopts **, struct mbuf *,
			    struct socket *, struct sockopt *sopt));
#else
a110 1
#endif
a117 4
#ifdef __bsdi__
#if _BSDI_VERSION < 199802
extern struct ifnet loif;
#else
a118 3
#endif
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
a119 1
#endif
d152 1
a152 3
#if defined(__bsdi__) && _BSDI_VERSION < 199802
	struct ifnet *loifp = &loif;
#endif
a523 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a528 6
#else
			if (ro == &ip6route)	/* xxx kazu */
				rtalloc((struct route *)ro);
			else
				rtcalloc((struct route *)ro);
#endif
a606 3
#if defined(__bsdi__)
				ifp = loifp;
#else
a607 1
#endif
d624 1
a624 5
						&ro->ro_dst, 0
#ifdef __FreeBSD__
						, 0UL
#endif
						);
a718 3
#ifdef __FreeBSD__
			rtcalloc((struct route *)ro_pmtu);
#else
a719 1
#endif
a823 11
#if defined(__NetBSD__) && defined(IFA_STATS)
		if (IFA_STATS) {
			struct in6_ifaddr *ia6;
			ip6 = mtod(m, struct ip6_hdr *);
			ia6 = in6_ifawithifp(ifp, &ip6->ip6_src);
			if (ia6) {
				ia->ia_ifa.ifa_data.ifad_outbytes +=
					m->m_pkthdr.len;
			}
		}
#endif
a947 11
#if defined(__NetBSD__) && defined(IFA_STATS)
			if (IFA_STATS) {
				struct in6_ifaddr *ia6;
				ip6 = mtod(m, struct ip6_hdr *);
				ia6 = in6_ifawithifp(ifp, &ip6->ip6_src);
				if (ia6) {
					ia->ia_ifa.ifa_data.ifad_outbytes +=
						m->m_pkthdr.len;
				}
			}
#endif
a1141 6
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int
ip6_ctloutput(so, sopt)
	struct socket *so;
	struct sockopt *sopt;
#else
a1147 1
#endif
a1149 18
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	register struct inpcb *in6p = sotoinpcb(so);
	int error, optval;
	int level, op, optname;
	int optlen;
	struct proc *p;

	if (sopt) {
		level = sopt->sopt_level;
		op = sopt->sopt_dir;
		optname = sopt->sopt_name;
		optlen = sopt->sopt_valsize;
		p = sopt->sopt_p;
	} else {
		panic("ip6_ctloutput: arg soopt is NULL");
	}
#else
#ifdef HAVE_NRL_INPCB
a1150 3
#else
	register struct in6pcb *in6p = sotoin6pcb(so);
#endif
a1153 3
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	struct proc *p = curproc;	/* XXX */
#endif
a1155 1
#endif
a1157 4
#if defined(__NetBSD__) || (defined(__FreeBSD__) && __FreeBSD__ >= 3)
	privileged = (p == 0 || suser(p->p_ucred, &p->p_acflag)) ? 0 : 1;
#else
#ifdef HAVE_NRL_INPCB
a1158 4
#else
	privileged = (in6p->in6p_socket->so_state & SS_PRIV);
#endif
#endif
a1161 4

#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		case SOPT_SET:
#else
a1162 1
#endif
a1164 15
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			    {
				struct mbuf *m;

				error = soopt_getm(sopt, &m); /* XXX */
				if (error != NULL)
					break;
				error = soopt_mcopyin(sopt, m); /* XXX */
				if (error != NULL)
					break;
				return (ip6_pcbopts(&in6p->in6p_outputopts,
						    m, so, sopt));
			    }
#else
#ifdef HAVE_NRL_INPCB
a1166 5
#else
				return(ip6_pcbopts(&in6p->in6p_outputopts,
						   m, so));
#endif
#endif
a1182 5
#ifdef MAPPED_ADDR_ENABLED
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			case IPV6_BINDV6ONLY:
#endif
#endif /* MAPPED_ADDR_ENABLED */
a1185 6
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
					error = sooptcopyin(sopt, &optval,
						sizeof optval, sizeof optval);
					if (error)
						break;
#else
a1186 1
#endif
a1193 1
#ifdef HAVE_NRL_INPCB
a1194 11
#else
							in6p->in6p_hops = optval;

#if defined(MAPPED_ADDR_ENABLED)
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
							if ((in6p->in6p_vflag &
							     INP_IPV4) != 0)
								in6p->inp_ip_ttl = optval;
#endif
#endif
#endif
a1196 1
#ifdef HAVE_NRL_INPCB
a1201 8
#else
#define OPTSET(bit) \
	if (optval) \
		in6p->in6p_flags |= bit; \
	else \
		in6p->in6p_flags &= ~bit;
#endif

a1234 1
#ifdef HAVE_NRL_INPCB
a1235 3
#else
						in6p->in6p_cksum = optval;
#endif
a1240 8

#ifdef MAPPED_ADDR_ENABLED
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
					case IPV6_BINDV6ONLY:
						OPTSET(IN6P_BINDV6ONLY);
						break;
#endif
#endif /* MAPPED_ADDR_ENABLED */
a1250 23
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			    {
				struct mbuf *m;
				if (sopt->sopt_valsize > MLEN) {
					error = EMSGSIZE;
					break;
				}
				/* XXX */
				MGET(m, sopt->sopt_p ? M_WAIT : M_DONTWAIT, MT_HEADER);
				if (m == 0) {
					error = ENOBUFS;
					break;
				}
				m->m_len = sopt->sopt_valsize;
				error = sooptcopyin(sopt, mtod(m, char *),
						    m->m_len, m->m_len);
				error =	ip6_setmoptions(sopt->sopt_name,
							&in6p->in6p_moptions,
							m);
				(void)m_free(m);
			    }
#else
#ifdef HAVE_NRL_INPCB
a1252 5
#else
				error =	ip6_setmoptions(optname,
					&in6p->in6p_moptions, m);
#endif
#endif
a1254 1
#ifndef __bsdi__
a1255 6
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			error = sooptcopyin(sopt, &optval, sizeof optval,
					    sizeof optval);
			if (error)
				break;
#else
a1256 1
#endif
a1257 1
#ifdef HAVE_NRL_INPCB
a1259 1
#endif
a1279 1
#ifdef HAVE_NRL_INPCB
a1281 1
#endif
a1282 1
#endif
a1287 10
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				struct mbuf *m;
#endif

#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				if (error = soopt_getm(sopt, &m)) /* XXX */
					break;
				if (error = soopt_mcopyin(sopt, m)) /* XXX */
					break;
#endif
a1291 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				m_freem(m);
#endif
a1301 13
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				struct mbuf *m;
				struct mbuf **mp = &m;
#endif

#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				if (ip6_fw_ctl_ptr == NULL)
					return EINVAL;
				if (error = soopt_getm(sopt, &m)) /* XXX */
					break;
				if (error = soopt_mcopyin(sopt, m)) /* XXX */
					break;
#else
a1305 1
#endif
a1315 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1317 1
#endif
a1319 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		case SOPT_GET:
#else
a1320 1
#endif
a1324 15
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
#if 0
				if (in6p->in6p_options) {
					error = sooptcopyout(sopt, 
						     mtod(in6p->in6p_options,
							  char *),
						     in6p->in6p_options->m_len);
				} else
					sopt->sopt_valsize = 0;
				break;
#else
				error = ENOPROTOOPT;
				break;
#endif
#else
a1338 1
#endif
a1340 7
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				if (in6p->in6p_options) {
					error = soopt_mcopyout(sopt, 
							       in6p->in6p_options);
				} else
					sopt->sopt_valsize = 0;
#elif defined(HAVE_NRL_INPCB)
a1347 9
#else
				if (in6p->in6p_options) {
					*mp = m_copym(in6p->in6p_options, 0,
						      M_COPYALL, M_WAIT);
				} else {
					*mp = m_get(M_WAIT, MT_SOOPTS);
					(*mp)->m_len = 0;
				}
#endif
a1365 5
#ifdef MAPPED_ADDR_ENABLED
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			case IPV6_BINDV6ONLY:
#endif
#endif /* MAPPED_ADDR_ENABLED */
a1368 1
#ifdef HAVE_NRL_INPCB
a1369 3
#else
					optval = in6p->in6p_hops;
#endif
a1371 1
#ifdef HAVE_NRL_INPCB
a1372 3
#else
#define OPTBIT(bit) (in6p->in6p_flags & bit ? 1 : 0)
#endif
a1406 1
#ifdef HAVE_NRL_INPCB
a1407 3
#else
					optval = in6p->in6p_cksum;
#endif
a1413 9
#ifdef MAPPED_ADDR_ENABLED
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				case IPV6_BINDV6ONLY:
					optval = OPTBIT(IN6P_BINDV6ONLY);
					break;
#endif
#endif /* MAPPED_ADDR_ENABLED */

#ifndef __bsdi__
d1417 1
a1417 1
#ifdef HAVE_NRL_INPCB
a1418 3
#else
					flags = in6p->in6p_flags;
#endif
a1426 1
#endif
a1427 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				error = sooptcopyout(sopt, &optval,
					sizeof optval);
#else
a1430 1
#endif
a1437 11
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			    {
				struct mbuf *m;
				error = ip6_getmoptions(sopt->sopt_name,
						in6p->in6p_moptions, &m);
				if (error == 0)
					error = sooptcopyout(sopt,
						mtod(m, char *), m->m_len);
				m_freem(m);
			    }
#elif defined(HAVE_NRL_INPCB)
a1438 3
#else
				error = ip6_getmoptions(optname, in6p->in6p_moptions, mp);
#endif
d1446 1
a1446 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				struct mbuf *m;
				struct mbuf **mp = &m;
#endif
a1451 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				if (error == 0)
					error = soopt_mcopyout(sopt, m); /*XXX*/
				m_freem(m);
#endif
a1458 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				struct mbuf *m;
				struct mbuf **mp = &m;
#endif

a1460 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1462 1
#endif
a1465 6
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
				if (error == 0)
					error = soopt_mcopyout(sopt, m); /* XXX */
				if (m)
					m_freem(m);
#endif
a1477 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1479 1
#endif
a1489 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
ip6_pcbopts(pktopt, m, so, sopt)
#else
a1490 1
#endif
a1493 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	struct sockopt *sopt;
#endif
a1496 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	struct proc *p = sopt->sopt_p;
#elif defined(__bsdi__) && _BSDI_VERSION >= 199802
	struct proc *p = PCPU(curproc);	/* XXX */
#else
a1497 1
#endif
a1547 3
#if defined(__bsdi__) && _BSDI_VERSION >= 199802
	struct proc *p = PCPU(curproc);	/* XXX */
#else
a1548 4
#endif
#if defined(__bsdi__) && _BSDI_VERSION < 199802
	struct ifnet *loifp = &loif;
#endif
a1668 3
#if defined(__bsdi__)
				ifp = loifp;
#else
a1669 1
#endif
a1826 3
#ifdef __FreeBSD__
	*mp = m_get(M_WAIT, MT_HEADER);		/*XXX*/
#else
a1827 1
#endif
a2056 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		(void)if_simloop(ifp, copym, (struct sockaddr *)dst, NULL);
#else
a2057 1
#endif
a2095 1
#ifdef HAVE_NRL_INPCB
d2098 1
a2098 1
#endif
a2118 1
#ifdef HAVE_NRL_INPCB
a2120 1
#endif
@

