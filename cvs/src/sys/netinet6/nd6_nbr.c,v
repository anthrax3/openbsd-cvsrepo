head	1.119;
access;
symbols
	OPENBSD_6_1:1.115.0.4
	OPENBSD_6_1_BASE:1.115
	OPENBSD_6_0:1.107.0.2
	OPENBSD_6_0_BASE:1.107
	OPENBSD_5_9:1.101.0.2
	OPENBSD_5_9_BASE:1.101
	OPENBSD_5_8:1.91.0.4
	OPENBSD_5_8_BASE:1.91
	OPENBSD_5_7:1.88.0.2
	OPENBSD_5_7_BASE:1.88
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.75.0.4
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.63.0.4
	OPENBSD_5_3_BASE:1.63
	OPENBSD_5_2:1.63.0.2
	OPENBSD_5_2_BASE:1.63
	OPENBSD_5_1_BASE:1.62
	OPENBSD_5_1:1.62.0.2
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.55.0.6
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.55.0.4
	OPENBSD_4_8_BASE:1.55
	OPENBSD_4_7:1.55.0.2
	OPENBSD_4_7_BASE:1.55
	OPENBSD_4_6:1.54.0.6
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.2
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.42.0.2
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.41.0.2
	OPENBSD_4_0_BASE:1.41
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.37.0.4
	OPENBSD_3_8_BASE:1.37
	OPENBSD_3_7:1.37.0.2
	OPENBSD_3_7_BASE:1.37
	OPENBSD_3_6:1.33.0.4
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.27.0.4
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.27.0.2
	OPENBSD_3_2_BASE:1.27
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.27
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.17.0.2
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.119
date	2017.07.11.12.51.05;	author florian;	state Exp;
branches;
next	1.118;
commitid	iTlWhLM2orYZnz27;

1.118
date	2017.07.05.09.51.37;	author florian;	state Exp;
branches;
next	1.117;
commitid	Dmk8iNjgdKaGUpyz;

1.117
date	2017.06.08.13.28.03;	author mpi;	state Exp;
branches;
next	1.116;
commitid	I1bHvUOroHRt4LWl;

1.116
date	2017.05.16.12.24.04;	author mpi;	state Exp;
branches;
next	1.115;
commitid	SAe3SQ48vKH6r5FL;

1.115
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.114;
commitid	1ap8YFU49Zg4mM41;

1.114
date	2017.01.03.13.32.51;	author bluhm;	state Exp;
branches;
next	1.113;
commitid	4q1m0pJ7v5CRCrlF;

1.113
date	2016.12.22.13.39.32;	author mpi;	state Exp;
branches;
next	1.112;
commitid	nLPA84mESw8iBVkC;

1.112
date	2016.12.21.12.30.19;	author mpi;	state Exp;
branches;
next	1.111;
commitid	FrghW2R8xsCu2Ex3;

1.111
date	2016.11.28.13.59.51;	author mpi;	state Exp;
branches;
next	1.110;
commitid	gDeAqDskWelvIYpy;

1.110
date	2016.08.23.11.03.10;	author mpi;	state Exp;
branches;
next	1.109;
commitid	YaFGsmlPtQmNg6em;

1.109
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.108;
commitid	ZsKqEaqTKPu9hWk6;

1.108
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.107;
commitid	nbCHuHn2E9uBfKJT;

1.107
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.106;
commitid	Cm0qxR09oTCkXjXZ;

1.106
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.105;
commitid	jodmGXAB42f8N6nf;

1.105
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.104;
commitid	LxUFHuffW7GZZ01f;

1.104
date	2016.06.15.11.49.35;	author mpi;	state Exp;
branches;
next	1.103;
commitid	qWegq9wDcxofLjIV;

1.103
date	2016.06.01.23.45.19;	author dlg;	state Exp;
branches;
next	1.102;
commitid	FDsCC33tBdAholzy;

1.102
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.101;
commitid	AZTNcVhJxOTcjeS6;

1.101
date	2015.12.09.15.05.51;	author mpi;	state Exp;
branches;
next	1.100;
commitid	q2xIbZZsrU0VN6YM;

1.100
date	2015.11.18.13.58.02;	author mpi;	state Exp;
branches;
next	1.99;
commitid	uGqqOfOdbFUfC7aN;

1.99
date	2015.11.02.15.05.23;	author mpi;	state Exp;
branches;
next	1.98;
commitid	aK60XMOKqPFfSdCc;

1.98
date	2015.11.02.07.24.08;	author mpi;	state Exp;
branches;
next	1.97;
commitid	j3heHwF6pc3KZsrO;

1.97
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.96;
commitid	tp9bS9eCrwvRYjyO;

1.96
date	2015.09.18.14.26.22;	author mpi;	state Exp;
branches;
next	1.95;
commitid	hGprk1rxxzKhgpj5;

1.95
date	2015.09.11.20.13.22;	author claudio;	state Exp;
branches;
next	1.94;
commitid	UPUIY6VNZRRXapwQ;

1.94
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.93;
commitid	Cr0DVA7exR1t2zXg;

1.93
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.92;
commitid	MtXIH0WHmPXVgeDN;

1.92
date	2015.08.24.15.58.35;	author mpi;	state Exp;
branches;
next	1.91;
commitid	hOA5qIh5CrYvhG4e;

1.91
date	2015.07.16.15.28.38;	author mpi;	state Exp;
branches;
next	1.90;
commitid	QBOmPvf4P5OsKq9v;

1.90
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.89;
commitid	h7z8lokZ0dFyuWpg;

1.89
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.88;
commitid	p4LJxGKbi0BU2cG6;

1.88
date	2014.12.17.09.57.13;	author mpi;	state Exp;
branches;
next	1.87;
commitid	cYQY7jiay4SydLhD;

1.87
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.86;
commitid	Vq8oSnWLkf7dyy0N;

1.86
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.85;
commitid	t9FBKDfc4VDxpEy2;

1.85
date	2014.11.20.13.54.24;	author mpi;	state Exp;
branches;
next	1.84;
commitid	F3Fu23ZZ8dwzir4r;

1.84
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.83;
commitid	Z1vcFtHO8wRH0yRt;

1.83
date	2014.11.10.10.46.10;	author mpi;	state Exp;
branches;
next	1.82;
commitid	PygNV68Vq7F7osTf;

1.82
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.81;
commitid	w0MRp28dmfD1ZzO8;

1.81
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.80;
commitid	6AYfDT0Lpez1LFQp;

1.80
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.79;
commitid	B4dZSbxas1X1IpXI;

1.79
date	2014.06.07.11.04.14;	author henning;	state Exp;
branches;
next	1.78;
commitid	3AS3WOjnaTtfOf9y;

1.78
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.77;

1.77
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2014.03.21.09.45.09;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2014.01.24.12.20.22;	author naddy;	state Exp;
branches;
next	1.74;

1.74
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.73;

1.73
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.72;

1.72
date	2013.11.19.09.00.43;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.68;

1.68
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.67;

1.67
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.66;

1.66
date	2013.03.07.09.03.16;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.64;

1.64
date	2013.03.03.00.35.14;	author bluhm;	state Exp;
branches;
next	1.63;

1.63
date	2012.05.16.09.48.38;	author mikeb;	state Exp;
branches;
next	1.62;

1.62
date	2012.01.11.19.12.23;	author bluhm;	state Exp;
branches;
next	1.61;

1.61
date	2012.01.03.23.41.51;	author bluhm;	state Exp;
branches;
next	1.60;

1.60
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.59;

1.59
date	2011.10.15.10.29.06;	author nigel;	state Exp;
branches;
next	1.58;

1.58
date	2011.10.14.16.16.43;	author stsp;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.26.21.19.51;	author bluhm;	state Exp;
branches;
next	1.56;

1.56
date	2011.03.09.23.31.25;	author bluhm;	state Exp;
branches;
next	1.55;

1.55
date	2010.02.08.11.56.09;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2008.11.25.12.11.45;	author markus;	state Exp;
branches;
next	1.53;

1.53
date	2008.10.01.21.17.06;	author claudio;	state Exp;
branches;
next	1.52;

1.52
date	2008.09.17.05.43.15;	author chl;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2008.05.11.03.50.23;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.48;

1.48
date	2008.03.04.11.19.35;	author markus;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.09.21.24.58;	author hshoexer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.08.09.31.38;	author henning;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.42;

1.42
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.16.15.41.19;	author pascoe;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.06.17.37.28;	author jmc;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.10.03.40.16;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2005.01.18.23.26.52;	author mpf;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.21.10.28.35;	author mcbride;	state Exp;
branches;
next	1.34;

1.34
date	2004.10.28.20.34.57;	author henning;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.31.09.00.32;	author mcbride;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.27.22.47.32;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.24.07.55.12;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.22.10.20.57;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.08.21.29.13;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.08.21.22.03;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.28.10.34.11;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.15.09.44.56;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.11.30.07.59.17;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.23.08.01.15;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.16.16.08.01;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.16.08.47.12;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.08.14.51.23;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.07.11.43.54;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.18.04.57.05;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.19.13.55.17;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.11.55.23;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.07.06.04.43;	author itojun;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.01.08.05.28.08;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.08.04.49.22;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.12.15.07.08.00;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	99.12.08.19.53.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.12.08.12.13.37;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.23;	author itojun;	state Exp;
branches;
next	;

1.8.2.1
date	2000.03.02.07.04.46;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.05.14.22.40.20;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.07.04.10.55.27;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2001.12.05.01.02.40;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.8.2.7;

1.8.2.7
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.8.2.8;

1.8.2.8
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.8.2.9;

1.8.2.9
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.8.2.10;

1.8.2.10
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.42.2.1
date	2008.03.21.20.38.33;	author brad;	state Exp;
branches;
next	;

1.45.2.1
date	2008.03.21.20.39.45;	author brad;	state Exp;
branches;
next	1.45.2.2;

1.45.2.2
date	2008.10.02.17.28.12;	author brad;	state Exp;
branches;
next	;

1.48.2.1
date	2008.10.02.17.28.35;	author brad;	state Exp;
branches;
next	;

1.51.2.1
date	2008.11.02.04.02.10;	author brad;	state Exp;
branches;
next	;


desc
@@


1.119
log
@Purging is at last at hand. Day of Doom is here. All that is evil
shall all be cleansed.

Remove sending of router solicitations and processing of router
advertisements from the kernel. It's handled by slaacd(8) these days.

Input & OK bluhm@@, mpi@@
@
text
@/*	$OpenBSD: nd6_nbr.c,v 1.118 2017/07/05 09:51:37 florian Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.61 2001/02/10 16:06:14 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>
#include <netinet/icmp6.h>

#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

TAILQ_HEAD(dadq_head, dadq);
struct dadq {
	TAILQ_ENTRY(dadq) dad_list;
	struct ifaddr *dad_ifa;
	int dad_count;		/* max NS to send */
	int dad_ns_tcount;	/* # of trials to send NS */
	int dad_ns_ocount;	/* NS sent so far */
	int dad_ns_icount;
	int dad_na_icount;
	struct timeout dad_timer_ch;
};

struct dadq *nd6_dad_find(struct ifaddr *);
void nd6_dad_starttimer(struct dadq *, int);
void nd6_dad_stoptimer(struct dadq *);
void nd6_dad_timer(void *);
void nd6_dad_ns_output(struct dadq *, struct ifaddr *);
void nd6_dad_ns_input(struct ifaddr *);
void nd6_dad_duplicated(struct dadq *);

int nd6_isneighbor(const struct ifnet *, const struct in6_addr *);

static int dad_maxtry = 15;	/* max # of *tries* to transmit DAD packet */

/*
 * Input an Neighbor Solicitation Message.
 *
 * Based on RFC 2461
 * Based on RFC 2462 (duplicated address detection)
 */
void
nd6_ns_input(struct mbuf *m, int off, int icmp6len)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct nd_neighbor_solicit *nd_ns;
	struct in6_addr saddr6 = ip6->ip6_src;
	struct in6_addr daddr6 = ip6->ip6_dst;
	struct in6_addr taddr6;
	struct in6_addr myaddr6;
	char *lladdr = NULL;
	struct ifaddr *ifa = NULL;
	int lladdrlen = 0;
	int anycast = 0, proxy = 0, tentative = 0;
	int router = ip6_forwarding;
	int tlladdr;
	union nd_opts ndopts;
	struct sockaddr_dl *proxydl = NULL;
	char addr[INET6_ADDRSTRLEN], addr0[INET6_ADDRSTRLEN];

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	IP6_EXTHDR_GET(nd_ns, struct nd_neighbor_solicit *, m, off, icmp6len);
	if (nd_ns == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		if_put(ifp);
		return;
	}
	ip6 = mtod(m, struct ip6_hdr *); /* adjust pointer for safety */
	taddr6 = nd_ns->nd_ns_target;

	if (ip6->ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    "nd6_ns_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim,
		    inet_ntop(AF_INET6, &ip6->ip6_src, addr, sizeof(addr)),
		    inet_ntop(AF_INET6, &ip6->ip6_dst, addr0, sizeof(addr0)),
		    ifp->if_xname));
		goto bad;
	}

	if (IN6_IS_ADDR_UNSPECIFIED(&saddr6)) {
		/* dst has to be solicited node multicast address. */
		/* don't check ifindex portion */
		if (daddr6.s6_addr16[0] == __IPV6_ADDR_INT16_MLL &&
		    daddr6.s6_addr32[1] == 0 &&
		    daddr6.s6_addr32[2] == __IPV6_ADDR_INT32_ONE &&
		    daddr6.s6_addr8[12] == 0xff) {
			; /*good*/
		} else {
			nd6log((LOG_INFO, "nd6_ns_input: bad DAD packet "
			    "(wrong ip6 dst)\n"));
			goto bad;
		}
	} else {
		/*
		 * Make sure the source address is from a neighbor's address.
		 */
		if (!nd6_isneighbor(ifp, &saddr6)) {
			nd6log((LOG_INFO, "nd6_ns_input: "
			    "NS packet from non-neighbor\n"));
			goto bad;
		}
	}


	if (IN6_IS_ADDR_MULTICAST(&taddr6)) {
		nd6log((LOG_INFO, "nd6_ns_input: bad NS target (multicast)\n"));
		goto bad;
	}

	if (IN6_IS_SCOPE_EMBED(&taddr6))
		taddr6.s6_addr16[1] = htons(ifp->if_index);

	icmp6len -= sizeof(*nd_ns);
	nd6_option_init(nd_ns + 1, icmp6len, &ndopts);
	if (nd6_options(&ndopts) < 0) {
		nd6log((LOG_INFO,
		    "nd6_ns_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
		goto freeit;
	}

	if (ndopts.nd_opts_src_lladdr) {
		lladdr = (char *)(ndopts.nd_opts_src_lladdr + 1);
		lladdrlen = ndopts.nd_opts_src_lladdr->nd_opt_len << 3;
	}

	if (IN6_IS_ADDR_UNSPECIFIED(&ip6->ip6_src) && lladdr) {
		nd6log((LOG_INFO, "nd6_ns_input: bad DAD packet "
		    "(link-layer address option)\n"));
		goto bad;
	}

	/*
	 * Attaching target link-layer address to the NA?
	 * (RFC 2461 7.2.4)
	 *
	 * NS IP dst is unicast/anycast			MUST NOT add
	 * NS IP dst is solicited-node multicast	MUST add
	 *
	 * In implementation, we add target link-layer address by default.
	 * We do not add one in MUST NOT cases.
	 */
#if 0 /* too much! */
	ifa = &in6ifa_ifpwithaddr(ifp, &daddr6)->ia_ifa;
	if (ifa && (ifatoia6(ifa)->ia6_flags & IN6_IFF_ANYCAST))
		tlladdr = 0;
	else
#endif
	if (!IN6_IS_ADDR_MULTICAST(&daddr6))
		tlladdr = 0;
	else
		tlladdr = 1;

	/*
	 * Target address (taddr6) must be either:
	 * (1) Valid unicast/anycast address for my receiving interface,
	 * (2) Unicast address for which I'm offering proxy service, or
	 * (3) "tentative" address on which DAD is being performed.
	 */
	/* (1) and (3) check. */
	ifa = &in6ifa_ifpwithaddr(ifp, &taddr6)->ia_ifa;
#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ifa && !carp_iamatch6(ifp))
		ifa = NULL;
#endif

	/* (2) check. */
	if (!ifa) {
		struct rtentry *rt;
		struct sockaddr_in6 tsin6;

		bzero(&tsin6, sizeof tsin6);
		tsin6.sin6_len = sizeof(struct sockaddr_in6);
		tsin6.sin6_family = AF_INET6;
		tsin6.sin6_addr = taddr6;

		rt = rtalloc(sin6tosa(&tsin6), 0, m->m_pkthdr.ph_rtableid);
		if (rt && (rt->rt_flags & RTF_ANNOUNCE) != 0 &&
		    rt->rt_gateway->sa_family == AF_LINK) {
			/*
			 * proxy NDP for single entry
			 */
			ifa = &in6ifa_ifpforlinklocal(ifp, IN6_IFF_TENTATIVE|
			    IN6_IFF_DUPLICATED|IN6_IFF_ANYCAST)->ia_ifa;
			if (ifa) {
				proxy = 1;
				proxydl = satosdl(rt->rt_gateway);
				router = 0;	/* XXX */
			}
		}
		if (rt)
			rtfree(rt);
	}
	if (!ifa) {
		/*
		 * We've got an NS packet, and we don't have that address
		 * assigned for us.  We MUST silently ignore it.
		 * See RFC2461 7.2.3.
		 */
		goto freeit;
	}
	myaddr6 = *IFA_IN6(ifa);
	anycast = ifatoia6(ifa)->ia6_flags & IN6_IFF_ANYCAST;
	tentative = ifatoia6(ifa)->ia6_flags & IN6_IFF_TENTATIVE;
	if (ifatoia6(ifa)->ia6_flags & IN6_IFF_DUPLICATED)
		goto freeit;

	if (lladdr && ((ifp->if_addrlen + 2 + 7) & ~7) != lladdrlen) {
		nd6log((LOG_INFO, "nd6_ns_input: lladdrlen mismatch for %s "
		    "(if %d, NS packet %d)\n",
		    inet_ntop(AF_INET6, &taddr6, addr, sizeof(addr)),
		    ifp->if_addrlen, lladdrlen - 2));
		goto bad;
	}

	if (IN6_ARE_ADDR_EQUAL(&myaddr6, &saddr6)) {
		log(LOG_INFO, "nd6_ns_input: duplicate IP6 address %s\n",
		    inet_ntop(AF_INET6, &saddr6, addr, sizeof(addr)));
		goto freeit;
	}

	/*
	 * We have neighbor solicitation packet, with target address equals to
	 * one of my tentative address.
	 *
	 * src addr	how to process?
	 * ---		---
	 * multicast	of course, invalid (rejected in ip6_input)
	 * unicast	somebody is doing address resolution -> ignore
	 * unspec	dup address detection
	 *
	 * The processing is defined in RFC 2462.
	 */
	if (tentative) {
		/*
		 * If source address is unspecified address, it is for
		 * duplicated address detection.
		 *
		 * If not, the packet is for address resolution;
		 * silently ignore it.
		 */
		if (IN6_IS_ADDR_UNSPECIFIED(&saddr6))
			nd6_dad_ns_input(ifa);

		goto freeit;
	}

	/*
	 * If the source address is unspecified address, entries must not
	 * be created or updated.
	 * It looks that sender is performing DAD.  Output NA toward
	 * all-node multicast address, to tell the sender that I'm using
	 * the address.
	 * S bit ("solicited") must be zero.
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&saddr6)) {
		saddr6 = in6addr_linklocal_allnodes;
		saddr6.s6_addr16[1] = htons(ifp->if_index);
		nd6_na_output(ifp, &saddr6, &taddr6,
		    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
		    (router ? ND_NA_FLAG_ROUTER : 0),
		    tlladdr, sdltosa(proxydl));
		goto freeit;
	}

	nd6_cache_lladdr(ifp, &saddr6, lladdr, lladdrlen, ND_NEIGHBOR_SOLICIT, 0);

	nd6_na_output(ifp, &saddr6, &taddr6,
	    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
	    (router ? ND_NA_FLAG_ROUTER : 0) | ND_NA_FLAG_SOLICITED,
	    tlladdr, sdltosa(proxydl));
 freeit:
	m_freem(m);
	if_put(ifp);
	return;

 bad:
	nd6log((LOG_ERR, "nd6_ns_input: src=%s\n",
	    inet_ntop(AF_INET6, &saddr6, addr, sizeof(addr))));
	nd6log((LOG_ERR, "nd6_ns_input: dst=%s\n",
	    inet_ntop(AF_INET6, &daddr6, addr, sizeof(addr))));
	nd6log((LOG_ERR, "nd6_ns_input: tgt=%s\n",
	    inet_ntop(AF_INET6, &taddr6, addr, sizeof(addr))));
	icmp6stat_inc(icp6s_badns);
	m_freem(m);
	if_put(ifp);
}

/*
 * Output an Neighbor Solicitation Message. Caller specifies:
 *	- ICMP6 header source IP6 address
 *	- ND6 header target IP6 address
 *	- ND6 header source datalink address
 *
 * Based on RFC 2461
 * Based on RFC 2462 (duplicated address detection)
 *
 * ln - for source address determination
 * dad - duplicated address detection
 */
void
nd6_ns_output(struct ifnet *ifp, struct in6_addr *daddr6, 
    struct in6_addr *taddr6, struct llinfo_nd6 *ln, int dad)
{
	struct mbuf *m;
	struct ip6_hdr *ip6;
	struct nd_neighbor_solicit *nd_ns;
	struct sockaddr_in6 src_sa, dst_sa;
	struct ip6_moptions im6o;
	int icmp6len;
	int maxlen;
	caddr_t mac;

	if (IN6_IS_ADDR_MULTICAST(taddr6))
		return;

	/* estimate the size of message */
	maxlen = sizeof(*ip6) + sizeof(*nd_ns);
	maxlen += (sizeof(struct nd_opt_hdr) + ifp->if_addrlen + 7) & ~7;
#ifdef DIAGNOSTIC
	if (max_linkhdr + maxlen >= MCLBYTES) {
		printf("nd6_ns_output: max_linkhdr + maxlen >= MCLBYTES "
		    "(%d + %d > %d)\n", max_linkhdr, maxlen, MCLBYTES);
		panic("nd6_ns_output: insufficient MCLBYTES");
		/* NOTREACHED */
	}
#endif

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m && max_linkhdr + maxlen >= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	if (m == NULL)
		return;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	if (daddr6 == NULL || IN6_IS_ADDR_MULTICAST(daddr6)) {
		m->m_flags |= M_MCAST;
		im6o.im6o_ifidx = ifp->if_index;
		im6o.im6o_hlim = 255;
		im6o.im6o_loop = 0;
	}

	icmp6len = sizeof(*nd_ns);
	m->m_pkthdr.len = m->m_len = sizeof(*ip6) + icmp6len;
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */

	/* fill neighbor solicitation packet */
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	/* ip6->ip6_plen will be set later */
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	ip6->ip6_hlim = 255;
	/* determine the source and destination addresses */
	bzero(&src_sa, sizeof(src_sa));
	bzero(&dst_sa, sizeof(dst_sa));
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
	if (daddr6)
		dst_sa.sin6_addr = *daddr6;
	else {
		dst_sa.sin6_addr.s6_addr16[0] = __IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = __IPV6_ADDR_INT32_ONE;
		dst_sa.sin6_addr.s6_addr32[3] = taddr6->s6_addr32[3];
		dst_sa.sin6_addr.s6_addr8[12] = 0xff;
	}
	ip6->ip6_dst = dst_sa.sin6_addr;
	if (!dad) {
		/*
		 * RFC2461 7.2.2:
		 * "If the source address of the packet prompting the
		 * solicitation is the same as one of the addresses assigned
		 * to the outgoing interface, that address SHOULD be placed
		 * in the IP Source Address of the outgoing solicitation.
		 * Otherwise, any one of the addresses assigned to the
		 * interface should be used."
		 *
		 * We use the source address for the prompting packet
		 * (saddr6), if:
		 * - saddr6 is given from the caller (by giving "ln"), and
		 * - saddr6 belongs to the outgoing interface and
		 * - if taddr is link local saddr6 must be link local as well
		 * Otherwise, we perform the source address selection as usual.
		 */
		struct ip6_hdr *hip6;		/* hold ip6 */
		struct in6_addr *saddr6;

		if (ln && ln->ln_hold) {
			hip6 = mtod(ln->ln_hold, struct ip6_hdr *);
			if (sizeof(*hip6) <= ln->ln_hold->m_len) {
				saddr6 = &hip6->ip6_src;
				if (saddr6 && IN6_IS_ADDR_LINKLOCAL(taddr6) &&
				    !IN6_IS_ADDR_LINKLOCAL(saddr6))
					saddr6 = NULL;
			} else
				saddr6 = NULL;
		} else
			saddr6 = NULL;
		if (saddr6 && in6ifa_ifpwithaddr(ifp, saddr6))
			src_sa.sin6_addr = *saddr6;
		else {
			struct rtentry *rt;

			rt = rtalloc(sin6tosa(&dst_sa), RT_RESOLVE,
			    m->m_pkthdr.ph_rtableid);
			if (!rtisvalid(rt)) {
				char addr[INET6_ADDRSTRLEN];

				nd6log((LOG_DEBUG,
				    "%s: source can't be determined: dst=%s\n",
				    __func__, inet_ntop(AF_INET6,
				    &dst_sa.sin6_addr, addr, sizeof(addr))));
				rtfree(rt);
				goto bad;
			}
			src_sa.sin6_addr =
			    ifatoia6(rt->rt_ifa)->ia_addr.sin6_addr;
			rtfree(rt);
		}
	} else {
		/*
		 * Source address for DAD packet must always be IPv6
		 * unspecified address. (0::0)
		 * We actually don't have to 0-clear the address (we did it
		 * above), but we do so here explicitly to make the intention
		 * clearer.
		 */
		bzero(&src_sa.sin6_addr, sizeof(src_sa.sin6_addr));
	}
	ip6->ip6_src = src_sa.sin6_addr;
	nd_ns = (struct nd_neighbor_solicit *)(ip6 + 1);
	nd_ns->nd_ns_type = ND_NEIGHBOR_SOLICIT;
	nd_ns->nd_ns_code = 0;
	nd_ns->nd_ns_reserved = 0;
	nd_ns->nd_ns_target = *taddr6;

	if (IN6_IS_SCOPE_EMBED(&nd_ns->nd_ns_target))
		nd_ns->nd_ns_target.s6_addr16[1] = 0;

	/*
	 * Add source link-layer address option.
	 *
	 *				spec		implementation
	 *				---		---
	 * DAD packet			MUST NOT	do not add the option
	 * there's no link layer address:
	 *				impossible	do not add the option
	 * there's link layer address:
	 *	Multicast NS		MUST add one	add the option
	 *	Unicast NS		SHOULD add one	add the option
	 */
	if (!dad && (mac = nd6_ifptomac(ifp))) {
		int optlen = sizeof(struct nd_opt_hdr) + ifp->if_addrlen;
		struct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)(nd_ns + 1);
		/* 8 byte alignments... */
		optlen = (optlen + 7) & ~7;

		m->m_pkthdr.len += optlen;
		m->m_len += optlen;
		icmp6len += optlen;
		bzero((caddr_t)nd_opt, optlen);
		nd_opt->nd_opt_type = ND_OPT_SOURCE_LINKADDR;
		nd_opt->nd_opt_len = optlen >> 3;
		bcopy(mac, (caddr_t)(nd_opt + 1), ifp->if_addrlen);
	}

	ip6->ip6_plen = htons((u_short)icmp6len);
	nd_ns->nd_ns_cksum = 0;
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;

	ip6_output(m, NULL, NULL, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL);
	icmp6stat_inc(icp6s_outhist + ND_NEIGHBOR_SOLICIT);
	return;

  bad:
	m_freem(m);
}

/*
 * Neighbor advertisement input handling.
 *
 * Based on RFC 2461
 * Based on RFC 2462 (duplicated address detection)
 *
 * the following items are not implemented yet:
 * - proxy advertisement delay rule (RFC2461 7.2.8, last paragraph, SHOULD)
 * - anycast advertisement delay rule (RFC2461 7.2.7, SHOULD)
 */
void
nd6_na_input(struct mbuf *m, int off, int icmp6len)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct nd_neighbor_advert *nd_na;
	struct in6_addr saddr6 = ip6->ip6_src;
	struct in6_addr daddr6 = ip6->ip6_dst;
	struct in6_addr taddr6;
	int flags;
	int is_router;
	int is_solicited;
	int is_override;
	char *lladdr = NULL;
	int lladdrlen = 0;
	struct ifaddr *ifa;
	struct llinfo_nd6 *ln;
	struct rtentry *rt = NULL;
	struct sockaddr_dl *sdl;
	union nd_opts ndopts;
	char addr[INET6_ADDRSTRLEN], addr0[INET6_ADDRSTRLEN];

	NET_ASSERT_LOCKED();

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	if (ip6->ip6_hlim != 255) {
		nd6log((LOG_ERR,
		    "nd6_na_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim,
		    inet_ntop(AF_INET6, &ip6->ip6_src, addr, sizeof(addr)),
		    inet_ntop(AF_INET6, &ip6->ip6_dst, addr0, sizeof(addr0)),
		    ifp->if_xname));
		goto bad;
	}

	IP6_EXTHDR_GET(nd_na, struct nd_neighbor_advert *, m, off, icmp6len);
	if (nd_na == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		if_put(ifp);
		return;
	}
	taddr6 = nd_na->nd_na_target;
	flags = nd_na->nd_na_flags_reserved;
	is_router = ((flags & ND_NA_FLAG_ROUTER) != 0);
	is_solicited = ((flags & ND_NA_FLAG_SOLICITED) != 0);
	is_override = ((flags & ND_NA_FLAG_OVERRIDE) != 0);

	if (IN6_IS_SCOPE_EMBED(&taddr6))
		taddr6.s6_addr16[1] = htons(ifp->if_index);

	if (IN6_IS_ADDR_MULTICAST(&taddr6)) {
		nd6log((LOG_ERR,
		    "nd6_na_input: invalid target address %s\n",
		    inet_ntop(AF_INET6, &taddr6, addr, sizeof(addr))));
		goto bad;
	}
	if (is_solicited && IN6_IS_ADDR_MULTICAST(&daddr6)) {
		nd6log((LOG_ERR,
		    "nd6_na_input: a solicited adv is multicasted\n"));
		goto bad;
	}

	icmp6len -= sizeof(*nd_na);
	nd6_option_init(nd_na + 1, icmp6len, &ndopts);
	if (nd6_options(&ndopts) < 0) {
		nd6log((LOG_INFO,
		    "nd6_na_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
		goto freeit;
	}

	if (IN6_IS_ADDR_MULTICAST(&daddr6) && !ndopts.nd_opts_tgt_lladdr) {
		nd6log((LOG_INFO,
		    "nd6_na_input: multicast adv without TLLA\n"));
		goto bad;
	}

	if (ndopts.nd_opts_tgt_lladdr) {
		lladdr = (char *)(ndopts.nd_opts_tgt_lladdr + 1);
		lladdrlen = ndopts.nd_opts_tgt_lladdr->nd_opt_len << 3;
	}

	ifa = &in6ifa_ifpwithaddr(ifp, &taddr6)->ia_ifa;

	/*
	 * Target address matches one of my interface address.
	 *
	 * If my address is tentative, this means that there's somebody
	 * already using the same address as mine.  This indicates DAD failure.
	 * This is defined in RFC 2462.
	 *
	 * Otherwise, process as defined in RFC 2461.
	 */
	if (ifa && (ifatoia6(ifa)->ia6_flags & IN6_IFF_TENTATIVE)) {
		struct dadq *dp;

		dp = nd6_dad_find(ifa);
		if (dp) {
			dp->dad_na_icount++;

			/* remove the address. */
			nd6_dad_duplicated(dp);
		}
		goto freeit;
	}

	if (ifa) {
#if NCARP > 0
		/*
		 * Ignore NAs silently for carp addresses if we're not
		 * the CARP master.
		 */
		if (ifp->if_type == IFT_CARP && !carp_iamatch6(ifp))
			goto freeit;
#endif
		log(LOG_ERR,
		    "nd6_na_input: duplicate IP6 address %s\n",
		    inet_ntop(AF_INET6, &taddr6, addr, sizeof(addr)));
		goto freeit;
	}
	/*
	 * Make sure the source address is from a neighbor's address.
	 */
	if (!nd6_isneighbor(ifp, &saddr6)) {
		nd6log((LOG_INFO, "nd6_na_input: "
		    "ND packet from non-neighbor\n"));
		goto bad;
	}

	if (lladdr && ((ifp->if_addrlen + 2 + 7) & ~7) != lladdrlen) {
		nd6log((LOG_INFO, "nd6_na_input: lladdrlen mismatch for %s "
		    "(if %d, NA packet %d)\n",
		    inet_ntop(AF_INET6, &taddr6, addr, sizeof(addr)),
		    ifp->if_addrlen, lladdrlen - 2));
		goto bad;
	}

	/*
	 * If no neighbor cache entry is found, NA SHOULD silently be
	 * discarded.
	 */
	rt = nd6_lookup(&taddr6, 0, ifp, ifp->if_rdomain);
	if ((rt == NULL) ||
	   ((ln = (struct llinfo_nd6 *)rt->rt_llinfo) == NULL) ||
	   ((sdl = satosdl(rt->rt_gateway)) == NULL))
		goto freeit;

	if (ln->ln_state == ND6_LLINFO_INCOMPLETE) {
		/*
		 * If the link-layer has address, and no lladdr option came,
		 * discard the packet.
		 */
		if (ifp->if_addrlen && !lladdr)
			goto freeit;

		/*
		 * Record link-layer address, and update the state.
		 */
		sdl->sdl_alen = ifp->if_addrlen;
		bcopy(lladdr, LLADDR(sdl), ifp->if_addrlen);
		if (is_solicited) {
			ln->ln_state = ND6_LLINFO_REACHABLE;
			ln->ln_byhint = 0;
			/* Notify userland that a new ND entry is reachable. */
			KERNEL_LOCK();
			rtm_send(rt, RTM_RESOLVE, ifp->if_rdomain);
			KERNEL_UNLOCK();
			if (!ND6_LLINFO_PERMANENT(ln)) {
				nd6_llinfo_settimer(ln,
				    ND_IFINFO(ifp)->reachable);
			}
		} else {
			ln->ln_state = ND6_LLINFO_STALE;
			nd6_llinfo_settimer(ln, nd6_gctimer);
		}
		if ((ln->ln_router = is_router) != 0) {
			/*
			 * This means a router's state has changed from
			 * non-reachable to probably reachable, and might
			 * affect the status of associated prefixes..
			 */
			if ((rt->rt_flags & RTF_LLINFO) == 0)
				goto freeit;	/* ln is gone */
		}
	} else {
		int llchange;

		/*
		 * Check if the link-layer address has changed or not.
		 */
		if (!lladdr)
			llchange = 0;
		else {
			if (sdl->sdl_alen) {
				if (bcmp(lladdr, LLADDR(sdl), ifp->if_addrlen))
					llchange = 1;
				else
					llchange = 0;
			} else
				llchange = 1;
		}

		/*
		 * This is VERY complex.  Look at it with care.
		 *
		 * override solicit lladdr llchange	action
		 *					(L: record lladdr)
		 *
		 *	0	0	n	--	(2c)
		 *	0	0	y	n	(2b) L
		 *	0	0	y	y	(1)    REACHABLE->STALE
		 *	0	1	n	--	(2c)   *->REACHABLE
		 *	0	1	y	n	(2b) L *->REACHABLE
		 *	0	1	y	y	(1)    REACHABLE->STALE
		 *	1	0	n	--	(2a)
		 *	1	0	y	n	(2a) L
		 *	1	0	y	y	(2a) L *->STALE
		 *	1	1	n	--	(2a)   *->REACHABLE
		 *	1	1	y	n	(2a) L *->REACHABLE
		 *	1	1	y	y	(2a) L *->REACHABLE
		 */
		if (!is_override && (lladdr && llchange)) {	   /* (1) */
			/*
			 * If state is REACHABLE, make it STALE.
			 * no other updates should be done.
			 */
			if (ln->ln_state == ND6_LLINFO_REACHABLE) {
				ln->ln_state = ND6_LLINFO_STALE;
				nd6_llinfo_settimer(ln, nd6_gctimer);
			}
			goto freeit;
		} else if (is_override				   /* (2a) */
			|| (!is_override && (lladdr && !llchange)) /* (2b) */
			|| !lladdr) {				   /* (2c) */
			/*
			 * Update link-local address, if any.
			 */
			if (llchange) {
				log(LOG_INFO, "ndp info overwritten for %s "
				    "by %s on %s\n",
				    inet_ntop(AF_INET6, &taddr6,
					addr, sizeof(addr)),
				    ether_sprintf(lladdr), ifp->if_xname);
			}
			if (lladdr) {
				sdl->sdl_alen = ifp->if_addrlen;
				bcopy(lladdr, LLADDR(sdl), ifp->if_addrlen);
			}

			/*
			 * If solicited, make the state REACHABLE.
			 * If not solicited and the link-layer address was
			 * changed, make it STALE.
			 */
			if (is_solicited) {
				ln->ln_state = ND6_LLINFO_REACHABLE;
				ln->ln_byhint = 0;
				if (!ND6_LLINFO_PERMANENT(ln)) {
					nd6_llinfo_settimer(ln,
					    ND_IFINFO(ifp)->reachable);
				}
			} else {
				if (lladdr && llchange) {
					ln->ln_state = ND6_LLINFO_STALE;
					nd6_llinfo_settimer(ln, nd6_gctimer);
				}
			}
		}

		if (ln->ln_router && !is_router) {
			if (!ip6_forwarding) {
				/*
				 * The neighbor may be used
				 * as a next hop for some destinations
				 * (e.g. redirect case). So we must
				 * call rt6_flush explicitly.
				 */
				rt6_flush(&ip6->ip6_src, ifp);
			}
		}
		ln->ln_router = is_router;
	}
	rt->rt_flags &= ~RTF_REJECT;
	ln->ln_asked = 0;
	if (ln->ln_hold) {
		struct mbuf *n = ln->ln_hold;
		ln->ln_hold = NULL;
		/*
		 * we assume ifp is not a loopback here, so just set the 2nd
		 * argument as the 1st one.
		 */
		ifp->if_output(ifp, n, rt_key(rt), rt);
		if (ln->ln_hold == n) {
			/* n is back in ln_hold. Discard. */
			m_freem(ln->ln_hold);
			ln->ln_hold = NULL;
		}
	}

 freeit:
 	rtfree(rt);
	m_freem(m);
	if_put(ifp);
	return;

 bad:
	icmp6stat_inc(icp6s_badna);
	m_freem(m);
	if_put(ifp);
}

/*
 * Neighbor advertisement output handling.
 *
 * Based on RFC 2461
 *
 * the following items are not implemented yet:
 * - proxy advertisement delay rule (RFC2461 7.2.8, last paragraph, SHOULD)
 * - anycast advertisement delay rule (RFC2461 7.2.7, SHOULD)
 *
 * tlladdr - 1 if include target link-layer address
 * sdl0 - sockaddr_dl (= proxy NA) or NULL
 */
void
nd6_na_output(struct ifnet *ifp, struct in6_addr *daddr6, 
    struct in6_addr *taddr6, u_long flags, int tlladdr, 
    struct sockaddr *sdl0)
{
	struct mbuf *m;
	struct rtentry *rt = NULL;
	struct ip6_hdr *ip6;
	struct nd_neighbor_advert *nd_na;
	struct ip6_moptions im6o;
	struct sockaddr_in6 dst_sa;
	int icmp6len, maxlen;
	caddr_t mac = NULL;

	/* estimate the size of message */
	maxlen = sizeof(*ip6) + sizeof(*nd_na);
	maxlen += (sizeof(struct nd_opt_hdr) + ifp->if_addrlen + 7) & ~7;
#ifdef DIAGNOSTIC
	if (max_linkhdr + maxlen >= MCLBYTES) {
		printf("nd6_na_output: max_linkhdr + maxlen >= MCLBYTES "
		    "(%d + %d > %d)\n", max_linkhdr, maxlen, MCLBYTES);
		panic("nd6_na_output: insufficient MCLBYTES");
		/* NOTREACHED */
	}
#endif

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m && max_linkhdr + maxlen >= MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_free(m);
			m = NULL;
		}
	}
	if (m == NULL)
		return;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_pkthdr.ph_rtableid = ifp->if_rdomain;

	if (IN6_IS_ADDR_MULTICAST(daddr6)) {
		m->m_flags |= M_MCAST;
		im6o.im6o_ifidx = ifp->if_index;
		im6o.im6o_hlim = 255;
		im6o.im6o_loop = 0;
	}

	icmp6len = sizeof(*nd_na);
	m->m_pkthdr.len = m->m_len = sizeof(struct ip6_hdr) + icmp6len;
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */

	/* fill neighbor advertisement packet */
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	ip6->ip6_hlim = 255;
	bzero(&dst_sa, sizeof(dst_sa));
	dst_sa.sin6_len = sizeof(struct sockaddr_in6);
	dst_sa.sin6_family = AF_INET6;
	dst_sa.sin6_addr = *daddr6;
	if (IN6_IS_ADDR_UNSPECIFIED(daddr6)) {
		/* reply to DAD */
		dst_sa.sin6_addr.s6_addr16[0] = __IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = 0;
		dst_sa.sin6_addr.s6_addr32[3] = __IPV6_ADDR_INT32_ONE;

		flags &= ~ND_NA_FLAG_SOLICITED;
	}
	ip6->ip6_dst = dst_sa.sin6_addr;

	/*
	 * Select a source whose scope is the same as that of the dest.
	 */
	rt = rtalloc(sin6tosa(&dst_sa), RT_RESOLVE, ifp->if_rdomain);
	if (!rtisvalid(rt)) {
		char addr[INET6_ADDRSTRLEN];

		nd6log((LOG_DEBUG, "%s: source can't be determined: dst=%s\n",
		    __func__, inet_ntop(AF_INET6, &dst_sa.sin6_addr, addr,
		    sizeof(addr))));
		rtfree(rt);
		goto bad;
	}
	ip6->ip6_src = ifatoia6(rt->rt_ifa)->ia_addr.sin6_addr;
	rtfree(rt);
	nd_na = (struct nd_neighbor_advert *)(ip6 + 1);
	nd_na->nd_na_type = ND_NEIGHBOR_ADVERT;
	nd_na->nd_na_code = 0;
	nd_na->nd_na_target = *taddr6;
	if (IN6_IS_SCOPE_EMBED(&nd_na->nd_na_target))
		nd_na->nd_na_target.s6_addr16[1] = 0;

	/*
	 * "tlladdr" indicates NS's condition for adding tlladdr or not.
	 * see nd6_ns_input() for details.
	 * Basically, if NS packet is sent to unicast/anycast addr,
	 * target lladdr option SHOULD NOT be included.
	 */
	if (tlladdr) {
		/*
		 * sdl0 != NULL indicates proxy NA.  If we do proxy, use
		 * lladdr in sdl0.  If we are not proxying (sending NA for
		 * my address) use lladdr configured for the interface.
		 */
		if (sdl0 == NULL) {
			mac = nd6_ifptomac(ifp);
		} else if (sdl0->sa_family == AF_LINK) {
			struct sockaddr_dl *sdl;
			sdl = satosdl(sdl0);
			if (sdl->sdl_alen == ifp->if_addrlen)
				mac = LLADDR(sdl);
		}
	}
	if (tlladdr && mac) {
		int optlen = sizeof(struct nd_opt_hdr) + ifp->if_addrlen;
		struct nd_opt_hdr *nd_opt = (struct nd_opt_hdr *)(nd_na + 1);

		/* roundup to 8 bytes alignment! */
		optlen = (optlen + 7) & ~7;

		m->m_pkthdr.len += optlen;
		m->m_len += optlen;
		icmp6len += optlen;
		bzero((caddr_t)nd_opt, optlen);
		nd_opt->nd_opt_type = ND_OPT_TARGET_LINKADDR;
		nd_opt->nd_opt_len = optlen >> 3;
		bcopy(mac, (caddr_t)(nd_opt + 1), ifp->if_addrlen);
	} else
		flags &= ~ND_NA_FLAG_OVERRIDE;

#if NCARP > 0
	/* Do not send NAs for carp addresses if we're not the CARP master. */
	if (ifp->if_type == IFT_CARP && !carp_iamatch6(ifp))
		goto bad;
#endif

	ip6->ip6_plen = htons((u_short)icmp6len);
	nd_na->nd_na_flags_reserved = flags;
	nd_na->nd_na_cksum = 0;
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;

	ip6_output(m, NULL, NULL, 0, &im6o, NULL);
	icmp6stat_inc(icp6s_outhist+ ND_NEIGHBOR_ADVERT);
	return;

  bad:
	m_freem(m);
}

caddr_t
nd6_ifptomac(struct ifnet *ifp)
{
	switch (ifp->if_type) {
	case IFT_ETHER:
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
	case IFT_CARP:
	case IFT_IEEE80211:
		return ((caddr_t)(ifp + 1));
	default:
		return NULL;
	}
}

static struct dadq_head dadq;
static int dad_init = 0;

struct dadq *
nd6_dad_find(struct ifaddr *ifa)
{
	struct dadq *dp;

	TAILQ_FOREACH(dp, &dadq, dad_list) {
		if (dp->dad_ifa == ifa)
			return dp;
	}
	return NULL;
}

void
nd6_dad_starttimer(struct dadq *dp, int ticks)
{

	timeout_set_proc(&dp->dad_timer_ch, nd6_dad_timer, dp->dad_ifa);
	timeout_add(&dp->dad_timer_ch, ticks);
}

void
nd6_dad_stoptimer(struct dadq *dp)
{

	timeout_del(&dp->dad_timer_ch);
}

/*
 * Start Duplicated Address Detection (DAD) for specified interface address.
 */
void
nd6_dad_start(struct ifaddr *ifa)
{
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
	struct dadq *dp;
	char addr[INET6_ADDRSTRLEN];

	NET_ASSERT_LOCKED();

	if (!dad_init) {
		TAILQ_INIT(&dadq);
		dad_init++;
	}

	/*
	 * If we don't need DAD, don't do it.
	 * There are several cases:
	 * - DAD is disabled (ip6_dad_count == 0)
	 * - the interface address is anycast
	 */
	KASSERT(ia6->ia6_flags & IN6_IFF_TENTATIVE);
	if ((ia6->ia6_flags & IN6_IFF_ANYCAST) || (!ip6_dad_count)) {
		ia6->ia6_flags &= ~IN6_IFF_TENTATIVE;
		return;
	}

	/* DAD already in progress */
	if (nd6_dad_find(ifa) != NULL)
		return;

	dp = malloc(sizeof(*dp), M_IP6NDP, M_NOWAIT | M_ZERO);
	if (dp == NULL) {
		log(LOG_ERR, "%s: memory allocation failed for %s(%s)\n",
			__func__, inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			    addr, sizeof(addr)),
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
		return;
	}
	bzero(&dp->dad_timer_ch, sizeof(dp->dad_timer_ch));

	TAILQ_INSERT_TAIL(&dadq, (struct dadq *)dp, dad_list);
	ip6_dad_pending++;

	nd6log((LOG_DEBUG, "%s: starting DAD for %s\n", ifa->ifa_ifp->if_xname,
	    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr, addr, sizeof(addr))));

	/*
	 * Send NS packet for DAD, ip6_dad_count times.
	 * Note that we must delay the first transmission, if this is the
	 * first packet to be sent from the interface after interface
	 * (re)initialization.
	 */
	dp->dad_ifa = ifa;
	ifa->ifa_refcnt++;	/* just for safety */
	dp->dad_count = ip6_dad_count;
	dp->dad_ns_icount = dp->dad_na_icount = 0;
	dp->dad_ns_ocount = dp->dad_ns_tcount = 0;
	nd6_dad_ns_output(dp, ifa);
	nd6_dad_starttimer(dp,
	    (long)ND_IFINFO(ifa->ifa_ifp)->retrans * hz / 1000);
}

/*
 * terminate DAD unconditionally.  used for address removals.
 */
void
nd6_dad_stop(struct ifaddr *ifa)
{
	struct dadq *dp;

	if (!dad_init)
		return;
	dp = nd6_dad_find(ifa);
	if (!dp) {
		/* DAD wasn't started yet */
		return;
	}

	nd6_dad_stoptimer(dp);

	TAILQ_REMOVE(&dadq, (struct dadq *)dp, dad_list);
	free(dp, M_IP6NDP, sizeof(*dp));
	dp = NULL;
	ifafree(ifa);
	ip6_dad_pending--;
}

void
nd6_dad_timer(void *xifa)
{
	struct ifaddr *ifa = xifa;
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
	struct dadq *dp;
	char addr[INET6_ADDRSTRLEN];
	int s;

	NET_LOCK(s);

	/* Sanity check */
	if (ia6 == NULL) {
		log(LOG_ERR, "%s: called with null parameter\n", __func__);
		goto done;
	}
	dp = nd6_dad_find(ifa);
	if (dp == NULL) {
		log(LOG_ERR, "%s: DAD structure not found\n", __func__);
		goto done;
	}
	if (ia6->ia6_flags & IN6_IFF_DUPLICATED) {
		log(LOG_ERR, "%s: called with duplicated address %s(%s)\n",
		    __func__, inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			addr, sizeof(addr)),
		    ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
		goto done;
	}
	if ((ia6->ia6_flags & IN6_IFF_TENTATIVE) == 0) {
		log(LOG_ERR, "%s: called with non-tentative address %s(%s)\n",
		    __func__, inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			addr, sizeof(addr)),
		    ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
		goto done;
	}

	/* timeouted with IFF_{RUNNING,UP} check */
	if (dp->dad_ns_tcount > dad_maxtry) {
		nd6log((LOG_INFO, "%s: could not run DAD, driver problem?\n",
			ifa->ifa_ifp->if_xname));

		TAILQ_REMOVE(&dadq, (struct dadq *)dp, dad_list);
		free(dp, M_IP6NDP, sizeof(*dp));
		dp = NULL;
		ifafree(ifa);
		ip6_dad_pending--;
		goto done;
	}

	/* Need more checks? */
	if (dp->dad_ns_ocount < dp->dad_count) {
		/*
		 * We have more NS to go.  Send NS packet for DAD.
		 */
		nd6_dad_ns_output(dp, ifa);
		nd6_dad_starttimer(dp,
		    (long)ND_IFINFO(ifa->ifa_ifp)->retrans * hz / 1000);
	} else {
		/*
		 * We have transmitted sufficient number of DAD packets.
		 * See what we've got.
		 */
		int duplicate;

		duplicate = 0;

		if (dp->dad_na_icount) {
			duplicate++;
		}

		if (dp->dad_ns_icount) {
			/* We've seen NS, means DAD has failed. */
			duplicate++;
		}

		if (duplicate) {
			/* dp will be freed in nd6_dad_duplicated() */
			nd6_dad_duplicated(dp);
		} else {
			/*
			 * We are done with DAD.  No NA came, no NS came.
			 * duplicated address found.
			 */
			ia6->ia6_flags &= ~IN6_IFF_TENTATIVE;

			nd6log((LOG_DEBUG,
			    "%s: DAD complete for %s - no duplicates found\n",
			    ifa->ifa_ifp->if_xname,
			    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
				addr, sizeof(addr))));

			TAILQ_REMOVE(&dadq, (struct dadq *)dp, dad_list);
			free(dp, M_IP6NDP, sizeof(*dp));
			dp = NULL;
			ifafree(ifa);
			ip6_dad_pending--;
		}
	}

done:
	NET_UNLOCK(s);
}

void
nd6_dad_duplicated(struct dadq *dp)
{
	struct in6_ifaddr *ia6 = ifatoia6(dp->dad_ifa);
	char addr[INET6_ADDRSTRLEN];

	log(LOG_ERR, "%s: DAD detected duplicate IPv6 address %s: "
	    "NS in/out=%d/%d, NA in=%d\n",
	    ia6->ia_ifp->if_xname,
	    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr, addr, sizeof(addr)),
	    dp->dad_ns_icount, dp->dad_ns_ocount, dp->dad_na_icount);

	ia6->ia6_flags &= ~IN6_IFF_TENTATIVE;
	ia6->ia6_flags |= IN6_IFF_DUPLICATED;

	/* We are done with DAD, with duplicated address found. (failure) */
	nd6_dad_stoptimer(dp);

	log(LOG_ERR, "%s: DAD complete for %s - duplicate found\n",
	    ia6->ia_ifp->if_xname,
	    inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr, addr, sizeof(addr)));
	log(LOG_ERR, "%s: manual intervention required\n",
	    ia6->ia_ifp->if_xname);

	TAILQ_REMOVE(&dadq, dp, dad_list);
	ifafree(dp->dad_ifa);
	free(dp, M_IP6NDP, sizeof(*dp));
	ip6_dad_pending--;
}

void
nd6_dad_ns_output(struct dadq *dp, struct ifaddr *ifa)
{
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
	struct ifnet *ifp = ifa->ifa_ifp;

	dp->dad_ns_tcount++;
	if ((ifp->if_flags & IFF_UP) == 0) {
#if 0
		printf("%s: interface down?\n", ifp->if_xname);
#endif
		return;
	}
	if ((ifp->if_flags & IFF_RUNNING) == 0) {
#if 0
		printf("%s: interface not running?\n", ifp->if_xname);
#endif
		return;
	}

	dp->dad_ns_ocount++;
	nd6_ns_output(ifp, NULL, &ia6->ia_addr.sin6_addr, NULL, 1);
}

void
nd6_dad_ns_input(struct ifaddr *ifa)
{
	struct dadq *dp;
	int duplicate;

	if (!ifa)
		panic("ifa == NULL in nd6_dad_ns_input");

	duplicate = 0;
	dp = nd6_dad_find(ifa);

	/*
	 * if I'm yet to start DAD, someone else started using this address
	 * first.  I have a duplicate and you win.
	 */
	if (!dp || dp->dad_ns_ocount == 0)
		duplicate++;

	/* XXX more checks for loopback situation - see nd6_dad_timer too */

	if (duplicate) {
		/* dp will be freed in nd6_dad_duplicated() */
		nd6_dad_duplicated(dp);
	} else {
		/*
		 * not sure if I got a duplicate.
		 * increment ns count and see what happens.
		 */
		if (dp)
			dp->dad_ns_icount++;
	}
}

/*
 * Check whether ``addr'' is a neighbor address connected to ``ifp''.
 */
int
nd6_isneighbor(const struct ifnet *ifp, const struct in6_addr *addr)
{
	struct rtentry		*rt;
	struct sockaddr_in6	 sin6;
	unsigned int		 tableid = ifp->if_rdomain;
	int rv = 0;

	memset(&sin6, 0, sizeof(sin6));
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_family = AF_INET6;
	sin6.sin6_addr = *addr;
	rt = rtalloc(sin6tosa(&sin6), 0, tableid);

	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_CLONING|RTF_CLONED))
		rv = if_isconnected(ifp, rt->rt_ifidx);

	rtfree(rt);
	return (rv);
}
@


1.118
log
@If we are sending a neighbor solicitation for a link local address
send it with a link local source address as well.

This helps upstream routers with their own source address
selection.

A reoccurring scenario is:
- gateway on fe80::1%if
- the gateway does not have an IP in the same prefix as our global address

When we want to talk to the outside world we first need to resolve the
gateway. We copy the source address from our outgoing packet to the
neighbor solicitation packet (a global address) and ask for layer2
information of a link local address.

The upstream router now needs to do source address selection of it's
own. Since we are coming from a global address and there is no address
from the same prefix the router uses another global address lying
around.

We then drop this with "ND packet from non-neighbor".

Reported over the years by a few people, most recently by Marc Peters
on bugs@@ who confirmed that this fixes the problem.

OK stsp@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.117 2017/06/08 13:28:03 mpi Exp $	*/
a739 1
			pfxlist_onlink_check();
d829 1
a829 20
			/*
			 * The peer dropped the router flag.
			 * Remove the sender from the Default Router List and
			 * update the Destination Cache entries.
			 */
			struct nd_defrouter *dr;
			struct in6_addr *in6;

			in6 = &satosin6(rt_key(rt))->sin6_addr;

			/*
			 * Lock to protect the default router list.
			 * XXX: this might be unnecessary, since this function
			 * is only called under the network software interrupt
			 * context.  However, we keep it just for safety.
			 */
			dr = defrouter_lookup(in6, rt->rt_ifidx);
			if (dr)
				defrtrlist_del(dr);
			else if (!ip6_forwarding) {
d831 1
a831 2
				 * Even if the neighbor is not in the default
				 * router list, the neighbor may be used
@


1.117
log
@Notify userland when a new ND is reachable.

The same notification is already present in ARP.

From Jan Klemkow, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.116 2017/05/16 12:24:04 mpi Exp $	*/
d448 2
a449 1
		 * - saddr6 belongs to the outgoing interface.
d457 1
a457 1
			if (sizeof(*hip6) <= ln->ln_hold->m_len)
d459 4
a462 1
			else
@


1.116
log
@Replace remaining splsoftassert(IPL_SOFTNET) by NET_ASSERT_LOCKED().

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.115 2017/02/09 15:23:35 jca Exp $	*/
d718 4
@


1.115
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.114 2017/01/03 13:32:51 bluhm Exp $	*/
d574 1
a574 1
	splsoftassert(IPL_SOFTNET);
d1102 1
a1102 1
	splsoftassert(IPL_SOFTNET);
@


1.114
log
@Take the neighbor solicitation's source address from the packet to
send if the mbuf contains the complete IPv6 header.  The old check
was wrong, it required one additional octet after the header.  So
the source address selection was depending on the layout of the
mbuf chain.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.113 2016/12/22 13:39:32 mpi Exp $	*/
d121 1
a121 1
		icmp6stat.icp6s_tooshort++;
d342 1
a342 1
	icmp6stat.icp6s_badns++;
d535 1
a535 1
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_SOLICIT]++;
d592 1
a592 1
		icmp6stat.icp6s_tooshort++;
d878 1
a878 1
	icmp6stat.icp6s_badna++;
d1040 1
a1040 1
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_ADVERT]++;
@


1.113
log
@Remove all splsoftnet() from ND6 converting the non-recrusive ones to
NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.112 2016/12/21 12:30:19 mpi Exp $	*/
d456 1
a456 2
			/* XXX pullup? */
			if (sizeof(*hip6) < ln->ln_hold->m_len)
@


1.112
log
@Use __func__ in debug log to reduce noise when grepping.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.111 2016/11/28 13:59:51 mpi Exp $	*/
d575 2
a829 1
			int s;
a838 1
			s = splsoftnet();
a851 1
			splx(s);
d1082 1
a1082 1
	timeout_set(&dp->dad_timer_ch, nd6_dad_timer, dp->dad_ifa);
d1192 1
a1192 1
	s = splsoftnet();		/* XXX */
d1283 1
a1283 1
	splx(s);
@


1.111
log
@Remove multiple recursive splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.110 2016/08/23 11:03:10 mpi Exp $	*/
d80 1
a80 1
void nd6_dad_timer(struct ifaddr *);
d1083 1
a1083 2
	timeout_set(&dp->dad_timer_ch, (void (*)(void *))nd6_dad_timer,
	    (void *)dp->dad_ifa);
d1185 1
a1185 1
nd6_dad_timer(struct ifaddr *ifa)
d1187 1
a1187 1
	int s;
d1191 1
d1197 1
a1197 1
		log(LOG_ERR, "nd6_dad_timer: called with null parameter\n");
d1202 1
a1202 1
		log(LOG_ERR, "nd6_dad_timer: DAD structure not found\n");
d1206 4
a1209 5
		log(LOG_ERR, "nd6_dad_timer: called with duplicated address "
			"%s(%s)\n",
			inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			    addr, sizeof(addr)),
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
d1213 4
a1216 5
		log(LOG_ERR, "nd6_dad_timer: called with non-tentative address "
			"%s(%s)\n",
			inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			    addr, sizeof(addr)),
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
@


1.110
log
@Use rtalloc(9) directly instead of in6_selectsr() in NS/NA output
routines.

This is another little step towards deprecating 'struct route{,_in6}'.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.109 2016/08/22 10:33:22 mpi Exp $	*/
d1104 2
a1105 1
	int s;
d1130 2
a1131 3
		log(LOG_ERR, "nd6_dad_start: memory allocation failed for "
			"%s(%s)\n",
			inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
a1137 1
	s = splsoftnet();
a1157 1
	splx(s);
@


1.109
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.108 2016/08/04 20:46:24 vgross Exp $	*/
a370 4
	struct route_in6 ro;

	bzero(&ro, sizeof(ro));
	ro.ro_tableid = ifp->if_rdomain;
d466 1
a466 2
			struct in6_addr *src0;
			int error;
d468 1
a468 2
			bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
			error = in6_selectsrc(&src0, &dst_sa, NULL, &ro,
d470 1
a470 1
			if (error) {
d474 4
a477 5
				    "nd6_ns_output: source can't be "
				    "determined: dst=%s, error=%d\n",
				    inet_ntop(AF_INET6, &dst_sa.sin6_addr,
					addr, sizeof(addr)),
				    error));
d480 3
a482 1
			src_sa.sin6_addr = *src0;
d535 1
a535 1
	ip6_output(m, NULL, &ro, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL);
a536 4

	if (ro.ro_rt) {		/* we don't cache this route. */
		rtfree(ro.ro_rt);
	}
a539 3
	if (ro.ro_rt) {
		rtfree(ro.ro_rt);
	}
a540 1
	return;
d903 1
d907 3
a909 9
	struct sockaddr_in6 src_sa, dst_sa;
	struct in6_addr *src0;
	int icmp6len, maxlen, error;
	caddr_t mac;
	struct route_in6 ro;

	mac = NULL;
	bzero(&ro, sizeof(ro));
	ro.ro_tableid = ifp->if_rdomain;
a953 1
	bzero(&src_sa, sizeof(src_sa));
d955 2
a956 2
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
d973 2
a974 4
	bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
	error = in6_selectsrc(&src0, &dst_sa, NULL, &ro,
	    m->m_pkthdr.ph_rtableid);
	if (error) {
d977 4
a980 4
		nd6log((LOG_DEBUG, "nd6_na_output: source can't be "
		    "determined: dst=%s, error=%d\n",
		    inet_ntop(AF_INET6, &dst_sa.sin6_addr, addr, sizeof(addr)),
		    error));
d983 2
a984 2
	src_sa.sin6_addr = *src0;
	ip6->ip6_src = src_sa.sin6_addr;
d1041 1
a1041 1
	ip6_output(m, NULL, &ro, 0, &im6o, NULL);
a1042 4

	if (ro.ro_rt) {		/* we don't cache this route. */
		rtfree(ro.ro_rt);
	}
a1045 3
	if (ro.ro_rt) {
		rtfree(ro.ro_rt);
	}
a1046 1
	return;
@


1.108
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.107 2016/07/22 11:14:41 mpi Exp $	*/
d1210 1
a1210 1
	free(dp, M_IP6NDP, 0);
d1259 1
a1259 1
		free(dp, M_IP6NDP, 0);
d1309 1
a1309 1
			free(dp, M_IP6NDP, 0);
d1346 1
a1346 1
	free(dp, M_IP6NDP, 0);
@


1.107
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.105 2016/07/05 10:17:14 mpi Exp $	*/
d474 2
a475 2
			error = in6_selectsrc(&src0, &dst_sa, NULL, NULL, &ro,
			    NULL, m->m_pkthdr.ph_rtableid);
d993 1
a993 1
	error = in6_selectsrc(&src0, &dst_sa, NULL, NULL, &ro, NULL,
@


1.106
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d474 2
a475 2
			error = in6_selectsrc(&src0, &dst_sa, NULL, &ro,
			    m->m_pkthdr.ph_rtableid);
d993 1
a993 1
	error = in6_selectsrc(&src0, &dst_sa, NULL, &ro,
@


1.105
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.104 2016/06/15 11:49:35 mpi Exp $	*/
d474 2
a475 2
			error = in6_selectsrc(&src0, &dst_sa, NULL, NULL, &ro,
			    NULL, m->m_pkthdr.ph_rtableid);
d993 1
a993 1
	error = in6_selectsrc(&src0, &dst_sa, NULL, NULL, &ro, NULL,
@


1.104
log
@Kill nd6_output(), it doesn't do anything since the resolution logic
has been moved to nd6_resolve().

ok visa@@, millert@@, florian@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.103 2016/06/01 23:45:19 dlg Exp $	*/
d241 2
a242 2
			ifa = &in6ifa_ifpforlinklocal(ifp,
			    IN6_IFF_NOTREADY | IN6_IFF_ANYCAST)->ia_ifa;
@


1.103
log
@make nd6_llinfo_settimer take seconds instead of ticks.

most callers are working in seconds, internally it uses seconds, and
you can call timeout_add_sec as easily as timeout_add.

this also fixes an issue with an nd_defrouter expire which was
incorrectly scaled with ticks in a comparison.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.102 2016/03/29 11:57:51 chl Exp $	*/
d878 1
a878 1
		nd6_output(ifp, n, satosin6(rt_key(rt)), rt);
@


1.102
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.101 2015/12/09 15:05:51 mpi Exp $	*/
d732 1
a732 1
				    (long)ND_IFINFO(ifp)->reachable * hz);
d736 1
a736 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d792 1
a792 1
				nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d823 1
a823 1
					    (long)ND_IFINFO(ifp)->reachable * hz);
d828 1
a828 2
					nd6_llinfo_settimer(ln,
					    (long)nd6_gctimer * hz);
@


1.101
log
@Keep all ether prototypes in one place.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.100 2015/11/18 13:58:02 mpi Exp $	*/
a1377 2
	struct in6_ifaddr *ia6;
	struct in6_addr *taddr6;
a1383 2
	ia6 = ifatoia6(ifa);
	taddr6 = &ia6->ia_addr.sin6_addr;
@


1.100
log
@Factorize the bits to check if a L2 route is connected, wether it is
attached to a carp(4) or bridge(4) member, to not dereference rt_ifp
directly.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.99 2015/11/02 15:05:23 mpi Exp $	*/
d53 1
@


1.99
log
@Retire ARP load-balacing, thanks for all the fish!

One of the keys of our MP work relies on making OpenBSD's kernel simpler!
In this case turning ARP processing MP-safe is quite complicated due to
the way carp(4) is hooked in arpinput() and nowadays you'd better run
kitchensinkd(9) anyway :)

ok bluhm@@, claudio@@, reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.98 2015/11/02 07:24:08 mpi Exp $	*/
d84 2
d154 1
a154 1
		if (!in6_ifpprefix(ifp, &saddr6)) {
d689 1
a689 1
	if (!in6_ifpprefix(ifp, &saddr6)) {
d1410 24
@


1.98
log
@Prefer an existing refcounted ``ifp'' to rt_ifp when possible or use the
interface index directly.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.97 2015/10/22 15:37:47 bluhm Exp $	*/
d218 1
a218 2
	if (ifp->if_type == IFT_CARP && ifa &&
	    !carp_iamatch6(ifp, lladdr, &proxydl))
a671 2
		struct sockaddr_dl *proxydl = NULL;

d676 1
a676 2
		if (ifp->if_type == IFT_CARP &&
		    !carp_iamatch6(ifp, lladdr, &proxydl))
a921 3
#if NCARP > 0
	struct sockaddr_dl *proxydl = NULL;
#endif
d1051 1
a1051 1
	if (ifp->if_type == IFT_CARP && !carp_iamatch6(ifp, mac, &proxydl))
@


1.97
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.96 2015/09/18 14:26:22 mpi Exp $	*/
d733 1
a733 1
				    (long)ND_IFINFO(rt->rt_ifp)->reachable * hz);
d854 1
a854 1
			dr = defrouter_lookup(in6, rt->rt_ifp);
d865 1
a865 1
				rt6_flush(&ip6->ip6_src, rt->rt_ifp);
@


1.96
log
@Do not manually decrement rt's refcounter in nd6_lookup() and let the
callers rtfree(9) it.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.95 2015/09/11 20:13:22 claudio Exp $	*/
a63 2
#define SDL(s) ((struct sockaddr_dl *)s)

d243 1
a243 1
				proxydl = SDL(rt->rt_gateway);
d318 1
a318 1
		    tlladdr, (struct sockaddr *)proxydl);
d327 1
a327 1
	    tlladdr, (struct sockaddr *)proxydl);
d712 1
a712 1
	   ((sdl = SDL(rt->rt_gateway)) == NULL))
d1034 1
a1034 1
			sdl = (struct sockaddr_dl *)sdl0;
@


1.95
log
@if_put after if_get for nd6_nbr. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.94 2015/09/11 08:17:06 claudio Exp $	*/
d583 1
a583 1
	struct rtentry *rt;
d891 1
@


1.94
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.93 2015/09/09 15:51:40 mpi Exp $	*/
d121 1
d332 1
d344 1
d605 1
d892 1
d898 1
@


1.93
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.92 2015/08/24 15:58:35 mpi Exp $	*/
d537 1
a537 1
	ip6_output(m, NULL, &ro, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL, NULL);
d1062 1
a1062 1
	ip6_output(m, NULL, &ro, 0, &im6o, NULL, NULL);
@


1.92
log
@Rework the code to decide when to perform DAD to no longer rely on the
IN6_IFF_NODAD pseudo-flag not being set.

This was just a flag for spaghetti code that should not exist in the
first place.

Tested by sebastia@@, ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.91 2015/07/16 15:28:38 mpi Exp $	*/
a537 2
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighborsolicit);
a1062 3

	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighboradvert);
@


1.91
log
@Kill incorrect and never set ``dad_ignore_ns'' button.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.90 2015/06/16 11:09:40 mpi Exp $	*/
a1130 2
 *
 * tick - minimum delay ticks for IFF_UP event
d1133 1
a1133 1
nd6_dad_start(struct ifaddr *ifa, int *tick)
d1138 1
d1151 2
a1152 10
	if (!(ia6->ia6_flags & IN6_IFF_TENTATIVE)) {
		log(LOG_DEBUG,
			"nd6_dad_start: called with non-tentative address "
			"%s(%s)\n",
			inet_ntop(AF_INET6, &ia6->ia_addr.sin6_addr,
			    addr, sizeof(addr)),
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
		return;
	}
	if (ia6->ia6_flags & IN6_IFF_ANYCAST) {
d1156 3
a1158 2
	if (!ip6_dad_count) {
		ia6->ia6_flags &= ~IN6_IFF_TENTATIVE;
a1159 9
	}
	if (!ifa->ifa_ifp)
		panic("nd6_dad_start: ifa->ifa_ifp == NULL");
	if (!(ifa->ifa_ifp->if_flags & IFF_UP))
		return;
	if (nd6_dad_find(ifa) != NULL) {
		/* DAD already in progress */
		return;
	}
d1171 2
d1190 4
a1193 15
	if (tick == NULL) {
		nd6_dad_ns_output(dp, ifa);
		nd6_dad_starttimer(dp,
		    (long)ND_IFINFO(ifa->ifa_ifp)->retrans * hz / 1000);
	} else {
		int ntick;

		if (*tick == 0)
			ntick = arc4random_uniform(MAX_RTR_SOLICITATION_DELAY *
			    hz);
		else
			ntick = *tick + arc4random_uniform(hz / 2);
		*tick = ntick;
		nd6_dad_starttimer(dp, ntick);
	}
@


1.90
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.89 2015/03/14 03:38:52 jsg Exp $	*/
a85 1
static int dad_ignore_ns = 0;	/* ignore NS in DAD - specwise incorrect*/
a1419 12

	/* Quickhack - completely ignore DAD NS packets */
	if (dad_ignore_ns) {
		char addr[INET6_ADDRSTRLEN];

		nd6log((LOG_INFO,
		    "nd6_dad_ns_input: ignoring DAD NS packet for "
		    "address %s(%s)\n",
		    inet_ntop(AF_INET6, taddr6, addr, sizeof(addr)),
		    ifa->ifa_ifp->if_xname));
		return;
	}
@


1.89
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.88 2014/12/17 09:57:13 mpi Exp $	*/
d98 1
a98 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d115 4
d399 1
a399 1
	m->m_pkthdr.rcvif = NULL;
d569 1
a569 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d588 4
d954 1
a954 1
	m->m_pkthdr.rcvif = NULL;
@


1.88
log
@Remove the "multicast_" prefix from the fields a multicast-only struct.

Prodded by claudio@@ and mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.87 2014/12/17 09:45:59 mpi Exp $	*/
a40 1
#include <sys/errno.h>
@


1.87
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.86 2014/12/05 15:50:04 mpi Exp $	*/
d402 2
a403 2
		im6o.im6o_multicast_hlim = 255;
		im6o.im6o_multicast_loop = 0;
d953 2
a954 2
		im6o.im6o_multicast_hlim = 255;
		im6o.im6o_multicast_loop = 0;
@


1.86
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.85 2014/11/20 13:54:24 mpi Exp $	*/
d401 1
a401 1
		im6o.im6o_multicast_ifp = ifp;
d952 1
a952 1
		im6o.im6o_multicast_ifp = ifp;
@


1.85
log
@Rework the handling of interfaces and IPv6 addresses for local delivery.

- Unicast packets sent to any local address will have their interface
set to loobpack.

- In order to differentiate traffic from interfaces having identical
link-local addresses, provide the scoped addresses to pf(4).

- Update the icmp6 state lookup logic to match scoped MLL addresses.

- Remove a shortcut in ip6_input() that bypasses pf and always look
for an RTF_LOCAL route.

Packets sent to multicast addresses still retain their original
interface due to the fact that local multicast packet delivering
does not use if_output.

This makes ping6 to link-local addresses work even with pf enabled
and "set skip" on loopbacks, reported by Pieter Verberne.

Debugged, analysed and tested with mikeb@@.

ok mikeb@@, henning@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.84 2014/11/18 02:37:31 tedu Exp $	*/
d48 1
@


1.84
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.83 2014/11/10 10:46:10 mpi Exp $	*/
d873 1
a873 1
		nd6_output(ifp, ifp, n, satosin6(rt_key(rt)), rt);
@


1.83
log
@Do not pass an ifa pointer when we already have a DAD descriptor.

Tweaks and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.82 2014/11/01 21:40:39 mpi Exp $	*/
a57 2

#include <dev/rndvar.h>
@


1.82
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.81 2014/10/14 09:52:26 mpi Exp $	*/
d68 12
a79 1
struct dadq;
d86 1
a86 1
void nd6_dad_na_input(struct ifaddr *);
d654 9
a662 1
		nd6_dad_na_input(ifa);
a1092 12
TAILQ_HEAD(dadq_head, dadq);
struct dadq {
	TAILQ_ENTRY(dadq) dad_list;
	struct ifaddr *dad_ifa;
	int dad_count;		/* max NS to send */
	int dad_ns_tcount;	/* # of trials to send NS */
	int dad_ns_ocount;	/* NS sent so far */
	int dad_ns_icount;
	int dad_na_icount;
	struct timeout dad_timer_ch;
};

a1309 4
			/*
			 * the check is in nd6_dad_na_input(),
			 * but just in case
			 */
d1319 2
a1320 3
			/* (*dp) will be freed in nd6_dad_duplicated() */
			dp = NULL;
			nd6_dad_duplicated(ifa);
d1347 1
a1347 1
nd6_dad_duplicated(struct ifaddr *ifa)
d1349 1
a1349 2
	struct in6_ifaddr *ia6 = ifatoia6(ifa);
	struct dadq *dp;
a1351 6
	dp = nd6_dad_find(ifa);
	if (dp == NULL) {
		log(LOG_ERR, "nd6_dad_duplicated: DAD structure not found\n");
		return;
	}

d1354 1
a1354 1
	    ifa->ifa_ifp->if_xname,
d1365 1
a1365 1
	    ifa->ifa_ifp->if_xname,
d1368 1
a1368 1
	    ifa->ifa_ifp->if_xname);
d1370 2
a1371 1
	TAILQ_REMOVE(&dadq, (struct dadq *)dp, dad_list);
a1372 2
	dp = NULL;
	ifafree(ifa);
d1438 2
a1439 2
		dp = NULL;	/* will be freed in nd6_dad_duplicated() */
		nd6_dad_duplicated(ifa);
a1447 16
}

void
nd6_dad_na_input(struct ifaddr *ifa)
{
	struct dadq *dp;

	if (!ifa)
		panic("ifa == NULL in nd6_dad_na_input");

	dp = nd6_dad_find(ifa);
	if (dp)
		dp->dad_na_icount++;

	/* remove the address. */
	nd6_dad_duplicated(ifa);
@


1.81
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.80 2014/07/12 18:44:23 tedu Exp $	*/
d222 1
a222 1
		rt = rtalloc1(sin6tosa(&tsin6), 0, m->m_pkthdr.ph_rtableid);
@


1.80
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.79 2014/06/07 11:04:14 henning Exp $	*/
d531 1
a531 1
		RTFREE(ro.ro_rt);
d537 1
a537 1
		RTFREE(ro.ro_rt);
d1047 1
a1047 1
		RTFREE(ro.ro_rt);
d1053 1
a1053 1
		RTFREE(ro.ro_rt);
@


1.79
log
@g/c unused IFT_L2VLAN, ok reyk bluhm
the #define stays since it's userland visible and who knows what uses it
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.77 2014/04/14 09:06:42 mpi Exp $	*/
d1229 1
a1229 1
	free(dp, M_IP6NDP);
d1278 1
a1278 1
		free(dp, M_IP6NDP);
d1333 1
a1333 1
			free(dp, M_IP6NDP);
d1376 1
a1376 1
	free(dp, M_IP6NDP);
@


1.78
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@a1066 1
	case IFT_L2VLAN:
@


1.77
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.76 2014/03/21 09:45:09 mpi Exp $	*/
d459 3
a461 3
			src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL,
			    &error, m->m_pkthdr.ph_rtableid);
			if (src0 == NULL) {
d971 1
a971 1
	src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL, &error,
d973 1
a973 1
	if (src0 == NULL) {
@


1.76
log
@If a NA is received on a carp interface in BACKUP state and match one
of the carp addresses silently ignore it since it is certainly coming
from the carp MASTER.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.75 2014/01/24 12:20:22 naddy Exp $	*/
d222 1
a222 1
		rt = rtalloc1(sin6tosa(&tsin6), 0, m->m_pkthdr.rdomain);
d387 1
a387 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
d460 1
a460 1
			    &error, m->m_pkthdr.rdomain);
d930 1
a930 1
	m->m_pkthdr.rdomain = ifp->if_rdomain;
d972 1
a972 1
	    m->m_pkthdr.rdomain);
@


1.75
log
@Instead of calculating the ICMPv6 checksum here, just set the flag that
is needed and the lower parts of the stack will take care of it.
ok henning@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.74 2014/01/13 23:03:52 bluhm Exp $	*/
a572 3
#if NCARP > 0
	struct sockaddr_dl *proxydl = NULL;
#endif
a631 5
#if NCARP > 0
	if (ifp->if_type == IFT_CARP && ifa &&
	    !carp_iamatch6(ifp, lladdr, &proxydl))
		ifa = NULL;
#endif
a646 1
	/* Just for safety, maybe unnecessary. */
d648 11
@


1.74
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.73 2014/01/07 17:07:46 mikeb Exp $	*/
d523 1
a523 2
	nd_ns->nd_ns_cksum =
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(*ip6), icmp6len);
d1036 1
a1036 2
	nd_na->nd_na_cksum =
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(struct ip6_hdr), icmp6len);
@


1.73
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.72 2013/11/19 09:00:43 mpi Exp $	*/
d1126 1
a1126 1
	struct in6_ifaddr *ia = ifatoia6(ifa);
d1141 1
a1141 1
	if (!(ia->ia6_flags & IN6_IFF_TENTATIVE)) {
d1145 1
a1145 1
			inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1150 2
a1151 2
	if (ia->ia6_flags & IN6_IFF_ANYCAST) {
		ia->ia6_flags &= ~IN6_IFF_TENTATIVE;
d1155 1
a1155 1
		ia->ia6_flags &= ~IN6_IFF_TENTATIVE;
d1171 1
a1171 1
			inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1181 1
a1181 1
	    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr, addr, sizeof(addr))));
d1240 1
a1240 1
	struct in6_ifaddr *ia = ifatoia6(ifa);
d1247 1
a1247 1
	if (ia == NULL) {
d1256 1
a1256 1
	if (ia->ia6_flags & IN6_IFF_DUPLICATED) {
d1259 1
a1259 1
			inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1264 1
a1264 1
	if ((ia->ia6_flags & IN6_IFF_TENTATIVE) == 0) {
d1267 1
a1267 1
			inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1325 1
a1325 1
			ia->ia6_flags &= ~IN6_IFF_TENTATIVE;
d1330 1
a1330 1
			    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr,
d1348 1
a1348 1
	struct in6_ifaddr *ia = ifatoia6(ifa);
d1361 1
a1361 1
	    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr, addr, sizeof(addr)),
d1364 2
a1365 2
	ia->ia6_flags &= ~IN6_IFF_TENTATIVE;
	ia->ia6_flags |= IN6_IFF_DUPLICATED;
d1372 1
a1372 1
	    inet_ntop(AF_INET6, &ia->ia_addr.sin6_addr, addr, sizeof(addr)));
d1386 1
a1386 1
	struct in6_ifaddr *ia = ifatoia6(ifa);
d1404 1
a1404 1
	nd6_ns_output(ifp, NULL, &ia->ia_addr.sin6_addr, NULL, 1);
d1410 1
a1410 1
	struct in6_ifaddr *ia;
d1418 2
a1419 2
	ia = ifatoia6(ifa);
	taddr6 = &ia->ia_addr.sin6_addr;
@


1.72
log
@Remove some FDDI/ATM leftovers.

ok mikeb@@, henning@@, deraadt@@, brad@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.71 2013/11/11 09:15:35 mpi Exp $	*/
d684 1
a684 1
	rt = nd6_lookup(&taddr6, 0, ifp);
@


1.71
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.70 2013/10/24 11:20:18 deraadt Exp $	*/
a1063 1
	case IFT_FDDI:
@


1.70
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.69 2013/10/20 11:03:02 phessler Exp $	*/
d104 1
d117 4
a120 2
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d256 2
a257 1
		    ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
d263 1
a263 1
		    ip6_sprintf(&saddr6));
d322 6
a327 3
	nd6log((LOG_ERR, "nd6_ns_input: src=%s\n", ip6_sprintf(&saddr6)));
	nd6log((LOG_ERR, "nd6_ns_input: dst=%s\n", ip6_sprintf(&daddr6)));
	nd6log((LOG_ERR, "nd6_ns_input: tgt=%s\n", ip6_sprintf(&taddr6)));
d462 2
d467 3
a469 1
				    ip6_sprintf(&dst_sa.sin6_addr), error));
d577 1
d582 4
a585 2
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d606 1
a606 1
		    ip6_sprintf(&taddr6)));
d660 1
a660 1
		    ip6_sprintf(&taddr6));
d674 2
a675 1
		    "(if %d, NA packet %d)\n", ip6_sprintf(&taddr6),
d779 3
a781 1
				    "by %s on %s\n", ip6_sprintf(&taddr6),
d973 2
d977 2
a978 1
		    ip6_sprintf(&dst_sa.sin6_addr), error));
d1129 1
d1146 2
a1147 1
			ip6_sprintf(&ia->ia_addr.sin6_addr),
d1172 2
a1173 1
			ip6_sprintf(&ia->ia_addr.sin6_addr),
d1182 1
a1182 1
	    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d1243 1
d1260 2
a1261 1
			ip6_sprintf(&ia->ia_addr.sin6_addr),
d1268 2
a1269 1
			ip6_sprintf(&ia->ia_addr.sin6_addr),
d1331 2
a1332 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d1351 1
d1361 2
a1362 1
	    ifa->ifa_ifp->if_xname, ip6_sprintf(&ia->ia_addr.sin6_addr),
d1372 2
a1373 1
	    ifa->ifa_ifp->if_xname, ip6_sprintf(&ia->ia_addr.sin6_addr));
d1426 2
d1430 2
a1431 1
		    "address %s(%s)\n", ip6_sprintf(taddr6),
@


1.69
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.68 2013/10/17 16:27:46 bluhm Exp $	*/
d124 1
a124 1
		if (daddr6.s6_addr16[0] == IPV6_ADDR_INT16_MLL &&
d126 1
a126 1
		    daddr6.s6_addr32[2] == IPV6_ADDR_INT32_ONE &&
d409 1
a409 1
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
d412 1
a412 1
		dst_sa.sin6_addr.s6_addr32[2] = IPV6_ADDR_INT32_ONE;
d939 1
a939 1
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
d943 1
a943 1
		dst_sa.sin6_addr.s6_addr32[3] = IPV6_ADDR_INT32_ONE;
@


1.68
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.67 2013/05/31 15:04:24 bluhm Exp $	*/
d352 1
d887 1
@


1.67
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.66 2013/03/07 09:03:16 mpi Exp $	*/
a52 1
#include <netinet/in_var.h>
@


1.66
log
@Remove the IFAFREE() macro, the ifafree() function it was calling already
check for the reference counter.

ok mikeb@@, miod@@, pelikan@@, kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.65 2013/03/04 14:42:25 bluhm Exp $	*/
d220 1
a220 2
		rt = rtalloc1((struct sockaddr *)&tsin6, 0,
			      m->m_pkthdr.rdomain);
d803 1
a803 1
			in6 = &((struct sockaddr_in6 *)rt_key(rt))->sin6_addr;
d838 1
a838 1
		nd6_output(ifp, ifp, n, (struct sockaddr_in6 *)rt_key(rt), rt);
@


1.65
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.64 2013/03/03 00:35:14 bluhm Exp $	*/
d1210 1
a1210 1
	IFAFREE(ifa);
d1256 1
a1256 1
		IFAFREE(ifa);
d1310 1
a1310 1
			IFAFREE(ifa);
d1350 1
a1350 1
	IFAFREE(ifa);
@


1.64
log
@Make sure that IPv6 source address selection only chooses a CARP
address if the interface is in master state.  Disable duplicate
address detection on CARP interfaces as the peer may have the same
addresses.
Test and OK sthen@@ florian@@ benno@@ camield@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.63 2012/05/16 09:48:38 mikeb Exp $	*/
d187 1
a187 1
	if (ifa && (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_ANYCAST))
d247 3
a249 3
	anycast = ((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_ANYCAST;
	tentative = ((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_TENTATIVE;
	if (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_DUPLICATED)
d638 1
a638 2
	if (ifa
	 && (((struct in6_ifaddr *)ifa)->ia6_flags & IN6_IFF_TENTATIVE)) {
d1107 1
a1107 1
	struct in6_ifaddr *ia = (struct in6_ifaddr *)ifa;
d1218 1
a1218 1
	struct in6_ifaddr *ia = (struct in6_ifaddr *)ifa;
d1322 1
a1322 1
	struct in6_ifaddr *ia = (struct in6_ifaddr *)ifa;
d1357 1
a1357 1
	struct in6_ifaddr *ia = (struct in6_ifaddr *)ifa;
d1389 1
a1389 1
	ia = (struct in6_ifaddr *)ifa;
@


1.63
log
@rfc 4861 mandates that target link local address must be included
with a neighbour advertisment sent to a multicast address;
nits & ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.62 2012/01/11 19:12:23 bluhm Exp $	*/
d564 3
d623 5
@


1.62
log
@Simplify the #if CARP and if (IFT_CARP) dance in nd6_ns_input().
Fix a white space bug while there.  No functional change.
ok mikeb@@ robert@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.61 2012/01/03 23:41:51 bluhm Exp $	*/
d606 6
@


1.61
log
@To access the ifaddr of an in_ifaddr or in6_ifaddr struct, it is
cleaner to access the first member via ia_ifa instead of casting.
No binary change.
ok henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.60 2011/11/24 17:39:55 sperreault Exp $	*/
d203 1
d205 3
a207 9
	if (ifp->if_type == IFT_CARP) {
		ifa = &in6ifa_ifpwithaddr(ifp, &taddr6)->ia_ifa;
		if (ifa && !carp_iamatch6(ifp, lladdr, &proxydl))
			ifa = NULL;
	} else {
		ifa = &in6ifa_ifpwithaddr(ifp, &taddr6)->ia_ifa;
	}
#else
	ifa = &in6ifa_ifpwithaddr(ifp, &taddr6)->ia_ifa;
d998 1
a998 1
	    	goto bad;
@


1.60
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.59 2011/10/15 10:29:06 nigel Exp $	*/
d186 1
a186 1
	ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &daddr6);
d205 1
a205 1
		ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &taddr6);
d209 1
a209 1
		ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &taddr6);
d212 1
a212 1
	ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &taddr6);
d232 2
a233 2
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp,
				IN6_IFF_NOTREADY|IN6_IFF_ANYCAST);
d618 1
a618 1
	ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &taddr6);
@


1.59
log
@dont define proxydl in nd6_na_output when NCARP = 0 as unused

OK sthend@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.58 2011/10/14 16:16:43 stsp Exp $	*/
d225 2
a226 1
		rt = rtalloc1((struct sockaddr *)&tsin6, 0, 0);
d386 1
d459 1
a459 1
			    &error);
d904 1
d945 2
a946 1
	src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL, &error);
@


1.58
log
@Prevent carp slaves from sending IPv6 neighbour advertisements for carp
addresses. Fixes "duplicate IP6 address" warnings, appearing since we started
accepting IPv6 neighbour discovery packets on carp interfaces.
ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.57 2011/07/26 21:19:51 bluhm Exp $	*/
d872 1
d874 1
@


1.57
log
@Accept neighbor discovery packets from source IPv6 addresses for
which we have a cloning or cloned route.  The old check was based
on configured interface addresses, now we use a route lookup.  This
allows us to use prefixes for the local network that ospf6d has
added.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.56 2011/03/09 23:31:25 bluhm Exp $	*/
d872 1
d993 6
@


1.56
log
@Log MAC address changes in the IPv6 neighbor discovery protocol
cache as "ndp info overwritten".  This makes the behavior similar
to ARP.
ok todd@@, deraadt@@, henning@@, giovanni@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.55 2010/02/08 11:56:09 jsing Exp $	*/
d139 1
a139 1
		if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
d643 1
a643 1
	if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
@


1.55
log
@Destatic and ansify.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.53 2008/10/01 21:17:06 claudio Exp $	*/
d753 5
@


1.54
log
@delay /etc/netstart until IPv6-DAD (dup-address-detection) is completed.
ok fries, hshoexer, claudio
@
text
@d70 7
a76 7
static struct dadq *nd6_dad_find(struct ifaddr *);
static void nd6_dad_starttimer(struct dadq *, int);
static void nd6_dad_stoptimer(struct dadq *);
static void nd6_dad_timer(struct ifaddr *);
static void nd6_dad_ns_output(struct dadq *, struct ifaddr *);
static void nd6_dad_ns_input(struct ifaddr *);
static void nd6_dad_na_input(struct ifaddr *);
d345 1
a345 1
	struct in6_addr *taddr6, struct llinfo_nd6 *ln, int dad)
d855 2
a856 2
	struct in6_addr *taddr6, u_long flags, int tlladdr, 
	struct sockaddr *sdl0)
d1045 1
a1045 1
static struct dadq *
d1057 1
a1057 1
static void
d1066 1
a1066 1
static void
d1188 1
a1188 1
static void
d1328 1
a1328 1
static void
d1352 1
a1352 1
static void
d1399 1
a1399 1
static void
@


1.53
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
From NetBSD, tested by todd@@ and naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.52 2008/09/17 05:43:15 chl Exp $	*/
d1130 1
d1185 1
d1231 1
d1285 1
d1325 1
@


1.52
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.51 2008/06/11 19:00:50 mcbride Exp $	*/
d135 9
d146 1
a552 1
#if 0
a553 1
#endif
d639 8
@


1.51
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.50 2008/05/11 03:50:23 krw Exp $	*/
a1334 1
	struct ifnet *ifp;
a1342 1
	ifp = ifa->ifa_ifp;
@


1.51.2.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.51 2008/06/11 19:00:50 mcbride Exp $	*/
a134 9
	} else {
		/*
		 * Make sure the source address is from a neighbor's address.
		 */
		if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
			nd6log((LOG_INFO, "nd6_ns_input: "
			    "NS packet from non-neighbor\n"));
			goto bad;
		}
a136 1

d543 1
d545 1
a630 8
	}
	/*
	 * Make sure the source address is from a neighbor's address.
	 */
	if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
		nd6log((LOG_INFO, "nd6_na_input: "
		    "ND packet from non-neighbor\n"));
		goto bad;
@


1.50
log
@Try harder to avoid corrupting the mbuf pool. Stuff any mbuf chain in
ln_hold or la_hold into temporary storage and null ln_hold or
la_hold before manually processing the mbuf chain. Discard the mbuf chain
if it is put back in the hold area.

ok claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.49 2008/04/18 06:42:20 djm Exp $	*/
d88 1
a88 3
nd6_ns_input(m, off, icmp6len)
	struct mbuf *m;
	int off, icmp6len;
d329 3
d334 2
a335 5
nd6_ns_output(ifp, daddr6, taddr6, ln, dad)
	struct ifnet *ifp;
	struct in6_addr *daddr6, *taddr6;
	struct llinfo_nd6 *ln;	/* for source address determination */
	int dad;	/* duplicated address detection */
d538 1
a538 3
nd6_na_input(m, off, icmp6len)
	struct mbuf *m;
	int off, icmp6len;
d833 3
d838 3
a840 6
nd6_na_output(ifp, daddr6, taddr6, flags, tlladdr, sdl0)
	struct ifnet *ifp;
	struct in6_addr *daddr6, *taddr6;
	u_long flags;
	int tlladdr;		/* 1 if include target link-layer address */
	struct sockaddr *sdl0;	/* sockaddr_dl (= proxy NA) or NULL */
d998 1
a998 2
nd6_ifptomac(ifp)
	struct ifnet *ifp;
d1030 1
a1030 2
nd6_dad_find(ifa)
	struct ifaddr *ifa;
d1042 1
a1042 3
nd6_dad_starttimer(dp, ticks)
	struct dadq *dp;
	int ticks;
d1051 1
a1051 2
nd6_dad_stoptimer(dp)
	struct dadq *dp;
d1059 2
d1063 1
a1063 3
nd6_dad_start(ifa, tick)
	struct ifaddr *ifa;
	int *tick;	/* minimum delay ticks for IFF_UP event */
d1150 1
a1150 2
nd6_dad_stop(ifa)
	struct ifaddr *ifa;
d1171 1
a1171 2
nd6_dad_timer(ifa)
	struct ifaddr *ifa;
d1274 1
a1274 2
nd6_dad_duplicated(ifa)
	struct ifaddr *ifa;
d1308 1
a1308 3
nd6_dad_ns_output(dp, ifa)
	struct dadq *dp;
	struct ifaddr *ifa;
d1332 1
a1332 2
nd6_dad_ns_input(ifa)
	struct ifaddr *ifa;
d1381 1
a1381 2
nd6_dad_na_input(ifa)
	struct ifaddr *ifa;
@


1.49
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.48 2008/03/04 11:19:35 markus Exp $	*/
d806 2
d812 6
a817 3
		nd6_output(ifp, ifp, ln->ln_hold,
			   (struct sockaddr_in6 *)rt_key(rt), rt);
		ln->ln_hold = NULL;
@


1.48
log
@fix use-after-free: pfxlist_onlink_check() might free rt_llinfo for
the current route, so make sure RTF_LLINFO is still set; fixes pr 5711;
with krw@@ and claudio@@; ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.47 2008/02/05 22:57:31 mpf Exp $	*/
d1141 2
a1142 1
			ntick = arc4random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1144 1
a1144 1
			ntick = *tick + arc4random() % (hz / 2);
@


1.48.2.1
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.48 2008/03/04 11:19:35 markus Exp $	*/
a136 9
	} else {
		/*
		 * Make sure the source address is from a neighbor's address.
		 */
		if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
			nd6log((LOG_INFO, "nd6_ns_input: "
			    "NS packet from non-neighbor\n"));
			goto bad;
		}
a138 1

d547 1
d549 1
a634 8
	}
	/*
	 * Make sure the source address is from a neighbor's address.
	 */
	if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
		nd6log((LOG_INFO, "nd6_na_input: "
		    "ND packet from non-neighbor\n"));
		goto bad;
@


1.47
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.46 2007/12/09 21:24:58 hshoexer Exp $	*/
d685 2
@


1.46
log
@take advantage of M_ZERO

ok claudio gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.45 2007/06/08 09:31:38 henning Exp $	*/
d198 1
a198 1
		if (ifa && !carp_iamatch6(ifp, ifa))
@


1.45
log
@kill arcnet leftovers, some pt out by Mike Belopuhov <mkb@@crypt.org.ru>,
some I found afterwards, ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.44 2007/06/01 00:52:38 henning Exp $	*/
d1106 1
a1106 1
	dp = malloc(sizeof(*dp), M_IP6NDP, M_NOWAIT);
a1113 1
	bzero(dp, sizeof(*dp));
@


1.45.2.1
log
@fix use-after-free: pfxlist_onlink_check() might free rt_llinfo for
the current route, so make sure RTF_LLINFO is still set; fixes pr 5711;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.45 2007/06/08 09:31:38 henning Exp $	*/
a684 2
			if ((rt->rt_flags & RTF_LLINFO) == 0)
				goto freeit;	/* ln is gone */
@


1.45.2.2
log
@If a neighbor solictation isn't from the unspecified address, make sure
that the source address matches one of the interfaces address prefixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.45.2.1 2008/03/21 20:39:45 brad Exp $	*/
a136 9
	} else {
		/*
		 * Make sure the source address is from a neighbor's address.
		 */
		if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
			nd6log((LOG_INFO, "nd6_ns_input: "
			    "NS packet from non-neighbor\n"));
			goto bad;
		}
a138 1

d547 1
d549 1
a634 8
	}
	/*
	 * Make sure the source address is from a neighbor's address.
	 */
	if (in6ifa_ifplocaladdr(ifp, &saddr6) == NULL) {
		nd6log((LOG_INFO, "nd6_na_input: "
		    "ND packet from non-neighbor\n"));
		goto bad;
@


1.44
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.43 2007/03/18 23:23:17 mpf Exp $	*/
a998 1
	case IFT_ARCNET:
@


1.43
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.42 2006/11/17 01:11:23 itojun Exp $	*/
d511 1
a511 1
	ip6_output(m, NULL, &ro, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL);
d975 1
a975 1
	ip6_output(m, NULL, &ro, 0, &im6o, NULL);
@


1.42
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.41 2006/06/16 16:49:40 henning Exp $	*/
d196 1
a196 3
	if (ifp->if_carp && ifp->if_type != IFT_CARP) 
		ifa = carp_iamatch6(ifp->if_carp, &taddr6);
	if (!ifa) 
d198 5
@


1.42.2.1
log
@fix use-after-free: pfxlist_onlink_check() might free rt_llinfo for
the current route, so make sure RTF_LLINFO is still set; fixes pr 5711;

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.42 2006/11/17 01:11:23 itojun Exp $	*/
a681 2
			if ((rt->rt_flags & RTF_LLINFO) == 0)
				goto freeit;	/* ln is gone */
@


1.41
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.40 2006/06/16 15:41:19 pascoe Exp $	*/
d144 1
a144 1
	if (IN6_IS_SCOPE_LINKLOCAL(&taddr6))
d473 1
a473 1
	if (IN6_IS_SCOPE_LINKLOCAL(&nd_ns->nd_ns_target))
d580 1
a580 1
	if (IN6_IS_SCOPE_LINKLOCAL(&taddr6))
d925 1
a925 1
	if (IN6_IS_SCOPE_LINKLOCAL(&nd_na->nd_na_target))
@


1.40
log
@Spelling.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.39 2006/03/05 21:48:57 miod Exp $	*/
d214 1
a214 1
		rt = rtalloc1((struct sockaddr *)&tsin6, 0);
@


1.39
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.38 2006/02/06 17:37:28 jmc Exp $	*/
d275 1
a275 1
		 * If not, the packet is for addess resolution;
@


1.38
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.37 2005/02/10 03:40:16 itojun Exp $	*/
d1031 1
a1031 1
	for (dp = dadq.tqh_first; dp; dp = dp->dad_list.tqe_next) {
@


1.37
log
@remove #if 0'ed code (which was experimental and should never be used)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.36 2005/01/18 23:26:52 mpf Exp $	*/
d233 1
a233 1
		 * We've got an NS packet, and we don't have that adddress
@


1.36
log
@Rewriting the lladdr can now be done without using mbuf tags.
Advertisements run through the carp interface first.
So we just take the address from ifp0.
While we're there,
also remove carp_macmatch6, which isn't used anymore.

Proposed by mcbride@@
ok mcbride@@, pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.35 2004/12/21 10:28:35 mcbride Exp $	*/
a1243 24
#if 0 /* heuristics */
			/*
			 * if
			 * - we have sent many(?) DAD NS, and
			 * - the number of NS we sent equals to the
			 *   number of NS we've got, and
			 * - we've got no NA
			 * we may have a faulty network card/driver which
			 * loops back multicasts to myself.
			 */
			if (3 < dp->dad_count
			 && dp->dad_ns_icount == dp->dad_count
			 && dp->dad_na_icount == 0) {
				log(LOG_INFO, "DAD questionable for %s(%s): "
				    "network card loops back multicast?\n",
				    ip6_sprintf(&ia->ia_addr.sin6_addr),
				    ifa->ifa_ifp->if_xname);
				/* XXX consider it a duplicate or not? */
				/* duplicate++; */
			} else {
				/* We've seen NS, means DAD has failed. */
				duplicate++;
			}
#else
a1245 1
#endif
@


1.35
log
@Check that if_type != IFT_CARP before using ifp->if_carp.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.34 2004/10/28 20:34:57 henning Exp $	*/
a940 7
#if NCARP > 0
			if (ifp->if_carp && ifp->if_type != IFT_CARP) 
				mac = carp_macmatch6(ifp->if_carp, m, taddr6);
			if (mac == NULL)
				mac = nd6_ifptomac(ifp);
#else

a941 1
#endif
@


1.34
log
@treat IFT_CARP like IFT_PROPVIRTUAL, ryan daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.33 2003/10/31 09:00:32 mcbride Exp $	*/
d196 1
a196 1
	if (ifp->if_carp) 
d942 1
a942 1
			if (ifp->if_carp) 
@


1.33
log
@Add IPv6 support to CARP.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.32 2003/06/27 22:47:32 itojun Exp $	*/
d1009 1
@


1.32
log
@split ND6 cache timer management to per-entry.  increased accuracy,
no O(N) loop.   sync w/ kame.  marc tested, daniel ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.31 2003/06/24 07:55:12 itojun Exp $	*/
d62 5
d100 1
a100 1
	struct ifaddr *ifa;
d195 6
d202 1
d940 8
a947 1
		if (sdl0 == NULL)
d949 2
a950 1
		else if (sdl0->sa_family == AF_LINK) {
@


1.31
log
@remove unneeded checks of accept_rtadv.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.30 2003/06/24 07:47:54 itojun Exp $	*/
d655 4
a658 3
			if (ln->ln_expire)
				ln->ln_expire = time.tv_sec +
				    ND_IFINFO(rt->rt_ifp)->reachable;
d661 1
a661 1
			ln->ln_expire = time.tv_sec + nd6_gctimer;
d715 1
a715 1
				ln->ln_expire = time.tv_sec + nd6_gctimer;
d737 3
a739 3
				if (ln->ln_expire) {
					ln->ln_expire = time.tv_sec +
					    ND_IFINFO(ifp)->reachable;
d744 2
a745 1
					ln->ln_expire = time.tv_sec + nd6_gctimer;
d1120 1
a1120 1
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
d1212 1
a1212 1
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
@


1.30
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.29 2003/05/22 10:20:57 itojun Exp $	*/
d770 1
a770 1
			else if (!ip6_forwarding && ip6_accept_rtadv) {
@


1.29
log
@remove break after return
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.28 2003/05/14 14:24:44 itojun Exp $	*/
a547 1
	long time_second = time.tv_sec;
d656 1
a656 1
				ln->ln_expire = time_second +
d660 1
a660 1
			ln->ln_expire = time_second + nd6_gctimer;
d714 1
a714 1
				ln->ln_expire = time_second + nd6_gctimer;
d737 1
a737 1
					ln->ln_expire = time_second +
d743 1
a743 1
					ln->ln_expire = time_second + nd6_gctimer;
@


1.28
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.27 2002/06/09 14:38:39 itojun Exp $	*/
a990 1
		break;
@


1.27
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.26 2002/06/08 21:51:08 itojun Exp $	*/
a102 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ns = (struct nd_neighbor_solicit *)((caddr_t)ip6 + off);
#else
a107 1
#endif
a557 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_na = (struct nd_neighbor_advert *)((caddr_t)ip6 + off);
#else
a562 1
#endif
@


1.26
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.25 2002/06/08 21:29:13 itojun Exp $	*/
d160 1
a160 1
	
d202 1
a202 1
		bzero(&tsin6, sizeof tsin6);		
d340 1
a340 1
	
d486 1
a486 1
		
d949 1
a949 1
		
@


1.25
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.24 2002/06/08 21:22:03 itojun Exp $	*/
d777 1
a777 1
			s = splnet();
d1176 1
a1176 1
	s = splnet();		/* XXX */
@


1.24
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.23 2002/05/29 07:54:59 itojun Exp $	*/
d1255 3
a1257 3
					"network card loops back multicast?\n",
					ip6_sprintf(&ia->ia_addr.sin6_addr),
					ifa->ifa_ifp->if_xname);
@


1.23
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.22 2002/05/28 10:34:11 itojun Exp $	*/
d98 1
d126 5
a130 5
		if (daddr6.s6_addr16[0] == IPV6_ADDR_INT16_MLL
		    /* don't check ifindex portion */
		    && daddr6.s6_addr32[1] == 0
		    && daddr6.s6_addr32[2] == IPV6_ADDR_INT32_ONE
		    && daddr6.s6_addr8[12] == 0xff) {
d134 1
a134 1
				"(wrong ip6 dst)\n"));
d157 1
a157 1
		lladdr = (char *)(ndopts.nd_opts_src_lladdr +1);
d218 1
d239 1
a239 2
		nd6log((LOG_INFO,
		    "nd6_ns_input: lladdrlen mismatch for %s "
d241 1
a241 1
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
d246 1
a246 2
		log(LOG_INFO,
		    "nd6_ns_input: duplicate IP6 address %s\n",
d289 3
a291 4
			      ((anycast || proxy || !tlladdr)
				      ? 0 : ND_NA_FLAG_OVERRIDE)
			      	| (ip6_forwarding ? ND_NA_FLAG_ROUTER : 0),
			      tlladdr, (struct sockaddr *)proxydl);
d298 3
a300 4
		      ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE)
			| (ip6_forwarding ? ND_NA_FLAG_ROUTER : 0)
			| ND_NA_FLAG_SOLICITED,
		      tlladdr, (struct sockaddr *)proxydl);
d332 1
a332 1
	struct in6_ifaddr *ia = NULL;
d337 3
a339 1
	struct ifnet *outif = NULL;
d347 1
a348 1
#ifdef DIAGNOSTIC
d351 3
a354 2
		return;
	}
d366 1
d387 5
d393 1
a393 1
		ip6->ip6_dst = *daddr6;
d395 6
a400 6
		ip6->ip6_dst.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		ip6->ip6_dst.s6_addr16[1] = htons(ifp->if_index);
		ip6->ip6_dst.s6_addr32[1] = 0;
		ip6->ip6_dst.s6_addr32[2] = IPV6_ADDR_INT32_ONE;
		ip6->ip6_dst.s6_addr32[3] = taddr6->s6_addr32[3];
		ip6->ip6_dst.s6_addr8[12] = 0xff;
d402 1
a403 14
#if 0	/* KAME way, exact address scope match */
		/*
		 * Select a source whose scope is the same as that of the dest.
		 * Typically, the dest is link-local solicitation multicast
		 * (i.e. neighbor discovery) or link-local/global unicast
		 * (i.e. neighbor un-reachability detection).
		 */
		ia = in6_ifawithifp(ifp, &ip6->ip6_dst);
		if (ia == NULL) {
			m_freem(m);
			return;
		}
		ip6->ip6_src = ia->ia_addr.sin6_addr;
#else	/* spec-wise correct */
d417 1
a417 1
		 * Otherwise, we perform a scope-wise match.
d432 1
a432 1
			bcopy(saddr6, &ip6->ip6_src, sizeof(*saddr6));
d434 12
a445 4
			ia = in6_ifawithifp(ifp, &ip6->ip6_dst);
			if (ia == NULL) {
				m_freem(m);
				return;
d447 1
a447 1
			ip6->ip6_src = ia->ia_addr.sin6_addr;
a448 1
#endif
d453 3
d457 1
a457 1
		bzero(&ip6->ip6_src, sizeof(ip6->ip6_src));
d459 1
d498 2
a499 2
	nd_ns->nd_ns_cksum
		= in6_cksum(m, IPPROTO_ICMPV6, sizeof(*ip6), icmp6len);
d501 7
a507 4
	ip6_output(m, NULL, NULL, dad ? IPV6_DADOUTPUT : 0, &im6o, &outif);
	if (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_neighborsolicit);
d509 8
a516 1
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_SOLICIT]++;
d553 1
d588 5
a592 6
	if (IN6_IS_ADDR_MULTICAST(&daddr6))
		if (is_solicited) {
			nd6log((LOG_ERR,
			    "nd6_na_input: a solicited adv is multicasted\n"));
			goto bad;
		}
d634 3
a636 4
		nd6log((LOG_INFO,
		    "nd6_na_input: lladdrlen mismatch for %s "
		    "(if %d, NA packet %d)\n",
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
d641 2
a642 1
	 * If no neighbor cache entry is found, NA SHOULD silently be discarded.
d667 1
a667 1
				ln->ln_expire = time.tv_sec +
d671 9
a679 1
			ln->ln_expire = time.tv_sec + nd6_gctimer;
a680 1
		ln->ln_router = is_router;
d725 1
a725 1
				ln->ln_expire = time.tv_sec + nd6_gctimer;
d748 1
a748 1
					ln->ln_expire = time.tv_sec +
d754 1
a754 1
					ln->ln_expire = time.tv_sec + nd6_gctimer;
d771 6
a777 1

d799 1
a799 1
		 * we assume ifp is not a p2p here, so just set the 2nd
a835 1
	struct in6_ifaddr *ia = NULL;
d837 3
a839 2
	int icmp6len;
	int maxlen;
d841 4
a844 1
	struct ifnet *outif = NULL;
d849 1
a850 1
#ifdef DIAGNOSTIC
d853 3
a856 2
		return;
	}
d868 1
d879 1
a879 1
	m->m_data += max_linkhdr;	/*or MH_ALIGN() equivalent?*/
d888 5
d895 6
a900 5
		ip6->ip6_dst.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		ip6->ip6_dst.s6_addr16[1] = htons(ifp->if_index);
		ip6->ip6_dst.s6_addr32[1] = 0;
		ip6->ip6_dst.s6_addr32[2] = 0;
		ip6->ip6_dst.s6_addr32[3] = IPV6_ADDR_INT32_ONE;
d902 2
a903 2
	} else
		ip6->ip6_dst = *daddr6;
d908 7
a914 4
	ia = in6_ifawithifp(ifp, &ip6->ip6_dst);
	if (ia == NULL) {
		m_freem(m);
		return;
d916 2
a917 1
	ip6->ip6_src = ia->ia_addr.sin6_addr;
a931 1
		mac = NULL;
d967 12
a978 1
		in6_cksum(m, IPPROTO_ICMPV6, sizeof(struct ip6_hdr), icmp6len);
d980 3
a982 4
	ip6_output(m, NULL, NULL, 0, &im6o, &outif);
	if (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_neighboradvert);
d984 2
a985 1
	icmp6stat.icp6s_outhist[ND_NEIGHBOR_ADVERT]++;
d996 4
d1123 1
a1123 1
	ifa->ifa_refcnt++;	/*just for safety*/
d1129 1
a1129 1
		nd6_dad_starttimer(dp, 
d1176 1
a1176 1
	s = splnet();		/*XXX*/
d1221 1
a1221 1
		nd6_dad_starttimer(dp, 
d1310 4
a1313 4
	log(LOG_ERR, "%s: DAD detected duplicate IPv6 address %s: %d NS, "
	    "%d NA\n", ifa->ifa_ifp->if_xname,
	    ip6_sprintf(&ia->ia_addr.sin6_addr),
	    dp->dad_ns_icount, dp->dad_na_icount);
a1375 6

	/*
	 * If it is from myself, ignore this.
	 */
	if (ifp && (ifp->if_flags & IFF_LOOPBACK))
		return;
@


1.22
log
@remove #define for kame portability
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.21 2002/03/15 09:44:56 itojun Exp $	*/
d653 1
a653 1
					nd_ifinfo[rt->rt_ifp->if_index].reachable;
d727 1
a727 1
						nd_ifinfo[ifp->if_index].reachable;
d1074 1
a1074 1
		    nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
d1166 1
a1166 1
		    nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
@


1.21
log
@s/0/NULL/ for pointer assignment.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.20 2002/03/14 01:27:12 millert Exp $	*/
a1077 1
#define random	arc4random
d1079 1
a1079 1
			ntick = random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1081 1
a1081 2
			ntick = *tick + random() % (hz / 2);
#undef random
@


1.20
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.19 2001/12/07 09:16:07 itojun Exp $	*/
d777 1
a777 1
		ln->ln_hold = 0;
@


1.19
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.18 2001/11/30 07:59:17 itojun Exp $	*/
d65 7
a71 7
static struct dadq *nd6_dad_find __P((struct ifaddr *));
static void nd6_dad_starttimer __P((struct dadq *, int));
static void nd6_dad_stoptimer __P((struct dadq *));
static void nd6_dad_timer __P((struct ifaddr *));
static void nd6_dad_ns_output __P((struct dadq *, struct ifaddr *));
static void nd6_dad_ns_input __P((struct ifaddr *));
static void nd6_dad_na_input __P((struct ifaddr *));
d985 1
a985 1
	timeout_set(&dp->dad_timer_ch, (void (*) __P((void *)))nd6_dad_timer,
@


1.19.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.19 2001/12/07 09:16:07 itojun Exp $	*/
d65 7
a71 7
static struct dadq *nd6_dad_find(struct ifaddr *);
static void nd6_dad_starttimer(struct dadq *, int);
static void nd6_dad_stoptimer(struct dadq *);
static void nd6_dad_timer(struct ifaddr *);
static void nd6_dad_ns_output(struct dadq *, struct ifaddr *);
static void nd6_dad_ns_input(struct ifaddr *);
static void nd6_dad_na_input(struct ifaddr *);
a97 1
	int router = ip6_forwarding;
d125 5
a129 5
		/* don't check ifindex portion */
		if (daddr6.s6_addr16[0] == IPV6_ADDR_INT16_MLL &&
		    daddr6.s6_addr32[1] == 0 &&
		    daddr6.s6_addr32[2] == IPV6_ADDR_INT32_ONE &&
		    daddr6.s6_addr8[12] == 0xff) {
d133 1
a133 1
			    "(wrong ip6 dst)\n"));
d156 1
a156 1
		lladdr = (char *)(ndopts.nd_opts_src_lladdr + 1);
a216 1
				router = 0;	/* XXX */
d237 2
a238 1
		nd6log((LOG_INFO, "nd6_ns_input: lladdrlen mismatch for %s "
d240 1
a240 1
		    ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
d245 2
a246 1
		log(LOG_INFO, "nd6_ns_input: duplicate IP6 address %s\n",
d289 4
a292 3
		    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
		    (router ? ND_NA_FLAG_ROUTER : 0),
		    tlladdr, (struct sockaddr *)proxydl);
d299 4
a302 3
	    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
	    (router ? ND_NA_FLAG_ROUTER : 0) | ND_NA_FLAG_SOLICITED,
	    tlladdr, (struct sockaddr *)proxydl);
d334 1
a334 1
	struct sockaddr_in6 src_sa, dst_sa;
d339 1
a339 3
	struct route_in6 ro;

	bzero(&ro, sizeof(ro));
d347 1
a348 1
	if (max_linkhdr + maxlen >= MCLBYTES) {
d351 2
a352 2
		panic("nd6_ns_output: insufficient MCLBYTES");
		/* NOTREACHED */
a353 1
#endif
a364 1
	m->m_pkthdr.rcvif = NULL;
a384 5
	/* determine the source and destination addresses */
	bzero(&src_sa, sizeof(src_sa));
	bzero(&dst_sa, sizeof(dst_sa));
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
d386 1
a386 1
		dst_sa.sin6_addr = *daddr6;
d388 6
a393 6
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = IPV6_ADDR_INT32_ONE;
		dst_sa.sin6_addr.s6_addr32[3] = taddr6->s6_addr32[3];
		dst_sa.sin6_addr.s6_addr8[12] = 0xff;
a394 1
	ip6->ip6_dst = dst_sa.sin6_addr;
d396 14
d423 1
a423 1
		 * Otherwise, we perform the source address selection as usual.
d438 1
a438 1
			src_sa.sin6_addr = *saddr6;
d440 4
a443 12
			struct in6_addr *src0;
			int error;

			bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
			src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL,
			    &error);
			if (src0 == NULL) {
				nd6log((LOG_DEBUG,
				    "nd6_ns_output: source can't be "
				    "determined: dst=%s, error=%d\n",
				    ip6_sprintf(&dst_sa.sin6_addr), error));
				goto bad;
d445 1
a445 1
			src_sa.sin6_addr = *src0;
d447 1
a451 3
		 * We actually don't have to 0-clear the address (we did it
		 * above), but we do so here explicitly to make the intention
		 * clearer.
d453 1
a453 1
		bzero(&src_sa.sin6_addr, sizeof(src_sa.sin6_addr));
a454 1
	ip6->ip6_src = src_sa.sin6_addr;
d493 2
a494 2
	nd_ns->nd_ns_cksum =
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(*ip6), icmp6len);
d496 5
a500 3
	ip6_output(m, NULL, &ro, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL);
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighborsolicit);
a501 12

	if (ro.ro_rt) {		/* we don't cache this route. */
		RTFREE(ro.ro_rt);
	}
	return;

  bad:
	if (ro.ro_rt) {
		RTFREE(ro.ro_rt);
	}
	m_freem(m);
	return;
a537 1
	long time_second = time.tv_sec;
d572 6
a577 5
	if (is_solicited && IN6_IS_ADDR_MULTICAST(&daddr6)) {
		nd6log((LOG_ERR,
		    "nd6_na_input: a solicited adv is multicasted\n"));
		goto bad;
	}
d619 4
a622 3
		nd6log((LOG_INFO, "nd6_na_input: lladdrlen mismatch for %s "
		    "(if %d, NA packet %d)\n", ip6_sprintf(&taddr6),
		    ifp->if_addrlen, lladdrlen - 2));
d627 1
a627 2
	 * If no neighbor cache entry is found, NA SHOULD silently be
	 * discarded.
d652 2
a653 2
				ln->ln_expire = time_second +
				    ND_IFINFO(rt->rt_ifp)->reachable;
d656 1
a656 9
			ln->ln_expire = time_second + nd6_gctimer;
		}
		if ((ln->ln_router = is_router) != 0) {
			/*
			 * This means a router's state has changed from
			 * non-reachable to probably reachable, and might
			 * affect the status of associated prefixes..
			 */
			pfxlist_onlink_check();
d658 1
d703 1
a703 1
				ln->ln_expire = time_second + nd6_gctimer;
d726 2
a727 2
					ln->ln_expire = time_second +
					    ND_IFINFO(ifp)->reachable;
d732 1
a732 1
					ln->ln_expire = time_second + nd6_gctimer;
d749 2
a750 7
			/*
			 * Lock to protect the default router list.
			 * XXX: this might be unnecessary, since this function
			 * is only called under the network software interrupt
			 * context.  However, we keep it just for safety.
			 */
			s = splsoftnet();
d772 1
a772 1
		 * we assume ifp is not a loopback here, so just set the 2nd
d777 1
a777 1
		ln->ln_hold = NULL;
d809 1
d811 2
a812 3
	struct sockaddr_in6 src_sa, dst_sa;
	struct in6_addr *src0;
	int icmp6len, maxlen, error;
d814 1
a814 4
	struct route_in6 ro;

	mac = NULL;
	bzero(&ro, sizeof(ro));
d819 1
a820 1
	if (max_linkhdr + maxlen >= MCLBYTES) {
d823 2
a824 2
		panic("nd6_na_output: insufficient MCLBYTES");
		/* NOTREACHED */
a825 1
#endif
a836 1
	m->m_pkthdr.rcvif = NULL;
d847 1
a847 1
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */
a855 5
	bzero(&src_sa, sizeof(src_sa));
	bzero(&dst_sa, sizeof(dst_sa));
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
	dst_sa.sin6_addr = *daddr6;
d858 5
a862 6
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = 0;
		dst_sa.sin6_addr.s6_addr32[3] = IPV6_ADDR_INT32_ONE;

d864 2
a865 2
	}
	ip6->ip6_dst = dst_sa.sin6_addr;
d870 4
a873 7
	bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
	src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL, &error);
	if (src0 == NULL) {
		nd6log((LOG_DEBUG, "nd6_na_output: source can't be "
		    "determined: dst=%s, error=%d\n",
		    ip6_sprintf(&dst_sa.sin6_addr), error));
		goto bad;
d875 1
a875 2
	src_sa.sin6_addr = *src0;
	ip6->ip6_src = src_sa.sin6_addr;
d890 1
d926 1
a926 1
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(struct ip6_hdr), icmp6len);
d928 5
a932 4
	ip6_output(m, NULL, &ro, 0, &im6o, NULL);

	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighboradvert);
a933 12

	if (ro.ro_rt) {		/* we don't cache this route. */
		RTFREE(ro.ro_rt);
	}
	return;

  bad:
	if (ro.ro_rt) {
		RTFREE(ro.ro_rt);
	}
	m_freem(m);
	return;
a943 4
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
	case IFT_L2VLAN:
	case IFT_IEEE80211:
d985 1
a985 1
	timeout_set(&dp->dad_timer_ch, (void (*)(void *))nd6_dad_timer,
d1067 1
a1067 1
	ifa->ifa_refcnt++;	/* just for safety */
d1073 2
a1074 2
		nd6_dad_starttimer(dp,
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
d1078 1
d1080 1
a1080 1
			ntick = arc4random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1082 2
a1083 1
			ntick = *tick + arc4random() % (hz / 2);
d1122 1
a1122 1
	s = splsoftnet();		/* XXX */
d1167 2
a1168 2
		nd6_dad_starttimer(dp,
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
d1201 3
a1203 3
				    "network card loops back multicast?\n",
				    ip6_sprintf(&ia->ia_addr.sin6_addr),
				    ifa->ifa_ifp->if_xname);
d1256 4
a1259 4
	log(LOG_ERR, "%s: DAD detected duplicate IPv6 address %s: "
	    "NS in/out=%d/%d, NA in=%d\n",
	    ifa->ifa_ifp->if_xname, ip6_sprintf(&ia->ia_addr.sin6_addr),
	    dp->dad_ns_icount, dp->dad_ns_ocount, dp->dad_na_icount);
d1322 6
@


1.19.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.19.2.1 2002/06/11 03:31:37 art Exp $	*/
d160 1
a160 1

d202 1
a202 1
		bzero(&tsin6, sizeof tsin6);
d340 1
a340 1

d486 1
a486 1

d949 1
a949 1

@


1.19.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d103 4
d112 1
d563 4
d572 1
@


1.18
log
@unifdef OLDIP6OUTPUT
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.17 2001/06/09 06:43:38 angelos Exp $	*/
d126 1
a126 1
		    /*don't check ifindex portion*/
d375 1
a375 1
	m->m_data += max_linkhdr;	/*or MH_ALIGN() equivalent?*/
d425 1
a425 1
		struct ip6_hdr *hip6;		/*hold ip6*/
d442 1
a442 1
				m_freem(m);	/*XXX*/
d610 1
a610 1
	/* Just for safety, maybe unnecessery. */
d1071 1
a1071 1
	if (!tick) {
d1187 1
a1187 1
#if 0 /*heuristics*/
@


1.17
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.16 2001/02/23 08:01:15 itojun Exp $	*/
a770 3
#ifdef OLDIP6OUTPUT
		(*ifp->if_output)(ifp, ln->ln_hold, rt_key(rt), rt);
#else
a776 1
#endif
@


1.16
log
@garbage-collect stale ND entries (default: 1 day).
RFC 2461 5.3.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.15 2001/02/16 16:08:01 itojun Exp $	*/
a59 2
#include <net/net_osdep.h>

d119 1
a119 1
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
d543 1
a543 1
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
d1029 1
a1029 1
			ifa->ifa_ifp ? if_name(ifa->ifa_ifp) : "???");
d1054 1
a1054 1
			ifa->ifa_ifp ? if_name(ifa->ifa_ifp) : "???");
d1061 1
a1061 1
	nd6log((LOG_DEBUG, "%s: starting DAD for %s\n", if_name(ifa->ifa_ifp),
d1142 1
a1142 1
			ifa->ifa_ifp ? if_name(ifa->ifa_ifp) : "???");
d1149 1
a1149 1
			ifa->ifa_ifp ? if_name(ifa->ifa_ifp) : "???");
d1156 1
a1156 1
			if_name(ifa->ifa_ifp)));
d1207 1
a1207 1
					if_name(ifa->ifa_ifp));
d1233 1
a1233 1
			    if_name(ifa->ifa_ifp),
d1261 1
a1261 1
	    "%d NA\n", if_name(ifa->ifa_ifp),
d1272 1
a1272 1
	    if_name(ifa->ifa_ifp), ip6_sprintf(&ia->ia_addr.sin6_addr));
d1274 1
a1274 1
	    if_name(ifa->ifa_ifp));
d1293 1
a1293 1
		printf("%s: interface down?\n", if_name(ifp));
d1299 1
a1299 1
		printf("%s: interface not running?\n", if_name(ifp));
d1338 1
a1338 1
		    if_name(ifa->ifa_ifp)));
@


1.15
log
@oops, remove #ifdef __fooBSD__.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_nbr.c,v 1.14 2001/02/16 08:47:12 itojun Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.58 2001/02/08 10:57:00 itojun Exp $	*/
d656 1
a656 1
		} else
d658 2
d703 1
a703 1
			if (ln->ln_state == ND6_LLINFO_REACHABLE)
d705 2
d732 1
a732 1
				if (lladdr && llchange)
d734 2
@


1.14
log
@make sure to clear ln_byhint when neighbor state goes to REACHABLE.
sync whitespace/comment with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.13 2001/02/08 14:51:23 itojun Exp $	*/
a1077 1
#ifdef __OpenBSD__
a1078 1
#endif
a1082 1
#ifdef __OpenBSD__
a1083 1
#endif
@


1.13
log
@use timeout_xx() throughout sys/netinet6.  sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.12 2001/02/07 11:43:54 itojun Exp $	*/
d652 1
d722 1
@


1.12
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_nbr.c,v 1.11 2001/01/18 04:57:05 itojun Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.57 2001/02/07 08:18:21 itojun Exp $	*/
d45 1
d958 1
d983 3
a985 10
#ifdef __NetBSD__
	callout_reset(&dp->dad_timer_ch, ticks,
	    (void (*) __P((void *)))nd6_dad_timer, (void *)dp->dad_ifa);
#else
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	dp->dad_timer =
#endif
	timeout((void (*) __P((void *)))nd6_dad_timer, (void *)dp->dad_ifa,
	    ticks);
#endif
d993 1
a993 9
#ifdef __NetBSD__
	callout_stop(&dp->dad_timer_ch);
#else
	untimeout((void (*) __P((void *)))nd6_dad_timer, (void *)dp->dad_ifa
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		, dp->dad_timer
#endif
		);
#endif
d1052 1
@


1.11
log
@wrap too noisy warnings into #ifdef ND6_DEBUG
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_nbr.c,v 1.10 2000/05/19 13:55:17 itojun Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.36 2000/05/17 12:35:59 jinmei Exp $	*/
d67 2
d103 13
d117 5
a121 5
#ifdef ND6_DEBUG
		log(LOG_ERR,
		    "nd6_ns_input: invalid hlim %d\n", ip6->ip6_hlim);
#endif
		goto freeit;
d133 2
a134 2
			log(LOG_INFO, "nd6_ns_input: bad DAD packet "
				"(wrong ip6 dst)\n");
a138 12
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ns = (struct nd_neighbor_solicit *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_ns, struct nd_neighbor_solicit *, m, off, icmp6len);
	if (nd_ns == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif
	taddr6 = nd_ns->nd_ns_target;

d140 1
a140 1
		log(LOG_INFO, "nd6_ns_input: bad NS target (multicast)\n");
d150 4
a153 2
		log(LOG_INFO, "nd6_ns_input: invalid ND option, ignored\n");
		goto bad;
d162 2
a163 2
		log(LOG_INFO, "nd6_ns_input: bad DAD packet "
			"(link-layer address option)\n");
d225 1
a225 1
		 * We've got a NS packet, and we don't have that adddress
d238 1
a238 1
		log(LOG_INFO,
d241 2
a242 1
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2);
d309 4
a312 3
	log(LOG_ERR, "nd6_ns_input: src=%s\n", ip6_sprintf(&saddr6));
	log(LOG_ERR, "nd6_ns_input: dst=%s\n", ip6_sprintf(&daddr6));
	log(LOG_ERR, "nd6_ns_input: tgt=%s\n", ip6_sprintf(&taddr6));
d541 5
a545 5
#ifdef ND6_DEBUG
		log(LOG_ERR,
		    "nd6_na_input: invalid hlim %d\n", ip6->ip6_hlim);
#endif
		goto freeit;
d568 1
a568 1
		log(LOG_ERR,
d570 2
a571 2
		    ip6_sprintf(&taddr6));
		goto freeit;
d575 3
a577 3
			log(LOG_ERR,
			    "nd6_na_input: a solicited adv is multicasted\n");
			goto freeit;
d583 3
a585 1
		log(LOG_INFO, "nd6_na_input: invalid ND option, ignored\n");
d620 1
a620 1
		log(LOG_INFO,
d623 2
a624 1
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2);
d779 5
d960 1
d975 34
a1018 1
	static int dad_init = 0;
d1067 2
a1068 4
#ifdef DEBUG
	log(LOG_DEBUG, "%s: starting DAD for %s\n", if_name(ifa->ifa_ifp),
	    ip6_sprintf(&ia->ia_addr.sin6_addr));
#endif
d1083 2
a1084 2
		timeout((void (*) __P((void *)))nd6_dad_timer, (void *)ifa,
			nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
d1088 3
d1092 1
a1092 1
			ntick = arc4random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1094 4
a1097 1
			ntick = *tick + arc4random() % (hz / 2);
d1099 19
a1117 2
		timeout((void (*) __P((void *)))nd6_dad_timer, (void *)ifa,
			ntick);
d1119 7
d1165 2
a1166 2
		log(LOG_ERR, "%s: could not run DAD, driver problem?\n",
		    if_name(ifa->ifa_ifp));
d1181 2
a1182 2
		timeout((void (*) __P((void *)))nd6_dad_timer, (void *)ifa,
			nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
d1241 1
a1241 2
#ifdef DEBUG
			log(LOG_INFO,
d1244 1
a1244 2
			    ip6_sprintf(&ia->ia_addr.sin6_addr));
#endif
d1279 1
a1279 1
	untimeout((void (*) __P((void *)))nd6_dad_timer, (void *)ifa);
d1345 2
a1346 1
		log(LOG_INFO, "nd6_dad_ns_input: ignoring DAD NS packet for "
d1348 1
a1348 1
		    if_name(ifa->ifa_ifp));
@


1.10
log
@never forward packet with link-local address.
experimental support for new loopback packet handling (with FAKE_LOOPBACK_IF,
rcvif will be set to real outgoing interface, not the loopback, to honor scope)
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.9 2000/02/28 11:55:23 itojun Exp $	*/
d102 1
d105 1
d534 1
d537 1
@


1.9
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_nbr.c,v 1.8 2000/02/07 06:04:43 itojun Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.29 2000/02/26 08:20:58 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d753 5
a757 1
		nd6_output(ifp, ln->ln_hold,
d759 1
a759 1
#endif 
@


1.8
log
@use log(), not printf(), for DAD messages.
make more checks on mbuf length for outbound packets.
correct include file path.
@
text
@d1 2
a2 1
/*	$OpenBSD: nd6_nbr.c,v 1.7 2000/01/08 05:28:08 deraadt Exp $	*/
a64 4
#if 0
extern	struct timeval time;
#endif

a79 2
 *
 * XXX proxy advertisement
d88 1
a88 2
	struct nd_neighbor_solicit *nd_ns
		= (struct nd_neighbor_solicit *)((caddr_t)ip6 + off);
d91 1
a91 1
	struct in6_addr taddr6 = nd_ns->nd_ns_target;
d99 1
d104 1
a104 1
		return;
d122 12
d191 1
a191 1
	if (!ifa && nd6_proxyall) {
d201 2
a202 1
		if (rt && rt->rt_ifp != ifp) {
d204 1
a204 2
			 * search link local addr for ifp, and use it for
			 * proxy NA.
d206 3
a208 2
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp);
			if (ifa)
d210 2
d213 2
a214 1
		rtfree(rt);
d222 1
a222 1
		return;
d228 1
a228 1
		return;
d241 1
a241 1
		return;
d267 1
a267 1
		return;
d285 2
a286 2
			      tlladdr);
		return;
d295 3
a297 1
		      tlladdr);
d304 1
a304 1
	return;
d501 4
d513 1
a513 2
	struct nd_neighbor_advert *nd_na
		= (struct nd_neighbor_advert *)((caddr_t)ip6 + off);
d518 5
a522 5
	struct in6_addr taddr6 = nd_na->nd_na_target;
	int flags = nd_na->nd_na_flags_reserved;
	int is_router = ((flags & ND_NA_FLAG_ROUTER) != 0);
	int is_solicited = ((flags & ND_NA_FLAG_SOLICITED) != 0);
	int is_override = ((flags & ND_NA_FLAG_OVERRIDE) != 0);
d534 10
d546 6
d560 1
a560 1
		return;
d566 1
a566 1
			return;
d573 1
a573 1
		return;
d595 1
a595 1
		return;
d603 1
a603 1
		return;
d620 1
a620 1
		return;
d628 1
a628 1
			return;
d687 1
a687 1
			return;
d758 3
d768 3
a770 3
 * XXX NA delay for anycast address is not implemented yet
 *      (RFC 2461 7.2.7)
 * XXX proxy advertisement?
d773 1
a773 1
nd6_na_output(ifp, daddr6, taddr6, flags, tlladdr)
d777 2
a778 1
	int tlladdr;	/* 1 if include target link-layer address */
d863 17
a879 1
	if (tlladdr && (mac = nd6_ifptomac(ifp))) {
d1157 3
a1159 2
			log(LOG_INFO, "%s: DAD complete for %s - no duplicates "
			    "found\n", if_name(ifa->ifa_ifp),
@


1.8.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: nd6_nbr.c,v 1.29 2000/02/26 08:20:58 itojun Exp $	*/
d64 4
d83 2
d93 2
a94 1
	struct nd_neighbor_solicit *nd_ns;
d97 1
a97 1
	struct in6_addr taddr6;
a104 1
	struct sockaddr_dl *proxydl = NULL;
d109 1
a109 1
		goto freeit;
a126 12
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ns = (struct nd_neighbor_solicit *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_ns, struct nd_neighbor_solicit *, m, off, icmp6len);
	if (nd_ns == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif
	taddr6 = nd_ns->nd_ns_target;

d184 1
a184 1
	if (!ifa) {
d194 1
a194 2
		if (rt && (rt->rt_flags & RTF_ANNOUNCE) != 0 &&
		    rt->rt_gateway->sa_family == AF_LINK) {
d196 2
a197 1
			 * proxy NDP for single entry
d199 2
a200 3
			ifa = (struct ifaddr *)in6ifa_ifpforlinklocal(ifp,
				IN6_IFF_NOTREADY|IN6_IFF_ANYCAST);
			if (ifa) {
a201 2
				proxydl = SDL(rt->rt_gateway);
			}
d203 1
a203 2
		if (rt)
			rtfree(rt);
d211 1
a211 1
		goto freeit;
d217 1
a217 1
		goto freeit;
d230 1
a230 1
		goto freeit;
d256 1
a256 1
		goto freeit;
d274 2
a275 2
			      tlladdr, (struct sockaddr *)proxydl);
		goto freeit;
d284 1
a284 3
		      tlladdr, (struct sockaddr *)proxydl);
 freeit:
	m_freem(m);
d291 1
a291 1
	m_freem(m);
a487 4
 *
 * the following items are not implemented yet:
 * - proxy advertisement delay rule (RFC2461 7.2.8, last paragraph, SHOULD)
 * - anycast advertisement delay rule (RFC2461 7.2.7, SHOULD)
d496 2
a497 1
	struct nd_neighbor_advert *nd_na;
d502 5
a506 5
	struct in6_addr taddr6;
	int flags;
	int is_router;
	int is_solicited;
	int is_override;
a517 10
		goto freeit;
	}

#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_na = (struct nd_neighbor_advert *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_na, struct nd_neighbor_advert *, m, off, icmp6len);
	if (nd_na == NULL) {
		icmp6stat.icp6s_tooshort++;
a519 6
#endif
	taddr6 = nd_na->nd_na_target;
	flags = nd_na->nd_na_flags_reserved;
	is_router = ((flags & ND_NA_FLAG_ROUTER) != 0);
	is_solicited = ((flags & ND_NA_FLAG_SOLICITED) != 0);
	is_override = ((flags & ND_NA_FLAG_OVERRIDE) != 0);
d528 1
a528 1
		goto freeit;
d534 1
a534 1
			goto freeit;
d541 1
a541 1
		goto freeit;
d563 1
a563 1
		goto freeit;
d571 1
a571 1
		goto freeit;
d588 1
a588 1
		goto freeit;
d596 1
a596 1
			goto freeit;
d655 1
a655 1
			goto freeit;
a725 3

 freeit:
	m_freem(m);
d733 3
a735 3
 * the following items are not implemented yet:
 * - proxy advertisement delay rule (RFC2461 7.2.8, last paragraph, SHOULD)
 * - anycast advertisement delay rule (RFC2461 7.2.7, SHOULD)
d738 1
a738 1
nd6_na_output(ifp, daddr6, taddr6, flags, tlladdr, sdl0)
d742 1
a742 2
	int tlladdr;		/* 1 if include target link-layer address */
	struct sockaddr *sdl0;	/* sockaddr_dl (= proxy NA) or NULL */
d827 1
a827 17
	if (tlladdr) {
		mac = NULL;
		/*
		 * sdl0 != NULL indicates proxy NA.  If we do proxy, use
		 * lladdr in sdl0.  If we are not proxying (sending NA for
		 * my address) use lladdr configured for the interface.
		 */
		if (sdl0 == NULL)
			mac = nd6_ifptomac(ifp);
		else if (sdl0->sa_family == AF_LINK) {
			struct sockaddr_dl *sdl;
			sdl = (struct sockaddr_dl *)sdl0;
			if (sdl->sdl_alen == ifp->if_addrlen)
				mac = LLADDR(sdl);
		}
	}
	if (tlladdr && mac) {
d1105 2
a1106 3
			log(LOG_INFO,
			    "%s: DAD complete for %s - no duplicates found\n",
			    if_name(ifa->ifa_ifp),
@


1.8.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: nd6_nbr.c,v 1.16 2001/02/23 08:01:15 itojun Exp $	*/
/*	$KAME: nd6_nbr.c,v 1.61 2001/02/10 16:06:14 jinmei Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a44 1
#include <sys/timeout.h>
a66 2
static void nd6_dad_starttimer __P((struct dadq *, int));
static void nd6_dad_stoptimer __P((struct dadq *));
a100 13
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_ns = (struct nd_neighbor_solicit *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_ns, struct nd_neighbor_solicit *, m, off, icmp6len);
	if (nd_ns == NULL) {
		icmp6stat.icp6s_tooshort++;
		return;
	}
#endif
	ip6 = mtod(m, struct ip6_hdr *); /* adjust pointer for safety */
	taddr6 = nd_ns->nd_ns_target;

d102 3
a104 5
		nd6log((LOG_ERR,
		    "nd6_ns_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
		goto bad;
d116 2
a117 2
			nd6log((LOG_INFO, "nd6_ns_input: bad DAD packet "
				"(wrong ip6 dst)\n"));
d122 12
d135 1
a135 1
		nd6log((LOG_INFO, "nd6_ns_input: bad NS target (multicast)\n"));
d145 2
a146 4
		nd6log((LOG_INFO,
		    "nd6_ns_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
		goto freeit;
d155 2
a156 2
		nd6log((LOG_INFO, "nd6_ns_input: bad DAD packet "
		    "(link-layer address option)\n"));
d218 1
a218 1
		 * We've got an NS packet, and we don't have that adddress
d231 1
a231 1
		nd6log((LOG_INFO,
d234 1
a234 2
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
		goto bad;
d301 3
a303 4
	nd6log((LOG_ERR, "nd6_ns_input: src=%s\n", ip6_sprintf(&saddr6)));
	nd6log((LOG_ERR, "nd6_ns_input: dst=%s\n", ip6_sprintf(&daddr6)));
	nd6log((LOG_ERR, "nd6_ns_input: tgt=%s\n", ip6_sprintf(&taddr6)));
	icmp6stat.icp6s_badns++;
d532 3
a534 5
		nd6log((LOG_ERR,
		    "nd6_na_input: invalid hlim (%d) from %s to %s on %s\n",
		    ip6->ip6_hlim, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst), if_name(ifp)));
		goto bad;
d557 1
a557 1
		nd6log((LOG_ERR,
d559 2
a560 2
		    ip6_sprintf(&taddr6)));
		goto bad;
d564 3
a566 3
			nd6log((LOG_ERR,
			    "nd6_na_input: a solicited adv is multicasted\n"));
			goto bad;
d572 1
a572 3
		nd6log((LOG_INFO,
		    "nd6_na_input: invalid ND option, ignored\n"));
		/* nd6_options have incremented stats */
d607 1
a607 1
		nd6log((LOG_INFO,
d610 1
a610 2
			ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
		goto bad;
a636 1
			ln->ln_byhint = 0;
d640 1
a640 1
		} else {
a641 2
			ln->ln_expire = time.tv_sec + nd6_gctimer;
		}
d685 1
a685 1
			if (ln->ln_state == ND6_LLINFO_REACHABLE) {
a686 2
				ln->ln_expire = time.tv_sec + nd6_gctimer;
			}
a705 1
				ln->ln_byhint = 0;
d711 1
a711 1
				if (lladdr && llchange) {
a712 2
					ln->ln_expire = time.tv_sec + nd6_gctimer;
				}
d753 1
a753 5
		/*
		 * we assume ifp is not a p2p here, so just set the 2nd
		 * argument as the 1st one.
		 */
		nd6_output(ifp, ifp, ln->ln_hold,
d755 1
a755 1
#endif
a760 5
	return;

 bad:
	icmp6stat.icp6s_badna++;
	m_freem(m);
a933 1
	struct timeout dad_timer_ch;
a936 1
static int dad_init = 0;
a950 19
static void
nd6_dad_starttimer(dp, ticks)
	struct dadq *dp;
	int ticks;
{

	timeout_set(&dp->dad_timer_ch, (void (*) __P((void *)))nd6_dad_timer,
	    (void *)dp->dad_ifa);
	timeout_add(&dp->dad_timer_ch, ticks);
}

static void
nd6_dad_stoptimer(dp)
	struct dadq *dp;
{

	timeout_del(&dp->dad_timer_ch);
}

d961 1
a1007 1
	bzero(&dp->dad_timer_ch, sizeof(dp->dad_timer_ch));
d1010 4
a1013 2
	nd6log((LOG_DEBUG, "%s: starting DAD for %s\n", if_name(ifa->ifa_ifp),
	    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d1028 2
a1029 2
		nd6_dad_starttimer(dp, 
		    nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
a1032 1
#define random	arc4random
d1034 1
a1034 1
			ntick = random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1036 1
a1036 2
			ntick = *tick + random() % (hz / 2);
#undef random
d1038 2
a1039 19
		nd6_dad_starttimer(dp, ntick);
	}
}

/*
 * terminate DAD unconditionally.  used for address removals.
 */
void
nd6_dad_stop(ifa)
	struct ifaddr *ifa;
{
	struct dadq *dp;

	if (!dad_init)
		return;
	dp = nd6_dad_find(ifa);
	if (!dp) {
		/* DAD wasn't started yet */
		return;
a1040 7

	nd6_dad_stoptimer(dp);

	TAILQ_REMOVE(&dadq, (struct dadq *)dp, dad_list);
	free(dp, M_IP6NDP);
	dp = NULL;
	IFAFREE(ifa);
d1080 2
a1081 2
		nd6log((LOG_INFO, "%s: could not run DAD, driver problem?\n",
			if_name(ifa->ifa_ifp)));
d1096 2
a1097 2
		nd6_dad_starttimer(dp, 
		    nd_ifinfo[ifa->ifa_ifp->if_index].retrans * hz / 1000);
d1156 2
a1157 1
			nd6log((LOG_DEBUG,
d1160 2
a1161 1
			    ip6_sprintf(&ia->ia_addr.sin6_addr)));
d1196 1
a1196 1
	nd6_dad_stoptimer(dp);
d1262 1
a1262 2
		nd6log((LOG_INFO,
		    "nd6_dad_ns_input: ignoring DAD NS packet for "
d1264 1
a1264 1
		    if_name(ifa->ifa_ifp)));
@


1.8.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.8.2.2 2001/05/14 22:40:20 niklas Exp $	*/
d60 2
d121 1
a121 1
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d545 1
a545 1
		    ip6_sprintf(&ip6->ip6_dst), ifp->if_xname));
d1031 1
a1031 1
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
d1056 1
a1056 1
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
d1063 1
a1063 1
	nd6log((LOG_DEBUG, "%s: starting DAD for %s\n", ifa->ifa_ifp->if_xname,
d1144 1
a1144 1
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
d1151 1
a1151 1
			ifa->ifa_ifp ? ifa->ifa_ifp->if_xname : "???");
d1158 1
a1158 1
			ifa->ifa_ifp->if_xname));
d1209 1
a1209 1
					ifa->ifa_ifp->if_xname);
d1235 1
a1235 1
			    ifa->ifa_ifp->if_xname,
d1263 1
a1263 1
	    "%d NA\n", ifa->ifa_ifp->if_xname,
d1274 1
a1274 1
	    ifa->ifa_ifp->if_xname, ip6_sprintf(&ia->ia_addr.sin6_addr));
d1276 1
a1276 1
	    ifa->ifa_ifp->if_xname);
d1295 1
a1295 1
		printf("%s: interface down?\n", ifp->if_xname);
d1301 1
a1301 1
		printf("%s: interface not running?\n", ifp->if_xname);
d1340 1
a1340 1
		    ifa->ifa_ifp->if_xname));
@


1.8.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d771 3
d780 1
@


1.8.2.5
log
@Merge in trunk
@
text
@d126 1
a126 1
		    /* don't check ifindex portion */
d375 1
a375 1
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */
d425 1
a425 1
		struct ip6_hdr *hip6;		/* hold ip6 */
d442 1
a442 1
				m_freem(m);
d610 1
a610 1
	/* Just for safety, maybe unnecessary. */
d1071 1
a1071 1
	if (tick == NULL) {
d1187 1
a1187 1
#if 0 /* heuristics */
@


1.8.2.6
log
@Merge in -current from roughly a week ago
@
text
@d65 7
a71 7
static struct dadq *nd6_dad_find(struct ifaddr *);
static void nd6_dad_starttimer(struct dadq *, int);
static void nd6_dad_stoptimer(struct dadq *);
static void nd6_dad_timer(struct ifaddr *);
static void nd6_dad_ns_output(struct dadq *, struct ifaddr *);
static void nd6_dad_ns_input(struct ifaddr *);
static void nd6_dad_na_input(struct ifaddr *);
d777 1
a777 1
		ln->ln_hold = NULL;
d985 1
a985 1
	timeout_set(&dp->dad_timer_ch, (void (*)(void *))nd6_dad_timer,
@


1.8.2.7
log
@Sync the SMP branch with 3.3
@
text
@a97 1
	int router = ip6_forwarding;
d125 5
a129 5
		/* don't check ifindex portion */
		if (daddr6.s6_addr16[0] == IPV6_ADDR_INT16_MLL &&
		    daddr6.s6_addr32[1] == 0 &&
		    daddr6.s6_addr32[2] == IPV6_ADDR_INT32_ONE &&
		    daddr6.s6_addr8[12] == 0xff) {
d133 1
a133 1
			    "(wrong ip6 dst)\n"));
d156 1
a156 1
		lladdr = (char *)(ndopts.nd_opts_src_lladdr + 1);
d159 1
a159 1

d201 1
a201 1
		bzero(&tsin6, sizeof tsin6);
a216 1
				router = 0;	/* XXX */
d237 2
a238 1
		nd6log((LOG_INFO, "nd6_ns_input: lladdrlen mismatch for %s "
d240 1
a240 1
		    ip6_sprintf(&taddr6), ifp->if_addrlen, lladdrlen - 2));
d245 2
a246 1
		log(LOG_INFO, "nd6_ns_input: duplicate IP6 address %s\n",
d289 4
a292 3
		    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
		    (router ? ND_NA_FLAG_ROUTER : 0),
		    tlladdr, (struct sockaddr *)proxydl);
d299 4
a302 3
	    ((anycast || proxy || !tlladdr) ? 0 : ND_NA_FLAG_OVERRIDE) |
	    (router ? ND_NA_FLAG_ROUTER : 0) | ND_NA_FLAG_SOLICITED,
	    tlladdr, (struct sockaddr *)proxydl);
d334 1
a334 1
	struct sockaddr_in6 src_sa, dst_sa;
d339 2
a340 4
	struct route_in6 ro;

	bzero(&ro, sizeof(ro));

d347 1
a348 1
	if (max_linkhdr + maxlen >= MCLBYTES) {
d351 2
a352 2
		panic("nd6_ns_output: insufficient MCLBYTES");
		/* NOTREACHED */
a353 1
#endif
a364 1
	m->m_pkthdr.rcvif = NULL;
a384 5
	/* determine the source and destination addresses */
	bzero(&src_sa, sizeof(src_sa));
	bzero(&dst_sa, sizeof(dst_sa));
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
d386 1
a386 1
		dst_sa.sin6_addr = *daddr6;
d388 6
a393 6
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = IPV6_ADDR_INT32_ONE;
		dst_sa.sin6_addr.s6_addr32[3] = taddr6->s6_addr32[3];
		dst_sa.sin6_addr.s6_addr8[12] = 0xff;
a394 1
	ip6->ip6_dst = dst_sa.sin6_addr;
d396 14
d423 1
a423 1
		 * Otherwise, we perform the source address selection as usual.
d438 1
a438 1
			src_sa.sin6_addr = *saddr6;
d440 4
a443 12
			struct in6_addr *src0;
			int error;

			bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
			src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL,
			    &error);
			if (src0 == NULL) {
				nd6log((LOG_DEBUG,
				    "nd6_ns_output: source can't be "
				    "determined: dst=%s, error=%d\n",
				    ip6_sprintf(&dst_sa.sin6_addr), error));
				goto bad;
d445 1
a445 1
			src_sa.sin6_addr = *src0;
d447 1
a451 3
		 * We actually don't have to 0-clear the address (we did it
		 * above), but we do so here explicitly to make the intention
		 * clearer.
d453 1
a453 1
		bzero(&src_sa.sin6_addr, sizeof(src_sa.sin6_addr));
a454 1
	ip6->ip6_src = src_sa.sin6_addr;
d481 1
a481 1

d493 2
a494 2
	nd_ns->nd_ns_cksum =
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(*ip6), icmp6len);
d496 5
a500 3
	ip6_output(m, NULL, &ro, dad ? IPV6_UNSPECSRC : 0, &im6o, NULL);
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighborsolicit);
a501 12

	if (ro.ro_rt) {		/* we don't cache this route. */
		RTFREE(ro.ro_rt);
	}
	return;

  bad:
	if (ro.ro_rt) {
		RTFREE(ro.ro_rt);
	}
	m_freem(m);
	return;
a537 1
	long time_second = time.tv_sec;
d572 6
a577 5
	if (is_solicited && IN6_IS_ADDR_MULTICAST(&daddr6)) {
		nd6log((LOG_ERR,
		    "nd6_na_input: a solicited adv is multicasted\n"));
		goto bad;
	}
d619 4
a622 3
		nd6log((LOG_INFO, "nd6_na_input: lladdrlen mismatch for %s "
		    "(if %d, NA packet %d)\n", ip6_sprintf(&taddr6),
		    ifp->if_addrlen, lladdrlen - 2));
d627 1
a627 2
	 * If no neighbor cache entry is found, NA SHOULD silently be
	 * discarded.
d652 2
a653 2
				ln->ln_expire = time_second +
				    ND_IFINFO(rt->rt_ifp)->reachable;
d656 1
a656 9
			ln->ln_expire = time_second + nd6_gctimer;
		}
		if ((ln->ln_router = is_router) != 0) {
			/*
			 * This means a router's state has changed from
			 * non-reachable to probably reachable, and might
			 * affect the status of associated prefixes..
			 */
			pfxlist_onlink_check();
d658 1
d703 1
a703 1
				ln->ln_expire = time_second + nd6_gctimer;
d726 2
a727 2
					ln->ln_expire = time_second +
					    ND_IFINFO(ifp)->reachable;
d732 1
a732 1
					ln->ln_expire = time_second + nd6_gctimer;
d749 2
a750 7
			/*
			 * Lock to protect the default router list.
			 * XXX: this might be unnecessary, since this function
			 * is only called under the network software interrupt
			 * context.  However, we keep it just for safety.
			 */
			s = splsoftnet();
d772 1
a772 1
		 * we assume ifp is not a loopback here, so just set the 2nd
d809 1
d811 2
a812 3
	struct sockaddr_in6 src_sa, dst_sa;
	struct in6_addr *src0;
	int icmp6len, maxlen, error;
d814 1
a814 4
	struct route_in6 ro;

	mac = NULL;
	bzero(&ro, sizeof(ro));
d819 1
a820 1
	if (max_linkhdr + maxlen >= MCLBYTES) {
d823 2
a824 2
		panic("nd6_na_output: insufficient MCLBYTES");
		/* NOTREACHED */
a825 1
#endif
a836 1
	m->m_pkthdr.rcvif = NULL;
d847 1
a847 1
	m->m_data += max_linkhdr;	/* or MH_ALIGN() equivalent? */
a855 5
	bzero(&src_sa, sizeof(src_sa));
	bzero(&dst_sa, sizeof(dst_sa));
	src_sa.sin6_len = dst_sa.sin6_len = sizeof(struct sockaddr_in6);
	src_sa.sin6_family = dst_sa.sin6_family = AF_INET6;
	dst_sa.sin6_addr = *daddr6;
d858 5
a862 6
		dst_sa.sin6_addr.s6_addr16[0] = IPV6_ADDR_INT16_MLL;
		dst_sa.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		dst_sa.sin6_addr.s6_addr32[1] = 0;
		dst_sa.sin6_addr.s6_addr32[2] = 0;
		dst_sa.sin6_addr.s6_addr32[3] = IPV6_ADDR_INT32_ONE;

d864 2
a865 2
	}
	ip6->ip6_dst = dst_sa.sin6_addr;
d870 4
a873 7
	bcopy(&dst_sa, &ro.ro_dst, sizeof(dst_sa));
	src0 = in6_selectsrc(&dst_sa, NULL, NULL, &ro, NULL, &error);
	if (src0 == NULL) {
		nd6log((LOG_DEBUG, "nd6_na_output: source can't be "
		    "determined: dst=%s, error=%d\n",
		    ip6_sprintf(&dst_sa.sin6_addr), error));
		goto bad;
d875 1
a875 2
	src_sa.sin6_addr = *src0;
	ip6->ip6_src = src_sa.sin6_addr;
d890 1
d908 1
a908 1

d926 1
a926 1
	    in6_cksum(m, IPPROTO_ICMPV6, sizeof(struct ip6_hdr), icmp6len);
d928 5
a932 4
	ip6_output(m, NULL, &ro, 0, &im6o, NULL);

	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_neighboradvert);
a933 12

	if (ro.ro_rt) {		/* we don't cache this route. */
		RTFREE(ro.ro_rt);
	}
	return;

  bad:
	if (ro.ro_rt) {
		RTFREE(ro.ro_rt);
	}
	m_freem(m);
	return;
a943 4
	case IFT_IEEE1394:
	case IFT_PROPVIRTUAL:
	case IFT_L2VLAN:
	case IFT_IEEE80211:
d1067 1
a1067 1
	ifa->ifa_refcnt++;	/* just for safety */
d1073 2
a1074 2
		nd6_dad_starttimer(dp,
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
d1078 1
d1080 1
a1080 1
			ntick = arc4random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d1082 2
a1083 1
			ntick = *tick + arc4random() % (hz / 2);
d1122 1
a1122 1
	s = splsoftnet();		/* XXX */
d1167 2
a1168 2
		nd6_dad_starttimer(dp,
		    ND6_RETRANS_SEC(ND_IFINFO(ifa->ifa_ifp)->retrans) * hz);
d1201 3
a1203 3
				    "network card loops back multicast?\n",
				    ip6_sprintf(&ia->ia_addr.sin6_addr),
				    ifa->ifa_ifp->if_xname);
d1256 4
a1259 4
	log(LOG_ERR, "%s: DAD detected duplicate IPv6 address %s: "
	    "NS in/out=%d/%d, NA in=%d\n",
	    ifa->ifa_ifp->if_xname, ip6_sprintf(&ia->ia_addr.sin6_addr),
	    dp->dad_ns_icount, dp->dad_ns_ocount, dp->dad_na_icount);
d1322 6
@


1.8.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d103 4
d112 1
d563 4
d572 1
@


1.8.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.8.2.8 2003/05/16 00:29:44 niklas Exp $	*/
d991 1
@


1.8.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a61 5
#include "carp.h"
#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

d95 1
a95 1
	struct ifaddr *ifa = NULL;
a189 6
#if NCARP > 0
	if (ifp->if_carp) 
		ifa = carp_iamatch6(ifp->if_carp, &taddr6);
	if (!ifa) 
		ifa = (struct ifaddr *)in6ifa_ifpwithaddr(ifp, &taddr6);
#else
a190 1
#endif
d548 1
d656 3
a658 4
			if (!ND6_LLINFO_PERMANENT(ln)) {
				nd6_llinfo_settimer(ln,
				    (long)ND_IFINFO(rt->rt_ifp)->reachable * hz);
			}
d661 1
a661 1
			nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d715 1
a715 1
				nd6_llinfo_settimer(ln, (long)nd6_gctimer * hz);
d737 3
a739 3
				if (!ND6_LLINFO_PERMANENT(ln)) {
					nd6_llinfo_settimer(ln,
					    (long)ND_IFINFO(ifp)->reachable * hz);
d744 1
a744 2
					nd6_llinfo_settimer(ln,
					    (long)nd6_gctimer * hz);
d771 1
a771 1
			else if (!ip6_forwarding) {
d927 1
a927 8
		if (sdl0 == NULL) {
#if NCARP > 0
			if (ifp->if_carp) 
				mac = carp_macmatch6(ifp->if_carp, m, taddr6);
			if (mac == NULL)
				mac = nd6_ifptomac(ifp);
#else

d929 1
a929 2
#endif
		} else if (sdl0->sa_family == AF_LINK) {
d1119 1
a1119 1
		    (long)ND_IFINFO(ifa->ifa_ifp)->retrans * hz / 1000);
d1211 1
a1211 1
		    (long)ND_IFINFO(ifa->ifa_ifp)->retrans * hz / 1000);
@


1.7
log
@pull in arc4random() prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.6 2000/01/08 04:49:22 deraadt Exp $	*/
d53 1
a53 1
#include <netinet6/ip6.h>
d56 1
a56 1
#include <netinet6/icmp6.h>
d316 1
d323 20
a342 1
	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d354 1
a354 1
	MH_ALIGN(m, m->m_len + 16); /* 1+1+6 is enought. but just in case */
d750 1
d753 21
a773 2
	
	if ((m = m_gethdr(M_DONTWAIT, MT_DATA)) == NULL)
d785 1
a785 1
	MH_ALIGN(m, m->m_len + 16); /* 1+1+6 is enough. but just in case */
d923 2
a924 1
		printf("nd6_dad_start: called with non-tentative address "
d949 1
a949 1
		printf("nd6_dad_start: memory allocation failed for "
d959 1
a959 2
	/* XXXJRT This is probably a purely debugging message. */
	printf("%s: starting DAD for %s\n", if_name(ifa->ifa_ifp),
d1003 1
a1003 1
		printf("nd6_dad_timer: called with null parameter\n");
d1008 1
a1008 1
		printf("nd6_dad_timer: DAD structure not found\n");
d1012 1
a1012 1
		printf("nd6_dad_timer: called with duplicated address "
d1019 1
a1019 1
		printf("nd6_dad_timer: called with non-tentative address "
d1028 1
a1028 1
		printf("%s: could not run DAD, driver problem?\n",
d1034 1
a1034 1
		ifa->ifa_refcnt--;
d1105 1
a1105 2
			/* XXXJRT This is probably a purely debugging message */
			printf("%s: DAD complete for %s - no duplicates "
d1113 1
a1113 1
			ifa->ifa_refcnt--;
d1130 1
a1130 1
		printf("nd6_dad_duplicated: DAD structure not found\n");
d1145 1
a1145 1
	printf("%s: DAD complete for %s - duplicate found\n",
d1147 2
a1148 1
	printf("%s: manual intervention required\n", if_name(ifa->ifa_ifp));
d1153 1
a1153 1
	ifa->ifa_refcnt--;
@


1.6
log
@use arc4random() instead of random for two reasons.
1) on some architectures, random() should only be used by the scheduler
   (ie. statintr() because it is uniformly distributed
2) arc4random() is actually strong, random() is not at all
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.5 1999/12/15 07:08:00 itojun Exp $	*/
d59 2
@


1.5
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.4 1999/12/10 10:04:28 angelos Exp $	*/
d940 1
a940 1
			ntick = random() % (MAX_RTR_SOLICITATION_DELAY * hz);
d942 1
a942 1
			ntick = *tick + random() % (hz / 2);
@


1.4
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.3 1999/12/08 19:53:39 deraadt Exp $	*/
d337 2
a338 1
	ip6->ip6_vfc = IPV6_VERSION;
d748 2
a749 1
	ip6->ip6_vfc = IPV6_VERSION;
@


1.3
log
@silence more DAD debugging information
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.2 1999/12/08 12:13:37 deraadt Exp $	*/
a31 7
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a40 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a41 1
#endif 
d191 1
a191 5
		rt = rtalloc1((struct sockaddr *)&tsin6, 0
#ifdef __FreeBSD__
			      , 0
#endif /* __FreeBSD__ */
			      );
a451 5
#ifdef IPSEC
#ifndef __OpenBSD__ /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif
#endif /*IPSEC*/
a582 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a583 3
#else
				ln->ln_expire = time_second +
#endif
a651 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a652 3
#else
					ln->ln_expire = time_second +
#endif
d672 1
a672 3
#ifdef __NetBSD__
			s = splsoftnet();
#else
d674 1
a674 1
#endif
a805 5
#ifdef IPSEC
#ifndef __OpenBSD__ /*KAME IPSEC*/
	m->m_pkthdr.rcvif = NULL;
#endif
#endif /*IPSEC*/
a821 3
#ifdef __NetBSD__
		return LLADDR(ifp->if_sadl);
#else
a822 1
#endif
a837 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	struct callout_handle dad_timer;
#endif
a931 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		dp->dad_timer =
#endif
a941 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		dp->dad_timer =
#endif
a954 3
#ifdef __NetBSD__
	s = splsoftnet();	/*XXX*/
#else
a955 1
#endif
a999 3
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		dp->dad_timer =
#endif
d1100 1
a1100 5
	untimeout((void (*) __P((void *)))nd6_dad_timer, (void *)ifa
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		, dp->dad_timer
#endif
		);
@


1.2
log
@silence non-duplicate DAD completion messages
@
text
@d1 1
a1 1
/*	$OpenBSD: nd6_nbr.c,v 1.1 1999/12/08 06:50:23 itojun Exp $	*/
d953 1
d957 1
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1111 1
d1116 1
@

