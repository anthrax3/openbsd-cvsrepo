head	1.53;
access;
symbols
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.50.0.2
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.17.0.6
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.4
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.2
	OPENBSD_5_0:1.16.0.12
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.10
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.8
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.4
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.14.0.4
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.13.0.2
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.12.0.10
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.8
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.6
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.4
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.53
date	2016.12.19.15.47.19;	author mpi;	state Exp;
branches;
next	1.52;
commitid	xfCbE6Pg35TUdksM;

1.52
date	2016.11.18.02.53.47;	author dlg;	state Exp;
branches;
next	1.51;
commitid	VkivwyRVzetroSYM;

1.51
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.50;
commitid	nbCHuHn2E9uBfKJT;

1.50
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.49;
commitid	Cm0qxR09oTCkXjXZ;

1.49
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.48;
commitid	jodmGXAB42f8N6nf;

1.48
date	2016.05.19.08.02.22;	author vgross;	state Exp;
branches;
next	1.47;
commitid	b4TfdKExdy3OBYmG;

1.47
date	2016.03.31.11.59.28;	author vgross;	state Exp;
branches;
next	1.46;
commitid	QfQMS2WXKyVpMQQq;

1.46
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.45;
commitid	iMWKOVeEybjVAEfv;

1.45
date	2016.03.21.21.21.35;	author vgross;	state Exp;
branches;
next	1.44;
commitid	kJec2D6LBVBbvezW;

1.44
date	2016.03.20.01.26.30;	author jca;	state Exp;
branches;
next	1.43;
commitid	GLsXKfQ2x1mJBQlZ;

1.43
date	2016.03.19.23.59.49;	author vgross;	state Exp;
branches;
next	1.42;
commitid	RAixKEXoKbQFRWrg;

1.42
date	2016.03.12.09.25.38;	author vgross;	state Exp;
branches;
next	1.41;
commitid	xZkfuhhTAfgA3ISo;

1.41
date	2015.12.02.22.13.44;	author vgross;	state Exp;
branches
	1.41.2.1;
next	1.40;
commitid	Qc8hTbFRvzRyD1WZ;

1.40
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.39;
commitid	djjKhPvMtRdFfuFJ;

1.39
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.38;
commitid	xFxvBxiFybIsZNMc;

1.38
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.37;
commitid	aMzCQ7pRC6VLKZyx;

1.37
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.36;
commitid	Cr0DVA7exR1t2zXg;

1.36
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.35;
commitid	sTEWfQrcV5GjIWc0;

1.35
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches
	1.35.4.1;
next	1.34;
commitid	4Ro7ulidQXNcMvmM;

1.34
date	2015.05.13.10.42.47;	author jsg;	state Exp;
branches;
next	1.33;
commitid	hN5bFCE56DrAjl99;

1.33
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches
	1.33.2.1;
next	1.32;
commitid	t9FBKDfc4VDxpEy2;

1.32
date	2014.11.09.22.05.08;	author bluhm;	state Exp;
branches;
next	1.31;
commitid	SqTYB83QZLRauhYQ;

1.31
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.30;
commitid	DQakU8LLWV6Iwx84;

1.30
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.29;
commitid	2Ufy37wyO5neufOK;

1.29
date	2014.04.18.18.56.25;	author jca;	state Exp;
branches;
next	1.28;

1.28
date	2014.04.18.18.44.18;	author jca;	state Exp;
branches;
next	1.27;

1.27
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.16.13.04.38;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2014.04.09.08.44.08;	author chrisz;	state Exp;
branches;
next	1.23;

1.23
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.10.22.15.08.55;	author naddy;	state Exp;
branches;
next	1.21;

1.21
date	2013.10.21.12.37.42;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2013.10.17.16.27.47;	author bluhm;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.01.00.52.39;	author henning;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.12.04.58.48;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.11.14.27.13;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.11.08.09.29;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.02.23.28.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.04.07.26.53;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.29.23.38.58;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2001.12.06.04.19.26;	author itojun;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.06.09.06.43.38;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.16.08.19.32;	author itojun;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.08.18.46.23;	author itojun;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.18.17.32.48;	author itojun;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.40.21;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.07.04.10.55.28;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.28.00.41.30;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.06.13.08.50.18;	author niklas;	state Exp;
branches;
next	;

1.5.2.1
date	2002.06.11.03.31.38;	author art;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;

1.33.2.1
date	2016.03.16.09.26.13;	author vgross;	state Exp;
branches;
next	;
commitid	QzqLM83mhlnOhiMu;

1.35.4.1
date	2016.03.16.10.03.05;	author vgross;	state Exp;
branches;
next	;
commitid	k5C4GbDmZW2gkGJW;

1.41.2.1
date	2016.03.24.05.02.53;	author jsg;	state Exp;
branches;
next	;
commitid	2YBobhUsn73qIAzL;


desc
@@


1.53
log
@Remove redundant splsoftnet().

ok bluhm@@
@
text
@/*	$OpenBSD: udp6_output.c,v 1.52 2016/11/18 02:53:47 dlg Exp $	*/
/*	$KAME: udp6_output.c,v 1.21 2001/02/07 11:51:54 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1989, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "pf.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/stat.h>
#include <sys/systm.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/udp.h>
#include <netinet/udp_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/ip6protosw.h>

/*
 * UDP protocol inplementation.
 * Per RFC 768, August, 1980.
 */
int
udp6_output(struct inpcb *in6p, struct mbuf *m, struct mbuf *addr6,
	struct mbuf *control)
{
	u_int32_t ulen = m->m_pkthdr.len;
	u_int32_t plen = sizeof(struct udphdr) + ulen;
	int error = 0, priv = 0, hlen, flags;
	struct ip6_hdr *ip6;
	struct udphdr *udp6;
	struct in6_addr *laddr, *faddr;
	struct ip6_pktopts *optp, opt;
	struct sockaddr_in6 tmp, valid;
	struct proc *p = curproc;	/* XXX */
	u_short fport;

	if ((in6p->inp_socket->so_state & SS_PRIV) != 0)
		priv = 1;
	if (control) {
		if ((error = ip6_setpktopts(control, &opt,
		    in6p->inp_outputopts6, priv, IPPROTO_UDP)) != 0)
			goto release;
		optp = &opt;
	} else
		optp = in6p->inp_outputopts6;

	if (addr6) {
		struct sockaddr_in6 *sin6 = mtod(addr6, struct sockaddr_in6 *);

		if (addr6->m_len != sizeof(*sin6)) {
			error = EINVAL;
			goto release;
		}
		if (sin6->sin6_family != AF_INET6) {
			error = EAFNOSUPPORT;
			goto release;
		}
		if (sin6->sin6_port == 0) {
			error = EADDRNOTAVAIL;
			goto release;
		}
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
			error = EINVAL;
			goto release;
		}

		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_faddr6)) {
			error = EISCONN;
			goto release;
		}

		/* protect *sin6 from overwrites */
		tmp = *sin6;
		sin6 = &tmp;

		faddr = &sin6->sin6_addr;
		fport = sin6->sin6_port; /* allow 0 port */

		/* KAME hack: embed scopeid */
		if (in6_embedscope(&sin6->sin6_addr, sin6, in6p) != 0) {
			error = EINVAL;
			goto release;
		}

		error = in6_pcbselsrc(&laddr, sin6, in6p, optp);
		if (error)
			goto release;

		if (in6p->inp_lport == 0){
			error = in_pcbbind(in6p, NULL, p);
			if (error)
				goto release;
		}

		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_laddr6) &&
		    !IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr)) {
			valid.sin6_addr = *laddr;
			valid.sin6_port = in6p->inp_lport;
			valid.sin6_scope_id = 0;
			valid.sin6_family = AF_INET6;
			valid.sin6_len = sizeof(valid);
			error = in6_pcbaddrisavail(in6p, &valid, 0, p);
			if (error)
				goto release;
		}
	} else {
		if (IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_faddr6)) {
			error = ENOTCONN;
			goto release;
		}
		laddr = &in6p->inp_laddr6;
		faddr = &in6p->inp_faddr6;
		fport = in6p->inp_fport;
	}

	hlen = sizeof(struct ip6_hdr);

	/*
	 * Calculate data length and get a mbuf
	 * for UDP and IP6 headers.
	 */
	M_PREPEND(m, hlen + sizeof(struct udphdr), M_DONTWAIT);
	if (m == NULL) {
		error = ENOBUFS;
		goto releaseopt;
	}

	/*
	 * Stuff checksum and output datagram.
	 */
	udp6 = (struct udphdr *)(mtod(m, caddr_t) + hlen);
	udp6->uh_sport = in6p->inp_lport; /* lport is always set in the PCB */
	udp6->uh_dport = fport;
	if (plen <= 0xffff)
		udp6->uh_ulen = htons((u_short)plen);
	else
		udp6->uh_ulen = 0;
	udp6->uh_sum = 0;

	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow	= in6p->inp_flowinfo & IPV6_FLOWINFO_MASK;
	ip6->ip6_vfc	&= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc	|= IPV6_VERSION;
#if 0	/* ip6_plen will be filled in ip6_output. */
	ip6->ip6_plen	= htons((u_short)plen);
#endif
	ip6->ip6_nxt	= IPPROTO_UDP;
	ip6->ip6_hlim	= in6_selecthlim(in6p);
	ip6->ip6_src	= *laddr;
	ip6->ip6_dst	= *faddr;

	m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;

	flags = 0;
	if (in6p->inp_flags & IN6P_MINMTU)
		flags |= IPV6_MINMTU;

	udpstat_inc(udps_opackets);

	/* force routing table */
	m->m_pkthdr.ph_rtableid = in6p->inp_rtableid;

#if NPF > 0
	if (in6p->inp_socket->so_state & SS_ISCONNECTED)
		m->m_pkthdr.pf.inp = in6p;
#endif

	error = ip6_output(m, optp, &in6p->inp_route6,
	    flags, in6p->inp_moptions6, in6p);
	goto releaseopt;

release:
	m_freem(m);

releaseopt:
	if (control) {
		ip6_clearpktopts(&opt, -1);
		m_freem(control);
	}
	return (error);
}
@


1.52
log
@turn ipstat into a set of percpu counters.

each counter is identified by an enum value which correspond to the
original members of the udpstat struct.

udpstat_inc(udps_foo) replaces udpstat.udps_foo++ for the actual
updates. udpstat_inc is a thin wrapper around counters_inc.

counters are still returned to userland via the udpstat struct for
now.

ok mpi@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.51 2016/08/04 20:46:24 vgross Exp $	*/
a161 1
			int s = splsoftnet();
a162 1
			splx(s);
@


1.51
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.50 2016/07/22 11:14:41 mpi Exp $	*/
d232 1
a232 1
	udpstat.udps_opackets++;
@


1.50
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.48 2016/05/19 08:02:22 vgross Exp $	*/
d157 1
a157 3
		error = in6_selectsrc(&laddr, sin6, optp,
		    in6p->inp_moptions6, &in6p->inp_route6,
		    &in6p->inp_laddr6, in6p->inp_rtableid);
@


1.49
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d157 3
a159 1
		error = in6_pcbselsrc(&laddr, sin6, in6p, optp);
@


1.48
log
@Do not check if source address is available when the UDP6 socket is bound
to [::]. We should be able to send from a socket bound to [::] while using
sockets bound to specified addresses for reception.

Spotted with regress/usr.sbin/syslogd/args-client-bind-only6.pl test case.

"makes sense to me" millert@@, ok benno@@, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.47 2016/03/31 11:59:28 vgross Exp $	*/
d157 1
a157 3
		error = in6_selectsrc(&laddr, sin6, optp,
		    in6p->inp_moptions6, &in6p->inp_route6,
		    &in6p->inp_laddr6, in6p->inp_rtableid);
@


1.47
log
@Don't forget to initialize scope_id. This fixes semarie@@ and sthen@@'s
regressions with dhcpcd.

Ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.46 2016/03/23 15:50:36 vgross Exp $	*/
d171 2
a172 1
		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr)) {
@


1.46
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.45 2016/03/21 21:21:35 vgross Exp $	*/
d174 1
@


1.45
log
@Extract in6_pcbaddrisavail() from in6_pcbbind(), and use it when
checking for source availability in udp6_output(); This time with
all the files.

Ok jca@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.44 2016/03/20 01:26:30 jca Exp $	*/
d165 1
a165 1
			error = in6_pcbbind(in6p, NULL, p);
@


1.44
log
@Revert, missing decl for in6_pcbaddrisavail() breaks kernel build.

Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.42 2016/03/12 09:25:38 vgross Exp $	*/
d105 1
a105 1
	struct sockaddr_in6 tmp;
d171 7
a177 13
		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr) &&
		    (in6p->inp_socket->so_euid != 0)) {
			struct inpcb *t;

			t = in_pcblookup(in6p->inp_table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)laddr, in6p->inp_lport,
			    (INPLOOKUP_WILDCARD | INPLOOKUP_IPV6),
			    in6p->inp_rtableid);
			if (t &&
			    (t->inp_socket->so_euid !=
			    in6p->inp_socket->so_euid)) {
				error = EADDRINUSE;
a178 1
			}
@


1.43
log
@Extract in6_pcbaddrisavail() from in6_pcbbind(), and use it when
checking for source availability in udp6_output().

Ok jca@@ bluhm@@
@
text
@d105 1
a105 1
	struct sockaddr_in6 tmp, valid;
d171 13
a183 7
		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr)) {
			valid.sin6_addr = *laddr;
			valid.sin6_port = in6p->inp_lport;
			valid.sin6_family = AF_INET6;
			valid.sin6_len = sizeof(valid);
			error = in6_pcbaddrisavail(in6p, &valid, 0, p);
			if (error)
d185 1
@


1.42
log
@Add checks on overlapping IPv6 sockets ownership

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.41 2015/12/02 22:13:44 vgross Exp $	*/
d105 1
a105 1
	struct sockaddr_in6 tmp;
d171 7
a177 13
		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr) &&
		    (in6p->inp_socket->so_euid != 0)) {
			struct inpcb *t;

			t = in_pcblookup(in6p->inp_table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)laddr, in6p->inp_lport,
			    (INPLOOKUP_WILDCARD | INPLOOKUP_IPV6),
			    in6p->inp_rtableid);
			if (t &&
			    (t->inp_socket->so_euid !=
			    in6p->inp_socket->so_euid)) {
				error = EADDRINUSE;
a178 1
			}
@


1.41
log
@Move port picking away from in_pcbbind()

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.40 2015/11/24 13:37:16 mpi Exp $	*/
d169 17
@


1.41.2.1
log
@OpenBSD 5.9 errata 2, Mar 16, 2016:

Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.41 2015/12/02 22:13:44 vgross Exp $	*/
a168 17
		}

		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr) &&
		    (in6p->inp_socket->so_euid != 0)) {
			struct inpcb *t;

			t = in_pcblookup(in6p->inp_table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)laddr, in6p->inp_lport,
			    (INPLOOKUP_WILDCARD | INPLOOKUP_IPV6),
			    in6p->inp_rtableid);
			if (t &&
			    (t->inp_socket->so_euid !=
			    in6p->inp_socket->so_euid)) {
				error = EADDRINUSE;
				goto release;
			}
@


1.40
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.39 2015/10/24 16:08:48 mpi Exp $	*/
d163 7
a169 3
		if (in6p->inp_lport == 0 &&
		    (error = in6_pcbsetport(laddr, in6p, p)) != 0)
			goto release;
@


1.39
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.38 2015/10/19 12:11:28 mpi Exp $	*/
a76 1
#include <net/if_types.h>
@


1.38
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.37 2015/09/11 08:17:06 claudio Exp $	*/
a107 1
	struct ifnet *ifp;
d209 1
a209 4
	ifp = NULL;
	if (rtisvalid(in6p->inp_route6.ro_rt))
		ifp = in6p->inp_route6.ro_rt->rt_ifp;
	ip6->ip6_hlim	= in6_selecthlim(in6p, ifp);
@


1.37
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.36 2015/09/11 07:42:35 claudio Exp $	*/
d211 1
a211 2
	if (in6p->inp_route6.ro_rt &&
	    in6p->inp_route6.ro_rt->rt_flags & RTF_UP)
@


1.36
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.35 2015/06/08 22:19:28 krw Exp $	*/
d235 1
a235 1
	    flags, in6p->inp_moptions6, NULL, in6p);
@


1.35
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.34 2015/05/13 10:42:47 jsg Exp $	*/
d154 1
a154 1
		if (in6_embedscope(&sin6->sin6_addr, sin6, in6p, NULL) != 0) {
@


1.35.4.1
log
@Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.

See Errata 012
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.35 2015/06/08 22:19:28 krw Exp $	*/
a167 17

		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr) &&
		    (in6p->inp_socket->so_euid != 0)) {
			struct inpcb *t;

			t = in_pcblookup(in6p->inp_table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)laddr, in6p->inp_lport,
			    (INPLOOKUP_WILDCARD | INPLOOKUP_IPV6),
			    in6p->inp_rtableid);
			if (t &&
			    (t->inp_socket->so_euid !=
			    in6p->inp_socket->so_euid)) {
				error = EADDRINUSE;
				goto release;
			}
		}
@


1.34
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.33 2014/12/05 15:50:04 mpi Exp $	*/
d96 1
a96 1
udp6_output(struct inpcb *in6p, struct mbuf *m, struct mbuf *addr6, 
d204 2
a205 2
	ip6->ip6_vfc 	&= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc 	|= IPV6_VERSION;
@


1.33
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.32 2014/11/09 22:05:08 bluhm Exp $	*/
d185 1
a185 1
	if (m == 0) {
@


1.33.2.1
log
@Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.

See Errata 024
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.33 2014/12/05 15:50:04 mpi Exp $	*/
a167 17

		if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, laddr) &&
		    (in6p->inp_socket->so_euid != 0)) {
			struct inpcb *t;

			t = in_pcblookup(in6p->inp_table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)laddr, in6p->inp_lport,
			    (INPLOOKUP_WILDCARD | INPLOOKUP_IPV6),
			    in6p->inp_rtableid);
			if (t &&
			    (t->inp_socket->so_euid !=
			    in6p->inp_socket->so_euid)) {
				error = EADDRINUSE;
				goto release;
			}
		}
@


1.32
log
@To implement transparent relays for connectionless protocols, the
pf the state has to vanish immediately when the relay closes the
socket.  To make this work reliably, the linkage between state and
socket must be established with the first packet.  This packet could
be incomming or outgoing.
Link the pf state in the socket layer earlier.  This makes all tests
in /usr/src/regress/sys/net/pf_divert pass.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.31 2014/07/22 11:06:10 mpi Exp $	*/
d75 1
@


1.31
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.30 2014/06/03 13:32:24 mpi Exp $	*/
d62 2
d227 5
@


1.30
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.29 2014/04/18 18:56:25 jca Exp $	*/
a77 1
#include <netinet/in_systm.h>
@


1.29
log
@Remove the dead KAME code that dealt with IPv4-mapped IPv6 addresses.
Add a check for IPv4-mapped IPv6 destination addresses, like in the most
recent KAME code, for non-connected sockets.  This prevents packets from
reaching the wire through the default route, if a reject route
for ::ffff:0.0.0.0/96 isn't present.  ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.27 2014/04/18 10:48:30 jca Exp $	*/
a62 1
#include <sys/malloc.h>
@


1.28
log
@This remnant comment doesn't belong here.  ok claudio@@
@
text
@d100 1
a100 1
	int error = 0, priv = 0, af, hlen, flags;
d135 4
d177 1
a177 7
	if (1) {	/* we don't support IPv4 mapped address */
		af = AF_INET6;
		hlen = sizeof(struct ip6_hdr);
	} else {
		af = AF_INET;
		hlen = sizeof(struct ip);
	}
d201 6
a206 8
	switch (af) {
	case AF_INET6:
		ip6 = mtod(m, struct ip6_hdr *);
		ip6->ip6_flow	= in6p->inp_flowinfo & IPV6_FLOWINFO_MASK;
		ip6->ip6_vfc 	&= ~IPV6_VERSION_MASK;
		ip6->ip6_vfc 	|= IPV6_VERSION;
#if 0				/* ip6_plen will be filled in ip6_output. */
		ip6->ip6_plen	= htons((u_short)plen);
d208 22
a229 27
		ip6->ip6_nxt	= IPPROTO_UDP;
		ifp = NULL;
		if (in6p->inp_route6.ro_rt &&
		    in6p->inp_route6.ro_rt->rt_flags & RTF_UP)
			ifp = in6p->inp_route6.ro_rt->rt_ifp;
		ip6->ip6_hlim	= in6_selecthlim(in6p, ifp);
		ip6->ip6_src	= *laddr;
		ip6->ip6_dst	= *faddr;

		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;

		flags = 0;
		if (in6p->inp_flags & IN6P_MINMTU)
			flags |= IPV6_MINMTU;

		udpstat.udps_opackets++;

		/* force routing table */
		m->m_pkthdr.ph_rtableid = in6p->inp_rtableid;

		error = ip6_output(m, optp, &in6p->inp_route6,
		    flags, in6p->inp_moptions6, NULL, in6p);
		break;
	case AF_INET:
		error = EAFNOSUPPORT;
		goto release;
	}
@


1.27
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.26 2014/04/16 13:04:38 mpi Exp $	*/
a153 1
		/* we don't support IPv4 mapped address */
@


1.26
log
@Merge in_fixaddr() into in_selectsrc() in order to prepare for
IP_SENDSRCADDR support.  This reduces the differences with the
IPv6 version and kill some comments that are no longer true.

ok jca@@, chrisz@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.25 2014/04/14 09:06:42 mpi Exp $	*/
d155 1
a155 1
		laddr = in6_selectsrc(sin6, optp,
d157 2
a158 4
		    &in6p->inp_laddr6, &error, in6p->inp_rtableid);
		if (laddr == NULL) {
			if (error == 0)
				error = EADDRNOTAVAIL;
d160 1
a160 1
		}
@


1.25
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.24 2014/04/09 08:44:08 chrisz Exp $	*/
a120 8
		/*
		 * IPv4 version of udp_output calls in_pcbconnect in this case,
		 * which needs splnet and affects performance.
		 * Since we saw no essential reason for calling in_pcbconnect,
		 * we get rid of such kind of logic, and call in6_selectsrc
		 * and in6_pcbsetport in order to fill in the local address
		 * and the local port.
		 */
d154 4
a157 6
		if (1) {	/* we don't support IPv4 mapped address */
			laddr = in6_selectsrc(sin6, optp,
			    in6p->inp_moptions6, &in6p->inp_route6,
			    &in6p->inp_laddr6, &error, in6p->inp_rtableid);
		} else
			laddr = &in6p->inp_laddr6;	/*XXX*/
@


1.24
log
@Fix m_freem(NULL) in error case.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.23 2013/10/23 19:57:50 deraadt Exp $	*/
d242 2
a243 2
		/* force routing domain */
		m->m_pkthdr.rdomain = in6p->inp_rtableid;
@


1.23
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.22 2013/10/22 15:08:55 naddy Exp $	*/
d201 1
a201 1
		goto release;
@


1.22
log
@Compute the checksum in in_proto_cksum_out, just set the flag in
the UDP stack.  ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.21 2013/10/21 12:37:42 deraadt Exp $	*/
a93 15

#define in6pcb		inpcb
#define in6p_outputopts	inp_outputopts6
#define in6p_socket	inp_socket
#define in6p_faddr	inp_faddr6
#define in6p_laddr	inp_laddr6
#define in6p_fport	inp_fport
#define in6p_lport	inp_lport
#define in6p_flags	inp_flags
#define in6p_moptions	inp_moptions6
#define in6p_route	inp_route6
#define in6p_flowinfo	inp_flowinfo
#define udp6stat	udpstat
#define udp6s_opackets	udps_opackets

d95 1
a95 1
udp6_output(struct in6pcb *in6p, struct mbuf *m, struct mbuf *addr6, 
d110 1
a110 1
	if ((in6p->in6p_socket->so_state & SS_PRIV) != 0)
d114 1
a114 1
		    in6p->in6p_outputopts, priv, IPPROTO_UDP)) != 0)
d118 1
a118 1
		optp = in6p->in6p_outputopts;
d144 1
a144 1
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr)) {
d164 2
a165 2
			    in6p->in6p_moptions, &in6p->in6p_route,
			    &in6p->in6p_laddr, &error, in6p->inp_rtableid);
d167 1
a167 1
			laddr = &in6p->in6p_laddr;	/*XXX*/
d173 1
a173 1
		if (in6p->in6p_lport == 0 &&
d177 1
a177 1
		if (IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr)) {
d181 3
a183 3
		laddr = &in6p->in6p_laddr;
		faddr = &in6p->in6p_faddr;
		fport = in6p->in6p_fport;
d208 1
a208 1
	udp6->uh_sport = in6p->in6p_lport; /* lport is always set in the PCB */
d219 1
a219 1
		ip6->ip6_flow	= in6p->in6p_flowinfo & IPV6_FLOWINFO_MASK;
d227 3
a229 3
		if (in6p->in6p_route.ro_rt &&
		    in6p->in6p_route.ro_rt->rt_flags & RTF_UP)
			ifp = in6p->in6p_route.ro_rt->rt_ifp;
d237 1
a237 1
		if (in6p->in6p_flags & IN6P_MINMTU)
d240 1
a240 1
		udp6stat.udp6s_opackets++;
d245 2
a246 2
		error = ip6_output(m, optp, &in6p->in6p_route,
		    flags, in6p->in6p_moptions, NULL, in6p);
@


1.21
log
@Janitoring.  No significant binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.20 2013/10/17 16:27:47 bluhm Exp $	*/
d249 1
a249 4
		if ((udp6->uh_sum = in6_cksum(m, IPPROTO_UDP,
		    sizeof(struct ip6_hdr), plen)) == 0) {
			udp6->uh_sum = 0xffff;
		}
@


1.20
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.19 2013/03/28 16:45:16 tedu Exp $	*/
a59 2
 *
 *	@@(#)udp_var.h	8.1 (Berkeley) 6/10/93
d115 1
d118 1
a118 3
	struct	in6_addr *laddr, *faddr;
	u_short fport;
	int error = 0;
a119 3
	int priv;
	int af, hlen;
	int flags;
d123 1
a124 1
	priv = 0;
d177 1
a177 2
		if (1)	/* we don't support IPv4 mapped address */
		{
d179 2
a180 4
					      in6p->in6p_moptions,
					      &in6p->in6p_route,
					      &in6p->in6p_laddr, &error,
					      in6p->inp_rtableid);
d201 1
a201 2
	if (1)	/* we don't support IPv4 mapped address */
	{
d250 1
a250 1
				sizeof(struct ip6_hdr), plen)) == 0) {
d264 1
a264 1
			    flags, in6p->in6p_moptions, NULL, in6p);
@


1.19
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.18 2013/03/14 11:18:37 mpi Exp $	*/
d80 1
a80 1
#include <netinet/in_var.h>
@


1.18
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.17 2011/11/24 17:39:55 sperreault Exp $	*/
a72 1
#include <sys/proc.h>
@


1.17
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.16 2008/11/23 13:30:59 claudio Exp $	*/
a91 2

#include "faith.h"
@


1.16
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.15 2008/06/11 19:00:50 mcbride Exp $	*/
d191 2
a192 1
					      &in6p->in6p_laddr, &error);
d272 4
@


1.15
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.14 2007/06/01 00:52:39 henning Exp $	*/
d131 1
d253 5
a257 3
		ip6->ip6_hlim	= in6_selecthlim(in6p,
						 in6p->in6p_route.ro_rt ?
						 in6p->in6p_route.ro_rt->rt_ifp : NULL);
@


1.14
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.13 2006/12/09 01:12:28 itojun Exp $	*/
d115 2
a116 4
udp6_output(in6p, m, addr6, control)
	struct in6pcb *in6p;
	struct mbuf *m;
	struct mbuf *addr6, *control;
@


1.13
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.12 2004/06/12 04:58:48 itojun Exp $	*/
d271 1
a271 1
			    flags, in6p->in6p_moptions, NULL);
@


1.12
log
@support IPV6_USE_MIN_MTU, to make BIND9 better.
(sorry about the mess yesterday)
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.11 2004/06/11 14:27:13 deraadt Exp $	*/
d127 1
a127 1
	struct ip6_pktopts opt, *stickyopt;
a136 1
	stickyopt = in6p->in6p_outputopts;
d138 2
a139 1
		if ((error = ip6_setpktoptions(control, &opt, priv)) != 0)
d141 3
a143 2
		in6p->in6p_outputopts = &opt;
	}
d189 1
a189 1
			laddr = in6_selectsrc(sin6, in6p->in6p_outputopts,
d270 1
a270 1
		error = ip6_output(m, in6p->in6p_outputopts, &in6p->in6p_route,
d284 1
a284 1
		in6p->in6p_outputopts = stickyopt;
@


1.11
log
@back out tree breakage.  Like, come on
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.9 2003/06/02 23:28:16 millert Exp $	*/
a264 1
#ifdef IN6P_MINMTU
a266 1
#endif
@


1.10
log
@support IPV6_USE_MIN_MTU, which is needed to run BIND9 well.  from kame
markus ok
@
text
@d265 1
d268 1
@


1.9
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.8 2002/09/11 03:15:36 itojun Exp $	*/
a264 1
#ifdef IN6P_MINMTU
a266 1
#endif
@


1.8
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.7 2002/09/04 07:26:53 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.7
log
@pass struct proc * down to in6_pcbsetport
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.6 2002/05/29 23:38:58 itojun Exp $	*/
d292 1
a292 1
	return(error);
@


1.6
log
@force fragment to minimum link MTU (1280) when needed (when PMTUD does
not take effect) - like icmp6 responses or foo-over-IPv6 tunnel.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.5 2001/12/06 04:19:26 itojun Exp $	*/
d77 1
d136 1
d204 1
a204 1
		    (error = in6_pcbsetport(laddr, in6p)) != 0)
@


1.5
log
@remove kame IPSEC code within #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.4 2001/06/09 06:43:38 angelos Exp $	*/
d267 1
a267 1
#ifdef IPV6_MINMTU
@


1.5.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.5 2001/12/06 04:19:26 itojun Exp $	*/
d267 1
a267 1
#ifdef IN6P_MINMTU
@


1.5.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.5.2.1 2002/06/11 03:31:38 art Exp $	*/
a76 1
#include <sys/proc.h>
a134 1
	struct proc *p = curproc;	/* XXX */
d202 1
a202 1
		    (error = in6_pcbsetport(laddr, in6p, p)) != 0)
d290 1
a290 1
	return (error);
@


1.4
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.3 2001/02/16 08:19:32 itojun Exp $	*/
a95 2
#undef IPSEC

a272 3
#ifdef IPSEC
		ipsec_setsocket(m, in6p->in6p_socket);
#endif /*IPSEC*/
@


1.3
log
@sync better with kame.  remove register decls.  $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a98 2

#include <net/net_osdep.h>
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.3 2001/02/16 08:19:32 itojun Exp $	*/
@


1.3.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.3.4.1 2001/05/14 22:40:21 niklas Exp $	*/
d99 2
@


1.3.4.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 2
d275 3
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@a76 1
#include <sys/proc.h>
a134 1
	struct proc *p = curproc;	/* XXX */
d202 1
a202 1
		    (error = in6_pcbsetport(laddr, in6p, p)) != 0)
d267 1
a267 1
#ifdef IN6P_MINMTU
d290 1
a290 1
	return (error);
@


1.3.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: udp6_output.c,v 1.3.4.4 2003/03/28 00:41:30 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.4.6
log
@sync to HEAD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d265 1
d268 1
@


1.2
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 2
a2 1
/*	$KAME: udp6_output.c,v 1.14 2000/06/13 10:31:23 itojun Exp $	*/
d123 2
a124 2
	register struct in6pcb *in6p;
	register struct mbuf *m;
d127 1
a127 1
	register u_int32_t ulen = m->m_pkthdr.len;
d192 2
a193 1
		if (1) {	/* we don't support IPv4 mapped address */
d218 2
a219 1
	if (1) {	/* we don't support IPv4 mapped address */
@


1.1
log
@sync with KAME udp6_output().  udp output logic is very different between
IPv4/v6 so the separation should make more sense.

TODO: remove IPv6 case from udp_output()
TODO: remove/comment out/#if 0 IPv4 mapped address cases
@
text
@d116 1
a116 1
#define in6p_flowinfo	inp_fflowinfo
@

