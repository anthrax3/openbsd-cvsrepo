head	1.81;
access;
symbols
	OPENBSD_6_0:1.78.0.2
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.72.0.2
	OPENBSD_5_9_BASE:1.72
	OPENBSD_5_8:1.51.0.4
	OPENBSD_5_8_BASE:1.51
	OPENBSD_5_7:1.50.0.2
	OPENBSD_5_7_BASE:1.50
	OPENBSD_5_6:1.45.0.4
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.32.0.2
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.27.0.6
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.4
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.26.0.2
	OPENBSD_5_0_BASE:1.26
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.8
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.8
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.6
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.4
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.8
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.11.0.6
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.2
	SMP_BASE:1.3
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.81
date	2016.12.02.11.16.04;	author mpi;	state Exp;
branches;
next	1.80;
commitid	WNL3JHfh9QQ4epFM;

1.80
date	2016.09.02.13.53.44;	author vgross;	state Exp;
branches;
next	1.79;
commitid	j7vsahHAiZXQ6IjB;

1.79
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.78;
commitid	nbCHuHn2E9uBfKJT;

1.78
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.77;
commitid	Cm0qxR09oTCkXjXZ;

1.77
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.76;
commitid	jodmGXAB42f8N6nf;

1.76
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.75;
commitid	LxUFHuffW7GZZ01f;

1.75
date	2016.07.05.09.17.10;	author mpi;	state Exp;
branches;
next	1.74;
commitid	1gPJe3piOxCmCu6H;

1.74
date	2016.06.30.12.36.27;	author mpi;	state Exp;
branches;
next	1.73;
commitid	CBXvgAdAkcHfXnGX;

1.73
date	2016.06.27.16.36.08;	author jca;	state Exp;
branches;
next	1.72;
commitid	UQdMkkDalincB7ca;

1.72
date	2015.12.05.13.21.00;	author vgross;	state Exp;
branches;
next	1.71;
commitid	X15ZQEh3txIlwce1;

1.71
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.70;
commitid	Hf3C2AvfIXmCAmHE;

1.70
date	2015.10.25.14.43.06;	author florian;	state Exp;
branches;
next	1.69;
commitid	YdNR4Tx8Af0XRTgT;

1.69
date	2015.10.25.13.55.51;	author mpi;	state Exp;
branches;
next	1.68;
commitid	xFB8CWsOnikvd8RS;

1.68
date	2015.10.24.16.57.46;	author mpi;	state Exp;
branches;
next	1.67;
commitid	rxQp7xkBZ8RdiSsL;

1.67
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.66;
commitid	xFxvBxiFybIsZNMc;

1.66
date	2015.10.24.12.33.16;	author mpi;	state Exp;
branches;
next	1.65;
commitid	FKjowUWiF07inZqL;

1.65
date	2015.10.22.16.33.32;	author mpi;	state Exp;
branches;
next	1.64;
commitid	wcopv9ib7iJxpyRA;

1.64
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.63;
commitid	aMzCQ7pRC6VLKZyx;

1.63
date	2015.10.13.10.16.17;	author mpi;	state Exp;
branches;
next	1.62;
commitid	x5pP5R0xzn8v0H1b;

1.62
date	2015.09.18.14.26.22;	author mpi;	state Exp;
branches;
next	1.61;
commitid	hGprk1rxxzKhgpj5;

1.61
date	2015.09.11.20.16.03;	author claudio;	state Exp;
branches;
next	1.60;
commitid	FB0cvtO9tSu02Aw9;

1.60
date	2015.09.11.19.23.00;	author mpi;	state Exp;
branches;
next	1.59;
commitid	ZcCSlMJqT7JT7yQD;

1.59
date	2015.09.11.13.53.04;	author mpi;	state Exp;
branches;
next	1.58;
commitid	PQQVxswGql4gzKJa;

1.58
date	2015.09.11.09.58.33;	author mpi;	state Exp;
branches;
next	1.57;
commitid	QtNDimZdovXpU3uh;

1.57
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.56;
commitid	sTEWfQrcV5GjIWc0;

1.56
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.55;
commitid	PcRGyy4jlpJbKkXz;

1.55
date	2015.09.03.14.59.23;	author mpi;	state Exp;
branches;
next	1.54;
commitid	2xlxwCdXfTZ2Xdk2;

1.54
date	2015.09.03.09.59.59;	author mpi;	state Exp;
branches;
next	1.53;
commitid	59waGk54fAHjhss2;

1.53
date	2015.09.02.08.28.06;	author mpi;	state Exp;
branches;
next	1.52;
commitid	dLfuF0b8wZHTynjf;

1.52
date	2015.09.01.14.33.15;	author mpi;	state Exp;
branches;
next	1.51;
commitid	5R8mYbNSlPpr0mpl;

1.51
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.50;
commitid	4Ro7ulidQXNcMvmM;

1.50
date	2014.12.17.09.45.59;	author mpi;	state Exp;
branches;
next	1.49;
commitid	Vq8oSnWLkf7dyy0N;

1.49
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.48;
commitid	t9FBKDfc4VDxpEy2;

1.48
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.47;
commitid	w0MRp28dmfD1ZzO8;

1.47
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.46;
commitid	6AYfDT0Lpez1LFQp;

1.46
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.45;
commitid	HQcmytntiCJTHORs;

1.45
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.44;
commitid	DQakU8LLWV6Iwx84;

1.44
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.43;
commitid	2Ufy37wyO5neufOK;

1.43
date	2014.04.21.11.10.54;	author henning;	state Exp;
branches;
next	1.42;

1.42
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.41;

1.41
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.40;

1.40
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.39;

1.39
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.12.14.15.09;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.36;

1.36
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.35;

1.35
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2013.10.21.08.42.25;	author phessler;	state Exp;
branches;
next	1.33;

1.33
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.28.00.32.11;	author bluhm;	state Exp;
branches;
next	1.29;

1.29
date	2013.03.20.10.34.12;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.27;

1.27
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.26;

1.26
date	2011.08.07.18.49.50;	author mikeb;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.02.08.12.04.35;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.11.11.26.05;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.19.19.38.34;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.10.03.30.21;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.29.01.45.52;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.30.11.09.00;	author itojun;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2001.02.16.14.45.12;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.06.00.22.23;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.21.09.07.24;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.18.17.02.59;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.18.04.49.32;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.13.10.12.01;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.05.14.22.40.18;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2000.06.18.18.02.33;	author jason;	state Exp;
branches;
next	;

1.11.6.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.11.6.2;

1.11.6.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	;


desc
@@


1.81
log
@Rremoves 'struct route_in6 *' argument from in6_selectsrc().

Move the corresponding code in in6_pcbselsrc().  This reduces
differences with IPv4 and will help us to get rid of 'struct route*'.

ok vgross@@
@
text
@/*	$OpenBSD: in6_src.c,v 1.80 2016/09/02 13:53:44 vgross Exp $	*/
/*	$KAME: in6_src.c,v 1.36 2001/02/06 04:08:17 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)in_pcb.c	8.2 (Berkeley) 1/4/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/time.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet6/nd6.h>

int in6_selectif(struct sockaddr_in6 *, struct ip6_pktopts *,
    struct ip6_moptions *, struct route_in6 *, struct ifnet **, u_int);

/*
 * Return an IPv6 address, which is the most appropriate for a given
 * destination and pcb. We need the additional opt parameter because
 * the values set at pcb level can be overriden via cmsg.
 */
int
in6_pcbselsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct inpcb *inp, struct ip6_pktopts *opts)
{
	struct ip6_moptions *mopts = inp->inp_moptions6;
	struct route_in6 *ro = &inp->inp_route6;
	struct in6_addr *laddr = &inp->inp_laddr6;
	u_int rtableid = inp->inp_rtableid;
	struct ifnet *ifp = NULL;
	struct in6_addr *dst;
	struct in6_ifaddr *ia6 = NULL;
	struct in6_pktinfo *pi = NULL;
	int	error;

	dst = &dstsock->sin6_addr;

	/*
	 * If the source address is explicitly specified by the caller,
	 * check if the requested source address is indeed a unicast address
	 * assigned to the node, and can be used as the packet's source
	 * address.  If everything is okay, use the address as source.
	 */
	if (opts && (pi = opts->ip6po_pktinfo) &&
	    !IN6_IS_ADDR_UNSPECIFIED(&pi->ipi6_addr)) {
		struct sockaddr_in6 sa6;

		/* get the outgoing interface */
		error = in6_selectif(dstsock, opts, mopts, ro, &ifp, rtableid);
		if (error)
			return (error);

		bzero(&sa6, sizeof(sa6));
		sa6.sin6_family = AF_INET6;
		sa6.sin6_len = sizeof(sa6);
		sa6.sin6_addr = pi->ipi6_addr;

		if (ifp && IN6_IS_SCOPE_EMBED(&sa6.sin6_addr))
			sa6.sin6_addr.s6_addr16[1] = htons(ifp->if_index);
		if_put(ifp); /* put reference from in6_selectif */

		ia6 = ifatoia6(ifa_ifwithaddr(sin6tosa(&sa6), rtableid));
		if (ia6 == NULL || (ia6->ia6_flags &
		     (IN6_IFF_ANYCAST|IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED)))
			return (EADDRNOTAVAIL);

		pi->ipi6_addr = sa6.sin6_addr; /* XXX: this overrides pi */

		*in6src = &pi->ipi6_addr;
		return (0);
	}

	/*
	 * If the source address is not specified but the socket(if any)
	 * is already bound, use the bound address.
	 */
	if (laddr && !IN6_IS_ADDR_UNSPECIFIED(laddr)) {
		*in6src = laddr;
		return (0);
	}

	/*
	 * If the caller doesn't specify the source address but
	 * the outgoing interface, use an address associated with
	 * the interface.
	 */
	if (pi && pi->ipi6_ifindex) {
		ifp = if_get(pi->ipi6_ifindex);
		if (ifp == NULL)
			return (ENXIO); /* XXX: better error? */

		ia6 = in6_ifawithscope(ifp, dst, rtableid);
		if_put(ifp);

		if (ia6 == NULL)
			return (EADDRNOTAVAIL);

		*in6src = &ia6->ia_addr.sin6_addr;
		return (0);
	}

	error = in6_selectsrc(in6src, dstsock, mopts, rtableid);
	if (error != EADDRNOTAVAIL)
		return (error);

	/*
	 * If route is known or can be allocated now,
	 * our src addr is taken from the i/f, else punt.
	 */
	if (!rtisvalid(ro->ro_rt) || (ro->ro_tableid != rtableid) ||
	    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
		rtfree(ro->ro_rt);
		ro->ro_rt = NULL;
	}
	if (ro->ro_rt == NULL) {
		struct sockaddr_in6 *sa6;

		/* No route yet, so try to acquire one */
		bzero(&ro->ro_dst, sizeof(struct sockaddr_in6));
		ro->ro_tableid = rtableid;
		sa6 = &ro->ro_dst;
		sa6->sin6_family = AF_INET6;
		sa6->sin6_len = sizeof(struct sockaddr_in6);
		sa6->sin6_addr = *dst;
		sa6->sin6_scope_id = dstsock->sin6_scope_id;
		ro->ro_rt = rtalloc(sin6tosa(&ro->ro_dst),
		    RT_RESOLVE, ro->ro_tableid);
	}

	/*
	 * in_pcbconnect() checks out IFF_LOOPBACK to skip using
	 * the address. But we don't know why it does so.
	 * It is necessary to ensure the scope even for lo0
	 * so doesn't check out IFF_LOOPBACK.
	 */

	if (ro->ro_rt) {
		ifp = if_get(ro->ro_rt->rt_ifidx);
		if (ifp != NULL) {
			ia6 = in6_ifawithscope(ifp, dst, rtableid);
			if_put(ifp);
		}
		if (ia6 == NULL) /* xxx scope error ?*/
			ia6 = ifatoia6(ro->ro_rt->rt_ifa);
	}
	if (ia6 == NULL)
		return (EHOSTUNREACH);	/* no route */

	*in6src = &ia6->ia_addr.sin6_addr;
	return (0);
}

/*
 * Return an IPv6 address, which is the most appropriate for a given
 * destination and multicast options.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
 */
int
in6_selectsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct ip6_moptions *mopts, unsigned int rtableid)
{
	struct ifnet *ifp = NULL;
	struct in6_addr *dst;
	struct in6_ifaddr *ia6 = NULL;

	dst = &dstsock->sin6_addr;

	/*
	 * If the destination address is a link-local unicast address or
	 * a link/interface-local multicast address, and if the outgoing
	 * interface is specified by the sin6_scope_id filed, use an address
	 * associated with the interface.
	 * XXX: We're now trying to define more specific semantics of
	 *      sin6_scope_id field, so this part will be rewritten in
	 *      the near future.
	 */
	if ((IN6_IS_ADDR_LINKLOCAL(dst) || IN6_IS_ADDR_MC_LINKLOCAL(dst) ||
	     IN6_IS_ADDR_MC_INTFACELOCAL(dst)) && dstsock->sin6_scope_id) {
		ifp = if_get(dstsock->sin6_scope_id);
		if (ifp == NULL)
			return (ENXIO); /* XXX: better error? */

		ia6 = in6_ifawithscope(ifp, dst, rtableid);
		if_put(ifp);

		if (ia6 == NULL)
			return (EADDRNOTAVAIL);

		*in6src = &ia6->ia_addr.sin6_addr;
		return (0);
	}

	/*
	 * If the destination address is a multicast address and
	 * the outgoing interface for the address is specified
	 * by the caller, use an address associated with the interface.
	 * Even if the outgoing interface is not specified, we also
	 * choose a loopback interface as the outgoing interface.
	 */
	if (IN6_IS_ADDR_MULTICAST(dst)) {
		ifp = mopts ? if_get(mopts->im6o_ifidx) : NULL;

		if (!ifp && dstsock->sin6_scope_id)
			ifp = if_get(htons(dstsock->sin6_scope_id));

		if (ifp) {
			ia6 = in6_ifawithscope(ifp, dst, rtableid);
			if_put(ifp);

			if (ia6 == NULL)
				return (EADDRNOTAVAIL);

			*in6src = &ia6->ia_addr.sin6_addr;
			return (0);
		}
	}

	return (EADDRNOTAVAIL);
}

struct rtentry *
in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
    struct route_in6 *ro, unsigned int rtableid)
{
	struct in6_addr *dst;

	dst = &dstsock->sin6_addr;

	/*
	 * Use a cached route if it exists and is valid, else try to allocate
	 * a new one.
	 */
	if (ro) {
		if (rtisvalid(ro->ro_rt))
			KASSERT(sin6tosa(&ro->ro_dst)->sa_family == AF_INET6);
		if (!rtisvalid(ro->ro_rt) ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
			rtfree(ro->ro_rt);
			ro->ro_rt = NULL;
		}
		if (ro->ro_rt == NULL) {
			struct sockaddr_in6 *sa6;

			/* No route yet, so try to acquire one */
			bzero(&ro->ro_dst, sizeof(struct sockaddr_in6));
			ro->ro_tableid = rtableid;
			sa6 = &ro->ro_dst;
			*sa6 = *dstsock;
			sa6->sin6_scope_id = 0;
			ro->ro_tableid = rtableid;
			ro->ro_rt = rtalloc_mpath(sin6tosa(&ro->ro_dst),
			    NULL, ro->ro_tableid);
		}

		/*
		 * Check if the outgoing interface conflicts with
		 * the interface specified by ipi6_ifindex (if specified).
		 * Note that loopback interface is always okay.
		 * (this may happen when we are sending a packet to one of
		 *  our own addresses.)
		 */
		if (opts && opts->ip6po_pktinfo &&
		    opts->ip6po_pktinfo->ipi6_ifindex) {
			if (ro->ro_rt != NULL &&
			    !ISSET(ro->ro_rt->rt_flags, RTF_LOCAL) &&
			    ro->ro_rt->rt_ifidx !=
			    opts->ip6po_pktinfo->ipi6_ifindex) {
			    	return (NULL);
			}
		}

		return (ro->ro_rt);
	}

	return (NULL);
}

int
in6_selectif(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
    struct ip6_moptions *mopts, struct route_in6 *ro, struct ifnet **retifp,
    u_int rtableid)
{
	struct rtentry *rt = NULL;
	struct in6_pktinfo *pi = NULL;

	/* If the caller specify the outgoing interface explicitly, use it. */
	if (opts && (pi = opts->ip6po_pktinfo) != NULL && pi->ipi6_ifindex) {
		*retifp = if_get(pi->ipi6_ifindex);
		if (*retifp != NULL)
			return (0);
	}

	/*
	 * If the destination address is a multicast address and the outgoing
	 * interface for the address is specified by the caller, use it.
	 */
	if (IN6_IS_ADDR_MULTICAST(&dstsock->sin6_addr) &&
	    mopts != NULL && (*retifp = if_get(mopts->im6o_ifidx)) != NULL)
	    	return (0);

	rt = in6_selectroute(dstsock, opts, ro, rtableid);
	if (rt == NULL)
		return (EHOSTUNREACH);

	/*
	 * do not use a rejected or black hole route.
	 * XXX: this check should be done in the L2 output routine.
	 * However, if we skipped this check here, we'd see the following
	 * scenario:
	 * - install a rejected route for a scoped address prefix
	 *   (like fe80::/10)
	 * - send a packet to a destination that matches the scoped prefix,
	 *   with ambiguity about the scope zone.
	 * - pick the outgoing interface from the route, and disambiguate the
	 *   scope zone with the interface.
	 * - ip6_output() would try to get another route with the "new"
	 *   destination, which may be valid.
	 * - we'd see no error on output.
	 * Although this may not be very harmful, it should still be confusing.
	 * We thus reject the case here.
	 */
	if (rt && (rt->rt_flags & (RTF_REJECT | RTF_BLACKHOLE)))
		return (rt->rt_flags & RTF_HOST ? EHOSTUNREACH : ENETUNREACH);

	if (rt != NULL)
		*retifp = if_get(rt->rt_ifidx);

	return (0);
}

int
in6_selecthlim(struct inpcb *in6p)
{
	if (in6p && in6p->inp_hops >= 0)
		return (in6p->inp_hops);

	return (ip6_defhlim);
}

/*
 * generate kernel-internal form (scopeid embedded into s6_addr16[1]).
 * If the address scope of is link-local, embed the interface index in the
 * address.  The routine determines our precedence
 * between advanced API scope/interface specification and basic API
 * specification.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 *
 * XXX actually, it is over-specification to return ifp against sin6_scope_id.
 * there can be multiple interfaces that belong to a particular scope zone
 * (in specification, we have 1:N mapping between a scope zone and interfaces).
 * we may want to change the function to return something other than ifp.
 */
int
in6_embedscope(struct in6_addr *in6, const struct sockaddr_in6 *sin6,
    struct inpcb *in6p)
{
	struct ifnet *ifp = NULL;
	u_int32_t scopeid;

	*in6 = sin6->sin6_addr;
	scopeid = sin6->sin6_scope_id;

	/*
	 * don't try to read sin6->sin6_addr beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */

	if (IN6_IS_SCOPE_EMBED(in6)) {
		struct in6_pktinfo *pi;

		/*
		 * KAME assumption: link id == interface id
		 */

		if (in6p && in6p->inp_outputopts6 &&
		    (pi = in6p->inp_outputopts6->ip6po_pktinfo) &&
		    pi->ipi6_ifindex) {
			ifp = if_get(pi->ipi6_ifindex);
			if (ifp == NULL)
				return ENXIO;  /* XXX EINVAL? */
			in6->s6_addr16[1] = htons(pi->ipi6_ifindex);
		} else if (in6p && IN6_IS_ADDR_MULTICAST(in6) &&
		    in6p->inp_moptions6 &&
		    (ifp = if_get(in6p->inp_moptions6->im6o_ifidx))) {
			in6->s6_addr16[1] = htons(ifp->if_index);
		} else if (scopeid) {
			ifp = if_get(scopeid);
			if (ifp == NULL)
				return ENXIO;  /* XXX EINVAL? */
			/*XXX assignment to 16bit from 32bit variable */
			in6->s6_addr16[1] = htons(scopeid & 0xffff);
		}
		if_put(ifp);
	}

	return 0;
}

/*
 * generate standard sockaddr_in6 from embedded form.
 * touches sin6_addr and sin6_scope_id only.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 */
void
in6_recoverscope(struct sockaddr_in6 *sin6, const struct in6_addr *in6)
{
	u_int32_t scopeid;

	sin6->sin6_addr = *in6;

	/*
	 * don't try to read *in6 beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */

	sin6->sin6_scope_id = 0;
	if (IN6_IS_SCOPE_EMBED(in6)) {
		/*
		 * KAME assumption: link id == interface id
		 */
		scopeid = ntohs(sin6->sin6_addr.s6_addr16[1]);
		if (scopeid) {
			sin6->sin6_addr.s6_addr16[1] = 0;
			sin6->sin6_scope_id = scopeid;
		}
	}
}

/*
 * just clear the embedded scope identifer.
 */
void
in6_clearscope(struct in6_addr *addr)
{
	if (IN6_IS_SCOPE_EMBED(addr))
		addr->s6_addr16[1] = 0;
}
@


1.80
log
@in6_selectroute should never get a valid struct route * filled with something
else than AF_INET6.

Ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.79 2016/08/04 20:46:24 vgross Exp $	*/
a101 1

d174 49
a222 1
	return in6_selectsrc(in6src, dstsock, mopts, ro, rtableid);
d233 1
a233 1
    struct ip6_moptions *mopts, struct route_in6 *ro, u_int rtableid)
a288 48
	}

	/*
	 * If route is known or can be allocated now,
	 * our src addr is taken from the i/f, else punt.
	 */
	if (ro) {
		if (!rtisvalid(ro->ro_rt) || (ro->ro_tableid != rtableid) ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
			rtfree(ro->ro_rt);
			ro->ro_rt = NULL;
		}
		if (ro->ro_rt == NULL) {
			struct sockaddr_in6 *sa6;

			/* No route yet, so try to acquire one */
			bzero(&ro->ro_dst, sizeof(struct sockaddr_in6));
			ro->ro_tableid = rtableid;
			sa6 = &ro->ro_dst;
			sa6->sin6_family = AF_INET6;
			sa6->sin6_len = sizeof(struct sockaddr_in6);
			sa6->sin6_addr = *dst;
			sa6->sin6_scope_id = dstsock->sin6_scope_id;
			ro->ro_rt = rtalloc(sin6tosa(&ro->ro_dst),
			    RT_RESOLVE, ro->ro_tableid);
		}

		/*
		 * in_pcbconnect() checks out IFF_LOOPBACK to skip using
		 * the address. But we don't know why it does so.
		 * It is necessary to ensure the scope even for lo0
		 * so doesn't check out IFF_LOOPBACK.
		 */

		if (ro->ro_rt) {
			ifp = if_get(ro->ro_rt->rt_ifidx);
			if (ifp != NULL) {
				ia6 = in6_ifawithscope(ifp, dst, rtableid);
				if_put(ifp);
			}
			if (ia6 == NULL) /* xxx scope error ?*/
				ia6 = ifatoia6(ro->ro_rt->rt_ifa);
		}
		if (ia6 == NULL)
			return (EHOSTUNREACH);	/* no route */

		*in6src = &ia6->ia_addr.sin6_addr;
		return (0);
@


1.79
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.78 2016/07/22 11:14:41 mpi Exp $	*/
d305 1
a305 2
	 * a new one.  Note that we should check the address family of the
	 * cached destination, in case of sharing the cache with IPv4.
d308 2
d311 1
a311 2
		     sin6tosa(&ro->ro_dst)->sa_family != AF_INET6 ||
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
@


1.78
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.76 2016/07/05 10:17:14 mpi Exp $	*/
d91 2
a92 3
 * destination and user specified options.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
d95 2
a96 3
in6_selectsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct ip6_pktopts *opts, struct ip6_moptions *mopts,
    struct route_in6 *ro, struct in6_addr *laddr, u_int rtableid)
d98 5
d174 19
@


1.77
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d91 3
a93 2
 * destination and pcb. We need the additional opt parameter because
 * the values set at pcb level can be overriden via cmsg.
d96 3
a98 2
in6_pcbselsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct inpcb *inp, struct ip6_pktopts *opts)
a99 5
	struct ip6_moptions *mopts = inp->inp_moptions6;
	struct route_in6 *ro = &inp->inp_route6;
	struct in6_addr *laddr = &inp->inp_laddr6;
	u_int rtableid = inp->inp_rtableid;

a170 17

	return in6_selectsrc(in6src, dstsock, mopts, ro, rtableid);
}

/*
 * Return an IPv6 address, which is the most appropriate for a given
 * destination and multicast options.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
 */
int
in6_selectsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct ip6_moptions *mopts, struct route_in6 *ro, u_int rtableid)
{
	struct ifnet *ifp = NULL;
	struct in6_addr *dst;
	struct in6_ifaddr *ia6 = NULL;
@


1.76
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.75 2016/07/05 09:17:10 mpi Exp $	*/
d91 2
a92 3
 * destination and user specified options.
 * If necessary, this function lookups the routing table and returns
 * an entry to the caller for later use.
d95 2
a96 3
in6_selectsrc(struct in6_addr **in6src, struct sockaddr_in6 *dstsock,
    struct ip6_pktopts *opts, struct ip6_moptions *mopts,
    struct route_in6 *ro, struct in6_addr *laddr, u_int rtableid)
d98 5
d174 17
@


1.75
log
@Do not use ``rt_addr'' in in{6,}_selectsrc() it doesn't work with magic
addresses set on p2p interfaces.

Found the hardway by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.74 2016/06/30 12:36:27 mpi Exp $	*/
d133 2
a134 2
		if (ia6 == NULL ||
		    (ia6->ia6_flags & (IN6_IFF_ANYCAST | IN6_IFF_NOTREADY)))
@


1.74
log
@Use ``rt_addr'' rather than ``rt_ifa'' to get the source address
corresponding to a route.

ok florian@@ on a previous version, input and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.73 2016/06/27 16:36:08 jca Exp $	*/
d260 2
a261 5
			if (ia6 == NULL) { /* xxx scope error ?*/
				*in6src =
				    &satosin6(ro->ro_rt->rt_addr)->sin6_addr;
				return (0);
			}
@


1.73
log
@Kill outdated comment.  Reading the code is enough.

ok sthen@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.72 2015/12/05 13:21:00 vgross Exp $	*/
d260 5
a264 2
			if (ia6 == NULL) /* xxx scope error ?*/
				ia6 = ifatoia6(ro->ro_rt->rt_ifa);
@


1.72
log
@Remove useless "if() else", multicast and unicast v6 route lookups are
actually the same. This has been introduced in r1.7 to prevent RTM_MISS
storms, but we don't send this message anymore.

ok @@mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.71 2015/12/02 13:29:26 claudio Exp $	*/
a382 7
/*
 * Default hop limit selection. The precedence is as follows:
 * 1. Hoplimit value specified via ioctl.
 * 2. (If the outgoing interface is detected) the current
 *     hop limit of the interface specified by router advertisement.
 * 3. The system default hoplimit.
*/
@


1.71
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.70 2015/10/25 14:43:06 florian Exp $	*/
d243 2
a244 7
			if (IN6_IS_ADDR_MULTICAST(dst)) {
				ro->ro_rt = rtalloc(sin6tosa(&ro->ro_dst),
				    RT_RESOLVE, ro->ro_tableid);
			} else {
				ro->ro_rt = rtalloc_mpath(sin6tosa(&ro->ro_dst),
				    NULL, ro->ro_tableid);
			}
@


1.70
log
@Remove IPV6_NEXTHOP implementation. Source routing is considered to be
a bad idea these days.
kill it mpi@@
general agreement in the network hackers room at u2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.69 2015/10/25 13:55:51 mpi Exp $	*/
d245 1
a245 1
				    RT_REPORT|RT_RESOLVE, ro->ro_tableid);
@


1.69
log
@Use the "modern" way to check if a route entry correspond to a local
address.

Fix a regression introduced when removing the lo0 hack.

ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.68 2015/10/24 16:57:46 mpi Exp $	*/
a222 32
	 * If the next hop address for the packet is specified
	 * by caller, use an address associated with the route
	 * to the next hop.
	 */
	{
		struct sockaddr_in6 *sin6_next;
		struct rtentry *rt;

		if (opts && opts->ip6po_nexthop) {
			sin6_next = satosin6(opts->ip6po_nexthop);
			rt = nd6_lookup(&sin6_next->sin6_addr, 1, NULL,
			    rtableid);
			if (rt != NULL) {
				ifp = if_get(rt->rt_ifidx);
				if (ifp != NULL) {
					ia6 = in6_ifawithscope(ifp, dst,
					    rtableid);
					if_put(ifp);
				}
				if (ia6 == NULL)
					ia6 = ifatoia6(rt->rt_ifa);
				rtfree(rt);
			}
			if (ia6 == NULL)
				return (EADDRNOTAVAIL);

			*in6src = &ia6->ia_addr.sin6_addr;
			return (0);
		}
	}

	/*
a281 1
	struct sockaddr_in6 *sin6_next;
a284 51

	/*
	 * If the next hop address for the packet is specified by the caller,
	 * use it as the gateway.
	 */
	if (opts && opts->ip6po_nexthop) {
		struct route_in6 *ron;

		sin6_next = satosin6(opts->ip6po_nexthop);

		/* We only support AF_INET6 next hops */
		if (sin6_next->sin6_family != AF_INET6)
			return (NULL);

		/*
		 * If the next hop is an IPv6 address, then the node identified
		 * by that address must be a neighbor of the sending host.
		 */
		ron = &opts->ip6po_nextroute;
		if (!rtisvalid(ron->ro_rt) ||
		    ISSET(ron->ro_rt->rt_flags, RTF_GATEWAY) ||
		    !IN6_ARE_ADDR_EQUAL(&ron->ro_dst.sin6_addr,
		    &sin6_next->sin6_addr)) {
			if (ron->ro_rt) {
				rtfree(ron->ro_rt);
				ron->ro_rt = NULL;
			}
			ron->ro_dst = *sin6_next;
			ron->ro_tableid = rtableid;
		}
		if (ron->ro_rt == NULL) {
			/* multi path case? */
			ron->ro_rt = rtalloc(sin6tosa(&ron->ro_dst),
			    RT_REPORT|RT_RESOLVE, ron->ro_tableid);
			if (ron->ro_rt == NULL ||
			    (ron->ro_rt->rt_flags & RTF_GATEWAY)) {
				if (ron->ro_rt) {
					rtfree(ron->ro_rt);
					ron->ro_rt = NULL;
				}
				return (NULL);
			}
		}
		if (!nd6_is_addr_neighbor(sin6_next, ron->ro_rt->rt_ifp)) {
			rtfree(ron->ro_rt);
			ron->ro_rt = NULL;
			return (NULL);
		}

		return (ron->ro_rt);
	}
@


1.68
log
@Convert to rt_ifidx.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.67 2015/10/24 16:08:48 mpi Exp $	*/
d406 2
a407 2
			    (ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK) == 0 &&
			    ro->ro_rt->rt_ifp->if_index !=
@


1.67
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.66 2015/10/24 12:33:16 mpi Exp $	*/
d236 6
a241 2
				ia6 = in6_ifawithscope(rt->rt_ifp, dst,
				    rtableid);
d292 5
a296 2
			ia6 = in6_ifawithscope(ro->ro_rt->rt_ifp, dst,
			    rtableid);
@


1.66
log
@Convert some if_ref() to if_get().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.65 2015/10/22 16:33:32 mpi Exp $	*/
d473 1
a473 1
in6_selecthlim(struct inpcb *in6p, struct ifnet *ifp)
d477 2
a478 4
	else if (ifp)
		return (ND_IFINFO(ifp)->chlim);
	else
		return (ip6_defhlim);
@


1.65
log
@Use rt_ifp instead of rt_ifa->ifa_ifp.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.64 2015/10/19 12:11:28 mpi Exp $	*/
d460 1
a460 1
		*retifp = if_ref(rt->rt_ifp);
@


1.64
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.63 2015/10/13 10:16:17 mpi Exp $	*/
d288 1
a288 1
			ia6 = in6_ifawithscope(ro->ro_rt->rt_ifa->ifa_ifp, dst,
d459 2
a460 9
	/*
	 * Adjust the "outgoing" interface.  If we're going to loop the packet
	 * back to ourselves, the ifp would be the loopback interface.
	 * However, we'd rather know the interface associated to the
	 * destination address (which should probably be one of our own
	 * addresses.)
	 */
	if (rt && rt->rt_ifa && rt->rt_ifa->ifa_ifp)
		*retifp = if_ref(rt->rt_ifa->ifa_ifp);
@


1.63
log
@Use rtisivalid(9) to check if the given (cached) route can be used.

Note that after calling rtalloc(9) we only check if a route has been
returned or not and do not check for its validity.  This cannot be
improved without a massive refactoring.

The kernel currently *do* use !RTF_UP route due to a mismatch between
the value of ifp->if_link_state and the IFF_UP|IFF_RUNNING code.

I'd explain the RTF_UP flag as follow:

.  If a cached route entry w/o RTF_UP is passed to ip{6,}_output(),
.  call rtalloc(9) to see if a better entry is present in the tree.

This is enough to support MPATH and route cache invalidation.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.62 2015/09/18 14:26:22 mpi Exp $	*/
d255 1
a255 1
		if (!rtisvalid(ro->ro_rt) ||
d330 2
a331 3
		if ((ron->ro_rt &&
		    (ron->ro_rt->rt_flags & (RTF_UP | RTF_GATEWAY)) !=
		    RTF_UP) ||
@


1.62
log
@Do not manually decrement rt's refcounter in nd6_lookup() and let the
callers rtfree(9) it.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.61 2015/09/11 20:16:03 claudio Exp $	*/
d255 2
a256 2
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
d260 1
a260 2
		if (ro->ro_rt == (struct rtentry *)0 ||
		    ro->ro_rt->rt_ifp == (struct ifnet *)0) {
d370 1
a370 2
		if (ro->ro_rt &&
		    (!(ro->ro_rt->rt_flags & RTF_UP) ||
d372 1
a372 1
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
@


1.61
log
@if_put after if_get for in6_src and ip6_output which got a lot easier after
all the cleanup by mpi@@ since we no longer overwrite ifps, etc. OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.60 2015/09/11 19:23:00 mpi Exp $	*/
d235 1
a235 1
			if (rt) {
d240 1
@


1.60
log
@Rewrite in6_selectroute() to no longer return an ifp.

The returned "struct rtentry" is either the cached one or the one passed
in options.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.59 2015/09/11 13:53:04 mpi Exp $	*/
d130 1
d163 2
d188 2
d212 2
d469 1
a469 1
		*retifp = rt->rt_ifa->ifa_ifp;
@


1.59
log
@Move the multicast option parsing out of in6_selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.58 2015/09/11 09:58:33 mpi Exp $	*/
d296 1
a296 1
int
d298 1
a298 2
    struct route_in6 *ro, struct ifnet **retifp,
    struct rtentry **retrt, unsigned int rtableid)
a299 3
	int error = 0;
	struct ifnet *ifp = NULL;
	struct rtentry *rt = NULL;
d314 3
a316 5
		/* at this moment, we only support AF_INET6 next hops */
		if (sin6_next->sin6_family != AF_INET6) {
			error = EAFNOSUPPORT; /* or should we proceed? */
			goto done;
		}
d345 1
a345 2
				error = EHOSTUNREACH;
				goto done;
d351 1
a351 2
			error = EHOSTUNREACH;
			goto done;
a352 2
		rt = ron->ro_rt;
		ifp = rt->rt_ifp;
d354 1
a354 6
		/*
		 * When cloning is required, try to allocate a route to the
		 * destination so that the caller can store path MTU
		 * information.
		 */
		goto done;
a384 19
		 * do not care about the result if we have the nexthop
		 * explicitly specified.
		 */
		if (opts && opts->ip6po_nexthop)
			goto done;

		if (ro->ro_rt) {
			ifp = ro->ro_rt->rt_ifp;

			if (ifp == NULL) { /* can this really happen? */
				rtfree(ro->ro_rt);
				ro->ro_rt = NULL;
			}
		}
		if (ro->ro_rt == NULL)
			error = EHOSTUNREACH;
		rt = ro->ro_rt;

		/*
d393 3
a395 2
			if (!(ifp->if_flags & IFF_LOOPBACK) &&
			    ifp->if_index !=
d397 1
a397 2
				error = EHOSTUNREACH;
				goto done;
a399 1
	}
d401 1
a401 7
  done:
	if (ifp == NULL && rt == NULL) {
		/*
		 * This can happen if the caller did not pass a cached route
		 * nor any other hints.  We treat this case an error.
		 */
		error = EHOSTUNREACH;
d404 1
a404 6
	if (retifp != NULL)
		*retifp = ifp;
	if (retrt != NULL)
		*retrt = rt;	/* rt may be NULL */

	return (error);
a413 1
	int error;
d430 3
a432 3
	if ((error = in6_selectroute(dstsock, opts, ro, retifp,
	    &rt, rtableid)) != 0)
		return (error);
@


1.58
log
@Kill selectroute().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.57 2015/09/11 07:42:35 claudio Exp $	*/
d298 2
a299 2
    struct ip6_moptions *mopts, struct route_in6 *ro, struct ifnet **retifp,
    struct rtentry **retrt, int norouteok, u_int rtableid)
a304 1
	struct in6_pktinfo *pi = NULL;
a308 25
	/* If the caller specify the outgoing interface explicitly, use it. */
	if (opts && (pi = opts->ip6po_pktinfo) != NULL && pi->ipi6_ifindex) {
		ifp = if_get(pi->ipi6_ifindex);
		if (ifp != NULL &&
		    (norouteok || retrt == NULL ||
		     IN6_IS_ADDR_MULTICAST(dst))) {
			/*
			 * we do not have to check or get the route for
			 * multicast.
			 */
			goto done;
		} else
			goto getroute;
	}

	/*
	 * If the destination address is a multicast address and the outgoing
	 * interface for the address is specified by the caller, use it.
	 */
	if (IN6_IS_ADDR_MULTICAST(dst) &&
	    mopts != NULL && (ifp = if_get(mopts->im6o_ifidx)) != NULL) {
		goto done; /* we do not need a route for multicast. */
	}

  getroute:
a443 2
	if (error == EHOSTUNREACH)
		ip6stat.ip6s_noroute++;
d459 1
d462 17
a478 2
	if ((error = in6_selectroute(dstsock, opts, mopts, ro, retifp,
	    &rt, 1, rtableid)) != 0)
@


1.57
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.56 2015/09/10 17:52:05 claudio Exp $	*/
a87 3
int selectroute(struct sockaddr_in6 *, struct ip6_pktopts *,
    struct ip6_moptions *, struct route_in6 *, struct ifnet **,
    struct rtentry **, int, u_int);
d297 1
a297 1
selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
a309 15
#if 0
	char ip[INET6_ADDRSTRLEN];

	if (dstsock->sin6_addr.s6_addr32[0] == 0 &&
	    dstsock->sin6_addr.s6_addr32[1] == 0 &&
	    !IN6_IS_ADDR_LOOPBACK(&dstsock->sin6_addr)) {
		printf("in6_selectroute: strange destination %s\n",
		    inet_ntop(AF_INET6, &dstsock->sin6_addr, ip, sizeof(ip)));
	} else {
		printf("in6_selectroute: destination = %s%%%d\n",
		    inet_ntop(AF_INET6, &dstsock->sin6_addr, ip, sizeof(ip)),
		    dstsock->sin6_scope_id); /* for debug */
	}
#endif

d489 1
a489 1
	if ((error = selectroute(dstsock, opts, mopts, ro, retifp,
a523 10
}

int
in6_selectroute(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
    struct ip6_moptions *mopts, struct route_in6 *ro, struct ifnet **retifp,
    struct rtentry **retrt, u_int rtableid)
{

	return (selectroute(dstsock, opts, mopts, ro, retifp, retrt, 0,
	    rtableid));
@


1.56
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.55 2015/09/03 14:59:23 mpi Exp $	*/
d589 1
a589 1
    struct inpcb *in6p, struct ifnet **ifpp)
a595 2
	if (ifpp)
		*ifpp = NULL;
d617 2
a618 2
			   in6p->inp_moptions6 &&
			   (ifp = if_get(in6p->inp_moptions6->im6o_ifidx))) {
d627 1
a627 3

		if (ifpp)
			*ifpp = ifp;
@


1.55
log
@Revert (again!) the two uses of rtisvalid(9), they break NFS!

Found the hardway by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.54 2015/09/03 09:59:59 mpi Exp $	*/
d644 2
a645 3
int
in6_recoverscope(struct sockaddr_in6 *sin6, const struct in6_addr *in6,
    struct ifnet *ifp)
a662 5
			/* sanity check */
			if (if_get(scopeid) == NULL)
				return ENXIO;
			if (ifp && ifp->if_index != scopeid)
				return ENXIO;
a666 2

	return 0;
@


1.54
log
@Convert ip{,6}_output() (cached) route entry checks to rtisvalid(9).

This introduces a behavior change as we now reject !RTF_UP routes to
output packets.  This stricter check exposed a bug in the setup of
new routes and was the reason for the previous revert.  This should
be now fixed by r1.229 of sys/net/route.c .

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.53 2015/09/02 08:28:06 mpi Exp $	*/
d250 2
a251 2
		if (!rtisvalid(ro->ro_rt) ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
d255 2
a256 1
		if (ro->ro_rt == NULL) {
d422 2
a423 1
		if (!rtisvalid(ro->ro_rt) ||
d425 1
a425 1
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
@


1.53
log
@Revert the two uses of rtisvalid(9) for the moment, it breaks dhclient(8)
configured networks on RAMDISK kernels.

The problem is that the default route installed by dhclient(8) does not
have the RTF_UP flag in this environement and rtisvalid(9) doesn't allow
you to use a RTF_DOWN route.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.52 2015/09/01 14:33:15 mpi Exp $	*/
d250 2
a251 2
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
d255 1
a255 2
		if (ro->ro_rt == (struct rtentry *)0 ||
		    ro->ro_rt->rt_ifp == (struct ifnet *)0) {
d421 1
a421 2
		if (ro->ro_rt &&
		    (!(ro->ro_rt->rt_flags & RTF_UP) ||
d423 1
a423 1
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
@


1.52
log
@Convert ip{,6}_output() (cached) route entry checks to rtisvalid(9).

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.51 2015/06/08 22:19:28 krw Exp $	*/
d250 2
a251 2
		if (!rtisvalid(ro->ro_rt) ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
d255 2
a256 1
		if (ro->ro_rt == NULL) {
d422 2
a423 1
		if (!rtisvalid(ro->ro_rt) ||
d425 1
a425 1
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst)) {
@


1.51
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.50 2014/12/17 09:45:59 mpi Exp $	*/
d250 2
a251 2
		if (ro->ro_rt && ((ro->ro_rt->rt_flags & RTF_UP) == 0 ||
		    !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
d255 1
a255 2
		if (ro->ro_rt == (struct rtentry *)0 ||
		    ro->ro_rt->rt_ifp == (struct ifnet *)0) {
d421 1
a421 2
		if (ro->ro_rt &&
		    (!(ro->ro_rt->rt_flags & RTF_UP) ||
d423 1
a423 1
		     !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, dst))) {
@


1.50
log
@Use an interface index instead of a pointer for multicast options.

Output interface (port) selection for multicast traffic is not done via
route lookups.  Instead the output ifp is registred when setsockopt(2)
is called with the IP{V6,}_MULTICAST_IF option.  But since there is no
mechanism to invalidate such pointer stored in a pcb when an interface
is destroyed/removed, it might lead your kernel to fault.

Prevent a fault upon resume reported by frantisek holop, thanks!

ok mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.49 2014/12/05 15:50:04 mpi Exp $	*/
d234 1
a234 1
				if (ia6 == 0)
d286 1
a286 1
			if (ia6 == 0) /* xxx scope error ?*/
@


1.49
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.48 2014/11/01 21:40:39 mpi Exp $	*/
d203 1
a203 1
		ifp = mopts ? mopts->im6o_multicast_ifp : NULL;
d348 1
a348 1
	    mopts != NULL && (ifp = mopts->im6o_multicast_ifp) != NULL) {
d620 1
a620 2
			   in6p->inp_moptions6->im6o_multicast_ifp) {
			ifp = in6p->inp_moptions6->im6o_multicast_ifp;
@


1.48
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.47 2014/10/14 09:52:26 mpi Exp $	*/
d75 1
@


1.47
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.46 2014/09/27 12:26:16 mpi Exp $	*/
d267 2
a268 2
				ro->ro_rt = rtalloc1(sin6tosa(&ro->ro_dst),
				    RT_REPORT, ro->ro_tableid);
d385 3
a387 2
			ron->ro_rt = rtalloc1(sin6tosa(&ron->ro_dst),
			    RT_REPORT, ron->ro_tableid); /* multi path case? */
@


1.46
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.45 2014/07/22 11:06:10 mpi Exp $	*/
d251 2
a252 2
			RTFREE(ro->ro_rt);
			ro->ro_rt = (struct rtentry *)0;
d378 1
a378 1
				RTFREE(ron->ro_rt);
d390 1
a390 1
					RTFREE(ron->ro_rt);
d398 1
a398 1
			RTFREE(ron->ro_rt);
d424 1
a424 1
			RTFREE(ro->ro_rt);
d452 1
a452 1
				RTFREE(ro->ro_rt);
@


1.45
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.44 2014/06/03 13:32:24 mpi Exp $	*/
d267 2
a268 1
				rtalloc((struct route *)ro);
d270 2
a271 1
				rtalloc_mpath((struct route *)ro, NULL);
d385 2
a386 1
			rtalloc((struct route *)ron); /* multi path case? */
d437 2
a438 1
			rtalloc_mpath((struct route *)ro, NULL);
@


1.44
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.43 2014/04/21 11:10:54 henning Exp $	*/
a77 1
#include <netinet/in_systm.h>
@


1.43
log
@we'll do fine without casting NULL to struct foo * / void *
ok gcc & md5 (alas, no binary change)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.41 2014/04/07 10:04:17 mpi Exp $	*/
a65 1
#include <sys/malloc.h>
@


1.42
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d424 1
a424 1
			ro->ro_rt = (struct rtentry *)NULL;
d426 1
a426 1
		if (ro->ro_rt == (struct rtentry *)NULL) {
@


1.41
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.39 2014/03/27 13:27:28 mpi Exp $	*/
d99 4
a102 4
struct in6_addr *
in6_selectsrc(struct sockaddr_in6 *dstsock, struct ip6_pktopts *opts,
    struct ip6_moptions *mopts, struct route_in6 *ro, struct in6_addr *laddr,
    int *errorp, u_int rtableid)
d108 1
a110 1
	*errorp = 0;
d123 3
a125 3
		if ((*errorp = in6_selectif(dstsock, opts, mopts, ro,
		    &ifp, rtableid)) != 0)
			return (NULL);
d137 2
a138 4
		    (ia6->ia6_flags & (IN6_IFF_ANYCAST | IN6_IFF_NOTREADY))) {
			*errorp = EADDRNOTAVAIL;
			return (NULL);
		}
d142 2
a143 1
		return (&pi->ipi6_addr);
d150 4
a153 2
	if (laddr && !IN6_IS_ADDR_UNSPECIFIED(laddr))
		return (laddr);
d162 3
a164 4
		if (ifp == NULL) {
			*errorp = ENXIO; /* XXX: better error? */
			return (0);
		}
d166 5
a170 5
		if (ia6 == 0) {
			*errorp = EADDRNOTAVAIL;
			return (0);
		}
		return (&ia6->ia_addr.sin6_addr);
d185 3
a187 4
		if (ifp == NULL) {
			*errorp = ENXIO; /* XXX: better error? */
			return (0);
		}
d189 5
a193 5
		if (ia6 == 0) {
			*errorp = EADDRNOTAVAIL;
			return (0);
		}
		return (&ia6->ia_addr.sin6_addr);
d211 5
a215 5
			if (ia6 == 0) {
				*errorp = EADDRNOTAVAIL;
				return (0);
			}
			return (&ia6->ia_addr.sin6_addr);
d238 5
a242 5
			if (ia6 == 0) {
				*errorp = EADDRNOTAVAIL;
				return (0);
			}
			return (&ia6->ia_addr.sin6_addr);
d288 5
a292 5
		if (ia6 == 0) {
			*errorp = EHOSTUNREACH;	/* no route */
			return (0);
		}
		return (&ia6->ia_addr.sin6_addr);
d295 1
a295 2
	*errorp = EADDRNOTAVAIL;
	return (0);
@


1.40
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.38 2014/03/12 14:15:09 mpi Exp $	*/
a288 19
#if 0
		/*
		 * xxx The followings are necessary? (kazu)
		 * I don't think so.
		 * It's for SO_DONTROUTE option in IPv4.(jinmei)
		 */
		if (ia6 == 0) {
			struct sockaddr_in6 sin6 = {sizeof(sin6), AF_INET6, 0};

			sin6->sin6_addr = *dst;

			ia6 = ifatoia6(ifa_ifwithdstaddr(sin6tosa(&sin6)));
			if (ia6 == 0)
				ia6 = ifatoia6(ifa_ifwithnet(sin6tosa(&sin6)));
			if (ia6 == 0)
				return (0);
			return (&ia6->ia_addr.sin6_addr);
		}
#endif /* 0 */
@


1.39
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d289 19
@


1.38
log
@ANSIfy a declaration, no object change.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.37 2014/01/07 17:07:46 mikeb Exp $	*/
a288 19
#if 0
		/*
		 * xxx The followings are necessary? (kazu)
		 * I don't think so.
		 * It's for SO_DONTROUTE option in IPv4.(jinmei)
		 */
		if (ia6 == 0) {
			struct sockaddr_in6 sin6 = {sizeof(sin6), AF_INET6, 0};

			sin6->sin6_addr = *dst;

			ia6 = ifatoia6(ifa_ifwithdstaddr(sin6tosa(&sin6)));
			if (ia6 == 0)
				ia6 = ifatoia6(ifa_ifwithnet(sin6tosa(&sin6)));
			if (ia6 == 0)
				return (0);
			return (&ia6->ia_addr.sin6_addr);
		}
#endif /* 0 */
@


1.37
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.36 2013/11/11 09:15:35 mpi Exp $	*/
d605 2
a606 5
in6_embedscope(in6, sin6, in6p, ifpp)
	struct in6_addr *in6;
	const struct sockaddr_in6 *sin6;
	struct inpcb *in6p;
	struct ifnet **ifpp;
@


1.36
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.35 2013/10/23 19:57:50 deraadt Exp $	*/
d231 2
a232 1
			rt = nd6_lookup(&sin6_next->sin6_addr, 1, NULL);
@


1.35
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.34 2013/10/21 08:42:25 phessler Exp $	*/
d333 2
d339 1
a339 1
		       ip6_sprintf(&dstsock->sin6_addr));
d342 2
a343 2
		       ip6_sprintf(&dstsock->sin6_addr),
		       dstsock->sin6_scope_id); /* for debug */
@


1.34
log
@Sprinkle a lot more IPv6 routing domains support in the kernel.

Mostly mechanical, setting and passing the rdomain and rtable correctly.
Not yet enabled.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.33 2013/10/17 16:27:46 bluhm Exp $	*/
a574 2
#define in6pcb		inpcb
#define in6p_hops	inp_hops	
d576 1
a576 1
in6_selecthlim(struct in6pcb *in6p, struct ifnet *ifp)
d578 2
a579 2
	if (in6p && in6p->in6p_hops >= 0)
		return (in6p->in6p_hops);
a584 2
#undef in6pcb
#undef in6p_hops
a605 2
#define in6p_outputopts	inp_outputopts6
#define in6p_moptions	inp_moptions6
d628 2
a629 2
		if (in6p && in6p->in6p_outputopts &&
		    (pi = in6p->in6p_outputopts->ip6po_pktinfo) &&
d636 3
a638 3
			   in6p->in6p_moptions &&
			   in6p->in6p_moptions->im6o_multicast_ifp) {
			ifp = in6p->in6p_moptions->im6o_multicast_ifp;
a653 2
#undef in6p_outputopts
#undef in6p_moptions
@


1.33
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.32 2013/05/31 15:04:24 bluhm Exp $	*/
d262 1
d449 1
@


1.32
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.31 2013/03/28 16:45:16 tedu Exp $	*/
a78 1
#include <netinet/in_var.h>
@


1.31
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.30 2013/03/28 00:32:11 bluhm Exp $	*/
d136 1
a136 2
		ia6 = ifatoia6(
		    ifa_ifwithaddr((struct sockaddr *)&sa6, rtableid));
d263 1
a263 1
			sa6 = (struct sockaddr_in6 *)&ro->ro_dst;
d439 1
a439 1
		     ((struct sockaddr *)(&ro->ro_dst))->sa_family != AF_INET6 ||
d449 1
a449 1
			sa6 = (struct sockaddr_in6 *)&ro->ro_dst;
@


1.30
log
@Unfortunately the satosin, sintosa, ifatoia, satosin6, sin6tosa,
ifatoia6 macros do not check the source type.  They just cast
anything.  Remove needless casts and do not use those macros if the
source type does not match.  Remove duplicate defines.
No binary change.  OK kettenis@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.29 2013/03/20 10:34:12 mpi Exp $	*/
a73 1
#include <sys/proc.h>
@


1.29
log
@Introduce if_get() to retrieve an interface descriptor pointer given
an interface index and replace all the redondant checks and accesses
to a global array by a call to this function.

With imputs from and ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.28 2013/03/04 14:42:25 bluhm Exp $	*/
d173 1
a173 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d197 1
a197 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d219 1
a219 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d245 1
a245 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d255 1
a255 1
		    !IN6_ARE_ADDR_EQUAL(&satosin6(&ro->ro_dst)->sin6_addr, dst))) {
d306 1
a306 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d313 1
a313 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d395 1
a395 1
		    !IN6_ARE_ADDR_EQUAL(&satosin6(&ron->ro_dst)->sin6_addr,
d401 1
a401 1
			*satosin6(&ron->ro_dst) = *sin6_next;
d442 1
a442 2
		     !IN6_ARE_ADDR_EQUAL(&satosin6(&ro->ro_dst)->sin6_addr,
		     dst))) {
@


1.28
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.27 2011/11/24 17:39:55 sperreault Exp $	*/
d106 1
a121 1
		struct ifnet *ifp = NULL;
d163 6
a168 3
		/* XXX boundary check is assumed to be already done. */
		ia6 = in6_ifawithscope(ifindex2ifnet[pi->ipi6_ifindex],
				       dst, rtableid);
d187 2
a188 7
		/*
		 * I'm not sure if boundary check for scope_id is done
		 * somewhere...
		 */
		if (dstsock->sin6_scope_id < 0 ||
		    if_indexlim <= dstsock->sin6_scope_id ||
		    !ifindex2ifnet[dstsock->sin6_scope_id]) {
d192 1
a192 2
		ia6 = in6_ifawithscope(ifindex2ifnet[dstsock->sin6_scope_id],
				       dst, rtableid);
d208 1
a208 1
		struct ifnet *ifp = mopts ? mopts->im6o_multicast_ifp : NULL;
d211 1
a211 1
			ifp = ifindex2ifnet[htons(dstsock->sin6_scope_id)];
d349 1
a349 2
		/* XXX boundary check is assumed to be already done. */
		ifp = ifindex2ifnet[pi->ipi6_ifindex];
d639 3
a641 1
			ifp = ifindex2ifnet[pi->ipi6_ifindex];
d649 2
a650 3
			/* boundary check */
			if (scopeid < 0 || if_indexlim <= scopeid ||
			    !ifindex2ifnet[scopeid])
a651 1
			ifp = ifindex2ifnet[scopeid];
d693 1
a693 2
			if (scopeid < 0 || if_indexlim <= scopeid ||
			    !ifindex2ifnet[scopeid])
@


1.27
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.26 2011/08/07 18:49:50 mikeb Exp $	*/
d107 1
a107 1
	struct in6_ifaddr *ia6 = 0;
d137 2
a138 2
		ia6 = (struct in6_ifaddr *)
		    ifa_ifwithaddr((struct sockaddr *)&sa6, rtableid);
@


1.26
log
@Several fixes for the IPV6_PKTINFO handling with sendmsg(2)

Verify that the address in the in6_pktinfo structure included
in the control message is unicast and configured on the local
host. Additional checks prevent from using non-routable
addresses and inactive interfaces.

Embed the scope identifier into the link local addresses as
required by the stack.  Do not force users to provide valid
interface index in the ipi6_ifindex but look it up in place
if needed.

ok bluhm, waived by deraadt for the release.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.25 2010/05/07 13:33:17 claudio Exp $	*/
d90 1
a90 1
    struct ip6_moptions *, struct route_in6 *, struct ifnet **);
d93 1
a93 1
    struct rtentry **, int);
d104 1
a104 1
    int *errorp)
d126 1
a126 1
		    &ifp)) != 0)
d138 1
a138 1
		    ifa_ifwithaddr((struct sockaddr *)&sa6, 0);
d165 1
a165 1
				       dst);
d195 1
a195 1
				       dst);
d217 1
a217 1
			ia6 = in6_ifawithscope(ifp, dst);
d239 2
a240 1
				ia6 = in6_ifawithscope(rt->rt_ifp, dst);
d288 2
a289 1
			ia6 = in6_ifawithscope(ro->ro_rt->rt_ifa->ifa_ifp, dst);
d326 1
a326 1
    struct rtentry **retrt, int norouteok)
d406 1
a406 1
			ron->ro_tableid = 0;	/* XXX rtableid */
d459 1
d521 2
a522 1
    struct ip6_moptions *mopts, struct route_in6 *ro, struct ifnet **retifp)
d528 1
a528 1
	    &rt, 1)) != 0)
d567 1
a567 1
    struct rtentry **retrt)
d570 2
a571 1
	return (selectroute(dstsock, opts, mopts, ro, retifp, retrt, 0));
@


1.25
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.24 2010/02/08 12:04:35 jsing Exp $	*/
d89 2
d115 3
a117 1
	 * use it.
d120 27
a146 1
	    !IN6_IS_ADDR_UNSPECIFIED(&pi->ipi6_addr))
d148 1
d514 44
@


1.24
log
@More destatic and ansification.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.22 2006/12/11 11:26:05 itojun Exp $	*/
d242 1
a242 2
				ro->ro_rt = rtalloc1(&((struct route *)ro)
						     ->ro_dst, 0, 0);
d244 1
a244 1
				rtalloc_mpath((struct route *)ro, NULL, 0);
d373 1
d426 1
a426 1
			rtalloc_mpath((struct route *)ro, NULL, 0);
@


1.23
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d89 3
a91 3
static int selectroute(struct sockaddr_in6 *, struct ip6_pktopts *,
	struct ip6_moptions *, struct route_in6 *, struct ifnet **,
	struct rtentry **, int);
d100 3
a102 7
in6_selectsrc(dstsock, opts, mopts, ro, laddr, errorp)
	struct sockaddr_in6 *dstsock;
	struct ip6_pktopts *opts;
	struct ip6_moptions *mopts;
	struct route_in6 *ro;
	struct in6_addr *laddr;
	int *errorp;
d291 4
a294 9
static int
selectroute(dstsock, opts, mopts, ro, retifp, retrt, norouteok)
	struct sockaddr_in6 *dstsock;
	struct ip6_pktopts *opts;
	struct ip6_moptions *mopts;
	struct route_in6 *ro;
	struct ifnet **retifp;
	struct rtentry **retrt;
	int norouteok;
d486 3
a488 7
in6_selectroute(dstsock, opts, mopts, ro, retifp, retrt)
	struct sockaddr_in6 *dstsock;
	struct ip6_pktopts *opts;
	struct ip6_moptions *mopts;
	struct route_in6 *ro;
	struct ifnet **retifp;
	struct rtentry **retrt;
d504 1
a504 3
in6_selecthlim(in6p, ifp)
	struct in6pcb *in6p;
	struct ifnet *ifp;
d597 2
a598 4
in6_recoverscope(sin6, in6, ifp)
	struct sockaddr_in6 *sin6;
	const struct in6_addr *in6;
	struct ifnet *ifp;
d634 1
a634 2
in6_clearscope(addr)
	struct in6_addr *addr;
@


1.22
log
@de-__P.  noted by Dries Schellekens
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.21 2006/12/09 01:12:28 itojun Exp $	*/
d229 2
a230 2
		if (ro->ro_rt &&
		    !IN6_ARE_ADDR_EQUAL(&satosin6(&ro->ro_dst)->sin6_addr, dst)) {
@


1.21
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.20 2006/11/17 01:11:23 itojun Exp $	*/
d89 1
a89 1
static int selectroute __P((struct sockaddr_in6 *, struct ip6_pktopts *,
d91 1
a91 1
	struct rtentry **, int));
@


1.20
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.19 2006/06/18 11:47:46 pascoe Exp $	*/
d89 4
d293 212
@


1.19
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.18 2006/06/16 16:49:40 henning Exp $	*/
d144 3
a146 3
	 * a multicast address, and if the outgoing interface is specified
	 * by the sin6_scope_id filed, use an address associated with the
	 * interface.
d151 2
a152 2
	if ((IN6_IS_ADDR_LINKLOCAL(dst) || IN6_IS_ADDR_MC_LINKLOCAL(dst)) &&
	    dstsock->sin6_scope_id) {
a175 2
	 * There is a sanity check here; if the destination has node-local
	 * scope, the outgoing interfacde should be a loopback address.
d182 2
a183 3
		if (ifp == NULL && IN6_IS_ADDR_MC_NODELOCAL(dst)) {
			ifp = lo0ifp;
		}
d352 1
a352 1
	if (IN6_IS_SCOPE_LINKLOCAL(in6)) {
d411 1
a411 1
	if (IN6_IS_SCOPE_LINKLOCAL(in6)) {
d438 1
a438 1
	if (IN6_IS_SCOPE_LINKLOCAL(addr))
@


1.18
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.17 2005/09/19 19:38:34 brad Exp $	*/
d248 1
a248 1
				rtalloc((struct route *)ro);
@


1.17
log
@sin6_scope_id maps to interface indices for link local addresses only!
(unlikely to be used with other scopes for now, but we should be
correct anyway)

From drochner NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.16 2003/12/10 03:30:21 itojun Exp $	*/
d246 1
a246 1
						     ->ro_dst, 0);
@


1.16
log
@use if_indexlim (instead of if_index) and ifindex2ifnet[x] != NULL
to check if interface exists, as (1) if_index will have different meaning
(2) ifindex2ifnet could become NULL when interface gets destroyed,
when we introduce dynamically-created interfaces.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.15 2003/06/02 23:28:15 millert Exp $	*/
d151 1
a151 1
	if ((IN6_IS_ADDR_LINKLOCAL(dst) || IN6_IS_ADDR_MULTICAST(dst)) &&
@


1.15
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.14 2002/09/11 03:15:36 itojun Exp $	*/
d158 2
a159 1
		    if_index < dstsock->sin6_scope_id) {
d374 2
a375 1
			if (scopeid < 0 || if_index < scopeid)
d421 2
a422 1
			if (scopeid < 0 || if_index < scopeid)
@


1.14
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.13 2002/05/29 07:54:59 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.13
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.12 2002/05/29 01:45:52 itojun Exp $	*/
d121 1
a121 1
		return(&pi->ipi6_addr);
d128 1
a128 1
		return(laddr);
d141 1
a141 1
			return(0);
d143 1
a143 1
		return(&satosin6(&ia6->ia_addr)->sin6_addr);
d164 1
a164 1
			return(0);
d170 1
a170 1
			return(0);
d172 1
a172 1
		return(&satosin6(&ia6->ia_addr)->sin6_addr);
d195 1
a195 1
				return(0);
d197 1
a197 1
			return(&satosin6(&ia6->ia_addr)->sin6_addr);
d220 1
a220 1
				return(0);
d222 1
a222 1
			return(&satosin6(&ia6->ia_addr)->sin6_addr);
d282 2
a283 2
				return(0);
			return(&satosin6(&ia6->ia_addr)->sin6_addr);
d288 1
a288 1
			return(0);
d290 1
a290 1
		return(&satosin6(&ia6->ia_addr)->sin6_addr);
d294 1
a294 1
	return(0);
d312 1
a312 1
		return(in6p->in6p_hops);
d314 1
a314 1
		return(ND_IFINFO(ifp)->chlim);
d316 1
a316 1
		return(ip6_defhlim);
@


1.12
log
@rm obsolete comment
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.11 2001/03/30 11:09:00 itojun Exp $	*/
d314 1
a314 1
		return(nd_ifinfo[ifp->if_index].chlim);
@


1.11
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.10 2001/02/16 14:45:12 itojun Exp $	*/
a436 1
 * XXX: currently used for bsdi4 only as a supplement function.
@


1.11.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.11 2001/03/30 11:09:00 itojun Exp $	*/
d314 1
a314 1
		return(ND_IFINFO(ifp)->chlim);
d437 1
@


1.11.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.11.6.1 2002/06/11 03:31:37 art Exp $	*/
d121 1
a121 1
		return (&pi->ipi6_addr);
d128 1
a128 1
		return (laddr);
d141 1
a141 1
			return (0);
d143 1
a143 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d164 1
a164 1
			return (0);
d170 1
a170 1
			return (0);
d172 1
a172 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d195 1
a195 1
				return (0);
d197 1
a197 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d220 1
a220 1
				return (0);
d222 1
a222 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d282 2
a283 2
				return (0);
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d288 1
a288 1
			return (0);
d290 1
a290 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d294 1
a294 1
	return (0);
d312 1
a312 1
		return (in6p->in6p_hops);
d314 1
a314 1
		return (ND_IFINFO(ifp)->chlim);
d316 1
a316 1
		return (ip6_defhlim);
@


1.10
log
@amove in6_{embed,recover}scope prototypes to in6_var.h (kernel only).
add in6_clearscope.  sync better with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.9 2001/02/06 00:22:23 mickey Exp $	*/
a424 6
#ifndef FAKE_LOOPBACK_IF
			if (ifp && (ifp->if_flags & IFF_LOOPBACK) == 0 &&
			    ifp->if_index != scopeid) {
				return ENXIO;
			}
#else
a426 1
#endif
@


1.9
log
@allow changing number of loopbacks in ukc.
change rest of the code to use lo0ifp pointing
to the corresponding struct ifnet.
itojun@@ and niklas@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_src.c,v 1.8 2000/06/21 09:07:24 itojun Exp $	*/
/*	$KAME: in6_src.c,v 1.27 2000/06/21 08:07:13 itojun Exp $	*/
d94 1
a94 1
 * Return an IPv6 address, which is the most appropriate for given
d96 1
a96 1
 * If necessary, this function lookups the routing table and return
d238 2
d242 5
a246 4
			ro->ro_dst.sin6_family = AF_INET6;
			ro->ro_dst.sin6_len = sizeof(struct sockaddr_in6);
			ro->ro_dst.sin6_addr = *dst;
			ro->ro_dst.sin6_scope_id = dstsock->sin6_scope_id;
d304 2
d307 2
a308 2
in6_selecthlim(inp, ifp)
	struct inpcb *inp;
d311 2
a312 2
	if (inp && inp->inp_hops >= 0)
		return(inp->inp_hops);
d318 2
d341 2
d365 2
a366 2
		if (in6p && in6p->inp_outputopts6 &&
		    (pi = in6p->inp_outputopts6->ip6po_pktinfo) &&
d371 3
a373 3
			   in6p->inp_moptions6 &&
			   in6p->inp_moptions6->im6o_multicast_ifp) {
			ifp = in6p->inp_moptions6->im6o_multicast_ifp;
d390 2
d440 12
@


1.8
log
@correct in6_recoverscope() for multicast loopback case.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.7 2000/06/18 17:02:59 itojun Exp $	*/
a92 4
#include "loop.h"

extern struct ifnet loif[NLOOP];

d188 1
a188 1
			ifp = &loif[0];
@


1.7
log
@lookup routing table for multicast too, to allow scoped IPv6 multicast
to go out of the node.  "ping6 ff02::1%wi0" will work fine with this
(and should correct route6d behavior too)

this is major issue for IPv6.  i think this needs to become an erratta entry.
sorry about this.
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_src.c,v 1.6 2000/06/18 04:49:32 itojun Exp $	*/
/*	$KAME: in6_src.c,v 1.26 2000/06/18 06:31:40 itojun Exp $	*/
d418 6
d426 1
@


1.6
log
@don't panic even if in6p == NULL.
(this should have been there with tcp_ident change... sorry)
@
text
@d1 2
a2 2
/*	$OpenBSD: in6_src.c,v 1.5 2000/06/13 10:12:01 itojun Exp $	*/
/*	$KAME: in6_src.c,v 1.23 2000/06/12 08:15:27 itojun Exp $	*/
d247 5
a251 1
			if (!IN6_IS_ADDR_MULTICAST(dst)) {
@


1.5
log
@allow link-local IPv6 addres in in6_pcbbind.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.4 2000/02/28 11:55:22 itojun Exp $	*/
d356 1
a356 1
		if (in6p->inp_outputopts6 &&
d361 3
a363 3
		} else if (IN6_IS_ADDR_MULTICAST(in6)
			&& in6p->inp_moptions6
			&& in6p->inp_moptions6->im6o_multicast_ifp) {
@


1.4
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 1
/*	$OpenBSD: in6_src.c,v 1.3 2000/02/07 06:09:10 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d296 1
a296 1
 * 1. Hoplimit valued specified via ioctl.
d312 110
@


1.4.2.1
log
@pull in patch from current:
Fix (itojun):
lookup routing table for multicast too, to allow scoped IPv6 multicast
to go out of the node.  "ping6 ff02::1%wi0" will work fine with this
(and should correct route6d behavior too)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.4 2000/02/28 11:55:22 itojun Exp $	*/
d246 1
a246 5
			ro->ro_dst.sin6_scope_id = dstsock->sin6_scope_id;
			if (IN6_IS_ADDR_MULTICAST(dst)) {
				ro->ro_rt = rtalloc1(&((struct route *)ro)
						     ->ro_dst, 0);
			} else {
@


1.3
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
a88 3
#if 0
#include <netinet6/in6_pcb.h>
#endif
@


1.3.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 3
@


1.3.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: in6_src.c,v 1.11 2001/03/30 11:09:00 itojun Exp $	*/
/*	$KAME: in6_src.c,v 1.36 2001/02/06 04:08:17 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d92 4
d97 1
a97 1
 * Return an IPv6 address, which is the most appropriate for a given
d99 1
a99 1
 * If necessary, this function lookups the routing table and returns
d191 1
a191 1
			ifp = lo0ifp;
a240 2
			struct sockaddr_in6 *sa6;

d243 4
a246 9
			sa6 = (struct sockaddr_in6 *)&ro->ro_dst;
			sa6->sin6_family = AF_INET6;
			sa6->sin6_len = sizeof(struct sockaddr_in6);
			sa6->sin6_addr = *dst;
			sa6->sin6_scope_id = dstsock->sin6_scope_id;
			if (IN6_IS_ADDR_MULTICAST(dst)) {
				ro->ro_rt = rtalloc1(&((struct route *)ro)
						     ->ro_dst, 0);
			} else {
d295 1
a295 1
 * 1. Hoplimit value specified via ioctl.
a299 2
#define in6pcb		inpcb
#define in6p_hops	inp_hops	
d301 2
a302 2
in6_selecthlim(in6p, ifp)
	struct in6pcb *in6p;
d305 2
a306 2
	if (in6p && in6p->in6p_hops >= 0)
		return(in6p->in6p_hops);
a310 128
}
#undef in6pcb
#undef in6p_hops

/*
 * generate kernel-internal form (scopeid embedded into s6_addr16[1]).
 * If the address scope of is link-local, embed the interface index in the
 * address.  The routine determines our precedence
 * between advanced API scope/interface specification and basic API
 * specification.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 *
 * XXX actually, it is over-specification to return ifp against sin6_scope_id.
 * there can be multiple interfaces that belong to a particular scope zone
 * (in specification, we have 1:N mapping between a scope zone and interfaces).
 * we may want to change the function to return something other than ifp.
 */
int
in6_embedscope(in6, sin6, in6p, ifpp)
	struct in6_addr *in6;
	const struct sockaddr_in6 *sin6;
	struct inpcb *in6p;
#define in6p_outputopts	inp_outputopts6
#define in6p_moptions	inp_moptions6
	struct ifnet **ifpp;
{
	struct ifnet *ifp = NULL;
	u_int32_t scopeid;

	*in6 = sin6->sin6_addr;
	scopeid = sin6->sin6_scope_id;
	if (ifpp)
		*ifpp = NULL;

	/*
	 * don't try to read sin6->sin6_addr beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */

	if (IN6_IS_SCOPE_LINKLOCAL(in6)) {
		struct in6_pktinfo *pi;

		/*
		 * KAME assumption: link id == interface id
		 */

		if (in6p && in6p->in6p_outputopts &&
		    (pi = in6p->in6p_outputopts->ip6po_pktinfo) &&
		    pi->ipi6_ifindex) {
			ifp = ifindex2ifnet[pi->ipi6_ifindex];
			in6->s6_addr16[1] = htons(pi->ipi6_ifindex);
		} else if (in6p && IN6_IS_ADDR_MULTICAST(in6) &&
			   in6p->in6p_moptions &&
			   in6p->in6p_moptions->im6o_multicast_ifp) {
			ifp = in6p->in6p_moptions->im6o_multicast_ifp;
			in6->s6_addr16[1] = htons(ifp->if_index);
		} else if (scopeid) {
			/* boundary check */
			if (scopeid < 0 || if_index < scopeid)
				return ENXIO;  /* XXX EINVAL? */
			ifp = ifindex2ifnet[scopeid];
			/*XXX assignment to 16bit from 32bit variable */
			in6->s6_addr16[1] = htons(scopeid & 0xffff);
		}

		if (ifpp)
			*ifpp = ifp;
	}

	return 0;
}
#undef in6p_outputopts
#undef in6p_moptions

/*
 * generate standard sockaddr_in6 from embedded form.
 * touches sin6_addr and sin6_scope_id only.
 *
 * this function should be nuked in the future, when we get rid of
 * embedded scopeid thing.
 */
int
in6_recoverscope(sin6, in6, ifp)
	struct sockaddr_in6 *sin6;
	const struct in6_addr *in6;
	struct ifnet *ifp;
{
	u_int32_t scopeid;

	sin6->sin6_addr = *in6;

	/*
	 * don't try to read *in6 beyond here, since the caller may
	 * ask us to overwrite existing sockaddr_in6
	 */

	sin6->sin6_scope_id = 0;
	if (IN6_IS_SCOPE_LINKLOCAL(in6)) {
		/*
		 * KAME assumption: link id == interface id
		 */
		scopeid = ntohs(sin6->sin6_addr.s6_addr16[1]);
		if (scopeid) {
			/* sanity check */
			if (scopeid < 0 || if_index < scopeid)
				return ENXIO;
			if (ifp && ifp->if_index != scopeid)
				return ENXIO;
			sin6->sin6_addr.s6_addr16[1] = 0;
			sin6->sin6_scope_id = scopeid;
		}
	}

	return 0;
}

/*
 * just clear the embedded scope identifer.
 * XXX: currently used for bsdi4 only as a supplement function.
 */
void
in6_clearscope(addr)
	struct in6_addr *addr;
{
	if (IN6_IS_SCOPE_LINKLOCAL(addr))
		addr->s6_addr16[1] = 0;
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 1
a121 1
		return (&pi->ipi6_addr);
d128 1
a128 1
		return (laddr);
d141 1
a141 1
			return (0);
d143 1
a143 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d164 1
a164 1
			return (0);
d170 1
a170 1
			return (0);
d172 1
a172 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d195 1
a195 1
				return (0);
d197 1
a197 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d220 1
a220 1
				return (0);
d222 1
a222 1
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d282 2
a283 2
				return (0);
			return (&satosin6(&ia6->ia_addr)->sin6_addr);
d288 1
a288 1
			return (0);
d290 1
a290 1
		return (&satosin6(&ia6->ia_addr)->sin6_addr);
d294 1
a294 1
	return (0);
d312 1
a312 1
		return (in6p->in6p_hops);
d314 1
a314 1
		return (ND_IFINFO(ifp)->chlim);
d316 1
a316 1
		return (ip6_defhlim);
d437 1
@


1.3.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.3.2.3 2003/03/28 00:41:29 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.3.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 2
		    if_indexlim <= dstsock->sin6_scope_id ||
		    !ifindex2ifnet[dstsock->sin6_scope_id]) {
d373 1
a373 2
			if (scopeid < 0 || if_indexlim <= scopeid ||
			    !ifindex2ifnet[scopeid])
d419 1
a419 2
			if (scopeid < 0 || if_indexlim <= scopeid ||
			    !ifindex2ifnet[scopeid])
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_src.c,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d88 1
a88 1
#include <netinet6/ip6.h>
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 4
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif

a94 1
#ifndef __bsdi__
d96 1
a96 2
#endif
#if defined(__NetBSD__) || defined(__OpenBSD__)
a97 1
#endif
a191 8
#ifdef __bsdi__
#if _BSDI_VERSION >= 199802
		extern struct ifnet *loifp;
#else
		extern struct ifnet loif;
		struct ifnet *loifp = &loif;
#endif
#endif
a193 3
#ifdef __bsdi__
			ifp = loifp;
#else
a194 1
#endif
d249 1
a249 13
			if (IN6_IS_ADDR_MULTICAST(dst)) {
#ifdef __FreeBSD__
				ro->ro_rt = rtalloc1(&((struct route *)ro)
						     ->ro_dst, 0, 0UL);
#endif /*__FreeBSD__*/
#if defined(__bsdi__) || defined(__NetBSD__)
				ro->ro_rt = rtalloc1(&((struct route *)ro)
						     ->ro_dst, 0);
#endif /*__bsdi__*/
			} else {
#ifdef __FreeBSD__
				rtcalloc((struct route *)ro);
#else
a250 1
#endif
@

