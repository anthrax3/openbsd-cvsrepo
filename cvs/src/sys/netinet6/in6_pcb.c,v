head	1.100;
access;
symbols
	OPENBSD_6_1:1.97.0.4
	OPENBSD_6_1_BASE:1.97
	OPENBSD_6_0:1.95.0.2
	OPENBSD_6_0_BASE:1.95
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.69.0.4
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.67.0.2
	OPENBSD_5_7_BASE:1.67
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.56.0.2
	OPENBSD_5_4_BASE:1.56
	OPENBSD_5_3:1.50.0.6
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.50.0.4
	OPENBSD_5_2_BASE:1.50
	OPENBSD_5_1_BASE:1.50
	OPENBSD_5_1:1.50.0.2
	OPENBSD_5_0:1.49.0.10
	OPENBSD_5_0_BASE:1.49
	OPENBSD_4_9:1.49.0.8
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.49.0.6
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.48.0.2
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.43.0.12
	OPENBSD_4_3_BASE:1.43
	OPENBSD_4_2:1.43.0.10
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.43.0.8
	OPENBSD_4_1_BASE:1.43
	OPENBSD_4_0:1.43.0.6
	OPENBSD_4_0_BASE:1.43
	OPENBSD_3_9:1.43.0.4
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.42.0.6
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.4
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.2
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.32
	UBC:1.26.0.4
	UBC_BASE:1.26
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	OPENBSD_2_9_BASE:1.25
	OPENBSD_2_9:1.25.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.4
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5;
locks; strict;
comment	@ * @;


1.100
date	2017.08.11.19.53.02;	author bluhm;	state Exp;
branches;
next	1.99;
commitid	ZSLEQCt6cCaCd9uI;

1.99
date	2017.08.04.18.16.42;	author bluhm;	state Exp;
branches;
next	1.98;
commitid	QSvbBHviN55gYPsY;

1.98
date	2017.05.13.17.42.55;	author bluhm;	state Exp;
branches;
next	1.97;
commitid	gDw2L5Ia2WLwp3z8;

1.97
date	2017.03.07.16.59.40;	author bluhm;	state Exp;
branches;
next	1.96;
commitid	FWorR2yatnd5ZrSk;

1.96
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.95;
commitid	nbCHuHn2E9uBfKJT;

1.95
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.94;
commitid	Cm0qxR09oTCkXjXZ;

1.94
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.93;
commitid	jodmGXAB42f8N6nf;

1.93
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.92;
commitid	LxUFHuffW7GZZ01f;

1.92
date	2016.04.11.21.24.29;	author vgross;	state Exp;
branches;
next	1.91;
commitid	KN7g5vtebtPTCcjK;

1.91
date	2016.04.05.21.21.41;	author vgross;	state Exp;
branches;
next	1.90;
commitid	hj4FrKNwbP0WyZIh;

1.90
date	2016.03.30.13.02.22;	author vgross;	state Exp;
branches;
next	1.89;
commitid	SCVNHkAMbhnWh0Dl;

1.89
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.88;
commitid	iMWKOVeEybjVAEfv;

1.88
date	2016.03.21.21.21.35;	author vgross;	state Exp;
branches;
next	1.87;
commitid	kJec2D6LBVBbvezW;

1.87
date	2016.03.20.01.26.30;	author jca;	state Exp;
branches;
next	1.86;
commitid	GLsXKfQ2x1mJBQlZ;

1.86
date	2016.03.19.23.59.49;	author vgross;	state Exp;
branches;
next	1.85;
commitid	RAixKEXoKbQFRWrg;

1.85
date	2016.03.12.09.25.37;	author vgross;	state Exp;
branches;
next	1.84;
commitid	xZkfuhhTAfgA3ISo;

1.84
date	2015.12.18.22.25.16;	author vgross;	state Exp;
branches
	1.84.2.1;
next	1.83;
commitid	y6SQx88Uf5pOjMYS;

1.83
date	2015.12.02.22.13.44;	author vgross;	state Exp;
branches;
next	1.82;
commitid	Qc8hTbFRvzRyD1WZ;

1.82
date	2015.10.24.16.08.48;	author mpi;	state Exp;
branches;
next	1.81;
commitid	xFxvBxiFybIsZNMc;

1.81
date	2015.10.20.18.04.03;	author deraadt;	state Exp;
branches;
next	1.80;
commitid	cbpu7TMBEmsrNLlG;

1.80
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.79;
commitid	aMzCQ7pRC6VLKZyx;

1.79
date	2015.10.19.08.49.14;	author vgross;	state Exp;
branches;
next	1.78;
commitid	OkNHrnqnaRaotlx9;

1.78
date	2015.10.18.00.04.43;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	19QhHGSTTsDpRV7q;

1.77
date	2015.10.15.10.27.18;	author vgross;	state Exp;
branches;
next	1.76;
commitid	2bWmzbWLuzqWVxfo;

1.76
date	2015.10.09.01.10.27;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	av6ZVErLSWkVP5Zz;

1.75
date	2015.09.22.09.34.39;	author vgross;	state Exp;
branches;
next	1.74;
commitid	S3cAlx4uzc9zehGV;

1.74
date	2015.09.11.15.29.47;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	0NZe9BgjJety4Dtk;

1.73
date	2015.09.11.08.22.31;	author guenther;	state Exp;
branches;
next	1.72;
commitid	Lqreadw8v5IPAc0L;

1.72
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.71;
commitid	sTEWfQrcV5GjIWc0;

1.71
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.70;
commitid	PcRGyy4jlpJbKkXz;

1.70
date	2015.08.22.20.18.50;	author deraadt;	state Exp;
branches;
next	1.69;
commitid	6NDuzTPjBp2GqkfQ;

1.69
date	2015.07.19.02.35.35;	author deraadt;	state Exp;
branches
	1.69.4.1;
next	1.68;
commitid	CJwjm9NDWu6nJ6ES;

1.68
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.67;
commitid	4Ro7ulidQXNcMvmM;

1.67
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches
	1.67.2.1;
next	1.66;
commitid	t9FBKDfc4VDxpEy2;

1.66
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.65;
commitid	Z1vcFtHO8wRH0yRt;

1.65
date	2014.08.21.11.54.00;	author mpi;	state Exp;
branches;
next	1.64;
commitid	cZvIRysBPo2ZYlUZ;

1.64
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.63;
commitid	DQakU8LLWV6Iwx84;

1.63
date	2014.06.03.13.32.24;	author mpi;	state Exp;
branches;
next	1.62;
commitid	2Ufy37wyO5neufOK;

1.62
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.61;

1.61
date	2014.04.16.13.04.38;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2014.04.06.16.49.40;	author chrisz;	state Exp;
branches;
next	1.59;

1.59
date	2014.01.08.22.38.29;	author bluhm;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.56;

1.56
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.55;

1.55
date	2013.05.31.13.15.53;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.10.08.50.59;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.25.14.40.57;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.50;

1.50
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.46;

1.46
date	2008.05.23.15.51.12;	author thib;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.19.14.58.29;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2008.04.18.06.42.20;	author djm;	state Exp;
branches;
next	1.43;

1.43
date	2005.06.24.07.57.24;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.06.21.05.57;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.05.04.39.57;	author itojun;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.21.15.12.27;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.04.22.39.38;	author markus;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.28.23.17.45;	author cloder;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.15.20.32.20;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.15.19.16.10;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2002.09.04.07.26.53;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.20.21.50.56;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2002.06.09.00.22.24;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2002.01.21.05.33.14;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2001.06.05.02.31.37;	author deraadt;	state Exp;
branches
	1.26.4.1;
next	1.25;

1.25
date	2001.02.16.16.00.56;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2001.02.16.08.22.05;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.08.18.46.23;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.06.16.07.45;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.12.21.00.54.11;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.10.11.09.14.14;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.06.18.18.07.49;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.18.18.00.18;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.18.17.56.42;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.18.17.27.05;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.13.10.12.01;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.03.13.04.39;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.28.23.58.51;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.27.09.23.21;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.21.11.42.25;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.28.11.55.22;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.07.06.09.10;	author itojun;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.12.10.08.53.17;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.12.08.11.28.35;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	99.03.24.02.28.22;	author cmetz;	state Exp;
branches;
next	1.4;

1.4
date	99.03.09.05.31.52;	author cmetz;	state Exp;
branches;
next	1.3;

1.3
date	99.02.24.04.36.41;	author cmetz;	state Exp;
branches;
next	1.2;

1.2
date	99.01.07.05.44.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.01.06.23.26.55;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2000.03.02.07.04.45;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.05.14.22.40.17;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2001.07.04.10.55.20;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2003.06.07.11.06.09;	author ho;	state Exp;
branches;
next	1.9.2.8;

1.9.2.8
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.9.2.9;

1.9.2.9
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.26.4.1
date	2002.01.31.22.55.46;	author niklas;	state Exp;
branches;
next	1.26.4.2;

1.26.4.2
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.26.4.3;

1.26.4.3
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.26.4.4;

1.26.4.4
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.67.2.1
date	2016.03.16.09.26.13;	author vgross;	state Exp;
branches;
next	;
commitid	QzqLM83mhlnOhiMu;

1.69.4.1
date	2016.03.16.10.03.05;	author vgross;	state Exp;
branches;
next	;
commitid	k5C4GbDmZW2gkGJW;

1.84.2.1
date	2016.03.24.05.02.53;	author jsg;	state Exp;
branches;
next	;
commitid	2YBobhUsn73qIAzL;


desc
@@


1.100
log
@Validate sockaddr from userland in central functions.  This results
in common checks for unix, inet, inet6 instead of partial checks
here and there.  Some checks are already done at a higher layer,
but better be paranoid with user input.
OK claudio@@ millert@@
@
text
@/*	$OpenBSD: in6_pcb.c,v 1.99 2017/08/04 18:16:42 bluhm Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 *
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 *	This product includes software developed at the Information
 *	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */

/*
 * Copyright (c) 1982, 1986, 1990, 1993, 1995
 *	Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/pledge.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/in_pcb.h>
#include <netinet/ip_var.h>

#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>

/*
 * External globals
 */

/*
 * Globals
 */

struct in6_addr zeroin6_addr;

/*
 * Keep separate inet6ctlerrmap, because I may remap some of these.
 * I also put it here, because, quite frankly, it belongs here, not in
 * ip{v6,}_input().
 */
#if 0
u_char inet6ctlerrmap[PRC_NCMDS] = {
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	EHOSTUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
};
#endif

int
in6_pcbaddrisavail(struct inpcb *inp, struct sockaddr_in6 *sin6, int wild,
    struct proc *p)
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_short lport = sin6->sin6_port;
	int reuseport = (so->so_options & SO_REUSEPORT);

	wild |= INPLOOKUP_IPV6;
	/* KAME hack: embed scopeid */
	if (in6_embedscope(&sin6->sin6_addr, sin6, inp) != 0)
		return (EINVAL);
	/* this must be cleared for ifa_ifwithaddr() */
	sin6->sin6_scope_id = 0;
	/* reject IPv4 mapped address, we have no support for it */
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
		return (EADDRNOTAVAIL);

	if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
		/*
		 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
		 * allow complete duplication of binding if
		 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
		 * and a multicast address is bound on both
		 * new and duplicated sockets.
		 */
		if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
			reuseport = SO_REUSEADDR | SO_REUSEPORT;
	} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
		struct ifaddr *ifa = NULL;

		sin6->sin6_port = 0;  /*
				       * Yechhhh, because of upcoming
				       * call to ifa_ifwithaddr(), which
				       * does bcmp's over the PORTS as
				       * well.  (What about flow?)
				       */
		sin6->sin6_flowinfo = 0;
		if (!(so->so_options & SO_BINDANY) &&
		    (ifa = ifa_ifwithaddr(sin6tosa(sin6),
		    inp->inp_rtableid)) == NULL)
			return (EADDRNOTAVAIL);
		sin6->sin6_port = lport;

		/*
		 * bind to an anycast address might accidentally
		 * cause sending a packet with an anycast source
		 * address, so we forbid it.
		 *
		 * We should allow to bind to a deprecated address,
		 * since the application dare to use it.
		 * But, can we assume that they are careful enough
		 * to check if the address is deprecated or not?
		 * Maybe, as a safeguard, we should have a setsockopt
		 * flag to control the bind(2) behavior against
		 * deprecated addresses (default: forbid bind(2)).
		 */
		if (ifa && ifatoia6(ifa)->ia6_flags & (IN6_IFF_ANYCAST|
		    IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED|IN6_IFF_DETACHED))
			return (EADDRNOTAVAIL);
	}
	if (lport) {
		struct inpcb *t;

		if (so->so_euid) {
			t = in_pcblookup_local(table,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
			    inp->inp_rtableid);
			if (t && (so->so_euid != t->inp_socket->so_euid))
				return (EADDRINUSE);
		}
		t = in_pcblookup_local(table,
		    (struct in_addr *)&sin6->sin6_addr, lport,
		    wild, inp->inp_rtableid);
		if (t && (reuseport & t->inp_socket->so_options) == 0)
			return (EADDRINUSE);
	}
	return (0);
}

/*
 * Connect from a socket to a specified address.
 * Both address and port must be specified in argument sin6.
 * Eventually, flow labels will have to be dealt with here, as well.
 *
 * If don't have a local address for this socket yet,
 * then pick one.
 */
int
in6_pcbconnect(struct inpcb *inp, struct mbuf *nam)
{
	struct in6_addr *in6a = NULL;
	struct sockaddr_in6 *sin6;
	int error;
	struct sockaddr_in6 tmp;

	if ((error = in6_nam2sin6(nam, &sin6)))
		return (error);
	if (sin6->sin6_port == 0)
		return (EADDRNOTAVAIL);
	/* reject IPv4 mapped address, we have no support for it */
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
		return (EADDRNOTAVAIL);

	/* protect *sin6 from overwrites */
	tmp = *sin6;
	sin6 = &tmp;

	/* KAME hack: embed scopeid */
	if (in6_embedscope(&sin6->sin6_addr, sin6, inp) != 0)
		return EINVAL;
	/* this must be cleared for ifa_ifwithaddr() */
	sin6->sin6_scope_id = 0;

	/* Source address selection. */
	/*
	 * XXX: in6_selectsrc might replace the bound local address
	 * with the address specified by setsockopt(IPV6_PKTINFO).
	 * Is it the intended behavior?
	 */
	error = in6_pcbselsrc(&in6a, sin6, inp, inp->inp_outputopts6);
	if (error)
		return (error);

	inp->inp_ipv6.ip6_hlim = (u_int8_t)in6_selecthlim(inp);

	if (in6_pcbhashlookup(inp->inp_table, &sin6->sin6_addr, sin6->sin6_port,
	    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ? in6a : &inp->inp_laddr6,
	    inp->inp_lport, inp->inp_rtableid) != NULL) {
		return (EADDRINUSE);
	}

	KASSERT(IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) || inp->inp_lport);

	if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) {
		if (inp->inp_lport == 0) {
			error = in_pcbbind(inp, NULL, curproc);
			if (error)
				return (error);
			if (in6_pcbhashlookup(inp->inp_table, &sin6->sin6_addr,
			    sin6->sin6_port, in6a, inp->inp_lport,
			    inp->inp_rtableid) != NULL) {
				inp->inp_lport = 0;
				return (EADDRINUSE);
			}
		}
		inp->inp_laddr6 = *in6a;
	}
	inp->inp_faddr6 = sin6->sin6_addr;
	inp->inp_fport = sin6->sin6_port;
	inp->inp_flowinfo &= ~IPV6_FLOWLABEL_MASK;
	if (ip6_auto_flowlabel)
		inp->inp_flowinfo |=
		    (htonl(ip6_randomflowlabel()) & IPV6_FLOWLABEL_MASK);
	in_pcbrehash(inp);
	return (0);
}

/*
 * Pass some notification to all connections of a protocol
 * associated with address dst.  The local address and/or port numbers
 * may be specified to limit the search.  The "usual action" will be
 * taken, depending on the ctlinput cmd.  The caller must filter any
 * cmds that are uninteresting (e.g., no error in the map).
 * Call the protocol specific routine (if any) to report
 * any errors for each matching socket.
 *
 * Also perform input-side security policy check
 *    once PCB to be notified has been located.
 */
int
in6_pcbnotify(struct inpcbtable *head, struct sockaddr_in6 *dst,
    uint fport_arg, const struct sockaddr_in6 *src, uint lport_arg,
    u_int rdomain, int cmd, void *cmdarg, void (*notify)(struct inpcb *, int))
{
	struct inpcb *inp, *ninp;
	u_short fport = fport_arg, lport = lport_arg;
	struct sockaddr_in6 sa6_src;
	int errno, nmatch = 0;
	u_int32_t flowinfo;

	NET_ASSERT_LOCKED();

	if ((unsigned)cmd >= PRC_NCMDS)
		return (0);

	if (IN6_IS_ADDR_UNSPECIFIED(&dst->sin6_addr))
		return (0);
	if (IN6_IS_ADDR_V4MAPPED(&dst->sin6_addr)) {
#ifdef DIAGNOSTIC
		printf("Huh?  Thought in6_pcbnotify() never got "
		       "called with mapped!\n");
#endif
		return (0);
	}

	rdomain = rtable_l2(rdomain);
	/*
	 * note that src can be NULL when we get notify by local fragmentation.
	 */
	sa6_src = (src == NULL) ? sa6_any : *src;
	flowinfo = sa6_src.sin6_flowinfo;

	/*
	 * Redirects go to all references to the destination,
	 * and use in_rtchange to invalidate the route cache.
	 * Dead host indications: also use in_rtchange to invalidate
	 * the cache, and deliver the error to all the sockets.
	 * Otherwise, if we have knowledge of the local port and address,
	 * deliver only to that socket.
	 */
	if (PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD) {
		fport = 0;
		lport = 0;
		sa6_src.sin6_addr = in6addr_any;

		if (cmd != PRC_HOSTDEAD)
			notify = in_rtchange;
	}
	errno = inet6ctlerrmap[cmd];

	TAILQ_FOREACH_SAFE(inp, &head->inpt_queue, inp_queue, ninp) {
		if ((inp->inp_flags & INP_IPV6) == 0)
			continue;

		/*
		 * Under the following condition, notify of redirects
		 * to the pcb, without making address matches against inpcb.
		 * - redirect notification is arrived.
		 * - the inpcb is unconnected.
		 * - the inpcb is caching !RTF_HOST routing entry.
		 * - the ICMPv6 notification is from the gateway cached in the
		 *   inpcb.  i.e. ICMPv6 notification is from nexthop gateway
		 *   the inpcb used very recently.
		 *
		 * This is to improve interaction between netbsd/openbsd
		 * redirect handling code, and inpcb route cache code.
		 * without the clause, !RTF_HOST routing entry (which carries
		 * gateway used by inpcb right before the ICMPv6 redirect)
		 * will be cached forever in unconnected inpcb.
		 *
		 * There still is a question regarding to what is TRT:
		 * - On bsdi/freebsd, RTF_HOST (cloned) routing entry will be
		 *   generated on packet output.  inpcb will always cache
		 *   RTF_HOST routing entry so there's no need for the clause
		 *   (ICMPv6 redirect will update RTF_HOST routing entry,
		 *   and inpcb is caching it already).
		 *   However, bsdi/freebsd are vulnerable to local DoS attacks
		 *   due to the cloned routing entries.
		 * - Specwise, "destination cache" is mentioned in RFC2461.
		 *   Jinmei says that it implies bsdi/freebsd behavior, itojun
		 *   is not really convinced.
		 * - Having hiwat/lowat on # of cloned host route (redirect/
		 *   pmtud) may be a good idea.  netbsd/openbsd has it.  see
		 *   icmp6_mtudisc_update().
		 */
		if ((PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD) &&
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) &&
		    inp->inp_route.ro_rt &&
		    !(inp->inp_route.ro_rt->rt_flags & RTF_HOST)) {
			struct sockaddr_in6 *dst6;

			dst6 = satosin6(&inp->inp_route.ro_dst);
			if (IN6_ARE_ADDR_EQUAL(&dst6->sin6_addr,
			    &dst->sin6_addr))
				goto do_notify;
		}

		/*
		 * Detect if we should notify the error. If no source and
		 * destination ports are specified, but non-zero flowinfo and
		 * local address match, notify the error. This is the case
		 * when the error is delivered with an encrypted buffer
		 * by ESP. Otherwise, just compare addresses and ports
		 * as usual.
		 */
		if (lport == 0 && fport == 0 && flowinfo &&
		    inp->inp_socket != NULL &&
		    flowinfo == (inp->inp_flowinfo & IPV6_FLOWLABEL_MASK) &&
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &sa6_src.sin6_addr))
			goto do_notify;
		else if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6,
					     &dst->sin6_addr) ||
			 rtable_l2(inp->inp_rtableid) != rdomain ||
			 inp->inp_socket == 0 ||
			 (lport && inp->inp_lport != lport) ||
			 (!IN6_IS_ADDR_UNSPECIFIED(&sa6_src.sin6_addr) &&
			  !IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6,
					      &sa6_src.sin6_addr)) ||
			 (fport && inp->inp_fport != fport)) {
			continue;
		}
	  do_notify:
		nmatch++;
		if (notify)
			(*notify)(inp, errno);
	}
	return (nmatch);
}

/*
 * Get the local address/port, and put it in a sockaddr_in6.
 * This services the getsockname(2) call.
 */
int
in6_setsockaddr(struct inpcb *inp, struct mbuf *nam)
{
	struct sockaddr_in6 *sin6;

	nam->m_len = sizeof(struct sockaddr_in6);
	sin6 = mtod(nam,struct sockaddr_in6 *);

	bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
	sin6->sin6_family = AF_INET6;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_port = inp->inp_lport;
	sin6->sin6_addr = inp->inp_laddr6;
	/* KAME hack: recover scopeid */
	in6_recoverscope(sin6, &inp->inp_laddr6);

	return 0;
}

/*
 * Get the foreign address/port, and put it in a sockaddr_in6.
 * This services the getpeername(2) call.
 */
int
in6_setpeeraddr(struct inpcb *inp, struct mbuf *nam)
{
	struct sockaddr_in6 *sin6;

	nam->m_len = sizeof(struct sockaddr_in6);
	sin6 = mtod(nam,struct sockaddr_in6 *);

	bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
	sin6->sin6_family = AF_INET6;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_port = inp->inp_fport;
	sin6->sin6_addr = inp->inp_faddr6;
	/* KAME hack: recover scopeid */
	in6_recoverscope(sin6, &inp->inp_faddr6);

	return 0;
}
@


1.99
log
@The in_pcbhashlookup() in in_pcbconnect() enforces that the 4 tupel
of src/dst ip/port is unique for TCP.  But if the socket is not
bound, the automatic bind by connect happens after the check.  If
the socket has the SO_REUSEADDR flag, in_pcbbind() may select an
existing local port.  Then we had two colliding TCP PCBs.  This
resulted in a packet storm of ACK packets on loopback.  The softnet
task was constantly holding the netlock and has a high priority,
so the system hung.
Do the in_pcbhashlookup() again after in_pcbbind().  This creates
sporadic "connect: Address already in use" errors instead of a hang.
bug report and testing Olivier Antoine; OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.98 2017/05/13 17:42:55 bluhm Exp $	*/
d247 2
a248 2
	struct sockaddr_in6 *sin6 = mtod(nam, struct sockaddr_in6 *);
	int error = 0;
d251 2
a252 6
	(void)&in6a;				/* XXX fool gcc */

	if (nam->m_len != sizeof(*sin6))
		return (EINVAL);
	if (sin6->sin6_family != AF_INET6)
		return (EAFNOSUPPORT);
@


1.98
log
@Do not check for locally bound mapped addresses in in6_pcbconnect(),
this is done during bind(2) in in6_pcbaddrisavail().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.97 2017/03/07 16:59:40 bluhm Exp $	*/
d287 1
a287 1
	    inp->inp_lport, inp->inp_rtableid)) {
d294 11
a304 3
		if (inp->inp_lport == 0 &&
		    in_pcbbind(inp, NULL, curproc) == EADDRNOTAVAIL)
			return (EADDRNOTAVAIL);
@


1.97
log
@When the inpcb queue and hash lists are traversed or modified we
need netlock.  Remove the obsolete splnet.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.96 2016/08/04 20:46:24 vgross Exp $	*/
a258 1

d261 1
a261 5
		return EADDRNOTAVAIL;

	/* sanity check for mapped address case */
	if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
		return EINVAL;
@


1.96
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.95 2016/07/22 11:14:41 mpi Exp $	*/
d336 2
@


1.95
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.93 2016/07/05 10:17:14 mpi Exp $	*/
d284 1
a284 3
	error = in6_selectsrc(&in6a, sin6, inp->inp_outputopts6,
	    inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
	    inp->inp_rtableid);
@


1.94
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d284 3
a286 1
	error = in6_pcbselsrc(&in6a, sin6, inp, inp->inp_outputopts6);
@


1.93
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.92 2016/04/11 21:24:29 vgross Exp $	*/
d284 1
a284 3
	error = in6_selectsrc(&in6a, sin6, inp->inp_outputopts6,
	    inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
	    inp->inp_rtableid);
@


1.92
log
@Rename in_pcblookup() to in_pcblookup_local() and change its prototype
to get rid of the now useless foreign address and ports parameters.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.91 2016/04/05 21:21:41 vgross Exp $	*/
d211 2
a212 3
		if (ifa &&
		    ifatoia6(ifa)->ia6_flags &
		    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|IN6_IFF_DETACHED))
@


1.91
log
@Move reserved port checks from in(6)_pcbaddrisavail() to in_pcbbind().
Kill old comments while at it.

Ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.90 2016/03/30 13:02:22 vgross Exp $	*/
d220 1
a220 2
			t = in_pcblookup(table,
			    (struct in_addr *)&zeroin6_addr, 0,
d227 1
a227 2
		t = in_pcblookup(table,
		    (struct in_addr *)&zeroin6_addr, 0,
@


1.90
log
@Use in6_pcbhashlookup() in in6_pcbconnect(). We don't need in_pcblookup()
broad search and in_pcbconnect() already uses in_pcbhashlookup().

ok bluhm@@ mpi@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.89 2016/03/23 15:50:36 vgross Exp $	*/
a160 1
	int error;
a218 11
		/*
		 * Question:  Do we wish to continue the Berkeley
		 * tradition of ports < IPPORT_RESERVED be only for
		 * root?
		 * Answer: For now yes, but IMHO, it should be REMOVED!
		 * OUCH: One other thing, is there no better way of
		 * finding a process for a socket instead of using
		 * curproc?  (Marked with BSD's {in,}famous XXX ?
		 */
		if (ntohs(lport) < IPPORT_RESERVED && (error = suser(p, 0)))
			return error;
@


1.89
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.88 2016/03/21 21:21:35 vgross Exp $	*/
d307 1
a307 1
	if (in_pcblookup(inp->inp_table, &sin6->sin6_addr, sin6->sin6_port,
d309 1
a309 1
	    inp->inp_lport, INPLOOKUP_IPV6, inp->inp_rtableid)) {
@


1.88
log
@Extract in6_pcbaddrisavail() from in6_pcbbind(), and use it when
checking for source availability in udp6_output(); This time with
all the files.

Ok jca@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.87 2016/03/20 01:26:30 jca Exp $	*/
a152 57
/*
 * Bind an address (or at least a port) to an PF_INET6 socket.
 */
int
in6_pcbbind(struct inpcb *inp, struct mbuf *nam, struct proc *p)
{
	struct socket *so = inp->inp_socket;

	struct sockaddr_in6 *sin6;
	u_short lport = 0;
	int wild = INPLOOKUP_IPV6;
	int error;

	/*
	 * REMINDER:  Once up to speed, flow label processing should go here,
	 * too.  (Same with in6_pcbconnect.)
	 */
	if (TAILQ_EMPTY(&in6_ifaddr))
		return EADDRNOTAVAIL;

	if (inp->inp_lport != 0 || !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
		return EINVAL;	/* If already bound, EINVAL! */

	if ((so->so_options & (SO_REUSEADDR | SO_REUSEPORT)) == 0 &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
	     (so->so_options & SO_ACCEPTCONN) == 0))
		wild |= INPLOOKUP_WILDCARD;

	/*
	 * If I did get a sockaddr passed in...
	 */
	if (nam) {
		sin6 = mtod(nam, struct sockaddr_in6 *);
		if (nam->m_len != sizeof (*sin6))
			return EINVAL;

		/*
		 * Unlike v4, I have no qualms about EAFNOSUPPORT if the
		 * wretched family is not filled in!
		 */
		if (sin6->sin6_family != AF_INET6)
			return EAFNOSUPPORT;

		if ((error = in6_pcbaddrisavail(inp, sin6, wild, p)))
			return (error);
		inp->inp_laddr6 = sin6->sin6_addr;
		lport = sin6->sin6_port;
	}

	if (lport == 0)
		if ((error = in_pcbpickport(&lport, wild, inp, p)))
			return (error);
	inp->inp_lport = lport;
	in_pcbrehash(inp);
	return 0;
}

d317 1
a317 1
		    in6_pcbbind(inp, NULL, curproc) == EADDRNOTAVAIL)
@


1.87
log
@Revert, missing decl for in6_pcbaddrisavail() breaks kernel build.

Spotted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.85 2016/03/12 09:25:37 vgross Exp $	*/
a160 1
	struct inpcbtable *head = inp->inp_table;
d163 1
a163 1
	int wild = INPLOOKUP_IPV6, reuseport = (so->so_options & SO_REUSEPORT);
d196 3
a198 6
		/* KAME hack: embed scopeid */
		if (in6_embedscope(&sin6->sin6_addr, sin6, inp) != 0)
			return EINVAL;
		/* this must be cleared for ifa_ifwithaddr() */
		sin6->sin6_scope_id = 0;

a199 82

		/* reject IPv4 mapped address, we have no support for it */
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
			return EADDRNOTAVAIL;

		if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
			/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow complete duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */
			if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
				reuseport = SO_REUSEADDR | SO_REUSEPORT;
		} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			struct ifaddr *ifa = NULL;

			sin6->sin6_port = 0;  /*
					       * Yechhhh, because of upcoming
					       * call to ifa_ifwithaddr(), which
					       * does bcmp's over the PORTS as
					       * well.  (What about flow?)
					       */
			sin6->sin6_flowinfo = 0;
			if (!(so->so_options & SO_BINDANY) &&
			    (ifa = ifa_ifwithaddr(sin6tosa(sin6),
			    inp->inp_rtableid)) == NULL)
				return EADDRNOTAVAIL;

			/*
			 * bind to an anycast address might accidentally
			 * cause sending a packet with an anycast source
			 * address, so we forbid it.
			 *
			 * We should allow to bind to a deprecated address,
			 * since the application dare to use it.
			 * But, can we assume that they are careful enough
			 * to check if the address is deprecated or not?
			 * Maybe, as a safeguard, we should have a setsockopt
			 * flag to control the bind(2) behavior against
			 * deprecated addresses (default: forbid bind(2)).
			 */
			if (ifa &&
			    ifatoia6(ifa)->ia6_flags &
			    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|IN6_IFF_DETACHED))
				return (EADDRNOTAVAIL);
		}
		if (lport) {
			struct inpcb *t;

			/*
			 * Question:  Do we wish to continue the Berkeley
			 * tradition of ports < IPPORT_RESERVED be only for
			 * root?
			 * Answer: For now yes, but IMHO, it should be REMOVED!
			 * OUCH: One other thing, is there no better way of
			 * finding a process for a socket instead of using
			 * curproc?  (Marked with BSD's {in,}famous XXX ?
			 */
			if (ntohs(lport) < IPPORT_RESERVED &&
			    (error = suser(p, 0)))
				return error;
			if (so->so_euid) {
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return EADDRINUSE;
			}
			t = in_pcblookup(head,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    wild, inp->inp_rtableid);

			if (t && (reuseport & t->inp_socket->so_options) == 0)
				return EADDRINUSE;
		}
		inp->inp_laddr6 = sin6->sin6_addr;
d208 97
@


1.86
log
@Extract in6_pcbaddrisavail() from in6_pcbbind(), and use it when
checking for source availability in udp6_output().

Ok jca@@ bluhm@@
@
text
@d161 1
d164 1
a164 1
	int wild = INPLOOKUP_IPV6;
d197 88
a284 2
		if ((error = in6_pcbaddrisavail(inp, sin6, wild, p)))
			return (error);
a285 1
		lport = sin6->sin6_port;
a293 97
}

int
in6_pcbaddrisavail(struct inpcb *inp, struct sockaddr_in6 *sin6, int wild,
    struct proc *p)
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_short lport = sin6->sin6_port;
	int reuseport = (so->so_options & SO_REUSEPORT);
	int error;

	wild |= INPLOOKUP_IPV6;
	/* KAME hack: embed scopeid */
	if (in6_embedscope(&sin6->sin6_addr, sin6, inp) != 0)
		return (EINVAL);
	/* this must be cleared for ifa_ifwithaddr() */
	sin6->sin6_scope_id = 0;
	/* reject IPv4 mapped address, we have no support for it */
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
		return (EADDRNOTAVAIL);

	if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
		/*
		 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
		 * allow complete duplication of binding if
		 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
		 * and a multicast address is bound on both
		 * new and duplicated sockets.
		 */
		if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
			reuseport = SO_REUSEADDR | SO_REUSEPORT;
	} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
		struct ifaddr *ifa = NULL;

		sin6->sin6_port = 0;  /*
				       * Yechhhh, because of upcoming
				       * call to ifa_ifwithaddr(), which
				       * does bcmp's over the PORTS as
				       * well.  (What about flow?)
				       */
		sin6->sin6_flowinfo = 0;
		if (!(so->so_options & SO_BINDANY) &&
		    (ifa = ifa_ifwithaddr(sin6tosa(sin6),
		    inp->inp_rtableid)) == NULL)
			return (EADDRNOTAVAIL);
		sin6->sin6_port = lport;

		/*
		 * bind to an anycast address might accidentally
		 * cause sending a packet with an anycast source
		 * address, so we forbid it.
		 *
		 * We should allow to bind to a deprecated address,
		 * since the application dare to use it.
		 * But, can we assume that they are careful enough
		 * to check if the address is deprecated or not?
		 * Maybe, as a safeguard, we should have a setsockopt
		 * flag to control the bind(2) behavior against
		 * deprecated addresses (default: forbid bind(2)).
		 */
		if (ifa &&
		    ifatoia6(ifa)->ia6_flags &
		    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|IN6_IFF_DETACHED))
			return (EADDRNOTAVAIL);
	}
	if (lport) {
		struct inpcb *t;

		/*
		 * Question:  Do we wish to continue the Berkeley
		 * tradition of ports < IPPORT_RESERVED be only for
		 * root?
		 * Answer: For now yes, but IMHO, it should be REMOVED!
		 * OUCH: One other thing, is there no better way of
		 * finding a process for a socket instead of using
		 * curproc?  (Marked with BSD's {in,}famous XXX ?
		 */
		if (ntohs(lport) < IPPORT_RESERVED && (error = suser(p, 0)))
			return error;
		if (so->so_euid) {
			t = in_pcblookup(table,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
			    inp->inp_rtableid);
			if (t && (so->so_euid != t->inp_socket->so_euid))
				return (EADDRINUSE);
		}
		t = in_pcblookup(table,
		    (struct in_addr *)&zeroin6_addr, 0,
		    (struct in_addr *)&sin6->sin6_addr, lport,
		    wild, inp->inp_rtableid);
		if (t && (reuseport & t->inp_socket->so_options) == 0)
			return (EADDRINUSE);
	}
	return (0);
@


1.85
log
@Add checks on overlapping IPv6 sockets ownership

ok mpi@@ bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.84 2015/12/18 22:25:16 vgross Exp $	*/
a160 1
	struct inpcbtable *head = inp->inp_table;
d163 1
a163 1
	int wild = INPLOOKUP_IPV6, reuseport = (so->so_options & SO_REUSEPORT);
d196 3
a198 6
		/* KAME hack: embed scopeid */
		if (in6_embedscope(&sin6->sin6_addr, sin6, inp) != 0)
			return EINVAL;
		/* this must be cleared for ifa_ifwithaddr() */
		sin6->sin6_scope_id = 0;

a199 82

		/* reject IPv4 mapped address, we have no support for it */
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
			return EADDRNOTAVAIL;

		if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
			/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow complete duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */
			if (so->so_options & (SO_REUSEADDR|SO_REUSEPORT))
				reuseport = SO_REUSEADDR | SO_REUSEPORT;
		} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			struct ifaddr *ifa = NULL;

			sin6->sin6_port = 0;  /*
					       * Yechhhh, because of upcoming
					       * call to ifa_ifwithaddr(), which
					       * does bcmp's over the PORTS as
					       * well.  (What about flow?)
					       */
			sin6->sin6_flowinfo = 0;
			if (!(so->so_options & SO_BINDANY) &&
			    (ifa = ifa_ifwithaddr(sin6tosa(sin6),
			    inp->inp_rtableid)) == NULL)
				return EADDRNOTAVAIL;

			/*
			 * bind to an anycast address might accidentally
			 * cause sending a packet with an anycast source
			 * address, so we forbid it.
			 *
			 * We should allow to bind to a deprecated address,
			 * since the application dare to use it.
			 * But, can we assume that they are careful enough
			 * to check if the address is deprecated or not?
			 * Maybe, as a safeguard, we should have a setsockopt
			 * flag to control the bind(2) behavior against
			 * deprecated addresses (default: forbid bind(2)).
			 */
			if (ifa &&
			    ifatoia6(ifa)->ia6_flags &
			    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|IN6_IFF_DETACHED))
				return (EADDRNOTAVAIL);
		}
		if (lport) {
			struct inpcb *t;

			/*
			 * Question:  Do we wish to continue the Berkeley
			 * tradition of ports < IPPORT_RESERVED be only for
			 * root?
			 * Answer: For now yes, but IMHO, it should be REMOVED!
			 * OUCH: One other thing, is there no better way of
			 * finding a process for a socket instead of using
			 * curproc?  (Marked with BSD's {in,}famous XXX ?
			 */
			if (ntohs(lport) < IPPORT_RESERVED &&
			    (error = suser(p, 0)))
				return error;
			if (so->so_euid) {
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return EADDRINUSE;
			}
			t = in_pcblookup(head,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    wild, inp->inp_rtableid);

			if (t && (reuseport & t->inp_socket->so_options) == 0)
				return EADDRINUSE;
		}
		inp->inp_laddr6 = sin6->sin6_addr;
d208 97
@


1.84
log
@Fix SO_REUSE* flags effects when binding multicast addresses. No
regression observed on avahi.

ok benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.83 2015/12/02 22:13:44 vgross Exp $	*/
d267 10
a276 1

@


1.84.2.1
log
@OpenBSD 5.9 errata 2, Mar 16, 2016:

Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.84 2015/12/18 22:25:16 vgross Exp $	*/
d267 1
a267 10
			if (so->so_euid) {
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return EADDRINUSE;
			}
@


1.83
log
@Move port picking away from in_pcbbind()

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.82 2015/10/24 16:08:48 mpi Exp $	*/
d217 1
a217 1
			if (so->so_options & SO_REUSEADDR)
@


1.82
log
@Ignore Router Advertisment's current hop limit.

Appart from the usual inet6 axe murdering exercise to keep you fit, this
allows us to get rid of a lot of layer violation due to the use of per-
ifp variables to store the current hop limit.

Imputs from bluhm@@, ok phessler@@, florian@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.81 2015/10/20 18:04:03 deraadt Exp $	*/
d279 3
a281 70
	if (lport == 0) {
		error = in6_pcbsetport(&inp->inp_laddr6, inp, p);
		if (error != 0)
			return error;
	} else {
		inp->inp_lport = lport;
		in_pcbrehash(inp);
	}

	return 0;
}

int
in6_pcbsetport(struct in6_addr *laddr, struct inpcb *inp, struct proc *p)
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_int16_t bound_a, bound_b, first, last;
	u_int16_t lastport = 0;
	u_int16_t lport = 0;
	int count;
	int wild = INPLOOKUP_IPV6;
	int error;

	/* XXX we no longer support IPv4 mapped address, so no tweaks here */

	if ((so->so_options & (SO_REUSEADDR|SO_REUSEPORT)) == 0 &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
	     (so->so_options & SO_ACCEPTCONN) == 0))
		wild |= INPLOOKUP_WILDCARD;

	if (inp->inp_flags & INP_HIGHPORT) {
		bound_a = ipport_hifirstauto;	/* sysctl */
		bound_b = ipport_hilastauto;
	} else if (inp->inp_flags & INP_LOWPORT) {
		if ((error = suser(p, 0)))
			return (EACCES);
		bound_a = IPPORT_RESERVED-1; /* 1023 */
		bound_b = 600;		   /* not IPPORT_RESERVED/2 */
	} else {
		bound_a = ipport_firstauto;	/* sysctl */
		bound_b = ipport_lastauto;
	}
	if (bound_a < bound_b) {
		first = bound_a;
		last  = bound_b;
	} else {
		first = bound_b;
		last  = bound_a;
	}

	/*
	 * Simple check to ensure all ports are not used up causing
	 * a deadlock here.
	 */

	count = last - first;
	lastport = first + arc4random_uniform(count);

	do {
		if (count-- < 0)	/* completely used? */
			return (EADDRNOTAVAIL);
		++lastport;
		if (lastport < first || lastport > last)
			lastport = first;
		lport = htons(lastport);
	} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
	    in_pcblookup(table, &zeroin6_addr, 0,
	    &inp->inp_laddr6, lport, wild, inp->inp_rtableid));

a283 5

#if 0
	inp->inp_flowinfo = 0;	/* XXX */
#endif

@


1.81
log
@At guenther's suggestion replace dnssocket() with a SOCK_DNS flag on
socket().  Without pledge, all other socket behaviours become permitted,
except this one case: connect/send* only works to *:53.  In pledge mode,
a very few are further restricted.  Some backwards compatibility for
the dnssocket/dnsconnect calls will remain in the tree temporarily so
that people can build through the transition.
ok tedu guenther semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.80 2015/10/19 12:11:28 mpi Exp $	*/
a371 1
	struct ifnet *ifp = NULL;	/* outgoing interface */
d414 1
a414 4
	if (rtisvalid(inp->inp_route6.ro_rt))
		ifp = inp->inp_route6.ro_rt->rt_ifp;

	inp->inp_ipv6.ip6_hlim = (u_int8_t)in6_selecthlim(inp, ifp);
@


1.80
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.79 2015/10/19 08:49:14 vgross Exp $	*/
a372 1
	struct proc *p = curproc;
a383 3

	if (pledge_dns_check(p, sin6->sin6_port))
		return (pledge_fail(p, EPERM, PLEDGE_DNS));
@


1.79
log
@deduplicate in[6]_pcbbind() port scan loop.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.78 2015/10/18 00:04:43 deraadt Exp $	*/
d419 1
a419 1
	if (inp->inp_route6.ro_rt && inp->inp_route6.ro_rt->rt_flags & RTF_UP)
@


1.78
log
@Add two new system calls: dnssocket() and dnsconnect().  This creates a
SS_DNS tagged socket which has limited functionality (for example, you
cannot accept on them...)  The libc resolver will switch to using these,
therefore pledge can identify a DNS transaction better.
ok tedu guenther kettenis beck and others
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.77 2015/10/15 10:27:18 vgross Exp $	*/
d296 1
a296 1
	u_int16_t first, last;
d311 2
a312 2
		first = ipport_hifirstauto;	/* sysctl */
		last = ipport_hilastauto;
d316 2
a317 2
		first = IPPORT_RESERVED-1; /* 1023 */
		last = 600;		   /* not IPPORT_RESERVED/2 */
d319 9
a327 2
		first = ipport_firstauto;	/* sysctl */
		last  = ipport_lastauto;
a332 3
	 *
	 * We split the two cases (up and down) so that the direction
	 * is not being tested on each round of the loop.
d335 2
a336 7
	if (first > last) {
		/*
		 * counting down
		 */
		count = first - last;
		if (count)
			lastport = first - arc4random_uniform(count);
d338 10
a347 29
		do {
			if (count-- < 0)	/* completely used? */
				return (EADDRNOTAVAIL);
			--lastport;
			if (lastport > first || lastport < last)
				lastport = first;
			lport = htons(lastport);
		} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
		    in_pcblookup(table, &zeroin6_addr, 0,
		    &inp->inp_laddr6, lport, wild, inp->inp_rtableid));
	} else {
		/*
		 * counting up
		 */
		count = last - first;
		if (count)
			lastport = first + arc4random_uniform(count);

		do {
			if (count-- < 0)	/* completely used? */
				return (EADDRNOTAVAIL);
			++lastport;
			if (lastport < first || lastport > last)
				lastport = first;
			lport = htons(lastport);
		} while (in_baddynamic(lastport, so->so_proto->pr_protocol) ||
		    in_pcblookup(table, &zeroin6_addr, 0,
		    &inp->inp_laddr6, lport, wild, inp->inp_rtableid));
	}
@


1.77
log
@in6_pcbconnect() returns EADDRNOTAVAIL when
all the ports in the range portfirst .. portlast
are in use.

ok millert@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.76 2015/10/09 01:10:27 deraadt Exp $	*/
d407 1
a407 1
		return (pledge_fail(p, EPERM, PLEDGE_DNSPATH));
@


1.76
log
@Rename tame() to pledge().  This fairly interface has evolved to be more
strict than anticipated.  It allows a programmer to pledge/promise/covenant
that their program will operate within an easily defined subset of the
Unix environment, or it pays the price.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.75 2015/09/22 09:34:39 vgross Exp $	*/
d453 3
a455 2
		if (inp->inp_lport == 0)
			(void)in6_pcbbind(inp, NULL, curproc);
@


1.75
log
@Remove inpt_lastport from struct inpcbtable, use local variables
in in_pcbbind() and in6_pcbsetport()

ok claudio@@, with input from David Hill
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.74 2015/09/11 15:29:47 deraadt Exp $	*/
d112 1
a112 1
#include <sys/tame.h>
d406 2
a407 2
	if (tame_dns_check(p, sin6->sin6_port))
		return (tame_fail(p, EPERM, TAME_DNSPATH));
@


1.74
log
@Convert _TM_ flags to TAME_ flags, collapsing the entire mapping
layer because the strings select the right options.  Mechanical
conversion.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.73 2015/09/11 08:22:31 guenther Exp $	*/
d297 1
a297 1
	u_int16_t *lastport = &inp->inp_table->inpt_lastport;
d337 1
a337 1
			*lastport = first - arc4random_uniform(count);
d342 5
a346 5
			--*lastport;
			if (*lastport > first || *lastport < last)
				*lastport = first;
			lport = htons(*lastport);
		} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
d355 1
a355 1
			*lastport = first + arc4random_uniform(count);
d360 5
a364 5
			++*lastport;
			if (*lastport < first || *lastport > last)
				*lastport = first;
			lport = htons(*lastport);
		} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
@


1.73
log
@Only include <sys/tame.h> in the .c files that need it

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.72 2015/09/11 07:42:35 claudio Exp $	*/
d407 1
a407 1
		return (tame_fail(p, EPERM, TAME_DNS));
@


1.72
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.71 2015/09/10 17:52:05 claudio Exp $	*/
d112 1
@


1.71
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.70 2015/08/22 20:18:50 deraadt Exp $	*/
d197 1
a197 1
		if (in6_embedscope(&sin6->sin6_addr, sin6, inp, NULL) != 0)
d421 1
a421 1
	if (in6_embedscope(&sin6->sin6_addr, sin6, inp, &ifp) != 0)
@


1.70
log
@Move to tame(int flags, char *paths[]) API/ABI.

The pathlist is a whitelist of dirs and files; anything else returns ENOENT.
Recommendation is to use a narrowly defined list.  Also add TAME_FATTR, which
permits explicit change operations against "struct stat" fields.  Some
other TAME_ flags are refined slightly.

Not cranking libc now, since nothing commited in base uses this and the
timing is uncomfortable for others.  Discussed with many; thanks for a
few bug fixes from semarie, doug, guenther.
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.69 2015/07/19 02:35:35 deraadt Exp $	*/
d624 1
a624 1
	(void)in6_recoverscope(sin6, &inp->inp_laddr6, NULL);
d647 1
a647 1
	(void)in6_recoverscope(sin6, &inp->inp_faddr6, NULL);
@


1.69
log
@tame(2) is a subsystem which restricts programs into a "reduced feature
operating model".  This is the kernel component; various changes should
proceed in-tree for a while before userland programs start using it.
ok miod, discussions and help from many
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.68 2015/06/08 22:19:28 krw Exp $	*/
a111 1
#include <sys/tame.h>
@


1.69.4.1
log
@Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.

See Errata 012
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.69 2015/07/19 02:35:35 deraadt Exp $	*/
d267 1
a267 10
			if (so->so_euid) {
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return EADDRINUSE;
			}
@


1.68
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.67 2014/12/05 15:50:04 mpi Exp $	*/
d111 2
d393 1
d405 3
@


1.67
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.66 2014/11/18 02:37:31 tedu Exp $	*/
d34 1
a34 1
 * 
d38 1
a38 1
 * 
d46 4
a49 4
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
d53 1
a53 1
 * 
d65 1
a65 1
 * 
d474 1
a474 1
in6_pcbnotify(struct inpcbtable *head, struct sockaddr_in6 *dst, 
@


1.67.2.1
log
@Insufficient checks in IPv6 socket binding and UDP IPv6 option
processing allow a local user to send UDP packets with a source
(IPv6 address + port) already reserved by another user.

See Errata 024
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.67 2014/12/05 15:50:04 mpi Exp $	*/
d265 1
a265 10
			if (so->so_euid) {
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    INPLOOKUP_WILDCARD | INPLOOKUP_IPV6,
				    inp->inp_rtableid);
				if (t &&
				    (so->so_euid != t->inp_socket->so_euid))
					return EADDRINUSE;
			}
@


1.66
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.65 2014/08/21 11:54:00 mpi Exp $	*/
d113 1
@


1.65
log
@Misleading comments about splnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.64 2014/07/22 11:06:10 mpi Exp $	*/
a126 2

#include <dev/rndvar.h>
@


1.64
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.63 2014/06/03 13:32:24 mpi Exp $	*/
a384 2
 *
 * I believe this has to be called at splnet().
a472 2
 *
 * Must be called at splnet.
@


1.63
log
@Do not include <sys/malloc.h> where it is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.62 2014/04/18 10:48:30 jca Exp $	*/
a115 1
#include <netinet/in_systm.h>
@


1.62
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.61 2014/04/16 13:04:38 mpi Exp $	*/
a103 1
#include <sys/malloc.h>
@


1.61
log
@Merge in_fixaddr() into in_selectsrc() in order to prepare for
IP_SENDSRCADDR support.  This reduces the differences with the
IPv6 version and kill some comments that are no longer true.

ok jca@@, chrisz@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.60 2014/04/06 16:49:40 chrisz Exp $	*/
d432 1
a432 1
	in6a = in6_selectsrc(sin6, inp->inp_outputopts6,
d434 2
a435 4
	    &error, inp->inp_rtableid);
	if (in6a == 0) {
		if (error == 0)
			error = EADDRNOTAVAIL;
a436 1
	}
@


1.60
log
@Remove redundant call to in{,6}_pcbbind() from tcp PRU_CONNECT.
Make sure that in_pcbbind() is called from in_pcbconnect() by KASSERTing that
local port == 0 implies an unspecified local address.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.59 2014/01/08 22:38:29 bluhm Exp $	*/
d451 3
a453 1
	KASSERT(IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) || inp->inp_lport != 0);
@


1.59
log
@Name the local variables for struct ifaddr consistently "ifa".
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.58 2013/12/20 02:04:09 krw Exp $	*/
d451 1
@


1.58
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.57 2013/10/20 11:03:02 phessler Exp $	*/
d221 1
a221 1
			struct ifaddr *ia = NULL;
d231 1
a231 1
			    (ia = ifa_ifwithaddr(sin6tosa(sin6),
d248 2
a249 2
			if (ia &&
			    ifatoia6(ia)->ia6_flags &
@


1.57
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.56 2013/05/31 15:04:24 bluhm Exp $	*/
d529 1
a529 4
	for (inp = CIRCLEQ_FIRST(&head->inpt_queue);
	     inp != CIRCLEQ_END(&head->inpt_queue); inp = ninp) {
		ninp = CIRCLEQ_NEXT(inp, inp_queue);

@


1.56
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.55 2013/05/31 13:15:53 bluhm Exp $	*/
d272 1
a272 1
			    wild, /* XXX */ 0);
d349 1
a349 1
		    &inp->inp_laddr6, lport, wild, /* XXX */ 0));
d367 1
a367 1
		    &inp->inp_laddr6, lport, wild, /* XXX */ 0));
d448 1
a448 1
	    inp->inp_lport, INPLOOKUP_IPV6, /* XXX */ 0)) {
d482 2
a483 2
    uint fport_arg, const struct sockaddr_in6 *src, uint lport_arg, int cmd, 
    void *cmdarg, void (*notify)(struct inpcb *, int))
d504 1
d594 1
@


1.55
log
@The function rip6_ctlinput() claims that sa6_src is constant to
allow the assingment of &sa6_any.  But rip6_ctlinput() could not
guarantee that as it casted away the const attribute when it passes
the pointer to in6_pcbnotify().  Replace sockaddr with const
sockaddr_in6 in the in6_pcbnotify() parameters.  This reduces the
number of casts.  Also adjust in6_pcbhashlookup() to handle the
const attribute correctly.
Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.54 2013/04/10 08:50:59 mpi Exp $	*/
d231 1
a231 1
			    (ia = ifa_ifwithaddr((struct sockaddr *)sin6,
d572 1
a572 1
			dst6 = (struct sockaddr_in6 *)&inp->inp_route.ro_dst;
@


1.54
log
@Remove various external variable declaration from sources files and
move them to the corresponding header with an appropriate comment if
necessary.

ok guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.53 2013/03/28 16:45:16 tedu Exp $	*/
d481 3
a483 3
in6_pcbnotify(struct inpcbtable *head, struct sockaddr *dst, 
	uint fport_arg, struct sockaddr *src, uint lport_arg, int cmd, 
	void *cmdarg, void (*notify)(struct inpcb *, int))
d487 1
a487 1
	struct sockaddr_in6 sa6_src, *sa6_dst;
d491 1
a491 1
	if ((unsigned)cmd >= PRC_NCMDS || dst->sa_family != AF_INET6)
d494 1
a494 2
	sa6_dst = (struct sockaddr_in6 *)dst;
	if (IN6_IS_ADDR_UNSPECIFIED(&sa6_dst->sin6_addr))
d496 1
a496 1
	if (IN6_IS_ADDR_V4MAPPED(&sa6_dst->sin6_addr)) {
d507 1
a507 1
	sa6_src = (src == NULL) ? sa6_any : *(struct sockaddr_in6 *)src;
d574 1
a574 1
			    &sa6_dst->sin6_addr))
d592 1
a592 1
					     &sa6_dst->sin6_addr) ||
@


1.53
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.52 2013/03/25 14:40:57 mpi Exp $	*/
d120 1
a136 5

extern int ipport_firstauto;
extern int ipport_lastauto;
extern int ipport_hifirstauto;
extern int ipport_hilastauto;
@


1.52
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.51 2013/03/04 14:42:25 bluhm Exp $	*/
a111 1
#include <sys/proc.h>
@


1.51
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.50 2011/11/24 17:39:55 sperreault Exp $	*/
a131 2
extern struct in6_ifaddr *in6_ifaddr;

d177 1
a177 1
	if (in6_ifaddr == 0)
@


1.50
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.49 2009/06/05 00:05:22 claudio Exp $	*/
d256 1
a256 1
			    ((struct in6_ifaddr *)ia)->ia6_flags &
@


1.49
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.48 2008/11/23 13:30:59 claudio Exp $	*/
d239 1
a239 1
			    /* XXX */ 0)) == NULL)
d441 1
a441 1
	    &error);
@


1.48
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.47 2008/06/11 19:00:50 mcbride Exp $	*/
d238 2
a239 2
			    ((ia = ifa_ifwithaddr((struct sockaddr *)sin6))
			    == NULL))
d279 1
a279 1
			    wild);
d356 1
a356 1
		    &inp->inp_laddr6, lport, wild));
d374 1
a374 1
		    &inp->inp_laddr6, lport, wild));
d455 1
a455 1
	    inp->inp_lport, INPLOOKUP_IPV6)) {
@


1.47
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.46 2008/05/23 15:51:12 thib Exp $	*/
d448 1
a448 1
	if (inp->inp_route6.ro_rt)
@


1.46
log
@Deal with the situation when TCP nfs mounts timeout and processes
get hung in nfs_reconnect() because they do not have the proper
privilages to bind to a socket, by adding a struct proc * argument
to sobind() (and the *_usrreq() routines, and finally in{6}_pcbbind)
and do the sobind() with proc0 in nfs_connect.

OK markus@@, blambert@@.
"go ahead" deraadt@@.

Fixes an issue reported by bernd@@ (Tested by bernd@@).
Fixes PR5135 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.45 2008/05/19 14:58:29 markus Exp $	*/
d165 1
a165 4
in6_pcbbind(inp, nam, p)
	struct inpcb *inp;
	struct mbuf *nam;
	struct proc *p;
d300 1
a300 4
in6_pcbsetport(laddr, inp, p)
	struct in6_addr *laddr;
	struct inpcb *inp;
	struct proc *p;
d398 1
a398 3
in6_pcbconnect(inp, nam)
	struct inpcb *inp;
	struct mbuf *nam;
d488 3
a490 8
in6_pcbnotify(head, dst, fport_arg, src, lport_arg, cmd, cmdarg, notify)
	struct inpcbtable *head;
	struct sockaddr *dst, *src;
	uint fport_arg;
	uint lport_arg;
	int cmd;
	void *cmdarg;
	void (*notify)(struct inpcb *, int);
d622 1
a622 3
in6_setsockaddr(inp, nam)
	struct inpcb *inp;
	struct mbuf *nam;
d645 1
a645 3
in6_setpeeraddr(inp, nam)
	struct inpcb *inp;
	struct mbuf *nam;
@


1.45
log
@SO_BINDANY for ipv6; ok djm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.44 2008/04/18 06:42:20 djm Exp $	*/
d165 1
a165 1
in6_pcbbind(inp, nam)
d168 1
a173 1
	struct proc *p = curproc;		/* XXX */
d468 1
a468 1
			(void)in6_pcbbind(inp, (struct mbuf *)0);
@


1.44
log
@use arc4random_uniform() for random number requests that are not a
power of two.

use arc4random_bytes() when requesting more than a word of PRNG
output.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.43 2005/06/24 07:57:24 markus Exp $	*/
d240 3
a242 2
			if ((ia = ifa_ifwithaddr((struct sockaddr *)sin6))
			    == NULL)
@


1.43
log
@simplify port allocation in pcb_bind(); based on freebsd; ok claudio henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.42 2004/02/06 21:05:57 itojun Exp $	*/
d350 1
a350 1
			*lastport = first - (arc4random() % count);
d368 1
a368 1
			*lastport = first + (arc4random() % count);
@


1.42
log
@permit IPv6-only operation (permit AF_INET6 bind(2) without IPv4 address).
found by todd fries.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.41 2004/02/05 04:39:57 itojun Exp $	*/
d309 1
a309 1
	u_int16_t first, last, old = 0;
a312 1
	int loopcount = 0;
a343 1
portloop:
a347 4
		if (loopcount == 0) {	/* only do this once. */
			old = first;
			first -= (arc4random() % (first - last));
		}
d349 2
a350 1
		*lastport = first;		/* restart each time */
d353 1
a353 6
			if (count-- <= 0) {	/* completely used? */
				if (loopcount == 0) {
					last = old;
					loopcount++;
					goto portloop;
				}
a354 1
			}
a365 4
		if (loopcount == 0) {	/* only do this once. */
			old = first;
			first += (arc4random() % (last - first));
		}
d367 2
a368 1
		*lastport = first;		/* restart each time */
d371 1
a371 6
			if (count-- <= 0) {	/* completely used? */
				if (loopcount == 0) {
					first = old;
					loopcount++;
					goto portloop;
				}
a372 1
			}
@


1.41
log
@remove never-to-be-used codepath (IPv4 mapped address).  ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.40 2003/12/21 15:12:27 markus Exp $	*/
a132 1
extern struct in_ifaddr *in_ifaddr;
d182 1
a182 1
	if (in6_ifaddr == 0 || in_ifaddr == 0)
@


1.40
log
@change in*_pcbnotify to return numbers of matches; ok itojun, mcbride, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.39 2003/12/21 14:57:19 markus Exp $	*/
a431 1
	struct in6_addr mapped;
d448 2
a449 9
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
		if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
			inp->inp_laddr6.s6_addr16[5] = htons(0xffff);
		if (!IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
			return EINVAL;
	} else {
		if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
			return EINVAL;
	}
d462 12
a473 34
	if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6) &&
	    inp->inp_laddr6.s6_addr32[3] == 0) {
		struct sockaddr_in sin, *sinp;

		bzero(&sin, sizeof(sin));
		sin.sin_len = sizeof(sin);
		sin.sin_family = AF_INET;
		bcopy(&sin6->sin6_addr.s6_addr32[3], &sin.sin_addr,
		    sizeof(sin.sin_addr));
		sinp = in_selectsrc(&sin, (struct route *)&inp->inp_route6,
		    inp->inp_socket->so_options, NULL, &error);
		if (sinp == 0) {
			if (error == 0)
				error = EADDRNOTAVAIL;
			return (error);
		}
		bzero(&mapped, sizeof(mapped));
		mapped.s6_addr16[5] = htons(0xffff);
		bcopy(&sinp->sin_addr, &mapped.s6_addr32[3], sizeof(sinp->sin_addr));
		in6a = &mapped;
	} else {
		/*
		 * XXX: in6_selectsrc might replace the bound local address
		 * with the address specified by setsockopt(IPV6_PKTINFO).
		 * Is it the intended behavior?
		 */
		in6a = in6_selectsrc(sin6, inp->inp_outputopts6,
		    inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
		    &error);
		if (in6a == 0) {
			if (error == 0)
				error = EADDRNOTAVAIL;
			return (error);
		}
d475 1
d486 1
a486 3
	if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ||
	    (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6) &&
	     inp->inp_laddr6.s6_addr32[3] == 0)) {
d537 2
a538 1
	if (IN6_IS_ADDR_V4MAPPED(&sa6_dst->sin6_addr))
d541 3
@


1.39
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.38 2003/11/04 22:39:38 markus Exp $	*/
d563 1
a563 1
		return 1;
d567 1
a567 1
		return 1;
d674 1
a674 1
	return 0;
@


1.38
log
@don't call in_pcbrehash twice; ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.37 2003/10/01 21:41:05 itojun Exp $	*/
d596 3
a598 3
	for (inp = head->inpt_queue.cqh_first;
	     inp != (struct inpcb *)&head->inpt_queue; inp = ninp) {
		ninp = inp->inp_queue.cqe_next;
@


1.37
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.36 2003/09/28 23:17:45 cloder Exp $	*/
d294 1
a294 1
	} else
d296 2
a297 2

	in_pcbrehash(inp);
@


1.36
log
@Correct off-by-ones with respect to PRC_NCMDS.  Mostly from FreeBSD.
OK krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.35 2003/08/15 20:32:20 tedu Exp $	*/
a287 5

		if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
			inp->inp_ipv6.ip6_flow = htonl(0x60000000) |
			    (sin6->sin6_flowinfo & htonl(0x0fffffff));
		}
d406 4
d524 4
a527 5
	/*
	 * xxx kazu flowlabel is necessary for connect?
	 * but if this line is missing, the garbage value remains.
	 */
	inp->inp_ipv6.ip6_flow = sin6->sin6_flowinfo;
@


1.35
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.34 2003/06/02 23:28:15 millert Exp $	*/
d564 1
a564 1
	if ((unsigned)cmd > PRC_NCMDS || dst->sa_family != AF_INET6)
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.33 2003/03/15 19:16:10 deraadt Exp $	*/
d276 1
a276 1
			    (error = suser(p->p_ucred, &p->p_acflag)))
d334 1
a334 1
		if ((error = suser(p->p_ucred, &p->p_acflag)))
@


1.33
log
@specifed -> specified
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.32 2002/09/11 03:15:36 itojun Exp $	*/
d84 1
a84 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.31 2002/09/04 07:26:53 itojun Exp $	*/
d654 1
a654 1
		 * destination ports are specifed, but non-zero flowinfo and
@


1.31
log
@pass struct proc * down to in6_pcbsetport
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.30 2002/08/20 21:50:56 itojun Exp $	*/
d265 1
a265 1
				return(EADDRNOTAVAIL);
d443 1
a443 1
		return(EINVAL);
d445 1
a445 1
		return(EAFNOSUPPORT);
d447 1
a447 1
		return(EADDRNOTAVAIL);
d489 1
a489 1
			return(error);
d507 1
a507 1
			return(error);
d518 1
a518 1
		return(EADDRINUSE);
d535 1
a535 1
	return(0);
@


1.30
log
@more comment on bind(deprecated) handling
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.29 2002/06/09 00:22:24 itojun Exp $	*/
d300 1
a300 1
		error = in6_pcbsetport(&inp->inp_laddr6, inp);
d312 1
a312 1
in6_pcbsetport(laddr, inp)
d315 1
a324 1
	struct proc *p = curproc;		/* XXX */
@


1.29
log
@correct getpeername(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.28 2002/03/14 01:27:12 millert Exp $	*/
d250 11
a260 4
			 * XXX: bind to an anycast address might accidentally
			 * cause sending a packet with anycast source address.
			 * We should allow to bind to a deprecated address, since
			 * the application dare to use it.
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.27 2002/01/21 05:33:14 itojun Exp $	*/
d720 2
@


1.27
log
@remove couple of #if 0'ed portion we will never use
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.26 2001/06/05 02:31:37 deraadt Exp $	*/
d553 1
a553 1
	void (*notify) __P((struct inpcb *, int));
@


1.26
log
@repair copyright notices for NRL & cmetz; cmetz
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.25 2001/02/16 16:00:56 itojun Exp $	*/
a259 25
#if 0 /* we don't support it */
		else if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
			struct sockaddr_in sin;

			bzero(&sin, sizeof(sin));
			sin.sin_port = 0;
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];

			/*
			 * Yechhhh, because of upcoming call to
			 * ifa_ifwithaddr(), which does bcmp's
			 * over the PORTS as well.  (What about flow?)
			 */
			sin6->sin6_port = 0;
			sin6->sin6_flowinfo = 0;
			if (ifa_ifwithaddr((struct sockaddr *)sin6) == 0) {
				if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
				    ifa_ifwithaddr((struct sockaddr *)&sin) == 0) {
					return EADDRNOTAVAIL;
				}
			}
		}
#endif
a261 3
#if 0 /* we don't support IPv4 mapped address */
			struct in_addr fa,la;
#endif
d276 4
a279 16
#if 0 /* we don't support IPv4 mapped address */
			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
				fa.s_addr = 0;
				la.s_addr = sin6->sin6_addr.s6_addr32[3];
				wild &= ~INPLOOKUP_IPV6;

				t = in_pcblookup(head, (struct in_addr *)&fa, 0,
				    (struct in_addr *)&la, lport, wild);
			} else
#endif
			{
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    wild);
			}
@


1.26.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.27 2002/01/21 05:33:14 itojun Exp $	*/
d260 25
d287 3
d304 16
a319 4
			t = in_pcblookup(head,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    wild);
@


1.26.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.26.4.1 2002/01/31 22:55:46 niklas Exp $	*/
d553 1
a553 1
	void (*notify)(struct inpcb *, int);
a719 2
	/* KAME hack: recover scopeid */
	(void)in6_recoverscope(sin6, &inp->inp_faddr6, NULL);
@


1.26.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.26.4.2 2002/06/11 03:31:37 art Exp $	*/
d250 4
a253 11
			 * bind to an anycast address might accidentally
			 * cause sending a packet with an anycast source
			 * address, so we forbid it.
			 *
			 * We should allow to bind to a deprecated address,
			 * since the application dare to use it.
			 * But, can we assume that they are careful enough
			 * to check if the address is deprecated or not?
			 * Maybe, as a safeguard, we should have a setsockopt
			 * flag to control the bind(2) behavior against
			 * deprecated addresses (default: forbid bind(2)).
d258 1
a258 1
				return (EADDRNOTAVAIL);
d293 1
a293 1
		error = in6_pcbsetport(&inp->inp_laddr6, inp, p);
d305 1
a305 1
in6_pcbsetport(laddr, inp, p)
a307 1
	struct proc *p;
d317 1
d436 1
a436 1
		return (EINVAL);
d438 1
a438 1
		return (EAFNOSUPPORT);
d440 1
a440 1
		return (EADDRNOTAVAIL);
d482 1
a482 1
			return (error);
d500 1
a500 1
			return (error);
d511 1
a511 1
		return (EADDRINUSE);
d528 1
a528 1
	return (0);
@


1.26.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d654 1
a654 1
		 * destination ports are specified, but non-zero flowinfo and
@


1.25
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.24 2001/02/16 08:22:05 itojun Exp $	*/
d33 38
a70 8
%%% copyright-nrl-95
This software is Copyright 1995-1998 by Randall Atkinson, Ronald Lee,
Daniel McDonald, Bao Phan, and Chris Winters. All Rights Reserved. All
rights under this copyright have been assigned to the US Naval Research
Laboratory (NRL). The NRL Copyright Notice and License Agreement Version
1.1 (January 17, 1995) applies to this software.
You should have received a copy of the license with this software. If you
didn't get a copy, you may request one from <license@@ipv6.nrl.navy.mil>.
a71 1
*/
@


1.24
log
@kill register declarations.  to sync with kame better.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.23 2001/02/08 18:46:23 itojun Exp $	*/
d557 1
a557 1
in6_pcbnotify(head, dst, fport_arg, la, lport_arg, cmd, notify)
d559 1
a559 1
	struct sockaddr *dst;
a560 1
	struct in6_addr *la;
d563 1
a566 1
	struct in6_addr *faddr,laddr = *la;
d568 1
d570 1
a570 1
	int do_rtchange = (notify == in_rtchange);
d574 3
a576 2
	faddr = &(((struct sockaddr_in6 *)dst)->sin6_addr);
	if (IN6_IS_ADDR_UNSPECIFIED(faddr))
d578 9
a586 2
	if (IN6_IS_ADDR_V4MAPPED(faddr))
		printf("Huh?  Thought in6_pcbnotify() never got called with mapped!\n");
d599 1
a599 1
		laddr = in6addr_any;
d601 2
a602 1
		notify = in_rtchange;
a609 1
#ifdef INET6
a611 1
#endif
d613 41
a653 17
		if (do_rtchange) {
			/*
			 * Since a non-connected PCB might have a cached route,
			 * we always call in_rtchange without matching
			 * the PCB to the src/dst pair.
			 *
			 * XXX: we assume in_rtchange does not free the PCB.
			 */
			if (IN6_ARE_ADDR_EQUAL(&inp->inp_route6.ro_dst.sin6_addr,
			    faddr)) {
				in_rtchange(inp, errno);

				if (notify == in_rtchange) {
					/* there's nothing to do any more */
					continue;
				}
			}
d656 21
a676 5
		if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, faddr) ||
		    !inp->inp_socket ||
		    (lport && inp->inp_lport != lport) ||
		    (!IN6_IS_ADDR_UNSPECIFIED(&laddr) && !IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &laddr)) ||
		    (fport && inp->inp_fport != fport)) {
d679 1
a680 1

@


1.23
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.22 2001/01/06 16:07:45 itojun Exp $	*/
d142 1
a142 1
	register struct inpcb *inp;
d145 1
a145 1
	register struct socket *so = inp->inp_socket;
d147 2
a148 2
	register struct inpcbtable *head = inp->inp_table;
	register struct sockaddr_in6 *sin6;
d434 1
a434 1
	register struct inpcb *inp;
d566 1
a566 1
	register struct inpcb *inp, *ninp;
d646 1
a646 1
	register struct inpcb *inp;
d649 1
a649 1
	register struct sockaddr_in6 *sin6;
d671 1
a671 1
	register struct inpcb *inp;
d674 1
a674 1
	register struct sockaddr_in6 *sin6;
@


1.22
log
@prohibited binding to an anycast, notready, or detached IPv6 address.
sync with kame 1.46 -> 1.47
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.21 2000/12/21 00:54:11 itojun Exp $	*/
a683 1
	sin6->sin6_flowinfo = inp->inp_fflowinfo;
@


1.21
log
@correct ipv6 path mtu discovery.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.20 2000/10/11 09:14:14 itojun Exp $	*/
d206 24
@


1.20
log
@nuke inp_flags bits for controlling IPv4 mapped address.
we don't support IPv4 mapped address,
and there are inconsistent bit manipulation code so it's safer to nuke them.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.19 2000/06/18 18:07:49 itojun Exp $	*/
d590 2
a591 1
			if (IN6_ARE_ADDR_EQUAL(&inp->inp_route6.ro_dst.sin6_addr, faddr))
d594 5
a598 2
			if (notify == in_rtchange)
				continue; /* there's nothing to do any more */
@


1.19
log
@KNF (sorry craig)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.18 2000/06/18 18:00:18 itojun Exp $	*/
d192 4
d206 3
a208 1
		} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
d231 1
a276 20

		/*
		 * Unroll first 2 compares of {UNSPEC,V4MAPPED}.
		 * Mark PF_INET6 socket as undecided (bound to port-only) or
		 * mapped (INET6 socket talking IPv4) here.  I may need to move
		 * this code out of this if (nam) clause, and put it just before
		 * function return.
		 *
		 * Then again, the only time this function is called with NULL
		 * nam might be during a *_pcbconnect(), which then sets the
		 * local address ANYWAY.
		 */
		if (inp->inp_laddr6.s6_addr32[0] == 0 &&
		    inp->inp_laddr6.s6_addr32[1] == 0) {
			if (inp->inp_laddr6.s6_addr32[2] == ntohl(0xffff))
				inp->inp_flags |= INP_IPV6_MAPPED;
			if (inp->inp_laddr6.s6_addr32[2] == 0 &&
			    inp->inp_laddr6.s6_addr32[3] == 0)
				inp->inp_flags |= INP_IPV6_UNDEC;
		}
d429 4
a513 5
	/* configure NRL flags properly */
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
		inp->inp_flags |= INP_IPV6_MAPPED;
		inp->inp_flags &= ~INP_IPV6_UNDEC;
	}
@


1.18
log
@remove now-unnecessary statement due to "for" logic clarfication.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.17 2000/06/18 17:56:42 itojun Exp $	*/
d128 6
a133 6
        0,              0,              0,              0,
        0,              EMSGSIZE,       EHOSTDOWN,      EHOSTUNREACH,
        EHOSTUNREACH,   EHOSTUNREACH,   ECONNREFUSED,   ECONNREFUSED,
        EMSGSIZE,       EHOSTUNREACH,   0,              0,
        0,              0,              0,              0,
        ENOPROTOOPT
d137 1
a137 1
/*----------------------------------------------------------------------
d139 1
a139 1
 ----------------------------------------------------------------------*/
d142 2
a143 2
     register struct inpcb *inp;
     struct mbuf *nam;
d145 18
a162 1
  register struct socket *so = inp->inp_socket;
d164 12
a175 87
  register struct inpcbtable *head = inp->inp_table;
  register struct sockaddr_in6 *sin6;
  struct proc *p = curproc;		/* XXX */
  u_short lport = 0;
  int wild = INPLOOKUP_IPV6, reuseport = (so->so_options & SO_REUSEPORT);
  int error;

  /*
   * REMINDER:  Once up to speed, flow label processing should go here,
   *            too.  (Same with in6_pcbconnect.)  
   */

  if (in6_ifaddr == 0 || in_ifaddr == 0)
    return EADDRNOTAVAIL;

  if (inp->inp_lport != 0 || !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
    return EINVAL;   /* If already bound, EINVAL! */

  if ((so->so_options & (SO_REUSEADDR | SO_REUSEPORT)) == 0 &&
      ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
       (so->so_options & SO_ACCEPTCONN) == 0))
    wild |= INPLOOKUP_WILDCARD;

  /*
   * If I did get a sockaddr passed in...
   */
  if (nam)
    {
      sin6 = mtod(nam, struct sockaddr_in6 *);
      if (nam->m_len != sizeof (*sin6))
	return EINVAL;

      /*
       * Unlike v4, I have no qualms about EAFNOSUPPORT if the
       * wretched family is not filled in!
       */
      if (sin6->sin6_family != AF_INET6)
	return EAFNOSUPPORT;

      /* KAME hack: embed scopeid */
      if (in6_embedscope(&sin6->sin6_addr, sin6, inp, NULL) != 0)
	return EINVAL;
      /* this must be cleared for ifa_ifwithaddr() */
      sin6->sin6_scope_id = 0;

      lport = sin6->sin6_port;

      if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))
	{
	  /*
	   * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
	   * allow complete duplication of binding if
	   * SO_REUSEPORT is set, or if SO_REUSEADDR is set
	   * and a multicast address is bound on both
	   * new and duplicated sockets.
	   */
	  if (so->so_options & SO_REUSEADDR)
	    reuseport = SO_REUSEADDR | SO_REUSEPORT;
	}
      else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))
	{
	  struct sockaddr_in sin;

	  bzero(&sin, sizeof(sin));
	  sin.sin_port = 0;
	  sin.sin_len = sizeof(sin);
	  sin.sin_family = AF_INET;
	  sin.sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];

	  sin6->sin6_port = 0;  /* Yechhhh, because of upcoming call to
				   ifa_ifwithaddr(), which does bcmp's
				   over the PORTS as well.  (What about flow?)
				   */
	  sin6->sin6_flowinfo = 0;
	  if (ifa_ifwithaddr((struct sockaddr *)sin6) == 0) {
	    if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
		ifa_ifwithaddr((struct sockaddr *)&sin) == 0) {
	      return EADDRNOTAVAIL;
	    }
	  }
	}
      if (lport)
	{
	  struct inpcb *t;
#if 0 /* we don't support IPv4 mapped address */
	  struct in_addr fa,la;
#endif
d177 6
a182 2
	  /* Question:  Do we wish to continue the Berkeley tradition of
	     ports < IPPORT_RESERVED be only for root? 
d184 5
a188 1
	     Answer:  For now yes, but IMHO, it should be REMOVED! 
d190 1
a190 6
	     OUCH:  One other thing, is there no better way of finding
	     a process for a socket instead of using curproc?  (Marked
	     with BSD's {in,}famous XXX ? */
	  if (ntohs(lport) < IPPORT_RESERVED &&
	      (error = suser(p->p_ucred, &p->p_acflag)))
	    return error;
d192 35
d228 2
a229 5
	  if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
	    {
	      fa.s_addr = 0;
	      la.s_addr = sin6->sin6_addr.s6_addr32[3];
	      wild &= ~INPLOOKUP_IPV6;
d231 12
a242 2
	      t = in_pcblookup(head, (struct in_addr *)&fa, 0,
			       (struct in_addr *)&la, lport, wild);
d244 9
a252 2
	    }
	  else
d254 6
a259 4
	    {
	      t = in_pcblookup(head, (struct in_addr *)&zeroin6_addr, 0,
			(struct in_addr *)&sin6->sin6_addr, lport, wild);
	    }
d261 9
a269 4
	  if (t && (reuseport & t->inp_socket->so_options) == 0)
	    return EADDRINUSE;
	}
      inp->inp_laddr6 = sin6->sin6_addr;
d271 19
a289 23
      if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
	inp->inp_ipv6.ip6_flow = htonl(0x60000000) | 
	  (sin6->sin6_flowinfo & htonl(0x0fffffff));

      /*
       * Unroll first 2 compares of {UNSPEC,V4MAPPED}.
       * Mark PF_INET6 socket as undecided (bound to port-only) or
       * mapped (INET6 socket talking IPv4) here.  I may need to move
       * this code out of this if (nam) clause, and put it just before
       * function return.
       *
       * Then again, the only time this function is called with NULL nam
       * might be during a *_pcbconnect(), which then sets the local address
       * ANYWAY.
       */
      if (inp->inp_laddr6.s6_addr32[0] == 0 && 
	  inp->inp_laddr6.s6_addr32[1] == 0)
	{
	  if (inp->inp_laddr6.s6_addr32[2] == ntohl(0xffff))
	    inp->inp_flags |= INP_IPV6_MAPPED;
	  if (inp->inp_laddr6.s6_addr32[2] == 0 &&
	      inp->inp_laddr6.s6_addr32[3] == 0)
	    inp->inp_flags |= INP_IPV6_UNDEC;
a290 1
    }
d411 1
a411 1
/*----------------------------------------------------------------------
d420 1
a420 2
 ----------------------------------------------------------------------*/

d464 2
a465 2
	if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6)
	 && inp->inp_laddr6.s6_addr32[3] == 0) {
d472 1
a472 1
			sizeof(sin.sin_addr));
d474 1
a474 1
			inp->inp_socket->so_options, NULL, &error);
d491 2
a492 3
				     inp->inp_moptions6,
				     &inp->inp_route6,
				     &inp->inp_laddr6, &error);
d504 3
a506 7
	if (in_pcblookup(inp->inp_table,
			 &sin6->sin6_addr,
			 sin6->sin6_port,
			 IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ?
			  in6a : &inp->inp_laddr6,
			 inp->inp_lport,
			 INPLOOKUP_IPV6))
d508 4
a511 3
	if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)
	 || (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6)
	  && inp->inp_laddr6.s6_addr32[3] == 0)) {
d532 1
a532 1
/*----------------------------------------------------------------------
d541 1
a541 1
 * Also perform input-side security policy check 
d545 1
a545 2
 ----------------------------------------------------------------------*/

d548 7
a554 7
     struct inpcbtable *head;
     struct sockaddr *dst;
     uint fport_arg;
     struct in6_addr *la;
     uint lport_arg;
     int cmd;
     void (*notify) __P((struct inpcb *, int));
d556 34
a589 39
  register struct inpcb *inp, *ninp;
  struct in6_addr *faddr,laddr = *la;
  u_short fport = fport_arg, lport = lport_arg;
  int errno, nmatch = 0;
  int do_rtchange = (notify == in_rtchange);

  if ((unsigned)cmd > PRC_NCMDS || dst->sa_family != AF_INET6)
    return 1;
  faddr = &(((struct sockaddr_in6 *)dst)->sin6_addr);
  if (IN6_IS_ADDR_UNSPECIFIED(faddr))
    return 1;
  if (IN6_IS_ADDR_V4MAPPED(faddr))
    {
      printf("Huh?  Thought in6_pcbnotify() never got called with mapped!\n");
    }
  
  /*
   * Redirects go to all references to the destination,
   * and use in_rtchange to invalidate the route cache.
   * Dead host indications: also use in_rtchange to invalidate
   * the cache, and deliver the error to all the sockets.
   * Otherwise, if we have knowledge of the local port and address,
   * deliver only to that socket.
   */

  if (PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD)
    {
      fport = 0;
      lport = 0;
      laddr = in6addr_any;

      notify = in_rtchange;
    }
  errno = inet6ctlerrmap[cmd];

  for (inp = head->inpt_queue.cqh_first;
       inp != (struct inpcb *)&head->inpt_queue; inp = ninp)
    {
      ninp = inp->inp_queue.cqe_next;
d592 2
a593 2
      if ((inp->inp_flags & INP_IPV6) == 0)
	continue;
d596 23
a618 10
      if (do_rtchange) {
	/*
	 * Since a non-connected PCB might have a cached route,
	 * we always call in_rtchange without matching
	 * the PCB to the src/dst pair.
	 *
	 * XXX: we assume in_rtchange does not free the PCB.
	 */
	if (IN6_ARE_ADDR_EQUAL(&inp->inp_route6.ro_dst.sin6_addr, faddr))
	  in_rtchange(inp, errno);
d620 2
a621 11
	if (notify == in_rtchange)
	  continue;		/* there's nothing to do any more */
      }

      if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6, faddr) ||
	  !inp->inp_socket ||
	  (lport && inp->inp_lport != lport) ||
	  (!IN6_IS_ADDR_UNSPECIFIED(&laddr) && !IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &laddr)) ||
	  (fport && inp->inp_fport != fport))
	{
	  continue;
d623 1
a623 6
      nmatch++;

      if (notify)
	(*notify)(inp, errno);
    }
   return 0;
d626 1
a626 1
/*----------------------------------------------------------------------
d629 1
a629 2
 ----------------------------------------------------------------------*/

d632 2
a633 2
     register struct inpcb *inp;
     struct mbuf *nam;
d635 1
a635 1
  register struct sockaddr_in6 *sin6;
d637 2
a638 2
  nam->m_len = sizeof(struct sockaddr_in6);
  sin6 = mtod(nam,struct sockaddr_in6 *);
d640 7
a646 7
  bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
  sin6->sin6_family = AF_INET6;
  sin6->sin6_len = sizeof(struct sockaddr_in6);
  sin6->sin6_port = inp->inp_lport;
  sin6->sin6_addr = inp->inp_laddr6;
  /* KAME hack: recover scopeid */
  (void)in6_recoverscope(sin6, &inp->inp_laddr6, NULL);
d648 1
a648 1
  return 0;
d651 1
a651 1
/*----------------------------------------------------------------------
d654 1
a654 2
 ----------------------------------------------------------------------*/

d657 2
a658 2
     register struct inpcb *inp;
     struct mbuf *nam;
d660 1
a660 1
  register struct sockaddr_in6 *sin6;
d662 2
a663 2
  nam->m_len = sizeof(struct sockaddr_in6);
  sin6 = mtod(nam,struct sockaddr_in6 *);
d665 6
a670 6
  bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
  sin6->sin6_family = AF_INET6;
  sin6->sin6_len = sizeof(struct sockaddr_in6);
  sin6->sin6_port = inp->inp_fport;
  sin6->sin6_addr = inp->inp_faddr6;
  sin6->sin6_flowinfo = inp->inp_fflowinfo;
d672 1
a672 1
  return 0;
@


1.17
log
@correct logic mistake in in6_pcbnotify, due to indentation.
will KNF it soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.16 2000/06/18 17:27:05 itojun Exp $	*/
a631 1
	  inp = inp->inp_queue.cqe_next;
@


1.16
log
@use in6_recoverscope
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.15 2000/06/13 10:12:01 itojun Exp $	*/
d619 2
a620 4
	if (IN6_ARE_ADDR_EQUAL(&inp->inp_route6.ro_dst.sin6_addr, faddr)) {
	    {
	      in_rtchange(inp, errno);
	    }
d622 2
a623 3
	  if (notify == in_rtchange)
		  continue;		/* there's nothing to do any more */
	}
@


1.15
log
@allow link-local IPv6 addres in in6_pcbbind.
@
text
@d1 30
a30 1
/*	$OpenBSD: in6_pcb.c,v 1.14 2000/06/03 13:04:39 itojun Exp $	*/
d296 47
a342 29
  if (lport == 0) {
    /* This code block was derived from OpenBSD */
    uint16_t first, last, old = 0;
    int count;
    int loopcount = 0;
    struct in_addr fa, la;
    u_int16_t *lastport;

    lastport = &inp->inp_table->inpt_lastport;

    if (inp->inp_flags & INP_IPV6_MAPPED) {
      la.s_addr = inp->inp_laddr6.s6_addr32[3];
      fa.s_addr = 0;
      wild &= ~INPLOOKUP_IPV6;
    };

    if (inp->inp_flags & INP_HIGHPORT) {
      first = ipport_hifirstauto;	/* sysctl */
      last = ipport_hilastauto;
    } else if (inp->inp_flags & INP_LOWPORT) {
      if ((error = suser(p->p_ucred, &p->p_acflag)))
	return (EACCES);

      first = IPPORT_RESERVED-1; /* 1023 */
      last = 600;		   /* not IPPORT_RESERVED/2 */
    } else {
      first = ipport_firstauto;	/* sysctl */
      last  = ipport_lastauto;
    }
d344 7
a350 7
    /*
     * Simple check to ensure all ports are not used up causing
     * a deadlock here.
     *
     * We split the two cases (up and down) so that the direction
     * is not being tested on each round of the loop.
     */
d353 54
a406 19
    if (first > last) {
      /*
       * counting down
       */
      if (loopcount == 0) {	/* only do this once. */
	old = first;
	first -= (arc4random() % (first - last));
      }
      count = first - last;
      *lastport = first;		/* restart each time */
      
      do {
	if (count-- <= 0) {	/* completely used? */
	  if (loopcount == 0) {
	    last = old;
	    loopcount++;
	    goto portloop;
	  }
	  return (EADDRNOTAVAIL);
a407 42
	--*lastport;
	if (*lastport > first || *lastport < last)
	  *lastport = first;
	lport = htons(*lastport);
      } while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
	       ((wild & INPLOOKUP_IPV6) ?
		in_pcblookup(head, (struct in_addr *)&zeroin6_addr, 0,
			(struct in_addr *)&inp->inp_laddr6, lport, wild) :
		in_pcblookup(head, (struct in_addr *)&fa, 0,
			(struct in_addr *)&la, lport, wild)));
    } else {
      /*
       * counting up
       */
      if (loopcount == 0) {	/* only do this once. */
	old = first;
	first += (arc4random() % (last - first));
      }
      count = last - first;
      *lastport = first;		/* restart each time */
      
      do {
	if (count-- <= 0) {	/* completely used? */
	  if (loopcount == 0) {
	    first = old;
	    loopcount++;
	    goto portloop;
	  }
	  return (EADDRNOTAVAIL);
	}
	++*lastport;
	if (*lastport < first || *lastport > last)
	  *lastport = first;
	lport = htons(*lastport);
      } while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
	       ((wild & INPLOOKUP_IPV6) ?
		in_pcblookup(head, (struct in_addr *)&zeroin6_addr, 0,
			(struct in_addr *)&inp->inp_laddr6, lport, wild) :
		in_pcblookup(head, (struct in_addr *)&fa, 0,
			(struct in_addr *)&la, lport, wild)));
    }
  }
d409 2
a410 1
  inp->inp_lport = lport;
d412 1
a412 2
  /* XXX hash */
  return 0;
d464 1
a464 1
	  return EINVAL;
d584 2
a585 2
   * and use in6_rtchange to invalidate the route cache.
   * Dead host indications: also use in6_rtchange to invalidate
d590 1
d605 1
d607 2
a608 2
      if (!(inp->inp_flags & INP_IPV6))
	  continue;
d610 10
a619 10
      if (do_rtchange)
	{
	  /*
	   * Since a non-connected PCB might have a cached route,
	   * we always call in_rtchange without matching
	   * the PCB to the src/dst pair.
	   *
	   * XXX: we assume in_rtchange does not free the PCB.
	   */
	  if (IN6_ARE_ADDR_EQUAL(&inp->inp_route6.ro_dst.sin6_addr, faddr))
d625 1
a625 3
	    {
	      continue;		/* there's nothing to do any more */
	    }
d627 2
d635 1
a637 1

d641 1
a641 3
	{
	  (*notify)(inp, errno);
	}
d666 3
d693 1
@


1.14
log
@correctly handle ctlinput messages for IPv6.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.13 2000/05/28 23:58:51 itojun Exp $	*/
d156 7
a392 1
	struct in6_pktinfo *pi;
d396 1
d418 9
a426 30
	/*
	 * If the scope of the destination is link-local, embed the interface
	 * index in the address.
	 */
	if (IN6_IS_SCOPE_LINKLOCAL(&sin6->sin6_addr)) {
		/* XXX boundary check is assumed to be already done. */
		/* XXX sin6_scope_id is weaker than advanced-api. */
		if (inp->inp_outputopts6 &&
		    (pi = inp->inp_outputopts6->ip6po_pktinfo) &&
		    pi->ipi6_ifindex) {
			sin6->sin6_addr.s6_addr16[1] = htons(pi->ipi6_ifindex);
			ifp = ifindex2ifnet[pi->ipi6_ifindex];
		}
		else if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr) &&
			 inp->inp_moptions6 &&
			 inp->inp_moptions6->im6o_multicast_ifp) {
			sin6->sin6_addr.s6_addr16[1] =
				htons(inp->inp_moptions6->im6o_multicast_ifp->if_index);
			ifp = ifindex2ifnet[inp->inp_moptions6->im6o_multicast_ifp->if_index];
		} else if (sin6->sin6_scope_id) {
			/* boundary check */
			if (sin6->sin6_scope_id < 0 
			 || if_index < sin6->sin6_scope_id) {
				return ENXIO;  /* XXX EINVAL? */
			}
			sin6->sin6_addr.s6_addr16[1]
				= htons(sin6->sin6_scope_id & 0xffff);/*XXX*/
			ifp = ifindex2ifnet[sin6->sin6_scope_id];
		}
	}
@


1.13
log
@do not treat bind(2) with IPv4 mapped address in a special way.
old code fails to check for port number duplicate.
XXX should remove more IPv4 mapped code
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.12 2000/04/27 09:23:21 itojun Exp $	*/
d174 1
a178 1
	  bzero(&sin.sin_zero,8);
d185 1
a185 1
	  if (ifa_ifwithaddr((struct sockaddr *)sin6) == 0)
d187 1
a187 1
		ifa_ifwithaddr((struct sockaddr *)&sin) == 0)
d189 2
d220 1
d540 1
a540 1
  register struct inpcb *inp, *oinp;
d543 2
a544 1
  int errno;
d558 3
a560 2
   * and use in_rtchange to invalidate the route cache.
   * Dead host indications: notify all references to the destination.
a563 1

d569 2
a570 2
      if (cmd != PRC_HOSTDEAD)
	notify = in_rtchange;
d575 1
a575 1
       inp != (struct inpcb *)&head->inpt_queue;)
d577 1
d579 1
a579 2
      if (!(inp->inp_flags & INP_IPV6)) {
	  inp = inp->inp_queue.cqe_next;
a580 1
      }
d582 19
a606 1
	  inp = inp->inp_queue.cqe_next;
a608 1
      oinp = inp;
d610 2
a611 1
      inp = inp->inp_queue.cqe_next;
d613 3
a615 1
	  (*notify)(oinp, errno);
@


1.12
log
@avoid infinite loop in in{6,}_pcbnotify (can occurs on family mismatch)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.11 2000/04/21 11:42:25 itojun Exp $	*/
d193 1
d195 1
d209 1
d220 1
@


1.11
log
@NRL pcb issue; inp_{f,l}addr{,6} is a union so we need to be sure about
af match.
- do not touch IPv4 pcb entries on in6_pcbnotify.
- do not touch IPv6 pcb entries on in_pcbnotify.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.10 2000/02/28 11:55:22 itojun Exp $	*/
d570 2
a571 1
      if (!(inp->inp_flags & INP_IPV6))
d573 1
@


1.10
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.9 2000/02/07 06:09:10 itojun Exp $	*/
d569 4
@


1.9
log
@fix include file path related to ip6.
@
text
@d1 1
a1 1
/* $OpenBSD: in6_pcb.c,v 1.8 1999/12/10 08:53:17 angelos Exp $ */
@


1.9.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.9.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 30
/*	$OpenBSD: in6_pcb.c,v 1.25 2001/02/16 16:00:56 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
d99 6
a104 6
	0,		0,		0,		0,
	0,		EMSGSIZE,	EHOSTDOWN,	EHOSTUNREACH,
	EHOSTUNREACH,	EHOSTUNREACH,	ECONNREFUSED,	ECONNREFUSED,
	EMSGSIZE,	EHOSTUNREACH,	0,		0,
	0,		0,		0,		0,
	ENOPROTOOPT
d108 1
a108 1
/*
d110 1
a110 1
 */
d113 2
a114 2
	struct inpcb *inp;
	struct mbuf *nam;
d116 1
a116 1
	struct socket *so = inp->inp_socket;
d118 103
a220 6
	struct inpcbtable *head = inp->inp_table;
	struct sockaddr_in6 *sin6;
	struct proc *p = curproc;		/* XXX */
	u_short lport = 0;
	int wild = INPLOOKUP_IPV6, reuseport = (so->so_options & SO_REUSEPORT);
	int error;
d222 2
a223 147
	/*
	 * REMINDER:  Once up to speed, flow label processing should go here,
	 * too.  (Same with in6_pcbconnect.)
	 */
	if (in6_ifaddr == 0 || in_ifaddr == 0)
		return EADDRNOTAVAIL;

	if (inp->inp_lport != 0 || !IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
		return EINVAL;	/* If already bound, EINVAL! */

	if ((so->so_options & (SO_REUSEADDR | SO_REUSEPORT)) == 0 &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
	     (so->so_options & SO_ACCEPTCONN) == 0))
		wild |= INPLOOKUP_WILDCARD;

	/*
	 * If I did get a sockaddr passed in...
	 */
	if (nam) {
		sin6 = mtod(nam, struct sockaddr_in6 *);
		if (nam->m_len != sizeof (*sin6))
			return EINVAL;

		/*
		 * Unlike v4, I have no qualms about EAFNOSUPPORT if the
		 * wretched family is not filled in!
		 */
		if (sin6->sin6_family != AF_INET6)
			return EAFNOSUPPORT;

		/* KAME hack: embed scopeid */
		if (in6_embedscope(&sin6->sin6_addr, sin6, inp, NULL) != 0)
			return EINVAL;
		/* this must be cleared for ifa_ifwithaddr() */
		sin6->sin6_scope_id = 0;

		lport = sin6->sin6_port;

		/* reject IPv4 mapped address, we have no support for it */
		if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
			return EADDRNOTAVAIL;

		if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr)) {
			/*
			 * Treat SO_REUSEADDR as SO_REUSEPORT for multicast;
			 * allow complete duplication of binding if
			 * SO_REUSEPORT is set, or if SO_REUSEADDR is set
			 * and a multicast address is bound on both
			 * new and duplicated sockets.
			 */
			if (so->so_options & SO_REUSEADDR)
				reuseport = SO_REUSEADDR | SO_REUSEPORT;
		} else if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
			struct ifaddr *ia = NULL;

			sin6->sin6_port = 0;  /*
					       * Yechhhh, because of upcoming
					       * call to ifa_ifwithaddr(), which
					       * does bcmp's over the PORTS as
					       * well.  (What about flow?)
					       */
			sin6->sin6_flowinfo = 0;
			if ((ia = ifa_ifwithaddr((struct sockaddr *)sin6))
			    == NULL)
				return EADDRNOTAVAIL;

			/*
			 * XXX: bind to an anycast address might accidentally
			 * cause sending a packet with anycast source address.
			 * We should allow to bind to a deprecated address, since
			 * the application dare to use it.
			 */
			if (ia &&
			    ((struct in6_ifaddr *)ia)->ia6_flags &
			    (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY|IN6_IFF_DETACHED))
				return(EADDRNOTAVAIL);
		}
#if 0 /* we don't support it */
		else if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
			struct sockaddr_in sin;

			bzero(&sin, sizeof(sin));
			sin.sin_port = 0;
			sin.sin_len = sizeof(sin);
			sin.sin_family = AF_INET;
			sin.sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];

			/*
			 * Yechhhh, because of upcoming call to
			 * ifa_ifwithaddr(), which does bcmp's
			 * over the PORTS as well.  (What about flow?)
			 */
			sin6->sin6_port = 0;
			sin6->sin6_flowinfo = 0;
			if (ifa_ifwithaddr((struct sockaddr *)sin6) == 0) {
				if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr) ||
				    ifa_ifwithaddr((struct sockaddr *)&sin) == 0) {
					return EADDRNOTAVAIL;
				}
			}
		}
#endif
		if (lport) {
			struct inpcb *t;
#if 0 /* we don't support IPv4 mapped address */
			struct in_addr fa,la;
#endif

			/*
			 * Question:  Do we wish to continue the Berkeley
			 * tradition of ports < IPPORT_RESERVED be only for
			 * root?
			 * Answer: For now yes, but IMHO, it should be REMOVED!
			 * OUCH: One other thing, is there no better way of
			 * finding a process for a socket instead of using
			 * curproc?  (Marked with BSD's {in,}famous XXX ?
			 */
			if (ntohs(lport) < IPPORT_RESERVED &&
			    (error = suser(p->p_ucred, &p->p_acflag)))
				return error;

#if 0 /* we don't support IPv4 mapped address */
			if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
				fa.s_addr = 0;
				la.s_addr = sin6->sin6_addr.s6_addr32[3];
				wild &= ~INPLOOKUP_IPV6;

				t = in_pcblookup(head, (struct in_addr *)&fa, 0,
				    (struct in_addr *)&la, lport, wild);
			} else
#endif
			{
				t = in_pcblookup(head,
				    (struct in_addr *)&zeroin6_addr, 0,
				    (struct in_addr *)&sin6->sin6_addr, lport,
				    wild);
			}

			if (t && (reuseport & t->inp_socket->so_options) == 0)
				return EADDRINUSE;
		}
		inp->inp_laddr6 = sin6->sin6_addr;

		if (!IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr)) {
			inp->inp_ipv6.ip6_flow = htonl(0x60000000) |
			    (sin6->sin6_flowinfo & htonl(0x0fffffff));
		}
d225 1
d227 23
a249 46
	if (lport == 0) {
		error = in6_pcbsetport(&inp->inp_laddr6, inp);
		if (error != 0)
			return error;
	} else
		inp->inp_lport = lport;

	in_pcbrehash(inp);

	return 0;
}

int
in6_pcbsetport(laddr, inp)
	struct in6_addr *laddr;
	struct inpcb *inp;
{
	struct socket *so = inp->inp_socket;
	struct inpcbtable *table = inp->inp_table;
	u_int16_t first, last, old = 0;
	u_int16_t *lastport = &inp->inp_table->inpt_lastport;
	u_int16_t lport = 0;
	int count;
	int loopcount = 0;
	int wild = INPLOOKUP_IPV6;
	struct proc *p = curproc;		/* XXX */
	int error;

	/* XXX we no longer support IPv4 mapped address, so no tweaks here */

	if ((so->so_options & (SO_REUSEADDR|SO_REUSEPORT)) == 0 &&
	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
	     (so->so_options & SO_ACCEPTCONN) == 0))
		wild |= INPLOOKUP_WILDCARD;

	if (inp->inp_flags & INP_HIGHPORT) {
		first = ipport_hifirstauto;	/* sysctl */
		last = ipport_hilastauto;
	} else if (inp->inp_flags & INP_LOWPORT) {
		if ((error = suser(p->p_ucred, &p->p_acflag)))
			return (EACCES);
		first = IPPORT_RESERVED-1; /* 1023 */
		last = 600;		   /* not IPPORT_RESERVED/2 */
	} else {
		first = ipport_firstauto;	/* sysctl */
		last  = ipport_lastauto;
d251 1
d253 37
a289 7
	/*
	 * Simple check to ensure all ports are not used up causing
	 * a deadlock here.
	 *
	 * We split the two cases (up and down) so that the direction
	 * is not being tested on each round of the loop.
	 */
d292 49
a340 54
	if (first > last) {
		/*
		 * counting down
		 */
		if (loopcount == 0) {	/* only do this once. */
			old = first;
			first -= (arc4random() % (first - last));
		}
		count = first - last;
		*lastport = first;		/* restart each time */

		do {
			if (count-- <= 0) {	/* completely used? */
				if (loopcount == 0) {
					last = old;
					loopcount++;
					goto portloop;
				}
				return (EADDRNOTAVAIL);
			}
			--*lastport;
			if (*lastport > first || *lastport < last)
				*lastport = first;
			lport = htons(*lastport);
		} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
		    in_pcblookup(table, &zeroin6_addr, 0,
		    &inp->inp_laddr6, lport, wild));
	} else {
		/*
		 * counting up
		 */
		if (loopcount == 0) {	/* only do this once. */
			old = first;
			first += (arc4random() % (last - first));
		}
		count = last - first;
		*lastport = first;		/* restart each time */

		do {
			if (count-- <= 0) {	/* completely used? */
				if (loopcount == 0) {
					first = old;
					loopcount++;
					goto portloop;
				}
				return (EADDRNOTAVAIL);
			}
			++*lastport;
			if (*lastport < first || *lastport > last)
				*lastport = first;
			lport = htons(*lastport);
		} while (in_baddynamic(*lastport, so->so_proto->pr_protocol) ||
		    in_pcblookup(table, &zeroin6_addr, 0,
		    &inp->inp_laddr6, lport, wild));
d342 12
d355 1
a355 2
	inp->inp_lport = lport;
	in_pcbrehash(inp);
d357 2
a358 1
	return 0;
d361 1
a361 1
/*
d370 2
a371 1
 */
d374 1
a374 1
	struct inpcb *inp;
d379 1
a382 1
	struct sockaddr_in6 tmp;
a392 4
	/* reject IPv4 mapped address, we have no support for it */
	if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
		return EADDRNOTAVAIL;

d404 30
a433 9
	/* protect *sin6 from overwrites */
	tmp = *sin6;
	sin6 = &tmp;

	/* KAME hack: embed scopeid */
	if (in6_embedscope(&sin6->sin6_addr, sin6, inp, &ifp) != 0)
		return EINVAL;
	/* this must be cleared for ifa_ifwithaddr() */
	sin6->sin6_scope_id = 0;
d436 2
a437 2
	if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6) &&
	    inp->inp_laddr6.s6_addr32[3] == 0) {
d444 1
a444 1
		    sizeof(sin.sin_addr));
d446 1
a446 1
		    inp->inp_socket->so_options, NULL, &error);
d463 3
a465 2
		    inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
		    &error);
d477 7
a483 3
	if (in_pcblookup(inp->inp_table, &sin6->sin6_addr, sin6->sin6_port,
	    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ? in6a : &inp->inp_laddr6,
	    inp->inp_lport, INPLOOKUP_IPV6)) {
d485 3
a487 4
	}
	if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) ||
	    (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6) &&
	     inp->inp_laddr6.s6_addr32[3] == 0)) {
d499 5
d508 1
a508 1
/*
d517 1
a517 1
 * Also perform input-side security policy check
d521 2
a522 1
 */
d524 8
a531 8
in6_pcbnotify(head, dst, fport_arg, src, lport_arg, cmd, cmdarg, notify)
	struct inpcbtable *head;
	struct sockaddr *dst, *src;
	uint fport_arg;
	uint lport_arg;
	int cmd;
	void *cmdarg;
	void (*notify) __P((struct inpcb *, int));
d533 46
a578 89
	struct inpcb *inp, *ninp;
	u_short fport = fport_arg, lport = lport_arg;
	struct sockaddr_in6 sa6_src, *sa6_dst;
	int errno, nmatch = 0;
	u_int32_t flowinfo;

	if ((unsigned)cmd > PRC_NCMDS || dst->sa_family != AF_INET6)
		return 1;

	sa6_dst = (struct sockaddr_in6 *)dst;
	if (IN6_IS_ADDR_UNSPECIFIED(&sa6_dst->sin6_addr))
		return 1;
	if (IN6_IS_ADDR_V4MAPPED(&sa6_dst->sin6_addr))
		printf("Huh?  Thought in6_pcbnotify() never got "
		       "called with mapped!\n");

	/*
	 * note that src can be NULL when we get notify by local fragmentation.
	 */
	sa6_src = (src == NULL) ? sa6_any : *(struct sockaddr_in6 *)src;
	flowinfo = sa6_src.sin6_flowinfo;

	/*
	 * Redirects go to all references to the destination,
	 * and use in_rtchange to invalidate the route cache.
	 * Dead host indications: also use in_rtchange to invalidate
	 * the cache, and deliver the error to all the sockets.
	 * Otherwise, if we have knowledge of the local port and address,
	 * deliver only to that socket.
	 */
	if (PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD) {
		fport = 0;
		lport = 0;
		sa6_src.sin6_addr = in6addr_any;

		if (cmd != PRC_HOSTDEAD)
			notify = in_rtchange;
	}
	errno = inet6ctlerrmap[cmd];

	for (inp = head->inpt_queue.cqh_first;
	     inp != (struct inpcb *)&head->inpt_queue; inp = ninp) {
		ninp = inp->inp_queue.cqe_next;

		if ((inp->inp_flags & INP_IPV6) == 0)
			continue;

		/*
		 * Under the following condition, notify of redirects
		 * to the pcb, without making address matches against inpcb.
		 * - redirect notification is arrived.
		 * - the inpcb is unconnected.
		 * - the inpcb is caching !RTF_HOST routing entry.
		 * - the ICMPv6 notification is from the gateway cached in the
		 *   inpcb.  i.e. ICMPv6 notification is from nexthop gateway
		 *   the inpcb used very recently.
		 *
		 * This is to improve interaction between netbsd/openbsd
		 * redirect handling code, and inpcb route cache code.
		 * without the clause, !RTF_HOST routing entry (which carries
		 * gateway used by inpcb right before the ICMPv6 redirect)
		 * will be cached forever in unconnected inpcb.
		 *
		 * There still is a question regarding to what is TRT:
		 * - On bsdi/freebsd, RTF_HOST (cloned) routing entry will be
		 *   generated on packet output.  inpcb will always cache
		 *   RTF_HOST routing entry so there's no need for the clause
		 *   (ICMPv6 redirect will update RTF_HOST routing entry,
		 *   and inpcb is caching it already).
		 *   However, bsdi/freebsd are vulnerable to local DoS attacks
		 *   due to the cloned routing entries.
		 * - Specwise, "destination cache" is mentioned in RFC2461.
		 *   Jinmei says that it implies bsdi/freebsd behavior, itojun
		 *   is not really convinced.
		 * - Having hiwat/lowat on # of cloned host route (redirect/
		 *   pmtud) may be a good idea.  netbsd/openbsd has it.  see
		 *   icmp6_mtudisc_update().
		 */
		if ((PRC_IS_REDIRECT(cmd) || cmd == PRC_HOSTDEAD) &&
		    IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) &&
		    inp->inp_route.ro_rt &&
		    !(inp->inp_route.ro_rt->rt_flags & RTF_HOST)) {
			struct sockaddr_in6 *dst6;

			dst6 = (struct sockaddr_in6 *)&inp->inp_route.ro_dst;
			if (IN6_ARE_ADDR_EQUAL(&dst6->sin6_addr,
			    &sa6_dst->sin6_addr))
				goto do_notify;
		}
d580 5
a584 29
		/*
		 * Detect if we should notify the error. If no source and
		 * destination ports are specifed, but non-zero flowinfo and
		 * local address match, notify the error. This is the case
		 * when the error is delivered with an encrypted buffer
		 * by ESP. Otherwise, just compare addresses and ports
		 * as usual.
		 */
		if (lport == 0 && fport == 0 && flowinfo &&
		    inp->inp_socket != NULL &&
		    flowinfo == (inp->inp_flowinfo & IPV6_FLOWLABEL_MASK) &&
		    IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6, &sa6_src.sin6_addr))
			goto do_notify;
		else if (!IN6_ARE_ADDR_EQUAL(&inp->inp_faddr6,
					     &sa6_dst->sin6_addr) ||
			 inp->inp_socket == 0 ||
			 (lport && inp->inp_lport != lport) ||
			 (!IN6_IS_ADDR_UNSPECIFIED(&sa6_src.sin6_addr) &&
			  !IN6_ARE_ADDR_EQUAL(&inp->inp_laddr6,
					      &sa6_src.sin6_addr)) ||
			 (fport && inp->inp_fport != fport)) {
			continue;
		}
	  do_notify:
		nmatch++;
		if (notify)
			(*notify)(inp, errno);
	}
	return 0;
d587 1
a587 1
/*
d590 2
a591 1
 */
d594 2
a595 2
	struct inpcb *inp;
	struct mbuf *nam;
d597 1
a597 4
	struct sockaddr_in6 *sin6;

	nam->m_len = sizeof(struct sockaddr_in6);
	sin6 = mtod(nam,struct sockaddr_in6 *);
d599 2
a600 7
	bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
	sin6->sin6_family = AF_INET6;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_port = inp->inp_lport;
	sin6->sin6_addr = inp->inp_laddr6;
	/* KAME hack: recover scopeid */
	(void)in6_recoverscope(sin6, &inp->inp_laddr6, NULL);
d602 6
a607 1
	return 0;
d610 1
a610 1
/*
d613 2
a614 1
 */
d617 2
a618 2
	struct inpcb *inp;
	struct mbuf *nam;
d620 1
a620 4
	struct sockaddr_in6 *sin6;

	nam->m_len = sizeof(struct sockaddr_in6);
	sin6 = mtod(nam,struct sockaddr_in6 *);
d622 2
a623 5
	bzero ((caddr_t)sin6,sizeof(struct sockaddr_in6));
	sin6->sin6_family = AF_INET6;
	sin6->sin6_len = sizeof(struct sockaddr_in6);
	sin6->sin6_port = inp->inp_fport;
	sin6->sin6_addr = inp->inp_faddr6;
d625 7
a631 1
	return 0;
@


1.9.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.9.2.2 2001/05/14 22:40:17 niklas Exp $	*/
d33 8
a40 38
 *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995
 * 
 * NRL grants permission for redistribution and use in source and binary
 * forms, with or without modification, of the software and documentation
 * created at NRL provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgements:
 * 	This product includes software developed by the University of
 * 	California, Berkeley and its contributors.
 * 	This product includes software developed at the Information
 * 	Technology Division, US Naval Research Laboratory.
 * 4. Neither the name of the NRL nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * The views and conclusions contained in the software and documentation
 * are those of the authors and should not be interpreted as representing
 * official policies, either expressed or implied, of the US Naval
 * Research Laboratory (NRL).
 */
d42 1
@


1.9.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d260 25
d287 3
d304 16
a319 4
			t = in_pcblookup(head,
			    (struct in_addr *)&zeroin6_addr, 0,
			    (struct in_addr *)&sin6->sin6_addr, lport,
			    wild);
@


1.9.2.5
log
@Merge in -current from roughly a week ago
@
text
@d553 1
a553 1
	void (*notify)(struct inpcb *, int);
@


1.9.2.6
log
@Sync the SMP branch with 3.3
@
text
@d250 4
a253 11
			 * bind to an anycast address might accidentally
			 * cause sending a packet with an anycast source
			 * address, so we forbid it.
			 *
			 * We should allow to bind to a deprecated address,
			 * since the application dare to use it.
			 * But, can we assume that they are careful enough
			 * to check if the address is deprecated or not?
			 * Maybe, as a safeguard, we should have a setsockopt
			 * flag to control the bind(2) behavior against
			 * deprecated addresses (default: forbid bind(2)).
d258 1
a258 1
				return (EADDRNOTAVAIL);
d293 1
a293 1
		error = in6_pcbsetport(&inp->inp_laddr6, inp, p);
d305 1
a305 1
in6_pcbsetport(laddr, inp, p)
a307 1
	struct proc *p;
d317 1
d436 1
a436 1
		return (EINVAL);
d438 1
a438 1
		return (EAFNOSUPPORT);
d440 1
a440 1
		return (EADDRNOTAVAIL);
d482 1
a482 1
			return (error);
d500 1
a500 1
			return (error);
d511 1
a511 1
		return (EADDRINUSE);
d528 1
a528 1
	return (0);
d647 1
a647 1
		 * destination ports are specified, but non-zero flowinfo and
a719 2
	/* KAME hack: recover scopeid */
	(void)in6_recoverscope(sin6, &inp->inp_faddr6, NULL);
@


1.9.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: in6_pcb.c,v 1.9.2.6 2003/03/28 00:41:29 niklas Exp $	*/
d84 5
a88 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d276 1
a276 1
			    (error = suser(p, 0)))
d288 5
d299 1
a299 1
	} else {
d301 2
a302 2
		in_pcbrehash(inp);
	}
d334 1
a334 1
		if ((error = suser(p, 0)))
a410 4
#if 0
	inp->inp_flowinfo = 0;	/* XXX */
#endif

d525 5
a529 4
	inp->inp_flowinfo &= ~IPV6_FLOWLABEL_MASK;
	if (ip6_auto_flowlabel)
		inp->inp_flowinfo |=
		    (htonl(ip6_randomflowlabel()) & IPV6_FLOWLABEL_MASK);
d564 2
a565 2
	if ((unsigned)cmd >= PRC_NCMDS || dst->sa_family != AF_INET6)
		return (0);
d569 1
a569 1
		return (0);
d598 3
a600 3
	for (inp = CIRCLEQ_FIRST(&head->inpt_queue);
	     inp != CIRCLEQ_END(&head->inpt_queue); inp = ninp) {
		ninp = CIRCLEQ_NEXT(inp, inp_queue);
d676 1
a676 1
	return (nmatch);
@


1.9.2.9
log
@Merge with the trunk
@
text
@d133 1
d183 1
a183 1
	if (in6_ifaddr == 0)
d432 1
d449 9
a457 2
	if (IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
		return EINVAL;
d470 34
a503 12
	/*
	 * XXX: in6_selectsrc might replace the bound local address
	 * with the address specified by setsockopt(IPV6_PKTINFO).
	 * Is it the intended behavior?
	 */
	in6a = in6_selectsrc(sin6, inp->inp_outputopts6,
	    inp->inp_moptions6, &inp->inp_route6, &inp->inp_laddr6,
	    &error);
	if (in6a == 0) {
		if (error == 0)
			error = EADDRNOTAVAIL;
		return (error);
a504 1

d515 3
a517 1
	if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) {
d568 1
a568 2
	if (IN6_IS_ADDR_V4MAPPED(&sa6_dst->sin6_addr)) {
#ifdef DIAGNOSTIC
a570 3
#endif
		return (0);
	}
@


1.8
log
@Add RCS tags, remove unused header files and code, remove a few
unnecessary ifdefs...
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d69 1
a69 1
#include <netinet6/ip6.h>
@


1.7
log
@Removed about 24KB of ifdef'ed code. It's nice to be able to see what
other OSes do, but not if I can't read our code.
@
text
@d1 2
@


1.6
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@a45 4
#if __FreeBSD__
#include <sys/queue.h>
#endif /* __FreeBSD__ */

a53 1
/*#include <sys/ioctl.h>*/
a69 27
#if __OpenBSD__
#undef IPSEC
#ifdef NRL_IPSEC
#define IPSEC 1
#endif /* NRL_IPSEC */
#endif /* __OpenBSD__ */

#ifdef IPSEC
#include <sys/osdep.h>
#include <net/netproc.h>
#include <net/netproc_var.h>
#endif /* IPSEC */

#if defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802)
#include <machine/pcpu.h>
#endif /* defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802) */

#ifdef DEBUG_NRL
#include <sys/debug.h>
#else /* DEBUG_NRL */
#if __OpenBSD__
#include <netinet6/debug.h>
#else /* __OpenBSD__ */
#include <sys/debug.h>
#endif /* __OpenBSD__ */
#endif /* DEBUG_NRL */

a73 1
#if __OpenBSD__
a74 15
#endif /* __OpenBSD__ */

#if __FreeBSD__
/*
 * These configure the range of local port addresses assigned to
 * "unspecified" outgoing connections/packets/whatever.
 */
static int ipport_lowfirstauto  = IPPORT_RESERVED - 1;	/* 1023 */
static int ipport_lowlastauto = IPPORT_RESERVEDSTART;	/* 600 */
static int ipport_firstauto = IPPORT_RESERVED;		/* 1024 */
static int ipport_lastauto  = IPPORT_USERRESERVED;	/* 5000 */
static int ipport_hifirstauto = IPPORT_HIFIRSTAUTO;	/* 49152 */
static int ipport_hilastauto  = IPPORT_HILASTAUTO;	/* 65535 */
extern void in_rtchange(struct inpcb *, int);
#endif /* __FreeBSD__ */
a76 4
#if __FreeBSD__
int in6_pcbladdr(register struct inpcb *, struct sockaddr *, struct sockaddr **);
extern  TAILQ_HEAD(in_ifaddrhead, in_ifaddr) in_ifaddrhead;
#else /* __FreeBSD__ */
d78 1
a78 1
#endif /* __FreeBSD__ */
a84 1
#if __OpenBSD__
a88 1
#endif /* __OpenBSD__ */
a111 3
#if __FreeBSD__
     struct sockaddr *nam;
#else /* __FreeBSD__ */
a112 1
#endif /* __FreeBSD__ */
a115 1
#if __NetBSD__ || __OpenBSD__
a116 7
#else /* __OpenBSD__ */
#ifndef __FreeBSD__
  register struct inpcb *head = inp->inp_head;
#else /* __FreeBSD__ */
    struct inpcbinfo *pcbinfo = inp->inp_pcbinfo;
#endif /* __FreeBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */
a117 1
#if !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802)
a118 3
#else /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */
  struct proc *p = PCPU(curproc);		/* XXX */
#endif /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */
a127 4
#if __FreeBSD__
  if (in6_ifaddr == 0 || in_ifaddrhead.tqh_first == 0)
    return EADDRNOTAVAIL;
#else /* __FreeBSD__ */
d130 1
a130 1
#endif/* __FreeBSD__ */
a143 5
#if __FreeBSD__
      sin6 = (struct sockaddr_in6 *)nam;
      if (nam->sa_len != sizeof (*sin6))
	return EINVAL;
#else /* __FreeBSD__ */
a146 1
#endif /* __FreeBSD__ */
a210 8
#if __FreeBSD__
	      t = in_pcblookup_local(inp->inp_pcbinfo, 
			       (struct in_addr *)&la, lport, wild);
#else /* __FreeBSD__ */
#if __NetBSD__
	      t = in_pcblookup_port(inp->inp_table, (struct in_addr *)&la,
				    lport, wild);
#else /* __NetBSD__ */
a212 3
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */

a215 8
#if __FreeBSD__
	      t = in_pcblookup_local(inp->inp_pcbinfo, 
			(struct in_addr *)&sin6->sin6_addr, lport, wild);
#else /* __FreeBSD__ */
#if __NetBSD__
	      t = in_pcblookup_port(inp->inp_table,
			          (struct in_addr *)&in6addr_any, lport, wild);
#else /* __NetBSD__ */
a217 2
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */
a257 2
#if defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802)
    u_int16_t last_port = head->inp_lport;
a258 3
    lastport = &last_port;
#endif /* defined(_BSDI_VERSION) && (_BSDI_VERSION >= 199802) */
#if __NetBSD__ || __OpenBSD__
a259 1
#endif /* __NetBSD__ || __OpenBSD__ */
a266 5
#if __OpenBSD__ || __FreeBSD__
#if __FreeBSD__
    inp->inp_flags |= INP_ANONPORT;
#endif /* __FreeBSD__ */

a269 3
#if __FreeBSD__
      lastport = &pcbinfo->lasthi;
#endif /* __FreeBSD__ */
d273 1
a273 5
#if __FreeBSD__
      first = ipport_lowfirstauto;
      last = ipport_lowlastauto;
      lastport = &pcbinfo->lastlow;
#else /* __FreeBSD__ */
a275 1
#endif /* __FreeBSD__ */
a278 3
#if __FreeBSD__
      lastport = &pcbinfo->lastport;
#endif /* __FreeBSD__ */
a279 9
#else /* __OpenBSD__ */
#if __bsdi__
    first = IPPORT_DYNAMIC;
    last = IPPORT_DYNAMIC_LAST;
#else /* __bsdi__ */
    first = IPPORT_RESERVED;
    last = IPPORT_USERRESERVED;
#endif /* __bsdi__ */
#endif /* __OpenBSD__ */
a295 1
#if __OpenBSD__
a296 3
#else /* __OpenBSD__ */
	first -= (random() % (first - last));
#endif /* __OpenBSD__ */
a313 1
#if __OpenBSD__
a314 3
#else /* __OpenBSD__ */
      } while (
#endif /* __OpenBSD__ */
a315 11
#ifdef __FreeBSD__ 
		in_pcblookup_local(pcbinfo,
			(struct in_addr *)&inp->inp_laddr6, lport, wild) :
		in_pcblookup_local(pcbinfo,
			(struct in_addr *)&la, lport, wild)));
#else /* __FreeBSD__ */
#if __NetBSD__
		in_pcblookup_port(head, (struct in_addr *)&inp->inp_laddr6,
				  lport, wild) :
		in_pcblookup_port(head, (struct in_addr *)&la, lport, wild)));
#else /* __NetBSD__ */
a319 2
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */
a325 1
#if __OpenBSD__
a326 3
#else /* __OpenBSD__ */
	first += (random() % (last - first));
#endif /* __OpenBSD__ */
a343 1
#if __OpenBSD__
a344 3
#else /* __OpenBSD__ */
      } while (
#endif /* __OpenBSD__ */
a345 11
#ifdef __FreeBSD__ 
		in_pcblookup_local(pcbinfo,
			(struct in_addr *)&inp->inp_laddr6, lport, wild) :
		in_pcblookup_local(pcbinfo,
			(struct in_addr *)&la, lport, wild)));
#else /* __FreeBSD__ */
#if __NetBSD__
		in_pcblookup_port(head, (struct in_addr *)&inp->inp_laddr6,
		  lport, wild) :
		in_pcblookup_port(head, (struct in_addr *)&la, lport, wild)));
#else /* __NetBSD__ */
a349 2
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */
a354 22
#if __FreeBSD__ 
#if 0
	 inp->inp_laddr.s_addr = inp->inp_laddr6.s6_addr32[3]
	                       ^ inp->inp_laddr6.s6_addr32[1];
  	/* 
	 * If this is FreeBSD then it requires the inpcb structure to be 
	 * inserted into various hash-tables.  Right now this is copies 
	 * directly from FreeBSD's source, but this will have to change for
	 * v6 addresses soon I think.  We're still not sure if word2 XOR word4
	 * is a good subject for the hash function.
	 */
#endif /* 0 */
	if (in_pcbinshash(inp) != 0) {
		bzero(&inp->inp_laddru, sizeof(inp->inp_laddru));
		inp->inp_lport = 0;
		return (EAGAIN);
	}
#endif /* __FreeBSD__ */
#if __NetBSD__
  in_pcbstate(inp, INP_BOUND);
#endif /* __NetBSD__ */

a359 270
 * This is maximum suckage point value.  This function is the first 
 * half or so of in6_pcbconnect.  It exists because FreeBSD's code 
 * supports this function for T/TCP.  If we want TCP to work with our 
 * code it must be supported. 
 ----------------------------------------------------------------------*/
#if __FreeBSD__ 
int
in6_pcbladdr(inp, nam, plocal_sin)
	 register struct inpcb *inp;
	 struct sockaddr *nam;
	 struct sockaddr **plocal_sin;
{

  struct in6_ifaddr *i6a;
  struct sockaddr_in  *ifaddr = NULL;

  register struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)nam;
  if (nam->sa_len != sizeof(struct sockaddr_in6))
    return (EINVAL);
    
  if (sin6->sin6_family != AF_INET6)
    return (EAFNOSUPPORT);
  if (sin6->sin6_port == 0)
    return (EADDRNOTAVAIL);


  if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
    {
      struct domain hackdomain, *save;
      struct sockaddr_in *sin;
      int rc;

      /*
       * FreeBSD doesn't want an mbuf to pcbconnect.
       */
      struct sockaddr_in hacksin;

      /*
       * Hmmm, if this is a v4-mapped v6 address, re-call in_pcbconnect
       * with a fake domain for now.  Then re-adjust the socket, and
       * return out of here.  Since this is called at splnet(), I don't
       * think temporarily altering the socket will matter.  XXX
       */

      /*
       * Can't have v6 talking to v4, now can we!
       */
      if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) && 
	  !IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
	return EINVAL;  

      bzero(&hackdomain,sizeof(hackdomain));
      save = inp->inp_socket->so_proto->pr_domain;
      inp->inp_socket->so_proto->pr_domain = &hackdomain;
      hackdomain.dom_family = PF_INET;

      sin = &hacksin;
      sin->sin_len = sizeof(*sin);
      sin->sin_family = AF_INET;
      sin->sin_port = sin6->sin6_port;
      sin->sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];

      /* CHANGE */
      rc = in_pcbladdr(inp, (struct sockaddr *) sin, &ifaddr);

      inp->inp_socket->so_proto->pr_domain = save;

      if (rc == 0)
	{
	  inp->inp_laddr6.s6_addr32[2] = htonl(0xffff);
	  inp->inp_faddr6.s6_addr32[2] = htonl(0xffff);
	  inp->inp_flags |= INP_IPV6_MAPPED;
	  inp->inp_flags &= ~INP_IPV6_UNDEC;
	}
      *plocal_sin = (struct sockaddr *)ifaddr;

      return rc;
    }

  if (in6_ifaddr && IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))
    {
      /*
       * If the destination address is all 0's,
       * use the first non-loopback (and if possibly, non-link-local, else
       * use the LAST link-local, non-loopback) address as the destination.
       */
#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
#define sin6tosa(sin6)	((struct sockaddr *)(sin6))
#define ifatoi6a(ifa)	((struct in6_ifaddr *)(ifa))
      struct in6_ifaddr *ti6a = NULL;

      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
        {
          /* Find first (non-link-local if possible) address for
             source usage.  If multiple link-locals, use last one found. */
	  if (IN6_IS_ADDR_LINKLOCAL(&IA6_SIN6(i6a)->sin6_addr))
	    ti6a=i6a;
	  else if (!IN6_IS_ADDR_LOOPBACK(&IA6_SIN6(i6a)->sin6_addr))
	    break;
        }
      if (i6a == NULL && ti6a != NULL)
	i6a = ti6a;
    }

  if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
    {
      register struct route_in6 *ro;

      i6a = NULL;
      /* 
       * If route is known or can be allocated now,
       * our src addr is taken from the rt_ifa, else punt.
       */
      ro = &inp->inp_route6;
      if (ro->ro_rt &&
	  (ro->ro_dst.sin6_family != sin6->sin6_family ||	
	   rt_key(ro->ro_rt)->sa_family != sin6->sin6_family ||
	   !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, &sin6->sin6_addr) ||
	   inp->inp_socket->so_options & SO_DONTROUTE))
	{
	  RTFREE(ro->ro_rt);
	  ro->ro_rt = NULL;
	}
      if ((inp->inp_socket->so_options & SO_DONTROUTE) == 0 && /*XXX*/
	  (ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL))
	{
	  /* No route yet, try and acquire one. */
	  ro->ro_dst.sin6_family = AF_INET6;  /* Is ro blanked out? */
	  ro->ro_dst.sin6_len = sizeof(struct sockaddr_in6);
	  ro->ro_dst.sin6_addr = sin6->sin6_addr;
	  /* 
	   *  Need to wipe out the flowlabel for ifa_ifwith*
	   *  but don't need to for rtalloc.
	   */
	  rtalloc((struct route *)ro);
	}

#if 0 /* NRL IPv6*/
      if (ro->ro_rt == NULL)
	{
	  /*
	   * No route of any kind, so spray neighbor solicits out all
	   * interfaces, unless it's a multicast address.
	   */
	  if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))
	    return ENETUNREACH;
	  ipv6_onlink_query((struct sockaddr_in6 *)&ro->ro_dst);
	  rtalloc((struct route *)ro);
	}
#endif
      if (ro->ro_rt == NULL)
	{
	  /*
	   * ipv6_onlink_query() should've added a route.  It probably
	   * failed.
	   */
	  DPRINTF(IDL_GROSS_EVENT, ("v6_output: onlink_query didn't add route!\n"));
	  return ENETUNREACH;
	}

      if (ro->ro_rt->rt_ifa == NULL)
	{
	  /*
	   * We have a route where we don't quite know which interface 
	   * the neighbor belongs to yet.  If I get here, I know that this
	   * route is not pre-allocated (such as done by in6_pcbconnect()),
	   * because those pre-allocators will do the same ipv6_onlink_query()
	   * and ipv6_verify_onlink() in advance.
	   *
	   * I can therefore free the route, and get it again.
	   */
	  int error;

	  RTFREE(ro->ro_rt);
	  ro->ro_rt = NULL;
	  switch (error = ipv6_verify_onlink(&ro->ro_dst))
	    {
	    case -1:
	      return ENETUNREACH;
	    case 0:
	      break;
	    default:
	      return error;
	    }
	  rtalloc((struct route *)ro);
	  if (ro->ro_rt == NULL || ro->ro_rt->rt_ifa == NULL)
	    panic("Oops2, I'm forgetting something after verify_onlink().");
	}


      /*
       * If we found a route, use the address
       * corresponding to the outgoing interface
       * unless it is the loopback (in case a route
       * to our address on another net goes to loopback).
       *
       * This code may be simplified if the above gyrations work.
       */
      if (ro->ro_rt && ro->ro_rt->rt_ifp &&
		!(ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK))
	i6a = ifatoi6a(ro->ro_rt->rt_ifa);
      if (i6a == NULL)
	{
	  u_short fport = sin6->sin6_port;

	  /*
	   * Source address selection when there is no route.
	   *
	   * If ND out all if's is to be used, this is the point to do it.
	   * (Similar to when the route lookup fails in ipv6_output.c, and
	   * the 'on-link' assumption kicks in.)
	   *
	   * For multicast, use i6a of mcastdef.
	   */

	  sin6->sin6_port = 0;
	  i6a = ifatoi6a(ifa_ifwithdstaddr(sin6tosa(sin6)));
	  if (i6a == NULL)
	    i6a = ifatoi6a(ifa_ifwithnet(sin6tosa(sin6)));
	  sin6->sin6_port = fport;
	  if (i6a == NULL)
	    {
	      struct in6_ifaddr *ti6a = NULL;
	      
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
		{
		  /* Find first (non-local if possible) address for
		     source usage.  If multiple locals, use last one found. */
		  if (IN6_IS_ADDR_LINKLOCAL(&IA6_SIN6(i6a)->sin6_addr))
		    ti6a=i6a;
		  else if (!IN6_IS_ADDR_LOOPBACK(&IA6_SIN6(i6a)->sin6_addr))
		    break;
		}
	      if (i6a == NULL && ti6a != NULL)
		i6a = ti6a;
	    }
	  if (i6a == NULL)
	    return EADDRNOTAVAIL;
	}

      /*
       * If I'm "connecting" to a multicast address, gyrate properly to
       * get a source address based upon the user-requested mcast interface.
       */
      if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr) && inp->inp_moptions6 != NULL &&
	  (inp->inp_flags & INP_IPV6_MCAST))
	{
	  struct ip6_hdr_moptions *im6o;
	  struct ifnet *ifp;
	  
	  im6o = inp->inp_moptions6;
	  if (im6o->im6o_multicast_ifp != NULL)
	    {
	      ifp = im6o->im6o_multicast_ifp;
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
		if (i6a->ia_ifp == ifp)  /* Linkloc vs. global? */
		  break;
	      if (i6a == NULL)
		return EADDRNOTAVAIL;
	    }
	}

      *plocal_sin = (struct sockaddr *)&i6a->i6a_addr;
    }

    return (0);
}
#endif /* __FreeBSD__ */

/*----------------------------------------------------------------------
a372 3
#if __FreeBSD__
	struct sockaddr *nam;
#else /* __FreeBSD__ */
a373 343
#endif /* __FreeBSD__ */
#if 0
{
  struct in6_ifaddr *i6a;
  struct sockaddr_in6 *ifaddr = NULL;

#if __FreeBSD__
  register struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)nam;
#else /* __FreeBSD__ */
  register struct sockaddr_in6 *sin6 = mtod(nam, struct sockaddr_in6 *);
  if (nam->m_len != sizeof(struct sockaddr_in6))
    return (EINVAL);
#endif /* __FreeBSD__ */

  if (sin6->sin6_len != sizeof(struct sockaddr_in6))
    return (EINVAL);
  if (sin6->sin6_family != AF_INET6)
    return (EAFNOSUPPORT);
  if (sin6->sin6_port == 0)
    return (EADDRNOTAVAIL);

  if (IN6_IS_ADDR_V4MAPPED(&sin6->sin6_addr))
    {
      struct domain hackdomain, *save;
      struct mbuf hackmbuf;
      struct sockaddr_in *sin;
      int rc;

#if __FreeBSD__ 
      /*
       * FreeBSD doesn't want an mbuf to pcbconnect.
       */
      struct sockaddr_in hacksin;
#endif /* __FreeBSD__ */

      /*
       * Hmmm, if this is a v4-mapped v6 address, re-call in_pcbconnect
       * with a fake domain for now.  Then re-adjust the socket, and
       * return out of here.  Since this is called at splnet(), I don't
       * think temporarily altering the socket will matter.  XXX
       */

      /*
       * Can't have v6 talking to v4, now can we!
       */
      if (!IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6) && 
	  !IN6_IS_ADDR_V4MAPPED(&inp->inp_laddr6))
	return EINVAL;  

      bzero(&hackdomain,sizeof(hackdomain));
      bzero(&hackmbuf,sizeof(hackmbuf));
      save = inp->inp_socket->so_proto->pr_domain;
      inp->inp_socket->so_proto->pr_domain = &hackdomain;
      hackdomain.dom_family = PF_INET;
#ifndef __FreeBSD__ 
      hackmbuf.m_hdr = nam->m_hdr;
#endif /* __FreeBSD__ */
      hackmbuf.m_len = sizeof(*sin);
      hackmbuf.m_data = hackmbuf.m_dat;

#if __FreeBSD__ 
      sin = &hacksin;
#else /* __FreeBSD__ */
      sin = mtod(&hackmbuf,struct sockaddr_in *);
#endif /* __FreeBSD__ */
      sin->sin_len = sizeof(*sin);
      sin->sin_family = AF_INET;
      sin->sin_port = sin6->sin6_port;
      sin->sin_addr.s_addr = sin6->sin6_addr.s6_addr32[3];

#if __FreeBSD__
  {
#if !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802)
  struct proc *p = curproc;		/* XXX */
#else /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */
  struct proc *p = PCPU(curproc);		/* XXX */
#endif /* !defined(_BSDI_VERSION) || (_BSDI_VERSION < 199802) */
      rc = in_pcbconnect(inp, (struct sockaddr *) sin, p);
  }
#else /* __FreeBSD__ */
      rc = in_pcbconnect(inp,&hackmbuf);
#endif /* __FreeBSD__ */

      inp->inp_socket->so_proto->pr_domain = save;

      if (rc == 0)
	{
	  inp->inp_laddr6.s6_addr32[2] = htonl(0xffff);
	  inp->inp_faddr6.s6_addr32[2] = htonl(0xffff);
	  inp->inp_flags |= INP_IPV6_MAPPED;
	  inp->inp_flags &= ~INP_IPV6_UNDEC;
	}

      return rc;
    }

  if (in6_ifaddr && IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr))
    {
      /*
       * If the destination address is all 0's,
       * use the first non-loopback (and if possibly, non-link-local, else
       * use the LAST link-local, non-loopback) address as the destination.
       */
#define	satosin6(sa)	((struct sockaddr_in6 *)(sa))
#define sin6tosa(sin6)	((struct sockaddr *)(sin6))
#define ifatoi6a(ifa)	((struct in6_ifaddr *)(ifa))
      struct in6_ifaddr *ti6a = NULL;

      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
        {
          /* Find first (non-link-local if possible) address for
             source usage.  If multiple link-locals, use last one found. */
	  if (IN6_IS_ADDR_LINKLOCAL(&IA6_SIN6(i6a)->sin6_addr))
	    ti6a=i6a;
	  else if (!IN6_IS_ADDR_LOOPBACK(&IA6_SIN6(i6a)->sin6_addr))
	    break;
        }
      if (i6a == NULL && ti6a != NULL)
	i6a = ti6a;
    }

  if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
    {
      register struct route_in6 *ro;

      i6a = NULL;
      /* 
       * If route is known or can be allocated now,
       * our src addr is taken from the rt_ifa, else punt.
       */
      ro = &inp->inp_route6;
      if (ro->ro_rt &&
	  (ro->ro_dst.sin6_family != sin6->sin6_family ||	
	   rt_key(ro->ro_rt)->sa_family != sin6->sin6_family ||
	   !IN6_ARE_ADDR_EQUAL(&ro->ro_dst.sin6_addr, &sin6->sin6_addr) ||
	   inp->inp_socket->so_options & SO_DONTROUTE))
	{
	  RTFREE(ro->ro_rt);
	  ro->ro_rt = NULL;
	}
      if ((inp->inp_socket->so_options & SO_DONTROUTE) == 0 && /*XXX*/
	  (ro->ro_rt == NULL || ro->ro_rt->rt_ifp == NULL))
	{
	  /* No route yet, try and acquire one. */
	  ro->ro_dst.sin6_family = AF_INET6;  /* Is ro blanked out? */
	  ro->ro_dst.sin6_len = sizeof(struct sockaddr_in6);
	  ro->ro_dst.sin6_addr = sin6->sin6_addr;
	  /* 
	   *  Need to wipe out the flowlabel for ifa_ifwith*
	   *  but don't need to for rtalloc.
	   */
	  rtalloc((struct route *)ro);
	}

#if 0 /* NRL IPv6*/
      if (ro->ro_rt == NULL)
	{
	  /*
	   * No route of any kind, so spray neighbor solicits out all
	   * interfaces, unless it's a multicast address.
	   */
	  if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr))
	    return ENETUNREACH;
	  ipv6_onlink_query((struct sockaddr_in6 *)&ro->ro_dst);
	  rtalloc((struct route *)ro);
	}
#endif
      if (ro->ro_rt == NULL)
	{
	  /*
	   * ipv6_onlink_query() should've added a route.  It probably
	   * failed.
	   */
	  DPRINTF(GROSSEVENT, ("v6_output: onlink_query didn't add route!\n"));
	  return ENETUNREACH;
	}

#if 0	/*NRL IPv6*/
      if (ro->ro_rt->rt_ifa == NULL)
	{
	  /*
	   * We have a route where we don't quite know which interface 
	   * the neighbor belongs to yet.  If I get here, I know that this
	   * route is not pre-allocated (such as done by in6_pcbconnect()),
	   * because those pre-allocators will do the same ipv6_onlink_query()
	   * and ipv6_verify_onlink() in advance.
	   *
	   * I can therefore free the route, and get it again.
	   */
	  int error;

	  RTFREE(ro->ro_rt);
	  ro->ro_rt = NULL;
	  switch (error = ipv6_verify_onlink(&ro->ro_dst))
	    {
	    case -1:
	      return ENETUNREACH;
	    case 0:
	      break;
	    default:
	      return error;
	    }
	  rtalloc((struct route *)ro);
	  if (ro->ro_rt == NULL || ro->ro_rt->rt_ifa == NULL)
	    panic("Oops2, I'm forgetting something after verify_onlink().");
	}
#endif


      /*
       * If we found a route, use the address
       * corresponding to the outgoing interface
       * unless it is the loopback (in case a route
       * to our address on another net goes to loopback).
       *
       * This code may be simplified if the above gyrations work.
       */
      if (ro->ro_rt && ro->ro_rt->rt_ifp &&
		!(ro->ro_rt->rt_ifp->if_flags & IFF_LOOPBACK))
	i6a = ifatoi6a(ro->ro_rt->rt_ifa);
      if (i6a == NULL)
	{
	  u_short fport = sin6->sin6_port;

	  /*
	   * Source address selection when there is no route.
	   *
	   * If ND out all if's is to be used, this is the point to do it.
	   * (Similar to when the route lookup fails in ipv6_output.c, and
	   * the 'on-link' assumption kicks in.)
	   *
	   * For multicast, use i6a of mcastdef.
	   */

	  sin6->sin6_port = 0;
	  i6a = ifatoi6a(ifa_ifwithdstaddr(sin6tosa(sin6)));
	  if (i6a == NULL)
	    i6a = ifatoi6a(ifa_ifwithnet(sin6tosa(sin6)));
	  sin6->sin6_port = fport;
	  if (i6a == NULL)
	    {
	      struct in6_ifaddr *ti6a = NULL;
	      
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
		{
		  /* Find first (non-local if possible) address for
		     source usage.  If multiple locals, use last one found. */
		  if (IN6_IS_ADDR_LINKLOCAL(&IA6_SIN6(i6a)->sin6_addr))
		    ti6a=i6a;
		  else if (!IN6_IS_ADDR_LOOPBACK(&IA6_SIN6(i6a)->sin6_addr))
		    break;
		}
	      if (i6a == NULL && ti6a != NULL)
		i6a = ti6a;
	    }
	  if (i6a == NULL)
	    return EADDRNOTAVAIL;
	}

      /*
       * If I'm "connecting" to a multicast address, gyrate properly to
       * get a source address based upon the user-requested mcast interface.
       */
      if (IN6_IS_ADDR_MULTICAST(&sin6->sin6_addr) && inp->inp_moptions6 != NULL &&
	  (inp->inp_flags & INP_IPV6_MCAST))
	{
	  struct ip6_moptions *im6o;
	  struct ifnet *ifp;
	  
	  im6o = inp->inp_moptions6;
	  if (im6o->im6o_multicast_ifp != NULL)
	    {
	      ifp = im6o->im6o_multicast_ifp;
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->ia_next)
		if (i6a->ia_ifp == ifp)  /* Linkloc vs. global? */
		  break;
	      if (i6a == NULL)
		return EADDRNOTAVAIL;
	    }
	}

      ifaddr = (struct sockaddr_in6 *)&i6a->ia_addr;
    }

#if __FreeBSD__
  if (in_pcblookup_hash(inp->inp_pcbinfo,
    ((IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) ?
    	(struct in_addr *)&ifaddr->sin6_addr :
	(struct in_addr *)&inp->inp_laddr6),
    	sin6->sin6_port, (struct in_addr *)&sin6->sin6_addr,
	inp->inp_lport, INPLOOKUP_IPV6)) return EADDRINUSE;
#else /* __FreeBSD__ */
#if __NetBSD__
  if (in6_pcblookup_connect(inp->inp_table,
    ((IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) ? &ifaddr->sin6_addr :
    &inp->inp_laddr6), sin6->sin6_port, &sin6->sin6_addr, inp->inp_lport))
     return EADDRINUSE;
#else /* __NetBSD__ */
#ifdef __OpenBSD__
  if (in_pcblookup(inp->inp_table, ((IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) ?
#else /* __OpenBSD__ */
  if (in_pcblookup(inp->inp_head, ((IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6)) ?
#endif /* __OpenBSD__ */
    	(struct in_addr *)&ifaddr->sin6_addr :
	(struct in_addr *)&inp->inp_laddr6),
    	sin6->sin6_port, (struct in_addr *)&sin6->sin6_addr,
	inp->inp_lport, INPLOOKUP_IPV6)) return EADDRINUSE;
#endif /* __NetBSD__ */
#endif /* __FreeBSD__ */

  if (IN6_IS_ADDR_UNSPECIFIED(&inp->inp_laddr6))
    {
      if (inp->inp_lport == 0)
	(void)in6_pcbbind(inp, NULL);  /* To find free port & bind to it. */
      inp->inp_laddr6 = ifaddr->sin6_addr;
    }
  inp->inp_faddr6 = sin6->sin6_addr;
  inp->inp_fport = sin6->sin6_port;

  /*
   * Assumes user specify flowinfo in network order.
   */
  inp->inp_ipv6.ip6_flow = htonl(0x60000000) | 
    (sin6->sin6_flowinfo & htonl(0x0fffffff));

#if __NetBSD__
  in_pcbstate(inp, INP_CONNECTED);
#endif /* __NetBSD__ */
  
#if __FreeBSD__ 
  /*
   * See pcbbind near the end for reasoning on setting this for a value to 
   * hash on. 
   */
#if 0
  inp->inp_laddr.s_addr = inp->inp_laddr6.s6_addr32[3]
                        ^ inp->inp_laddr6.s6_addr32[1];
#endif /* 0 */
  in_pcbrehash(inp);
#endif /* __FreeBSD__ */
  return 0;
}
#else
a504 1
#endif
a521 3
#ifdef IPSEC
in6_pcbnotify(head, dst, fport_arg, la, lport_arg, cmd, notify, m, nexthdr)
#else /* IPSEC */
a522 2
#endif /* IPSEC */
#if __NetBSD__ || __OpenBSD__
a523 7
#else /* __NetBSD__ || __OpenBSD__ */
#if __FreeBSD__ 
     struct inpcbhead *head;
#else /* __FreeBSD__ */
     struct inpcb *head;
#endif /* __FreeBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */
a529 4
#ifdef IPSEC
     struct mbuf *m;
     int nexthdr;
#endif /* IPSEC */
a534 9
#ifdef IPSEC
  struct sockaddr_in6 srcsa, dstsa;
#endif /* IPSEC */

  DPRINTF(IDL_EVENT,("Entering in6_pcbnotify.  head = 0x%lx, dst is\n", (unsigned long)head));
  DDO(IDL_EVENT,dump_smart_sockaddr(dst));
  DPRINTF(IDL_EVENT,("fport_arg = %d, lport_arg = %d, cmd = %d\n",\
			   fport_arg, lport_arg, cmd));
  DDO(IDL_EVENT,printf("la is ");dump_in6_addr(la));
a563 18
#ifdef IPSEC
  /* Build these again because args aren't necessarily correctly formed
     sockaddrs, and the policy code will eventually need that. -cmetz */

  memset(&srcsa, 0, sizeof(struct sockaddr_in6));
  srcsa.sin6_len = sizeof(struct sockaddr_in6);
  srcsa.sin6_family = AF_INET6;
  /* defer port */
  srcsa.sin6_addr = *faddr;

  memset(&dstsa, 0, sizeof(struct sockaddr_in6));
  dstsa.sin6_len = sizeof(struct sockaddr_in6);
  dstsa.sin6_family = AF_INET6;
  /* defer port */
  dstsa.sin6_addr = laddr;
#endif /* IPSEC */

#if __NetBSD__ || __OpenBSD__
a565 7
#else /* __NetBSD__ || __OpenBSD__ */
#if __FreeBSD__
  for (inp = head->lh_first; inp != NULL;)
#else /* __FreeBSD__ */
  for (inp = head->inp_next; inp != head;)
#endif /* __FreeBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */
a572 1
#if __NetBSD__ || __OpenBSD__
a573 7
#else /* __NetBSD__ || __OpenBSD__ */
#if __FreeBSD__
	  inp = inp->inp_list.le_next;
#else /* __FreeBSD__ */
	  inp = inp->inp_next;
#endif /* __FreeBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */
a577 1
#if __NetBSD__ || __OpenBSD__
a578 8
#else /* __NetBSD__ || __OpenBSD__ */
#if __FreeBSD__
      inp = inp->inp_list.le_next;
#else /* __FreeBSD__ */
      inp = inp->inp_next;
#endif /* __FreeBSD__ */
#endif /* __NetBSD__ || __OpenBSD__ */

a579 15
#ifdef IPSEC
	{
	  /* Pretend the packet came in for this source/destination port pair,
	     since that's what we care about for policy. If the passed in
	     fport and/or lport were nonzero, the comparison will make sure
	     they match that of the PCB and the right thing will happen.
	     -cmetz */
	  srcsa.sin6_port = oinp->inp_fport;
	  dstsa.sin6_port = oinp->inp_lport;

	  /* XXX - state arg should not be NULL */
	  if (!netproc_inputpolicy(oinp->inp_socket, (struct sockaddr *)&srcsa,
			          (struct sockaddr *)&dstsa, nexthdr, m, NULL,
				   NULL))
#endif /* IPSEC */
a580 3
#ifdef IPSEC
	}
#endif /* IPSEC */
a592 3
#if __FreeBSD__
     struct sockaddr **nam; 
#else /* __FreeBSD__ */
a593 1
#endif /* __FreeBSD__ */
a596 11
#if __FreeBSD__ 
  /*
   * In FreeBSD we have to allocate the sockaddr_in6 structure since we aren't
   * given an mbuf, but a sockaddr ** as the second argument. (i.e. a location
   * to reference the space this routine allocates.  
   */
  if (!(sin6 = (struct sockaddr_in6 *)malloc(sizeof(struct sockaddr_in6),M_SONAME, M_DONTWAIT)))
  	return ENOBUFS; /* XXX */

#else /* __FreeBSD__ */

a599 2
#endif /* __FreeBSD__ */

a604 5

#if __FreeBSD__
  *nam = (struct sockaddr *) sin6;
#endif /* __FreeBSD__ */

a615 3
#if __FreeBSD__
     struct sockaddr **nam; 
#else /* __FreeBSD__ */
a616 1
#endif /* __FreeBSD__ */
a619 11
#if __FreeBSD__ 
  /*
   * In FreeBSD we have to allocate the sockaddr_in6 structure since we aren't
   * given an mbuf, but a sockaddr ** as the second argument. (i.e. a location
   * to reference the space this routine allocates.  
   */
  if (!(sin6 = (struct sockaddr_in6 *)malloc(sizeof(struct sockaddr_in6),M_SONAME, M_DONTWAIT)))
  	return ENOBUFS; /* XXX */

#else /* __FreeBSD__ */

a622 2
#endif /* __FreeBSD__ */

a628 5

#if __FreeBSD__
  *nam = (struct sockaddr *) sin6;
#endif /* __FreeBSD__ */

@


1.5
log
@Replace 'in6a_words' (old NRL convention) with 's6_addr32' (new BSDI et al.
convention that is more common and more specific as to the access size)
@
text
@a70 1
#include <netinet6/in6.h>
d72 2
a73 2
#include <netinet6/ipv6.h>
#include <netinet6/ipv6_var.h>
d149 1
d158 1
d327 1
a327 1
	inp->inp_ipv6.ipv6_versfl = htonl(0x60000000) | 
d647 1
a647 1
      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
d651 1
a651 1
	  if (IN6_IS_ADDR_LINKLOCAL(&I6A_SIN(i6a)->sin6_addr))
d653 1
a653 1
	  else if (!IN6_IS_ADDR_LOOPBACK(&I6A_SIN(i6a)->sin6_addr))
d662 1
a662 1
      register struct route6 *ro;
d693 1
d705 1
d780 1
a780 1
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
d784 1
a784 1
		  if (IN6_IS_ADDR_LINKLOCAL(&I6A_SIN(i6a)->sin6_addr))
d786 1
a786 1
		  else if (!IN6_IS_ADDR_LOOPBACK(&I6A_SIN(i6a)->sin6_addr))
d803 1
a803 1
	  struct ipv6_moptions *i6mo;
d806 2
a807 2
	  i6mo = inp->inp_moptions6;
	  if (i6mo->i6mo_multicast_ifp != NULL)
d809 3
a811 3
	      ifp = i6mo->i6mo_multicast_ifp;
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
		if (i6a->i6a_ifp == ifp)  /* Linkloc vs. global? */
d844 1
d951 1
a951 1
      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
d955 1
a955 1
	  if (IN6_IS_ADDR_LINKLOCAL(&I6A_SIN(i6a)->sin6_addr))
d957 1
a957 1
	  else if (!IN6_IS_ADDR_LOOPBACK(&I6A_SIN(i6a)->sin6_addr))
d966 1
a966 2
      register struct route6 *ro;

d997 1
d1009 1
d1020 1
d1049 1
d1086 1
a1086 1
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
d1090 1
a1090 1
		  if (IN6_IS_ADDR_LINKLOCAL(&I6A_SIN(i6a)->sin6_addr))
d1092 1
a1092 1
		  else if (!IN6_IS_ADDR_LOOPBACK(&I6A_SIN(i6a)->sin6_addr))
d1109 1
a1109 1
	  struct ipv6_moptions *i6mo;
d1112 2
a1113 2
	  i6mo = inp->inp_moptions6;
	  if (i6mo->i6mo_multicast_ifp != NULL)
d1115 3
a1117 3
	      ifp = i6mo->i6mo_multicast_ifp;
	      for (i6a = in6_ifaddr; i6a; i6a = i6a->i6a_next)
		if (i6a->i6a_ifp == ifp)  /* Linkloc vs. global? */
d1124 1
a1124 1
      ifaddr = (struct sockaddr_in6 *)&i6a->i6a_addr;
d1165 1
a1165 1
  inp->inp_ipv6.ipv6_versfl = htonl(0x60000000) | 
d1185 133
a1497 1

@


1.4
log
@Demangled the INET6 stuff so as not to require any extra options and not to
be mutually exclusive with the IPSEC option.
@
text
@d254 1
a254 1
	  sin.sin_addr.s_addr = sin6->sin6_addr.in6a_words[3];
d287 1
a287 1
	      la.s_addr = sin6->sin6_addr.in6a_words[3];
d340 2
a341 2
      if (inp->inp_laddr6.in6a_words[0] == 0 && 
	  inp->inp_laddr6.in6a_words[1] == 0)
d343 1
a343 1
	  if (inp->inp_laddr6.in6a_words[2] == ntohl(0xffff))
d345 2
a346 2
	  if (inp->inp_laddr6.in6a_words[2] == 0 &&
	      inp->inp_laddr6.in6a_words[3] == 0)
d368 1
a368 1
      la.s_addr = inp->inp_laddr6.in6a_words[3];
d530 2
a531 2
	 inp->inp_laddr.s_addr = inp->inp_laddr6.in6a_words[3]
	                       ^ inp->inp_laddr6.in6a_words[1];
d615 1
a615 1
      sin->sin_addr.s_addr = sin6->sin6_addr.in6a_words[3];
d624 2
a625 2
	  inp->inp_laddr6.in6a_words[2] = htonl(0xffff);
	  inp->inp_faddr6.in6a_words[2] = htonl(0xffff);
d907 1
a907 1
      sin->sin_addr.s_addr = sin6->sin6_addr.in6a_words[3];
d926 2
a927 2
	  inp->inp_laddr6.in6a_words[2] = htonl(0xffff);
	  inp->inp_faddr6.in6a_words[2] = htonl(0xffff);
d1171 2
a1172 2
  inp->inp_laddr.s_addr = inp->inp_laddr6.in6a_words[3]
                        ^ inp->inp_laddr6.in6a_words[1];
@


1.3
log
@Synchronized changes needed to integrate into OpenBSD with the NRL source
tree so we can have a unified netinet6 directory.
@
text
@d76 3
a78 1
#if __OpenBSD__ && defined(NRL_IPSEC)
d80 2
a81 1
#endif /* __OpenBSD__ && defined(NRL_IPSEC) */
a88 7
#ifdef DEBUG_NRL_SYS
#include <sys/debug.h>
#endif /* DEBUG_NRL_SYS */
#ifdef DEBUG_NRL_NETINET6
#include <netinet6/debug.h>
#endif /* DEBUG_NRL_NETINET6 */

d92 10
@


1.2
log
@rename baddynamic() to in_baddynamic(), and export it
@
text
@d86 1
d88 4
@


1.1
log
@first few files of NRL ipv6.  This NRL release was officially exported
to me by US DOD officials, with the crypto already removed.
@
text
@a133 4
#if __OpenBSD__
int in_baddynamic __P((u_int16_t, u_int16_t));
#endif /* __OpenBSD__ */

@

