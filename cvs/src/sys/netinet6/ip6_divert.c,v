head	1.51;
access;
symbols
	OPENBSD_6_2_BASE:1.51
	OPENBSD_6_1:1.46.0.4
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.41.0.2
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.17.0.4
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.5.0.10
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.8
	OPENBSD_5_0:1.5.0.6
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.4
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.51
date	2017.09.06.11.43.04;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	dT9JmzubTWWxQY0W;

1.50
date	2017.09.05.07.59.11;	author mpi;	state Exp;
branches;
next	1.49;
commitid	fWUv1bxRFYaflFag;

1.49
date	2017.07.27.12.04.42;	author mpi;	state Exp;
branches;
next	1.48;
commitid	5D4ggruywFBANoeX;

1.48
date	2017.06.26.09.32.32;	author mpi;	state Exp;
branches;
next	1.47;
commitid	gZMpLuRopIsWa0cT;

1.47
date	2017.05.30.07.50.37;	author mpi;	state Exp;
branches;
next	1.46;
commitid	p51F2KIwIJB1dU8P;

1.46
date	2017.03.13.20.18.21;	author claudio;	state Exp;
branches;
next	1.45;
commitid	ZsxSSZJSFxZH81LL;

1.45
date	2017.02.09.15.32.56;	author jca;	state Exp;
branches;
next	1.44;
commitid	fXr0qQRRcc8oQZmX;

1.44
date	2017.01.29.19.58.47;	author bluhm;	state Exp;
branches;
next	1.43;
commitid	3e3CkrbYekyVOcxy;

1.43
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.42;
commitid	QqHqT2WhCBWqYgGJ;

1.42
date	2016.11.21.09.09.06;	author mpi;	state Exp;
branches;
next	1.41;
commitid	wuzpseLx3Ntn9R7b;

1.41
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.40;
commitid	AZTNcVhJxOTcjeS6;

1.40
date	2016.03.23.15.50.36;	author vgross;	state Exp;
branches;
next	1.39;
commitid	iMWKOVeEybjVAEfv;

1.39
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.38;
commitid	Z6e4eqr6FuYFPnlL;

1.38
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.37;
commitid	Cr0DVA7exR1t2zXg;

1.37
date	2015.09.10.08.46.17;	author claudio;	state Exp;
branches;
next	1.36;
commitid	XwOgCd5wSQPr8HhN;

1.36
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	ncpqEGjDtSFuLAgn;

1.35
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.34;
commitid	h7z8lokZ0dFyuWpg;

1.34
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.33;
commitid	4Ro7ulidQXNcMvmM;

1.33
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.32;
commitid	c7ei8kPelCOOwHXy;

1.32
date	2015.01.24.00.29.06;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	VK3ncyiP3NS1N4Sy;

1.31
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.30;
commitid	t9FBKDfc4VDxpEy2;

1.30
date	2014.09.08.06.24.13;	author jsg;	state Exp;
branches;
next	1.29;
commitid	ZqXwxwmeo3l29NOg;

1.29
date	2014.08.10.03.24.51;	author lteo;	state Exp;
branches;
next	1.28;
commitid	VjxsNUiMtqRcFS5K;

1.28
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.27;
commitid	DQakU8LLWV6Iwx84;

1.27
date	2014.07.12.19.05.45;	author lteo;	state Exp;
branches;
next	1.26;
commitid	sAeylUBMB7AL0Bm4;

1.26
date	2014.07.12.19.04.29;	author lteo;	state Exp;
branches;
next	1.25;
commitid	EE8axg2xWGclVtBz;

1.25
date	2014.07.12.03.27.00;	author lteo;	state Exp;
branches;
next	1.24;
commitid	Rk1KC09W15Q80m90;

1.24
date	2014.07.10.03.17.59;	author lteo;	state Exp;
branches;
next	1.23;
commitid	baLHEMMpirACq25p;

1.23
date	2014.04.28.15.43.04;	author reyk;	state Exp;
branches;
next	1.22;

1.22
date	2014.04.23.14.43.14;	author florian;	state Exp;
branches;
next	1.21;

1.21
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.20;

1.20
date	2014.04.07.10.04.17;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2014.03.28.08.33.51;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2014.03.27.13.27.28;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2013.12.20.02.04.09;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2013.11.22.07.59.09;	author mpi;	state Exp;
branches;
next	1.15;

1.15
date	2013.11.15.16.46.15;	author lteo;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.17.16.27.46;	author bluhm;	state Exp;
branches;
next	1.13;

1.13
date	2013.06.26.09.12.40;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2013.05.31.15.04.24;	author bluhm;	state Exp;
branches;
next	1.11;

1.11
date	2013.04.08.15.32.23;	author lteo;	state Exp;
branches;
next	1.10;

1.10
date	2013.04.02.18.27.47;	author bluhm;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2012.11.06.12.32.42;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2012.11.01.07.55.56;	author henning;	state Exp;
branches;
next	1.6;

1.6
date	2012.10.21.13.06.03;	author benno;	state Exp;
branches;
next	1.5;

1.5
date	2010.07.03.04.44.51;	author guenther;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.3;

1.3
date	2010.03.09.12.36.12;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2010.03.08.14.18.07;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2009.11.05.20.50.14;	author michele;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Replace the call to ifa_ifwithaddr() in divert6_output() with a
route lookup to make it MP safe.  Only set the mbuf header fields
that are needed.  Validate the name input.  Also use the same
variables in IPv4 and IPv6 functions and avoid unneccessary
initialization.
OK mpi@@
@
text
@/*      $OpenBSD: ip6_divert.c,v 1.50 2017/09/05 07:59:11 mpi Exp $ */

/*
 * Copyright (c) 2009 Michele Marchetto <michele@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/route.h>
#include <net/if_var.h>
#include <net/netisr.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/in_pcb.h>
#include <netinet/ip6.h>
#include <netinet6/in6_var.h>
#include <netinet6/ip6_divert.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/icmp6.h>

#include <net/pfvar.h>

struct	inpcbtable	divb6table;
struct	cpumem		*div6counters;

#ifndef DIVERT_SENDSPACE
#define DIVERT_SENDSPACE	(65536 + 100)
#endif
u_int   divert6_sendspace = DIVERT_SENDSPACE;
#ifndef DIVERT_RECVSPACE
#define DIVERT_RECVSPACE	(65536 + 100)
#endif
u_int   divert6_recvspace = DIVERT_RECVSPACE;

#ifndef DIVERTHASHSIZE
#define DIVERTHASHSIZE	128
#endif

int *divert6ctl_vars[DIVERT6CTL_MAXID] = DIVERT6CTL_VARS;

int divb6hashsize = DIVERTHASHSIZE;

int	divert6_output(struct inpcb *, struct mbuf *, struct mbuf *,
	    struct mbuf *);

void
divert6_init(void)
{
	in_pcbinit(&divb6table, divb6hashsize);
	div6counters = counters_alloc(div6s_ncounters);
}

int
divert6_output(struct inpcb *inp, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control)
{
	struct sockaddr_in6 *sin6;
	int error, min_hdrlen, nxt, off, dir;
	struct ip6_hdr *ip6;

	m_freem(control);

	if ((error = in6_nam2sin6(nam, &sin6)))
		goto fail;

	/* Do basic sanity checks. */
	if (m->m_pkthdr.len < sizeof(struct ip6_hdr))
		goto fail;
	if ((m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {
		/* m_pullup() has freed the mbuf, so just return. */
		div6stat_inc(div6s_errors);
		return (ENOBUFS);
	}
	ip6 = mtod(m, struct ip6_hdr *);
	if ((ip6->ip6_vfc & IPV6_VERSION_MASK) != IPV6_VERSION)
		goto fail;
	if (m->m_pkthdr.len < sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen))
		goto fail;

	/*
	 * Recalculate the protocol checksum since the userspace application
	 * may have modified the packet prior to reinjection.
	 */
	off = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxt);
	if (off < sizeof(struct ip6_hdr))
		goto fail;

	dir = (IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr) ? PF_OUT : PF_IN);

	switch (nxt) {
	case IPPROTO_TCP:
		min_hdrlen = sizeof(struct tcphdr);
		m->m_pkthdr.csum_flags |= M_TCP_CSUM_OUT;
		break;
	case IPPROTO_UDP:
		min_hdrlen = sizeof(struct udphdr);
		m->m_pkthdr.csum_flags |= M_UDP_CSUM_OUT;
		break;
	case IPPROTO_ICMPV6:
		min_hdrlen = sizeof(struct icmp6_hdr);
		m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
		break;
	default:
		min_hdrlen = 0;
		break;
	}
	if (min_hdrlen && m->m_pkthdr.len < off + min_hdrlen)
		goto fail;

	m->m_pkthdr.pf.flags |= PF_TAG_DIVERTED_PACKET;

	if (dir == PF_IN) {
		struct rtentry *rt;
		struct ifnet *ifp;

		rt = rtalloc(sin6tosa(sin6), 0, inp->inp_rtableid);
		if (!rtisvalid(rt) || !ISSET(rt->rt_flags, RTF_LOCAL)) {
			rtfree(rt);
			error = EADDRNOTAVAIL;
			goto fail;
		}
		m->m_pkthdr.ph_ifidx = rt->rt_ifidx;
		rtfree(rt);

		/*
		 * Recalculate the protocol checksum for the inbound packet
		 * since the userspace application may have modified the packet
		 * prior to reinjection.
		 */
		in6_proto_cksum_out(m, NULL);

		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL) {
			error = ENETDOWN;
			goto fail;
		}
		ipv6_input(ifp, m);
		if_put(ifp);
	} else {
		m->m_pkthdr.ph_rtableid = inp->inp_rtableid;

		error = ip6_output(m, NULL, &inp->inp_route6,
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL);
	}

	div6stat_inc(div6s_opackets);
	return (error);

fail:
	div6stat_inc(div6s_errors);
	m_freem(m);
	return (error ? error : EINVAL);
}

int
divert6_packet(struct mbuf *m, int dir, u_int16_t divert_port)
{
	struct inpcb *inp;
	struct socket *sa = NULL;
	struct sockaddr_in6 addr;

	inp = NULL;
	div6stat_inc(div6s_ipackets);

	if (m->m_len < sizeof(struct ip6_hdr) &&
	    (m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL) {
		div6stat_inc(div6s_errors);
		return (0);
	}

	TAILQ_FOREACH(inp, &divb6table.inpt_queue, inp_queue) {
		if (inp->inp_lport != divert_port)
			continue;
		if (inp->inp_divertfl == 0)
			break;
		if (dir == PF_IN && !(inp->inp_divertfl & IPPROTO_DIVERT_RESP))
			return (-1);
		if (dir == PF_OUT && !(inp->inp_divertfl & IPPROTO_DIVERT_INIT))
			return (-1);
		break;
	}

	memset(&addr, 0, sizeof(addr));
	addr.sin6_family = AF_INET6;
	addr.sin6_len = sizeof(addr);

	if (dir == PF_IN) {
		struct ifaddr *ifa;
		struct ifnet *ifp;

		ifp = if_get(m->m_pkthdr.ph_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			return (0);
		}
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			addr.sin6_addr = satosin6(ifa->ifa_addr)->sin6_addr;
			break;
		}
		if_put(ifp);
	}

	if (inp) {
		sa = inp->inp_socket;
		if (sbappendaddr(sa, &sa->so_rcv, sin6tosa(&addr), m, NULL) == 0) {
			div6stat_inc(div6s_fullsock);
			m_freem(m);
			return (0);
		} else {
			KERNEL_LOCK();
			sorwakeup(inp->inp_socket);
			KERNEL_UNLOCK();
		}
	}

	if (sa == NULL) {
		div6stat_inc(div6s_noport);
		m_freem(m);
	}
	return (0);
}

/*ARGSUSED*/
int
divert6_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *addr,
    struct mbuf *control, struct proc *p)
{
	struct inpcb *inp = sotoinpcb(so);
	int error = 0;

	soassertlocked(so);

	if (req == PRU_CONTROL) {
		return (in6_control(so, (u_long)m, (caddr_t)addr,
		    (struct ifnet *)control));
	}
	if (inp == NULL) {
		error = EINVAL;
		goto release;
	}
	switch (req) {

	case PRU_DETACH:
		in_pcbdetach(inp);
		break;

	case PRU_BIND:
		error = in_pcbbind(inp, addr, p);
		break;

	case PRU_SHUTDOWN:
		socantsendmore(so);
		break;

	case PRU_SEND:
		return (divert6_output(inp, m, addr, control));

	case PRU_ABORT:
		soisdisconnected(so);
		in_pcbdetach(inp);
		break;

	case PRU_SOCKADDR:
		in6_setsockaddr(inp, addr);
		break;

	case PRU_PEERADDR:
		in6_setpeeraddr(inp, addr);
		break;

	case PRU_SENSE:
		return (0);

	case PRU_LISTEN:
	case PRU_CONNECT:
	case PRU_CONNECT2:
	case PRU_ACCEPT:
	case PRU_DISCONNECT:
	case PRU_SENDOOB:
	case PRU_FASTTIMO:
	case PRU_SLOWTIMO:
	case PRU_PROTORCV:
	case PRU_PROTOSEND:
		error =  EOPNOTSUPP;
		break;

	case PRU_RCVD:
	case PRU_RCVOOB:
		return (EOPNOTSUPP);	/* do not free mbuf's */

	default:
		panic("divert6_usrreq");
	}

release:
	m_freem(control);
	m_freem(m);
	return (error);
}

int
divert6_attach(struct socket *so, int proto)
{
	int error;

	if (so->so_pcb != NULL)
		return EINVAL;

	if ((so->so_state & SS_PRIV) == 0)
		return EACCES;

	error = in_pcballoc(so, &divb6table);
	if (error)
		return (error);

	error = soreserve(so, divert6_sendspace, divert6_recvspace);
	if (error)
		return (error);
	sotoinpcb(so)->inp_flags |= INP_HDRINCL;
	return (0);
}

int
divert6_sysctl_div6stat(void *oldp, size_t *oldlenp, void *newp)
{
	uint64_t counters[div6s_ncounters];
	struct div6stat div6stat;
	u_long *words = (u_long *)&div6stat;
	int i;

	CTASSERT(sizeof(div6stat) == (nitems(counters) * sizeof(u_long)));

	counters_read(div6counters, counters, nitems(counters));

	for (i = 0; i < nitems(counters); i++)
		words[i] = (u_long)counters[i];

	return (sysctl_rdstruct(oldp, oldlenp, newp,
	    &div6stat, sizeof(div6stat)));
}

/*
 * Sysctl for divert variables.
 */
int
divert6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	case DIVERT6CTL_SENDSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &divert6_sendspace));
	case DIVERT6CTL_RECVSPACE:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &divert6_recvspace));
	case DIVERT6CTL_STATS:
		return (divert6_sysctl_div6stat(oldp, oldlenp, newp));
	default:
		if (name[0] < DIVERT6CTL_MAXID)
			return sysctl_int_arr(divert6ctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen);

		return (ENOPROTOOPT);
	}
	/* NOTREACHED */
}
@


1.50
log
@Replace NET_ASSERT_LOCKED() by soassertlocked() in *_usrreq().

Not all of them need the NET_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.49 2017/07/27 12:04:42 mpi Exp $ */
a64 2
static struct sockaddr_in6 ip6addr = { sizeof(ip6addr), AF_INET6 };

d80 1
a80 2
	struct ifaddr *ifa;
	int error = 0, min_hdrlen = 0, nxt = 0, off, dir;
a82 4
	m->m_pkthdr.ph_ifidx = 0;
	m->m_nextpkt = NULL;
	m->m_pkthdr.ph_rtableid = inp->inp_rtableid;

d85 2
a86 1
	sin6 = mtod(nam, struct sockaddr_in6 *);
d126 1
a126 1
		/* nothing */
d135 6
a140 5
		ip6addr.sin6_addr = sin6->sin6_addr;
		/* XXXSMP ``ifa'' is not reference counted. */
		ifa = ifa_ifwithaddr(sin6tosa(&ip6addr),
		    m->m_pkthdr.ph_rtableid);
		if (ifa == NULL) {
d144 2
a145 1
		m->m_pkthdr.ph_ifidx = ifa->ifa_ifp->if_index;
d154 7
a160 2
		/* XXXSMP ``ifa'' is not reference counted. */
		ipv6_input(ifa->ifa_ifp, m);
d162 2
@


1.49
log
@Grab the KERNEL_LOCK() before calling sorwakeup().

In the forwarding path, pf_test() is executed w/o KERNEL_LOCK() and
in case of divert end up calling sowakup().  However selwakup() and
csignal() are not yet ready to be executed w/o KERNEL_LOCK().

ok bluhm@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.48 2017/06/26 09:32:32 mpi Exp $ */
d252 1
a252 1
	NET_ASSERT_LOCKED();
@


1.48
log
@Assert that the corresponding socket is locked when manipulating socket
buffers.

This is one step towards unlocking TCP input path.  Note that all the
functions asserting for the socket lock are not necessarilly MP-safe.
All the fields of 'struct socket' aren't protected.

Introduce a new kernel-only kqueue hint, NOTE_SUBMIT, to be able to
tell when a filter needs to lock the underlying data structures.  Logic
and name taken from NetBSD.

Tested by Hrvoje Popovski.

ok claudio@@, bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.47 2017/05/30 07:50:37 mpi Exp $ */
d230 2
a231 1
		} else
d233 2
@


1.47
log
@Introduce ipv{4,6}_input(), two wrappers around IP queues.

This will help transitionning to an un-KERNEL_LOCK()ed IP
forwarding path.

Disucssed with bluhm@@, ok claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.46 2017/03/13 20:18:21 claudio Exp $ */
d226 1
a226 1
		if (sbappendaddr(&sa->so_rcv, sin6tosa(&addr), m, NULL) == 0) {
@


1.46
log
@Move PRU_ATTACH out of the pr_usrreq functions into pr_attach.
Attach is quite a different thing to the other PRU functions and
this should make locking a bit simpler. This also removes the ugly
hack on how proto was passed to the attach function.
OK bluhm@@ and mpi@@ on a previous version
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.45 2017/02/09 15:32:56 jca Exp $ */
d142 1
d158 2
a159 1
		niq_enqueue(&ip6intrq, m); /* return error on q full? */
@


1.45
log
@percpu counters for divert(4) stats

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.44 2017/01/29 19:58:47 bluhm Exp $ */
d253 1
a253 1
	if (inp == NULL && req != PRU_ATTACH) {
a258 19
	case PRU_ATTACH:
		if (inp != NULL) {
			error = EINVAL;
			break;
		}
		if ((so->so_state & SS_PRIV) == 0) {
			error = EACCES;
			break;
		}
		error = in_pcballoc(so, &divb6table);
		if (error)
			break;

		error = soreserve(so, divert6_sendspace, divert6_recvspace);
		if (error)
			break;
		sotoinpcb(so)->inp_flags |= INP_HDRINCL;
		break;

d315 22
@


1.44
log
@Change the IPv4 pr_input function to the way IPv6 is implemented,
to get rid of struct ip6protosw and some wrapper functions.  It is
more consistent to have less different structures.  The divert_input
functions cannot be called anyway, so remove them.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.43 2016/12/19 08:36:50 mpi Exp $ */
d46 1
a46 1
struct	div6stat	div6stat;
d74 1
d99 1
a99 1
		div6stat.divs_errors++;
d163 1
a163 1
	div6stat.divs_opackets++;
d167 1
a167 1
	div6stat.divs_errors++;
d180 1
a180 1
	div6stat.divs_ipackets++;
d184 1
a184 1
		div6stat.divs_errors++;
d225 1
a225 1
			div6stat.divs_fullsock++;
d233 1
a233 1
		div6stat.divs_noport++;
d336 19
d374 1
a374 4
		if (newp != NULL)
			return (EPERM);
		return (sysctl_struct(oldp, oldlenp, newp, newlen,
		    &div6stat, sizeof(div6stat)));
@


1.43
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.42 2016/11/21 09:09:06 mpi Exp $ */
a73 8
}

int
divert6_input(struct mbuf **mp, int *offp, int proto)
{
	m_freem(*mp);

	return (0);
@


1.42
log
@Enforce that pr_usrreq functions are called at IPL_SOFTNET.

This will allow us to keep locking simple as soon as we trade
splsoftnet() for a rwlock.

ok bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.41 2016/03/29 11:57:51 chl Exp $ */
d254 1
a254 1
	splsoftassert(IPL_SOFTNET);
@


1.41
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.40 2016/03/23 15:50:36 vgross Exp $ */
a66 1
void	divert6_detach(struct inpcb *);
d253 2
a254 1
	int s;
a274 1
		s = splsoftnet();
a275 1
		splx(s);
d286 1
a286 1
		divert6_detach(inp);
a289 1
		s = splsoftnet();
a290 1
		splx(s);
d302 1
a302 1
		divert6_detach(inp);
a340 9
}

void
divert6_detach(struct inpcb *inp)
{
	int s = splsoftnet();

	in_pcbdetach(inp);
	splx(s);
@


1.40
log
@Merge in_pcbbind() and in6_pcbbind(), and change every call to
in6_pcbbind() into in_pcbbind().

Ok jca@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.39 2016/03/07 18:44:00 naddy Exp $ */
a89 1
	struct socket *so;
a100 1
	so = inp->inp_socket;
@


1.39
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.38 2015/09/11 08:17:06 claudio Exp $ */
d295 1
a295 1
		error = in6_pcbbind(inp, addr, p);
@


1.38
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.37 2015/09/10 08:46:17 claudio Exp $ */
d72 1
a72 1
divert6_init()
@


1.37
log
@Another trivial if_put addition. OK dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.36 2015/07/15 22:16:42 deraadt Exp $ */
d170 1
a170 1
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL, NULL);
@


1.36
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.35 2015/06/16 11:09:40 mpi Exp $ */
d229 1
@


1.35
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.34 2015/06/08 22:19:28 krw Exp $ */
d99 1
a99 2
	if (control)
		m_freem(control);
d343 2
a344 5
	if (control) {
		m_freem(control);
	}
	if (m)
		m_freem(m);
@


1.34
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.33 2015/04/10 13:58:20 dlg Exp $ */
d95 1
a95 1
	m->m_pkthdr.rcvif = NULL;
d159 1
a159 1
		m->m_pkthdr.rcvif = ifa->ifa_ifp;
d219 5
a223 1
		ifp = m->m_pkthdr.rcvif;
@


1.33
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.32 2015/01/24 00:29:06 deraadt Exp $ */
d192 1
a192 1
	
@


1.32
log
@Userland (base & ports) was adapted to always include <netinet/in.h>
before <net/pfvar.h> or <net/if_pflog.h>.  The kernel files can be
cleaned up next.  Some sockaddr_union steps make it into here as well.
ok naddy
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.31 2014/12/05 15:50:04 mpi Exp $ */
a88 1
	struct ifqueue *inq;
d92 1
a92 1
	int s, error = 0, min_hdrlen = 0, nxt = 0, off, dir;
a160 2
		inq = &ip6intrq;

d168 1
a168 4
		s = splnet();
		IF_INPUT_ENQUEUE(inq, m);
		schednetisr(NETISR_IPV6);
		splx(s);
@


1.31
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.30 2014/09/08 06:24:13 jsg Exp $ */
d28 1
a30 1
#include <net/pfvar.h>
d42 2
@


1.30
log
@remove uneeded route.h includes
ok miod@@ mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.29 2014/08/10 03:24:51 lteo Exp $ */
d28 1
@


1.29
log
@Rename p_hdrlen to min_hdrlen to better reflect its purpose.

No object file change
ok florian@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.28 2014/07/22 11:06:10 mpi Exp $ */
a27 1
#include <net/route.h>
@


1.28
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.27 2014/07/12 19:05:45 lteo Exp $ */
d91 1
a91 1
	int s, error = 0, p_hdrlen = 0, nxt = 0, off, dir;
d130 1
a130 1
		p_hdrlen = sizeof(struct tcphdr);
d134 1
a134 1
		p_hdrlen = sizeof(struct udphdr);
d138 1
a138 1
		p_hdrlen = sizeof(struct icmp6_hdr);
d145 1
a145 1
	if (p_hdrlen && m->m_pkthdr.len < off + p_hdrlen)
@


1.27
log
@Remove the redundant csum_flag variable and just set the checksum flag
in the pkthdr directly.

ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.26 2014/07/12 19:04:29 lteo Exp $ */
a32 1
#include <netinet/in_systm.h>
@


1.26
log
@Protocol checksums have been recalculated on reinjection for a while
now, so there is no need to calculate them before sending them to
userspace.

ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.25 2014/07/12 03:27:00 lteo Exp $ */
a93 1
	u_int16_t csum_flag = 0;
d132 1
a132 1
		csum_flag = M_TCP_CSUM_OUT;
d136 1
a136 1
		csum_flag = M_UDP_CSUM_OUT;
d140 1
a140 1
		csum_flag = M_ICMP_CSUM_OUT;
a147 3

	if (csum_flag)
		m->m_pkthdr.csum_flags |= csum_flag;
@


1.25
log
@Implement checksum offload for divert(4): simply set the checksum flag
and let the stack take care of the checksums for reinjected outbound
packets.

Reinjected inbound packets will continue to have their checksums
calculated manually but we can now take advantage of in_proto_cksum_out
and in6_proto_cksum_out to streamline the way their checksums are done.

help from florian@@ and henning@@, feedback from naddy@@
ok florian@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.24 2014/07/10 03:17:59 lteo Exp $ */
a235 3
	/* force checksum calculation */
	if (dir == PF_OUT)
		in6_proto_cksum_out(m, NULL);
@


1.24
log
@Simplify the way divert(4) sends packets to userspace: Instead of
unnecessarily allocating an mbuf tag to store the divert port, just pass
the divert port directly to divert_packet() or divert6_packet() as an
argument.

includes a style fix pointed out by bluhm@@
ok bluhm@@ henning@@ reyk@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.23 2014/04/28 15:43:04 reyk Exp $ */
d92 1
a92 1
	int s, error = 0, p_hdrlen = 0, nxt = 0, off;
d94 1
a94 2
	u_int16_t csum = 0;
	size_t p_off = 0;
d127 3
d133 1
a133 1
		p_off = offsetof(struct tcphdr, th_sum);
d137 1
a137 1
		p_off = offsetof(struct udphdr, uh_sum);
d141 1
a141 1
		p_off = offsetof(struct icmp6_hdr, icmp6_cksum);
d147 2
a148 3
	if (p_hdrlen) {
		if (m->m_pkthdr.len < off + p_hdrlen)
			goto fail;
d150 2
a151 8
		if ((error = m_copyback(m, off + p_off, sizeof(csum), &csum, M_NOWAIT)))
			goto fail;
		csum = in6_cksum(m, nxt, off, m->m_pkthdr.len - off);
		if (nxt == IPPROTO_UDP && csum == 0)
			csum = 0xffff;
		if ((error = m_copyback(m, off + p_off, sizeof(csum), &csum, M_NOWAIT)))
			goto fail;
	}
d155 1
a155 1
	if (!IN6_IS_ADDR_UNSPECIFIED(&sin6->sin6_addr)) {
d166 7
@


1.23
log
@sync bzero => memset that was done for ip_divert.c before.

ok tedu@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.22 2014/04/23 14:43:14 florian Exp $ */
d191 1
a191 1
divert6_packet(struct mbuf *m, int dir)
a195 1
	struct pf_divert *divert;
a205 7
	divert = pf_find_divert(m);
	if (divert == NULL) {
		div6stat.divs_errors++;
		m_freem(m);
		return (0);
	}

d207 1
a207 1
		if (inp->inp_lport != divert->port)
@


1.22
log
@No need for vargs here.
While there move declaration of divert{,6}_output() to .c as it's a
private function. Also switch first two args to make it more like
similar functions (both suggested by mpi@@).
Input/OK mpi@@, OK lteo@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.21 2014/04/14 09:06:42 mpi Exp $ */
d226 1
a226 1
	bzero(&addr, sizeof(addr));
@


1.21
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.20 2014/04/07 10:04:17 mpi Exp $ */
d66 3
a68 1
void divert6_detach(struct inpcb *);
d85 2
a86 1
divert6_output(struct mbuf *m, ...)
a87 1
	struct inpcb *inp;
a88 1
	struct mbuf *nam, *control;
a92 1
	va_list ap;
a96 6
	va_start(ap, m);
	inp = va_arg(ap, struct inpcb *);
	nam = va_arg(ap, struct mbuf *);
	control = va_arg(ap, struct mbuf *);
	va_end(ap);

d318 1
a318 1
		return (divert6_output(m, inp, addr, control));
@


1.20
log
@Retire kernel support for SO_DONTROUTE, this time without breaking
localhost connections.

The plan is to always use the routing table for addresses and routes
resolutions, so there is no future for an option that wants to bypass
it.  This option has never been implemented for IPv6 anyway, so let's
just remove the IPv4 bits that you weren't aware of.

Tested a least by lteo@@, guenther@@ and chrisz@@, ok mikeb@@, benno@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.18 2014/03/27 13:27:28 mpi Exp $ */
d105 1
a105 1
	m->m_pkthdr.rdomain = inp->inp_rtableid;
d168 2
a169 1
		ifa = ifa_ifwithaddr(sin6tosa(&ip6addr), m->m_pkthdr.rdomain);
@


1.19
log
@revert "Retire kernel support for SO_DONTROUTE" diff, which does bad things
for localhost connections. discussed with deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.17 2013/12/20 02:04:09 krw Exp $ */
d183 1
a183 2
		    ((so->so_options & SO_DONTROUTE) ? IP_ROUTETOIF : 0)
		    | IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL, NULL);
@


1.18
log
@Retire kernel support for SO_DONTROUTE, since the plan is to always
use the routing table there's no future for an option that wants to
bypass it.  This option has never been implemented for IPv6 anyway,
so let's just remove the IPv4 bits that you weren't aware of.

Tested by florian@@, man pages inputs from jmc@@, ok benno@@
@
text
@d183 2
a184 1
		    IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL, NULL);
@


1.17
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.16 2013/11/22 07:59:09 mpi Exp $ */
d183 1
a183 2
		    ((so->so_options & SO_DONTROUTE) ? IP_ROUTETOIF : 0)
		    | IP_ALLOWBROADCAST | IP_RAWOUTPUT, NULL, NULL, NULL);
@


1.16
log
@Remove unused proc argument in in6_control().

ok henning@@, mikeb@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.15 2013/11/15 16:46:15 lteo Exp $ */
d220 1
a220 1
	CIRCLEQ_FOREACH(inp, &divb6table.inpt_queue, inp_queue) {
d252 1
a252 1
	if (inp != CIRCLEQ_END(&divb6table.inpt_queue)) {
@


1.15
log
@Rename the struct pf_divert variable in divert_packet() and
divert6_packet() from "pd" to "divert" to match the rest of the source.
I think "pd" was not a good name for a struct pf_divert because "pd"
usually refers to a pf_pdesc.

No object file change.

OK benno@@ bluhm@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.14 2013/10/17 16:27:46 bluhm Exp $ */
d280 1
a280 1
		    (struct ifnet *)control, p));
@


1.14
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.13 2013/06/26 09:12:40 henning Exp $ */
d202 1
a202 1
	struct pf_divert *pd;
d213 2
a214 2
	pd = pf_find_divert(m);
	if (pd == NULL) {
d221 1
a221 1
		if (inp->inp_lport != pd->port)
@


1.13
log
@put the cksum diff back, of course with the bug fixed where we could
under some circumstances repair broken checksums on the way.
ok ryan naddy mikeb
.
redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.12 2013/05/31 15:04:24 bluhm Exp $ */
a33 1
#include <netinet/in_var.h>
@


1.12
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.11 2013/04/08 15:32:23 lteo Exp $ */
d249 3
@


1.11
log
@Recalculate the IP and protocol checksums of packets (re)injected via
divert(4) sockets.

Recalculation of these checksums is necessary because (1) PF no longer
updates IP checksums as of pf.c rev 1.731, so translated packets that
are diverted to userspace (e.g. divert-packet with nat-to/rdr-to) will
have bad IP checksums and will be reinjected with bad IP checksums if
the userspace program doesn't correct the checksums; (2) the userspace
program may modify the packets, which would invalidate the checksums;
and (3) the divert(4) man page states that checksums are supposed to be
recalculated on reinjection.

This diff has been tested on a public webserver serving both IPv4/IPv6
for more than four weeks.  It has also been tested on a firewall with
divert-packet and nat-to/rdr-to where it transferred over 60GB of
FTP/HTTP/HTTPS/SSH/DNS/ICMP/ICMPv6 data correctly, using IPv4/IPv6
userspace programs that intentionally break the IP and protocol
checksums to confirm that recalculation is done correctly on
reinjection.  IPv6 extension headers were tested with Scapy.

Thanks to florian@@ for testing the original version of the diff with
dnsfilter and Justin Mayes for testing the original version with Snort
inline.  Thanks also to todd@@ for helping me in my search for the cause
of this bug.

I would especially like to thank blambert@@ for reviewing many versions
of this diff, and providing guidance and tons of helpful feedback.

no objections from florian@@
help/ok blambert@@, ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.10 2013/04/02 18:27:47 bluhm Exp $ */
d245 1
a245 2
			addr.sin6_addr = ((struct sockaddr_in6 *)
			    ifa->ifa_addr)->sin6_addr;
d252 1
a252 2
		if (sbappendaddr(&sa->so_rcv, (struct sockaddr *)&addr, 
		    m, NULL) == 0) {
@


1.10
log
@Use macros sotoinpcb() and intotcpcb() instead of casts.  Use NULL
instead of 0 for pointers.  No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.9 2013/03/28 16:45:16 tedu Exp $ */
a39 1
#include <netinet6/in6_var.h>
d41 3
d92 1
a92 1
	int s, error = 0;
d94 3
d114 51
d171 2
a172 3
			div6stat.divs_errors++;
			m_freem(m);
			return (EADDRNOTAVAIL);
d190 5
@


1.9
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.8 2012/11/06 12:32:42 henning Exp $ */
d246 1
a246 1
		((struct inpcb *) so->so_pcb)->inp_flags |= INP_HDRINCL;
@


1.8
log
@backout csum diff for the moment, requested by theo
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.7 2012/11/01 07:55:56 henning Exp $ */
a24 1
#include <sys/proc.h>
@


1.7
log
@redo most of the protocol (tcp/udp/...) checksum handling
-assume we have hardware checksum offloading. stop mucking with the
 checksum in most of the stack
-stop checksum mucking in pf, just set a "needs checksumming" flag if needed
-in all output pathes, very late, if we figure out the outbound interface
 doesn't have hw cksum offloading, do the cksum in software. this especially
 makes the bridge path behave like a regular output path
-little special casing for bridge still required until the broadcast path
 loses its disgusting shortcut hacks, but at least it's in one place now
 and not all over the stack
in6_proto_cksum_out mostly written by krw@@
started at k2k11 in iceland more than 1.5 years ago - yes it took that
long, this stuff is everything but easy.
this happens to fix the infamous pf rdr bug that made us turn off proto
cksum offloading on almost all interface drivers.
ok camield sthen claudio, testing by many, thanks!
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.5 2010/07/03 04:44:51 guenther Exp $ */
a190 3
	/* force checksum calculation */
	if (dir == PF_OUT)
		in6_proto_cksum_out(m, NULL);
@


1.6
log
@Add the IP_DIVERTFL socket option on divert(4) sockets to control
which packets (as in direction) of the traffic will be diverted
through the divert socket.
ok claudio@@, henning@@
@
text
@d191 3
@


1.5
log
@Fix the naming of interfaces and variables for rdomains and rtables
and make it possible to bind sockets (including listening sockets!)
to rtables and not just rdomains.  This changes the name of the
system calls, socket option, and ioctl.  After building with this
you should remove the files /usr/share/man/cat2/[gs]etrdomain.0.

Since this removes the existing [gs]etrdomain() system calls, the
libc major is bumped.

Written by claudio@@, criticized^Wcritiqued by me
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.4 2010/04/20 22:05:44 tedu Exp $ */
d138 1
a138 1
void
d146 1
d152 1
a152 1
		return;
d159 13
a171 1
		return;
d192 1
a192 4
	CIRCLEQ_FOREACH(inp, &divb6table.inpt_queue, inp_queue) {
		if (inp->inp_lport != pd->port)
			continue;

d198 1
a198 1
			return;
a200 1
		break;
d207 1
@


1.4
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.3 2010/03/09 12:36:12 jsing Exp $ */
d102 1
a102 1
	m->m_pkthdr.rdomain = inp->inp_rdomain;
@


1.3
log
@Use correct routing domain when doing address lookups.

ok claudio@@ "approved" deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: ip6_divert.c,v 1.2 2010/03/08 14:18:07 jsing Exp $ */
d25 1
@


1.2
log
@Use properly initialised sockaddr_in/sockaddr_in6 struct when performing
address lookups. Found whilst investigating address lookup failures.

ok michele@@
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d113 1
a113 1
		ifa = ifa_ifwithaddr(sin6tosa(&ip6addr), 0);
@


1.1
log
@IPv6 support for divert sockets.

tested by phessler@@ pyr@@
ok claudio@@
"go ahead" deraadt@@
@
text
@d63 2
d112 2
a113 1
		ifa = ifa_ifwithaddr((struct sockaddr *)sin6, 0);
@

