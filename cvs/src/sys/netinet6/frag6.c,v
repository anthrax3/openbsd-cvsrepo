head	1.73;
access;
symbols
	OPENBSD_6_1:1.72.0.4
	OPENBSD_6_1_BASE:1.72
	OPENBSD_6_0:1.67.0.2
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.54.0.4
	OPENBSD_5_6_BASE:1.54
	OPENBSD_5_5:1.51.0.4
	OPENBSD_5_5_BASE:1.51
	OPENBSD_5_4:1.47.0.2
	OPENBSD_5_4_BASE:1.47
	OPENBSD_5_3:1.43.0.2
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.42.0.4
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.30.0.2
	OPENBSD_4_8_BASE:1.30
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.27.0.6
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.2
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.26.0.2
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.25.0.2
	OPENBSD_4_3_BASE:1.25
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.8
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.21.0.6
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.2
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.19.0.4
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.19
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.6.0.6
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.4
	OPENBSD_2_7_BASE:1.6
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.73
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.72;
commitid	00hB28wQPwG5Ysk0;

1.72
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.71;
commitid	2R0NOjEDy2jGtnjL;

1.71
date	2016.11.28.11.12.45;	author mpi;	state Exp;
branches;
next	1.70;
commitid	pr5LCKF5IZsR2oy7;

1.70
date	2016.10.24.11.09.05;	author bluhm;	state Exp;
branches;
next	1.69;
commitid	1m3nlmWqQvR0x8XU;

1.69
date	2016.08.24.09.41.12;	author mpi;	state Exp;
branches;
next	1.68;
commitid	0Qtt2cJVj3irHniv;

1.68
date	2016.08.22.10.33.22;	author mpi;	state Exp;
branches;
next	1.67;
commitid	ZsKqEaqTKPu9hWk6;

1.67
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.66;
commitid	Z6e4eqr6FuYFPnlL;

1.66
date	2015.12.03.13.13.04;	author tedu;	state Exp;
branches;
next	1.65;
commitid	RzwVZMgf2a3EYYFd;

1.65
date	2015.10.22.10.22.53;	author mpi;	state Exp;
branches;
next	1.64;
commitid	sx9mcXnCpd2IWSZh;

1.64
date	2015.10.19.11.59.26;	author mpi;	state Exp;
branches;
next	1.63;
commitid	kfYDbDKgruYr99Oc;

1.63
date	2015.09.10.16.39.39;	author mpi;	state Exp;
branches;
next	1.62;
commitid	7KYjCOTlSY9IP6al;

1.62
date	2015.09.09.14.02.29;	author mpi;	state Exp;
branches;
next	1.61;
commitid	rqcRalpFRBw7CAML;

1.61
date	2015.07.08.07.31.14;	author mpi;	state Exp;
branches;
next	1.60;
commitid	FNQ3CrZoGHDjgm2D;

1.60
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.59;
commitid	h7z8lokZ0dFyuWpg;

1.59
date	2014.12.08.10.51.00;	author mpi;	state Exp;
branches;
next	1.58;
commitid	OytlsHKQQEAcUSnu;

1.58
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.57;
commitid	t9FBKDfc4VDxpEy2;

1.57
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.56;
commitid	Z1vcFtHO8wRH0yRt;

1.56
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.55;
commitid	6AYfDT0Lpez1LFQp;

1.55
date	2014.09.27.12.26.16;	author mpi;	state Exp;
branches;
next	1.54;
commitid	HQcmytntiCJTHORs;

1.54
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.53;
commitid	DQakU8LLWV6Iwx84;

1.53
date	2014.07.12.18.44.23;	author tedu;	state Exp;
branches;
next	1.52;
commitid	B4dZSbxas1X1IpXI;

1.52
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.10.20.11.03.02;	author phessler;	state Exp;
branches;
next	1.49;

1.49
date	2013.10.17.16.27.45;	author bluhm;	state Exp;
branches;
next	1.48;

1.48
date	2013.08.27.08.20.32;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.06.11.18.15.54;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.31.15.04.23;	author bluhm;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.43;

1.43
date	2012.12.28.17.52.06;	author gsoares;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.24.19.08.46;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.23.18.37.20;	author bluhm;	state Exp;
branches;
next	1.40;

1.40
date	2012.01.10.17.09.02;	author bluhm;	state Exp;
branches;
next	1.39;

1.39
date	2012.01.10.12.50.32;	author bluhm;	state Exp;
branches;
next	1.38;

1.38
date	2012.01.09.14.47.53;	author bluhm;	state Exp;
branches;
next	1.37;

1.37
date	2012.01.09.01.01.12;	author bluhm;	state Exp;
branches;
next	1.36;

1.36
date	2012.01.05.21.14.47;	author bluhm;	state Exp;
branches;
next	1.35;

1.35
date	2012.01.05.20.54.28;	author bluhm;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.02.22.16.33;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.03.13.54.21;	author stsp;	state Exp;
branches;
next	1.32;

1.32
date	2011.03.06.19.55.54;	author bluhm;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.13.23.36.53;	author bluhm;	state Exp;
branches;
next	1.30;

1.30
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2010.02.08.11.51.16;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2009.12.27.19.38.33;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2008.11.23.13.30.59;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.09.21.24.58;	author hshoexer;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.01.03.38.45;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.06.18.11.47.46;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.20.19.25.16;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.11.03.27.30;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2002.06.08.21.51.08;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.28.03.04.38;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.27.19.48.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.16.14.10.51;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.15.10.50.59;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2001.05.17.18.11.26;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.22.05.11.52;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.16.08.50.23;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.16.08.48.05;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.02.04.18.11.38;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.08.05.28.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.08.04.49.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.27;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.40.16;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.55.16;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.11.4.3;

1.11.4.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.73
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@/*	$OpenBSD: frag6.c,v 1.72 2017/02/05 16:04:14 jca Exp $	*/
/*	$KAME: frag6.c,v 1.40 2002/05/27 21:40:31 itojun Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/domain.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet/ip.h>		/* for ECN definitions */

void frag6_freef(struct ip6q *);

static int ip6q_locked;
u_int frag6_nfragpackets;
u_int frag6_nfrags;
TAILQ_HEAD(ip6q_head, ip6q) frag6_queue;	/* ip6 reassemble queue */

static __inline int ip6q_lock_try(void);
static __inline void ip6q_unlock(void);

static __inline int
ip6q_lock_try(void)
{
	int s;

	/* Use splvm() due to mbuf allocation. */
	s = splvm();
	if (ip6q_locked) {
		splx(s);
		return (0);
	}
	ip6q_locked = 1;
	splx(s);
	return (1);
}

static __inline void
ip6q_unlock(void)
{
	int s;

	s = splvm();
	ip6q_locked = 0;
	splx(s);
}

#ifdef DIAGNOSTIC
#define	IP6Q_LOCK()							\
do {									\
	if (ip6q_lock_try() == 0) {					\
		printf("%s:%d: ip6q already locked\n", __FILE__, __LINE__); \
		panic("ip6q_lock");					\
	}								\
} while (0)
#define	IP6Q_LOCK_CHECK()						\
do {									\
	if (ip6q_locked == 0) {						\
		printf("%s:%d: ip6q lock not held\n", __FILE__, __LINE__); \
		panic("ip6q lock check");				\
	}								\
} while (0)
#else
#define	IP6Q_LOCK()		(void) ip6q_lock_try()
#define	IP6Q_LOCK_CHECK()	/* nothing */
#endif

#define	IP6Q_UNLOCK()		ip6q_unlock()

/*
 * Initialise reassembly queue and fragment identifier.
 */
void
frag6_init(void)
{

	TAILQ_INIT(&frag6_queue);
}

/*
 * In RFC2460, fragment and reassembly rule do not agree with each other,
 * in terms of next header field handling in fragment header.
 * While the sender will use the same value for all of the fragmented packets,
 * receiver is suggested not to check the consistency.
 *
 * fragment rule (p20):
 *	(2) A Fragment header containing:
 *	The Next Header value that identifies the first header of
 *	the Fragmentable Part of the original packet.
 *		-> next header field is same for all fragments
 *
 * reassembly rule (p21):
 *	The Next Header field of the last header of the Unfragmentable
 *	Part is obtained from the Next Header field of the first
 *	fragment's Fragment header.
 *		-> should grab it from the first fragment only
 *
 * The following note also contradicts with fragment rule - noone is going to
 * send different fragment with different next header field.
 *
 * additional note (p22):
 *	The Next Header values in the Fragment headers of different
 *	fragments of the same original packet may differ.  Only the value
 *	from the Offset zero fragment packet is used for reassembly.
 *		-> should grab it from the first fragment only
 *
 * There is no explicit reason given in the RFC.  Historical reason maybe?
 */
/*
 * Fragment input
 */
int
frag6_input(struct mbuf **mp, int *offp, int proto, int af)
{
	struct mbuf *m = *mp, *t;
	struct ip6_hdr *ip6;
	struct ip6_frag *ip6f;
	struct ip6q *q6;
	struct ip6asfrag *af6, *ip6af, *naf6, *paf6;
	int offset = *offp, nxt, i, next;
	int first_frag = 0;
	int fragoff, frgpartlen;	/* must be larger than u_int16_t */
	u_int8_t ecn, ecn0;

	ip6 = mtod(m, struct ip6_hdr *);
	IP6_EXTHDR_GET(ip6f, struct ip6_frag *, m, offset, sizeof(*ip6f));
	if (ip6f == NULL)
		return IPPROTO_DONE;

	/* jumbo payload can't contain a fragment header */
	if (ip6->ip6_plen == 0) {
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER, offset);
		return IPPROTO_DONE;
	}

	/*
	 * check whether fragment packet's fragment length is
	 * multiple of 8 octets.
	 * sizeof(struct ip6_frag) == 8
	 * sizeof(struct ip6_hdr) = 40
	 */
	if ((ip6f->ip6f_offlg & IP6F_MORE_FRAG) &&
	    (((ntohs(ip6->ip6_plen) - offset) & 0x7) != 0)) {
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
		    offsetof(struct ip6_hdr, ip6_plen));
		return IPPROTO_DONE;
	}

	ip6stat_inc(ip6s_fragments);

	/* offset now points to data portion */
	offset += sizeof(struct ip6_frag);

	/*
	 * RFC6946:  A host that receives an IPv6 packet which includes
	 * a Fragment Header with the "Fragment Offset" equal to 0 and
	 * the "M" bit equal to 0 MUST process such packet in isolation
	 * from any other packets/fragments.
	 */
	fragoff = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK);
	if (fragoff == 0 && !(ip6f->ip6f_offlg & IP6F_MORE_FRAG)) {
		ip6stat_inc(ip6s_reassembled);
		*offp = offset;
		return ip6f->ip6f_nxt;
	}

	/* Ignore empty non atomic fragment, do not classify as overlapping. */
	if (sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen) <= offset) {
		m_freem(m);
		return IPPROTO_DONE;
	}

	IP6Q_LOCK();

	/*
	 * Enforce upper bound on number of fragments.
	 * If maxfrag is 0, never accept fragments.
	 * If maxfrag is -1, accept all fragments without limitation.
	 */
	if (ip6_maxfrags >= 0 && frag6_nfrags >= (u_int)ip6_maxfrags)
		goto dropfrag;

	TAILQ_FOREACH(q6, &frag6_queue, ip6q_queue)
		if (ip6f->ip6f_ident == q6->ip6q_ident &&
		    IN6_ARE_ADDR_EQUAL(&ip6->ip6_src, &q6->ip6q_src) &&
		    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &q6->ip6q_dst))
			break;

	if (q6 == NULL) {
		/*
		 * the first fragment to arrive, create a reassembly queue.
		 */
		first_frag = 1;

		/*
		 * Enforce upper bound on number of fragmented packets
		 * for which we attempt reassembly;
		 * If maxfragpackets is 0, never accept fragments.
		 * If maxfragpackets is -1, accept all fragments without
		 * limitation.
		 */
		if (ip6_maxfragpackets >= 0 &&
		    frag6_nfragpackets >= (u_int)ip6_maxfragpackets)
			goto dropfrag;
		frag6_nfragpackets++;
		q6 = malloc(sizeof(*q6), M_FTABLE, M_NOWAIT | M_ZERO);
		if (q6 == NULL)
			goto dropfrag;

		TAILQ_INSERT_HEAD(&frag6_queue, q6, ip6q_queue);

		/* ip6q_nxt will be filled afterwards, from 1st fragment */
		LIST_INIT(&q6->ip6q_asfrag);
		q6->ip6q_ident	= ip6f->ip6f_ident;
		q6->ip6q_ttl	= IPV6_FRAGTTL;
		q6->ip6q_src	= ip6->ip6_src;
		q6->ip6q_dst	= ip6->ip6_dst;
		q6->ip6q_unfrglen = -1;	/* The 1st fragment has not arrived. */
		q6->ip6q_nfrag = 0;
	}

	/*
	 * If it's the 1st fragment, record the length of the
	 * unfragmentable part and the next header of the fragment header.
	 */
	if (fragoff == 0) {
		q6->ip6q_unfrglen = offset - sizeof(struct ip6_hdr) -
		    sizeof(struct ip6_frag);
		q6->ip6q_nxt = ip6f->ip6f_nxt;
	}

	/*
	 * Check that the reassembled packet would not exceed 65535 bytes
	 * in size.
	 * If it would exceed, discard the fragment and return an ICMP error.
	 */
	frgpartlen = sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen) - offset;
	if (q6->ip6q_unfrglen >= 0) {
		/* The 1st fragment has already arrived. */
		if (q6->ip6q_unfrglen + fragoff + frgpartlen > IPV6_MAXPACKET) {
			icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    offset - sizeof(struct ip6_frag) +
			    offsetof(struct ip6_frag, ip6f_offlg));
			IP6Q_UNLOCK();
			return (IPPROTO_DONE);
		}
	} else if (fragoff + frgpartlen > IPV6_MAXPACKET) {
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
			    offset - sizeof(struct ip6_frag) +
				offsetof(struct ip6_frag, ip6f_offlg));
		IP6Q_UNLOCK();
		return (IPPROTO_DONE);
	}
	/*
	 * If it's the first fragment, do the above check for each
	 * fragment already stored in the reassembly queue.
	 */
	if (fragoff == 0) {
		LIST_FOREACH_SAFE(af6, &q6->ip6q_asfrag, ip6af_list, naf6) {
			if (q6->ip6q_unfrglen + af6->ip6af_off +
			    af6->ip6af_frglen > IPV6_MAXPACKET) {
				struct mbuf *merr = IP6_REASS_MBUF(af6);
				struct ip6_hdr *ip6err;
				int erroff = af6->ip6af_offset;

				/* dequeue the fragment. */
				LIST_REMOVE(af6, ip6af_list);
				free(af6, M_FTABLE, sizeof(*af6));

				/* adjust pointer. */
				ip6err = mtod(merr, struct ip6_hdr *);

				/*
				 * Restore source and destination addresses
				 * in the erroneous IPv6 header.
				 */
				ip6err->ip6_src = q6->ip6q_src;
				ip6err->ip6_dst = q6->ip6q_dst;

				icmp6_error(merr, ICMP6_PARAM_PROB,
				    ICMP6_PARAMPROB_HEADER,
				    erroff - sizeof(struct ip6_frag) +
				    offsetof(struct ip6_frag, ip6f_offlg));
			}
		}
	}

	ip6af = malloc(sizeof(*ip6af), M_FTABLE, M_NOWAIT | M_ZERO);
	if (ip6af == NULL)
		goto dropfrag;
	ip6af->ip6af_flow = ip6->ip6_flow;
	ip6af->ip6af_mff = ip6f->ip6f_offlg & IP6F_MORE_FRAG;
	ip6af->ip6af_off = fragoff;
	ip6af->ip6af_frglen = frgpartlen;
	ip6af->ip6af_offset = offset;
	IP6_REASS_MBUF(ip6af) = m;

	if (first_frag) {
		paf6 = NULL;
		goto insert;
	}

	/*
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	af6 = LIST_FIRST(&q6->ip6q_asfrag);
	ecn = (ntohl(ip6->ip6_flow) >> 20) & IPTOS_ECN_MASK;
	ecn0 = (ntohl(af6->ip6af_flow) >> 20) & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT) {
			free(ip6af, M_FTABLE, sizeof(*ip6af));
			goto dropfrag;
		}
		if (ecn0 != IPTOS_ECN_CE)
			af6->ip6af_flow |= htonl(IPTOS_ECN_CE << 20);
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT) {
		free(ip6af, M_FTABLE, sizeof(*ip6af));
		goto dropfrag;
	}

	/*
	 * Find a segment which begins after this one does.
	 */
	for (paf6 = NULL, af6 = LIST_FIRST(&q6->ip6q_asfrag);
	    af6 != NULL;
	    paf6 = af6, af6 = LIST_NEXT(af6, ip6af_list))
		if (af6->ip6af_off > ip6af->ip6af_off)
			break;

	/*
	 * RFC 5722, Errata 3089:  When reassembling an IPv6 datagram, if one
	 * or more its constituent fragments is determined to be an overlapping
	 * fragment, the entire datagram (and any constituent fragments) MUST
	 * be silently discarded.
	 */
	if (paf6 != NULL) {
		i = (paf6->ip6af_off + paf6->ip6af_frglen) - ip6af->ip6af_off;
		if (i > 0) {
#if 0				/* suppress the noisy log */
			char ip[INET6_ADDRSTRLEN];
			log(LOG_ERR, "%d bytes of a fragment from %s "
			    "overlaps the previous fragment\n",
			    i,
			    inet_ntop(AF_INET6, &q6->ip6q_src, ip, sizeof(ip)));
#endif
			free(ip6af, M_FTABLE, sizeof(*ip6af));
			goto flushfrags;
		}
	}
	if (af6 != NULL) {
		i = (ip6af->ip6af_off + ip6af->ip6af_frglen) - af6->ip6af_off;
		if (i > 0) {
#if 0				/* suppress the noisy log */
			char ip[INET6_ADDRSTRLEN];
			log(LOG_ERR, "%d bytes of a fragment from %s "
			    "overlaps the succeeding fragment",
			    i,
			    inet_ntop(AF_INET6, &q6->ip6q_src, ip, sizeof(ip)));
#endif
			free(ip6af, M_FTABLE, sizeof(*ip6af));
			goto flushfrags;
		}
	}

 insert:
	/*
	 * Stick new segment in its place;
	 * check for complete reassembly.
	 * Move to front of packet queue, as we are
	 * the most recently active fragmented packet.
	 */
	if (paf6 != NULL)
		LIST_INSERT_AFTER(paf6, ip6af, ip6af_list);
	else
		LIST_INSERT_HEAD(&q6->ip6q_asfrag, ip6af, ip6af_list);
	frag6_nfrags++;
	q6->ip6q_nfrag++;
#if 0 /* xxx */
	if (q6 != TAILQ_FIRST(&frag6_queue)) {
		TAILQ_REMOVE(&frag6_queue, q6, ip6q_queue);
		TAILQ_INSERT_HEAD(&frag6_queue, q6, ip6q_queue);
	}
#endif
	next = 0;
	for (paf6 = NULL, af6 = LIST_FIRST(&q6->ip6q_asfrag);
	    af6 != NULL;
	    paf6 = af6, af6 = LIST_NEXT(af6, ip6af_list)) {
		if (af6->ip6af_off != next) {
			IP6Q_UNLOCK();
			return IPPROTO_DONE;
		}
		next += af6->ip6af_frglen;
	}
	if (paf6->ip6af_mff) {
		IP6Q_UNLOCK();
		return IPPROTO_DONE;
	}

	/*
	 * Reassembly is complete; concatenate fragments.
	 */
	ip6af = LIST_FIRST(&q6->ip6q_asfrag);
	LIST_REMOVE(ip6af, ip6af_list);
	t = m = IP6_REASS_MBUF(ip6af);
	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) != NULL) {
		LIST_REMOVE(af6, ip6af_list);
		while (t->m_next)
			t = t->m_next;
		t->m_next = IP6_REASS_MBUF(af6);
		m_adj(t->m_next, af6->ip6af_offset);
		free(af6, M_FTABLE, sizeof(*af6));
	}

	/* adjust offset to point where the original next header starts */
	offset = ip6af->ip6af_offset - sizeof(struct ip6_frag);
	free(ip6af, M_FTABLE, sizeof(*ip6af));
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_plen = htons((u_short)next + offset - sizeof(struct ip6_hdr));
	ip6->ip6_src = q6->ip6q_src;
	ip6->ip6_dst = q6->ip6q_dst;
	nxt = q6->ip6q_nxt;

	/* Delete frag6 header */
	if (frag6_deletefraghdr(m, offset) != 0) {
		TAILQ_REMOVE(&frag6_queue, q6, ip6q_queue);
		frag6_nfrags -= q6->ip6q_nfrag;
		free(q6, M_FTABLE, sizeof(*q6));
		frag6_nfragpackets--;
		goto dropfrag;
	}

	/*
	 * Store NXT to the original.
	 */
	{
		u_int8_t *prvnxtp = ip6_get_prevhdr(m, offset); /* XXX */
		*prvnxtp = nxt;
	}

	TAILQ_REMOVE(&frag6_queue, q6, ip6q_queue);
	frag6_nfrags -= q6->ip6q_nfrag;
	free(q6, M_FTABLE, sizeof(*q6));
	frag6_nfragpackets--;

	if (m->m_flags & M_PKTHDR) { /* Isn't it always true? */
		int plen = 0;
		for (t = m; t; t = t->m_next)
			plen += t->m_len;
		m->m_pkthdr.len = plen;
	}

	ip6stat_inc(ip6s_reassembled);

	/*
	 * Tell launch routine the next header
	 */

	*mp = m;
	*offp = offset;

	IP6Q_UNLOCK();
	return nxt;

 flushfrags:
	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) != NULL) {
		LIST_REMOVE(af6, ip6af_list);
		m_freem(IP6_REASS_MBUF(af6));
		free(af6, M_FTABLE, sizeof(*af6));
	}
	ip6stat_add(ip6s_fragdropped, q6->ip6q_nfrag);
	TAILQ_REMOVE(&frag6_queue, q6, ip6q_queue);
	frag6_nfrags -= q6->ip6q_nfrag;
	free(q6, M_FTABLE, sizeof(*q6));
	frag6_nfragpackets--;

 dropfrag:
	ip6stat_inc(ip6s_fragdropped);
	m_freem(m);
	IP6Q_UNLOCK();
	return IPPROTO_DONE;
}

/*
 * Delete fragment header after the unfragmentable header portions.
 */
int
frag6_deletefraghdr(struct mbuf *m, int offset)
{
	struct mbuf *t;

	if (m->m_len >= offset + sizeof(struct ip6_frag)) {
		memmove(mtod(m, caddr_t) + sizeof(struct ip6_frag),
		    mtod(m, caddr_t), offset);
		m->m_data += sizeof(struct ip6_frag);
		m->m_len -= sizeof(struct ip6_frag);
	} else {
		/* this comes with no copy if the boundary is on cluster */
		if ((t = m_split(m, offset, M_DONTWAIT)) == NULL)
			return (ENOBUFS);
		m_adj(t, sizeof(struct ip6_frag));
		m_cat(m, t);
	}

	return (0);
}

/*
 * Free a fragment reassembly header and all
 * associated datagrams.
 */
void
frag6_freef(struct ip6q *q6)
{
	struct ip6asfrag *af6;

	IP6Q_LOCK_CHECK();

	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) != NULL) {
		struct mbuf *m = IP6_REASS_MBUF(af6);

		LIST_REMOVE(af6, ip6af_list);

		/*
		 * Return ICMP time exceeded error for the 1st fragment.
		 * Just free other fragments.
		 */
		if (af6->ip6af_off == 0) {
			struct ip6_hdr *ip6;

			/* adjust pointer */
			ip6 = mtod(m, struct ip6_hdr *);

			/* restore source and destination addresses */
			ip6->ip6_src = q6->ip6q_src;
			ip6->ip6_dst = q6->ip6q_dst;

			icmp6_error(m, ICMP6_TIME_EXCEEDED,
				    ICMP6_TIME_EXCEED_REASSEMBLY, 0);
		} else
			m_freem(m);
		free(af6, M_FTABLE, sizeof(*af6));
	}
	TAILQ_REMOVE(&frag6_queue, q6, ip6q_queue);
	frag6_nfrags -= q6->ip6q_nfrag;
	free(q6, M_FTABLE, sizeof(*q6));
	frag6_nfragpackets--;
}

/*
 * IPv6 reassembling timer processing;
 * if a timer expires on a reassembly
 * queue, discard it.
 */
void
frag6_slowtimo(void)
{
	struct ip6q *q6, *nq6;

	splsoftassert(IPL_SOFTNET);

	IP6Q_LOCK();
	TAILQ_FOREACH_SAFE(q6, &frag6_queue, ip6q_queue, nq6)
		if (--q6->ip6q_ttl == 0) {
			ip6stat_inc(ip6s_fragtimeout);
			frag6_freef(q6);
		}

	/*
	 * If we are over the maximum number of fragments
	 * (due to the limit being lowered), drain off
	 * enough to get down to the new limit.
	 */
	while (frag6_nfragpackets > (u_int)ip6_maxfragpackets &&
	    !TAILQ_EMPTY(&frag6_queue)) {
		ip6stat_inc(ip6s_fragoverflow);
		frag6_freef(TAILQ_LAST(&frag6_queue, ip6q_head));
	}
	IP6Q_UNLOCK();
}

/*
 * Drain off all datagram fragments.
 */
void
frag6_drain(void)
{
	struct ip6q *q6;

	if (ip6q_lock_try() == 0)
		return;
	while ((q6 = TAILQ_FIRST(&frag6_queue)) != NULL) {
		ip6stat_inc(ip6s_fragdropped);
		frag6_freef(q6);
	}
	IP6Q_UNLOCK();
}
@


1.72
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.71 2016/11/28 11:12:45 mpi Exp $	*/
d157 1
a157 1
frag6_input(struct mbuf **mp, int *offp, int proto)
@


1.71
log
@Assert that every slow/fast timeout routine is called at IPL_SOFTNET.

This removes multipe recursive splsoftnet()/splx() dances.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.70 2016/10/24 11:09:05 bluhm Exp $	*/
d193 1
a193 1
	ip6stat.ip6s_fragments++;
d206 1
a206 1
		ip6stat.ip6s_reassembled++;
d499 1
a499 1
	ip6stat.ip6s_reassembled++;
d517 1
a517 1
	ip6stat.ip6s_fragdropped += q6->ip6q_nfrag;
d524 1
a524 1
	ip6stat.ip6s_fragdropped++;
d611 1
a611 1
			ip6stat.ip6s_fragtimeout++;
d622 1
a622 1
		ip6stat.ip6s_fragoverflow++;
d639 1
a639 1
		ip6stat.ip6s_fragdropped++;
@


1.70
log
@When the IPv6 network stack receives an empty non atomic fragment,
just drop it.  It can never overlap existing content, there is no
ambiguous payload.  So save resources and do not try to insert it
into the queue.  This makes our IPv6 stack behave like pf fragment
reassembly.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.69 2016/08/24 09:41:12 mpi Exp $	*/
a604 1
	int s;
d606 2
a607 1
	s = splsoftnet();
a625 1
	splx(s);
@


1.69
log
@Kill ip6_forward_rt reducing differences between v4 and v6.

A single forwarding cache is not the answer.  The answer is 42... err PF!

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.68 2016/08/22 10:33:22 mpi Exp $	*/
d209 6
@


1.68
log
@Sizes for free(9) from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.67 2016/03/07 18:44:00 naddy Exp $	*/
d599 1
a599 2
	int s = splsoftnet();
	extern struct route_in6 ip6_forward_rt;
d601 1
a619 11

	/*
	 * Routing changes might produce a better route than we last used;
	 * make sure we notice eventually, even if forwarding only for one
	 * destination and the cache is never replaced.
	 */
	if (ip6_forward_rt.ro_rt) {
		rtfree(ip6_forward_rt.ro_rt);
		ip6_forward_rt.ro_rt = NULL;
	}

@


1.67
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.66 2015/12/03 13:13:04 tedu Exp $	*/
d306 1
a306 1
				free(af6, M_FTABLE, 0);
d351 1
a351 1
			free(ip6af, M_FTABLE, 0);
d358 1
a358 1
		free(ip6af, M_FTABLE, 0);
d387 1
a387 1
			free(ip6af, M_FTABLE, 0);
d401 1
a401 1
			free(ip6af, M_FTABLE, 0);
d452 1
a452 1
		free(af6, M_FTABLE, 0);
d457 1
a457 1
	free(ip6af, M_FTABLE, 0);
d468 1
a468 1
		free(q6, M_FTABLE, 0);
d483 1
a483 1
	free(q6, M_FTABLE, 0);
d509 1
a509 1
		free(af6, M_FTABLE, 0);
d514 1
a514 1
	free(q6, M_FTABLE, 0);
d582 1
a582 1
		free(af6, M_FTABLE, 0);
d586 1
a586 1
	free(q6, M_FTABLE, 0);
@


1.66
log
@rewrite if to be more clear. ok bluhm stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.65 2015/10/22 10:22:53 mpi Exp $	*/
d67 1
a67 1
ip6q_lock_try()
d83 1
a83 1
ip6q_unlock()
@


1.65
log
@Kill dead code missed in per-ifp counter removal.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.64 2015/10/19 11:59:26 mpi Exp $	*/
d218 1
a218 3
	if (ip6_maxfrags < 0)
		;
	else if (frag6_nfrags >= (u_int)ip6_maxfrags)
d240 2
a241 3
		if (ip6_maxfragpackets < 0)
			;
		else if (frag6_nfragpackets >= (u_int)ip6_maxfragpackets)
@


1.64
log
@Remove superfluous NULL checks.

ifa are refcounted to ensure that rt_ifa is always valid.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.63 2015/09/10 16:39:39 mpi Exp $	*/
a166 3
	struct ifnet *dstifp;
	struct sockaddr_in6 dst;
	struct rtentry *rt;
a172 15

	dstifp = NULL;
	/* find the destination interface of the packet. */
	memset(&dst, 0, sizeof(dst));
	dst.sin6_family = AF_INET6;
	dst.sin6_len = sizeof(struct sockaddr_in6);
	dst.sin6_addr = ip6->ip6_dst;

	rt = rtalloc_mpath(sin6tosa(&dst), &ip6->ip6_src.s6_addr32[0],
	    m->m_pkthdr.ph_rtableid);
	if (rt != NULL) {
		dstifp = ifatoia6(rt->rt_ifa)->ia_ifp;
		rtfree(rt);
		rt = NULL;
	}
@


1.63
log
@Kill in6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_IN6 is no longer supported.

ok mikeb@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.62 2015/09/09 14:02:29 mpi Exp $	*/
a185 1

d187 1
a187 2
		if (rt->rt_ifa != NULL)
			dstifp = ifatoia6(rt->rt_ifa)->ia_ifp;
@


1.62
log
@Kill some commented out in6_ifstat_inc().
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.61 2015/07/08 07:31:14 mpi Exp $	*/
a196 1
		in6_ifstat_inc(dstifp, ifs6_reass_fail);
a209 1
		in6_ifstat_inc(dstifp, ifs6_reass_fail);
a213 1
	in6_ifstat_inc(dstifp, ifs6_reass_reqd);
a226 1
		in6_ifstat_inc(dstifp, ifs6_reass_ok);
a516 1
	in6_ifstat_inc(dstifp, ifs6_reass_ok);
a540 1
	in6_ifstat_inc(dstifp, ifs6_reass_fail);
@


1.61
log
@unifdef IN6_IFSTAT_STRICT.

ok deraadt@@, millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.60 2015/06/16 11:09:40 mpi Exp $	*/
a634 1
			/* XXX in6_ifstat_inc(ifp, ifs6_reass_fail) */
a645 1
		/* XXX in6_ifstat_inc(ifp, ifs6_reass_fail) */
a674 1
		/* XXX in6_ifstat_inc(ifp, ifs6_reass_fail) */
@


1.60
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.59 2014/12/08 10:51:00 mpi Exp $	*/
a55 7
/*
 * Define it to get a correct behavior on per-interface statistics.
 * You will need to perform an extra routing table lookup, per fragment,
 * to do it.  This may, or may not be, a performance hit.
 */
#define IN6_IFSTAT_STRICT

a167 1
#ifdef IN6_IFSTAT_STRICT
a169 1
#endif
a177 1
#ifdef IN6_IFSTAT_STRICT
a192 5
#else
	/* we are violating the spec, this is not the destination interface */
	if ((m->m_flags & M_PKTHDR) != 0)
		dstifp = if_get(m->m_pkthdr.ph_ifidx);
#endif
@


1.59
log
@Do not use a "struct route" when a "struct rtentry" is enough.

ok millert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.58 2014/12/05 15:50:04 mpi Exp $	*/
d206 1
a206 1
		dstifp = m->m_pkthdr.rcvif;
@


1.58
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.57 2014/11/18 02:37:31 tedu Exp $	*/
d176 2
a177 2
	struct route_in6 ro;
	struct sockaddr_in6 *dst;
d189 13
a201 15
	bzero(&ro, sizeof(ro));
	ro.ro_tableid = m->m_pkthdr.ph_rtableid;
	dst = &ro.ro_dst;
	dst->sin6_family = AF_INET6;
	dst->sin6_len = sizeof(struct sockaddr_in6);
	dst->sin6_addr = ip6->ip6_dst;

	ro.ro_rt = rtalloc_mpath(sin6tosa(&ro.ro_dst),
	    &ip6->ip6_src.s6_addr32[0], ro.ro_tableid);

	if (ro.ro_rt != NULL && ro.ro_rt->rt_ifa != NULL)
		dstifp = ifatoia6(ro.ro_rt->rt_ifa)->ia_ifp;
	if (ro.ro_rt != NULL) {
		rtfree(ro.ro_rt);
		ro.ro_rt = NULL;
@


1.57
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.56 2014/10/14 09:52:26 mpi Exp $	*/
d46 1
@


1.56
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.55 2014/09/27 12:26:16 mpi Exp $	*/
a53 2

#include <dev/rndvar.h>
@


1.55
log
@Kill rtalloc() and update rtalloc1() and rtalloc_mpath() to no longer
rely on "struct route" that should die.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.54 2014/07/22 11:06:10 mpi Exp $	*/
d203 1
a203 1
		RTFREE(ro.ro_rt);
d676 2
a677 2
		RTFREE(ip6_forward_rt.ro_rt);
		ip6_forward_rt.ro_rt = 0;
@


1.54
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.53 2014/07/12 18:44:23 tedu Exp $	*/
d197 2
a198 1
	rtalloc_mpath((struct route *)&ro, &ip6->ip6_src.s6_addr32[0]);
@


1.53
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.52 2014/04/14 09:06:42 mpi Exp $	*/
a52 1
#include <netinet/in_systm.h>	/* for ECN definitions */
@


1.52
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.51 2013/11/11 09:15:35 mpi Exp $	*/
d351 1
a351 1
				free(af6, M_FTABLE);
d396 1
a396 1
			free(ip6af, M_FTABLE);
d403 1
a403 1
		free(ip6af, M_FTABLE);
d432 1
a432 1
			free(ip6af, M_FTABLE);
d446 1
a446 1
			free(ip6af, M_FTABLE);
d497 1
a497 1
		free(af6, M_FTABLE);
d502 1
a502 1
	free(ip6af, M_FTABLE);
d513 1
a513 1
		free(q6, M_FTABLE);
d528 1
a528 1
	free(q6, M_FTABLE);
d555 1
a555 1
		free(af6, M_FTABLE);
d560 1
a560 1
	free(q6, M_FTABLE);
d629 1
a629 1
		free(af6, M_FTABLE);
d633 1
a633 1
	free(q6, M_FTABLE);
@


1.51
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.50 2013/10/20 11:03:02 phessler Exp $	*/
d192 1
a192 1
	ro.ro_tableid = m->m_pkthdr.rdomain;
@


1.50
log
@Put a large chunk of the IPv6 rdomain support in-tree.

Still some important missing pieces, and this is not yet enabled.

OK bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.49 2013/10/17 16:27:45 bluhm Exp $	*/
d426 1
d429 2
a430 1
			    i, ip6_sprintf(&q6->ip6q_src));
d440 1
d443 2
a444 1
			    i, ip6_sprintf(&q6->ip6q_src));
@


1.49
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.48 2013/08/27 08:20:32 mpi Exp $	*/
d192 1
@


1.48
log
@Sync comment with reality, the draft is now an RFC and OpenBSD follows
it since bluhm@@ implemented it in 2012.

From Loganaden Velvindron, ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.47 2013/06/11 18:15:54 deraadt Exp $	*/
d49 1
a49 1
#include <netinet/in_var.h>
@


1.47
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.46 2013/05/31 15:04:23 bluhm Exp $	*/
d239 4
a242 4
	 * draft-gont-6man-ipv6-atomic-fragments-00:  A host that receives an
	 * IPv6 packet which includes a Fragment Header with the "Fragment
	 * Offset" equal to 0 and the "M" bit equal to 0 MUST process such
	 * packet in isolation from any other packets/fragments.
@


1.46
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.45 2013/03/22 01:41:12 tedu Exp $	*/
d575 2
a576 2
		ovbcopy(mtod(m, caddr_t), mtod(m, caddr_t) +
		    sizeof(struct ip6_frag), offset);
@


1.45
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.44 2013/03/04 14:42:25 bluhm Exp $	*/
d192 1
a192 1
	dst = (struct sockaddr_in6 *)&ro.ro_dst;
@


1.44
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.43 2012/12/28 17:52:06 gsoares Exp $	*/
d270 1
a270 1
	if (q6 == TAILQ_END(&frag6_queue)) {
d381 1
a381 1
		paf6 = LIST_END(&q6->ip6q_asfrag);
d409 2
a410 3
	for (paf6 = LIST_END(&q6->ip6q_asfrag),
	    af6 = LIST_FIRST(&q6->ip6q_asfrag);
	    af6 != LIST_END(&q6->ip6q_asfrag);
d421 1
a421 1
	if (paf6 != LIST_END(&q6->ip6q_asfrag)) {
d433 1
a433 1
	if (af6 != LIST_END(&q6->ip6q_asfrag)) {
d453 1
a453 1
	if (paf6 != LIST_END(&q6->ip6q_asfrag))
d466 2
a467 3
	for (paf6 = LIST_END(&q6->ip6q_asfrag),
	    af6 = LIST_FIRST(&q6->ip6q_asfrag);
	    af6 != LIST_END(&q6->ip6q_asfrag);
d486 1
a486 2
	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) !=
	    LIST_END(&q6->ip6q_asfrag)) {
d547 1
a547 2
	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) !=
	    LIST_END(&q6->ip6q_asfrag)) {
d601 1
a601 2
	while ((af6 = LIST_FIRST(&q6->ip6q_asfrag)) !=
	    LIST_END(&q6->ip6q_asfrag)) {
d688 1
a688 1
	while ((q6 = TAILQ_FIRST(&frag6_queue)) != TAILQ_END(&frag6_queue)) {
@


1.43
log
@change the malloc(9) flags from M_DONTWAIT to M_NOWAIT; OK millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.42 2012/01/24 19:08:46 bluhm Exp $	*/
d200 1
a200 1
		dstifp = ((struct in6_ifaddr *)ro.ro_rt->rt_ifa)->ia_ifp;
@


1.42
log
@Add a short cut for atomic IPv6 fragments.  They will be processed
immediately and not go through the fragment queue.
See draft-gont-6man-ipv6-atomic-fragments-00.txt.
tested and ok sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.41 2012/01/23 18:37:20 bluhm Exp $	*/
d288 1
a288 1
		q6 = malloc(sizeof(*q6), M_FTABLE, M_DONTWAIT | M_ZERO);
d370 1
a370 1
	ip6af = malloc(sizeof(*ip6af), M_FTABLE, M_DONTWAIT | M_ZERO);
@


1.41
log
@Do not keep state when dropping overlapping IPv6 fragments in pf
and IPv6 stack.
ok sperreault@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.40 2012/01/10 17:09:02 bluhm Exp $	*/
d238 14
a307 1
	fragoff = ntohs(ip6f->ip6f_offlg & IP6F_OFF_MASK);
@


1.40
log
@Implement RFC 5722 and drop all IPv6 fragments that belong to a
packet with overlapping fragments.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.39 2012/01/10 12:50:32 bluhm Exp $	*/
a287 8
	} else if (LIST_EMPTY(&q6->ip6q_asfrag)) {
		/*
		 * Overlapping fragments have been detected.  Do not
		 * reassemble packet but also drop future fragments.
		 * This will be done for this ident/src/dst combination
		 * until fragment queue timeout.
		 */
		goto dropfrag;
d404 4
a407 4
	 * RFC5722:  When reassembling an IPv6 datagram, if one or more its
	 * constituent fragments is determined to be an overlapping fragment,
	 * the entire datagram (and any constituent fragments, including those
	 * not yet received) MUST be silently discarded.
d544 1
d546 2
a547 1
	q6->ip6q_nfrag = 0;
@


1.39
log
@Flush the cached IPv6 forward route every 500 ms.  This prevents
wrong checks for local addresses and wrong packet forwarding in
environments with only one communication partner and changing
addresses or routes.  Remove the #if 0 around the existing code to
make IPv6 behave like IPv4.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.38 2012/01/09 14:47:53 bluhm Exp $	*/
a286 1

d288 8
d412 4
a415 5
	 * If the incoming fragment overlaps some existing fragments in
	 * the reassembly queue, drop it, since it is dangerous to override
	 * existing fragments from a security point of view.
	 * We don't know which fragment is the bad guy - here we trust
	 * fragment that came in earlier, with no real reason.
d426 1
a426 1
			goto dropfrag;
d438 1
a438 1
			goto dropfrag;
d543 11
@


1.38
log
@Remove the IPv6 fragment overlapping length adjustment code.  It
was already #if 0 and will never come back.  Remove unused fragment
struct fields and sort the others.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.37 2012/01/09 01:01:12 bluhm Exp $	*/
d623 1
a645 1
#if 0
a654 1
#endif
@


1.37
log
@Replace the hand-crafted queue for IPv6 fragments with LIST.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.36 2012/01/05 21:14:47 bluhm Exp $	*/
a281 3
#ifdef notyet
		q6->ip6q_nxtp	= (u_char *)nxtp;
#endif
d283 1
a283 2
		q6->ip6q_arrive = 0; /* Is it used anywhere? */
		q6->ip6q_ttl 	= IPV6_FRAGTTL;
d361 1
a361 4
	ip6af->ip6af_head = ip6->ip6_flow;
	ip6af->ip6af_len = ip6->ip6_plen;
	ip6af->ip6af_nxt = ip6->ip6_nxt;
	ip6af->ip6af_hlim = ip6->ip6_hlim;
d380 1
a380 1
	ecn0 = (ntohl(af6->ip6af_head) >> 20) & IPTOS_ECN_MASK;
d387 1
a387 1
			af6->ip6af_head |= htonl(IPTOS_ECN_CE << 20);
a403 36
#if 0
	/*
	 * If there is a preceding segment, it may provide some of
	 * our data already.  If so, drop the data from the incoming
	 * segment.  If it provides all of our data, drop us.
	 */
	if (paf6 != LIST_END(&q6->ip6q_asfrag) {
		i = (paf6->ip6af_off + paf6->ip6af_frglen) - ip6af->ip6af_off;
		if (i > 0) {
			if (i >= ip6af->ip6af_frglen)
				goto dropfrag;
			m_adj(IP6_REASS_MBUF(ip6af), i);
			ip6af->ip6af_off += i;
			ip6af->ip6af_frglen -= i;
		}
	}

	/*
	 * While we overlap succeeding segments trim them or,
	 * if they are completely covered, dequeue them.
	 */
	while (af6 != LIST_END(&q6->ip6q_asfrag) &&
	    ip6af->ip6af_off + ip6af->ip6af_frglen > af6->ip6af_off) {
		i = (ip6af->ip6af_off + ip6af->ip6af_frglen) - af6->ip6af_off;
		if (i < af6->ip6af_frglen) {
			af6->ip6af_frglen -= i;
			af6->ip6af_off += i;
			m_adj(IP6_REASS_MBUF(af6), i);
			break;
		}
		naf6 = LIST_NEXT(af6, ip6af_list);
		m_freem(IP6_REASS_MBUF(af6));
		LIST_REMOVE(&q6->ip6q_asfrag, af6, ip6af_list);
		af6 = naf6;
	}
#else
a434 1
#endif
a494 3
#ifdef notyet
	*q6->ip6q_nxtp = (u_char)(nxt & 0xff);
#endif
@


1.36
log
@Remove dead code from #if 0: we do not have an ipsrcchk_rt anywhere else.
from FreeBSD; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.35 2012/01/05 20:54:28 bluhm Exp $	*/
a64 2
void frag6_enq(struct ip6asfrag *, struct ip6asfrag *);
void frag6_deq(struct ip6asfrag *);
d172 1
a172 1
	struct ip6asfrag *af6, *ip6af, *af6dwn;
d281 1
a281 1
		q6->ip6q_down	= q6->ip6q_up = (struct ip6asfrag *)q6;
d333 3
a335 6
		for (af6 = q6->ip6q_down; af6 != (struct ip6asfrag *)q6;
		     af6 = af6dwn) {
			af6dwn = af6->ip6af_down;

			if (q6->ip6q_unfrglen + af6->ip6af_off + af6->ip6af_frglen >
			    IPV6_MAXPACKET) {
d341 1
a341 1
				frag6_deq(af6);
d376 1
a376 1
		af6 = (struct ip6asfrag *)q6;
d385 1
d387 1
a387 1
	ecn0 = (ntohl(q6->ip6q_down->ip6af_head) >> 20) & IPTOS_ECN_MASK;
d394 1
a394 1
			q6->ip6q_down->ip6af_head |= htonl(IPTOS_ECN_CE << 20);
d404 4
a407 2
	for (af6 = q6->ip6q_down; af6 != (struct ip6asfrag *)q6;
	     af6 = af6->ip6af_down)
d417 2
a418 3
	if (af6->ip6af_up != (struct ip6asfrag *)q6) {
		i = af6->ip6af_up->ip6af_off + af6->ip6af_up->ip6af_frglen
			- ip6af->ip6af_off;
d432 2
a433 2
	while (af6 != (struct ip6asfrag *)q6 &&
	       ip6af->ip6af_off + ip6af->ip6af_frglen > af6->ip6af_off) {
d441 4
a444 3
		af6 = af6->ip6af_down;
		m_freem(IP6_REASS_MBUF(af6->ip6af_up));
		frag6_deq(af6->ip6af_up);
d454 2
a455 3
	if (af6->ip6af_up != (struct ip6asfrag *)q6) {
		i = af6->ip6af_up->ip6af_off + af6->ip6af_up->ip6af_frglen
			- ip6af->ip6af_off;
d466 1
a466 1
	if (af6 != (struct ip6asfrag *)q6) {
d480 1
a480 2
insert:

d487 4
a490 1
	frag6_enq(ip6af, af6->ip6af_up);
d500 4
a503 2
	for (af6 = q6->ip6q_down; af6 != (struct ip6asfrag *)q6;
	     af6 = af6->ip6af_down) {
d510 1
a510 1
	if (af6->ip6af_up->ip6af_mff) {
d518 2
a519 1
	ip6af = q6->ip6q_down;
d521 3
a523 5
	af6 = ip6af->ip6af_down;
	frag6_deq(ip6af);
	while (af6 != (struct ip6asfrag *)q6) {
		af6dwn = af6->ip6af_down;
		frag6_deq(af6);
a528 1
		af6 = af6dwn;
d624 1
a624 1
	struct ip6asfrag *af6, *down6;
d628 2
a629 2
	for (af6 = q6->ip6q_down; af6 != (struct ip6asfrag *)q6;
	     af6 = down6) {
d632 1
a632 2
		down6 = af6->ip6af_down;
		frag6_deq(af6);
a657 29
}

/*
 * Put an ip fragment on a reassembly chain.
 * Like insque, but pointers in middle of structure.
 */
void
frag6_enq(struct ip6asfrag *af6, struct ip6asfrag *up6)
{

	IP6Q_LOCK_CHECK();

	af6->ip6af_up = up6;
	af6->ip6af_down = up6->ip6af_down;
	up6->ip6af_down->ip6af_up = af6;
	up6->ip6af_down = af6;
}

/*
 * To frag6_enq as remque is to insque.
 */
void
frag6_deq(struct ip6asfrag *af6)
{

	IP6Q_LOCK_CHECK();

	af6->ip6af_up->ip6af_down = af6->ip6af_down;
	af6->ip6af_down->ip6af_up = af6->ip6af_up;
@


1.35
log
@Replace the hand-crafted queue for fragmented IPv6 packets with TAILQ.
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.34 2011/05/02 22:16:33 chl Exp $	*/
a731 4
	}
	if (ipsrcchk_rt.ro_rt) {
		RTFREE(ipsrcchk_rt.ro_rt);
		ipsrcchk_rt.ro_rt = 0;
@


1.34
log
@Fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.33 2011/04/03 13:54:21 stsp Exp $	*/
a66 2
void frag6_insque(struct ip6q *, struct ip6q *);
void frag6_remque(struct ip6q *);
d72 1
a72 1
struct	ip6q ip6q;	/* ip6 reassemble queue */
d132 1
a132 1
	ip6q.ip6q_next = ip6q.ip6q_prev = &ip6q;
d236 1
a236 1
	
d252 1
a252 1
	for (q6 = ip6q.ip6q_next; q6 != &ip6q; q6 = q6->ip6q_next)
d258 1
a258 1
	if (q6 == &ip6q) {
d280 1
a280 1
		frag6_insque(q6, &ip6q);
d495 3
a497 3
	if (q6 != ip6q.ip6q_next) {
		frag6_remque(q6);
		frag6_insque(q6, &ip6q);
d546 1
a546 1
		frag6_remque(q6);
d561 1
a561 1
	frag6_remque(q6);
d572 1
a572 1
	
d656 1
a656 1
	frag6_remque(q6);
a690 22
void
frag6_insque(struct ip6q *new, struct ip6q *old)
{

	IP6Q_LOCK_CHECK();

	new->ip6q_prev = old;
	new->ip6q_next = old->ip6q_next;
	old->ip6q_next->ip6q_prev= new;
	old->ip6q_next = new;
}

void
frag6_remque(struct ip6q *p6)
{

	IP6Q_LOCK_CHECK();

	p6->ip6q_prev->ip6q_next = p6->ip6q_next;
	p6->ip6q_next->ip6q_prev = p6->ip6q_prev;
}

d699 1
a699 1
	struct ip6q *q6;
d703 5
a707 10
	q6 = ip6q.ip6q_next;
	if (q6)
		while (q6 != &ip6q) {
			--q6->ip6q_ttl;
			q6 = q6->ip6q_next;
			if (q6->ip6q_prev->ip6q_ttl == 0) {
				ip6stat.ip6s_fragtimeout++;
				/* XXX in6_ifstat_inc(ifp, ifs6_reass_fail) */
				frag6_freef(q6->ip6q_prev);
			}
d709 1
d716 1
a716 1
	    ip6q.ip6q_prev) {
d719 1
a719 1
		frag6_freef(ip6q.ip6q_prev);
d748 1
d752 1
a752 1
	while (ip6q.ip6q_next != &ip6q) {
d755 1
a755 1
		frag6_freef(ip6q.ip6q_next);
@


1.33
log
@Kill redundant offsetof definitions; ok deraadt henning sthen thib
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.32 2011/03/06 19:55:54 bluhm Exp $	*/
d205 4
a208 2
	RTFREE(ro.ro_rt);
	ro.ro_rt = NULL;
@


1.32
log
@Extract the new function frag6_deletefraghdr() from frag6_input()
to make it reusable by pf.  No functional change.
ok henning@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.31 2011/01/13 23:36:53 bluhm Exp $	*/
a125 4

#ifndef offsetof		/* XXX */
#define	offsetof(type, member)	((size_t)(&((type *)0)->member))
#endif
@


1.31
log
@In frag6_input() there was an mbuf length calculation error.  If
you want to move "offset" bytes forward by "sizeof(struct ip6_frag)"
bytes within an mbuf, you must have at least "offset + sizeof(struct
ip6_frag)" bytes space in that mbuf.
Fix from KAME, FreeBSD also has it.
ok claudio@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.30 2010/05/07 13:33:17 claudio Exp $	*/
d549 6
a554 17
	if (m->m_len >= offset + sizeof(struct ip6_frag)) {
		/* This is the only possible case with !PULLDOWN_TEST */
		ovbcopy((caddr_t)ip6, (caddr_t)ip6 + sizeof(struct ip6_frag),
		    offset);
		m->m_data += sizeof(struct ip6_frag);
		m->m_len -= sizeof(struct ip6_frag);
	} else {
		/* this comes with no copy if the boundary is on cluster */
		if ((t = m_split(m, offset, M_DONTWAIT)) == NULL) {
			frag6_remque(q6);
			frag6_nfrags -= q6->ip6q_nfrag;
			free(q6, M_FTABLE);
			frag6_nfragpackets--;
			goto dropfrag;
		}
		m_adj(t, sizeof(struct ip6_frag));
		m_cat(m, t);
d596 24
@


1.30
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.29 2010/02/08 11:51:16 jsing Exp $	*/
d548 3
a550 4
	/*
	 * Delete frag6 header with as a few cost as possible.
	 */
	if (offset < m->m_len) {
d552 1
a552 1
			offset);
@


1.29
log
@Destatic and ansify.

ok claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.27 2008/11/23 13:30:59 claudio Exp $	*/
d186 1
a186 1
	static struct route_in6 ro;
d199 1
d201 3
a203 11
	if (ro.ro_rt && ((ro.ro_rt->rt_flags & RTF_UP) == 0
	  || !IN6_ARE_ADDR_EQUAL(&dst->sin6_addr, &ip6->ip6_dst))) {
		RTFREE(ro.ro_rt);
		ro.ro_rt = (struct rtentry *)0;
	}
	if (ro.ro_rt == NULL) {
		bzero(dst, sizeof(*dst));
		dst->sin6_family = AF_INET6;
		dst->sin6_len = sizeof(struct sockaddr_in6);
		dst->sin6_addr = ip6->ip6_dst;
	}
d205 1
a205 1
	rtalloc_mpath((struct route *)&ro, &ip6->ip6_src.s6_addr32[0], 0);
d209 2
@


1.28
log
@- obvious typo in comment, from holger mikolon
@
text
@d65 5
a69 5
static void frag6_enq(struct ip6asfrag *, struct ip6asfrag *);
static void frag6_deq(struct ip6asfrag *);
static void frag6_insque(struct ip6q *, struct ip6q *);
static void frag6_remque(struct ip6q *);
static void frag6_freef(struct ip6q *);
d135 1
a135 1
frag6_init()
d716 1
a716 1
frag6_slowtimo()
d769 1
a769 1
frag6_drain()
@


1.27
log
@When accessing cached routes make sure the route is actually still valid.
Before accessing a ro_rt make sure the route is either freshly allocated or
RTF_UP is set. If not ro_rt should be freed and reallocated or at least no
info from the ro_rt should be considered valid.
This seems to solve the crashes seen by Felipe Alfaro Solana.
some sort of OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.26 2008/06/11 19:00:50 mcbride Exp $	*/
d643 1
a643 1
			/* restoure source and destination addresses */
@


1.26
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.25 2007/12/09 21:24:58 hshoexer Exp $	*/
d200 1
a200 2
	if (ro.ro_rt
	 && ((ro.ro_rt->rt_flags & RTF_UP) == 0
@


1.25
log
@take advantage of M_ZERO

ok claudio gilles
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.24 2007/05/01 03:38:45 ray Exp $	*/
d174 1
a174 3
frag6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
d621 1
a621 2
frag6_freef(q6)
	struct ip6q *q6;
d665 1
a665 2
frag6_enq(af6, up6)
	struct ip6asfrag *af6, *up6;
d680 1
a680 2
frag6_deq(af6)
	struct ip6asfrag *af6;
d690 1
a690 2
frag6_insque(new, old)
	struct ip6q *new, *old;
d702 1
a702 2
frag6_remque(p6)
	struct ip6q *p6;
@


1.24
log
@framgent -> fragment
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.23 2006/06/18 11:47:46 pascoe Exp $	*/
d288 1
a288 2
		q6 = (struct ip6q *)malloc(sizeof(struct ip6q), M_FTABLE,
		    M_DONTWAIT);
a290 1
		bzero(q6, sizeof(*q6));
d379 1
a379 2
	ip6af = (struct ip6asfrag *)malloc(sizeof(struct ip6asfrag), M_FTABLE,
	    M_DONTWAIT);
a381 1
	bzero(ip6af, sizeof(*ip6af));
@


1.23
log
@Add support for equal-cost multipath IP.

To minimise path disruptions, this implements recommendations made in RFC2992 -
the hash-threshold mechanism to select paths based on source/destination IP
address pairs, and inserts multipath routes in the middle of the route table.

To enable multipath distribution, use:
   sysctl net.inet.ip.multipath=1
and/or:
   sysctl net.inet6.ip6.multipath=1

testing norby@@
ok claudio@@ henning@@ hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.22 2005/11/20 19:25:16 brad Exp $	*/
d466 1
a466 1
	 * If the incoming framgent overlaps some existing fragments in
@


1.22
log
@splimp -> splvm. mbuf allocation here.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.21 2003/10/01 21:41:05 itojun Exp $	*/
d215 1
a215 1
	rtalloc((struct route *)&ro);
@


1.21
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.20 2003/05/14 14:24:44 itojun Exp $	*/
d84 2
a85 1
	s = splimp();
d100 1
a100 1
	s = splimp();
@


1.20
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.19 2002/09/11 03:27:30 itojun Exp $	*/
d136 1
a136 1
	ip6_id = arc4random();
@


1.19
log
@fix pointer signedness mixup.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.18 2002/09/11 03:15:36 itojun Exp $	*/
a192 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, offset, sizeof(struct ip6_frag), IPPROTO_DONE);
	ip6f = (struct ip6_frag *)((caddr_t)ip6 + offset);
#else
a195 1
#endif
@


1.18
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.17 2002/06/08 21:51:08 itojun Exp $	*/
d589 1
a589 1
		char *prvnxtp = ip6_get_prevhdr(m, offset); /* XXX */
@


1.17
log
@splnet -> splsoftnet where appropriate
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.16 2002/05/28 03:04:38 itojun Exp $	*/
d339 1
a339 1
			return(IPPROTO_DONE);
d346 1
a346 1
		return(IPPROTO_DONE);
@


1.16
log
@limit number of IPv6 fragments (not the fragment queue size) to
fight against lots-of-frags DoS attacks.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.15 2002/05/27 19:48:27 deraadt Exp $	*/
d735 1
a735 1
	int s = splnet();
@


1.15
log
@kill __P
@
text
@d1 2
a2 2
/*	$OpenBSD: frag6.c,v 1.14 2002/05/16 14:10:51 kjc Exp $	*/
/*	$KAME: frag6.c,v 1.31 2001/05/17 13:45:34 jinmei Exp $	*/
d73 1
d244 2
a245 3
		icmp6_error(m, ICMP6_PARAM_PROB,
			    ICMP6_PARAMPROB_HEADER,
			    offsetof(struct ip6_hdr, ip6_plen));
d258 10
d283 3
a285 2
		 * If maxfrag is 0, never accept fragments.
		 * If maxfrag is -1, accept all fragments without limitation.
d293 1
a293 1
			M_DONTWAIT);
d311 2
d321 2
a322 2
		q6->ip6q_unfrglen = offset - sizeof(struct ip6_hdr)
			- sizeof(struct ip6_frag);
d336 2
a337 2
				    offset - sizeof(struct ip6_frag) +
					offsetof(struct ip6_frag, ip6f_offlg));
d341 1
a341 2
	}
	else if (fragoff + frgpartlen > IPV6_MAXPACKET) {
d378 3
a380 3
					    ICMP6_PARAMPROB_HEADER,
					    erroff - sizeof(struct ip6_frag) +
						offsetof(struct ip6_frag, ip6f_offlg));
d473 2
d512 2
d576 1
d594 1
d666 1
@


1.14
log
@bring in ECN support from KAME.
it consists of
 - ECN support in TCP
 - tunnel-egress and fragment reassembly rules in layer-3 not to lose
   congestion info at tunnel-egress and fragment reassembly

to enable ECN in TCP, build a kernel with TCP_ECN, and then,
turn it on by "sysctl -w net.inet.tcp.ecn=1".

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.13 2002/03/15 10:50:59 itojun Exp $	*/
d75 2
a76 2
static __inline int ip6q_lock_try __P((void));
static __inline void ip6q_unlock __P((void));
@


1.13
log
@have a real lock around IPv6 reassembly.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.12 2002/03/14 01:27:11 millert Exp $	*/
d53 2
d189 1
d391 20
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.11 2001/06/09 06:43:37 angelos Exp $	*/
d69 1
a69 2
/* XXX we eventually need splreass6, or some real semaphore */
int frag6_doing_reass;
d73 50
d253 1
a253 1
	frag6_doing_reass = 1;
d322 1
a322 1
			frag6_doing_reass = 0;
d330 1
a330 1
		frag6_doing_reass = 0;
d485 1
a485 1
			frag6_doing_reass = 0;
d491 1
a491 1
		frag6_doing_reass = 0;
d574 1
a574 1
	frag6_doing_reass = 0;
d581 1
a581 1
	frag6_doing_reass = 0;
d595 2
d637 3
d653 3
d664 3
d677 3
d695 1
a695 1
	frag6_doing_reass = 1;
d718 1
a718 1
	frag6_doing_reass = 0;
d745 2
a746 1
	if (frag6_doing_reass)
d753 1
@


1.11
log
@No need for net/net_osdep.h
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.10 2001/05/17 18:11:26 itojun Exp $	*/
d63 5
a67 5
static void frag6_enq __P((struct ip6asfrag *, struct ip6asfrag *));
static void frag6_deq __P((struct ip6asfrag *));
static void frag6_insque __P((struct ip6q *, struct ip6q *));
static void frag6_remque __P((struct ip6q *));
static void frag6_freef __P((struct ip6q *));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: frag6.c,v 1.40 2002/05/27 21:40:31 itojun Exp $	*/
a52 2
#include <netinet/in_systm.h>	/* for ECN definitions */
#include <netinet/ip.h>		/* for ECN definitions */
d63 5
a67 5
static void frag6_enq(struct ip6asfrag *, struct ip6asfrag *);
static void frag6_deq(struct ip6asfrag *);
static void frag6_insque(struct ip6q *, struct ip6q *);
static void frag6_remque(struct ip6q *);
static void frag6_freef(struct ip6q *);
d69 2
a70 1
static int ip6q_locked;
a71 1
u_int frag6_nfrags;
a73 50
static __inline int ip6q_lock_try(void);
static __inline void ip6q_unlock(void);

static __inline int
ip6q_lock_try()
{
	int s;

	s = splimp();
	if (ip6q_locked) {
		splx(s);
		return (0);
	}
	ip6q_locked = 1;
	splx(s);
	return (1);
}

static __inline void
ip6q_unlock()
{
	int s;

	s = splimp();
	ip6q_locked = 0;
	splx(s);
}

#ifdef DIAGNOSTIC
#define	IP6Q_LOCK()							\
do {									\
	if (ip6q_lock_try() == 0) {					\
		printf("%s:%d: ip6q already locked\n", __FILE__, __LINE__); \
		panic("ip6q_lock");					\
	}								\
} while (0)
#define	IP6Q_LOCK_CHECK()						\
do {									\
	if (ip6q_locked == 0) {						\
		printf("%s:%d: ip6q lock not held\n", __FILE__, __LINE__); \
		panic("ip6q lock check");				\
	}								\
} while (0)
#else
#define	IP6Q_LOCK()		(void) ip6q_lock_try()
#define	IP6Q_LOCK_CHECK()	/* nothing */
#endif

#define	IP6Q_UNLOCK()		ip6q_unlock()

a137 1
	u_int8_t ecn, ecn0;
d191 3
a193 2
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
		    offsetof(struct ip6_hdr, ip6_plen));
d204 1
a204 11
	IP6Q_LOCK();

	/*
	 * Enforce upper bound on number of fragments.
	 * If maxfrag is 0, never accept fragments.
	 * If maxfrag is -1, accept all fragments without limitation.
	 */
	if (ip6_maxfrags < 0)
		;
	else if (frag6_nfrags >= (u_int)ip6_maxfrags)
		goto dropfrag;
d221 2
a222 3
		 * If maxfragpackets is 0, never accept fragments.
		 * If maxfragpackets is -1, accept all fragments without
		 * limitation.
d230 1
a230 1
		    M_DONTWAIT);
a247 2

		q6->ip6q_nfrag = 0;
d256 2
a257 2
		q6->ip6q_unfrglen = offset - sizeof(struct ip6_hdr) -
		    sizeof(struct ip6_frag);
d271 3
a273 3
			    offset - sizeof(struct ip6_frag) +
			    offsetof(struct ip6_frag, ip6f_offlg));
			IP6Q_UNLOCK();
d276 2
a277 1
	} else if (fragoff + frgpartlen > IPV6_MAXPACKET) {
d281 1
a281 1
		IP6Q_UNLOCK();
d314 3
a316 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff - sizeof(struct ip6_frag) +
				    offsetof(struct ip6_frag, ip6f_offlg));
a341 20
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	ecn = (ntohl(ip6->ip6_flow) >> 20) & IPTOS_ECN_MASK;
	ecn0 = (ntohl(q6->ip6q_down->ip6af_head) >> 20) & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT) {
			free(ip6af, M_FTABLE);
			goto dropfrag;
		}
		if (ecn0 != IPTOS_ECN_CE)
			q6->ip6q_down->ip6af_head |= htonl(IPTOS_ECN_CE << 20);
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT) {
		free(ip6af, M_FTABLE);
		goto dropfrag;
	}

	/*
a388 2
	 * We don't know which fragment is the bad guy - here we trust
	 * fragment that came in earlier, with no real reason.
a425 2
	frag6_nfrags++;
	q6->ip6q_nfrag++;
d436 1
a436 1
			IP6Q_UNLOCK();
d442 1
a442 1
		IP6Q_UNLOCK();
a487 1
			frag6_nfrags -= q6->ip6q_nfrag;
a504 1
	frag6_nfrags -= q6->ip6q_nfrag;
d525 1
a525 1
	IP6Q_UNLOCK();
d532 1
a532 1
	IP6Q_UNLOCK();
a545 2
	IP6Q_LOCK_CHECK();

a573 1
	frag6_nfrags -= q6->ip6q_nfrag;
a585 3

	IP6Q_LOCK_CHECK();

a598 3

	IP6Q_LOCK_CHECK();

a606 3

	IP6Q_LOCK_CHECK();

a616 3

	IP6Q_LOCK_CHECK();

d630 1
a630 1
	int s = splsoftnet();
d632 1
a632 1
	IP6Q_LOCK();
d655 1
a655 1
	IP6Q_UNLOCK();
d682 1
a682 2

	if (ip6q_lock_try() == 0)
a688 1
	IP6Q_UNLOCK();
@


1.11.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.11.4.1 2002/06/11 03:31:37 art Exp $	*/
d339 1
a339 1
			return (IPPROTO_DONE);
d346 1
a346 1
		return (IPPROTO_DONE);
d589 1
a589 1
		u_int8_t *prvnxtp = ip6_get_prevhdr(m, offset); /* XXX */
@


1.11.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d193 4
d200 1
@


1.10
log
@fix memory leak on ipv6 reass failure.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.9 2001/02/22 05:11:52 itojun Exp $	*/
a54 2

#include <net/net_osdep.h>
@


1.9
log
@correct behavior when ip6 reass queue reaches the upper limit.
@
text
@d1 2
a2 2
/*	$OpenBSD: frag6.c,v 1.8 2001/02/16 08:50:23 itojun Exp $	*/
/*	$KAME: frag6.c,v 1.30 2001/02/22 04:52:36 itojun Exp $	*/
d71 1
d396 1
d400 2
d408 1
d412 2
@


1.8
log
@set frag6_doing_reass while doing reass, to help frag6_drain.
@
text
@d1 2
a2 2
/*	$OpenBSD: frag6.c,v 1.7 2001/02/16 08:48:05 itojun Exp $	*/
/*	$KAME: frag6.c,v 1.28 2000/12/12 10:54:06 itojun Exp $	*/
a217 1
		frag6_nfragpackets++;
d225 5
a229 5
		if (frag6_nfragpackets >= (u_int)ip6_maxfragpackets) {
			ip6stat.ip6s_fragoverflow++;
			in6_ifstat_inc(dstifp, ifs6_reass_fail);
			frag6_freef(ip6q.ip6q_prev);
		}
d644 2
a645 1
	while (frag6_nfragpackets > (u_int)ip6_maxfragpackets) {
@


1.7
log
@sync whitespace/comment with kame.  to help merge tasks
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.6 2000/02/07 06:09:09 itojun Exp $	*/
d54 2
a57 2
#include <dev/rndvar.h>

d77 1
a77 1
#endif 
d205 2
d275 1
d283 1
d528 1
a626 3
#if 0
	extern struct	route_in6 ip6_forward_rt;
#endif
@


1.6
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: frag6.c,v 1.5 2000/02/04 18:11:38 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d101 1
a101 1
 * reassembly rule (p21): 
d186 1
a186 1
	 * multiple of 8 octets. 
d220 1
a220 1
		 * for which we attempt reassembly; 
d594 1
a594 1
void 
d613 1
a613 1
 * IP timer processing;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: frag6.c,v 1.9 2001/02/22 05:11:52 itojun Exp $	*/
/*	$KAME: frag6.c,v 1.30 2001/02/22 04:52:36 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d53 2
a56 2
#include <net/net_osdep.h>

d76 1
a76 1
#endif
d100 1
a100 1
 * reassembly rule (p21):
d185 1
a185 1
	 * multiple of 8 octets.
a203 2
	frag6_doing_reass = 1;

d215 1
d219 1
a219 1
		 * for which we attempt reassembly;
d223 5
a227 5
		if (ip6_maxfragpackets < 0)
			;
		else if (frag6_nfragpackets >= (u_int)ip6_maxfragpackets)
			goto dropfrag;
		frag6_nfragpackets++;
a271 1
			frag6_doing_reass = 0;
a278 1
		frag6_doing_reass = 0;
a522 1
	frag6_doing_reass = 0;
d593 1
a593 1
void
d612 1
a612 1
 * IPv6 reassembling timer processing;
d621 3
d642 1
a642 2
	while (frag6_nfragpackets > (u_int)ip6_maxfragpackets &&
	    ip6q.ip6q_prev) {
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: frag6.c,v 1.31 2001/05/17 13:45:34 jinmei Exp $	*/
d56 2
a70 1
/* XXX we eventually need splreass6, or some real semaphore */
a394 1
#if 0				/* suppress the noisy log */
a397 2
#endif
			free(ip6af, M_FTABLE);
a403 1
#if 0				/* suppress the noisy log */
a406 2
#endif
			free(ip6af, M_FTABLE);
@


1.6.2.3
log
@Merge in -current from roughly a week ago
@
text
@d63 5
a67 5
static void frag6_enq(struct ip6asfrag *, struct ip6asfrag *);
static void frag6_deq(struct ip6asfrag *);
static void frag6_insque(struct ip6q *, struct ip6q *);
static void frag6_remque(struct ip6q *);
static void frag6_freef(struct ip6q *);
d69 2
a70 1
static int ip6q_locked;
a73 50
static __inline int ip6q_lock_try __P((void));
static __inline void ip6q_unlock __P((void));

static __inline int
ip6q_lock_try()
{
	int s;

	s = splimp();
	if (ip6q_locked) {
		splx(s);
		return (0);
	}
	ip6q_locked = 1;
	splx(s);
	return (1);
}

static __inline void
ip6q_unlock()
{
	int s;

	s = splimp();
	ip6q_locked = 0;
	splx(s);
}

#ifdef DIAGNOSTIC
#define	IP6Q_LOCK()							\
do {									\
	if (ip6q_lock_try() == 0) {					\
		printf("%s:%d: ip6q already locked\n", __FILE__, __LINE__); \
		panic("ip6q_lock");					\
	}								\
} while (0)
#define	IP6Q_LOCK_CHECK()						\
do {									\
	if (ip6q_locked == 0) {						\
		printf("%s:%d: ip6q lock not held\n", __FILE__, __LINE__); \
		panic("ip6q lock check");				\
	}								\
} while (0)
#else
#define	IP6Q_LOCK()		(void) ip6q_lock_try()
#define	IP6Q_LOCK_CHECK()	/* nothing */
#endif

#define	IP6Q_UNLOCK()		ip6q_unlock()

d204 1
a204 1
	IP6Q_LOCK();
d273 1
a273 1
			IP6Q_UNLOCK();
d281 1
a281 1
		IP6Q_UNLOCK();
d436 1
a436 1
			IP6Q_UNLOCK();
d442 1
a442 1
		IP6Q_UNLOCK();
d525 1
a525 1
	IP6Q_UNLOCK();
d532 1
a532 1
	IP6Q_UNLOCK();
a545 2
	IP6Q_LOCK_CHECK();

a585 3

	IP6Q_LOCK_CHECK();

a598 3

	IP6Q_LOCK_CHECK();

a606 3

	IP6Q_LOCK_CHECK();

a616 3

	IP6Q_LOCK_CHECK();

d632 1
a632 1
	IP6Q_LOCK();
d655 1
a655 1
	IP6Q_UNLOCK();
d682 1
a682 2

	if (ip6q_lock_try() == 0)
a688 1
	IP6Q_UNLOCK();
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$KAME: frag6.c,v 1.40 2002/05/27 21:40:31 itojun Exp $	*/
a52 2
#include <netinet/in_systm.h>	/* for ECN definitions */
#include <netinet/ip.h>		/* for ECN definitions */
a70 1
u_int frag6_nfrags;
d73 2
a74 2
static __inline int ip6q_lock_try(void);
static __inline void ip6q_unlock(void);
a186 1
	u_int8_t ecn, ecn0;
d240 3
a242 2
		icmp6_error(m, ICMP6_PARAM_PROB, ICMP6_PARAMPROB_HEADER,
		    offsetof(struct ip6_hdr, ip6_plen));
a254 10
	/*
	 * Enforce upper bound on number of fragments.
	 * If maxfrag is 0, never accept fragments.
	 * If maxfrag is -1, accept all fragments without limitation.
	 */
	if (ip6_maxfrags < 0)
		;
	else if (frag6_nfrags >= (u_int)ip6_maxfrags)
		goto dropfrag;

d270 2
a271 3
		 * If maxfragpackets is 0, never accept fragments.
		 * If maxfragpackets is -1, accept all fragments without
		 * limitation.
d279 1
a279 1
		    M_DONTWAIT);
a296 2

		q6->ip6q_nfrag = 0;
d305 2
a306 2
		q6->ip6q_unfrglen = offset - sizeof(struct ip6_hdr) -
		    sizeof(struct ip6_frag);
d320 2
a321 2
			    offset - sizeof(struct ip6_frag) +
			    offsetof(struct ip6_frag, ip6f_offlg));
d323 1
a323 1
			return (IPPROTO_DONE);
d325 2
a326 1
	} else if (fragoff + frgpartlen > IPV6_MAXPACKET) {
d331 1
a331 1
		return (IPPROTO_DONE);
d363 3
a365 3
				    ICMP6_PARAMPROB_HEADER,
				    erroff - sizeof(struct ip6_frag) +
				    offsetof(struct ip6_frag, ip6f_offlg));
a390 20
	 * Handle ECN by comparing this segment with the first one;
	 * if CE is set, do not lose CE.
	 * drop if CE and not-ECT are mixed for the same packet.
	 */
	ecn = (ntohl(ip6->ip6_flow) >> 20) & IPTOS_ECN_MASK;
	ecn0 = (ntohl(q6->ip6q_down->ip6af_head) >> 20) & IPTOS_ECN_MASK;
	if (ecn == IPTOS_ECN_CE) {
		if (ecn0 == IPTOS_ECN_NOTECT) {
			free(ip6af, M_FTABLE);
			goto dropfrag;
		}
		if (ecn0 != IPTOS_ECN_CE)
			q6->ip6q_down->ip6af_head |= htonl(IPTOS_ECN_CE << 20);
	}
	if (ecn == IPTOS_ECN_NOTECT && ecn0 != IPTOS_ECN_NOTECT) {
		free(ip6af, M_FTABLE);
		goto dropfrag;
	}

	/*
a437 2
	 * We don't know which fragment is the bad guy - here we trust
	 * fragment that came in earlier, with no real reason.
a474 2
	frag6_nfrags++;
	q6->ip6q_nfrag++;
a536 1
			frag6_nfrags -= q6->ip6q_nfrag;
d549 1
a549 1
		u_int8_t *prvnxtp = ip6_get_prevhdr(m, offset); /* XXX */
a553 1
	frag6_nfrags -= q6->ip6q_nfrag;
a624 1
	frag6_nfrags -= q6->ip6q_nfrag;
d693 1
a693 1
	int s = splsoftnet();
@


1.6.2.5
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d193 4
d200 1
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d136 1
a136 1

@


1.5
log
@make IPv6 reass work on alpha.  NetBSD PR 9340.
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.4 2000/01/08 05:28:08 deraadt Exp $	*/
d49 1
a49 1
#include <netinet6/ip6.h>
d51 1
a51 1
#include <netinet6/icmp6.h>
@


1.4
log
@pull in arc4random() prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.3 2000/01/08 04:49:22 deraadt Exp $	*/
d74 4
d84 1
a85 1
	ip6_id = arc4random();
d89 29
d129 1
a129 1
	struct ip6asfrag *af6, *ip6af;
d132 1
a132 1
	u_short fragoff, frgpartlen;
d193 1
a193 1
			    (caddr_t)&ip6->ip6_plen - (caddr_t)ip6);
d201 1
a201 7
	/*
	 * Presence of header sizes in mbufs
	 * would confuse code below.
	 */
#ifdef PULLDOWN_TEST
	/* XXX too strong mbuf requirement in m_pulldown() world */
#endif
a202 2
	m->m_data += offset;
	m->m_len -= offset;
d232 1
d236 1
a237 7
#if 0
		/*
		 * It is not necessarily the first segment; fragment offset
		 * might be non-0.
		 */
		q6->ip6q_nxt	= ip6f->ip6f_nxt;
#endif
d265 1
a265 1
	frgpartlen =  sizeof(struct ip6_hdr) + ntohs(ip6->ip6_plen) - offset;
a268 2
			m->m_data -= offset;
			m->m_len += offset;
d270 2
a271 1
				    offset - sizeof(struct ip6_frag) + 2);
a275 2
		m->m_data -= offset;
		m->m_len += offset;
d277 2
a278 1
			    offset - sizeof(struct ip6_frag) + 2);
a285 2
		struct ip6asfrag *af6dwn;
		
d298 1
a300 2
				merr->m_data -= af6->ip6af_offset;
				merr->m_len += af6->ip6af_offset;
d312 2
a313 1
					    erroff - sizeof(struct ip6_frag) + 2);
d318 9
a326 2
	/* Override the IPv6 header */
	ip6af = (struct ip6asfrag *)ip6;
a439 1

d443 1
d445 2
d450 3
a452 1
		af6 = af6->ip6af_down;
d457 2
a458 1
	ip6 = (struct ip6_hdr *)ip6af;
d470 1
a470 2

	if (offset < m->m_len)
d473 12
a484 3
	else {
		ovbcopy(mtod(m, caddr_t), (caddr_t)ip6 + offset, m->m_len);
		m->m_data -= sizeof(struct ip6_frag);
a485 2
	m->m_data -= offset;	
	m->m_len += offset; 
a550 2
			m->m_data -= af6->ip6af_offset;
			m->m_len += af6->ip6af_offset;
d559 1
a559 2
		}
		else
d561 1
@


1.3
log
@use arc4random() instead of random for two reasons.
1) on some architectures, random() should only be used by the scheduler
   (ie. statintr() because it is uniformly distributed
2) arc4random() is actually strong, random() is not at all
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.2 1999/12/10 10:04:27 angelos Exp $	*/
d54 2
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: frag6.c,v 1.1 1999/12/08 06:50:20 itojun Exp $	*/
a77 7
	struct timeval tv;

	/*
	 * in many cases, random() here does NOT return random number
	 * as initialization during bootstrap time occur in fixed order.
	 */
	microtime(&tv);
d79 1
a79 1
	ip6_id = random() ^ tv.tv_usec;
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a49 3
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3) && !defined(__OpenBSD__)
#include <netinet6/in6_pcb.h>
#endif
a71 5
/* FreeBSD tweak */
#if !defined(M_FTABLE) && (defined(__FreeBSD__) && __FreeBSD__ >= 3)
MALLOC_DEFINE(M_FTABLE, "fragment", "fragment reassembly header");
#endif

d137 1
a137 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d139 1
a139 3
#else
	rtcalloc((struct route *)&ro);
#endif
a592 3
#ifdef __NetBSD__
	int s = splsoftnet();
#else
a593 1
#endif
@

