head	1.212;
access;
symbols
	OPENBSD_6_1:1.203.0.4
	OPENBSD_6_1_BASE:1.203
	OPENBSD_6_0:1.188.0.2
	OPENBSD_6_0_BASE:1.188
	OPENBSD_5_9:1.184.0.2
	OPENBSD_5_9_BASE:1.184
	OPENBSD_5_8:1.163.0.4
	OPENBSD_5_8_BASE:1.163
	OPENBSD_5_7:1.157.0.2
	OPENBSD_5_7_BASE:1.157
	OPENBSD_5_6:1.147.0.4
	OPENBSD_5_6_BASE:1.147
	OPENBSD_5_5:1.140.0.4
	OPENBSD_5_5_BASE:1.140
	OPENBSD_5_4:1.130.0.2
	OPENBSD_5_4_BASE:1.130
	OPENBSD_5_3:1.118.0.4
	OPENBSD_5_3_BASE:1.118
	OPENBSD_5_2:1.118.0.2
	OPENBSD_5_2_BASE:1.118
	OPENBSD_5_1_BASE:1.117
	OPENBSD_5_1:1.117.0.2
	OPENBSD_5_0:1.116.0.2
	OPENBSD_5_0_BASE:1.116
	OPENBSD_4_9:1.113.0.4
	OPENBSD_4_9_BASE:1.113
	OPENBSD_4_8:1.113.0.2
	OPENBSD_4_8_BASE:1.113
	OPENBSD_4_7:1.110.0.2
	OPENBSD_4_7_BASE:1.110
	OPENBSD_4_6:1.105.0.4
	OPENBSD_4_6_BASE:1.105
	OPENBSD_4_5:1.104.0.2
	OPENBSD_4_5_BASE:1.104
	OPENBSD_4_4:1.99.0.2
	OPENBSD_4_4_BASE:1.99
	OPENBSD_4_3:1.95.0.2
	OPENBSD_4_3_BASE:1.95
	OPENBSD_4_2:1.94.0.2
	OPENBSD_4_2_BASE:1.94
	OPENBSD_4_1:1.92.0.2
	OPENBSD_4_1_BASE:1.92
	OPENBSD_4_0:1.87.0.2
	OPENBSD_4_0_BASE:1.87
	OPENBSD_3_9:1.85.0.2
	OPENBSD_3_9_BASE:1.85
	OPENBSD_3_8:1.84.0.4
	OPENBSD_3_8_BASE:1.84
	OPENBSD_3_7:1.84.0.2
	OPENBSD_3_7_BASE:1.84
	OPENBSD_3_6:1.83.0.2
	OPENBSD_3_6_BASE:1.83
	SMP_SYNC_A:1.82
	SMP_SYNC_B:1.82
	OPENBSD_3_5:1.82.0.2
	OPENBSD_3_5_BASE:1.82
	OPENBSD_3_4:1.74.0.2
	OPENBSD_3_4_BASE:1.74
	UBC_SYNC_A:1.67
	OPENBSD_3_3:1.65.0.2
	OPENBSD_3_3_BASE:1.65
	OPENBSD_3_2:1.64.0.2
	OPENBSD_3_2_BASE:1.64
	OPENBSD_3_1:1.54.0.2
	OPENBSD_3_1_BASE:1.54
	UBC_SYNC_B:1.65
	UBC:1.52.0.2
	UBC_BASE:1.52
	OPENBSD_3_0:1.47.0.2
	OPENBSD_3_0_BASE:1.47
	OPENBSD_2_9_BASE:1.39
	OPENBSD_2_9:1.39.0.2
	OPENBSD_2_8:1.24.0.2
	OPENBSD_2_8_BASE:1.24
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.212
date	2017.06.26.14.12.35;	author bluhm;	state Exp;
branches;
next	1.211;
commitid	abhJXWaNSr54JPlr;

1.211
date	2017.05.30.12.09.27;	author friehm;	state Exp;
branches;
next	1.210;
commitid	0nYUFDGviFDMy9X0;

1.210
date	2017.05.08.16.14.47;	author rzalamena;	state Exp;
branches;
next	1.209;
commitid	am0bPefWnjYUK27l;

1.209
date	2017.05.08.13.51.09;	author rzalamena;	state Exp;
branches;
next	1.208;
commitid	CXscqOGRbc4oswR8;

1.208
date	2017.05.04.17.58.46;	author bluhm;	state Exp;
branches;
next	1.207;
commitid	Q1XaPbKgEyYyAOP7;

1.207
date	2017.04.19.15.44.45;	author bluhm;	state Exp;
branches;
next	1.206;
commitid	vhVfmw1Ka999L46J;

1.206
date	2017.04.19.15.21.54;	author bluhm;	state Exp;
branches;
next	1.205;
commitid	86fZyVCZMRPZ29Fb;

1.205
date	2017.04.14.20.46.31;	author bluhm;	state Exp;
branches;
next	1.204;
commitid	00hB28wQPwG5Ysk0;

1.204
date	2017.04.05.13.35.18;	author deraadt;	state Exp;
branches;
next	1.203;
commitid	4O5LUh13nIhVt6oZ;

1.203
date	2017.03.03.13.19.40;	author bluhm;	state Exp;
branches;
next	1.202;
commitid	L35o398B8SPI29ub;

1.202
date	2017.03.02.09.06.59;	author mpi;	state Exp;
branches;
next	1.201;
commitid	j91Qri5uOnFYiHsQ;

1.201
date	2017.02.09.20.31.29;	author jca;	state Exp;
branches;
next	1.200;
commitid	Qlj9VqBELjOQOt8O;

1.200
date	2017.02.09.15.23.35;	author jca;	state Exp;
branches;
next	1.199;
commitid	1ap8YFU49Zg4mM41;

1.199
date	2017.02.05.16.04.14;	author jca;	state Exp;
branches;
next	1.198;
commitid	2R0NOjEDy2jGtnjL;

1.198
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.197;
commitid	UBL7uwpXqTP4EWIu;

1.197
date	2017.01.19.14.49.19;	author bluhm;	state Exp;
branches;
next	1.196;
commitid	15IMDG7eAMZX5Azd;

1.196
date	2017.01.18.17.59.01;	author bluhm;	state Exp;
branches;
next	1.195;
commitid	zHAhMBwxfaciUcTg;

1.195
date	2016.12.19.08.36.50;	author mpi;	state Exp;
branches;
next	1.194;
commitid	QqHqT2WhCBWqYgGJ;

1.194
date	2016.11.28.14.14.39;	author mpi;	state Exp;
branches;
next	1.193;
commitid	6k4TK07Jp4xe3PKg;

1.193
date	2016.11.16.12.48.19;	author bluhm;	state Exp;
branches;
next	1.192;
commitid	n2RvgM2Tgp3821dQ;

1.192
date	2016.11.16.12.21.46;	author bluhm;	state Exp;
branches;
next	1.191;
commitid	EvKrV7faDiEzI4Jd;

1.191
date	2016.11.09.09.04.48;	author mpi;	state Exp;
branches;
next	1.190;
commitid	zv2B8XroCnaWYTvP;

1.190
date	2016.08.24.09.38.29;	author mpi;	state Exp;
branches;
next	1.189;
commitid	WJHh1vrj4dKt1mk4;

1.189
date	2016.08.04.20.46.24;	author vgross;	state Exp;
branches;
next	1.188;
commitid	nbCHuHn2E9uBfKJT;

1.188
date	2016.07.22.11.14.41;	author mpi;	state Exp;
branches;
next	1.187;
commitid	Cm0qxR09oTCkXjXZ;

1.187
date	2016.07.20.18.51.50;	author vgross;	state Exp;
branches;
next	1.186;
commitid	jodmGXAB42f8N6nf;

1.186
date	2016.07.05.10.17.14;	author mpi;	state Exp;
branches;
next	1.185;
commitid	LxUFHuffW7GZZ01f;

1.185
date	2016.03.29.11.57.51;	author chl;	state Exp;
branches;
next	1.184;
commitid	AZTNcVhJxOTcjeS6;

1.184
date	2016.01.21.06.32.19;	author jsg;	state Exp;
branches;
next	1.183;
commitid	gTyxmhWmJScdzWE7;

1.183
date	2015.12.09.09.27.40;	author mpi;	state Exp;
branches;
next	1.182;
commitid	1YVTO7Z5j7IINidX;

1.182
date	2015.12.03.21.11.53;	author sashan;	state Exp;
branches;
next	1.181;
commitid	nhuzteWvIf6uiITt;

1.181
date	2015.12.02.16.35.53;	author bluhm;	state Exp;
branches;
next	1.180;
commitid	i3XNpYhaQ8QndxLo;

1.180
date	2015.12.02.13.29.26;	author claudio;	state Exp;
branches;
next	1.179;
commitid	Hf3C2AvfIXmCAmHE;

1.179
date	2015.12.01.21.26.43;	author mpi;	state Exp;
branches;
next	1.178;
commitid	XfTOZsoiIJCcV93d;

1.178
date	2015.11.21.11.23.07;	author mpi;	state Exp;
branches;
next	1.177;
commitid	sXDLQd07bF9g3e1c;

1.177
date	2015.11.03.21.39.34;	author chl;	state Exp;
branches;
next	1.176;
commitid	iKw3fv7fbm1Ty7ms;

1.176
date	2015.10.30.09.39.42;	author bluhm;	state Exp;
branches;
next	1.175;
commitid	7wrRch1SS813fOcY;

1.175
date	2015.10.28.12.14.25;	author florian;	state Exp;
branches;
next	1.174;
commitid	Ajb0hNGeCqGFHjjg;

1.174
date	2015.10.22.15.37.47;	author bluhm;	state Exp;
branches;
next	1.173;
commitid	tp9bS9eCrwvRYjyO;

1.173
date	2015.10.19.12.11.28;	author mpi;	state Exp;
branches;
next	1.172;
commitid	aMzCQ7pRC6VLKZyx;

1.172
date	2015.09.18.14.26.22;	author mpi;	state Exp;
branches;
next	1.171;
commitid	hGprk1rxxzKhgpj5;

1.171
date	2015.09.11.22.00.36;	author claudio;	state Exp;
branches;
next	1.170;
commitid	mlF9piyzkEcexMxc;

1.170
date	2015.09.11.19.42.45;	author dlg;	state Exp;
branches;
next	1.169;
commitid	e4G6tAr739Th0Bqm;

1.169
date	2015.09.11.15.12.29;	author bluhm;	state Exp;
branches;
next	1.168;
commitid	WiOHVoKXV2bal1nI;

1.168
date	2015.09.11.09.14.06;	author claudio;	state Exp;
branches;
next	1.167;
commitid	cvCN0oX1O1LGXfhv;

1.167
date	2015.09.11.08.17.06;	author claudio;	state Exp;
branches;
next	1.166;
commitid	Cr0DVA7exR1t2zXg;

1.166
date	2015.09.11.07.42.35;	author claudio;	state Exp;
branches;
next	1.165;
commitid	sTEWfQrcV5GjIWc0;

1.165
date	2015.09.10.17.52.05;	author claudio;	state Exp;
branches;
next	1.164;
commitid	PcRGyy4jlpJbKkXz;

1.164
date	2015.09.09.15.51.40;	author mpi;	state Exp;
branches;
next	1.163;
commitid	MtXIH0WHmPXVgeDN;

1.163
date	2015.07.28.12.22.07;	author bluhm;	state Exp;
branches;
next	1.162;
commitid	HopFqP0BfcI2KM6j;

1.162
date	2015.07.15.22.16.42;	author deraadt;	state Exp;
branches;
next	1.161;
commitid	ncpqEGjDtSFuLAgn;

1.161
date	2015.07.08.08.48.34;	author mpi;	state Exp;
branches;
next	1.160;
commitid	PeSgmtaVq0R4a133;

1.160
date	2015.06.30.15.30.17;	author mpi;	state Exp;
branches;
next	1.159;
commitid	J4OPNuggl4DOKGzM;

1.159
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.158;
commitid	h7z8lokZ0dFyuWpg;

1.158
date	2015.06.08.22.19.27;	author krw;	state Exp;
branches;
next	1.157;
commitid	4Ro7ulidQXNcMvmM;

1.157
date	2015.03.04.11.10.55;	author mpi;	state Exp;
branches;
next	1.156;
commitid	qKIbFOrY1lWEYrPI;

1.156
date	2015.02.05.03.01.03;	author mpi;	state Exp;
branches;
next	1.155;
commitid	DhkSbioeq059UWqq;

1.155
date	2015.01.28.22.10.13;	author mpi;	state Exp;
branches;
next	1.154;
commitid	qWMiETGHDs7AwODS;

1.154
date	2015.01.26.11.38.37;	author mpi;	state Exp;
branches;
next	1.153;
commitid	4QI0UcDYcdBMTh1W;

1.153
date	2015.01.19.13.53.55;	author mpi;	state Exp;
branches;
next	1.152;
commitid	QLR9BrkHZXJalVFJ;

1.152
date	2014.12.22.11.05.53;	author mpi;	state Exp;
branches;
next	1.151;
commitid	ZiNnf658AJiR4Tll;

1.151
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.150;
commitid	t9FBKDfc4VDxpEy2;

1.150
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.149;
commitid	w0MRp28dmfD1ZzO8;

1.149
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.148;
commitid	6AYfDT0Lpez1LFQp;

1.148
date	2014.08.27.14.04.16;	author florian;	state Exp;
branches;
next	1.147;
commitid	JNq3mHDvq54quWei;

1.147
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.146;
commitid	DQakU8LLWV6Iwx84;

1.146
date	2014.07.11.12.20.26;	author benno;	state Exp;
branches;
next	1.145;
commitid	P8JppJvHVB5bPsqa;

1.145
date	2014.07.08.17.19.26;	author deraadt;	state Exp;
branches;
next	1.144;
commitid	EF98ch02VpFassUi;

1.144
date	2014.05.07.08.09.33;	author mpi;	state Exp;
branches;
next	1.143;

1.143
date	2014.04.18.10.48.30;	author jca;	state Exp;
branches;
next	1.142;

1.142
date	2014.04.14.09.06.42;	author mpi;	state Exp;
branches;
next	1.141;

1.141
date	2014.03.21.10.44.42;	author mpi;	state Exp;
branches;
next	1.140;

1.140
date	2014.01.24.12.20.22;	author naddy;	state Exp;
branches;
next	1.139;

1.139
date	2014.01.13.23.03.52;	author bluhm;	state Exp;
branches;
next	1.138;

1.138
date	2014.01.07.17.07.46;	author mikeb;	state Exp;
branches;
next	1.137;

1.137
date	2013.12.20.02.04.08;	author krw;	state Exp;
branches;
next	1.136;

1.136
date	2013.11.11.09.15.35;	author mpi;	state Exp;
branches;
next	1.135;

1.135
date	2013.10.24.11.20.18;	author deraadt;	state Exp;
branches;
next	1.134;

1.134
date	2013.10.23.19.57.50;	author deraadt;	state Exp;
branches;
next	1.133;

1.133
date	2013.10.21.12.27.14;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2013.10.21.08.42.25;	author phessler;	state Exp;
branches;
next	1.131;

1.131
date	2013.10.17.16.27.45;	author bluhm;	state Exp;
branches;
next	1.130;

1.130
date	2013.06.05.15.22.32;	author bluhm;	state Exp;
branches;
next	1.129;

1.129
date	2013.06.04.19.11.51;	author bluhm;	state Exp;
branches;
next	1.128;

1.128
date	2013.06.01.16.22.05;	author bluhm;	state Exp;
branches;
next	1.127;

1.127
date	2013.05.31.15.04.23;	author bluhm;	state Exp;
branches;
next	1.126;

1.126
date	2013.04.24.10.17.08;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.124;

1.124
date	2013.04.04.17.58.42;	author bluhm;	state Exp;
branches;
next	1.123;

1.123
date	2013.03.28.16.45.16;	author tedu;	state Exp;
branches;
next	1.122;

1.122
date	2013.03.25.14.40.56;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2013.03.22.01.41.12;	author tedu;	state Exp;
branches;
next	1.120;

1.120
date	2013.03.14.11.18.37;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2013.03.04.14.42.25;	author bluhm;	state Exp;
branches;
next	1.118;

1.118
date	2012.04.03.14.58.45;	author mikeb;	state Exp;
branches;
next	1.117;

1.117
date	2011.11.24.17.39.55;	author sperreault;	state Exp;
branches;
next	1.116;

1.116
date	2011.04.06.19.23.15;	author sthen;	state Exp;
branches;
next	1.115;

1.115
date	2011.04.05.11.48.28;	author blambert;	state Exp;
branches;
next	1.114;

1.114
date	2011.04.03.13.54.21;	author stsp;	state Exp;
branches;
next	1.113;

1.113
date	2010.07.09.15.44.20;	author claudio;	state Exp;
branches;
next	1.112;

1.112
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.111;

1.111
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.110;

1.110
date	2010.01.14.04.27.32;	author jsing;	state Exp;
branches;
next	1.109;

1.109
date	2010.01.05.22.28.09;	author jasper;	state Exp;
branches;
next	1.108;

1.108
date	2009.11.20.09.02.21;	author guenther;	state Exp;
branches;
next	1.107;

1.107
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2009.07.26.12.59.17;	author thib;	state Exp;
branches;
next	1.105;

1.105
date	2009.06.05.00.05.22;	author claudio;	state Exp;
branches;
next	1.104;

1.104
date	2009.02.22.17.43.20;	author claudio;	state Exp;
branches;
next	1.103;

1.103
date	2009.02.18.20.54.48;	author claudio;	state Exp;
branches;
next	1.102;

1.102
date	2008.10.02.14.11.06;	author jsing;	state Exp;
branches;
next	1.101;

1.101
date	2008.09.17.05.43.14;	author chl;	state Exp;
branches;
next	1.100;

1.100
date	2008.09.12.12.53.55;	author henning;	state Exp;
branches;
next	1.99;

1.99
date	2008.06.11.19.00.50;	author mcbride;	state Exp;
branches;
next	1.98;

1.98
date	2008.06.11.06.30.36;	author mcbride;	state Exp;
branches;
next	1.97;

1.97
date	2008.05.11.08.13.02;	author claudio;	state Exp;
branches;
next	1.96;

1.96
date	2008.03.08.01.52.35;	author sthen;	state Exp;
branches;
next	1.95;

1.95
date	2008.02.05.22.57.31;	author mpf;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.01.00.52.38;	author henning;	state Exp;
branches;
next	1.93;

1.93
date	2007.03.18.23.23.17;	author mpf;	state Exp;
branches;
next	1.92;

1.92
date	2007.01.16.11.05.25;	author itojun;	state Exp;
branches;
next	1.91;

1.91
date	2007.01.15.21.32.29;	author itojun;	state Exp;
branches;
next	1.90;

1.90
date	2006.12.09.01.12.28;	author itojun;	state Exp;
branches;
next	1.89;

1.89
date	2006.11.17.01.11.23;	author itojun;	state Exp;
branches;
next	1.88;

1.88
date	2006.11.15.03.07.44;	author itojun;	state Exp;
branches;
next	1.87;

1.87
date	2006.06.16.16.49.40;	author henning;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2006.03.05.21.48.57;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2005.10.22.06.38.54;	author brad;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2005.01.17.10.18.03;	author itojun;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.21.23.50.37;	author tholo;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.25.14.01.20;	author dhartmei;	state Exp;
branches;
next	1.81;

1.81
date	2004.02.15.11.16.08;	author markus;	state Exp;
branches;
next	1.80;

1.80
date	2004.02.04.13.14.42;	author dhartmei;	state Exp;
branches;
next	1.79;

1.79
date	2004.02.04.11.23.15;	author dhartmei;	state Exp;
branches;
next	1.78;

1.78
date	2004.02.01.19.57.12;	author dhartmei;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.15.17.51.42;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.21.14.57.19;	author markus;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.01.21.41.05;	author itojun;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.07.09.11.24;	author itojun;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.24.07.55.12;	author itojun;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.24.07.47.54;	author itojun;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.11.02.54.02;	author itojun;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.03.06.25.26;	author itojun;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.02.23.28.15;	author millert;	state Exp;
branches;
next	1.68;

1.68
date	2003.05.22.10.20.57;	author itojun;	state Exp;
branches;
next	1.67;

1.67
date	2003.05.14.14.24.44;	author itojun;	state Exp;
branches;
next	1.66;

1.66
date	2003.04.01.01.09.37;	author itojun;	state Exp;
branches;
next	1.65;

1.65
date	2002.10.12.01.09.45;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2002.09.11.03.15.36;	author itojun;	state Exp;
branches;
next	1.63;

1.63
date	2002.07.30.23.30.08;	author itojun;	state Exp;
branches;
next	1.62;

1.62
date	2002.07.10.05.08.03;	author itojun;	state Exp;
branches;
next	1.61;

1.61
date	2002.06.09.14.38.39;	author itojun;	state Exp;
branches;
next	1.60;

1.60
date	2002.06.08.21.22.02;	author itojun;	state Exp;
branches;
next	1.59;

1.59
date	2002.05.31.04.27.00;	author itojun;	state Exp;
branches;
next	1.58;

1.58
date	2002.05.29.23.38.58;	author itojun;	state Exp;
branches;
next	1.57;

1.57
date	2002.05.29.07.54.59;	author itojun;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.29.07.21.08;	author itojun;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.24.09.15.29;	author itojun;	state Exp;
branches;
next	1.54;

1.54
date	2002.03.14.01.27.11;	author millert;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.05.08.29.45;	author itojun;	state Exp;
branches;
next	1.52;

1.52
date	2001.12.07.09.56.32;	author itojun;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2001.12.07.09.33.10;	author itojun;	state Exp;
branches;
next	1.50;

1.50
date	2001.12.07.09.16.07;	author itojun;	state Exp;
branches;
next	1.49;

1.49
date	2001.12.06.04.19.25;	author itojun;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.06.19.53.20;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2001.06.27.03.49.54;	author angelos;	state Exp;
branches;
next	1.46;

1.46
date	2001.06.26.19.58.57;	author itojun;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.25.02.59.01;	author angelos;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.22.12.59.08;	author itojun;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.09.06.43.37;	author angelos;	state Exp;
branches;
next	1.42;

1.42
date	2001.06.01.06.08.22;	author itojun;	state Exp;
branches;
next	1.41;

1.41
date	2001.05.26.06.57.19;	author angelos;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.20.08.36.01;	author angelos;	state Exp;
branches;
next	1.39;

1.39
date	2001.04.04.06.03.45;	author itojun;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.03.30.11.08.58;	author itojun;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.28.20.03.07;	author angelos;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.21.15.01.08;	author itojun;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.20.03.17.44;	author itojun;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.08.00.18.36;	author itojun;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.16.16.00.55;	author itojun;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.08.18.46.22;	author itojun;	state Exp;
branches;
next	1.31;

1.31
date	2001.02.08.16.07.59;	author itojun;	state Exp;
branches;
next	1.30;

1.30
date	2001.02.07.11.43.52;	author itojun;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.16.06.16.34;	author itojun;	state Exp;
branches;
next	1.28;

1.28
date	2001.01.08.06.22.05;	author itojun;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.11.19.29.50;	author itojun;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.11.08.04.56;	author itojun;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.11.00.45.39;	author itojun;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.10.15.53.08;	author itojun;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.10.14.24.34;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2000.09.16.08.58.18;	author itojun;	state Exp;
branches;
next	1.21;

1.21
date	2000.08.19.09.17.36;	author itojun;	state Exp;
branches;
next	1.20;

1.20
date	2000.08.03.14.39.23;	author itojun;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.06.10.11.24;	author itojun;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.13.17.32.47;	author itojun;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.13.16.36.11;	author itojun;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.12.17.24.26;	author itojun;	state Exp;
branches;
next	1.15;

1.15
date	2000.05.22.11.17.51;	author itojun;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.22.10.32.51;	author itojun;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.15.11.45.35;	author itojun;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.15.11.34.46;	author itojun;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.13.14.08.50;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.22.03.50.35;	author itojun;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.28.14.30.40;	author itojun;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.28.14.05.59;	author itojun;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.28.11.55.21;	author itojun;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.07.06.09.09;	author itojun;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.01.08.13.54.36;	author itojun;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.02.04.52.26;	author itojun;	state Exp;
branches;
next	1.3;

1.3
date	99.12.15.07.08.00;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.27;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.08.06.50.20;	author itojun;	state Exp;
branches;
next	;

1.6.2.1
date	2000.03.02.07.04.44;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.03.24.09.09.39;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.05.14.22.40.16;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2001.07.04.10.55.16;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2001.11.13.22.59.58;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2002.03.06.02.15.08;	author niklas;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2003.03.28.00.41.29;	author niklas;	state Exp;
branches;
next	1.6.2.9;

1.6.2.9
date	2003.05.13.19.36.18;	author ho;	state Exp;
branches;
next	1.6.2.10;

1.6.2.10
date	2003.05.16.00.29.44;	author niklas;	state Exp;
branches;
next	1.6.2.11;

1.6.2.11
date	2003.06.07.11.06.08;	author ho;	state Exp;
branches;
next	1.6.2.12;

1.6.2.12
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	1.6.2.13;

1.6.2.13
date	2004.06.05.23.11.26;	author niklas;	state Exp;
branches;
next	;

1.39.2.1
date	2001.06.03.18.50.21;	author jason;	state Exp;
branches;
next	;

1.52.2.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2002.10.29.00.36.48;	author art;	state Exp;
branches;
next	1.52.2.3;

1.52.2.3
date	2003.05.19.22.27.25;	author tedu;	state Exp;
branches;
next	;

1.85.2.1
date	2007.01.16.06.17.51;	author miod;	state Exp;
branches;
next	1.85.2.2;

1.85.2.2
date	2007.01.16.19.32.38;	author miod;	state Exp;
branches;
next	;

1.87.2.1
date	2007.01.16.06.17.26;	author miod;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2007.01.16.19.31.41;	author miod;	state Exp;
branches;
next	;


desc
@@


1.212
log
@When pinging an IPv6 link-local address, the reflected packet had
::1 as source address.  It should be the link-local address of the
attached interface.  The rtalloc() in icmp6_reflect() did not find
the correct local address.  The IPv6 routing table does not use
sin6_scope_id, but the embedded scope.  So do not recover the scope.
bug report Harald Dunkel; OK mpi@@
@
text
@/*	$OpenBSD: icmp6.c,v 1.211 2017/05/30 12:09:27 friehm Exp $	*/
/*	$KAME: icmp6.c,v 1.217 2001/06/20 15:03:29 jinmei Exp $	*/

/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 1982, 1986, 1988, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ip_icmp.c	8.2 (Berkeley) 1/4/94
 */

#include "carp.h"
#include "pf.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/sysctl.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/domain.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/route.h>
#include <net/if_dl.h>
#include <net/if_types.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet6/in6_var.h>
#include <netinet/ip6.h>
#include <netinet6/ip6_var.h>
#include <netinet/icmp6.h>
#include <netinet6/mld6_var.h>
#include <netinet/in_pcb.h>
#include <netinet6/nd6.h>
#include <netinet6/ip6protosw.h>

#if NCARP > 0
#include <netinet/ip_carp.h>
#endif

#if NPF > 0
#include <net/pfvar.h>
#endif

struct cpumem *icmp6counters;

extern struct inpcbtable rawin6pcbtable;
extern int icmp6errppslim;
static int icmp6errpps_count = 0;
static struct timeval icmp6errppslim_last;

/*
 * List of callbacks to notify when Path MTU changes are made.
 */
struct icmp6_mtudisc_callback {
	LIST_ENTRY(icmp6_mtudisc_callback) mc_list;
	void (*mc_func)(struct sockaddr_in6 *, u_int);
};

LIST_HEAD(, icmp6_mtudisc_callback) icmp6_mtudisc_callbacks =
    LIST_HEAD_INITIALIZER(icmp6_mtudisc_callbacks);

struct rttimer_queue *icmp6_mtudisc_timeout_q = NULL;

/* XXX do these values make any sense? */
static int icmp6_mtudisc_hiwat = 1280;
static int icmp6_mtudisc_lowat = 256;

/*
 * keep track of # of redirect routes.
 */
static struct rttimer_queue *icmp6_redirect_timeout_q = NULL;

/* XXX experimental, turned off */
static int icmp6_redirect_lowat = -1;

void	icmp6_errcount(int, int);
int	icmp6_ratelimit(const struct in6_addr *, const int, const int);
const char *icmp6_redirect_diag(struct in6_addr *, struct in6_addr *,
	    struct in6_addr *);
int	icmp6_notify_error(struct mbuf *, int, int, int);
struct rtentry *icmp6_mtudisc_clone(struct sockaddr *, u_int);
void	icmp6_mtudisc_timeout(struct rtentry *, struct rttimer *);
void	icmp6_redirect_timeout(struct rtentry *, struct rttimer *);

void
icmp6_init(void)
{
	mld6_init();
	icmp6_mtudisc_timeout_q = rt_timer_queue_create(ip6_mtudisc_timeout);
	icmp6_redirect_timeout_q = rt_timer_queue_create(icmp6_redirtimeout);
	icmp6counters = counters_alloc(icp6s_ncounters);
}

void
icmp6_errcount(int type, int code)
{
	enum icmp6stat_counters c = icp6s_ounknown;

	switch (type) {
	case ICMP6_DST_UNREACH:
		switch (code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			c = icp6s_odst_unreach_noroute;
			break;
		case ICMP6_DST_UNREACH_ADMIN:
			c = icp6s_odst_unreach_admin;
			break;
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			c = icp6s_odst_unreach_beyondscope;
			break;
		case ICMP6_DST_UNREACH_ADDR:
			c = icp6s_odst_unreach_addr;
			break;
		case ICMP6_DST_UNREACH_NOPORT:
			c = icp6s_odst_unreach_noport;
			break;
		}
		break;
	case ICMP6_PACKET_TOO_BIG:
		c = icp6s_opacket_too_big;
		break;
	case ICMP6_TIME_EXCEEDED:
		switch (code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			c = icp6s_otime_exceed_transit;
			break;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			c = icp6s_otime_exceed_reassembly;
			break;
		}
		break;
	case ICMP6_PARAM_PROB:
		switch (code) {
		case ICMP6_PARAMPROB_HEADER:
			c = icp6s_oparamprob_header;
			break;
		case ICMP6_PARAMPROB_NEXTHEADER:
			c = icp6s_oparamprob_nextheader;
			break;
		case ICMP6_PARAMPROB_OPTION:
			c = icp6s_oparamprob_option;
			break;
		}
		break;
	case ND_REDIRECT:
		c = icp6s_oredirect;
		break;
	}

	icmp6stat_inc(c);
}

/*
 * Register a Path MTU Discovery callback.
 */
void
icmp6_mtudisc_callback_register(void (*func)(struct sockaddr_in6 *, u_int))
{
	struct icmp6_mtudisc_callback *mc;

	LIST_FOREACH(mc, &icmp6_mtudisc_callbacks, mc_list) {
		if (mc->mc_func == func)
			return;
	}

	mc = malloc(sizeof(*mc), M_PCB, M_NOWAIT);
	if (mc == NULL)
		panic("icmp6_mtudisc_callback_register");

	mc->mc_func = func;
	LIST_INSERT_HEAD(&icmp6_mtudisc_callbacks, mc, mc_list);
}

/*
 * Generate an error packet of type error in response to bad IP6 packet.
 */
void
icmp6_error(struct mbuf *m, int type, int code, int param)
{
	struct ip6_hdr *oip6, *nip6;
	struct icmp6_hdr *icmp6;
	u_int preplen;
	int off;
	int nxt;

	icmp6stat_inc(icp6s_error);

	/* count per-type-code statistics */
	icmp6_errcount(type, code);

	if (m->m_len < sizeof(struct ip6_hdr)) {
		m = m_pullup(m, sizeof(struct ip6_hdr));
		if (m == NULL)
			return;
	}
	oip6 = mtod(m, struct ip6_hdr *);

	/*
	 * If the destination address of the erroneous packet is a multicast
	 * address, or the packet was sent using link-layer multicast,
	 * we should basically suppress sending an error (RFC 2463, Section
	 * 2.4).
	 * We have two exceptions (the item e.2 in that section):
	 * - the Packet Too Big message can be sent for path MTU discovery.
	 * - the Parameter Problem Message that can be allowed an icmp6 error
	 *   in the option type field.  This check has been done in
	 *   ip6_unknown_opt(), so we can just check the type and code.
	 */
	if ((m->m_flags & (M_BCAST|M_MCAST) ||
	     IN6_IS_ADDR_MULTICAST(&oip6->ip6_dst)) &&
	    (type != ICMP6_PACKET_TOO_BIG &&
	     (type != ICMP6_PARAM_PROB ||
	      code != ICMP6_PARAMPROB_OPTION)))
		goto freeit;

	/*
	 * RFC 2463, 2.4 (e.5): source address check.
	 * XXX: the case of anycast source?
	 */
	if (IN6_IS_ADDR_UNSPECIFIED(&oip6->ip6_src) ||
	    IN6_IS_ADDR_MULTICAST(&oip6->ip6_src))
		goto freeit;

	/*
	 * If we are about to send ICMPv6 against ICMPv6 error/redirect,
	 * don't do it.
	 */
	nxt = -1;
	off = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxt);
	if (off >= 0 && nxt == IPPROTO_ICMPV6) {
		struct icmp6_hdr *icp;

		IP6_EXTHDR_GET(icp, struct icmp6_hdr *, m, off,
			sizeof(*icp));
		if (icp == NULL) {
			icmp6stat_inc(icp6s_tooshort);
			return;
		}
		if (icp->icmp6_type < ICMP6_ECHO_REQUEST ||
		    icp->icmp6_type == ND_REDIRECT) {
			/*
			 * ICMPv6 error
			 * Special case: for redirect (which is
			 * informational) we must not send icmp6 error.
			 */
			icmp6stat_inc(icp6s_canterror);
			goto freeit;
		} else {
			/* ICMPv6 informational - send the error */
		}
	}
	else {
		/* non-ICMPv6 - send the error */
	}

	oip6 = mtod(m, struct ip6_hdr *); /* adjust pointer */

	/* Finally, do rate limitation check. */
	if (icmp6_ratelimit(&oip6->ip6_src, type, code)) {
		icmp6stat_inc(icp6s_toofreq);
		goto freeit;
	}

	/*
	 * OK, ICMP6 can be generated.
	 */

	if (m->m_pkthdr.len >= ICMPV6_PLD_MAXLEN)
		m_adj(m, ICMPV6_PLD_MAXLEN - m->m_pkthdr.len);

	preplen = sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr);
	M_PREPEND(m, preplen, M_DONTWAIT);
	if (m && m->m_len < preplen)
		m = m_pullup(m, preplen);
	if (m == NULL) {
		nd6log((LOG_DEBUG, "ENOBUFS in icmp6_error %d\n", __LINE__));
		return;
	}

	nip6 = mtod(m, struct ip6_hdr *);
	nip6->ip6_src  = oip6->ip6_src;
	nip6->ip6_dst  = oip6->ip6_dst;

	if (IN6_IS_SCOPE_EMBED(&oip6->ip6_src))
		oip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_SCOPE_EMBED(&oip6->ip6_dst))
		oip6->ip6_dst.s6_addr16[1] = 0;

	icmp6 = (struct icmp6_hdr *)(nip6 + 1);
	icmp6->icmp6_type = type;
	icmp6->icmp6_code = code;
	icmp6->icmp6_pptr = htonl((u_int32_t)param);

	/*
	 * icmp6_reflect() is designed to be in the input path.
	 * icmp6_error() can be called from both input and outut path,
	 * and if we are in output path rcvif could contain bogus value.
	 * clear m->m_pkthdr.ph_ifidx for safety, we should have enough
	 * scope information in ip header (nip6).
	 */
	m->m_pkthdr.ph_ifidx = 0;

	icmp6stat_inc(icp6s_outhist + type);
	icmp6_reflect(m, sizeof(struct ip6_hdr)); /* header order: IPv6 - ICMPv6 */

	return;

  freeit:
	/*
	 * If we can't tell wheter or not we can generate ICMP6, free it.
	 */
	m_freem(m);
}

/*
 * Process a received ICMP6 message.
 */
int
icmp6_input(struct mbuf **mp, int *offp, int proto, int af)
{
#if NCARP > 0
	struct ifnet *ifp;
#endif
	struct mbuf *m = *mp, *n;
	struct ip6_hdr *ip6, *nip6;
	struct icmp6_hdr *icmp6, *nicmp6;
	int off = *offp;
	int icmp6len = m->m_pkthdr.len - *offp;
	int code, sum, noff;
	char src[INET6_ADDRSTRLEN], dst[INET6_ADDRSTRLEN];

	/*
	 * Locate icmp6 structure in mbuf, and check
	 * that not corrupted and of at least minimum length
	 */

	ip6 = mtod(m, struct ip6_hdr *);
	if (icmp6len < sizeof(struct icmp6_hdr)) {
		icmp6stat_inc(icp6s_tooshort);
		goto freeit;
	}

	/*
	 * calculate the checksum
	 */
	IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off, sizeof(*icmp6));
	if (icmp6 == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		return IPPROTO_DONE;
	}
	code = icmp6->icmp6_code;

	if ((sum = in6_cksum(m, IPPROTO_ICMPV6, off, icmp6len)) != 0) {
		nd6log((LOG_ERR,
		    "ICMP6 checksum error(%d|%x) %s\n",
		    icmp6->icmp6_type, sum,
		    inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src))));
		icmp6stat_inc(icp6s_checksum);
		goto freeit;
	}

#if NPF > 0
	if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
		switch (icmp6->icmp6_type) {
		/*
		 * These ICMP6 types map to other connections.  They must be
		 * delivered to pr_ctlinput() also for diverted connections.
		 */
		case ICMP6_DST_UNREACH:
		case ICMP6_PACKET_TOO_BIG:
		case ICMP6_TIME_EXCEEDED:
		case ICMP6_PARAM_PROB:
			break;
		default:
			goto raw;
		}
	}
#endif /* NPF */

#if NCARP > 0
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

	if (ifp->if_type == IFT_CARP &&
	    icmp6->icmp6_type == ICMP6_ECHO_REQUEST &&
	    carp_lsdrop(m, AF_INET6, ip6->ip6_src.s6_addr32,
	    ip6->ip6_dst.s6_addr32, 1)) {
		if_put(ifp);
		goto freeit;
	}

	if_put(ifp);
#endif
	icmp6stat_inc(icp6s_inhist + icmp6->icmp6_type);

	switch (icmp6->icmp6_type) {
	case ICMP6_DST_UNREACH:
		switch (code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			code = PRC_UNREACH_NET;
			break;
		case ICMP6_DST_UNREACH_ADMIN:
			code = PRC_UNREACH_PROTOCOL; /* is this a good code? */
			break;
		case ICMP6_DST_UNREACH_ADDR:
			code = PRC_HOSTDEAD;
			break;
#ifdef COMPAT_RFC1885
		case ICMP6_DST_UNREACH_NOTNEIGHBOR:
			code = PRC_UNREACH_SRCFAIL;
			break;
#else
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			/* I mean "source address was incorrect." */
			code = PRC_PARAMPROB;
			break;
#endif
		case ICMP6_DST_UNREACH_NOPORT:
			code = PRC_UNREACH_PORT;
			break;
		default:
			goto badcode;
		}
		goto deliver;

	case ICMP6_PACKET_TOO_BIG:
		/* MTU is checked in icmp6_mtudisc_update. */
		code = PRC_MSGSIZE;

		/*
		 * Updating the path MTU will be done after examining
		 * intermediate extension headers.
		 */
		goto deliver;

	case ICMP6_TIME_EXCEEDED:
		switch (code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			code = PRC_TIMXCEED_INTRANS;
			break;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			code = PRC_TIMXCEED_REASS;
			break;
		default:
			goto badcode;
		}
		goto deliver;

	case ICMP6_PARAM_PROB:
		switch (code) {
		case ICMP6_PARAMPROB_NEXTHEADER:
			code = PRC_UNREACH_PROTOCOL;
			break;
		case ICMP6_PARAMPROB_HEADER:
		case ICMP6_PARAMPROB_OPTION:
			code = PRC_PARAMPROB;
			break;
		default:
			goto badcode;
		}
		goto deliver;

	case ICMP6_ECHO_REQUEST:
		if (code != 0)
			goto badcode;
		/*
		 * Copy mbuf to send to two data paths: userland socket(s),
		 * and to the querier (echo reply).
		 * m: a copy for socket, n: a copy for querier
		 */
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* Give up local */
			n = m;
			m = *mp = NULL;
			goto deliverecho;
		}
		/*
		 * If the first mbuf is shared, or the first mbuf is too short,
		 * copy the first part of the data into a fresh mbuf.
		 * Otherwise, we will wrongly overwrite both copies.
		 */
		if ((n->m_flags & M_EXT) != 0 ||
		    n->m_len < off + sizeof(struct icmp6_hdr)) {
			struct mbuf *n0 = n;
			const int maxlen = sizeof(*nip6) + sizeof(*nicmp6);

			/*
			 * Prepare an internal mbuf.  m_pullup() doesn't
			 * always copy the length we specified.
			 */
			if (maxlen >= MCLBYTES) {
				/* Give up remote */
				m_freem(n0);
				break;
			}
			MGETHDR(n, M_DONTWAIT, n0->m_type);
			if (n && maxlen >= MHLEN) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
			if (n == NULL) {
				/* Give up local */
				m_freem(n0);
				n = m;
				m = *mp = NULL;
				goto deliverecho;
			}
			M_MOVE_PKTHDR(n, n0);
			/*
			 * Copy IPv6 and ICMPv6 only.
			 */
			nip6 = mtod(n, struct ip6_hdr *);
			bcopy(ip6, nip6, sizeof(struct ip6_hdr));
			nicmp6 = (struct icmp6_hdr *)(nip6 + 1);
			bcopy(icmp6, nicmp6, sizeof(struct icmp6_hdr));
			noff = sizeof(struct ip6_hdr);
			n->m_len = noff + sizeof(struct icmp6_hdr);
			/*
			 * Adjust mbuf.  ip6_plen will be adjusted in
			 * ip6_output().
			 * n->m_pkthdr.len == n0->m_pkthdr.len at this point.
			 */
			n->m_pkthdr.len += noff + sizeof(struct icmp6_hdr);
			n->m_pkthdr.len -= (off + sizeof(struct icmp6_hdr));
			m_adj(n0, off + sizeof(struct icmp6_hdr));
			n->m_next = n0;
		} else {
	 deliverecho:
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off,
			    sizeof(*nicmp6));
			noff = off;
		}
		if (n) {
			nicmp6->icmp6_type = ICMP6_ECHO_REPLY;
			nicmp6->icmp6_code = 0;
			icmp6stat_inc(icp6s_reflect);
			icmp6stat_inc(icp6s_outhist + ICMP6_ECHO_REPLY);
			icmp6_reflect(n, noff);
		}
		if (!m)
			goto freeit;
		break;

	case ICMP6_ECHO_REPLY:
		if (code != 0)
			goto badcode;
		break;

	case MLD_LISTENER_QUERY:
	case MLD_LISTENER_REPORT:
		if (icmp6len < sizeof(struct mld_hdr))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			mld6_input(m, off);
			m = NULL;
			goto freeit;
		}
		mld6_input(n, off);
		/* m stays. */
		break;

	case MLD_LISTENER_DONE:
		if (icmp6len < sizeof(struct mld_hdr))	/* necessary? */
			goto badlen;
		break;		/* nothing to be done in kernel */

	case MLD_MTRACE_RESP:
	case MLD_MTRACE:
		/* XXX: these two are experimental.  not officially defined. */
		/* XXX: per-interface statistics? */
		break;		/* just pass it to applications */

	case ICMP6_WRUREQUEST:	/* ICMP6_FQDN_QUERY */
		/* IPv6 Node Information Queries are not supported */
		break;
	case ICMP6_WRUREPLY:
		break;

	case ND_ROUTER_SOLICIT:
		if (code != 0)
			goto badcode;
		if (icmp6len < sizeof(struct nd_router_solicit))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_rs_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_rs_input(n, off, icmp6len);
		/* m stays. */
		break;

	case ND_ROUTER_ADVERT:
		if (code != 0)
			goto badcode;
		if (icmp6len < sizeof(struct nd_router_advert))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_ra_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_ra_input(n, off, icmp6len);
		/* m stays. */
		break;

	case ND_NEIGHBOR_SOLICIT:
		if (code != 0)
			goto badcode;
		if (icmp6len < sizeof(struct nd_neighbor_solicit))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_ns_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_ns_input(n, off, icmp6len);
		/* m stays. */
		break;

	case ND_NEIGHBOR_ADVERT:
		if (code != 0)
			goto badcode;
		if (icmp6len < sizeof(struct nd_neighbor_advert))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_na_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_na_input(n, off, icmp6len);
		/* m stays. */
		break;

	case ND_REDIRECT:
		if (code != 0)
			goto badcode;
		if (icmp6len < sizeof(struct nd_redirect))
			goto badlen;
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			icmp6_redirect_input(m, off);
			m = NULL;
			goto freeit;
		}
		icmp6_redirect_input(n, off);
		/* m stays. */
		break;

	case ICMP6_ROUTER_RENUMBERING:
		if (code != ICMP6_ROUTER_RENUMBERING_COMMAND &&
		    code != ICMP6_ROUTER_RENUMBERING_RESULT)
			goto badcode;
		if (icmp6len < sizeof(struct icmp6_router_renum))
			goto badlen;
		break;

	default:
		nd6log((LOG_DEBUG,
		    "icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%u)\n",
		    icmp6->icmp6_type,
		    inet_ntop(AF_INET6, &ip6->ip6_src, src, sizeof(src)),
		    inet_ntop(AF_INET6, &ip6->ip6_dst, dst, sizeof(dst)),
		    m->m_pkthdr.ph_ifidx));
		if (icmp6->icmp6_type < ICMP6_ECHO_REQUEST) {
			/* ICMPv6 error: MUST deliver it by spec... */
			code = PRC_NCMDS;
			/* deliver */
		} else {
			/* ICMPv6 informational: MUST not deliver */
			break;
		}
deliver:
		if (icmp6_notify_error(m, off, icmp6len, code)) {
			/* In this case, m should've been freed. */
			return (IPPROTO_DONE);
		}
		break;

badcode:
		icmp6stat_inc(icp6s_badcode);
		break;

badlen:
		icmp6stat_inc(icp6s_badlen);
		break;
	}

#if NPF > 0
raw:
#endif
	/* deliver the packet to appropriate sockets */
	return rip6_input(mp, offp, proto, af);

 freeit:
	m_freem(m);
	return IPPROTO_DONE;
}

int
icmp6_notify_error(struct mbuf *m, int off, int icmp6len, int code)
{
	struct icmp6_hdr *icmp6;
	struct ip6_hdr *eip6;
	u_int32_t notifymtu;
	struct sockaddr_in6 icmp6src, icmp6dst;

	if (icmp6len < sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr)) {
		icmp6stat_inc(icp6s_tooshort);
		goto freeit;
	}
	IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off,
		       sizeof(*icmp6) + sizeof(struct ip6_hdr));
	if (icmp6 == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		return (-1);
	}
	eip6 = (struct ip6_hdr *)(icmp6 + 1);

	/* Detect the upper level protocol */
	{
		void (*ctlfunc)(int, struct sockaddr *, u_int, void *);
		u_int8_t nxt = eip6->ip6_nxt;
		int eoff = off + sizeof(struct icmp6_hdr) +
			sizeof(struct ip6_hdr);
		struct ip6ctlparam ip6cp;
		struct in6_addr *finaldst = NULL;
		int icmp6type = icmp6->icmp6_type;
		struct ip6_frag *fh;
		struct ip6_rthdr *rth;
		struct ip6_rthdr0 *rth0;
		int rthlen;

		while (1) { /* XXX: should avoid infinite loop explicitly? */
			struct ip6_ext *eh;

			switch (nxt) {
			case IPPROTO_HOPOPTS:
			case IPPROTO_DSTOPTS:
			case IPPROTO_AH:
				IP6_EXTHDR_GET(eh, struct ip6_ext *, m,
					       eoff, sizeof(*eh));
				if (eh == NULL) {
					icmp6stat_inc(icp6s_tooshort);
					return (-1);
				}

				if (nxt == IPPROTO_AH)
					eoff += (eh->ip6e_len + 2) << 2;
				else
					eoff += (eh->ip6e_len + 1) << 3;
				nxt = eh->ip6e_nxt;
				break;
			case IPPROTO_ROUTING:
				/*
				 * When the erroneous packet contains a
				 * routing header, we should examine the
				 * header to determine the final destination.
				 * Otherwise, we can't properly update
				 * information that depends on the final
				 * destination (e.g. path MTU).
				 */
				IP6_EXTHDR_GET(rth, struct ip6_rthdr *, m,
					       eoff, sizeof(*rth));
				if (rth == NULL) {
					icmp6stat_inc(icp6s_tooshort);
					return (-1);
				}
				rthlen = (rth->ip6r_len + 1) << 3;
				/*
				 * XXX: currently there is no
				 * officially defined type other
				 * than type-0.
				 * Note that if the segment left field
				 * is 0, all intermediate hops must
				 * have been passed.
				 */
				if (rth->ip6r_segleft &&
				    rth->ip6r_type == IPV6_RTHDR_TYPE_0) {
					int hops;

					IP6_EXTHDR_GET(rth0,
						       struct ip6_rthdr0 *, m,
						       eoff, rthlen);
					if (rth0 == NULL) {
						icmp6stat_inc(icp6s_tooshort);
						return (-1);
					}
					/* just ignore a bogus header */
					if ((rth0->ip6r0_len % 2) == 0 &&
					    (hops = rth0->ip6r0_len/2))
						finaldst = (struct in6_addr *)(rth0 + 1) + (hops - 1);
				}
				eoff += rthlen;
				nxt = rth->ip6r_nxt;
				break;
			case IPPROTO_FRAGMENT:
				IP6_EXTHDR_GET(fh, struct ip6_frag *, m,
					       eoff, sizeof(*fh));
				if (fh == NULL) {
					icmp6stat_inc(icp6s_tooshort);
					return (-1);
				}
				/*
				 * Data after a fragment header is meaningless
				 * unless it is the first fragment, but
				 * we'll go to the notify label for path MTU
				 * discovery.
				 */
				if (fh->ip6f_offlg & IP6F_OFF_MASK)
					goto notify;

				eoff += sizeof(struct ip6_frag);
				nxt = fh->ip6f_nxt;
				break;
			default:
				/*
				 * This case includes ESP and the No Next
				 * Header.  In such cases going to the notify
				 * label does not have any meaning
				 * (i.e. ctlfunc will be NULL), but we go
				 * anyway since we might have to update
				 * path MTU information.
				 */
				goto notify;
			}
		}
	  notify:
		IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off,
			       sizeof(*icmp6) + sizeof(struct ip6_hdr));
		if (icmp6 == NULL) {
			icmp6stat_inc(icp6s_tooshort);
			return (-1);
		}

		eip6 = (struct ip6_hdr *)(icmp6 + 1);
		bzero(&icmp6dst, sizeof(icmp6dst));
		icmp6dst.sin6_len = sizeof(struct sockaddr_in6);
		icmp6dst.sin6_family = AF_INET6;
		if (finaldst == NULL)
			icmp6dst.sin6_addr = eip6->ip6_dst;
		else
			icmp6dst.sin6_addr = *finaldst;
		icmp6dst.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.ph_ifidx,
		    &icmp6dst.sin6_addr);
		if (in6_embedscope(&icmp6dst.sin6_addr, &icmp6dst, NULL)) {
			/* should be impossbile */
			nd6log((LOG_DEBUG,
			    "icmp6_notify_error: in6_embedscope failed\n"));
			goto freeit;
		}

		/*
		 * retrieve parameters from the inner IPv6 header, and convert
		 * them into sockaddr structures.
		 */
		bzero(&icmp6src, sizeof(icmp6src));
		icmp6src.sin6_len = sizeof(struct sockaddr_in6);
		icmp6src.sin6_family = AF_INET6;
		icmp6src.sin6_addr = eip6->ip6_src;
		icmp6src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.ph_ifidx,
		    &icmp6src.sin6_addr);
		if (in6_embedscope(&icmp6src.sin6_addr, &icmp6src, NULL)) {
			/* should be impossbile */
			nd6log((LOG_DEBUG,
			    "icmp6_notify_error: in6_embedscope failed\n"));
			goto freeit;
		}
		icmp6src.sin6_flowinfo =
		    (eip6->ip6_flow & IPV6_FLOWLABEL_MASK);

		if (finaldst == NULL)
			finaldst = &eip6->ip6_dst;
		ip6cp.ip6c_m = m;
		ip6cp.ip6c_icmp6 = icmp6;
		ip6cp.ip6c_ip6 = (struct ip6_hdr *)(icmp6 + 1);
		ip6cp.ip6c_off = eoff;
		ip6cp.ip6c_finaldst = finaldst;
		ip6cp.ip6c_src = &icmp6src;
		ip6cp.ip6c_nxt = nxt;
#if NPF > 0
		pf_pkt_addr_changed(m);
#endif

		if (icmp6type == ICMP6_PACKET_TOO_BIG) {
			notifymtu = ntohl(icmp6->icmp6_mtu);
			ip6cp.ip6c_cmdarg = (void *)&notifymtu;
		}

		ctlfunc = inet6sw[ip6_protox[nxt]].pr_ctlinput;
		if (ctlfunc)
			(*ctlfunc)(code, sin6tosa(&icmp6dst),
			    m->m_pkthdr.ph_rtableid, &ip6cp);
	}
	return (0);

  freeit:
	m_freem(m);
	return (-1);
}

void
icmp6_mtudisc_update(struct ip6ctlparam *ip6cp, int validated)
{
	unsigned long rtcount;
	struct icmp6_mtudisc_callback *mc;
	struct in6_addr *dst = ip6cp->ip6c_finaldst;
	struct icmp6_hdr *icmp6 = ip6cp->ip6c_icmp6;
	struct mbuf *m = ip6cp->ip6c_m;	/* will be necessary for scope issue */
	u_int mtu = ntohl(icmp6->icmp6_mtu);
	struct rtentry *rt = NULL;
	struct sockaddr_in6 sin6;

	if (mtu < IPV6_MMTU)
		return;

	/*
	 * allow non-validated cases if memory is plenty, to make traffic
	 * from non-connected pcb happy.
	 */
	rtcount = rt_timer_queue_count(icmp6_mtudisc_timeout_q);
	if (validated) {
		if (0 <= icmp6_mtudisc_hiwat && rtcount > icmp6_mtudisc_hiwat)
			return;
		else if (0 <= icmp6_mtudisc_lowat &&
		    rtcount > icmp6_mtudisc_lowat) {
			/*
			 * XXX nuke a victim, install the new one.
			 */
		}
	} else {
		if (0 <= icmp6_mtudisc_lowat && rtcount > icmp6_mtudisc_lowat)
			return;
	}

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = PF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *dst;
	/* XXX normally, this won't happen */
	if (IN6_IS_ADDR_LINKLOCAL(dst)) {
		sin6.sin6_addr.s6_addr16[1] = htons(m->m_pkthdr.ph_ifidx);
	}
	sin6.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.ph_ifidx,
	    &sin6.sin6_addr);

	rt = icmp6_mtudisc_clone(sin6tosa(&sin6), m->m_pkthdr.ph_rtableid);

	if (rt != NULL && ISSET(rt->rt_flags, RTF_HOST) &&
	    !(rt->rt_locks & RTV_MTU) &&
	    (rt->rt_mtu > mtu || rt->rt_mtu == 0)) {
		struct ifnet *ifp;

		ifp = if_get(rt->rt_ifidx);
		if (ifp != NULL && mtu < ifp->if_mtu) {
			icmp6stat_inc(icp6s_pmtuchg);
			rt->rt_mtu = mtu;
		}
		if_put(ifp);
	}
	rtfree(rt);

	/*
	 * Notify protocols that the MTU for this destination
	 * has changed.
	 */
	LIST_FOREACH(mc, &icmp6_mtudisc_callbacks, mc_list)
		(*mc->mc_func)(&sin6, m->m_pkthdr.ph_rtableid);
}

/*
 * Reflect the ip6 packet back to the source.
 * OFF points to the icmp6 header, counted from the top of the mbuf.
 *
 * Note: RFC 1885 required that an echo reply should be truncated if it
 * did not fit in with (return) path MTU, and KAME code supported the
 * behavior.  However, as a clarification after the RFC, this limitation
 * was removed in a revised version of the spec, RFC 2463.  We had kept the
 * old behavior, with a (non-default) ifdef block, while the new version of
 * the spec was an internet-draft status, and even after the new RFC was
 * published.  But it would rather make sense to clean the obsoleted part
 * up, and to make the code simpler at this stage.
 */
void
icmp6_reflect(struct mbuf *m, size_t off)
{
	struct rtentry *rt = NULL;
	struct ip6_hdr *ip6;
	struct icmp6_hdr *icmp6;
	struct in6_addr t, *src = NULL;
	struct sockaddr_in6 sa6_src, sa6_dst;

	CTASSERT(sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) <= MHLEN);

	/* too short to reflect */
	if (off < sizeof(struct ip6_hdr)) {
		nd6log((LOG_DEBUG,
		    "sanity fail: off=%lx, sizeof(ip6)=%lx in %s:%d\n",
		    (u_long)off, (u_long)sizeof(struct ip6_hdr),
		    __FILE__, __LINE__));
		goto bad;
	}

	/*
	 * If there are extra headers between IPv6 and ICMPv6, strip
	 * off that header first.
	 */
	if (off > sizeof(struct ip6_hdr)) {
		size_t l;
		struct ip6_hdr nip6;

		l = off - sizeof(struct ip6_hdr);
		m_copydata(m, 0, sizeof(nip6), (caddr_t)&nip6);
		m_adj(m, l);
		l = sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr);
		if (m->m_len < l) {
			if ((m = m_pullup(m, l)) == NULL)
				return;
		}
		bcopy((caddr_t)&nip6, mtod(m, caddr_t), sizeof(nip6));
	} else /* off == sizeof(struct ip6_hdr) */ {
		size_t l;
		l = sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr);
		if (m->m_len < l) {
			if ((m = m_pullup(m, l)) == NULL)
				return;
		}
	}
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	icmp6 = (struct icmp6_hdr *)(ip6 + 1);

	t = ip6->ip6_dst;
	/*
	 * ip6_input() drops a packet if its src is multicast.
	 * So, the src is never multicast.
	 */
	ip6->ip6_dst = ip6->ip6_src;

	/*
	 * XXX: make sure to embed scope zone information, using
	 * already embedded IDs or the received interface (if any).
	 * Note that rcvif may be NULL.
	 * TODO: scoped routing case (XXX).
	 */
	bzero(&sa6_src, sizeof(sa6_src));
	sa6_src.sin6_family = AF_INET6;
	sa6_src.sin6_len = sizeof(sa6_src);
	sa6_src.sin6_addr = ip6->ip6_dst;
	bzero(&sa6_dst, sizeof(sa6_dst));
	sa6_dst.sin6_family = AF_INET6;
	sa6_dst.sin6_len = sizeof(sa6_dst);
	sa6_dst.sin6_addr = t;

	/*
	 * If the incoming packet was addressed directly to us (i.e. unicast),
	 * use dst as the src for the reply.
	 * The IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED case would be VERY rare,
	 * but is possible (for example) when we encounter an error while
	 * forwarding procedure destined to a duplicated address of ours.
	 */
	rt = rtalloc(sin6tosa(&sa6_dst), 0, m->m_pkthdr.ph_rtableid);
	if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL) &&
	    !ISSET(ifatoia6(rt->rt_ifa)->ia6_flags,
	    IN6_IFF_ANYCAST|IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED)) {
		src = &t;
	}
	rtfree(rt);
	rt = NULL;

	if (src == NULL) {
		/*
		 * This case matches to multicasts, our anycast, or unicasts
		 * that we do not own.  Select a source address based on the
		 * source address of the erroneous packet.
		 */
		rt = rtalloc(sin6tosa(&sa6_src), RT_RESOLVE,
		    m->m_pkthdr.ph_rtableid);
		if (!rtisvalid(rt)) {
			char addr[INET6_ADDRSTRLEN];

			nd6log((LOG_DEBUG,
			    "%s: source can't be determined: dst=%s\n",
			    __func__, inet_ntop(AF_INET6, &sa6_src.sin6_addr,
				addr, sizeof(addr))));
			rtfree(rt);
			goto bad;
		}
		src = &ifatoia6(rt->rt_ifa)->ia_addr.sin6_addr;
	}

	ip6->ip6_src = *src;
	rtfree(rt);

	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	ip6->ip6_hlim = ip6_defhlim;

	icmp6->icmp6_cksum = 0;
	m->m_pkthdr.csum_flags = M_ICMP_CSUM_OUT;

	/*
	 * XXX option handling
	 */

	m->m_flags &= ~(M_BCAST|M_MCAST);

	/*
	 * To avoid a "too big" situation at an intermediate router
	 * and the path MTU discovery process, specify the IPV6_MINMTU flag.
	 * Note that only echo and node information replies are affected,
	 * since the length of ICMP6 errors is limited to the minimum MTU.
	 */
#if NPF > 0
	pf_pkt_addr_changed(m);
#endif
	ip6_send(m);
	return;

 bad:
	m_freem(m);
	return;
}

void
icmp6_fasttimo(void)
{

	mld6_fasttimeo();
}

const char *
icmp6_redirect_diag(struct in6_addr *src6, struct in6_addr *dst6,
    struct in6_addr *tgt6)
{
	static char buf[1024]; /* XXX */
	char src[INET6_ADDRSTRLEN];
	char dst[INET6_ADDRSTRLEN];
	char tgt[INET6_ADDRSTRLEN];

	snprintf(buf, sizeof(buf), "(src=%s dst=%s tgt=%s)",
		 inet_ntop(AF_INET6, src6, src, sizeof(src)),
		 inet_ntop(AF_INET6, dst6, dst, sizeof(dst)),
		 inet_ntop(AF_INET6, tgt6, tgt, sizeof(tgt)));
	return buf;
}

void
icmp6_redirect_input(struct mbuf *m, int off)
{
	struct ifnet *ifp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct nd_redirect *nd_rd;
	int icmp6len = ntohs(ip6->ip6_plen);
	char *lladdr = NULL;
	int lladdrlen = 0;
	struct rtentry *rt = NULL;
	int is_router;
	int is_onlink;
	struct in6_addr src6 = ip6->ip6_src;
	struct in6_addr redtgt6;
	struct in6_addr reddst6;
	union nd_opts ndopts;
	char addr[INET6_ADDRSTRLEN];

	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		return;

	/* XXX if we are router, we don't update route by icmp6 redirect */
	if (ip6_forwarding)
		goto freeit;
	if (!(ifp->if_xflags & IFXF_AUTOCONF6))
		goto freeit;

	IP6_EXTHDR_GET(nd_rd, struct nd_redirect *, m, off, icmp6len);
	if (nd_rd == NULL) {
		icmp6stat_inc(icp6s_tooshort);
		if_put(ifp);
		return;
	}
	redtgt6 = nd_rd->nd_rd_target;
	reddst6 = nd_rd->nd_rd_dst;

	if (IN6_IS_ADDR_LINKLOCAL(&redtgt6))
		redtgt6.s6_addr16[1] = htons(ifp->if_index);
	if (IN6_IS_ADDR_LINKLOCAL(&reddst6))
		reddst6.s6_addr16[1] = htons(ifp->if_index);

	/* validation */
	if (!IN6_IS_ADDR_LINKLOCAL(&src6)) {
		nd6log((LOG_ERR,
			"ICMP6 redirect sent from %s rejected; "
			"must be from linklocal\n",
			inet_ntop(AF_INET6, &src6, addr, sizeof(addr))));
		goto bad;
	}
	if (ip6->ip6_hlim != 255) {
		nd6log((LOG_ERR,
			"ICMP6 redirect sent from %s rejected; "
			"hlim=%d (must be 255)\n",
			inet_ntop(AF_INET6, &src6, addr, sizeof(addr)),
			ip6->ip6_hlim));
		goto bad;
	}
	if (IN6_IS_ADDR_MULTICAST(&reddst6)) {
		nd6log((LOG_ERR,
			"ICMP6 redirect rejected; "
			"redirect dst must be unicast: %s\n",
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
	}
    {
	/* ip6->ip6_src must be equal to gw for icmp6->icmp6_reddst */
	struct sockaddr_in6 sin6;
	struct in6_addr *gw6;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	bcopy(&reddst6, &sin6.sin6_addr, sizeof(reddst6));
	rt = rtalloc(sin6tosa(&sin6), 0, m->m_pkthdr.ph_rtableid);
	if (rt) {
		if (rt->rt_gateway == NULL ||
		    rt->rt_gateway->sa_family != AF_INET6) {
			nd6log((LOG_ERR,
			    "ICMP6 redirect rejected; no route "
			    "with inet6 gateway found for redirect dst: %s\n",
			    icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
			rtfree(rt);
			goto bad;
		}

		gw6 = &(satosin6(rt->rt_gateway)->sin6_addr);
		if (bcmp(&src6, gw6, sizeof(struct in6_addr)) != 0) {
			nd6log((LOG_ERR,
				"ICMP6 redirect rejected; "
				"not equal to gw-for-src=%s (must be same): "
				"%s\n",
				inet_ntop(AF_INET6, gw6, addr, sizeof(addr)),
				icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
			rtfree(rt);
			goto bad;
		}
	} else {
		nd6log((LOG_ERR,
			"ICMP6 redirect rejected; "
			"no route found for redirect dst: %s\n",
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
	}
	rtfree(rt);
	rt = NULL;
    }

	is_router = is_onlink = 0;
	if (IN6_IS_ADDR_LINKLOCAL(&redtgt6))
		is_router = 1;	/* router case */
	if (bcmp(&redtgt6, &reddst6, sizeof(redtgt6)) == 0)
		is_onlink = 1;	/* on-link destination case */
	if (!is_router && !is_onlink) {
		nd6log((LOG_ERR,
			"ICMP6 redirect rejected; "
			"neither router case nor onlink case: %s\n",
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
	}
	/* validation passed */

	icmp6len -= sizeof(*nd_rd);
	nd6_option_init(nd_rd + 1, icmp6len, &ndopts);
	if (nd6_options(&ndopts) < 0) {
		nd6log((LOG_INFO, "icmp6_redirect_input: "
			"invalid ND option, rejected: %s\n",
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		/* nd6_options have incremented stats */
		goto freeit;
	}

	if (ndopts.nd_opts_tgt_lladdr) {
		lladdr = (char *)(ndopts.nd_opts_tgt_lladdr + 1);
		lladdrlen = ndopts.nd_opts_tgt_lladdr->nd_opt_len << 3;
	}

	if (lladdr && ((ifp->if_addrlen + 2 + 7) & ~7) != lladdrlen) {
		nd6log((LOG_INFO,
			"icmp6_redirect_input: lladdrlen mismatch for %s "
			"(if %d, icmp6 packet %d): %s\n",
			inet_ntop(AF_INET6, &redtgt6, addr, sizeof(addr)),
			ifp->if_addrlen, lladdrlen - 2,
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
	}

	/* RFC 2461 8.3 */
	nd6_cache_lladdr(ifp, &redtgt6, lladdr, lladdrlen, ND_REDIRECT,
			 is_onlink ? ND_REDIRECT_ONLINK : ND_REDIRECT_ROUTER);

	if (!is_onlink) {	/* better router case.  perform rtredirect. */
		/* perform rtredirect */
		struct sockaddr_in6 sdst;
		struct sockaddr_in6 sgw;
		struct sockaddr_in6 ssrc;
		unsigned long rtcount;
		struct rtentry *newrt = NULL;

		/*
		 * do not install redirect route, if the number of entries
		 * is too much (> hiwat).  note that, the node (= host) will
		 * work just fine even if we do not install redirect route
		 * (there will be additional hops, though).
		 */
		rtcount = rt_timer_queue_count(icmp6_redirect_timeout_q);
		if (0 <= ip6_maxdynroutes && rtcount >= ip6_maxdynroutes)
			goto freeit;
		else if (0 <= icmp6_redirect_lowat &&
		    rtcount > icmp6_redirect_lowat) {
			/*
			 * XXX nuke a victim, install the new one.
			 */
		}

		bzero(&sdst, sizeof(sdst));
		bzero(&sgw, sizeof(sgw));
		bzero(&ssrc, sizeof(ssrc));
		sdst.sin6_family = sgw.sin6_family = ssrc.sin6_family = AF_INET6;
		sdst.sin6_len = sgw.sin6_len = ssrc.sin6_len =
			sizeof(struct sockaddr_in6);
		bcopy(&redtgt6, &sgw.sin6_addr, sizeof(struct in6_addr));
		bcopy(&reddst6, &sdst.sin6_addr, sizeof(struct in6_addr));
		bcopy(&src6, &ssrc.sin6_addr, sizeof(struct in6_addr));
		rtredirect(sin6tosa(&sdst), sin6tosa(&sgw), sin6tosa(&ssrc),
		    &newrt, m->m_pkthdr.ph_rtableid);

		if (newrt) {
			(void)rt_timer_add(newrt, icmp6_redirect_timeout,
			    icmp6_redirect_timeout_q, m->m_pkthdr.ph_rtableid);
			rtfree(newrt);
		}
	}
	/* finally update cached route in each socket via pfctlinput */
	{
		struct sockaddr_in6 sdst;

		bzero(&sdst, sizeof(sdst));
		sdst.sin6_family = AF_INET6;
		sdst.sin6_len = sizeof(struct sockaddr_in6);
		bcopy(&reddst6, &sdst.sin6_addr, sizeof(struct in6_addr));
		pfctlinput(PRC_REDIRECT_HOST, sin6tosa(&sdst));
	}

 freeit:
	if_put(ifp);
	m_freem(m);
	return;

 bad:
	if_put(ifp);
	icmp6stat_inc(icp6s_badredirect);
	m_freem(m);
}

void
icmp6_redirect_output(struct mbuf *m0, struct rtentry *rt)
{
	struct ifnet *ifp = NULL;
	struct in6_addr *ifp_ll6;
	struct in6_addr *nexthop;
	struct ip6_hdr *sip6;	/* m0 as struct ip6_hdr */
	struct mbuf *m = NULL;	/* newly allocated one */
	struct ip6_hdr *ip6;	/* m as struct ip6_hdr */
	struct nd_redirect *nd_rd;
	size_t maxlen;
	u_char *p;
	struct sockaddr_in6 src_sa;

	icmp6_errcount(ND_REDIRECT, 0);

	/* if we are not router, we don't send icmp6 redirect */
	if (!ip6_forwarding)
		goto fail;

	/* sanity check */
	if (m0 == NULL || !rtisvalid(rt))
		goto fail;

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		goto fail;

	/*
	 * Address check:
	 *  the source address must identify a neighbor, and
	 *  the destination address must not be a multicast address
	 *  [RFC 2461, sec 8.2]
	 */
	sip6 = mtod(m0, struct ip6_hdr *);
	bzero(&src_sa, sizeof(src_sa));
	src_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = sizeof(src_sa);
	src_sa.sin6_addr = sip6->ip6_src;
	/* we don't currently use sin6_scope_id, but eventually use it */
	src_sa.sin6_scope_id = in6_addr2scopeid(ifp->if_index, &sip6->ip6_src);
	if (nd6_is_addr_neighbor(&src_sa, ifp) == 0)
		goto fail;
	if (IN6_IS_ADDR_MULTICAST(&sip6->ip6_dst))
		goto fail;	/* what should we do here? */

	/* rate limit */
	if (icmp6_ratelimit(&sip6->ip6_src, ND_REDIRECT, 0))
		goto fail;

	/*
	 * Since we are going to append up to 1280 bytes (= IPV6_MMTU),
	 * we almost always ask for an mbuf cluster for simplicity.
	 * (MHLEN < IPV6_MMTU is almost always true)
	 */
#if IPV6_MMTU >= MCLBYTES
# error assumption failed about IPV6_MMTU and MCLBYTES
#endif
	MGETHDR(m, M_DONTWAIT, MT_HEADER);
	if (m && IPV6_MMTU >= MHLEN)
		MCLGET(m, M_DONTWAIT);
	if (!m)
		goto fail;
	m->m_pkthdr.ph_ifidx = 0;
	m->m_len = 0;
	maxlen = M_TRAILINGSPACE(m);
	maxlen = min(IPV6_MMTU, maxlen);
	/* just for safety */
	if (maxlen < sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) +
	    ((sizeof(struct nd_opt_hdr) + ifp->if_addrlen + 7) & ~7)) {
		goto fail;
	}

	{
		/* get ip6 linklocal address for ifp(my outgoing interface). */
		struct in6_ifaddr *ia6;
		if ((ia6 = in6ifa_ifpforlinklocal(ifp, IN6_IFF_TENTATIVE|
		    IN6_IFF_DUPLICATED|IN6_IFF_ANYCAST)) == NULL)
			goto fail;
		ifp_ll6 = &ia6->ia_addr.sin6_addr;
	}

	/* get ip6 linklocal address for the router. */
	if (rt->rt_gateway && (rt->rt_flags & RTF_GATEWAY)) {
		struct sockaddr_in6 *sin6;
		sin6 = satosin6(rt->rt_gateway);
		nexthop = &sin6->sin6_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(nexthop))
			nexthop = NULL;
	} else
		nexthop = NULL;

	/* ip6 */
	ip6 = mtod(m, struct ip6_hdr *);
	ip6->ip6_flow = 0;
	ip6->ip6_vfc &= ~IPV6_VERSION_MASK;
	ip6->ip6_vfc |= IPV6_VERSION;
	/* ip6->ip6_plen will be set later */
	ip6->ip6_nxt = IPPROTO_ICMPV6;
	ip6->ip6_hlim = 255;
	/* ip6->ip6_src must be linklocal addr for my outgoing if. */
	bcopy(ifp_ll6, &ip6->ip6_src, sizeof(struct in6_addr));
	bcopy(&sip6->ip6_src, &ip6->ip6_dst, sizeof(struct in6_addr));

	/* ND Redirect */
	nd_rd = (struct nd_redirect *)(ip6 + 1);
	nd_rd->nd_rd_type = ND_REDIRECT;
	nd_rd->nd_rd_code = 0;
	nd_rd->nd_rd_reserved = 0;
	if (rt->rt_flags & RTF_GATEWAY) {
		/*
		 * nd_rd->nd_rd_target must be a link-local address in
		 * better router cases.
		 */
		if (!nexthop)
			goto fail;
		bcopy(nexthop, &nd_rd->nd_rd_target,
		      sizeof(nd_rd->nd_rd_target));
		bcopy(&sip6->ip6_dst, &nd_rd->nd_rd_dst,
		      sizeof(nd_rd->nd_rd_dst));
	} else {
		/* make sure redtgt == reddst */
		nexthop = &sip6->ip6_dst;
		bcopy(&sip6->ip6_dst, &nd_rd->nd_rd_target,
		      sizeof(nd_rd->nd_rd_target));
		bcopy(&sip6->ip6_dst, &nd_rd->nd_rd_dst,
		      sizeof(nd_rd->nd_rd_dst));
	}

	p = (u_char *)(nd_rd + 1);

	{
		/* target lladdr option */
		struct rtentry *nrt;
		int len;
		struct sockaddr_dl *sdl;
		struct nd_opt_hdr *nd_opt;
		char *lladdr;

		len = sizeof(*nd_opt) + ifp->if_addrlen;
		len = (len + 7) & ~7;	/* round by 8 */
		/* safety check */
		if (len + (p - (u_char *)ip6) > maxlen)
			goto nolladdropt;
		nrt = nd6_lookup(nexthop, 0, ifp, ifp->if_rdomain);
		if ((nrt != NULL) &&
		    (nrt->rt_flags & (RTF_GATEWAY|RTF_LLINFO)) == RTF_LLINFO &&
		    (nrt->rt_gateway->sa_family == AF_LINK) &&
		    (sdl = satosdl(nrt->rt_gateway)) &&
		    sdl->sdl_alen) {
			nd_opt = (struct nd_opt_hdr *)p;
			nd_opt->nd_opt_type = ND_OPT_TARGET_LINKADDR;
			nd_opt->nd_opt_len = len >> 3;
			lladdr = (char *)(nd_opt + 1);
			bcopy(LLADDR(sdl), lladdr, ifp->if_addrlen);
			p += len;
		}
		rtfree(nrt);
	}
  nolladdropt:;

	m->m_pkthdr.len = m->m_len = p - (u_char *)ip6;

	/* just to be safe */
	if (p - (u_char *)ip6 > maxlen)
		goto noredhdropt;

	{
		/* redirected header option */
		int len;
		struct nd_opt_rd_hdr *nd_opt_rh;

		/*
		 * compute the maximum size for icmp6 redirect header option.
		 * XXX room for auth header?
		 */
		len = maxlen - (p - (u_char *)ip6);
		len &= ~7;

		/*
		 * Redirected header option spec (RFC2461 4.6.3) talks nothing
		 * about padding/truncate rule for the original IP packet.
		 * From the discussion on IPv6imp in Feb 1999,
		 * the consensus was:
		 * - "attach as much as possible" is the goal
		 * - pad if not aligned (original size can be guessed by
		 *   original ip6 header)
		 * Following code adds the padding if it is simple enough,
		 * and truncates if not.
		 */
		if (len - sizeof(*nd_opt_rh) < m0->m_pkthdr.len) {
			/* not enough room, truncate */
			m_adj(m0, (len - sizeof(*nd_opt_rh)) -
			    m0->m_pkthdr.len);
		} else {
			/*
			 * enough room, truncate if not aligned.
			 * we don't pad here for simplicity.
			 */
			size_t extra;

			extra = m0->m_pkthdr.len % 8;
			if (extra) {
				/* truncate */
				m_adj(m0, -extra);
			}
			len = m0->m_pkthdr.len + sizeof(*nd_opt_rh);
		}

		nd_opt_rh = (struct nd_opt_rd_hdr *)p;
		bzero(nd_opt_rh, sizeof(*nd_opt_rh));
		nd_opt_rh->nd_opt_rh_type = ND_OPT_REDIRECTED_HEADER;
		nd_opt_rh->nd_opt_rh_len = len >> 3;
		p += sizeof(*nd_opt_rh);
		m->m_pkthdr.len = m->m_len = p - (u_char *)ip6;

		/* connect m0 to m */
		m->m_pkthdr.len += m0->m_pkthdr.len;
		m_cat(m, m0);
		m0 = NULL;
	}
noredhdropt:
	m_freem(m0);
	m0 = NULL;

	sip6 = mtod(m, struct ip6_hdr *);
	if (IN6_IS_ADDR_LINKLOCAL(&sip6->ip6_src))
		sip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_ADDR_LINKLOCAL(&sip6->ip6_dst))
		sip6->ip6_dst.s6_addr16[1] = 0;
#if 0
	if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_src))
		ip6->ip6_src.s6_addr16[1] = 0;
	if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] = 0;
#endif
	if (IN6_IS_ADDR_LINKLOCAL(&nd_rd->nd_rd_target))
		nd_rd->nd_rd_target.s6_addr16[1] = 0;
	if (IN6_IS_ADDR_LINKLOCAL(&nd_rd->nd_rd_dst))
		nd_rd->nd_rd_dst.s6_addr16[1] = 0;

	ip6->ip6_plen = htons(m->m_pkthdr.len - sizeof(struct ip6_hdr));

	nd_rd->nd_rd_cksum = 0;
	m->m_pkthdr.csum_flags = M_ICMP_CSUM_OUT;

	/* send the packet to outside... */
	ip6_output(m, NULL, NULL, 0, NULL, NULL);

	icmp6stat_inc(icp6s_outhist + ND_REDIRECT);

	if_put(ifp);
	return;

fail:
	if_put(ifp);
	m_freem(m);
	m_freem(m0);
}

/*
 * ICMPv6 socket option processing.
 */
int
icmp6_ctloutput(int op, struct socket *so, int level, int optname,
    struct mbuf *m)
{
	int error = 0;
	struct inpcb *in6p = sotoinpcb(so);

	if (level != IPPROTO_ICMPV6) {
		if (op == PRCO_SETOPT)
			(void)m_free(m);
		return EINVAL;
	}

	switch (op) {
	case PRCO_SETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			if (m == NULL || m->m_len != sizeof(*p)) {
				error = EMSGSIZE;
				break;
			}
			p = mtod(m, struct icmp6_filter *);
			if (!p || !in6p->inp_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(p, in6p->inp_icmp6filt,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		m_freem(m);
		break;

	case PRCO_GETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			if (!in6p->inp_icmp6filt) {
				error = EINVAL;
				break;
			}
			m->m_len = sizeof(struct icmp6_filter);
			p = mtod(m, struct icmp6_filter *);
			bcopy(in6p->inp_icmp6filt, p,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}

	return (error);
}

/*
 * Perform rate limit check.
 * Returns 0 if it is okay to send the icmp6 packet.
 * Returns 1 if the router SHOULD NOT send this icmp6 packet due to rate
 * limitation.
 *
 * XXX per-destination/type check necessary?
 *
 * dst - not used at this moment
 * type - not used at this moment
 * code - not used at this moment
 */
int
icmp6_ratelimit(const struct in6_addr *dst, const int type, const int code)
{
	/* PPS limit */
	if (!ppsratecheck(&icmp6errppslim_last, &icmp6errpps_count,
	    icmp6errppslim))
		return 1;	/* The packet is subject to rate limit */
	return 0;		/* okay to send */
}

struct rtentry *
icmp6_mtudisc_clone(struct sockaddr *dst, u_int rtableid)
{
	struct rtentry *rt;
	int    error;

	rt = rtalloc(dst, RT_RESOLVE, rtableid);

	/* Check if the route is actually usable */
	if (!rtisvalid(rt) || (rt->rt_flags & (RTF_REJECT|RTF_BLACKHOLE))) {
		rtfree(rt);
		return (NULL);
	}

	/* If we didn't get a host route, allocate one */
	if ((rt->rt_flags & RTF_HOST) == 0) {
		struct rtentry *nrt;
		struct rt_addrinfo info;
		struct sockaddr_rtlabel sa_rl;

		memset(&info, 0, sizeof(info));
		info.rti_ifa = rt->rt_ifa;
		info.rti_flags = RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC;
		info.rti_info[RTAX_DST] = dst;
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_LABEL] =
		    rtlabel_id2sa(rt->rt_labelid, &sa_rl);

		error = rtrequest(RTM_ADD, &info, rt->rt_priority, &nrt,
		    rtableid);
		if (error) {
			rtfree(rt);
			return (NULL);
		}
		nrt->rt_rmx = rt->rt_rmx;
		rtfree(rt);
		rt = nrt;
	}
	error = rt_timer_add(rt, icmp6_mtudisc_timeout, icmp6_mtudisc_timeout_q,
	    rtableid);
	if (error) {
		rtfree(rt);
		return (NULL);
	}

	return (rt);
}

void
icmp6_mtudisc_timeout(struct rtentry *rt, struct rttimer *r)
{
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		return;

	if ((rt->rt_flags & (RTF_DYNAMIC|RTF_HOST)) == (RTF_DYNAMIC|RTF_HOST)) {
		rtdeletemsg(rt, ifp, r->rtt_tableid);
	} else {
		if (!(rt->rt_locks & RTV_MTU))
			rt->rt_mtu = 0;
	}

	if_put(ifp);
}

void
icmp6_redirect_timeout(struct rtentry *rt, struct rttimer *r)
{
	struct ifnet *ifp;

	NET_ASSERT_LOCKED();

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		return;

	if ((rt->rt_flags & (RTF_DYNAMIC|RTF_HOST)) == (RTF_DYNAMIC|RTF_HOST)) {
		rtdeletemsg(rt, ifp, r->rtt_tableid);
	}

	if_put(ifp);
}

int *icmpv6ctl_vars[ICMPV6CTL_MAXID] = ICMPV6CTL_VARS;

int
icmp6_sysctl_icmp6stat(void *oldp, size_t *oldlenp, void *newp)
{
	struct icmp6stat *icmp6stat;
	int ret;

	CTASSERT(sizeof(*icmp6stat) == icp6s_ncounters * sizeof(uint64_t));
	icmp6stat = malloc(sizeof(*icmp6stat), M_TEMP, M_WAITOK|M_ZERO);
	counters_read(icmp6counters, (uint64_t *)icmp6stat, icp6s_ncounters);
	ret = sysctl_rdstruct(oldp, oldlenp, newp,
	    icmp6stat, sizeof(*icmp6stat));
	free(icmp6stat, M_TEMP, sizeof(*icmp6stat));

	return (ret);
}

int
icmp6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen)
{
	/* All sysctl names at this level are terminal. */
	if (namelen != 1)
		return ENOTDIR;

	switch (name[0]) {

	case ICMPV6CTL_STATS:
		return icmp6_sysctl_icmp6stat(oldp, oldlenp, newp);
	case ICMPV6CTL_ND6_DRLIST:
	case ICMPV6CTL_ND6_PRLIST:
		return nd6_sysctl(name[0], oldp, oldlenp, newp, newlen);
	default:
		if (name[0] < ICMPV6CTL_MAXID)
			return (sysctl_int_arr(icmpv6ctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
		return ENOPROTOOPT;
	}
	/* NOTREACHED */
}
@


1.211
log
@Carp balancing ip does not work since there is a mac filter in
ether_input(). Now we use mbuf tags instead of modifying the MAC
address.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.210 2017/05/08 16:14:47 rzalamena Exp $	*/
a1119 2
	in6_recoverscope(&sa6_src, &ip6->ip6_dst);
	in6_embedscope(&ip6->ip6_dst, &sa6_src, NULL);
a1123 2
	in6_recoverscope(&sa6_dst, &t);
	in6_embedscope(&t, &sa6_dst, NULL);
@


1.210
log
@Fix a possible NULL pointer deference on icmp6 echo reply caught by
clang.

with tweak from and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.209 2017/05/08 13:51:09 rzalamena Exp $	*/
d449 1
a449 1
	    ip6->ip6_dst.s6_addr32)) {
@


1.209
log
@Remove icmp6_reflect() micro optimization to simplify code and avoid a
M_LOOP flag dance in ip6_output().

ok bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.208 2017/05/04 17:58:46 bluhm Exp $	*/
a597 2
		nicmp6->icmp6_type = ICMP6_ECHO_REPLY;
		nicmp6->icmp6_code = 0;
d599 2
@


1.208
log
@If m is not a continuous mbuf cluster, m_pullup() in pr_input may
change the pointer.  Then *mp keeps the invalid pointer and it might
be used.  Fix the potential use after free and also reset *mp in
other places to have less dangling pointers to freed mbufs.
OK mpi@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.207 2017/04/19 15:44:45 bluhm Exp $	*/
a1129 7
	 * This is the case if the dst is our link-local address
	 * and the sender is also ourselves.
	 */
	if (IN6_IS_ADDR_LINKLOCAL(&t) && (m->m_flags & M_LOOP))
		src = &t;

	/*
d1136 5
a1140 9
	if (src == NULL) {
		rt = rtalloc(sin6tosa(&sa6_dst), 0, m->m_pkthdr.ph_rtableid);
		if (rtisvalid(rt) && ISSET(rt->rt_flags, RTF_LOCAL) &&
		    !ISSET(ifatoia6(rt->rt_ifa)->ia6_flags,
		    IN6_IFF_ANYCAST|IN6_IFF_TENTATIVE|IN6_IFF_DUPLICATED)) {
			src = &t;
		}
		rtfree(rt);
		rt = NULL;
d1142 2
@


1.207
log
@icmp6_rip6_input() was mostly duplicated code from rip6_input().
Merge these functions together and remove icmp6_rip6_input().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.206 2017/04/19 15:21:54 bluhm Exp $	*/
d536 1
a536 1
			m = NULL;
d570 1
a570 1
				m = NULL;
@


1.206
log
@Use the rt_rmx defines that hide the struct rt_kmetrics indirection.
No binary change.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.205 2017/04/14 20:46:31 bluhm Exp $	*/
a137 1
int	icmp6_rip6_input(struct mbuf **, int);
d763 1
a763 3
	icmp6_rip6_input(&m, *offp);

	return IPPROTO_DONE;
a1038 98
}

/*
 * XXX almost dup'ed code with rip6_input.
 */
int
icmp6_rip6_input(struct mbuf **mp, int off)
{
	struct mbuf *m = *mp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct inpcb *in6p;
	struct inpcb *last = NULL;
	struct sockaddr_in6 rip6src;
	struct icmp6_hdr *icmp6;
	struct mbuf *opts = NULL;

	IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off, sizeof(*icmp6));
	if (icmp6 == NULL) {
		/* m is already reclaimed */
		return IPPROTO_DONE;
	}

	bzero(&rip6src, sizeof(rip6src));
	rip6src.sin6_len = sizeof(struct sockaddr_in6);
	rip6src.sin6_family = AF_INET6;
	/* KAME hack: recover scopeid */
	in6_recoverscope(&rip6src, &ip6->ip6_src);

	TAILQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
		if (!(in6p->inp_flags & INP_IPV6))
			continue;
		if (in6p->inp_ipv6.ip6_nxt != IPPROTO_ICMPV6)
			continue;
#if NPF > 0
		if (m->m_pkthdr.pf.flags & PF_TAG_DIVERTED) {
			struct pf_divert *divert;

			/* XXX rdomain support */
			if ((divert = pf_find_divert(m)) == NULL)
				continue;
			if (IN6_IS_ADDR_UNSPECIFIED(&divert->addr.v6))
				goto divert_reply;
			if (!IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6,
			    &divert->addr.v6))
				continue;
		} else
 divert_reply:
#endif
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_laddr6) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->inp_laddr6, &ip6->ip6_dst))
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->inp_faddr6) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->inp_faddr6, &ip6->ip6_src))
			continue;
		if (in6p->inp_icmp6filt
		    && ICMP6_FILTER_WILLBLOCK(icmp6->icmp6_type,
				 in6p->inp_icmp6filt))
			continue;
		if (last) {
			struct	mbuf *n;
			if ((n = m_copym(m, 0, M_COPYALL, M_NOWAIT)) != NULL) {
				if (last->inp_flags & IN6P_CONTROLOPTS)
					ip6_savecontrol(last, n, &opts);
				/* strip intermediate headers */
				m_adj(n, off);
				if (sbappendaddr(&last->inp_socket->so_rcv,
				    sin6tosa(&rip6src), n, opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					m_freem(opts);
				} else
					sorwakeup(last->inp_socket);
				opts = NULL;
			}
		}
		last = in6p;
	}
	if (last) {
		if (last->inp_flags & IN6P_CONTROLOPTS)
			ip6_savecontrol(last, m, &opts);
		/* strip intermediate headers */
		m_adj(m, off);
		if (sbappendaddr(&last->inp_socket->so_rcv,
		    sin6tosa(&rip6src), m, opts) == 0) {
			m_freem(m);
			m_freem(opts);
		} else
			sorwakeup(last->inp_socket);
	} else {
		struct counters_ref ref;
		uint64_t *counters;

		m_freem(m);
		counters = counters_enter(&ref, ip6counters);
		counters[ip6s_delivered]--;
		counters_leave(&ref, ip6counters);
	}
	return IPPROTO_DONE;
@


1.205
log
@Pass down the address family through the pr_input calls.  This
allows to simplify code used for both IPv4 and IPv6.
OK mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.204 2017/04/05 13:35:18 deraadt Exp $	*/
d1023 2
a1024 2
	    !(rt->rt_rmx.rmx_locks & RTV_MTU) &&
	    (rt->rt_rmx.rmx_mtu > mtu || rt->rt_rmx.rmx_mtu == 0)) {
d1030 1
a1030 1
			rt->rt_rmx.rmx_mtu = mtu;
d1966 2
a1967 2
		if (!(rt->rt_rmx.rmx_locks & RTV_MTU))
			rt->rt_rmx.rmx_mtu = 0;
@


1.204
log
@When building counter memory in preparation to copy to userland, always
zero the buffers first.  All the current objects appear to be safe,
however future changes might introduce structure pads.
Discussed with guenther, ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.203 2017/03/03 13:19:40 bluhm Exp $	*/
d381 1
a381 1
icmp6_input(struct mbuf **mp, int *offp, int proto)
@


1.203
log
@Replace a panic with a compile time assert in icmp6_reflect().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.202 2017/03/02 09:06:59 mpi Exp $	*/
d2000 1
a2000 1
	icmp6stat = malloc(sizeof(*icmp6stat), M_TEMP, M_WAITOK);
@


1.202
log
@Use the routing table rather than the global list of IPv6 address.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.201 2017/02/09 20:31:29 jca Exp $	*/
d1164 2
a1178 4
#ifdef DIAGNOSTIC
	if (sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) > MHLEN)
		panic("assumption failed in icmp6_reflect");
#endif
@


1.201
log
@Dedup calls to icmp6stat_inc in icmp6_errcount, should save a few bytes

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.200 2017/02/09 15:23:35 jca Exp $	*/
a1160 1
	struct in6_ifaddr *ia6;
d1233 7
d1246 5
a1250 4
	TAILQ_FOREACH(ia6, &in6_ifaddr, ia_list)
		if (IN6_ARE_ADDR_EQUAL(&t, &ia6->ia_addr.sin6_addr) &&
		    (ia6->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_TENTATIVE|
		    IN6_IFF_DUPLICATED)) == 0) {
a1251 1
			break;
d1253 2
a1254 6
	if (ia6 == NULL && IN6_IS_ADDR_LINKLOCAL(&t) && (m->m_flags & M_LOOP)) {
		/*
		 * This is the case if the dst is our link-local address
		 * and the sender is also ourselves.
		 */
		src = &t;
@


1.200
log
@percpu counters for raw ipv6 and icmp6 stats

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.199 2017/02/05 16:04:14 jca Exp $	*/
d159 2
d165 2
a166 2
			icmp6stat_inc(icp6s_odst_unreach_noroute);
			return;
d168 2
a169 2
			icmp6stat_inc(icp6s_odst_unreach_admin);
			return;
d171 2
a172 2
			icmp6stat_inc(icp6s_odst_unreach_beyondscope);
			return;
d174 2
a175 2
			icmp6stat_inc(icp6s_odst_unreach_addr);
			return;
d177 2
a178 2
			icmp6stat_inc(icp6s_odst_unreach_noport);
			return;
d182 2
a183 2
		icmp6stat_inc(icp6s_opacket_too_big);
		return;
d187 2
a188 2
			icmp6stat_inc(icp6s_otime_exceed_transit);
			return;
d190 2
a191 2
			icmp6stat_inc(icp6s_otime_exceed_reassembly);
			return;
d197 2
a198 2
			icmp6stat_inc(icp6s_oparamprob_header);
			return;
d200 2
a201 2
			icmp6stat_inc(icp6s_oparamprob_nextheader);
			return;
d203 2
a204 2
			icmp6stat_inc(icp6s_oparamprob_option);
			return;
d208 2
a209 2
		icmp6stat_inc(icp6s_oredirect);
		return;
d211 2
a212 1
	icmp6stat_inc(icp6s_ounknown);
@


1.199
log
@Use percpu counters for ip6stat

Try to follow the existing examples.  Some notes:
- don't implement counters_dec() yet, which could be used in two
  similar chunks of code.  Let's see if there are more users first.
- stop incrementing IPv6-specific mbuf stats, IPv4 has no equivalent.

Input from mpi@@, ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.198 2017/02/01 20:59:47 dhill Exp $	*/
d105 1
a105 1
struct icmp6stat icmp6stat;
d137 1
a137 1
void	icmp6_errcount(struct icmp6errstat *, int, int);
d153 1
d157 1
a157 1
icmp6_errcount(struct icmp6errstat *stat, int type, int code)
d163 1
a163 1
			stat->icp6errs_dst_unreach_noroute++;
d166 1
a166 1
			stat->icp6errs_dst_unreach_admin++;
d169 1
a169 1
			stat->icp6errs_dst_unreach_beyondscope++;
d172 1
a172 1
			stat->icp6errs_dst_unreach_addr++;
d175 1
a175 1
			stat->icp6errs_dst_unreach_noport++;
d180 1
a180 1
		stat->icp6errs_packet_too_big++;
d185 1
a185 1
			stat->icp6errs_time_exceed_transit++;
d188 1
a188 1
			stat->icp6errs_time_exceed_reassembly++;
d195 1
a195 1
			stat->icp6errs_paramprob_header++;
d198 1
a198 1
			stat->icp6errs_paramprob_nextheader++;
d201 1
a201 1
			stat->icp6errs_paramprob_option++;
d206 1
a206 1
		stat->icp6errs_redirect++;
d209 1
a209 1
	stat->icp6errs_unknown++;
d245 1
a245 1
	icmp6stat.icp6s_error++;
d248 1
a248 1
	icmp6_errcount(&icmp6stat.icp6s_outerrhist, type, code);
d295 1
a295 1
			icmp6stat.icp6s_tooshort++;
d305 1
a305 1
			icmp6stat.icp6s_canterror++;
d319 1
a319 1
		icmp6stat.icp6s_toofreq++;
d362 1
a362 1
	icmp6stat.icp6s_outhist[type]++;
d398 1
a398 1
		icmp6stat.icp6s_tooshort++;
d407 1
a407 1
		icmp6stat.icp6s_tooshort++;
d417 1
a417 1
		icmp6stat.icp6s_checksum++;
d454 1
a454 1
	icmp6stat.icp6s_inhist[icmp6->icmp6_type]++;
d599 2
a600 2
			icmp6stat.icp6s_reflect++;
			icmp6stat.icp6s_outhist[ICMP6_ECHO_REPLY]++;
d749 1
a749 1
		icmp6stat.icp6s_badcode++;
d753 1
a753 1
		icmp6stat.icp6s_badlen++;
d779 1
a779 1
		icmp6stat.icp6s_tooshort++;
d785 1
a785 1
		icmp6stat.icp6s_tooshort++;
d814 1
a814 1
					icmp6stat.icp6s_tooshort++;
d836 1
a836 1
					icmp6stat.icp6s_tooshort++;
d856 1
a856 1
						icmp6stat.icp6s_tooshort++;
d871 1
a871 1
					icmp6stat.icp6s_tooshort++;
d902 1
a902 1
			icmp6stat.icp6s_tooshort++;
d1026 1
a1026 1
			icmp6stat.icp6s_pmtuchg++;
d1361 1
a1361 1
		icmp6stat.icp6s_tooshort++;
d1542 1
a1542 1
	icmp6stat.icp6s_badredirect++;
d1560 1
a1560 1
	icmp6_errcount(&icmp6stat.icp6s_outerrhist, ND_REDIRECT, 0);
d1795 1
a1795 1
	icmp6stat.icp6s_outhist[ND_REDIRECT]++;
d1991 16
d2017 1
a2017 2
		return sysctl_rdstruct(oldp, oldlenp, newp,
				&icmp6stat, sizeof(icmp6stat));
@


1.198
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.197 2017/01/19 14:49:19 bluhm Exp $	*/
d1127 3
d1131 3
a1133 1
		ip6stat.ip6s_delivered--;
@


1.197
log
@RFC 8021 "IPv6 Atomic Fragments Considered Harmful" deprecates
generating atomic fragments.  So remove the code that sends them.
CVE-2016-10142 has been assigned to that issue.
OK visa@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.196 2017/01/18 17:59:01 bluhm Exp $	*/
d1805 1
a1805 1
    struct mbuf **mp)
a1808 1
	struct mbuf *m = *mp;
a1854 1
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
@


1.196
log
@Use LIST_FOREACH to traverse icmp6_mtudisc_callbacks.  Fix whitespaces.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.195 2016/12/19 08:36:50 mpi Exp $	*/
d983 1
a983 5
	/*
	 * The MTU may not be less then the minimal IPv6 MTU except for the
	 * hack in ip6_output/ip6_setpmtu where we always include a frag header.
	 */
	if (mtu < IPV6_MMTU - sizeof(struct ip6_frag))
@


1.195
log
@Introduce the NET_LOCK() a rwlock used to serialize accesses to the parts
of the network stack that are not yet ready to be executed in parallel or
where new sleeping points are not possible.

This first pass replace all the entry points leading to ip_output(). This
is done to not introduce new sleeping points when trying to acquire ART's
write lock, needed when a new L2 entry is created via the RT_RESOLVE.

Inputs from and ok bluhm@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.194 2016/11/28 14:14:39 mpi Exp $	*/
d219 1
a219 2
	for (mc = LIST_FIRST(&icmp6_mtudisc_callbacks); mc != NULL;
	     mc = LIST_NEXT(mc, mc_list)) {
d1025 1
a1025 1
	    	struct ifnet *ifp;
d1027 1
a1027 1
	    	ifp = if_get(rt->rt_ifidx);
d1040 1
a1040 2
	for (mc = LIST_FIRST(&icmp6_mtudisc_callbacks); mc != NULL;
	     mc = LIST_NEXT(mc, mc_list))
@


1.194
log
@Explicitly initialize rti_ifa when automagically adding a route.

This will allow to strengthen checks when userland adds a route.

ok phessler@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.193 2016/11/16 12:48:19 bluhm Exp $	*/
d1956 1
a1956 1
	splsoftassert(IPL_SOFTNET);
d1977 1
a1977 1
	splsoftassert(IPL_SOFTNET);
@


1.193
log
@Bring icmp6_mtudisc_clone() in line with icmp_mtudisc_clone().  The
IPv4 dynamic route inherits the priority.  Only clone from a valid
IPv6 route.  Do not use splsoftnet() in IPv6.  Some stylistic changes
to make the functions similar.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.192 2016/11/16 12:21:46 bluhm Exp $	*/
d1924 1
@


1.192
log
@Inherit route label when creating dynamic routes for path MTU.
From Rivo Nurges; OK claudio@@ mpi@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.191 2016/11/09 09:04:48 mpi Exp $	*/
d1904 1
a1904 1
icmp6_mtudisc_clone(struct sockaddr *dst, u_int rdomain)
d1909 7
a1915 3
	rt = rtalloc(dst, RT_RESOLVE, rdomain);
	if (rt == NULL)
		return NULL;
a1921 1
		int s;
a1929 1
		s = splsoftnet();
d1931 1
a1931 2
		    rdomain);
		splx(s);
d1934 1
a1934 1
			return NULL;
d1940 2
a1941 2
	error = rt_timer_add(rt, icmp6_mtudisc_timeout,
			icmp6_mtudisc_timeout_q, rdomain);
d1944 1
a1944 1
		return NULL;
d1947 1
a1947 1
	return rt;	/* caller need to call rtfree() */
@


1.191
log
@Do not call splsoftnet() recursively, this won't work with a lock.

Timers configured via rt_timer_add(9) always run at IPL_SOFTNET, so
assert that rather than calling splsoftnet().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.190 2016/08/24 09:38:29 mpi Exp $	*/
d1915 1
d1917 1
a1917 1
		struct rtentry *nrt;
d1920 1
a1920 1
		bzero(&info, sizeof(info));
d1924 2
@


1.190
log
@Use rtalloc(9) directly instead of in6_selectsr() in icmp6_reflect().

This is another little step towards deprecating 'struct route{,_in6}'.

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.189 2016/08/04 20:46:24 vgross Exp $	*/
d1950 2
a1951 1
	int s;
a1957 1
		s = splsoftnet();
a1958 1
		splx(s);
d1971 2
a1972 1
	int s;
a1978 1
		s = splsoftnet();
a1979 1
		splx(s);
@


1.189
log
@Commit in6_selectsrc() split again, with missing assignment fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.188 2016/07/22 11:14:41 mpi Exp $	*/
d1155 1
a1252 4
		int error;
		struct route_in6 ro;
		char addr[INET6_ADDRSTRLEN];

d1258 1
a1258 2
		bzero(&ro, sizeof(ro));
		error = in6_selectsrc(&src, &sa6_src, NULL, &ro,
d1260 3
a1262 3
		if (ro.ro_rt)
			rtfree(ro.ro_rt); /* XXX: we could use this */
		if (error) {
d1264 4
a1267 5
			    "icmp6_reflect: source can't be determined: "
			    "dst=%s, error=%d\n",
			    inet_ntop(AF_INET6, &sa6_src.sin6_addr,
				addr, sizeof(addr)),
			    error));
d1270 1
d1274 1
@


1.188
log
@Revert in_selectsrc() refactoring, it breaks IPv6.

Reported by Heiko on bugs@@.

ok stsp@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.186 2016/07/05 10:17:14 mpi Exp $	*/
d1262 1
a1262 1
		error = in6_selectsrc(&src, &sa6_src, NULL, NULL, &ro, NULL,
@


1.187
log
@Split in6_selectsrc() into a low-level part and a pcb-level part, and
convert in_selectsrc() prototype to match.

Ok bluhm@@ mpi@@.
@
text
@d1262 1
a1262 1
		error = in6_selectsrc(&src, &sa6_src, NULL, &ro,
@


1.186
log
@Expand IN6_IFF_NOTREADY, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.185 2016/03/29 11:57:51 chl Exp $	*/
d1262 1
a1262 1
		error = in6_selectsrc(&src, &sa6_src, NULL, NULL, &ro, NULL,
@


1.185
log
@remove dead stores and unused variables

ok bluhm@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.184 2016/01/21 06:32:19 jsg Exp $	*/
d1232 3
a1234 3
	 * The IN6_IFF_NOTREADY case would be VERY rare, but is possible
	 * (for example) when we encounter an error while forwarding procedure
	 * destined to a duplicated address of ours.
d1238 2
a1239 1
		    (ia6->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) == 0) {
d1625 2
a1626 3
		if ((ia6 = in6ifa_ifpforlinklocal(ifp,
						 IN6_IFF_NOTREADY|
						 IN6_IFF_ANYCAST)) == NULL)
@


1.184
log
@add a missing if_put() in a carp specific path
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.183 2015/12/09 09:27:40 mpi Exp $	*/
a1158 2
	int plen;
	int type, code;
a1198 1
	plen = m->m_pkthdr.len - sizeof(struct ip6_hdr);
a1201 2
	type = icmp6->icmp6_type; /* keep type for statistics */
	code = icmp6->icmp6_code; /* ditto. */
@


1.183
log
@Always pass a valid interface pointer to rtdeletemsg().

This will allows for stricter checks inside rtdeletemsg() and it should be
up to the caller to decide if the route needs to be deleted or not.

ok vgross@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.182 2015/12/03 21:11:53 sashan Exp $	*/
d447 2
a448 1
	    ip6->ip6_dst.s6_addr32))
d450 1
@


1.182
log
@ip_send()/ip6_send() allow PF to send response packet in ipsoftnet task.
this avoids current recursion to pf_test() function. the change also
switches icmp_error()/icmp6_error() to use ip_send()/ip6_send() so
they are safe for PF.

The idea comes from Markus Friedl. bluhm, mikeb and mpi helped me
a lot to get it into shape.

OK bluhm@@, mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.181 2015/12/02 16:35:53 bluhm Exp $	*/
d1955 6
a1960 5
	if (rt == NULL)
		panic("icmp6_mtudisc_timeout: bad route to timeout");
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
	    (RTF_DYNAMIC | RTF_HOST)) {
		int s;
d1962 1
d1964 1
a1964 1
		rtdeletemsg(rt, NULL, r->rtt_tableid);
d1970 2
d1977 6
a1982 5
	if (rt == NULL)
		panic("icmp6_redirect_timeout: bad route to timeout");
	if ((rt->rt_flags & (RTF_GATEWAY | RTF_DYNAMIC | RTF_HOST)) ==
	    (RTF_GATEWAY | RTF_DYNAMIC | RTF_HOST)) {
		int s;
d1984 1
d1986 1
a1986 1
		rtdeletemsg(rt, NULL, r->rtt_tableid);
d1989 2
@


1.181
log
@When destroying an interface, we have to wait until all references
are not used anymore.  This has to be done before any interface
fields become invalid.
As the route delete request cannot call if_get() anymore, pass down
the interface.  Split rtrequest_delete() into a separate function
that may take an existing inteface.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.180 2015/12/02 13:29:26 claudio Exp $	*/
d1305 1
a1305 1
	ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, NULL);
@


1.180
log
@Kill the RT_REPORT flag to rtalloc() and stop sending RTM_MISS messages
for failed route lookups. This is something that was maybe useful in the
90is but in this modern times it is just annoying and nothing expect it
anyway. OK mpi@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.179 2015/12/01 21:26:43 mpi Exp $	*/
d1962 1
a1962 1
		rtdeletemsg(rt, r->rtt_tableid);
d1980 1
a1980 1
		rtdeletemsg(rt, r->rtt_tableid);
@


1.179
log
@Kill redundant or unused arguments in rtredirect().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.178 2015/11/21 11:23:07 mpi Exp $	*/
d1915 1
a1915 1
	rt = rtalloc(dst, RT_REPORT|RT_RESOLVE, rdomain);
@


1.178
log
@Use if_get() rather than dereferencing rt_ifp directly.

ok sthen@@, visa@@, sashan@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.177 2015/11/03 21:39:34 chl Exp $	*/
d1520 1
a1520 2
		rtredirect(sin6tosa(&sdst), sin6tosa(&sgw), NULL,
		    RTF_GATEWAY | RTF_HOST, sin6tosa(&ssrc),
@


1.177
log
@Remove dead assignments.

Found by LLVM/Clang Static Analyzer.

ok bluhm@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.176 2015/10/30 09:39:42 bluhm Exp $	*/
d1021 1
a1021 1
	if (rt && (rt->rt_flags & RTF_HOST) &&
d1024 4
a1027 1
		if (mtu < rt->rt_ifp->if_mtu) {
d1031 1
d1033 1
a1033 2
	if (rt)
		rtfree(rt);
d1555 1
a1555 1
	struct ifnet *ifp;	/* my outgoing interface */
d1575 4
a1578 1
	ifp = rt->rt_ifp;
d1804 1
d1808 1
@


1.176
log
@Rename rtrequest1() to rtrequest().
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.175 2015/10/28 12:14:25 florian Exp $	*/
a589 1
			nip6 = mtod(n, struct ip6_hdr *);
@


1.175
log
@Remove linkmtu and maxmtu from struct nd_ifinfo. IN6_LINKMTU can now
die and ifp->if_mtu is the one true mtu.
Suggested by and OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.174 2015/10/22 15:37:47 bluhm Exp $	*/
d1925 1
a1925 1
		error = rtrequest1(RTM_ADD, &info, rt->rt_priority, &nrt,
@


1.174
log
@Inspired by satosin(), use inline functions to convert sockaddr dl.
Instead of casts they check wether the incoming object has the
expected type.  So introduce satosdl() and sdltosa() in the kernel.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.173 2015/10/19 12:11:28 mpi Exp $	*/
d1025 1
a1025 1
		if (mtu < IN6_LINKMTU(rt->rt_ifp)) {
@


1.173
log
@Stop checking for RTF_UP directly, call rtisvalid(9) instead.

While here add two missing ``rtableid'' checks in in6_selectsrc().

ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.172 2015/09/18 14:26:22 mpi Exp $	*/
d1696 1
a1696 1
		    (sdl = (struct sockaddr_dl *)nrt->rt_gateway) &&
@


1.172
log
@Do not manually decrement rt's refcounter in nd6_lookup() and let the
callers rtfree(9) it.

Inputs and ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.171 2015/09/11 22:00:36 claudio Exp $	*/
d1571 1
a1571 1
	if (!m0 || !rt || !(rt->rt_flags & RTF_UP) || !(ifp = rt->rt_ifp))
d1573 1
@


1.171
log
@Bad whatever, that if_put() should not be there. Found the hard way by deraadt@@
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.170 2015/09/11 19:42:45 dlg Exp $	*/
d1680 1
a1680 1
		struct rtentry *rt_nexthop = NULL;
a1685 3
		rt_nexthop = nd6_lookup(nexthop, 0, ifp, ifp->if_rdomain);
		if (!rt_nexthop)
			goto nolladdropt;
d1691 5
a1695 4
		if (!(rt_nexthop->rt_flags & RTF_GATEWAY) &&
		    (rt_nexthop->rt_flags & RTF_LLINFO) &&
		    (rt_nexthop->rt_gateway->sa_family == AF_LINK) &&
		    (sdl = (struct sockaddr_dl *)rt_nexthop->rt_gateway) &&
d1704 1
@


1.170
log
@if_put after if_get when IP6_EXTHDR_GET fails in icmp6_input.

claudio missed this one cos he was drunk while he was supposed to
be fixing this file.

ok claudio@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.169 2015/09/11 15:12:29 bluhm Exp $	*/
a407 1
		if_put(ifp);
@


1.169
log
@When pf modifies a TCP packet, it sets the M_TCP_CSUM_OUT flag in
the mbuf packet header.  If the packet and is later dropped in
ip6_forward(), the TCP mbuf is copied and passed to icmp6_error().
IPv6 uses m_copym() and M_PREPEND() which preserve the packet header.
The inherited M_TCP_CSUM_OUT flag generates ICMP6 packets with an
incorrect checksum.  So reset the csum_flags when packets are
generated by icmp6_reflect() or icmp6_redirect_output().

IPv4 does m_copydata() into a fresh mbuf.  There m_inithdr() clears
the packet header, so the problem does not occur.  But setting the
csum_flags explicitly also makes sense for icmp_send().  Do not or
M_ICMP_CSUM_OUT to a value that is 0 because of some function calls
before.

OK mpi@@ lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.168 2015/09/11 09:14:06 claudio Exp $	*/
d408 1
@


1.168
log
@if_put for icmp6. Again we cheat a bit with the hop limit to simplify the code.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.167 2015/09/11 08:17:06 claudio Exp $	*/
d1286 1
a1286 1
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
d1792 1
a1792 1
	m->m_pkthdr.csum_flags |= M_ICMP_CSUM_OUT;
@


1.167
log
@Kill yet another argument to functions in IPv6. This time ip6_output's
ifpp - XXX: just for statistics
ifpp is always NULL in all callers so that statistic confirms ifpp is
dying
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.166 2015/09/11 07:42:35 claudio Exp $	*/
d380 1
d382 1
a390 4
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL)
		goto freeit;

d440 4
d449 2
d727 1
a727 1
		    "icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%d)\n",
d731 1
a731 1
		    ifp ? ifp->if_index : 0));
d1283 1
a1283 5
	if (if_get(m->m_pkthdr.ph_ifidx) != NULL) {
		/* XXX: This may not be the outgoing interface */
		ip6->ip6_hlim = ND_IFINFO(if_get(m->m_pkthdr.ph_ifidx))->chlim;
	} else
		ip6->ip6_hlim = ip6_defhlim;
d1365 1
d1540 1
d1545 1
@


1.166
log
@in6_embedscope() needs to lose some weight. Remove the last argument.
In all but two calls NULL is passed and in the other 2 cases the ifp
is only used to maybe feed it to in6_selecthlim() to select the hoplimit
for the link. Since in6_embedscope() only works on link-local addresses
it does not matter what hop limit we select since the destination is
directly reachable.
OK florian@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.165 2015/09/10 17:52:05 claudio Exp $	*/
d1303 1
a1303 1
	ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, NULL, NULL);
d1792 1
a1792 1
	ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL);
@


1.165
log
@It is time to put inet6 on a diet. Use the flensing knife and cut out
the 3rd argument of in6_recoverscope() and make it return void.
OK dlg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.164 2015/09/09 15:51:40 mpi Exp $	*/
d911 1
a911 2
		if (in6_embedscope(&icmp6dst.sin6_addr, &icmp6dst,
				   NULL, NULL)) {
d928 1
a928 2
		if (in6_embedscope(&icmp6src.sin6_addr, &icmp6src,
				   NULL, NULL)) {
d1218 1
a1218 1
	in6_embedscope(&ip6->ip6_dst, &sa6_src, NULL, NULL);
d1224 1
a1224 1
	in6_embedscope(&t, &sa6_dst, NULL, NULL);
@


1.164
log
@Kill icmp6_ifstat_inc() and associated per-ifp storage.

The SIOCGIFSTAT_ICMP6 is no longer supported.

ok dlg@@, mikeb@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.163 2015/07/28 12:22:07 bluhm Exp $	*/
d1064 1
a1064 1
	(void)in6_recoverscope(&rip6src, &ip6->ip6_src, NULL);
d1219 1
a1219 1
	in6_recoverscope(&sa6_src, &ip6->ip6_dst, if_get(m->m_pkthdr.ph_ifidx));
d1225 1
a1225 1
	in6_recoverscope(&sa6_dst, &t, if_get(m->m_pkthdr.ph_ifidx));
@


1.163
log
@Implement pf divert-reply for raw sockets.  Note that an empty
divert->addr means that the rule has a divert-reply option.  With
divert-to the divert->addr is always set.  The divert-reply rules
should compare the original packet with the socket addresses.  So
skip the step that compares the inp->inp_laddr with the empty
divert->addr.
OK mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.162 2015/07/15 22:16:42 deraadt Exp $	*/
a392 2
	icmp6_ifstat_inc(ifp, ifs6_in_msg);

a400 1
		icmp6_ifstat_inc(ifp, ifs6_in_error);
a419 1
		icmp6_ifstat_inc(ifp, ifs6_in_error);
a451 1
		icmp6_ifstat_inc(ifp, ifs6_in_dstunreach);
a456 1
			icmp6_ifstat_inc(ifp, ifs6_in_adminprohib);
a480 2
		icmp6_ifstat_inc(ifp, ifs6_in_pkttoobig);

a490 1
		icmp6_ifstat_inc(ifp, ifs6_in_timeexceed);
a503 1
		icmp6_ifstat_inc(ifp, ifs6_in_paramprob);
a517 1
		icmp6_ifstat_inc(ifp, ifs6_in_echo);
a602 1
		icmp6_ifstat_inc(ifp, ifs6_in_echoreply);
a610 4
		if (icmp6->icmp6_type == MLD_LISTENER_QUERY) /* XXX: ugly... */
			icmp6_ifstat_inc(ifp, ifs6_in_mldquery);
		else
			icmp6_ifstat_inc(ifp, ifs6_in_mldreport);
a621 1
		icmp6_ifstat_inc(ifp, ifs6_in_mlddone);
a638 1
		icmp6_ifstat_inc(ifp, ifs6_in_routersolicit);
a653 1
		icmp6_ifstat_inc(ifp, ifs6_in_routeradvert);
a668 1
		icmp6_ifstat_inc(ifp, ifs6_in_neighborsolicit);
a683 1
		icmp6_ifstat_inc(ifp, ifs6_in_neighboradvert);
a698 1
		icmp6_ifstat_inc(ifp, ifs6_in_redirect);
a1154 1
	struct ifnet *outif = NULL;
d1305 1
a1305 7
	if (ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, &outif, NULL) != 0 &&
	    outif)
		icmp6_ifstat_inc(outif, ifs6_out_error);

	if (outif)
		icmp6_ifoutstat_inc(outif, type, code);

d1794 1
a1794 2
	if (ip6_output(m, NULL, NULL, 0, NULL, NULL, NULL) != 0)
		icmp6_ifstat_inc(ifp, ifs6_out_error);
a1795 2
	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_redirect);
@


1.162
log
@m_freem() can handle NULL, do not check for this condition beforehands.
ok stsp mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.161 2015/07/08 08:48:34 mpi Exp $	*/
d1100 2
d1106 1
@


1.161
log
@Pass an interface index instead of a pointer to in6_addr2scopeid().

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.160 2015/06/30 15:30:17 mpi Exp $	*/
d1126 1
a1126 2
					if (opts)
						m_freem(opts);
d1142 1
a1142 2
			if (opts)
				m_freem(opts);
d1795 2
a1796 4
	if (m0) {
		m_freem(m0);
		m0 = NULL;
	}
d1830 2
a1831 4
	if (m)
		m_freem(m);
	if (m0)
		m_freem(m0);
d1846 1
a1846 1
		if (op == PRCO_SETOPT && m)
d1877 1
a1877 2
		if (m)
			m_freem(m);
@


1.160
log
@Get rid of the undocumented & temporary* m_copy() macro added for
compatibility with 4.3BSD in September 1989.

*Pick your own definition for "temporary".

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.159 2015/06/16 11:09:40 mpi Exp $	*/
d931 2
a932 2
		icmp6dst.sin6_scope_id = in6_addr2scopeid(
		    if_get(m->m_pkthdr.ph_ifidx), &icmp6dst.sin6_addr);
d949 2
a950 2
		icmp6src.sin6_scope_id = in6_addr2scopeid(
		    if_get(m->m_pkthdr.ph_ifidx), &icmp6src.sin6_addr);
d1037 1
a1037 1
	sin6.sin6_scope_id = in6_addr2scopeid(if_get(m->m_pkthdr.ph_ifidx),
d1613 1
a1613 1
	src_sa.sin6_scope_id = in6_addr2scopeid(ifp, &sip6->ip6_src);
@


1.159
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.158 2015/06/08 22:19:27 krw Exp $	*/
d1117 1
a1117 1
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
@


1.158
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.157 2015/03/04 11:10:55 mpi Exp $	*/
d357 2
a358 2
	 * clear m->m_pkthdr.rcvif for safety, we should have enough scope
	 * information in ip header (nip6).
d360 1
a360 1
	m->m_pkthdr.rcvif = NULL;
d389 3
a391 1
	ifp = m->m_pkthdr.rcvif;
d931 2
a932 2
		icmp6dst.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
							  &icmp6dst.sin6_addr);
d949 2
a950 2
		icmp6src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
							  &icmp6src.sin6_addr);
d1035 1
a1035 2
		sin6.sin6_addr.s6_addr16[1] =
		    htons(m->m_pkthdr.rcvif->if_index);
d1037 1
a1037 1
	sin6.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
d1241 1
a1241 1
	in6_recoverscope(&sa6_src, &ip6->ip6_dst, m->m_pkthdr.rcvif);
d1247 1
a1247 1
	in6_recoverscope(&sa6_dst, &t, m->m_pkthdr.rcvif);
d1303 1
a1303 1
	if (m->m_pkthdr.rcvif) {
d1305 1
a1305 1
		ip6->ip6_hlim = ND_IFINFO(m->m_pkthdr.rcvif)->chlim;
d1367 1
a1367 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d1382 2
a1383 1
	if (!ifp)
d1636 1
a1636 1
	m->m_pkthdr.rcvif = NULL;
@


1.157
log
@Do not check if the interface index matches the scope when all we want
is to clear the damn embedded scope.

At this point the receiving interface should not matter and will in the
future be cleared to prevent such layer violations.

This prevent exporting addresses with embedded scope to userland.

Found the hardway by and ok florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.156 2015/02/05 03:01:03 mpi Exp $	*/
d1348 1
a1348 1
icmp6_redirect_diag(struct in6_addr *src6, struct in6_addr *dst6, 
d1842 1
a1842 1
icmp6_ctloutput(int op, struct socket *so, int level, int optname, 
d1943 1
a1943 1
	if (rt == 0)
d2015 1
a2015 1
icmp6_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, 
@


1.156
log
@Convert various rtrequest1(RTM_DELETE,...) calls to rtdeletemsg(9).

This unify some code and notify userland for free.

blambert@@ agrees, ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.155 2015/01/28 22:10:13 mpi Exp $	*/
d1085 1
a1085 1
	(void)in6_recoverscope(&rip6src, &ip6->ip6_src, m->m_pkthdr.rcvif);
@


1.155
log
@Revert rtdeletemsg conversion.  It was not ok'd, I misunderstood bluhm@@'s
email.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.154 2015/01/26 11:38:37 mpi Exp $	*/
a1985 1
		struct rt_addrinfo info;
a1987 6
		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);

d1989 1
a1989 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
a2003 1
		struct rt_addrinfo info;
a2005 6
		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);

d2007 1
a2007 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
@


1.154
log
@Call rtdeletemsg(9) instead of rerolling its code.  As a bonus you'll
get userland notification for free.

ok blambert@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.153 2015/01/19 13:53:55 mpi Exp $	*/
d1986 1
d1989 6
d1996 2
a1997 1
		rtdeletemsg(rt, r->rtt_tableid);
d2012 1
d2015 6
d2022 2
a2023 1
		rtdeletemsg(rt, r->rtt_tableid);
@


1.153
log
@<netinet6/in6_ifattach.h> is not needed here.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.152 2014/12/22 11:05:53 mpi Exp $	*/
a1985 1
		struct rt_addrinfo info;
a1987 6
		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);

d1989 1
a1989 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
a2003 1
		struct rt_addrinfo info;
a2005 6
		bzero(&info, sizeof(info));
		info.rti_flags = rt->rt_flags;
		info.rti_info[RTAX_DST] = rt_key(rt);
		info.rti_info[RTAX_GATEWAY] = rt->rt_gateway;
		info.rti_info[RTAX_NETMASK] = rt_mask(rt);

d2007 1
a2007 2
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL,
		    r->rtt_tableid);
@


1.152
log
@Make sure rtrequest1(9) is called under splsoftnet().
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.151 2014/12/05 15:50:04 mpi Exp $	*/
a94 1
#include <netinet6/in6_ifattach.h>
@


1.151
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.150 2014/11/01 21:40:39 mpi Exp $	*/
d1951 1
d1957 2
d1961 1
d1988 1
d1995 2
d1999 1
d2014 1
d2021 2
d2025 1
@


1.150
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.149 2014/10/14 09:52:26 mpi Exp $	*/
d81 1
@


1.149
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.148 2014/08/27 14:04:16 florian Exp $	*/
d1435 1
a1435 1
	rt = rtalloc1(sin6tosa(&sin6), 0, m->m_pkthdr.ph_rtableid);
d1942 1
a1942 1
	rt = rtalloc1(dst, RT_REPORT, rdomain);
@


1.148
log
@Nuke net.inet6.icmp6.rediraccept and allow redirects on interfaces
with autoconf enabled.
If one is doing SLAAC one does already trust link local icmp6 so the
policy for icmp6 redirects should be the same.
pointed out by & OK bluhm@@; OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.147 2014/07/22 11:06:10 mpi Exp $	*/
d1049 2
a1050 3
	if (rt) { /* XXX: need braces to avoid conflict with else in RTFREE. */
		RTFREE(rt);
	}
d1283 2
a1284 3
		if (ro.ro_rt) { /* XXX: see comments in icmp6_mtudisc_update */
			RTFREE(ro.ro_rt); /* XXX: we could use this */
		}
d1443 1
a1443 1
			RTFREE(rt);
d1455 1
a1455 1
			RTFREE(rt);
d1465 1
a1465 1
	RTFREE(rt);
@


1.147
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.146 2014/07/11 12:20:26 benno Exp $	*/
d1389 1
a1389 1
	if (!icmp6_rediraccept)
@


1.146
log
@Remove rfc 4620 Node Information Query support (from the kernel).

ok henning@@ stu@@, Yay! weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.145 2014/07/08 17:19:26 deraadt Exp $	*/
a85 1
#include <netinet/in_systm.h>
@


1.145
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.144 2014/05/07 08:09:33 mpi Exp $	*/
a111 1
extern int icmp6_nodeinfo;
a142 7
struct mbuf *ni6_input(struct mbuf *, int);
struct mbuf *ni6_nametodns(const char *, int, int);
int	ni6_dnsmatch(const char *, int, const char *, int);
int	ni6_addrs(struct icmp6_nodeinfo *, struct mbuf *, struct ifnet **,
	    char *);
int	ni6_store_addrs(struct icmp6_nodeinfo *, struct icmp6_nodeinfo *,
	    struct ifnet *, int);
d649 1
a649 76
	    {
		enum { WRU, FQDN } mode;

		if (!icmp6_nodeinfo)
			break;

		if (icmp6len == sizeof(struct icmp6_hdr) + 4)
			mode = WRU;
		else if (icmp6len >= sizeof(struct icmp6_nodeinfo))
			mode = FQDN;
		else
			goto badlen;

		if (mode == FQDN) {
			n = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
			if (n)
				n = ni6_input(n, off);
			/* XXX meaningless if n == NULL */
			noff = sizeof(struct ip6_hdr);
		} else {
			u_char *p;
			int maxlen, maxhlen;

			if ((icmp6_nodeinfo & 1) == 0)
				break;

			if (code != 0)
				goto badcode;
			maxlen = sizeof(*nip6) + sizeof(*nicmp6) + 4;
			if (maxlen >= MCLBYTES) {
				/* Give up remote */
				break;
			}
			MGETHDR(n, M_DONTWAIT, m->m_type);
			if (n && maxlen > MHLEN) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
			if (n == NULL) {
				/* Give up remote */
				break;
			}
			n->m_pkthdr.rcvif = NULL;
			n->m_len = 0;
			maxhlen = M_TRAILINGSPACE(n) - maxlen;
			if (maxhlen > hostnamelen)
				maxhlen = hostnamelen;
			/*
			 * Copy IPv6 and ICMPv6 only.
			 */
			nip6 = mtod(n, struct ip6_hdr *);
			bcopy(ip6, nip6, sizeof(struct ip6_hdr));
			nicmp6 = (struct icmp6_hdr *)(nip6 + 1);
			bcopy(icmp6, nicmp6, sizeof(struct icmp6_hdr));
			p = (u_char *)(nicmp6 + 1);
			bzero(p, 4);
			bcopy(hostname, p + 4, maxhlen); /* meaningless TTL */
			noff = sizeof(struct ip6_hdr);
			if (m_dup_pkthdr(n, m, M_DONTWAIT)) { /* for rcvif */
				m_freem(n);
				break;
			}
			n->m_pkthdr.len = n->m_len = sizeof(struct ip6_hdr) +
				sizeof(struct icmp6_hdr) + 4 + maxhlen;
			nicmp6->icmp6_type = ICMP6_WRUREPLY;
			nicmp6->icmp6_code = 0;
		}
#undef hostnamelen
		if (n) {
			icmp6stat.icp6s_reflect++;
			icmp6stat.icp6s_outhist[ICMP6_WRUREPLY]++;
			icmp6_reflect(n, noff);
		}
a650 2
	    }

a651 2
		if (code != 0)
			goto badcode;
a1060 708
}

/*
 * Process a Node Information Query packet, based on
 * draft-ietf-ipngwg-icmp-name-lookups-07.
 *
 * Spec incompatibilities:
 * - IPv6 Subject address handling
 * - IPv4 Subject address handling support missing
 * - Proxy reply (answer even if it's not for me)
 * - joins NI group address at in6_ifattach() time only, does not cope
 *   with hostname changes by sethostname(3)
 */
struct mbuf *
ni6_input(struct mbuf *m, int off)
{
	struct icmp6_nodeinfo *ni6, *nni6;
	struct mbuf *n = NULL;
	u_int16_t qtype;
	int subjlen;
	int replylen = sizeof(struct ip6_hdr) + sizeof(struct icmp6_nodeinfo);
	struct ni_reply_fqdn *fqdn;
	int addrs;		/* for NI_QTYPE_NODEADDR */
	struct ifnet *ifp = NULL; /* for NI_QTYPE_NODEADDR */
	struct sockaddr_in6 sin6; /* double meaning; ip6_dst and subjectaddr */
	struct ip6_hdr *ip6;
	int oldfqdn = 0;	/* if 1, return pascal string (03 draft) */
	char *subj = NULL;

	ip6 = mtod(m, struct ip6_hdr *);
	IP6_EXTHDR_GET(ni6, struct icmp6_nodeinfo *, m, off, sizeof(*ni6));
	if (ni6 == NULL) {
		/* m is already reclaimed */
		return NULL;
	}

	/*
	 * Validate IPv6 destination address.
	 *
	 * The Responder must discard the Query without further processing
	 * unless it is one of the Responder's unicast or anycast addresses, or
	 * a link-local scope multicast address which the Responder has joined.
	 * [icmp-name-lookups-07, Section 4.]
	 */
	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	bcopy(&ip6->ip6_dst, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
	/* XXX scopeid */
	if (ifa_ifwithaddr(sin6tosa(&sin6), m->m_pkthdr.ph_rtableid))
		; /* unicast/anycast, fine */
	else if (IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr))
		; /* link-local multicast, fine */
	else
		goto bad;

	/* validate query Subject field. */
	qtype = ntohs(ni6->ni_qtype);
	subjlen = m->m_pkthdr.len - off - sizeof(struct icmp6_nodeinfo);
	switch (qtype) {
	case NI_QTYPE_NOOP:
	case NI_QTYPE_SUPTYPES:
		/* 07 draft */
		if (ni6->ni_code == ICMP6_NI_SUBJ_FQDN && subjlen == 0)
			break;
		/* FALLTHROUGH */
	case NI_QTYPE_FQDN:
	case NI_QTYPE_NODEADDR:
		switch (ni6->ni_code) {
		case ICMP6_NI_SUBJ_IPV6:
#if ICMP6_NI_SUBJ_IPV6 != 0
		case 0:
#endif
			/*
			 * backward compatibility - try to accept 03 draft
			 * format, where no Subject is present.
			 */
			if (qtype == NI_QTYPE_FQDN && ni6->ni_code == 0 &&
			    subjlen == 0) {
				oldfqdn++;
				break;
			}
#if ICMP6_NI_SUBJ_IPV6 != 0
			if (ni6->ni_code != ICMP6_NI_SUBJ_IPV6)
				goto bad;
#endif

			if (subjlen != sizeof(sin6.sin6_addr))
				goto bad;

			/*
			 * Validate Subject address.
			 *
			 * Not sure what exactly "address belongs to the node"
			 * means in the spec, is it just unicast, or what?
			 *
			 * At this moment we consider Subject address as
			 * "belong to the node" if the Subject address equals
			 * to the IPv6 destination address; validation for
			 * IPv6 destination address should have done enough
			 * check for us.
			 *
			 * We do not do proxy at this moment.
			 */
			/* m_pulldown instead of copy? */
			m_copydata(m, off + sizeof(struct icmp6_nodeinfo),
			    subjlen, (caddr_t)&sin6.sin6_addr);
			/* XXX kame scope hack */
			if (IN6_IS_SCOPE_EMBED(&sin6.sin6_addr)) {
				if ((m->m_flags & M_PKTHDR) != 0 &&
				    m->m_pkthdr.rcvif) {
					sin6.sin6_addr.s6_addr16[1] =
					    htons(m->m_pkthdr.rcvif->if_index);
				}
			}
			subj = (char *)&sin6;
			if (IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &sin6.sin6_addr))
				break;

			/*
			 * XXX if we are to allow other cases, we should really
			 * be careful about scope here.
			 * basically, we should disallow queries toward IPv6
			 * destination X with subject Y, if scope(X) > scope(Y).
			 * if we allow scope(X) > scope(Y), it will result in
			 * information leakage across scope boundary.
			 */
			goto bad;

		case ICMP6_NI_SUBJ_FQDN:
			/*
			 * Validate Subject name with gethostname(3).
			 *
			 * The behavior may need some debate, since:
			 * - we are not sure if the node has FQDN as
			 *   hostname (returned by gethostname(3)).
			 * - the code does wildcard match for truncated names.
			 *   however, we are not sure if we want to perform
			 *   wildcard match, if gethostname(3) side has
			 *   truncated hostname.
			 */
			n = ni6_nametodns(hostname, hostnamelen, 0);
			if (!n || n->m_next || n->m_len == 0)
				goto bad;
			IP6_EXTHDR_GET(subj, char *, m,
			    off + sizeof(struct icmp6_nodeinfo), subjlen);
			if (subj == NULL)
				goto bad;
			if (!ni6_dnsmatch(subj, subjlen, mtod(n, const char *),
					n->m_len)) {
				goto bad;
			}
			m_freem(n);
			n = NULL;
			break;

		case ICMP6_NI_SUBJ_IPV4:	/* XXX: to be implemented? */
		default:
			goto bad;
		}
		break;
	}

	/* refuse based on configuration.  XXX ICMP6_NI_REFUSED? */
	switch (qtype) {
	case NI_QTYPE_FQDN:
		if ((icmp6_nodeinfo & 1) == 0)
			goto bad;
		break;
	case NI_QTYPE_NODEADDR:
		if ((icmp6_nodeinfo & 2) == 0)
			goto bad;
		break;
	}

	/* guess reply length */
	switch (qtype) {
	case NI_QTYPE_NOOP:
		break;		/* no reply data */
	case NI_QTYPE_SUPTYPES:
		replylen += sizeof(u_int32_t);
		break;
	case NI_QTYPE_FQDN:
		/* XXX will append an mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		break;
	case NI_QTYPE_NODEADDR:
		addrs = ni6_addrs(ni6, m, &ifp, subj);
		if ((replylen += addrs * (sizeof(struct in6_addr) +
					  sizeof(u_int32_t))) > MCLBYTES)
			replylen = MCLBYTES; /* XXX: will truncate pkt later */
		break;
	default:
		/*
		 * XXX: We must return a reply with the ICMP6 code
		 * `unknown Qtype' in this case.  However we regard the case
		 * as an FQDN query for backward compatibility.
		 * Older versions set a random value to this field,
		 * so it rarely varies in the defined qtypes.
		 * But the mechanism is not reliable...
		 * maybe we should obsolete older versions.
		 */
		qtype = NI_QTYPE_FQDN;
		/* XXX will append an mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		oldfqdn++;
		break;
	}

	/* allocate an mbuf to reply. */
	MGETHDR(n, M_DONTWAIT, m->m_type);
	if (n == NULL) {
		m_freem(m);
		return (NULL);
	}

	if (m_dup_pkthdr(n, m, M_DONTWAIT)) /* just for rcvif */
		goto bad;

	if (replylen > MHLEN) {
		if (replylen > MCLBYTES) {
			/*
			 * XXX: should we try to allocate more? But MCLBYTES
			 * is probably much larger than IPV6_MMTU...
			 */
			goto bad;
		}
		MCLGET(n, M_DONTWAIT);
		if ((n->m_flags & M_EXT) == 0) {
			goto bad;
		}
	}
	n->m_pkthdr.len = n->m_len = replylen;

	/* copy mbuf header and IPv6 + Node Information base headers */
	bcopy(mtod(m, caddr_t), mtod(n, caddr_t), sizeof(struct ip6_hdr));
	nni6 = (struct icmp6_nodeinfo *)(mtod(n, struct ip6_hdr *) + 1);
	bcopy((caddr_t)ni6, (caddr_t)nni6, sizeof(struct icmp6_nodeinfo));

	/* qtype dependent procedure */
	switch (qtype) {
	case NI_QTYPE_NOOP:
		nni6->ni_code = ICMP6_NI_SUCCESS;
		nni6->ni_flags = 0;
		break;
	case NI_QTYPE_SUPTYPES:
	{
		u_int32_t v;
		nni6->ni_code = ICMP6_NI_SUCCESS;
		nni6->ni_flags = htons(0x0000);	/* raw bitmap */
		/* supports NOOP, SUPTYPES, FQDN, and NODEADDR */
		v = (u_int32_t)htonl(0x0000000f);
		bcopy(&v, nni6 + 1, sizeof(u_int32_t));
		break;
	}
	case NI_QTYPE_FQDN:
		nni6->ni_code = ICMP6_NI_SUCCESS;
		fqdn = (struct ni_reply_fqdn *)(mtod(n, caddr_t) +
						sizeof(struct ip6_hdr) +
						sizeof(struct icmp6_nodeinfo));
		nni6->ni_flags = 0; /* XXX: meaningless TTL */
		fqdn->ni_fqdn_ttl = 0;	/* ditto. */
		/*
		 * XXX do we really have FQDN in variable "hostname"?
		 */
		n->m_next = ni6_nametodns(hostname, hostnamelen, oldfqdn);
		if (n->m_next == NULL)
			goto bad;
		/* XXX we assume that n->m_next is not a chain */
		if (n->m_next->m_next != NULL)
			goto bad;
		n->m_pkthdr.len += n->m_next->m_len;
		break;
	case NI_QTYPE_NODEADDR:
	{
		int lenlim, copied;

		nni6->ni_code = ICMP6_NI_SUCCESS;
		n->m_pkthdr.len = n->m_len =
		    sizeof(struct ip6_hdr) + sizeof(struct icmp6_nodeinfo);
		lenlim = M_TRAILINGSPACE(n);
		copied = ni6_store_addrs(ni6, nni6, ifp, lenlim);
		/* XXX: reset mbuf length */
		n->m_pkthdr.len = n->m_len = sizeof(struct ip6_hdr) +
			sizeof(struct icmp6_nodeinfo) + copied;
		break;
	}
	default:
		break;		/* XXX impossible! */
	}

	nni6->ni_type = ICMP6_NI_REPLY;
	m_freem(m);
	return (n);

  bad:
	m_freem(m);
	if (n)
		m_freem(n);
	return (NULL);
}
#undef hostnamelen

#define isupper(x) ('A' <= (x) && (x) <= 'Z')
#define isalpha(x) (('A' <= (x) && (x) <= 'Z') || ('a' <= (x) && (x) <= 'z'))
#define isalnum(x) (isalpha(x) || ('0' <= (x) && (x) <= '9'))
#define tolower(x) (isupper(x) ? (x) + 'a' - 'A' : (x))

/*
 * make a mbuf with DNS-encoded string.  no compression support.
 *
 * XXX names with less than 2 dots (like "foo" or "foo.section") will be
 * treated as truncated name (two \0 at the end).  this is a wild guess.
 *
 * old - return pascal string if non-zero
 */
struct mbuf *
ni6_nametodns(const char *name, int namelen, int old)
{
	struct mbuf *m;
	char *cp, *ep;
	const char *p, *q;
	int i, len, nterm;

	if (old)
		len = namelen + 1;
	else
		len = MCLBYTES;

	/* because MAXHOSTNAMELEN is usually 256, we use cluster mbuf */
	MGET(m, M_DONTWAIT, MT_DATA);
	if (m && len > MLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0)
			goto fail;
	}
	if (!m)
		goto fail;
	m->m_next = NULL;

	if (old) {
		m->m_len = len;
		*mtod(m, char *) = namelen;
		bcopy(name, mtod(m, char *) + 1, namelen);
		return m;
	} else {
		m->m_len = 0;
		cp = mtod(m, char *);
		ep = mtod(m, char *) + M_TRAILINGSPACE(m);

		/* if not certain about my name, return empty buffer */
		if (namelen == 0)
			return m;

		/*
		 * guess if it looks like shortened hostname, or FQDN.
		 * shortened hostname needs two trailing "\0".
		 */
		i = 0;
		for (p = name; p < name + namelen; p++) {
			if (*p && *p == '.')
				i++;
		}
		if (i < 2)
			nterm = 2;
		else
			nterm = 1;

		p = name;
		while (cp < ep && p < name + namelen) {
			i = 0;
			for (q = p; q < name + namelen && *q && *q != '.'; q++)
				i++;
			/* result does not fit into mbuf */
			if (cp + i + 1 >= ep)
				goto fail;
			/*
			 * DNS label length restriction, RFC1035 page 8.
			 * "i == 0" case is included here to avoid returning
			 * 0-length label on "foo..bar".
			 */
			if (i <= 0 || i >= 64)
				goto fail;
			*cp++ = i;
			if (!isalnum(p[0]) || !isalnum(p[i - 1]))
				goto fail;
			while (i > 0) {
				if (!isalnum(*p) && *p != '-')
					goto fail;
				if (isupper(*p)) {
					*cp++ = tolower(*p);
					p++;
				} else
					*cp++ = *p++;
				i--;
			}
			p = q;
			if (p < name + namelen && *p == '.')
				p++;
		}
		/* termination */
		if (cp + nterm >= ep)
			goto fail;
		while (nterm-- > 0)
			*cp++ = '\0';
		m->m_len = cp - mtod(m, char *);
		return m;
	}

	panic("should not reach here");
	/* NOTREACHED */

 fail:
	if (m)
		m_freem(m);
	return NULL;
}

/*
 * check if two DNS-encoded string matches.  takes care of truncated
 * form (with \0\0 at the end).  no compression support.
 * XXX upper/lowercase match (see RFC2065)
 */
int
ni6_dnsmatch(const char *a, int alen, const char *b, int blen)
{
	const char *a0, *b0;
	int l;

	/* simplest case - need validation? */
	if (alen == blen && bcmp(a, b, alen) == 0)
		return 1;

	a0 = a;
	b0 = b;

	/* termination is mandatory */
	if (alen < 2 || blen < 2)
		return 0;
	if (a0[alen - 1] != '\0' || b0[blen - 1] != '\0')
		return 0;
	alen--;
	blen--;

	while (a - a0 < alen && b - b0 < blen) {
		if (a - a0 + 1 > alen || b - b0 + 1 > blen)
			return 0;

		if ((signed char)a[0] < 0 || (signed char)b[0] < 0)
			return 0;
		/* we don't support compression yet */
		if (a[0] >= 64 || b[0] >= 64)
			return 0;

		/* truncated case */
		if (a[0] == 0 && a - a0 == alen - 1)
			return 1;
		if (b[0] == 0 && b - b0 == blen - 1)
			return 1;
		if (a[0] == 0 || b[0] == 0)
			return 0;

		if (a[0] != b[0])
			return 0;
		l = a[0];
		if (a - a0 + 1 + l > alen || b - b0 + 1 + l > blen)
			return 0;
		if (bcmp(a + 1, b + 1, l) != 0)
			return 0;

		a += 1 + l;
		b += 1 + l;
	}

	if (a - a0 == alen && b - b0 == blen)
		return 1;
	else
		return 0;
}

/*
 * calculate the number of addresses to be returned in the node info reply.
 */
int
ni6_addrs(struct icmp6_nodeinfo *ni6, struct mbuf *m, struct ifnet **ifpp, 
    char *subj)
{
	struct ifnet *ifp;
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa;
	struct sockaddr_in6 *subj_ip6 = NULL; /* XXX pedant */
	int addrs = 0, addrsofif, iffound = 0;
	int niflags = ni6->ni_flags;

	if ((niflags & NI_NODEADDR_FLAG_ALL) == 0) {
		switch (ni6->ni_code) {
		case ICMP6_NI_SUBJ_IPV6:
			if (subj == NULL) /* must be impossible... */
				return (0);
			subj_ip6 = (struct sockaddr_in6 *)subj;
			break;
		default:
			/*
			 * XXX: we only support IPv6 subject address for
			 * this Qtype.
			 */
			return (0);
		}
	}

	TAILQ_FOREACH(ifp, &ifnet, if_list) {
		addrsofif = 0;
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			ia6 = ifatoia6(ifa);

			if ((niflags & NI_NODEADDR_FLAG_ALL) == 0 &&
			    IN6_ARE_ADDR_EQUAL(&subj_ip6->sin6_addr,
					       &ia6->ia_addr.sin6_addr))
				iffound = 1;

			/*
			 * IPv4-mapped addresses can only be returned by a
			 * Node Information proxy, since they represent
			 * addresses of IPv4-only nodes, which perforce do
			 * not implement this protocol.
			 * [icmp-name-lookups-07, Section 5.4]
			 * So we don't support NI_NODEADDR_FLAG_COMPAT in
			 * this function at this moment.
			 */

			/* What do we have to do about ::1? */
			switch (in6_addrscope(&ia6->ia_addr.sin6_addr)) {
			case __IPV6_ADDR_SCOPE_LINKLOCAL:
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL) == 0)
					continue;
				break;
			case __IPV6_ADDR_SCOPE_SITELOCAL:
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL) == 0)
					continue;
				break;
			case __IPV6_ADDR_SCOPE_GLOBAL:
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL) == 0)
					continue;
				break;
			default:
				continue;
			}

			/*
			 * check if anycast is okay.
			 * XXX: just experimental.  not in the spec.
			 */
			if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
			    (niflags & NI_NODEADDR_FLAG_ANYCAST) == 0)
				continue; /* we need only unicast addresses */

			addrsofif++; /* count the address */
		}
		if (iffound) {
			*ifpp = ifp;
			return (addrsofif);
		}

		addrs += addrsofif;
	}

	return (addrs);
}

int
ni6_store_addrs(struct icmp6_nodeinfo *ni6, struct icmp6_nodeinfo *nni6, 
    struct ifnet *ifp0, int resid)
{
	struct ifnet *ifp = ifp0 ? ifp0 : TAILQ_FIRST(&ifnet);
	struct in6_ifaddr *ia6;
	struct ifaddr *ifa;
	struct ifnet *ifp_dep = NULL;
	int copied = 0, allow_deprecated = 0;
	u_char *cp = (u_char *)(nni6 + 1);
	int niflags = ni6->ni_flags;
	u_int32_t ltime;

	if (ifp0 == NULL && !(niflags & NI_NODEADDR_FLAG_ALL))
		return (0);	/* needless to copy */

  again:

	for (; ifp != NULL; ifp = TAILQ_NEXT(ifp, if_list)) {
		TAILQ_FOREACH(ifa, &ifp->if_addrlist, ifa_list) {
			if (ifa->ifa_addr->sa_family != AF_INET6)
				continue;
			ia6 = ifatoia6(ifa);

			if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) != 0 &&
			    allow_deprecated == 0) {
				/*
				 * preferred address should be put before
				 * deprecated addresses.
				 */

				/* record the interface for later search */
				if (ifp_dep == NULL)
					ifp_dep = ifp;

				continue;
			}
			else if ((ia6->ia6_flags & IN6_IFF_DEPRECATED) == 0 &&
				 allow_deprecated != 0)
				continue; /* we now collect deprecated addrs */

			/* What do we have to do about ::1? */
			switch (in6_addrscope(&ia6->ia_addr.sin6_addr)) {
			case __IPV6_ADDR_SCOPE_LINKLOCAL:
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL) == 0)
					continue;
				break;
			case __IPV6_ADDR_SCOPE_SITELOCAL:
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL) == 0)
					continue;
				break;
			case __IPV6_ADDR_SCOPE_GLOBAL:
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL) == 0)
					continue;
				break;
			default:
				continue;
			}

			/*
			 * check if anycast is okay.
			 * XXX: just experimental.  not in the spec.
			 */
			if ((ia6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
			    (niflags & NI_NODEADDR_FLAG_ANYCAST) == 0)
				continue;

			/* now we can copy the address */
			if (resid < sizeof(struct in6_addr) +
			    sizeof(u_int32_t)) {
				/*
				 * We give up much more copy.
				 * Set the truncate flag and return.
				 */
				nni6->ni_flags |=
					NI_NODEADDR_FLAG_TRUNCATE;
				return (copied);
			}

			/*
			 * Set the TTL of the address.
			 * The TTL value should be one of the following
			 * according to the specification:
			 *
			 * 1. The remaining lifetime of a DHCP lease on the
			 *    address, or
			 * 2. The remaining Valid Lifetime of a prefix from
			 *    which the address was derived through Stateless
			 *    Autoconfiguration.
			 *
			 * Note that we currently do not support stateful
			 * address configuration by DHCPv6, so the former
			 * case can't happen.
			 *
			 * TTL must be 2^31 > TTL >= 0.
			 */
			if (ia6->ia6_lifetime.ia6t_expire == 0)
				ltime = ND6_INFINITE_LIFETIME;
			else {
				time_t diff = ia6->ia6_lifetime.ia6t_expire -
				    time_second;

				if (diff <= 0)
					ltime = 0;
				else if (diff >= ND6_INFINITE_LIFETIME)
					ltime = ND6_INFINITE_LIFETIME;
				else
					ltime = htonl((u_int32_t)diff);
			}

			bcopy(&ltime, cp, sizeof(u_int32_t));
			cp += sizeof(u_int32_t);

			/* copy the address itself */
			bcopy(&ia6->ia_addr.sin6_addr, cp,
			      sizeof(struct in6_addr));
			/* XXX: KAME link-local hack; remove ifindex */
			if (IN6_IS_ADDR_LINKLOCAL(&ia6->ia_addr.sin6_addr))
				((struct in6_addr *)cp)->s6_addr16[1] = 0;
			cp += sizeof(struct in6_addr);

			resid -= (sizeof(struct in6_addr) + sizeof(u_int32_t));
			copied += (sizeof(struct in6_addr) +
				   sizeof(u_int32_t));
		}
		if (ifp0)	/* we need search only on the specified IF */
			break;
	}

	if (allow_deprecated == 0 && ifp_dep != NULL) {
		ifp = ifp_dep;
		allow_deprecated = 1;

		goto again;
	}

	return (copied);
@


1.144
log
@Remove some m->m_pkthdr.rcvif dereference to help for upcoming
receiving pointer -> index conversion.  No functional change.

ok chrisz@@, jca@@, mikeb@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.143 2014/04/18 10:48:30 jca Exp $	*/
d71 1
a2812 3

#include <uvm/uvm_extern.h>
#include <sys/sysctl.h>
@


1.143
log
@Invert the signature logic of in{,6}_selectsrc, make them return the
error code and pass the resulting source address back to the caller
through a pointer, as suggested by chrisz.  This gives us more readable
code, and eases the deletion of useless checks in the callers' error path.
Add a bunch of "0 -> NULL" conversions, while here.
ok chrisz@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.142 2014/04/14 09:06:42 mpi Exp $	*/
d388 1
d397 3
a399 1
	icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_msg);
d409 1
a409 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
d429 1
a429 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
d452 1
a452 1
	if (m->m_pkthdr.rcvif->if_type == IFT_CARP &&
d462 1
a462 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_dstunreach);
d468 1
a468 1
			icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_adminprohib);
d493 1
a493 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_pkttoobig);
d505 1
a505 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_timeexceed);
d519 1
a519 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_paramprob);
d534 1
a534 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_echo);
d620 1
a620 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_echoreply);
d630 1
a630 1
			icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_mldquery);
d632 1
a632 1
			icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_mldreport);
d644 1
a644 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_mlddone);
d741 1
a741 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_routersolicit);
d757 1
a757 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_routeradvert);
d773 1
a773 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_neighborsolicit);
d789 1
a789 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_neighboradvert);
d805 1
a805 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_redirect);
d834 1
a834 1
		    m->m_pkthdr.rcvif ? m->m_pkthdr.rcvif->if_index : 0));
@


1.142
log
@"struct pkthdr" holds a routing table ID, not a routing domain one.
Avoid the confusion by using an appropriate name for the variable.

Note that since routing domain IDs are a subset of the set of routing
table IDs, the following idiom is correct:

	rtableid = rdomain

But to get the routing domain ID corresponding to a given routing table
ID, you must call rtable_l2(9).

claudio@@ likes it, ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.141 2014/03/21 10:44:42 mpi Exp $	*/
d1965 1
a1965 1
	struct in6_addr t, *src = 0;
d2063 2
a2064 2
	if (src == 0) {
		int e;
d2074 1
a2074 1
		src = in6_selectsrc(&sa6_src, NULL, NULL, &ro, NULL, &e,
d2079 1
a2079 1
		if (src == NULL) {
d2085 1
a2085 1
			    e));
@


1.141
log
@rt_timer* spring cleanup.

Rename and document rt_timer_count() into rt_timer_queue_count() to
be consistent with the other functions.  Remove unused argument from
rt_timer_queue_destroy(), clean the definitions and finally use the
same order in NAME and DESCRIPTION as requested by jmc@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.140 2014/01/24 12:20:22 naddy Exp $	*/
d1064 1
a1064 1
			    m->m_pkthdr.rdomain, &ip6cp);
d1123 1
a1123 1
	rt = icmp6_mtudisc_clone(sin6tosa(&sin6), m->m_pkthdr.rdomain);
d1143 1
a1143 1
		(*mc->mc_func)(&sin6, m->m_pkthdr.rdomain);
d1193 1
a1193 1
	if (ifa_ifwithaddr(sin6tosa(&sin6), m->m_pkthdr.rdomain))
d2075 1
a2075 1
		    m->m_pkthdr.rdomain);
d2229 1
a2229 1
	rt = rtalloc1(sin6tosa(&sin6), 0, m->m_pkthdr.rdomain);
d2341 1
a2341 1
		    &newrt, m->m_pkthdr.rdomain);
d2345 1
a2345 1
			    icmp6_redirect_timeout_q, m->m_pkthdr.rdomain);
@


1.140
log
@Instead of calculating the ICMPv6 checksum here, just set the flag that
is needed and the lower parts of the stack will take care of it.
ok henning@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.139 2014/01/13 23:03:52 bluhm Exp $	*/
d1096 1
a1096 1
	rtcount = rt_timer_count(icmp6_mtudisc_timeout_q);
d2320 1
a2320 1
		rtcount = rt_timer_count(icmp6_redirect_timeout_q);
@


1.139
log
@Call all local valiables of type struct in6_ifaddr "ia6".  This is
consistent with struct ifaddr "ifa" and struct in_ifaddr "ia".
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.138 2014/01/07 17:07:46 mikeb Exp $	*/
d2103 1
a2103 2
	icmp6->icmp6_cksum = in6_cksum(m, IPPROTO_ICMPV6,
					sizeof(struct ip6_hdr), plen);
d2613 1
a2613 2
	nd_rd->nd_rd_cksum
		= in6_cksum(m, IPPROTO_ICMPV6, sizeof(*ip6), ntohs(ip6->ip6_plen));
@


1.138
log
@Propagate an rdomain number to the nd6_lookup independently from
the ifp pointer which can be NULL.  This prevents a crash reported
by David Hill <dhill at mindcry ! org>.  OK bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.137 2013/12/20 02:04:08 krw Exp $	*/
d1632 1
a1632 1
	struct in6_ifaddr *ifa6;
d1659 1
a1659 1
			ifa6 = ifatoia6(ifa);
d1663 1
a1663 1
					       &ifa6->ia_addr.sin6_addr))
d1677 1
a1677 1
			switch (in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
d1698 1
a1698 1
			if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
d1720 1
a1720 1
	struct in6_ifaddr *ifa6;
d1737 1
a1737 1
			ifa6 = ifatoia6(ifa);
d1739 1
a1739 1
			if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) != 0 &&
d1752 1
a1752 1
			else if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) == 0 &&
d1757 1
a1757 1
			switch (in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
d1778 1
a1778 1
			if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
d1811 1
a1811 1
			if (ifa6->ia6_lifetime.ia6t_expire == 0)
d1814 1
a1814 1
				time_t diff = ifa6->ia6_lifetime.ia6t_expire -
d1829 1
a1829 1
			bcopy(&ifa6->ia_addr.sin6_addr, cp,
d1832 1
a1832 1
			if (IN6_IS_ADDR_LINKLOCAL(&ifa6->ia_addr.sin6_addr))
d1964 1
a1964 1
	struct in6_ifaddr *ia;
d2049 3
a2051 3
	TAILQ_FOREACH(ia, &in6_ifaddr, ia_list)
		if (IN6_ARE_ADDR_EQUAL(&t, &ia->ia_addr.sin6_addr) &&
		    (ia->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) == 0) {
d2055 1
a2055 1
	if (ia == NULL && IN6_IS_ADDR_LINKLOCAL(&t) && (m->m_flags & M_LOOP)) {
d2441 2
a2442 2
		struct in6_ifaddr *ia;
		if ((ia = in6ifa_ifpforlinklocal(ifp,
d2446 1
a2446 1
		ifp_ll6 = &ia->ia_addr.sin6_addr;
@


1.137
log
@Switch inpt_queue from CIRCLEQ to TAILQ. Thus ending use of CIRCLEQ
in the base. Ports fixes to follow shortly for the two ports (gkrellm
and net-snmp) affected.

ok zhuk@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.136 2013/11/11 09:15:35 mpi Exp $	*/
d2506 1
a2506 1
		rt_nexthop = nd6_lookup(nexthop, 0, ifp);
@


1.136
log
@Replace most of our formating functions to convert IPv4/6 addresses from
network to presentation format to inet_ntop().

The few remaining functions will be soon converted.

ok mikeb@@, deraadt@@ and moral support from henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.135 2013/10/24 11:20:18 deraadt Exp $	*/
d1880 1
a1880 1
	CIRCLEQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
@


1.135
log
@Significant namespace cleanup of netinet6 symbols.

One worrying bit is in icmp6.h where some htols() and htonl() are
added, which may affect compatibility down the line.  This component
can be reverted if issues show up.  Ports tree greps indicate no issue.

ok claudio mpi etc
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.134 2013/10/23 19:57:50 deraadt Exp $	*/
d394 1
d423 2
a424 1
		    icmp6->icmp6_type, sum, ip6_sprintf(&ip6->ip6_src)));
d828 3
a830 2
		    icmp6->icmp6_type, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst),
d2066 1
d2083 3
a2085 1
			    ip6_sprintf(&sa6_src.sin6_addr), e));
d2146 5
a2150 1
	static char buf[1024];
d2152 3
a2154 1
		 ip6_sprintf(src6), ip6_sprintf(dst6), ip6_sprintf(tgt6));
d2174 1
d2202 2
a2203 1
			"must be from linklocal\n", ip6_sprintf(&src6)));
d2210 2
a2211 1
			ip6_sprintf(&src6), ip6->ip6_hlim));
d2248 1
a2248 1
				ip6_sprintf(gw6),
d2297 2
a2298 1
			ip6_sprintf(&redtgt6), ifp->if_addrlen, lladdrlen - 2,
@


1.134
log
@Back when some NRL code was merged into KAME to create the *BSD IPV6
stack (factoid: by a bunch of people in my living room), some compatibility
#define's were created to shim incompatible inpcb access methods. There
was an understanding they would eventually be removed.  Since they are
error prone, and 1999 is a long time ago, now they die.
ok mikeb claudio mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.133 2013/10/21 12:27:14 deraadt Exp $	*/
d1675 1
a1675 1
			case IPV6_ADDR_SCOPE_LINKLOCAL:
d1679 1
a1679 1
			case IPV6_ADDR_SCOPE_SITELOCAL:
d1683 1
a1683 1
			case IPV6_ADDR_SCOPE_GLOBAL:
d1755 1
a1755 1
			case IPV6_ADDR_SCOPE_LINKLOCAL:
d1759 1
a1759 1
			case IPV6_ADDR_SCOPE_SITELOCAL:
d1763 1
a1763 1
			case IPV6_ADDR_SCOPE_GLOBAL:
@


1.133
log
@There are gasps of shock!  Add a pmtu delay sysctl BUTTON for netinet6,
making the code the same as netinet4 along the way.
ok bluhm phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.132 2013/10/21 08:42:25 phessler Exp $	*/
a104 27
/* inpcb members */
#define in6pcb		inpcb
#define in6p_laddr	inp_laddr6
#define in6p_faddr	inp_faddr6
#define in6p_icmp6filt	inp_icmp6filt
#define in6p_route	inp_route
#define in6p_socket	inp_socket
#define in6p_flags	inp_flags
#define in6p_moptions	inp_moptions6
#define in6p_outputopts	inp_outputopts6
#define in6p_ip6	inp_ipv6
#define in6p_flowinfo	inp_flowinfo
#define in6p_sp		inp_sp
#define in6p_next	inp_next
#define in6p_prev	inp_prev
/* macro names */
#define sotoin6pcb	sotoinpcb
/* function names */
#define in6_pcbdetach	in_pcbdetach
#define in6_rtchange	in_rtchange

/*
 * for KAME src sync over BSD*'s.  XXX: FreeBSD (>=3) are VERY different from
 * others...
 */
#define in6p_ip6_nxt	inp_ipv6.ip6_nxt

d1859 2
a1860 2
	struct in6pcb *in6p;
	struct in6pcb *last = NULL;
d1878 1
a1878 1
		if (!(in6p->in6p_flags & INP_IPV6))
d1880 1
a1880 1
		if (in6p->in6p_ip6_nxt != IPPROTO_ICMPV6)
d1889 1
a1889 1
			if (!IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr,
d1894 2
a1895 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_laddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
d1897 2
a1898 2
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
d1900 1
a1900 1
		if (in6p->in6p_icmp6filt
d1902 1
a1902 1
				 in6p->in6p_icmp6filt))
d1907 1
a1907 1
				if (last->in6p_flags & IN6P_CONTROLOPTS)
d1911 1
a1911 1
				if (sbappendaddr(&last->in6p_socket->so_rcv,
d1918 1
a1918 1
					sorwakeup(last->in6p_socket);
d1925 1
a1925 1
		if (last->in6p_flags & IN6P_CONTROLOPTS)
d1929 1
a1929 1
		if (sbappendaddr(&last->in6p_socket->so_rcv,
d1935 1
a1935 1
			sorwakeup(last->in6p_socket);
a2617 5
/* NRL PCB */
#define sotoin6pcb	sotoinpcb
#define in6pcb		inpcb
#define in6p_icmp6filt	inp_icmp6filt

d2626 1
a2626 1
	struct in6pcb *in6p = sotoin6pcb(so);
d2647 1
a2647 1
			if (!p || !in6p->in6p_icmp6filt) {
d2651 1
a2651 1
			bcopy(p, in6p->in6p_icmp6filt,
d2671 1
a2671 1
			if (!in6p->in6p_icmp6filt) {
d2678 1
a2678 1
			bcopy(in6p->in6p_icmp6filt, p,
a2692 5

/* NRL PCB */
#undef sotoin6pcb
#undef in6pcb
#undef in6p_icmp6filt
@


1.132
log
@Sprinkle a lot more IPv6 routing domains support in the kernel.

Mostly mechanical, setting and passing the rdomain and rtable correctly.
Not yet enabled.

Lots of help and hints from claudio and bluhm

OK claudio@@, bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.131 2013/10/17 16:27:45 bluhm Exp $	*/
d151 1
a151 2
static struct rttimer_queue *icmp6_mtudisc_timeout_q = NULL;
extern int pmtu_expire;
d186 1
a186 1
	icmp6_mtudisc_timeout_q = rt_timer_queue_create(pmtu_expire);
a2745 4
	int ret;

	ret = 0;	/* okay to send */

d2748 3
a2750 6
	    icmp6errppslim)) {
		/* The packet is subject to rate limit */
		ret++;
	}

	return ret;
@


1.131
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.130 2013/06/05 15:22:32 bluhm Exp $	*/
d145 1
a145 1
	void (*mc_func)(struct in6_addr *);
d251 1
a251 1
icmp6_mtudisc_callback_register(void (*func)(struct in6_addr *))
d1145 3
a1147 1
	/* sin6.sin6_scope_id = XXX: should be set if DST is a scoped addr */
d1168 1
a1168 1
		(*mc->mc_func)(&sin6.sin6_addr);
d2354 1
a2354 1
		    &newrt, /* XXX */ 0);
d2358 1
a2358 1
			    icmp6_redirect_timeout_q, /* XXX */ 0);
d2791 1
a2791 1
			icmp6_mtudisc_timeout_q, /* XXX */ 0);
@


1.130
log
@If an ICMP packet gets diverted to a raw IP socket, if must not be
consumed by icmp_input().  As an exception, control packets that
belong to a connection to a local socket must go to pr_ctlinput().
Add a switch over the ICMP type to handle that.
OK markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.129 2013/06/04 19:11:51 bluhm Exp $	*/
a84 1
#include <netinet/in_var.h>
d87 1
@


1.129
log
@Implement pf divert-to and divert-reply also for IPv6 raw sockets.
OK henning@@ markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.128 2013/06/01 16:22:05 bluhm Exp $	*/
d456 18
d881 3
@


1.128
log
@Pass the routing domain to IPv6 pr_ctlinput() like in IPv4.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.127 2013/05/31 15:04:23 bluhm Exp $	*/
d1887 12
@


1.127
log
@Remove a bunch of sockaddr_in6 pointer casts and replace others
with sin6tosa() or satosin6() inline functions.  This allows the
compiler to check the types more strictly.
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.126 2013/04/24 10:17:08 mpi Exp $	*/
d895 1
a895 1
		void (*ctlfunc)(int, struct sockaddr *, void *);
d1065 1
a1065 2
		ctlfunc = (void (*)(int, struct sockaddr *, void *))
			(inet6sw[ip6_protox[nxt]].pr_ctlinput);
d1067 2
a1068 1
			(void) (*ctlfunc)(code, sin6tosa(&icmp6dst), &ip6cp);
@


1.126
log
@Instead of having various extern declarations for protocol variables,
declare them once in their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.125 2013/04/10 01:35:55 guenther Exp $	*/
d1067 2
a1068 4
		if (ctlfunc) {
			(void) (*ctlfunc)(code, (struct sockaddr *)&icmp6dst,
					  &ip6cp);
		}
d1125 1
a1125 1
	rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6, m->m_pkthdr.rdomain);
d1195 1
a1195 1
	if (ifa_ifwithaddr((struct sockaddr *)&sin6, m->m_pkthdr.rdomain))
d1905 1
a1905 2
						 (struct sockaddr *)&rip6src,
						 n, opts) == 0) {
d1923 1
a1923 2
				 (struct sockaddr *)&rip6src,
				 m, opts) == 0) {
d2208 1
a2208 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0, m->m_pkthdr.rdomain);
d2220 1
a2220 1
		gw6 = &(((struct sockaddr_in6 *)rt->rt_gateway)->sin6_addr);
d2317 3
a2319 4
		rtredirect((struct sockaddr *)&sdst, (struct sockaddr *)&sgw,
			   (struct sockaddr *)NULL, RTF_GATEWAY | RTF_HOST,
			   (struct sockaddr *)&ssrc,
			   &newrt, /* XXX */ 0);
d2335 1
a2335 1
		pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&sdst);
d2429 1
a2429 1
		sin6 = (struct sockaddr_in6 *)rt->rt_gateway;
@


1.125
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.124 2013/04/04 17:58:42 bluhm Exp $	*/
a130 4

extern struct domain inet6domain;
extern struct ip6protosw inet6sw[];
extern u_char ip6_protox[];
@


1.124
log
@Make icmp6 ready for 64 bit time_t by adding a range check and an
explicit cast.
OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.123 2013/03/28 16:45:16 tedu Exp $	*/
d153 1
a153 1
    LIST_HEAD_INITIALIZER(&icmp6_mtudisc_callbacks);
@


1.123
log
@no need for a lot of code to include proc.h
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.122 2013/03/25 14:40:56 mpi Exp $	*/
d1822 7
a1828 3
				if (ifa6->ia6_lifetime.ia6t_expire >
				    time_second)
					ltime = htonl(ifa6->ia6_lifetime.ia6t_expire - time_second);
d1830 1
a1830 1
					ltime = 0;
@


1.122
log
@Substitute the handcrafted list of IPv6 addresses by a proper TAILQ.

ok bluhm@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.121 2013/03/22 01:41:12 tedu Exp $	*/
a2811 1
#include <sys/proc.h>
@


1.121
log
@simple replacement of LIST_END with NULL. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.120 2013/03/14 11:18:37 mpi Exp $	*/
d2043 1
a2043 1
	for (ia = in6_ifaddr; ia; ia = ia->ia_next)
@


1.120
log
@tedu faith(4), suggested by todd@@ some weeks ago after a submission by
dhill.

ok krw@@, mikeb@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.119 2013/03/04 14:42:25 bluhm Exp $	*/
d1741 1
a1741 1
	for (; ifp != TAILQ_END(&ifnet); ifp = TAILQ_NEXT(ifp, if_list)) {
@


1.119
log
@Replace the cast to struct in6_ifaddr pointer with the ifatoia6() macro.
No binary change.
OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.118 2012/04/03 14:58:45 mikeb Exp $	*/
a63 1
#include "faith.h"
a458 18

#if defined(NFAITH) && 0 < NFAITH
	if (m->m_pkthdr.rcvif && m->m_pkthdr.rcvif->if_type == IFT_FAITH) {
		/*
		 * Deliver very specific ICMP6 type only.
		 * This is important to deliver TOOBIG.  Otherwise PMTUD
		 * will not work.
		 */
		switch (icmp6->icmp6_type) {
		case ICMP6_DST_UNREACH:
		case ICMP6_PACKET_TOO_BIG:
		case ICMP6_TIME_EXCEEDED:
			break;
		default:
			goto freeit;
		}
	}
#endif
@


1.118
log
@bail if redirect destination is not unicast before doing other
expensive checks;  ok sperreault, todd, sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.117 2011/11/24 17:39:55 sperreault Exp $	*/
d1686 1
a1686 1
			ifa6 = (struct in6_ifaddr *)ifa;
d1764 1
a1764 1
			ifa6 = (struct in6_ifaddr *)ifa;
@


1.117
log
@rdomain support for IPv6
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.116 2011/04/06 19:23:15 sthen Exp $	*/
d2215 7
a2263 7
	if (IN6_IS_ADDR_MULTICAST(&reddst6)) {
		nd6log((LOG_ERR,
			"ICMP6 redirect rejected; "
			"redirect dst must be unicast: %s\n",
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
	}
@


1.116
log
@comment typo
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.115 2011/04/05 11:48:28 blambert Exp $	*/
d184 1
a184 1
struct rtentry *icmp6_mtudisc_clone(struct sockaddr *);
d1150 1
a1150 1
	rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6);
d1220 1
a1220 1
	if (ifa_ifwithaddr((struct sockaddr *)&sin6, /* XXX */ 0))
d2086 2
a2087 1
		src = in6_selectsrc(&sa6_src, NULL, NULL, &ro, NULL, &e);
d2224 1
a2224 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0, 0);
d2751 1
a2751 1
icmp6_mtudisc_clone(struct sockaddr *dst)
d2756 1
a2756 1
	rt = rtalloc1(dst, RT_REPORT, 0);
d2769 2
a2770 1
		error = rtrequest1(RTM_ADD, &info, rt->rt_priority, &nrt, 0);
@


1.115
log
@Passing M_WAITOK to mbuf functions is supposed to be a contract between
the caller and the function that the function will not fail to allocate
memory and return a NULL pointer. However, m_dup_pkthdr() violates
this contract, making it possible for functions that pass M_WAITOK to
be surprised in ways that hurt.

Fix this by passing the wait flag all the way down the functions that
actually do the allocation for m_dup_pkthdr() so that we won't be
surprised.

man page update forthcoming

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.114 2011/04/03 13:54:21 stsp Exp $	*/
d1769 1
a1769 1
				 * prefererred address should be put before
@


1.114
log
@Kill redundant offsetof definitions; ok deraadt henning sthen thib
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.113 2010/07/09 15:44:20 claudio Exp $	*/
d745 1
a745 1
			if (m_dup_pkthdr(n, m)) { /* just for rcvif */
d1387 1
a1387 1
	if (m_dup_pkthdr(n, m)) /* just for rcvif */
@


1.113
log
@Add the rtableid to struct rttimer and therefor  make it available to
the callback functions. This fixes a problem where dynamic routes in
different tables would not get deleted because the callback was doing
the remove on the wrong table.
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.112 2010/05/07 13:33:17 claudio Exp $	*/
a1183 3
#ifndef offsetof		/* XXX */
#define	offsetof(type, member)	((size_t)(&((type *)0)->member))
#endif
@


1.112
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.111 2010/04/20 22:05:43 tedu Exp $	*/
d2349 1
a2349 1
			    icmp6_redirect_timeout_q);
d2781 1
a2781 1
			icmp6_mtudisc_timeout_q);
d2804 2
a2805 1
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
d2826 2
a2827 1
		rtrequest1(RTM_DELETE, &info, rt->rt_priority, NULL, 0);
@


1.111
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.110 2010/01/14 04:27:32 jsing Exp $	*/
d2758 1
a2758 1
	rt = rtalloc1(dst, 1, 0);
@


1.110
log
@Destatic.

ok kettenis@@ claudio@@ naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.108 2009/11/20 09:02:21 guenther Exp $	*/
d2830 1
@


1.109
log
@- properly spell "packet".
@
text
@d171 16
a186 16
static void icmp6_errcount(struct icmp6errstat *, int, int);
static int icmp6_rip6_input(struct mbuf **, int);
static int icmp6_ratelimit(const struct in6_addr *, const int, const int);
static const char *icmp6_redirect_diag(struct in6_addr *,
	struct in6_addr *, struct in6_addr *);
static struct mbuf *ni6_input(struct mbuf *, int);
static struct mbuf *ni6_nametodns(const char *, int, int);
static int ni6_dnsmatch(const char *, int, const char *, int);
static int ni6_addrs(struct icmp6_nodeinfo *, struct mbuf *,
			  struct ifnet **, char *);
static int ni6_store_addrs(struct icmp6_nodeinfo *, struct icmp6_nodeinfo *,
				struct ifnet *, int);
static int icmp6_notify_error(struct mbuf *, int, int, int);
static struct rtentry *icmp6_mtudisc_clone(struct sockaddr *);
static void icmp6_mtudisc_timeout(struct rtentry *, struct rttimer *);
static void icmp6_redirect_timeout(struct rtentry *, struct rttimer *);
d189 1
a189 1
icmp6_init()
d196 1
a196 1
static void
d896 1
a896 1
static int
d1187 1
a1187 1
static struct mbuf *
d1490 1
a1490 1
static struct mbuf *
d1597 1
a1597 1
static int
d1657 1
a1657 1
static int
d1659 1
a1659 1
	char *subj)
d1745 1
a1745 1
static int
d1747 1
a1747 1
	struct ifnet *ifp0, int resid)
d1883 1
a1883 1
static int
d2148 1
a2148 1
icmp6_fasttimo()
d2154 1
a2154 1
static const char *
d2156 1
a2156 1
	struct in6_addr *tgt6)
d2647 1
a2647 1
	struct mbuf **mp)
d2735 1
a2735 1
static int
d2752 1
a2752 1
static struct rtentry *
d2790 1
a2790 1
static void
d2811 1
a2811 1
static void
d2836 1
a2836 1
	void *newp, size_t newlen)
@


1.108
log
@NULL dereference in IPV6_PORTRANGE and IP_IPSEC_*, found by Clement LECIGNE,
localhost DoS everywhere.  To help minimize further issues, make the
mbuf != NULL test explicit instead of implicit in a length test.
Suggestions and initial work by mpf@@ and miod@@
ok henning@@, mpf@@, claudio@@,
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.107 2009/09/13 14:42:52 krw Exp $	*/
d304 1
a304 1
	 * - the Pakcet Too Big message can be sent for path MTU discovery.
@


1.107
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.106 2009/07/26 12:59:17 thib Exp $	*/
a2649 1
	int optlen;
a2652 2
	optlen = m ? m->m_len : 0;

d2666 1
a2666 1
			if (optlen != sizeof(*p)) {
@


1.106
log
@no need to cast the return value of m_freem() to void
as its a void function.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.104 2009/02/22 17:43:20 claudio Exp $	*/
d745 4
a748 1
			M_DUP_PKTHDR(n, m); /* just for rcvif */
d1389 4
a1392 1
	M_DUP_PKTHDR(n, m); /* just for rcvif */
@


1.105
log
@Initial support for routing domains. This allows to bind interfaces to
alternate routing table and separate them from other interfaces in distinct
routing tables. The same network can now be used in any doamin at the same
time without causing conflicts.
This diff is mostly mechanical and adds the necessary rdomain checks accross
net and netinet. L2 and IPv4 are mostly covered still missing pf and IPv6.
input and tested by jsg@@, phessler@@ and reyk@@. "put it in" deraadt@@
@
text
@d2683 1
a2683 1
			(void)m_freem(m);
@


1.104
log
@In icmp6_mtudisc_update make sure that the requested MTU is not less then
the minimal IPv6 MTU minus the size of a frag header (which is needed because
of a hack in ip6_output/ip6_setpmtu).
Inspired by a similar fix from netbsd. OK markus@@, OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.103 2009/02/18 20:54:48 claudio Exp $	*/
d1220 1
a1220 1
	if (ifa_ifwithaddr((struct sockaddr *)&sin6))
d2339 1
a2339 1
			   &newrt);
@


1.103
log
@Move goto lables to the beginning of the line. Having them indented like
the rest of the switch cases is a good camouflage.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.102 2008/10/02 14:11:06 jsing Exp $	*/
d523 1
d1110 7
@


1.102
log
@Fix PF state key mismatches that occur when callers of icmp6_reflect()
recycle mbufs. Based on an initial diff by henning@@, also tested by todd@@.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.100 2008/09/12 12:53:55 henning Exp $	*/
d866 1
a866 1
	deliver:
d873 1
a873 1
	badcode:
d877 1
a877 1
	badlen:
@


1.101
log
@remove dead stores and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok henning@@ mpf@@
@
text
@d2116 3
@


1.100
log
@just like v4 icmp, icmp6 recycles mbufs so we need to call
pf_pkt_addr_changed to clear the recorded pf state information in the hdr
claudio ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.99 2008/06/11 19:00:50 mcbride Exp $	*/
a2155 2
	u_char *redirhdr = NULL;
	int redirhdrlen = 0;
a2276 5
	}

	if (ndopts.nd_opts_rh) {
		redirhdrlen = ndopts.nd_opts_rh->nd_opt_rh_len;
		redirhdr = (u_char *)(ndopts.nd_opts_rh + 1); /* xxx */
@


1.99
log
@ANSIfy to sync with KAME. From Karl Sjodahl <dunceor@@gmail.com>.

ok todd deraadt naddy bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.98 2008/06/11 06:30:36 mcbride Exp $	*/
d66 1
d102 4
d1075 3
@


1.98
log
@From KAME, allow adjustable limits on NDP entries and discovered routes.

ok mpf naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.97 2008/05/11 08:13:02 claudio Exp $	*/
d192 1
a192 3
icmp6_errcount(stat, type, code)
	struct icmp6errstat *stat;
	int type, code;
d251 1
a251 2
icmp6_mtudisc_callback_register(func)
	void (*func)(struct in6_addr *);
d273 1
a273 3
icmp6_error(m, type, code, param)
	struct mbuf *m;
	int type, code, param;
d414 1
a414 3
icmp6_input(mp, offp, proto)
	struct mbuf **mp;
	int *offp, proto;
d888 1
a888 3
icmp6_notify_error(m, off, icmp6len, code)
	struct mbuf *m;
	int off, icmp6len, code;
d1091 1
a1091 3
icmp6_mtudisc_update(ip6cp, validated)
	struct ip6ctlparam *ip6cp;
	int validated;
d1169 1
a1169 3
ni6_input(m, off)
	struct mbuf *m;
	int off;
d1465 2
d1469 1
a1469 4
ni6_nametodns(name, namelen, old)
	const char *name;
	int namelen;
	int old;	/* return pascal string if non-zero */
d1576 1
a1576 5
ni6_dnsmatch(a, alen, b, blen)
	const char *a;
	int alen;
	const char *b;
	int blen;
d1636 2
a1637 5
ni6_addrs(ni6, m, ifpp, subj)
	struct icmp6_nodeinfo *ni6;
	struct mbuf *m;
	struct ifnet **ifpp;
	char *subj;
d1724 2
a1725 4
ni6_store_addrs(ni6, nni6, ifp0, resid)
	struct icmp6_nodeinfo *ni6, *nni6;
	struct ifnet *ifp0;
	int resid;
d1862 1
a1862 3
icmp6_rip6_input(mp, off)
	struct	mbuf **mp;
	int	off;
d1954 1
a1954 3
icmp6_reflect(m, off)
	struct	mbuf *m;
	size_t off;
d2130 2
a2131 4
icmp6_redirect_diag(src6, dst6, tgt6)
	struct in6_addr *src6;
	struct in6_addr *dst6;
	struct in6_addr *tgt6;
d2140 1
a2140 3
icmp6_redirect_input(m, off)
	struct mbuf *m;
	int off;
d2356 1
a2356 3
icmp6_redirect_output(m0, rt)
	struct mbuf *m0;
	struct rtentry *rt;
d2628 2
a2629 5
icmp6_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
d2715 4
d2721 1
a2721 4
icmp6_ratelimit(dst, type, code)
	const struct in6_addr *dst;	/* not used at this moment */
	const int type;			/* not used at this moment */
	const int code;			/* not used at this moment */
d2738 1
a2738 2
icmp6_mtudisc_clone(dst)
	struct sockaddr *dst;
d2776 1
a2776 3
icmp6_mtudisc_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
d2797 1
a2797 3
icmp6_redirect_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
d2820 2
a2821 7
icmp6_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
a2822 1

@


1.97
log
@rtrequest to rtrequest1 conversion in inet6. With that no rtrequest should
be left over. OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.96 2008/03/08 01:52:35 sthen Exp $	*/
a163 1
static int icmp6_redirect_hiwat = -1;
d2337 2
a2338 2
		if (0 <= icmp6_redirect_hiwat && rtcount > icmp6_redirect_hiwat)
			return;
@


1.96
log
@allow a response to icmp6 node information queries where the local
hostname starts with a digit. ok mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.95 2008/02/05 22:57:31 mpf Exp $	*/
d2786 1
d2789 5
a2793 4
		error = rtrequest((int) RTM_ADD, dst,
		    (struct sockaddr *) rt->rt_gateway,
		    (struct sockaddr *) 0,
		    RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC, &nrt, 0);
d2821 8
a2828 2
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0, 0);
d2844 8
a2851 2
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0, 0);
@


1.95
log
@Move carp load balancing (ARP/IP) to a simpler configuration scheme.
Instead of using the same IP on multiple interfaces, carp has to be
configured with the new "carpnodes" and "balancing" options.
 # ifconfig carp0 carpnodes 1:0,2:100,3:100 balancing ip carpdev sis0 192.168.5.50

Please note, that this is a flag day for anyone using carp balancing.
You'll need to adjust your configuration accordingly.

Addititionally this diff adds IPv6 NDP balancing support.

Tested and OK mcbride@@, reyk@@.
Manpage help by jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.94 2007/06/01 00:52:38 henning Exp $	*/
d1551 1
a1551 1
			if (!isalpha(p[0]) || !isalnum(p[i - 1]))
@


1.94
log
@apply the "skip ipsec if there are no flows" speedup diff to IPv6 too.
we need a pointer to the inpcb to decide, which was not previously
passed to ip6_output, so this diff is a little bigger.
from itojun, ok ryan
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.93 2007/03/18 23:23:17 mpf Exp $	*/
a483 1
	    m->m_pkthdr.rcvif->if_flags & IFF_LINK0 &&
@


1.93
log
@Add IP load balancing support for carp(4).
This provides a similar functionality as ARP balancing,
but also works for traffic that comes across routers.
IPv6 is supported as well.
The configuration scheme will change as soon we have sth better.

Also add support for changing the MAC address on carp(4)
interfaces. (code from mcbride)

Tested by pyr@@ and reyk@@
OK mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.92 2007/01/16 11:05:25 itojun Exp $	*/
d2137 2
a2138 1
	if (ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, &outif) != 0 && outif)
d2638 1
a2638 1
	if (ip6_output(m, NULL, NULL, 0, NULL, NULL) != 0)
@


1.92
log
@oops, previous commit was incorrect.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.91 2007/01/15 21:32:29 itojun Exp $	*/
d64 3
d97 3
a99 1
#include "faith.h"
d482 8
@


1.91
log
@fix infinite loop in case nip6 and nicmp6 are not on the same mbuf.  NetBSD PR 34994+35333
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.90 2006/12/09 01:12:28 itojun Exp $	*/
d622 2
a623 2
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off, NULL);
			nicmp6 = (struct icmp6_hdr *)((caddr_t)nip6 + off);
@


1.90
log
@switch IPv6 advanced API from RFC2292 to RFC3542 (2292 is superseded by 3542).
the kernel still handles RFC2292 set/getsockopts, so that compiled binary
has no trouble running.  userland sees RFC3542 symbols only on header file
so new code has to use RFC3542 API.

bump libc shlib minor for function additions.

tested on i386/amd64 by jmc, i386 by brad. checked by deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.89 2006/11/17 01:11:23 itojun Exp $	*/
d622 1
@


1.89
log
@change semantics of ff01::/16 to interface local multicast
(to sync up with more recent IPv6 spec)

ok from: deraadt mcbride
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.88 2006/11/15 03:07:44 itojun Exp $	*/
d1916 1
a1916 1
					ip6_savecontrol(last, &opts, ip6, n);
d1935 1
a1935 1
			ip6_savecontrol(last, &opts, ip6, m);
@


1.88
log
@unifdef -USCOPEDROUTING
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.87 2006/06/16 16:49:40 henning Exp $	*/
d380 1
a380 1
	if (IN6_IS_SCOPE_LINKLOCAL(&oip6->ip6_src))
d382 1
a382 1
	if (IN6_IS_SCOPE_LINKLOCAL(&oip6->ip6_dst))
d1264 1
a1264 1
			if (IN6_IS_SCOPE_LINKLOCAL(&sin6.sin6_addr)) {
@


1.87
log
@adjust functions dealing with the routing table to take a table ID as
parameter so they can work on alternate tables. table 0 hardcoded for
many callers yet, that will be adapted step by step.
input + ok claudio norby hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.86 2006/03/05 21:48:57 miod Exp $	*/
a1029 1
#ifndef SCOPEDROUTING
a1036 1
#endif
a1047 1
#ifndef SCOPEDROUTING
a1054 1
#endif
@


1.87.2.1
log
@Errata #8:
Under some circumstances, processing an ICMP6 echo request would cause
the kernel to enter an infinite loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.87 2006/06/16 16:49:40 henning Exp $	*/
a621 1
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off, NULL);
@


1.87.2.2
log
@Update to errata #8, merge revision 1.92 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.87.2.1 2007/01/16 06:17:26 miod Exp $	*/
d622 2
a623 2
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off,
			    sizeof(*nicmp6));
@


1.86
log
@Use more queue macros rather than doing it by hand; ok otto@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.85 2005/10/22 06:38:54 brad Exp $	*/
d2225 1
a2225 1
	rt = rtalloc1((struct sockaddr *)&sin6, 0);
d2770 1
a2770 1
	rt = rtalloc1(dst, 1);
d2781 1
a2781 1
		    RTF_GATEWAY | RTF_HOST | RTF_DYNAMIC, &nrt);
d2810 1
a2810 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
d2827 1
a2827 1
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
@


1.85
log
@In icmp6_redirect_output(), sip6 is initialised to point to the data area of
m0. But m0 may be freed later, so trying to use sip6 at the end of this
function is wrong. My guess is that we want to reference the data area
of m (the mbuf about to be send) instead at this point.
Fix a panic on Xen (where a data area of a mbuf may be unmapped when the
mbuf is freed), and probably potential data/pool corruption in other cases.

From bouyer NetBSD

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.84 2005/01/17 10:18:03 itojun Exp $	*/
d1675 1
a1675 2
	for (ifp = TAILQ_FIRST(&ifnet); ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
d1677 1
a1677 3
		for (ifa = ifp->if_addrlist.tqh_first; ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
d1756 2
a1757 5
	for (; ifp; ifp = TAILQ_NEXT(ifp, if_list))
	{
		for (ifa = ifp->if_addrlist.tqh_first; ifa;
		     ifa = ifa->ifa_list.tqe_next)
		{
@


1.85.2.1
log
@Errata #18:
Under some circumstances, processing an ICMP6 echo request would cause
the kernel to enter an infinite loop.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.85 2005/10/22 06:38:54 brad Exp $	*/
a621 1
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off, NULL);
@


1.85.2.2
log
@Update to errata #18, merge revision 1.92 as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.85.2.1 2007/01/16 06:17:51 miod Exp $	*/
d622 2
a623 2
			IP6_EXTHDR_GET(nicmp6, struct icmp6_hdr *, n, off,
			    sizeof(*nicmp6));
@


1.84
log
@should not check "code" field on icmp6 too big message.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.83 2004/06/21 23:50:37 tholo Exp $	*/
d2610 1
@


1.83
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.82 2004/03/25 14:01:20 dhartmei Exp $	*/
a512 2
		if (code != 0)
			goto badcode;
@


1.82
log
@Don't use mbuf pointer in error case, when it has been set to NULL.
From Patrick Latifi. ok markus@@, henning@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.81 2004/02/15 11:16:08 markus Exp $	*/
d1846 2
a1847 2
				    time.tv_sec)
					ltime = htonl(ifa6->ia6_lifetime.ia6t_expire - time.tv_sec);
@


1.81
log
@switch to sysctl_int_arr(); ok itojun, henning, miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.80 2004/02/04 13:14:42 dhartmei Exp $	*/
a445 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
@


1.80
log
@typo within comment, deilver -> deliver
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.79 2004/02/04 11:23:15 dhartmei Exp $	*/
d2841 3
a2859 6
	case ICMPV6CTL_REDIRACCEPT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_rediraccept);
	case ICMPV6CTL_REDIRTIMEOUT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_redirtimeout);
a2862 26
	case ICMPV6CTL_ND6_PRUNE:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_prune);
	case ICMPV6CTL_ND6_DELAY:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_delay);
	case ICMPV6CTL_ND6_UMAXTRIES:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_umaxtries);
	case ICMPV6CTL_ND6_MMAXTRIES:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_mmaxtries);
	case ICMPV6CTL_ND6_USELOOPBACK:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&nd6_useloopback);
	case ICMPV6CTL_NODEINFO:
		return sysctl_int(oldp, oldlenp, newp, newlen, &icmp6_nodeinfo);
	case ICMPV6CTL_ERRPPSLIMIT:
		return sysctl_int(oldp, oldlenp, newp, newlen, &icmp6errppslim);
	case ICMPV6CTL_ND6_MAXNUDHINT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&nd6_maxnudhint);
	case ICMPV6CTL_MTUDISC_HIWAT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_mtudisc_hiwat);
	case ICMPV6CTL_MTUDISC_LOWAT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_mtudisc_lowat);
	case ICMPV6CTL_ND6_DEBUG:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_debug);
d2867 3
@


1.79
log
@remove kludge now that proper IPV6_MMTU handling is in
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.78 2004/02/01 19:57:12 dhartmei Exp $	*/
d464 1
a464 1
		 * This is important to deilver TOOBIG.  Otherwise PMTUD
@


1.78
log
@ignore too small MTUs (below 296 octets), similar to IPv4.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.77 2004/01/15 17:51:42 miod Exp $	*/
d1142 1
a1142 1
		if (mtu >= 296 && mtu < IN6_LINKMTU(rt->rt_ifp)) {
@


1.77
log
@Provide explicit function argument declarations.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.76 2003/12/21 14:57:19 markus Exp $	*/
d1142 1
a1142 1
		if (mtu < IN6_LINKMTU(rt->rt_ifp)) {
@


1.76
log
@use CIRCLEQ* for pcb's; ok deraadt, henning, mcbride, with help from canacar
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.75 2003/10/01 21:41:05 itojun Exp $	*/
d888 1
a888 1
	int off, icmp6len;
@


1.75
log
@use random number generator to generate IPv6 fragment ID/flowlabel.
cleanup IPv6 flowlabel handling.  deraadt ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.74 2003/08/07 09:11:24 itojun Exp $	*/
d1910 1
a1910 4
	for (in6p = rawin6pcbtable.inpt_queue.cqh_first;
	     in6p != (struct inpcb *)&rawin6pcbtable.inpt_queue;
	     in6p = in6p->inp_queue.cqe_next)
	{
@


1.74
log
@m_cat might free mbuf passed as 2nd arg.  compute pkthdr.len before m_cat.
from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.73 2003/06/24 07:55:12 itojun Exp $	*/
d1063 1
a1063 1
			(eip6->ip6_flow & IPV6_FLOWLABEL_MASK);
@


1.73
log
@remove unneeded checks of accept_rtadv.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.72 2003/06/24 07:47:54 itojun Exp $	*/
d2606 1
a2607 1
		m->m_pkthdr.len += m0->m_pkthdr.len;
@


1.72
log
@use time.tv_sec directly, rather than having time_second (freebsd NIH).
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.71 2003/06/11 02:54:02 itojun Exp $	*/
d2408 1
a2408 1
	if (!ip6_forwarding || ip6_accept_rtadv)
@


1.71
log
@- sync up MLD declaration with RFC3542 (s/MLD6/MLD/)
- routing header declaration with RFC3542
  (note: sizeof(ip6_rthdr0) has changed!)
  also, sync up with RFC2460 routing header definition (no "strict" source
  routing mode any more)

part of advanced API update (RFC2292 -> 3542).

markus, todd, millert, henning ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.70 2003/06/03 06:25:26 itojun Exp $	*/
a1755 1
	long time_second = time.tv_sec;
d1847 2
a1848 2
				    time_second)
					ltime = htonl(ifa6->ia6_lifetime.ia6t_expire - time_second);
@


1.70
log
@remove assumption on mbuf pointed to by m0; sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.69 2003/06/02 23:28:15 millert Exp $	*/
d645 3
a647 3
	case MLD6_LISTENER_QUERY:
	case MLD6_LISTENER_REPORT:
		if (icmp6len < sizeof(struct mld6_hdr))
d649 1
a649 1
		if (icmp6->icmp6_type == MLD6_LISTENER_QUERY) /* XXX: ugly... */
d663 1
a663 1
	case MLD6_LISTENER_DONE:
d665 1
a665 1
		if (icmp6len < sizeof(struct mld6_hdr))	/* necessary? */
d669 2
a670 2
	case MLD6_MTRACE_RESP:
	case MLD6_MTRACE:
@


1.69
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.68 2003/05/22 10:20:57 itojun Exp $	*/
d2557 4
a2560 4
    {
	/* redirected header option */
	int len;
	struct nd_opt_rd_hdr *nd_opt_rh;
d2562 6
a2567 6
	/*
	 * compute the maximum size for icmp6 redirect header option.
	 * XXX room for auth header?
	 */
	len = maxlen - (p - (u_char *)ip6);
	len &= ~7;
d2569 21
a2589 28
	/* This is just for simplicity. */
	if (m0->m_pkthdr.len != m0->m_len) {
		if (m0->m_next) {
			m_freem(m0->m_next);
			m0->m_next = NULL;
		}
		m0->m_pkthdr.len = m0->m_len;
	}

	/*
	 * Redirected header option spec (RFC2461 4.6.3) talks nothing
	 * about padding/truncate rule for the original IP packet.
	 * From the discussion on IPv6imp in Feb 1999, the consensus was:
	 * - "attach as much as possible" is the goal
	 * - pad if not aligned (original size can be guessed by original
	 *   ip6 header)
	 * Following code adds the padding if it is simple enough,
	 * and truncates if not.
	 */
	if (m0->m_next || m0->m_pkthdr.len != m0->m_len)
		panic("assumption failed in %s:%d", __FILE__, __LINE__);

	if (len - sizeof(*nd_opt_rh) < m0->m_pkthdr.len) {
		/* not enough room, truncate */
		m0->m_pkthdr.len = m0->m_len = len - sizeof(*nd_opt_rh);
	} else {
		/* enough room, pad or truncate */
		size_t extra;
d2591 2
a2592 8
		extra = m0->m_pkthdr.len % 8;
		if (extra) {
			/* pad if easy enough, truncate if not */
			if (8 - extra <= M_TRAILINGSPACE(m0)) {
				/* pad */
				m0->m_len += (8 - extra);
				m0->m_pkthdr.len += (8 - extra);
			} else {
d2594 1
a2594 2
				m0->m_pkthdr.len -= extra;
				m0->m_len -= extra;
d2596 1
d2598 12
a2609 2
		len = m0->m_pkthdr.len + sizeof(*nd_opt_rh);
		m0->m_pkthdr.len = m0->m_len = len - sizeof(*nd_opt_rh);
d2611 1
a2611 14

	nd_opt_rh = (struct nd_opt_rd_hdr *)p;
	bzero(nd_opt_rh, sizeof(*nd_opt_rh));
	nd_opt_rh->nd_opt_rh_type = ND_OPT_REDIRECTED_HEADER;
	nd_opt_rh->nd_opt_rh_len = len >> 3;
	p += sizeof(*nd_opt_rh);
	m->m_pkthdr.len = m->m_len = p - (u_char *)ip6;

	/* connect m0 to m */
	m->m_next = m0;
	m->m_pkthdr.len = m->m_len + m0->m_len;
	m0 = NULL;
    }
noredhdropt:;
@


1.68
log
@remove break after return
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.67 2003/05/14 14:24:44 itojun Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.67
log
@make PULLDOWN_TEST codepath the default (has been default for a long time).
markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.66 2003/04/01 01:09:37 itojun Exp $	*/
a514 1
		break;
a527 1
		break;
a541 1
		break;
a556 1
		break;
@


1.66
log
@avoid memory leak on redirect header generation.  from kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.65 2002/10/12 01:09:45 krw Exp $	*/
a290 3
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, 0, sizeof(struct ip6_hdr), );
#else
a295 1
#endif
a332 4
#ifndef PULLDOWN_TEST
		IP6_EXTHDR_CHECK(m, 0, off + sizeof(struct icmp6_hdr), );
		icp = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
#else
a338 1
#endif
a431 5
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, sizeof(struct icmp6_hdr), IPPROTO_DONE);
	/* m might change if M_LOOP.  So, call mtod after this */
#endif

a446 3
#ifndef PULLDOWN_TEST
	icmp6 = (struct icmp6_hdr *)((caddr_t)ip6 + off);
#else
a452 1
#endif
a697 4
#ifndef PULLDOWN_TEST
			IP6_EXTHDR_CHECK(m, off, sizeof(struct icmp6_nodeinfo),
					 IPPROTO_DONE);
#endif
a906 6
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off,
			 sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr),
			 -1);
	icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
#else
a912 1
#endif
a935 7
#ifndef PULLDOWN_TEST
				IP6_EXTHDR_CHECK(m, 0, eoff +
						 sizeof(struct ip6_ext),
						 -1);
				eh = (struct ip6_ext *)(mtod(m, caddr_t)
							+ eoff);
#else
a941 1
#endif
a957 6
#ifndef PULLDOWN_TEST
				IP6_EXTHDR_CHECK(m, 0, eoff + sizeof(*rth),
						 -1);
				rth = (struct ip6_rthdr *)(mtod(m, caddr_t)
							   + eoff);
#else
a963 1
#endif
a976 5
#ifndef PULLDOWN_TEST
					IP6_EXTHDR_CHECK(m, 0, eoff + rthlen,
							 -1);
					rth0 = (struct ip6_rthdr0 *)(mtod(m, caddr_t) + eoff);
#else
a983 1
#endif
a992 7
#ifndef PULLDOWN_TEST
				IP6_EXTHDR_CHECK(m, 0, eoff +
						 sizeof(struct ip6_frag),
						 -1);
				fh = (struct ip6_frag *)(mtod(m, caddr_t)
							 + eoff);
#else
a998 1
#endif
a1023 3
#ifndef PULLDOWN_TEST
		icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
#else
a1029 1
#endif
a1200 3
#ifndef PULLDOWN_TEST
	ni6 = (struct icmp6_nodeinfo *)(mtod(m, caddr_t) + off);
#else
a1205 1
#endif
a1906 4
#ifndef PULLDOWN_TEST
	/* this is assumed to be safe. */
	icmp6 = (struct icmp6_hdr *)((caddr_t)ip6 + off);
#else
a1911 1
#endif
a2209 4
#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_rd = (struct nd_redirect *)((caddr_t)ip6 + off);
#else
a2214 1
#endif
@


1.65
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.64 2002/09/11 03:15:36 itojun Exp $	*/
d2709 1
d2712 4
@


1.64
log
@KNF - return is not a function.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.63 2002/07/30 23:30:08 itojun Exp $	*/
d2673 1
a2673 1
		panic("assumption failed in %s:%d\n", __FILE__, __LINE__);
@


1.63
log
@remove unneeded NULL pointer checks.
From: tedu <grendel@@zeitbombe.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.62 2002/07/10 05:08:03 itojun Exp $	*/
d892 1
a892 1
			return(IPPROTO_DONE);
d939 1
a939 1
		return(-1);
d976 1
a976 1
					return(-1);
d1005 1
a1005 1
					return(-1);
d1031 1
a1031 1
						return(-1);
d1054 1
a1054 1
					return(-1);
d1089 1
a1089 1
			return(-1);
d1157 1
a1157 1
	return(0);
d1161 1
a1161 1
	return(-1);
d1450 1
a1450 1
		return(NULL);
d1527 1
a1527 1
	return(n);
d1533 1
a1533 1
	return(NULL);
d1740 1
a1740 1
				return(0);
d1748 1
a1748 1
			return(0);
d1807 1
a1807 1
			return(addrsofif);
d1813 1
a1813 1
	return(addrs);
d1833 1
a1833 1
		return(0);	/* needless to copy */
d1898 1
a1898 1
				return(copied);
d1954 1
a1954 1
	return(copied);
d2834 1
a2834 1
	return(error);
@


1.62
log
@do not use p++ in tolower().  NetBSD PR 17540.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.61 2002/06/09 14:38:39 itojun Exp $	*/
d2272 1
a2272 1
	if (!m || !ifp)
@


1.61
log
@whitespace cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.60 2002/06/08 21:22:02 itojun Exp $	*/
d1624 4
a1627 3
				if (isupper(*p))
					*cp++ = tolower(*p++);
				else
@


1.60
log
@sync with latest KAME in6_ifaddr/prefix/default router manipulation.
behavior changes:
- two iocts used by ndp(8) are now obsolete (backward compat provided).
  use sysctl path instead.
- lo0 does not get ::1 automatically.  it will get ::1 when lo0 comes up.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.59 2002/05/31 04:27:00 itojun Exp $	*/
d979 1
a979 1
				
d1233 1
a1233 1
 * 
d1926 1
a1926 1
			
d1937 1
a1937 1
			
@


1.59
log
@do not mistakenly lock PMTUD route entry with RTV_MTU.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.58 2002/05/29 23:38:58 itojun Exp $	*/
d2990 3
@


1.58
log
@force fragment to minimum link MTU (1280) when needed (when PMTUD does
not take effect) - like icmp6 responses or foo-over-IPv6 tunnel.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.57 2002/05/29 07:54:59 itojun Exp $	*/
d1209 4
a1212 7
	if (rt && (rt->rt_flags & RTF_HOST)
	    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
		if (mtu < IPV6_MMTU) {
				/* xxx */
			rt->rt_rmx.rmx_locks |= RTV_MTU;
		} else if (mtu < rt->rt_ifp->if_mtu &&
			   rt->rt_rmx.rmx_mtu > mtu) {
@


1.57
log
@attach nd_ifinfo structure to if_afdata.
split IPv6 MTU (advertised by RA) from real link MTU.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.56 2002/05/29 07:21:08 itojun Exp $	*/
d2215 7
a2221 1
	if (ip6_output(m, NULL, NULL, 0, NULL, &outif) != 0 && outif)
@


1.56
log
@set rmx_mtu to 0 on PMTUD route entry timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.55 2002/05/24 09:15:29 itojun Exp $	*/
d2201 1
a2201 1
		ip6->ip6_hlim = nd_ifinfo[m->m_pkthdr.rcvif->if_index].chlim;
@


1.55
log
@make a strict check before sending FQDN node information reply.  sync w/kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.54 2002/03/14 01:27:11 millert Exp $	*/
d2915 2
a2916 2
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
			rt->rt_rmx.rmx_mtu = rt->rt_ifp->if_mtu;
@


1.54
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.53 2002/03/05 08:29:45 itojun Exp $	*/
d1540 5
d1622 11
a1632 2
			bcopy(p, cp, i);
			cp += i;
@


1.53
log
@on redirect output, always try to attach target link layer address option.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.52 2001/12/07 09:56:32 itojun Exp $	*/
d144 1
a144 1
	void (*mc_func) __P((struct in6_addr *));
d166 16
a181 16
static void icmp6_errcount __P((struct icmp6errstat *, int, int));
static int icmp6_rip6_input __P((struct mbuf **, int));
static int icmp6_ratelimit __P((const struct in6_addr *, const int, const int));
static const char *icmp6_redirect_diag __P((struct in6_addr *,
	struct in6_addr *, struct in6_addr *));
static struct mbuf *ni6_input __P((struct mbuf *, int));
static struct mbuf *ni6_nametodns __P((const char *, int, int));
static int ni6_dnsmatch __P((const char *, int, const char *, int));
static int ni6_addrs __P((struct icmp6_nodeinfo *, struct mbuf *,
			  struct ifnet **, char *));
static int ni6_store_addrs __P((struct icmp6_nodeinfo *, struct icmp6_nodeinfo *,
				struct ifnet *, int));
static int icmp6_notify_error __P((struct mbuf *, int, int, int));
static struct rtentry *icmp6_mtudisc_clone __P((struct sockaddr *));
static void icmp6_mtudisc_timeout __P((struct rtentry *, struct rttimer *));
static void icmp6_redirect_timeout __P((struct rtentry *, struct rttimer *));
d254 1
a254 1
	void (*func) __P((struct in6_addr *));
d946 1
a946 1
		void (*ctlfunc) __P((int, struct sockaddr *, void *));
d1150 1
a1150 1
		ctlfunc = (void (*) __P((int, struct sockaddr *, void *)))
@


1.52
log
@give up local, instead of remote, on ping6 -w during memory starved
situation.  validate hostname encoding more strictly.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.51 2001/12/07 09:33:10 itojun Exp $	*/
d2463 1
a2463 1
	struct in6_addr *router_ll6;
d2541 3
a2543 3
		router_ll6 = &sin6->sin6_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(router_ll6))
			router_ll6 = (struct in6_addr *)NULL;
d2545 1
a2545 1
		router_ll6 = (struct in6_addr *)NULL;
d2569 1
a2569 1
		if (!router_ll6)
d2571 1
a2571 1
		bcopy(router_ll6, &nd_rd->nd_rd_target,
d2577 1
d2586 28
a2613 30
	if (!router_ll6)
		goto nolladdropt;

    {
	/* target lladdr option */
	struct rtentry *rt_router = NULL;
	int len;
	struct sockaddr_dl *sdl;
	struct nd_opt_hdr *nd_opt;
	char *lladdr;

	rt_router = nd6_lookup(router_ll6, 0, ifp);
	if (!rt_router)
		goto nolladdropt;
	len = sizeof(*nd_opt) + ifp->if_addrlen;
	len = (len + 7) & ~7;	/* round by 8 */
	/* safety check */
	if (len + (p - (u_char *)ip6) > maxlen)
		goto nolladdropt;
	if (!(rt_router->rt_flags & RTF_GATEWAY) &&
	    (rt_router->rt_flags & RTF_LLINFO) &&
	    (rt_router->rt_gateway->sa_family == AF_LINK) &&
	    (sdl = (struct sockaddr_dl *)rt_router->rt_gateway) &&
	    sdl->sdl_alen) {
		nd_opt = (struct nd_opt_hdr *)p;
		nd_opt->nd_opt_type = ND_OPT_TARGET_LINKADDR;
		nd_opt->nd_opt_len = len >> 3;
		lladdr = (char *)(nd_opt + 1);
		bcopy(LLADDR(sdl), lladdr, ifp->if_addrlen);
		p += len;
d2615 1
a2615 2
    }
nolladdropt:;
@


1.52.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.52 2001/12/07 09:56:32 itojun Exp $	*/
d144 1
a144 1
	void (*mc_func)(struct in6_addr *);
d166 16
a181 16
static void icmp6_errcount(struct icmp6errstat *, int, int);
static int icmp6_rip6_input(struct mbuf **, int);
static int icmp6_ratelimit(const struct in6_addr *, const int, const int);
static const char *icmp6_redirect_diag(struct in6_addr *,
	struct in6_addr *, struct in6_addr *);
static struct mbuf *ni6_input(struct mbuf *, int);
static struct mbuf *ni6_nametodns(const char *, int, int);
static int ni6_dnsmatch(const char *, int, const char *, int);
static int ni6_addrs(struct icmp6_nodeinfo *, struct mbuf *,
			  struct ifnet **, char *);
static int ni6_store_addrs(struct icmp6_nodeinfo *, struct icmp6_nodeinfo *,
				struct ifnet *, int);
static int icmp6_notify_error(struct mbuf *, int, int, int);
static struct rtentry *icmp6_mtudisc_clone(struct sockaddr *);
static void icmp6_mtudisc_timeout(struct rtentry *, struct rttimer *);
static void icmp6_redirect_timeout(struct rtentry *, struct rttimer *);
d254 1
a254 1
	void (*func)(struct in6_addr *);
d946 1
a946 1
		void (*ctlfunc)(int, struct sockaddr *, void *);
d1150 1
a1150 1
		ctlfunc = (void (*)(int, struct sockaddr *, void *))
d1209 7
a1215 4
	if (rt && (rt->rt_flags & RTF_HOST) &&
	    !(rt->rt_rmx.rmx_locks & RTV_MTU) &&
	    (rt->rt_rmx.rmx_mtu > mtu || rt->rt_rmx.rmx_mtu == 0)) {
		if (mtu < IN6_LINKMTU(rt->rt_ifp)) {
a1539 5
#define isupper(x) ('A' <= (x) && (x) <= 'Z')
#define isalpha(x) (('A' <= (x) && (x) <= 'Z') || ('a' <= (x) && (x) <= 'z'))
#define isalnum(x) (isalpha(x) || ('0' <= (x) && (x) <= '9'))
#define tolower(x) (isupper(x) ? (x) + 'a' - 'A' : (x))

d1617 2
a1618 11
			if (!isalpha(p[0]) || !isalnum(p[i - 1]))
				goto fail;
			while (i > 0) {
				if (!isalnum(*p) && *p != '-')
					goto fail;
				if (isupper(*p))
					*cp++ = tolower(*p++);
				else
					*cp++ = *p++;
				i--;
			}
d2187 1
a2187 1
		ip6->ip6_hlim = ND_IFINFO(m->m_pkthdr.rcvif)->chlim;
d2201 1
a2201 7
	/*
	 * To avoid a "too big" situation at an intermediate router
	 * and the path MTU discovery process, specify the IPV6_MINMTU flag.
	 * Note that only echo and node information replies are affected,
	 * since the length of ICMP6 errors is limited to the minimum MTU.
	 */
	if (ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, &outif) != 0 && outif)
d2463 1
a2463 1
	struct in6_addr *nexthop;
d2541 3
a2543 3
		nexthop = &sin6->sin6_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(nexthop))
			nexthop = NULL;
d2545 1
a2545 1
		nexthop = NULL;
d2569 1
a2569 1
		if (!nexthop)
d2571 1
a2571 1
		bcopy(nexthop, &nd_rd->nd_rd_target,
a2576 1
		nexthop = &sip6->ip6_dst;
d2585 30
a2614 28
	{
		/* target lladdr option */
		struct rtentry *rt_nexthop = NULL;
		int len;
		struct sockaddr_dl *sdl;
		struct nd_opt_hdr *nd_opt;
		char *lladdr;

		rt_nexthop = nd6_lookup(nexthop, 0, ifp);
		if (!rt_nexthop)
			goto nolladdropt;
		len = sizeof(*nd_opt) + ifp->if_addrlen;
		len = (len + 7) & ~7;	/* round by 8 */
		/* safety check */
		if (len + (p - (u_char *)ip6) > maxlen)
			goto nolladdropt;
		if (!(rt_nexthop->rt_flags & RTF_GATEWAY) &&
		    (rt_nexthop->rt_flags & RTF_LLINFO) &&
		    (rt_nexthop->rt_gateway->sa_family == AF_LINK) &&
		    (sdl = (struct sockaddr_dl *)rt_nexthop->rt_gateway) &&
		    sdl->sdl_alen) {
			nd_opt = (struct nd_opt_hdr *)p;
			nd_opt->nd_opt_type = ND_OPT_TARGET_LINKADDR;
			nd_opt->nd_opt_len = len >> 3;
			lladdr = (char *)(nd_opt + 1);
			bcopy(LLADDR(sdl), lladdr, ifp->if_addrlen);
			p += len;
		}
d2616 2
a2617 1
  nolladdropt:;
d2903 2
a2904 2
		if (!(rt->rt_rmx.rmx_locks & RTV_MTU))
			rt->rt_rmx.rmx_mtu = 0;
a2974 3
	case ICMPV6CTL_ND6_DRLIST:
	case ICMPV6CTL_ND6_PRLIST:
		return nd6_sysctl(name[0], oldp, oldlenp, newp, newlen);
@


1.52.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.52.2.1 2002/06/11 03:31:37 art Exp $	*/
d892 1
a892 1
			return (IPPROTO_DONE);
d939 1
a939 1
		return (-1);
d976 1
a976 1
					return (-1);
d979 1
a979 1

d1005 1
a1005 1
					return (-1);
d1031 1
a1031 1
						return (-1);
d1054 1
a1054 1
					return (-1);
d1089 1
a1089 1
			return (-1);
d1157 1
a1157 1
	return (0);
d1161 1
a1161 1
	return (-1);
d1233 1
a1233 1
 *
d1450 1
a1450 1
		return (NULL);
d1527 1
a1527 1
	return (n);
d1533 1
a1533 1
	return (NULL);
d1624 3
a1626 4
				if (isupper(*p)) {
					*cp++ = tolower(*p);
					p++;
				} else
d1739 1
a1739 1
				return (0);
d1747 1
a1747 1
			return (0);
d1806 1
a1806 1
			return (addrsofif);
d1812 1
a1812 1
	return (addrs);
d1832 1
a1832 1
		return (0);	/* needless to copy */
d1897 1
a1897 1
				return (copied);
d1926 1
a1926 1

d1937 1
a1937 1

d1953 1
a1953 1
	return (copied);
d2271 1
a2271 1
	if (!ifp)
d2672 1
a2672 1
		panic("assumption failed in %s:%d", __FILE__, __LINE__);
d2833 1
a2833 1
	return (error);
@


1.52.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d291 3
d299 1
d337 4
d347 1
d441 5
d461 3
d470 1
d716 4
d929 6
d941 1
d965 7
d978 1
d995 6
d1007 1
d1021 5
d1033 1
d1043 7
d1056 1
d1082 3
d1091 1
d1263 3
d1271 1
d1973 4
d1982 1
d2281 4
d2290 1
a2708 1
	m0 = NULL;
a2710 4
	if (m0) {
		m_freem(m0);
		m0 = NULL;
	}
@


1.51
log
@correct icmp6 MIB counter mistake
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.50 2001/12/07 09:16:07 itojun Exp $	*/
d553 2
d556 1
a556 1
			code += PRC_TIMXCEED_INTRANS;
d584 10
a593 3
		if ((n = m_copy(m, 0, M_COPYALL)) == NULL) {
			/* Give up remote */
			break;
d595 7
a601 2
		if ((n->m_flags & M_EXT) != 0
		 || n->m_len < off + sizeof(struct icmp6_hdr)) {
d606 1
a606 1
			 * Prepare an internal mbuf. m_pullup() doesn't
d623 1
a623 1
				/* Give up remote */
d625 3
a627 1
				break;
d649 1
d661 2
d720 1
a720 1
			n = m_copy(m, 0, M_COPYALL);
d751 1
d1609 6
a1614 2
			/* DNS label length restriction, RFC1035 page 8 */
			if (i >= 64)
d2517 1
@


1.50
log
@whitespace/comment sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.49 2001/12/06 04:19:25 itojun Exp $	*/
d439 2
d454 1
d467 1
d478 1
a500 3
	icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_msg);
	if (icmp6->icmp6_type < ICMP6_INFOMSG_MASK)
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
d2177 2
a2178 1
	ip6_output(m, NULL, NULL, 0, NULL, &outif);
a2445 1
	struct ifnet *outif = NULL;
d2693 5
a2697 5
	ip6_output(m, NULL, NULL, 0, NULL, &outif);
	if (outif) {
		icmp6_ifstat_inc(outif, ifs6_out_msg);
		icmp6_ifstat_inc(outif, ifs6_out_redirect);
	}
@


1.49
log
@remove kame IPSEC code within #ifdef.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.48 2001/11/06 19:53:20 miod Exp $	*/
d122 1
a122 1
 * for KAME src sync over BSD*'s. XXX: FreeBSD (>=3) are VERY different from
d303 9
a311 3
	 * Multicast destination check. For unrecognized option errors,
	 * this check has already done in ip6_unknown_opt(), so we can
	 * check only for other errors.
d320 4
a323 1
	/* Source address check. XXX: the case of anycast source? */
d360 2
a361 1
	} else {
d413 1
a413 1
	icmp6_reflect(m, sizeof(struct ip6_hdr)); /*header order: IPv6 - ICMPv6*/
d441 1
a441 1
	/* m might change if M_LOOP. So, call mtod after this */
a500 1

d622 1
a622 1
			 * Adjust mbuf. ip6_plen will be adjusted in
d676 1
a676 1
		/* XXX: these two are experimental. not officially defind. */
d743 1
a743 1
			bcopy(hostname, p + 4, maxhlen); /*meaningless TTL*/
d936 1
a936 1
		while (1) { /* XXX: should avoid inf. loop explicitly? */
d1050 1
a1050 1
				 * Header. In such cases going to the notify
d1198 1
a1198 1
	if (rt)
d1200 1
d1283 1
a1283 1
		/*FALLTHROUGH*/
d1413 1
a1413 1
		 * `unknown Qtype' in this case. However we regard the case
d1607 1
a1607 1
	/*NOTREACHED*/
d1759 1
a1759 1
			 * XXX: just experimental. not in the spec.
d1845 1
a1845 1
			 * XXX: just experimental. not in the spec.
d1877 2
d2110 1
a2110 1
	 * If the incoming packet was addressed directly to us(i.e. unicast),
d2125 1
a2125 1
		 * and the sender is also ourseleves.
d2136 1
a2136 1
		 * that we do not own. Select a source address based on the
d2141 1
a2141 1
		if (ro.ro_rt)
d2143 1
d2170 1
a2170 1
	 * xxx option handling
d2365 1
a2365 1
	if (!is_onlink) {	/* better router case. perform rtredirect. */
d2410 2
a2411 2
    {
	struct sockaddr_in6 sdst;
d2413 6
a2418 6
	bzero(&sdst, sizeof(sdst));
	sdst.sin6_family = AF_INET6;
	sdst.sin6_len = sizeof(struct sockaddr_in6);
	bcopy(&reddst6, &sdst.sin6_addr, sizeof(struct in6_addr));
	pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&sdst);
    }
d2573 1
a2573 1
	len = (len + 7) & ~7;	/*round by 8*/
d2815 1
a2815 1
	ret = 0;	/*okay to send*/
@


1.48
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.47 2001/06/27 03:49:54 angelos Exp $	*/
a97 2
#undef IPSEC

a484 8
#ifdef IPSEC
	/* drop it if it does not match the default policy */
	if (ipsec6_in_reject(m, NULL)) {
		ipsec6stat.in_polvio++;
		goto freeit;
	}
#endif

a2160 3
#ifdef IPSEC
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/
a2404 3
#ifdef IPSEC
	key_sa_routechange((struct sockaddr *)&sdst);
#endif
a2677 3
#ifdef IPSEC
	m->m_pkthdr.rcvif = NULL;
#endif /*IPSEC*/
@


1.47
log
@Get rid of M_COPY_* macros; either use M_MOVE_* or M_DUP_*, depending
on how macros should be treated. Code by fgsch@@, ok by me and itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.46 2001/06/26 19:58:57 itojun Exp $	*/
d2901 1
a2901 1
#include <vm/vm.h>
@


1.46
log
@modify m_pkthdr.len computation to work with both 4.4BSD M_COPY_PKTHDR
and openbsd 2.9+ M_COPY_PKTHDR.  discussed with angelos.  sync with kame.

XXX it is bad to change behavior of existing macro without name change...
new behavior will be renamed M_MOVE_PKTHDR soon.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.45 2001/06/25 02:59:01 angelos Exp $	*/
d612 1
a612 1
			M_COPY_PKTHDR(n, n0);
@


1.45
log
@Don't double-clear M_PKTHDR/tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.44 2001/06/22 12:59:08 itojun Exp $	*/
d621 1
a621 2
			n->m_pkthdr.len = n->m_len =
				noff + sizeof(struct icmp6_hdr);
d625 1
d627 2
a629 1
			n->m_pkthdr.len += n0->m_pkthdr.len;
@


1.44
log
@cleanup COMPAT_RFC1885 case, for icmp6 echoback packet size consideration
(obsolete).  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.43 2001/06/09 06:43:37 angelos Exp $	*/
a629 2
			n0->m_flags &= ~M_PKTHDR;
			m_tag_init(n0);
@


1.43
log
@No need for net/net_osdep.h
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.42 2001/06/01 06:08:22 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.212 2001/06/01 05:35:52 jinmei Exp $	*/
a184 4
#ifdef COMPAT_RFC1885
static struct route_in6 icmp6_reflect_rt;
#endif

d2013 9
a2035 4
#ifdef COMPAT_RFC1885
	int mtu = IPV6_MMTU;
	struct sockaddr_in6 *sin6 = &icmp6_reflect_rt.ro_dst;
#endif
a2107 32
#ifdef COMPAT_RFC1885
	/*
	 * xxx guess MTU
	 * RFC 1885 requires that echo reply should be truncated if it
	 * does not fit in with (return) path MTU, but the description was
	 * removed in the new spec.
	 */
	if (icmp6_reflect_rt.ro_rt == 0 ||
	    ! (IN6_ARE_ADDR_EQUAL(&sin6->sin6_addr, &ip6->ip6_dst))) {
		if (icmp6_reflect_rt.ro_rt) {
			icmp6_reflect_rt.ro_rt = 0;
		}
		bzero(sin6, sizeof(*sin6));
		sin6->sin6_family = PF_INET6;
		sin6->sin6_len = sizeof(struct sockaddr_in6);
		sin6->sin6_addr = ip6->ip6_dst;

		rtalloc((struct route *)&icmp6_reflect_rt.ro_rt);
	}

	if (icmp6_reflect_rt.ro_rt == 0)
		goto bad;

	if ((icmp6_reflect_rt.ro_rt->rt_flags & RTF_HOST)
	    && mtu < icmp6_reflect_rt.ro_rt->rt_ifp->if_mtu)
		mtu = icmp6_reflect_rt.ro_rt->rt_rmx.rmx_mtu;

	if (mtu < m->m_pkthdr.len) {
		plen -= (m->m_pkthdr.len - mtu);
		m_adj(m, mtu - m->m_pkthdr.len);
	}
#endif
a2175 3
#ifdef COMPAT_RFC1885
	ip6_output(m, NULL, &icmp6_reflect_rt, 0, NULL, &outif);
#else
d2177 1
a2177 1
#endif
@


1.42
log
@use default hoplimit when incoming interface is not known to icmp6_error.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.41 2001/05/26 06:57:19 angelos Exp $	*/
a101 2
#include <net/net_osdep.h>

d2748 1
a2748 1
#ifdef HAVE_NRL_INPCB
d2752 1
a2752 1
#endif
d2834 2
a2835 1
#ifdef HAVE_NRL_INPCB
a2838 1
#endif
@


1.41
log
@Use m_tag_init() to initialize new mbuf m_pkthdr fields, rather than
having to change it every time.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.40 2001/05/20 08:36:01 angelos Exp $	*/
/*	$KAME: icmp6.c,v 1.205 2001/03/21 07:48:57 itojun Exp $	*/
d2193 2
a2194 1
	}
@


1.40
log
@Convert from tdbi to packet tags.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.39 2001/04/04 06:03:45 itojun Exp $	*/
d637 1
a637 1
			TAILQ_INIT(&n0->m_pkthdr.tags);
@


1.39
log
@make sure rcvif is not bogus, on call to icmp6_reflect.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.38 2001/03/30 11:08:58 itojun Exp $	*/
d637 1
a637 1
			n0->m_pkthdr.tdbi = NULL;
@


1.39.2.1
log
@Pull in patch from current:
Fix (itojun):
use default hoplimit when incoming interface is not known to icmp6_error.
sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.39 2001/04/04 06:03:45 itojun Exp $	*/
d2193 1
a2193 2
	} else
		ip6->ip6_hlim = ip6_defhlim;
@


1.38
log
@enable FAKE_LOOPBACK_IF case by default.
now traffic on loopback interface will be presented to bpf as normal wire
format packet (without KAME scopeid in s6_addr16[1]).

fix KAME PR 250 (host mistakenly accepts packets to fe80::x%lo0).

sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.37 2001/03/28 20:03:07 angelos Exp $	*/
d400 9
@


1.37
log
@Allow tdbi's to appear in mbufs throughout the stack; this allows
security properties of the packets to be pushed up to the application
(not done yet). Eventually, this will be turned into a packet
attributes framework.

Make sure tdbi's are free'd/cleared properly whenever drivers (or NFS)
does weird things with mbufs.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.36 2001/03/21 15:01:08 itojun Exp $	*/
a1324 1
#ifdef FAKE_LOOPBACK_IF
a1329 6
#else
				if (IN6_IS_SCOPE_LINKLOCAL(&ip6->ip6_dst)) {
					sin6.sin6_addr.s6_addr16[1] =
					    ip6->ip6_dst.s6_addr16[1];
				}
#endif
@


1.36
log
@set rmx_mtu to L2 interface mtu, instead of 0, on mtudisc timeout.
ip6_output() change is for safety.  sync with kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.35 2001/03/20 03:17:44 itojun Exp $	*/
d628 1
d744 1
a744 1
			M_COPY_PKTHDR(n, m); /* just for recvif */
d1438 1
a1438 1
	M_COPY_PKTHDR(n, m); /* just for recvif */
@


1.35
log
@change interpretation of net.inet6.icmp6.nodeinfo from true/fale to bitmap.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.34 2001/03/08 00:18:36 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.204 2001/03/20 02:44:39 itojun Exp $	*/
d2915 2
a2916 3
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0) {
			rt->rt_rmx.rmx_mtu = 0;
		}
@


1.34
log
@remove bogus rtfree.  inspired by fix to PR 1706.  sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.33 2001/02/16 16:00:55 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.203 2001/03/08 00:17:54 itojun Exp $	*/
d706 3
d1382 12
@


1.33
log
@pull in new pcb notification code from kame.  better handling of scope address.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.32 2001/02/08 18:46:22 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.201 2001/02/16 12:23:40 itojun Exp $	*/
a2871 1
			rtfree(nrt);
@


1.32
log
@witch raw ip6 socket code from NRL to kame.
makes upgrades/code sharing much easier.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.31 2001/02/08 16:07:59 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.195 2001/02/08 15:35:31 itojun Exp $	*/
d182 1
d204 1
a204 1
	switch(type) {
d228 1
a228 1
		switch(code) {
d238 1
a238 1
		switch(code) {
a426 1
	struct sockaddr_in6 icmp6src;
d863 3
a865 3
		if (icmp6len < sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr)) {
			icmp6stat.icp6s_tooshort++;
			goto freeit;
d867 35
d903 4
a906 4
		IP6_EXTHDR_CHECK(m, off,
			sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr),
			IPPROTO_DONE);
		icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
d908 6
a913 6
		IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off,
			sizeof(*icmp6) + sizeof(struct ip6_hdr));
		if (icmp6 == NULL) {
			icmp6stat.icp6s_tooshort++;
			return IPPROTO_DONE;
		}
d915 1
a915 4
		bzero(&icmp6src, sizeof(icmp6src));
		icmp6src.sin6_len = sizeof(struct sockaddr_in6);
		icmp6src.sin6_family = AF_INET6;
		icmp6src.sin6_addr = ((struct ip6_hdr *)(icmp6 + 1))->ip6_dst;
d917 2
a918 2
		/* Detect the upper level protocol */
	    {
a919 1
		struct ip6_hdr *eip6 = (struct ip6_hdr *)(icmp6 + 1);
d925 1
d934 1
a934 1
			switch(nxt) {
d941 1
a941 1
						 IPPROTO_DONE);
d946 1
a946 1
					eoff, sizeof(*eh));
d949 1
a949 1
					return IPPROTO_DONE;
d970 1
a970 1
						 IPPROTO_DONE);
d975 1
a975 1
					eoff, sizeof(*rth));
d978 1
a978 1
					return IPPROTO_DONE;
d996 1
a996 1
							 IPPROTO_DONE);
d1004 1
a1004 1
						return IPPROTO_DONE;
d1019 1
a1019 1
						 IPPROTO_DONE);
d1024 1
a1024 1
					eoff, sizeof(*fh));
d1027 1
a1027 1
					return IPPROTO_DONE;
d1059 1
a1059 1
			sizeof(*icmp6) + sizeof(struct ip6_hdr));
d1062 1
a1062 1
			return IPPROTO_DONE;
d1065 5
d1071 39
a1109 1
			finaldst = &((struct ip6_hdr *)(icmp6 + 1))->ip6_dst;
d1115 7
d1126 2
a1127 2
			(void) (*ctlfunc)(code, (struct sockaddr *)&icmp6src,
			    &ip6cp);
a1128 10
	    }
		break;

	badcode:
		icmp6stat.icp6s_badcode++;
		break;

	badlen:
		icmp6stat.icp6s_badlen++;
		break;
d1130 1
d1132 1
a1132 4
	icmp6_rip6_input(&m, *offp);
	return IPPROTO_DONE;

 freeit:
d1134 1
a1134 1
	return IPPROTO_DONE;
d1688 1
a1688 1
		switch(ni6->ni_code) {
d1729 1
a1729 1
			switch(in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
d1815 1
a1815 1
			switch(in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
d2759 1
a2759 1
	switch(op) {
@


1.31
log
@implement upper limit to icmp6 redirects (experimental, turned off)
negative value to {mtudisc,redirect}_{hi,lo}wat will turn off the limitation.
sync with kame.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.30 2001/02/07 11:43:52 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.194 2001/02/08 15:19:12 itojun Exp $	*/
d104 27
d137 1
d171 1
d1059 1
a1059 1
	rip6_input(&m, offp, IPPROTO_ICMPV6);
d1837 92
d2660 92
@


1.30
log
@by default, don't bark on inbound ND messages, as outsider may be able to
fill up /var with bogus packets.
setting net.inet6.icmp6.nd6_debug will re-enable kernel messages on invalid
ND packet and other occasions.

improve icmp6 stats.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.29 2001/01/16 06:16:34 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.191 2001/02/07 08:07:38 itojun Exp $	*/
a109 1
extern struct in6pcb rawin6pcb;
d130 11
a140 2
int icmp6_mtudisc_hiwat = 1280;
int icmp6_mtudisc_lowat = 256;
d155 1
d166 1
d1058 1
a1058 1
		if (rtcount > icmp6_mtudisc_hiwat)
d1060 2
a1061 1
		else if (rtcount > icmp6_mtudisc_lowat) {
d1067 1
a1067 1
		if (rtcount > icmp6_mtudisc_lowat)
d1823 1
d1881 18
a1898 6
	/* XXX hack for link-local addresses */
	if (IN6_IS_ADDR_LINKLOCAL(&ip6->ip6_dst))
		ip6->ip6_dst.s6_addr16[1] =
			htons(m->m_pkthdr.rcvif->if_index);
	if (IN6_IS_ADDR_LINKLOCAL(&t))
		t.s6_addr16[1] = htons(m->m_pkthdr.rcvif->if_index);
d1953 4
a1956 1
	if (src == 0)
d1959 2
a1960 4
		 * that we do not own. Select a source address which has the
		 * same scope.
		 * XXX: for (non link-local) multicast addresses, this might
		 * not be a good choice.
d1962 12
a1973 5
		if ((ia = in6_ifawithscope(m->m_pkthdr.rcvif, &t)) != 0)
			src = &IA6_SIN6(ia)->sin6_addr;

	if (src == 0)
		goto bad;
d2197 18
d2228 7
a2234 2
			   (struct rtentry **)NULL
			   );
d2621 14
@


1.29
log
@s/ND6DEBUG/ND6_DEBUG/ to synchronize with other places
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.28 2001/01/08 06:22:05 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.172 2000/12/11 19:27:06 itojun Exp $	*/
d343 1
a343 1
		printf("ENOBUFS in icmp6_error %d\n", __LINE__);
d420 1
a420 2
#ifdef ND6_DEBUG
		log(LOG_ERR,
d422 1
a422 2
		    icmp6->icmp6_type, sum, ip6_sprintf(&ip6->ip6_src));
#endif
a552 3
#ifdef DIAGNOSTIC
				printf("MCLBYTES too small\n");
#endif
a670 3
#ifdef DIAGNOSTIC
				printf("MCLBYTES too small\n");
#endif
d810 5
a814 4
		printf("icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%d)\n",
		       icmp6->icmp6_type, ip6_sprintf(&ip6->ip6_src),
		       ip6_sprintf(&ip6->ip6_dst),
		       m->m_pkthdr.rcvif ? m->m_pkthdr.rcvif->if_index : 0);
d983 1
a983 1
	    notify:
d1195 2
a1196 2
			 * Not sure what exactly does "address belongs to the
			 * node" mean in the spec, is it just unicast, or what?
d1315 4
a1318 4
			 /*
			  * XXX: should we try to allocate more? But MCLBYTES
			  * is probably much larger than IPV6_MMTU...
			  */
d1570 3
a1572 3
	register struct ifnet *ifp;
	register struct in6_ifaddr *ifa6;
	register struct ifaddr *ifa;
d1621 1
a1621 2
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL)
				    == 0)
d1625 1
a1625 2
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL)
				    == 0)
d1629 1
a1629 2
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL)
				    == 0)
d1663 3
a1665 3
	register struct ifnet *ifp = ifp0 ? ifp0 : TAILQ_FIRST(&ifnet);
	register struct in6_ifaddr *ifa6;
	register struct ifaddr *ifa;
d1707 1
a1707 2
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL)
				    == 0)
d1711 1
a1711 2
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL)
				    == 0)
d1715 1
a1715 2
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL)
				    == 0)
d1819 4
a1822 3
		printf("sanity fail: off=%lx, sizeof(ip6)=%lx in %s:%d\n",
		       (u_long)off, (u_long)sizeof(struct ip6_hdr),
		       __FILE__, __LINE__);
d2003 1
a2003 1
	register struct mbuf *m;
d2051 1
a2051 1
		log(LOG_ERR,
d2053 2
a2054 2
			"must be from linklocal\n", ip6_sprintf(&src6));
		goto freeit;
d2057 1
a2057 1
		log(LOG_ERR,
d2060 2
a2061 2
			ip6_sprintf(&src6), ip6->ip6_hlim);
		goto freeit;
d2076 1
a2076 1
			log(LOG_ERR,
d2079 1
a2079 1
			    icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
d2081 1
a2081 1
			goto freeit;
d2086 1
a2086 1
			log(LOG_ERR,
d2091 1
a2091 1
				icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
d2093 1
a2093 1
			goto freeit;
d2096 1
a2096 1
		log(LOG_ERR,
d2099 2
a2100 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
		goto freeit;
d2106 1
a2106 1
		log(LOG_ERR,
d2109 2
a2110 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
		goto freeit;
d2119 1
a2119 1
		log(LOG_ERR,
d2122 2
a2123 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
		goto freeit;
d2130 1
a2130 1
		log(LOG_INFO, "icmp6_redirect_input: "
d2132 2
a2133 1
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
d2148 1
a2148 1
		log(LOG_INFO,
d2152 2
a2153 1
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6));
a2183 4
#if 1
#else
	struct ip6protosw *pr;
#endif
a2188 1
#if 1
a2189 14
#else
	/*
	 * do not use pfctlinput() here, we have different prototype for
	 * xx_ctlinput() in ip6proto.
	 */
	for (pr = (struct ip6protosw *)inet6domain.dom_protosw;
	     pr < (struct ip6protosw *)inet6domain.dom_protoswNPROTOSW;
	     pr++) {
		if (pr->pr_ctlinput) {
			(*pr->pr_ctlinput)(PRC_REDIRECT_HOST,
				(struct sockaddr *)&sdst, NULL, NULL, 0);
		}
	}
#endif
d2197 5
d2620 2
@


1.28
log
@wrap "icmp6 checksum error" message into #ifdef ND6DEBUG.  NetBSD PR 11911.
sync with kame
aVS: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.27 2000/12/11 19:29:50 itojun Exp $	*/
d420 1
a420 1
#ifdef ND6DEBUG
@


1.27
log
@no need to rtalloc1() twice in pmtud. from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.26 2000/12/11 08:04:56 itojun Exp $	*/
d420 1
d423 2
a424 3
		    icmp6->icmp6_type,
		    sum,
		    ip6_sprintf(&ip6->ip6_src));
@


1.26
log
@nuke #ifdef TCP6 (no longer supported).
validate ICMPv6 too big messages (pmtud) based on pcb.  we accept
certain amount of non-validated ones, as IPv6 mandates ICMPv6 (so even for
traffic from unconnected pcb, we need pmtud).
sync with kame
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.25 2000/11/11 00:45:39 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.156 2000/10/19 19:21:07 itojun Exp $	*/
d1077 1
a1077 6
	rt = rtalloc1((struct sockaddr *)&sin6, 1);	/*clone*/
	if (!rt || (rt->rt_flags & RTF_HOST) == 0) {
		if (rt)
			RTFREE(rt);
		rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6);
	}
@


1.25
log
@improve spec conformance of node information query (07).
make sure to check scoped address right on PMTUD.
sync with kame.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.24 2000/10/10 15:53:08 itojun Exp $	*/
d115 12
d130 4
a134 2
static void icmp6_mtudisc_update __P((struct in6_addr *, struct icmp6_hdr *,
				      struct mbuf *));
d218 23
d450 1
a450 1
		ipsecstat.in_polvio++;
a861 1
		int icmp6type = icmp6->icmp6_type;
d1001 7
a1007 5
		if (icmp6type == ICMP6_PACKET_TOO_BIG) {
			if (finaldst == NULL)
				finaldst = &((struct ip6_hdr *)(icmp6 + 1))->ip6_dst;
			icmp6_mtudisc_update(finaldst, icmp6, m);
		}
d1012 2
a1013 4
			ip6cp.ip6c_m = m;
			ip6cp.ip6c_ip6 = (struct ip6_hdr *)(icmp6 + 1);
			ip6cp.ip6c_off = eoff;
			(*ctlfunc)(code, (struct sockaddr *)&icmp6src, &ip6cp);
d1035 4
a1038 5
static void
icmp6_mtudisc_update(dst, icmp6, m)
	struct in6_addr *dst;
	struct icmp6_hdr *icmp6;/* we can assume the validity of the pointer */
	struct mbuf *m;	/* currently unused but added for scoped addrs */
d1040 5
d1049 18
d1091 1
d1097 8
d2643 6
@


1.24
log
@little bit of sync with kame ($KAME, s/u_char/u_int8_t/)
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.23 2000/10/10 14:24:34 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.147 2000/10/10 15:35:47 itojun Exp $	*/
d128 1
a128 1
			  struct ifnet **));
d1013 5
d1042 1
a1042 1
 * draft-ietf-ipngwg-icmp-name-lookups-06.
d1067 1
a1067 1
	struct sockaddr_in6 sin6;
d1070 1
a1070 1
	char *subj;
d1086 4
a1089 3
	 * We accept packets with the following IPv6 destination address:
	 * - Responder's unicast/anycast address, and
	 * - link-local multicast address (including NI group address)
d1097 1
a1097 1
		; /*unicast/anycast, fine*/
d1099 1
a1099 1
		; /*violates spec slightly, see above*/
d1103 1
a1103 1
	/* guess reply length */
a1104 33
	switch (qtype) {
	case NI_QTYPE_NOOP:
		break;		/* no reply data */
	case NI_QTYPE_SUPTYPES:
		replylen += sizeof(u_int32_t);
		break;
	case NI_QTYPE_FQDN:
		/* XXX will append a mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		break;
	case NI_QTYPE_NODEADDR:
		addrs = ni6_addrs(ni6, m, &ifp);
		if ((replylen += addrs * sizeof(struct in6_addr)) > MCLBYTES)
			replylen = MCLBYTES; /* XXX: we'll truncate later */
		break;
	default:
		/*
		 * XXX: We must return a reply with the ICMP6 code
		 * `unknown Qtype' in this case. However we regard the case
		 * as an FQDN query for backward compatibility.
		 * Older versions set a random value to this field,
		 * so it rarely varies in the defined qtypes.
		 * But the mechanism is not reliable...
		 * maybe we should obsolete older versions.
		 */
		qtype = NI_QTYPE_FQDN;
		/* XXX will append a mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		oldfqdn++;
		break;
	}

	/* validate query Subject field. */
d1109 1
a1109 1
		/* 06 draft */
d1169 1
d1172 1
d1210 1
a1210 1
		case ICMP6_NI_SUBJ_IPV4:	/* xxx: to be implemented? */
d1217 35
a1251 1
	/* allocate a mbuf to reply. */
d1261 2
a1262 2
			  * XXX: should we try to allocate more? But MCLBYTES is
			  * probably much larger than IPV6_MMTU...
d1509 1
a1509 1
ni6_addrs(ni6, m, ifpp)
d1513 1
d1518 1
a1518 1
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
d1520 17
d1548 2
a1549 2
			if (!(ni6->ni_flags & NI_NODEADDR_FLAG_ALL) &&
			    IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst,
d1558 1
a1558 1
			 * [icmp-name-lookups-05]
a1562 8
			if (ifa6->ia6_flags & IN6_IFF_ANYCAST)
				continue; /* we need only unicast addresses */

			if ((ni6->ni_flags & (NI_NODEADDR_FLAG_LINKLOCAL |
					      NI_NODEADDR_FLAG_SITELOCAL |
					      NI_NODEADDR_FLAG_GLOBAL)) == 0)
				continue;

d1565 4
a1568 3
			 case IPV6_ADDR_SCOPE_LINKLOCAL:
				if (ni6->ni_flags & NI_NODEADDR_FLAG_LINKLOCAL)
					addrsofif++;
d1570 9
a1578 3
			 case IPV6_ADDR_SCOPE_SITELOCAL:
				if (ni6->ni_flags & NI_NODEADDR_FLAG_SITELOCAL)
					addrsofif++;
d1580 2
a1581 6
			 case IPV6_ADDR_SCOPE_GLOBAL:
				 if (ni6->ni_flags & NI_NODEADDR_FLAG_GLOBAL)
					 addrsofif++;
				 break;
			 default:
				 continue;
d1583 10
d1614 2
a1615 1
	int docopy, copied = 0;
d1617 3
d1621 1
a1621 1
	if (ifp0 == NULL && !(ni6->ni_flags & NI_NODEADDR_FLAG_ALL))
d1624 2
a1630 2
			docopy = 0;

d1635 12
a1646 12
			if (ifa6->ia6_flags & IN6_IFF_ANYCAST) {
				/* just experimental. not in the spec. */
				if (ni6->ni_flags & NI_NODEADDR_FLAG_ANYCAST)
					docopy = 1;
				else
					continue;
			}
			else {	/* unicast address */
				if (ni6->ni_flags & NI_NODEADDR_FLAG_ANYCAST)
					continue;
				else
					docopy = 1;
d1648 3
d1654 4
a1657 3
			 case IPV6_ADDR_SCOPE_LINKLOCAL:
				if (ni6->ni_flags & NI_NODEADDR_FLAG_LINKLOCAL)
					docopy = 1;
d1659 9
a1667 3
			 case IPV6_ADDR_SCOPE_SITELOCAL:
				if (ni6->ni_flags & NI_NODEADDR_FLAG_SITELOCAL)
					docopy = 1;
d1669 22
a1690 6
			 case IPV6_ADDR_SCOPE_GLOBAL:
				 if (ni6->ni_flags & NI_NODEADDR_FLAG_GLOBAL)
					 docopy = 1;
				 break;
			 default:
				 continue;
d1693 23
a1715 18
			if (docopy) {
				if (resid < sizeof(struct in6_addr)) {
					/*
					 * We give up much more copy.
					 * Set the truncate flag and return.
					 */
					nni6->ni_flags |=
						NI_NODEADDR_FLAG_TRUNCATE;
					return(copied);
				}
				bcopy(&ifa6->ia_addr.sin6_addr, cp,
				      sizeof(struct in6_addr));
				/* XXX: KAME link-local hack; remove ifindex */
				if (IN6_IS_ADDR_LINKLOCAL(&ifa6->ia_addr.sin6_addr))
					((struct in6_addr *)cp)->s6_addr16[1] = 0;
				cp += sizeof(struct in6_addr);
				resid -= sizeof(struct in6_addr);
				copied += sizeof(struct in6_addr);
d1717 15
d1735 7
@


1.23
log
@bring in icmp rate limitation code.
make icmp6 rate limitation to latest (uses ppsratecheck only).
(sync with netbsd)
TODO: tcp SYN rate limit?
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.22 2000/09/16 08:58:18 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.144 2000/09/15 08:10:45 jinmei Exp $	*/
@


1.22
log
@kame sys/netinet6/icmp6.c 1.140 -> 1.144.
>   in the check for the incoming redirect message, examine the gateway
>   (from the routing table) only when the address family of the gateway is
>   AF_INET6.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.21 2000/08/19 09:17:36 itojun Exp $	*/
a110 2
extern struct timeval icmp6errratelim;
static struct timeval icmp6errratelim_last;
d113 1
a1847 3

	/* reset ICMPv6 pps limit */
	icmp6errpps_count = 0;
a2363 8
 * There are two limitations defined:
 * - pps limit: ICMPv6 error packet cannot exceed defined packet-per-second.
 *   we measure it every 0.2 second, since fasttimo works every 0.2 second.
 * - rate limit: ICMPv6 error packet cannot appear more than once per
 *   defined interval.
 * In any case, if we perform rate limitation, we'll see jitter in the ICMPv6
 * error packets.
 *
d2377 2
a2378 7
	icmp6errpps_count++;
	if (icmp6errppslim && icmp6errpps_count > icmp6errppslim / 5) {
		/* The packet is subject to pps limit */
		ret++;
	}

	if (!ratecheck(&icmp6errratelim_last, &icmp6errratelim)) {
a2468 22
	case ICMPV6CTL_ERRRATELIMIT:
	    {
		int rate_usec, error, s;

		/*
		 * The sysctl specifies the rate in usec-between-icmp,
		 * so we must convert from/to a timeval.
		 */
		rate_usec = (icmp6errratelim.tv_sec * 1000000) +
		    icmp6errratelim.tv_usec;
		error = sysctl_int(oldp, oldlenp, newp, newlen, &rate_usec);
		if (error)
			return (error);
		if (rate_usec < 0)
			return (EINVAL);
		s = splsoftnet();
		icmp6errratelim.tv_sec = rate_usec / 1000000;
		icmp6errratelim.tv_usec = rate_usec % 1000000;
		splx(s);

		return (0);
	    }
@


1.21
log
@- upgrade icmp6 node information query support to 06 draft.
- pedant: possible alignment issue in ALIGN > 8 arch (should be okay for now)
(sync with kame)
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.20 2000/08/03 14:39:23 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.134 2000/08/19 02:01:46 itojun Exp $	*/
d1939 10
@


1.20
log
@typo in #define.  ICMP6_NI_SUCESS -> SUCCESS.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.19 2000/07/06 10:11:24 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.130 2000/08/03 14:22:10 itojun Exp $	*/
d1037 2
a1038 2
 * Process a Node Information Query packet, (roughly) based on
 * draft-ietf-ipngwg-icmp-name-lookups-05.
a1043 1
 * - "Supported Qtypes" support missing
d1083 2
a1084 18
	 * - Responder's unicast/anycast address,
	 * - link-local multicast address
	 * This is a violation to last paragraph in icmp-name-lookups-05
	 * page 4, which restricts IPv6 destination address of a query to:
	 * - Responder's unicast/anycast address,
	 * - NI group address for a name belongs to the Responder, or
	 * - NI group address for a name for which the Responder is providing
	 *   proxy service.
	 * (note: NI group address is a link-local multicast address)
	 *
	 * We allow any link-local multicast address, since "ping6 -w ff02::1"
	 * has been really useful for us debugging our network.  Also this is
	 * still questionable if the restriction in spec buy us security at all,
	 * since RFC2463 permits echo packet to multicast destination.
	 * Even if we forbid NI query to ff02::1, we can effectively get the
	 * same result as "ping6 -w ff02::1" by the following steps:
	 * - run "ping6 ff02::1", then
	 * - run "ping6 -w" for all addresses replied.
d1104 1
a1104 1
		goto bad;	/* xxx: to be implemented */
d1137 4
a1140 4
		if (subjlen != 0)
			goto bad;
		break;

d1152 2
a1153 1
			if (subjlen == 0) {
d1157 4
a1240 4

	default:
		/* should never be here due to "switch (qtype)" above */
		goto bad;
d1273 1
d1277 7
a1283 1
		goto bad;	/* xxx: to be implemented */
d1285 1
d1287 1
d1308 4
a1311 6
		if (n->m_flags & M_EXT)
			lenlim = MCLBYTES - sizeof(struct ip6_hdr) -
				sizeof(struct icmp6_nodeinfo);
		else
			lenlim = MHLEN - sizeof(struct ip6_hdr) -
				sizeof(struct icmp6_nodeinfo);
a1322 1
	nni6->ni_code = ICMP6_NI_SUCCESS;
d1434 1
d2133 2
a2134 1
	maxlen = (m->m_flags & M_EXT) ? MCLBYTES : MHLEN;
@


1.19
log
@- more icmp6/ip6 stats.
- protect IPv6 ND from being hosed (due to neighbor unreachability detection
  hint) by wrong tcp traffic.  still not sure if there's real attack, but
  it is good to be cautious.
- avoid bitfield for router renumbering header decl.
- implement packet-per-sec limitation for icmp6 errors, turn interval
  limit off (it is not very useful due to unix timer resolution).
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.18 2000/06/13 17:32:47 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.119 2000/07/03 14:16:46 itojun Exp $	*/
d1332 1
a1332 1
	nni6->ni_code = ICMP6_NI_SUCESS;
@


1.18
log
@the last commit was not enough. s/(int)/(signed char)/.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.17 2000/06/13 16:36:11 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.113 2000/06/12 09:24:41 itojun Exp $	*/
d112 3
d119 1
d146 58
d220 3
d1701 4
d1858 3
d2097 2
d2245 2
d2317 1
d2366 8
d2382 3
a2384 1
	static struct timeval icmp6errratelim_last;
d2386 13
a2398 5
	/*
	 * ratecheck() returns true if it is okay to send.  We return
	 * true if it is not okay to send.
	 */
	return (ratecheck(&icmp6errratelim_last, &icmp6errratelim) == 0);
d2519 5
@


1.17
log
@workaround for arch with char == unsigned char (suppress warning).
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.16 2000/06/12 17:24:26 itojun Exp $	*/
d1409 1
a1409 1
		if ((int)a[0] < 0 || (int)b[0] < 0)
@


1.16
log
@update icmp6 name lookup code to conform to 05 draft.  previous code
was 03/05 chimera.

ping6: -n by default due to too many false error report due to too long
reverse query delay.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.15 2000/05/22 11:17:51 itojun Exp $	*/
d1409 1
a1409 1
		if (a[0] < 0 || b[0] < 0)
@


1.15
log
@disallow negative number for rate limit period.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.14 2000/05/22 10:32:51 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.88 2000/05/11 00:58:53 itojun Exp $	*/
d121 3
a123 1
static struct mbuf * ni6_input __P((struct mbuf *, int));
a546 2
		if (code != 0)
			goto badcode;
d552 1
a552 1
		else if (icmp6len >= sizeof(struct icmp6_hdr) + 8) /* XXX */
d565 2
a566 2
			if (n)
				noff = sizeof(struct ip6_hdr);
d571 2
d606 1
a606 1
			bcopy(hostname, p + 4, maxhlen);
d972 10
a981 1
 * Process a Node Information Query
a985 1

d994 1
d999 4
d1004 1
d1014 37
d1052 136
d1189 3
a1191 30
	switch(qtype) {
	 case NI_QTYPE_NOOP:
		 break;		/* no reply data */
	 case NI_QTYPE_SUPTYPES:
		 goto bad;	/* xxx: to be implemented */
		 break;
	 case NI_QTYPE_FQDN:
		 replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_name) +
			 hostnamelen;
		 break;
	 case NI_QTYPE_NODEADDR:
		 addrs = ni6_addrs(ni6, m, &ifp);
		 if ((replylen += addrs * sizeof(struct in6_addr)) > MCLBYTES)
			 replylen = MCLBYTES; /* XXX: we'll truncate later */
		
		 break;
	 default:
		 /*
		  * XXX: We must return a reply with the ICMP6 code
		  * `unknown Qtype' in this case. However we regard the case
		  * as an FQDN query for backward compatibility.
		  * Older versions set a random value to this field,
		  * so it rarely varies in the defined qtypes.
		  * But the mechanism is not reliable...
		  * maybe we should obsolete older versions.
		  */
		 qtype = NI_QTYPE_FQDN;
		 replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_name) +
			 hostnamelen;
		 break;
d1202 1
a1202 1
		if (replylen > MCLBYTES)
d1208 1
d1223 41
a1263 39
	 case NI_QTYPE_NOOP:
		 nni6->ni_flags = 0;
		 break;
	 case NI_QTYPE_SUPTYPES:
		 goto bad;	/* xxx: to be implemented */
		 break;
	 case NI_QTYPE_FQDN:
		 if (hostnamelen > 255) { /* XXX: rare case, but may happen */
			 printf("ni6_input: "
				"hostname length(%d) is too large for reply\n",
				hostnamelen);
			 goto bad;
		 }
		 fqdn = (struct ni_reply_fqdn *)(mtod(n, caddr_t) +
						 sizeof(struct ip6_hdr) +
						 sizeof(struct icmp6_nodeinfo));
		 nni6->ni_flags = 0; /* XXX: meaningless TTL */
		 fqdn->ni_fqdn_ttl = 0;	/* ditto. */
		 fqdn->ni_fqdn_namelen = hostnamelen;
		 bcopy(hostname, &fqdn->ni_fqdn_name[0], hostnamelen);
		 break;
	 case NI_QTYPE_NODEADDR:
	 {
		 int lenlim, copied;

		 if (n->m_flags & M_EXT)
			 lenlim = MCLBYTES - sizeof(struct ip6_hdr) -
				 sizeof(struct icmp6_nodeinfo);
		 else
			 lenlim = MHLEN - sizeof(struct ip6_hdr) -
				 sizeof(struct icmp6_nodeinfo);
		 copied = ni6_store_addrs(ni6, nni6, ifp, lenlim);
		 /* XXX: reset mbuf length */
		 n->m_pkthdr.len = n->m_len = sizeof(struct ip6_hdr) +
			 sizeof(struct icmp6_nodeinfo) + copied;
		 break;
	 }
	 default:
		 break;		/* XXX impossible! */
d1280 162
d1605 1
a1605 5
 * The caller MUST check if the destination is multicast or not.
 * This function is usually called with a unicast destination which
 * can be safely the source of the reply packet. But some exceptions
 * exist(e.g. ECHOREPLY, PATCKET_TOOBIG, "10" in OPTION type).
 * ``off'' points to the icmp6 header, counted from the top of the mbuf.
d1713 1
a1713 1
	 * The IN6_IFF_NOTREADY case would be VERY rare, but is possible when
d1787 1
@


1.14
log
@use ratecheck(9) for ICMPv6 rate limitation.  sync with netbsd-current.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.13 2000/05/15 11:45:35 itojun Exp $	*/
d2078 2
@


1.13
log
@perform NUD on p2p link, only if the destination/gateway is real neighbor.
this removes temporary workaround (no NUD on p2p link).  KAME PR 245.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.12 2000/05/15 11:34:46 itojun Exp $	*/
d111 1
a111 1
extern u_int icmp6errratelim;
a131 1
static struct timeval icmp6_nextsend = {0, 0};
d1973 1
a1973 2
	struct timeval tp;
	long sec_diff, usec_diff;
d1975 5
a1979 21
	/* If we are not doing rate limitation, it is always okay to send */
	if (!icmp6errratelim)
		return 0;

	tp = time;
	if (tp.tv_sec < icmp6_nextsend.tv_sec
	 || (tp.tv_sec == icmp6_nextsend.tv_sec
	  && tp.tv_usec < icmp6_nextsend.tv_usec)) {
		/* The packet is subject to rate limit */
		return 1;
	}
	sec_diff = icmp6errratelim / 1000000;
	usec_diff = icmp6errratelim % 1000000;
	icmp6_nextsend.tv_sec = tp.tv_sec + sec_diff;
	if ((tp.tv_usec = tp.tv_usec + usec_diff) >= 1000000) {
		icmp6_nextsend.tv_sec++;
		icmp6_nextsend.tv_usec -= 1000000;
	}

	/* it is okay to send this */
	return 0;
d2066 19
a2084 2
		return sysctl_int(oldp, oldlenp, newp, newlen,
				  &icmp6errratelim);
@


1.12
log
@remove whitespace at EOL
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.11 2000/04/13 14:08:50 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.75 2000/03/11 09:32:17 itojun Exp $	*/
d1700 1
d1717 7
a1723 1
	if (nd6_is_addr_neighbor(&sip6->ip6_src, ifp) == 0)
@


1.11
log
@do not return icmp6 error against icmp6 error.
(this is due to a bug in header chain chasing)
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.10 2000/03/22 03:50:35 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d131 1
a131 1
#endif 
d382 1
a382 1
#endif 
d975 1
a975 1
#endif 
d1015 1
a1015 1
		 
d1044 1
a1044 1
			  * probably much larger than IPV6_MMTU... 
d1056 1
a1056 1
	nni6 = (struct icmp6_nodeinfo *)(mtod(n, struct ip6_hdr *) + 1); 
d1300 1
a1300 1
#endif 
d1387 1
a1387 1
#endif 
d1420 1
a1420 1
	if (src == 0) 
d2003 1
a2003 1
    
d2008 1
a2008 1
		error = rtrequest((int) RTM_ADD, dst, 
d2010 1
a2010 1
		    (struct sockaddr *) 0, 
d2038 1
a2038 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) == 
@


1.10
log
@aintroduce ip6_{next,last}hdr which lets us parse IPv6 header chain correctly.
use it from icmp6 code.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.9 2000/02/28 14:30:40 itojun Exp $	*/
d190 1
a190 1
	off = ip6_lasthdr(m, sizeof(struct ip6_hdr), oip6->ip6_nxt, &nxt);
@


1.9
log
@fix ICMPv6 redirect input.  the bug can result in invalid ND entry.
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.8 2000/02/28 14:05:59 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.71 2000/02/28 09:25:42 jinmei Exp $	*/
d153 1
a153 1
	u_char nxt;
d186 2
a187 1
	 * If the erroneous packet is also an ICMP error, discard it.
d189 3
a191 4
	off = sizeof(struct ip6_hdr);
	nxt = oip6->ip6_nxt;
	while (1) {		/* XXX: should avoid inf. loop explicitly? */
		struct ip6_ext *ip6e;
a193 16
		switch(nxt) {
		case IPPROTO_IPV6:
		case IPPROTO_IPV4:
		case IPPROTO_UDP:
		case IPPROTO_TCP:
		case IPPROTO_ESP:
		case IPPROTO_IPCOMP:
		case IPPROTO_FRAGMENT:
			/*
			 * ICMPv6 error must not be fragmented.
			 * XXX: but can we trust the sender?
			 */
		default:
			/* What if unknown header followed by ICMP error? */
			goto generate;
		case IPPROTO_ICMPV6:
d195 2
a196 2
			IP6_EXTHDR_CHECK(m, 0, off + sizeof(struct icmp6_hdr), );
			icp = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
d198 6
a203 6
			IP6_EXTHDR_GET(icp, struct icmp6_hdr *, m, off,
				sizeof(*icp));
			if (icp == NULL) {
				icmp6stat.icp6s_tooshort++;
				return;
			}
d205 11
a215 34
			if (icp->icmp6_type < ICMP6_ECHO_REQUEST
			 || icp->icmp6_type == ND_REDIRECT) {
				/*
				 * ICMPv6 error
				 * Special case: for redirect (which is
				 * informational) we must not send icmp6 error.
				 */
				icmp6stat.icp6s_canterror++;
				goto freeit;
			} else {
				/* ICMPv6 informational */
				goto generate;
			}
		case IPPROTO_HOPOPTS:
		case IPPROTO_DSTOPTS:
		case IPPROTO_ROUTING:
		case IPPROTO_AH:
#ifndef PULLDOWN_TEST
			IP6_EXTHDR_CHECK(m, 0, off + sizeof(struct ip6_ext), );
			ip6e = (struct ip6_ext *)(mtod(m, caddr_t) + off);
#else
			IP6_EXTHDR_GET(ip6e, struct ip6_ext *, m, off,
				sizeof(*ip6e));
			if (ip6e == NULL) {
				/*XXX stat */
				return;
			}
#endif
			if (nxt == IPPROTO_AH)
				off += (ip6e->ip6e_len + 2) << 2;
			else
				off += (ip6e->ip6e_len + 1) << 3;
			nxt = ip6e->ip6e_nxt;
			break;
d217 2
a220 8
  freeit:
	/*
	 * If we can't tell wheter or not we can generate ICMP6, free it.
	 */
	m_freem(m);
	return;

  generate:
d261 8
@


1.8
log
@upgrade node information query protocol support from 04 draft to
draft-ietf-ipngwg-icmp-name-lookups-05.txt.

NOTE: 04 and 05 has no interoperability, in terms of "ping6 -a".
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.7 2000/02/28 11:55:21 itojun Exp $	*/
a1546 5
	if (IN6_IS_ADDR_LINKLOCAL(&redtgt6))
		redtgt6.s6_addr16[1] = htons(ifp->if_index);
	if (IN6_IS_ADDR_LINKLOCAL(&reddst6))
		reddst6.s6_addr16[1] = htons(ifp->if_index);

d1559 5
@


1.7
log
@bring in recent KAME changes (only important and stable ones, as usual).
- remove net.inet6.ip6.nd6_proxyall.  introduce proxy NDP code works
  just like "arp -s".
- revise source address selection.
  be more careful about use of yet-to-be-valid addresses as source.
- as router, transmit ICMP6_DST_UNREACH_BEYONDSCOPE against out-of-scope
  packet forwarding attempt.
- path MTU discovery takes care of routing header properly.
- be more strict about mbuf chain parsing.
- nuke xxCTL_VARS #define, they are for BSDI.
- disable SIOCSIFDSTADDR_IN6/SIOCSIFNETMASK_IN6 ioctl, they do not fit
  IPv6 model where multiple address on interface is normal.
  (kernel side supports them for a while for backward compat,
  the support will be nuked shortly)
- introduce "default outgoing interface" (for spec conformance in very
  rare case)
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.6 2000/02/07 06:09:09 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.70 2000/02/26 07:01:11 itojun Exp $	*/
d1181 10
@


1.6
log
@fix include file path related to ip6.
@
text
@d1 2
a2 1
/*	$OpenBSD: icmp6.c,v 1.5 2000/01/08 13:54:36 itojun Exp $	*/
d116 2
d151 1
a151 1
	u_int prep;
d200 1
d281 4
a284 4
	prep = sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr);
	M_PREPEND(m, prep, M_DONTWAIT);
	if (m && m->m_len < prep)
		m = m_pullup(m, prep);
d405 2
d408 1
a408 1
			code = PRC_UNREACH_HOST;
d410 1
d414 6
a432 4
	    {
		u_int mtu = ntohl(icmp6->icmp6_mtu);
		struct rtentry *rt = NULL;
		struct sockaddr_in6 sin6;
a433 17
		if (icmp6len < sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr)) {
			icmp6stat.icp6s_tooshort++;
			goto freeit;
		}
#ifndef PULLDOWN_TEST
		IP6_EXTHDR_CHECK(m, off,
			sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr),
			IPPROTO_DONE);
		icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
#else
		IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off,
			sizeof(*icmp6) + sizeof(struct ip6_hdr));
		if (icmp6 == NULL) {
			icmp6stat.icp6s_tooshort++;
			return IPPROTO_DONE;
		}
#endif
a434 23
		bzero(&sin6, sizeof(sin6));
		sin6.sin6_family = PF_INET6;
		sin6.sin6_len = sizeof(struct sockaddr_in6);
		sin6.sin6_addr = ((struct ip6_hdr *)(icmp6 + 1))->ip6_dst;
		rt = rtalloc1((struct sockaddr *)&sin6, 1);	/*clone*/
		if (!rt || (rt->rt_flags & RTF_HOST) == 0) {
			if (rt)
				RTFREE(rt);
			rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6);
		}

		if (rt && (rt->rt_flags & RTF_HOST)
		    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
			if (mtu < IPV6_MMTU) {
				/* xxx */
				rt->rt_rmx.rmx_locks |= RTV_MTU;
			} else if (mtu < rt->rt_ifp->if_mtu &&
				   rt->rt_rmx.rmx_mtu > mtu) {
				rt->rt_rmx.rmx_mtu = mtu;
			}
		}
		if (rt)
			RTFREE(rt);
d436 4
a440 1
	    }
d483 1
d489 8
d498 7
d557 7
a563 2
		IP6_EXTHDR_CHECK(m, off, icmp6len, IPPROTO_DONE);
		mld6_input(m, off);
d577 1
a577 1
		break;		/* just pass it to the userland daemon */
d607 1
d609 8
d618 7
d629 4
d642 1
a642 1
			bcopy(hostname, p + 4, hostnamelen);
d646 1
a646 1
				sizeof(struct icmp6_hdr) + 4 + hostnamelen;
d670 7
a676 2
		IP6_EXTHDR_CHECK(m, off, icmp6len, IPPROTO_DONE);
		nd6_rs_input(m, off, icmp6len);
d686 7
a692 2
		IP6_EXTHDR_CHECK(m, off, icmp6len, IPPROTO_DONE);
		nd6_ra_input(m, off, icmp6len);
d702 7
a708 2
		IP6_EXTHDR_CHECK(m, off, icmp6len, IPPROTO_DONE);
		nd6_ns_input(m, off, icmp6len);
d718 7
a724 2
		IP6_EXTHDR_CHECK(m, off, icmp6len, IPPROTO_DONE);
		nd6_na_input(m, off, icmp6len);
d734 7
a740 1
		icmp6_redirect_input(m, off);
d796 6
a806 3
			case IPPROTO_ESP:
			case IPPROTO_NONE:
				goto passit;
a808 1
			case IPPROTO_ROUTING:
a809 1
			case IPPROTO_FRAGMENT:
d824 1
a826 2
				else if (nxt == IPPROTO_FRAGMENT)
					eoff += sizeof(struct ip6_frag);
d831 83
d915 8
d937 6
a962 1
 passit:
d971 36
d1418 3
d1424 1
a1424 1
		    (ia->ia6_flags & IN6_IFF_ANYCAST) == 0) {
d1438 5
a1442 3
		 * We have not multicast routing yet. So this case matches
		 * to our multicast, our anycast or not to our unicast.
		 * Select a source address which has the same scope.
d1514 1
a1514 1
	struct nd_redirect *nd_rd = (struct nd_redirect *)((caddr_t)ip6 + off);
d1524 2
a1525 2
	struct in6_addr redtgt6 = nd_rd->nd_rd_target;
	struct in6_addr reddst6 = nd_rd->nd_rd_dst;
d1533 1
a1533 1
		return;
d1535 1
a1535 1
		return;
d1542 13
d1560 1
a1560 1
		return;
d1567 1
a1567 1
		return;
d1589 1
a1589 1
			return;
d1596 1
a1596 1
		return;
d1606 1
a1606 1
		return;
d1619 1
a1619 1
		return;
d1629 1
a1629 1
		return;
d1707 3
d1757 3
d1761 2
a1764 2
	if (MHLEN < IPV6_MMTU)
		MCLGET(m, M_DONTWAIT);
d1768 2
a1769 1
	if (maxlen < sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr))
d1771 1
d1775 4
a1778 2
		struct in6_ifaddr *ia = in6ifa_ifpforlinklocal(ifp);
		if (ia == NULL)
d1845 5
a1856 2
		len = 2 + ifp->if_addrlen;
		len = (len + 7) & ~7;	/*round by 8*/
a1857 1
		p += len;
d1860 1
a2116 2
	case ICMPV6CTL_ND6_PROXYALL:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_proxyall);
@


1.6.2.1
log
@Sync with -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$KAME: icmp6.c,v 1.71 2000/02/28 09:25:42 jinmei Exp $	*/
a114 2
static void icmp6_mtudisc_update __P((struct in6_addr *, struct icmp6_hdr *,
				      struct mbuf *));
d148 1
a148 1
	u_int preplen;
a196 1
		case IPPROTO_IPCOMP:
d277 4
a280 4
	preplen = sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr);
	M_PREPEND(m, preplen, M_DONTWAIT);
	if (m && m->m_len < preplen)
		m = m_pullup(m, preplen);
a400 2
			code = PRC_UNREACH_PROTOCOL; /* is this a good code? */
			break;
d402 1
a402 1
			code = PRC_HOSTDEAD;
a403 1
#ifdef COMPAT_RFC1885
a406 6
#else
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			/* I mean "source address was incorrect." */
			code = PRC_PARAMPROB;
			break;
#endif 
d420 4
d425 17
d443 23
a466 4
		/*
		 * Updating the path MTU will be done after examining
		 * intermediate extension headers.
		 */
d468 1
a510 1
			const int maxlen = sizeof(*nip6) + sizeof(*nicmp6);
a515 8
			if (maxlen >= MCLBYTES) {
#ifdef DIAGNOSTIC
				printf("MCLBYTES too small\n");
#endif
				/* Give up remote */
				m_freem(n0);
				break;
			}
a516 7
			if (n && maxlen >= MHLEN) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
d569 2
a570 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			mld6_input(m, off);
			m = NULL;
			goto freeit;
		}
		mld6_input(n, off);
d584 1
a584 1
		break;		/* just pass it to applications */
a613 1
			int maxlen, maxhlen;
a614 8
			maxlen = sizeof(*nip6) + sizeof(*nicmp6) + 4;
			if (maxlen >= MCLBYTES) {
#ifdef DIAGNOSTIC
				printf("MCLBYTES too small\n");
#endif
				/* Give up remote */
				break;
			}
a615 7
			if (n && maxlen > MHLEN) {
				MCLGET(n, M_DONTWAIT);
				if ((n->m_flags & M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
a619 4
			n->m_len = 0;
			maxhlen = M_TRAILINGSPACE(n) - maxlen;
			if (maxhlen > hostnamelen)
				maxhlen = hostnamelen;
d629 1
a629 1
			bcopy(hostname, p + 4, maxhlen);
d633 1
a633 1
				sizeof(struct icmp6_hdr) + 4 + maxhlen;
d657 2
a658 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_rs_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_rs_input(n, off, icmp6len);
d668 2
a669 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_ra_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_ra_input(n, off, icmp6len);
d679 2
a680 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_ns_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_ns_input(n, off, icmp6len);
d690 2
a691 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			nd6_na_input(m, off, icmp6len);
			m = NULL;
			goto freeit;
		}
		nd6_na_input(n, off, icmp6len);
d701 1
a701 7
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* give up local */
			icmp6_redirect_input(m, off);
			m = NULL;
			goto freeit;
		}
		icmp6_redirect_input(n, off);
a756 6
		struct in6_addr *finaldst = NULL;
		int icmp6type = icmp6->icmp6_type;
		struct ip6_frag *fh;
		struct ip6_rthdr *rth;
		struct ip6_rthdr0 *rth0;
		int rthlen;
d762 3
d767 1
d769 1
a783 1
				
d786 2
a791 83
			case IPPROTO_ROUTING:
				/*
				 * When the erroneous packet contains a
				 * routing header, we should examine the
				 * header to determine the final destination.
				 * Otherwise, we can't properly update
				 * information that depends on the final
				 * destination (e.g. path MTU).
				 */
#ifndef PULLDOWN_TEST
				IP6_EXTHDR_CHECK(m, 0, eoff + sizeof(*rth),
						 IPPROTO_DONE);
				rth = (struct ip6_rthdr *)(mtod(m, caddr_t)
							   + eoff);
#else
				IP6_EXTHDR_GET(rth, struct ip6_rthdr *, m,
					eoff, sizeof(*rth));
				if (rth == NULL) {
					icmp6stat.icp6s_tooshort++;
					return IPPROTO_DONE;
				}
#endif
				rthlen = (rth->ip6r_len + 1) << 3;
				/*
				 * XXX: currently there is no
				 * officially defined type other
				 * than type-0.
				 * Note that if the segment left field
				 * is 0, all intermediate hops must
				 * have been passed.
				 */
				if (rth->ip6r_segleft &&
				    rth->ip6r_type == IPV6_RTHDR_TYPE_0) {
					int hops;

#ifndef PULLDOWN_TEST
					IP6_EXTHDR_CHECK(m, 0, eoff + rthlen,
							 IPPROTO_DONE);
					rth0 = (struct ip6_rthdr0 *)(mtod(m, caddr_t) + eoff);
#else
					IP6_EXTHDR_GET(rth0,
						       struct ip6_rthdr0 *, m,
						       eoff, rthlen);
					if (rth0 == NULL) {
						icmp6stat.icp6s_tooshort++;
						return IPPROTO_DONE;
					}
#endif
					/* just ignore a bogus header */
					if ((rth0->ip6r0_len % 2) == 0 &&
					    (hops = rth0->ip6r0_len/2))
						finaldst = (struct in6_addr *)(rth0 + 1) + (hops - 1);
				}
				eoff += rthlen;
				nxt = rth->ip6r_nxt;
				break;
			case IPPROTO_FRAGMENT:
#ifndef PULLDOWN_TEST
				IP6_EXTHDR_CHECK(m, 0, eoff +
						 sizeof(struct ip6_frag),
						 IPPROTO_DONE);
				fh = (struct ip6_frag *)(mtod(m, caddr_t)
							 + eoff);
#else
				IP6_EXTHDR_GET(fh, struct ip6_frag *, m,
					eoff, sizeof(*fh));
				if (fh == NULL) {
					icmp6stat.icp6s_tooshort++;
					return IPPROTO_DONE;
				}
#endif
				/*
				 * Data after a fragment header is meaningless
				 * unless it is the first fragment, but
				 * we'll go to the notify label for path MTU
				 * discovery.
				 */
				if (fh->ip6f_offlg & IP6F_OFF_MASK)
					goto notify;

				eoff += sizeof(struct ip6_frag);
				nxt = fh->ip6f_nxt;
				break;
a792 8
				/*
				 * This case includes ESP and the No Next
				 * Header. In such cases going to the notify
				 * label does not have any meaning
				 * (i.e. ctlfunc will be NULL), but we go
				 * anyway since we might have to update
				 * path MTU information.
				 */
a806 6
		if (icmp6type == ICMP6_PACKET_TOO_BIG) {
			if (finaldst == NULL)
				finaldst = &((struct ip6_hdr *)(icmp6 + 1))->ip6_dst;
			icmp6_mtudisc_update(finaldst, icmp6, m);
		}

d827 1
a835 36
static void
icmp6_mtudisc_update(dst, icmp6, m)
	struct in6_addr *dst;
	struct icmp6_hdr *icmp6;/* we can assume the validity of the pointer */
	struct mbuf *m;	/* currently unused but added for scoped addrs */
{
	u_int mtu = ntohl(icmp6->icmp6_mtu);
	struct rtentry *rt = NULL;
	struct sockaddr_in6 sin6;

	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = PF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	sin6.sin6_addr = *dst;
	/* sin6.sin6_scope_id = XXX: should be set if DST is a scoped addr */
	rt = rtalloc1((struct sockaddr *)&sin6, 1);	/*clone*/
	if (!rt || (rt->rt_flags & RTF_HOST) == 0) {
		if (rt)
			RTFREE(rt);
		rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6);
	}

	if (rt && (rt->rt_flags & RTF_HOST)
	    && !(rt->rt_rmx.rmx_locks & RTV_MTU)) {
		if (mtu < IPV6_MMTU) {
				/* xxx */
			rt->rt_rmx.rmx_locks |= RTV_MTU;
		} else if (mtu < rt->rt_ifp->if_mtu &&
			   rt->rt_rmx.rmx_mtu > mtu) {
			rt->rt_rmx.rmx_mtu = mtu;
		}
	}
	if (rt)
		RTFREE(rt);
}

a1010 10
			/*
			 * IPv4-mapped addresses can only be returned by a
			 * Node Information proxy, since they represent
			 * addresses of IPv4-only nodes, which perforce do
			 * not implement this protocol.
			 * [icmp-name-lookups-05]
			 * So we don't support NI_NODEADDR_FLAG_COMPAT in
			 * this function at this moment.
			 */

a1246 3
	 * The IN6_IFF_NOTREADY case would be VERY rare, but is possible when
	 * (for example) when we encounter an error while forwarding procedure
	 * destined to a duplicated address of ours.
d1250 1
a1250 1
		    (ia->ia6_flags & (IN6_IFF_ANYCAST|IN6_IFF_NOTREADY)) == 0) {
d1264 3
a1266 5
		 * This case matches to multicasts, our anycast, or unicasts
		 * that we do not own. Select a source address which has the
		 * same scope.
		 * XXX: for (non link-local) multicast addresses, this might
		 * not be a good choice.
d1338 1
a1338 1
	struct nd_redirect *nd_rd;
d1348 2
a1349 2
	struct in6_addr redtgt6;
	struct in6_addr reddst6;
d1357 1
a1357 1
		goto freeit;
a1358 9
		goto freeit;

#ifndef PULLDOWN_TEST
	IP6_EXTHDR_CHECK(m, off, icmp6len,);
	nd_rd = (struct nd_redirect *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(nd_rd, struct nd_redirect *, m, off, icmp6len);
	if (nd_rd == NULL) {
		icmp6stat.icp6s_tooshort++;
a1359 4
	}
#endif
	redtgt6 = nd_rd->nd_rd_target;
	reddst6 = nd_rd->nd_rd_dst;
d1371 1
a1371 1
		goto freeit;
d1378 1
a1378 1
		goto freeit;
d1400 1
a1400 1
			goto freeit;
d1407 1
a1407 1
		goto freeit;
d1417 1
a1417 1
		goto freeit;
d1430 1
a1430 1
		goto freeit;
d1440 1
a1440 1
		goto freeit;
a1517 3

 freeit:
	m_freem(m);
a1564 3
#if IPV6_MMTU >= MCLBYTES
# error assumption failed about IPV6_MMTU and MCLBYTES
#endif
a1565 2
	if (m && IPV6_MMTU >= MHLEN)
		MCLGET(m, M_DONTWAIT);
d1568 2
d1573 1
a1573 2
	if (maxlen < sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) +
	    ((sizeof(struct nd_opt_hdr) + ifp->if_addrlen + 7) & ~7)) {
a1574 1
	}
d1578 2
a1579 4
		struct in6_ifaddr *ia;
		if ((ia = in6ifa_ifpforlinklocal(ifp,
						 IN6_IFF_NOTREADY|
						 IN6_IFF_ANYCAST)) == NULL)
a1645 5
	len = sizeof(*nd_opt) + ifp->if_addrlen;
	len = (len + 7) & ~7;	/*round by 8*/
	/* safety check */
	if (len + (p - (u_char *)ip6) > maxlen)
		goto nolladdropt;
d1653 2
d1656 1
a1658 1
		p += len;
d1915 2
@


1.6.2.2
log
@Sync with -current
@
text
@d2 1
a2 1
/*	$KAME: icmp6.c,v 1.75 2000/03/11 09:32:17 itojun Exp $	*/
d153 1
a153 1
	int nxt;
d186 1
a186 2
	 * If we are about to send ICMPv6 against ICMPv6 error/redirect,
	 * don't do it.
d188 4
a191 3
	nxt = -1;
	off = ip6_lasthdr(m, sizeof(struct ip6_hdr), oip6->ip6_nxt, &nxt);
	if (off >= 0 && nxt == IPPROTO_ICMPV6) {
d194 44
d239 2
a240 2
		IP6_EXTHDR_CHECK(m, 0, off + sizeof(struct icmp6_hdr), );
		icp = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
d242 6
a247 6
		IP6_EXTHDR_GET(icp, struct icmp6_hdr *, m, off,
			sizeof(*icp));
		if (icp == NULL) {
			icmp6stat.icp6s_tooshort++;
			return;
		}
d249 6
a254 11
		if (icp->icmp6_type < ICMP6_ECHO_REQUEST ||
		    icp->icmp6_type == ND_REDIRECT) {
			/*
			 * ICMPv6 error
			 * Special case: for redirect (which is
			 * informational) we must not send icmp6 error.
			 */
			icmp6stat.icp6s_canterror++;
			goto freeit;
		} else {
			/* ICMPv6 informational - send the error */
a255 2
	} else {
		/* non-ICMPv6 - send the error */
d258 8
a305 8

	return;

  freeit:
	/*
	 * If we can't tell wheter or not we can generate ICMP6, free it.
	 */
	m_freem(m);
@


1.6.2.3
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: icmp6.c,v 1.39 2001/04/04 06:03:45 itojun Exp $	*/
/*	$KAME: icmp6.c,v 1.205 2001/03/21 07:48:57 itojun Exp $	*/
d7 1
a7 1
 *
d19 1
a19 1
 *
a103 27
/* inpcb members */
#define in6pcb		inpcb
#define in6p_laddr	inp_laddr6
#define in6p_faddr	inp_faddr6
#define in6p_icmp6filt	inp_icmp6filt
#define in6p_route	inp_route
#define in6p_socket	inp_socket
#define in6p_flags	inp_flags
#define in6p_moptions	inp_moptions6
#define in6p_outputopts	inp_outputopts6
#define in6p_ip6	inp_ipv6
#define in6p_flowinfo	inp_flowinfo
#define in6p_sp		inp_sp
#define in6p_next	inp_next
#define in6p_prev	inp_prev
/* macro names */
#define sotoin6pcb	sotoinpcb
/* function names */
#define in6_pcbdetach	in_pcbdetach
#define in6_rtchange	in_rtchange

/*
 * for KAME src sync over BSD*'s. XXX: FreeBSD (>=3) are VERY different from
 * others...
 */
#define in6p_ip6_nxt	inp_ipv6.ip6_nxt

d110 2
a111 4
extern struct inpcbtable rawin6pcbtable;
extern int icmp6errppslim;
static int icmp6errpps_count = 0;
static struct timeval icmp6errppslim_last;
a112 12

/*
 * List of callbacks to notify when Path MTU changes are made.
 */
struct icmp6_mtudisc_callback {
	LIST_ENTRY(icmp6_mtudisc_callback) mc_list;
	void (*mc_func) __P((struct in6_addr *));
};

LIST_HEAD(, icmp6_mtudisc_callback) icmp6_mtudisc_callbacks =
    LIST_HEAD_INITIALIZER(&icmp6_mtudisc_callbacks);

d116 2
a117 15
/* XXX do these values make any sense? */
static int icmp6_mtudisc_hiwat = 1280;
static int icmp6_mtudisc_lowat = 256;

/*
 * keep track of # of redirect routes.
 */
static struct rttimer_queue *icmp6_redirect_timeout_q = NULL;

/* XXX experimental, turned off */
static int icmp6_redirect_hiwat = -1;
static int icmp6_redirect_lowat = -1;

static void icmp6_errcount __P((struct icmp6errstat *, int, int));
static int icmp6_rip6_input __P((struct mbuf **, int));
d121 1
a121 3
static struct mbuf *ni6_input __P((struct mbuf *, int));
static struct mbuf *ni6_nametodns __P((const char *, int, int));
static int ni6_dnsmatch __P((const char *, int, const char *, int));
d123 1
a123 1
			  struct ifnet **, char *));
a125 1
static int icmp6_notify_error __P((struct mbuf *, int, int, int));
a127 1
static void icmp6_redirect_timeout __P((struct rtentry *, struct rttimer *));
d131 2
a132 1
#endif
a138 82
	icmp6_redirect_timeout_q = rt_timer_queue_create(icmp6_redirtimeout);
}

static void
icmp6_errcount(stat, type, code)
	struct icmp6errstat *stat;
	int type, code;
{
	switch (type) {
	case ICMP6_DST_UNREACH:
		switch (code) {
		case ICMP6_DST_UNREACH_NOROUTE:
			stat->icp6errs_dst_unreach_noroute++;
			return;
		case ICMP6_DST_UNREACH_ADMIN:
			stat->icp6errs_dst_unreach_admin++;
			return;
		case ICMP6_DST_UNREACH_BEYONDSCOPE:
			stat->icp6errs_dst_unreach_beyondscope++;
			return;
		case ICMP6_DST_UNREACH_ADDR:
			stat->icp6errs_dst_unreach_addr++;
			return;
		case ICMP6_DST_UNREACH_NOPORT:
			stat->icp6errs_dst_unreach_noport++;
			return;
		}
		break;
	case ICMP6_PACKET_TOO_BIG:
		stat->icp6errs_packet_too_big++;
		return;
	case ICMP6_TIME_EXCEEDED:
		switch (code) {
		case ICMP6_TIME_EXCEED_TRANSIT:
			stat->icp6errs_time_exceed_transit++;
			return;
		case ICMP6_TIME_EXCEED_REASSEMBLY:
			stat->icp6errs_time_exceed_reassembly++;
			return;
		}
		break;
	case ICMP6_PARAM_PROB:
		switch (code) {
		case ICMP6_PARAMPROB_HEADER:
			stat->icp6errs_paramprob_header++;
			return;
		case ICMP6_PARAMPROB_NEXTHEADER:
			stat->icp6errs_paramprob_nextheader++;
			return;
		case ICMP6_PARAMPROB_OPTION:
			stat->icp6errs_paramprob_option++;
			return;
		}
		break;
	case ND_REDIRECT:
		stat->icp6errs_redirect++;
		return;
	}
	stat->icp6errs_unknown++;
}

/*
 * Register a Path MTU Discovery callback.
 */
void
icmp6_mtudisc_callback_register(func)
	void (*func) __P((struct in6_addr *));
{
	struct icmp6_mtudisc_callback *mc;

	for (mc = LIST_FIRST(&icmp6_mtudisc_callbacks); mc != NULL;
	     mc = LIST_NEXT(mc, mc_list)) {
		if (mc->mc_func == func)
			return;
	}

	mc = malloc(sizeof(*mc), M_PCB, M_NOWAIT);
	if (mc == NULL)
		panic("icmp6_mtudisc_callback_register");

	mc->mc_func = func;
	LIST_INSERT_HEAD(&icmp6_mtudisc_callbacks, mc, mc_list);
a156 3
	/* count per-type-code statistics */
	icmp6_errcount(&icmp6stat.icp6s_outerrhist, type, code);

d190 1
a190 1
	off = ip6_lasthdr(m, 0, IPPROTO_IPV6, &nxt);
d241 1
a241 1
		nd6log((LOG_DEBUG, "ENOBUFS in icmp6_error %d\n", __LINE__));
a258 9
	/*
	 * icmp6_reflect() is designed to be in the input path.
	 * icmp6_error() can be called from both input and outut path,
	 * and if we are in output path rcvif could contain bogus value.
	 * clear m->m_pkthdr.rcvif for safety, we should have enough scope
	 * information in ip header (nip6).
	 */
	m->m_pkthdr.rcvif = NULL;

d285 1
d318 1
a318 1
		nd6log((LOG_ERR,
d320 3
a322 1
		    icmp6->icmp6_type, sum, ip6_sprintf(&ip6->ip6_src)));
d348 1
a348 1
		ipsec6stat.in_polvio++;
d382 1
a382 1
#endif
d453 3
a491 1
			n0->m_pkthdr.tdbi = NULL;
d546 2
d553 1
a553 1
		else if (icmp6len >= sizeof(struct icmp6_nodeinfo))
d566 2
a567 2
			/* XXX meaningless if n == NULL */
			noff = sizeof(struct ip6_hdr);
a571 5
			if ((icmp6_nodeinfo & 1) == 0)
				break;

			if (code != 0)
				goto badcode;
d574 3
d605 1
a605 1
			bcopy(hostname, p + 4, maxhlen); /*meaningless TTL*/
d607 1
a607 1
			M_DUP_PKTHDR(n, m); /* just for rcvif */
d716 4
a719 5
		nd6log((LOG_DEBUG,
		    "icmp6_input: unknown type %d(src=%s, dst=%s, ifid=%d)\n",
		    icmp6->icmp6_type, ip6_sprintf(&ip6->ip6_src),
		    ip6_sprintf(&ip6->ip6_dst),
		    m->m_pkthdr.rcvif ? m->m_pkthdr.rcvif->if_index : 0));
d729 3
a731 3
		if (icmp6_notify_error(m, off, icmp6len, code)) {
			/* In this case, m should've been freed. */
			return(IPPROTO_DONE);
a732 35
		break;

	badcode:
		icmp6stat.icp6s_badcode++;
		break;

	badlen:
		icmp6stat.icp6s_badlen++;
		break;
	}

	/* deliver the packet to appropriate sockets */
	icmp6_rip6_input(&m, *offp);

	return IPPROTO_DONE;

 freeit:
	m_freem(m);
	return IPPROTO_DONE;
}

static int
icmp6_notify_error(m, off, icmp6len, code)
	struct mbuf *m;
	int off, icmp6len;
{
	struct icmp6_hdr *icmp6;
	struct ip6_hdr *eip6;
	u_int32_t notifymtu;
	struct sockaddr_in6 icmp6src, icmp6dst;

	if (icmp6len < sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr)) {
		icmp6stat.icp6s_tooshort++;
		goto freeit;
	}
d734 4
a737 4
	IP6_EXTHDR_CHECK(m, off,
			 sizeof(struct icmp6_hdr) + sizeof(struct ip6_hdr),
			 -1);
	icmp6 = (struct icmp6_hdr *)(mtod(m, caddr_t) + off);
d739 6
a744 6
	IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off,
		       sizeof(*icmp6) + sizeof(struct ip6_hdr));
	if (icmp6 == NULL) {
		icmp6stat.icp6s_tooshort++;
		return(-1);
	}
d746 4
a749 1
	eip6 = (struct ip6_hdr *)(icmp6 + 1);
d751 2
a752 2
	/* Detect the upper level protocol */
	{
d754 1
d769 1
a769 1
			switch (nxt) {
d776 1
a776 1
						 -1);
d781 1
a781 1
					       eoff, sizeof(*eh));
d784 1
a784 1
					return(-1);
d805 1
a805 1
						 -1);
d810 1
a810 1
					       eoff, sizeof(*rth));
d813 1
a813 1
					return(-1);
d831 1
a831 1
							 -1);
d839 1
a839 1
						return(-1);
d854 1
a854 1
						 -1);
d859 1
a859 1
					       eoff, sizeof(*fh));
d862 1
a862 1
					return(-1);
d889 1
a889 1
	  notify:
d894 1
a894 1
			       sizeof(*icmp6) + sizeof(struct ip6_hdr));
d897 1
a897 1
			return(-1);
a899 53

		eip6 = (struct ip6_hdr *)(icmp6 + 1);
		bzero(&icmp6dst, sizeof(icmp6dst));
		icmp6dst.sin6_len = sizeof(struct sockaddr_in6);
		icmp6dst.sin6_family = AF_INET6;
		if (finaldst == NULL)
			icmp6dst.sin6_addr = eip6->ip6_dst;
		else
			icmp6dst.sin6_addr = *finaldst;
		icmp6dst.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
							  &icmp6dst.sin6_addr);
#ifndef SCOPEDROUTING
		if (in6_embedscope(&icmp6dst.sin6_addr, &icmp6dst,
				   NULL, NULL)) {
			/* should be impossbile */
			nd6log((LOG_DEBUG,
			    "icmp6_notify_error: in6_embedscope failed\n"));
			goto freeit;
		}
#endif

		/*
		 * retrieve parameters from the inner IPv6 header, and convert
		 * them into sockaddr structures.
		 */
		bzero(&icmp6src, sizeof(icmp6src));
		icmp6src.sin6_len = sizeof(struct sockaddr_in6);
		icmp6src.sin6_family = AF_INET6;
		icmp6src.sin6_addr = eip6->ip6_src;
		icmp6src.sin6_scope_id = in6_addr2scopeid(m->m_pkthdr.rcvif,
							  &icmp6src.sin6_addr);
#ifndef SCOPEDROUTING
		if (in6_embedscope(&icmp6src.sin6_addr, &icmp6src,
				   NULL, NULL)) {
			/* should be impossbile */
			nd6log((LOG_DEBUG,
			    "icmp6_notify_error: in6_embedscope failed\n"));
			goto freeit;
		}
#endif
		icmp6src.sin6_flowinfo =
			(eip6->ip6_flow & IPV6_FLOWLABEL_MASK);

		if (finaldst == NULL)
			finaldst = &eip6->ip6_dst;
		ip6cp.ip6c_m = m;
		ip6cp.ip6c_icmp6 = icmp6;
		ip6cp.ip6c_ip6 = (struct ip6_hdr *)(icmp6 + 1);
		ip6cp.ip6c_off = eoff;
		ip6cp.ip6c_finaldst = finaldst;
		ip6cp.ip6c_src = &icmp6src;
		ip6cp.ip6c_nxt = nxt;

d901 3
a903 2
			notifymtu = ntohl(icmp6->icmp6_mtu);
			ip6cp.ip6c_cmdarg = (void *)&notifymtu;
d909 4
a912 2
			(void) (*ctlfunc)(code, (struct sockaddr *)&icmp6dst,
					  &ip6cp);
d914 10
a924 1
	return(0);
d926 4
a929 1
  freeit:
d931 1
a931 1
	return(-1);
d934 5
a938 4
void
icmp6_mtudisc_update(ip6cp, validated)
	struct ip6ctlparam *ip6cp;
	int validated;
a939 5
	unsigned long rtcount;
	struct icmp6_mtudisc_callback *mc;
	struct in6_addr *dst = ip6cp->ip6c_finaldst;
	struct icmp6_hdr *icmp6 = ip6cp->ip6c_icmp6;
	struct mbuf *m = ip6cp->ip6c_m;	/* will be necessary for scope issue */
a943 19
	/*
	 * allow non-validated cases if memory is plenty, to make traffic
	 * from non-connected pcb happy.
	 */
	rtcount = rt_timer_count(icmp6_mtudisc_timeout_q);
	if (validated) {
		if (0 <= icmp6_mtudisc_hiwat && rtcount > icmp6_mtudisc_hiwat)
			return;
		else if (0 <= icmp6_mtudisc_lowat &&
		    rtcount > icmp6_mtudisc_lowat) {
			/*
			 * XXX nuke a victim, install the new one.
			 */
		}
	} else {
		if (0 <= icmp6_mtudisc_lowat && rtcount > icmp6_mtudisc_lowat)
			return;
	}

d948 6
a953 4
	/* XXX normally, this won't happen */
	if (IN6_IS_ADDR_LINKLOCAL(dst)) {
		sin6.sin6_addr.s6_addr16[1] =
		    htons(m->m_pkthdr.rcvif->if_index);
a954 2
	/* sin6.sin6_scope_id = XXX: should be set if DST is a scoped addr */
	rt = icmp6_mtudisc_clone((struct sockaddr *)&sin6);
a962 1
			icmp6stat.icp6s_pmtuchg++;
a967 8

	/*
	 * Notify protocols that the MTU for this destination
	 * has changed.
	 */
	for (mc = LIST_FIRST(&icmp6_mtudisc_callbacks); mc != NULL;
	     mc = LIST_NEXT(mc, mc_list))
		(*mc->mc_func)(&sin6.sin6_addr);
d971 1
a971 9
 * Process a Node Information Query packet, based on
 * draft-ietf-ipngwg-icmp-name-lookups-07.
 * 
 * Spec incompatibilities:
 * - IPv6 Subject address handling
 * - IPv4 Subject address handling support missing
 * - Proxy reply (answer even if it's not for me)
 * - joins NI group address at in6_ifattach() time only, does not cope
 *   with hostname changes by sethostname(3)
d975 2
a976 1
#endif
a984 1
	int subjlen;
a988 4
	struct sockaddr_in6 sin6; /* double meaning; ip6_dst and subjectaddr */
	struct ip6_hdr *ip6;
	int oldfqdn = 0;	/* if 1, return pascal string (03 draft) */
	char *subj = NULL;
a989 1
	ip6 = mtod(m, struct ip6_hdr *);
a998 22

	/*
	 * Validate IPv6 destination address.
	 *
	 * The Responder must discard the Query without further processing
	 * unless it is one of the Responder's unicast or anycast addresses, or
	 * a link-local scope multicast address which the Responder has joined.
	 * [icmp-name-lookups-07, Section 4.]
	 */
	bzero(&sin6, sizeof(sin6));
	sin6.sin6_family = AF_INET6;
	sin6.sin6_len = sizeof(struct sockaddr_in6);
	bcopy(&ip6->ip6_dst, &sin6.sin6_addr, sizeof(sin6.sin6_addr));
	/* XXX scopeid */
	if (ifa_ifwithaddr((struct sockaddr *)&sin6))
		; /* unicast/anycast, fine */
	else if (IN6_IS_ADDR_MC_LINKLOCAL(&sin6.sin6_addr))
		; /* link-local multicast, fine */
	else
		goto bad;

	/* validate query Subject field. */
a999 60
	subjlen = m->m_pkthdr.len - off - sizeof(struct icmp6_nodeinfo);
	switch (qtype) {
	case NI_QTYPE_NOOP:
	case NI_QTYPE_SUPTYPES:
		/* 07 draft */
		if (ni6->ni_code == ICMP6_NI_SUBJ_FQDN && subjlen == 0)
			break;
		/*FALLTHROUGH*/
	case NI_QTYPE_FQDN:
	case NI_QTYPE_NODEADDR:
		switch (ni6->ni_code) {
		case ICMP6_NI_SUBJ_IPV6:
#if ICMP6_NI_SUBJ_IPV6 != 0
		case 0:
#endif
			/*
			 * backward compatibility - try to accept 03 draft
			 * format, where no Subject is present.
			 */
			if (qtype == NI_QTYPE_FQDN && ni6->ni_code == 0 &&
			    subjlen == 0) {
				oldfqdn++;
				break;
			}
#if ICMP6_NI_SUBJ_IPV6 != 0
			if (ni6->ni_code != ICMP6_NI_SUBJ_IPV6)
				goto bad;
#endif

			if (subjlen != sizeof(sin6.sin6_addr))
				goto bad;

			/*
			 * Validate Subject address.
			 *
			 * Not sure what exactly "address belongs to the node"
			 * means in the spec, is it just unicast, or what?
			 *
			 * At this moment we consider Subject address as
			 * "belong to the node" if the Subject address equals
			 * to the IPv6 destination address; validation for
			 * IPv6 destination address should have done enough
			 * check for us.
			 *
			 * We do not do proxy at this moment.
			 */
			/* m_pulldown instead of copy? */
			m_copydata(m, off + sizeof(struct icmp6_nodeinfo),
			    subjlen, (caddr_t)&sin6.sin6_addr);
			/* XXX kame scope hack */
			if (IN6_IS_SCOPE_LINKLOCAL(&sin6.sin6_addr)) {
				if ((m->m_flags & M_PKTHDR) != 0 &&
				    m->m_pkthdr.rcvif) {
					sin6.sin6_addr.s6_addr16[1] =
					    htons(m->m_pkthdr.rcvif->if_index);
				}
			}
			subj = (char *)&sin6;
			if (IN6_ARE_ADDR_EQUAL(&ip6->ip6_dst, &sin6.sin6_addr))
				break;
d1001 30
a1030 88
			/*
			 * XXX if we are to allow other cases, we should really
			 * be careful about scope here.
			 * basically, we should disallow queries toward IPv6
			 * destination X with subject Y, if scope(X) > scope(Y).
			 * if we allow scope(X) > scope(Y), it will result in
			 * information leakage across scope boundary.
			 */
			goto bad;

		case ICMP6_NI_SUBJ_FQDN:
			/*
			 * Validate Subject name with gethostname(3).
			 *
			 * The behavior may need some debate, since:
			 * - we are not sure if the node has FQDN as
			 *   hostname (returned by gethostname(3)).
			 * - the code does wildcard match for truncated names.
			 *   however, we are not sure if we want to perform
			 *   wildcard match, if gethostname(3) side has
			 *   truncated hostname.
			 */
			n = ni6_nametodns(hostname, hostnamelen, 0);
			if (!n || n->m_next || n->m_len == 0)
				goto bad;
			IP6_EXTHDR_GET(subj, char *, m,
			    off + sizeof(struct icmp6_nodeinfo), subjlen);
			if (subj == NULL)
				goto bad;
			if (!ni6_dnsmatch(subj, subjlen, mtod(n, const char *),
					n->m_len)) {
				goto bad;
			}
			m_freem(n);
			n = NULL;
			break;

		case ICMP6_NI_SUBJ_IPV4:	/* XXX: to be implemented? */
		default:
			goto bad;
		}
		break;
	}

	/* refuse based on configuration.  XXX ICMP6_NI_REFUSED? */
	switch (qtype) {
	case NI_QTYPE_FQDN:
		if ((icmp6_nodeinfo & 1) == 0)
			goto bad;
		break;
	case NI_QTYPE_NODEADDR:
		if ((icmp6_nodeinfo & 2) == 0)
			goto bad;
		break;
	}

	/* guess reply length */
	switch (qtype) {
	case NI_QTYPE_NOOP:
		break;		/* no reply data */
	case NI_QTYPE_SUPTYPES:
		replylen += sizeof(u_int32_t);
		break;
	case NI_QTYPE_FQDN:
		/* XXX will append an mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		break;
	case NI_QTYPE_NODEADDR:
		addrs = ni6_addrs(ni6, m, &ifp, subj);
		if ((replylen += addrs * (sizeof(struct in6_addr) +
					  sizeof(u_int32_t))) > MCLBYTES)
			replylen = MCLBYTES; /* XXX: will truncate pkt later */
		break;
	default:
		/*
		 * XXX: We must return a reply with the ICMP6 code
		 * `unknown Qtype' in this case. However we regard the case
		 * as an FQDN query for backward compatibility.
		 * Older versions set a random value to this field,
		 * so it rarely varies in the defined qtypes.
		 * But the mechanism is not reliable...
		 * maybe we should obsolete older versions.
		 */
		qtype = NI_QTYPE_FQDN;
		/* XXX will append an mbuf */
		replylen += offsetof(struct ni_reply_fqdn, ni_fqdn_namelen);
		oldfqdn++;
		break;
d1033 1
a1033 1
	/* allocate an mbuf to reply. */
d1039 1
a1039 1
	M_DUP_PKTHDR(n, m); /* just for rcvif */
d1041 5
a1045 5
		if (replylen > MCLBYTES) {
			/*
			 * XXX: should we try to allocate more? But MCLBYTES
			 * is probably much larger than IPV6_MMTU...
			 */
a1046 1
		}
d1056 1
a1056 1
	nni6 = (struct icmp6_nodeinfo *)(mtod(n, struct ip6_hdr *) + 1);
d1061 39
a1099 48
	case NI_QTYPE_NOOP:
		nni6->ni_code = ICMP6_NI_SUCCESS;
		nni6->ni_flags = 0;
		break;
	case NI_QTYPE_SUPTYPES:
	{
		u_int32_t v;
		nni6->ni_code = ICMP6_NI_SUCCESS;
		nni6->ni_flags = htons(0x0000);	/* raw bitmap */
		/* supports NOOP, SUPTYPES, FQDN, and NODEADDR */
		v = (u_int32_t)htonl(0x0000000f);
		bcopy(&v, nni6 + 1, sizeof(u_int32_t));
		break;
	}
	case NI_QTYPE_FQDN:
		nni6->ni_code = ICMP6_NI_SUCCESS;
		fqdn = (struct ni_reply_fqdn *)(mtod(n, caddr_t) +
						sizeof(struct ip6_hdr) +
						sizeof(struct icmp6_nodeinfo));
		nni6->ni_flags = 0; /* XXX: meaningless TTL */
		fqdn->ni_fqdn_ttl = 0;	/* ditto. */
		/*
		 * XXX do we really have FQDN in variable "hostname"?
		 */
		n->m_next = ni6_nametodns(hostname, hostnamelen, oldfqdn);
		if (n->m_next == NULL)
			goto bad;
		/* XXX we assume that n->m_next is not a chain */
		if (n->m_next->m_next != NULL)
			goto bad;
		n->m_pkthdr.len += n->m_next->m_len;
		break;
	case NI_QTYPE_NODEADDR:
	{
		int lenlim, copied;

		nni6->ni_code = ICMP6_NI_SUCCESS;
		n->m_pkthdr.len = n->m_len =
		    sizeof(struct ip6_hdr) + sizeof(struct icmp6_nodeinfo);
		lenlim = M_TRAILINGSPACE(n);
		copied = ni6_store_addrs(ni6, nni6, ifp, lenlim);
		/* XXX: reset mbuf length */
		n->m_pkthdr.len = n->m_len = sizeof(struct ip6_hdr) +
			sizeof(struct icmp6_nodeinfo) + copied;
		break;
	}
	default:
		break;		/* XXX impossible! */
d1103 1
a1115 163
 * make a mbuf with DNS-encoded string.  no compression support.
 *
 * XXX names with less than 2 dots (like "foo" or "foo.section") will be
 * treated as truncated name (two \0 at the end).  this is a wild guess.
 */
static struct mbuf *
ni6_nametodns(name, namelen, old)
	const char *name;
	int namelen;
	int old;	/* return pascal string if non-zero */
{
	struct mbuf *m;
	char *cp, *ep;
	const char *p, *q;
	int i, len, nterm;

	if (old)
		len = namelen + 1;
	else
		len = MCLBYTES;

	/* because MAXHOSTNAMELEN is usually 256, we use cluster mbuf */
	MGET(m, M_DONTWAIT, MT_DATA);
	if (m && len > MLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0)
			goto fail;
	}
	if (!m)
		goto fail;
	m->m_next = NULL;

	if (old) {
		m->m_len = len;
		*mtod(m, char *) = namelen;
		bcopy(name, mtod(m, char *) + 1, namelen);
		return m;
	} else {
		m->m_len = 0;
		cp = mtod(m, char *);
		ep = mtod(m, char *) + M_TRAILINGSPACE(m);

		/* if not certain about my name, return empty buffer */
		if (namelen == 0)
			return m;

		/*
		 * guess if it looks like shortened hostname, or FQDN.
		 * shortened hostname needs two trailing "\0".
		 */
		i = 0;
		for (p = name; p < name + namelen; p++) {
			if (*p && *p == '.')
				i++;
		}
		if (i < 2)
			nterm = 2;
		else
			nterm = 1;

		p = name;
		while (cp < ep && p < name + namelen) {
			i = 0;
			for (q = p; q < name + namelen && *q && *q != '.'; q++)
				i++;
			/* result does not fit into mbuf */
			if (cp + i + 1 >= ep)
				goto fail;
			/* DNS label length restriction, RFC1035 page 8 */
			if (i >= 64)
				goto fail;
			*cp++ = i;
			bcopy(p, cp, i);
			cp += i;
			p = q;
			if (p < name + namelen && *p == '.')
				p++;
		}
		/* termination */
		if (cp + nterm >= ep)
			goto fail;
		while (nterm-- > 0)
			*cp++ = '\0';
		m->m_len = cp - mtod(m, char *);
		return m;
	}

	panic("should not reach here");
	/*NOTREACHED*/

 fail:
	if (m)
		m_freem(m);
	return NULL;
}

/*
 * check if two DNS-encoded string matches.  takes care of truncated
 * form (with \0\0 at the end).  no compression support.
 * XXX upper/lowercase match (see RFC2065)
 */
static int
ni6_dnsmatch(a, alen, b, blen)
	const char *a;
	int alen;
	const char *b;
	int blen;
{
	const char *a0, *b0;
	int l;

	/* simplest case - need validation? */
	if (alen == blen && bcmp(a, b, alen) == 0)
		return 1;

	a0 = a;
	b0 = b;

	/* termination is mandatory */
	if (alen < 2 || blen < 2)
		return 0;
	if (a0[alen - 1] != '\0' || b0[blen - 1] != '\0')
		return 0;
	alen--;
	blen--;

	while (a - a0 < alen && b - b0 < blen) {
		if (a - a0 + 1 > alen || b - b0 + 1 > blen)
			return 0;

		if ((signed char)a[0] < 0 || (signed char)b[0] < 0)
			return 0;
		/* we don't support compression yet */
		if (a[0] >= 64 || b[0] >= 64)
			return 0;

		/* truncated case */
		if (a[0] == 0 && a - a0 == alen - 1)
			return 1;
		if (b[0] == 0 && b - b0 == blen - 1)
			return 1;
		if (a[0] == 0 || b[0] == 0)
			return 0;

		if (a[0] != b[0])
			return 0;
		l = a[0];
		if (a - a0 + 1 + l > alen || b - b0 + 1 + l > blen)
			return 0;
		if (bcmp(a + 1, b + 1, l) != 0)
			return 0;

		a += 1 + l;
		b += 1 + l;
	}

	if (a - a0 == alen && b - b0 == blen)
		return 1;
	else
		return 0;
}

/*
d1119 1
a1119 1
ni6_addrs(ni6, m, ifpp, subj)
a1122 1
	char *subj;
d1124 4
a1127 4
	struct ifnet *ifp;
	struct in6_ifaddr *ifa6;
	struct ifaddr *ifa;
	struct sockaddr_in6 *subj_ip6 = NULL; /* XXX pedant */
a1128 17
	int niflags = ni6->ni_flags;

	if ((niflags & NI_NODEADDR_FLAG_ALL) == 0) {
		switch (ni6->ni_code) {
		case ICMP6_NI_SUBJ_IPV6:
			if (subj == NULL) /* must be impossible... */
				return(0);
			subj_ip6 = (struct sockaddr_in6 *)subj;
			break;
		default:
			/*
			 * XXX: we only support IPv6 subject address for
			 * this Qtype.
			 */
			return(0);
		}
	}
d1140 2
a1141 2
			if ((niflags & NI_NODEADDR_FLAG_ALL) == 0 &&
			    IN6_ARE_ADDR_EQUAL(&subj_ip6->sin6_addr,
d1150 1
a1150 1
			 * [icmp-name-lookups-07, Section 5.4]
d1155 8
d1164 4
a1167 4
			switch (in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
			case IPV6_ADDR_SCOPE_LINKLOCAL:
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL) == 0)
					continue;
d1169 3
a1171 7
			case IPV6_ADDR_SCOPE_SITELOCAL:
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL) == 0)
					continue;
				break;
			case IPV6_ADDR_SCOPE_GLOBAL:
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL) == 0)
					continue;
d1173 6
a1178 2
			default:
				continue;
a1179 10

			/*
			 * check if anycast is okay.
			 * XXX: just experimental. not in the spec.
			 */
			if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
			    (niflags & NI_NODEADDR_FLAG_ANYCAST) == 0)
				continue; /* we need only unicast addresses */

			addrsofif++; /* count the address */
d1198 4
a1201 5
	struct ifnet *ifp = ifp0 ? ifp0 : TAILQ_FIRST(&ifnet);
	struct in6_ifaddr *ifa6;
	struct ifaddr *ifa;
	struct ifnet *ifp_dep = NULL;
	int copied = 0, allow_deprecated = 0;
a1202 3
	int niflags = ni6->ni_flags;
	u_int32_t ltime;
	long time_second = time.tv_sec;
d1204 1
a1204 1
	if (ifp0 == NULL && !(niflags & NI_NODEADDR_FLAG_ALL))
a1206 2
  again:

d1212 2
d1218 12
a1229 12
			if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) != 0 &&
			    allow_deprecated == 0) {
				/*
				 * prefererred address should be put before
				 * deprecated addresses.
				 */

				/* record the interface for later search */
				if (ifp_dep == NULL)
					ifp_dep = ifp;

				continue;
a1230 3
			else if ((ifa6->ia6_flags & IN6_IFF_DEPRECATED) == 0 &&
				 allow_deprecated != 0)
				continue; /* we now collect deprecated addrs */
d1233 4
a1236 4
			switch (in6_addrscope(&ifa6->ia_addr.sin6_addr)) {
			case IPV6_ADDR_SCOPE_LINKLOCAL:
				if ((niflags & NI_NODEADDR_FLAG_LINKLOCAL) == 0)
					continue;
d1238 3
a1240 7
			case IPV6_ADDR_SCOPE_SITELOCAL:
				if ((niflags & NI_NODEADDR_FLAG_SITELOCAL) == 0)
					continue;
				break;
			case IPV6_ADDR_SCOPE_GLOBAL:
				if ((niflags & NI_NODEADDR_FLAG_GLOBAL) == 0)
					continue;
d1242 6
a1247 2
			default:
				continue;
d1250 18
a1267 43
			/*
			 * check if anycast is okay.
			 * XXX: just experimental. not in the spec.
			 */
			if ((ifa6->ia6_flags & IN6_IFF_ANYCAST) != 0 &&
			    (niflags & NI_NODEADDR_FLAG_ANYCAST) == 0)
				continue;

			/* now we can copy the address */
			if (resid < sizeof(struct in6_addr) +
			    sizeof(u_int32_t)) {
				/*
				 * We give up much more copy.
				 * Set the truncate flag and return.
				 */
				nni6->ni_flags |=
					NI_NODEADDR_FLAG_TRUNCATE;
				return(copied);
			}

			/*
			 * Set the TTL of the address.
			 * The TTL value should be one of the following
			 * according to the specification:
			 *
			 * 1. The remaining lifetime of a DHCP lease on the
			 *    address, or
			 * 2. The remaining Valid Lifetime of a prefix from
			 *    which the address was derived through Stateless
			 *    Autoconfiguration.
			 *
			 * Note that we currently do not support stateful
			 * address configuration by DHCPv6, so the former
			 * case can't happen.
			 */
			if (ifa6->ia6_lifetime.ia6t_expire == 0)
				ltime = ND6_INFINITE_LIFETIME;
			else {
				if (ifa6->ia6_lifetime.ia6t_expire >
				    time_second)
					ltime = htonl(ifa6->ia6_lifetime.ia6t_expire - time_second);
				else
					ltime = 0;
a1268 15
			
			bcopy(&ltime, cp, sizeof(u_int32_t));
			cp += sizeof(u_int32_t);

			/* copy the address itself */
			bcopy(&ifa6->ia_addr.sin6_addr, cp,
			      sizeof(struct in6_addr));
			/* XXX: KAME link-local hack; remove ifindex */
			if (IN6_IS_ADDR_LINKLOCAL(&ifa6->ia_addr.sin6_addr))
				((struct in6_addr *)cp)->s6_addr16[1] = 0;
			cp += sizeof(struct in6_addr);
			
			resid -= (sizeof(struct in6_addr) + sizeof(u_int32_t));
			copied += (sizeof(struct in6_addr) +
				   sizeof(u_int32_t));
a1273 7
	if (allow_deprecated == 0 && ifp_dep != NULL) {
		ifp = ifp_dep;
		allow_deprecated = 1;

		goto again;
	}

a1277 92
 * XXX almost dup'ed code with rip6_input.
 */
static int
icmp6_rip6_input(mp, off)
	struct	mbuf **mp;
	int	off;
{
	struct mbuf *m = *mp;
	struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	struct in6pcb *in6p;
	struct in6pcb *last = NULL;
	struct sockaddr_in6 rip6src;
	struct icmp6_hdr *icmp6;
	struct mbuf *opts = NULL;

#ifndef PULLDOWN_TEST
	/* this is assumed to be safe. */
	icmp6 = (struct icmp6_hdr *)((caddr_t)ip6 + off);
#else
	IP6_EXTHDR_GET(icmp6, struct icmp6_hdr *, m, off, sizeof(*icmp6));
	if (icmp6 == NULL) {
		/* m is already reclaimed */
		return IPPROTO_DONE;
	}
#endif

	bzero(&rip6src, sizeof(rip6src));
	rip6src.sin6_len = sizeof(struct sockaddr_in6);
	rip6src.sin6_family = AF_INET6;
	/* KAME hack: recover scopeid */
	(void)in6_recoverscope(&rip6src, &ip6->ip6_src, m->m_pkthdr.rcvif);

	for (in6p = rawin6pcbtable.inpt_queue.cqh_first;
	     in6p != (struct inpcb *)&rawin6pcbtable.inpt_queue;
	     in6p = in6p->inp_queue.cqe_next)
	{
		if (!(in6p->in6p_flags & INP_IPV6))
			continue;
		if (in6p->in6p_ip6_nxt != IPPROTO_ICMPV6)
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_laddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
			continue;
		if (in6p->in6p_icmp6filt
		    && ICMP6_FILTER_WILLBLOCK(icmp6->icmp6_type,
				 in6p->in6p_icmp6filt))
			continue;
		if (last) {
			struct	mbuf *n;
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
				if (last->in6p_flags & IN6P_CONTROLOPTS)
					ip6_savecontrol(last, &opts, ip6, n);
				/* strip intermediate headers */
				m_adj(n, off);
				if (sbappendaddr(&last->in6p_socket->so_rcv,
						 (struct sockaddr *)&rip6src,
						 n, opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					if (opts)
						m_freem(opts);
				} else
					sorwakeup(last->in6p_socket);
				opts = NULL;
			}
		}
		last = in6p;
	}
	if (last) {
		if (last->in6p_flags & IN6P_CONTROLOPTS)
			ip6_savecontrol(last, &opts, ip6, m);
		/* strip intermediate headers */
		m_adj(m, off);
		if (sbappendaddr(&last->in6p_socket->so_rcv,
				 (struct sockaddr *)&rip6src,
				 m, opts) == 0) {
			m_freem(m);
			if (opts)
				m_freem(opts);
		} else
			sorwakeup(last->in6p_socket);
	} else {
		m_freem(m);
		ip6stat.ip6s_delivered--;
	}
	return IPPROTO_DONE;
}

/*
d1279 5
a1283 1
 * OFF points to the icmp6 header, counted from the top of the mbuf.
a1296 1
	struct sockaddr_in6 sa6_src, sa6_dst;
d1300 1
a1300 1
#endif
d1304 3
a1306 4
		nd6log((LOG_DEBUG,
		    "sanity fail: off=%lx, sizeof(ip6)=%lx in %s:%d\n",
		    (u_long)off, (u_long)sizeof(struct ip6_hdr),
		    __FILE__, __LINE__));
a1313 4
#ifdef DIAGNOSTIC
	if (sizeof(struct ip6_hdr) + sizeof(struct icmp6_hdr) > MHLEN)
		panic("assumption failed in icmp6_reflect");
#endif
d1349 6
a1354 18
	/*
	 * XXX: make sure to embed scope zone information, using
	 * already embedded IDs or the received interface (if any).
	 * Note that rcvif may be NULL.
	 * TODO: scoped routing case (XXX).
	 */
	bzero(&sa6_src, sizeof(sa6_src));
	sa6_src.sin6_family = AF_INET6;
	sa6_src.sin6_len = sizeof(sa6_src);
	sa6_src.sin6_addr = ip6->ip6_dst;
	in6_recoverscope(&sa6_src, &ip6->ip6_dst, m->m_pkthdr.rcvif);
	in6_embedscope(&ip6->ip6_dst, &sa6_src, NULL, NULL);
	bzero(&sa6_dst, sizeof(sa6_dst));
	sa6_dst.sin6_family = AF_INET6;
	sa6_dst.sin6_len = sizeof(sa6_dst);
	sa6_dst.sin6_addr = t;
	in6_recoverscope(&sa6_dst, &t, m->m_pkthdr.rcvif);
	in6_embedscope(&t, &sa6_dst, NULL, NULL);
d1387 1
a1387 1
#endif
d1391 1
a1391 1
	 * The IN6_IFF_NOTREADY case would be VERY rare, but is possible
d1409 1
a1409 4
	if (src == 0) {
		int e;
		struct route_in6 ro;

d1412 4
a1415 2
		 * that we do not own. Select a source address based on the
		 * source address of the erroneous packet.
d1417 5
a1421 12
		bzero(&ro, sizeof(ro));
		src = in6_selectsrc(&sa6_src, NULL, NULL, &ro, NULL, &e);
		if (ro.ro_rt)
			RTFREE(ro.ro_rt); /* XXX: we could use this */
		if (src == NULL) {
			nd6log((LOG_DEBUG,
			    "icmp6_reflect: source can't be determined: "
			    "dst=%s, error=%d\n",
			    ip6_sprintf(&sa6_src.sin6_addr), e));
			goto bad;
		}
	}
a1464 1

d1482 1
a1482 1
	struct mbuf *m;
d1530 1
a1530 1
		nd6log((LOG_ERR,
d1532 2
a1533 2
			"must be from linklocal\n", ip6_sprintf(&src6)));
		goto bad;
d1536 1
a1536 1
		nd6log((LOG_ERR,
d1539 2
a1540 2
			ip6_sprintf(&src6), ip6->ip6_hlim));
		goto bad;
a1552 10
		if (rt->rt_gateway == NULL ||
		    rt->rt_gateway->sa_family != AF_INET6) {
			nd6log((LOG_ERR,
			    "ICMP6 redirect rejected; no route "
			    "with inet6 gateway found for redirect dst: %s\n",
			    icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
			RTFREE(rt);
			goto bad;
		}

d1555 1
a1555 1
			nd6log((LOG_ERR,
d1560 1
a1560 1
				icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
d1562 1
a1562 1
			goto bad;
d1565 1
a1565 1
		nd6log((LOG_ERR,
d1568 2
a1569 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
d1575 1
a1575 1
		nd6log((LOG_ERR,
d1578 2
a1579 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
d1588 1
a1588 1
		nd6log((LOG_ERR,
d1591 2
a1592 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
d1599 1
a1599 1
		nd6log((LOG_INFO, "icmp6_redirect_input: "
d1601 1
a1601 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		/* nd6_options have incremented stats */
d1616 1
a1616 1
		nd6log((LOG_INFO,
d1620 1
a1620 2
			icmp6_redirect_diag(&src6, &reddst6, &redtgt6)));
		goto bad;
a1631 18
		unsigned long rtcount;
		struct rtentry *newrt = NULL;

		/*
		 * do not install redirect route, if the number of entries
		 * is too much (> hiwat).  note that, the node (= host) will
		 * work just fine even if we do not install redirect route
		 * (there will be additional hops, though).
		 */
		rtcount = rt_timer_count(icmp6_redirect_timeout_q);
		if (0 <= icmp6_redirect_hiwat && rtcount > icmp6_redirect_hiwat)
			return;
		else if (0 <= icmp6_redirect_lowat &&
		    rtcount > icmp6_redirect_lowat) {
			/*
			 * XXX nuke a victim, install the new one.
			 */
		}
d1645 2
a1646 7
			   &newrt);

		if (newrt) {
			(void)rt_timer_add(newrt, icmp6_redirect_timeout,
			    icmp6_redirect_timeout_q);
			rtfree(newrt);
		}
d1651 4
d1660 1
d1662 14
a1682 5
	return;

 bad:
	icmp6stat.icp6s_badredirect++;
	m_freem(m);
a1699 3
	struct sockaddr_in6 src_sa;

	icmp6_errcount(&icmp6stat.icp6s_outerrhist, ND_REDIRECT, 0);
d1716 1
a1716 7
	bzero(&src_sa, sizeof(src_sa));
	src_sa.sin6_family = AF_INET6;
	src_sa.sin6_len = sizeof(src_sa);
	src_sa.sin6_addr = sip6->ip6_src;
	/* we don't currently use sin6_scope_id, but eventually use it */
	src_sa.sin6_scope_id = in6_addr2scopeid(ifp, &sip6->ip6_src);
	if (nd6_is_addr_neighbor(&src_sa, ifp) == 0)
d1738 1
a1738 2
	m->m_len = 0;
	maxlen = M_TRAILINGSPACE(m);
a1840 2
	if (p - (u_char *)ip6 > maxlen)
		goto noredhdropt;
a1910 1
noredhdropt:;
a1952 92
#ifdef HAVE_NRL_INPCB
#define sotoin6pcb	sotoinpcb
#define in6pcb		inpcb
#define in6p_icmp6filt	inp_icmp6filt
#endif
/*
 * ICMPv6 socket option processing.
 */
int
icmp6_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	int error = 0;
	int optlen;
	struct in6pcb *in6p = sotoin6pcb(so);
	struct mbuf *m = *mp;

	optlen = m ? m->m_len : 0;

	if (level != IPPROTO_ICMPV6) {
		if (op == PRCO_SETOPT && m)
			(void)m_free(m);
		return EINVAL;
	}

	switch (op) {
	case PRCO_SETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			if (optlen != sizeof(*p)) {
				error = EMSGSIZE;
				break;
			}
			p = mtod(m, struct icmp6_filter *);
			if (!p || !in6p->in6p_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(p, in6p->in6p_icmp6filt,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		if (m)
			(void)m_freem(m);
		break;

	case PRCO_GETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			if (!in6p->in6p_icmp6filt) {
				error = EINVAL;
				break;
			}
			*mp = m = m_get(M_WAIT, MT_SOOPTS);
			m->m_len = sizeof(struct icmp6_filter);
			p = mtod(m, struct icmp6_filter *);
			bcopy(in6p->in6p_icmp6filt, p,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}

	return(error);
}
#ifdef HAVE_NRL_INPCB
#undef sotoin6pcb
#undef in6pcb
#undef in6p_icmp6filt
#endif

d1967 2
a1968 1
	int ret;
d1970 3
a1972 1
	ret = 0;	/*okay to send*/
d1974 4
a1977 3
	/* PPS limit */
	if (!ppsratecheck(&icmp6errppslim_last, &icmp6errpps_count,
	    icmp6errppslim)) {
d1979 8
a1986 1
		ret++;
d1989 2
a1990 1
	return ret;
d2003 1
a2003 1

d2008 1
a2008 1
		error = rtrequest((int) RTM_ADD, dst,
d2010 1
a2010 1
		    (struct sockaddr *) 0,
d2014 1
d2038 1
a2038 1
	if ((rt->rt_flags & (RTF_DYNAMIC | RTF_HOST)) ==
d2043 3
a2045 16
		if ((rt->rt_rmx.rmx_locks & RTV_MTU) == 0)
			rt->rt_rmx.rmx_mtu = rt->rt_ifp->if_mtu;
	}
}

static void
icmp6_redirect_timeout(rt, r)
	struct rtentry *rt;
	struct rttimer *r;
{
	if (rt == NULL)
		panic("icmp6_redirect_timeout: bad route to timeout");
	if ((rt->rt_flags & (RTF_GATEWAY | RTF_DYNAMIC | RTF_HOST)) ==
	    (RTF_GATEWAY | RTF_DYNAMIC | RTF_HOST)) {
		rtrequest((int) RTM_DELETE, (struct sockaddr *)rt_key(rt),
		    rt->rt_gateway, rt_mask(rt), rt->rt_flags, 0);
d2076 3
a2091 13
	case ICMPV6CTL_ERRPPSLIMIT:
		return sysctl_int(oldp, oldlenp, newp, newlen, &icmp6errppslim);
	case ICMPV6CTL_ND6_MAXNUDHINT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&nd6_maxnudhint);
	case ICMPV6CTL_MTUDISC_HIWAT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_mtudisc_hiwat);
	case ICMPV6CTL_MTUDISC_LOWAT:
		return sysctl_int(oldp, oldlenp, newp, newlen,
				&icmp6_mtudisc_lowat);
	case ICMPV6CTL_ND6_DEBUG:
		return sysctl_int(oldp, oldlenp, newp, newlen, &nd6_debug);
@


1.6.2.4
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$KAME: icmp6.c,v 1.217 2001/06/20 15:03:29 jinmei Exp $	*/
d102 2
d187 4
d618 1
a618 1
			M_MOVE_PKTHDR(n, n0);
d627 2
a628 1
			n->m_len = noff + sizeof(struct icmp6_hdr);
a631 1
			 * n->m_pkthdr.len == n0->m_pkthdr.len at this point.
a632 2
			n->m_pkthdr.len += noff + sizeof(struct icmp6_hdr);
			n->m_pkthdr.len -= (off + sizeof(struct icmp6_hdr));
d634 1
d636 2
a2018 9
 *
 * Note: RFC 1885 required that an echo reply should be truncated if it
 * did not fit in with (return) path MTU, and KAME code supported the
 * behavior.  However, as a clarification after the RFC, this limitation
 * was removed in a revised version of the spec, RFC 2463.  We had kept the
 * old behavior, with a (non-default) ifdef block, while the new version of
 * the spec was an internet-draft status, and even after the new RFC was
 * published.  But it would rather make sense to clean the obsoleted part
 * up, and to make the code simpler at this stage.
d2033 4
d2109 32
d2193 1
a2193 2
	} else
		ip6->ip6_hlim = ip6_defhlim;
d2208 3
d2212 1
a2212 1

d2749 1
a2749 1
/* NRL PCB */
d2753 1
a2753 1

d2835 1
a2835 2

/* NRL PCB */
d2839 1
@


1.6.2.5
log
@merge in -current
@
text
@d2901 1
a2901 1
#include <uvm/uvm_extern.h>
@


1.6.2.6
log
@Merge in trunk
@
text
@d98 2
d124 1
a124 1
 * for KAME src sync over BSD*'s.  XXX: FreeBSD (>=3) are VERY different from
d305 3
a307 9
	 * If the destination address of the erroneous packet is a multicast
	 * address, or the packet was sent using link-layer multicast,
	 * we should basically suppress sending an error (RFC 2463, Section
	 * 2.4).
	 * We have two exceptions (the item e.2 in that section):
	 * - the Pakcet Too Big message can be sent for path MTU discovery.
	 * - the Parameter Problem Message that can be allowed an icmp6 error
	 *   in the option type field.  This check has been done in
	 *   ip6_unknown_opt(), so we can just check the type and code.
d316 1
a316 4
	/*
	 * RFC 2463, 2.4 (e.5): source address check.
	 * XXX: the case of anycast source?
	 */
d353 1
a353 2
	}
	else {
d405 1
a405 1
	icmp6_reflect(m, sizeof(struct ip6_hdr)); /* header order: IPv6 - ICMPv6 */
a430 2
	icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_msg);

d433 1
a433 1
	/* m might change if M_LOOP.  So, call mtod after this */
a443 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
a455 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
a465 1
		icmp6_ifstat_inc(m->m_pkthdr.rcvif, ifs6_in_error);
d487 8
d496 3
d501 1
a551 2
			code = PRC_TIMXCEED_INTRANS;
			break;
d553 1
a553 1
			code = PRC_TIMXCEED_REASS;
d581 3
a583 10
		/*
		 * Copy mbuf to send to two data paths: userland socket(s),
		 * and to the querier (echo reply).
		 * m: a copy for socket, n: a copy for querier
		 */
		if ((n = m_copym(m, 0, M_COPYALL, M_DONTWAIT)) == NULL) {
			/* Give up local */
			n = m;
			m = NULL;
			goto deliverecho;
d585 2
a586 7
		/*
		 * If the first mbuf is shared, or the first mbuf is too short,
		 * copy the first part of the data into a fresh mbuf.
		 * Otherwise, we will wrongly overwrite both copies.
		 */
		if ((n->m_flags & M_EXT) != 0 ||
		    n->m_len < off + sizeof(struct icmp6_hdr)) {
d591 1
a591 1
			 * Prepare an internal mbuf.  m_pullup() doesn't
d608 1
a608 1
				/* Give up local */
d610 1
a610 3
				n = m;
				m = NULL;
				goto deliverecho;
d623 1
a623 1
			 * Adjust mbuf.  ip6_plen will be adjusted in
a631 1
	 deliverecho:
a642 2
		if (!m)
			goto freeit;
d677 1
a677 1
		/* XXX: these two are experimental.  not officially defined. */
d700 1
a700 1
			n = m_copym(m, 0, M_COPYALL, M_DONTWAIT);
a730 1
			n->m_pkthdr.rcvif = NULL;
d744 1
a744 1
			bcopy(hostname, p + 4, maxhlen); /* meaningless TTL */
d937 1
a937 1
		while (1) { /* XXX: should avoid infinite loop explicitly? */
d1051 1
a1051 1
				 * Header.  In such cases going to the notify
d1199 1
a1199 1
	if (rt) { /* XXX: need braces to avoid conflict with else in RTFREE. */
a1200 1
	}
d1283 1
a1283 1
		/* FALLTHROUGH */
d1413 1
a1413 1
		 * `unknown Qtype' in this case.  However we regard the case
d1587 2
a1588 6
			/*
			 * DNS label length restriction, RFC1035 page 8.
			 * "i == 0" case is included here to avoid returning
			 * 0-length label on "foo..bar".
			 */
			if (i <= 0 || i >= 64)
d1607 1
a1607 1
	/* NOTREACHED */
d1759 1
a1759 1
			 * XXX: just experimental.  not in the spec.
d1845 1
a1845 1
			 * XXX: just experimental.  not in the spec.
a1876 2
			 *
			 * TTL must be 2^31 > TTL >= 0.
d2108 1
a2108 1
	 * If the incoming packet was addressed directly to us (i.e. unicast),
d2123 1
a2123 1
		 * and the sender is also ourselves.
d2134 1
a2134 1
		 * that we do not own.  Select a source address based on the
d2139 1
a2139 1
		if (ro.ro_rt) { /* XXX: see comments in icmp6_mtudisc_update */
a2140 1
		}
d2167 1
a2167 1
	 * XXX option handling
d2171 3
d2175 1
a2175 2
	if (ip6_output(m, NULL, NULL, 0, NULL, &outif) != 0 && outif)
		icmp6_ifstat_inc(outif, ifs6_out_error);
d2365 1
a2365 1
	if (!is_onlink) {	/* better router case.  perform rtredirect. */
d2410 2
a2411 2
	{
		struct sockaddr_in6 sdst;
d2413 9
a2421 6
		bzero(&sdst, sizeof(sdst));
		sdst.sin6_family = AF_INET6;
		sdst.sin6_len = sizeof(struct sockaddr_in6);
		bcopy(&reddst6, &sdst.sin6_addr, sizeof(struct in6_addr));
		pfctlinput(PRC_REDIRECT_HOST, (struct sockaddr *)&sdst);
	}
d2439 1
a2439 1
	struct in6_addr *nexthop;
d2446 1
a2493 1
	m->m_pkthdr.rcvif = NULL;
d2517 3
a2519 3
		nexthop = &sin6->sin6_addr;
		if (!IN6_IS_ADDR_LINKLOCAL(nexthop))
			nexthop = NULL;
d2521 1
a2521 1
		nexthop = NULL;
d2545 1
a2545 1
		if (!nexthop)
d2547 1
a2547 1
		bcopy(nexthop, &nd_rd->nd_rd_target,
a2552 1
		nexthop = &sip6->ip6_dst;
d2561 30
a2590 28
	{
		/* target lladdr option */
		struct rtentry *rt_nexthop = NULL;
		int len;
		struct sockaddr_dl *sdl;
		struct nd_opt_hdr *nd_opt;
		char *lladdr;

		rt_nexthop = nd6_lookup(nexthop, 0, ifp);
		if (!rt_nexthop)
			goto nolladdropt;
		len = sizeof(*nd_opt) + ifp->if_addrlen;
		len = (len + 7) & ~7;	/* round by 8 */
		/* safety check */
		if (len + (p - (u_char *)ip6) > maxlen)
			goto nolladdropt;
		if (!(rt_nexthop->rt_flags & RTF_GATEWAY) &&
		    (rt_nexthop->rt_flags & RTF_LLINFO) &&
		    (rt_nexthop->rt_gateway->sa_family == AF_LINK) &&
		    (sdl = (struct sockaddr_dl *)rt_nexthop->rt_gateway) &&
		    sdl->sdl_alen) {
			nd_opt = (struct nd_opt_hdr *)p;
			nd_opt->nd_opt_type = ND_OPT_TARGET_LINKADDR;
			nd_opt->nd_opt_len = len >> 3;
			lladdr = (char *)(nd_opt + 1);
			bcopy(LLADDR(sdl), lladdr, ifp->if_addrlen);
			p += len;
		}
d2592 2
a2593 1
  nolladdropt:;
d2694 8
a2701 5
	if (ip6_output(m, NULL, NULL, 0, NULL, NULL) != 0)
		icmp6_ifstat_inc(ifp, ifs6_out_error);

	icmp6_ifstat_inc(ifp, ifs6_out_msg);
	icmp6_ifstat_inc(ifp, ifs6_out_redirect);
d2821 1
a2821 1
	ret = 0;	/* okay to send */
@


1.6.2.7
log
@Merge in -current from roughly a week ago
@
text
@d144 1
a144 1
	void (*mc_func)(struct in6_addr *);
d166 16
a181 16
static void icmp6_errcount(struct icmp6errstat *, int, int);
static int icmp6_rip6_input(struct mbuf **, int);
static int icmp6_ratelimit(const struct in6_addr *, const int, const int);
static const char *icmp6_redirect_diag(struct in6_addr *,
	struct in6_addr *, struct in6_addr *);
static struct mbuf *ni6_input(struct mbuf *, int);
static struct mbuf *ni6_nametodns(const char *, int, int);
static int ni6_dnsmatch(const char *, int, const char *, int);
static int ni6_addrs(struct icmp6_nodeinfo *, struct mbuf *,
			  struct ifnet **, char *);
static int ni6_store_addrs(struct icmp6_nodeinfo *, struct icmp6_nodeinfo *,
				struct ifnet *, int);
static int icmp6_notify_error(struct mbuf *, int, int, int);
static struct rtentry *icmp6_mtudisc_clone(struct sockaddr *);
static void icmp6_mtudisc_timeout(struct rtentry *, struct rttimer *);
static void icmp6_redirect_timeout(struct rtentry *, struct rttimer *);
d254 1
a254 1
	void (*func)(struct in6_addr *);
d946 1
a946 1
		void (*ctlfunc)(int, struct sockaddr *, void *);
d1150 1
a1150 1
		ctlfunc = (void (*)(int, struct sockaddr *, void *))
@


1.6.2.8
log
@Sync the SMP branch with 3.3
@
text
@d892 1
a892 1
			return (IPPROTO_DONE);
d939 1
a939 1
		return (-1);
d976 1
a976 1
					return (-1);
d979 1
a979 1

d1005 1
a1005 1
					return (-1);
d1031 1
a1031 1
						return (-1);
d1054 1
a1054 1
					return (-1);
d1089 1
a1089 1
			return (-1);
d1157 1
a1157 1
	return (0);
d1161 1
a1161 1
	return (-1);
d1209 7
a1215 4
	if (rt && (rt->rt_flags & RTF_HOST) &&
	    !(rt->rt_rmx.rmx_locks & RTV_MTU) &&
	    (rt->rt_rmx.rmx_mtu > mtu || rt->rt_rmx.rmx_mtu == 0)) {
		if (mtu < IN6_LINKMTU(rt->rt_ifp)) {
d1236 1
a1236 1
 *
d1453 1
a1453 1
		return (NULL);
d1530 1
a1530 1
	return (n);
d1536 1
a1536 1
	return (NULL);
a1539 5
#define isupper(x) ('A' <= (x) && (x) <= 'Z')
#define isalpha(x) (('A' <= (x) && (x) <= 'Z') || ('a' <= (x) && (x) <= 'z'))
#define isalnum(x) (isalpha(x) || ('0' <= (x) && (x) <= '9'))
#define tolower(x) (isupper(x) ? (x) + 'a' - 'A' : (x))

d1617 2
a1618 12
			if (!isalpha(p[0]) || !isalnum(p[i - 1]))
				goto fail;
			while (i > 0) {
				if (!isalnum(*p) && *p != '-')
					goto fail;
				if (isupper(*p)) {
					*cp++ = tolower(*p);
					p++;
				} else
					*cp++ = *p++;
				i--;
			}
d1728 1
a1728 1
				return (0);
d1736 1
a1736 1
			return (0);
d1795 1
a1795 1
			return (addrsofif);
d1801 1
a1801 1
	return (addrs);
d1821 1
a1821 1
		return (0);	/* needless to copy */
d1886 1
a1886 1
				return (copied);
d1915 1
a1915 1

d1926 1
a1926 1

d1942 1
a1942 1
	return (copied);
d2187 1
a2187 1
		ip6->ip6_hlim = ND_IFINFO(m->m_pkthdr.rcvif)->chlim;
d2201 1
a2201 7
	/*
	 * To avoid a "too big" situation at an intermediate router
	 * and the path MTU discovery process, specify the IPV6_MINMTU flag.
	 * Note that only echo and node information replies are affected,
	 * since the length of ICMP6 errors is limited to the minimum MTU.
	 */
	if (ip6_output(m, NULL, NULL, IPV6_MINMTU, NULL, &outif) != 0 && outif)
d2254 1
a2254 1
	if (!ifp)
d2655 1
a2655 1
		panic("assumption failed in %s:%d", __FILE__, __LINE__);
d2816 1
a2816 1
	return (error);
d2901 2
a2902 2
		if (!(rt->rt_rmx.rmx_locks & RTV_MTU))
			rt->rt_rmx.rmx_mtu = 0;
a2972 3
	case ICMPV6CTL_ND6_DRLIST:
	case ICMPV6CTL_ND6_PRLIST:
		return nd6_sysctl(name[0], oldp, oldlenp, newp, newlen);
@


1.6.2.9
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.6.2.8 2003/03/28 00:41:29 niklas Exp $	*/
a2708 1
	m0 = NULL;
a2710 4
	if (m0) {
		m_freem(m0);
		m0 = NULL;
	}
@


1.6.2.10
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d291 3
d299 1
d337 4
d347 1
d441 5
d461 3
d470 1
d716 4
d929 6
d941 1
d965 7
d978 1
d995 6
d1007 1
d1021 5
d1033 1
d1043 7
d1056 1
d1082 3
d1091 1
d1263 3
d1271 1
d1973 4
d1982 1
d2281 4
d2290 1
@


1.6.2.11
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.6.2.10 2003/05/16 00:29:44 niklas Exp $	*/
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
d515 1
d529 1
d544 1
d560 1
d2565 20
a2584 4
	{
		/* redirected header option */
		int len;
		struct nd_opt_rd_hdr *nd_opt_rh;
d2586 12
a2597 6
		/*
		 * compute the maximum size for icmp6 redirect header option.
		 * XXX room for auth header?
		 */
		len = maxlen - (p - (u_char *)ip6);
		len &= ~7;
d2599 6
a2604 21
		/*
		 * Redirected header option spec (RFC2461 4.6.3) talks nothing
		 * about padding/truncate rule for the original IP packet.
		 * From the discussion on IPv6imp in Feb 1999,
		 * the consensus was:
		 * - "attach as much as possible" is the goal
		 * - pad if not aligned (original size can be guessed by
		 *   original ip6 header)
		 * Following code adds the padding if it is simple enough,
		 * and truncates if not.
		 */
		if (len - sizeof(*nd_opt_rh) < m0->m_pkthdr.len) {
			/* not enough room, truncate */
			m_adj(m0, (len - sizeof(*nd_opt_rh)) -
			    m0->m_pkthdr.len);
		} else {
			/*
			 * enough room, truncate if not aligned.
			 * we don't pad here for simplicity.
			 */
			size_t extra;
d2606 8
a2613 2
			extra = m0->m_pkthdr.len % 8;
			if (extra) {
d2615 2
a2616 1
				m_adj(m0, -extra);
a2617 1
			len = m0->m_pkthdr.len + sizeof(*nd_opt_rh);
d2619 3
d2623 13
a2635 13
		nd_opt_rh = (struct nd_opt_rd_hdr *)p;
		bzero(nd_opt_rh, sizeof(*nd_opt_rh));
		nd_opt_rh->nd_opt_rh_type = ND_OPT_REDIRECTED_HEADER;
		nd_opt_rh->nd_opt_rh_len = len >> 3;
		p += sizeof(*nd_opt_rh);
		m->m_pkthdr.len = m->m_len = p - (u_char *)ip6;

		/* connect m0 to m */
		m_cat(m, m0);
		m->m_pkthdr.len += m0->m_pkthdr.len;
		m0 = NULL;
	}
noredhdropt:
@


1.6.2.12
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d645 3
a647 3
	case MLD_LISTENER_QUERY:
	case MLD_LISTENER_REPORT:
		if (icmp6len < sizeof(struct mld_hdr))
d649 1
a649 1
		if (icmp6->icmp6_type == MLD_LISTENER_QUERY) /* XXX: ugly... */
d663 1
a663 1
	case MLD_LISTENER_DONE:
d665 1
a665 1
		if (icmp6len < sizeof(struct mld_hdr))	/* necessary? */
d669 2
a670 2
	case MLD_MTRACE_RESP:
	case MLD_MTRACE:
d888 1
a888 1
	int off, icmp6len, code;
d1063 1
a1063 1
		    (eip6->ip6_flow & IPV6_FLOWLABEL_MASK);
d1142 1
a1142 1
		if (mtu >= 296 && mtu < IN6_LINKMTU(rt->rt_ifp)) {
d1756 1
d1848 2
a1849 2
				    time.tv_sec)
					ltime = htonl(ifa6->ia6_lifetime.ia6t_expire - time.tv_sec);
d1911 4
a1914 1
	CIRCLEQ_FOREACH(in6p, &rawin6pcbtable.inpt_queue, inp_queue) {
d2409 1
a2409 1
	if (!ip6_forwarding)
d2607 1
a2608 1
		m_cat(m, m0);
@


1.6.2.13
log
@Merge with the trunk
@
text
@d446 1
d464 1
a464 1
		 * This is important to deliver TOOBIG.  Otherwise PMTUD
d1142 1
a1142 1
		if (mtu < IN6_LINKMTU(rt->rt_ifp)) {
a2840 3

int *icmpv6ctl_vars[ICMPV6CTL_MAXID] = ICMPV6CTL_VARS;

d2857 6
d2866 26
a2895 3
		if (name[0] < ICMPV6CTL_MAXID)
			return (sysctl_int_arr(icmpv6ctl_vars, name, namelen,
			    oldp, oldlenp, newp, newlen));
@


1.5
log
@remove never-visited function icmp6_ctloutput().
for openbsd, this is integrated into rip6_ctloutput().
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.4 2000/01/02 04:52:26 itojun Exp $	*/
d88 1
a88 1
#include <netinet6/ip6.h>
d90 1
a90 1
#include <netinet6/icmp6.h>
@


1.4
log
@implement net.inet6.icmp6.nodeinfo sysctl, which disables
ICMPv6 node information query (and FQDN query - old variant).

kame repository has the change as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.3 1999/12/15 07:08:00 itojun Exp $	*/
a1775 78
}

/*
 * ICMPv6 socket option processing.
 */
int
icmp6_ctloutput(op, so, level, optname, mp)
	int op;
	struct socket *so;
	int level, optname;
	struct mbuf **mp;
{
	int error = 0;
	int optlen;
	register struct inpcb *inp = sotoinpcb(so);
	register struct mbuf *m = *mp;

	optlen = m ? m->m_len : 0;

	if (level != IPPROTO_ICMPV6) {
		if (op == PRCO_SETOPT && m)
			(void)m_free(m);
		return EINVAL;
	}

	switch(op) {
	case PRCO_SETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			if (optlen != sizeof(*p)) {
				error = EMSGSIZE;
				break;
			}
			p = mtod(m, struct icmp6_filter *);
			if (!p || !inp->inp_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(p, inp->inp_icmp6filt,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;

	case PRCO_GETOPT:
		switch (optname) {
		case ICMP6_FILTER:
		    {
			struct icmp6_filter *p;

			p = mtod(m, struct icmp6_filter *);
			if (!p || !inp->inp_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(inp->inp_icmp6filt, p,
				sizeof(struct icmp6_filter));
			error = 0;
			break;
		    }

		default:
			error = ENOPROTOOPT;
			break;
		}
		break;
	}

	return(error);
@


1.3
log
@do not overwrite traffic class portion when filling in IPv6 version field.
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.2 1999/12/10 10:04:27 angelos Exp $	*/
d111 1
d592 3
d603 1
d606 7
a612 4
			n = ni6_input(m, off);
			noff = sizeof(struct ip6_hdr);
		}
		else {
d859 3
a861 3
	IP6_EXTHDR_GET(ni6, struct icmp6_nodeinfo *, m, off,
		sizeof(*ni6));
	if (ni6 == NULL)
d863 1
d901 2
a902 1
	if (n == NULL)
d904 1
d970 1
d974 1
d1995 2
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: icmp6.c,v 1.1 1999/12/08 06:50:20 itojun Exp $	*/
d1264 2
a1265 1
	ip6->ip6_vfc = IPV6_VERSION;
d1584 2
a1585 1
	ip6->ip6_vfc = IPV6_VERSION;
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a66 7
#if (defined(__FreeBSD__) && __FreeBSD__ >= 3) || defined(__NetBSD__)
#include "opt_inet.h"
#ifdef __NetBSD__	/*XXX*/
#include "opt_ipsec.h"
#endif
#endif

a85 1
#ifdef __OpenBSD__
a87 1
#endif
a91 3
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3) && !defined(__OpenBSD__)
#include <netinet6/in6_pcb.h>
#else
a92 1
#endif
a96 1
#ifdef __OpenBSD__ /*KAME IPSEC*/
a97 7
#endif

#ifdef IPSEC
#include <netinet6/ipsec.h>
#include <netkey/key.h>
#include <netkey/key_debug.h>
#endif
a108 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a109 3
#else
extern struct inpcbhead ripcb;
#endif
a110 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a112 1
#endif
a113 3
#ifndef HAVE_NRL_INPCB
static int icmp6_rip6_input __P((struct mbuf **, int));
#endif
a121 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a123 1
#endif
a133 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a134 1
#endif
a152 5
#ifdef M_DECRYPTED	/*not openbsd*/
	if (m->m_flags & M_DECRYPTED)
		goto freeit;
#endif

a422 3
#ifdef __bsdi__
		struct route_in6 ro6;
#endif
a445 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a451 11
#endif
#ifdef __FreeBSD__
		rt = rtalloc1((struct sockaddr *)&sin6, 0,
			RTF_CLONING | RTF_PRCLONING);
#endif /*__FreeBSD__*/
#ifdef __bsdi__
		bcopy(&sin6, &ro6.ro_dst, sizeof(struct sockaddr_in6));
		ro6.ro_rt = 0;
		rtcalloc((struct route *)&ro6);
		rt = ro6.ro_rt;
#endif /*__bsdi__*/
a597 3
#ifdef __FreeBSD__
#define hostnamelen	strlen(hostname)
#endif
a819 1
#ifdef HAVE_NRL_INPCB
a820 3
#else
	icmp6_rip6_input(&m, *offp);
#endif
a830 3
#ifdef __FreeBSD__
#define hostnamelen	strlen(hostname)
#endif
a982 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (ifp = ifnet; ifp; ifp = ifp->if_next)
#else
a983 1
#endif
a985 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a987 1
#endif
a1040 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	register struct ifnet *ifp = ifp0 ? ifp0 : ifnet;
#else
a1041 1
#endif
a1049 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
	for (; ifp; ifp = ifp->if_next)
#else
a1050 1
#endif
a1051 3
#if defined(__bsdi__) || (defined(__FreeBSD__) && __FreeBSD__ < 3)
		for (ifa = ifp->if_addrlist; ifa; ifa = ifa->ifa_next)
#else
a1053 1
#endif
a1119 98
#ifndef HAVE_NRL_INPCB
/*
 * XXX almost dup'ed code with rip6_input.
 */
static int
icmp6_rip6_input(mp, off)
	struct	mbuf **mp;
	int	off;
{
	struct mbuf *m = *mp;
	register struct ip6_hdr *ip6 = mtod(m, struct ip6_hdr *);
	register struct in6pcb *in6p;
	struct in6pcb *last = NULL;
	struct sockaddr_in6 rip6src;
	struct icmp6_hdr *icmp6;
	struct mbuf *opts = NULL;

	/* this is assumed to be safe. */
	icmp6 = (struct icmp6_hdr *)((caddr_t)ip6 + off);

	bzero(&rip6src, sizeof(rip6src));
	rip6src.sin6_len = sizeof(struct sockaddr_in6);
	rip6src.sin6_family = AF_INET6;
	rip6src.sin6_addr = ip6->ip6_src;
	if (IN6_IS_SCOPE_LINKLOCAL(&rip6src.sin6_addr))
		rip6src.sin6_addr.s6_addr16[1] = 0;
	if (m->m_pkthdr.rcvif) {
		if (IN6_IS_SCOPE_LINKLOCAL(&rip6src.sin6_addr))
			rip6src.sin6_scope_id = m->m_pkthdr.rcvif->if_index;
		else
			rip6src.sin6_scope_id = 0;
	} else
		rip6src.sin6_scope_id = 0;

#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	LIST_FOREACH(in6p, &ripcb, inp_list)
#else
	for (in6p = rawin6pcb.in6p_next;
	     in6p != &rawin6pcb; in6p = in6p->in6p_next)
#endif
	{
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
		if ((in6p->inp_vflag & INP_IPV6) == NULL)
			continue;
#endif
		if (in6p->in6p_ip6_nxt != IPPROTO_ICMPV6)
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_laddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_laddr, &ip6->ip6_dst))
			continue;
		if (!IN6_IS_ADDR_UNSPECIFIED(&in6p->in6p_faddr) &&
		   !IN6_ARE_ADDR_EQUAL(&in6p->in6p_faddr, &ip6->ip6_src))
			continue;
		if (in6p->in6p_icmp6filt
		    && ICMP6_FILTER_WILLBLOCK(icmp6->icmp6_type,
				 in6p->in6p_icmp6filt))
			continue;
		if (last) {
			struct	mbuf *n;
			if ((n = m_copy(m, 0, (int)M_COPYALL)) != NULL) {
				if (last->in6p_flags & IN6P_CONTROLOPTS)
					ip6_savecontrol(last, &opts, ip6, n);
				/* strip intermediate headers */
				m_adj(n, off);
				if (sbappendaddr(&last->in6p_socket->so_rcv,
						 (struct sockaddr *)&rip6src,
						 n, opts) == 0) {
					/* should notify about lost packet */
					m_freem(n);
					if (opts)
						m_freem(opts);
				} else
					sorwakeup(last->in6p_socket);
				opts = NULL;
			}
		}
		last = in6p;
	}
	if (last) {
		if (last->in6p_flags & IN6P_CONTROLOPTS)
			ip6_savecontrol(last, &opts, ip6, m);
		/* strip intermediate headers */
		m_adj(m, off);
		if (sbappendaddr(&last->in6p_socket->so_rcv,
				(struct sockaddr *)&rip6src, m, opts) == 0) {
			m_freem(m);
			if (opts)
				m_freem(opts);
		} else
			sorwakeup(last->in6p_socket);
	} else {
		m_freem(m);
		ip6stat.ip6s_delivered--;
	}
	return IPPROTO_DONE;
}
#endif /*OpenBSD*/

a1208 6
#ifdef __FreeBSD__
			RTFREE(icmp6_reflect_rt.ro_rt);
#endif
#ifdef __bsdi__
			rtfree(icmp6_reflect_rt.ro_rt);
#endif
a1215 4
#ifdef __FreeBSD__
		rtalloc_ign((struct route *)&icmp6_reflect_rt.ro_rt,
			    RTF_PRCLONING);
#else
a1216 1
#endif
a1311 1
#if !defined(__OpenBSD__) && !defined(__bsdi__)
d1313 1
a1313 5
		ip6_sprintf(src6), ip6_sprintf(dst6), ip6_sprintf(tgt6));
#else
	sprintf(buf, "(src=%s dst=%s tgt=%s)",
		ip6_sprintf(src6), ip6_sprintf(dst6), ip6_sprintf(tgt6));
#endif
d1375 1
a1375 5
	rt = rtalloc1((struct sockaddr *)&sin6, 0
#ifdef __FreeBSD__
		      , 0UL
#endif
		      );
a1455 3
#ifdef __bsdi__
		extern int icmp_redirtimeout;	/*XXX*/
#endif
a1468 3
#ifdef __bsdi__
			   icmp_redirtimeout
#else
a1469 1
#endif /*__FreeBSD__, __NetBSD__, __bsdi__*/
a1650 4
#ifdef M_DECRYPTED	/*not openbsd*/
	if (m0->m_flags & M_DECRYPTED)
		goto noredhdropt;
#endif
a1720 3
#ifdef M_DECRYPTED	/*not openbsd*/
noredhdropt:;
#endif
a1766 5
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
icmp6_ctloutput(so, sopt)
	struct socket *so;
	struct sockopt *sopt;
#else
a1771 1
#endif
a1774 1
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
a1775 15
	int level, op, optname;

	if (sopt) {
		level = sopt->sopt_level;
		op = sopt->sopt_dir;
		optname = sopt->sopt_name;
		optlen = sopt->sopt_valsize;
	} else
		level = op = optname = optlen = 0;
#else
#if defined(__OpenBSD__)
	register struct inpcb *inp = sotoinpcb(so);
#else
	register struct in6pcb *in6p = sotoin6pcb(so);
#endif
a1778 1
#endif
a1780 1
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
a1782 1
#endif
a1796 8
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			if (inp->in6p_icmp6filt == NULL) {
				error = EINVAL;
				break;
			}
			error = sooptcopyin(sopt, inp->in6p_icmp6filt, optlen,
				optlen);
#elif defined(__OpenBSD__)
a1804 10
#else
			p = mtod(m, struct icmp6_filter *);
			if (!p || !in6p->in6p_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(p, in6p->in6p_icmp6filt,
				sizeof(struct icmp6_filter));
			error = 0;
#endif
a1811 4
#if !(defined(__FreeBSD__) && __FreeBSD__ >= 3)
		if (m)
			(void)m_freem(m);
#endif		
a1817 8
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
			if (inp->in6p_icmp6filt == NULL) {
				error = EINVAL;
				break;
			}
			error = sooptcopyout(sopt, inp->in6p_icmp6filt,
				sizeof(struct icmp6_filter));
#elif defined(__OpenBSD__)
a1827 12
#else
			struct icmp6_filter *p;

			p = mtod(m, struct icmp6_filter *);
			if (!p || !in6p->in6p_icmp6filt) {
				error = EINVAL;
				break;
			}
			bcopy(in6p->in6p_icmp6filt, p,
				sizeof(struct icmp6_filter));
			error = 0;
#endif
a1861 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
	microtime(&tp);
	tp.tv_sec = time_second;
#else
a1862 1
#endif
a1880 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1935 45
#endif /*__NetBSD__ || __OpenBSD__*/

#ifdef __bsdi__
void
icmp6_mtuexpire(rt, rtt)
	struct rtentry *rt;
	struct rttimer *rtt;
{
	rt->rt_flags |= RTF_PROBEMTU;
	Free(rtt);
}

int *icmp6_sysvars[] = ICMPV6CTL_VARS;

int
icmp6_sysctl(name, namelen, oldp, oldlenp, newp, newlen)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
{
	if (name[0] >= ICMPV6CTL_MAXID)
		return (EOPNOTSUPP);
	switch (name[0]) {
#if 0
	ICMPV6CTL_ND6_PRUNE:
	ICMPV6CTL_ND6_DELAY:
	ICMPV6CTL_ND6_UMAXTRIES:
	ICMPV6CTL_ND6_MMAXTRIES:
	ICMPV6CTL_ND6_USELOOPBACK:
	ICMPV6CTL_ND6_PROXYALL:
		/* need to check the value. */
#endif
	case ICMPV6CTL_STATS:
		return sysctl_rdtrunc(oldp, oldlenp, newp, &icmp6stat,
		    sizeof(icmp6stat));

	default:
		return (sysctl_int_arr(icmp6_sysvars, name, namelen,
		    oldp, oldlenp, newp, newlen));
	}
}
#endif /*__bsdi__*/
a1936 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1984 1
#endif /* __NetBSD__ */
@

