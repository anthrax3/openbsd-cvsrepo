head	1.18;
access;
symbols
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.13.0.4
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.2
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.7.0.26
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.24
	OPENBSD_5_0:1.7.0.22
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.20
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.18
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.14
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.6.0.12
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.10
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.8
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.6
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.4
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.4
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.2
	SMP_BASE:1.2
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.18
date	2017.02.01.20.59.47;	author dhill;	state Exp;
branches;
next	1.17;
commitid	UBL7uwpXqTP4EWIu;

1.17
date	2016.12.22.11.04.44;	author rzalamena;	state Exp;
branches;
next	1.16;
commitid	T2qzeepA7r1EGy1x;

1.16
date	2015.06.08.22.19.28;	author krw;	state Exp;
branches;
next	1.15;
commitid	4Ro7ulidQXNcMvmM;

1.15
date	2015.02.09.12.23.22;	author claudio;	state Exp;
branches;
next	1.14;
commitid	lhMJN7NMGgqb766x;

1.14
date	2014.07.09.15.35.53;	author mpi;	state Exp;
branches;
next	1.13;
commitid	rcrNPIflhvgmU1TF;

1.13
date	2013.10.29.19.05.45;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2013.10.27.20.57.39;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2013.10.21.12.36.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2013.10.21.10.07.04;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2013.05.02.11.54.10;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2012.09.19.22.37.23;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.06.02.56.58;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.08.10.23.32;	author itojun;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.27.12;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.16.08.12.30;	author itojun;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2000.05.19.13.11.34;	author itojun;	state Exp;
branches;
next	1.2;

1.2
date	99.12.10.10.04.28;	author angelos;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.08.06.50.21;	author itojun;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.40.19;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2002.03.28.14.56.46;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.02.19.10.57.25;	author niklas;	state Exp;
branches;
next	;

1.4.6.1
date	2002.06.11.03.31.37;	author art;	state Exp;
branches;
next	;


desc
@@


1.18
log
@In sogetopt, preallocate an mbuf to avoid using sleeping mallocs with
the netlock held.  This also changes the prototypes of the *ctloutput
functions to take an mbuf instead of an mbuf pointer.

help, guidance from bluhm@@ and mpi@@
ok bluhm@@
@
text
@/*	$OpenBSD: ip6_mroute.h,v 1.17 2016/12/22 11:04:44 rzalamena Exp $	*/
/*	$KAME: ip6_mroute.h,v 1.17 2001/02/10 02:05:52 itojun Exp $	*/

/*
 * Copyright (C) 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Definitions for IP multicast forwarding.
 *
 * Written by David Waitzman, BBN Labs, August 1988.
 * Modified by Steve Deering, Stanford, February 1989.
 * Modified by Ajit Thyagarajan, PARC, August 1993.
 * Modified by Ajit Thyagarajan, PARC, August 1994.
 * Modified by Ahmed Helmy, USC, September 1996.
 *
 * MROUTING Revision: 1.2
 */

#ifndef _NETINET6_IP6_MROUTE_H_
#define _NETINET6_IP6_MROUTE_H_

/*
 * Multicast Routing set/getsockopt commands.
 */
#define MRT6_DONE		101	/* shut down forwarder */
#define MRT6_ADD_MIF		102	/* add multicast interface */
#define MRT6_DEL_MIF		103	/* delete multicast interface */
#define MRT6_ADD_MFC		104	/* insert forwarding cache entry */
#define MRT6_DEL_MFC		105	/* delete forwarding cache entry */
#define MRT6_INIT		108	/* initialize forwarder (mrt6msg) */

/*
 * Types and macros for handling bitmaps with one bit per multicast interface.
 */
typedef u_short mifi_t;		/* type of a mif index */
#define MAXMIFS		64

/*
 * Assume inclusion of sys/param.h or sys/select.h for howmany()
 */
#define	__NIFBITS	(sizeof(uint32_t) * 8)	/* bits per mask */
typedef	struct if_set {
	uint32_t	ifs_bits[howmany(256, __NIFBITS)];
} if_set;

#define	IF_SET(n, p) \
	((p)->ifs_bits[(n)/__NIFBITS] |= (1U << ((n) % __NIFBITS)))
#define	IF_CLR(n, p) \
	((p)->ifs_bits[(n)/__NIFBITS] &= ~(1U << ((n) % __NIFBITS)))
#define	IF_ISSET(n, p) \
	((p)->ifs_bits[(n)/__NIFBITS] & (1U << ((n) % __NIFBITS)))
#define	IF_COPY(f, t)	memcpy(t, f, sizeof(*(f)))
#define	IF_ZERO(p)	memset(p, 0, sizeof(*(p)))

/*
 * Argument structure for MRT6_ADD_IF.
 */
struct mif6ctl {
	mifi_t	    mif6c_mifi;		/* the index of the mif to be added  */
	u_char	    mif6c_flags;	/* MIFF_ flags defined below         */
	u_short	    mif6c_pifi;		/* the index of the physical IF */
#ifdef notyet
	u_int	    mif6c_rate_limit;    /* max rate			     */
#endif
};

#define	MIFF_REGISTER	0x1	/* mif represents a register end-point */

#define MF6C_INCOMPLETE_PARENT ((mifi_t)-1)

/*
 * Argument structure for MRT6_ADD_MFC and MRT6_DEL_MFC
 */
struct mf6cctl {
	struct sockaddr_in6 mf6cc_origin;	/* IPv6 origin of mcasts */
	struct sockaddr_in6 mf6cc_mcastgrp; /* multicast group associated */
	mifi_t		mf6cc_parent;	/* incoming ifindex */
	struct if_set	mf6cc_ifset;	/* set of forwarding ifs */
};

/* structure used to get all the mif entries via sysctl */
struct mif6info {
	struct in6_addr	m6_lcl_addr;	/* local interface address           */
	u_int16_t	m6_ifindex;	/* interface index                   */
	u_int64_t	m6_pkt_in;	/* # pkts in on interface            */
	u_int64_t	m6_pkt_out;	/* # pkts out on interface           */
	u_int64_t	m6_bytes_in;	/* # bytes in on interface	     */
	u_int64_t	m6_bytes_out;	/* # bytes out on interface	     */
	u_int		m6_rate_limit;	/* max rate			     */
	mifi_t		m6_mifi;
        u_char		m6_flags;	/* MIFF_ flags defined above         */
};

/* structure used to get all the mf6c entries via sysctl */
struct mf6cinfo {
	struct sockaddr_in6  mf6c_origin;	/* IPv6 origin of mcasts     */
	struct sockaddr_in6  mf6c_mcastgrp;	/* multicast group associated*/
	mifi_t		 mf6c_parent;		/* incoming IF               */
	struct if_set	 mf6c_ifset;		/* set of outgoing IFs */

	u_int64_t	mf6c_pkt_cnt;		/* pkt count for src-grp     */
	u_int64_t	mf6c_byte_cnt;		/* byte count for src-grp    */
	u_int64_t	mf6c_stall_cnt;		/* pkt-cnt waiting for route */
};

/*
 * The kernel's multicast routing statistics.
 */
struct mrt6stat {
	u_int64_t mrt6s_mfc_lookups;	/* # forw. cache hash table hits   */
	u_int64_t mrt6s_mfc_misses;	/* # forw. cache hash table misses */
	u_int64_t mrt6s_upcalls;	/* # calls to mrouted              */
	u_int64_t mrt6s_no_route;	/* no route for packet's origin    */
	u_int64_t mrt6s_bad_tunnel;	/* malformed tunnel options        */
	u_int64_t mrt6s_cant_tunnel;	/* no room for tunnel options      */
	u_int64_t mrt6s_wrong_if;	/* arrived on wrong interface	   */
	u_int64_t mrt6s_upq_ovflw;	/* upcall Q overflow		   */
	u_int64_t mrt6s_cache_cleanups;	/* # entries with no upcalls	   */
	u_int64_t mrt6s_drop_sel;	/* pkts dropped selectively        */
	u_int64_t mrt6s_q_overflow;	/* pkts dropped - Q overflow       */
	u_int64_t mrt6s_pkt2large;	/* pkts dropped - size > BKT SIZE  */
	u_int64_t mrt6s_upq_sockfull;	/* upcalls dropped - socket full   */
};

/*
 * Structure used to communicate from kernel to multicast router.
 * We'll overlay the structure onto an MLD header (not an IPv6 header
 * like igmpmsg{} used for IPv4 implementation). This is because this
 * structure will be passed via an IPv6 raw socket, on which an application
 * will only receive the payload i.e. the data after the IPv6 header and all
 * the extension headers. (see Section 3 of draft-ietf-ipngwg-2292bis-01)
 */
struct mrt6msg {
#define MRT6MSG_NOCACHE		1
#define MRT6MSG_WRONGMIF	2
#define MRT6MSG_WHOLEPKT	3		/* used for user level encap*/
	u_char	    im6_mbz;			/* must be zero		    */
	u_char	    im6_msgtype;		/* what type of message	    */
	u_int16_t   im6_mif;			/* mif rec'd on		    */
	u_int32_t   im6_pad;			/* padding for 64bit arch   */
	struct in6_addr  im6_src, im6_dst;
};

/*
 * Argument structure used by multicast routing daemon to get src-grp
 * packet counts
 */
struct sioc_sg_req6 {
	struct sockaddr_in6 src;
	struct sockaddr_in6 grp;
	u_int64_t pktcnt;
	u_int64_t bytecnt;
	u_int64_t wrong_if;
};

/*
 * Argument structure used by mrouted to get mif pkt counts
 */
struct sioc_mif_req6 {
	mifi_t mifi;		/* mif number				*/
	u_int64_t icount;	/* Input packet count on mif		*/
	u_int64_t ocount;	/* Output packet count on mif		*/
	u_int64_t ibytes;	/* Input byte count on mif		*/
	u_int64_t obytes;	/* Output byte count on mif		*/
};

#if defined(_KERNEL)
/*
 * The kernel's multicast-interface structure.
 */
struct mif6 {
        u_char		m6_flags;	/* MIFF_ flags defined above         */
	u_int		m6_rate_limit;	/* max rate			     */
#ifdef notyet
	struct tbf      *m6_tbf;	/* token bucket structure at intf.   */
#endif
	struct in6_addr	m6_lcl_addr;	/* local interface address           */
	struct ifnet    *m6_ifp;	/* pointer to interface              */
	u_int64_t	m6_pkt_in;	/* # pkts in on interface            */
	u_int64_t	m6_pkt_out;	/* # pkts out on interface           */
	u_int64_t	m6_bytes_in;	/* # bytes in on interface	     */
	u_int64_t	m6_bytes_out;	/* # bytes out on interface	     */
};

/*
 * The kernel's multicast forwarding cache entry structure
 */
struct mf6c {
	struct sockaddr_in6  mf6c_origin;	/* IPv6 origin of mcasts     */
	struct sockaddr_in6  mf6c_mcastgrp;	/* multicast group associated*/
	mifi_t		 mf6c_parent;		/* incoming IF               */
	struct if_set	 mf6c_ifset;		/* set of outgoing IFs */

	u_int64_t	mf6c_pkt_cnt;		/* pkt count for src-grp     */
	u_int64_t	mf6c_byte_cnt;		/* byte count for src-grp    */
	u_int64_t	mf6c_wrong_if;		/* wrong if for src-grp	     */
	int		mf6c_expire;		/* time to clean entry up    */
	struct timeval  mf6c_last_assert;	/* last time I sent an assert*/
	struct rtdetq  *mf6c_stall;		/* pkts waiting for route */
	struct mf6c    *mf6c_next;		/* hash table linkage */
};

/*
 * Argument structure used for pkt info. while upcall is made
 */
#ifndef _NETINET_IP_MROUTE_H_
struct rtdetq {		/* XXX: rtdetq is also defined in ip_mroute.h */
	struct mbuf	*m;		/* A copy of the packet		    */
	struct ifnet	*ifp;		/* Interface pkt came in on	    */
	struct rtdetq	*next;
};
#endif /* _NETINET_IP_MROUTE_H_ */

#define MF6CTBLSIZ	256
#if (MF6CTBLSIZ & (MF6CTBLSIZ - 1)) == 0	  /* from sys:route.h */
#define MF6CHASHMOD(h)	((h) & (MF6CTBLSIZ - 1))
#else
#define MF6CHASHMOD(h)	((h) % MF6CTBLSIZ)
#endif

#define MAX_UPQ6	4		/* max. no of pkts in upcall Q */

int	ip6_mrouter_set(int, struct socket *, struct mbuf *);
int	ip6_mrouter_get(int, struct socket *, struct mbuf *);
int	ip6_mrouter_done(void);
void	ip6_mrouter_detach(struct ifnet *);
int	mrt6_ioctl(u_long, caddr_t);
int	mrt6_sysctl_mif(void *, size_t *);
int	mrt6_sysctl_mfc(void *, size_t *);
#endif /* _KERNEL */

#endif /* !_NETINET6_IP6_MROUTE_H_ */
@


1.17
log
@Remove PIM support from the multicast stack.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.16 2015/06/08 22:19:28 krw Exp $	*/
d250 1
a250 1
int	ip6_mrouter_get(int, struct socket *, struct mbuf **);
@


1.16
log
@More damned eye searing whitespace. No change to .o files.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.15 2015/02/09 12:23:22 claudio Exp $	*/
a55 1
#define MRT6_PIM                107     /* enable pim code */
@


1.15
log
@Implement 2 sysctl to retrieve the multicast forwarding cache (mf6c) and the
multicast interface table (mif6). Will be used by netstat soon.
Looked over by guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.14 2014/07/09 15:35:53 mpi Exp $	*/
d86 2
a87 2
	mifi_t	    mif6c_mifi;	    	/* the index of the mif to be added  */
	u_char	    mif6c_flags;     	/* MIFF_ flags defined below         */
d90 1
a90 1
	u_int	    mif6c_rate_limit;    /* max rate           		     */
d110 2
a111 2
	struct in6_addr	m6_lcl_addr;   	/* local interface address           */
	u_int16_t 	m6_ifindex;    	/* interface index                   */
d116 1
a116 1
	u_int      	m6_rate_limit; 	/* max rate			     */
d118 1
a118 1
        u_char   	m6_flags;     	/* MIFF_ flags defined above         */
d125 1
a125 1
	mifi_t	    	 mf6c_parent; 		/* incoming IF               */
d128 3
a130 3
	u_int64_t    	mf6c_pkt_cnt;		/* pkt count for src-grp     */
	u_int64_t    	mf6c_byte_cnt;		/* byte count for src-grp    */
	u_int64_t    	mf6c_stall_cnt;		/* pkt-cnt waiting for route */
d145 4
a148 4
	u_int64_t mrt6s_cache_cleanups;	/* # entries with no upcalls 	   */
	u_int64_t mrt6s_drop_sel;     	/* pkts dropped selectively        */
	u_int64_t mrt6s_q_overflow;    	/* pkts dropped - Q overflow       */
	u_int64_t mrt6s_pkt2large;     	/* pkts dropped - size > BKT SIZE  */
d199 2
a200 2
        u_char   	m6_flags;     	/* MIFF_ flags defined above         */
	u_int      	m6_rate_limit; 	/* max rate			     */
d202 1
a202 1
	struct tbf      *m6_tbf;      	/* token bucket structure at intf.   */
d204 2
a205 2
	struct in6_addr	m6_lcl_addr;   	/* local interface address           */
	struct ifnet    *m6_ifp;     	/* pointer to interface              */
d218 1
a218 1
	mifi_t	    	 mf6c_parent; 		/* incoming IF               */
d221 4
a224 4
	u_int64_t    	mf6c_pkt_cnt;		/* pkt count for src-grp     */
	u_int64_t    	mf6c_byte_cnt;		/* byte count for src-grp    */
	u_int64_t    	mf6c_wrong_if;		/* wrong if for src-grp	     */
	int	    	mf6c_expire;		/* time to clean entry up    */
d235 2
a236 2
	struct mbuf	*m;		/* A copy of the packet	    	    */
	struct ifnet	*ifp;		/* Interface pkt came in on 	    */
@


1.14
log
@Kill unused route storages.

blambert@@, henning@@, lteo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.13 2013/10/29 19:05:45 deraadt Exp $	*/
d96 2
d108 25
a229 2
#define MF6C_INCOMPLETE_PARENT ((mifi_t)-1)

d255 2
@


1.13
log
@remove left over bits of omrt6msg, and cleanup the yucky
clone of fd_set for interfaces
tested in ports tree build by naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.12 2013/10/27 20:57:39 deraadt Exp $	*/
a182 1
	struct route_in6 m6_route;/* cached route if this is a tunnel */
@


1.12
log
@delete UPCALL_TIMING debug code from a the dark ages
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.11 2013/10/21 12:36:14 deraadt Exp $	*/
a50 3
#ifdef _KERNEL
#define MRT6_OINIT		100	/* initialize forwarder (omrt6msg) */
#endif
d65 4
a68 11
#ifndef	IF_SETSIZE
#define	IF_SETSIZE	256
#endif

typedef	u_int32_t	if_mask;
#define	NIFBITS	(sizeof(if_mask) * NBBY)	/* bits per mask */

#ifndef howmany
#define	howmany(x, y)	(((x) + ((y) - 1)) / (y))
#endif

d70 1
a70 1
	if_mask	ifs_bits[howmany(IF_SETSIZE, NIFBITS)];
d73 8
a80 5
#define	IF_SET(n, p)	((p)->ifs_bits[(n)/NIFBITS] |= (1 << ((n) % NIFBITS)))
#define	IF_CLR(n, p)	((p)->ifs_bits[(n)/NIFBITS] &= ~(1 << ((n) % NIFBITS)))
#define	IF_ISSET(n, p)	((p)->ifs_bits[(n)/NIFBITS] & (1 << ((n) % NIFBITS)))
#define	IF_COPY(f, t)	bcopy(f, t, sizeof(*(f)))
#define	IF_ZERO(p)	bzero(p, sizeof(*(p)))
a123 21

#ifdef MRT6_OINIT
/*
 * Struct used to communicate from kernel to multicast router
 * note the convenient similarity to an IPv6 header.
 * XXX old version, superseded by mrt6msg.
 */
struct omrt6msg {
	u_long	    unused1;
	u_char	    im6_msgtype;		/* what type of message	    */
#if 0
#define MRT6MSG_NOCACHE	1
#define MRT6MSG_WRONGMIF	2
#define MRT6MSG_WHOLEPKT	3		/* used for user level encap*/
#endif
	u_char	    im6_mbz;			/* must be zero		    */
	u_char	    im6_mif;			/* mif rec'd on		    */
	u_char	    unused2;
	struct in6_addr  im6_src, im6_dst;
};
#endif
@


1.11
log
@no more #ifdef KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.10 2013/10/21 10:07:04 deraadt Exp $	*/
d239 3
a241 6
    struct mbuf 	*m;		/* A copy of the packet	    	    */
    struct ifnet	*ifp;		/* Interface pkt came in on 	    */
#ifdef UPCALL_TIMING
    struct timeval	t;		/* Timestamp */
#endif /* UPCALL_TIMING */
    struct rtdetq	*next;
@


1.10
log
@remove GET_TIME() wrapper
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.9 2013/05/02 11:54:10 mpi Exp $	*/
a32 2
/*	BSDI ip_mroute.h,v 2.5 1996/10/11 16:01:48 pjd Exp	*/

d195 1
a195 1
#if defined(_KERNEL) || defined(KERNEL)
@


1.9
log
@tedu broken Resource Reservation Protocol code that was ifdef RSVP_ISI.

ok deraadt@@, tedu@@ (implicit)
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.8 2012/09/19 22:37:23 jsg Exp $	*/
a62 8

#if BSD >= 199103
#define GET_TIME(t)	microtime(&t)
#elif defined(sun)
#define GET_TIME(t)	uniqtime(&t)
#else
#define GET_TIME(t)	((t) = time)
#endif
@


1.8
log
@ioctl requests are u_long not int, spotted via clang
ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.7 2006/07/06 02:56:58 brad Exp $	*/
a221 4
#ifdef notyet
	u_int		m6_rsvp_on;	/* RSVP listening on this vif */
	struct socket   *m6_rsvpd;	/* RSVP daemon socket */
#endif
@


1.7
log
@u_quad_t -> u_int64_t

no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.6 2003/07/08 10:23:32 itojun Exp $	*/
d275 1
a275 1
int	mrt6_ioctl(int, caddr_t);
@


1.6
log
@on interface removal, clear multicast forwarding stuff.  from kame
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.5 2002/03/14 01:27:12 millert Exp $	*/
d127 13
a139 13
	u_quad_t mrt6s_mfc_lookups;	/* # forw. cache hash table hits   */
	u_quad_t mrt6s_mfc_misses;	/* # forw. cache hash table misses */
	u_quad_t mrt6s_upcalls;		/* # calls to mrouted              */
	u_quad_t mrt6s_no_route;	/* no route for packet's origin    */
	u_quad_t mrt6s_bad_tunnel;	/* malformed tunnel options        */
	u_quad_t mrt6s_cant_tunnel;	/* no room for tunnel options      */
	u_quad_t mrt6s_wrong_if;	/* arrived on wrong interface	   */
	u_quad_t mrt6s_upq_ovflw;	/* upcall Q overflow		   */
	u_quad_t mrt6s_cache_cleanups;	/* # entries with no upcalls 	   */
	u_quad_t mrt6s_drop_sel;     	/* pkts dropped selectively        */
	u_quad_t mrt6s_q_overflow;    	/* pkts dropped - Q overflow       */
	u_quad_t mrt6s_pkt2large;     	/* pkts dropped - size > BKT SIZE  */
	u_quad_t mrt6s_upq_sockfull;	/* upcalls dropped - socket full   */
d189 3
a191 3
	u_quad_t pktcnt;
	u_quad_t bytecnt;
	u_quad_t wrong_if;
d199 4
a202 4
	u_quad_t icount;	/* Input packet count on mif		*/
	u_quad_t ocount;	/* Output packet count on mif		*/
	u_quad_t ibytes;	/* Input byte count on mif		*/
	u_quad_t obytes;	/* Output byte count on mif		*/
d217 4
a220 4
	u_quad_t	m6_pkt_in;	/* # pkts in on interface            */
	u_quad_t	m6_pkt_out;	/* # pkts out on interface           */
	u_quad_t	m6_bytes_in;	/* # bytes in on interface	     */
	u_quad_t	m6_bytes_out;	/* # bytes out on interface	     */
d237 3
a239 3
	u_quad_t    	mf6c_pkt_cnt;		/* pkt count for src-grp     */
	u_quad_t    	mf6c_byte_cnt;		/* byte count for src-grp    */
	u_quad_t    	mf6c_wrong_if;		/* wrong if for src-grp	     */
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.4 2001/02/16 08:12:30 itojun Exp $	*/
d274 1
@


1.4
log
@fix multicast API for sizeof(long) != 4.  (IF_SET and family will not
overrun, it will compute values too little, so old code will not
overrun buffers. (we don't include any multicast daemons in openbsd tree)

sync better with kame.  remove register variable declarations, styles
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.3 2000/05/19 13:11:34 itojun Exp $	*/
d271 4
a274 4
int	ip6_mrouter_set __P((int, struct socket *, struct mbuf *));
int	ip6_mrouter_get __P((int, struct socket *, struct mbuf **));
int	ip6_mrouter_done __P((void));
int	mrt6_ioctl __P((int, caddr_t));
@


1.4.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ip6_mroute.h,v 1.4 2001/02/16 08:12:30 itojun Exp $	*/
d271 4
a274 4
int	ip6_mrouter_set(int, struct socket *, struct mbuf *);
int	ip6_mrouter_get(int, struct socket *, struct mbuf **);
int	ip6_mrouter_done(void);
int	mrt6_ioctl(int, caddr_t);
@


1.3
log
@update multicast routing message (struct mrt6msg) to the latest kame.
structure overlaying is corrected to meet IPv6 raw socket spec.

just to be sure, binary backward compatiblity is provided since we shipped
old message handling with openbsd 2.7.  no openbsd 2.7 userland code have
used the API, though, because we did not merge kame pim6[sd]d to openbsd due to
mrouted license issue.
@
text
@d1 2
a2 2
/*	$OpenBSD: ip6_mroute.h,v 1.2 1999/12/10 10:04:28 angelos Exp $	*/
/*	$KAME: ip6_mroute.h,v 1.10 2000/05/19 02:38:53 itojun Exp $	*/
d82 1
a82 1
typedef	long	if_mask;
d90 1
a90 1
	fd_mask	ifs_bits[howmany(IF_SETSIZE, NIFBITS)];
@


1.2
log
@Remove remaining unnecessary ifdefs (itojun will hate me for this :-)
@
text
@d1 2
a2 1
/*	$OpenBSD: ip6_mroute.h,v 1.1 1999/12/08 06:50:21 itojun Exp $	*/
d7 1
a7 1
 * 
d19 1
a19 1
 * 
d53 3
a55 1
#define MRT6_INIT		100	/* initialize forwarder */
d62 1
d64 1
a64 1
#if BSD >= 199103 
d142 1
d146 1
d148 1
a148 1
struct mrt6msg {
d151 2
a152 1
#define MRT6MSG_NOCACHE		1
d155 1
d161 20
d214 1
a214 1
#endif 
d225 1
a225 1
#endif 
d229 1
a229 1
 * The kernel's multicast forwarding cache entry structure 
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: ip6_mroute.h,v 1.4 2001/02/16 08:12:30 itojun Exp $	*/
/*	$KAME: ip6_mroute.h,v 1.17 2001/02/10 02:05:52 itojun Exp $	*/
d6 1
a6 1
 *
d18 1
a18 1
 *
d52 1
a52 3
#ifdef _KERNEL
#define MRT6_OINIT		100	/* initialize forwarder (omrt6msg) */
#endif
a58 1
#define MRT6_INIT		108	/* initialize forwarder (mrt6msg) */
d60 1
a60 1
#if BSD >= 199103
d78 1
a78 1
typedef	u_int32_t	if_mask;
d86 1
a86 1
	if_mask	ifs_bits[howmany(IF_SETSIZE, NIFBITS)];
a137 1
#ifdef MRT6_OINIT
a140 1
 * XXX old version, superseded by mrt6msg.
d142 1
a142 1
struct omrt6msg {
d145 1
a145 2
#if 0
#define MRT6MSG_NOCACHE	1
a147 1
#endif
a152 20
#endif

/*
 * Structure used to communicate from kernel to multicast router.
 * We'll overlay the structure onto an MLD header (not an IPv6 header
 * like igmpmsg{} used for IPv4 implementation). This is because this
 * structure will be passed via an IPv6 raw socket, on which an application
 * will only receive the payload i.e. the data after the IPv6 header and all
 * the extension headers. (see Section 3 of draft-ietf-ipngwg-2292bis-01)
 */
struct mrt6msg {
#define MRT6MSG_NOCACHE		1
#define MRT6MSG_WRONGMIF	2
#define MRT6MSG_WHOLEPKT	3		/* used for user level encap*/
	u_char	    im6_mbz;			/* must be zero		    */
	u_char	    im6_msgtype;		/* what type of message	    */
	u_int16_t   im6_mif;			/* mif rec'd on		    */
	u_int32_t   im6_pad;			/* padding for 64bit arch   */
	struct in6_addr  im6_src, im6_dst;
};
d186 1
a186 1
#endif
d197 1
a197 1
#endif
d201 1
a201 1
 * The kernel's multicast forwarding cache entry structure
@


1.2.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d271 4
a274 4
int	ip6_mrouter_set(int, struct socket *, struct mbuf *);
int	ip6_mrouter_get(int, struct socket *, struct mbuf **);
int	ip6_mrouter_done(void);
int	mrt6_ioctl(int, caddr_t);
@


1.2.2.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a273 1
void	ip6_mrouter_detach(struct ifnet *);
@


1.1
log
@bring in KAME IPv6 code, dated 19991208.
replaces NRL IPv6 layer.  reuses NRL pcb layer.  no IPsec-on-v6 support.
see sys/netinet6/{TODO,IMPLEMENTATION} for more details.

GENERIC configuration should work fine as before.  GENERIC.v6 works fine
as well, but you'll need KAME userland tools to play with IPv6 (will be
bringed into soon).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a242 4
#if defined(__FreeBSD__) && __FreeBSD__ >= 3
int	ip6_mrouter_set __P((struct socket *so, struct sockopt *sopt));
int	ip6_mrouter_get __P((struct socket *so, struct sockopt *sopt));
#else
a244 1
#endif
@

