head	1.64;
access;
symbols
	OPENBSD_6_2:1.64.0.8
	OPENBSD_6_2_BASE:1.64
	OPENBSD_6_1:1.64.0.6
	OPENBSD_6_1_BASE:1.64
	OPENBSD_6_0:1.64.0.2
	OPENBSD_6_0_BASE:1.64
	OPENBSD_5_9:1.62.0.2
	OPENBSD_5_9_BASE:1.62
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.59.0.2
	OPENBSD_5_7_BASE:1.59
	OPENBSD_5_6:1.55.0.4
	OPENBSD_5_6_BASE:1.55
	OPENBSD_5_5:1.54.0.4
	OPENBSD_5_5_BASE:1.54
	OPENBSD_5_4:1.50.0.2
	OPENBSD_5_4_BASE:1.50
	OPENBSD_5_3:1.45.0.4
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.2
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.39.0.4
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.35.0.4
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.33.0.2
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.30.0.2
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.27.0.2
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7;
locks; strict;
comment	@ * @;


1.64
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.63;
commitid	wHLNY5GFNXJSFYaC;

1.63
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.62;
commitid	gAjwyca5TfuoJAhn;

1.62
date	2016.02.02.16.44.44;	author stefan;	state Exp;
branches;
next	1.61;
commitid	CyrlYMpaefGtarZA;

1.61
date	2015.09.23.15.37.26;	author tedu;	state Exp;
branches;
next	1.60;
commitid	xTdRXaXuj71z4icR;

1.60
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.59;
commitid	p4LJxGKbi0BU2cG6;

1.59
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.58;
commitid	C5iGb36LQxjM60Q3;

1.58
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.57;
commitid	P6Av4XGqOi3rFasL;

1.57
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.56;
commitid	4DOHz2gKfCx7RejS;

1.56
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.55;
commitid	EkuwmBeHv2Tqmdnx;

1.55
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.54;
commitid	C8XZQyreqTUCeixA;

1.54
date	2013.12.14.02.57.25;	author guenther;	state Exp;
branches;
next	1.53;

1.53
date	2013.09.22.15.42.53;	author guenther;	state Exp;
branches;
next	1.52;

1.52
date	2013.08.30.05.35.47;	author guenther;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.13.05.52.22;	author guenther;	state Exp;
branches;
next	1.50;

1.50
date	2013.06.11.16.42.16;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2013.06.02.15.38.26;	author guenther;	state Exp;
branches;
next	1.48;

1.48
date	2013.06.02.15.35.18;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.45;

1.45
date	2012.06.20.17.30.22;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.42;

1.42
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.41;

1.41
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2009.08.27.23.14.47;	author jolan;	state Exp;
branches;
next	1.38;

1.38
date	2009.08.14.22.23.45;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.05.04.35.25;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.08.01.27.51;	author chl;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.14.10.55.21;	author mk;	state Exp;
branches;
next	1.32;

1.32
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.09.20.54.01;	author jmc;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.29.13.02.20;	author chl;	state Exp;
branches;
next	1.28;

1.28
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.01.23.47.56;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.09.02.46.12;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.25.18.38.20;	author thib;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.21.17.29.31;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.09.04.23.09;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.09.04.14.25;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.08.23.29.20;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.08.23.11.59;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.08.20.53.31;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.05.17.57.50;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.01.00.08.57;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.24.15.09.17;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.14.16.48.10;	author pat;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.18.19.27.48;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2006.01.14.19.04.17;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.8;

1.8
date	2005.10.29.00.17.19;	author pedro;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.11.18.06.31;	author pedro;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.15.11.49.37;	author pedro;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.05.14.06.52;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.30.01.10.00;	author pedro;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.30.00.37.13;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.30.00.30.51;	author pedro;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.17.24.52;	author pedro;	state Exp;
branches;
next	;


desc
@@


1.64
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@/*	$OpenBSD: udf_vnops.c,v 1.63 2016/03/19 12:04:15 natano Exp $	*/

/*
 * Copyright (c) 2001, 2002 Scott Long <scottl@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/fs/udf/udf_vnops.c,v 1.50 2005/01/28 14:42:16 phk Exp $
 */

/*
 * Ported to OpenBSD by Pedro Martelletto in February 2005.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/pool.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/dirent.h>
#include <sys/queue.h>
#include <sys/endian.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <crypto/siphash.h>

#include <isofs/udf/ecma167-udf.h>
#include <isofs/udf/udf.h>
#include <isofs/udf/udf_extern.h>

int udf_bmap_internal(struct unode *, off_t, daddr_t *, uint32_t *);

struct vops udf_vops = {
	.vop_access	= udf_access,
	.vop_bmap	= udf_bmap,
	.vop_lookup	= udf_lookup,
	.vop_getattr	= udf_getattr,
	.vop_open	= udf_open,
	.vop_close	= udf_close,
	.vop_ioctl	= udf_ioctl,
	.vop_read	= udf_read,
	.vop_readdir	= udf_readdir,
	.vop_readlink	= udf_readlink,
	.vop_inactive	= udf_inactive,
	.vop_reclaim	= udf_reclaim,
	.vop_strategy	= udf_strategy,
	.vop_lock	= udf_lock,
	.vop_unlock	= udf_unlock,
	.vop_pathconf	= udf_pathconf,
	.vop_islocked	= udf_islocked,
	.vop_print	= udf_print
};

#define UDF_INVALID_BMAP	-1

/* Look up a unode based on the udfino_t passed in and return its vnode */
int
udf_hashlookup(struct umount *ump, udfino_t id, int flags, struct vnode **vpp)
{
	struct unode *up;
	struct udf_hash_lh *lh;
	struct proc *p = curproc;
	int error;

	*vpp = NULL;

loop:
	mtx_enter(&ump->um_hashmtx);
	lh = &ump->um_hashtbl[SipHash24(&ump->um_hashkey, &id, sizeof(id)) &
	    ump->um_hashsz];
	if (lh == NULL) {
		mtx_leave(&ump->um_hashmtx);
		return (ENOENT);
	}

	LIST_FOREACH(up, lh, u_le) {
		if (up->u_ino == id) {
			mtx_leave(&ump->um_hashmtx);
			error = vget(up->u_vnode, flags, p);
			if (error == ENOENT)
				goto loop;
			if (error)
				return (error);
			*vpp = up->u_vnode;
			return (0);
		}
	}

	mtx_leave(&ump->um_hashmtx);

	return (0);
}

int
udf_hashins(struct unode *up)
{
	struct umount *ump;
	struct udf_hash_lh *lh;
	struct proc *p = curproc;

	ump = up->u_ump;

	vn_lock(up->u_vnode, LK_EXCLUSIVE | LK_RETRY, p);
	mtx_enter(&ump->um_hashmtx);
	lh = &ump->um_hashtbl[SipHash24(&ump->um_hashkey,
	    &up->u_ino, sizeof(up->u_ino)) & ump->um_hashsz];
	if (lh == NULL)
		panic("hash entry is NULL, up->u_ino = %d", up->u_ino);
	LIST_INSERT_HEAD(lh, up, u_le);
	mtx_leave(&ump->um_hashmtx);

	return (0);
}

int
udf_hashrem(struct unode *up)
{
	struct umount *ump;
	struct udf_hash_lh *lh;

	ump = up->u_ump;

	mtx_enter(&ump->um_hashmtx);
	lh = &ump->um_hashtbl[SipHash24(&ump->um_hashkey,
	    &up->u_ino, sizeof(up->u_ino)) & ump->um_hashsz];
	if (lh == NULL)
		panic("hash entry is NULL, up->u_ino = %d", up->u_ino);
	LIST_REMOVE(up, u_le);
	mtx_leave(&ump->um_hashmtx);

	return (0);
}

int
udf_allocv(struct mount *mp, struct vnode **vpp, struct proc *p)
{
	int error;
	struct vnode *vp;

	error = getnewvnode(VT_UDF, mp, &udf_vops, &vp);
	if (error) {
		printf("udf_allocv: failed to allocate new vnode\n");
		return (error);
	}

	*vpp = vp;
	return (0);
}

/* Convert file entry permission (5 bits per owner/group/user) to a mode_t */
static mode_t
udf_permtomode(struct unode *up)
{
	uint32_t perm;
	uint16_t flags;
	mode_t mode;

	perm = letoh32(up->u_fentry->perm);
	flags = letoh16(up->u_fentry->icbtag.flags);

	mode = perm & UDF_FENTRY_PERM_USER_MASK;
	mode |= ((perm & UDF_FENTRY_PERM_GRP_MASK) >> 2);
	mode |= ((perm & UDF_FENTRY_PERM_OWNER_MASK) >> 4);
	mode |= ((flags & UDF_ICB_TAG_FLAGS_STICKY) << 4);
	mode |= ((flags & UDF_ICB_TAG_FLAGS_SETGID) << 6);
	mode |= ((flags & UDF_ICB_TAG_FLAGS_SETUID) << 8);

	return (mode);
}

int
udf_access(void *v)
{
	struct vop_access_args *ap = v;
	struct vnode *vp;
	struct unode *up;
	mode_t a_mode, mode;

	vp = ap->a_vp;
	up = VTOU(vp);
	a_mode = ap->a_mode;

	if (a_mode & VWRITE) {
		switch (vp->v_type) {
		case VDIR:
		case VLNK:
		case VREG:
			return (EROFS);
			/* NOTREACHED */
		default:
			break;
		}
	}

	mode = udf_permtomode(up);

	return (vaccess(vp->v_type, mode, up->u_fentry->uid, up->u_fentry->gid,
	    a_mode, ap->a_cred));
}

static int mon_lens[2][12] = {
	{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
	{31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};

static int
udf_isaleapyear(int year)
{
	int i;

	i = (year % 4) ? 0 : 1;
	i &= (year % 100) ? 1 : 0;
	i |= (year % 400) ? 0 : 1;

	return (i);
}

/*
 * This is just a rough hack.  Daylight savings isn't calculated and tv_nsec
 * is ignored.
 * Timezone calculation compliments of Julian Elischer <julian@@elischer.org>.
 */
static void
udf_timetotimespec(struct timestamp *time, struct timespec *t)
{
	int i, lpyear, daysinyear, year;
	union {
		uint16_t	u_tz_offset;
		int16_t		s_tz_offset;
	} tz;

	/* DirectCD seems to like using bogus year values */
	year = letoh16(time->year);
	if (year < 1970) {
		t->tv_sec = 0;
		t->tv_nsec = 0;
		return;
	}

	/* Calculate the time and day */
	t->tv_nsec = 1000 * time->usec + 100000 * time->hund_usec
	    + 10000000 * time->centisec;
	t->tv_sec = time->second;
	t->tv_sec += time->minute * 60;
	t->tv_sec += time->hour * 3600;
	t->tv_sec += time->day * 3600 * 24;

	/* Calculate the month */
	lpyear = udf_isaleapyear(year);
	for (i = 1; i < time->month; i++)
		t->tv_sec += mon_lens[lpyear][i] * 3600 * 24;

	/* Speed up the calculation */
	if (year > 1979)
		t->tv_sec += 315532800;
	if (year > 1989)
		t->tv_sec += 315619200;
	if (year > 1999)
		t->tv_sec += 315532800;
	for (i = 2000; i < year; i++) {
		daysinyear = udf_isaleapyear(i) + 365 ;
		t->tv_sec += daysinyear * 3600 * 24;
	}

	/*
	 * Calculate the time zone.  The timezone is 12 bit signed 2's
	 * compliment, so we gotta do some extra magic to handle it right.
	 */
	tz.u_tz_offset = letoh16(time->type_tz);
	tz.u_tz_offset &= 0x0fff;
	if (tz.u_tz_offset & 0x0800)
		tz.u_tz_offset |= 0xf000;	/* extend the sign to 16 bits */
	if ((time->type_tz & 0x1000) && (tz.s_tz_offset != -2047))
		t->tv_sec -= tz.s_tz_offset * 60;

	return;
}

int
udf_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp;
	struct unode *up;
	struct vattr *vap;
	struct extfile_entry *xfentry;
	struct file_entry *fentry;
	struct timespec ts;

	ts.tv_sec = 0;

	vp = ap->a_vp;
	vap = ap->a_vap;
	up = VTOU(vp);

	xfentry = up->u_fentry;
	fentry = (struct file_entry *)up->u_fentry;

	vap->va_fsid = up->u_dev;
	vap->va_fileid = up->u_ino;
	vap->va_mode = udf_permtomode(up);
	vap->va_nlink = letoh16(fentry->link_cnt);
	/*
	 * The spec says that -1 is valid for uid/gid and indicates an
	 * invalid uid/gid.  How should this be represented?
	 */
	vap->va_uid = (letoh32(fentry->uid) == -1) ? 0 : letoh32(fentry->uid);
	vap->va_gid = (letoh32(fentry->gid) == -1) ? 0 : letoh32(fentry->gid);
	vap->va_rdev = 0;
	if (vp->v_type & VDIR) {
		vap->va_nlink++; /* Count a reference to ourselves */
		/*
		 * Directories that are recorded within their ICB will show
		 * as having 0 blocks recorded.  Since tradition dictates
		 * that directories consume at least one logical block,
		 * make it appear so.
		 */
		vap->va_size = up->u_ump->um_bsize;
	} else
		vap->va_size = letoh64(fentry->inf_len);
	if (udf_checktag(&xfentry->tag, TAGID_EXTFENTRY) == 0) {
		udf_timetotimespec(&xfentry->atime, &vap->va_atime);
		udf_timetotimespec(&xfentry->mtime, &vap->va_mtime);
		if ((vp->v_type & VDIR) && xfentry->logblks_rec != 0)
			vap->va_size =
				    letoh64(xfentry->logblks_rec) * up->u_ump->um_bsize;
	} else {
		udf_timetotimespec(&fentry->atime, &vap->va_atime);
		udf_timetotimespec(&fentry->mtime, &vap->va_mtime);
		if ((vp->v_type & VDIR) && fentry->logblks_rec != 0)
			vap->va_size =
				    letoh64(fentry->logblks_rec) * up->u_ump->um_bsize;
	}
	vap->va_ctime = vap->va_mtime; /* Stored as an Extended Attribute */
	vap->va_flags = 0;
	vap->va_gen = 1;
	vap->va_blocksize = up->u_ump->um_bsize;
	vap->va_bytes = letoh64(fentry->inf_len);
	vap->va_type = vp->v_type;
	vap->va_filerev = 0;

	return (0);
}

int
udf_open(void *v)
{
	return (0); /* Nothing to be done at this point */
}

int
udf_close(void *v)
{
	return (0); /* Nothing to be done at this point */
}

/*
 * File specific ioctls.
 */
int
udf_ioctl(void *v)
{
	return (ENOTTY);
}

/*
 * I'm not sure that this has much value in a read-only filesystem, but
 * cd9660 has it too.
 */
int
udf_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = 65535;
		break;
	case _PC_NAME_MAX:
		*ap->a_retval = NAME_MAX;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 1;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1000;		/* 1 microsecond */
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

int
udf_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct uio *uio = ap->a_uio;
	struct unode *up = VTOU(vp);
	struct buf *bp;
	uint8_t *data;
	off_t fsize, offset;
	int error = 0;
	int size;

	if (uio->uio_offset < 0)
		return (EINVAL);

	fsize = letoh64(up->u_fentry->inf_len);

	while (uio->uio_offset < fsize && uio->uio_resid > 0) {
		offset = uio->uio_offset;
		size = ulmin(uio->uio_resid, MAXBSIZE);
		if (size > fsize - offset)
			size = fsize - offset;
		error = udf_readatoffset(up, &size, offset, &bp, &data);
		if (error == 0)
			error = uiomove(data, (size_t)size, uio);
		if (bp != NULL) {
			brelse(bp);
			bp = NULL;
		}
		if (error)
			break;
	};

	return (error);
}

/*
 * Translate the name from a CS0 dstring to a 16-bit Unicode String.
 * Hooks need to be placed in here to translate from Unicode to the encoding
 * that the kernel/user expects.  Return the length of the translated string.
 */
int
udf_transname(char *cs0string, char *destname, int len, struct umount *ump)
{
	unicode_t *transname;
	int i, unilen = 0, destlen;

	if (len > MAXNAMLEN) {
#ifdef DIAGNOSTIC
		printf("udf_transname(): name too long\n");
#endif
		return (0);
	}

	/* allocate a buffer big enough to hold an 8->16 bit expansion */
	transname = pool_get(&udf_trans_pool, PR_WAITOK);

	if ((unilen = udf_rawnametounicode(len, cs0string, transname)) == -1) {
#ifdef DIAGNOSTIC
		printf("udf_transname(): Unicode translation failed\n");
#endif
		pool_put(&udf_trans_pool, transname);
		return (0);
	}

	/* Pack it back to 8-bit Unicode. */
	for (i = 0; i < unilen ; i++)
		if (transname[i] & 0xff00)
			destname[i] = '?';	/* Fudge the 16bit chars */
		else
			destname[i] = transname[i] & 0xff;

	pool_put(&udf_trans_pool, transname);

	/* Don't forget to terminate the string. */
	destname[unilen] = 0;
	destlen = unilen;

	return (destlen);
}

/*
 * Compare a CS0 dstring with a name passed in from the VFS layer.  Return
 * 0 on a successful match, nonzero otherwise.  Unicode work may need to be
 * done here also.
 */
static int
udf_cmpname(char *cs0string, char *cmpname, int cs0len, int cmplen, struct umount *ump)
{
	char *transname;
	int error = 0;

	/* This is overkill, but not worth creating a new pool */
	transname = pool_get(&udf_trans_pool, PR_WAITOK);

	cs0len = udf_transname(cs0string, transname, cs0len, ump);

	/* Easy check.  If they aren't the same length, they aren't equal */
	if ((cs0len == 0) || (cs0len != cmplen))
		error = -1;
	else
		error = bcmp(transname, cmpname, cmplen);

	pool_put(&udf_trans_pool, transname);

	return (error);
}

struct udf_uiodir {
	struct dirent *dirent;
	int eofflag;
};

static int
udf_uiodir(struct udf_uiodir *uiodir, struct uio *uio, long off)
{
	size_t de_size = DIRENT_SIZE(uiodir->dirent);

	if (uio->uio_resid < de_size) {
		uiodir->eofflag = 0;
		return (-1);
	}
	uiodir->dirent->d_off = off;
	uiodir->dirent->d_reclen = de_size;

	return (uiomove(uiodir->dirent, de_size, uio));
}

static struct udf_dirstream *
udf_opendir(struct unode *up, int offset, int fsize, struct umount *ump)
{
	struct udf_dirstream *ds;

	ds = pool_get(&udf_ds_pool, PR_WAITOK | PR_ZERO);

	ds->node = up;
	ds->offset = offset;
	ds->ump = ump;
	ds->fsize = fsize;

	return (ds);
}

static struct fileid_desc *
udf_getfid(struct udf_dirstream *ds)
{
	struct fileid_desc *fid;
	int error, frag_size = 0, total_fid_size;

	/* End of directory? */
	if (ds->offset + ds->off >= ds->fsize) {
		ds->error = 0;
		return (NULL);
	}

	/* Grab the first extent of the directory */
	if (ds->off == 0) {
		ds->size = 0;
		error = udf_readatoffset(ds->node, &ds->size, ds->offset,
		    &ds->bp, &ds->data);
		if (error) {
			ds->error = error;
			if (ds->bp != NULL) {
				brelse(ds->bp);
				ds->bp = NULL;
			}
			return (NULL);
		}
	}

	/*
	 * Clean up from a previous fragmented FID.
	 * Is this the right place for this?
	 */
	if (ds->fid_fragment && ds->buf != NULL) {
		ds->fid_fragment = 0;
		free(ds->buf, M_UDFFID, 0);
	}

	fid = (struct fileid_desc*)&ds->data[ds->off];

	/*
	 * Check to see if the fid is fragmented. The first test
	 * ensures that we don't wander off the end of the buffer
	 * looking for the l_iu and l_fi fields.
	 */
	if (ds->off + UDF_FID_SIZE > ds->size ||
	    ds->off + letoh16(fid->l_iu) + fid->l_fi + UDF_FID_SIZE > ds->size){

		/* Copy what we have of the fid into a buffer */
		frag_size = ds->size - ds->off;
		if (frag_size >= ds->ump->um_bsize) {
			printf("udf: invalid FID fragment\n");
			ds->error = EINVAL;
			return (NULL);
		}

		/*
		 * File ID descriptors can only be at most one
		 * logical sector in size.
		 */
		ds->buf = malloc(ds->ump->um_bsize, M_UDFFID, M_WAITOK|M_ZERO);
		bcopy(fid, ds->buf, frag_size);

		/* Reduce all of the casting magic */
		fid = (struct fileid_desc*)ds->buf;

		if (ds->bp != NULL) {
			brelse(ds->bp);
			ds->bp = NULL;
		}

		/* Fetch the next allocation */
		ds->offset += ds->size;
		ds->size = 0;
		error = udf_readatoffset(ds->node, &ds->size, ds->offset,
		    &ds->bp, &ds->data);
		if (error) {
			ds->error = error;
			if (ds->bp != NULL) {
				brelse(ds->bp);
				ds->bp = NULL;
			}
			return (NULL);
		}

		/*
		 * If the fragment was so small that we didn't get
		 * the l_iu and l_fi fields, copy those in.
		 */
		if (frag_size < UDF_FID_SIZE)
			bcopy(ds->data, &ds->buf[frag_size],
			    UDF_FID_SIZE - frag_size);

		/*
		 * Now that we have enough of the fid to work with,
		 * copy in the rest of the fid from the new
		 * allocation.
		 */
		total_fid_size = UDF_FID_SIZE + letoh16(fid->l_iu) + fid->l_fi;
		if (total_fid_size > ds->ump->um_bsize) {
			printf("udf: invalid FID\n");
			ds->error = EIO;
			return (NULL);
		}
		bcopy(ds->data, &ds->buf[frag_size],
		    total_fid_size - frag_size);

		ds->fid_fragment = 1;
	} else {
		total_fid_size = letoh16(fid->l_iu) + fid->l_fi + UDF_FID_SIZE;
	}

	/*
	 * Update the offset. Align on a 4 byte boundary because the
	 * UDF spec says so.
	 */
	if (!ds->fid_fragment) {
		ds->off += (total_fid_size + 3) & ~0x03;
	} else {
		ds->off = (total_fid_size - frag_size + 3) & ~0x03;
	}
	ds->this_off = ds->offset + ds->off;

	return (fid);
}

static void
udf_closedir(struct udf_dirstream *ds)
{

	if (ds->bp != NULL) {
		brelse(ds->bp);
		ds->bp = NULL;
	}

	if (ds->fid_fragment && ds->buf != NULL)
		free(ds->buf, M_UDFFID, 0);

	pool_put(&udf_ds_pool, ds);
}

#define SELF_OFFSET	1
#define PARENT_OFFSET	2

int
udf_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	struct vnode *vp;
	struct uio *uio;
	struct dirent dir;
	struct unode *up;
	struct umount *ump;
	struct fileid_desc *fid;
	struct udf_uiodir uiodir;
	struct udf_dirstream *ds;
	off_t last_off;
	enum { MODE_NORMAL, MODE_SELF, MODE_PARENT } mode;
	int error = 0;

	vp = ap->a_vp;
	uio = ap->a_uio;
	up = VTOU(vp);
	ump = up->u_ump;
	uiodir.eofflag = 1;
	uiodir.dirent = &dir;
	memset(&dir, 0, sizeof(dir));

	/*
	 * if asked to start at SELF_OFFSET or PARENT_OFFSET, search
	 * for the parent ref
	 */
	if (uio->uio_offset == SELF_OFFSET) {
		mode = MODE_SELF;
		uio->uio_offset = 0;
	} else if (uio->uio_offset == PARENT_OFFSET) {
		mode = MODE_PARENT;
		uio->uio_offset = 0;
	} else
		mode = MODE_NORMAL;

	/*
	 * Iterate through the file id descriptors.  Give the parent dir
	 * entry special attention.
	 */
	if (ISSET(up->u_ump->um_flags, UDF_MNT_USES_META)) {
		up->u_ump->um_start += up->u_ump->um_meta_start;
		up->u_ump->um_len = up->u_ump->um_meta_len;
	}
	ds = udf_opendir(up, uio->uio_offset,
	    letoh64(up->u_fentry->inf_len), up->u_ump);

	last_off = ds->offset + ds->off;
	while ((fid = udf_getfid(ds)) != NULL) {

		/* Should we return an error on a bad fid? */
		if (udf_checktag(&fid->tag, TAGID_FID)) {
			printf("Invalid FID tag (%d)\n", fid->tag.id);
			error = EIO;
			break;
		}

		/* Is this a deleted file? */
		if (fid->file_char & UDF_FILE_CHAR_DEL)
			continue;

		if ((fid->l_fi == 0) && (fid->file_char & UDF_FILE_CHAR_PAR)) {
			/* Do up the '.' and '..' entries.  Dummy values are
			 * used for the offset since the offset here is
			 * usually zero, and NFS doesn't like that value
			 */
			if (mode == MODE_NORMAL) {
				dir.d_fileno = up->u_ino;
				dir.d_type = DT_DIR;
				dir.d_name[0] = '.';
				dir.d_name[1] = '\0';
				dir.d_namlen = 1;
				error = udf_uiodir(&uiodir, uio, SELF_OFFSET);
				if (error)
					break;
			}
			if (mode != MODE_PARENT) {
				dir.d_fileno = udf_getid(&fid->icb);
				dir.d_type = DT_DIR;
				dir.d_name[0] = '.';
				dir.d_name[1] = '.';
				dir.d_name[2] = '\0';
				dir.d_namlen = 2;
				error = udf_uiodir(&uiodir, uio, PARENT_OFFSET);
			}
			mode = MODE_NORMAL;
		} else if (mode != MODE_NORMAL) {
			continue;
		} else {
			dir.d_namlen = udf_transname(&fid->data[fid->l_iu],
			    &dir.d_name[0], fid->l_fi, ump);
			dir.d_fileno = udf_getid(&fid->icb);
			dir.d_type = (fid->file_char & UDF_FILE_CHAR_DIR) ?
			    DT_DIR : DT_UNKNOWN;
			error = udf_uiodir(&uiodir, uio, ds->this_off);
		}
		if (error) {
			/*
			 * udf_uiodir() indicates there isn't space for
			 * another entry by returning -1
			 */
			if (error == -1)
				error = 0;
			break;
		}
		last_off = ds->this_off;
	}

	/* tell the calling layer whether we need to be called again */
	*ap->a_eofflag = uiodir.eofflag;
	uio->uio_offset = last_off;

	if (!error)
		error = ds->error;

	udf_closedir(ds);
	if (ISSET(up->u_ump->um_flags, UDF_MNT_USES_META)) {
		up->u_ump->um_start = up->u_ump->um_realstart;
		up->u_ump->um_len = up->u_ump->um_reallen;
	}

	return (error);
}

/* Are there any implementations out there that do soft-links? */
int
udf_readlink(void *v)
{
	return (EOPNOTSUPP);
}

int
udf_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp;
	struct vnode *vp;
	struct unode *up;
	int maxsize, s, error;

	bp = ap->a_bp;
	vp = bp->b_vp;
	up = VTOU(vp);

	/* cd9660 has this test reversed, but it seems more logical this way */
	if (bp->b_blkno != bp->b_lblkno) {
		/*
		 * Files that are embedded in the fentry don't translate well
		 * to a block number.  Reject.
		 */
		if (udf_bmap_internal(up, bp->b_lblkno * up->u_ump->um_bsize,
		    &bp->b_lblkno, &maxsize)) {
			clrbuf(bp);
			bp->b_blkno = -1;
		}
	} else {
		error = VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL);
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			s = splbio();
			biodone(bp);
			splx(s);
			return (error);
		}

		if ((long)bp->b_blkno == -1)
			clrbuf(bp);
	}

	if ((long)bp->b_blkno == -1) {
		s = splbio();
		biodone(bp);
		splx(s);
	} else {
		bp->b_dev = vp->v_rdev;
		(up->u_devvp->v_op->vop_strategy)(ap);
	}

	return (0);
}

int
udf_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return rrw_enter(&VTOU(vp)->u_lock, ap->a_flags & LK_RWFLAGS);
}

int
udf_unlock(void *v)
{
	struct vop_unlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	rrw_exit(&VTOU(vp)->u_lock);
	return 0;
}

int
udf_islocked(void *v)
{
	struct vop_islocked_args *ap = v;

	return rrw_status(&VTOU(ap->a_vp)->u_lock);
}

int
udf_print(void *v)
{
	struct vop_print_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct unode *up = VTOU(vp);

	/*
	 * Complete the information given by vprint().
	 */
	printf("tag VT_UDF, hash id %u\n", up->u_ino);
#ifdef DIAGNOSTIC
	printf("\n");
#endif
	return (0);
}

int
udf_bmap(void *v)
{
	struct vop_bmap_args *ap = v;
	struct unode *up;
	uint32_t max_size;
	daddr_t lsector;
	int error;

	up = VTOU(ap->a_vp);

	if (ap->a_vpp != NULL)
		*ap->a_vpp = up->u_devvp;
	if (ap->a_bnp == NULL)
		return (0);

	error = udf_bmap_internal(up, ap->a_bn * up->u_ump->um_bsize,
	    &lsector, &max_size);
	if (error)
		return (error);

	/* Translate logical to physical sector number */
	*ap->a_bnp = lsector << (up->u_ump->um_bshift - DEV_BSHIFT);

	/* Punt on read-ahead for now */
	if (ap->a_runp)
		*ap->a_runp = 0;

	return (0);
}

/*
 * The all powerful VOP_LOOKUP().
 */
int
udf_lookup(void *v)
{
	struct vop_lookup_args *ap = v;
	struct vnode *dvp;
	struct vnode *tdp = NULL;
	struct vnode **vpp = ap->a_vpp;
	struct unode *up;
	struct umount *ump;
	struct fileid_desc *fid = NULL;
	struct udf_dirstream *ds;
	struct proc *p;
	u_long nameiop;
	u_long flags;
	char *nameptr;
	long namelen;
	udfino_t id = 0;
	int offset, error = 0;
	int numdirpasses, fsize;

	extern struct nchstats nchstats;

	dvp = ap->a_dvp;
	up = VTOU(dvp);
	ump = up->u_ump;
	nameiop = ap->a_cnp->cn_nameiop;
	flags = ap->a_cnp->cn_flags;
	nameptr = ap->a_cnp->cn_nameptr;
	namelen = ap->a_cnp->cn_namelen;
	fsize = letoh64(up->u_fentry->inf_len);
	p = ap->a_cnp->cn_proc;
	*vpp = NULL;

	/*
	 * Make sure the process can scan the requested directory.
	 */
	error = VOP_ACCESS(dvp, VEXEC, ap->a_cnp->cn_cred, p);
	if (error)
		return (error);

	/*
	 * Check if the (directory, name) tuple has been already cached.
	 */
	error = cache_lookup(dvp, vpp, ap->a_cnp);
	if (error >= 0)
		return (error);
	else
		error = 0;

	/*
	 * If dvp is what's being looked up, then return it.
	 */
	if (ap->a_cnp->cn_namelen == 1 && ap->a_cnp->cn_nameptr[0] == '.') {
		vref(dvp);
		*vpp = dvp;
		return (0);
	}

	/*
	 * If this is a LOOKUP and we've already partially searched through
	 * the directory, pick up where we left off and flag that the
	 * directory may need to be searched twice.  For a full description,
	 * see /sys/isofs/cd9660/cd9660_lookup.c:cd9660_lookup()
	 */
	if (nameiop != LOOKUP || up->u_diroff == 0 || up->u_diroff > fsize) {
		offset = 0;
		numdirpasses = 1;
	} else {
		offset = up->u_diroff;
		numdirpasses = 2;
		nchstats.ncs_2passes++;
	}

	if (ISSET(up->u_ump->um_flags, UDF_MNT_USES_META)) {
		up->u_ump->um_start += up->u_ump->um_meta_start;
		up->u_ump->um_len = up->u_ump->um_meta_len;
	}
lookloop:
	ds = udf_opendir(up, offset, fsize, ump);

	while ((fid = udf_getfid(ds)) != NULL) {
		/* Check for a valid FID tag. */
		if (udf_checktag(&fid->tag, TAGID_FID)) {
			printf("udf_lookup: Invalid tag\n");
			error = EIO;
			break;
		}

		/* Is this a deleted file? */
		if (fid->file_char & UDF_FILE_CHAR_DEL)
			continue;

		if ((fid->l_fi == 0) && (fid->file_char & UDF_FILE_CHAR_PAR)) {
			if (flags & ISDOTDOT) {
				id = udf_getid(&fid->icb);
				break;
			}
		} else {
			if (!(udf_cmpname(&fid->data[fid->l_iu],
			    nameptr, fid->l_fi, namelen, ump))) {
				id = udf_getid(&fid->icb);
				break;
			}
		}
	}

	if (!error)
		error = ds->error;

	if (error) {
		udf_closedir(ds);
		if (ISSET(up->u_ump->um_flags, UDF_MNT_USES_META)) {
			up->u_ump->um_start = up->u_ump->um_realstart;
			up->u_ump->um_len = up->u_ump->um_reallen;
		}
		return (error);
	}

	/* Did we have a match? */
	if (id) {
		error = udf_vget(ump->um_mountp, id, &tdp);
		if (!error) {
			/*
			 * Remember where this entry was if it's the final
			 * component.
			 */
			if ((flags & ISLASTCN) && nameiop == LOOKUP)
				up->u_diroff = ds->offset + ds->off;
			if (numdirpasses == 2)
				nchstats.ncs_pass2++;
			if (!(flags & LOCKPARENT) || !(flags & ISLASTCN)) {
				ap->a_cnp->cn_flags |= PDIRUNLOCK;
				VOP_UNLOCK(dvp, p);
			}

			*vpp = tdp;
		}
	} else {
		/* Name wasn't found on this pass.  Do another pass? */
		if (numdirpasses == 2) {
			numdirpasses--;
			offset = 0;
			udf_closedir(ds);
			goto lookloop;
		}

		if ((flags & ISLASTCN) &&
		    (nameiop == CREATE || nameiop == RENAME)) {
			error = EROFS;
		} else {
			error = ENOENT;
		}
	}

	/*
	 * Cache the result of this lookup.
	 */
	if (flags & MAKEENTRY)
		cache_enter(dvp, *vpp, ap->a_cnp);

	udf_closedir(ds);
	if (ISSET(up->u_ump->um_flags, UDF_MNT_USES_META)) {
		up->u_ump->um_start = up->u_ump->um_realstart;
		up->u_ump->um_len = up->u_ump->um_reallen;
	}

	return (error);
}

int
udf_inactive(void *v)
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct proc *p = ap->a_p;

	/*
	 * No need to sync anything, so just unlock the vnode and return.
	 */
	VOP_UNLOCK(vp, p);

	return (0);
}

int
udf_reclaim(void *v)
{
	struct vop_reclaim_args *ap = v;
	struct vnode *vp;
	struct unode *up;

	vp = ap->a_vp;
	up = VTOU(vp);

	if (up != NULL) {
		udf_hashrem(up);
		if (up->u_devvp) {
			vrele(up->u_devvp);
			up->u_devvp = 0;
		}

		if (up->u_fentry != NULL)
			free(up->u_fentry, M_UDFFENTRY, 0);

		pool_put(&unode_pool, up);
		vp->v_data = NULL;
	}
	
	return (0);
}

/*
 * Read the block and then set the data pointer to correspond with the
 * offset passed in.  Only read in at most 'size' bytes, and then set 'size'
 * to the number of bytes pointed to.  If 'size' is zero, try to read in a
 * whole extent.
 *
 * Note that *bp may be assigned error or not.
 *
 */
int
udf_readatoffset(struct unode *up, int *size, off_t offset,
    struct buf **bp, uint8_t **data)
{
	struct umount *ump;
	struct extfile_entry *xfentry = NULL;
	struct file_entry *fentry = NULL;
	struct buf *bp1;
	uint32_t max_size;
	daddr_t sector;
	int error;

	ump = up->u_ump;

	*bp = NULL;
	error = udf_bmap_internal(up, offset, &sector, &max_size);
	if (error == UDF_INVALID_BMAP) {
		/*
		 * This error means that the file *data* is stored in the
		 * allocation descriptor field of the file entry.
		 */
		if (udf_checktag(&up->u_fentry->tag, TAGID_EXTFENTRY) == 0) {
			xfentry = up->u_fentry;
			*data = &xfentry->data[letoh32(xfentry->l_ea)];
			*size = letoh32(xfentry->l_ad);
		} else {
			fentry = (struct file_entry *)up->u_fentry;
			*data = &fentry->data[letoh32(fentry->l_ea)];
			*size = letoh32(fentry->l_ad);
		}
		return (0);
	} else if (error != 0) {
		return (error);
	}

	/* Adjust the size so that it is within range */
	if (*size == 0 || *size > max_size)
		*size = max_size;
	*size = min(*size, MAXBSIZE);

	if ((error = udf_readlblks(ump, sector, *size, bp))) {
		printf("warning: udf_readlblks returned error %d\n", error);
		/* note: *bp may be non-NULL */
		return (error);
	}

	bp1 = *bp;
	*data = (uint8_t *)&bp1->b_data[offset % ump->um_bsize];
	return (0);
}

/*
 * Translate a file offset into a logical block and then into a physical
 * block.
 */
int
udf_bmap_internal(struct unode *up, off_t offset, daddr_t *sector,
    uint32_t *max_size)
{
	struct umount *ump;
	struct extfile_entry *xfentry;
	struct file_entry *fentry;
	void *icb;
	struct icb_tag *tag;
	uint32_t icblen = 0;
	daddr_t lsector;
	int ad_offset, ad_num = 0;
	int i, p_offset, l_ea, l_ad;

	ump = up->u_ump;
	xfentry = up->u_fentry;
	fentry = (struct file_entry *)up->u_fentry;
	tag = &fentry->icbtag;
	if (udf_checktag(&xfentry->tag, TAGID_EXTFENTRY) == 0) {
		l_ea = letoh32(xfentry->l_ea);
		l_ad = letoh32(xfentry->l_ad);
	} else {
		l_ea = letoh32(fentry->l_ea);
		l_ad = letoh32(fentry->l_ad);
	}

	switch (letoh16(tag->strat_type)) {
	case 4:
		break;

	case 4096:
		printf("Cannot deal with strategy4096 yet!\n");
		return (ENODEV);

	default:
		printf("Unknown strategy type %d\n", tag->strat_type);
		return (ENODEV);
	}

	switch (letoh16(tag->flags) & 0x7) {
	case 0:
		/*
		 * The allocation descriptor field is filled with short_ad's.
		 * If the offset is beyond the current extent, look for the
		 * next extent.
		 */
		do {
			offset -= icblen;
			ad_offset = sizeof(struct short_ad) * ad_num;
			if (ad_offset > l_ad) {
				printf("SFile offset out of bounds (%d > %d)\n",
				    ad_offset, l_ad);
				return (EINVAL);
			}
			
			if (udf_checktag(&up->u_fentry->tag, TAGID_EXTFENTRY) == 0)
				icb = GETICB(short_ad, xfentry, l_ea + ad_offset);
			else
				icb = GETICB(short_ad, fentry, l_ea + ad_offset);

			icblen = GETICBLEN(short_ad, icb);
			ad_num++;
		} while(offset >= icblen);

		lsector = (offset  >> ump->um_bshift) +
		    letoh32(((struct short_ad *)(icb))->lb_num);

		*max_size = GETICBLEN(short_ad, icb);

		break;
	case 1:
		/*
		 * The allocation descriptor field is filled with long_ad's
		 * If the offset is beyond the current extent, look for the
		 * next extent.
		 */
		do {
			offset -= icblen;
			ad_offset = sizeof(struct long_ad) * ad_num;
			if (ad_offset > l_ad) {
				printf("LFile offset out of bounds (%d > %d)\n",
				    ad_offset, l_ad);
				return (EINVAL);
			}
			if (udf_checktag(&up->u_fentry->tag, TAGID_EXTFENTRY) == 0)
				icb = GETICB(long_ad, xfentry, l_ea + ad_offset);
			else
				icb = GETICB(long_ad, fentry, l_ea + ad_offset);
			icblen = GETICBLEN(long_ad, icb);
			ad_num++;
		} while(offset >= icblen);

		lsector = (offset >> ump->um_bshift) +
		    letoh32(((struct long_ad *)(icb))->loc.lb_num);

		*max_size = GETICBLEN(long_ad, icb);

		break;
	case 3:
		/*
		 * This type means that the file *data* is stored in the
		 * allocation descriptor field of the file entry.
		 */
		*max_size = 0;
		*sector = up->u_ino + ump->um_start;

		return (UDF_INVALID_BMAP);
	case 2:
		/* DirectCD does not use extended_ad's */
	default:
		printf("Unsupported allocation descriptor %d\n",
		       tag->flags & 0x7);
		return (ENODEV);
	}

	*sector = lsector + ump->um_start;

	/*
	 * Check the sparing table.  Each entry represents the beginning of
	 * a packet.
	 */
	if (ump->um_stbl != NULL) {
		for (i = 0; i< ump->um_stbl_len; i++) {
			p_offset =
			    lsector - letoh32(ump->um_stbl->entries[i].org);
			if ((p_offset < ump->um_psecs) && (p_offset >= 0)) {
				*sector =
				   letoh32(ump->um_stbl->entries[i].map) +
				    p_offset;
				break;
			}
		}
	}

	return (0);
}
@


1.63
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.62 2016/02/02 16:44:44 stefan Exp $	*/
a900 1

d903 1
a903 1
	return (lockmgr(&VTOU(vp)->u_lock, ap->a_flags, NULL));
a909 1

d912 2
a913 1
	return (lockmgr(&VTOU(vp)->u_lock, LK_RELEASE, NULL));
d921 1
a921 1
	return (lockstatus(&VTOU(ap->a_vp)->u_lock));
@


1.62
log
@Convert to uiomove(). From Martin Natano.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.61 2015/09/23 15:37:26 tedu Exp $	*/
d914 1
a914 1
	return (lockmgr(&VTOU(vp)->u_lock, ap->a_flags | LK_RELEASE, NULL));
d1108 1
a1108 1
				VOP_UNLOCK(dvp, 0, p);
d1155 1
a1155 1
	VOP_UNLOCK(vp, 0, p);
@


1.61
log
@remove lockmgr_printinfo stubs. from Martin Natano
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.60 2015/03/14 03:38:50 jsg Exp $	*/
d448 2
a449 3
		if (uio->uio_resid + offset <= fsize)
			size = uio->uio_resid;
		else
d453 1
a453 1
			error = uiomovei(data, size, uio);
d545 1
a545 1
	int de_size = DIRENT_SIZE(uiodir->dirent);
d554 1
a554 1
	return (uiomovei(uiodir->dirent, de_size, uio));
@


1.60
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.59 2015/02/10 21:56:09 miod Exp $	*/
a937 1
	lockmgr_printinfo(&up->u_lock);
@


1.59
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.58 2014/12/16 18:30:03 tedu Exp $	*/
a37 1
#include <sys/kernel.h>
@


1.58
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.57 2014/11/18 10:42:15 dlg Exp $	*/
d455 1
a455 1
			error = uiomove(data, size, uio);
d556 1
a556 1
	return (uiomove(uiodir->dirent, de_size, uio));
@


1.57
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.56 2014/11/03 21:28:35 tedu Exp $	*/
d47 1
@


1.56
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.55 2014/07/12 18:50:00 tedu Exp $	*/
d53 2
d97 2
a98 1
	lh = &ump->um_hashtbl[id & ump->um_hashsz];
d133 2
a134 1
	lh = &ump->um_hashtbl[up->u_ino & ump->um_hashsz];
d152 2
a153 1
	lh = &ump->um_hashtbl[up->u_ino & ump->um_hashsz];
@


1.55
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.54 2013/12/14 02:57:25 guenther Exp $	*/
a48 1
#include <sys/unistd.h>
d51 1
@


1.54
log
@Zero out dirent structures that will be copied out to avoid leaking garbage
in the padding or trailing name bytes.

ok beck@@ millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.53 2013/09/22 15:42:53 guenther Exp $	*/
d601 1
a601 1
		free(ds->buf, M_UDFFID);
d702 1
a702 1
		free(ds->buf, M_UDFFID);
d1175 1
a1175 1
			free(up->u_fentry, M_UDFFENTRY);
@


1.53
log
@On return, uio_offset needs to be set to the offset of the first entry
not returned instead of the offset after that one.
udf_uiodir() returns -1 when there isn't enough space for the next entry,
so just break from the loop and return 0 in that case.
Remove the bogus printf there now that this is handled correctly.

problem reported by espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.52 2013/08/30 05:35:47 guenther Exp $	*/
d732 1
@


1.52
log
@Fix handling of getdents() against UDF filesystems: d_off must be the
position after the entry, and seeking to just after the '.' or '..'
entries requires special handling because they're fabricated.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.51 2013/08/13 05:52:22 guenther Exp $	*/
d722 1
d757 1
d807 6
a812 1
			printf("uiomove returned %d\n", error);
d815 1
a815 1

d820 1
a820 1
	uio->uio_offset = ds->offset + ds->off;
@


1.51
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.50 2013/06/11 16:42:16 deraadt Exp $	*/
a681 1
	ds->this_off = ds->off;
d687 1
d707 3
d722 1
d733 13
d774 22
a795 16
			dir.d_fileno = up->u_ino;
			dir.d_type = DT_DIR;
			dir.d_name[0] = '.';
			dir.d_name[1] = '\0';
			dir.d_namlen = 1;
			error = udf_uiodir(&uiodir, uio, 1);
			if (error)
				break;

			dir.d_fileno = udf_getid(&fid->icb);
			dir.d_type = DT_DIR;
			dir.d_name[0] = '.';
			dir.d_name[1] = '.';
			dir.d_name[2] = '\0';
			dir.d_namlen = 2;
			error = udf_uiodir(&uiodir, uio, 2);
@


1.50
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.49 2013/06/02 15:38:26 guenther Exp $	*/
a534 3
	u_long *cookies;
	int ncookies;
	int acookies;
d539 1
a539 1
udf_uiodir(struct udf_uiodir *uiodir, int de_size, struct uio *uio, long cookie)
d541 1
a541 7
	if (uiodir->cookies != NULL) {
		if (++uiodir->acookies > uiodir->ncookies) {
			uiodir->eofflag = 0;
			return (-1);
		}
		*uiodir->cookies++ = cookie;
	}
d547 2
a718 2
	u_long *cookies = NULL;
	int ncookies;
a720 3
#define GENERIC_DIRSIZ(dp) \
    ((sizeof (struct dirent) - (MAXNAMLEN+1)) + (((dp)->d_namlen+1 + 3) &~ 3))

d726 1
a726 15

	if (ap->a_ncookies != NULL) {
		/*
		 * Guess how many entries are needed.  If we run out, this
		 * function will be called again and thing will pick up were
		 * it left off.
		 */
		ncookies = uio->uio_resid / 8;
		cookies = malloc(sizeof(u_long) * ncookies, M_TEMP, M_WAITOK);
		uiodir.ncookies = ncookies;
		uiodir.cookies = cookies;
		uiodir.acookies = 0;
	} else {
		uiodir.cookies = NULL;
	}
d754 1
a754 1
			 * used for the cookies since the offset here is
d762 1
a762 3
			dir.d_reclen = GENERIC_DIRSIZ(&dir);
			uiodir.dirent = &dir;
			error = udf_uiodir(&uiodir, dir.d_reclen, uio, 1);
d772 1
a772 3
			dir.d_reclen = GENERIC_DIRSIZ(&dir);
			uiodir.dirent = &dir;
			error = udf_uiodir(&uiodir, dir.d_reclen, uio, 2);
d779 1
a779 4
			dir.d_reclen = GENERIC_DIRSIZ(&dir);
			uiodir.dirent = &dir;
			error = udf_uiodir(&uiodir, dir.d_reclen, uio,
			    ds->this_off);
a787 2
#undef GENERIC_DIRSIZ

a798 9
	}

	if (ap->a_ncookies != NULL) {
		if (error)
			free(cookies, M_TEMP);
		else {
			*ap->a_ncookies = uiodir.acookies;
			*ap->a_cookies = cookies;
		}
@


1.49
log
@Actually use the subsecond timestamp data

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.48 2013/06/02 15:35:18 deraadt Exp $	*/
d57 1
a57 1
int udf_bmap_internal(struct unode *, off_t, daddr64_t *, uint32_t *);
d958 1
a958 1
	daddr64_t lsector;
d1215 1
a1215 1
	daddr64_t sector;
d1262 1
a1262 1
udf_bmap_internal(struct unode *up, off_t offset, daddr64_t *sector,
d1271 1
a1271 1
	daddr64_t lsector;
@


1.48
log
@repair and activate pathconf support
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.47 2013/05/30 17:35:01 guenther Exp $	*/
a254 2
	t->tv_nsec = 0;

d259 1
d264 2
@


1.47
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.46 2013/03/28 02:08:39 guenther Exp $	*/
d75 1
d392 2
a393 3
#if 0
static int
udf_pathconf(struct vop_pathconf_args *a)
d395 1
d405 3
d411 3
a420 1
#endif
@


1.46
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.45 2012/06/20 17:30:22 matthew Exp $	*/
d81 1
a81 1
/* Look up a unode based on the ino_t passed in and return its vnode */
d83 1
a83 1
udf_hashlookup(struct umount *ump, ino_t id, int flags, struct vnode **vpp)
d995 1
a995 1
	ino_t id = 0;
@


1.45
log
@Cleanup our filesystem pathconf() code a little bit to make it easier
to diff against FreeBSD's.

From Brad; no object file change on amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.44 2011/07/04 20:35:35 deraadt Exp $	*/
a402 3
		break;
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
@


1.44
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.43 2011/04/05 14:14:07 thib Exp $	*/
d395 1
d400 1
a400 1
		return (0);
d403 1
a403 1
		return (0);
d406 1
a406 1
		return (0);
d409 1
a409 1
		return (0);
d411 2
a412 1
		return (EINVAL);
d414 2
@


1.43
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.42 2010/12/21 20:14:43 thib Exp $	*/
d51 1
a51 2

#include <miscfs/specfs/specdev.h>
@


1.42
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.41 2010/09/10 16:34:08 thib Exp $	*/
a60 1
	.vop_default	= eopnotsupp,
@


1.41
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.40 2010/09/06 23:44:10 thib Exp $	*/
d60 19
a78 21
int (**udf_vnodeop_p)(void *);
struct vnodeopv_entry_desc udf_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_access_desc, udf_access },
	{ &vop_bmap_desc, udf_bmap },
	{ &vop_lookup_desc, udf_lookup },
	{ &vop_getattr_desc, udf_getattr },
	{ &vop_open_desc, udf_open },
	{ &vop_close_desc, udf_close },
	{ &vop_ioctl_desc, udf_ioctl },
	{ &vop_read_desc, udf_read },
	{ &vop_readdir_desc, udf_readdir },
	{ &vop_readlink_desc, udf_readlink },
	{ &vop_inactive_desc, udf_inactive },
	{ &vop_reclaim_desc, udf_reclaim },
	{ &vop_strategy_desc, udf_strategy },
	{ &vop_lock_desc, udf_lock },
	{ &vop_unlock_desc, udf_unlock },
	{ &vop_islocked_desc, udf_islocked },
	{ &vop_print_desc, udf_print },
	{ NULL, NULL }
a79 2
struct vnodeopv_desc udf_vnodeop_opv_desc =
	{ &udf_vnodeop_p, udf_vnodeop_entries };
d164 1
a164 1
	error = getnewvnode(VT_UDF, mp, udf_vnodeop_p, &vp);
d894 1
a894 1
		VOCALL(up->u_devvp->v_op, VOFFSET(vop_strategy), ap);
@


1.40
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.39 2009/08/27 23:14:47 jolan Exp $	*/
d60 21
a80 19
struct vops udf_vops = {
	.vop_default	= eopnotsupp,
	.vop_access	= udf_access,
	.vop_bmap	= udf_bmap,
	.vop_lookup	= udf_lookup,
	.vop_getattr	= udf_getattr,
	.vop_open	= udf_open,
	.vop_close	= udf_close,
	.vop_ioctl	= udf_ioctl,
	.vop_read	= udf_read,
	.vop_readdir	= udf_readdir,
	.vop_readlink	= udf_readlink,
	.vop_inactive	= udf_inactive,
	.vop_reclaim	= udf_reclaim,
	.vop_strategy	= udf_strategy,
	.vop_lock	= udf_lock,
	.vop_unlock	= udf_unlock,
	.vop_islocked	= udf_islocked,
	.vop_print	= udf_print
d82 2
d168 1
a168 1
	error = getnewvnode(VT_UDF, mp, &udf_vops, &vp);
d898 1
a898 1
		(up->u_devvp->v_op->vop_strategy)(ap);
@


1.39
log
@make UDF less chatty during normal operation

ok krw/phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.38 2009/08/14 22:23:45 krw Exp $	*/
d60 19
a78 21
int (**udf_vnodeop_p)(void *);
struct vnodeopv_entry_desc udf_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_access_desc, udf_access },
	{ &vop_bmap_desc, udf_bmap },
	{ &vop_lookup_desc, udf_lookup },
	{ &vop_getattr_desc, udf_getattr },
	{ &vop_open_desc, udf_open },
	{ &vop_close_desc, udf_close },
	{ &vop_ioctl_desc, udf_ioctl },
	{ &vop_read_desc, udf_read },
	{ &vop_readdir_desc, udf_readdir },
	{ &vop_readlink_desc, udf_readlink },
	{ &vop_inactive_desc, udf_inactive },
	{ &vop_reclaim_desc, udf_reclaim },
	{ &vop_strategy_desc, udf_strategy },
	{ &vop_lock_desc, udf_lock },
	{ &vop_unlock_desc, udf_unlock },
	{ &vop_islocked_desc, udf_islocked },
	{ &vop_print_desc, udf_print },
	{ NULL, NULL }
a79 2
struct vnodeopv_desc udf_vnodeop_opv_desc =
	{ &udf_vnodeop_p, udf_vnodeop_entries };
d164 1
a164 1
	error = getnewvnode(VT_UDF, mp, udf_vnodeop_p, &vp);
d894 1
a894 1
		VOCALL(up->u_devvp->v_op, VOFFSET(vop_strategy), ap);
@


1.38
log
@First cut at UDF 2.[56] support, allowing read-only access to HDDVD
and Blu-ray disks. Previously working DVDs should still work.

Done at f2k9 with phessler@@. Vnode bug squashing by beck@@. Thanks
to Bryan Brake for sending HDDVD/Blu-ray hardware and disks to f2k9
in Stockholm.

ok beck@@ dlg@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.37 2009/08/13 15:00:14 jasper Exp $	*/
a1075 1
printf("name: '%s', file_char: %u\n", nameptr, fid->file_char);
@


1.37
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.36 2009/07/09 22:29:56 thib Exp $	*/
d313 1
d322 3
a324 1
	fentry = up->u_fentry;
a335 3
	udf_timetotimespec(&fentry->atime, &vap->va_atime);
	udf_timetotimespec(&fentry->mtime, &vap->va_mtime);
	vap->va_ctime = vap->va_mtime; /* Stored as an Extended Attribute */
d345 7
a351 1
		if (fentry->logblks_rec != 0) {
d353 1
a353 4
			    letoh64(fentry->logblks_rec) * up->u_ump->um_bsize;
		} else {
			vap->va_size = up->u_ump->um_bsize;
		}
d355 5
a359 1
		vap->va_size = letoh64(fentry->inf_len);
d361 1
d448 1
a448 1
		if (bp != NULL)
d450 2
d592 1
a592 1
			if (ds->bp != NULL)
d594 2
d637 1
a637 1
		if (ds->bp != NULL)
d639 2
d649 4
d701 1
a701 1
	if (ds->bp != NULL)
d703 2
d756 4
d767 1
a767 1
			printf("Invalid FID tag\n");
d829 4
d1057 4
d1076 1
d1096 4
d1146 4
d1210 1
d1226 9
a1234 3
		fentry = up->u_fentry;
		*data = &fentry->data[letoh32(fentry->l_ea)];
		*size = letoh32(fentry->l_ad);
d1265 1
d1272 1
a1272 1
	int i, p_offset;
d1275 2
a1276 1
	fentry = up->u_fentry;
d1278 7
d1309 3
a1311 2
			if (ad_offset > letoh32(fentry->l_ad)) {
				printf("File offset out of bounds\n");
d1314 6
a1319 2
			icb = GETICB(short_ad, fentry,
			    letoh32(fentry->l_ea) + ad_offset);
d1339 3
a1341 2
			if (ad_offset > letoh32(fentry->l_ad)) {
				printf("File offset out of bounds\n");
d1344 4
a1347 2
			icb = GETICB(long_ad, fentry,
			    letoh32(fentry->l_ea) + ad_offset);
@


1.36
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.34 2008/11/08 01:27:51 chl Exp $	*/
d63 17
a79 17
	{ &vop_access_desc, udf_access },		/* access */
	{ &vop_bmap_desc, udf_bmap },			/* bmap */
	{ &vop_lookup_desc, udf_lookup },		/* lookup */
	{ &vop_getattr_desc, udf_getattr },		/* getattr */
	{ &vop_open_desc, udf_open },			/* open */
	{ &vop_close_desc, udf_close },			/* close */
	{ &vop_ioctl_desc, udf_ioctl },			/* ioctl */
	{ &vop_read_desc, udf_read },			/* read */
	{ &vop_readdir_desc, udf_readdir },		/* readdir */
	{ &vop_readlink_desc, udf_readlink },		/* readlink */
	{ &vop_inactive_desc, udf_inactive },		/* inactive */
	{ &vop_reclaim_desc, udf_reclaim },		/* reclaim */
	{ &vop_strategy_desc, udf_strategy },		/* strategy */
	{ &vop_lock_desc, udf_lock },			/* lock */
	{ &vop_unlock_desc, udf_unlock },		/* unlock */
	{ &vop_islocked_desc, udf_islocked },		/* islocked */
	{ &vop_print_desc, udf_print },			/* print */
@


1.35
log
@Update to Reinoud Zandijk's much more current version of ecma167-udf.h
and make textual tweaks to .c files to keep them compiling. From
NetBSD.

No changes to .o's at this point.
@
text
@d1009 1
a1009 1
		VREF(dvp);
@


1.34
log
@fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok krw@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.33 2008/06/14 10:55:21 mk Exp $	*/
d1263 1
a1263 1
		    letoh32(((struct short_ad *)(icb))->pos);
@


1.33
log
@A bunch of pool_get() + bzero() -> pool_get(..., .. | PR_ZERO)
conversions that should shave a few bytes off the kernel.

ok henning, krw, jsing, oga, miod, and thib (``even though i usually prefer
FOO|BAR''; thanks for looking.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.32 2008/06/09 23:38:37 millert Exp $	*/
d137 1
a137 1
		LIST_INIT(lh);
@


1.32
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.31 2008/05/08 17:45:45 thib Exp $	*/
d553 1
a553 2
	ds = pool_get(&udf_ds_pool, PR_WAITOK);
	bzero(ds, sizeof(struct udf_dirstream));
@


1.31
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.30 2007/12/09 20:54:01 jmc Exp $	*/
d225 2
a226 2
	return (vaccess(mode, up->u_fentry->uid, up->u_fentry->gid, a_mode,
	    ap->a_cred));
@


1.30
log
@update pedro's email address, at his request;
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.29 2007/10/29 13:02:20 chl Exp $	*/
d62 1
a62 1
	{ &vop_default_desc, vn_default_error },
@


1.29
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.28 2007/09/17 01:33:33 krw Exp $	*/
d32 1
a32 1
 * Ported to OpenBSD by Pedro Martelletto <pedro@@openbsd.org> in February 2005.
@


1.28
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.27 2007/06/06 17:15:13 deraadt Exp $	*/
d725 1
a725 2
		MALLOC(cookies, u_long *, sizeof(u_long) * ncookies,
		    M_TEMP, M_WAITOK);
d809 1
a809 1
			FREE(cookies, M_TEMP);
@


1.27
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.26 2007/06/01 23:47:56 deraadt Exp $	*/
d620 1
a620 2
		ds->buf = malloc(ds->ump->um_bsize, M_UDFFID, M_WAITOK);
		bzero(ds->buf, ds->ump->um_bsize);
@


1.26
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.25 2007/05/09 02:46:12 deraadt Exp $	*/
d1224 1
a1224 1
	daddr_t lsector;
@


1.25
log
@lockmgr_printinfo() calls only if DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.24 2007/04/10 17:47:55 miod Exp $	*/
d202 1
a202 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d309 1
a309 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *v_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d416 1
a416 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d697 1
a697 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long **a_cookies;
		int *ncookies;
	} */ *ap = v;
d831 1
a831 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d882 1
a882 5
	struct vop_lock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap = v;
d892 1
a892 5
	struct vop_unlock_args /* {
		struct vnode *a_vp;
		int a_flags;
		struct proc *a_p;
	} */ *ap= v;
d902 1
a902 3
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d910 1
a910 3
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d928 1
a928 7
	struct vop_bmap_args /* {
		struct vnode *a_vp;
		daddr_t a_bn;
		struct vnode **a_vpp;
		daddr_t *a_bnp;
		int *a_runp;
	} */ *ap = v;
d962 1
a962 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
d1119 1
a1119 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
d1134 1
a1134 4
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
@


1.24
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.23 2007/03/25 18:38:20 thib Exp $	*/
d954 1
d957 1
a957 1

@


1.23
log
@Remove LK_INTERLOCK from flags in a call to vget();

ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.22 2007/03/21 17:29:31 thib Exp $	*/
d87 1
a87 1
/* Look up a unode based on the ino_t passed in and return it's vnode */
@


1.22
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.21 2006/10/16 11:27:53 pedro Exp $	*/
d109 1
a109 1
			error = vget(up->u_vnode, flags | LK_INTERLOCK, p);
@


1.21
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.20 2006/07/09 04:23:09 pedro Exp $	*/
d914 1
a914 1
	return (lockmgr(&VTOU(vp)->u_lock, ap->a_flags, &vp->v_interlock));
d928 1
a928 2
	return (lockmgr(&VTOU(vp)->u_lock, ap->a_flags | LK_RELEASE,
	    &vp->v_interlock));
@


1.20
log
@Be consistent about how we name 'struct umount' instances
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.19 2006/07/09 04:14:25 pedro Exp $	*/
d58 1
a58 1
int udf_bmap_internal(struct unode *, off_t, daddr_t *, uint32_t *);
d973 1
a973 1
	daddr_t lsector;
d1227 1
a1227 1
	daddr_t sector;
d1268 1
a1268 1
udf_bmap_internal(struct unode *up, off_t offset, daddr_t *sector,
@


1.19
log
@udf_mnt -> umount and rename fields accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.18 2006/07/08 23:29:20 pedro Exp $	*/
d89 1
a89 1
udf_hashlookup(struct umount *udfmp, ino_t id, int flags, struct vnode **vpp)
d99 2
a100 2
	mtx_enter(&udfmp->um_hashmtx);
	lh = &udfmp->um_hashtbl[id & udfmp->um_hashsz];
d102 1
a102 1
		mtx_leave(&udfmp->um_hashmtx);
d108 1
a108 1
			mtx_leave(&udfmp->um_hashmtx);
d119 1
a119 1
	mtx_leave(&udfmp->um_hashmtx);
d127 1
a127 1
	struct umount *udfmp;
d131 1
a131 1
	udfmp = up->u_ump;
d134 2
a135 2
	mtx_enter(&udfmp->um_hashmtx);
	lh = &udfmp->um_hashtbl[up->u_ino & udfmp->um_hashsz];
d139 1
a139 1
	mtx_leave(&udfmp->um_hashmtx);
d147 1
a147 1
	struct umount *udfmp;
d150 1
a150 1
	udfmp = up->u_ump;
d152 2
a153 2
	mtx_enter(&udfmp->um_hashmtx);
	lh = &udfmp->um_hashtbl[up->u_ino & udfmp->um_hashsz];
d157 1
a157 1
	mtx_leave(&udfmp->um_hashmtx);
d470 1
a470 1
udf_transname(char *cs0string, char *destname, int len, struct umount *udfmp)
d515 1
a515 1
udf_cmpname(char *cs0string, char *cmpname, int cs0len, int cmplen, struct umount *udfmp)
d523 1
a523 1
	cs0len = udf_transname(cs0string, transname, cs0len, udfmp);
d564 1
a564 1
udf_opendir(struct unode *up, int offset, int fsize, struct umount *udfmp)
d573 1
a573 1
	ds->udfmp = udfmp;
d625 1
a625 1
		if (frag_size >= ds->udfmp->um_bsize) {
d635 2
a636 2
		ds->buf = malloc(ds->udfmp->um_bsize, M_UDFFID, M_WAITOK);
		bzero(ds->buf, ds->udfmp->um_bsize);
d669 1
a669 1
		if (total_fid_size > ds->udfmp->um_bsize) {
d724 1
a724 1
	struct umount *udfmp;
d738 1
a738 1
	udfmp = up->u_ump;
d804 1
a804 1
			    &dir.d_name[0], fid->l_fi, udfmp);
d1013 1
a1013 1
	struct umount *udfmp;
d1029 1
a1029 1
	udfmp = up->u_ump;
d1079 1
a1079 1
	ds = udf_opendir(up, offset, fsize, udfmp);
d1100 1
a1100 1
			    nameptr, fid->l_fi, namelen, udfmp))) {
d1117 1
a1117 1
		error = udf_vget(udfmp->um_mountp, id, &tdp);
d1223 1
a1223 1
	struct umount *udfmp;
d1230 1
a1230 1
	udfmp = up->u_ump;
d1252 1
a1252 1
	if ((error = udf_readlblks(udfmp, sector, *size, bp))) {
d1259 1
a1259 1
	*data = (uint8_t *)&bp1->b_data[offset % udfmp->um_bsize];
d1271 1
a1271 1
	struct umount *udfmp;
d1280 1
a1280 1
	udfmp = up->u_ump;
d1317 1
a1317 1
		lsector = (offset  >> udfmp->um_bshift) +
d1342 1
a1342 1
		lsector = (offset >> udfmp->um_bshift) +
d1354 1
a1354 1
		*sector = up->u_ino + udfmp->um_start;
d1365 1
a1365 1
	*sector = lsector + udfmp->um_start;
d1371 2
a1372 2
	if (udfmp->um_stbl != NULL) {
		for (i = 0; i< udfmp->um_stbl_len; i++) {
d1374 2
a1375 2
			    lsector - letoh32(udfmp->um_stbl->entries[i].org);
			if ((p_offset < udfmp->um_psecs) && (p_offset >= 0)) {
d1377 1
a1377 1
				   letoh32(udfmp->um_stbl->entries[i].map) +
@


1.18
log
@Be consistent about how we name 'struct unode' instances
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.17 2006/07/08 23:11:59 pedro Exp $	*/
d89 1
a89 1
udf_hashlookup(struct udf_mnt *udfmp, ino_t id, int flags, struct vnode **vpp)
d99 2
a100 2
	mtx_enter(&udfmp->hash_mtx);
	lh = &udfmp->hashtbl[id & udfmp->hashsz];
d102 1
a102 1
		mtx_leave(&udfmp->hash_mtx);
d108 1
a108 1
			mtx_leave(&udfmp->hash_mtx);
d119 1
a119 1
	mtx_leave(&udfmp->hash_mtx);
d127 1
a127 1
	struct udf_mnt *udfmp;
d134 2
a135 2
	mtx_enter(&udfmp->hash_mtx);
	lh = &udfmp->hashtbl[up->u_ino & udfmp->hashsz];
d139 1
a139 1
	mtx_leave(&udfmp->hash_mtx);
d147 1
a147 1
	struct udf_mnt *udfmp;
d152 2
a153 2
	mtx_enter(&udfmp->hash_mtx);
	lh = &udfmp->hashtbl[up->u_ino & udfmp->hashsz];
d157 1
a157 1
	mtx_leave(&udfmp->hash_mtx);
d357 1
a357 1
			    letoh64(fentry->logblks_rec) * up->u_ump->bsize;
d359 1
a359 1
			vap->va_size = up->u_ump->bsize;
d366 1
a366 1
	vap->va_blocksize = up->u_ump->bsize;
d470 1
a470 1
udf_transname(char *cs0string, char *destname, int len, struct udf_mnt *udfmp)
d515 1
a515 1
udf_cmpname(char *cs0string, char *cmpname, int cs0len, int cmplen, struct udf_mnt *udfmp)
d564 1
a564 1
udf_opendir(struct unode *up, int offset, int fsize, struct udf_mnt *udfmp)
d625 1
a625 1
		if (frag_size >= ds->udfmp->bsize) {
d635 2
a636 2
		ds->buf = malloc(ds->udfmp->bsize, M_UDFFID, M_WAITOK);
		bzero(ds->buf, ds->udfmp->bsize);
d669 1
a669 1
		if (total_fid_size > ds->udfmp->bsize) {
d724 1
a724 1
	struct udf_mnt *udfmp;
d871 1
a871 1
		if (udf_bmap_internal(up, bp->b_lblkno * up->u_ump->bsize,
d983 1
a983 1
	error = udf_bmap_internal(up, ap->a_bn * up->u_ump->bsize,
d989 1
a989 1
	*ap->a_bnp = lsector << (up->u_ump->bshift - DEV_BSHIFT);
d1013 1
a1013 1
	struct udf_mnt *udfmp;
d1117 1
a1117 1
		error = udf_vget(udfmp->im_mountp, id, &tdp);
d1223 1
a1223 1
	struct udf_mnt *udfmp;
d1259 1
a1259 1
	*data = (uint8_t *)&bp1->b_data[offset % udfmp->bsize];
d1271 1
a1271 1
	struct udf_mnt *udfmp;
d1317 1
a1317 1
		lsector = (offset  >> udfmp->bshift) +
d1342 1
a1342 1
		lsector = (offset >> udfmp->bshift) +
d1354 1
a1354 1
		*sector = up->u_ino + udfmp->part_start;
d1365 1
a1365 1
	*sector = lsector + udfmp->part_start;
d1371 2
a1372 2
	if (udfmp->s_table != NULL) {
		for (i = 0; i< udfmp->s_table_entries; i++) {
d1374 2
a1375 2
			    lsector - letoh32(udfmp->s_table->entries[i].org);
			if ((p_offset < udfmp->p_sectors) && (p_offset >= 0)) {
d1377 1
a1377 1
				   letoh32(udfmp->s_table->entries[i].map) +
@


1.17
log
@udf_node -> unode and rename fields accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.16 2006/07/08 20:53:31 pedro Exp $	*/
d91 1
a91 1
	struct unode *node;
d106 2
a107 2
	LIST_FOREACH(node, lh, u_le) {
		if (node->u_ino == id) {
d109 1
a109 1
			error = vget(node->u_vnode, flags | LK_INTERLOCK, p);
d114 1
a114 1
			*vpp = node->u_vnode;
d125 1
a125 1
udf_hashins(struct unode *node)
d131 1
a131 1
	udfmp = node->u_ump;
d133 1
a133 1
	vn_lock(node->u_vnode, LK_EXCLUSIVE | LK_RETRY, p);
d135 1
a135 1
	lh = &udfmp->hashtbl[node->u_ino & udfmp->hashsz];
d138 1
a138 1
	LIST_INSERT_HEAD(lh, node, u_le);
d145 1
a145 1
udf_hashrem(struct unode *node)
d150 1
a150 1
	udfmp = node->u_ump;
d153 1
a153 1
	lh = &udfmp->hashtbl[node->u_ino & udfmp->hashsz];
d155 2
a156 2
		panic("hash entry is NULL, node->u_ino= %d", node->u_ino);
	LIST_REMOVE(node, u_le);
d180 1
a180 1
udf_permtomode(struct unode *node)
d186 2
a187 2
	perm = letoh32(node->u_fentry->perm);
	flags = letoh16(node->u_fentry->icbtag.flags);
d209 1
a209 1
	struct unode *node;
d213 1
a213 1
	node = VTOU(vp);
d228 1
a228 1
	mode = udf_permtomode(node);
d230 1
a230 1
	return (vaccess(mode, node->u_fentry->uid, node->u_fentry->gid, a_mode,
d321 1
a321 1
	struct unode *node;
d330 2
a331 2
	node = VTOU(vp);
	fentry = node->u_fentry;
d333 3
a335 3
	vap->va_fsid = node->u_dev;
	vap->va_fileid = node->u_ino;
	vap->va_mode = udf_permtomode(node);
d357 1
a357 1
			    letoh64(fentry->logblks_rec) * node->u_ump->bsize;
d359 1
a359 1
			vap->va_size = node->u_ump->bsize;
d366 1
a366 1
	vap->va_blocksize = node->u_ump->bsize;
d434 1
a434 1
	struct unode *node = VTOU(vp);
d444 1
a444 1
	fsize = letoh64(node->u_fentry->inf_len);
d452 1
a452 1
		error = udf_readatoffset(node, &size, offset, &bp, &data);
d564 1
a564 1
udf_opendir(struct unode *node, int offset, int fsize, struct udf_mnt *udfmp)
d571 1
a571 1
	ds->node = node;
d723 1
a723 1
	struct unode *node;
d737 2
a738 2
	node = VTOU(vp);
	udfmp = node->u_ump;
d761 2
a762 2
	ds = udf_opendir(node, uio->uio_offset,
	    letoh64(node->u_fentry->inf_len), node->u_ump);
d782 1
a782 1
			dir.d_fileno = node->u_ino;
d858 1
a858 1
	struct unode *node;
d863 1
a863 1
	node = VTOU(vp);
d871 1
a871 1
		if (udf_bmap_internal(node, bp->b_lblkno * node->u_ump->bsize,
d897 1
a897 1
		VOCALL(node->u_devvp->v_op, VOFFSET(vop_strategy), ap);
d949 1
a949 1
	struct unode *node = VTOU(vp);
d954 2
a955 2
	printf("tag VT_UDF, hash id %u\n", node->u_ino);
	lockmgr_printinfo(&node->u_lock);
d971 1
a971 1
	struct unode *node;
d976 1
a976 1
	node = VTOU(ap->a_vp);
d979 1
a979 1
		*ap->a_vpp = node->u_devvp;
d983 1
a983 1
	error = udf_bmap_internal(node, ap->a_bn * node->u_ump->bsize,
d989 1
a989 1
	*ap->a_bnp = lsector << (node->u_ump->bshift - DEV_BSHIFT);
d1012 1
a1012 1
	struct unode *node;
d1028 2
a1029 2
	node = VTOU(dvp);
	udfmp = node->u_ump;
d1034 1
a1034 1
	fsize = letoh64(node->u_fentry->inf_len);
d1069 1
a1069 2
	if (nameiop != LOOKUP || node->u_diroff == 0 ||
	    node->u_diroff > fsize) {
d1073 1
a1073 1
		offset = node->u_diroff;
d1079 1
a1079 1
	ds = udf_opendir(node, offset, fsize, udfmp);
d1124 1
a1124 1
				node->u_diroff = ds->offset + ds->off;
d1188 1
a1188 1
	struct unode *unode;
d1191 1
a1191 1
	unode = VTOU(vp);
d1193 5
a1197 5
	if (unode != NULL) {
		udf_hashrem(unode);
		if (unode->u_devvp) {
			vrele(unode->u_devvp);
			unode->u_devvp = 0;
d1200 2
a1201 2
		if (unode->u_fentry != NULL)
			free(unode->u_fentry, M_UDFFENTRY);
d1203 1
a1203 1
		pool_put(&unode_pool, unode);
d1220 1
a1220 1
udf_readatoffset(struct unode *node, int *size, off_t offset,
d1230 1
a1230 1
	udfmp = node->u_ump;
d1233 1
a1233 1
	error = udf_bmap_internal(node, offset, &sector, &max_size);
d1239 1
a1239 1
		fentry = node->u_fentry;
d1268 1
a1268 1
udf_bmap_internal(struct unode *node, off_t offset, daddr_t *sector,
d1280 2
a1281 2
	udfmp = node->u_ump;
	fentry = node->u_fentry;
d1354 1
a1354 1
		*sector = node->u_ino + udfmp->part_start;
@


1.16
log
@Rename VTON() to VTOU()
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.15 2006/07/05 17:57:50 pedro Exp $	*/
d58 1
a58 1
int udf_bmap_internal(struct udf_node *, off_t, daddr_t *, uint32_t *);
d87 1
a87 1
/* Look up a udf_node based on the ino_t passed in and return it's vnode */
d91 1
a91 1
	struct udf_node *node;
d106 2
a107 2
	LIST_FOREACH(node, lh, le) {
		if (node->hash_id == id) {
d109 1
a109 1
			error = vget(node->i_vnode, flags | LK_INTERLOCK, p);
d114 1
a114 1
			*vpp = node->i_vnode;
d125 1
a125 1
udf_hashins(struct udf_node *node)
d131 1
a131 1
	udfmp = node->udfmp;
d133 1
a133 1
	vn_lock(node->i_vnode, LK_EXCLUSIVE | LK_RETRY, p);
d135 1
a135 1
	lh = &udfmp->hashtbl[node->hash_id & udfmp->hashsz];
d138 1
a138 1
	LIST_INSERT_HEAD(lh, node, le);
d145 1
a145 1
udf_hashrem(struct udf_node *node)
d150 1
a150 1
	udfmp = node->udfmp;
d153 1
a153 1
	lh = &udfmp->hashtbl[node->hash_id & udfmp->hashsz];
d155 2
a156 2
		panic("hash entry is NULL, node->hash_id= %d", node->hash_id);
	LIST_REMOVE(node, le);
d180 1
a180 1
udf_permtomode(struct udf_node *node)
d186 2
a187 2
	perm = letoh32(node->fentry->perm);
	flags = letoh16(node->fentry->icbtag.flags);
d209 1
a209 1
	struct udf_node *node;
d230 1
a230 1
	return (vaccess(mode, node->fentry->uid, node->fentry->gid, a_mode,
d321 1
a321 1
	struct udf_node *node;
d331 1
a331 1
	fentry = node->fentry;
d333 2
a334 2
	vap->va_fsid = node->i_dev;
	vap->va_fileid = node->hash_id;
d357 1
a357 1
			    letoh64(fentry->logblks_rec) * node->udfmp->bsize;
d359 1
a359 1
			vap->va_size = node->udfmp->bsize;
d366 1
a366 1
	vap->va_blocksize = node->udfmp->bsize;
d434 1
a434 1
	struct udf_node *node = VTOU(vp);
d444 1
a444 1
	fsize = letoh64(node->fentry->inf_len);
d564 1
a564 1
udf_opendir(struct udf_node *node, int offset, int fsize, struct udf_mnt *udfmp)
d723 1
a723 1
	struct udf_node *node;
d738 1
a738 1
	udfmp = node->udfmp;
d761 2
a762 2
	ds = udf_opendir(node, uio->uio_offset, letoh64(node->fentry->inf_len),
	    node->udfmp);
d782 1
a782 1
			dir.d_fileno = node->hash_id;
d858 1
a858 1
	struct udf_node *node;
d871 1
a871 1
		if (udf_bmap_internal(node, bp->b_lblkno * node->udfmp->bsize,
d897 1
a897 1
		VOCALL(node->i_devvp->v_op, VOFFSET(vop_strategy), ap);
d914 1
a914 1
	return (lockmgr(&VTOU(vp)->i_lock, ap->a_flags, &vp->v_interlock));
d928 1
a928 1
	return (lockmgr(&VTOU(vp)->i_lock, ap->a_flags | LK_RELEASE,
d939 1
a939 1
	return (lockstatus(&VTOU(ap->a_vp)->i_lock));
d949 1
a949 1
	struct udf_node *node = VTOU(vp);
d954 2
a955 2
	printf("tag VT_UDF, hash id %u\n", node->hash_id);
	lockmgr_printinfo(&node->i_lock);
d971 1
a971 1
	struct udf_node *node;
d979 1
a979 1
		*ap->a_vpp = node->i_devvp;
d983 2
a984 2
	error = udf_bmap_internal(node, ap->a_bn * node->udfmp->bsize, &lsector,
	    &max_size);
d989 1
a989 1
	*ap->a_bnp = lsector << (node->udfmp->bshift - DEV_BSHIFT);
d1012 1
a1012 1
	struct udf_node *node;
d1029 1
a1029 1
	udfmp = node->udfmp;
d1034 1
a1034 1
	fsize = letoh64(node->fentry->inf_len);
d1069 2
a1070 1
	if (nameiop != LOOKUP || node->diroff == 0 || node->diroff > fsize) {
d1074 1
a1074 1
		offset = node->diroff;
d1125 1
a1125 1
				node->diroff = ds->offset + ds->off;
d1189 1
a1189 1
	struct udf_node *unode;
d1196 3
a1198 3
		if (unode->i_devvp) {
			vrele(unode->i_devvp);
			unode->i_devvp = 0;
d1201 2
a1202 2
		if (unode->fentry != NULL)
			free(unode->fentry, M_UDFFENTRY);
d1204 1
a1204 1
		pool_put(&udf_node_pool, unode);
d1221 1
a1221 1
udf_readatoffset(struct udf_node *node, int *size, off_t offset,
d1231 1
a1231 1
	udfmp = node->udfmp;
d1240 1
a1240 1
		fentry = node->fentry;
d1269 1
a1269 1
udf_bmap_internal(struct udf_node *node, off_t offset, daddr_t *sector,
d1281 2
a1282 2
	udfmp = node->udfmp;
	fentry = node->fentry;
d1355 1
a1355 1
		*sector = node->hash_id + udfmp->part_start;
@


1.15
log
@Add VAT support a la UDF 1.50
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.14 2006/07/01 00:08:57 pedro Exp $	*/
d213 1
a213 1
	node = VTON(vp);
d330 1
a330 1
	node = VTON(vp);
d434 1
a434 1
	struct udf_node *node = VTON(vp);
d737 1
a737 1
	node = VTON(vp);
d863 1
a863 1
	node = VTON(vp);
d914 1
a914 1
	return (lockmgr(&VTON(vp)->i_lock, ap->a_flags, &vp->v_interlock));
d928 1
a928 1
	return (lockmgr(&VTON(vp)->i_lock, ap->a_flags | LK_RELEASE,
d939 1
a939 1
	return (lockstatus(&VTON(ap->a_vp)->i_lock));
d949 1
a949 1
	struct udf_node *node = VTON(vp);
d976 1
a976 1
	node = VTON(ap->a_vp);
d1028 1
a1028 1
	node = VTON(dvp);
d1191 1
a1191 1
	unode = VTON(vp);
@


1.14
log
@Fix MALLOC()/malloc() usage in a couple of places
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.13 2006/06/24 15:09:17 pedro Exp $	*/
a57 2
int udf_readatoffset(struct udf_node *, int *, off_t, struct buf **,
    uint8_t **);
@


1.13
log
@rearrange some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.12 2006/06/14 16:48:10 pat Exp $	*/
d612 1
a612 1
		FREE(ds->buf, M_UDFFID);
d637 1
a637 2
		MALLOC(ds->buf, uint8_t*, ds->udfmp->bsize, M_UDFFID,
		     M_WAITOK);
d706 1
a706 1
		FREE(ds->buf, M_UDFFID);
d1203 2
a1204 1
			FREE(unode->fentry, M_UDFFENTRY);
@


1.12
log
@Avoid potential deadlock during hash lookup; ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.11 2006/01/18 19:27:48 pedro Exp $	*/
d254 1
a254 1
 * XXX This is just a rough hack.  Daylight savings isn't calculated and tv_nsec
d340 1
a340 1
	 * XXX The spec says that -1 is valid for uid/gid and indicates an
d347 2
a348 2
	vap->va_ctime = vap->va_mtime; /* XXX Stored as an Extended Attribute */
	vap->va_rdev = 0; /* XXX */
d371 1
a371 1
	vap->va_filerev = 0; /* XXX */
d379 1
a379 5
	/*
	 * Dummy. Nothing to be done at this point.
	 */

	return (0);
d385 1
a385 5
	/*
	 * Dummy. Nothing to be done at this point.
	 */

	return (0);
d522 1
a522 1
	/* This is overkill, but not worth creating a new zone */
d608 1
a608 1
	 * XXX Is this the right place for this?
d769 1
a769 1
		/* XXX Should we return an error on a bad fid? */
@


1.11
log
@Fix math in udf_bmap_internal() on big-endian architectures
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.10 2006/01/14 19:04:17 miod Exp $	*/
d103 2
a104 1
	if (lh == NULL)
d106 2
@


1.10
log
@Better UDF name extraction code, which will not forget to report errors in
some cases; also silence a few udf messages unless option DIAGNOSTIC.

Tests and tweaks and ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.9 2005/11/19 02:18:01 pedro Exp $	*/
d1325 1
a1325 1
		    ((struct short_ad *)(icb))->pos;
@


1.9
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.8 2005/10/29 00:17:19 pedro Exp $	*/
a54 1
#include <isofs/udf/osta.h>
d472 3
a474 4
 * Call the OSTA routines to translate the name from a CS0 dstring to a
 * 16-bit Unicode String.  Hooks need to be placed in here to translate from
 * Unicode to the encoding that the kernel/user expects.  Return the length
 * of the translated string.
d483 1
d485 1
d492 4
a495 2
	if ((unilen = udf_UncompressUnicode(len, cs0string, transname)) == -1) {
		printf("udf: Unicode translation failed\n");
d503 1
a503 1
			destname[i] = '.';	/* Fudge the 16bit chars */
d508 2
@


1.8
log
@Account a self-reference for directories in udf_getattr(), okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.7 2005/05/11 18:06:31 pedro Exp $	*/
d918 1
a918 2
	return (lockmgr(&VTON(vp)->i_lock, ap->a_flags, &vp->v_interlock,
	    ap->a_p));
d933 1
a933 1
	    &vp->v_interlock, ap->a_p));
@


1.7
log
@no need to include '\n' on a panic(), fix two typos,
from Leonardo C. Filho <leonardo@@fesppr.br>, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.6 2005/04/15 11:49:37 pedro Exp $	*/
d348 1
@


1.6
log
@don't need to check for NULL when using M_WAITOK, from mpech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.5 2005/04/05 14:06:52 pedro Exp $	*/
d155 1
a155 1
		panic("hash entry is NULL, node->hash_id= %d\n", node->hash_id);
d280 1
a280 1
	/* Calclulate the month */
d513 2
a514 2
 * 0 on a successful match, nonzero therwise.  Unicode work may need to be done
 * here also.
@


1.5
log
@make sure *vpp == NULL if udf_lookup() returns an error
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.4 2005/03/30 01:10:00 pedro Exp $	*/
a752 2
		if (cookies == NULL)
			return (ENOMEM);
@


1.4
log
@Insert elucidative comment about what's going on.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.3 2005/03/30 00:37:13 pedro Exp $	*/
d1042 1
@


1.3
log
@Export udf_transname(), which will be needed
by disklabel spoofing code later on.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.2 2005/03/30 00:30:51 pedro Exp $	*/
d497 1
@


1.2
log
@Before doing the 8->16 bit expansion using a fixed-size buffer,
bound-check the string to see if it can be correctly translated.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vnops.c,v 1.1 2005/03/29 17:24:52 pedro Exp $	*/
d477 1
a477 1
static int
@


1.1
log
@Bring in UDF support from FreeBSD, disabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d482 5
@

