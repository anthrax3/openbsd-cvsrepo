head	1.58;
access;
symbols
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.38.0.6
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.4
	OPENBSD_5_0:1.38.0.2
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.36.0.2
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.27.0.4
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.23.0.6
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.4
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.23.0.2
	OPENBSD_4_0_BASE:1.23
	OPENBSD_3_9:1.6.0.2
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.3.0.2
	OPENBSD_3_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.58
date	2017.02.08.01.32.38;	author jsg;	state Exp;
branches;
next	1.57;
commitid	FqZ5ypdTGrHI31Vo;

1.57
date	2016.09.24.18.38.23;	author tedu;	state Exp;
branches;
next	1.56;
commitid	MPQxYy8mwzE8urJx;

1.56
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.55;
commitid	RlO92XR575sygHqm;

1.55
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.54;
commitid	D0avTYSlvEmEjLyB;

1.54
date	2016.08.25.00.06.44;	author dlg;	state Exp;
branches;
next	1.53;
commitid	IVsCIVcD4Ys8smQ3;

1.53
date	2016.08.13.20.53.17;	author guenther;	state Exp;
branches;
next	1.52;
commitid	15rk0aE492iEzsGW;

1.52
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.51;
commitid	wHLNY5GFNXJSFYaC;

1.51
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.50;
commitid	IMex9jbP378m0AFa;

1.50
date	2016.04.26.18.37.02;	author natano;	state Exp;
branches;
next	1.49;
commitid	WbumX8gCUOD8jZ5X;

1.49
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.48;
commitid	C0IKsjKoZxFScK3M;

1.48
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.47;
commitid	gAjwyca5TfuoJAhn;

1.47
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.46;
commitid	XOU3hWgTktDOU9BT;

1.46
date	2015.08.31.06.56.25;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	3mEO50kFOWsHyVUx;

1.45
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.44;
commitid	p4LJxGKbi0BU2cG6;

1.44
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.43;
commitid	P6Av4XGqOi3rFasL;

1.43
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.42;
commitid	4DOHz2gKfCx7RejS;

1.42
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.41;
commitid	C8XZQyreqTUCeixA;

1.41
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.35;

1.35
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.33;

1.33
date	2010.06.29.04.09.32;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.19.00.27.17;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.27.23.14.47;	author jolan;	state Exp;
branches;
next	1.30;

1.30
date	2009.08.14.22.23.45;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.09.22.29.56;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.05.04.35.25;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.14.10.55.21;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.09.20.54.01;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.06.02.18.38;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.07.15.50.42;	author pedro;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.06.18.42.01;	author thib;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.11.22.02.08;	author pedro;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.11.16.24.09;	author pedro;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.09.04.23.09;	author pedro;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.09.04.14.25;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.08.23.29.20;	author pedro;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.08.23.11.59;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.08.20.53.31;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.05.17.57.50;	author pedro;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.01.00.08.57;	author pedro;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.24.15.32.37;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.24.15.09.17;	author pedro;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.23.11.21.29;	author pedro;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.22.00.48.31;	author pedro;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.22.00.10.01;	author pedro;	state Exp;
branches;
next	1.7;

1.7
date	2006.06.14.16.40.15;	author pat;	state Exp;
branches;
next	1.6;

1.6
date	2006.01.14.23.59.32;	author pedro;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.14.21.32.40;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2006.01.14.19.04.17;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2005.05.15.21.26.19;	author pedro;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.30.00.56.19;	author pedro;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.17.24.52;	author pedro;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Move a pointer deref to after a NULL test.
ok krw@@
@
text
@/*	$OpenBSD: udf_vfsops.c,v 1.57 2016/09/24 18:38:23 tedu Exp $	*/

/*
 * Copyright (c) 2001, 2002 Scott Long <scottl@@freebsd.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/fs/udf/udf_vfsops.c,v 1.25 2005/01/25 15:52:03 phk Exp $
 */

/*
 * Ported to OpenBSD by Pedro Martelletto in February 2005.
 */

/*
 * Ok, here's how it goes.  The UDF specs are pretty clear on how each data
 * structure is made up, but not very clear on how they relate to each other.
 * Here is the skinny... This demostrates a filesystem with one file in the
 * root directory.  Subdirectories are treated just as normal files, but they
 * have File Id Descriptors of their children as their file data.  As for the
 * Anchor Volume Descriptor Pointer, it can exist in two of the following three
 * places: sector 256, sector n (the max sector of the disk), or sector
 * n - 256.  It's a pretty good bet that one will exist at sector 256 though.
 * One caveat is unclosed CD media.  For that, sector 256 cannot be written,
 * so the Anchor Volume Descriptor Pointer can exist at sector 512 until the
 * media is closed.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/uio.h>
#include <sys/buf.h>
#include <sys/dirent.h>
#include <sys/fcntl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mutex.h>
#include <sys/mount.h>
#include <sys/namei.h>
#include <sys/pool.h>
#include <sys/proc.h>
#include <sys/lock.h>
#include <sys/queue.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/endian.h>
#include <sys/specdev.h>

#include <crypto/siphash.h>

#include <isofs/udf/ecma167-udf.h>
#include <isofs/udf/udf.h>
#include <isofs/udf/udf_extern.h>

struct pool udf_trans_pool;
struct pool unode_pool;
struct pool udf_ds_pool;

int udf_find_partmaps(struct umount *, struct logvol_desc *);
int udf_get_vpartmap(struct umount *, struct part_map_virt *);
int udf_get_spartmap(struct umount *, struct part_map_spare *);
int udf_get_mpartmap(struct umount *, struct part_map_meta *);
int udf_mountfs(struct vnode *, struct mount *, uint32_t, struct proc *);

const struct vfsops udf_vfsops = {
	.vfs_fhtovp =		udf_fhtovp,
	.vfs_init =		udf_init,
	.vfs_mount =		udf_mount,
	.vfs_start =		udf_start,
	.vfs_root =		udf_root,
	.vfs_quotactl =		udf_quotactl,
	.vfs_statfs =		udf_statfs,
	.vfs_sync =		udf_sync,
	.vfs_unmount =		udf_unmount,
	.vfs_vget =		udf_vget,
	.vfs_vptofh =		udf_vptofh,
	.vfs_sysctl =		udf_sysctl,
	.vfs_checkexp =		udf_checkexp,
};

int
udf_init(struct vfsconf *foo)
{
	pool_init(&udf_trans_pool, MAXNAMLEN * sizeof(unicode_t), 0, IPL_NONE,
	    PR_WAITOK, "udftrpl", NULL);
	pool_init(&unode_pool, sizeof(struct unode), 0, IPL_NONE,
	    PR_WAITOK, "udfndpl", NULL);
	pool_init(&udf_ds_pool, sizeof(struct udf_dirstream), 0, IPL_NONE,
	    PR_WAITOK, "udfdspl", NULL);

	return (0);
}

int
udf_start(struct mount *mp, int flags, struct proc *p)
{
	return (0);
}

int
udf_mount(struct mount *mp, const char *path, void *data,
    struct nameidata *ndp,  struct proc *p)
{
	struct vnode *devvp;	/* vnode of the mount device */
	struct udf_args args;
	char fspec[MNAMELEN];
	int error;

	if ((mp->mnt_flag & MNT_RDONLY) == 0) {
		mp->mnt_flag |= MNT_RDONLY;
#ifdef UDF_DEBUG
		printf("udf_mount: enforcing read-only mode\n");
#endif
	}

	/*
	 * No root filesystem support.  Probably not a big deal, since the
	 * bootloader doesn't understand UDF.
	 */
	if (mp->mnt_flag & MNT_ROOTFS)
		return (EOPNOTSUPP);

	error = copyin(data, &args, sizeof(struct udf_args));
	if (error)
		return (error);

	if (args.fspec == NULL)
		return (EINVAL);

	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		return (error);

	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
	if ((error = namei(ndp)))
		return (error);

	devvp = ndp->ni_vp;
	if (devvp->v_type != VBLK) {
		vrele(devvp);
		return (ENOTBLK);
	}

	if (major(devvp->v_rdev) >= nblkdev) {
		vrele(devvp);
		return (ENXIO);
	}

	if ((error = udf_mountfs(devvp, mp, args.lastblock, p))) {
		vrele(devvp);
		return (error);
	}

	/*
	 * Keep a copy of the mount information.
	 */
	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);

	return (0);
};

/*
 * Check the descriptor tag for both the correct id and correct checksum.
 * Return zero if all is good, EINVAL if not.
 */
int
udf_checktag(struct desc_tag *tag, uint16_t id)
{
	uint8_t *itag;
	uint8_t i, cksum = 0;

	itag = (uint8_t *)tag;

	if (letoh16(tag->id) != id)
		return (EINVAL);

	for (i = 0; i < 15; i++)
		cksum = cksum + itag[i];
	cksum = cksum - itag[4];

	if (cksum == tag->cksum)
		return (0);

	return (EINVAL);
}

int
udf_mountfs(struct vnode *devvp, struct mount *mp, uint32_t lb, struct proc *p)
{
	struct buf *bp = NULL;
	struct anchor_vdp avdp;
	struct umount *ump = NULL;
	struct part_desc *pd;
	struct logvol_desc *lvd;
	struct fileset_desc *fsd;
	struct extfile_entry *xfentry;
	struct file_entry *fentry;
	uint32_t sector, size, mvds_start, mvds_end;
	uint32_t fsd_offset = 0;
	uint16_t part_num = 0, fsd_part = 0;
	int error = EINVAL;
	int logvol_found = 0, part_found = 0, fsd_found = 0;
	int bsize;

	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)))
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		return (error);

	error = VOP_OPEN(devvp, FREAD, FSCRED, p);
	if (error)
		return (error);

	ump = malloc(sizeof(*ump), M_UDFMOUNT, M_WAITOK | M_ZERO);

	mp->mnt_data = ump;
	mp->mnt_stat.f_fsid.val[0] = devvp->v_rdev;
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
	mp->mnt_stat.f_namemax = NAME_MAX;
	mp->mnt_flag |= MNT_LOCAL;

	ump->um_mountp = mp;
	ump->um_dev = devvp->v_rdev;
	ump->um_devvp = devvp;

	bsize = 2048;	/* Should probe the media for its size. */

	/* 
	 * Get the Anchor Volume Descriptor Pointer from sector 256.
	 * Should also check sector n - 256, n, and 512.
	 */
	sector = 256;
	if ((error = bread(devvp, sector * btodb(bsize), bsize, &bp)) != 0)
		goto bail;
	if ((error = udf_checktag((struct desc_tag *)bp->b_data, TAGID_ANCHOR)))
		goto bail;

	bcopy(bp->b_data, &avdp, sizeof(struct anchor_vdp));
	brelse(bp);
	bp = NULL;

	/*
	 * Extract the Partition Descriptor and Logical Volume Descriptor
	 * from the Volume Descriptor Sequence.
	 * Should we care about the partition type right now?
	 * What about multiple partitions?
	 */
	mvds_start = letoh32(avdp.main_vds_ex.loc);
	mvds_end = mvds_start + (letoh32(avdp.main_vds_ex.len) - 1) / bsize;
	for (sector = mvds_start; sector < mvds_end; sector++) {
		if ((error = bread(devvp, sector * btodb(bsize), bsize, 
				   &bp)) != 0) {
			printf("Can't read sector %d of VDS\n", sector);
			goto bail;
		}
		lvd = (struct logvol_desc *)bp->b_data;
		if (!udf_checktag(&lvd->tag, TAGID_LOGVOL)) {
			ump->um_bsize = letoh32(lvd->lb_size);
			ump->um_bmask = ump->um_bsize - 1;
			ump->um_bshift = ffs(ump->um_bsize) - 1;
			fsd_part = letoh16(lvd->_lvd_use.fsd_loc.loc.part_num);
			fsd_offset = letoh32(lvd->_lvd_use.fsd_loc.loc.lb_num);
			if (udf_find_partmaps(ump, lvd))
				break;
			logvol_found = 1;
		}
		pd = (struct part_desc *)bp->b_data;
		if (!udf_checktag(&pd->tag, TAGID_PARTITION)) {
			part_found = 1;
			part_num = letoh16(pd->part_num);
			ump->um_len = ump->um_reallen = letoh32(pd->part_len);
			ump->um_start = ump->um_realstart = letoh32(pd->start_loc);
		}

		brelse(bp); 
		bp = NULL;
		if ((part_found) && (logvol_found))
			break;
	}

	if (!part_found || !logvol_found) {
		error = EINVAL;
		goto bail;
	}

	if (ISSET(ump->um_flags, UDF_MNT_USES_META)) {
		/* Read Metadata File 'File Entry' to find Metadata file. */
		struct long_ad *la;
		sector = ump->um_start + ump->um_meta_start; /* Set in udf_get_mpartmap() */
		if ((error = RDSECTOR(devvp, sector, ump->um_bsize, &bp)) != 0) {
			printf("Cannot read sector %d for Metadata File Entry\n", sector);
			error = EINVAL;
			goto bail;
		}
		xfentry = (struct extfile_entry *)bp->b_data;
		fentry = (struct file_entry *)bp->b_data;
		if (udf_checktag(&xfentry->tag, TAGID_EXTFENTRY) == 0)
			la = (struct long_ad *)&xfentry->data[letoh32(xfentry->l_ea)];
		else if (udf_checktag(&fentry->tag, TAGID_FENTRY) == 0)
			la = (struct long_ad *)&fentry->data[letoh32(fentry->l_ea)];
		else {
			printf("Invalid Metadata File FE @@ sector %d! (tag.id %d)\n",
			    sector, fentry->tag.id);
			error = EINVAL;
			goto bail;
		}
		ump->um_meta_start = letoh32(la->loc.lb_num);
		ump->um_meta_len = letoh32(la->len);
		if (bp != NULL) {
			brelse(bp);
			bp = NULL;
		}
	} else if (fsd_part != part_num) {
		printf("FSD does not lie within the partition!\n");
		error = EINVAL;
		goto bail;
	}

	mtx_init(&ump->um_hashmtx, IPL_NONE);
	ump->um_hashtbl = hashinit(UDF_HASHTBLSIZE, M_UDFMOUNT, M_WAITOK,
	    &ump->um_hashsz);
	arc4random_buf(&ump->um_hashkey, sizeof(ump->um_hashkey));

	/* Get the VAT, if needed */
	if (ump->um_flags & UDF_MNT_FIND_VAT) {
		error = udf_vat_get(ump, lb);
		if (error)
			goto bail;
	}

	/*
	 * Grab the Fileset Descriptor
	 * Thanks to Chuck McCrobie <mccrobie@@cablespeed.com> for pointing
	 * me in the right direction here.
	 */

	if (ISSET(ump->um_flags, UDF_MNT_USES_META))
		sector = ump->um_meta_start; 
	else
		sector = fsd_offset;
	udf_vat_map(ump, &sector);
	if ((error = RDSECTOR(devvp, sector, ump->um_bsize, &bp)) != 0) {
		printf("Cannot read sector %d of FSD\n", sector);
		goto bail;
	}
	fsd = (struct fileset_desc *)bp->b_data;
	if (!udf_checktag(&fsd->tag, TAGID_FSD)) {
		fsd_found = 1;
		bcopy(&fsd->rootdir_icb, &ump->um_root_icb,
		    sizeof(struct long_ad));
		if (ISSET(ump->um_flags, UDF_MNT_USES_META)) {
			ump->um_root_icb.loc.lb_num += ump->um_meta_start; 
			ump->um_root_icb.loc.part_num = part_num;
		}
	}

	brelse(bp);
	bp = NULL;

	if (!fsd_found) {
		printf("Couldn't find the fsd\n");
		error = EINVAL;
		goto bail;
	}

	/*
	 * Find the file entry for the root directory.
	 */
	sector = letoh32(ump->um_root_icb.loc.lb_num);
	size = letoh32(ump->um_root_icb.len);
	udf_vat_map(ump, &sector);
	if ((error = udf_readlblks(ump, sector, size, &bp)) != 0) {
		printf("Cannot read sector %d\n", sector);
		goto bail;
	}

	xfentry = (struct extfile_entry *)bp->b_data;
	fentry = (struct file_entry *)bp->b_data;
	error = udf_checktag(&xfentry->tag, TAGID_EXTFENTRY);
	if (error) {
	    	error = udf_checktag(&fentry->tag, TAGID_FENTRY);
		if (error) {
			printf("Invalid root file entry!\n");
			goto bail;
		}
	}

	brelse(bp);
	bp = NULL;

	devvp->v_specmountpoint = mp;

	return (0);

bail:
	if (ump != NULL) {
		hashfree(ump->um_hashtbl, UDF_HASHTBLSIZE, M_UDFMOUNT);
		free(ump, M_UDFMOUNT, 0);
		mp->mnt_data = NULL;
		mp->mnt_flag &= ~MNT_LOCAL;
	}
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp != NULL)
		brelse(bp);

	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
	VOP_CLOSE(devvp, FREAD, FSCRED, p);
	VOP_UNLOCK(devvp, p);

	return (error);
}

int
udf_unmount(struct mount *mp, int mntflags, struct proc *p)
{
	struct umount *ump;
	struct vnode *devvp;
	int error, flags = 0;

	ump = VFSTOUDFFS(mp);
	devvp = ump->um_devvp;

	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;

	if ((error = vflush(mp, NULL, flags)))
		return (error);

	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	vinvalbuf(devvp, V_SAVE, NOCRED, p, 0, 0);
	(void)VOP_CLOSE(devvp, FREAD, NOCRED, p);
	VOP_UNLOCK(devvp, p);

	devvp->v_specmountpoint = NULL;
	vrele(devvp);

	if (ump->um_flags & UDF_MNT_USES_VAT)
		free(ump->um_vat, M_UDFMOUNT, 0);

	if (ump->um_stbl != NULL)
		free(ump->um_stbl, M_UDFMOUNT, 0);

	hashfree(ump->um_hashtbl, UDF_HASHTBLSIZE, M_UDFMOUNT);
	free(ump, M_UDFMOUNT, 0);

	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;

	return (0);
}

int
udf_root(struct mount *mp, struct vnode **vpp)
{
	struct umount *ump;
	struct vnode *vp;
	udfino_t id;
	int error;

	ump = VFSTOUDFFS(mp);

	id = udf_getid(&ump->um_root_icb);

	error = udf_vget(mp, id, vpp);
	if (error)
		return (error);

	vp = *vpp;
	vp->v_flag |= VROOT;

	return (0);
}

int
udf_quotactl(struct mount *mp, int cmds, uid_t uid, caddr_t arg,
    struct proc *p)
{
	return (EOPNOTSUPP);
}

int
udf_statfs(struct mount *mp, struct statfs *sbp, struct proc *p)
{
	struct umount *ump;

	ump = VFSTOUDFFS(mp);

	sbp->f_bsize = ump->um_bsize;
	sbp->f_iosize = ump->um_bsize;
	sbp->f_blocks = ump->um_len;
	sbp->f_bfree = 0;
	sbp->f_bavail = 0;
	sbp->f_files = 0;
	sbp->f_ffree = 0;
	sbp->f_favail = 0;
	copy_statfs_info(sbp, mp);

	return (0);
}

int
udf_sync(struct mount *mp, int waitfor, struct ucred *cred, struct proc *p)
{
	return (0);
}

int
udf_vget(struct mount *mp, ino_t ino, struct vnode **vpp)
{
	struct buf *bp;
	struct vnode *devvp;
	struct umount *ump;
	struct proc *p;
	struct vnode *vp, *nvp;
	struct unode *up;
	struct extfile_entry *xfe;
	struct file_entry *fe;
	uint32_t sector;
	int error, size;

	if (ino > (udfino_t)-1)
		panic("udf_vget: alien ino_t %llu", (unsigned long long)ino);

	p = curproc;
	bp = NULL;
	*vpp = NULL;
	ump = VFSTOUDFFS(mp);

	/* See if we already have this in the cache */
	if ((error = udf_hashlookup(ump, ino, LK_EXCLUSIVE, vpp)) != 0)
		return (error);
	if (*vpp != NULL)
		return (0);

	/*
	 * Allocate memory and check the tag id's before grabbing a new
	 * vnode, since it's hard to roll back if there is a problem.
	 */
	up = pool_get(&unode_pool, PR_WAITOK | PR_ZERO);

	/*
	 * Copy in the file entry.  Per the spec, the size can only be 1 block.
	 */
	sector = ino;
	devvp = ump->um_devvp;
	udf_vat_map(ump, &sector);
	if ((error = RDSECTOR(devvp, sector, ump->um_bsize, &bp)) != 0) {
		printf("Cannot read sector %d\n", sector);
		pool_put(&unode_pool, up);
		if (bp != NULL)
			brelse(bp);
		return (error);
	}

	xfe = (struct extfile_entry *)bp->b_data;
	fe = (struct file_entry *)bp->b_data;
	error = udf_checktag(&xfe->tag, TAGID_EXTFENTRY);
	if (error == 0) {
		size = letoh32(xfe->l_ea) + letoh32(xfe->l_ad);
	} else {
		error = udf_checktag(&fe->tag, TAGID_FENTRY);
		if (error) {
			printf("Invalid file entry!\n");
			pool_put(&unode_pool, up);
			if (bp != NULL)
				brelse(bp);
			return (ENOMEM);
		} else
			size = letoh32(fe->l_ea) + letoh32(fe->l_ad);
	}

	/* Allocate max size of FE/XFE. */
	up->u_fentry = malloc(size + UDF_EXTFENTRY_SIZE, M_UDFFENTRY, M_NOWAIT | M_ZERO);
	if (up->u_fentry == NULL) {
		pool_put(&unode_pool, up);
		if (bp != NULL)
			brelse(bp);
		return (ENOMEM); /* Cannot allocate file entry block */
	}

	if (udf_checktag(&xfe->tag, TAGID_EXTFENTRY) == 0)
		bcopy(bp->b_data, up->u_fentry, size + UDF_EXTFENTRY_SIZE);
	else
		bcopy(bp->b_data, up->u_fentry, size + UDF_FENTRY_SIZE);
	
	brelse(bp);
	bp = NULL;

	if ((error = udf_allocv(mp, &vp, p))) {
		free(up->u_fentry, M_UDFFENTRY, 0);
		pool_put(&unode_pool, up);
		return (error); /* Error from udf_allocv() */
	}

	up->u_vnode = vp;
	up->u_ino = ino;
	up->u_devvp = ump->um_devvp;
	up->u_dev = ump->um_dev;
	up->u_ump = ump;
	vp->v_data = up;
	vref(ump->um_devvp);

	rrw_init(&up->u_lock, "unode");

	/*
	 * udf_hashins() will lock the vnode for us.
	 */
	udf_hashins(up);

	switch (up->u_fentry->icbtag.file_type) {
	default:
		printf("Unrecognized file type (%d)\n", vp->v_type);
		vp->v_type = VREG;
		break;
	case UDF_ICB_FILETYPE_DIRECTORY:
		vp->v_type = VDIR;
		break;
	case UDF_ICB_FILETYPE_BLOCKDEVICE:
		vp->v_type = VBLK;
		break;
	case UDF_ICB_FILETYPE_CHARDEVICE:
		vp->v_type = VCHR;
		break;
	case UDF_ICB_FILETYPE_FIFO:
		vp->v_type = VFIFO;
		break;
	case UDF_ICB_FILETYPE_SOCKET:
		vp->v_type = VSOCK;
		break;
	case UDF_ICB_FILETYPE_SYMLINK:
		vp->v_type = VLNK;
		break;
	case UDF_ICB_FILETYPE_RANDOMACCESS:
	case UDF_ICB_FILETYPE_REALTIME:
	case UDF_ICB_FILETYPE_UNKNOWN:
		vp->v_type = VREG;
		break;
	}

	/* check if this is a vnode alias */
	if ((nvp = checkalias(vp, up->u_dev, ump->um_mountp)) != NULL) {
		printf("found a vnode alias\n");
		/*
		 * Discard unneeded vnode, but save its udf_node.
		 * Note that the lock is carried over in the udf_node
		 */
		nvp->v_data = vp->v_data;
		vp->v_data = NULL;
		vp->v_op = &spec_vops;
		vrele(vp);
		vgone(vp);
		/*
		 * Reinitialize aliased inode.
		 */
		vp = nvp;
		ump->um_devvp = vp;
	}

	*vpp = vp;

	return (0);
}

struct ifid {
	u_short	ifid_len;
	u_short	ifid_pad;
	int	ifid_ino;
	long	ifid_start;
};

int
udf_fhtovp(struct mount *mp, struct fid *fhp, struct vnode **vpp)
{
	struct ifid *ifhp;
	struct vnode *nvp;
	int error;

	ifhp = (struct ifid *)fhp;

	if ((error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}

	*vpp = nvp;

	return (0);
}

int
udf_vptofh(struct vnode *vp, struct fid *fhp)
{
	struct unode *up;
	struct ifid *ifhp;

	up = VTOU(vp);
	ifhp = (struct ifid *)fhp;
	ifhp->ifid_len = sizeof(struct ifid);
	ifhp->ifid_ino = up->u_ino;

	return (0);
}

int
udf_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	return (EINVAL);
}

int
udf_checkexp(struct mount *mp, struct mbuf *nam, int *exflagsp,
    struct ucred **credanonp)
{
	return (EACCES); /* For the time being */
}

/* Handle a virtual partition map */
int
udf_get_vpartmap(struct umount *ump, struct part_map_virt *pmv)
{
	ump->um_flags |= UDF_MNT_FIND_VAT; /* Should do more than this */
	return (0);
}

/* Handle a sparable partition map */
int
udf_get_spartmap(struct umount *ump, struct part_map_spare *pms)
{
	struct buf *bp;
	int i, error;

	ump->um_stbl = malloc(letoh32(pms->st_size), M_UDFMOUNT, M_NOWAIT);
	if (ump->um_stbl == NULL)
		return (ENOMEM);

	bzero(ump->um_stbl, letoh32(pms->st_size));

	/* Calculate the number of sectors per packet */
	ump->um_psecs = letoh16(pms->packet_len) / ump->um_bsize;

	error = udf_readlblks(ump, letoh32(pms->st_loc[0]),
	    letoh32(pms->st_size), &bp);

	if (error) {
		if (bp != NULL)
			brelse(bp);
		free(ump->um_stbl, M_UDFMOUNT, 0);
		return (error); /* Failed to read sparing table */
	}

	bcopy(bp->b_data, ump->um_stbl, letoh32(pms->st_size));
	brelse(bp);
	bp = NULL;

	if (udf_checktag(&ump->um_stbl->tag, 0)) {
		free(ump->um_stbl, M_UDFMOUNT, 0);
		return (EINVAL); /* Invalid sparing table found */
	}

	/*
	 * See how many valid entries there are here. The list is
	 * supposed to be sorted, 0xfffffff0 and higher are not valid.
	 */
	for (i = 0; i < letoh16(ump->um_stbl->rt_l); i++) {
		ump->um_stbl_len = i;
		if (letoh32(ump->um_stbl->entries[i].org) >= 0xfffffff0)
			break;
	}

	return (0);
}

/* Handle a metadata partition map */
int
udf_get_mpartmap(struct umount *ump, struct part_map_meta *pmm)
{
	ump->um_flags |= UDF_MNT_USES_META;
	ump->um_meta_start = pmm->meta_file_lbn;
	return (0);
}

/* Scan the partition maps */
int
udf_find_partmaps(struct umount *ump, struct logvol_desc *lvd)
{
	struct regid *pmap_id;
	unsigned char regid_id[UDF_REGID_ID_SIZE + 1];
	int i, ptype, psize, error;
	uint8_t *pmap = (uint8_t *) &lvd->maps[0];

	for (i = 0; i < letoh32(lvd->n_pm); i++) {
		ptype = pmap[0];
		psize = pmap[1];

		if (ptype != 1 && ptype != 2)
			return (EINVAL); /* Invalid partition map type */

		if (psize != sizeof(struct part_map_1)  &&
		    psize != sizeof(struct part_map_2))
			return (EINVAL); /* Invalid partition map size */

		if (ptype == 1) {
			pmap += sizeof(struct part_map_1);
			continue;
		}

		/* Type 2 map. Find out the details */
		pmap_id = (struct regid *) &pmap[4];
		regid_id[UDF_REGID_ID_SIZE] = '\0';
		bcopy(&pmap_id->id[0], &regid_id[0], UDF_REGID_ID_SIZE);

		if (!bcmp(&regid_id[0], "*UDF Virtual Partition",
		    UDF_REGID_ID_SIZE))
			error = udf_get_vpartmap(ump,
			    (struct part_map_virt *) pmap);
		else if (!bcmp(&regid_id[0], "*UDF Sparable Partition",
		    UDF_REGID_ID_SIZE))
			error = udf_get_spartmap(ump,
			    (struct part_map_spare *) pmap);
		else if (!bcmp(&regid_id[0], "*UDF Metadata Partition",
		    UDF_REGID_ID_SIZE))
			error = udf_get_mpartmap(ump,
			    (struct part_map_meta *) pmap);
		else
			return (EINVAL); /* Unsupported partition map */

		if (error)
			return (error); /* Error getting partition */

		pmap += sizeof(struct part_map_2);
	}

	return (0);
}
@


1.57
log
@use hashfree in fs code. from Mathieu -
ok guenther
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.56 2016/09/15 02:00:18 dlg Exp $	*/
a432 2
	hashfree(ump->um_hashtbl, UDF_HASHTBLSIZE, M_UDFMOUNT);

d434 1
@


1.56
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.55 2016/09/07 17:30:12 natano Exp $	*/
d433 1
a433 2
	if (ump->um_hashtbl != NULL)
		free(ump->um_hashtbl, M_UDFMOUNT, 0);
d482 1
a482 3
	if (ump->um_hashtbl != NULL)
		free(ump->um_hashtbl, M_UDFMOUNT, 0);

@


1.55
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.54 2016/08/25 00:06:44 dlg Exp $	*/
d105 1
a105 1
	pool_init(&udf_trans_pool, MAXNAMLEN * sizeof(unicode_t), 0, 0,
d107 1
a107 2
	pool_setipl(&udf_trans_pool, IPL_NONE);
	pool_init(&unode_pool, sizeof(struct unode), 0, 0,
d109 1
a109 2
	pool_setipl(&unode_pool, IPL_NONE);
	pool_init(&udf_ds_pool, sizeof(struct udf_dirstream), 0, 0,
a110 1
	pool_setipl(&udf_ds_pool, IPL_NONE);
@


1.54
log
@pool_setipl for udf

ok phessler@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.53 2016/08/13 20:53:17 guenther Exp $	*/
a170 11
	}

	/* Check the access rights on the mount device */
	if (p->p_ucred->cr_uid) {
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, VREAD, p->p_ucred, p);
		VOP_UNLOCK(devvp, p);
		if (error) {
			vrele(devvp);
			return (error);
		}
@


1.53
log
@Eliminate pointless casts to qaddr_t of a value being assigned to a void*

ok kettenis@@ krw@@ natano@@ dlg@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.52 2016/06/19 11:54:33 natano Exp $	*/
d107 1
d110 1
d113 1
@


1.52
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.51 2016/05/22 20:27:04 bluhm Exp $	*/
d264 1
a264 1
	mp->mnt_data = (qaddr_t) ump;
@


1.51
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.50 2016/04/26 18:37:02 natano Exp $	*/
d656 1
a656 1
	lockinit(&up->u_lock, PINOD, "unode", 0, 0);
@


1.50
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.49 2016/03/27 11:39:37 bluhm Exp $	*/
d452 2
@


1.49
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.48 2016/03/19 12:04:15 natano Exp $	*/
d267 1
d546 2
@


1.48
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.47 2016/03/17 18:52:31 bluhm Exp $	*/
d479 1
a479 1
	error = VOP_CLOSE(devvp, FREAD, NOCRED, p);
a480 2
	if (error)
		return (error);
@


1.47
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.46 2015/08/31 06:56:25 kettenis Exp $	*/
d174 1
a174 1
		VOP_UNLOCK(devvp, 0, p);
d254 1
a254 1
	VOP_UNLOCK(devvp, 0, p);
d456 1
a456 1
	VOP_UNLOCK(devvp, 0, p);
d480 1
a480 1
	VOP_UNLOCK(devvp, 0, p);
@


1.46
log
@Use PR_WAITOK to indicate that pools are not used in interrupt context
instead of using pool_allocator_nointr.

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.45 2015/03/14 03:38:50 jsg Exp $	*/
d498 1
a498 1
	mp->mnt_data = (qaddr_t)0;
@


1.45
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.44 2014/12/16 18:30:03 tedu Exp $	*/
d105 6
a110 6
	pool_init(&udf_trans_pool, MAXNAMLEN * sizeof(unicode_t), 0, 0, 0,
	    "udftrpl", &pool_allocator_nointr);
	pool_init(&unode_pool, sizeof(struct unode), 0, 0, 0,
	    "udfndpl", &pool_allocator_nointr);
	pool_init(&udf_ds_pool, sizeof(struct udf_dirstream), 0, 0, 0,
	    "udfdspl", &pool_allocator_nointr);
@


1.44
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.43 2014/11/18 10:42:15 dlg Exp $	*/
a53 1
#include <sys/conf.h>
@


1.43
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.42 2014/07/12 18:50:00 tedu Exp $	*/
d67 1
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.41 2013/05/30 17:35:01 guenther Exp $	*/
d70 2
d369 1
@


1.41
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.40 2013/04/15 15:32:19 jsing Exp $	*/
d441 1
a441 1
		free(ump->um_hashtbl, M_UDFMOUNT);
d444 1
a444 1
		free(ump, M_UDFMOUNT);
d485 1
a485 1
		free(ump->um_vat, M_UDFMOUNT);
d488 1
a488 1
		free(ump->um_stbl, M_UDFMOUNT);
d491 1
a491 1
		free(ump->um_hashtbl, M_UDFMOUNT);
d493 1
a493 1
	free(ump, M_UDFMOUNT);
d637 1
a637 1
		free(up->u_fentry, M_UDFFENTRY);
d795 1
a795 1
		free(ump->um_stbl, M_UDFMOUNT);
d804 1
a804 1
		free(ump->um_stbl, M_UDFMOUNT);
@


1.40
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.39 2012/09/10 11:10:59 jsing Exp $	*/
d506 1
a506 1
	ino_t id;
d565 5
a569 1
	int error, sector, size;
@


1.39
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.37 2011/07/04 04:30:41 tedu Exp $	*/
d191 2
@


1.38
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d125 1
a125 1
	size_t len;
d149 5
a153 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d187 4
a190 4
	copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &len);
	bzero(mp->mnt_stat.f_mntonname + len, MNAMELEN - len);
	copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1, &len);
	bzero(mp->mnt_stat.f_mntfromname + len, MNAMELEN - len);
@


1.37
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.36 2010/12/21 20:14:43 thib Exp $	*/
d68 1
a68 2

#include <miscfs/specfs/specdev.h>
@


1.36
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.35 2010/09/10 16:34:08 thib Exp $	*/
d273 1
a273 2
	if ((error = bread(devvp, sector * btodb(bsize), bsize, NOCRED,
			   &bp)) != 0)
d292 1
a292 1
				   NOCRED, &bp)) != 0) {
@


1.35
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.34 2010/09/06 23:44:10 thib Exp $	*/
d688 1
a688 1
		vp->v_op = spec_vnodeop_p;
@


1.34
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.33 2010/06/29 04:09:32 tedu Exp $	*/
d688 1
a688 1
		vp->v_op = &spec_vops;
@


1.33
log
@makefstype was only used in ported from freebsd filesystems.  fix them
and remove the function.  ok thib
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.32 2009/12/19 00:27:17 krw Exp $	*/
d688 1
a688 1
		vp->v_op = spec_vnodeop_p;
@


1.32
log
@Re-introduce the remaining bits of thib@@'s Aug 2006 VOP_CLOSE()
locking fixes. Tweak cd9660 code to be the same as everywhere else,
no functional change.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.31 2009/08/27 23:14:47 jolan Exp $	*/
d259 1
a259 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_UDF);
@


1.31
log
@make UDF less chatty during normal operation

ok krw/phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.30 2009/08/14 22:23:45 krw Exp $	*/
d446 2
d449 1
@


1.30
log
@First cut at UDF 2.[56] support, allowing read-only access to HDDVD
and Blu-ray disks. Previously working DVDs should still work.

Done at f2k9 with phessler@@. Vnode bug squashing by beck@@. Thanks
to Bryan Brake for sending HDDVD/Blu-ray hardware and disks to f2k9
in Stockholm.

ok beck@@ dlg@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.29 2009/07/09 22:29:56 thib Exp $	*/
d131 1
d133 1
@


1.29
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.27 2008/06/14 10:55:21 mk Exp $	*/
d82 1
d224 2
a225 1
	struct file_entry *root_fentry;
d310 2
a311 2
			ump->um_len = letoh32(pd->part_len);
			ump->um_start = letoh32(pd->start_loc);
d325 28
a352 1
	if (fsd_part != part_num) {
d374 5
a378 1
	sector = fsd_offset;
d389 4
d415 9
a423 4
	root_fentry = (struct file_entry *)bp->b_data;
	if ((error = udf_checktag(&root_fentry->tag, TAGID_FENTRY))) {
		printf("Invalid root file entry!\n");
		goto bail;
d552 1
a552 1
	struct vnode *vp;
d554 1
d589 1
d591 13
a603 5
	if (udf_checktag(&fe->tag, TAGID_FENTRY)) {
		printf("Invalid file entry!\n");
		pool_put(&unode_pool, up);
		brelse(bp);
		return (ENOMEM);
d606 2
a607 3
	size = UDF_FENTRY_SIZE + letoh32(fe->l_ea) + letoh32(fe->l_ad);

	up->u_fentry = malloc(size, M_UDFFENTRY, M_NOWAIT);
d610 2
a611 1
		brelse(bp);
d615 4
a618 1
	bcopy(bp->b_data, up->u_fentry, size);
d646 2
a647 1
		vp->v_type = VBAD;
a651 3
	case UDF_ICB_FILETYPE_RANDOMACCESS:
		vp->v_type = VREG;
		break;
d667 2
d674 19
d788 1
d808 8
d855 4
@


1.28
log
@Update to Reinoud Zandijk's much more current version of ecma167-udf.h
and make textual tweaks to .c files to keep them compiling. From
NetBSD.

No changes to .o's at this point.
@
text
@d580 1
a580 1
	VREF(ump->um_devvp);
@


1.27
log
@A bunch of pool_get() + bzero() -> pool_get(..., .. | PR_ZERO)
conversions that should shave a few bytes off the kernel.

ok henning, krw, jsing, oga, miod, and thib (``even though i usually prefer
FOO|BAR''; thanks for looking.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.26 2007/12/09 20:54:01 jmc Exp $	*/
d593 1
a593 1
	case UDF_ICB_TYPE_DIR:
d596 1
a596 1
	case UDF_ICB_TYPE_FILE:
d599 1
a599 1
	case UDF_ICB_TYPE_BLKDEV:
d602 1
a602 1
	case UDF_ICB_TYPE_CHRDEV:
d605 1
a605 1
	case UDF_ICB_TYPE_FIFO:
d608 1
a608 1
	case UDF_ICB_TYPE_SOCKET:
d611 1
a611 1
	case UDF_ICB_TYPE_SYMLINK:
d614 1
a614 1
	case UDF_ICB_TYPE_VAT_150:
d733 1
d750 2
a751 2
		if (psize != UDF_PMAP_TYPE1_SIZE &&
		    psize != UDF_PMAP_TYPE2_SIZE)
d755 1
a755 1
			pmap += UDF_PMAP_TYPE1_SIZE;
d778 1
a778 1
		pmap += UDF_PMAP_TYPE2_SIZE;
@


1.26
log
@update pedro's email address, at his request;
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.25 2007/10/06 02:18:38 krw Exp $	*/
d530 1
a530 2
	up = pool_get(&unode_pool, PR_WAITOK);
	bzero(up, sizeof(struct unode));
@


1.25
log
@Oops. Forgot to do FREE -> free when I did MALLOC -> malloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.24 2007/10/03 10:52:11 krw Exp $	*/
d32 1
a32 1
 * Ported to OpenBSD by Pedro Martelletto <pedro@@openbsd.org> in February 2005.
@


1.24
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.23 2006/08/07 15:50:42 pedro Exp $	*/
d396 1
a396 1
		FREE(ump, M_UDFMOUNT);
d442 1
a442 1
	FREE(ump, M_UDFMOUNT);
@


1.23
log
@Revert last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.21 2006/07/11 22:02:08 pedro Exp $	*/
d251 1
a251 3
	MALLOC(ump, struct umount *, sizeof(struct umount), M_UDFMOUNT,
	    M_WAITOK);
	bzero(ump, sizeof(struct umount));
@


1.22
log
@obey the locking disaplince wrt to VOP_CLOSE during umounts
and mount error paths.

ok sturm@@ pedro@@
@
text
@a403 2

	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
a404 1
	VOP_UNLOCK(devvp, 0, p);
@


1.21
log
@Don't hold up a vnode for the VAT when a unode is sufficient
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.20 2006/07/11 16:24:09 pedro Exp $	*/
d404 2
d407 1
@


1.20
log
@Make the mounting process pass a hint to the kernel of where to find the VAT
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.19 2006/07/09 04:23:09 pedro Exp $	*/
d434 3
@


1.19
log
@Be consistent about how we name 'struct umount' instances
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.18 2006/07/09 04:14:25 pedro Exp $	*/
d82 1
a99 2
int udf_mountfs(struct vnode *, struct mount *, struct proc *);

d173 1
a173 1
	if ((error = udf_mountfs(devvp, mp, p))) {
d215 1
a215 1
udf_mountfs(struct vnode *devvp, struct mount *mp, struct proc *p)
d337 1
a337 1
		error = udf_vat_get(ump);
@


1.18
log
@udf_mnt -> umount and rename fields accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.17 2006/07/08 23:29:20 pedro Exp $	*/
d220 1
a220 1
	struct umount *udfmp = NULL;
d252 1
a252 1
	MALLOC(udfmp, struct umount *, sizeof(struct umount), M_UDFMOUNT,
d254 1
a254 1
	bzero(udfmp, sizeof(struct umount));
d256 1
a256 1
	mp->mnt_data = (qaddr_t)udfmp;
d260 4
a263 3
	udfmp->um_mountp = mp;
	udfmp->um_dev = devvp->v_rdev;
	udfmp->um_devvp = devvp;
d298 3
a300 3
			udfmp->um_bsize = letoh32(lvd->lb_size);
			udfmp->um_bmask = udfmp->um_bsize - 1;
			udfmp->um_bshift = ffs(udfmp->um_bsize) - 1;
d303 1
a303 1
			if (udf_find_partmaps(udfmp, lvd))
d311 2
a312 2
			udfmp->um_len = letoh32(pd->part_len);
			udfmp->um_start = letoh32(pd->start_loc);
d332 3
a334 3
	mtx_init(&udfmp->um_hashmtx, IPL_NONE);
	udfmp->um_hashtbl = hashinit(UDF_HASHTBLSIZE, M_UDFMOUNT, M_WAITOK,
	    &udfmp->um_hashsz);
d337 2
a338 2
	if (udfmp->um_flags & UDF_MNT_FIND_VAT) {
		error = udf_vat_get(udfmp);
d349 2
a350 2
	udf_vat_map(udfmp, &sector);
	if ((error = RDSECTOR(devvp, sector, udfmp->um_bsize, &bp)) != 0) {
d357 1
a357 1
		bcopy(&fsd->rootdir_icb, &udfmp->um_root_icb,
d373 4
a376 4
	sector = letoh32(udfmp->um_root_icb.loc.lb_num);
	size = letoh32(udfmp->um_root_icb.len);
	udf_vat_map(udfmp, &sector);
	if ((error = udf_readlblks(udfmp, sector, size, &bp)) != 0) {
d395 2
a396 2
	if (udfmp->um_hashtbl != NULL)
		free(udfmp->um_hashtbl, M_UDFMOUNT);
d398 2
a399 2
	if (udfmp != NULL) {
		FREE(udfmp, M_UDFMOUNT);
d413 1
a413 1
	struct umount *udfmp;
d417 2
a418 2
	udfmp = VFSTOUDFFS(mp);
	devvp = udfmp->um_devvp;
d436 2
a437 2
	if (udfmp->um_stbl != NULL)
		free(udfmp->um_stbl, M_UDFMOUNT);
d439 2
a440 2
	if (udfmp->um_hashtbl != NULL)
		free(udfmp->um_hashtbl, M_UDFMOUNT);
d442 1
a442 1
	FREE(udfmp, M_UDFMOUNT);
d453 1
a453 1
	struct umount *udfmp;
d458 1
a458 1
	udfmp = VFSTOUDFFS(mp);
d460 1
a460 1
	id = udf_getid(&udfmp->um_root_icb);
d482 1
a482 1
	struct umount *udfmp;
d484 1
a484 1
	udfmp = VFSTOUDFFS(mp);
d486 3
a488 3
	sbp->f_bsize = udfmp->um_bsize;
	sbp->f_iosize = udfmp->um_bsize;
	sbp->f_blocks = udfmp->um_len;
d508 1
a508 1
	struct umount *udfmp;
d518 1
a518 1
	udfmp = VFSTOUDFFS(mp);
d521 1
a521 1
	if ((error = udf_hashlookup(udfmp, ino, LK_EXCLUSIVE, vpp)) != 0)
d537 3
a539 3
	devvp = udfmp->um_devvp;
	udf_vat_map(udfmp, &sector);
	if ((error = RDSECTOR(devvp, sector, udfmp->um_bsize, &bp)) != 0) {
d577 3
a579 3
	up->u_devvp = udfmp->um_devvp;
	up->u_dev = udfmp->um_dev;
	up->u_ump = udfmp;
d581 1
a581 1
	VREF(udfmp->um_devvp);
d681 1
a681 1
udf_get_vpartmap(struct umount *udfmp, struct part_map_virt *pmv)
d683 1
a683 1
	udfmp->um_flags |= UDF_MNT_FIND_VAT; /* Should do more than this */
d689 1
a689 1
udf_get_spartmap(struct umount *udfmp, struct part_map_spare *pms)
d694 2
a695 2
	udfmp->um_stbl = malloc(letoh32(pms->st_size), M_UDFMOUNT, M_NOWAIT);
	if (udfmp->um_stbl == NULL)
d698 1
a698 1
	bzero(udfmp->um_stbl, letoh32(pms->st_size));
d701 1
a701 1
	udfmp->um_psecs = letoh16(pms->packet_len) / udfmp->um_bsize;
d703 1
a703 1
	error = udf_readlblks(udfmp, letoh32(pms->st_loc[0]),
d709 1
a709 1
		free(udfmp->um_stbl, M_UDFMOUNT);
d713 1
a713 1
	bcopy(bp->b_data, udfmp->um_stbl, letoh32(pms->st_size));
d716 2
a717 2
	if (udf_checktag(&udfmp->um_stbl->tag, 0)) {
		free(udfmp->um_stbl, M_UDFMOUNT);
d725 3
a727 3
	for (i = 0; i < letoh16(udfmp->um_stbl->rt_l); i++) {
		udfmp->um_stbl_len = i;
		if (letoh32(udfmp->um_stbl->entries[i].org) >= 0xfffffff0)
d736 1
a736 1
udf_find_partmaps(struct umount *udfmp, struct logvol_desc *lvd)
d766 1
a766 1
			error = udf_get_vpartmap(udfmp,
d770 1
a770 1
			error = udf_get_spartmap(udfmp,
@


1.17
log
@Be consistent about how we name 'struct unode' instances
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.16 2006/07/08 23:11:59 pedro Exp $	*/
d79 3
a81 3
int udf_find_partmaps(struct udf_mnt *, struct logvol_desc *);
int udf_get_vpartmap(struct udf_mnt *, struct part_map_virt *);
int udf_get_spartmap(struct udf_mnt *, struct part_map_spare *);
d220 1
a220 1
	struct udf_mnt *udfmp = NULL;
d252 1
a252 1
	MALLOC(udfmp, struct udf_mnt *, sizeof(struct udf_mnt), M_UDFMOUNT,
d254 1
a254 1
	bzero(udfmp, sizeof(struct udf_mnt));
d260 3
a262 3
	udfmp->im_mountp = mp;
	udfmp->im_dev = devvp->v_rdev;
	udfmp->im_devvp = devvp;
d297 3
a299 3
			udfmp->bsize = letoh32(lvd->lb_size);
			udfmp->bmask = udfmp->bsize - 1;
			udfmp->bshift = ffs(udfmp->bsize) - 1;
d310 2
a311 2
			udfmp->part_len = letoh32(pd->part_len);
			udfmp->part_start = letoh32(pd->start_loc);
d331 3
a333 3
	mtx_init(&udfmp->hash_mtx, IPL_NONE);
	udfmp->hashtbl = hashinit(UDF_HASHTBLSIZE, M_UDFMOUNT, M_WAITOK,
	    &udfmp->hashsz);
d336 1
a336 1
	if (udfmp->im_flags & UDF_MNT_FIND_VAT) {
d349 1
a349 1
	if ((error = RDSECTOR(devvp, sector, udfmp->bsize, &bp)) != 0) {
d356 1
a356 1
		bcopy(&fsd->rootdir_icb, &udfmp->root_icb,
d372 2
a373 2
	sector = letoh32(udfmp->root_icb.loc.lb_num);
	size = letoh32(udfmp->root_icb.len);
d394 2
a395 2
	if (udfmp->hashtbl != NULL)
		free(udfmp->hashtbl, M_UDFMOUNT);
d412 1
a412 1
	struct udf_mnt *udfmp;
d417 1
a417 1
	devvp = udfmp->im_devvp;
d435 2
a436 2
	if (udfmp->s_table != NULL)
		free(udfmp->s_table, M_UDFMOUNT);
d438 2
a439 2
	if (udfmp->hashtbl != NULL)
		free(udfmp->hashtbl, M_UDFMOUNT);
d452 1
a452 1
	struct udf_mnt *udfmp;
d459 1
a459 1
	id = udf_getid(&udfmp->root_icb);
a466 1
	udfmp->root_vp = vp;
d481 1
a481 1
	struct udf_mnt *udfmp;
d485 3
a487 3
	sbp->f_bsize = udfmp->bsize;
	sbp->f_iosize = udfmp->bsize;
	sbp->f_blocks = udfmp->part_len;
d507 1
a507 1
	struct udf_mnt *udfmp;
d536 1
a536 1
	devvp = udfmp->im_devvp;
d538 1
a538 1
	if ((error = RDSECTOR(devvp, sector, udfmp->bsize, &bp)) != 0) {
d576 2
a577 2
	up->u_devvp = udfmp->im_devvp;
	up->u_dev = udfmp->im_dev;
d580 1
a580 1
	VREF(udfmp->im_devvp);
d680 1
a680 1
udf_get_vpartmap(struct udf_mnt *udfmp, struct part_map_virt *pmv)
d682 1
a682 1
	udfmp->im_flags |= UDF_MNT_FIND_VAT; /* Should do more than this */
d688 1
a688 1
udf_get_spartmap(struct udf_mnt *udfmp, struct part_map_spare *pms)
d693 2
a694 2
	udfmp->s_table = malloc(letoh32(pms->st_size), M_UDFMOUNT, M_NOWAIT);
	if (udfmp->s_table == NULL)
d697 1
a697 1
	bzero(udfmp->s_table, letoh32(pms->st_size));
d700 1
a700 1
	udfmp->p_sectors = letoh16(pms->packet_len) / udfmp->bsize;
d708 1
a708 1
		free(udfmp->s_table, M_UDFMOUNT);
d712 1
a712 1
	bcopy(bp->b_data, udfmp->s_table, letoh32(pms->st_size));
d715 2
a716 2
	if (udf_checktag(&udfmp->s_table->tag, 0)) {
		free(udfmp->s_table, M_UDFMOUNT);
d724 3
a726 3
	for (i = 0; i < letoh16(udfmp->s_table->rt_l); i++) {
		udfmp->s_table_entries = i;
		if (letoh32(udfmp->s_table->entries[i].org) >= 0xfffffff0)
d735 1
a735 1
udf_find_partmaps(struct udf_mnt *udfmp, struct logvol_desc *lvd)
@


1.16
log
@udf_node -> unode and rename fields accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.15 2006/07/08 20:53:31 pedro Exp $	*/
d511 1
a511 1
	struct unode *unode;
d530 2
a531 2
	unode = pool_get(&unode_pool, PR_WAITOK);
	bzero(unode, sizeof(struct unode));
d541 1
a541 1
		pool_put(&unode_pool, unode);
d550 1
a550 1
		pool_put(&unode_pool, unode);
d557 3
a559 3
	unode->u_fentry = malloc(size, M_UDFFENTRY, M_NOWAIT);
	if (unode->u_fentry == NULL) {
		pool_put(&unode_pool, unode);
d564 1
a564 1
	bcopy(bp->b_data, unode->u_fentry, size);
d570 2
a571 2
		free(unode->u_fentry, M_UDFFENTRY);
		pool_put(&unode_pool, unode);
d575 6
a580 6
	unode->u_vnode = vp;
	unode->u_ino = ino;
	unode->u_devvp = udfmp->im_devvp;
	unode->u_dev = udfmp->im_dev;
	unode->u_ump = udfmp;
	vp->v_data = unode;
d583 1
a583 1
	lockinit(&unode->u_lock, PINOD, "unode", 0, 0);
d588 1
a588 1
	udf_hashins(unode);
d590 1
a590 1
	switch (unode->u_fentry->icbtag.file_type) {
d654 1
a654 1
	struct unode *node;
d657 1
a657 1
	node = VTOU(vp);
d660 1
a660 1
	ifhp->ifid_ino = node->u_ino;
@


1.15
log
@Rename VTON() to VTOU()
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.14 2006/07/05 17:57:50 pedro Exp $	*/
d76 1
a76 1
struct pool udf_node_pool;
d106 1
a106 1
	pool_init(&udf_node_pool, sizeof(struct udf_node), 0, 0, 0,
d511 1
a511 1
	struct udf_node *unode;
d530 2
a531 2
	unode = pool_get(&udf_node_pool, PR_WAITOK);
	bzero(unode, sizeof(struct udf_node));
d541 1
a541 1
		pool_put(&udf_node_pool, unode);
d550 1
a550 1
		pool_put(&udf_node_pool, unode);
d557 3
a559 3
	unode->fentry = malloc(size, M_UDFFENTRY, M_NOWAIT);
	if (unode->fentry == NULL) {
		pool_put(&udf_node_pool, unode);
d564 1
a564 1
	bcopy(bp->b_data, unode->fentry, size);
d570 2
a571 2
		free(unode->fentry, M_UDFFENTRY);
		pool_put(&udf_node_pool, unode);
d575 5
a579 5
	unode->i_vnode = vp;
	unode->hash_id = ino;
	unode->i_devvp = udfmp->im_devvp;
	unode->i_dev = udfmp->im_dev;
	unode->udfmp = udfmp;
d583 1
a583 1
	lockinit(&unode->i_lock, PINOD, "unode", 0, 0);
d590 1
a590 1
	switch (unode->fentry->icbtag.file_type) {
d654 1
a654 1
	struct udf_node *node;
d660 1
a660 1
	ifhp->ifid_ino = node->hash_id;
@


1.14
log
@Add VAT support a la UDF 1.50
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.13 2006/07/01 00:08:57 pedro Exp $	*/
d657 1
a657 1
	node = VTON(vp);
@


1.13
log
@Fix MALLOC()/malloc() usage in a couple of places
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.12 2006/06/24 15:32:37 pedro Exp $	*/
d331 10
d347 2
a348 1
	sector = udfmp->part_start + fsd_offset;
d372 1
a372 1
	sector = letoh32(udfmp->root_icb.loc.lb_num) + udfmp->part_start;
d374 1
a388 4
	mtx_init(&udfmp->hash_mtx, IPL_NONE);
	udfmp->hashtbl = hashinit(UDF_HASHTBLSIZE, M_UDFMOUNT, M_WAITOK,
	    &udfmp->hashsz);

d394 3
d536 1
a536 1
	sector = ino + udfmp->part_start;
d538 1
d615 3
d683 2
a684 1
	return (EOPNOTSUPP); /* Not supported yet */
@


1.12
log
@replace unneeded bzero()
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.11 2006/06/24 15:09:17 pedro Exp $	*/
d428 1
a428 1
		FREE(udfmp->hashtbl, M_UDFMOUNT);
d542 1
d544 2
a545 2
	MALLOC(unode->fentry, struct file_entry *, size, M_UDFFENTRY,
	    M_NOWAIT);
a546 1
		printf("Cannot allocate file entry block\n");
d549 1
a549 1
		return (ENOMEM);
d558 1
a558 2
		printf("Error from udf_allocv\n");
		FREE(unode->fentry, M_UDFFENTRY);
d560 1
a560 1
		return (error);
@


1.11
log
@rearrange some comments
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.10 2006/06/23 11:21:29 pedro Exp $	*/
d746 1
a746 1
		bzero(&regid_id[0], UDF_REGID_ID_SIZE);
@


1.10
log
@fix two nested loops sharing the same control variable, plug two memory
leaks and be consistent about error values returned to the caller
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.9 2006/06/22 00:48:31 pedro Exp $	*/
a46 28
 *
 *  Sector:
 *     256:
 *       n: Anchor Volume Descriptor Pointer
 * n - 256:	|
 *		|
 *		|-->Main Volume Descriptor Sequence
 *			|	|
 *			|	|
 *			|	|-->Logical Volume Descriptor
 *			|			  |
 *			|-->Partition Descriptor  |
 *				|		  |
 *				|		  |
 *				|-->Fileset Descriptor
 *					|
 *					|
 *					|-->Root Dir File Entry
 *						|
 *						|
 *						|-->File data:
 *						    File Id Descriptor
 *							|
 *							|
 *							|-->File Entry
 *								|
 *								|
 *								|-->File data
d264 1
a264 1
	bsize = 2048;	/* XXX Should probe the media for its size. */
d268 1
a268 1
	 * XXX Should also check sector n - 256, n, and 512.
d284 2
a285 2
	 * XXX Should we care about the partition type right now?
	 * XXX What about multiple partitions?
@


1.9
log
@Roll in some defines for the file types used in udf_vget() and add one
for the VAT, no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.8 2006/06/22 00:10:01 pedro Exp $	*/
d108 2
d453 1
a453 1
		FREE(udfmp->s_table, M_UDFMOUNT);
d690 1
a690 2
	/* For the time being. */
	return (EACCES);
d693 55
a750 1
	struct part_map_spare *pms;
a751 1
	struct buf *bp;
d761 1
a761 1
			return (1); /* Invalid partition map type */
d765 1
a765 1
			return (1); /* Invalid partition map size */
d772 1
a772 1
		/* Type 2 map.  Gotta find out the details */
d777 13
a789 5
		if (bcmp(&regid_id[0], "*UDF Sparable Partition",
		    UDF_REGID_ID_SIZE)) {
			printf("Unsupported partition map: %s\n", &regid_id[0]);
			return (1);
		}
a790 1
		pms = (struct part_map_spare *) pmap;
a791 42

		MALLOC(udfmp->s_table, struct udf_sparing_table *,
		    letoh32(pms->st_size), M_UDFMOUNT, M_NOWAIT);
		if (udfmp->s_table == NULL)
			return (ENOMEM);

		bzero(udfmp->s_table, letoh32(pms->st_size));

		/* Calculate the number of sectors per packet. */
		/* XXX Logical or physical? */
		udfmp->p_sectors = letoh16(pms->packet_len) / udfmp->bsize;

		/*
		 * XXX If reading the first Sparing Table fails, should look
		 * for another table.
		 */
		if ((error = udf_readlblks(udfmp, letoh32(pms->st_loc[0]),
					   letoh32(pms->st_size), &bp)) != 0) {
			if (bp != NULL)
				brelse(bp);
			printf("Failed to read Sparing Table at sector %d\n",
			    letoh32(pms->st_loc[0]));
			return (error);
		}
		bcopy(bp->b_data, udfmp->s_table, letoh32(pms->st_size));
		brelse(bp);

		if (udf_checktag(&udfmp->s_table->tag, 0)) {
			printf("Invalid sparing table found\n");
			return (EINVAL);
		}

		/*
		 * See how many valid entries there are here.  The list is
		 * supposed to be sorted. 0xfffffff0 and higher are not valid
		 */
		for (i = 0; i < letoh16(udfmp->s_table->rt_l); i++) {
			udfmp->s_table_entries = i;
			if (letoh32(udfmp->s_table->entries[i].org) >=
			    0xfffffff0)
				break;
		}
@


1.8
log
@Make udf_find_partmaps() correctly spot virtual partition maps in
medias that have it, testing jmc@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.7 2006/06/14 16:40:15 pat Exp $	*/
d609 1
a609 1
	case 4:
d612 1
a612 1
	case 5:
d615 1
a615 1
	case 6:
d618 1
a618 1
	case 7:
d621 1
a621 1
	case 9:
d624 1
a624 1
	case 10:
d627 1
a627 1
	case 12:
@


1.7
log
@Plug memory leak in error path; ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.6 2006/01/14 23:59:32 pedro Exp $	*/
a694 1
	union udf_pmap *pmap;
d700 1
d703 9
a711 8
		pmap = (union udf_pmap *)&lvd->maps[i * UDF_PMAP_SIZE];
		ptype = pmap->data[0];
		psize = pmap->data[1];
		if (((ptype != 1) && (ptype != 2)) ||
		    ((psize != UDF_PMAP_SIZE) && (psize != 6))) {
			printf("Invalid partition map found\n");
			return (1);
		}
d714 1
a714 1
			/* Type 1 map.  We don't care */
d719 1
a719 1
		pmap_id = (struct regid *)&pmap->data[4];
d729 3
a731 1
		pms = &pmap->pms;
@


1.6
log
@Move udf_disklabelspoof() to udf_subr.c, no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.5 2006/01/14 21:32:40 pedro Exp $	*/
d242 2
a243 1
udf_mountfs(struct vnode *devvp, struct mount *mp, struct proc *p) {
d412 1
a412 1
	if (udfmp != NULL)
d414 3
d422 1
a422 1
};
d585 1
@


1.5
log
@Give UDF a chance of working on big-endian architectures, okay miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.4 2006/01/14 19:04:17 miod Exp $	*/
a95 1
#include <sys/disklabel.h>
a238 98
}

/*
 * Do a lazy probe on the underlying media to check if it's an UDF volume, in
 * which case we fake a disklabel for it.
 */
int
udf_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp)
{
	char vid[32];
	int i, bsize = 2048, error = EINVAL;
	uint32_t sector = 256, mvds_start, mvds_end;
	struct buf *bp;
	struct anchor_vdp avdp;
	struct pri_vol_desc *pvd;

	/*
	 * Get a buffer to work with.
	 */
	bp = geteblk(bsize);
	bp->b_dev = dev;

	/*
	 * Look for an Anchor Volume Descriptor at sector 256.
	 */
	bp->b_blkno = sector * btodb(bsize);
	bp->b_bcount = bsize;
	bp->b_flags = B_BUSY | B_READ;
	bp->b_resid = bp->b_blkno / lp->d_secpercyl;

	(*strat)(bp);
	if (biowait(bp))
		goto out;

	if (udf_checktag((struct desc_tag *)bp->b_data, TAGID_ANCHOR))
		goto out;

	bcopy(bp->b_data, &avdp, sizeof(avdp));
	mvds_start = letoh32(avdp.main_vds_ex.loc);
	mvds_end = mvds_start + (letoh32(avdp.main_vds_ex.len) - 1) / bsize;

	/*
	 * Then try to find a reference to a Primary Volume Descriptor.
	 */
	for (sector = mvds_start; sector < mvds_end; sector++) {
		bp->b_blkno = sector * btodb(bsize);
		bp->b_bcount = bsize;
		bp->b_flags = B_BUSY | B_READ;
		bp->b_resid = bp->b_blkno / lp->d_secpercyl;

		(*strat)(bp);
		if (biowait(bp))
			goto out;

		pvd = (struct pri_vol_desc *)bp->b_data;
		if (!udf_checktag(&pvd->tag, TAGID_PRI_VOL))
			break;
	}

	/*
	 * If we couldn't find a reference, bail out.
	 */
	if (sector == mvds_end)
		goto out;

	/*
	 * Okay, it's an UDF volume. Spoof a disklabel for it.
	 */
	if (udf_transname(pvd->vol_id, vid, sizeof(pvd->vol_id), NULL))
		strlcpy(lp->d_typename, vid, sizeof(lp->d_typename));

	for (i = 0; i < MAXPARTITIONS; i++) {
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
	}

	/*
	 * Fake two partitions, 'a' and 'c'.
	 */
	lp->d_partitions[0].p_size = lp->d_secperunit;
	lp->d_partitions[0].p_fstype = FS_UDF;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UDF;
	lp->d_npartitions = RAW_PART + 1;

	lp->d_bbsize = 8192;	/* Fake. */
	lp->d_sbsize = 64*1024;	/* Fake. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	error = 0;
out:
	bp->b_flags |= B_INVAL;
	brelse(bp);

	return (error);
@


1.4
log
@Better UDF name extraction code, which will not forget to report errors in
some cases; also silence a few udf messages unless option DIAGNOSTIC.

Tests and tweaks and ok pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.3 2005/05/15 21:26:19 pedro Exp $	*/
d229 1
a229 1
	if (tag->id != id)
@


1.3
log
@in udf_vget(), release the buffer if a bread() fails
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.2 2005/03/30 00:56:19 pedro Exp $	*/
a100 1
#include <isofs/udf/osta.h>
@


1.2
log
@Add disklabel spoofing code for UDF.
@
text
@d1 1
a1 1
/*	$OpenBSD: udf_vfsops.c,v 1.1 2005/03/29 17:24:52 pedro Exp $	*/
d627 1
d652 2
@


1.1
log
@Bring in UDF support from FreeBSD, disabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
d241 98
@

