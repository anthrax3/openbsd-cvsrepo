head	1.31;
access;
symbols
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.2
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.24.0.4
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.23.0.6
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.21.0.12
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.10
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.8
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.8
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.10
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.10
	OPENBSD_2_8:1.10.0.8
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.6
	OPENBSD_2_7_BASE:1.10
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.9.0.4
	OPENBSD_2_5_BASE:1.9
	OPENBSD_2_4:1.9.0.2
	OPENBSD_2_4_BASE:1.9
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.31
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.30;
commitid	wHLNY5GFNXJSFYaC;

1.30
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.29;
commitid	gAjwyca5TfuoJAhn;

1.29
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.28;
commitid	p4LJxGKbi0BU2cG6;

1.28
date	2015.01.09.05.01.56;	author tedu;	state Exp;
branches;
next	1.27;
commitid	KWogeIYA2sxG3IjB;

1.27
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.26;
commitid	P6Av4XGqOi3rFasL;

1.26
date	2014.11.18.10.42.15;	author dlg;	state Exp;
branches;
next	1.25;
commitid	4DOHz2gKfCx7RejS;

1.25
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.24;
commitid	uzzBR7hz9ncd4O6G;

1.24
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.23;
commitid	C8XZQyreqTUCeixA;

1.23
date	2013.06.02.01.07.39;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.04.23.19.40.28;	author oga;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.29.13.02.19;	author chl;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.01.23.47.55;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.11.16.08.50;	author thib;	state Exp;
branches;
next	1.17;

1.17
date	2007.03.21.17.29.31;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.09.12.43.16;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.13.02.09.46;	author jason;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.02.14.22;	author csapuntz;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	99.04.28.09.28.14;	author art;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	98.08.21.23.31.32;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	98.07.22.16.40.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.11.08.17.21.06;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.58.10;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.19.43;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.08.41;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	97.08.01.05.58.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.10.12.19;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.10.4.1
date	2001.07.04.10.48.07;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2003.06.07.11.03.39;	author ho;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.29.20;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2003.05.19.21.53.27;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@/*	$OpenBSD: cd9660_node.c,v 1.30 2016/03/19 12:04:15 natano Exp $	*/
/*	$NetBSD: cd9660_node.c,v 1.17 1997/05/05 07:13:57 mycroft Exp $	*/

/*-
 * Copyright (c) 1982, 1986, 1989, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cd9660_node.c	8.5 (Berkeley) 12/5/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mount.h>
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/namei.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/stat.h>

#include <crypto/siphash.h>

#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/cd9660_node.h>

/*
 * Structures associated with iso_node caching.
 */
u_int cd9660_isohash(dev_t, cdino_t);

struct iso_node **isohashtbl;
u_long isohash;
SIPHASH_KEY isohashkey;
#define	INOHASH(device, inum) cd9660_isohash((device), (inum))

extern int prtactive;	/* 1 => print out reclaim of active vnodes */

static u_int cd9660_chars2ui(u_char *, int);

/*
 * Initialize hash links for inodes and dnodes.
 */
int
cd9660_init(vfsp)
	struct vfsconf *vfsp;
{

	isohashtbl = hashinit(initialvnodes, M_ISOFSMNT, M_WAITOK, &isohash);
	arc4random_buf(&isohashkey, sizeof(isohashkey));
	return (0);
}

u_int
cd9660_isohash(dev_t device, cdino_t inum)
{
	SIPHASH_CTX ctx;

	SipHash24_Init(&ctx, &isohashkey);
	SipHash24_Update(&ctx, &device, sizeof(device));
	SipHash24_Update(&ctx, &inum, sizeof(inum));
	return (SipHash24_End(&ctx) & isohash);
}

/*
 * Use the device/inum pair to find the incore inode, and return a pointer
 * to it. If it is in core, but locked, wait for it.
 */
struct vnode *
cd9660_ihashget(dev, inum)
	dev_t dev;
	cdino_t inum;
{
	struct proc *p = curproc;               /* XXX */
	struct iso_node *ip;
	struct vnode *vp;

loop:
	/* XXX locking lock hash list? */
       for (ip = isohashtbl[INOHASH(dev, inum)]; ip; ip = ip->i_next) {
               if (inum == ip->i_number && dev == ip->i_dev) {
                       vp = ITOV(ip);
			/* XXX locking unlock hash list? */
                       if (vget(vp, LK_EXCLUSIVE, p))
                               goto loop;
                       return (vp);
	       }
       }
	/* XXX locking unlock hash list? */
       return (NULL);
}

/*
 * Insert the inode into the hash table, and return it locked.
 */
int
cd9660_ihashins(ip)
	struct iso_node *ip;
{
	struct iso_node **ipp, *iq;

	/* XXX locking lock hash list? */
	ipp = &isohashtbl[INOHASH(ip->i_dev, ip->i_number)];

	for (iq = *ipp; iq; iq = iq->i_next) {
		if (iq->i_dev == ip->i_dev &&
		    iq->i_number == ip->i_number)
			return (EEXIST);
	}
			      
	if ((iq = *ipp) != NULL)
		iq->i_prev = &ip->i_next;
	ip->i_next = iq;
	ip->i_prev = ipp;
	*ipp = ip;
	/* XXX locking unlock hash list? */

	rrw_enter(&ip->i_lock, RW_WRITE);

	return (0);
}

/*
 * Remove the inode from the hash table.
 */
void
cd9660_ihashrem(ip)
	register struct iso_node *ip;
{
	register struct iso_node *iq;

	if (ip->i_prev == NULL)
		return;
	
	/* XXX locking lock hash list? */
	if ((iq = ip->i_next) != NULL)
		iq->i_prev = ip->i_prev;
	*ip->i_prev = iq;
#ifdef DIAGNOSTIC
	ip->i_next = NULL;
	ip->i_prev = NULL;
#endif
	/* XXX locking unlock hash list? */
}

/*
 * Last reference to an inode, write the inode out and if necessary,
 * truncate and deallocate the file.
 */
int
cd9660_inactive(v)
	void *v;
{
	struct vop_inactive_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct proc *p = ap->a_p;
	register struct iso_node *ip = VTOI(vp);
	int error = 0;

#ifdef DIAGNOSTIC
	if (prtactive && vp->v_usecount != 0)
		vprint("cd9660_inactive: pushing active", vp);
#endif
	
	ip->i_flag = 0;
	VOP_UNLOCK(vp, p);
	/*
	 * If we are done with the inode, reclaim it
	 * so that it can be reused immediately.
	 */
	if (ip->inode.iso_mode == 0)
		vrecycle(vp, p);

	return (error);
}

/*
 * Reclaim an inode so that it can be used for other purposes.
 */
int
cd9660_reclaim(v)
	void *v;
{
	struct vop_reclaim_args *ap = v;
	register struct vnode *vp = ap->a_vp;
	register struct iso_node *ip = VTOI(vp);

#ifdef DIAGNOSTIC
	if (prtactive && vp->v_usecount != 0)
		vprint("cd9660_reclaim: pushing active", vp);
#endif

	/*
	 * Remove the inode from its hash chain.
	 */
	cd9660_ihashrem(ip);
	/*
	 * Purge old data structures associated with the inode.
	 */
	cache_purge(vp);
	if (ip->i_devvp) {
		vrele(ip->i_devvp);
		ip->i_devvp = 0;
	}
	free(vp->v_data, M_ISOFSNODE, 0);
	vp->v_data = NULL;
	return (0);
}

/*
 * File attributes
 */
void
cd9660_defattr(isodir, inop, bp)
	struct iso_directory_record *isodir;
	struct iso_node *inop;
	struct buf *bp;
{
	struct buf *bp2 = NULL;
	struct iso_mnt *imp;
	struct iso_extended_attributes *ap = NULL;
	int off;
	
	if (isonum_711(isodir->flags)&2) {
		inop->inode.iso_mode = S_IFDIR;
		/*
		 * If we return 2, fts() will assume there are no subdirectories
		 * (just links for the path and .), so instead we return 1.
		 */
		inop->inode.iso_links = 1;
	} else {
		inop->inode.iso_mode = S_IFREG;
		inop->inode.iso_links = 1;
	}
	if (!bp
	    && ((imp = inop->i_mnt)->im_flags & ISOFSMNT_EXTATT)
	    && (off = isonum_711(isodir->ext_attr_length))) {
		cd9660_bufatoff(inop, (off_t)-(off << imp->im_bshift), NULL,
			     &bp2);
		bp = bp2;
	}
	if (bp) {
		ap = (struct iso_extended_attributes *)bp->b_data;
		
		if (isonum_711(ap->version) == 1) {
			if (!(ap->perm[1]&0x10))
				inop->inode.iso_mode |= S_IRUSR;
			if (!(ap->perm[1]&0x40))
				inop->inode.iso_mode |= S_IXUSR;
			if (!(ap->perm[0]&0x01))
				inop->inode.iso_mode |= S_IRGRP;
			if (!(ap->perm[0]&0x04))
				inop->inode.iso_mode |= S_IXGRP;
			if (!(ap->perm[0]&0x10))
				inop->inode.iso_mode |= S_IROTH;
			if (!(ap->perm[0]&0x40))
				inop->inode.iso_mode |= S_IXOTH;
			inop->inode.iso_uid = isonum_723(ap->owner); /* what about 0? */
			inop->inode.iso_gid = isonum_723(ap->group); /* what about 0? */
		} else
			ap = NULL;
	}
	if (!ap) {
		inop->inode.iso_mode |=
		    S_IRUSR|S_IXUSR|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH;
		inop->inode.iso_uid = (uid_t)0;
		inop->inode.iso_gid = (gid_t)0;
	}
	if (bp2)
		brelse(bp2);
}

/*
 * Time stamps
 */
void
cd9660_deftstamp(isodir,inop,bp)
	struct iso_directory_record *isodir;
	struct iso_node *inop;
	struct buf *bp;
{
	struct buf *bp2 = NULL;
	struct iso_mnt *imp;
	struct iso_extended_attributes *ap = NULL;
	int off;
	
	if (!bp
	    && ((imp = inop->i_mnt)->im_flags & ISOFSMNT_EXTATT)
	    && (off = isonum_711(isodir->ext_attr_length))) {
		cd9660_bufatoff(inop, (off_t)-(off << imp->im_bshift), NULL,
			     &bp2);
		bp = bp2;
	}
	if (bp) {
		ap = (struct iso_extended_attributes *)bp->b_data;
		
		if (isonum_711(ap->version) == 1) {
			if (!cd9660_tstamp_conv17(ap->ftime,&inop->inode.iso_atime))
				cd9660_tstamp_conv17(ap->ctime,&inop->inode.iso_atime);
			if (!cd9660_tstamp_conv17(ap->ctime,&inop->inode.iso_ctime))
				inop->inode.iso_ctime = inop->inode.iso_atime;
			if (!cd9660_tstamp_conv17(ap->mtime,&inop->inode.iso_mtime))
				inop->inode.iso_mtime = inop->inode.iso_ctime;
		} else
			ap = NULL;
	}
	if (!ap) {
		cd9660_tstamp_conv7(isodir->date,&inop->inode.iso_ctime);
		inop->inode.iso_atime = inop->inode.iso_ctime;
		inop->inode.iso_mtime = inop->inode.iso_ctime;
	}
	if (bp2)
		brelse(bp2);
}

int
cd9660_tstamp_conv7(pi,pu)
	u_char *pi;
	struct timespec *pu;
{
	int crtime, days;
	int y, m, d, hour, minute, second;
	signed char tz;
	
	y = pi[0] + 1900;
	m = pi[1];
	d = pi[2];
	hour = pi[3];
	minute = pi[4];
	second = pi[5];
	tz = (signed char) pi[6];
	
	if (y < 1970) {
		pu->tv_sec  = 0;
		pu->tv_nsec = 0;
		return (0);
	} else {
#ifdef	ORIGINAL
		/* computes day number relative to Sept. 19th,1989 */
		/* don't even *THINK* about changing formula. It works! */
		days = 367*(y-1980)-7*(y+(m+9)/12)/4-3*((y+(m-9)/7)/100+1)/4+275*m/9+d-100;
#else
		/*
		 * Changed :-) to make it relative to Jan. 1st, 1970
		 * and to disambiguate negative division
		 */
		days = 367*(y-1960)-7*(y+(m+9)/12)/4-3*((y+(m+9)/12-1)/100+1)/4+275*m/9+d-239;
#endif
		crtime = ((((days * 24) + hour) * 60 + minute) * 60) + second;
		
		/* timezone offset is unreliable on some disks */
		if (-48 <= tz && tz <= 52)
			crtime -= tz * 15 * 60;
	}
	pu->tv_sec  = crtime;
	pu->tv_nsec = 0;
	return (1);
}

static u_int
cd9660_chars2ui(begin,len)
	u_char *begin;
	int len;
{
	u_int rc;
	
	for (rc = 0; --len >= 0;) {
		rc *= 10;
		rc += *begin++ - '0';
	}
	return (rc);
}

int
cd9660_tstamp_conv17(pi,pu)
	u_char *pi;
	struct timespec *pu;
{
	u_char buf[7];
	
	/* year:"0001"-"9999" -> -1900  */
	buf[0] = cd9660_chars2ui(pi,4) - 1900;
	
	/* month: " 1"-"12"      -> 1 - 12 */
	buf[1] = cd9660_chars2ui(pi + 4,2);
	
	/* day:   " 1"-"31"      -> 1 - 31 */
	buf[2] = cd9660_chars2ui(pi + 6,2);
	
	/* hour:  " 0"-"23"      -> 0 - 23 */
	buf[3] = cd9660_chars2ui(pi + 8,2);
	
	/* minute:" 0"-"59"      -> 0 - 59 */
	buf[4] = cd9660_chars2ui(pi + 10,2);
	
	/* second:" 0"-"59"      -> 0 - 59 */
	buf[5] = cd9660_chars2ui(pi + 12,2);
	
	/* difference of GMT */
	buf[6] = pi[16];
	
	return (cd9660_tstamp_conv7(buf,pu));
}

cdino_t
isodirino(isodir, imp)
	struct iso_directory_record *isodir;
	struct iso_mnt *imp;
{
	cdino_t ino;

	ino = (isonum_733(isodir->extent) +
	    isonum_711(isodir->ext_attr_length)) << imp->im_bshift;
	return (ino);
}
@


1.30
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.29 2015/03/14 03:38:50 jsg Exp $	*/
d149 1
a149 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, NULL);
@


1.29
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.28 2015/01/09 05:01:56 tedu Exp $	*/
d197 1
a197 1
	VOP_UNLOCK(vp, 0, p);
@


1.28
log
@rename desiredvnodes to initialvnodes. less of a lie. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.27 2014/12/16 18:30:03 tedu Exp $	*/
a56 1
#include <isofs/cd9660/iso_rrip.h>
@


1.27
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.26 2014/11/18 10:42:15 dlg Exp $	*/
d81 1
a81 1
	isohashtbl = hashinit(desiredvnodes, M_ISOFSMNT, M_WAITOK, &isohash);
@


1.26
log
@use siphash for key lookups in all the filesystem hashes.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.25 2014/09/14 14:17:25 jsg Exp $	*/
d46 1
@


1.25
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.24 2014/07/12 18:50:00 tedu Exp $	*/
d51 2
d61 2
d65 2
a66 1
#define	INOHASH(device, inum)	(((device) + ((inum)>>12)) & isohash)
d81 1
d83 11
@


1.24
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.23 2013/06/02 01:07:39 deraadt Exp $	*/
a42 1
#include <sys/proc.h>
@


1.23
log
@Remove disabled ISODEVMAP support.  dev_t's on one system will not be
similar on another, so using that is crazy.
ok guenther krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.22 2013/05/30 17:35:01 guenther Exp $	*/
d220 1
a220 1
	free(vp->v_data, M_ISOFSNODE);
@


1.22
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.21 2010/04/23 19:40:28 oga Exp $	*/
a63 6
#ifdef ISODEVMAP
struct iso_node **idvhashtbl;
u_long idvhash;
#define	DNOHASH(device, inum)	(((device) + ((inum)>>12)) & idvhash)
#endif

a76 3
#ifdef ISODEVMAP
	idvhashtbl = hashinit(desiredvnodes / 8, M_ISOFSMNT, M_WAITOK, &idvhash);
#endif
a78 56

#ifdef ISODEVMAP
/*
 * Enter a new node into the device hash list
 */
struct iso_dnode *
iso_dmap(device, inum, create)
	dev_t	device;
	cdino_t	inum;
	int	create;
{
	register struct iso_dnode **dpp, *dp, *dq;

	dpp = &idvhashtbl[DNOHASH(device, inum)];
	for (dp = *dpp;; dp = dp->d_next) {
		if (dp == NULL)
			return (NULL);
		if (inum == dp->i_number && device == dp->i_dev)
			return (dp);
	}

	if (!create)
		return (NULL);

	dp = malloc(sizeof(struct iso_dnode), M_CACHE, M_WAITOK);
	dp->i_dev = dev;
	dp->i_number = ino;

	if (dq = *dpp)
		dq->d_prev = dp->d_next;
	dp->d_next = dq;
	dp->d_prev = dpp;
	*dpp = dp;

	return (dp);
}

void
iso_dunmap(device)
	dev_t device;
{
	struct iso_dnode **dpp, *dp, *dq;
	
	for (dpp = idvhashtbl; dpp <= idvhashtbl + idvhash; dpp++) {
		for (dp = *dpp; dp != NULL; dp = dq) {
			dq = dp->d_next;
			if (device == dp->i_dev) {
				if (dq)
					dq->d_prev = dp->d_prev;
				*dp->d_prev = dq;
				free(dp, M_CACHE);
			}
		}
	}
}
#endif
@


1.21
log
@simple_lock -> XXXLOCKING comments.

This is a similar case to the ntfs commit just made, howerver things a
somewhat more hard to audit because cd9660 actually implements vnode
locking (using lockmgr still due to vnode recursion *vomit*). No rwlock
on the hash table though so these locks can probably be converted to
mutexes fairly simply to prevent reentering the list code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.20 2007/10/29 13:02:19 chl Exp $	*/
d96 1
a96 1
	ino_t	inum;
d152 1
a152 1
	ino_t inum;
d485 1
a485 1
ino_t
d490 1
a490 1
	ino_t ino;
@


1.20
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.19 2007/06/01 23:47:55 deraadt Exp $	*/
a62 1
struct simplelock cd9660_ihash_slock;
a82 1
	simple_lock_init(&cd9660_ihash_slock);
d159 1
a159 1
       simple_lock(&cd9660_ihash_slock);
d163 1
a163 1
                       simple_unlock(&cd9660_ihash_slock);
d169 1
a169 1
       simple_unlock(&cd9660_ihash_slock);
d182 1
a182 1
	simple_lock(&cd9660_ihash_slock);
d196 1
a196 1
	simple_unlock(&cd9660_ihash_slock);
d215 1
a215 1
	simple_lock(&cd9660_ihash_slock);
d223 1
a223 1
	simple_unlock(&cd9660_ihash_slock);
@


1.19
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.18 2007/04/11 16:08:50 thib Exp $	*/
d114 1
a114 2
	MALLOC(dp, struct iso_dnode *, sizeof(struct iso_dnode), M_CACHE,
	       M_WAITOK);
d140 1
a140 1
				FREE(dp, M_CACHE);
d287 1
a287 1
	FREE(vp->v_data, M_ISOFSNODE);
@


1.18
log
@Remove the simplelock argument from vrecycle();

ok pedro@@, sturm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.17 2007/03/21 17:29:31 thib Exp $	*/
d237 1
a237 4
	struct vop_inactive_args /* {
		struct vnode *a_vp;
		struct proc *a_p;
	} */ *ap = v;
d267 1
a267 3
	struct vop_reclaim_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
@


1.17
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.16 2006/01/09 12:43:16 pedro Exp $	*/
d258 1
a258 1
		vrecycle(vp, (struct simplelock *)0, p);
@


1.16
log
@Put vprint() under DIAGNOSTIC, as to save space in generated ramdisks.
Inspiration from miod@@, okay deraadt@@. Tested on i386, macppc and amd64.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.15 2005/11/19 02:18:01 pedro Exp $	*/
a165 1
                       simple_lock(&vp->v_interlock);
d167 1
a167 1
                       if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
@


1.15
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.14 2003/06/02 23:28:05 millert Exp $	*/
d246 2
a247 1
	
d250 1
d276 2
a277 1
	
d280 2
@


1.14
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.13 2003/05/13 02:09:46 jason Exp $	*/
a183 1
	struct proc *p = curproc;
d202 2
a203 1
	lockmgr(&ip->i_lock, LK_EXCLUSIVE, 0, p);
@


1.13
log
@Kill a bunch more commons (very few left =)
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.12 2002/03/14 01:27:03 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.11 2001/06/23 02:14:22 csapuntz Exp $	*/
d75 1
a75 1
int prtactive;	/* 1 => print out reclaim of active vnodes */
@


1.11
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.10 1999/04/28 09:28:14 art Exp $	*/
d77 1
a77 1
static u_int cd9660_chars2ui __P((u_char *, int));
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.11 2001/06/23 02:14:22 csapuntz Exp $	*/
d77 1
a77 1
static u_int cd9660_chars2ui(u_char *, int);
@


1.11.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d75 1
a75 1
extern int prtactive;	/* 1 => print out reclaim of active vnodes */
@


1.10
log
@zap the newhashinit hack.
Add an extra flag to hashinit telling if it should wait in malloc.
update all calls to hashinit.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.9 1998/08/21 23:31:32 csapuntz Exp $	*/
d326 1
a326 1
		VOP_BLKATOFF(ITOV(inop), (off_t)-(off << imp->im_bshift), NULL,
d378 1
a378 1
		VOP_BLKATOFF(ITOV(inop), (off_t)-(off << imp->im_bshift), NULL,
@


1.10.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.10 1999/04/28 09:28:14 art Exp $	*/
d326 1
a326 1
		cd9660_bufatoff(inop, (off_t)-(off << imp->im_bshift), NULL,
d378 1
a378 1
		cd9660_bufatoff(inop, (off_t)-(off << imp->im_bshift), NULL,
@


1.10.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 1
static u_int cd9660_chars2ui(u_char *, int);
@


1.10.4.3
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d75 1
a75 1
extern int prtactive;	/* 1 => print out reclaim of active vnodes */
@


1.10.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.10.4.3 2003/05/16 00:29:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.9
log
@

Fix malloc race in the cd9660 fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.8 1998/07/22 16:40:08 deraadt Exp $	*/
d87 1
a87 1
	isohashtbl = hashinit(desiredvnodes, M_ISOFSMNT, &isohash);
d90 1
a90 1
	idvhashtbl = hashinit(desiredvnodes / 8, M_ISOFSMNT, &idvhash);
@


1.8
log
@fix tz calculation; bug found by rees
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.7 1997/11/08 17:21:06 niklas Exp $	*/
d184 1
a184 1
void
d193 7
d208 1
d220 3
@


1.7
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.6 1997/11/06 05:58:10 csapuntz Exp $	*/
d399 2
a400 1
	int y, m, d, hour, minute, second, tz;
d408 1
a408 1
	tz = pi[6];
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: cd9660_node.c,v 1.5 1997/10/06 20:19:43 deraadt Exp $	*/
/*	$NetBSD: cd9660_node.c,v 1.15 1996/02/09 21:31:58 christos Exp $	*/
d57 1
d78 1
d252 1
a252 1
	return error;
d412 1
a412 1
		return 0;
d433 1
a433 1
	return 1;
d447 1
a447 1
	return rc;
d478 1
a478 1
	return cd9660_tstamp_conv7(buf,pu);
d488 2
a489 2
	ino = (isonum_733(isodir->extent) + isonum_711(isodir->ext_attr_length))
	      << imp->im_bshift;
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.3 1997/08/01 05:58:55 millert Exp $	*/
d66 1
a76 1

d80 3
a82 2
void
cd9660_init()
d86 1
d90 1
d111 1
d137 1
a137 1
		for (dp = *dpp; dp != NULL; dp = dq)
d155 2
a156 2
cd9660_ihashget(device, inum)
	dev_t device;
d159 2
a160 1
	register struct iso_node *ip;
d163 14
a176 17
	for (;;)
		for (ip = isohashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
			if (ip == NULL)
				return (NULL);
			if (inum == ip->i_number && device == ip->i_dev) {
				if (ip->i_flag & IN_LOCKED) {
					ip->i_flag |= IN_WANTED;
					sleep(ip, PINOD);
					break;
				}
				vp = ITOV(ip);
				if (!vget(vp, 1))
					return (vp);
				break;
			}
		}
	/* NOTREACHED */
d186 1
d189 1
d196 3
a198 7
	if (ip->i_flag & IN_LOCKED)
		panic("cd9660_ihashins: already locked");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
	ip->i_flag |= IN_LOCKED;
d210 1
d218 1
d231 1
d234 1
d242 1
d247 3
a249 2
	if (vp->v_usecount == 0 && ip->inode.iso_mode == 0)
		vgone(vp);
@


1.4
log
@VFS Lite2 Changes
@
text
@a65 1
struct simplelock cd9660_ihash_slock;
d76 1
d80 2
a81 3
int
cd9660_init(vfsp)
	struct vfsconf *vfsp;
a84 1
	simple_lock_init(&cd9660_ihash_slock);
a87 1
	return (0);
a107 1
	}
d133 1
a133 1
		for (dp = *dpp; dp != NULL; dp = dq) {
d151 2
a152 2
cd9660_ihashget(dev, inum)
	dev_t dev;
d155 1
a155 2
	struct proc *p = curproc;               /* XXX */
	struct iso_node *ip;
d158 17
a174 14
loop:
       simple_lock(&cd9660_ihash_slock);
       for (ip = isohashtbl[INOHASH(dev, inum)]; ip; ip = ip->i_next) {
               if (inum == ip->i_number && dev == ip->i_dev) {
                       vp = ITOV(ip);
                       simple_lock(&vp->v_interlock);
                       simple_unlock(&cd9660_ihash_slock);
                       if (vget(vp, LK_EXCLUSIVE | LK_INTERLOCK, p))
                               goto loop;
                       return (vp);
	       }
       }
       simple_unlock(&cd9660_ihash_slock);
       return (NULL);
a183 1
	struct proc *p = curproc;
a185 1
	simple_lock(&cd9660_ihash_slock);
d192 7
a198 3
	simple_unlock(&cd9660_ihash_slock);

	lockmgr(&ip->i_lock, LK_EXCLUSIVE, 0, p);
a209 1
	simple_lock(&cd9660_ihash_slock);
a216 1
	simple_unlock(&cd9660_ihash_slock);
a228 1
		struct proc *a_p;
a230 1
	struct proc *p = ap->a_p;
a237 1
	VOP_UNLOCK(vp, 0, p);
d242 2
a243 3
	if (ip->inode.iso_mode == 0)
		vrecycle(vp, (struct simplelock *)0, p);

@


1.3
log
@From NetBSD (mycroft):
    Eliminate bogus uses of V{READ,WRITE,EXEC}.  Use S_I[RWX]{USR,GRP,OTH}
    where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_node.c,v 1.2 1996/02/29 10:12:19 niklas Exp $	*/
d66 1
a76 1

d80 3
a82 2
void
cd9660_init()
d86 1
d90 1
d111 1
d137 1
a137 1
		for (dp = *dpp; dp != NULL; dp = dq)
d155 2
a156 2
cd9660_ihashget(device, inum)
	dev_t device;
d159 2
a160 1
	register struct iso_node *ip;
d163 14
a176 17
	for (;;)
		for (ip = isohashtbl[INOHASH(device, inum)];; ip = ip->i_next) {
			if (ip == NULL)
				return (NULL);
			if (inum == ip->i_number && device == ip->i_dev) {
				if (ip->i_flag & IN_LOCKED) {
					ip->i_flag |= IN_WANTED;
					sleep(ip, PINOD);
					break;
				}
				vp = ITOV(ip);
				if (!vget(vp, 1))
					return (vp);
				break;
			}
		}
	/* NOTREACHED */
d186 1
d189 1
d196 3
a198 7
	if (ip->i_flag & IN_LOCKED)
		panic("cd9660_ihashins: already locked");
	if (curproc)
		ip->i_lockholder = curproc->p_pid;
	else
		ip->i_lockholder = -1;
	ip->i_flag |= IN_LOCKED;
d210 1
d218 1
d231 1
d234 1
d242 1
d247 3
a249 2
	if (vp->v_usecount == 0 && ip->inode.iso_mode == 0)
		vgone(vp);
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d315 10
d326 1
a326 11
				inop->inode.iso_mode |= VEXEC >> 6;
			if (!(ap->perm[0]&0x10))
				inop->inode.iso_mode |= VREAD >> 6;
			if (!(ap->perm[0]&4))
				inop->inode.iso_mode |= VEXEC >> 3;
			if (!(ap->perm[0]&1))
				inop->inode.iso_mode |= VREAD >> 3;
			if (!(ap->perm[1]&0x40))
				inop->inode.iso_mode |= VEXEC;
			if (!(ap->perm[1]&0x10))
				inop->inode.iso_mode |= VREAD;
d333 2
a334 1
		inop->inode.iso_mode |= VREAD|VEXEC|(VREAD|VEXEC)>>3|(VREAD|VEXEC)>>6;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: cd9660_node.c,v 1.13 1994/12/24 15:30:07 cgd Exp $	*/
d51 1
d75 2
d80 1
a80 1
int
d187 1
a187 1
	if (iq = *ipp)
d210 1
a210 1
	if (iq = ip->i_next)
d224 3
a226 1
cd9660_inactive(ap)
d229 1
a229 2
	} */ *ap;
{
d251 3
a253 1
cd9660_reclaim(ap)
d256 1
a256 2
	} */ *ap;
{
d401 2
a402 2
		pu->ts_sec  = 0;
		pu->ts_nsec = 0;
d422 2
a423 2
	pu->ts_sec  = crtime;
	pu->ts_nsec = 0;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
