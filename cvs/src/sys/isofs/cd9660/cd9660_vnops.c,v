head	1.76;
access;
symbols
	OPENBSD_6_0:1.76.0.2
	OPENBSD_6_0_BASE:1.76
	OPENBSD_5_9:1.74.0.2
	OPENBSD_5_9_BASE:1.74
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.70.0.2
	OPENBSD_5_7_BASE:1.70
	OPENBSD_5_6:1.66.0.4
	OPENBSD_5_6_BASE:1.66
	OPENBSD_5_5:1.64.0.4
	OPENBSD_5_5_BASE:1.64
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.57.0.2
	OPENBSD_5_3_BASE:1.57
	OPENBSD_5_2:1.56.0.6
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.52.0.2
	OPENBSD_4_9_BASE:1.52
	OPENBSD_4_8:1.49.0.4
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.47.0.6
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.2
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.46.0.2
	OPENBSD_4_4_BASE:1.46
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.38.0.2
	OPENBSD_4_1_BASE:1.38
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.32.0.4
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.29.0.2
	OPENBSD_3_5_BASE:1.29
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.23
	UBC:1.19.0.2
	UBC_BASE:1.19
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.6
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.4
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.2
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.11.0.2
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.5.0.4
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.76
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.75;
commitid	wHLNY5GFNXJSFYaC;

1.75
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.74;
commitid	gAjwyca5TfuoJAhn;

1.74
date	2016.01.19.19.11.21;	author stefan;	state Exp;
branches;
next	1.73;
commitid	xfvbhOW8ogeEssuU;

1.73
date	2015.12.11.11.25.55;	author tedu;	state Exp;
branches;
next	1.72;
commitid	QrjGowDy41Q7RbpM;

1.72
date	2015.04.17.04.43.20;	author guenther;	state Exp;
branches;
next	1.71;
commitid	zOwbm07fp3gPB2qr;

1.71
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.70;
commitid	p4LJxGKbi0BU2cG6;

1.70
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.69;
commitid	C5iGb36LQxjM60Q3;

1.69
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.68;
commitid	P6Av4XGqOi3rFasL;

1.68
date	2014.11.03.21.28.35;	author tedu;	state Exp;
branches;
next	1.67;
commitid	EkuwmBeHv2Tqmdnx;

1.67
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.66;
commitid	uzzBR7hz9ncd4O6G;

1.66
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.65;
commitid	C8XZQyreqTUCeixA;

1.65
date	2014.05.09.03.54.28;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2013.12.14.02.57.25;	author guenther;	state Exp;
branches;
next	1.63;

1.63
date	2013.08.13.05.52.22;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2013.06.11.16.42.15;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2013.06.02.01.07.39;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.59;

1.59
date	2013.03.28.03.29.44;	author guenther;	state Exp;
branches;
next	1.58;

1.58
date	2013.03.28.02.08.39;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2012.09.26.04.32.40;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.09.16.51.08;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2011.04.05.14.14.07;	author thib;	state Exp;
branches;
next	1.52;

1.52
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.11.07.13.30;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2009.08.13.15.00.14;	author jasper;	state Exp;
branches;
next	1.47;

1.47
date	2009.01.13.19.44.20;	author grange;	state Exp;
branches;
next	1.46;

1.46
date	2008.06.09.23.38.37;	author millert;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.08.17.45.45;	author thib;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.29.13.02.19;	author chl;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.01.23.47.55;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.01.22.30.48;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2007.04.13.18.07.36;	author thib;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.21.17.29.31;	author thib;	state Exp;
branches;
next	1.38;

1.38
date	2007.01.16.17.52.18;	author thib;	state Exp;
branches;
next	1.37;

1.37
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.16.11.27.53;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.03.19.49.06;	author pedro;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.25.21.15.55;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.19.02.18.01;	author pedro;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.29.17.05.05;	author grange;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.17.05.04.17;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.14.04.00.34;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.14.21.15.33;	author tdeval;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.14.21.13.43;	author tdeval;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.07.23.01.24;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.08.04.34.17;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2002.05.24.13.41.27;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2002.05.23.14.35.20;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.19;

1.19
date	2001.12.10.18.49.51;	author art;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2001.12.10.04.45.31;	author art;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.10.02.19.34;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.04.22.44.31;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.02.14.23;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.23.14.42.38;	author csapuntz;	state Exp;
branches;
next	1.12;

1.12
date	99.11.13.03.48.09;	author angelos;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	99.07.01.02.20.22;	author d;	state Exp;
branches;
next	1.10;

1.10
date	98.08.06.19.34.22;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	97.11.08.17.21.08;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.11.06.05.58.12;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	97.10.06.20.19.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.10.06.15.08.46;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.26.38;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.19.16.08.43;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.29.10.12.28;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.04.25.00;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.12.2.1
date	2001.05.14.22.32.37;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2001.07.04.10.48.09;	author niklas;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.12.2.4;

1.12.2.4
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.12.2.5;

1.12.2.5
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.12.2.6;

1.12.2.6
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.12.2.7;

1.12.2.7
date	2003.05.13.19.21.27;	author ho;	state Exp;
branches;
next	1.12.2.8;

1.12.2.8
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.12.2.9;

1.12.2.9
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.12.2.10;

1.12.2.10
date	2004.02.19.10.56.36;	author niklas;	state Exp;
branches;
next	1.12.2.11;

1.12.2.11
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.19.2.1
date	2002.02.02.03.28.25;	author art;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2002.06.11.03.29.20;	author art;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2002.11.04.18.02.31;	author art;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2003.05.19.21.53.27;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.76
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@/*	$OpenBSD: cd9660_vnops.c,v 1.75 2016/03/19 12:04:15 natano Exp $	*/
/*	$NetBSD: cd9660_vnops.c,v 1.42 1997/10/16 23:56:57 christos Exp $	*/

/*-
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cd9660_vnops.c	8.15 (Berkeley) 12/5/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/resourcevar.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/mount.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/dirent.h>
#include <sys/ioctl.h>
#include <sys/ioccom.h>
#include <sys/poll.h>
#include <sys/specdev.h>
#include <sys/unistd.h>

#include <miscfs/fifofs/fifo.h>

#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/cd9660_node.h>
#include <isofs/cd9660/iso_rrip.h>

int cd9660_kqfilter(void *v);


/*
 * Structure for reading directories
 */
struct isoreaddir {
	struct dirent saveent;
	struct dirent assocent;
	struct dirent current;
	off_t saveoff;
	off_t assocoff;
	off_t curroff;
	struct uio *uio;
	off_t uio_off;
	int eofflag;
};

int	iso_uiodir(struct isoreaddir *, struct dirent *, off_t);
int	iso_shipdir(struct isoreaddir *);

/*
 * Setattr call. Only allowed for block and character special devices.
 */
int
cd9660_setattr(void *v)
{
	struct vop_setattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct vattr *vap = ap->a_vap;

	if (vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_nsec != VNOVAL ||
	    vap->va_mtime.tv_nsec != VNOVAL || vap->va_mode != (mode_t)VNOVAL ||
	    (vap->va_vaflags & VA_UTIMES_CHANGE))
		return (EROFS);
	if (vap->va_size != VNOVAL) {
		switch (vp->v_type) {
		case VDIR:
			return (EISDIR);
		case VLNK:
		case VREG:
			return (EROFS);
		case VCHR:
		case VBLK:
		case VSOCK:
		case VFIFO:
			return (0);
		default:
			return (EINVAL);
		}
	}

	return (EINVAL);
}

/*
 * Open called.
 *
 * Nothing to do.
 */
/* ARGSUSED */
int
cd9660_open(void *v)
{
	return (0);
}

/*
 * Close called
 *
 * Update the times on the inode on writeable file systems.
 */
/* ARGSUSED */
int
cd9660_close(void *v)
{
	return (0);
}

/*
 * Check mode permission on inode pointer. Mode is READ, WRITE or EXEC.
 * The mode is shifted to select the owner/group/other fields. The
 * super user is granted all permissions.
 */
int
cd9660_access(void *v)
{
	struct vop_access_args *ap = v;
	struct iso_node *ip = VTOI(ap->a_vp);

	return (vaccess(ap->a_vp->v_type, ip->inode.iso_mode & ALLPERMS,
	    ip->inode.iso_uid, ip->inode.iso_gid, ap->a_mode, ap->a_cred));
}

int
cd9660_getattr(void *v)
{
	struct vop_getattr_args *ap = v;
	struct vnode *vp = ap->a_vp;
	register struct vattr *vap = ap->a_vap;
	register struct iso_node *ip = VTOI(vp);

	vap->va_fsid	= ip->i_dev;
	vap->va_fileid	= ip->i_number;

	vap->va_mode	= ip->inode.iso_mode & ALLPERMS;
	vap->va_nlink	= ip->inode.iso_links;
	vap->va_uid	= ip->inode.iso_uid;
	vap->va_gid	= ip->inode.iso_gid;
	vap->va_atime	= ip->inode.iso_atime;
	vap->va_mtime	= ip->inode.iso_mtime;
	vap->va_ctime	= ip->inode.iso_ctime;
	vap->va_rdev	= ip->inode.iso_rdev;

	vap->va_size	= (u_quad_t) ip->i_size;
	if (ip->i_size == 0 && vp->v_type  == VLNK) {
		struct vop_readlink_args rdlnk;
		struct iovec aiov;
		struct uio auio;
		char *cp;

		cp = malloc(MAXPATHLEN, M_TEMP, M_WAITOK);
		aiov.iov_base = cp;
		aiov.iov_len = MAXPATHLEN;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_offset = 0;
		auio.uio_rw = UIO_READ;
		auio.uio_segflg = UIO_SYSSPACE;
		auio.uio_procp = ap->a_p;
		auio.uio_resid = MAXPATHLEN;
		rdlnk.a_uio = &auio;
		rdlnk.a_vp = ap->a_vp;
		rdlnk.a_cred = ap->a_cred;
		if (cd9660_readlink(&rdlnk) == 0)
			vap->va_size = MAXPATHLEN - auio.uio_resid;
		free(cp, M_TEMP, 0);
	}
	vap->va_flags	= 0;
	vap->va_gen = 1;
	vap->va_blocksize = ip->i_mnt->logical_block_size;
	vap->va_bytes	= (u_quad_t) ip->i_size;
	vap->va_type	= vp->v_type;
	return (0);
}

/*
 * Vnode op for reading.
 */
int
cd9660_read(void *v)
{
	struct vop_read_args *ap = v;
	struct vnode *vp = ap->a_vp;
	register struct uio *uio = ap->a_uio;
	register struct iso_node *ip = VTOI(vp);
	register struct iso_mnt *imp;
	struct buf *bp;
	daddr_t lbn, rablock;
	off_t diff;
	int error = 0;
	long size, on;
	size_t n;

	if (uio->uio_resid == 0)
		return (0);
	if (uio->uio_offset < 0)
		return (EINVAL);
	ip->i_flag |= IN_ACCESS;
	imp = ip->i_mnt;
	do {
		struct cluster_info *ci = &ip->i_ci;

		lbn = lblkno(imp, uio->uio_offset);
		on = blkoff(imp, uio->uio_offset);
		n = ulmin(imp->logical_block_size - on, uio->uio_resid);
		diff = (off_t)ip->i_size - uio->uio_offset;
		if (diff <= 0)
			return (0);
		if (diff < n)
			n = diff;
		size = blksize(imp, ip, lbn);
		rablock = lbn + 1;
#define MAX_RA 32
		if (ci->ci_lastr + 1 == lbn) {
			struct ra {
				daddr_t blks[MAX_RA];
				int sizes[MAX_RA];
			} *ra;
			int i;

			ra = malloc(sizeof *ra, M_TEMP, M_WAITOK);
			for (i = 0; i < MAX_RA &&
			    lblktosize(imp, (rablock + i)) < ip->i_size;
			    i++) {
				ra->blks[i] = rablock + i;
				ra->sizes[i] = blksize(imp, ip, rablock + i);
			}
			error = breadn(vp, lbn, size, ra->blks,
			    ra->sizes, i, &bp);
			free(ra, M_TEMP, 0);
		} else
			error = bread(vp, lbn, size, &bp);
		ci->ci_lastr = lbn;
		n = ulmin(n, size - bp->b_resid);
		if (error) {
			brelse(bp);
			return (error);
		}

		error = uiomove(bp->b_data + on, n, uio);

		brelse(bp);
	} while (error == 0 && uio->uio_resid > 0 && n != 0);
	return (error);
}

/* ARGSUSED */
int
cd9660_ioctl(void *v)
{
	return (ENOTTY);
}

/* ARGSUSED */
int
cd9660_poll(void *v)
{
	struct vop_poll_args *ap = v;

	/*
	 * We should really check to see if I/O is possible.
	 */
	return (ap->a_events & (POLLIN | POLLOUT | POLLRDNORM | POLLWRNORM));
}

/*
 * Mmap a file
 *
 * NB Currently unsupported.
 */
/* ARGSUSED */
int
cd9660_mmap(void *v)
{

	return (EINVAL);
}

/*
 * Seek on a file
 *
 * Nothing to do, so just return.
 */
/* ARGSUSED */
int
cd9660_seek(void *v)
{
	return (0);
}

int
iso_uiodir(idp,dp,off)
	struct isoreaddir *idp;
	struct dirent *dp;
	off_t off;
{
	int error;

	dp->d_name[dp->d_namlen] = 0;
	dp->d_reclen = DIRENT_SIZE(dp);

	if (idp->uio->uio_resid < dp->d_reclen) {
		idp->eofflag = 0;
		return (-1);
	}

	dp->d_off = off;
	if ((error = uiomove(dp, dp->d_reclen, idp->uio)) != 0)
		return (error);
	idp->uio_off = off;
	return (0);
}

int
iso_shipdir(idp)
	struct isoreaddir *idp;
{
	struct dirent *dp;
	int cl, sl, assoc;
	int error;
	char *cname, *sname;

	cl = idp->current.d_namlen;
	cname = idp->current.d_name;

	if ((assoc = cl > 1 && *cname == ASSOCCHAR)) {
		cl--;
		cname++;
	}

	dp = &idp->saveent;
	sname = dp->d_name;
	if (!(sl = dp->d_namlen)) {
		dp = &idp->assocent;
		sname = dp->d_name + 1;
		sl = dp->d_namlen - 1;
	}
	if (sl > 0) {
		if (sl != cl
		    || bcmp(sname,cname,sl)) {
			if (idp->assocent.d_namlen) {
				error = iso_uiodir(idp, &idp->assocent,
						   idp->assocoff);
				if (error)
					return (error);
				idp->assocent.d_namlen = 0;
			}
			if (idp->saveent.d_namlen) {
				error = iso_uiodir(idp, &idp->saveent,
						   idp->saveoff);
				if (error)
					return (error);
				idp->saveent.d_namlen = 0;
			}
		}
	}
	idp->current.d_reclen = DIRENT_SIZE(&idp->current);
	if (assoc) {
		idp->assocoff = idp->curroff;
		bcopy(&idp->current,&idp->assocent,idp->current.d_reclen);
	} else {
		idp->saveoff = idp->curroff;
		bcopy(&idp->current,&idp->saveent,idp->current.d_reclen);
	}
	return (0);
}

/*
 * Vnode op for readdir
 */
int
cd9660_readdir(void *v)
{
	struct vop_readdir_args *ap = v;
	register struct uio *uio = ap->a_uio;
	struct isoreaddir *idp;
	struct vnode *vdp = ap->a_vp;
	struct iso_node *dp;
	struct iso_mnt *imp;
	struct buf *bp = NULL;
	struct iso_directory_record *ep;
	int entryoffsetinblock;
	doff_t endsearch;
	u_long bmask;
	int error = 0;
	int reclen;
	u_short namelen;
	cdino_t ino;

	dp = VTOI(vdp);
	imp = dp->i_mnt;
	bmask = imp->im_bmask;

	idp = malloc(sizeof(*idp), M_TEMP, M_WAITOK);

	/*
	 * These are passed to copyout(), so make sure there's no garbage
	 * being leaked in padding or after short names.
	 */
	memset(&idp->saveent, 0, sizeof(idp->saveent));
	memset(&idp->assocent, 0, sizeof(idp->assocent));
	memset(&idp->current, 0, sizeof(idp->current));

	/*
	 * XXX
	 * Is it worth trying to figure out the type?
	 */
	idp->saveent.d_type = idp->assocent.d_type = idp->current.d_type =
	    DT_UNKNOWN;
	idp->uio = uio;
	idp->eofflag = 1;
	idp->curroff = uio->uio_offset;
	idp->uio_off = uio->uio_offset;

	if ((entryoffsetinblock = idp->curroff & bmask) &&
	    (error = cd9660_bufatoff(dp, (off_t)idp->curroff, NULL, &bp))) {
		free(idp, M_TEMP, 0);
		return (error);
	}
	endsearch = dp->i_size;

	while (idp->curroff < endsearch) {
		/*
		 * If offset is on a block boundary,
		 * read the next directory block.
		 * Release previous if it exists.
		 */
		if ((idp->curroff & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);
			error = cd9660_bufatoff(dp, (off_t)idp->curroff,
					     NULL, &bp);
			if (error)
				break;
			entryoffsetinblock = 0;
		}
		/*
		 * Get pointer to next entry.
		 */
		ep = (struct iso_directory_record *)
			((char *)bp->b_data + entryoffsetinblock);

		reclen = isonum_711(ep->length);
		if (reclen == 0) {
			/* skip to next block, if any */
			idp->curroff =
			    (idp->curroff & ~bmask) + imp->logical_block_size;
			continue;
		}

		if (reclen < ISO_DIRECTORY_RECORD_SIZE) {
			error = EINVAL;
			/* illegal entry, stop */
			break;
		}

		if (entryoffsetinblock + reclen > imp->logical_block_size) {
			error = EINVAL;
			/* illegal directory, so stop looking */
			break;
		}

		idp->current.d_namlen = isonum_711(ep->name_len);

		if (reclen < ISO_DIRECTORY_RECORD_SIZE + idp->current.d_namlen) {
			error = EINVAL;
			/* illegal entry, stop */
			break;
		}

		if (isonum_711(ep->flags)&2)
			ino = isodirino(ep, imp);
		else
			ino = dbtob(bp->b_blkno) + entryoffsetinblock;

		idp->curroff += reclen;

		switch (imp->iso_ftype) {
		case ISO_FTYPE_RRIP:
			cd9660_rrip_getname(ep,idp->current.d_name, &namelen,
					   &ino, imp);
			idp->current.d_fileno = ino;
			idp->current.d_namlen = (u_char)namelen;
			if (idp->current.d_namlen)
				error = iso_uiodir(idp,&idp->current,idp->curroff);
			break;
		default:	/* ISO_FTYPE_DEFAULT || ISO_FTYPE_9660 */
			idp->current.d_fileno = ino;
			strlcpy(idp->current.d_name,"..",
			    sizeof idp->current.d_name);
			if (idp->current.d_namlen == 1 && ep->name[0] == 0) {
				idp->current.d_namlen = 1;
				error = iso_uiodir(idp,&idp->current,idp->curroff);
			} else if (idp->current.d_namlen == 1 && 
			    ep->name[0] == 1) {
				idp->current.d_namlen = 2;
				error = iso_uiodir(idp,&idp->current,idp->curroff);
			} else {
				isofntrans(ep->name,idp->current.d_namlen,
					   idp->current.d_name, &namelen,
					   imp->iso_ftype == ISO_FTYPE_9660,
					   isonum_711(ep->flags) & 4,
					   imp->joliet_level);
				idp->current.d_namlen = (u_char)namelen;
				if (imp->iso_ftype == ISO_FTYPE_DEFAULT)
					error = iso_shipdir(idp);
				else
					error = iso_uiodir(idp,&idp->current,idp->curroff);
			}
		}
		if (error)
			break;

		entryoffsetinblock += reclen;
	}

	if (!error && imp->iso_ftype == ISO_FTYPE_DEFAULT) {
		idp->current.d_namlen = 0;
		error = iso_shipdir(idp);
	}
	if (error < 0)
		error = 0;

	if (bp)
		brelse (bp);

	uio->uio_offset = idp->uio_off;
	*ap->a_eofflag = idp->eofflag;

	free(idp, M_TEMP, 0);

	return (error);
}

/*
 * Return target name of a symbolic link
 * Shouldn't we get the parent vnode and read the data from there?
 * This could eventually result in deadlocks in cd9660_lookup.
 * But otherwise the block read here is in the block buffer two times.
 */
typedef struct iso_directory_record ISODIR;
typedef struct iso_node             ISONODE;
typedef struct iso_mnt              ISOMNT;
int
cd9660_readlink(void *v)
{
	struct vop_readlink_args *ap = v;
	ISONODE	*ip;
	ISODIR	*dirp;
	ISOMNT	*imp;
	struct	buf *bp;
	struct	uio *uio;
	u_short	symlen;
	int	error;
	char	*symname;

	ip  = VTOI(ap->a_vp);
	imp = ip->i_mnt;
	uio = ap->a_uio;

	if (imp->iso_ftype != ISO_FTYPE_RRIP)
		return (EINVAL);

	/*
	 * Get parents directory record block that this inode included.
	 */
	error = bread(imp->im_devvp,
		      (ip->i_number >> imp->im_bshift) <<
		      (imp->im_bshift - DEV_BSHIFT),
		      imp->logical_block_size, &bp);
	if (error) {
		brelse(bp);
		return (EINVAL);
	}

	/*
	 * Setup the directory pointer for this inode
	 */
	dirp = (ISODIR *)(bp->b_data + (ip->i_number & imp->im_bmask));

	/*
	 * Just make sure, we have a right one....
	 *   1: Check not cross boundary on block
	 */
	if ((ip->i_number & imp->im_bmask) + isonum_711(dirp->length)
	    > imp->logical_block_size) {
		brelse(bp);
		return (EINVAL);
	}

	/*
	 * Now get a buffer
	 * Abuse a namei buffer for now.
	 */
	if (uio->uio_segflg == UIO_SYSSPACE &&
	    uio->uio_iov->iov_len >= MAXPATHLEN)
		symname = uio->uio_iov->iov_base;
	else
		symname = pool_get(&namei_pool, PR_WAITOK);
	
	/*
	 * Ok, we just gathering a symbolic name in SL record.
	 */
	if (cd9660_rrip_getsymname(dirp, symname, &symlen, imp) == 0) {
		if (uio->uio_segflg != UIO_SYSSPACE ||
		    uio->uio_iov->iov_len < MAXPATHLEN)
			pool_put(&namei_pool, symname);
		brelse(bp);
		return (EINVAL);
	}
	/*
	 * Don't forget before you leave from home ;-)
	 */
	brelse(bp);

	/*
	 * return with the symbolic name to caller's.
	 */
	if (uio->uio_segflg != UIO_SYSSPACE ||
	    uio->uio_iov->iov_len < MAXPATHLEN) {
		error = uiomove(symname, symlen, uio);
		pool_put(&namei_pool, symname);
		return (error);
	}
	uio->uio_resid -= symlen;
	uio->uio_iov->iov_base = (char *)uio->uio_iov->iov_base + symlen;
	uio->uio_iov->iov_len -= symlen;
	return (0);
}

int
cd9660_link(void *v)
{
	struct vop_link_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

int
cd9660_symlink(void *v)
{
	struct vop_symlink_args *ap = v;

	VOP_ABORTOP(ap->a_dvp, ap->a_cnp);
	vput(ap->a_dvp);
	return (EROFS);
}

/*
 * Lock an inode.
 */
int
cd9660_lock(void *v)
{
	struct vop_lock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	return rrw_enter(&VTOI(vp)->i_lock, ap->a_flags & LK_RWFLAGS);
}

/*
 * Unlock an inode.
 */
int
cd9660_unlock(void *v)
{
	struct vop_unlock_args *ap = v;
	struct vnode *vp = ap->a_vp;

	rrw_exit(&VTOI(vp)->i_lock);
	return 0;
}

/*
 * Calculate the logical to physical mapping if not done already,
 * then call the device strategy routine.
 */
int
cd9660_strategy(void *v)
{
	struct vop_strategy_args *ap = v;
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct iso_node *ip;
	int error;
	int s;

	ip = VTOI(vp);
	if (vp->v_type == VBLK || vp->v_type == VCHR)
		panic("cd9660_strategy: spec");
	if (bp->b_blkno == bp->b_lblkno) {
		error = VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL);
		if (error) {
			bp->b_error = error;
			bp->b_flags |= B_ERROR;
			s = splbio();
			biodone(bp);
			splx(s);
			return (error);
		}
		if ((long)bp->b_blkno == -1)
			clrbuf(bp);
	}
	if ((long)bp->b_blkno == -1) {
		s = splbio();
		biodone(bp);
		splx(s);
		return (0);
	}
	vp = ip->i_devvp;
	bp->b_dev = vp->v_rdev;
	(vp->v_op->vop_strategy)(ap);
	return (0);
}

/*
 * Print out the contents of an inode.
 */
/*ARGSUSED*/
int
cd9660_print(void *v)
{
	printf("tag VT_ISOFS, isofs vnode\n");
	return (0);
}

/*
 * Check for a locked inode.
 */
int
cd9660_islocked(void *v)
{
	struct vop_islocked_args *ap = v;

	return rrw_status(&VTOI(ap->a_vp)->i_lock);
}

/*
 * Return POSIX pathconf information applicable to cd9660 filesystems.
 */
int
cd9660_pathconf(void *v)
{
	struct vop_pathconf_args *ap = v;
	int error = 0;

	switch (ap->a_name) {
	case _PC_LINK_MAX:
		*ap->a_retval = 1;
		break;
	case _PC_NAME_MAX:
		if (VTOI(ap->a_vp)->i_mnt->iso_ftype == ISO_FTYPE_RRIP)
			*ap->a_retval = NAME_MAX;
		else
			*ap->a_retval = 37;
		break;
	case _PC_CHOWN_RESTRICTED:
		*ap->a_retval = 1;
		break;
	case _PC_NO_TRUNC:
		*ap->a_retval = 1;
		break;
	case _PC_TIMESTAMP_RESOLUTION:
		*ap->a_retval = 1000000000;	/* one billion nanoseconds */
		break;
	default:
		error = EINVAL;
		break;
	}

	return (error);
}

/*
 * Global vfs data structures for isofs
 */
#define	cd9660_create	eopnotsupp
#define	cd9660_mknod	eopnotsupp
#define	cd9660_write	eopnotsupp
#define	cd9660_fsync	nullop
#define	cd9660_remove	eopnotsupp
#define	cd9660_rename	eopnotsupp
#define	cd9660_mkdir	eopnotsupp
#define	cd9660_rmdir	eopnotsupp
#define	cd9660_advlock	eopnotsupp
#define	cd9660_valloc	eopnotsupp
#define	cd9660_vfree	eopnotsupp
#define	cd9660_truncate	eopnotsupp
#define	cd9660_update	eopnotsupp
#define	cd9660_bwrite	eopnotsupp
#define cd9660_revoke   vop_generic_revoke

/* Global vfs data structures for cd9660. */
struct vops cd9660_vops = {
	.vop_lookup	= cd9660_lookup,
	.vop_create	= cd9660_create,
	.vop_mknod	= cd9660_mknod,
	.vop_open	= cd9660_open,
	.vop_close	= cd9660_close,
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_read	= cd9660_read,
	.vop_write	= cd9660_write,
	.vop_ioctl	= cd9660_ioctl,
	.vop_poll	= cd9660_poll,
	.vop_kqfilter	= cd9660_kqfilter,
	.vop_revoke	= cd9660_revoke,
	.vop_fsync	= cd9660_fsync,
	.vop_remove	= cd9660_remove,
	.vop_link	= cd9660_link,
	.vop_rename	= cd9660_rename,
	.vop_mkdir	= cd9660_mkdir,
	.vop_rmdir	= cd9660_rmdir,
	.vop_symlink	= cd9660_symlink,
	.vop_readdir	= cd9660_readdir,
	.vop_readlink	= cd9660_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_bmap	= cd9660_bmap,
	.vop_strategy	= cd9660_strategy,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,
	.vop_pathconf	= cd9660_pathconf,
	.vop_advlock	= cd9660_advlock,
	.vop_bwrite	= vop_generic_bwrite
};

/* Special device vnode ops */
struct vops cd9660_specvops = {
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,

	/* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_close	= spec_close,
	.vop_read	= spec_read,
	.vop_write	= spec_write,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= spec_fsync,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
};

#ifdef FIFO
struct vops cd9660_fifovops = {
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,
	.vop_bwrite	= vop_generic_bwrite,

	/* XXX: Keep in sync with fifo_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_close	= fifo_close,
	.vop_read	= fifo_read,
	.vop_write	= fifo_write,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= nullop,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
};
#endif /* FIFO */

void filt_cd9660detach(struct knote *kn);
int filt_cd9660read(struct knote *kn, long hint);
int filt_cd9660write(struct knote *kn, long hint);
int filt_cd9660vnode(struct knote *kn, long hint);

struct filterops cd9660read_filtops = 
	{ 1, NULL, filt_cd9660detach, filt_cd9660read };
struct filterops cd9660write_filtops = 
	{ 1, NULL, filt_cd9660detach, filt_cd9660write };
struct filterops cd9660vnode_filtops = 
	{ 1, NULL, filt_cd9660detach, filt_cd9660vnode };

int
cd9660_kqfilter(void *v)
{
	struct vop_kqfilter_args *ap = v;
	struct vnode *vp = ap->a_vp;
	struct knote *kn = ap->a_kn;

	switch (kn->kn_filter) {
	case EVFILT_READ:
		kn->kn_fop = &cd9660read_filtops;
		break;
	case EVFILT_WRITE:
		kn->kn_fop = &cd9660write_filtops;
		break;
	case EVFILT_VNODE:
		kn->kn_fop = &cd9660vnode_filtops;
		break;
	default:
		return (EINVAL);
	}

	kn->kn_hook = (caddr_t)vp;

	SLIST_INSERT_HEAD(&vp->v_selectinfo.si_note, kn, kn_selnext);

	return (0);
}

void
filt_cd9660detach(struct knote *kn)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;

	SLIST_REMOVE(&vp->v_selectinfo.si_note, kn, knote, kn_selnext);
}

int
filt_cd9660read(struct knote *kn, long hint)
{
	struct vnode *vp = (struct vnode *)kn->kn_hook;
	struct iso_node *node = VTOI(vp);

	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = node->i_size - kn->kn_fp->f_offset;
	if (kn->kn_data == 0 && kn->kn_sfflags & NOTE_EOF) {
		kn->kn_fflags |= NOTE_EOF;
		return (1);
	}

	return (kn->kn_data != 0);
}

int
filt_cd9660write(struct knote *kn, long hint)
{
	/*
	 * filesystem is gone, so set the EOF flag and schedule 
	 * the knote for deletion.
	 */
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= (EV_EOF | EV_ONESHOT);
		return (1);
	}

	kn->kn_data = 0;
	return (1);
}

int
filt_cd9660vnode(struct knote *kn, long hint)
{
	if (kn->kn_sfflags & hint)
		kn->kn_fflags |= hint;
	if (hint == NOTE_REVOKE) {
		kn->kn_flags |= EV_EOF;
		return (1);
	}
	return (kn->kn_fflags != 0);
}
@


1.75
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.74 2016/01/19 19:11:21 stefan Exp $	*/
d699 1
a699 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, NULL));
d711 2
a712 1
	return (lockmgr(&VTOI(vp)->i_lock, LK_RELEASE, NULL));
d776 1
a776 1
	return (lockstatus(&VTOI(ap->a_vp)->i_lock));
@


1.74
log
@Convert min() and uiomovei() to ulmin() and uiomove().

Diff from Martin Natano

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.73 2015/12/11 11:25:55 tedu Exp $	*/
d711 1
a711 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE, NULL));
@


1.73
log
@implement kqfilter. copied from tmpfs (which I copied from ufs).
hint about kqueue from jsg after a crashing httpd report from sevan
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.72 2015/04/17 04:43:20 guenther Exp $	*/
d230 2
a231 1
	long size, n, on;
d244 1
a244 2
		n = min((u_int)(imp->logical_block_size - on),
			uio->uio_resid);
d273 1
a273 1
		n = min(n, size - bp->b_resid);
d279 1
a279 1
		error = uiomovei(bp->b_data + on, (int)n, uio);
d347 1
a347 1
	if ((error = uiomovei((caddr_t)dp, dp->d_reclen, idp->uio)) != 0)
d660 1
a660 1
		error = uiomovei(symname, symlen, uio);
@


1.72
log
@Tweaks utimensat/futimens handling to always update ctime, even when both
atime and mtime are UTIME_OMIT (at least for ufs, tmpfs, and ext2fs), and
to correctly handle a timestamp of -1.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.71 2015/03/14 03:38:50 jsg Exp $	*/
d68 3
d847 1
d954 100
@


1.71
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.70 2015/02/10 21:56:09 miod Exp $	*/
d97 3
a99 2
	    vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
	    vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL)
@


1.70
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.69 2014/12/16 18:30:03 tedu Exp $	*/
a56 1
#include <sys/cdio.h>
@


1.69
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.68 2014/11/03 21:28:35 tedu Exp $	*/
d276 1
a276 1
		error = uiomove(bp->b_data + on, (int)n, uio);
d344 1
a344 1
	if ((error = uiomove((caddr_t)dp, dp->d_reclen, idp->uio)) != 0)
d657 1
a657 1
		error = uiomove(symname, symlen, uio);
@


1.68
log
@include sys/unistd.h where needed instead of indirect reliance. ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.67 2014/09/14 14:17:25 jsg Exp $	*/
d51 1
@


1.67
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.66 2014/07/12 18:50:00 tedu Exp $	*/
d59 1
@


1.66
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.65 2014/05/09 03:54:28 tedu Exp $	*/
a47 1
#include <sys/proc.h>
@


1.65
log
@stop using B_AGE, it was effectively retired some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.64 2013/12/14 02:57:25 guenther Exp $	*/
d201 1
a201 1
		free(cp, M_TEMP);
d265 1
a265 1
			free(ra, M_TEMP);
d452 1
a452 1
		free(idp, M_TEMP);
d565 1
a565 1
	free(idp, M_TEMP);
@


1.64
log
@Zero out dirent structures that will be copied out to avoid leaking garbage
in the padding or trailing name bytes.

ok beck@@ millert@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.63 2013/08/13 05:52:22 guenther Exp $	*/
a276 3
                if (n + on == imp->logical_block_size ||
		    uio->uio_offset == (off_t)ip->i_size)
			bp->b_flags |= B_AGE;
@


1.63
log
@Switch time_t, ino_t, clock_t, and struct kevent's ident and data
members to 64bit types.  Assign new syscall numbers for (almost
all) the syscalls that involve the affected types, including anything
with time_t, timeval, itimerval, timespec, rusage, dirent, stat,
or kevent arguments.  Add a d_off member to struct dirent and replace
getdirentries() with getdents(), thus immensely simplifying and
accelerating telldir/seekdir.  Build perl with -DBIG_TIME.

Bump the major on every single base library: the compat bits included
here are only good enough to make the transition; the T32 compat
option will be burned as soon as we've reached the new world are
are happy with the snapshots for all architectures.

DANGER: ABI incompatibility.  Updating to this kernel requires extra
work or you won't be able to login: install a snapshot instead.

Much assistance in fixing userland issues from deraadt@@ and tedu@@
and build assistance from todd@@ and otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.62 2013/06/11 16:42:15 deraadt Exp $	*/
d433 9
a441 1
	idp->saveent.d_namlen = idp->assocent.d_namlen = 0;
@


1.62
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.61 2013/06/02 01:07:39 deraadt Exp $	*/
a80 2
	u_long *cookies;
	int ncookies;
d345 1
a345 10
	if (idp->cookies) {
		if (idp->ncookies <= 0) {
			idp->eofflag = 0;
			return (-1);
		}

		*idp->cookies++ = off;
		--idp->ncookies;
	}

a425 2
	int  ncookies = 0;
	u_long *cookies = NULL;
a440 11
	if (ap->a_ncookies == NULL) {
		idp->cookies = NULL;
	} else {
               /*
                * Guess the number of cookies needed.
                */
               ncookies = uio->uio_resid / 16;
               cookies = malloc(ncookies * sizeof(u_long), M_TEMP, M_WAITOK);
               idp->cookies = cookies;
               idp->ncookies = ncookies;
	}
a553 12
	if (ap->a_ncookies != NULL) {
		if (error)
			free(cookies, M_TEMP);
		else {
			/*
			 * Work out the number of cookies actually used.
			 */
			*ap->a_ncookies = ncookies - idp->ncookies;
			*ap->a_cookies = cookies;
		}
	}
	
@


1.61
log
@Remove disabled ISODEVMAP support.  dev_t's on one system will not be
similar on another, so using that is crazy.
ok guenther krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.60 2013/05/30 17:35:01 guenther Exp $	*/
d225 1
a225 1
	daddr64_t lbn, rablock;
d253 1
a253 1
				daddr64_t blks[MAX_RA];
@


1.60
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.59 2013/03/28 03:29:44 guenther Exp $	*/
a86 57

#if 0
/*
 * Mknod vnode call
 *  Actually remap the device number
 */
int
cd9660_mknod(ndp, vap, cred, p)
	struct nameidata *ndp;
	struct ucred *cred;
	struct vattr *vap;
	struct proc *p;
{
#ifndef	ISODEVMAP
	pool_put(&namei_pool, ndp->ni_pnbuf);
	vput(ndp->ni_dvp);
	vput(ndp->ni_vp);
	return (EINVAL);
#else
	register struct vnode *vp;
	struct iso_node *ip;
	struct iso_dnode *dp;
	int error;

	vp = ndp->ni_vp;
	ip = VTOI(vp);

	if (ip->i_mnt->iso_ftype != ISO_FTYPE_RRIP
	    || vap->va_type != vp->v_type
	    || (vap->va_type != VCHR && vap->va_type != VBLK)) {
		pool_put(&namei_pool, ndp->ni_pnbuf);
		vput(ndp->ni_dvp);
		vput(ndp->ni_vp);
		return (EINVAL);
	}

	dp = iso_dmap(ip->i_dev,ip->i_number,1);
	if (ip->inode.iso_rdev == vap->va_rdev || vap->va_rdev == VNOVAL) {
		/* same as the unmapped one, delete the mapping */
		remque(dp);
		free(dp, M_CACHE);
	} else
		/* enter new mapping */
		dp->d_dev = vap->va_rdev;

	/*
	 * Remove inode so that it will be reloaded by iget and
	 * checked to see if it is an alias of an existing entry
	 * in the inode cache.
	 */
	vput(vp);
	vp->v_type = VNON;
	vgone(vp);
	return (0);
#endif
}
#endif
@


1.59
log
@Add support for _PC_TIMESTAMP_RESOLUTION for ffs/mfs, cd9600, ext2,
msdos, NFS, fifos and devices, plus support for querying it in
getconf(2) and the requisite pathconf(2) manpage blurb

ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.58 2013/03/28 02:08:39 guenther Exp $	*/
d496 1
d583 1
a583 1
			idp->current.d_fileno = isodirino(ep, imp);
d585 1
a585 2
			idp->current.d_fileno = dbtob(bp->b_blkno) +
				entryoffsetinblock;
d592 2
a593 1
					   &idp->current.d_fileno,imp);
d599 1
@


1.58
log
@Handle the pathconf _PC_PATH_MAX, _PC_PIPE_BUF, _PC_ASYNC_IO,
_PC_PRIO_IO, and _PC_SYNC_IO names in VOP_PATHCONF(), as they're
fs-independent for us.  Since we don't support latter three on any
fs, we can also define the related _POSIX_{ASYNC,PRIO,SYNC}_IO
symbols in <unistd.h> (via sys/unistd.h) with value -1.

Also, zap pointless tty-only values from procfs(!).

ok beck@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.57 2012/09/26 04:32:40 brad Exp $	*/
d884 3
@


1.57
log
@cleanup the pathconf function a bit. Same MD5.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.56 2011/07/09 16:51:08 matthew Exp $	*/
a877 6
		break;
	case _PC_PATH_MAX:
		*ap->a_retval = PATH_MAX;
		break;
	case _PC_PIPE_BUF:
		*ap->a_retval = PIPE_BUF;
@


1.56
log
@Switch to ANSI C function definitions.

ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.55 2011/07/04 20:35:35 deraadt Exp $	*/
d867 2
d872 1
a872 1
		return (0);
d878 1
a878 1
		return (0);
d881 1
a881 1
		return (0);
d884 1
a884 1
		return (0);
d887 1
a887 1
		return (0);
d890 1
a890 1
		return (0);
d892 2
a893 1
		return (EINVAL);
d895 2
a896 1
	/* NOTREACHED */
@


1.55
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.54 2011/07/04 04:30:41 tedu Exp $	*/
d149 1
a149 2
cd9660_setattr(v)
	void *v;
d186 1
a186 2
cd9660_open(v)
	void *v;
d198 1
a198 2
cd9660_close(v)
	void *v;
d209 1
a209 2
cd9660_access(v)
	void *v;
d219 1
a219 2
cd9660_getattr(v)
	void *v;
d274 1
a274 2
cd9660_read(v)
	void *v;
d346 1
a346 2
cd9660_ioctl(v)
	void *v;
d353 1
a353 2
cd9660_poll(v)
	void *v;
d370 1
a370 2
cd9660_mmap(v)
	void *v;
d383 1
a383 2
cd9660_seek(v)
	void *v;
d478 1
a478 2
cd9660_readdir(v)
	void *v;
d666 1
a666 2
cd9660_readlink(v)
	void *v;
d753 1
a753 2
cd9660_link(v)
	void *v;
d763 1
a763 2
cd9660_symlink(v)
	void *v;
d776 1
a776 2
cd9660_lock(v)
	void *v;
d788 1
a788 2
cd9660_unlock(v)
	void *v;
d801 1
a801 2
cd9660_strategy(v)
	void *v;
d843 1
a843 2
cd9660_print(v)
	void *v;
d853 1
a853 2
cd9660_islocked(v)
	void *v;
d864 1
a864 2
cd9660_pathconf(v)
	void *v;
@


1.54
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.53 2011/04/05 14:14:07 thib Exp $	*/
d59 1
a61 1
#include <miscfs/specfs/specdev.h>
@


1.53
log
@Every single vop_default is set to eopnotsupp, so retire it
and return EOPNOTSUPP directly from the VOP_* functions.

Filesystems should, at some point fill in every function
in the vop_default struct so we can get rid of the 'if'
statements in VOP_*.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.52 2010/12/21 20:14:43 thib Exp $	*/
d329 1
a329 1
			    ra->sizes, i, NOCRED, &bp);
d332 1
a332 1
			error = bread(vp, lbn, size, NOCRED, &bp);
d703 1
a703 1
		      imp->logical_block_size, NOCRED, &bp);
@


1.52
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.51 2010/09/10 16:34:08 thib Exp $	*/
a935 1
	.vop_default	= eopnotsupp,
a973 1
	.vop_default	= eopnotsupp,
a1014 1
	.vop_default	= eopnotsupp,
@


1.51
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.50 2010/09/06 23:44:10 thib Exp $	*/
d851 1
a851 1
	VOCALL (vp->v_op, VOFFSET(vop_strategy), ap);
d934 37
a970 41
/*
 * Global vfs data structures for cd9660
 */
int (**cd9660_vnodeop_p)(void *);
struct vnodeopv_entry_desc cd9660_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, cd9660_lookup },
	{ &vop_create_desc, cd9660_create },
	{ &vop_mknod_desc, cd9660_mknod },
	{ &vop_open_desc, cd9660_open },
	{ &vop_close_desc, cd9660_close },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_read_desc, cd9660_read },
	{ &vop_write_desc, cd9660_write },
	{ &vop_ioctl_desc, cd9660_ioctl },
	{ &vop_poll_desc, cd9660_poll },
	{ &vop_revoke_desc, cd9660_revoke },
	{ &vop_fsync_desc, cd9660_fsync },
	{ &vop_remove_desc, cd9660_remove },
	{ &vop_link_desc, cd9660_link },
	{ &vop_rename_desc, cd9660_rename },
	{ &vop_mkdir_desc, cd9660_mkdir },
	{ &vop_rmdir_desc, cd9660_rmdir },
	{ &vop_symlink_desc, cd9660_symlink },
	{ &vop_readdir_desc, cd9660_readdir },
	{ &vop_readlink_desc, cd9660_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_bmap_desc, cd9660_bmap },
	{ &vop_strategy_desc, cd9660_strategy },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ &vop_pathconf_desc, cd9660_pathconf },
	{ &vop_advlock_desc, cd9660_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a971 2
struct vnodeopv_desc cd9660_vnodeop_opv_desc =
	{ &cd9660_vnodeop_p, cd9660_vnodeop_entries };
d973 40
a1012 16
/*
 * Special device vnode ops
 */
int (**cd9660_specop_p)(void *);
struct vnodeopv_entry_desc cd9660_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ NULL, NULL }
a1013 2
struct vnodeopv_desc cd9660_specop_opv_desc =
	{ &cd9660_specop_p, cd9660_specop_entries };
d1016 39
a1054 14
int (**cd9660_fifoop_p)(void *);
struct vnodeopv_entry_desc cd9660_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1055 2
struct vnodeopv_desc cd9660_fifoop_opv_desc =
	{ &cd9660_fifoop_p, cd9660_fifoop_entries };
@


1.50
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.49 2010/01/11 07:13:30 krw Exp $	*/
d851 1
a851 1
	(vp->v_op->vop_strategy)(ap);
d934 41
a974 37
/* Global vfs data structures for cd9660. */
struct vops cd9660_vops = {
	.vop_default	= eopnotsupp,
	.vop_lookup	= cd9660_lookup,
	.vop_create	= cd9660_create,
	.vop_mknod	= cd9660_mknod,
	.vop_open	= cd9660_open,
	.vop_close	= cd9660_close,
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_read	= cd9660_read,
	.vop_write	= cd9660_write,
	.vop_ioctl	= cd9660_ioctl,
	.vop_poll	= cd9660_poll,
	.vop_revoke	= cd9660_revoke,
	.vop_fsync	= cd9660_fsync,
	.vop_remove	= cd9660_remove,
	.vop_link	= cd9660_link,
	.vop_rename	= cd9660_rename,
	.vop_mkdir	= cd9660_mkdir,
	.vop_rmdir	= cd9660_rmdir,
	.vop_symlink	= cd9660_symlink,
	.vop_readdir	= cd9660_readdir,
	.vop_readlink	= cd9660_readlink,
	.vop_abortop	= vop_generic_abortop,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_bmap	= cd9660_bmap,
	.vop_strategy	= cd9660_strategy,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,
	.vop_pathconf	= cd9660_pathconf,
	.vop_advlock	= cd9660_advlock,
	.vop_bwrite	= vop_generic_bwrite
d976 2
d979 16
a994 40
/* Special device vnode ops */
struct vops cd9660_specvops = {
	.vop_default	= eopnotsupp,
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,

	/* XXX: Keep in sync with spec_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= spec_badop,
	.vop_mknod	= spec_badop,
	.vop_open	= spec_open,
	.vop_close	= spec_close,
	.vop_read	= spec_read,
	.vop_write	= spec_write,
	.vop_ioctl	= spec_ioctl,
	.vop_poll	= spec_poll,
	.vop_kqfilter	= spec_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= spec_fsync,
	.vop_remove	= spec_badop,
	.vop_link	= spec_badop,
	.vop_rename	= spec_badop,
	.vop_mkdir	= spec_badop,
	.vop_rmdir	= spec_badop,
	.vop_symlink	= spec_badop,
	.vop_readdir	= spec_badop,
	.vop_readlink	= spec_badop,
	.vop_abortop	= spec_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= spec_strategy,
	.vop_pathconf	= spec_pathconf,
	.vop_advlock	= spec_advlock,
	.vop_bwrite	= vop_generic_bwrite,
d996 2
d1000 14
a1013 39
struct vops cd9660_fifovops = {
	.vop_default	= eopnotsupp,
	.vop_access	= cd9660_access,
	.vop_getattr	= cd9660_getattr,
	.vop_setattr	= cd9660_setattr,
	.vop_inactive	= cd9660_inactive,
	.vop_reclaim	= cd9660_reclaim,
	.vop_lock	= cd9660_lock,
	.vop_unlock	= cd9660_unlock,
	.vop_print	= cd9660_print,
	.vop_islocked	= cd9660_islocked,
	.vop_bwrite	= vop_generic_bwrite,

	/* XXX: Keep in sync with fifo_vops. */
	.vop_lookup	= vop_generic_lookup,
	.vop_create	= fifo_badop,
	.vop_mknod	= fifo_badop,
	.vop_open	= fifo_open,
	.vop_close	= fifo_close,
	.vop_read	= fifo_read,
	.vop_write	= fifo_write,
	.vop_ioctl	= fifo_ioctl,
	.vop_poll	= fifo_poll,
	.vop_kqfilter	= fifo_kqfilter,
	.vop_revoke	= vop_generic_revoke,
	.vop_fsync	= nullop,
	.vop_remove	= fifo_badop,
	.vop_link	= fifo_badop,
	.vop_rename	= fifo_badop,
	.vop_mkdir	= fifo_badop,
	.vop_rmdir	= fifo_badop,
	.vop_symlink	= fifo_badop,
	.vop_readdir	= fifo_badop,
	.vop_readlink	= fifo_badop,
	.vop_abortop	= fifo_badop,
	.vop_bmap	= vop_generic_bmap,
	.vop_strategy	= fifo_badop,
	.vop_pathconf	= fifo_pathconf,
	.vop_advlock	= fifo_advlock,
d1015 2
@


1.49
log
@Pull in fix from kif via FreeBSD r1.114 to properly initialize
uio_off. Prevents crap being passed as the starting offset to
getdirentries(), which could lead to various kinds of confusion
when trying to process cd9660 directory entries.

Problem seen by jsg@@, who also found the fix in FreeBSD.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.48 2009/08/13 15:00:14 jasper Exp $	*/
d851 1
a851 1
	VOCALL (vp->v_op, VOFFSET(vop_strategy), ap);
d934 37
a970 41
/*
 * Global vfs data structures for cd9660
 */
int (**cd9660_vnodeop_p)(void *);
struct vnodeopv_entry_desc cd9660_vnodeop_entries[] = {
	{ &vop_default_desc, eopnotsupp },
	{ &vop_lookup_desc, cd9660_lookup },
	{ &vop_create_desc, cd9660_create },
	{ &vop_mknod_desc, cd9660_mknod },
	{ &vop_open_desc, cd9660_open },
	{ &vop_close_desc, cd9660_close },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_read_desc, cd9660_read },
	{ &vop_write_desc, cd9660_write },
	{ &vop_ioctl_desc, cd9660_ioctl },
	{ &vop_poll_desc, cd9660_poll },
	{ &vop_revoke_desc, cd9660_revoke },
	{ &vop_fsync_desc, cd9660_fsync },
	{ &vop_remove_desc, cd9660_remove },
	{ &vop_link_desc, cd9660_link },
	{ &vop_rename_desc, cd9660_rename },
	{ &vop_mkdir_desc, cd9660_mkdir },
	{ &vop_rmdir_desc, cd9660_rmdir },
	{ &vop_symlink_desc, cd9660_symlink },
	{ &vop_readdir_desc, cd9660_readdir },
	{ &vop_readlink_desc, cd9660_readlink },
	{ &vop_abortop_desc, vop_generic_abortop },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_bmap_desc, cd9660_bmap },
	{ &vop_strategy_desc, cd9660_strategy },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ &vop_pathconf_desc, cd9660_pathconf },
	{ &vop_advlock_desc, cd9660_advlock },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a971 2
struct vnodeopv_desc cd9660_vnodeop_opv_desc =
	{ &cd9660_vnodeop_p, cd9660_vnodeop_entries };
d973 40
a1012 16
/*
 * Special device vnode ops
 */
int (**cd9660_specop_p)(void *);
struct vnodeopv_entry_desc cd9660_specop_entries[] = {
	{ &vop_default_desc, spec_vnoperate },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ NULL, NULL }
a1013 2
struct vnodeopv_desc cd9660_specop_opv_desc =
	{ &cd9660_specop_p, cd9660_specop_entries };
d1016 39
a1054 14
int (**cd9660_fifoop_p)(void *);
struct vnodeopv_entry_desc cd9660_fifoop_entries[] = {
	{ &vop_default_desc, fifo_vnoperate },
	{ &vop_access_desc, cd9660_access },
	{ &vop_getattr_desc, cd9660_getattr },
	{ &vop_setattr_desc, cd9660_setattr },
	{ &vop_inactive_desc, cd9660_inactive },
	{ &vop_reclaim_desc, cd9660_reclaim },
	{ &vop_lock_desc, cd9660_lock },
	{ &vop_unlock_desc, cd9660_unlock },
	{ &vop_print_desc, cd9660_print },
	{ &vop_islocked_desc, cd9660_islocked },
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ NULL, NULL }
a1055 2
struct vnodeopv_desc cd9660_fifoop_opv_desc =
	{ &cd9660_fifoop_p, cd9660_fifoop_entries };
@


1.48
log
@- remove super-obvious comments from $fs_vnodeop_entries[]

prodded by and ok thib@@
agreed by art@@ and blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.47 2009/01/13 19:44:20 grange Exp $	*/
d534 1
@


1.47
log
@Trivial lvalue abuse fixes, no binary changes.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.46 2008/06/09 23:38:37 millert Exp $	*/
d939 33
a971 33
	{ &vop_lookup_desc, cd9660_lookup },	/* lookup */
	{ &vop_create_desc, cd9660_create },	/* create */
	{ &vop_mknod_desc, cd9660_mknod },	/* mknod */
	{ &vop_open_desc, cd9660_open },	/* open */
	{ &vop_close_desc, cd9660_close },	/* close */
	{ &vop_access_desc, cd9660_access },	/* access */
	{ &vop_getattr_desc, cd9660_getattr },	/* getattr */
	{ &vop_setattr_desc, cd9660_setattr },	/* setattr */
	{ &vop_read_desc, cd9660_read },	/* read */
	{ &vop_write_desc, cd9660_write },	/* write */
	{ &vop_ioctl_desc, cd9660_ioctl },	/* ioctl */
	{ &vop_poll_desc, cd9660_poll },	/* poll */
	{ &vop_revoke_desc, cd9660_revoke },    /* revoke */
	{ &vop_fsync_desc, cd9660_fsync },	/* fsync */
	{ &vop_remove_desc, cd9660_remove },	/* remove */
	{ &vop_link_desc, cd9660_link },	/* link */
	{ &vop_rename_desc, cd9660_rename },	/* rename */
	{ &vop_mkdir_desc, cd9660_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, cd9660_rmdir },	/* rmdir */
	{ &vop_symlink_desc, cd9660_symlink },	/* symlink */
	{ &vop_readdir_desc, cd9660_readdir },	/* readdir */
	{ &vop_readlink_desc, cd9660_readlink },/* readlink */
	{ &vop_abortop_desc, vop_generic_abortop },	/* abortop */
	{ &vop_inactive_desc, cd9660_inactive },/* inactive */
	{ &vop_reclaim_desc, cd9660_reclaim },	/* reclaim */
	{ &vop_lock_desc, cd9660_lock },	/* lock */
	{ &vop_unlock_desc, cd9660_unlock },	/* unlock */
	{ &vop_bmap_desc, cd9660_bmap },	/* bmap */
	{ &vop_strategy_desc, cd9660_strategy },/* strategy */
	{ &vop_print_desc, cd9660_print },	/* print */
	{ &vop_islocked_desc, cd9660_islocked },/* islocked */
	{ &vop_pathconf_desc, cd9660_pathconf },/* pathconf */
	{ &vop_advlock_desc, cd9660_advlock },	/* advlock */
d984 9
a992 9
	{ &vop_access_desc, cd9660_access },	/* access */
	{ &vop_getattr_desc, cd9660_getattr },	/* getattr */
	{ &vop_setattr_desc, cd9660_setattr },	/* setattr */
	{ &vop_inactive_desc, cd9660_inactive },/* inactive */
	{ &vop_reclaim_desc, cd9660_reclaim },	/* reclaim */
	{ &vop_lock_desc, cd9660_lock },	/* lock */
	{ &vop_unlock_desc, cd9660_unlock },	/* unlock */
	{ &vop_print_desc, cd9660_print },	/* print */
	{ &vop_islocked_desc, cd9660_islocked },/* islocked */
d1002 9
a1010 9
	{ &vop_access_desc, cd9660_access },	/* access */
	{ &vop_getattr_desc, cd9660_getattr },	/* getattr */
	{ &vop_setattr_desc, cd9660_setattr },	/* setattr */
	{ &vop_inactive_desc, cd9660_inactive },/* inactive */
	{ &vop_reclaim_desc, cd9660_reclaim },	/* reclaim */
	{ &vop_lock_desc, cd9660_lock },	/* lock */
	{ &vop_unlock_desc, cd9660_unlock },	/* unlock */
	{ &vop_print_desc, cd9660_print },	/* print */
	{ &vop_islocked_desc, cd9660_islocked },/* islocked */
@


1.46
log
@Update access(2) to have modern semantics with respect to X_OK and
the superuser.  access(2) will now only indicate success for X_OK on
non-directories if there is at least one execute bit set on the file.
OK deraadt@@ thib@@ otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.45 2008/05/08 17:45:45 thib Exp $	*/
d758 1
a758 1
	(char *)uio->uio_iov->iov_base += symlen;
@


1.45
log
@retire vn_default_error() and replace all instances
with eopnotsupp() instead;

ok blambert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.44 2007/10/29 13:02:19 chl Exp $	*/
d218 2
a219 2
	return (vaccess(ip->inode.iso_mode & ALLPERMS, ip->inode.iso_uid,
	    ip->inode.iso_gid, ap->a_mode, ap->a_cred));
@


1.44
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.43 2007/06/06 17:15:13 deraadt Exp $	*/
d938 1
a938 1
	{ &vop_default_desc, vn_default_error },
@


1.43
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.42 2007/06/01 23:47:55 deraadt Exp $	*/
d127 1
a127 1
		FREE(dp, M_CACHE);
d250 1
a250 1
		MALLOC(cp, char *, MAXPATHLEN, M_TEMP, M_WAITOK);
d265 1
a265 1
		FREE(cp, M_TEMP);
d321 1
a321 2
			MALLOC(ra, struct ra *, sizeof *ra,
			    M_TEMP, M_WAITOK);
d330 1
a330 1
			FREE(ra, M_TEMP);
d512 1
a512 1
	MALLOC(idp, struct isoreaddir *, sizeof(*idp), M_TEMP, M_WAITOK);
d528 1
a528 2
               MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
                   M_WAITOK);
d537 1
a537 1
		FREE(idp, M_TEMP);
d661 1
a661 1
	FREE(idp, M_TEMP);
@


1.42
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.41 2007/06/01 22:30:48 deraadt Exp $	*/
d288 1
a288 1
	daddr_t lbn, rablock;
@


1.41
log
@FIBMAP is used by nothing; checked by miod and pvalchev
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.40 2007/04/13 18:07:36 thib Exp $	*/
d152 1
a152 7
	struct vop_setattr_args /* {
		struct vnodeop_desc *a_desc;
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d215 1
a215 6
	struct vop_access_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d226 1
a226 6
	struct vop_getattr_args /* {
		struct vnode *a_vp;
		struct vattr *a_vap;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
d282 1
a282 6
	struct vop_read_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		int a_ioflag;
		struct ucred *a_cred;
	} */ *ap = v;
d364 1
a364 5
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;
d492 1
a492 8
	struct vop_readdir_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
		int *a_eofflag;
		u_long *a_cookies;
		int a_ncookies;
	} */ *ap = v;
d681 1
a681 5
	struct vop_readlink_args /* {
		struct vnode *a_vp;
		struct uio *a_uio;
		struct ucred *a_cred;
	} */ *ap = v;
d769 1
a769 5
	struct vop_link_args /* {
		struct vnode *a_dvp;
		struct vnode *a_vp;
		struct componentname *a_cnp;
	} */ *ap = v;
d780 1
a780 7
	struct vop_symlink_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
		struct vattr *a_vap;
		char *a_target;
	} */ *ap = v;
d794 1
a794 3
	struct vop_lock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d807 1
a807 3
	struct vop_unlock_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d821 1
a821 3
	struct vop_strategy_args /* {
		struct buf *a_bp;
	} */ *ap = v;
d875 1
a875 3
	struct vop_islocked_args /* {
		struct vnode *a_vp;
	} */ *ap = v;
d887 1
a887 5
	struct vop_pathconf_args /* {
		struct vnode *a_vp;
		int a_name;
		register_t *a_retval;
	} */ *ap = v;
@


1.40
log
@Remove cluster reading from cd9660_read(); wich doesnt work.
From mickey@@; ok thib@@,miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.39 2007/03/21 17:29:31 thib Exp $	*/
d377 1
a377 21
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap = v;
	daddr32_t *blkp;
	daddr64_t blk;
	int error;

	switch (ap->a_command) {
	case FIBMAP:
		blkp = (daddr32_t *) ap->a_data;
		error = VOP_BMAP(ap->a_vp, *blkp, NULL, &blk, 0);
		*blkp = (daddr32_t) blk;
		return (error);
	default:
		return (ENOTTY);
	}
@


1.39
log
@Remove the v_interlock simplelock from the vnode structure.
Zap all calls to simple_lock/unlock() on it (those calls are
#defined away though). Remove the LK_INTERLOCK from the calls
to vn_lock() and cleanup the filesystems wich implement VOP_LOCK().
(by remvoing the v_interlock from there calls to lockmgr()).

ok pedro@@, art@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.38 2007/01/16 17:52:18 thib Exp $	*/
a290 10
#ifdef DEBUG
extern int doclusterread;
#else
#define doclusterread 1
#endif

/* XXX until cluster routines can handle block sizes less than one page */
#define cd9660_doclusterread \
	(doclusterread && (ISO_DEFAULT_BLOCK_SIZE >= NBPG))

a333 7
		if (cd9660_doclusterread) {
			if (lblktosize(imp, rablock) <= ip->i_size)
				error = cluster_read(vp, &ip->i_ci,
				    (off_t)ip->i_size, lbn, size, NOCRED, &bp);
			else
				error = bread(vp, lbn, size, NOCRED, &bp);
		} else {
d335 20
a354 21
			if (ci->ci_lastr + 1 == lbn) {
				struct ra {
					daddr64_t blks[MAX_RA];
					int sizes[MAX_RA];
				} *ra;
				int i;

				MALLOC(ra, struct ra *, sizeof *ra,
				    M_TEMP, M_WAITOK);
				for (i = 0; i < MAX_RA &&
				    lblktosize(imp, (rablock + i)) < ip->i_size;
				    i++) {
					ra->blks[i] = rablock + i;
					ra->sizes[i] = blksize(imp, ip, rablock + i);
				}
				error = breadn(vp, lbn, size, ra->blks,
				    ra->sizes, i, NOCRED, &bp);
				FREE(ra, M_TEMP);
			} else
				error = bread(vp, lbn, size, NOCRED, &bp);
		}
@


1.38
log
@Retire VOP_LEASE(); It was a bit for NQNFS and has
effectively been a no-op for quite some time now,
without promise for future usage.

ok pedro@@
Testing by krw@@ (earlier diff)
and Johan Mson Lindman (tybollt@@solace.miun.se)
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.37 2006/12/29 13:04:37 pedro Exp $	*/
d883 1
a883 1
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock));
d898 1
a898 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE,
	    &vp->v_interlock));
@


1.37
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.36 2006/10/16 11:27:53 pedro Exp $	*/
a1018 6
#ifdef	NFSSERVER
int	lease_check(void *);
#define	cd9660_lease_check	lease_check
#else
#define	cd9660_lease_check	nullop
#endif
a1047 1
	{ &vop_lease_desc, cd9660_lease_check },/* lease */
@


1.36
log
@Use daddr64_t for logical blocks, okay krw@@ thib@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.35 2006/10/03 19:49:06 pedro Exp $	*/
d834 1
a834 1
	uio->uio_iov->iov_base += symlen;
@


1.35
log
@Introduce daddr64_t and use it for physical block numbers
Okay weingart@@, "I'm game with putting my name on it" dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.34 2006/01/25 21:15:55 mickey Exp $	*/
d354 1
a354 1
					daddr_t blks[MAX_RA];
@


1.34
log
@reduce stack use; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.33 2005/11/19 02:18:01 pedro Exp $	*/
d403 3
a405 1
	daddr_t *block;
d409 4
a412 3
		block = (daddr_t *)ap->a_data;

		return (VOP_BMAP(ap->a_vp, *block, NULL, block, 0));
@


1.33
log
@Remove unnecessary lockmgr() archaism that was costing too much in terms
of panics and bugfixes. Access curproc directly, do not expect a process
pointer as an argument. Should fix many "process context required" bugs.
Incentive and okay millert@@, okay marc@@. Various testing, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.32 2004/11/29 17:05:05 grange Exp $	*/
d353 4
a356 2
				daddr_t rablks[MAX_RA];
				int rasizes[MAX_RA];
d359 2
d364 2
a365 2
					rablks[i] = rablock + i;
					rasizes[i] = blksize(imp, ip, rablock + i);
d367 3
a369 2
				error = breadn(vp, lbn, size, rablks,
				    rasizes, i, NOCRED, &bp);
@


1.32
log
@Don't use seltrue() in poll ops since it requires v_rdev dereferencing
which is not possible here. Problem found and fixed by form@@.

ok millert@@ fgsch@@ pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.31 2004/05/17 05:04:17 brad Exp $	*/
d875 1
a875 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock,
			ap->a_p));
d891 1
a891 1
			&vp->v_interlock, ap->a_p));
@


1.31
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.30 2004/05/14 04:00:34 tedu Exp $	*/
d424 1
a424 1
	return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
@


1.30
log
@use pool for namei pathbuf.  testing ok millert@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.29 2003/09/23 16:51:12 millert Exp $	*/
d101 1
a101 1
	pool_put(i&namei_pool, ndp->ni_pnbuf);
@


1.29
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.28 2003/06/02 23:28:05 millert Exp $	*/
d53 1
d101 1
a101 1
	free(ndp->ni_pnbuf, M_NAMEI);
d117 1
a117 1
		free(ndp->ni_pnbuf, M_NAMEI);
d799 1
a799 1
		MALLOC(symname, char *, MAXPATHLEN, M_NAMEI, M_WAITOK);
d807 1
a807 1
			FREE(symname, M_NAMEI);
d822 1
a822 1
		FREE(symname, M_NAMEI);
@


1.28
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.27 2003/05/14 21:15:33 tdeval Exp $	*/
d57 1
d411 1
a411 1
cd9660_select(v)
d414 6
d423 1
a423 1
	return (1);
d1048 1
a1048 1
	{ &vop_select_desc, cd9660_select },	/* select */
@


1.27
log
@Wrong check..
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.26 2003/05/14 21:13:43 tdeval Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.26
log
@strcpy + size check
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.25 2003/05/07 23:01:24 deraadt Exp $	*/
d802 1
a802 1
		    uio->uio_iov->iov_len >= MAXPATHLEN)
@


1.25
log
@string fix; tedu ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.24 2002/11/08 04:34:17 art Exp $	*/
d791 2
a792 1
	if (uio->uio_segflg == UIO_SYSSPACE)
d801 2
a802 1
		if (uio->uio_segflg != UIO_SYSSPACE)
d815 2
a816 1
	if (uio->uio_segflg != UIO_SYSSPACE) {
@


1.24
log
@Implement simple vnodeop inheritance for specfs and fifofs.

The inheritace is implemented by setting the default vnodeop to a
bypass op that repeats the operation on the spec/fifo vnodeop vector.
The overhead of one extra indirect function call is worth the cleanup
and improved correctness.

This actually solves a few bugs where some vnode ops were missing from
some vectors (like kqfilter or revoke). (and even more on the ubc
branch).

Inspired by the same thing done in FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.23 2002/05/24 13:41:27 art Exp $	*/
d668 2
a669 1
			strcpy(idp->current.d_name,"..");
@


1.23
log
@splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.22 2002/05/23 14:35:20 art Exp $	*/
d1064 1
a1064 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1074 1
a1074 6
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, spec_lookup },	/* lookup */
	{ &vop_create_desc, spec_create },	/* create */
	{ &vop_mknod_desc, spec_mknod },	/* mknod */
	{ &vop_open_desc, spec_open },		/* open */
	{ &vop_close_desc, spec_close },	/* close */
a1077 16
	{ &vop_read_desc, spec_read },		/* read */
	{ &vop_write_desc, spec_write },	/* write */
	{ &vop_lease_desc, spec_lease_check },	/* lease */
	{ &vop_ioctl_desc, spec_ioctl },	/* ioctl */
	{ &vop_select_desc, spec_select },	/* select */
	{ &vop_revoke_desc, spec_revoke },    /* revoke */
	{ &vop_fsync_desc, spec_fsync },	/* fsync */
	{ &vop_remove_desc, spec_remove },	/* remove */
	{ &vop_link_desc, spec_link },		/* link */
	{ &vop_rename_desc, spec_rename },	/* rename */
	{ &vop_mkdir_desc, spec_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, spec_rmdir },	/* rmdir */
	{ &vop_symlink_desc, spec_symlink },	/* symlink */
	{ &vop_readdir_desc, spec_readdir },	/* readdir */
	{ &vop_readlink_desc, spec_readlink },	/* readlink */
	{ &vop_abortop_desc, spec_abortop },	/* abortop */
a1081 2
	{ &vop_bmap_desc, spec_bmap },		/* bmap */
	{ &vop_strategy_desc, spec_strategy },	/* strategy */
d1084 1
a1084 4
	{ &vop_pathconf_desc, spec_pathconf },	/* pathconf */
	{ &vop_advlock_desc, spec_advlock },	/* advlock */
	{ &vop_bwrite_desc, vop_generic_bwrite },
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1092 1
a1092 6
	{ &vop_default_desc, vn_default_error },
	{ &vop_lookup_desc, fifo_lookup },	/* lookup */
	{ &vop_create_desc, fifo_create },	/* create */
	{ &vop_mknod_desc, fifo_mknod },	/* mknod */
	{ &vop_open_desc, fifo_open },		/* open */
	{ &vop_close_desc, fifo_close },	/* close */
a1095 16
	{ &vop_read_desc, fifo_read },		/* read */
	{ &vop_write_desc, fifo_write },	/* write */
	{ &vop_lease_desc, fifo_lease_check },	/* lease */
	{ &vop_ioctl_desc, fifo_ioctl },	/* ioctl */
	{ &vop_select_desc, fifo_select },	/* select */
	{ &vop_revoke_desc, fifo_revoke },      /* revoke */
	{ &vop_fsync_desc, fifo_fsync },	/* fsync */
	{ &vop_remove_desc, fifo_remove },	/* remove */
	{ &vop_link_desc, fifo_link }	,	/* link */
	{ &vop_rename_desc, fifo_rename },	/* rename */
	{ &vop_mkdir_desc, fifo_mkdir },	/* mkdir */
	{ &vop_rmdir_desc, fifo_rmdir },	/* rmdir */
	{ &vop_symlink_desc, fifo_symlink },	/* symlink */
	{ &vop_readdir_desc, fifo_readdir },	/* readdir */
	{ &vop_readlink_desc, fifo_readlink },	/* readlink */
	{ &vop_abortop_desc, fifo_abortop },	/* abortop */
a1099 2
	{ &vop_bmap_desc, fifo_bmap },		/* bmap */
	{ &vop_strategy_desc, fifo_strategy },	/* strategy */
a1101 2
	{ &vop_pathconf_desc, fifo_pathconf },	/* pathconf */
	{ &vop_advlock_desc, fifo_advlock },	/* advlock */
d1103 1
a1103 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.22
log
@Since the days of architectures where page size is smaller than
9660 block size are long gone and we can't use cluster_read on modern
machines, improve the dumb read-ahead.

Doesn't change much on macppc and sparc64, but gives a nice speed boost on
i386 (noone knows why). espie can watch his DVDs again.

espie@@ ok (noone else complained)
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.21 2002/03/14 01:27:03 millert Exp $	*/
d898 3
a900 3
	register struct buf *bp = ap->a_bp;
	register struct vnode *vp = bp->b_vp;
	register struct iso_node *ip;
d902 1
d912 1
d914 1
d921 1
d923 1
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.20 2001/12/19 08:58:06 art Exp $	*/
d323 1
a323 1
	int rasize, error = 0;
d333 2
d353 14
a366 5
			if (ip->i_ci.ci_lastr + 1 == lbn &&
			    lblktosize(imp, rablock) < ip->i_size) {
				rasize = blksize(imp, ip, rablock);
				error = breadn(vp, lbn, size, &rablock,
					       &rasize, 1, NOCRED, &bp);
d370 1
a370 1
		ip->i_ci.ci_lastr = lbn;
@


1.20
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.14 2001/06/23 02:14:23 csapuntz Exp $	*/
d87 2
a88 2
int	iso_uiodir __P((struct isoreaddir *, struct dirent *, off_t));
int	iso_shipdir __P((struct isoreaddir *));
d989 1
a989 1
int	lease_check	__P((void *));
d1010 1
a1010 1
int (**cd9660_vnodeop_p) __P((void *));
d1048 1
a1048 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1056 1
a1056 1
int (**cd9660_specop_p) __P((void *));
d1094 1
a1094 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1100 1
a1100 1
int (**cd9660_fifoop_p) __P((void *));
d1138 1
a1138 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.19
log
@Since VOP_READ is never called on VDIR vnodes and ext2fs_read
is only in the vnodeops in VREG and VDIR vnodes, we can remove tons of
code here.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.18 2001/12/10 04:45:31 art Exp $	*/
d293 10
d317 8
a324 3
	struct uio *uio = ap->a_uio;
	struct iso_node *ip = VTOI(vp);
	int error;
a329 9

	if (vp->v_type != VREG) {
		/*
		 * XXXART - maybe we should just panic? this is not possible
		 *  unless vn_rdwr is called with VDIR and that's an error.
		 */
		return (EISDIR);
	}

d331 34
d366 1
a366 13
	while (uio->uio_resid > 0) {
		void *win;
		vsize_t bytelen = MIN(ip->i_size - uio->uio_offset,
		    uio->uio_resid);
		if (bytelen == 0)
			break;
		win = ubc_alloc(&vp->v_uobj, uio->uio_offset, &bytelen,
		    UBC_READ);
		error = uiomove(win, bytelen, uio);
		ubc_release(win, 0);
		if (error)
			return (error);
	}
d368 6
a373 1
	return (0);
d1048 1
a1048 3
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_mmap_desc, cd9660_mmap },
	{ NULL, NULL }
d1094 1
a1094 2
	{ &vop_mmap_desc, spec_mmap },
	{ NULL, NULL }
d1138 1
a1138 2
	{ &vop_mmap_desc, fifo_mmap },
	{ NULL, NULL }
@


1.19.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.19 2001/12/10 18:49:51 art Exp $	*/
a1015 1
	{ &vop_putpages_desc, genfs_putpages },
@


1.19.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.19.2.1 2002/02/02 03:28:25 art Exp $	*/
d87 2
a88 2
int	iso_uiodir(struct isoreaddir *, struct dirent *, off_t);
int	iso_shipdir(struct isoreaddir *);
d854 3
a856 3
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct iso_node *ip;
a857 1
	int s;
a866 1
			s = splbio();
a867 1
			splx(s);
a873 1
		s = splbio();
a874 1
		splx(s);
d956 1
a956 1
int	lease_check(void *);
d977 1
a977 1
int (**cd9660_vnodeop_p)(void *);
d1026 1
a1026 1
int (**cd9660_specop_p)(void *);
d1071 1
a1071 1
int (**cd9660_fifoop_p)(void *);
@


1.19.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.19.2.2 2002/06/11 03:29:20 art Exp $	*/
d1034 4
d1044 4
d1049 9
d1062 2
d1066 4
a1069 1
	SPEC_VNODEOP_DESCS,
d1079 4
d1089 4
d1094 9
d1108 1
d1111 2
d1114 1
a1114 1
	FIFO_VNODEOP_DESCS,
@


1.19.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d624 1
a624 2
			strlcpy(idp->current.d_name,"..",
			    sizeof idp->current.d_name);
d746 1
a746 2
	if (uio->uio_segflg == UIO_SYSSPACE &&
	    uio->uio_iov->iov_len >= MAXPATHLEN)
d755 1
a755 2
		if (uio->uio_segflg != UIO_SYSSPACE ||
		    uio->uio_iov->iov_len < MAXPATHLEN)
d768 1
a768 2
	if (uio->uio_segflg != UIO_SYSSPACE ||
	    uio->uio_iov->iov_len < MAXPATHLEN) {
d1033 2
a1034 1
	{ &vop_default_desc, spec_vnoperate },
d1038 3
d1047 1
d1056 2
a1057 1
	{ &vop_default_desc, fifo_vnoperate },
d1061 3
d1068 1
d1072 1
@


1.18
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.17 2001/12/10 02:19:34 art Exp $	*/
a292 10
#ifdef DEBUG
extern int doclusterread;
#else
#define doclusterread 1
#endif

/* XXX until cluster routines can handle block sizes less than one page */
#define cd9660_doclusterread \
	(doclusterread && (ISO_DEFAULT_BLOCK_SIZE >= NBPG))

d309 1
a309 6
	struct iso_mnt *imp;
	struct buf *bp;
	daddr_t lbn, rablock;
	off_t diff;
	int rasize, error = 0;
	long size, n, on;
a314 2
	ip->i_flag |= IN_ACCESS;
	imp = ip->i_mnt;
d316 6
a321 17
	if (vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {
			void *win;
			vsize_t bytelen = MIN(ip->i_size - uio->uio_offset,
					uio->uio_resid);

			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uobj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
				break;
		}
		goto out;
d324 13
a336 31
	do {
		lbn = lblkno(imp, uio->uio_offset);
		on = blkoff(imp, uio->uio_offset);
		n = min((u_int)(imp->logical_block_size - on),
			uio->uio_resid);
		diff = (off_t)ip->i_size - uio->uio_offset;
		if (diff <= 0)
			return (0);
		if (diff < n)
			n = diff;
		size = blksize(imp, ip, lbn);
		rablock = lbn + 1;
		if (cd9660_doclusterread) {
			if (lblktosize(imp, rablock) <= ip->i_size)
				error = cluster_read(vp, &ip->i_ci,
				    (off_t)ip->i_size, lbn, size, NOCRED, &bp);
			else
				error = bread(vp, lbn, size, NOCRED, &bp);
		} else {
			if (ip->i_ci.ci_lastr + 1 == lbn &&
			    lblktosize(imp, rablock) < ip->i_size) {
				rasize = blksize(imp, ip, rablock);
				error = breadn(vp, lbn, size, &rablock,
					       &rasize, 1, NOCRED, &bp);
			} else
				error = bread(vp, lbn, size, NOCRED, &bp);
		}
		ip->i_ci.ci_lastr = lbn;
		n = min(n, size - bp->b_resid);
		if (error) {
			brelse(bp);
d338 1
a338 1
		}
d340 1
a340 10
		error = uiomove(bp->b_data + on, (int)n, uio);

                if (n + on == imp->logical_block_size ||
		    uio->uio_offset == (off_t)ip->i_size)
			bp->b_flags |= B_AGE;
		brelse(bp);
	} while (error == 0 && uio->uio_resid > 0 && n != 0);

out:
	return (error);
@


1.17
log
@Merge in struct uvm_vnode into struct vnode.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.16 2001/12/04 22:44:31 art Exp $	*/
a1070 1
	{ &vop_size_desc, genfs_size },
@


1.16
log
@Readd VOP_MMAP, will be used soon. Right now it's just a question to
the filesystem if we're allowed to mmap the file.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.15 2001/11/27 05:27:11 art Exp $	*/
d342 1
a342 1
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
@


1.15
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.14 2001/06/23 02:14:23 csapuntz Exp $	*/
d1072 1
d1119 2
a1120 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
d1164 2
a1165 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.14
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.13 2001/02/23 14:42:38 csapuntz Exp $	*/
d317 3
a319 3
	register struct uio *uio = ap->a_uio;
	register struct iso_node *ip = VTOI(vp);
	register struct iso_mnt *imp;
d332 20
d393 2
d1070 3
a1072 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.13
log
@

Remove the clustering fields from the vnodes and place them in the
file system inode instead
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.12 1999/11/13 03:48:09 angelos Exp $	*/
d585 1
a585 1
	    (error = VOP_BLKATOFF(vdp, (off_t)idp->curroff, NULL, &bp))) {
d600 1
a600 1
			error = VOP_BLKATOFF(vdp, (off_t)idp->curroff,
a1026 1
	{ &vop_mmap_desc, cd9660_mmap },	/* mmap */
a1027 1
	{ &vop_seek_desc, cd9660_seek },	/* seek */
a1046 5
	{ &vop_blkatoff_desc, cd9660_blkatoff },/* blkatoff */
	{ &vop_valloc_desc, cd9660_valloc },	/* valloc */
	{ &vop_vfree_desc, cd9660_vfree },	/* vfree */
	{ &vop_truncate_desc, cd9660_truncate },/* truncate */
	{ &vop_update_desc, cd9660_update },	/* update */
a1072 1
	{ &vop_mmap_desc, spec_mmap },		/* mmap */
a1073 1
	{ &vop_seek_desc, spec_seek },		/* seek */
a1092 5
	{ &vop_blkatoff_desc, spec_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, spec_valloc },	/* valloc */
	{ &vop_vfree_desc, spec_vfree },	/* vfree */
	{ &vop_truncate_desc, spec_truncate },	/* truncate */
	{ &vop_update_desc, cd9660_update },	/* update */
a1116 1
	{ &vop_mmap_desc, fifo_mmap },		/* mmap */
a1117 1
	{ &vop_seek_desc, fifo_seek },		/* seek */
a1136 5
	{ &vop_blkatoff_desc, fifo_blkatoff },	/* blkatoff */
	{ &vop_valloc_desc, fifo_valloc },	/* valloc */
	{ &vop_vfree_desc, fifo_vfree },	/* vfree */
	{ &vop_truncate_desc, fifo_truncate },	/* truncate */
	{ &vop_update_desc, cd9660_update },	/* update */
@


1.12
log
@FIBMAP ioctl from Linux, only usable on ISO 9660 FS. Note that the lba
returned is in 512-byte sectors, so if you're going to use it for
things like DVD, you need to divide the result by 4 (for 2048-byte
sectors). OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.11 1999/07/01 02:20:22 d Exp $	*/
d346 2
a347 2
				error = cluster_read(vp, (off_t)ip->i_size,
						     lbn, size, NOCRED, &bp);
d351 1
a351 1
			if (vp->v_lastr + 1 == lbn &&
d359 1
a359 1
		vp->v_lastr = lbn;
@


1.12.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.13 2001/02/23 14:42:38 csapuntz Exp $	*/
d346 2
a347 2
				error = cluster_read(vp, &ip->i_ci,
				    (off_t)ip->i_size, lbn, size, NOCRED, &bp);
d351 1
a351 1
			if (ip->i_ci.ci_lastr + 1 == lbn &&
d359 1
a359 1
		ip->i_ci.ci_lastr = lbn;
@


1.12.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.12.2.1 2001/05/14 22:32:37 niklas Exp $	*/
d585 1
a585 1
	    (error = cd9660_bufatoff(dp, (off_t)idp->curroff, NULL, &bp))) {
d600 1
a600 1
			error = cd9660_bufatoff(dp, (off_t)idp->curroff,
d1027 1
d1029 1
d1049 5
d1080 1
d1082 1
d1102 5
d1131 1
d1133 1
d1153 5
@


1.12.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d317 3
a319 3
	struct uio *uio = ap->a_uio;
	struct iso_node *ip = VTOI(vp);
	struct iso_mnt *imp;
a331 20

	if (vp->v_type == VREG) {
		error = 0;
		while (uio->uio_resid > 0) {
			void *win;
			vsize_t bytelen = MIN(ip->i_size - uio->uio_offset,
					uio->uio_resid);

			if (bytelen == 0)
				break;
			win = ubc_alloc(&vp->v_uvm.u_obj, uio->uio_offset,
					&bytelen, UBC_READ);
			error = uiomove(win, bytelen, uio);
			ubc_release(win, 0);
			if (error)
				break;
		}
		goto out;
	}

a372 2

out:
d1048 1
a1048 3
	{ &vop_getpages_desc, genfs_getpages },
	{ &vop_size_desc, genfs_size },
	{ NULL, NULL }
@


1.12.2.4
log
@Merge in trunk
@
text
@d317 3
a319 3
	register struct uio *uio = ap->a_uio;
	register struct iso_node *ip = VTOI(vp);
	register struct iso_mnt *imp;
d332 20
d393 2
d1070 3
a1072 1
	{ (struct vnodeop_desc*)NULL, (int(*) __P((void *)))NULL }
@


1.12.2.5
log
@Merge in -current from roughly a week ago
@
text
@d87 2
a88 2
int	iso_uiodir(struct isoreaddir *, struct dirent *, off_t);
int	iso_shipdir(struct isoreaddir *);
d989 1
a989 1
int	lease_check(void *);
d1010 1
a1010 1
int (**cd9660_vnodeop_p)(void *);
d1048 1
a1048 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1056 1
a1056 1
int (**cd9660_specop_p)(void *);
d1094 1
a1094 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
d1100 1
a1100 1
int (**cd9660_fifoop_p)(void *);
d1138 1
a1138 1
	{ (struct vnodeop_desc*)NULL, (int(*)(void *))NULL }
@


1.12.2.6
log
@Sync the SMP branch with 3.3
@
text
@d323 1
a323 1
	int error = 0;
a332 2
		struct cluster_info *ci = &ip->i_ci;

d351 5
a355 14
#define MAX_RA 32
			if (ci->ci_lastr + 1 == lbn) {
				daddr_t rablks[MAX_RA];
				int rasizes[MAX_RA];
				int i;

				for (i = 0; i < MAX_RA &&
				    lblktosize(imp, (rablock + i)) < ip->i_size;
				    i++) {
					rablks[i] = rablock + i;
					rasizes[i] = blksize(imp, ip, rablock + i);
				}
				error = breadn(vp, lbn, size, rablks,
				    rasizes, i, NOCRED, &bp);
d359 1
a359 1
		ci->ci_lastr = lbn;
d887 3
a889 3
	struct buf *bp = ap->a_bp;
	struct vnode *vp = bp->b_vp;
	struct iso_node *ip;
a890 1
	int s;
a899 1
			s = splbio();
a900 1
			splx(s);
a906 1
		s = splbio();
a907 1
		splx(s);
d1048 1
a1048 1
	{ NULL, NULL }
d1058 6
a1063 1
	{ &vop_default_desc, spec_vnoperate },
d1067 16
d1087 2
d1091 4
a1094 1
	{ NULL, NULL }
d1102 6
a1107 1
	{ &vop_default_desc, fifo_vnoperate },
d1111 16
d1131 2
d1135 2
d1138 1
a1138 1
	{ NULL, NULL }
@


1.12.2.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.12.2.6 2003/03/28 00:00:19 niklas Exp $	*/
d668 1
a668 2
			strlcpy(idp->current.d_name,"..",
			    sizeof idp->current.d_name);
@


1.12.2.8
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d791 1
a791 2
	if (uio->uio_segflg == UIO_SYSSPACE &&
	    uio->uio_iov->iov_len >= MAXPATHLEN)
d800 1
a800 2
		if (uio->uio_segflg != UIO_SYSSPACE ||
		    uio->uio_iov->iov_len < MAXPATHLEN)
d813 1
a813 2
	if (uio->uio_segflg != UIO_SYSSPACE ||
	    uio->uio_iov->iov_len < MAXPATHLEN) {
@


1.12.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.12.2.8 2003/05/16 00:29:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.12.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a56 1
#include <sys/poll.h>
d410 1
a410 1
cd9660_poll(v)
a412 6
	struct vop_poll_args /* {
		struct vnode *a_vp;
		int a_events;
		struct proc *a_p;
	} */ *ap = v;

d416 1
a416 1
	return (seltrue(ap->a_vp->v_rdev, ap->a_events, ap->a_p));
d1041 1
a1041 1
	{ &vop_poll_desc, cd9660_poll },	/* poll */
@


1.12.2.11
log
@Merge with the trunk
@
text
@a52 1
#include <sys/pool.h>
d100 1
a100 1
	pool_put(&namei_pool, ndp->ni_pnbuf);
d116 1
a116 1
		pool_put(&namei_pool, ndp->ni_pnbuf);
d798 1
a798 1
		symname = pool_get(&namei_pool, PR_WAITOK);
d806 1
a806 1
			pool_put(&namei_pool, symname);
d821 1
a821 1
		pool_put(&namei_pool, symname);
@


1.11
log
@Add support for Joliet extensions. From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.10 1998/08/06 19:34:22 csapuntz Exp $	*/
d58 3
d381 18
a398 2
	printf("You did ioctl for isofs !!\n");
	return (ENOTTY);
@


1.10
log
@

Rename vop_revoke, vn_bwrite, vop_noislocked, vop_nolock, vop_nounlock
to be vop_generic_revoke, vop_generic_bwrite, vop_generic_islocked,
vop_generic_lock and vop_generic_unlock.

Create vop_generic_abortop and propogate change to all file systems.

Fix PR/371.

Get rid of locking in NULLFS (should be mostly unnecessary now except for
forced unmounts).
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.9 1997/11/08 17:21:08 niklas Exp $	*/
d639 1
a639 2
			switch (ep->name[0]) {
			case 0:
d642 2
a643 2
				break;
			case 1:
d646 1
a646 2
				break;
			default:
d650 2
a651 1
					   isonum_711(ep->flags)&4);
a656 1
				break;
@


1.9
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.8 1997/11/06 05:58:12 csapuntz Exp $	*/
a827 17
 * cd9660 abort op, called after namei() when a CREATE/DELETE isn't actually
 * done. If a buffer has been saved in anticipation of a CREATE, delete it.
 */
int
cd9660_abortop(v)
	void *v;
{
	struct vop_abortop_args /* {
		struct vnode *a_dvp;
		struct componentname *a_cnp;
	} */ *ap = v;
	if ((ap->a_cnp->cn_flags & (HASBUF | SAVESTART)) == HASBUF)
		FREE(ap->a_cnp->cn_pnbuf, M_NAMEI);
	return (0);
}

/*
d988 1
a988 1
#define cd9660_revoke   vop_revoke
d1021 1
a1021 1
	{ &vop_abortop_desc, cd9660_abortop },	/* abortop */
d1037 1
a1037 1
	{ &vop_bwrite_desc, vn_bwrite },
d1090 1
a1090 1
	{ &vop_bwrite_desc, vn_bwrite },
d1141 1
a1141 1
	{ &vop_bwrite_desc, vn_bwrite },
@


1.8
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: cd9660_vnops.c,v 1.7 1997/10/06 20:19:46 deraadt Exp $	*/
/*	$NetBSD: cd9660_vnops.c,v 1.32 1996/03/16 20:25:40 ws Exp $	*/
a55 2
#include <miscfs/specfs/specdev.h>
#include <miscfs/fifofs/fifo.h>
d59 3
d63 1
d149 11
a159 1
       void *v;
d161 20
a180 31
{
       struct vop_setattr_args /* {
               struct vnodeop_desc *a_desc;
               struct vnode *a_vp;
               struct vattr *a_vap;
               struct ucred *a_cred;
               struct proc *a_p;
       } */ *ap = v;
       struct vnode *vp = ap->a_vp;
       struct vattr *vap = ap->a_vap;

       if (vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
           vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
           vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL)
               return (EROFS);
       if (vap->va_size != VNOVAL) {
               switch (vp->v_type) {
               case VDIR:
                       return (EISDIR);
               case VLNK:
               case VREG:
                       return (EROFS);
               case VCHR:
               case VBLK:
               case VSOCK:
               case VFIFO:
                       return (0);
	       default:
		       return (EINVAL);
               }
       }
d182 1
a182 1
       return (EINVAL);
d228 1
a228 1
	return (vaccess(ip->inode.iso_mode, ip->inode.iso_uid,
d249 1
a249 1
	vap->va_mode	= ip->inode.iso_mode;
d259 1
a259 1
	if (ip->i_size == 0 && (vap->va_mode & S_IFMT) == S_IFLNK) {
a289 1
#if ISO_DEFAULT_BLOCK_SIZE >= NBPG
d295 4
a298 3
#else
#define doclusterread 0
#endif
d341 1
a341 1
		if (doclusterread) {
d368 1
a368 1
	brelse(bp);
a419 1

d687 1
a687 1
	       brelse (bp);
d723 1
a723 1
	
d852 1
a852 1
		struct vnode *a_vp;	      
@


1.7
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.5 1996/04/21 22:26:38 deraadt Exp $	*/
d123 1
a123 2
		dp->d_next->d_prev = dp->d_prev;
		*dp->d_prev = dp->d_next;
d143 42
d289 1
d295 3
a297 4

/* XXX until cluster routines can handle block sizes less than one page */
#define cd9660_doclusterread \
	(doclusterread && (ISO_DEFAULT_BLOCK_SIZE >= NBPG))
d340 1
a340 1
		if (cd9660_doclusterread) {
d363 5
a367 1
		brelse(bp);
d534 2
d550 12
a562 2
	idp->cookies = ap->a_cookies;
	idp->ncookies = ap->a_ncookies;
d674 12
d687 1
a687 1
		brelse (bp);
d723 1
a723 1

d852 1
a852 1
		struct vnode *a_vp;
d854 1
a854 5
	register struct vnode *vp = ap->a_vp;
	register struct iso_node *ip;
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d856 2
a857 34
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	ip = VTOI(vp);
	if (ip->i_flag & IN_LOCKED) {
		ip->i_flag |= IN_WANTED;
#ifdef DIAGNOSTIC
		if (p) {
			if (p->p_pid == ip->i_lockholder)
				panic("locking against myself");
			ip->i_lockwaiter = p->p_pid;
		} else
			ip->i_lockwaiter = -1;
#endif
		(void) sleep((caddr_t)ip, PINOD);
		goto start;
	}
#ifdef DIAGNOSTIC
	ip->i_lockwaiter = 0;
	if (ip->i_lockholder != 0)
		panic("lockholder (%d) != 0", ip->i_lockholder);
	if (p && p->p_pid == 0)
		printf("locking by process 0\n");
	if (p)
		ip->i_lockholder = p->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
	return (0);
d870 1
a870 1
	register struct iso_node *ip = VTOI(ap->a_vp);
d872 2
a873 19
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */

	if ((ip->i_flag & IN_LOCKED) == 0) {
		vprint("cd9660_unlock: unlocked inode", ap->a_vp);
		panic("cd9660_unlock NOT LOCKED");
	}
	if (p && p->p_pid != ip->i_lockholder && p->p_pid > -1 &&
	    ip->i_lockholder > -1/* && lockcount++ < 100*/)
		panic("unlocker (%d) != lock holder (%d)",
		    p->p_pid, ip->i_lockholder);
	ip->i_lockholder = 0;
#endif
	ip->i_flag &= ~IN_LOCKED;
	if (ip->i_flag & IN_WANTED) {
		ip->i_flag &= ~IN_WANTED;
		wakeup((caddr_t)ip);
	}
	return (0);
d939 1
a939 3
	if (VTOI(ap->a_vp)->i_flag & IN_LOCKED)
		return (1);
	return (0);
a982 12
 * Unsupported operation
 */
/*ARGSUSED*/
int
cd9660_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
}

/*
d985 3
a987 4
#define	cd9660_create	cd9660_enotsupp
#define	cd9660_mknod	cd9660_enotsupp
#define	cd9660_setattr	cd9660_enotsupp
#define	cd9660_write	cd9660_enotsupp
d995 11
a1005 10
#define	cd9660_remove	cd9660_enotsupp
#define	cd9660_rename	cd9660_enotsupp
#define	cd9660_mkdir	cd9660_enotsupp
#define	cd9660_rmdir	cd9660_enotsupp
#define	cd9660_advlock	cd9660_enotsupp
#define	cd9660_valloc	cd9660_enotsupp
#define	cd9660_vfree	cd9660_enotsupp
#define	cd9660_truncate	cd9660_enotsupp
#define	cd9660_update	cd9660_enotsupp
#define	cd9660_bwrite	cd9660_enotsupp
d1026 1
d1079 1
d1130 1
@


1.6
log
@VFS Lite2 Changes
@
text
@d123 2
a124 1
		remque(dp);
a143 42
 * Setattr call. Only allowed for block and character special devices.
 */
int
cd9660_setattr(v)
       void *v;

{
       struct vop_setattr_args /* {
               struct vnodeop_desc *a_desc;
               struct vnode *a_vp;
               struct vattr *a_vap;
               struct ucred *a_cred;
               struct proc *a_p;
       } */ *ap = v;
       struct vnode *vp = ap->a_vp;
       struct vattr *vap = ap->a_vap;

       if (vap->va_flags != VNOVAL || vap->va_uid != (uid_t)VNOVAL ||
           vap->va_gid != (gid_t)VNOVAL || vap->va_atime.tv_sec != VNOVAL ||
           vap->va_mtime.tv_sec != VNOVAL || vap->va_mode != (mode_t)VNOVAL)
               return (EROFS);
       if (vap->va_size != VNOVAL) {
               switch (vp->v_type) {
               case VDIR:
                       return (EISDIR);
               case VLNK:
               case VREG:
                       return (EROFS);
               case VCHR:
               case VBLK:
               case VSOCK:
               case VFIFO:
                       return (0);
	       default:
		       return (EINVAL);
               }
       }

       return (EINVAL);
}

/*
a247 1
#if ISO_DEFAULT_BLOCK_SIZE >= NBPG
d253 4
a256 3
#else
#define doclusterread 0
#endif
d299 1
a299 1
		if (doclusterread) {
d322 1
a322 5

                if (n + on == imp->logical_block_size ||
		    uio->uio_offset == (off_t)ip->i_size)
			bp->b_flags |= B_AGE;
	brelse(bp);
a488 2
	int  ncookies = 0;
	u_long *cookies = NULL;
a502 12
	if (ap->a_ncookies == NULL) {
		idp->cookies = NULL;
	} else {
               /*
                * Guess the number of cookies needed.
                */
               ncookies = uio->uio_resid / 16;
               MALLOC(cookies, u_long *, ncookies * sizeof(u_long), M_TEMP,
                   M_WAITOK);
               idp->cookies = cookies;
               idp->ncookies = ncookies;
	}
d504 2
a616 12
	if (ap->a_ncookies != NULL) {
		if (error)
			free(cookies, M_TEMP);
		else {
			/*
			 * Work out the number of cookies actually used.
			 */
			*ap->a_ncookies = ncookies - idp->ncookies;
			*ap->a_cookies = cookies;
		}
	}
	
d618 1
a618 1
	       brelse (bp);
d654 1
a654 1
	
d783 1
a783 1
		struct vnode *a_vp;	      
d785 5
a789 1
	struct vnode *vp = ap->a_vp;
d791 34
a824 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags, &vp->v_interlock,
			ap->a_p));
d837 4
a840 1
	struct vnode *vp = ap->a_vp;
d842 16
a857 2
	return (lockmgr(&VTOI(vp)->i_lock, ap->a_flags | LK_RELEASE,
			&vp->v_interlock, ap->a_p));
d923 3
a925 1
	return (lockstatus(&VTOI(ap->a_vp)->i_lock));
d969 12
d983 4
a986 3
#define	cd9660_create	eopnotsupp
#define	cd9660_mknod	eopnotsupp
#define	cd9660_write	eopnotsupp
d994 10
a1003 11
#define	cd9660_remove	eopnotsupp
#define	cd9660_rename	eopnotsupp
#define	cd9660_mkdir	eopnotsupp
#define	cd9660_rmdir	eopnotsupp
#define	cd9660_advlock	eopnotsupp
#define	cd9660_valloc	eopnotsupp
#define	cd9660_vfree	eopnotsupp
#define	cd9660_truncate	eopnotsupp
#define	cd9660_update	eopnotsupp
#define	cd9660_bwrite	eopnotsupp
#define cd9660_revoke   vop_revoke
a1023 1
	{ &vop_revoke_desc, cd9660_revoke },    /* revoke */
a1075 1
	{ &vop_revoke_desc, spec_revoke },    /* revoke */
a1125 1
	{ &vop_revoke_desc, fifo_revoke },      /* revoke */
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vnops.c,v 1.4 1996/04/19 16:08:43 niklas Exp $	*/
d123 1
a123 2
		dp->d_next->d_prev = dp->d_prev;
		*dp->d_prev = dp->d_next;
d143 42
d289 1
d295 3
a297 4

/* XXX until cluster routines can handle block sizes less than one page */
#define cd9660_doclusterread \
	(doclusterread && (ISO_DEFAULT_BLOCK_SIZE >= NBPG))
d340 1
a340 1
		if (cd9660_doclusterread) {
d363 5
a367 1
		brelse(bp);
d534 2
d550 12
a562 2
	idp->cookies = ap->a_cookies;
	idp->ncookies = ap->a_ncookies;
d674 12
d687 1
a687 1
		brelse (bp);
d723 1
a723 1

d852 1
a852 1
		struct vnode *a_vp;
d854 1
a854 5
	register struct vnode *vp = ap->a_vp;
	register struct iso_node *ip;
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */
#endif
d856 2
a857 34
start:
	while (vp->v_flag & VXLOCK) {
		vp->v_flag |= VXWANT;
		sleep((caddr_t)vp, PINOD);
	}
	if (vp->v_tag == VT_NON)
		return (ENOENT);
	ip = VTOI(vp);
	if (ip->i_flag & IN_LOCKED) {
		ip->i_flag |= IN_WANTED;
#ifdef DIAGNOSTIC
		if (p) {
			if (p->p_pid == ip->i_lockholder)
				panic("locking against myself");
			ip->i_lockwaiter = p->p_pid;
		} else
			ip->i_lockwaiter = -1;
#endif
		(void) sleep((caddr_t)ip, PINOD);
		goto start;
	}
#ifdef DIAGNOSTIC
	ip->i_lockwaiter = 0;
	if (ip->i_lockholder != 0)
		panic("lockholder (%d) != 0", ip->i_lockholder);
	if (p && p->p_pid == 0)
		printf("locking by process 0\n");
	if (p)
		ip->i_lockholder = p->p_pid;
	else
		ip->i_lockholder = -1;
#endif
	ip->i_flag |= IN_LOCKED;
	return (0);
d870 1
a870 1
	register struct iso_node *ip = VTOI(ap->a_vp);
d872 2
a873 19
#ifdef DIAGNOSTIC
	struct proc *p = curproc;	/* XXX */

	if ((ip->i_flag & IN_LOCKED) == 0) {
		vprint("cd9660_unlock: unlocked inode", ap->a_vp);
		panic("cd9660_unlock NOT LOCKED");
	}
	if (p && p->p_pid != ip->i_lockholder && p->p_pid > -1 &&
	    ip->i_lockholder > -1/* && lockcount++ < 100*/)
		panic("unlocker (%d) != lock holder (%d)",
		    p->p_pid, ip->i_lockholder);
	ip->i_lockholder = 0;
#endif
	ip->i_flag &= ~IN_LOCKED;
	if (ip->i_flag & IN_WANTED) {
		ip->i_flag &= ~IN_WANTED;
		wakeup((caddr_t)ip);
	}
	return (0);
d939 1
a939 3
	if (VTOI(ap->a_vp)->i_flag & IN_LOCKED)
		return (1);
	return (0);
a982 12
 * Unsupported operation
 */
/*ARGSUSED*/
int
cd9660_enotsupp(v)
	void *v;
{

	return (EOPNOTSUPP);
}

/*
d985 3
a987 4
#define	cd9660_create	cd9660_enotsupp
#define	cd9660_mknod	cd9660_enotsupp
#define	cd9660_setattr	cd9660_enotsupp
#define	cd9660_write	cd9660_enotsupp
d995 11
a1005 10
#define	cd9660_remove	cd9660_enotsupp
#define	cd9660_rename	cd9660_enotsupp
#define	cd9660_mkdir	cd9660_enotsupp
#define	cd9660_rmdir	cd9660_enotsupp
#define	cd9660_advlock	cd9660_enotsupp
#define	cd9660_valloc	cd9660_enotsupp
#define	cd9660_vfree	cd9660_enotsupp
#define	cd9660_truncate	cd9660_enotsupp
#define	cd9660_update	cd9660_enotsupp
#define	cd9660_bwrite	cd9660_enotsupp
d1026 1
d1079 1
d1130 1
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: cd9660_vnops.c,v 1.3 1996/02/29 10:12:28 niklas Exp $	*/
/*	$NetBSD: cd9660_vnops.c,v 1.31 1996/03/08 18:13:07 scottr Exp $	*/
d401 1
a401 1
	if ((error = uiomove((caddr_t) dp,dp->d_reclen,idp->uio)) != 0)
d419 1
a419 1
	if ((assoc = (cl > 1)) && *cname == ASSOCCHAR) {
d733 1
a733 1
		struct componentname *a_cnp; 
d759 1
a759 1
 * Ufs abort op, called after namei() when a CREATE/DELETE isn't actually
d843 2
a844 2
		vprint("ufs_unlock: unlocked inode", ap->a_vp);
		panic("ufs_unlock NOT LOCKED");
@


1.3
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cd9660_vnops.c,v 1.29 1996/02/10 00:33:53 christos Exp $	*/
d59 1
a59 1
#include <sys/dir.h>
d384 1
a384 1
	dp->d_reclen = DIRSIZ(dp);
d450 1
a450 1
	idp->current.d_reclen = DIRSIZ(&idp->current);
@


1.2
log
@from netbsd:
"goto start" after sleeping for locked iso_node in cd9660_lock, like
in ufs_lock.
NBPG may not be computable by the preprocessor. Make "do clustered io"
a run-time decision. Note: the compiler can optimize it away.
@
text
@d1 2
a2 1
/*	$NetBSD: cd9660_vnops.c,v 1.26 1995/12/01 00:47:33 pk Exp $	*/
d65 20
d90 1
d150 2
a151 7
cd9660_open(ap)
	struct vop_open_args /* {
		struct vnode *a_vp;
		int  a_mode;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d163 2
a164 7
cd9660_close(ap)
	struct vop_close_args /* {
		struct vnode *a_vp;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
a173 1
/* ARGSUSED */
d175 3
a177 1
cd9660_access(ap)
d183 1
a183 2
	} */ *ap;
{
d191 3
a193 1
cd9660_getattr(ap)
d199 1
a199 3
	} */ *ap;

{
d262 3
a264 1
cd9660_read(ap)
d270 1
a270 2
	} */ *ap;
{
d329 2
a330 9
cd9660_ioctl(ap)
	struct vop_ioctl_args /* {
		struct vnode *a_vp;
		u_long a_command;
		caddr_t  a_data;
		int  a_fflag;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d338 2
a339 8
cd9660_select(ap)
	struct vop_select_args /* {
		struct vnode *a_vp;
		int  a_which;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
a340 1

d354 2
a355 7
cd9660_mmap(ap)
	struct vop_mmap_args /* {
		struct vnode *a_vp;
		int  a_fflags;
		struct ucred *a_cred;
		struct proc *a_p;
	} */ *ap;
d368 2
a369 7
cd9660_seek(ap)
	struct vop_seek_args /* {
		struct vnode *a_vp;
		off_t  a_oldoff;
		off_t  a_newoff;
		struct ucred *a_cred;
	} */ *ap;
a370 1

a373 16
/*
 * Structure for reading directories
 */
struct isoreaddir {
	struct dirent saveent;
	struct dirent assocent;
	struct dirent current;
	off_t saveoff;
	off_t assocoff;
	off_t curroff;
	struct uio *uio;
	off_t uio_off;
	int eofflag;
	u_long *cookies;
	int ncookies;
};
d401 1
a401 1
	if (error = uiomove(dp,dp->d_reclen,idp->uio))
d418 2
a419 1
	if (assoc = cl > 1 && *cname == ASSOCCHAR) {
d435 3
a437 1
				if (error = iso_uiodir(idp,&idp->assocent,idp->assocoff))
d442 3
a444 1
				if (error = iso_uiodir(idp,&idp->saveent,idp->saveoff))
d465 3
a467 1
cd9660_readdir(ap)
d475 1
a475 2
	} */ *ap;
{
d524 3
a526 2
			if (error =
			    VOP_BLKATOFF(vdp, (off_t)idp->curroff, NULL, &bp))
d638 3
a640 1
cd9660_readlink(ap)
d645 1
a645 2
	} */ *ap;
{
d726 32
d763 3
a765 1
cd9660_abortop(ap)
d769 1
a769 2
	} */ *ap;
{
d779 3
a781 1
cd9660_lock(ap)
d784 1
a784 2
	} */ *ap;
{
d787 1
d789 1
d831 3
a833 1
cd9660_unlock(ap)
d836 1
a836 2
	} */ *ap;
{
d838 2
a841 1
#ifdef DIAGNOSTIC
d865 3
a867 1
cd9660_strategy(ap)
d870 1
a870 2
	} */ *ap;
{
d880 2
a881 2
		if (error =
		    VOP_BMAP(vp, bp->b_lblkno, NULL, &bp->b_blkno, NULL)) {
d903 1
d905 2
a906 4
cd9660_print(ap)
	struct vop_print_args /* {
		struct vnode *a_vp;
	} */ *ap;
a907 1

d916 3
a918 1
cd9660_islocked(ap)
d921 1
a921 2
	} */ *ap;
{
d932 3
a934 1
cd9660_pathconf(ap)
d939 1
a939 3
	} */ *ap;
{

d971 1
d973 2
a974 1
cd9660_enotsupp()
d983 7
a989 9
#define cd9660_create \
	((int (*) __P((struct  vop_create_args *)))cd9660_enotsupp)
#define cd9660_mknod ((int (*) __P((struct  vop_mknod_args *)))cd9660_enotsupp)
#define cd9660_setattr \
	((int (*) __P((struct  vop_setattr_args *)))cd9660_enotsupp)
#define cd9660_write ((int (*) __P((struct  vop_write_args *)))cd9660_enotsupp)
#ifdef NFSSERVER
int	lease_check __P((struct vop_lease_args *));
#define	cd9660_lease_check lease_check
d991 1
a991 1
#define	cd9660_lease_check ((int (*) __P((struct vop_lease_args *)))nullop)
d993 11
a1003 24
#define cd9660_fsync ((int (*) __P((struct  vop_fsync_args *)))nullop)
#define cd9660_remove \
	((int (*) __P((struct  vop_remove_args *)))cd9660_enotsupp)
#define cd9660_link ((int (*) __P((struct  vop_link_args *)))cd9660_enotsupp)
#define cd9660_rename \
	((int (*) __P((struct  vop_rename_args *)))cd9660_enotsupp)
#define cd9660_mkdir ((int (*) __P((struct  vop_mkdir_args *)))cd9660_enotsupp)
#define cd9660_rmdir ((int (*) __P((struct  vop_rmdir_args *)))cd9660_enotsupp)
#define cd9660_symlink \
	((int (*) __P((struct vop_symlink_args *)))cd9660_enotsupp)
#define cd9660_advlock \
	((int (*) __P((struct vop_advlock_args *)))cd9660_enotsupp)
#define cd9660_valloc ((int(*) __P(( \
		struct vnode *pvp, \
		int mode, \
		struct ucred *cred, \
		struct vnode **vpp))) cd9660_enotsupp)
#define cd9660_vfree ((int (*) __P((struct  vop_vfree_args *)))cd9660_enotsupp)
#define cd9660_truncate \
	((int (*) __P((struct  vop_truncate_args *)))cd9660_enotsupp)
#define cd9660_update \
	((int (*) __P((struct  vop_update_args *)))cd9660_enotsupp)
#define cd9660_bwrite \
	((int (*) __P((struct  vop_bwrite_args *)))cd9660_enotsupp)
d1008 1
a1008 1
int (**cd9660_vnodeop_p)();
d1052 1
a1052 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d1060 1
a1060 1
int (**cd9660_specop_p)();
d1104 1
a1104 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
d1110 1
a1110 1
int (**cd9660_fifoop_p)();
d1154 1
a1154 1
	{ (struct vnodeop_desc*)NULL, (int(*)())NULL }
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: cd9660_vnops.c,v 1.24 1995/07/24 21:19:27 cgd Exp $	*/
a235 1
#if ISO_DEFAULT_BLOCK_SIZE >= NBPG
d241 1
a241 1
#else
d243 2
a244 2
#define doclusterread 0
#endif
d286 1
a286 1
		if (doclusterread) {
d794 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
