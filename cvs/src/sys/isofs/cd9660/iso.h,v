head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.16
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.14
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.10
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.12
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.4
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.8
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.14.0.30
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.28
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.26
	OPENBSD_5_0:1.14.0.24
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.22
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.20
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.16
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.18
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.14
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.10
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.8
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.6
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.10.0.6
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.8.0.4
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.8.0.2
	OPENBSD_2_4_BASE:1.8
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.5.0.2
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.28.20.53.54;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.15.18.18.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2000.12.06.17.18.42;	author deraadt;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	99.07.01.02.20.22;	author d;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	98.05.30.02.28.38;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	97.11.08.17.21.09;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	97.11.06.05.58.13;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	97.10.06.20.19.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.15.08.47;	author csapuntz;	state Exp;
branches;
next	1.3;

1.3
date	96.04.21.22.26.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.10.12.30;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.9.4.1
date	2001.05.14.22.32.37;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	;

1.10.6.1
date	2002.06.11.03.29.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@/*	$OpenBSD: iso.h,v 1.14 2005/09/28 20:53:54 miod Exp $	*/
/*	$NetBSD: iso.h,v 1.20 1997/07/07 22:45:34 cgd Exp $	*/

/*-
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)iso.h	8.4 (Berkeley) 12/5/94
 */

/*
 * Definitions describing ISO9660 file system structure, as well as
 * the functions necessary to access fields of ISO9660 file system
 * structures.
 */

typedef uint32_t cdino_t;

#define ISODCL(from, to) (to - from + 1)

struct iso_volume_descriptor {
	char type[ISODCL(1,1)]; /* 711 */
	char id[ISODCL(2,6)];
	char version[ISODCL(7,7)];
	char data[ISODCL(8,2048)];
};

/* volume descriptor types */
#define ISO_VD_PRIMARY 1
#define ISO_VD_SUPPLEMENTARY 2
#define ISO_VD_END 255

#define ISO_STANDARD_ID "CD001"
#define ISO_ECMA_ID     "CDW01"

struct iso_primary_descriptor {
	char type			[ISODCL (  1,   1)]; /* 711 */
	char id				[ISODCL (  2,   6)];
	char version			[ISODCL (  7,   7)]; /* 711 */
	char unused1			[ISODCL (  8,   8)];
	char system_id			[ISODCL (  9,  40)]; /* achars */
	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
	char unused2			[ISODCL ( 73,  80)];
	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
	char unused3			[ISODCL ( 89, 120)];
	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
	char path_table_size		[ISODCL (133, 140)]; /* 733 */
	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
	char publisher_id		[ISODCL (319, 446)]; /* achars */
	char preparer_id		[ISODCL (447, 574)]; /* achars */
	char application_id		[ISODCL (575, 702)]; /* achars */
	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
	char unused4			[ISODCL (883, 883)];
	char application_data		[ISODCL (884, 1395)];
	char unused5			[ISODCL (1396, 2048)];
};
#define ISO_DEFAULT_BLOCK_SHIFT		11
#define ISO_DEFAULT_BLOCK_SIZE		(1<<ISO_DEFAULT_BLOCK_SHIFT)

/*
 * Used by Microsoft Joliet extension to ISO9660. Almost the same
 * as PVD, but byte position 8 is a flag, and 89-120 is for escape.
 */

struct iso_supplementary_descriptor {
	char type			[ISODCL (  1,   1)]; /* 711 */
	char id				[ISODCL (  2,   6)];
	char version			[ISODCL (  7,   7)]; /* 711 */
	char flags			[ISODCL (  8,   8)];
	char system_id			[ISODCL (  9,  40)]; /* achars */
	char volume_id			[ISODCL ( 41,  72)]; /* dchars */
	char unused2			[ISODCL ( 73,  80)];
	char volume_space_size		[ISODCL ( 81,  88)]; /* 733 */
	char escape			[ISODCL ( 89, 120)];
	char volume_set_size		[ISODCL (121, 124)]; /* 723 */
	char volume_sequence_number	[ISODCL (125, 128)]; /* 723 */
	char logical_block_size		[ISODCL (129, 132)]; /* 723 */
	char path_table_size		[ISODCL (133, 140)]; /* 733 */
	char type_l_path_table		[ISODCL (141, 144)]; /* 731 */
	char opt_type_l_path_table	[ISODCL (145, 148)]; /* 731 */
	char type_m_path_table		[ISODCL (149, 152)]; /* 732 */
	char opt_type_m_path_table	[ISODCL (153, 156)]; /* 732 */
	char root_directory_record	[ISODCL (157, 190)]; /* 9.1 */
	char volume_set_id		[ISODCL (191, 318)]; /* dchars */
	char publisher_id		[ISODCL (319, 446)]; /* achars */
	char preparer_id		[ISODCL (447, 574)]; /* achars */
	char application_id		[ISODCL (575, 702)]; /* achars */
	char copyright_file_id		[ISODCL (703, 739)]; /* 7.5 dchars */
	char abstract_file_id		[ISODCL (740, 776)]; /* 7.5 dchars */
	char bibliographic_file_id	[ISODCL (777, 813)]; /* 7.5 dchars */
	char creation_date		[ISODCL (814, 830)]; /* 8.4.26.1 */
	char modification_date		[ISODCL (831, 847)]; /* 8.4.26.1 */
	char expiration_date		[ISODCL (848, 864)]; /* 8.4.26.1 */
	char effective_date		[ISODCL (865, 881)]; /* 8.4.26.1 */
	char file_structure_version	[ISODCL (882, 882)]; /* 711 */
	char unused4			[ISODCL (883, 883)];
	char application_data		[ISODCL (884, 1395)];
	char unused5			[ISODCL (1396, 2048)];
};

struct iso_directory_record {
	char length			[ISODCL (1, 1)]; /* 711 */
	char ext_attr_length		[ISODCL (2, 2)]; /* 711 */
	u_char extent			[ISODCL (3, 10)]; /* 733 */
	u_char size			[ISODCL (11, 18)]; /* 733 */
	char date			[ISODCL (19, 25)]; /* 7 by 711 */
	char flags			[ISODCL (26, 26)];
	char file_unit_size		[ISODCL (27, 27)]; /* 711 */
	char interleave			[ISODCL (28, 28)]; /* 711 */
	char volume_sequence_number	[ISODCL (29, 32)]; /* 723 */
	char name_len			[ISODCL (33, 33)]; /* 711 */
	char name			[1];			/* XXX */
};
/* can't take sizeof(iso_directory_record), because of possible alignment
   of the last entry (34 instead of 33) */
#define ISO_DIRECTORY_RECORD_SIZE	33

struct iso_extended_attributes {
	u_char owner			[ISODCL (1, 4)]; /* 723 */
	u_char group			[ISODCL (5, 8)]; /* 723 */
	u_char perm			[ISODCL (9, 10)]; /* 9.5.3 */
	char ctime			[ISODCL (11, 27)]; /* 8.4.26.1 */
	char mtime			[ISODCL (28, 44)]; /* 8.4.26.1 */
	char xtime			[ISODCL (45, 61)]; /* 8.4.26.1 */
	char ftime			[ISODCL (62, 78)]; /* 8.4.26.1 */
	char recfmt			[ISODCL (79, 79)]; /* 711 */
	char recattr			[ISODCL (80, 80)]; /* 711 */
	u_char reclen			[ISODCL (81, 84)]; /* 723 */
	char system_id			[ISODCL (85, 116)]; /* achars */
	char system_use			[ISODCL (117, 180)];
	char version			[ISODCL (181, 181)]; /* 711 */
	char len_esc			[ISODCL (182, 182)]; /* 711 */
	char reserved			[ISODCL (183, 246)];
	u_char len_au			[ISODCL (247, 250)]; /* 723 */
};

static __inline int isonum_711(u_char *) __attribute__ ((__unused__));
static __inline int isonum_712(char *) __attribute__ ((__unused__));
static __inline int isonum_721(u_char *) __attribute__ ((__unused__));
static __inline int isonum_722(u_char *) __attribute__ ((__unused__));
static __inline int isonum_723(u_char *) __attribute__ ((__unused__));
static __inline int isonum_731(u_char *) __attribute__ ((__unused__));
static __inline int isonum_732(u_char *) __attribute__ ((__unused__));
static __inline int isonum_733(u_char *) __attribute__ ((__unused__));

/* 7.1.1: unsigned char */
static __inline int
isonum_711(u_char *p)
{
	return *p;
}

/* 7.1.2: signed(?) char */
static __inline int
isonum_712(char *p)
{
	return *p;
}

/* 7.2.1: unsigned little-endian 16-bit value.  NOT USED IN KERNEL. */
static __inline int
isonum_721(p)
	u_char *p;
{
#if !defined(__STRICT_ALIGNMENT) && (BYTE_ORDER == LITTLE_ENDIAN)
	return *(u_int16_t *)p;
#else
	return *p|((char)p[1] << 8);
#endif
}

/* 7.2.2: unsigned big-endian 16-bit value.  NOT USED IN KERNEL. */
static __inline int     
isonum_722(p)
	unsigned char *p;
{
#if !defined(__STRICT_ALIGNMENT) && (BYTE_ORDER == BIG_ENDIAN)
	return *(u_int16_t *)p;
#else
	return ((char)*p << 8)|p[1];
#endif
} 

/* 7.2.3: unsigned both-endian (little, then big) 16-bit value */
static __inline int
isonum_723(u_char *p)
{
#if !defined(__STRICT_ALIGNMENT) && \
    ((BYTE_ORDER == LITTLE_ENDIAN) || (BYTE_ORDER == BIG_ENDIAN))
#if BYTE_ORDER == LITTLE_ENDIAN
	return *(u_int16_t *)p;
#else
	return *(u_int16_t *)(p + 2);
#endif
#else /* __STRICT_ALIGNMENT or weird byte order */
	return *p|(p[1] << 8);
#endif
}

/* 7.3.1: unsigned little-endian 32-bit value.  NOT USED IN KERNEL. */
static __inline int
isonum_731(p)
	u_char *p;
{
#if !defined(__STRICT_ALIGNMENT) && (BYTE_ORDER == LITTLE_ENDIAN)
	return *(u_int32_t *)p;
#else
	return *p|(p[1] << 8)|(p[2] << 16)|(p[3] << 24);
#endif
}

/* 7.3.2: unsigned big-endian 32-bit value.  NOT USED IN KERNEL. */
static __inline int
isonum_732(p)
	unsigned char *p;
{
#if !defined(__STRICT_ALIGNMENT) && (BYTE_ORDER == BIG_ENDIAN)
	return *(u_int32_t *)p;
#else
	return (*p << 24)|(p[1] << 16)|(p[2] << 8)|p[3];
#endif
}

/* 7.3.3: unsigned both-endian (little, then big) 32-bit value */
static __inline int
isonum_733(u_char *p)
{
#if !defined(__STRICT_ALIGNMENT) && \
    ((BYTE_ORDER == LITTLE_ENDIAN) || (BYTE_ORDER == BIG_ENDIAN))
#if BYTE_ORDER == LITTLE_ENDIAN
	return *(u_int32_t *)p;
#else
	return *(u_int32_t *)(p + 4);
#endif
#else /* __STRICT_ALIGNMENT or weird byte order */
	return *p|(p[1] << 8)|(p[2] << 16)|(p[3] << 24);
#endif
}

/*
 * Associated files have a leading '='.
 */
#define	ASSOCCHAR	'='
@


1.14
log
@No part of the code defines UNALIGNED_ACCESS, use reverted tests for
__STRICT_ALIGNMENT instead.

Help pedro@@ deraadt@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.13 2003/06/02 23:28:05 millert Exp $	*/
d45 2
@


1.13
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.12 2002/03/15 18:18:09 millert Exp $	*/
d206 2
a207 2
#if defined(UNALIGNED_ACCESS) && (BYTE_ORDER == LITTLE_ENDIAN)
	return *(u_int16t *)p;
d218 2
a219 2
#if defined(UNALIGNED_ACCESS) && (BYTE_ORDER == BIG_ENDIAN)
	return *(u_int16t *)p;
d229 1
a229 1
#if defined(UNALIGNED_ACCESS) && \
d232 1
a232 1
	return *(u_int16t *)p;
d234 1
a234 1
	return *(u_int16t *)(p + 2);
d236 1
a236 1
#else /* !UNALIGNED_ACCESS or weird byte order */
d246 2
a247 2
#if defined(UNALIGNED_ACCESS) && (BYTE_ORDER == LITTLE_ENDIAN)
	return *(u_int32t *)p;
d258 2
a259 2
#if defined(UNALIGNED_ACCESS) && (BYTE_ORDER == BIG_ENDIAN)
	return *(u_int32t *)p;
d269 1
a269 1
#if defined(UNALIGNED_ACCESS) && \
d272 1
a272 1
	return *(u_int32t *)p;
d274 1
a274 1
	return *(u_int32t *)(p + 4);
d276 1
a276 1
#else /* !UNALIGNED_ACCESS or weird byte order */
@


1.12
log
@Kill some #if __STDC__ used with 8bit function args; we live in an ANSI world
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.11 2002/03/14 01:27:03 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.10 2000/12/06 17:18:42 deraadt Exp $	*/
a192 1
#if __STDC__
a193 4
#else
isonum_711(p)
	u_char *p;
#endif
a199 1
#if __STDC__
a200 4
#else
isonum_712(p)
	char *p;
#endif
a230 1
#if __STDC__
a231 4
#else
isonum_723(p)
	u_char *p;
#endif
a270 1
#if __STDC__
a271 4
#else
isonum_733(p)
	u_char *p;
#endif
@


1.10
log
@use __x__ formats for __attribute__ arguments; guenther@@gac.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.9 1999/07/01 02:20:22 d Exp $	*/
d182 8
a189 8
static __inline int isonum_711 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_712 __P((char *)) __attribute__ ((__unused__));
static __inline int isonum_721 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_722 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_723 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_731 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_732 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_733 __P((u_char *)) __attribute__ ((__unused__));
@


1.10.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.10 2000/12/06 17:18:42 deraadt Exp $	*/
d182 8
a189 8
static __inline int isonum_711(u_char *) __attribute__ ((__unused__));
static __inline int isonum_712(char *) __attribute__ ((__unused__));
static __inline int isonum_721(u_char *) __attribute__ ((__unused__));
static __inline int isonum_722(u_char *) __attribute__ ((__unused__));
static __inline int isonum_723(u_char *) __attribute__ ((__unused__));
static __inline int isonum_731(u_char *) __attribute__ ((__unused__));
static __inline int isonum_732(u_char *) __attribute__ ((__unused__));
static __inline int isonum_733(u_char *) __attribute__ ((__unused__));
d193 1
d195 4
d205 1
d207 4
d241 1
d243 4
d286 1
d288 4
@


1.9
log
@Add support for Joliet extensions. From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.8 1998/05/30 02:28:38 mickey Exp $	*/
d182 8
a189 8
static __inline int isonum_711 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_712 __P((char *)) __attribute__ ((unused));
static __inline int isonum_721 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_722 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_723 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_731 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_732 __P((u_char *)) __attribute__ ((unused));
static __inline int isonum_733 __P((u_char *)) __attribute__ ((unused));
@


1.9.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.10 2000/12/06 17:18:42 deraadt Exp $	*/
d182 8
a189 8
static __inline int isonum_711 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_712 __P((char *)) __attribute__ ((__unused__));
static __inline int isonum_721 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_722 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_723 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_731 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_732 __P((u_char *)) __attribute__ ((__unused__));
static __inline int isonum_733 __P((u_char *)) __attribute__ ((__unused__));
@


1.9.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d182 8
a189 8
static __inline int isonum_711(u_char *) __attribute__ ((__unused__));
static __inline int isonum_712(char *) __attribute__ ((__unused__));
static __inline int isonum_721(u_char *) __attribute__ ((__unused__));
static __inline int isonum_722(u_char *) __attribute__ ((__unused__));
static __inline int isonum_723(u_char *) __attribute__ ((__unused__));
static __inline int isonum_731(u_char *) __attribute__ ((__unused__));
static __inline int isonum_732(u_char *) __attribute__ ((__unused__));
static __inline int isonum_733(u_char *) __attribute__ ((__unused__));
d193 1
d195 4
d205 1
d207 4
d241 1
d243 4
d286 1
d288 4
@


1.9.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.9.4.2 2002/03/28 15:02:00 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.8
log
@define ISO_DEFAULT_BLOCK_SHIFT and redefine ISO_DEFAULT_BLOCK_SIZE through it
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.7 1997/11/08 17:21:09 niklas Exp $	*/
d61 1
d104 41
@


1.7
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.6 1997/11/06 05:58:13 csapuntz Exp $	*/
d101 2
a102 1
#define ISO_DEFAULT_BLOCK_SIZE		2048
@


1.6
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: iso.h,v 1.5 1997/10/06 20:19:47 deraadt Exp $	*/
/*	$NetBSD: iso.h,v 1.11 1996/03/16 20:25:42 ws Exp $	*/
d44 6
d139 8
a146 60
/* CD-ROM Format type */
enum ISO_FTYPE  { ISO_FTYPE_DEFAULT, ISO_FTYPE_9660, ISO_FTYPE_RRIP, ISO_FTYPE_ECMA };

#ifndef	ISOFSMNT_ROOT
#define	ISOFSMNT_ROOT	0
#endif

struct iso_mnt {
	int im_flags;

	struct mount *im_mountp;
	dev_t im_dev;
	struct vnode *im_devvp;

	int logical_block_size;
	int im_bshift;
	int im_bmask;
	
	int volume_space_size;
	struct netexport im_export;
	
	char root[ISODCL (157, 190)];
	int root_extent;
	int root_size;
	enum ISO_FTYPE  iso_ftype;
	
	int rr_skip;
	int rr_skip0;
};

#define VFSTOISOFS(mp)	((struct iso_mnt *)((mp)->mnt_data))

#define blkoff(imp, loc)	((loc) & (imp)->im_bmask)
#define lblktosize(imp, blk)	((blk) << (imp)->im_bshift)
#define lblkno(imp, loc)	((loc) >> (imp)->im_bshift)
#define blksize(imp, ip, lbn)	((imp)->logical_block_size)

int cd9660_mount __P((struct mount *,
	    char *, caddr_t, struct nameidata *, struct proc *));
int cd9660_start __P((struct mount *, int, struct proc *));
int cd9660_unmount __P((struct mount *, int, struct proc *));
int cd9660_root __P((struct mount *, struct vnode **));
int cd9660_quotactl __P((struct mount *, int, uid_t, caddr_t, struct proc *));
int cd9660_statfs __P((struct mount *, struct statfs *, struct proc *));
int cd9660_sync __P((struct mount *, int, struct ucred *, struct proc *));
int cd9660_vget __P((struct mount *, ino_t, struct vnode **));
int cd9660_fhtovp __P((struct mount *, struct fid *, struct mbuf *,
	    struct vnode **, int *, struct ucred **));
int cd9660_vptofh __P((struct vnode *, struct fid *));
int cd9660_init __P((struct vfsconf *));
#define cd9660_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *)))eopnotsupp)

int cd9660_mountroot __P((void)); 

extern int (**cd9660_vnodeop_p) __P((void *));
extern int (**cd9660_specop_p) __P((void *));
#ifdef FIFO
extern int (**cd9660_fifoop_p) __P((void *));
#endif
d148 1
d160 1
d172 1
a172 2
#ifndef UNALIGNED_ACCESS

d174 5
a178 2
#if __STDC__
isonum_723(u_char *p)
d180 1
a180 2
isonum_723(p)
	u_char *p;
a181 2
{
	return *p|(p[1] << 8);
d184 7
a190 3
static __inline int
#if __STDC__
isonum_733(u_char *p)
d192 1
a192 2
isonum_733(p)
	u_char *p;
d194 1
a194 7
{
	return *p|(p[1] << 8)|(p[2] << 16)|(p[3] << 24);
}

#else /* UNALIGNED_ACCESS */

#if BYTE_ORDER == LITTLE_ENDIAN
d196 1
d205 3
d209 6
d217 1
d219 1
a219 4
#if __STDC__
isonum_733(u_char *p)
#else
isonum_733(p)
a220 1
#endif
d222 1
d224 3
d229 1
a229 4
#endif

#if BYTE_ORDER == BIG_ENDIAN

d231 5
a235 2
#if __STDC__
isonum_723(u_char *p)
d237 1
a237 2
isonum_723(p)
	u_char *p;
a238 2
{
	return *(u_int16t *)(p + 2);
d241 1
d250 5
d256 4
a260 8

#endif

#endif /* UNALIGNED_ACCESS */

int isofncmp __P((u_char *, int, u_char *, int));
void isofntrans __P((u_char *, int, u_char *, u_short *, int, int));
ino_t isodirino __P((struct iso_directory_record *, struct iso_mnt *));
@


1.5
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.3 1996/04/21 22:26:41 deraadt Exp $	*/
d182 3
a184 1
void cd9660_init __P((void));
@


1.4
log
@VFS Lite2 Changes
@
text
@d182 1
a182 3
int cd9660_init __P((struct vfsconf *));
#define cd9660_sysctl ((int (*) __P((int *, u_int, void *, size_t *, void *, \
                                    size_t, struct proc *)))eopnotsupp)
@


1.3
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: iso.h,v 1.2 1996/02/29 10:12:30 niklas Exp $	*/
d182 3
a184 1
void cd9660_init __P((void));
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: iso.h,v 1.10 1996/02/09 21:32:11 christos Exp $	*/
d247 1
a247 1
	u_char *p
d273 1
a273 1
	u_char *p
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: iso.h,v 1.9 1995/01/18 09:23:19 mycroft Exp $	*/
d182 1
a182 1
int cd9660_init __P(());
d186 2
a187 2
extern int (**cd9660_vnodeop_p)();
extern int (**cd9660_specop_p)();
d189 1
a189 1
extern int (**cd9660_fifoop_p)();
d193 3
d198 1
d204 3
d209 1
d217 3
d222 1
d228 3
d233 1
d243 3
d248 1
d254 3
d259 1
d269 3
d274 1
d280 3
d285 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
