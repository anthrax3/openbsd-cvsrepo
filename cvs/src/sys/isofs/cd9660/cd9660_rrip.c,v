head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.6
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.8
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.9.0.18
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.16
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.12
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.14
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.10
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.8
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.6
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.14
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.12
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.10
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.8
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.6
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.4
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.14
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.12
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.10
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4
	OPENBSD_2_2:1.3.0.6
	OPENBSD_2_2_BASE:1.3
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.12;
commitid	p4LJxGKbi0BU2cG6;

1.12
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.11;
commitid	P6Av4XGqOi3rFasL;

1.11
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.14.21.13.43;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.07.01.02.20.21;	author d;	state Exp;
branches
	1.5.4.1
	1.5.14.1;
next	1.4;

1.4
date	97.11.08.17.21.07;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.10.04.03.05.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.10.12.22;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.5.4.1
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.16.00.29.43;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2003.06.07.11.03.39;	author ho;	state Exp;
branches;
next	;

1.5.14.1
date	2002.06.11.03.29.20;	author art;	state Exp;
branches;
next	1.5.14.2;

1.5.14.2
date	2003.05.19.21.53.27;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: cd9660_rrip.c,v 1.12 2014/12/16 18:30:03 tedu Exp $	*/
/*	$NetBSD: cd9660_rrip.c,v 1.17 1997/01/24 00:27:32 cgd Exp $	*/

/*-
 * Copyright (c) 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cd9660_rrip.c	8.6 (Berkeley) 12/5/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/kernel.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/time.h>

#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/cd9660_node.h>
#include <isofs/cd9660/cd9660_rrip.h>
#include <isofs/cd9660/iso_rrip.h>

typedef struct {
	char type[2];
	int (*func)(void *, ISO_RRIP_ANALYZE *);
	void (*func2)(void *, ISO_RRIP_ANALYZE *);
	int result;
} RRIP_TABLE;

static int cd9660_rrip_attr(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defattr(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_slink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_altname(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defname(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_pclink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_reldir(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_tstamp(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_deftstamp(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_device(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_idflag(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_cont(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_stop(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_extref(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_loop(struct iso_directory_record *,
    ISO_RRIP_ANALYZE *, RRIP_TABLE *);
/*
 * POSIX file attribute
 */
static int
cd9660_rrip_attr(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_ATTR *p = v;

	ana->inop->inode.iso_mode = isonum_733(p->mode);
	ana->inop->inode.iso_uid = isonum_733(p->uid);
	ana->inop->inode.iso_gid = isonum_733(p->gid);
	ana->inop->inode.iso_links = isonum_733(p->links);
	ana->fields &= ~ISO_SUSP_ATTR;
	return (ISO_SUSP_ATTR);
}

static void
cd9660_rrip_defattr(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	struct iso_directory_record *isodir = v;

	/* But this is a required field! */
	printf("RRIP without PX field?\n");
	cd9660_defattr(isodir, ana->inop, NULL);
}

/*
 * Symbolic Links
 */
static int
cd9660_rrip_slink(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_SLINK  *p = v;
	register ISO_RRIP_SLINK_COMPONENT *pcomp;
	register ISO_RRIP_SLINK_COMPONENT *pcompe;
	int len, wlen, cont;
	char *outbuf, *inbuf;
	
	pcomp = (ISO_RRIP_SLINK_COMPONENT *)p->component;
	pcompe =
	    (ISO_RRIP_SLINK_COMPONENT *)((char *)p + isonum_711(p->h.length));
	len = *ana->outlen;
	outbuf = ana->outbuf;
	cont = ana->cont;
	
	/*
	 * Gathering a Symbolic name from each component with path
	 */
	for (; pcomp < pcompe;
	    pcomp = (ISO_RRIP_SLINK_COMPONENT *)
	    ((char *)pcomp + ISO_RRIP_SLSIZ + isonum_711(pcomp->clen))) {
		
		if (!cont) {
			if (len < ana->maxlen) {
				len++;
				*outbuf++ = '/';
			}
		}
		cont = 0;
		
		inbuf = "..";
		wlen = 0;
		
		switch (*pcomp->cflag) {
			
		case ISO_SUSP_CFLAG_CURRENT:
			/* Inserting Current */
			wlen = 1;
			break;
			
		case ISO_SUSP_CFLAG_PARENT:
			/* Inserting Parent */
			wlen = 2;
			break;
			
		case ISO_SUSP_CFLAG_ROOT:
			/* Inserting slash for ROOT */
			/* start over from beginning(?) */
			outbuf -= len;
			len = 0;
			break;
			
		case ISO_SUSP_CFLAG_VOLROOT:
			/* Inserting a mount point i.e. "/cdrom" */
			/* same as above */
			outbuf -= len;
			len = 0;
			inbuf = ana->imp->im_mountp->mnt_stat.f_mntonname;
			wlen = strlen(inbuf);
			break;
			
		case ISO_SUSP_CFLAG_HOST:
			/* Inserting hostname i.e. "kurt.tools.de" */
			inbuf = hostname;
			wlen = hostnamelen;
			break;
			
		case ISO_SUSP_CFLAG_CONTINUE:
			cont = 1;
			/* FALLTHROUGH */
		case 0:
			/* Inserting component */
			wlen = isonum_711(pcomp->clen);
			inbuf = pcomp->name;
			break;
		default:
			printf("RRIP with incorrect flags?");
			wlen = ana->maxlen + 1;
			break;
		}
		
		if (len + wlen > ana->maxlen) {
			/* indicate error to caller */
			ana->cont = 1;
			ana->fields = 0;
			ana->outbuf -= *ana->outlen;
			*ana->outlen = 0;
			return (0);
		}
		
		bcopy(inbuf, outbuf, wlen);
		outbuf += wlen;
		len += wlen;
	}
	ana->outbuf = outbuf;
	*ana->outlen = len;
	ana->cont = cont;
	
	if (!isonum_711(p->flags)) {
		ana->fields &= ~ISO_SUSP_SLINK;
		return (ISO_SUSP_SLINK);
	}
	return (0);
}

/*
 * Alternate name
 */
static int
cd9660_rrip_altname(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_ALTNAME *p = v;
	char *inbuf;
	int wlen;
	int cont;
	
	inbuf = "..";
	wlen = 0;
	cont = 0;
	
	switch (*p->flags) {
	case ISO_SUSP_CFLAG_CURRENT:
		/* Inserting Current */
		wlen = 1;
		break;
		
	case ISO_SUSP_CFLAG_PARENT:
		/* Inserting Parent */
		wlen = 2;
		break;
		
	case ISO_SUSP_CFLAG_HOST:
		/* Inserting hostname i.e. "kurt.tools.de" */
		inbuf = hostname;
		wlen = hostnamelen;
		break;
		
	case ISO_SUSP_CFLAG_CONTINUE:
		cont = 1;
		/* FALLTHROUGH */
	case 0:
		/* Inserting component */
		wlen = isonum_711(p->h.length) - 5;
		inbuf = (char *)p + 5;
		break;
		
	default:
		printf("RRIP with incorrect NM flags?\n");
		wlen = ana->maxlen + 1;
		break;
	}
	
	if ((*ana->outlen += wlen) > ana->maxlen) {
		/* treat as no name field */
		ana->fields &= ~ISO_SUSP_ALTNAME;
		ana->outbuf -= *ana->outlen - wlen;
		*ana->outlen = 0;
		return (0);
	}
	
	bcopy(inbuf, ana->outbuf, wlen);
	ana->outbuf += wlen;
	
	if (!cont) {
		ana->fields &= ~ISO_SUSP_ALTNAME;
		return (ISO_SUSP_ALTNAME);
	}
	return (0);
}

static void
cd9660_rrip_defname(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	struct iso_directory_record *isodir = v;

	strlcpy(ana->outbuf, "..", ana->maxlen - *ana->outlen);
	switch (*isodir->name) {
	default:
		isofntrans(isodir->name, isonum_711(isodir->name_len),
		    ana->outbuf, ana->outlen, 1,
		    isonum_711(isodir->flags) & 4, ana->imp->joliet_level);
		break;
	case 0:
		*ana->outlen = 1;
		break;
	case 1:
		*ana->outlen = 2;
		break;
	}
}

/*
 * Parent or Child Link
 */
static int
cd9660_rrip_pclink(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_CLINK  *p = v;

	*ana->inump = isonum_733(p->dir_loc) << ana->imp->im_bshift;
	ana->fields &= ~(ISO_SUSP_CLINK | ISO_SUSP_PLINK);
	return (*p->h.type == 'C' ? ISO_SUSP_CLINK : ISO_SUSP_PLINK);
}

/*
 * Relocated directory
 */
/*ARGSUSED*/
static int
cd9660_rrip_reldir(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	/* special hack to make caller aware of RE field */
	*ana->outlen = 0;
	ana->fields = 0;
	return (ISO_SUSP_RELDIR | ISO_SUSP_ALTNAME | ISO_SUSP_CLINK |
	    ISO_SUSP_PLINK);
}

static int
cd9660_rrip_tstamp(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_TSTAMP *p = v;
	u_char *ptime;
	
	ptime = p->time;
	
	/* Check a format of time stamp (7bytes/17bytes) */
	if (!(*p->flags & ISO_SUSP_TSTAMP_FORM17)) {
		if (*p->flags & ISO_SUSP_TSTAMP_CREAT)
			ptime += 7;
		
		if (*p->flags & ISO_SUSP_TSTAMP_MODIFY) {
			cd9660_tstamp_conv7(ptime,
			    &ana->inop->inode.iso_mtime);
			ptime += 7;
		} else
			bzero(&ana->inop->inode.iso_mtime,
			    sizeof(struct timespec));
		
		if (*p->flags & ISO_SUSP_TSTAMP_ACCESS) {
			cd9660_tstamp_conv7(ptime,
			    &ana->inop->inode.iso_atime);
			ptime += 7;
		} else
			ana->inop->inode.iso_atime =
			    ana->inop->inode.iso_mtime;
		
		if (*p->flags & ISO_SUSP_TSTAMP_ATTR)
			cd9660_tstamp_conv7(ptime,
			    &ana->inop->inode.iso_ctime);
		else
			ana->inop->inode.iso_ctime =
			    ana->inop->inode.iso_mtime;
		
	} else {
		if (*p->flags & ISO_SUSP_TSTAMP_CREAT)
			ptime += 17;
		
		if (*p->flags & ISO_SUSP_TSTAMP_MODIFY) {
			cd9660_tstamp_conv17(ptime,
			    &ana->inop->inode.iso_mtime);
			ptime += 17;
		} else
			bzero(&ana->inop->inode.iso_mtime,
			    sizeof(struct timespec));
		
		if (*p->flags & ISO_SUSP_TSTAMP_ACCESS) {
			cd9660_tstamp_conv17(ptime,
			    &ana->inop->inode.iso_atime);
			ptime += 17;
		} else
			ana->inop->inode.iso_atime =
			    ana->inop->inode.iso_mtime;
		
		if (*p->flags & ISO_SUSP_TSTAMP_ATTR)
			cd9660_tstamp_conv17(ptime,
			    &ana->inop->inode.iso_ctime);
		else
			ana->inop->inode.iso_ctime =
			    ana->inop->inode.iso_mtime;
		
	}
	ana->fields &= ~ISO_SUSP_TSTAMP;
	return (ISO_SUSP_TSTAMP);
}

static void
cd9660_rrip_deftstamp(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	struct iso_directory_record  *isodir = v;

	cd9660_deftstamp(isodir, ana->inop, NULL);
}

/*
 * POSIX device modes
 */
static int
cd9660_rrip_device(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_DEVICE *p = v;
	u_int high, low;
	
	high = isonum_733(p->dev_t_high);
	low  = isonum_733(p->dev_t_low);
	
	if (high == 0)
		ana->inop->inode.iso_rdev = makedev(major(low), minor(low));
	else
		ana->inop->inode.iso_rdev = makedev(high, minor(low));
	ana->fields &= ~ISO_SUSP_DEVICE;
	return (ISO_SUSP_DEVICE);
}

/*
 * Flag indicating
 */
static int
cd9660_rrip_idflag(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_IDFLAG *p = v;

	/* don't touch high bits */
	ana->fields &= isonum_711(p->flags) | ~0xff;
	/* special handling of RE field */
	if (ana->fields & ISO_SUSP_RELDIR)
		return (cd9660_rrip_reldir(p, ana));
	
	return (ISO_SUSP_IDFLAG);
}

/*
 * Continuation pointer
 */
static int
cd9660_rrip_cont(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_CONT *p = v;

	ana->iso_ce_blk = isonum_733(p->location);
	ana->iso_ce_off = isonum_733(p->offset);
	ana->iso_ce_len = isonum_733(p->length);
	return (ISO_SUSP_CONT);
}

/*
 * System Use end
 */
static int
cd9660_rrip_stop(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	return (ISO_SUSP_STOP);
}

/*
 * Extension reference
 */
static int
cd9660_rrip_extref(v, ana)
	void *v;
	ISO_RRIP_ANALYZE *ana;
{
	ISO_RRIP_EXTREF *p = v;

	if (isonum_711(p->version) != 1)
		return (0);
	if (isonum_711(p->len_id) != 9 &&
	    isonum_711(p->len_id) != 10)
		return (0);
	if (isonum_711(p->len_id) == 9 &&
	    bcmp((char *)p + 8, "IEEE_1282", 9))
		return (0);
	if (isonum_711(p->len_id) == 10 &&
	    bcmp((char *)p + 8, "IEEE_P1282", 10) &&
	    bcmp((char *)p + 8, "RRIP_1991A", 10))
		return (0);
	ana->fields &= ~ISO_SUSP_EXTREF;
	return (ISO_SUSP_EXTREF);
}


static int
cd9660_rrip_loop(isodir, ana, table)
	struct iso_directory_record *isodir;
	ISO_RRIP_ANALYZE *ana;
	RRIP_TABLE *table;
{
	register RRIP_TABLE *ptable;
	register ISO_SUSP_HEADER *phead;
	register ISO_SUSP_HEADER *pend;
	struct buf *bp = NULL;
	char *pwhead;
	u_char c;
	int result;
	
	/*
	 * Note: If name length is odd,
	 *       it will be padded by 1 byte after the name
	 */
	pwhead = isodir->name + isonum_711(isodir->name_len);
	if (!(isonum_711(isodir->name_len) & 1))
		pwhead++;
	isochar(isodir->name, pwhead, ana->imp->joliet_level, &c);
	
	/* If it's not the '.' entry of the root dir obey SP field */
	if (c != 0 || isonum_733(isodir->extent) != ana->imp->root_extent)
		pwhead += ana->imp->rr_skip;
	else
		pwhead += ana->imp->rr_skip0;
	
	phead = (ISO_SUSP_HEADER *)pwhead;
	pend =
	    (ISO_SUSP_HEADER *)((char *)isodir + isonum_711(isodir->length));
	
	result = 0;
	while (1) {
		ana->iso_ce_len = 0;
		/*
		 * Note: "pend" should be more than one SUSP header
		 */ 
		while (pend >= phead + 1) {
			if (isonum_711(phead->version) == 1) {
				for (ptable = table; ptable->func; ptable++) {
					if (*phead->type == *ptable->type &&
					    phead->type[1] == ptable->type[1])
					    {
						result |=
						    ptable->func(phead, ana);
						break;
					}
				}
				if (!ana->fields)
					break;
			}
			if (result & ISO_SUSP_STOP) {
				result &= ~ISO_SUSP_STOP;
				break;
			}
			/* plausibility check */
			if (isonum_711(phead->length) < sizeof(*phead))
				break;
			/*
			 * move to next SUSP
			 * Hopefully this works with newer versions, too
			 */
			phead = (ISO_SUSP_HEADER *)
			    ((char *)phead + isonum_711(phead->length));
		}
		
		if (ana->fields && ana->iso_ce_len) {
			if (ana->iso_ce_blk >= ana->imp->volume_space_size ||
			    ana->iso_ce_off + ana->iso_ce_len >
			    ana->imp->logical_block_size ||
			    bread(ana->imp->im_devvp, ana->iso_ce_blk <<
			    (ana->imp->im_bshift - DEV_BSHIFT),
			    ana->imp->logical_block_size, &bp))
				/* what to do now? */
				break;
			phead =
			    (ISO_SUSP_HEADER *)(bp->b_data + ana->iso_ce_off);
			pend = (ISO_SUSP_HEADER *)
			    ((char *)phead + ana->iso_ce_len);
		} else
			break;
	}
	if (bp)
		brelse(bp);
	/*
	 * If we don't find the Basic SUSP stuffs, just set default value
	 *   (attribute/time stamp)
	 */
	for (ptable = table; ptable->func2; ptable++)
		if (!(ptable->result & result))
			ptable->func2(isodir, ana);
	
	return (result);
}

/*
 * Get Attributes.
 */
static RRIP_TABLE rrip_table_analyze[] = {
	{ "PX", cd9660_rrip_attr,	cd9660_rrip_defattr,
	    ISO_SUSP_ATTR },
	{ "TF", cd9660_rrip_tstamp,	cd9660_rrip_deftstamp,
	    ISO_SUSP_TSTAMP },
	{ "PN", cd9660_rrip_device,	0,
	    ISO_SUSP_DEVICE },
	{ "RR", cd9660_rrip_idflag,	0,
	    ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,
	    ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,
	    ISO_SUSP_STOP },
	{ "",	0,			0,
	    0 }
};

int
cd9660_rrip_analyze(isodir, inop, imp)
	struct iso_directory_record *isodir;
	struct iso_node *inop;
	struct iso_mnt *imp;
{
	ISO_RRIP_ANALYZE analyze;
	
	analyze.inop = inop;
	analyze.imp = imp;
	analyze.fields = ISO_SUSP_ATTR | ISO_SUSP_TSTAMP | ISO_SUSP_DEVICE;
	
	return (cd9660_rrip_loop(isodir, &analyze, rrip_table_analyze));
}

/* 
 * Get Alternate Name.
 */
static RRIP_TABLE rrip_table_getname[] = {
	{ "NM", cd9660_rrip_altname,	cd9660_rrip_defname,
	    ISO_SUSP_ALTNAME },
	{ "CL", cd9660_rrip_pclink,	0,
	    ISO_SUSP_CLINK|ISO_SUSP_PLINK },
	{ "PL", cd9660_rrip_pclink,	0,
	    ISO_SUSP_CLINK|ISO_SUSP_PLINK },
	{ "RE", cd9660_rrip_reldir,	0,
	    ISO_SUSP_RELDIR },
	{ "RR", cd9660_rrip_idflag,	0,
	    ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,
	    ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,
	    ISO_SUSP_STOP },
	{ "",	0,			0,
	    0 }
};

int
cd9660_rrip_getname(isodir, outbuf, outlen, inump, imp)
	struct iso_directory_record *isodir;
	char *outbuf;
	u_short *outlen;
	cdino_t *inump;
	struct iso_mnt *imp;
{
	ISO_RRIP_ANALYZE analyze;
	RRIP_TABLE *tab;
	u_char c;
	
	analyze.outbuf = outbuf;
	analyze.outlen = outlen;
	analyze.maxlen = NAME_MAX;
	analyze.inump = inump;
	analyze.imp = imp;
	analyze.fields = ISO_SUSP_ALTNAME | ISO_SUSP_RELDIR | ISO_SUSP_CLINK |
	    ISO_SUSP_PLINK;
	*outlen = 0;
	
	isochar(isodir->name, isodir->name + isonum_711(isodir->name_len),
	    imp->joliet_level, &c);
	tab = rrip_table_getname;
	if (c == 0 || c == 1) {
		cd9660_rrip_defname(isodir, &analyze);
		
		analyze.fields &= ~ISO_SUSP_ALTNAME;
		tab++;
	}
	
	return (cd9660_rrip_loop(isodir, &analyze, tab));
}

/* 
 * Get Symbolic Link.
 */
static RRIP_TABLE rrip_table_getsymname[] = {
	{ "SL", cd9660_rrip_slink,	0,	ISO_SUSP_SLINK },
	{ "RR", cd9660_rrip_idflag,	0,	ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,	ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,	ISO_SUSP_STOP },
	{ "",	0,			0,	0 }
};

int
cd9660_rrip_getsymname(isodir, outbuf, outlen, imp)
	struct iso_directory_record *isodir;
	char *outbuf;
	u_short *outlen;
	struct iso_mnt *imp;
{
	ISO_RRIP_ANALYZE analyze;
	
	analyze.outbuf = outbuf;
	analyze.outlen = outlen;
	*outlen = 0;
	analyze.maxlen = MAXPATHLEN;
	analyze.cont = 1;		/* don't start with a slash */
	analyze.imp = imp;
	analyze.fields = ISO_SUSP_SLINK;
	
	return (cd9660_rrip_loop(isodir, &analyze, rrip_table_getsymname) &
	    ISO_SUSP_SLINK);
}

static RRIP_TABLE rrip_table_extref[] = {
	{ "ER", cd9660_rrip_extref,	0,	ISO_SUSP_EXTREF },
	{ "CE", cd9660_rrip_cont,	0,	ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,	ISO_SUSP_STOP },
	{ "",	0,			0,	0 }
};

/*
 * Check for Rock Ridge Extension and return offset of its fields.
 * Note: We insist on the ER field.
 */
int
cd9660_rrip_offset(isodir, imp)
	struct iso_directory_record *isodir;
	struct iso_mnt *imp;
{
	ISO_RRIP_OFFSET *p;
	ISO_RRIP_ANALYZE analyze;
	
	imp->rr_skip0 = 0;
	p = (ISO_RRIP_OFFSET *)(isodir->name + 1);
	if (bcmp(p, "SP\7\1\276\357", 6)) {
		/* Maybe, it's a CDROM XA disc? */
		imp->rr_skip0 = 15;
		p = (ISO_RRIP_OFFSET *)((char *)p + 15);
		if (bcmp(p, "SP\7\1\276\357", 6))
			return (-1);
	}
	
	analyze.imp = imp;
	analyze.fields = ISO_SUSP_EXTREF;
	if (!(cd9660_rrip_loop(isodir, &analyze, rrip_table_extref) &
	    ISO_SUSP_EXTREF))
		return (-1);
	
	return (isonum_711(p->skip));
}
@


1.12
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.11 2013/05/30 17:35:01 guenther Exp $	*/
a43 1
#include <sys/file.h>
@


1.11
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.10 2011/07/04 04:30:41 tedu Exp $	*/
d46 1
a50 1

@


1.10
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.9 2007/02/14 00:53:48 jsg Exp $	*/
d678 1
a678 1
	ino_t *inump;
@


1.9
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.8 2003/06/02 23:28:05 millert Exp $	*/
d593 1
a593 1
			    ana->imp->logical_block_size, NOCRED, &bp))
@


1.8
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.7 2003/05/14 21:13:43 tdeval Exp $	*/
d187 1
a187 1
			/* fall thru */
d259 1
a259 1
		/* fall thru */
@


1.7
log
@strcpy + size check
ok tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.6 2002/03/14 01:27:03 millert Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.5 1999/07/01 02:20:21 d Exp $	*/
d301 1
a301 1
	strcpy(ana->outbuf, "..");
@


1.5
log
@Add support for Joliet extensions. From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.4 1997/11/08 17:21:07 niklas Exp $	*/
d65 2
a66 2
	int (*func) __P((void *, ISO_RRIP_ANALYZE *));
	void (*func2) __P((void *, ISO_RRIP_ANALYZE *));
d70 16
a85 16
static int cd9660_rrip_attr __P((void *, ISO_RRIP_ANALYZE *));
static void cd9660_rrip_defattr __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_slink __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_altname __P((void *, ISO_RRIP_ANALYZE *));
static void cd9660_rrip_defname __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_pclink __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_reldir __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_tstamp __P((void *, ISO_RRIP_ANALYZE *));
static void cd9660_rrip_deftstamp __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_device __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_idflag __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_cont __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_stop __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_extref __P((void *, ISO_RRIP_ANALYZE *));
static int cd9660_rrip_loop __P((struct iso_directory_record *,
    ISO_RRIP_ANALYZE *, RRIP_TABLE *));
@


1.5.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.5 1999/07/01 02:20:21 d Exp $	*/
d65 2
a66 2
	int (*func)(void *, ISO_RRIP_ANALYZE *);
	void (*func2)(void *, ISO_RRIP_ANALYZE *);
d70 16
a85 16
static int cd9660_rrip_attr(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defattr(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_slink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_altname(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defname(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_pclink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_reldir(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_tstamp(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_deftstamp(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_device(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_idflag(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_cont(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_stop(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_extref(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_loop(struct iso_directory_record *,
    ISO_RRIP_ANALYZE *, RRIP_TABLE *);
@


1.5.14.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d301 1
a301 1
	strlcpy(ana->outbuf, "..", ana->maxlen - *ana->outlen);
@


1.5.4.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 2
a66 2
	int (*func)(void *, ISO_RRIP_ANALYZE *);
	void (*func2)(void *, ISO_RRIP_ANALYZE *);
d70 16
a85 16
static int cd9660_rrip_attr(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defattr(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_slink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_altname(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_defname(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_pclink(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_reldir(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_tstamp(void *, ISO_RRIP_ANALYZE *);
static void cd9660_rrip_deftstamp(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_device(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_idflag(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_cont(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_stop(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_extref(void *, ISO_RRIP_ANALYZE *);
static int cd9660_rrip_loop(struct iso_directory_record *,
    ISO_RRIP_ANALYZE *, RRIP_TABLE *);
@


1.5.4.2
log
@merge the trunk so we will get the genfs and locking fixes
@
text
@d301 1
a301 1
	strlcpy(ana->outbuf, "..", ana->maxlen - *ana->outlen);
@


1.5.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.5.4.2 2003/05/16 00:29:43 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.4
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_rrip.c,v 1.3 1996/10/04 03:05:30 deraadt Exp $	*/
d306 1
a306 1
		    isonum_711(isodir->flags) & 4);
d534 1
d544 1
d547 1
a547 2
	if (*isodir->name != 0 ||
	    isonum_733(isodir->extent) != ana->imp->root_extent)
d687 1
d698 2
d701 1
a701 1
	if (*isodir->name == 0 || *isodir->name == 1) {
@


1.3
log
@sync
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: cd9660_rrip.c,v 1.12 1996/02/09 21:32:02 christos Exp $	*/
d58 1
d85 1
a85 1
				 ISO_RRIP_ANALYZE *, RRIP_TABLE *));
d95 1
d101 1
a101 1
	return ISO_SUSP_ATTR;
d110 1
d113 1
a113 1
	cd9660_defattr(isodir,ana->inop,NULL);
d131 2
a132 2
	pcompe = (ISO_RRIP_SLINK_COMPONENT *)
		((char *)p + isonum_711(p->h.length));
d140 3
a142 4
	for (;
	     pcomp < pcompe;
	     pcomp = (ISO_RRIP_SLINK_COMPONENT *)((char *)pcomp + ISO_RRIP_SLSIZ
						  + isonum_711(pcomp->clen))) {
d209 1
a209 1
			return 0;
d212 1
a212 1
		bcopy(inbuf,outbuf,wlen);
a214 1
		
d222 1
a222 1
		return ISO_SUSP_SLINK;
d224 1
a224 1
	return 0;
d281 1
a281 1
		return 0;
d284 1
a284 1
	bcopy(inbuf,ana->outbuf,wlen);
d289 1
a289 1
		return ISO_SUSP_ALTNAME;
d291 1
a291 1
	return 0;
d300 2
a301 1
	strcpy(ana->outbuf,"..");
d304 3
a306 3
		isofntrans(isodir->name,isonum_711(isodir->name_len),
			   ana->outbuf,ana->outlen,
			   1,isonum_711(isodir->flags)&4);
d326 1
d328 2
a329 2
	ana->fields &= ~(ISO_SUSP_CLINK|ISO_SUSP_PLINK);
	return *p->h.type == 'C' ? ISO_SUSP_CLINK : ISO_SUSP_PLINK;
d344 2
a345 1
	return ISO_SUSP_RELDIR|ISO_SUSP_ALTNAME|ISO_SUSP_CLINK|ISO_SUSP_PLINK;
d359 2
a360 2
	if (!(*p->flags&ISO_SUSP_TSTAMP_FORM17)) {
		if (*p->flags&ISO_SUSP_TSTAMP_CREAT)
d363 3
a365 2
		if (*p->flags&ISO_SUSP_TSTAMP_MODIFY) {
			cd9660_tstamp_conv7(ptime,&ana->inop->inode.iso_mtime);
d368 2
a369 1
			bzero(&ana->inop->inode.iso_mtime,sizeof(struct timespec));
d371 3
a373 2
		if (*p->flags&ISO_SUSP_TSTAMP_ACCESS) {
			cd9660_tstamp_conv7(ptime,&ana->inop->inode.iso_atime);
d376 2
a377 1
			ana->inop->inode.iso_atime = ana->inop->inode.iso_mtime;
d379 3
a381 2
		if (*p->flags&ISO_SUSP_TSTAMP_ATTR)
			cd9660_tstamp_conv7(ptime,&ana->inop->inode.iso_ctime);
d383 2
a384 1
			ana->inop->inode.iso_ctime = ana->inop->inode.iso_mtime;
d387 1
a387 1
		if (*p->flags&ISO_SUSP_TSTAMP_CREAT)
d390 3
a392 2
		if (*p->flags&ISO_SUSP_TSTAMP_MODIFY) {
			cd9660_tstamp_conv17(ptime,&ana->inop->inode.iso_mtime);
d395 2
a396 1
			bzero(&ana->inop->inode.iso_mtime,sizeof(struct timespec));
d398 3
a400 2
		if (*p->flags&ISO_SUSP_TSTAMP_ACCESS) {
			cd9660_tstamp_conv17(ptime,&ana->inop->inode.iso_atime);
d403 2
a404 1
			ana->inop->inode.iso_atime = ana->inop->inode.iso_mtime;
d406 3
a408 2
		if (*p->flags&ISO_SUSP_TSTAMP_ATTR)
			cd9660_tstamp_conv17(ptime,&ana->inop->inode.iso_ctime);
d410 2
a411 1
			ana->inop->inode.iso_ctime = ana->inop->inode.iso_mtime;
d415 1
a415 1
	return ISO_SUSP_TSTAMP;
d424 2
a425 1
	cd9660_deftstamp(isodir,ana->inop,NULL);
d447 1
a447 1
	return ISO_SUSP_DEVICE;
d459 3
a461 1
	ana->fields &= isonum_711(p->flags)|~0xff; /* don't touch high bits */
d463 2
a464 2
	if (ana->fields&ISO_SUSP_RELDIR)
		return cd9660_rrip_reldir(p,ana);
d466 1
a466 1
	return ISO_SUSP_IDFLAG;
d478 1
d482 1
a482 1
	return ISO_SUSP_CONT;
d493 1
a493 1
	return ISO_SUSP_STOP;
d507 11
a517 11
		return 0;
	if (isonum_711(p->len_id) != 9
	    && isonum_711(p->len_id) != 10)
		return 0;
	if (isonum_711(p->len_id) == 9
	    && bcmp((char *)p + 8, "IEEE_1282", 9))
		return 0;
	if (isonum_711(p->len_id) == 10
	    && bcmp((char *)p + 8, "IEEE_P1282", 10)
	    && bcmp((char *)p + 8, "RRIP_1991A", 10))
		return 0;
d519 1
a519 1
	return ISO_SUSP_EXTREF;
d524 1
a524 1
cd9660_rrip_loop(isodir,ana,table)
d538 1
a538 1
	 *       it will be padding 1 byte  after the name
d541 1
a541 1
	if (!(isonum_711(isodir->name_len)&1))
d545 2
a546 2
	if (*isodir->name != 0
	    || isonum_733(isodir->extent) != ana->imp->root_extent)
d552 2
a553 1
	pend = (ISO_SUSP_HEADER *)((char *)isodir + isonum_711(isodir->length));
d564 5
a568 3
					if (*phead->type == *ptable->type
					    && phead->type[1] == ptable->type[1]) {
						result |= ptable->func(phead,ana);
d575 1
a575 1
			if (result&ISO_SUSP_STOP) {
d586 2
a587 1
			phead = (ISO_SUSP_HEADER *)((char *)phead + isonum_711(phead->length));
d591 6
a596 6
			if (ana->iso_ce_blk >= ana->imp->volume_space_size
			    || ana->iso_ce_off + ana->iso_ce_len > ana->imp->logical_block_size
			    || bread(ana->imp->im_devvp,
				     ana->iso_ce_blk <<
				     (ana->imp->im_bshift - DEV_BSHIFT),
				     ana->imp->logical_block_size, NOCRED, &bp))
d599 4
a602 2
			phead = (ISO_SUSP_HEADER *)(bp->b_data + ana->iso_ce_off);
			pend = (ISO_SUSP_HEADER *) ((char *)phead + ana->iso_ce_len);
d613 2
a614 2
		if (!(ptable->result&result))
			ptable->func2(isodir,ana);
d616 1
a616 1
	return result;
d623 14
a636 7
	{ "PX", cd9660_rrip_attr,	cd9660_rrip_defattr,	ISO_SUSP_ATTR },
	{ "TF", cd9660_rrip_tstamp,	cd9660_rrip_deftstamp,	ISO_SUSP_TSTAMP },
	{ "PN", cd9660_rrip_device,	0,			ISO_SUSP_DEVICE },
	{ "RR", cd9660_rrip_idflag,	0,			ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,			ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,			ISO_SUSP_STOP },
	{ "",	0,			0,			0 }
d649 1
a649 1
	analyze.fields = ISO_SUSP_ATTR|ISO_SUSP_TSTAMP|ISO_SUSP_DEVICE;
d651 1
a651 1
	return cd9660_rrip_loop(isodir,&analyze,rrip_table_analyze);
d658 16
a673 8
	{ "NM", cd9660_rrip_altname,	cd9660_rrip_defname,	ISO_SUSP_ALTNAME },
	{ "CL", cd9660_rrip_pclink,	0,			ISO_SUSP_CLINK|ISO_SUSP_PLINK },
	{ "PL", cd9660_rrip_pclink,	0,			ISO_SUSP_CLINK|ISO_SUSP_PLINK },
	{ "RE", cd9660_rrip_reldir,	0,			ISO_SUSP_RELDIR },
	{ "RR", cd9660_rrip_idflag,	0,			ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,			ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,			ISO_SUSP_STOP },
	{ "",	0,			0,			0 }
d677 1
a677 1
cd9660_rrip_getname(isodir,outbuf,outlen,inump,imp)
d692 2
a693 1
	analyze.fields = ISO_SUSP_ALTNAME|ISO_SUSP_RELDIR|ISO_SUSP_CLINK|ISO_SUSP_PLINK;
d697 2
a698 3
	if (*isodir->name == 0
	    || *isodir->name == 1) {
		cd9660_rrip_defname(isodir,&analyze);
d704 1
a704 1
	return cd9660_rrip_loop(isodir,&analyze,tab);
d711 5
a715 5
	{ "SL", cd9660_rrip_slink,	0,			ISO_SUSP_SLINK },
	{ "RR", cd9660_rrip_idflag,	0,			ISO_SUSP_IDFLAG },
	{ "CE", cd9660_rrip_cont,	0,			ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,			ISO_SUSP_STOP },
	{ "",	0,			0,			0 }
d719 1
a719 1
cd9660_rrip_getsymname(isodir,outbuf,outlen,imp)
d736 1
a736 1
		ISO_SUSP_SLINK);
d751 1
a751 1
cd9660_rrip_offset(isodir,imp)
d760 1
a760 1
	if (bcmp(p,"SP\7\1\276\357",6)) {
d764 2
a765 2
		if (bcmp(p,"SP\7\1\276\357",6))
			return -1;
d770 3
a772 3
	if (!(cd9660_rrip_loop(isodir, &analyze, rrip_table_extref)
		& ISO_SUSP_EXTREF))
		return -1;
d774 1
a774 1
	return isonum_711(p->skip);
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d485 12
a496 3
	if (isonum_711(p->len_id) != 10
	    || bcmp((char *)p + 8,"RRIP_1991A",10)
	    || isonum_711(p->version) != 1)
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: cd9660_rrip.c,v 1.11 1994/12/24 15:30:10 cgd Exp $	*/
d62 23
d89 2
a90 2
cd9660_rrip_attr(p,ana)
	ISO_RRIP_ATTR *p;
d93 1
d103 2
a104 2
cd9660_rrip_defattr(isodir,ana)
	struct iso_directory_record *isodir;
d107 1
d117 2
a118 2
cd9660_rrip_slink(p,ana)
	ISO_RRIP_SLINK  *p;
d121 1
d128 2
a129 1
	pcompe = (ISO_RRIP_SLINK_COMPONENT *)((char *)p + isonum_711(p->h.length));
d230 2
a231 2
cd9660_rrip_altname(p,ana)
	ISO_RRIP_ALTNAME *p;
d234 1
d294 2
a295 2
cd9660_rrip_defname(isodir,ana)
	struct iso_directory_record *isodir;
d298 1
d319 2
a320 2
cd9660_rrip_pclink(p,ana)
	ISO_RRIP_CLINK  *p;
d323 1
d332 1
d334 2
a335 2
cd9660_rrip_reldir(p,ana)
	ISO_RRIP_RELDIR  *p;
d345 2
a346 2
cd9660_rrip_tstamp(p,ana)
	ISO_RRIP_TSTAMP *p;
d349 1
d403 2
a404 2
cd9660_rrip_deftstamp(isodir,ana)
	struct iso_directory_record  *isodir;
d407 1
d415 2
a416 2
cd9660_rrip_device(p,ana)
	ISO_RRIP_DEVICE *p;
d419 1
d437 2
a438 2
cd9660_rrip_idflag(p,ana)
	ISO_RRIP_IDFLAG *p;
d441 1
d454 2
a455 2
cd9660_rrip_cont(p,ana)
	ISO_RRIP_CONT *p;
d458 1
d469 2
a470 2
cd9660_rrip_stop(p,ana)
	ISO_SUSP_HEADER *p;
d480 2
a481 2
cd9660_rrip_extref(p,ana)
	ISO_RRIP_EXTREF *p;
d484 1
a492 6
typedef struct {
	char type[2];
	int (*func)();
	void (*func2)();
	int result;
} RRIP_TABLE;
d598 1
a598 1
cd9660_rrip_analyze(isodir,inop,imp)
d685 2
a686 1
	return (cd9660_rrip_loop(isodir,&analyze,rrip_table_getsymname)&ISO_SUSP_SLINK);
d690 4
a693 4
	{ "ER", cd9660_rrip_extref,	0,			ISO_SUSP_EXTREF },
	{ "CE", cd9660_rrip_cont,	0,			ISO_SUSP_CONT },
	{ "ST", cd9660_rrip_stop,	0,			ISO_SUSP_STOP },
	{ "",	0,			0,			0 }
d720 2
a721 1
	if (!(cd9660_rrip_loop(isodir,&analyze,rrip_table_extref)&ISO_SUSP_EXTREF))
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
