head	1.24;
access;
symbols
	OPENBSD_6_2:1.24.0.4
	OPENBSD_6_2_BASE:1.24
	OPENBSD_6_1:1.24.0.6
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.2
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.20.0.6
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.2
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.12.0.6
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.4
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.2
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.11.0.10
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.8
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.6
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.8
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.6
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.10
	OPENBSD_2_8:1.8.0.8
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.6
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.4
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.2
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.7.0.6
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.7.0.4
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.2
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.24
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.23;
commitid	gAjwyca5TfuoJAhn;

1.23
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.22;
commitid	p4LJxGKbi0BU2cG6;

1.22
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.21;
commitid	P6Av4XGqOi3rFasL;

1.21
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.20;
commitid	C8XZQyreqTUCeixA;

1.20
date	2013.06.11.16.42.15;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2010.01.17.20.25.58;	author chl;	state Exp;
branches;
next	1.16;

1.16
date	2009.07.09.22.29.55;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.29.13.02.19;	author chl;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.01.23.47.55;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2006.01.25.21.15.55;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.31.17.37.49;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.23.02.14.22;	author csapuntz;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.07.01.02.20.21;	author d;	state Exp;
branches
	1.8.4.1;
next	1.7;

1.7
date	97.12.02.17.47.38;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	97.11.08.17.21.06;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	97.11.06.05.58.09;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	97.10.06.20.19.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	97.10.06.15.08.40;	author csapuntz;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.10.12.17;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.8.4.1
date	2001.07.04.10.48.06;	author niklas;	state Exp;
branches;
next	1.8.4.2;

1.8.4.2
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.8.4.3;

1.8.4.3
date	2003.06.07.11.03.39;	author ho;	state Exp;
branches;
next	;

1.9.4.1
date	2003.05.19.21.53.27;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@/*	$OpenBSD: cd9660_lookup.c,v 1.23 2015/03/14 03:38:50 jsg Exp $	*/
/*	$NetBSD: cd9660_lookup.c,v 1.18 1997/05/08 16:19:59 mycroft Exp $	*/

/*-
 * Copyright (c) 1989, 1993, 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	from: @@(#)ufs_lookup.c	7.33 (Berkeley) 5/19/91
 *
 *	@@(#)cd9660_lookup.c	8.5 (Berkeley) 12/5/94
 */

#include <sys/param.h>
#include <sys/namei.h>
#include <sys/buf.h>
#include <sys/file.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/mount.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/cd9660_node.h>
#include <isofs/cd9660/iso_rrip.h>

struct	nchstats iso_nchstats;

/*
 * Convert a component of a pathname into a pointer to a locked inode.
 * This is a very central and rather complicated routine.
 * If the file system is not maintained in a strict tree hierarchy,
 * this can result in a deadlock situation (see comments in code below).
 *
 * The flag argument is LOOKUP, CREATE, RENAME, or DELETE depending on
 * whether the name is to be looked up, created, renamed, or deleted.
 * When CREATE, RENAME, or DELETE is specified, information usable in
 * creating, renaming, or deleting a directory entry may be calculated.
 * If flag has LOCKPARENT or'ed into it and the target of the pathname
 * exists, lookup returns both the target and its parent directory locked.
 * When creating or renaming and LOCKPARENT is specified, the target may
 * not be ".".  When deleting and LOCKPARENT is specified, the target may
 * be "."., but the caller must check to ensure it does an vrele and iput
 * instead of two iputs.
 *
 * Overall outline of cd9660_lookup:
 *
 *	check accessibility of directory
 *	look for name in cache, if found, then if at end of path
 *	  and deleting or creating, drop it, else return name
 *	search for name in directory, to found or notfound
 * notfound:
 *	if creating, return locked directory, leaving info on available slots
 *	else return error
 * found:
 *	if at end of path and deleting, return information to allow delete
 *	if at end of path and rewriting (RENAME and LOCKPARENT), lock target
 *	  inode and return info to allow rewrite
 *	if not at end, add name to cache; if at end and neither creating
 *	  nor deleting, add name to cache
 *
 * NOTE: (LOOKUP | LOCKPARENT) currently returns the parent inode unlocked.
 */
int
cd9660_lookup(v)
	void *v;
{
	struct vop_lookup_args *ap = v;
	register struct vnode *vdp;	/* vnode for directory being searched */
	register struct iso_node *dp;	/* inode for directory being searched */
	register struct iso_mnt *imp;	/* file system that directory is in */
	struct buf *bp;			/* a buffer of directory entries */
	struct iso_directory_record *ep = NULL;
					/* the current directory entry */
	int entryoffsetinblock;		/* offset of ep in bp's buffer */
	int saveoffset = -1;		/* offset of last directory entry in dir */
	int numdirpasses;		/* strategy for directory search */
	doff_t endsearch;		/* offset to end directory search */
	struct vnode *pdp;		/* saved dp during symlink work */
	struct vnode *tdp;		/* returned by cd9660_vget_internal */
	u_long bmask;			/* block offset mask */
	int lockparent;			/* 1 => lockparent flag is set */
	int error;
	cdino_t ino = 0;
	int reclen;
	u_short namelen;
	char *altname;
	int res;
	int assoc, len;
	char *name;
	struct vnode **vpp = ap->a_vpp;
	struct componentname *cnp = ap->a_cnp;
	struct ucred *cred = cnp->cn_cred;
	int flags;
	int nameiop = cnp->cn_nameiop;
	struct proc *p = cnp->cn_proc;

	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

	bp = NULL;
	*vpp = NULL;
	vdp = ap->a_dvp;
	dp = VTOI(vdp);
	imp = dp->i_mnt;
	lockparent = flags & LOCKPARENT;
	
	/*
	 * Check accessiblity of directory.
	 */
	if ((error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc)) != 0)
		return (error);

	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);
	
	/*
	 * We now have a segment name to search for, and a directory to search.
	 *
	 * Before tediously performing a linear scan of the directory,
	 * check the name cache to see if the directory/name pair
	 * we are looking for is known already.
	 */
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);

	len = cnp->cn_namelen;
	name = cnp->cn_nameptr;
	/*
	 * A leading `=' means, we are looking for an associated file
	 */
	assoc = (imp->iso_ftype != ISO_FTYPE_RRIP && *name == ASSOCCHAR);
	if (assoc) {
		len--;
		name++;
	}
	
	/*
	 * If there is cached information on a previous search of
	 * this directory, pick up where we last left off.
	 * We cache only lookups as these are the most common
	 * and have the greatest payoff. Caching CREATE has little
	 * benefit as it usually must search the entire directory
	 * to determine that the entry does not exist. Caching the
	 * location of the last DELETE or RENAME has not reduced
	 * profiling time and hence has been removed in the interest
	 * of simplicity.
	 */
	bmask = imp->im_bmask;
	if (nameiop != LOOKUP || dp->i_diroff == 0 ||
	    dp->i_diroff > dp->i_size) {
		entryoffsetinblock = 0;
		dp->i_offset = 0;
		numdirpasses = 1;
	} else {
		dp->i_offset = dp->i_diroff;
		if ((entryoffsetinblock = dp->i_offset & bmask) &&
		    (error = cd9660_bufatoff(dp, (off_t)dp->i_offset, NULL, 
			&bp)))
				return (error);
		numdirpasses = 2;
		iso_nchstats.ncs_2passes++;
	}
	endsearch = dp->i_size;
	
searchloop:
	while (dp->i_offset < endsearch) {
		/*
		 * If offset is on a block boundary,
		 * read the next directory block.
		 * Release previous if it exists.
		 */
		if ((dp->i_offset & bmask) == 0) {
			if (bp != NULL)
				brelse(bp);
			error = cd9660_bufatoff(dp, (off_t)dp->i_offset,
					     NULL, &bp);
			if (error)
				return (error);
			entryoffsetinblock = 0;
		}
		/*
		 * Get pointer to next entry.
		 */
		ep = (struct iso_directory_record *)
			((char *)bp->b_data + entryoffsetinblock);
		
		reclen = isonum_711(ep->length);
		if (reclen == 0) {
			/* skip to next block, if any */
			dp->i_offset =
			    (dp->i_offset & ~bmask) + imp->logical_block_size;
			continue;
		}
		
		if (reclen < ISO_DIRECTORY_RECORD_SIZE)
			/* illegal entry, stop */
			break;
		
		if (entryoffsetinblock + reclen > imp->logical_block_size)
			/* entries are not allowed to cross boundaries */
			break;
		
		namelen = isonum_711(ep->name_len);
		
		if (reclen < ISO_DIRECTORY_RECORD_SIZE + namelen)
			/* illegal entry, stop */
			break;
		
		/*
		 * Check for a name match.
		 */
		switch (imp->iso_ftype) {
		default:
			if ((!(isonum_711(ep->flags)&4)) == !assoc) {
				if ((len == 1
				     && *name == '.')
				    || (flags & ISDOTDOT)) {
					if (namelen == 1
					    && ep->name[0] == ((flags & ISDOTDOT) ? 1 : 0)) {
						/*
						 * Save directory entry's inode number and
						 * release directory buffer.
						 */
						dp->i_ino = isodirino(ep, imp);
						goto found;
					}
					if (namelen != 1
					    || ep->name[0] != 0)
						goto notfound;
				} else if (!(res = isofncmp(name, len, 
				    ep->name, namelen, imp->joliet_level))) {
					if (isonum_711(ep->flags)&2)
						ino = isodirino(ep, imp);
					else
						ino = dbtob(bp->b_blkno)
							+ entryoffsetinblock;
					saveoffset = dp->i_offset;
				} else if (ino)
					goto foundino;
#ifdef	NOSORTBUG	/* On some CDs directory entries are not sorted correctly */
				else if (res < 0)
					goto notfound;
				else if (res > 0 && numdirpasses == 2)
					numdirpasses++;
#endif
			}
			break;
		case ISO_FTYPE_RRIP:
			if (isonum_711(ep->flags)&2)
				ino = isodirino(ep, imp);
			else
				ino = dbtob(bp->b_blkno) + entryoffsetinblock;
			dp->i_ino = ino;
			altname = malloc(NAME_MAX, M_TEMP, M_WAITOK);
			cd9660_rrip_getname(ep,altname,&namelen,&dp->i_ino,imp);
			if (namelen == cnp->cn_namelen
			    && !bcmp(name,altname,namelen)) {
				free(altname, M_TEMP, 0);
				goto found;
			}
			free(altname, M_TEMP, 0);
			ino = 0;
			break;
		}
		dp->i_offset += reclen;
		entryoffsetinblock += reclen;
	}
	if (ino) {
foundino:
		dp->i_ino = ino;
		if (saveoffset != dp->i_offset) {
			if (lblkno(imp, dp->i_offset) !=
			    lblkno(imp, saveoffset)) {
				if (bp != NULL)
					brelse(bp);
				if ((error = cd9660_bufatoff(dp,
					    (off_t)saveoffset, NULL, &bp)) != 0)
					return (error);
			}
			entryoffsetinblock = saveoffset & bmask;
			ep = (struct iso_directory_record *)
				((char *)bp->b_data + entryoffsetinblock);
			dp->i_offset = saveoffset;
		}
		goto found;
	}
notfound:
	/*
	 * If we started in the middle of the directory and failed
	 * to find our target, we must check the beginning as well.
	 */
	if (numdirpasses == 2) {
		numdirpasses--;
		dp->i_offset = 0;
		endsearch = dp->i_diroff;
		goto searchloop;
	}
	if (bp != NULL)
		brelse(bp);

	/*
	 * Insert name into cache (as non-existent) if appropriate.
	 */
	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(vdp, *vpp, cnp);
	if (nameiop == CREATE || nameiop == RENAME)
		return (EJUSTRETURN);
	return (ENOENT);
	
found:
	if (numdirpasses == 2)
		iso_nchstats.ncs_pass2++;
	
	/*
	 * Found component in pathname.
	 * If the final component of path name, save information
	 * in the cache as to where the entry was found.
	 */
	if ((flags & ISLASTCN) && nameiop == LOOKUP)
		dp->i_diroff = dp->i_offset;
	
	/*
	 * Step through the translation in the name.  We do not `iput' the
	 * directory because we may need it again if a symbolic link
	 * is relative to the current directory.  Instead we save it
	 * unlocked as "pdp".  We must get the target inode before unlocking
	 * the directory to insure that the inode will not be removed
	 * before we get it.  We prevent deadlock by always fetching
	 * inodes from the root, moving down the directory tree. Thus
	 * when following backward pointers ".." we must unlock the
	 * parent directory before getting the requested directory.
	 * There is a potential race condition here if both the current
	 * and parent directories are removed before the `iget' for the
	 * inode associated with ".." returns.  We hope that this occurs
	 * infrequently since we cannot avoid this race condition without
	 * implementing a sophisticated deadlock detection algorithm.
	 * Note also that this simple deadlock detection scheme will not
	 * work if the file system has any hard links other than ".."
	 * that point backwards in the directory structure.
	 */
	pdp = vdp;
	/*
	 * If ino is different from dp->i_ino,
	 * it's a relocated directory.
	 */
	if (flags & ISDOTDOT) {
		brelse(bp);
		VOP_UNLOCK(pdp, p);	/* race to get the inode */
		cnp->cn_flags |= PDIRUNLOCK;
		error = cd9660_vget_internal(vdp->v_mount, dp->i_ino, &tdp,
			    dp->i_ino != ino, NULL);
		if (error) {
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
			return (error);
		}
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
		}
		*vpp = tdp;
	} else if (dp->i_number == dp->i_ino) {
		brelse(bp);
		vref(vdp);	/* we want ourself, ie "." */
		*vpp = vdp;
	} else {
		error = cd9660_vget_internal(vdp->v_mount, dp->i_ino, &tdp,
					     dp->i_ino != ino, ep);
		brelse(bp);
		if (error)
			return (error);
		if (!lockparent || !(flags & ISLASTCN)) {
			VOP_UNLOCK(pdp, p);
			cnp->cn_flags |= PDIRUNLOCK;
		}
		*vpp = tdp;
	}
	
	/*
	 * Insert name into cache if appropriate.
	 */
	if (cnp->cn_flags & MAKEENTRY)
		cache_enter(vdp, *vpp, cnp);
	return (0);
}

/*
 * Return buffer with the contents of block "offset" from the beginning of
 * directory "ip".  If "res" is non-zero, fill it in with a pointer to the
 * remaining space in the directory.
 */
int
cd9660_bufatoff(struct iso_node *ip, off_t offset, char **res, 
    struct buf **bpp)
{
	struct iso_mnt *imp;
	struct buf *bp;
	daddr_t lbn;
	int bsize, error;
	struct vnode *vp = ITOV(ip);

	imp = ip->i_mnt;
	lbn = lblkno(imp, offset);
	bsize = blksize(imp, ip, lbn);
	
	if ((error = bread(vp, lbn, bsize, &bp)) != 0) {
		brelse(bp);
		*bpp = NULL;
		return (error);
	}
	if (res)
		*res = (char *)bp->b_data + blkoff(imp, offset);
	*bpp = bp;
	return (0);
}
@


1.23
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.22 2014/12/16 18:30:03 tedu Exp $	*/
d380 1
a380 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d408 1
a408 1
			VOP_UNLOCK(pdp, 0, p);
@


1.22
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.21 2014/07/12 18:50:00 tedu Exp $	*/
a55 1
#include <isofs/cd9660/cd9660_rrip.h>
@


1.21
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.20 2013/06/11 16:42:15 deraadt Exp $	*/
d47 1
@


1.20
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.19 2013/05/30 17:35:01 guenther Exp $	*/
d290 1
a290 1
				free(altname, M_TEMP);
d293 1
a293 1
			free(altname, M_TEMP);
@


1.19
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.18 2011/07/04 04:30:41 tedu Exp $	*/
d433 1
a433 1
	daddr64_t lbn;
@


1.18
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.17 2010/01/17 20:25:58 chl Exp $	*/
d114 1
a114 1
	ino_t ino = 0;
@


1.17
log
@Remove dead assignment and newly created unused variable.

Found by LLVM/Clang Static Analyzer.

ok otto@@ krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.16 2009/07/09 22:29:55 thib Exp $	*/
d441 1
a441 1
	if ((error = bread(vp, lbn, bsize, NOCRED, &bp)) != 0) {
@


1.16
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.14 2007/06/06 17:15:13 deraadt Exp $	*/
a112 1
	int wantparent;			/* 1 => wantparent or lockparent flag */
a136 1
	wantparent = flags & (LOCKPARENT|WANTPARENT);
@


1.15
log
@MALLOC/FREE -> malloc/free

ok krw@@
@
text
@d401 1
a401 1
		VREF(vdp);	/* we want ourself, ie "." */
@


1.14
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.13 2007/06/01 23:47:55 deraadt Exp $	*/
d288 1
a288 1
			MALLOC(altname, char *, NAME_MAX, M_TEMP, M_WAITOK);
d292 1
a292 1
				FREE(altname, M_TEMP);
d295 1
a295 1
			FREE(altname, M_TEMP);
@


1.13
log
@pedro ok'd this ~3500 line diff which removes the vop argument
"ap = v" comments in under 8 seconds, so it must be ok.  and it compiles
too.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.12 2006/01/25 21:15:55 mickey Exp $	*/
d435 1
a435 1
	daddr_t lbn;
@


1.12
log
@reduce stack use; pedro@@ miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.11 2003/06/02 23:28:05 millert Exp $	*/
d98 1
a98 5
	struct vop_lookup_args /* {
		struct vnode *a_dvp;
		struct vnode **a_vpp;
		struct componentname *a_cnp;
	} */ *ap = v;
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.10 2003/01/31 17:37:49 art Exp $	*/
d49 1
d122 1
a122 1
	char altname[NAME_MAX];
d292 1
d295 2
a296 1
			    && !bcmp(name,altname,namelen))
d298 2
@


1.10
log
@File system locking fixups, mostly from NetBSD:
- cache_lookup
        move common code from various fs's here
        always return with vnode and parent locked
        adjust return codes
- PDIRUNLOCK - new flag set if lookup couldn't lock parent vnode
- kernfs and procfs
        lock vnode in get_root
        don't unlock (again) in kernfs_freevp
        fix memory leak in procfs

From tedu@@stanford.edu
deraadt@@ and various other ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.9 2001/06/23 02:14:22 csapuntz Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.8 1999/07/01 02:20:21 d Exp $	*/
d132 1
a132 1
	int flags = cnp->cn_flags;
d136 3
d164 2
a165 2
	if ((error = cache_lookup(vdp, vpp, cnp)) != 0) {
		int vpid;	/* capability number of vnode */
a166 46
		if (error == ENOENT)
			return (error);
#ifdef PARANOID
		if ((vdp->v_flag & VROOT) && (flags & ISDOTDOT))
			panic("cd9660_lookup: .. through root");
#endif
		/*
		 * Get the next vnode in the path.
		 * See comment below starting `Step through' for
		 * an explaination of the locking protocol.
		 */
		pdp = vdp;
		dp = VTOI(*vpp);
		vdp = *vpp;
		vpid = vdp->v_id;
		if (pdp == vdp) {
			VREF(vdp);
			error = 0;
		} else if (flags & ISDOTDOT) {
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!error && lockparent && (flags & ISLASTCN))
				error = vn_lock(pdp, LK_EXCLUSIVE, p);
		} else {
			error = vget(vdp, LK_EXCLUSIVE, p);
			if (!lockparent || error || !(flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		/*
		 * Check that the capability number did not change
		 * while we were waiting for the lock.
		 */
		if (!error) {
			if (vpid == vdp->v_id)
				return (0);
			vput(vdp);
			if (lockparent && pdp != vdp && (flags & ISLASTCN))
				VOP_UNLOCK(pdp, 0, p);
		}
		if ((error = vn_lock(pdp, LK_EXCLUSIVE, p)) != 0)
			return (error);
		vdp = pdp;
		dp = VTOI(pdp);
		*vpp = NULL;
	}
	
d386 1
d388 1
a388 1
					     dp->i_ino != ino, NULL);
d390 2
a391 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d394 6
a399 4
		if (lockparent && (flags & ISLASTCN) &&
		    (error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
			vput(tdp);
			return (error);
d412 1
a412 1
		if (!lockparent || !(flags & ISLASTCN))
d414 2
@


1.9.4.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
	int flags;
a135 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d161 2
a162 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d164 46
a428 1
		cnp->cn_flags |= PDIRUNLOCK;
d430 1
a430 1
			    dp->i_ino != ino, NULL);
d432 1
a432 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d435 4
a438 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d451 1
a451 1
		if (!lockparent || !(flags & ISLASTCN)) {
a452 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.8
log
@Add support for Joliet extensions. From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.7 1997/12/02 17:47:38 csapuntz Exp $	*/
d241 2
a242 1
		    (error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp)))
d259 1
a259 1
			error = VOP_BLKATOFF(vdp, (off_t)dp->i_offset,
d356 1
a356 1
				if ((error = VOP_BLKATOFF(vdp,
d470 2
a471 2
cd9660_blkatoff(v)
	void *v;
d473 1
a473 8
	struct vop_blkatoff_args /* {
		struct vnode *a_vp;
		off_t a_offset;
		char **a_res;
		struct buf **a_bpp;
	} */ *ap = v;
	struct iso_node *ip;
	register struct iso_mnt *imp;
d477 1
a478 1
	ip = VTOI(ap->a_vp);
d480 1
a480 1
	lbn = lblkno(imp, ap->a_offset);
d483 1
a483 1
	if ((error = bread(ap->a_vp, lbn, bsize, NOCRED, &bp)) != 0) {
d485 1
a485 1
		*ap->a_bpp = NULL;
d488 3
a490 3
	if (ap->a_res)
		*ap->a_res = (char *)bp->b_data + blkoff(imp, ap->a_offset);
	*ap->a_bpp = bp;
@


1.8.4.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.8 1999/07/01 02:20:21 d Exp $	*/
d241 1
a241 2
		    (error = cd9660_bufatoff(dp, (off_t)dp->i_offset, NULL, 
			&bp)))
d258 1
a258 1
			error = cd9660_bufatoff(dp, (off_t)dp->i_offset,
d355 1
a355 1
				if ((error = cd9660_bufatoff(dp,
d469 2
a470 2
cd9660_bufatoff(struct iso_node *ip, off_t offset, char **res, 
    struct buf **bpp)
d472 8
a479 1
	struct iso_mnt *imp;
a482 1
	struct vnode *vp = ITOV(ip);
d484 1
d486 1
a486 1
	lbn = lblkno(imp, offset);
d489 1
a489 1
	if ((error = bread(vp, lbn, bsize, NOCRED, &bp)) != 0) {
d491 1
a491 1
		*bpp = NULL;
d494 3
a496 3
	if (res)
		*res = (char *)bp->b_data + blkoff(imp, offset);
	*bpp = bp;
@


1.8.4.2
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d132 1
a132 1
	int flags;
a135 3
	cnp->cn_flags &= ~PDIRUNLOCK;
	flags = cnp->cn_flags;

d161 2
a162 2
	if ((error = cache_lookup(vdp, vpp, cnp)) >= 0)
		return (error);
d164 46
a428 1
		cnp->cn_flags |= PDIRUNLOCK;
d430 1
a430 1
			    dp->i_ino != ino, NULL);
d432 1
a432 2
			if (vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p) == 0)
				cnp->cn_flags &= ~PDIRUNLOCK;
d435 4
a438 6
		if (lockparent && (flags & ISLASTCN)) {
			if ((error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
				vput(tdp);
				return (error);
			}
			cnp->cn_flags &= ~PDIRUNLOCK;
d451 1
a451 1
		if (!lockparent || !(flags & ISLASTCN)) {
a452 2
			cnp->cn_flags |= PDIRUNLOCK;
		}
@


1.8.4.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.8.4.2 2003/03/28 00:00:19 niklas Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.7
log
@Fix deadlock in cd9660 code. NetBSD PR#2262
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.6 1997/11/08 17:21:06 niklas Exp $	*/
d313 2
a314 2
				} else if (!(res = isofncmp(name,len,
							    ep->name,namelen))) {
@


1.6
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.5 1997/11/06 05:58:09 csapuntz Exp $	*/
d426 1
d429 1
a429 2
					     dp->i_ino != ino, ep);
		brelse(bp);
@


1.5
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: cd9660_lookup.c,v 1.4 1997/10/06 20:19:42 deraadt Exp $	*/
/*	$NetBSD: cd9660_lookup.c,v 1.14 1996/02/09 21:31:56 christos Exp $	*/
d55 1
d79 1
a79 1
 * Overall outline of ufs_lookup:
a146 2
	if (vdp->v_type != VDIR)
		return (ENOTDIR);
@


1.4
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_lookup.c,v 1.2 1996/02/29 10:12:17 niklas Exp $	*/
d133 2
a134 1
	
d150 4
d184 2
a185 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d187 1
a187 1
				error = VOP_LOCK(pdp);
d189 1
a189 1
			error = vget(vdp, 1);
d191 1
a191 1
				VOP_UNLOCK(pdp);
d202 1
a202 1
				VOP_UNLOCK(pdp);
d204 1
a204 1
		if ((error = VOP_LOCK(pdp)) != 0)
d427 1
a427 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d432 1
a432 1
			VOP_LOCK(pdp);
d436 1
a436 1
		    (error = VOP_LOCK(pdp))) {
d452 1
a452 1
			VOP_UNLOCK(pdp);
@


1.3
log
@VFS Lite2 Changes
@
text
@d133 1
a133 2
	struct proc *p = cnp->cn_proc;

a148 4

	if ((flags & ISLASTCN) && (vdp->v_mount->mnt_flag & MNT_RDONLY) &&
	    (cnp->cn_nameiop == DELETE || cnp->cn_nameiop == RENAME))
		return (EROFS);
d179 2
a180 2
			VOP_UNLOCK(pdp, 0, p);
			error = vget(vdp, LK_EXCLUSIVE, p);
d182 1
a182 1
				error = vn_lock(pdp, LK_EXCLUSIVE, p);
d184 1
a184 1
			error = vget(vdp, LK_EXCLUSIVE, p);
d186 1
a186 1
				VOP_UNLOCK(pdp, 0, p);
d197 1
a197 1
				VOP_UNLOCK(pdp, 0, p);
d199 1
a199 1
		if ((error = vn_lock(pdp, LK_EXCLUSIVE, p)) != 0)
d422 1
a422 1
		VOP_UNLOCK(pdp, 0, p);	/* race to get the inode */
d427 1
a427 1
			vn_lock(pdp, LK_EXCLUSIVE | LK_RETRY, p);
d431 1
a431 1
		    (error = vn_lock(pdp, LK_EXCLUSIVE, p))) {
d447 1
a447 1
			VOP_UNLOCK(pdp, 0, p);
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 2
a134 1
	
d150 4
d184 2
a185 2
			VOP_UNLOCK(pdp);
			error = vget(vdp, 1);
d187 1
a187 1
				error = VOP_LOCK(pdp);
d189 1
a189 1
			error = vget(vdp, 1);
d191 1
a191 1
				VOP_UNLOCK(pdp);
d202 1
a202 1
				VOP_UNLOCK(pdp);
d204 1
a204 1
		if ((error = VOP_LOCK(pdp)) != 0)
d427 1
a427 1
		VOP_UNLOCK(pdp);	/* race to get the inode */
d432 1
a432 1
			VOP_LOCK(pdp);
d436 1
a436 1
		    (error = VOP_LOCK(pdp))) {
d452 1
a452 1
			VOP_UNLOCK(pdp);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: cd9660_lookup.c,v 1.13 1994/12/24 15:30:03 cgd Exp $	*/
d52 1
d97 3
a99 1
cd9660_lookup(ap)
d104 1
a104 2
	} */ *ap;
{
d109 2
a110 1
	struct iso_directory_record *ep;/* the current directory entry */
d112 1
a112 1
	int saveoffset;			/* offset of last directory entry in dir */
d147 1
a147 1
	if (error = VOP_ACCESS(vdp, VEXEC, cred, cnp->cn_proc))
d157 1
a157 1
	if (error = cache_lookup(vdp, vpp, cnp)) {
d199 1
a199 1
		if (error = VOP_LOCK(pdp))
d211 2
a212 1
	if (assoc = (imp->iso_ftype != ISO_FTYPE_RRIP && *name == ASSOCCHAR)) {
d254 3
a256 2
			if (error =
			    VOP_BLKATOFF(vdp, (off_t)dp->i_offset, NULL, &bp))
d351 2
a352 2
				if (error = VOP_BLKATOFF(vdp,
				    (off_t)saveoffset, NULL, &bp))
d465 3
a467 1
cd9660_blkatoff(ap)
d473 1
a473 2
	} */ *ap;
{
d485 1
a485 1
	if (error = bread(ap->a_vp, lbn, bsize, NOCRED, &bp)) {
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
