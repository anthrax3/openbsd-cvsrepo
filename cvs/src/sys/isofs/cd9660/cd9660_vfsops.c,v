head	1.84;
access;
symbols
	OPENBSD_6_1:1.83.0.4
	OPENBSD_6_1_BASE:1.83
	OPENBSD_6_0:1.80.0.2
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.71.0.2
	OPENBSD_5_9_BASE:1.71
	OPENBSD_5_8:1.70.0.4
	OPENBSD_5_8_BASE:1.70
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.68.0.4
	OPENBSD_5_6_BASE:1.68
	OPENBSD_5_5:1.66.0.4
	OPENBSD_5_5_BASE:1.66
	OPENBSD_5_4:1.64.0.2
	OPENBSD_5_4_BASE:1.64
	OPENBSD_5_3:1.61.0.2
	OPENBSD_5_3_BASE:1.61
	OPENBSD_5_2:1.60.0.6
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.4
	OPENBSD_5_0:1.60.0.2
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.53.0.4
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.53.0.2
	OPENBSD_4_7_BASE:1.53
	OPENBSD_4_6:1.49.0.4
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.48.0.4
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.47.0.2
	OPENBSD_4_3_BASE:1.47
	OPENBSD_4_2:1.46.0.2
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.42.0.4
	OPENBSD_4_1_BASE:1.42
	OPENBSD_4_0:1.42.0.2
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.38.0.2
	OPENBSD_3_9_BASE:1.38
	OPENBSD_3_8:1.35.0.10
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.8
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.6
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.32.0.4
	OPENBSD_3_3_BASE:1.32
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.26.0.2
	UBC_BASE:1.26
	OPENBSD_3_0:1.22.0.2
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.20.0.2
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.19.0.4
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.2
	SMP_BASE:1.19
	kame_19991208:1.18
	OPENBSD_2_6:1.18.0.2
	OPENBSD_2_6_BASE:1.18
	OPENBSD_2_5:1.15.0.4
	OPENBSD_2_5_BASE:1.15
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2017.04.20.14.13.00;	author visa;	state Exp;
branches;
next	1.83;
commitid	GnoPKa34InShCqYl;

1.83
date	2016.09.07.17.30.12;	author natano;	state Exp;
branches;
next	1.82;
commitid	D0avTYSlvEmEjLyB;

1.82
date	2016.09.02.10.16.03;	author tom;	state Exp;
branches;
next	1.81;
commitid	dcQ5QPWzll6YmxJz;

1.81
date	2016.08.13.20.53.17;	author guenther;	state Exp;
branches;
next	1.80;
commitid	15rk0aE492iEzsGW;

1.80
date	2016.06.19.11.54.33;	author natano;	state Exp;
branches;
next	1.79;
commitid	wHLNY5GFNXJSFYaC;

1.79
date	2016.05.22.20.27.04;	author bluhm;	state Exp;
branches;
next	1.78;
commitid	IMex9jbP378m0AFa;

1.78
date	2016.04.26.18.37.02;	author natano;	state Exp;
branches;
next	1.77;
commitid	WbumX8gCUOD8jZ5X;

1.77
date	2016.03.27.11.39.37;	author bluhm;	state Exp;
branches;
next	1.76;
commitid	C0IKsjKoZxFScK3M;

1.76
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.75;
commitid	gAjwyca5TfuoJAhn;

1.75
date	2016.03.17.18.52.31;	author bluhm;	state Exp;
branches;
next	1.74;
commitid	XOU3hWgTktDOU9BT;

1.74
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.73;
commitid	kCz5QgxnxRMKOzNf;

1.73
date	2016.03.07.18.43.59;	author naddy;	state Exp;
branches;
next	1.72;
commitid	Z6e4eqr6FuYFPnlL;

1.72
date	2016.02.27.18.50.38;	author natano;	state Exp;
branches;
next	1.71;
commitid	gFybgYMymUyTbVeS;

1.71
date	2015.09.09.15.59.19;	author krw;	state Exp;
branches;
next	1.70;
commitid	WE3N3dW2fdeI55Mk;

1.70
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.69;
commitid	p4LJxGKbi0BU2cG6;

1.69
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.68;
commitid	P6Av4XGqOi3rFasL;

1.68
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.67;
commitid	C8XZQyreqTUCeixA;

1.67
date	2014.05.09.03.54.28;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2013.12.01.16.40.56;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2013.11.21.00.13.33;	author dlg;	state Exp;
branches;
next	1.64;

1.64
date	2013.06.02.01.07.39;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2013.05.30.17.35.01;	author guenther;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.15.15.32.19;	author jsing;	state Exp;
branches;
next	1.61;

1.61
date	2012.09.10.11.10.59;	author jsing;	state Exp;
branches;
next	1.60;

1.60
date	2011.07.04.20.35.35;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2011.07.04.04.30.41;	author tedu;	state Exp;
branches;
next	1.58;

1.58
date	2011.04.16.03.21.15;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2011.04.15.14.57.29;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.21.20.14.43;	author thib;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.10.16.34.08;	author thib;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.06.23.44.10;	author thib;	state Exp;
branches;
next	1.53;

1.53
date	2009.12.19.00.27.17;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2009.12.12.06.44.46;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.09.22.29.55;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.21.23.45.48;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.23.16.24.43;	author beck;	state Exp;
branches;
next	1.47;

1.47
date	2007.10.03.10.52.11;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.08.05.35.32;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.05.00.38.22;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.03.25.10.20.50;	author pedro;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.21.13.44.04;	author pedro;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.07.15.50.42;	author pedro;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.06.18.42.01;	author thib;	state Exp;
branches;
next	1.40;

1.40
date	2006.06.28.15.07.00;	author pedro;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.19.11.55.55;	author pedro;	state Exp;
branches;
next	1.38;

1.38
date	2006.01.22.00.40.02;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.30.10.35.07;	author pedro;	state Exp;
branches;
next	1.36;

1.36
date	2005.11.09.02.38.38;	author pedro;	state Exp;
branches;
next	1.35;

1.35
date	2003.08.14.07.46.39;	author mickey;	state Exp;
branches
	1.35.8.1
	1.35.10.1;
next	1.34;

1.34
date	2003.06.02.23.28.05;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.06.21.43.23;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.23.18.54.12;	author espie;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.03.16.09;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.10.03.34.35;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2002.01.25.04.50.20;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2001.12.19.08.58.06;	author art;	state Exp;
branches;
next	1.26;

1.26
date	2001.12.10.04.45.31;	author art;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.11.27.05.27.11;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.08.27.28;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.03.23.27.43;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.23.02.14.22;	author csapuntz;	state Exp;
branches;
next	1.21;

1.21
date	2001.02.20.01.50.09;	author assar;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.07.23.25.08;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2000.02.07.04.57.15;	author assar;	state Exp;
branches
	1.19.2.1
	1.19.4.1;
next	1.18;

1.18
date	99.08.17.10.56.07;	author art;	state Exp;
branches;
next	1.17;

1.17
date	99.07.01.02.20.22;	author d;	state Exp;
branches;
next	1.16;

1.16
date	99.05.31.17.34.46;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	98.09.06.20.31.31;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	98.08.21.23.31.35;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.02.08.22.41.32;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	97.11.08.17.21.08;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	97.11.06.05.58.11;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	97.10.06.20.19.45;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	97.10.06.15.08.44;	author csapuntz;	state Exp;
branches;
next	1.8;

1.8
date	97.06.04.23.55.30;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.05.28.21.30.38;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.01.21.21.34.18;	author rahnds;	state Exp;
branches;
next	1.5;

1.5
date	96.12.25.10.21.40;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.12.05.13.40.28;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.12.05.13.08.11;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.02.29.10.12.26;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.42;	author deraadt;	state Exp;
branches;
next	;

1.19.2.1
date	2001.05.14.22.32.37;	author niklas;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2001.07.04.10.48.08;	author niklas;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2001.11.13.23.04.23;	author niklas;	state Exp;
branches;
next	1.19.2.4;

1.19.2.4
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.19.2.5;

1.19.2.5
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.19.2.6;

1.19.2.6
date	2002.03.28.15.02.00;	author niklas;	state Exp;
branches;
next	1.19.2.7;

1.19.2.7
date	2003.03.28.00.00.19;	author niklas;	state Exp;
branches;
next	1.19.2.8;

1.19.2.8
date	2003.05.13.19.21.27;	author ho;	state Exp;
branches;
next	1.19.2.9;

1.19.2.9
date	2003.06.07.11.03.40;	author ho;	state Exp;
branches;
next	1.19.2.10;

1.19.2.10
date	2004.02.19.10.56.36;	author niklas;	state Exp;
branches;
next	;

1.19.4.1
date	2000.06.09.05.17.51;	author jason;	state Exp;
branches;
next	;

1.26.2.1
date	2002.01.31.22.55.40;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2002.06.11.03.29.20;	author art;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2003.05.19.21.53.27;	author tedu;	state Exp;
branches;
next	;

1.35.8.1
date	2005.12.01.00.45.20;	author brad;	state Exp;
branches;
next	;

1.35.10.1
date	2005.12.01.00.42.13;	author brad;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Tweak lock inits to make the system runnable with witness(4)
on amd64 and i386.
@
text
@/*	$OpenBSD: cd9660_vfsops.c,v 1.83 2016/09/07 17:30:12 natano Exp $	*/
/*	$NetBSD: cd9660_vfsops.c,v 1.26 1997/06/13 15:38:58 pk Exp $	*/

/*-
 * Copyright (c) 1994
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley
 * by Pace Willisson (pace@@blitz.com).  The Rock Ridge Extension
 * Support code is derived from software contributed to Berkeley
 * by Atsushi Murai (amurai@@spec.co.jp).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)cd9660_vfsops.c	8.9 (Berkeley) 12/5/94
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/lock.h>
#include <sys/specdev.h>
#include <sys/mount.h>
#include <sys/buf.h>
#include <sys/file.h>
#include <sys/disklabel.h>
#include <sys/ioctl.h>
#include <sys/cdio.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/stat.h>

#include <isofs/cd9660/iso.h>
#include <isofs/cd9660/cd9660_extern.h>
#include <isofs/cd9660/iso_rrip.h>
#include <isofs/cd9660/cd9660_node.h>

const struct vfsops cd9660_vfsops = {
	cd9660_mount,
	cd9660_start,
	cd9660_unmount,
	cd9660_root,
	cd9660_quotactl,
	cd9660_statfs,
	cd9660_sync,
	cd9660_vget,
	cd9660_fhtovp,
	cd9660_vptofh,
	cd9660_init,
	cd9660_sysctl,
	cd9660_check_export
};

/*
 * Called by vfs_mountroot when iso is going to be mounted as root.
 */

static	int iso_mountfs(struct vnode *devvp, struct mount *mp,
	    struct proc *p, struct iso_args *argp);
int	iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	    struct disklabel *lp);

int
cd9660_mountroot(void)
{
	struct mount *mp;
	extern struct vnode *rootvp;
	struct proc *p = curproc;	/* XXX */
	int error;
	struct iso_args args;

	/*
	 * Get vnodes for swapdev and rootdev.
	 */
	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("cd9660_mountroot: can't setup bdevvp's");
                return (error);
        }

	if ((error = vfs_rootmountalloc("cd9660", "root_device", &mp)) != 0)
		return (error);
	args.flags = ISOFSMNT_ROOT;
	if ((error = iso_mountfs(rootvp, mp, p, &args)) != 0) {
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp);
                free(mp, M_MOUNT, 0);
                return (error);
        }

        TAILQ_INSERT_TAIL(&mountlist, mp, mnt_list);
        (void)cd9660_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp);
	inittodr(0);

        return (0);
}

/*
 * VFS Operations.
 *
 * mount system call
 */
int
cd9660_mount(mp, path, data, ndp, p)
	register struct mount *mp;
	const char *path;
	void *data;
	struct nameidata *ndp;
	struct proc *p;
{
	struct iso_mnt *imp = NULL;
	struct iso_args args;
	struct vnode *devvp;
	char fspec[MNAMELEN];
	int error;

	if ((mp->mnt_flag & MNT_RDONLY) == 0)
		return (EROFS);

	error = copyin(data, &args, sizeof(struct iso_args));
	if (error)
		return (error);

	/*
	 * If updating, check whether changing from read-only to
	 * read/write; if there is no device name, that's all we do.
	 */
	if (mp->mnt_flag & MNT_UPDATE) {
		imp = VFSTOISOFS(mp);
		if (args.fspec == NULL)
			return (vfs_export(mp, &imp->im_export,
			    &args.export_info));
	}

	/*
	 * Not an update, or updating the name: look up the name
	 * and verify that it refers to a sensible block device.
	 */
	error = copyinstr(args.fspec, fspec, sizeof(fspec), NULL);
	if (error)
		return (error);
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_SYSSPACE, fspec, p);
	if ((error = namei(ndp)) != 0)
		return (error);
	devvp = ndp->ni_vp;

	if (devvp->v_type != VBLK) {
		vrele(devvp);
		return (ENOTBLK);
	}
	if (major(devvp->v_rdev) >= nblkdev) {
		vrele(devvp);
		return (ENXIO);
	}

	if ((mp->mnt_flag & MNT_UPDATE) == 0)
		error = iso_mountfs(devvp, mp, p, &args);
	else {
		if (devvp != imp->im_devvp)
			error = EINVAL;	/* needs translation */
		else
			vrele(devvp);
	}
	if (error) {
		vrele(devvp);
		return (error);
	}

	bzero(mp->mnt_stat.f_mntonname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntonname, path, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromname, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromname, fspec, MNAMELEN);
	bzero(mp->mnt_stat.f_mntfromspec, MNAMELEN);
	strlcpy(mp->mnt_stat.f_mntfromspec, fspec, MNAMELEN);
	bcopy(&args, &mp->mnt_stat.mount_info.iso_args, sizeof(args));

	cd9660_statfs(mp, &mp->mnt_stat, p);

	return (0);
}

/*
 * Common code for mount and mountroot
 */
static int
iso_mountfs(devvp, mp, p, argp)
	register struct vnode *devvp;
	struct mount *mp;
	struct proc *p;
	struct iso_args *argp;
{
	register struct iso_mnt *isomp = NULL;
	struct buf *bp = NULL;
	struct buf *pribp = NULL, *supbp = NULL;
	dev_t dev = devvp->v_rdev;
	int error = EINVAL;
	int ronly = (mp->mnt_flag & MNT_RDONLY) != 0;
	extern struct vnode *rootvp;
	int iso_bsize;
	int iso_blknum;
	int joliet_level;
	struct iso_volume_descriptor *vdp;
	struct iso_primary_descriptor *pri = NULL;
	struct iso_supplementary_descriptor *sup = NULL;
	struct iso_directory_record *rootp;
	int logical_block_size;
	int sess;

	if (!ronly)
		return (EROFS);

	/*
	 * Disallow multiple mounts of the same device.
	 * Disallow mounting of a device that is currently in use
	 * (except for root, which might share swap device for miniroot).
	 * Flush out any old buffers remaining from a previous use.
	 */
	if ((error = vfs_mountedon(devvp)) != 0)
		return (error);
	if (vcount(devvp) > 1 && devvp != rootvp)
		return (EBUSY);
	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0);
	VOP_UNLOCK(devvp, p);
	if (error)
		return (error);

	error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p);
	if (error)
		return (error);

	/*
	 * This is the "logical sector size".  The standard says this
	 * should be 2048 or the physical sector size on the device,
	 * whichever is greater.  For now, we'll just use a constant.
	 */
	iso_bsize = ISO_DEFAULT_BLOCK_SIZE;

	if (argp->flags & ISOFSMNT_SESS) {
		sess = argp->sess;
		if (sess < 0)
			sess = 0;
	} else {
		sess = 0;
		error = VOP_IOCTL(devvp, CDIOREADMSADDR, (caddr_t)&sess, 0,
		    FSCRED, p);
		if (error)
			sess = 0;
	}

	joliet_level = 0;
	for (iso_blknum = 16; iso_blknum < 100; iso_blknum++) {
		if ((error = bread(devvp,
		    (iso_blknum + sess) * btodb(iso_bsize),
		    iso_bsize, &bp)) != 0)
			goto out;

		vdp = (struct iso_volume_descriptor *)bp->b_data;
		if (bcmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) != 0) {
			error = EINVAL;
			goto out;
		}

		switch (isonum_711 (vdp->type)){
		case ISO_VD_PRIMARY:
			if (pribp == NULL) {
				pribp = bp;
				bp = NULL;
				pri = (struct iso_primary_descriptor *)vdp;
			}
			break;
		case ISO_VD_SUPPLEMENTARY:
			if (supbp == NULL) {
				supbp = bp;
				bp = NULL;
				sup = (struct iso_supplementary_descriptor *)vdp;

				if (!(argp->flags & ISOFSMNT_NOJOLIET)) {
					if (bcmp(sup->escape, "%/@@", 3) == 0)
						joliet_level = 1;
					if (bcmp(sup->escape, "%/C", 3) == 0)
						joliet_level = 2;
					if (bcmp(sup->escape, "%/E", 3) == 0)
						joliet_level = 3;

					if (isonum_711 (sup->flags) & 1)
						joliet_level = 0;
				}
			}
			break;

		case ISO_VD_END:
			goto vd_end;

		default:
			break;
		}
		if (bp) {
			brelse(bp);
			bp = NULL;
		}
	}
    vd_end:
	if (bp) {
		brelse(bp);
		bp = NULL;
	}

	if (pri == NULL) {
		error = EINVAL;
		goto out;
	}

	logical_block_size = isonum_723 (pri->logical_block_size);

	if (logical_block_size < DEV_BSIZE || logical_block_size > MAXBSIZE
	    || (logical_block_size & (logical_block_size - 1)) != 0) {
		error = EINVAL;
		goto out;
	}

	rootp = (struct iso_directory_record *)pri->root_directory_record;

	isomp = malloc(sizeof *isomp, M_ISOFSMNT, M_WAITOK);
	bzero((caddr_t)isomp, sizeof *isomp);
	isomp->logical_block_size = logical_block_size;
	isomp->volume_space_size = isonum_733 (pri->volume_space_size);
	bcopy (rootp, isomp->root, sizeof isomp->root);
	isomp->root_extent = isonum_733 (rootp->extent);
	isomp->root_size = isonum_733 (rootp->size);
	isomp->joliet_level = 0;
	/*
	 * Since an ISO9660 multi-session CD can also access previous sessions,
	 * we have to include them into the space considerations.
	 */
	isomp->volume_space_size += sess;
	isomp->im_bmask = logical_block_size - 1;
	isomp->im_bshift = ffs(logical_block_size) - 1;

	brelse(pribp);
	pribp = NULL;

	mp->mnt_data = isomp;
	mp->mnt_stat.f_fsid.val[0] = (long)dev;
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
	mp->mnt_stat.f_namemax = NAME_MAX;
	mp->mnt_flag |= MNT_LOCAL;
	isomp->im_mountp = mp;
	isomp->im_dev = dev;
	isomp->im_devvp = devvp;

	/* Check the Rock Ridge Extension support */
	if (!(argp->flags & ISOFSMNT_NORRIP)) {
		if ((error = bread(isomp->im_devvp, (isomp->root_extent +
		    isonum_711(rootp->ext_attr_length)) <<
		    (isomp->im_bshift - DEV_BSHIFT),
		    isomp->logical_block_size, &bp)) != 0)
			goto out;

		rootp = (struct iso_directory_record *)bp->b_data;

		if ((isomp->rr_skip = cd9660_rrip_offset(rootp,isomp)) < 0) {
		    argp->flags  |= ISOFSMNT_NORRIP;
		} else {
		    argp->flags  &= ~ISOFSMNT_GENS;
		}

		/*
		 * The contents are valid,
		 * but they will get reread as part of another vnode, so...
		 */
		brelse(bp);
		bp = NULL;
	}
	isomp->im_flags = argp->flags & (ISOFSMNT_NORRIP | ISOFSMNT_GENS |
	    ISOFSMNT_EXTATT | ISOFSMNT_NOJOLIET);
	switch (isomp->im_flags & (ISOFSMNT_NORRIP | ISOFSMNT_GENS)) {
	default:
	    isomp->iso_ftype = ISO_FTYPE_DEFAULT;
	    break;
	case ISOFSMNT_GENS|ISOFSMNT_NORRIP:
	    isomp->iso_ftype = ISO_FTYPE_9660;
	    break;
	case 0:
	    isomp->iso_ftype = ISO_FTYPE_RRIP;
	    break;
	}

	/* Decide whether to use the Joliet descriptor */

	if (isomp->iso_ftype != ISO_FTYPE_RRIP && joliet_level) {
		rootp = (struct iso_directory_record *)
			sup->root_directory_record;
		bcopy(rootp, isomp->root, sizeof isomp->root);
		isomp->root_extent = isonum_733(rootp->extent);
		isomp->root_size = isonum_733(rootp->size);
		isomp->joliet_level = joliet_level;
	}

	if (supbp) {
		brelse(supbp);
		supbp = NULL;
	}

	devvp->v_specmountpoint = mp;

	return (0);
out:
	if (devvp->v_specinfo)
		devvp->v_specmountpoint = NULL;
	if (bp)
		brelse(bp);
	if (supbp)
		brelse(supbp);

	vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
	VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
	VOP_UNLOCK(devvp, p);

	if (isomp) {
		free((caddr_t)isomp, M_ISOFSMNT, 0);
		mp->mnt_data = NULL;
	}
	return (error);
}

/*
 * Test to see if the device is an ISOFS filesystem.
 */
int
iso_disklabelspoof(dev, strat, lp)
	dev_t dev;
	void (*strat)(struct buf *);
	register struct disklabel *lp;
{
	struct buf *bp = NULL;
	struct iso_volume_descriptor *vdp;
	struct iso_primary_descriptor *pri;
	int logical_block_size;
	int error = EINVAL;
	int iso_blknum;
	int i;

	bp = geteblk(ISO_DEFAULT_BLOCK_SIZE);
	bp->b_dev = dev;

	for (iso_blknum = 16; iso_blknum < 100; iso_blknum++) {
		bp->b_blkno = iso_blknum * btodb(ISO_DEFAULT_BLOCK_SIZE);
		bp->b_bcount = ISO_DEFAULT_BLOCK_SIZE;
		CLR(bp->b_flags, B_READ | B_WRITE | B_DONE);
		SET(bp->b_flags, B_BUSY | B_READ | B_RAW);

		/*printf("d_secsize %d iso_blknum %d b_blkno %d bcount %d\n",
		    lp->d_secsize, iso_blknum, bp->b_blkno, bp->b_bcount);*/

		(*strat)(bp);

		if (biowait(bp))
			goto out;

		vdp = (struct iso_volume_descriptor *)bp->b_data;
		/*printf("%2x%2x%2x type %2x\n", vdp->id[0], vdp->id[1],
		    vdp->id[2], isonum_711(vdp->type));*/
		if (bcmp (vdp->id, ISO_STANDARD_ID, sizeof vdp->id) != 0 ||
		    isonum_711 (vdp->type) == ISO_VD_END)
			goto out;

		if (isonum_711 (vdp->type) == ISO_VD_PRIMARY)
			break;
	}

	if (isonum_711 (vdp->type) != ISO_VD_PRIMARY)
		goto out;

	pri = (struct iso_primary_descriptor *)vdp;
	logical_block_size = isonum_723 (pri->logical_block_size);
	if (logical_block_size < DEV_BSIZE || logical_block_size > MAXBSIZE ||
	    (logical_block_size & (logical_block_size - 1)) != 0)
		goto out;

	/*
	 * build a disklabel for the CD
	 */
	strncpy(lp->d_typename, pri->volume_id, sizeof lp->d_typename);
	strncpy(lp->d_packname, pri->volume_id+16, sizeof lp->d_packname);
	for (i = 0; i < MAXPARTITIONS; i++) {
		DL_SETPSIZE(&lp->d_partitions[i], 0);
		DL_SETPOFFSET(&lp->d_partitions[i], 0);
	}
	DL_SETPOFFSET(&lp->d_partitions[0], 0);
	DL_SETPSIZE(&lp->d_partitions[0], DL_GETDSIZE(lp));
	lp->d_partitions[0].p_fstype = FS_ISO9660;
	DL_SETPOFFSET(&lp->d_partitions[RAW_PART], 0);
	DL_SETPSIZE(&lp->d_partitions[RAW_PART], DL_GETDSIZE(lp));
	lp->d_partitions[RAW_PART].p_fstype = FS_ISO9660;
	lp->d_npartitions = MAXPARTITIONS;
	lp->d_bbsize = 8192;		/* fake */
	lp->d_sbsize = 64*1024;		/* fake */
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);
	error = 0;
out:
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (error);
}

/*
 * Make a filesystem operational.
 * Nothing to do at the moment.
 */
/* ARGSUSED */
int
cd9660_start(mp, flags, p)
	struct mount *mp;
	int flags;
	struct proc *p;
{
	return (0);
}

/*
 * unmount system call
 */
int
cd9660_unmount(mp, mntflags, p)
	struct mount *mp;
	int mntflags;
	struct proc *p;
{
	register struct iso_mnt *isomp;
	int error, flags = 0;

	if (mntflags & MNT_FORCE)
		flags |= FORCECLOSE;
#if 0
	mntflushbuf(mp, 0);
	if (mntinvalbuf(mp))
		return (EBUSY);
#endif
	if ((error = vflush(mp, NULLVP, flags)) != 0)
		return (error);

	isomp = VFSTOISOFS(mp);

	isomp->im_devvp->v_specmountpoint = NULL;
	vn_lock(isomp->im_devvp, LK_EXCLUSIVE | LK_RETRY, p);
	(void)VOP_CLOSE(isomp->im_devvp, FREAD, NOCRED, p);
	vput(isomp->im_devvp);
	free((caddr_t)isomp, M_ISOFSMNT, 0);
	mp->mnt_data = NULL;
	mp->mnt_flag &= ~MNT_LOCAL;
	return (0);
}

/*
 * Return root of a filesystem
 */
int
cd9660_root(mp, vpp)
	struct mount *mp;
	struct vnode **vpp;
{
	struct iso_mnt *imp = VFSTOISOFS(mp);
	struct iso_directory_record *dp =
	    (struct iso_directory_record *)imp->root;
	cdino_t ino = isodirino(dp, imp);

	/*
	 * With RRIP we must use the `.' entry of the root directory.
	 * Simply tell vget, that it's a relocated directory.
	 */
	return (cd9660_vget_internal(mp, ino, vpp,
	    imp->iso_ftype == ISO_FTYPE_RRIP, dp));
}

/*
 * Do operations associated with quotas, not supported
 */
/* ARGSUSED */
int
cd9660_quotactl(mp, cmd, uid, arg, p)
	struct mount *mp;
	int cmd;
	uid_t uid;
	caddr_t arg;
	struct proc *p;
{

	return (EOPNOTSUPP);
}

/*
 * Get file system statistics.
 */
int
cd9660_statfs(mp, sbp, p)
	struct mount *mp;
	register struct statfs *sbp;
	struct proc *p;
{
	register struct iso_mnt *isomp;

	isomp = VFSTOISOFS(mp);

	sbp->f_bsize = isomp->logical_block_size;
	sbp->f_iosize = sbp->f_bsize;	/* XXX */
	sbp->f_blocks = isomp->volume_space_size;
	sbp->f_bfree = 0; /* total free blocks */
	sbp->f_bavail = 0; /* blocks free for non superuser */
	sbp->f_files =  0; /* total files */
	sbp->f_ffree = 0; /* free file nodes */
	sbp->f_favail = 0; /* file nodes free for non superuser */
	copy_statfs_info(sbp, mp);

	return (0);
}

/* ARGSUSED */
int
cd9660_sync(mp, waitfor, cred, p)
	struct mount *mp;
	int waitfor;
	struct ucred *cred;
	struct proc *p;
{
	return (0);
}

/*
 * File handle to vnode
 *
 * Have to be really careful about stale file handles:
 * - check that the inode number is in range
 * - call iget() to get the locked inode
 * - check for an unallocated inode (i_mode == 0)
 * - check that the generation number matches
 */

struct ifid {
	ushort	ifid_len;
	ushort	ifid_pad;
	int	ifid_ino;
	long	ifid_start;
};

/* ARGSUSED */
int
cd9660_fhtovp(mp, fhp, vpp)
	register struct mount *mp;
	struct fid *fhp;
	struct vnode **vpp;
{
	struct ifid *ifhp = (struct ifid *)fhp;
	register struct iso_node *ip;
	struct vnode *nvp;
	int error;

#ifdef	ISOFS_DBG
	printf("fhtovp: ino %d, start %ld\n", ifhp->ifid_ino,
	    ifhp->ifid_start);
#endif

	if ((error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
	ip = VTOI(nvp);
	if (ip->inode.iso_mode == 0) {
		vput(nvp);
		*vpp = NULLVP;
		return (ESTALE);
	}
	*vpp = nvp;
	return (0);
}

int
cd9660_vget(mp, ino, vpp)
	struct mount *mp;
	ino_t ino;
	struct vnode **vpp;
{

	if (ino > (cdino_t)-1)
		panic("cd9660_vget: alien ino_t %llu",
		    (unsigned long long)ino);

	/*
	 * XXXX
	 * It would be nice if we didn't always set the `relocated' flag
	 * and force the extra read, but I don't want to think about fixing
	 * that right now.
	 */
	return (cd9660_vget_internal(mp, ino, vpp,
#if 0
	    VFSTOISOFS(mp)->iso_ftype == ISO_FTYPE_RRIP,
#else
	    0,
#endif
	    NULL));
}

int
cd9660_vget_internal(mp, ino, vpp, relocated, isodir)
	struct mount *mp;
	cdino_t ino;
	struct vnode **vpp;
	int relocated;
	struct iso_directory_record *isodir;
{
	register struct iso_mnt *imp;
	struct iso_node *ip;
	struct buf *bp;
	struct vnode *vp, *nvp;
	dev_t dev;
	int error;

retry:
	imp = VFSTOISOFS(mp);
	dev = imp->im_dev;
	if ((*vpp = cd9660_ihashget(dev, ino)) != NULLVP)
		return (0);

	/* Allocate a new vnode/iso_node. */
	if ((error = getnewvnode(VT_ISOFS, mp, &cd9660_vops, &vp)) != 0) {
		*vpp = NULLVP;
		return (error);
	}
	ip = malloc(sizeof(*ip), M_ISOFSNODE, M_WAITOK | M_ZERO);
	rrw_init_flags(&ip->i_lock, "isoinode", RWL_DUPOK);
	vp->v_data = ip;
	ip->i_vnode = vp;
	ip->i_dev = dev;
	ip->i_number = ino;

	/*
	 * Put it onto its hash chain and lock it so that other requests for
	 * this inode will block if they arrive while we are sleeping waiting
	 * for old data structures to be purged or for the contents of the
	 * disk portion of this inode to be read.
	 */
	error = cd9660_ihashins(ip);

	if (error) {
		vrele(vp);

		if (error == EEXIST)
			goto retry;

		return (error);
	}

	if (isodir == 0) {
		int lbn, off;

		lbn = lblkno(imp, ino);
		if (lbn >= imp->volume_space_size) {
			vput(vp);
			printf("fhtovp: lbn exceed volume space %d\n", lbn);
			return (ESTALE);
		}

		off = blkoff(imp, ino);
		if (off + ISO_DIRECTORY_RECORD_SIZE > imp->logical_block_size)
		    {
			vput(vp);
			printf("fhtovp: crosses block boundary %d\n",
			    off + ISO_DIRECTORY_RECORD_SIZE);
			return (ESTALE);
		}

		error = bread(imp->im_devvp,
			      lbn << (imp->im_bshift - DEV_BSHIFT),
			      imp->logical_block_size, &bp);
		if (error) {
			vput(vp);
			brelse(bp);
			printf("fhtovp: bread error %d\n",error);
			return (error);
		}
		isodir = (struct iso_directory_record *)(bp->b_data + off);

		if (off + isonum_711(isodir->length) >
		    imp->logical_block_size) {
			vput(vp);
			if (bp != 0)
				brelse(bp);
			printf("fhtovp: directory crosses block boundary %d[off=%d/len=%d]\n",
			    off +isonum_711(isodir->length), off,
			    isonum_711(isodir->length));
			return (ESTALE);
		}

#if 0
		if (isonum_733(isodir->extent) +
		    isonum_711(isodir->ext_attr_length) != ifhp->ifid_start) {
			if (bp != 0)
				brelse(bp);
			printf("fhtovp: file start miss %d vs %d\n",
			    isonum_733(isodir->extent) +
			    isonum_711(isodir->ext_attr_length),
			    ifhp->ifid_start);
			return (ESTALE);
		}
#endif
	} else
		bp = 0;

	ip->i_mnt = imp;
	ip->i_devvp = imp->im_devvp;
	vref(ip->i_devvp);

	if (relocated) {
		/*
		 * On relocated directories we must
		 * read the `.' entry out of a dir.
		 */
		ip->iso_start = ino >> imp->im_bshift;
		if (bp != 0)
			brelse(bp);
		if ((error = cd9660_bufatoff(ip, (off_t)0, NULL, &bp)) != 0) {
			vput(vp);
			return (error);
		}
		isodir = (struct iso_directory_record *)bp->b_data;
	}

	ip->iso_extent = isonum_733(isodir->extent);
	ip->i_size = (u_int32_t) isonum_733(isodir->size);
	ip->iso_start = isonum_711(isodir->ext_attr_length) + ip->iso_extent;

	/*
	 * Setup time stamp, attribute
	 */
	vp->v_type = VNON;
	switch (imp->iso_ftype) {
	default:	/* ISO_FTYPE_9660 */
	    {
		struct buf *bp2;
		int off;
		if ((imp->im_flags & ISOFSMNT_EXTATT) &&
		    (off = isonum_711(isodir->ext_attr_length)))
			cd9660_bufatoff(ip, (off_t)-(off << imp->im_bshift),
			    NULL, &bp2);
		else
			bp2 = NULL;
		cd9660_defattr(isodir, ip, bp2);
		cd9660_deftstamp(isodir, ip, bp2);
		if (bp2)
			brelse(bp2);
		break;
	    }
	case ISO_FTYPE_RRIP:
		cd9660_rrip_analyze(isodir, ip, imp);
		break;
	}

	if (bp != 0)
		brelse(bp);

	/*
	 * Initialize the associated vnode
	 */
	switch (vp->v_type = IFTOVT(ip->inode.iso_mode)) {
	case VFIFO:
#ifdef	FIFO
		vp->v_op = &cd9660_fifovops;
		break;
#else
		vput(vp);
		return (EOPNOTSUPP);
#endif	/* FIFO */
	case VCHR:
	case VBLK:
		/*
		 * if device, look at device number table for translation
		 */
		vp->v_op = &cd9660_specvops;
		if ((nvp = checkalias(vp, ip->inode.iso_rdev, mp)) != NULL) {
			/*
			 * Discard unneeded vnode, but save its iso_node.
			 * Note that the lock is carried over in the iso_node
			 */
			nvp->v_data = vp->v_data;
			vp->v_data = NULL;
			vp->v_op = &spec_vops;
			vrele(vp);
			vgone(vp);
			/*
			 * Reinitialize aliased inode.
			 */
			vp = nvp;
			ip->i_vnode = vp;
		}
		break;
	case VLNK:
	case VNON:
	case VSOCK:
	case VDIR:
	case VBAD:
		break;
	case VREG:
		uvm_vnp_setsize(vp, ip->i_size);
		break;
	}

	if (ip->iso_extent == imp->root_extent)
		vp->v_flag |= VROOT;

	/*
	 * XXX need generation number?
	 */

	*vpp = vp;
	return (0);
}

/*
 * Vnode pointer to File handle
 */
/* ARGSUSED */
int
cd9660_vptofh(vp, fhp)
	struct vnode *vp;
	struct fid *fhp;
{
	register struct iso_node *ip = VTOI(vp);
	register struct ifid *ifhp;

	ifhp = (struct ifid *)fhp;
	ifhp->ifid_len = sizeof(struct ifid);

	ifhp->ifid_ino = ip->i_number;
	ifhp->ifid_start = ip->iso_start;

#ifdef	ISOFS_DBG
	printf("vptofh: ino %d, start %ld\n",
	    ifhp->ifid_ino,ifhp->ifid_start);
#endif
	return (0);
}

/*
 * Verify a remote client has export rights and return these rights via
 * exflagsp and credanonp.
 */
int
cd9660_check_export(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
{
	register struct netcred *np;
	register struct iso_mnt *imp = VFSTOISOFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &imp->im_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
	return (0);
}
@


1.83
log
@Remove usermount remnants. ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.82 2016/09/02 10:16:03 tom Exp $	*/
d760 1
a760 1
	rrw_init(&ip->i_lock, "isoinode");
@


1.82
log
@Variable 'imp' is set earlier in cd9660_mount() if it's needed (when
MNT_UPDATE is set in mnt_flag), so remove an unnecessary assignment later.

ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.81 2016/08/13 20:53:17 guenther Exp $	*/
a181 13
	/*
	 * If mount by non-root, then verify that user has necessary
	 * permissions on the device.
	 */
	if (suser(p, 0) != 0) {
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		error = VOP_ACCESS(devvp, VREAD, p->p_ucred, p);
		if (error) {
			vput(devvp);
			return (error);
		}
		VOP_UNLOCK(devvp, p);
	}
@


1.81
log
@Eliminate pointless casts to qaddr_t of a value being assigned to a void*

ok kettenis@@ krw@@ natano@@ dlg@@ espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.80 2016/06/19 11:54:33 natano Exp $	*/
a206 1
	imp = VFSTOISOFS(mp);
@


1.80
log
@Remove the lockmgr() API. It is only used by filesystems, where it is a
trivial change to use rrw locks instead. All it needs is LK_* defines
for the RW_* flags.

tested by naddy and sthen on package building infrastructure
input and ok jmc mpi tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.79 2016/05/22 20:27:04 bluhm Exp $	*/
d383 1
a383 1
	mp->mnt_data = (qaddr_t)isomp;
@


1.79
log
@When pulling an msdos formated umass stick during mount while the
usb stack was busy, the kernel could trigger an uvm fault.  There
is a race between vop_generic_revoke() and sys_mount() where vgonel()
could reset v_specinfo.  Then v_specmountpoint is no longer valid.
So after sleeping, msdosfs_mountfs() could crash in the error path.
The code in the different *_mountfs() functions was inconsistent,
implement the same check everywhere.
OK krw@@ natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.78 2016/04/26 18:37:02 natano Exp $	*/
d774 1
a774 1
	lockinit(&ip->i_lock, PINOD, "isoinode", 0, 0);
@


1.78
log
@Populate all necessary statfs members in .vfs_statfs. cd9660, udf,
msdosfs and nfsv2 don't set f_namemax. ntfs and ext2fs don't set
f_namemeax and f_favail. fusefs doesn't set f_mntfromspec, f_favail and
f_iosize. Also, make all filesystems use copy_statfs_info(), so that all
statfs information is filled in correctly for the (sb != &mp->mnt-stat)
case.

ok stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.77 2016/03/27 11:39:37 bluhm Exp $	*/
d449 2
@


1.77
log
@When pulling and unmounting an umass USB stick, the file system
could end up in an inconsistent state.  The fstype dependent
mp->mnt_data was NULL, but the general mp was still listed as a
valid mount point.  Next access to the file system would crash with
a NULL pointer dereference.
If closing the device fails, the mount point must go away anyway.
There is nothing we can do about it.  Remove the workaround for the
EIO error in the general unmount code, but do not generate any error
in the file system specific unmount functions.
OK natano@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.76 2016/03/19 12:04:15 natano Exp $	*/
d386 1
d654 3
a656 7
	if (sbp != &mp->mnt_stat) {
		bcopy(mp->mnt_stat.f_mntonname, sbp->f_mntonname, MNAMELEN);
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname,
		    MNAMELEN);
		bcopy(&mp->mnt_stat.mount_info.iso_args,
		    &sbp->mount_info.iso_args, sizeof(struct iso_args));
	}
@


1.76
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.75 2016/03/17 18:52:31 bluhm Exp $	*/
d588 1
a588 1
	error = VOP_CLOSE(isomp->im_devvp, FREAD, NOCRED, p);
d593 1
a593 1
	return (error);
@


1.75
log
@Set mnt_data to NULL after freeing the file system specific mount point.
OK krw@@ natano@@ as part of a larger diff
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.74 2016/03/14 23:08:06 krw Exp $	*/
d193 1
a193 1
		VOP_UNLOCK(devvp, 0, p);
d264 1
a264 1
	VOP_UNLOCK(devvp, 0, p);
d455 1
a455 1
	VOP_UNLOCK(devvp, 0, p);
@


1.74
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.73 2016/03/07 18:43:59 naddy Exp $	*/
d459 1
a459 1
		mp->mnt_data = (qaddr_t)0;
d591 1
a591 1
	mp->mnt_data = (qaddr_t)0;
@


1.73
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.72 2016/02/27 18:50:38 natano Exp $	*/
d232 1
a232 1
	register struct iso_mnt *isomp = (struct iso_mnt *)0;
@


1.72
log
@Move mnt_maxsymlink from struct mount to struct ufsmount.

The concept of differentiating between "short" and "long" symlinks is
specific to ufs/, so it shouldn't creep into the generic fs layer.
Inspired by a similar commit to NetBSD.

While there replace all references to mnt_maxsymlinklen in ufs/ext2fs
with EXT2_MAXSYMLINKLEN, which is the constant max short symlink len for
ext2fs. This allows to get rid of some (mnt_maxsymlinklen == 0) checks
there, which is always false for ext2fs.

input and ok stefan@@
ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.71 2015/09/09 15:59:19 krw Exp $	*/
d89 1
a89 1
cd9660_mountroot()
@


1.71
log
@Nuke some extraneous whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.70 2015/03/14 03:38:50 jsg Exp $	*/
a385 1
	mp->mnt_maxsymlinklen = 0;
@


1.70
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.69 2014/12/16 18:30:03 tedu Exp $	*/
d96 1
a96 1
	
d142 1
a142 1
	
d145 1
a145 1
	
d157 1
a157 1
			return (vfs_export(mp, &imp->im_export, 
d248 1
a248 1
	
d251 1
a251 1
	
d271 1
a271 1
	
d297 1
a297 1
		
d303 1
a303 1
		
d317 1
a317 1
  
d325 1
a325 1
  
d331 1
a331 1
  
d334 1
a334 1
  
d348 1
a348 1
  
d355 1
a355 1
	
d361 1
a361 1
	
d363 1
a363 1
	
d372 1
a372 1
	/*                                                                  
d382 1
a382 1
	
d399 1
a399 1
		
d401 1
a401 1
		
d407 1
a407 1
		
d430 1
a430 1
  
d439 1
a439 1
  
d444 1
a444 1
  
d505 1
a505 1
		
d509 1
a509 1
	
d512 1
a512 1
	
d574 1
a574 1
	
d609 1
a609 1
	
d644 1
a644 1
	
d703 1
a703 1
	
d708 1
a708 1
	
d808 1
a808 1
	
d817 1
a817 1
	
d839 1
a839 1
	
d877 1
a877 1
	
d887 1
a887 1
		if ((imp->im_flags & ISOFSMNT_EXTATT) && 
d952 1
a952 1
	
d959 1
a959 1
	
d978 1
a978 1
	
d981 1
a981 1
	
@


1.69
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.68 2014/07/12 18:50:00 tedu Exp $	*/
a53 1
#include <sys/conf.h>
@


1.68
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.67 2014/05/09 03:54:28 tedu Exp $	*/
d46 1
@


1.67
log
@stop using B_AGE, it was effectively retired some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.66 2013/12/01 16:40:56 krw Exp $	*/
d112 1
a112 1
                free(mp, M_MOUNT);
d459 1
a459 1
		free((caddr_t)isomp, M_ISOFSMNT);
d591 1
a591 1
	free((caddr_t)isomp, M_ISOFSMNT);
@


1.66
log
@Change 'mountlist' from CIRCLEQ to TAILQ. Be paranoid and
use TAILQ_*_SAFE more than might be needed.

Bulk ports build by sthen@@ showed nobody sticking their fingers
so deep into the kernel.

Feedback and suggestions from millert@@. ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.65 2013/11/21 00:13:33 dlg Exp $	*/
a379 1
	pribp->b_flags |= B_AGE;
a411 1
		bp->b_flags |= B_AGE;
a437 1
		supbp->b_flags |= B_AGE;
@


1.65
log
@remove the #define b_cylinder b_resid from bufs. i hated the
overloading of that thing.

the only hardware that seems to care about cylinders in our tree
are floppy drives, and the drivers for those calculate their own
cylinders from logical block addresses and ignore whatever the rest
of the kernel thought b_cylinders should be.

most of this diff is moving the floppy drivers to using b_resid as
a resid and using that as part of the calculation for real cylinder
values.

the rest of the diff is getting rid of the useless assignments to
b_cylinder that dont get used by anything (now that disksort is
gone).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.64 2013/06/02 01:07:39 deraadt Exp $	*/
d116 1
a116 1
        CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
@


1.64
log
@Remove disabled ISODEVMAP support.  dev_t's on one system will not be
similar on another, so using that is crazy.
ok guenther krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.63 2013/05/30 17:35:01 guenther Exp $	*/
a492 1
		bp->b_cylinder = bp->b_blkno / lp->d_secpercyl;
@


1.63
log
@CD filesystems don't do inode numbers >2^32, so use a smaller type internally,
only using ino_t in the VFS layer APIs: vget, readdir, getattr.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.62 2013/04/15 15:32:19 jsing Exp $	*/
a590 5
#ifdef	ISODEVMAP
	if (isomp->iso_ftype == ISO_FTYPE_RRIP)
		iso_dunmap(isomp->im_dev);
#endif
	
a927 4
#ifdef	ISODEVMAP
		if (dp = iso_dmap(dev, ino, 0))
			ip->inode.iso_rdev = dp->d_dev;
#endif
@


1.62
log
@Add an f_mntfromspec member to struct statfs, which specifies the name of
the special provided when the mount was requested. This may be the same as
the special that was actually used for the mount (e.g. in the case of a
device node) or it may be different (e.g. in the case of a DUID).

Whilst here, change f_ctime to a 64 bit type and remove the pointless
f_spare members.

Compatibility goo courtesy of guenther@@

ok krw@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.61 2012/09/10 11:10:59 jsing Exp $	*/
d617 1
a617 1
	ino_t ino = isodirino(dp, imp);
d739 4
d761 1
a761 1
	ino_t ino;
@


1.61
log
@Cleanup VFS mount string handling:

- Avoid using copyinstr() without checking the return value.

- sys_mount() has already copied the path in, so pass this to the
  filesystem mount code so that it does not have to copy it in again.

- Avoid copyinstr()/bzero() dance when we can simply bzero() and strlcpy().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.59 2011/07/04 04:30:41 tedu Exp $	*/
d213 2
a669 2
	/* Use the first spare for flags: */
	sbp->f_spare[0] = isomp->im_flags;
@


1.60
log
@move the specfs code to a place people can see it; ok guenther thib krw
@
text
@d137 2
d140 1
a140 2
	struct iso_args args;
	size_t size;
a141 5
	struct iso_mnt *imp = NULL;
	
	error = copyin(data, &args, sizeof (struct iso_args));
	if (error)
		return (error);
d146 4
d156 1
a156 1
		if (args.fspec == 0)
d160 1
d165 4
a168 1
	NDINIT(ndp, LOOKUP, FOLLOW, UIO_USERSPACE, args.fspec, p);
d181 1
d208 5
a212 5
	(void)copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	(void)copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
d214 3
a216 1
	(void)cd9660_statfs(mp, &mp->mnt_stat, p);
@


1.59
log
@bread does nothing with its ucred argument.  remove it.  ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.58 2011/04/16 03:21:15 krw Exp $	*/
d46 1
a46 1
#include <miscfs/specfs/specdev.h>
@


1.58
log
@Use 'CLR(<buf>->b_flags, B_READ | B_WRITE | B_DONE)' regardless of
what the previous IO was. Less chance of copy and paste errors.
Suggested by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.57 2011/04/15 14:57:29 krw Exp $	*/
d286 1
a286 1
		    iso_bsize, NOCRED, &bp)) != 0)
d389 1
a389 1
		    isomp->logical_block_size, NOCRED, &bp)) != 0)
d818 1
a818 1
			      imp->logical_block_size, NOCRED, &bp);
@


1.57
log
@In days of yore one could arbitrarily whack buffer flags. Those days
are past. Use CLR() and SET() to modify necessary flags while leaving
the flags used by the buffer cache in peace.

Should make bufcache code much less confused about the state of the
bufs used in reading/writing disklabels. Other such flag abuses no
doubt await a visit.

Errors in original diff found by miod@@.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.56 2010/12/21 20:14:43 thib Exp $	*/
d482 1
a482 1
		CLR(bp->b_flags, B_WRITE | B_DONE);
@


1.56
log
@Bring back the "End the VOP experiment." diff, naddy's issues where
unrelated, and his alpha is much happier now.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.55 2010/09/10 16:34:08 thib Exp $	*/
d482 2
a483 1
		bp->b_flags = B_BUSY | B_READ | B_RAW;
@


1.55
log
@Backout the VOP diff until the issues naddy was seeing on alpha (gcc3)
have been resolved.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.54 2010/09/06 23:44:10 thib Exp $	*/
d768 1
a768 1
	if ((error = getnewvnode(VT_ISOFS, mp, cd9660_vnodeop_p, &vp)) != 0) {
d910 1
a910 1
		vp->v_op = cd9660_fifoop_p;
d925 1
a925 1
		vp->v_op = cd9660_specop_p;
d933 1
a933 1
			vp->v_op = spec_vnodeop_p;
@


1.54
log
@End the VOP experiment. Instead of the ridicolusly complicated operation
vector setup that has questionable features (that have, as far as I can
tell never been used in practice, atleast not in OpenBSD), remove all
the gunk and favor a simple struct full of function pointers that get
set directly by each of the filesystems.

Removes gobs of ugly code and makes things simpler by a magnitude.

The only downside of this is that we loose the vnoperate feature so
the spec/fifo operations of the filesystems need to be kept in sync
with specfs and fifofs, this is no big deal as the API it self is pretty
static.

Many thanks to armani@@ who pulled an earlier version of this diff to
current after c2k10 and Gabriel Kihlman on tech@@ for testing.

Liked by many. "come on, find your balls" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.53 2009/12/19 00:27:17 krw Exp $	*/
d768 1
a768 1
	if ((error = getnewvnode(VT_ISOFS, mp, &cd9660_vops, &vp)) != 0) {
d910 1
a910 1
		vp->v_op = &cd9660_fifovops;
d925 1
a925 1
		vp->v_op = &cd9660_specvops;
d933 1
a933 1
			vp->v_op = &spec_vops;
@


1.53
log
@Re-introduce the remaining bits of thib@@'s Aug 2006 VOP_CLOSE()
locking fixes. Tweak cd9660 code to be the same as everywhere else,
no functional change.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.52 2009/12/12 06:44:46 krw Exp $	*/
d768 1
a768 1
	if ((error = getnewvnode(VT_ISOFS, mp, cd9660_vnodeop_p, &vp)) != 0) {
d910 1
a910 1
		vp->v_op = cd9660_fifoop_p;
d925 1
a925 1
		vp->v_op = cd9660_specop_p;
d933 1
a933 1
			vp->v_op = spec_vnodeop_p;
@


1.52
log
@Add some locking around VOP_CLOSE() and friends. Lets VFSDEBUG
kernels once again mount cd9660 filesystems without crashing.

From an old reverted diff of thib@@, parts of which apparently did
not get re-committed.

ok oga@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.51 2009/10/31 12:00:08 fgsch Exp $	*/
a227 1
	int needclose = 0;
a261 1
	needclose = 1;
d447 4
a450 5
	if (needclose) {
		vn_lock(devvp, LK_EXCLUSIVE | LK_RETRY, p);
		VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
		VOP_UNLOCK(devvp, 0, p);
	}
@


1.51
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.50 2009/07/09 22:29:55 thib Exp $	*/
d254 4
a257 1
	if ((error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
d449 6
a454 3
	if (needclose)
		(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED,
		    p);
d590 1
d592 1
a592 1
	vrele(isomp->im_devvp);
@


1.50
log
@Remove the VREF() macro and replaces all instances with a call to verf(),
which is exactly what the macro does.

Macro's that are nothing more then:
#define FUNCTION(arg) function(arg)
are almost always pointless and should go away.

OK blambert@@
Agreed by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.48 2008/07/23 16:24:43 beck Exp $	*/
d181 1
a181 1
	if (p->p_ucred->cr_uid != 0) {
@


1.49
log
@The only value that d_npartitions should have is MAXPARTITIONS.
@
text
@d850 1
a850 1
	VREF(ip->i_devvp);
@


1.48
log
@
Correct cases of mishandling of pending reads and writes to prevent
them going negative - this consists of identifying a number of cases of
IO not going through the buffer cache and marking those buffers with
B_RAW - as well as fixing nfs_bio to show pending writes and reads through
the buffer cache via NFS

still has a problem with mishandling the counters I believe in the
async/sync fallback case where counters stay positive which will be
addressed seperately.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.47 2007/10/03 10:52:11 krw Exp $	*/
d525 1
a525 1
	lp->d_npartitions = RAW_PART + 1;
@


1.47
log
@MALLOC+bzero -> malloc+M_ZERO.

In ip_esp.c all allocated memory is now zero'd in the
"malloc(sizeof(*tc) + alen ..." case. The +alen memory was not
initialized by the bzero() call. Noticed by chl@@.

"Looks good" art@@ "seems ok" chl@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.46 2007/06/08 05:35:32 deraadt Exp $	*/
d479 1
a479 1
		bp->b_flags = B_BUSY | B_READ;
@


1.46
log
@all disklabels read from the kernel now always contain a total sector
size which is the REAL DISK SIZE.  always.  if a driver fails to set
this right, please fix it.  agreed with otto and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.45 2007/06/05 00:38:22 deraadt Exp $	*/
d768 1
a768 3
	MALLOC(ip, struct iso_node *, sizeof(struct iso_node), M_ISOFSNODE,
	    M_WAITOK);
	bzero((caddr_t)ip, sizeof(struct iso_node));
@


1.45
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.44 2007/03/25 10:20:50 pedro Exp $	*/
d528 1
@


1.44
log
@Account for the space of all the previous sessions on disk when
mounting a multisession CD, as they may be accessed as well.
From FreeBSD via Enache Adrian, okay krw@@ thib@@ tedu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.43 2007/03/21 13:44:04 pedro Exp $	*/
d516 2
a517 2
		lp->d_partitions[i].p_size = 0;
		lp->d_partitions[i].p_offset = 0;
d519 2
a520 2
	lp->d_partitions[0].p_offset = 0;
	lp->d_partitions[0].p_size = lp->d_secperunit;
d522 2
a523 2
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
@


1.43
log
@Add support for mounting arbitrary sessions, from Enache Adrian
OK deraadt@@ mjc@@ canacar@@ krw@@, with much input from Enache himself
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.42 2006/08/07 15:50:42 pedro Exp $	*/
d362 5
a366 1
	
@


1.42
log
@Revert last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.40 2006/06/28 15:07:00 pedro Exp $	*/
d239 1
a239 1
	int sess = 0;
d262 2
a263 1
	/* This is the "logical sector size".  The standard says this
d269 5
a273 2
	error = VOP_IOCTL(devvp, CDIOREADMSADDR, (caddr_t)&sess, 0, FSCRED, p);
	if (error)
d275 6
a280 1
	
@


1.41
log
@obey the locking disaplince wrt to VOP_CLOSE during umounts
and mount error paths.

ok sturm@@ pedro@@
@
text
@d254 1
a254 4
	vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
	error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0);
	VOP_UNLOCK(devvp, 0, p);
	if (error != 0);
d433 3
a435 5
	if (needclose) {
		vn_lock(devvp, LK_EXCLUSIVE|LK_RETRY, p);
		VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
		VOP_UNLOCK(devvp, 0, p);
	}
a569 2

	vn_lock(isomp->im_devvp, LK_EXCLUSIVE|LK_RETRY, p);
d571 1
a571 2
	vput(isomp->im_devvp);
	
@


1.40
log
@Only set devvp->v_specmountpoint on successful mounts, Nicholas Marriott
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.39 2006/04/19 11:55:55 pedro Exp $	*/
d254 4
a257 1
	if ((error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0)) != 0)
d436 5
a440 3
	if (needclose)
		(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED,
		    p);
d575 2
d578 2
a579 1
	vrele(isomp->im_devvp);
@


1.39
log
@Remove unused mount list simple_lock() goo
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.38 2006/01/22 00:40:02 miod Exp $	*/
d370 1
a370 3
	devvp->v_specmountpoint = mp;

	/* Check the Rock Ridge Extention support */
d425 2
@


1.38
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.37 2005/11/30 10:35:07 pedro Exp $	*/
d115 1
a115 1
	simple_lock(&mountlist_slock);
a116 1
	simple_unlock(&mountlist_slock);
d120 1
@


1.37
log
@No need for vfs_busy() and vfs_unbusy() to take a process pointer
anymore. Testing by jolan@@, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.36 2005/11/09 02:38:38 pedro Exp $	*/
a57 2
#define	b_cylin	b_resid

d467 1
a467 1
		bp->b_cylin = bp->b_blkno / lp->d_secpercyl;
@


1.36
log
@Add missing cast when reading in the file size, fixes PR 4480, okay krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.35 2003/08/14 07:46:39 mickey Exp $	*/
d113 1
a113 1
		vfs_unbusy(mp, p);
d121 1
a121 1
	vfs_unbusy(mp, p);
@


1.35
log
@constify vfsops; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.34 2003/06/02 23:28:05 millert Exp $	*/
d858 1
a858 1
	ip->i_size = isonum_733(isodir->size);
@


1.35.8.1
log
@MFC:
Fix by pedro@@

Add missing cast when reading in the file size, fixes PR 4480.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.35 2003/08/14 07:46:39 mickey Exp $	*/
d858 1
a858 1
	ip->i_size = (u_int32_t) isonum_733(isodir->size);
@


1.35.10.1
log
@MFC:
Fix by pedro@@

Add missing cast when reading in the file size, fixes PR 4480.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.35 2003/08/14 07:46:39 mickey Exp $	*/
d858 1
a858 1
	ip->i_size = (u_int32_t) isonum_733(isodir->size);
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.33 2003/04/06 21:43:23 krw Exp $	*/
d65 1
a65 1
struct vfsops cd9660_vfsops = {
@


1.33
log
@Missed file in previous strncpy fixup for d_packname, d_typename fields.

As in that commit, ok millert@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.32 2002/04/23 18:54:12 espie Exp $	*/
d21 1
a21 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@In mount.h, rename field export -> export_info, to avoid collision with C++.
Synch files that use that field.

(This argument is an internal interface specific to OpenBSD, so it won't
cause compatibility problems.)

(No bump, not an ABI change).

ok art, millert...
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.31 2002/03/14 03:16:09 millert Exp $	*/
d506 2
a507 2
	strncpy(lp->d_typename, pri->volume_id, 16);
	strncpy(lp->d_packname, pri->volume_id+16, 16);
@


1.31
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.30 2002/03/14 01:27:03 millert Exp $	*/
d163 2
a164 1
			return (vfs_export(mp, &imp->im_export, &args.export));
@


1.30
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.29 2002/03/10 03:34:35 fgsch Exp $	*/
d90 3
a92 3
    struct proc *p, struct iso_args *argp);
int	iso_disklabelspoof __P((dev_t dev, void (*strat)(struct buf *),
    struct disklabel *lp));
@


1.29
log
@call inittodr() to avoid reseting the clock; problem reported in tech@@.
millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.28 2002/01/25 04:50:20 fgsch Exp $	*/
d89 3
a91 3
static	int iso_mountfs __P((struct vnode *devvp, struct mount *mp,
    struct proc *p, struct iso_args *argp));
int	iso_disklabelspoof __P((dev_t dev, void (*strat) __P((struct buf *)),
d454 1
a454 1
	void (*strat) __P((struct buf *));
@


1.28
log
@multi-session support; from NetBSD. millert@@ ok

this only affects iso_mountfs(), not disklabel. code for it may be added
later.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.24 2001/11/15 08:27:28 art Exp $	*/
d126 1
@


1.27
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d56 2
d243 1
d271 4
d278 3
a280 2
		if ((error = bread(devvp, iso_blknum * btodb(iso_bsize),
				   iso_bsize, NOCRED, &bp)) != 0)
@


1.26
log
@Big cleanup inspired by NetBSD with some parts of the code from NetBSD.
 - get rid of VOP_BALLOCN and VOP_SIZE
 - move the generic getpages and putpages into miscfs/genfs
 - create a genfs_node which must be added to the top of the private portion
   of each vnode for filsystems that want to use genfs_{get,put}pages
 - rename genfs_mmap to vop_generic_mmap
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.25 2001/11/27 05:27:11 art Exp $	*/
a82 4
struct genfs_ops cd9660_genfsops = {
	genfs_size,
};

a361 2
	mp->mnt_dev_bshift = iso_bsize;
	mp->mnt_fs_bshift = isomp->im_bshift;
d940 1
a940 2

	genfs_node_init(vp, &cd9660_genfsops);
@


1.26.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.28 2002/01/25 04:50:20 fgsch Exp $	*/
a55 2
#include <sys/cdio.h>
#include <sys/conf.h>
a244 1
	int sess = 0;
a271 4

	error = VOP_IOCTL(devvp, CDIOREADMSADDR, (caddr_t)&sess, 0, FSCRED, p);
	if (error)
		sess = 0;
d275 2
a276 3
		if ((error = bread(devvp,
		    (iso_blknum + sess) * btodb(iso_bsize),
		    iso_bsize, NOCRED, &bp)) != 0)
@


1.26.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.26.2.1 2002/01/31 22:55:40 niklas Exp $	*/
d93 4
a96 4
static	int iso_mountfs(struct vnode *devvp, struct mount *mp,
	    struct proc *p, struct iso_args *argp);
int	iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	    struct disklabel *lp);
a129 1
	inittodr(0);
d166 1
a166 2
			return (vfs_export(mp, &imp->im_export, 
			    &args.export_info));
d459 1
a459 1
	void (*strat)(struct buf *);
@


1.26.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d512 2
a513 2
	strncpy(lp->d_typename, pri->volume_id, sizeof lp->d_typename);
	strncpy(lp->d_packname, pri->volume_id+16, sizeof lp->d_packname);
@


1.25
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.24 2001/11/15 08:27:28 art Exp $	*/
d83 4
d946 2
a947 1
	
@


1.24
log
@uvm_vnp_setsize
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.23 2001/11/03 23:27:43 miod Exp $	*/
d362 2
@


1.23
log
@The contents of cd9660_mount.h duplicate <sys/mount.h>, so get rid of it.
Agreed by fgs@@ and millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.22 2001/06/23 02:14:22 csapuntz Exp $	*/
d928 1
d930 1
@


1.22
log
@Get rid of several unused vnode operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.21 2001/02/20 01:50:09 assar Exp $	*/
a65 1
#include <isofs/cd9660/cd9660_mount.h>
@


1.21
log
@use void * consistently in vfs_mount and sys_mount.  ok @@art
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.20 2000/06/07 23:25:08 millert Exp $	*/
d845 1
a845 1
		if ((error = VOP_BLKATOFF(vp, (off_t)0, NULL, &bp)) != 0) {
d865 4
a868 4
		if ((imp->im_flags & ISOFSMNT_EXTATT)
		    && (off = isonum_711(isodir->ext_attr_length)))
			VOP_BLKATOFF(vp, (off_t)-(off << imp->im_bshift), NULL,
				     &bp2);
@


1.20
log
@Add cd9660_check_export() (from ufs_check_export() with trivial modifications).
Fixes the "NFS mounting of exported cd-rom causes panic" bug.  Apparently
when the checkexp vfs support was added cd9660 was left out.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.19 2000/02/07 04:57:15 assar Exp $	*/
d137 1
a137 1
	caddr_t data;
d147 1
a147 1
	error = copyin(data, (caddr_t)&args, sizeof (struct iso_args));
@


1.19
log
@update to use new checkexp vfs operation
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.18 1999/08/17 10:56:07 art Exp $	*/
d80 2
a81 1
	cd9660_sysctl
d966 26
@


1.19.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.21 2001/02/20 01:50:09 assar Exp $	*/
d80 1
a80 2
	cd9660_sysctl,
	cd9660_check_export
d136 1
a136 1
	void *data;
d146 1
a146 1
	error = copyin(data, &args, sizeof (struct iso_args));
a964 26
	return (0);
}

/*
 * Verify a remote client has export rights and return these rights via
 * exflagsp and credanonp.
 */
int
cd9660_check_export(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
{
	register struct netcred *np;
	register struct iso_mnt *imp = VFSTOISOFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &imp->im_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
@


1.19.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.19.2.1 2001/05/14 22:32:37 niklas Exp $	*/
d845 1
a845 1
		if ((error = cd9660_bufatoff(ip, (off_t)0, NULL, &bp)) != 0) {
d865 4
a868 4
		if ((imp->im_flags & ISOFSMNT_EXTATT) && 
		    (off = isonum_711(isodir->ext_attr_length)))
			cd9660_bufatoff(ip, (off_t)-(off << imp->im_bshift),
			    NULL, &bp2);
@


1.19.2.3
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 1
@


1.19.2.4
log
@Merge in -current
@
text
@a361 2
	mp->mnt_dev_bshift = iso_bsize;
	mp->mnt_fs_bshift = isomp->im_bshift;
a927 1
		break;
a928 1
		uvm_vnp_setsize(vp, ip->i_size);
@


1.19.2.5
log
@Merge in trunk
@
text
@a55 2
#include <sys/cdio.h>
#include <sys/conf.h>
a240 1
	int sess = 0;
a267 4

	error = VOP_IOCTL(devvp, CDIOREADMSADDR, (caddr_t)&sess, 0, FSCRED, p);
	if (error)
		sess = 0;
d271 2
a272 3
		if ((error = bread(devvp,
		    (iso_blknum + sess) * btodb(iso_bsize),
		    iso_bsize, NOCRED, &bp)) != 0)
d362 2
@


1.19.2.6
log
@Merge in -current from roughly a week ago
@
text
@d89 4
a92 4
static	int iso_mountfs(struct vnode *devvp, struct mount *mp,
	    struct proc *p, struct iso_args *argp);
int	iso_disklabelspoof(dev_t dev, void (*strat)(struct buf *),
	    struct disklabel *lp);
a125 1
	inittodr(0);
d453 1
a453 1
	void (*strat)(struct buf *);
@


1.19.2.7
log
@Sync the SMP branch with 3.3
@
text
@d163 1
a163 2
			return (vfs_export(mp, &imp->im_export, 
			    &args.export_info));
@


1.19.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.19.2.7 2003/03/28 00:00:19 niklas Exp $	*/
d506 2
a507 2
	strncpy(lp->d_typename, pri->volume_id, sizeof lp->d_typename);
	strncpy(lp->d_packname, pri->volume_id+16, sizeof lp->d_packname);
@


1.19.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.19.2.8 2003/05/13 19:21:27 ho Exp $	*/
d21 5
a25 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.19.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
const struct vfsops cd9660_vfsops = {
@


1.19.4.1
log
@Pull in patch from current:
Errata:
NFS exporting of CD filesystems caused a system panic.
Fix (millert):
Add cd9660_check_export() (from ufs_check_export() with trivial modifications).
Fixes the "NFS mounting of exported cd-rom causes panic" bug.  Apparently
when the checkexp vfs support was added cd9660 was left out.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.19 2000/02/07 04:57:15 assar Exp $	*/
d80 1
a80 2
	cd9660_sysctl,
	cd9660_check_export
a964 26
	return (0);
}

/*
 * Verify a remote client has export rights and return these rights via
 * exflagsp and credanonp.
 */
int
cd9660_check_export(mp, nam, exflagsp, credanonp)
	register struct mount *mp;
	struct mbuf *nam;
	int *exflagsp;
	struct ucred **credanonp;
{
	register struct netcred *np;
	register struct iso_mnt *imp = VFSTOISOFS(mp);

	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &imp->im_export, nam);
	if (np == NULL)
		return (EACCES);

	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
@


1.18
log
@initialize an incorrectly uninitialized variable
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.17 1999/07/01 02:20:22 d Exp $	*/
d673 1
a673 1
cd9660_fhtovp(mp, fhp, nam, vpp, exflagsp, credanonp)
a675 1
	struct mbuf *nam;
a676 2
	int *exflagsp;
	struct ucred **credanonp;
a679 2
	register struct netcred *np;
	register struct iso_mnt *imp = VFSTOISOFS(mp);
a687 7
	/*
	 * Get the export permission structure for this <mp, client> tuple.
	 */
	np = vfs_export_lookup(mp, &imp->im_export, nam);
	if (np == NULL)
		return (EACCES);

a698 2
	*exflagsp = np->netc_exflags;
	*credanonp = &np->netc_anon;
@


1.17
log
@Add support for Joliet extensions. From FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.16 1999/05/31 17:34:46 millert Exp $	*/
d237 1
a237 1
	struct iso_primary_descriptor *pri;
@


1.16
log
@New struct statfs with mount options.  NOTE: this replaces statfs(2),
fstatfs(2), and getfsstat(2) so you will need to build a new kernel
before doing a "make build" or you will get "unimplemented syscall" errors.

The new struct statfs has the following featuires:
o Has a u_int32_t flags field--now softdep can have a real flag.

o Uses u_int32_t instead of longs (nicer on the alpha).  Note: the man
page used to lie about setting invalid/unused fields to -1.  SunOS does
that but our code never has.

o Gets rid of f_type completely.  It hasn't been used since NetBSD 0.9
and having it there but always 0 is confusing.  It is conceivable
that this may cause some old code to not compile but that is better
than silently breaking.

o Adds a mount_info union that contains the FSTYPE_args struct.  This
means that "mount" can now tell you all the options a filesystem was
mounted with.  This is especially nice for NFS.

Other changes:
o The linux statfs emulation didn't convert between BSD fs names
  and linux f_type numbers.  Now it does, since the BSD f_type
  number is useless to linux apps (and has been removed anyway)

o FreeBSD's struct statfs is different from our (both old and new)
and thus needs conversion.  Previously, the OpenBSD syscalls
were used without any real translation.

o mount(8) will now show extra info when invoked with no arguments.
However, to see *everything* you need to use the -v (verbose) flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.15 1998/09/06 20:31:31 millert Exp $	*/
d66 1
d227 1
d235 1
d238 1
d269 1
d281 37
a317 3
		if (isonum_711 (vdp->type) == ISO_VD_END) {
			error = EINVAL;
			goto out;
d319 3
a321 3
		
		if (isonum_711 (vdp->type) == ISO_VD_PRIMARY)
			break;
d323 1
d325 2
a326 2
	
	if (isonum_711 (vdp->type) != ISO_VD_PRIMARY) {
d330 1
a330 3
	
	pri = (struct iso_primary_descriptor *)vdp;
	
d348 1
d351 5
a355 7
	isomp->im_bshift = 0;
	while ((1 << isomp->im_bshift) < isomp->logical_block_size)
		isomp->im_bshift++;
	
	bp->b_flags |= B_AGE;
	brelse(bp);
	bp = NULL;
d393 1
a393 1
	    ISOFSMNT_EXTATT);
d405 18
a422 1
	
d427 2
@


1.15
log
@If mount by non-root, then verify that user has necessary permissions on
the device.  NetBSD (mycroft) made a similar change yesterday but there
are vfs differences.  Thanks to Hubert Feyrer for bringing this to our
attention.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.14 1998/08/21 23:31:35 csapuntz Exp $	*/
d209 1
a567 5
#ifdef COMPAT_09
	sbp->f_type = 5;
#else
	sbp->f_type = 0;
#endif
d579 2
@


1.14
log
@

Fix malloc race in the cd9660 fs.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.13 1998/02/08 22:41:32 tholo Exp $	*/
d177 13
@


1.13
log
@Updates to match type changes in syscall tables
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.12 1997/11/08 17:21:08 niklas Exp $	*/
d686 1
d712 10
a721 1
	cd9660_ihashins(ip);
a867 1
			cd9660_ihashins(ip);
@


1.12
log
@Sync to NetBSD; some extra KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.11 1997/11/06 05:58:11 csapuntz Exp $	*/
d134 1
a134 1
	char *path;
@


1.11
log
@Updates for VFS Lite 2 + soft update.
@
text
@d1 2
a2 2
/*	$OpenBSD: cd9660_vfsops.c,v 1.10 1997/10/06 20:19:45 deraadt Exp $	*/
/*	$NetBSD: cd9660_vfsops.c,v 1.20 1996/02/09 21:32:08 christos Exp $	*/
d63 1
d86 4
a89 4
static int iso_mountfs __P((struct vnode *devvp, struct mount *mp,
		struct proc *p, struct iso_args *argp));
int iso_disklabelspoof __P((dev_t dev, void (*strat) __P((struct buf *)),
		struct disklabel *lp));
a108 1

d172 1
a172 1
		return ENOTBLK;
d176 1
a176 1
		return ENXIO;
d188 1
a188 1
		return error;
d191 1
a191 1
	(void) copyinstr(path, mp->mnt_stat.f_mntonname, MNAMELEN - 1, &size);
d193 1
a193 1
	(void) copyinstr(args.fspec, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
d196 2
a197 2
	(void) cd9660_statfs(mp, &mp->mnt_stat, p);
	return 0;
d225 1
a225 1
		return EROFS;
d234 1
a234 1
		return error;
d236 1
a236 1
		return EBUSY;
d242 1
a242 1
		return error;
d314 1
a314 1
	
d316 1
a316 1
	
d319 5
a323 6
		if ((error = bread(isomp->im_devvp,
				   (isomp->root_extent + isonum_711(rootp->ext_attr_length)) <<
				   (isomp->im_bshift - DEV_BSHIFT),
				   isomp->logical_block_size, NOCRED,
				   &bp)) != 0)
		    goto out;
d341 3
a343 2
	isomp->im_flags = argp->flags&(ISOFSMNT_NORRIP|ISOFSMNT_GENS|ISOFSMNT_EXTATT);
	switch (isomp->im_flags&(ISOFSMNT_NORRIP|ISOFSMNT_GENS)) {
d355 1
a355 1
	return 0;
d360 2
a361 1
		(void)VOP_CLOSE(devvp, ronly ? FREAD : FREAD|FWRITE, NOCRED, p);
d366 1
a366 1
	return error;
d463 1
a463 1
	return 0;
d483 1
a483 1
		return EBUSY;
d522 1
a522 1
				     imp->iso_ftype == ISO_FTYPE_RRIP, dp));
d568 2
a569 1
		bcopy(mp->mnt_stat.f_mntfromname, sbp->f_mntfromname, MNAMELEN);
d573 1
a573 1
	return 0;
d622 2
a623 2
	printf("fhtovp: ino %d, start %ld\n",
	       ifhp->ifid_ino, ifhp->ifid_start);
d664 1
a664 1
				     VFSTOISOFS(mp)->iso_ftype == ISO_FTYPE_RRIP,
d666 1
a666 1
				     0,
d668 1
a668 1
				     NULL));
d724 2
a725 1
		if (off + ISO_DIRECTORY_RECORD_SIZE > imp->logical_block_size) {
d728 1
a728 1
			       off + ISO_DIRECTORY_RECORD_SIZE);
d749 2
a750 2
			       off +isonum_711(isodir->length), off,
			       isonum_711(isodir->length));
d760 3
a762 2
			       isonum_733(isodir->extent) + isonum_711(isodir->ext_attr_length),
			       ifhp->ifid_start);
d901 1
a901 1
	       ifhp->ifid_ino,ifhp->ifid_start);
d903 1
a903 1
	return 0;
@


1.10
log
@back out vfs lite2 till after 2.2
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.8 1997/06/04 23:55:30 deraadt Exp $	*/
a66 1
	MOUNT_CD9660,
d78 1
a82 2
 *
 * Name is updated by mount(8) after booting.
a83 1
#define ROOTNAME	"root_device"
d93 1
a93 1
	register struct mount *mp;
a95 2
	struct iso_mnt *imp;
	size_t size;
d102 6
a107 2
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("cd9660_mountroot: can't setup bdevvp's");
d109 2
a110 5
	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &cd9660_vfsops;
	mp->mnt_flag = MNT_RDONLY;
	LIST_INIT(&mp->mnt_vnodelist);
d113 11
a123 21
		free(mp, M_MOUNT);
		return (error);
	}
	if ((error = vfs_lock(mp)) != 0) {
		(void)cd9660_unmount(mp, 0, p);
		free(mp, M_MOUNT);
		return (error);
	}
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	mp->mnt_vnodecovered = NULLVP;
	imp = VFSTOISOFS(mp);
	(void) copystr("/", mp->mnt_stat.f_mntonname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	(void)cd9660_statfs(mp, &mp->mnt_stat, p);
	vfs_unlock(mp);
	inittodr(0); /* XXX - can we get the cd creation time here?? */
	return (0);
d196 1
d308 1
a308 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_CD9660);
d315 1
a315 1
	devvp->v_specflags |= SI_MOUNTEDON;
d494 1
a494 1
	isomp->im_devvp->v_specflags &= ~SI_MOUNTEDON;
a568 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d697 1
d842 1
a843 2
			cd9660_ihashrem(ip);
			VOP_UNLOCK(vp);
d888 1
a888 1
	
@


1.9
log
@VFS Lite2 Changes
@
text
@d67 1
a78 1
	cd9660_sysctl
d83 2
d86 1
d96 1
a96 1
	struct mount *mp;
d99 2
d107 2
a108 6
	if ((error = bdevvp(swapdev, &swapdev_vp)) ||
	    (error = bdevvp(rootdev, &rootvp))) {
		printf("cd9660_mountroot: can't setup bdevvp's");
                return (error);
        }

d110 5
a114 2
	if ((error = vfs_rootmountalloc("cd9660", "root_device", &mp)) != 0)
		return (error);
d117 21
a137 11
		mp->mnt_vfc->vfc_refcount--;
		vfs_unbusy(mp, p);
                free(mp, M_MOUNT);
                return (error);
        }
	simple_lock(&mountlist_slock);
        CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	simple_unlock(&mountlist_slock);
        (void)cd9660_statfs(mp, &mp->mnt_stat, p);
	vfs_unbusy(mp, p);
        return (0);
a209 1
	(void) cd9660_statfs(mp, &mp->mnt_stat, p);
d321 1
a321 1
	mp->mnt_stat.f_fsid.val[1] = mp->mnt_vfc->vfc_typenum;
d328 1
a328 1
	devvp->v_specmountpoint = mp;
d507 1
a507 1
	isomp->im_devvp->v_specmountpoint = NULL;
d582 1
a710 1
	lockinit(&ip->i_lock, PINOD, "isoinode", 0, 0);
a854 1
			 * Note that the lock is carried over in the iso_node
d856 2
d902 1
a902 1

@


1.8
log
@undo more pre-spoofing data structure damage by readdisklabel
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.7 1997/05/28 21:30:38 deraadt Exp $	*/
a66 1
	MOUNT_CD9660,
d78 1
a82 2
 *
 * Name is updated by mount(8) after booting.
a83 1
#define ROOTNAME	"root_device"
d93 1
a93 1
	register struct mount *mp;
a95 2
	struct iso_mnt *imp;
	size_t size;
d102 6
a107 2
	if (bdevvp(swapdev, &swapdev_vp) || bdevvp(rootdev, &rootvp))
		panic("cd9660_mountroot: can't setup bdevvp's");
d109 2
a110 5
	mp = malloc((u_long)sizeof(struct mount), M_MOUNT, M_WAITOK);
	bzero((char *)mp, (u_long)sizeof(struct mount));
	mp->mnt_op = &cd9660_vfsops;
	mp->mnt_flag = MNT_RDONLY;
	LIST_INIT(&mp->mnt_vnodelist);
d113 11
a123 21
		free(mp, M_MOUNT);
		return (error);
	}
	if ((error = vfs_lock(mp)) != 0) {
		(void)cd9660_unmount(mp, 0, p);
		free(mp, M_MOUNT);
		return (error);
	}
	CIRCLEQ_INSERT_TAIL(&mountlist, mp, mnt_list);
	mp->mnt_vnodecovered = NULLVP;
	imp = VFSTOISOFS(mp);
	(void) copystr("/", mp->mnt_stat.f_mntonname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntonname + size, MNAMELEN - size);
	(void) copystr(ROOTNAME, mp->mnt_stat.f_mntfromname, MNAMELEN - 1,
	    &size);
	bzero(mp->mnt_stat.f_mntfromname + size, MNAMELEN - size);
	(void)cd9660_statfs(mp, &mp->mnt_stat, p);
	vfs_unlock(mp);
	inittodr(0); /* XXX - can we get the cd creation time here?? */
	return (0);
d196 1
d308 1
a308 1
	mp->mnt_stat.f_fsid.val[1] = makefstype(MOUNT_CD9660);
d315 1
a315 1
	devvp->v_specflags |= SI_MOUNTEDON;
d494 1
a494 1
	isomp->im_devvp->v_specflags &= ~SI_MOUNTEDON;
a568 1
	strncpy(sbp->f_fstypename, mp->mnt_op->vfs_name, MFSNAMELEN);
d697 1
d842 1
a843 2
			cd9660_ihashrem(ip);
			VOP_UNLOCK(vp);
d888 1
a888 1
	
@


1.7
log
@inval other parts, in case
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.6 1997/01/21 21:34:18 rahnds Exp $	*/
d440 1
a440 1
	for (i = 0; i < MAXPARTITIONS; i++)
d442 2
@


1.6
log
@If mounting a CD filesystem as a root image, at least call inittodr.
Most filesystems have a last modified date that is supplied,
however since that is not available on iso9660 could image creation
time be used instead? Currently it supplies 0, the beginning of time
as the parameter to inittodr.
This is so that when installing from a CD image, the file or directory
timestamps will be sane, not beginning of time.
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.5 1996/12/25 10:21:40 deraadt Exp $	*/
d396 1
d440 2
@


1.5
log
@smaller code
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.4 1996/12/05 13:40:28 deraadt Exp $	*/
d136 1
@


1.4
log
@pack cd9660 volume id into disklabel struct; very pretty result
@
text
@d1 1
a1 1
/*	$OpenBSD: cd9660_vfsops.c,v 1.3 1996/12/05 13:08:11 deraadt Exp $	*/
d393 1
d451 1
a451 4
	bp->b_flags |= B_INVAL;
	brelse(bp);
	return (0);

d455 1
a455 1
	return (EINVAL);
@


1.3
log
@provide iso_disklabelspoof()
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d435 2
@


1.2
log
@From NetBSD: merge with 960217
@
text
@d60 2
d90 2
d378 78
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD: cd9660_vfsops.c,v 1.19 1995/06/18 14:47:01 cgd Exp $	*/
a63 2
extern int enodev ();

a95 1
	register struct fs *fs;
d112 1
a112 1
	if (error = iso_mountfs(rootvp, mp, p, &args)) {
d116 1
a116 1
	if (error = vfs_lock(mp)) {
d152 1
a152 1
	struct iso_mnt *imp;
d154 2
a155 1
	if (error = copyin(data, (caddr_t)&args, sizeof (struct iso_args)))
d175 1
a175 1
	if (error = namei(ndp))
d221 1
a221 1
	int error = EINVAL, i, size;
d241 1
a241 1
	if (error = vfs_mountedon(devvp))
d245 1
a245 1
	if (error = vinvalbuf(devvp, V_SAVE, p->p_ucred, p, 0, 0))
d248 2
a249 1
	if (error = VOP_OPEN(devvp, ronly ? FREAD : FREAD|FWRITE, FSCRED, p))
d260 2
a261 2
		if (error = bread(devvp, iso_blknum * btodb(iso_bsize),
				  iso_bsize, NOCRED, &bp))
d327 5
a331 4
		if (error = bread(isomp->im_devvp,
				  (isomp->root_extent + isonum_711(rootp->ext_attr_length)) <<
				  (isomp->im_bshift - DEV_BSHIFT),
				  isomp->logical_block_size, NOCRED, &bp))
d409 1
a409 1
	if (error = vflush(mp, NULLVP, flags))
d446 1
a446 1
	    imp->iso_ftype == ISO_FTYPE_RRIP, dp));
d557 1
a557 1
	if (error = VFS_VGET(mp, ifhp->ifid_ino, &nvp)) {
d588 1
a588 1
	    VFSTOISOFS(mp)->iso_ftype == ISO_FTYPE_RRIP,
d590 1
a590 1
	    0,
d592 1
a592 1
	    (struct iso_directory_entry *)0));
d616 1
a616 1
	if (error = getnewvnode(VT_ISOFS, mp, cd9660_vnodeop_p, &vp)) {
d702 1
a702 1
		if (error = VOP_BLKATOFF(vp, (off_t)0, NULL, &bp)) {
d764 1
a764 1
		if (nvp = checkalias(vp, ip->inode.iso_rdev, mp)) {
d782 7
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
