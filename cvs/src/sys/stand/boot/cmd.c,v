head	1.63;
access;
symbols
	OPENBSD_6_2_BASE:1.63
	OPENBSD_6_1:1.63.0.14
	OPENBSD_6_1_BASE:1.63
	OPENBSD_6_0:1.63.0.10
	OPENBSD_6_0_BASE:1.63
	OPENBSD_5_9:1.63.0.6
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.8
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.63.0.2
	OPENBSD_5_7_BASE:1.63
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.61.0.4
	OPENBSD_5_5_BASE:1.61
	OPENBSD_5_4:1.60.0.20
	OPENBSD_5_4_BASE:1.60
	OPENBSD_5_3:1.60.0.18
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.60.0.16
	OPENBSD_5_2_BASE:1.60
	OPENBSD_5_1_BASE:1.60
	OPENBSD_5_1:1.60.0.14
	OPENBSD_5_0:1.60.0.12
	OPENBSD_5_0_BASE:1.60
	OPENBSD_4_9:1.60.0.10
	OPENBSD_4_9_BASE:1.60
	OPENBSD_4_8:1.60.0.8
	OPENBSD_4_8_BASE:1.60
	OPENBSD_4_7:1.60.0.4
	OPENBSD_4_7_BASE:1.60
	OPENBSD_4_6:1.60.0.6
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.59.0.6
	OPENBSD_4_4_BASE:1.59
	OPENBSD_4_3:1.59.0.4
	OPENBSD_4_3_BASE:1.59
	OPENBSD_4_2:1.59.0.2
	OPENBSD_4_2_BASE:1.59
	OPENBSD_4_1:1.58.0.2
	OPENBSD_4_1_BASE:1.58
	OPENBSD_4_0:1.57.0.10
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.57.0.8
	OPENBSD_3_9_BASE:1.57
	OPENBSD_3_8:1.57.0.6
	OPENBSD_3_8_BASE:1.57
	OPENBSD_3_7:1.57.0.4
	OPENBSD_3_7_BASE:1.57
	OPENBSD_3_6:1.57.0.2
	OPENBSD_3_6_BASE:1.57
	SMP_SYNC_A:1.52
	SMP_SYNC_B:1.52
	OPENBSD_3_5:1.52.0.2
	OPENBSD_3_5_BASE:1.52
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.48
	OPENBSD_3_3:1.48.0.4
	OPENBSD_3_3_BASE:1.48
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.47.0.2
	OPENBSD_3_1_BASE:1.47
	UBC_SYNC_B:1.48
	UBC:1.46.0.12
	UBC_BASE:1.46
	OPENBSD_3_0:1.46.0.10
	OPENBSD_3_0_BASE:1.46
	OPENBSD_2_9_BASE:1.46
	OPENBSD_2_9:1.46.0.8
	OPENBSD_2_8:1.46.0.6
	OPENBSD_2_8_BASE:1.46
	OPENBSD_2_7:1.46.0.4
	OPENBSD_2_7_BASE:1.46
	SMP:1.46.0.2
	SMP_BASE:1.46
	kame_19991208:1.44
	OPENBSD_2_6:1.44.0.2
	OPENBSD_2_6_BASE:1.44
	OPENBSD_2_5:1.43.0.2
	OPENBSD_2_5_BASE:1.43
	OPENBSD_2_4:1.42.0.2
	OPENBSD_2_4_BASE:1.42
	OPENBSD_2_3:1.37.0.2
	OPENBSD_2_3_BASE:1.37
	OPENBSD_2_2:1.34.0.2
	OPENBSD_2_2_BASE:1.34;
locks; strict;
comment	@ * @;


1.63
date	2014.07.20.19.33.54;	author tobias;	state Exp;
branches;
next	1.62;
commitid	3nI5A0z6WuBa0dGs;

1.62
date	2014.06.27.20.35.37;	author tobias;	state Exp;
branches;
next	1.61;
commitid	2iiWRmSUbBOgeOHO;

1.61
date	2013.12.23.23.32.40;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.16.23.58.05;	author sthen;	state Exp;
branches;
next	1.59;

1.59
date	2007.04.27.10.08.34;	author tom;	state Exp;
branches;
next	1.58;

1.58
date	2007.02.21.13.17.12;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.26.17.50.47;	author tom;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.25.01.32.54;	author tom;	state Exp;
branches;
next	1.55;

1.55
date	2004.06.24.22.32.26;	author tom;	state Exp;
branches;
next	1.54;

1.54
date	2004.06.24.22.10.18;	author tom;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.24.16.38.59;	author tom;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.51;

1.51
date	2003.08.11.06.23.07;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.02.20.20.54;	author mickey;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.01.17.00.27;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.14.09.19.17;	author mdw;	state Exp;
branches;
next	1.47;

1.47
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2000.01.20.19.56.48;	author mickey;	state Exp;
branches
	1.46.2.1
	1.46.12.1;
next	1.45;

1.45
date	2000.01.12.19.50.25;	author mickey;	state Exp;
branches;
next	1.44;

1.44
date	99.04.20.02.20.12;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	98.10.29.17.07.24;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	98.07.13.16.19.26;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	98.06.23.05.14.49;	author mickey;	state Exp;
branches;
next	1.40;

1.40
date	98.05.31.23.41.47;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	98.05.30.01.48.31;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	98.05.25.19.17.40;	author mickey;	state Exp;
branches;
next	1.37;

1.37
date	98.04.18.07.40.03;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	98.02.24.22.16.03;	author weingart;	state Exp;
branches;
next	1.35;

1.35
date	97.11.04.20.15.31;	author weingart;	state Exp;
branches;
next	1.34;

1.34
date	97.10.07.07.59.57;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	97.09.20.22.40.37;	author flipk;	state Exp;
branches;
next	1.32;

1.32
date	97.09.17.19.55.34;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	97.09.02.21.02.15;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	97.09.02.20.48.17;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.08.22.00.41.27;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.08.21.22.17.56;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	97.08.21.22.15.17;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	97.08.21.22.04.32;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	97.08.21.21.40.24;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	97.08.21.19.07.29;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.13.14.24.00;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.08.13.03.49.28;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	97.08.12.22.10.43;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.08.12.21.51.35;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	97.08.06.18.45.02;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	97.07.01.20.02.22;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	97.06.06.18.23.43;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	97.06.06.16.26.56;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	97.05.31.15.48.25;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.05.31.01.35.58;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.04.28.07.39.00;	author weingart;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	97.04.26.17.50.07;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.04.21.20.20.25;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.04.21.20.03.30;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.04.17.21.47.37;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.04.16.22.14.15;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.04.15.08.32.51;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	97.04.11.19.12.56;	author weingart;	state Exp;
branches;
next	1.5;

1.5
date	97.04.08.22.48.29;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.07.01.26.00;	author weingart;	state Exp;
branches;
next	1.3;

1.3
date	97.04.01.04.50.33;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.23.06.21;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	97.03.31.03.12.03;	author weingart;	state Exp;
branches;
next	;

1.13.2.1
date	97.06.01.09.53.05;	author deraadt;	state Exp;
branches;
next	;

1.46.2.1
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	;

1.46.12.1
date	2002.06.11.03.32.24;	author art;	state Exp;
branches;
next	1.46.12.2;

1.46.12.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	;


desc
@@


1.63
log
@Merge cmd.c from zboot into boot, dropping "clear" command while at it.

With input from deraadt@@

okay jasper@@, uebayashi@@
@
text
@/*	$OpenBSD: cmd.c,v 1.62 2014/06/27 20:35:37 tobias Exp $	*/

/*
 * Copyright (c) 1997-1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/reboot.h>

#include <libsa.h>
#include <lib/libkern/funcs.h>

#include "cmd.h"

#define CTRL(c)	((c)&0x1f)

static int Xboot(void);
static int Xecho(void);
static int Xhelp(void);
static int Xls(void);
static int Xnop(void);
static int Xreboot(void);
static int Xstty(void);
static int Xtime(void);
#ifdef MACHINE_CMD
static int Xmachine(void);
extern const struct cmd_table MACHINE_CMD[];
#endif
extern int Xset(void);
extern int Xenv(void);

#ifdef CHECK_SKIP_CONF
extern int CHECK_SKIP_CONF(void);
#endif

extern const struct cmd_table cmd_set[];
const struct cmd_table cmd_table[] = {
	{"#",      CMDT_CMD, Xnop},  /* XXX must be first */
	{"boot",   CMDT_CMD, Xboot},
	{"echo",   CMDT_CMD, Xecho},
	{"env",    CMDT_CMD, Xenv},
	{"help",   CMDT_CMD, Xhelp},
	{"ls",     CMDT_CMD, Xls},
#ifdef MACHINE_CMD
	{"machine",CMDT_MDC, Xmachine},
#endif
	{"reboot", CMDT_CMD, Xreboot},
	{"set",    CMDT_SET, Xset},
	{"stty",   CMDT_CMD, Xstty},
	{"time",   CMDT_CMD, Xtime},
	{NULL, 0},
};

static void ls(char *, struct stat *);
static int readline(char *, size_t, int);
char *nextword(char *);
static char *whatcmd(const struct cmd_table **ct, char *);
static char *qualify(char *);

char cmd_buf[CMD_BUFF_SIZE];

int
getcmd(void)
{
	cmd.cmd = NULL;

	if (!readline(cmd_buf, sizeof(cmd_buf), cmd.timeout))
		cmd.cmd = cmd_table;

	return docmd();
}

int
read_conf(void)
{
#ifndef INSECURE
	struct stat sb;
#endif
	int fd, rc = 0;

#ifdef CHECK_SKIP_CONF
	if (CHECK_SKIP_CONF()) {
		printf("boot.conf processing skipped at operator request\n");
		cmd.timeout = 0;
		return -1;		/* Pretend file wasn't found */
	}
#endif

	if ((fd = open(qualify(cmd.conf), 0)) < 0) {
		if (errno != ENOENT && errno != ENXIO) {
			printf("open(%s): %s\n", cmd.path, strerror(errno));
			return 0;
		}
		return -1;
	}

#ifndef INSECURE
	(void) fstat(fd, &sb);
	if (sb.st_uid || (sb.st_mode & 2)) {
		printf("non-secure %s, will not proceed\n", cmd.path);
		close(fd);
		return -1;
	}
#endif

	do {
		char *p = cmd_buf;

		cmd.cmd = NULL;
		do {
			rc = read(fd, p, 1);
		} while (rc > 0 && *p++ != '\n' &&
		    (p-cmd_buf) < sizeof(cmd_buf));

		if (rc < 0) {			/* Error from read() */
			printf("%s: %s\n", cmd.path, strerror(errno));
			break;
		}

		if (rc == 0) {			/* eof from read() */
			if (p != cmd_buf) {	/* Line w/o trailing \n */
				*p = '\0';
				rc = docmd();
				break;
			}
		} else {			/* rc > 0, read a char */
			p--;			/* Get back to last character */

			if (*p != '\n') {	/* Line was too long */
				printf("%s: line too long\n", cmd.path);

				/* Don't want to run the truncated command */
				rc = -1;
			}
			*p = '\0';
		}
	} while (rc > 0 && !(rc = docmd()));

	close(fd);
	return rc;
}

int
docmd(void)
{
	char *p = NULL;
	const struct cmd_table *ct = cmd_table, *cs;

	cmd.argc = 1;
	if (cmd.cmd == NULL) {

		/* command */
		for (p = cmd_buf; *p == ' ' || *p == '\t'; p++)
			;
		if (*p == '#' || *p == '\0') { /* comment or empty string */
#ifdef DEBUG
			printf("rem\n");
#endif
			return 0;
		}
		ct = cmd_table;
		cs = NULL;
		cmd.argv[cmd.argc] = p; /* in case it's shortcut boot */
		p = whatcmd(&ct, p);
		if (ct == NULL) {
			cmd.argc++;
			ct = cmd_table;
		} else if (ct->cmd_type == CMDT_SET && p != NULL) {
			cs = cmd_set;
#ifdef MACHINE_CMD
		} else if (ct->cmd_type == CMDT_MDC && p != NULL) {
			cs = MACHINE_CMD;
#endif
		}

		if (cs != NULL) {
			p = whatcmd(&cs, p);
			if (cs == NULL) {
				printf("%s: syntax error\n", ct->cmd_name);
				return 0;
			}
			ct = cs;
		}
		cmd.cmd = ct;
	}

	cmd.argv[0] = ct->cmd_name;
	while (p && cmd.argc+1 < sizeof(cmd.argv) / sizeof(cmd.argv[0])) {
		cmd.argv[cmd.argc++] = p;
		p = nextword(p);
	}
	cmd.argv[cmd.argc] = NULL;

	return (*cmd.cmd->cmd_exec)();
}

static char *
whatcmd(const struct cmd_table **ct, char *p)
{
	char *q;
	int l;

	q = nextword(p);

	for (l = 0; p[l]; l++)
		;

	while ((*ct)->cmd_name != NULL && strncmp(p, (*ct)->cmd_name, l))
		(*ct)++;

	if ((*ct)->cmd_name == NULL)
		*ct = NULL;

	return q;
}

static int
readline(char *buf, size_t n, int to)
{
#ifdef DEBUG
	extern int debug;
#endif
	char *p = buf, ch;

	/* Only do timeout if greater than 0 */
	if (to > 0) {
		u_long i = 0;
		time_t tt = getsecs() + to;
#ifdef DEBUG
		if (debug > 2)
			printf ("readline: timeout(%d) at %u\n", to, tt);
#endif
		/* check for timeout expiration less often
		   (for some very constrained archs) */
		while (!cnischar())
			if (!(i++ % 1000) && (getsecs() >= tt))
				break;

		if (!cnischar()) {
			strlcpy(buf, "boot", 5);
			putchar('\n');
			return strlen(buf);
		}
	} else
		while (!cnischar())
			;

	/* User has typed something.  Turn off timeouts. */
	cmd.timeout = 0;

	while (1) {
		switch ((ch = getchar())) {
		case CTRL('u'):
			while (p > buf) {
				putchar('\177');
				p--;
			}
			continue;
		case '\n':
		case '\r':
			*p = '\0';
			break;
		case '\b':
		case '\177':
			if (p > buf) {
				putchar('\177');
				p--;
			}
			continue;
		default:
			if (ch >= ' ' && ch < '\177') {
				if (p - buf < n-1)
					*p++ = ch;
				else {
					putchar('\007');
					putchar('\177');
				}
			}
			continue;
		}
		break;
	}

	return p - buf;
}

/*
 * Search for spaces/tabs after the current word. If found, \0 the
 * first one.  Then pass a pointer to the first character of the
 * next word, or NULL if there is no next word.
 */
char *
nextword(char *p)
{
	/* skip blanks */
	while (*p && *p != '\t' && *p != ' ')
		p++;
	if (*p) {
		*p++ = '\0';
		while (*p == '\t' || *p == ' ')
			p++;
	}
	if (*p == '\0')
		p = NULL;
	return p;
}

static void
print_help(const struct cmd_table *ct)
{
	for (; ct->cmd_name != NULL; ct++)
		printf(" %s", ct->cmd_name);
	putchar('\n');
}

static int
Xhelp(void)
{
	printf("commands:");
	print_help(cmd_table);
#ifdef MACHINE_CMD
	return Xmachine();
#else
	return 0;
#endif
}

#ifdef MACHINE_CMD
static int
Xmachine(void)
{
	printf("machine:");
	print_help(MACHINE_CMD);
	return 0;
}
#endif

static int
Xecho(void)
{
	int i;

	for (i = 1; i < cmd.argc; i++)
		printf("%s ", cmd.argv[i]);
	putchar('\n');
	return 0;
}

static int
Xstty(void)
{
	int sp;
	char *cp;
	dev_t dev;

	if (cmd.argc == 1) {
		printf("%s speed is %d\n", ttyname(0), cnspeed(0, -1));
		return 0;
	}
	dev = ttydev(cmd.argv[1]);
	if (dev == NODEV) {
		printf("%s not a console device\n", cmd.argv[1]);
		return 0;
	}

	if (cmd.argc == 2)
		printf("%s speed is %d\n", cmd.argv[1],
		    cnspeed(dev, -1));
	else {
		sp = 0;
		for (cp = cmd.argv[2]; isdigit(*cp); cp++)
			sp = sp * 10 + (*cp - '0');
		cnspeed(dev, sp);
	}
	return 0;
}

static int
Xtime(void)
{
	time_t tt = getsecs();

	if (cmd.argc == 1)
		printf(ctime(&tt));

	return 0;
}

static int
Xls(void)
{
	struct stat sb;
	char *p;
	int fd;

	if (stat(qualify((cmd.argv[1]? cmd.argv[1]: "/.")), &sb) < 0) {
		printf("stat(%s): %s\n", cmd.path, strerror(errno));
		return 0;
	}

	if ((sb.st_mode & S_IFMT) != S_IFDIR)
		ls(cmd.path, &sb);
	else {
		if ((fd = opendir(cmd.path)) < 0) {
			printf("opendir(%s): %s\n", cmd.path,
			    strerror(errno));
			return 0;
		}

		/* no strlen in lib !!! */
		for (p = cmd.path; *p; p++)
			;
		*p++ = '/';
		*p = '\0';

		while (readdir(fd, p) >= 0) {
			if (stat(cmd.path, &sb) < 0)
				printf("stat(%s): %s\n", cmd.path,
				    strerror(errno));
			else
				ls(p, &sb);
		}
		closedir (fd);
	}
	return 0;
}

#define lsrwx(mode,s) \
	putchar ((mode) & S_IROTH? 'r' : '-'); \
	putchar ((mode) & S_IWOTH? 'w' : '-'); \
	putchar ((mode) & S_IXOTH? *(s): (s)[1]);

static void
ls(char *name, struct stat *sb)
{
	putchar("-fc-d-b---l-s-w-"[(sb->st_mode & S_IFMT) >> 12]);
	lsrwx(sb->st_mode >> 6, (sb->st_mode & S_ISUID? "sS" : "x-"));
	lsrwx(sb->st_mode >> 3, (sb->st_mode & S_ISGID? "sS" : "x-"));
	lsrwx(sb->st_mode     , (sb->st_mode & S_ISTXT? "tT" : "x-"));

	printf (" %u,%u\t%lu\t%s\n", sb->st_uid, sb->st_gid,
	    (u_long)sb->st_size, name);
}
#undef lsrwx

int doboot = 1;

static int
Xnop(void)
{
	if (doboot) {
		doboot = 0;
		return (Xboot());
	}

	return 0;
}

static int
Xboot(void)
{
	if (cmd.argc > 1 && cmd.argv[1][0] != '-') {
		qualify((cmd.argv[1]? cmd.argv[1]: cmd.image));
		if (bootparse(2))
			return 0;
	} else {
		if (bootparse(1))
			return 0;
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, cmd.image);
	}

	return 1;
}

/*
 * Qualifies the path adding necessary dev
 */

static char *
qualify(char *name)
{
	char *p;

	for (p = name; *p; p++)
		if (*p == ':')
			break;
	if (*p == ':')
		strlcpy(cmd.path, name, sizeof(cmd.path));
	else
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, name);
	return cmd.path;
}

static int
Xreboot(void)
{
	printf("Rebooting...\n");
	exit();
	return 0; /* just in case */
}

@


1.62
log
@Avoid buffer overflow on max line length by ending string with just one \0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.61 2013/12/23 23:32:40 deraadt Exp $	*/
a131 1

a156 1

a158 1

d378 1
a378 1
	if (cmd.argc == 1)
d380 11
d392 4
a395 14
		dev = ttydev(cmd.argv[1]);
		if (dev == NODEV)
			printf("%s not a console device\n", cmd.argv[1]);
		else {
			if (cmd.argc == 2)
				printf("%s speed is %d\n", cmd.argv[1],
				       cnspeed(dev, -1));
			else {
				sp = 0;
				for (cp = cmd.argv[2]; *cp && isdigit(*cp); cp++)
					sp = sp * 10 + (*cp - '0');
				cnspeed(dev, sp);
			}
		}
a396 1

a406 2
	else {
	}
d427 2
a428 2
			printf ("opendir(%s): %s\n", cmd.path,
				strerror(errno));
d438 1
a438 1
		while(readdir(fd, p) >= 0) {
d441 1
a441 1
				       strerror(errno));
@


1.61
log
@remove junk
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.60 2009/02/16 23:58:05 sthen Exp $	*/
d286 1
a286 1
			p[1] = *p = '\0';
@


1.60
log
@Cancel the automatic boot when you hold ctrl to skip boot.conf.
"I like it" deraadt "sweet" tedu "love it" marco
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.59 2007/04/27 10:08:34 tom Exp $	*/
a31 4
#ifdef REGRESS
#include <sys/stat.h>
#include <errno.h>
#else
a33 1
#endif
a218 4
#ifdef REGRESS
	printf("%s %s\n", cmd.argv[0],
	    (cmd.argv[1] == NULL) ? "(null)" : cmd.argv[1]);
#else
a219 1
#endif
@


1.59
log
@Check for Control key held down when starting, and don't read boot.conf
if it is.  This gives a way to recover from "switching to com0" when
there's no serial cable handy.

Bump version numbers.

A similar change will be made to amd64 boot soon.

ok toby@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.58 2007/02/21 13:17:12 deraadt Exp $	*/
d111 1
@


1.58
log
@hand-cruft an isprint() for deciding which characters to echo to the
console; ignore all others.  based on idea by didickman@@gmail.com,
ok tom
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.57 2004/06/26 17:50:47 tom Exp $	*/
d59 4
d107 7
@


1.57
log
@Simplify expression in loop.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.56 2004/06/25 01:32:54 tom Exp $	*/
d294 7
a300 5
			if (p - buf < n-1)
				*p++ = ch;
			else {
				putchar('\007');
				putchar('\177');
@


1.56
log
@Avoid spurious error message "line too long" (introduced with last commit,
which fixed a buffer overflow here).

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.55 2004/06/24 22:32:26 tom Exp $	*/
d171 1
a171 1
		for (p = cmd_buf; *p && (*p == ' ' || *p == '\t'); p++)
@


1.55
log
@Turn off timeouts if the user types anything at all.  This prevents an
automatic boot in 5 seconds after you type "set tty com0", for example.

"I like this" deraadt@@, "oh! yes" henning@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.53 2004/06/24 16:38:59 tom Exp $	*/
d131 1
a131 1
		if (rc < 0)
d133 10
a142 1
		else {
@


1.54
log
@Minor changes (structural, not behavioural) in order to support a regress
test for boot command handling.

Suggested by avsm@@; discussed with avsm@@ and weingart@@ - thanks
@
text
@d262 3
@


1.53
log
@If a line in boot.conf is too long for our buffer, stop before we
overrun the buffer, print an error message, then stop processing
boot.conf.  Also change name of variable "eof" to "rc", since it's
not just for eof.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.52 2003/11/08 19:17:28 jmc Exp $	*/
a26 1
 *
d30 6
a36 1
#include <sys/reboot.h>
d38 2
a80 1
static int docmd(void);
d83 1
a83 1
char cmd_buf[133];
d152 1
a152 1
static int
d203 4
d208 1
@


1.52
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.51 2003/08/11 06:23:07 deraadt Exp $	*/
d97 1
a97 1
	int fd, eof = 0;
d122 3
a124 2
			eof = read(fd, p, 1);
		} while (eof > 0 && *p++ != '\n');
d126 1
a126 1
		if (eof < 0)
d128 2
a129 2
		else
			*--p = '\0';
d131 11
a141 1
	} while (eof > 0 && !(eof = docmd()));
d144 1
a144 1
	return eof;
@


1.51
log
@ansification and knf and protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.50 2003/06/02 20:20:54 mickey Exp $	*/
d467 1
a467 1
 * Qualifies the path adding neccessary dev
@


1.50
log
@three four kill ...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.49 2003/06/01 17:00:27 deraadt Exp $	*/
d71 4
a74 4
static void ls(char *, register struct stat *);
static int readline(register char *, size_t, int);
char *nextword(register char *);
static char *whatcmd(register const struct cmd_table **ct, register char *);
d81 1
a81 1
getcmd()
d92 1
a92 1
read_conf()
d117 1
a117 1
		register char *p = cmd_buf;
d137 1
a137 1
docmd()
d139 1
a139 1
	register char *p = NULL;
d191 1
a191 3
whatcmd(ct, p)
	register const struct cmd_table **ct;
	register char *p;
d193 2
a194 2
	register char *q;
	register int l;
d211 1
a211 4
readline(buf, n, to)
	register char *buf;
	size_t n;
	int	to;
d216 1
a216 1
	register char *p = buf, ch;
d281 1
a281 2
nextword(p)
	register char *p;
d297 1
a297 2
print_help(ct)
	register const struct cmd_table *ct;
d305 1
a305 1
Xhelp()
d318 1
a318 1
Xmachine()
d327 1
a327 1
Xecho()
d329 2
a330 1
	register int i;
d338 1
a338 1
Xstty()
d340 2
a341 2
	register int sp;
	register char *cp;
d367 1
a367 1
Xtime()
d380 1
a380 1
Xls()
d383 1
a383 1
	register char *p;
d424 1
a424 3
ls(name, sb)
	register char *name;
	register struct stat *sb;
d439 1
a439 1
Xnop()
d450 1
a450 1
Xboot()
d471 1
a471 2
qualify(name)
	char *name;
d473 1
a473 1
	register char *p;
d487 1
a487 1
Xreboot()
@


1.49
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.48 2002/07/14 09:19:17 mdw Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.48
log
@Fix ^U^U^M buffer underrun bug
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.47 2002/03/14 01:27:13 millert Exp $	*/
d21 2
a22 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d38 1
d126 1
a126 1
		do
d128 1
a128 1
		while (eof > 0 && *p++ != '\n');
d243 1
a243 1
			strncpy(buf, "boot", 5);
d248 2
a249 1
		while (!cnischar()) ;
d288 1
a288 1
 * next word, or NULL if there is no next word. 
d412 2
a413 1
		for (p = cmd.path; *p; p++);
d445 1
a445 1
		(u_long)sb->st_size, name);
d472 2
a473 1
		sprintf(cmd.path, "%s:%s", cmd.bootdev, cmd.image);
d493 1
a493 1
		strncpy(cmd.path, name, sizeof(cmd.path));
d495 2
a496 1
		sprintf(cmd.path, "%s:%s", cmd.bootdev, name);
@


1.47
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46 2000/01/20 19:56:48 mickey Exp $	*/
d252 1
a252 1
			while (p-- > buf)
d254 2
@


1.46
log
@buffer overflow in readline(;) from espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.45 2000/01/12 19:50:25 mickey Exp $	*/
d42 8
a49 8
static int Xboot __P((void));
static int Xecho __P((void));
static int Xhelp __P((void));
static int Xls __P((void));
static int Xnop __P((void));
static int Xreboot __P((void));
static int Xstty __P((void));
static int Xtime __P((void));
d51 1
a51 1
static int Xmachine __P((void));
d54 2
a55 2
extern int Xset __P((void));
extern int Xenv __P((void));
d75 6
a80 7
static void ls __P((char *, register struct stat *));
static int readline __P((register char *, size_t, int));
char *nextword __P((register char *));
static char *whatcmd
	__P((register const struct cmd_table **ct, register char *));
static int docmd __P((void));
static char *qualify __P((char *));
@


1.46.12.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46 2000/01/20 19:56:48 mickey Exp $	*/
d42 8
a49 8
static int Xboot(void);
static int Xecho(void);
static int Xhelp(void);
static int Xls(void);
static int Xnop(void);
static int Xreboot(void);
static int Xstty(void);
static int Xtime(void);
d51 1
a51 1
static int Xmachine(void);
d54 2
a55 2
extern int Xset(void);
extern int Xenv(void);
d75 7
a81 6
static void ls(char *, register struct stat *);
static int readline(register char *, size_t, int);
char *nextword(register char *);
static char *whatcmd(register const struct cmd_table **ct, register char *);
static int docmd(void);
static char *qualify(char *);
@


1.46.12.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46.12.1 2002/06/11 03:32:24 art Exp $	*/
d252 1
a252 1
			while (p > buf) {
a253 2
				p--;
			}
@


1.46.2.1
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 8
a49 8
static int Xboot(void);
static int Xecho(void);
static int Xhelp(void);
static int Xls(void);
static int Xnop(void);
static int Xreboot(void);
static int Xstty(void);
static int Xtime(void);
d51 1
a51 1
static int Xmachine(void);
d54 2
a55 2
extern int Xset(void);
extern int Xenv(void);
d75 7
a81 6
static void ls(char *, register struct stat *);
static int readline(register char *, size_t, int);
char *nextword(register char *);
static char *whatcmd(register const struct cmd_table **ct, register char *);
static int docmd(void);
static char *qualify(char *);
@


1.46.2.2
log
@Sync the SMP branch with 3.3
@
text
@d252 1
a252 1
			while (p > buf) {
a253 2
				p--;
			}
@


1.46.2.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.46.2.2 2003/03/28 00:08:47 niklas Exp $	*/
d15 5
d21 2
a22 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
a37 1
#include <lib/libkern/funcs.h>
d125 1
a125 1
		do {
d127 1
a127 1
		} while (eof > 0 && *p++ != '\n');
d242 1
a242 1
			strlcpy(buf, "boot", 5);
d247 1
a247 2
		while (!cnischar())
			;
d286 1
a286 1
 * next word, or NULL if there is no next word.
d410 1
a410 2
		for (p = cmd.path; *p; p++)
			;
d442 1
a442 1
	    (u_long)sb->st_size, name);
d469 1
a469 2
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, cmd.image);
d489 1
a489 1
		strlcpy(cmd.path, name, sizeof(cmd.path));
d491 1
a491 2
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, name);
@


1.46.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d71 4
a74 4
static void ls(char *, struct stat *);
static int readline(char *, size_t, int);
char *nextword(char *);
static char *whatcmd(const struct cmd_table **ct, char *);
d81 1
a81 1
getcmd(void)
d92 1
a92 1
read_conf(void)
d117 1
a117 1
		char *p = cmd_buf;
d137 1
a137 1
docmd(void)
d139 1
a139 1
	char *p = NULL;
d191 3
a193 1
whatcmd(const struct cmd_table **ct, char *p)
d195 2
a196 2
	char *q;
	int l;
d213 4
a216 1
readline(char *buf, size_t n, int to)
d221 1
a221 1
	char *p = buf, ch;
d286 2
a287 1
nextword(char *p)
d303 2
a304 1
print_help(const struct cmd_table *ct)
d312 1
a312 1
Xhelp(void)
d325 1
a325 1
Xmachine(void)
d334 1
a334 1
Xecho(void)
d336 1
a336 2
	int i;

d344 1
a344 1
Xstty(void)
d346 2
a347 2
	int sp;
	char *cp;
d373 1
a373 1
Xtime(void)
d386 1
a386 1
Xls(void)
d389 1
a389 1
	char *p;
d430 3
a432 1
ls(char *name, struct stat *sb)
d447 1
a447 1
Xnop(void)
d458 1
a458 1
Xboot(void)
d475 1
a475 1
 * Qualifies the path adding necessary dev
d479 2
a480 1
qualify(char *name)
d482 1
a482 1
	char *p;
d496 1
a496 1
Xreboot(void)
@


1.45
log
@repair printf format strings in echo; espie@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.44 1999/04/20 02:20:12 mickey Exp $	*/
d76 1
a76 1
static int readline __P((register char *, int));
d90 1
a90 1
	if (!readline(cmd_buf, cmd.timeout))
d218 1
a218 1
readline(buf, to)
d220 1
d226 1
a226 1
	register char *p = buf, *pe = buf, ch;
d253 1
a253 1
			while (pe-- > buf)
a254 1
			p = pe = buf;
d258 1
a258 1
			pe[1] = *pe = '\0';
a264 1
				pe--;
d268 6
a273 2
			pe++;
			*p++ = ch;
d279 1
a279 1
	return pe - buf;
@


1.44
log
@make calls for current time to BIOS less often; toby -- ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.43 1998/10/29 17:07:24 mickey Exp $	*/
d337 1
a337 1
		printf(cmd.argv[i]), putchar(' ');
@


1.43
log
@print \n when we've got timed out waiting for an operator
input, so the 'booting' progress will be shown on the next
line making that consistant w/ the 'boot' command look.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.42 1998/07/13 16:19:26 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997,1998 Michael Shalayeff
a225 1
	register time_t tt;
d229 2
a230 1
		tt = getsecs() + to;
d235 5
a239 2
		while (getsecs() < tt && !cnischar())
			;
@


1.42
log
@add extern debug decl for DEBUG enabled code
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.41 1998/06/23 05:14:49 mickey Exp $	*/
d240 1
@


1.41
log
@insert debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.40 1998/05/31 23:41:47 mickey Exp $	*/
d222 3
d233 1
a233 1
			printf ("readline: timeout(%d) at %lu\n", to, tt);
@


1.40
log
@cleanup for  !ANSI compilers, mostly __P usage
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.39 1998/05/30 01:48:31 mickey Exp $	*/
d223 1
a223 1
	time_t tt;
d227 6
a232 1
		for (tt = getsecs() + to; getsecs() < tt && !cnischar(); )
@


1.39
log
@use ctime(), kill that ugly time_print() hack
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.38 1998/05/25 19:17:40 mickey Exp $	*/
d290 2
a291 1
print_help(register const struct cmd_table *ct)
@


1.38
log
@make a new file for variable manipulation code; add environment support
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.37 1998/04/18 07:40:03 deraadt Exp $	*/
d361 2
d364 1
a364 1
		time_print();
@


1.37
log
@i386 bootblocks that work for 2.3. A tale too long to tell
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.36 1998/02/24 22:16:03 weingart Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
a39 2
extern int debug;

a41 1
static int Xaddr __P((void));
d43 1
a43 4
static int Xdevice __P((void));
#ifdef DEBUG
static int Xdebug __P((void));
#endif
a44 1
static int Ximage __P((void));
a47 1
static int Xset __P((void));
a48 2
static int Xhowto __P((void));
static int Xtty __P((void));
a49 1
static int Xecho __P((void));
d54 2
d57 1
a57 12
const struct cmd_table cmd_set[] = {
	{"addr",   CMDT_VAR, Xaddr},
	{"howto",  CMDT_VAR, Xhowto},
#ifdef DEBUG	
	{"debug",  CMDT_VAR, Xdebug},
#endif
	{"device", CMDT_VAR, Xdevice},
	{"tty",    CMDT_VAR, Xtty},
	{"image",  CMDT_VAR, Ximage},
	{NULL,0}
};

d62 1
a74 1
extern const char version[];
a77 1
static int bootparse __P((int));
a288 14
#ifdef DEBUG
static int
Xdebug()
{
	if (cmd.argc !=2)
		printf(debug? "on": "off");
	else
		debug = (cmd.argv[1][0] == '0' ||
			 (cmd.argv[1][0] == 'o' && cmd.argv[1][1] == 'f'))?
			 0: 1;
	return 0;
}
#endif

a328 15
/* called only w/ no arguments */
static int
Xset()
{
	register const struct cmd_table *ct;

	printf("OpenBSD boot[%s]\n", version);
	for (ct = cmd_set; ct->cmd_name != NULL; ct++) {
		printf("%s\t ", ct->cmd_name);
		(*ct->cmd_exec)();
		putchar('\n');
	}
	return 0;
}

a358 51
Xdevice()
{
	if (cmd.argc != 2)
		printf(cmd.bootdev);
	else
		strncpy(cmd.bootdev, cmd.argv[1], sizeof(cmd.bootdev));
	return 0;
}

static int
Ximage()
{
	if (cmd.argc != 2)
		printf(cmd.image);
	else
		strncpy(cmd.image, cmd.argv[1], sizeof(cmd.image));
	return 0;
}

static int
Xaddr()
{
	if (cmd.argc != 2)
		printf("%p", cmd.addr);
	else
		cmd.addr = (void *)strtol(cmd.argv[1], NULL, 0);
	return 0;
}

static int
Xtty()
{
	dev_t dev;

	if (cmd.argc == 1)
		printf(ttyname(0));
	else {
		dev = ttydev(cmd.argv[1]);
		if (dev == NODEV)
			printf("%s not a console device\n", cmd.argv[1]);
		else {
			printf("switching console to %s\n", cmd.argv[1]);
			if (cnset(dev))
				printf("%s console not present\n",
				       cmd.argv[1]);
		}
	}
	return 0;
}

static int
a440 22
Xhowto()
{
	if (cmd.argc < 2) {
		if (cmd.boothowto) {
			putchar('-');
			if (cmd.boothowto & RB_ASKNAME)
				putchar('a');
			if (cmd.boothowto & RB_HALT)
				putchar('b');
			if (cmd.boothowto & RB_CONFIG)
				putchar('c');
			if (cmd.boothowto & RB_SINGLE)
				putchar('s');
			if (cmd.boothowto & RB_KDB)
				putchar('d');
		}
	} else
		bootparse(1);
	return 0;
}

static int
a473 41
}

static int
bootparse(i)
	int i;
{
	register char *cp;
	int howto = cmd.boothowto;

	for (; i < cmd.argc; i++) {
		cp = cmd.argv[i];
		if (*cp == '-') {
			while (*++cp) {
				switch (*cp) {
				case 'a':
					howto |= RB_ASKNAME;
					break;
				case 'b':
					howto |= RB_HALT;
					break;
				case 'c':
					howto |= RB_CONFIG;
					break;
				case 's':
					howto |= RB_SINGLE;
					break;
				case 'd':
					howto |= RB_KDB;
					break;
				default:
					printf("howto: bad option: %c\n", *cp);
					return 1;
				}
			}
		} else {
			printf("boot: illegal argument %s\n", cmd.argv[i]);
			return 1;
		}
	}
	cmd.boothowto = howto;
	return 0;
@


1.36
log
@Various fixes (timeout, uninited vars), as well as some semantics
improvements.  Needs another overhaul still though...
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.35 1997/11/04 20:15:31 weingart Exp $	*/
d66 1
a66 1
static const struct cmd_table cmd_set[] = {
d78 1
a78 1
static const struct cmd_table cmd_table[] = {
d104 1
a104 1
static char cmd_buf[133];
d528 2
a532 2
	static int doboot = 1;

d535 1
a535 1
		return(Xboot());
@


1.35
log
@Get GID bit correct in ls.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.34 1997/10/07 07:59:57 mickey Exp $	*/
d53 1
d79 2
a80 1
	{"boot",   CMDT_CMD, Xboot}, /* XXX must be first */
d166 1
a166 1
	const struct cmd_table *ct, *cs;
d246 4
a249 2
	for (tt = getsecs() + to; getsecs() < tt && !cnischar(); )
		;
d251 6
a256 2
	if (!cnischar())
		return 0;
a430 2
	register char *p;

d433 2
a434 13
	else {
		register u_long a;

		p = cmd.argv[1];
		if (p[0] == '0' && p[1] == 'x')
			p += 2;
		for (a = 0; *p != '\0'; p++) {
			a <<= 4;
			a |= (isdigit(*p)? *p - '0':
			      10 + tolower(*p) - 'a') & 0xf;
		}
		cmd.addr = (void *)a;
	}
d527 13
@


1.34
log
@let's keep it MI; 10x phil for the MD implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.33 1997/09/20 22:40:37 flipk Exp $	*/
d525 1
a525 1
	lsrwx(sb->st_mode >> 3, (sb->st_mode & S_ISUID? "sS" : "x-"));
@


1.33
log
@- add 'stty [baudrate]' command to /boot, for serial consoles
- switch baud rates using i/o instead of bios, since bios commands
have only a limited bitwidth for baudrate, and max out at 9600
- when switching console devices, print msg to both old device and new
- fix timeout bug in com_getc() (dev | 0x80 was reading gobbledygook)
- document 'stty' command in boot(8)
- wording and cleanup in man pages
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.32 1997/09/17 19:55:34 mickey Exp $	*/
a36 1
#include <biosdev.h>
d374 4
a377 2
	int sp;
	char *cp;
d379 1
a379 1
		printf("com speed is %d\n", com_setsp(0));
d381 14
a394 4
		sp = 0;
		for (cp = cmd.argv[1]; *cp && isdigit(*cp); cp++)
			sp = sp*10 + (*cp - '0');
		com_setsp(sp);
@


1.32
log
@regs command is MD
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.31 1997/09/02 21:02:15 mickey Exp $	*/
d37 1
d56 1
d88 1
d373 17
d443 6
a448 2
		else if (cnset(dev))
			printf("%s console not present\n", cmd.argv[1]);
@


1.31
log
@Xregs is DUMP_REGS -- dependable
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.30 1997/09/02 20:48:17 mickey Exp $	*/
a36 1
#include <debug.h>
a49 3
#ifdef DUMP_REGS
static int Xregs __P((void));
#endif
a84 3
#ifdef DUMP_REGS
	{"regs",   CMDT_CMD, Xregs},
#endif
a604 8
#ifdef DUMP_REGS
static int
Xregs()
{
	DUMP_REGS;
	return 0;
}
#endif
@


1.30
log
@machine(MD) command set support
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.29 1997/08/22 00:41:27 mickey Exp $	*/
d50 2
@


1.29
log
@theo said we don't need 'cd' command
remove c-r, it won't work anyways
fix c-u
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.28 1997/08/21 22:17:56 mickey Exp $	*/
d61 4
a64 9

struct cmd_table {
	char *cmd_name;
	char cmd_type;
#define CMDT_CMD 0
#define CMDT_VAR 1
#define CMDT_SET 2
	int (*cmd_exec) __P((void));
};
d83 3
d87 1
a87 1
#ifdef DEBUG
a165 1
	const struct cmd_table *ct;
d167 1
d182 1
d189 8
a196 1
			const struct cmd_table *cs = cmd_set;
d319 8
a329 2
	register const struct cmd_table *ct;

d331 7
a337 3
	for (ct = cmd_table; ct->cmd_name != NULL; ct++)
		printf(" %s", ct->cmd_name);
	putchar('\n');
d339 6
d347 1
d610 1
a610 1
#ifdef DEBUG
@


1.28
log
@correct dev:<need cwd>name case in qualify()
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.27 1997/08/21 22:15:17 mickey Exp $	*/
a46 1
static int Xcd __P((void));
a84 1
	{"cd",     CMDT_CMD, Xcd},
a248 4
		case CTRL('r'):
			while (pe > buf)
				putchar('\177');
			printf(buf);
d250 1
a250 2
			while (pe >= buf) {
				pe--;
a251 1
			}
a342 1
	printf("cwd\t%s\n", cmd.cwd);
d512 1
a512 1
		sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, cmd.image);
d519 1
a519 1
 * Qualifies the path adding neccessary dev&|cwd
d532 2
a533 5
		if (p[1] == '/')
			sprintf(cmd.path, "%s", name);
		else
			sprintf(cmd.path, "%s%s", cmd.cwd, name);
	else if (name[0] == '/')
a534 2
	else
		sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, name);
a575 51
	return 0;
}

static int
Xcd()
{
	register char *p, *q;
	struct stat sb;

	/* cd home */
	if (cmd.argc == 1) {
		cmd.cwd[0] = '/';
		cmd.cwd[1] = '\0';
		return 0;
	}

	/* cd '.' */
	if (cmd.argv[1][0] == '.' && cmd.argv[1][1] == '\0')
		return 0;

	/* cd '..' */
	if (cmd.argv[1][0] == '.' && cmd.argv[1][1] == '.'
	    && cmd.argv[1][2] == '\0') {
		/* strrchr(cmd.cwd, '/'); */
		for (p = cmd.cwd; *++p;);
		for (p--; *--p != '/';);
		p[1] = '\0';
		return 0;
	}

	/* cd dir */
	sprintf(cmd.path, "%s:%s%s", cmd.bootdev, cmd.cwd, cmd.argv[1]);

	if (stat(cmd.path, &sb) < 0) {
		printf("stat(%s): %s\n", cmd.argv[1], strerror(errno));
		return 0;
	}

	if (!S_ISDIR(sb.st_mode)) {
		printf("boot: %s: not a dir\n", cmd.argv[1]);
		return 0;
	}

	/* change dir */
	for (p = cmd.cwd; *p; p++);
	for (q = cmd.argv[1]; (*p++ = *q++) != '\0';);
	if (p[-2] != '/') {
		p[-1] = '/';
		p[0] = '\0';
	}

@


1.27
log
@print ttyname w/o format string
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.26 1997/08/21 22:04:32 mickey Exp $	*/
d544 1
a544 1
			sprintf(cmd.path, "%s%s%s", name, cmd.cwd, name);
@


1.26
log
@boothowto is local to boot
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.25 1997/08/21 21:40:24 mickey Exp $	*/
d409 1
a409 1
		printf("%s", ttyname(0));
@


1.25
log
@no need for \n
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.24 1997/08/21 19:07:29 mickey Exp $	*/
d493 1
a493 1
		if (boothowto) {
d495 1
a495 1
			if (boothowto & RB_ASKNAME)
d497 1
a497 1
			if (boothowto & RB_HALT)
d499 1
a499 1
			if (boothowto & RB_CONFIG)
d501 1
a501 1
			if (boothowto & RB_SINGLE)
d503 1
a503 1
			if (boothowto & RB_KDB)
d557 1
a557 1
	int howto = boothowto;
d589 1
a589 1
	boothowto = howto;
@


1.24
log
@kill unused commands, yes we are not an operating system
sutisfied?
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.23 1997/08/13 14:24:00 niklas Exp $	*/
d409 1
a409 1
		printf("%s\n", ttyname(0));
@


1.23
log
@s/kbd/pc/ for consistency with kernel.  Do even better __asms for BIOS calls.
Adapt to new console probing and setting API.  Do not try to probe pc0 via
the NVRAM.  Fix some other buglets.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.22 1997/08/13 03:49:28 mickey Exp $	*/
a47 1
static int Xcp __P((void));
d51 1
a55 1
static int Xnope __P((void));
a56 1
static int Xregs __P((void));
a60 1
static int Xdmesg __P((void));
a86 2
	{"cp",     CMDT_CMD, Xcp},
	{"dmesg",  CMDT_CMD, Xdmesg},
a89 1
	{"nope",   CMDT_CMD, Xnope},
d91 1
d93 1
a431 6
Xdmesg()
{
	return 0;
}

static int
d652 1
d659 1
a659 14

static int
Xnope()
{
	return 0;
}

static int
Xcp()
{
	printf("cp: no writable filesystems\n");
	return 0;
}

@


1.22
log
@remove unused include
more const
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.21 1997/08/12 22:10:43 mickey Exp $	*/
d267 1
d271 1
d410 2
d413 1
a413 1
		printf(ttyname(0));
d415 5
a420 1

@


1.21
log
@slite rewrite
set/print vars in a consistent (by niklas@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.20 1997/08/12 21:51:35 mickey Exp $	*/
a39 3
#ifndef _TEST0
#include <biosdev.h>
#endif
d75 1
a75 1
static struct cmd_table cmd_set[] = {
d87 1
a87 1
static struct cmd_table cmd_table[] = {
@


1.20
log
@new cons
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.19 1997/08/06 18:45:02 mickey Exp $	*/
d40 1
a40 1
#ifndef _TEST
d71 4
a75 1
	const struct cmd_table *cmd_table;
d78 3
a80 3
static const struct cmd_table cmd_set[] = {
	{"addr",      Xaddr},
	{"boothowto", Xhowto},
d82 1
a82 1
	{"debug",     Xdebug},
d84 3
a86 3
	{"device",    Xdevice},
	{"tty",       Xtty},
	{"image",     Ximage},
d90 13
a102 13
static const struct cmd_table cmd_table[] = {
	{"boot",   Xboot}, /* XXX must be first */
	{"cd",     Xcd},
	{"cp",     Xcp},
	{"dmesg",  Xdmesg},
	{"echo",   Xecho},
	{"help",   Xhelp},
	{"ls",     Xls},
	{"nope",   Xnope},
	{"reboot", Xreboot},
	{"regs",   Xregs},
	{"set",    Xset, cmd_set},
	{"time",   Xtime},
d198 2
a199 2
		} else if (ct->cmd_table != NULL && p != NULL) {
			const struct cmd_table *cs = ct->cmd_table;
d317 1
a317 1
		printf("debug\t%s\n", (debug? "on": "off"));
d331 1
a331 1
	printf("commands: ");
d357 2
a358 1
	for (ct = cmd_set; ct->cmd_name != NULL; ct++)
d360 2
d369 1
a369 1
		printf("device\t%s\n", cmd.bootdev);
d379 1
a379 1
		printf("image\t%s\n", cmd.image);
d391 1
a391 1
		printf("addr\t%p\n", cmd.addr);
d412 1
a412 1
		printf("tty\t%s\n", ttyname(0));
a497 1
		printf("boothowto=");
a510 1
		putchar('\n');
@


1.19
log
@cmd is global anyways, don't pass it to handlers
add echo command
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.18 1997/07/01 20:02:22 mickey Exp $	*/
d247 1
a247 1
	for (tt = getsecs() + to; getsecs() < tt && !ischar(); )
d250 1
a250 1
	if (!ischar())
@


1.18
log
@smooth char waiting loop
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.17 1997/06/06 18:23:43 mickey Exp $	*/
d48 5
a52 5
static int Xaddr __P((register struct cmd_state *));
static int Xboot __P((register struct cmd_state *));
static int Xcd __P((register struct cmd_state *));
static int Xcp __P((register struct cmd_state *));
static int Xdevice __P((register struct cmd_state *));
d54 1
a54 1
static int Xdebug __P((register struct cmd_state *));
d56 12
a67 11
static int Xhelp __P((register struct cmd_state *));
static int Ximage __P((register struct cmd_state *));
static int Xls __P((register struct cmd_state *));
static int Xnope __P((register struct cmd_state *));
static int Xreboot __P((register struct cmd_state *));
static int Xregs __P((register struct cmd_state *));
static int Xset __P((register struct cmd_state *));
static int Xhowto __P((register struct cmd_state *));
static int Xtty __P((register struct cmd_state *));
static int Xtime __P((register struct cmd_state *));
static int Xdmesg __P((register struct cmd_state *));
d71 1
a71 1
	int (*cmd_exec) __P((register struct cmd_state *));
d92 1
d107 1
a107 1
static int bootparse __P((register struct cmd_state *, int));
d109 3
a111 3
	__P((register const struct cmd_table **, register char *));
static int docmd __P((register struct cmd_state *));
static char *qualify __P((register struct cmd_state *, char *));
d116 1
a116 2
getcmd(cmd)
	register struct cmd_state *cmd;
d118 1
a118 1
	cmd->cmd = NULL;
d120 2
a121 2
	if (!readline(cmd_buf, cmd->timeout))
		cmd->cmd = cmd_table;
d123 1
a123 1
	return docmd(cmd);
d127 1
a127 2
read_conf(cmd)
	register struct cmd_state *cmd;
d134 1
a134 1
	if ((fd = open(qualify(cmd, cmd->conf), 0)) < 0) {
d136 1
a136 1
			printf("open(%s): %s\n", cmd->path, strerror(errno));
d145 1
a145 1
		printf("non-secure %s, will not proceed\n", cmd->path);
d154 1
a154 1
		cmd->cmd = NULL;
d161 1
a161 1
			printf("%s: %s\n", cmd->path, strerror(errno));
d165 1
a165 1
	} while (eof > 0 && !(eof = docmd(cmd)));
d172 1
a172 2
docmd(cmd)
	register struct cmd_state *cmd;
d177 2
a178 2
	cmd->argc = 1;
	if (cmd->cmd == NULL) {
d190 1
a190 1
		cmd->argv[cmd->argc] = p; /* in case it's shortcut boot */
d193 1
a193 1
			cmd->argc++;
d204 1
a204 1
		cmd->cmd = ct;
d207 3
a209 3
	cmd->argv[0] = ct->cmd_name;
	while (p && cmd->argc+1 < sizeof(cmd->argv) / sizeof(cmd->argv[0])) {
		cmd->argv[cmd->argc++] = p;
d212 1
a212 1
	cmd->argv[cmd->argc] = NULL;
d214 1
a214 1
	return (*cmd->cmd->cmd_exec)(cmd);
d311 1
a311 2
Xdebug(cmd)
	struct cmd_state *cmd;
d313 2
a314 2
	if (cmd->argc !=2)
		printf("debug=%s\n", (debug? "on": "off"));
d316 2
a317 2
		debug = (cmd->argv[1][0] == '0' ||
			 (cmd->argv[1][0] == 'o' && cmd->argv[1][1] == 'f'))?
d324 1
a324 2
Xhelp(cmd)
	register struct cmd_state *cmd;
d336 10
d348 1
a348 2
Xset(cmd)
	register struct cmd_state *cmd;
d353 1
a353 1
	printf("cwd=%s\n", cmd->cwd);
d355 1
a355 1
		(*ct->cmd_exec)(cmd);
d360 1
a360 2
Xdevice(cmd)
	register struct cmd_state *cmd;
d362 2
a363 2
	if (cmd->argc != 2)
		printf("device=%s\n", cmd->bootdev);
d365 1
a365 1
		strncpy(cmd->bootdev, cmd->argv[1], sizeof(cmd->bootdev));
d370 1
a370 2
Ximage(cmd)
	register struct cmd_state *cmd;
d372 2
a373 2
	if (cmd->argc != 2)
		printf("image=%s\n", cmd->image);
d375 1
a375 1
		strncpy(cmd->image, cmd->argv[1], sizeof(cmd->image));
d380 1
a380 2
Xaddr(cmd)
	register struct cmd_state *cmd;
d384 2
a385 2
	if (cmd->argc != 2)
		printf("addr=%p\n", cmd->addr);
d389 1
a389 1
		p = cmd->argv[1];
d397 1
a397 1
		cmd->addr = (void *)a;
d403 1
a403 2
Xtty(cmd)
	register struct cmd_state *cmd;
d405 2
a406 2
	if (cmd->argc == 1)
		printf("tty=%s\n", ttyname(0));
d414 1
a414 2
Xtime(cmd)
	register struct cmd_state *cmd;
d416 1
a416 1
	if (cmd->argc == 1)
d425 1
a425 2
Xdmesg(cmd)
	register struct cmd_state *cmd;
d431 1
a431 2
Xls(cmd)
	register struct cmd_state *cmd;
d437 2
a438 2
	if (stat(qualify(cmd, (cmd->argv[1]? cmd->argv[1]: "/.")), &sb) < 0) {
		printf("stat(%s): %s\n", cmd->path, strerror(errno));
d443 1
a443 1
		ls(cmd->path, &sb);
d445 2
a446 2
		if ((fd = opendir(cmd->path)) < 0) {
			printf ("opendir(%s): %s\n", cmd->path,
d452 1
a452 1
		for (p = cmd->path; *p; p++);
d457 3
a459 3
			if (stat(cmd->path, &sb) < 0)
				printf("stat(%s): %s\n", cmd->path,
					strerror(errno));
d489 1
a489 2
Xhowto(cmd)
	register struct cmd_state *cmd;
d491 1
a491 1
	if (cmd->argc < 2) {
d508 1
a508 1
		bootparse(cmd, 1);
d513 1
a513 2
Xboot(cmd)
	register struct cmd_state *cmd;
d515 3
a517 3
	if (cmd->argc > 1 && cmd->argv[1][0] != '-') {
		qualify(cmd, (cmd->argv[1]? cmd->argv[1]: cmd->image));
		if (bootparse(cmd, 2))
d520 1
a520 1
		if (bootparse(cmd, 1))
d522 1
a522 2
		sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
			cmd->cwd, cmd->image);
d533 1
a533 2
qualify(cmd, name)
	register struct cmd_state *cmd;
d543 1
a543 1
			sprintf(cmd->path, "%s", name);
d545 1
a545 1
			sprintf(cmd->path, "%s%s%s", name, cmd->cwd, name);
d547 1
a547 1
		sprintf(cmd->path, "%s:%s", cmd->bootdev, name);
d549 2
a550 2
		sprintf(cmd->path, "%s:%s%s", cmd->bootdev, cmd->cwd, name);
	return cmd->path;
d554 1
a554 2
bootparse(cmd, i)
	register struct cmd_state *cmd;
d560 2
a561 2
	for (; i < cmd->argc; i++) {
		cp = cmd->argv[i];
d586 1
a586 1
			printf("boot: illegal argument %s\n", cmd->argv[i]);
d595 1
a595 2
Xcd(cmd)
	register struct cmd_state *cmd;
d601 3
a603 3
	if (cmd->argc == 1) {
		cmd->cwd[0] = '/';
		cmd->cwd[1] = '\0';
d608 1
a608 1
	if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '\0')
d612 4
a615 4
	if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '.'
	    && cmd->argv[1][2] == '\0') {
		/* strrchr(cmd->cwd, '/'); */
		for (p = cmd->cwd; *++p;);
d622 1
a622 2
	sprintf(cmd->path, "%s:%s%s",
		cmd->bootdev, cmd->cwd, cmd->argv[1]);
d624 2
a625 2
	if (stat(cmd->path, &sb) < 0) {
		printf("stat(%s): %s\n", cmd->argv[1], strerror(errno));
d630 1
a630 1
		printf("boot: %s: not a dir\n", cmd->argv[1]);
d635 2
a636 2
	for (p = cmd->cwd; *p; p++);
	for (q = cmd->argv[1]; (*p++ = *q++) != '\0';);
d646 1
a646 2
Xreboot(cmd)
	register struct cmd_state *cmd;
d654 1
a654 2
Xregs(cmd)
	register struct cmd_state *cmd;
d661 1
a661 2
Xnope(cmd)
	register struct cmd_state *cmd;
d667 1
a667 2
Xcp(cmd)
	register struct cmd_state *cmd;
@


1.17
log
@use destructive erase
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.16 1997/06/06 16:26:56 kstailey Exp $	*/
d246 1
a246 1
	register int i;
d248 1
a248 4
	for (i = to; i-- && !ischar(); )
#ifndef _TEST
		sleep(1);
#else
d250 2
a251 2
#endif
	if (i < 0)
@


1.16
log
@fix twiddle() without breaking backspace
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 1997/05/31 15:48:25 mickey Exp $	*/
d261 1
a261 1
				putchar('\b');
d266 1
a266 1
				putchar('\b');
@


1.15
log
@usleep won't work on some weird laptops
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.13 1997/04/28 07:39:00 weingart Exp $	*/
d275 1
a275 1
				putchar('\b');
@


1.14
log
@usleep is void now
@
text
@d66 1
d90 1
d135 1
a135 1
		if (errno != ENOENT) {
d245 2
a246 2
	char *p = buf, *pe = buf, ch;
	int i;
d250 1
a250 1
		usleep(100000);
d423 7
@


1.13
log
@Add getsecs().  Use biostime & biosdate routines.
Parse and convert to seconds since epoch.  Please
test, there is a new command "time", which should
print the current time (according to the BIOS) on
the console.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.12 1997/04/26 17:50:07 mickey Exp $	*/
a35 1
#include <string.h>
d248 1
a248 5
		if ((to = usleep(100000))) {
			printf ("usleep failed (%d)\n", to);
			i = 1;
			break;
		}
@


1.13.2.1
log
@2.1 laptop kbd fixes from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.15 1997/05/31 15:48:25 mickey Exp $	*/
d36 1
d134 1
a134 1
		if (errno != ENOENT && errno != ENXIO) {
a216 3
int strncmp __P((char *, char *, int));
int sleep __P((int));

d244 2
a245 2
	register char *p = buf, *pe = buf, ch;
	register int i;
d249 5
a253 1
		sleep(1);
@


1.12
log
@boot.conf support
ttyname function in cons.c
rdonly var 'tty' to view tty settings
serial console soon
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.11 1997/04/21 20:20:25 mickey Exp $	*/
d66 1
d96 1
d411 12
@


1.11
log
@usleep testing code
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.10 1997/04/21 20:03:30 mickey Exp $	*/
d49 5
a53 5
static int Xaddr __P((struct cmd_state *));
static int Xboot __P((struct cmd_state *));
static int Xcd __P((struct cmd_state *));
static int Xcp __P((struct cmd_state *));
static int Xdevice __P((struct cmd_state *));
d55 1
a55 1
static int Xdebug __P((struct cmd_state *));
d57 9
a65 8
static int Xhelp __P((struct cmd_state *));
static int Ximage __P((struct cmd_state *));
static int Xls __P((struct cmd_state *));
static int Xnope __P((struct cmd_state *));
static int Xreboot __P((struct cmd_state *));
static int Xregs __P((struct cmd_state *));
static int Xset __P((struct cmd_state *));
static int Xhowto __P((struct cmd_state *));
d69 1
a69 1
	int (*cmd_exec)(struct cmd_state *);
d73 1
a73 1
const struct cmd_table cmd_set[] = {
d80 1
d85 1
a85 1
const struct cmd_table cmd_table[] = {
d102 1
a102 1
static int bootparse __P((struct cmd_state *, int));
d105 4
a108 1
char cmd_buf[133];
d112 59
a170 1
	struct cmd_state *cmd;
d173 1
a173 1
	register char *p;
d176 1
a176 5

	if (!readline(cmd_buf, cmd->timeout)) {
		cmd->cmd = cmd_table;
		p = NULL;
	} else {
d181 6
d260 4
a267 2
				putchar(' ');
				putchar('\b');
a276 2
				putchar(' ');
				putchar('\b');
d331 1
a331 1
	struct cmd_state *cmd;
d346 1
a346 1
	struct cmd_state *cmd;
d359 1
a359 1
	struct cmd_state *cmd;
d370 1
a370 1
	struct cmd_state *cmd;
d381 1
a381 1
	struct cmd_state *cmd;
d404 12
d417 1
a417 1
	struct cmd_state *cmd;
d423 1
a423 6
	if (cmd->argv[1] != NULL)
		strncpy (cmd->path, cmd->argv[1], sizeof(cmd->path));
	else
		sprintf(cmd->path, "%s:%s/.", cmd->bootdev, cmd->cwd);

	if (stat(cmd->path, &sb) < 0) {
d459 1
a459 1
void
d461 1
a461 1
	char *name;
d476 1
a476 1
	struct cmd_state *cmd;
d501 1
a501 1
	struct cmd_state *cmd;
d504 1
a504 14
		register char *p;

		for (p = cmd->argv[1]; *p; p++)
			if (*p == ':')
				break;
		if (*p == ':')
			sprintf(cmd->path, "%s", cmd->argv[1]);
		else if (cmd->argv[1][0] == '/')
			sprintf(cmd->path, "%s:%s", cmd->bootdev,
				cmd->argv[1]);
		else
			sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
				cmd->cwd, cmd->argv[1]);

d517 26
d545 1
a545 1
	struct cmd_state *cmd;
d587 1
a587 1
	struct cmd_state *cmd;
d640 1
a640 1
	struct cmd_state *cmd;
d649 1
a649 1
	struct cmd_state *cmd;
d657 1
a657 1
	struct cmd_state *cmd;
d664 1
a664 1
	struct cmd_state *cmd;
@


1.10
log
@rewrite command processing.
two levels of commands from now (set has it's own {device,image,addr,howto})
all the combinations of {device,path,image,options} is now possible on boot.
move cmd_state init into .data again, no more memory limits
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.9 1997/04/17 21:47:37 deraadt Exp $	*/
d182 5
a186 1
		usleep(100000);
@


1.9
log
@make "boot> -a" work like "boot> bsd -a"; ie. flags shortcut
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.8 1997/04/16 22:14:15 deraadt Exp $	*/
d49 18
a66 1
const struct cmd_table {
d68 7
a74 6
	int cmd_id;
} cmd_table[] = {
	{"addr",   CMD_ADDR},
	{"boot",   CMD_BOOT},
	{"cd",     CMD_CD},
	{"device", CMD_DEVICE},
d76 1
a76 1
	{"debug",  CMD_DEBUG},
d78 15
a92 7
	{"help",   CMD_HELP},
	{"image",  CMD_IMAGE},
	{"ls",     CMD_LS},
	{"nope",   CMD_NOPE},
	{"reboot", CMD_REBOOT},
	{"regs",   CMD_REGS},
	{"set",    CMD_SET},
d100 4
a103 3
int bootparse __P((struct cmd_state *));

char *cmd_buf = NULL;
d109 2
a110 3
	register const struct cmd_table *ct = cmd_table;
	register char *p, *q;
	int l;
a111 4
	if (cmd_buf == NULL)
		cmd_buf = alloc(133);

	cmd->rc = 0;
d115 3
a117 7
		printf("\n");
		cmd->cmd = CMD_BOOT;
		cmd->argv[0] = cmd_table[CMD_BOOT].cmd_name;
		cmd->argv[1] = NULL;
		cmd->rc = 1;
		return 0;
	}
d119 17
a135 17
	/* command */
	for (q = cmd_buf; *q && (*q == ' ' || *q == '\t'); q++)
		;
	p = nextword(q);

	for (l = 0; q[l]; l++)
		;
	while (ct->cmd_name != NULL && strncmp(q, ct->cmd_name, l))
		ct++;

	if (ct->cmd_name == NULL) {
		cmd->cmd = CMD_BOOT;
		cmd->argv[0] = cmd_table[CMD_BOOT].cmd_name;
		if (q && *q) {
			if (*q == '-')
				cmd->argv[cmd->argc++] = NULL;	/* XXX */
			cmd->argv[cmd->argc++] = q;
d137 1
a137 3
	} else {
		cmd->cmd = ct->cmd_id;
		cmd->argv[0] = ct->cmd_name;
d139 2
d146 24
a169 1
	return bootparse(cmd);
d245 3
a247 2
int
execmd(cmd)
d250 8
a257 13
	struct stat sb;
	int fd;
	register char *p, *q;
	register const struct cmd_table *ct;

	cmd->rc = 0;
	switch (cmd->cmd) {

#ifdef DEBUG
	case CMD_DEBUG:
		debug = !debug;
		printf("debug is %s\n", debug? "on": "off");
		break;
d260 5
a264 6
	case CMD_HELP:
		printf("commands: ");
		for (ct = cmd_table; ct->cmd_name != NULL; ct++)
			printf(" %s", ct->cmd_name);
		putchar('\n');
		break;
d266 4
a269 8
	case CMD_DEVICE:
		if (cmd->argc != 2)
			printf("device: device name required\n");
		else {
			strncpy(cmd->bootdev, cmd->argv[1],
				sizeof(cmd->bootdev));
		}
		break;
d271 2
a272 8
	case CMD_IMAGE:
		if (cmd->argc != 2)
			printf("image: pathname required\n");
		else {
			strncpy(cmd->image, cmd->argv[1],
				sizeof(cmd->image));
		}
		break;
d274 6
a279 14
	case CMD_ADDR:
		if (cmd->argc != 2)
			printf("addr: address required\n");
		else {
			register u_long a;

			p = cmd->argv[1];
			if (p[0] == '0' && p[1] == 'x')
				p += 2;
			for (a = 0; *p != '\0'; p++) {
				a <<= 4;
				a |= (isdigit(*p)? *p - '0':
				      10 + tolower(*p) - 'a') & 0xf;
			}
d281 6
a286 3
			cmd->addr = (void *)a;
		}
		break;
d288 10
a297 8
	case CMD_LS:
		{
			if (cmd->argv[1] != NULL)
				strncpy (cmd->path, cmd->argv[1],
					 sizeof(cmd->path));
			else
				sprintf(cmd->path, "%s:%s/.",
					cmd->bootdev, cmd->cwd);
d299 10
a308 4
			if (stat(cmd->path, &sb) < 0) {
				printf("stat(%s): %d\n", cmd->path, errno);
				break;
			}
d310 5
a314 22
			if ((sb.st_mode & S_IFMT) != S_IFDIR)
				ls(cmd->path, &sb);
			else {
				if ((fd = opendir(cmd->path)) < 0) {
					printf ("opendir(%s): %d\n",
						cmd->path, errno);
					break;
				}

				/* no strlen in lib !!! */
				for (p = cmd->path; *p; p++);
				*p++ = '/';
				*p = '\0';

				while(readdir(fd, p) >= 0) {

					if (stat(cmd->path, &sb) < 0)
						printf("stat(%s): %d\n",
						       cmd->path, errno);
					else
						ls(p, &sb);
				}
d316 12
a327 2
				closedir (fd);
			}
d329 4
a332 1
		break;
d334 7
a340 6
	case CMD_CD:
		if (cmd->argc == 1) {
			cmd->cwd[0] = '/';
			cmd->cwd[1] = '\0';
			break;
		}
d342 4
a345 2
		if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '\0')
			break;
d347 4
a350 8
		if (cmd->argv[1][0] == '.' && cmd->argv[1][1] == '.'
		    && cmd->argv[1][2] == '\0') {
			/* strrchr(cmd->cwd, '/'); */
			for (p = cmd->cwd; *++p;);
			for (p--; *--p != '/';);
			p[1] = '\0';
			break;
		}
d352 20
a371 5
		sprintf(cmd->path, "%s:%s%s",
			cmd->bootdev, cmd->cwd, cmd->argv[1]);
		if (stat(cmd->path, &sb) < 0) {
			printf("stat(%s): %d\n", cmd->argv[1], errno);
			break;
d373 1
a373 65

		if (!S_ISDIR(sb.st_mode)) {
			printf("boot: %s: not a dir\n", cmd->argv[1]);
			break;
		}

		/* change dir */
		for (p = cmd->cwd; *p; p++);
		for (q = cmd->argv[1]; (*p++ = *q++) != '\0';);
		if (p[-2] != '/') {
			p[-1] = '/';
			p[0] = '\0';
		}
		break;

	case CMD_SET:
		printf("OpenBSD/i386 boot version %s(debug is %s)\n"
		       "device:\t%s\n"
		       "cwd:\t%s\n"
		       "image:\t%s\n"
		       "load at:\t%p\n"
		       "timeout:\t%d\n",
		       version,
#ifdef DEBUG
		       (debug? "on": "off"),
#else
				"not present",
#endif
		       cmd->bootdev, cmd->cwd, cmd->image,
		       cmd->addr, cmd->timeout);
		break;

	case CMD_REBOOT:
		printf("Rebooting...\n");
		cmd->rc = -1;
		break;

	case CMD_REGS:
		DUMP_REGS;
		break;

	case CMD_BOOT:
		/* XXX "boot -s" will not work as this is written */
		if (cmd->argc > 1 && cmd->argv[1]) {
			char *p;

			for (p = cmd->argv[1]; *p; p++)
				if (*p == ':')
					break;
			if (*p == ':')
				sprintf(cmd->path, "%s", cmd->argv[1]);
			else 
				sprintf(cmd->path, "%s:%s", cmd->bootdev,
				    cmd->argv[1]);
		} else
			sprintf(cmd->path, "%s:%s%s", cmd->bootdev,
				cmd->cwd, cmd->image);
		cmd->rc = !bootparse(cmd);
		break;

	case CMD_ERROR:
	default:
		printf ("%s: invalid command\n", cmd->argv[0]);
	case CMD_NOPE:
		break;
d375 1
a375 2

	return cmd->rc;
d396 1
d398 27
a424 2
int
bootparse(cmd)
d427 30
a456 1
	char *cp;
d458 3
d462 1
a462 1
	for (i = 2; i < cmd->argc; i++) {
d468 1
a468 1
					boothowto |= RB_ASKNAME;
d471 1
a471 1
					boothowto |= RB_HALT;
d474 1
a474 1
					boothowto |= RB_CONFIG;
d477 1
a477 1
					boothowto |= RB_SINGLE;
d480 1
a480 1
					boothowto |= RB_KDB;
d482 3
d492 1
d495 86
@


1.8
log
@add RB_KDB support
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.7 1997/04/15 08:32:51 deraadt Exp $	*/
d93 1
a104 1
printf("cmd=%s\n", q);
d114 3
a116 1
		if (q && *q)
d118 1
a124 1
printf("argN=%s\n", p);
d377 1
a377 1
		if (cmd->argc > 1) {
@


1.7
log
@mostly repair option arg handling for booting
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.6 1997/04/11 19:12:56 weingart Exp $	*/
d444 3
@


1.6
log
@Works with .gz kernels now
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.5 1997/04/08 22:48:29 mickey Exp $	*/
d39 1
a71 1
static char *skipblnk __P((register char *));
d73 2
d83 2
a84 1
	register char *p = cmd_buf, *q; /* input */
d87 1
a87 1
		p = cmd_buf = alloc(133);
d96 1
a99 2
	p = skipblnk(cmd_buf);

d101 4
a104 2
	for ( q = p; *p != '\0' && *p != ' ' && *p != '\t'; p++);
	*p = '\0';
d106 3
a108 1
	while (ct->cmd_name != NULL && strncmp(q, ct->cmd_name, (p - q)))
d114 5
a118 4
		cmd->argv[1] = skipblnk(cmd_buf);
		cmd->argv[2] = NULL;
		cmd->argc++;
		return 0;
d120 4
a123 6

	cmd->cmd = ct->cmd_id;
	cmd->argv[0] = ct->cmd_name;
	for (p++; *(p = skipblnk(p)) != '\0'; *p++ = '\0') {
		cmd->argv[cmd->argc++] = q = p;
		for (; *p && *p != '\t' && *p != ' '; p++);
d126 1
a126 2

	return cmd->rc;
d147 1
a147 1
		switch (ch = getchar()) {
d149 1
a149 1
			while (pe > buf) {
d180 5
d186 1
a186 1
skipblnk(p)
d190 1
a190 1
	while (*p == '\t' || *p == ' ')
d192 7
a198 1

d374 13
a386 3
		if (cmd->argc > 1)
			strncpy(cmd->path, cmd->argv[1], sizeof(cmd->path));
		else
d389 1
a389 1
		cmd->rc = 1;
d421 33
@


1.5
log
@use new device names: fd(0,a) -> fd0a
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.4 1997/04/07 01:26:00 weingart Exp $	*/
d342 2
@


1.4
log
@Reboot stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: cmd.c,v 1.3 1997/04/01 04:50:33 mickey Exp $	*/
d256 1
a256 1
				sprintf(cmd->path, "%s%s/.",
d311 1
a311 1
		sprintf(cmd->path, "%s%s%s",
d360 1
a360 1
			sprintf(cmd->path, "%s%s%s", cmd->bootdev,
@


1.3
log
@^U hotkey in readline
sample regs command to show the registers
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d348 1
@


1.2
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d38 1
d46 2
d64 1
d126 2
a127 2
readline(p, to)
	register char *p;
d130 1
a130 1
	char *buf = p, ch;
d144 9
d154 1
a154 1
			p[1] = *p = '\0';
d162 1
d166 1
d172 2
a173 1
	return p - buf;
d349 4
@


1.1
log
@Initial /boot stuff (from Mickey)
@
text
@d39 3
d43 3
a45 1
static struct cmd_table {
d53 3
d65 4
a68 3
extern char version[];
void ls __P((char *, register struct stat *));
char skipblnk __P((void));
d70 1
a70 1
char cmd_buf[133];
d74 1
a74 1
	register struct cmd_state *cmd;
d76 5
a80 4
	register struct cmd_table *ct = cmd_table;
	register char *p = cmd_buf; /* input */
	register char ch;
	int len;
d85 1
a85 3
	for (len = cmd->timeout; len-- && !ischar(); );

	if (len < 0) {
d92 1
a92 1
	ch = skipblnk();
d94 2
a95 3
	for (len = 0; ch != '\n' &&
		     ch != ' ' && ch != '\t'; len++, ch = getchar())
		*p++ = ch;
d98 1
a98 7
	if (len == 0 && ch == '\n') {
		cmd->cmd = CMD_NOPE;
		return 0;
	}

	while (ct->cmd_name != NULL &&
	       strncmp(cmd_buf, ct->cmd_name, len))
d102 5
a106 2
		cmd->cmd = CMD_ERROR;
		cmd->argv[0] = ct->cmd_name;
d112 5
a116 2
	if (ct->cmd_name != NULL) {
		while (ch != '\n') {
d118 2
a119 1
			ch = skipblnk();
d121 28
a148 9
			if (ch != '\n') {
				cmd->argv[cmd->argc] = p;
				*p++ = ch;
				for (len = 0; (ch = getchar()) != '\n' &&
					     ch != ' ' && ch != '\t'; len++)
					*p++ = ch;
				*p++ = '\0';
				if (len != 0)
					cmd->argc++;
d150 4
d155 1
a155 1
		cmd->argv[cmd->argc] = NULL;
d157 1
a157 2

	return cmd->rc;
d160 3
a162 2
char
skipblnk()
a163 2
	register char ch;

d165 2
a166 2
	while ((ch = getchar()) != '\n' &&
	       (ch == ' ' || ch == '\t'));
d168 1
a168 1
	return ch;
d173 1
a173 1
	register struct cmd_state *cmd;
d178 1
a178 1
	register struct cmd_table *ct;
d181 1
d183 6
a188 1
	switch (cmd->cmd) {
d236 6
a241 3
			q = cmd->argv[1] == NULL? "." : cmd->argv[1];
			sprintf(cmd->path, "%s%s%s",
				cmd->bootdev, cmd->cwd, q);
d249 1
a249 1
				ls(q, &sb);
d257 2
a258 1
				p = cmd->path + strlen(cmd->path);
d262 1
a262 1
				while(readdir(fd, p) >= 0 && *p != '\0') {
d264 1
a264 1
					if (stat(cmd->path, &sb) < 0) {
d267 2
a268 3
						break;
					}
					ls(p, &sb);
d317 1
a317 1
		printf("OpenBSD boot version %s\n"
d323 5
a327 1
		       version, cmd->bootdev, cmd->cwd, cmd->image,
d332 1
a332 1
		exit(1);
d336 6
a341 1
		return 1;
d369 2
a370 2
	printf (" %s\tuid=%u\tgid=%u\t%lu\n", name, sb->st_uid, sb->st_gid,
		(u_long)sb->st_size);
@

