head	1.44;
access;
symbols
	OPENBSD_6_2:1.44.0.4
	OPENBSD_6_2_BASE:1.44
	OPENBSD_6_1:1.43.0.16
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.12
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.8
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.10
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.43.0.2
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.6
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.37.0.10
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.37.0.8
	OPENBSD_5_3_BASE:1.37
	OPENBSD_5_2:1.37.0.6
	OPENBSD_5_2_BASE:1.37
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.4
	OPENBSD_5_0:1.37.0.2
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.36.0.16
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.14
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.36.0.10
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.12
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.8
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.6
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.32.0.12
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.10
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.8
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.6
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.32.0.4
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.32.0.2
	OPENBSD_3_6_BASE:1.32
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.23.0.12
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.10
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.8
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.23.0.6
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.4
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.12
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.10
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.8
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.6
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.22.0.4
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.22.0.2
	OPENBSD_2_4_BASE:1.22
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.16.0.2
	OPENBSD_2_2_BASE:1.16;
locks; strict;
comment	@ * @;


1.44
date	2017.06.19.22.50.50;	author deraadt;	state Exp;
branches;
next	1.43;
commitid	qxUetDs8y9dCgVHx;

1.43
date	2014.02.19.22.02.15;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2014.01.24.23.32.15;	author deraadt;	state Exp;
branches;
next	1.41;

1.41
date	2014.01.24.05.24.07;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2014.01.24.04.52.59;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2014.01.02.00.03.04;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2013.12.28.02.51.07;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2011.04.17.09.49.48;	author kettenis;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.26.10.34.41;	author tom;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.24.14.58.12;	author tom;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.13.02.17.32;	author drahn;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.29.00.03.13;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.06.24.22.32.26;	author tom;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.24.17.10.17;	author tom;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.29.00.54.08;	author tom;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.11.06.23.07;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.02.20.22.44;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.01.17.00.26;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.19.08.18.25;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.17.12.09.48;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.17.12.06.05;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.29.19.24.44;	author mickey;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	98.07.08.19.24.52;	author mickey;	state Exp;
branches
	1.22.8.1;
next	1.21;

1.21
date	98.05.30.05.45.24;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.05.30.01.44.17;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	98.05.25.19.17.36;	author mickey;	state Exp;
branches;
next	1.18;

1.18
date	98.05.14.14.39.11;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	98.02.24.22.16.02;	author weingart;	state Exp;
branches;
next	1.16;

1.16
date	97.09.02.21.37.38;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	97.08.22.00.41.27;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	97.08.21.22.04.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	97.08.13.04.35.42;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	97.08.06.18.45.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	97.07.21.15.36.17;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	97.07.18.00.52.08;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	97.05.31.15.48.24;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	97.04.26.17.50.07;	author mickey;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	97.04.21.20.03.30;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	97.04.14.10.48.04;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	97.04.05.23.27.35;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	97.04.04.04.47.45;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	97.03.31.23.06.20;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	97.03.31.03.12.03;	author weingart;	state Exp;
branches;
next	1.1;

1.1
date	96.12.03.13.16.57;	author mickey;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	96.12.03.13.16.58;	author mickey;	state Exp;
branches;
next	;

1.8.2.1
date	97.06.01.09.53.04;	author deraadt;	state Exp;
branches;
next	;

1.22.8.1
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.22.8.2;

1.22.8.2
date	2003.05.13.19.36.57;	author ho;	state Exp;
branches;
next	1.22.8.3;

1.22.8.3
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.22.8.4;

1.22.8.4
date	2004.02.19.11.01.32;	author niklas;	state Exp;
branches;
next	;

1.23.6.1
date	2003.05.19.22.28.04;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.44
log
@As early as possible, create a link /bsd.booted to the /bsd kernel we
presume we booted from.  If you boot from another kernel, we cannot help
you later with hibernate, sorry -- The kernel does not get a useable
filename from the bootblocks.

In the bootblocks, detect a live hibernate signature and boot from
/bsd.booted instead.

with yasuoka, lots of discussion with mlarkin, ok tom
@
text
@/*	$OpenBSD: boot.c,v 1.43 2014/02/19 22:02:15 miod Exp $	*/

/*
 * Copyright (c) 2003 Dale Rahn
 * Copyright (c) 1997,1998 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <libsa.h>
#include <lib/libsa/loadfile.h>
#include <lib/libkern/funcs.h>

#include <stand/boot/bootarg.h>

#include "cmd.h"

#ifndef KERNEL
#define KERNEL "/bsd"
#endif

char prog_ident[40];
char *progname = "BOOT";

extern	const char version[];
struct cmd_state cmd;

/* bootprompt can be set by MD code to avoid prompt first time round */
int bootprompt = 1;
char *kernelfile = KERNEL;		/* can be changed by MD code */
int boottimeout = 5;			/* can be changed by MD code */

char	rnddata[BOOTRANDOM_MAX];

void
boot(dev_t bootdev)
{
	int fd;
	int try = 0, st;
	u_long marks[MARK_MAX];

	machdep();

	snprintf(prog_ident, sizeof(prog_ident),
	    ">> OpenBSD/" MACHINE " %s %s", progname, version);
	printf("%s\n", prog_ident);

	devboot(bootdev, cmd.bootdev);
	strlcpy(cmd.image, kernelfile, sizeof(cmd.image));
	cmd.boothowto = 0;
	cmd.conf = "/etc/boot.conf";
	cmd.addr = (void *)DEFAULT_KERNEL_ADDRESS;
	cmd.timeout = boottimeout;

	st = read_conf();

#ifdef HIBERNATE
	int bootdev_has_hibernate(void);

	if (bootdev_has_hibernate()) {
		strlcpy(cmd.image, "/bsd.booted", sizeof(cmd.image));
		printf("unhibernate detected: switching to %s\n", cmd.image);
	}
#endif

	if (!bootprompt)
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, cmd.image);

	while (1) {
		/* no boot.conf, or no boot cmd in there */
		if (bootprompt && st <= 0) {
			do {
				printf("boot> ");
			} while(!getcmd());
		}

		loadrandom(BOOTRANDOM, rnddata, sizeof(rnddata));
#ifdef MDRANDOM
		mdrandom(rnddata, sizeof(rnddata));
#endif

		st = 0;
		bootprompt = 1;	/* allow reselect should we fail */

		printf("booting %s: ", cmd.path);
		marks[MARK_START] = (u_long)cmd.addr;
		if ((fd = loadfile(cmd.path, marks, LOAD_ALL)) != -1) {
			close(fd);
			break;
		}

		kernelfile = KERNEL;
		try++;
		strlcpy(cmd.image, kernelfile, sizeof(cmd.image));
		printf(" failed(%d). will try %s\n", errno, kernelfile);

		if (try < 2) {
			if (cmd.timeout > 0)
				cmd.timeout++;
		} else {
			if (cmd.timeout)
				printf("Turning timeout off.\n");
			cmd.timeout = 0;
		}
	}

	/* exec */
	run_loadfile(marks, cmd.boothowto);
}

void
loadrandom(char *name, char *buf, size_t buflen)
{
	char path[MAXPATHLEN];
	struct stat sb;
	int fd, i;

#define O_RDONLY	0

	/* Extract the device name from the kernel we are loading. */
	for (i = 0; i < sizeof(cmd.path); i++) {
		if (cmd.path[i] == ':') {
			strlcpy(path, cmd.path, i + 1);
			snprintf(path + i, sizeof(path) - i, ":%s", name);
			break;
		} else if (cmd.path[i] == '\0') {
			snprintf(path, sizeof path, "%s:%s",
			    cmd.bootdev, name);
			break;
		}
	}

	fd = open(path, O_RDONLY);
	if (fd == -1) {
		if (errno != EPERM)
			printf("cannot open %s: %s\n", path, strerror(errno));
		return;
	}
	if (fstat(fd, &sb) == -1 ||
	    sb.st_uid != 0 ||
	    (sb.st_mode & (S_IWOTH|S_IROTH)))
		goto fail;
	(void) read(fd, buf, buflen);
fail:
	close(fd);
}
@


1.43
log
@Don't try to close(-1) if EPERM.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.42 2014/01/24 23:32:15 deraadt Exp $	*/
d80 10
@


1.42
log
@OK, loadrandom should not care about EPERM I suppose
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.41 2014/01/24 05:24:07 deraadt Exp $	*/
d150 2
a151 3
		if (errno == EPERM)
			goto fail;
		printf("cannot open %s: %s\n", path, strerror(errno));
@


1.41
log
@remove irrelevant error handling in loadrandom; this operates on the
principe of fire and forget, and we really want developers to start
trying to write per-architecture XOR thingies using timers and such
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.40 2014/01/24 04:52:59 deraadt Exp $	*/
d150 2
@


1.40
log
@Only report about random seed failures, not attempts.
Discussed with jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.39 2014/01/02 00:03:04 deraadt Exp $	*/
d92 1
a92 3
		st = loadrandom(BOOTRANDOM, rnddata, sizeof(rnddata));
		if (st)
			printf("loadrandom: error %d\n", st);
d126 1
a126 1
int
a149 2
		if (errno == ENXIO || errno == ENOENT)
			return -1;
d151 1
a151 1
		return -1;
d157 1
a157 4
	if (read(fd, buf, buflen) != buflen)
		goto fail;
	close(fd);
 	return 0;
a159 1
	return (-1);
@


1.39
log
@loadrandom() status should be ignored, so that we do not loop.
issue reported by halex
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.38 2013/12/28 02:51:07 deraadt Exp $	*/
a149 2
	printf("loadrandom: %s\n", path);

d152 3
a154 1
		printf("cannot open %s\n", path);
@


1.38
log
@Try to load entropy data from disk:/etc/random.seed, and additionally
use a MD-supplied random function.  Then, insert this into the ELF
openbsd.randomdata of the kernel, so that it has entropy right from
the start.  Some help from jsing for the softraid aspects.
Also tested by phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.37 2011/04/17 09:49:48 kettenis Exp $	*/
a90 2
		st = 0;
		bootprompt = 1;	/* allow reselect should we fail */
d93 1
a93 1
		if (st != 0)
d98 3
@


1.37
log
@Tweak the behaviour of boot(8) on hppa.  Normal boots now will give you a
chance to interrupt the boot procedure before booting the default kernel,
just like (most) of our other hardware platforms.  Interactive boots, where
you interrupt the firmware boot procedure and answer "Y" to the
"Interact with IPL?" question will now wait for human intervention at the
boot> prompt (without a timeout).  Should reduce frustration when trying to
boot an alternative kernel.

ok deraadt@@, miod@@, jsing@@, todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.36 2007/06/26 10:34:41 tom Exp $	*/
d38 2
d57 2
d86 1
a86 1
		if (bootprompt && st <= 0)
d90 1
d94 7
a126 1
#ifdef _TEST
d128 1
a128 1
main()
d130 37
a166 2
	boot(0);
	return 0;
a167 1
#endif
@


1.36
log
@loadfile() returns an open file descriptor on successful exit, so
close it before going off to execute the newly-loaded kernel.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.35 2007/06/24 14:58:12 tom Exp $	*/
d53 1
d73 1
a73 1
	cmd.timeout = 5;
@


1.35
log
@When bootfile was made global so that macppc could modify it, it
clashed with a global variable already used by the bootblocks.
Therefore rename bootfile here to kernelfile.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.34 2007/06/13 02:17:32 drahn Exp $	*/
d57 1
d90 2
a91 1
		if (loadfile(cmd.path, marks, LOAD_ALL) >= 0)
d93 1
@


1.34
log
@Switch macppc to the interactive bootloader in stand/boot.
Much more useable on serial console systems.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.33 2007/05/29 00:03:13 deraadt Exp $	*/
d52 1
a52 1
const char *bootfile = KERNEL;
d67 1
a67 1
	strlcpy(cmd.image, bootfile, sizeof(cmd.image));
d92 1
a92 1
		bootfile = KERNEL;
d94 2
a95 2
		strlcpy(cmd.image, bootfile, sizeof(cmd.image));
		printf(" failed(%d). will try %s\n", errno, bootfile);
@


1.33
log
@remove support for many alternative kernel choices -- only try /bsd and
not the other stupid names.  that feature was retarded.  tested on a few
architectures by a few people
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.32 2004/06/24 22:32:26 tom Exp $	*/
d52 1
a56 1
	const char *bootfile = KERNEL;
@


1.32
log
@Turn off timeouts if the user types anything at all.  This prevents an
automatic boot in 5 seconds after you type "set tty com0", for example.

"I like this" deraadt@@, "oh! yes" henning@@, ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.31 2004/06/24 17:10:17 tom Exp $	*/
d40 3
a42 6
static const char *const kernels[] = {
	"/bsd",
	"/obsd",
	"/bsd.old",
	NULL
};
d56 2
a57 2
	const char *bootfile = kernels[0];
	int i = 0, try = 0, st;
d92 2
a93 5
		if (kernels[++i] == NULL) {
			try += 1;
			bootfile = kernels[i=0];
		} else
			bootfile = kernels[i];
@


1.31
log
@Add comment explaining what "bootprompt" is for
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.30 2004/01/29 00:54:08 tom Exp $	*/
d103 4
a106 3
		if (try < 2)
			cmd.timeout++;
		else {
@


1.30
log
@Allow the machine-dependent part of BOOT to change the program name.

ok weingart@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.28 2003/06/02 20:22:44 mickey Exp $	*/
d52 2
@


1.29
log
@ansification and knf and protos
@
text
@d47 3
d63 3
a65 1
	printf(">> OpenBSD/" MACHINE " BOOT %s\n", version);
@


1.28
log
@three four kill ... dale agrees on this one as he holds a kprite on it too
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.27 2003/06/01 17:00:26 deraadt Exp $	*/
d52 1
a52 2
boot(bootdev)
	dev_t	bootdev;
d54 2
a55 2
	register const char *bootfile = kernels[0];
	register int i = 0, try = 0, st;
@


1.27
log
@strcpy/strcat/sprintf removal in all bootblocks.  various testing by
various people.  outside of some messy things in src/gnu, only one
thing in the main tree now violates this rule: bind
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.26 2003/05/19 08:18:25 mickey Exp $	*/
a15 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.26
log
@allow md part to skip the interactive part (the first try around)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.25 2003/04/17 12:09:48 mickey Exp $	*/
d22 2
a23 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
d41 1
a44 1

d69 1
a69 1
	strncpy(cmd.image, bootfile, sizeof(cmd.image));
d77 2
a78 1
		sprintf(cmd.path, "%s:%s", cmd.bootdev, cmd.image);
d99 1
a99 1
		strncpy(cmd.image, bootfile, sizeof(cmd.image));
@


1.25
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.24 2003/04/17 12:06:05 mickey Exp $	*/
d54 1
d76 2
d80 2
a81 1
		if (st <= 0) /* no boot.conf, or no boot cmd in there */
d86 1
@


1.24
log
@there is no reason to keep both around. just rename
@
text
@d1 1
a1 1
/*	$OpenBSD: boot_loadfile.c,v 1.1 2003/04/17 03:53:53 drahn Exp $	*/
d84 1
a84 1
		marks[MARK_START] = cmd.addr;
@


1.23
log
@OpenBSD/machine banner, not machine_arch
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22 1998/07/08 19:24:52 mickey Exp $	*/
d4 1
d40 2
d44 1
d61 1
d84 3
a86 1
		exec(cmd.path, cmd.addr, cmd.boothowto);
d104 3
@


1.23.6.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a3 1
 * Copyright (c) 2003 Dale Rahn
a38 2
#include <lib/libsa/loadfile.h>

a40 1

a56 1
	u_long marks[MARK_MAX];
d79 1
a79 3
		marks[MARK_START] = (u_long)cmd.addr;
		if (loadfile(cmd.path, marks, LOAD_ALL) >= 0)
			break;
a96 3

	/* exec */
	run_loadfile(marks, cmd.boothowto);
@


1.22
log
@use KERNEL_DEFAULT_ADDRESS from MD libsa.h for default kernel load address
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.21 1998/05/30 05:45:24 deraadt Exp $	*/
d60 1
a60 1
	printf(">> OpenBSD/" MACHINE_ARCH " BOOT %s\n", version);
@


1.22.8.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.23 2000/12/29 19:24:44 mickey Exp $	*/
d60 1
a60 1
	printf(">> OpenBSD/" MACHINE " BOOT %s\n", version);
@


1.22.8.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22.8.1 2001/05/14 22:45:00 niklas Exp $	*/
a3 1
 * Copyright (c) 2003 Dale Rahn
a38 2
#include <lib/libsa/loadfile.h>

a40 1

a56 1
	u_long marks[MARK_MAX];
d79 1
a79 3
		marks[MARK_START] = (u_long)cmd.addr;
		if (loadfile(cmd.path, marks, LOAD_ALL) >= 0)
			break;
a96 3

	/* exec */
	run_loadfile(marks, cmd.boothowto);
@


1.22.8.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.22.8.2 2003/05/13 19:36:57 ho Exp $	*/
d16 5
d22 2
a23 2
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
a40 1
#include <lib/libkern/funcs.h>
d44 1
a53 1
int bootprompt = 1;
d68 1
a68 1
	strlcpy(cmd.image, bootfile, sizeof(cmd.image));
a74 3
	if (!bootprompt)
		snprintf(cmd.path, sizeof cmd.path, "%s:%s",
		    cmd.bootdev, cmd.image);
d77 1
a77 2
		/* no boot.conf, or no boot cmd in there */
		if (bootprompt && st <= 0)
a81 1
		bootprompt = 1;	/* allow reselect should we fail */
d93 1
a93 1
		strlcpy(cmd.image, bootfile, sizeof(cmd.image));
@


1.22.8.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a46 3
char prog_ident[40];
char *progname = "BOOT";

d52 2
a53 1
boot(dev_t bootdev)
d55 2
a56 2
	const char *bootfile = kernels[0];
	int i = 0, try = 0, st;
d61 1
a61 3
	snprintf(prog_ident, sizeof(prog_ident),
	    ">> OpenBSD/" MACHINE " %s %s", progname, version);
	printf("%s\n", prog_ident);
@


1.21
log
@save space
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.20 1998/05/30 01:44:17 mickey Exp $	*/
d66 1
a66 1
	cmd.addr = (void *)0x100000;
@


1.20
log
@add bsd.old, bsd.old.gz kernels.
print boot label earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.19 1998/05/25 19:17:36 mickey Exp $	*/
d42 3
a44 3
	"/bsd",  "/bsd.gz",
	"/obsd", "/obsd.gz",
	"/bsd.old", "/bsd.old.gz",
@


1.19
log
@make a new file for variable manipulation code; add environment support
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.18 1998/05/14 14:39:11 mickey Exp $	*/
d41 1
a41 1
const char *const kernels[] = {
d44 1
d60 2
a69 2

	printf(">> OpenBSD/" MACHINE_ARCH " BOOT %s\n", version);
@


1.18
log
@nicer boot message
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.17 1998/02/24 22:16:02 weingart Exp $	*/
d4 1
a4 1
 * Copyright (c) 1997 Michael Shalayeff
@


1.17
log
@Various fixes (timeout, uninited vars), as well as some semantics
improvements.  Needs another overhaul still though...
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.16 1997/09/02 21:37:38 mickey Exp $	*/
d68 1
a68 1
	printf(">> OpenBSD BOOT %s\n", version);
@


1.16
log
@dead vars
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.15 1997/08/22 00:41:27 mickey Exp $	*/
d55 1
a55 1
	register int i = 0, f;
d66 1
a66 1
	f = read_conf();
d71 1
a71 1
		if (f <= 0) /* no boot.conf, or no boot cmd in there */
d75 1
a75 1
		f = 0;
d80 2
a81 1
		if (kernels[++i] == NULL)
d83 1
a83 1
		else
d85 2
d88 7
a94 3
		cmd.timeout++;
		printf(" failed(%d). will try %s\n", errno, bootfile);
		strncpy(cmd.image, bootfile, sizeof(cmd.image));
@


1.15
log
@theo said we don't need 'cd' command
remove c-r, it won't work anyways
fix c-u
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.14 1997/08/21 22:04:31 mickey Exp $	*/
a47 1
u_int	cnvmem, extmem;
@


1.14
log
@boothowto is local to boot
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.13 1997/08/13 04:35:42 mickey Exp $	*/
d42 2
a43 2
	"bsd",	"bsd.gz",
	"obsd",	"obsd.gz",
a63 1
	cmd.cwd[0] = '/'; cmd.cwd[1] = '\0';
@


1.13
log
@print boot message on the right console
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.12 1997/08/06 18:45:01 mickey Exp $	*/
a47 1
int	boothowto;
d60 1
d62 1
a66 1
	devboot(bootdev, cmd.bootdev);
d70 1
a70 1
	printf(">> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);
d80 1
a80 1
		exec(cmd.path, cmd.addr, boothowto);
@


1.12
log
@cmd is global anyways, don't pass it to handlers
add echo command
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.11 1997/07/21 15:36:17 mickey Exp $	*/
a60 2
	printf(">> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);

d69 3
@


1.11
log
@indent (;
supply fake arg for boot() in testing main()
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.10 1997/07/18 00:52:08 mickey Exp $	*/
d70 1
a70 1
	f = read_conf(&cmd);
d75 1
a75 1
			} while(!getcmd(&cmd));
@


1.10
log
@most of the stuff is no in libsa, very tiny srt0
boot calls machdep()
move to .bss again (;
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 1997/05/31 15:48:24 mickey Exp $	*/
d68 1
a69 1
	devboot(bootdev, cmd.bootdev);
d96 1
a96 1
	boot();
@


1.9
log
@usleep won't work on some weird laptops
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.8 1997/04/26 17:50:07 mickey Exp $	*/
a38 1
#include <debug.h>
d41 1
a41 1
char *kernels[] = {
d50 1
a50 3
struct cmd_state cmd = {
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 5, ""
};
d56 1
a56 1
	register char *bootfile = kernels[0];
d59 1
a59 12
#ifdef DEBUG
	*(u_int16_t*)0xb8148 = 0x4730;
#endif
	gateA20(1);
	cons_probe();	/* call console init before any io */
#ifndef _TEST
	memprobe();
#endif
#ifdef DEBUG
	*(u_int16_t*)0xb8148 = 0x4f31;
#endif
	debug_init();
d62 6
@


1.8
log
@boot.conf support
ttyname function in cons.c
rdonly var 'tty' to view tty settings
serial console soon
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.7 1997/04/21 20:03:30 mickey Exp $	*/
d52 1
a52 1
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 50, ""
d94 1
a94 1
		cmd.timeout += 20;
@


1.8.2.1
log
@2.1 laptop kbd fixes from mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.9 1997/05/31 15:48:24 mickey Exp $	*/
d52 1
a52 1
	"", "bsd", "/etc/boot.conf", "/", (void *)0x100000, 5, ""
d94 1
a94 1
		cmd.timeout++;
@


1.7
log
@rewrite command processing.
two levels of commands from now (set has it's own {device,image,addr,howto})
all the combinations of {device,path,image,options} is now possible on boot.
move cmd_state init into .data again, no more memory limits
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.6 1997/04/14 10:48:04 deraadt Exp $	*/
d52 1
a52 1
	"", "", "/", (void *)0x100000, 50, ""
d60 1
a60 1
	register int i = 0;
d66 1
a72 1
	cons_probe();
d78 1
d80 5
a84 5
		strncpy(cmd.image, bootfile, sizeof(cmd.image));

		do {
			printf("boot> ");
		} while(!getcmd(&cmd));
d96 1
@


1.6
log
@kill extra linefeeding
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.5 1997/04/05 23:27:35 mickey Exp $	*/
d51 3
a59 1
	register struct cmd_state *cmd;
d77 1
a77 9
	/* XXX init cmd here to cut on .data !!! */
	cmd = (struct cmd_state *)alloc(sizeof(*cmd));
	devboot(bootdev, cmd->bootdev);
	cmd->image[0] = '\0';
	cmd->cwd[0] = '/';
	cmd->cwd[1] = '\0';
	cmd->addr = (void *)0x100000;
	cmd->timeout = 50;

d79 1
a79 1
		strncpy(cmd->image, bootfile, sizeof(cmd->image));
d83 1
a83 4
		} while(!getcmd(cmd) && !execmd(cmd));

		if (cmd->rc < 0)
			break;
d85 2
a86 2
		printf("booting %s: ", cmd->path);
		exec(cmd->path, cmd->addr, boothowto);
d93 1
a93 1
		cmd->timeout += 20;
@


1.5
log
@devboot is no longer in boot.c
missed from last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.4 1997/04/04 04:47:45 mickey Exp $	*/
d42 5
a46 4
char *kernels[] = { "bsd",     "bsd.gz",
		    "obsd",    "obsd.gz",
		    "bsd.old", "bsd.old.gz",
		  NULL };
d58 1
a58 1
	register int i;
d73 1
a73 1
	printf("\n>> OpenBSD BOOT: %u/%u k [%s]\n", cnvmem, extmem, version);
d84 1
a84 2
	for (i = 0;;) {

d94 2
a95 2
		printf("\nbooting %s: ", cmd->path);
		exec (cmd->path, cmd->addr, boothowto);
d97 1
a97 1
		if(kernels[++i] == NULL)
d103 1
a103 2

		printf(" failed(%d)\nwill try %s\n", errno, bootfile);
@


1.4
log
@dump regs w/ NMI (int 2)
more debugging is on the way
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.3 1997/03/31 23:06:20 mickey Exp $	*/
a50 2
void	devboot __P((dev_t, char *));

a105 32
}

void
devboot(bootdev, p)
	dev_t bootdev;
	char *p;
{
#ifdef _TEST
	*p++ = '/';
	*p++ = 'd';
	*p++ = 'e';
	*p++ = 'v';
	*p++ = '/';
	*p++ = 'r';
#endif
	if (bootdev & 0x80)
		*p++ = 'h';
	else
		*p++ = 'f';
	*p++ = 'd';
#ifndef _TEST
	*p++ = '(';
#endif
	*p++ = '0' + (bootdev & 0x7f);
#ifndef _TEST
	*p++ = ',';
#endif
	*p++ = 'a';
#ifndef _TEST
	*p++ = ')';
#endif
	*p = '\0';
@


1.3
log
@commit all my mods to the last imported libsa stuff....
including:
- disklabel support;
- better boot cmd line
- smaller size (using some compilation switches ;)
- no more relocations in /boot, it's loaded in the place;
- better disk performance (maybe were already in there)
- installboot -n does not require write perms for device
- more debugs
- missing parts in libsa (such as cd9660 and so)
- i don't like 2 files for exec_i386 (sorry, toby, let's discuss maybe?)
tricks and tails:
- joined .text and .data (saves you a page)
- prot mode switching still in biosboot (it's freezed for awhile)
- biosdisk internals changed
- biosdev is not passed propery to the kernel (i'll fix it soon)
- sure i missed smth here to note (use the source, Luke!)
@
text
@d1 1
a1 1
/*	$OpenBSD: boot.c,v 1.1.2.1 1996/12/03 13:16:58 mickey Exp $	*/
d39 1
d72 1
@


1.2
log
@Initial /boot stuff (from Mickey)
@
text
@d2 1
a37 2
#include <a.out.h>
#include <sys/disklabel.h>
d41 8
a48 19
/*
 * Boot program, loaded by boot block from remaing 7.5K of boot area.
 * Sifts through disklabel and attempts to load an program image of
 * a standalone program off the disk. If keyboard is hit during load,
 * or if an error is encounter, try alternate files.
 */

char *kernels[] = {
	"bsd", "bsd.gz",
	"obsd", "obsd.gz",
	"bsd.old", "bsd.old.gz",
	NULL
};

int	retry = 0;
extern	char version[];
extern dev_t bootdev;
extern int boothowto;
int	cnvmem, extmem, probemem;
d50 1
a50 2
void	boot ();
struct cmd_state cmd;
a51 4
/*
 * Boot program... loads /boot out of filesystem indicated by arguements.
 * We assume an autoboot unless we detect a misconfiguration.
 */
d53 2
a54 1
boot()
d57 1
d60 3
a62 4

	/* Get memory size */
	cnvmem = memsize(0);
	extmem = memsize(1);
d64 7
a70 1
	probemem = memprobe();
d72 1
d75 7
a81 15
	strncpy(cmd.bootdev,
#ifdef _TEST
		"/dev/rfd0a",
#else
		"fd(0,a)",
#endif
		sizeof(cmd.bootdev));
	cmd.image[0] = '\0';
	cmd.cwd[0] = '/';
	cmd.cwd[1] = '\0';
	cmd.addr = (void *)0x100000;
	cmd.timeout = 50000;

	printf("\n>> OpenBSD BOOT: %d/%d (%d) k [%s]\n",
		cnvmem, extmem, probemem, version);
d85 1
a85 1
		strncpy(cmd.image, bootfile, sizeof(cmd.image));
d89 4
a92 1
		} while(!getcmd(&cmd) && !execmd(&cmd));
d94 2
a95 3
		sprintf(cmd.path, "%s%s%s", cmd.bootdev, cmd.cwd, bootfile);
		printf("\nbooting %s: ", cmd.path);
		exec (cmd.path, cmd.addr, boothowto);
d102 1
a102 1
		cmd.timeout += 20;
d106 32
@


1.1
log
@file boot.c was initially added on branch new.
@
text
@d1 130
@


1.1.2.1
log
@new hierarchy. raw /boot loading, just 1(one) boot stage.
@
text
@a0 203
/*	$OpenBSD: boot.c,v 1.3.4.3 1996/10/29 09:15:46 mickey Exp $	*/
/*	$NetBSD: boot.c,v 1.6 1994/10/27 04:21:49 cgd Exp $	*/

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifdef lint
char copyright[] =
"@@(#) Copyright (c) 1990 The Regents of the University of California.\n\
 All rights reserved.\n";
#endif /* not lint */

#ifdef lint
#ifdef notdef
static char sccsid[] = "@@(#)boot.c	7.3 (Berkeley) 5/4/91";
#endif
static char rcsid[] = "$NetBSD: boot.c,v 1.6 1994/10/27 04:21:49 cgd Exp $";
#endif /* not lint */

#include <sys/param.h>
#include <sys/reboot.h>
#include <sys/stat.h>
#include <a.out.h>
#include <sys/disklabel.h>
#include <libsa.h>

/*
 * Boot program, loaded by boot block from remaing 7.5K of boot area.
 * Sifts through disklabel and attempts to load an program image of
 * a standalone program off the disk. If keyboard is hit during load,
 * or if an error is encounter, try alternate files.
 */

char *kernels[] = { "bsd.z", "obsd.z", "bsd.old.z",
		  "bsd", "obsd", "bsd.old",
		  NULL };

int	retry = 0;
extern struct disklabel disklabel;
extern	char version[];
static unsigned char *biosparams = (char *) 0x9ff00; /* XXX */
int	cnvmem, extmem;

#ifndef HZ
#define HZ 100
#endif
int	hz = HZ;

void	copyunix (char*, int, long);
void	wait (int);

struct disklabel disklabel;

/*
 * Boot program... loads /boot out of filesystem indicated by arguements.
 * We assume an autoboot unless we detect a misconfiguration.
 */
void
boot(dev, unit, off)
{
	register struct disklabel *lp;
	register int io;
	register char **bootfile = kernels;
	int howto = 0;

	*((int *)0xb8004) = 0xa55a5aa5;
	asm("hlt");

	/* init system clock */
	/* startrtclock(); */

#ifdef	DEBUG
	printf("cyl %x %x hd %x sect %x ",
		biosparams[0], biosparams[1], biosparams[2], biosparams[0xe]);
	printf("dev %x unit %x off %d\n", dev, unit, off);
#endif

	/* are we a disk, if so look at disklabel and do things */
	lp = &disklabel;

	printf("\n"
		">> OpenBSD BOOT: %d/%d k [%s]\n"
		"use ? for file list, or carriage return for defaults\n"
		"use hd(1,a)/bsd to boot sd0 when wd0 is also installed\n",
		cnvmem, extmem, version);

	asm("hlt");

	if (lp->d_magic == DISKMAGIC) {
	    /*
	     * Synthesize bootdev from dev, unit, type and partition
	     * information from the block 0 bootstrap.
	     * It's dirty work, but someone's got to do it.
	     * This will be used by the filesystem primatives, and
	     * drivers. Ultimately, opendev will be created corresponding
	     * to which drive to pass to top level bootstrap.
	     */
	    for (io = 0; io < lp->d_npartitions; io++) {
		int sn;

		if (lp->d_partitions[io].p_size == 0)
			continue;
		if (lp->d_type == DTYPE_SCSI)
			sn = off;
		else
			sn = off * lp->d_secpercyl;
		if (lp->d_partitions[io].p_offset == sn)
			break;
	    }

	    if (io == lp->d_npartitions) goto screwed;
            cyloffset = off;
	} else {
screwed:
		/* probably a bad or non-existant disklabel */
		io = 0 ;
		howto |= RB_SINGLE|RB_ASKNAME ;
	}

	/* construct bootdev */
	/* currently, PC has no way of booting off alternate controllers */
	bootdev = MAKEBOOTDEV(/*i_dev*/ dev, /*i_adapt*/0, /*i_ctlr*/0,
	    unit, /*i_part*/io);

	for (;;) {

		copyunix(*bootfile, howto, off);

		if(*++bootfile == NULL) bootfile = kernels;
		printf("will try %s\n", *bootfile);

		wait(1<<((retry++) + 10));
	}
}

/*ARGSUSED*/
void
copyunix(name, howto, off)
	char	*name;
	int	howto;
	long	off;
{
	int	f;
	struct stat sb;
	char	*addr = NULL, *loadaddr;

	printf("loading %s: ", name);

	/* read file */
	if (stat(name, &sb) < 0)
		return;

	if ((f = open(name, 1)) < 0)
		return;

	/* exec */
	execz(addr, loadaddr, 0);

	return;
}

int
zread(f, loadaddr, size)
	int	f;
	void	*loadaddr;
	size_t	size;
{

	return -1;
}
@

