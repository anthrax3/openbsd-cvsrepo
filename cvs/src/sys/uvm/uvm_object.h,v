head	1.22;
access;
symbols
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.21.0.10
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.6
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.8
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.2
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.4
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.8
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.6
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.4
	OPENBSD_5_0:1.18.0.2
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.16.0.2
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.10.0.8
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.6
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.4
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.2
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.9.0.8
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.6
	OPENBSD_4_0_BASE:1.9
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.8.0.14
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.2
	UBC_BASE:1.7
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.22
date	2016.09.16.02.35.42;	author dlg;	state Exp;
branches;
next	1.21;
commitid	Fei4687v68qad1tP;

1.21
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.20;
commitid	7NtJNW9udCOFtDNM;

1.20
date	2014.05.08.20.08.50;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2013.05.30.15.17.59;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2011.07.07.14.25.15;	author sobrado;	state Exp;
branches;
next	1.17;

1.17
date	2010.04.30.21.56.39;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2009.11.25.19.11.38;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2009.08.06.15.28.14;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.17.00.13.59;	author oga;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.16.00.11.29;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.06.03.45.08;	author oga;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.02.23.00.19;	author oga;	state Exp;
branches;
next	1.10;

1.10
date	2007.04.11.12.10.42;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.26.07.11.55;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.28.19.28.15;	author art;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.11.12.01.26.09;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.47;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.22.11.04;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.24;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.16;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.50;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2002.02.02.03.28.27;	author art;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2004.02.21.00.20.22;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.22
log
@move the vm_page struct from being stored in RB macro trees to RBT functions

vm_page structs go into three trees, uvm_objtree, uvm_pmr_addr, and
uvm_pmr_size. all these have been moved to RBT code.

this should give us a decent chunk of code space back.
@
text
@/*	$OpenBSD: uvm_object.h,v 1.21 2014/07/11 16:35:40 jsg Exp $	*/
/*	$NetBSD: uvm_object.h,v 1.11 2001/03/09 01:02:12 chs Exp $	*/

/*
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_object.h,v 1.1.2.2 1998/01/04 22:44:51 chuck Exp
 */

#ifndef _UVM_UVM_OBJECT_H_
#define _UVM_UVM_OBJECT_H_

/*
 * uvm_object.h
 */

/*
 * uvm_object: all that is left of mach objects.
 */

struct uvm_object {
	struct uvm_pagerops		*pgops;		/* pager ops */
	RBT_HEAD(uvm_objtree, vm_page)	 memt;		/* pages in object */
	int				 uo_npages;	/* # of pages in memt */
	int				 uo_refs;	/* reference count */
};

/*
 * UVM_OBJ_KERN is a 'special' uo_refs value which indicates that the
 * object is a kernel memory object rather than a normal one (kernel
 * memory objects don't have reference counts -- they never die).
 *
 * this value is used to detected kernel object mappings at uvm_unmap()
 * time.  normally when an object is unmapped its pages eventually become
 * deactivated and then paged out and/or freed.  this is not useful
 * for kernel objects... when a kernel object is unmapped we always want
 * to free the resources associated with the mapping.  UVM_OBJ_KERN
 * allows us to decide which type of unmapping we want to do.
 *
 * in addition, we have kernel objects which may be used in an
 * interrupt context.  these objects get their mappings entered
 * with pmap_kenter*() and removed with pmap_kremove(), which
 * are safe to call in interrupt context, and must be used ONLY
 * for wired kernel mappings in these objects and their associated
 * maps.
 */
#define UVM_OBJ_KERN		(-2)

#define	UVM_OBJ_IS_KERN_OBJECT(uobj)					\
	((uobj)->uo_refs == UVM_OBJ_KERN)

#ifdef _KERNEL

extern struct uvm_pagerops uvm_vnodeops;
extern struct uvm_pagerops uvm_deviceops;

/* For object trees */
int	uvm_pagecmp(const struct vm_page *, const struct vm_page *);
RBT_PROTOTYPE(uvm_objtree, vm_page, objt, uvm_pagecmp)

#define	UVM_OBJ_IS_VNODE(uobj)						\
	((uobj)->pgops == &uvm_vnodeops)

#define UVM_OBJ_IS_DEVICE(uobj)						\
	((uobj)->pgops == &uvm_deviceops)

#define	UVM_OBJ_IS_VTEXT(uobj)						\
	((uobj)->pgops == &uvm_vnodeops &&				\
	 ((struct vnode *)uobj)->v_flag & VTEXT)

void	uvm_objinit(struct uvm_object *, struct uvm_pagerops *, int);
int	uvm_objwire(struct uvm_object *, voff_t, voff_t, struct pglist *);
void	uvm_objunwire(struct uvm_object *, voff_t, voff_t);

#endif /* _KERNEL */

#endif /* _UVM_UVM_OBJECT_H_ */
@


1.21
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.20 2014/05/08 20:08:50 kettenis Exp $	*/
d44 1
a44 1
	RB_HEAD(uvm_objtree, vm_page)	 memt;		/* pages in object */
d79 2
a80 2
int	uvm_pagecmp(struct vm_page *, struct vm_page *);
RB_PROTOTYPE(uvm_objtree, vm_page, objt, uvm_pagecmp)
@


1.20
log
@Fix some potential integer overflows caused by converting a page number into
an offset/size/address by shifting by PAGE_SHIFT.  Make uvm_objwrire/unwire
use voff_t instead of off_t.  The former is the right type here even if it is
equivalent to the latter.

Inspired by a somewhat similar changes in Bitrig.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.19 2013/05/30 15:17:59 tedu Exp $	*/
a4 1
 *
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.19
log
@remove simple_locks from uvm code. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.18 2011/07/07 14:25:15 sobrado Exp $	*/
d100 2
a101 2
int	uvm_objwire(struct uvm_object *, off_t, off_t, struct pglist *);
void	uvm_objunwire(struct uvm_object *, off_t, off_t);
@


1.18
log
@fix typos; while here, improve spacing in comments.

changes to libevent and zlib headers sent to the upstream maintainers.

ok jmc@@ (for typos), millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.17 2010/04/30 21:56:39 oga Exp $	*/
a49 1
	simple_lock_data_t		 vmobjlock;	/* lock on memt */
@


1.17
log
@Right now, if anything internal changes with a uvm object, diverse
places in the tree need to be touched to update the object
initialisation with respect to that.

So, make a function (uvm_initobj) that takes the refcount, object and
pager ops and does this initialisation for us. This should save on
maintainance in the future.

looked good to fgs@@. Tedu complained about the British spelling but OKed
it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.16 2009/11/25 19:11:38 oga Exp $	*/
d63 2
a64 2
 * time.   normally when an object is unmapped its pages eventaully become
 * deactivated and then paged out and/or freed.    this is not useful
d66 1
a66 1
 * to free the resources associated with the mapping.   UVM_OBJ_KERN
@


1.16
log
@re-add uvm_objwire and uvm_objunwire. needed for intel GEM support.

It was backed out as part of the date-based revert after c2k9.

"you can commit that" kettenis@@

original diff oked by ariane@@, art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.15 2009/08/06 15:28:14 oga Exp $	*/
d100 1
a100 1

@


1.15
log
@reintroduce the uvm_tree commit.

Now instead of the global object hashtable, we have a per object tree.

Testing shows no performance difference and a slight code shrink. OTOH when
locking is more fine grained this should be faster due to lock contention on
uvm.hashlock.

ok thib@@, art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.14 2009/06/17 00:13:59 oga Exp $	*/
d100 3
@


1.14
log
@date based reversion of uvm to the 4th May.

More backouts in line with previous ones, this appears to bring us back to a
stable condition.

A machine forced to 64mb of ram cycled 10GB through swap with this diff
and is still running as I type this. Other tests by ariane@@ and thib@@
also seem to show that it's alright.

ok deraadt@@, thib@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.10 2007/04/11 12:10:42 art Exp $	*/
d50 5
a54 5
	simple_lock_data_t	vmobjlock;	/* lock on memq */
	struct uvm_pagerops	*pgops;		/* pager ops */
	struct pglist		memq;		/* pages in this object */
	int			uo_npages;	/* # of pages in memq */
	int			uo_refs;	/* reference count */
d85 4
@


1.13
log
@Backout all changes to uvm after pmemrange (which will be backed out
separately).

a change at or just before the hackathon has either exposed or added a
very very nasty memory corruption bug that is giving us hell right now.
So in the interest of kernel stability these diffs are being backed out
until such a time as that corruption bug has been found and squashed,
then the ones that are proven good may slowly return.

a quick hitlist of the main commits this backs out:

mine:
uvm_objwire
the lock change in uvm_swap.c
using trees for uvm objects instead of the hash
removing the pgo_releasepg callback.

art@@'s:
putting pmap_page_protect(VM_PROT_NONE) in uvm_pagedeactivate() since
all callers called that just prior anyway.

ok beck@@, ariane@@.

prompted by deraadt@@.
@
text
@@


1.12
log
@Add uvm_objwire() and uvm_objunwire(), I need this for some of my crazy
shitz.

Code mostly from netbsd with some tweaks from me. The loaning case is
specifcically if 0ed out right now because we do not do loaning.

ok ariane@@, art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.11 2009/06/02 23:00:19 oga Exp $	*/
d50 5
a54 5
	simple_lock_data_t		vmobjlock;	/* lock on memq */
	struct uvm_pagerops		*pgops;		/* pager ops */
	RB_HEAD(uobj_pgs, vm_page)	memt;		/* pages in obj */
	int				uo_npages;	/* # of pages in memq */
	int				uo_refs;	/* reference count */
a95 5
int	uvm_pagecmp(struct vm_page *, struct vm_page *);
RB_PROTOTYPE(uobj_pgs, vm_page, fq.queues.tree, uvm_pagecmp);

int	uvm_objwire(struct uvm_object *, off_t, off_t, struct pglist *);
void	uvm_objunwire(struct uvm_object *, off_t, off_t);
@


1.11
log
@Instead of the global hash table with the terrible hashfunction and a
global lock, switch the uvm object pages to being kept in a per-object
RB_TREE. Right now this is approximately the same speed, but cleaner.
When biglock usage is reduced this will improve concurrency due to lock
contention..

ok beck@@ art@@. Thanks to jasper for the speed testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.10 2007/04/11 12:10:42 art Exp $	*/
d98 3
@


1.10
log
@Instead of managing pages for intrsafe maps in special objects (aka.
kmem_object) just so that we can remove them, just use pmap_extract
to get the pages to free and simplify a lot of code to not deal with
the list of intrsafe maps, intrsafe objects, etc.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.9 2005/07/26 07:11:55 art Exp $	*/
d50 5
a54 5
	simple_lock_data_t	vmobjlock;	/* lock on memq */
	struct uvm_pagerops	*pgops;		/* pager ops */
	struct pglist		memq;		/* pages in this object */
	int			uo_npages;	/* # of pages in memq */
	int			uo_refs;	/* reference count */
d96 2
@


1.9
log
@ - Make a UVM_OBJ_IS_DEVICE macro.
 - Use it to skip device mappings while dumping core.
 - Ignore EFAULT errors while dumping core since they can happen
   even for valid mappings. Just skip that part of the core file and
   let it get automagically zero-filled.

This fixes the broken X core dumps that people have been seeing and also
fixes some other potential problems that could prevent core dumps (mmaps
beyond EOF, etc.).

tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.8 2001/12/19 08:58:07 art Exp $	*/
a76 1
#define	UVM_OBJ_KERN_INTRSAFE	(-3)
d79 1
a79 5
	((uobj)->uo_refs == UVM_OBJ_KERN ||				\
	 (uobj)->uo_refs == UVM_OBJ_KERN_INTRSAFE)

#define	UVM_OBJ_IS_INTRSAFE_OBJECT(uobj)				\
	((uobj)->uo_refs == UVM_OBJ_KERN_INTRSAFE)
@


1.8
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.6 2001/11/12 01:26:09 art Exp $	*/
d89 1
d93 3
@


1.7
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_object.h,v 1.12 2001/05/26 16:32:47 chs Exp $	*/
d50 1
a50 1
	struct simplelock	vmobjlock;	/* lock on memq */
@


1.7.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_object.h,v 1.7 2001/11/28 19:28:15 art Exp $	*/
/*	$NetBSD: uvm_object.h,v 1.14 2001/10/30 15:32:05 thorpej Exp $	*/
d68 7
d77 1
d80 5
a84 1
	((uobj)->uo_refs == UVM_OBJ_KERN)
a92 5
#ifdef notyet	/* XXXART */
#define	UVM_OBJ_IS_VTEXT(uobj)						\
	((uobj)->pgops == &uvm_vnodeops &&				\
	 ((struct vnode *)uobj)->v_flag & VEXECMAP)
#else
a95 1
#endif
@


1.7.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_object.h,v 1.7.2.1 2002/02/02 03:28:27 art Exp $	*/
/*	$NetBSD: uvm_object.h,v 1.16 2002/06/20 15:05:29 chs Exp $	*/
a76 3
extern struct uvm_pagerops uvm_deviceops;
extern struct uvm_pagerops ubc_pager;
extern struct uvm_pagerops aobj_pager;
a90 2
#define	UVM_OBJ_IS_AOBJ(uobj)						\
	((uobj)->pgops == &aobj_pager)
@


1.7.2.3
log
@add VEXECMAP.  also make sure to modify filepages count only in the not
execpages case in uvm_pageremove().
this actually appears to solve the swap freak out problems.  sitting on it for
a long time, never checked if it worked.  sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.h,v 1.7.2.2 2002/11/04 18:02:33 art Exp $	*/
d84 1
a84 1
#if 1
@


1.6
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_object.h,v 1.5 2001/01/29 02:07:47 niklas Exp $	*/
/*	$NetBSD: uvm_object.h,v 1.11 2001/03/09 01:02:12 chs Exp $	*/
d50 1
a50 1
	simple_lock_data_t	vmobjlock;	/* lock on memq */
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_object.h,v 1.8 1999/05/25 20:30:09 thorpej Exp $	*/
/*	$NetBSD: uvm_object.h,v 1.8 1999/05/25 20:30:09 thorpej Exp $	*/
d85 14
@


1.4
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_object.h,v 1.5 1998/03/09 00:58:58 mrg Exp $	*/
d67 7
d75 9
a83 1
#define UVM_OBJ_KERN	(-2)
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_object.h,v 1.8 1999/05/25 20:30:09 thorpej Exp $	*/
a66 7
 *
 * in addition, we have kernel objects which may be used in an
 * interrupt context.  these objects get their mappings entered
 * with pmap_kenter*() and removed with pmap_kremove(), which
 * are safe to call in interrupt context, and must be used ONLY
 * for wired kernel mappings in these objects and their associated
 * maps.
d68 1
a68 9
#define UVM_OBJ_KERN		(-2)
#define	UVM_OBJ_KERN_INTRSAFE	(-3)

#define	UVM_OBJ_IS_KERN_OBJECT(uobj)					\
	((uobj)->uo_refs == UVM_OBJ_KERN ||				\
	 (uobj)->uo_refs == UVM_OBJ_KERN_INTRSAFE)

#define	UVM_OBJ_IS_INTRSAFE_OBJECT(uobj)				\
	((uobj)->uo_refs == UVM_OBJ_KERN_INTRSAFE)
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_object.h,v 1.5 2001/01/29 02:07:47 niklas Exp $	*/
@


1.3.4.3
log
@merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_object.h,v 1.11 2001/03/09 01:02:12 chs Exp $	*/
a84 14

#ifdef _KERNEL

extern struct uvm_pagerops uvm_vnodeops;

#define	UVM_OBJ_IS_VNODE(uobj)						\
	((uobj)->pgops == &uvm_vnodeops)

#define	UVM_OBJ_IS_VTEXT(uobj)						\
	((uobj)->pgops == &uvm_vnodeops &&				\
	 ((struct vnode *)uobj)->v_flag & VTEXT)


#endif /* _KERNEL */
@


1.3.4.4
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_object.h,v 1.12 2001/05/26 16:32:47 chs Exp $	*/
d50 1
a50 1
	struct simplelock	vmobjlock;	/* lock on memq */
@


1.3.4.5
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_object.h,v 1.11 2001/03/09 01:02:12 chs Exp $	*/
d50 1
a50 1
	simple_lock_data_t	vmobjlock;	/* lock on memq */
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

