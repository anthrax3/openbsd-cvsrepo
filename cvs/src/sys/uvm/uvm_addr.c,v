head	1.24;
access;
symbols
	OPENBSD_6_1:1.24.0.4
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.16.0.2
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.14.0.2
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.4
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.6.0.4
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.5.0.6
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.4
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.2
	OPENBSD_5_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.24
date	2017.01.23.01.10.10;	author patrick;	state Exp;
branches;
next	1.23;
commitid	7zJotUStYCl80SkP;

1.23
date	2017.01.17.17.19.21;	author stefan;	state Exp;
branches;
next	1.22;
commitid	v2YvnjMySRAyIm1v;

1.22
date	2016.09.16.02.50.54;	author dlg;	state Exp;
branches;
next	1.21;
commitid	H6qWlQMbaewJS1jU;

1.21
date	2016.09.16.01.51.40;	author dlg;	state Exp;
branches;
next	1.20;
commitid	VnUbZlTLXkN5bQhd;

1.20
date	2016.09.16.01.09.53;	author dlg;	state Exp;
branches;
next	1.19;
commitid	S1LT7BcQMYzBQOe8;

1.19
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.18;
commitid	RlO92XR575sygHqm;

1.18
date	2016.09.02.16.45.12;	author stefan;	state Exp;
branches;
next	1.17;
commitid	UgW3ZaCXpBW5Lrc8;

1.17
date	2016.07.30.16.37.54;	author kettenis;	state Exp;
branches;
next	1.16;
commitid	VaWzUox6GP23o7ES;

1.16
date	2016.06.02.18.48.01;	author tedu;	state Exp;
branches;
next	1.15;
commitid	yZeX7RCnqAcdw8IQ;

1.15
date	2016.03.07.18.44.00;	author naddy;	state Exp;
branches;
next	1.14;
commitid	Z6e4eqr6FuYFPnlL;

1.14
date	2015.07.17.21.56.14;	author kettenis;	state Exp;
branches;
next	1.13;
commitid	54fGtmaEmMoqowTP;

1.13
date	2015.03.30.21.08.40;	author miod;	state Exp;
branches;
next	1.12;
commitid	UIgWyHZZqklZyLUa;

1.12
date	2015.03.30.21.05.17;	author miod;	state Exp;
branches;
next	1.11;
commitid	7xl0eQAuOwSlCM52;

1.11
date	2014.12.23.02.01.57;	author tedu;	state Exp;
branches;
next	1.10;
commitid	q8S2qkrDRKx3mqd8;

1.10
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.9;
commitid	Z1vcFtHO8wRH0yRt;

1.9
date	2014.11.13.00.47.44;	author tedu;	state Exp;
branches;
next	1.8;
commitid	t8zRELnW12GnYxX5;

1.8
date	2014.06.10.20.08.48;	author kettenis;	state Exp;
branches;
next	1.7;
commitid	vDqiuTHW2RwTT2V3;

1.7
date	2014.04.13.23.14.15;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2014.02.04.01.04.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2012.07.18.20.28.18;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2012.06.06.04.54.36;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	2012.04.11.11.23.22;	author ariane;	state Exp;
branches;
next	1.2;

1.2
date	2012.03.15.17.52.28;	author ariane;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.09.13.01.29;	author ariane;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Move static function to the bottom of the file, to the only user
of that function, to guard it with SMALL_KERNEL.

ok mpi@@
@
text
@/*	$OpenBSD: uvm_addr.c,v 1.23 2017/01/17 17:19:21 stefan Exp $	*/

/*
 * Copyright (c) 2011 Ariane van der Steldt <ariane@@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* #define DEBUG */

#include <sys/param.h>
#include <uvm/uvm.h>
#include <uvm/uvm_addr.h>
#include <sys/pool.h>

/* Max gap between hint allocations. */
#define UADDR_HINT_MAXGAP	(4 * PAGE_SIZE)
/* Number of pivots in pivot allocator. */
#define NUM_PIVOTS		16
/*
 * Max number (inclusive) of pages the pivot allocator
 * will place between allocations.
 *
 * The uaddr_pivot_random() function attempts to bias towards
 * small space between allocations, so putting a large number here is fine.
 */
#define PIVOT_RND		8
/*
 * Number of allocations that a pivot can supply before expiring.
 * When a pivot expires, a new pivot has to be found.
 *
 * Must be at least 1.
 */
#define PIVOT_EXPIRE		1024


/* Pool with uvm_addr_state structures. */
struct pool uaddr_pool;
struct pool uaddr_bestfit_pool;
struct pool uaddr_pivot_pool;
struct pool uaddr_rnd_pool;

/* uvm_addr state for bestfit selector. */
struct uaddr_bestfit_state {
	struct uvm_addr_state		 ubf_uaddr;
	struct uaddr_free_rbtree	 ubf_free;
};

/* uvm_addr state for rnd selector. */
struct uaddr_rnd_state {
	struct uvm_addr_state		 ur_uaddr;
#if 0
	TAILQ_HEAD(, vm_map_entry)	 ur_free;
#endif
};

/* Definition of a pivot in pivot selector. */
struct uaddr_pivot {
	vaddr_t				 addr;	/* End of prev. allocation. */
	int				 expire;/* Best before date. */
	int				 dir;	/* Direction. */
	struct vm_map_entry		*entry; /* Will contain next alloc. */
};
/* uvm_addr state for pivot selector. */
struct uaddr_pivot_state {
	struct uvm_addr_state		 up_uaddr;

	/* Free space tree, for fast pivot selection. */
	struct uaddr_free_rbtree	 up_free;

	/* List of pivots. The pointers point to after the last allocation. */
	struct uaddr_pivot		 up_pivots[NUM_PIVOTS];
};

/* Forward declaration (see below). */
extern const struct uvm_addr_functions uaddr_kernel_functions;
struct uvm_addr_state uaddr_kbootstrap;

/* Support functions. */
#ifndef SMALL_KERNEL
struct vm_map_entry	*uvm_addr_entrybyspace(struct uaddr_free_rbtree*,
			    vsize_t);
#endif /* !SMALL_KERNEL */
void			 uaddr_kinsert(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_kremove(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_kbootstrapdestroy(struct uvm_addr_state *);

void			 uaddr_destroy(struct uvm_addr_state *);
void			 uaddr_kbootstrap_destroy(struct uvm_addr_state *);
void			 uaddr_rnd_destroy(struct uvm_addr_state *);
void			 uaddr_bestfit_destroy(struct uvm_addr_state *);
void			 uaddr_pivot_destroy(struct uvm_addr_state *);

#if 0
int			 uaddr_lin_select(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
#endif
int			 uaddr_kbootstrap_select(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
int			 uaddr_rnd_select(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
int			 uaddr_bestfit_select(struct vm_map *,
			    struct uvm_addr_state*, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
#ifndef SMALL_KERNEL
int			 uaddr_pivot_select(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
int			 uaddr_stack_brk_select(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
#endif /* !SMALL_KERNEL */

void			 uaddr_rnd_insert(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_rnd_remove(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_bestfit_insert(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_bestfit_remove(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_pivot_insert(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);
void			 uaddr_pivot_remove(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry *);

#ifndef SMALL_KERNEL
vsize_t			 uaddr_pivot_random(void);
int			 uaddr_pivot_newpivot(struct vm_map *,
			    struct uaddr_pivot_state *, struct uaddr_pivot *,
			    struct vm_map_entry **, vaddr_t *,
			    vsize_t, vaddr_t, vaddr_t, vsize_t, vsize_t);
#endif /* !SMALL_KERNEL */

#if defined(DEBUG) || defined(DDB)
void			 uaddr_pivot_print(struct uvm_addr_state *, boolean_t,
			    int (*)(const char *, ...));
#if 0
void			 uaddr_rnd_print(struct uvm_addr_state *, boolean_t,
			    int (*)(const char *, ...));
#endif
#endif /* DEBUG || DDB */


#ifndef SMALL_KERNEL
/*
 * Find smallest entry in tree that will fit sz bytes.
 */
struct vm_map_entry *
uvm_addr_entrybyspace(struct uaddr_free_rbtree *free, vsize_t sz)
{
	struct vm_map_entry	*tmp, *res;

	tmp = RBT_ROOT(uaddr_free_rbtree, free);
	res = NULL;
	while (tmp) {
		if (tmp->fspace >= sz) {
			res = tmp;
			tmp = RBT_LEFT(uaddr_free_rbtree, tmp);
		} else if (tmp->fspace < sz)
			tmp = RBT_RIGHT(uaddr_free_rbtree, tmp);
	}
	return res;
}
#endif /* !SMALL_KERNEL */

static __inline vaddr_t
uvm_addr_align_forward(vaddr_t addr, vaddr_t align, vaddr_t offset)
{
	vaddr_t adjusted;

	KASSERT(offset < align || (align == 0 && offset == 0));
	KASSERT((align & (align - 1)) == 0);
	KASSERT((offset & PAGE_MASK) == 0);

	align = MAX(align, PAGE_SIZE);
	adjusted = addr & ~(align - 1);
	adjusted += offset;
	return (adjusted < addr ? adjusted + align : adjusted);
}

static __inline vaddr_t
uvm_addr_align_backward(vaddr_t addr, vaddr_t align, vaddr_t offset)
{
	vaddr_t adjusted;

	KASSERT(offset < align || (align == 0 && offset == 0));
	KASSERT((align & (align - 1)) == 0);
	KASSERT((offset & PAGE_MASK) == 0);

	align = MAX(align, PAGE_SIZE);
	adjusted = addr & ~(align - 1);
	adjusted += offset;
	return (adjusted > addr ? adjusted - align : adjusted);
}

/*
 * Try to fit the requested space into the entry.
 */
int
uvm_addr_fitspace(vaddr_t *min_result, vaddr_t *max_result,
    vaddr_t low_addr, vaddr_t high_addr, vsize_t sz,
    vaddr_t align, vaddr_t offset,
    vsize_t before_gap, vsize_t after_gap)
{
	vaddr_t	tmp;
	vsize_t	fspace;

	if (low_addr > high_addr)
		return ENOMEM;
	fspace = high_addr - low_addr;
	if (fspace < before_gap + after_gap)
		return ENOMEM;
	if (fspace - before_gap - after_gap < sz)
		return ENOMEM;

	/* Calculate lowest address. */
	low_addr += before_gap;
	low_addr = uvm_addr_align_forward(tmp = low_addr, align, offset);
	if (low_addr < tmp)	/* Overflow during alignment. */
		return ENOMEM;
	if (high_addr - after_gap - sz < low_addr)
		return ENOMEM;

	/* Calculate highest address. */
	high_addr -= after_gap + sz;
	high_addr = uvm_addr_align_backward(tmp = high_addr, align, offset);
	if (high_addr > tmp)	/* Overflow during alignment. */
		return ENOMEM;
	if (low_addr > high_addr)
		return ENOMEM;

	*min_result = low_addr;
	*max_result = high_addr;
	return 0;
}


/*
 * Initialize uvm_addr.
 */
void
uvm_addr_init(void)
{
	pool_init(&uaddr_pool, sizeof(struct uvm_addr_state), 0,
	    IPL_VM, PR_WAITOK, "uaddr", NULL);
	pool_init(&uaddr_bestfit_pool, sizeof(struct uaddr_bestfit_state), 0,
	    IPL_VM, PR_WAITOK, "uaddrbest", NULL);
	pool_init(&uaddr_pivot_pool, sizeof(struct uaddr_pivot_state), 0,
	    IPL_VM, PR_WAITOK, "uaddrpivot", NULL);
	pool_init(&uaddr_rnd_pool, sizeof(struct uaddr_rnd_state), 0,
	    IPL_VM, PR_WAITOK, "uaddrrnd", NULL);

	uaddr_kbootstrap.uaddr_minaddr = PAGE_SIZE;
	uaddr_kbootstrap.uaddr_maxaddr = -(vaddr_t)PAGE_SIZE;
	uaddr_kbootstrap.uaddr_functions = &uaddr_kernel_functions;
}

/*
 * Invoke destructor function of uaddr.
 */
void
uvm_addr_destroy(struct uvm_addr_state *uaddr)
{
	if (uaddr)
		(*uaddr->uaddr_functions->uaddr_destroy)(uaddr);
}

/*
 * Move address forward to satisfy align, offset.
 */
vaddr_t
uvm_addr_align(vaddr_t addr, vaddr_t align, vaddr_t offset)
{
	vaddr_t result = (addr & ~(align - 1)) + offset;
	if (result < addr)
		result += align;
	return result;
}

/*
 * Move address backwards to satisfy align, offset.
 */
vaddr_t
uvm_addr_align_back(vaddr_t addr, vaddr_t align, vaddr_t offset)
{
	vaddr_t result = (addr & ~(align - 1)) + offset;
	if (result > addr)
		result -= align;
	return result;
}

/*
 * Directional first fit.
 *
 * Do a linear search for free space, starting at addr in entry.
 * direction ==  1: search forward
 * direction == -1: search backward
 *
 * Output: low <= addr <= high and entry will contain addr.
 * 0 will be returned if no space is available.
 *
 * gap describes the space that must appear between the preceding entry.
 */
int
uvm_addr_linsearch(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vaddr_t hint, vsize_t sz, vaddr_t align, vaddr_t offset,
    int direction, vaddr_t low, vaddr_t high,
    vsize_t before_gap, vsize_t after_gap)
{
	struct vm_map_entry	*entry;
	vaddr_t			 low_addr, high_addr;

	KASSERT(entry_out != NULL && addr_out != NULL);
	KASSERT(direction == -1 || direction == 1);
	KASSERT((hint & PAGE_MASK) == 0 && (high & PAGE_MASK) == 0 &&
	    (low & PAGE_MASK) == 0 &&
	    (before_gap & PAGE_MASK) == 0 && (after_gap & PAGE_MASK) == 0);
	KASSERT(high + sz > high); /* Check for overflow. */

	/* Hint magic. */
	if (hint == 0)
		hint = (direction == 1 ? low : high);
	else if (hint > high) {
		if (direction != -1)
			return ENOMEM;
		hint = high;
	} else if (hint < low) {
		if (direction != 1)
			return ENOMEM;
		hint = low;
	}

	for (entry = uvm_map_entrybyaddr(&map->addr,
	    hint - (direction == -1 ? 1 : 0)); entry != NULL;
	    entry = (direction == 1 ?
	    RBT_NEXT(uvm_map_addr, entry) :
	    RBT_PREV(uvm_map_addr, entry))) {
		if (VMMAP_FREE_START(entry) > high ||
		    VMMAP_FREE_END(entry) < low) {
			break;
		}

		if (uvm_addr_fitspace(&low_addr, &high_addr,
		    MAX(low, VMMAP_FREE_START(entry)),
		    MIN(high, VMMAP_FREE_END(entry)),
		    sz, align, offset, before_gap, after_gap) == 0) {
			*entry_out = entry;
			if (hint >= low_addr && hint <= high_addr) {
				*addr_out = hint;
			} else {
				*addr_out = (direction == 1 ?
				    low_addr : high_addr);
			}
			return 0;
		}
	}

	return ENOMEM;
}

/*
 * Invoke address selector of uaddr.
 * uaddr may be NULL, in which case the algorithm will fail with ENOMEM.
 *
 * Will invoke uvm_addr_isavail to fill in last_out.
 */
int
uvm_addr_invoke(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, struct vm_map_entry **last_out,
    vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset, vm_prot_t prot, vaddr_t hint)
{
	int error;

	if (uaddr == NULL)
		return ENOMEM;

	hint &= ~((vaddr_t)PAGE_MASK);
	if (hint != 0 &&
	    !(hint >= uaddr->uaddr_minaddr && hint < uaddr->uaddr_maxaddr))
		return ENOMEM;

	error = (*uaddr->uaddr_functions->uaddr_select)(map, uaddr,
	    entry_out, addr_out, sz, align, offset, prot, hint);

	if (error == 0) {
		KASSERT(*entry_out != NULL);
		*last_out = NULL;
		if (!uvm_map_isavail(map, uaddr, entry_out, last_out,
		    *addr_out, sz)) {
			panic("uvm_addr_invoke: address selector %p "
			    "(%s 0x%lx-0x%lx) "
			    "returned unavailable address 0x%lx sz 0x%lx",
			    uaddr, uaddr->uaddr_functions->uaddr_name,
			    uaddr->uaddr_minaddr, uaddr->uaddr_maxaddr,
			    *addr_out, sz);
		}
	}

	return error;
}

#if defined(DEBUG) || defined(DDB)
void
uvm_addr_print(struct uvm_addr_state *uaddr, const char *slot, boolean_t full,
    int (*pr)(const char *, ...))
{
	if (uaddr == NULL) {
		(*pr)("- uvm_addr %s: NULL\n", slot);
		return;
	}

	(*pr)("- uvm_addr %s: %p (%s 0x%lx-0x%lx)\n", slot, uaddr,
	    uaddr->uaddr_functions->uaddr_name,
	    uaddr->uaddr_minaddr, uaddr->uaddr_maxaddr);
	if (uaddr->uaddr_functions->uaddr_print == NULL)
		return;

	(*uaddr->uaddr_functions->uaddr_print)(uaddr, full, pr);
}
#endif /* DEBUG || DDB */

/*
 * Destroy a uvm_addr_state structure.
 * The uaddr must have been previously allocated from uaddr_state_pool.
 */
void
uaddr_destroy(struct uvm_addr_state *uaddr)
{
	pool_put(&uaddr_pool, uaddr);
}


#if 0
/*
 * Linear allocator.
 * This allocator uses a first-fit algorithm.
 *
 * If hint is set, search will start at the hint position.
 * Only searches forward.
 */
const struct uvm_addr_functions uaddr_lin_functions = {
	.uaddr_select = &uaddr_lin_select,
	.uaddr_destroy = &uaddr_destroy,
	.uaddr_name = "uaddr_lin"
};

struct uvm_addr_state *
uaddr_lin_create(vaddr_t minaddr, vaddr_t maxaddr)
{
	struct uvm_addr_state *uaddr;

	uaddr = pool_get(&uaddr_pool, PR_WAITOK);
	uaddr->uaddr_minaddr = minaddr;
	uaddr->uaddr_maxaddr = maxaddr;
	uaddr->uaddr_functions = &uaddr_lin_functions;
	return uaddr;
}

int
uaddr_lin_select(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	vaddr_t guard_sz;

	/* Deal with guardpages: search for space with one extra page. */
	guard_sz = ((map->flags & VM_MAP_GUARDPAGES) == 0 ? 0 : PAGE_SIZE);

	if (uaddr->uaddr_maxaddr - uaddr->uaddr_minaddr - guard_sz < sz)
		return ENOMEM;
	return uvm_addr_linsearch(map, uaddr, entry_out, addr_out, 0, sz,
	    align, offset, 1, uaddr->uaddr_minaddr, uaddr->uaddr_maxaddr - sz,
	    0, guard_sz);
}
#endif

/*
 * Randomized allocator.
 * This allocator use uvm_map_hint to acquire a random address and searches
 * from there.
 */

const struct uvm_addr_functions uaddr_rnd_functions = {
	.uaddr_select = &uaddr_rnd_select,
	.uaddr_free_insert = &uaddr_rnd_insert,
	.uaddr_free_remove = &uaddr_rnd_remove,
	.uaddr_destroy = &uaddr_rnd_destroy,
#if defined(DEBUG) || defined(DDB)
#if 0
	.uaddr_print = &uaddr_rnd_print,
#endif
#endif /* DEBUG || DDB */
	.uaddr_name = "uaddr_rnd"
};

struct uvm_addr_state *
uaddr_rnd_create(vaddr_t minaddr, vaddr_t maxaddr)
{
	struct uaddr_rnd_state *uaddr;

	uaddr = pool_get(&uaddr_rnd_pool, PR_WAITOK);
	uaddr->ur_uaddr.uaddr_minaddr = minaddr;
	uaddr->ur_uaddr.uaddr_maxaddr = maxaddr;
	uaddr->ur_uaddr.uaddr_functions = &uaddr_rnd_functions;
#if 0
	TAILQ_INIT(&uaddr->ur_free);
#endif
	return &uaddr->ur_uaddr;
}

int
uaddr_rnd_select(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	struct vmspace		*vm;
	vaddr_t			 minaddr, maxaddr;
	vaddr_t			 guard_sz;
	vaddr_t			 low_addr, high_addr;
	struct vm_map_entry	*entry, *next;
	vsize_t			 before_gap, after_gap;
	vaddr_t			 tmp;

	KASSERT((map->flags & VM_MAP_ISVMSPACE) != 0);
	vm = (struct vmspace *)map;

	/* Deal with guardpages: search for space with one extra page. */
	guard_sz = ((map->flags & VM_MAP_GUARDPAGES) == 0 ? 0 : PAGE_SIZE);

	if (uaddr->uaddr_maxaddr - guard_sz < sz)
		return ENOMEM;
	minaddr = uvm_addr_align_forward(uaddr->uaddr_minaddr, align, offset);
	maxaddr = uvm_addr_align_backward(uaddr->uaddr_maxaddr - sz - guard_sz,
	    align, offset);

	/* Quick fail if the allocation won't fit. */
	if (minaddr >= maxaddr)
		return ENOMEM;

	/* Select a hint. */
	if (hint == 0)
		hint = uvm_map_hint(vm, prot, minaddr, maxaddr);
	/* Clamp hint to uaddr range. */
	hint = MIN(MAX(hint, minaddr), maxaddr);

	/* Align hint to align,offset parameters. */
	tmp = hint;
	hint = uvm_addr_align_forward(tmp, align, offset);
	/* Check for overflow during alignment. */
	if (hint < tmp || hint > maxaddr)
		return ENOMEM; /* Compatibility mode: never look backwards. */

	before_gap = 0;
	after_gap = guard_sz;
	hint -= MIN(hint, before_gap);

	/*
	 * Use the augmented address tree to look up the first entry
	 * at or after hint with sufficient space.
	 *
	 * This code is the original optimized code, but will fail if the
	 * subtree it looks at does have sufficient space, but fails to meet
	 * the align constraint.
	 *
	 * Guard: subtree is not exhausted and max(fspace) >= required.
	 */
	entry = uvm_map_entrybyaddr(&map->addr, hint);

	/* Walk up the tree, until there is at least sufficient space. */
	while (entry != NULL &&
	    entry->fspace_augment < before_gap + after_gap + sz)
		entry = RBT_PARENT(uvm_map_addr, entry);

	while (entry != NULL) {
		/* Test if this fits. */
		if (VMMAP_FREE_END(entry) > hint &&
		    uvm_map_uaddr_e(map, entry) == uaddr &&
		    uvm_addr_fitspace(&low_addr, &high_addr,
		    MAX(uaddr->uaddr_minaddr, VMMAP_FREE_START(entry)),
		    MIN(uaddr->uaddr_maxaddr, VMMAP_FREE_END(entry)),
		    sz, align, offset, before_gap, after_gap) == 0) {
			*entry_out = entry;
			if (hint >= low_addr && hint <= high_addr)
				*addr_out = hint;
			else
				*addr_out = low_addr;
			return 0;
		}

		/* RBT_NEXT, but skip subtrees that cannot possible fit. */
		next = RBT_RIGHT(uvm_map_addr, entry);
		if (next != NULL &&
		    next->fspace_augment >= before_gap + after_gap + sz) {
			entry = next;
			while ((next = RBT_LEFT(uvm_map_addr, entry)) !=
			    NULL)
				entry = next;
		} else {
do_parent:
			next = RBT_PARENT(uvm_map_addr, entry);
			if (next == NULL)
				entry = NULL;
			else if (RBT_LEFT(uvm_map_addr, next) == entry)
				entry = next;
			else {
				entry = next;
				goto do_parent;
			}
		}
	}

	/* Lookup failed. */
	return ENOMEM;
}

/*
 * Destroy a uaddr_rnd_state structure.
 */
void
uaddr_rnd_destroy(struct uvm_addr_state *uaddr)
{
	pool_put(&uaddr_rnd_pool, uaddr);
}

/*
 * Add entry to tailq.
 */
void
uaddr_rnd_insert(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	return;
}

/*
 * Remove entry from tailq.
 */
void
uaddr_rnd_remove(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	return;
}

#if 0
#if defined(DEBUG) || defined(DDB)
void
uaddr_rnd_print(struct uvm_addr_state *uaddr_p, boolean_t full,
    int (*pr)(const char*, ...))
{
	struct vm_map_entry	*entry;
	struct uaddr_rnd_state	*uaddr;
	vaddr_t			 addr;
	size_t			 count;
	vsize_t			 space;

	uaddr = (struct uaddr_rnd_state *)uaddr_p;
	addr = 0;
	count = 0;
	space = 0;
	TAILQ_FOREACH(entry, &uaddr->ur_free, dfree.tailq) {
		count++;
		space += entry->fspace;

		if (full) {
			(*pr)("\tentry %p: 0x%lx-0x%lx G=0x%lx F=0x%lx\n",
			    entry, entry->start, entry->end,
			    entry->guard, entry->fspace);
			(*pr)("\t\tfree: 0x%lx-0x%lx\n",
			    VMMAP_FREE_START(entry), VMMAP_FREE_END(entry));
		}
		if (entry->start < addr) {
			if (!full)
				(*pr)("\tentry %p: 0x%lx-0x%lx "
				    "G=0x%lx F=0x%lx\n",
				    entry, entry->start, entry->end,
				    entry->guard, entry->fspace);
			(*pr)("\t\tstart=0x%lx, expected at least 0x%lx\n",
			    entry->start, addr);
		}

		addr = VMMAP_FREE_END(entry);
	}
	(*pr)("\t0x%lu entries, 0x%lx free bytes\n", count, space);
}
#endif /* DEBUG || DDB */
#endif

/*
 * Kernel allocation bootstrap logic.
 */
const struct uvm_addr_functions uaddr_kernel_functions = {
	.uaddr_select = &uaddr_kbootstrap_select,
	.uaddr_destroy = &uaddr_kbootstrap_destroy,
	.uaddr_name = "uaddr_kbootstrap"
};

/*
 * Select an address from the map.
 *
 * This function ignores the uaddr spec and instead uses the map directly.
 * Because of that property, the uaddr algorithm can be shared across all
 * kernel maps.
 */
int
uaddr_kbootstrap_select(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset, vm_prot_t prot, vaddr_t hint)
{
	vaddr_t tmp;

	RBT_FOREACH(*entry_out, uvm_map_addr, &map->addr) {
		if (VMMAP_FREE_END(*entry_out) <= uvm_maxkaddr &&
		    uvm_addr_fitspace(addr_out, &tmp,
		    VMMAP_FREE_START(*entry_out), VMMAP_FREE_END(*entry_out),
		    sz, align, offset, 0, 0) == 0)
			return 0;
	}

	return ENOMEM;
}

/*
 * Don't destroy the kernel bootstrap allocator.
 */
void
uaddr_kbootstrap_destroy(struct uvm_addr_state *uaddr)
{
	KASSERT(uaddr == (struct uvm_addr_state *)&uaddr_kbootstrap);
}

#ifndef SMALL_KERNEL
/*
 * Best fit algorithm.
 */

const struct uvm_addr_functions uaddr_bestfit_functions = {
	.uaddr_select = &uaddr_bestfit_select,
	.uaddr_free_insert = &uaddr_bestfit_insert,
	.uaddr_free_remove = &uaddr_bestfit_remove,
	.uaddr_destroy = &uaddr_bestfit_destroy,
	.uaddr_name = "uaddr_bestfit"
};

struct uvm_addr_state *
uaddr_bestfit_create(vaddr_t minaddr, vaddr_t maxaddr)
{
	struct uaddr_bestfit_state *uaddr;

	uaddr = pool_get(&uaddr_bestfit_pool, PR_WAITOK);
	uaddr->ubf_uaddr.uaddr_minaddr = minaddr;
	uaddr->ubf_uaddr.uaddr_maxaddr = maxaddr;
	uaddr->ubf_uaddr.uaddr_functions = &uaddr_bestfit_functions;
	RBT_INIT(uaddr_free_rbtree, &uaddr->ubf_free);
	return &uaddr->ubf_uaddr;
}

void
uaddr_bestfit_destroy(struct uvm_addr_state *uaddr)
{
	pool_put(&uaddr_bestfit_pool, uaddr);
}

void
uaddr_bestfit_insert(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	struct uaddr_bestfit_state	*uaddr;
	struct vm_map_entry		*rb_rv;

	uaddr = (struct uaddr_bestfit_state *)uaddr_p;
	if ((rb_rv = RBT_INSERT(uaddr_free_rbtree, &uaddr->ubf_free, entry)) !=
	    NULL) {
		panic("%s: duplicate insertion: state %p "
		    "interting %p, colliding with %p", __func__,
		    uaddr, entry, rb_rv);
	}
}

void
uaddr_bestfit_remove(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	struct uaddr_bestfit_state	*uaddr;

	uaddr = (struct uaddr_bestfit_state *)uaddr_p;
	if (RBT_REMOVE(uaddr_free_rbtree, &uaddr->ubf_free, entry) != entry)
		panic("%s: entry was not in tree", __func__);
}

int
uaddr_bestfit_select(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	vaddr_t				 min, max;
	struct uaddr_bestfit_state	*uaddr;
	struct vm_map_entry		*entry;
	vsize_t				 guardsz;

	uaddr = (struct uaddr_bestfit_state *)uaddr_p;
	guardsz = ((map->flags & VM_MAP_GUARDPAGES) ? PAGE_SIZE : 0);
	if (sz + guardsz < sz)
		return ENOMEM;

	/*
	 * Find smallest item on freelist capable of holding item.
	 * Deal with guardpages: search for space with one extra page.
	 */
	entry = uvm_addr_entrybyspace(&uaddr->ubf_free, sz + guardsz);
	if (entry == NULL)
		return ENOMEM;

	/* Walk the tree until we find an entry that fits.  */
	while (uvm_addr_fitspace(&min, &max,
	    VMMAP_FREE_START(entry), VMMAP_FREE_END(entry),
	    sz, align, offset, 0, guardsz) != 0) {
		entry = RBT_NEXT(uaddr_free_rbtree, entry);
		if (entry == NULL)
			return ENOMEM;
	}

	/* Return the address that generates the least fragmentation. */
	*entry_out = entry;
	*addr_out = (min - VMMAP_FREE_START(entry) <=
	    VMMAP_FREE_END(entry) - guardsz - sz - max ?
	    min : max);
	return 0;
}
#endif /* !SMALL_KERNEL */


#ifndef SMALL_KERNEL
/*
 * A userspace allocator based on pivots.
 */

const struct uvm_addr_functions uaddr_pivot_functions = {
	.uaddr_select = &uaddr_pivot_select,
	.uaddr_free_insert = &uaddr_pivot_insert,
	.uaddr_free_remove = &uaddr_pivot_remove,
	.uaddr_destroy = &uaddr_pivot_destroy,
#if defined(DEBUG) || defined(DDB)
	.uaddr_print = &uaddr_pivot_print,
#endif /* DEBUG || DDB */
	.uaddr_name = "uaddr_pivot"
};

/*
 * A special random function for pivots.
 *
 * This function will return:
 * - a random number
 * - a multiple of PAGE_SIZE
 * - at least PAGE_SIZE
 *
 * The random function has a slightly higher change to return a small number.
 */
vsize_t
uaddr_pivot_random(void)
{
	int			r;

	/*
	 * The sum of two six-sided dice will have a normal distribution.
	 * We map the highest probable number to 1, by folding the curve
	 * (think of a graph on a piece of paper, that you fold).
	 *
	 * Because the fold happens at PIVOT_RND - 1, the numbers 0 and 1
	 * have the same and highest probability of happening.
	 */
	r = arc4random_uniform(PIVOT_RND) + arc4random_uniform(PIVOT_RND) -
	    (PIVOT_RND - 1);
	if (r < 0)
		r = -r;

	/*
	 * Make the returned value at least PAGE_SIZE and a multiple of
	 * PAGE_SIZE.
	 */
	return (vaddr_t)(1 + r) << PAGE_SHIFT;
}

/*
 * Select a new pivot.
 *
 * A pivot must:
 * - be chosen random
 * - have a randomly chosen gap before it, where the uaddr_state starts
 * - have a randomly chosen gap after it, before the uaddr_state ends
 *
 * Furthermore, the pivot must provide sufficient space for the allocation.
 * The addr will be set to the selected address.
 *
 * Returns ENOMEM on failure.
 */
int
uaddr_pivot_newpivot(struct vm_map *map, struct uaddr_pivot_state *uaddr,
    struct uaddr_pivot *pivot,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vsize_t before_gap, vsize_t after_gap)
{
	struct vm_map_entry		*entry, *found;
	vaddr_t				 minaddr, maxaddr;
	vsize_t				 dist;
	vaddr_t				 found_minaddr, found_maxaddr;
	vaddr_t				 min, max;
	vsize_t				 arc4_arg;
	int				 fit_error;
	u_int32_t			 path;

	minaddr = uaddr->up_uaddr.uaddr_minaddr;
	maxaddr = uaddr->up_uaddr.uaddr_maxaddr;
	KASSERT(minaddr < maxaddr);
#ifdef DIAGNOSTIC
	if (minaddr + 2 * PAGE_SIZE > maxaddr) {
		panic("uaddr_pivot_newpivot: cannot grant random pivot "
		    "in area less than 2 pages (size = 0x%lx)",
		    maxaddr - minaddr);
	}
#endif /* DIAGNOSTIC */

	/*
	 * Gap calculation: 1/32 of the size of the managed area.
	 *
	 * At most: sufficient to not get truncated at arc4random.
	 * At least: 2 PAGE_SIZE
	 *
	 * minaddr and maxaddr will be changed according to arc4random.
	 */
	dist = MAX((maxaddr - minaddr) / 32, 2 * (vaddr_t)PAGE_SIZE);
	if (dist >> PAGE_SHIFT > 0xffffffff) {
		minaddr += (vsize_t)arc4random() << PAGE_SHIFT;
		maxaddr -= (vsize_t)arc4random() << PAGE_SHIFT;
	} else {
		minaddr += (vsize_t)arc4random_uniform(dist >> PAGE_SHIFT) <<
		    PAGE_SHIFT;
		maxaddr -= (vsize_t)arc4random_uniform(dist >> PAGE_SHIFT) <<
		    PAGE_SHIFT;
	}

	/*
	 * A very fast way to find an entry that will be large enough
	 * to hold the allocation, but still is found more or less
	 * randomly: the tree path selector has a 50% chance to go for
	 * a bigger or smaller entry.
	 *
	 * Note that the memory may actually be available,
	 * but the fragmentation may be so bad and the gaps chosen
	 * so unfortunately, that the allocation will not succeed.
	 * Or the alignment can only be satisfied by an entry that
	 * is not visited in the randomly selected path.
	 *
	 * This code finds an entry with sufficient space in O(log n) time.
	 */
	path = arc4random();
	found = NULL;
	entry = RBT_ROOT(uaddr_free_rbtree, &uaddr->up_free);
	while (entry != NULL) {
		fit_error = uvm_addr_fitspace(&min, &max,
		    MAX(VMMAP_FREE_START(entry), minaddr),
		    MIN(VMMAP_FREE_END(entry), maxaddr),
		    sz, align, offset, before_gap, after_gap);

		/* It fits, save this entry. */
		if (fit_error == 0) {
			found = entry;
			found_minaddr = min;
			found_maxaddr = max;
		}

		/* Next. */
		if (fit_error != 0)
			entry = RBT_RIGHT(uaddr_free_rbtree, entry);
		else if	((path & 0x1) == 0) {
			path >>= 1;
			entry = RBT_RIGHT(uaddr_free_rbtree, entry);
		} else {
			path >>= 1;
			entry = RBT_LEFT(uaddr_free_rbtree, entry);
		}
	}
	if (found == NULL)
		return ENOMEM;	/* Not found a large enough region. */

	/*
	 * Calculate a random address within found.
	 *
	 * found_minaddr and found_maxaddr are already aligned, so be sure
	 * to select a multiple of align as the offset in the entry.
	 * Preferably, arc4random_uniform is used to provide no bias within
	 * the entry.
	 * However if the size of the entry exceeds arc4random_uniforms
	 * argument limit, we simply use arc4random (thus limiting ourselves
	 * to 4G * PAGE_SIZE bytes offset).
	 */
	if (found_maxaddr == found_minaddr)
		*addr_out = found_minaddr;
	else {
		KASSERT(align >= PAGE_SIZE && (align & (align - 1)) == 0);
		arc4_arg = found_maxaddr - found_minaddr;
		if (arc4_arg > 0xffffffff) {
			*addr_out = found_minaddr +
			    (arc4random() & ~(align - 1));
		} else {
			*addr_out = found_minaddr +
			    (arc4random_uniform(arc4_arg) & ~(align - 1));
		}
	}
	/* Address was found in this entry. */
	*entry_out = found;

	/*
	 * Set up new pivot and return selected address.
	 *
	 * Depending on the direction of the pivot, the pivot must be placed
	 * at the bottom or the top of the allocation:
	 * - if the pivot moves upwards, place the pivot at the top of the
	 *   allocation,
	 * - if the pivot moves downwards, place the pivot at the bottom
	 *   of the allocation.
	 */
	pivot->entry = found;
	pivot->dir = (arc4random() & 0x1 ? 1 : -1);
	if (pivot->dir > 0)
		pivot->addr = *addr_out + sz;
	else
		pivot->addr = *addr_out;
	pivot->expire = PIVOT_EXPIRE - 1; /* First use is right now. */
	return 0;
}

/*
 * Pivot selector.
 *
 * Each time the selector is invoked, it will select a random pivot, which
 * it will use to select memory with. The memory will be placed at the pivot,
 * with a randomly sized gap between the allocation and the pivot.
 * The pivot will then move so it will never revisit this address.
 *
 * Each allocation, the pivot expiry timer ticks. Once the pivot becomes
 * expired, it will be replaced with a newly created pivot. Pivots also
 * automatically expire if they fail to provide memory for an allocation.
 *
 * Expired pivots are replaced using the uaddr_pivot_newpivot() function,
 * which will ensure the pivot points at memory in such a way that the
 * allocation will succeed.
 * As an added bonus, the uaddr_pivot_newpivot() function will perform the
 * allocation immediately and move the pivot as appropriate.
 *
 * If uaddr_pivot_newpivot() fails to find a new pivot that will allow the
 * allocation to succeed, it will not create a new pivot and the allocation
 * will fail.
 *
 * A pivot running into used memory will automatically expire (because it will
 * fail to allocate).
 *
 * Characteristics of the allocator:
 * - best case, an allocation is O(log N)
 *   (it would be O(1), if it werent for the need to check if the memory is
 *   free; although that can be avoided...)
 * - worst case, an allocation is O(log N)
 *   (the uaddr_pivot_newpivot() function has that complexity)
 * - failed allocations always take O(log N)
 *   (the uaddr_pivot_newpivot() function will walk that deep into the tree).
 */
int
uaddr_pivot_select(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	struct uaddr_pivot_state	*uaddr;
	struct vm_map_entry		*entry;
	struct uaddr_pivot		*pivot;
	vaddr_t				 min, max;
	vsize_t				 before_gap, after_gap;
	int				 err;

	/*
	 * When we have a hint, use the rnd allocator that finds the
	 * area that is closest to the hint, if there is such an area.
	 */
	if (hint != 0) {
		if (uaddr_rnd_select(map, uaddr_p, entry_out, addr_out,
		    sz, align, offset, prot, hint) == 0)
			return 0;
		return ENOMEM;
	}

	/*
	 * Select a random pivot and a random gap sizes around the allocation.
	 */
	uaddr = (struct uaddr_pivot_state *)uaddr_p;
	pivot = &uaddr->up_pivots[
	    arc4random_uniform(nitems(uaddr->up_pivots))];
	before_gap = uaddr_pivot_random();
	after_gap = uaddr_pivot_random();
	if (pivot->addr == 0 || pivot->entry == NULL || pivot->expire == 0)
		goto expired;	/* Pivot is invalid (null or expired). */

	/* Attempt to use the pivot to map the entry. */
	entry = pivot->entry;
	if (pivot->dir > 0) {
		if (uvm_addr_fitspace(&min, &max,
		    MAX(VMMAP_FREE_START(entry), pivot->addr),
		    VMMAP_FREE_END(entry), sz, align, offset,
		    before_gap, after_gap) == 0) {
			*addr_out = min;
			*entry_out = entry;
			pivot->addr = min + sz;
			pivot->expire--;
			return 0;
		}
	} else {
		if (uvm_addr_fitspace(&min, &max,
		    VMMAP_FREE_START(entry),
		    MIN(VMMAP_FREE_END(entry), pivot->addr),
		    sz, align, offset, before_gap, after_gap) == 0) {
			*addr_out = max;
			*entry_out = entry;
			pivot->addr = max;
			pivot->expire--;
			return 0;
		}
	}

expired:
	/*
	 * Pivot expired or allocation failed.
	 * Use pivot selector to do the allocation and find a new pivot.
	 */
	err = uaddr_pivot_newpivot(map, uaddr, pivot, entry_out, addr_out,
	    sz, align, offset, before_gap, after_gap);
	return err;
}

/*
 * Free the pivot.
 */
void
uaddr_pivot_destroy(struct uvm_addr_state *uaddr)
{
	pool_put(&uaddr_pivot_pool, uaddr);
}

/*
 * Insert an entry with free space in the space tree.
 */
void
uaddr_pivot_insert(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	struct uaddr_pivot_state	*uaddr;
	struct vm_map_entry		*rb_rv;
	struct uaddr_pivot		*p;
	vaddr_t				 check_addr;
	vaddr_t				 start, end;

	uaddr = (struct uaddr_pivot_state *)uaddr_p;
	if ((rb_rv = RBT_INSERT(uaddr_free_rbtree, &uaddr->up_free, entry)) !=
	    NULL) {
		panic("%s: duplicate insertion: state %p "
		    "inserting entry %p which collides with %p", __func__,
		    uaddr, entry, rb_rv);
	}

	start = VMMAP_FREE_START(entry);
	end = VMMAP_FREE_END(entry);

	/*
	 * Update all pivots that are contained in this entry.
	 */
	for (p = &uaddr->up_pivots[0];
	    p != &uaddr->up_pivots[nitems(uaddr->up_pivots)]; p++) {
		check_addr = p->addr;
		if (check_addr == 0)
			continue;
		if (p->dir < 0)
			check_addr--;

		if (start <= check_addr &&
		    check_addr < end) {
			KASSERT(p->entry == NULL);
			p->entry = entry;
		}
	}
}

/*
 * Remove an entry with free space from the space tree.
 */
void
uaddr_pivot_remove(struct vm_map *map, struct uvm_addr_state *uaddr_p,
    struct vm_map_entry *entry)
{
	struct uaddr_pivot_state	*uaddr;
	struct uaddr_pivot		*p;

	uaddr = (struct uaddr_pivot_state *)uaddr_p;
	if (RBT_REMOVE(uaddr_free_rbtree, &uaddr->up_free, entry) != entry)
		panic("%s: entry was not in tree", __func__);

	/*
	 * Inform any pivot with this entry that the entry is gone.
	 * Note that this does not automatically invalidate the pivot.
	 */
	for (p = &uaddr->up_pivots[0];
	    p != &uaddr->up_pivots[nitems(uaddr->up_pivots)]; p++) {
		if (p->entry == entry)
			p->entry = NULL;
	}
}

/*
 * Create a new pivot selector.
 *
 * Initially, all pivots are in the expired state.
 * Two reasons for this:
 * - it means this allocator will not take a huge amount of time
 * - pivots select better on demand, because the pivot selection will be
 *   affected by preceding allocations:
 *   the next pivots will likely end up in different segments of free memory,
 *   that was segmented by an earlier allocation; better spread.
 */
struct uvm_addr_state *
uaddr_pivot_create(vaddr_t minaddr, vaddr_t maxaddr)
{
	struct uaddr_pivot_state *uaddr;

	uaddr = pool_get(&uaddr_pivot_pool, PR_WAITOK);
	uaddr->up_uaddr.uaddr_minaddr = minaddr;
	uaddr->up_uaddr.uaddr_maxaddr = maxaddr;
	uaddr->up_uaddr.uaddr_functions = &uaddr_pivot_functions;
	RBT_INIT(uaddr_free_rbtree, &uaddr->up_free);
	memset(uaddr->up_pivots, 0, sizeof(uaddr->up_pivots));

	return &uaddr->up_uaddr;
}

#if defined(DEBUG) || defined(DDB)
/*
 * Print the uaddr_pivot_state.
 *
 * If full, a listing of all entries in the state will be provided.
 */
void
uaddr_pivot_print(struct uvm_addr_state *uaddr_p, boolean_t full,
    int (*pr)(const char *, ...))
{
	struct uaddr_pivot_state	*uaddr;
	struct uaddr_pivot		*pivot;
	struct vm_map_entry		*entry;
	int				 i;
	vaddr_t				 check_addr;

	uaddr = (struct uaddr_pivot_state *)uaddr_p;

	for (i = 0; i < NUM_PIVOTS; i++) {
		pivot = &uaddr->up_pivots[i];

		(*pr)("\tpivot 0x%lx, epires in %d, direction %d\n",
		    pivot->addr, pivot->expire, pivot->dir);
	}
	if (!full)
		return;

	if (RBT_EMPTY(uaddr_free_rbtree, &uaddr->up_free))
		(*pr)("\tempty\n");
	/* Print list of free space. */
	RBT_FOREACH(entry, uaddr_free_rbtree, &uaddr->up_free) {
		(*pr)("\t0x%lx - 0x%lx free (0x%lx bytes)\n",
		    VMMAP_FREE_START(entry), VMMAP_FREE_END(entry),
		    VMMAP_FREE_END(entry) - VMMAP_FREE_START(entry));

		for (i = 0; i < NUM_PIVOTS; i++) {
			pivot = &uaddr->up_pivots[i];
			check_addr = pivot->addr;
			if (check_addr == 0)
				continue;
			if (pivot->dir < 0)
				check_addr--;

			if (VMMAP_FREE_START(entry) <= check_addr &&
			    check_addr < VMMAP_FREE_END(entry)) {
				(*pr)("\t\tcontains pivot %d (0x%lx)\n",
				    i, pivot->addr);
			}
		}
	}
}
#endif /* DEBUG || DDB */
#endif /* !SMALL_KERNEL */

#ifndef SMALL_KERNEL
/*
 * Strategy for uaddr_stack_brk_select.
 */
struct uaddr_bs_strat {
	vaddr_t			start;		/* Start of area. */
	vaddr_t			end;		/* End of area. */
	int			dir;		/* Search direction. */
};

/*
 * Stack/break allocator.
 *
 * Stack area is grown into in the opposite direction of the stack growth,
 * brk area is grown downward (because sbrk() grows upward).
 *
 * Both areas are grown into proportially: a weighted chance is used to
 * select which one (stack or brk area) to try. If the allocation fails,
 * the other one is tested.
 */
const struct uvm_addr_functions uaddr_stack_brk_functions = {
	.uaddr_select = &uaddr_stack_brk_select,
	.uaddr_destroy = &uaddr_destroy,
	.uaddr_name = "uaddr_stckbrk"
};

/*
 * Stack/brk address selector.
 */
int
uaddr_stack_brk_select(struct vm_map *map, struct uvm_addr_state *uaddr,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	vsize_t			before_gap, after_gap;
	int			stack_idx, brk_idx;
	struct uaddr_bs_strat	strat[2], *s;
	vsize_t			sb_size;

	/*
	 * Choose gap size and if the stack is searched before or after the
	 * brk area.
	 */
	before_gap = ((arc4random() & 0x3) + 1) << PAGE_SHIFT;
	after_gap = ((arc4random() & 0x3) + 1) << PAGE_SHIFT;

	sb_size = (map->s_end - map->s_start) + (map->b_end - map->b_start);
	sb_size >>= PAGE_SHIFT;
	if (arc4random_uniform(MAX(sb_size, 0xffffffff)) >
	    map->b_end - map->b_start) {
		brk_idx = 1;
		stack_idx = 0;
	} else {
		brk_idx = 0;
		stack_idx = 1;
	}

	/* Set up stack search strategy. */
	s = &strat[stack_idx];
	s->start = MAX(map->s_start, uaddr->uaddr_minaddr);
	s->end = MIN(map->s_end, uaddr->uaddr_maxaddr);
#ifdef MACHINE_STACK_GROWS_UP
	s->dir = -1;
#else
	s->dir =  1;
#endif

	/* Set up brk search strategy. */
	s = &strat[brk_idx];
	s->start = MAX(map->b_start, uaddr->uaddr_minaddr);
	s->end = MIN(map->b_end, uaddr->uaddr_maxaddr);
	s->dir = -1;	/* Opposite of brk() growth. */

	/* Linear search for space.  */
	for (s = &strat[0]; s < &strat[nitems(strat)]; s++) {
		if (s->end - s->start < sz)
			continue;
		if (uvm_addr_linsearch(map, uaddr, entry_out, addr_out,
		    0, sz, align, offset, s->dir, s->start, s->end - sz,
		    before_gap, after_gap) == 0)
			return 0;
	}

	return ENOMEM;
}

struct uvm_addr_state *
uaddr_stack_brk_create(vaddr_t minaddr, vaddr_t maxaddr)
{
	struct uvm_addr_state* uaddr;

	uaddr = pool_get(&uaddr_pool, PR_WAITOK);
	uaddr->uaddr_minaddr = minaddr;
	uaddr->uaddr_maxaddr = maxaddr;
	uaddr->uaddr_functions = &uaddr_stack_brk_functions;
	return uaddr;
}
#endif /* !SMALL_KERNEL */


#ifndef SMALL_KERNEL
/*
 * Free space comparison.
 * Compares smaller free-space before larger free-space.
 */
static inline int
uvm_mapent_fspace_cmp(const struct vm_map_entry *e1,
    const struct vm_map_entry *e2)
{
	if (e1->fspace != e2->fspace)
		return (e1->fspace < e2->fspace ? -1 : 1);
	return (e1->start < e2->start ? -1 : e1->start > e2->start);
}

RBT_GENERATE(uaddr_free_rbtree, vm_map_entry, dfree.rbtree,
    uvm_mapent_fspace_cmp);
#endif /* !SMALL_KERNEL */
@


1.23
log
@Remove uaddr_hint allocator

The hint allocator would have to check that the
allocation does not overlap with brk, stack or text
areas. This would make the address selectors too
entagled. Just use the rnd allocator for hinted allocations
in case pivots are used. This also reduces the amount of code somewhat.

ok kettenis visa deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.22 2016/09/16 02:50:54 dlg Exp $	*/
a84 13
/*
 * Free space comparison.
 * Compares smaller free-space before larger free-space.
 */
static inline int
uvm_mapent_fspace_cmp(const struct vm_map_entry *e1,
    const struct vm_map_entry *e2)
{
	if (e1->fspace != e2->fspace)
		return (e1->fspace < e2->fspace ? -1 : 1);
	return (e1->start < e2->start ? -1 : e1->start > e2->start);
}

d1425 13
@


1.22
log
@fix spelling of RBT_NEXT in a comment
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.21 2016/09/16 01:51:40 dlg Exp $	*/
a48 1
struct pool uaddr_hint_pool;
a52 6
/* uvm_addr state for hint based selector. */
struct uaddr_hint_state {
	struct uvm_addr_state		 uaddr;
	vsize_t				 max_dist;
};

a113 1
void			 uaddr_hint_destroy(struct uvm_addr_state *);
a132 4
int			 uaddr_hint_select(struct vm_map *,
			    struct uvm_addr_state*, struct vm_map_entry **,
			    vaddr_t *, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
			    vaddr_t);
a280 2
	pool_init(&uaddr_hint_pool, sizeof(struct uaddr_hint_state), 0,
	    IPL_VM, PR_WAITOK, "uaddrhint", NULL);
a728 110
 * An allocator that selects an address within distance of the hint.
 *
 * If no hint is given, the allocator refuses to allocate.
 */
const struct uvm_addr_functions uaddr_hint_functions = {
	.uaddr_select = &uaddr_hint_select,
	.uaddr_destroy = &uaddr_hint_destroy,
	.uaddr_name = "uaddr_hint"
};

/*
 * Create uaddr_hint state.
 */
struct uvm_addr_state *
uaddr_hint_create(vaddr_t minaddr, vaddr_t maxaddr, vsize_t max_dist)
{
	struct uaddr_hint_state *ua_hint;

	KASSERT(uaddr_hint_pool.pr_size == sizeof(*ua_hint));

	ua_hint = pool_get(&uaddr_hint_pool, PR_WAITOK);
	ua_hint->uaddr.uaddr_minaddr = minaddr;
	ua_hint->uaddr.uaddr_maxaddr = maxaddr;
	ua_hint->uaddr.uaddr_functions = &uaddr_hint_functions;
	ua_hint->max_dist = max_dist;
	return &ua_hint->uaddr;
}

/*
 * Destroy uaddr_hint state.
 */
void
uaddr_hint_destroy(struct uvm_addr_state *uaddr)
{
	pool_put(&uaddr_hint_pool, uaddr);
}

/*
 * Hint selector.
 *
 * Attempts to find an address that is within max_dist of the hint.
 */
int
uaddr_hint_select(struct vm_map *map, struct uvm_addr_state *uaddr_param,
    struct vm_map_entry **entry_out, vaddr_t *addr_out,
    vsize_t sz, vaddr_t align, vaddr_t offset,
    vm_prot_t prot, vaddr_t hint)
{
	struct uaddr_hint_state	*uaddr =
	    (struct uaddr_hint_state *)uaddr_param;
	vsize_t			 before_gap, after_gap;
	vaddr_t			 low, high;
	int			 dir;

	if (hint == 0)
		return ENOMEM;

	/* Calculate upper and lower bound for selected address. */
	high = hint + uaddr->max_dist;
	if (high < hint)	/* overflow */
		high = map->max_offset;
	high = MIN(high, uaddr->uaddr.uaddr_maxaddr);
	if (high < sz)
		return ENOMEM;	/* Protect against underflow. */
	high -= sz;

	/* Calculate lower bound for selected address. */
	low = hint - uaddr->max_dist;
	if (low > hint)		/* underflow */
		low = map->min_offset;
	low = MAX(low, uaddr->uaddr.uaddr_minaddr);

	/* Search strategy setup. */
	before_gap = PAGE_SIZE +
	    (arc4random_uniform(UADDR_HINT_MAXGAP) & ~(vaddr_t)PAGE_MASK);
	after_gap = PAGE_SIZE +
	    (arc4random_uniform(UADDR_HINT_MAXGAP) & ~(vaddr_t)PAGE_MASK);
	dir = (arc4random() & 0x01) ? 1 : -1;

	/*
	 * Try to search:
	 * - forward,  with gap
	 * - backward, with gap
	 * - forward,  without gap
	 * - backward, without gap
	 * (Where forward is in the direction specified by dir and
	 * backward is in the direction specified by -dir).
	 */
	if (uvm_addr_linsearch(map, uaddr_param,
	    entry_out, addr_out, hint, sz, align, offset,
	    dir, low, high, before_gap, after_gap) == 0)
		return 0;
	if (uvm_addr_linsearch(map, uaddr_param,
	    entry_out, addr_out, hint, sz, align, offset,
	    -dir, low, high, before_gap, after_gap) == 0)
		return 0;

	if (uvm_addr_linsearch(map, uaddr_param,
	    entry_out, addr_out, hint, sz, align, offset,
	    dir, low, high, 0, 0) == 0)
		return 0;
	if (uvm_addr_linsearch(map, uaddr_param,
	    entry_out, addr_out, hint, sz, align, offset,
	    -dir, low, high, 0, 0) == 0)
		return 0;

	return ENOMEM;
}

/*
d1121 10
a1130 3
	/* Hint must be handled by dedicated hint allocator. */
	if (hint != 0)
		return EINVAL;
@


1.21
log
@move uaddr_free_rbtree from RB macros to RBT functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.20 2016/09/16 01:09:53 dlg Exp $	*/
d643 1
a643 1
		/* RB_NEXT, but skip subtrees that cannot possible fit. */
@


1.20
log
@move the uvm_map_addr RB tree from RB macros to the RBT functions

this tree is interesting because it uses all the red black tree
features, specifically the augment callback thats called on tree
topology changes, and it poisons and checks entries as theyre removed
from and inserted back into the tree respectively.

ok stefan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.19 2016/09/15 02:00:18 dlg Exp $	*/
d96 3
a98 2
static __inline int
uvm_mapent_fspace_cmp(struct vm_map_entry *e1, struct vm_map_entry *e2)
d200 1
a200 1
	tmp = RB_ROOT(free);
d205 1
a205 1
			tmp = RB_LEFT(tmp, dfree.rbtree);
d207 1
a207 1
			tmp = RB_RIGHT(tmp, dfree.rbtree);
d917 1
a917 1
	RB_INIT(&uaddr->ubf_free);
d935 1
a935 1
	if ((rb_rv = RB_INSERT(uaddr_free_rbtree, &uaddr->ubf_free, entry)) !=
d950 1
a950 1
	if (RB_REMOVE(uaddr_free_rbtree, &uaddr->ubf_free, entry) != entry)
d982 1
a982 1
		entry = RB_NEXT(uaddr_free_rbtree, &uaddr->ubf_free, entry);
d1123 1
a1123 1
	entry = RB_ROOT(&uaddr->up_free);
d1139 1
a1139 1
			entry = RB_RIGHT(entry, dfree.rbtree);
d1142 1
a1142 1
			entry = RB_RIGHT(entry, dfree.rbtree);
d1145 1
a1145 1
			entry = RB_LEFT(entry, dfree.rbtree);
d1319 1
a1319 1
	if ((rb_rv = RB_INSERT(uaddr_free_rbtree, &uaddr->up_free, entry)) !=
d1359 1
a1359 1
	if (RB_REMOVE(uaddr_free_rbtree, &uaddr->up_free, entry) != entry)
d1393 1
a1393 1
	RB_INIT(&uaddr->up_free);
d1426 1
a1426 1
	if (RB_EMPTY(&uaddr->up_free))
d1429 1
a1429 1
	RB_FOREACH(entry, uaddr_free_rbtree, &uaddr->up_free) {
d1555 1
a1555 1
RB_GENERATE(uaddr_free_rbtree, vm_map_entry, dfree.rbtree,
@


1.19
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.18 2016/09/02 16:45:12 stefan Exp $	*/
d385 2
a386 2
	    RB_NEXT(uvm_map_addr, &map->addr, entry) :
	    RB_PREV(uvm_map_addr, &map->addr, entry))) {
d624 1
a624 1
		entry = RB_PARENT(entry, daddrs.addr_entry);
d643 1
a643 1
		next = RB_RIGHT(entry, daddrs.addr_entry);
d647 1
a647 1
			while ((next = RB_LEFT(entry, daddrs.addr_entry)) !=
d652 1
a652 1
			next = RB_PARENT(entry, daddrs.addr_entry);
d655 1
a655 1
			else if (RB_LEFT(next, daddrs.addr_entry) == entry)
d874 1
a874 1
	RB_FOREACH(*entry_out, uvm_map_addr, &map->addr) {
@


1.18
log
@Mask out lower bits of randomly selected address

Fixes uvm pivots bug that would create non-page aligned addresses.
This fix is in code that's not yet enabled.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.17 2016/07/30 16:37:54 kettenis Exp $	*/
d290 10
a299 15
	pool_init(&uaddr_pool, sizeof(struct uvm_addr_state),
	    0, 0, PR_WAITOK, "uaddr", NULL);
	pool_setipl(&uaddr_pool, IPL_VM);
	pool_init(&uaddr_hint_pool, sizeof(struct uaddr_hint_state),
	    0, 0, PR_WAITOK, "uaddrhint", NULL);
	pool_setipl(&uaddr_hint_pool, IPL_VM);
	pool_init(&uaddr_bestfit_pool, sizeof(struct uaddr_bestfit_state),
	    0, 0, PR_WAITOK, "uaddrbest", NULL);
	pool_setipl(&uaddr_bestfit_pool, IPL_VM);
	pool_init(&uaddr_pivot_pool, sizeof(struct uaddr_pivot_state),
	    0, 0, PR_WAITOK, "uaddrpivot", NULL);
	pool_setipl(&uaddr_pivot_pool, IPL_VM);
	pool_init(&uaddr_rnd_pool, sizeof(struct uaddr_rnd_state),
	    0, 0, PR_WAITOK, "uaddrrnd", NULL);
	pool_setipl(&uaddr_rnd_pool, IPL_VM);
@


1.17
log
@Add a few checks for potential integer overflow and underflow related to the
size of an address range.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.16 2016/06/02 18:48:01 tedu Exp $	*/
d1173 1
a1173 1
			    (arc4random() & (align - 1));
d1176 1
a1176 1
			    (arc4random_uniform(arc4_arg) & (align - 1));
@


1.16
log
@print the size when an unavailable address is returned. it is useful.
ok millert stefan
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.15 2016/03/07 18:44:00 naddy Exp $	*/
d257 3
a259 1
	if (fspace < sz + before_gap + after_gap)
d525 1
a525 1
	if (uaddr->uaddr_maxaddr - uaddr->uaddr_minaddr < sz + guard_sz)
d587 2
d971 2
@


1.15
log
@Sync no-argument function declaration and definition by adding (void).
ok mpi@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.14 2015/07/17 21:56:14 kettenis Exp $	*/
d445 1
a445 1
			    "returned unavailable address 0x%lx",
d448 1
a448 1
			    *addr_out);
@


1.14
log
@Release the kernel lock while tearing down the uvm map in the reaper.  Speeds
up workloads that fork a lot of processes and, more importantly reduces
latency because it makes sure the reaper doesn't hold on to the kernel lock
for long periods of time.

This almost certainly breaks MP kernels on alpha, macppc, m88k and sgi;
hppa might work, but probably doesn't.

ok deraadt@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.13 2015/03/30 21:08:40 miod Exp $	*/
d1022 1
a1022 1
uaddr_pivot_random()
@


1.13
log
@Extend uvm_map_hint() to get an address range as extra arguments, and make
sure it will return an address within that range.

Use this in uaddr_rnd_select() to make sure we will not attempt to pick
an address beyond what we are allowed to map.

In my trees for 9 months, blackmailed s2k15 attendees into agreeing now would
be a good time to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.12 2015/03/30 21:05:17 miod Exp $	*/
d290 1
d293 1
d296 1
d299 1
d302 1
@


1.12
log
@#if 0 various unused definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.11 2014/12/23 02:01:57 tedu Exp $	*/
d567 1
d580 4
d585 1
a585 1
	if (uaddr->uaddr_maxaddr - uaddr->uaddr_minaddr < sz + guard_sz)
d590 1
a590 1
		hint = uvm_map_hint(vm, prot);
d592 1
a592 2
	hint = MIN(MAX(hint, uaddr->uaddr_minaddr),
	    uaddr->uaddr_maxaddr - sz - guard_sz);
d598 1
a598 1
	if (hint < tmp || hint > uaddr->uaddr_maxaddr - sz - guard_sz)
@


1.11
log
@convert nointr pool_init argument to pr_waitok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.10 2014/11/18 02:37:31 tedu Exp $	*/
d69 1
d71 1
d126 1
d131 1
d183 1
d186 1
d481 1
d483 1
a483 1
 * Lineair allocator.
d524 1
a524 1

d538 1
d540 1
d554 1
d556 1
d689 1
d731 1
a731 1

@


1.10
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.9 2014/11/13 00:47:44 tedu Exp $	*/
d283 1
a283 1
	    0, 0, 0, "uaddr", &pool_allocator_nointr);
d285 1
a285 1
	    0, 0, 0, "uaddrhint", &pool_allocator_nointr);
d287 1
a287 1
	    0, 0, 0, "uaddrbest", &pool_allocator_nointr);
d289 1
a289 1
	    0, 0, 0, "uaddrpivot", &pool_allocator_nointr);
d291 1
a291 1
	    0, 0, 0, "uaddrrnd", &pool_allocator_nointr);
@


1.9
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.8 2014/06/10 20:08:48 kettenis Exp $	*/
a24 1
#include <dev/rndvar.h>
@


1.8
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.7 2014/04/13 23:14:15 tedu Exp $	*/
d1372 1
a1372 1
	bzero(uaddr->up_pivots, sizeof(uaddr->up_pivots));
@


1.7
log
@compress code by turning four line comments into one line comments.
emphatic ok usual suspects, grudging ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.6 2014/02/04 01:04:03 tedu Exp $	*/
d112 16
a127 16
void			 uaddr_kinsert(struct vm_map*, struct uvm_addr_state*,
			    struct vm_map_entry*);
void			 uaddr_kremove(struct vm_map*, struct uvm_addr_state*,
			    struct vm_map_entry*);
void			 uaddr_kbootstrapdestroy(struct uvm_addr_state*);

void			 uaddr_destroy(struct uvm_addr_state*);
void			 uaddr_hint_destroy(struct uvm_addr_state*);
void			 uaddr_kbootstrap_destroy(struct uvm_addr_state*);
void			 uaddr_rnd_destroy(struct uvm_addr_state*);
void			 uaddr_bestfit_destroy(struct uvm_addr_state*);
void			 uaddr_pivot_destroy(struct uvm_addr_state*);

int			 uaddr_lin_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d129 3
a131 3
int			 uaddr_kbootstrap_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d133 3
a135 3
int			 uaddr_rnd_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d137 3
a139 3
int			 uaddr_hint_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d141 3
a143 3
int			 uaddr_bestfit_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d146 3
a148 3
int			 uaddr_pivot_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d150 3
a152 3
int			 uaddr_stack_brk_select(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    vaddr_t*, vsize_t, vaddr_t, vaddr_t, vm_prot_t,
d156 12
a167 12
void			 uaddr_rnd_insert(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
void			 uaddr_rnd_remove(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
void			 uaddr_bestfit_insert(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
void			 uaddr_bestfit_remove(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
void			 uaddr_pivot_insert(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
void			 uaddr_pivot_remove(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry*);
d171 3
a173 3
int			 uaddr_pivot_newpivot(struct vm_map*,
			    struct uaddr_pivot_state*, struct uaddr_pivot*,
			    struct vm_map_entry**, vaddr_t*,
d178 4
a181 4
void			 uaddr_pivot_print(struct uvm_addr_state*, boolean_t,
			    int (*)(const char*, ...));
void			 uaddr_rnd_print(struct uvm_addr_state*, boolean_t,
			    int (*)(const char*, ...));
d189 1
a189 1
struct vm_map_entry*
d281 1
a281 1
uvm_addr_init()
d347 1
a347 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d411 1
a411 1
    struct vm_map_entry**entry_out, struct vm_map_entry**last_out,
d448 1
a448 1
    int (*pr)(const char*, ...))
d489 1
a489 1
struct uvm_addr_state*
d492 1
a492 1
	struct uvm_addr_state* uaddr;
d503 1
a503 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d537 1
a537 1
struct uvm_addr_state*
d540 1
a540 1
	struct uaddr_rnd_state* uaddr;
d552 1
a552 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d564 1
a564 1
	vm = (struct vmspace*)map;
d690 1
a690 1
	uaddr = (struct uaddr_rnd_state*)uaddr_p;
d736 1
a736 1
struct uvm_addr_state*
d739 1
a739 1
	struct uaddr_hint_state* ua_hint;
d767 1
a767 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d771 2
a772 1
	struct uaddr_hint_state	*uaddr = (struct uaddr_hint_state*)uaddr_param;
d872 1
a872 1
	KASSERT(uaddr == (struct uvm_addr_state*)&uaddr_kbootstrap);
d888 1
a888 1
struct uvm_addr_state*
d914 1
a914 1
	uaddr = (struct uaddr_bestfit_state*)uaddr_p;
d929 1
a929 1
	uaddr = (struct uaddr_bestfit_state*)uaddr_p;
d936 1
a936 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d945 1
a945 1
	uaddr = (struct uaddr_bestfit_state*)uaddr_p;
d1042 1
a1042 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d1212 1
a1212 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d1230 1
a1230 1
	uaddr = (struct uaddr_pivot_state*)uaddr_p;
d1296 1
a1296 1
	uaddr = (struct uaddr_pivot_state*)uaddr_p;
d1336 1
a1336 1
	uaddr = (struct uaddr_pivot_state*)uaddr_p;
d1362 1
a1362 1
struct uvm_addr_state*
d1385 1
a1385 1
    int (*pr)(const char*, ...))
d1393 1
a1393 1
	uaddr = (struct uaddr_pivot_state*)uaddr_p;
d1462 1
a1462 1
    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d1518 1
a1518 1
struct uvm_addr_state*
@


1.6
log
@reduce the length of some pool names. ok deraadt guenther mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.5 2012/07/18 20:28:18 matthew Exp $	*/
d73 1
a73 3
/*
 * Definition of a pivot in pivot selector.
 */
d107 1
a107 5

/*
 * Support functions.
 */

d255 1
a255 3
	/*
	 * Calculate lowest address.
	 */
d263 1
a263 3
	/*
	 * Calculate highest address.
	 */
d362 1
a362 3
	/*
	 * Hint magic.
	 */
a482 1

d509 1
a509 3
	/*
	 * Deal with guardpages: search for space with one extra page.
	 */
a726 1

d779 1
a779 3
	/*
	 * Calculate upper and lower bound for selected address.
	 */
a833 1

d955 1
a955 3
	/*
	 * Walk the tree until we find an entry that fits.
	 */
d964 1
a964 3
	/*
	 * Return the address that generates the least fragmentation.
	 */
d1237 1
a1237 3
	/*
	 * Attempt to use the pivot to map the entry.
	 */
a1449 1

d1488 1
a1488 3
	/*
	 * Set up stack search strategy.
	 */
d1498 1
a1498 3
	/*
	 * Set up brk search strategy.
	 */
d1504 1
a1504 3
	/*
	 * Linear search for space.
	 */
@


1.5
log
@comment typo; s/lineair/linear/
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.4 2012/06/06 04:54:36 matthew Exp $	*/
d298 1
a298 1
	    0, 0, 0, "uaddrbestfit", &pool_allocator_nointr);
@


1.4
log
@Fix address-space randomization that was accidentally disabled in
uvm_addr.c r1.3.

ok deraadt, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.3 2012/04/11 11:23:22 ariane Exp $	*/
d346 1
a346 1
 * Do a lineair search for free space, starting at addr in entry.
@


1.3
log
@vmmap: speed up allocations

Reduces O(n log n) allocations to O(log n).

ok deraadt, tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.2 2012/03/15 17:52:28 ariane Exp $	*/
d632 4
a635 1
			*addr_out = low_addr;
@


1.2
log
@Reduce installmedia pressure from new vmmap.

Has less special allocators on install media (where they aren't required
anyway).
Bonus: makes the vmmap initialization code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.c,v 1.1 2012/03/09 13:01:29 ariane Exp $	*/
d574 1
a574 1
	struct vm_map_entry	*entry;
d604 1
d607 6
a612 1
	 * Find the first entry at or after hint with free space.
d614 1
a614 2
	 * Since we need an entry that is on the free-list, search until
	 * we hit an entry that is owned by our uaddr.
d616 1
a616 10
	for (entry = uvm_map_entrybyaddr(&map->addr, hint);
	    entry != NULL &&
	    uvm_map_uaddr_e(map, entry) != uaddr;
	    entry = RB_NEXT(uvm_map_addr, &map->addr, entry)) {
		/* Fail if we search past uaddr_maxaddr. */
		if (VMMAP_FREE_START(entry) >= uaddr->uaddr_maxaddr) {
			entry = NULL;
			break;
		}
	}
d618 10
a627 4
	for ( /* initial entry filled in above */ ;
	    entry != NULL && VMMAP_FREE_START(entry) < uaddr->uaddr_maxaddr;
	    entry = TAILQ_NEXT(entry, dfree.tailq)) {
		if (uvm_addr_fitspace(&low_addr, &high_addr,
d632 1
a632 4
			if (hint >= low_addr && hint <= high_addr)
				*addr_out = hint;
			else
				*addr_out = low_addr;
d635 21
d658 1
d678 1
a678 28
	struct uaddr_rnd_state	*uaddr;
	struct vm_map_entry	*prev;

	uaddr = (struct uaddr_rnd_state*)uaddr_p;
	KASSERT(entry == RB_FIND(uvm_map_addr, &map->addr, entry));

	/*
	 * Make prev the first vm_map_entry before entry.
	 */
	for (prev = RB_PREV(uvm_map_addr, &map->addr, entry);
	    prev != NULL;
	    prev = RB_PREV(uvm_map_addr, &map->addr, prev)) {
		/* Stop and fail when reaching uaddr minaddr. */
		if (VMMAP_FREE_START(prev) < uaddr_p->uaddr_minaddr) {
			prev = NULL;
			break;
		}

		KASSERT(prev->etype & UVM_ET_FREEMAPPED);
		if (uvm_map_uaddr_e(map, prev) == uaddr_p)
			break;
	}

	/* Perform insertion. */
	if (prev == NULL)
		TAILQ_INSERT_HEAD(&uaddr->ur_free, entry, dfree.tailq);
	else
		TAILQ_INSERT_AFTER(&uaddr->ur_free, prev, entry, dfree.tailq);
d688 1
a688 4
	struct uaddr_rnd_state	*uaddr;

	uaddr = (struct uaddr_rnd_state*)uaddr_p;
	TAILQ_REMOVE(&uaddr->ur_free, entry, dfree.tailq);
@


1.1
log
@New vmmap implementation.

no oks (it is really a pain to review properly)
extensively tested, I'm confident it'll be stable
'now is the time' from several icb inhabitants

Diff provides:
- ability to specify different allocators for different regions/maps
- a simpler implementation of the current allocator
- currently in compatibility mode: it will generate similar addresses
  as the old allocator
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_map.c,v 1.144 2011/07/03 18:36:49 oga Exp $	*/
d114 1
d117 1
d151 1
d160 1
d175 1
d181 1
d191 1
d211 1
d899 1
d1000 1
d1003 1
d1459 1
d1461 1
d1566 1
d1569 1
d1572 1
@

