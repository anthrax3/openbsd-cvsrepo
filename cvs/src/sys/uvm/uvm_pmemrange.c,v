head	1.53;
access;
symbols
	OPENBSD_6_2_BASE:1.53
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.50.0.4
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.44.0.2
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.4
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.2
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.34.0.4
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.2
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17;
locks; strict;
comment	@ * @;


1.53
date	2016.09.16.02.52.24;	author dlg;	state Exp;
branches;
next	1.52;
commitid	stvXyfwEbGVZMDOs;

1.52
date	2016.09.16.02.47.09;	author dlg;	state Exp;
branches;
next	1.51;
commitid	er2YnxHqqQ4UcS7k;

1.51
date	2016.09.16.02.35.42;	author dlg;	state Exp;
branches;
next	1.50;
commitid	Fei4687v68qad1tP;

1.50
date	2016.01.29.11.50.40;	author tb;	state Exp;
branches;
next	1.49;
commitid	wdsCJfnz2IT7Qf4z;

1.49
date	2015.12.06.10.42.43;	author blambert;	state Exp;
branches;
next	1.48;
commitid	QPaJJmSJGkAm41mW;

1.48
date	2015.08.21.16.04.35;	author visa;	state Exp;
branches;
next	1.47;
commitid	gglpDr80UKmkkP9A;

1.47
date	2015.08.19.12.24.30;	author visa;	state Exp;
branches;
next	1.46;
commitid	MMkVublheD8xiUU1;

1.46
date	2015.06.27.21.25.55;	author miod;	state Exp;
branches;
next	1.45;
commitid	pT0LAHZErmJgveRm;

1.45
date	2015.06.20.20.20.08;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	yH3zQCzl9k5OGVP8;

1.44
date	2014.11.13.00.47.44;	author tedu;	state Exp;
branches;
next	1.43;
commitid	t8zRELnW12GnYxX5;

1.43
date	2014.10.03.22.25.58;	author guenther;	state Exp;
branches;
next	1.42;
commitid	ySIgms0mSFhDk0B8;

1.42
date	2014.10.03.18.06.47;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	3JKupIsvM8vNecnK;

1.41
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.40;
commitid	uzzBR7hz9ncd4O6G;

1.40
date	2014.04.13.23.14.15;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2014.04.05.17.18.00;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2014.03.21.21.39.36;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2014.02.06.16.40.40;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2013.01.29.19.55.48;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.21.18.25.27;	author beck;	state Exp;
branches;
next	1.34;

1.34
date	2012.01.05.17.49.45;	author ariane;	state Exp;
branches;
next	1.33;

1.33
date	2011.12.03.20.07.06;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.08.18.25.56;	author ariane;	state Exp;
branches;
next	1.31;

1.31
date	2011.07.08.18.20.10;	author ariane;	state Exp;
branches;
next	1.30;

1.30
date	2011.07.08.18.15.44;	author ariane;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.08.00.10.59;	author tedu;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.07.20.52.50;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.06.19.50.38;	author beck;	state Exp;
branches;
next	1.26;

1.26
date	2011.07.05.19.48.02;	author ariane;	state Exp;
branches;
next	1.25;

1.25
date	2011.06.22.00.16.47;	author ariane;	state Exp;
branches;
next	1.24;

1.24
date	2011.05.30.21.25.08;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2011.05.30.21.23.36;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.06.12.31.10;	author mlarkin;	state Exp;
branches;
next	1.21;

1.21
date	2011.04.05.22.33.51;	author ariane;	state Exp;
branches;
next	1.20;

1.20
date	2011.04.04.22.58.48;	author ariane;	state Exp;
branches;
next	1.19;

1.19
date	2011.04.03.22.07.37;	author ariane;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.28.22.27.47;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.01.21.40.32;	author oga;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.29.20.59.04;	author thib;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.27.03.03.49;	author thib;	state Exp;
branches;
next	1.14;

1.14
date	2010.06.23.09.36.03;	author thib;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.10.08.48.36;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2010.06.10.08.42.23;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2010.04.23.20.42.22;	author ariane;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.22.19.02.55;	author oga;	state Exp;
branches;
next	1.9;

1.9
date	2009.06.16.16.42.41;	author ariane;	state dead;
branches;
next	1.8;

1.8
date	2009.06.14.03.04.08;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.14.02.20.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2009.06.14.02.04.15;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2009.06.12.00.01.21;	author ariane;	state Exp;
branches;
next	1.4;

1.4
date	2009.06.10.20.36.40;	author ariane;	state Exp;
branches;
next	1.3;

1.3
date	2009.06.07.02.01.54;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.04.00.20.53;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2009.06.01.17.42.33;	author ariane;	state Exp;
branches;
next	;


desc
@@


1.53
log
@fix some DEBUG code so its using the right rb tree code
@
text
@/*	$OpenBSD: uvm_pmemrange.c,v 1.52 2016/09/16 02:47:09 dlg Exp $	*/

/*
 * Copyright (c) 2009, 2010 Ariane van der Steldt <ariane@@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <uvm/uvm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/mount.h>

/*
 * 2 trees: addr tree and size tree.
 *
 * The allocator keeps chunks of free pages (called a range).
 * Two pages are part of the same range if:
 * - all pages in between are part of that range,
 * - they are of the same memory type (zeroed or non-zeroed),
 * - they are part of the same pmemrange.
 * A pmemrange is a range of memory which is part of the same vm_physseg
 * and has a use-count.
 *
 * addr tree is vm_page[0].objt
 * size tree is vm_page[1].objt
 *
 * The size tree is not used for memory ranges of 1 page, instead,
 * single queue is vm_page[0].pageq
 *
 * vm_page[0].fpgsz describes the length of a free range. Two adjecent ranges
 * are joined, unless:
 * - they have pages in between them which are not free
 * - they belong to different memtypes (zeroed vs dirty memory)
 * - they are in different pmemrange areas (ISA vs non-ISA memory for instance)
 * - they are not a continuation of the same array
 * The latter issue is caused by vm_physseg ordering and splitting from the
 * MD initialization machinery. The MD code is dependant on freelists and
 * happens to split ISA memory from non-ISA memory.
 * (Note: freelists die die die!)
 *
 * uvm_page_init guarantees that every vm_physseg contains an array of
 * struct vm_page. Also, uvm_page_physload allocates an array of struct
 * vm_page. This code depends on that array. The array may break across
 * vm_physsegs boundaries.
 */

/*
 * Validate the flags of the page. (Used in asserts.)
 * Any free page must have the PQ_FREE flag set.
 * Free pages may be zeroed.
 * Pmap flags are left untouched.
 *
 * The PQ_FREE flag is not checked here: by not checking, we can easily use
 * this check in pages which are freed.
 */
#define VALID_FLAGS(pg_flags)						\
	(((pg_flags) & ~(PQ_FREE|PG_ZERO|PG_PMAPMASK)) == 0x0)

/* Tree comparators. */
int	uvm_pmemrange_addr_cmp(const struct uvm_pmemrange *,
	    const struct uvm_pmemrange *);
int	uvm_pmemrange_use_cmp(struct uvm_pmemrange *, struct uvm_pmemrange *);
int	uvm_pmr_pg_to_memtype(struct vm_page *);

#ifdef DDB
void	uvm_pmr_print(void);
#endif

/*
 * Memory types. The page flags are used to derive what the current memory
 * type of a page is.
 */
int
uvm_pmr_pg_to_memtype(struct vm_page *pg)
{
	if (pg->pg_flags & PG_ZERO)
		return UVM_PMR_MEMTYPE_ZERO;
	/* Default: dirty memory. */
	return UVM_PMR_MEMTYPE_DIRTY;
}

/* Trees. */
RBT_GENERATE(uvm_pmr_addr, vm_page, objt, uvm_pmr_addr_cmp);
RBT_GENERATE(uvm_pmr_size, vm_page, objt, uvm_pmr_size_cmp);
RBT_GENERATE(uvm_pmemrange_addr, uvm_pmemrange, pmr_addr,
    uvm_pmemrange_addr_cmp);

/* Validation. */
#ifdef DEBUG
void	uvm_pmr_assertvalid(struct uvm_pmemrange *pmr);
#else
#define uvm_pmr_assertvalid(pmr)	do {} while (0)
#endif

psize_t			 uvm_pmr_get1page(psize_t, int, struct pglist *,
			    paddr_t, paddr_t, int);

struct uvm_pmemrange	*uvm_pmr_allocpmr(void);
struct vm_page		*uvm_pmr_nfindsz(struct uvm_pmemrange *, psize_t, int);
struct vm_page		*uvm_pmr_nextsz(struct uvm_pmemrange *,
			    struct vm_page *, int);
void			 uvm_pmr_pnaddr(struct uvm_pmemrange *pmr,
			    struct vm_page *pg, struct vm_page **pg_prev,
			    struct vm_page **pg_next);
struct vm_page		*uvm_pmr_findnextsegment(struct uvm_pmemrange *,
			    struct vm_page *, paddr_t);
psize_t			 uvm_pmr_remove_1strange(struct pglist *, paddr_t,
			    struct vm_page **, int);
void			 uvm_pmr_split(paddr_t);
struct uvm_pmemrange	*uvm_pmemrange_find(paddr_t);
struct uvm_pmemrange	*uvm_pmemrange_use_insert(struct uvm_pmemrange_use *,
			    struct uvm_pmemrange *);
psize_t			 pow2divide(psize_t, psize_t);
struct vm_page		*uvm_pmr_rootupdate(struct uvm_pmemrange *,
			    struct vm_page *, paddr_t, paddr_t, int);

/*
 * Computes num/denom and rounds it up to the next power-of-2.
 *
 * This is a division function which calculates an approximation of
 * num/denom, with result =~ num/denom. It is meant to be fast and doesn't
 * have to be accurate.
 *
 * Providing too large a value makes the allocator slightly faster, at the
 * risk of hitting the failure case more often. Providing too small a value
 * makes the allocator a bit slower, but less likely to hit a failure case.
 */
psize_t
pow2divide(psize_t num, psize_t denom)
{
	int rshift;

	for (rshift = 0; num > denom; rshift++, denom <<= 1)
		;
	return (paddr_t)1 << rshift;
}

/*
 * Predicate: lhs is a subrange or rhs.
 *
 * If rhs_low == 0: don't care about lower bound.
 * If rhs_high == 0: don't care about upper bound.
 */
#define PMR_IS_SUBRANGE_OF(lhs_low, lhs_high, rhs_low, rhs_high)	\
	(((rhs_low) == 0 || (lhs_low) >= (rhs_low)) &&			\
	((rhs_high) == 0 || (lhs_high) <= (rhs_high)))

/*
 * Predicate: lhs intersects with rhs.
 *
 * If rhs_low == 0: don't care about lower bound.
 * If rhs_high == 0: don't care about upper bound.
 * Ranges don't intersect if they don't have any page in common, array
 * semantics mean that < instead of <= should be used here.
 */
#define PMR_INTERSECTS_WITH(lhs_low, lhs_high, rhs_low, rhs_high)	\
	(((rhs_low) == 0 || (rhs_low) < (lhs_high)) &&			\
	((rhs_high) == 0 || (lhs_low) < (rhs_high)))

/*
 * Align to power-of-2 alignment.
 */
#define PMR_ALIGN(pgno, align)						\
	(((pgno) + ((align) - 1)) & ~((align) - 1))


/*
 * Comparator: sort by address ascending.
 */
int
uvm_pmemrange_addr_cmp(const struct uvm_pmemrange *lhs,
    const struct uvm_pmemrange *rhs)
{
	return lhs->low < rhs->low ? -1 : lhs->low > rhs->low;
}

/*
 * Comparator: sort by use ascending.
 *
 * The higher the use value of a range, the more devices need memory in
 * this range. Therefore allocate from the range with the lowest use first.
 */
int
uvm_pmemrange_use_cmp(struct uvm_pmemrange *lhs, struct uvm_pmemrange *rhs)
{
	int result;

	result = lhs->use < rhs->use ? -1 : lhs->use > rhs->use;
	if (result == 0)
		result = uvm_pmemrange_addr_cmp(lhs, rhs);
	return result;
}

int
uvm_pmr_addr_cmp(const struct vm_page *lhs, const struct vm_page *rhs)
{
	paddr_t lhs_addr, rhs_addr;

	lhs_addr = VM_PAGE_TO_PHYS(lhs);
	rhs_addr = VM_PAGE_TO_PHYS(rhs);

	return (lhs_addr < rhs_addr ? -1 : lhs_addr > rhs_addr);
}

int
uvm_pmr_size_cmp(const struct vm_page *lhs, const struct vm_page *rhs)
{
	psize_t lhs_size, rhs_size;
	int cmp;

	/* Using second tree, so we receive pg[1] instead of pg[0]. */
	lhs_size = (lhs - 1)->fpgsz;
	rhs_size = (rhs - 1)->fpgsz;

	cmp = (lhs_size < rhs_size ? -1 : lhs_size > rhs_size);
	if (cmp == 0)
		cmp = uvm_pmr_addr_cmp(lhs - 1, rhs - 1);
	return cmp;
}

/*
 * Find the first range of free pages that is at least sz pages long.
 */
struct vm_page *
uvm_pmr_nfindsz(struct uvm_pmemrange *pmr, psize_t sz, int mti)
{
	struct	vm_page *node, *best;

	KASSERT(sz >= 1);

	if (sz == 1 && !TAILQ_EMPTY(&pmr->single[mti]))
		return TAILQ_FIRST(&pmr->single[mti]);

	node = RBT_ROOT(uvm_pmr_size, &pmr->size[mti]);
	best = NULL;
	while (node != NULL) {
		if ((node - 1)->fpgsz >= sz) {
			best = (node - 1);
			node = RBT_LEFT(uvm_objtree, node);
		} else
			node = RBT_RIGHT(uvm_objtree, node);
	}
	return best;
}

/*
 * Finds the next range. The next range has a size >= pg->fpgsz.
 * Returns NULL if no more ranges are available.
 */
struct vm_page *
uvm_pmr_nextsz(struct uvm_pmemrange *pmr, struct vm_page *pg, int mt)
{
	struct vm_page *npg;

	KASSERT(pmr != NULL && pg != NULL);
	if (pg->fpgsz == 1) {
		if (TAILQ_NEXT(pg, pageq) != NULL)
			return TAILQ_NEXT(pg, pageq);
		else
			npg = RBT_MIN(uvm_pmr_size, &pmr->size[mt]);
	} else
		npg = RBT_NEXT(uvm_pmr_size, pg + 1);

	return npg == NULL ? NULL : npg - 1;
}

/*
 * Finds the previous and next ranges relative to the (uninserted) pg range.
 *
 * *pg_prev == NULL if no previous range is available, that can join with
 * 	pg.
 * *pg_next == NULL if no next range is available, that can join with
 * 	pg.
 */
void
uvm_pmr_pnaddr(struct uvm_pmemrange *pmr, struct vm_page *pg,
    struct vm_page **pg_prev, struct vm_page **pg_next)
{
	KASSERT(pg_prev != NULL && pg_next != NULL);

	*pg_next = RBT_NFIND(uvm_pmr_addr, &pmr->addr, pg);
	if (*pg_next == NULL)
		*pg_prev = RBT_MAX(uvm_pmr_addr, &pmr->addr);
	else
		*pg_prev = RBT_PREV(uvm_pmr_addr, *pg_next);

	KDASSERT(*pg_next == NULL ||
	    VM_PAGE_TO_PHYS(*pg_next) > VM_PAGE_TO_PHYS(pg));
	KDASSERT(*pg_prev == NULL ||
	    VM_PAGE_TO_PHYS(*pg_prev) < VM_PAGE_TO_PHYS(pg));

	/* Reset if not contig. */
	if (*pg_prev != NULL &&
	    (atop(VM_PAGE_TO_PHYS(*pg_prev)) + (*pg_prev)->fpgsz
	    != atop(VM_PAGE_TO_PHYS(pg)) ||
	    *pg_prev + (*pg_prev)->fpgsz != pg || /* Array broke. */
	    uvm_pmr_pg_to_memtype(*pg_prev) != uvm_pmr_pg_to_memtype(pg)))
		*pg_prev = NULL;
	if (*pg_next != NULL &&
	    (atop(VM_PAGE_TO_PHYS(pg)) + pg->fpgsz
	    != atop(VM_PAGE_TO_PHYS(*pg_next)) ||
	    pg + pg->fpgsz != *pg_next || /* Array broke. */
	    uvm_pmr_pg_to_memtype(*pg_next) != uvm_pmr_pg_to_memtype(pg)))
		*pg_next = NULL;
	return;
}

/*
 * Remove a range from the address tree.
 * Address tree maintains pmr counters.
 */
void
uvm_pmr_remove_addr(struct uvm_pmemrange *pmr, struct vm_page *pg)
{
	KDASSERT(RBT_FIND(uvm_pmr_addr, &pmr->addr, pg) == pg);
	KDASSERT(pg->pg_flags & PQ_FREE);
	RBT_REMOVE(uvm_pmr_addr, &pmr->addr, pg);

	pmr->nsegs--;
}
/*
 * Remove a range from the size tree.
 */
void
uvm_pmr_remove_size(struct uvm_pmemrange *pmr, struct vm_page *pg)
{
	int memtype;
#ifdef DEBUG
	struct vm_page *i;
#endif

	KDASSERT(pg->fpgsz >= 1);
	KDASSERT(pg->pg_flags & PQ_FREE);
	memtype = uvm_pmr_pg_to_memtype(pg);

	if (pg->fpgsz == 1) {
#ifdef DEBUG
		TAILQ_FOREACH(i, &pmr->single[memtype], pageq) {
			if (i == pg)
				break;
		}
		KDASSERT(i == pg);
#endif
		TAILQ_REMOVE(&pmr->single[memtype], pg, pageq);
	} else {
		KDASSERT(RBT_FIND(uvm_pmr_size, &pmr->size[memtype],
		    pg + 1) == pg + 1);
		RBT_REMOVE(uvm_pmr_size, &pmr->size[memtype], pg + 1);
	}
}
/* Remove from both trees. */
void
uvm_pmr_remove(struct uvm_pmemrange *pmr, struct vm_page *pg)
{
	uvm_pmr_assertvalid(pmr);
	uvm_pmr_remove_size(pmr, pg);
	uvm_pmr_remove_addr(pmr, pg);
	uvm_pmr_assertvalid(pmr);
}

/*
 * Insert the range described in pg.
 * Returns the range thus created (which may be joined with the previous and
 * next ranges).
 * If no_join, the caller guarantees that the range cannot possibly join
 * with adjecent ranges.
 */
struct vm_page *
uvm_pmr_insert_addr(struct uvm_pmemrange *pmr, struct vm_page *pg, int no_join)
{
	struct vm_page *prev, *next;

#ifdef DEBUG
	struct vm_page *i;
	int mt;
#endif

	KDASSERT(pg->pg_flags & PQ_FREE);
	KDASSERT(pg->fpgsz >= 1);

#ifdef DEBUG
	for (mt = 0; mt < UVM_PMR_MEMTYPE_MAX; mt++) {
		TAILQ_FOREACH(i, &pmr->single[mt], pageq)
			KDASSERT(i != pg);
		if (pg->fpgsz > 1) {
			KDASSERT(RBT_FIND(uvm_pmr_size, &pmr->size[mt],
			    pg + 1) == NULL);
		}
		KDASSERT(RBT_FIND(uvm_pmr_addr, &pmr->addr, pg) == NULL);
	}
#endif

	if (!no_join) {
		uvm_pmr_pnaddr(pmr, pg, &prev, &next);
		if (next != NULL) {
			uvm_pmr_remove_size(pmr, next);
			uvm_pmr_remove_addr(pmr, next);
			pg->fpgsz += next->fpgsz;
			next->fpgsz = 0;
		}
		if (prev != NULL) {
			uvm_pmr_remove_size(pmr, prev);
			prev->fpgsz += pg->fpgsz;
			pg->fpgsz = 0;
			return prev;
		}
	}

	RBT_INSERT(uvm_pmr_addr, &pmr->addr, pg);

	pmr->nsegs++;

	return pg;
}
/*
 * Insert the range described in pg.
 * Returns the range thus created (which may be joined with the previous and
 * next ranges).
 * Page must already be in the address tree.
 */
void
uvm_pmr_insert_size(struct uvm_pmemrange *pmr, struct vm_page *pg)
{
	int memtype;
#ifdef DEBUG
	struct vm_page *i;
	int mti;
#endif

	KDASSERT(pg->fpgsz >= 1);
	KDASSERT(pg->pg_flags & PQ_FREE);

	memtype = uvm_pmr_pg_to_memtype(pg);
#ifdef DEBUG
	for (mti = 0; mti < UVM_PMR_MEMTYPE_MAX; mti++) {
		TAILQ_FOREACH(i, &pmr->single[mti], pageq)
			KDASSERT(i != pg);
		if (pg->fpgsz > 1) {
			KDASSERT(RBT_FIND(uvm_pmr_size, &pmr->size[mti],
			    pg + 1) == NULL);
		}
		KDASSERT(RBT_FIND(uvm_pmr_addr, &pmr->addr, pg) == pg);
	}
	for (i = pg; i < pg + pg->fpgsz; i++)
		KASSERT(uvm_pmr_pg_to_memtype(i) == memtype);
#endif

	if (pg->fpgsz == 1)
		TAILQ_INSERT_TAIL(&pmr->single[memtype], pg, pageq);
	else
		RBT_INSERT(uvm_pmr_size, &pmr->size[memtype], pg + 1);
}
/* Insert in both trees. */
struct vm_page *
uvm_pmr_insert(struct uvm_pmemrange *pmr, struct vm_page *pg, int no_join)
{
	uvm_pmr_assertvalid(pmr);
	pg = uvm_pmr_insert_addr(pmr, pg, no_join);
	uvm_pmr_insert_size(pmr, pg);
	uvm_pmr_assertvalid(pmr);
	return pg;
}

/*
 * Find the last page that is part of this segment.
 * => pg: the range at which to start the search.
 * => boundary: the page number boundary specification (0 = no boundary).
 * => pmr: the pmemrange of the page.
 * 
 * This function returns 1 before the next range, so if you want to have the
 * next range, you need to run TAILQ_NEXT(result, pageq) after calling.
 * The reason is that this way, the length of the segment is easily
 * calculated using: atop(result) - atop(pg) + 1.
 * Hence this function also never returns NULL.
 */
struct vm_page *
uvm_pmr_findnextsegment(struct uvm_pmemrange *pmr,
    struct vm_page *pg, paddr_t boundary)
{
	paddr_t	first_boundary;
	struct	vm_page *next;
	struct	vm_page *prev;

	KDASSERT(pmr->low <= atop(VM_PAGE_TO_PHYS(pg)) &&
	    pmr->high > atop(VM_PAGE_TO_PHYS(pg)));
	if (boundary != 0) {
		first_boundary =
		    PMR_ALIGN(atop(VM_PAGE_TO_PHYS(pg)) + 1, boundary);
	} else
		first_boundary = 0;

	/*
	 * Increase next until it hits the first page of the next segment.
	 *
	 * While loop checks the following:
	 * - next != NULL	we have not reached the end of pgl
	 * - boundary == 0 || next < first_boundary
	 *			we do not cross a boundary
	 * - atop(prev) + 1 == atop(next)
	 *			still in the same segment
	 * - low <= last
	 * - high > last	still in the same memory range
	 * - memtype is equal	allocator is unable to view different memtypes
	 *			as part of the same segment
	 * - prev + 1 == next	no array breakage occurs
	 */
	prev = pg;
	next = TAILQ_NEXT(prev, pageq);
	while (next != NULL &&
	    (boundary == 0 || atop(VM_PAGE_TO_PHYS(next)) < first_boundary) &&
	    atop(VM_PAGE_TO_PHYS(prev)) + 1 == atop(VM_PAGE_TO_PHYS(next)) &&
	    pmr->low <= atop(VM_PAGE_TO_PHYS(next)) &&
	    pmr->high > atop(VM_PAGE_TO_PHYS(next)) &&
	    uvm_pmr_pg_to_memtype(prev) == uvm_pmr_pg_to_memtype(next) &&
	    prev + 1 == next) {
		prev = next;
		next = TAILQ_NEXT(prev, pageq);
	}

	/*
	 * End of this segment.
	 */
	return prev;
}

/*
 * Remove the first segment of contiguous pages from pgl.
 * A segment ends if it crosses boundary (unless boundary = 0) or
 * if it would enter a different uvm_pmemrange.
 *
 * Work: the page range that the caller is currently working with.
 * May be null.
 *
 * If is_desperate is non-zero, the smallest segment is erased. Otherwise,
 * the first segment is erased (which, if called by uvm_pmr_getpages(),
 * probably is the smallest or very close to it).
 */
psize_t
uvm_pmr_remove_1strange(struct pglist *pgl, paddr_t boundary,
    struct vm_page **work, int is_desperate)
{
	struct vm_page *start, *end, *iter, *iter_end, *inserted;
	psize_t count;
	struct uvm_pmemrange *pmr, *pmr_iter;

	KASSERT(!TAILQ_EMPTY(pgl));

	/*
	 * Initialize to first page.
	 * Unless desperate scan finds a better candidate, this is what'll be
	 * erased.
	 */
	start = TAILQ_FIRST(pgl);
	pmr = uvm_pmemrange_find(atop(VM_PAGE_TO_PHYS(start)));
	end = uvm_pmr_findnextsegment(pmr, start, boundary);

	/*
	 * If we are desperate, we _really_ want to get rid of the smallest
	 * element (rather than a close match to the smallest element).
	 */
	if (is_desperate) {
		/* Linear search for smallest segment. */
		pmr_iter = pmr;
		for (iter = TAILQ_NEXT(end, pageq);
		    iter != NULL && start != end;
		    iter = TAILQ_NEXT(iter_end, pageq)) {
			/*
			 * Only update pmr if it doesn't match current
			 * iteration.
			 */
			if (pmr->low > atop(VM_PAGE_TO_PHYS(iter)) ||
			    pmr->high <= atop(VM_PAGE_TO_PHYS(iter))) {
				pmr_iter = uvm_pmemrange_find(atop(
				    VM_PAGE_TO_PHYS(iter)));
			}

			iter_end = uvm_pmr_findnextsegment(pmr_iter, iter,
			    boundary);

			/*
			 * Current iteration is smaller than best match so
			 * far; update.
			 */
			if (VM_PAGE_TO_PHYS(iter_end) - VM_PAGE_TO_PHYS(iter) <
			    VM_PAGE_TO_PHYS(end) - VM_PAGE_TO_PHYS(start)) {
				start = iter;
				end = iter_end;
				pmr = pmr_iter;
			}
		}
	}

	/*
	 * Calculate count and end of the list.
	 */
	count = atop(VM_PAGE_TO_PHYS(end) - VM_PAGE_TO_PHYS(start)) + 1;
	end = TAILQ_NEXT(end, pageq);

	/*
	 * Actually remove the range of pages.
	 *
	 * Sadly, this cannot be done using pointer iteration:
	 * vm_physseg is not guaranteed to be sorted on address, hence
	 * uvm_page_init() may not have initialized its array sorted by
	 * page number.
	 */
	for (iter = start; iter != end; iter = iter_end) {
		iter_end = TAILQ_NEXT(iter, pageq);
		TAILQ_REMOVE(pgl, iter, pageq);
	}

	start->fpgsz = count;
	inserted = uvm_pmr_insert(pmr, start, 0);

	/*
	 * If the caller was working on a range and this function modified
	 * that range, update the pointer.
	 */
	if (work != NULL && *work != NULL &&
	    atop(VM_PAGE_TO_PHYS(inserted)) <= atop(VM_PAGE_TO_PHYS(*work)) &&
	    atop(VM_PAGE_TO_PHYS(inserted)) + inserted->fpgsz >
	    atop(VM_PAGE_TO_PHYS(*work)))
		*work = inserted;
	return count;
}

/*
 * Extract a number of pages from a segment of free pages.
 * Called by uvm_pmr_getpages.
 *
 * Returns the segment that was created from pages left over at the tail
 * of the remove set of pages, or NULL if no pages were left at the tail.
 */
struct vm_page *
uvm_pmr_extract_range(struct uvm_pmemrange *pmr, struct vm_page *pg,
    paddr_t start, paddr_t end, struct pglist *result)
{
	struct vm_page *after, *pg_i;
	psize_t before_sz, after_sz;
#ifdef DEBUG
	psize_t i;
#endif

	KDASSERT(end > start);
	KDASSERT(pmr->low <= atop(VM_PAGE_TO_PHYS(pg)));
	KDASSERT(pmr->high >= atop(VM_PAGE_TO_PHYS(pg)) + pg->fpgsz);
	KDASSERT(atop(VM_PAGE_TO_PHYS(pg)) <= start);
	KDASSERT(atop(VM_PAGE_TO_PHYS(pg)) + pg->fpgsz >= end);

	before_sz = start - atop(VM_PAGE_TO_PHYS(pg));
	after_sz = atop(VM_PAGE_TO_PHYS(pg)) + pg->fpgsz - end;
	KDASSERT(before_sz + after_sz + (end - start) == pg->fpgsz);
	uvm_pmr_assertvalid(pmr);

	uvm_pmr_remove_size(pmr, pg);
	if (before_sz == 0)
		uvm_pmr_remove_addr(pmr, pg);
	after = pg + before_sz + (end - start);

	/* Add selected pages to result. */
	for (pg_i = pg + before_sz; pg_i != after; pg_i++) {
		KASSERT(pg_i->pg_flags & PQ_FREE);
		pg_i->fpgsz = 0;
		TAILQ_INSERT_TAIL(result, pg_i, pageq);
	}

	/* Before handling. */
	if (before_sz > 0) {
		pg->fpgsz = before_sz;
		uvm_pmr_insert_size(pmr, pg);
	}

	/* After handling. */
	if (after_sz > 0) {
#ifdef DEBUG
		for (i = 0; i < after_sz; i++) {
			KASSERT(!uvm_pmr_isfree(after + i));
		}
#endif
		KDASSERT(atop(VM_PAGE_TO_PHYS(after)) == end);
		after->fpgsz = after_sz;
		after = uvm_pmr_insert_addr(pmr, after, 1);
		uvm_pmr_insert_size(pmr, after);
	}

	uvm_pmr_assertvalid(pmr);
	return (after_sz > 0 ? after : NULL);
}

/*
 * Acquire a number of pages.
 *
 * count:	the number of pages returned
 * start:	lowest page number
 * end:		highest page number +1
 * 		(start = end = 0: no limitation)
 * align:	power-of-2 alignment constraint (align = 1: no alignment)
 * boundary:	power-of-2 boundary (boundary = 0: no boundary)
 * maxseg:	maximum number of segments to return
 * flags:	UVM_PLA_* flags
 * result:	returned pages storage (uses pageq)
 */
int
uvm_pmr_getpages(psize_t count, paddr_t start, paddr_t end, paddr_t align,
    paddr_t boundary, int maxseg, int flags, struct pglist *result)
{
	struct	uvm_pmemrange *pmr;	/* Iterate memory ranges. */
	struct	vm_page *found, *f_next; /* Iterate chunks. */
	psize_t	fcount;			/* Current found pages. */
	int	fnsegs;			/* Current segment counter. */
	int	try, start_try;
	psize_t	search[3];
	paddr_t	fstart, fend;		/* Pages to be taken from found. */
	int	memtype;		/* Requested memtype. */
	int	memtype_init;		/* Best memtype. */
	int	desperate;		/* True if allocation failed. */
#ifdef DIAGNOSTIC
	struct	vm_page *diag_prev;	/* Used during validation. */
#endif /* DIAGNOSTIC */

	/*
	 * Validate arguments.
	 */
	KASSERT(count > 0);
	KASSERT(start == 0 || end == 0 || start < end);
	KASSERT(align >= 1);
	KASSERT(powerof2(align));
	KASSERT(maxseg > 0);
	KASSERT(boundary == 0 || powerof2(boundary));
	KASSERT(boundary == 0 || maxseg * boundary >= count);
	KASSERT(TAILQ_EMPTY(result));

	/*
	 * TRYCONTIG is a noop if you only want a single segment.
	 * Remove it if that's the case: otherwise it'll deny the fast
	 * allocation.
	 */
	if (maxseg == 1 || count == 1)
		flags &= ~UVM_PLA_TRYCONTIG;

	/*
	 * Configure search.
	 *
	 * search[0] is one segment, only used in UVM_PLA_TRYCONTIG case.
	 * search[1] is multiple segments, chosen to fulfill the search in
	 *   approximately even-sized segments.
	 *   This is a good trade-off between slightly reduced allocation speed
	 *   and less fragmentation.
	 * search[2] is the worst case, in which all segments are evaluated.
	 *   This provides the least fragmentation, but makes the search
	 *   possibly longer (although in the case it is selected, that no
	 *   longer matters most).
	 *
	 * The exception is when maxseg == 1: since we can only fulfill that
	 * with one segment of size pages, only a single search type has to
	 * be attempted.
	 */
	if (maxseg == 1 || count == 1) {
		start_try = 2;
		search[2] = count;
	} else if (maxseg >= count && (flags & UVM_PLA_TRYCONTIG) == 0) {
		start_try = 2;
		search[2] = 1;
	} else {
		start_try = 0;
		search[0] = count;
		search[1] = pow2divide(count, maxseg);
		search[2] = 1;
		if ((flags & UVM_PLA_TRYCONTIG) == 0)
			start_try = 1;
		if (search[1] >= search[0]) {
			search[1] = search[0];
			start_try = 1;
		}
		if (search[2] >= search[start_try]) {
			start_try = 2;
		}
	}

	/*
	 * Memory type: if zeroed memory is requested, traverse the zero set.
	 * Otherwise, traverse the dirty set.
	 *
	 * The memtype iterator is reinitialized to memtype_init on entrance
	 * of a pmemrange.
	 */
	if (flags & UVM_PLA_ZERO)
		memtype_init = UVM_PMR_MEMTYPE_ZERO;
	else
		memtype_init = UVM_PMR_MEMTYPE_DIRTY;

	/*
	 * Initially, we're not desperate.
	 *
	 * Note that if we return from a sleep, we are still desperate.
	 * Chances are that memory pressure is still high, so resetting
	 * seems over-optimistic to me.
	 */
	desperate = 0;

	uvm_lock_fpageq();

retry:		/* Return point after sleeping. */
	fcount = 0;
	fnsegs = 0;

retry_desperate:
	/*
	 * If we just want any page(s), go for the really fast option.
	 */
	if (count <= maxseg && align == 1 && boundary == 0 &&
	    (flags & UVM_PLA_TRYCONTIG) == 0) {
		fcount += uvm_pmr_get1page(count - fcount, memtype_init,
		    result, start, end, 0);

		/*
		 * If we found sufficient pages, go to the succes exit code.
		 *
		 * Otherwise, go immediately to fail, since we collected
		 * all we could anyway.
		 */
		if (fcount == count)
			goto out;
		else
			goto fail;
	}

	/*
	 * The heart of the contig case.
	 *
	 * The code actually looks like this:
	 *
	 * foreach (struct pmemrange) {
	 *	foreach (memtype) {
	 *		foreach(try) {
	 *			foreach (free range of memtype in pmemrange,
	 *			    starting at search[try]) {
	 *				while (range has space left)
	 *					take from range
	 *			}
	 *		}
	 *	}
	 *
	 *	if next pmemrange has higher usecount than current:
	 *		enter desperate case (which will drain the pmemranges
	 *		until empty prior to moving to the next one)
	 * }
	 *
	 * When desperate is activated, try always starts at the highest
	 * value. The memtype loop is using a goto ReScanMemtype.
	 * The try loop is using a goto ReScan.
	 * The 'range has space left' loop uses label DrainFound.
	 *
	 * Writing them all as loops would take up a lot of screen space in
	 * the form of indentation and some parts are easier to express
	 * using the labels.
	 */

	TAILQ_FOREACH(pmr, &uvm.pmr_control.use, pmr_use) {
		/* Empty range. */
		if (pmr->nsegs == 0)
			continue;

		/* Outside requested range. */
		if (!PMR_INTERSECTS_WITH(pmr->low, pmr->high, start, end))
			continue;

		memtype = memtype_init;

rescan_memtype:	/* Return point at memtype++. */
		try = start_try;

rescan:		/* Return point at try++. */
		for (found = uvm_pmr_nfindsz(pmr, search[try], memtype);
		    found != NULL;
		    found = f_next) {
			f_next = uvm_pmr_nextsz(pmr, found, memtype);

			fstart = atop(VM_PAGE_TO_PHYS(found));
			if (start != 0)
				fstart = MAX(start, fstart);
drain_found:
			/*
			 * Throw away the first segment if fnsegs == maxseg
			 *
			 * Note that f_next is still valid after this call,
			 * since we only allocated from entries before f_next.
			 * We don't revisit the entries we already extracted
			 * from unless we entered the desperate case.
			 */
			if (fnsegs == maxseg) {
				fnsegs--;
				fcount -=
				    uvm_pmr_remove_1strange(result, boundary,
				    &found, desperate);
			}

			fstart = PMR_ALIGN(fstart, align);
			fend = atop(VM_PAGE_TO_PHYS(found)) + found->fpgsz;
			if (end != 0)
				fend = MIN(end, fend);
			if (boundary != 0) {
				fend =
				    MIN(fend, PMR_ALIGN(fstart + 1, boundary));
			}
			if (fstart >= fend)
				continue;
			if (fend - fstart > count - fcount)
				fend = fstart + (count - fcount);

			fcount += fend - fstart;
			fnsegs++;
			found = uvm_pmr_extract_range(pmr, found,
			    fstart, fend, result);

			if (fcount == count)
				goto out;

			/*
			 * If there's still space left in found, try to
			 * fully drain it prior to continueing.
			 */
			if (found != NULL) {
				fstart = fend;
				goto drain_found;
			}
		}

		/* Try a smaller search now. */
		if (++try < nitems(search))
			goto rescan;

		/*
		 * Exhaust all memory types prior to going to the next memory
		 * segment.
		 * This means that zero-vs-dirty are eaten prior to moving
		 * to a pmemrange with a higher use-count.
		 *
		 * Code is basically a difficult way of writing:
		 * memtype = memtype_init;
		 * do {
		 *	...;
		 *	memtype += 1;
		 *	memtype %= MEMTYPE_MAX;
		 * } while (memtype != memtype_init);
		 */
		memtype += 1;
		if (memtype == UVM_PMR_MEMTYPE_MAX)
			memtype = 0;
		if (memtype != memtype_init)
			goto rescan_memtype;

		/*
		 * If not desperate, enter desperate case prior to eating all
		 * the good stuff in the next range.
		 */
		if (!desperate && TAILQ_NEXT(pmr, pmr_use) != NULL &&
		    TAILQ_NEXT(pmr, pmr_use)->use != pmr->use)
			break;
	}

	/*
	 * Not enough memory of the requested type available. Fall back to
	 * less good memory that we'll clean up better later.
	 *
	 * This algorithm is not very smart though, it just starts scanning
	 * a different typed range, but the nicer ranges of the previous
	 * iteration may fall out. Hence there is a small chance of a false
	 * negative.
	 *
	 * When desparate: scan all sizes starting at the smallest
	 * (start_try = 1) and do not consider UVM_PLA_TRYCONTIG (which may
	 * allow us to hit the fast path now).
	 *
	 * Also, because we will revisit entries we scanned before, we need
	 * to reset the page queue, or we may end up releasing entries in
	 * such a way as to invalidate f_next.
	 */
	if (!desperate) {
		desperate = 1;
		start_try = nitems(search) - 1;
		flags &= ~UVM_PLA_TRYCONTIG;

		while (!TAILQ_EMPTY(result))
			uvm_pmr_remove_1strange(result, 0, NULL, 0);
		fnsegs = 0;
		fcount = 0;
		goto retry_desperate;
	}

fail:
	/* Allocation failed. */
	/* XXX: claim from memory reserve here */

	while (!TAILQ_EMPTY(result))
		uvm_pmr_remove_1strange(result, 0, NULL, 0);

	if (flags & UVM_PLA_WAITOK) {
		if (uvm_wait_pla(ptoa(start), ptoa(end) - 1, ptoa(count),
		    flags & UVM_PLA_FAILOK) == 0)
			goto retry;
		KASSERT(flags & UVM_PLA_FAILOK);
	} else
		wakeup(&uvm.pagedaemon);
	uvm_unlock_fpageq();

	return ENOMEM;

out:
	/* Allocation succesful. */
	uvmexp.free -= fcount;

	uvm_unlock_fpageq();

	/* Update statistics and zero pages if UVM_PLA_ZERO. */
#ifdef DIAGNOSTIC
	fnsegs = 0;
	fcount = 0;
	diag_prev = NULL;
#endif /* DIAGNOSTIC */
	TAILQ_FOREACH(found, result, pageq) {
		atomic_clearbits_int(&found->pg_flags, PG_PMAPMASK);

		if (found->pg_flags & PG_ZERO) {
			uvm_lock_fpageq();
			uvmexp.zeropages--;
			if (uvmexp.zeropages < UVM_PAGEZERO_TARGET)
				wakeup(&uvmexp.zeropages);
			uvm_unlock_fpageq();
		}
		if (flags & UVM_PLA_ZERO) {
			if (found->pg_flags & PG_ZERO)
				uvmexp.pga_zerohit++;
			else {
				uvmexp.pga_zeromiss++;
				uvm_pagezero(found);
			}
		}
		atomic_clearbits_int(&found->pg_flags, PG_ZERO|PQ_FREE);

		found->uobject = NULL;
		found->uanon = NULL;
		found->pg_version++;

		/*
		 * Validate that the page matches range criterium.
		 */
		KDASSERT(start == 0 || atop(VM_PAGE_TO_PHYS(found)) >= start);
		KDASSERT(end == 0 || atop(VM_PAGE_TO_PHYS(found)) < end);

#ifdef DIAGNOSTIC
		/*
		 * Update fcount (# found pages) and
		 * fnsegs (# found segments) counters.
		 */
		if (diag_prev == NULL ||
		    /* new segment if it contains a hole */
		    atop(VM_PAGE_TO_PHYS(diag_prev)) + 1 !=
		    atop(VM_PAGE_TO_PHYS(found)) ||
		    /* new segment if it crosses boundary */
		    (atop(VM_PAGE_TO_PHYS(diag_prev)) & ~(boundary - 1)) !=
		    (atop(VM_PAGE_TO_PHYS(found)) & ~(boundary - 1)))
			fnsegs++;
		fcount++;

		diag_prev = found;
#endif /* DIAGNOSTIC */
	}

#ifdef DIAGNOSTIC
	/*
	 * Panic on algorithm failure.
	 */
	if (fcount != count || fnsegs > maxseg) {
		panic("pmemrange allocation error: "
		    "allocated %ld pages in %d segments, "
		    "but request was %ld pages in %d segments",
		    fcount, fnsegs, count, maxseg);
	}
#endif /* DIAGNOSTIC */

	return 0;
}

/*
 * Free a number of contig pages (invoked by uvm_page_init).
 */
void
uvm_pmr_freepages(struct vm_page *pg, psize_t count)
{
	struct uvm_pmemrange *pmr;
	psize_t i, pmr_count;
	struct vm_page *firstpg = pg;

	for (i = 0; i < count; i++) {
		KASSERT(atop(VM_PAGE_TO_PHYS(&pg[i])) ==
		    atop(VM_PAGE_TO_PHYS(pg)) + i);

		if (!((pg[i].pg_flags & PQ_FREE) == 0 &&
		    VALID_FLAGS(pg[i].pg_flags))) {
			printf("Flags: 0x%x, will panic now.\n",
			    pg[i].pg_flags);
		}
		KASSERT((pg[i].pg_flags & PQ_FREE) == 0 &&
		    VALID_FLAGS(pg[i].pg_flags));
		atomic_setbits_int(&pg[i].pg_flags, PQ_FREE);
		atomic_clearbits_int(&pg[i].pg_flags, PG_ZERO);
	}

	uvm_lock_fpageq();

	for (i = count; i > 0; i -= pmr_count) {
		pmr = uvm_pmemrange_find(atop(VM_PAGE_TO_PHYS(pg)));
		KASSERT(pmr != NULL);

		pmr_count = MIN(i, pmr->high - atop(VM_PAGE_TO_PHYS(pg)));
		pg->fpgsz = pmr_count;
		uvm_pmr_insert(pmr, pg, 0);

		uvmexp.free += pmr_count;
		pg += pmr_count;
	}
	wakeup(&uvmexp.free);
	if (uvmexp.zeropages < UVM_PAGEZERO_TARGET)
		wakeup(&uvmexp.zeropages);

	uvm_wakeup_pla(VM_PAGE_TO_PHYS(firstpg), ptoa(count));

	uvm_unlock_fpageq();
}

/*
 * Free all pages in the queue.
 */
void
uvm_pmr_freepageq(struct pglist *pgl)
{
	struct vm_page *pg;
	paddr_t pstart;
	psize_t plen;

	TAILQ_FOREACH(pg, pgl, pageq) {
		if (!((pg->pg_flags & PQ_FREE) == 0 &&
		    VALID_FLAGS(pg->pg_flags))) {
			printf("Flags: 0x%x, will panic now.\n",
			    pg->pg_flags);
		}
		KASSERT((pg->pg_flags & PQ_FREE) == 0 &&
		    VALID_FLAGS(pg->pg_flags));
		atomic_setbits_int(&pg->pg_flags, PQ_FREE);
		atomic_clearbits_int(&pg->pg_flags, PG_ZERO);
	}

	uvm_lock_fpageq();
	while (!TAILQ_EMPTY(pgl)) {
		pstart = VM_PAGE_TO_PHYS(TAILQ_FIRST(pgl));
		plen = uvm_pmr_remove_1strange(pgl, 0, NULL, 0);
		uvmexp.free += plen;

		uvm_wakeup_pla(pstart, ptoa(plen));
	}
	wakeup(&uvmexp.free);
	if (uvmexp.zeropages < UVM_PAGEZERO_TARGET)
		wakeup(&uvmexp.zeropages);
	uvm_unlock_fpageq();

	return;
}

/*
 * Store a pmemrange in the list.
 *
 * The list is sorted by use.
 */
struct uvm_pmemrange *
uvm_pmemrange_use_insert(struct uvm_pmemrange_use *useq,
    struct uvm_pmemrange *pmr)
{
	struct uvm_pmemrange *iter;
	int cmp = 1;

	TAILQ_FOREACH(iter, useq, pmr_use) {
		cmp = uvm_pmemrange_use_cmp(pmr, iter);
		if (cmp == 0)
			return iter;
		if (cmp == -1)
			break;
	}

	if (iter == NULL)
		TAILQ_INSERT_TAIL(useq, pmr, pmr_use);
	else
		TAILQ_INSERT_BEFORE(iter, pmr, pmr_use);
	return NULL;
}

#ifdef DEBUG
/*
 * Validation of the whole pmemrange.
 * Called with fpageq locked.
 */
void
uvm_pmr_assertvalid(struct uvm_pmemrange *pmr)
{
	struct vm_page *prev, *next, *i, *xref;
	int lcv, mti;

	/* Empty range */
	if (pmr->nsegs == 0)
		return;

	/* Validate address tree. */
	RBT_FOREACH(i, uvm_pmr_addr, &pmr->addr) {
		/* Validate the range. */
		KASSERT(i->fpgsz > 0);
		KASSERT(atop(VM_PAGE_TO_PHYS(i)) >= pmr->low);
		KASSERT(atop(VM_PAGE_TO_PHYS(i)) + i->fpgsz
		    <= pmr->high);

		/* Validate each page in this range. */
		for (lcv = 0; lcv < i->fpgsz; lcv++) {
			/*
			 * Only the first page has a size specification.
			 * Rest is size 0.
			 */
			KASSERT(lcv == 0 || i[lcv].fpgsz == 0);
			/*
			 * Flag check.
			 */
			KASSERT(VALID_FLAGS(i[lcv].pg_flags) &&
			    (i[lcv].pg_flags & PQ_FREE) == PQ_FREE);
			/*
			 * Free pages are:
			 * - not wired
			 * - have no vm_anon
			 * - have no uvm_object
			 */
			KASSERT(i[lcv].wire_count == 0);
			KASSERT(i[lcv].uanon == (void*)0xdeadbeef ||
			    i[lcv].uanon == NULL);
			KASSERT(i[lcv].uobject == (void*)0xdeadbeef ||
			    i[lcv].uobject == NULL);
			/*
			 * Pages in a single range always have the same
			 * memtype.
			 */
			KASSERT(uvm_pmr_pg_to_memtype(&i[0]) ==
			    uvm_pmr_pg_to_memtype(&i[lcv]));
		}

		/* Check that it shouldn't be joined with its predecessor. */
		prev = RBT_PREV(uvm_pmr_addr, i);
		if (prev != NULL) {
			KASSERT(uvm_pmr_pg_to_memtype(i) !=
			    uvm_pmr_pg_to_memtype(prev) ||
			    atop(VM_PAGE_TO_PHYS(i)) >
			    atop(VM_PAGE_TO_PHYS(prev)) + prev->fpgsz ||
			    prev + prev->fpgsz != i);
		}

		/* Assert i is in the size tree as well. */
		if (i->fpgsz == 1) {
			TAILQ_FOREACH(xref,
			    &pmr->single[uvm_pmr_pg_to_memtype(i)], pageq) {
				if (xref == i)
					break;
			}
			KASSERT(xref == i);
		} else {
			KASSERT(RBT_FIND(uvm_pmr_size,
			    &pmr->size[uvm_pmr_pg_to_memtype(i)], i + 1) ==
			    i + 1);
		}
	}

	/* Validate size tree. */
	for (mti = 0; mti < UVM_PMR_MEMTYPE_MAX; mti++) {
		for (i = uvm_pmr_nfindsz(pmr, 1, mti); i != NULL; i = next) {
			next = uvm_pmr_nextsz(pmr, i, mti);
			if (next != NULL) {
				KASSERT(i->fpgsz <=
				    next->fpgsz);
			}

			/* Assert i is in the addr tree as well. */
			KASSERT(RBT_FIND(uvm_pmr_addr, &pmr->addr, i) == i);

			/* Assert i is of the correct memory type. */
			KASSERT(uvm_pmr_pg_to_memtype(i) == mti);
		}
	}

	/* Validate nsegs statistic. */
	lcv = 0;
	RBT_FOREACH(i, uvm_pmr_addr, &pmr->addr)
		lcv++;
	KASSERT(pmr->nsegs == lcv);
}
#endif /* DEBUG */

/*
 * Split pmr at split point pageno.
 * Called with fpageq unlocked.
 *
 * Split is only applied if a pmemrange spans pageno.
 */
void
uvm_pmr_split(paddr_t pageno)
{
	struct uvm_pmemrange *pmr, *drain;
	struct vm_page *rebuild, *prev, *next;
	psize_t prev_sz;

	uvm_lock_fpageq();
	pmr = uvm_pmemrange_find(pageno);
	if (pmr == NULL || !(pmr->low < pageno)) {
		/* No split required. */
		uvm_unlock_fpageq();
		return;
	}

	KASSERT(pmr->low < pageno);
	KASSERT(pmr->high > pageno);

	/*
	 * uvm_pmr_allocpmr() calls into malloc() which in turn calls into
	 * uvm_kmemalloc which calls into pmemrange, making the locking
	 * a bit hard, so we just race!
	 */
	uvm_unlock_fpageq();
	drain = uvm_pmr_allocpmr();
	uvm_lock_fpageq();
	pmr = uvm_pmemrange_find(pageno);
	if (pmr == NULL || !(pmr->low < pageno)) {
		/*
		 * We lost the race since someone else ran this or a related
		 * function, however this should be triggered very rarely so
		 * we just leak the pmr.
		 */
		printf("uvm_pmr_split: lost one pmr\n");
		uvm_unlock_fpageq();
		return;
	}

	drain->low = pageno;
	drain->high = pmr->high;
	drain->use = pmr->use;

	uvm_pmr_assertvalid(pmr);
	uvm_pmr_assertvalid(drain);
	KASSERT(drain->nsegs == 0);

	RBT_FOREACH(rebuild, uvm_pmr_addr, &pmr->addr) {
		if (atop(VM_PAGE_TO_PHYS(rebuild)) >= pageno)
			break;
	}
	if (rebuild == NULL)
		prev = RBT_MAX(uvm_pmr_addr, &pmr->addr);
	else
		prev = RBT_PREV(uvm_pmr_addr, rebuild);
	KASSERT(prev == NULL || atop(VM_PAGE_TO_PHYS(prev)) < pageno);

	/*
	 * Handle free chunk that spans the split point.
	 */
	if (prev != NULL &&
	    atop(VM_PAGE_TO_PHYS(prev)) + prev->fpgsz > pageno) {
		psize_t before, after;

		KASSERT(atop(VM_PAGE_TO_PHYS(prev)) < pageno);

		uvm_pmr_remove(pmr, prev);
		prev_sz = prev->fpgsz;
		before = pageno - atop(VM_PAGE_TO_PHYS(prev));
		after = atop(VM_PAGE_TO_PHYS(prev)) + prev_sz - pageno;

		KASSERT(before > 0);
		KASSERT(after > 0);

		prev->fpgsz = before;
		uvm_pmr_insert(pmr, prev, 1);
		(prev + before)->fpgsz = after;
		uvm_pmr_insert(drain, prev + before, 1);
	}

	/* Move free chunks that no longer fall in the range. */
	for (; rebuild != NULL; rebuild = next) {
		next = RBT_NEXT(uvm_pmr_addr, rebuild);

		uvm_pmr_remove(pmr, rebuild);
		uvm_pmr_insert(drain, rebuild, 1);
	}

	pmr->high = pageno;
	uvm_pmr_assertvalid(pmr);
	uvm_pmr_assertvalid(drain);

	RBT_INSERT(uvm_pmemrange_addr, &uvm.pmr_control.addr, drain);
	uvm_pmemrange_use_insert(&uvm.pmr_control.use, drain);
	uvm_unlock_fpageq();
}

/*
 * Increase the usage counter for the given range of memory.
 *
 * The more usage counters a given range of memory has, the more will be
 * attempted not to allocate from it.
 *
 * Addresses here are in paddr_t, not page-numbers.
 * The lowest and highest allowed address are specified.
 */
void
uvm_pmr_use_inc(paddr_t low, paddr_t high)
{
	struct uvm_pmemrange *pmr;
	paddr_t sz;

	/* pmr uses page numbers, translate low and high. */
	high++;
	high = atop(trunc_page(high));
	low = atop(round_page(low));
	uvm_pmr_split(low);
	uvm_pmr_split(high);

	sz = 0;
	uvm_lock_fpageq();
	/* Increase use count on segments in range. */
	RBT_FOREACH(pmr, uvm_pmemrange_addr, &uvm.pmr_control.addr) {
		if (PMR_IS_SUBRANGE_OF(pmr->low, pmr->high, low, high)) {
			TAILQ_REMOVE(&uvm.pmr_control.use, pmr, pmr_use);
			pmr->use++;
			sz += pmr->high - pmr->low;
			uvm_pmemrange_use_insert(&uvm.pmr_control.use, pmr);
		}
		uvm_pmr_assertvalid(pmr);
	}
	uvm_unlock_fpageq();

	KASSERT(sz >= high - low);
}

/*
 * Allocate a pmemrange.
 *
 * If called from uvm_page_init, the uvm_pageboot_alloc is used.
 * If called after uvm_init, malloc is used.
 * (And if called in between, you're dead.)
 */
struct uvm_pmemrange *
uvm_pmr_allocpmr(void)
{
	struct uvm_pmemrange *nw;
	int i;

	/* We're only ever hitting the !uvm.page_init_done case for now. */
	if (!uvm.page_init_done) {
		nw = (struct uvm_pmemrange *)
		    uvm_pageboot_alloc(sizeof(struct uvm_pmemrange));
	} else {
		nw = malloc(sizeof(struct uvm_pmemrange),
		    M_VMMAP, M_NOWAIT);
	}
	KASSERT(nw != NULL);
	memset(nw, 0, sizeof(struct uvm_pmemrange));
	RBT_INIT(uvm_pmr_addr, &nw->addr);
	for (i = 0; i < UVM_PMR_MEMTYPE_MAX; i++) {
		RBT_INIT(uvm_pmr_size, &nw->size[i]);
		TAILQ_INIT(&nw->single[i]);
	}
	return nw;
}

/*
 * Initialization of pmr.
 * Called by uvm_page_init.
 *
 * Sets up pmemranges.
 */
void
uvm_pmr_init(void)
{
	struct uvm_pmemrange *new_pmr;
	int i;

	TAILQ_INIT(&uvm.pmr_control.use);
	RBT_INIT(uvm_pmemrange_addr, &uvm.pmr_control.addr);
	TAILQ_INIT(&uvm.pmr_control.allocs);

	/* By default, one range for the entire address space. */
	new_pmr = uvm_pmr_allocpmr();
	new_pmr->low = 0;
	new_pmr->high = atop((paddr_t)-1) + 1; 

	RBT_INSERT(uvm_pmemrange_addr, &uvm.pmr_control.addr, new_pmr);
	uvm_pmemrange_use_insert(&uvm.pmr_control.use, new_pmr);

	for (i = 0; uvm_md_constraints[i] != NULL; i++) {
		uvm_pmr_use_inc(uvm_md_constraints[i]->ucr_low,
	    	    uvm_md_constraints[i]->ucr_high);
	}
}

/*
 * Find the pmemrange that contains the given page number.
 *
 * (Manually traverses the binary tree, because that is cheaper on stack
 * usage.)
 */
struct uvm_pmemrange *
uvm_pmemrange_find(paddr_t pageno)
{
	struct uvm_pmemrange *pmr;

	pmr = RBT_ROOT(uvm_pmemrange_addr, &uvm.pmr_control.addr);
	while (pmr != NULL) {
		if (pmr->low > pageno)
			pmr = RBT_LEFT(uvm_pmemrange_addr, pmr);
		else if (pmr->high <= pageno)
			pmr = RBT_RIGHT(uvm_pmemrange_addr, pmr);
		else
			break;
	}

	return pmr;
}

#if defined(DDB) || defined(DEBUG)
/*
 * Return true if the given page is in any of the free lists.
 * Used by uvm_page_printit.
 * This function is safe, even if the page is not on the freeq.
 * Note: does not apply locking, only called from ddb.
 */
int
uvm_pmr_isfree(struct vm_page *pg)
{
	struct vm_page *r;
	struct uvm_pmemrange *pmr;

	pmr = uvm_pmemrange_find(atop(VM_PAGE_TO_PHYS(pg)));
	if (pmr == NULL)
		return 0;
	r = RBT_NFIND(uvm_pmr_addr, &pmr->addr, pg);
	if (r == NULL)
		r = RBT_MAX(uvm_pmr_addr, &pmr->addr);
	else if (r != pg)
		r = RBT_PREV(uvm_pmr_addr, r);
	if (r == NULL)
		return 0; /* Empty tree. */

	KDASSERT(atop(VM_PAGE_TO_PHYS(r)) <= atop(VM_PAGE_TO_PHYS(pg)));
	return atop(VM_PAGE_TO_PHYS(r)) + r->fpgsz >
	    atop(VM_PAGE_TO_PHYS(pg));
}
#endif /* DEBUG */

/*
 * Given a root of a tree, find a range which intersects start, end and
 * is of the same memtype.
 *
 * Page must be in the address tree.
 */
struct vm_page*
uvm_pmr_rootupdate(struct uvm_pmemrange *pmr, struct vm_page *init_root,
    paddr_t start, paddr_t end, int memtype)
{
	int	direction;
	struct	vm_page *root;
	struct	vm_page *high, *high_next;
	struct	vm_page *low, *low_next;

	KDASSERT(pmr != NULL && init_root != NULL);
	root = init_root;

	/* Which direction to use for searching. */
	if (start != 0 && atop(VM_PAGE_TO_PHYS(root)) + root->fpgsz <= start)
		direction =  1;
	else if (end != 0 && atop(VM_PAGE_TO_PHYS(root)) >= end)
		direction = -1;
	else /* nothing to do */
		return root;

	/* First, update root to fall within the chosen range. */
	while (root && !PMR_INTERSECTS_WITH(
	    atop(VM_PAGE_TO_PHYS(root)),
	    atop(VM_PAGE_TO_PHYS(root)) + root->fpgsz,
	    start, end)) {
		if (direction == 1)
			root = RBT_RIGHT(uvm_objtree, root);
		else
			root = RBT_LEFT(uvm_objtree, root);
	}
	if (root == NULL || uvm_pmr_pg_to_memtype(root) == memtype)
		return root;

	/*
	 * Root is valid, but of the wrong memtype.
	 *
	 * Try to find a range that has the given memtype in the subtree
	 * (memtype mismatches are costly, either because the conversion
	 * is expensive, or a later allocation will need to do the opposite
	 * conversion, which will be expensive).
	 *
	 *
	 * First, simply increase address until we hit something we can use.
	 * Cache the upper page, so we can page-walk later.
	 */
	high = root;
	high_next = RBT_RIGHT(uvm_objtree, high);
	while (high_next != NULL && PMR_INTERSECTS_WITH(
	    atop(VM_PAGE_TO_PHYS(high_next)),
	    atop(VM_PAGE_TO_PHYS(high_next)) + high_next->fpgsz,
	    start, end)) {
		high = high_next;
		if (uvm_pmr_pg_to_memtype(high) == memtype)
			return high;
		high_next = RBT_RIGHT(uvm_objtree, high);
	}

	/*
	 * Second, decrease the address until we hit something we can use.
	 * Cache the lower page, so we can page-walk later.
	 */
	low = root;
	low_next = RBT_LEFT(uvm_objtree, low);
	while (low_next != NULL && PMR_INTERSECTS_WITH(
	    atop(VM_PAGE_TO_PHYS(low_next)),
	    atop(VM_PAGE_TO_PHYS(low_next)) + low_next->fpgsz,
	    start, end)) {
		low = low_next;
		if (uvm_pmr_pg_to_memtype(low) == memtype)
			return low;
		low_next = RBT_LEFT(uvm_objtree, low);
	}

	if (low == high)
		return NULL;

	/* No hits. Walk the address tree until we find something usable. */
	for (low = RBT_NEXT(uvm_pmr_addr, low);
	    low != high;
	    low = RBT_NEXT(uvm_pmr_addr, low)) {
		KDASSERT(PMR_IS_SUBRANGE_OF(atop(VM_PAGE_TO_PHYS(low)),
	    	    atop(VM_PAGE_TO_PHYS(low)) + low->fpgsz,
	    	    start, end));
		if (uvm_pmr_pg_to_memtype(low) == memtype)
			return low;
	}

	/* Nothing found. */
	return NULL;
}

/*
 * Allocate any page, the fastest way. Page number constraints only.
 */
psize_t
uvm_pmr_get1page(psize_t count, int memtype_init, struct pglist *result,
    paddr_t start, paddr_t end, int memtype_only)
{
	struct	uvm_pmemrange *pmr;
	struct	vm_page *found, *splitpg;
	psize_t	fcount;
	int	memtype;

	fcount = 0;
	TAILQ_FOREACH(pmr, &uvm.pmr_control.use, pmr_use) {
		/* We're done. */
		if (fcount == count)
			break;

		/* Outside requested range. */
		if (!(start == 0 && end == 0) &&
		    !PMR_INTERSECTS_WITH(pmr->low, pmr->high, start, end))
			continue;

		/* Range is empty. */
		if (pmr->nsegs == 0)
			continue;

		/* Loop over all memtypes, starting at memtype_init. */
		memtype = memtype_init;
		while (fcount != count) {
			found = TAILQ_FIRST(&pmr->single[memtype]);
			/*
			 * If found is outside the range, walk the list
			 * until we find something that intersects with
			 * boundaries.
			 */
			while (found && !PMR_INTERSECTS_WITH(
			    atop(VM_PAGE_TO_PHYS(found)),
			    atop(VM_PAGE_TO_PHYS(found)) + 1,
			    start, end))
				found = TAILQ_NEXT(found, pageq);

			if (found == NULL) {
				/*
				 * Check if the size tree contains a range
				 * that intersects with the boundaries. As the
				 * allocation is for any page, try the smallest
				 * range so that large ranges are preserved for
				 * more constrained cases. Only one entry is
				 * checked here, to avoid a brute-force search.
				 *
				 * Note that a size tree gives pg[1] instead of
				 * pg[0].
				 */
				found = RBT_MIN(uvm_pmr_size,
				    &pmr->size[memtype]);
				if (found != NULL) {
					found--;
					if (!PMR_INTERSECTS_WITH(
					    atop(VM_PAGE_TO_PHYS(found)),
					    atop(VM_PAGE_TO_PHYS(found)) +
					    found->fpgsz, start, end))
						found = NULL;
				}
			}
			if (found == NULL) {
				/*
				 * Try address-guided search to meet the page
				 * number constraints.
				 */
				found = RBT_ROOT(uvm_pmr_addr, &pmr->addr);
				if (found != NULL) {
					found = uvm_pmr_rootupdate(pmr, found,
					    start, end, memtype);
				}
			}
			if (found != NULL) {
				uvm_pmr_assertvalid(pmr);
				uvm_pmr_remove_size(pmr, found);

				/*
				 * If the page intersects the end, then it'll
				 * need splitting.
				 *
				 * Note that we don't need to split if the page
				 * intersects start: the drain function will
				 * simply stop on hitting start.
				 */
				if (end != 0 && atop(VM_PAGE_TO_PHYS(found)) +
				    found->fpgsz > end) {
					psize_t splitsz =
					    atop(VM_PAGE_TO_PHYS(found)) +
					    found->fpgsz - end;

					uvm_pmr_remove_addr(pmr, found);
					uvm_pmr_assertvalid(pmr);
					found->fpgsz -= splitsz;
					splitpg = found + found->fpgsz;
					splitpg->fpgsz = splitsz;
					uvm_pmr_insert(pmr, splitpg, 1);

					/*
					 * At this point, splitpg and found
					 * actually should be joined.
					 * But we explicitly disable that,
					 * because we will start subtracting
					 * from found.
					 */
					KASSERT(start == 0 ||
					    atop(VM_PAGE_TO_PHYS(found)) +
					    found->fpgsz > start);
					uvm_pmr_insert_addr(pmr, found, 1);
				}

				/*
				 * Fetch pages from the end.
				 * If the range is larger than the requested
				 * number of pages, this saves us an addr-tree
				 * update.
				 *
				 * Since we take from the end and insert at
				 * the head, any ranges keep preserved.
				 */
				while (found->fpgsz > 0 && fcount < count &&
				    (start == 0 ||
				    atop(VM_PAGE_TO_PHYS(found)) +
				    found->fpgsz > start)) {
					found->fpgsz--;
					fcount++;
					TAILQ_INSERT_HEAD(result,
					    &found[found->fpgsz], pageq);
				}
				if (found->fpgsz > 0) {
					uvm_pmr_insert_size(pmr, found);
					KDASSERT(fcount == count);
					uvm_pmr_assertvalid(pmr);
					return fcount;
				}

				/*
				 * Delayed addr-tree removal.
				 */
				uvm_pmr_remove_addr(pmr, found);
				uvm_pmr_assertvalid(pmr);
			} else {
				if (memtype_only)
					break;
				/*
				 * Skip to the next memtype.
				 */
				memtype += 1;
				if (memtype == UVM_PMR_MEMTYPE_MAX)
					memtype = 0;
				if (memtype == memtype_init)
					break;
			}
		}
	}

	/*
	 * Search finished.
	 *
	 * Ran out of ranges before enough pages were gathered, or we hit the
	 * case where found->fpgsz == count - fcount, in which case the
	 * above exit condition didn't trigger.
	 *
	 * On failure, caller will free the pages.
	 */
	return fcount;
}

#ifdef DDB
/*
 * Print information about pmemrange.
 * Does not do locking (so either call it from DDB or acquire fpageq lock
 * before invoking.
 */
void
uvm_pmr_print(void)
{
	struct	uvm_pmemrange *pmr;
	struct	vm_page *pg;
	psize_t	size[UVM_PMR_MEMTYPE_MAX];
	psize_t	free;
	int	useq_len;
	int	mt;

	printf("Ranges, use queue:\n");
	useq_len = 0;
	TAILQ_FOREACH(pmr, &uvm.pmr_control.use, pmr_use) {
		useq_len++;
		free = 0;
		for (mt = 0; mt < UVM_PMR_MEMTYPE_MAX; mt++) {
			pg = RBT_MAX(uvm_pmr_size, &pmr->size[mt]);
			if (pg != NULL)
				pg--;
			else
				pg = TAILQ_FIRST(&pmr->single[mt]);
			size[mt] = (pg == NULL ? 0 : pg->fpgsz);

			RBT_FOREACH(pg, uvm_pmr_addr, &pmr->addr)
				free += pg->fpgsz;
		}

		printf("* [0x%lx-0x%lx] use=%d nsegs=%ld",
		    (unsigned long)pmr->low, (unsigned long)pmr->high,
		    pmr->use, (unsigned long)pmr->nsegs);
		for (mt = 0; mt < UVM_PMR_MEMTYPE_MAX; mt++) {
			printf(" maxsegsz[%d]=0x%lx", mt,
			    (unsigned long)size[mt]);
		}
		printf(" free=0x%lx\n", (unsigned long)free);
	}
	printf("#ranges = %d\n", useq_len);
}
#endif

/*
 * uvm_wait_pla: wait (sleep) for the page daemon to free some pages
 * in a specific physmem area.
 *
 * Returns ENOMEM if the pagedaemon failed to free any pages.
 * If not failok, failure will lead to panic.
 *
 * Must be called with fpageq locked.
 */
int
uvm_wait_pla(paddr_t low, paddr_t high, paddr_t size, int failok)
{
	struct uvm_pmalloc pma;
	const char *wmsg = "pmrwait";

	if (curproc == uvm.pagedaemon_proc) {
		/*
		 * This is not that uncommon when the pagedaemon is trying
		 * to flush out a large mmapped file. VOP_WRITE will circle
		 * back through the buffer cache and try to get more memory.
		 * The pagedaemon starts by calling bufbackoff, but we can
		 * easily use up that reserve in a single scan iteration.
		 */
		uvm_unlock_fpageq();
		if (bufbackoff(NULL, atop(size)) == 0) {
			uvm_lock_fpageq();
			return 0;
		}
		uvm_lock_fpageq();

		/*
		 * XXX detect pagedaemon deadlock - see comment in
		 * uvm_wait(), as this is exactly the same issue.
		 */
		printf("pagedaemon: wait_pla deadlock detected!\n");
		msleep(&uvmexp.free, &uvm.fpageqlock, PVM, wmsg, hz >> 3);
#if defined(DEBUG)
		/* DEBUG: panic so we can debug it */
		panic("wait_pla pagedaemon deadlock");
#endif
		return 0;
	}

	for (;;) {
		pma.pm_constraint.ucr_low = low;
		pma.pm_constraint.ucr_high = high;
		pma.pm_size = size;
		pma.pm_flags = UVM_PMA_LINKED;
		TAILQ_INSERT_TAIL(&uvm.pmr_control.allocs, &pma, pmq);

		wakeup(&uvm.pagedaemon);		/* wake the daemon! */
		while (pma.pm_flags & (UVM_PMA_LINKED | UVM_PMA_BUSY))
			msleep(&pma, &uvm.fpageqlock, PVM, wmsg, 0);

		if (!(pma.pm_flags & UVM_PMA_FREED) &&
		    pma.pm_flags & UVM_PMA_FAIL) {
			if (failok)
				return ENOMEM;
			printf("uvm_wait: failed to free %ld pages between "
			    "0x%lx-0x%lx\n", atop(size), low, high);
		} else
			return 0;
	}
	/* UNREACHABLE */
}

/*
 * Wake up uvm_pmalloc sleepers.
 */
void
uvm_wakeup_pla(paddr_t low, psize_t len)
{
	struct uvm_pmalloc *pma, *pma_next;
	paddr_t high;

	high = low + len;

	/* Wake specific allocations waiting for this memory. */
	for (pma = TAILQ_FIRST(&uvm.pmr_control.allocs); pma != NULL;
	    pma = pma_next) {
		pma_next = TAILQ_NEXT(pma, pmq);

		if (low < pma->pm_constraint.ucr_high &&
		    high > pma->pm_constraint.ucr_low) {
			pma->pm_flags |= UVM_PMA_FREED;
			if (!(pma->pm_flags & UVM_PMA_BUSY)) {
				pma->pm_flags &= ~UVM_PMA_LINKED;
				TAILQ_REMOVE(&uvm.pmr_control.allocs, pma,
				    pmq);
				wakeup(pma);
			}
		}
	}
}

void
uvm_pagezero_thread(void *arg)
{
	struct pglist pgl;
	struct vm_page *pg;
	int count;

	/* Run at the lowest possible priority. */
	curproc->p_p->ps_nice = NZERO + PRIO_MAX;

	KERNEL_UNLOCK();

	TAILQ_INIT(&pgl);
	for (;;) {
		uvm_lock_fpageq();
		while (uvmexp.zeropages >= UVM_PAGEZERO_TARGET ||
		    (count = uvm_pmr_get1page(16, UVM_PMR_MEMTYPE_DIRTY,
		     &pgl, 0, 0, 1)) == 0) {
			msleep(&uvmexp.zeropages, &uvm.fpageqlock, MAXPRI,
			    "pgzero", 0);
		}
		uvm_unlock_fpageq();

		TAILQ_FOREACH(pg, &pgl, pageq) {
			uvm_pagezero(pg);
			atomic_setbits_int(&pg->pg_flags, PG_ZERO);
		}

		uvm_lock_fpageq();
		while (!TAILQ_EMPTY(&pgl))
			uvm_pmr_remove_1strange(&pgl, 0, NULL, 0);
		uvmexp.zeropages += count;
 		uvm_unlock_fpageq();

		yield();
	}
}
@


1.52
log
@move uvm_pmemrange_addr from RB macros to RBT functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.51 2016/09/16 02:35:42 dlg Exp $	*/
d360 1
a360 1
		KDASSERT(RB_FIND(uvm_pmr_size, &pmr->size[memtype],
d400 1
a400 1
			KDASSERT(RB_FIND(uvm_pmr_size, &pmr->size[mt],
d403 1
a403 1
		KDASSERT(RB_FIND(uvm_pmr_addr, &pmr->addr, pg) == NULL);
d453 1
a453 1
			KDASSERT(RB_FIND(uvm_pmr_size, &pmr->size[mti],
d456 1
a456 1
		KDASSERT(RB_FIND(uvm_pmr_addr, &pmr->addr, pg) == pg);
d1227 1
a1227 1
	RB_FOREACH(i, uvm_pmr_addr, &pmr->addr) {
d1266 1
a1266 1
		prev = RB_PREV(uvm_pmr_addr, &pmr->addr, i);
d1284 1
a1284 1
			KASSERT(RB_FIND(uvm_pmr_size,
d1300 1
a1300 1
			KASSERT(RB_FIND(uvm_pmr_addr, &pmr->addr, i) == i);
d1309 1
a1309 1
	RB_FOREACH(i, uvm_pmr_addr, &pmr->addr)
@


1.51
log
@move the vm_page struct from being stored in RB macro trees to RBT functions

vm_page structs go into three trees, uvm_objtree, uvm_pmr_addr, and
uvm_pmr_size. all these have been moved to RBT code.

this should give us a decent chunk of code space back.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.50 2016/01/29 11:50:40 tb Exp $	*/
d74 2
a75 1
int	uvm_pmemrange_addr_cmp(struct uvm_pmemrange *, struct uvm_pmemrange *);
d99 1
a99 1
RB_GENERATE(uvm_pmemrange_addr, uvm_pmemrange, pmr_addr,
d185 2
a186 1
uvm_pmemrange_addr_cmp(struct uvm_pmemrange *lhs, struct uvm_pmemrange *rhs)
d1412 1
a1412 1
	RB_INSERT(uvm_pmemrange_addr, &uvm.pmr_control.addr, drain);
d1442 1
a1442 1
	RB_FOREACH(pmr, uvm_pmemrange_addr, &uvm.pmr_control.addr) {
d1500 1
a1500 1
	RB_INIT(&uvm.pmr_control.addr);
d1508 1
a1508 1
	RB_INSERT(uvm_pmemrange_addr, &uvm.pmr_control.addr, new_pmr);
d1528 1
a1528 1
	pmr = RB_ROOT(&uvm.pmr_control.addr);
d1531 1
a1531 1
			pmr = RB_LEFT(pmr, pmr_addr);
d1533 1
a1533 1
			pmr = RB_RIGHT(pmr, pmr_addr);
@


1.50
log
@Therefor -> Therefore (where appropriate)

from ray@@, ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.49 2015/12/06 10:42:43 blambert Exp $	*/
a75 2
int	uvm_pmr_addr_cmp(struct vm_page *, struct vm_page *);
int	uvm_pmr_size_cmp(struct vm_page *, struct vm_page *);
d96 2
a97 2
RB_GENERATE(uvm_pmr_addr, vm_page, objt, uvm_pmr_addr_cmp);
RB_GENERATE(uvm_pmr_size, vm_page, objt, uvm_pmr_size_cmp);
d207 1
a207 1
uvm_pmr_addr_cmp(struct vm_page *lhs, struct vm_page *rhs)
d218 1
a218 1
uvm_pmr_size_cmp(struct vm_page *lhs, struct vm_page *rhs)
d246 1
a246 1
	node = RB_ROOT(&pmr->size[mti]);
d251 1
a251 1
			node = RB_LEFT(node, objt);
d253 1
a253 1
			node = RB_RIGHT(node, objt);
d272 1
a272 1
			npg = RB_MIN(uvm_pmr_size, &pmr->size[mt]);
d274 1
a274 1
		npg = RB_NEXT(uvm_pmr_size, &pmr->size[mt], pg + 1);
d293 1
a293 1
	*pg_next = RB_NFIND(uvm_pmr_addr, &pmr->addr, pg);
d295 1
a295 1
		*pg_prev = RB_MAX(uvm_pmr_addr, &pmr->addr);
d297 1
a297 1
		*pg_prev = RB_PREV(uvm_pmr_addr, &pmr->addr, *pg_next);
d327 1
a327 1
	KDASSERT(RB_FIND(uvm_pmr_addr, &pmr->addr, pg) == pg);
d329 1
a329 1
	RB_REMOVE(uvm_pmr_addr, &pmr->addr, pg);
d360 1
a360 1
		RB_REMOVE(uvm_pmr_size, &pmr->size[memtype], pg + 1);
d421 1
a421 1
	RB_INSERT(uvm_pmr_addr, &pmr->addr, pg);
d463 1
a463 1
		RB_INSERT(uvm_pmr_size, &pmr->size[memtype], pg + 1);
d1365 1
a1365 1
	RB_FOREACH(rebuild, uvm_pmr_addr, &pmr->addr) {
d1370 1
a1370 1
		prev = RB_MAX(uvm_pmr_addr, &pmr->addr);
d1372 1
a1372 1
		prev = RB_PREV(uvm_pmr_addr, &pmr->addr, rebuild);
d1400 1
a1400 1
		next = RB_NEXT(uvm_pmr_addr, &pmr->addr, rebuild);
d1477 1
a1477 1
	RB_INIT(&nw->addr);
d1479 1
a1479 1
		RB_INIT(&nw->size[i]);
d1555 1
a1555 1
	r = RB_NFIND(uvm_pmr_addr, &pmr->addr, pg);
d1557 1
a1557 1
		r = RB_MAX(uvm_pmr_addr, &pmr->addr);
d1559 1
a1559 1
		r = RB_PREV(uvm_pmr_addr, &pmr->addr, r);
d1601 1
a1601 1
			root = RB_RIGHT(root, objt);
d1603 1
a1603 1
			root = RB_LEFT(root, objt);
d1621 1
a1621 1
	high_next = RB_RIGHT(high, objt);
d1629 1
a1629 1
		high_next = RB_RIGHT(high, objt);
d1637 1
a1637 1
	low_next = RB_LEFT(low, objt);
d1645 1
a1645 1
		low_next = RB_LEFT(low, objt);
d1652 1
a1652 1
	for (low = RB_NEXT(uvm_pmr_addr, &pmr->addr, low);
d1654 1
a1654 1
	    low = RB_NEXT(uvm_pmr_addr, &pmr->addr, low)) {
d1720 1
a1720 1
				found = RB_MIN(uvm_pmr_size,
d1736 1
a1736 1
				found = RB_ROOT(&pmr->addr);
d1859 1
a1859 1
			pg = RB_MAX(uvm_pmr_size, &pmr->size[mt]);
d1866 1
a1866 1
			RB_FOREACH(pg, uvm_pmr_addr, &pmr->addr)
@


1.49
log
@
Since the page zeroing thread runs without the kernel lock,
it relies upon the fpageq lock for data consistency and
sleep/wakeup interlocking.

Therefore, code which modifies page zeroing thread data
or performs a wakeup of the thread must also hold the
fpageq lock.

Fix an instance where this was not the case.

ok kettenis@@
diff --git a/sys/uvm/uvm_pmemrange.c b/sys/uvm/uvm_pmemrange.c
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.48 2015/08/21 16:04:35 visa Exp $	*/
d195 1
a195 1
 * this range. Therefor allocate from the range with the lowest use first.
@


1.48
log
@Remove the unused loan_count field and the related uvm logic. Most of
the page loaning code is already in the Attic.

ok kettenis@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.47 2015/08/19 12:24:30 visa Exp $	*/
d1039 1
d1043 1
@


1.47
log
@Make uvm_pmr_isfree() work correctly when RB_NFIND() returns
an exact match.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.46 2015/06/27 21:25:55 miod Exp $	*/
a1246 1
			 * - not loaned
a1250 1
			KASSERT(i[lcv].loan_count == 0);
@


1.46
log
@uvm_pmr_get1page() should return psize_t, not int; dhill@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.45 2015/06/20 20:20:08 kettenis Exp $	*/
d1560 1
a1560 1
	else
@


1.45
log
@Fix a bug that causes uvm_pmr_get1page() to fail for allocations that
specify an address constraint even when free pages that meet the constraint
are still available.  This happens because the old code was using the root
of the size tree as a starting point for a search down the address tree.
This meant only part of the address tree was searched, and that part could
very well not contain any of the pages that met the constraint.  Instead,
always walk the address tree from its root if the list of single pages is
empty and the root of the size tree doesn't meet our constraints.

From Visa Hankala.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.44 2014/11/13 00:47:44 tedu Exp $	*/
d110 1
a110 1
int			 uvm_pmr_get1page(psize_t, int, struct pglist *,
d1671 1
a1671 1
int
@


1.44
log
@bzero -> memset
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.43 2014/10/03 22:25:58 guenther Exp $	*/
d1711 13
a1723 2
				found = RB_ROOT(&pmr->size[memtype]);
				/* Size tree gives pg[1] instead of pg[0] */
d1726 14
a1739 1

@


1.43
log
@Initialize uvm_pagezero_thread()'s page list variable.

ok krw@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.42 2014/10/03 18:06:47 kettenis Exp $	*/
d1478 1
a1478 1
	bzero(nw, sizeof(struct uvm_pmemrange));
@


1.42
log
@Introduce a thread for zeroing pages without holding the kernel lock.  This
way we can do some useful kernel lock in parallel with other things and create
a reservoir of zeroed pages ready for use elsewhere.  This should reduce
latency.  The thread runs at the absolutel lowest priority such that we don't
keep other kernel threads or userland from doing useful work.

Can be easily disabled by disabling the kthread_create(9) call in main().
Which perhaps we should do for non-MP kernels.

ok deraadt@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.41 2014/09/14 14:17:27 jsg Exp $	*/
d1968 1
@


1.41
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.40 2014/04/13 23:14:15 tedu Exp $	*/
d24 1
d111 1
a111 1
			    paddr_t, paddr_t);
d828 1
a828 1
		    result, start, end);
d1040 2
d1136 2
d1175 2
d1673 1
a1673 1
    paddr_t start, paddr_t end)
d1789 2
d1953 37
@


1.40
log
@compress code by turning four line comments into one line comments.
emphatic ok usual suspects, grudging ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.39 2014/04/05 17:18:00 miod Exp $	*/
a22 1
#include <sys/proc.h>		/* XXX for atomic */
@


1.39
log
@Fix logic error and prevent theoretical infinite loop in the worst case scenario
in uvm_pmr_rootupdate(). Issue spotted and fix provided by Kieran Devlin.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.38 2014/03/21 21:39:36 miod Exp $	*/
d943 1
a943 3
		/*
		 * Try a smaller search now.
		 */
d1006 1
a1006 4
	/*
	 * Allocation failed.
	 */

d1024 1
a1024 5

	/*
	 * Allocation succesful.
	 */

d1394 1
a1394 3
	/*
	 * Move free chunks that no longer fall in the range.
	 */
d1583 1
a1583 3
	/*
	 * Which direction to use for searching.
	 */
d1591 1
a1591 3
	/*
	 * First, update root to fall within the chosen range.
	 */
d1647 1
a1647 3
	/*
	 * Ack, no hits. Walk the address tree until to find something usable.
	 */
d1658 1
a1658 3
	/*
	 * Nothing found.
	 */
d1930 1
a1930 3
	/*
	 * Wake specific allocations waiting for this memory.
	 */
@


1.38
log
@Allow for two more pmap-specific bits in vm_page pg_flags. Define
PG_PMAPMASK as all the possible pmap-specific bits (similar to the other
PG_fooMASK) to make sure MI code does not need to be updated, the next time
more bits are allocated to greedy pmaps.

No functional change, soon to be used by the (greedy) mips64 pmap.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.37 2014/02/06 16:40:40 tedu Exp $	*/
d1648 1
a1648 1
	low_next = RB_RIGHT(low, objt);
d1656 1
a1656 1
		low_next = RB_RIGHT(low, objt);
d1658 3
@


1.37
log
@add some more bufbackoff calls. uvm_wait optimistically (?), uvm_wait_pla
after analysis and testing. when flushing a large mmapped file, we can
eat up all the reserve bufs, but there's a good chance there will be more
clean ones available.
ok beck kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.36 2013/01/29 19:55:48 beck Exp $	*/
d71 1
a71 2
	(((pg_flags) & ~(PQ_FREE|PG_ZERO|				\
	    PG_PMAP0|PG_PMAP1|PG_PMAP2|PG_PMAP3)) == 0x0)
d1045 1
a1045 2
		atomic_clearbits_int(&found->pg_flags,
		    PG_PMAP0|PG_PMAP1|PG_PMAP2|PG_PMAP3);
@


1.36
log
@7 &&'ed elements in a single KASSERT involving complex tests is just painful
when you hit it. Separate out these tests.
ok millert@@ kettenis@@, phessler@@, with miod@@ bikeshedding.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.35 2013/01/21 18:25:27 beck Exp $	*/
d25 1
d1887 14
@


1.35
log
@Stop hiding when this is failing - make this as obvious as it is
when uvm_wait gets hit from the pagedaemon. - code copied from uvm_wait.
ok guenther@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.34 2012/01/05 17:49:45 ariane Exp $	*/
d738 8
a745 7
	KASSERT(count > 0 &&
	    (start == 0 || end == 0 || start < end) &&
	    align >= 1 && powerof2(align) &&
	    maxseg > 0 &&
	    (boundary == 0 || powerof2(boundary)) &&
	    (boundary == 0 || maxseg * boundary >= count) &&
	    TAILQ_EMPTY(result));
@


1.34
log
@Prevent integer wrap-around in pmemrange.

Found by and original fix from Geoff Steckel.
While here, switch the assert that prevents this from happening from DEBUG to DIAGNOSTIC.

ok thib@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.33 2011/12/03 20:07:06 miod Exp $	*/
a1883 3
	/*
	 * Prevent deadlock.
	 */
d1885 5
d1891 4
@


1.33
log
@Be sure not to access the vm_page array out of bounds in uvm_pmr_freepages().
Among other things, this fixes early panics on hppa system which memory size
is exactly 128MB.

Found the hard way and reported by fries@@, not reported by beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.32 2011/07/08 18:25:56 ariane Exp $	*/
d676 1
a676 1
		KDASSERT(pg_i->pg_flags & PQ_FREE);
d913 2
a914 2
			if (fstart >= fend)
				continue;
d919 2
a920 2
			if (end != 0)
				fend = MIN(end, fend);
@


1.32
log
@Move uvm_pmr_alloc_pig to kern/subr_hibernate.c

No callers, no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.31 2011/07/08 18:20:10 ariane Exp $	*/
d1112 1
d1131 1
a1131 1
	while (count > 0) {
d1135 1
a1135 1
		pmr_count = MIN(count, pmr->high - atop(VM_PAGE_TO_PHYS(pg)));
a1139 1
		count -= pmr_count;
d1144 1
a1144 1
	uvm_wakeup_pla(VM_PAGE_TO_PHYS(pg), ptoa(count));
@


1.31
log
@Move uvm_pmr_zero_everything() to subr_hibernate.

This function will probably die before ever being called
from the in-tree code, since hibernate will move to RLE encoding.

No functional change, function had no callers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.30 2011/07/08 18:15:44 ariane Exp $	*/
a1944 46

#ifndef SMALL_KERNEL
/*
 * Allocate the biggest contig chunk of memory.
 */
int
uvm_pmr_alloc_pig(paddr_t *addr, psize_t *sz)
{
	struct uvm_pmemrange	*pig_pmr, *pmr;
	struct vm_page		*pig_pg, *pg;
	int			 memtype;

	uvm_lock_fpageq();
	pig_pg = NULL;
	TAILQ_FOREACH(pmr, &uvm.pmr_control.use, pmr_use) {
		for (memtype = 0; memtype < UVM_PMR_MEMTYPE_MAX; memtype++) {
			/* Find biggest page in this memtype pmr. */
			pg = RB_MAX(uvm_pmr_size, &pmr->size[memtype]);
			if (pg == NULL)
				pg = TAILQ_FIRST(&pmr->single[memtype]);
			else
				pg--;

			if (pig_pg == NULL || (pg != NULL && pig_pg != NULL &&
			    pig_pg->fpgsz < pg->fpgsz)) {
				pig_pmr = pmr;
				pig_pg = pg;
			}
		}
	}

	/* Remove page from freelist. */
	if (pig_pg != NULL) {
		uvm_pmr_remove(pig_pmr, pig_pg);
		uvmexp.free -= pig_pg->fpgsz;
		if (pig_pg->pg_flags & PG_ZERO)
			uvmexp.zeropages -= pig_pg->fpgsz;
		*addr = VM_PAGE_TO_PHYS(pig_pg);
		*sz = pig_pg->fpgsz;
	}
	uvm_unlock_fpageq();

	/* Return. */
	return (pig_pg != NULL ? 0 : ENOMEM);
}
#endif /* SMALL_KERNEL */
@


1.30
log
@Expose pmemrange internal functions via pmemrange.h.
This is so I can move the pig allocator to subr_hibernate.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.29 2011/07/08 00:10:59 tedu Exp $	*/
a1946 38
/*
 * Zero all free memory.
 */
void
uvm_pmr_zero_everything(void)
{
	struct uvm_pmemrange	*pmr;
	struct vm_page		*pg;
	int			 i;

	uvm_lock_fpageq();
	TAILQ_FOREACH(pmr, &uvm.pmr_control.use, pmr_use) {
		/* Zero single pages. */
		while ((pg = TAILQ_FIRST(&pmr->single[UVM_PMR_MEMTYPE_DIRTY]))
		    != NULL) {
			uvm_pmr_remove(pmr, pg);
			uvm_pagezero(pg);
			atomic_setbits_int(&pg->pg_flags, PG_ZERO);
			uvmexp.zeropages++;
			uvm_pmr_insert(pmr, pg, 0);
		}

		/* Zero multi page ranges. */
		while ((pg = RB_ROOT(&pmr->size[UVM_PMR_MEMTYPE_DIRTY]))
		    != NULL) {
			pg--; /* Size tree always has second page. */
			uvm_pmr_remove(pmr, pg);
			for (i = 0; i < pg->fpgsz; i++) {
				uvm_pagezero(&pg[i]);
				atomic_setbits_int(&pg[i].pg_flags, PG_ZERO);
				uvmexp.zeropages++;
			}
			uvm_pmr_insert(pmr, pg, 0);
		}
	}
	uvm_unlock_fpageq();
}

@


1.29
log
@some machines don't boot with the previous uvm reserve enforcement diff.
back it out.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.28 2011/07/07 20:52:50 oga Exp $	*/
a97 4
RB_PROTOTYPE(uvm_pmr_addr, vm_page, objt, uvm_pmr_addr_cmp);
RB_PROTOTYPE(uvm_pmr_size, vm_page, objt, uvm_pmr_size_cmp);
RB_PROTOTYPE(uvm_pmemrange_addr, uvm_pmemrange, pmr_addr,
    uvm_pmemrange_addr_cmp);
a119 12
struct vm_page		*uvm_pmr_insert_addr(struct uvm_pmemrange *,
			    struct vm_page *, int);
void			 uvm_pmr_insert_size(struct uvm_pmemrange *,
			    struct vm_page *);
struct vm_page		*uvm_pmr_insert(struct uvm_pmemrange *,
			    struct vm_page *, int);
void			 uvm_pmr_remove_size(struct uvm_pmemrange *,
			    struct vm_page *);
void			 uvm_pmr_remove_addr(struct uvm_pmemrange *,
			    struct vm_page *);
void			 uvm_pmr_remove(struct uvm_pmemrange *,
			    struct vm_page *);
a127 3
struct vm_page		*uvm_pmr_extract_range(struct uvm_pmemrange *,
			    struct vm_page *, paddr_t, paddr_t,
			    struct pglist *);
@


1.28
log
@Move the uvm reserve enforcement from uvm_pagealloc to pmemrange.

More and more things are allocating outside of uvm_pagealloc these days making
it easy for something like the buffer cache to eat your last page with no
repercussions (other than a hung machine, of course).

ok ariane@@ also ok ariane@@ again after I spotted and fixed a possible underflow
problem in the calculation.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.27 2011/07/06 19:50:38 beck Exp $	*/
a22 1
#include <sys/mount.h>		/* for BUFPAGES defines */
a749 1
	int	is_pdaemon;
a764 20
	is_pdaemon = ((curproc == uvm.pagedaemon_proc) ||
	      (curproc == syncerproc));

	/*
	 * All allocations by the pagedaemon automatically get access to
	 * the kernel reserve of pages so swapping can catch up with memory
	 * exhaustion
	 */
	if (is_pdaemon)
		flags |= UVM_PLA_USERESERVE;

	/*
	 * check to see if we need to generate some free pages waking
	 * the pagedaemon.
	 */
	if ((uvmexp.free - BUFPAGES_DEFICIT) < uvmexp.freemin ||
	    ((uvmexp.free - BUFPAGES_DEFICIT) < uvmexp.freetarg &&
	    (uvmexp.inactive + BUFPAGES_INACT) < uvmexp.inactarg))
		wakeup(&uvm.pagedaemon);

a837 14

	/*
	 * fail if any of these conditions are true:
	 * [1]  there really are no free pages, or
	 * [2]  only kernel "reserved" pages remain and
	 *        the we are not allowed to use them.
	 * [3]  only pagedaemon "reserved" pages remain and
	 *        the requestor isn't the pagedaemon.
	 */
	if (((uvmexp.free  < uvmexp.reserve_kernel + ptoa(count)) &&
	    (flags & UVM_PLA_USERESERVE) == 0) ||
	    ((uvmexp.free < uvmexp.reserve_pagedaemon + ptoa(count)) &&
	    !is_pdaemon))
		goto fail;
@


1.27
log
@
uvm changes for buffer cache improvements.
1) Make the pagedaemon aware of the memory ranges and size of allocations
where memory is being requested, and pass this information on to
bufbackoff(), which will later (not yet) be used to ensure that the
buffer cache gets out of the way in the right area of memory.

Note that this commit does not yet make it *do* that - as currently
the buffer cache is all in dma-able memory and it will simply back
off.

2) Add uvm_pagerealloc_multi - to be used by the buffer cache code
for reallocating pages to particular regions.

much of this work by ariane, with smatterings of me, art,and oga

ok oga@@, thib@@, ariane@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.26 2011/07/05 19:48:02 ariane Exp $	*/
d23 1
d751 1
d767 20
d860 14
@


1.26
log
@Don't derefence the item past the end of the array to figure out if
the extraction loop should stop.
No more 298 pages in 42 segments when asking for only 32 pages in 1 segment.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.25 2011/06/22 00:16:47 ariane Exp $	*/
d20 1
d24 1
d833 2
a838 2
	uvm_lock_fpageq();

a1033 1
	uvm_unlock_fpageq();
d1036 4
a1039 2
		uvm_wait("uvm_pmr_getpages");
		goto retry;
d1042 1
d1163 2
d1175 2
d1191 7
a1197 2
	while (!TAILQ_EMPTY(pgl))
		uvmexp.free += uvm_pmr_remove_1strange(pgl, 0, NULL, 0);
d1525 1
d1887 77
@


1.25
log
@Validate pmemrange result, enabling early catching of bugs in the code.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.24 2011/05/30 21:25:08 oga Exp $	*/
d689 1
d692 1
a692 2
	for (pg_i = pg + before_sz; atop(VM_PAGE_TO_PHYS(pg_i)) < end;
	    pg_i++) {
a704 1
	after = NULL;
a705 1
		after = pg + before_sz + (end - start);
d718 1
a718 1
	return after;
@


1.24
log
@for (some; stuff; here)
	;

instead of
for (some; stuff; here);

reads easier.

ok ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.23 2011/05/30 21:23:36 oga Exp $	*/
d750 3
d1055 5
d1086 29
d1116 1
@


1.23
log
@s/hart/heart/ to make more sense (another dutchism).

ok ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.22 2011/04/06 12:31:10 mlarkin Exp $	*/
d165 2
a166 1
	for (rshift = 0; num > denom; rshift++, denom <<= 1);
@


1.22
log
@fix uvm_pmr_alloc_pig to return the proper pig range size
ok ariane
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.21 2011/04/05 22:33:51 ariane Exp $	*/
d857 1
a857 1
	 * The hart of the contig case.
@


1.21
log
@Test iterated variable instead of a temporary variable from the previous
code block (not 'high_next' but 'low').
While here, change the KASSERT to a KDASSERT.

Pointed out by Amit Kulkarni.

ok thib@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.20 2011/04/04 22:58:48 ariane Exp $	*/
d1894 2
@


1.20
log
@Remove debug code.

Pointed out and ok mlarkin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.19 2011/04/03 22:07:37 ariane Exp $	*/
d1633 2
a1634 2
		KASSERT(PMR_IS_SUBRANGE_OF(atop(VM_PAGE_TO_PHYS(high_next)),
	    	    atop(VM_PAGE_TO_PHYS(high_next)) + high_next->fpgsz,
@


1.19
log
@Helper functions for suspend.

Allow reclaiming pages from all pools.
Allow zeroing all pages.
Allocate the more equal pig.

mlarking@@ needs this.
Not called yet.

ok mlarkin@@, theo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.18 2010/08/28 22:27:47 miod Exp $	*/
a1846 1
	psize_t			 zeroed = 0;
a1857 5

			zeroed++; /* DEBUG */

			if (zeroed % 1000)
				printf("1");
a1870 4

			zeroed++; /* DEBUG */
			if (zeroed % 100)
				printf("L");
@


1.18
log
@Fix an uninitialized value leading to bogus KASSERT in uvm_pmr_use_inc().
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.17 2010/07/01 21:40:32 oga Exp $	*/
d1836 92
@


1.17
log
@We don't do CamelCase: fix style(9) violations in goto labels.

no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.16 2010/06/29 20:59:04 thib Exp $	*/
d1413 1
@


1.16
log
@skip empty ranges in uvm_pmr_assertvalid;
ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.15 2010/06/27 03:03:49 thib Exp $	*/
d829 1
a829 1
ReTry:		/* Return point after sleeping. */
d835 1
a835 1
ReTryDesperate:
d851 1
a851 1
			goto Out;
d853 1
a853 1
			goto Fail;
d898 1
a898 1
ReScanMemtype:	/* Return point at memtype++. */
d901 1
a901 1
ReScan:		/* Return point at try++. */
d910 1
a910 1
DrainFound:
d945 1
a945 1
				goto Out;
d953 1
a953 1
				goto DrainFound;
d961 1
a961 1
			goto ReScan;
d981 1
a981 1
			goto ReScanMemtype;
d1018 1
a1018 1
		goto ReTryDesperate;
d1021 1
a1021 1
Fail:
d1034 1
a1034 1
		goto ReTry;
d1040 1
a1040 1
Out:
@


1.15
log
@uvm constraints. Add two mandatory MD symbols, uvm_md_constraints
which contains the constraints for DMA/memory allocation for each
architecture, and dma_constraints which contains the range of addresses
that are dma accessable by the system.

This is based on ariane@@'s physcontig diff, with lots of bugfixes and
additions the following additions by my self:

Introduce a new function pool_set_constraints() which sets the address
range for which we allocate pages for the pool from, this is now used
for the mbuf/mbuf cluster pools to keep them dma accessible.

The !direct archs no longer stuff pages into the kernel object in
uvm_km_getpage_pla but rather do a pmap_extract() in uvm_km_putpages.

Tested heavily by my self on i386, amd64 and sparc64. Some tests on
alpha and SGI.

"commit it" beck, art, oga, deraadt
"i like the diff" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.13 2010/06/10 08:48:36 thib Exp $	*/
d1191 4
@


1.14
log
@Fix a bug in uvm_pmr_get1page() which could cause us to bounce
between an allocating process failing and waking up the pagedaemon
and the pagedaemon (since everything was dandy).

Rework the do ... while ()  logic searching for pages of a certain
memtype in a pmr into a while () loop where we check if we've found
enough pages and break out of the pmr and check the memtype inside
the loop. This prevents us from doing an early return without enough
pages for the caller even though more pages exist.


comments and help from oga, style nit from miod.
OK miod@@, oga@@
@
text
@a111 1

d1307 6
d1314 13
d1400 1
d1402 1
a1402 5
	/*
	 * If high+1 == 0 and low == 0, then you are increasing use
	 * of the whole address space, which won't make any difference.
	 * Skip in that case.
	 */
d1404 1
a1404 6
	if (high == 0 && low == 0)
		return;

	/*
	 * pmr uses page numbers, translate low and high.
	 */
a1405 1
	high = atop(trunc_page(high));
a1409 1

d1415 1
d1420 1
d1422 1
a1422 1
	uvm_unlock_fpageq();
d1433 1
a1433 1
uvm_pmr_allocpmr()
d1438 1
a1441 1
		bzero(nw, sizeof(struct uvm_pmemrange));
d1444 1
a1444 1
		    M_VMMAP, M_NOWAIT | M_ZERO);
d1446 2
a1455 2
static const struct uvm_io_ranges uvm_io_ranges[] = UVM_IO_RANGES;

d1471 1
d1474 1
a1474 1
	new_pmr->high = atop((paddr_t)-1) + 1;
d1479 4
a1482 2
	for (i = 0; i < nitems(uvm_io_ranges); i++)
		uvm_pmr_use_inc(uvm_io_ranges[i].low, uvm_io_ranges[i].high);
@


1.13
log
@fix typos in comments: lineair -> linear.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.12 2010/06/10 08:42:23 thib Exp $	*/
d1641 5
a1645 2
	for (pmr = TAILQ_FIRST(&uvm.pmr_control.use);
	    pmr != NULL && fcount != count; pmr = TAILQ_NEXT(pmr, pmr_use)) {
d1655 1
a1655 3
		/*
		 * Loop over all memtypes, starting at memtype_init.
		 */
d1657 1
a1657 1
		do {
d1755 2
d1758 1
a1758 1
		} while (memtype != memtype_init && fcount != count);
@


1.12
log
@the pagedaemon sleeps on uvm.pagedaemon not
uvm.pagedaemon_proc, do the wakeup on the
right ident.

this had been fixed, but the fix got backed
out during The Big Backout.

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.11 2010/04/23 20:42:22 ariane Exp $	*/
d593 1
a593 1
		/* Lineair search for smallest segment. */
@


1.11
log
@Fix null-pointer dereference.

ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.10 2010/04/22 19:02:55 oga Exp $	*/
d1037 1
a1037 1
		wakeup(&uvm.pagedaemon_proc);
@


1.10
log
@Committing on behalf or ariane@@.

recommit pmemrange:
        physmem allocator: change the view of free memory from single
        free pages to free ranges.  Classify memory based on region with
        associated use-counter (which is used to construct a priority
        list of where to allocate memory).

	Based on code from tedu@@, help from many.

Useable now that bugs have been found and fixed in most architecture's
pmap.c

ok by everyone who has done a pmap or uvm commit in the last year.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.5 2009/06/12 00:01:21 ariane Exp $	*/
d1672 1
a1672 1
				if (found != NULL)
d1675 3
a1677 2
				found = uvm_pmr_rootupdate(pmr, found,
				    start, end, memtype);
@


1.9
log
@Backout pmemrange (which to most people is more well known as physmem
allocator).

"i can't see any obvious problems" oga
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.8 2009/06/14 03:04:08 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2009 Ariane van der Steldt <ariane@@stack.nl>
d22 1
d27 10
a36 2
 * addr tree is vm_page[0].fq.free.tree
 * size tree is vm_page[1].fq.free.tree
d41 11
d54 2
a55 1
 * vm_page. This code depends on that array.
d58 13
d76 5
d82 5
a86 3
/* Memory types. The page flags are used to derive what the current memory
 * type of a page is. */
static __inline int
d96 2
a97 2
RB_PROTOTYPE(uvm_pmr_addr, vm_page, fq.free.tree, uvm_pmr_addr_cmp);
RB_PROTOTYPE(uvm_pmr_size, vm_page, fq.free.tree, uvm_pmr_size_cmp);
d100 2
a101 2
RB_GENERATE(uvm_pmr_addr, vm_page, fq.free.tree, uvm_pmr_addr_cmp);
RB_GENERATE(uvm_pmr_size, vm_page, fq.free.tree, uvm_pmr_size_cmp);
d123 4
d129 4
d135 2
d138 1
a138 1
			    struct vm_page **);
d146 3
d152 8
d161 1
a161 1
static __inline psize_t
d164 1
a164 1
	int rshift = 0;
d166 1
a166 2
	while (num > (denom << rshift))
		rshift++;
d172 3
d177 14
a190 1
	((lhs_low) >= (rhs_low) && (lhs_high <= rhs_high))
d243 2
a244 2
	lhs_size = (lhs - 1)->fq.free.pages;
	rhs_size = (rhs - 1)->fq.free.pages;
d268 1
a268 1
		if ((node - 1)->fq.free.pages >= sz) {
d270 1
a270 1
			node = RB_LEFT(node, fq.free.tree);
d272 1
a272 1
			node = RB_RIGHT(node, fq.free.tree);
d278 1
a278 1
 * Finds the next range. The next range has a size >= pg->fq.free.pages.
d287 1
a287 1
	if (pg->fq.free.pages == 1) {
d303 1
a303 1
 * *pg_next == NULL if no previous range is available, that can join with
d318 5
d325 1
a325 1
	    (atop(VM_PAGE_TO_PHYS(*pg_prev)) + (*pg_prev)->fq.free.pages
d327 1
d331 1
a331 1
	    (atop(VM_PAGE_TO_PHYS(pg)) + pg->fq.free.pages
d333 1
d343 1
a343 1
static __inline void
d347 1
a347 1
	KASSERT(pg->pg_flags & PQ_FREE);
d355 1
a355 1
static __inline void
d363 2
a364 1
	KASSERT(pg->pg_flags & PQ_FREE);
d367 1
a367 1
	if (pg->fq.free.pages == 1) {
d399 1
a399 1
static __inline struct vm_page *
d407 1
d409 4
d416 1
a416 1
		if (pg->fq.free.pages > 1) {
a423 3
	KASSERT(pg->pg_flags & PQ_FREE);
	KASSERT(pg->fq.free.pages >= 1);

d429 2
a430 2
			pg->fq.free.pages += next->fq.free.pages;
			next->fq.free.pages = 0;
d434 2
a435 2
			prev->fq.free.pages += pg->fq.free.pages;
			pg->fq.free.pages = 0;
a438 6
#ifdef DEBUG
	else {
		uvm_pmr_pnaddr(pmr, pg, &prev, &next);
		KDASSERT(prev == NULL && next == NULL);
	}
#endif /* DEBUG */
d452 1
a452 1
static __inline void
d461 3
d469 1
a469 1
		if (pg->fq.free.pages > 1) {
d475 1
a475 1
	for (i = pg; i < pg + pg->fq.free.pages; i++)
d479 1
a479 4
	KASSERT(pg->pg_flags & PQ_FREE);
	KASSERT(pg->fq.free.pages >= 1);

	if (pg->fq.free.pages == 1)
d496 62
d564 4
d571 1
a571 1
    struct vm_page **work)
d573 1
a573 1
	struct vm_page *pg, *pre_last, *last, *inserted;
d575 1
a575 2
	struct uvm_pmemrange *pmr;
	paddr_t first_boundary;
d579 50
a628 8
	pg = TAILQ_FIRST(pgl);
	pmr = uvm_pmemrange_find(atop(VM_PAGE_TO_PHYS(pg)));
	KDASSERT(pmr != NULL);
	if (boundary != 0) {
		first_boundary =
		    PMR_ALIGN(atop(VM_PAGE_TO_PHYS(pg)) + 1, boundary);
	} else
		first_boundary = 0;
a629 5
	/* Remove all pages in the first segment. */
	pre_last = pg;
	last = TAILQ_NEXT(pre_last, pageq);
	TAILQ_REMOVE(pgl, pre_last, pageq);
	count = 1;
d631 1
a631 8
	 * While loop checks the following:
	 * - last != NULL	we have not reached the end of pgs
	 * - boundary == 0 || last < first_boundary
	 * 			we do not cross a boundary
	 * - atop(pre_last) + 1 == atop(last)
	 * 			still in the same segment
	 * - low <= last
	 * - high > last  	still testing the same memory range
d633 8
a640 14
	 * At the end of the loop, last points at the next segment
	 * and each page [pg, pre_last] (inclusive range) has been removed
	 * and count is the number of pages that have been removed.
	 */
	while (last != NULL &&
	    (boundary == 0 || atop(VM_PAGE_TO_PHYS(last)) < first_boundary) &&
	    atop(VM_PAGE_TO_PHYS(pre_last)) + 1 ==
	     atop(VM_PAGE_TO_PHYS(last)) &&
	    pmr->low <= atop(VM_PAGE_TO_PHYS(last)) &&
	    pmr->high > atop(VM_PAGE_TO_PHYS(last))) {
		count++;
		pre_last = last;
		last = TAILQ_NEXT(last, pageq);
		TAILQ_REMOVE(pgl, pre_last, pageq);
a641 2
	KDASSERT(TAILQ_FIRST(pgl) == last);
	KDASSERT(pg + (count - 1) == pre_last);
d643 2
a644 2
	pg->fq.free.pages = count;
	inserted = uvm_pmr_insert(pmr, pg, 0);
d646 4
d652 1
a652 1
	    atop(VM_PAGE_TO_PHYS(inserted)) + inserted->fq.free.pages >
d675 5
a679 5
	KASSERT(end > start);
	KASSERT(pmr->low <= atop(VM_PAGE_TO_PHYS(pg)));
	KASSERT(pmr->high >= atop(VM_PAGE_TO_PHYS(pg)) + pg->fq.free.pages);
	KASSERT(atop(VM_PAGE_TO_PHYS(pg)) <= start);
	KASSERT(atop(VM_PAGE_TO_PHYS(pg)) + pg->fq.free.pages >= end);
d682 2
a683 2
	after_sz = atop(VM_PAGE_TO_PHYS(pg)) + pg->fq.free.pages - end;
	KDASSERT(before_sz + after_sz + (end - start) == pg->fq.free.pages);
d693 2
a694 1
		pg_i->fq.free.pages = 0;
a695 1
		KDASSERT(pg_i->pg_flags & PQ_FREE);
d700 1
a700 1
		pg->fq.free.pages = before_sz;
d714 1
a714 1
		after->fq.free.pages = after_sz;
d745 1
a745 1
	psize_t	search[2];
d748 1
d751 10
a760 23
	/* Validate arguments. */
	KASSERT(count > 0);
	KASSERT((start == 0 && end == 0) || (start < end));
	KASSERT(align >= 1 && powerof2(align));
	KASSERT(maxseg > 0);
	KASSERT(boundary == 0 || powerof2(boundary));
	KDASSERT(boundary == 0 || maxseg * boundary >= count);
	KASSERT(TAILQ_EMPTY(result));

	/* Configure search. If start_try == 0, search[0] should be faster
	 * (because it will have to throw away less segments).
	 * search[1] is the worst case: start searching at the smallest
	 * possible range instead of starting at the range most likely to
	 * fulfill the allocation. */
	start_try = 0;
	search[0] = (flags & UVM_PLA_TRY_CONTIG ? count :
	    pow2divide(count, maxseg));
	search[1] = 1;
	if (maxseg == 1) {
		start_try = 1;
		search[1] = count;
	} else if (search[1] >= search[0])
		start_try = 1;
d762 46
a807 3
ReTry:		/* Return point after sleeping. */
	fcount = 0;
	fnsegs = 0;
d809 7
a815 2
	/* Memory type: if zeroed memory is requested, traverse the zero set.
	 * Otherwise, traverse the dirty set. */
d817 1
a817 1
		memtype = UVM_PMR_MEMTYPE_ZERO;
d819 9
a827 1
		memtype = UVM_PMR_MEMTYPE_DIRTY;
d830 4
d841 10
a850 13
	    (flags & UVM_PLA_TRY_CONTIG) == 0) {
		if (!desperate) {
			KASSERT(fcount == 0);
			fcount += uvm_pmr_get1page(count, memtype, result,
			    start, end);
		} else {
			for (memtype = 0; memtype < UVM_PMR_MEMTYPE_MAX &&
			    fcount < count; memtype++) {
				fcount += uvm_pmr_get1page(count - fcount,
				    memtype, result, start, end);
			}
		}

d857 31
d894 1
a894 2
		if (!(start == 0 && end == 0) &&
		    !PMR_IS_SUBRANGE_OF(pmr->low, pmr->high, start, end))
d897 3
d901 1
a902 1

d909 2
d912 8
a919 1
			/* Throw away the first segment if fnsegs == maxseg */
d924 1
a924 1
				    &found);
d928 1
a928 2
			fend = atop(VM_PAGE_TO_PHYS(found)) +
			    found->fq.free.pages;
d935 2
d948 4
a951 2
			/* If there's still space left in found, try to
			 * fully drain it prior to continueing. */
d958 3
d963 28
d999 10
a1008 1
	 * iteration may fall out.
d1012 7
a1018 3
		memtype = 0;
		goto ReTryDesperate;
	} else if (++memtype < UVM_PMR_MEMTYPE_MAX)
d1020 1
d1030 1
a1030 1
		uvm_pmr_remove_1strange(result, 0, NULL);
d1053 3
d1067 1
a1067 1
		atomic_clearbits_int(&found->pg_flags, PG_ZERO | PQ_FREE);
d1072 6
d1092 3
a1094 1
	uvm_lock_fpageq();
d1096 7
a1102 2
	for (i = 0; i < count; i++) {
		atomic_clearbits_int(&pg[i].pg_flags, pg[i].pg_flags);
d1104 1
d1107 2
d1114 1
a1114 1
		pg->fq.free.pages = pmr_count;
d1135 7
a1141 1
		atomic_clearbits_int(&pg->pg_flags, pg->pg_flags);
d1143 1
d1148 1
a1148 1
		uvmexp.free += uvm_pmr_remove_1strange(pgl, 0, NULL);
a1173 2
	if (cmp == 0)
		return iter;
d1196 1
a1196 1
		KASSERT(i->fq.free.pages > 0);
d1198 1
a1198 1
		KASSERT(atop(VM_PAGE_TO_PHYS(i)) + i->fq.free.pages
d1202 13
a1214 12
		for (lcv = 0; lcv < i->fq.free.pages; lcv++) {
			KASSERT(lcv == 0 || i[lcv].fq.free.pages == 0);
			/* Flag check:
			 * - PG_ZERO: page is zeroed.
			 * - PQ_FREE: page is free.
			 * Any other flag is a mistake. */
			if (i[lcv].pg_flags !=
			    (i[lcv].pg_flags & (PG_ZERO | PQ_FREE))) {
				panic("i[%lu].pg_flags = %x, should be %x\n",
				    lcv, i[lcv].pg_flags, PG_ZERO | PQ_FREE);
			}
			/* Free pages are:
d1218 2
a1219 1
			 * - have no uvm_object */
d1222 8
a1229 4
			KASSERT(i[lcv].uanon == NULL);
			KASSERT(i[lcv].uobject == NULL);
			/* Pages in a single range always have the same
			 * memtype. */
d1237 2
a1238 2
			KASSERT(uvm_pmr_pg_to_memtype(&i[0]) !=
			    uvm_pmr_pg_to_memtype(&i[lcv]) ||
d1240 2
a1241 1
			    atop(VM_PAGE_TO_PHYS(prev)) + prev->fq.free.pages);
d1245 1
a1245 1
		if (i->fq.free.pages == 1) {
d1264 2
a1265 2
				KASSERT(i->fq.free.pages <=
				    next->fq.free.pages);
d1331 1
a1331 1
	    atop(VM_PAGE_TO_PHYS(prev)) + prev->fq.free.pages > pageno) {
d1337 1
a1337 1
		prev_sz = prev->fq.free.pages;
d1344 1
a1344 1
		prev->fq.free.pages = before;
d1346 1
a1346 1
		(prev + before)->fq.free.pages = after;
d1384 3
a1386 2
	 * If high+1 == 0, then you are increasing use of the whole address
	 * space, which won't make any difference. Skip in that case.
d1389 1
a1389 1
	if (high == 0)
d1450 1
a1450 1
 * Sets up pmemranges that maps the vm_physmem data.
d1461 3
a1463 2
	for (i = 0 ; i < vm_nphysseg ; i++) {
		new_pmr = uvm_pmr_allocpmr();
d1465 2
a1466 6
		new_pmr->low = vm_physmem[i].start;
		new_pmr->high = vm_physmem[i].end;

		RB_INSERT(uvm_pmemrange_addr, &uvm.pmr_control.addr, new_pmr);
		uvm_pmemrange_use_insert(&uvm.pmr_control.use, new_pmr);
	}
d1521 1
a1521 1
	return atop(VM_PAGE_TO_PHYS(r)) + r->fq.free.pages >
d1527 103
a1629 1
 * Allocate any page, the fastest way. No constraints.
d1632 1
a1632 1
uvm_pmr_get1page(psize_t count, int memtype, struct pglist *result,
d1636 1
a1636 1
	struct	vm_page *found;
d1638 1
d1641 2
a1642 2
	pmr = TAILQ_FIRST(&uvm.pmr_control.use);
	while (pmr != NULL && fcount != count) {
d1645 1
a1645 2
		    !PMR_IS_SUBRANGE_OF(pmr->low, pmr->high, start, end)) {
			pmr = TAILQ_NEXT(pmr, pmr_use);
a1646 1
		}
d1648 2
a1649 9
		found = TAILQ_FIRST(&pmr->single[memtype]);
		if (found == NULL) {
			found = RB_ROOT(&pmr->size[memtype]);
			/* Size tree gives pg[1] instead of pg[0] */
			if (found != NULL)
				found--;
		}
		if (found == NULL) {
			pmr = TAILQ_NEXT(pmr, pmr_use);
a1650 1
		}
d1652 103
a1754 16
		uvm_pmr_assertvalid(pmr);
		uvm_pmr_remove_size(pmr, found);
		while (found->fq.free.pages > 0 && fcount < count) {
			found->fq.free.pages--;
			fcount++;
			TAILQ_INSERT_HEAD(result,
			    &found[found->fq.free.pages], pageq);
		}
		if (found->fq.free.pages > 0) {
			uvm_pmr_insert_size(pmr, found);
			KASSERT(fcount == count);
			uvm_pmr_assertvalid(pmr);
			return fcount;
		} else
			uvm_pmr_remove_addr(pmr, found);
		uvm_pmr_assertvalid(pmr);
d1757 9
a1765 1
	/* Ran out of ranges before enough pages were gathered. */
d1768 46
@


1.8
log
@backout:
> extend uvm_page_physload to have the ability to add "device" pages to the
> system.
since it was overlayed over a system that we warned would go "in to be
tested, but may be pulled out".  oga, you just made me spend 20 minutes
of time I should not have had to spend doing this.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.2 2009/06/04 00:20:53 jsg Exp $	*/
@


1.7
log
@back out the free vs dirty fix, because pmemrange will go soon too
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.3 2009/06/07 02:01:54 oga Exp $	*/
a778 1
		KASSERT((pg->pg_flags & PG_DEV) == 0);
a808 1
		KASSERT((pg->pg_flags & PG_DEV) == 0);
@


1.6
log
@backout the assert diff in 1.5
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.4 2009/06/10 20:36:40 ariane Exp $	*/
d622 11
a632 2
		fcount += uvm_pmr_get1page(count - fcount, memtype, result,
		    start, end);
a699 1
Fail:
d710 3
a712 4
#if UVM_PMR_MEMTYPE_MAX != 2
#error Too many memtypes, need to become smarter!
#endif
		memtype = UVM_PMR_MEMTYPE_MAX - 1 - memtype;
a713 1
	}
d715 1
@


1.5
log
@Add asserts on free memory, double free and while here, fix 1 assert.
Also de-inline functions.

This diff is intended to ease debugging. Once the current bug is fixed,
proper inlining will be redone.

ok: oga
@
text
@a41 1
int	uvm_pmr_pg_to_memtype(struct vm_page *);
d45 1
a45 1
int
a81 4
struct vm_page		*uvm_pmr_insert_addr(struct uvm_pmemrange *,
			    struct vm_page *, int);
void			 uvm_pmr_insert_size(struct uvm_pmemrange *,
			    struct vm_page *);
a83 4
void			 uvm_pmr_remove_size(struct uvm_pmemrange *,
			    struct vm_page *);
void			 uvm_pmr_remove_addr(struct uvm_pmemrange *,
			    struct vm_page *);
a94 1
psize_t			 pow2divide(psize_t, psize_t);
d99 1
a99 1
psize_t
a240 5
	KASSERT(*pg_next == NULL ||
	    VM_PAGE_TO_PHYS(*pg_next) > VM_PAGE_TO_PHYS(pg));
	KASSERT(*pg_prev == NULL ||
	    VM_PAGE_TO_PHYS(*pg_prev) < VM_PAGE_TO_PHYS(pg));

d259 1
a259 1
void
d271 1
a271 1
void
a278 1
	KASSERT(pg->fq.free.pages >= 1);
d314 1
a314 1
struct vm_page *
d371 1
a371 1
void
a379 2
	KASSERT(pg->fq.free.pages >= 1);
	KASSERT(pg->pg_flags & PQ_FREE);
d772 1
a772 1
		KASSERT((pg[i].pg_flags & (PG_DEV|PQ_FREE)) == 0);
d803 1
a803 1
		KASSERT((pg->pg_flags & (PG_DEV|PQ_FREE)) == 0);
@


1.4
log
@Fix: Clean and dirty pages had the memtype ids and the desparate case failed
to function properly in the fast-allocation path (should not have triggered).

ok: oga, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.3 2009/06/07 02:01:54 oga Exp $	*/
d42 1
d46 1
a46 1
static __inline int
d83 4
d89 4
d104 1
d109 1
a109 1
static __inline psize_t
d251 5
d274 1
a274 1
static __inline void
d286 1
a286 1
static __inline void
d294 1
d330 1
a330 1
static __inline struct vm_page *
d387 1
a387 1
static __inline void
d396 2
d790 1
a790 1
		KASSERT((pg->pg_flags & PG_DEV) == 0);
d821 1
a821 1
		KASSERT((pg->pg_flags & PG_DEV) == 0);
@


1.3
log
@extend uvm_page_physload to have the ability to add "device" pages to the
system.

This is needed in the case where you need managed pages so you can
handle faulting and pmap_page_protect() on said pages when you manage
memory in such regions (i'm looking at you, graphics cards).

these pages are flagged PG_DEV, and shall never be on the freelists,
assert this. behaviour remains unchanged in the non-device case,
specifically for all archs currently in the tree we panic if called
after bootstrap.

ok art@@, kettenis@@, ariane@@, beck@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.2 2009/06/04 00:20:53 jsg Exp $	*/
d622 2
a623 11
		if (!desperate) {
			KASSERT(fcount == 0);
			fcount += uvm_pmr_get1page(count, memtype, result,
			    start, end);
		} else {
			for (memtype = 0; memtype < UVM_PMR_MEMTYPE_MAX &&
			    fcount < count; memtype++) {
				fcount += uvm_pmr_get1page(count - fcount,
				    memtype, result, start, end);
			}
		}
d691 1
d702 4
a705 3
		memtype = 0;
		goto ReTryDesperate;
	} else if (++memtype < UVM_PMR_MEMTYPE_MAX)
d707 1
a708 1
Fail:
@


1.2
log
@remove redefinitions of static and __inline ariane
says were debugging leftovers.

ok ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmemrange.c,v 1.1 2009/06/01 17:42:33 ariane Exp $	*/
d779 1
d810 1
@


1.1
log
@physmem allocator: change the view of free memory from single free pages
to free ranges.
Classify memory based on region with associated use-counter (which is used
to construct a priority list of where to allocate memory).

Based on code from tedu@@, help from many.
Ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a53 3
/* Cancel static calls (for profiling). */
#define static
#define __inline
a62 2
#undef static
#undef __inline
@

