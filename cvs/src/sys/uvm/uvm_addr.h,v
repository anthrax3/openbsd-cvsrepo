head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.6
	OPENBSD_6_2_BASE:1.7
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.5.0.6
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.2
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.4
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.2.0.10
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.6
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.4
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.2
	OPENBSD_5_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2017.01.17.17.19.21;	author stefan;	state Exp;
branches;
next	1.6;
commitid	v2YvnjMySRAyIm1v;

1.6
date	2016.09.16.01.51.40;	author dlg;	state Exp;
branches;
next	1.5;
commitid	VnUbZlTLXkN5bQhd;

1.5
date	2015.03.30.21.05.17;	author miod;	state Exp;
branches;
next	1.4;
commitid	7xl0eQAuOwSlCM52;

1.4
date	2015.02.05.23.51.06;	author mpi;	state Exp;
branches;
next	1.3;
commitid	ofjqNcubSq8nv7rW;

1.3
date	2014.06.10.20.08.48;	author kettenis;	state Exp;
branches;
next	1.2;
commitid	vDqiuTHW2RwTT2V3;

1.2
date	2012.03.15.17.52.28;	author ariane;	state Exp;
branches;
next	1.1;

1.1
date	2012.03.09.13.01.29;	author ariane;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Remove uaddr_hint allocator

The hint allocator would have to check that the
allocation does not overlap with brk, stack or text
areas. This would make the address selectors too
entagled. Just use the rnd allocator for hinted allocations
in case pivots are used. This also reduces the amount of code somewhat.

ok kettenis visa deraadt
@
text
@/*	$OpenBSD: uvm_addr.h,v 1.6 2016/09/16 01:51:40 dlg Exp $	*/

/*
 * Copyright (c) 2011 Ariane van der Steldt <ariane@@stack.nl>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _UVM_UVM_ADDR_H_
#define _UVM_UVM_ADDR_H_

/*
 * Address selection logic.
 *
 * Address selection is just that: selection. These functions may make no
 * changes to the map, except for their own state (which is passed as a
 * uaddr_state pointer).
 */


/*
 * UVM address selection base state.
 *
 * Each uvm address algorithm requires these parameters:
 * - lower bound address (page aligned)
 * - upper bound address (page aligned)
 * - function address pointers
 */
struct uvm_addr_state {
	vaddr_t uaddr_minaddr;
	vaddr_t uaddr_maxaddr;
	const struct uvm_addr_functions *uaddr_functions;
};

/*
 * This structure describes one algorithm implementation.
 *
 * Each algorithm is described in terms of:
 * - uaddr_select: an address selection algorithm
 * - uaddr_free_insert: a freelist insertion function (optional)
 * - uaddr_free_remove: a freelist deletion function (optional)
 * - uaddr_destroy: a destructor for the algorithm state
 */
struct uvm_addr_functions {
	int (*uaddr_select)(struct vm_map *map,
	    struct uvm_addr_state *uaddr,
	    struct vm_map_entry **entry_out, vaddr_t *addr_out,
	    vsize_t sz, vaddr_t align, vaddr_t offset,
	    vm_prot_t prot, vaddr_t hint);
	void (*uaddr_free_insert)(struct vm_map *map,
	    struct uvm_addr_state *uaddr_state,
	    struct vm_map_entry *entry);
	void (*uaddr_free_remove)(struct vm_map *map,
	    struct uvm_addr_state *uaddr_state,
	    struct vm_map_entry *entry);
	void (*uaddr_destroy)(struct uvm_addr_state *uaddr_state);
	void (*uaddr_print)(struct uvm_addr_state *uaddr_state, boolean_t full,
	    int (*pr)(const char *, ...));

	const char* uaddr_name;		/* Name of the allocator. */
};


#ifdef _KERNEL

void			 uvm_addr_init(void);
void			 uvm_addr_destroy(struct uvm_addr_state *);
vaddr_t			 uvm_addr_align(vaddr_t, vaddr_t, vaddr_t);
vaddr_t			 uvm_addr_align_back(vaddr_t, vaddr_t, vaddr_t);
int			 uvm_addr_linsearch(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    vaddr_t *addr_out, vaddr_t, vsize_t,
			    vaddr_t, vaddr_t, int, vaddr_t, vaddr_t,
			    vsize_t, vsize_t);
int			 uvm_addr_invoke(struct vm_map *,
			    struct uvm_addr_state *, struct vm_map_entry **,
			    struct vm_map_entry **, vaddr_t*,
			    vsize_t, vaddr_t, vaddr_t, vm_prot_t, vaddr_t);
#if 0
struct uvm_addr_state	*uaddr_lin_create(vaddr_t, vaddr_t);
#endif
struct uvm_addr_state	*uaddr_rnd_create(vaddr_t, vaddr_t);
#ifndef SMALL_KERNEL
struct uvm_addr_state	*uaddr_bestfit_create(vaddr_t, vaddr_t);
struct uvm_addr_state	*uaddr_pivot_create(vaddr_t, vaddr_t);
struct uvm_addr_state	*uaddr_stack_brk_create(vaddr_t, vaddr_t);
#endif /* SMALL_KERNEL */
int			 uvm_addr_fitspace(vaddr_t *, vaddr_t *,
			    vaddr_t, vaddr_t, vsize_t, vaddr_t, vaddr_t,
			    vsize_t, vsize_t);

#if defined(DEBUG) || defined(DDB)
void			 uvm_addr_print(struct uvm_addr_state *, const char *,
			    boolean_t, int (*pr)(const char *, ...));
#endif /* DEBUG || DDB */

/*
 * Kernel bootstrap allocator.
 */
RBT_HEAD(uaddr_free_rbtree, vm_map_entry);
RBT_PROTOTYPE(uaddr_free_rbtree, vm_map_entry, dfree.rbtree,
    uvm_mapent_fspace_cmp);

extern struct uvm_addr_state uaddr_kbootstrap;

#endif /* _KERNEL */
#endif /* _UVM_UVM_ADDR_H_ */
@


1.6
log
@move uaddr_free_rbtree from RB macros to RBT functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.h,v 1.5 2015/03/30 21:05:17 miod Exp $	*/
a92 1
struct uvm_addr_state	*uaddr_hint_create(vaddr_t, vaddr_t, vsize_t);
@


1.5
log
@#if 0 various unused definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.h,v 1.4 2015/02/05 23:51:06 mpi Exp $	*/
d111 2
a112 2
RB_HEAD(uaddr_free_rbtree, vm_map_entry);
RB_PROTOTYPE(uaddr_free_rbtree, vm_map_entry, dfree.rbtree,
@


1.4
log
@Remove some unneeded <uvm/uvm_extern.h> inclusions.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.h,v 1.3 2014/06/10 20:08:48 kettenis Exp $	*/
d89 1
d91 1
@


1.3
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.h,v 1.2 2012/03/15 17:52:28 ariane Exp $	*/
a20 2

#include <uvm/uvm_extern.h>
@


1.2
log
@Reduce installmedia pressure from new vmmap.

Has less special allocators on install media (where they aren't required
anyway).
Bonus: makes the vmmap initialization code easier to read.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_addr.h,v 1.1 2012/03/09 13:01:29 ariane Exp $	*/
d59 1
a59 1
	    struct vm_map_entry**entry_out, vaddr_t *addr_out,
d70 1
a70 1
	    int (*pr)(const char*, ...));
d79 1
a79 1
void			 uvm_addr_destroy(struct uvm_addr_state*);
d82 2
a83 2
int			 uvm_addr_linsearch(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
d87 3
a89 3
int			 uvm_addr_invoke(struct vm_map*,
			    struct uvm_addr_state*, struct vm_map_entry**,
			    struct vm_map_entry**, vaddr_t*,
d99 1
a99 1
int			 uvm_addr_fitspace(vaddr_t*, vaddr_t*,
d104 2
a105 2
void			 uvm_addr_print(struct uvm_addr_state*, const char*,
			    boolean_t, int (*pr)(const char*, ...));
@


1.1
log
@New vmmap implementation.

no oks (it is really a pain to review properly)
extensively tested, I'm confident it'll be stable
'now is the time' from several icb inhabitants

Diff provides:
- ability to specify different allocators for different regions/maps
- a simpler implementation of the current allocator
- currently in compatibility mode: it will generate similar addresses
  as the old allocator
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_map.h,v 1.46 2011/06/06 17:10:23 ariane Exp $	*/
d94 1
d98 1
@

