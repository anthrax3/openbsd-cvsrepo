head	1.27;
access;
symbols
	OPENBSD_6_2:1.27.0.2
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.25.0.2
	OPENBSD_5_9_BASE:1.25
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.18
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.10
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.8
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.18.0.6
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.18.0.4
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.18.0.2
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.6.0.2
	UBC_BASE:1.6
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.27
date	2016.10.19.08.28.19;	author guenther;	state Exp;
branches;
next	1.26;
commitid	VoR9X3uHTxRSYC5r;

1.26
date	2016.03.03.12.41.30;	author naddy;	state Exp;
branches;
next	1.25;
commitid	Ykztt9UU7jxBEqeD;

1.25
date	2015.11.10.08.21.28;	author mlarkin;	state Exp;
branches;
next	1.24;
commitid	HLPQzqC25IJVc8C6;

1.24
date	2015.02.15.21.34.33;	author miod;	state Exp;
branches;
next	1.23;
commitid	eahBabNpxnDWKzqJ;

1.23
date	2014.11.16.12.31.01;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	yv0ECmCdICvq576h;

1.22
date	2010.12.26.15.41.00;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2010.11.18.21.21.38;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.05.01.10.44;	author oga;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.18.49.45;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2005.04.04.23.40.05;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.29.20.50.33;	author drahn;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.24;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.10.18.29.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.18.07.48.11;	author hugh;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.18.07.42.45;	author hugh;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.15.35.48;	author dhartmei;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.04.41.18;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.00.58.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.16.18.06.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.11.28.19.28.15;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.28.14.29.13;	author art;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.28.14.20.16;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.28.14.13.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.06.01.35.04;	author art;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.11.14.10.19.26;	author ho;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2002.03.28.14.54.27;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.02.19.11.01.44;	author niklas;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.33.04;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2004.02.22.23.51.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Change pmap_proc_iflush() to take a process instead of a proc
powerpc: rename second argument of pmap_proc_iflush() to match other archs

ok kettenis@@
@
text
@/*	$OpenBSD: uvm_pmap.h,v 1.26 2016/03/03 12:41:30 naddy Exp $	*/
/*	$NetBSD: uvm_pmap.h,v 1.1 2000/06/27 09:00:14 mrg Exp $	*/

/* 
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * The Mach Operating System project at Carnegie-Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pmap.h	8.1 (Berkeley) 6/11/93
 *
 *
 * Copyright (c) 1987, 1990 Carnegie-Mellon University.
 * All rights reserved.
 *
 * Author: Avadis Tevanian, Jr.
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

/*
 *	Machine address mapping definitions -- machine-independent
 *	section.  [For machine-dependent section, see "machine/pmap.h".]
 */

#ifndef	_PMAP_VM_
#define	_PMAP_VM_

struct proc;		/* for pmap_activate()/pmap_deactivate() proto */

/*
 * Each machine dependent implementation is expected to
 * keep certain statistics.  They may do this anyway they
 * so choose, but are expected to return the statistics
 * in the following structure.
 */
struct pmap_statistics {
	long		resident_count;	/* # of pages mapped (total)*/
	long		wired_count;	/* # of pages wired */
};
typedef struct pmap_statistics	*pmap_statistics_t;

#include <machine/pmap.h>

/*
 * Flags passed to pmap_enter().  Note the bottom 3 bits are PROT_*
 * bits, used to indicate the access type that was made (to seed modified
 * and referenced information).
 */
#define	PMAP_WIRED	0x00000010	/* wired mapping */
#define	PMAP_CANFAIL	0x00000020	/* can fail if resource shortage */
#define	PMAP_MD0	0x00000040	/* Machine dependant */
#define	PMAP_MD1	0x00000080	/* Machine dependant */
#define	PMAP_MD2	0x00000100	/* Machine dependant */
#define	PMAP_MD3	0x00000200	/* Machine dependant */

#ifndef PMAP_EXCLUDE_DECLS	/* Used in Sparc port to virtualize pmap mod */
#ifdef _KERNEL
__BEGIN_DECLS
#ifndef	pmap_activate
void		 pmap_activate(struct proc *);
#endif
#ifndef	pmap_deactivate
void		 pmap_deactivate(struct proc *);
#endif
#ifndef	pmap_unwire
void		 pmap_unwire(pmap_t, vaddr_t);
#endif

#if !defined(pmap_clear_modify)
boolean_t	 pmap_clear_modify(struct vm_page *);
#endif
#if !defined(pmap_clear_reference)
boolean_t	 pmap_clear_reference(struct vm_page *);
#endif

#if !defined(pmap_collect)
void		 pmap_collect(pmap_t);
#endif
#if !defined(pmap_copy)
void		 pmap_copy(pmap_t, pmap_t, vaddr_t, vsize_t, vaddr_t);
#endif
#if !defined(pmap_copy_page)
void		 pmap_copy_page(struct vm_page *, struct vm_page *);
#endif
struct pmap 	 *pmap_create(void);
void		 pmap_destroy(pmap_t);
int		 pmap_enter(pmap_t,
		    vaddr_t, paddr_t, vm_prot_t, int);
boolean_t	 pmap_extract(pmap_t, vaddr_t, paddr_t *);
#if defined(PMAP_GROWKERNEL)
vaddr_t		 pmap_growkernel(vaddr_t);
#endif

void		 pmap_init(void);

void		 pmap_kenter_pa(vaddr_t, paddr_t, vm_prot_t);
void		 pmap_kremove(vaddr_t, vsize_t);
#if !defined(pmap_is_modified)
boolean_t	 pmap_is_modified(struct vm_page *);
#endif
#if !defined(pmap_is_referenced)
boolean_t	 pmap_is_referenced(struct vm_page *);
#endif

void		 pmap_page_protect(struct vm_page *, vm_prot_t);

#if !defined(pmap_proc_iflush)
void		pmap_proc_iflush(struct process *, vaddr_t, vsize_t);
#endif
void		 pmap_protect(pmap_t, vaddr_t, vaddr_t, vm_prot_t);
#if !defined(pmap_reference)
void		 pmap_reference(pmap_t);
#endif
#if !defined(pmap_remove)
void		 pmap_remove(pmap_t, vaddr_t, vaddr_t);
#endif
#if !defined(pmap_remove_holes)
void		pmap_remove_holes(struct vmspace *);
#endif
#if !defined(pmap_update)
void		 pmap_update(pmap_t);
#endif
#if !defined(pmap_zero_page)
void		 pmap_zero_page(struct vm_page *);
#endif

void		 pmap_virtual_space(vaddr_t *, vaddr_t *);
#if defined(PMAP_STEAL_MEMORY)
vaddr_t		 pmap_steal_memory(vsize_t, vaddr_t *, vaddr_t *);
#endif

/* nested pmaps are used in i386/amd64 vmm */
#ifndef pmap_nested
#define pmap_nested(pm) 0
#endif

__END_DECLS
#endif	/* kernel*/
#endif  /* PMAP_EXCLUDE_DECLS */

#endif /* _PMAP_VM_ */
@


1.26
log
@Remove option USER_LDT and everything depending on it.
Remove machdep.userldt sysctl.
Remove i386_[gs]et_ldt syscall stub from libi386.
Remove i386_[gs]et_ldt regression test.

ok mlarkin@@ millert@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.25 2015/11/10 08:21:28 mlarkin Exp $	*/
d152 1
a152 1
void		pmap_proc_iflush(struct proc *, vaddr_t, vsize_t);
@


1.25
log
@
UVM change needed for vmm.

discussed with miod, deraadt, and guenther.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.24 2015/02/15 21:34:33 miod Exp $	*/
a173 4
#endif

#if defined(PMAP_FORK)
void		pmap_fork(pmap_t, pmap_t);
@


1.24
log
@Change pmap_remove_holes() to take a vmspace instead of a map as its argument.

Use this on vax to correctly pick the end of the stack area now that the
stackgap adjustment code will no longer guarantee it is a fixed location.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.23 2014/11/16 12:31:01 deraadt Exp $	*/
d179 6
@


1.23
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.22 2010/12/26 15:41:00 miod Exp $	*/
d162 1
a162 1
void		pmap_remove_holes(struct vm_map *);
@


1.22
log
@Kill pmap_phys_address(), and force every driver's mmap() routine to return
a physical address [more precisely, something suitable to pass to pmap_enter()'sphysical address argument].

This allows MI drivers to implement mmap() routines without having to know
about the pmap_phys_address() implementation and #ifdef obfuscation.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.21 2010/11/18 21:21:38 miod Exp $	*/
d89 1
a89 1
 * Flags passed to pmap_enter().  Note the bottom 3 bits are VM_PROT_*
@


1.21
log
@Declare pmap_proc_iflush() in <uvm/uvm_pmap.h> unless <machine/pmap.h>
provides an inline version of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.20 2009/02/05 01:10:44 oga Exp $	*/
a150 3
#if !defined(pmap_phys_address)
paddr_t		 pmap_phys_address(paddr_t);
#endif
@


1.20
log
@Add some (currently unused) MD pmap flags to be used for pushing in
parameters such as cacheability, which is too different per-arch to be
MI.

discussed with miod, kettenis and art. ok miod@@, art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.19 2007/09/10 18:49:45 miod Exp $	*/
d154 4
a157 2
void		 pmap_protect(pmap_t,
		    vaddr_t, vaddr_t, vm_prot_t);
@


1.19
log
@Introduce a md pmap hook, pmap_remove_holes(), which is supposed to mark
the holes a MMU may have from a given vm_map. This will be automagically
invoked for newly created vmspaces.

On platforms with MMU holes (e.g. sun4, sun4c and vax), this prevents
mmap(2) hints which would end up being in the hole to be accepted as valid,
causing unexpected signals when the process tries to access the hole
(since pmap can not fill the hole anyway).

Unfortunately, the logic mmap() uses to pick a valid address for anonymous
mappings needs work, as it will only try to find an address higher than the
hint, which causes all mmap() with a hint in the hole to fail on vax. This
will be improved later.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.18 2005/04/04 23:40:05 miod Exp $	*/
d95 4
@


1.18
log
@Nuke pmap_bootstrap_alloc(), not used anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.17 2004/01/29 20:50:33 drahn Exp $	*/
d148 1
a148 1
paddr_t	 pmap_phys_address(int);
d157 3
@


1.17
log
@fix prototype of pmap_update(), ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.16 2003/06/02 23:28:24 millert Exp $	*/
a98 1
void		*pmap_bootstrap_alloc(int);
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.15 2002/09/10 18:29:44 art Exp $	*/
d160 1
a160 1
void		 pmap_update(void);
@


1.15
log
@Change the pmap_zero_page and pmap_copy_page API to take the struct vm_page *
instead of the pa. Most callers already had it handy and those who didn't
only called it for managed pages and were outside time-critical code.

This will allow us to make those functions clean and fast on sparc and
sparc64 letting us to avoid unnecessary cache flushes.

deraadt@@ miod@@ drahn@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.14 2002/03/18 07:48:11 hugh Exp $	*/
d19 1
a19 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@These are macro inlines on vax, so check if they're defined before
trying to prototype them. millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.13 2002/03/18 07:42:45 hugh Exp $	*/
d128 1
a128 1
void		 pmap_copy_page(paddr_t, paddr_t);
d167 1
a167 1
void		 pmap_zero_page(paddr_t);
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d121 1
d123 1
d127 1
d129 1
d157 1
d159 2
d162 1
d166 1
d168 1
@


1.12
log
@Prototype pmap_unwire() only if it's not already defined. ok drahn@@.
@
text
@d1 1
@


1.11
log
@do not proto pmap(de)activate if one was defined
@
text
@d109 1
d111 1
@


1.10
log
@First round of __P removal in sys
@
text
@d103 1
d105 2
d108 1
@


1.9
log
@Don't prototype pmap_copy() if it is a macro
@
text
@d102 4
a105 4
void		*pmap_bootstrap_alloc __P((int));
void		 pmap_activate __P((struct proc *));
void		 pmap_deactivate __P((struct proc *));
void		 pmap_unwire __P((pmap_t, vaddr_t));
d108 1
a108 1
boolean_t	 pmap_clear_modify __P((struct vm_page *));
d111 1
a111 1
boolean_t	 pmap_clear_reference __P((struct vm_page *));
d114 1
a114 1
void		 pmap_collect __P((pmap_t));
d116 1
a116 1
void		 pmap_copy __P((pmap_t, pmap_t, vaddr_t, vsize_t, vaddr_t));
d118 6
a123 6
void		 pmap_copy_page __P((paddr_t, paddr_t));
struct pmap 	 *pmap_create __P((void));
void		 pmap_destroy __P((pmap_t));
int		 pmap_enter __P((pmap_t,
		    vaddr_t, paddr_t, vm_prot_t, int));
boolean_t	 pmap_extract __P((pmap_t, vaddr_t, paddr_t *));
d125 1
a125 1
vaddr_t		 pmap_growkernel __P((vaddr_t));
d128 1
a128 1
void		 pmap_init __P((void));
d130 2
a131 2
void		 pmap_kenter_pa __P((vaddr_t, paddr_t, vm_prot_t));
void		 pmap_kremove __P((vaddr_t, vsize_t));
d133 1
a133 1
boolean_t	 pmap_is_modified __P((struct vm_page *));
d136 1
a136 1
boolean_t	 pmap_is_referenced __P((struct vm_page *));
d139 1
a139 1
void		 pmap_page_protect __P((struct vm_page *, vm_prot_t));
d142 1
a142 1
paddr_t	 pmap_phys_address __P((int));
d144 4
a147 4
void		 pmap_protect __P((pmap_t,
		    vaddr_t, vaddr_t, vm_prot_t));
void		 pmap_reference __P((pmap_t));
void		 pmap_remove __P((pmap_t, vaddr_t, vaddr_t));
d149 1
a149 1
void		 pmap_update __P((void));
d151 1
a151 1
void		 pmap_zero_page __P((paddr_t));
d153 1
a153 1
void		 pmap_virtual_space __P((vaddr_t *, vaddr_t *));
d155 1
a155 1
vaddr_t		 pmap_steal_memory __P((vsize_t, vaddr_t *, vaddr_t *));
d159 1
a159 1
void		pmap_fork __P((pmap_t, pmap_t));
@


1.8
log
@Don't prototype functions if they are really just macros.
@
text
@d115 3
a117 2
void		 pmap_copy __P((pmap_t,
		    pmap_t, vaddr_t, vsize_t, vaddr_t));
@


1.7
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d147 1
d149 1
@


1.6
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.9 2001/09/10 21:19:43 chris Exp $	*/
d3 1
a3 1
/*
d45 1
a45 1
 *
d51 3
a53 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d55 1
a55 1
 *
a88 1
#ifdef _KERNEL
a89 1
#endif
d102 1
a102 4
#if !defined(pmap_kernel)
struct pmap	*pmap_kernel __P((void));
#endif

d141 1
a141 1
paddr_t		pmap_phys_address __P((int));
d147 1
a147 7
void		 pmap_update __P((pmap_t));
#if !defined(pmap_resident_count)
long		 pmap_resident_count __P((pmap_t));
#endif
#if !defined(pmap_wired_count)
long		 pmap_wired_count __P((pmap_t));
#endif
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_pmap.h,v 1.1 2000/06/27 09:00:14 mrg Exp $	*/
d105 1
a105 10
struct pmap	*pmap_kernel(void);
#endif
#ifndef	pmap_activate
void		 pmap_activate(struct proc *);
#endif
#ifndef	pmap_deactivate
void		 pmap_deactivate(struct proc *);
#endif
#ifndef	pmap_unwire
void		 pmap_unwire(pmap_t, vaddr_t);
d107 4
d113 1
a113 1
boolean_t	 pmap_clear_modify(struct vm_page *);
d116 1
a116 1
boolean_t	 pmap_clear_reference(struct vm_page *);
d119 9
a127 14
#if !defined(pmap_collect)
void		 pmap_collect(pmap_t);
#endif
#if !defined(pmap_copy)
void		 pmap_copy(pmap_t, pmap_t, vaddr_t, vsize_t, vaddr_t);
#endif
#if !defined(pmap_copy_page)
void		 pmap_copy_page(paddr_t, paddr_t);
#endif
struct pmap 	 *pmap_create(void);
void		 pmap_destroy(pmap_t);
int		 pmap_enter(pmap_t,
		    vaddr_t, paddr_t, vm_prot_t, int);
boolean_t	 pmap_extract(pmap_t, vaddr_t, paddr_t *);
d129 1
a129 1
vaddr_t		 pmap_growkernel(vaddr_t);
d132 1
a132 1
void		 pmap_init(void);
d134 2
a135 2
void		 pmap_kenter_pa(vaddr_t, paddr_t, vm_prot_t);
void		 pmap_kremove(vaddr_t, vsize_t);
d137 1
a137 1
boolean_t	 pmap_is_modified(struct vm_page *);
d140 1
a140 1
boolean_t	 pmap_is_referenced(struct vm_page *);
d143 1
a143 1
void		 pmap_page_protect(struct vm_page *, vm_prot_t);
d146 1
a146 9
paddr_t	 pmap_phys_address(int);
#endif
void		 pmap_protect(pmap_t,
		    vaddr_t, vaddr_t, vm_prot_t);
#if !defined(pmap_reference)
void		 pmap_reference(pmap_t);
#endif
#if !defined(pmap_remove)
void		 pmap_remove(pmap_t, vaddr_t, vaddr_t);
d148 7
a154 2
#if !defined(pmap_update)
void		 pmap_update(void);
d156 2
a157 2
#if !defined(pmap_zero_page)
void		 pmap_zero_page(paddr_t);
d159 1
d161 1
a161 1
void		 pmap_virtual_space(vaddr_t *, vaddr_t *);
d163 1
a163 1
vaddr_t		 pmap_steal_memory(vsize_t, vaddr_t *, vaddr_t *);
d167 1
a167 1
void		pmap_fork(pmap_t, pmap_t);
@


1.6.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.6.2.1 2002/06/11 03:33:04 art Exp $	*/
d132 1
a132 1
void		 pmap_copy_page(struct vm_page *, struct vm_page *);
d171 1
a171 1
void		 pmap_zero_page(struct vm_page *);
@


1.6.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pmap.h,v 1.6.2.2 2002/10/29 00:36:50 art Exp $	*/
/*	$NetBSD: uvm_pmap.h,v 1.11 2002/09/22 07:17:25 chs Exp $	*/
@


1.6.2.4
log
@userland wants this
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.6.2.3 2002/11/04 18:02:33 art Exp $	*/
d90 1
d92 1
@


1.5
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.7 2001/05/25 04:06:17 chs Exp $	*/
d89 1
d91 1
d152 1
a152 1
void		 pmap_update __P((void));
@


1.4
log
@more sync to netbsd. some bugfixes in uvm_km_kmemalloc, lots of fixes in uvm_loan.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.5 2001/04/22 23:42:11 thorpej Exp $	*/
d3 1
a3 1
/* 
d45 1
a45 1
 * 
d51 3
a53 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d55 1
a55 1
 * 
d102 4
a105 1
void		*pmap_bootstrap_alloc __P((int));
d144 1
a144 1
paddr_t	 pmap_phys_address __P((int));
d151 6
@


1.3
log
@make pmap_virtual_space madatory in all pmaps.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.1 2000/06/27 09:00:14 mrg Exp $	*/
@


1.2
log
@pmap_kenter_pgs is not used and not really useful. remove.
@
text
@d150 1
a152 2
#else
void		 pmap_virtual_space __P((vaddr_t *, vaddr_t *));
@


1.1
log
@Move the last content from vm/ to uvm/
The only thing left in vm/ are just dumb wrappers.
vm/vm.h includes uvm/uvm_extern.h
vm/pmap.h includes uvm/uvm_pmap.h
vm/vm_page.h includes uvm/uvm_page.h
@
text
@a129 1
void		 pmap_kenter_pgs __P((vaddr_t, struct vm_page **, int));
@


1.1.2.1
log
@sync
@
text
@@


1.1.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.7 2001/05/25 04:06:17 chs Exp $	*/
d3 1
a3 1
/*
d45 1
a45 1
 *
d51 3
a53 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d55 1
a55 1
 *
d102 1
a102 4
#if !defined(pmap_kernel)
struct pmap	*pmap_kernel __P((void));
#endif

d130 1
d142 1
a142 1
paddr_t		pmap_phys_address __P((int));
a148 6
#if !defined(pmap_resident_count)
long		 pmap_resident_count __P((pmap_t));
#endif
#if !defined(pmap_wired_count)
long		 pmap_wired_count __P((pmap_t));
#endif
a150 1
void		 pmap_virtual_space __P((vaddr_t *, vaddr_t *));
d153 2
@


1.1.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pmap.h,v 1.1 2000/06/27 09:00:14 mrg Exp $	*/
d3 1
a3 1
/* 
d45 1
a45 1
 * 
d51 3
a53 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d55 1
a55 1
 * 
d102 4
a105 1
void		*pmap_bootstrap_alloc __P((int));
d144 1
a144 1
paddr_t	 pmap_phys_address __P((int));
a149 1
#if !defined(pmap_update)
d151 5
@


1.1.2.4
log
@Merge in -current from roughly a week ago
@
text
@a0 1
/*	$OpenBSD$	*/
d102 4
a105 10
void		*pmap_bootstrap_alloc(int);
#ifndef	pmap_activate
void		 pmap_activate(struct proc *);
#endif
#ifndef	pmap_deactivate
void		 pmap_deactivate(struct proc *);
#endif
#ifndef	pmap_unwire
void		 pmap_unwire(pmap_t, vaddr_t);
#endif
d108 1
a108 1
boolean_t	 pmap_clear_modify(struct vm_page *);
d111 1
a111 1
boolean_t	 pmap_clear_reference(struct vm_page *);
d114 9
a122 14
#if !defined(pmap_collect)
void		 pmap_collect(pmap_t);
#endif
#if !defined(pmap_copy)
void		 pmap_copy(pmap_t, pmap_t, vaddr_t, vsize_t, vaddr_t);
#endif
#if !defined(pmap_copy_page)
void		 pmap_copy_page(paddr_t, paddr_t);
#endif
struct pmap 	 *pmap_create(void);
void		 pmap_destroy(pmap_t);
int		 pmap_enter(pmap_t,
		    vaddr_t, paddr_t, vm_prot_t, int);
boolean_t	 pmap_extract(pmap_t, vaddr_t, paddr_t *);
d124 1
a124 1
vaddr_t		 pmap_growkernel(vaddr_t);
d127 1
a127 1
void		 pmap_init(void);
d129 2
a130 2
void		 pmap_kenter_pa(vaddr_t, paddr_t, vm_prot_t);
void		 pmap_kremove(vaddr_t, vsize_t);
d132 1
a132 1
boolean_t	 pmap_is_modified(struct vm_page *);
d135 1
a135 1
boolean_t	 pmap_is_referenced(struct vm_page *);
d138 1
a138 1
void		 pmap_page_protect(struct vm_page *, vm_prot_t);
d141 1
a141 9
paddr_t	 pmap_phys_address(int);
#endif
void		 pmap_protect(pmap_t,
		    vaddr_t, vaddr_t, vm_prot_t);
#if !defined(pmap_reference)
void		 pmap_reference(pmap_t);
#endif
#if !defined(pmap_remove)
void		 pmap_remove(pmap_t, vaddr_t, vaddr_t);
d143 4
d148 1
a148 4
void		 pmap_update(void);
#endif
#if !defined(pmap_zero_page)
void		 pmap_zero_page(paddr_t);
d150 1
d152 1
a152 1
void		 pmap_virtual_space(vaddr_t *, vaddr_t *);
d154 1
a154 1
vaddr_t		 pmap_steal_memory(vsize_t, vaddr_t *, vaddr_t *);
d158 1
a158 1
void		pmap_fork(pmap_t, pmap_t);
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d128 1
a128 1
void		 pmap_copy_page(struct vm_page *, struct vm_page *);
d167 1
a167 1
void		 pmap_zero_page(struct vm_page *);
@


1.1.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pmap.h,v 1.1.2.5 2003/03/28 00:08:48 niklas Exp $	*/
d19 5
a23 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.1.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d160 1
a160 1
void		 pmap_update(pmap_t);
@


