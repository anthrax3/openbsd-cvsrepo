head	1.29;
access;
symbols
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.6
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.8
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.27.0.20
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.27.0.16
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.27.0.14
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.27.0.12
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.10
	OPENBSD_5_0:1.27.0.8
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.27.0.6
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.27.0.4
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.2
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.26.0.4
	OPENBSD_4_6_BASE:1.26
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.22
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.20
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.18
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.16
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.14
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.12
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.10
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.8
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.6
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.29
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.28;
commitid	7NtJNW9udCOFtDNM;

1.28
date	2014.07.08.13.15.07;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	ciXrFuAjclTvL0IG;

1.27
date	2009.07.22.21.05.37;	author oga;	state Exp;
branches;
next	1.26;

1.26
date	2009.06.17.00.13.59;	author oga;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.16.00.11.29;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2009.06.01.19.54.02;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2009.03.27.16.29.33;	author oga;	state Exp;
branches;
next	1.22;

1.22
date	2009.03.25.20.00.18;	author oga;	state Exp;
branches;
next	1.21;

1.21
date	2008.11.24.19.55.33;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.02.23.28.24;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.15.01.20.04;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.27.18;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.19.28.15;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.28.13.47.40;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.10.18.42.31;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.07.02.55.50;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.00.20.22;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.12.21.36.48;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.06.14.03.05;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.26.19.37.13;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.22.03.05.56;	author smart;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.34.38;	author smart;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.48;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.15.50.20;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.24;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.17;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.51;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.28.14.54.27;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2003.06.07.11.09.09;	author ho;	state Exp;
branches;
next	;

1.16.2.1
date	2002.02.02.03.28.27;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.06.11.03.33.04;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@/*	$OpenBSD: uvm_pager.h,v 1.28 2014/07/08 13:15:07 deraadt Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.20 2000/11/27 08:40:05 chs Exp $	*/

/*
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_pager.h,v 1.1.2.14 1998/01/13 19:00:50 chuck Exp
 */

/*
 * Copyright (c) 1990 University of Utah.
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_pager.h	8.5 (Berkeley) 7/7/94
 */

#ifndef _UVM_UVM_PAGER_H_
#define _UVM_UVM_PAGER_H_

#ifdef _KERNEL

struct uvm_pagerops {
						/* init pager */
	void			(*pgo_init)(void);
						/* add reference to obj */
	void			(*pgo_reference)(struct uvm_object *);
						/* drop reference to obj */
	void			(*pgo_detach)(struct uvm_object *);
						/* special nonstd fault fn */
	int			(*pgo_fault)(struct uvm_faultinfo *, vaddr_t,
				 vm_page_t *, int, int, vm_fault_t,
				 vm_prot_t, int);
						/* flush pages out of obj */
	boolean_t		(*pgo_flush)(struct uvm_object *, voff_t,
				 voff_t, int);
						/* get/read page */
	int			(*pgo_get)(struct uvm_object *, voff_t,
				 vm_page_t *, int *, int, vm_prot_t, int, int);
						/* put/write page */
	int			(*pgo_put)(struct uvm_object *, vm_page_t *,
				 int, boolean_t);
						/* return range of cluster */
	void			(*pgo_cluster)(struct uvm_object *, voff_t,
				 voff_t *, voff_t *);
						/* make "put" cluster */
	struct vm_page **	(*pgo_mk_pcluster)(struct uvm_object *,
				 struct vm_page **, int *, struct vm_page *,
				 int, voff_t, voff_t);
};

/* pager flags [mostly for flush] */

#define PGO_CLEANIT	0x001	/* write dirty pages to backing store */
#define PGO_SYNCIO	0x002	/* if PGO_CLEANIT: use sync I/O? */
#define PGO_DEACTIVATE	0x004	/* deactivate flushed pages */
#define PGO_FREE	0x008	/* free flushed pages */
/* if PGO_FREE is not set then the pages stay where they are. */

#define PGO_ALLPAGES	0x010	/* flush whole object/get all pages */
#define PGO_DOACTCLUST	0x020	/* flag to mk_pcluster to include active */
#define PGO_LOCKED	0x040	/* fault data structures are locked [get] */
#define PGO_PDFREECLUST	0x080	/* daemon's free cluster flag [uvm_pager_put] */
#define PGO_REALLOCSWAP	0x100	/* reallocate swap area [pager_dropcluster] */

/* page we are not interested in getting */
#define PGO_DONTCARE ((struct vm_page *) -1L)	/* [get only] */

/*
 * prototypes
 */

void		uvm_pager_dropcluster(struct uvm_object *, struct vm_page *,
		    struct vm_page **, int *, int);
void		uvm_pager_init(void);
int		uvm_pager_put(struct uvm_object *, struct vm_page *, 
		    struct vm_page ***, int *, int, voff_t, voff_t);


vaddr_t		uvm_pagermapin(struct vm_page **, int, int);
void		uvm_pagermapout(vaddr_t, int);
struct vm_page **uvm_mk_pcluster(struct uvm_object *, struct vm_page **,
		    int *, struct vm_page *, int, voff_t, voff_t);

/* Flags to uvm_pagermapin() */
#define	UVMPAGER_MAPIN_WAITOK	0x01	/* it's okay to wait */
#define	UVMPAGER_MAPIN_READ	0x02	/* host <- device */
#define	UVMPAGER_MAPIN_WRITE	0x00	/* device -> host (pseudo flag) */

/*
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7

/*
 * XXX
 * this is needed until the device strategy interface
 * is changed to do physically-addressed i/o.
 */

#ifndef PAGER_MAP_SIZE
#define PAGER_MAP_SIZE       (16 * 1024 * 1024)
#endif

#endif /* _KERNEL */

#endif /* _UVM_UVM_PAGER_H_ */
@


1.28
log
@the #ifdef _KERNEL can wrap the entire file.  uvm_extern.h only pulls
this inside #ifdef _KERNEL in any case, so nothing really changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.27 2009/07/22 21:05:37 oga Exp $	*/
a4 1
 *
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.27
log
@Put the PG_RELEASED changes diff back in.

This has has been tested very very thoroughly on all archs we have
excepting 88k and 68k. Please see cvs log for the individual commit
messages.

ok beck@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.26 2009/06/17 00:13:59 oga Exp $	*/
d77 1
a77 7
/*
 * uvm_pager.h
 */

/*
 * pager ops
 */
a123 2

#ifdef _KERNEL
@


1.26
log
@date based reversion of uvm to the 4th May.

More backouts in line with previous ones, this appears to bring us back to a
stable condition.

A machine forced to 64mb of ram cycled 10GB through swap with this diff
and is still running as I type this. Other tests by ariane@@ and thib@@
also seem to show that it's alright.

ok deraadt@@, thib@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.23 2009/03/27 16:29:33 oga Exp $	*/
a111 2
						/* release page */
	boolean_t		(*pgo_releasepg)(struct vm_page *, struct vm_page **);
@


1.25
log
@Backout all changes to uvm after pmemrange (which will be backed out
separately).

a change at or just before the hackathon has either exposed or added a
very very nasty memory corruption bug that is giving us hell right now.
So in the interest of kernel stability these diffs are being backed out
until such a time as that corruption bug has been found and squashed,
then the ones that are proven good may slowly return.

a quick hitlist of the main commits this backs out:

mine:
uvm_objwire
the lock change in uvm_swap.c
using trees for uvm objects instead of the hash
removing the pgo_releasepg callback.

art@@'s:
putting pmap_page_protect(VM_PROT_NONE) in uvm_pagedeactivate() since
all callers called that just prior anyway.

ok beck@@, ariane@@.

prompted by deraadt@@.
@
text
@@


1.24
log
@Since we've now cleared up a lot of the PG_RELEASED setting, remove the
pgo_releasepg() hook and just free the page the "normal" way in the one
place we'll ever see PG_RELEASED and should care (uvm_page_unbusy,
called in aiodoned).

ok art@@, beck@@, thib@@
@
text
@d112 2
@


1.23
log
@remove PGO_OVERWRITE, PGO_WEAK and PGO_PASTEOF from the pager. They're all
unused.

ok art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.22 2009/03/25 20:00:18 oga Exp $	*/
a111 2
						/* release page */
	boolean_t		(*pgo_releasepg)(struct vm_page *, struct vm_page **);
@


1.22
log
@Move all of the pseudo-inline functions in uvm into C files.

By pseudo-inline, I mean that if a certain macro was defined, they would
be inlined. However, no architecture defines that, and none has for a
very very long time. Therefore mainly this just makes the code a damned
sight easier to read. Some k&r -> ansi declarations while I'm in there.

"just commit it" art@@. ok weingart@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.21 2008/11/24 19:55:33 thib Exp $	*/
a128 3
#define PGO_OVERWRITE	0x200	/* pages will be overwritten before unlocked */
#define PGO_WEAK	0x400	/* "weak" put, for nfs */
#define PGO_PASTEOF	0x800	/* allow allocation of pages past EOF */
@


1.21
log
@garbage collect uvm_errno2vmerror();

ok miod@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.20 2003/06/02 23:28:24 millert Exp $	*/
a138 10
 * handle inline options
 */

#ifdef UVM_PAGER_INLINE
#define PAGER_INLINE static __inline
#else 
#define PAGER_INLINE /* nothing */
#endif /* UVM_PAGER_INLINE */

/*
d142 2
a143 3
void		uvm_pager_dropcluster(struct uvm_object *, 
					struct vm_page *, struct vm_page **, 
					int *, int);
d146 1
a146 2
				   struct vm_page ***, int *, int, 
				   voff_t, voff_t);
a147 1
PAGER_INLINE struct vm_page *uvm_pageratop(vaddr_t);
d152 2
a153 2
				       int *, struct vm_page *, int, 
				       voff_t, voff_t);
@


1.20
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.19 2002/03/15 01:20:04 millert Exp $	*/
a166 2
int		uvm_errno2vmerror(int);

@


1.19
log
@Cosmetic changes only, primarily making comments line up nicely after the
__P removal.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.18 2002/03/14 01:27:18 millert Exp $	*/
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.17 2001/12/19 08:58:07 art Exp $	*/
d90 8
a97 4
	void		(*pgo_init)(void);/* init pager */
	void		(*pgo_reference)	/* add reference to obj */(struct uvm_object *);		
	void			(*pgo_detach)	/* drop reference to obj */(struct uvm_object *);
	int			(*pgo_fault)	/* special nonstd fault fn */(struct uvm_faultinfo *, vaddr_t,
d100 5
a104 2
	boolean_t		(*pgo_flush)	/* flush pages out of obj */(struct uvm_object *, voff_t, voff_t, int);
	int			(*pgo_get)	/* get/read page */(struct uvm_object *, voff_t,
d106 2
a107 1
	int			(*pgo_put)	/* put/write page */(struct uvm_object *, vm_page_t *, 
d109 9
a117 6
	void			(*pgo_cluster)	/* return range of cluster */(struct uvm_object *, voff_t, voff_t *,
				voff_t *);
	struct vm_page **	(*pgo_mk_pcluster)	/* make "put" cluster */(struct uvm_object *, struct vm_page **,
				 int *, struct vm_page *, int, voff_t,
				 voff_t);
	boolean_t		(*pgo_releasepg)	/* release page */(struct vm_page *, struct vm_page **);
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.14 2001/11/10 18:42:31 art Exp $	*/
d90 4
a93 7
	void		(*pgo_init) __P((void));/* init pager */
	void		(*pgo_reference)	/* add reference to obj */
			 __P((struct uvm_object *));		
	void			(*pgo_detach)	/* drop reference to obj */
			 __P((struct uvm_object *));
	int			(*pgo_fault)	/* special nonstd fault fn */
			 __P((struct uvm_faultinfo *, vaddr_t,
d95 9
a103 14
				 vm_prot_t, int));
	boolean_t		(*pgo_flush)	/* flush pages out of obj */
			 __P((struct uvm_object *, voff_t, voff_t, int));
	int			(*pgo_get)	/* get/read page */
			 __P((struct uvm_object *, voff_t,
				 vm_page_t *, int *, int, vm_prot_t, int, int));
	int			(*pgo_put)	/* put/write page */
			 __P((struct uvm_object *, vm_page_t *, 
				 int, boolean_t));
	void			(*pgo_cluster)	/* return range of cluster */
			__P((struct uvm_object *, voff_t, voff_t *,
				voff_t *));
	struct vm_page **	(*pgo_mk_pcluster)	/* make "put" cluster */
			 __P((struct uvm_object *, struct vm_page **,
d105 2
a106 3
				 voff_t));
	boolean_t		(*pgo_releasepg)	/* release page */
			 __P((struct vm_page *, struct vm_page **));
d145 1
a145 1
void		uvm_pager_dropcluster __P((struct uvm_object *, 
d147 3
a149 3
					int *, int));
void		uvm_pager_init __P((void));
int		uvm_pager_put __P((struct uvm_object *, struct vm_page *, 
d151 1
a151 1
				   voff_t, voff_t));
d153 1
a153 1
PAGER_INLINE struct vm_page *uvm_pageratop __P((vaddr_t));
d155 3
a157 3
vaddr_t		uvm_pagermapin __P((struct vm_page **, int, int));
void		uvm_pagermapout __P((vaddr_t, int));
struct vm_page **uvm_mk_pcluster  __P((struct uvm_object *, struct vm_page **,
d159 2
a160 2
				       voff_t, voff_t));
int		uvm_errno2vmerror __P((int));
@


1.16
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.15 2001/11/28 13:47:40 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.23 2001/05/26 21:27:21 chs Exp $	*/
d92 1
a92 1
			 __P((struct uvm_object *));
d97 1
a97 1
				 struct vm_page **, int, int, vm_fault_t,
d103 1
a103 2
				 struct vm_page **, int *, int, vm_prot_t, int,
			         int));
d105 1
a105 1
			 __P((struct uvm_object *, struct vm_page **,
d146 1
a146 1
#else
d154 2
a155 2
void		uvm_pager_dropcluster __P((struct uvm_object *,
					struct vm_page *, struct vm_page **,
d158 2
a159 2
int		uvm_pager_put __P((struct uvm_object *, struct vm_page *,
				   struct vm_page ***, int *, int,
d167 1
a167 1
				       int *, struct vm_page *, int,
d169 1
d175 21
@


1.16.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.16 2001/11/28 19:28:15 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.24 2001/09/15 20:36:47 chs Exp $	*/
a85 6
 * forward structure declarations
 */

struct uvm_faultinfo;

/*
d90 27
a116 20

	/* init pager */
	void	(*pgo_init) __P((void));

	/* add reference to obj */
	void	(*pgo_reference)(struct uvm_object *);

	/* drop reference to obj */
	void	(*pgo_detach)(struct uvm_object *);

	/* special non-standard fault processing */
	int	(*pgo_fault)(struct uvm_faultinfo *, vaddr_t, struct vm_page **,
			     int, int, vm_fault_t, vm_prot_t, int);

	/* get/read pages */
	int	(*pgo_get)(struct uvm_object *, voff_t, struct vm_page **,
			   int *, int, vm_prot_t, int, int);

	/* put/write pages */
	int	(*pgo_put)(struct uvm_object *, voff_t, voff_t, int);
d128 1
d130 2
d155 8
a162 1
void	uvm_pager_init __P((void));
d164 6
a169 2
vaddr_t	uvm_pagermapin __P((struct vm_page **, int, int));
void	uvm_pagermapout __P((vaddr_t, int));
d173 2
a174 2
#define	UVMPAGER_MAPIN_READ	0x02	/* device -> host */
#define	UVMPAGER_MAPIN_WRITE	0x00	/* host -> device (pseudo flag) */
@


1.16.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.16.2.1 2002/02/02 03:28:27 art Exp $	*/
d98 1
a98 1
	void	(*pgo_init)(void);
d151 4
a154 4
void	uvm_pager_init(void);
PAGER_INLINE struct vm_page *uvm_pageratop(vaddr_t);
vaddr_t	uvm_pagermapin(struct vm_page **, int, int);
void	uvm_pagermapout(vaddr_t, int);
@


1.16.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.16.2.2 2002/06/11 03:33:04 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.25 2002/03/25 02:08:10 chs Exp $	*/
d129 2
a130 1
#define PGO_PASTEOF	0x400	/* allow allocation of pages past EOF */
@


1.15
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.14 2001/11/10 18:42:31 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.21 2001/03/10 22:46:50 chs Exp $	*/
d92 1
a92 1
			 __P((struct uvm_object *));		
d97 1
a97 1
				 vm_page_t *, int, int, vm_fault_t,
d103 2
a104 1
				 vm_page_t *, int *, int, vm_prot_t, int, int));
d106 1
a106 1
			 __P((struct uvm_object *, vm_page_t *, 
d147 1
a147 1
#else 
d155 2
a156 2
void		uvm_pager_dropcluster __P((struct uvm_object *, 
					struct vm_page *, struct vm_page **, 
d159 2
a160 2
int		uvm_pager_put __P((struct uvm_object *, struct vm_page *, 
				   struct vm_page ***, int *, int, 
d168 1
a168 1
				       int *, struct vm_page *, int, 
@


1.14
log
@Merge in some parts of the ubc work that has been done in NetBSD that are not
UBC, but prerequsites for it.

- Create a daemon that processes async I/O (swap and paging in the future)
  requests that need processing in process context and that were processed
  in the pagedaemon before.
- Convert some ugly ifdef DIAGNOSTIC code to less intrusive KASSERTs.
- misc other cleanups.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.13 2001/11/07 02:55:50 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.20 2000/11/27 08:40:05 chs Exp $	*/
a168 1
int		uvm_errno2vmerror __P((int));
a173 21

/*
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7
@


1.13
log
@Another sync of uvm to NetBSD. Just minor fiddling, no major changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.12 2001/11/06 00:20:22 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.18 2000/11/24 22:41:39 chs Exp $	*/
a85 15
 * async pager i/o descriptor structure
 */

TAILQ_HEAD(uvm_aiohead, uvm_aiodesc);

struct uvm_aiodesc {
	void (*aiodone) __P((struct uvm_aiodesc *));
						/* aio done function */
	vaddr_t kva;			/* KVA of mapped page(s) */
	int npages;				/* # of pages in I/O req */
	void *pd_ptr;				/* pager-dependent pointer */
	TAILQ_ENTRY(uvm_aiodesc) aioq;		/* linked list of aio's */
};

/*
d121 1
a121 5
#define PGO_SYNCIO	0x002	/* if PGO_CLEAN: use sync I/O? */
/*
 * obviously if neither PGO_INVALIDATE or PGO_FREE are set then the pages
 * stay where they are.
 */
d124 1
d131 3
d136 1
a136 1
#define PGO_DONTCARE ((struct vm_page *) -1)	/* [get only] */
d164 1
a164 2
vaddr_t	uvm_pagermapin __P((struct vm_page **, int, 
				    struct uvm_aiodesc **, int));
d169 1
d203 1
d205 1
@


1.12
log
@Minor sync to NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.11 2001/08/12 21:36:48 mickey Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.16 2000/06/26 14:21:18 mrg Exp $	*/
a118 2
	int			(*pgo_asyncget)	/* start async get */
			 __P((struct uvm_object *, voff_t, int));
a128 2
	void			(*pgo_aiodone)		/* async iodone */
			 __P((struct uvm_aiodesc *));
d211 8
@


1.11
log
@vm_pager.h no more
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.10 2001/08/11 10:57:22 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.15 2000/05/19 03:45:04 thorpej Exp $	*/
d38 40
a159 21
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7

/*
d194 21
@


1.10
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.9 2001/08/06 14:03:05 art Exp $	*/
d118 21
@


1.9
log
@Add a new type voff_t (right now it's typedefed as off_t) used for offsets
into objects.

Gives the possibilty to mmap beyond the size of vaddr_t.

From NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.8 2001/07/26 19:37:13 art Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.12 2000/03/26 20:54:47 kleink Exp $	*/
a90 2
	void			(*pgo_shareprot)	/* share protect */
			 __P((vm_map_entry_t, vm_prot_t));
d149 5
a153 1
void		uvm_shareprot __P((vm_map_entry_t, vm_prot_t));
@


1.8
log
@Add support for disabling swap devices (swapctl -d).
Improve error handling on I/O errors to swap.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.7 2001/03/22 03:05:56 smart Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.11 2000/01/11 06:57:50 chs Exp $	*/
d75 1
a75 1
			 __P((struct uvm_object *, vaddr_t, vaddr_t, int));
d77 1
a77 1
			 __P((struct uvm_object *, vaddr_t, 
d80 1
a80 1
			 __P((struct uvm_object *, vaddr_t, int));
d85 2
a86 2
			__P((struct uvm_object *, vaddr_t, vaddr_t *,
				vaddr_t *));
d89 2
a90 2
				 int *, struct vm_page *, int, vaddr_t,
				 vaddr_t));
d141 1
a141 1
				   vaddr_t, vaddr_t));
d150 1
a150 1
				       vaddr_t, vaddr_t));
@


1.7
log
@Sync style, typo, and comments a little closer to NetBSD.  art@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.6 2001/03/09 05:34:38 smart Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.10 1999/06/21 17:25:12 thorpej Exp $	*/
d137 1
a137 1
					int *, int, int));
@


1.6
log
@Protect protypes, certain macros, and inlines from userland.  Checked userland
with a 'make build'.  From NetBSD.  art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.5 2001/01/29 02:07:48 niklas Exp $	*/
d75 1
a75 2
			 __P((struct uvm_object *, vaddr_t, 
				vaddr_t, int));
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_pager.h,v 1.9 1999/03/25 18:48:55 mrg Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.9 1999/03/25 18:48:55 mrg Exp $	*/
d120 2
d154 1
@


1.4
log
@Fix the NetBSD id strings.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pager.h,v 1.8 1999/03/24 03:45:28 cgd Exp $	*/
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_pager.h,v 1.9 1999/03/25 18:48:55 mrg Exp $	*/
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: uvm_pager.h,v 1.7 2001/03/22 03:05:56 smart Exp $	*/
/*	$NetBSD: uvm_pager.h,v 1.10 1999/06/21 17:25:12 thorpej Exp $	*/
d74 2
a75 1
			 __P((struct uvm_object *, vaddr_t, vaddr_t, int));
a118 2
#ifdef _KERNEL

a150 1
#endif /* _KERNEL */
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_pager.h,v 1.15 2000/05/19 03:45:04 thorpej Exp $	*/
d75 1
a75 1
			 __P((struct uvm_object *, voff_t, voff_t, int));
d77 1
a77 1
			 __P((struct uvm_object *, voff_t,
d80 1
a80 1
			 __P((struct uvm_object *, voff_t, int));
d85 2
a86 2
			__P((struct uvm_object *, voff_t, voff_t *,
				voff_t *));
d89 4
a92 2
				 int *, struct vm_page *, int, voff_t,
				 voff_t));
a121 21
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7

/*
d137 1
a137 1
					int *, int));
d141 1
a141 1
				   voff_t, voff_t));
d150 2
a151 6
				       voff_t, voff_t));

/* Flags to uvm_pagermapin() */
#define	UVMPAGER_MAPIN_WAITOK	0x01	/* it's okay to wait */
#define	UVMPAGER_MAPIN_READ	0x02	/* host <- device */
#define	UVMPAGER_MAPIN_WRITE	0x00	/* device -> host (pseudo flag) */
@


1.3.4.4
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_pager.h,v 1.20 2000/11/27 08:40:05 chs Exp $	*/
a37 40
/*
 * Copyright (c) 1990 University of Utah.
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_pager.h	8.5 (Berkeley) 7/7/94
 */

d46 15
d79 2
d91 2
d100 5
a104 1
#define PGO_SYNCIO	0x002	/* if PGO_CLEANIT: use sync I/O? */
a106 1
/* if PGO_FREE is not set then the pages stay where they are. */
a112 3
#define PGO_OVERWRITE	0x200	/* pages will be overwritten before unlocked */
#define PGO_WEAK	0x400	/* "weak" put, for nfs */
#define PGO_PASTEOF	0x800	/* allow allocation of pages past EOF */
d115 1
a115 1
#define PGO_DONTCARE ((struct vm_page *) -1L)	/* [get only] */
d120 21
d164 2
a165 1
vaddr_t		uvm_pagermapin __P((struct vm_page **, int, int));
a169 1
int		uvm_errno2vmerror __P((int));
a174 31

/*
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7

/*
 * XXX
 * this is needed until the device strategy interface
 * is changed to do physically-addressed i/o.
 */

#ifndef PAGER_MAP_SIZE
#define PAGER_MAP_SIZE       (16 * 1024 * 1024)
#endif
@


1.3.4.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_pager.h,v 1.23 2001/05/26 21:27:21 chs Exp $	*/
d92 1
a92 1
			 __P((struct uvm_object *));
d97 1
a97 1
				 struct vm_page **, int, int, vm_fault_t,
d103 1
a103 2
				 struct vm_page **, int *, int, vm_prot_t, int,
			         int));
d105 1
a105 1
			 __P((struct uvm_object *, struct vm_page **,
d146 1
a146 1
#else
d154 2
a155 2
void		uvm_pager_dropcluster __P((struct uvm_object *,
					struct vm_page *, struct vm_page **,
d158 2
a159 2
int		uvm_pager_put __P((struct uvm_object *, struct vm_page *,
				   struct vm_page ***, int *, int,
d167 1
a167 1
				       int *, struct vm_page *, int,
d169 1
d175 21
@


1.3.4.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_pager.h,v 1.20 2000/11/27 08:40:05 chs Exp $	*/
d92 1
a92 1
			 __P((struct uvm_object *));		
d97 1
a97 1
				 vm_page_t *, int, int, vm_fault_t,
d103 2
a104 1
				 vm_page_t *, int *, int, vm_prot_t, int, int));
d106 1
a106 1
			 __P((struct uvm_object *, vm_page_t *, 
d147 1
a147 1
#else 
d155 2
a156 2
void		uvm_pager_dropcluster __P((struct uvm_object *, 
					struct vm_page *, struct vm_page **, 
d159 2
a160 2
int		uvm_pager_put __P((struct uvm_object *, struct vm_page *, 
				   struct vm_page ***, int *, int, 
d168 1
a168 1
				       int *, struct vm_page *, int, 
a169 1
int		uvm_errno2vmerror __P((int));
a174 21

/*
 * get/put return values
 * OK	   operation was successful
 * BAD	   specified data was out of the accepted range
 * FAIL	   specified data was in range, but doesn't exist
 * PEND	   operations was initiated but not completed
 * ERROR   error while accessing data that is in range and exists
 * AGAIN   temporary resource shortage prevented operation from happening
 * UNLOCK  unlock the map and try again
 * REFAULT [uvm_fault internal use only!] unable to relock data structures,
 *         thus the mapping needs to be reverified before we can procede
 */
#define	VM_PAGER_OK		0
#define	VM_PAGER_BAD		1
#define	VM_PAGER_FAIL		2
#define	VM_PAGER_PEND		3
#define	VM_PAGER_ERROR		4
#define VM_PAGER_AGAIN		5
#define VM_PAGER_UNLOCK		6
#define VM_PAGER_REFAULT	7
@


1.3.4.7
log
@Merge in -current from roughly a week ago
@
text
@d90 7
a96 8
						/* init pager */
	void			(*pgo_init)(void);
						/* add reference to obj */
	void			(*pgo_reference)(struct uvm_object *);
						/* drop reference to obj */
	void			(*pgo_detach)(struct uvm_object *);
						/* special nonstd fault fn */
	int			(*pgo_fault)(struct uvm_faultinfo *, vaddr_t,
d98 18
a115 19
				 vm_prot_t, int);
						/* flush pages out of obj */
	boolean_t		(*pgo_flush)(struct uvm_object *, voff_t,
				 voff_t, int);
						/* get/read page */
	int			(*pgo_get)(struct uvm_object *, voff_t,
				 vm_page_t *, int *, int, vm_prot_t, int, int);
						/* put/write page */
	int			(*pgo_put)(struct uvm_object *, vm_page_t *,
				 int, boolean_t);
						/* return range of cluster */
	void			(*pgo_cluster)(struct uvm_object *, voff_t,
				 voff_t *, voff_t *);
						/* make "put" cluster */
	struct vm_page **	(*pgo_mk_pcluster)(struct uvm_object *,
				 struct vm_page **, int *, struct vm_page *,
				 int, voff_t, voff_t);
						/* release page */
	boolean_t		(*pgo_releasepg)(struct vm_page *, struct vm_page **);
d154 1
a154 1
void		uvm_pager_dropcluster(struct uvm_object *, 
d156 3
a158 3
					int *, int);
void		uvm_pager_init(void);
int		uvm_pager_put(struct uvm_object *, struct vm_page *, 
d160 1
a160 1
				   voff_t, voff_t);
d162 1
a162 1
PAGER_INLINE struct vm_page *uvm_pageratop(vaddr_t);
d164 3
a166 3
vaddr_t		uvm_pagermapin(struct vm_page **, int, int);
void		uvm_pagermapout(vaddr_t, int);
struct vm_page **uvm_mk_pcluster(struct uvm_object *, struct vm_page **,
d168 2
a169 2
				       voff_t, voff_t);
int		uvm_errno2vmerror(int);
@


1.3.4.8
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_pager.h,v 1.3.4.7 2002/03/28 14:54:27 niklas Exp $	*/
d55 5
a59 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2
log
@add OpenBSD tags
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_pager.h,v 1.7 1998/08/13 02:11:03 eeh Exp $	*/
a3 4
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
/*
a64 2
	struct uvm_object * (*pgo_attach)	/* get uvm_object */
			__P((void *, vm_prot_t));
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

