head	1.35;
access;
symbols
	OPENBSD_5_3:1.34.0.14
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.34.0.12
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.10
	OPENBSD_5_0:1.34.0.8
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.6
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.4
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.34.0.2
	OPENBSD_4_7_BASE:1.34
	OPENBSD_4_6:1.33.0.4
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.28.0.8
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.6
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.10
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.8
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.6
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.8
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.6
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.19.0.4
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.19.0.2
	OPENBSD_3_1_BASE:1.19
	UBC_SYNC_B:1.19
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.35
date	2013.05.29.22.23.01;	author tedu;	state dead;
branches;
next	1.34;

1.34
date	2009.07.22.21.05.37;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.17.00.13.59;	author oga;	state Exp;
branches;
next	1.32;

1.32
date	2009.06.16.00.11.29;	author oga;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.01.19.54.02;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2009.05.08.13.50.15;	author ariane;	state Exp;
branches;
next	1.29;

1.29
date	2009.03.20.15.19.04;	author oga;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.18.21.51.15;	author pedro;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.31.21.20.30;	author thib;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.13.18.57.49;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.04.17.44.45;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2007.03.26.08.43.34;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2007.03.25.11.31.07;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.13.22.51.26;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.21.16.20.05;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.08.22.19.57;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.01.27.18;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.02.22.23.25;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.04.23.22.42;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.28.19.28.14;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.28.14.29.13;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.11.01.16.56;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.06.01.35.04;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.05.22.14.54;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.11.20.05.26;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.15.21.37;	author smart;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.22.11.04;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.24;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.14;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.49;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.46;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2004.02.19.11.01.44;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.01.31.22.55.51;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.06.11.03.33.03;	author art;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.35
log
@uvm_loan has not (ever) been compiled or used.
@
text
@/*	$OpenBSD: uvm_loan.c,v 1.34 2009/07/22 21:05:37 oga Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.22 2000/06/27 17:29:25 mrg Exp $	*/

/*
 *
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_loan.c,v 1.1.6.4 1998/02/06 05:08:43 chs Exp
 */

/*
 * uvm_loan.c: page loanout handler
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/malloc.h>
#include <sys/mman.h>

#include <uvm/uvm.h>

/*
 * "loaned" pages are pages which are (read-only, copy-on-write) loaned 
 * from the VM system to other parts of the kernel.   this allows page
 * copying to be avoided (e.g. you can loan pages from objs/anons to
 * the mbuf system).
 *
 * there are 3 types of loans possible:
 *  O->K  uvm_object page to wired kernel page (e.g. mbuf data area)
 *  A->K  anon page to wired kernel page (e.g. mbuf data area)
 *  O->A  uvm_object to anon loan (e.g. vnode page to an anon)
 * note that it possible to have an O page loaned to both an A and K
 * at the same time.
 *
 * loans are tracked by pg->loan_count.  an O->A page will have both
 * a uvm_object and a vm_anon, but PQ_ANON will not be set.   this sort
 * of page is considered "owned" by the uvm_object (not the anon).
 *
 * each loan of a page to the kernel bumps the pg->wire_count.  the
 * kernel mappings for these pages will be read-only and wired.  since
 * the page will also be wired, it will not be a candidate for pageout,
 * and thus will never be pmap_page_protect()'d with VM_PROT_NONE.  a
 * write fault in the kernel to one of these pages will not cause
 * copy-on-write.  instead, the page fault is considered fatal.  this
 * is because the kernel mapping will have no way to look up the
 * object/anon which the page is owned by.  this is a good side-effect,
 * since a kernel write to a loaned page is an error.
 *
 * owners that want to free their pages and discover that they are 
 * loaned out simply "disown" them (the page becomes an orphan).  these
 * pages should be freed when the last loan is dropped.   in some cases
 * an anon may "adopt" an orphaned page.
 *
 * locking: to read pg->loan_count either the owner or the page queues
 * must be locked.   to modify pg->loan_count, both the owner of the page
 * and the PQs must be locked.   pg->flags is (as always) locked by
 * the owner of the page.
 *
 * note that locking from the "loaned" side is tricky since the object
 * getting the loaned page has no reference to the page's owner and thus
 * the owner could "die" at any time.   in order to prevent the owner
 * from dying the page queues should be locked.   this forces us to sometimes
 * use "try" locking.
 *
 * loans are typically broken by the following events:
 *  1. write fault to a loaned page 
 *  2. pageout of clean+inactive O->A loaned page
 *  3. owner frees page (e.g. pager flush)
 *
 * note that loaning a page causes all mappings of the page to become
 * read-only (via pmap_page_protect).   this could have an unexpected
 * effect on normal "wired" pages if one is not careful (XXX).
 */

/*
 * local prototypes
 */

static int	uvm_loananon(struct uvm_faultinfo *, void ***, 
				int, struct vm_anon *);
static int	uvm_loanentry(struct uvm_faultinfo *, void ***, int);
static int	uvm_loanuobj(struct uvm_faultinfo *, void ***, 
				int, vaddr_t);
static int	uvm_loanzero(struct uvm_faultinfo *, void ***, int);

/*
 * inlines
 */

/*
 * uvm_loanentry: loan out pages in a map entry (helper fn for uvm_loan())
 *
 * => "ufi" is the result of a successful map lookup (meaning that
 *	the maps are locked by the caller)
 * => we may unlock the maps if needed (for I/O)
 * => we put our output result in "output"
 * => we return the number of pages we loaned, or -1 if we had an error
 */

static __inline int
uvm_loanentry(struct uvm_faultinfo *ufi, void ***output, int flags)
{
	vaddr_t curaddr = ufi->orig_rvaddr;
	vsize_t togo = ufi->size;
	struct vm_aref *aref = &ufi->entry->aref;
	struct uvm_object *uobj = ufi->entry->object.uvm_obj;
	struct vm_anon *anon;
	int rv, result = 0;

	/*
	 * lock us the rest of the way down
	 */
	if (uobj)
		simple_lock(&uobj->vmobjlock);

	/*
	 * loop until done
	 */
	while (togo) {

		/*
		 * find the page we want.   check the anon layer first.
		 */

		if (aref->ar_amap) {
			anon = amap_lookup(aref, curaddr - ufi->entry->start);
		} else {
			anon = NULL;
		}

		if (anon) {
			rv = uvm_loananon(ufi, output, flags, anon);
		} else if (uobj) {
			rv = uvm_loanuobj(ufi, output, flags, curaddr);
		} else if (UVM_ET_ISCOPYONWRITE(ufi->entry)) {
			rv = uvm_loanzero(ufi, output, flags);
		} else {
			rv = -1;		/* null map entry... fail now */
		}

		/* total failure */
		if (rv < 0)
			return(-1);

		/* relock failed, need to do another lookup */
		if (rv == 0)
			return(result);

		/*
		 * got it... advance to next page
		 */
		result++;
		togo -= PAGE_SIZE;
		curaddr += PAGE_SIZE;
	}

	/*
	 * unlock everything and return
	 */
	uvmfault_unlockall(ufi, aref->ar_amap, uobj, NULL);
	return(result);
}

/*
 * normal functions
 */

/*
 * uvm_loan: loan pages out to anons or to the kernel
 * 
 * => map should be unlocked
 * => start and len should be multiples of PAGE_SIZE
 * => result is either an array of anon's or vm_pages (depending on flags)
 * => flag values: UVM_LOAN_TOANON - loan to anons
 *                 UVM_LOAN_TOPAGE - loan to wired kernel page
 *    one and only one of these flags must be set!
 */

int
uvm_loan(struct vm_map *map, vaddr_t start, vsize_t len,
    void **result, int flags)
{
	struct uvm_faultinfo ufi;
	void **output;
	int rv;

#ifdef DIAGNOSTIC
	if (map->flags & VM_MAP_INTRSAFE)
		panic("uvm_loan: intrsafe map");
#endif

	/*
	 * ensure that one and only one of the flags is set
	 */

	if ((flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 
	    (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE) ||
	    (flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 0)
		return (EFAULT);

	/*
	 * "output" is a pointer to the current place to put the loaned
	 * page...
	 */

	output = &result[0];	/* start at the beginning ... */

	/*
	 * while we've got pages to do
	 */

	while (len > 0) {

		/*
		 * fill in params for a call to uvmfault_lookup
		 */

		ufi.orig_map = map;
		ufi.orig_rvaddr = start;
		ufi.orig_size = len;
		
		/*
		 * do the lookup, the only time this will fail is if we hit on
		 * an unmapped region (an error)
		 */

		if (!uvmfault_lookup(&ufi, FALSE)) 
			goto fail;

		/*
		 * map now locked.  now do the loanout...
		 */
		rv = uvm_loanentry(&ufi, &output, flags);
		if (rv < 0) 
			goto fail;

		/*
		 * done!  the map is unlocked.  advance, if possible.
		 *
		 * XXXCDC: could be recoded to hold the map lock with   
		 *	   smarter code (but it only happens on map entry
		 *	   boundaries, so it isn't that bad).
		 */
		if (rv) {
			rv <<= PAGE_SHIFT;
			len -= rv;
			start += rv;
		}
	}
	
	/*
	 * got it!   return success.
	 */

	return (0);

fail:
	/*
	 * fail: failed to do it.   drop our loans and return failure code.
	 */
	if (output - result) {
		if (flags & UVM_LOAN_TOANON)
			uvm_unloananon((struct vm_anon **)result,
			    output - result);
		else
			uvm_unloanpage((struct vm_page **)result,
			    output - result);
	}
	return (EFAULT);
}

/*
 * uvm_loananon: loan a page from an anon out
 * 
 * => return value:
 *	-1 = fatal error, everything is unlocked, abort.
 *	 0 = lookup in ufi went stale, everything unlocked, relookup and
 *		try again
 *	 1 = got it, everything still locked
 */

int
uvm_loananon(struct uvm_faultinfo *ufi, void ***output, int flags,
    struct vm_anon *anon)
{
	struct vm_page *pg;
	int result;

	/*
	 * if we are loaning to another anon then it is easy, we just
	 * bump the reference count on the current anon and return a
	 * pointer to it.
	 */
	if (flags & UVM_LOAN_TOANON) {
		simple_lock(&anon->an_lock);
		pg = anon->an_page;
		if (pg && (pg->pg_flags & PQ_ANON) != 0 && anon->an_ref == 1)
			/* read protect it */
			pmap_page_protect(pg, VM_PROT_READ);
		anon->an_ref++;
		**output = anon;
		*output = (*output) + 1;
		simple_unlock(&anon->an_lock);
		return(1);
	}

	/*
	 * we are loaning to a kernel-page.   we need to get the page
	 * resident so we can wire it.   uvmfault_anonget will handle
	 * this for us.
	 */

	simple_lock(&anon->an_lock);
	result = uvmfault_anonget(ufi, ufi->entry->aref.ar_amap, anon);

	/*
	 * if we were unable to get the anon, then uvmfault_anonget has
	 * unlocked everything and returned an error code.
	 */

	if (result != VM_PAGER_OK) {

		/* need to refault (i.e. refresh our lookup) ? */
		if (result == VM_PAGER_REFAULT)
			return(0);

		/* "try again"?   sleep a bit and retry ... */
		if (result == VM_PAGER_AGAIN) {
			tsleep((caddr_t)&lbolt, PVM, "loanagain", 0);
			return(0);
		}

		/* otherwise flag it as an error */
		return(-1);
	}

	/*
	 * we have the page and its owner locked: do the loan now.
	 */

	pg = anon->an_page;
	uvm_lock_pageq();
	if (pg->loan_count == 0)
		pmap_page_protect(pg, VM_PROT_READ);
	pg->loan_count++;
	uvm_pagewire(pg);	/* always wire it */
	uvm_unlock_pageq();
	**output = pg;
	*output = (*output) + 1;

	/* unlock anon and return success */
	if (pg->uobject)
		simple_unlock(&pg->uobject->vmobjlock);
	simple_unlock(&anon->an_lock);
	return(1);
}

/*
 * uvm_loanuobj: loan a page from a uobj out
 *
 * => return value:
 *	-1 = fatal error, everything is unlocked, abort.
 *	 0 = lookup in ufi went stale, everything unlocked, relookup and
 *		try again
 *	 1 = got it, everything still locked
 */

int
uvm_loanuobj(struct uvm_faultinfo *ufi, void ***output, int flags, vaddr_t va)
{
	struct vm_amap *amap = ufi->entry->aref.ar_amap;
	struct uvm_object *uobj = ufi->entry->object.uvm_obj;
	struct vm_page *pg;
	struct vm_anon *anon;
	int result, npages;
	boolean_t locked;

	/*
	 * first we must make sure the page is resident.
	 *
	 * XXXCDC: duplicate code with uvm_fault().
	 */

	if (uobj->pgops->pgo_get) {
		npages = 1;
		pg = NULL;
		result = uobj->pgops->pgo_get(uobj, va - ufi->entry->start,
		    &pg, &npages, 0, VM_PROT_READ, MADV_NORMAL, PGO_LOCKED);
	} else {
		result = VM_PAGER_ERROR;
	}

	/*
	 * check the result of the locked pgo_get.  if there is a problem,
	 * then we fail the loan.
	 */

	if (result != VM_PAGER_OK && result != VM_PAGER_UNLOCK) {
		uvmfault_unlockall(ufi, amap, uobj, NULL);
		return(-1);
	}

	/*
	 * if we need to unlock for I/O, do so now.
	 */

	if (result == VM_PAGER_UNLOCK) {
		uvmfault_unlockall(ufi, amap, NULL, NULL);
		
		npages = 1;
		/* locked: uobj */
		result = uobj->pgops->pgo_get(uobj, va - ufi->entry->start,
		    &pg, &npages, 0, VM_PROT_READ, MADV_NORMAL, 0);
		/* locked: <nothing> */
		
		/*
		 * check for errors
		 */

		if (result != VM_PAGER_OK) {
			 if (result == VM_PAGER_AGAIN) {
				tsleep((caddr_t)&lbolt, PVM, "fltagain2", 0);
				return(0); /* redo the lookup and try again */
			} 
			return(-1);	/* total failure */
		}

		/*
		 * pgo_get was a success.   attempt to relock everything.
		 */

		locked = uvmfault_relock(ufi);
		simple_lock(&uobj->vmobjlock);

		/*
		 * Re-verify that amap slot is still free. if there is a
		 * problem we drop our lock (thus force a lookup refresh/retry).
		 */
			
		if (locked && amap && amap_lookup(&ufi->entry->aref,
		    ufi->orig_rvaddr - ufi->entry->start)) {
			
			if (locked)
				uvmfault_unlockall(ufi, amap, NULL, NULL);
			locked = FALSE;
		} 

		/*
		 * didn't get the lock?   release the page and retry.
		 */

		if (locked == FALSE) {

			if (pg->pg_flags & PG_WANTED)
				/* still holding object lock */
				wakeup(pg);

			uvm_lock_pageq();
			uvm_pageactivate(pg); /* make sure it is in queues */
			uvm_unlock_pageq();
			atomic_clearbits_int(&pg->pg_flags, PG_BUSY|PG_WANTED);
			UVM_PAGE_OWN(pg, NULL);
			simple_unlock(&uobj->vmobjlock);
			return (0);
		}
	}

	/*
	 * at this point we have the page we want ("pg") marked PG_BUSY for us
	 * and we have all data structures locked.   do the loanout.
	 */

	if ((flags & UVM_LOAN_TOANON) == 0) {	/* loan to wired-kernel page? */
		uvm_lock_pageq();
		if (pg->loan_count == 0)
			pmap_page_protect(pg, VM_PROT_READ);
		pg->loan_count++;
		uvm_pagewire(pg);
		uvm_unlock_pageq();
		**output = pg;
		*output = (*output) + 1;
		if (pg->pg_flags & PG_WANTED)
			wakeup(pg);
		atomic_clearbits_int(&pg->pg_flags, PG_WANTED|PG_BUSY);
		UVM_PAGE_OWN(pg, NULL);
		return(1);		/* got it! */
	}

	/*
	 * must be a loan to an anon.   check to see if there is already
	 * an anon associated with this page.  if so, then just return
	 * a reference to this object.   the page should already be 
	 * mapped read-only because it is already on loan.
	 */

	if (pg->uanon) {
		anon = pg->uanon;
		simple_lock(&anon->an_lock);
		anon->an_ref++;
		simple_unlock(&anon->an_lock);
		**output = anon;
		*output = (*output) + 1;
		uvm_lock_pageq();
		uvm_pageactivate(pg);	/* reactivate */
		uvm_unlock_pageq();
		if (pg->pg_flags & PG_WANTED)
			wakeup(pg);
		atomic_clearbits_int(&pg->pg_flags, PG_WANTED|PG_BUSY);
		UVM_PAGE_OWN(pg, NULL);
		return(1);
	}
	
	/*
	 * need to allocate a new anon
	 */

	anon = uvm_analloc();
	if (anon == NULL) {		/* out of VM! */
		if (pg->pg_flags & PG_WANTED)
			wakeup(pg);
		atomic_clearbits_int(&pg->pg_flags, PG_WANTED|PG_BUSY);
		UVM_PAGE_OWN(pg, NULL);
		uvmfault_unlockall(ufi, amap, uobj, NULL);
		return(-1);
	}
	anon->an_page = pg;
	pg->uanon = anon;
	uvm_lock_pageq();
	if (pg->loan_count == 0)
		pmap_page_protect(pg, VM_PROT_READ);
	pg->loan_count++;
	uvm_pageactivate(pg);
	uvm_unlock_pageq();
	**output = anon;
	*output = (*output) + 1;
	if (pg->pg_flags & PG_WANTED)
		wakeup(pg);
	atomic_clearbits_int(&pg->pg_flags, PG_WANTED|PG_BUSY);
	UVM_PAGE_OWN(pg, NULL);
	return(1);
}

/*
 * uvm_loanzero: "loan" a zero-fill page out
 *
 * => return value:
 *	-1 = fatal error, everything is unlocked, abort.
 *	 0 = lookup in ufi went stale, everything unlocked, relookup and
 *		try again
 *	 1 = got it, everything still locked
 */

int
uvm_loanzero(struct uvm_faultinfo *ufi, void ***output, int flags)
{
	struct vm_anon *anon;
	struct vm_page *pg;

	if ((flags & UVM_LOAN_TOANON) == 0) {	/* loaning to kernel-page */

		while ((pg = uvm_pagealloc(NULL, 0, NULL,
		    UVM_PGA_ZERO)) == NULL) {
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, 
			    ufi->entry->object.uvm_obj, NULL);
			uvm_wait("loanzero1");
			if (!uvmfault_relock(ufi))
				return(0);
			if (ufi->entry->object.uvm_obj)
				simple_lock(
				    &ufi->entry->object.uvm_obj->vmobjlock);
			/* ... and try again */
		}
		
		/* got a zero'd page; return */
		atomic_clearbits_int(&pg->pg_flags, PG_BUSY|PG_FAKE);
		UVM_PAGE_OWN(pg, NULL);
		**output = pg;
		*output = (*output) + 1;
		uvm_lock_pageq();
		/* wire it as we are loaning to kernel-page */
		uvm_pagewire(pg);
		pg->loan_count = 1;
		uvm_unlock_pageq();
		return(1);
	}

	/* loaning to an anon */
	while ((anon = uvm_analloc()) == NULL || 
	    (pg = uvm_pagealloc(NULL, 0, anon, UVM_PGA_ZERO)) == NULL) {

		/* unlock everything */
		uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap,
		       ufi->entry->object.uvm_obj, NULL);

		/* out of swap causes us to fail */
		if (anon == NULL)
			return(-1);

		uvm_anfree(anon);
		uvm_wait("loanzero2");		/* wait for pagedaemon */

		if (!uvmfault_relock(ufi))
			/* map changed while unlocked, need relookup */
			return (0);

		/* relock everything else */
		if (ufi->entry->object.uvm_obj)
			simple_lock(&ufi->entry->object.uvm_obj->vmobjlock);
		/* ... and try again */
	}

	/* got a zero'd page; return */
	atomic_clearbits_int(&pg->pg_flags, PG_BUSY|PG_FAKE);
	UVM_PAGE_OWN(pg, NULL);
	uvm_lock_pageq();
	uvm_pageactivate(pg);
	uvm_unlock_pageq();
	**output = anon;
	*output = (*output) + 1;
	return(1);
}


/*
 * uvm_unloananon: kill loans on anons (basically a normal ref drop)
 *
 * => we expect all our resources to be unlocked
 */

void
uvm_unloananon(struct vm_anon **aloans, int nanons)
{
	struct vm_anon *anon;

	while (nanons-- > 0) {
		int refs;

		anon = *aloans++;
		simple_lock(&anon->an_lock);
		refs = --anon->an_ref;
		simple_unlock(&anon->an_lock);

		if (refs == 0) {
			uvm_anfree(anon);	/* last reference: kill anon */
		}
	}
}

/*
 * uvm_unloanpage: kill loans on pages loaned out to the kernel
 *
 * => we expect all our resources to be unlocked
 */

void
uvm_unloanpage(struct vm_page **ploans, int npages)
{
	struct vm_page *pg;

	uvm_lock_pageq();

	while (npages-- > 0) {
		pg = *ploans++;

		if (pg->loan_count < 1)
			panic("uvm_unloanpage: page %p isn't loaned", pg);

		pg->loan_count--;		/* drop loan */
		uvm_pageunwire(pg);		/* and wire */

		/*
		 * if page is unowned and we killed last loan, then we can
		 * free it
		 */
		if (pg->loan_count == 0 && pg->uobject == NULL &&
		    pg->uanon == NULL) {

			if (pg->pg_flags & PG_BUSY)
	panic("uvm_unloanpage: page %p unowned but PG_BUSY!", pg);

			/* be safe */
			pmap_page_protect(pg, VM_PROT_NONE);
			uvm_pagefree(pg);	/* pageq locked above */

		}
	}

	uvm_unlock_pageq();
}

@


1.34
log
@Put the PG_RELEASED changes diff back in.

This has has been tested very very thoroughly on all archs we have
excepting 88k and 68k. Please see cvs log for the individual commit
messages.

ok beck@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.33 2009/06/17 00:13:59 oga Exp $	*/
@


1.33
log
@date based reversion of uvm to the 4th May.

More backouts in line with previous ones, this appears to bring us back to a
stable condition.

A machine forced to 64mb of ram cycled 10GB through swap with this diff
and is still running as I type this. Other tests by ariane@@ and thib@@
also seem to show that it's alright.

ok deraadt@@, thib@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.29 2009/03/20 15:19:04 oga Exp $	*/
d465 2
a466 3
		 * verify that the page has not be released and re-verify
		 * that amap slot is still free.   if there is a problem we
		 * drop our lock (thus force a lookup refresh/retry).
d469 2
a470 3
		if ((pg->pg_flags & PG_RELEASED) != 0 ||
		    (locked && amap && amap_lookup(&ufi->entry->aref,
		    ufi->orig_rvaddr - ufi->entry->start))) {
a486 11
			if (pg->pg_flags & PG_RELEASED) {
#ifdef DIAGNOSTIC
				if (uobj->pgops->pgo_releasepg == NULL)
			panic("uvm_loanuobj: object has no releasepg function");
#endif
				/* frees page */
				if (uobj->pgops->pgo_releasepg(pg, NULL))
					simple_unlock(&uobj->vmobjlock);
				return (0);
			}

d499 1
a499 2
	 * and we have all data structures locked.   do the loanout.   page can
	 * not be PG_RELEASED (we caught this above).
@


1.32
log
@Backout all changes to uvm after pmemrange (which will be backed out
separately).

a change at or just before the hackathon has either exposed or added a
very very nasty memory corruption bug that is giving us hell right now.
So in the interest of kernel stability these diffs are being backed out
until such a time as that corruption bug has been found and squashed,
then the ones that are proven good may slowly return.

a quick hitlist of the main commits this backs out:

mine:
uvm_objwire
the lock change in uvm_swap.c
using trees for uvm objects instead of the hash
removing the pgo_releasepg callback.

art@@'s:
putting pmap_page_protect(VM_PROT_NONE) in uvm_pagedeactivate() since
all callers called that just prior anyway.

ok beck@@, ariane@@.

prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.30 2009/05/08 13:50:15 ariane Exp $	*/
d108 1
a108 1
int		uvm_loananon(struct uvm_faultinfo *, void ***, 
d111 1
a111 1
int		uvm_loanuobj(struct uvm_faultinfo *, void ***, 
d113 1
a113 1
int		uvm_loanzero(struct uvm_faultinfo *, void ***, int);
@


1.31
log
@Since we've now cleared up a lot of the PG_RELEASED setting, remove the
pgo_releasepg() hook and just free the page the "normal" way in the one
place we'll ever see PG_RELEASED and should care (uvm_page_unbusy,
called in aiodoned).

ok art@@, beck@@, thib@@
@
text
@d465 3
a467 2
		 * Re-verify that amap slot is still free. if there is a
		 * problem we drop our lock (thus force a lookup refresh/retry).
d470 3
a472 2
		if (locked && amap && amap_lookup(&ufi->entry->aref,
		    ufi->orig_rvaddr - ufi->entry->start)) {
d489 11
d512 2
a513 1
	 * and we have all data structures locked.   do the loanout.
@


1.30
log
@Remove static qualifier of functions that are not inline.
Makes trace in ddb useful.

ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.29 2009/03/20 15:19:04 oga Exp $	*/
d465 2
a466 3
		 * verify that the page has not be released and re-verify
		 * that amap slot is still free.   if there is a problem we
		 * drop our lock (thus force a lookup refresh/retry).
d469 2
a470 3
		if ((pg->pg_flags & PG_RELEASED) != 0 ||
		    (locked && amap && amap_lookup(&ufi->entry->aref,
		    ufi->orig_rvaddr - ufi->entry->start))) {
a486 11
			if (pg->pg_flags & PG_RELEASED) {
#ifdef DIAGNOSTIC
				if (uobj->pgops->pgo_releasepg == NULL)
			panic("uvm_loanuobj: object has no releasepg function");
#endif
				/* frees page */
				if (uobj->pgops->pgo_releasepg(pg, NULL))
					simple_unlock(&uobj->vmobjlock);
				return (0);
			}

d499 1
a499 2
	 * and we have all data structures locked.   do the loanout.   page can
	 * not be PG_RELEASED (we caught this above).
@


1.29
log
@While working on some stuff in uvm I've gotten REALLY sick of reading
K&R function declarations, so switch them all over to ansi-style, in
accordance with the prophesy.

"go for it" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.28 2007/06/18 21:51:15 pedro Exp $	*/
d108 1
a108 1
static int	uvm_loananon(struct uvm_faultinfo *, void ***, 
d111 1
a111 1
static int	uvm_loanuobj(struct uvm_faultinfo *, void ***, 
d113 1
a113 1
static int	uvm_loanzero(struct uvm_faultinfo *, void ***, int);
@


1.28
log
@Bring back Mickey's UVM anon change. Testing by thib@@, beck@@ and
ckuethe@@ for a while. Okay beck@@, "it is good timing" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.27 2007/05/31 21:20:30 thib Exp $	*/
d130 1
a130 4
uvm_loanentry(ufi, output, flags)
	struct uvm_faultinfo *ufi;
	void ***output;
	int flags;
d209 2
a210 6
uvm_loan(map, start, len, result, flags)
	struct vm_map *map;
	vaddr_t start;
	vsize_t len;
	void **result;
	int flags;
d312 2
a313 5
uvm_loananon(ufi, output, flags, anon)
	struct uvm_faultinfo *ufi;
	void ***output;
	int flags;
	struct vm_anon *anon;
d398 1
a398 5
uvm_loanuobj(ufi, output, flags, va)
	struct uvm_faultinfo *ufi;
	void ***output;
	int flags;
	vaddr_t va;
d597 1
a597 4
uvm_loanzero(ufi, output, flags)
	struct uvm_faultinfo *ufi;
	void ***output;
	int flags;
d674 1
a674 3
uvm_unloananon(aloans, nanons)
	struct vm_anon **aloans;
	int nanons;
d699 1
a699 3
uvm_unloanpage(ploans, npages)
	struct vm_page **ploans;
	int npages;
@


1.27
log
@zap the vm_amap am_l simplelock, and amap_{lock/unlock} macros for
simple_{lock/unlock}.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.26 2007/04/13 18:57:49 art Exp $	*/
d335 1
a335 1
		pg = anon->u.an_page;
d380 1
a380 1
	pg = anon->u.an_page;
d583 1
a583 1
	anon->u.an_page = pg;
@


1.26
log
@While splitting flags and pqflags might have been a good idea in theory
to separate locking, on most modern machines this is not enough
since operations on short types touch other short types that share the
same word in memory.

Merge pg_flags and pqflags again and now use atomic operations to change
the flags. Also bump wire_count to an int and pg_version might go
int as well, just for alignment.

tested by many, many. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.25 2007/04/04 17:44:45 art Exp $	*/
a144 2
	if (aref->ar_amap)
		amap_lock(aref->ar_amap);
a475 2
		if (locked && amap)
			amap_lock(amap);
a627 2
			if (ufi->entry->aref.ar_amap)
				amap_lock(ufi->entry->aref.ar_amap);
a666 2
		if (ufi->entry->aref.ar_amap)
			amap_lock(ufi->entry->aref.ar_amap);
@


1.25
log
@Mechanically rename the "flags" and "version" fields in struct vm_page
to "pg_flags" and "pg_version", so that they are a bit easier to work with.
Whoever uses generic names like this for a popular struct obviously doesn't
read much code.

Most architectures compile and there are no functionality changes.

deraadt@@ ok ("if something fails to compile, we fix that by hand")
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.24 2007/03/26 08:43:34 art Exp $	*/
d338 1
a338 1
		if (pg && (pg->pqflags & PQ_ANON) != 0 && anon->an_ref == 1)
d521 1
a521 1
			pg->pg_flags &= ~(PG_BUSY|PG_WANTED);
d545 1
a545 1
		pg->pg_flags &= ~(PG_WANTED|PG_BUSY);
d569 1
a569 1
		pg->pg_flags &= ~(PG_WANTED|PG_BUSY);
d582 1
a582 1
		pg->pg_flags &= ~(PG_WANTED|PG_BUSY);
d599 1
a599 1
	pg->pg_flags &= ~(PG_WANTED|PG_BUSY);
d641 1
a641 1
		pg->pg_flags &= ~(PG_BUSY|PG_FAKE);
d681 1
a681 1
	pg->pg_flags &= ~(PG_BUSY|PG_FAKE);
@


1.24
log
@Rip out the KERN_ error codes.
ok otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.23 2007/03/25 11:31:07 art Exp $	*/
d488 1
a488 1
		if ((pg->flags & PG_RELEASED) != 0 ||
d503 1
a503 1
			if (pg->flags & PG_WANTED)
d507 1
a507 1
			if (pg->flags & PG_RELEASED) {
d521 1
a521 1
			pg->flags &= ~(PG_BUSY|PG_WANTED);
d543 1
a543 1
		if (pg->flags & PG_WANTED)
d545 1
a545 1
		pg->flags &= ~(PG_WANTED|PG_BUSY);
d567 1
a567 1
		if (pg->flags & PG_WANTED)
d569 1
a569 1
		pg->flags &= ~(PG_WANTED|PG_BUSY);
d580 1
a580 1
		if (pg->flags & PG_WANTED)
d582 1
a582 1
		pg->flags &= ~(PG_WANTED|PG_BUSY);
d597 1
a597 1
	if (pg->flags & PG_WANTED)
d599 1
a599 1
	pg->flags &= ~(PG_WANTED|PG_BUSY);
d641 1
a641 1
		pg->flags &= ~(PG_BUSY|PG_FAKE);
d681 1
a681 1
	pg->flags &= ~(PG_BUSY|PG_FAKE);
d750 1
a750 1
			if (pg->flags & PG_BUSY)
@


1.23
log
@remove KERN_SUCCESS and use 0 instead.
eyeballed by miod@@ and pedro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.22 2006/07/13 22:51:26 deraadt Exp $	*/
d237 1
a237 1
		return(KERN_FAILURE);
d307 1
a307 1
	return(KERN_FAILURE);
@


1.22
log
@Back out the anon change.  Apparently it was tested by a few, but most of
us did not see it or get a chance to test it before it was commited. It
broke cvs, in the ami driver, making it not succeed at seeing it's devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.20 2003/12/08 22:19:57 mickey Exp $	*/
d293 1
a293 1
	return(KERN_SUCCESS);
@


1.21
log
@from netbsd: make anons dynamically allocated from pool.
this results in lesse kva waste due to static preallocation of those
for every phys page and also every swap page.
tested by beck krw miod
@
text
@d337 1
a337 1
		pg = anon->an_page;
d382 1
a382 1
	pg = anon->an_page;
d587 1
a587 1
	anon->an_page = pg;
@


1.20
log
@remove unneeded uvmfault_unlockmaps; form netbsd via Julien Bordet <zejames@@greyhats.org>; tedu@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.19 2002/03/14 01:27:18 millert Exp $	*/
d337 1
a337 1
		pg = anon->u.an_page;
d382 1
a382 1
	pg = anon->u.an_page;
d587 1
a587 1
	anon->u.an_page = pg;
@


1.19
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.18 2002/01/02 22:23:25 miod Exp $	*/
d269 1
a269 1
		 * now do the loanout
d276 5
a280 1
		 * done!   advance pointers and unlock.
d282 5
a286 4
		rv <<= PAGE_SHIFT;
		len -= rv;
		start += rv;
		uvmfault_unlockmaps(&ufi, FALSE);
@


1.18
log
@Back out a few more uvm changes, especially wrt swap usage.
This unbreaks m68k m88k sparc and perhaps others, which eventually froze
when hitting swap.
Tested by various people on various platforms.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.11 2001/11/06 01:35:04 art Exp $	*/
d108 6
a113 6
static int	uvm_loananon __P((struct uvm_faultinfo *, void ***, 
				int, struct vm_anon *));
static int	uvm_loanentry __P((struct uvm_faultinfo *, void ***, int));
static int	uvm_loanuobj __P((struct uvm_faultinfo *, void ***, 
				int, vaddr_t));
static int	uvm_loanzero __P((struct uvm_faultinfo *, void ***, int));
@


1.17
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.12 2001/11/11 01:16:56 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.23 2001/01/23 02:27:39 thorpej Exp $	*/
a581 1
	/* anon is locked! */
a595 1
	simple_unlock(&anon->an_lock);
d654 1
a654 1
		       ufi->entry->object.uvm_obj, anon);
a658 7

		/*
		 * drop our reference; we're the only one,
		 * so it's okay that the anon isn't locked
		 * here.
		 */
		anon->an_ref--;
@


1.16
log
@Yet another sync to NetBSD uvm.
Today we add a pmap argument to pmap_update() and allocate map entries for
kernel_map from kmem_map instead of using the static entries. This should
get rid of MAX_KMAPENT panics. Also some uvm_loan problems are fixed.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.15 2001/11/28 19:28:14 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.31 2001/08/27 02:34:29 chuck Exp $	*/
d52 1
a52 1
 * "loaned" pages are pages which are (read-only, copy-on-write) loaned
d78 1
a78 1
 * owners that want to free their pages and discover that they are
d95 1
a95 1
 *  1. user-level xwrite fault to a loaned page
d108 1
a108 1
static int	uvm_loananon __P((struct uvm_faultinfo *, void ***,
d111 1
a111 1
static int	uvm_loanuobj __P((struct uvm_faultinfo *, void ***,
d123 2
a124 2
 *	on entry the map is locked by the caller)
 * => we may unlock and then relock the map if needed (for I/O)
d126 1
a126 5
 * => we always return with the map unlocked
 * => possible return values:
 *	-1 == error, map is unlocked
 *	 0 == map relock error (try again!), map is unlocked
 *	>0 == number of pages we loaned, map is unlocked
d143 1
a143 1
	 * lock us the rest of the way down (we unlock before return)
a164 1
		/* locked: map, amap, uobj */
d172 1
a172 1
			rv = -1;	/* null map entry... fail now */
a173 1
		/* locked: if (rv > 0) => map, amap, uobj  [o.w. unlocked] */
d177 1
a177 1
			return(-1);		/* everything unlocked */
d181 1
a181 1
			return(result);		/* everything unlocked */
d192 1
a192 1
	 * unlock what we locked, unlock the maps and return
d194 1
a194 5
	if (aref->ar_amap)
		amap_unlock(aref->ar_amap);
	if (uobj)
		simple_unlock(&uobj->vmobjlock);
	uvmfault_unlockmaps(ufi, FALSE);
d203 2
a204 2
 * uvm_loan: loan pages in a map out to anons or to the kernel
 *
a210 1
 * => returns 0 (success), or an appropriate error number
d223 6
a228 1
	int rv, error;
d234 4
a237 3
	KASSERT(((flags & UVM_LOAN_TOANON) == 0) ^
		((flags & UVM_LOAN_TOPAGE) == 0));
	KASSERT((map->flags & VM_MAP_INTRSAFE) == 0);
d259 1
a259 1

d265 1
a265 2
		if (!uvmfault_lookup(&ufi, FALSE)) {
			error = ENOENT;
a266 1
		}
d269 1
a269 1
		 * map now locked.  now do the loanout...
d272 1
a272 3
		if (rv < 0) {
			/* all unlocked due to error */
			error = EINVAL;
a273 1
		}
d276 6
a281 11
		 * done!  the map is unlocked.  advance, if possible.
		 *
		 * XXXCDC: could be recoded to hold the map lock with 
		 *	   smarter code (but it only happens on map entry 
		 *	   boundaries, so it isn't that bad).
		 */
		if (rv) {
			rv <<= PAGE_SHIFT;
			len -= rv;
			start += rv;
		}
d283 1
a283 1

d288 1
a288 1
	return 0;
a292 1
	 * map is already unlocked.
d302 1
a302 1
	return (error);
d307 1
a307 2
 *
 * => called with map, amap, uobj locked
d326 1
a326 1
	 * if we are loaning to "another" anon then it is easy, we just
d328 1
a328 1
	 * pointer to it (it becomes copy-on-write shared).
a332 1
		/* if (in RAM) and (owned by this anon) and (only 1 ref) */
d334 1
a334 1
			/* write-protect it */
d356 2
a357 1
	if (result != 0) {
d360 1
a360 1
		if (result == ERESTART)
d364 2
a365 2
		if (result == EAGAIN) {
			tsleep(&lbolt, PVM, "loanagain", 0);
d388 1
a388 1
	if (pg->uobject)	/* XXXCDC: what if this is our uobj? bad */
a396 1
 * => called with map, amap, uobj locked
d424 1
a424 1
	if (uobj->pgops->pgo_get) {	/* try locked pgo_get */
d430 1
a430 1
		result = EIO;		/* must have pgo_get op */
d438 1
a438 1
	if (result != 0 && result != EBUSY) {
d447 1
a447 1
	if (result == EBUSY) {
d449 1
a449 1

d453 1
a453 1
		    &pg, &npages, 0, VM_PROT_READ, MADV_NORMAL, PGO_SYNCIO);
d455 1
a455 1

d460 3
a462 3
		if (result != 0) {
			 if (result == EAGAIN) {
				tsleep(&lbolt, PVM, "fltagain2", 0);
d464 1
a464 1
			}
d482 1
a482 1

d486 1
a486 1

d490 1
a490 1
		}
d529 1
a529 1
	if ((flags & UVM_LOAN_TOANON) == 0) { /* loan to wired-kernel page? */
d548 1
a548 1
	 * a reference to this object.   the page should already be
d568 1
a568 1

a603 1
 * => called with map, amap, uobj locked
d624 1
a624 1
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap,
d636 1
a636 1

d651 1
a651 1
	while ((anon = uvm_analloc()) == NULL ||
d745 1
a745 1
		uvm_pageunwire(pg);		/* and unwire */
@


1.16.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.18 2002/01/02 22:23:25 miod Exp $	*/
d600 1
d615 1
d675 1
a675 1
		       ufi->entry->object.uvm_obj, NULL);
d680 7
@


1.16.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.16.2.1 2002/01/31 22:55:51 niklas Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.35 2001/11/10 07:37:00 lukem Exp $	*/
a113 3
static void	uvm_unloananon __P((struct vm_anon **, int));
static void	uvm_unloanpage __P((struct vm_page **, int));

d177 1
a177 1
			rv = -1;
d183 1
a183 1
			return (-1);
d187 1
a187 1
			return (result);
a191 1

a199 1

d205 1
a205 1
	return (result);
d225 1
a225 1
uvm_loan(map, start, len, v, flags)
d229 1
a229 1
	void *v;
d233 1
a233 1
	void **result, **output;
d245 2
a246 1
	 * "output" is a pointer to the current place to put the loaned page.
a248 1
	result = v;
a277 1

a291 1

d298 5
d307 1
a307 1
	 * failed to complete loans.  drop any loans and return failure code.
a309 1

d311 1
a311 1
		if (flags & UVM_LOAN_TOANON) {
d314 1
a314 1
		} else {
a316 1
		}
d340 1
a340 1
	int error;
a346 1

d350 3
a352 1
		if (pg && (pg->pqflags & PQ_ANON) != 0 && anon->an_ref == 1) {
a353 1
		}
d356 1
a356 1
		(*output)++;
d358 1
a358 1
		return (1);
d368 1
a368 1
	error = uvmfault_anonget(ufi, ufi->entry->aref.ar_amap, anon);
d374 1
a374 2

	if (error) {
d377 2
a378 3
		if (error == ERESTART) {
			return (0);
		}
d381 1
a381 1
		if (error == EAGAIN) {
d383 1
a383 1
			return (0);
d387 1
a387 1
		return (-1);
d396 1
a396 2
	KASSERT(pg->wire_count == 0);
	if (pg->loan_count == 0) {
a397 1
	}
d399 1
a399 1
	uvm_pagedequeue(pg);
d402 1
a402 1
	(*output)++;
d408 1
a408 1
	return (1);
d422 1
a422 1
static int
d433 1
a433 1
	int error, npages;
d445 1
a445 1
		error = uobj->pgops->pgo_get(uobj, va - ufi->entry->start,
d448 1
a448 1
		error = EIO;		/* must have pgo_get op */
d456 1
a456 1
	if (error && error != EBUSY) {
d458 1
a458 1
		return (-1);
d465 1
a465 1
	if (error == EBUSY) {
d468 1
d470 1
a470 2
		npages = 1;
		error = uobj->pgops->pgo_get(uobj, va - ufi->entry->start,
d474 6
a479 2
		if (error) {
			 if (error == EAGAIN) {
d481 1
a481 1
				return (0);
d483 1
a483 1
			return (-1);
d504 1
d515 3
a517 1
			if (pg->flags & PG_WANTED) {
d519 1
a519 1
			}
d521 7
a527 1
				uvm_pagefree(pg);
d530 1
d532 1
a532 1
			uvm_pageactivate(pg);
d543 1
a543 1
	 * and we have all data structures locked.  do the loanout.  page can
d547 1
a547 1
	if ((flags & UVM_LOAN_TOANON) == 0) {
d549 1
a549 1
		if (pg->loan_count == 0) {
a550 1
		}
d552 1
a552 1
		uvm_pagedequeue(pg);
d554 3
a556 1
		if (pg->flags & PG_WANTED) {
a557 1
		}
d560 1
a560 3
		**output = pg;
		(*output)++;
		return (1);
d575 6
a580 1
		if (pg->flags & PG_WANTED) {
a581 1
		}
d584 1
a584 3
		**output = anon;
		(*output)++;
		return (1);
d592 2
a593 2
	if (anon == NULL) {
		if (pg->flags & PG_WANTED) {
a594 1
		}
d598 1
a598 1
		return (-1);
d603 1
a603 1
	if (pg->loan_count == 0) {
a604 1
	}
d608 3
a610 1
	if (pg->flags & PG_WANTED) {
a611 1
	}
d614 1
a614 4
	simple_unlock(&anon->an_lock);
	**output = anon;
	(*output)++;
	return (1);
d628 1
a628 1
static int
a635 2
	struct uvm_object *uobj = ufi->entry->object.uvm_obj;
	struct vm_amap *amap = ufi->entry->aref.ar_amap;
d638 1
d641 2
a642 1
			uvmfault_unlockall(ufi, amap, uobj, NULL);
d644 8
a651 9
			if (!uvmfault_relock(ufi)) {
				return (0);
			}
			if (amap) {
				amap_lock(amap);
			}
			if (uobj) {
				simple_lock(&uobj->vmobjlock);
			}
d655 1
a655 1
		pg->flags &= ~(PG_WANTED|PG_BUSY);
d658 4
a661 1
		(*output)++;
d663 2
a664 1
		return (1);
d670 4
a673 1
		uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, uobj, anon);
d676 2
a677 3
		if (anon == NULL) {
			return (-1);
		}
a678 7
		/*
		 * drop our reference; we're the only one,
		 * so it's okay that the anon isn't locked
		 * here.
		 */

		anon->an_ref--;
d682 1
a682 1
		if (!uvmfault_relock(ufi)) {
a684 1
		}
d687 5
a691 6
		if (amap) {
			amap_lock(amap);
		}
		if (uobj) {
			simple_lock(&uobj->vmobjlock);
		}
d701 2
a702 2
	(*output)++;
	return (1);
d712 1
a712 1
static void
d728 1
a728 1
			uvm_anfree(anon);
d739 1
a739 1
static void
d747 1
d751 6
d758 2
a759 3
		 * drop our loan.  if page is unowned and we are removing
		 * the last loan, we can free the page.
		 * the 
d761 9
a770 12
		KASSERT(pg->loan_count > 0);
		pg->loan_count--;
		if (pg->loan_count == 0) {
			if (pg->uobject == NULL && pg->uanon == NULL) {
				KASSERT((pg->flags & PG_BUSY) == 0);
				uvm_pagefree(pg);
			} else {
				uvm_pageactivate(pg);
			}
		} else if (pg->loan_count == 1 && pg->uanon != NULL &&
			   pg->uobject == NULL) {
			uvm_pageactivate(pg);
d773 1
a776 13
/*
 * uvm_unloan: kill loans on pages or anons.
 */

void
uvm_unloan(void *v, int npages, int flags)
{
	if (flags & UVM_LOAN_TOANON) {
		uvm_unloananon(v, npages);
	} else {
		uvm_unloanpage(v, npages);
	}
}
@


1.16.2.3
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.16.2.2 2002/02/02 03:28:26 art Exp $	*/
d108 9
a116 8
static int	uvm_loananon(struct uvm_faultinfo *, void ***,
				int, struct vm_anon *);
static int	uvm_loanentry(struct uvm_faultinfo *, void ***, int);
static int	uvm_loanuobj(struct uvm_faultinfo *, void ***,
				int, vaddr_t);
static int	uvm_loanzero(struct uvm_faultinfo *, void ***, int);
static void	uvm_unloananon(struct vm_anon **, int);
static void	uvm_unloanpage(struct vm_page **, int);
@


1.16.2.4
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.16.2.3 2002/06/11 03:33:03 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.39 2002/07/14 23:53:41 chs Exp $	*/
d452 1
a452 2
		error = (*uobj->pgops->pgo_get)(uobj,
		    va - ufi->entry->start + ufi->entry->offset,
d477 1
a477 2
		error = (*uobj->pgops->pgo_get)(uobj,
		    va - ufi->entry->start + ufi->entry->offset,
a520 1
				uvm_lock_pageq();
a521 1
				uvm_unlock_pageq();
a745 1
	struct simplelock *slock;
d752 3
a754 29
		 * do a little dance to acquire the object or anon lock
		 * as appropriate.  we are locking in the wrong order,
		 * so we have to do a try-lock here.
		 */

		slock = NULL;
		while (pg->uobject != NULL || pg->uanon != NULL) {
			if (pg->uobject != NULL) {
				slock = &pg->uobject->vmobjlock;
			} else {
				slock = &pg->uanon->an_lock;
			}
			if (simple_lock_try(slock)) {
				break;
			}
			uvm_unlock_pageq();
			uvm_lock_pageq();
			slock = NULL;
		}

		/*
		 * drop our loan.  if page is owned by an anon but
		 * PQ_ANON is not set, the page was loaned to the anon
		 * from an object which dropped ownership, so resolve
		 * this by turning the anon's loan into real ownership
		 * (ie. decrement loan_count again and set PQ_ANON).
		 * after all this, if there are no loans left, put the
		 * page back a paging queue (if the page is owned by
		 * an anon) or free it (if the page is now unowned).
a758 6
		if (pg->uobject == NULL && pg->uanon != NULL &&
		    (pg->pqflags & PQ_ANON) == 0) {
			KASSERT(pg->loan_count > 0);
			pg->loan_count--;
			pg->pqflags |= PQ_ANON;
		}
d766 2
a767 2
		} else if (pg->loan_count == 1 && pg->uobject != NULL &&
			   pg->uanon != NULL) {
a768 3
		}
		if (slock != NULL) {
			simple_unlock(slock);
@


1.15
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.14 2001/11/28 14:29:13 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.29 2001/05/25 04:06:14 chs Exp $	*/
d123 1
a123 1
 *	the map is locked by the caller)
d126 1
d130 1
a130 1
 *	>0 == number of pages we loaned, map remain locked
d179 1
a179 1
		/* locked: if (rv > 0) => map, amap, uobj */
d183 1
a183 1
			return(-1);
d187 1
a187 1
			return(result);
d198 1
a198 1
	 * unlock what we locked and return (with map still locked)
d204 1
d286 1
a286 2
		 * done!  the map is locked only if rv > 0.  if that
		 * is the case, advance and unlock.
d288 3
a290 3
		 * XXXCDC: could avoid the unlock with smarter code
		 *         (but it only happens on map entry boundaries,
		 *          so it isn't that bad).
a295 1
			uvmfault_unlockmaps(&ufi, FALSE);
d471 1
a471 1
		    &pg, &npages, 0, VM_PROT_READ, MADV_NORMAL, 0);
d764 1
a764 1
		uvm_pageunwire(pg);		/* and wire */
@


1.14
log
@more sync to netbsd. some bugfixes in uvm_km_kmemalloc, lots of fixes in uvm_loan.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.13 2001/11/28 13:47:39 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.28 2001/04/10 00:53:21 chuck Exp $	*/
d52 1
a52 1
 * "loaned" pages are pages which are (read-only, copy-on-write) loaned 
d78 1
a78 1
 * owners that want to free their pages and discover that they are 
d95 1
a95 1
 *  1. user-level xwrite fault to a loaned page 
d108 1
a108 1
static int	uvm_loananon __P((struct uvm_faultinfo *, void ***, 
d111 1
a111 1
static int	uvm_loanuobj __P((struct uvm_faultinfo *, void ***, 
d212 1
a212 1
 * 
d262 1
a262 1
		
d285 1
a285 1
		 * is the case, advance and unlock.  
d288 1
a288 1
		 *         (but it only happens on map entry boundaries, 
d298 1
a298 1
	
d323 1
a323 1
 * 
d467 1
a467 1
		
d473 1
a473 1
		
d482 1
a482 1
			} 
d500 1
a500 1
			
d504 1
a504 1
			
d508 1
a508 1
		} 
d566 1
a566 1
	 * a reference to this object.   the page should already be 
d586 1
a586 1
	
d643 1
a643 1
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, 
d655 1
a655 1
		
d670 1
a670 1
	while ((anon = uvm_analloc()) == NULL || 
@


1.13
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.12 2001/11/11 01:16:56 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.27 2001/04/09 06:21:03 jdolecek Exp $	*/
d95 1
a95 1
 *  1. write fault to a loaned page 
d123 2
a124 2
 *	the maps are locked by the caller)
 * => we may unlock the maps if needed (for I/O)
d126 4
a129 1
 * => we return the number of pages we loaned, or -1 if we had an error
d146 1
a146 1
	 * lock us the rest of the way down
d168 1
d176 1
a176 1
			rv = -1;		/* null map entry... fail now */
d178 1
d197 1
a197 1
	 * unlock everything and return
d199 4
a202 1
	uvmfault_unlockall(ufi, aref->ar_amap, uobj, NULL);
d211 1
a211 1
 * uvm_loan: loan pages out to anons or to the kernel
d219 1
d274 1
a274 1
		 * now do the loanout
d278 1
d284 6
a289 1
		 * done!   advance pointers and unlock.
d291 6
a296 4
		rv <<= PAGE_SHIFT;
		len -= rv;
		start += rv;
		uvmfault_unlockmaps(&ufi, FALSE);
d308 1
d324 1
d343 1
a343 1
	 * if we are loaning to another anon then it is easy, we just
d345 1
a345 1
	 * pointer to it.
d350 1
d352 1
a352 1
			/* read protect it */
a373 1

d405 1
a405 1
	if (pg->uobject)
d414 1
d442 1
a442 1
	if (uobj->pgops->pgo_get) {
d448 1
a448 1
		result = EIO;
d547 1
a547 1
	if ((flags & UVM_LOAN_TOANON) == 0) {	/* loan to wired-kernel page? */
d622 1
@


1.12
log
@Sync in more stuff from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.11 2001/11/06 01:35:04 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.23 2001/01/23 02:27:39 thorpej Exp $	*/
d223 1
a223 6
	int rv;

#ifdef DIAGNOSTIC
	if (map->flags & VM_MAP_INTRSAFE)
		panic("uvm_loan: intrsafe map");
#endif
d229 3
a231 4
	if ((flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 
	    (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE) ||
	    (flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 0)
		return(KERN_FAILURE);
d259 2
a260 1
		if (!uvmfault_lookup(&ufi, FALSE)) 
d262 1
d268 2
a269 1
		if (rv < 0) 
d271 1
d286 1
a286 1
	return(KERN_SUCCESS);
d300 1
a300 1
	return(KERN_FAILURE);
d355 1
a355 1
	if (result != VM_PAGER_OK) {
d358 1
a358 1
		if (result == VM_PAGER_REFAULT)
d362 2
a363 2
		if (result == VM_PAGER_AGAIN) {
			tsleep((caddr_t)&lbolt, PVM, "loanagain", 0);
d428 1
a428 1
		result = VM_PAGER_ERROR;
d436 1
a436 1
	if (result != VM_PAGER_OK && result != VM_PAGER_UNLOCK) {
d445 1
a445 1
	if (result == VM_PAGER_UNLOCK) {
d458 3
a460 3
		if (result != VM_PAGER_OK) {
			 if (result == VM_PAGER_AGAIN) {
				tsleep((caddr_t)&lbolt, PVM, "fltagain2", 0);
@


1.11
log
@Move the last content from vm/ to uvm/
The only thing left in vm/ are just dumb wrappers.
vm/vm.h includes uvm/uvm_extern.h
vm/pmap.h includes uvm/uvm_pmap.h
vm/vm_page.h includes uvm/uvm_page.h
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.10 2001/11/05 22:14:54 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.22 2000/06/27 17:29:25 mrg Exp $	*/
d582 1
d597 1
d653 1
a653 1
		
d656 2
a657 2
		       ufi->entry->object.uvm_obj, NULL);
		
d661 7
@


1.10
log
@Minor sync to NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.9 2001/09/11 20:05:26 miod Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.21 2000/06/26 14:21:18 mrg Exp $	*/
a47 2

#include <vm/vm.h>
@


1.9
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.8 2001/08/11 10:57:22 art Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.20 2000/04/10 00:32:46 thorpej Exp $	*/
a49 1
#include <vm/vm_page.h>
@


1.8
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_loan.c,v 1.7 2001/07/18 10:47:05 art Exp $	*/
a50 1
#include <vm/vm_kern.h>
@


1.7
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.6 2001/03/08 15:21:37 smart Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.19 1999/09/12 01:17:36 chs Exp $	*/
d624 2
a625 1
		while ((pg = uvm_pagealloc(NULL, 0, NULL, 0)) == NULL) {
d639 1
a639 2
		/* got a page, zero it and return */
		uvm_pagezero(pg);		/* clears PG_CLEAN */
d654 1
a654 1
	    (pg = uvm_pagealloc(NULL, 0, anon, 0)) == NULL) {
d679 1
a679 2
	/* got a page, zero it and return */
	uvm_pagezero(pg);		/* clears PG_CLEAN */
@


1.6
log
@Replace thread_wakeup() with wakeup().  It is defined in vm_extern.h as a
wrapper, so this removes a dependence on the old VM system.  From NetBSD.
art@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.5 2001/01/29 02:07:45 niklas Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.18 1999/07/22 22:58:38 thorpej Exp $	*/
d339 1
a339 1
			pmap_page_protect(PMAP_PGARG(pg), VM_PROT_READ);
d384 1
a384 1
		pmap_page_protect(PMAP_PGARG(pg), VM_PROT_READ);
d536 1
a536 1
			pmap_page_protect(PMAP_PGARG(pg), VM_PROT_READ);
d590 1
a590 1
		pmap_page_protect(PMAP_PGARG(pg), VM_PROT_READ);
d754 1
a754 1
			pmap_page_protect(PMAP_PGARG(pg), VM_PROT_NONE);
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_loan.c,v 1.17 1999/06/03 00:05:45 thorpej Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.17 1999/06/03 00:05:45 thorpej Exp $	*/
d504 1
a504 1
				thread_wakeup(pg);
d543 1
a543 1
			thread_wakeup(pg);
d567 1
a567 1
			thread_wakeup(pg);
d580 1
a580 1
			thread_wakeup(pg);
d597 1
a597 1
		thread_wakeup(pg);
@


1.4
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_loan.c,v 1.14 1999/03/25 18:48:52 mrg Exp $	*/
d62 1
a62 1
 *  A->K  anon page to kernel wired kernel page (e.g. mbuf data area)
d71 9
a79 4
 * each loan of a page to a wired kernel page bumps the pg->wire_count.
 * wired kernel mappings should be entered with pmap_kenter functions
 * so that pmap_page_protect() will not affect the kernel mappings.
 * (this requires the PMAP_NEW interface...).
d104 1
a104 1
 * effect on normal "wired" pages if one is not careful.
d227 5
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_loan.c,v 1.17 1999/06/03 00:05:45 thorpej Exp $	*/
d62 1
a62 1
 *  A->K  anon page to wired kernel page (e.g. mbuf data area)
d71 4
a74 9
 * each loan of a page to the kernel bumps the pg->wire_count.  the
 * kernel mappings for these pages will be read-only and wired.  since
 * the page will also be wired, it will not be a candidate for pageout,
 * and thus will never be pmap_page_protect()'d with VM_PROT_NONE.  a
 * write fault in the kernel to one of these pages will not cause
 * copy-on-write.  instead, the page fault is considered fatal.  this
 * is because the kernel mapping will have no way to look up the
 * object/anon which the page is owned by.  this is a good side-effect,
 * since a kernel write to a loaned page is an error.
d99 1
a99 1
 * effect on normal "wired" pages if one is not careful (XXX).
a221 5

#ifdef DIAGNOSTIC
	if (map->flags & VM_MAP_INTRSAFE)
		panic("uvm_loan: intrsafe map");
#endif
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: uvm_loan.c,v 1.6 2001/03/08 15:21:37 smart Exp $	*/
/*	$NetBSD: uvm_loan.c,v 1.18 1999/07/22 22:58:38 thorpej Exp $	*/
d503 1
a503 1
				wakeup(pg);
d542 1
a542 1
			wakeup(pg);
d566 1
a566 1
			wakeup(pg);
d579 1
a579 1
			wakeup(pg);
d596 1
a596 1
		wakeup(pg);
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_loan.c,v 1.20 2000/04/10 00:32:46 thorpej Exp $	*/
d51 1
d339 1
a339 1
			pmap_page_protect(pg, VM_PROT_READ);
d384 1
a384 1
		pmap_page_protect(pg, VM_PROT_READ);
d536 1
a536 1
			pmap_page_protect(pg, VM_PROT_READ);
d590 1
a590 1
		pmap_page_protect(pg, VM_PROT_READ);
d624 1
a624 2
		while ((pg = uvm_pagealloc(NULL, 0, NULL,
		    UVM_PGA_ZERO)) == NULL) {
d638 2
a639 1
		/* got a zero'd page; return */
d654 1
a654 1
	    (pg = uvm_pagealloc(NULL, 0, anon, UVM_PGA_ZERO)) == NULL) {
d679 2
a680 1
	/* got a zero'd page; return */
d754 1
a754 1
			pmap_page_protect(pg, VM_PROT_NONE);
@


1.3.4.4
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_loan.c,v 1.23 2001/01/23 02:27:39 thorpej Exp $	*/
d49 3
a584 1
	/* anon is locked! */
a598 1
	simple_unlock(&anon->an_lock);
d654 1
a654 1

d657 2
a658 2
		       ufi->entry->object.uvm_obj, anon);

a661 7

		/*
		 * drop our reference; we're the only one,
		 * so it's okay that the anon isn't locked
		 * here.
		 */
		anon->an_ref--;
@


1.3.4.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_loan.c,v 1.29 2001/05/25 04:06:14 chs Exp $	*/
d52 1
a52 1
 * "loaned" pages are pages which are (read-only, copy-on-write) loaned
d78 1
a78 1
 * owners that want to free their pages and discover that they are
d95 1
a95 1
 *  1. user-level xwrite fault to a loaned page
d108 1
a108 1
static int	uvm_loananon __P((struct uvm_faultinfo *, void ***,
d111 1
a111 1
static int	uvm_loanuobj __P((struct uvm_faultinfo *, void ***,
d123 2
a124 2
 *	the map is locked by the caller)
 * => we may unlock and then relock the map if needed (for I/O)
d126 1
a126 4
 * => possible return values:
 *	-1 == error, map is unlocked
 *	 0 == map relock error (try again!), map is unlocked
 *	>0 == number of pages we loaned, map remain locked
d143 1
a143 1
	 * lock us the rest of the way down (we unlock before return)
a164 1
		/* locked: map, amap, uobj */
d172 1
a172 1
			rv = -1;	/* null map entry... fail now */
a173 1
		/* locked: if (rv > 0) => map, amap, uobj */
d192 1
a192 1
	 * unlock what we locked and return (with map still locked)
d194 1
a194 4
	if (aref->ar_amap)
		amap_unlock(aref->ar_amap);
	if (uobj)
		simple_unlock(&uobj->vmobjlock);
d203 2
a204 2
 * uvm_loan: loan pages in a map out to anons or to the kernel
 *
a210 1
 * => returns 0 (success), or an appropriate error number
d223 6
a228 1
	int rv, error;
d234 4
a237 3
	KASSERT(((flags & UVM_LOAN_TOANON) == 0) ^
		((flags & UVM_LOAN_TOPAGE) == 0));
	KASSERT((map->flags & VM_MAP_INTRSAFE) == 0);
d259 1
a259 1

d265 1
a265 2
		if (!uvmfault_lookup(&ufi, FALSE)) {
			error = ENOENT;
a266 1
		}
d269 1
a269 1
		 * map now locked.  now do the loanout...
d272 1
a272 3
		if (rv < 0) {
			/* all unlocked due to error */
			error = EINVAL;
a273 1
		}
d276 1
a276 6
		 * done!  the map is locked only if rv > 0.  if that
		 * is the case, advance and unlock.
		 *
		 * XXXCDC: could avoid the unlock with smarter code
		 *         (but it only happens on map entry boundaries,
		 *          so it isn't that bad).
d278 4
a281 6
		if (rv) {
			rv <<= PAGE_SHIFT;
			len -= rv;
			start += rv;
			uvmfault_unlockmaps(&ufi, FALSE);
		}
d283 1
a283 1

d288 1
a288 1
	return 0;
a292 1
	 * map is already unlocked.
d302 1
a302 1
	return (error);
d307 1
a307 2
 *
 * => called with map, amap, uobj locked
d326 1
a326 1
	 * if we are loaning to "another" anon then it is easy, we just
d328 1
a328 1
	 * pointer to it (it becomes copy-on-write shared).
a332 1
		/* if (in RAM) and (owned by this anon) and (only 1 ref) */
d334 1
a334 1
			/* write-protect it */
d356 2
a357 1
	if (result != 0) {
d360 1
a360 1
		if (result == ERESTART)
d364 2
a365 2
		if (result == EAGAIN) {
			tsleep(&lbolt, PVM, "loanagain", 0);
d388 1
a388 1
	if (pg->uobject)	/* XXXCDC: what if this is our uobj? bad */
a396 1
 * => called with map, amap, uobj locked
d424 1
a424 1
	if (uobj->pgops->pgo_get) {	/* try locked pgo_get */
d430 1
a430 1
		result = EIO;		/* must have pgo_get op */
d438 1
a438 1
	if (result != 0 && result != EBUSY) {
d447 1
a447 1
	if (result == EBUSY) {
d449 1
a449 1

d455 1
a455 1

d460 3
a462 3
		if (result != 0) {
			 if (result == EAGAIN) {
				tsleep(&lbolt, PVM, "fltagain2", 0);
d464 1
a464 1
			}
d482 1
a482 1

d486 1
a486 1

d490 1
a490 1
		}
d529 1
a529 1
	if ((flags & UVM_LOAN_TOANON) == 0) { /* loan to wired-kernel page? */
d548 1
a548 1
	 * a reference to this object.   the page should already be
d568 1
a568 1

a603 1
 * => called with map, amap, uobj locked
d624 1
a624 1
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap,
d636 1
a636 1

d651 1
a651 1
	while ((anon = uvm_analloc()) == NULL ||
@


1.3.4.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_loan.c,v 1.22 2000/06/27 17:29:25 mrg Exp $	*/
d52 1
a52 1
 * "loaned" pages are pages which are (read-only, copy-on-write) loaned 
d78 1
a78 1
 * owners that want to free their pages and discover that they are 
d95 1
a95 1
 *  1. write fault to a loaned page 
d108 1
a108 1
static int	uvm_loananon __P((struct uvm_faultinfo *, void ***, 
d111 1
a111 1
static int	uvm_loanuobj __P((struct uvm_faultinfo *, void ***, 
d123 2
a124 2
 *	the maps are locked by the caller)
 * => we may unlock the maps if needed (for I/O)
d126 4
a129 1
 * => we return the number of pages we loaned, or -1 if we had an error
d146 1
a146 1
	 * lock us the rest of the way down
d168 1
d176 1
a176 1
			rv = -1;		/* null map entry... fail now */
d178 1
d197 1
a197 1
	 * unlock everything and return
d199 4
a202 1
	uvmfault_unlockall(ufi, aref->ar_amap, uobj, NULL);
d211 2
a212 2
 * uvm_loan: loan pages out to anons or to the kernel
 * 
d219 1
d232 1
a232 6
	int rv;

#ifdef DIAGNOSTIC
	if (map->flags & VM_MAP_INTRSAFE)
		panic("uvm_loan: intrsafe map");
#endif
d238 3
a240 4
	if ((flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 
	    (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE) ||
	    (flags & (UVM_LOAN_TOANON|UVM_LOAN_TOPAGE)) == 0)
		return(KERN_FAILURE);
d262 1
a262 1
		
d268 2
a269 1
		if (!uvmfault_lookup(&ufi, FALSE)) 
d271 1
d274 1
a274 1
		 * now do the loanout
d277 3
a279 1
		if (rv < 0) 
d281 1
d284 6
a289 1
		 * done!   advance pointers and unlock.
d291 6
a296 4
		rv <<= PAGE_SHIFT;
		len -= rv;
		start += rv;
		uvmfault_unlockmaps(&ufi, FALSE);
d298 1
a298 1
	
d303 1
a303 1
	return(KERN_SUCCESS);
d308 1
d318 1
a318 1
	return(KERN_FAILURE);
d323 2
a324 1
 * 
d343 1
a343 1
	 * if we are loaning to another anon then it is easy, we just
d345 1
a345 1
	 * pointer to it.
d350 1
d352 1
a352 1
			/* read protect it */
d374 1
a374 2

	if (result != VM_PAGER_OK) {
d377 1
a377 1
		if (result == VM_PAGER_REFAULT)
d381 2
a382 2
		if (result == VM_PAGER_AGAIN) {
			tsleep((caddr_t)&lbolt, PVM, "loanagain", 0);
d405 1
a405 1
	if (pg->uobject)
d414 1
d442 1
a442 1
	if (uobj->pgops->pgo_get) {
d448 1
a448 1
		result = VM_PAGER_ERROR;
d456 1
a456 1
	if (result != VM_PAGER_OK && result != VM_PAGER_UNLOCK) {
d465 1
a465 1
	if (result == VM_PAGER_UNLOCK) {
d467 1
a467 1
		
d473 1
a473 1
		
d478 3
a480 3
		if (result != VM_PAGER_OK) {
			 if (result == VM_PAGER_AGAIN) {
				tsleep((caddr_t)&lbolt, PVM, "fltagain2", 0);
d482 1
a482 1
			} 
d500 1
a500 1
			
d504 1
a504 1
			
d508 1
a508 1
		} 
d547 1
a547 1
	if ((flags & UVM_LOAN_TOANON) == 0) {	/* loan to wired-kernel page? */
d566 1
a566 1
	 * a reference to this object.   the page should already be 
d586 1
a586 1
	
d600 1
d615 1
d622 1
d643 1
a643 1
			uvmfault_unlockall(ufi, ufi->entry->aref.ar_amap, 
d655 1
a655 1
		
d670 1
a670 1
	while ((anon = uvm_analloc()) == NULL || 
d675 1
a675 1
		       ufi->entry->object.uvm_obj, NULL);
d680 7
@


1.3.4.7
log
@Merge in -current from roughly a week ago
@
text
@d108 6
a113 6
static int	uvm_loananon(struct uvm_faultinfo *, void ***, 
				int, struct vm_anon *);
static int	uvm_loanentry(struct uvm_faultinfo *, void ***, int);
static int	uvm_loanuobj(struct uvm_faultinfo *, void ***, 
				int, vaddr_t);
static int	uvm_loanzero(struct uvm_faultinfo *, void ***, int);
@


1.3.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d269 1
a269 1
		 * map now locked.  now do the loanout...
d276 1
a276 5
		 * done!  the map is unlocked.  advance, if possible.
		 *
		 * XXXCDC: could be recoded to hold the map lock with   
		 *	   smarter code (but it only happens on map entry
		 *	   boundaries, so it isn't that bad).
d278 4
a281 5
		if (rv) {
			rv <<= PAGE_SHIFT;
			len -= rv;
			start += rv;
		}
@


1.2
log
@add OpenBSD tags
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_loan.c,v 1.13 1999/01/24 23:53:15 chuck Exp $	*/
a3 4
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
/*
d613 1
a613 1
		while ((pg = uvm_pagealloc(NULL, 0, NULL)) == NULL) {
d643 1
a643 1
	    (pg = uvm_pagealloc(NULL, 0, anon)) == NULL) {
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

