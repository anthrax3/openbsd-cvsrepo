head	1.21;
access;
symbols
	OPENBSD_4_5:1.20.0.6
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.4
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.2
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.15.0.20
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.18
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.16
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.14
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.12
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.10
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.8
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2009.03.25.20.00.18;	author oga;	state dead;
branches;
next	1.20;

1.20
date	2008.01.09.17.42.17;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2007.12.18.11.05.52;	author thib;	state Exp;
branches;
next	1.18;

1.18
date	2007.11.29.00.26.42;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.13.18.57.49;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.04.17.44.45;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2002.09.10.18.29.44;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.02.22.23.25;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.19.28.15;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.27.05.27.12;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.12.01.26.10;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.09.03.32.23;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.06.14.03.05;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.47;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.22.11.04;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.24;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.17;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.51;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.01.31.22.55.51;	author niklas;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.02.02.03.28.27;	author art;	state Exp;
branches;
next	1.12.2.3;

1.12.2.3
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Move all of the pseudo-inline functions in uvm into C files.

By pseudo-inline, I mean that if a certain macro was defined, they would
be inlined. However, no architecture defines that, and none has for a
very very long time. Therefore mainly this just makes the code a damned
sight easier to read. Some k&r -> ansi declarations while I'm in there.

"just commit it" art@@. ok weingart@@.
@
text
@/*	$OpenBSD: uvm_page_i.h,v 1.20 2008/01/09 17:42:17 miod Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.14 2000/11/27 07:47:42 chs Exp $	*/

/* 
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * Copyright (c) 1991, 1993, The Regents of the University of California.  
 *
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * The Mach Operating System project at Carnegie-Mellon University.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles D. Cranor,
 *      Washington University, the University of California, Berkeley and 
 *      its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)vm_page.c   8.3 (Berkeley) 3/21/94
 * from: Id: uvm_page_i.h,v 1.1.2.7 1998/01/05 00:26:02 chuck Exp
 *
 *
 * Copyright (c) 1987, 1990 Carnegie-Mellon University.
 * All rights reserved.
 * 
 * Permission to use, copy, modify and distribute this software and
 * its documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
 * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 *
 *  Software Distribution Coordinator  or  Software.Distribution@@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 *
 * any improvements or extensions that they make and grant Carnegie the
 * rights to redistribute these changes.
 */

#ifndef _UVM_UVM_PAGE_I_H_
#define _UVM_UVM_PAGE_I_H_

/*
 * uvm_page_i.h
 */

/*
 * inline functions [maybe]
 */

#if defined(UVM_PAGE_INLINE) || defined(UVM_PAGE)
/*
 * uvm_pagelookup: look up a page
 *
 * => caller should lock object to keep someone from pulling the page
 *	out from under it
 */

struct vm_page *
uvm_pagelookup(struct uvm_object *obj, voff_t off)
{
	struct vm_page *pg;
	struct pglist *buck;
	int s;

	buck = &uvm.page_hash[uvm_pagehash(obj,off)];

	s = splvm();
	simple_lock(&uvm.hashlock);
	TAILQ_FOREACH(pg, buck, hashq) {
		if (pg->uobject == obj && pg->offset == off) {
			break;
		}
	}
	simple_unlock(&uvm.hashlock);
	splx(s);
	return(pg);
}

/*
 * uvm_pagewire: wire the page, thus removing it from the daemon's grasp
 *
 * => caller must lock page queues
 */

PAGE_INLINE void
uvm_pagewire(struct vm_page *pg)
{
	if (pg->wire_count == 0) {
		if (pg->pg_flags & PQ_ACTIVE) {
			TAILQ_REMOVE(&uvm.page_active, pg, pageq);
			atomic_clearbits_int(&pg->pg_flags, PQ_ACTIVE);
			uvmexp.active--;
		}
		if (pg->pg_flags & PQ_INACTIVE) {
			if (pg->pg_flags & PQ_SWAPBACKED)
				TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
			else
				TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
			atomic_clearbits_int(&pg->pg_flags, PQ_INACTIVE);
			uvmexp.inactive--;
		}
		uvmexp.wired++;
	}
	pg->wire_count++;
}

/*
 * uvm_pageunwire: unwire the page.   
 *
 * => activate if wire count goes to zero.
 * => caller must lock page queues
 */
 
PAGE_INLINE void
uvm_pageunwire(struct vm_page *pg)
{
	pg->wire_count--;
	if (pg->wire_count == 0) {
		TAILQ_INSERT_TAIL(&uvm.page_active, pg, pageq);
		uvmexp.active++;
		atomic_setbits_int(&pg->pg_flags, PQ_ACTIVE);
		uvmexp.wired--;
	}
}

/*
 * uvm_pagedeactivate: deactivate page -- no pmaps have access to page
 *
 * => caller must lock page queues
 * => caller must check to make sure page is not wired
 * => object that page belongs to must be locked (so we can adjust pg->flags)
 */

PAGE_INLINE void
uvm_pagedeactivate(struct vm_page *pg)
{
	if (pg->pg_flags & PQ_ACTIVE) {
		TAILQ_REMOVE(&uvm.page_active, pg, pageq);
		atomic_clearbits_int(&pg->pg_flags, PQ_ACTIVE);
		uvmexp.active--;
	}
	if ((pg->pg_flags & PQ_INACTIVE) == 0) {
		KASSERT(pg->wire_count == 0);
		if (pg->pg_flags & PQ_SWAPBACKED)
			TAILQ_INSERT_TAIL(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_INSERT_TAIL(&uvm.page_inactive_obj, pg, pageq);
		atomic_setbits_int(&pg->pg_flags, PQ_INACTIVE);
		uvmexp.inactive++;
		pmap_clear_reference(pg);
		/*
		 * update the "clean" bit.  this isn't 100%
		 * accurate, and doesn't have to be.  we'll
		 * re-sync it after we zap all mappings when
		 * scanning the inactive list.
		 */
		if ((pg->pg_flags & PG_CLEAN) != 0 &&
		    pmap_is_modified(pg))
			atomic_clearbits_int(&pg->pg_flags, PG_CLEAN);
	}
}

/*
 * uvm_pageactivate: activate page
 *
 * => caller must lock page queues
 */

PAGE_INLINE void
uvm_pageactivate(struct vm_page *pg)
{
	if (pg->pg_flags & PQ_INACTIVE) {
		if (pg->pg_flags & PQ_SWAPBACKED)
			TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
		atomic_clearbits_int(&pg->pg_flags, PQ_INACTIVE);
		uvmexp.inactive--;
	}
	if (pg->wire_count == 0) {

		/*
		 * if page is already active, remove it from list so we
		 * can put it at tail.  if it wasn't active, then mark
		 * it active and bump active count
		 */
		if (pg->pg_flags & PQ_ACTIVE)
			TAILQ_REMOVE(&uvm.page_active, pg, pageq);
		else {
			atomic_setbits_int(&pg->pg_flags, PQ_ACTIVE);
			uvmexp.active++;
		}

		TAILQ_INSERT_TAIL(&uvm.page_active, pg, pageq);
	}
}

/*
 * uvm_pagezero: zero fill a page
 *
 * => if page is part of an object then the object should be locked
 *	to protect pg->flags.
 */

PAGE_INLINE void
uvm_pagezero(struct vm_page *pg)
{
	atomic_clearbits_int(&pg->pg_flags, PG_CLEAN);
	pmap_zero_page(pg);
}

/*
 * uvm_pagecopy: copy a page
 *
 * => if page is part of an object then the object should be locked
 *	to protect pg->flags.
 */

PAGE_INLINE void
uvm_pagecopy(struct vm_page *src, struct vm_page *dst)
{
	atomic_clearbits_int(&dst->pg_flags, PG_CLEAN);
	pmap_copy_page(src, dst);
}

/*
 * uvm_page_lookup_freelist: look up the free list for the specified page
 */

PAGE_INLINE int
uvm_page_lookup_freelist(struct vm_page *pg)
{
#if VM_PHYSSEG_MAX == 1
	return (vm_physmem[0].free_list);
#else
	int lcv;

	lcv = vm_physseg_find(atop(VM_PAGE_TO_PHYS(pg)), NULL);
	KASSERT(lcv != -1);
	return (vm_physmem[lcv].free_list);
#endif
}

#endif /* defined(UVM_PAGE_INLINE) || defined(UVM_PAGE) */

#endif /* _UVM_UVM_PAGE_I_H_ */
@


1.20
log
@Make uvm_page_lookup_freelist() simpler and faster if VM_PHYSSEG_MAX is 1.
Has been in snapshots for a short while.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.19 2007/12/18 11:05:52 thib Exp $	*/
@


1.19
log
@Turn the uvm_{lock/unlock}_fpageq() inlines into
macros that just expand into the mutex functions
to keep the abstraction, do assorted cleanup.

ok miod@@,art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.18 2007/11/29 00:26:42 tedu Exp $	*/
d264 3
d272 1
@


1.18
log
@use a working mutex for the freepage list. ok art deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.17 2007/04/13 18:57:49 art Exp $	*/
a81 30

/*
 * uvm_lock_fpageq: lock the free page queue
 *
 * => free page queue can be accessed in interrupt context, so this
 *	blocks all interrupts that can cause memory allocation, and
 *	returns the previous interrupt level.
 */

PAGE_INLINE int
uvm_lock_fpageq(void)
{
	mtx_enter(&uvm.fpageqlock);
	return (0);
}

/*
 * uvm_unlock_fpageq: unlock the free page queue
 *
 * => caller must supply interrupt level returned by uvm_lock_fpageq()
 *	so that it may be restored.
 */

PAGE_INLINE void
uvm_unlock_fpageq(int s)
{

	mtx_leave(&uvm.fpageqlock);
}

@


1.17
log
@While splitting flags and pqflags might have been a good idea in theory
to separate locking, on most modern machines this is not enough
since operations on short types touch other short types that share the
same word in memory.

Merge pg_flags and pqflags again and now use atomic operations to change
the flags. Also bump wire_count to an int and pg_version might go
int as well, just for alignment.

tested by many, many. ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.16 2007/04/04 17:44:45 art Exp $	*/
d94 2
a95 5
	int s;

	s = splvm();
	simple_lock(&uvm.fpageqlock);
	return (s);
d109 1
a109 2
	simple_unlock(&uvm.fpageqlock);
	splx(s);
@


1.16
log
@Mechanically rename the "flags" and "version" fields in struct vm_page
to "pg_flags" and "pg_version", so that they are a bit easier to work with.
Whoever uses generic names like this for a popular struct obviously doesn't
read much code.

Most architectures compile and there are no functionality changes.

deraadt@@ ok ("if something fails to compile, we fix that by hand")
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.15 2002/09/10 18:29:44 art Exp $	*/
d154 1
a154 1
		if (pg->pqflags & PQ_ACTIVE) {
d156 1
a156 1
			pg->pqflags &= ~PQ_ACTIVE;
d159 2
a160 2
		if (pg->pqflags & PQ_INACTIVE) {
			if (pg->pqflags & PQ_SWAPBACKED)
d164 1
a164 1
			pg->pqflags &= ~PQ_INACTIVE;
d186 1
a186 1
		pg->pqflags |= PQ_ACTIVE;
d202 1
a202 1
	if (pg->pqflags & PQ_ACTIVE) {
d204 1
a204 1
		pg->pqflags &= ~PQ_ACTIVE;
d207 1
a207 1
	if ((pg->pqflags & PQ_INACTIVE) == 0) {
d209 1
a209 1
		if (pg->pqflags & PQ_SWAPBACKED)
d213 1
a213 1
		pg->pqflags |= PQ_INACTIVE;
a214 1
#ifndef UBC
a215 1
#endif
d224 1
a224 1
			pg->pg_flags &= ~PG_CLEAN;
d237 2
a238 2
	if (pg->pqflags & PQ_INACTIVE) {
		if (pg->pqflags & PQ_SWAPBACKED)
d242 1
a242 1
		pg->pqflags &= ~PQ_INACTIVE;
d252 1
a252 1
		if (pg->pqflags & PQ_ACTIVE)
d255 1
a255 1
			pg->pqflags |= PQ_ACTIVE;
d273 1
a273 1
	pg->pg_flags &= ~PG_CLEAN;
d287 1
a287 1
	dst->pg_flags &= ~PG_CLEAN;
@


1.15
log
@Change the pmap_zero_page and pmap_copy_page API to take the struct vm_page *
instead of the pa. Most callers already had it handy and those who didn't
only called it for managed pages and were outside time-critical code.

This will allow us to make those functions clean and fast on sparc and
sparc64 letting us to avoid unnecessary cache flushes.

deraadt@@ miod@@ drahn@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.14 2002/01/02 22:23:25 miod Exp $	*/
d92 1
a92 1
uvm_lock_fpageq()
d109 1
a109 2
uvm_unlock_fpageq(s)
	int s;
d124 1
a124 3
uvm_pagelookup(obj, off)
	struct uvm_object *obj;
	voff_t off;
d151 1
a151 2
uvm_pagewire(pg)
	struct vm_page *pg;
d180 1
a180 2
uvm_pageunwire(pg)
	struct vm_page *pg;
d200 1
a200 2
uvm_pagedeactivate(pg)
	struct vm_page *pg;
d224 1
a224 1
		if ((pg->flags & PG_CLEAN) != 0 &&
d226 1
a226 1
			pg->flags &= ~PG_CLEAN;
d237 1
a237 2
uvm_pageactivate(pg)
	struct vm_page *pg;
d273 1
a273 2
uvm_pagezero(pg)
	struct vm_page *pg;
d275 1
a275 2

	pg->flags &= ~PG_CLEAN;
d287 1
a287 2
uvm_pagecopy(src, dst)
	struct vm_page *src, *dst;
d289 1
a289 2

	dst->flags &= ~PG_CLEAN;
d298 1
a298 2
uvm_page_lookup_freelist(pg)
	struct vm_page *pg;
@


1.14
log
@Back out a few more uvm changes, especially wrt swap usage.
This unbreaks m68k m88k sparc and perhaps others, which eventually froze
when hitting swap.
Tested by various people on various platforms.
ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.9 2001/11/09 03:32:23 art Exp $	*/
d285 1
a285 1
	pmap_zero_page(VM_PAGE_TO_PHYS(pg));
d301 1
a301 1
	pmap_copy_page(VM_PAGE_TO_PHYS(src), VM_PAGE_TO_PHYS(dst));
@


1.13
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.10 2001/11/12 01:26:10 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.16 2001/01/28 23:30:45 thorpej Exp $	*/
d197 1
a197 1
 * uvm_pagedeactivate: deactivate page
a201 1
 * => caller must clear the reference on the page before calling
@


1.12
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.11 2001/11/27 05:27:12 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.19 2001/06/27 23:57:17 thorpej Exp $	*/
d4 1
a4 1
/*
d6 1
a6 1
 * Copyright (c) 1991, 1993, The Regents of the University of California.
d24 1
a24 1
 *      Washington University, the University of California, Berkeley and
d48 1
a48 1
 *
d54 3
a56 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d58 1
a58 1
 *
d162 6
a167 2
		} else if (pg->pqflags & PQ_INACTIVE) {
			TAILQ_REMOVE(&uvm.page_inactive, pg, pageq);
d177 1
a177 1
 * uvm_pageunwire: unwire the page.
d182 1
a182 1

d216 4
a219 1
		TAILQ_INSERT_TAIL(&uvm.page_inactive, pg, pageq);
d222 3
d248 4
a251 1
		TAILQ_REMOVE(&uvm.page_inactive, pg, pageq);
@


1.12.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.14 2002/01/02 22:23:25 miod Exp $	*/
d193 1
a193 1
 * uvm_pagedeactivate: deactivate page -- no pmaps have access to page
d198 1
@


1.12.2.2
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.12.2.1 2002/01/31 22:55:51 niklas Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.20 2001/09/15 20:36:47 chs Exp $	*/
d131 1
d134 2
d143 1
a143 3
	KASSERT(pg == NULL || obj->uo_npages != 0);
	KASSERT(pg == NULL || (pg->flags & (PG_RELEASED|PG_PAGEOUT)) == 0 ||
		(pg->flags & PG_BUSY) != 0);
d158 9
a166 1
		uvm_pagedequeue(pg);
d193 1
a193 1
 * uvm_pagedeactivate: deactivate page
a197 1
 * => caller must clear the reference on the page before calling
d214 9
d236 5
a240 1
	uvm_pagedequeue(pg);
a241 5
		TAILQ_INSERT_TAIL(&uvm.page_active, pg, pageq);
		pg->pqflags |= PQ_ACTIVE;
		uvmexp.active++;
	}
}
d243 11
a253 3
/*
 * uvm_pagedequeue: remove a page from any paging queue
 */
d255 1
a255 12
PAGE_INLINE void
uvm_pagedequeue(pg)
	struct vm_page *pg;
{
	if (pg->pqflags & PQ_ACTIVE) {
		TAILQ_REMOVE(&uvm.page_active, pg, pageq);
		pg->pqflags &= ~PQ_ACTIVE;
		uvmexp.active--;
	} else if (pg->pqflags & PQ_INACTIVE) {
		TAILQ_REMOVE(&uvm.page_inactive, pg, pageq);
		pg->pqflags &= ~PQ_INACTIVE;
		uvmexp.inactive--;
d270 1
@


1.12.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.12.2.2 2002/02/02 03:28:27 art Exp $	*/
d258 1
a258 1
	pmap_zero_page(pg);
d274 1
a274 1
	pmap_copy_page(src, dst);
@


1.11
log
@Merge in the unified buffer cache code as found in NetBSD 2001/03/10. The
code is written mostly by Chuck Silvers <chuq@@chuq.com>/<chs@@netbsd.org>.

Tested for the past few weeks by many developers, should be in a pretty stable
state, but will require optimizations and additional cleanups.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.10 2001/11/12 01:26:10 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.16 2001/01/28 23:30:45 thorpej Exp $	*/
d4 1
a4 1
/* 
d6 1
a6 1
 * Copyright (c) 1991, 1993, The Regents of the University of California.  
d24 1
a24 1
 *      Washington University, the University of California, Berkeley and 
d48 1
a48 1
 * 
d54 3
a56 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d58 1
a58 1
 * 
d162 2
a163 6
		}
		if (pg->pqflags & PQ_INACTIVE) {
			if (pg->pqflags & PQ_SWAPBACKED)
				TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
			else
				TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
d173 1
a173 1
 * uvm_pageunwire: unwire the page.   
d178 1
a178 1
 
d212 1
a212 4
		if (pg->pqflags & PQ_SWAPBACKED)
			TAILQ_INSERT_TAIL(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_INSERT_TAIL(&uvm.page_inactive_obj, pg, pageq);
d238 1
a238 4
		if (pg->pqflags & PQ_SWAPBACKED)
			TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
@


1.10
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_page_i.h,v 1.9 2001/11/09 03:32:23 art Exp $	*/
a221 3
#ifndef UBC
		pmap_clear_reference(pg);
#endif
@


1.9
log
@minor sync to NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.8 2001/08/11 10:57:22 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.14 2000/11/27 07:47:42 chs Exp $	*/
d96 1
a96 1
	s = splimp();
d135 1
a135 1
	s = splimp();
d197 1
a197 1
 * uvm_pagedeactivate: deactivate page -- no pmaps have access to page
d202 1
d222 1
d224 9
a232 1
		if (pmap_is_modified(pg))
@


1.8
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.7 2001/08/06 14:03:05 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.13 2000/05/08 23:11:53 thorpej Exp $	*/
d137 1
a137 1
	for (pg = buck->tqh_first ; pg != NULL ; pg = pg->hashq.tqe_next) {
d139 1
a139 3
			simple_unlock(&uvm.hashlock);
			splx(s);
			return(pg);
d144 1
a144 1
	return(NULL);
a156 1

a186 1

d214 1
a214 5
#ifdef DIAGNOSTIC 
		if (__predict_false(pg->wire_count))
			panic("uvm_pagedeactivate: caller did not check "
			    "wire count");
#endif
d252 1
a252 1
		if (pg->pqflags & PQ_ACTIVE) 
d306 1
a306 4
#ifdef DIAGNOSTIC
	if (__predict_false(lcv == -1))
		panic("uvm_page_lookup_freelist: unable to locate physseg");
#endif
@


1.7
log
@Add a new type voff_t (right now it's typedefed as off_t) used for offsets
into objects.

Gives the possibilty to mmap beyond the size of vaddr_t.

From NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.6 2001/07/18 10:47:05 art Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.12 2000/03/26 20:54:47 kleink Exp $	*/
d219 1
a219 1
		if (pg->wire_count)
d315 1
a315 1
	if (lcv == -1)
@


1.6
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.5 2001/01/29 02:07:47 niklas Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.11 1999/09/12 01:17:38 chs Exp $	*/
d127 1
a127 1
	vaddr_t off;
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_page_i.h,v 1.10 1999/05/24 19:10:57 thorpej Exp $	*/
/*	$NetBSD: uvm_page_i.h,v 1.10 1999/05/24 19:10:57 thorpej Exp $	*/
d229 2
a230 2
		pmap_clear_reference(PMAP_PGARG(pg));
		if (pmap_is_modified(PMAP_PGARG(pg)))
@


1.4
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_page_i.h,v 1.8 1998/08/13 02:11:02 eeh Exp $	*/
d81 34
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_page_i.h,v 1.10 1999/05/24 19:10:57 thorpej Exp $	*/
a80 34

/*
 * uvm_lock_fpageq: lock the free page queue
 *
 * => free page queue can be accessed in interrupt context, so this
 *	blocks all interrupts that can cause memory allocation, and
 *	returns the previous interrupt level.
 */

PAGE_INLINE int
uvm_lock_fpageq()
{
	int s;

	s = splimp();
	simple_lock(&uvm.fpageqlock);
	return (s);
}

/*
 * uvm_unlock_fpageq: unlock the free page queue
 *
 * => caller must supply interrupt level returned by uvm_lock_fpageq()
 *	so that it may be restored.
 */

PAGE_INLINE void
uvm_unlock_fpageq(s)
	int s;
{

	simple_unlock(&uvm.fpageqlock);
	splx(s);
}
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_page_i.h,v 1.5 2001/01/29 02:07:47 niklas Exp $	*/
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_page_i.h,v 1.13 2000/05/08 23:11:53 thorpej Exp $	*/
d127 1
a127 1
	voff_t off;
d219 1
a219 1
		if (__predict_false(pg->wire_count))
d229 2
a230 2
		pmap_clear_reference(pg);
		if (pmap_is_modified(pg))
d315 1
a315 1
	if (__predict_false(lcv == -1))
@


1.3.4.4
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_page_i.h,v 1.16 2001/01/28 23:30:45 thorpej Exp $	*/
d96 1
a96 1
	s = splvm();
d135 1
a135 1
	s = splvm();
d137 1
a137 1
	TAILQ_FOREACH(pg, buck, hashq) {
d139 3
a141 1
			break;
d146 1
a146 1
	return(pg);
d159 1
d190 1
d201 1
a201 1
 * uvm_pagedeactivate: deactivate page
a205 1
 * => caller must clear the reference on the page before calling
d218 5
a222 1
		KASSERT(pg->wire_count == 0);
a228 1
#ifndef UBC
d230 1
a230 9
#endif
		/*
		 * update the "clean" bit.  this isn't 100%
		 * accurate, and doesn't have to be.  we'll
		 * re-sync it after we zap all mappings when
		 * scanning the inactive list.
		 */
		if ((pg->flags & PG_CLEAN) != 0 &&
		    pmap_is_modified(pg))
d260 1
a260 1
		if (pg->pqflags & PQ_ACTIVE)
d314 4
a317 1
	KASSERT(lcv != -1);
@


1.3.4.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_page_i.h,v 1.19 2001/06/27 23:57:17 thorpej Exp $	*/
d4 1
a4 1
/*
d6 1
a6 1
 * Copyright (c) 1991, 1993, The Regents of the University of California.
d24 1
a24 1
 *      Washington University, the University of California, Berkeley and
d48 1
a48 1
 *
d54 3
a56 3
 *
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND
d58 1
a58 1
 *
d162 6
a167 2
		} else if (pg->pqflags & PQ_INACTIVE) {
			TAILQ_REMOVE(&uvm.page_inactive, pg, pageq);
d177 1
a177 1
 * uvm_pageunwire: unwire the page.
d182 1
a182 1

d216 4
a219 1
		TAILQ_INSERT_TAIL(&uvm.page_inactive, pg, pageq);
d222 3
d248 4
a251 1
		TAILQ_REMOVE(&uvm.page_inactive, pg, pageq);
@


1.3.4.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_page_i.h,v 1.14 2000/11/27 07:47:42 chs Exp $	*/
d4 1
a4 1
/* 
d6 1
a6 1
 * Copyright (c) 1991, 1993, The Regents of the University of California.  
d24 1
a24 1
 *      Washington University, the University of California, Berkeley and 
d48 1
a48 1
 * 
d54 3
a56 3
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS" 
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND 
d58 1
a58 1
 * 
d162 2
a163 6
		}
		if (pg->pqflags & PQ_INACTIVE) {
			if (pg->pqflags & PQ_SWAPBACKED)
				TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
			else
				TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
d173 1
a173 1
 * uvm_pageunwire: unwire the page.   
d178 1
a178 1
 
d193 1
a193 1
 * uvm_pagedeactivate: deactivate page -- no pmaps have access to page
d198 1
d212 1
a212 4
		if (pg->pqflags & PQ_SWAPBACKED)
			TAILQ_INSERT_TAIL(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_INSERT_TAIL(&uvm.page_inactive_obj, pg, pageq);
a214 3
#ifndef UBC
		pmap_clear_reference(pg);
#endif
d238 1
a238 4
		if (pg->pqflags & PQ_SWAPBACKED)
			TAILQ_REMOVE(&uvm.page_inactive_swp, pg, pageq);
		else
			TAILQ_REMOVE(&uvm.page_inactive_obj, pg, pageq);
@


1.3.4.7
log
@Sync the SMP branch with 3.3
@
text
@d285 1
a285 1
	pmap_zero_page(pg);
d301 1
a301 1
	pmap_copy_page(src, dst);
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!
 *         >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

