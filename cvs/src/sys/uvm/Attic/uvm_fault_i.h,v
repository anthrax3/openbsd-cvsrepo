head	1.13;
access;
symbols
	OPENBSD_4_5:1.12.0.8
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.6
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.4
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.10.0.22
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.20
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.18
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.16
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.14
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.10.0.12
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.10
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.8
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2009.03.25.20.00.18;	author oga;	state dead;
branches;
next	1.12;

1.12
date	2007.05.31.21.20.30;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.11.12.10.42;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.18;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.28.19.28.14;	author art;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.11.05.22.14.54;	author art;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.26.19.37.13;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.44;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.16.22.11.04;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.23;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.06;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.12;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.49;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.45;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.06.11.03.33.03;	author art;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Move all of the pseudo-inline functions in uvm into C files.

By pseudo-inline, I mean that if a certain macro was defined, they would
be inlined. However, no architecture defines that, and none has for a
very very long time. Therefore mainly this just makes the code a damned
sight easier to read. Some k&r -> ansi declarations while I'm in there.

"just commit it" art@@. ok weingart@@.
@
text
@/*	$OpenBSD: uvm_fault_i.h,v 1.12 2007/05/31 21:20:30 thib Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.11 2000/06/26 14:21:17 mrg Exp $	*/

/*
 *
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_fault_i.h,v 1.1.6.1 1997/12/08 16:07:12 chuck Exp
 */

#ifndef _UVM_UVM_FAULT_I_H_
#define _UVM_UVM_FAULT_I_H_

/*
 * uvm_fault_i.h: fault inline functions
 */
static boolean_t uvmfault_lookup(struct uvm_faultinfo *, boolean_t);
static boolean_t uvmfault_relock(struct uvm_faultinfo *);
static void uvmfault_unlockall(struct uvm_faultinfo *, struct vm_amap *,
			            struct uvm_object *, struct vm_anon *);
static void uvmfault_unlockmaps(struct uvm_faultinfo *, boolean_t);

/*
 * uvmfault_unlockmaps: unlock the maps
 */

static __inline void
uvmfault_unlockmaps(ufi, write_locked)
	struct uvm_faultinfo *ufi;
	boolean_t write_locked;
{
	/*
	 * ufi can be NULL when this isn't really a fault,
	 * but merely paging in anon data.
	 */

	if (ufi == NULL) {
		return;
	}

	if (write_locked) {
		vm_map_unlock(ufi->map);
	} else {
		vm_map_unlock_read(ufi->map);
	}
}

/*
 * uvmfault_unlockall: unlock everything passed in.
 *
 * => maps must be read-locked (not write-locked).
 */

static __inline void
uvmfault_unlockall(ufi, amap, uobj, anon)
	struct uvm_faultinfo *ufi;
	struct vm_amap *amap;
	struct uvm_object *uobj;
	struct vm_anon *anon;
{

	if (anon)
		simple_unlock(&anon->an_lock);
	if (uobj)
		simple_unlock(&uobj->vmobjlock);
	uvmfault_unlockmaps(ufi, FALSE);
}

/*
 * uvmfault_lookup: lookup a virtual address in a map
 *
 * => caller must provide a uvm_faultinfo structure with the IN
 *	params properly filled in
 * => we will lookup the map entry (handling submaps) as we go
 * => if the lookup is a success we will return with the maps locked
 * => if "write_lock" is TRUE, we write_lock the map, otherwise we only
 *	get a read lock.
 * => note that submaps can only appear in the kernel and they are 
 *	required to use the same virtual addresses as the map they
 *	are referenced by (thus address translation between the main
 *	map and the submap is unnecessary).
 */

static __inline boolean_t
uvmfault_lookup(ufi, write_lock)
	struct uvm_faultinfo *ufi;
	boolean_t write_lock;
{
	vm_map_t tmpmap;

	/*
	 * init ufi values for lookup.
	 */

	ufi->map = ufi->orig_map;
	ufi->size = ufi->orig_size;

	/*
	 * keep going down levels until we are done.   note that there can
	 * only be two levels so we won't loop very long.
	 */

	while (1) {

		/*
		 * lock map
		 */
		if (write_lock) {
			vm_map_lock(ufi->map);
		} else {
			vm_map_lock_read(ufi->map);
		}

		/*
		 * lookup
		 */
		if (!uvm_map_lookup_entry(ufi->map, ufi->orig_rvaddr, 
								&ufi->entry)) {
			uvmfault_unlockmaps(ufi, write_lock);
			return(FALSE);
		}

		/*
		 * reduce size if necessary
		 */
		if (ufi->entry->end - ufi->orig_rvaddr < ufi->size)
			ufi->size = ufi->entry->end - ufi->orig_rvaddr;

		/*
		 * submap?    replace map with the submap and lookup again.
		 * note: VAs in submaps must match VAs in main map.
		 */
		if (UVM_ET_ISSUBMAP(ufi->entry)) {
			tmpmap = ufi->entry->object.sub_map;
			if (write_lock) {
				vm_map_unlock(ufi->map);
			} else {
				vm_map_unlock_read(ufi->map);
			}
			ufi->map = tmpmap;
			continue;
		}

		/*
		 * got it!
		 */

		ufi->mapv = ufi->map->timestamp;
		return(TRUE);

	}	/* while loop */

	/*NOTREACHED*/
}

/*
 * uvmfault_relock: attempt to relock the same version of the map
 *
 * => fault data structures should be unlocked before calling.
 * => if a success (TRUE) maps will be locked after call.
 */

static __inline boolean_t
uvmfault_relock(ufi)
	struct uvm_faultinfo *ufi;
{
	/*
	 * ufi can be NULL when this isn't really a fault,
	 * but merely paging in anon data.
	 */

	if (ufi == NULL) {
		return TRUE;
	}

	uvmexp.fltrelck++;

	/*
	 * relock map.   fail if version mismatch (in which case nothing 
	 * gets locked).
	 */

	vm_map_lock_read(ufi->map);
	if (ufi->mapv != ufi->map->timestamp) {
		vm_map_unlock_read(ufi->map);
		return(FALSE);
	}

	uvmexp.fltrelckok++;
	return(TRUE);		/* got it! */
}

#endif /* _UVM_UVM_FAULT_I_H_ */
@


1.12
log
@zap the vm_amap am_l simplelock, and amap_{lock/unlock} macros for
simple_{lock/unlock}.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_fault_i.h,v 1.11 2007/04/11 12:10:42 art Exp $	*/
@


1.11
log
@Instead of managing pages for intrsafe maps in special objects (aka.
kmem_object) just so that we can remove them, just use pmap_extract
to get the pages to free and simplify a lot of code to not deal with
the list of intrsafe maps, intrsafe objects, etc.

miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_fault_i.h,v 1.10 2002/03/14 01:27:18 millert Exp $	*/
a92 2
	if (amap)
		amap_unlock(amap);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_fault_i.h,v 1.9 2001/12/19 08:58:07 art Exp $	*/
a43 1
static boolean_t uvmfault_check_intrsafe(struct uvm_faultinfo *);
a95 33
}

/*
 * uvmfault_check_intrsafe: check for a virtual address managed by
 * an interrupt-safe map.
 *
 * => caller must provide a uvm_faultinfo structure with the IN
 *	params properly filled in
 * => if we find an intersafe VA, we fill in ufi->map, and return TRUE
 */

static __inline boolean_t
uvmfault_check_intrsafe(ufi)
	struct uvm_faultinfo *ufi;
{
	struct vm_map_intrsafe *vmi;
	int s;

	s = vmi_list_lock();
	for (vmi = LIST_FIRST(&vmi_list); vmi != NULL;
	     vmi = LIST_NEXT(vmi, vmi_list)) {
		if (ufi->orig_rvaddr >= vm_map_min(&vmi->vmi_map) &&
		    ufi->orig_rvaddr < vm_map_max(&vmi->vmi_map))
			break;
	}
	vmi_list_unlock(s);

	if (vmi != NULL) {
		ufi->map = &vmi->vmi_map;
		return (TRUE);
	}

	return (FALSE);
@


1.9
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_fault_i.h,v 1.7 2001/11/05 22:14:54 art Exp $	*/
d44 6
a49 6
static boolean_t uvmfault_check_intrsafe __P((struct uvm_faultinfo *));
static boolean_t uvmfault_lookup __P((struct uvm_faultinfo *, boolean_t));
static boolean_t uvmfault_relock __P((struct uvm_faultinfo *));
static void uvmfault_unlockall __P((struct uvm_faultinfo *, struct vm_amap *,
			            struct uvm_object *, struct vm_anon *));
static void uvmfault_unlockmaps __P((struct uvm_faultinfo *, boolean_t));
@


1.8
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_fault_i.h,v 1.14 2001/06/26 17:55:15 thorpej Exp $	*/
d44 1
d100 33
d141 1
a141 1
 * => note that submaps can only appear in the kernel and they are
d152 1
a152 1
	struct vm_map *tmpmap;
a166 7
		/*
		 * Make sure this is not an "interrupt safe" map.
		 * Such maps are never supposed to be involved in
		 * a fault.
		 */
		if (ufi->map->flags & VM_MAP_INTRSAFE)
			return (FALSE);
d180 1
a180 1
		if (!uvm_map_lookup_entry(ufi->map, ufi->orig_rvaddr,
d242 1
a242 1
	 * relock map.   fail if version mismatch (in which case nothing
@


1.8.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_fault_i.h,v 1.8 2001/11/28 19:28:14 art Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.15 2001/09/15 20:36:45 chs Exp $	*/
d226 1
a226 1
	return(TRUE);
@


1.8.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_fault_i.h,v 1.8.2.1 2002/02/02 03:28:26 art Exp $	*/
d44 5
a48 5
static boolean_t uvmfault_lookup(struct uvm_faultinfo *, boolean_t);
static boolean_t uvmfault_relock(struct uvm_faultinfo *);
static void uvmfault_unlockall(struct uvm_faultinfo *, struct vm_amap *,
			            struct uvm_object *, struct vm_anon *);
static void uvmfault_unlockmaps(struct uvm_faultinfo *, boolean_t);
@


1.8.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_fault_i.h,v 1.8.2.2 2002/06/11 03:33:03 art Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.16 2002/11/02 07:38:42 perry Exp $	*/
a131 1
	/*CONSTCOND*/
@


1.7
log
@Minor sync to NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_fault_i.h,v 1.6 2001/07/26 19:37:13 art Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.11 2000/06/26 14:21:17 mrg Exp $	*/
a43 1
static boolean_t uvmfault_check_intrsafe __P((struct uvm_faultinfo *));
a98 33
 * uvmfault_check_intrsafe: check for a virtual address managed by
 * an interrupt-safe map.
 *
 * => caller must provide a uvm_faultinfo structure with the IN
 *	params properly filled in
 * => if we find an intersafe VA, we fill in ufi->map, and return TRUE
 */

static __inline boolean_t
uvmfault_check_intrsafe(ufi)
	struct uvm_faultinfo *ufi;
{
	struct vm_map_intrsafe *vmi;
	int s;

	s = vmi_list_lock();
	for (vmi = LIST_FIRST(&vmi_list); vmi != NULL;
	     vmi = LIST_NEXT(vmi, vmi_list)) {
		if (ufi->orig_rvaddr >= vm_map_min(&vmi->vmi_map) &&
		    ufi->orig_rvaddr < vm_map_max(&vmi->vmi_map))
			break;
	}
	vmi_list_unlock(s);

	if (vmi != NULL) {
		ufi->map = &vmi->vmi_map;
		return (TRUE);
	}

	return (FALSE);
}

/*
d107 1
a107 1
 * => note that submaps can only appear in the kernel and they are 
d118 1
a118 1
	vm_map_t tmpmap;
d133 7
d153 1
a153 1
		if (!uvm_map_lookup_entry(ufi->map, ufi->orig_rvaddr, 
d215 1
a215 1
	 * relock map.   fail if version mismatch (in which case nothing 
@


1.6
log
@Add support for disabling swap devices (swapctl -d).
Improve error handling on I/O errors to swap.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_fault_i.h,v 1.5 2001/01/29 02:07:44 niklas Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.10 2000/01/11 06:57:50 chs Exp $	*/
d44 6
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_fault_i.h,v 1.9 1999/06/04 23:38:41 thorpej Exp $	*/
/*	$NetBSD: uvm_fault_i.h,v 1.9 1999/06/04 23:38:41 thorpej Exp $	*/
d54 8
d224 8
d234 1
@


1.4
log
@Bring in some new UVM code from NetBSD (not current).

 - Introduce a new type of map that are interrupt safe and never allow faults
   in them. mb_map and kmem_map are made intrsafe.
 - Add "access protection" to uvm_vslock (to be passed down to uvm_fault and
   later to pmap_enter).
 - madvise(2) now works.
 - various cleanups.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_fault_i.h,v 1.7 1999/01/24 23:53:15 chuck Exp $	*/
d82 33
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_fault_i.h,v 1.9 1999/06/04 23:38:41 thorpej Exp $	*/
a81 33
}

/*
 * uvmfault_check_intrsafe: check for a virtual address managed by
 * an interrupt-safe map.
 *
 * => caller must provide a uvm_faultinfo structure with the IN
 *	params properly filled in
 * => if we find an intersafe VA, we fill in ufi->map, and return TRUE
 */

static __inline boolean_t
uvmfault_check_intrsafe(ufi)
	struct uvm_faultinfo *ufi;
{
	struct vm_map_intrsafe *vmi;
	int s;

	s = vmi_list_lock();
	for (vmi = LIST_FIRST(&vmi_list); vmi != NULL;
	     vmi = LIST_NEXT(vmi, vmi_list)) {
		if (ufi->orig_rvaddr >= vm_map_min(&vmi->vmi_map) &&
		    ufi->orig_rvaddr < vm_map_max(&vmi->vmi_map))
			break;
	}
	vmi_list_unlock(s);

	if (vmi != NULL) {
		ufi->map = &vmi->vmi_map;
		return (TRUE);
	}

	return (FALSE);
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_fault_i.h,v 1.5 2001/01/29 02:07:44 niklas Exp $	*/
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_fault_i.h,v 1.10 2000/01/11 06:57:50 chs Exp $	*/
a53 8
	/*
	 * ufi can be NULL when this isn't really a fault,
	 * but merely paging in anon data.
	 */

	if (ufi == NULL) {
		return;
	}
a215 8
	/*
	 * ufi can be NULL when this isn't really a fault,
	 * but merely paging in anon data.
	 */

	if (ufi == NULL) {
		return TRUE;
	}
a217 1

@


1.3.4.4
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_fault_i.h,v 1.11 2000/06/26 14:21:17 mrg Exp $	*/
a43 6
static boolean_t uvmfault_check_intrsafe __P((struct uvm_faultinfo *));
static boolean_t uvmfault_lookup __P((struct uvm_faultinfo *, boolean_t));
static boolean_t uvmfault_relock __P((struct uvm_faultinfo *));
static void uvmfault_unlockall __P((struct uvm_faultinfo *, struct vm_amap *,
			            struct uvm_object *, struct vm_anon *));
static void uvmfault_unlockmaps __P((struct uvm_faultinfo *, boolean_t));
@


1.3.4.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_fault_i.h,v 1.14 2001/06/26 17:55:15 thorpej Exp $	*/
d44 1
d100 33
d141 1
a141 1
 * => note that submaps can only appear in the kernel and they are
d152 1
a152 1
	struct vm_map *tmpmap;
a166 7
		/*
		 * Make sure this is not an "interrupt safe" map.
		 * Such maps are never supposed to be involved in
		 * a fault.
		 */
		if (ufi->map->flags & VM_MAP_INTRSAFE)
			return (FALSE);
d180 1
a180 1
		if (!uvm_map_lookup_entry(ufi->map, ufi->orig_rvaddr,
d242 1
a242 1
	 * relock map.   fail if version mismatch (in which case nothing
@


1.3.4.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_fault_i.h,v 1.11 2000/06/26 14:21:17 mrg Exp $	*/
a43 1
static boolean_t uvmfault_check_intrsafe __P((struct uvm_faultinfo *));
a98 33
 * uvmfault_check_intrsafe: check for a virtual address managed by
 * an interrupt-safe map.
 *
 * => caller must provide a uvm_faultinfo structure with the IN
 *	params properly filled in
 * => if we find an intersafe VA, we fill in ufi->map, and return TRUE
 */

static __inline boolean_t
uvmfault_check_intrsafe(ufi)
	struct uvm_faultinfo *ufi;
{
	struct vm_map_intrsafe *vmi;
	int s;

	s = vmi_list_lock();
	for (vmi = LIST_FIRST(&vmi_list); vmi != NULL;
	     vmi = LIST_NEXT(vmi, vmi_list)) {
		if (ufi->orig_rvaddr >= vm_map_min(&vmi->vmi_map) &&
		    ufi->orig_rvaddr < vm_map_max(&vmi->vmi_map))
			break;
	}
	vmi_list_unlock(s);

	if (vmi != NULL) {
		ufi->map = &vmi->vmi_map;
		return (TRUE);
	}

	return (FALSE);
}

/*
d107 1
a107 1
 * => note that submaps can only appear in the kernel and they are 
d118 1
a118 1
	vm_map_t tmpmap;
d133 7
d153 1
a153 1
		if (!uvm_map_lookup_entry(ufi->map, ufi->orig_rvaddr, 
d215 1
a215 1
	 * relock map.   fail if version mismatch (in which case nothing 
@


1.3.4.7
log
@Merge in -current from roughly a week ago
@
text
@d44 6
a49 6
static boolean_t uvmfault_check_intrsafe(struct uvm_faultinfo *);
static boolean_t uvmfault_lookup(struct uvm_faultinfo *, boolean_t);
static boolean_t uvmfault_relock(struct uvm_faultinfo *);
static void uvmfault_unlockall(struct uvm_faultinfo *, struct vm_amap *,
			            struct uvm_object *, struct vm_anon *);
static void uvmfault_unlockmaps(struct uvm_faultinfo *, boolean_t);
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

