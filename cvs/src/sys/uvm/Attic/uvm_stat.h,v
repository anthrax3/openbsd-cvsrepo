head	1.17;
access;
symbols
	OPENBSD_4_9:1.15.0.14
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.16
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.14
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.12
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.10
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2011.07.03.18.36.51;	author oga;	state dead;
branches;
next	1.16;

1.16
date	2011.07.03.18.34.14;	author oga;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.07.15.00.20;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.16.13.11.06;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.19;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.28.19.28.15;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.12.01.26.10;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.24.21.29.04;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.09.05.34.38;	author smart;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.02.07.49;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.07.20.15.28;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.15.50.21;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.25;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.08;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.18;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.51;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.48;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.07.04.11.01.08;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.8;

1.3.4.8
date	2002.03.28.14.54.27;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.33.04;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@endodoify UVM_CNT too.

``beat it'' tedu@@ the deleteotron
@
text
@/*	$OpenBSD: uvm_stat.h,v 1.16 2011/07/03 18:34:14 oga Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.19 2001/02/04 10:55:58 mrg Exp $	*/

/*
 *
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_stat.h,v 1.1.2.4 1998/02/07 01:16:56 chs Exp
 */

#ifndef _UVM_UVM_STAT_H_
#define _UVM_UVM_STAT_H_

#include <sys/queue.h>

/*
 * uvm_stat: monitor what is going on with uvm (or whatever)
 */

/*
 * counters  [XXX: maybe replace event counters with this]
 */

#define UVMCNT_MASK	0xf			/* rest are private */
#define UVMCNT_CNT	0			/* normal counter */
#define UVMCNT_DEV	1			/* device event counter */

struct uvm_cnt {
	int c;					/* the value */
	int t;					/* type */
	struct uvm_cnt *next;			/* global list of cnts */
	char *name;				/* counter name */
	void *p;				/* private data */
};

#ifdef _KERNEL

extern struct uvm_cnt *uvm_cnt_head;

/*
 * counter operations.  assume spl is set ok.
 */

#define UVMCNT_INIT(CNT,TYP,VAL,NAM,PRIV) \
do { \
	CNT.c = VAL; \
	CNT.t = TYP; \
	CNT.next = uvm_cnt_head; \
	uvm_cnt_head = &CNT; \
	CNT.name = NAM; \
	CNT.p = PRIV; \
} while (0)

#define UVMCNT_SET(C,V) \
do { \
	(C).c = (V); \
} while (0)

#define UVMCNT_ADD(C,V) \
do { \
	(C).c += (V); \
} while (0)

#define UVMCNT_INCR(C) UVMCNT_ADD(C,1)
#define UVMCNT_DECR(C) UVMCNT_ADD(C,-1)

#endif /* _KERNEL */

#endif /* _UVM_UVM_STAT_H_ */
@


1.16
log
@Rip out and burn support for UVM_HIST.

The vm hackers don't use it, don't maintain it and have to look at it all the
time. About time this 800 lines of code hit /dev/null.

``never liked it'' tedu@@. ariane@@ was very happy when i told her i wrote
this diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.15 2007/09/07 15:00:20 art Exp $	*/
@


1.15
log
@Use M_ZERO in a few more places to shave bytes from the kernel.

eyeballed and ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.14 2006/01/16 13:11:06 mickey Exp $	*/
a92 152

#endif /* _KERNEL */

/*
 * history/tracing
 */

struct uvm_history_ent {
	struct timeval tv; 		/* time stamp */
	char *fmt; 			/* printf format */
	size_t fmtlen;			/* length of printf format */
	char *fn;			/* function name */
	size_t fnlen;			/* length of function name */
	u_long call;			/* function call number */
	u_long v[4];			/* values */
};

struct uvm_history {
	const char *name;		/* name of this this history */
	size_t namelen;			/* length of name, not including null */
	LIST_ENTRY(uvm_history) list;	/* link on list of all histories */
	int n;				/* number of entries */
	int f; 				/* next free one */
	simple_lock_data_t l;		/* lock on this history */
	struct uvm_history_ent *e;	/* the malloc'd entries */
};

LIST_HEAD(uvm_history_head, uvm_history);

/*
 * grovelling lists all at once.  we currently do not allow more than
 * 32 histories to exist, as the way to dump a number of them at once
 * is by calling uvm_hist() with a bitmask.
 */

/* this is used to set the size of some arrays */
#define	MAXHISTS		32	/* do not change this! */

/* and these are the bit values of each history */
#define	UVMHIST_MAPHIST		0x00000001	/* maphist */
#define	UVMHIST_PDHIST		0x00000002	/* pdhist */
#define	UVMHIST_UBCHIST		0x00000004	/* ubchist */
#define	UVMHIST_PGHIST		0x00000008	/* pghist */

#ifdef _KERNEL

/*
 * macros to use the history/tracing code.  note that UVMHIST_LOG
 * must take 4 arguments (even if they are ignored by the format).
 */
#ifndef UVMHIST
#define UVMHIST_DECL(NAME)
#define UVMHIST_INIT(NAME,N)
#define UVMHIST_INIT_STATIC(NAME,BUF)
#define UVMHIST_LOG(NAME,FMT,A,B,C,D)
#define UVMHIST_CALLED(NAME)
#define UVMHIST_FUNC(FNAME)
#define uvmhist_dump(NAME)
#else
extern	struct uvm_history_head uvm_histories;

#define UVMHIST_DECL(NAME) struct uvm_history NAME

#define UVMHIST_INIT(NAME,N) \
do { \
	(NAME).name = __STRING(NAME); \
	(NAME).namelen = strlen((NAME).name); \
	(NAME).n = (N); \
	(NAME).f = 0; \
	simple_lock_init(&(NAME).l); \
	(NAME).e = (struct uvm_history_ent *) \
		malloc(sizeof(struct uvm_history_ent) * (N), M_TEMP, \
		    M_WAITOK|M_ZERO); \
	LIST_INSERT_HEAD(&uvm_histories, &(NAME), list); \
} while (0)

#define UVMHIST_INIT_STATIC(NAME,BUF) \
do { \
	(NAME).name = __STRING(NAME); \
	(NAME).namelen = strlen((NAME).name); \
	(NAME).n = sizeof(BUF) / sizeof(struct uvm_history_ent); \
	(NAME).f = 0; \
	simple_lock_init(&(NAME).l); \
	(NAME).e = (struct uvm_history_ent *) (BUF); \
	memset((NAME).e, 0, sizeof(struct uvm_history_ent) * (NAME).n); \
	LIST_INSERT_HEAD(&uvm_histories, &(NAME), list); \
} while (0)

#if defined(UVMHIST_PRINT)
extern int uvmhist_print_enabled;
#define UVMHIST_PRINTNOW(E) \
do { \
		if (uvmhist_print_enabled) { \
			uvmhist_print(E); \
			DELAY(100000); \
		} \
} while (0)
#else
#define UVMHIST_PRINTNOW(E) /* nothing */
#endif

#define UVMHIST_LOG(NAME,FMT,A,B,C,D) \
do { \
	int _i_, _s_ = splhigh(); \
	simple_lock(&(NAME).l); \
	_i_ = (NAME).f; \
	(NAME).f = (_i_ + 1) % (NAME).n; \
	simple_unlock(&(NAME).l); \
	splx(_s_); \
	if (!cold) \
		microtime(&(NAME).e[_i_].tv); \
	(NAME).e[_i_].fmt = (FMT); \
	(NAME).e[_i_].fmtlen = strlen((NAME).e[_i_].fmt); \
	(NAME).e[_i_].fn = _uvmhist_name; \
	(NAME).e[_i_].fnlen = strlen((NAME).e[_i_].fn); \
	(NAME).e[_i_].call = _uvmhist_call; \
	(NAME).e[_i_].v[0] = (u_long)(A); \
	(NAME).e[_i_].v[1] = (u_long)(B); \
	(NAME).e[_i_].v[2] = (u_long)(C); \
	(NAME).e[_i_].v[3] = (u_long)(D); \
	UVMHIST_PRINTNOW(&((NAME).e[_i_])); \
} while (0)

#define UVMHIST_CALLED(NAME) \
do { \
	{ \
		int s = splhigh(); \
		simple_lock(&(NAME).l); \
		_uvmhist_call = _uvmhist_cnt++; \
		simple_unlock(&(NAME).l); \
		splx(s); \
	} \
	UVMHIST_LOG(NAME,"called!", 0, 0, 0, 0); \
} while (0)

#define UVMHIST_FUNC(FNAME) \
	static int _uvmhist_cnt = 0; \
	static char *_uvmhist_name = FNAME; \
	int _uvmhist_call; 

static __inline void uvmhist_print(struct uvm_history_ent *);

static __inline void
uvmhist_print(e)
	struct uvm_history_ent *e;
{
	printf("%06ld.%06ld ", e->tv.tv_sec, e->tv.tv_usec);
	printf("%s#%ld: ", e->fn, e->call);
	printf(e->fmt, e->v[0], e->v[1], e->v[2], e->v[3]);
	printf("\n");
}
#endif /* UVMHIST */
@


1.14
log
@add another uvm histroy for physpage alloc/free and propagate a debugging pgfree check into pglist; no functional change for normal kernels; make histories uncommon
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.13 2002/03/14 01:27:19 millert Exp $	*/
d165 1
a165 2
		    M_WAITOK); \
	memset((NAME).e, 0, sizeof(struct uvm_history_ent) * (N)); \
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.12 2001/12/19 08:58:07 art Exp $	*/
d135 1
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.10 2001/11/12 01:26:10 art Exp $	*/
d233 1
a233 1
static __inline void uvmhist_print __P((struct uvm_history_ent *));
@


1.11
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_stat.h,v 1.22 2001/05/30 11:57:17 mrg Exp $	*/
a40 4
#if defined(_KERNEL_OPT)
#include "opt_uvmhist.h"
#endif

d116 1
a116 1
	struct simplelock l;		/* lock on this history */
d231 1
a231 1
	int _uvmhist_call;
@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.11 2001/11/28 19:28:15 art Exp $	*/
d237 1
a237 1
static __inline void uvmhist_print(struct uvm_history_ent *);
@


1.11.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_stat.h,v 1.11.2.1 2002/06/11 03:33:04 art Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.25 2002/11/02 07:40:49 perry Exp $	*/
d83 1
a83 1
} while (/*CONSTCOND*/ 0)
d88 1
a88 1
} while (/*CONSTCOND*/ 0)
d93 1
a93 1
} while (/*CONSTCOND*/ 0)
a154 2
#include <sys/kernel.h>		/* for "cold" variable */

d171 1
a171 1
} while (/*CONSTCOND*/ 0)
d183 1
a183 1
} while (/*CONSTCOND*/ 0)
d193 1
a193 1
} while (/*CONSTCOND*/ 0)
d218 1
a218 1
} while (/*CONSTCOND*/ 0)
d230 1
a230 1
} while (/*CONSTCOND*/ 0)
@


1.10
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_stat.h,v 1.9 2001/08/11 10:57:22 art Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.19 2001/02/04 10:55:58 mrg Exp $	*/
d41 4
d120 1
a120 1
	simple_lock_data_t l;		/* lock on this history */
d235 1
a235 1
	int _uvmhist_call; 
@


1.9
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_stat.h,v 1.8 2001/06/24 21:29:04 mickey Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.18 2000/04/11 08:12:14 pk Exp $	*/
d134 1
@


1.8
log
@cold is in systm now
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_stat.h,v 1.7 2001/03/09 05:34:38 smart Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.15 1999/06/21 17:25:12 thorpej Exp $	*/
d195 1
a195 1
	register int i, s = splhigh(); \
d197 2
a198 2
	i = (NAME).f; \
	(NAME).f = (i + 1) % (NAME).n; \
d200 1
a200 1
	splx(s); \
d202 11
a212 11
		microtime(&(NAME).e[i].tv); \
	(NAME).e[i].fmt = (FMT); \
	(NAME).e[i].fmtlen = strlen((NAME).e[i].fmt); \
	(NAME).e[i].fn = _uvmhist_name; \
	(NAME).e[i].fnlen = strlen((NAME).e[i].fn); \
	(NAME).e[i].call = _uvmhist_call; \
	(NAME).e[i].v[0] = (u_long)(A); \
	(NAME).e[i].v[1] = (u_long)(B); \
	(NAME).e[i].v[2] = (u_long)(C); \
	(NAME).e[i].v[3] = (u_long)(D); \
	UVMHIST_PRINTNOW(&((NAME).e[i])); \
@


1.7
log
@Protect protypes, certain macros, and inlines from userland.  Checked userland
with a 'make build'.  From NetBSD.  art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.6 2001/01/29 02:07:49 niklas Exp $	*/
a178 2

extern int cold;
@


1.6
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_stat.h,v 1.14 1999/03/25 18:48:56 mrg Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.14 1999/03/25 18:48:56 mrg Exp $	*/
d63 2
d94 1
d135 2
d246 2
@


1.5
log
@Convert bzero to memset(X, 0..) and bcopy to memcpy.
This is to match (make diffs smaller) the code in NetBSD.
new gcc inlines those functions, so this could also be a performance win.
@
text
@d1 1
@


1.4
log
@Fix the NetBSD id strings.
@
text
@d158 1
a158 1
	bzero((NAME).e, sizeof(struct uvm_history_ent) * (N)); \
d170 1
a170 1
	bzero((NAME).e, sizeof(struct uvm_history_ent) * (NAME).n); \
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_stat.h,v 1.13 1998/08/09 22:36:39 perry Exp $	*/
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_stat.h,v 1.14 1999/03/25 18:48:56 mrg Exp $	*/
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: uvm_stat.h,v 1.7 2001/03/09 05:34:38 smart Exp $	*/
/*	$NetBSD: uvm_stat.h,v 1.15 1999/06/21 17:25:12 thorpej Exp $	*/
a61 2
#ifdef _KERNEL

a90 1
#endif /* _KERNEL */
a130 2
#ifdef _KERNEL

d158 1
a158 1
	memset((NAME).e, 0, sizeof(struct uvm_history_ent) * (N)); \
d170 1
a170 1
	memset((NAME).e, 0, sizeof(struct uvm_history_ent) * (NAME).n); \
a239 2

#endif /* _KERNEL */
@


1.3.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_stat.h,v 1.3.4.2 2001/05/14 22:47:48 niklas Exp $	*/
d179 2
@


1.3.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_stat.h,v 1.18 2000/04/11 08:12:14 pk Exp $	*/
d195 1
a195 1
	int _i_, _s_ = splhigh(); \
d197 2
a198 2
	_i_ = (NAME).f; \
	(NAME).f = (_i_ + 1) % (NAME).n; \
d200 1
a200 1
	splx(_s_); \
d202 11
a212 11
		microtime(&(NAME).e[_i_].tv); \
	(NAME).e[_i_].fmt = (FMT); \
	(NAME).e[_i_].fmtlen = strlen((NAME).e[_i_].fmt); \
	(NAME).e[_i_].fn = _uvmhist_name; \
	(NAME).e[_i_].fnlen = strlen((NAME).e[_i_].fn); \
	(NAME).e[_i_].call = _uvmhist_call; \
	(NAME).e[_i_].v[0] = (u_long)(A); \
	(NAME).e[_i_].v[1] = (u_long)(B); \
	(NAME).e[_i_].v[2] = (u_long)(C); \
	(NAME).e[_i_].v[3] = (u_long)(D); \
	UVMHIST_PRINTNOW(&((NAME).e[_i_])); \
@


1.3.4.5
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_stat.h,v 1.19 2001/02/04 10:55:58 mrg Exp $	*/
a133 1
#define	UVMHIST_UBCHIST		0x00000004	/* ubchist */
@


1.3.4.6
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_stat.h,v 1.22 2001/05/30 11:57:17 mrg Exp $	*/
a40 4
#if defined(_KERNEL_OPT)
#include "opt_uvmhist.h"
#endif

d116 1
a116 1
	struct simplelock l;		/* lock on this history */
d231 1
a231 1
	int _uvmhist_call;
@


1.3.4.7
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_stat.h,v 1.19 2001/02/04 10:55:58 mrg Exp $	*/
d41 4
d120 1
a120 1
	simple_lock_data_t l;		/* lock on this history */
d235 1
a235 1
	int _uvmhist_call; 
@


1.3.4.8
log
@Merge in -current from roughly a week ago
@
text
@d233 1
a233 1
static __inline void uvmhist_print(struct uvm_history_ent *);
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

