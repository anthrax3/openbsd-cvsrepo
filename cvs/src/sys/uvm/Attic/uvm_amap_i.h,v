head	1.20;
access;
symbols
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.12.0.18
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.20
date	2009.03.25.20.00.18;	author oga;	state dead;
branches;
next	1.19;

1.19
date	2009.03.20.15.19.04;	author oga;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.18.21.51.15;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.31.21.20.30;	author thib;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.31.11.51.29;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.26.23.15.55;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.13.22.51.26;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.21.16.20.05;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.28.19.28.14;	author art;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.11.07.02.55.50;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.18.10.47.05;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.10.14.51.21;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.22.03.05.54;	author smart;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.29.02.07.42;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.07.20.15.28;	author art;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.15.50.18;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.22;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.06;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.11;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.48;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.44;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.07.04.11.01.00;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2001.12.05.01.19.55;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.11.04.18.02.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Move all of the pseudo-inline functions in uvm into C files.

By pseudo-inline, I mean that if a certain macro was defined, they would
be inlined. However, no architecture defines that, and none has for a
very very long time. Therefore mainly this just makes the code a damned
sight easier to read. Some k&r -> ansi declarations while I'm in there.

"just commit it" art@@. ok weingart@@.
@
text
@/*	$OpenBSD: uvm_amap_i.h,v 1.19 2009/03/20 15:19:04 oga Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.15 2000/11/25 06:27:59 chs Exp $	*/

/*
 *
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_amap_i.h,v 1.1.2.4 1998/01/05 18:12:57 chuck Exp
 */

#ifndef _UVM_UVM_AMAP_I_H_
#define _UVM_UVM_AMAP_I_H_

/*
 * uvm_amap_i.h
 */

/*
 * if inlines are enabled always pull in these functions, otherwise
 * pull them in only once (when we are compiling uvm_amap.c).
 */

#if defined(UVM_AMAP_INLINE) || defined(UVM_AMAP_C)

/*
 * amap_lookup: look up a page in an amap
 *
 * => amap should be locked by caller.
 */
AMAP_INLINE struct vm_anon *
amap_lookup(struct vm_aref *aref, vaddr_t offset)
{
	int slot;
	struct vm_amap *amap = aref->ar_amap;
	UVMHIST_FUNC("amap_lookup"); UVMHIST_CALLED(maphist);

	AMAP_B2SLOT(slot, offset);
	slot += aref->ar_pageoff;

	if (slot >= amap->am_nslot)
		panic("amap_lookup: offset out of range");

	UVMHIST_LOG(maphist, "<- done (amap=%p, offset=0x%lx, result=%p)",
	    amap, offset, amap->am_anon[slot], 0);
	return(amap->am_anon[slot]);
}

/*
 * amap_lookups: look up a range of pages in an amap
 *
 * => amap should be locked by caller.
 * => XXXCDC: this interface is biased toward array-based amaps.  fix.
 */
AMAP_INLINE void
amap_lookups(struct vm_aref *aref, vaddr_t offset,
    struct vm_anon **anons, int npages)
{
	int slot;
	struct vm_amap *amap = aref->ar_amap;
	UVMHIST_FUNC("amap_lookups"); UVMHIST_CALLED(maphist);

	AMAP_B2SLOT(slot, offset);
	slot += aref->ar_pageoff;

	UVMHIST_LOG(maphist, "  slot=%ld, npages=%ld, nslot=%ld", slot, npages,
		amap->am_nslot, 0);

	if ((slot + (npages - 1)) >= amap->am_nslot)
		panic("amap_lookups: offset out of range");

	memcpy(anons, &amap->am_anon[slot], npages * sizeof(struct vm_anon *));

	UVMHIST_LOG(maphist, "<- done", 0, 0, 0, 0);
	return;
}

/*
 * amap_add: add (or replace) a page to an amap
 *
 * => caller must lock amap.   
 * => if (replace) caller must lock anon because we might have to call
 *	pmap_page_protect on the anon's page.
 * => returns an "offset" which is meaningful to amap_unadd().
 */
AMAP_INLINE void
amap_add(struct vm_aref *aref, vaddr_t offset, struct vm_anon *anon,
    boolean_t replace)
{
	int slot;
	struct vm_amap *amap = aref->ar_amap;
	UVMHIST_FUNC("amap_add"); UVMHIST_CALLED(maphist);

	AMAP_B2SLOT(slot, offset);
	slot += aref->ar_pageoff;

	if (slot >= amap->am_nslot)
		panic("amap_add: offset out of range");

	if (replace) {

		if (amap->am_anon[slot] == NULL)
			panic("amap_add: replacing null anon");
		if (amap->am_anon[slot]->an_page != NULL && 
		    (amap->am_flags & AMAP_SHARED) != 0) {
			pmap_page_protect(amap->am_anon[slot]->an_page,
			    VM_PROT_NONE);
			/*
			 * XXX: suppose page is supposed to be wired somewhere?
			 */
		}
	} else {   /* !replace */
		if (amap->am_anon[slot] != NULL)
			panic("amap_add: slot in use");

		amap->am_bckptr[slot] = amap->am_nused;
		amap->am_slots[amap->am_nused] = slot;
		amap->am_nused++;
	}
	amap->am_anon[slot] = anon;
	UVMHIST_LOG(maphist,
	    "<- done (amap=%p, offset=0x%lx, anon=%p, rep=%ld)",
	    amap, offset, anon, replace);
}

/*
 * amap_unadd: remove a page from an amap
 *
 * => caller must lock amap
 */
AMAP_INLINE void
amap_unadd(struct vm_aref *aref, vaddr_t offset)
{
	int ptr, slot;
	struct vm_amap *amap = aref->ar_amap;
	UVMHIST_FUNC("amap_unadd"); UVMHIST_CALLED(maphist);

	AMAP_B2SLOT(slot, offset);
	slot += aref->ar_pageoff;

	if (slot >= amap->am_nslot)
		panic("amap_unadd: offset out of range");

	if (amap->am_anon[slot] == NULL)
		panic("amap_unadd: nothing there");

	amap->am_anon[slot] = NULL;
	ptr = amap->am_bckptr[slot];

	if (ptr != (amap->am_nused - 1)) {	/* swap to keep slots contig? */
		amap->am_slots[ptr] = amap->am_slots[amap->am_nused - 1];
		amap->am_bckptr[amap->am_slots[ptr]] = ptr;	/* back link */
	}
	amap->am_nused--;
	UVMHIST_LOG(maphist, "<- done (amap=%p, slot=%ld)", amap, slot,0, 0);
}

/*
 * amap_ref: gain a reference to an amap
 *
 * => amap must not be locked (we will lock)
 * => "offset" and "len" are in units of pages
 * => called at fork time to gain the child's reference
 */
AMAP_INLINE void
amap_ref(struct vm_amap *amap, vaddr_t offset, vsize_t len, int flags)
{
	UVMHIST_FUNC("amap_ref"); UVMHIST_CALLED(maphist);

	amap->am_ref++;
	if (flags & AMAP_SHARED)
		amap->am_flags |= AMAP_SHARED;
#ifdef UVM_AMAP_PPREF
	if (amap->am_ppref == NULL && (flags & AMAP_REFALL) == 0 &&
	    len != amap->am_nslot)
		amap_pp_establish(amap);
	if (amap->am_ppref && amap->am_ppref != PPREF_NONE) {
		if (flags & AMAP_REFALL)
			amap_pp_adjref(amap, 0, amap->am_nslot, 1);
		else
			amap_pp_adjref(amap, offset, len, 1);
	}
#endif
	UVMHIST_LOG(maphist,"<- done!  amap=%p", amap, 0, 0, 0);
}

/*
 * amap_unref: remove a reference to an amap
 *
 * => caller must remove all pmap-level references to this amap before
 *	dropping the reference
 * => called from uvm_unmap_detach [only]  ... note that entry is no
 *	longer part of a map and thus has no need for locking
 * => amap must be unlocked (we will lock it).
 */
AMAP_INLINE void
amap_unref(struct vm_amap *amap, vaddr_t offset, vsize_t len, boolean_t all)
{
	UVMHIST_FUNC("amap_unref"); UVMHIST_CALLED(maphist);

	UVMHIST_LOG(maphist,"  amap=%p  refs=%ld, nused=%ld",
	    amap, amap->am_ref, amap->am_nused, 0);

	/*
	 * if we are the last reference, free the amap and return.
	 */

	if (amap->am_ref-- == 1) {
		amap_wipeout(amap);	/* drops final ref and frees */
		UVMHIST_LOG(maphist,"<- done (was last ref)!", 0, 0, 0, 0);
		return;			/* no need to unlock */
	}

	/*
	 * otherwise just drop the reference count(s)
	 */
	if (amap->am_ref == 1 && (amap->am_flags & AMAP_SHARED) != 0)
		amap->am_flags &= ~AMAP_SHARED;	/* clear shared flag */
#ifdef UVM_AMAP_PPREF
	if (amap->am_ppref == NULL && all == 0 && len != amap->am_nslot)
		amap_pp_establish(amap);
	if (amap->am_ppref && amap->am_ppref != PPREF_NONE) {
		if (all)
			amap_pp_adjref(amap, 0, amap->am_nslot, -1);
		else
			amap_pp_adjref(amap, offset, len, -1);
	}
#endif

	UVMHIST_LOG(maphist,"<- done!", 0, 0, 0, 0);
}

#endif /* defined(UVM_AMAP_INLINE) || defined(UVM_AMAP_C) */

#endif /* _UVM_UVM_AMAP_I_H_ */
@


1.19
log
@While working on some stuff in uvm I've gotten REALLY sick of reading
K&R function declarations, so switch them all over to ansi-style, in
accordance with the prophesy.

"go for it" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.18 2007/06/18 21:51:15 pedro Exp $	*/
@


1.18
log
@Bring back Mickey's UVM anon change. Testing by thib@@, beck@@ and
ckuethe@@ for a while. Okay beck@@, "it is good timing" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.17 2007/05/31 21:20:30 thib Exp $	*/
d58 1
a58 3
amap_lookup(aref, offset)
	struct vm_aref *aref;
	vaddr_t offset;
d82 2
a83 5
amap_lookups(aref, offset, anons, npages)
	struct vm_aref *aref;
	vaddr_t offset;
	struct vm_anon **anons;
	int npages;
d113 2
a114 5
amap_add(aref, offset, anon, replace)
	struct vm_aref *aref;
	vaddr_t offset;
	struct vm_anon *anon;
	boolean_t replace;
d158 1
a158 3
amap_unadd(aref, offset)
	struct vm_aref *aref;
	vaddr_t offset;
d192 1
a192 5
amap_ref(amap, offset, len, flags)
	struct vm_amap *amap;
	vaddr_t offset;
	vsize_t len;
	int flags;
d223 1
a223 5
amap_unref(amap, offset, len, all)
	struct vm_amap *amap;
	vaddr_t offset;
	vsize_t len;
	boolean_t all;
@


1.17
log
@zap the vm_amap am_l simplelock, and amap_{lock/unlock} macros for
simple_{lock/unlock}.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.16 2006/07/31 11:51:29 mickey Exp $	*/
d138 1
a138 1
		if (amap->am_anon[slot]->u.an_page != NULL && 
d140 1
a140 1
			pmap_page_protect(amap->am_anon[slot]->u.an_page,
d252 1
a252 1
	if (amap->am_ref == 1) {
a260 2

	amap->am_ref--;
@


1.16
log
@fix uvmhist #2: args are always u_long so fix missing %d and %x and no %ll; no change for normal code
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.15 2006/07/26 23:15:55 mickey Exp $	*/
a209 1
	amap_lock(amap);
a223 1
	amap_unlock(amap);
a244 4
	/*
	 * lock it
	 */
	amap_lock(amap);
a274 1
	amap_unlock(amap);
@


1.15
log
@fix fmts for UVMHIST_LOG() entries making it more useful on 64bit archs; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.14 2006/07/13 22:51:26 deraadt Exp $	*/
d97 1
a97 1
	UVMHIST_LOG(maphist, "  slot=%d, npages=%d, nslot=%d", slot, npages,
d156 1
a156 1
	    "<- done (amap=%p, offset=0x%lx, anon=%p, rep=%d)",
d191 1
a191 1
	UVMHIST_LOG(maphist, "<- done (amap=%p, slot=%d)", amap, slot,0, 0);
d251 1
a251 1
	UVMHIST_LOG(maphist,"  amap=%p  refs=%d, nused=%d",
@


1.14
log
@Back out the anon change.  Apparently it was tested by a few, but most of
us did not see it or get a chance to test it before it was commited. It
broke cvs, in the ami driver, making it not succeed at seeing it's devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.12 2001/12/19 08:58:07 art Exp $	*/
d72 1
a72 1
	UVMHIST_LOG(maphist, "<- done (amap=0x%x, offset=0x%x, result=0x%x)",
d156 1
a156 1
	    "<- done (amap=0x%x, offset=0x%x, anon=0x%x, rep=%d)",
d191 1
a191 1
	UVMHIST_LOG(maphist, "<- done (amap=0x%x, slot=0x%x)", amap, slot,0, 0);
d226 1
a226 1
	UVMHIST_LOG(maphist,"<- done!  amap=0x%x", amap, 0, 0, 0);
d251 1
a251 1
	UVMHIST_LOG(maphist,"  amap=0x%x  refs=%d, nused=%d",
@


1.13
log
@from netbsd: make anons dynamically allocated from pool.
this results in lesse kva waste due to static preallocation of those
for every phys page and also every swap page.
tested by beck krw miod
@
text
@d138 1
a138 1
		if (amap->am_anon[slot]->an_page != NULL && 
d140 1
a140 1
			pmap_page_protect(amap->am_anon[slot]->an_page,
d258 1
a258 1
	if (amap->am_ref-- == 1) {
d267 2
@


1.12
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.10 2001/11/07 02:55:50 art Exp $	*/
d138 1
a138 1
		if (amap->am_anon[slot]->u.an_page != NULL && 
d140 1
a140 1
			pmap_page_protect(amap->am_anon[slot]->u.an_page,
d258 1
a258 1
	if (amap->am_ref == 1) {
a266 2

	amap->am_ref--;
@


1.11
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_amap_i.h,v 1.17 2001/05/25 04:06:11 chs Exp $	*/
d112 1
a112 1
 * => caller must lock amap.
d115 1
d138 1
a138 1
		if (amap->am_anon[slot]->u.an_page != NULL &&
@


1.11.2.1
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.11 2001/11/28 19:28:14 art Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.18 2002/08/22 23:39:37 matt Exp $	*/
d210 1
a216 3
#endif
	amap->am_ref++;
#ifdef UVM_AMAP_PPREF
@


1.10
log
@Another sync of uvm to NetBSD. Just minor fiddling, no major changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.9 2001/07/18 10:47:05 art Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.15 2000/11/25 06:27:59 chs Exp $	*/
d112 1
a112 1
 * => caller must lock amap.   
a114 1
 * => returns an "offset" which is meaningful to amap_unadd().
d137 1
a137 1
		if (amap->am_anon[slot]->u.an_page != NULL && 
@


1.9
log
@Get rid of the PMAP_NEW option by making it mandatory for all archs.
The archs that didn't have a proper PMAP_NEW now have a dummy implementation
with wrappers around the old functions.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.8 2001/05/10 14:51:21 art Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.14 1999/09/12 01:17:34 chs Exp $	*/
d122 1
a122 1
	int replace;
d198 1
d202 4
a205 2
amap_ref(entry, flags)
	vm_map_entry_t entry;
a207 1
	struct vm_amap *amap = entry->aref.ar_amap;
d216 1
a216 1
	    (entry->start - entry->end) >> PAGE_SHIFT != amap->am_nslot)
d220 1
a220 1
			amap_pp_adjref(amap, 0, amap->am_nslot << PAGE_SHIFT, 1);
d222 1
a222 2
			amap_pp_adjref(amap, entry->aref.ar_pageoff, 
			 	entry->end - entry->start, 1);
d239 5
a243 3
amap_unref(entry, all)
	vm_map_entry_t entry;
	int all;
a244 1
	struct vm_amap *amap = entry->aref.ar_amap;
d251 2
a252 3

	UVMHIST_LOG(maphist,"(entry=0x%x)  amap=0x%x  refs=%d, nused=%d",
	    entry, amap, amap->am_ref, amap->am_nused);
d272 1
a272 2
	if (amap->am_ppref == NULL && all == 0 &&
	    (entry->start - entry->end) >> PAGE_SHIFT != amap->am_nslot)
d276 1
a276 1
			amap_pp_adjref(amap, 0, amap->am_nslot << PAGE_SHIFT, -1);
d278 1
a278 2
			amap_pp_adjref(amap, entry->aref.ar_pageoff, 
			    entry->end - entry->start, -1);
@


1.8
log
@More sync to NetBSD.
The highlight is some more advices to madvise(2).
 o MADV_DONTNEED will deactive the pages in the given range giving a quicker
   reuse.
 o MADV_FREE will garbage-collect the pages and swap resources causing the
   next fault to either page in new pages from backing store (mapped vnode)
   or allocate new zero-fill pages (anonymous mapping).
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.7 2001/03/22 03:05:54 smart Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.13 1999/07/07 05:31:40 thorpej Exp $	*/
d140 1
a140 2
			pmap_page_protect(
			    PMAP_PGARG(amap->am_anon[slot]->u.an_page),
@


1.7
log
@Sync style, typo, and comments a little closer to NetBSD.  art@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.6 2001/01/29 02:07:42 niklas Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.12 1999/03/25 18:48:49 mrg Exp $	*/
d117 1
a117 1
AMAP_INLINE vaddr_t
a158 2

	return(slot);
d162 1
a162 1
 * amap_unadd: remove a page from an amap, given we know the slot #.
d167 3
a169 3
amap_unadd(amap, slot)
	struct vm_amap *amap;
	vaddr_t slot;
d171 2
a172 1
	int ptr;
d174 3
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_amap_i.h,v 1.12 1999/03/25 18:48:49 mrg Exp $	*/
d177 1
a177 1
		panic("amap_add: offset out of range");
@


1.5
log
@Convert bzero to memset(X, 0..) and bcopy to memcpy.
This is to match (make diffs smaller) the code in NetBSD.
new gcc inlines those functions, so this could also be a performance win.
@
text
@d1 1
@


1.4
log
@Fix the NetBSD id strings.
@
text
@d102 1
a102 1
	bcopy(&amap->am_anon[slot], anons, npages * sizeof(struct vm_anon *));
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_amap_i.h,v 1.11 1999/01/28 14:46:27 chuck Exp $	*/
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_amap_i.h,v 1.12 1999/03/25 18:48:49 mrg Exp $	*/
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_amap_i.h,v 1.7 2001/03/22 03:05:54 smart Exp $	*/
d102 1
a102 1
	memcpy(anons, &amap->am_anon[slot], npages * sizeof(struct vm_anon *));
d176 1
a176 1
		panic("amap_unadd: offset out of range");
@


1.3.4.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_amap_i.h,v 1.13 1999/07/07 05:31:40 thorpej Exp $	*/
d117 1
a117 1
AMAP_INLINE void
d159 2
d164 1
a164 1
 * amap_unadd: remove a page from an amap
d169 3
a171 3
amap_unadd(aref, offset)
	struct vm_aref *aref;
	vaddr_t offset;
d173 1
a173 2
	int ptr, slot;
	struct vm_amap *amap = aref->ar_amap;
a174 3

	AMAP_B2SLOT(slot, offset);
	slot += aref->ar_pageoff;
@


1.3.4.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_amap_i.h,v 1.3.4.3 2001/07/04 11:01:00 niklas Exp $	*/
/*	$NetBSD: uvm_amap_i.h,v 1.14 1999/09/12 01:17:34 chs Exp $	*/
d140 2
a141 1
			pmap_page_protect(amap->am_anon[slot]->u.an_page,
@


1.3.4.5
log
@merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_amap_i.h,v 1.15 2000/11/25 06:27:59 chs Exp $	*/
d122 1
a122 1
	boolean_t replace;
a197 1
 * => "offset" and "len" are in units of pages
d201 2
a202 4
amap_ref(amap, offset, len, flags)
	struct vm_amap *amap;
	vaddr_t offset;
	vsize_t len;
d205 1
d214 1
a214 1
	    len != amap->am_nslot)
d218 1
a218 1
			amap_pp_adjref(amap, 0, amap->am_nslot, 1);
d220 2
a221 1
			amap_pp_adjref(amap, offset, len, 1);
d238 3
a240 5
amap_unref(amap, offset, len, all)
	struct vm_amap *amap;
	vaddr_t offset;
	vsize_t len;
	boolean_t all;
d242 1
d249 3
a251 2
	UVMHIST_LOG(maphist,"  amap=0x%x  refs=%d, nused=%d",
	    amap, amap->am_ref, amap->am_nused, 0);
d271 2
a272 1
	if (amap->am_ppref == NULL && all == 0 && len != amap->am_nslot)
d276 1
a276 1
			amap_pp_adjref(amap, 0, amap->am_nslot, -1);
d278 2
a279 1
			amap_pp_adjref(amap, offset, len, -1);
@


1.3.4.6
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_amap_i.h,v 1.17 2001/05/25 04:06:11 chs Exp $	*/
d112 1
a112 1
 * => caller must lock amap.
d115 1
d138 1
a138 1
		if (amap->am_anon[slot]->u.an_page != NULL &&
@


1.3.4.7
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_amap_i.h,v 1.15 2000/11/25 06:27:59 chs Exp $	*/
d112 1
a112 1
 * => caller must lock amap.   
a114 1
 * => returns an "offset" which is meaningful to amap_unadd().
d137 1
a137 1
		if (amap->am_anon[slot]->u.an_page != NULL && 
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

