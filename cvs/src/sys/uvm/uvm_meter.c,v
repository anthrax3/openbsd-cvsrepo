head	1.37;
access;
symbols
	OPENBSD_6_2:1.37.0.4
	OPENBSD_6_2_BASE:1.37
	OPENBSD_6_1:1.36.0.10
	OPENBSD_6_1_BASE:1.36
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.2
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.30.0.6
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.2
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.29.0.12
	OPENBSD_5_3_BASE:1.29
	OPENBSD_5_2:1.29.0.10
	OPENBSD_5_2_BASE:1.29
	OPENBSD_5_1_BASE:1.29
	OPENBSD_5_1:1.29.0.8
	OPENBSD_5_0:1.29.0.6
	OPENBSD_5_0_BASE:1.29
	OPENBSD_4_9:1.29.0.4
	OPENBSD_4_9_BASE:1.29
	OPENBSD_4_8:1.29.0.2
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.28.0.4
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.24.0.6
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.20.0.10
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.8
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.6
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.4
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.20.0.2
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.10
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.4.0.2
	SMP_BASE:1.4
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2017.05.09.09.36.04;	author mpi;	state Exp;
branches;
next	1.36;
commitid	vSAZkZz1YWOfLCqU;

1.36
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2015.01.20.19.43.21;	author kettenis;	state Exp;
branches;
next	1.34;
commitid	Fn841MmVYz2JHvBP;

1.34
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.33;
commitid	7NtJNW9udCOFtDNM;

1.33
date	2014.07.08.13.19.16;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	7feeN59qH7ny9fm9;

1.32
date	2014.05.06.11.50.14;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.13.23.14.15;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2013.03.23.16.12.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.07.22.17.31.39;	author thib;	state Exp;
branches;
next	1.28;

1.28
date	2009.06.17.00.13.59;	author oga;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.08.13.50.15;	author ariane;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.23.13.25.11;	author art;	state Exp;
branches;
next	1.25;

1.25
date	2009.03.20.15.19.04;	author oga;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.15.03.42.57;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.10.15.53.53;	author art;	state Exp;
branches;
next	1.22;

1.22
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.29.12.24.18;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.21.23.50.38;	author tholo;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.13.21.49.29;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.17.13.08.42;	author pedro;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.27.18;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.28.19.28.15;	author art;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.11.12.01.26.09;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.07.02.55.50;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.01.35.04;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.02.11.06.38;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.23.19.24.34;	author smart;	state Exp;
branches;
next	1.9;

1.9
date	2001.01.29.02.07.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.07.20.15.28;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.14.16.51.55;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.18.20.51.32;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.15.15.50.20;	author art;	state Exp;
branches;
next	1.4;

1.4
date	99.12.30.18.21.55;	author provos;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.08.23.08.13.24;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.02.26.05.32.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.15;	author art;	state Exp;
branches;
next	;

1.4.2.1
date	2000.03.24.09.09.50;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.14.22.47.47;	author niklas;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.07.04.11.01.06;	author niklas;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2002.03.28.14.54.26;	author niklas;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2004.06.05.23.13.13;	author niklas;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2004.06.11.19.03.23;	author drahn;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2004.06.11.19.06.40;	author drahn;	state Exp;
branches;
next	;

1.16.2.1
date	2002.02.02.03.28.27;	author art;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.06.11.03.33.03;	author art;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Stop considering some sleeping threads are running.

PZERO used to be a special value in the first BSD releases but since
the introduction of tsleep(9) there's no way to tell if a thread is
going to sleep for a "short" period of time.

This remove the only (ab)use of ``p_priority'' outside the scheuler
logic, which will help moving avway from a priority-based scheduler.

ok visa@@
@
text
@/*	$OpenBSD: uvm_meter.c,v 1.36 2015/03/14 03:38:53 jsg Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.21 2001/07/14 06:36:03 matt Exp $	*/

/*
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * Copyright (c) 1982, 1986, 1989, 1993
 *      The Regents of the University of California.
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *      @@(#)vm_meter.c  8.4 (Berkeley) 1/4/94
 * from: Id: uvm_meter.c,v 1.1.2.1 1997/08/14 19:10:35 chuck Exp
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/sysctl.h>
#include <sys/vmmeter.h>
#include <uvm/uvm.h>

#ifdef UVM_SWAP_ENCRYPT
#include <uvm/uvm_swap.h>
#include <uvm/uvm_swap_encrypt.h>
#endif

/*
 * The time for a process to be blocked before being very swappable.
 * This is a number of seconds which the system takes as being a non-trivial
 * amount of real time.  You probably shouldn't change this;
 * it is used in subtle ways (fractions and multiples of it are, that is, like
 * half of a ``long time'', almost a long time, etc.)
 * It is related to human patience and other factors which don't really
 * change over time.
 */
#define	MAXSLP	20

int maxslp = MAXSLP;	/* patchable ... */
struct loadavg averunnable;

/*
 * constants for averages over 1, 5, and 15 minutes when sampling at
 * 5 second intervals.
 */

static fixpt_t cexp[3] = {
	0.9200444146293232 * FSCALE,	/* exp(-1/12) */
	0.9834714538216174 * FSCALE,	/* exp(-1/60) */
	0.9944598480048967 * FSCALE,	/* exp(-1/180) */
};


static void uvm_loadav(struct loadavg *);
void uvm_total(struct vmtotal *);

/*
 * uvm_meter: calculate load average and wake up the swapper (if needed)
 */
void
uvm_meter(void)
{
	if ((time_second % 5) == 0)
		uvm_loadav(&averunnable);
	if (proc0.p_slptime > (maxslp / 2))
		wakeup(&proc0);
}

/*
 * uvm_loadav: compute a tenex style load average of a quantity on
 * 1, 5, and 15 minute intervals.
 */
static void
uvm_loadav(struct loadavg *avg)
{
	CPU_INFO_ITERATOR cii;
	struct cpu_info *ci;
	int i, nrun;
	struct proc *p;
	int nrun_cpu[MAXCPUS];

	nrun = 0;
	memset(nrun_cpu, 0, sizeof(nrun_cpu));

	LIST_FOREACH(p, &allproc, p_list) {
		switch (p->p_stat) {
		case SSTOP:
		case SSLEEP:
			break;
		case SRUN:
		case SONPROC:
			if (p == p->p_cpu->ci_schedstate.spc_idleproc)
				continue;
		/* FALLTHROUGH */
		case SIDL:
			nrun++;
			if (p->p_cpu)
				nrun_cpu[CPU_INFO_UNIT(p->p_cpu)]++;
		}
	}

	for (i = 0; i < 3; i++) {
		avg->ldavg[i] = (cexp[i] * avg->ldavg[i] +
		    nrun * FSCALE * (FSCALE - cexp[i])) >> FSHIFT;
	}

	CPU_INFO_FOREACH(cii, ci) {
		struct schedstate_percpu *spc = &ci->ci_schedstate;

		if (nrun_cpu[CPU_INFO_UNIT(ci)] == 0)
			continue;
		spc->spc_ldavg = (cexp[0] * spc->spc_ldavg +
		    nrun_cpu[CPU_INFO_UNIT(ci)] * FSCALE *
		    (FSCALE - cexp[0])) >> FSHIFT;
	}
}

/*
 * uvm_sysctl: sysctl hook into UVM system.
 */
int
uvm_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen, struct proc *p)
{
	struct process *pr = p->p_p;
	struct vmtotal vmtotals;
	int rv, t;

	switch (name[0]) {
	case VM_SWAPENCRYPT:
#ifdef UVM_SWAP_ENCRYPT
		return (swap_encrypt_ctl(name + 1, namelen - 1, oldp, oldlenp,
					 newp, newlen, p));
#else
		return (EOPNOTSUPP);
#endif
	default:
		/* all sysctl names at this level are terminal */
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
		break;
	}

	switch (name[0]) {
	case VM_LOADAVG:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &averunnable,
		    sizeof(averunnable)));

	case VM_METER:
		uvm_total(&vmtotals);
		return (sysctl_rdstruct(oldp, oldlenp, newp, &vmtotals,
		    sizeof(vmtotals)));

	case VM_UVMEXP:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &uvmexp,
		    sizeof(uvmexp)));

	case VM_NKMEMPAGES:
		return (sysctl_rdint(oldp, oldlenp, newp, nkmempages));

	case VM_PSSTRINGS:
		return (sysctl_rdstruct(oldp, oldlenp, newp, &pr->ps_strings,
		    sizeof(pr->ps_strings)));

	case VM_ANONMIN:
		t = uvmexp.anonminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (t + uvmexp.vtextminpct + uvmexp.vnodeminpct > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.anonminpct = t;
		uvmexp.anonmin = t * 256 / 100;
		return rv;

	case VM_VTEXTMIN:
		t = uvmexp.vtextminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (uvmexp.anonminpct + t + uvmexp.vnodeminpct > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.vtextminpct = t;
		uvmexp.vtextmin = t * 256 / 100;
		return rv;

	case VM_VNODEMIN:
		t = uvmexp.vnodeminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (uvmexp.anonminpct + uvmexp.vtextminpct + t > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.vnodeminpct = t;
		uvmexp.vnodemin = t * 256 / 100;
		return rv;

	case VM_MAXSLP:
		return (sysctl_rdint(oldp, oldlenp, newp, maxslp));

	case VM_USPACE:
		return (sysctl_rdint(oldp, oldlenp, newp, USPACE));

	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

/*
 * uvm_total: calculate the current state of the system.
 */
void
uvm_total(struct vmtotal *totalp)
{
	struct proc *p;
#if 0
	struct vm_map_entry *	entry;
	struct vm_map *map;
	int paging;
#endif

	memset(totalp, 0, sizeof *totalp);

	/* calculate process statistics */
	LIST_FOREACH(p, &allproc, p_list) {
		switch (p->p_stat) {
		case 0:
			continue;

		case SSLEEP:
		case SSTOP:
			totalp->t_sl++;
			break;
		case SRUN:
		case SONPROC:
			if (p == p->p_cpu->ci_schedstate.spc_idleproc)
				continue;
		case SIDL:
			totalp->t_rq++;
			if (p->p_stat == SIDL)
				continue;
			break;
		}
		/*
		 * note active objects
		 */
#if 0
		/*
		 * XXXCDC: BOGUS!  rethink this.   in the mean time
		 * don't do it.
		 */
		paging = 0;
		vm_map_lock(map);
		for (map = &p->p_vmspace->vm_map, entry = map->header.next;
		    entry != &map->header; entry = entry->next) {
			if (entry->is_a_map || entry->is_sub_map ||
			    entry->object.uvm_obj == NULL)
				continue;
			/* XXX how to do this with uvm */
		}
		vm_map_unlock(map);
		if (paging)
			totalp->t_pw++;
#endif
	}
	/*
	 * Calculate object memory usage statistics.
	 */
	totalp->t_free = uvmexp.free;
	totalp->t_vm = uvmexp.npages - uvmexp.free + uvmexp.swpginuse;
	totalp->t_avm = uvmexp.active + uvmexp.swpginuse;	/* XXX */
	totalp->t_rm = uvmexp.npages - uvmexp.free;
	totalp->t_arm = uvmexp.active;
	totalp->t_vmshr = 0;		/* XXX */
	totalp->t_avmshr = 0;		/* XXX */
	totalp->t_rmshr = 0;		/* XXX */
	totalp->t_armshr = 0;		/* XXX */
}
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.35 2015/01/20 19:43:21 kettenis Exp $	*/
d111 1
d113 1
a113 3
			if (p->p_priority > PZERO || p->p_slptime > 1)
				continue;
		/* FALLTHROUGH */
d118 1
d139 1
a139 1
	}		
a256 2
		if (p->p_flag & P_SYSTEM)
			continue;
d263 1
a263 6
			if (p->p_priority <= PZERO)
				totalp->t_dw++;
			else if (p->p_slptime < maxslp)
				totalp->t_sl++;
			if (p->p_slptime >= maxslp)
				continue;
d266 3
a269 1
		case SONPROC:
@


1.35
log
@Move ps_strings "after" the random stackgap.  This makes its location a
per-process value, and therefpore turns the VM_PSSTRINGS sysctl into a
per-process one as well.  This gets rid of a pointer to the bottom of the
stack at a fixed location.  Also clears the road for unmapping the stackgap.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.34 2014/07/11 16:35:40 jsg Exp $	*/
a44 1
#include <sys/exec.h>
@


1.34
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.33 2014/07/08 13:19:16 deraadt Exp $	*/
d150 1
a152 1
	struct _ps_strings _ps = { PS_STRINGS };
d187 3
a189 2
		return (sysctl_rdstruct(oldp, oldlenp, newp, &_ps,
		    sizeof(_ps)));
@


1.33
log
@rearrange some includes.  also, pull in uvm/uvm.h because soon sysctl.h
won't be pulling in the uvm side of the kitchen.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.32 2014/05/06 11:50:14 mpi Exp $	*/
d19 1
a19 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor,
 *      Washington University, and the University of California, Berkeley
 *      and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@Include <sys/vmmeter.h> directly instead of relying on it being
pulled by <uvm/uvm_extern.h> and turn uvm_total() into a private
function.

The preferred way to get memory stats is through the VM_UVMEXP
sysctl(3) since VM_METER is just a wrapper on top of it.  In the
kernel, use `uvmexp' directly instead of uvm_total().

This change does not remove <sys/vmmeter.h> from <uvm/uvm_extern.h>
to give some more time to port maintainers to fix their ports.

ok guenther@@ as part of a larger diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.31 2014/04/13 23:14:15 tedu Exp $	*/
a44 1
#include <sys/proc.h>
d47 2
a49 1
#include <sys/sysctl.h>
d51 1
@


1.31
log
@compress code by turning four line comments into one line comments.
emphatic ok usual suspects, grudging ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.30 2013/03/23 16:12:31 deraadt Exp $	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
d82 1
a82 3
/*
 * prototypes
 */
d84 1
@


1.30
log
@refactor sys/param.h and machine/param.h.  A lot of #ifdef _KERNEL is added
to keep definitions our of user space.  The MD files now follow a consistant
order -- all namespace intrusion is at the tail can be cleaned up
independently.  locore, bootblocks, and libkvm still see enough visibility to
build.  Checked on 90% of platforms...
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.29 2010/07/22 17:31:39 thib Exp $	*/
a84 1

d260 1
a260 4
	/*
	 * calculate process statistics
	 */

a276 1

@


1.29
log
@Remove the VM_KMPAGESFREE sysctl. After the pmemrange
changes it was returing a constant 0, changing to cope
with those changes makes less sense then just removing
as it provides the user with no usefull information.

sthen@@ grepped the port's tree for me and found not hits,
thanks!

OK deraadt@@, matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.28 2009/06/17 00:13:59 oga Exp $	*/
d58 7
a64 1
 * maxslp: ???? XXXCDC
d66 1
@


1.28
log
@date based reversion of uvm to the 4th May.

More backouts in line with previous ones, this appears to bring us back to a
stable condition.

A machine forced to 64mb of ram cycled 10GB through swap with this diff
and is still running as I type this. Other tests by ariane@@ and thib@@
also seem to show that it's alright.

ok deraadt@@, thib@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.26 2009/03/23 13:25:11 art Exp $	*/
a151 1
	extern int uvm_km_pages_free;
a231 3

	case VM_KMPAGESFREE:
		return (sysctl_rdint(oldp, oldlenp, newp, uvm_km_pages_free));
@


1.27
log
@Remove static qualifier of functions that are not inline.
Makes trace in ddb useful.

ok oga
@
text
@d79 1
a79 1
void uvm_loadav(struct loadavg *);
d97 1
a97 1
void
@


1.26
log
@Processor affinity for processes.
 - Split up run queues so that every cpu has one.
 - Make setrunqueue choose the cpu where we want to make this process
   runnable (this should be refined and less brutal in the future).
 - When choosing the cpu where we want to run, make some kind of educated
   guess where it will be best to run (very naive right now).
Other:
 - Set operations for sets of cpus.
 - load average calculations per cpu.
 - sched_is_idle() -> curcpu_is_idle()

tested, debugged and prodded by many@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.25 2009/03/20 15:19:04 oga Exp $	*/
d79 1
a79 1
static void uvm_loadav(struct loadavg *);
d97 1
a97 1
static void
@


1.25
log
@While working on some stuff in uvm I've gotten REALLY sick of reading
K&R function declarations, so switch them all over to ansi-style, in
accordance with the prophesy.

"go for it" art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.24 2007/12/15 03:42:57 deraadt Exp $	*/
d100 2
d104 1
d107 2
d121 2
d125 2
a126 1
	for (i = 0; i < 3; i++)
d129 11
@


1.24
log
@export kernel uvm_km_pages_free as vm.kmpagesfree; ok tedu, tested jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.23 2007/10/10 15:53:53 art Exp $	*/
d85 1
a85 1
uvm_meter()
d98 1
a98 2
uvm_loadav(avg)
	struct loadavg *avg;
d127 2
a128 8
uvm_sysctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d228 1
a228 2
uvm_total(totalp)
	struct vmtotal *totalp;
@


1.23
log
@Make context switching much more MI:
 - Move the functionality of choosing a process from cpu_switch into
   a much simpler function: cpu_switchto. Instead of having the locore
   code walk the run queues, let the MI code choose the process we
   want to run and only implement the context switching itself in MD
   code.
 - Let MD context switching run without worrying about spls or locks.
 - Instead of having the idle loop implemented with special contexts
   in MD code, implement one idle proc for each cpu. make the idle
   loop MI with MD hooks.
 - Change the proc lists from the old style vax queues to TAILQs.
 - Change the sleep queue from vax queues to TAILQs. This makes
   wakeup() go from O(n^2) to O(n)

there will be some MD fallout, but it will be fixed shortly.
There's also a few cleanups to be done after this.

deraadt@@, kettenis@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.22 2007/02/14 00:53:48 jsg Exp $	*/
d140 1
d221 3
@


1.22
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.21 2006/11/29 12:24:18 miod Exp $	*/
d112 3
a115 1
		case SONPROC:
@


1.21
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.20 2004/06/21 23:50:38 tholo Exp $	*/
d110 1
a110 1
		/* fall through */
@


1.20
log
@First step towards more sane time handling in the kernel -- this changes
things such that code that only need a second-resolution uptime or wall
time, and used to get that from time.tv_secs or mono_time.tv_secs now get
this from separate time_t globals time_second and time_uptime.

ok art@@ niklas@@ nordin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.19 2004/06/13 21:49:29 niklas Exp $	*/
d254 4
a257 7
			if (p->p_flag & P_INMEM) {
				if (p->p_priority <= PZERO)
					totalp->t_dw++;
				else if (p->p_slptime < maxslp)
					totalp->t_sl++;
			} else if (p->p_slptime < maxslp)
				totalp->t_sw++;
d265 1
a265 4
			if (p->p_flag & P_INMEM)
				totalp->t_rq++;
			else
				totalp->t_sw++;
@


1.19
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d87 1
a87 1
	if ((time.tv_sec % 5) == 0)
@


1.18
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.17 2002/03/14 01:27:18 millert Exp $	*/
d113 1
d267 1
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.16 2001/11/28 19:28:15 art Exp $	*/
d95 1
a95 1
 * 1, 5, and 15 minute internvals.
@


1.16
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.15 2001/11/12 01:26:09 art Exp $	*/
d79 1
a79 1
static void uvm_loadav __P((struct loadavg *));
@


1.16.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.16 2001/11/28 19:28:15 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.22 2001/11/10 07:37:00 lukem Exp $	*/
@


1.16.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.16.2.1 2002/02/02 03:28:27 art Exp $	*/
d79 1
a79 1
static void uvm_loadav(struct loadavg *);
@


1.16.2.3
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.16.2.2 2002/06/11 03:33:03 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.23 2001/12/09 03:07:19 chs Exp $	*/
a172 15
#define UPDATEMIN(a, ap, bp, cp) 					\
	{								\
		t = uvmexp.ap;						\
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);	\
		if (rv) {						\
			return rv;					\
		}							\
		if (t + uvmexp.bp + uvmexp.cp > 95 || t < 0) {		\
			return EINVAL;					\
		}							\
		uvmexp.ap = t;						\
		uvmexp.a = t * 256 / 100;				\
		return rv;						\
	}

d174 37
a210 32
		UPDATEMIN(anonmin, anonminpct, fileminpct, execminpct);

	case VM_EXECMIN:
		UPDATEMIN(execmin, execminpct, fileminpct, anonminpct);

	case VM_FILEMIN:
		UPDATEMIN(filemin, fileminpct, execminpct, anonminpct);

#undef UPDATEMIN
#define UPDATEMAX(a, ap)	 					\
	{								\
		t = uvmexp.ap;						\
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);	\
		if (rv) {						\
			return rv;					\
		}							\
		if (t > 100 || t < 0) {					\
			return EINVAL;					\
		}							\
		uvmexp.ap = t;						\
		uvmexp.a = t * 256 / 100;				\
		return rv;						\
	}

	case VM_ANONMAX:
		UPDATEMAX(anonmax, anonmaxpct);

	case VM_EXECMAX:
		UPDATEMAX(execmax, execmaxpct);

	case VM_FILEMAX:
		UPDATEMAX(filemax, filemaxpct);
a211 1
#undef UPDATEMAX
@


1.15
log
@Bring in more changes from NetBSD. Mostly pagedaemon improvements.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.14 2001/11/07 02:55:50 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.17 2001/03/09 01:02:12 chs Exp $	*/
d7 1
a7 1
 *      The Regents of the University of California.  
d22 1
a22 1
 *      Washington University, and the University of California, Berkeley 
d65 1
a65 1
 * constants for averages over 1, 5, and 15 minutes when sampling at 
d94 1
a94 1
 * uvm_loadav: compute a tenex style load average of a quantity on 
d211 7
d233 2
a234 2
	vm_map_entry_t	entry;
	vm_map_t map;
@


1.14
log
@Another sync of uvm to NetBSD. Just minor fiddling, no major changes.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.13 2001/11/06 01:35:04 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.14 2000/11/24 18:54:31 chs Exp $	*/
d135 1
d173 38
@


1.13
log
@Move the last content from vm/ to uvm/
The only thing left in vm/ are just dumb wrappers.
vm/vm.h includes uvm/uvm_extern.h
vm/pmap.h includes uvm/uvm_pmap.h
vm/vm_page.h includes uvm/uvm_page.h
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.12 2001/08/11 10:57:22 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.13 2000/06/27 17:29:27 mrg Exp $	*/
d62 1
a62 1
struct loadavg averunnable; /* decl. */
d90 1
a90 1
		wakeup((caddr_t)&proc0);
d104 2
a105 1
	for (nrun = 0, p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
d198 1
a198 1
	for (p = allproc.lh_first; p != 0; p = p->p_list.le_next) {
@


1.12
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.11 2001/08/02 11:06:38 art Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.12 2000/05/26 00:36:53 thorpej Exp $	*/
d48 1
a48 1
#include <vm/vm.h>
@


1.11
log
@Sysctl for finding out how many pages there are in kmem_map.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.10 2001/06/23 19:24:34 smart Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.11 2000/02/11 19:22:54 thorpej Exp $	*/
@


1.10
log
@Sync with NetBSD 19990911 (just before PMAP_NEW was required)
  - thread_sleep_msg() -> uvm_sleep()
  - initialize reference count lock in uvm_anon_{init,add}()
  - add uao_flush()
  - replace boolean 'islocked' with 'lockflags'
  - in uvm_fault() change FALSE to TRUE to in 'wide' fault handling
  - get rid of uvm_km_get()
  - various bug fixes
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.9 2001/01/29 02:07:46 niklas Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.10 1999/07/25 06:30:36 thorpej Exp $	*/
d164 3
@


1.9
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_meter.c,v 1.8 1999/03/25 18:48:53 mrg Exp $	*/
/*	$NetBSD: uvm_meter.c,v 1.8 1999/03/25 18:48:53 mrg Exp $	*/
@


1.8
log
@Convert bzero to memset(X, 0..) and bcopy to memcpy.
This is to match (make diffs smaller) the code in NetBSD.
new gcc inlines those functions, so this could also be a performance win.
@
text
@d1 1
@


1.7
log
@put in own ctl level for swapencrypt.
@
text
@d187 1
a187 1
	bzero(totalp, sizeof *totalp);
@


1.6
log
@postpone memory allocation for uvm swap encryption until it is turned on with
sysctl.
@
text
@d135 14
a148 3
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */
a166 19
#ifdef UVM_SWAP_ENCRYPT
	case VM_SWAPENCRYPT: {
		int doencrypt = uvm_doswapencrypt;
		int result;

		result = sysctl_int(oldp, oldlenp, newp, newlen, &doencrypt);
		if (result)
			return result;

		/* Swap Encryption has been turned on, we need to
		 * initalize state for swap devices that have been
		 * added 
		 */
		if (doencrypt)
			uvm_swap_initcrypt_all();
		uvm_doswapencrypt = doencrypt;
		return (0);
	}
#endif
@


1.5
log
@Fix the NetBSD id strings.
@
text
@d52 1
d157 17
a173 3
	case VM_SWAPENCRYPT:
		return (sysctl_int(oldp, oldlenp, newp, newlen,
		    &uvm_doswapencrypt));
@


1.4
log
@swap encryption for UVM, option UVM_SWAP_ENCRYPT.  needs to be enabled
via sysctl.
Pages are encrypted with the Blowfish encryption algorithm, the key
is initialized randomly on first swap out, ensuring that entropy has
accumulated in the kernel randomness pool.  Eventually, swap encryption
will be decided on a process by process basis, e.g. a process that reads from
a cryptographic filesystem will enable swap encrypt for its pages. okay
art@@ and deraadt@@.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_meter.c,v 1.7 1998/08/09 22:36:39 perry Exp $	*/
@


1.4.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_meter.c,v 1.8 1999/03/25 18:48:53 mrg Exp $	*/
a51 1
#include <uvm/uvm_swap.h>
d156 3
a158 17
	case VM_SWAPENCRYPT: {
		int doencrypt = uvm_doswapencrypt;
		int result;

		result = sysctl_int(oldp, oldlenp, newp, newlen, &doencrypt);
		if (result)
			return result;

		/* Swap Encryption has been turned on, we need to
		 * initalize state for swap devices that have been
		 * added 
		 */
		if (doencrypt)
			uvm_swap_initcrypt_all();
		uvm_doswapencrypt = doencrypt;
		return (0);
	}
@


1.4.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_meter.c,v 1.9 2001/01/29 02:07:46 niklas Exp $	*/
d135 3
a137 14
	switch (name[0]) {
	case VM_SWAPENCRYPT:
#ifdef UVM_SWAP_ENCRYPT
		return (swap_encrypt_ctl(name + 1, namelen - 1, oldp, oldlenp,
					 newp, newlen, p));
#else
		return (EOPNOTSUPP);
#endif
	default:
		/* all sysctl names at this level are terminal */
		if (namelen != 1)
			return (ENOTDIR);		/* overloaded */
		break;
	}
d156 19
d195 1
a195 1
	memset(totalp, 0, sizeof *totalp);
@


1.4.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_meter.c,v 1.10 1999/07/25 06:30:36 thorpej Exp $	*/
@


1.4.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_meter.c,v 1.12 2000/05/26 00:36:53 thorpej Exp $	*/
a163 3

	case VM_NKMEMPAGES:
		return (sysctl_rdint(oldp, oldlenp, newp, nkmempages));
@


1.4.2.5
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_meter.c,v 1.17 2001/03/09 01:02:12 chs Exp $	*/
d48 1
a48 1
#include <uvm/uvm_extern.h>
d62 1
a62 1
struct loadavg averunnable;
d90 1
a90 1
		wakeup(&proc0);
d104 1
a104 2
	nrun = 0;
	LIST_FOREACH(p, &allproc, p_list) {
a133 1
	int rv, t;
a170 38
	case VM_ANONMIN:
		t = uvmexp.anonminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (t + uvmexp.vtextminpct + uvmexp.vnodeminpct > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.anonminpct = t;
		uvmexp.anonmin = t * 256 / 100;
		return rv;

	case VM_VTEXTMIN:
		t = uvmexp.vtextminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (uvmexp.anonminpct + t + uvmexp.vnodeminpct > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.vtextminpct = t;
		uvmexp.vtextmin = t * 256 / 100;
		return rv;

	case VM_VNODEMIN:
		t = uvmexp.vnodeminpct;
		rv = sysctl_int(oldp, oldlenp, newp, newlen, &t);
		if (rv) {
			return rv;
		}
		if (uvmexp.anonminpct + uvmexp.vtextminpct + t > 95 || t < 0) {
			return EINVAL;
		}
		uvmexp.vnodeminpct = t;
		uvmexp.vnodemin = t * 256 / 100;
		return rv;
d197 1
a197 1
	LIST_FOREACH(p, &allproc, p_list) {
@


1.4.2.6
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_meter.c,v 1.21 2001/07/14 06:36:03 matt Exp $	*/
d7 1
a7 1
 *      The Regents of the University of California.
d22 1
a22 1
 *      Washington University, and the University of California, Berkeley
d65 1
a65 1
 * constants for averages over 1, 5, and 15 minutes when sampling at
d94 1
a94 1
 * uvm_loadav: compute a tenex style load average of a quantity on
a210 7

	case VM_MAXSLP:
		return (sysctl_rdint(oldp, oldlenp, newp, maxslp));

	case VM_USPACE:
		return (sysctl_rdint(oldp, oldlenp, newp, USPACE));

d226 2
a227 2
	struct vm_map_entry *	entry;
	struct vm_map *map;
@


1.4.2.7
log
@Merge in -current from roughly a week ago
@
text
@d79 1
a79 1
static void uvm_loadav(struct loadavg *);
@


1.4.2.8
log
@Merge with the trunk
@
text
@d95 1
a95 1
 * 1, 5, and 15 minute intervals.
@


1.4.2.9
log
@ONPROC processes count as runable in t_rq as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.4.2.8 2004/06/05 23:13:13 niklas Exp $	*/
a265 1
		case SONPROC:
@


1.4.2.10
log
@Treat SONPROC as runnable for nrun (uptime) too. pointed out by millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_meter.c,v 1.4.2.9 2004/06/11 19:03:23 drahn Exp $	*/
a112 1
		case SONPROC:
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d51 4
d155 5
a159 1

@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *         >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

