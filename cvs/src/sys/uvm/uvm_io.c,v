head	1.26;
access;
symbols
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.25.0.4
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.24.0.2
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.4
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.20.0.10
	OPENBSD_5_5_BASE:1.20
	OPENBSD_5_4:1.20.0.6
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.4
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.2
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.16.0.18
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.14
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.12
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.10
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.6
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2016.01.09.11.34.27;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	3iSrdkO42f8EdbTY;

1.25
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.24;
commitid	p4LJxGKbi0BU2cG6;

1.24
date	2015.02.10.21.56.10;	author miod;	state Exp;
branches;
next	1.23;
commitid	C5iGb36LQxjM60Q3;

1.23
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.22;
commitid	uzzBR7hz9ncd4O6G;

1.22
date	2014.07.11.16.35.40;	author jsg;	state Exp;
branches;
next	1.21;
commitid	7NtJNW9udCOFtDNM;

1.21
date	2014.04.13.23.14.15;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2012.03.09.13.01.29;	author ariane;	state Exp;
branches;
next	1.19;

1.19
date	2011.06.06.17.10.23;	author ariane;	state Exp;
branches;
next	1.18;

1.18
date	2011.05.24.15.27.36;	author ariane;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.25.12.55.40;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.04.21.48.07;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.24.21.11.47;	author tedu;	state Exp;
branches;
next	1.14;

1.14
date	2002.10.29.18.30.21;	author art;	state Exp;
branches;
next	1.13;

1.13
date	2001.12.19.08.58.07;	author art;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.28.19.28.14;	author art;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.11.28.13.47.39;	author art;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.01.35.04;	author art;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.05.22.14.54;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.20.02.07.43;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.20.50.59;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.08.11.10.57.22;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.45;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.15.15.50.20;	author art;	state Exp;
branches;
next	1.3;

1.3
date	99.08.23.08.13.23;	author art;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.02.26.05.32.07;	author art;	state Exp;
branches;
next	1.1;

1.1
date	99.02.26.01.30.13;	author art;	state Exp;
branches;
next	;

1.3.4.1
date	2000.03.24.09.09.49;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.05.14.22.47.45;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2001.12.05.01.23.58;	author niklas;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2002.03.06.02.17.14;	author niklas;	state Exp;
branches;
next	1.3.4.7;

1.3.4.7
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.02.02.03.28.26;	author art;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2002.11.04.20.11.00;	author art;	state Exp;
branches;
next	;


desc
@@


1.26
log
@Use uiomove(9) instead of uiomovei(9).  From Martin Natano.
@
text
@/*	$OpenBSD: uvm_io.c,v 1.25 2015/03/14 03:38:53 jsg Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.12 2000/06/27 17:29:23 mrg Exp $	*/

/*
 * Copyright (c) 1997 Charles D. Cranor and Washington University.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * from: Id: uvm_io.c,v 1.1.2.2 1997/12/30 12:02:00 mrg Exp
 */

/*
 * uvm_io.c: uvm i/o ops
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mman.h>
#include <sys/uio.h>

#include <uvm/uvm.h>

/*
 * functions
 */

/*
 * uvm_io: perform I/O on a map
 *
 * => caller must have a reference to "map" so that it doesn't go away
 *    while we are working.
 */

int
uvm_io(vm_map_t map, struct uio *uio, int flags)
{
	vaddr_t baseva, endva, pageoffset, kva;
	vsize_t chunksz, togo, sz;
	struct uvm_map_deadq dead_entries;
	int error, extractflags;

	/*
	 * step 0: sanity checks and set up for copy loop.  start with a
	 * large chunk size.  if we have trouble finding vm space we will
	 * reduce it.
	 */
	if (uio->uio_resid == 0)
		return(0);
	togo = uio->uio_resid;

	baseva = (vaddr_t) uio->uio_offset;
	endva = baseva + (togo - 1);

	if (endva < baseva)   /* wrap around? */
		return(EIO);

	if (baseva >= VM_MAXUSER_ADDRESS)
		return(0);
	if (endva >= VM_MAXUSER_ADDRESS)
		/* EOF truncate */
		togo = togo - (endva - VM_MAXUSER_ADDRESS + 1);
	pageoffset = baseva & PAGE_MASK;
	baseva = trunc_page(baseva);
	chunksz = min(round_page(togo + pageoffset), MAXBSIZE);
	error = 0;

	extractflags = 0;
	if (flags & UVM_IO_FIXPROT)
		extractflags |= UVM_EXTRACT_FIXPROT;

	/* step 1: main loop...  while we've got data to move */
	for (/*null*/; togo > 0 ; pageoffset = 0) {
		/* step 2: extract mappings from the map into kernel_map */
		error = uvm_map_extract(map, baseva, chunksz, &kva,
		    extractflags);
		if (error) {

			/* retry with a smaller chunk... */
			if (error == ENOMEM && chunksz > PAGE_SIZE) {
				chunksz = trunc_page(chunksz / 2);
				if (chunksz < PAGE_SIZE)
					chunksz = PAGE_SIZE;
				continue;
			}

			break;
		}

		/* step 3: move a chunk of data */
		sz = chunksz - pageoffset;
		if (sz > togo)
			sz = togo;
		error = uiomove((caddr_t) (kva + pageoffset), sz, uio);
		togo -= sz;
		baseva += chunksz;

		/* step 4: unmap the area of kernel memory */
		vm_map_lock(kernel_map);
		TAILQ_INIT(&dead_entries);
		uvm_unmap_remove(kernel_map, kva, kva+chunksz,
		    &dead_entries, FALSE, TRUE);
		vm_map_unlock(kernel_map);
		uvm_unmap_detach(&dead_entries, AMAP_REFALL);

		/*
		 * We defer checking the error return from uiomove until
		 * here so that we won't leak memory.
		 */
		if (error)
			break;
	}

	return (error);
}
@


1.25
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.24 2015/02/10 21:56:10 miod Exp $	*/
d112 1
a112 1
		error = uiomovei((caddr_t) (kva + pageoffset), sz, uio);
@


1.24
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.23 2014/09/14 14:17:27 jsg Exp $	*/
a37 1
#include <sys/malloc.h>
@


1.23
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.22 2014/07/11 16:35:40 jsg Exp $	*/
d113 1
a113 1
		error = uiomove((caddr_t) (kva + pageoffset), sz, uio);
@


1.22
log
@Chuck Cranor rescinded clauses in his license
on the 2nd of February 2011 in NetBSD.

http://marc.info/?l=netbsd-source-changes&m=129658899212732&w=2
http://marc.info/?l=netbsd-source-changes&m=129659095515558&w=2
http://marc.info/?l=netbsd-source-changes&m=129659157916514&w=2
http://marc.info/?l=netbsd-source-changes&m=129665962324372&w=2
http://marc.info/?l=netbsd-source-changes&m=129666033625342&w=2
http://marc.info/?l=netbsd-source-changes&m=129666052825545&w=2
http://marc.info/?l=netbsd-source-changes&m=129666922906480&w=2
http://marc.info/?l=netbsd-source-changes&m=129667725518082&w=2
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.21 2014/04/13 23:14:15 tedu Exp $	*/
a37 1
#include <sys/proc.h>
@


1.21
log
@compress code by turning four line comments into one line comments.
emphatic ok usual suspects, grudging ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.20 2012/03/09 13:01:29 ariane Exp $	*/
a4 1
 *
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Charles D. Cranor and
 *      Washington University.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.20
log
@New vmmap implementation.

no oks (it is really a pain to review properly)
extensively tested, I'm confident it'll be stable
'now is the time' from several icb inhabitants

Diff provides:
- ability to specify different allocators for different regions/maps
- a simpler implementation of the current allocator
- currently in compatibility mode: it will generate similar addresses
  as the old allocator
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.19 2011/06/06 17:10:23 ariane Exp $	*/
a74 1

d99 1
a99 4
	/*
	 * step 1: main loop...  while we've got data to move
	 */

d101 1
a101 5

		/*
		 * step 2: extract mappings from the map into kernel_map
		 */

d117 1
a117 4
		/*
		 * step 3: move a chunk of data
		 */

d125 1
a125 5

		/*
		 * step 4: unmap the area of kernel memory
		 */

a139 4

	/*
	 * done
	 */
@


1.19
log
@Backout vmmap in order to repair virtual address selection algorithms
outside the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.18 2011/05/24 15:27:36 ariane Exp $	*/
d67 1
a67 1
	vm_map_entry_t dead_entries;
d96 1
a96 1
	extractflags = UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG;
d110 1
a110 1
		error = uvm_map_extract(map, baseva, chunksz, kernel_map, &kva,
d142 1
d144 1
a144 1
		    &dead_entries, NULL, FALSE);
d146 1
a146 3

		if (dead_entries != NULL)
			uvm_unmap_detach(dead_entries, AMAP_REFALL);
@


1.18
log
@Reimplement uvm/uvm_map.

vmmap is designed to perform address space randomized allocations,
without letting fragmentation of the address space go through the roof.

Some highlights:
- kernel address space randomization
- proper implementation of guardpages
- roughly 10% system time reduction during kernel build

Tested by alot of people on tech@@ and developers.
Theo's machines are still happy.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.17 2009/07/25 12:55:40 miod Exp $	*/
d67 1
a67 1
	struct uvm_map_deadq dead_entries;
d96 1
a96 1
	extractflags = 0;
d110 1
a110 1
		error = uvm_map_extract(map, baseva, chunksz, &kva,
a141 1
		TAILQ_INIT(&dead_entries);
d143 1
a143 1
		    &dead_entries, FALSE, TRUE);
d145 3
a147 1
		uvm_unmap_detach(&dead_entries, AMAP_REFALL);
@


1.17
log
@Add an extra argument to uvm_unmap_remove(), for the caller to tell it
whether removing holes or parts of them is allowed or not.
Only allow hole removal in uvmspace_free(), when tearing the vmspace down.

ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.16 2005/11/04 21:48:07 miod Exp $	*/
d67 1
a67 1
	vm_map_entry_t dead_entries;
d96 1
a96 1
	extractflags = UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG;
d110 1
a110 1
		error = uvm_map_extract(map, baseva, chunksz, kernel_map, &kva,
d142 1
d144 1
a144 1
		    &dead_entries, NULL, FALSE);
d146 1
a146 3

		if (dead_entries != NULL)
			uvm_unmap_detach(dead_entries, AMAP_REFALL);
@


1.16
log
@Add an extra flags argument to uvm_io(), to specify whether we want to fix
the protection of the memory mapping we're doing I/O on, or if we want to
leave them as they are. This should only be necessary for breakpoint
insertion in code, so we'll only use it for ptrace requests.

Initially from art@@ after discussion with kettenis@@ millert@@ and I,
tested by many.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.15 2005/05/24 21:11:47 tedu Exp $	*/
d143 1
a143 1
		    &dead_entries, NULL);
@


1.15
log
@add a new field to vm_space and use it to track the number of anon
pages a process uses.  this is now the userland "data size" value.
ok art deraadt tdeval.  thanks testers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.14 2002/10/29 18:30:21 art Exp $	*/
d63 1
a63 3
uvm_io(map, uio)
	vm_map_t map;
	struct uio *uio;
d68 1
a68 1
	int error;
d96 4
d111 1
a111 2
			    UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG | 
			    UVM_EXTRACT_FIXPROT);
@


1.14
log
@Since memory deallocation can't fail, remove the error return from
uvm_unmap, uvm_deallocate and a few other functions.
Simplifies some code and reduces diff to the UBC branch.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.13 2001/12/19 08:58:07 art Exp $	*/
d142 1
a142 1
		    &dead_entries);
@


1.13
log
@UBC was a disaster. It worked very good when it worked, but on some
machines or some configurations or in some phase of the moon (we actually
don't know when or why) files disappeared. Since we've not been able to
track down the problem in two weeks intense debugging and we need -current
to be stable, back out everything to a state it had before UBC.

We apologise for the inconvenience.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.10 2001/11/06 01:35:04 art Exp $	*/
d141 1
a141 1
		(void)uvm_unmap_remove(kernel_map, kva, kva+chunksz,
@


1.12
log
@Sync in more uvm from NetBSD. Mostly just cosmetic stuff.
Contains also support for page coloring.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.11 2001/11/28 13:47:39 art Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.15 2001/06/02 18:09:26 chs Exp $	*/
d64 1
a64 1
	struct vm_map *map;
d69 1
a69 1
	struct vm_map_entry *dead_entries;
d109 1
a109 1
			    UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG |
d141 2
a142 1
		uvm_unmap_remove(kernel_map, kva, kva + chunksz, &dead_entries);
@


1.12.2.1
log
@Merge in UBC performance changes from NetBSD.
Fix a bunch of merge errors from yesterday.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.12 2001/11/28 19:28:14 art Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.17 2001/11/10 07:37:00 lukem Exp $	*/
d95 1
a95 1
	chunksz = MIN(round_page(togo + pageoffset), MAXBSIZE);
@


1.12.2.2
log
@Some minor cleanups to reduce diff to netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.12.2.1 2002/02/02 03:28:26 art Exp $	*/
d143 1
d154 5
@


1.11
log
@Sync in more uvm changes from NetBSD.
This time we're getting rid of KERN_* and VM_PAGER_* error codes and
use errnos instead.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.10 2001/11/06 01:35:04 art Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.13 2001/03/15 06:10:57 chs Exp $	*/
d64 1
a64 1
	vm_map_t map;
d69 1
a69 1
	vm_map_entry_t dead_entries;
d109 1
a109 1
			    UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG | 
@


1.10
log
@Move the last content from vm/ to uvm/
The only thing left in vm/ are just dumb wrappers.
vm/vm.h includes uvm/uvm_extern.h
vm/pmap.h includes uvm/uvm_pmap.h
vm/vm_page.h includes uvm/uvm_page.h
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.9 2001/11/05 22:14:54 art Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.12 2000/06/27 17:29:23 mrg Exp $	*/
d141 1
a141 2
		(void)uvm_unmap_remove(kernel_map, kva, kva+chunksz,
		    &dead_entries);
@


1.9
log
@Minor sync to NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.8 2001/09/20 02:07:43 art Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.11 2000/06/26 14:21:18 mrg Exp $	*/
a47 2

#include <vm/vm.h>
@


1.8
log
@Avoid leaking memory if uiomove fails.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.7 2001/09/19 20:50:59 mickey Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.10 2000/06/02 12:02:44 pk Exp $	*/
a49 1
#include <vm/vm_page.h>
@


1.7
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.6 2001/08/11 10:57:22 art Exp $	*/
a134 2
		if (error)
			break;
d150 7
@


1.6
log
@Various random fixes from NetBSD.
Including support for zeroing pages in the idle loop (not enabled yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_io.c,v 1.5 2001/01/29 02:07:45 niklas Exp $	*/
a50 1
#include <vm/vm_kern.h>
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_io.c,v 1.8 1999/03/25 18:48:51 mrg Exp $	*/
/*	$NetBSD: uvm_io.c,v 1.8 1999/03/25 18:48:51 mrg Exp $	*/
@


1.4
log
@Fix the NetBSD id strings.
@
text
@d1 1
@


1.3
log
@sync with NetBSD from 1999.05.24 (there is a reason for this date)
 Mostly cleanups, but also a few improvements to pagedaemon for better
 handling of low memory and/or low swap conditions.
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_io.c,v 1.7 1998/10/11 23:18:20 chuck Exp $	*/
@


1.3.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$NetBSD: uvm_io.c,v 1.8 1999/03/25 18:48:51 mrg Exp $	*/
@


1.3.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 1
/*	$OpenBSD: uvm_io.c,v 1.5 2001/01/29 02:07:45 niklas Exp $	*/
@


1.3.4.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_io.c,v 1.10 2000/06/02 12:02:44 pk Exp $	*/
d51 1
d136 2
a152 7

		/*
		 * We defer checking the error return from uiomove until
		 * here so that we won't leak memory.
		 */
		if (error)
			break;
@


1.3.4.4
log
@merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_io.c,v 1.12 2000/06/27 17:29:23 mrg Exp $	*/
d48 3
@


1.3.4.5
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_io.c,v 1.15 2001/06/02 18:09:26 chs Exp $	*/
d64 1
a64 1
	struct vm_map *map;
d69 1
a69 1
	struct vm_map_entry *dead_entries;
d109 1
a109 1
			    UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG |
d141 2
a142 1
		uvm_unmap_remove(kernel_map, kva, kva + chunksz, &dead_entries);
@


1.3.4.6
log
@Merge in trunk
@
text
@d2 1
a2 1
/*	$NetBSD: uvm_io.c,v 1.12 2000/06/27 17:29:23 mrg Exp $	*/
d64 1
a64 1
	vm_map_t map;
d69 1
a69 1
	vm_map_entry_t dead_entries;
d109 1
a109 1
			    UVM_EXTRACT_QREF | UVM_EXTRACT_CONTIG | 
d141 1
a141 2
		(void)uvm_unmap_remove(kernel_map, kva, kva+chunksz,
		    &dead_entries);
@


1.3.4.7
log
@Sync the SMP branch with 3.3
@
text
@d141 1
a141 1
		uvm_unmap_remove(kernel_map, kva, kva+chunksz,
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
a2 4
/*
 * XXXCDC: "ROUGH DRAFT" QUALITY UVM PRE-RELEASE FILE!   
 *	   >>>USE AT YOUR OWN RISK, WORK IS NOT FINISHED<<<
 */
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

