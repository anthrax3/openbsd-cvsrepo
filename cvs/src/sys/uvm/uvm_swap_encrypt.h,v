head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.10
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.6
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.4
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.9.0.20
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.24
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.22
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.18
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.16
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.14
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.12
	OPENBSD_5_0:1.9.0.10
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.8
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.6
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.7.0.28
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.26
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.24
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.22
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.20
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.18
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.16
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.14
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.12
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.10
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.8
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.6
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.4
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.7
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.10
date	2015.05.06.04.00.10;	author dlg;	state Exp;
branches;
next	1.9;
commitid	B7QBP4rg1P9WFyqZ;

1.9
date	2009.03.23.22.10.04;	author oga;	state Exp;
branches;
next	1.8;

1.8
date	2009.03.23.22.07.41;	author oga;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.50;	author niklas;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2000.06.14.16.51.55;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.27.21.06.08;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.26.15.18.29;	author provos;	state Exp;
branches;
next	1.1;

1.1
date	99.12.30.18.21.56;	author provos;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.47.48;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.03.28.14.54.27;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.33.04;	author art;	state Exp;
branches;
next	1.5.6.2;

1.5.6.2
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@make SWAP_KEY_GET symmetrical with SWAP_KEY_PUT by having it call
a function in uvm_swap_encrypt.c instead of doing stuff inline.

lets me remove an extern from the header too.

ok kettenis@@
@
text
@/*	$OpenBSD: uvm_swap_encrypt.h,v 1.9 2009/03/23 22:10:04 oga Exp $	*/

/*
 * Copyright 1999 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _UVM_SWAP_ENCRYPT_H
#define _UVM_SWAP_ENCRYPT_H

#define SWPENC_ENABLE	0
#define SWPENC_CREATED	1
#define SWPENC_DELETED	2
#define SWPENC_MAXID	3

#define CTL_SWPENC_NAMES { \
	{ "enable", CTLTYPE_INT }, \
	{ "keyscreated", CTLTYPE_INT }, \
	{ "keysdeleted", CTLTYPE_INT }, \
}

#define SWAP_KEY_EXPIRE (120 /*60 * 60*/)	/* time after that keys expire */
#define SWAP_KEY_SIZE	4		/* 128-bit keys */

struct swap_key {
	u_int32_t key[SWAP_KEY_SIZE];	/* secret key for swap range */
	u_int16_t refcount;		/* pages that still need it */
};

int swap_encrypt_ctl(int *, u_int, void *, size_t *, void *, size_t,
			  struct proc *);

void swap_encrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);
void swap_decrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);

void swap_key_cleanup(struct swap_key *);
void swap_key_prepare(struct swap_key *, int);

#define SWAP_KEY_GET(s,x)	do {					\
					if ((x)->refcount == 0) {	\
						swap_key_create(x);	\
					}				\
					(x)->refcount++;		\
				} while(0);

#define SWAP_KEY_PUT(s,x)	do {					\
					(x)->refcount--;		\
					if ((x)->refcount == 0) {	\
						swap_key_delete(x);	\
					}				\
				} while(0);

void swap_key_create(struct swap_key *);
void swap_key_delete(struct swap_key *);

extern int uvm_doswapencrypt;		/* swapencrypt enabled/disabled */
extern int uvm_swprekeyprint;
extern u_int uvm_swpkeyexpire;		/* expiry time for keys (tR) */
extern int swap_encrypt_initialized;

#endif /* _UVM_SWAP_ENCRYPT_H */
@


1.9
log
@Whitespace nit in previous.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.8 2009/03/23 22:07:41 oga Exp $	*/
a63 2
extern u_int uvm_swpkeyscreated;

d66 1
a66 3
						arc4random_buf((x)->key,\
						    sizeof((x)->key));	\
						uvm_swpkeyscreated++;	\
d78 1
@


1.8
log
@turn a for (i = 0; i < size; i++) arc4random(); loop into arc4random_buf().

Since that function is now so small (2 lines), inline it into it's only user.

Shaves some bytes (104 on amd64).

ok deraadt@@, blambert@@. djm@@ liked an earlier diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.7 2002/07/02 19:38:55 nate Exp $	*/
d71 1
a71 1
						}			\
@


1.7
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.6 2002/03/14 01:27:19 millert Exp $	*/
d64 17
a80 9
#define SWAP_KEY_GET(s,x) do { if ((x)->refcount == 0) {\
					swap_key_create(x); \
			       } \
			       (x)->refcount++; } while(0);
#define SWAP_KEY_PUT(s,x) do { (x)->refcount--; \
			       if ((x)->refcount == 0) { \
					swap_key_delete(x); \
			       } \
			     } while(0);
a81 1
void swap_key_create(struct swap_key *);
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.5 2001/01/29 02:07:50 niklas Exp $	*/
d80 1
a80 1
extern int swap_encrypt_initalized;
@


1.5
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a56 2
int swap_encrypt_ctl __P((int *, u_int, void *, size_t *, void *, size_t,
			  struct proc *));
d58 2
a59 2
void swap_encrypt __P((struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t));
void swap_decrypt __P((struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t));
d61 2
a62 2
void swap_key_cleanup __P((struct swap_key *));
void swap_key_prepare __P((struct swap_key *, int));
d74 2
a75 2
void swap_key_create __P((struct swap_key *));
void swap_key_delete __P((struct swap_key *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.5 2001/01/29 02:07:50 niklas Exp $	*/
d55 2
a56 2
int swap_encrypt_ctl(int *, u_int, void *, size_t *, void *, size_t,
			  struct proc *);
d58 2
a59 2
void swap_encrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);
void swap_decrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);
d61 2
a62 2
void swap_key_cleanup(struct swap_key *);
void swap_key_prepare(struct swap_key *, int);
d74 2
a75 2
void swap_key_create(struct swap_key *);
void swap_key_delete(struct swap_key *);
@


1.5.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.5.6.1 2002/06/11 03:33:04 art Exp $	*/
d80 1
a80 1
extern int swap_encrypt_initialized;
@


1.4
log
@put in own ctl level for swapencrypt.
@
text
@d1 2
@


1.3
log
@use rijndael instead of blowfish because of faster key setup.
break swap paritions into sections, each section has own
encryption key.  if a section's key becomes unreferenced, erase it.
@
text
@d34 11
d52 3
@


1.2
log
@use encrypted blocknumber as IV
@
text
@d34 26
a59 3
void swap_encrypt_init __P((caddr_t, size_t));
void swap_encrypt __P((caddr_t, caddr_t, u_int64_t, size_t));
void swap_decrypt __P((caddr_t, caddr_t, u_int64_t, size_t));
d62 2
@


1.1
log
@swap encryption for UVM, option UVM_SWAP_ENCRYPT.  needs to be enabled
via sysctl.
Pages are encrypted with the Blowfish encryption algorithm, the key
is initialized randomly on first swap out, ensuring that entropy has
accumulated in the kernel randomness pool.  Eventually, swap encryption
will be decided on a process by process basis, e.g. a process that reads from
a cryptographic filesystem will enable swap encrypt for its pages. okay
art@@ and deraadt@@.
@
text
@d35 2
a36 2
void swap_encrypt __P((caddr_t, caddr_t, size_t));
void swap_decrypt __P((caddr_t, caddr_t, size_t));
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 2
/*	$OpenBSD: uvm_swap_encrypt.h,v 1.5 2001/01/29 02:07:50 niklas Exp $	*/

d34 3
a36 40
#define SWPENC_ENABLE	0
#define SWPENC_CREATED	1
#define SWPENC_DELETED	2
#define SWPENC_MAXID	3

#define CTL_SWPENC_NAMES { \
	{ "enable", CTLTYPE_INT }, \
	{ "keyscreated", CTLTYPE_INT }, \
	{ "keysdeleted", CTLTYPE_INT }, \
}

#define SWAP_KEY_EXPIRE (120 /*60 * 60*/)	/* time after that keys expire */
#define SWAP_KEY_SIZE	4		/* 128-bit keys */

struct swap_key {
	u_int32_t key[SWAP_KEY_SIZE];	/* secret key for swap range */
	u_int16_t refcount;		/* pages that still need it */
};

int swap_encrypt_ctl __P((int *, u_int, void *, size_t *, void *, size_t,
			  struct proc *));

void swap_encrypt __P((struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t));
void swap_decrypt __P((struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t));

void swap_key_cleanup __P((struct swap_key *));
void swap_key_prepare __P((struct swap_key *, int));

#define SWAP_KEY_GET(s,x) do { if ((x)->refcount == 0) {\
					swap_key_create(x); \
			       } \
			       (x)->refcount++; } while(0);
#define SWAP_KEY_PUT(s,x) do { (x)->refcount--; \
			       if ((x)->refcount == 0) { \
					swap_key_delete(x); \
			       } \
			     } while(0);

void swap_key_create __P((struct swap_key *));
void swap_key_delete __P((struct swap_key *));
a38 2
extern int uvm_swprekeyprint;
extern u_int uvm_swpkeyexpire;		/* expiry time for keys (tR) */
@


1.1.2.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d55 2
a56 2
int swap_encrypt_ctl(int *, u_int, void *, size_t *, void *, size_t,
			  struct proc *);
d58 2
a59 2
void swap_encrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);
void swap_decrypt(struct swap_key *,caddr_t, caddr_t, u_int64_t, size_t);
d61 2
a62 2
void swap_key_cleanup(struct swap_key *);
void swap_key_prepare(struct swap_key *, int);
d74 2
a75 2
void swap_key_create(struct swap_key *);
void swap_key_delete(struct swap_key *);
@


1.1.2.3
log
@Sync the SMP branch with 3.3
@
text
@d80 1
a80 1
extern int swap_encrypt_initialized;
@


