head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.2
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.12
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.10
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.8
	OPENBSD_5_0:1.6.0.6
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.4
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.2
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.14
date	2016.09.16.02.35.42;	author dlg;	state Exp;
branches;
next	1.13;
commitid	Fei4687v68qad1tP;

1.13
date	2015.08.21.16.04.35;	author visa;	state Exp;
branches;
next	1.12;
commitid	gglpDr80UKmkkP9A;

1.12
date	2014.12.17.19.42.15;	author tedu;	state Exp;
branches;
next	1.11;
commitid	G4ldVK4QwvfU3tRp;

1.11
date	2014.12.17.06.58.11;	author guenther;	state Exp;
branches;
next	1.10;
commitid	DImukoCWyTxwdbuh;

1.10
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.9;
commitid	yv0ECmCdICvq576h;

1.9
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.8;
commitid	uzzBR7hz9ncd4O6G;

1.8
date	2014.05.08.20.08.50;	author kettenis;	state Exp;
branches;
next	1.7;

1.7
date	2013.05.30.15.17.59;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2010.05.01.13.13.10;	author oga;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.30.21.56.39;	author oga;	state Exp;
branches;
next	1.4;

1.4
date	2010.04.21.03.04.49;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.25.19.19.14;	author oga;	state Exp;
branches;
next	1.2;

1.2
date	2009.06.16.00.11.29;	author oga;	state dead;
branches;
next	1.1;

1.1
date	2009.06.06.03.45.08;	author oga;	state Exp;
branches;
next	;


desc
@@


1.14
log
@move the vm_page struct from being stored in RB macro trees to RBT functions

vm_page structs go into three trees, uvm_objtree, uvm_pmr_addr, and
uvm_pmr_size. all these have been moved to RBT code.

this should give us a decent chunk of code space back.
@
text
@/*	$OpenBSD: uvm_object.c,v 1.13 2015/08/21 16:04:35 visa Exp $	*/

/*
 * Copyright (c) 2006 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Mindaugas Rasiukevicius.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * uvm_object.c: operate with memory objects
 *
 */

#include <sys/param.h>
#include <sys/mman.h>
#include <sys/atomic.h>

#include <uvm/uvm.h>

/* We will fetch this page count per step */
#define	FETCH_PAGECOUNT	16

/*
 * uvm_objinit: initialise a uvm object.
 */
void
uvm_objinit(struct uvm_object *uobj, struct uvm_pagerops *pgops, int refs)
{
	uobj->pgops = pgops;
	RBT_INIT(uvm_objtree, &uobj->memt);
	uobj->uo_npages = 0;
	uobj->uo_refs = refs;
}

#ifndef SMALL_KERNEL
/*
 * uvm_objwire: wire the pages of entire uobj
 *
 * => caller must pass page-aligned start and end values
 * => if the caller passes in a pageq pointer, we'll return a list of
 *  wired pages.
 */

int
uvm_objwire(struct uvm_object *uobj, voff_t start, voff_t end,
    struct pglist *pageq)
{
	int i, npages, left, error;
	struct vm_page *pgs[FETCH_PAGECOUNT];
	voff_t offset = start;

	left = (end - start) >> PAGE_SHIFT;

	while (left) {

		npages = MIN(FETCH_PAGECOUNT, left);

		/* Get the pages */
		memset(pgs, 0, sizeof(pgs));
		error = (*uobj->pgops->pgo_get)(uobj, offset, pgs, &npages, 0,
			PROT_READ | PROT_WRITE, MADV_SEQUENTIAL,
			PGO_ALLPAGES | PGO_SYNCIO);

		if (error)
			goto error;

		for (i = 0; i < npages; i++) {

			KASSERT(pgs[i] != NULL);
			KASSERT(!(pgs[i]->pg_flags & PG_RELEASED));

			if (pgs[i]->pg_flags & PQ_AOBJ) {
				atomic_clearbits_int(&pgs[i]->pg_flags,
				    PG_CLEAN);
				uao_dropswap(uobj, i);
			}
		}

		/* Wire the pages */
		uvm_lock_pageq();
		for (i = 0; i < npages; i++) {
			uvm_pagewire(pgs[i]);
			if (pageq != NULL)
				TAILQ_INSERT_TAIL(pageq, pgs[i], pageq);
		}
		uvm_unlock_pageq();

		/* Unbusy the pages */
		uvm_page_unbusy(pgs, npages);

		left -= npages;
		offset += (voff_t)npages << PAGE_SHIFT;
	}

	return 0;

error:
	/* Unwire the pages which have been wired */
	uvm_objunwire(uobj, start, offset);

	return error;
}

/*
 * uobj_unwirepages: unwire the pages of entire uobj
 *
 * => caller must pass page-aligned start and end values
 */

void
uvm_objunwire(struct uvm_object *uobj, voff_t start, voff_t end)
{
	struct vm_page *pg;
	off_t offset;

	uvm_lock_pageq();
	for (offset = start; offset < end; offset += PAGE_SIZE) {
		pg = uvm_pagelookup(uobj, offset);

		KASSERT(pg != NULL);
		KASSERT(!(pg->pg_flags & PG_RELEASED));

		uvm_pageunwire(pg);
	}
	uvm_unlock_pageq();
}
#endif /* !SMALL_KERNEL */
@


1.13
log
@Remove the unused loan_count field and the related uvm logic. Most of
the page loaning code is already in the Attic.

ok kettenis@@, beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.12 2014/12/17 19:42:15 tedu Exp $	*/
d53 1
a53 1
	RB_INIT(&uobj->memt);
@


1.12
log
@remove lock.h from uvm_extern.h. another holdover from the simpletonlock
era. fix uvm including c files to include lock.h or atomic.h as necessary.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.11 2014/12/17 06:58:11 guenther Exp $	*/
a93 16

#if 0
			/*
			 * Loan break
			 */
			if (pgs[i]->loan_count) {
				while (pgs[i]->loan_count) {
					pg = uvm_loanbreak(pgs[i]);
					if (!pg) {
						uvm_wait("uobjwirepg");
						continue;
					}
				}
				pgs[i] = pg;
			}
#endif
@


1.11
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.10 2014/11/16 12:31:00 deraadt Exp $	*/
d39 1
@


1.10
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.9 2014/09/14 14:17:27 jsg Exp $	*/
d83 1
a83 1
			PROT_READ | PROT_WRITE, POSIX_MADV_SEQUENTIAL,
@


1.9
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.8 2014/05/08 20:08:50 kettenis Exp $	*/
d38 1
d83 1
a83 1
			VM_PROT_READ | VM_PROT_WRITE, UVM_ADV_SEQUENTIAL,
@


1.8
log
@Fix some potential integer overflows caused by converting a page number into
an offset/size/address by shifting by PAGE_SHIFT.  Make uvm_objwrire/unwire
use voff_t instead of off_t.  The former is the right type here even if it is
equivalent to the latter.

Inspired by a somewhat similar changes in Bitrig.

ok deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.7 2013/05/30 15:17:59 tedu Exp $	*/
a37 1
#include <sys/proc.h>		/* XXX for atomic */
@


1.7
log
@remove simple_locks from uvm code. ok beck deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.6 2010/05/01 13:13:10 oga Exp $	*/
d67 1
a67 1
uvm_objwire(struct uvm_object *uobj, off_t start, off_t end,
d70 1
a70 1
	int i, npages, error;
d72 1
a72 1
	off_t offset = start, left;
d130 1
a130 1
		offset += npages << PAGE_SHIFT;
d149 1
a149 1
uvm_objunwire(struct uvm_object *uobj, off_t start, off_t end)
@


1.6
log
@Unbreak ramdisks.

I forgot that uvm_object.c wasn't build if SMALL_KERNEL. Fix this by building
the file unconditionally and only building the less used functions when
SMALL_KERNEL is not defined.

unbreaks ramdisk build. ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.5 2010/04/30 21:56:39 oga Exp $	*/
a75 1
	simple_lock(&uobj->vmobjlock);
a88 1
		simple_lock(&uobj->vmobjlock);
a101 1
						simple_unlock(&uobj->vmobjlock);
a102 1
						simple_lock(&uobj->vmobjlock);
a131 1
	simple_unlock(&uobj->vmobjlock);
a153 1
	simple_lock(&uobj->vmobjlock);
a163 1
	simple_unlock(&uobj->vmobjlock);
@


1.5
log
@Right now, if anything internal changes with a uvm object, diverse
places in the tree need to be touched to update the object
initialisation with respect to that.

So, make a function (uvm_initobj) that takes the refcount, object and
pager ops and does this initialisation for us. This should save on
maintainance in the future.

looked good to fgs@@. Tedu complained about the British spelling but OKed
it anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.4 2010/04/21 03:04:49 deraadt Exp $	*/
d57 1
d172 1
@


1.4
log
@the atomic primitives are still impossible to get at without using proc.h
(because it pulls in so much of the world) so include it for now, but
mark it XXX
ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.3 2009/11/25 19:19:14 oga Exp $	*/
d44 12
@


1.3
log
@something hairy happened with cvs so this file didn't get added.

re-add uvm_objwire and uvm_objunwire.

"you may commit that" kettenis@@
original diff oked by ariane@@ and art@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 2
#include <sys/cdefs.h>

d38 1
@


1.2
log
@Backout all changes to uvm after pmemrange (which will be backed out
separately).

a change at or just before the hackathon has either exposed or added a
very very nasty memory corruption bug that is giving us hell right now.
So in the interest of kernel stability these diffs are being backed out
until such a time as that corruption bug has been found and squashed,
then the ones that are proven good may slowly return.

a quick hitlist of the main commits this backs out:

mine:
uvm_objwire
the lock change in uvm_swap.c
using trees for uvm objects instead of the hash
removing the pgo_releasepg callback.

art@@'s:
putting pmap_page_protect(VM_PROT_NONE) in uvm_pagedeactivate() since
all callers called that just prior anyway.

ok beck@@, ariane@@.

prompted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_object.c,v 1.1 2009/06/06 03:45:08 oga Exp $	*/
@


1.1
log
@Add uvm_objwire() and uvm_objunwire(), I need this for some of my crazy
shitz.

Code mostly from netbsd with some tweaks from me. The loaning case is
specifcically if 0ed out right now because we do not do loaning.

ok ariane@@, art@@.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

