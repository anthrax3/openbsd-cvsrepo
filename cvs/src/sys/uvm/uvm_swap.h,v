head	1.16;
access;
symbols
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.12
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.8
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.10
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.6
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.4
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.15.0.6
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.4
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.6
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.8
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.4
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.2
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.11.0.26
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.24
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.22
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.20
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.18
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.16
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.14
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.12
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.10
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.8
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.8.0.2
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.16
date	2013.11.05.06.02.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2012.07.11.16.00.15;	author mlarkin;	state Exp;
branches;
next	1.14;

1.14
date	2012.07.11.10.07.40;	author mlarkin;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.01.19.48.05;	author oga;	state Exp;
branches;
next	1.12;

1.12
date	2008.04.12.20.37.36;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.19;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.10.18.42.32;	author art;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.11.07.02.55.51;	author art;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.26.19.37.13;	author art;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.22.03.05.57;	author smart;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.09.05.34.38;	author smart;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.29.02.07.49;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.18.20.51.32;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.15.15.50.21;	author art;	state Exp;
branches;
next	1.2;

1.2
date	99.02.26.05.32.08;	author art;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	99.02.26.01.30.18;	author art;	state Exp;
branches;
next	;

1.2.6.1
date	2000.03.24.09.09.52;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.05.14.22.47.48;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.2.6.4;

1.2.6.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.2.6.5;

1.2.6.5
date	2002.03.28.14.54.27;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.06.11.03.33.04;	author art;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2002.11.04.18.02.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@new function uvm_hibswap() finds a the largest free zone in swap, which
hibernate can use place the data.
ok mlarkin
@
text
@/*	$OpenBSD: uvm_swap.h,v 1.15 2012/07/11 16:00:15 mlarkin Exp $	*/
/*	$NetBSD: uvm_swap.h,v 1.5 2000/01/11 06:57:51 chs Exp $	*/

/*
 * Copyright (c) 1997 Matthew R. Green
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * from: Id: uvm_swap.h,v 1.1.2.6 1997/12/15 05:39:31 mrg Exp
 */

#ifndef _UVM_UVM_SWAP_H_
#define _UVM_UVM_SWAP_H_

#define	SWSLOT_BAD	(-1)

#ifdef _KERNEL

int			uvm_swap_get(struct vm_page *, int, int);
int			uvm_swap_put(int, struct vm_page **, int, int);
int			uvm_swap_alloc(int *, boolean_t);
void			uvm_swap_free(int, int);
void			uvm_swap_markbad(int, int);
void			uvm_swap_freepages(struct vm_page **, int);
#ifdef HIBERNATE
int			uvm_hibswap(dev_t, u_long *, u_long *);
#endif /* HIBERNATE */
#ifdef UVM_SWAP_ENCRYPT
void			uvm_swap_initcrypt_all(void);
void			uvm_swap_finicrypt_all(void);
#endif

#endif /* _KERNEL */

#endif /* _UVM_UVM_SWAP_H_ */
@


1.15
log
@

#ifdef the uvm swap checker fn for hibernate only, to save space in kernels
that don't use hibernate

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.14 2012/07/11 10:07:40 mlarkin Exp $	*/
d48 1
a48 1
int			uvm_swap_check_range(dev_t, size_t);
@


1.14
log
@

add uvm_swap_check_range to scan for contig free space at end of swap.
will be needed shortly for hibernate.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.13 2010/07/01 19:48:05 oga Exp $	*/
d47 1
d49 1
@


1.13
log
@Allow swapping to happen in the case where where we have more memory
than we can realistically dma to.

In the swap encrypt case we already bounce through a intermediate buffer
for pageout, so just make sure that that buffer is constrained to
dmaable memory. In the other cases we check to see if the memory is
dmaable, then if not we bounce it.

ok beck@@, art@@, thib@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.12 2008/04/12 20:37:36 miod Exp $	*/
d47 1
@


1.12
log
@Prune the in-use swap encryption keys in uvm_shutdown(), per deraadt@@'s idea.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.11 2002/03/14 01:27:19 millert Exp $	*/
d46 1
a48 1
void			uvm_swap_freepages(struct vm_page **, int);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.10 2001/11/10 18:42:32 art Exp $	*/
d49 1
@


1.10
log
@Merge in some parts of the ubc work that has been done in NetBSD that are not
UBC, but prerequsites for it.

- Create a daemon that processes async I/O (swap and paging in the future)
  requests that need processing in process context and that were processed
  in the pagedaemon before.
- Convert some ugly ifdef DIAGNOSTIC code to less intrusive KASSERTs.
- misc other cleanups.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.9 2001/11/07 02:55:51 art Exp $	*/
d41 5
a45 5
int			uvm_swap_get __P((struct vm_page *, int, int));
int			uvm_swap_put __P((int, struct vm_page **, int, int));
int			uvm_swap_alloc __P((int *, boolean_t));
void			uvm_swap_free __P((int, int));
void			uvm_swap_markbad __P((int, int));
d47 2
a48 2
void			uvm_swap_initcrypt_all __P((void));
void			uvm_swap_freepages __P((struct vm_page **, int));
@


1.10.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.10 2001/11/10 18:42:32 art Exp $	*/
d41 5
a45 5
int			uvm_swap_get(struct vm_page *, int, int);
int			uvm_swap_put(int, struct vm_page **, int, int);
int			uvm_swap_alloc(int *, boolean_t);
void			uvm_swap_free(int, int);
void			uvm_swap_markbad(int, int);
d47 2
a48 2
void			uvm_swap_initcrypt_all(void);
void			uvm_swap_freepages(struct vm_page **, int);
@


1.10.2.2
log
@Huge sync to NetBSD plus lots of bugfixes.
 - uvm is as in netbsd-current minus uvm_map forward merge.
 - various locking bugfixes in nfs.
 - make sure that all specops and fifoops are correct in all vnodeop vectors.
 - make the filesystem code more like filsystem code and less like vm code.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_swap.h,v 1.10.2.1 2002/06/11 03:33:04 art Exp $	*/
/*	$NetBSD: uvm_swap.h,v 1.6 2002/03/18 11:43:01 manu Exp $	*/
a40 2
struct swapent;

a45 2
void			uvm_swap_stats(int, struct swapent *,
			    int, register_t *);
@


1.9
log
@Another sync of uvm to NetBSD. Just minor fiddling, no major changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.8 2001/07/26 19:37:13 art Exp $	*/
d48 1
@


1.8
log
@Add support for disabling swap devices (swapctl -d).
Improve error handling on I/O errors to swap.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.7 2001/03/22 03:05:57 smart Exp $	*/
d37 1
a37 1
#define SWSLOT_BAD	(-1)
@


1.7
log
@Sync style, typo, and comments a little closer to NetBSD.  art@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_swap.h,v 1.6 2001/03/09 05:34:38 smart Exp $	*/
/*	$NetBSD: uvm_swap.h,v 1.4 1999/06/21 17:25:12 thorpej Exp $	*/
d37 2
d45 1
a45 1

@


1.6
log
@Protect protypes, certain macros, and inlines from userland.  Checked userland
with a 'make build'.  From NetBSD.  art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap.h,v 1.5 2001/01/29 02:07:49 niklas Exp $	*/
d40 3
a42 4
int			uvm_swap_put __P((int, struct vm_page **, int,
			    int));
int			uvm_swap_alloc __P((int *wanted, boolean_t lessok));
void			uvm_swap_free __P((int startslot, int nslots));
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: uvm_swap.h,v 1.3 1998/02/07 11:09:48 mrg Exp $	*/
/*	$NetBSD: uvm_swap.h,v 1.3 1998/02/07 11:09:48 mrg Exp $	*/
d37 2
d48 3
@


1.4
log
@postpone memory allocation for uvm swap encryption until it is turned on with
sysctl.
@
text
@d1 1
@


1.3
log
@Fix the NetBSD id strings.
@
text
@d42 3
@


1.2
log
@add OpenBSD tags
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.2.6.1
log
@Sync with -current
@
text
@d1 1
a42 3
#ifdef UVM_SWAP_ENCRYPT
void			uvm_swap_initcrypt_all __P((void));
#endif
@


1.2.6.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 2
/*	$OpenBSD: uvm_swap.h,v 1.7 2001/03/22 03:05:57 smart Exp $	*/
/*	$NetBSD: uvm_swap.h,v 1.4 1999/06/21 17:25:12 thorpej Exp $	*/
a35 2
#ifdef _KERNEL

d37 4
a40 3
int			uvm_swap_put __P((int, struct vm_page **, int, int));
int			uvm_swap_alloc __P((int *, boolean_t));
void			uvm_swap_free __P((int, int));
a44 3

#endif /* _KERNEL */

@


1.2.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvm_swap.h,v 1.5 2000/01/11 06:57:51 chs Exp $	*/
a36 2
#define SWSLOT_BAD	(-1)

d43 1
a43 1
void			uvm_swap_markbad __P((int, int));
@


1.2.6.4
log
@merge in -current
@
text
@d37 1
a37 1
#define	SWSLOT_BAD	(-1)
a47 1
void			uvm_swap_freepages __P((struct vm_page **, int));
@


1.2.6.5
log
@Merge in -current from roughly a week ago
@
text
@d41 5
a45 5
int			uvm_swap_get(struct vm_page *, int, int);
int			uvm_swap_put(int, struct vm_page **, int, int);
int			uvm_swap_alloc(int *, boolean_t);
void			uvm_swap_free(int, int);
void			uvm_swap_markbad(int, int);
d47 2
a48 2
void			uvm_swap_initcrypt_all(void);
void			uvm_swap_freepages(struct vm_page **, int);
@


1.1
log
@Import of uvm from NetBSD. Some local changes, some code disabled
@
text
@d1 1
@

