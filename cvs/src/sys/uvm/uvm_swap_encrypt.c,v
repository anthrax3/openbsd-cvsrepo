head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.8
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.22.0.10
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.17.0.18
	OPENBSD_5_6_BASE:1.17
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.14.0.16
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.14
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.12
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.10
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.6
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.4
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.4
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.10.0.2
	UBC_BASE:1.10
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	SMP:1.1.0.2
	SMP_BASE:1.1;
locks; strict;
comment	@ * @;


1.22
date	2015.05.06.04.00.10;	author dlg;	state Exp;
branches;
next	1.21;
commitid	B7QBP4rg1P9WFyqZ;

1.21
date	2015.05.04.10.21.15;	author dlg;	state Exp;
branches;
next	1.20;
commitid	dd7E1ky1UwQRrLhI;

1.20
date	2015.03.14.03.38.53;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.11.18.02.37.31;	author tedu;	state Exp;
branches;
next	1.18;
commitid	Z1vcFtHO8wRH0yRt;

1.18
date	2014.09.14.14.17.27;	author jsg;	state Exp;
branches;
next	1.17;
commitid	uzzBR7hz9ncd4O6G;

1.17
date	2011.01.11.15.42.06;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.20.22.05.44;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.03.23.22.07.41;	author oga;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.26.16.06.46;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.29.23.01.37;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.26.10.04.49;	author markus;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.02.19.38.55;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.06.19.53.21;	author miod;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.08.24.15.59.42;	author markus;	state Exp;
branches;
next	1.8;

1.8
date	2001.08.06.22.34.44;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.29.02.07.49;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.07.20.15.28;	author art;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.14.16.51.55;	author provos;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.27.21.06.08;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.15.18.29;	author provos;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.29.11.16.45;	author markus;	state Exp;
branches;
next	1.1;

1.1
date	99.12.30.18.21.55;	author provos;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.03.02.07.04.48;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.47.48;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.32.14;	author nate;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.11.13.23.02.31;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.08.48;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2004.02.19.11.01.45;	author niklas;	state Exp;
branches;
next	;

1.10.2.1
date	2002.10.29.00.36.50;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@make SWAP_KEY_GET symmetrical with SWAP_KEY_PUT by having it call
a function in uvm_swap_encrypt.c instead of doing stuff inline.

lets me remove an extern from the header too.

ok kettenis@@
@
text
@/*	$OpenBSD: uvm_swap_encrypt.c,v 1.21 2015/05/04 10:21:15 dlg Exp $	*/

/*
 * Copyright 1999 Niels Provos <provos@@citi.umich.edu>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Niels Provos.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>
#include <sys/time.h>
#include <crypto/rijndael.h>

#include <uvm/uvm.h>
#include <uvm/uvm_swap_encrypt.h>

struct swap_key *kcur = NULL;
rijndael_ctx swap_ctxt;

int uvm_doswapencrypt = 1;
u_int uvm_swpkeyscreated = 0;
u_int uvm_swpkeysdeleted = 0;

int swap_encrypt_initialized = 0;

int
swap_encrypt_ctl(int *name, u_int namelen, void *oldp, size_t *oldlenp,
    void *newp, size_t newlen, struct proc *p)
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case SWPENC_ENABLE: {
		int doencrypt = uvm_doswapencrypt;
		int result;

		result = sysctl_int(oldp, oldlenp, newp, newlen, &doencrypt);
		if (result)
			return result;

		/*
		 * Swap Encryption has been turned on, we need to
		 * initialize state for swap devices that have been
		 * added.
		 */
		if (doencrypt)
			uvm_swap_initcrypt_all();
		uvm_doswapencrypt = doencrypt;
		return (0);
	}
	case SWPENC_CREATED:
		return (sysctl_rdint(oldp, oldlenp, newp, uvm_swpkeyscreated));
	case SWPENC_DELETED:
		return (sysctl_rdint(oldp, oldlenp, newp, uvm_swpkeysdeleted));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}

void
swap_key_create(struct swap_key *key)
{
	arc4random_buf(key->key, sizeof(key->key));
	uvm_swpkeyscreated++;
}

void
swap_key_delete(struct swap_key *key)
{
	/* Make sure that this key gets removed if we just used it */
	swap_key_cleanup(key);

	explicit_bzero(key, sizeof(*key));
	uvm_swpkeysdeleted++;
}

/*
 * Encrypt the data before it goes to swap, the size should be 64-bit
 * aligned.
 */

void
swap_encrypt(struct swap_key *key, caddr_t src, caddr_t dst, u_int64_t block,
    size_t count)
{
	u_int32_t *dsrc = (u_int32_t *)src;
	u_int32_t *ddst = (u_int32_t *)dst;
	u_int32_t iv[4];
	u_int32_t iv1, iv2, iv3, iv4;

	if (!swap_encrypt_initialized)
		swap_encrypt_initialized = 1;

	swap_key_prepare(key, 1);

	count /= sizeof(u_int32_t);

	iv[0] = block >> 32; iv[1] = block; iv[2] = ~iv[0]; iv[3] = ~iv[1];
	rijndael_encrypt(&swap_ctxt, (u_char *)iv, (u_char *)iv); 
	iv1 = iv[0]; iv2 = iv[1]; iv3 = iv[2]; iv4 = iv[3];

	for (; count > 0; count -= 4) {
		ddst[0] = dsrc[0] ^ iv1;
		ddst[1] = dsrc[1] ^ iv2;
		ddst[2] = dsrc[2] ^ iv3;
		ddst[3] = dsrc[3] ^ iv4;
		/*
		 * Do not worry about endianess, it only needs to decrypt
		 * on this machine.
		 */
		rijndael_encrypt(&swap_ctxt, (u_char *)ddst, (u_char *)ddst);
		iv1 = ddst[0];
		iv2 = ddst[1];
		iv3 = ddst[2];
		iv4 = ddst[3];

		dsrc += 4;
		ddst += 4;
	}
}

/*
 * Decrypt the data after we retrieved it from swap, the size should be 64-bit
 * aligned.
 */

void
swap_decrypt(struct swap_key *key, caddr_t src, caddr_t dst, u_int64_t block,
    size_t count)
{
	u_int32_t *dsrc = (u_int32_t *)src;
	u_int32_t *ddst = (u_int32_t *)dst;
	u_int32_t iv[4];
	u_int32_t iv1, iv2, iv3, iv4, niv1, niv2, niv3, niv4;

	if (!swap_encrypt_initialized)
		panic("swap_decrypt: key not initialized");

	swap_key_prepare(key, 0);

	count /= sizeof(u_int32_t);

	iv[0] = block >> 32; iv[1] = block; iv[2] = ~iv[0]; iv[3] = ~iv[1];
	rijndael_encrypt(&swap_ctxt, (u_char *)iv, (u_char *)iv); 
	iv1 = iv[0]; iv2 = iv[1]; iv3 = iv[2]; iv4 = iv[3];

	for (; count > 0; count -= 4) {
		ddst[0] = niv1 = dsrc[0];
		ddst[1] = niv2 = dsrc[1];
		ddst[2] = niv3 = dsrc[2];
		ddst[3] = niv4 = dsrc[3];
		rijndael_decrypt(&swap_ctxt, (u_char *)ddst, (u_char *)ddst);
		ddst[0] ^= iv1;
		ddst[1] ^= iv2;
		ddst[2] ^= iv3;
		ddst[3] ^= iv4;

		iv1 = niv1;
		iv2 = niv2;
		iv3 = niv3;
		iv4 = niv4;

		dsrc += 4;
		ddst += 4;
	}
}

void
swap_key_prepare(struct swap_key *key, int encrypt)
{
	/*
	 * Check if we have prepared for this key already,
	 * if we only have the encryption schedule, we have
	 * to recompute and get the decryption schedule also.
	 */
	if (kcur == key && (encrypt || !swap_ctxt.enc_only))
		return;

	if (encrypt)
		rijndael_set_key_enc_only(&swap_ctxt, (u_char *)key->key,
		    sizeof(key->key) * 8);
	else
		rijndael_set_key(&swap_ctxt, (u_char *)key->key,
		    sizeof(key->key) * 8);

	kcur = key;
}

/*
 * Make sure that a specific key is no longer available.
 */

void
swap_key_cleanup(struct swap_key *key)
{
	/* Check if we have a key */
	if (kcur == NULL || kcur != key)
		return;

	/* Zero out the subkeys */
	explicit_bzero(&swap_ctxt, sizeof(swap_ctxt));

	kcur = NULL;
}
@


1.21
log
@reduce the scope of things that include uvm_swap_encrypt.h.

uvm_meter.c needs it to route the sysctl, uvm_swap.c needs it to
use the functionality, and uvm_swap_encrypt.c needs it to for obvious
reasons. userland sysctl already includes it explicitely.

everything else doesnt and shouldnt care.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.20 2015/03/14 03:38:53 jsg Exp $	*/
d88 7
@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.19 2014/11/18 02:37:31 tedu Exp $	*/
d42 1
@


1.19
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.18 2014/09/14 14:17:27 jsg Exp $	*/
a38 1
#include <sys/conf.h>
@


1.18
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.17 2011/01/11 15:42:06 deraadt Exp $	*/
a39 1
#include <dev/rndvar.h>
@


1.17
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.16 2010/04/20 22:05:44 tedu Exp $	*/
a36 1
#include <sys/proc.h>
@


1.16
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.15 2009/03/23 22:07:41 oga Exp $	*/
d98 1
a98 1
	memset(key, 0, sizeof(*key));
d226 1
a226 1
	memset(&swap_ctxt, 0, sizeof(swap_ctxt));
@


1.15
log
@turn a for (i = 0; i < size; i++) arc4random(); loop into arc4random_buf().

Since that function is now so small (2 lines), inline it into it's only user.

Shaves some bytes (104 on amd64).

ok deraadt@@, blambert@@. djm@@ liked an earlier diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.14 2005/03/26 16:06:46 deraadt Exp $	*/
d37 1
@


1.14
log
@encrypt swap by default.  cheap, and why not.  can be disabled by people
who have machines that hit swap a lot.  decided after survey of developers,
we found that most turned this on.  ok various
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.14 2005/03/26 15:53:16 deraadt Exp $	*/
a88 13
}

void
swap_key_create(struct swap_key *key)
{
	int i;
	u_int32_t *p = key->key;

	key->refcount = 0;
	for (i = 0; i < sizeof(key->key) / sizeof(u_int32_t); i++)
		*p++ = arc4random();

	uvm_swpkeyscreated++;
@


1.13
log
@ansi + some knf, no binary change

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.12 2003/12/26 10:04:49 markus Exp $	*/
d48 1
a48 1
int uvm_doswapencrypt = 0;
@


1.12
log
@- use 1/2 space for rijndael context in ipsec
- rijndael_set_key_enc_only()  sets up context for encryption only
- rijndael_set_key() always sets up full context
- rijndaelKeySetupDec() gets back original protoype
- uvm: use _enc_only() interface
with hshoexer@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.11 2002/07/02 19:38:55 nate Exp $	*/
d55 2
a56 8
swap_encrypt_ctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
d71 2
a72 1
		/* Swap Encryption has been turned on, we need to
d74 1
a74 1
		 * added 
d120 2
a121 2
swap_encrypt(struct swap_key *key, caddr_t src, caddr_t dst,
	     u_int64_t block, size_t count)
d146 1
a146 1
		 * on this machine
d165 2
a166 2
swap_decrypt(struct swap_key *key, caddr_t src, caddr_t dst,
	     u_int64_t block, size_t count)
d208 2
a209 1
	/* Check if we have prepared for this key already,
d211 1
a211 1
	 * to recompute and get the decryption schedule also
d238 1
a238 1
       	memset(&swap_ctxt, 0, sizeof(swap_ctxt));
@


1.11
log
@inital -> initial
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.10 2001/11/06 19:53:21 miod Exp $	*/
d46 1
a46 1
rijndael_ctx swap_key;
d141 1
a141 1
	rijndael_encrypt(&swap_key, (u_char *)iv, (u_char *)iv); 
d153 1
a153 1
		rijndael_encrypt(&swap_key, (u_char *)ddst, (u_char *)ddst);
d186 1
a186 1
	rijndael_encrypt(&swap_key, (u_char *)iv, (u_char *)iv); 
d194 1
a194 1
		rijndael_decrypt(&swap_key, (u_char *)ddst, (u_char *)ddst);
d215 1
a215 1
	 * to recompute ang get the decryption schedule also
d217 1
a217 1
	if (kcur == key && (encrypt || swap_key.decrypt))
d220 6
a225 3
	rijndael_set_key(&swap_key, (u_char *)key->key,
			 sizeof(key->key) * 8,
			 encrypt);
d242 1
a242 1
       	memset(&swap_key, 0, sizeof(swap_key));
@


1.10
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.9 2001/08/24 15:59:42 markus Exp $	*/
d52 1
a52 1
int swap_encrypt_initalized = 0;
d78 1
a78 1
		 * initalize state for swap devices that have been
d133 2
a134 2
	if (!swap_encrypt_initalized)
		swap_encrypt_initalized = 1;
d178 2
a179 2
	if (!swap_encrypt_initalized)
		panic("swap_decrypt: key not initalized");
@


1.10.2.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.10 2001/11/06 19:53:21 miod Exp $	*/
d52 1
a52 1
int swap_encrypt_initialized = 0;
d78 1
a78 1
		 * initialize state for swap devices that have been
d133 2
a134 2
	if (!swap_encrypt_initialized)
		swap_encrypt_initialized = 1;
d178 2
a179 2
	if (!swap_encrypt_initialized)
		panic("swap_decrypt: key not initialized");
@


1.9
log
@switch to the optimised AES reference code from
http://www.esat.kuleuven.ac.be/~rijmen/rijndael/rijndael-fst-3.0.zip
the same code is used by ssh, so please make sure to update
usr.sbin/ssh/rijndael.c if you change this code.
tested on sparc (jason) and with swap encryption (me); ok deraadt@@, provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.8 2001/08/06 22:34:44 mickey Exp $	*/
a41 2

#include <vm/vm.h>
@


1.8
log
@remove vm_conf.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.7 2001/01/29 02:07:49 niklas Exp $	*/
d143 1
a143 1
	rijndael_encrypt(&swap_key, iv, iv); 
d155 1
a155 1
		rijndael_encrypt(&swap_key, ddst, ddst);
d188 1
a188 1
	rijndael_encrypt(&swap_key, iv, iv); 
d196 1
a196 1
		rijndael_decrypt(&swap_key, ddst, ddst);
d222 1
a222 1
	rijndael_set_key(&swap_key, key->key,
@


1.7
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d39 1
a43 1
#include <vm/vm_conf.h>
@


1.6
log
@Convert bzero to memset(X, 0..) and bcopy to memcpy.
This is to match (make diffs smaller) the code in NetBSD.
new gcc inlines those functions, so this could also be a performance win.
@
text
@d1 2
@


1.5
log
@put in own ctl level for swapencrypt.
@
text
@d115 1
a115 1
	bzero(key, sizeof(*key));
d239 1
a239 1
	bzero(&swap_key, sizeof(swap_key));
@


1.4
log
@use rijndael instead of blowfish because of faster key setup.
break swap paritions into sections, each section has own
encryption key.  if a section's key becomes unreferenced, erase it.
@
text
@d35 1
d53 42
@


1.3
log
@use encrypted blocknumber as IV
@
text
@d33 3
d37 1
a37 1
#include <crypto/blf.h>
d39 2
a40 1
#include <uvm/uvm_swap_encrypt.h>
d42 4
a45 1
blf_ctx swap_key;
d48 3
a52 5
/*
 * Initalize the key from the kernel random number generator.  This is
 * done once on startup.
 */

d54 1
a54 1
swap_encrypt_init(caddr_t data, size_t len)
d57 5
a61 1
	u_int32_t *key = (u_int32_t *)data;
d63 2
a64 2
	if (swap_encrypt_initalized)
		return;
d66 5
a70 2
	for (i = 0; i < len / sizeof(u_int32_t); i++)
		*key++ = arc4random();
d72 2
a73 1
	swap_encrypt_initalized = 1;
d82 2
a83 1
swap_encrypt(caddr_t src, caddr_t dst, u_int64_t block, size_t count)
d85 34
a118 26
  u_int32_t *dsrc = (u_int32_t *)src;
  u_int32_t *ddst = (u_int32_t *)dst;
  u_int32_t iv[2];
  u_int32_t iv1, iv2;

  if (!swap_encrypt_initalized)
	swap_encrypt_init((caddr_t)&swap_key, sizeof(swap_key));

  count /= sizeof(u_int32_t);

  iv[0] = block >> 32; iv[1] = block;
  Blowfish_encipher(&swap_key, iv);
  iv1 = iv[0]; iv2 = iv[1];
  for (; count > 0; count -= 2) {
    ddst[0] = dsrc[0] ^ iv1;
    ddst[1] = dsrc[1] ^ iv2;
    /*
     * Do not worry about endianess, it only needs to decrypt on this machine
     */
    Blowfish_encipher(&swap_key, ddst);
    iv1 = ddst[0];
    iv2 = ddst[1];

    dsrc += 2;
    ddst += 2;
  }
d127 42
a168 1
swap_decrypt(caddr_t src, caddr_t dst, u_int64_t block, size_t count)
d170 29
a198 26
  u_int32_t *dsrc = (u_int32_t *)src;
  u_int32_t *ddst = (u_int32_t *)dst;
  u_int32_t iv[2];
  u_int32_t iv1, iv2, niv1, niv2;

  if (!swap_encrypt_initalized)
    panic("swap_decrypt: key not initalized");

  count /= sizeof(u_int32_t);

  iv[0] = block >> 32; iv[1] = block;
  Blowfish_encipher(&swap_key, iv);
  iv1 = iv[0]; iv2 = iv[1];
  for (; count > 0; count -= 2) {
    ddst[0] = niv1 = dsrc[0];
    ddst[1] = niv2 = dsrc[1];
    Blowfish_decipher(&swap_key, ddst);
    ddst[0] ^= iv1;
    ddst[1] ^= iv2;

    iv1 = niv1;
    iv2 = niv2;

    dsrc += 2;
    ddst += 2;
  }
@


1.2
log
@<crypto/blf.h>
@
text
@d69 1
a69 1
swap_encrypt(caddr_t src, caddr_t dst, size_t count)
d73 1
d81 3
a83 1
  iv1 = iv2 = 0;
d105 1
a105 1
swap_decrypt(caddr_t src, caddr_t dst, size_t count)
d109 1
d117 3
a119 1
  iv1 = iv2 = 0;
@


1.1
log
@swap encryption for UVM, option UVM_SWAP_ENCRYPT.  needs to be enabled
via sysctl.
Pages are encrypted with the Blowfish encryption algorithm, the key
is initialized randomly on first swap out, ensuring that entropy has
accumulated in the kernel randomness pool.  Eventually, swap encryption
will be decided on a process by process basis, e.g. a process that reads from
a cryptographic filesystem will enable swap encrypt for its pages. okay
art@@ and deraadt@@.
@
text
@d34 1
a34 1
#include <netinet/ip_blf.h>
@


1.1.2.1
log
@Sync with -current
@
text
@d34 1
a34 1
#include <crypto/blf.h>
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 2
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.7 2001/01/29 02:07:49 niklas Exp $	*/

a32 4
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/sysctl.h>
#include <sys/time.h>
d34 1
a34 4
#include <crypto/rijndael.h>

#include <vm/vm.h>
#include <vm/vm_conf.h>
d36 1
a36 1
#include <uvm/uvm.h>
d38 1
a38 2
struct swap_key *kcur = NULL;
rijndael_ctx swap_key;
a40 3
u_int uvm_swpkeyscreated = 0;
u_int uvm_swpkeysdeleted = 0;

d43 4
a46 41
int
swap_encrypt_ctl(name, namelen, oldp, oldlenp, newp, newlen, p)
	int *name;
	u_int namelen;
	void *oldp;
	size_t *oldlenp;
	void *newp;
	size_t newlen;
	struct proc *p;
{
	/* all sysctl names at this level are terminal */
	if (namelen != 1)
		return (ENOTDIR);		/* overloaded */

	switch (name[0]) {
	case SWPENC_ENABLE: {
		int doencrypt = uvm_doswapencrypt;
		int result;

		result = sysctl_int(oldp, oldlenp, newp, newlen, &doencrypt);
		if (result)
			return result;

		/* Swap Encryption has been turned on, we need to
		 * initalize state for swap devices that have been
		 * added 
		 */
		if (doencrypt)
			uvm_swap_initcrypt_all();
		uvm_doswapencrypt = doencrypt;
		return (0);
	}
	case SWPENC_CREATED:
		return (sysctl_rdint(oldp, oldlenp, newp, uvm_swpkeyscreated));
	case SWPENC_DELETED:
		return (sysctl_rdint(oldp, oldlenp, newp, uvm_swpkeysdeleted));
	default:
		return (EOPNOTSUPP);
	}
	/* NOTREACHED */
}
d49 1
a49 1
swap_key_create(struct swap_key *key)
d52 1
a52 1
	u_int32_t *p = key->key;
d54 2
a55 3
	key->refcount = 0;
	for (i = 0; i < sizeof(key->key) / sizeof(u_int32_t); i++)
		*p++ = arc4random();
d57 2
a58 8
	uvm_swpkeyscreated++;
}

void
swap_key_delete(struct swap_key *key)
{
	/* Make sure that this key gets removed if we just used it */
	swap_key_cleanup(key);
d60 1
a60 2
	memset(key, 0, sizeof(*key));
	uvm_swpkeysdeleted++;
d69 1
a69 2
swap_encrypt(struct swap_key *key, caddr_t src, caddr_t dst,
	     u_int64_t block, size_t count)
d71 23
a93 34
	u_int32_t *dsrc = (u_int32_t *)src;
	u_int32_t *ddst = (u_int32_t *)dst;
	u_int32_t iv[4];
	u_int32_t iv1, iv2, iv3, iv4;

	if (!swap_encrypt_initalized)
		swap_encrypt_initalized = 1;

	swap_key_prepare(key, 1);

	count /= sizeof(u_int32_t);

	iv[0] = block >> 32; iv[1] = block; iv[2] = ~iv[0]; iv[3] = ~iv[1];
	rijndael_encrypt(&swap_key, iv, iv); 
	iv1 = iv[0]; iv2 = iv[1]; iv3 = iv[2]; iv4 = iv[3];

	for (; count > 0; count -= 4) {
		ddst[0] = dsrc[0] ^ iv1;
		ddst[1] = dsrc[1] ^ iv2;
		ddst[2] = dsrc[2] ^ iv3;
		ddst[3] = dsrc[3] ^ iv4;
		/*
		 * Do not worry about endianess, it only needs to decrypt
		 * on this machine
		 */
		rijndael_encrypt(&swap_key, ddst, ddst);
		iv1 = ddst[0];
		iv2 = ddst[1];
		iv3 = ddst[2];
		iv4 = ddst[3];

		dsrc += 4;
		ddst += 4;
	}
d102 1
a102 2
swap_decrypt(struct swap_key *key, caddr_t src, caddr_t dst,
	     u_int64_t block, size_t count)
d104 23
a126 69
	u_int32_t *dsrc = (u_int32_t *)src;
	u_int32_t *ddst = (u_int32_t *)dst;
	u_int32_t iv[4];
	u_int32_t iv1, iv2, iv3, iv4, niv1, niv2, niv3, niv4;

	if (!swap_encrypt_initalized)
		panic("swap_decrypt: key not initalized");

	swap_key_prepare(key, 0);

	count /= sizeof(u_int32_t);

	iv[0] = block >> 32; iv[1] = block; iv[2] = ~iv[0]; iv[3] = ~iv[1];
	rijndael_encrypt(&swap_key, iv, iv); 
	iv1 = iv[0]; iv2 = iv[1]; iv3 = iv[2]; iv4 = iv[3];

	for (; count > 0; count -= 4) {
		ddst[0] = niv1 = dsrc[0];
		ddst[1] = niv2 = dsrc[1];
		ddst[2] = niv3 = dsrc[2];
		ddst[3] = niv4 = dsrc[3];
		rijndael_decrypt(&swap_key, ddst, ddst);
		ddst[0] ^= iv1;
		ddst[1] ^= iv2;
		ddst[2] ^= iv3;
		ddst[3] ^= iv4;

		iv1 = niv1;
		iv2 = niv2;
		iv3 = niv3;
		iv4 = niv4;

		dsrc += 4;
		ddst += 4;
	}
}

void
swap_key_prepare(struct swap_key *key, int encrypt)
{
	/* Check if we have prepared for this key already,
	 * if we only have the encryption schedule, we have
	 * to recompute ang get the decryption schedule also
	 */
	if (kcur == key && (encrypt || swap_key.decrypt))
		return;

	rijndael_set_key(&swap_key, key->key,
			 sizeof(key->key) * 8,
			 encrypt);

	kcur = key;
}

/*
 * Make sure that a specific key is no longer available.
 */

void
swap_key_cleanup(struct swap_key *key)
{
	/* Check if we have a key */
	if (kcur == NULL || kcur != key)
		return;

	/* Zero out the subkeys */
       	memset(&swap_key, 0, sizeof(swap_key));

	kcur = NULL;
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uvm_swap_encrypt.c,v 1.1.2.2 2001/05/14 22:47:48 niklas Exp $	*/
a38 1
#include <sys/conf.h>
d43 1
d143 1
a143 1
	rijndael_encrypt(&swap_key, (u_char *)iv, (u_char *)iv); 
d155 1
a155 1
		rijndael_encrypt(&swap_key, (u_char *)ddst, (u_char *)ddst);
d188 1
a188 1
	rijndael_encrypt(&swap_key, (u_char *)iv, (u_char *)iv); 
d196 1
a196 1
		rijndael_decrypt(&swap_key, (u_char *)ddst, (u_char *)ddst);
d222 1
a222 1
	rijndael_set_key(&swap_key, (u_char *)key->key,
@


1.1.2.4
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 2
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d52 1
a52 1
int swap_encrypt_initialized = 0;
d78 1
a78 1
		 * initialize state for swap devices that have been
d133 2
a134 2
	if (!swap_encrypt_initialized)
		swap_encrypt_initialized = 1;
d178 2
a179 2
	if (!swap_encrypt_initialized)
		panic("swap_decrypt: key not initialized");
@


1.1.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d46 1
a46 1
rijndael_ctx swap_ctxt;
d141 1
a141 1
	rijndael_encrypt(&swap_ctxt, (u_char *)iv, (u_char *)iv); 
d153 1
a153 1
		rijndael_encrypt(&swap_ctxt, (u_char *)ddst, (u_char *)ddst);
d186 1
a186 1
	rijndael_encrypt(&swap_ctxt, (u_char *)iv, (u_char *)iv); 
d194 1
a194 1
		rijndael_decrypt(&swap_ctxt, (u_char *)ddst, (u_char *)ddst);
d215 1
a215 1
	 * to recompute and get the decryption schedule also
d217 1
a217 1
	if (kcur == key && (encrypt || !swap_ctxt.enc_only))
d220 3
a222 6
	if (encrypt)
		rijndael_set_key_enc_only(&swap_ctxt, (u_char *)key->key,
		    sizeof(key->key) * 8);
	else
		rijndael_set_key(&swap_ctxt, (u_char *)key->key,
		    sizeof(key->key) * 8);
d239 1
a239 1
       	memset(&swap_ctxt, 0, sizeof(swap_ctxt));
@


