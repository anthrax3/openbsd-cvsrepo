head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.2
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.35.0.4
	OPENBSD_6_0_BASE:1.35
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.8
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.28.0.6
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.25.0.10
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.6
	OPENBSD_5_0:1.25.0.4
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.11.0.2
	OPENBSD_4_4_BASE:1.11;
locks; strict;
comment	@ * @;


1.37
date	2017.02.28.07.07.07;	author claudio;	state Exp;
branches;
next	1.36;
commitid	XvBOPA3dTZdG2FZH;

1.36
date	2017.02.27.19.16.56;	author claudio;	state Exp;
branches;
next	1.35;
commitid	Ukq2QkllmG8rHpFv;

1.35
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.34;
commitid	bBZq0t5zueGnkAtX;

1.34
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.33;
commitid	9x7oePEcDKgC05vn;

1.33
date	2015.07.20.22.16.41;	author rzalamena;	state Exp;
branches;
next	1.32;
commitid	yaHvJbufOxtjWSFd;

1.32
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.31;
commitid	t2fhFUpUuj89g4Sj;

1.31
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.30;
commitid	c7ei8kPelCOOwHXy;

1.30
date	2015.03.26.11.02.44;	author mpi;	state Exp;
branches;
next	1.29;
commitid	0DQqDmKCmYNj6g7x;

1.29
date	2015.01.15.23.50.31;	author deraadt;	state Exp;
branches;
next	1.28;
commitid	zxBqxs0ajs184AMe;

1.28
date	2013.04.24.10.20.15;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.03.27.02.00.08;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2010.09.08.08.00.56;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.09.11.40.36;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.02.15.41.06;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.28.12.09.10;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.28.12.07.43;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.17.12.10.08;	author michele;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.03.16.42.54;	author michele;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.29.11.11.33;	author michele;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.16;

1.16
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.15;

1.15
date	2008.12.15.16.13.55;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.01.16.37.55;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2008.10.28.01.16.14;	author michele;	state Exp;
branches;
next	1.12;

1.12
date	2008.10.14.20.43.33;	author michele;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.23.16.03.03;	author thib;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.09.15.08.36;	author claudio;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.08.03.18.39;	author claudio;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.07.08.00.50;	author pyr;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.07.07.16.49;	author pyr;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.07.06.53.42;	author pyr;	state Exp;
branches;
next	1.5;

1.5
date	2008.05.06.13.33.50;	author pyr;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.30.07.39.48;	author norby;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.23.12.28.49;	author norby;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.23.11.22.23;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.23.11.00.35;	author norby;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove mpls_raw_usrreq() prototype, that function is gone.
@
text
@/*	$OpenBSD: mpls.h,v 1.36 2017/02/27 19:16:56 claudio Exp $	*/

/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

#ifndef _NETMPLS_MPLS_H_
#define _NETMPLS_MPLS_H_

/*
 * Structure of a SHIM header.
 */
#define MPLS_LABEL_MAX		((1 << 20) - 1)

struct shim_hdr {
	u_int32_t shim_label;	/* 20 bit label, 4 bit exp & BoS, 8 bit TTL */
};

#define MPLS_HDRLEN	sizeof(struct shim_hdr)

/*
 * By byte-swapping the constants, we avoid ever having to byte-swap IP
 * addresses inside the kernel.  Unfortunately, user-level programs rely
 * on these macros not doing byte-swapping.
 */

#ifdef _KERNEL
#define __MADDR(x)     ((u_int32_t)htonl((u_int32_t)(x)))
#else
#define __MADDR(x)     ((u_int32_t)(x))
#endif

#define MPLS_LABEL_MASK		__MADDR(0xfffff000U)
#define MPLS_LABEL_OFFSET	12
#define MPLS_EXP_MASK		__MADDR(0x00000e00U)
#define MPLS_EXP_OFFSET		9
#define MPLS_BOS_MASK		__MADDR(0x00000100U)
#define MPLS_BOS_OFFSET		8
#define MPLS_TTL_MASK		__MADDR(0x000000ffU)

#define CW_ZERO_MASK		__MADDR(0xf0000000U)
#define CW_FRAG_MASK		__MADDR(0x00300000U)

#define MPLS_BOS_ISSET(l)	(((l) & MPLS_BOS_MASK) == MPLS_BOS_MASK)

/* Reserved lavel values (RFC3032) */
#define MPLS_LABEL_IPV4NULL	0               /* IPv4 Explicit NULL Label */
#define MPLS_LABEL_RTALERT	1               /* Router Alert Label       */
#define MPLS_LABEL_IPV6NULL	2               /* IPv6 Explicit NULL Label */
#define MPLS_LABEL_IMPLNULL	3               /* Implicit NULL Label      */
/*      MPLS_LABEL_RESERVED	4-15 */		/* Values 4-15 are reserved */
#define MPLS_LABEL_RESERVED_MAX 15

/*
 * Socket address
 */

struct sockaddr_mpls {
	u_int8_t	smpls_len;		/* length */
	u_int8_t	smpls_family;		/* AF_MPLS */
	u_int16_t	smpls_pad0;
	u_int32_t	smpls_label;		/* MPLS label */
	u_int32_t	smpls_pad1[2];
};

struct rt_mpls {
	u_int32_t	mpls_label;
	u_int8_t	mpls_operation;
	u_int8_t	mpls_exp;
};

#define MPLS_OP_LOCAL		0x0
#define MPLS_OP_POP		0x1
#define MPLS_OP_PUSH		0x2
#define MPLS_OP_SWAP		0x4

#define MPLS_INKERNEL_LOOP_MAX	16

#define satosmpls(sa)		((struct sockaddr_mpls *)(sa))
#define smplstosa(smpls)	((struct sockaddr *)(smpls))

/*
 * Names for MPLS sysctl objects
 */
#define MPLSCTL_ENABLE			1
#define	MPLSCTL_DEFTTL			2
#define	MPLSCTL_MAXINKLOOP		4
#define MPLSCTL_MAPTTL_IP		5
#define MPLSCTL_MAPTTL_IP6		6
#define MPLSCTL_MAXID			7	

#define MPLSCTL_NAMES { \
	{ NULL, 0 }, \
	{ NULL, 0 }, \
	{ "ttl", CTLTYPE_INT }, \
	{ "ifq", CTLTYPE_NODE },\
	{ "maxloop_inkernel", CTLTYPE_INT }, \
	{ "mapttl_ip", CTLTYPE_INT }, \
	{ "mapttl_ip6", CTLTYPE_INT } \
}

#define MPLSCTL_VARS { \
	NULL, \
	NULL, \
	&mpls_defttl, \
	NULL, \
	&mpls_inkloop, \
	&mpls_mapttl_ip, \
	&mpls_mapttl_ip6 \
}

#define IMR_TYPE_NONE			0
#define IMR_TYPE_ETHERNET		1
#define IMR_TYPE_ETHERNET_TAGGED	2

#define IMR_FLAG_CONTROLWORD		0x1

struct ifmpwreq {
	uint32_t	imr_flags;
	uint32_t	imr_type; /* pseudowire type */
	struct		shim_hdr imr_lshim; /* local label */
	struct		shim_hdr imr_rshim; /* remote label */
	struct		sockaddr_storage imr_nexthop;
};

#endif

#ifdef _KERNEL

extern	struct domain mplsdomain;

struct mpe_softc {
	struct ifnet		sc_if;		/* the interface */
	struct ifaddr		sc_ifa;
	int			sc_unit;
	struct sockaddr_mpls	sc_smpls;
	LIST_ENTRY(mpe_softc)	sc_list;
};

#define MPE_HDRLEN	sizeof(struct shim_hdr)
#define MPE_MTU		1500
#define MPE_MTU_MIN	256
#define MPE_MTU_MAX	8192

void	mpe_input(struct mbuf *, struct ifnet *, struct sockaddr_mpls *,
	    u_int8_t);
void	mpe_input6(struct mbuf *, struct ifnet *, struct sockaddr_mpls *,
	    u_int8_t);

extern int		mpls_defttl;
extern int		mpls_mapttl_ip;
extern int		mpls_mapttl_ip6;
extern int		mpls_inkloop;


struct mbuf	*mpls_shim_pop(struct mbuf *);
struct mbuf	*mpls_shim_swap(struct mbuf *, struct rt_mpls *);
struct mbuf	*mpls_shim_push(struct mbuf *, struct rt_mpls *);

int		 mpls_output(struct ifnet *, struct mbuf *, struct sockaddr *,
		    struct rtentry *);
void		 mpls_input(struct mbuf *);

#endif /* _KERNEL */
@


1.36
log
@Retire the AF_MPLS protosw struct. Nothing is using it and the code was super
basic anyway. Simplifies the code a lot also by calling the mpls sysctl no
longer via the protosw but instead directly.
OK mpi@@ on a previous diff. Also tested by renato@@ who actually found a bug
which is now fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.35 2015/12/02 08:47:00 claudio Exp $	*/
a174 3

extern int mpls_raw_usrreq(struct socket *, int, struct mbuf *,
			struct mbuf *, struct mbuf *, struct proc *);
@


1.35
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.34 2015/07/29 00:04:03 rzalamena Exp $	*/
a184 2
void	mpls_init(void);

a188 1
int		 mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);
@


1.34
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.33 2015/07/20 22:16:41 rzalamena Exp $	*/
d194 1
a194 1
void		 mpls_input(struct ifnet *, struct mbuf *);
@


1.33
log
@Implemented MPLS pseudowire (mpw(4)) to be used with VPLS and VPWS.

ok mpi@@, claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.32 2015/07/20 21:16:39 rzalamena Exp $	*/
d194 1
a194 2
int		 mpls_install_handler(struct ifnet *);
void		 mpls_uninstall_handler(struct ifnet *);
@


1.32
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.31 2015/04/10 13:58:20 dlg Exp $	*/
d67 3
d137 14
@


1.31
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.30 2015/03/26 11:02:44 mpi Exp $	*/
a109 1
#define MPLSCTL_IFQUEUE			3
a161 1
extern struct niqueue	mplsintrq;	/* MPLS input queue */
a168 1
void	mplsintr(void);
a174 1
void		 mpls_input(struct mbuf *);
d177 2
@


1.30
log
@Use rt_ifa_add(9) and rt_ifa_del(9) to configure MPLS labels.

Since the removal of the link-layer ifa from "struct ifnet" it was
impossible to configure MPLS routes on mpe(4).  Because just like
enc(4), mpe(4) was abusing the link-layer ifa to attach its route
entries.

So explicitly pass a "glue" ifa to the routing layer.

From Rafael Zalamena who discovered this the hardway, thanks!

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.29 2015/01/15 23:50:31 deraadt Exp $	*/
d163 1
a163 1
extern struct ifqueue	mplsintrq;	/* MPLS input queue */
@


1.29
log
@Do not include 5 header files, including <sys/param.h>
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.28 2013/04/24 10:20:15 mpi Exp $	*/
d144 1
d146 1
a146 1
	struct shim_hdr		sc_shim;
@


1.28
log
@Move various extern declarations into their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.27 2013/03/27 02:00:08 tedu Exp $	*/
a34 7

#include <sys/param.h>
#include <sys/time.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>
@


1.27
log
@a little header cleanup. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.26 2013/03/26 13:19:26 mpi Exp $	*/
d147 2
d173 1
@


1.26
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.25 2010/09/08 08:00:56 claudio Exp $	*/
a37 1
#include <sys/proc.h>
@


1.25
log
@Map the TTL when building the initial MPLS stack from the encapsulated
packet. For IP and IPv6 the corresponding mapttl sysctl needs to be set.
This is needed to make traceroute work over MPLS.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.24 2010/06/09 11:40:36 claudio Exp $	*/
a168 1
extern int		mplsqmaxlen;	/* MPLS input queue length */
@


1.24
log
@Fix the pop operation to make PHP work again. When popping the last label
by a pop operation we need to forward the packet to the specified nexthop
as is. This is done by calling the interface output routine directly.
This is different to the local operation since that one injects the packets
into ip_input() via netisr.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.23 2010/06/02 15:41:06 claudio Exp $	*/
d171 3
@


1.23
log
@Kill the mpls enable sysctl knob. Since MPLS needs to be enabled explicitly
on each interface there is no need for yet another knob.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.22 2010/05/28 12:09:10 claudio Exp $	*/
a182 3

void		 mpls_ip_input(struct mbuf *, u_int8_t);
void		 mpls_ip6_input(struct mbuf *, u_int8_t);
@


1.22
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.21 2009/04/28 12:07:43 michele Exp $	*/
d125 2
a126 2
	{ 0, 0 }, \
	{ "enable", CTLTYPE_INT }, \
d131 1
a131 1
	{ "mapttl_ip6", CTLTYPE_INT }, \
d135 2
a136 2
	0, \
	&mpls_enable, \
d138 1
a138 1
	0, \
d141 1
a141 1
	&mpls_mapttl_ip6, \
a169 1
extern int		mpls_enable;
@


1.21
log
@Introduce a new dummy operation to easily handle packets that have to leave
the MPLS cloud and join ipv4/ipv6 stack.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.20 2009/04/17 12:10:08 michele Exp $	*/
d182 2
a183 1
struct mbuf	*mpls_output(struct mbuf *, struct rtentry *);
@


1.20
log
@Correctly handle packets that are leaving the MPLS cloud and
joining the ipv4/ipv6 stack.

Get also rid of the dependency on mpe(4) for packets not belonging
to VPN traffic.

ok laurent@@, ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.19 2009/02/03 16:42:54 michele Exp $	*/
d103 1
@


1.19
log
@Use our own flags to set the operations and not RTF_PROTOX.
Switch the padding field into a MPLS one in rt_msghdr to store
relevant informations.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.18 2009/01/29 11:11:33 michele Exp $	*/
d182 3
@


1.18
log
@mpls_operation have to be 2 bytes long to store
operations correctly

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.17 2009/01/28 22:18:44 michele Exp $	*/
d99 1
a99 1
	u_int16_t	mpls_operation;
d103 3
a105 3
#define MPLS_OP_POP		RTF_PROTO3
#define MPLS_OP_PUSH		RTF_PROTO2
#define MPLS_OP_SWAP		RTF_PROTO1
@


1.17
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.16 2009/01/08 12:47:45 michele Exp $	*/
d99 1
a99 1
	u_int8_t	mpls_operation;
@


1.16
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.15 2008/12/15 16:13:55 michele Exp $	*/
d97 7
a103 1
#define MPLS_OP_POP		RTF_PROTO1
d105 1
a105 1
#define MPLS_OP_SWAP		RTF_PROTO3
d176 2
a177 2
struct mbuf	*mpls_shim_swap(struct mbuf *, struct sockaddr_mpls *);
struct mbuf	*mpls_shim_push(struct mbuf *, struct sockaddr_mpls *);
d179 3
a181 3
int	mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);
void	mpls_input(struct mbuf *);
void	mpls_output(struct mbuf *);
@


1.15
log
@Initial fixup of sockaddr_mpls struct.

Remove smpls_in_iface as labels must be per platform unique.
Remove smpls_out_iface. It is redudant and can be inferred from nexthop.
Move smpls_operation to rt_flags and temporary remove smpls_out_exp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.14 2008/11/01 16:37:55 michele Exp $	*/
d53 2
d92 3
a94 2
	u_int32_t	smpls_out_label;	/* outgoing MPLS label */
	u_int32_t	smpls_in_label;		/* MPLS label 20 bits*/
@


1.14
log
@Introduced Uniform Model for TTL handling.
MPLS TTL is mapped into network layer one as the packet exits the LSP.
Just IPv4 support for now.
Added the relevant sysctls to enable this behaviour.

Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.13 2008/10/28 01:16:14 michele Exp $	*/
a89 2
	u_int8_t	smpls_operation;
	u_int8_t	smpls_out_exp;		/* outgoing exp value */
a90 2
	u_int16_t	smpls_out_ifindex;
	u_int16_t	smpls_in_ifindex;
a91 5
#if MPLS_MCAST
	u_int8_t smpls_mcexp;
	u_int8_t smpls_pad2[2];
	u_int32_t smpls_mclabel;
#endif
d94 3
a96 3
#define MPLS_OP_POP		1
#define MPLS_OP_PUSH		2
#define MPLS_OP_SWAP		3
@


1.13
log
@Added mpls_output() used to output mpls packets originating from local host.
Strictly similar to mpls_input().

Input and OK claudio@@, OK laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.12 2008/10/14 20:43:33 michele Exp $	*/
d119 3
a121 1
#define MPLSCTL_MAXID			5
d129 2
d139 2
d160 1
a160 1
	    u_int32_t);
d162 1
a162 1
	    u_int32_t);
@


1.12
log
@Now mpls_input() handles ipv4 and ipv6 explicit null labels.
Added mpe_input6 to manage also ipv6 packets insted of just ipv4 ones.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.11 2008/05/23 16:03:03 thib Exp $	*/
d175 1
@


1.11
log
@Make this compile again, by adding a struct proc * argument
to the usrreq's.

(Both MPLS and NETATALK are disabled in GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.10 2008/05/09 15:08:36 claudio Exp $	*/
d154 2
@


1.10
log
@Kill some useless makros.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.9 2008/05/08 03:18:39 claudio Exp $	*/
d157 1
a157 1
			struct mbuf *, struct mbuf *);
@


1.9
log
@Hook mpe(4) correctly into mpls so that it is possible to tunnel packets over
MPLS. Still a bit hackish but getting closer. hai norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.8 2008/05/07 08:00:50 pyr Exp $	*/
a110 2
#define satosdl(sa)		((struct sockaddr_dl *)(sa))
#define sdltosa(sdl)		((struct sockaddr *)(sdl))
@


1.8
log
@add mpe_input() to be able to be fed packets that will reenter ip.
no consumers yet, they should come soon.

ok norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.7 2008/05/07 07:16:49 pyr Exp $	*/
d155 2
a156 1
void	mpe_input(struct mbuf *);
@


1.7
log
@Make mpe a point-to-point interface.
Make the mtu user definable.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.6 2008/05/07 06:53:42 pyr Exp $	*/
d154 2
@


1.6
log
@Correctly initialize labels by byte-swapping and inserting BoS and TTL.
While there bump MTU to 1500 and set the receiving interface before
calling mpls_input. mpestart will eventually call mpls_output when it
exists.

``yaaaaayyy'' and ok claudio@@ and norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.5 2008/05/06 13:33:50 pyr Exp $	*/
d151 3
@


1.5
log
@bring in the mpe interface - for ``MPLS Provider Edge'' - this is a work
in progress and some bits need to be cleaned up but will be in-tree for
convenience.

ok claudio@@, norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.4 2008/04/30 07:39:48 norby Exp $	*/
d158 1
@


1.4
log
@Drop all MPLS packets when MPLS is not enabled.
Discussed with claudio@@ dlg@@ laurent@@

Remember to enable MPLS vith sysctl(8).
sysctl -w net.mpls.enable=1

ok claudio@@ dlg@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.3 2008/04/23 12:28:49 norby Exp $	*/
d47 2
d142 10
d167 1
@


1.3
log
@add missing prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.2 2008/04/23 11:22:23 norby Exp $	*/
d145 1
@


1.2
log
@I hate working outside the tree.

Fix my faulty import....
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls.h,v 1.1 2008/04/23 11:00:35 norby Exp $	*/
d138 18
@


1.1
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a137 159
/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

/*
 *
 *	$Id: ayame-src.diff,v 1.2 2006/03/04 10:45:08 koifren Exp $
 */

#ifndef _NETMPLS_MPLS_H_
#define _NETMPLS_MPLS_H_

#include <sys/param.h>
#include <sys/time.h>
#include <sys/proc.h>
#include <sys/queue.h>

#include <net/if.h>
#include <net/if_dl.h>

/*
 * Structure of a SHIM header.
 */
struct shim_hdr {
	u_int32_t shim_label;	/* 20bit label, 4bit exp & BOS, 8bit ttl */
};

/*
 * By byte-swapping the constants, we avoid ever having to byte-swap IP
 * addresses inside the kernel.  Unfortunately, user-level programs rely
 * on these macros not doing byte-swapping.
 */
#define SHIM_LABEL_MASK		0xfffff000U
#define SHIM_LABEL_OFFSET	12
#define SHIM_EXP_MASK		0x00000e00U
#define SHIM_EXP_OFFSET		9
#define SHIM_BOS_MASK		0x00000100U
#define SHIM_BOS_OFFSET		8
#define SHIM_TTL_MASK		0x000000ffU

#define MPLS_SHIM_LABEL_GET(l)	(((l) & SHIM_LABEL_MASK) >> SHIM_LABEL_OFFSET)
#define MPLS_SHIM_EXP_GET(l)	(((l) & SHIM_EXP_MASK) >> SHIM_EXP_OFFSET)
#define MPLS_SHIM_BOS_ISSET(l)	(((l) & SHIM_BOS_MASK) == SHIM_BOS_MASK)
#define MPLS_SHIM_TTL_GET(l)	((l) & SHIM_TTL_MASK)
#define MPLS_SHIM_TTL_SET(l, t)	(((l) & ~SHIM_TTL_MASK) | ((t) & SHIM_TTL_MASK))

/* Reserved lavel values (rfc3032) */
#define MPLS_LABEL_IPV4NULL	0               /* IPv4 Explicit NULL Label */
#define MPLS_LABEL_RTALERT	1               /* Router Alert Label       */
#define MPLS_LABEL_IPV6NULL	2               /* IPv6 Explicit NULL Label */
#define MPLS_LABEL_IMPLNULL	3               /* Implicit NULL Label      */
/*      MPLS_LABEL_RESERVED	4-15 */		/* Values 4-15 are reserved */
#define MPLS_LABEL_RESERVED_MAX 15

/*
 * Socket address
 */

struct sockaddr_mpls {
	u_int8_t	smpls_len;		/* length */
	u_int8_t	smpls_family;		/* AF_MPLS */
	u_int8_t	smpls_operation;
	u_int8_t	smpls_out_exp;		/* outgoing exp value */
	u_int32_t	smpls_out_label;	/* outgoing MPLS label */
	u_int16_t	smpls_out_ifindex;
	u_int16_t	smpls_in_ifindex;
	u_int32_t	smpls_in_label;		/* MPLS label 20 bits*/
#if MPLS_MCAST
	u_int8_t smpls_mcexp;
	u_int8_t smpls_pad2[2];
	u_int32_t smpls_mclabel;
#endif
};

#define MPLS_EXP_MASK	0x07		/* mpls exp value   ( 3bits) */

#define MPLS_OP_POP		1
#define MPLS_OP_PUSH		2
#define MPLS_OP_SWAP		3

#define MPLS_INKERNEL_LOOP_MAX	16

#define satosmpls(sa)		((struct sockaddr_mpls *)(sa))
#define smplstosa(smpls)	((struct sockaddr *)(smpls))
#define satosdl(sa)		((struct sockaddr_dl *)(sa))
#define sdltosa(sdl)		((struct sockaddr *)(sdl))

struct mpls_ifaddr {
	struct  ifaddr ia_ifa;		/* protocol-independent info */
#define ia_ifp		ia_ifa.ifa_ifp
#define ia_flags	ia_ifa.ifa_flags
	TAILQ_ENTRY(mpls_ifaddr) ia_list;	/* list of MPLS addresses */
	struct sockaddr_mpls ia_addr;	/* interface address */
	struct sockaddr ia_dstaddr;	/* peer dst address */
};

struct  mpls_aliasreq {
	char ifra_name[IFNAMSIZ];		/* if name, e.g. "en0" */
	struct sockaddr_mpls ifra_addr;
	struct sockaddr ifra_dstaddr;
	struct sockaddr_mpls ifra_mask;		/* not used */
};


/*
 * Names for IP sysctl objects
 */
#define	MPLSCTL_DEFTTL			1
#define	MPLSCTL_MAXINKLOOP		2
#define	MPLSCTL_PUSHEXPNULL_IP		3
#define	MPLSCTL_PUSHEXPNULL_IP6		4
#define	MPLSCTL_MAPTTL_IP		5
#define	MPLSCTL_MAPTTL_IP6		6
#define MPLSCTL_MAXID			7

#define MPLSCTL_NAMES { \
	{ 0, 0 }, \
	{ "ttl", CTLTYPE_INT }, \
	{ "maxloop_inkernel", CTLTYPE_INT }, \
	{ "pushexpnull_ip", CTLTYPE_INT }, \
	{ "pushexpnull_ip6", CTLTYPE_INT }, \
	{ "mapttl_ip", CTLTYPE_INT }, \
	{ "mapttl_ip6", CTLTYPE_INT }, \
}

#ifdef _KERNEL
TAILQ_HEAD(mpls_ifaddrhead, mpls_ifaddr);	/* the actual queue head */
extern struct mpls_ifaddrhead mpls_ifaddr;

extern void mpls_init(void);
extern int mpls_control(struct socket *, u_long, caddr_t, struct ifnet *);
extern void mpls_purgeif(struct ifnet *);
#endif /* _KERNEL */
#endif /* _NETMPLS_MPLS_H_ */
@

