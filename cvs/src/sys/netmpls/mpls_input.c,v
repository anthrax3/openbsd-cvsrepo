head	1.59;
access;
symbols
	OPENBSD_6_1:1.59.0.2
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.56.0.2
	OPENBSD_6_0_BASE:1.56
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.47.0.4
	OPENBSD_5_8_BASE:1.47
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.35.0.2
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.31.0.2
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.28.0.2
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.4
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13;
locks; strict;
comment	@ * @;


1.59
date	2017.03.02.03.09.50;	author renato;	state Exp;
branches;
next	1.58;
commitid	15KE7F69zvHLMIyM;

1.58
date	2017.02.27.19.16.56;	author claudio;	state Exp;
branches;
next	1.57;
commitid	Ukq2QkllmG8rHpFv;

1.57
date	2016.08.22.15.37.23;	author mpi;	state Exp;
branches;
next	1.56;
commitid	S0vYMPQvKRgA9JxA;

1.56
date	2016.07.11.09.23.06;	author mpi;	state Exp;
branches;
next	1.55;
commitid	Z6QboMLW08GSdJ1F;

1.55
date	2016.06.14.09.44.41;	author mpi;	state Exp;
branches;
next	1.54;
commitid	jROApUVEsAXWIH7k;

1.54
date	2015.12.04.11.13.21;	author claudio;	state Exp;
branches;
next	1.53;
commitid	gfl6QlN7EEgEzTcw;

1.53
date	2015.12.02.13.45.07;	author claudio;	state Exp;
branches;
next	1.52;
commitid	KyYqJDJXojQsr3KO;

1.52
date	2015.12.02.08.47.00;	author claudio;	state Exp;
branches;
next	1.51;
commitid	bBZq0t5zueGnkAtX;

1.51
date	2015.10.23.14.49.36;	author mpi;	state Exp;
branches;
next	1.50;
commitid	dJoHmXQSuWTW4Mfo;

1.50
date	2015.09.23.08.49.46;	author mpi;	state Exp;
branches;
next	1.49;
commitid	24xqlqpNt9NPeWH3;

1.49
date	2015.09.13.17.53.44;	author mpi;	state Exp;
branches;
next	1.48;
commitid	zZXiESHR0g5lNO0l;

1.48
date	2015.09.12.20.26.07;	author mpi;	state Exp;
branches;
next	1.47;
commitid	UM7jfgLT8vWQUBm1;

1.47
date	2015.07.29.00.04.03;	author rzalamena;	state Exp;
branches;
next	1.46;
commitid	9x7oePEcDKgC05vn;

1.46
date	2015.07.20.22.16.41;	author rzalamena;	state Exp;
branches;
next	1.45;
commitid	yaHvJbufOxtjWSFd;

1.45
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.44;
commitid	t2fhFUpUuj89g4Sj;

1.44
date	2015.06.16.11.09.40;	author mpi;	state Exp;
branches;
next	1.43;
commitid	h7z8lokZ0dFyuWpg;

1.43
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.42;
commitid	c7ei8kPelCOOwHXy;

1.42
date	2014.12.23.03.24.08;	author tedu;	state Exp;
branches;
next	1.41;
commitid	PYnSnAqgemmk34E3;

1.41
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.40;
commitid	t9FBKDfc4VDxpEy2;

1.40
date	2014.11.01.21.40.39;	author mpi;	state Exp;
branches;
next	1.39;
commitid	w0MRp28dmfD1ZzO8;

1.39
date	2014.10.14.09.52.26;	author mpi;	state Exp;
branches;
next	1.38;
commitid	6AYfDT0Lpez1LFQp;

1.38
date	2014.07.22.11.06.10;	author mpi;	state Exp;
branches;
next	1.37;
commitid	DQakU8LLWV6Iwx84;

1.37
date	2013.10.24.11.31.43;	author mpi;	state Exp;
branches;
next	1.36;

1.36
date	2013.10.17.16.27.47;	author bluhm;	state Exp;
branches;
next	1.35;

1.35
date	2013.07.10.07.30.39;	author mpi;	state Exp;
branches;
next	1.34;

1.34
date	2013.04.24.10.20.15;	author mpi;	state Exp;
branches;
next	1.33;

1.33
date	2013.03.26.13.19.26;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.06.02.42.28;	author henning;	state Exp;
branches;
next	1.31;

1.31
date	2011.01.21.17.42.57;	author mikeb;	state Exp;
branches;
next	1.30;

1.30
date	2010.10.07.12.34.15;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2010.09.13.10.02.49;	author claudio;	state Exp;
branches;
next	1.28;

1.28
date	2010.07.07.20.58.25;	author claudio;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.09.11.40.36;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2010.06.02.15.41.07;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2010.05.31.15.31.01;	author claudio;	state Exp;
branches;
next	1.24;

1.24
date	2010.05.31.11.46.02;	author claudio;	state Exp;
branches;
next	1.23;

1.23
date	2010.05.28.12.09.10;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.07.13.33.17;	author claudio;	state Exp;
branches;
next	1.21;

1.21
date	2009.04.29.19.26.52;	author michele;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.28.12.07.43;	author michele;	state Exp;
branches;
next	1.19;

1.19
date	2009.04.17.12.10.08;	author michele;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.15.16.13.55;	author michele;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.01.16.37.55;	author michele;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.14.20.43.33;	author michele;	state Exp;
branches;
next	1.13;

1.13
date	2008.05.23.16.06.29;	author thib;	state Exp;
branches;
next	1.12;

1.12
date	2008.05.10.01.56.32;	author claudio;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.08.03.18.39;	author claudio;	state Exp;
branches;
next	1.10;

1.10
date	2008.05.06.13.33.50;	author pyr;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.06.08.04.04;	author norby;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.06.08.01.24;	author norby;	state Exp;
branches;
next	1.7;

1.7
date	2008.05.06.02.47.20;	author norby;	state Exp;
branches;
next	1.6;

1.6
date	2008.05.02.12.40.29;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.30.07.39.48;	author norby;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.24.11.36.39;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.23.12.59.35;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.23.11.22.23;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.23.11.00.35;	author norby;	state Exp;
branches;
next	;


desc
@@


1.59
log
@Allow MPLS switching and VPLS across rdomains.

OK claudio@@ mpi@@
@
text
@/*	$OpenBSD: mpls_input.c,v 1.58 2017/02/27 19:16:56 claudio Exp $	*/

/*
 * Copyright (c) 2008 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "mpe.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_var.h>
#include <net/if_types.h>
#include <net/netisr.h>
#include <net/route.h>

#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/ip_var.h>
#include <netinet/ip_icmp.h>

#ifdef INET6
#include <netinet/ip6.h>
#endif /* INET6 */

#include <netmpls/mpls.h>

#ifdef MPLS_DEBUG
#define MPLS_LABEL_GET(l)	((ntohl((l) & MPLS_LABEL_MASK)) >> MPLS_LABEL_OFFSET)
#define MPLS_TTL_GET(l)		(ntohl((l) & MPLS_TTL_MASK))
#endif

int	mpls_ip_adjttl(struct mbuf *, u_int8_t);
#ifdef INET6
int	mpls_ip6_adjttl(struct mbuf *, u_int8_t);
#endif

struct mbuf	*mpls_do_error(struct mbuf *, int, int, int);

void
mpls_input(struct mbuf *m)
{
	struct sockaddr_mpls *smpls;
	struct sockaddr_mpls sa_mpls;
	struct shim_hdr	*shim;
	struct rtentry *rt;
	struct rt_mpls *rt_mpls;
	struct ifnet   *ifp = NULL;
	u_int8_t ttl;
	int hasbos;

	/* drop all broadcast and multicast packets */
	if (m->m_flags & (M_BCAST | M_MCAST)) {
		m_freem(m);
		return;
	}

	if (m->m_len < sizeof(*shim))
		if ((m = m_pullup(m, sizeof(*shim))) == NULL)
			return;

	shim = mtod(m, struct shim_hdr *);

#ifdef MPLS_DEBUG
	printf("mpls_input: iface %d label=%d, ttl=%d BoS %d\n",
	    m->m_pkthdr.ph_ifidx, MPLS_LABEL_GET(shim->shim_label),
	    MPLS_TTL_GET(shim->shim_label),
	    MPLS_BOS_ISSET(shim->shim_label));
#endif

	/* check and decrement TTL */
	ttl = ntohl(shim->shim_label & MPLS_TTL_MASK);
	if (ttl-- <= 1) {
		/* TTL exceeded */
		m = mpls_do_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, 0);
		if (m == NULL)
			return;
		shim = mtod(m, struct shim_hdr *);
		ttl = ntohl(shim->shim_label & MPLS_TTL_MASK);
	}

	bzero(&sa_mpls, sizeof(sa_mpls));
	smpls = &sa_mpls;
	smpls->smpls_family = AF_MPLS;
	smpls->smpls_len = sizeof(*smpls);
	smpls->smpls_label = shim->shim_label & MPLS_LABEL_MASK;

	hasbos = MPLS_BOS_ISSET(shim->shim_label);

	if (ntohl(smpls->smpls_label) < MPLS_LABEL_RESERVED_MAX) {
		m = mpls_shim_pop(m);
		if (!hasbos) {
			/*
			 * RFC 4182 relaxes the position of the
			 * explicit NULL labels. They no longer need
			 * to be at the beginning of the stack.
			 * In this case the label is ignored and the decision
			 * is made based on the lower one.
			 */
			shim = mtod(m, struct shim_hdr *);
			smpls->smpls_label = shim->shim_label & MPLS_LABEL_MASK;
			hasbos = MPLS_BOS_ISSET(shim->shim_label);
		} else {
			switch (ntohl(smpls->smpls_label)) {
			case MPLS_LABEL_IPV4NULL:
do_v4:
				if (mpls_ip_adjttl(m, ttl))
					return;
				niq_enqueue(&ipintrq, m);
				return;
#ifdef INET6
			case MPLS_LABEL_IPV6NULL:
do_v6:
				if (mpls_ip6_adjttl(m, ttl))
					return;
				niq_enqueue(&ip6intrq, m);
				return;
#endif	/* INET6 */
			case MPLS_LABEL_IMPLNULL:
				switch (*mtod(m, u_char *) >> 4) {
				case IPVERSION:
					goto do_v4;
#ifdef INET6
				case IPV6_VERSION >> 4:
					goto do_v6;
#endif
				default:
					m_freem(m);
					return;
				}
			default:
				/* Other cases are not handled for now */
				m_freem(m);
				return;
			}
		}
	}

	rt = rtalloc(smplstosa(smpls), RT_RESOLVE, m->m_pkthdr.ph_rtableid);
	if (rt == NULL) {
		/* no entry for this label */
#ifdef MPLS_DEBUG
		printf("MPLS_DEBUG: label not found\n");
#endif
		m_freem(m);
		return;
	}

	rt_mpls = (struct rt_mpls *)rt->rt_llinfo;
	if (rt_mpls == NULL || (rt->rt_flags & RTF_MPLS) == 0) {
#ifdef MPLS_DEBUG
		printf("MPLS_DEBUG: no MPLS information attached\n");
#endif
		m_freem(m);
		goto done;
	}

	switch (rt_mpls->mpls_operation) {
	case MPLS_OP_POP:
		m = mpls_shim_pop(m);
		if (!hasbos)
			/* just forward to gw */
			break;

		/* last label popped so decide where to push it to */
		ifp = if_get(rt->rt_ifidx);
		if (ifp == NULL) {
			m_freem(m);
			goto done;
		}
#if NMPE > 0
		if (ifp->if_type == IFT_MPLS) {
			smpls = satosmpls(rt_key(rt));
			mpe_input(m, ifp, smpls, ttl);
			goto done;
		}
#endif
		if (ifp->if_type == IFT_MPLSTUNNEL) {
			ifp->if_output(ifp, m, rt_key(rt), rt);
			goto done;
		}

		KASSERT(rt->rt_gateway);

		switch(rt->rt_gateway->sa_family) {
		case AF_INET:
			if (mpls_ip_adjttl(m, ttl))
				goto done;
			break;
#ifdef INET6
		case AF_INET6:
			if (mpls_ip6_adjttl(m, ttl))
				goto done;
			break;
#endif
		default:
			m_freem(m);
			goto done;
		}

		/* shortcut sending out the packet */
		if (!ISSET(ifp->if_xflags, IFXF_MPLS))
			(*ifp->if_output)(ifp, m, rt->rt_gateway, rt);
		else
			(*ifp->if_ll_output)(ifp, m, rt->rt_gateway, rt);
		goto done;
	case MPLS_OP_PUSH:
		/* this does not make much sense but it does not hurt */
		m = mpls_shim_push(m, rt_mpls);
		break;
	case MPLS_OP_SWAP:
		m = mpls_shim_swap(m, rt_mpls);
		break;
	default:
		m_freem(m);
		goto done;
	}

	if (m == NULL)
		goto done;

	/* refetch label and write back TTL */
	shim = mtod(m, struct shim_hdr *);
	shim->shim_label = (shim->shim_label & ~MPLS_TTL_MASK) | htonl(ttl);

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL) {
		m_freem(m);
		goto done;
	}
#ifdef MPLS_DEBUG
	printf("MPLS: sending on %s outlabel %x dst af %d in %d out %d\n",
    	    ifp->if_xname, ntohl(shim->shim_label), smpls->smpls_family,
	    MPLS_LABEL_GET(smpls->smpls_label),
	    MPLS_LABEL_GET(rt_mpls->mpls_label));
#endif

	/* Output iface is not MPLS-enabled */
	if (!ISSET(ifp->if_xflags, IFXF_MPLS)) {
#ifdef MPLS_DEBUG
		printf("MPLS_DEBUG: interface %s not mpls enabled\n",
		    ifp->if_xname);
#endif
		m_freem(m);
		goto done;
	}

	(*ifp->if_ll_output)(ifp, m, smplstosa(smpls), rt);
done:
	if_put(ifp);
	rtfree(rt);
}

int
mpls_ip_adjttl(struct mbuf *m, u_int8_t ttl)
{
	struct ip *ip;
	int hlen;

	if (mpls_mapttl_ip) {
		if (m->m_len < sizeof(struct ip) &&
		    (m = m_pullup(m, sizeof(struct ip))) == NULL)
			return -1;
		ip = mtod(m, struct ip *);
		hlen = ip->ip_hl << 2;
		if (m->m_len < hlen) {
			if ((m = m_pullup(m, hlen)) == NULL)
				return -1;
			ip = mtod(m, struct ip *);
		}
		/* make sure we have a valid header */
		if (in_cksum(m, hlen) != 0) {
			m_free(m);
			return -1;
		}

		/* set IP ttl from MPLS ttl */
		ip->ip_ttl = ttl;

		/* recalculate checksum */
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, hlen);
	}
	return 0;
}

#ifdef INET6
int
mpls_ip6_adjttl(struct mbuf *m, u_int8_t ttl)
{
	struct ip6_hdr *ip6hdr;

	if (mpls_mapttl_ip6) {
		if (m->m_len < sizeof(struct ip6_hdr) &&
		    (m = m_pullup(m, sizeof(struct ip6_hdr))) == NULL)
			return -1;

		ip6hdr = mtod(m, struct ip6_hdr *);

		/* set IPv6 ttl from MPLS ttl */
		ip6hdr->ip6_hlim = ttl;
	}
	return 0;
}
#endif	/* INET6 */

struct mbuf *
mpls_do_error(struct mbuf *m, int type, int code, int destmtu)
{
	struct shim_hdr stack[MPLS_INKERNEL_LOOP_MAX];
	struct sockaddr_mpls sa_mpls;
	struct sockaddr_mpls *smpls;
	struct rtentry *rt = NULL;
	struct shim_hdr *shim;
	struct in_ifaddr *ia;
	struct icmp *icp;
	struct ip *ip;
	int nstk, error;

	for (nstk = 0; nstk < MPLS_INKERNEL_LOOP_MAX; nstk++) {
		if (m->m_len < sizeof(*shim) &&
		    (m = m_pullup(m, sizeof(*ip))) == NULL)
			return (NULL);
		stack[nstk] = *mtod(m, struct shim_hdr *);
		m_adj(m, sizeof(*shim));
		if (MPLS_BOS_ISSET(stack[nstk].shim_label))
			break;
	}
	shim = &stack[0];

	switch (*mtod(m, u_char *) >> 4) {
	case IPVERSION:
		if (m->m_len < sizeof(*ip) &&
		    (m = m_pullup(m, sizeof(*ip))) == NULL)
			return (NULL);
		m = icmp_do_error(m, type, code, 0, destmtu);
		if (m == NULL)
			return (NULL);

		if (icmp_do_exthdr(m, ICMP_EXT_MPLS, 1, stack,
		    (nstk + 1) * sizeof(*shim)))
			return (NULL);

		/* set ip_src to something usable, based on the MPLS label */
		bzero(&sa_mpls, sizeof(sa_mpls));
		smpls = &sa_mpls;
		smpls->smpls_family = AF_MPLS;
		smpls->smpls_len = sizeof(*smpls);
		smpls->smpls_label = shim->shim_label & MPLS_LABEL_MASK;

		rt = rtalloc(smplstosa(smpls), RT_RESOLVE, 0);
		if (rt == NULL) {
			/* no entry for this label */
			m_freem(m);
			return (NULL);
		}
		if (rt->rt_ifa->ifa_addr->sa_family == AF_INET)
			ia = ifatoia(rt->rt_ifa);
		else {
			/* XXX this needs fixing, if the MPLS is on an IP
			 * less interface we need to find some other IP to
			 * use as source.
			 */
			rtfree(rt);
			m_freem(m);
			return (NULL);
		}
		/* It is safe to dereference ``ia'' iff ``rt'' is valid. */
		error = icmp_reflect(m, NULL, ia);
		rtfree(rt);
		if (error)
			return (NULL);

		ip = mtod(m, struct ip *);
		/* stuff to fix up which is normaly done in ip_output */
		ip->ip_v = IPVERSION;
		ip->ip_id = htons(ip_randomid());
		ip->ip_sum = 0;
		ip->ip_sum = in_cksum(m, sizeof(*ip));

		/* stolen from icmp_send() */
		icp = (struct icmp *)(mtod(m, caddr_t) + sizeof(*ip));
		icp->icmp_cksum = 0;
		icp->icmp_cksum = in4_cksum(m, 0, sizeof(*ip),
		    ntohs(ip->ip_len) - sizeof(*ip));

		break;
#ifdef INET6
	case IPV6_VERSION >> 4:
#endif
	default:
		m_freem(m);
		return (NULL);
	}

	/* add mpls stack back to new packet */
	M_PREPEND(m, (nstk + 1) * sizeof(*shim), M_NOWAIT);
	if (m == NULL)
		return (NULL);
	m_copyback(m, 0, (nstk + 1) * sizeof(*shim), stack, M_NOWAIT);

	/* change TTL to default */
	shim = mtod(m, struct shim_hdr *);
	shim->shim_label =
	    (shim->shim_label & ~MPLS_TTL_MASK) | htonl(mpls_defttl);

	return (m);
}
@


1.58
log
@Retire the AF_MPLS protosw struct. Nothing is using it and the code was super
basic anyway. Simplifies the code a lot also by calling the mpls sysctl no
longer via the protosw but instead directly.
OK mpi@@ on a previous diff. Also tested by renato@@ who actually found a bug
which is now fixed.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.57 2016/08/22 15:37:23 mpi Exp $	*/
d154 1
a154 1
	rt = rtalloc(smplstosa(smpls), RT_RESOLVE, 0);
@


1.57
log
@Do not dereference ``rt->rt_ifa'' after calling rtfree(9).

This could result in a use after free if the route entry was holding
the last reference of the address descriptor.

ok jca@@, bluhm@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.56 2016/07/11 09:23:06 mpi Exp $	*/
a53 5

void
mpls_init(void)
{
}
@


1.56
log
@Revert the introduction of ``rt_addr''.

Being able to add route entries without configured addresses is a nice
feature but this is not my fight.  So I'd rather no add another pointer
to ``struct rtentry'' if I'm not removing another one.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.55 2016/06/14 09:44:41 mpi Exp $	*/
d388 2
a390 1
		error = icmp_reflect(m, NULL, ia);
@


1.55
log
@Store the source address associated with a route in its own chunk of
memory.

This will allow to unlink 'sruct rtentry' and 'struct ifaddr' to be able
to add route entries without needing an address.

ok sthen@@, visa@@, florian@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.54 2015/12/04 11:13:21 claudio Exp $	*/
d377 1
a377 1
		if (rt->rt_addr->sa_family == AF_INET)
@


1.54
log
@There is no need to grab the KERNEL_LOCK here anymore. After discussion with
dlg@@ and mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.53 2015/12/02 13:45:07 claudio Exp $	*/
d377 1
a377 1
		if (rt->rt_ifa->ifa_addr->sa_family == AF_INET)
@


1.53
log
@Oups, forgot in the tedu of RT_REPORT commit
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.52 2015/12/02 08:47:00 claudio Exp $	*/
a221 1
		KERNEL_LOCK();
a225 1
		KERNEL_UNLOCK();
a267 1
	KERNEL_LOCK();
a268 1
	KERNEL_UNLOCK();
a388 1
		KERNEL_LOCK();
a389 1
		KERNEL_UNLOCK();
@


1.52
log
@Rework the MPLS handling. Remove the lookup loops since nothing is using
them and they make everything so much harder with no gain. Remove the
ifp argument from mpls_input since it is not needed. On the input side
the lookup side is modified a bit when it comes to BOS handling.
Tested in a L3VPN setup with ldpd and bgpd. Commiting now so we can move
on with cleaning up rt_ifp usage. If this breaks L2VPN I will fix it once
reported. OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.51 2015/10/23 14:49:36 mpi Exp $	*/
d159 1
a159 1
	rt = rtalloc(smplstosa(smpls), RT_REPORT|RT_RESOLVE, 0);
d375 1
a375 1
		rt = rtalloc(smplstosa(smpls), RT_REPORT|RT_RESOLVE, 0);
@


1.51
log
@rtfree(9) and rtalloc(9) no longer need to be called under KERNEL_LOCK.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.50 2015/09/23 08:49:46 mpi Exp $	*/
d61 1
a61 1
mpls_input(struct ifnet *ifp, struct mbuf *m)
d66 1
a66 1
	struct rtentry *rt = NULL;
d68 1
d70 1
a70 6
	int i, hasbos;

	if (!ISSET(ifp->if_xflags, IFXF_MPLS)) {
		m_freem(m);
		return;
	}
d85 2
a86 2
	printf("mpls_input: iface %s label=%d, ttl=%d BoS %d\n",
	    ifp->if_xname, MPLS_LABEL_GET(shim->shim_label),
d106 1
a106 2
	for (i = 0; i < mpls_inkloop; i++) {
		smpls->smpls_label = shim->shim_label & MPLS_LABEL_MASK;
d108 1
a108 6
#ifdef MPLS_DEBUG
		printf("smpls af %d len %d in_label %d in_ifindex %d\n",
		    smpls->smpls_family, smpls->smpls_len,
		    MPLS_LABEL_GET(smpls->smpls_label),
		    ifp->if_index);
#endif
d110 12
a121 1
		if (ntohl(smpls->smpls_label) < MPLS_LABEL_RESERVED_MAX) {
d123 1
a123 3
			m = mpls_shim_pop(m);
			shim = mtod(m, struct shim_hdr *);

a125 6
				/*
				 * RFC 4182 relaxes the position of the
				 * explicit NULL labels. The no longer need
				 * to be at the beginning of the stack.
				 */
				if (hasbos) {
d127 4
a130 6
					if (mpls_ip_adjttl(m, ttl))
						goto done;
					niq_enqueue(&ipintrq, m);
					goto done;
				}
				continue;
a132 1
				if (hasbos) {
d134 4
a137 6
					if (mpls_ip6_adjttl(m, ttl))
						goto done;
					niq_enqueue(&ip6intrq, m);
					goto done;
				}
				continue;
d140 3
a142 4
				if (hasbos) {
					switch (*mtod(m, u_char *) >> 4) {
					case IPVERSION:
						goto do_v4;
d144 2
a145 2
					case IPV6_VERSION >> 4:
						goto do_v6;
d147 3
a149 4
					default:
						m_freem(m);
						goto done;
					}
a150 1
				/* FALLTHROUGH */
d154 1
a154 1
				goto done;
d157 1
d159 3
a161 3
		rt = rtalloc(smplstosa(smpls), RT_REPORT|RT_RESOLVE, 0);
		if (rt == NULL) {
			/* no entry for this label */
d163 1
a163 1
			printf("MPLS_DEBUG: label not found\n");
d165 3
a167 5
			m_freem(m);
			goto done;
		}

		rt_mpls = (struct rt_mpls *)rt->rt_llinfo;
d169 2
a170 1
		if (rt_mpls == NULL || (rt->rt_flags & RTF_MPLS) == 0) {
d172 1
a172 2
			printf("MPLS_DEBUG: no MPLS information "
			    "attached\n");
d174 14
d191 6
a196 27

		hasbos = MPLS_BOS_ISSET(shim->shim_label);
		switch (rt_mpls->mpls_operation) {
		case MPLS_OP_LOCAL:
			/* Packet is for us */
			m = mpls_shim_pop(m);
			if (!hasbos)
				/* redo lookup with next label */
				break;

			if (!rt->rt_gateway) {
				m_freem(m);
				goto done;
			}

			switch(rt->rt_gateway->sa_family) {
			case AF_INET:
				if (mpls_ip_adjttl(m, ttl))
					break;
				niq_enqueue(&ipintrq, m);
				break;
#ifdef INET6
			case AF_INET6:
				if (mpls_ip6_adjttl(m, ttl))
					break;
				niq_enqueue(&ip6intrq, m);
				break;
d198 2
a199 3
			default:
				m_freem(m);
			}
d201 1
a201 5
		case MPLS_OP_POP:
			m = mpls_shim_pop(m);
			if (!hasbos)
				/* redo lookup with next label */
				break;
d203 1
a203 12
			ifp = rt->rt_ifp;
#if NMPE > 0
			if (ifp->if_type == IFT_MPLS) {
				smpls = satosmpls(rt_key(rt));
				mpe_input(m, rt->rt_ifp, smpls, ttl);
				goto done;
			}
#endif
			if (ifp->if_type == IFT_MPLSTUNNEL) {
				ifp->if_output(ifp, m, rt_key(rt), rt);
				goto done;
			}
d205 3
a207 2
			if (!rt->rt_gateway) {
				m_freem(m);
d209 1
a209 7
			}

			switch(rt->rt_gateway->sa_family) {
			case AF_INET:
				if (mpls_ip_adjttl(m, ttl))
					goto done;
				break;
d211 4
a214 4
			case AF_INET6:
				if (mpls_ip6_adjttl(m, ttl))
					goto done;
				break;
d216 2
a217 12
			default:
				m_freem(m);
				goto done;
			}

			/* Output iface is not MPLS-enabled */
			if (!ISSET(ifp->if_xflags, IFXF_MPLS)) {
				m_freem(m);
				goto done;
			}

			(*ifp->if_ll_output)(ifp, m, rt->rt_gateway, rt);
a218 6
		case MPLS_OP_PUSH:
			m = mpls_shim_push(m, rt_mpls);
			break;
		case MPLS_OP_SWAP:
			m = mpls_shim_swap(m, rt_mpls);
			break;
d221 19
a239 2
		if (m == NULL)
			goto done;
d241 2
a242 2
		/* refetch label */
		shim = mtod(m, struct shim_hdr *);
d244 3
a246 7
		ifp = rt->rt_ifp;
		if (ifp != NULL && rt_mpls->mpls_operation != MPLS_OP_LOCAL)
			break;

		rtfree(rt);
		rt = NULL;
	}
d248 2
a249 1
	if (rt == NULL) {
a252 4

	/* write back TTL */
	shim->shim_label = (shim->shim_label & ~MPLS_TTL_MASK) | htonl(ttl);

d263 2
a264 1
		printf("MPLS_DEBUG: interface not mpls enabled\n");
d266 1
d274 1
@


1.50
log
@Always increment rt_use inside rtalloc(9) instead of doing it in some
specific places.

ok claudio@@, benno@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.49 2015/09/13 17:53:44 mpi Exp $	*/
a172 1
		KERNEL_LOCK();
a173 1
		KERNEL_UNLOCK();
a290 1
		KERNEL_LOCK();
a291 1
		KERNEL_UNLOCK();
d322 1
a322 5
	if (rt) {
		KERNEL_LOCK();
		rtfree(rt);
		KERNEL_UNLOCK();
	}
d389 1
a389 1
	int nstk;
a421 1
		KERNEL_LOCK();
a422 1
		KERNEL_UNLOCK();
a434 1
			KERNEL_LOCK();
a435 1
			KERNEL_UNLOCK();
d439 1
d441 3
a443 3
		rtfree(rt);
		if (icmp_reflect(m, NULL, ia)) {
			KERNEL_UNLOCK();
a444 2
		}
		KERNEL_UNLOCK();
@


1.49
log
@There's no point in abstracting ifp->if_output() as long as pf_test()
needs to see lo0 in the output path.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.48 2015/09/12 20:26:07 mpi Exp $	*/
a184 1
		rt->rt_use++;
a450 1
		rt->rt_use++;
@


1.48
log
@Stop overwriting the rt_ifp pointer of RTF_LOCAL routes with lo0ifp.

Use instead the RTF_LOCAL flag to loop local traffic back to the
corresponding protocol queue.

With this change rt_ifp is now always the same as rt_ifa->ifa_ifp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.47 2015/07/29 00:04:03 rzalamena Exp $	*/
d243 1
a243 1
				if_output(ifp, m, rt_key(rt), rt);
@


1.47
log
@Don't use mpls_input() as input handler anymore and instead call it
directly. Also protect non mp-safe functions while at it.

ok mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.46 2015/07/20 22:16:41 rzalamena Exp $	*/
d243 1
a243 1
				ifp->if_output(ifp, m, rt_key(rt), rt);
@


1.46
log
@Implemented MPLS pseudowire (mpw(4)) to be used with VPLS and VPWS.

ok mpi@@, claudio@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.45 2015/07/20 21:16:39 rzalamena Exp $	*/
a53 1
int		 mpls_input(struct ifnet *, struct mbuf *);
a59 24
int
mpls_install_handler(struct ifnet *ifp)
{
	struct ifih *ifih, *ifihn;

	ifih = malloc(sizeof(*ifih), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (ifih == NULL)
		return (-1);

	ifih->ifih_input = mpls_input;

	/* We must install mpls_input() after ether_input(). */
	SLIST_FOREACH(ifihn, &ifp->if_inputs, ifih_next)
		if (SLIST_NEXT(ifihn, ifih_next) == NULL)
			break;

	if (ifihn == NULL)
		SLIST_INSERT_HEAD(&ifp->if_inputs, ifih, ifih_next);
	else
		SLIST_INSERT_AFTER(ifihn, ifih, ifih_next);

	return (0);
}

a60 16
mpls_uninstall_handler(struct ifnet *ifp)
{
	struct ifih *ifih;

	SLIST_FOREACH(ifih, &ifp->if_inputs, ifih_next) {
		if (ifih->ifih_input != mpls_input)
			continue;

		SLIST_REMOVE(&ifp->if_inputs, ifih, ifih, ifih_next);
		break;
	}

	free(ifih, M_DEVBUF, sizeof(*ifih));
}

int
d73 1
a73 1
		return (1);
d79 1
a79 1
		return (1);
d84 1
a84 1
			return (1);
d101 1
a101 1
			return (1);
d173 1
d175 1
d294 1
d296 1
d323 1
d325 1
d327 2
a328 1
	if (rt)
d330 2
a331 2

	return (1);
d431 1
d433 1
d446 1
d448 1
d453 1
d455 2
a456 1
		if (icmp_reflect(m, NULL, ia))
d458 2
@


1.45
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.44 2015/06/16 11:09:40 mpi Exp $	*/
d281 5
@


1.44
log
@Store a unique ID, an interface index, rather than a pointer to the
receiving interface in the packet header of every mbuf.

The interface pointer should now be retrieved when necessary with
if_get().  If a NULL pointer is returned by if_get(), the interface
has probably been destroy/removed and the mbuf should be freed.

Such mechanism will simplify garbage collection of mbufs and limit
problems with dangling ifp pointers.

Tested by jmatthew@@ and krw@@, discussed with many.

ok mikeb@@, bluhm@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.43 2015/04/10 13:58:20 dlg Exp $	*/
a42 2
struct niqueue	mplsintrq = NIQUEUE_INITIALIZER(IFQ_MAXLEN, NETISR_MPLS);

d54 1
d61 24
d86 1
a86 1
mplsintr(void)
d88 1
a88 1
	struct mbuf *m;
d90 6
a95 7
	/* Get next datagram of input queue */
	while ((m = niq_dequeue(&mplsintrq)) != NULL) {
#ifdef DIAGNOSTIC
		if ((m->m_flags & M_PKTHDR) == 0)
			panic("mplsintr no HDR");
#endif
		mpls_input(m);
d97 2
d101 2
a102 2
void
mpls_input(struct mbuf *m)
a103 1
	struct ifnet *ifp;
d112 1
a112 2
	ifp = if_get(m->m_pkthdr.ph_ifidx);
	if (ifp == NULL || !ISSET(ifp->if_xflags, IFXF_MPLS)) {
d114 1
a114 1
		return;
d120 1
a120 1
		return;
d125 1
a125 1
			return;
d142 1
a142 1
			return;
d359 2
@


1.43
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.42 2014/12/23 03:24:08 tedu Exp $	*/
d80 1
a80 1
	struct ifnet *ifp = m->m_pkthdr.rcvif;
d89 2
a90 1
	if (!ISSET(ifp->if_xflags, IFXF_MPLS)) {
@


1.42
log
@unifdef some more INET. v4 4life.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.41 2014/12/05 15:50:04 mpi Exp $	*/
d43 1
a43 1
struct ifqueue	mplsintrq;
a59 1
	IFQ_SET_MAXLEN(&mplsintrq, IFQ_MAXLEN);
a65 1
	int s;
d67 2
a68 7
	for (;;) {
		/* Get next datagram of input queue */
		s = splnet();
		IF_DEQUEUE(&mplsintrq, m);
		splx(s);
		if (m == NULL)
			return;
d87 1
a87 1
	int i, s, hasbos;
d154 1
a154 4
					s = splnet();
					IF_INPUT_ENQUEUE(&ipintrq, m);
					schednetisr(NETISR_IP);
					splx(s);
d164 1
a164 4
					s = splnet();
					IF_INPUT_ENQUEUE(&ip6intrq, m);
					schednetisr(NETISR_IPV6);
					splx(s);
d231 1
a231 4
				s = splnet();
				IF_INPUT_ENQUEUE(&ipintrq, m);
				schednetisr(NETISR_IP);
				splx(s);
d237 1
a237 4
				s = splnet();
				IF_INPUT_ENQUEUE(&ip6intrq, m);
				schednetisr(NETISR_IPV6);
				splx(s);
@


1.41
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.40 2014/11/01 21:40:39 mpi Exp $	*/
a31 1
#ifdef  INET
a35 1
#endif
a38 3
#ifndef INET
#include <netinet/in.h>
#endif
@


1.40
log
@Rename rtalloc1() into rtalloc(9) and convert its flags to only enable
functionnality instead of a mix of enable/disable.

ok bluhm@@, jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.39 2014/10/14 09:52:26 mpi Exp $	*/
d27 1
@


1.39
log
@Use rtfree() instead of RTFREE(), NULLify some free'd route pointers and
kill the macro.

ok mikeb@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.38 2014/07/22 11:06:10 mpi Exp $	*/
d208 1
a208 1
		rt = rtalloc1(smplstosa(smpls), RT_REPORT, 0);
d458 1
a458 1
		rt = rtalloc1(smplstosa(smpls), RT_REPORT, 0);
@


1.38
log
@Fewer <netinet/in_systm.h> !
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.37 2013/10/24 11:31:43 mpi Exp $	*/
d328 1
a328 1
		RTFREE(rt);
d358 1
a358 1
		RTFREE(rt);
d471 1
a471 1
			RTFREE(rt);
d476 1
a476 1
		RTFREE(rt);
@


1.37
log
@Remove the number of in6_var.h inclusions by moving some functions and
global variables to in6.h.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.36 2013/10/17 16:27:47 bluhm Exp $	*/
a32 1
#include <netinet/in_systm.h>
@


1.36
log
@The header file netinet/in_var.h included netinet6/in6_var.h.  This
created a bunch of useless dependencies.  Remove this implicit
inclusion and do an explicit #include <netinet6/in6_var.h> when it
is needed.
OK mpi@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.35 2013/07/10 07:30:39 mpi Exp $	*/
a32 1
#include <netinet/in_var.h>
a39 1
#include <netinet6/in6_var.h>
@


1.35
log
@Keep this copy of the ICMP checksum code in sync with recent changes.

ok lteo@@, claudio@@, bluhm@@, henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.34 2013/04/24 10:20:15 mpi Exp $	*/
d41 1
@


1.34
log
@Move various extern declarations into their corresponding header file.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.33 2013/03/26 13:19:26 mpi Exp $	*/
d490 1
a490 3
		m->m_data += sizeof(*ip);
		m->m_len -= sizeof(*ip);
		icp = mtod(m, struct icmp *);
d492 2
a493 3
		icp->icmp_cksum = in_cksum(m, ntohs(ip->ip_len) - sizeof(*ip));
		m->m_data -= sizeof(*ip);
		m->m_len += sizeof(*ip);
@


1.33
log
@Remove various read-only *maxlen variables and use IFQ_MAXLEN directly.

ok beck@@, mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.32 2011/07/06 02:42:28 henning Exp $	*/
a49 1
extern int	mpls_inkloop;
@


1.32
log
@cosnistently use IFQ_SET_MAXLEN, surfaced in a discussion with + ok bluhm
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.31 2011/01/21 17:42:57 mikeb Exp $	*/
a49 1
int		mplsqmaxlen = IFQ_MAXLEN;
d67 1
a67 1
	IFQ_SET_MAXLEN(&mplsintrq, mplsqmaxlen);
@


1.31
log
@make mpls compile w/o errors when inet6 is not defined

diff from form@@ who's too busy drinking vodka with pelmeni to commit this;
ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.30 2010/10/07 12:34:15 claudio Exp $	*/
d68 1
a68 1
	mplsintrq.ifq_maxlen = mplsqmaxlen;
@


1.30
log
@Handle IMPLNULL labels (#3) directly in the kernel like we do with the
explicit NULL labels. IMPLNULL labels should never ever be seen on the
wire but we're realists. michele@@ agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.29 2010/09/13 10:02:49 claudio Exp $	*/
d59 1
d61 1
d176 1
d189 1
d195 1
d198 1
d257 1
d266 1
d295 1
d300 1
d398 1
d416 1
d501 1
d503 1
@


1.29
log
@First shot at ICMP error handling inside an MPLS path. Currently only
TTL exceeded errors for IPv4 are handled. This makes traceroute through
MPLS tunnels work (including RFC 4950 MPLS extension header).
"best to get it in." deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.28 2010/07/07 20:58:25 claudio Exp $	*/
d164 1
d172 2
a173 2
				} else
					continue;
d176 1
d184 15
a198 2
				} else
					continue;
d200 1
a203 1
			/* Other cases are not handled for now */
@


1.28
log
@Use correct function name in panic()
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.27 2010/06/09 11:40:36 claudio Exp $	*/
d36 2
a57 3
extern int	mpls_mapttl_ip;
extern int	mpls_mapttl_ip6;

d61 2
d128 1
a128 1
	if (ttl <= 1) {
d130 5
a134 6
		/*
		 * XXX if possible hand packet up to network layer so that an
		 * ICMP TTL exceeded can be sent back.
		 */
		m_freem(m);
		return;
a135 1
	ttl--;
d343 2
a344 2
	struct ip	*ip;
	int		 hlen;
d347 1
a347 1
		if (m->m_len < sizeof (struct ip) &&
d379 1
a379 1
		if (m->m_len < sizeof (struct ip6_hdr) &&
d389 103
@


1.27
log
@Fix the pop operation to make PHP work again. When popping the last label
by a pop operation we need to forward the packet to the specified nexthop
as is. This is done by calling the interface output routine directly.
This is different to the local operation since that one injects the packets
into ip_input() via netisr.
OK michele
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.26 2010/06/02 15:41:07 claudio Exp $	*/
d83 1
a83 1
			panic("ipintr no HDR");
@


1.26
log
@Kill the mpls enable sysctl knob. Since MPLS needs to be enabled explicitly
on each interface there is no need for yet another knob.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.25 2010/05/31 15:31:01 claudio Exp $	*/
d59 3
d99 1
a99 1
	int i, hasbos;
d123 1
a123 1
#endif	/* MPLS_DEBUG */
d165 6
a170 1
					mpls_ip_input(m, ttl);
d176 6
a181 1
					mpls_ip6_input(m, ttl);
a223 4
#ifdef MPLS_DEBUG
				printf("MPLS_DEBUG: no layer 3 informations "
				    "attached\n");
#endif
d230 6
a235 1
				mpls_ip_input(m, ttl);
d238 6
a243 1
				mpls_ip6_input(m, ttl);
d251 5
a255 1
			if (hasbos) {
d257 14
a270 3
				if (rt->rt_ifp->if_type == IFT_MPLS) {
					smpls = satosmpls(rt_key(rt));
					mpe_input(m, rt->rt_ifp, smpls, ttl);
d272 12
a283 3
				}
#endif
				/* last label but we have no clue so drop */
d287 3
a289 1
			break;
d341 2
a342 2
void
mpls_ip_input(struct mbuf *m, u_int8_t ttl)
d345 1
a345 1
	int		 s, hlen;
d350 1
a350 1
			return;
d355 1
a355 1
				return;
d358 1
a358 1

d361 1
a361 1
			return;
d371 1
a371 5

	s = splnet();
	IF_INPUT_ENQUEUE(&ipintrq, m);
	schednetisr(NETISR_IP);
	splx(s);
d374 2
a375 2
void
mpls_ip6_input(struct mbuf *m, u_int8_t ttl)
a377 1
	int		s;
d382 1
a382 1
			return;
d389 1
a389 5

	s = splnet();
	IF_INPUT_ENQUEUE(&ip6intrq, m);
	schednetisr(NETISR_IPV6);
	splx(s);
@


1.25
log
@Add a comment about the explicit NULL label handling. We follow RFC 4182
which relaxes the position of these labels. After discussion with
Christophe Fillot (cf (at) utc fr)
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.24 2010/05/31 11:46:02 claudio Exp $	*/
d98 1
a98 1
	if (!mpls_enable || !ISSET(ifp->if_xflags, IFXF_MPLS)) {
@


1.24
log
@Do not use IF_ENQUEUE() but IF_INPUT_ENQUEUE() instead. The first makro
does no overflow checking and does not set the congestion flag. Protocol
input queues (inet, inet6, ...) should always use IF_INPUT_ENQUEUE().
OK henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.23 2010/05/28 12:09:10 claudio Exp $	*/
d156 5
@


1.23
log
@Rework the way we handle MPLS in the kernel. Instead of fumbling MPLS into
ether_output() and later on other L2 output functions use a trick and over-
load the ifp->if_output() function pointer on MPLS enabled interfaces to
go through mpls_output() which will then call the link level output function.
By setting IFXF_MPLS on an interface the output pointers are switched.
This now allows to cleanup the MPLS input and output pathes and fix mpe(4)
so that the MPLS code now actually works for both P and PE systems.
Tested by myself and michele
(A custom kernel with MPLS and mpe enabled is still needed).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.22 2010/05/07 13:33:17 claudio Exp $	*/
d323 1
a323 1
	IF_ENQUEUE(&ipintrq, m);
d346 1
a346 1
	IF_ENQUEUE(&ip6intrq, m);
@


1.22
log
@Start cleaning up the mess called rtalloc*. Kill rtalloc2, make rtalloc1
accept flags for report and nocloning. Move the rtableid into struct route
(with a minor twist for now) and make a few more codepathes rdomain aware.
Appart from the pf.c and route.c bits the diff is mostly mechanical.
More to come...
OK michele, henning
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.21 2009/04/29 19:26:52 michele Exp $	*/
d98 1
a98 1
	if (!mpls_enable) {
d135 4
a139 4
		bzero(&sa_mpls, sizeof(sa_mpls));
		smpls = &sa_mpls;
		smpls->smpls_family = AF_MPLS;
		smpls->smpls_len = sizeof(*smpls);
d154 1
a154 2
			switch (ntohl(smpls->smpls_label)) { 

a160 1

a184 1
		smpls = satosmpls(rt_key(rt));
d196 3
a198 1
		if (rt_mpls->mpls_operation == MPLS_OP_LOCAL) {
a199 8
			hasbos = MPLS_BOS_ISSET(shim->shim_label);
			if (!hasbos) {
#ifdef MPLS_DEBUG
				printf("MPLS_DEBUG: packet malformed\n");
#endif
				m_freem(m);
				goto done;
			}
d201 3
a223 1

d225 2
a226 4
		}

		if (rt_mpls->mpls_operation & MPLS_OP_POP) {
			hasbos = MPLS_BOS_ISSET(shim->shim_label);
a227 1
				m = mpls_shim_pop(m);
d230 1
d239 7
d248 3
d253 1
d255 1
a255 2

		if (ifp != NULL)  
d277 9
a285 1
	(*ifp->if_output)(ifp, m, smplstosa(smpls), rt);
d292 1
a292 1
mpls_ip_input(struct mbuf *m, u_int8_t ttl) 
@


1.21
log
@Split up functionalities between mpls_input and mpls_output.
The former is responsible to handle packets destined to localhost,
the latter handles packet that have to be forwarded or the ones
originated from localhost.

"i like it" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.20 2009/04/28 12:07:43 michele Exp $	*/
d176 1
a176 2
		rt = rtalloc1(smplstosa(smpls), 1, 0);

@


1.20
log
@Introduce a new dummy operation to easily handle packets that have to leave
the MPLS cloud and join ipv4/ipv6 stack.

ok claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.19 2009/04/17 12:10:08 michele Exp $	*/
d235 1
a235 4
		switch (rt_mpls->mpls_operation & (MPLS_OP_PUSH | MPLS_OP_POP |
		    MPLS_OP_SWAP)){

		case MPLS_OP_POP:
a236 1
			m = mpls_shim_pop(m);
d238 1
a248 10
			break;
		case MPLS_OP_PUSH:
			m = mpls_shim_push(m, rt_mpls);
			break;
		case MPLS_OP_SWAP:
			m = mpls_shim_swap(m, rt_mpls);
			break;
		default:
			m_freem(m);
			goto done;
a249 3

		if (m == NULL)
			goto done;
@


1.19
log
@Correctly handle packets that are leaving the MPLS cloud and
joining the ipv4/ipv6 stack.

Get also rid of the dependency on mpe(4) for packets not belonging
to VPN traffic.

ok laurent@@, ok and input claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.18 2009/01/28 22:18:44 michele Exp $	*/
a149 1

d192 9
d203 7
d211 2
a212 1
			if (!hasbos || !rt->rt_gateway) {
d214 1
a214 1
				printf("MPLS_DEBUG: no MPLS information "
@


1.18
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.17 2009/01/08 12:47:45 michele Exp $	*/
d28 1
d31 14
d56 3
d159 1
a159 1
					mpe_input(m, NULL, smpls, ttl);
d166 1
a166 1
					mpe_input6(m, NULL, smpls, ttl);
d170 3
d193 4
a196 1
			/* no MPLS information for this entry */
d198 2
a199 1
			printf("MPLS_DEBUG: no MPLS information attached\n");
d201 15
a215 1
			m_freem(m);
d281 60
@


1.17
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.16 2008/12/15 16:13:55 michele Exp $	*/
d73 1
a73 2
	struct sockaddr_mpls *newsmpls;
	struct sockaddr_mpls sa_mpls, sa_outmpls;
d76 1
a94 5
	bzero(&sa_outmpls, sizeof(sa_outmpls));
	newsmpls = &sa_outmpls;
	newsmpls->smpls_family = AF_MPLS;
	newsmpls->smpls_len = sizeof(*smpls);

d169 10
a178 1
		newsmpls->smpls_label = rt->rt_mpls;
d180 1
a180 1
		switch (rt->rt_flags & (MPLS_OP_PUSH | MPLS_OP_POP |
d199 1
a199 1
			m = mpls_shim_push(m, newsmpls);
d202 1
a202 1
			m = mpls_shim_swap(m, newsmpls);
d223 5
d235 1
a235 1
	    MPLS_LABEL_GET(newsmpls->smpls_label));
@


1.16
log
@Initial fixup of sockaddr_mpls struct.

Remove smpls_in_iface as labels must be per platform unique.
Remove smpls_out_iface. It is redudant and can be inferred from nexthop.
Move smpls_operation to rt_flags and temporary remove smpls_out_exp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.15 2008/11/01 16:37:55 michele Exp $	*/
d73 2
a74 1
	struct sockaddr_mpls sa_mpls;
d95 5
d127 1
a127 1
		smpls->smpls_in_label = shim->shim_label & MPLS_LABEL_MASK;
d132 1
a132 1
		    MPLS_LABEL_GET(smpls->smpls_in_label),
d136 1
a136 1
		if (ntohl(smpls->smpls_in_label) < MPLS_LABEL_RESERVED_MAX) {
d142 1
a142 1
			switch (ntohl(smpls->smpls_in_label)) { 
d174 1
a174 7

#ifdef MPLS_DEBUG
		printf("route af %d len %d in_label %d in_ifindex %d\n",
		    smpls->smpls_family, smpls->smpls_len,
		    MPLS_LABEL_GET(smpls->smpls_in_label),
		    ifp->if_index);
#endif
d195 1
a195 1
			m = mpls_shim_push(m, smpls);
d198 1
a198 1
			m = mpls_shim_swap(m, smpls);
d225 2
a226 2
	    MPLS_LABEL_GET(smpls->smpls_in_label),
	    MPLS_LABEL_GET(smpls->smpls_out_label));
@


1.15
log
@Introduced Uniform Model for TTL handling.
MPLS TTL is mapped into network layer one as the packet exits the LSP.
Just IPv4 support for now.
Added the relevant sysctls to enable this behaviour.

Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.14 2008/10/14 20:43:33 michele Exp $	*/
a120 1
		smpls->smpls_in_ifindex = ifp->if_index;
d127 1
a127 1
		    smpls->smpls_in_ifindex);
d168 1
d173 1
a173 5
		    smpls->smpls_in_ifindex);
		printf("\top %d out_label %d out_ifindex %d\n",
		    smpls->smpls_operation, 
		    MPLS_LABEL_GET(smpls->smpls_out_label), 
		    smpls->smpls_out_ifindex);
d176 3
a178 1
		switch (smpls->smpls_operation) {
d212 1
a212 1
		if (smpls->smpls_out_ifindex)
@


1.14
log
@Now mpls_input() handles ipv4 and ipv6 explicit null labels.
Added mpe_input6 to manage also ipv6 packets insted of just ipv4 ones.

OK claudio@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.13 2008/05/23 16:06:29 thib Exp $	*/
d74 1
a74 1
	struct shim_hdr *shim;
d76 1
a76 1
	u_int32_t ttl;
d114 1
a114 1
	ttl = htonl(ttl - 1);
d222 1
a222 1
	shim->shim_label = (shim->shim_label & ~MPLS_TTL_MASK) | ttl;
@


1.13
log
@Forgot this one. Wrap a printf() into MPLS_DEBUG since
MPLS_LABEL_GET() is only available #ifdef MPLS_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.12 2008/05/10 01:56:32 claudio Exp $	*/
d131 26
a156 1
		rt = rtalloc1(smplstosa(smpls),1, 0);
@


1.12
log
@Make MPLS code compile without pseudo device mpe. OK norby
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.11 2008/05/08 03:18:39 claudio Exp $	*/
d124 1
d129 1
@


1.11
log
@Hook mpe(4) correctly into mpls so that it is possible to tunnel packets over
MPLS. Still a bit hackish but getting closer. hai norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.10 2008/05/06 13:33:50 pyr Exp $	*/
d19 2
d158 1
d163 1
@


1.10
log
@bring in the mpe interface - for ``MPLS Provider Edge'' - this is a work
in progress and some bits need to be cleaned up but will be in-tree for
convenience.

ok claudio@@, norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.9 2008/05/06 08:04:04 norby Exp $	*/
d25 1
d75 1
a75 1
	int i;
a114 7
		/* XXX maybe this should be done later */
		if (MPLS_BOS_ISSET(shim->shim_label)) {
			/* no LER until now */
			m_freem(m);
			goto done;
		}

d153 1
d155 9
@


1.9
log
@Drop all broadcast and multicast packets.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.8 2008/05/06 08:01:24 norby Exp $	*/
a31 2

void	mpls_input(struct mbuf *);
@


1.8
log
@get rid of rtalloc, use rtalloc1 instead.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.7 2008/05/06 02:47:20 norby Exp $	*/
d79 6
@


1.7
log
@fix debug output.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.6 2008/05/02 12:40:29 claudio Exp $	*/
a69 1
	struct route ro;
d72 1
d117 2
a118 2
		bzero(&ro, sizeof(ro));
		smpls = satosmpls(&ro.ro_dst);
d129 1
a129 2
		rtalloc(&ro);	/* XXX switch to rtalloc1() */
		rt = ro.ro_rt;
@


1.6
log
@Fix the label swithing and forwarding logic a bit. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.5 2008/04/30 07:39:48 norby Exp $	*/
d124 4
a127 2
printf("smpls af %d len %d in_label %d in_ifindex %d\n", smpls->smpls_family,
    smpls->smpls_len, smpls->smpls_in_label, smpls->smpls_in_ifindex);
d144 8
a151 5
printf("route af %d len %d in_label %d in_ifindex %d\n", smpls->smpls_family,
    smpls->smpls_len, MPLS_LABEL_GET(smpls->smpls_in_label),
    smpls->smpls_in_ifindex);
printf("\top %d out_label %d out_ifindex %d\n", smpls->smpls_operation,
    MPLS_LABEL_GET(smpls->smpls_out_label), smpls->smpls_out_ifindex);
d187 4
a190 4
printf("MPLS: sending on %s outlabel %x dst af %d in %d out %d\n",
    ifp->if_xname, ntohl(shim->shim_label), smpls->smpls_family,
    MPLS_LABEL_GET(smpls->smpls_in_label),
    MPLS_LABEL_GET(smpls->smpls_out_label));
@


1.5
log
@Drop all MPLS packets when MPLS is not enabled.
Discussed with claudio@@ dlg@@ laurent@@

Remember to enable MPLS vith sysctl(8).
sysctl -w net.mpls.enable=1

ok claudio@@ dlg@@ laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.4 2008/04/24 11:36:39 dlg Exp $	*/
d160 12
a172 1
		}
d174 2
a175 6
		break;
		/* not yet done with packet */
		if (rt) {
			RTFREE(rt);
			rt = NULL;
		}
@


1.4
log
@the softnet intr handlers check if the input queue has packets on
it by reading the queues head pointer. if that pointer is not null
then it takes splnet and dequeues a packet for handling. this is
bad because the ifqueue head is modified at splnet and the sofnet
handlers read it without holding splnet.

this removes that check of the head pointer and simply checks if
the dequeue gave us a packet or not before proceeding.

found while reading mpls code.
discussed with norby@@ and henning@@

ok mcbride@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.3 2008/04/23 12:59:35 dlg Exp $	*/
d77 5
@


1.3
log
@unbreak compilationg with option MPLS but without option MPLS_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.2 2008/04/23 11:22:23 norby Exp $	*/
d52 1
a52 1
	while (mplsintrq.ifq_head) {
@


1.2
log
@I hate working outside the tree.

Fix my faulty import....
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_input.c,v 1.1 2008/04/23 11:00:35 norby Exp $	*/
d136 1
d142 1
d169 1
d174 1
@


1.1
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a173 161
	if (rt)
		RTFREE(rt);
}
/*	$OpenBSD$	*/
/*
 * Copyright (c) 2008 Claudio Jeker <claudio@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/systm.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/route.h>

#include <netmpls/mpls.h>
#include <netmpls/mpls_var.h>

struct ifqueue mplsintrq;

void	mpls_input(struct mbuf *);

void
mplsintr(void)
{
	struct mbuf *m;
	int s;

	while (mplsintrq.ifq_head) {
		/* Get next datagram of input queue */
		s = splnet();
		IF_DEQUEUE(&mplsintrq, m);
		splx(s);
		if (m == NULL)
			return;
#ifdef DIAGNOSTIC
		if ((m->m_flags & M_PKTHDR) == 0)
			panic("ipintr no HDR");
#endif
		mpls_input(m);
	}
}

void
mpls_input(struct mbuf *m)
{
	struct route ro;
	struct ifnet *ifp = m->m_pkthdr.rcvif;
	struct sockaddr_mpls *smpls;
	struct shim_hdr *shim;
	struct rtentry *rt = NULL;
	u_int32_t label, ttl;
	int i, error;

	printf("mpls_input: !! \n");

	if (m->m_len < sizeof(label))
		if ((m = m_pullup(m, sizeof(label))) == NULL)
			return;

	shim = mtod(m, struct shim_hdr *);
	/* swap label to host byte order. */
	label = ntohl(shim->shim_label);

#ifdef MPLS_DEBUG
	printf("mpls_input: iface %s label=%d, ttl=%d BoS %d\n",
	    ifp->if_xname, MPLS_SHIM_LABEL_GET(label),
	    MPLS_SHIM_TTL_GET(label), MPLS_SHIM_BOS_ISSET(label));
#endif	/* MPLS_DEBUG */

	/* check and decrement TTL */
	ttl = MPLS_SHIM_TTL_GET(label);
	if (ttl <= 1) {
		/* ttl exceeded */
		/*
		 * XXX if possible hand packet up to network layer so that an
		 * ICMP TTL exceeded can be sent back.
		 */
		m_freem(m);
		return;
	}
	ttl--;

	for (i = 0; i < MPLS_INKERNEL_LOOP_MAX; i++) {
		/* XXX maybe this should be done later */
		if (MPLS_SHIM_BOS_ISSET(label)) {
			/* no LER until now */
			error = EHOSTUNREACH;
			goto done;
		}

		bzero(&ro, sizeof(ro));
		smpls = satosmpls(&ro.ro_dst);
		smpls->smpls_family = AF_MPLS;
		smpls->smpls_len = sizeof(*smpls);
		smpls->smpls_in_ifindex = ifp->if_index;
		smpls->smpls_in_label = MPLS_SHIM_LABEL_GET(label);

		rtalloc(&ro);	/* XXX switch to rtalloc1() */
		rt = ro.ro_rt;

		if (rt == NULL) {
			/* no entry for this label */
			error = EHOSTUNREACH;
#ifdef MPLS_DEBUG
			printf("MPLS_DEBUG: label not found\n");
#endif
			goto done;
		}

		rt->rt_use++;
		smpls = satosmpls(rt_key(rt));

		switch (smpls->smpls_operation) {
		case MPLS_OP_POP:
			printf("mpls_input: POP\n");
			/* mpls_shim_pop() */
			break;
		case MPLS_OP_PUSH:
			printf("mpls_input: PUSH\n");
			/* mpls_shim_push() */
			break;
		case MPLS_OP_SWAP:
			printf("mpls_input: SWAP\n");
			/* mpls_shim_swap() */
			break;
		default:
			break;
		}

		/* not yet done with packet */
		/* reget current label */
		shim = mtod(m, struct shim_hdr *);
		label = ntohl(shim->shim_label);

		if (rt) {
			RTFREE(rt);
			rt = NULL;
		}
	}

	/* write back modified label */
	shim->shim_label = htonl(MPLS_SHIM_TTL_SET(label, ttl));

	error = (*ifp->if_output)(ifp, m, smplstosa(&smpls), rt);
done:
	if (error)
		m_freem(m);
@

