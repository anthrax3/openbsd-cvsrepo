head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.4
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.4.0.4
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2017.02.27.19.16.56;	author claudio;	state Exp;
branches;
next	1.14;
commitid	Ukq2QkllmG8rHpFv;

1.14
date	2016.11.15.13.44.03;	author mpi;	state Exp;
branches;
next	1.13;
commitid	h1TyNWCITMoCFMYn;

1.13
date	2015.11.24.13.37.16;	author mpi;	state Exp;
branches;
next	1.12;
commitid	djjKhPvMtRdFfuFJ;

1.12
date	2015.07.20.21.16.39;	author rzalamena;	state Exp;
branches;
next	1.11;
commitid	t2fhFUpUuj89g4Sj;

1.11
date	2015.04.10.13.58.20;	author dlg;	state Exp;
branches;
next	1.10;
commitid	c7ei8kPelCOOwHXy;

1.10
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.9;
commitid	t9FBKDfc4VDxpEy2;

1.9
date	2013.03.27.02.00.08;	author tedu;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.03.13.12.31;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.15.13.30.45;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2010.06.02.15.41.07;	author claudio;	state Exp;
branches;
next	1.5;

1.5
date	2010.04.22.06.46.18;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.01.16.37.55;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.23.16.03.03;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.23.11.22.23;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.23.11.00.35;	author norby;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Retire the AF_MPLS protosw struct. Nothing is using it and the code was super
basic anyway. Simplifies the code a lot also by calling the mpls sysctl no
longer via the protosw but instead directly.
OK mpi@@ on a previous diff. Also tested by renato@@ who actually found a bug
which is now fixed.
@
text
@/*	$OpenBSD: mpls_raw.c,v 1.14 2016/11/15 13:44:03 mpi Exp $	*/

/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/sockio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/systm.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netmpls/mpls.h>

int mpls_defttl = 255;
int mpls_inkloop = MPLS_INKERNEL_LOOP_MAX;
int mpls_push_expnull_ip = 0;
int mpls_push_expnull_ip6 = 0;
int mpls_mapttl_ip = 1;
int mpls_mapttl_ip6 = 0;

int *mplsctl_vars[MPLSCTL_MAXID] = MPLSCTL_VARS;

int
mpls_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	if (name[0] >= MPLSCTL_MAXID)
		return (EOPNOTSUPP);

	/* Almost all sysctl names at this level are terminal. */
	if (namelen != 1)
		return (ENOTDIR);

	switch (name[0]) {
	default:
		return sysctl_int_arr(mplsctl_vars, name, namelen,
		    oldp, oldlenp, newp, newlen);
	}
}
@


1.14
log
@Return EOPNOTSUPP instead of calling a function to do only that.

ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.13 2015/11/24 13:37:16 mpi Exp $	*/
a47 6
#define MPLS_RAW_SNDQ	8192
#define MPLS_RAW_RCVQ	8192

u_long mpls_raw_sendspace = MPLS_RAW_SNDQ;
u_long mpls_raw_recvspace = MPLS_RAW_RCVQ;

a55 47

int
mpls_raw_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control, struct proc *p)
{
	int error = 0;

#ifdef MPLS_DEBUG
	printf("mpls_raw_usrreq: called! (reqid=%d).\n", req);
#endif	/* MPLS_DEBUG */

	if (req == PRU_CONTROL)
		return (EOPNOTSUPP);

	switch (req) {
	case PRU_ATTACH:
		if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
			error = soreserve(so, mpls_raw_sendspace,
				mpls_raw_recvspace);
			if (error)
				break;
		}
		break;

	case PRU_DETACH:
	case PRU_BIND:
	case PRU_LISTEN:
	case PRU_CONNECT:
	case PRU_CONNECT2:
	case PRU_DISCONNECT:
	case PRU_SHUTDOWN:
	case PRU_RCVD:
	case PRU_SEND:
	case PRU_SENSE:
	case PRU_RCVOOB:
	case PRU_SENDOOB:
	case PRU_SOCKADDR:
	case PRU_PEERADDR:
		error = EOPNOTSUPP;
		break;

	default:
		panic("mpls_raw_usrreq");
	}

	return (error);
}
@


1.13
log
@No need for <net/if_types.h>

As a bonus this removes a "#if NCARP > 0", say yeah!
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.12 2015/07/20 21:16:39 rzalamena Exp $	*/
a62 13
int	mpls_control(struct socket *, u_long, caddr_t, struct ifnet *);

/*
 * Generic MPLS control operations (ioctl's).
 * Ifp is 0 if not an interface-specific ioctl.
 */
/* ARGSUSED */
int
mpls_control(struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp)
{
	return (EOPNOTSUPP);
}

d74 1
a74 2
		return (mpls_control(so, (u_long)m, (caddr_t)nam,
		    (struct ifnet *)control));
@


1.12
log
@Kill NETISR_MPLS, from now on we will use interface input handlers to deal
with MPLS packets.

ok mpi@@, claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.11 2015/04/10 13:58:20 dlg Exp $	*/
a44 1
#include <net/if_types.h>
@


1.11
log
@replace the use of ifqueues for most input queues serviced by netisr
with niqueues.

this change is so big because there's a lot of code that takes
pointers to different input queues (eg, ether_input picks between
ipv4, ipv6, pppoe, arp, and mpls input queues) and falls through
to code to enqueue packets against the pointer. if i changed only
one of the input queues id have to add sepearate code paths, one
for ifqueues and one for niqueues in each of these places

by flipping all these input queues at once i can keep the currently
common code common.

testing by mpi@@ sthen@@ and rafael zalamena
ok mpi@@ sthen@@ claudio@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.10 2014/12/05 15:50:04 mpi Exp $	*/
d133 1
a133 1
	if (namelen != 1 && name[0] != MPLSCTL_IFQUEUE)
a136 3
	case MPLSCTL_IFQUEUE:
		return (sysctl_niq(name + 1, namelen - 1,
		    oldp, oldlenp, newp, newlen, &mplsintrq));
@


1.10
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.9 2013/03/27 02:00:08 tedu Exp $	*/
d138 1
a138 1
		return (sysctl_ifq(name + 1, namelen - 1,
@


1.9
log
@a little header cleanup. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.8 2010/09/03 13:12:31 claudio Exp $	*/
d44 1
@


1.8
log
@Use MPLS_INKERNEL_LOOP_MAX instead of 16 when initializing mpls_inkloop.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.7 2010/07/15 13:30:45 claudio Exp $	*/
a33 1
#include <sys/malloc.h>
a40 1
#include <sys/proc.h>
a44 1
#include <net/route.h>
@


1.7
log
@Correct function in panic string. From Christophe Fillot
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.6 2010/06/02 15:41:07 claudio Exp $	*/
d58 1
a58 1
int mpls_inkloop = 16;
@


1.6
log
@Kill the mpls enable sysctl knob. Since MPLS needs to be enabled explicitly
on each interface there is no need for yet another knob.
OK michele@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.5 2010/04/22 06:46:18 michele Exp $	*/
d121 1
a121 1
		panic("rip_usrreq");
@


1.5
log
@Unbreak build of MPLS enabled kernel. proc.h is needed.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.4 2008/11/01 16:37:55 michele Exp $	*/
a56 1
int mpls_enable = 0;
@


1.4
log
@Introduced Uniform Model for TTL handling.
MPLS TTL is mapped into network layer one as the packet exits the LSP.
Just IPv4 support for now.
Added the relevant sysctls to enable this behaviour.

Input and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.3 2008/05/23 16:03:03 thib Exp $	*/
d42 1
@


1.3
log
@Make this compile again, by adding a struct proc * argument
to the usrreq's.

(Both MPLS and NETATALK are disabled in GENERIC).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.2 2008/04/23 11:22:23 norby Exp $	*/
d132 1
a132 1
		return EOPNOTSUPP;
@


1.2
log
@I hate working outside the tree.

Fix my faulty import....
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_raw.c,v 1.1 2008/04/23 11:00:35 norby Exp $	*/
d81 1
a81 1
    struct mbuf *control)
@


1.1
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a146 155
/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

/*
 *
 *	$Id: ayame-src.diff,v 1.2 2006/03/04 10:45:08 koifren Exp $
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/protosw.h>
#include <sys/sockio.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/systm.h>
#include <sys/sysctl.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/route.h>

#include <netmpls/mpls.h>
#include <netmpls/mpls_var.h>

#define MPLS_RAW_SNDQ	8192
#define MPLS_RAW_RCVQ	8192

u_long mpls_raw_sendspace = MPLS_RAW_SNDQ;
u_long mpls_raw_recvspace = MPLS_RAW_RCVQ;

int mpls_defttl = 255;
int mpls_inkloop = 16;
int mpls_push_expnull_ip = 0;
int mpls_push_expnull_ip6 = 0;
int mpls_mapttl_ip = 1;
int mpls_mapttl_ip6 = 0;

#define	MPLSCTL_VARS { \
	0, \
	&mpls_defttl, \
	&mpls_inkloop, \
	&mpls_push_expnull_ip, \
	&mpls_push_expnull_ip6, \
	&mpls_mapttl_ip, \
	&mpls_mapttl_ip6, \
}

int
mpls_raw_usrreq(struct socket *so, int req, struct mbuf *m, struct mbuf *nam,
    struct mbuf *control)
{
	int s;
	int error = 0;

#ifdef MPLS_DEBUG
	printf("mpls_raw_usrreq: called! (reqid=%d).\n", req);
#endif	/* MPLS_DEBUG */

	if (req == PRU_CONTROL)
		return (mpls_control(so, (long)m, (caddr_t)nam,
		    (struct ifnet *)control));
/* XXX norby
	if (req == PRU_PURGEIF) {
		mpls_purgeif((struct ifnet *)control);
		return (0);
	}
*/
	s = splsoftnet();

	switch (req) {

	case PRU_ATTACH:
		if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) {
			error = soreserve(so, mpls_raw_sendspace, mpls_raw_recvspace);
			if (error)
				break;
		}
		break;

	case PRU_DETACH:
	case PRU_BIND:
	case PRU_LISTEN:
	case PRU_CONNECT:
	case PRU_CONNECT2:
	case PRU_DISCONNECT:
	case PRU_SHUTDOWN:
	case PRU_RCVD:
	case PRU_SEND:
	case PRU_SENSE:
	case PRU_RCVOOB:
	case PRU_SENDOOB:
	case PRU_SOCKADDR:
	case PRU_PEERADDR:
		error = EOPNOTSUPP;
		break;

	default:
		panic("rip_usrreq");
	}

/* release: */
	splx(s);
	return (error);
}

static int *mpls_sysvars[] = MPLSCTL_VARS;

int
mpls_sysctl(int *name, u_int namelen, void *oldp, size_t *oldlenp, void *newp,
    size_t newlen)
{
	if (name[0] >= MPLSCTL_MAXID)
		return EOPNOTSUPP;
	if (!mpls_sysvars[name[0]])
		return EOPNOTSUPP;

#ifdef MPLS_DEBUG
	printf("mpls_sysctl\n");
#endif	/* MPLS_DEBUG */

	switch (name[0]) {
	default:
		return sysctl_int(oldp, oldlenp, newp, newlen,
		    mpls_sysvars[name[0]]);
	}
}

@

