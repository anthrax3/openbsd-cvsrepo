head	1.8;
access;
symbols
	OPENBSD_6_0:1.8.0.8
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.4
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.6
	OPENBSD_5_8_BASE:1.8
	OPENBSD_5_7:1.8.0.2
	OPENBSD_5_7_BASE:1.8
	OPENBSD_5_6:1.7.0.8
	OPENBSD_5_6_BASE:1.7
	OPENBSD_5_5:1.7.0.6
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.6.0.18
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.16
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.14
	OPENBSD_5_0:1.6.0.12
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.10
	OPENBSD_4_9_BASE:1.6
	OPENBSD_4_8:1.6.0.8
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.4
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.8
date	2014.12.05.15.50.04;	author mpi;	state Exp;
branches;
next	1.7;
commitid	t9FBKDfc4VDxpEy2;

1.7
date	2013.03.27.02.00.08;	author tedu;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.28.22.18.44;	author michele;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.08.12.47.45;	author michele;	state Exp;
branches;
next	1.4;

1.4
date	2008.12.15.16.13.55;	author michele;	state Exp;
branches;
next	1.3;

1.3
date	2008.05.02.12.37.08;	author claudio;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.23.11.22.23;	author norby;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.23.11.00.35;	author norby;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Explicitly include <net/if_var.h> instead of pulling it in <net/if.h>.

ok mikeb@@, krw@@, bluhm@@, tedu@@
@
text
@/*	$OpenBSD: mpls_shim.c,v 1.7 2013/03/27 02:00:08 tedu Exp $	*/

/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/if_var.h>

#include <netmpls/mpls.h>

struct mbuf *
mpls_shim_pop(struct mbuf *m)
{
	/* shaves off top shim header from mbuf */
	m_adj(m, sizeof(struct shim_hdr));

	/* catch-up next shim_hdr */
	if (m->m_len < sizeof(struct shim_hdr))
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == NULL)
			return (NULL);

	/* return mbuf */
	return (m);
}

struct mbuf *
mpls_shim_swap(struct mbuf *m, struct rt_mpls *rt_mpls)
{
	struct shim_hdr *shim;

	/* pullup shim_hdr */
	if (m->m_len < sizeof(struct shim_hdr))
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == NULL)
			return (NULL);
	shim = mtod(m, struct shim_hdr *);

	/* swap label */
	shim->shim_label &= ~MPLS_LABEL_MASK;
	shim->shim_label |= rt_mpls->mpls_label & MPLS_LABEL_MASK;

	/* swap exp : XXX exp override */
	{
		u_int32_t	t;

		shim->shim_label &= ~MPLS_EXP_MASK;
		t = rt_mpls->mpls_exp << MPLS_EXP_OFFSET;
		shim->shim_label |= htonl(t) & MPLS_EXP_MASK;
	}

	return (m);
}

struct mbuf *
mpls_shim_push(struct mbuf *m, struct rt_mpls *rt_mpls)
{
	struct shim_hdr *shim;

	M_PREPEND(m, sizeof(struct shim_hdr), M_DONTWAIT);
	if (m == NULL)
		return (NULL);

	shim = mtod(m, struct shim_hdr *);
	bzero((caddr_t)shim, sizeof(*shim));

	return (mpls_shim_swap(m, rt_mpls));
}
@


1.7
log
@a little header cleanup. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.6 2009/01/28 22:18:44 michele Exp $	*/
d40 1
@


1.6
log
@Get rid of the ugly rtentry hack.

We can now act as edge node and allow ipv4 packets to
enter a Label Switched Path and not just forwarding
MPLS packets.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.5 2009/01/08 12:47:45 michele Exp $	*/
a33 1
#include <sys/malloc.h>
a39 1
#include <net/route.h>
@


1.5
log
@Fix sockaddr_mpls structure.
Now it contains just the label as it must be.

This introduces a ugly hack in rtentry that will be removed
as soon as possible.

OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.4 2008/12/15 16:13:55 michele Exp $	*/
d53 1
a53 1
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == 0)
d61 1
a61 1
mpls_shim_swap(struct mbuf *m, struct sockaddr_mpls *smplsp)
d67 1
a67 1
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == 0)
d73 1
a73 1
	shim->shim_label |= smplsp->smpls_label & MPLS_LABEL_MASK;
d80 1
a80 1
		t = 0;
d88 1
a88 1
mpls_shim_push(struct mbuf *m, struct sockaddr_mpls *smplsp)
d93 1
a93 1
	if (m == 0)
d99 1
a99 1
	return (mpls_shim_swap(m, smplsp));
@


1.4
log
@Initial fixup of sockaddr_mpls struct.

Remove smpls_in_iface as labels must be per platform unique.
Remove smpls_out_iface. It is redudant and can be inferred from nexthop.
Move smpls_operation to rt_flags and temporary remove smpls_out_exp.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.3 2008/05/02 12:37:08 claudio Exp $	*/
d73 1
a73 1
	shim->shim_label |= smplsp->smpls_out_label & MPLS_LABEL_MASK;
@


1.3
log
@There is no need to endian convert the label after swapping it, all label ops
are done with network byte ordering now. OK norby@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.2 2008/04/23 11:22:23 norby Exp $	*/
d80 1
a80 1
		t = smplsp->smpls_out_exp << MPLS_EXP_OFFSET;
@


1.2
log
@I hate working outside the tree.

Fix my faulty import....
@
text
@d1 1
a1 1
/*	$OpenBSD: mpls_shim.c,v 1.1 2008/04/23 11:00:35 norby Exp $	*/
a82 1
	shim->shim_label = htonl(shim->shim_label);
@


1.1
log
@Import MPLS (Multi Protocol Label Switching)

MPLS support partly based on the (abandoned?) AYAME project.
Basic LSR (Label Switch Router) functionality is present, but not fully
functional yet.

It is currently possible to insert entries in the LIB (Label Information Base)
with route(8), but setting the operation type is not supported yet.

Imported to allow more people to work on this in the coming weeks.

ok claudio@@ laurent@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a100 146
}
/*
 * Copyright (C) 1999, 2000 and 2001 AYAME Project, WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
 * SUCH DAMAGE.
 */

/*
 *
 *	$Id: ayame-src.diff,v 1.2 2006/03/04 10:45:08 koifren Exp $
 */

#include <sys/param.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <net/if.h>
#include <net/route.h>

#include <netmpls/mpls.h>
#include <netmpls/mpls_var.h>

struct mbuf *
mpls_shim_pop(struct mbuf *m, struct sockaddr_mpls *smplsp, u_int32_t *labelp,
    u_int8_t *bosp, u_int8_t *ttlp)
{
	u_int32_t label;

	/* shaves off top shim header from mbuf */
	m_adj(m, sizeof(struct shim_hdr));

	/* catch-up next shim_hdr */
	if (m->m_len < sizeof(struct shim_hdr))
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == 0)
			return(0);

	label = ntohl(*mtod(m, u_int32_t *));

	/* set each values, if need */
	if (bosp)
		*bosp = MPLS_SHIM_BOS_ISSET(label);
	if (ttlp)
		*ttlp = MPLS_SHIM_TTL_GET(label);
	if (labelp)
		*labelp = MPLS_SHIM_LABEL_GET(label);
	if (smplsp) {
		bzero(smplsp, sizeof(*smplsp));
		smplsp->smpls_family = AF_MPLS;
		smplsp->smpls_len = sizeof(*smplsp);
		smplsp->smpls_in_label = MPLS_SHIM_LABEL_GET(label);
	}

	/* return mbuf */
	return(m);
}

struct mbuf *
mpls_shim_swap(struct mbuf *m, struct sockaddr_mpls *smplsp, u_int32_t *labelp)
{
	struct shim_hdr *shim;
	u_int32_t label;

	/* pullup shim_hdr */
	if (m->m_len < sizeof(struct shim_hdr))		/* XXX isn't this
					already checked by mpls_shim_peep ? */
		if ((m = m_pullup(m, sizeof(struct shim_hdr))) == 0)
			return(0);
        shim = mtod(m, struct shim_hdr *);
	shim->shim_label = ntohl(shim->shim_label);

	if (smplsp == NULL && labelp == NULL)
		/* can't swap, because no dst label */
		return(m);	/* XXX discard? XXX */

	if (labelp) {
		label = *labelp;
		/*
		if (smplsp)
			smplsp->smpls_in_label = htonl(*labelp);
		*/
	} else
		label = ntohl(smplsp->smpls_in_label);

	/* shim swap label */
	shim->shim_label &= ~SHIM_LABEL_MASK;
	shim->shim_label |= MPLS_SHIM_LABEL_GET(label) << SHIM_LABEL_OFFSET;

	/* shim swap exp : XXX exp override */
	if (smplsp) {
		shim->shim_label &= ~SHIM_EXP_MASK;
		shim->shim_label |=
			smplsp->smpls_out_exp << SHIM_EXP_OFFSET & SHIM_EXP_MASK;
	}
	shim->shim_label = htonl(shim->shim_label);

	return(m);
}

struct mbuf *
mpls_shim_push(struct mbuf *m, struct sockaddr_mpls *smplsp, u_int32_t *labelp,
    u_int8_t *bosp, u_int8_t *ttlp)
{
	struct shim_hdr *shim;

        M_PREPEND(m, sizeof(struct shim_hdr), M_DONTWAIT);
        if (m == 0)
		return(0);

        shim = mtod(m, struct shim_hdr *);
	bzero((caddr_t)shim, sizeof(*shim));

	if (bosp && *bosp)
		shim->shim_label |= SHIM_BOS_MASK;
	if (ttlp)
		shim->shim_label |= *ttlp & SHIM_TTL_MASK;
	else
		shim->shim_label |= 255;	/* XXX */
	m = mpls_shim_swap(m, smplsp, labelp);

	return m;
@

