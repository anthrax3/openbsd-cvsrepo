head	1.4;
access;
symbols
	OPENBSD_6_1:1.4.0.6
	OPENBSD_6_1_BASE:1.4
	OPENBSD_6_0:1.4.0.4
	OPENBSD_6_0_BASE:1.4
	OPENBSD_5_9:1.4.0.2
	OPENBSD_5_9_BASE:1.4
	OPENBSD_5_8:1.3.0.10
	OPENBSD_5_8_BASE:1.3
	OPENBSD_5_7:1.3.0.2
	OPENBSD_5_7_BASE:1.3
	OPENBSD_5_6:1.3.0.6
	OPENBSD_5_6_BASE:1.3
	OPENBSD_5_5:1.3.0.4
	OPENBSD_5_5_BASE:1.3
	OPENBSD_5_4:1.2.0.44
	OPENBSD_5_4_BASE:1.2
	OPENBSD_5_3:1.2.0.42
	OPENBSD_5_3_BASE:1.2
	OPENBSD_5_2:1.2.0.40
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.38
	OPENBSD_5_0:1.2.0.36
	OPENBSD_5_0_BASE:1.2
	OPENBSD_4_9:1.2.0.34
	OPENBSD_4_9_BASE:1.2
	OPENBSD_4_8:1.2.0.32
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.28
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.30
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.26
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.24
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.22
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.20
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.18
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.16
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.14
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.12
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.10
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.8
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.6
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.2
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.1.0.16
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.14
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.2
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.3;
commitid	T0HbsCFlrwPATHlH;

1.3
date	2013.11.18.18.49.53;	author brad;	state Exp;
branches;
next	1.2;

1.2
date	2002.10.27.13.24.26;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.28.23.13.05;	author deraadt;	state Exp;
branches
	1.1.2.1
	1.1.12.1;
next	;

1.1.2.1
date	2000.03.02.07.04.37;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	;

1.1.12.1
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@/*	$OpenBSD: set_key.c,v 1.3 2013/11/18 18:49:53 brad Exp $	*/

/* lib/des/set_key.c */
/* Copyright (C) 1995 Eric Young (eay@@mincom.oz.au)
 * All rights reserved.
 * 
 * This file is part of an SSL implementation written
 * by Eric Young (eay@@mincom.oz.au).
 * The implementation was written so as to conform with Netscapes SSL
 * specification.  This library and applications are
 * FREE FOR COMMERCIAL AND NON-COMMERCIAL USE
 * as long as the following conditions are aheared to.
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.  If this code is used in a product,
 * Eric Young should be given attribution as the author of the parts used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    This product includes software developed by Eric Young (eay@@mincom.oz.au)
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* set_key.c v 1.4 eay 24/9/91
 * 1.4 Speed up by 400% :-)
 * 1.3 added register declarations.
 * 1.2 unrolled make_key_sched a bit more
 * 1.1 added norm_expand_bits
 * 1.0 First working version
 */
#include "des_locl.h"
#include "podd.h"
#include "sk.h"

static int check_parity(des_cblock (*key));

int des_check_key=0;

static int
check_parity(des_cblock (*key))
{
	int i;

	for (i = 0; i < DES_KEY_SZ; i++) {
		if ((*key)[i] != odd_parity[(*key)[i]])
			return(0);
	}
	return (1);
}

/* Weak and semi week keys as take from
 * %A D.W. Davies
 * %A W.L. Price
 * %T Security for Computer Networks
 * %I John Wiley & Sons
 * %D 1984
 * Many thanks to smb@@ulysses.att.com (Steven Bellovin) for the reference
 * (and actual cblock values).
 */
#define NUM_WEAK_KEY	16
static des_cblock weak_keys[NUM_WEAK_KEY]={
	/* weak keys */
	{0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01},
	{0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE},
	{0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F},
	{0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0,0xE0},
	/* semi-weak keys */
	{0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE},
	{0xFE,0x01,0xFE,0x01,0xFE,0x01,0xFE,0x01},
	{0x1F,0xE0,0x1F,0xE0,0x0E,0xF1,0x0E,0xF1},
	{0xE0,0x1F,0xE0,0x1F,0xF1,0x0E,0xF1,0x0E},
	{0x01,0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1},
	{0xE0,0x01,0xE0,0x01,0xF1,0x01,0xF1,0x01},
	{0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E,0xFE},
	{0xFE,0x1F,0xFE,0x1F,0xFE,0x0E,0xFE,0x0E},
	{0x01,0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E},
	{0x1F,0x01,0x1F,0x01,0x0E,0x01,0x0E,0x01},
	{0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1,0xFE},
	{0xFE,0xE0,0xFE,0xE0,0xFE,0xF1,0xFE,0xF1}};

int
des_is_weak_key(des_cblock (*key))
{
	int i;

	for (i = 0; i < NUM_WEAK_KEY; i++) {
		/* Added == 0 to comparision, I obviously don't run
		 * this section very often :-(, thanks to
		 * engineering@@MorningStar.Com for the fix
		 * eay 93/06/29 */
		if (bcmp(weak_keys[i], key, sizeof(des_cblock)) == 0)
			return (1);
	}
	return (0);
}

/* NOW DEFINED IN des_local.h
 * See ecb_encrypt.c for a pseudo description of these macros. 
 * #define PERM_OP(a, b, t, n, m) ((t) = ((((a) >> (n))^(b)) & (m)),\
 * 	(b)^=(t),\
 * 	(a) = ((a)^((t) << (n))))
 */

#define HPERM_OP(a, t, n, m) ((t) = ((((a) << (16 - (n)))^(a)) & (m)),\
	(a) = (a)^(t)^(t >> (16 - (n))))

static int shifts2[16]={0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0};

/* return 0 if key parity is odd (correct),
 * return -1 if key parity error,
 * return -2 if illegal weak key.
 */
int
des_set_key(des_cblock (*key), des_key_schedule schedule)
{
	register u_int32_t c, d, t, s;
	register unsigned char *in;
	register u_int32_t *k;
	register int i;

	if (des_check_key) {
		if (!check_parity(key))
			return(-1);

		if (des_is_weak_key(key))
			return(-2);
	}

	k = (u_int32_t *) schedule;
	in = (unsigned char *) key;

	c2l(in, c);
	c2l(in, d);

	/* do PC1 in 60 simple operations */ 
/*	PERM_OP(d, c, t, 4, 0x0f0f0f0fL);
	HPERM_OP(c, t, -2, 0xcccc0000L);
	HPERM_OP(c, t, -1, 0xaaaa0000L);
	HPERM_OP(c, t, 8, 0x00ff0000L);
	HPERM_OP(c, t, -1, 0xaaaa0000L);
	HPERM_OP(d, t, -8, 0xff000000L);
	HPERM_OP(d, t, 8, 0x00ff0000L);
	HPERM_OP(d, t, 2, 0x33330000L);
	d = ((d & 0x00aa00aaL) << 7L) | ((d & 0x55005500L) >> 7L) | (d & 0xaa55aa55L);
	d = (d >> 8) | ((c & 0xf0000000L) >> 4);
	c &= 0x0fffffffL; */

	/* I now do it in 47 simple operations :-)
	 * Thanks to John Fletcher (john_fletcher@@lccmail.ocf.llnl.gov)
	 * for the inspiration. :-) */
	PERM_OP (d, c, t, 4, 0x0f0f0f0fL);
	HPERM_OP(c, t, -2, 0xcccc0000L);
	HPERM_OP(d, t, -2, 0xcccc0000L);
	PERM_OP (d, c, t, 1, 0x55555555L);
	PERM_OP (c, d, t, 8, 0x00ff00ffL);
	PERM_OP (d, c, t, 1, 0x55555555L);
	d = (((d & 0x000000ffL) << 16L) | (d & 0x0000ff00L) |
	     ((d & 0x00ff0000L) >> 16L) | ((c & 0xf0000000L) >> 4L));
	c &= 0x0fffffffL;

	for (i = 0; i < ITERATIONS; i++) {
		if (shifts2[i])
			{ c = ((c >> 2L) | (c << 26L)); d = ((d >> 2L) | (d << 26L)); }
		else
			{ c = ((c >> 1L) | (c << 27L)); d = ((d >> 1L) | (d << 27L)); }
		c &= 0x0fffffffL;
		d &= 0x0fffffffL;
		/* could be a few less shifts but I am to lazy at this
		 * point in time to investigate */
		s = des_skb[0][ (c    ) & 0x3f                ]|
		    des_skb[1][((c >> 6) & 0x03) | ((c >> 7L) & 0x3c)]|
		    des_skb[2][((c >> 13) & 0x0f) | ((c >> 14L) & 0x30)]|
		    des_skb[3][((c >> 20) & 0x01) | ((c >> 21L) & 0x06) |
						  ((c >> 22L) & 0x38)];
		t = des_skb[4][ (d    ) & 0x3f                ]|
		    des_skb[5][((d >> 7L) & 0x03) | ((d >> 8L) & 0x3c)]|
		    des_skb[6][ (d >> 15L) & 0x3f                ]|
		    des_skb[7][((d >> 21L) & 0x0f) | ((d >> 22L) & 0x30)];

		/* table contained 0213 4657 */
		*(k++) = ((t << 16L) | (s & 0x0000ffffL)) & 0xffffffffL;
		s = ((s >> 16L) | (t & 0xffff0000L));
		
		s = (s << 4L) | (s >> 28L);
		*(k++) = s & 0xffffffffL;
	}
	return (0);
}
@


1.3
log
@ansify some function definitions and tidy up this code style wise. this
ancient code looked pretty crummy.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: set_key.c,v 1.2 2002/10/27 13:24:26 miod Exp $	*/
a60 1
#ifdef PROTO
a61 3
#else
static int check_parity();
#endif
a64 9
void
des_set_odd_parity(des_cblock (*key))
{
	int i;

	for (i = 0; i < DES_KEY_SZ; i++)
		(*key)[i] = odd_parity[(*key)[i]];
}

a213 6
}

int
des_key_sched(des_cblock (*key), des_key_schedule schedule)
{
	return (des_set_key(key, schedule));
@


1.2
log
@Use int32_t rather long on strategic places, to be more sparc64-friendly;
ok jason@@ a long time ago
@
text
@d1 1
a1 1
/*	$OpenBSD: set_key.c,v 1.1 2000/02/28 23:13:05 deraadt Exp $	*/
d69 3
a71 3
void des_set_odd_parity(key)
des_cblock (*key);
	{
d74 7
a80 7
	for (i=0; i<DES_KEY_SZ; i++)
		(*key)[i]=odd_parity[(*key)[i]];
	}

static int check_parity(key)
des_cblock (*key);
	{
d83 1
a83 2
	for (i=0; i<DES_KEY_SZ; i++)
		{
a85 2
		}
	return(1);
d87 2
d120 3
a122 3
int des_is_weak_key(key)
des_cblock (*key);
	{
d125 1
a125 1
	for (i=0; i<NUM_WEAK_KEY; i++)
d130 2
a131 2
		if (bcmp(weak_keys[i],key,sizeof(des_cblock)) == 0) return(1);
	return(0);
d133 2
d138 1
a138 1
 * #define PERM_OP(a,b,t,n,m) ((t)=((((a)>>(n))^(b))&(m)),\
d140 1
a140 1
 * 	(a)=((a)^((t)<<(n))))
d143 2
a144 2
#define HPERM_OP(a,t,n,m) ((t)=((((a)<<(16-(n)))^(a))&(m)),\
	(a)=(a)^(t)^(t>>(16-(n))))
d146 1
a146 1
static int shifts2[16]={0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0};
d152 4
a155 5
int des_set_key(key, schedule)
des_cblock (*key);
des_key_schedule schedule;
	{
	register u_int32_t c,d,t,s;
d160 1
a160 2
	if (des_check_key)
		{
d166 1
a166 1
		}
d168 2
a169 2
	k=(u_int32_t *)schedule;
	in=(unsigned char *)key;
d171 2
a172 2
	c2l(in,c);
	c2l(in,d);
d175 11
a185 11
/*	PERM_OP(d,c,t,4,0x0f0f0f0fL);
	HPERM_OP(c,t,-2, 0xcccc0000L);
	HPERM_OP(c,t,-1, 0xaaaa0000L);
	HPERM_OP(c,t, 8, 0x00ff0000L);
	HPERM_OP(c,t,-1, 0xaaaa0000L);
	HPERM_OP(d,t,-8, 0xff000000L);
	HPERM_OP(d,t, 8, 0x00ff0000L);
	HPERM_OP(d,t, 2, 0x33330000L);
	d=((d&0x00aa00aaL)<<7L)|((d&0x55005500L)>>7L)|(d&0xaa55aa55L);
	d=(d>>8)|((c&0xf0000000L)>>4);
	c&=0x0fffffffL; */
d190 9
a198 9
	PERM_OP (d,c,t,4,0x0f0f0f0fL);
	HPERM_OP(c,t,-2,0xcccc0000L);
	HPERM_OP(d,t,-2,0xcccc0000L);
	PERM_OP (d,c,t,1,0x55555555L);
	PERM_OP (c,d,t,8,0x00ff00ffL);
	PERM_OP (d,c,t,1,0x55555555L);
	d=	(((d&0x000000ffL)<<16L)| (d&0x0000ff00L)     |
		 ((d&0x00ff0000L)>>16L)|((c&0xf0000000L)>>4L));
	c&=0x0fffffffL;
d200 1
a200 2
	for (i=0; i<ITERATIONS; i++)
		{
d202 1
a202 1
			{ c=((c>>2L)|(c<<26L)); d=((d>>2L)|(d<<26L)); }
d204 3
a206 3
			{ c=((c>>1L)|(c<<27L)); d=((d>>1L)|(d<<27L)); }
		c&=0x0fffffffL;
		d&=0x0fffffffL;
d209 9
a217 9
		s=	des_skb[0][ (c    )&0x3f                ]|
			des_skb[1][((c>> 6)&0x03)|((c>> 7L)&0x3c)]|
			des_skb[2][((c>>13)&0x0f)|((c>>14L)&0x30)]|
			des_skb[3][((c>>20)&0x01)|((c>>21L)&0x06) |
						  ((c>>22L)&0x38)];
		t=	des_skb[4][ (d    )&0x3f                ]|
			des_skb[5][((d>> 7L)&0x03)|((d>> 8L)&0x3c)]|
			des_skb[6][ (d>>15L)&0x3f                ]|
			des_skb[7][((d>>21L)&0x0f)|((d>>22L)&0x30)];
d220 2
a221 2
		*(k++)=((t<<16L)|(s&0x0000ffffL))&0xffffffffL;
		s=     ((s>>16L)|(t&0xffff0000L));
d223 2
a224 4
		s=(s<<4L)|(s>>28L);
		*(k++)=s&0xffffffffL;
		}
	return(0);
d226 2
d229 5
a233 6
int des_key_sched(key, schedule)
des_cblock (*key);
des_key_schedule schedule;
	{
	return(des_set_key(key,schedule));
	}
@


1.1
log
@move crypto code
@
text
@d1 1
a1 1
/*	$OpenBSD: set_key.c,v 1.4 1999/02/19 00:48:20 art Exp $	*/
d155 1
a155 1
	register unsigned long c,d,t,s;
d157 1
a157 1
	register unsigned long *k;
d169 1
a169 1
	k=(unsigned long *)schedule;
@


1.1.12.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: set_key.c,v 1.1 2000/02/28 23:13:05 deraadt Exp $	*/
d155 1
a155 1
	register u_int32_t c,d,t,s;
d157 1
a157 1
	register u_int32_t *k;
d169 1
a169 1
	k=(u_int32_t *)schedule;
@


1.1.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@Sync the SMP branch with 3.3
@
text
@d155 1
a155 1
	register u_int32_t c,d,t,s;
d157 1
a157 1
	register u_int32_t *k;
d169 1
a169 1
	k=(u_int32_t *)schedule;
@


