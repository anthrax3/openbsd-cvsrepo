head	1.84;
access;
symbols
	OPENBSD_5_6:1.81.0.4
	OPENBSD_5_6_BASE:1.81
	OPENBSD_5_5:1.80.0.8
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.80.0.4
	OPENBSD_5_4_BASE:1.80
	OPENBSD_5_3:1.80.0.2
	OPENBSD_5_3_BASE:1.80
	OPENBSD_5_2:1.79.0.2
	OPENBSD_5_2_BASE:1.79
	OPENBSD_5_1_BASE:1.77
	OPENBSD_5_1:1.77.0.6
	OPENBSD_5_0:1.77.0.4
	OPENBSD_5_0_BASE:1.77
	OPENBSD_4_9:1.77.0.2
	OPENBSD_4_9_BASE:1.77
	OPENBSD_4_8:1.73.0.2
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.70.0.4
	OPENBSD_4_7_BASE:1.70
	OPENBSD_4_6:1.70.0.6
	OPENBSD_4_6_BASE:1.70
	OPENBSD_4_5:1.70.0.2
	OPENBSD_4_5_BASE:1.70
	OPENBSD_4_4:1.68.0.2
	OPENBSD_4_4_BASE:1.68
	OPENBSD_4_3:1.67.0.2
	OPENBSD_4_3_BASE:1.67
	OPENBSD_4_2:1.66.0.4
	OPENBSD_4_2_BASE:1.66
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.65.0.2
	OPENBSD_4_0_BASE:1.65
	OPENBSD_3_9:1.64.0.4
	OPENBSD_3_9_BASE:1.64
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.62.0.4
	OPENBSD_3_7_BASE:1.62
	OPENBSD_3_6:1.62.0.2
	OPENBSD_3_6_BASE:1.62
	SMP_SYNC_A:1.62
	SMP_SYNC_B:1.62
	OPENBSD_3_5:1.61.0.2
	OPENBSD_3_5_BASE:1.61
	OPENBSD_3_4:1.59.0.2
	OPENBSD_3_4_BASE:1.59
	UBC_SYNC_A:1.55
	OPENBSD_3_3:1.55.0.2
	OPENBSD_3_3_BASE:1.55
	OPENBSD_3_2:1.53.0.2
	OPENBSD_3_2_BASE:1.53
	OPENBSD_3_1:1.36.0.2
	OPENBSD_3_1_BASE:1.36
	UBC_SYNC_B:1.53
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.24.0.2
	OPENBSD_3_0_BASE:1.24
	SMP:1.20.0.2;
locks; strict;
comment	@ * @;


1.84
date	2014.08.20.06.31.22;	author mikeb;	state dead;
branches;
next	1.83;
commitid	aaWPsHjCEZGgdCL9;

1.83
date	2014.08.20.06.23.03;	author mikeb;	state Exp;
branches;
next	1.82;
commitid	3nalvU8sn6rZiZ1d;

1.82
date	2014.08.18.05.11.03;	author dlg;	state Exp;
branches;
next	1.81;
commitid	hjFdrSJM3VTXJUZV;

1.81
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.80;
commitid	C8XZQyreqTUCeixA;

1.80
date	2012.10.28.21.26.11;	author mikeb;	state Exp;
branches;
next	1.79;

1.79
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.78;

1.78
date	2012.02.15.04.26.27;	author guenther;	state Exp;
branches;
next	1.77;

1.77
date	2011.01.11.16.06.40;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2011.01.11.16.04.19;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.14.20.26.44;	author mikeb;	state Exp;
branches;
next	1.74;

1.74
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.73;

1.73
date	2010.07.21.18.44.01;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.20.09.06.38;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.17.19.16.26;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.02.17.18.38.31;	author oga;	state Exp;
branches;
next	1.68;

1.68
date	2008.06.09.16.07.00;	author djm;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.13.21.26.41;	author hshoexer;	state Exp;
branches;
next	1.66;

1.66
date	2006.10.25.15.10.25;	author tedu;	state Exp;
branches;
next	1.65;

1.65
date	2006.05.31.23.01.44;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.18.13.10.02;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2004.05.07.14.42.26;	author millert;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.14.18.36.36;	author markus;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.10.18.34.51;	author jason;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.03.15.51.28;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.03.15.28.06;	author beck;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.30.03.33.23;	author jason;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.21.19.34.25;	author jason;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2002.11.12.18.23.13;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2002.07.10.22.21.30;	author mickey;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.19.07.22.46;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.19.03.23.12;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.12.17.54.15;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.06.12.17.25.38;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2002.06.12.04.16.02;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.11.11.14.29;	author beck;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.10.21.09.27;	author angelos;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.07.08.09.04;	author nordin;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.18.17.00.33;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2002.05.18.09.58.12;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.08.22.04.38;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.27.23.13.59;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2002.04.26.04.31.14;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.24.23.24.32;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.04.23.22.20.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2002.04.23.19.13.04;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.03.05.12.41;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.05.15.59.41;	author markus;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.04.21.25.02;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.01.02.52.51;	author provos;	state Exp;
branches;
next	1.30;

1.30
date	2002.02.23.08.07.59;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.02.08.13.53.28;	author art;	state Exp;
branches;
next	1.28;

1.28
date	2001.11.13.17.45.46;	author deraadt;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.11.08.23.12.38;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.26.12.03.27;	author art;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.03.10.13.44;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.28.12.20.43;	author ben;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.24.17.19.18;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.08.17.17.37.12;	author ben;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.24.17.06.39;	author angelos;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2001.06.23.22.57.55;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.23.22.37.19;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.23.22.36.10;	author angelos;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.23.21.56.58;	author angelos;	state Exp;
branches;
next	1.15;

1.15
date	2001.06.23.18.30.36;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.01.29.40;	author pvalchev;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.18.10.55.01;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.16.10.46.03;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.15.09.14.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.15.00.04.53;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.11.22.44.03;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.16.12.54.34;	author ho;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.15.09.00.23;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.14.15.37.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.14.15.19.37;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.13.16.52.33;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.13.16.16.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	;

1.20.2.1
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.20.2.4;

1.20.2.4
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.20.2.5;

1.20.2.5
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.20.2.6;

1.20.2.6
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.20.2.7;

1.20.2.7
date	2003.06.07.11.02.27;	author ho;	state Exp;
branches;
next	1.20.2.8;

1.20.2.8
date	2004.02.19.10.51.30;	author niklas;	state Exp;
branches;
next	1.20.2.9;

1.20.2.9
date	2004.06.05.23.12.35;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2002.06.11.03.28.34;	author art;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	1.28.2.3;

1.28.2.3
date	2003.05.19.21.53.13;	author tedu;	state Exp;
branches;
next	;

1.55.2.1
date	2003.06.09.17.16.29;	author brad;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2003.06.12.18.54.31;	author brad;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@@


1.83
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@@


1.82
log
@dont rely on mbuf.h to provide pool.h.

ok miod@@, who has offerred to help with any MD fallout
ok guenther@@
@
text
@a0 760
/*	$OpenBSD: cryptodev.c,v 1.81 2014/07/12 18:50:00 tedu Exp $	*/

/*
 * Copyright (c) 2001 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/errno.h>
#include <dev/rndvar.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/cast.h>
#include <crypto/blf.h>
#include <crypto/cryptodev.h>
#include <crypto/xform.h>

extern struct cryptocap *crypto_drivers;
extern int crypto_drivers_num;

struct csession {
	TAILQ_ENTRY(csession) next;
	u_int64_t	sid;
	u_int32_t	ses;

	u_int32_t	cipher;
	struct enc_xform *txform;
	u_int32_t	mac;
	struct auth_hash *thash;

	caddr_t		key;
	int		keylen;
	u_char		tmp_iv[EALG_MAX_BLOCK_LEN];

	caddr_t		mackey;
	int		mackeylen;
	u_char		tmp_mac[CRYPTO_MAX_MAC_LEN];

	struct iovec	iovec[IOV_MAX];
	struct uio	uio;
	int		error;
};

struct fcrypt {
	TAILQ_HEAD(csessionlist, csession) csessions;
	int		sesn;
};

void	cryptoattach(int);

int	cryptof_read(struct file *, off_t *, struct uio *, struct ucred *);
int	cryptof_write(struct file *, off_t *, struct uio *, struct ucred *);
int	cryptof_ioctl(struct file *, u_long, caddr_t, struct proc *p);
int	cryptof_poll(struct file *, int, struct proc *);
int	cryptof_kqfilter(struct file *, struct knote *);
int	cryptof_stat(struct file *, struct stat *, struct proc *);
int	cryptof_close(struct file *, struct proc *);

static struct fileops cryptofops = {
    cryptof_read,
    cryptof_write,
    cryptof_ioctl,
    cryptof_poll,
    cryptof_kqfilter,
    cryptof_stat,
    cryptof_close
};

struct	csession *csefind(struct fcrypt *, u_int);
int	csedelete(struct fcrypt *, struct csession *);
struct	csession *cseadd(struct fcrypt *, struct csession *);
struct	csession *csecreate(struct fcrypt *, u_int64_t, caddr_t, u_int64_t,
    caddr_t, u_int64_t, u_int32_t, u_int32_t, struct enc_xform *,
    struct auth_hash *);
int	csefree(struct csession *);

int	cryptodev_op(struct csession *, struct crypt_op *, struct proc *);
int	cryptodev_key(struct crypt_kop *);
int	cryptodev_dokey(struct crypt_kop *kop, struct crparam kvp[]);

int	cryptodev_cb(struct cryptop *);
int	cryptodevkey_cb(struct cryptkop *);

int	usercrypto = 0;		/* userland may do crypto requests */
int	userasymcrypto = 0;	/* userland may do asymmetric crypto reqs */
int	cryptodevallowsoft = 0;	/* only use hardware crypto */

/* ARGSUSED */
int
cryptof_read(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{
	return (EIO);
}

/* ARGSUSED */
int
cryptof_write(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
{
	return (EIO);
}

/* ARGSUSED */
int
cryptof_ioctl(struct file *fp, u_long cmd, caddr_t data, struct proc *p)
{
	struct cryptoini cria, crie;
	struct fcrypt *fcr = fp->f_data;
	struct csession *cse;
	struct session_op *sop;
	struct crypt_op *cop;
	struct enc_xform *txform = NULL;
	struct auth_hash *thash = NULL;
	u_int64_t sid;
	u_int32_t ses;
	int error = 0;

	switch (cmd) {
	case CIOCGSESSION:
		sop = (struct session_op *)data;
		switch (sop->cipher) {
		case 0:
			break;
		case CRYPTO_DES_CBC:
			txform = &enc_xform_des;
			break;
		case CRYPTO_3DES_CBC:
			txform = &enc_xform_3des;
			break;
		case CRYPTO_BLF_CBC:
			txform = &enc_xform_blf;
			break;
		case CRYPTO_CAST_CBC:
			txform = &enc_xform_cast5;
			break;
		case CRYPTO_AES_CBC:
			txform = &enc_xform_rijndael128;
			break;
		case CRYPTO_AES_CTR:
			txform = &enc_xform_aes_ctr;
			break;
		case CRYPTO_AES_XTS:
			txform = &enc_xform_aes_xts;
			break;
		case CRYPTO_ARC4:
			txform = &enc_xform_arc4;
			break;
		case CRYPTO_NULL:
			txform = &enc_xform_null;
			break;
		default:
			return (EINVAL);
		}

		switch (sop->mac) {
		case 0:
			break;
#if 0
		case CRYPTO_MD5_HMAC:
			thash = &auth_hash_hmac_md5_96;
			break;
		case CRYPTO_SHA1_HMAC:
			thash = &auth_hash_hmac_sha1_96;
			break;
		case CRYPTO_RIPEMD160_HMAC:
			thash = &auth_hash_hmac_ripemd_160_96;
			break;
		case CRYPTO_MD5:
			thash = &auth_hash_md5;
			break;
		case CRYPTO_SHA1:
			thash = &auth_hash_sha1;
			break;
#endif
		default:
			return (EINVAL);
		}

		bzero(&crie, sizeof(crie));
		bzero(&cria, sizeof(cria));

		if (txform) {
			crie.cri_alg = txform->type;
			crie.cri_klen = sop->keylen * 8;
			if (sop->keylen > txform->maxkey ||
			    sop->keylen < txform->minkey) {
				error = EINVAL;
				goto bail;
			}

			crie.cri_key = malloc(crie.cri_klen / 8, M_XDATA,
			    M_WAITOK);
			if ((error = copyin(sop->key, crie.cri_key,
			    crie.cri_klen / 8)))
				goto bail;
			if (thash)
				crie.cri_next = &cria;
		}

		if (thash) {
			cria.cri_alg = thash->type;
			cria.cri_klen = sop->mackeylen * 8;
			if (sop->mackeylen != thash->keysize) {
				error = EINVAL;
				goto bail;
			}

			if (cria.cri_klen) {
				cria.cri_key = malloc(cria.cri_klen / 8,
				    M_XDATA, M_WAITOK);
				if ((error = copyin(sop->mackey, cria.cri_key,
				    cria.cri_klen / 8)))
					goto bail;
			}
		}

		error = crypto_newsession(&sid, (txform ? &crie : &cria),
		    !cryptodevallowsoft);

		if (error)
			goto bail;

		cse = csecreate(fcr, sid, crie.cri_key, crie.cri_klen,
		    cria.cri_key, cria.cri_klen, sop->cipher, sop->mac, txform,
		    thash);

		if (cse == NULL) {
			crypto_freesession(sid);
			error = EINVAL;
			goto bail;
		}
		sop->ses = cse->ses;

bail:
		if (error) {
			if (crie.cri_key) {
				explicit_bzero(crie.cri_key, crie.cri_klen / 8);
				free(crie.cri_key, M_XDATA, 0);
			}
			if (cria.cri_key) {
				explicit_bzero(cria.cri_key, cria.cri_klen / 8);
				free(cria.cri_key, M_XDATA, 0);
			}
		}
		break;
	case CIOCFSESSION:
		ses = *(u_int32_t *)data;
		cse = csefind(fcr, ses);
		if (cse == NULL)
			return (EINVAL);
		csedelete(fcr, cse);
		error = csefree(cse);
		break;
	case CIOCCRYPT:
		cop = (struct crypt_op *)data;
		cse = csefind(fcr, cop->ses);
		if (cse == NULL)
			return (EINVAL);
		error = cryptodev_op(cse, cop, p);
		break;
	case CIOCKEY:
		error = cryptodev_key((struct crypt_kop *)data);
		break;
	case CIOCASYMFEAT:
		error = crypto_getfeat((int *)data);
		break;
	default:
		error = EINVAL;
	}
	return (error);
}

int
cryptodev_op(struct csession *cse, struct crypt_op *cop, struct proc *p)
{
	struct cryptop *crp = NULL;
	struct cryptodesc *crde = NULL, *crda = NULL;
	int s, error;
	u_int32_t hid;

	if (cop->len > 64*1024-4)
		return (E2BIG);

	if (cse->txform) {
		if (cop->len == 0 || (cop->len % cse->txform->blocksize) != 0)
			return (EINVAL);
	}

	bzero(&cse->uio, sizeof(cse->uio));
	cse->uio.uio_iovcnt = 1;
	cse->uio.uio_segflg = UIO_SYSSPACE;
	cse->uio.uio_rw = UIO_WRITE;
	cse->uio.uio_procp = p;
	cse->uio.uio_iov = cse->iovec;
	bzero(&cse->iovec, sizeof(cse->iovec));
	cse->uio.uio_iov[0].iov_len = cop->len;
	cse->uio.uio_iov[0].iov_base = dma_alloc(cop->len, M_WAITOK);
	cse->uio.uio_resid = cse->uio.uio_iov[0].iov_len;

	/* number of requests, not logical and */
	crp = crypto_getreq((cse->txform != NULL) + (cse->thash != NULL));
	if (crp == NULL) {
		error = ENOMEM;
		goto bail;
	}

	if (cse->thash) {
		crda = crp->crp_desc;
		if (cse->txform)
			crde = crda->crd_next;
	} else {
		if (cse->txform)
			crde = crp->crp_desc;
		else {
			error = EINVAL;
			goto bail;
		}
	}

	if ((error = copyin(cop->src, cse->uio.uio_iov[0].iov_base, cop->len)))
		goto bail;

	if (crda) {
		crda->crd_skip = 0;
		crda->crd_len = cop->len;
		crda->crd_inject = 0;	/* ??? */

		crda->crd_alg = cse->mac;
		crda->crd_key = cse->mackey;
		crda->crd_klen = cse->mackeylen * 8;
	}

	if (crde) {
		if (cop->op == COP_ENCRYPT)
			crde->crd_flags |= CRD_F_ENCRYPT;
		else
			crde->crd_flags &= ~CRD_F_ENCRYPT;
		crde->crd_len = cop->len;
		crde->crd_inject = 0;

		crde->crd_alg = cse->cipher;
		crde->crd_key = cse->key;
		crde->crd_klen = cse->keylen * 8;
	}

	crp->crp_ilen = cop->len;
	crp->crp_buf = (caddr_t)&cse->uio;
	crp->crp_callback = cryptodev_cb;
	crp->crp_sid = cse->sid;
	crp->crp_opaque = cse;

	if (cop->iv) {
		if (crde == NULL) {
			error = EINVAL;
			goto bail;
		}
		if (cse->cipher == CRYPTO_ARC4) { /* XXX use flag? */
			error = EINVAL;
			goto bail;
		}
		if ((error = copyin(cop->iv, cse->tmp_iv, cse->txform->blocksize)))
			goto bail;
		bcopy(cse->tmp_iv, crde->crd_iv, cse->txform->blocksize);
		crde->crd_flags |= CRD_F_IV_EXPLICIT | CRD_F_IV_PRESENT;
		crde->crd_skip = 0;
	} else if (cse->cipher == CRYPTO_ARC4) { /* XXX use flag? */
		crde->crd_skip = 0;
	} else if (crde) {
		crde->crd_flags |= CRD_F_IV_PRESENT;
		crde->crd_skip = cse->txform->blocksize;
		crde->crd_len -= cse->txform->blocksize;
	}

	if (cop->mac) {
		if (crda == NULL) {
			error = EINVAL;
			goto bail;
		}
		crp->crp_mac = cse->tmp_mac;
	}

	/* try the fast path first */
	crp->crp_flags = CRYPTO_F_IOV | CRYPTO_F_NOQUEUE;
	hid = (crp->crp_sid >> 32) & 0xffffffff;
	if (hid >= crypto_drivers_num)
		goto dispatch;
	if (crypto_drivers[hid].cc_flags & CRYPTOCAP_F_SOFTWARE)
		goto dispatch;
	if (crypto_drivers[hid].cc_process == NULL)
		goto dispatch;
	error = crypto_drivers[hid].cc_process(crp);
	if (error) {
		/* clear error */
		crp->crp_etype = 0;
		goto dispatch;
	}
	goto processed;
 dispatch:
	crp->crp_flags = CRYPTO_F_IOV;
	crypto_dispatch(crp);
 processed:
	s = splnet();
	while (!(crp->crp_flags & CRYPTO_F_DONE)) {
		error = tsleep(cse, PSOCK, "crydev", 0);
	}
	splx(s);
	if (error) {
		/* XXX can this happen?  if so, how do we recover? */
		goto bail;
	}

	if (cse->error) {
		error = cse->error;
		goto bail;
	}
	if (crp->crp_etype != 0) {
		error = crp->crp_etype;
		goto bail;
	}


	if (cop->dst &&
	    (error = copyout(cse->uio.uio_iov[0].iov_base, cop->dst, cop->len)))
		goto bail;

	if (cop->mac &&
	    (error = copyout(crp->crp_mac, cop->mac, cse->thash->authsize)))
		goto bail;

bail:
	if (crp)
		crypto_freereq(crp);
	if (cse->uio.uio_iov[0].iov_base)
		dma_free(cse->uio.uio_iov[0].iov_base, cop->len);

	return (error);
}

int
cryptodev_cb(struct cryptop *crp)
{
	struct csession *cse = crp->crp_opaque;

	cse->error = crp->crp_etype;
	if (crp->crp_etype == EAGAIN) {
		crp->crp_flags = CRYPTO_F_IOV;
		return crypto_dispatch(crp);
	}
	wakeup(cse);
	return (0);
}

int
cryptodevkey_cb(struct cryptkop *krp)
{

	wakeup(krp);
	return (0);
}

int
cryptodev_key(struct crypt_kop *kop)
{
	struct cryptkop *krp = NULL;
	int error = EINVAL;
	int in, out, size, i;

	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM) {
		return (EFBIG);
	}

	in = kop->crk_iparams;
	out = kop->crk_oparams;
	switch (kop->crk_op) {
	case CRK_MOD_EXP:
		if (in == 3 && out == 1)
			break;
		return (EINVAL);
	case CRK_MOD_EXP_CRT:
		if (in == 6 && out == 1)
			break;
		return (EINVAL);
	case CRK_DSA_SIGN:
		if (in == 5 && out == 2)
			break;
		return (EINVAL);
	case CRK_DSA_VERIFY:
		if (in == 7 && out == 0)
			break;
		return (EINVAL);
	case CRK_DH_COMPUTE_KEY:
		if (in == 3 && out == 1)
			break;
		return (EINVAL);
	default:
		return (EINVAL);
	}

	krp = malloc(sizeof *krp, M_XDATA, M_WAITOK | M_ZERO);
	krp->krp_op = kop->crk_op;
	krp->krp_status = kop->crk_status;
	krp->krp_iparams = kop->crk_iparams;
	krp->krp_oparams = kop->crk_oparams;
	krp->krp_status = 0;
	krp->krp_callback = cryptodevkey_cb;

	for (i = 0; i < CRK_MAXPARAM; i++) {
		krp->krp_param[i].crp_nbits = kop->crk_param[i].crp_nbits;
		if (kop->crk_param[i].crp_nbits > 65536) {
			/* XXX how big do we need to support? */
			goto fail;
		}
	}
	for (i = 0; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		krp->krp_param[i].crp_p = malloc(size, M_XDATA, M_WAITOK);
		if (i >= krp->krp_iparams)
			continue;
		error = copyin(kop->crk_param[i].crp_p, krp->krp_param[i].crp_p, size);
		if (error)
			goto fail;
	}

	error = crypto_kdispatch(krp);
	if (error)
		goto fail;
	error = tsleep(krp, PSOCK, "crydev", 0);
	if (error) {
		/* XXX can this happen?  if so, how do we recover? */
		goto fail;
	}
	
	if (krp->krp_status != 0) {
		error = krp->krp_status;
		goto fail;
	}

	for (i = krp->krp_iparams; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		error = copyout(krp->krp_param[i].crp_p, kop->crk_param[i].crp_p, size);
		if (error)
			goto fail;
	}

fail:
	if (krp) {
		kop->crk_status = krp->krp_status;
		for (i = 0; i < CRK_MAXPARAM; i++) {
			if (krp->krp_param[i].crp_p) {
				explicit_bzero(krp->krp_param[i].crp_p,
				    (krp->krp_param[i].crp_nbits + 7) / 8);
				free(krp->krp_param[i].crp_p, M_XDATA, 0);
			}
		}
		free(krp, M_XDATA, 0);
	}
	return (error);
}

/* ARGSUSED */
int
cryptof_poll(struct file *fp, int events, struct proc *p)
{
	return (0);
}

/* ARGSUSED */
int
cryptof_kqfilter(struct file *fp, struct knote *kn)
{
	return (0);
}

/* ARGSUSED */
int
cryptof_stat(struct file *fp, struct stat *sb, struct proc *p)
{
	return (EOPNOTSUPP);
}

/* ARGSUSED */
int
cryptof_close(struct file *fp, struct proc *p)
{
	struct fcrypt *fcr = fp->f_data;
	struct csession *cse;

	while ((cse = TAILQ_FIRST(&fcr->csessions))) {
		TAILQ_REMOVE(&fcr->csessions, cse, next);
		(void)csefree(cse);
	}
	free(fcr, M_XDATA, 0);
	fp->f_data = NULL;
	return 0;
}

void
cryptoattach(int n)
{
}

int
cryptoopen(dev_t dev, int flag, int mode, struct proc *p)
{
	if (usercrypto == 0)
		return (ENXIO);
#ifdef CRYPTO
	return (0);
#else
	return (ENXIO);
#endif
}

int
cryptoclose(dev_t dev, int flag, int mode, struct proc *p)
{
	return (0);
}

int
cryptoioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct file *f;
	struct fcrypt *fcr;
	int fd, error;

	switch (cmd) {
	case CRIOGET:
		fcr = malloc(sizeof(struct fcrypt), M_XDATA, M_WAITOK);
		TAILQ_INIT(&fcr->csessions);
		fcr->sesn = 0;

		fdplock(p->p_fd);
		error = falloc(p, &f, &fd);
		fdpunlock(p->p_fd);
		if (error) {
			free(fcr, M_XDATA, 0);
			return (error);
		}
		f->f_flag = FREAD | FWRITE;
		f->f_type = DTYPE_CRYPTO;
		f->f_ops = &cryptofops;
		f->f_data = fcr;
		*(u_int32_t *)data = fd;
		FILE_SET_MATURE(f, p);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}

struct csession *
csefind(struct fcrypt *fcr, u_int ses)
{
	struct csession *cse;

	TAILQ_FOREACH(cse, &fcr->csessions, next)
		if (cse->ses == ses)
			return (cse);
	return (NULL);
}

int
csedelete(struct fcrypt *fcr, struct csession *cse_del)
{
	struct csession *cse;

	TAILQ_FOREACH(cse, &fcr->csessions, next) {
		if (cse == cse_del) {
			TAILQ_REMOVE(&fcr->csessions, cse, next);
			return (1);
		}
	}
	return (0);
}

struct csession *
cseadd(struct fcrypt *fcr, struct csession *cse)
{
	TAILQ_INSERT_TAIL(&fcr->csessions, cse, next);
	cse->ses = fcr->sesn++;
	return (cse);
}

struct csession *
csecreate(struct fcrypt *fcr, u_int64_t sid, caddr_t key, u_int64_t keylen,
    caddr_t mackey, u_int64_t mackeylen, u_int32_t cipher, u_int32_t mac,
    struct enc_xform *txform, struct auth_hash *thash)
{
	struct csession *cse;

	cse = malloc(sizeof(struct csession), M_XDATA, M_NOWAIT);
	if (cse == NULL)
		return NULL;
	cse->key = key;
	cse->keylen = keylen/8;
	cse->mackey = mackey;
	cse->mackeylen = mackeylen/8;
	cse->sid = sid;
	cse->cipher = cipher;
	cse->mac = mac;
	cse->txform = txform;
	cse->thash = thash;
	cseadd(fcr, cse);
	return (cse);
}

int
csefree(struct csession *cse)
{
	int error;

	error = crypto_freesession(cse->sid);
	if (cse->key)
		free(cse->key, M_XDATA, 0);
	if (cse->mackey)
		free(cse->mackey, M_XDATA, 0);
	free(cse, M_XDATA, 0);
	return (error);
}
@


1.81
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.80 2012/10/28 21:26:11 mikeb Exp $	*/
d36 1
@


1.80
log
@We need to allocate memory for crp_buf in the DMA accessible
region since it's passed to the hardware directly.

Tested by Yoshihisa Matsushita <y at m8a ! org>, thanks!
ok kettenis miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.79 2012/04/22 05:43:14 guenther Exp $	*/
d271 1
a271 1
				free(crie.cri_key, M_XDATA);
d275 1
a275 1
				free(cria.cri_key, M_XDATA);
d589 1
a589 1
				free(krp->krp_param[i].crp_p, M_XDATA);
d592 1
a592 1
		free(krp, M_XDATA);
d629 1
a629 1
	free(fcr, M_XDATA);
d674 1
a674 1
			free(fcr, M_XDATA);
d754 1
a754 1
		free(cse->key, M_XDATA);
d756 2
a757 2
		free(cse->mackey, M_XDATA);
	free(cse, M_XDATA);
@


1.79
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.78 2012/02/15 04:26:27 guenther Exp $	*/
d330 1
a330 1
	cse->uio.uio_iov[0].iov_base = malloc(cop->len, M_XDATA, M_WAITOK); /* XXX dma accessible */
d467 1
a467 1
		free(cse->uio.uio_iov[0].iov_base, M_XDATA);
@


1.78
log
@Hold struct filedesc's fd_lock when writing to the fd_ofiles, fd_ofileflags,
or fd_{lo,hi}maps members, or when doing a read for a write.  Fixes hangs
when an rthreaded processes sleeps while copying the fd table for fork()
and catches another thread with the lock.

ok jsing@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.77 2011/01/11 16:06:40 deraadt Exp $	*/
d682 1
a682 1
		FILE_SET_MATURE(f);
@


1.77
log
@key lengths are counted in bits
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.76 2011/01/11 16:04:19 deraadt Exp $	*/
d37 1
d670 1
d672 1
@


1.76
log
@add explicit_bzero() calls before free()ing key material
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.75 2010/12/14 20:26:44 mikeb Exp $	*/
d269 1
a269 1
				explicit_bzero(crie.cri_key, crie.cri_klen);
d273 1
a273 1
				explicit_bzero(cria.cri_key, cria.cri_klen);
@


1.75
log
@disable access to the crypto(4) device from userland; ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.74 2010/10/06 22:19:20 mikeb Exp $	*/
d268 2
a269 1
			if (crie.cri_key)
d271 3
a273 1
			if (cria.cri_key)
d275 1
d585 3
a587 1
			if (krp->krp_param[i].crp_p)
d589 1
@


1.74
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.73 2010/07/21 18:44:01 deraadt Exp $	*/
d117 2
a118 2
int	usercrypto = 1;		/* userland may do crypto requests */
int	userasymcrypto = 1;	/* userland may do asymmetric crypto reqs */
@


1.73
log
@No need for read/write functions, just use enodev like all the other
things things do
ok nicm
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.72 2010/07/20 09:06:38 matthew Exp $	*/
a46 1
#include <crypto/skipjack.h>
a166 3
			break;
		case CRYPTO_SKIPJACK_CBC:
			txform = &enc_xform_skipjack;
@


1.72
log
@Mark a DMA accessible malloc for later correction.  This is
potentially up to 64KB, so we'll need something fancier than
dma_alloc().
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.71 2010/04/20 22:05:41 tedu Exp $	*/
a653 12
cryptoread(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
cryptowrite(dev_t dev, struct uio *uio, int ioflag)
{
	return (EIO);
}

int
a682 6
}

int
cryptopoll(dev_t dev, int events, struct proc *p)
{
	return (seltrue(dev, events, p));
@


1.71
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.70 2009/02/17 19:16:26 deraadt Exp $	*/
d329 1
a329 1
	cse->uio.uio_iov[0].iov_base = malloc(cop->len, M_XDATA, M_WAITOK);
@


1.70
log
@variable no longer used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.69 2009/02/17 18:38:31 oga Exp $	*/
a36 1
#include <sys/sysctl.h>
@


1.69
log
@The loop here preparing the uio always added the length of the first
iovec, not the correct one. It worked ok since iovcnt was always 1.

Since it's unlikely to be any other number, remove the loop and just add
the one length we care about.

"go ahead" deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.68 2008/06/09 16:07:00 djm Exp $	*/
d311 1
a311 1
	int i, s, error;
@


1.68
log
@Implement the AES XTS mode of operation for the crypto(9) framework.
XTS is a "tweaked" AES mode that has properties that are desirable
for block device encryption and it is specified in the IEEE
P1619-2007 standard for this purpose.

prodded by & ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.67 2007/09/13 21:26:41 hshoexer Exp $	*/
a323 1
	cse->uio.uio_resid = 0;
d331 1
a331 2
	for (i = 0; i < cse->uio.uio_iovcnt; i++)
		cse->uio.uio_resid += cse->uio.uio_iov[0].iov_len;
@


1.67
log
@Here too:  Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

error spotting and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.66 2006/10/25 15:10:25 tedu Exp $	*/
d178 3
@


1.66
log
@pr5274 fix localhost dos with oversized values
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.65 2006/05/31 23:01:44 tedu Exp $	*/
d225 2
a226 2
			MALLOC(crie.cri_key, u_int8_t *,
			    crie.cri_klen / 8, M_XDATA, M_WAITOK);
d243 2
a244 2
				MALLOC(cria.cri_key, u_int8_t *,
				    cria.cri_klen / 8, M_XDATA, M_WAITOK);
d271 1
a271 1
				FREE(crie.cri_key, M_XDATA);
d273 1
a273 1
				FREE(cria.cri_key, M_XDATA);
d531 1
a531 2
	krp = malloc(sizeof *krp, M_XDATA, M_WAITOK);
	bzero(krp, sizeof *krp);
d625 1
a625 1
	FREE(fcr, M_XDATA);
d674 1
a674 2
		MALLOC(fcr, struct fcrypt *,
		    sizeof(struct fcrypt), M_XDATA, M_WAITOK);
d680 1
a680 1
			FREE(fcr, M_XDATA);
d743 1
a743 2
	MALLOC(cse, struct csession *, sizeof(struct csession),
	    M_XDATA, M_NOWAIT);
d766 1
a766 1
		FREE(cse->key, M_XDATA);
d768 2
a769 2
		FREE(cse->mackey, M_XDATA);
	FREE(cse, M_XDATA);
@


1.65
log
@remove some silly casts.  put spl calls after all declarations.
put one splx in a better spot.  make a variable size MALLOC use malloc.
remove null test after malloc(M_WAITOK).
add PR_NOWAIT flag to pool_get instead of 0.  change callbacks to correct type.
ok brad deraadt markus mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.64 2005/08/18 13:10:02 deraadt Exp $	*/
d540 1
a540 1
	for (i = 0; i < CRK_MAXPARAM; i++)
d542 5
@


1.64
log
@do not allow 0-length transforms; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.63 2005/05/25 05:47:53 markus Exp $	*/
d116 2
a117 2
int	cryptodev_cb(void *);
int	cryptodevkey_cb(void *);
d142 1
a142 1
	struct fcrypt *fcr = (struct fcrypt *)fp->f_data;
d306 1
a306 1
	struct cryptop *crp= NULL;
d332 1
d380 1
a380 1
	crp->crp_callback = (int (*) (struct cryptop *)) cryptodev_cb;
d382 1
a382 1
	crp->crp_opaque = (void *)cse;
d411 1
a411 1
		crp->crp_mac=cse->tmp_mac;
d472 1
a472 1
cryptodev_cb(void *op)
d474 1
a474 2
	struct cryptop *crp = (struct cryptop *) op;
	struct csession *cse = (struct csession *)crp->crp_opaque;
d486 1
a486 1
cryptodevkey_cb(void *op)
a487 1
	struct cryptkop *krp = (struct cryptkop *) op;
d531 1
a531 3
	krp = (struct cryptkop *)malloc(sizeof *krp, M_XDATA, M_WAITOK);
	if (!krp)
		return (ENOMEM);
d538 1
a538 1
	krp->krp_callback = (int (*) (struct cryptkop *)) cryptodevkey_cb;
d546 1
a546 1
		MALLOC(krp->krp_param[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
d582 1
a582 1
				FREE(krp->krp_param[i].crp_p, M_XDATA);
d614 1
a614 1
	struct fcrypt *fcr = (struct fcrypt *)fp->f_data;
d683 1
a683 1
		f->f_data = (caddr_t)fcr;
@


1.63
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.62 2004/05/07 14:42:26 millert Exp $	*/
d314 3
a316 2
	if (cse->txform && (cop->len % cse->txform->blocksize) != 0) {
		return (EINVAL);
@


1.62
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.61 2004/03/14 18:36:36 markus Exp $	*/
d175 3
@


1.61
log
@disable mac for now, they are not usable with current hardware; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.60 2003/09/23 16:51:12 millert Exp $	*/
a40 1
#include <sys/md5k.h>
d44 1
@


1.60
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.59 2003/06/10 18:34:51 jason Exp $	*/
d189 1
d205 1
@


1.59
log
@don't allow /dev/crypto to be opened ifndef CRYPTO (the thread hasn't been
started, so all operations will hang later on anyway).
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.58 2003/06/03 15:51:28 deraadt Exp $	*/
d89 1
a89 1
int	cryptof_select(struct file *, int, struct proc *);
d98 1
a98 1
    cryptof_select,
d588 1
a588 1
cryptof_select(struct file *fp, int which, struct proc *p)
d692 1
a692 1
cryptoselect(dev_t dev, int rw, struct proc *p)
d694 1
a694 1
	return (0);
@


1.58
log
@license cleanup regarding term 4
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.57 2003/06/03 15:28:06 beck Exp $	*/
d633 1
d635 3
@


1.57
log
@Fastpath for userland crypto requests. This change makes userland
crypto requests attempt to call the crypto driver directly to process
crypto layer requests, as opposed to queueing them in the kernel
crypto thread. If we can't use the crypto devices (i.e. they're busy)
we fall back to queueing the request up in the crypto thread as
before. This does allow for faster performance in some cases (smaller
requests, how small seems to be dependent on the card/cpu combination)
where context switching is a major issue in performance.
ok deraadt@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.56 2003/05/30 03:33:23 jason Exp $	*/
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
@


1.56
log
@move max limit back down to 65536-4
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.55 2002/11/21 19:34:25 jason Exp $	*/
d55 3
d303 1
a303 1
	struct cryptop *crp = NULL;
d305 2
a306 1
	int i, error;
a373 1
	crp->crp_flags = CRYPTO_F_IOV;
d409 18
d428 6
a433 1
	error = tsleep(cse, PSOCK, "crydev", 0);
d439 4
a447 4
	if (cse->error) {
		error = cse->error;
		goto bail;
	}
d473 2
a474 1
	if (crp->crp_etype == EAGAIN)
d476 1
@


1.55
log
@From Angelos:
- simplistic load balancing across multiple cards
- simplified registration process
- a few style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.54 2002/11/12 18:23:13 jason Exp $	*/
d304 1
a304 1
	if (cop->len > 256*1024-4)
@


1.54
log
@Add a CRYPTO_NULL xform (it's a do nothing, but nice for measuring the
bandwidth of the kernel API).  It's only available from userland and
then only if kern.cryptodevallowsoft=1.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.53 2002/07/10 22:21:30 mickey Exp $	*/
d307 1
a307 1
	if (cse->txform && (cop->len % cse->txform->blocksize) != 0)
d309 1
@


1.53
log
@proper cdev_decl(crypto) and no private protos
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.52 2002/06/19 07:22:46 deraadt Exp $	*/
d177 3
@


1.52
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.51 2002/06/19 03:23:12 deraadt Exp $	*/
a83 7

int	cryptoopen(dev_t, int, int, struct proc *);
int	cryptoclose(dev_t, int, int, struct proc *);
int	cryptoread(dev_t, struct uio *, int);
int	cryptowrite(dev_t, struct uio *, int);
int	cryptoioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cryptoselect(dev_t, int, struct proc *);
@


1.51
log
@re-enable both crypto operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.50 2002/06/12 17:54:15 deraadt Exp $	*/
d131 1
a131 5
cryptof_read(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d138 1
a138 5
cryptof_write(fp, poff, uio, cred)
	struct file *fp;
	off_t *poff;
	struct uio *uio;
	struct ucred *cred;
d145 1
a145 5
cryptof_ioctl(fp, cmd, data, p)
	struct file *fp;
	u_long cmd;
	caddr_t data;
	struct proc *p;
d565 1
a565 4
cryptof_select(fp, which, p)
	struct file *fp;
	int which;
	struct proc *p;
d572 1
a572 3
cryptof_kqfilter(fp, kn)
	struct file *fp;
	struct knote *kn;
d579 1
a579 4
cryptof_stat(fp, sb, p)
	struct file *fp;
	struct stat *sb;
	struct proc *p;
d586 1
a586 3
cryptof_close(fp, p)
	struct file *fp;
	struct proc *p;
d606 1
a606 5
cryptoopen(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d614 1
a614 5
cryptoclose(dev, flag, mode, p)
	dev_t	dev;
	int	flag;
	int	mode;
	struct proc *p;
d620 1
a620 4
cryptoread(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
d626 1
a626 4
cryptowrite(dev, uio, ioflag)
	dev_t	dev;
	struct uio *uio;
	int	ioflag;
d632 1
a632 6
cryptoioctl(dev, cmd, data, flag, p)
	dev_t	dev;
	u_long	cmd;
	caddr_t	data;
	int	flag;
	struct proc *p;
d665 1
a665 4
cryptoselect(dev, rw, p)
	dev_t	dev;
	int	rw;
	struct proc *p;
@


1.50
log
@looks slightly better
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.49 2002/06/12 17:25:38 markus Exp $	*/
d125 2
a126 2
int	usercrypto = 0;		/* userland may do crypto requests */
int	userasymcrypto = 0;	/* userland may do asymmetric crypto reqs */
@


1.49
log
@undo 1.46; fixes double free (the keys are freed on session close).
passes regress/sys/crypto
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.48 2002/06/12 04:16:02 deraadt Exp $	*/
a275 1

a284 1

@


1.48
log
@so let us analyse the development process here:
- complete breakage of symmetric userland crypto
- fast commit without review by other developers
- no regression test run (markus points out regression crash kernel)
Hence, we must disable userland crypto for now, until it gets repaired
by these people who don't follow process....
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.47 2002/06/11 11:14:29 beck Exp $	*/
d280 6
a285 4
		if (crie.cri_key)
			FREE(crie.cri_key, M_XDATA);
		if (cria.cri_key)
			FREE(cria.cri_key, M_XDATA);
@


1.47
log
@kernel changes to make asymmetric crypto work in userland
- modify getfeat to return something more useful to us on devices
  (like lofn and everything else until jason fixes it) that can't
  do rsa stuff, etc and can only do mod_exp..
- error handling fixes so we correctly fail to software when we can't
  deal with a particular key size
- add sysctl kern.userasymcrypto to turn on/off userland asymmetric crypto
  via /dev/crypto - 1 == on, 0 == off, default is off
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.46 2002/06/10 21:09:27 angelos Exp $	*/
d125 1
a125 1
int	usercrypto = 1;		/* userland may do crypto requests */
@


1.46
log
@You should always free the keys, not just on error --- the crypto
framework doesn't hold on to these.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.45 2002/06/07 08:09:04 nordin Exp $	*/
d126 1
d304 1
a304 1
	case CIOCSYMFEAT:
d428 5
d484 1
a484 1
	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM)
d486 1
d546 5
@


1.45
log
@Handle csecreate errors. deraadt@@ and beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.44 2002/05/18 17:00:33 deraadt Exp $	*/
d279 4
a282 6
		if (error) {
			if (crie.cri_key)
				FREE(crie.cri_key, M_XDATA);
			if (cria.cri_key)
				FREE(cria.cri_key, M_XDATA);
		}
@


1.44
log
@not ready to export fcrypt to userland yet; spotted by lebel
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.42 2002/05/08 22:04:38 jason Exp $	*/
d263 15
a283 1
			return (error);
a285 4
		cse = csecreate(fcr, sid, crie.cri_key, crie.cri_klen,
		    cria.cri_key, cria.cri_klen, sop->cipher, sop->mac, txform,
		    thash);
		sop->ses = cse->ses;
d746 2
@


1.43
log
@export struct fcrypt to userland
@
text
@d55 28
@


1.42
log
@Don't deref null pointer in failure case.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.41 2002/04/27 23:13:59 deraadt Exp $	*/
a53 28

struct csession {
	TAILQ_ENTRY(csession) next;
	u_int64_t	sid;
	u_int32_t	ses;

	u_int32_t	cipher;
	struct enc_xform *txform;
	u_int32_t	mac;
	struct auth_hash *thash;

	caddr_t		key;
	int		keylen;
	u_char		tmp_iv[EALG_MAX_BLOCK_LEN];

	caddr_t		mackey;
	int		mackeylen;
	u_char		tmp_mac[CRYPTO_MAX_MAC_LEN];

	struct iovec	iovec[IOV_MAX];
	struct uio	uio;
	int		error;
};

struct fcrypt {
	TAILQ_HEAD(csessionlist, csession) csessions;
	int		sesn;
};
@


1.41
log
@32 bit constraint is wrong, we think
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.40 2002/04/26 04:31:14 deraadt Exp $	*/
d479 1
a479 1
		goto fail;
d483 1
a483 1
		goto fail;
d487 1
a487 1
		goto fail;
d491 1
a491 1
		goto fail;
d495 1
a495 1
		goto fail;
d497 1
a497 1
		goto fail;
a543 1
	kop->crk_status = krp->krp_status;
d545 1
@


1.40
log
@disable cryptodevallowsoft again; constrain key bit sizes to % 32cryptodev.c
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.39 2002/04/24 23:24:32 deraadt Exp $	*/
d511 1
a511 1
	for (i = 0; i < CRK_MAXPARAM; i++) {
a512 5
		if (krp->krp_param[i].crp_nbits % 32) {
			error = EINVAL;
			goto fail;
		}
	}
@


1.39
log
@kernel API does not need the userland addresses, make them go away
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.38 2002/04/23 22:20:47 deraadt Exp $	*/
d126 1
a126 1
int	cryptodevallowsoft = 1;	/* only use hardware crypto */
d511 1
a511 1
	for (i = 0; i < CRK_MAXPARAM; i++)
d513 5
@


1.38
log
@initial hack at a CIOCSYMFEAT ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.37 2002/04/23 19:13:04 deraadt Exp $	*/
a466 1
	int in, out;
d468 1
a468 1
	int size, i;
d473 3
a475 14
	krp = (struct cryptkop *)malloc(sizeof *krp, M_XDATA, M_WAITOK);
	if (!krp)
		return (ENOMEM);

	bzero(krp, sizeof *krp);
	krp->krp_op = kop->crk_op;
	krp->krp_status = kop->crk_status;
	krp->krp_iparams = kop->crk_iparams;
	krp->krp_oparams = kop->crk_oparams;
	memcpy(krp->krp_param, kop->crk_param, sizeof(kop->crk_param));

	in = krp->krp_iparams;
	out = krp->krp_oparams;
	switch (krp->krp_op) {
d500 11
d512 1
a512 2
		krp->krp_kvp[i].crp_nbits = krp->krp_param[i].crp_nbits;

d514 1
a514 1
		size = (krp->krp_kvp[i].crp_nbits + 7) / 8;
d517 1
a517 1
		MALLOC(krp->krp_kvp[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
d520 1
a520 1
		error = copyin(krp->krp_param[i].crp_p, krp->krp_kvp[i].crp_p, size);
a524 3
	krp->krp_status = 0;
	krp->krp_callback = (int (*) (struct cryptkop *)) cryptodevkey_cb;

a527 1

d535 1
a535 3
		int err;

		size = (krp->krp_kvp[i].crp_nbits + 7) / 8;
d538 2
a539 3
		err = copyout(krp->krp_kvp[i].crp_p, krp->krp_param[i].crp_p, size);
		if (err) {
			error = err;
a540 1
		}
d547 2
a548 2
			if (krp->krp_kvp[i].crp_p)
				FREE(krp->krp_kvp[i].crp_p, M_XDATA);
@


1.37
log
@driver queueing & callback code for keying operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.36 2002/04/08 17:49:42 jason Exp $	*/
d294 3
@


1.36
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.35 2002/04/03 05:12:41 deraadt Exp $	*/
d123 1
d125 2
a126 2
int	usercrypto = 0;		/* userland may do crypto requests */
int	cryptodevallowsoft = 0;	/* only use hardware crypto */
d452 1
a452 1
cryptodev_dokey(struct crypt_kop *kop, struct crparam kvp[])
d454 4
a457 1
	return (EIO);
d463 2
a464 2
	struct crparam kvp[CRK_MAXPARAM];
	int in = kop->crk_iparams, out = kop->crk_oparams;
a469 1
	bzero(&kvp, sizeof(kvp));
d471 14
a484 1
	switch (kop->crk_op) {
d510 1
a510 1
		kvp[i].crp_nbits = kop->crk_param[i].crp_nbits;
d512 2
a513 2
	for (i = 0; i < kop->crk_iparams + kop->crk_oparams; i++) {
		size = (kvp[i].crp_nbits + 7) / 8;
d516 2
a517 2
		MALLOC(kvp[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
		if (i >= kop->crk_iparams)
d519 1
a519 1
		error = copyin(kop->crk_param[i].crp_p, kvp[i].crp_p, size);
d524 2
a525 2
	kop->crk_status = 0;
	error = cryptodev_dokey(kop, kvp);
d527 11
a537 1
	for (i = kop->crk_iparams; i < kop->crk_iparams + kop->crk_oparams; i++) {
d540 1
a540 1
		size = (kvp[i].crp_nbits + 7) / 8;
d543 1
a543 1
		err = copyout(kvp[i].crp_p, kop->crk_param[i].crp_p, size);
d551 7
a557 3
	for (i = 0; i < CRK_MAXPARAM; i++) {
		if (kvp[i].crp_p)
			FREE(kvp[i].crp_p, M_XDATA);
@


1.35
log
@disable userland crypto for 3.1
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.34 2002/03/14 01:26:51 millert Exp $	*/
d28 5
@


1.34
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.33 2002/03/05 15:59:41 markus Exp $	*/
d119 1
a119 1
int	usercrypto = 1;		/* userland may do crypto requests */
@


1.33
log
@export MD5/SHA1 via /dev/crypto; ok provos@@, beck@@
tested with cryptosoft and kern.cryptodevallowsoft=1
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.32 2002/03/04 21:25:02 deraadt Exp $	*/
d78 1
a78 1
void	cryptoattach __P((int));
d80 6
a85 6
int	cryptoopen __P((dev_t, int, int, struct proc *));
int	cryptoclose __P((dev_t, int, int, struct proc *));
int	cryptoread __P((dev_t, struct uio *, int));
int	cryptowrite __P((dev_t, struct uio *, int));
int	cryptoioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int	cryptoselect __P((dev_t, int, struct proc *));
@


1.32
log
@parts that copy in PK parameters
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.31 2002/03/01 02:52:51 provos Exp $	*/
d245 7
a251 5
			MALLOC(cria.cri_key, u_int8_t *,
			    cria.cri_klen / 8, M_XDATA, M_WAITOK);
			if ((error = copyin(sop->mackey, cria.cri_key,
			    cria.cri_klen / 8)))
				goto bail;
d415 2
a416 1
	if ((error = copyout(cse->uio.uio_iov[0].iov_base, cop->dst, cop->len)))
d420 1
a420 1
	    (error = copyout(crp->crp_mac, cop->mac, cse->thash->hashsize)))
@


1.31
log
@sysctl for cryptodevallowsoft - /dev/crypto will allow the software engine
to be used if there are no hardware cards.  mostly for debugging and
regression.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.30 2002/02/23 08:07:59 deraadt Exp $	*/
d113 5
a117 1
int	crypto_op(struct csession *, struct crypt_op *, struct proc *);
d282 4
a285 1
		error = crypto_op(cse, cop, p);
a292 3
int	cryptodev_cb(void *);


d294 1
a294 1
crypto_op(struct csession *cse, struct crypt_op *cop, struct proc *p)
d442 82
d687 1
a687 1
	
@


1.30
log
@sysctl kern.usercrypto
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.29 2002/02/08 13:53:28 art Exp $	*/
d116 1
d248 2
a249 1
		error = crypto_newsession(&sid, (txform ? &crie : &cria), 1);
@


1.29
log
@- Rename FILE_{,UN}USE to FREF and FRELE. USE is a bad verb and we don't have
  the same semantics as NetBSD anyway, so it's good to avoid name collissions.
- Always fdremove before freeing the file, not the other way around.
- falloc FREFs the file.
- have FILE_SET_MATURE FRELE the file (It feels like a good ortogonality to
  falloc FREFing the file).
- Use closef as much as possible instead of ffree in error paths of
  falloc:ing functions. closef is much more careful with the fd and can
  deal with the fd being forcibly closed by dup2. Also try to avoid
  manually calling *fo_close when closef can do that for us (this makes
  some error paths mroe complicated (sys_socketpair and sys_pipe), but
  others become simpler (sys_open)).
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.28 2001/11/13 17:45:46 deraadt Exp $	*/
d115 2
d495 2
@


1.28
log
@garbage in my last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.27 2001/11/09 03:11:38 deraadt Exp $	*/
a543 1

@


1.27
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.26 2001/11/08 23:12:38 deraadt Exp $	*/
d224 1
a224 2
			    crie.cri_klen / 8))) {
				error = EINVAL;
a225 1
			}
d241 1
a241 2
			    cria.cri_klen / 8))) {
				error = EINVAL;
a242 1
			}
@


1.26
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.25 2001/10/26 12:03:27 art Exp $	*/
d224 2
a225 1
			    crie.cri_klen / 8)))
d227 1
d243 2
a244 1
			    cria.cri_klen / 8)))
d246 1
@


1.25
log
@ - every new fd created by falloc() is marked as larval and should not be used
   any anyone. Every caller of falloc matures the fd when it's usable.
 - Since every lookup in the fd table must now check this flag and all of
   them do the same thing, move all the necessary checks into a function -
   fd_getfile.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.24 2001/09/03 10:13:44 deraadt Exp $	*/
d215 2
a216 2
			if (sop->keylen > txform->maxkey
			    || sop->keylen < txform->minkey) {
@


1.24
log
@do not screw up the reference counts
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.23 2001/08/28 12:20:43 ben Exp $	*/
d554 1
@


1.23
log
@Getting closer to working userland MAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.22 2001/08/24 17:19:18 deraadt Exp $	*/
d111 1
a111 1
void	csefree(struct csession *);
a265 1
		error = crypto_freesession(cse->sid);
d267 1
a267 1
		csefree(cse);
d474 1
a474 1
		csefree(cse);
d626 1
a626 1
void
d629 3
a635 1
	(void) crypto_freesession(cse->sid);
d637 1
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.21 2001/08/17 17:37:12 ben Exp $	*/
d66 1
a66 1
	u_char		tmp_mac[16];		/* XXX MAX_MAC_SIZE */
d108 3
a110 2
struct	csession *csecreate(struct fcrypt *, u_int64_t, caddr_t, u_int64_t, caddr_t, u_int32_t,
	    u_int32_t, struct enc_xform *, struct auth_hash *);
d199 6
d257 2
a258 1
		    cria.cri_key, sop->cipher, sop->mac, txform, thash);
d380 1
a380 1
	} else {
d391 1
a391 3
		if ((error = copyin(cop->mac, cse->tmp_mac, 16)))    /* XXX */
			goto bail;
		crp->crp_mac_trunc_len = 16;	/* XXX */
d410 1
a410 1
	    (error = copyout(crp->crp_mac, cop->mac, crp->crp_mac_trunc_len)))
d606 3
a608 3
csecreate(struct fcrypt *fcr, u_int64_t sid, caddr_t key, u_int64_t keylen, caddr_t mackey,
    u_int32_t cipher, u_int32_t mac, struct enc_xform *txform,
    struct auth_hash *thash)
d617 1
@


1.21
log
@Add RC4 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.20 2001/06/24 17:06:39 angelos Exp $	*/
d370 1
a370 1
	} else if(cse->cipher == CRYPTO_ARC4) { /* XXX use flag? */
@


1.20
log
@Remove whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.19 2001/06/23 22:57:55 angelos Exp $	*/
d108 1
a108 1
struct	csession *csecreate(struct fcrypt *, u_int64_t, caddr_t, caddr_t, u_int32_t,
d179 3
d208 2
a209 1
			if (sop->keylen != txform->maxkey) {
d249 2
a250 2
		cse = csecreate(fcr, sid, crie.cri_key, cria.cri_key,
		    sop->cipher, sop->mac, txform, thash);
d361 4
d370 2
d600 1
a600 1
csecreate(struct fcrypt *fcr, u_int64_t sid, caddr_t key, caddr_t mackey,
d609 1
@


1.19
log
@Adjust length.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.18 2001/06/23 22:37:19 angelos Exp $	*/
a417 2


@


1.18
log
@Use C-style comments...
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.17 2001/06/23 22:36:10 angelos Exp $	*/
d365 1
@


1.17
log
@Initialize crd_skip
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.16 2001/06/23 21:56:58 angelos Exp $	*/
d372 1
a372 1
		if ((error = copyin(cop->mac, cse->tmp_mac, 16)))	/* XXX */
d380 1
a380 1
		/// XXX can this happen?  if so, how do we recover?
@


1.16
log
@Remove unneeded crp_iv field, set the right flags for IV handling in
the crypto device.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.15 2001/06/23 18:30:36 deraadt Exp $	*/
d361 1
@


1.15
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.14 2001/06/23 01:29:40 pvalchev Exp $	*/
a336 1
		crde->crd_skip = 0;
d338 1
a338 1
		crde->crd_inject = 0;	/* ??? */
d360 4
a363 1
		crde->crd_flags |= CRD_F_IV_EXPLICIT;
@


1.14
log
@hifn now supports up to 256K
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.13 2001/06/18 10:55:01 deraadt Exp $	*/
d47 1
a47 1
#include <crypto/crypto.h>
a48 1
#include <crypto/cryptodev.h>
@


1.13
log
@keep track of the txform/thash, and make sure that non-blocksize
requests do not get passed to device drivers, because some like the
ubsec(4) will do really nasty things like DMA to completely random
locations in memory when you do so
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.12 2001/06/16 10:46:03 deraadt Exp $	*/
d282 1
a282 1
	if (cop->len > 64*1024-4)		/* XXX -4 because of hifn bug */
@


1.12
log
@range check the enc & mac key lengths
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.11 2001/06/15 09:14:46 deraadt Exp $	*/
d57 3
a59 1
	u_int32_t	blocksize;
a64 1
	u_int32_t	mac;
d110 1
a110 1
	    u_int32_t, u_int32_t);
d247 1
a247 1
		    sop->cipher, sop->mac, txform->blocksize);
d282 1
a282 1
	if (cop->len > 64*1024-4)
d285 3
d301 1
a301 1
	crp = crypto_getreq((cse->cipher > 0) + (cse->mac > 0));
d307 1
a307 1
	if (cse->mac) {
d309 1
a309 1
		if (cse->cipher)
d312 1
a312 1
		if (cse->cipher)
d359 1
a359 1
		if ((error = copyin(cop->iv, cse->tmp_iv, cse->blocksize)))
d361 1
a361 1
		bcopy(cse->tmp_iv, crde->crd_iv, cse->blocksize);
d590 2
a591 1
    u_int32_t cipher, u_int32_t mac, u_int32_t blocksize)
d602 2
a603 1
	cse->blocksize = blocksize;
@


1.11
log
@save txform->blocksize so we know what the IV size is
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.10 2001/06/15 00:04:53 deraadt Exp $	*/
d204 5
a208 1
			crie.cri_klen = sop->keylen * 8;	/* XXX range check */
d221 5
a225 1
			cria.cri_klen = sop->mackeylen * 8;	/* XXX range check */
@


1.10
log
@constrain to less than 64K until a hifn driver bug is fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.9 2001/06/11 22:44:03 deraadt Exp $	*/
d57 2
d80 6
a85 6
int     cryptoopen __P((dev_t, int, int, struct proc *));
int     cryptoclose __P((dev_t, int, int, struct proc *));
int     cryptoread __P((dev_t, struct uio *, int));
int     cryptowrite __P((dev_t, struct uio *, int));
int     cryptoioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int     cryptoselect __P((dev_t, int, struct proc *));
d109 1
a109 1
	    u_int32_t);
d238 1
a238 1
		    sop->cipher, sop->mac);
d347 1
a347 1
		if ((error = copyin(cop->iv, cse->tmp_iv, 8)))	/* XXX sop->iv_size? */
d349 1
a349 1
		bcopy(cse->tmp_iv, crde->crd_iv, 8);
d460 3
a462 3
	dev_t   dev;
	int     flag;
	int     mode;
d470 3
a472 3
	dev_t   dev;
	int     flag;
	int     mode;
d480 1
a480 1
	dev_t   dev;
d482 1
a482 1
	int     ioflag;
d489 1
a489 1
	dev_t   dev;
d491 1
a491 1
	int     ioflag;
d498 4
a501 4
	dev_t   dev;
	u_long  cmd;
	caddr_t data;
	int     flag;
d536 2
a537 2
	dev_t   dev;
	int     rw;
d578 1
a578 1
    u_int32_t cipher, u_int32_t mac)
d589 1
@


1.9
log
@explicit IV & other fixes; pointed out as umich people tried to use this...
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.8 2001/05/16 12:54:34 ho Exp $	*/
d271 1
a271 1
	if (cop->len > 64*1024)
@


1.8
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.7 2001/05/15 09:00:23 deraadt Exp $	*/
d59 1
a59 1
	u_char		tmp_iv[16];		/* XXX MAX_IV_SIZE */
d106 2
a107 1
struct	csession *csecreate(struct fcrypt *, u_int64_t, caddr_t, caddr_t);
d235 2
a236 1
		cse = csecreate(fcr, sid, crie.cri_key, cria.cri_key);
d249 1
d288 2
a289 1
	if (crp == NULL)
d291 1
d320 4
d347 2
d368 2
a369 1
	if (cse->error)
d371 1
d511 1
d575 2
a576 1
csecreate(struct fcrypt *fcr, u_int64_t sid, caddr_t key, caddr_t mackey)
d585 2
@


1.7
log
@DTYPE_CRYPTO
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.6 2001/05/14 15:37:16 deraadt Exp $	*/
a280 2
	if (cse->uio.uio_iov[0].iov_base == NULL)
		return (ENOMEM);
@


1.6
log
@dummy cryptof_stat
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.5 2001/05/14 15:19:37 deraadt Exp $	*/
d508 1
a508 1
		f->f_type = DTYPE_PIPE;
@


1.5
log
@art added fo_stat everywhere, except here, then blamed me...
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.4 2001/05/14 02:45:19 deraadt Exp $	*/
d90 1
d99 1
a99 1
    NULL,
d410 10
@


1.4
log
@use real uio
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.3 2001/05/13 16:52:33 jason Exp $	*/
d93 8
a100 2
    cryptof_read, cryptof_write, cryptof_ioctl,
    cryptof_select, cryptof_kqfilter, cryptof_close };
@


1.3
log
@copyrights and $OpenBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d66 2
a67 1
	struct criov	criov;
d102 1
a102 1
int	crypto_op(struct csession *, struct crypt_op *);
d243 1
a243 1
		error = crypto_op(cse, cop);
d255 1
a255 1
crypto_op(struct csession *cse, struct crypt_op *cop)
d259 1
a259 1
	int error;
d264 11
a274 5
	bzero(&cse->criov, sizeof(cse->criov));
	cse->criov.niov = 1;
	cse->criov.iov[0].iov_len = cop->len;
	cse->criov.iov[0].iov_base = malloc(cop->len, M_XDATA, M_WAITOK);
	if (cse->criov.iov[0].iov_base == NULL)
d276 2
d296 1
a296 1
	if ((error = copyin(cop->src, cse->criov.iov[0].iov_base, cop->len)))
d321 1
a321 1
	crp->crp_buf = (caddr_t)&cse->criov;
d355 1
a355 1
	if ((error = copyout(cse->criov.iov[0].iov_base, cop->dst, cop->len)))
d365 2
a366 2
	if (cse->criov.iov[0].iov_base)
		free(cse->criov.iov[0].iov_base, M_XDATA);
@


1.2
log
@bail out better from tsleep failure
@
text
@d1 29
@


1.1
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d311 1
a311 1
		return (error);
@


1.20.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.20 2001/06/24 17:06:39 angelos Exp $	*/
d66 1
a66 1
	u_char		tmp_mac[CRYPTO_MAX_MAC_LEN];
d108 3
a110 4
struct	csession *csecreate(struct fcrypt *, u_int64_t, caddr_t, u_int64_t,
    caddr_t, u_int64_t, u_int32_t, u_int32_t, struct enc_xform *,
    struct auth_hash *);
int	csefree(struct csession *);
a178 3
		case CRYPTO_ARC4:
			txform = &enc_xform_arc4;
			break;
a194 6
		case CRYPTO_MD5:
			thash = &auth_hash_md5;
			break;
		case CRYPTO_SHA1:
			thash = &auth_hash_sha1;
			break;
d205 1
a205 2
			if (sop->keylen > txform->maxkey
			    || sop->keylen < txform->minkey) {
d245 2
a246 3
		cse = csecreate(fcr, sid, crie.cri_key, crie.cri_klen,
		    cria.cri_key, cria.cri_klen, sop->cipher, sop->mac, txform,
		    thash);
d254 1
d256 1
a256 1
		error = csefree(cse);
a356 4
		if (cse->cipher == CRYPTO_ARC4) { /* XXX use flag? */
			error = EINVAL;
			goto bail;
		}
d362 1
a362 3
	} else if (cse->cipher == CRYPTO_ARC4) { /* XXX use flag? */
		crde->crd_skip = 0;
	} else if (crde) {
d373 3
a375 1
		crp->crp_mac=cse->tmp_mac;
d394 1
a394 1
	    (error = copyout(crp->crp_mac, cop->mac, cse->thash->hashsize)))
d459 1
a459 1
		(void)csefree(cse);
a538 1
		FILE_SET_MATURE(f);
d590 3
a592 3
csecreate(struct fcrypt *fcr, u_int64_t sid, caddr_t key, u_int64_t keylen,
    caddr_t mackey, u_int64_t mackeylen, u_int32_t cipher, u_int32_t mac,
    struct enc_xform *txform, struct auth_hash *thash)
a598 1
	cse->keylen = keylen/8;
a599 1
	cse->mackeylen = mackeylen/8;
d609 1
a609 1
int
a611 3
	int error;

	error = crypto_freesession(cse->sid);
d616 1
a617 1
	return (error);
@


1.20.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d215 2
a216 2
			if (sop->keylen > txform->maxkey ||
			    sop->keylen < txform->minkey) {
d224 1
a224 2
			    crie.cri_klen / 8))) {
				error = EINVAL;
a225 1
			}
d241 1
a241 2
			    cria.cri_klen / 8))) {
				error = EINVAL;
a242 1
			}
@


1.20.2.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.20.2.2 2001/11/13 21:05:48 niklas Exp $	*/
d224 2
a225 1
			    crie.cri_klen / 8)))
d227 1
d243 2
a244 1
			    cria.cri_klen / 8)))
d246 1
@


1.20.2.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 8
int	cryptodev_op(struct csession *, struct crypt_op *, struct proc *);
int	cryptodev_key(struct crypt_kop *);
int	cryptodev_dokey(struct crypt_kop *kop, struct crparam kvp[]);

int	cryptodev_cb(void *);

int	usercrypto = 1;		/* userland may do crypto requests */
int	cryptodevallowsoft = 0;	/* only use hardware crypto */
d238 5
a242 7
			if (cria.cri_klen) {
				MALLOC(cria.cri_key, u_int8_t *,
				    cria.cri_klen / 8, M_XDATA, M_WAITOK);
				if ((error = copyin(sop->mackey, cria.cri_key,
				    cria.cri_klen / 8)))
					goto bail;
			}
d245 1
a245 2
		error = crypto_newsession(&sid, (txform ? &crie : &cria),
		    !cryptodevallowsoft);
d274 1
a274 4
		error = cryptodev_op(cse, cop, p);
		break;
	case CIOCKEY:
		error = cryptodev_key((struct crypt_kop *)data);
d282 3
d286 1
a286 1
cryptodev_op(struct csession *cse, struct crypt_op *cop, struct proc *p)
d405 1
a405 2
	if (cop->dst &&
	    (error = copyout(cse->uio.uio_iov[0].iov_base, cop->dst, cop->len)))
d409 1
a409 1
	    (error = copyout(crp->crp_mac, cop->mac, cse->thash->authsize)))
a433 82
int
cryptodev_dokey(struct crypt_kop *kop, struct crparam kvp[])
{
	return (EIO);
}

int
cryptodev_key(struct crypt_kop *kop)
{
	struct crparam kvp[CRK_MAXPARAM];
	int in = kop->crk_iparams, out = kop->crk_oparams;
	int error = EINVAL;
	int size, i;

	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM)
		return (EFBIG);
	bzero(&kvp, sizeof(kvp));

	switch (kop->crk_op) {
	case CRK_MOD_EXP:
		if (in == 3 && out == 1)
			break;
		goto fail;
	case CRK_MOD_EXP_CRT:
		if (in == 6 && out == 1)
			break;
		goto fail;
	case CRK_DSA_SIGN:
		if (in == 5 && out == 2)
			break;
		goto fail;
	case CRK_DSA_VERIFY:
		if (in == 7 && out == 0)
			break;
		goto fail;
	case CRK_DH_COMPUTE_KEY:
		if (in == 3 && out == 1)
			break;
		goto fail;
	default:
		goto fail;
	}

	for (i = 0; i < CRK_MAXPARAM; i++)
		kvp[i].crp_nbits = kop->crk_param[i].crp_nbits;

	for (i = 0; i < kop->crk_iparams + kop->crk_oparams; i++) {
		size = (kvp[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		MALLOC(kvp[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
		if (i >= kop->crk_iparams)
			continue;
		error = copyin(kop->crk_param[i].crp_p, kvp[i].crp_p, size);
		if (error)
			goto fail;
	}

	kop->crk_status = 0;
	error = cryptodev_dokey(kop, kvp);

	for (i = kop->crk_iparams; i < kop->crk_iparams + kop->crk_oparams; i++) {
		int err;

		size = (kvp[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		err = copyout(kvp[i].crp_p, kop->crk_param[i].crp_p, size);
		if (err) {
			error = err;
			goto fail;
		}
	}

fail:
	for (i = 0; i < CRK_MAXPARAM; i++) {
		if (kvp[i].crp_p)
			FREE(kvp[i].crp_p, M_XDATA);
	}
	return (error);
}

a492 2
	if (usercrypto == 0)
		return (ENXIO);
d544 1
d596 1
a596 1

@


1.20.2.5
log
@Merge in -current from about a week ago
@
text
@d78 1
a78 1
void	cryptoattach(int);
d80 6
a85 6
int	cryptoopen(dev_t, int, int, struct proc *);
int	cryptoclose(dev_t, int, int, struct proc *);
int	cryptoread(dev_t, struct uio *, int);
int	cryptowrite(dev_t, struct uio *, int);
int	cryptoioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cryptoselect(dev_t, int, struct proc *);
@


1.20.2.6
log
@Sync the SMP branch with 3.3
@
text
@a27 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d80 7
a117 1
int	cryptodevkey_cb(void *);
a119 1
int	userasymcrypto = 1;	/* userland may do asymmetric crypto reqs */
d124 5
a128 1
cryptof_read(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
d135 5
a139 1
cryptof_write(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
d146 5
a150 1
cryptof_ioctl(struct file *fp, u_long cmd, caddr_t data, struct proc *p)
a189 3
		case CRYPTO_NULL:
			txform = &enc_xform_null;
			break;
a256 14
		if (error)
			goto bail;

		cse = csecreate(fcr, sid, crie.cri_key, crie.cri_klen,
		    cria.cri_key, cria.cri_klen, sop->cipher, sop->mac, txform,
		    thash);

		if (cse == NULL) {
			crypto_freesession(sid);
			error = EINVAL;
			goto bail;
		}
		sop->ses = cse->ses;

d263 1
d265 5
a288 3
	case CIOCASYMFEAT:
		error = crypto_getfeat((int *)data);
		break;
d305 1
a305 1
	if (cse->txform && (cop->len % cse->txform->blocksize) != 0) {
a306 1
	}
a409 5
	if (crp->crp_etype != 0) {
		error = crp->crp_etype;
		goto bail;
	}

d446 1
a446 1
cryptodevkey_cb(void *op)
d448 1
a448 4
	struct cryptkop *krp = (struct cryptkop *) op;

	wakeup(krp);
	return (0);
d454 2
a455 1
	struct cryptkop *krp = NULL;
d457 1
a457 1
	int in, out, size, i;
d459 1
a459 1
	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM) {
d461 1
a461 1
	}
a462 2
	in = kop->crk_iparams;
	out = kop->crk_oparams;
d467 1
a467 1
		return (EINVAL);
d471 1
a471 1
		return (EINVAL);
d475 1
a475 1
		return (EINVAL);
d479 1
a479 1
		return (EINVAL);
d483 1
a483 1
		return (EINVAL);
d485 1
a485 1
		return (EINVAL);
d488 2
a489 10
	krp = (struct cryptkop *)malloc(sizeof *krp, M_XDATA, M_WAITOK);
	if (!krp)
		return (ENOMEM);
	bzero(krp, sizeof *krp);
	krp->krp_op = kop->crk_op;
	krp->krp_status = kop->crk_status;
	krp->krp_iparams = kop->crk_iparams;
	krp->krp_oparams = kop->crk_oparams;
	krp->krp_status = 0;
	krp->krp_callback = (int (*) (struct cryptkop *)) cryptodevkey_cb;
d491 2
a492 4
	for (i = 0; i < CRK_MAXPARAM; i++)
		krp->krp_param[i].crp_nbits = kop->crk_param[i].crp_nbits;
	for (i = 0; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
d495 2
a496 2
		MALLOC(krp->krp_param[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
		if (i >= krp->krp_iparams)
d498 1
a498 1
		error = copyin(kop->crk_param[i].crp_p, krp->krp_param[i].crp_p, size);
d503 5
a507 13
	error = crypto_kdispatch(krp);
	if (error)
		goto fail;
	error = tsleep(krp, PSOCK, "crydev", 0);
	if (error) {
		/* XXX can this happen?  if so, how do we recover? */
		goto fail;
	}
	
	if (krp->krp_status != 0) {
		error = krp->krp_status;
		goto fail;
	}
d509 1
a509 2
	for (i = krp->krp_iparams; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
d512 3
a514 2
		error = copyout(krp->krp_param[i].crp_p, kop->crk_param[i].crp_p, size);
		if (error)
d516 1
d520 3
a522 7
	if (krp) {
		kop->crk_status = krp->krp_status;
		for (i = 0; i < CRK_MAXPARAM; i++) {
			if (krp->krp_param[i].crp_p)
				FREE(krp->krp_param[i].crp_p, M_XDATA);
		}
		free(krp, M_XDATA);
d529 4
a532 1
cryptof_select(struct file *fp, int which, struct proc *p)
d539 3
a541 1
cryptof_kqfilter(struct file *fp, struct knote *kn)
d548 4
a551 1
cryptof_stat(struct file *fp, struct stat *sb, struct proc *p)
d558 3
a560 1
cryptof_close(struct file *fp, struct proc *p)
d580 5
a584 1
cryptoopen(dev_t dev, int flag, int mode, struct proc *p)
d592 5
a596 1
cryptoclose(dev_t dev, int flag, int mode, struct proc *p)
d602 4
a605 1
cryptoread(dev_t dev, struct uio *uio, int ioflag)
d611 4
a614 1
cryptowrite(dev_t dev, struct uio *uio, int ioflag)
d620 6
a625 1
cryptoioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d658 4
a661 1
cryptoselect(dev_t dev, int rw, struct proc *p)
a707 2
	if (cse == NULL)
		return NULL;
@


1.20.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.20.2.6 2003/03/27 23:53:48 niklas Exp $	*/
d15 2
a54 3
extern struct cryptocap *crypto_drivers;
extern int crypto_drivers_num;

d300 1
a300 1
	struct cryptop *crp= NULL;
d302 1
a302 2
	int i, s, error;
	u_int32_t hid;
d304 1
a304 1
	if (cop->len > 64*1024-4)
d370 1
a405 18
	/* try the fast path first */
	crp->crp_flags = CRYPTO_F_IOV | CRYPTO_F_NOQUEUE;
	hid = (crp->crp_sid >> 32) & 0xffffffff;
	if (hid >= crypto_drivers_num)
		goto dispatch;
	if (crypto_drivers[hid].cc_flags & CRYPTOCAP_F_SOFTWARE)
		goto dispatch;
	if (crypto_drivers[hid].cc_process == NULL)
		goto dispatch;
	error = crypto_drivers[hid].cc_process(crp);
	if (error) {
		/* clear error */
		crp->crp_etype = 0;
		goto dispatch;
	}
	goto processed;
 dispatch:
	crp->crp_flags = CRYPTO_F_IOV;
d407 1
a407 6
 processed:
	s = splnet();
	while (!(crp->crp_flags & CRYPTO_F_DONE)) {
		error = tsleep(cse, PSOCK, "crydev", 0);
	}
	splx(s);
a412 4
	if (cse->error) {
		error = cse->error;
		goto bail;
	}
d418 4
d447 1
a447 2
	if (crp->crp_etype == EAGAIN) {
		crp->crp_flags = CRYPTO_F_IOV;
a448 1
	}
@


1.20.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
int	cryptof_poll(struct file *, int, struct proc *);
d98 1
a98 1
    cryptof_poll,
d588 1
a588 1
cryptof_poll(struct file *fp, int events, struct proc *p)
a632 1
#ifdef CRYPTO
a633 3
#else
	return (ENXIO);
#endif
d688 1
a688 1
cryptopoll(dev_t dev, int events, struct proc *p)
d690 1
a690 1
	return (seltrue(dev, events, p));
@


1.20.2.9
log
@Merge with the trunk
@
text
@d41 1
a44 1
#include <crypto/md5.h>
a188 1
#if 0
a203 1
#endif
@


1.28.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.28 2001/11/13 17:45:46 deraadt Exp $	*/
a27 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d78 1
a78 1
void	cryptoattach(int);
d80 6
a85 6
int	cryptoopen(dev_t, int, int, struct proc *);
int	cryptoclose(dev_t, int, int, struct proc *);
int	cryptoread(dev_t, struct uio *, int);
int	cryptowrite(dev_t, struct uio *, int);
int	cryptoioctl(dev_t, u_long, caddr_t, int, struct proc *);
int	cryptoselect(dev_t, int, struct proc *);
d113 1
a113 9
int	cryptodev_op(struct csession *, struct crypt_op *, struct proc *);
int	cryptodev_key(struct crypt_kop *);
int	cryptodev_dokey(struct crypt_kop *kop, struct crparam kvp[]);

int	cryptodev_cb(void *);
int	cryptodevkey_cb(void *);

int	usercrypto = 1;		/* userland may do crypto requests */
int	cryptodevallowsoft = 0;	/* only use hardware crypto */
d238 5
a242 7
			if (cria.cri_klen) {
				MALLOC(cria.cri_key, u_int8_t *,
				    cria.cri_klen / 8, M_XDATA, M_WAITOK);
				if ((error = copyin(sop->mackey, cria.cri_key,
				    cria.cri_klen / 8)))
					goto bail;
			}
d245 1
a245 17
		error = crypto_newsession(&sid, (txform ? &crie : &cria),
		    !cryptodevallowsoft);

		if (error)
			goto bail;

		cse = csecreate(fcr, sid, crie.cri_key, crie.cri_klen,
		    cria.cri_key, cria.cri_klen, sop->cipher, sop->mac, txform,
		    thash);

		if (cse == NULL) {
			crypto_freesession(sid);
			error = EINVAL;
			goto bail;
		}

		sop->ses = cse->ses;
d253 1
d256 4
d274 1
a274 7
		error = cryptodev_op(cse, cop, p);
		break;
	case CIOCKEY:
		error = cryptodev_key((struct crypt_kop *)data);
		break;
	case CIOCSYMFEAT:
		error = crypto_getfeat((int *)data);
d282 3
d286 1
a286 1
cryptodev_op(struct csession *cse, struct crypt_op *cop, struct proc *p)
d405 1
a405 2
	if (cop->dst &&
	    (error = copyout(cse->uio.uio_iov[0].iov_base, cop->dst, cop->len)))
d409 1
a409 1
	    (error = copyout(crp->crp_mac, cop->mac, cse->thash->authsize)))
a433 101
int
cryptodevkey_cb(void *op)
{
	struct cryptkop *krp = (struct cryptkop *) op;

	wakeup(krp);
	return (0);
}

int
cryptodev_key(struct crypt_kop *kop)
{
	struct cryptkop *krp = NULL;
	int error = EINVAL;
	int in, out, size, i;

	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM)
		return (EFBIG);

	in = kop->crk_iparams;
	out = kop->crk_oparams;
	switch (kop->crk_op) {
	case CRK_MOD_EXP:
		if (in == 3 && out == 1)
			break;
		return (EINVAL);
	case CRK_MOD_EXP_CRT:
		if (in == 6 && out == 1)
			break;
		return (EINVAL);
	case CRK_DSA_SIGN:
		if (in == 5 && out == 2)
			break;
		return (EINVAL);
	case CRK_DSA_VERIFY:
		if (in == 7 && out == 0)
			break;
		return (EINVAL);
	case CRK_DH_COMPUTE_KEY:
		if (in == 3 && out == 1)
			break;
		return (EINVAL);
	default:
		return (EINVAL);
	}

	krp = (struct cryptkop *)malloc(sizeof *krp, M_XDATA, M_WAITOK);
	if (!krp)
		return (ENOMEM);
	bzero(krp, sizeof *krp);
	krp->krp_op = kop->crk_op;
	krp->krp_status = kop->crk_status;
	krp->krp_iparams = kop->crk_iparams;
	krp->krp_oparams = kop->crk_oparams;
	krp->krp_status = 0;
	krp->krp_callback = (int (*) (struct cryptkop *)) cryptodevkey_cb;

	for (i = 0; i < CRK_MAXPARAM; i++)
		krp->krp_param[i].crp_nbits = kop->crk_param[i].crp_nbits;
	for (i = 0; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		MALLOC(krp->krp_param[i].crp_p, caddr_t, size, M_XDATA, M_WAITOK);
		if (i >= krp->krp_iparams)
			continue;
		error = copyin(kop->crk_param[i].crp_p, krp->krp_param[i].crp_p, size);
		if (error)
			goto fail;
	}

	error = crypto_kdispatch(krp);
	if (error)
		goto fail;
	error = tsleep(krp, PSOCK, "crydev", 0);
	if (error) {
		/* XXX can this happen?  if so, how do we recover? */
		goto fail;
	}

	for (i = krp->krp_iparams; i < krp->krp_iparams + krp->krp_oparams; i++) {
		size = (krp->krp_param[i].crp_nbits + 7) / 8;
		if (size == 0)
			continue;
		error = copyout(krp->krp_param[i].crp_p, kop->crk_param[i].crp_p, size);
		if (error)
			goto fail;
	}

fail:
	if (krp) {
		kop->crk_status = krp->krp_status;
		for (i = 0; i < CRK_MAXPARAM; i++) {
			if (krp->krp_param[i].crp_p)
				FREE(krp->krp_param[i].crp_p, M_XDATA);
		}
		free(krp, M_XDATA);
	}
	return (error);
}

a492 2
	if (usercrypto == 0)
		return (ENXIO);
d544 1
d596 1
a596 1

a613 2
	if (cse == NULL)
		return NULL;
@


1.28.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.28.2.1 2002/06/11 03:28:34 art Exp $	*/
d85 7
a125 1
int	userasymcrypto = 1;	/* userland may do asymmetric crypto reqs */
d130 5
a134 1
cryptof_read(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
d141 5
a145 1
cryptof_write(struct file *fp, off_t *poff, struct uio *uio, struct ucred *cred)
d152 5
a156 1
cryptof_ioctl(struct file *fp, u_long cmd, caddr_t data, struct proc *p)
d275 1
d285 1
d305 1
a305 1
	case CIOCASYMFEAT:
a428 5
	if (crp->crp_etype != 0) {
		error = crp->crp_etype;
		goto bail;
	}

d480 1
a480 1
	if (kop->crk_iparams + kop->crk_oparams > CRK_MAXPARAM) {
a481 1
	}
a542 5
	
	if (krp->krp_status != 0) {
		error = krp->krp_status;
		goto fail;
	}
d567 4
a570 1
cryptof_select(struct file *fp, int which, struct proc *p)
d577 3
a579 1
cryptof_kqfilter(struct file *fp, struct knote *kn)
d586 4
a589 1
cryptof_stat(struct file *fp, struct stat *sb, struct proc *p)
d596 3
a598 1
cryptof_close(struct file *fp, struct proc *p)
d618 5
a622 1
cryptoopen(dev_t dev, int flag, int mode, struct proc *p)
d630 5
a634 1
cryptoclose(dev_t dev, int flag, int mode, struct proc *p)
d640 4
a643 1
cryptoread(dev_t dev, struct uio *uio, int ioflag)
d649 4
a652 1
cryptowrite(dev_t dev, struct uio *uio, int ioflag)
d658 6
a663 1
cryptoioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d696 4
a699 1
cryptoselect(dev_t dev, int rw, struct proc *p)
@


1.28.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a177 3
		case CRYPTO_NULL:
			txform = &enc_xform_null;
			break;
d304 1
a304 1
	if (cse->txform && (cop->len % cse->txform->blocksize) != 0) {
a305 1
	}
@


1.55.2.1
log
@MFC:
Fix by jason@@

move max limit back down to 65536-4

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.55 2002/11/21 19:34:25 jason Exp $	*/
d304 1
a304 1
	if (cop->len > 64*1024-4)
@


1.55.2.2
log
@MFC:
Fix by jason@@

don't allow /dev/crypto to be opened ifndef CRYPTO (the thread hasn't been
started, so all operations will hang later on anyway).

deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.c,v 1.55.2.1 2003/06/09 17:16:29 brad Exp $	*/
a606 1
#ifdef CRYPTO
a607 3
#else
	return (ENXIO);
#endif
@
