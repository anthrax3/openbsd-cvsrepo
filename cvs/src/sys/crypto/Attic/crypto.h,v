head	1.21;
access;
symbols
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	UBC_SYNC_A:1.21
	UBC_SYNC_B:1.21
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.21
date	2001.06.23.18.30.36;	author deraadt;	state dead;
branches;
next	1.20;

1.20
date	2001.06.16.22.17.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.06.18.58.53;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.01.00.16.01;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.15.02.40.35;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.11.17.04.07.05;	author angelos;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.09.22.17.30;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.20.05.38.42;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.18.08.37.11;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.18.03.08.56;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.18.03.07.11;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.06.04.49.45;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.28.05.21.45;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.23.05.01.53;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.19.00.10.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.29.07.09.40;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.25.04.40.44;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.20.21.21.49;	author deraadt;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.03.17.10.25.21;	author angelos;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.24.09.09.05;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.06.51;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.39.58;	author niklas;	state dead;
branches;
next	;


desc
@@


1.21
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@/*	$OpenBSD: crypto.h,v 1.20 2001/06/16 22:17:49 deraadt Exp $	*/

/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Athens, Greece, in
 * February 2000. Network Security Technologies Inc. (NSTI) kindly
 * supported the development of this code.
 *
 * Copyright (c) 2000 Angelos D. Keromytis
 *
 * Permission to use, copy, and modify this software without fee
 * is hereby granted, provided that this entire notice is included in
 * all source code copies of any software which is or includes a copy or
 * modification of this software. 
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#ifndef _CRYPTO_CRYPTO_H_
#define _CRYPTO_CRYPTO_H_

/* Some initial values */
#define CRYPTO_DRIVERS_INITIAL	4
#define CRYPTO_SW_SESSIONS	32

/* HMAC values */
#define HMAC_BLOCK_LEN		64
#define HMAC_IPAD_VAL		0x36
#define HMAC_OPAD_VAL		0x5C

/* Encryption algorithm block sizes */
#define DES_BLOCK_LEN		8
#define DES3_BLOCK_LEN		8
#define BLOWFISH_BLOCK_LEN	8
#define SKIPJACK_BLOCK_LEN	8
#define CAST128_BLOCK_LEN	8
#define RIJNDAEL128_BLOCK_LEN	16
#define EALG_MAX_BLOCK_LEN	16 /* Keep this updated */

/* Maximum hash algorithm result length */
#define AALG_MAX_RESULT_LEN	20 /* Keep this updated */

#define CRYPTO_DES_CBC		1
#define CRYPTO_3DES_CBC		2
#define CRYPTO_BLF_CBC		3
#define CRYPTO_CAST_CBC		4
#define CRYPTO_SKIPJACK_CBC	5
#define CRYPTO_MD5_HMAC		6
#define CRYPTO_SHA1_HMAC	7
#define CRYPTO_RIPEMD160_HMAC	8
#define CRYPTO_MD5_KPDK		9
#define CRYPTO_SHA1_KPDK	10
#define CRYPTO_RIJNDAEL128_CBC	11 /* 128 bit blocksize */
#define CRYPTO_AES_CBC		11 /* 128 bit blocksize -- the same as above */

#define CRYPTO_ALGORITHM_MAX	11 /* Keep this updated */

/* Standard initialization structure beginning */
struct cryptoini {
	int		cri_alg;	/* Algorithm to use */
	int		cri_klen;	/* Key length, in bits */
	int		cri_rnd;	/* Algorithm rounds, where relevant */
	caddr_t		cri_key;	/* key to use */
	u_int8_t	cri_iv[EALG_MAX_BLOCK_LEN];	/* IV to use */
	struct cryptoini *cri_next;
};

/* Describe boundaries of a single crypto operation */
struct cryptodesc {
	int		crd_skip;	/* How many bytes to ignore from start */
	int		crd_len;	/* How many bytes to process */
	int		crd_inject;	/* Where to inject results, if applicable */
	int		crd_flags;

#define CRD_F_ENCRYPT		0x1	/* Set when doing encryption */
#define CRD_F_IV_PRESENT	0x2	/* When encrypting, IV is already in
					   place, so don't copy. */
#define CRD_F_IV_EXPLICIT	0x4	/* IV explicitly provided */

	struct cryptoini	CRD_INI; /* Initialization/context data */
#define crd_iv		CRD_INI.cri_iv
#define crd_key		CRD_INI.cri_key
#define crd_rnd		CRD_INI.cri_rnd
#define crd_alg		CRD_INI.cri_alg
#define crd_klen	CRD_INI.cri_klen

	struct cryptodesc *crd_next;
};

/* Structure describing complete operation */
struct cryptop {
	u_int64_t	crp_sid;	/* Session ID */
	int		crp_ilen;	/* Input data total length */
	int		crp_olen;	/* Result total length (unused for now) */
	int		crp_alloctype;	/* Type of buf to allocate if needed */

	int		crp_etype;	/*
					 * Error type (zero means no error).
					 * All error codes except EAGAIN
					 * indicate possible data corruption (as in,
					 * the data have been touched). On all
					 * errors, the crp_sid may have changed
					 * (reset to a new one), so the caller
					 * should always check and use the new
					 * value on future requests.
					 */
	int		crp_flags;

#define CRYPTO_F_IMBUF	0x0001	/* Input/output are mbuf chains, otherwise contig */
#define CRYPTO_F_IOV	0x0002	/* Input/output are uio */
#define CRYPTO_F_REL	0x0004	/* Must return data in same place */

	caddr_t		crp_buf;	/* Data to be processed */
	caddr_t		crp_opaque;	/* Opaque pointer, passed along */
	struct cryptodesc *crp_desc;	/* Linked list of processing descriptors */
	int (*crp_callback)(struct cryptop *); /* Callback function */
	struct cryptop	*crp_next;
	caddr_t		crp_iv;
	caddr_t		crp_mac;
	int		crp_mac_trunc_len;
};

#define CRYPTO_BUF_CONTIG	0x1
#define CRYPTO_BUF_MBUF		0x2

#define CRYPTO_OP_DECRYPT	0x0
#define CRYPTO_OP_ENCRYPT	0x1

/* Crypto capabilities structure */
struct cryptocap {
	u_int32_t	cc_sessions;
	u_int8_t	cc_alg[CRYPTO_ALGORITHM_MAX + 1]; /* Supported */
	u_int8_t	cc_flags;
#define CRYPTOCAP_F_CLEANUP   0x1
#define CRYPTOCAP_F_SOFTWARE  0x02

	int		(*cc_newsession) (u_int32_t *, struct cryptoini *);
	int		(*cc_process) (struct cryptop *);
	int		(*cc_freesession) (u_int64_t);
};


#ifdef _KERNEL
int	crypto_newsession(u_int64_t *, struct cryptoini *, int);
int	crypto_freesession(u_int64_t);
int	crypto_dispatch(struct cryptop *);
int	crypto_register(u_int32_t, int,
	    int (*)(u_int32_t *, struct cryptoini *), int (*)(u_int64_t),
	    int (*)(struct cryptop *));
int	crypto_unregister(u_int32_t, int);
int32_t	crypto_get_driverid(void);
void	crypto_thread(void);
int	crypto_invoke(struct cryptop *);
void	crypto_done(struct cryptop *);

struct mbuf;
int	mbuf2pages __P((struct mbuf *, int *, long *, int *, int, int *));
int	iov2pages __P((struct uio *, int *, long *, int *, int, int *));
void	cuio_copydata __P((struct uio *, int, int, caddr_t));
void	cuio_copyback __P((struct uio *, int, int, caddr_t));

struct	cryptop *crypto_getreq(int);
void	crypto_freereq(struct cryptop *);
#endif /* _KERNEL */
#endif /* _CRYPTO_CRYPTO_H_ */
@


1.20
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.h,v 1.19 2001/06/06 18:58:53 angelos Exp $	*/
@


1.19
log
@Use pool(9) for some of the structures, and splimp/splx to protect
from ourselves. Should solve PR 1850.
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.h,v 1.18 2001/06/01 00:16:01 angelos Exp $	*/
d28 2
a29 2
#define CRYPTO_DRIVERS_INITIAL  4
#define CRYPTO_SW_SESSIONS      32
d33 2
a34 2
#define HMAC_IPAD_VAL           0x36
#define HMAC_OPAD_VAL           0x5C
d37 7
a43 7
#define DES_BLOCK_LEN           8
#define DES3_BLOCK_LEN          8
#define BLOWFISH_BLOCK_LEN      8
#define SKIPJACK_BLOCK_LEN      8
#define CAST128_BLOCK_LEN       8
#define RIJNDAEL128_BLOCK_LEN  16
#define EALG_MAX_BLOCK_LEN     16  /* Keep this updated */
d46 1
a46 1
#define AALG_MAX_RESULT_LEN     20 /* Keep this updated */
d48 12
a59 12
#define CRYPTO_DES_CBC          1
#define CRYPTO_3DES_CBC         2
#define CRYPTO_BLF_CBC          3
#define CRYPTO_CAST_CBC         4
#define CRYPTO_SKIPJACK_CBC     5
#define CRYPTO_MD5_HMAC         6
#define CRYPTO_SHA1_HMAC        7
#define CRYPTO_RIPEMD160_HMAC   8
#define CRYPTO_MD5_KPDK         9
#define CRYPTO_SHA1_KPDK        10
#define CRYPTO_RIJNDAEL128_CBC  11 /* 128 bit blocksize */
#define CRYPTO_AES_CBC          11 /* 128 bit blocksize -- the same as above */
d61 1
a61 1
#define CRYPTO_ALGORITHM_MAX    11 /* Keep this updated */
d64 7
a70 8
struct cryptoini
{ 
    int                cri_alg;     /* Algorithm to use */
    int                cri_klen;    /* Key length, in bits */
    int                cri_rnd;     /* Algorithm rounds, where relevant */
    caddr_t            cri_key;     /* key to use */
    u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN];      /* IV to use */
    struct cryptoini  *cri_next;
d74 17
a90 18
struct cryptodesc
{
    int                crd_skip;   /* How many bytes to ignore from start */
    int                crd_len;    /* How many bytes to process */
    int                crd_inject; /* Where to inject results, if applicable */
    int                crd_flags;

#define CRD_F_ENCRYPT             0x1 /* Set when doing encryption */
#define CRD_F_IV_PRESENT          0x2 /* When encrypting, IV is already in
				         place, so don't copy. */
#define CRD_F_IV_EXPLICIT         0x4 /* IV explicitly provided */

    struct cryptoini   CRD_INI;    /* Initialization/context data */
#define crd_iv   CRD_INI.cri_iv
#define crd_key  CRD_INI.cri_key
#define crd_rnd  CRD_INI.cri_rnd
#define crd_alg  CRD_INI.cri_alg
#define crd_klen CRD_INI.cri_klen
d92 1
a92 1
    struct cryptodesc *crd_next;
d96 30
a125 36
struct cryptop
{
    u_int64_t          crp_sid;   /* Session ID */
    int                crp_ilen;  /* Input data total length */
    int                crp_olen;  /* Result total length (unused for now) */
    int                crp_alloctype; /* Type of buf to allocate if needed */

    int                crp_etype; /* Error type (zero means no error).
				   * All error codes except EAGAIN
				   * indicate possible data corruption (as in,
				   * the data have been touched). On all
				   * errors, the crp_sid may have changed
				   * (reset to a new one), so the caller
				   * should always check and use the new
				   * value on future requests.
				   */
    int                crp_flags;

#define CRYPTO_F_IMBUF 0x0001  /* Input/output are mbuf chains, otherwise contig */
#define CRYPTO_F_IOV   0x0002  /* Input/output are uio */
#define CRYPTO_F_REL   0x0004  /* Must return data in same place */

    caddr_t            crp_buf;   /* Data to be processed */

    caddr_t            crp_opaque;/* Opaque pointer, passed along */

    struct cryptodesc *crp_desc;  /* Linked list of processing descriptors */

    int (*crp_callback) (struct cryptop *); /* Callback function */

    struct cryptop    *crp_next;

    caddr_t            crp_iv;
    caddr_t            crp_mac;
    int                crp_mac_trunc_len;

d128 2
a129 2
#define CRYPTO_BUF_CONTIG     0x1
#define CRYPTO_BUF_MBUF       0x2
d131 2
a132 2
#define CRYPTO_OP_DECRYPT     0x0
#define CRYPTO_OP_ENCRYPT     0x1
d135 4
a138 6
struct cryptocap
{
    u_int32_t         cc_sessions;

    u_int8_t          cc_alg[CRYPTO_ALGORITHM_MAX + 1]; /* Supported */
    u_int8_t          cc_flags;
d142 3
a144 3
    int             (*cc_newsession) (u_int32_t *, struct cryptoini *);
    int             (*cc_process) (struct cryptop *);
    int             (*cc_freesession) (u_int64_t);
a147 7
#if 0
struct criov {
       int niov;
       struct iovec iov[IOV_MAX];
};
#endif

d149 11
a159 11
extern int crypto_newsession(u_int64_t *, struct cryptoini *, int);
extern int crypto_freesession(u_int64_t);
extern int crypto_dispatch(struct cryptop *);
extern int crypto_register(u_int32_t, int,
    int (*)(u_int32_t *, struct cryptoini *), int (*)(u_int64_t),
    int (*)(struct cryptop *));
extern int crypto_unregister(u_int32_t, int);
extern int32_t crypto_get_driverid(void);
extern void crypto_thread(void);
extern int crypto_invoke(struct cryptop *);
extern void crypto_done(struct cryptop *);
d167 2
a168 2
extern struct cryptop *crypto_getreq(int);
extern void crypto_freereq(struct cryptop *);
@


1.18
log
@What was cri_insert used for anyway ?
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.h,v 1.17 2001/05/15 02:40:35 deraadt Exp $	*/
a29 4

#ifndef CRYPTO_MAX_CACHED
#define CRYPTO_MAX_CACHED	128
#endif
@


1.17
log
@fix $OpenBSD$ header
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a74 1
    int		       cri_insert;  /* XXX Number of bytes MAC "uses" */
@


1.16
log
@use real uio
@
text
@d1 2
@


1.15
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d135 1
a135 1
    int                        crp_mac_trunc_len;
d161 1
d166 1
d183 3
a185 3
int	iov2pages __P((struct criov *, int *, long *, int *, int, int *));
void	criov_copydata __P((struct criov *, int, int, caddr_t));
void	criov_copyback __P((struct criov *, int, int, caddr_t));
@


1.14
log
@*HMAC96->*HMAC
@
text
@d73 1
d119 3
a121 1
#define CRYPTO_F_IMBUF 0x0001    /* Input is an mbuf chain, otherwise contig */
d132 5
d153 1
d161 5
d167 1
a167 1
extern int crypto_newsession(u_int64_t *, struct cryptoini *);
d180 4
a183 1
int	mbuf2pages(struct mbuf *, int *, long *, int *, int, int *);
@


1.13
log
@AES alias for Rijndael, also adjust the name.
@
text
@d55 3
a57 3
#define CRYPTO_MD5_HMAC96       6
#define CRYPTO_SHA1_HMAC96      7
#define CRYPTO_RIPEMD160_HMAC96 8
@


1.12
log
@Add crypto_done() prototype.
@
text
@d61 1
@


1.11
log
@Add Rijndael (128-bit blocksize) in the software crypto driver.

Hacking at OpenBSD Crypto 2000 :-)
@
text
@d162 1
@


1.10
log
@Move prototype to include file.
@
text
@d44 2
a45 1
#define EALG_MAX_BLOCK_LEN      8  /* Keep this updated */
d60 1
d62 1
a62 1
#define CRYPTO_ALGORITHM_MAX    10 /* Keep this updated */
@


1.9
log
@Crypto kernel thread interface; requests are enqueued and processed by
a kernel thread. This allows a much cleaner interface with respect to
spl levels.
@
text
@d158 2
a165 1
extern void crypto_thread(void);
@


1.8
log
@Replace all the opaque pointers with just one.
@
text
@d164 1
@


1.7
log
@avoid using void * when we are talking about pointers
@
text
@d119 1
a119 4
    caddr_t            crp_opaque1;/* Opaque pointer, passed along */
    caddr_t            crp_opaque2;/* Opaque pointer, passed along */
    caddr_t            crp_opaque3;/* Opaque pointer, passed along */
    caddr_t            crp_opaque4;/* Opaque pointer, passed along */
@


1.6
log
@Change the type of freesession to take u_int64_t as argument.
@
text
@d156 3
a158 1
extern int crypto_register(u_int32_t, int, void *, void *, void *);
@


1.5
log
@split out mbuf scatter gather function
@
text
@d148 1
a148 1
    int             (*cc_freesession) (u_int32_t);
@


1.4
log
@Better support for weird IV schemes (like ESP half-IV, or the swap
encryption block-number IV).
@
text
@d160 3
@


1.3
log
@Add CRD_F_IV_PRESENT, to indicate encryption requests where an
explicit IV preceeds the data to be encrypted.

Nice weather in Australia...
@
text
@d69 1
d82 3
a84 2
#define CRD_F_HALFIV              0x2
#define CRD_F_IV_PRESENT          0x4 /* Used/sensible only when encrypting */
d87 1
@


1.2
log
@move software crypto engine out of main crypto.c
@
text
@d82 1
@


1.2.2.1
log
@Sync with -current
@
text
@@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d44 1
a44 2
#define RIJNDAEL128_BLOCK_LEN  16
#define EALG_MAX_BLOCK_LEN     16  /* Keep this updated */
d54 3
a56 3
#define CRYPTO_MD5_HMAC         6
#define CRYPTO_SHA1_HMAC        7
#define CRYPTO_RIPEMD160_HMAC   8
a58 2
#define CRYPTO_RIJNDAEL128_CBC  11 /* 128 bit blocksize */
#define CRYPTO_AES_CBC          11 /* 128 bit blocksize -- the same as above */
d60 1
a60 1
#define CRYPTO_ALGORITHM_MAX    11 /* Keep this updated */
a68 1
    u_int8_t           cri_iv[EALG_MAX_BLOCK_LEN];      /* IV to use */
d81 1
a81 3
#define CRD_F_IV_PRESENT          0x2 /* When encrypting, IV is already in
				         place, so don't copy. */
#define CRD_F_IV_EXPLICIT         0x4 /* IV explicitly provided */
a83 1
#define crd_iv   CRD_INI.cri_iv
d115 4
a118 1
    caddr_t            crp_opaque;/* Opaque pointer, passed along */
d144 1
a144 1
    int             (*cc_freesession) (u_int64_t);
d152 1
a152 3
extern int crypto_register(u_int32_t, int,
    int (*)(u_int32_t *, struct cryptoini *), int (*)(u_int64_t),
    int (*)(struct cryptop *));
a154 6
extern void crypto_thread(void);
extern int crypto_invoke(struct cryptop *);
extern void crypto_done(struct cryptop *);

struct mbuf;
int	mbuf2pages(struct mbuf *, int *, long *, int *, int, int *);
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@@


1.1
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@a146 30
/* Software session entry */
struct swcr_data
{
    int               sw_alg;		/* Algorithm */
    union
    {
	struct
	{
            u_int8_t         *SW_ictx;
            u_int8_t         *SW_octx;
	    struct auth_hash *SW_axf;
	} SWCR_AUTH;

	struct
	{
            u_int8_t         *SW_kschedule;
            u_int8_t         *SW_iv;
	    struct enc_xform *SW_exf;
	} SWCR_ENC;
    } SWCR_UN;

#define sw_ictx      SWCR_UN.SWCR_AUTH.SW_ictx
#define sw_octx      SWCR_UN.SWCR_AUTH.SW_octx
#define sw_axf       SWCR_UN.SWCR_AUTH.SW_axf
#define sw_kschedule SWCR_UN.SWCR_ENC.SW_kschedule
#define sw_iv        SWCR_UN.SWCR_ENC.SW_iv
#define sw_exf       SWCR_UN.SWCR_ENC.SW_exf

    struct swcr_data *sw_next;
};
a148 11
extern u_int8_t hmac_ipad_buffer[64];
extern u_int8_t hmac_opad_buffer[64];

extern int swcr_encdec(struct cryptodesc *, struct swcr_data *, caddr_t, int);
extern int swcr_authcompute(struct cryptodesc *, struct swcr_data *,
			    caddr_t, int);
extern int swcr_process(struct cryptop *);
extern int swcr_newsession(u_int32_t *, struct cryptoini *);
extern int swcr_freesession(u_int32_t);
extern void swcr_init(void);

@

