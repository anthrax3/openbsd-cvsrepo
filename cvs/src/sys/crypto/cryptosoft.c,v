head	1.83;
access;
symbols
	OPENBSD_6_2:1.83.0.2
	OPENBSD_6_2_BASE:1.83
	OPENBSD_6_1:1.82.0.4
	OPENBSD_6_1_BASE:1.82
	OPENBSD_6_0:1.80.0.4
	OPENBSD_6_0_BASE:1.80
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.73.0.4
	OPENBSD_5_8_BASE:1.73
	OPENBSD_5_7:1.72.0.2
	OPENBSD_5_7_BASE:1.72
	OPENBSD_5_6:1.71.0.4
	OPENBSD_5_6_BASE:1.71
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.68.0.4
	OPENBSD_5_4_BASE:1.68
	OPENBSD_5_3:1.68.0.2
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.64.0.2
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.63
	OPENBSD_5_1:1.63.0.6
	OPENBSD_5_0:1.63.0.4
	OPENBSD_5_0_BASE:1.63
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.8
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.4
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.51.0.2
	OPENBSD_4_4_BASE:1.51
	OPENBSD_4_3:1.49.0.2
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.46.0.4
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.2
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.45.0.6
	OPENBSD_4_0_BASE:1.45
	OPENBSD_3_9:1.45.0.4
	OPENBSD_3_9_BASE:1.45
	OPENBSD_3_8:1.45.0.2
	OPENBSD_3_8_BASE:1.45
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.41
	SMP_SYNC_B:1.41
	OPENBSD_3_5:1.39.0.4
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.38.0.2
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.35.0.2
	OPENBSD_3_2_BASE:1.35
	OPENBSD_3_1:1.33.0.2
	OPENBSD_3_1_BASE:1.33
	UBC_SYNC_B:1.35
	UBC:1.29.0.2
	UBC_BASE:1.29
	OPENBSD_3_0:1.28.0.2
	OPENBSD_3_0_BASE:1.28
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.15.0.2
	OPENBSD_2_8_BASE:1.15
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.83
date	2017.05.02.11.44.32;	author mikeb;	state Exp;
branches;
next	1.82;
commitid	wirszMgsR4O7G8R6;

1.82
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.81;
commitid	dMJlqKWYCJoMV7JN;

1.81
date	2016.09.02.09.12.49;	author tom;	state Exp;
branches;
next	1.80;
commitid	usWbfmtqPiIXMDzk;

1.80
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.79;
commitid	T0HbsCFlrwPATHlH;

1.79
date	2015.11.18.12.23.14;	author mikeb;	state Exp;
branches;
next	1.78;
commitid	a2M45b9n6Xcrv6Sz;

1.78
date	2015.11.13.12.21.16;	author mikeb;	state Exp;
branches;
next	1.77;
commitid	YLaQcqVfNSwoLvqJ;

1.77
date	2015.11.12.16.57.00;	author mikeb;	state Exp;
branches;
next	1.76;
commitid	AJi1Y8XIoDdjU0oD;

1.76
date	2015.11.03.01.35.16;	author mikeb;	state Exp;
branches;
next	1.75;
commitid	1euqS2XorQ0iDt3L;

1.75
date	2015.10.26.17.22.50;	author mikeb;	state Exp;
branches;
next	1.74;
commitid	e1FGCCNx58gvmcqL;

1.74
date	2015.08.31.18.13.27;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	rKjFWyCG4i3evDF6;

1.73
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.72;
commitid	p4LJxGKbi0BU2cG6;

1.72
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.71;
commitid	cPvnXrnDy9of9D0l;

1.71
date	2014.07.13.23.24.47;	author deraadt;	state Exp;
branches;
next	1.70;
commitid	rg2qHVAzxM4HfBBO;

1.70
date	2014.07.12.18.50.00;	author tedu;	state Exp;
branches;
next	1.69;
commitid	C8XZQyreqTUCeixA;

1.69
date	2013.08.25.14.26.56;	author jsing;	state Exp;
branches;
next	1.68;

1.68
date	2012.12.11.14.49.31;	author mikeb;	state Exp;
branches;
next	1.67;

1.67
date	2012.12.07.20.55.51;	author mikeb;	state Exp;
branches;
next	1.66;

1.66
date	2012.12.07.17.03.22;	author mikeb;	state Exp;
branches;
next	1.65;

1.65
date	2012.10.04.13.17.12;	author haesbaert;	state Exp;
branches;
next	1.64;

1.64
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.11.23.00.21;	author markus;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.11.16.04.19;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.11.15.46.47;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2010.12.22.00.55.45;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.12.21.22.24.21;	author markus;	state Exp;
branches;
next	1.57;

1.57
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.56;

1.56
date	2010.10.06.10.00.59;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.22.11.54.23;	author mikeb;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.02.02.40.15;	author blambert;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.51;

1.51
date	2008.06.09.16.07.00;	author djm;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.09.07.07.15;	author djm;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.15.11.00.51;	author hshoexer;	state Exp;
branches;
next	1.48;

1.48
date	2007.09.13.21.26.41;	author hshoexer;	state Exp;
branches;
next	1.47;

1.47
date	2007.09.10.22.19.42;	author henric;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.44;

1.44
date	2005.05.10.13.42.11;	author markus;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.02.22.19.10;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.20.20.31.18;	author hshoexer;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.07.14.42.26;	author millert;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.14.20.03.05;	author markus;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.21.20.33.35;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.21.19.34.25;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.12.18.23.13;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.04.26.08.43.50;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2002.04.22.23.10.09;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2002.04.03.23.22.36;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.19.23.24.53;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.05.15.59.41;	author markus;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.01.02.50.02;	author provos;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches
	1.29.2.1;
next	1.28;

1.28
date	2001.08.08.15.12.09;	author jjbg;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.07.05.17.53.28;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.05.16.44.00;	author jjbg;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.25.05.02.22;	author angelos;	state Exp;
branches;
next	1.24;

1.24
date	2001.06.23.21.00.49;	author angelos;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.23.18.30.36;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.16.22.17.49;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.06.04.37.07;	author angelos;	state Exp;
branches;
next	1.20;

1.20
date	2001.05.15.02.40.35;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.05.00.31.34;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.17.04.07.05;	author angelos;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.11.09.14.26.24;	author art;	state Exp;
branches;
next	1.15;

1.15
date	2000.10.15.01.12.24;	author angelos;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.19.13.43.23;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.21.00.02.20;	author angelos;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.20.05.40.38;	author angelos;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.18.08.48.10;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.18.08.37.11;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.06.06.49.47;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.06.06.43.38;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.23.05.04.13;	author angelos;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.04.23.05.01.53;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.18.06.21.14;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.29.07.09.40;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.25.04.40.44;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.20.21.21.49;	author deraadt;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.03.19.06.53.40;	author deraadt;	state Exp;
branches;
next	;

1.2.2.1
date	2000.03.24.09.09.05;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.05.14.22.06.51;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.07.04.10.39.59;	author niklas;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.2.2.7;

1.2.2.7
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.2.2.8;

1.2.2.8
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.2.2.9;

1.2.2.9
date	2004.02.19.10.51.30;	author niklas;	state Exp;
branches;
next	1.2.2.10;

1.2.2.10
date	2004.06.05.23.12.35;	author niklas;	state Exp;
branches;
next	;

1.7.2.1
date	2000.08.04.05.47.09;	author jason;	state Exp;
branches;
next	;

1.17.2.1
date	2001.06.06.22.29.57;	author jason;	state Exp;
branches;
next	;

1.28.2.1
date	2001.12.14.21.48.07;	author jason;	state Exp;
branches;
next	;

1.29.2.1
date	2002.06.11.03.28.34;	author art;	state Exp;
branches;
next	1.29.2.2;

1.29.2.2
date	2003.05.19.21.53.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.83
log
@Switch OCF and IPsec over to the new AES

ok djm
@
text
@/*	$OpenBSD: cryptosoft.c,v 1.82 2017/02/07 17:25:46 patrick Exp $	*/

/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Athens, Greece, in
 * February 2000. Network Security Technologies Inc. (NSTI) kindly
 * supported the development of this code.
 *
 * Copyright (c) 2000, 2001 Angelos D. Keromytis
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all source code copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/errno.h>
#include <dev/rndvar.h>
#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/rmd160.h>
#include <crypto/cast.h>
#include <crypto/cryptodev.h>
#include <crypto/cryptosoft.h>
#include <crypto/xform.h>

const u_int8_t hmac_ipad_buffer[HMAC_MAX_BLOCK_LEN] = {
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};

const u_int8_t hmac_opad_buffer[HMAC_MAX_BLOCK_LEN] = {
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
};


struct swcr_data **swcr_sessions = NULL;
u_int32_t swcr_sesnum = 0;
int32_t swcr_id = -1;

#define COPYBACK(x, a, b, c, d) \
	do { \
		if ((x) == CRYPTO_BUF_MBUF) \
			m_copyback((struct mbuf *)a,b,c,d,M_NOWAIT); \
		else \
			cuio_copyback((struct uio *)a,b,c,d); \
	} while (0)
#define COPYDATA(x, a, b, c, d) \
	do { \
		if ((x) == CRYPTO_BUF_MBUF) \
			m_copydata((struct mbuf *)a,b,c,d); \
		else \
			cuio_copydata((struct uio *)a,b,c,d); \
	} while (0)

/*
 * Apply a symmetric encryption/decryption algorithm.
 */
int
swcr_encdec(struct cryptodesc *crd, struct swcr_data *sw, caddr_t buf,
    int outtype)
{
	unsigned char iv[EALG_MAX_BLOCK_LEN], blk[EALG_MAX_BLOCK_LEN], *idat;
	unsigned char *ivp, *nivp, iv2[EALG_MAX_BLOCK_LEN];
	struct enc_xform *exf;
	int i, k, j, blks, ind, count, ivlen;
	struct mbuf *m = NULL;
	struct uio *uio = NULL;

	exf = sw->sw_exf;
	blks = exf->blocksize;
	ivlen = exf->ivsize;

	/* Check for non-padded data */
	if (crd->crd_len % blks)
		return EINVAL;

	if (outtype == CRYPTO_BUF_MBUF)
		m = (struct mbuf *) buf;
	else
		uio = (struct uio *) buf;

	/* Initialize the IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		/* IV explicitly provided ? */
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, ivlen);
		else
			arc4random_buf(iv, ivlen);

		/* Do we need to write the IV */
		if (!(crd->crd_flags & CRD_F_IV_PRESENT))
			COPYBACK(outtype, buf, crd->crd_inject, ivlen, iv);

	} else {	/* Decryption */
			/* IV explicitly provided ? */
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, ivlen);
		else {
			/* Get IV off buf */
			COPYDATA(outtype, buf, crd->crd_inject, ivlen, iv);
		}
	}

	ivp = iv;

	/*
	 * xforms that provide a reinit method perform all IV
	 * handling themselves.
	 */
	if (exf->reinit)
		exf->reinit(sw->sw_kschedule, iv);

	if (outtype == CRYPTO_BUF_MBUF) {
		/* Find beginning of data */
		m = m_getptr(m, crd->crd_skip, &k);
		if (m == NULL)
			return EINVAL;

		i = crd->crd_len;

		while (i > 0) {
			/*
			 * If there's insufficient data at the end of
			 * an mbuf, we have to do some copying.
			 */
			if (m->m_len < k + blks && m->m_len != k) {
				m_copydata(m, k, blks, blk);

				/* Actual encryption/decryption */
				if (exf->reinit) {
					if (crd->crd_flags & CRD_F_ENCRYPT) {
						exf->encrypt(sw->sw_kschedule,
						    blk);
					} else {
						exf->decrypt(sw->sw_kschedule,
						    blk);
					}
				} else if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, blk);

					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					bcopy(blk, iv, blks);
					ivp = iv;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					nivp = (ivp == iv) ? iv2 : iv;
					bcopy(blk, nivp, blks);

					exf->decrypt(sw->sw_kschedule, blk);

					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];
					ivp = nivp;
				}

				/* Copy back decrypted block */
				m_copyback(m, k, blks, blk, M_NOWAIT);

				/* Advance pointer */
				m = m_getptr(m, k + blks, &k);
				if (m == NULL)
					return EINVAL;

				i -= blks;

				/* Could be done... */
				if (i == 0)
					break;
			}

			/* Skip possibly empty mbufs */
			if (k == m->m_len) {
				for (m = m->m_next; m && m->m_len == 0;
				    m = m->m_next)
					;
				k = 0;
			}

			/* Sanity check */
			if (m == NULL)
				return EINVAL;

			/*
			 * Warning: idat may point to garbage here, but
			 * we only use it in the while() loop, only if
			 * there are indeed enough data.
			 */
			idat = mtod(m, unsigned char *) + k;

			while (m->m_len >= k + blks && i > 0) {
				if (exf->reinit) {
					if (crd->crd_flags & CRD_F_ENCRYPT) {
						exf->encrypt(sw->sw_kschedule,
						    idat);
					} else {
						exf->decrypt(sw->sw_kschedule,
						    idat);
					}
				} else if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, idat);
					ivp = idat;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block to be used
					 * in next block's processing.
					 */
					nivp = (ivp == iv) ? iv2 : iv;
					bcopy(idat, nivp, blks);

					exf->decrypt(sw->sw_kschedule, idat);

					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];
					ivp = nivp;
				}

				idat += blks;
				k += blks;
				i -= blks;
			}
		}
	} else {
		/* Find beginning of data */
		count = crd->crd_skip;
		ind = cuio_getptr(uio, count, &k);
		if (ind == -1)
			return EINVAL;

		i = crd->crd_len;

		while (i > 0) {
			/*
			 * If there's insufficient data at the end,
			 * we have to do some copying.
			 */
			if (uio->uio_iov[ind].iov_len < k + blks &&
			    uio->uio_iov[ind].iov_len != k) {
				cuio_copydata(uio, count, blks, blk);

				/* Actual encryption/decryption */
				if (exf->reinit) {
					if (crd->crd_flags & CRD_F_ENCRYPT) {
						exf->encrypt(sw->sw_kschedule,
						    blk);
					} else {
						exf->decrypt(sw->sw_kschedule,
						    blk);
					}
				} else if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, blk);

					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					bcopy(blk, iv, blks);
					ivp = iv;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					nivp = (ivp == iv) ? iv2 : iv;
					bcopy(blk, nivp, blks);

					exf->decrypt(sw->sw_kschedule, blk);

					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];
					ivp = nivp;
				}

				/* Copy back decrypted block */
				cuio_copyback(uio, count, blks, blk);

				count += blks;

				/* Advance pointer */
				ind = cuio_getptr(uio, count, &k);
				if (ind == -1)
					return (EINVAL);

				i -= blks;

				/* Could be done... */
				if (i == 0)
					break;
			}

			/*
			 * Warning: idat may point to garbage here, but
			 * we only use it in the while() loop, only if
			 * there are indeed enough data.
			 */
			idat = (char *)uio->uio_iov[ind].iov_base + k;

			while (uio->uio_iov[ind].iov_len >= k + blks &&
			    i > 0) {
				if (exf->reinit) {
					if (crd->crd_flags & CRD_F_ENCRYPT) {
						exf->encrypt(sw->sw_kschedule,
						    idat);
					} else {
						exf->decrypt(sw->sw_kschedule,
						    idat);
					}
				} else if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, idat);
					ivp = idat;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block to be used
					 * in next block's processing.
					 */
					nivp = (ivp == iv) ? iv2 : iv;
					bcopy(idat, nivp, blks);

					exf->decrypt(sw->sw_kschedule, idat);

					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];
					ivp = nivp;
				}

				idat += blks;
				count += blks;
				k += blks;
				i -= blks;
			}

			/*
			 * Advance to the next iov if the end of the current iov
			 * is aligned with the end of a cipher block.
			 * Note that the code is equivalent to calling:
			 *	ind = cuio_getptr(uio, count, &k);
			 */
			if (i > 0 && k == uio->uio_iov[ind].iov_len) {
				k = 0;
				ind++;
				if (ind >= uio->uio_iovcnt)
					return (EINVAL);
			}
		}
	}

	return 0; /* Done with encryption/decryption */
}

/*
 * Compute keyed-hash authenticator.
 */
int
swcr_authcompute(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf, int outtype)
{
	unsigned char aalg[AALG_MAX_RESULT_LEN];
	struct auth_hash *axf;
	union authctx ctx;
	int err;

	if (sw->sw_ictx == 0)
		return EINVAL;

	axf = sw->sw_axf;

	bcopy(sw->sw_ictx, &ctx, axf->ctxsize);

	if (outtype == CRYPTO_BUF_MBUF)
		err = m_apply((struct mbuf *) buf, crd->crd_skip, crd->crd_len,
		    (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		    (caddr_t) &ctx);
	else
		err = cuio_apply((struct uio *) buf, crd->crd_skip,
		    crd->crd_len,
		    (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		    (caddr_t) &ctx);

	if (err)
		return err;

	if (crd->crd_flags & CRD_F_ESN)
		axf->Update(&ctx, crd->crd_esn, 4);

	switch (sw->sw_alg) {
	case CRYPTO_MD5_HMAC:
	case CRYPTO_SHA1_HMAC:
	case CRYPTO_RIPEMD160_HMAC:
	case CRYPTO_SHA2_256_HMAC:
	case CRYPTO_SHA2_384_HMAC:
	case CRYPTO_SHA2_512_HMAC:
		if (sw->sw_octx == NULL)
			return EINVAL;

		axf->Final(aalg, &ctx);
		bcopy(sw->sw_octx, &ctx, axf->ctxsize);
		axf->Update(&ctx, aalg, axf->hashsize);
		axf->Final(aalg, &ctx);
		break;
	}

	/* Inject the authentication data */
	if (outtype == CRYPTO_BUF_MBUF)
		COPYBACK(outtype, buf, crd->crd_inject, axf->authsize, aalg);
	else
		bcopy(aalg, crp->crp_mac, axf->authsize);

	return 0;
}

/*
 * Apply a combined encryption-authentication transformation
 */
int
swcr_authenc(struct cryptop *crp)
{
	uint32_t blkbuf[howmany(EALG_MAX_BLOCK_LEN, sizeof(uint32_t))];
	u_char *blk = (u_char *)blkbuf;
	u_char aalg[AALG_MAX_RESULT_LEN];
	u_char iv[EALG_MAX_BLOCK_LEN];
	union authctx ctx;
	struct cryptodesc *crd, *crda = NULL, *crde = NULL;
	struct swcr_data *sw, *swa, *swe = NULL;
	struct auth_hash *axf = NULL;
	struct enc_xform *exf = NULL;
	caddr_t buf = (caddr_t)crp->crp_buf;
	uint32_t *blkp;
	int aadlen, blksz, i, ivlen, outtype, len, iskip, oskip;

	ivlen = blksz = iskip = oskip = 0;

	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		for (sw = swcr_sessions[crp->crp_sid & 0xffffffff];
		     sw && sw->sw_alg != crd->crd_alg;
		     sw = sw->sw_next)
			;
		if (sw == NULL)
			return (EINVAL);

		switch (sw->sw_alg) {
		case CRYPTO_AES_GCM_16:
		case CRYPTO_AES_GMAC:
		case CRYPTO_CHACHA20_POLY1305:
			swe = sw;
			crde = crd;
			exf = swe->sw_exf;
			ivlen = exf->ivsize;
			break;
		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
		case CRYPTO_CHACHA20_POLY1305_MAC:
			swa = sw;
			crda = crd;
			axf = swa->sw_axf;
			if (swa->sw_ictx == 0)
				return (EINVAL);
			bcopy(swa->sw_ictx, &ctx, axf->ctxsize);
			blksz = axf->blocksize;
			break;
		default:
			return (EINVAL);
		}
	}
	if (crde == NULL || crda == NULL)
		return (EINVAL);

	if (crp->crp_flags & CRYPTO_F_IMBUF) {
		outtype = CRYPTO_BUF_MBUF;
	} else {
		outtype = CRYPTO_BUF_IOV;
	}

	/* Initialize the IV */
	if (crde->crd_flags & CRD_F_ENCRYPT) {
		/* IV explicitly provided ? */
		if (crde->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crde->crd_iv, iv, ivlen);
		else
			arc4random_buf(iv, ivlen);

		/* Do we need to write the IV */
		if (!(crde->crd_flags & CRD_F_IV_PRESENT))
			COPYBACK(outtype, buf, crde->crd_inject, ivlen, iv);

	} else {	/* Decryption */
			/* IV explicitly provided ? */
		if (crde->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crde->crd_iv, iv, ivlen);
		else {
			/* Get IV off buf */
			COPYDATA(outtype, buf, crde->crd_inject, ivlen, iv);
		}
	}

	/* Supply MAC with IV */
	if (axf->Reinit)
		axf->Reinit(&ctx, iv, ivlen);

	/* Supply MAC with AAD */
	aadlen = crda->crd_len;
	/*
	 * Section 5 of RFC 4106 specifies that AAD construction consists of
	 * {SPI, ESN, SN} whereas the real packet contains only {SPI, SN}.
	 * Unfortunately it doesn't follow a good example set in the Section
	 * 3.3.2.1 of RFC 4303 where upper part of the ESN, located in the
	 * external (to the packet) memory buffer, is processed by the hash
	 * function in the end thus allowing to retain simple programming
	 * interfaces and avoid kludges like the one below.
	 */
	if (crda->crd_flags & CRD_F_ESN) {
		aadlen += 4;
		/* SPI */
		COPYDATA(outtype, buf, crda->crd_skip, 4, blk);
		iskip = 4; /* loop below will start with an offset of 4 */
		/* ESN */
		bcopy(crda->crd_esn, blk + 4, 4);
		oskip = iskip + 4; /* offset output buffer blk by 8 */
	}
	for (i = iskip; i < crda->crd_len; i += axf->hashsize) {
		len = MIN(crda->crd_len - i, axf->hashsize - oskip);
		COPYDATA(outtype, buf, crda->crd_skip + i, len, blk + oskip);
		bzero(blk + len + oskip, axf->hashsize - len - oskip);
		axf->Update(&ctx, blk, axf->hashsize);
		oskip = 0; /* reset initial output offset */
	}

	if (exf->reinit)
		exf->reinit(swe->sw_kschedule, iv);

	/* Do encryption/decryption with MAC */
	for (i = 0; i < crde->crd_len; i += blksz) {
		len = MIN(crde->crd_len - i, blksz);
		if (len < blksz)
			bzero(blk, blksz);
		COPYDATA(outtype, buf, crde->crd_skip + i, len, blk);
		if (crde->crd_flags & CRD_F_ENCRYPT) {
			exf->encrypt(swe->sw_kschedule, blk);
			axf->Update(&ctx, blk, len);
		} else {
			axf->Update(&ctx, blk, len);
			exf->decrypt(swe->sw_kschedule, blk);
		}
		COPYBACK(outtype, buf, crde->crd_skip + i, len, blk);
	}

	/* Do any required special finalization */
	switch (crda->crd_alg) {
		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
			/* length block */
			bzero(blk, axf->hashsize);
			blkp = (uint32_t *)blk + 1;
			*blkp = htobe32(aadlen * 8);
			blkp = (uint32_t *)blk + 3;
			*blkp = htobe32(crde->crd_len * 8);
			axf->Update(&ctx, blk, axf->hashsize);
			break;
		case CRYPTO_CHACHA20_POLY1305_MAC:
			/* length block */
			bzero(blk, axf->hashsize);
			blkp = (uint32_t *)blk;
			*blkp = htole32(aadlen);
			blkp = (uint32_t *)blk + 2;
			*blkp = htole32(crde->crd_len);
			axf->Update(&ctx, blk, axf->hashsize);
			break;
	}

	/* Finalize MAC */
	axf->Final(aalg, &ctx);

	/* Inject the authentication data */
	if (outtype == CRYPTO_BUF_MBUF)
		COPYBACK(outtype, buf, crda->crd_inject, axf->authsize, aalg);
	else
		bcopy(aalg, crp->crp_mac, axf->authsize);

	return (0);
}

/*
 * Apply a compression/decompression algorithm
 */
int
swcr_compdec(struct cryptodesc *crd, struct swcr_data *sw,
    caddr_t buf, int outtype)
{
	u_int8_t *data, *out;
	struct comp_algo *cxf;
	int adj;
	u_int32_t result;

	cxf = sw->sw_cxf;

	/* We must handle the whole buffer of data in one time
	 * then if there is not all the data in the mbuf, we must
	 * copy in a buffer.
	 */

	data = malloc(crd->crd_len, M_CRYPTO_DATA, M_NOWAIT);
	if (data == NULL)
		return (EINVAL);
	COPYDATA(outtype, buf, crd->crd_skip, crd->crd_len, data);

	if (crd->crd_flags & CRD_F_COMP)
		result = cxf->compress(data, crd->crd_len, &out);
	else
		result = cxf->decompress(data, crd->crd_len, &out);

	free(data, M_CRYPTO_DATA, crd->crd_len);
	if (result == 0)
		return EINVAL;

	/* Copy back the (de)compressed data. m_copyback is
	 * extending the mbuf as necessary.
	 */
	sw->sw_size = result;
	/* Check the compressed size when doing compression */
	if (crd->crd_flags & CRD_F_COMP) {
		if (result > crd->crd_len) {
			/* Compression was useless, we lost time */
			free(out, M_CRYPTO_DATA, 0);
			return 0;
		}
	}

	COPYBACK(outtype, buf, crd->crd_skip, result, out);
	if (result < crd->crd_len) {
		adj = result - crd->crd_len;
		if (outtype == CRYPTO_BUF_MBUF) {
			adj = result - crd->crd_len;
			m_adj((struct mbuf *)buf, adj);
		} else {
			struct uio *uio = (struct uio *)buf;
			int ind;

			adj = crd->crd_len - result;
			ind = uio->uio_iovcnt - 1;

			while (adj > 0 && ind >= 0) {
				if (adj < uio->uio_iov[ind].iov_len) {
					uio->uio_iov[ind].iov_len -= adj;
					break;
				}

				adj -= uio->uio_iov[ind].iov_len;
				uio->uio_iov[ind].iov_len = 0;
				ind--;
				uio->uio_iovcnt--;
			}
		}
	}
	free(out, M_CRYPTO_DATA, 0);
	return 0;
}

/*
 * Generate a new software session.
 */
int
swcr_newsession(u_int32_t *sid, struct cryptoini *cri)
{
	struct swcr_data **swd;
	struct auth_hash *axf;
	struct enc_xform *txf;
	struct comp_algo *cxf;
	u_int32_t i;
	int k;

	if (sid == NULL || cri == NULL)
		return EINVAL;

	if (swcr_sessions) {
		for (i = 1; i < swcr_sesnum; i++)
			if (swcr_sessions[i] == NULL)
				break;
	}

	if (swcr_sessions == NULL || i == swcr_sesnum) {
		if (swcr_sessions == NULL) {
			i = 1; /* We leave swcr_sessions[0] empty */
			swcr_sesnum = CRYPTO_SW_SESSIONS;
		} else
			swcr_sesnum *= 2;

		swd = mallocarray(swcr_sesnum, sizeof(struct swcr_data *),
		    M_CRYPTO_DATA, M_NOWAIT | M_ZERO);
		if (swd == NULL) {
			/* Reset session number */
			if (swcr_sesnum == CRYPTO_SW_SESSIONS)
				swcr_sesnum = 0;
			else
				swcr_sesnum /= 2;
			return ENOBUFS;
		}

		/* Copy existing sessions */
		if (swcr_sessions) {
			bcopy(swcr_sessions, swd,
			    (swcr_sesnum / 2) * sizeof(struct swcr_data *));
			free(swcr_sessions, M_CRYPTO_DATA,
			    (swcr_sesnum / 2) * sizeof(struct swcr_data *));
		}

		swcr_sessions = swd;
	}

	swd = &swcr_sessions[i];
	*sid = i;

	while (cri) {
		*swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
		    M_NOWAIT | M_ZERO);
		if (*swd == NULL) {
			swcr_freesession(i);
			return ENOBUFS;
		}

		switch (cri->cri_alg) {
		case CRYPTO_3DES_CBC:
			txf = &enc_xform_3des;
			goto enccommon;
		case CRYPTO_BLF_CBC:
			txf = &enc_xform_blf;
			goto enccommon;
		case CRYPTO_CAST_CBC:
			txf = &enc_xform_cast5;
			goto enccommon;
		case CRYPTO_AES_CBC:
			txf = &enc_xform_aes;
			goto enccommon;
		case CRYPTO_AES_CTR:
			txf = &enc_xform_aes_ctr;
			goto enccommon;
		case CRYPTO_AES_XTS:
			txf = &enc_xform_aes_xts;
			goto enccommon;
		case CRYPTO_AES_GCM_16:
			txf = &enc_xform_aes_gcm;
			goto enccommon;
		case CRYPTO_AES_GMAC:
			txf = &enc_xform_aes_gmac;
			(*swd)->sw_exf = txf;
			break;
		case CRYPTO_CHACHA20_POLY1305:
			txf = &enc_xform_chacha20_poly1305;
			goto enccommon;
		case CRYPTO_NULL:
			txf = &enc_xform_null;
			goto enccommon;
		enccommon:
			if (txf->ctxsize > 0) {
				(*swd)->sw_kschedule = malloc(txf->ctxsize,
				    M_CRYPTO_DATA, M_NOWAIT | M_ZERO);
				if ((*swd)->sw_kschedule == NULL) {
					swcr_freesession(i);
					return EINVAL;
				}
			}
			if (txf->setkey((*swd)->sw_kschedule, cri->cri_key,
			    cri->cri_klen / 8) < 0) {
				swcr_freesession(i);
				return EINVAL;
			}
			(*swd)->sw_exf = txf;
			break;

		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_128;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_192;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_256;
			goto authcommon;
		authcommon:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			(*swd)->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_octx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= HMAC_IPAD_VAL;

			axf->Init((*swd)->sw_ictx);
			axf->Update((*swd)->sw_ictx, cri->cri_key,
			    cri->cri_klen / 8);
			axf->Update((*swd)->sw_ictx, hmac_ipad_buffer,
			    axf->blocksize - (cri->cri_klen / 8));

			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

			axf->Init((*swd)->sw_octx);
			axf->Update((*swd)->sw_octx, cri->cri_key,
			    cri->cri_klen / 8);
			axf->Update((*swd)->sw_octx, hmac_opad_buffer,
			    axf->blocksize - (cri->cri_klen / 8));

			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= HMAC_OPAD_VAL;
			(*swd)->sw_axf = axf;
			break;

		case CRYPTO_AES_128_GMAC:
			axf = &auth_hash_gmac_aes_128;
			goto authenccommon;
		case CRYPTO_AES_192_GMAC:
			axf = &auth_hash_gmac_aes_192;
			goto authenccommon;
		case CRYPTO_AES_256_GMAC:
			axf = &auth_hash_gmac_aes_256;
			goto authenccommon;
		case CRYPTO_CHACHA20_POLY1305_MAC:
			axf = &auth_hash_chacha20_poly1305;
			goto authenccommon;
		authenccommon:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
			axf->Init((*swd)->sw_ictx);
			axf->Setkey((*swd)->sw_ictx, cri->cri_key,
			    cri->cri_klen / 8);
			(*swd)->sw_axf = axf;
			break;

		case CRYPTO_DEFLATE_COMP:
			cxf = &comp_algo_deflate;
			(*swd)->sw_cxf = cxf;
			break;
		case CRYPTO_ESN:
			/* nothing to do */
			break;
		default:
			swcr_freesession(i);
			return EINVAL;
		}

		(*swd)->sw_alg = cri->cri_alg;
		cri = cri->cri_next;
		swd = &((*swd)->sw_next);
	}
	return 0;
}

/*
 * Free a session.
 */
int
swcr_freesession(u_int64_t tid)
{
	struct swcr_data *swd;
	struct enc_xform *txf;
	struct auth_hash *axf;
	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;

	if (sid > swcr_sesnum || swcr_sessions == NULL ||
	    swcr_sessions[sid] == NULL)
		return EINVAL;

	/* Silently accept and return */
	if (sid == 0)
		return 0;

	while ((swd = swcr_sessions[sid]) != NULL) {
		swcr_sessions[sid] = swd->sw_next;

		switch (swd->sw_alg) {
		case CRYPTO_3DES_CBC:
		case CRYPTO_BLF_CBC:
		case CRYPTO_CAST_CBC:
		case CRYPTO_AES_CBC:
		case CRYPTO_AES_CTR:
		case CRYPTO_AES_XTS:
		case CRYPTO_AES_GCM_16:
		case CRYPTO_AES_GMAC:
		case CRYPTO_CHACHA20_POLY1305:
		case CRYPTO_NULL:
			txf = swd->sw_exf;

			if (swd->sw_kschedule) {
				explicit_bzero(swd->sw_kschedule, txf->ctxsize);
				free(swd->sw_kschedule, M_CRYPTO_DATA, 0);
			}
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			axf = swd->sw_axf;

			if (swd->sw_ictx) {
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
				free(swd->sw_ictx, M_CRYPTO_DATA, 0);
			}
			if (swd->sw_octx) {
				explicit_bzero(swd->sw_octx, axf->ctxsize);
				free(swd->sw_octx, M_CRYPTO_DATA, 0);
			}
			break;

		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
		case CRYPTO_CHACHA20_POLY1305_MAC:
			axf = swd->sw_axf;

			if (swd->sw_ictx) {
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
				free(swd->sw_ictx, M_CRYPTO_DATA, 0);
			}
			break;
		}

		free(swd, M_CRYPTO_DATA, 0);
	}
	return 0;
}

/*
 * Process a software request.
 */
int
swcr_process(struct cryptop *crp)
{
	struct cryptodesc *crd;
	struct swcr_data *sw;
	u_int32_t lid;
	int type;
	int i;

	/* Sanity check */
	if (crp == NULL)
		return EINVAL;

	if (crp->crp_ndesc < 1 || crp->crp_buf == NULL) {
		crp->crp_etype = EINVAL;
		goto done;
	}

	lid = crp->crp_sid & 0xffffffff;
	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions[lid] == NULL) {
		crp->crp_etype = ENOENT;
		goto done;
	}

	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type = CRYPTO_BUF_IOV;

	/* Go through crypto descriptors, processing as we go */
	for (i = 0; i < crp->crp_ndesc; i++) {
		crd = &crp->crp_desc[i];
		/*
		 * Find the crypto context.
		 *
		 * XXX Note that the logic here prevents us from having
		 * XXX the same algorithm multiple times in a session
		 * XXX (or rather, we can but it won't give us the right
		 * XXX results). To do that, we'd need some way of differentiating
		 * XXX between the various instances of an algorithm (so we can
		 * XXX locate the correct crypto context).
		 */
		for (sw = swcr_sessions[lid];
		    sw && sw->sw_alg != crd->crd_alg;
		    sw = sw->sw_next)
			;

		/* No such context ? */
		if (sw == NULL) {
			crp->crp_etype = EINVAL;
			goto done;
		}

		switch (sw->sw_alg) {
		case CRYPTO_NULL:
			break;
		case CRYPTO_3DES_CBC:
		case CRYPTO_BLF_CBC:
		case CRYPTO_CAST_CBC:
		case CRYPTO_RIJNDAEL128_CBC:
		case CRYPTO_AES_CTR:
		case CRYPTO_AES_XTS:
			if ((crp->crp_etype = swcr_encdec(crd, sw,
			    crp->crp_buf, type)) != 0)
				goto done;
			break;
		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
			if ((crp->crp_etype = swcr_authcompute(crp, crd, sw,
			    crp->crp_buf, type)) != 0)
				goto done;
			break;

		case CRYPTO_AES_GCM_16:
		case CRYPTO_AES_GMAC:
		case CRYPTO_AES_128_GMAC:
		case CRYPTO_AES_192_GMAC:
		case CRYPTO_AES_256_GMAC:
		case CRYPTO_CHACHA20_POLY1305:
		case CRYPTO_CHACHA20_POLY1305_MAC:
			crp->crp_etype = swcr_authenc(crp);
			goto done;

		case CRYPTO_DEFLATE_COMP:
			if ((crp->crp_etype = swcr_compdec(crd, sw,
			    crp->crp_buf, type)) != 0)
				goto done;
			else
				crp->crp_olen = (int)sw->sw_size;
			break;

		default:
			/* Unknown/unsupported algorithm */
			crp->crp_etype = EINVAL;
			goto done;
		}
	}

done:
	crypto_done(crp);
	return 0;
}

/*
 * Initialize the driver, called from the kernel main().
 */
void
swcr_init(void)
{
	int algs[CRYPTO_ALGORITHM_MAX + 1];
	int flags = CRYPTOCAP_F_SOFTWARE;

	swcr_id = crypto_get_driverid(flags);
	if (swcr_id < 0) {
		/* This should never happen */
		panic("Software crypto device cannot initialize!");
	}

	bzero(algs, sizeof(algs));

	algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_BLF_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_CAST_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_CTR] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_XTS] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_GCM_16] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_DEFLATE_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_NULL] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_128_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_192_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_AES_256_GMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_CHACHA20_POLY1305] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_CHACHA20_POLY1305_MAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_ESN] = CRYPTO_ALG_FLAG_SUPPORTED;

	crypto_register(swcr_id, algs, swcr_newsession,
	    swcr_freesession, swcr_process);
}
@


1.82
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.81 2016/09/02 09:12:49 tom Exp $	*/
d798 2
a799 2
		case CRYPTO_RIJNDAEL128_CBC:
			txf = &enc_xform_rijndael128;
d963 1
a963 1
		case CRYPTO_RIJNDAEL128_CBC:
d1147 1
a1147 1
	algs[CRYPTO_RIJNDAEL128_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.81
log
@Remove variables 'm' and 'uio' that are only ever assigned to
(in swcr_authenc())

ok mikeb@@, who pointed out that I'd missed uio
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.80 2015/12/10 21:00:51 naddy Exp $	*/
d498 2
a499 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
d1024 1
d1030 1
a1030 1
	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
d1047 2
a1048 1
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
@


1.80
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.79 2015/11/18 12:23:14 mikeb Exp $	*/
a491 2
	struct mbuf *m = NULL;
	struct uio *uio = NULL;
a535 1
		m = (struct mbuf *)buf;
a537 1
		uio = (struct uio *)buf;
@


1.79
log
@Cleanup gotos as suggested by jsing@@ along with spaces and label names
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.78 2015/11/13 12:21:16 mikeb Exp $	*/
a791 3
		case CRYPTO_DES_CBC:
			txf = &enc_xform_des;
			goto enccommon;
a962 1
		case CRYPTO_DES_CBC:
a1073 1
		case CRYPTO_DES_CBC:
a1141 1
	algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.78
log
@Remove unused non HMAC versions of MD5 and SHA1;  ok mpi, deraadt, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.77 2015/11/12 16:57:00 mikeb Exp $	*/
d860 1
d901 1
a901 2
			goto auth4common;

d904 1
a904 2
			goto auth4common;

d907 1
a907 2
			goto auth4common;

d910 2
a911 1
		auth4common:
@


1.77
log
@remove a few unused defines
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.76 2015/11/03 01:35:16 mikeb Exp $	*/
a465 5

	case CRYPTO_MD5:
	case CRYPTO_SHA1:
		axf->Final(aalg, &ctx);
		break;
a897 18
		case CRYPTO_MD5:
			axf = &auth_hash_md5;
			goto auth3common;

		case CRYPTO_SHA1:
			axf = &auth_hash_sha1;
		auth3common:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			axf->Init((*swd)->sw_ictx);
			(*swd)->sw_axf = axf;
			break;

a1007 2
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
a1095 2
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
a1154 2
	algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.76
log
@Enable Chacha20-Poly1305 in the software crypto driver

ok naddy, jsing, reyk
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.75 2015/10/26 17:22:50 mikeb Exp $	*/
d1165 1
a1165 2
	int flags = CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_ENCRYPT_MAC |
	    CRYPTOCAP_F_MAC_ENCRYPT;
@


1.75
log
@Use axf's hashsize as a block size in the authenticated encryption routine.
No change for GCM, however upcoming changes will rely on this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.74 2015/08/31 18:13:27 deraadt Exp $	*/
d516 1
d525 1
d635 9
d825 3
d931 4
d999 1
d1030 1
d1133 2
d1198 2
@


1.74
log
@two fairly simple sizes for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.73 2015/03/14 03:38:46 jsg Exp $	*/
d593 2
a594 2
	for (i = iskip; i < crda->crd_len; i += blksz) {
		len = MIN(crda->crd_len - i, blksz - oskip);
d596 2
a597 2
		bzero(blk + len + oskip, blksz - len - oskip);
		axf->Update(&ctx, blk, blksz);
d626 1
a626 1
			bzero(blk, blksz);
d631 1
a631 1
			axf->Update(&ctx, blk, blksz);
@


1.73
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.72 2014/12/28 10:02:37 tedu Exp $	*/
d676 1
a676 1
	free(data, M_CRYPTO_DATA, 0);
d767 2
a768 1
			free(swcr_sessions, M_CRYPTO_DATA, 0);
@


1.72
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.71 2014/07/13 23:24:47 deraadt Exp $	*/
a33 1
#include <crypto/blf.h>
@


1.71
log
@use mallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.70 2014/07/12 18:50:00 tedu Exp $	*/
a467 9
	case CRYPTO_MD5_KPDK:
	case CRYPTO_SHA1_KPDK:
		if (sw->sw_octx == NULL)
			return EINVAL;

		axf->Update(&ctx, sw->sw_octx, sw->sw_klen);
		axf->Final(aalg, &ctx);
		break;

a888 31
		case CRYPTO_MD5_KPDK:
			axf = &auth_hash_key_md5;
			goto auth2common;

		case CRYPTO_SHA1_KPDK:
			axf = &auth_hash_key_sha1;
		auth2common:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			/* Store the key so we can "append" it to the payload */
			(*swd)->sw_octx = malloc(cri->cri_klen / 8, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_octx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			(*swd)->sw_klen = cri->cri_klen / 8;
			bcopy(cri->cri_key, (*swd)->sw_octx, cri->cri_klen / 8);
			axf->Init((*swd)->sw_ictx);
			axf->Update((*swd)->sw_ictx, cri->cri_key,
			    cri->cri_klen / 8);
			axf->Final(NULL, (*swd)->sw_ictx);
			(*swd)->sw_axf = axf;
			break;

a1007 14
		case CRYPTO_MD5_KPDK:
		case CRYPTO_SHA1_KPDK:
			axf = swd->sw_axf;

			if (swd->sw_ictx) {
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
				free(swd->sw_ictx, M_CRYPTO_DATA, 0);
			}
			if (swd->sw_octx) {
				explicit_bzero(swd->sw_octx, swd->sw_klen);
				free(swd->sw_octx, M_CRYPTO_DATA, 0);
			}
			break;

a1100 2
		case CRYPTO_MD5_KPDK:
		case CRYPTO_SHA1_KPDK:
a1160 2
	algs[CRYPTO_MD5_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.70
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.69 2013/08/25 14:26:56 jsing Exp $	*/
d762 1
a762 1
		swd = malloc(swcr_sesnum * sizeof(struct swcr_data *),
@


1.69
log
@Allocate and deallocate memory for encryption contexts within cryptosoft,
rather than requiring each algorithm to provide their own memory handling.
This matches the interface already provided by cryptosoft for
authentication algorithms and removes the need for zerokey functions.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.67 2012/12/07 20:55:51 mikeb Exp $	*/
d686 1
a686 1
	free(data, M_CRYPTO_DATA);
d698 1
a698 1
			free(out, M_CRYPTO_DATA);
d729 1
a729 1
	free(out, M_CRYPTO_DATA);
d777 1
a777 1
			free(swcr_sessions, M_CRYPTO_DATA);
d1026 1
a1026 1
				free(swd->sw_kschedule, M_CRYPTO_DATA);
d1040 1
a1040 1
				free(swd->sw_ictx, M_CRYPTO_DATA);
d1044 1
a1044 1
				free(swd->sw_octx, M_CRYPTO_DATA);
d1054 1
a1054 1
				free(swd->sw_ictx, M_CRYPTO_DATA);
d1058 1
a1058 1
				free(swd->sw_octx, M_CRYPTO_DATA);
d1071 1
a1071 1
				free(swd->sw_ictx, M_CRYPTO_DATA);
d1076 1
a1076 1
		free(swd, M_CRYPTO_DATA);
@


1.68
log
@Bring back a small copy optimization in the aes-gcm handling:
with ESN AAD is 12 bytes long so it's faster to zero out 4
bytes than to copy 12.  Without ESN it's either copying or
zeroing out 8 bytes but we'll rely on the cache locality here.
@
text
@d827 9
a835 1
			if (txf->setkey(&((*swd)->sw_kschedule), cri->cri_key,
d1024 4
a1027 2
			if (swd->sw_kschedule)
				txf->zerokey(&(swd->sw_kschedule));
@


1.67
log
@RFC 4106, Section 5 states that the SPI and a 64-bit Sequence
Number are provided to the GCM as an Additional Authenticated
Data.  Usually an SPI and a lower 32-bit part of the ESN are
contained within the same memory buffer whereas an upper part
of the ESN comes from an external location.  To accommodate
that RFC 4303, Section 3.3.2.1 states that upper part of the
ESN is hashed in the end.  Unfortunately this advice is not
applicable for the combined authentication/encryption modes
and RFC 4106 decided not to follow that advice, effectively
requiring large API changes to accommodate that poor choice.
For now implement a kludge that will take an effect in case
CRD_F_ESN flag is set in the crypto operation descriptor.
Successfully tested against Linux 3.2 with strongSwan 4.6.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.66 2012/12/07 17:03:22 mikeb Exp $	*/
d606 2
a607 1
		axf->Update(&ctx, blk, len + oskip);
@


1.66
log
@Fix one of the two issues with ESN support in the GCM case:
supply correct AAD length to the final round of hashing.
While here rename swcr_combined to swcr_authenc.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.65 2012/10/04 13:17:12 haesbaert Exp $	*/
d511 1
a511 1
	int aadlen, blksz, i, ivlen, outtype, left, len;
d513 1
a513 1
	ivlen = blksz = 0;
d585 10
a594 1
	if (crda->crd_flags & CRD_F_ESN)
d596 12
a607 13
	for (i = 0; i < aadlen; i += blksz) {
		len = 0;
		if (i < crda->crd_len) {
			len = MIN(crda->crd_len - i, blksz);
			COPYDATA(outtype, buf, crda->crd_skip + i, len, blk);
		}
		left = blksz - len;
		if (crda->crd_flags & CRD_F_ESN && left > 0) {
			bcopy(crda->crd_esn, blk + len, MIN(left, aadlen - i));
			len += MIN(left, aadlen - i);
		}
		bzero(blk + len, blksz - len);
		axf->Update(&ctx, blk, blksz);
@


1.65
log
@Clean up uninitialized warnings from cryptosoft and aesni.
Part of the work to remove -Wno-uninitialized.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.64 2012/06/29 14:48:04 mikeb Exp $	*/
d496 1
a496 1
swcr_combined(struct cryptop *crp)
d629 1
a629 1
			*blkp = htobe32(crda->crd_len * 8);
d1150 1
a1150 1
			crp->crp_etype = swcr_combined(crp);
@


1.64
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.63 2011/01/11 23:00:21 markus Exp $	*/
d504 1
a504 1
	struct swcr_data *sw, *swa, *swe;
d512 2
@


1.63
log
@fix encryption for uio_iovcnt > 1 by passing the absolute offset 'count'
to cuio_copydata() and make sure we don't loop forever if the end of
an iov matches the cipher block boundary.
ok mikeb, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.62 2011/01/11 16:04:19 deraadt Exp $	*/
d449 3
d511 1
a511 1
	int i, blksz, ivlen, outtype, len;
d582 16
a597 4
	for (i = 0; i < crda->crd_len; i += blksz) {
		len = MIN(crda->crd_len - i, blksz);
		COPYDATA(outtype, buf, crda->crd_skip + i, len, blk);
		axf->Update(&ctx, blk, len);
d955 3
d1213 1
@


1.62
log
@add explicit_bzero() calls before free()ing key material
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.61 2011/01/11 15:46:47 deraadt Exp $	*/
d296 1
a296 1
				cuio_copydata(uio, k, blks, blk);
d337 1
a337 1
				cuio_copyback(uio, k, blks, blk);
d397 13
@


1.61
log
@accidental commit of a pending diff relating to something else
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.59 2010/12/22 00:55:45 deraadt Exp $	*/
d987 1
a987 1
				bzero(swd->sw_ictx, axf->ctxsize);
d991 1
a991 1
				bzero(swd->sw_octx, axf->ctxsize);
d1001 1
a1001 1
				bzero(swd->sw_ictx, axf->ctxsize);
d1005 1
a1005 1
				bzero(swd->sw_octx, swd->sw_klen);
d1018 1
a1018 1
				bzero(swd->sw_ictx, axf->ctxsize);
@


1.60
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d296 1
a296 1
				cuio_copydata(uio, count, blks, blk);
d337 1
a337 1
				cuio_copyback(uio, count, blks, blk);
a397 13

			/*
			 * Advance to the next iov if the end of the current iov
			 * is aligned with the end of a cipher block.
			 * Note that the code is equivalent to calling:
			 *	ind = cuio_getptr(uio, count, &k);
			 */
			if (i > 0 && k == uio->uio_iov[ind].iov_len) {
				k = 0;
				ind++;
				if (ind >= uio->uio_iovcnt)
					return (EINVAL);
			}
d987 1
a987 1
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
d991 1
a991 1
				explicit_bzero(swd->sw_octx, axf->ctxsize);
d1001 1
a1001 1
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
d1005 1
a1005 1
				explicit_bzero(swd->sw_octx, swd->sw_klen);
d1018 1
a1018 1
				explicit_bzero(swd->sw_ictx, axf->ctxsize);
@


1.59
log
@use the do {} while construct in the copying macros
ok mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.58 2010/12/21 22:24:21 markus Exp $	*/
d296 1
a296 1
				cuio_copydata(uio, k, blks, blk);
d337 1
a337 1
				cuio_copyback(uio, k, blks, blk);
d398 13
d1000 1
a1000 1
				bzero(swd->sw_ictx, axf->ctxsize);
d1004 1
a1004 1
				bzero(swd->sw_octx, axf->ctxsize);
d1014 1
a1014 1
				bzero(swd->sw_ictx, axf->ctxsize);
d1018 1
a1018 1
				bzero(swd->sw_octx, swd->sw_klen);
d1031 1
a1031 1
				bzero(swd->sw_ictx, axf->ctxsize);
@


1.58
log
@remove dead code (ivp did always point to iv in the decrypt path).
instead save one bcopy() per block by alternating between two iv buffers;
ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.57 2010/10/06 22:19:20 mikeb Exp $	*/
d83 6
a88 2
	(x) == CRYPTO_BUF_MBUF ? m_copyback((struct mbuf *)a,b,c,d,M_NOWAIT) \
	: cuio_copyback((struct uio *)a,b,c,d)
d90 6
a95 2
	(x) == CRYPTO_BUF_MBUF ? m_copydata((struct mbuf *)a,b,c,d) \
	: cuio_copydata((struct uio *)a,b,c,d)
d133 1
a133 1
		if (!(crd->crd_flags & CRD_F_IV_PRESENT)) {
a134 1
		}
d548 1
a548 1
		if (!(crde->crd_flags & CRD_F_IV_PRESENT)) {
a549 1
		}
@


1.57
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.56 2010/10/06 10:00:59 mikeb Exp $	*/
d97 1
a97 1
	unsigned char *ivp, piv[EALG_MAX_BLOCK_LEN];
d191 2
a192 4
					if (ivp == iv)
						bcopy(blk, piv, blks);
					else
						bcopy(blk, iv, blks);
d199 1
a199 5

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
d257 2
a258 4
					if (ivp == iv)
						bcopy(idat, piv, blks);
					else
						bcopy(idat, iv, blks);
d265 1
a265 5

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
d318 2
a319 4
					if (ivp == iv)
						bcopy(blk, piv, blks);
					else
						bcopy(blk, iv, blks);
d326 1
a326 5

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
d375 2
a376 4
					if (ivp == iv)
						bcopy(idat, piv, blks);
					else
						bcopy(idat, iv, blks);
d383 1
a383 5

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
@


1.56
log
@zero out auth hash context before freeing it;  ok matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.55 2010/09/22 11:54:23 mikeb Exp $	*/
a33 1
#include <crypto/skipjack.h>
a785 3
		case CRYPTO_SKIPJACK_CBC:
			txf = &enc_xform_skipjack;
			goto enccommon;
a983 1
		case CRYPTO_SKIPJACK_CBC:
a1107 1
		case CRYPTO_SKIPJACK_CBC:
a1179 1
	algs[CRYPTO_SKIPJACK_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.55
log
@OCF support for the Galois/Counter Mode (GCM) for AES as
described in FIPS SP 800-38D.

This implementation supports 16 byte authentication tag only,
splitting transformation into two parts: encryption and
authentication.  Encryption is handled by the existing
AES-CTR implementation, while authentication requires new
AES_GMAC hash function.

Additional routine is added to the software crypto driver
to deal with peculiarities of a combined authentication-
encryption transformation.

With suggestions from reyk, naddy and toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.54 2010/07/02 02:40:15 blambert Exp $	*/
d1040 2
a1041 1
			if (swd->sw_ictx)
d1043 1
@


1.54
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.53 2010/04/20 22:05:41 tedu Exp $	*/
d495 143
d799 7
d922 23
d992 2
d1033 3
d1134 8
d1195 2
d1202 3
@


1.53
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.52 2010/01/10 12:43:07 markus Exp $	*/
d84 1
a84 1
	(x) == CRYPTO_BUF_MBUF ? m_copyback((struct mbuf *)a,b,c,d) \
d210 1
a210 1
				m_copyback(m, k, blks, blk);
@


1.52
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.51 2008/06/09 16:07:00 djm Exp $	*/
a27 1
#include <sys/sysctl.h>
@


1.51
log
@Implement the AES XTS mode of operation for the crypto(9) framework.
XTS is a "tweaked" AES mode that has properties that are desirable
for block device encryption and it is specified in the IEEE
P1619-2007 standard for this purpose.

prodded by & ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.50 2008/06/09 07:07:15 djm Exp $	*/
d41 9
a49 1
const u_int8_t hmac_ipad_buffer[64] = {
d60 9
a68 1
const u_int8_t hmac_opad_buffer[64] = {
d679 1
a679 1
			axf = &auth_hash_hmac_sha2_256_96;
d682 1
a682 1
			axf = &auth_hash_hmac_sha2_384_96;
d685 1
a685 1
			axf = &auth_hash_hmac_sha2_512_96;
d708 1
a708 1
			    HMAC_BLOCK_LEN - (cri->cri_klen / 8));
d717 1
a717 1
			    HMAC_BLOCK_LEN - (cri->cri_klen / 8));
@


1.50
log
@rename arc4random_bytes => arc4random_buf to match libc's nicer name;
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.49 2007/09/15 11:00:51 hshoexer Exp $	*/
d127 4
d152 7
a158 1
					exf->encrypt(sw->sw_kschedule, blk);
d230 7
a236 1
					exf->encrypt(sw->sw_kschedule, idat);
d291 7
a297 1
					exf->encrypt(sw->sw_kschedule, blk);
d360 7
a366 1
					exf->encrypt(sw->sw_kschedule, idat);
d638 3
d803 1
d921 1
d993 1
@


1.49
log
@fix error introduced by my previous commit:

	"MALLOC(*swd, ...)" vs. "swd = malloc(..."

ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.48 2007/09/13 21:26:41 hshoexer Exp $	*/
d108 1
a108 1
			arc4random_bytes(iv, ivlen);
@


1.48
log
@Here too:  Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

error spotting and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.47 2007/09/10 22:19:42 henric Exp $	*/
d581 1
a581 1
		swd = malloc(sizeof(struct swcr_data), M_CRYPTO_DATA,
@


1.47
log
@Make the hmac ipad/opad globals "const" and fixup the crypto functions
to match.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.46 2006/12/29 13:04:37 pedro Exp $	*/
d470 1
a470 1
	MALLOC(data, u_int8_t *, crd->crd_len, M_CRYPTO_DATA,  M_NOWAIT);
d480 1
a480 1
	FREE(data, M_CRYPTO_DATA);
d492 1
a492 1
			FREE(out, M_CRYPTO_DATA);
d523 1
a523 1
	FREE(out, M_CRYPTO_DATA);
d557 1
a557 1
		    M_CRYPTO_DATA, M_NOWAIT);
a566 2
		bzero(swd, swcr_sesnum * sizeof(struct swcr_data *));

d581 2
a582 2
		MALLOC(*swd, struct swcr_data *, sizeof(struct swcr_data),
		    M_CRYPTO_DATA, M_NOWAIT);
a586 1
		bzero(*swd, sizeof(struct swcr_data));
d820 1
a820 1
		FREE(swd, M_CRYPTO_DATA);
@


1.46
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.45 2005/05/25 05:47:53 markus Exp $	*/
d41 1
a41 1
u_int8_t hmac_ipad_buffer[64] = {
d52 1
a52 1
u_int8_t hmac_opad_buffer[64] = {
@


1.45
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.44 2005/05/10 13:42:11 markus Exp $	*/
d333 1
a333 1
			idat = uio->uio_iov[ind].iov_base + k;
@


1.44
log
@support NULL encryption for ESP; ok hshoexer, ho
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.43 2005/05/02 22:19:10 markus Exp $	*/
d85 1
a85 1
	int i, k, j, blks, ind, count;
a88 1

d91 1
a96 3
	if (exf == &enc_xform_null)
		return (0);

d106 1
a106 1
			bcopy(crd->crd_iv, iv, blks);
d108 1
a108 1
			arc4random_bytes(iv, blks);
d112 1
a112 1
			COPYBACK(outtype, buf, crd->crd_inject, blks, iv);
d118 1
a118 1
			bcopy(crd->crd_iv, iv, blks);
d121 1
a121 1
			COPYDATA(outtype, buf, crd->crd_inject, blks, iv);
d127 3
d147 3
a149 1
				if (crd->crd_flags & CRD_F_ENCRYPT) {
d219 3
a221 1
				if (crd->crd_flags & CRD_F_ENCRYPT) {
d274 3
a276 1
				if (crd->crd_flags & CRD_F_ENCRYPT) {
d337 3
a339 1
				if (crd->crd_flags & CRD_F_ENCRYPT) {
d610 3
d774 1
d883 2
d891 1
a891 1
		case CRYPTO_NULL:
d962 1
@


1.43
log
@simplify by using arc4random_bytes(), ok djm, hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.42 2004/12/20 20:31:18 hshoexer Exp $	*/
d96 3
@


1.42
log
@Allow the setkey function of a transform to fail, eg. when an insufficient
number of key bits is supplied.

Only AES and DES/3DES might fail.

ok and help markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.41 2004/05/07 14:42:26 millert Exp $	*/
d107 2
a108 21
		else {
			/* Get random IV */
			for (i = 0;
			    i + sizeof (u_int32_t) < EALG_MAX_BLOCK_LEN;
			    i += sizeof (u_int32_t)) {
				u_int32_t temp = arc4random();

				bcopy(&temp, iv + i, sizeof(u_int32_t));
			}
			/*
			 * What if the block size is not a multiple
			 * of sizeof (u_int32_t), which is the size of
			 * what arc4random() returns ?
			 */
			if (EALG_MAX_BLOCK_LEN % sizeof (u_int32_t) != 0) {
				u_int32_t temp = arc4random();

				bcopy (&temp, iv + i,
				    EALG_MAX_BLOCK_LEN - i);
			}
		}
@


1.41
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.40 2004/04/14 20:03:05 markus Exp $	*/
d622 5
a626 2
			txf->setkey(&((*swd)->sw_kschedule), cri->cri_key,
			    cri->cri_klen / 8);
@


1.40
log
@leak; vgirish at tenet.res.in; via angelos; ok hshoexer, henning, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.39 2003/07/24 08:03:19 itojun Exp $	*/
a29 1
#include <sys/md5k.h>
d31 1
@


1.39
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.38 2003/02/21 20:33:35 jason Exp $	*/
d786 3
@


1.38
log
@There's no cleaning necessary for deflate compression, so remove it from
the switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.37 2002/11/21 19:34:25 jason Exp $	*/
d423 3
d635 9
d895 3
d960 3
@


1.37
log
@From Angelos:
- simplistic load balancing across multiple cards
- simplified registration process
- a few style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.36 2002/11/12 18:23:13 jason Exp $	*/
a743 1
	struct comp_algo *cxf;
a805 4
			break;

		case CRYPTO_DEFLATE_COMP:
			cxf = swd->sw_cxf;
@


1.36
log
@Add a CRYPTO_NULL xform (it's a do nothing, but nice for measuring the
bandwidth of the kernel API).  It's only available from userland and
then only if kern.cryptodevallowsoft=1.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.35 2002/04/26 08:43:50 deraadt Exp $	*/
d923 5
a927 1
	swcr_id = crypto_get_driverid(CRYPTOCAP_F_SOFTWARE);
d933 19
a951 1
	crypto_register(swcr_id, CRYPTO_DES_CBC, 0, 0, swcr_newsession,
a952 28
	crypto_register(swcr_id, CRYPTO_3DES_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_BLF_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_CAST_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5_KPDK, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1_KPDK, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_DEFLATE_COMP, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_NULL, 0, 0,
	    NULL, NULL, NULL);
@


1.35
log
@minor tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.34 2002/04/22 23:10:09 deraadt Exp $	*/
d615 3
d765 1
d880 1
d956 2
@


1.34
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.33 2002/04/03 23:22:36 fgsch Exp $	*/
d828 1
a828 1
	return EINVAL;
d919 33
a951 34
	if (swcr_id >= 0) {
		crypto_register(swcr_id, CRYPTO_DES_CBC, 0, 0, swcr_newsession,
		    swcr_freesession, swcr_process);
		crypto_register(swcr_id, CRYPTO_3DES_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_BLF_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_CAST_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_KPDK, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_KPDK, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_DEFLATE_COMP, 0, 0,
		    NULL, NULL, NULL);
		return;
	}

	/* This should never happen */
	panic("Software crypto device cannot initialize!");
@


1.33
log
@fix possible alignment problem; with markus@@, angelos@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.32 2002/03/19 23:24:53 angelos Exp $	*/
d15 1
a15 1
 * modification of this software. 
d42 7
a48 7
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
d177 1
a177 1
					/*	
d300 1
a300 1
					/*	
d323 1
a323 1
			       
d452 1
a452 1
	
d467 1
a467 1
   
d474 1
a474 1
       
d479 1
a479 1
	
d484 1
a484 1
    
d489 1
a489 1
	/* Copy back the (de)compressed data. m_copyback is 
d501 1
a501 1
	
d620 1
a620 1
	
d636 1
a636 1
	
d643 1
a643 1
	
d646 1
a646 1
	
d652 1
a652 1
	
d655 1
a655 1
	
d661 1
a661 1
	
d666 1
a666 1
	
d670 1
a670 1
	
d680 1
a680 1
	
d688 1
a688 1
	
d701 1
a701 1
	
d711 1
a711 1
	
d724 1
a724 1
	
d893 1
a893 1
			if ((crp->crp_etype = swcr_compdec(crd, sw, 
@


1.32
log
@Don't keep the last blocksize-bytes of ciphertext for use as the next
plaintext's IV, in CBC mode. Use arc4random() to acquire fresh IVs per
message instead (particularly useful for IPsec).

This avoids the CBC oracle attack. provos@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.31 2002/03/05 15:59:41 markus Exp $	*/
d111 5
a115 2
			    i += sizeof (u_int32_t))
				*((u_int32_t *) (iv + i)) = arc4random();
@


1.31
log
@export MD5/SHA1 via /dev/crypto; ok provos@@, beck@@
tested with cryptosoft and kern.cryptodevallowsoft=1
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.30 2002/03/01 02:50:02 provos Exp $	*/
d108 16
a123 2
			/* Use IV from context */
			bcopy(sw->sw_iv, iv, blks);
a380 4
	/* Keep the last block */
	if (crd->crd_flags & CRD_F_ENCRYPT)
		bcopy(ivp, sw->sw_iv, blks);

a614 5
			(*swd)->sw_iv = malloc(txf->blocksize, M_CRYPTO_DATA, M_NOWAIT);
			if ((*swd)->sw_iv == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
a615 1
			get_random_bytes((*swd)->sw_iv, txf->blocksize);
a762 2
			if (swd->sw_iv)
				free(swd->sw_iv, M_CRYPTO_DATA);
@


1.30
log
@remove CRYPTO_BUF_CONTIG and convert to handle iovs. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.29 2001/11/09 03:11:38 deraadt Exp $	*/
d378 2
a379 2
swcr_authcompute(struct cryptodesc *crd, struct swcr_data *sw,
    caddr_t buf, int outtype)
d427 5
d435 5
a439 1
	COPYBACK(outtype, buf, crd->crd_inject, axf->authsize, aalg);
d691 18
d792 8
d880 3
a882 1
			if ((crp->crp_etype = swcr_authcompute(crd, sw,
d934 4
@


1.29
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.28 2001/08/08 15:12:09 jjbg Exp $	*/
d68 7
d85 4
a88 2
	int i, k, j, blks;
	struct mbuf *m;
d97 4
a100 5
	if (outtype == CRYPTO_BUF_CONTIG) {
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, sw->sw_iv, blks);
d102 9
a110 14
			if (!(crd->crd_flags & CRD_F_IV_PRESENT))
				bcopy(sw->sw_iv, buf + crd->crd_inject, blks);

			for (i = crd->crd_skip;
			    i < crd->crd_skip + crd->crd_len; i += blks) {
				/* XOR with the IV/previous block, as appropriate. */
				if (i == crd->crd_skip)
					for (k = 0; k < blks; k++)
						buf[i + k] ^= sw->sw_iv[k];
				else
					for (k = 0; k < blks; k++)
						buf[i + k] ^= buf[i + k - blks];
				exf->encrypt(sw->sw_kschedule, buf + i);
			}
d112 3
a114 26
			/* Keep the last block */
			bcopy(buf + crd->crd_len - blks, sw->sw_iv, blks);

		} else {		/* Decrypt */
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, sw->sw_iv, blks);
			else /* IV preceeds data */
				bcopy(buf + crd->crd_inject, sw->sw_iv, blks);

			/*
			 * Start at the end, so we don't need to keep the encrypted
			 * block as the IV for the next block.
			 */
			for (i = crd->crd_skip + crd->crd_len - blks;
			    i >= crd->crd_skip; i -= blks) {
				exf->decrypt(sw->sw_kschedule, buf + i);

				/* XOR with the IV/previous block, as appropriate */
				if (i == crd->crd_skip)
					for (k = 0; k < blks; k++)
						buf[i + k] ^= sw->sw_iv[k];
				else
					for (k = 0; k < blks; k++)
						buf[i + k] ^= buf[i + k - blks];
			}
a115 17
		return 0;
	} else {
		m = (struct mbuf *) buf;

		/* Initialize the IV */
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, iv, blks);
			else {
				/* Use IV from context */
				bcopy(sw->sw_iv, iv, blks);
			}

			/* Do we need to write the IV */
			if (!(crd->crd_flags & CRD_F_IV_PRESENT))
				m_copyback(m, crd->crd_inject, blks, iv);
d117 1
a117 1
		} else {	/* Decryption */
d119 5
a123 6
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, iv, blks);
			else {
				/* Get IV off mbuf */
				m_copydata(m, crd->crd_inject, blks, iv);
			}
d125 1
d127 1
a127 1
		ivp = iv;
d129 1
d215 1
a215 1
	   		while (m->m_len >= k + blks && i > 0) {
d250 23
d274 19
a292 3
		/* Keep the last block */
		if (crd->crd_flags & CRD_F_ENCRYPT)
			bcopy(ivp, sw->sw_iv, blks);
d294 71
a364 1
		return 0; /* Done with mbuf encryption/decryption */
d367 5
a371 2
	/* Unreachable */
	return EINVAL;
d393 1
a393 3
	if (outtype == CRYPTO_BUF_CONTIG)
		axf->Update(&ctx, buf + crd->crd_skip, crd->crd_len);
	else {
d397 8
a404 3
		if (err)
			return err;
	}
d430 1
a430 5
	if (outtype == CRYPTO_BUF_CONTIG)
		bcopy(aalg, buf + crd->crd_inject, axf->authsize);
	else
		m_copyback((struct mbuf *) buf, crd->crd_inject,
		    axf->authsize, aalg);
d443 1
a443 1
	int k, adj;
a444 1
	struct mbuf *m, *m1;
d448 4
a451 18
	if (outtype == CRYPTO_BUF_CONTIG) {
		if (crd->crd_flags & CRD_F_COMP)
			result = cxf->compress(buf + crd->crd_skip, 
			    crd->crd_len, &out);
		else
			result = cxf->decompress(buf + crd->crd_skip, 
			    crd->crd_len, &out);
	} else { /* mbuf */
		m = (struct mbuf *)buf;
	
		/* Find beginning of data */
		m1 = m_getptr(m, crd->crd_skip, &k);
		if (m1 == NULL)
		return EINVAL;
		/* We must handle the whole buffer of data in one time
		 * then if there is not all the data in the mbuf, we must
		 * copy in a buffer.
		 */
d453 4
a456 5
		MALLOC(data, u_int8_t *, crd->crd_len, M_CRYPTO_DATA, 
		       M_NOWAIT);
		if (data == NULL)
			return EINVAL;
		m_copydata(m1, k, crd->crd_len, data);
d458 4
a461 5
		if (crd->crd_flags & CRD_F_COMP)
			result = cxf->compress(data, crd->crd_len, &out);
		else
			result = cxf->decompress(data, crd->crd_len, &out);
	}
d463 14
a476 11
	if (outtype == CRYPTO_BUF_CONTIG) {
		if (result == 0)
			return EINVAL;
		sw->sw_size = result;
		/* Check the compressed size when doing compression */
		if (crd->crd_flags & CRD_F_COMP) {
			if (result > crd->crd_len) {
				/* Compression was useless, we lost time */
				FREE(out, M_CRYPTO_DATA);
				return 0;
			}
d478 25
a502 17
		buf = out;
		/* Don't forget to FREE buf later */
		return 0;
	} else {
		FREE(data, M_CRYPTO_DATA);
		if (result == 0)
			return EINVAL;
		/* Copy back the (de)compressed data. m_copyback is 
		 * extending the mbuf as necessary.
		 */
		sw->sw_size = result;
		/* Check the compressed size when doing compression */
		if (crd->crd_flags & CRD_F_COMP) {
			if (result > crd->crd_len) {
				/* Compression was useless, we lost time */
				FREE(out, M_CRYPTO_DATA);
				return 0;
a504 7
		m_copyback(m1, k, result, out);
		if (result < crd->crd_len) {
			adj = result - crd->crd_len;
			m_adj(m, adj);
		}
		FREE(out, M_CRYPTO_DATA);
		return 0;
d506 2
a507 3
    
	/* Unreachable */
	return EINVAL;
d804 1
a804 1
		type = CRYPTO_BUF_CONTIG;
@


1.28
log
@remove IPCOMP. derradt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.27 2001/07/05 17:53:28 deraadt Exp $	*/
d815 1
a815 1
	swcr_id = crypto_get_driverid();
@


1.27
log
@#ifdef IPCOMP stuff properly
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.26 2001/07/05 16:44:00 jjbg Exp $	*/
a457 1
#ifdef IPCOMP
a458 1
#endif
a620 1
#ifdef IPCOMP
a624 1
#endif
@


1.26
log
@Support for compression. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.25 2001/06/25 05:02:22 angelos Exp $	*/
d458 1
d460 1
d623 1
a625 3
			goto compcommon;

		compcommon:
d628 1
a628 1

@


1.25
log
@Update copyright; you can use this with or without fee (unless your
name is Theo Deraadt)
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.24 2001/06/23 21:00:49 angelos Exp $	*/
d360 90
d458 1
d620 9
a628 1
	
d650 1
d707 4
d793 8
d842 2
@


1.24
log
@New prototype for crypto_register(), to take into account maximum key
length (for PK operations) and various flags.

Structures for public key operations (DH, RSA, DSA). A lot of this
work was done by jgarfiel@@seas.upenn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.23 2001/06/23 18:30:36 deraadt Exp $	*/
d10 1
a10 1
 * Copyright (c) 2000 Angelos D. Keromytis
d12 1
a12 1
 * Permission to use, copy, and modify this software without fee
@


1.23
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.22 2001/06/16 22:17:49 deraadt Exp $	*/
d709 1
a709 1
		crypto_register(swcr_id, CRYPTO_DES_CBC, swcr_newsession,
d711 20
a730 10
		crypto_register(swcr_id, CRYPTO_3DES_CBC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_BLF_CBC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_CAST_CBC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_HMAC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_HMAC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_KPDK, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_KPDK, NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, NULL, NULL, NULL);
@


1.22
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.21 2001/06/06 04:37:07 angelos Exp $	*/
d37 1
a37 1
#include <crypto/crypto.h>
@


1.21
log
@Don't bother migrating software sessions, as this might lead to
session leakage.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.20 2001/05/15 02:40:35 deraadt Exp $	*/
d42 9
a50 8
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
    0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36 };
d53 9
a61 8
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
    0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C };
d73 1
a73 1
	    int outtype)
d75 5
a79 116
    unsigned char iv[EALG_MAX_BLOCK_LEN], blk[EALG_MAX_BLOCK_LEN], *idat;
    unsigned char *ivp, piv[EALG_MAX_BLOCK_LEN];
    struct enc_xform *exf;
    int i, k, j, blks;
    struct mbuf *m;

    exf = sw->sw_exf;
    blks = exf->blocksize;

    /* Check for non-padded data */
    if (crd->crd_len % blks)
      return EINVAL;

    if (outtype == CRYPTO_BUF_CONTIG)
    {
	if (crd->crd_flags & CRD_F_ENCRYPT)
	{
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, sw->sw_iv, blks);

	    if (!(crd->crd_flags & CRD_F_IV_PRESENT))
	      bcopy(sw->sw_iv, buf + crd->crd_inject, blks);

	    for (i = crd->crd_skip;
		 i < crd->crd_skip + crd->crd_len;
		 i += blks)
	    {
		/* XOR with the IV/previous block, as appropriate. */
		if (i == crd->crd_skip)
		  for (k = 0; k < blks; k++)
		    buf[i + k] ^= sw->sw_iv[k];
		else
		  for (k = 0; k < blks; k++)
		    buf[i + k] ^= buf[i + k - blks];

		exf->encrypt(sw->sw_kschedule, buf + i);
	    }

	    /* Keep the last block */
	    bcopy(buf + crd->crd_len - blks, sw->sw_iv, blks);
	}
	else /* Decrypt */
	{
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, sw->sw_iv, blks);
	    else /* IV preceeds data */
	      bcopy(buf + crd->crd_inject, sw->sw_iv, blks);

	    /*
	     * Start at the end, so we don't need to keep the encrypted
	     * block as the IV for the next block.
	     */
	    for (i = crd->crd_skip + crd->crd_len - blks;
		 i >= crd->crd_skip;
		 i -= blks)
	    {
		exf->decrypt(sw->sw_kschedule, buf + i);

		/* XOR with the IV/previous block, as appropriate */
		if (i == crd->crd_skip)
		  for (k = 0; k < blks; k++)
		    buf[i + k] ^= sw->sw_iv[k];
		else
		  for (k = 0; k < blks; k++)
		    buf[i + k] ^= buf[i + k - blks];
	    }
	}

	return 0; /* Done with contiguous buffer encryption/decryption */
    }
    else /* mbuf */
    {
	m = (struct mbuf *) buf;

	/* Initialize the IV */
	if (crd->crd_flags & CRD_F_ENCRYPT)
	{
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, iv, blks);
	    else
	      bcopy(sw->sw_iv, iv, blks); /* Use IV from context */

	    /* Do we need to write the IV */
	    if (!(crd->crd_flags & CRD_F_IV_PRESENT))
	      m_copyback(m, crd->crd_inject, blks, iv);
	}
	else /* Decryption */
	{
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, iv, blks);
	    else
	      m_copydata(m, crd->crd_inject, blks, iv); /* Get IV off mbuf */
	}

	ivp = iv;

	/* Find beginning of data */
	m = m_getptr(m, crd->crd_skip, &k);
	if (m == NULL)
	  return EINVAL;

	i = crd->crd_len;

	while (i > 0)
	{
	    /*
	     * If there's insufficient data at the end of an mbuf, we have
	     * to do some copying.
	     */
	    if ((m->m_len < k + blks) && (m->m_len != k))
	    {
		m_copydata(m, k, blks, blk);
d81 81
a161 31
		/* Actual encryption/decryption */
		if (crd->crd_flags & CRD_F_ENCRYPT)
		{
		    /* XOR with previous block */
		    for (j = 0; j < blks; j++)
		      blk[j] ^= ivp[j];

		    exf->encrypt(sw->sw_kschedule, blk);

		    /* Keep encrypted block for XOR'ing with next block */
		    bcopy(blk, iv, blks);
		    ivp = iv;
		}
		else /* decrypt */
		{
		    /* Keep encrypted block for XOR'ing with next block */
		    if (ivp == iv)
		      bcopy(blk, piv, blks);
		    else
		      bcopy(blk, iv, blks);

		    exf->decrypt(sw->sw_kschedule, blk);

		    /* XOR with previous block */
		    for (j = 0; j < blks; j++)
		      blk[j] ^= ivp[j];

		    if (ivp == iv)
		      bcopy(piv, iv, blks);
		    else
		      ivp = iv;
d164 1
a164 2
		/* Copy back decrypted block */
		m_copyback(m, k, blks, blk);
d166 2
a167 2
		/* Advance pointer */
		m = m_getptr(m, k + blks, &k);
d169 1
a169 1
		  return EINVAL;
d171 1
a171 1
		i -= blks;
d173 113
a285 23
		/* Could be done... */
		if (i == 0)
		  break;
	    }

	    /* Skip possibly empty mbufs */
	    if (k == m->m_len)
	    {
		for (m = m->m_next; m && m->m_len == 0; m = m->m_next)
		  ;

		k = 0;
	    }

	    /* Sanity check */
	    if (m == NULL)
	      return EINVAL;

	    /*
	     * Warning: idat may point to garbage here, but we only use it
	     * in the while() loop, only if there are indeed enough data.
	     */
	    idat = mtod(m, unsigned char *) + k;
d287 1
a287 2
	    while ((m->m_len >= k + blks) && (i > 0))
	    {
d289 1
a289 4
		{
		    /* XOR with previous block/IV */
		    for (j = 0; j < blks; j++)
		      idat[j] ^= ivp[j];
d291 1
a291 30
		    exf->encrypt(sw->sw_kschedule, idat);
		    ivp = idat;
		}
		else /* decrypt */
		{
		    /*
		     * Keep encrypted block to be used in next block's
		     * processing.
		     */
		    if (ivp == iv)
		      bcopy(idat, piv, blks);
		    else
		      bcopy(idat, iv, blks);

		    exf->decrypt(sw->sw_kschedule, idat);

		    /* XOR with previous block/IV */
		    for (j = 0; j < blks; j++)
		      idat[j] ^= ivp[j];

		    if (ivp == iv)
		      bcopy(piv, iv, blks);
		    else
		      ivp = iv;
		}

		idat += blks;
		k += blks;
		i -= blks;
	    }
d294 2
a295 9
	/* Keep the last block */
	if (crd->crd_flags & CRD_F_ENCRYPT)
	  bcopy(ivp, sw->sw_iv, blks);

	return 0; /* Done with mbuf encryption/decryption */
    }

    /* Unreachable */
    return EINVAL;
d303 1
a303 1
		 caddr_t buf, int outtype)
d305 11
a315 23
    unsigned char aalg[AALG_MAX_RESULT_LEN];
    struct auth_hash *axf;
    union authctx ctx;
    int err;

    if (sw->sw_ictx == 0)
      return EINVAL;

    axf = sw->sw_axf;

    bcopy(sw->sw_ictx, &ctx, axf->ctxsize);

    if (outtype == CRYPTO_BUF_CONTIG)
      axf->Update(&ctx, buf + crd->crd_skip, crd->crd_len);
    else
    {
	err = m_apply((struct mbuf *) buf, crd->crd_skip,
		      crd->crd_len,
		      (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		      (caddr_t) &ctx);
	if (err)
	  return err;
    }
d317 11
a327 2
    switch (sw->sw_alg)
    {
d331 13
a343 2
	    if (sw->sw_octx == NULL)
	      return EINVAL;
d345 4
a348 21
            axf->Final(aalg, &ctx);
	    bcopy(sw->sw_octx, &ctx, axf->ctxsize);
	    axf->Update(&ctx, aalg, axf->hashsize);
	    axf->Final(aalg, &ctx);
	    break;

        case CRYPTO_MD5_KPDK:
        case CRYPTO_SHA1_KPDK:
	    if (sw->sw_octx == NULL)
	      return EINVAL;

	    axf->Update(&ctx, sw->sw_octx, sw->sw_klen);
	    axf->Final(aalg, &ctx);
            break;
    }

    /* Inject the authentication data */
    if (outtype == CRYPTO_BUF_CONTIG)
      bcopy(aalg, buf + crd->crd_inject, axf->authsize);
    else
      m_copyback((struct mbuf *) buf, crd->crd_inject, axf->authsize, aalg);
d350 7
a356 1
    return 0;
d365 5
a369 23
    struct swcr_data **swd;
    struct auth_hash *axf;
    struct enc_xform *txf;
    u_int32_t i;
    int k;

    if ((sid == NULL) || (cri == NULL))
      return EINVAL;

    if (swcr_sessions)
      for (i = 1; i < swcr_sesnum; i++)
	if (swcr_sessions[i] == NULL)
	  break;

    if ((swcr_sessions == NULL) || (i == swcr_sesnum))
    {
	if (swcr_sessions == NULL)
	{
	    i = 1; /* We leave swcr_sessions[0] empty */
	    swcr_sesnum = CRYPTO_SW_SESSIONS;
	}
	else
	  swcr_sesnum *= 2;
d371 2
a372 40
	swd = malloc(swcr_sesnum * sizeof(struct swcr_data *),
		     M_CRYPTO_DATA, M_NOWAIT);
	if (swd == NULL)
	{
	    /* Reset session number */
	    if (swcr_sesnum == CRYPTO_SW_SESSIONS)
	      swcr_sesnum = 0;
	    else
	      swcr_sesnum /= 2;

	    return ENOBUFS;
	}

	bzero(swd, swcr_sesnum * sizeof(struct swcr_data *));

	/* Copy existing sessions */
	if (swcr_sessions)
	{
	    bcopy(swcr_sessions, swd,
		  (swcr_sesnum / 2) * sizeof(struct swcr_data *));
	    free(swcr_sessions, M_CRYPTO_DATA);
	}

	swcr_sessions = swd;
    }

    swd = &swcr_sessions[i];
    *sid = i;

    while (cri)
    {
	MALLOC(*swd, struct swcr_data *, sizeof(struct swcr_data),
	       M_CRYPTO_DATA, M_NOWAIT);
	if (*swd == NULL)
	{
	    swcr_freesession(i);
	    return ENOBUFS;
	}

	bzero(*swd, sizeof(struct swcr_data));
d374 69
a442 28
	switch (cri->cri_alg)
	{
	    case CRYPTO_DES_CBC:
		txf = &enc_xform_des;
		goto enccommon;

	    case CRYPTO_3DES_CBC:
		txf = &enc_xform_3des;
		goto enccommon;

	    case CRYPTO_BLF_CBC:
		txf = &enc_xform_blf;
		goto enccommon;

	    case CRYPTO_CAST_CBC:
		txf = &enc_xform_cast5;
		goto enccommon;

	    case CRYPTO_SKIPJACK_CBC:
		txf = &enc_xform_skipjack;
                goto enccommon;

	    case CRYPTO_RIJNDAEL128_CBC:
                txf = &enc_xform_rijndael128;
                goto enccommon;

	enccommon:
		txf->setkey(&((*swd)->sw_kschedule), cri->cri_key,
d444 37
a480 46
		(*swd)->sw_iv = malloc(txf->blocksize, M_CRYPTO_DATA,
				       M_NOWAIT);
		if ((*swd)->sw_iv == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		(*swd)->sw_exf = txf;

		get_random_bytes((*swd)->sw_iv, txf->blocksize);
		break;

	    case CRYPTO_MD5_HMAC:
		axf = &auth_hash_hmac_md5_96;
		goto authcommon;

	    case CRYPTO_SHA1_HMAC:
		axf = &auth_hash_hmac_sha1_96;
		goto authcommon;
		
	    case CRYPTO_RIPEMD160_HMAC:
		axf = &auth_hash_hmac_ripemd_160_96;

	authcommon:
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
					 M_NOWAIT);
		if ((*swd)->sw_ictx == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		(*swd)->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
					 M_NOWAIT);
		if ((*swd)->sw_octx == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		for (k = 0; k < cri->cri_klen / 8; k++)
		  cri->cri_key[k] ^= HMAC_IPAD_VAL;

		axf->Init((*swd)->sw_ictx);
		axf->Update((*swd)->sw_ictx, cri->cri_key,
d482 1
a482 1
		axf->Update((*swd)->sw_ictx, hmac_ipad_buffer,
d484 6
a489 6

		for (k = 0; k < cri->cri_klen / 8; k++)
		  cri->cri_key[k] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

		axf->Init((*swd)->sw_octx);
		axf->Update((*swd)->sw_octx, cri->cri_key,
d491 1
a491 1
		axf->Update((*swd)->sw_octx, hmac_opad_buffer,
d493 32
a524 37

		for (k = 0; k < cri->cri_klen / 8; k++)
		  cri->cri_key[k] ^= HMAC_OPAD_VAL;

		(*swd)->sw_axf = axf;
		break;

	    case CRYPTO_MD5_KPDK:
		axf = &auth_hash_key_md5;
		goto auth2common;

	    case CRYPTO_SHA1_KPDK:
		axf = &auth_hash_key_sha1;

	auth2common:
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
					 M_NOWAIT);
		if ((*swd)->sw_ictx == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		/* Store the key so we can "append" it to the payload */
		(*swd)->sw_octx = malloc(cri->cri_klen / 8, M_CRYPTO_DATA,
					 M_NOWAIT);
		if ((*swd)->sw_octx == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		(*swd)->sw_klen = cri->cri_klen / 8;
		bcopy(cri->cri_key, (*swd)->sw_octx, cri->cri_klen / 8);

		axf->Init((*swd)->sw_ictx);
		axf->Update((*swd)->sw_ictx, cri->cri_key,
d526 12
a537 8
		axf->Final(NULL, (*swd)->sw_ictx);

		(*swd)->sw_axf = axf;
		break;

	    default:
		swcr_freesession(i);
		return EINVAL;
d539 1
a539 7

	(*swd)->sw_alg = cri->cri_alg;
	cri = cri->cri_next;
	swd = &((*swd)->sw_next);
    }

    return 0;
d548 4
a551 26
    struct swcr_data *swd;
    struct enc_xform *txf;
    struct auth_hash *axf;
    u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;

    if ((sid > swcr_sesnum) || (swcr_sessions == NULL) ||
	(swcr_sessions[sid] == NULL))
      return EINVAL;

    /* Silently accept and return */
    if (sid == 0)
      return 0;

    while ((swd = swcr_sessions[sid]) != NULL)
    {
        swcr_sessions[sid] = swd->sw_next;

	switch (swd->sw_alg)
	{
	    case CRYPTO_DES_CBC:
	    case CRYPTO_3DES_CBC:
	    case CRYPTO_BLF_CBC:
	    case CRYPTO_CAST_CBC:
	    case CRYPTO_SKIPJACK_CBC:
	    case CRYPTO_RIJNDAEL128_CBC:
		txf = swd->sw_exf;
d553 3
a555 2
		if (swd->sw_kschedule)
		  txf->zerokey(&(swd->sw_kschedule));
d557 50
a606 30
		if (swd->sw_iv)
		  free(swd->sw_iv, M_CRYPTO_DATA);
		break;

	    case CRYPTO_MD5_HMAC:
	    case CRYPTO_SHA1_HMAC:
	    case CRYPTO_RIPEMD160_HMAC:
		axf = swd->sw_axf;

		if (swd->sw_ictx)
		{
		    bzero(swd->sw_ictx, axf->ctxsize);
		    free(swd->sw_ictx, M_CRYPTO_DATA);
		}

		if (swd->sw_octx)
		{
		    bzero(swd->sw_octx, axf->ctxsize);
		    free(swd->sw_octx, M_CRYPTO_DATA);
		}
		break;

	    case CRYPTO_MD5_KPDK:
	    case CRYPTO_SHA1_KPDK:
		axf = swd->sw_axf;

		if (swd->sw_ictx)
		{
		    bzero(swd->sw_ictx, axf->ctxsize);
		    free(swd->sw_ictx, M_CRYPTO_DATA);
d609 1
a609 6
		if (swd->sw_octx)
		{
		    bzero(swd->sw_octx, swd->sw_klen);
		    free(swd->sw_octx, M_CRYPTO_DATA);
		}
		break;
d611 1
a611 5

	FREE(swd, M_CRYPTO_DATA);
    }

    return 0;
d620 8
a627 64
    struct cryptodesc *crd;
    struct swcr_data *sw;
    u_int32_t lid;
    int type;

    /* Sanity check */
    if (crp == NULL)
      return EINVAL;

    if ((crp->crp_desc == NULL) || (crp->crp_buf == NULL))
    {
	crp->crp_etype = EINVAL;
	goto done;
    }

    lid = crp->crp_sid & 0xffffffff;
    if ((lid >= swcr_sesnum) || (lid == 0) || (swcr_sessions[lid] == NULL))
    {
	crp->crp_etype = ENOENT;
	goto done;
    }

    if (crp->crp_flags & CRYPTO_F_IMBUF)
      type = CRYPTO_BUF_MBUF;
    else
      type = CRYPTO_BUF_CONTIG;

    /* Go through crypto descriptors, processing as we go */
    for (crd = crp->crp_desc; crd; crd = crd->crd_next)
    {
	/*
	 * Find the crypto context.
	 *
	 * XXX Note that the logic here prevents us from having
	 * XXX the same algorithm multiple times in a session
	 * XXX (or rather, we can but it won't give us the right
	 * XXX results). To do that, we'd need some way of differentiating
	 * XXX between the various instances of an algorithm (so we can
	 * XXX locate the correct crypto context).
	 */
	for (sw = swcr_sessions[lid];
	     sw && sw->sw_alg != crd->crd_alg;
	     sw = sw->sw_next)
	  ;

	/* No such context ? */
	if (sw == NULL)
	{
	    crp->crp_etype = EINVAL;
	    goto done;
	}

	switch (sw->sw_alg)
	{
	    case CRYPTO_DES_CBC:
	    case CRYPTO_3DES_CBC:
	    case CRYPTO_BLF_CBC:
	    case CRYPTO_CAST_CBC:
	    case CRYPTO_SKIPJACK_CBC:
	    case CRYPTO_RIJNDAEL128_CBC:
		if ((crp->crp_etype = swcr_encdec(crd, sw, crp->crp_buf,
						  type)) != 0)
		  goto done;
		break;
d629 4
a632 9
	    case CRYPTO_MD5_HMAC:
	    case CRYPTO_SHA1_HMAC:
	    case CRYPTO_RIPEMD160_HMAC:
	    case CRYPTO_MD5_KPDK:
	    case CRYPTO_SHA1_KPDK:
		if ((crp->crp_etype = swcr_authcompute(crd, sw, crp->crp_buf,
						       type)) != 0)
		  goto done;
		break;
d634 3
a636 2
	    default:  /* Unknown/unsupported algorithm */
		crp->crp_etype = EINVAL;
a638 1
    }
d640 59
a698 3
 done:
    crypto_done(crp);
    return 0;
d707 16
a722 17
    swcr_id = crypto_get_driverid();
    if (swcr_id >= 0)
    {
	crypto_register(swcr_id, CRYPTO_DES_CBC, swcr_newsession,
                        swcr_freesession, swcr_process);
        crypto_register(swcr_id, CRYPTO_3DES_CBC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_BLF_CBC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_CAST_CBC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_MD5_HMAC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_SHA1_HMAC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_MD5_KPDK, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_SHA1_KPDK, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, NULL, NULL, NULL);
	return;
    }
d724 2
a725 2
    /* This should never happen */
    panic("Software crypto device cannot initialize!");
@


1.20
log
@fix $OpenBSD$ header
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a676 1
    u_int64_t nid;
a755 12
    if (crp->crp_etype == ENOENT)
    {
	crypto_freesession(crp->crp_sid); /* Just in case */

	/* Migrate session */
	for (crd = crp->crp_desc; crd->crd_next; crd = crd->crd_next)
	  crd->CRD_INI.cri_next = &(crd->crd_next->CRD_INI);

	if (crypto_newsession(&nid, &(crp->crp_desc->CRD_INI), 0) == 0)
	  crp->crp_sid = nid;
    }

@


1.19
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
@


1.18
log
@Use the M_CRYPTO_DATA and M_CRYPTO_OPS malloc types.
@
text
@d765 1
a765 1
	if (crypto_newsession(&nid, &(crp->crp_desc->CRD_INI)) == 0)
@


1.17
log
@*HMAC96->*HMAC
@
text
@d403 1
a403 1
		     M_XDATA, M_NOWAIT);
d422 1
a422 1
	    free(swcr_sessions, M_XDATA);
d433 2
a434 2
	MALLOC(*swd, struct swcr_data *, sizeof(struct swcr_data), M_XDATA,
	       M_NOWAIT);
d472 2
a473 1
		(*swd)->sw_iv = malloc(txf->blocksize, M_XDATA, M_NOWAIT);
d497 2
a498 1
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
d505 2
a506 1
		(*swd)->sw_octx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
d545 2
a546 1
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
d554 2
a555 1
		(*swd)->sw_octx = malloc(cri->cri_klen / 8, M_XDATA, M_NOWAIT);
d623 1
a623 1
		  free(swd->sw_iv, M_XDATA);
d634 1
a634 1
		    free(swd->sw_ictx, M_XDATA);
d640 1
a640 1
		    free(swd->sw_octx, M_XDATA);
d651 1
a651 1
		    free(swd->sw_ictx, M_XDATA);
d657 1
a657 1
		    free(swd->sw_octx, M_XDATA);
d662 1
a662 1
	FREE(swd, M_XDATA);
@


1.16
log
@indentation nits.
@
text
@d341 3
a343 3
	case CRYPTO_MD5_HMAC96:
	case CRYPTO_SHA1_HMAC96:
	case CRYPTO_RIPEMD160_HMAC96:
d484 1
a484 1
	    case CRYPTO_MD5_HMAC96:
d488 1
a488 1
	    case CRYPTO_SHA1_HMAC96:
d492 1
a492 1
	    case CRYPTO_RIPEMD160_HMAC96:
d621 3
a623 3
	    case CRYPTO_MD5_HMAC96:
	    case CRYPTO_SHA1_HMAC96:
	    case CRYPTO_RIPEMD160_HMAC96:
d735 3
a737 3
	    case CRYPTO_MD5_HMAC96:
	    case CRYPTO_SHA1_HMAC96:
	    case CRYPTO_RIPEMD160_HMAC96:
d783 3
a785 3
        crypto_register(swcr_id, CRYPTO_MD5_HMAC96, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_SHA1_HMAC96, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC96, NULL, NULL, NULL);
@


1.15
log
@Forgot to commit this, necessary for AES support.
@
text
@d465 1
a465 1
            case CRYPTO_RIJNDAEL128_CBC:
d611 1
a611 1
            case CRYPTO_RIJNDAEL128_CBC:
@


1.14
log
@MALLOC/FREE -> malloc/free ok art@@ angelos@@
@
text
@d463 5
d611 1
d729 1
@


1.13
log
@Fix KPDK mode (based on patch provided by lob@@netstream.se)
@
text
@d402 2
a403 2
	MALLOC(swd, struct swcr_data **,
	       swcr_sesnum * sizeof(struct swcr_data *), M_XDATA, M_NOWAIT);
d422 1
a422 1
	    FREE(swcr_sessions, M_XDATA);
d467 1
a467 2
		MALLOC((*swd)->sw_iv, u_int8_t *, txf->blocksize, M_XDATA,
		       M_NOWAIT);
d491 1
a491 2
		MALLOC((*swd)->sw_ictx, u_int8_t *, axf->ctxsize, M_XDATA,
		       M_NOWAIT);
d498 1
a498 2
		MALLOC((*swd)->sw_octx, u_int8_t *, axf->ctxsize, M_XDATA,
		       M_NOWAIT);
d537 1
a537 2
		MALLOC((*swd)->sw_ictx, u_int8_t *, axf->ctxsize, M_XDATA,
		       M_NOWAIT);
d545 1
a545 2
		MALLOC((*swd)->sw_octx, u_int8_t *, cri->cri_klen / 8,
		       M_XDATA, M_NOWAIT);
d612 1
a612 1
		  FREE(swd->sw_iv, M_XDATA);
d623 1
a623 1
		    FREE(swd->sw_ictx, M_XDATA);
d629 1
a629 1
		    FREE(swd->sw_octx, M_XDATA);
d640 1
a640 1
		    FREE(swd->sw_ictx, M_XDATA);
d646 1
a646 1
		    FREE(swd->sw_octx, M_XDATA);
@


1.12
log
@Use crypto_done()
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d328 1
a328 4
    {
	axf->Update(&ctx, buf + crd->crd_skip, crd->crd_len);
	axf->Final(aalg, &ctx);
    }
a336 2

	axf->Final(aalg, &ctx);
a338 1
    /* HMAC processing */
d347 1
d352 9
d548 12
d623 15
d650 1
a650 1
		    bzero(swd->sw_octx, axf->ctxsize);
@


1.11
log
@Register software Rijndael.
@
text
@d643 2
a644 2
    /* Some simple sanity checks */
    if ((crp == NULL) || (crp->crp_callback == NULL))
d731 2
a732 1
    return crp->crp_callback(crp);
@


1.10
log
@Add Rijndael (128-bit blocksize) in the software crypto driver.

Hacking at OpenBSD Crypto 2000 :-)
@
text
@d754 1
@


1.9
log
@OpenBSD tags
@
text
@d399 1
a399 1
	       swcr_sesnum * sizeof(struct swcr_data *), M_XDATA, M_DONTWAIT);
d430 1
a430 1
	       M_DONTWAIT);
d464 1
a464 1
		       M_DONTWAIT);
d489 1
a489 1
		       M_DONTWAIT);
d497 1
a497 1
		       M_DONTWAIT);
d537 1
a537 1
		       M_DONTWAIT);
@


1.8
log
@fix cleanup of crypto sessions
@
text
@d1 2
@


1.7
log
@Correct bitmask.
@
text
@d572 1
a572 1
    u_int32_t sid = (tid >> 31) & 0xffffffff;
@


1.6
log
@Change the type of freesession to take u_int64_t as argument.
@
text
@d572 1
a572 1
    u_int32_t sid = (tid >> 31) & 0xffff;
@


1.5
log
@Add a few newlines for readability.
@
text
@d567 1
a567 1
swcr_freesession(u_int32_t sid)
d572 1
@


1.4
log
@Better support for weird IV schemes (like ESP half-IV, or the swap
encryption block-number IV).
@
text
@d723 1
@


1.3
log
@Add CRD_F_IV_PRESENT, to indicate encryption requests where an
explicit IV preceeds the data to be encrypted.

Nice weather in Australia...
@
text
@d88 3
a90 9
	    /* Inject IV */
	    if (crd->crd_flags & CRD_F_HALFIV)
	    {
		if (crd->crd_flags & CRD_F_IV_PRESENT)
		  bcopy(buf + crd->crd_inject, sw->sw_iv, blks / 2);

		/* "Cook" half-IV */
		for (k = 0; k < blks / 2; k++)
		  sw->sw_iv[(blks / 2) + k] = ~sw->sw_iv[k];
d92 2
a93 9
	        bcopy(sw->sw_iv, buf + crd->crd_inject, blks / 2);
	    }
	    else
	    {
		if (crd->crd_flags & CRD_F_IV_PRESENT)
		  bcopy(buf + crd->crd_inject, sw->sw_iv, blks);
		else
		  bcopy(sw->sw_iv, buf + crd->crd_inject, blks);
	    }
d115 5
a119 7
	    /* Copy the IV off the buffer */
	    bcopy(buf + crd->crd_inject, sw->sw_iv, blks);

	    /* "Cook" half-IV */
	    if (crd->crd_flags & CRD_F_HALFIV)
	      for (k = 0; k < blks / 2; k++)
		sw->sw_iv[(blks / 2) + k] = ~sw->sw_iv[k];
d150 3
a152 2
	    if (crd->crd_flags & CRD_F_IV_PRESENT)
	      m_copydata(m, crd->crd_inject, blks, iv);
d154 1
a154 7
	      bcopy(sw->sw_iv, iv, blks);

	    /* "Cook" half-IV */
	    if (crd->crd_flags & CRD_F_HALFIV)
	    {
		for (k = 0; k < blks / 2; k++)
		  iv[(blks / 2) + k] = ~iv[k];
d156 3
a158 6
		if (!(crd->crd_flags & CRD_F_IV_PRESENT))
		  m_copyback(m, crd->crd_inject, blks / 2, iv);
	    }
	    else
	      if (!(crd->crd_flags & CRD_F_IV_PRESENT))
		m_copyback(m, crd->crd_inject, blks, iv);
d160 1
a160 1
	else
d162 5
a166 6
	    m_copydata(m, crd->crd_inject, blks, iv); /* Get IV off mbuf */

	    /* "Cook" half-IV */
	    if (crd->crd_flags & CRD_F_HALFIV)
	      for (k = 0; k < blks / 2; k++)
	        iv[(blks / 2) + k] = ~iv[k];
@


1.2
log
@move software crypto engine out of main crypto.c
@
text
@d91 3
d101 6
a106 1
	      bcopy(sw->sw_iv, buf + crd->crd_inject, blks);
d165 4
a168 1
	    bcopy(sw->sw_iv, iv, blks);
d172 3
a174 2
	      for (k = 0; k < blks / 2; k++)
	        iv[(blks / 2) + k] = ~iv[k];
d176 6
a181 2
	    /* Inject IV */
	    m_copyback(m, crd->crd_inject, blks, iv);
@


1.1
log
@split crypto driver front-end from software crypto engine
@
text
@d36 1
@


1.2.2.1
log
@Sync with -current
@
text
@@


1.2.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a0 2
/* $OpenBSD$ */

d88 6
a93 3
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, sw->sw_iv, blks);
d95 3
a97 1
	    if (!(crd->crd_flags & CRD_F_IV_PRESENT))
d120 7
a126 5
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, sw->sw_iv, blks);
	    else /* IV preceeds data */
	      bcopy(buf + crd->crd_inject, sw->sw_iv, blks);
d157 6
a162 5
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, iv, blks);
	    else
	      bcopy(sw->sw_iv, iv, blks); /* Use IV from context */
d164 2
a165 3
	    /* Do we need to write the IV */
	    if (!(crd->crd_flags & CRD_F_IV_PRESENT))
	      m_copyback(m, crd->crd_inject, blks, iv);
d167 1
a167 1
	else /* Decryption */
d169 6
a174 5
	    /* IV explicitly provided ? */
	    if (crd->crd_flags & CRD_F_IV_EXPLICIT)
	      bcopy(crd->crd_iv, iv, blks);
	    else
	      m_copydata(m, crd->crd_inject, blks, iv); /* Get IV off mbuf */
d334 4
a337 1
      axf->Update(&ctx, buf + crd->crd_skip, crd->crd_len);
d346 2
d350 1
d353 3
a355 3
	case CRYPTO_MD5_HMAC:
	case CRYPTO_SHA1_HMAC:
	case CRYPTO_RIPEMD160_HMAC:
a358 1
            axf->Final(aalg, &ctx);
a362 9

        case CRYPTO_MD5_KPDK:
        case CRYPTO_SHA1_KPDK:
	    if (sw->sw_octx == NULL)
	      return EINVAL;

	    axf->Update(&ctx, sw->sw_octx, sw->sw_klen);
	    axf->Final(aalg, &ctx);
            break;
d404 2
a405 2
	swd = malloc(swcr_sesnum * sizeof(struct swcr_data *),
		     M_XDATA, M_NOWAIT);
d424 1
a424 1
	    free(swcr_sessions, M_XDATA);
d436 1
a436 1
	       M_NOWAIT);
a464 5
                goto enccommon;

	    case CRYPTO_RIJNDAEL128_CBC:
                txf = &enc_xform_rijndael128;
                goto enccommon;
d469 2
a470 1
		(*swd)->sw_iv = malloc(txf->blocksize, M_XDATA, M_NOWAIT);
d482 1
a482 1
	    case CRYPTO_MD5_HMAC:
d486 1
a486 1
	    case CRYPTO_SHA1_HMAC:
d490 1
a490 1
	    case CRYPTO_RIPEMD160_HMAC:
d494 2
a495 1
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
d502 2
a503 1
		(*swd)->sw_octx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
d542 2
a543 1
		(*swd)->sw_ictx = malloc(axf->ctxsize, M_XDATA, M_NOWAIT);
a549 11
		/* Store the key so we can "append" it to the payload */
		(*swd)->sw_octx = malloc(cri->cri_klen / 8, M_XDATA, M_NOWAIT);
		if ((*swd)->sw_octx == NULL)
		{
		    swcr_freesession(i);
		    return ENOBUFS;
		}

		(*swd)->sw_klen = cri->cri_klen / 8;
		bcopy(cri->cri_key, (*swd)->sw_octx, cri->cri_klen / 8);

d575 1
a575 1
swcr_freesession(u_int64_t tid)
a579 1
    u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
a599 1
	    case CRYPTO_RIJNDAEL128_CBC:
d606 1
a606 19
		  free(swd->sw_iv, M_XDATA);
		break;

	    case CRYPTO_MD5_HMAC:
	    case CRYPTO_SHA1_HMAC:
	    case CRYPTO_RIPEMD160_HMAC:
		axf = swd->sw_axf;

		if (swd->sw_ictx)
		{
		    bzero(swd->sw_ictx, axf->ctxsize);
		    free(swd->sw_ictx, M_XDATA);
		}

		if (swd->sw_octx)
		{
		    bzero(swd->sw_octx, axf->ctxsize);
		    free(swd->sw_octx, M_XDATA);
		}
d609 3
d619 1
a619 1
		    free(swd->sw_ictx, M_XDATA);
d624 2
a625 2
		    bzero(swd->sw_octx, swd->sw_klen);
		    free(swd->sw_octx, M_XDATA);
d648 2
a649 2
    /* Sanity check */
    if (crp == NULL)
a701 1
	    case CRYPTO_RIJNDAEL128_CBC:
d707 3
a709 3
	    case CRYPTO_MD5_HMAC:
	    case CRYPTO_SHA1_HMAC:
	    case CRYPTO_RIPEMD160_HMAC:
a730 1

d735 1
a735 2
    crypto_done(crp);
    return 0;
d753 3
a755 3
        crypto_register(swcr_id, CRYPTO_MD5_HMAC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_SHA1_HMAC, NULL, NULL, NULL);
        crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, NULL, NULL, NULL);
a757 1
        crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, NULL, NULL, NULL);
@


1.2.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d10 1
a10 1
 * Copyright (c) 2000, 2001 Angelos D. Keromytis
d12 1
a12 1
 * Permission to use, copy, and modify this software with or without fee
d37 1
a37 1
#include <crypto/cryptodev.h>
d42 8
a49 9
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36
};
d52 8
a59 9
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C,
	0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C, 0x5C
};
d71 1
a71 1
    int outtype)
d73 116
a188 5
	unsigned char iv[EALG_MAX_BLOCK_LEN], blk[EALG_MAX_BLOCK_LEN], *idat;
	unsigned char *ivp, piv[EALG_MAX_BLOCK_LEN];
	struct enc_xform *exf;
	int i, k, j, blks;
	struct mbuf *m;
d190 31
a220 81
	exf = sw->sw_exf;
	blks = exf->blocksize;

	/* Check for non-padded data */
	if (crd->crd_len % blks)
		return EINVAL;

	if (outtype == CRYPTO_BUF_CONTIG) {
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, sw->sw_iv, blks);

			if (!(crd->crd_flags & CRD_F_IV_PRESENT))
				bcopy(sw->sw_iv, buf + crd->crd_inject, blks);

			for (i = crd->crd_skip;
			    i < crd->crd_skip + crd->crd_len; i += blks) {
				/* XOR with the IV/previous block, as appropriate. */
				if (i == crd->crd_skip)
					for (k = 0; k < blks; k++)
						buf[i + k] ^= sw->sw_iv[k];
				else
					for (k = 0; k < blks; k++)
						buf[i + k] ^= buf[i + k - blks];
				exf->encrypt(sw->sw_kschedule, buf + i);
			}

			/* Keep the last block */
			bcopy(buf + crd->crd_len - blks, sw->sw_iv, blks);

		} else {		/* Decrypt */
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, sw->sw_iv, blks);
			else /* IV preceeds data */
				bcopy(buf + crd->crd_inject, sw->sw_iv, blks);

			/*
			 * Start at the end, so we don't need to keep the encrypted
			 * block as the IV for the next block.
			 */
			for (i = crd->crd_skip + crd->crd_len - blks;
			    i >= crd->crd_skip; i -= blks) {
				exf->decrypt(sw->sw_kschedule, buf + i);

				/* XOR with the IV/previous block, as appropriate */
				if (i == crd->crd_skip)
					for (k = 0; k < blks; k++)
						buf[i + k] ^= sw->sw_iv[k];
				else
					for (k = 0; k < blks; k++)
						buf[i + k] ^= buf[i + k - blks];
			}
		}
		return 0;
	} else {
		m = (struct mbuf *) buf;

		/* Initialize the IV */
		if (crd->crd_flags & CRD_F_ENCRYPT) {
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, iv, blks);
			else {
				/* Use IV from context */
				bcopy(sw->sw_iv, iv, blks);
			}

			/* Do we need to write the IV */
			if (!(crd->crd_flags & CRD_F_IV_PRESENT))
				m_copyback(m, crd->crd_inject, blks, iv);

		} else {	/* Decryption */
			/* IV explicitly provided ? */
			if (crd->crd_flags & CRD_F_IV_EXPLICIT)
				bcopy(crd->crd_iv, iv, blks);
			else {
				/* Get IV off mbuf */
				m_copydata(m, crd->crd_inject, blks, iv);
			}
d223 2
a224 1
		ivp = iv;
d226 2
a227 2
		/* Find beginning of data */
		m = m_getptr(m, crd->crd_skip, &k);
d229 1
a229 1
			return EINVAL;
d231 1
a231 1
		i = crd->crd_len;
d233 23
a255 113
		while (i > 0) {
			/*
			 * If there's insufficient data at the end of
			 * an mbuf, we have to do some copying.
			 */
			if (m->m_len < k + blks && m->m_len != k) {
				m_copydata(m, k, blks, blk);

				/* Actual encryption/decryption */
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, blk);

					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					bcopy(blk, iv, blks);
					ivp = iv;
				} else {	/* decrypt */
					/*	
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					if (ivp == iv)
						bcopy(blk, piv, blks);
					else
						bcopy(blk, iv, blks);

					exf->decrypt(sw->sw_kschedule, blk);

					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				/* Copy back decrypted block */
				m_copyback(m, k, blks, blk);

				/* Advance pointer */
				m = m_getptr(m, k + blks, &k);
				if (m == NULL)
					return EINVAL;

				i -= blks;

				/* Could be done... */
				if (i == 0)
					break;
			}

			/* Skip possibly empty mbufs */
			if (k == m->m_len) {
				for (m = m->m_next; m && m->m_len == 0;
				    m = m->m_next)
					;
				k = 0;
			}

			/* Sanity check */
			if (m == NULL)
				return EINVAL;

			/*
			 * Warning: idat may point to garbage here, but
			 * we only use it in the while() loop, only if
			 * there are indeed enough data.
			 */
			idat = mtod(m, unsigned char *) + k;

	   		while (m->m_len >= k + blks && i > 0) {
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, idat);
					ivp = idat;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block to be used
					 * in next block's processing.
					 */
					if (ivp == iv)
						bcopy(idat, piv, blks);
					else
						bcopy(idat, iv, blks);

					exf->decrypt(sw->sw_kschedule, idat);

					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				idat += blks;
				k += blks;
				i -= blks;
			}
		}
d257 2
a258 1
		/* Keep the last block */
d260 4
a263 1
			bcopy(ivp, sw->sw_iv, blks);
d265 30
a294 1
		return 0; /* Done with mbuf encryption/decryption */
d297 9
a305 2
	/* Unreachable */
	return EINVAL;
d313 1
a313 1
    caddr_t buf, int outtype)
d315 23
a337 4
	unsigned char aalg[AALG_MAX_RESULT_LEN];
	struct auth_hash *axf;
	union authctx ctx;
	int err;
d339 2
a340 18
	if (sw->sw_ictx == 0)
		return EINVAL;

	axf = sw->sw_axf;

	bcopy(sw->sw_ictx, &ctx, axf->ctxsize);

	if (outtype == CRYPTO_BUF_CONTIG)
		axf->Update(&ctx, buf + crd->crd_skip, crd->crd_len);
	else {
		err = m_apply((struct mbuf *) buf, crd->crd_skip, crd->crd_len,
		    (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		    (caddr_t) &ctx);
		if (err)
			return err;
	}

	switch (sw->sw_alg) {
d344 2
a345 2
		if (sw->sw_octx == NULL)
			return EINVAL;
d347 21
a367 5
		axf->Final(aalg, &ctx);
		bcopy(sw->sw_octx, &ctx, axf->ctxsize);
		axf->Update(&ctx, aalg, axf->hashsize);
		axf->Final(aalg, &ctx);
		break;
d369 1
a369 17
	case CRYPTO_MD5_KPDK:
	case CRYPTO_SHA1_KPDK:
		if (sw->sw_octx == NULL)
			return EINVAL;

		axf->Update(&ctx, sw->sw_octx, sw->sw_klen);
		axf->Final(aalg, &ctx);
		break;
	}

	/* Inject the authentication data */
	if (outtype == CRYPTO_BUF_CONTIG)
		bcopy(aalg, buf + crd->crd_inject, axf->authsize);
	else
		m_copyback((struct mbuf *) buf, crd->crd_inject,
		    axf->authsize, aalg);
	return 0;
d378 62
a439 5
	struct swcr_data **swd;
	struct auth_hash *axf;
	struct enc_xform *txf;
	u_int32_t i;
	int k;
d441 27
a467 2
	if (sid == NULL || cri == NULL)
		return EINVAL;
d469 2
a470 69
	if (swcr_sessions) {
		for (i = 1; i < swcr_sesnum; i++)
			if (swcr_sessions[i] == NULL)
				break;
	}

	if (swcr_sessions == NULL || i == swcr_sesnum) {
		if (swcr_sessions == NULL) {
			i = 1; /* We leave swcr_sessions[0] empty */
			swcr_sesnum = CRYPTO_SW_SESSIONS;
		} else
			swcr_sesnum *= 2;

		swd = malloc(swcr_sesnum * sizeof(struct swcr_data *),
		    M_CRYPTO_DATA, M_NOWAIT);
		if (swd == NULL) {
			/* Reset session number */
			if (swcr_sesnum == CRYPTO_SW_SESSIONS)
				swcr_sesnum = 0;
			else
				swcr_sesnum /= 2;
			return ENOBUFS;
		}

		bzero(swd, swcr_sesnum * sizeof(struct swcr_data *));

		/* Copy existing sessions */
		if (swcr_sessions) {
			bcopy(swcr_sessions, swd,
			    (swcr_sesnum / 2) * sizeof(struct swcr_data *));
			free(swcr_sessions, M_CRYPTO_DATA);
		}

		swcr_sessions = swd;
	}

	swd = &swcr_sessions[i];
	*sid = i;

	while (cri) {
		MALLOC(*swd, struct swcr_data *, sizeof(struct swcr_data),
		    M_CRYPTO_DATA, M_NOWAIT);
		if (*swd == NULL) {
			swcr_freesession(i);
			return ENOBUFS;
		}
		bzero(*swd, sizeof(struct swcr_data));

		switch (cri->cri_alg) {
		case CRYPTO_DES_CBC:
			txf = &enc_xform_des;
			goto enccommon;
		case CRYPTO_3DES_CBC:
			txf = &enc_xform_3des;
			goto enccommon;
		case CRYPTO_BLF_CBC:
			txf = &enc_xform_blf;
			goto enccommon;
		case CRYPTO_CAST_CBC:
			txf = &enc_xform_cast5;
			goto enccommon;
		case CRYPTO_SKIPJACK_CBC:
			txf = &enc_xform_skipjack;
			goto enccommon;
		case CRYPTO_RIJNDAEL128_CBC:
			txf = &enc_xform_rijndael128;
			goto enccommon;
		enccommon:
			txf->setkey(&((*swd)->sw_kschedule), cri->cri_key,
d472 43
a514 37
			(*swd)->sw_iv = malloc(txf->blocksize, M_CRYPTO_DATA, M_NOWAIT);
			if ((*swd)->sw_iv == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
			(*swd)->sw_exf = txf;
			get_random_bytes((*swd)->sw_iv, txf->blocksize);
			break;
	
		case CRYPTO_MD5_HMAC:
			axf = &auth_hash_hmac_md5_96;
			goto authcommon;
		case CRYPTO_SHA1_HMAC:
			axf = &auth_hash_hmac_sha1_96;
			goto authcommon;
		case CRYPTO_RIPEMD160_HMAC:
			axf = &auth_hash_hmac_ripemd_160_96;
		authcommon:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
	
			(*swd)->sw_octx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_octx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
	
			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= HMAC_IPAD_VAL;
	
			axf->Init((*swd)->sw_ictx);
			axf->Update((*swd)->sw_ictx, cri->cri_key,
d516 1
a516 1
			axf->Update((*swd)->sw_ictx, hmac_ipad_buffer,
d518 6
a523 6
	
			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);
	
			axf->Init((*swd)->sw_octx);
			axf->Update((*swd)->sw_octx, cri->cri_key,
d525 1
a525 1
			axf->Update((*swd)->sw_octx, hmac_opad_buffer,
d527 35
a561 32
	
			for (k = 0; k < cri->cri_klen / 8; k++)
				cri->cri_key[k] ^= HMAC_OPAD_VAL;
			(*swd)->sw_axf = axf;
			break;
	
		case CRYPTO_MD5_KPDK:
			axf = &auth_hash_key_md5;
			goto auth2common;
	
		case CRYPTO_SHA1_KPDK:
			axf = &auth_hash_key_sha1;
		auth2common:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
	
			/* Store the key so we can "append" it to the payload */
			(*swd)->sw_octx = malloc(cri->cri_klen / 8, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_octx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
	
			(*swd)->sw_klen = cri->cri_klen / 8;
			bcopy(cri->cri_key, (*swd)->sw_octx, cri->cri_klen / 8);
			axf->Init((*swd)->sw_ictx);
			axf->Update((*swd)->sw_ictx, cri->cri_key,
d563 8
a570 12
			axf->Final(NULL, (*swd)->sw_ictx);
			(*swd)->sw_axf = axf;
			break;
	
		default:
			swcr_freesession(i);
			return EINVAL;
		}
	
		(*swd)->sw_alg = cri->cri_alg;
		cri = cri->cri_next;
		swd = &((*swd)->sw_next);
d572 7
a578 1
	return 0;
d587 26
a612 4
	struct swcr_data *swd;
	struct enc_xform *txf;
	struct auth_hash *axf;
	u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
d614 24
a637 3
	if (sid > swcr_sesnum || swcr_sessions == NULL ||
	    swcr_sessions[sid] == NULL)
		return EINVAL;
d639 8
a646 50
	/* Silently accept and return */
	if (sid == 0)
		return 0;

	while ((swd = swcr_sessions[sid]) != NULL) {
		swcr_sessions[sid] = swd->sw_next;

		switch (swd->sw_alg) {
		case CRYPTO_DES_CBC:
		case CRYPTO_3DES_CBC:
		case CRYPTO_BLF_CBC:
		case CRYPTO_CAST_CBC:
		case CRYPTO_SKIPJACK_CBC:
		case CRYPTO_RIJNDAEL128_CBC:
			txf = swd->sw_exf;

			if (swd->sw_kschedule)
				txf->zerokey(&(swd->sw_kschedule));
			if (swd->sw_iv)
				free(swd->sw_iv, M_CRYPTO_DATA);
			break;

		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
			axf = swd->sw_axf;

			if (swd->sw_ictx) {
				bzero(swd->sw_ictx, axf->ctxsize);
				free(swd->sw_ictx, M_CRYPTO_DATA);
			}
			if (swd->sw_octx) {
				bzero(swd->sw_octx, axf->ctxsize);
				free(swd->sw_octx, M_CRYPTO_DATA);
			}
			break;

		case CRYPTO_MD5_KPDK:
		case CRYPTO_SHA1_KPDK:
			axf = swd->sw_axf;

			if (swd->sw_ictx) {
				bzero(swd->sw_ictx, axf->ctxsize);
				free(swd->sw_ictx, M_CRYPTO_DATA);
			}
			if (swd->sw_octx) {
				bzero(swd->sw_octx, swd->sw_klen);
				free(swd->sw_octx, M_CRYPTO_DATA);
			}
			break;
d649 6
a654 1
		FREE(swd, M_CRYPTO_DATA);
d656 5
a660 1
	return 0;
d669 75
a743 8
	struct cryptodesc *crd;
	struct swcr_data *sw;
	u_int32_t lid;
	int type;

	/* Sanity check */
	if (crp == NULL)
	return EINVAL;
d745 1
a745 1
	if (crp->crp_desc == NULL || crp->crp_buf == NULL) {
d749 1
d751 12
a762 5
	lid = crp->crp_sid & 0xffffffff;
	if (lid >= swcr_sesnum || lid == 0 || swcr_sessions[lid] == NULL) {
		crp->crp_etype = ENOENT;
		goto done;
	}
d764 2
a765 59
	if (crp->crp_flags & CRYPTO_F_IMBUF)
		type = CRYPTO_BUF_MBUF;
	else
		type = CRYPTO_BUF_CONTIG;

	/* Go through crypto descriptors, processing as we go */
	for (crd = crp->crp_desc; crd; crd = crd->crd_next) {
		/*
		 * Find the crypto context.
		 *
		 * XXX Note that the logic here prevents us from having
		 * XXX the same algorithm multiple times in a session
		 * XXX (or rather, we can but it won't give us the right
		 * XXX results). To do that, we'd need some way of differentiating
		 * XXX between the various instances of an algorithm (so we can
		 * XXX locate the correct crypto context).
		 */
		for (sw = swcr_sessions[lid];
		    sw && sw->sw_alg != crd->crd_alg;
		    sw = sw->sw_next)
			;

		/* No such context ? */
		if (sw == NULL) {
			crp->crp_etype = EINVAL;
			goto done;
		}

		switch (sw->sw_alg) {
		case CRYPTO_DES_CBC:
		case CRYPTO_3DES_CBC:
		case CRYPTO_BLF_CBC:
		case CRYPTO_CAST_CBC:
		case CRYPTO_SKIPJACK_CBC:
		case CRYPTO_RIJNDAEL128_CBC:
			if ((crp->crp_etype = swcr_encdec(crd, sw,
			    crp->crp_buf, type)) != 0)
				goto done;
			break;
		case CRYPTO_MD5_HMAC:
		case CRYPTO_SHA1_HMAC:
		case CRYPTO_RIPEMD160_HMAC:
		case CRYPTO_MD5_KPDK:
		case CRYPTO_SHA1_KPDK:
			if ((crp->crp_etype = swcr_authcompute(crd, sw,
			    crp->crp_buf, type)) != 0)
				goto done;
			break;

		default:
			/* Unknown/unsupported algorithm */
			crp->crp_etype = EINVAL;
			goto done;
		}
	}

done:
	crypto_done(crp);
	return 0;
d774 17
a790 26
	swcr_id = crypto_get_driverid();
	if (swcr_id >= 0) {
		crypto_register(swcr_id, CRYPTO_DES_CBC, 0, 0, swcr_newsession,
		    swcr_freesession, swcr_process);
		crypto_register(swcr_id, CRYPTO_3DES_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_BLF_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_CAST_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5_KPDK, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1_KPDK, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, 0, 0,
		    NULL, NULL, NULL);
		return;
	}
d792 2
a793 2
	/* This should never happen */
	panic("Software crypto device cannot initialize!");
@


1.2.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.2.2.3 2001/07/04 10:39:59 niklas Exp $	*/
a359 90
 * Apply a compression/decompression algorithm
 */
int
swcr_compdec(struct cryptodesc *crd, struct swcr_data *sw,
    caddr_t buf, int outtype)
{
	u_int8_t *data, *out;
	struct comp_algo *cxf;
	int k, adj;
	u_int32_t result;
	struct mbuf *m, *m1;
   
	cxf = sw->sw_cxf;

	if (outtype == CRYPTO_BUF_CONTIG) {
		if (crd->crd_flags & CRD_F_COMP)
			result = cxf->compress(buf + crd->crd_skip, 
			    crd->crd_len, &out);
		else
			result = cxf->decompress(buf + crd->crd_skip, 
			    crd->crd_len, &out);
	} else { /* mbuf */
		m = (struct mbuf *)buf;
	
		/* Find beginning of data */
		m1 = m_getptr(m, crd->crd_skip, &k);
		if (m1 == NULL)
		return EINVAL;
		/* We must handle the whole buffer of data in one time
		 * then if there is not all the data in the mbuf, we must
		 * copy in a buffer.
		 */
       
		MALLOC(data, u_int8_t *, crd->crd_len, M_CRYPTO_DATA, 
		       M_NOWAIT);
		if (data == NULL)
			return EINVAL;
		m_copydata(m1, k, crd->crd_len, data);
	
		if (crd->crd_flags & CRD_F_COMP)
			result = cxf->compress(data, crd->crd_len, &out);
		else
			result = cxf->decompress(data, crd->crd_len, &out);
	}
    
	if (outtype == CRYPTO_BUF_CONTIG) {
		if (result == 0)
			return EINVAL;
		sw->sw_size = result;
		/* Check the compressed size when doing compression */
		if (crd->crd_flags & CRD_F_COMP) {
			if (result > crd->crd_len) {
				/* Compression was useless, we lost time */
				FREE(out, M_CRYPTO_DATA);
				return 0;
			}
		}
		buf = out;
		/* Don't forget to FREE buf later */
		return 0;
	} else {
		FREE(data, M_CRYPTO_DATA);
		if (result == 0)
			return EINVAL;
		/* Copy back the (de)compressed data. m_copyback is 
		 * extending the mbuf as necessary.
		 */
		sw->sw_size = result;
		/* Check the compressed size when doing compression */
		if (crd->crd_flags & CRD_F_COMP) {
			if (result > crd->crd_len) {
				/* Compression was useless, we lost time */
				FREE(out, M_CRYPTO_DATA);
				return 0;
			}
		}
		m_copyback(m1, k, result, out);
		if (result < crd->crd_len) {
			adj = result - crd->crd_len;
			m_adj(m, adj);
		}
		FREE(out, M_CRYPTO_DATA);
		return 0;
	}
    
	/* Unreachable */
	return EINVAL;
}

/*
a367 1
	struct comp_algo *cxf;
d529 1
a529 5

		case CRYPTO_DEFLATE_COMP:
			cxf = &comp_algo_deflate;
			(*swd)->sw_cxf = cxf;
			break;
a550 1
	struct comp_algo *cxf;
a606 4

		case CRYPTO_DEFLATE_COMP:
			cxf = swd->sw_cxf;
			break;
a688 8
		case CRYPTO_DEFLATE_COMP:
			if ((crp->crp_etype = swcr_compdec(crd, sw, 
			    crp->crp_buf, type)) != 0)
				goto done;
			else
				crp->crp_olen = (int)sw->sw_size;
			break;

a729 2
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_DEFLATE_COMP, 0, 0,
@


1.2.2.5
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d815 1
a815 1
	swcr_id = crypto_get_driverid(CRYPTOCAP_F_SOFTWARE);
@


1.2.2.6
log
@Merge in trunk
@
text
@a67 7
#define COPYBACK(x, a, b, c, d) \
	(x) == CRYPTO_BUF_MBUF ? m_copyback((struct mbuf *)a,b,c,d) \
	: cuio_copyback((struct uio *)a,b,c,d)
#define COPYDATA(x, a, b, c, d) \
	(x) == CRYPTO_BUF_MBUF ? m_copydata((struct mbuf *)a,b,c,d) \
	: cuio_copydata((struct uio *)a,b,c,d)

d78 2
a79 4
	int i, k, j, blks, ind, count;
	struct mbuf *m = NULL;
	struct uio *uio = NULL;

d88 50
a137 1
	if (outtype == CRYPTO_BUF_MBUF)
a138 2
	else
		uio = (struct uio *) buf;
d140 9
a148 9
	/* Initialize the IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		/* IV explicitly provided ? */
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, blks);
		else {
			/* Use IV from context */
			bcopy(sw->sw_iv, iv, blks);
		}
d150 3
a152 4
		/* Do we need to write the IV */
		if (!(crd->crd_flags & CRD_F_IV_PRESENT)) {
			COPYBACK(outtype, buf, crd->crd_inject, blks, iv);
		}
d154 1
a154 1
	} else {	/* Decryption */
d156 6
a161 5
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, blks);
		else {
			/* Get IV off buf */
			COPYDATA(outtype, buf, crd->crd_inject, blks, iv);
a162 1
	}
d164 1
a164 1
	ivp = iv;
a165 1
	if (outtype == CRYPTO_BUF_MBUF) {
d251 1
a251 1
			while (m->m_len >= k + blks && i > 0) {
a285 70
	} else {
		/* Find beginning of data */
		count = crd->crd_skip;
		ind = cuio_getptr(uio, count, &k);
		if (ind == -1)
			return EINVAL;

		i = crd->crd_len;

		while (i > 0) {
			/*
			 * If there's insufficient data at the end,
			 * we have to do some copying.
			 */
			if (uio->uio_iov[ind].iov_len < k + blks &&
			    uio->uio_iov[ind].iov_len != k) {
				cuio_copydata(uio, k, blks, blk);

				/* Actual encryption/decryption */
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, blk);

					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					bcopy(blk, iv, blks);
					ivp = iv;
				} else {	/* decrypt */
					/*	
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					if (ivp == iv)
						bcopy(blk, piv, blks);
					else
						bcopy(blk, iv, blks);

					exf->decrypt(sw->sw_kschedule, blk);

					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				/* Copy back decrypted block */
				cuio_copyback(uio, k, blks, blk);
			       
				count += blks;

				/* Advance pointer */
				ind = cuio_getptr(uio, count, &k);
				if (ind == -1)
					return (EINVAL);

				i -= blks;

				/* Could be done... */
				if (i == 0)
					break;
			}
d287 3
a289 6
			/*
			 * Warning: idat may point to garbage here, but
			 * we only use it in the while() loop, only if
			 * there are indeed enough data.
			 */
			idat = uio->uio_iov[ind].iov_base + k;
d291 1
a291 37
			while (uio->uio_iov[ind].iov_len >= k + blks &&
			    i > 0) {
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, idat);
					ivp = idat;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block to be used
					 * in next block's processing.
					 */
					if (ivp == iv)
						bcopy(idat, piv, blks);
					else
						bcopy(idat, iv, blks);

					exf->decrypt(sw->sw_kschedule, idat);

					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				idat += blks;
				count += blks;
				k += blks;
				i -= blks;
			}
		}
d294 2
a295 5
	/* Keep the last block */
	if (crd->crd_flags & CRD_F_ENCRYPT)
		bcopy(ivp, sw->sw_iv, blks);

	return 0; /* Done with encryption/decryption */
d302 2
a303 2
swcr_authcompute(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf, int outtype)
d317 3
a319 1
	if (outtype == CRYPTO_BUF_MBUF)
d323 3
a325 8
	else
		err = cuio_apply((struct uio *) buf, crd->crd_skip,
		    crd->crd_len,
		    (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		    (caddr_t) &ctx);

	if (err)
		return err;
a347 5

	case CRYPTO_MD5:
	case CRYPTO_SHA1:
		axf->Final(aalg, &ctx);
		break;
d351 2
a352 2
	if (outtype == CRYPTO_BUF_MBUF)
		COPYBACK(outtype, buf, crd->crd_inject, axf->authsize, aalg);
d354 2
a355 2
		bcopy(aalg, crp->crp_mac, axf->authsize);
	
d368 1
a368 1
	int adj;
d370 1
d374 18
a391 4
	/* We must handle the whole buffer of data in one time
	 * then if there is not all the data in the mbuf, we must
	 * copy in a buffer.
	 */
d393 5
a397 4
	MALLOC(data, u_int8_t *, crd->crd_len, M_CRYPTO_DATA,  M_NOWAIT);
	if (data == NULL)
		return (EINVAL);
	COPYDATA(outtype, buf, crd->crd_skip, crd->crd_len, data);
d399 5
a403 4
	if (crd->crd_flags & CRD_F_COMP)
		result = cxf->compress(data, crd->crd_len, &out);
	else
		result = cxf->decompress(data, crd->crd_len, &out);
d405 30
a434 14
	FREE(data, M_CRYPTO_DATA);
	if (result == 0)
		return EINVAL;

	/* Copy back the (de)compressed data. m_copyback is 
	 * extending the mbuf as necessary.
	 */
	sw->sw_size = result;
	/* Check the compressed size when doing compression */
	if (crd->crd_flags & CRD_F_COMP) {
		if (result > crd->crd_len) {
			/* Compression was useless, we lost time */
			FREE(out, M_CRYPTO_DATA);
			return 0;
d436 2
a437 6
	}
	
	COPYBACK(outtype, buf, crd->crd_skip, result, out);
	if (result < crd->crd_len) {
		adj = result - crd->crd_len;
		if (outtype == CRYPTO_BUF_MBUF) {
d439 1
a439 19
			m_adj((struct mbuf *)buf, adj);
		} else {
			struct uio *uio = (struct uio *)buf;
			int ind;

			adj = crd->crd_len - result;
			ind = uio->uio_iovcnt - 1;

			while (adj > 0 && ind >= 0) {
				if (adj < uio->uio_iov[ind].iov_len) {
					uio->uio_iov[ind].iov_len -= adj;
					break;
				}

				adj -= uio->uio_iov[ind].iov_len;
				uio->uio_iov[ind].iov_len = 0;
				ind--;
				uio->uio_iovcnt--;
			}
d441 2
d444 3
a446 2
	FREE(out, M_CRYPTO_DATA);
	return 0;
a620 18
		case CRYPTO_MD5:
			axf = &auth_hash_md5;
			goto auth3common;
	
		case CRYPTO_SHA1:
			axf = &auth_hash_sha1;
		auth3common:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}
	
			axf->Init((*swd)->sw_ictx);
			(*swd)->sw_axf = axf;
			break;

a703 8
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
			axf = swd->sw_axf;

			if (swd->sw_ictx)
				free(swd->sw_ictx, M_CRYPTO_DATA);
			break;

d743 1
a743 1
		type = CRYPTO_BUF_IOV;
d784 1
a784 3
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
			if ((crp->crp_etype = swcr_authcompute(crp, crd, sw,
a835 4
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_MD5, 0, 0,
		    NULL, NULL, NULL);
		crypto_register(swcr_id, CRYPTO_SHA1, 0, 0,
@


1.2.2.7
log
@Merge in -current from about a week ago
@
text
@d108 2
a109 16
			/* Get random IV */
			for (i = 0;
			    i + sizeof (u_int32_t) < EALG_MAX_BLOCK_LEN;
			    i += sizeof (u_int32_t))
				*((u_int32_t *) (iv + i)) = arc4random();
			/*
			 * What if the block size is not a multiple
			 * of sizeof (u_int32_t), which is the size of
			 * what arc4random() returns ?
			 */
			if (EALG_MAX_BLOCK_LEN % sizeof (u_int32_t) != 0) {
				u_int32_t temp = arc4random();

				bcopy (&temp, iv + i,
				    EALG_MAX_BLOCK_LEN - i);
			}
d367 4
d605 5
d611 1
d759 2
@


1.2.2.8
log
@Sync the SMP branch with 3.3
@
text
@d15 1
a15 1
 * modification of this software.
d42 7
a48 7
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
d111 2
a112 5
			    i += sizeof (u_int32_t)) {
				u_int32_t temp = arc4random();

				bcopy(&temp, iv + i, sizeof(u_int32_t));
			}
d174 1
a174 1
					/*
d297 1
a297 1
					/*
d320 1
a320 1

d449 1
a449 1

d464 1
a464 1

d471 1
a471 1

d476 1
a476 1

d481 1
a481 1

d486 1
a486 1
	/* Copy back the (de)compressed data. m_copyback is
d498 1
a498 1

a611 3
		case CRYPTO_NULL:
			txf = &enc_xform_null;
			goto enccommon;
d617 1
a617 1

d633 1
a633 1

d640 1
a640 1

d643 1
a643 1

d649 1
a649 1

d652 1
a652 1

d658 1
a658 1

d663 1
a663 1

d667 1
a667 1

d677 1
a677 1

d685 1
a685 1

d698 1
a698 1

d708 1
a708 1

d721 1
a721 1

d738 1
a758 1
		case CRYPTO_NULL:
d801 4
d825 1
a825 1
		return EINVAL;
a872 1
		case CRYPTO_NULL:
d890 1
a890 1
			if ((crp->crp_etype = swcr_compdec(crd, sw,
d915 32
a946 27
	int algs[CRYPTO_ALGORITHM_MAX + 1];
	int flags = CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_ENCRYPT_MAC |
	    CRYPTOCAP_F_MAC_ENCRYPT;

	swcr_id = crypto_get_driverid(flags);
	if (swcr_id < 0) {
		/* This should never happen */
		panic("Software crypto device cannot initialize!");
	}

	bzero(algs, sizeof(algs));

	algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_BLF_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_CAST_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SKIPJACK_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIJNDAEL128_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_DEFLATE_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_NULL] = CRYPTO_ALG_FLAG_SUPPORTED;
d948 2
a949 2
	crypto_register(swcr_id, algs, swcr_newsession,
	    swcr_freesession, swcr_process);
@


1.2.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a422 3
	case CRYPTO_SHA2_256_HMAC:
	case CRYPTO_SHA2_384_HMAC:
	case CRYPTO_SHA2_512_HMAC:
a631 9
			goto authcommon;
		case CRYPTO_SHA2_256_HMAC:
			axf = &auth_hash_hmac_sha2_256_96;
			goto authcommon;
		case CRYPTO_SHA2_384_HMAC:
			axf = &auth_hash_hmac_sha2_384_96;
			goto authcommon;
		case CRYPTO_SHA2_512_HMAC:
			axf = &auth_hash_hmac_sha2_512_96;
a882 3
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
a944 3
	algs[CRYPTO_SHA2_256_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_384_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA2_512_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
@


1.2.2.10
log
@Merge with the trunk
@
text
@d30 1
a31 1
#include <crypto/md5.h>
a785 3
		case CRYPTO_SHA2_256_HMAC:
		case CRYPTO_SHA2_384_HMAC:
		case CRYPTO_SHA2_512_HMAC:
@


1.7.2.1
log
@Pull in patch from current:
Fix (deraadt):
fix cleanup of crypto sessions
@
text
@d572 1
a572 1
    u_int32_t sid = ((u_int32_t) tid) & 0xffffffff;
@


1.17.2.1
log
@Pull patch from current:
Fix (angelos):
prevent leak of crypto sessions on systems that use the crypto framework
heavily (heavy IPsec usage).  this only happens when using automated
keying; manually keyed IPsec is not vulnerable to this.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.21 2001/06/06 04:37:07 angelos Exp $	*/
d672 1
d752 12
@


1.28.2.1
log
@Pull in patch from current:
Fix (deraadt):
be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.28 2001/08/08 15:12:09 jjbg Exp $	*/
d815 1
a815 1
	swcr_id = crypto_get_driverid(CRYPTOCAP_F_SOFTWARE);
@


1.29.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptosoft.c,v 1.29 2001/11/09 03:11:38 deraadt Exp $	*/
d15 1
a15 1
 * modification of this software.
d42 7
a48 7
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
a67 7
#define COPYBACK(x, a, b, c, d) \
	(x) == CRYPTO_BUF_MBUF ? m_copyback((struct mbuf *)a,b,c,d) \
	: cuio_copyback((struct uio *)a,b,c,d)
#define COPYDATA(x, a, b, c, d) \
	(x) == CRYPTO_BUF_MBUF ? m_copydata((struct mbuf *)a,b,c,d) \
	: cuio_copydata((struct uio *)a,b,c,d)

d78 2
a79 4
	int i, k, j, blks, ind, count;
	struct mbuf *m = NULL;
	struct uio *uio = NULL;

d88 5
a92 4
	if (outtype == CRYPTO_BUF_MBUF)
		m = (struct mbuf *) buf;
	else
		uio = (struct uio *) buf;
d94 2
a95 11
	/* Initialize the IV */
	if (crd->crd_flags & CRD_F_ENCRYPT) {
		/* IV explicitly provided ? */
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, blks);
		else {
			/* Get random IV */
			for (i = 0;
			    i + sizeof (u_int32_t) < EALG_MAX_BLOCK_LEN;
			    i += sizeof (u_int32_t)) {
				u_int32_t temp = arc4random();
d97 10
a106 1
				bcopy(&temp, iv + i, sizeof(u_int32_t));
d108 11
d120 2
a121 3
			 * What if the block size is not a multiple
			 * of sizeof (u_int32_t), which is the size of
			 * what arc4random() returns ?
d123 16
a138 2
			if (EALG_MAX_BLOCK_LEN % sizeof (u_int32_t) != 0) {
				u_int32_t temp = arc4random();
d140 8
a147 2
				bcopy (&temp, iv + i,
				    EALG_MAX_BLOCK_LEN - i);
a148 1
		}
d150 3
a152 4
		/* Do we need to write the IV */
		if (!(crd->crd_flags & CRD_F_IV_PRESENT)) {
			COPYBACK(outtype, buf, crd->crd_inject, blks, iv);
		}
d154 1
a154 1
	} else {	/* Decryption */
d156 6
a161 5
		if (crd->crd_flags & CRD_F_IV_EXPLICIT)
			bcopy(crd->crd_iv, iv, blks);
		else {
			/* Get IV off buf */
			COPYDATA(outtype, buf, crd->crd_inject, blks, iv);
a162 1
	}
d164 1
a164 1
	ivp = iv;
a165 1
	if (outtype == CRYPTO_BUF_MBUF) {
d196 1
a196 1
					/*
d251 1
a251 1
			while (m->m_len >= k + blks && i > 0) {
a285 96
	} else {
		/* Find beginning of data */
		count = crd->crd_skip;
		ind = cuio_getptr(uio, count, &k);
		if (ind == -1)
			return EINVAL;

		i = crd->crd_len;

		while (i > 0) {
			/*
			 * If there's insufficient data at the end,
			 * we have to do some copying.
			 */
			if (uio->uio_iov[ind].iov_len < k + blks &&
			    uio->uio_iov[ind].iov_len != k) {
				cuio_copydata(uio, k, blks, blk);

				/* Actual encryption/decryption */
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, blk);

					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					bcopy(blk, iv, blks);
					ivp = iv;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block for XOR'ing
					 * with next block
					 */
					if (ivp == iv)
						bcopy(blk, piv, blks);
					else
						bcopy(blk, iv, blks);

					exf->decrypt(sw->sw_kschedule, blk);

					/* XOR with previous block */
					for (j = 0; j < blks; j++)
						blk[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				/* Copy back decrypted block */
				cuio_copyback(uio, k, blks, blk);

				count += blks;

				/* Advance pointer */
				ind = cuio_getptr(uio, count, &k);
				if (ind == -1)
					return (EINVAL);

				i -= blks;

				/* Could be done... */
				if (i == 0)
					break;
			}

			/*
			 * Warning: idat may point to garbage here, but
			 * we only use it in the while() loop, only if
			 * there are indeed enough data.
			 */
			idat = uio->uio_iov[ind].iov_base + k;

			while (uio->uio_iov[ind].iov_len >= k + blks &&
			    i > 0) {
				if (crd->crd_flags & CRD_F_ENCRYPT) {
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					exf->encrypt(sw->sw_kschedule, idat);
					ivp = idat;
				} else {	/* decrypt */
					/*
					 * Keep encrypted block to be used
					 * in next block's processing.
					 */
					if (ivp == iv)
						bcopy(idat, piv, blks);
					else
						bcopy(idat, iv, blks);
d287 3
a289 1
					exf->decrypt(sw->sw_kschedule, idat);
d291 1
a291 16
					/* XOR with previous block/IV */
					for (j = 0; j < blks; j++)
						idat[j] ^= ivp[j];

					if (ivp == iv)
						bcopy(piv, iv, blks);
					else
						ivp = iv;
				}

				idat += blks;
				count += blks;
				k += blks;
				i -= blks;
			}
		}
d294 2
a295 1
	return 0; /* Done with encryption/decryption */
d302 2
a303 2
swcr_authcompute(struct cryptop *crp, struct cryptodesc *crd,
    struct swcr_data *sw, caddr_t buf, int outtype)
d317 3
a319 1
	if (outtype == CRYPTO_BUF_MBUF)
d323 3
a325 8
	else
		err = cuio_apply((struct uio *) buf, crd->crd_skip,
		    crd->crd_len,
		    (int (*)(caddr_t, caddr_t, unsigned int)) axf->Update,
		    (caddr_t) &ctx);

	if (err)
		return err;
a347 5

	case CRYPTO_MD5:
	case CRYPTO_SHA1:
		axf->Final(aalg, &ctx);
		break;
d351 2
a352 2
	if (outtype == CRYPTO_BUF_MBUF)
		COPYBACK(outtype, buf, crd->crd_inject, axf->authsize, aalg);
d354 2
a355 2
		bcopy(aalg, crp->crp_mac, axf->authsize);

d368 1
a368 1
	int adj;
d370 2
a371 1

d374 13
a386 17
	/* We must handle the whole buffer of data in one time
	 * then if there is not all the data in the mbuf, we must
	 * copy in a buffer.
	 */

	MALLOC(data, u_int8_t *, crd->crd_len, M_CRYPTO_DATA,  M_NOWAIT);
	if (data == NULL)
		return (EINVAL);
	COPYDATA(outtype, buf, crd->crd_skip, crd->crd_len, data);

	if (crd->crd_flags & CRD_F_COMP)
		result = cxf->compress(data, crd->crd_len, &out);
	else
		result = cxf->decompress(data, crd->crd_len, &out);

	FREE(data, M_CRYPTO_DATA);
	if (result == 0)
d388 47
a434 11

	/* Copy back the (de)compressed data. m_copyback is
	 * extending the mbuf as necessary.
	 */
	sw->sw_size = result;
	/* Check the compressed size when doing compression */
	if (crd->crd_flags & CRD_F_COMP) {
		if (result > crd->crd_len) {
			/* Compression was useless, we lost time */
			FREE(out, M_CRYPTO_DATA);
			return 0;
d436 2
a437 6
	}

	COPYBACK(outtype, buf, crd->crd_skip, result, out);
	if (result < crd->crd_len) {
		adj = result - crd->crd_len;
		if (outtype == CRYPTO_BUF_MBUF) {
d439 1
a439 19
			m_adj((struct mbuf *)buf, adj);
		} else {
			struct uio *uio = (struct uio *)buf;
			int ind;

			adj = crd->crd_len - result;
			ind = uio->uio_iovcnt - 1;

			while (adj > 0 && ind >= 0) {
				if (adj < uio->uio_iov[ind].iov_len) {
					uio->uio_iov[ind].iov_len -= adj;
					break;
				}

				adj -= uio->uio_iov[ind].iov_len;
				uio->uio_iov[ind].iov_len = 0;
				ind--;
				uio->uio_iovcnt--;
			}
d441 2
d444 3
a446 2
	FREE(out, M_CRYPTO_DATA);
	return 0;
d535 5
d541 1
d543 1
a543 1

d559 1
a559 1

d566 1
a566 1

d569 1
a569 1

d575 1
a575 1

d578 1
a578 1

d584 1
a584 1

d589 1
a589 1

d593 1
a593 1

d603 1
a603 1

d611 1
a611 1

a620 18
		case CRYPTO_MD5:
			axf = &auth_hash_md5;
			goto auth3common;

		case CRYPTO_SHA1:
			axf = &auth_hash_sha1;
		auth3common:
			(*swd)->sw_ictx = malloc(axf->ctxsize, M_CRYPTO_DATA,
			    M_NOWAIT);
			if ((*swd)->sw_ictx == NULL) {
				swcr_freesession(i);
				return ENOBUFS;
			}

			axf->Init((*swd)->sw_ictx);
			(*swd)->sw_axf = axf;
			break;

d629 1
a629 1

d671 2
a703 8
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
			axf = swd->sw_axf;

			if (swd->sw_ictx)
				free(swd->sw_ictx, M_CRYPTO_DATA);
			break;

d727 1
a727 1
		return EINVAL;
d743 1
a743 1
		type = CRYPTO_BUF_IOV;
d784 1
a784 3
		case CRYPTO_MD5:
		case CRYPTO_SHA1:
			if ((crp->crp_etype = swcr_authcompute(crp, crd, sw,
d790 1
a790 1
			if ((crp->crp_etype = swcr_compdec(crd, sw,
d816 30
a845 33
	if (swcr_id < 0) {
		/* This should never happen */
		panic("Software crypto device cannot initialize!");
	}

	crypto_register(swcr_id, CRYPTO_DES_CBC, 0, 0, swcr_newsession,
	    swcr_freesession, swcr_process);
	crypto_register(swcr_id, CRYPTO_3DES_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_BLF_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_CAST_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SKIPJACK_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_RIPEMD160_HMAC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5_KPDK, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1_KPDK, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_MD5, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_SHA1, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_RIJNDAEL128_CBC, 0, 0,
	    NULL, NULL, NULL);
	crypto_register(swcr_id, CRYPTO_DEFLATE_COMP, 0, 0,
	    NULL, NULL, NULL);
@


1.29.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a614 3
		case CRYPTO_NULL:
			txf = &enc_xform_null;
			goto enccommon;
d741 1
a761 1
		case CRYPTO_NULL:
d804 4
a875 1
		case CRYPTO_NULL:
d918 1
a918 5
	int algs[CRYPTO_ALGORITHM_MAX + 1];
	int flags = CRYPTOCAP_F_SOFTWARE | CRYPTOCAP_F_ENCRYPT_MAC |
	    CRYPTOCAP_F_MAC_ENCRYPT;

	swcr_id = crypto_get_driverid(flags);
d924 1
a924 19
	bzero(algs, sizeof(algs));

	algs[CRYPTO_DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_3DES_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_BLF_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_CAST_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SKIPJACK_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIPEMD160_HMAC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1_KPDK] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_MD5] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_SHA1] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_RIJNDAEL128_CBC] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_DEFLATE_COMP] = CRYPTO_ALG_FLAG_SUPPORTED;
	algs[CRYPTO_NULL] = CRYPTO_ALG_FLAG_SUPPORTED;

	crypto_register(swcr_id, algs, swcr_newsession,
d926 26
@
