head	1.55;
access;
symbols
	OPENBSD_6_0:1.54.0.4
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.2
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.2
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.6
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.4
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.43.0.10
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.36.0.6
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.2
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.35.0.2
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.31.0.2
	OPENBSD_4_2_BASE:1.31
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.6
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.29.0.4
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.22.0.2
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.19.0.2
	OPENBSD_3_2_BASE:1.19
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.19
	UBC:1.16.0.4
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.55
date	2016.09.19.18.09.40;	author tedu;	state Exp;
branches;
next	1.54;
commitid	ylyllqBwTV1qZHDZ;

1.54
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.53;
commitid	T0HbsCFlrwPATHlH;

1.53
date	2015.11.13.15.29.55;	author naddy;	state Exp;
branches;
next	1.52;
commitid	kI77GdyYKaka3fwk;

1.52
date	2015.11.13.12.21.16;	author mikeb;	state Exp;
branches;
next	1.51;
commitid	YLaQcqVfNSwoLvqJ;

1.51
date	2015.11.07.17.46.49;	author mikeb;	state Exp;
branches;
next	1.50;
commitid	5yYZiRe9782UzVyj;

1.50
date	2015.11.07.17.46.07;	author mikeb;	state Exp;
branches;
next	1.49;
commitid	s8MMyIRXEKnnagrT;

1.49
date	2015.11.04.12.32.37;	author mikeb;	state Exp;
branches;
next	1.48;
commitid	xP4VlLzr2fMpa2v1;

1.48
date	2015.11.03.01.31.36;	author mikeb;	state Exp;
branches;
next	1.47;
commitid	jsYuUjxp9lhd0Ksp;

1.47
date	2015.10.27.12.00.25;	author mikeb;	state Exp;
branches;
next	1.46;
commitid	sbmuBuaeLC6LB7F4;

1.46
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.45;
commitid	p4LJxGKbi0BU2cG6;

1.45
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.44;
commitid	cPvnXrnDy9of9D0l;

1.44
date	2013.08.25.14.26.56;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2011.07.07.02.57.24;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.12.16.58.23;	author mikeb;	state Exp;
branches;
next	1.41;

1.41
date	2011.01.11.15.42.05;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.22.11.54.23;	author mikeb;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.20.22.05.41;	author tedu;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.06.22.23.21;	author djm;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.09.16.11.36;	author djm;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.09.16.07.00;	author djm;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.13.21.26.41;	author hshoexer;	state Exp;
branches;
next	1.32;

1.32
date	2007.09.10.22.19.42;	author henric;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.27.05.43.17;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.19.08.55.41;	author hshoexer;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.20.20.31.18;	author hshoexer;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.15.17.49.14;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2004.06.26.05.05.12;	author hshoexer;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.07.14.42.26;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.26.10.04.49;	author markus;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.19.02.38.42;	author jason;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.15.22.57.58;	author jason;	state Exp;
branches;
next	1.20;

1.20
date	2002.11.12.18.23.13;	author jason;	state Exp;
branches;
next	1.19;

1.19
date	2002.08.16.22.47.25;	author dhartmei;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.22.23.10.09;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.05.15.59.41;	author markus;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.28.12.20.43;	author ben;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2001.08.24.15.59.42;	author markus;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.17.17.37.12;	author ben;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.08.15.12.09;	author jjbg;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.05.17.53.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.05.16.44.00;	author jjbg;	state Exp;
branches;
next	1.10;

1.10
date	2001.06.27.04.57.08;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.05.02.22;	author angelos;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.23.18.30.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.16.22.17.50;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.13.13.43.34;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.05.00.31.34;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.17.04.07.05;	author angelos;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.09.22.17.30;	author angelos;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.18.08.37.11;	author angelos;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.17.10.25.21;	author angelos;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.03.24.09.09.05;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.05.14.22.06.55;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.07.04.10.40.04;	author niklas;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2004.02.19.10.51.30;	author niklas;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2004.06.05.23.12.36;	author niklas;	state Exp;
branches;
next	;

1.16.4.1
date	2002.06.11.03.28.34;	author art;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	1.16.4.3;

1.16.4.3
date	2003.05.19.21.53.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@convert bcopy to memcpy. from david hill
@
text
@/*	$OpenBSD: xform.c,v 1.54 2015/12/10 21:00:51 naddy Exp $	*/
/*
 * The authors of this code are John Ioannidis (ji@@tla.org),
 * Angelos D. Keromytis (kermit@@csd.uch.gr),
 * Niels Provos (provos@@physnet.uni-hamburg.de),
 * Damien Miller (djm@@mindrot.org) and
 * Mike Belopuhov (mikeb@@openbsd.org).
 *
 * This code was written by John Ioannidis for BSD/OS in Athens, Greece,
 * in November 1995.
 *
 * Ported to OpenBSD and NetBSD, with additional transforms, in December 1996,
 * by Angelos D. Keromytis.
 *
 * Additional transforms and features in 1997 and 1998 by Angelos D. Keromytis
 * and Niels Provos.
 *
 * Additional features in 1999 by Angelos D. Keromytis.
 *
 * AES XTS implementation in 2008 by Damien Miller
 *
 * AES-GCM-16 and Chacha20-Poly1305 AEAD modes by Mike Belopuhov.
 *
 * Copyright (C) 1995, 1996, 1997, 1998, 1999 by John Ioannidis,
 * Angelos D. Keromytis and Niels Provos.
 *
 * Copyright (C) 2001, Angelos D. Keromytis.
 *
 * Copyright (C) 2008, Damien Miller
 *
 * Copyright (C) 2010, 2015, Mike Belopuhov
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all copies of any software which is or includes a copy or
 * modification of this software.
 * You may use this code under the GNU public license if you so wish. Please
 * contribute changes back to the authors under this freer than GPL license
 * so that we may further the use of strong encryption without limitations to
 * all.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/kernel.h>
#include <machine/cpu.h>

#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/sha2.h>
#include <crypto/rmd160.h>
#include <crypto/blf.h>
#include <crypto/cast.h>
#include <crypto/rijndael.h>
#include <crypto/cryptodev.h>
#include <crypto/xform.h>
#include <crypto/gmac.h>
#include <crypto/chachapoly.h>

extern void des_ecb3_encrypt(caddr_t, caddr_t, caddr_t, caddr_t, caddr_t, int);

int  des_set_key(void *, caddr_t);
int  des3_setkey(void *, u_int8_t *, int);
int  blf_setkey(void *, u_int8_t *, int);
int  cast5_setkey(void *, u_int8_t *, int);
int  rijndael128_setkey(void *, u_int8_t *, int);
int  aes_ctr_setkey(void *, u_int8_t *, int);
int  aes_xts_setkey(void *, u_int8_t *, int);
int  null_setkey(void *, u_int8_t *, int);

void des3_encrypt(caddr_t, u_int8_t *);
void blf_encrypt(caddr_t, u_int8_t *);
void cast5_encrypt(caddr_t, u_int8_t *);
void rijndael128_encrypt(caddr_t, u_int8_t *);
void null_encrypt(caddr_t, u_int8_t *);
void aes_xts_encrypt(caddr_t, u_int8_t *);

void des3_decrypt(caddr_t, u_int8_t *);
void blf_decrypt(caddr_t, u_int8_t *);
void cast5_decrypt(caddr_t, u_int8_t *);
void rijndael128_decrypt(caddr_t, u_int8_t *);
void null_decrypt(caddr_t, u_int8_t *);
void aes_xts_decrypt(caddr_t, u_int8_t *);

void aes_ctr_crypt(caddr_t, u_int8_t *);

void aes_ctr_reinit(caddr_t, u_int8_t *);
void aes_xts_reinit(caddr_t, u_int8_t *);
void aes_gcm_reinit(caddr_t, u_int8_t *);

int MD5Update_int(void *, const u_int8_t *, u_int16_t);
int SHA1Update_int(void *, const u_int8_t *, u_int16_t);
int RMD160Update_int(void *, const u_int8_t *, u_int16_t);
int SHA256Update_int(void *, const u_int8_t *, u_int16_t);
int SHA384Update_int(void *, const u_int8_t *, u_int16_t);
int SHA512Update_int(void *, const u_int8_t *, u_int16_t);

u_int32_t deflate_compress(u_int8_t *, u_int32_t, u_int8_t **);
u_int32_t deflate_decompress(u_int8_t *, u_int32_t, u_int8_t **);
u_int32_t lzs_dummy(u_int8_t *, u_int32_t, u_int8_t **);

#define AESCTR_NONCESIZE	4
#define AESCTR_IVSIZE		8
#define AESCTR_BLOCKSIZE	16

struct aes_ctr_ctx {
	u_int32_t	ac_ek[4*(AES_MAXROUNDS + 1)];
	u_int8_t	ac_block[AESCTR_BLOCKSIZE];
	int		ac_nr;
};

#define AES_XTS_BLOCKSIZE	16
#define AES_XTS_IVSIZE		8
#define AES_XTS_ALPHA		0x87	/* GF(2^128) generator polynomial */

struct aes_xts_ctx {
	rijndael_ctx key1;
	rijndael_ctx key2;
	u_int8_t tweak[AES_XTS_BLOCKSIZE];
};

/* Helper */
void aes_xts_crypt(struct aes_xts_ctx *, u_int8_t *, u_int);

/* Encryption instances */
struct enc_xform enc_xform_3des = {
	CRYPTO_3DES_CBC, "3DES",
	8, 8, 24, 24, 384,
	des3_encrypt,
	des3_decrypt,
	des3_setkey,
	NULL
};

struct enc_xform enc_xform_blf = {
	CRYPTO_BLF_CBC, "Blowfish",
	8, 8, 5, 56 /* 448 bits, max key */,
	sizeof(blf_ctx),
	blf_encrypt,
	blf_decrypt,
	blf_setkey,
	NULL
};

struct enc_xform enc_xform_cast5 = {
	CRYPTO_CAST_CBC, "CAST-128",
	8, 8, 5, 16,
	sizeof(cast_key),
	cast5_encrypt,
	cast5_decrypt,
	cast5_setkey,
	NULL
};

struct enc_xform enc_xform_rijndael128 = {
	CRYPTO_RIJNDAEL128_CBC, "Rijndael-128/AES",
	16, 16, 16, 32,
	sizeof(rijndael_ctx),
	rijndael128_encrypt,
	rijndael128_decrypt,
	rijndael128_setkey,
	NULL
};

struct enc_xform enc_xform_aes_ctr = {
	CRYPTO_AES_CTR, "AES-CTR",
	16, 8, 16+4, 32+4,
	sizeof(struct aes_ctr_ctx),
	aes_ctr_crypt,
	aes_ctr_crypt,
	aes_ctr_setkey,
	aes_ctr_reinit
};

struct enc_xform enc_xform_aes_gcm = {
	CRYPTO_AES_GCM_16, "AES-GCM",
	1, 8, 16+4, 32+4,
	sizeof(struct aes_ctr_ctx),
	aes_ctr_crypt,
	aes_ctr_crypt,
	aes_ctr_setkey,
	aes_gcm_reinit
};

struct enc_xform enc_xform_aes_gmac = {
	CRYPTO_AES_GMAC, "AES-GMAC",
	1, 8, 16+4, 32+4, 0,
	NULL,
	NULL,
	NULL,
	NULL
};

struct enc_xform enc_xform_aes_xts = {
	CRYPTO_AES_XTS, "AES-XTS",
	16, 8, 32, 64,
	sizeof(struct aes_xts_ctx),
	aes_xts_encrypt,
	aes_xts_decrypt,
	aes_xts_setkey,
	aes_xts_reinit
};

struct enc_xform enc_xform_chacha20_poly1305 = {
	CRYPTO_CHACHA20_POLY1305, "CHACHA20-POLY1305",
	1, 8, 32+4, 32+4,
	sizeof(struct chacha20_ctx),
	chacha20_crypt,
	chacha20_crypt,
	chacha20_setkey,
	chacha20_reinit
};

struct enc_xform enc_xform_null = {
	CRYPTO_NULL, "NULL",
	4, 0, 0, 256, 0,
	null_encrypt,
	null_decrypt,
	null_setkey,
	NULL
};

/* Authentication instances */
struct auth_hash auth_hash_hmac_md5_96 = {
	CRYPTO_MD5_HMAC, "HMAC-MD5",
	16, 16, 12, sizeof(MD5_CTX), HMAC_MD5_BLOCK_LEN,
	(void (*) (void *)) MD5Init, NULL, NULL,
	MD5Update_int,
	(void (*) (u_int8_t *, void *)) MD5Final
};

struct auth_hash auth_hash_hmac_sha1_96 = {
	CRYPTO_SHA1_HMAC, "HMAC-SHA1",
	20, 20, 12, sizeof(SHA1_CTX), HMAC_SHA1_BLOCK_LEN,
	(void (*) (void *)) SHA1Init, NULL, NULL,
	SHA1Update_int,
	(void (*) (u_int8_t *, void *)) SHA1Final
};

struct auth_hash auth_hash_hmac_ripemd_160_96 = {
	CRYPTO_RIPEMD160_HMAC, "HMAC-RIPEMD-160",
	20, 20, 12, sizeof(RMD160_CTX), HMAC_RIPEMD160_BLOCK_LEN,
	(void (*)(void *)) RMD160Init, NULL, NULL,
	RMD160Update_int,
	(void (*)(u_int8_t *, void *)) RMD160Final
};

struct auth_hash auth_hash_hmac_sha2_256_128 = {
	CRYPTO_SHA2_256_HMAC, "HMAC-SHA2-256",
	32, 32, 16, sizeof(SHA2_CTX), HMAC_SHA2_256_BLOCK_LEN,
	(void (*)(void *)) SHA256Init, NULL, NULL,
	SHA256Update_int,
	(void (*)(u_int8_t *, void *)) SHA256Final
};

struct auth_hash auth_hash_hmac_sha2_384_192 = {
	CRYPTO_SHA2_384_HMAC, "HMAC-SHA2-384",
	48, 48, 24, sizeof(SHA2_CTX), HMAC_SHA2_384_BLOCK_LEN,
	(void (*)(void *)) SHA384Init, NULL, NULL,
	SHA384Update_int,
	(void (*)(u_int8_t *, void *)) SHA384Final
};

struct auth_hash auth_hash_hmac_sha2_512_256 = {
	CRYPTO_SHA2_512_HMAC, "HMAC-SHA2-512",
	64, 64, 32, sizeof(SHA2_CTX), HMAC_SHA2_512_BLOCK_LEN,
	(void (*)(void *)) SHA512Init, NULL, NULL,
	SHA512Update_int,
	(void (*)(u_int8_t *, void *)) SHA512Final
};

struct auth_hash auth_hash_gmac_aes_128 = {
	CRYPTO_AES_128_GMAC, "GMAC-AES-128",
	16+4, GMAC_BLOCK_LEN, GMAC_DIGEST_LEN, sizeof(AES_GMAC_CTX),
	AESCTR_BLOCKSIZE, AES_GMAC_Init, AES_GMAC_Setkey, AES_GMAC_Reinit,
	AES_GMAC_Update, AES_GMAC_Final
};

struct auth_hash auth_hash_gmac_aes_192 = {
	CRYPTO_AES_192_GMAC, "GMAC-AES-192",
	24+4, GMAC_BLOCK_LEN, GMAC_DIGEST_LEN, sizeof(AES_GMAC_CTX),
	AESCTR_BLOCKSIZE, AES_GMAC_Init, AES_GMAC_Setkey, AES_GMAC_Reinit,
	AES_GMAC_Update, AES_GMAC_Final
};

struct auth_hash auth_hash_gmac_aes_256 = {
	CRYPTO_AES_256_GMAC, "GMAC-AES-256",
	32+4, GMAC_BLOCK_LEN, GMAC_DIGEST_LEN, sizeof(AES_GMAC_CTX),
	AESCTR_BLOCKSIZE, AES_GMAC_Init, AES_GMAC_Setkey, AES_GMAC_Reinit,
	AES_GMAC_Update, AES_GMAC_Final
};

struct auth_hash auth_hash_chacha20_poly1305 = {
	CRYPTO_CHACHA20_POLY1305_MAC, "CHACHA20-POLY1305",
	CHACHA20_KEYSIZE+CHACHA20_SALT, POLY1305_BLOCK_LEN, POLY1305_TAGLEN,
	sizeof(CHACHA20_POLY1305_CTX), CHACHA20_BLOCK_LEN,
	Chacha20_Poly1305_Init, Chacha20_Poly1305_Setkey,
	Chacha20_Poly1305_Reinit, Chacha20_Poly1305_Update,
	Chacha20_Poly1305_Final
};

/* Compression instance */
struct comp_algo comp_algo_deflate = {
	CRYPTO_DEFLATE_COMP, "Deflate",
	90, deflate_compress,
	deflate_decompress
};

struct comp_algo comp_algo_lzs = {
	CRYPTO_LZS_COMP, "LZS",
	90, lzs_dummy,
	lzs_dummy
};

/*
 * Encryption wrapper routines.
 */
void
des3_encrypt(caddr_t key, u_int8_t *blk)
{
	des_ecb3_encrypt(blk, blk, key, key + 128, key + 256, 1);
}

void
des3_decrypt(caddr_t key, u_int8_t *blk)
{
	des_ecb3_encrypt(blk, blk, key + 256, key + 128, key, 0);
}

int
des3_setkey(void *sched, u_int8_t *key, int len)
{
	if (des_set_key(key, sched) < 0 || des_set_key(key + 8, sched + 128)
	    < 0 || des_set_key(key + 16, sched + 256) < 0)
		return -1;

	return 0;
}

void
blf_encrypt(caddr_t key, u_int8_t *blk)
{
	blf_ecb_encrypt((blf_ctx *) key, blk, 8);
}

void
blf_decrypt(caddr_t key, u_int8_t *blk)
{
	blf_ecb_decrypt((blf_ctx *) key, blk, 8);
}

int
blf_setkey(void *sched, u_int8_t *key, int len)
{
	blf_key((blf_ctx *)sched, key, len);

	return 0;
}

int
null_setkey(void *sched, u_int8_t *key, int len)
{
	return 0;
}

void
null_encrypt(caddr_t key, u_int8_t *blk)
{
}

void
null_decrypt(caddr_t key, u_int8_t *blk)
{
}

void
cast5_encrypt(caddr_t key, u_int8_t *blk)
{
	cast_encrypt((cast_key *) key, blk, blk);
}

void
cast5_decrypt(caddr_t key, u_int8_t *blk)
{
	cast_decrypt((cast_key *) key, blk, blk);
}

int
cast5_setkey(void *sched, u_int8_t *key, int len)
{
	cast_setkey((cast_key *)sched, key, len);

	return 0;
}

void
rijndael128_encrypt(caddr_t key, u_int8_t *blk)
{
	rijndael_encrypt((rijndael_ctx *) key, (u_char *) blk, (u_char *) blk);
}

void
rijndael128_decrypt(caddr_t key, u_int8_t *blk)
{
	rijndael_decrypt((rijndael_ctx *) key, (u_char *) blk, (u_char *) blk);
}

int
rijndael128_setkey(void *sched, u_int8_t *key, int len)
{
	return rijndael_set_key((rijndael_ctx *)sched, (u_char *)key, len * 8);
}

void
aes_ctr_reinit(caddr_t key, u_int8_t *iv)
{
	struct aes_ctr_ctx *ctx;

	ctx = (struct aes_ctr_ctx *)key;
	bcopy(iv, ctx->ac_block + AESCTR_NONCESIZE, AESCTR_IVSIZE);

	/* reset counter */
	bzero(ctx->ac_block + AESCTR_NONCESIZE + AESCTR_IVSIZE, 4);
}

void
aes_gcm_reinit(caddr_t key, u_int8_t *iv)
{
	struct aes_ctr_ctx *ctx;

	ctx = (struct aes_ctr_ctx *)key;
	bcopy(iv, ctx->ac_block + AESCTR_NONCESIZE, AESCTR_IVSIZE);

	/* reset counter */
	bzero(ctx->ac_block + AESCTR_NONCESIZE + AESCTR_IVSIZE, 4);
	ctx->ac_block[AESCTR_BLOCKSIZE - 1] = 1; /* GCM starts with 1 */
}

void
aes_ctr_crypt(caddr_t key, u_int8_t *data)
{
	struct aes_ctr_ctx *ctx;
	u_int8_t keystream[AESCTR_BLOCKSIZE];
	int i;

	ctx = (struct aes_ctr_ctx *)key;
	/* increment counter */
	for (i = AESCTR_BLOCKSIZE - 1;
	     i >= AESCTR_NONCESIZE + AESCTR_IVSIZE; i--)
		if (++ctx->ac_block[i])   /* continue on overflow */
			break;
	rijndaelEncrypt(ctx->ac_ek, ctx->ac_nr, ctx->ac_block, keystream);
	for (i = 0; i < AESCTR_BLOCKSIZE; i++)
		data[i] ^= keystream[i];
	explicit_bzero(keystream, sizeof(keystream));
}

int
aes_ctr_setkey(void *sched, u_int8_t *key, int len)
{
	struct aes_ctr_ctx *ctx;

	if (len < AESCTR_NONCESIZE)
		return -1;

	ctx = (struct aes_ctr_ctx *)sched;
	ctx->ac_nr = rijndaelKeySetupEnc(ctx->ac_ek, (u_char *)key,
	    (len - AESCTR_NONCESIZE) * 8);
	if (ctx->ac_nr == 0)
		return -1;
	bcopy(key + len - AESCTR_NONCESIZE, ctx->ac_block, AESCTR_NONCESIZE);
	return 0;
}

void
aes_xts_reinit(caddr_t key, u_int8_t *iv)
{
	struct aes_xts_ctx *ctx = (struct aes_xts_ctx *)key;
	u_int64_t blocknum;
	u_int i;

	/*
	 * Prepare tweak as E_k2(IV). IV is specified as LE representation
	 * of a 64-bit block number which we allow to be passed in directly.
	 */
	memcpy(&blocknum, iv, AES_XTS_IVSIZE);
	for (i = 0; i < AES_XTS_IVSIZE; i++) {
		ctx->tweak[i] = blocknum & 0xff;
		blocknum >>= 8;
	}
	/* Last 64 bits of IV are always zero */
	bzero(ctx->tweak + AES_XTS_IVSIZE, AES_XTS_IVSIZE);

	rijndael_encrypt(&ctx->key2, ctx->tweak, ctx->tweak);
}

void
aes_xts_crypt(struct aes_xts_ctx *ctx, u_int8_t *data, u_int do_encrypt)
{
	u_int8_t block[AES_XTS_BLOCKSIZE];
	u_int i, carry_in, carry_out;

	for (i = 0; i < AES_XTS_BLOCKSIZE; i++)
		block[i] = data[i] ^ ctx->tweak[i];

	if (do_encrypt)
		rijndael_encrypt(&ctx->key1, block, data);
	else
		rijndael_decrypt(&ctx->key1, block, data);

	for (i = 0; i < AES_XTS_BLOCKSIZE; i++)
		data[i] ^= ctx->tweak[i];

	/* Exponentiate tweak */
	carry_in = 0;
	for (i = 0; i < AES_XTS_BLOCKSIZE; i++) {
		carry_out = ctx->tweak[i] & 0x80;
		ctx->tweak[i] = (ctx->tweak[i] << 1) | (carry_in ? 1 : 0);
		carry_in = carry_out;
	}
	if (carry_in)
		ctx->tweak[0] ^= AES_XTS_ALPHA;
	explicit_bzero(block, sizeof(block));
}

void
aes_xts_encrypt(caddr_t key, u_int8_t *data)
{
	aes_xts_crypt((struct aes_xts_ctx *)key, data, 1);
}

void
aes_xts_decrypt(caddr_t key, u_int8_t *data)
{
	aes_xts_crypt((struct aes_xts_ctx *)key, data, 0);
}

int
aes_xts_setkey(void *sched, u_int8_t *key, int len)
{
	struct aes_xts_ctx *ctx;

	if (len != 32 && len != 64)
		return -1;

	ctx = (struct aes_xts_ctx *)sched;

	rijndael_set_key(&ctx->key1, key, len * 4);
	rijndael_set_key(&ctx->key2, key + (len / 2), len * 4);

	return 0;
}

/*
 * And now for auth.
 */

int
RMD160Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	RMD160Update(ctx, buf, len);
	return 0;
}

int
MD5Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	MD5Update(ctx, buf, len);
	return 0;
}

int
SHA1Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	SHA1Update(ctx, buf, len);
	return 0;
}

int
SHA256Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	SHA256Update(ctx, buf, len);
	return 0;
}

int
SHA384Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	SHA384Update(ctx, buf, len);
	return 0;
}

int
SHA512Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
{
	SHA512Update(ctx, buf, len);
	return 0;
}


u_int32_t deflate_global(u_int8_t *, u_int32_t, int, u_int8_t **);

struct deflate_buf {
        u_int8_t *out;
        u_int32_t size;
        int flag;
};

/*
 * And compression
 */

u_int32_t
deflate_compress(u_int8_t *data, u_int32_t size, u_int8_t **out)
{
	return deflate_global(data, size, 0, out);
}

u_int32_t
deflate_decompress(u_int8_t *data, u_int32_t size, u_int8_t **out)
{
	return deflate_global(data, size, 1, out);
}

u_int32_t
lzs_dummy(u_int8_t *data, u_int32_t size, u_int8_t **out)
{
	*out = NULL;
	return (0);
}
@


1.54
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.53 2015/11/13 15:29:55 naddy Exp $	*/
d494 1
a494 1
	bcopy(iv, &blocknum, AES_XTS_IVSIZE);
@


1.53
log
@remove unused ARC4 support; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.52 2015/11/13 12:21:16 mikeb Exp $	*/
a68 1
extern void des_ecb_encrypt(caddr_t, caddr_t, caddr_t, int);
a70 1
int  des1_setkey(void *, u_int8_t *, int);
a78 1
void des1_encrypt(caddr_t, u_int8_t *);
a85 1
void des1_decrypt(caddr_t, u_int8_t *);
a133 9
struct enc_xform enc_xform_des = {
	CRYPTO_DES_CBC, "DES",
	8, 8, 8, 8, 128,
	des1_encrypt,
	des1_decrypt,
	des1_setkey,
	NULL
};

a325 18
void
des1_encrypt(caddr_t key, u_int8_t *blk)
{
	des_ecb_encrypt(blk, blk, key, 1);
}

void
des1_decrypt(caddr_t key, u_int8_t *blk)
{
	des_ecb_encrypt(blk, blk, key, 0);
}

int
des1_setkey(void *sched, u_int8_t *key, int len)
{
	return des_set_key(key, sched);
}

@


1.52
log
@Remove unused non HMAC versions of MD5 and SHA1;  ok mpi, deraadt, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.51 2015/11/07 17:46:49 mikeb Exp $	*/
a232 9
};

struct enc_xform enc_xform_arc4 = {
	CRYPTO_ARC4, "ARC4",
	1, 1, 1, 32, 0,
	NULL,
	NULL,
	NULL,
	NULL
@


1.51
log
@Update copyright information
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.50 2015/11/07 17:46:07 mikeb Exp $	*/
a329 16
};

struct auth_hash auth_hash_md5 = {
	CRYPTO_MD5, "MD5",
	0, 16, 16, sizeof(MD5_CTX), 0,
	(void (*) (void *)) MD5Init, NULL, NULL,
	MD5Update_int,
	(void (*) (u_int8_t *, void *)) MD5Final
};

struct auth_hash auth_hash_sha1 = {
	CRYPTO_SHA1, "SHA1",
	0, 20, 20, sizeof(SHA1_CTX), 0,
	(void (*)(void *)) SHA1Init, NULL, NULL,
	SHA1Update_int,
	(void (*)(u_int8_t *, void *)) SHA1Final
@


1.50
log
@Pass AES_GMAC context as a void pointer to cut down on casts in xform.c
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.49 2015/11/04 12:32:37 mikeb Exp $	*/
d5 3
a7 2
 * Niels Provos (provos@@physnet.uni-hamburg.de) and
 * Damien Miller (djm@@mindrot.org).
d22 2
d30 2
@


1.49
log
@Pass context as a void pointer to cut down on casts in xform.c
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.48 2015/11/03 01:31:36 mikeb Exp $	*/
d300 2
a301 5
	AESCTR_BLOCKSIZE, (void (*)(void *)) AES_GMAC_Init,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Setkey,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Reinit,
	(int  (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Update,
	(void (*)(u_int8_t *, void *)) AES_GMAC_Final
d307 2
a308 5
	AESCTR_BLOCKSIZE, (void (*)(void *)) AES_GMAC_Init,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Setkey,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Reinit,
	(int  (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Update,
	(void (*)(u_int8_t *, void *)) AES_GMAC_Final
d314 2
a315 5
	AESCTR_BLOCKSIZE, (void (*)(void *)) AES_GMAC_Init,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Setkey,
	(void (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Reinit,
	(int  (*)(void *, const u_int8_t *, u_int16_t)) AES_GMAC_Update,
	(void (*)(u_int8_t *, void *)) AES_GMAC_Final
@


1.48
log
@Hook up Chacha20-Poly1305 to the OpenBSD Cryptographic Framework

ok naddy, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.47 2015/10/27 12:00:25 mikeb Exp $	*/
d331 3
a333 5
	(void (*)(void *))Chacha20_Poly1305_Init,
	(void (*)(void *, const u_int8_t *, u_int16_t))Chacha20_Poly1305_Setkey,
	(void (*)(void *, const u_int8_t *, u_int16_t))Chacha20_Poly1305_Reinit,
	(int  (*)(void *, const u_int8_t *, u_int16_t))Chacha20_Poly1305_Update,
	(void (*)(u_int8_t *, void *))Chacha20_Poly1305_Final
@


1.47
log
@Use verbose defines instead of hardcoded values for clarity when
initializing hash objects.  No binary or functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.46 2015/03/14 03:38:46 jsg Exp $	*/
d61 1
d220 10
d325 11
@


1.46
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.45 2014/12/28 10:02:37 tedu Exp $	*/
d288 2
a289 2
	16+4, 16, 16, sizeof(AES_GMAC_CTX), GMAC_BLOCK_LEN,
	(void (*)(void *)) AES_GMAC_Init,
d298 2
a299 2
	24+4, 16, 16, sizeof(AES_GMAC_CTX), GMAC_BLOCK_LEN,
	(void (*)(void *)) AES_GMAC_Init,
d308 2
a309 2
	32+4, 16, 16, sizeof(AES_GMAC_CTX), GMAC_BLOCK_LEN,
	(void (*)(void *)) AES_GMAC_Init,
@


1.45
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.44 2013/08/25 14:26:56 jsing Exp $	*/
a59 1
#include <lib/libz/zlib.h>
@


1.44
log
@Allocate and deallocate memory for encryption contexts within cryptosoft,
rather than requiring each algorithm to provide their own memory handling.
This matches the interface already provided by cryptosoft for
authentication algorithms and removes the need for zerokey functions.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.42 2011/01/12 16:58:23 mikeb Exp $	*/
a314 16
};

struct auth_hash auth_hash_key_md5 = {
	CRYPTO_MD5_KPDK, "Keyed MD5",
	0, 16, 16, sizeof(MD5_CTX), 0,
	(void (*)(void *)) MD5Init, NULL, NULL,
	MD5Update_int,
	(void (*)(u_int8_t *, void *)) MD5Final
};

struct auth_hash auth_hash_key_sha1 = {
	CRYPTO_SHA1_KPDK, "Keyed SHA1",
	0, 20, 20, sizeof(SHA1_CTX), 0,
	(void (*)(void *)) SHA1Init, NULL, NULL,
	SHA1Update_int,
	(void (*)(u_int8_t *, void *)) SHA1Final
@


1.43
log
@Replace the cruddy old sys/net/zlib.[ch].  We now use the sys/lib/libz
code.  Missing chunks of the API are imported from the libc version,
with a few #ifdef's to port it into the kernel environment.

The bootblocks already used the newer code, and should encounter no
surprises since there are so few changes to the existing files. In
the kernel, ipcomp and kernel ppp are changed to the new API.
ipcomp has been tested.

ok tedu the brave
@
text
@a45 1
#include <sys/malloc.h>
d66 9
a74 9
int  des_set_key(caddr_t, caddr_t);
int  des1_setkey(u_int8_t **, u_int8_t *, int);
int  des3_setkey(u_int8_t **, u_int8_t *, int);
int  blf_setkey(u_int8_t **, u_int8_t *, int);
int  cast5_setkey(u_int8_t **, u_int8_t *, int);
int  rijndael128_setkey(u_int8_t **, u_int8_t *, int);
int  aes_ctr_setkey(u_int8_t **, u_int8_t *, int);
int  aes_xts_setkey(u_int8_t **, u_int8_t *, int);
int  null_setkey(u_int8_t **, u_int8_t *, int);
a93 9
void des1_zerokey(u_int8_t **);
void des3_zerokey(u_int8_t **);
void blf_zerokey(u_int8_t **);
void cast5_zerokey(u_int8_t **);
void rijndael128_zerokey(u_int8_t **);
void aes_ctr_zerokey(u_int8_t **);
void aes_xts_zerokey(u_int8_t **);
void null_zerokey(u_int8_t **);

d109 20
a129 1
struct aes_xts_ctx;
d135 1
a135 1
	8, 8, 8, 8,
a138 1
	des1_zerokey,
d144 1
a144 1
	8, 8, 24, 24,
a147 1
	des3_zerokey,
d154 1
a157 1
	blf_zerokey,
d164 1
a167 1
	cast5_zerokey,
d174 1
a177 1
	rijndael128_zerokey,
d184 1
a187 1
	aes_ctr_zerokey,
d194 1
a197 1
	aes_ctr_zerokey,
d203 1
a203 2
	1, 8, 16+4, 32+4,
	NULL,
d213 1
a216 1
	aes_xts_zerokey,
d222 1
a222 2
	1, 1, 1, 32,
	NULL,
d231 1
a231 1
	4, 0, 0, 256,
a234 1
	null_zerokey,
d378 1
a378 1
des1_setkey(u_int8_t **sched, u_int8_t *key, int len)
d380 1
a380 16
	*sched = malloc(128, M_CRYPTO_DATA, M_WAITOK | M_ZERO);

	if (des_set_key(key, *sched) < 0) {
		des1_zerokey(sched);
		return -1;
	}

	return 0;
}

void
des1_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, 128);
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d396 1
a396 1
des3_setkey(u_int8_t **sched, u_int8_t *key, int len)
d398 2
a399 5
	*sched = malloc(384, M_CRYPTO_DATA, M_WAITOK | M_ZERO);

	if (des_set_key(key, *sched) < 0 || des_set_key(key + 8, *sched + 128)
	    < 0 || des_set_key(key + 16, *sched + 256) < 0) {
		des3_zerokey(sched);
a400 1
	}
a405 8
des3_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, 384);
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

void
d418 1
a418 1
blf_setkey(u_int8_t **sched, u_int8_t *key, int len)
d420 1
a420 2
	*sched = malloc(sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK | M_ZERO);
	blf_key((blf_ctx *)*sched, key, len);
a424 8
void
blf_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, sizeof(blf_ctx));
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

d426 1
a426 1
null_setkey(u_int8_t **sched, u_int8_t *key, int len)
a431 5
null_zerokey(u_int8_t **sched)
{
}

void
d454 1
a454 1
cast5_setkey(u_int8_t **sched, u_int8_t *key, int len)
d456 1
a456 2
	*sched = malloc(sizeof(cast_key), M_CRYPTO_DATA, M_WAITOK | M_ZERO);
	cast_setkey((cast_key *)*sched, key, len);
a461 8
cast5_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, sizeof(cast_key));
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

void
d474 1
a474 1
rijndael128_setkey(u_int8_t **sched, u_int8_t *key, int len)
d476 1
a476 9
	*sched = malloc(sizeof(rijndael_ctx), M_CRYPTO_DATA, M_WAITOK | M_ZERO);

	if (rijndael_set_key((rijndael_ctx *)*sched, (u_char *)key, len * 8)
	    < 0) {
		rijndael128_zerokey(sched);
		return -1;
	}

	return 0;
a479 18
rijndael128_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, sizeof(rijndael_ctx));
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

#define AESCTR_NONCESIZE	4
#define AESCTR_IVSIZE		8
#define AESCTR_BLOCKSIZE	16

struct aes_ctr_ctx {
	u_int32_t	ac_ek[4*(AES_MAXROUNDS + 1)];
	u_int8_t	ac_block[AESCTR_BLOCKSIZE];
	int		ac_nr;
};

void
d524 1
a524 1
aes_ctr_setkey(u_int8_t **sched, u_int8_t *key, int len)
d531 1
a531 3
	*sched = malloc(sizeof(struct aes_ctr_ctx), M_CRYPTO_DATA, M_WAITOK |
	    M_ZERO);
	ctx = (struct aes_ctr_ctx *)*sched;
d534 1
a534 2
	if (ctx->ac_nr == 0) {
		aes_ctr_zerokey(sched);
a535 1
	}
a540 18
aes_ctr_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, sizeof(struct aes_ctr_ctx));
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

#define AES_XTS_BLOCKSIZE	16
#define AES_XTS_IVSIZE		8
#define AES_XTS_ALPHA		0x87	/* GF(2^128) generator polynomial */

struct aes_xts_ctx {
	rijndael_ctx key1;
	rijndael_ctx key2;
	u_int8_t tweak[AES_XTS_BLOCKSIZE];
};

void
d604 1
a604 1
aes_xts_setkey(u_int8_t **sched, u_int8_t *key, int len)
d611 1
a611 3
	*sched = malloc(sizeof(struct aes_xts_ctx), M_CRYPTO_DATA,
	    M_WAITOK | M_ZERO);
	ctx = (struct aes_xts_ctx *)*sched;
a617 9

void
aes_xts_zerokey(u_int8_t **sched)
{
	explicit_bzero(*sched, sizeof(struct aes_xts_ctx));
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

@


1.42
log
@cleanup aes-ctr keystream after use;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.41 2011/01/11 15:42:05 deraadt Exp $	*/
d61 1
a61 1
#include <crypto/deflate.h>
d770 8
@


1.41
log
@for key material that is being being discarded, convert bzero() to
explicit_bzero() where required
ok markus mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.40 2010/10/06 22:19:20 mikeb Exp $	*/
d592 1
@


1.40
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.39 2010/09/22 11:54:23 mikeb Exp $	*/
d389 1
a389 1
	bzero(*sched, 128);
d423 1
a423 1
	bzero(*sched, 384);
d452 1
a452 1
	bzero(*sched, sizeof(blf_ctx));
d502 1
a502 1
	bzero(*sched, sizeof(cast_key));
d536 1
a536 1
	bzero(*sched, sizeof(rijndael_ctx));
d618 1
a618 1
	bzero(*sched, sizeof(struct aes_ctr_ctx));
d681 1
a681 1
	bzero(block, sizeof(block));
d717 1
a717 1
	bzero(*sched, sizeof(struct aes_xts_ctx));
@


1.39
log
@OCF support for the Galois/Counter Mode (GCM) for AES as
described in FIPS SP 800-38D.

This implementation supports 16 byte authentication tag only,
splitting transformation into two parts: encryption and
authentication.  Encryption is handled by the existing
AES-CTR implementation, while authentication requires new
AES_GMAC hash function.

Additional routine is added to the software crypto driver
to deal with peculiarities of a combined authentication-
encryption transformation.

With suggestions from reyk, naddy and toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.38 2010/04/20 22:05:41 tedu Exp $	*/
a57 1
#include <crypto/skipjack.h>
a71 1
int  skipjack_setkey(u_int8_t **, u_int8_t *, int);
a80 1
void skipjack_encrypt(caddr_t, u_int8_t *);
a88 1
void skipjack_decrypt(caddr_t, u_int8_t *);
a98 1
void skipjack_zerokey(u_int8_t **);
a163 10
struct enc_xform enc_xform_skipjack = {
	CRYPTO_SKIPJACK_CBC, "Skipjack",
	8, 8, 10, 10,
	skipjack_encrypt,
	skipjack_decrypt,
	skipjack_setkey,
	skipjack_zerokey,
	NULL
};

a502 38
	free(*sched, M_CRYPTO_DATA);
	*sched = NULL;
}

void
skipjack_encrypt(caddr_t key, u_int8_t *blk)
{
	skipjack_forwards(blk, blk, (u_int8_t **) key);
}

void
skipjack_decrypt(caddr_t key, u_int8_t *blk)
{
	skipjack_backwards(blk, blk, (u_int8_t **) key);
}

int
skipjack_setkey(u_int8_t **sched, u_int8_t *key, int len)
{
	*sched = malloc(10 * sizeof(u_int8_t *), M_CRYPTO_DATA, M_WAITOK |
	    M_ZERO);
	subkey_table_gen(key, (u_int8_t **) *sched);

	return 0;
}

void
skipjack_zerokey(u_int8_t **sched)
{
	int k;

	for (k = 0; k < 10; k++) {
		if (((u_int8_t **)(*sched))[k]) {
			bzero(((u_int8_t **)(*sched))[k], 0x100);
			free(((u_int8_t **)(*sched))[k], M_CRYPTO_DATA);
		}
	}
	bzero(*sched, 10 * sizeof(u_int8_t *));
@


1.38
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.37 2010/01/10 12:43:07 markus Exp $	*/
d63 1
d111 1
d199 20
d253 2
a254 1
	(void (*) (void *)) MD5Init, MD5Update_int,
d261 2
a262 1
	(void (*) (void *)) SHA1Init, SHA1Update_int,
d269 2
a270 1
	(void (*)(void *)) RMD160Init, RMD160Update_int,
d277 2
a278 1
	(void (*)(void *)) SHA256Init, SHA256Update_int,
d285 2
a286 1
	(void (*)(void *)) SHA384Init, SHA384Update_int,
d293 2
a294 1
	(void (*)(void *)) SHA512Init, SHA512Update_int,
d298 30
d331 2
a332 1
	(void (*)(void *)) MD5Init, MD5Update_int,
d339 2
a340 1
	(void (*)(void *)) SHA1Init, SHA1Update_int,
d347 2
a348 1
	(void (*) (void *)) MD5Init, MD5Update_int,
d355 2
a356 1
	(void (*)(void *)) SHA1Init, SHA1Update_int,
d617 13
d821 1
@


1.37
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.36 2008/09/06 22:23:21 djm Exp $	*/
a46 1
#include <sys/sysctl.h>
@


1.36
log
@match libc sha2(3) API changes for kernel; ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.35 2008/06/09 16:11:36 djm Exp $	*/
d231 1
a231 1
	16, 16, 12, sizeof(MD5_CTX),
d238 1
a238 1
	20, 20, 12, sizeof(SHA1_CTX),
d245 1
a245 1
	20, 20, 12, sizeof(RMD160_CTX),
d250 1
a250 1
struct auth_hash auth_hash_hmac_sha2_256_96 = {
d252 1
a252 1
	32, 32, 12, sizeof(SHA2_CTX),
d257 1
a257 1
struct auth_hash auth_hash_hmac_sha2_384_96 = {
d259 1
a259 1
	48, 48, 12, sizeof(SHA2_CTX),
d264 1
a264 1
struct auth_hash auth_hash_hmac_sha2_512_96 = {
d266 1
a266 1
	64, 64, 12, sizeof(SHA2_CTX),
d273 1
a273 1
	0, 16, 16, sizeof(MD5_CTX),
d280 1
a280 1
	0, 20, 20, sizeof(SHA1_CTX),
d287 1
a287 1
	0, 16, 16, sizeof(MD5_CTX),
d294 1
a294 1
	0, 20, 20, sizeof(SHA1_CTX),
@


1.35
log
@add myself to copyright
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.34 2008/06/09 16:07:00 djm Exp $	*/
d115 3
a117 3
int SHA256_Update_int(void *, const u_int8_t *, u_int16_t);
int SHA384_Update_int(void *, const u_int8_t *, u_int16_t);
int SHA512_Update_int(void *, const u_int8_t *, u_int16_t);
d252 3
a254 3
	32, 32, 12, sizeof(SHA256_CTX),
	(void (*)(void *)) SHA256_Init, SHA256_Update_int,
	(void (*)(u_int8_t *, void *)) SHA256_Final
d259 3
a261 3
	48, 48, 12, sizeof(SHA384_CTX),
	(void (*)(void *)) SHA384_Init, SHA384_Update_int,
	(void (*)(u_int8_t *, void *)) SHA384_Final
d266 3
a268 3
	64, 64, 12, sizeof(SHA512_CTX),
	(void (*)(void *)) SHA512_Init, SHA512_Update_int,
	(void (*)(u_int8_t *, void *)) SHA512_Final
d728 1
a728 1
SHA256_Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
d730 1
a730 1
	SHA256_Update(ctx, buf, len);
d735 1
a735 1
SHA384_Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
d737 1
a737 1
	SHA384_Update(ctx, buf, len);
d742 1
a742 1
SHA512_Update_int(void *ctx, const u_int8_t *buf, u_int16_t len)
d744 1
a744 1
	SHA512_Update(ctx, buf, len);
@


1.34
log
@Implement the AES XTS mode of operation for the crypto(9) framework.
XTS is a "tweaked" AES mode that has properties that are desirable
for block device encryption and it is specified in the IEEE
P1619-2007 standard for this purpose.

prodded by & ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.33 2007/09/13 21:26:41 hshoexer Exp $	*/
d4 3
a6 2
 * Angelos D. Keromytis (kermit@@csd.uch.gr) and
 * Niels Provos (provos@@physnet.uni-hamburg.de).
d19 2
d25 2
@


1.33
log
@Here too:  Convert MALLOC/FREE to malloc/free and use M_ZERO where applicable.

error spotting and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.32 2007/09/10 22:19:42 henric Exp $	*/
d71 3
d80 3
d89 5
d101 1
a101 1
void null_encrypt(caddr_t, u_int8_t *);
a102 2
int  null_setkey(u_int8_t **, u_int8_t *, int);
void null_decrypt(caddr_t, u_int8_t *);
d105 1
a105 1
void aes_ctr_crypt(caddr_t, u_int8_t *);
d118 4
d187 1
a187 1
	NULL,
d193 10
d596 100
@


1.32
log
@Make the hmac ipad/opad globals "const" and fixup the crypto functions
to match.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.31 2007/05/27 05:43:17 tedu Exp $	*/
d302 1
a302 2
	MALLOC(*sched, u_int8_t *, 128, M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, 128);
d316 1
a316 1
	FREE(*sched, M_CRYPTO_DATA);
d335 1
a335 2
	MALLOC(*sched, u_int8_t *, 384, M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, 384);
d350 1
a350 1
	FREE(*sched, M_CRYPTO_DATA);
d369 1
a369 2
	MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(blf_ctx));
d379 1
a379 1
	FREE(*sched, M_CRYPTO_DATA);
d419 1
a419 2
	MALLOC(*sched, u_int8_t *, sizeof(cast_key), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(cast_key));
d429 1
a429 1
	FREE(*sched, M_CRYPTO_DATA);
d448 2
a449 3
	MALLOC(*sched, u_int8_t *, 10 * sizeof(u_int8_t *), M_CRYPTO_DATA,
	    M_WAITOK);
	bzero(*sched, 10 * sizeof(u_int8_t *));
d463 1
a463 1
			FREE(((u_int8_t **)(*sched))[k], M_CRYPTO_DATA);
d467 1
a467 1
	FREE(*sched, M_CRYPTO_DATA);
d486 1
a486 3
	MALLOC(*sched, u_int8_t *, sizeof(rijndael_ctx), M_CRYPTO_DATA,
	    M_WAITOK);
	bzero(*sched, sizeof(rijndael_ctx));
d501 1
a501 1
	FREE(*sched, M_CRYPTO_DATA);
d553 2
a554 3
	MALLOC(*sched, u_int8_t *, sizeof(struct aes_ctr_ctx), M_CRYPTO_DATA,
	    M_WAITOK);
	bzero(*sched, sizeof(struct aes_ctr_ctx));
d570 1
a570 1
	FREE(*sched, M_CRYPTO_DATA);
@


1.31
log
@make the #defines in rijndael.h a bit more meaningful
ok djm and with a hint from henning
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.30 2007/02/19 08:55:41 hshoexer Exp $	*/
d98 6
a103 6
int MD5Update_int(void *, u_int8_t *, u_int16_t);
int SHA1Update_int(void *, u_int8_t *, u_int16_t);
int RMD160Update_int(void *, u_int8_t *, u_int16_t);
int SHA256_Update_int(void *, u_int8_t *, u_int16_t);
int SHA384_Update_int(void *, u_int8_t *, u_int16_t);
int SHA512_Update_int(void *, u_int8_t *, u_int16_t);
d587 1
a587 1
RMD160Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
d594 1
a594 1
MD5Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
d601 1
a601 1
SHA1Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
d608 1
a608 1
SHA256_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
d615 1
a615 1
SHA384_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
d622 1
a622 1
SHA512_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
@


1.30
log
@minimum blocksize for ESP is 32 bit, so adjust blocksize of NULL
encryption accordingly.  Makes NULL encryption useable with ESP.
Noticed by Martin Hedenfalk <martin.hedenfalk at gmail.com>.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.29 2005/05/25 05:47:53 markus Exp $	*/
d517 1
a517 1
	u_int32_t	ac_ek[4*(MAXNR + 1)];
@


1.29
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.28 2004/12/20 20:31:18 hshoexer Exp $	*/
d192 1
a192 1
	1, 0, 0, 256,
@


1.28
log
@Allow the setkey function of a transform to fail, eg. when an insufficient
number of key bits is supplied.

Only AES and DES/3DES might fail.

ok and help markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.27 2004/12/15 17:49:14 hshoexer Exp $	*/
d70 1
d89 1
d95 3
d112 1
a112 1
	8, 8, 8,
d117 1
d122 1
a122 1
	8, 24, 24,
d126 2
a127 1
	des3_zerokey
d132 1
a132 1
	8, 5, 56 /* 448 bits, max key */,
d136 2
a137 1
	blf_zerokey
d142 1
a142 1
	8, 5, 16,
d146 2
a147 1
	cast5_zerokey
d152 1
a152 1
	8, 10, 10,
d156 2
a157 1
	skipjack_zerokey
d162 1
a162 1
	16, 16, 32,
d167 11
d182 1
a182 1
	1, 1, 32,
d187 1
d192 1
a192 1
	8, 24, 24,
d197 1
d508 70
@


1.27
log
@minimum key length of aes is 128 bit, not 64.

ok markus
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.26 2004/06/26 05:05:12 hshoexer Exp $	*/
d63 7
a69 7
void des_set_key(caddr_t, caddr_t);
void des1_setkey(u_int8_t **, u_int8_t *, int);
void des3_setkey(u_int8_t **, u_int8_t *, int);
void blf_setkey(u_int8_t **, u_int8_t *, int);
void cast5_setkey(u_int8_t **, u_int8_t *, int);
void skipjack_setkey(u_int8_t **, u_int8_t *, int);
void rijndael128_setkey(u_int8_t **, u_int8_t *, int);
d90 1
a90 1
void null_setkey(u_int8_t **, u_int8_t *, int);
d276 1
a276 1
void
d281 7
a287 1
	des_set_key(key, *sched);
d310 1
a310 1
void
d315 8
a322 3
	des_set_key(key, *sched);
	des_set_key(key + 8, *sched + 128);
	des_set_key(key + 16, *sched + 256);
d345 1
a345 1
void
d351 2
d363 1
a363 1
void
d366 1
d396 1
a396 1
void
d402 2
d426 1
a426 1
void
d433 2
d465 1
a465 1
void
d471 8
a478 1
	rijndael_set_key((rijndael_ctx *) *sched, (u_char *) key, len * 8);
@


1.26
log
@Ansification of defalte-/lsz-stubs.

ok jfb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.25 2004/05/07 14:42:26 millert Exp $	*/
d152 1
a152 1
	16, 8, 32,
@


1.25
log
@Replace RSA-derived md5 code with code derived from Colin Plumb's PD version.
This moves md5.c out of libkern and into sys/crypto where it belongs (as
requested by markus@@).  Note that md5.c is still mandatory (dev/rnd.c uses it).
Verified with IPsec + hmac-md5 and tcp md5sig. OK henning@@ and hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.24 2003/12/26 10:04:49 markus Exp $	*/
d515 1
a515 4
deflate_compress(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
d521 1
a521 4
deflate_decompress(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
d527 1
a527 4
lzs_dummy(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
@


1.24
log
@- use 1/2 space for rijndael context in ipsec
- rijndael_set_key_enc_only()  sets up context for encryption only
- rijndael_set_key() always sets up full context
- rijndaelKeySetupDec() gets back original protoype
- uvm: use _enc_only() interface
with hshoexer@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.23 2003/07/24 08:03:19 itojun Exp $	*/
d48 1
a48 1
#include <sys/md5k.h>
@


1.23
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.22 2003/02/19 02:38:42 jason Exp $	*/
d444 1
a444 2
	rijndael_decrypt(((rijndael_ctx *) key) + 1, (u_char *) blk,
	    (u_char *) blk);
d450 1
a450 1
	MALLOC(*sched, u_int8_t *, 2 * sizeof(rijndael_ctx), M_CRYPTO_DATA,
d452 2
a453 4
	bzero(*sched, 2 * sizeof(rijndael_ctx));
	rijndael_set_key((rijndael_ctx *) *sched, (u_char *) key, len * 8, 1);
	rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u_char *) key,
	    len * 8, 0);
d459 1
a459 1
	bzero(*sched, 2 * sizeof(rijndael_ctx));
@


1.22
log
@lzs is lzs, lzs is not deflate
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.21 2003/02/15 22:57:58 jason Exp $	*/
d50 1
d96 3
d199 21
d489 21
@


1.21
log
@skeleton support for LZS compression
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.20 2002/11/12 18:23:13 jason Exp $	*/
d231 1
a231 1
	CRYPTO_DEFLATE_COMP, "LZS",
@


1.20
log
@Add a CRYPTO_NULL xform (it's a do nothing, but nice for measuring the
bandwidth of the kernel API).  It's only available from userland and
then only if kern.cryptodevallowsoft=1.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.19 2002/08/16 22:47:25 dhartmei Exp $	*/
d98 1
d230 6
d487 10
@


1.19
log
@fix size in MALLOC/bzero call, from sam@@errno.com, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.18 2002/04/22 23:10:09 deraadt Exp $	*/
d87 4
d163 9
d316 20
@


1.18
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.17 2002/03/05 15:59:41 markus Exp $	*/
d320 2
a321 2
	MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(blf_ctx));
@


1.17
log
@export MD5/SHA1 via /dev/crypto; ok provos@@, beck@@
tested with cryptosoft and kern.cryptodevallowsoft=1
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.16 2001/08/28 12:20:43 ben Exp $	*/
d182 1
a182 1
	CRYPTO_MD5_KPDK, "Keyed MD5", 
d185 1
a185 1
	(void (*)(u_int8_t *, void *)) MD5Final 
d192 1
a192 1
	(void (*)(u_int8_t *, void *)) SHA1Final 
d206 1
a206 1
	(void (*)(u_int8_t *, void *)) SHA1Final 
@


1.16
log
@Getting closer to working userland MAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.15 2001/08/24 15:59:42 markus Exp $	*/
d197 3
a199 2
	0, 16, 0, 0,
	NULL, NULL, NULL
d204 3
a206 2
	0, 20, 0, 0,
	NULL, NULL, NULL
@


1.16.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.16 2001/08/28 12:20:43 ben Exp $	*/
d182 1
a182 1
	CRYPTO_MD5_KPDK, "Keyed MD5",
d185 1
a185 1
	(void (*)(u_int8_t *, void *)) MD5Final
d192 1
a192 1
	(void (*)(u_int8_t *, void *)) SHA1Final
d197 2
a198 3
	0, 16, 16, sizeof(MD5_CTX),
	(void (*) (void *)) MD5Init, MD5Update_int,
	(void (*) (u_int8_t *, void *)) MD5Final
d203 2
a204 3
	0, 20, 20, sizeof(SHA1_CTX),
	(void (*)(void *)) SHA1Init, SHA1Update_int,
	(void (*)(u_int8_t *, void *)) SHA1Final
@


1.16.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.16.4.1 2002/06/11 03:28:34 art Exp $	*/
d320 2
a321 2
	MALLOC(*sched, u_int8_t *, sizeof(cast_key), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(cast_key));
@


1.16.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a86 4
void null_encrypt(caddr_t, u_int8_t *);
void null_zerokey(u_int8_t **);
void null_setkey(u_int8_t **, u_int8_t *, int);
void null_decrypt(caddr_t, u_int8_t *);
a93 1
u_int32_t lzs_dummy(u_int8_t *, u_int32_t, u_int8_t **);
a158 9
struct enc_xform enc_xform_null = {
	CRYPTO_NULL, "NULL",
	8, 24, 24,
	null_encrypt,
	null_decrypt,
	null_setkey,
	null_zerokey,
};

a215 6
struct comp_algo comp_algo_lzs = {
	CRYPTO_LZS_COMP, "LZS",
	90, lzs_dummy,
	lzs_dummy
};

a305 20
null_setkey(u_int8_t **sched, u_int8_t *key, int len)
{
}

void
null_zerokey(u_int8_t **sched)
{
}

void
null_encrypt(caddr_t key, u_int8_t *blk)
{
}

void
null_decrypt(caddr_t key, u_int8_t *blk)
{
}

void
a446 10
}

u_int32_t
lzs_dummy(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
{
	*out = NULL;
	return (0);
@


1.15
log
@switch to the optimised AES reference code from
http://www.esat.kuleuven.ac.be/~rijmen/rijndael/rijndael-fst-3.0.zip
the same code is used by ssh, so please make sure to update
usr.sbin/ssh/rijndael.c if you change this code.
tested on sparc (jason) and with swap encryption (me); ok deraadt@@, provos@@
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.14 2001/08/17 17:37:12 ben Exp $	*/
d193 12
@


1.14
log
@Add RC4 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.13 2001/08/08 15:12:09 jjbg Exp $	*/
d359 1
a359 1
	rijndael_encrypt((rijndael_ctx *) key, (u4byte *) blk, (u4byte *) blk);
d365 2
a366 2
	rijndael_decrypt(((rijndael_ctx *) key) + 1, (u4byte *) blk,
	    (u4byte *) blk);
d375 2
a376 2
	rijndael_set_key((rijndael_ctx *) *sched, (u4byte *) key, len * 8, 1);
	rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u4byte *) key,
@


1.13
log
@remove IPCOMP. derradt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.12 2001/07/05 17:53:28 deraadt Exp $	*/
d148 9
@


1.12
log
@#ifdef IPCOMP stuff properly
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.11 2001/07/05 16:44:00 jjbg Exp $	*/
a185 1
#ifdef IPCOMP
a191 1
#endif
a403 2
#ifdef IPCOMP

a424 2

#endif
@


1.11
log
@Support for compression. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.10 2001/06/27 04:57:08 angelos Exp $	*/
d186 1
d193 1
d406 2
d429 2
@


1.10
log
@Indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.9 2001/06/25 05:02:22 angelos Exp $	*/
d57 1
d92 3
d186 7
d402 22
@


1.9
log
@Update copyright; you can use this with or without fee (unless your
name is Theo Deraadt)
@
text
@d1 1
a1 2
/*	$OpenBSD: xform.c,v 1.8 2001/06/23 18:30:36 deraadt Exp $	*/

d356 2
a357 1
	rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u4byte *) key, len * 8, 0);
a391 1

@


1.8
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.7 2001/06/16 22:17:50 deraadt Exp $	*/
d22 3
a24 1
 * Permission to use, copy, and modify this software without fee
@


1.7
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.6 2001/06/13 13:43:34 angelos Exp $	*/
d54 1
a54 1
#include <crypto/crypto.h>
@


1.6
log
@ivmask has been deprecated.
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.5 2001/05/05 00:31:34 angelos Exp $	*/
d91 52
a142 58
struct enc_xform enc_xform_des =
{
    CRYPTO_DES_CBC, "DES",
    8, 8, 8,
    des1_encrypt,
    des1_decrypt,
    des1_setkey,
    des1_zerokey,
};

struct enc_xform enc_xform_3des =
{
    CRYPTO_3DES_CBC, "3DES",
    8, 24, 24,
    des3_encrypt,
    des3_decrypt,
    des3_setkey,
    des3_zerokey
};

struct enc_xform enc_xform_blf =
{
    CRYPTO_BLF_CBC, "Blowfish",
    8, 5, 56 /* 448 bits, max key */,
    blf_encrypt,
    blf_decrypt,
    blf_setkey,
    blf_zerokey
};

struct enc_xform enc_xform_cast5 =
{
    CRYPTO_CAST_CBC, "CAST-128",
    8, 5, 16,
    cast5_encrypt,
    cast5_decrypt,
    cast5_setkey,
    cast5_zerokey
};

struct enc_xform enc_xform_skipjack =
{
    CRYPTO_SKIPJACK_CBC, "Skipjack",
    8, 10, 10,
    skipjack_encrypt,
    skipjack_decrypt,
    skipjack_setkey,
    skipjack_zerokey
};

struct enc_xform enc_xform_rijndael128 =
{
    CRYPTO_RIJNDAEL128_CBC, "Rijndael-128/AES",
    16, 8, 32,
    rijndael128_encrypt,
    rijndael128_decrypt,
    rijndael128_setkey,
    rijndael128_zerokey,
d146 33
a178 38
struct auth_hash auth_hash_hmac_md5_96 =
{
    CRYPTO_MD5_HMAC, "HMAC-MD5",
    16, 16, 12, sizeof(MD5_CTX),
    (void (*) (void *)) MD5Init, MD5Update_int,
    (void (*) (u_int8_t *, void *)) MD5Final
};

struct auth_hash auth_hash_hmac_sha1_96 =
{
    CRYPTO_SHA1_HMAC, "HMAC-SHA1",
    20, 20, 12, sizeof(SHA1_CTX),
    (void (*) (void *)) SHA1Init, SHA1Update_int,
     (void (*) (u_int8_t *, void *)) SHA1Final
};

struct auth_hash auth_hash_hmac_ripemd_160_96 =
{
    CRYPTO_RIPEMD160_HMAC, "HMAC-RIPEMD-160",
    20, 20, 12, sizeof(RMD160_CTX),
    (void (*)(void *)) RMD160Init, RMD160Update_int,
    (void (*)(u_int8_t *, void *)) RMD160Final
};

struct auth_hash auth_hash_key_md5 =
{
    CRYPTO_MD5_KPDK, "Keyed MD5", 
    0, 16, 16, sizeof(MD5_CTX),
    (void (*)(void *)) MD5Init, MD5Update_int,
    (void (*)(u_int8_t *, void *)) MD5Final 
};

struct auth_hash auth_hash_key_sha1 =
{
    CRYPTO_SHA1_KPDK, "Keyed SHA1",
    0, 20, 20, sizeof(SHA1_CTX),
    (void (*)(void *)) SHA1Init, SHA1Update_int,
    (void (*)(u_int8_t *, void *)) SHA1Final 
d187 1
a187 1
    des_ecb_encrypt(blk, blk, key, 1);
d193 1
a193 1
    des_ecb_encrypt(blk, blk, key, 0);
d199 3
a201 3
    MALLOC(*sched, u_int8_t *, 128, M_CRYPTO_DATA, M_WAITOK);
    bzero(*sched, 128);
    des_set_key(key, *sched);
d207 3
a209 3
    bzero(*sched, 128);
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d215 1
a215 1
    des_ecb3_encrypt(blk, blk, key, key + 128, key + 256, 1);
d221 1
a221 1
    des_ecb3_encrypt(blk, blk, key + 256, key + 128, key, 0);
d227 5
a231 5
    MALLOC(*sched, u_int8_t *, 384, M_CRYPTO_DATA, M_WAITOK);
    bzero(*sched, 384);
    des_set_key(key, *sched);
    des_set_key(key + 8, *sched + 128);
    des_set_key(key + 16, *sched + 256);
d237 3
a239 3
    bzero(*sched, 384);
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d245 1
a245 1
    blf_ecb_encrypt((blf_ctx *) key, blk, 8);
d251 1
a251 1
    blf_ecb_decrypt((blf_ctx *) key, blk, 8);
d257 3
a259 3
    MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
    bzero(*sched, sizeof(blf_ctx));
    blf_key((blf_ctx *)*sched, key, len);
d265 3
a267 3
    bzero(*sched, sizeof(blf_ctx));
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d273 1
a273 1
    cast_encrypt((cast_key *) key, blk, blk);
d279 1
a279 1
    cast_decrypt((cast_key *) key, blk, blk);
d285 3
a287 3
    MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
    bzero(*sched, sizeof(blf_ctx));
    cast_setkey((cast_key *)*sched, key, len);
d293 3
a295 3
    bzero(*sched, sizeof(cast_key));
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d301 1
a301 1
    skipjack_forwards(blk, blk, (u_int8_t **) key);
d307 1
a307 1
    skipjack_backwards(blk, blk, (u_int8_t **) key);
d313 4
a316 4
    MALLOC(*sched, u_int8_t *, 10 * sizeof(u_int8_t *), M_CRYPTO_DATA,
	   M_WAITOK);
    bzero(*sched, 10 * sizeof(u_int8_t *));
    subkey_table_gen(key, (u_int8_t **) *sched);
d322 1
a322 1
    int k;
d324 5
a328 5
    for (k = 0; k < 10; k++)
	if (((u_int8_t **)(*sched))[k])
	{
	    bzero(((u_int8_t **)(*sched))[k], 0x100);
	    FREE(((u_int8_t **)(*sched))[k], M_CRYPTO_DATA);
d330 3
a332 3
    bzero(*sched, 10 * sizeof(u_int8_t *));
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d338 1
a338 1
    rijndael_encrypt((rijndael_ctx *) key, (u4byte *) blk, (u4byte *) blk);
d344 2
a345 2
    rijndael_decrypt(((rijndael_ctx *) key) + 1, (u4byte *) blk,
                     (u4byte *) blk);
d351 5
a355 5
    MALLOC(*sched, u_int8_t *, 2 * sizeof(rijndael_ctx), M_CRYPTO_DATA,
	   M_WAITOK);
    bzero(*sched, 2 * sizeof(rijndael_ctx));
    rijndael_set_key((rijndael_ctx *) *sched, (u4byte *) key, len * 8, 1);
    rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u4byte *) key, len * 8, 0);
d361 3
a363 3
    bzero(*sched, 2 * sizeof(rijndael_ctx));
    FREE(*sched, M_CRYPTO_DATA);
    *sched = NULL;
d373 2
a374 2
    RMD160Update(ctx, buf, len);
    return 0;
d380 2
a381 2
    MD5Update(ctx, buf, len);
    return 0;
d387 2
a388 2
    SHA1Update(ctx, buf, len);
    return 0;
@


1.5
log
@Use the M_CRYPTO_DATA and M_CRYPTO_OPS malloc types.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 1
a94 1
    8, 8, 8, 8,
d104 1
a104 1
    8, 24, 24, 8,
d114 1
a114 1
    8, 5, 56 /* 448 bits, max key */, 8,
d124 1
a124 1
    8, 5, 16, 8,
d134 1
a134 1
    8, 10, 10, 8,
d144 1
a144 1
    16, 8, 32, 16,
@


1.4
log
@*HMAC96->*HMAC
@
text
@d210 1
a210 1
    MALLOC(*sched, u_int8_t *, 128, M_XDATA, M_WAITOK);
d219 1
a219 1
    FREE(*sched, M_XDATA);
d238 1
a238 1
    MALLOC(*sched, u_int8_t *, 384, M_XDATA, M_WAITOK);
d249 1
a249 1
    FREE(*sched, M_XDATA);
d268 1
a268 1
    MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_XDATA, M_WAITOK);
d277 1
a277 1
    FREE(*sched, M_XDATA);
d296 1
a296 1
    MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_XDATA, M_WAITOK);
d305 1
a305 1
    FREE(*sched, M_XDATA);
d324 2
a325 1
    MALLOC(*sched, u_int8_t *, 10 * sizeof(u_int8_t *), M_XDATA, M_WAITOK);
d339 1
a339 1
	    FREE(((u_int8_t **)(*sched))[k], M_XDATA);
d342 1
a342 1
    FREE(*sched, M_XDATA);
d362 2
a363 1
    MALLOC(*sched, u_int8_t *, 2 * sizeof(rijndael_ctx), M_XDATA, M_WAITOK);
d373 1
a373 1
    FREE(*sched, M_XDATA);
@


1.3
log
@AES alias for Rijndael, also adjust the name.
@
text
@d154 1
a154 1
    CRYPTO_MD5_HMAC96, "HMAC-MD5-96",
d162 1
a162 1
    CRYPTO_SHA1_HMAC96, "HMAC-SHA1-96",
d170 1
a170 1
    CRYPTO_RIPEMD160_HMAC96, "HMAC-RIPEMD-160-96",
@


1.2
log
@Add Rijndael (128-bit blocksize) in the software crypto driver.

Hacking at OpenBSD Crypto 2000 :-)
@
text
@d143 1
a143 1
    CRYPTO_RIJNDAEL128_CBC, "Rijndael-128",
@


1.1
log
@Cryptographic services framework, and software "device driver". The
idea is to support various cryptographic hardware accelerators (which
may be (detachable) cards, secondary/tertiary/etc processors,
software crypto, etc). Supports session migration between crypto
devices. What it doesn't (yet) support:
 - multiple instances of the same algorithm used in the same session
 - use of multiple crypto drivers in the same session
 - asymmetric crypto

No support for a userland device yet.

IPsec code path modified to allow for asynchronous cryptography
(callbacks used in both input and output processing). Some unrelated
code simplification done in the process (especially for AH).

Development of this code kindly supported by Network Security
Technologies (NSTI). The code was writen mostly in Greece, and is
being committed from Montreal.
@
text
@d1 1
a1 1
/*	$OpenBSD: ip_xform.c,v 1.6 2000/03/10 03:51:59 deraadt Exp $	*/
d53 1
d66 1
d72 1
d78 1
d84 1
d141 10
d341 30
@


1.1.2.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.1.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@a52 1
#include <crypto/rijndael.h>
a64 1
void rijndael128_setkey(u_int8_t **, u_int8_t *, int);
a69 1
void rijndael128_encrypt(caddr_t, u_int8_t *);
a74 1
void rijndael128_decrypt(caddr_t, u_int8_t *);
a79 1
void rijndael128_zerokey(u_int8_t **);
a135 10
struct enc_xform enc_xform_rijndael128 =
{
    CRYPTO_RIJNDAEL128_CBC, "Rijndael-128/AES",
    16, 8, 32, 16,
    rijndael128_encrypt,
    rijndael128_decrypt,
    rijndael128_setkey,
    rijndael128_zerokey,
};

d139 1
a139 1
    CRYPTO_MD5_HMAC, "HMAC-MD5",
d147 1
a147 1
    CRYPTO_SHA1_HMAC, "HMAC-SHA1",
d155 1
a155 1
    CRYPTO_RIPEMD160_HMAC, "HMAC-RIPEMD-160",
a325 30
    FREE(*sched, M_XDATA);
    *sched = NULL;
}

void
rijndael128_encrypt(caddr_t key, u_int8_t *blk)
{
    rijndael_encrypt((rijndael_ctx *) key, (u4byte *) blk, (u4byte *) blk);
}

void
rijndael128_decrypt(caddr_t key, u_int8_t *blk)
{
    rijndael_decrypt(((rijndael_ctx *) key) + 1, (u4byte *) blk,
                     (u4byte *) blk);
}

void
rijndael128_setkey(u_int8_t **sched, u_int8_t *key, int len)
{
    MALLOC(*sched, u_int8_t *, 2 * sizeof(rijndael_ctx), M_XDATA, M_WAITOK);
    bzero(*sched, 2 * sizeof(rijndael_ctx));
    rijndael_set_key((rijndael_ctx *) *sched, (u4byte *) key, len * 8, 1);
    rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u4byte *) key, len * 8, 0);
}

void
rijndael128_zerokey(u_int8_t **sched)
{
    bzero(*sched, 2 * sizeof(rijndael_ctx));
@


1.1.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
d22 1
a22 3
 * Copyright (C) 2001, Angelos D. Keromytis.
 *
 * Permission to use, copy, and modify this software with or without fee
d54 1
a54 1
#include <crypto/cryptodev.h>
d91 58
a148 52
struct enc_xform enc_xform_des = {
	CRYPTO_DES_CBC, "DES",
	8, 8, 8,
	des1_encrypt,
	des1_decrypt,
	des1_setkey,
	des1_zerokey,
};

struct enc_xform enc_xform_3des = {
	CRYPTO_3DES_CBC, "3DES",
	8, 24, 24,
	des3_encrypt,
	des3_decrypt,
	des3_setkey,
	des3_zerokey
};

struct enc_xform enc_xform_blf = {
	CRYPTO_BLF_CBC, "Blowfish",
	8, 5, 56 /* 448 bits, max key */,
	blf_encrypt,
	blf_decrypt,
	blf_setkey,
	blf_zerokey
};

struct enc_xform enc_xform_cast5 = {
	CRYPTO_CAST_CBC, "CAST-128",
	8, 5, 16,
	cast5_encrypt,
	cast5_decrypt,
	cast5_setkey,
	cast5_zerokey
};

struct enc_xform enc_xform_skipjack = {
	CRYPTO_SKIPJACK_CBC, "Skipjack",
	8, 10, 10,
	skipjack_encrypt,
	skipjack_decrypt,
	skipjack_setkey,
	skipjack_zerokey
};

struct enc_xform enc_xform_rijndael128 = {
	CRYPTO_RIJNDAEL128_CBC, "Rijndael-128/AES",
	16, 8, 32,
	rijndael128_encrypt,
	rijndael128_decrypt,
	rijndael128_setkey,
	rijndael128_zerokey,
d152 38
a189 33
struct auth_hash auth_hash_hmac_md5_96 = {
	CRYPTO_MD5_HMAC, "HMAC-MD5",
	16, 16, 12, sizeof(MD5_CTX),
	(void (*) (void *)) MD5Init, MD5Update_int,
	(void (*) (u_int8_t *, void *)) MD5Final
};

struct auth_hash auth_hash_hmac_sha1_96 = {
	CRYPTO_SHA1_HMAC, "HMAC-SHA1",
	20, 20, 12, sizeof(SHA1_CTX),
	(void (*) (void *)) SHA1Init, SHA1Update_int,
	(void (*) (u_int8_t *, void *)) SHA1Final
};

struct auth_hash auth_hash_hmac_ripemd_160_96 = {
	CRYPTO_RIPEMD160_HMAC, "HMAC-RIPEMD-160",
	20, 20, 12, sizeof(RMD160_CTX),
	(void (*)(void *)) RMD160Init, RMD160Update_int,
	(void (*)(u_int8_t *, void *)) RMD160Final
};

struct auth_hash auth_hash_key_md5 = {
	CRYPTO_MD5_KPDK, "Keyed MD5", 
	0, 16, 16, sizeof(MD5_CTX),
	(void (*)(void *)) MD5Init, MD5Update_int,
	(void (*)(u_int8_t *, void *)) MD5Final 
};

struct auth_hash auth_hash_key_sha1 = {
	CRYPTO_SHA1_KPDK, "Keyed SHA1",
	0, 20, 20, sizeof(SHA1_CTX),
	(void (*)(void *)) SHA1Init, SHA1Update_int,
	(void (*)(u_int8_t *, void *)) SHA1Final 
d198 1
a198 1
	des_ecb_encrypt(blk, blk, key, 1);
d204 1
a204 1
	des_ecb_encrypt(blk, blk, key, 0);
d210 3
a212 3
	MALLOC(*sched, u_int8_t *, 128, M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, 128);
	des_set_key(key, *sched);
d218 3
a220 3
	bzero(*sched, 128);
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d226 1
a226 1
	des_ecb3_encrypt(blk, blk, key, key + 128, key + 256, 1);
d232 1
a232 1
	des_ecb3_encrypt(blk, blk, key + 256, key + 128, key, 0);
d238 5
a242 5
	MALLOC(*sched, u_int8_t *, 384, M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, 384);
	des_set_key(key, *sched);
	des_set_key(key + 8, *sched + 128);
	des_set_key(key + 16, *sched + 256);
d248 3
a250 3
	bzero(*sched, 384);
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d256 1
a256 1
	blf_ecb_encrypt((blf_ctx *) key, blk, 8);
d262 1
a262 1
	blf_ecb_decrypt((blf_ctx *) key, blk, 8);
d268 3
a270 3
	MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(blf_ctx));
	blf_key((blf_ctx *)*sched, key, len);
d276 3
a278 3
	bzero(*sched, sizeof(blf_ctx));
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d284 1
a284 1
	cast_encrypt((cast_key *) key, blk, blk);
d290 1
a290 1
	cast_decrypt((cast_key *) key, blk, blk);
d296 3
a298 3
	MALLOC(*sched, u_int8_t *, sizeof(blf_ctx), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(blf_ctx));
	cast_setkey((cast_key *)*sched, key, len);
d304 3
a306 3
	bzero(*sched, sizeof(cast_key));
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d312 1
a312 1
	skipjack_forwards(blk, blk, (u_int8_t **) key);
d318 1
a318 1
	skipjack_backwards(blk, blk, (u_int8_t **) key);
d324 3
a326 4
	MALLOC(*sched, u_int8_t *, 10 * sizeof(u_int8_t *), M_CRYPTO_DATA,
	    M_WAITOK);
	bzero(*sched, 10 * sizeof(u_int8_t *));
	subkey_table_gen(key, (u_int8_t **) *sched);
d332 1
a332 1
	int k;
d334 5
a338 5
	for (k = 0; k < 10; k++) {
		if (((u_int8_t **)(*sched))[k]) {
			bzero(((u_int8_t **)(*sched))[k], 0x100);
			FREE(((u_int8_t **)(*sched))[k], M_CRYPTO_DATA);
		}
d340 3
a342 3
	bzero(*sched, 10 * sizeof(u_int8_t *));
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d348 1
a348 1
	rijndael_encrypt((rijndael_ctx *) key, (u4byte *) blk, (u4byte *) blk);
d354 2
a355 2
	rijndael_decrypt(((rijndael_ctx *) key) + 1, (u4byte *) blk,
	    (u4byte *) blk);
d361 4
a364 6
	MALLOC(*sched, u_int8_t *, 2 * sizeof(rijndael_ctx), M_CRYPTO_DATA,
	    M_WAITOK);
	bzero(*sched, 2 * sizeof(rijndael_ctx));
	rijndael_set_key((rijndael_ctx *) *sched, (u4byte *) key, len * 8, 1);
	rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u4byte *) key,
	    len * 8, 0);
d370 3
a372 3
	bzero(*sched, 2 * sizeof(rijndael_ctx));
	FREE(*sched, M_CRYPTO_DATA);
	*sched = NULL;
d382 2
a383 2
	RMD160Update(ctx, buf, len);
	return 0;
d389 2
a390 2
	MD5Update(ctx, buf, len);
	return 0;
d396 2
a397 2
	SHA1Update(ctx, buf, len);
	return 0;
d399 1
@


1.1.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: xform.c,v 1.1.2.3 2001/07/04 10:40:04 niklas Exp $	*/
a56 1
#include <crypto/deflate.h>
a90 3
u_int32_t deflate_compress(u_int8_t *, u_int32_t, u_int8_t **);
u_int32_t deflate_decompress(u_int8_t *, u_int32_t, u_int8_t **);

a145 9
struct enc_xform enc_xform_arc4 = {
	CRYPTO_ARC4, "ARC4",
	1, 1, 32,
	NULL,
	NULL,
	NULL,
	NULL,
};

a181 19
struct auth_hash auth_hash_md5 = {
	CRYPTO_MD5, "MD5",
	0, 16, 0, 0,
	NULL, NULL, NULL
};

struct auth_hash auth_hash_sha1 = {
	CRYPTO_SHA1, "SHA1",
	0, 20, 0, 0,
	NULL, NULL, NULL
};

/* Compression instance */
struct comp_algo comp_algo_deflate = {
	CRYPTO_DEFLATE_COMP, "Deflate",
	90, deflate_compress,
	deflate_decompress
};

d339 1
a339 1
	rijndael_encrypt((rijndael_ctx *) key, (u_char *) blk, (u_char *) blk);
d345 2
a346 2
	rijndael_decrypt(((rijndael_ctx *) key) + 1, (u_char *) blk,
	    (u_char *) blk);
d355 2
a356 2
	rijndael_set_key((rijndael_ctx *) *sched, (u_char *) key, len * 8, 1);
	rijndael_set_key(((rijndael_ctx *) *sched) + 1, (u_char *) key,
a390 22
}

/*
 * And compression
 */

u_int32_t
deflate_compress(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
{
	return deflate_global(data, size, 0, out);
}

u_int32_t
deflate_decompress(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
{
	return deflate_global(data, size, 1, out);
@


1.1.2.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d197 2
a198 3
	0, 16, 16, sizeof(MD5_CTX),
	(void (*) (void *)) MD5Init, MD5Update_int,
	(void (*) (u_int8_t *, void *)) MD5Final
d203 2
a204 3
	0, 20, 20, sizeof(SHA1_CTX),
	(void (*)(void *)) SHA1Init, SHA1Update_int,
	(void (*)(u_int8_t *, void *)) SHA1Final 
@


1.1.2.6
log
@Sync the SMP branch with 3.3
@
text
@a86 4
void null_encrypt(caddr_t, u_int8_t *);
void null_zerokey(u_int8_t **);
void null_setkey(u_int8_t **, u_int8_t *, int);
void null_decrypt(caddr_t, u_int8_t *);
a93 1
u_int32_t lzs_dummy(u_int8_t *, u_int32_t, u_int8_t **);
a158 9
struct enc_xform enc_xform_null = {
	CRYPTO_NULL, "NULL",
	8, 24, 24,
	null_encrypt,
	null_decrypt,
	null_setkey,
	null_zerokey,
};

d182 1
a182 1
	CRYPTO_MD5_KPDK, "Keyed MD5",
d185 1
a185 1
	(void (*)(u_int8_t *, void *)) MD5Final
d192 1
a192 1
	(void (*)(u_int8_t *, void *)) SHA1Final
d206 1
a206 1
	(void (*)(u_int8_t *, void *)) SHA1Final
a215 6
struct comp_algo comp_algo_lzs = {
	CRYPTO_LZS_COMP, "LZS",
	90, lzs_dummy,
	lzs_dummy
};

a305 20
null_setkey(u_int8_t **sched, u_int8_t *key, int len)
{
}

void
null_zerokey(u_int8_t **sched)
{
}

void
null_encrypt(caddr_t key, u_int8_t *blk)
{
}

void
null_decrypt(caddr_t key, u_int8_t *blk)
{
}

void
d320 2
a321 2
	MALLOC(*sched, u_int8_t *, sizeof(cast_key), M_CRYPTO_DATA, M_WAITOK);
	bzero(*sched, sizeof(cast_key));
a446 10
}

u_int32_t
lzs_dummy(data, size, out)
	u_int8_t *data;
	u_int32_t size;
	u_int8_t **out;
{
	*out = NULL;
	return (0);
@


1.1.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a49 1
#include <crypto/sha2.h>
a94 3
int SHA256_Update_int(void *, u_int8_t *, u_int16_t);
int SHA384_Update_int(void *, u_int8_t *, u_int16_t);
int SHA512_Update_int(void *, u_int8_t *, u_int16_t);
a194 21
struct auth_hash auth_hash_hmac_sha2_256_96 = {
	CRYPTO_SHA2_256_HMAC, "HMAC-SHA2-256",
	32, 32, 12, sizeof(SHA256_CTX),
	(void (*)(void *)) SHA256_Init, SHA256_Update_int,
	(void (*)(u_int8_t *, void *)) SHA256_Final
};

struct auth_hash auth_hash_hmac_sha2_384_96 = {
	CRYPTO_SHA2_384_HMAC, "HMAC-SHA2-384",
	48, 48, 12, sizeof(SHA384_CTX),
	(void (*)(void *)) SHA384_Init, SHA384_Update_int,
	(void (*)(u_int8_t *, void *)) SHA384_Final
};

struct auth_hash auth_hash_hmac_sha2_512_96 = {
	CRYPTO_SHA2_512_HMAC, "HMAC-SHA2-512",
	64, 64, 12, sizeof(SHA512_CTX),
	(void (*)(void *)) SHA512_Init, SHA512_Update_int,
	(void (*)(u_int8_t *, void *)) SHA512_Final
};

d419 2
a420 1
	rijndael_decrypt((rijndael_ctx *) key, (u_char *) blk, (u_char *) blk);
d426 1
a426 1
	MALLOC(*sched, u_int8_t *, sizeof(rijndael_ctx), M_CRYPTO_DATA,
d428 4
a431 2
	bzero(*sched, sizeof(rijndael_ctx));
	rijndael_set_key((rijndael_ctx *) *sched, (u_char *) key, len * 8);
d437 1
a437 1
	bzero(*sched, sizeof(rijndael_ctx));
a463 21
	return 0;
}

int
SHA256_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
{
	SHA256_Update(ctx, buf, len);
	return 0;
}

int
SHA384_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
{
	SHA384_Update(ctx, buf, len);
	return 0;
}

int
SHA512_Update_int(void *ctx, u_int8_t *buf, u_int16_t len)
{
	SHA512_Update(ctx, buf, len);
@


1.1.2.8
log
@Merge with the trunk
@
text
@d48 1
a48 1
#include <crypto/md5.h>
@


