head	1.70;
access;
symbols
	OPENBSD_6_1:1.70.0.2
	OPENBSD_6_1_BASE:1.70
	OPENBSD_6_0:1.68.0.2
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.60.0.6
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.58.0.6
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.58.0.4
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.56.0.4
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.2
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.6
	OPENBSD_5_0:1.55.0.4
	OPENBSD_5_0_BASE:1.55
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.51.0.2
	OPENBSD_4_8_BASE:1.51
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.47.0.8
	OPENBSD_4_6_BASE:1.47
	OPENBSD_4_5:1.47.0.4
	OPENBSD_4_5_BASE:1.47
	OPENBSD_4_4:1.47.0.2
	OPENBSD_4_4_BASE:1.47
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.45.0.2
	OPENBSD_4_2_BASE:1.45
	OPENBSD_4_1:1.44.0.4
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.43.0.4
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.43.0.2
	OPENBSD_3_8_BASE:1.43
	OPENBSD_3_7:1.42.0.8
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.42.0.6
	OPENBSD_3_6_BASE:1.42
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	OPENBSD_3_5:1.42.0.4
	OPENBSD_3_5_BASE:1.42
	OPENBSD_3_4:1.42.0.2
	OPENBSD_3_4_BASE:1.42
	UBC_SYNC_A:1.37
	OPENBSD_3_3:1.37.0.2
	OPENBSD_3_3_BASE:1.37
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.33
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	SMP:1.9.0.2;
locks; strict;
comment	@ * @;


1.70
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.69;
commitid	dMJlqKWYCJoMV7JN;

1.69
date	2017.02.07.15.10.48;	author bluhm;	state Exp;
branches;
next	1.68;
commitid	7vg8X7gfUc0w7Qc8;

1.68
date	2016.04.18.21.05.55;	author kettenis;	state Exp;
branches;
next	1.67;
commitid	E50p5lFUXDjjcPsS;

1.67
date	2015.12.10.21.00.51;	author naddy;	state Exp;
branches;
next	1.66;
commitid	T0HbsCFlrwPATHlH;

1.66
date	2015.11.13.15.29.55;	author naddy;	state Exp;
branches;
next	1.65;
commitid	kI77GdyYKaka3fwk;

1.65
date	2015.11.13.12.21.16;	author mikeb;	state Exp;
branches;
next	1.64;
commitid	YLaQcqVfNSwoLvqJ;

1.64
date	2015.11.12.16.57.00;	author mikeb;	state Exp;
branches;
next	1.63;
commitid	AJi1Y8XIoDdjU0oD;

1.63
date	2015.11.12.16.50.55;	author mikeb;	state Exp;
branches;
next	1.62;
commitid	gf70yBQxrbRCQQTv;

1.62
date	2015.11.03.01.55.28;	author mikeb;	state Exp;
branches;
next	1.61;
commitid	TU44v05z438jEucf;

1.61
date	2015.11.03.01.31.36;	author mikeb;	state Exp;
branches;
next	1.60;
commitid	jsYuUjxp9lhd0Ksp;

1.60
date	2014.12.28.10.02.37;	author tedu;	state Exp;
branches;
next	1.59;
commitid	cPvnXrnDy9of9D0l;

1.59
date	2014.08.20.06.23.03;	author mikeb;	state Exp;
branches;
next	1.58;
commitid	3nalvU8sn6rZiZ1d;

1.58
date	2013.10.31.10.32.38;	author mikeb;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.27.16.42.05;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2012.06.29.14.48.04;	author mikeb;	state Exp;
branches;
next	1.55;

1.55
date	2010.12.16.16.56.08;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.16.00.07.25;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2010.10.06.22.19.20;	author mikeb;	state Exp;
branches;
next	1.52;

1.52
date	2010.09.22.11.54.23;	author mikeb;	state Exp;
branches;
next	1.51;

1.51
date	2010.06.23.09.26.32;	author thib;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.09.19.38.19;	author thib;	state Exp;
branches;
next	1.49;

1.49
date	2010.01.10.12.43.07;	author markus;	state Exp;
branches;
next	1.48;

1.48
date	2009.09.03.07.47.27;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2008.06.09.16.07.00;	author djm;	state Exp;
branches;
next	1.46;

1.46
date	2007.11.28.13.52.23;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.27.05.33.47;	author tedu;	state Exp;
branches;
next	1.44;

1.44
date	2006.05.31.23.01.44;	author tedu;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.25.05.47.53;	author markus;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.14.15.18.05;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.24.15.29.38;	author markus;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.24.08.03.19;	author itojun;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.03.15.51.28;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.03.15.28.06;	author beck;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.15.22.57.58;	author jason;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.15.18.55.50;	author jason;	state Exp;
branches;
next	1.35;

1.35
date	2002.11.21.19.34.25;	author jason;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.12.18.23.13;	author jason;	state Exp;
branches;
next	1.33;

1.33
date	2002.07.17.23.52.39;	author art;	state Exp;
branches;
next	1.32;

1.32
date	2002.07.16.06.10.58;	author angelos;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.11.11.14.29;	author beck;	state Exp;
branches;
next	1.30;

1.30
date	2002.06.09.22.23.17;	author angelos;	state Exp;
branches;
next	1.29;

1.29
date	2002.05.18.17.00.33;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.18.09.58.12;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2002.04.24.23.24.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.23.22.20.47;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.23.19.13.04;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2002.04.08.17.49.42;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.01.26.51;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.04.21.24.11;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.02.23.00.30;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.02.19.15.11;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.01.02.50.02;	author provos;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.01.02.46.57;	author provos;	state Exp;
branches;
next	1.17;

1.17
date	2002.02.24.00.30.00;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.29.15.48.29;	author jason;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.09.03.11.38;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.08.28.12.20.43;	author ben;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.08.22.17.34.35;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.05.09.36.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.05.08.34.12;	author angelos;	state Exp;
branches;
next	1.10;

1.10
date	2001.07.05.08.26.05;	author jjbg;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.25.17.52.37;	author angelos;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.06.25.17.35.47;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.24.22.11.02;	author angelos;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.23.21.57.00;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	2001.06.23.21.00.49;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.18.30.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.01.23.51.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.13.16.52.33;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.13.15.39.27;	author deraadt;	state Exp;
branches;
next	;

1.9.2.1
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2002.03.28.11.43.03;	author niklas;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.9.2.6;

1.9.2.6
date	2003.06.07.11.02.27;	author ho;	state Exp;
branches;
next	1.9.2.7;

1.9.2.7
date	2004.02.19.10.51.30;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2001.12.14.21.48.07;	author jason;	state Exp;
branches;
next	;

1.15.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.06.11.03.28.34;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.05.19.21.53.13;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.70
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@/*	$OpenBSD: cryptodev.h,v 1.69 2017/02/07 15:10:48 bluhm Exp $	*/

/*
 * The author of this code is Angelos D. Keromytis (angelos@@cis.upenn.edu)
 *
 * This code was written by Angelos D. Keromytis in Athens, Greece, in
 * February 2000. Network Security Technologies Inc. (NSTI) kindly
 * supported the development of this code.
 *
 * Copyright (c) 2000 Angelos D. Keromytis
 *
 * Permission to use, copy, and modify this software with or without fee
 * is hereby granted, provided that this entire notice is included in
 * all source code copies of any software which is or includes a copy or
 * modification of this software.
 *
 * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTY. IN PARTICULAR, NONE OF THE AUTHORS MAKES ANY
 * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE
 * MERCHANTABILITY OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR
 * PURPOSE.
 *
 * Copyright (c) 2001 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
 */

#ifndef _CRYPTO_CRYPTO_H_
#define _CRYPTO_CRYPTO_H_

#include <sys/ioccom.h>
#include <sys/task.h>

/* Some initial values */
#define CRYPTO_DRIVERS_INITIAL	4
#define CRYPTO_DRIVERS_MAX	128
#define CRYPTO_SW_SESSIONS	32

/* HMAC values */
#define HMAC_MD5_BLOCK_LEN	64
#define HMAC_SHA1_BLOCK_LEN	64
#define HMAC_RIPEMD160_BLOCK_LEN 64
#define HMAC_SHA2_256_BLOCK_LEN	64
#define HMAC_SHA2_384_BLOCK_LEN	128
#define HMAC_SHA2_512_BLOCK_LEN	128
#define HMAC_MAX_BLOCK_LEN	HMAC_SHA2_512_BLOCK_LEN	/* keep in sync */
#define HMAC_IPAD_VAL		0x36
#define HMAC_OPAD_VAL		0x5C

/* Encryption algorithm block sizes */
#define DES3_BLOCK_LEN		8
#define BLOWFISH_BLOCK_LEN	8
#define CAST128_BLOCK_LEN	8
#define RIJNDAEL128_BLOCK_LEN	16
#define CHACHA20_BLOCK_LEN	64
#define EALG_MAX_BLOCK_LEN	64 /* Keep this updated */

/* Maximum hash algorithm result length */
#define AALG_MAX_RESULT_LEN	64 /* Keep this updated */

#define CRYPTO_3DES_CBC		1
#define CRYPTO_BLF_CBC		2
#define CRYPTO_CAST_CBC		3
#define CRYPTO_MD5_HMAC		4
#define CRYPTO_SHA1_HMAC	5
#define CRYPTO_RIPEMD160_HMAC	6
#define CRYPTO_RIJNDAEL128_CBC	7  /* 128 bit blocksize */
#define CRYPTO_AES_CBC		7  /* 128 bit blocksize -- the same as above */
#define CRYPTO_DEFLATE_COMP	8  /* Deflate compression algorithm */
#define CRYPTO_NULL		9
#define CRYPTO_LZS_COMP		10 /* LZS compression algorithm */
#define CRYPTO_SHA2_256_HMAC	11
#define CRYPTO_SHA2_384_HMAC	12
#define CRYPTO_SHA2_512_HMAC	13
#define CRYPTO_AES_CTR		14
#define CRYPTO_AES_XTS		15
#define CRYPTO_AES_GCM_16	16
#define CRYPTO_AES_128_GMAC	17
#define CRYPTO_AES_192_GMAC	18
#define CRYPTO_AES_256_GMAC	19
#define CRYPTO_AES_GMAC		20
#define CRYPTO_CHACHA20_POLY1305	21
#define CRYPTO_CHACHA20_POLY1305_MAC	22
#define CRYPTO_ESN		23 /* Support for Extended Sequence Numbers */
#define CRYPTO_ALGORITHM_MAX	23 /* Keep updated */

/* Algorithm flags */
#define	CRYPTO_ALG_FLAG_SUPPORTED	0x01 /* Algorithm is supported */

/* Standard initialization structure beginning */
struct cryptoini {
	int		cri_alg;	/* Algorithm to use */
	int		cri_klen;	/* Key length, in bits */
	int		cri_rnd;	/* Algorithm rounds, where relevant */
	caddr_t		cri_key;	/* key to use */
	union {
		u_int8_t	iv[EALG_MAX_BLOCK_LEN];	/* IV to use */
		u_int8_t	esn[4];			/* high-order ESN */
	} u;
#define cri_iv		u.iv
#define cri_esn		u.esn
	struct cryptoini *cri_next;
};

/* Describe boundaries of a single crypto operation */
struct cryptodesc {
	int		crd_skip;	/* How many bytes to ignore from start */
	int		crd_len;	/* How many bytes to process */
	int		crd_inject;	/* Where to inject results, if applicable */
	int		crd_flags;

#define	CRD_F_ENCRYPT		0x01	/* Set when doing encryption */
#define	CRD_F_IV_PRESENT	0x02	/* When encrypting, IV is already in
					   place, so don't copy. */
#define	CRD_F_IV_EXPLICIT	0x04	/* IV explicitly provided */
#define CRD_F_COMP		0x10    /* Set when doing compression */
#define CRD_F_ESN		0x20	/* Set when ESN field is provided */

	struct cryptoini	CRD_INI; /* Initialization/context data */
#define crd_esn		CRD_INI.cri_esn
#define crd_iv		CRD_INI.cri_iv
#define crd_key		CRD_INI.cri_key
#define crd_rnd		CRD_INI.cri_rnd
#define crd_alg		CRD_INI.cri_alg
#define crd_klen	CRD_INI.cri_klen
};

/* Structure describing complete operation */
struct cryptop {
	struct task	crp_task;

	u_int64_t	crp_sid;	/* Session ID */
	int		crp_ilen;	/* Input data total length */
	int		crp_olen;	/* Result total length */
	int		crp_alloctype;	/* Type of buf to allocate if needed */

	int		crp_etype;	/*
					 * Error type (zero means no error).
					 * All error codes except EAGAIN
					 * indicate possible data corruption (as in,
					 * the data have been touched). On all
					 * errors, the crp_sid may have changed
					 * (reset to a new one), so the caller
					 * should always check and use the new
					 * value on future requests.
					 */
	int		crp_flags;

#define CRYPTO_F_IMBUF	0x0001	/* Input/output are mbuf chains, otherwise contig */
#define CRYPTO_F_IOV	0x0002	/* Input/output are uio */
#define CRYPTO_F_NOQUEUE	0x0008	/* Don't use crypto queue/thread */
#define CRYPTO_F_DONE	0x0010	/* request completed */

	void 		*crp_buf;	/* Data to be processed */
	void 		*crp_opaque;	/* Opaque pointer, passed along */

	struct cryptodesc *crp_desc;	/* List of processing descriptors */
	struct cryptodesc crp_sdesc[2];	/* Static array for small ops */
	int		 crp_ndesc;	/* Amount of descriptors to use */
	int		 crp_ndescalloc;/* Amount of descriptors allocated */

	void (*crp_callback)(struct cryptop *); /* Callback function */

	caddr_t		crp_mac;
};

#define CRYPTO_BUF_IOV		0x1
#define CRYPTO_BUF_MBUF		0x2

#define CRYPTO_OP_DECRYPT	0x0
#define CRYPTO_OP_ENCRYPT	0x1

/* Crypto capabilities structure */
struct cryptocap {
	u_int64_t	cc_operations;	/* Counter of how many ops done */
	u_int64_t	cc_bytes;	/* Counter of how many bytes done */
	u_int64_t	cc_koperations;	/* How many PK ops done */

	u_int32_t	cc_sessions;	/* How many sessions allocated */

	/* Symmetric/hash algorithms supported */
	int		cc_alg[CRYPTO_ALGORITHM_MAX + 1];

	int		cc_queued;	/* Operations queued */

	u_int8_t	cc_flags;
#define CRYPTOCAP_F_CLEANUP     0x01
#define CRYPTOCAP_F_SOFTWARE    0x02
#define CRYPTOCAP_F_MPSAFE      0x04

	int		(*cc_newsession) (u_int32_t *, struct cryptoini *);
	int		(*cc_process) (struct cryptop *);
	int		(*cc_freesession) (u_int64_t);
};

/*
 * ioctl parameter to request creation of a session.
 */
struct session_op {
	u_int32_t	cipher;		/* ie. CRYPTO_AES_CBC */
	u_int32_t	mac;		/* ie. CRYPTO_MD5_HMAC */

	u_int32_t	keylen;		/* cipher key */
	caddr_t		key;
	int		mackeylen;	/* mac key */
	caddr_t		mackey;

	u_int32_t	ses;		/* returns: session # */
};

/*
 * ioctl parameter to request a crypt/decrypt operation against a session.
 */
struct crypt_op {
	u_int32_t	ses;
	u_int16_t	op;		/* ie. COP_ENCRYPT */
#define COP_ENCRYPT	1
#define COP_DECRYPT	2
	u_int16_t	flags;		/* always 0 */

	u_int		len;
	caddr_t		src, dst;	/* become iov[] inside kernel */
	caddr_t		mac;		/* must be big enough for chosen MAC */
	caddr_t		iv;
};

#define CRYPTO_MAX_MAC_LEN	20

#ifdef _KERNEL
int	crypto_newsession(u_int64_t *, struct cryptoini *, int);
int	crypto_freesession(u_int64_t);
int	crypto_dispatch(struct cryptop *);
int	crypto_register(u_int32_t, int *,
	    int (*)(u_int32_t *, struct cryptoini *), int (*)(u_int64_t),
	    int (*)(struct cryptop *));
int	crypto_unregister(u_int32_t, int);
int32_t	crypto_get_driverid(u_int8_t);
int	crypto_invoke(struct cryptop *);
void	crypto_done(struct cryptop *);

void	cuio_copydata(struct uio *, int, int, caddr_t);
void	cuio_copyback(struct uio *, int, int, const void *);
int	cuio_getptr(struct uio *, int, int *);
int	cuio_apply(struct uio *, int, int,
	    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t);

struct	cryptop *crypto_getreq(int);
void	crypto_freereq(struct cryptop *);
#endif /* _KERNEL */
#endif /* _CRYPTO_CRYPTO_H_ */
@


1.69
log
@The return code of crp_callback is never checked, so it is not
useful to propagate the error.  When an error occurs in an asynchronous
network path, incrementing a counter is the right thing.  There are
four places where an error is not accounted, just add a comment for
now.
OK mpi@@ visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.68 2016/04/18 21:05:55 kettenis Exp $	*/
a149 2

	struct cryptodesc *crd_next;
d180 5
a184 1
	struct cryptodesc *crp_desc;	/* Linked list of processing descriptors */
@


1.68
log
@Add a mechanism for dispatching mpsafe crypto operations.  This adds a new
CRYPTOCAP_F_MPSAFE flag that crypto implementations can set to indicate that
their cc_process() implementation can safely run without holding the kernel
lock.

ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.67 2015/12/10 21:00:51 naddy Exp $	*/
d184 1
a184 1
	int (*crp_callback)(struct cryptop *); /* Callback function */
@


1.67
log
@Remove plain DES from the kernel crypto framework, including the crypto
accelerator drivers.  No longer used by anything.  ok sthen@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.66 2015/11/13 15:29:55 naddy Exp $	*/
d211 1
@


1.66
log
@remove unused ARC4 support; ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.65 2015/11/13 12:21:16 mikeb Exp $	*/
a74 1
#define DES_BLOCK_LEN		8
d85 25
a109 26
#define CRYPTO_DES_CBC		1
#define CRYPTO_3DES_CBC		2
#define CRYPTO_BLF_CBC		3
#define CRYPTO_CAST_CBC		4
#define CRYPTO_MD5_HMAC		6
#define CRYPTO_SHA1_HMAC	7
#define CRYPTO_RIPEMD160_HMAC	8
#define CRYPTO_RIJNDAEL128_CBC	11 /* 128 bit blocksize */
#define CRYPTO_AES_CBC		11 /* 128 bit blocksize -- the same as above */
#define CRYPTO_DEFLATE_COMP	12 /* Deflate compression algorithm */
#define CRYPTO_NULL		13
#define CRYPTO_LZS_COMP		14 /* LZS compression algorithm */
#define CRYPTO_SHA2_256_HMAC	15
#define CRYPTO_SHA2_384_HMAC	16
#define CRYPTO_SHA2_512_HMAC	17
#define CRYPTO_AES_CTR		18
#define CRYPTO_AES_XTS		19
#define CRYPTO_AES_GCM_16	20
#define CRYPTO_AES_128_GMAC	21
#define CRYPTO_AES_192_GMAC	22
#define CRYPTO_AES_256_GMAC	23
#define CRYPTO_AES_GMAC		24
#define CRYPTO_CHACHA20_POLY1305	25
#define CRYPTO_CHACHA20_POLY1305_MAC	26
#define CRYPTO_ESN		27 /* Support for Extended Sequence Numbers */
#define CRYPTO_ALGORITHM_MAX	27 /* Keep updated */
d221 1
a221 1
	u_int32_t	cipher;		/* ie. CRYPTO_DES_CBC */
@


1.65
log
@Remove unused non HMAC versions of MD5 and SHA1;  ok mpi, deraadt, naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.64 2015/11/12 16:57:00 mikeb Exp $	*/
d95 17
a111 18
#define CRYPTO_ARC4		12
#define CRYPTO_DEFLATE_COMP	13 /* Deflate compression algorithm */
#define CRYPTO_NULL		14
#define CRYPTO_LZS_COMP		15 /* LZS compression algorithm */
#define CRYPTO_SHA2_256_HMAC	16
#define CRYPTO_SHA2_384_HMAC	17
#define CRYPTO_SHA2_512_HMAC	18
#define CRYPTO_AES_CTR		19
#define CRYPTO_AES_XTS		20
#define CRYPTO_AES_GCM_16	21
#define CRYPTO_AES_128_GMAC	22
#define CRYPTO_AES_192_GMAC	23
#define CRYPTO_AES_256_GMAC	24
#define CRYPTO_AES_GMAC		25
#define CRYPTO_CHACHA20_POLY1305	26
#define CRYPTO_CHACHA20_POLY1305_MAC	27
#define CRYPTO_ESN		28 /* Support for Extended Sequence Numbers */
#define CRYPTO_ALGORITHM_MAX	28 /* Keep updated */
@


1.64
log
@remove a few unused defines
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.63 2015/11/12 16:50:55 mikeb Exp $	*/
d96 17
a112 19
#define CRYPTO_MD5		13
#define CRYPTO_SHA1		14
#define CRYPTO_DEFLATE_COMP	15 /* Deflate compression algorithm */
#define CRYPTO_NULL		16
#define CRYPTO_LZS_COMP		17 /* LZS compression algorithm */
#define CRYPTO_SHA2_256_HMAC	18
#define CRYPTO_SHA2_384_HMAC	19
#define CRYPTO_SHA2_512_HMAC	20
#define CRYPTO_AES_CTR		21
#define CRYPTO_AES_XTS		22
#define CRYPTO_AES_GCM_16	23
#define CRYPTO_AES_128_GMAC	24
#define CRYPTO_AES_192_GMAC	25
#define CRYPTO_AES_256_GMAC	26
#define CRYPTO_AES_GMAC		27
#define CRYPTO_CHACHA20_POLY1305	28
#define CRYPTO_CHACHA20_POLY1305_MAC	29
#define CRYPTO_ESN		30 /* Support for Extended Sequence Numbers */
#define CRYPTO_ALGORITHM_MAX	30 /* Keep updated */
@


1.63
log
@another define from the dsa era
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.62 2015/11/03 01:55:28 mikeb Exp $	*/
a181 1
#define CRYPTO_F_REL	0x0004	/* Must return data in same place */
a215 2
#define CRYPTOCAP_F_ENCRYPT_MAC 0x04 /* Can do encrypt-then-MAC (IPsec) */
#define CRYPTOCAP_F_MAC_ENCRYPT 0x08 /* Can do MAC-then-encrypt (TLS) */
@


1.62
log
@Remove two unused defines
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.61 2015/11/03 01:31:36 mikeb Exp $	*/
a144 1
#define	CRD_F_DSA_SHA_NEEDED	0x08	/* Compute SHA-1 of buffer for DSA */
@


1.61
log
@Hook up Chacha20-Poly1305 to the OpenBSD Cryptographic Framework

ok naddy, jsing
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.60 2014/12/28 10:02:37 tedu Exp $	*/
a117 2
#define	CRYPTO_ALG_FLAG_RNG_ENABLE	0x02 /* Has HW RNG for DH/DSA */
#define	CRYPTO_ALG_FLAG_DSA_SHA		0x04 /* Can do SHA on msg */
@


1.60
log
@remove KPDK. not really used, and a bad choice anyway. ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.59 2014/08/20 06:23:03 mikeb Exp $	*/
d80 2
a81 1
#define EALG_MAX_BLOCK_LEN	16 /* Keep this updated */
d111 4
a114 2
#define CRYPTO_ESN		28 /* Support for Extended Sequence Numbers */
#define CRYPTO_ALGORITHM_MAX	28 /* Keep updated */
@


1.59
log
@Bye bye /dev/crypto

The interface has been disabled by default for about 4 years and
currently there's not much value in having it around at all.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.58 2013/10/31 10:32:38 mikeb Exp $	*/
a91 2
#define CRYPTO_MD5_KPDK		9
#define CRYPTO_SHA1_KPDK	10
@


1.58
log
@convert crypto work queue to the task_add(9) api;  ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.57 2013/03/27 16:42:05 tedu Exp $	*/
a202 41
/* bignum parameter, in packed bytes, ... */
struct crparam {
	caddr_t		crp_p;
	u_int		crp_nbits;
};

#define CRK_MAXPARAM	8

struct crypt_kop {
	u_int		crk_op;		/* ie. CRK_MOD_EXP or other */
	u_int		crk_status;	/* return status */
	u_short		crk_iparams;	/* # of input parameters */
	u_short		crk_oparams;	/* # of output parameters */
	u_int		crk_pad1;
	struct crparam	crk_param[CRK_MAXPARAM];
};
#define CRK_MOD_EXP		0
#define CRK_MOD_EXP_CRT		1
#define CRK_DSA_SIGN		2
#define CRK_DSA_VERIFY		3
#define CRK_DH_COMPUTE_KEY	4
#define CRK_ALGORITHM_MAX	4 /* Keep updated */

#define CRF_MOD_EXP		(1 << CRK_MOD_EXP)
#define CRF_MOD_EXP_CRT		(1 << CRK_MOD_EXP_CRT)
#define CRF_DSA_SIGN		(1 << CRK_DSA_SIGN)
#define CRF_DSA_VERIFY		(1 << CRK_DSA_VERIFY)
#define CRF_DH_COMPUTE_KEY	(1 << CRK_DH_COMPUTE_KEY)

struct cryptkop {
	struct task	krp_task;

	u_int		krp_op;		/* ie. CRK_MOD_EXP or other */
	u_int		krp_status;	/* return status */
	u_short		krp_iparams;	/* # of input parameters */
	u_short		krp_oparams;	/* # of output parameters */
	u_int32_t	krp_hid;
	struct crparam	krp_param[CRK_MAXPARAM];	/* kvm */
	int		(*krp_callback)(struct cryptkop *);
};

a213 3
	/* Asymmetric algorithms supported */
	int		cc_kalg[CRK_ALGORITHM_MAX + 1];

a224 1
	int		(*cc_kprocess) (struct cryptkop *);
a259 14
/*
 * done against open of /dev/crypto, to get a cloned descriptor.
 * Please use F_SETFD against the cloned descriptor.
 */
#define	CRIOGET		_IOWR('c', 100, u_int32_t)

/* the following are done against the cloned descriptor */
#define	CIOCGSESSION	_IOWR('c', 101, struct session_op)
#define	CIOCFSESSION	_IOW('c', 102, u_int32_t)
#define CIOCCRYPT	_IOWR('c', 103, struct crypt_op)
#define CIOCKEY		_IOWR('c', 104, struct crypt_kop)

#define CIOCASYMFEAT	_IOR('c', 105, u_int32_t)

a263 1
int	crypto_kdispatch(struct cryptkop *);
a266 1
int	crypto_kregister(u_int32_t, int *, int (*)(struct cryptkop *));
a269 1
int	crypto_kinvoke(struct cryptkop *);
a270 2
void	crypto_kdone(struct cryptkop *);
int	crypto_getfeat(int *);
@


1.57
log
@institute a hard cap on crypto devs instead of a useless wraparound check
ok beck
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.56 2012/06/29 14:48:04 mikeb Exp $	*/
d56 1
a56 1
#include <sys/workq.h>
d163 1
a163 1
	struct workq_task crp_wqt;
d233 1
a233 1
	struct workq_task krp_wqt;
@


1.56
log
@Add support for the Extended (64-bit) Sequence Number as defined
in RFC4302 and RFC4303.  Right now only software crypto engine is
capable of doing it.

Replay check was rewritten to implement algorithm described in the
Appendix A of RFC4303 and the window size was increased to 64.

Tested against OpenBSD, Linux (strongswan) and Windows.

No objection from the usual suspects.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.55 2010/12/16 16:56:08 jsg Exp $	*/
d60 1
@


1.55
log
@move CRYPTO_VIAC3_MAX out of cryptodev.h and into the only
file it will be used from.

requested by/ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.54 2010/12/16 00:07:25 jsg Exp $	*/
d111 2
a112 1
#define CRYPTO_ALGORITHM_MAX	27 /* Keep updated */
d125 6
a130 1
	u_int8_t	cri_iv[EALG_MAX_BLOCK_LEN];	/* IV to use */
d147 1
d150 1
@


1.54
log
@The VIA ciphers are added to an array of CRYPTO_ALGORITHM_MAX length
which should have been declared as CRYPTO_ALGORITHM_MAX + 1,
fix this and reserve enough space for the VIA additions as well.

ok/comments from mikeb & deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.53 2010/10/06 22:19:20 mikeb Exp $	*/
a111 2

#define CRYPTO_VIAC3_MAX	3
@


1.53
log
@Retire Skipjack

There's not much use for the declassified cipher from the 80's
with a questionable license these days.  According to the FIPS
drafts, Skipjack reaches its EOL in December 2010.

The libc portion will be removed after the ports hackathon.

djm and thib agree, no objections from deraadt
Thanks to jsg for digging up FIPS drafts.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.52 2010/09/22 11:54:23 mikeb Exp $	*/
d112 2
@


1.52
log
@OCF support for the Galois/Counter Mode (GCM) for AES as
described in FIPS SP 800-38D.

This implementation supports 16 byte authentication tag only,
splitting transformation into two parts: encryption and
authentication.  Encryption is handled by the existing
AES-CTR implementation, while authentication requires new
AES_GMAC hash function.

Additional routine is added to the software crypto driver
to deal with peculiarities of a combined authentication-
encryption transformation.

With suggestions from reyk, naddy and toby.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.51 2010/06/23 09:26:32 thib Exp $	*/
a76 1
#define SKIPJACK_BLOCK_LEN	8
a87 1
#define CRYPTO_SKIPJACK_CBC	5
@


1.51
log
@Zap a dead prototype, crypto_thread(); Leftover since crypto was
moved from a special kthread to workqs.

OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.50 2010/06/09 19:38:19 thib Exp $	*/
d108 6
a113 1
#define CRYPTO_ALGORITHM_MAX	22 /* Keep updated */
@


1.50
log
@Remove the CRYPTO_ALGORITHM_ALL define, fixup accordingly
and make the loop invartiants <= CRYPTO_ALGORITHM_MAX
Do this also for the CRK_ALGORITHM_MAX this also fixes
the a bug that caused us to skip CRK_DH_COMPUTE_KEY.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.48 2009/09/03 07:47:27 dlg Exp $	*/
a317 1
void	crypto_thread(void);
@


1.49
log
@Fix two bugs in IPsec/HMAC-SHA2:
(1) use correct (message) block size of 128 byte (instead of 64
    bytes) for HMAC-SHA512/384 (RFC4634).
(2) RFC4868 specifies that HMAC-SHA-{256,384,512} is truncated to
    nnn/2 bits, while we still use 96 bits. 96 bits have been
    specified in draft-ietf-ipsec-ciph-sha-256-00 while
    draft-ietf-ipsec-ciph-sha-256-01 changed it to 128 bits.

WARNING: this change makes IPsec with SHA-256 (the default)
incompatible with older OpenBSD versions and other IPsec-implementations
that share this bug.

ok+tests naddy, fries; requested by reyk/deraadt
@
text
@d108 1
a108 3
#define CRYPTO_ALGORITHM_MAX	22 /* Keep updated - see below */

#define	CRYPTO_ALGORITHM_ALL	(CRYPTO_ALGORITHM_MAX + 1)
d212 1
a212 1
#define CRK_ALGORITHM_MAX	4 /* Keep updated - see below */
@


1.48
log
@crypto hardware (eg, hifn) establishes its interrupt handler at
IPL_NET. when the hardware finishes some work for the crypto subsystem
and therefore something in the kernel that wanted crypto done, it
calls crypto_done from that interrupt handler.

one of the things that uses crypto is ipsec. when crypto is done
for ipsec it then pushes the packet along the network stack. the
problem is that all the structures inside the network stack are
only protected at splsoftnet. we could be in the middle of modifications
to the pf state table or the pfsync queues when we get a hifn
interrupt and then go stomp on the same structures.

the solution is to defer the completions so they can do the right
spl protections.

this basically reverts r1.46 of src/sys/crypto/crypto.c.

found by naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.47 2008/06/09 16:07:00 djm Exp $	*/
d63 7
a69 1
#define HMAC_BLOCK_LEN		64
@


1.47
log
@Implement the AES XTS mode of operation for the crypto(9) framework.
XTS is a "tweaked" AES mode that has properties that are desirable
for block device encryption and it is specified in the IEEE
P1619-2007 standard for this purpose.

prodded by & ok hshoexer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.46 2007/11/28 13:52:23 tedu Exp $	*/
d56 1
d147 2
d217 2
@


1.46
log
@finish conversion to workq.  remove list remnants, and put spl in the right
places.  handle the no workq case here.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.45 2007/05/27 05:33:47 tedu Exp $	*/
d100 2
a101 1
#define CRYPTO_ALGORITHM_MAX	21 /* Keep updated - see below */
@


1.45
log
@make crp_buf a void *.  caddr_t implies bufferness, it's not.
ok deraadt jason
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.44 2006/05/31 23:01:44 tedu Exp $	*/
a173 1
	struct cryptop	*crp_next;
a219 1
	struct cryptkop *krp_next;
@


1.44
log
@remove some silly casts.  put spl calls after all declarations.
put one splx in a better spot.  make a variable size MALLOC use malloc.
remove null test after malloc(M_WAITOK).
add PR_NOWAIT flag to pool_get instead of 0.  change callbacks to correct type.
ok brad deraadt markus mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.43 2005/05/25 05:47:53 markus Exp $	*/
d168 1
a168 1
	caddr_t		crp_buf;	/* Data to be processed */
@


1.43
log
@AESCTR support for ESP (RFC 3686); ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.42 2003/08/14 15:18:05 jason Exp $	*/
d169 1
a169 1
	caddr_t		crp_opaque;	/* Opaque pointer, passed along */
@


1.42
log
@mirror change in mbufs: cuio_copyback's 4th arg is now const void *
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.41 2003/07/24 15:29:38 markus Exp $	*/
d99 2
a100 1
#define CRYPTO_ALGORITHM_MAX	20 /* Keep updated - see below */
@


1.41
log
@increase ALG_MAX_RESULT_LEN to 64 bytes for sha2-512
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.40 2003/07/24 08:03:19 itojun Exp $	*/
d317 1
a317 1
void	cuio_copyback(struct uio *, int, int, caddr_t);
@


1.40
log
@hmac-sha2-{256,384,512} support in AH/ESP auth.  markus ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.39 2003/06/03 15:51:28 deraadt Exp $	*/
d76 1
a76 1
#define AALG_MAX_RESULT_LEN	20 /* Keep this updated */
@


1.39
log
@license cleanup regarding term 4
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.38 2003/06/03 15:28:06 beck Exp $	*/
d96 4
a99 1
#define CRYPTO_ALGORITHM_MAX	17 /* Keep updated - see below */
@


1.38
log
@Fastpath for userland crypto requests. This change makes userland
crypto requests attempt to call the crypto driver directly to process
crypto layer requests, as opposed to queueing them in the kernel
crypto thread. If we can't use the crypto devices (i.e. they're busy)
we fall back to queueing the request up in the crypto thread as
before. This does allow for faster performance in some cases (smaller
requests, how small seems to be dependent on the card/cpu combination)
where context switching is a major issue in performance.
ok deraadt@@ jason@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.37 2003/02/15 22:57:58 jason Exp $	*/
d30 1
a30 1
 *   notice, this list of conditions and the following disclaimer.
d32 2
a33 4
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
@


1.37
log
@skeleton support for LZS compression
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.36 2003/02/15 18:55:50 jason Exp $	*/
d163 2
@


1.36
log
@CRD_F_COMP isn't so special that it needs 4 bits for a binary flag
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.35 2002/11/21 19:34:25 jason Exp $	*/
d97 2
a98 1
#define CRYPTO_ALGORITHM_MAX	16 /* Keep updated - see below */
@


1.35
log
@From Angelos:
- simplistic load balancing across multiple cards
- simplified registration process
- a few style nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.34 2002/11/12 18:23:13 jason Exp $	*/
d128 1
a128 1
#define CRD_F_COMP		0x0f    /* Set when doing compression */
@


1.34
log
@Add a CRYPTO_NULL xform (it's a do nothing, but nice for measuring the
bandwidth of the kernel API).  It's only available from userland and
then only if kern.cryptodevallowsoft=1.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.33 2002/07/17 23:52:39 art Exp $	*/
d99 2
d221 5
a225 1
	u_int32_t	cc_sessions;
d227 2
a228 5
	/*
	 * Largest possible operator length (in bits) for each type of
	 * encryption algorithm.
	 */
	u_int16_t	cc_max_op_len[CRYPTO_ALGORITHM_MAX + 1];
d230 2
a231 1
	u_int8_t	cc_alg[CRYPTO_ALGORITHM_MAX + 1];
d233 1
a233 1
	u_int8_t	cc_kalg[CRK_ALGORITHM_MAX + 1];
d236 4
a239 2
#define CRYPTOCAP_F_CLEANUP   0x1
#define CRYPTOCAP_F_SOFTWARE  0x02
d299 1
a299 1
int	crypto_register(u_int32_t, int, u_int16_t, u_int32_t,
d302 1
a302 2
int	crypto_kregister(u_int32_t, int, u_int32_t,
	    int (*)(struct cryptkop *));
@


1.33
log
@I don't know why this breaks things for me when sshd starts on sparc64.
But after wasting the whole day trying to just locate the problem I don't care.
Back out since this wasn't tested and showed to anyone else.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.31 2002/06/11 11:14:29 beck Exp $	*/
d96 2
a97 1
#define CRYPTO_ALGORITHM_MAX	15 /* Keep updated - see below */
@


1.32
log
@Add CRYPTO_ALGORITHM_ALL
@
text
@a97 2
#define	CRYPTO_ALGORITHM_ALL	(CRYPTO_ALGORITHM_MAX + 1)

@


1.31
log
@kernel changes to make asymmetric crypto work in userland
- modify getfeat to return something more useful to us on devices
  (like lofn and everything else until jason fixes it) that can't
  do rsa stuff, etc and can only do mod_exp..
- error handling fixes so we correctly fail to software when we can't
  deal with a particular key size
- add sysctl kern.userasymcrypto to turn on/off userland asymmetric crypto
  via /dev/crypto - 1 == on, 0 == off, default is off
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.30 2002/06/09 22:23:17 angelos Exp $	*/
d97 2
@


1.30
log
@Don't use an int for the flags, when the structure uses
u_int8_t. Also, make sure the logic is correct (bad theo!)
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.29 2002/05/18 17:00:33 deraadt Exp $	*/
d199 6
d285 1
a285 4
#define CIOCSYMFEAT	_IOR('c', 105, u_int32_t)
#define CRSFEAT_RSA	0x00000001	/* supports all basic RSA ops */
#define CRSFEAT_DSA	0x00000002	/* supports all basic DSA ops */
#define CRSFEAT_DH	0x00000004	/* supports all basic DH ops */
@


1.29
log
@not ready to export fcrypt to userland yet; spotted by lebel
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.27 2002/04/24 23:24:32 deraadt Exp $	*/
d99 3
a101 3
#define	CRYPTO_ALG_FLAG_SUPPORTED	0x00000001 /* Algorithm is supported */
#define	CRYPTO_ALG_FLAG_RNG_ENABLE	0x00000002 /* Has HW RNG for DH/DSA */
#define	CRYPTO_ALG_FLAG_DSA_SHA		0x00000004 /* Can do SHA on msg */
@


1.28
log
@export struct fcrypt to userland
@
text
@a284 23
struct csession {
	TAILQ_ENTRY(csession) next;
	u_int64_t	sid;
	u_int32_t	ses;

	u_int32_t	cipher;
	struct enc_xform *txform;
	u_int32_t	mac;
	struct auth_hash *thash;

	caddr_t		key;
	int		keylen;
	u_char		tmp_iv[EALG_MAX_BLOCK_LEN];

	caddr_t		mackey;
	int		mackeylen;
	u_char		tmp_mac[CRYPTO_MAX_MAC_LEN];

	struct iovec	iovec[IOV_MAX];
	struct uio	uio;
	int		error;
};

a311 7

struct csession;
struct fcrypt {
	TAILQ_HEAD(csessionlist, csession) csessions;
	int		sesn;
};

@


1.27
log
@kernel API does not need the userland addresses, make them go away
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.26 2002/04/23 22:20:47 deraadt Exp $	*/
d285 23
d335 7
@


1.26
log
@initial hack at a CIOCSYMFEAT ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.25 2002/04/23 19:13:04 deraadt Exp $	*/
a190 1

a203 4
	u_int		krp_pad1;
	struct crparam	krp_param[CRK_MAXPARAM];
	struct crparam	krp_kvp[CRK_MAXPARAM];

d205 1
@


1.25
log
@driver queueing & callback code for keying operations
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.24 2002/04/08 17:49:42 jason Exp $	*/
d305 1
@


1.24
log
@Credit DARPA/USAF appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.23 2002/03/14 01:26:51 millert Exp $	*/
d176 38
d226 2
d235 1
a270 21
/* bignum parameter, in packed bytes, ... */
struct crparam {
	caddr_t		crp_p;
	u_int		crp_nbits;
};

#define CRK_MAXPARAM	8
struct crypt_kop {
	u_int		crk_op;		/* ie. CRK_MOD_EXP or other */
	u_int		crk_status;	/* return status */
	u_short		crk_iparams;	/* # of input parameters */
	u_short		crk_oparams;	/* # of output parameters */
	u_int		crk_pad1;
	struct crparam	crk_param[CRK_MAXPARAM];
};
#define CRK_MOD_EXP		0
#define CRK_MOD_EXP_CRT		1
#define CRK_DSA_SIGN		2
#define CRK_DSA_VERIFY		3
#define CRK_DH_COMPUTE_KEY	4

d292 1
d296 2
d302 1
d304 1
@


1.23
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.22 2002/03/04 21:24:11 deraadt Exp $	*/
d47 5
@


1.22
log
@remove old PK stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.21 2002/03/02 23:00:30 deraadt Exp $	*/
d276 2
a277 2
void	cuio_copydata __P((struct uio *, int, int, caddr_t));
void	cuio_copyback __P((struct uio *, int, int, caddr_t));
@


1.21
log
@do some more renaming
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.20 2002/03/02 19:15:11 deraadt Exp $	*/
d15 1
a15 1
 * modification of this software. 
d87 5
a91 16
#define CRYPTO_ARC4		19
#define CRYPTO_MD5		20
#define CRYPTO_SHA1		21

/* Begin public key additions */
#define CRYPTO_DH_SEND		12 /* Compute public value */
#define CRYPTO_DH_RECEIVE	13 /* Compute DH shared secret */
#define CRYPTO_RSA_ENCRYPT	14 /* RSA public key encryption */
#define CRYPTO_RSA_DECRYPT	15 /* RSA public key decryption */
#define CRYPTO_DSA_SIGN		16 /* DSA sign */
#define CRYPTO_DSA_VERIFY	17 /* DSA verify */

/* Compression */
#define CRYPTO_DEFLATE_COMP	18 /* Deflate compression algorithm */

#define CRYPTO_ALGORITHM_MAX	21 /* Keep updated - see below */
a97 3
#define	SYMMETRIC		0
#define	PUBLIC_KEY		1

d175 1
a175 1
	/* 
d177 1
a177 2
	 * encryption algorithm - especially important for public key
	 * operations.
d179 1
a179 1
	u_int16_t	cc_max_op_len[CRYPTO_ALGORITHM_MAX + 1]; 
d192 3
d204 1
a204 1
  	u_int32_t	ses;		/* returns: session # */ 
d207 3
d212 3
a214 1
	u_int16_t	op;
d233 5
a237 4
	u_int		crk_op;		/* ie. CRK_RSA_MOD_EXP or other */
	u_int		crk_iparams;	/* # of input parameters */
	u_int		crk_oparams;	/* # of output parameters */
	u_int		crk_status;
d240 5
a244 6
#define CRK_RSA_MOD_EXP		0
#define CRK_MOD_EXP		1
#define CRK_RSA_MOD_EXP_CRT	2
#define CRK_DSA_SIGN		3
#define CRK_DSA_VERIFY		4
#define CRK_DH_COMPUTE_KEY	5
d246 4
d252 1
a254 1

a255 3
#define COP_ENCRYPT	1
#define COP_DECRYPT	2

a263 1
int	crypto_check_alg(struct cryptoini *);
d267 1
a267 1
int	crypto_register(u_int32_t, int, u_int16_t, u_int32_t, 
a274 1
int	crypto_check_alg(struct cryptoini *);
@


1.20
log
@initial cut at crypto_sop definitions for symmetric crypto
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.19 2002/03/01 02:50:02 provos Exp $	*/
d238 7
a244 7
#define CRS_MAXPARAM	8
struct crypt_sop {
	u_int		crs_op;		/* ie. CRS_RSA_MOD_EXP or other */
	u_int		crs_iparams;	/* # of input parameters */
	u_int		crs_oparams;	/* # of output parameters */
	u_int		crs_status;
	struct crparam	crs_param[CRS_MAXPARAM];
d246 6
a251 6
#define CRS_RSA_MOD_EXP		0
#define CRS_MOD_EXP		1
#define CRS_RSA_MOD_EXP_CRT	2
#define CRS_DSA_SIGN		3
#define CRS_DSA_VERIFY		4
#define CRS_DH_COMPUTE_KEY	5
d262 1
a262 1
#define CIOCSYMMETRIC	_IOWR('c', 104, struct crypt_sop)
@


1.19
log
@remove CRYPTO_BUF_CONTIG and convert to handle iovs. okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.18 2002/03/01 02:46:57 provos Exp $	*/
d109 2
a110 117
#define SYMMETRIC		0
#define PUBLIC_KEY		1

/* 
 * Diffie-Hellman structure which defines fields needed to operate on the
 * input. Should be passed in the cryptoini->cri_key field.
 */
struct DH_key {
	/* 
	 * CRYPTO_DH_SEND - Enable or disable the random number generator.
	 * If disabled, private key and length should be stored in
	 * DH_buf; otherwise only the length is needed and the generated
	 * private key is stored in DH_buf->priv_key.
	 */
    
	/* Length of key-related variables */
	u_int16_t	dhk_gen_length;	/* SEND - generator length */
	u_int16_t	dhk_mod_length;	/* SEND/RECEIVE - modulus length */
 
	/* Input/output buffers for key generation */
	caddr_t		dhk_generator;	/* SEND - generator to use */
	caddr_t		dhk_modulus;	/* SEND/RECEIVE - modulus to use */   
};  

/*
 * These are inputs for DH processing - the private keys and public
 * keys are stored here because For DH-Send, if RNG_ENABLE, the
 * private key does not have to be provided.  Should be passed to the
 * cryptop->crp_buf.
 */
struct DH_buf {
	/* Length of variables */
	u_int16_t dh_public_key_length;	/* SEND/RECEIVE - public value len */
	u_int16_t dh_ss_key_length;	/* RECEIVE - shared secret key len */
	u_int16_t dh_priv_key_length;	/* SEND/RECEIVE - Private key length */
    
	/* Input/output buffers */
	caddr_t	dh_priv_key; /* 
			      * Buffer for private key the private key
			      * buffer is placed here because it can
			      * be both an input and an output. If this
			      * is left empty, the crypto framework or
			      * the underlying hardware will provide it for
			      * SEND. Must be present on RECEIVE.
			      */
	caddr_t	dh_pub_key; /* SEND/RECEIVE - I/O buffer for public key */
	caddr_t	dh_ss_key;  /* RECEIVE - output buffer for shared secret key */
};

/* 
 * RSA structure which defines fields needed to operate on the input.
 * Should be passed to the cryptoini->cri_key field.
 */
struct RSA_key {
	/* Length of variables (in bits) */
	u_int16_t 	rsak_exponent_length;  	/* Length of exponent (e) */
	u_int16_t	rsak_mod_length;	/* Length of modulus */
	u_int16_t	rsak_p_length;		/* Length of p */
	u_int16_t	rsak_q_length;		/* Length of q */
	u_int16_t 	rsak_dp_length;		/* Length of CRT dp */
	u_int16_t	rsak_dq_length;		/* Length of CRT dq */
	u_int16_t	rsak_qinv_length;	/* Length of CRT qinv */

	/* Input/output buffers */
	caddr_t		rsak_exponent;
	caddr_t		rsak_modulus;
	caddr_t		rsak_p;
	caddr_t		rsak_q;
	caddr_t		rsak_dp;
	caddr_t		rsak_dq;
	caddr_t		rsak_qinv;
};
  
/*
 * These are inputs for RSA processing - they are the data buffers for
 * the input and output message. Should be passed through cryptop->crp_buf.
 */
struct RSA_buf {
	u_int16_t	rsa_in_buf_length;	/* Length of input buffer */
	u_int16_t	rsa_out_buf_length;	/* Length of output buffer */

	caddr_t		rsa_in_buf;		/* Input message buffer */
	caddr_t		rsa_out_buf;		/* Output message buffer */
};

/*
 * DSA structure which defines fields needed to operate on the input.
 * Should be passed to the cyprtonini->cri_key field.
 */    
struct DSA_key {
	u_int16_t	dsak_p_length;	/* Length of modulus p */

	caddr_t		dsak_generator;	/* Generator to use, dsak_p_length */
	caddr_t		dsak_mod_q;	/* Modulus q to use, 160 bits */
	caddr_t		dsak_mod_p;	/* Modulus p to use, dsak_p_length */
	caddr_t		dsak_pub_key;	/* VERIFY - public key, dsak_p_length */
	caddr_t		dsak_priv_key;	/* SIGN - private key, 160 bits */
};

/*
 * DSA structure which defines the input and output buffers.
 * Should be passed to the cryptop->crp_buf field.
 */
struct DSA_buf {
	u_int16_t	dsa_msg_len;	/* Message length */

	/* r,s,v are all 160 bits */
	caddr_t		dsa_r_param;	/* Input for VERIFY; output for SIGN */
	caddr_t		dsa_s_param;	/* Input for VERIFY; output for SIGN */
	caddr_t		dsa_v_param;	/* Output for VERIFY; should be
					 * compared against r_param. */
	caddr_t		dsa_msg_buf;	/* Message buffer (hash or message) */
	caddr_t		dsa_rnd_num;	/* Random value from SW, 160 bits;
					 * if not provided, framework will
					 * provide one.
					 */
};
d232 20
a251 4
#define COP_ENCRYPT	1
#define COP_DECRYPT	2
/* #define COP_SETKEY	3 */
/* #define COP_GETKEY	4 */
d257 1
d259 9
@


1.18
log
@helper functions for uio (cuio_apply and cuio_getptr) okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.17 2002/02/24 00:30:00 deraadt Exp $	*/
d294 1
a294 1
#define CRYPTO_BUF_CONTIG	0x1
@


1.17
log
@license repair, angelos ok
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.16 2002/01/29 15:48:29 jason Exp $	*/
d375 3
@


1.16
log
@Remove the iov2pages/mbuf2pages API... All of the relevant arch's support
bus_dma(9) which actually does this job correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.15 2001/11/09 03:11:38 deraadt Exp $	*/
d12 1
a12 1
 * Permission to use, copy, and modify this software without fee
@


1.15
log
@be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.14 2001/08/28 12:20:43 ben Exp $	*/
a372 3
struct mbuf;
int	mbuf2pages __P((struct mbuf *, int *, long *, int *, int, int *));
int	iov2pages __P((struct uio *, int *, long *, int *, int, int *));
@


1.15.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.16 2002/01/29 15:48:29 jason Exp $	*/
d373 3
@


1.15.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.15.2.1 2002/01/31 22:55:29 niklas Exp $	*/
d12 1
a12 1
 * Permission to use, copy, and modify this software with or without fee
d15 1
a15 1
 * modification of this software.
a46 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d87 16
a102 5
#define CRYPTO_ARC4		12
#define CRYPTO_MD5		13
#define CRYPTO_SHA1		14
#define CRYPTO_DEFLATE_COMP	15 /* Deflate compression algorithm */
#define CRYPTO_ALGORITHM_MAX	15 /* Keep updated - see below */
d109 118
d294 1
a294 1
#define CRYPTO_BUF_IOV		0x1
a299 34
/* bignum parameter, in packed bytes, ... */
struct crparam {
	caddr_t		crp_p;
	u_int		crp_nbits;
};

#define CRK_MAXPARAM	8

struct crypt_kop {
	u_int		crk_op;		/* ie. CRK_MOD_EXP or other */
	u_int		crk_status;	/* return status */
	u_short		crk_iparams;	/* # of input parameters */
	u_short		crk_oparams;	/* # of output parameters */
	u_int		crk_pad1;
	struct crparam	crk_param[CRK_MAXPARAM];
};
#define CRK_MOD_EXP		0
#define CRK_MOD_EXP_CRT		1
#define CRK_DSA_SIGN		2
#define CRK_DSA_VERIFY		3
#define CRK_DH_COMPUTE_KEY	4
#define CRK_ALGORITHM_MAX	4 /* Keep updated - see below */

struct cryptkop {
	u_int		krp_op;		/* ie. CRK_MOD_EXP or other */
	u_int		krp_status;	/* return status */
	u_short		krp_iparams;	/* # of input parameters */
	u_short		krp_oparams;	/* # of output parameters */
	u_int32_t	krp_hid;
	struct crparam	krp_param[CRK_MAXPARAM];	/* kvm */
	int		(*krp_callback)(struct cryptkop *);
	struct cryptkop *krp_next;
};

d304 1
a304 1
	/*
d306 2
a307 1
	 * encryption algorithm.
d309 1
a309 1
	u_int16_t	cc_max_op_len[CRYPTO_ALGORITHM_MAX + 1];
a312 2
	u_int8_t	cc_kalg[CRK_ALGORITHM_MAX + 1];

a319 1
	int		(*cc_kprocess) (struct cryptkop *);
a321 3
/*
 * ioctl parameter to request creation of a session.
 */
d331 1
a331 1
	u_int32_t	ses;		/* returns: session # */
a333 3
/*
 * ioctl parameter to request a crypt/decrypt operation against a session.
 */
d336 1
a336 3
	u_int16_t	op;		/* ie. COP_ENCRYPT */
#define COP_ENCRYPT	1
#define COP_DECRYPT	2
d347 5
a351 4
/*
 * done against open of /dev/crypto, to get a cloned descriptor.
 * Please use F_SETFD against the cloned descriptor.
 */
a353 1
/* the following are done against the cloned descriptor */
a356 6
#define CIOCKEY		_IOWR('c', 104, struct crypt_kop)

#define CIOCSYMFEAT	_IOR('c', 105, u_int32_t)
#define CRSFEAT_RSA	0x00000001	/* supports all basic RSA ops */
#define CRSFEAT_DSA	0x00000002	/* supports all basic DSA ops */
#define CRSFEAT_DH	0x00000004	/* supports all basic DH ops */
d359 1
d363 1
a363 2
int	crypto_kdispatch(struct cryptkop *);
int	crypto_register(u_int32_t, int, u_int16_t, u_int32_t,
a365 2
int	crypto_kregister(u_int32_t, int, u_int32_t,
	    int (*)(struct cryptkop *));
a369 1
int	crypto_kinvoke(struct cryptkop *);
d371 1
a371 2
void	crypto_kdone(struct cryptkop *);
int	crypto_getfeat(int *);
d373 2
a374 5
void	cuio_copydata(struct uio *, int, int, caddr_t);
void	cuio_copyback(struct uio *, int, int, caddr_t);
int	cuio_getptr(struct uio *, int, int *);
int	cuio_apply(struct uio *, int, int,
	    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t);
@


1.15.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.15.2.2 2002/06/11 03:28:34 art Exp $	*/
d99 3
a101 3
#define	CRYPTO_ALG_FLAG_SUPPORTED	0x01 /* Algorithm is supported */
#define	CRYPTO_ALG_FLAG_RNG_ENABLE	0x02 /* Has HW RNG for DH/DSA */
#define	CRYPTO_ALG_FLAG_DSA_SHA		0x04 /* Can do SHA on msg */
a198 6
#define CRF_MOD_EXP		(1 << CRK_MOD_EXP)
#define CRF_MOD_EXP_CRT		(1 << CRK_MOD_EXP_CRT)
#define CRF_DSA_SIGN		(1 << CRK_DSA_SIGN)
#define CRF_DSA_VERIFY		(1 << CRK_DSA_VERIFY)
#define CRF_DH_COMPUTE_KEY	(1 << CRK_DH_COMPUTE_KEY)

d279 4
a282 1
#define CIOCASYMFEAT	_IOR('c', 105, u_int32_t)
@


1.15.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d96 1
a96 5
#define CRYPTO_NULL		16
#define CRYPTO_LZS_COMP		17 /* LZS compression algorithm */
#define CRYPTO_ALGORITHM_MAX	17 /* Keep updated - see below */

#define	CRYPTO_ALGORITHM_ALL	(CRYPTO_ALGORITHM_MAX + 1)
d125 1
a125 1
#define CRD_F_COMP		0x10    /* Set when doing compression */
d218 1
a218 5
	u_int64_t	cc_operations;	/* Counter of how many ops done */
	u_int64_t	cc_bytes;	/* Counter of how many bytes done */
	u_int64_t	cc_koperations;	/* How many PK ops done */

	u_int32_t	cc_sessions;	/* How many sessions allocated */
d220 5
a224 2
	/* Symmetric/hash algorithms supported */
	int		cc_alg[CRYPTO_ALGORITHM_MAX + 1];
d226 1
a226 2
	/* Asymmetric algorithms supported */
	int		cc_kalg[CRK_ALGORITHM_MAX + 1];
d228 1
a228 1
	int		cc_queued;	/* Operations queued */
d231 2
a232 4
#define CRYPTOCAP_F_CLEANUP     0x01
#define CRYPTOCAP_F_SOFTWARE    0x02
#define CRYPTOCAP_F_ENCRYPT_MAC 0x04 /* Can do encrypt-then-MAC (IPsec) */
#define CRYPTOCAP_F_MAC_ENCRYPT 0x08 /* Can do MAC-then-encrypt (TLS) */
d292 1
a292 1
int	crypto_register(u_int32_t, int *,
d295 2
a296 1
int	crypto_kregister(u_int32_t, int *, int (*)(struct cryptkop *));
@


1.14
log
@Getting closer to working userland MAC.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.13 2001/08/22 17:34:35 deraadt Exp $	*/
d367 1
a367 1
int32_t	crypto_get_driverid(void);
@


1.14.2.1
log
@Pull in patch from current:
Fix (deraadt):
be way more sure that software cannot be used
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.14 2001/08/28 12:20:43 ben Exp $	*/
d367 1
a367 1
int32_t	crypto_get_driverid(u_int8_t);
@


1.13
log
@add RC4 and SHA1 support
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.12 2001/08/05 09:36:38 deraadt Exp $	*/
a291 1
	int		crp_mac_trunc_len;
d331 1
a331 1
	u_int32_t	ses;		/* returns: session # */
d341 1
a341 1
	caddr_t		mac;
d344 2
@


1.12
log
@put in tags for ARC4 to please ben, who now has no excuses
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.11 2001/07/05 08:34:12 angelos Exp $	*/
d88 2
d102 1
a102 1
#define CRYPTO_ALGORITHM_MAX	19 /* Keep updated - see below */
@


1.11
log
@Stylistic changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.10 2001/07/05 08:26:05 jjbg Exp $	*/
d87 1
a87 1
#define CRYPTO_ALGORITHM_MAX	18 /* Keep updated - see below */
d99 2
@


1.10
log
@Compression support for IPComp. Include files only. angelos@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.9 2001/06/25 17:52:37 angelos Exp $	*/
d87 1
a87 1
#define CRYPTO_ALGORITHM_MAX	18 /* Keep updated - including public key */
d97 2
a98 2
/* Non crypto algo, i.e compression */
#define CRYPTO_DEFLATE_COMP	18 /* Deflate compression algo */
@


1.9
log
@Add crypto_check_alg(), from jgarfiel@@seas.upenn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.8 2001/06/25 17:35:47 angelos Exp $	*/
d87 1
a87 1
#define CRYPTO_ALGORITHM_MAX	17 /* Keep updated - including public key */
d97 3
d245 1
d261 1
a261 1
	int		crp_olen;	/* Result total length (unused for now) */
@


1.9.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.9 2001/06/25 17:52:37 angelos Exp $	*/
d87 1
a87 3
#define CRYPTO_ARC4		19
#define CRYPTO_MD5		20
#define CRYPTO_SHA1		21
a96 5
/* Compression */
#define CRYPTO_DEFLATE_COMP	18 /* Deflate compression algorithm */

#define CRYPTO_ALGORITHM_MAX	21 /* Keep updated - see below */

a241 1
#define CRD_F_COMP		0x0f    /* Set when doing compression */
d257 1
a257 1
	int		crp_olen;	/* Result total length */
d284 1
d324 1
a324 1
  	u_int32_t	ses;		/* returns: session # */ 
d334 1
a334 1
	caddr_t		mac;		/* must be big enough for chosen MAC */
a336 2

#define CRYPTO_MAX_MAC_LEN	20
@


1.9.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d367 1
a367 1
int32_t	crypto_get_driverid(u_int8_t);
@


1.9.2.3
log
@Merge in trunk
@
text
@d12 1
a12 1
 * Permission to use, copy, and modify this software with or without fee
d15 1
a15 1
 * modification of this software.
d87 16
a102 5
#define CRYPTO_ARC4		12
#define CRYPTO_MD5		13
#define CRYPTO_SHA1		14
#define CRYPTO_DEFLATE_COMP	15 /* Deflate compression algorithm */
#define CRYPTO_ALGORITHM_MAX	15 /* Keep updated - see below */
d109 118
d294 1
a294 1
#define CRYPTO_BUF_IOV		0x1
d304 1
a304 1
	/*
d306 2
a307 1
	 * encryption algorithm.
d309 1
a309 1
	u_int16_t	cc_max_op_len[CRYPTO_ALGORITHM_MAX + 1];
a321 3
/*
 * ioctl parameter to request creation of a session.
 */
d331 1
a331 1
	u_int32_t	ses;		/* returns: session # */
a333 3
/*
 * ioctl parameter to request a crypt/decrypt operation against a session.
 */
d336 1
a336 3
	u_int16_t	op;		/* ie. COP_ENCRYPT */
#define COP_ENCRYPT	1
#define COP_DECRYPT	2
d347 4
a350 20
/* bignum parameter, in packed bytes, ... */
struct crparam {
	caddr_t		crp_p;
	u_int		crp_nbits;
};

#define CRK_MAXPARAM	8
struct crypt_kop {
	u_int		crk_op;		/* ie. CRK_MOD_EXP or other */
	u_int		crk_status;	/* return status */
	u_short		crk_iparams;	/* # of input parameters */
	u_short		crk_oparams;	/* # of output parameters */
	u_int		crk_pad1;
	struct crparam	crk_param[CRK_MAXPARAM];
};
#define CRK_MOD_EXP		0
#define CRK_MOD_EXP_CRT		1
#define CRK_DSA_SIGN		2
#define CRK_DSA_VERIFY		3
#define CRK_DH_COMPUTE_KEY	4
a351 4
/*
 * done against open of /dev/crypto, to get a cloned descriptor.
 * Please use F_SETFD against the cloned descriptor.
 */
a353 1
/* the following are done against the cloned descriptor */
a356 6
#define CIOCKEY		_IOWR('c', 104, struct crypt_kop)

#define CIOCSYMFEAT	_IOR('c', 105, u_int32_t)
#define CRSFEAT_RSA	0x00000001	/* supports all basic RSA ops */
#define CRSFEAT_DSA	0x00000002	/* supports all basic DSA ops */
#define CRSFEAT_DH	0x00000004	/* supports all basic DH ops */
d359 1
d363 1
a363 1
int	crypto_register(u_int32_t, int, u_int16_t, u_int32_t,
d371 1
d373 3
a377 3
int	cuio_getptr(struct uio *, int, int *);
int	cuio_apply(struct uio *, int, int,
	    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t);
@


1.9.2.4
log
@Merge in -current from about a week ago
@
text
@d276 2
a277 2
void	cuio_copydata(struct uio *, int, int, caddr_t);
void	cuio_copyback(struct uio *, int, int, caddr_t);
@


1.9.2.5
log
@Sync the SMP branch with 3.3
@
text
@a46 5
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 *
d91 1
a91 5
#define CRYPTO_NULL		16
#define CRYPTO_LZS_COMP		17 /* LZS compression algorithm */
#define CRYPTO_ALGORITHM_MAX	17 /* Keep updated - see below */

#define	CRYPTO_ALGORITHM_ALL	(CRYPTO_ALGORITHM_MAX + 1)
d94 3
a96 3
#define	CRYPTO_ALG_FLAG_SUPPORTED	0x01 /* Algorithm is supported */
#define	CRYPTO_ALG_FLAG_RNG_ENABLE	0x02 /* Has HW RNG for DH/DSA */
#define	CRYPTO_ALG_FLAG_DSA_SHA		0x04 /* Can do SHA on msg */
d120 1
a120 1
#define CRD_F_COMP		0x10    /* Set when doing compression */
a170 40
/* bignum parameter, in packed bytes, ... */
struct crparam {
	caddr_t		crp_p;
	u_int		crp_nbits;
};

#define CRK_MAXPARAM	8

struct crypt_kop {
	u_int		crk_op;		/* ie. CRK_MOD_EXP or other */
	u_int		crk_status;	/* return status */
	u_short		crk_iparams;	/* # of input parameters */
	u_short		crk_oparams;	/* # of output parameters */
	u_int		crk_pad1;
	struct crparam	crk_param[CRK_MAXPARAM];
};
#define CRK_MOD_EXP		0
#define CRK_MOD_EXP_CRT		1
#define CRK_DSA_SIGN		2
#define CRK_DSA_VERIFY		3
#define CRK_DH_COMPUTE_KEY	4
#define CRK_ALGORITHM_MAX	4 /* Keep updated - see below */

#define CRF_MOD_EXP		(1 << CRK_MOD_EXP)
#define CRF_MOD_EXP_CRT		(1 << CRK_MOD_EXP_CRT)
#define CRF_DSA_SIGN		(1 << CRK_DSA_SIGN)
#define CRF_DSA_VERIFY		(1 << CRK_DSA_VERIFY)
#define CRF_DH_COMPUTE_KEY	(1 << CRK_DH_COMPUTE_KEY)

struct cryptkop {
	u_int		krp_op;		/* ie. CRK_MOD_EXP or other */
	u_int		krp_status;	/* return status */
	u_short		krp_iparams;	/* # of input parameters */
	u_short		krp_oparams;	/* # of output parameters */
	u_int32_t	krp_hid;
	struct crparam	krp_param[CRK_MAXPARAM];	/* kvm */
	int		(*krp_callback)(struct cryptkop *);
	struct cryptkop *krp_next;
};

d173 1
a173 8
	u_int64_t	cc_operations;	/* Counter of how many ops done */
	u_int64_t	cc_bytes;	/* Counter of how many bytes done */
	u_int64_t	cc_koperations;	/* How many PK ops done */

	u_int32_t	cc_sessions;	/* How many sessions allocated */

	/* Symmetric/hash algorithms supported */
	int		cc_alg[CRYPTO_ALGORITHM_MAX + 1];
d175 5
a179 2
	/* Asymmetric algorithms supported */
	int		cc_kalg[CRK_ALGORITHM_MAX + 1];
d181 1
a181 1
	int		cc_queued;	/* Operations queued */
d184 2
a185 4
#define CRYPTOCAP_F_CLEANUP     0x01
#define CRYPTOCAP_F_SOFTWARE    0x02
#define CRYPTOCAP_F_ENCRYPT_MAC 0x04 /* Can do encrypt-then-MAC (IPsec) */
#define CRYPTOCAP_F_MAC_ENCRYPT 0x08 /* Can do MAC-then-encrypt (TLS) */
a189 1
	int		(*cc_kprocess) (struct cryptkop *);
d225 21
d258 4
a261 1
#define CIOCASYMFEAT	_IOR('c', 105, u_int32_t)
d267 1
a267 2
int	crypto_kdispatch(struct cryptkop *);
int	crypto_register(u_int32_t, int *,
a269 1
int	crypto_kregister(u_int32_t, int *, int (*)(struct cryptkop *));
a273 1
int	crypto_kinvoke(struct cryptkop *);
a274 2
void	crypto_kdone(struct cryptkop *);
int	crypto_getfeat(int *);
@


1.9.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.9.2.5 2003/03/27 23:53:48 niklas Exp $	*/
d30 1
a30 1
 *    notice, this list of conditions and the following disclaimer.
d32 4
a35 2
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
a162 2
#define CRYPTO_F_NOQUEUE	0x0008	/* Don't use crypto queue/thread */
#define CRYPTO_F_DONE	0x0010	/* request completed */
@


1.9.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 1
a76 1
#define AALG_MAX_RESULT_LEN	64 /* Keep this updated */
d96 1
a96 4
#define CRYPTO_SHA2_256_HMAC	18
#define CRYPTO_SHA2_384_HMAC	19
#define CRYPTO_SHA2_512_HMAC	20
#define CRYPTO_ALGORITHM_MAX	20 /* Keep updated - see below */
d314 1
a314 1
void	cuio_copyback(struct uio *, int, int, const void *);
@


1.8
log
@Update comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.7 2001/06/24 22:11:02 angelos Exp $	*/
d362 1
@


1.7
log
@Fix RSA structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.6 2001/06/23 21:57:00 angelos Exp $	*/
d142 4
a145 5
			      * be both an input and an output.  If
			      * CRD_F_RNG_NEEDED is set, then priv_key
			      * is an input - otherwise it does not
			      * have to be given and will be an output
			      * after the public key generation.
@


1.6
log
@Remove unneeded crp_iv field, set the right flags for IV handling in
the crypto device.
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.5 2001/06/23 21:00:49 angelos Exp $	*/
d158 1
a158 1
	u_int16_t 	rsak_exponent_length;  	/* Length of exponent */
d160 5
a164 3
	u_int16_t	rsak_p_length;		/* Length of prime number p */
	u_int16_t	rsak_q_length;		/* Length of prime number q */
	u_int16_t 	rsak_priv_key_length;	/* Length of private key */
d169 5
a173 4
	caddr_t		rsak_prime_p;
	caddr_t		rsak_prime_q;
	caddr_t		rsak_priv_coeff;
	caddr_t		rsak_priv_key;
@


1.5
log
@New prototype for crypto_register(), to take into account maximum key
length (for PK operations) and various flags.

Structures for public key operations (DH, RSA, DSA). A lot of this
work was done by jgarfiel@@seas.upenn.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.4 2001/06/23 18:30:36 deraadt Exp $	*/
a280 1
	caddr_t		crp_iv;
@


1.4
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*	$OpenBSD: crypto.h,v 1.20 2001/06/16 22:17:49 deraadt Exp $	*/
d87 1
d89 128
a216 1
#define CRYPTO_ALGORITHM_MAX	11 /* Keep this updated */
d235 2
a236 2
#define CRD_F_ENCRYPT		0x1	/* Set when doing encryption */
#define CRD_F_IV_PRESENT	0x2	/* When encrypting, IV is already in
d238 2
a239 1
#define CRD_F_IV_EXPLICIT	0x4	/* IV explicitly provided */
d277 1
d279 1
d295 10
a304 1
	u_int8_t	cc_alg[CRYPTO_ALGORITHM_MAX + 1]; /* Supported */
a347 1

d349 1
d353 1
a353 1
int	crypto_register(u_int32_t, int,
@


1.3
log
@CRIOGET is a _IOWR ioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: cryptodev.h,v 1.2 2001/05/13 16:52:33 jason Exp $	*/
d4 19
d49 3
d54 120
d207 25
@


1.2
log
@copyrights and $OpenBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
a60 1
#define	CRIOGET		_IOR('c', 100, u_int32_t)
@


1.1
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 29
@

