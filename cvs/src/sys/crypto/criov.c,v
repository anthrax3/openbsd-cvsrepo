head	1.20;
access;
symbols
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.2
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.4
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.16.0.32
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.28
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.26
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.24
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.22
	OPENBSD_5_0:1.16.0.20
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.18
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.16
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.16.0.12
	OPENBSD_4_7_BASE:1.16
	OPENBSD_4_6:1.16.0.14
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.10
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.16.0.8
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.6
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.4
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.14.0.14
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.12
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.10
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.8
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.6
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.6.0.2;
locks; strict;
comment	@ * @;


1.20
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2014.09.14.14.17.23;	author jsg;	state Exp;
branches;
next	1.18;
commitid	uzzBR7hz9ncd4O6G;

1.18
date	2014.07.13.17.39.56;	author deraadt;	state Exp;
branches;
next	1.17;
commitid	sVZahxygcFVLsXYr;

1.17
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	EF98ch02VpFassUi;

1.16
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.19.22.13.47;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.14.15.18.05;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.31.20.35.10;	author markus;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.15.51.28;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.10.19.36.43;	author espie;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.01.02.46.57;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.29.15.48.29;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.08.12.20.06.08;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.06.23.18.30.35;	author deraadt;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.06.18.08.34.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.18.07.57.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.06.08.08.09.35;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2001.05.14.02.45.19;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2001.05.13.15.39.26;	author deraadt;	state Exp;
branches;
next	;

1.6.2.1
date	2001.10.31.03.11.47;	author nate;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.11.13.21.05.48;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2002.03.06.02.07.09;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.27.23.53.48;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.06.07.11.02.27;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.51.30;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.01.31.22.55.29;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.06.11.03.28.34;	author art;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.10.29.00.30.52;	author art;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*      $OpenBSD: criov.c,v 1.19 2014/09/14 14:17:23 jsg Exp $	*/

/*
 * Copyright (c) 1999 Theo de Raadt
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>

void
cuio_copydata(struct uio *uio, int off, int len, caddr_t cp)
{
	struct iovec *iov = uio->uio_iov;
	int iol = uio->uio_iovcnt;
	unsigned count;

	if (off < 0)
		panic("cuio_copydata: off %d < 0", off);
	if (len < 0)
		panic("cuio_copydata: len %d < 0", len);
	while (off > 0) {
		if (iol == 0)
			panic("iov_copydata: empty in skip");
		if (off < iov->iov_len)
			break;
		off -= iov->iov_len;
		iol--;
		iov++;
	}
	while (len > 0) {
		if (iol == 0)
			panic("cuio_copydata: empty");
		count = min(iov->iov_len - off, len);
		bcopy(((caddr_t)iov->iov_base) + off, cp, count);
		len -= count;
		cp += count;
		off = 0;
		iol--;
		iov++;
	}
}

void
cuio_copyback(struct uio *uio, int off, int len, const void *_cp)
{
	struct iovec *iov = uio->uio_iov;
	int iol = uio->uio_iovcnt;
	unsigned count;
	caddr_t cp = (caddr_t)_cp;

	if (off < 0)
		panic("cuio_copyback: off %d < 0", off);
	if (len < 0)
		panic("cuio_copyback: len %d < 0", len);
	while (off > 0) {
		if (iol == 0)
			panic("cuio_copyback: empty in skip");
		if (off < iov->iov_len)
			break;
		off -= iov->iov_len;
		iol--;
		iov++;
	}
	while (len > 0) {
		if (iol == 0)
			panic("uio_copyback: empty");
		count = min(iov->iov_len - off, len);
		bcopy(cp, ((caddr_t)iov->iov_base) + off, count);
		len -= count;
		cp += count;
		off = 0;
		iol--;
		iov++;
	}
}

int
cuio_getptr(struct uio *uio, int loc, int *off)
{
	int ind, len;

	ind = 0;
	while (loc >= 0 && ind < uio->uio_iovcnt) {
		len = uio->uio_iov[ind].iov_len;
		if (len > loc) {
			*off = loc;
			return (ind);
		}
		loc -= len;
		ind++;
	}

	if (ind > 0 && loc == 0) {
		ind--;
		*off = uio->uio_iov[ind].iov_len;
		return (ind);
	}

	return (-1);
}

int
cuio_apply(struct uio *uio, int off, int len,
    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t fstate)
{
	int rval, ind, uiolen;
	unsigned int count;

	if (len < 0)
		panic("cuio_apply: len %d < 0", len);
	if (off < 0)
		panic("cuio_apply: off %d < 0", off);
	
	ind = 0;
	while (off > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("cuio_apply: ind %d >= uio_iovcnt %d for off",
			    ind, uio->uio_iovcnt);
		uiolen = uio->uio_iov[ind].iov_len;
		if (off < uiolen)
			break;
		off -= uiolen;
		ind++;
	}
	while (len > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("cuio_apply: ind %d >= uio_iovcnt %d for len",
			    ind, uio->uio_iovcnt);
		count = min(uio->uio_iov[ind].iov_len - off, len);

		rval = f(fstate, (char *)uio->uio_iov[ind].iov_base + off,
		    count);
		if (rval)
			return (rval);

		len -= count;
		off = 0;
		ind++;
	}

	return (0);
}
@


1.19
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.18 2014/07/13 17:39:56 deraadt Exp $	*/
a32 2

#include <crypto/cryptodev.h>
@


1.18
log
@do not need malloc.h
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.17 2014/07/08 17:19:25 deraadt Exp $	*/
a29 1
#include <sys/proc.h>
@


1.17
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.16 2006/12/29 13:04:37 pedro Exp $	*/
a31 1
#include <sys/malloc.h>
@


1.16
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.15 2006/11/19 22:13:47 jmc Exp $	*/
a34 2

#include <uvm/uvm_extern.h>
@


1.15
log
@typo; from bret lambert
ok pedro
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.14 2003/08/14 15:18:05 jason Exp $	*/
d74 1
a74 1
cuio_copyback(struct uio *uio, int off, int len, const void *cp)
d79 1
d161 2
a162 1
		rval = f(fstate, uio->uio_iov[ind].iov_base + off, count);
@


1.14
log
@mirror change in mbufs: cuio_copyback's 4th arg is now const void *
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.13 2003/07/31 20:35:10 markus Exp $	*/
d146 1
a146 1
			panic("cui_apply: ind %d >= uio_iovcnt %d for off",
d156 1
a156 1
			panic("cui_apply: ind %d >= uio_iovcnt %d for len",
@


1.13
log
@pasto; lha@@stacken.kth.se
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.12 2003/06/03 15:51:28 deraadt Exp $	*/
d41 1
a41 4
cuio_copydata(uio, off, len, cp)
	struct uio *uio;
	int off, len;
	caddr_t cp;
d74 1
a74 4
cuio_copyback(uio, off, len, cp)
	struct uio *uio;
	int off, len;
	caddr_t cp;
@


1.12
log
@license cleanup regarding term 4
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.11 2002/06/10 19:36:43 espie Exp $	*/
d145 1
a145 1
		panic("%s: len %d < 0", __func__, len);
d147 1
a147 1
		panic("%s: off %d < 0", __func__, off);
d152 2
a153 1
			panic("m_apply: null mbuf in skip");
d162 2
a163 1
			panic("m_apply: null mbuf");
@


1.11
log
@__FUNCTION__ -> __func__
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.10 2002/03/01 02:46:57 provos Exp $	*/
a14 2
 * 3. The name of the author may not be used to endorse or promote products
 *   derived from this software without specific prior written permission.
@


1.10
log
@helper functions for uio (cuio_apply and cuio_getptr) okay deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.9 2002/01/29 15:48:29 jason Exp $	*/
d147 1
a147 1
		panic("%s: len %d < 0", __FUNCTION__, len);
d149 1
a149 1
		panic("%s: off %d < 0", __FUNCTION__, off);
@


1.9
log
@Remove the iov2pages/mbuf2pages API... All of the relevant arch's support
bus_dma(9) which actually does this job correctly.
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.8 2001/11/06 19:53:18 miod Exp $	*/
d112 64
@


1.8
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.7 2001/08/12 20:06:08 mickey Exp $	*/
a40 60

int
iov2pages(uio, np, pp, lp, maxp, nicep)
	struct uio *uio;
	int *np;
	long *pp;
	int *lp;
	int maxp;
	int *nicep;
{
	int npa = 0, tlen = 0;
	int i;

	for (i = 0; i < uio->uio_iovcnt; i++) {
		vaddr_t va, off;
		paddr_t pa;
		int len;

		if ((len = uio->uio_iov[i].iov_len) == 0)
			continue;
		tlen += len;
		va = (vaddr_t)uio->uio_iov[i].iov_base;
		off = va & PAGE_MASK;
		va -= off;

next_page:
		
		if (pmap_extract(pmap_kernel(), va, &pa) == FALSE)
			panic("iov2pages: unmapped pages");

		pa += off;

		lp[npa] = len;
		pp[npa] = pa;

		if (++npa > maxp)
			return (0);

		if (len + off > PAGE_SIZE) {
			lp[npa - 1] = PAGE_SIZE - off;
			va += PAGE_SIZE;
			len -= PAGE_SIZE;
			goto next_page;
		}
	}
			
	if (nicep) {
		int nice = 1;
		int i;

		/* see if each [pa,len] entry is long-word aligned */
		for (i = 0; i < npa; i++)
			if ((lp[i] & 3) || (pp[i] & 3))
				nice = 0;
		*nicep = nice;
	}

	*np = npa;
	return (tlen);
}
@


1.8.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.9 2002/01/29 15:48:29 jason Exp $	*/
d41 60
@


1.8.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.8.2.1 2002/01/31 22:55:29 niklas Exp $	*/
a111 64
}

int
cuio_getptr(struct uio *uio, int loc, int *off)
{
	int ind, len;

	ind = 0;
	while (loc >= 0 && ind < uio->uio_iovcnt) {
		len = uio->uio_iov[ind].iov_len;
		if (len > loc) {
			*off = loc;
			return (ind);
		}
		loc -= len;
		ind++;
	}

	if (ind > 0 && loc == 0) {
		ind--;
		*off = uio->uio_iov[ind].iov_len;
		return (ind);
	}

	return (-1);
}

int
cuio_apply(struct uio *uio, int off, int len,
    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t fstate)
{
	int rval, ind, uiolen;
	unsigned int count;

	if (len < 0)
		panic("%s: len %d < 0", __FUNCTION__, len);
	if (off < 0)
		panic("%s: off %d < 0", __FUNCTION__, off);
	
	ind = 0;
	while (off > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("m_apply: null mbuf in skip");
		uiolen = uio->uio_iov[ind].iov_len;
		if (off < uiolen)
			break;
		off -= uiolen;
		ind++;
	}
	while (len > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("m_apply: null mbuf");
		count = min(uio->uio_iov[ind].iov_len - off, len);

		rval = f(fstate, uio->uio_iov[ind].iov_base + off, count);
		if (rval)
			return (rval);

		len -= count;
		off = 0;
		ind++;
	}

	return (0);
@


1.8.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.8.2.2 2002/06/11 03:28:34 art Exp $	*/
d147 1
a147 1
		panic("%s: len %d < 0", __func__, len);
d149 1
a149 1
		panic("%s: off %d < 0", __func__, off);
@


1.7
log
@remove redundant vm includes
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.6 2001/06/23 18:30:35 deraadt Exp $	*/
d38 1
a38 1
#include <vm/vm.h>
@


1.6
log
@merge crypto/crypto{dev,}.h to crypto/cryptodev.h, to avoid name conflicts inside OpenSSL codebase
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.5 2001/06/18 08:34:45 deraadt Exp $	*/
d37 1
a38 2
#include <vm/vm_extern.h>
#include <vm/pmap.h>
@


1.6.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.6 2001/06/23 18:30:35 deraadt Exp $	*/
a36 1

d38 2
@


1.6.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*      $OpenBSD$	*/
d38 1
a38 1
#include <uvm/uvm_extern.h>
@


1.6.2.3
log
@Merge in trunk
@
text
@d42 60
a171 64
}

int
cuio_getptr(struct uio *uio, int loc, int *off)
{
	int ind, len;

	ind = 0;
	while (loc >= 0 && ind < uio->uio_iovcnt) {
		len = uio->uio_iov[ind].iov_len;
		if (len > loc) {
			*off = loc;
			return (ind);
		}
		loc -= len;
		ind++;
	}

	if (ind > 0 && loc == 0) {
		ind--;
		*off = uio->uio_iov[ind].iov_len;
		return (ind);
	}

	return (-1);
}

int
cuio_apply(struct uio *uio, int off, int len,
    int (*f)(caddr_t, caddr_t, unsigned int), caddr_t fstate)
{
	int rval, ind, uiolen;
	unsigned int count;

	if (len < 0)
		panic("%s: len %d < 0", __FUNCTION__, len);
	if (off < 0)
		panic("%s: off %d < 0", __FUNCTION__, off);
	
	ind = 0;
	while (off > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("m_apply: null mbuf in skip");
		uiolen = uio->uio_iov[ind].iov_len;
		if (off < uiolen)
			break;
		off -= uiolen;
		ind++;
	}
	while (len > 0) {
		if (ind >= uio->uio_iovcnt)
			panic("m_apply: null mbuf");
		count = min(uio->uio_iov[ind].iov_len - off, len);

		rval = f(fstate, uio->uio_iov[ind].iov_base + off, count);
		if (rval)
			return (rval);

		len -= count;
		off = 0;
		ind++;
	}

	return (0);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d147 1
a147 1
		panic("%s: len %d < 0", __func__, len);
d149 1
a149 1
		panic("%s: off %d < 0", __func__, off);
@


1.6.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.6.2.4 2003/03/27 23:53:48 niklas Exp $	*/
d15 2
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD$	*/
d41 4
a44 1
cuio_copydata(struct uio *uio, int off, int len, caddr_t cp)
d77 4
a80 1
cuio_copyback(struct uio *uio, int off, int len, const void *cp)
d145 1
a145 1
		panic("cuio_apply: len %d < 0", len);
d147 1
a147 1
		panic("cuio_apply: off %d < 0", off);
d152 1
a152 2
			panic("cui_apply: ind %d >= uio_iovcnt %d for off",
			    ind, uio->uio_iovcnt);
d161 1
a161 2
			panic("cui_apply: ind %d >= uio_iovcnt %d for len",
			    ind, uio->uio_iovcnt);
@


1.5
log
@oops, backwards check
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.4 2001/06/18 07:57:40 deraadt Exp $	*/
d41 1
a41 1
#include <crypto/crypto.h>
@


1.4
log
@incorrect panic message
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.3 2001/06/08 08:09:35 art Exp $	*/
d69 2
a70 2
		if (pmap_extract(pmap_kernel(), va, &pa) == TRUE)
			panic("iov2pages: unmapped pages 0x%x", va);
@


1.3
log
@Change the paddr_t pmap_extract(struct pmap *, vaddr_t) interface to
boolean_t pmap_extract(struct pmap *, vaddr_t, paddr_t *).
Matches NetBSD. Tested by various people on various platforms.
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.2 2001/05/14 02:45:19 deraadt Exp $	*/
d70 1
a70 1
			panic("mbuf2pages: unmapped pages");
@


1.2
log
@use real uio
@
text
@d1 1
a1 1
/*      $OpenBSD: criov.c,v 1.1 2001/05/13 15:39:26 deraadt Exp $	*/
d68 3
a70 3
		pa = pmap_extract(pmap_kernel(), va);
		if (pa == 0)
			panic("mbuf2pages: pa == 0");
@


1.1
log
@initial cut at /dev/crypto support.  takes original mbuf "try, and discard
if we fail" semantics and extends to two varients of data movement: mbuf,
or an iovec style block.
@
text
@d1 1
a1 1
/*      $OpenBSD: mbuf.c,v 1.3 2000/04/24 04:54:19 deraadt Exp $	*/
d44 2
a45 2
iov2pages(crio, np, pp, lp, maxp, nicep)
	struct criov *crio;
d55 1
a55 1
	for (i = 0; i < crio->niov; i++) {
d60 1
a60 1
		if ((len = crio->iov[i].iov_len) == 0)
d63 1
a63 1
		va = (vaddr_t)crio->iov[i].iov_base;
d104 2
a105 2
criov_copydata(crio, off, len, cp)
	struct criov *crio;
d109 2
a110 2
	struct iovec *iov = crio->iov;
	int iol = crio->niov;
d114 1
a114 1
		panic("criov_copydata: off %d < 0", off);
d116 1
a116 1
		panic("criov_copydata: len %d < 0", len);
d128 1
a128 1
			panic("criov_copydata: empty");
d140 2
a141 2
criov_copyback(crio, off, len, cp)
	struct criov *crio;
d145 2
a146 2
	struct iovec *iov = crio->iov;
	int iol = crio->niov;
d150 1
a150 1
		panic("criov_copyback: off %d < 0", off);
d152 1
a152 1
		panic("criov_copyback: len %d < 0", len);
d155 1
a155 1
			panic("criov_copyback: empty in skip");
d164 1
a164 1
			panic("criov_copyback: empty");
@

