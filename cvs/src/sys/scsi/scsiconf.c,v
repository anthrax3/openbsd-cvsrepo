head	1.195;
access;
symbols
	OPENBSD_6_1:1.195.0.4
	OPENBSD_6_1_BASE:1.195
	OPENBSD_6_0:1.195.0.2
	OPENBSD_6_0_BASE:1.195
	OPENBSD_5_9:1.193.0.2
	OPENBSD_5_9_BASE:1.193
	OPENBSD_5_8:1.192.0.4
	OPENBSD_5_8_BASE:1.192
	OPENBSD_5_7:1.190.0.2
	OPENBSD_5_7_BASE:1.190
	OPENBSD_5_6:1.188.0.4
	OPENBSD_5_6_BASE:1.188
	OPENBSD_5_5:1.186.0.4
	OPENBSD_5_5_BASE:1.186
	OPENBSD_5_4:1.184.0.4
	OPENBSD_5_4_BASE:1.184
	OPENBSD_5_3:1.184.0.2
	OPENBSD_5_3_BASE:1.184
	OPENBSD_5_2:1.182.0.4
	OPENBSD_5_2_BASE:1.182
	OPENBSD_5_1_BASE:1.182
	OPENBSD_5_1:1.182.0.2
	OPENBSD_5_0:1.180.0.2
	OPENBSD_5_0_BASE:1.180
	OPENBSD_4_9:1.167.0.2
	OPENBSD_4_9_BASE:1.167
	OPENBSD_4_8:1.162.0.2
	OPENBSD_4_8_BASE:1.162
	OPENBSD_4_7:1.154.0.2
	OPENBSD_4_7_BASE:1.154
	OPENBSD_4_6:1.138.0.6
	OPENBSD_4_6_BASE:1.138
	OPENBSD_4_5:1.138.0.2
	OPENBSD_4_5_BASE:1.138
	OPENBSD_4_4:1.135.0.2
	OPENBSD_4_4_BASE:1.135
	OPENBSD_4_3:1.129.0.2
	OPENBSD_4_3_BASE:1.129
	OPENBSD_4_2:1.125.0.2
	OPENBSD_4_2_BASE:1.125
	OPENBSD_4_1:1.124.0.2
	OPENBSD_4_1_BASE:1.124
	OPENBSD_4_0:1.111.0.2
	OPENBSD_4_0_BASE:1.111
	OPENBSD_3_9:1.100.0.2
	OPENBSD_3_9_BASE:1.100
	OPENBSD_3_8:1.96.0.2
	OPENBSD_3_8_BASE:1.96
	OPENBSD_3_7:1.92.0.4
	OPENBSD_3_7_BASE:1.92
	OPENBSD_3_6:1.92.0.2
	OPENBSD_3_6_BASE:1.92
	SMP_SYNC_A:1.91
	SMP_SYNC_B:1.91
	OPENBSD_3_5:1.87.0.2
	OPENBSD_3_5_BASE:1.87
	OPENBSD_3_4:1.73.0.2
	OPENBSD_3_4_BASE:1.73
	UBC_SYNC_A:1.72
	OPENBSD_3_3:1.70.0.2
	OPENBSD_3_3_BASE:1.70
	OPENBSD_3_2:1.69.0.2
	OPENBSD_3_2_BASE:1.69
	OPENBSD_3_1:1.67.0.2
	OPENBSD_3_1_BASE:1.67
	UBC_SYNC_B:1.69
	UBC:1.63.0.2
	UBC_BASE:1.63
	OPENBSD_3_0:1.62.0.2
	OPENBSD_3_0_BASE:1.62
	OPENBSD_2_9_BASE:1.55
	OPENBSD_2_9:1.55.0.2
	OPENBSD_2_8:1.52.0.4
	OPENBSD_2_8_BASE:1.52
	OPENBSD_2_7:1.52.0.2
	OPENBSD_2_7_BASE:1.52
	SMP:1.49.0.2
	SMP_BASE:1.49
	kame_19991208:1.46
	OPENBSD_2_6:1.45.0.2
	OPENBSD_2_6_BASE:1.45
	OPENBSD_2_5:1.42.0.2
	OPENBSD_2_5_BASE:1.42
	OPENBSD_2_4:1.39.0.2
	OPENBSD_2_4_BASE:1.39
	OPENBSD_2_3:1.35.0.2
	OPENBSD_2_3_BASE:1.35
	OPENBSD_2_2:1.32.0.2
	OPENBSD_2_2_BASE:1.32
	OPENBSD_2_1:1.28.0.2
	OPENBSD_2_1_BASE:1.28
	OPENBSD_2_0:1.14.0.2
	OPENBSD_2_0_BASE:1.14
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.195
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.194;
commitid	zkFngOKA3woPgVlY;

1.194
date	2016.03.10.13.56.14;	author krw;	state Exp;
branches;
next	1.193;
commitid	1lzwtVyYzQ8tyf5s;

1.193
date	2015.08.23.01.55.39;	author tedu;	state Exp;
branches;
next	1.192;
commitid	OczmFvlAy5J4Utsq;

1.192
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.191;
commitid	MxUWuiPFtM1nRYxm;

1.191
date	2015.03.14.03.38.52;	author jsg;	state Exp;
branches;
next	1.190;
commitid	p4LJxGKbi0BU2cG6;

1.190
date	2015.02.11.00.50.03;	author dlg;	state Exp;
branches;
next	1.189;
commitid	aZMYtqPVrKhVed9H;

1.189
date	2014.12.15.02.11.57;	author tedu;	state Exp;
branches;
next	1.188;
commitid	idrzCI81iA9oSrel;

1.188
date	2014.07.12.18.50.25;	author tedu;	state Exp;
branches;
next	1.187;
commitid	iN7nvia2fLP712wt;

1.187
date	2014.04.22.07.29.11;	author dlg;	state Exp;
branches;
next	1.186;

1.186
date	2014.01.31.02.53.41;	author dlg;	state Exp;
branches;
next	1.185;

1.185
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.184;

1.184
date	2012.10.16.10.30.52;	author jsg;	state Exp;
branches;
next	1.183;

1.183
date	2012.10.08.21.47.51;	author deraadt;	state Exp;
branches;
next	1.182;

1.182
date	2011.09.22.21.36.00;	author jsing;	state Exp;
branches;
next	1.181;

1.181
date	2011.09.02.01.19.12;	author dlg;	state Exp;
branches;
next	1.180;

1.180
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.179;

1.179
date	2011.07.06.00.45.52;	author matthew;	state Exp;
branches;
next	1.178;

1.178
date	2011.07.05.21.39.56;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.176;

1.176
date	2011.06.21.22.36.42;	author matthew;	state Exp;
branches;
next	1.175;

1.175
date	2011.05.04.20.49.41;	author sthen;	state Exp;
branches;
next	1.174;

1.174
date	2011.04.29.02.10.05;	author dlg;	state Exp;
branches;
next	1.173;

1.173
date	2011.04.06.15.16.54;	author dlg;	state Exp;
branches;
next	1.172;

1.172
date	2011.04.06.13.33.46;	author dlg;	state Exp;
branches;
next	1.171;

1.171
date	2011.04.05.22.39.19;	author dlg;	state Exp;
branches;
next	1.170;

1.170
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	1.169;

1.169
date	2011.03.31.18.42.48;	author jasper;	state Exp;
branches;
next	1.168;

1.168
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.167;

1.167
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.166;

1.166
date	2010.09.08.00.58.05;	author dlg;	state Exp;
branches;
next	1.165;

1.165
date	2010.09.02.11.54.44;	author dlg;	state Exp;
branches;
next	1.164;

1.164
date	2010.08.31.17.13.48;	author deraadt;	state Exp;
branches;
next	1.163;

1.163
date	2010.08.25.00.31.35;	author dlg;	state Exp;
branches;
next	1.162;

1.162
date	2010.07.24.04.01.52;	author matthew;	state Exp;
branches;
next	1.161;

1.161
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.160;

1.160
date	2010.07.01.03.20.39;	author matthew;	state Exp;
branches;
next	1.159;

1.159
date	2010.06.30.19.23.59;	author deraadt;	state Exp;
branches;
next	1.158;

1.158
date	2010.06.30.19.06.29;	author kettenis;	state Exp;
branches;
next	1.157;

1.157
date	2010.04.23.21.34.40;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2010.04.17.00.51.13;	author dlg;	state Exp;
branches;
next	1.155;

1.155
date	2010.04.06.00.58.00;	author dlg;	state Exp;
branches;
next	1.154;

1.154
date	2010.01.01.14.28.59;	author miod;	state Exp;
branches;
next	1.153;

1.153
date	2010.01.01.06.30.27;	author dlg;	state Exp;
branches;
next	1.152;

1.152
date	2009.12.01.01.40.02;	author dlg;	state Exp;
branches;
next	1.151;

1.151
date	2009.11.12.06.20.27;	author dlg;	state Exp;
branches;
next	1.150;

1.150
date	2009.11.10.10.34.07;	author dlg;	state Exp;
branches;
next	1.149;

1.149
date	2009.11.10.10.13.08;	author dlg;	state Exp;
branches;
next	1.148;

1.148
date	2009.11.05.03.33.52;	author marco;	state Exp;
branches;
next	1.147;

1.147
date	2009.10.23.01.02.29;	author dlg;	state Exp;
branches;
next	1.146;

1.146
date	2009.10.22.11.56.32;	author dlg;	state Exp;
branches;
next	1.145;

1.145
date	2009.10.14.01.33.22;	author dlg;	state Exp;
branches;
next	1.144;

1.144
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.143;

1.143
date	2009.09.14.00.03.28;	author dlg;	state Exp;
branches;
next	1.142;

1.142
date	2009.08.10.11.02.38;	author dlg;	state Exp;
branches;
next	1.141;

1.141
date	2009.08.10.10.51.17;	author dlg;	state Exp;
branches;
next	1.140;

1.140
date	2009.08.09.12.47.23;	author dlg;	state Exp;
branches;
next	1.139;

1.139
date	2009.08.08.09.33.50;	author dlg;	state Exp;
branches;
next	1.138;

1.138
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.137;

1.137
date	2009.02.16.21.13.31;	author krw;	state Exp;
branches;
next	1.136;

1.136
date	2009.02.16.00.05.03;	author dlg;	state Exp;
branches;
next	1.135;

1.135
date	2008.07.22.01.01.31;	author dlg;	state Exp;
branches;
next	1.134;

1.134
date	2008.07.22.00.40.37;	author dlg;	state Exp;
branches;
next	1.133;

1.133
date	2008.07.21.23.40.03;	author dlg;	state Exp;
branches;
next	1.132;

1.132
date	2008.06.14.01.57.51;	author krw;	state Exp;
branches;
next	1.131;

1.131
date	2008.05.26.17.58.40;	author kettenis;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.24.14.51.12;	author krw;	state Exp;
branches;
next	1.129;

1.129
date	2007.11.26.15.40.51;	author dlg;	state Exp;
branches;
next	1.128;

1.128
date	2007.11.25.22.28.54;	author dlg;	state Exp;
branches;
next	1.127;

1.127
date	2007.11.06.02.49.19;	author krw;	state Exp;
branches;
next	1.126;

1.126
date	2007.09.16.15.54.52;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2007.05.08.18.50.39;	author deraadt;	state Exp;
branches;
next	1.124;

1.124
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.123;

1.123
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.122;

1.122
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.121;

1.121
date	2006.11.27.18.32.33;	author dlg;	state Exp;
branches;
next	1.120;

1.120
date	2006.11.27.13.33.15;	author dlg;	state Exp;
branches;
next	1.119;

1.119
date	2006.11.27.11.56.20;	author dlg;	state Exp;
branches;
next	1.118;

1.118
date	2006.11.26.09.29.07;	author dlg;	state Exp;
branches;
next	1.117;

1.117
date	2006.10.21.07.36.15;	author dlg;	state Exp;
branches;
next	1.116;

1.116
date	2006.10.07.23.40.07;	author beck;	state Exp;
branches;
next	1.115;

1.115
date	2006.10.02.09.06.26;	author dlg;	state Exp;
branches;
next	1.114;

1.114
date	2006.10.01.13.00.47;	author dlg;	state Exp;
branches;
next	1.113;

1.113
date	2006.09.22.00.33.41;	author dlg;	state Exp;
branches;
next	1.112;

1.112
date	2006.09.21.08.42.11;	author dlg;	state Exp;
branches;
next	1.111;

1.111
date	2006.07.29.02.40.45;	author krw;	state Exp;
branches;
next	1.110;

1.110
date	2006.07.23.14.34.55;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2006.07.22.18.25.42;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2006.07.22.18.03.07;	author krw;	state Exp;
branches;
next	1.107;

1.107
date	2006.07.14.01.27.40;	author krw;	state Exp;
branches;
next	1.106;

1.106
date	2006.07.13.11.46.16;	author krw;	state Exp;
branches;
next	1.105;

1.105
date	2006.07.11.21.55.46;	author dlg;	state Exp;
branches;
next	1.104;

1.104
date	2006.07.11.09.45.53;	author dlg;	state Exp;
branches;
next	1.103;

1.103
date	2006.07.11.09.28.35;	author dlg;	state Exp;
branches;
next	1.102;

1.102
date	2006.05.13.18.31.34;	author krw;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.100;

1.100
date	2006.01.21.12.18.49;	author miod;	state Exp;
branches;
next	1.99;

1.99
date	2006.01.18.19.54.49;	author krw;	state Exp;
branches;
next	1.98;

1.98
date	2005.11.13.03.27.42;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.10.20.06.12;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2005.06.03.15.24.05;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2005.05.07.16.24.46;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2005.04.28.00.12.55;	author krw;	state Exp;
branches;
next	1.93;

1.93
date	2005.04.27.23.54.44;	author krw;	state Exp;
branches;
next	1.92;

1.92
date	2004.07.31.11.31.30;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2004.05.09.14.08.11;	author krw;	state Exp;
branches;
next	1.90;

1.90
date	2004.05.07.22.56.19;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2004.05.07.18.13.31;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.18.00.49.29;	author krw;	state Exp;
branches;
next	1.87;

1.87
date	2004.03.10.01.37.40;	author krw;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2004.02.21.00.47.42;	author krw;	state Exp;
branches;
next	1.85;

1.85
date	2004.02.07.22.39.16;	author krw;	state Exp;
branches;
next	1.84;

1.84
date	2004.01.30.23.07.36;	author tdeval;	state Exp;
branches;
next	1.83;

1.83
date	2004.01.29.13.46.25;	author tdeval;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.29.12.47.18;	author tdeval;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.25.00.09.20;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.24.22.01.46;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.23.02.44.21;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.17.13.56.56;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.14.02.00.41;	author krw;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.07.18.11.16;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.27.03.08.58;	author mickey;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.30.02.24.44;	author mickey;	state Exp;
branches;
next	1.73;

1.73
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.72;

1.72
date	2003.05.17.06.08.39;	author nate;	state Exp;
branches;
next	1.71;

1.71
date	2003.05.16.19.54.05;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2002.12.30.21.50.28;	author grange;	state Exp;
branches;
next	1.69;

1.69
date	2002.09.04.23.11.10;	author tdeval;	state Exp;
branches;
next	1.68;

1.68
date	2002.09.04.23.07.28;	author tdeval;	state Exp;
branches;
next	1.67;

1.67
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.09.23.37.09;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.28.00.02.48;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2002.02.16.17.20.27;	author millert;	state Exp;
branches;
next	1.63;

1.63
date	2001.11.02.00.08.16;	author millert;	state Exp;
branches
	1.63.2.1;
next	1.62;

1.62
date	2001.10.08.01.50.48;	author drahn;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.26.22.35.03;	author millert;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.25.19.29.16;	author fgsch;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.18.02.24.02;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2001.06.24.21.29.04;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches;
next	1.56;

1.56
date	2001.05.24.04.13.16;	author angelos;	state Exp;
branches;
next	1.55;

1.55
date	2001.01.22.19.11.48;	author csapuntz;	state Exp;
branches;
next	1.54;

1.54
date	2000.11.23.08.55.35;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2000.11.20.07.34.51;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2000.04.18.05.53.17;	author csapuntz;	state Exp;
branches;
next	1.51;

1.51
date	2000.04.08.19.19.33;	author csapuntz;	state Exp;
branches;
next	1.50;

1.50
date	2000.02.21.08.21.22;	author mjacob;	state Exp;
branches;
next	1.49;

1.49
date	99.12.31.20.24.05;	author millert;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	99.12.16.05.17.36;	author mjacob;	state Exp;
branches;
next	1.47;

1.47
date	99.12.11.21.04.26;	author csapuntz;	state Exp;
branches;
next	1.46;

1.46
date	99.11.22.12.55.16;	author mjacob;	state Exp;
branches;
next	1.45;

1.45
date	99.07.24.23.56.43;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	99.07.24.13.16.01;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	99.07.20.06.21.59;	author csapuntz;	state Exp;
branches;
next	1.42;

1.42
date	99.02.24.07.36.02;	author downsj;	state Exp;
branches;
next	1.41;

1.41
date	98.11.28.23.33.30;	author downsj;	state Exp;
branches;
next	1.40;

1.40
date	98.11.11.00.03.47;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	98.07.19.06.08.28;	author downsj;	state Exp;
branches;
next	1.38;

1.38
date	98.06.26.01.28.28;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	98.05.05.19.07.18;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	98.04.25.00.25.26;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	98.03.18.21.56.46;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	98.02.16.21.23.38;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	98.01.12.19.20.35;	author kstailey;	state Exp;
branches;
next	1.32;

1.32
date	97.09.30.02.53.11;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	97.09.30.02.49.18;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	97.09.11.08.03.20;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.07.25.01.55.47;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	97.04.14.04.09.14;	author downsj;	state Exp;
branches;
next	1.27;

1.27
date	97.04.02.08.01.56;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	97.03.13.05.30.02;	author briggs;	state Exp;
branches;
next	1.25;

1.25
date	97.02.27.06.19.21;	author tholo;	state Exp;
branches;
next	1.24;

1.24
date	97.02.24.20.14.40;	author jkatz;	state Exp;
branches;
next	1.23;

1.23
date	97.01.18.12.24.25;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.01.16.20.47.32;	author kstailey;	state Exp;
branches;
next	1.21;

1.21
date	97.01.16.14.23.32;	author maja;	state Exp;
branches;
next	1.20;

1.20
date	97.01.15.05.50.27;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.11.28.13.20.37;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	96.11.25.04.49.23;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	96.11.25.00.31.14;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	96.11.23.21.47.12;	author kstailey;	state Exp;
branches;
next	1.15;

1.15
date	96.10.20.01.07.04;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	96.08.30.00.11.26;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	96.08.15.11.51.54;	author shawn;	state Exp;
branches;
next	1.12;

1.12
date	96.07.24.23.16.11;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.06.10.00.43.59;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.05.06.11.33.06;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.02.13.17.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.31.04;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.04.19.16.10.15;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.02.20.02.28.52;	author briggs;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.21.02.45;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.10.19.08.04;	author briggs;	state Exp;
branches;
next	1.3;

1.3
date	96.01.01.00.12.40;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.05.51.38;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.49.2.1
date	2000.02.21.22.29.15;	author niklas;	state Exp;
branches;
next	1.49.2.2;

1.49.2.2
date	2001.05.14.22.44.59;	author niklas;	state Exp;
branches;
next	1.49.2.3;

1.49.2.3
date	2001.07.04.11.00.06;	author niklas;	state Exp;
branches;
next	1.49.2.4;

1.49.2.4
date	2001.10.31.03.30.30;	author nate;	state Exp;
branches;
next	1.49.2.5;

1.49.2.5
date	2001.11.13.23.02.30;	author niklas;	state Exp;
branches;
next	1.49.2.6;

1.49.2.6
date	2002.03.06.02.17.13;	author niklas;	state Exp;
branches;
next	1.49.2.7;

1.49.2.7
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.49.2.8;

1.49.2.8
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.49.2.9;

1.49.2.9
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.49.2.10;

1.49.2.10
date	2004.02.19.11.01.30;	author niklas;	state Exp;
branches;
next	1.49.2.11;

1.49.2.11
date	2004.06.05.23.13.08;	author niklas;	state Exp;
branches;
next	;

1.63.2.1
date	2002.06.11.03.32.13;	author art;	state Exp;
branches;
next	1.63.2.2;

1.63.2.2
date	2002.10.29.00.36.49;	author art;	state Exp;
branches;
next	1.63.2.3;

1.63.2.3
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.87.2.1
date	2004.04.30.22.07.37;	author brad;	state Exp;
branches;
next	;


desc
@@


1.195
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@/*	$OpenBSD: scsiconf.c,v 1.194 2016/03/10 13:56:14 krw Exp $	*/
/*	$NetBSD: scsiconf.c,v 1.57 1996/05/02 01:09:01 neil Exp $	*/

/*
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 */

#include "bio.h"
#include "mpath.h"

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/atomic.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#if NBIO > 0
#include <sys/ioctl.h>
#include <sys/scsiio.h>
#include <dev/biovar.h>
#endif

/*
 * Declarations
 */
int	scsi_probedev(struct scsibus_softc *, int, int);

void	scsi_devid(struct scsi_link *);
int	scsi_devid_pg80(struct scsi_link *);
int	scsi_devid_pg83(struct scsi_link *);
int	scsi_devid_wwn(struct scsi_link *);

int	scsibusmatch(struct device *, void *, void *);
void	scsibusattach(struct device *, struct device *, void *);
int	scsibusactivate(struct device *, int);
int	scsibusdetach(struct device *, int);

int	scsibussubmatch(struct device *, void *, void *);

#if NBIO > 0
int	scsibus_bioctl(struct device *, u_long, caddr_t);
#endif

struct cfattach scsibus_ca = {
	sizeof(struct scsibus_softc), scsibusmatch, scsibusattach,
	scsibusdetach, scsibusactivate
};

struct cfdriver scsibus_cd = {
	NULL, "scsibus", DV_DULL
};

#ifdef SCSIDEBUG
u_int32_t scsidebug_buses = SCSIDEBUG_BUSES;
u_int32_t scsidebug_targets = SCSIDEBUG_TARGETS;
u_int32_t scsidebug_luns = SCSIDEBUG_LUNS;
int scsidebug_level = SCSIDEBUG_LEVEL;
#endif

int scsi_autoconf = SCSI_AUTOCONF;

int scsibusprint(void *, const char *);
void scsibus_printlink(struct scsi_link *);

int scsi_activate_bus(struct scsibus_softc *, int);
int scsi_activate_target(struct scsibus_softc *, int, int);
int scsi_activate_lun(struct scsibus_softc *, int, int, int);

const u_int8_t version_to_spc [] = {
	0, /* 0x00: The device does not claim conformance to any standard. */
	1, /* 0x01: (Obsolete) SCSI-1 in olden times. */
	2, /* 0x02: (Obsolete) SCSI-2 in olden times. */
	3, /* 0x03: The device complies to ANSI INCITS 301-1997 (SPC-3). */
	2, /* 0x04: The device complies to ANSI INCITS 351-2001 (SPC-2). */
	3, /* 0x05: The device complies to ANSI INCITS 408-2005 (SPC-3). */
	4, /* 0x06: The device complies to SPC-4. */
	0, /* 0x07: RESERVED. */
};

int
scsiprint(void *aux, const char *pnp)
{
	/* only "scsibus"es can attach to "scsi"s; easy. */
	if (pnp)
		printf("scsibus at %s", pnp);

	return (UNCONF);
}

int
scsibusmatch(struct device *parent, void *match, void *aux)
{
	return (1);
}

/*
 * The routine called by the adapter boards to get all their
 * devices configured in.
 */
void
scsibusattach(struct device *parent, struct device *self, void *aux)
{
	struct scsibus_softc		*sb = (struct scsibus_softc *)self;
	struct scsibus_attach_args	*saa = aux;
	struct scsi_link		*sc_link_proto = saa->saa_sc_link;

	if (!cold)
		scsi_autoconf = 0;

	sc_link_proto->bus = sb;
	sc_link_proto->scsibus = sb->sc_dev.dv_unit;
	sb->adapter_link = sc_link_proto;
	if (sb->adapter_link->adapter_buswidth == 0)
		sb->adapter_link->adapter_buswidth = 8;
	sb->sc_buswidth = sb->adapter_link->adapter_buswidth;
	if (sb->adapter_link->luns == 0)
		sb->adapter_link->luns = 8;

	printf(": %d targets", sb->sc_buswidth);
	if (sb->adapter_link->adapter_target < sb->sc_buswidth)
		printf(", initiator %d", sb->adapter_link->adapter_target);
	if (sb->adapter_link->port_wwn != 0x0 &&
	    sb->adapter_link->node_wwn != 0x0) {
		printf(", WWPN %016llx, WWNN %016llx",
		    sb->adapter_link->port_wwn, sb->adapter_link->node_wwn);
	}
	printf("\n");

	/* Initialize shared data. */
	scsi_init();

	SLIST_INIT(&sb->sc_link_list);

#if NBIO > 0
	if (bio_register(&sb->sc_dev, scsibus_bioctl) != 0)
		printf("%s: unable to register bio\n", sb->sc_dev.dv_xname);
#endif

	scsi_probe_bus(sb);
}

int
scsibusactivate(struct device *dev, int act)
{
	struct scsibus_softc *sb = (struct scsibus_softc *)dev;

	return scsi_activate(sb, -1, -1, act);
}

int
scsi_activate(struct scsibus_softc *sb, int target, int lun, int act)
{
	if (target == -1 && lun == -1)
		return scsi_activate_bus(sb, act);

	if (target == -1)
		return 0;

	if (lun == -1)
		return scsi_activate_target(sb, target, act);

	return scsi_activate_lun(sb, target, lun, act);
}

int
scsi_activate_bus(struct scsibus_softc *sb, int act)
{
	int target, rv = 0, r;

	for (target = 0; target < sb->sc_buswidth; target++) {
		r = scsi_activate_target(sb, target, act);
		if (r)
			rv = r;
	}
	return (rv);
}

int
scsi_activate_target(struct scsibus_softc *sb, int target, int act)
{
	int lun, rv = 0, r;

	for (lun = 0; lun < sb->adapter_link->luns; lun++) {
		r = scsi_activate_lun(sb, target, lun, act);
		if (r)
			rv = r;
	}
	return (rv);
}

int
scsi_activate_lun(struct scsibus_softc *sb, int target, int lun, int act)
{
	struct scsi_link *link;
	struct device *dev;
	int rv = 0;

	link = scsi_get_link(sb, target, lun);
	if (link == NULL)
		return (0);

	dev = link->device_softc;
	switch (act) {
	case DVACT_DEACTIVATE:
		atomic_setbits_int(&link->state, SDEV_S_DYING);
		config_deactivate(dev);
		break;
	default:
		rv = config_suspend(dev, act);
		break;
	}
	return (rv);
}

int
scsibusdetach(struct device *dev, int type)
{
	struct scsibus_softc		*sb = (struct scsibus_softc *)dev;
	int				error;

#if NBIO > 0
	bio_unregister(&sb->sc_dev);
#endif

	error = scsi_detach_bus(sb, type);
	if (error != 0)
		return (error);

	KASSERT(SLIST_EMPTY(&sb->sc_link_list));

	return (0);
}

int
scsibussubmatch(struct device *parent, void *match, void *aux)
{
	struct cfdata			*cf = match;
	struct scsi_attach_args		*sa = aux;
	struct scsi_link		*link = sa->sa_sc_link;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != link->target)
		return (0);
	if (cf->cf_loc[1] != -1 && cf->cf_loc[1] != link->lun)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, match, aux));
}

#if NBIO > 0
int
scsibus_bioctl(struct device *dev, u_long cmd, caddr_t addr)
{
	struct scsibus_softc		*sb = (struct scsibus_softc *)dev;
	struct sbioc_device		*sdev;

	switch (cmd) {
	case SBIOCPROBE:
		sdev = (struct sbioc_device *)addr;
		return (scsi_probe(sb, sdev->sd_target, sdev->sd_lun));

	case SBIOCDETACH:
		sdev = (struct sbioc_device *)addr;
		return (scsi_detach(sb, sdev->sd_target, sdev->sd_lun, 0));

	default:
		return (ENOTTY);
	}
}
#endif

int
scsi_probe_bus(struct scsibus_softc *sb)
{
	struct scsi_link *alink = sb->adapter_link;
	int i;

	for (i = 0; i < alink->adapter_buswidth; i++)
		scsi_probe_target(sb, i);

	return (0);
}

int
scsi_probe_target(struct scsibus_softc *sb, int target)
{
	struct scsi_link *alink = sb->adapter_link;
	struct scsi_link *link;
	struct scsi_report_luns_data *report;
	int i, nluns, lun;

	if (scsi_probe_lun(sb, target, 0) == EINVAL)
		return (EINVAL);

	link = scsi_get_link(sb, target, 0);
	if (link == NULL)
		return (ENXIO);

	if ((link->flags & (SDEV_UMASS | SDEV_ATAPI)) == 0 &&
	    SCSISPC(link->inqdata.version) > 2) {
		report = dma_alloc(sizeof(*report), PR_WAITOK);
		if (report == NULL)
			goto dumbscan;

		if (scsi_report_luns(link, REPORT_NORMAL, report,
		    sizeof(*report), scsi_autoconf | SCSI_SILENT |
		    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY |
		    SCSI_IGNORE_MEDIA_CHANGE, 10000) != 0) {
			dma_free(report, sizeof(*report));
			goto dumbscan;
		}

		/*
		 * XXX In theory we should check if data is full, which
		 * would indicate it needs to be enlarged and REPORT
		 * LUNS tried again. Solaris tries up to 3 times with
		 * larger sizes for data.
		 */
		nluns = _4btol(report->length) / RPL_LUNDATA_SIZE;
		for (i = 0; i < nluns; i++) {
			if (report->luns[i].lundata[0] != 0)
				continue;
			lun = report->luns[i].lundata[RPL_LUNDATA_T0LUN];
			if (lun == 0)
				continue;

			/* Probe the provided LUN. Don't check LUN 0. */
			scsi_remove_link(sb, link);
			scsi_probe_lun(sb, target, lun);
			scsi_add_link(sb, link);
		}

		dma_free(report, sizeof(*report));
		return (0);
	}

dumbscan:
	for (i = 1; i < alink->luns; i++) {
		if (scsi_probe_lun(sb, target, i) == EINVAL)
			break;
	}

	return (0);
}

int
scsi_probe(struct scsibus_softc *sb, int target, int lun)
{
	if (target == -1 && lun == -1)
		return (scsi_probe_bus(sb));

	/* specific lun and wildcard target is bad */
	if (target == -1)
		return (EINVAL);

	if (lun == -1)
		return (scsi_probe_target(sb, target));

	return (scsi_probe_lun(sb, target, lun));
}

int
scsi_probe_lun(struct scsibus_softc *sb, int target, int lun)
{
	struct scsi_link *alink = sb->adapter_link;

	if (target < 0 || target >= alink->adapter_buswidth ||
	    target == alink->adapter_target ||
	    lun < 0 || lun >= alink->luns)
		return (ENXIO);

	return (scsi_probedev(sb, target, lun));
}

int
scsi_detach_bus(struct scsibus_softc *sb, int flags)
{
	struct scsi_link *alink = sb->adapter_link;
	int i, err, rv = 0;

	for (i = 0; i < alink->adapter_buswidth; i++) {
		err = scsi_detach_target(sb, i, flags);
		if (err != 0 && err != ENXIO)
			rv = err;
	}

	return (rv);
}

int
scsi_detach(struct scsibus_softc *sb, int target, int lun, int flags)
{
	if (target == -1 && lun == -1)
		return (scsi_detach_bus(sb, flags));

	/* specific lun and wildcard target is bad */
	if (target == -1)
		return (EINVAL);

	if (lun == -1)
		return (scsi_detach_target(sb, target, flags));

	return (scsi_detach_lun(sb, target, lun, flags));
}

int
scsi_detach_target(struct scsibus_softc *sb, int target, int flags)
{
	struct scsi_link *alink = sb->adapter_link;
	int i, err, rv = 0;

	if (target < 0 || target >= alink->adapter_buswidth ||
	    target == alink->adapter_target)
		return (ENXIO);

	for (i = 0; i < alink->luns; i++) { /* nicer backwards? */
		if (scsi_get_link(sb, target, i) == NULL)
			continue;

		err = scsi_detach_lun(sb, target, i, flags);
		if (err != 0 && err != ENXIO)
			rv = err;
	}

	return (rv);
}

int
scsi_detach_lun(struct scsibus_softc *sb, int target, int lun, int flags)
{
	struct scsi_link *alink = sb->adapter_link;
	struct scsi_link *link;
	int rv;

	if (target < 0 || target >= alink->adapter_buswidth ||
	    target == alink->adapter_target ||
	    lun < 0 || lun >= alink->luns)
		return (ENXIO);

	link = scsi_get_link(sb, target, lun);
	if (link == NULL)
		return (ENXIO);

	if (((flags & DETACH_FORCE) == 0) && (link->flags & SDEV_OPEN))
		return (EBUSY);

	/* detaching a device from scsibus is a five step process... */

	/* 1. wake up processes sleeping for an xs */
	scsi_link_shutdown(link);

	/* 2. detach the device */
	rv = config_detach(link->device_softc, flags);

	if (rv != 0)
		return (rv);

	/* 3. if its using the openings io allocator, clean it up */
	if (ISSET(link->flags, SDEV_OWN_IOPL)) {
		scsi_iopool_destroy(link->pool);
		free(link->pool, M_DEVBUF, sizeof(*link->pool));
	}

	/* 4. free up its state in the adapter */
	if (alink->adapter->dev_free != NULL)
		alink->adapter->dev_free(link);

	/* 5. free up its state in the midlayer */
	if (link->id != NULL)
		devid_free(link->id);
	scsi_remove_link(sb, link);
	free(link, M_DEVBUF, sizeof(*link));

	return (0);
}

struct scsi_link *
scsi_get_link(struct scsibus_softc *sb, int target, int lun)
{
	struct scsi_link *link;

	SLIST_FOREACH(link, &sb->sc_link_list, bus_list)
		if (link->target == target && link->lun == lun)
			return (link);

	return (NULL);
}

void
scsi_add_link(struct scsibus_softc *sb, struct scsi_link *link)
{
	SLIST_INSERT_HEAD(&sb->sc_link_list, link, bus_list);
}

void
scsi_remove_link(struct scsibus_softc *sb, struct scsi_link *link)
{
	SLIST_REMOVE(&sb->sc_link_list, link, scsi_link, bus_list);
}

void
scsi_strvis(u_char *dst, u_char *src, int len)
{
	u_char				last;

	/* Trim leading and trailing whitespace and NULs. */
	while (len > 0 && (src[0] == ' ' || src[0] == '\t' || src[0] == '\n' ||
	    src[0] == '\0' || src[0] == 0xff))
		++src, --len;
	while (len > 0 && (src[len-1] == ' ' || src[len-1] == '\t' ||
	    src[len-1] == '\n' || src[len-1] == '\0' || src[len-1] == 0xff))
		--len;

	last = 0xff;
	while (len > 0) {
		switch (*src) {
		case ' ':
		case '\t':
		case '\n':
		case '\0':
		case 0xff:
			/* collapse whitespace and NULs to a single space */
			if (last != ' ')
				*dst++ = ' ';
			last = ' ';
			break;
		case '\\':
			/* quote characters */
			*dst++ = '\\';
			*dst++ = '\\';
			last = '\\';
			break;
		default:
			if (*src < 0x20 || *src >= 0x80) {
				/* non-printable characters */
				*dst++ = '\\';
				*dst++ = ((*src & 0300) >> 6) + '0';
				*dst++ = ((*src & 0070) >> 3) + '0';
				*dst++ = ((*src & 0007) >> 0) + '0';
			} else {
				/* normal characters */
				*dst++ = *src;
			}
			last = *src;
			break;
		}
		++src, --len;
	}

	*dst++ = 0;
}

struct scsi_quirk_inquiry_pattern {
	struct scsi_inquiry_pattern	pattern;
	u_int16_t			quirks;
};

const struct scsi_quirk_inquiry_pattern scsi_quirk_patterns[] = {
	{{T_CDROM, T_REMOV,
	 "PLEXTOR", "CD-ROM PX-40TS", "1.01"},    SDEV_NOSYNC},

	{{T_DIRECT, T_FIXED,
	 "MICROP  ", "1588-15MBSUN0669", ""},     SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "DEC     ", "RZ55     (C) DEC", ""},     SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "EMULEX  ", "MD21/S2     ESDI", "A00"},  SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "IBMRAID ", "0662S",            ""},     SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "IBM     ", "0663H",            ""},     SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "IBM",	  "0664",		 ""},	  SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "IBM     ", "H3171-S2",         ""},	  SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "IBM     ", "KZ-C",		 ""},	  SDEV_AUTOSAVE},
	/* Broken IBM disk */
	{{T_DIRECT, T_FIXED,
	 ""	   , "DFRSS2F",		 ""},	  SDEV_AUTOSAVE},
	{{T_DIRECT, T_FIXED,
	 "QUANTUM ", "ELS85S          ", ""},	  SDEV_AUTOSAVE},
	{{T_DIRECT, T_REMOV,
	 "iomega", "jaz 1GB",		 ""},	  SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "MICROP", "4421-07",		 ""},     SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "SEAGATE", "ST150176LW",        "0002"}, SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "HP", "C3725S",		 ""},     SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "IBM", "DCAS",			 ""},     SDEV_NOTAGS},

	{{T_SEQUENTIAL, T_REMOV,
	 "SONY    ", "SDT-5000        ", "3."},   SDEV_NOSYNC|SDEV_NOWIDE},
	{{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 1300      ", "02.4"}, SDEV_NOSYNC|SDEV_NOWIDE},
	{{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 2600      ", "01.7"}, SDEV_NOSYNC|SDEV_NOWIDE},
	{{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 3200      ", "02.2"}, SDEV_NOSYNC|SDEV_NOWIDE},

	/* ATAPI device quirks */
        {{T_CDROM, T_REMOV,
         "CR-2801TE", "", "1.07"},              ADEV_NOSENSE},
        {{T_CDROM, T_REMOV,
         "CREATIVECD3630E", "", "AC101"},       ADEV_NOSENSE},
        {{T_CDROM, T_REMOV,
         "FX320S", "", "q01"},                  ADEV_NOSENSE},
        {{T_CDROM, T_REMOV,
         "GCD-R580B", "", "1.00"},              ADEV_LITTLETOC},
        {{T_CDROM, T_REMOV,
         "MATSHITA CR-574", "", "1.02"},        ADEV_NOCAPACITY},
        {{T_CDROM, T_REMOV,
         "MATSHITA CR-574", "", "1.06"},        ADEV_NOCAPACITY},
        {{T_CDROM, T_REMOV,
         "Memorex CRW-2642", "", "1.0g"},       ADEV_NOSENSE},
        {{T_CDROM, T_REMOV,
         "SANYO CRD-256P", "", "1.02"},         ADEV_NOCAPACITY},
        {{T_CDROM, T_REMOV,
         "SANYO CRD-254P", "", "1.02"},         ADEV_NOCAPACITY},
        {{T_CDROM, T_REMOV,
         "SANYO CRD-S54P", "", "1.08"},         ADEV_NOCAPACITY},
        {{T_CDROM, T_REMOV,
         "CD-ROM  CDR-S1", "", "1.70"},         ADEV_NOCAPACITY}, /* Sanyo */
        {{T_CDROM, T_REMOV,
         "CD-ROM  CDR-N16", "", "1.25"},        ADEV_NOCAPACITY}, /* Sanyo */
        {{T_CDROM, T_REMOV,
         "UJDCD8730", "", "1.14"},              ADEV_NODOORLOCK}, /* Acer */
};


void
scsibus_printlink(struct scsi_link *link)
{
	char				vendor[33], product[65], revision[17];
	struct scsi_inquiry_data	*inqbuf;
	u_int8_t			type;
	int				removable;
	char				*dtype = NULL, *qtype = NULL;

	inqbuf = &link->inqdata;

	type = inqbuf->device & SID_TYPE;
	removable = inqbuf->dev_qual2 & SID_REMOVABLE ? 1 : 0;

	/*
	 * Figure out basic device type and qualifier.
	 */
	switch (inqbuf->device & SID_QUAL) {
	case SID_QUAL_LU_OK:
		qtype = "";
		break;

	case SID_QUAL_LU_OFFLINE:
		qtype = " offline";
		break;

	case SID_QUAL_RSVD:
		panic("scsibusprint: qualifier == SID_QUAL_RSVD");
	case SID_QUAL_BAD_LU:
		panic("scsibusprint: qualifier == SID_QUAL_BAD_LU");

	default:
		qtype = "";
		dtype = "vendor-unique";
		break;
	}
	if (dtype == NULL) {
		switch (type) {
		case T_DIRECT:
			dtype = "direct";
			break;
		case T_SEQUENTIAL:
			dtype = "sequential";
			break;
		case T_PRINTER:
			dtype = "printer";
			break;
		case T_PROCESSOR:
			dtype = "processor";
			break;
		case T_CDROM:
			dtype = "cdrom";
			break;
		case T_WORM:
			dtype = "worm";
			break;
		case T_SCANNER:
			dtype = "scanner";
			break;
		case T_OPTICAL:
			dtype = "optical";
			break;
		case T_CHANGER:
			dtype = "changer";
			break;
		case T_COMM:
			dtype = "communication";
			break;
		case T_ENCLOSURE:
			dtype = "enclosure services";
			break;
		case T_RDIRECT:
			dtype = "simplified direct";
			break;
		case T_NODEVICE:
			panic("scsibusprint: device type T_NODEVICE");
		default:
			dtype = "unknown";
			break;
		}
	}

	scsi_strvis(vendor, inqbuf->vendor, 8);
	scsi_strvis(product, inqbuf->product, 16);
	scsi_strvis(revision, inqbuf->revision, 4);

	printf(" targ %d lun %d: <%s, %s, %s> ", link->target, link->lun,
	    vendor, product, revision);
	if (link->flags & SDEV_ATAPI)
		printf("ATAPI");
	else
		printf("SCSI%d", SCSISPC(inqbuf->version));
	printf(" %d/%s %s%s", type, dtype, removable ? "removable" : "fixed",
	    qtype);

	if (link->id != NULL && link->id->d_type != DEVID_NONE) {
		u_int8_t *id = (u_int8_t *)(link->id + 1);
		int i;

		switch (link->id->d_type) {
		case DEVID_NAA:
			printf(" naa.");
			break;
		case DEVID_EUI:
			printf(" eui.");
			break;
		case DEVID_T10:
			printf(" t10.");
			break;
		case DEVID_SERIAL:
			printf(" serial.");
			break;
		case DEVID_WWN:
			printf(" wwn.");
			break;
		}

		if (ISSET(link->id->d_flags, DEVID_F_PRINT)) {
			for (i = 0; i < link->id->d_len; i++) {
				if (id[i] == '\0' || id[i] == ' ') {
					/* skip leading blanks */
					/* collapse multiple blanks into one */
					if (i > 0 && id[i-1] != id[i])
						printf("_");
				} else if (id[i] < 0x20 || id[i] >= 0x80) {
					/* non-printable characters */
					printf("~");
				} else {
					/* normal characters */
					printf("%c", id[i]);
				}
			}
		} else {
			for (i = 0; i < link->id->d_len; i++)
				printf("%02x", id[i]);
		}
	}
}

/*
 * Print out autoconfiguration information for a subdevice.
 *
 * This is a slight abuse of 'standard' autoconfiguration semantics,
 * because 'print' functions don't normally print the colon and
 * device information.  However, in this case that's better than
 * either printing redundant information before the attach message,
 * or having the device driver call a special function to print out
 * the standard device information.
 */
int
scsibusprint(void *aux, const char *pnp)
{
	struct scsi_attach_args		*sa = aux;

	if (pnp != NULL)
		printf("%s", pnp);

	scsibus_printlink(sa->sa_sc_link);

	return (UNCONF);
}

/*
 * Given a target and lun, ask the device what it is, and find the correct
 * driver table entry.
 *
 * Return 0 if further LUNs are possible, EINVAL if not.
 */
int
scsi_probedev(struct scsibus_softc *sb, int target, int lun)
{
	const struct scsi_quirk_inquiry_pattern *finger;
	struct scsi_inquiry_data *inqbuf, *usbinqbuf;
	struct scsi_attach_args sa;
	struct scsi_link *link, *link0;
	struct cfdata *cf;
	int priority, rslt = 0;

	/* Skip this slot if it is already attached and try the next LUN. */
	if (scsi_get_link(sb, target, lun) != NULL)
		return (0);

	link = malloc(sizeof(*link), M_DEVBUF, M_NOWAIT);
	if (link == NULL)
		return (EINVAL);

	*link = *sb->adapter_link;
	link->target = target;
	link->lun = lun;
	link->interpret_sense = scsi_interpret_sense;
	link->node_wwn = link->port_wwn = 0;
	TAILQ_INIT(&link->queue);

	SC_DEBUG(link, SDEV_DB2, ("scsi_link created.\n"));

	/* ask the adapter if this will be a valid device */
	if (sb->adapter_link->adapter->dev_probe != NULL &&
	    sb->adapter_link->adapter->dev_probe(link) != 0) {
		if (lun == 0)
			rslt = EINVAL;
		goto free;
	}

	/*
	 * If we havent been given an io pool by now then fall back to
	 * using link->openings.
	 */
	if (link->pool == NULL) {
		link->pool = malloc(sizeof(*link->pool),
		    M_DEVBUF, M_NOWAIT);
		if (link->pool == NULL) {
			rslt = ENOMEM;
			goto bad;
		}
		scsi_iopool_init(link->pool, link,
		    scsi_default_get, scsi_default_put);

		SET(link->flags, SDEV_OWN_IOPL);
	}

	/*
	 * Tell drivers that are paying attention to avoid sync/wide/tags until
	 * INQUIRY data has been processed and the quirks information is
	 * complete. Some drivers set bits in quirks before we get here, so
	 * just add NOTAGS, NOWIDE and NOSYNC.
	 */
	link->quirks |= SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;

	/*
	 * Ask the device what it is
	 */
#ifdef SCSIDEBUG
	if (((sb->sc_dev.dv_unit < 32) &&
	     ((1U << sb->sc_dev.dv_unit) & scsidebug_buses)) &&
	    ((target < 32) && ((1U << target) & scsidebug_targets)) &&
	    ((lun < 32) && ((1U << lun) & scsidebug_luns)))
		link->flags |= scsidebug_level;
#endif /* SCSIDEBUG */

	if (lun == 0) {
		/* Clear any outstanding errors. */
		scsi_test_unit_ready(link, TEST_READY_RETRIES,
		    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
	}

	/* Now go ask the device all about itself. */
	inqbuf = dma_alloc(sizeof(*inqbuf), PR_NOWAIT | PR_ZERO);
	if (inqbuf == NULL) {
		rslt = ENOMEM;
		goto bad;
	}

	rslt = scsi_inquire(link, inqbuf, scsi_autoconf | SCSI_SILENT);
	memcpy(&link->inqdata, inqbuf, sizeof(link->inqdata));
	dma_free(inqbuf, sizeof(*inqbuf));

	if (rslt != 0) {
		SC_DEBUG(link, SDEV_DB2, ("Bad LUN. rslt = %i\n", rslt));
		if (lun == 0)
			rslt = EINVAL;
		goto bad;
	}
	inqbuf = &link->inqdata;

	switch (inqbuf->device & SID_QUAL) {
	case SID_QUAL_RSVD:
	case SID_QUAL_BAD_LU:
	case SID_QUAL_LU_OFFLINE:
		SC_DEBUG(link, SDEV_DB1, ("Bad LUN. SID_QUAL = 0x%02x\n",
		    inqbuf->device & SID_QUAL));
		goto bad;

	case SID_QUAL_LU_OK:
		if ((inqbuf->device & SID_TYPE) == T_NODEVICE) {
			SC_DEBUG(link, SDEV_DB1,
			    ("Bad LUN. SID_TYPE = T_NODEVICE\n"));
			goto bad;
		}
		break;

	default:
		break;
	}

	scsi_devid(link);

	link0 = scsi_get_link(sb, target, 0);
	if (lun == 0 || link0 == NULL)
		;
	else if (link->flags & SDEV_UMASS)
		;
	else if (link->id != NULL && !DEVID_CMP(link0->id, link->id))
		;
	else if (memcmp(inqbuf, &link0->inqdata, sizeof(*inqbuf)) == 0) {
		/* The device doesn't distinguish between LUNs. */
		SC_DEBUG(link, SDEV_DB1, ("IDENTIFY not supported.\n"));
		rslt = EINVAL;
		goto free_devid;
	}

	finger = (const struct scsi_quirk_inquiry_pattern *)scsi_inqmatch(
	    inqbuf, scsi_quirk_patterns,
	    nitems(scsi_quirk_patterns),
	    sizeof(scsi_quirk_patterns[0]), &priority);

	/*
	 * Based upon the inquiry flags we got back, and if we're
	 * at SCSI-2 or better, remove some limiting quirks.
	 */
	if (SCSISPC(inqbuf->version) >= 2) {
		if ((inqbuf->flags & SID_CmdQue) != 0)
			link->quirks &= ~SDEV_NOTAGS;
		if ((inqbuf->flags & SID_Sync) != 0)
			link->quirks &= ~SDEV_NOSYNC;
		if ((inqbuf->flags & SID_WBus16) != 0)
			link->quirks &= ~SDEV_NOWIDE;
	} else
		/* Older devices do not have SYNCHRONIZE CACHE capability. */
		link->quirks |= SDEV_NOSYNCCACHE;

	/*
	 * Now apply any quirks from the table.
	 */
	if (priority != 0)
		link->quirks |= finger->quirks;

	/*
	 * If the device can't use tags, >1 opening may confuse it.
	 */
	if (ISSET(link->quirks, SDEV_NOTAGS))
		link->openings = 1;

	/*
	 * note what BASIC type of device it is
	 */
	if ((inqbuf->dev_qual2 & SID_REMOVABLE) != 0)
		link->flags |= SDEV_REMOVABLE;

	sa.sa_sc_link = link;
	sa.sa_inqbuf = &link->inqdata;

	if ((cf = config_search(scsibussubmatch, (struct device *)sb,
	    &sa)) == 0) {
		scsibusprint(&sa, sb->sc_dev.dv_xname);
		printf(" not configured\n");
		goto free_devid;
	}

	/*
	 * Braindead USB devices, especially some x-in-1 media readers, try to
	 * 'help' by pretending any LUN is actually LUN 0 until they see a
	 * different LUN used in a command. So do an INQUIRY on LUN 1 at this
	 * point to prevent such helpfulness before it causes confusion.
	 */
	if (lun == 0 && (link->flags & SDEV_UMASS) &&
	    scsi_get_link(sb, target, 1) == NULL && link->luns > 1 &&
	    (usbinqbuf = dma_alloc(sizeof(*usbinqbuf), M_NOWAIT)) != NULL) {

		link->lun = 1;
		scsi_inquire(link, usbinqbuf, scsi_autoconf | SCSI_SILENT);
		link->lun = 0;

		dma_free(usbinqbuf, sizeof(*usbinqbuf));
	}

	scsi_add_link(sb, link);

	/*
	 * Generate a TEST_UNIT_READY command. This gives drivers waiting for
	 * valid quirks data a chance to set wide/sync/tag options
	 * appropriately. It also clears any outstanding ACA conditions that
	 * INQUIRY may leave behind.
	 *
	 * Do this now so that any messages generated by config_attach() do not
	 * have negotiation messages inserted into their midst.
	 */
	scsi_test_unit_ready(link, TEST_READY_RETRIES,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
	    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);

	config_attach((struct device *)sb, cf, &sa, scsibusprint);

	return (0);

free_devid:
	if (link->id)
		devid_free(link->id);
bad:
	if (ISSET(link->flags, SDEV_OWN_IOPL))
		free(link->pool, M_DEVBUF, sizeof(*link->pool));

	if (sb->adapter_link->adapter->dev_free != NULL)
		sb->adapter_link->adapter->dev_free(link);
free:
	free(link, M_DEVBUF, sizeof(*link));
	return (rslt);
}

/*
 * Return a priority based on how much of the inquiry data matches
 * the patterns for the particular driver.
 */
const void *
scsi_inqmatch(struct scsi_inquiry_data *inqbuf, const void *_base,
    int nmatches, int matchsize, int *bestpriority)
{
	u_int8_t			type;
	int				removable;
	const void			*bestmatch;
	const unsigned char		*base = (const unsigned char *)_base;

	/* Include the qualifier to catch vendor-unique types. */
	type = inqbuf->device;
	removable = inqbuf->dev_qual2 & SID_REMOVABLE ? T_REMOV : T_FIXED;

	for (*bestpriority = 0, bestmatch = 0; nmatches--; base += matchsize) {
		struct scsi_inquiry_pattern *match = (void *)base;
		int priority, len;

		if (type != match->type)
			continue;
		if (removable != match->removable)
			continue;
		priority = 2;
		len = strlen(match->vendor);
		if (bcmp(inqbuf->vendor, match->vendor, len))
			continue;
		priority += len;
		len = strlen(match->product);
		if (bcmp(inqbuf->product, match->product, len))
			continue;
		priority += len;
		len = strlen(match->revision);
		if (bcmp(inqbuf->revision, match->revision, len))
			continue;
		priority += len;

#ifdef SCSIDEBUG
		printf("scsi_inqmatch: %d/%d/%d <%s, %s, %s>\n",
		    priority, match->type, match->removable,
		    match->vendor, match->product, match->revision);
#endif
		if (priority > *bestpriority) {
			*bestpriority = priority;
			bestmatch = base;
		}
	}

	return (bestmatch);
}

void
scsi_devid(struct scsi_link *link)
{
	struct {
		struct scsi_vpd_hdr hdr;
		u_int8_t list[32];
	} __packed *pg;
	int pg80 = 0, pg83 = 0, i;
	size_t len;

	if (link->id != NULL)
		return;

	pg = dma_alloc(sizeof(*pg), PR_WAITOK | PR_ZERO);

	if (SCSISPC(link->inqdata.version) >= 2) {
		if (scsi_inquire_vpd(link, pg, sizeof(*pg), SI_PG_SUPPORTED,
		    scsi_autoconf) != 0)
			goto wwn;

		len = MIN(sizeof(pg->list), _2btol(pg->hdr.page_length));
		for (i = 0; i < len; i++) {
			switch (pg->list[i]) {
			case SI_PG_SERIAL:
				pg80 = 1;
				break;
			case SI_PG_DEVID:
				pg83 = 1;
				break;
			}
		}

		if (pg83 && scsi_devid_pg83(link) == 0)
			goto done;
		if (pg80 && scsi_devid_pg80(link) == 0)
			goto done;
	}

wwn:
	scsi_devid_wwn(link);
done:
	dma_free(pg, sizeof(*pg));
}

int
scsi_devid_pg83(struct scsi_link *link)
{
	struct scsi_vpd_hdr *hdr = NULL;
	struct scsi_vpd_devid_hdr dhdr, chdr;
	u_int8_t *pg = NULL, *id;
	int type, idtype = 0;
	u_char idflags;
	int len, pos;
	int rv;

	hdr = dma_alloc(sizeof(*hdr), PR_WAITOK | PR_ZERO);

	rv = scsi_inquire_vpd(link, hdr, sizeof(*hdr), SI_PG_DEVID,
	    scsi_autoconf);
	if (rv != 0)
		goto done;

	len = sizeof(*hdr) + _2btol(hdr->page_length);
	pg = dma_alloc(len, PR_WAITOK | PR_ZERO);

	rv = scsi_inquire_vpd(link, pg, len, SI_PG_DEVID, scsi_autoconf);
	if (rv != 0)
		goto done;

	pos = sizeof(*hdr);

	do {
		if (len - pos < sizeof(dhdr)) {
			rv = EIO;
			goto done;
		}
		memcpy(&dhdr, &pg[pos], sizeof(dhdr));
		pos += sizeof(dhdr);
		if (len - pos < dhdr.len) {
			rv = EIO;
			goto done;
		}

		if (VPD_DEVID_ASSOC(dhdr.flags) == VPD_DEVID_ASSOC_LU) {
			type = VPD_DEVID_TYPE(dhdr.flags);
			switch (type) {
			case VPD_DEVID_TYPE_NAA:
			case VPD_DEVID_TYPE_EUI64:
			case VPD_DEVID_TYPE_T10:
				if (type >= idtype) {
					idtype = type;

					chdr = dhdr;
					id = &pg[pos];
				}
				break;

			default:
				/* skip */
				break;
			}
		}

		pos += dhdr.len;
	} while (idtype != VPD_DEVID_TYPE_NAA && len != pos);

	if (idtype > 0) {
		switch (VPD_DEVID_TYPE(chdr.flags)) {
		case VPD_DEVID_TYPE_NAA:
			idtype = DEVID_NAA;
			break;
		case VPD_DEVID_TYPE_EUI64:
			idtype = DEVID_EUI;
			break;
		case VPD_DEVID_TYPE_T10:
			idtype = DEVID_T10;
			break;
		}
		switch (VPD_DEVID_CODE(chdr.pi_code)) {
		case VPD_DEVID_CODE_ASCII:
		case VPD_DEVID_CODE_UTF8:
			idflags = DEVID_F_PRINT;
			break;
		default:
			idflags = 0;
			break;
		}
		link->id = devid_alloc(idtype, idflags, chdr.len, id);
	} else
		rv = ENODEV;

done:
	if (pg)
		dma_free(pg, len);
	if (hdr)
		dma_free(hdr, sizeof(*hdr));
	return (rv);
}

int
scsi_devid_pg80(struct scsi_link *link)
{
	struct scsi_vpd_hdr *hdr = NULL;
	u_int8_t *pg = NULL;
	char *id;
	size_t idlen;
	int pglen, len;
	int rv;

	hdr = dma_alloc(sizeof(*hdr), PR_WAITOK | PR_ZERO);

	rv = scsi_inquire_vpd(link, hdr, sizeof(*hdr), SI_PG_SERIAL,
	    scsi_autoconf);
	if (rv != 0)
		goto freehdr;

	len = _2btol(hdr->page_length);
	if (len == 0) {
		rv = EINVAL;
		goto freehdr;
	}

	pglen = sizeof(*hdr) + len;
	pg = dma_alloc(pglen, PR_WAITOK | PR_ZERO);

	rv = scsi_inquire_vpd(link, pg, pglen, SI_PG_SERIAL, scsi_autoconf);
	if (rv != 0)
		goto free;

	idlen = sizeof(link->inqdata.vendor) +
	    sizeof(link->inqdata.product) + len;
	id = malloc(idlen, M_TEMP, M_WAITOK);
	memcpy(id, link->inqdata.vendor, sizeof(link->inqdata.vendor));
	memcpy(id + sizeof(link->inqdata.vendor), link->inqdata.product,
	    sizeof(link->inqdata.product));
	memcpy(id + sizeof(link->inqdata.vendor) +
	    sizeof(link->inqdata.product), pg + sizeof(*hdr), len);

	link->id = devid_alloc(DEVID_SERIAL, DEVID_F_PRINT,
	    sizeof(link->inqdata.vendor) + sizeof(link->inqdata.product) + len,
	    id);

	free(id, M_TEMP, idlen);

free:
	dma_free(pg, pglen);
freehdr:
	dma_free(hdr, sizeof(*hdr));
	return (rv);
}

int
scsi_devid_wwn(struct scsi_link *link)
{
	u_int64_t wwnn;

	if (link->lun != 0 || link->node_wwn == 0)
		return (EOPNOTSUPP);

	wwnn = htobe64(link->node_wwn);
	link->id = devid_alloc(DEVID_WWN, 0, sizeof(wwnn), (u_int8_t *)&wwnn);

	return (0);
}

/*
 * scsi_minphys member of struct scsi_adapter for drivers which don't
 * need any specific routine.
 */
void
scsi_minphys(struct buf *bp, struct scsi_link *sl)
{
	minphys(bp);
}

struct devid *
devid_alloc(u_int8_t type, u_int8_t flags, u_int8_t len, u_int8_t *id)
{
	struct devid *d;

	d = malloc(sizeof(*d) + len, M_DEVBUF, M_WAITOK|M_CANFAIL);
	if (d == NULL)
		return (NULL);

	d->d_type = type;
	d->d_flags = flags;
	d->d_len = len;
	d->d_refcount = 1;
	memcpy(d + 1, id, len);

	return (d);
}

struct devid *
devid_copy(struct devid *d)
{
	d->d_refcount++;
	return (d);
}

void
devid_free(struct devid *d)
{
	if (--d->d_refcount == 0)
		free(d, M_DEVBUF, sizeof(*d) + d->d_len);
}
@


1.194
log
@Enforce some naming sanity. Stop using 'sc_link' to mean two different
things by renaming the field 'SLIST_HEAD(, scsi_link) sc_link' to
'sc_link_list' in struct scsibus_softc.  Use 'sb' as the short name
for scsibus_softc variables.

Impetus from & ok bluhm@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.193 2015/08/23 01:55:39 tedu Exp $	*/
d287 1
a287 1
	struct scsi_link		*sc_link = sa->sa_sc_link;
d289 1
a289 1
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != sc_link->target)
d291 1
a291 1
	if (cf->cf_loc[1] != -1 && cf->cf_loc[1] != sc_link->lun)
d854 1
a854 1
	struct scsi_link *sc_link, *link0;
d862 2
a863 2
	sc_link = malloc(sizeof(*sc_link), M_DEVBUF, M_NOWAIT);
	if (sc_link == NULL)
d866 6
a871 6
	*sc_link = *sb->adapter_link;
	sc_link->target = target;
	sc_link->lun = lun;
	sc_link->interpret_sense = scsi_interpret_sense;
	sc_link->node_wwn = sc_link->port_wwn = 0;
	TAILQ_INIT(&sc_link->queue);
d873 1
a873 1
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_link created.\n"));
d877 1
a877 1
	    sb->adapter_link->adapter->dev_probe(sc_link) != 0) {
d885 1
a885 1
	 * using sc_link->openings.
d887 2
a888 2
	if (sc_link->pool == NULL) {
		sc_link->pool = malloc(sizeof(*sc_link->pool),
d890 1
a890 1
		if (sc_link->pool == NULL) {
d894 1
a894 1
		scsi_iopool_init(sc_link->pool, sc_link,
d897 1
a897 1
		SET(sc_link->flags, SDEV_OWN_IOPL);
d906 1
a906 1
	sc_link->quirks |= SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;
d916 1
a916 1
		sc_link->flags |= scsidebug_level;
d921 1
a921 1
		scsi_test_unit_ready(sc_link, TEST_READY_RETRIES,
d933 2
a934 2
	rslt = scsi_inquire(sc_link, inqbuf, scsi_autoconf | SCSI_SILENT);
	memcpy(&sc_link->inqdata, inqbuf, sizeof(sc_link->inqdata));
d938 1
a938 1
		SC_DEBUG(sc_link, SDEV_DB2, ("Bad LUN. rslt = %i\n", rslt));
d943 1
a943 1
	inqbuf = &sc_link->inqdata;
d949 1
a949 1
		SC_DEBUG(sc_link, SDEV_DB1, ("Bad LUN. SID_QUAL = 0x%02x\n",
d955 1
a955 1
			SC_DEBUG(sc_link, SDEV_DB1,
d965 1
a965 1
	scsi_devid(sc_link);
d970 1
a970 1
	else if (sc_link->flags & SDEV_UMASS)
d972 1
a972 1
	else if (sc_link->id != NULL && !DEVID_CMP(link0->id, sc_link->id))
d976 1
a976 1
		SC_DEBUG(sc_link, SDEV_DB1, ("IDENTIFY not supported.\n"));
d992 1
a992 1
			sc_link->quirks &= ~SDEV_NOTAGS;
d994 1
a994 1
			sc_link->quirks &= ~SDEV_NOSYNC;
d996 1
a996 1
			sc_link->quirks &= ~SDEV_NOWIDE;
d999 1
a999 1
		sc_link->quirks |= SDEV_NOSYNCCACHE;
d1005 1
a1005 1
		sc_link->quirks |= finger->quirks;
d1010 2
a1011 2
	if (ISSET(sc_link->quirks, SDEV_NOTAGS))
		sc_link->openings = 1;
d1017 1
a1017 1
		sc_link->flags |= SDEV_REMOVABLE;
d1019 2
a1020 2
	sa.sa_sc_link = sc_link;
	sa.sa_inqbuf = &sc_link->inqdata;
d1035 2
a1036 2
	if (lun == 0 && (sc_link->flags & SDEV_UMASS) &&
	    scsi_get_link(sb, target, 1) == NULL && sc_link->luns > 1 &&
d1039 3
a1041 3
		sc_link->lun = 1;
		scsi_inquire(sc_link, usbinqbuf, scsi_autoconf | SCSI_SILENT);
		sc_link->lun = 0;
d1046 1
a1046 1
	scsi_add_link(sb, sc_link);
d1057 1
a1057 1
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES,
d1066 2
a1067 2
	if (sc_link->id)
		devid_free(sc_link->id);
d1069 2
a1070 2
	if (ISSET(sc_link->flags, SDEV_OWN_IOPL))
		free(sc_link->pool, M_DEVBUF, sizeof(*sc_link->pool));
d1073 1
a1073 1
		sb->adapter_link->adapter->dev_free(sc_link);
d1075 1
a1075 1
	free(sc_link, M_DEVBUF, sizeof(*sc_link));
@


1.193
log
@add some sizes to free. looked over by deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.192 2015/06/07 19:13:27 krw Exp $	*/
d180 1
a180 1
	SLIST_INIT(&sb->sc_link);
d193 1
a193 1
	struct scsibus_softc *sc = (struct scsibus_softc *)dev;
d195 1
a195 1
	return scsi_activate(sc, -1, -1, act);
d199 1
a199 1
scsi_activate(struct scsibus_softc *sc, int target, int lun, int act)
d202 1
a202 1
		return scsi_activate_bus(sc, act);
d208 1
a208 1
		return scsi_activate_target(sc, target, act);
d210 1
a210 1
	return scsi_activate_lun(sc, target, lun, act);
d214 1
a214 1
scsi_activate_bus(struct scsibus_softc *sc, int act)
d218 2
a219 2
	for (target = 0; target < sc->sc_buswidth; target++) {
		r = scsi_activate_target(sc, target, act);
d227 1
a227 1
scsi_activate_target(struct scsibus_softc *sc, int target, int act)
d231 2
a232 2
	for (lun = 0; lun < sc->adapter_link->luns; lun++) {
		r = scsi_activate_lun(sc, target, lun, act);
d240 1
a240 1
scsi_activate_lun(struct scsibus_softc *sc, int target, int lun, int act)
d246 1
a246 1
	link = scsi_get_link(sc, target, lun);
d277 1
a277 1
	KASSERT(SLIST_EMPTY(&sb->sc_link));
d301 1
a301 1
	struct scsibus_softc		*sc = (struct scsibus_softc *)dev;
d307 1
a307 1
		return (scsi_probe(sc, sdev->sd_target, sdev->sd_lun));
d311 1
a311 1
		return (scsi_detach(sc, sdev->sd_target, sdev->sd_lun, 0));
d320 1
a320 1
scsi_probe_bus(struct scsibus_softc *sc)
d322 1
a322 1
	struct scsi_link *alink = sc->adapter_link;
d326 1
a326 1
		scsi_probe_target(sc, i);
d332 1
a332 1
scsi_probe_target(struct scsibus_softc *sc, int target)
d334 1
a334 1
	struct scsi_link *alink = sc->adapter_link;
d339 1
a339 1
	if (scsi_probe_lun(sc, target, 0) == EINVAL)
d342 1
a342 1
	link = scsi_get_link(sc, target, 0);
d375 3
a377 3
			scsi_remove_link(sc, link);
			scsi_probe_lun(sc, target, lun);
			scsi_add_link(sc, link);
d386 1
a386 1
		if (scsi_probe_lun(sc, target, i) == EINVAL)
d394 1
a394 1
scsi_probe(struct scsibus_softc *sc, int target, int lun)
d397 1
a397 1
		return (scsi_probe_bus(sc));
d404 1
a404 1
		return (scsi_probe_target(sc, target));
d406 1
a406 1
	return (scsi_probe_lun(sc, target, lun));
d410 1
a410 1
scsi_probe_lun(struct scsibus_softc *sc, int target, int lun)
d412 1
a412 1
	struct scsi_link *alink = sc->adapter_link;
d419 1
a419 1
	return (scsi_probedev(sc, target, lun));
d423 1
a423 1
scsi_detach_bus(struct scsibus_softc *sc, int flags)
d425 1
a425 1
	struct scsi_link *alink = sc->adapter_link;
d429 1
a429 1
		err = scsi_detach_target(sc, i, flags);
d438 1
a438 1
scsi_detach(struct scsibus_softc *sc, int target, int lun, int flags)
d441 1
a441 1
		return (scsi_detach_bus(sc, flags));
d448 1
a448 1
		return (scsi_detach_target(sc, target, flags));
d450 1
a450 1
	return (scsi_detach_lun(sc, target, lun, flags));
d454 1
a454 1
scsi_detach_target(struct scsibus_softc *sc, int target, int flags)
d456 1
a456 1
	struct scsi_link *alink = sc->adapter_link;
d464 1
a464 1
		if (scsi_get_link(sc, target, i) == NULL)
d467 1
a467 1
		err = scsi_detach_lun(sc, target, i, flags);
d476 1
a476 1
scsi_detach_lun(struct scsibus_softc *sc, int target, int lun, int flags)
d478 1
a478 1
	struct scsi_link *alink = sc->adapter_link;
d487 1
a487 1
	link = scsi_get_link(sc, target, lun);
d518 1
a518 1
	scsi_remove_link(sc, link);
d525 1
a525 1
scsi_get_link(struct scsibus_softc *sc, int target, int lun)
d529 1
a529 1
	SLIST_FOREACH(link, &sc->sc_link, bus_list)
d537 1
a537 1
scsi_add_link(struct scsibus_softc *sc, struct scsi_link *link)
d539 1
a539 1
	SLIST_INSERT_HEAD(&sc->sc_link, link, bus_list);
d543 1
a543 1
scsi_remove_link(struct scsibus_softc *sc, struct scsi_link *link)
d545 1
a545 1
	SLIST_REMOVE(&sc->sc_link, link, scsi_link, bus_list);
d849 1
a849 1
scsi_probedev(struct scsibus_softc *scsi, int target, int lun)
d859 1
a859 1
	if (scsi_get_link(scsi, target, lun) != NULL)
d866 1
a866 1
	*sc_link = *scsi->adapter_link;
d876 2
a877 2
	if (scsi->adapter_link->adapter->dev_probe != NULL &&
	    scsi->adapter_link->adapter->dev_probe(sc_link) != 0) {
d912 2
a913 2
	if (((scsi->sc_dev.dv_unit < 32) &&
	     ((1U << scsi->sc_dev.dv_unit) & scsidebug_buses)) &&
d967 1
a967 1
	link0 = scsi_get_link(scsi, target, 0);
d1022 1
a1022 1
	if ((cf = config_search(scsibussubmatch, (struct device *)scsi,
d1024 1
a1024 1
		scsibusprint(&sa, scsi->sc_dev.dv_xname);
d1036 1
a1036 1
	    scsi_get_link(scsi, target, 1) == NULL && sc_link->luns > 1 &&
d1046 1
a1046 1
	scsi_add_link(scsi, sc_link);
d1061 1
a1061 1
	config_attach((struct device *)scsi, cf, &sa, scsibusprint);
d1072 2
a1073 2
	if (scsi->adapter_link->adapter->dev_free != NULL)
		scsi->adapter_link->adapter->dev_free(sc_link);
@


1.192
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.191 2015/03/14 03:38:52 jsg Exp $	*/
d508 1
a508 1
		free(link->pool, M_DEVBUF, 0);
d519 1
a519 1
	free(link, M_DEVBUF, 0);
d1070 1
a1070 1
		free(sc_link->pool, M_DEVBUF, 0);
d1075 1
a1075 1
	free(sc_link, M_DEVBUF, 0);
d1277 1
d1301 3
a1303 2
	id = malloc(sizeof(link->inqdata.vendor) +
	    sizeof(link->inqdata.product) + len, M_TEMP, M_WAITOK);
d1314 1
a1314 1
	free(id, M_TEMP, 0);
d1376 1
a1376 1
		free(d, M_DEVBUF, 0);
@


1.191
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.190 2015/02/11 00:50:03 dlg Exp $	*/
d780 1
a780 1
		case DEVID_NAA:   
d956 1
a956 1
		    	    ("Bad LUN. SID_TYPE = T_NODEVICE\n"));
d1041 1
a1041 1
	    	sc_link->lun = 0;
@


1.190
log
@we dont need sys/lock.h because we dont use lockmgr, but we do need
sys/atomic.h for atomic_setbits_int.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.189 2014/12/15 02:11:57 tedu Exp $	*/
a63 1
#include <scsi/mpathvar.h>
@


1.189
log
@convert bcopy to memcpy. ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.188 2014/07/12 18:50:25 tedu Exp $	*/
d60 1
a60 1
#include <sys/lock.h>
@


1.188
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.187 2014/04/22 07:29:11 dlg Exp $	*/
d935 1
a935 1
	bcopy(inqbuf, &sc_link->inqdata, sizeof(sc_link->inqdata));
@


1.187
log
@factor out the code that figures out whether you're probing or detaching
a whole bus, a target, or a specific lun on a target from the bioctl
and scsi_req paths.

i want to reuse this factored code for something claudio wants.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.186 2014/01/31 02:53:41 dlg Exp $	*/
d509 1
a509 1
		free(link->pool, M_DEVBUF);
d520 1
a520 1
	free(link, M_DEVBUF);
d1071 1
a1071 1
		free(sc_link->pool, M_DEVBUF);
d1076 1
a1076 1
	free(sc_link, M_DEVBUF);
d1313 1
a1313 1
	free(id, M_TEMP);
d1375 1
a1375 1
		free(d, M_DEVBUF);
@


1.186
log
@if a device doesnt have device ids or serial numbers, try using node_wwn to
generate a devid. if its an fc device this is good enough.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.185 2013/12/06 21:03:02 deraadt Exp $	*/
d308 1
a308 12

		if (sdev->sd_target == -1 && sdev->sd_lun == -1)
			return (scsi_probe_bus(sc));

		/* specific lun and wildcard target is bad */
		if (sdev->sd_target == -1)
			return (EINVAL);

		if (sdev->sd_lun == -1)
			return (scsi_probe_target(sc, sdev->sd_target));

		return (scsi_probe_lun(sc, sdev->sd_target, sdev->sd_lun));
d312 1
a312 11

		if (sdev->sd_target == -1 && sdev->sd_lun == -1)
			return (scsi_detach_bus(sc, 0));

		if (sdev->sd_target == -1)
			return (EINVAL);

		if (sdev->sd_lun == -1)
			return (scsi_detach_target(sc, sdev->sd_target, 0));

		return (scsi_detach_lun(sc, sdev->sd_target, sdev->sd_lun, 0));
d395 16
d436 16
@


1.185
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.184 2012/10/16 10:30:52 jsg Exp $	*/
d80 1
d782 3
d1140 1
a1140 1
			goto done;
d1159 3
d1309 14
@


1.184
log
@#if SCSIDEBUG -> #ifdef SCSIDEBUG
matches the rest of the scsi code.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.183 2012/10/08 21:47:51 deraadt Exp $	*/
d244 1
a251 6
	case DVACT_QUIESCE:
	case DVACT_SUSPEND:
	case DVACT_RESUME:
	case DVACT_POWERDOWN:
		config_suspend(dev, act);
		break;
d257 1
d260 1
a260 2

	return (0);
@


1.183
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.182 2011/09/22 21:36:00 jsing Exp $	*/
d1109 1
a1109 1
#if SCSIDEBUG
@


1.182
log
@Fix order of arguments passed to malloc(9) - type first then flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.180 2011/07/17 22:46:48 matthew Exp $	*/
d254 1
@


1.181
log
@generate a devid from vpd page 80 if vpd page 83 doesnt exist or work.

ok krw@@
@
text
@d1288 1
a1288 1
	    sizeof(link->inqdata.product) + len, M_WAITOK, M_TEMP);
@


1.180
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.179 2011/07/06 00:45:52 matthew Exp $	*/
d78 1
a1155 1
#ifdef notyet
a1157 1
#endif
d1255 50
@


1.179
log
@Add {sc,saa}_{targets,luns} to scsibus_softc and scsibus_attach_args.
These will be used to replace scsi_link's adapter_buswidth and luns
fields, but for now we stay compatible with existing SCSI adapter
driver conventions while I update them to set the scsibus_attach_args
fields directly.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.178 2011/07/05 21:39:56 matthew Exp $	*/
d158 1
d162 1
a162 3
	if (saa->saa_targets == 0)
		saa->saa_targets = sb->adapter_link->adapter_buswidth;
	sb->sc_targets = saa->saa_targets;
a164 3
	if (saa->saa_luns == 0)
		saa->saa_luns = sb->adapter_link->luns;
	sb->sc_luns = saa->saa_luns;
d166 2
a167 2
	printf(": %d targets", sb->sc_targets);
	if (sb->adapter_link->adapter_target < sb->sc_targets)
d217 1
a217 1
	for (target = 0; target < sc->sc_targets; target++) {
d230 1
a230 1
	for (lun = 0; lun < sc->sc_luns; lun++) {
d346 1
d349 1
a349 1
	for (i = 0; i < sc->sc_targets; i++)
d358 1
d409 1
a409 1
	for (i = 1; i < sc->sc_luns; i++) {
d422 1
a422 1
	if (target < 0 || target >= sc->sc_targets ||
d424 1
a424 1
	    lun < 0 || lun >= sc->sc_luns)
d433 1
d436 1
a436 1
	for (i = 0; i < sc->sc_targets; i++) {
d451 1
a451 1
	if (target < 0 || target >= sc->sc_targets ||
d455 1
a455 1
	for (i = 0; i < sc->sc_luns; i++) { /* nicer backwards? */
d474 1
a474 1
	if (target < 0 || target >= sc->sc_targets ||
d476 1
a476 1
	    lun < 0 || lun >= sc->sc_luns)
d1025 1
a1025 1
	    scsi_get_link(scsi, target, 1) == NULL && scsi->sc_luns > 1 &&
@


1.178
log
@Garbage collect SDEV_S_WAITING and scsi_link->scsibus now that nothing
needs either of them.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.177 2011/07/03 15:47:18 matthew Exp $	*/
d161 3
a163 1
	sb->sc_buswidth = sb->adapter_link->adapter_buswidth;
d166 3
d170 2
a171 2
	printf(": %d targets", sb->sc_buswidth);
	if (sb->adapter_link->adapter_target < sb->sc_buswidth)
d221 1
a221 1
	for (target = 0; target < sc->sc_buswidth; target++) {
d234 1
a234 1
	for (lun = 0; lun < sc->adapter_link->luns; lun++) {
a349 1
	struct scsi_link *alink = sc->adapter_link;
d352 1
a352 1
	for (i = 0; i < alink->adapter_buswidth; i++)
a360 1
	struct scsi_link *alink = sc->adapter_link;
d411 1
a411 1
	for (i = 1; i < alink->luns; i++) {
d424 1
a424 1
	if (target < 0 || target >= alink->adapter_buswidth ||
d426 1
a426 1
	    lun < 0 || lun >= alink->luns)
a434 1
	struct scsi_link *alink = sc->adapter_link;
d437 1
a437 1
	for (i = 0; i < alink->adapter_buswidth; i++) {
d452 1
a452 1
	if (target < 0 || target >= alink->adapter_buswidth ||
d456 1
a456 1
	for (i = 0; i < alink->luns; i++) { /* nicer backwards? */
d475 1
a475 1
	if (target < 0 || target >= alink->adapter_buswidth ||
d477 1
a477 1
	    lun < 0 || lun >= alink->luns)
d1026 1
a1026 1
	    scsi_get_link(scsi, target, 1) == NULL && sc_link->luns > 1 &&
@


1.177
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.176 2011/06/21 22:36:42 matthew Exp $	*/
a157 1
	sc_link_proto->scsibus = sb->sc_dev.dv_unit;
@


1.176
log
@scsi_link's scsibus field is redundant with bus->sc_dev.dv_unit, so
remove two of the remaining three uses of it.  (softraid(4) still uses
it at the moment, so the field and its assignment in scsibusattach()
stay for now...)

ok krw@@; feedback and "tenteiramen rejid"(!?) miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.175 2011/05/04 20:49:41 sthen Exp $	*/
a249 4
	case DVACT_ACTIVATE:
		atomic_clearbits_int(&link->state, SDEV_S_DYING);
		config_activate(dev);
		break;
@


1.175
log
@When printing scsi device ids, skip leading blanks and collapse multiple
whitespace into one. Written after Mitja showed a particularly unwieldy
attach line:

sd0 at scsibus0 targ 2 lun 0: <ATA, HTS721010G9SA00, MCZI> SCSI3 0/direct fixed t10.ATA_____HTS721010G9SA00_______________________________blahblahblah

ok/incorporating a suggestion from matthew@@, krw@@ likes it, dlg@@ doesn't
feel strongly either way.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.174 2011/04/29 02:10:05 dlg Exp $	*/
d101 3
a103 3
int scsidebug_buses = SCSIDEBUG_BUSES;
int scsidebug_targets = SCSIDEBUG_TARGETS;
int scsidebug_luns = SCSIDEBUG_LUNS;
d905 4
a908 3
	if (((1 << sc_link->scsibus) & scsidebug_buses) &&
	    ((target < 32) && ((1 << target) & scsidebug_targets)) &&
	    ((lun < 32) && ((1 << lun) & scsidebug_luns)))
@


1.174
log
@zero out a scsi_links node_wwn and port_wwn fields after initialising it
by copying the adapters scsi_link. this way devices wont inherit the
adapters addresses on fc fabrics.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.173 2011/04/06 15:16:54 dlg Exp $	*/
d792 6
a797 3
				if (id[i] == '\0' || id[i] == ' ')
					printf("_");
				else if (id[i] < 0x20 || id[i] >= 0x80) {
@


1.173
log
@add a new "serial" devid type for scsi devices. add code to usb that fakes
it up by using the usb devices iSerial thing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.172 2011/04/06 13:33:46 dlg Exp $	*/
d860 1
@


1.172
log
@unconditionally print scsi device ids instead of just when mpath is
enabled so people can get used to it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.171 2011/04/05 22:39:19 dlg Exp $	*/
d784 3
@


1.171
log
@do inquiries against dmaable memory while probing devices.

found by marco@@
ok and tweaks deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.170 2011/04/05 14:25:42 dlg Exp $	*/
a770 1
#if NMPATH > 0
a803 1
#endif /* NMPATH > 0 */
@


1.170
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.169 2011/03/31 18:42:48 jasper Exp $	*/
d841 1
a841 1
	struct scsi_inquiry_data *inqbuf;
a859 1
	inqbuf = &sc_link->inqdata;
d914 6
d921 3
d930 1
d1023 2
a1024 2
	    scsi_get_link(scsi, target, 1) == NULL && sc_link->luns > 1) {
		struct scsi_inquiry_data tmpinq;
d1027 1
a1027 1
		scsi_inquire(sc_link, &tmpinq, scsi_autoconf | SCSI_SILENT);
d1029 2
@


1.169
log
@- use nitems(); no binary change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.168 2011/03/17 21:30:24 deraadt Exp $	*/
d64 1
d252 1
a252 6
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_activate(link);
		else
#endif /* NMPATH */
			config_activate(dev);
d261 1
a261 6
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_deactivate(link);
		else
#endif /* NMPATH */
			config_deactivate(dev);
d496 1
a496 6
#if NMPATH > 0
	if (link->device_softc == NULL)
		rv = mpath_path_detach(link, flags);
	else
#endif /* NMPATH */
		rv = config_detach(link->device_softc, flags);
a957 12

#if NMPATH > 0
	/* should multipathing steal the link? */
	if (mpath_path_attach(sc_link) == 0) {
		printf("%s: path to", scsi->sc_dev.dv_xname);
		scsibus_printlink(sc_link);
		printf("\n");

		scsi_add_link(scsi, sc_link);
		return (0);
	}
#endif /* NMPATH */
@


1.168
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.167 2010/10/12 00:53:32 krw Exp $	*/
d987 1
a987 1
	    sizeof(scsi_quirk_patterns)/sizeof(scsi_quirk_patterns[0]),
@


1.167
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.166 2010/09/08 00:58:05 dlg Exp $	*/
d57 1
d385 1
a385 1
		report = malloc(sizeof(*report), M_TEMP, M_WAITOK);
d393 1
a393 1
			free(report, M_TEMP);
d417 1
a417 1
		free(report, M_TEMP);
d1140 1
a1140 1
	} __packed pg;
d1147 2
d1150 1
a1150 1
		if (scsi_inquire_vpd(link, &pg, sizeof(pg), SI_PG_SUPPORTED,
d1152 1
a1152 1
			return;
d1154 1
a1154 1
		len = MIN(sizeof(pg.list), _2btol(pg.hdr.page_length));
d1156 1
a1156 1
			switch (pg.list[i]) {
d1167 1
a1167 1
			return;
d1170 1
a1170 1
			return;
d1173 2
d1180 1
a1180 1
	struct scsi_vpd_hdr hdr;
d1182 1
a1182 1
	u_int8_t *pg, *id;
d1188 3
a1190 1
	rv = scsi_inquire_vpd(link, &hdr, sizeof(hdr), SI_PG_DEVID,
d1193 1
a1193 1
		return (rv);
d1195 2
a1196 2
	len = sizeof(hdr) + _2btol(hdr.page_length);
	pg = malloc(len, M_TEMP, M_WAITOK);
d1200 1
a1200 1
		goto err;
d1202 1
a1202 1
	pos = sizeof(hdr);
d1207 1
a1207 1
			goto err;
d1213 1
a1213 1
			goto err;
d1264 5
a1268 2
err:
	free(pg, M_TEMP);
@


1.166
log
@activate hooks should return a value.

all from deraadt@@
tested by me with hotplugged disks on mpi(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.165 2010/09/02 11:54:44 dlg Exp $	*/
d1009 6
@


1.165
log
@the page_length field in the vpd page header is 2 bytes, not 1.

ok krw@@ marco@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.164 2010/08/31 17:13:48 deraadt Exp $	*/
d110 3
a112 3
void scsi_activate_bus(struct scsibus_softc *, int);
void scsi_activate_target(struct scsibus_softc *, int, int);
void scsi_activate_lun(struct scsibus_softc *, int, int, int);
d192 1
a192 3
	scsi_activate(sc, -1, -1, act);

	return (0);
d195 1
a195 1
void
d199 1
a199 1
		scsi_activate_bus(sc, act);
d202 1
a202 1
		return;
d205 1
a205 1
		scsi_activate_target(sc, target, act);
d207 1
a207 1
	scsi_activate_lun(sc, target, lun, act);
d210 1
a210 1
void
d213 1
a213 1
	int target;
d215 6
a220 2
	for (target = 0; target < sc->sc_buswidth; target++)
		scsi_activate_target(sc, target, act);
d223 1
a223 1
void
d226 1
a226 1
	int lun;
d228 6
a233 2
	for (lun = 0; lun < sc->adapter_link->luns; lun++)
		scsi_activate_lun(sc, target, lun, act);
d236 1
a236 1
void
d244 1
a244 1
		return;
d274 2
@


1.164
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.163 2010/08/25 00:31:35 dlg Exp $	*/
d1127 1
d1137 2
a1138 1
		for (i = 0; i < MIN(sizeof(pg.list), pg.hdr.page_length); i++) {
d1174 1
a1174 1
	len = sizeof(hdr) + hdr.page_length;
@


1.163
log
@add scsi_iopool_destroy and scsi_link_shutdown. when a link or
device are going away, this will walk the pool and link queues and
wake up processes that are sleeping while waiting for an io or xs.
they will return NULL to the scsi_{xs,io}_get callers, which should
then check if they device is still alive. all other handlers that
are registered on the queues should be removed by their owners
before the destroy/shutdown funcs are called.

lots of help and discussion with matthew@@
ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.162 2010/07/24 04:01:52 matthew Exp $	*/
d251 5
a255 1

a263 4
		break;
	case DVACT_SUSPEND:
	case DVACT_RESUME:
		config_suspend(dev, act);
@


1.162
log
@Get rid of scsi_deinit(), and change scsi_init() back to a one-time
initialization strategy, rather than pretending to do user reference
counting.  Previously, we would re-initialize the SCSI pool(9)s, which
had the fun consequence of causing sysctl(kern.pool.npools) to
infinite loop at IPL_VM.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.161 2010/07/01 05:11:18 krw Exp $	*/
d490 1
a490 1
	/* detaching a device from scsibus is a four step process... */
d492 4
a495 1
	/* 1. detach the device */
d506 3
a508 2
	/* 2. if its using the openings io allocator, clean it up */
	if (ISSET(link->flags, SDEV_OWN_IOPL))
d510 1
d512 1
a512 1
	/* 3. free up its state in the adapter */
d516 1
a516 1
	/* 4. free up its state in the midlayer */
@


1.161
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.160 2010/07/01 03:20:39 matthew Exp $	*/
a284 3

	/* Free shared data. */
	scsi_deinit();
@


1.160
log
@Change scsibus(4)'s scsi_link array to an SLIST to save memory on
sparsely populated buses.

ok dlg@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.159 2010/06/30 19:23:59 deraadt Exp $	*/
a77 7
struct scsi_device probe_switch = {
	NULL,
	NULL,
	NULL,
	NULL,
};

d861 1
a861 1
	sc_link->device = &probe_switch;
@


1.159
log
@for scsibus, silence the activate function when unknown events are given.
they are supposed to do, or be silent.
ok mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.158 2010/06/30 19:06:29 kettenis Exp $	*/
a157 1
	int				nbytes, i;
d184 1
a184 10
	nbytes = sb->sc_buswidth * sizeof(struct scsi_link **);
	sb->sc_link = malloc(nbytes, M_DEVBUF, M_NOWAIT);
	if (sb->sc_link == NULL)
		panic("scsibusattach: can't allocate target links");
	nbytes = sb->adapter_link->luns * sizeof(struct scsi_link *);
	for (i = 0; i < sb->sc_buswidth; i++) {
		sb->sc_link[i] = malloc(nbytes, M_DEVBUF, M_NOWAIT | M_ZERO);
		if (sb->sc_link[i] == NULL)
			panic("scsibusattach: can't allocate lun links");
	}
d240 1
a240 1
	struct scsi_link *link = sc->sc_link[target][lun];
d243 1
d281 1
a281 1
	int				i, error;
d291 1
a291 6
	for (i = 0; i < sb->sc_buswidth; i++) {
		if (sb->sc_link[i] != NULL)
			free(sb->sc_link[i], M_DEVBUF);
	}

	free(sb->sc_link, M_DEVBUF);
d380 1
a380 1
	link = sc->sc_link[target][0];
d413 1
a413 1
			sc->sc_link[target][0] = NULL;
d415 1
a415 1
			sc->sc_link[target][0] = link;
a468 3
	if (sc->sc_link[target] == NULL)
		return (ENXIO);

d470 1
a470 1
		if (sc->sc_link[target][i] == NULL)
d493 1
a493 4
	if (sc->sc_link[target] == NULL)
		return (ENXIO);

	link = sc->sc_link[target][lun];
d524 1
a525 1
	sc->sc_link[target][lun] = NULL;
d530 24
d853 1
a853 1
	struct scsi_link *sc_link;
d858 1
a858 1
	if (scsi->sc_link[target][lun] != NULL)
d955 2
a956 1
	if (lun == 0 || scsi->sc_link[target][0] == NULL)
d960 1
a960 2
	else if (sc_link->id != NULL &&
	    !DEVID_CMP(scsi->sc_link[target][0]->id, sc_link->id))
d962 1
a962 2
	else if (memcmp(inqbuf, &scsi->sc_link[target][0]->inqdata,
	    sizeof(*inqbuf)) == 0) {
d976 1
a976 1
		scsi->sc_link[target][lun] = sc_link;
d1030 1
a1030 1
	    scsi->sc_link[target][1] == NULL && sc_link->luns > 1) {
d1038 1
a1038 1
	scsi->sc_link[target][lun] = sc_link;
@


1.158
log
@Flush cache before suspend.

ok krw@@, marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.157 2010/04/23 21:34:40 deraadt Exp $	*/
a281 3
#ifdef DIAGNOSTIC
		printf("%s: unsupported act %d\n", sc->sc_dev.dv_xname, act);
#endif
@


1.157
log
@Merge the only relevant (for now) parts of simplelock.h into lock.h
since it is time to start transitioning away from the no-op behaviour.
ok oga kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.156 2010/04/17 00:51:13 dlg Exp $	*/
d276 4
@


1.156
log
@use the iopools mutex to protect the semaphore wrapping the openings
runqueue. less is more sometimes.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.155 2010/04/06 00:58:00 dlg Exp $	*/
d59 1
a62 2

#include <machine/atomic.h>
@


1.155
log
@implement a new mechanism for allocating resources on the bus.

instead of optimistically trying to use a resource by executing an
xs and then failing when there's no room for it, this puts things
that want to use the hardware on a runqueue. as resources become
available on the bus then consumers on the runqueue are popped off
and guaranteed access to the resource.

the resources are generally "ccbs" in adapter drivers, so this
abstracts a way for the midlayer to get access to them into something
called iopools.

it also provides a callback api for consumers of resources to use:
the scsi_ioh api for things that want direct access to the ccbs,
and the scsi_xsh api for things that want to issue a scsi_xfer on
the bus. these apis have been modelled on the timeout api.

scsi_xs_get and therefore scsi_scs_cmd have been cut over to using these
apis internally, so if they are allowed to sleep then can wait on the
runqueue for a resource to become available and therefore guarantee that
when executed on an adapter providing an iopool that they will succeed.

ok krw@@ beck@@ marco@@
tested by many including krw@@ beck@@ mk@@ okan@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.154 2010/01/01 14:28:59 miod Exp $	*/
a864 1
	mtx_init(&sc_link->mtx, IPL_BIO);
@


1.154
log
@If you want to use atomic ops, you need to #include the proper files instead
of relying upon other headers bringing it in for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.153 2010/01/01 06:30:27 dlg Exp $	*/
d520 1
a520 1
	/* detaching a device from scsibus is a three step process... */
d533 5
a537 1
	/* 2. free up its state in the adapter */
d541 1
a541 1
	/* 3. free up its state in the midlayer */
d866 1
d880 17
d1059 3
@


1.153
log
@split the flags used in a scsi_link structure to represent its state at
runtime out into a separate state variable. only operate on the state bits
with atomic ops. introduce the DYING state so things that sleep can figure
out if they should keep going or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.151 2009/11/12 06:20:27 dlg Exp $	*/
d62 2
@


1.152
log
@put the midlayer changes back in.

the two issues affecting it last time are gone. the first, mishandling of
TRY_AGAIN_LATER is not relevant now that krw got rid of TRY_AGAIN_LATER.
the second, the misbehaving IBM disk was found to be a problem with siop
using ordered tags on most ops combined with the speed of the new code.

putting this in so we can move forward.

ok krw@@ "commit please" marco@@
@
text
@d258 1
d268 1
@


1.151
log
@revert midlayer back to it was before i put my big rewrite in. this is
causing a weird problems on an alpha and also appears responsible for
isp(4) weirdness i havent had a chance to examine yet.

sigh, this makes me sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.148 2009/11/05 03:33:52 marco Exp $	*/
d116 4
d206 74
a279 1
	return (config_activate_children(dev, act));
d286 1
a286 1
	int				i, j, error;
d292 2
a293 1
	if ((error = config_detach_children(dev, type)) != 0)
d297 1
a297 5
		if (sb->sc_link[i] != NULL) {
			for (j = 0; j < sb->adapter_link->luns; j++) {
				if (sb->sc_link[i][j] != NULL)
					free(sb->sc_link[i][j], M_DEVBUF);
			}
a298 1
		}
d350 3
d458 1
a458 1
	int i;
d460 5
a464 2
	for (i = 0; i < alink->adapter_buswidth; i++)
		scsi_detach_target(sc, i, flags);
d466 1
a466 1
	return (0);
d473 1
a473 1
	int i, err, rv = 0, detached = 0;
d487 1
a487 1
		if (err != 0)
a488 1
		detached = 1;
d491 1
a491 1
	return (detached ? rv : ENXIO);
d534 2
d768 36
d857 1
d930 2
a931 2
	else if (sc_link->id.d_type != DEVID_NONE &&
	    !DEVID_CMP(&scsi->sc_link[target][0]->id, &sc_link->id))
d938 1
a938 1
		goto bad;
d992 1
a992 1
		goto bad;
d1029 3
d1102 3
d1134 1
a1134 1
	struct scsi_vpd_devid_hdr dhdr;
d1136 2
a1137 1
	int type, idtype = 0, idlen;
d1175 2
a1176 1
					idlen = dhdr.len;
d1191 1
a1191 3
		link->id.d_id = malloc(idlen, M_DEVBUF, M_WAITOK);

		switch (idtype) {
d1193 1
a1193 1
			link->id.d_type = DEVID_NAA;
d1196 1
a1196 1
			link->id.d_type = DEVID_EUI;
d1199 10
a1208 1
			link->id.d_type = DEVID_T10;
d1211 1
a1211 2
		link->id.d_len = idlen;
		memcpy(link->id.d_id, id, idlen);
d1228 32
@


1.150
log
@dont compare devids when we dont have a devid to compare with.
DEVID_CMP now evaluates to false if the devids are NULL.

some stupid devices dont understand luns, so we have code that
detects when the device at lun 0 also appears at luns 1, 2, 3, and
so on. this check is short circuited if the devices report different
devids. no devids isnt the same as different devids though.

found by okan@@ on ciss (which currently ignores luns).
tested by krw@@ marco@@ johan@@ okan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.149 2009/11/10 10:13:08 dlg Exp $	*/
a115 4
void scsi_activate_bus(struct scsibus_softc *, int);
void scsi_activate_target(struct scsibus_softc *, int, int);
void scsi_activate_lun(struct scsibus_softc *, int, int, int);

d202 1
a202 74
	struct scsibus_softc *sc = (struct scsibus_softc *)dev;

	scsi_activate(sc, -1, -1, act);

	return (0);
}

void
scsi_activate(struct scsibus_softc *sc, int target, int lun, int act)
{
	if (target == -1 && lun == -1)
		scsi_activate_bus(sc, act);

	if (target == -1)
		return;

	if (lun == -1)
		scsi_activate_target(sc, target, act);

	scsi_activate_lun(sc, target, lun, act);
}

void
scsi_activate_bus(struct scsibus_softc *sc, int act)
{
	int target;

	for (target = 0; target < sc->sc_buswidth; target++)
		scsi_activate_target(sc, target, act);
}

void
scsi_activate_target(struct scsibus_softc *sc, int target, int act)
{
	int lun;

	for (lun = 0; lun < sc->adapter_link->luns; lun++)
		scsi_activate_lun(sc, target, lun, act);
}

void
scsi_activate_lun(struct scsibus_softc *sc, int target, int lun, int act)
{
	struct scsi_link *link = sc->sc_link[target][lun];
	struct device *dev;

	if (link == NULL)
		return;

	dev = link->device_softc;
	switch (act) {
	case DVACT_ACTIVATE:
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_activate(link);
		else
#endif /* NMPATH */
			config_activate(dev);
		break;

	case DVACT_DEACTIVATE:
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_deactivate(link);
		else
#endif /* NMPATH */
			config_deactivate(dev);
		break;
	default:
#ifdef DIAGNOSTIC
		printf("%s: unsupported act %d\n", sc->sc_dev.dv_xname, act);
#endif
		break;
	}
d209 1
a209 1
	int				i, error;
d215 1
a215 2
	error = scsi_detach_bus(sb, type);
	if (error != 0)
d219 5
a223 1
		if (sb->sc_link[i] != NULL)
d225 1
a276 3
		if (sdev->sd_target == -1 && sdev->sd_lun == -1)
			return (scsi_detach_bus(sc, 0));

d382 1
a382 1
	int i, err, rv = 0;
d384 2
a385 5
	for (i = 0; i < alink->adapter_buswidth; i++) {
		err = scsi_detach_target(sc, i, flags);
		if (err != 0 && err != ENXIO)
			rv = err;
	}
d387 1
a387 1
	return (rv);
d394 1
a394 1
	int i, err, rv = 0;
d408 1
a408 1
		if (err != 0 && err != ENXIO)
d410 1
d413 1
a413 1
	return (rv);
a455 2
	if (link->id != NULL)
		devid_free(link->id);
a687 36

#if NMPATH > 0
	if (link->id != NULL && link->id->d_type != DEVID_NONE) {
		u_int8_t *id = (u_int8_t *)(link->id + 1);
		int i;

		switch (link->id->d_type) {
		case DEVID_NAA:   
			printf(" naa.");
			break;
		case DEVID_EUI:
			printf(" eui.");
			break;
		case DEVID_T10:
			printf(" t10.");
			break;
		}

		if (ISSET(link->id->d_flags, DEVID_F_PRINT)) {
			for (i = 0; i < link->id->d_len; i++) {
				if (id[i] == '\0' || id[i] == ' ')
					printf("_");
				else if (id[i] < 0x20 || id[i] >= 0x80) {
					/* non-printable characters */
					printf("~");
				} else {
					/* normal characters */
					printf("%c", id[i]);
				}
			}
		} else {
			for (i = 0; i < link->id->d_len; i++)
				printf("%02x", id[i]);
		}
	}
#endif /* NMPATH > 0 */
a740 1
	mtx_init(&sc_link->mtx, IPL_BIO);
d813 2
a814 2
	else if (sc_link->id != NULL &&
	    !DEVID_CMP(scsi->sc_link[target][0]->id, sc_link->id))
d821 1
a821 1
		goto free_devid;
d875 1
a875 1
		goto free_devid;
a911 3
free_devid:
	if (sc_link->id)
		devid_free(sc_link->id);
a981 3
	if (link->id != NULL)
		return;

d1011 1
a1011 1
	struct scsi_vpd_devid_hdr dhdr, chdr;
d1013 1
a1013 2
	int type, idtype = 0;
	u_char idflags;
d1051 1
a1051 2

					chdr = dhdr;
d1066 3
a1068 1
		switch (VPD_DEVID_TYPE(chdr.flags)) {
d1070 1
a1070 1
			idtype = DEVID_NAA;
d1073 1
a1073 1
			idtype = DEVID_EUI;
d1076 1
a1076 10
			idtype = DEVID_T10;
			break;
		}
		switch (VPD_DEVID_CODE(chdr.pi_code)) {
		case VPD_DEVID_CODE_ASCII:
		case VPD_DEVID_CODE_UTF8:
			idflags = DEVID_F_PRINT;
			break;
		default:
			idflags = 0;
d1079 2
a1080 1
		link->id = devid_alloc(idtype, idflags, chdr.len, id);
a1096 32
}

struct devid *
devid_alloc(u_int8_t type, u_int8_t flags, u_int8_t len, u_int8_t *id)
{
	struct devid *d;

	d = malloc(sizeof(*d) + len, M_DEVBUF, M_WAITOK|M_CANFAIL);
	if (d == NULL)
		return (NULL);

	d->d_type = type;
	d->d_flags = flags;
	d->d_len = len;
	d->d_refcount = 1;
	memcpy(d + 1, id, len);

	return (d);
}

struct devid *
devid_copy(struct devid *d)
{
	d->d_refcount++;
	return (d);
}

void
devid_free(struct devid *d)
{
	if (--d->d_refcount == 0)
		free(d, M_DEVBUF);
@


1.149
log
@backout the backout marco did of my code because of the NO_CCB breakage.
the fix for the NO_CCB breakage will follow shortly.

tested by krw@@ marco@@ johan@@
ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.146 2009/10/22 11:56:32 dlg Exp $	*/
d930 2
a931 1
	else if (!DEVID_CMP(scsi->sc_link[target][0]->id, sc_link->id))
@


1.148
log
@The big diff dlg committed to the midlayer breaks NO_CCB and
TRY_AGAIN_LATER.  NO_CCB is a timer based mechanism that can trivially
be made to fail by running IO to two or more disks simultaneously.  The
TRY_AGAIN_LATER thing is more subtle because it now is a permanent
failure instead of transient however this is much harder to hit because
something must have gone wrong before it hits.

ok deraadt krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.142 2009/08/10 11:02:38 dlg Exp $	*/
d116 4
d206 74
a279 1
	return (config_activate_children(dev, act));
d286 1
a286 1
	int				i, j, error;
d292 2
a293 1
	if ((error = config_detach_children(dev, type)) != 0)
d297 1
a297 5
		if (sb->sc_link[i] != NULL) {
			for (j = 0; j < sb->adapter_link->luns; j++) {
				if (sb->sc_link[i][j] != NULL)
					free(sb->sc_link[i][j], M_DEVBUF);
			}
a298 1
		}
d350 3
d458 1
a458 1
	int i;
d460 5
a464 2
	for (i = 0; i < alink->adapter_buswidth; i++)
		scsi_detach_target(sc, i, flags);
d466 1
a466 1
	return (0);
d473 1
a473 1
	int i, err, rv = 0, detached = 0;
d487 1
a487 1
		if (err != 0)
a488 1
		detached = 1;
d491 1
a491 1
	return (detached ? rv : ENXIO);
d534 2
d768 36
d857 1
d930 1
a930 2
	else if (sc_link->id.d_type != DEVID_NONE &&
	    !DEVID_CMP(&scsi->sc_link[target][0]->id, &sc_link->id))
d937 1
a937 1
		goto bad;
d991 1
a991 1
		goto bad;
d1028 3
d1101 3
d1133 1
a1133 1
	struct scsi_vpd_devid_hdr dhdr;
d1135 2
a1136 1
	int type, idtype = 0, idlen;
d1174 2
a1175 1
					idlen = dhdr.len;
d1190 1
a1190 3
		link->id.d_id = malloc(idlen, M_DEVBUF, M_WAITOK);

		switch (idtype) {
d1192 1
a1192 1
			link->id.d_type = DEVID_NAA;
d1195 1
a1195 1
			link->id.d_type = DEVID_EUI;
d1198 10
a1207 1
			link->id.d_type = DEVID_T10;
d1210 1
a1210 2
		link->id.d_len = idlen;
		memcpy(link->id.d_id, id, idlen);
d1227 32
@


1.147
log
@if you're attempting to detach multiple devices (eg, many targets,
many luns, or the entire bus), dont report ENXIO as an error to the
caller. this broke autoconf when it tried to forcefully remove a
bus such as umass and it thought there was a failure.

this introduces a way for scsi hbas to call activate/deactivate on
a device based on its target/lun address via a call to scsi_activate().
they can then schedule the actual detach/attach in a thread later via
scsi_req_probe/detach.

the mpi changes tweak the sas event handling code to use these apis
to properly handle attaches and detaches of disks. event handling
is still disabled till i can make it less chatty.

umass breakage reported by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.146 2009/10/22 11:56:32 dlg Exp $	*/
a115 4
void scsi_activate_bus(struct scsibus_softc *, int);
void scsi_activate_target(struct scsibus_softc *, int, int);
void scsi_activate_lun(struct scsibus_softc *, int, int, int);

d202 1
a202 74
	struct scsibus_softc *sc = (struct scsibus_softc *)dev;

	scsi_activate(sc, -1, -1, act);

	return (0);
}

void
scsi_activate(struct scsibus_softc *sc, int target, int lun, int act)
{
	if (target == -1 && lun == -1)
		scsi_activate_bus(sc, act);

	if (target == -1)
		return;

	if (lun == -1)
		scsi_activate_target(sc, target, act);

	scsi_activate_lun(sc, target, lun, act);
}

void
scsi_activate_bus(struct scsibus_softc *sc, int act)
{
	int target;

	for (target = 0; target < sc->sc_buswidth; target++)
		scsi_activate_target(sc, target, act);
}

void
scsi_activate_target(struct scsibus_softc *sc, int target, int act)
{
	int lun;

	for (lun = 0; lun < sc->adapter_link->luns; lun++)
		scsi_activate_lun(sc, target, lun, act);
}

void
scsi_activate_lun(struct scsibus_softc *sc, int target, int lun, int act)
{
	struct scsi_link *link = sc->sc_link[target][lun];
	struct device *dev;

	if (link == NULL)
		return;

	dev = link->device_softc;
	switch (act) {
	case DVACT_ACTIVATE:
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_activate(link);
		else
#endif /* NMPATH */
			config_activate(dev);
		break;

	case DVACT_DEACTIVATE:
#if NMPATH > 0
		if (dev == NULL)
			mpath_path_deactivate(link);
		else
#endif /* NMPATH */
			config_deactivate(dev);
		break;
	default:
#ifdef DIAGNOSTIC
		printf("%s: unsupported act %d\n", sc->sc_dev.dv_xname, act);
#endif
		break;
	}
d209 1
a209 1
	int				i, error;
d215 1
a215 2
	error = scsi_detach_bus(sb, type);
	if (error != 0)
d219 5
a223 1
		if (sb->sc_link[i] != NULL)
d225 1
a276 3
		if (sdev->sd_target == -1 && sdev->sd_lun == -1)
			return (scsi_detach_bus(sc, 0));

d382 1
a382 1
	int i, err, rv = 0;
d384 2
a385 5
	for (i = 0; i < alink->adapter_buswidth; i++) {
		err = scsi_detach_target(sc, i, flags);
		if (err != 0 && err != ENXIO)
			rv = err;
	}
d387 1
a387 1
	return (rv);
d394 1
a394 1
	int i, err, rv = 0;
d408 1
a408 1
		if (err != 0 && err != ENXIO)
d410 1
d413 1
a413 1
	return (rv);
a455 2
	if (link->id != NULL)
		devid_free(link->id);
a687 36

#if NMPATH > 0
	if (link->id != NULL && link->id->d_type != DEVID_NONE) {
		u_int8_t *id = (u_int8_t *)(link->id + 1);
		int i;

		switch (link->id->d_type) {
		case DEVID_NAA:   
			printf(" naa.");
			break;
		case DEVID_EUI:
			printf(" eui.");
			break;
		case DEVID_T10:
			printf(" t10.");
			break;
		}

		if (ISSET(link->id->d_flags, DEVID_F_PRINT)) {
			for (i = 0; i < link->id->d_len; i++) {
				if (id[i] == '\0' || id[i] == ' ')
					printf("_");
				else if (id[i] < 0x20 || id[i] >= 0x80) {
					/* non-printable characters */
					printf("~");
				} else {
					/* normal characters */
					printf("%c", id[i]);
				}
			}
		} else {
			for (i = 0; i < link->id->d_len; i++)
				printf("%02x", id[i]);
		}
	}
#endif /* NMPATH > 0 */
a740 1
	mtx_init(&sc_link->mtx, IPL_BIO);
d813 2
a814 1
	else if (!DEVID_CMP(scsi->sc_link[target][0]->id, sc_link->id))
d821 1
a821 1
		goto free_devid;
d875 1
a875 1
		goto free_devid;
a911 3
free_devid:
	if (sc_link->id)
		devid_free(sc_link->id);
a981 3
	if (link->id != NULL)
		return;

d1011 1
a1011 1
	struct scsi_vpd_devid_hdr dhdr, chdr;
d1013 1
a1013 2
	int type, idtype = 0;
	u_char idflags;
d1051 1
a1051 2

					chdr = dhdr;
d1066 3
a1068 1
		switch (VPD_DEVID_TYPE(chdr.flags)) {
d1070 1
a1070 1
			idtype = DEVID_NAA;
d1073 1
a1073 1
			idtype = DEVID_EUI;
d1076 1
a1076 10
			idtype = DEVID_T10;
			break;
		}
		switch (VPD_DEVID_CODE(chdr.pi_code)) {
		case VPD_DEVID_CODE_ASCII:
		case VPD_DEVID_CODE_UTF8:
			idflags = DEVID_F_PRINT;
			break;
		default:
			idflags = 0;
d1079 2
a1080 1
		link->id = devid_alloc(idtype, idflags, chdr.len, id);
a1096 32
}

struct devid *
devid_alloc(u_int8_t type, u_int8_t flags, u_int8_t len, u_int8_t *id)
{
	struct devid *d;

	d = malloc(sizeof(*d) + len, M_DEVBUF, M_WAITOK|M_CANFAIL);
	if (d == NULL)
		return (NULL);

	d->d_type = type;
	d->d_flags = flags;
	d->d_len = len;
	d->d_refcount = 1;
	memcpy(d + 1, id, len);

	return (d);
}

struct devid *
devid_copy(struct devid *d)
{
	d->d_refcount++;
	return (d);
}

void
devid_free(struct devid *d)
{
	if (--d->d_refcount == 0)
		free(d, M_DEVBUF);
@


1.146
log
@devices below the scsibus should all be detached via scsi_detach_lun.
scsibusdetach wasnt doign it properly, so we would be leaking on detach in
some cases.

now, with the introduction of mpath, the scsi_link structures can
represent a path to a mpath node as well as normal devices. this
intercepts the device activate entrypoints and sends them to mpath
if it it in use rather than assuming a device is always there. the
scsibusdetach change ensures that detach always ends up handling
the mpath node case too.

hotplug bus functionality (eg, usb) tested by form@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.145 2009/10/14 01:33:22 dlg Exp $	*/
d116 4
a206 3
	struct scsi_link *link;
	int i, j;
	int rv, ret = 0;
d208 43
a250 3
	for (i = 0; i < sc->sc_buswidth; i++) {
		if (sc->sc_link[i] == NULL)
			continue;
d252 2
a253 5
		for (j = 0; j < sc->adapter_link->luns; j++) {
			link = sc->sc_link[i][j];
			if (link == NULL)
				continue;
			dev = link->device_softc;
d255 3
a257 2
			switch (act) {
			case DVACT_ACTIVATE:
d259 3
a261 3
				if (dev == NULL)
					rv = mpath_path_activate(link);
				else
d263 2
a264 2
					rv = config_activate(dev);
				break;
d266 1
a266 1
			case DVACT_DEACTIVATE:
d268 3
a270 3
				if (dev == NULL)
					rv = mpath_path_deactivate(link);
				else
d272 3
a274 3
					rv = config_deactivate(dev);
				break;
			default:
d276 1
a276 2
				printf("%s: unsupported act %d\n",
				    sc->sc_dev.dv_xname, act);
d278 1
a278 8
				rv = EOPNOTSUPP;
				break;

			}

			if (rv != 0)
				ret = rv;
		}
a279 2

	return (ret);
d458 1
a458 1
	int i, err, rv = 0, detached;
d462 1
a462 3
		if (err == 0)
			detached = 1;
		else
d466 1
a466 1
	return (detached ? rv : ENXIO);
d473 1
a473 1
	int i, err, rv = 0, detached = 0;
d487 1
a487 3
		if (err == 0)
			detached = 1;
		else
d491 1
a491 1
	return (detached ? rv : ENXIO);
@


1.145
log
@rework how devids are handled in the midlayer and mpath.

previously a devid was a structure containing its type, length, and
a pointer to the actual devid value. this has been changed so a
devid is a header followed immediately by the memory making up the
id value. this allows the header and its value to be allocated
together.

devids are now reference counted, so multiple things (eg, the mpath
node handlers and the various scsi_link structures) can share the
same allocation safely. this also frees devids when scsi_links go
away, which was previously not done.

if mpath is enabled, then print the devids out as part of the devices
attach line.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.144 2009/10/13 19:33:19 pirofti Exp $	*/
d202 49
a250 1
	return (config_activate_children(dev, act));
d257 1
a257 2
	struct scsi_link		*sc_link;
	int				i, j, error;
d263 2
a264 1
	if ((error = config_detach_children(dev, type)) != 0)
d268 1
a268 9
		if (sb->sc_link[i] != NULL) {
			for (j = 0; j < sb->adapter_link->luns; j++) {
				sc_link = sb->sc_link[i][j];
				if (sc_link != NULL) {
					if (sc_link->id != NULL)
						devid_free(sc_link->id);
					free(sc_link, M_DEVBUF);
				}
			}
a269 1
		}
d321 3
d429 1
a429 1
	int i;
d431 7
a437 2
	for (i = 0; i < alink->adapter_buswidth; i++)
		scsi_detach_target(sc, i, flags);
d439 1
a439 1
	return (0);
d460 3
a462 1
		if (err != 0)
a463 1
		detached = 1;
@


1.144
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.143 2009/09/14 00:03:28 dlg Exp $	*/
d209 1
d222 6
a227 2
				if (sb->sc_link[i][j] != NULL)
					free(sb->sc_link[i][j], M_DEVBUF);
d461 2
d695 36
d857 1
a857 2
	else if (sc_link->id.d_type != DEVID_NONE &&
	    !DEVID_CMP(&scsi->sc_link[target][0]->id, &sc_link->id))
d864 1
a864 1
		goto bad;
d918 1
a918 1
		goto bad;
d955 3
d1028 3
d1060 1
a1060 1
	struct scsi_vpd_devid_hdr dhdr;
d1062 2
a1063 1
	int type, idtype = 0, idlen;
d1101 2
a1102 1
					idlen = dhdr.len;
d1117 1
a1117 3
		link->id.d_id = malloc(idlen, M_DEVBUF, M_WAITOK);

		switch (idtype) {
d1119 1
a1119 1
			link->id.d_type = DEVID_NAA;
d1122 1
a1122 1
			link->id.d_type = DEVID_EUI;
d1125 1
a1125 1
			link->id.d_type = DEVID_T10;
d1128 10
a1137 2
		link->id.d_len = idlen;
		memcpy(link->id.d_id, id, idlen);
d1154 32
@


1.143
log
@rework the scsi midlayer to start addressing some problems i have
with it which became extremely annoying with what mpath wants to
do.

the major change is a new interface for submitting scsi commands.
previously the only way for drivers like sd, cd, st, etc to push
commands onto the hardware was via scsi_scsi_cmd(). the problem
with scsi_scsi_cmd is that it doesnt tell the caller if the command
failed, was queued, or completed unless you shoved a buf down with
it. this is important for mpath which wants to know what the physical
path to the device did so it can report it back to the midlayer
which called it.

this provides a new api which lets drivers like cd/sd/st/mpath etc
allocate an xs, fill it in, and provide a completion routine which
the midlayer will call with the state of the command when it is
finished with it. the caller is then responsible for freeing the
xs.

from the hba side of thing, the return code from the scsi_cmd
entrypoint is largely ignored now, and it is now always the
responsibility of the hba driver to call scsi_done when it has
completed the io, rather than returning COMPLETE and expecting the
midlayer to do it for you.

i have emulated scsi_scsi_cmd on top of this new api so existing
users of it will continue to work. sd(4) has been reworked to use
the new api directly to both demonstrate its use and test that the
new api actually does work.

this diff was mostly written in a day at f2k9. thanks to miod for poking
through hba drivers to help mitigate against fallout from the change to
the COMPLETE semantic. this has been reviewed by krw who didnt spot
anything wrong.

thanks to dave del debbio for testing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.142 2009/08/10 11:02:38 dlg Exp $	*/
d86 1
a86 1
int	scsibusactivate(struct device *, enum devact);
d200 1
a200 1
scsibusactivate(struct device *dev, enum devact act)
@


1.142
log
@if mpath steals a link, print out where the link was stolen so dmesg still
shows the physical topology of your system.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.141 2009/08/10 10:51:17 dlg Exp $	*/
d741 1
@


1.141
log
@pull the printing out of scsibusprint so it can be used against scsi_link
structures by things other than autoconf.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.140 2009/08/09 12:47:23 dlg Exp $	*/
d827 4
@


1.140
log
@add mpath(4), a driver that steals paths to scsi devices if it
thinks they could be available via multiple paths. those stolen
devices are then made available via mpath(4).

this is the minimum amount of code to implement the stealing. it
is generally broken and very brittle, so it is currently disabled.

it is going in so i can work on it in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.139 2009/08/08 09:33:50 dlg Exp $	*/
d114 1
d594 2
a595 12
/*
 * Print out autoconfiguration information for a subdevice.
 *
 * This is a slight abuse of 'standard' autoconfiguration semantics,
 * because 'print' functions don't normally print the colon and
 * device information.  However, in this case that's better than
 * either printing redundant information before the attach message,
 * or having the device driver call a special function to print out
 * the standard device information.
 */
int
scsibusprint(void *aux, const char *pnp)
d597 1
a597 1
	struct scsi_attach_args		*sa = aux;
d601 1
a601 3
	char				*dtype, *qtype;
	char				vendor[33], product[65], revision[17];
	int				target, lun;
d603 1
a603 7
	if (pnp != NULL)
		printf("%s", pnp);

	inqbuf = sa->sa_inqbuf;

	target = sa->sa_sc_link->target;
	lun = sa->sa_sc_link->lun;
a610 1
	dtype = 0;
a621 1

d630 1
a630 1
	if (dtype == 0) {
d680 3
a682 3
	printf(" targ %d lun %d: <%s, %s, %s> ", target, lun, vendor, product,
	    revision);
	if (sa->sa_sc_link->flags & SDEV_ATAPI)
d688 21
@


1.139
log
@if the adapters wwn fields are set, print them out when attaching scsibus.

we need this to get some clue as to which ports are which on an fc fabric.

requested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.137 2009/02/16 21:13:31 krw Exp $	*/
d51 1
d440 7
a446 1
	rv = config_detach(link->device_softc, flags);
d821 8
@


1.138
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d168 5
@


1.137
log
@Don't try to SCSIDEBUG targets or luns >31 since we only have 32 bits to
use to identify devices of interest.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.136 2009/02/16 00:05:03 dlg Exp $	*/
d57 1
d1061 10
@


1.136
log
@on some buses (eg sas and fc fabrics) the initiator id doesnt mean
anything. we represent that in the midlayre by moving the initiator id out
of the buswidth. let's not print it in that case.

ok deraadt@@ kettenis@@ krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.135 2008/07/22 01:01:31 dlg Exp $	*/
d751 2
a752 2
	    ((1 << target) & scsidebug_targets) &&
	    ((1 << lun) & scsidebug_luns))
@


1.135
log
@implement the fetching of a scsi devices "devid". recent hardware provides
a vpd page that uniquely identifies a device no matter what bus topology or
addressing was used to find it.

we have a workaround for old school scsi devices that do not differentiate
between luns. if the inq data for high luns is the same as the inq data
for lun 0, we assume it is one of these buggy devices.

the problem with this is that things like SANs present multiple
volumes as luns and they all have the same inq data. if you wanted
to present more than one volume to openbsd you would only ever see
the first one.

devices give us a mechanism to differentiate between luns, so now
i do get all my volumes attached in openbsde.

review and feedback by krw@@ marco@@ testing by todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.128 2007/11/25 22:28:54 dlg Exp $	*/
d164 4
a167 2
	printf(": %d targets, initiator %d\n", sb->sc_buswidth,
	    sb->adapter_link->adapter_target);
@


1.134
log
@tweak comment to reflect the new reality after my last change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.133 2008/07/21 23:40:03 dlg Exp $	*/
d72 3
d706 1
a706 1
	struct scsi_inquiry_data	*inqbuf;
d790 2
d796 3
d942 116
@


1.133
log
@when probing a device the midlayer queries its inquiry data and
keeps it on the stack till we attach a driver to it. then it copies
the inquiry data int the scsi_link struct.

this diff uses the scsi_link struct instead of the stack for that data,
which makes the inq data for users of the scsi_link struct available much
earlier during device probe.

review and feedback from both krw@@ and marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.131 2008/05/26 17:58:40 kettenis Exp $	*/
d845 1
a845 2
	 * point (since we are done with the data in inqbuf) to prevent such
	 * helpfulness before it causes confusion.
d850 1
@


1.132
log
@Nuke ADEV_NOTUR, always issue TEST UNIT READY to clear out power-up
errors before issuing INQUIRY. Fixes Sony YE-Data floppy drive and
probably other devices at the cost of possibly breaking some 10 year
old CD-ROM drives. Un-special cases mvme68k which was forcing these
initial TURs.

Now wait for the inevitable weird USB device that breaks to surface.

ok marco@@ deraadt@@
@
text
@d703 1
a703 1
	static struct scsi_inquiry_data	inqbuf;
d721 1
d759 1
a759 1
	rslt = scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT);
d767 1
a767 1
	switch (inqbuf.device & SID_QUAL) {
d771 2
a772 2
		SC_DEBUG(sc_link, SDEV_DB1,
		    ("Bad LUN. SID_QUAL = 0x%02x\n", inqbuf.device & SID_QUAL));
d776 1
a776 1
		if ((inqbuf.device & SID_TYPE) == T_NODEVICE) {
d791 2
a792 2
	else if (memcmp(&inqbuf, &scsi->sc_link[target][0]->inqdata,
	    sizeof inqbuf) == 0) {
d800 1
a800 1
	    &inqbuf, scsi_quirk_patterns,
d808 2
a809 2
	if (SCSISPC(inqbuf.version) >= 2) {
		if ((inqbuf.flags & SID_CmdQue) != 0)
d811 1
a811 1
		if ((inqbuf.flags & SID_Sync) != 0)
d813 1
a813 1
		if ((inqbuf.flags & SID_WBus16) != 0)
a825 5
	 * Save INQUIRY.
	 */
	memcpy(&sc_link->inqdata, &inqbuf, sizeof(sc_link->inqdata));

	/*
d828 1
a828 1
	if ((inqbuf.dev_qual2 & SID_REMOVABLE) != 0)
d850 1
d852 1
a852 1
		scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT);
@


1.131
log
@Print SCSI initiator ID such that it is easier to spot configuration
problems.

ok krw@@, marco@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.130 2008/04/24 14:51:12 krw Exp $	*/
a546 2
         "ALPS ELECTRIC CO.,LTD. DC544C", "", "SW03D"}, ADEV_NOTUR},
        {{T_CDROM, T_REMOV,
a560 2
         "NEC                 CD-ROM DRIVE:273", "", "4.21"}, ADEV_NOTUR},
        {{T_CDROM, T_REMOV,
a749 1
#if defined(mvme68k)
d751 1
a751 1
		/* XXX some drivers depend on this */
a755 1
#endif
@


1.130
log
@Say 'ATAPI' rather than 'SCSIn' for ATAPI devices found on (pseudo)
SCSI buses like atapiscsi.  This more accurately describes the
commands that will be used on the device.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.129 2007/11/26 15:40:51 dlg Exp $	*/
d161 2
a162 1
	printf(": %d targets\n", sb->sc_buswidth);
@


1.129
log
@let scsibus ask the adapter about a device before probing it. also allow
the adapter to be notified when a device goes away so it can free any state
it maintains about that device.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.128 2007/11/25 22:28:54 dlg Exp $	*/
d684 8
a691 4
	printf(" targ %d lun %d: <%s, %s, %s> SCSI%d %d/%s %s%s",
	    target, lun, vendor, product, revision,
	    SCSISPC(inqbuf->version), type, dtype,
	    removable ? "removable" : "fixed", qtype);
@


1.128
log
@dont use the adapter_softc member of scsi_link as a softc anymore. the
"adapter_softc" is simply a way for the adapter to determine what scsibus
it is now dealing with, not a pointer back to the adapters device struct.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.127 2007/11/06 02:49:19 krw Exp $	*/
d424 1
a424 1
	/* detaching a device from scsibus is a two step process... */
d431 5
a435 1
	/* 2. free up its state in the midlayer */
d723 8
d880 3
@


1.127
log
@Fix SDF_DIRTY handling, eliminate useless SDF_FLUSHING. The sd_flush()
called from the last sdclose() on a device will now reset SDF_DIRTY
after submitting the SYNCHRONIZE CACHE command. sddone() need not
worry about SDF_DIRTY since it was never called for the SYNCHRONIZE
CACHE command anyway.

This eliminates a spurious SYNCHRONIZE CACHE command being issued for
every sd device from sd_shutdown().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.126 2007/09/16 15:54:52 krw Exp $	*/
d152 1
@


1.126
log
@A couple of obvious bzero() -> M_ZERO changes I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.125 2007/05/08 18:50:39 deraadt Exp $	*/
d802 4
a805 1
	}
@


1.125
log
@all scsidebug_*-using code is under #ifdef, so the variables themselves should be too
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.124 2006/12/29 13:04:37 pedro Exp $	*/
d171 1
a171 1
		sb->sc_link[i] = malloc(nbytes, M_DEVBUF, M_NOWAIT);
a173 1
		bzero(sb->sc_link[i], nbytes);
@


1.124
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.123 2006/11/28 23:59:45 dlg Exp $	*/
d99 1
d104 1
@


1.123
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.122 2006/11/28 16:56:50 dlg Exp $	*/
d872 2
a873 2
scsi_inqmatch(struct scsi_inquiry_data *inqbuf, const void *base, int nmatches,
    int matchsize, int *bestpriority)
d878 1
@


1.122
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.121 2006/11/27 18:32:33 dlg Exp $	*/
d143 2
a144 1
	struct scsi_link		*sc_link_proto = aux;
@


1.121
log
@add bio code to do hotplug of devices on the scsibus.

thumbs up deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.120 2006/11/27 13:33:15 dlg Exp $	*/
d223 1
a223 1
	struct scsibus_attach_args	*sa = aux;
d584 1
a584 1
	struct scsibus_attach_args	*sa = aux;
d696 1
a696 1
	struct scsibus_attach_args sa;
@


1.120
log
@hook scsibus up to bio.

ok deraadt@@ krw@@ an earlier diff was ok marco@@ too
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.119 2006/11/27 11:56:20 dlg Exp $	*/
d62 2
d238 33
a270 1
	return (ENOTTY);
@


1.119
log
@if there are no luns on a target, then say there were no devices,
otherwise return any error we find during detach of the luns.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.118 2006/11/26 09:29:07 dlg Exp $	*/
d50 2
d61 4
d84 4
d172 5
d192 4
d231 8
@


1.118
log
@provide scsi_detach_bus, _target, and _lun to wrap up config_detach for
scsi devices. the midlayer keeps some state for each device that is
attached which needs to be cleaned up on detach, hence this wrapper.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.117 2006/10/21 07:36:15 dlg Exp $	*/
d304 1
a304 1
	int i, err, rv;
d306 2
a307 3
	for (i = 0; i < alink->adapter_buswidth; i++) {
		if (sc->sc_link[i] == NULL)
			continue;
d309 1
a309 6
		err = scsi_detach_target(sc, i, flags);
		if (err != 0)
			rv = err;
	}

	return (rv);
d316 1
a316 1
	int i, err, rv;
d322 3
d332 1
d335 1
a335 1
	return (rv);
d357 1
a357 1
	if (((flags & DETACH_FORCE) == 0) && link->flags & SDEV_OPEN)
@


1.117
log
@rework the bus scanning code by splitting it out into separate functions
for walking the bus and targets, and probing the luns. this removes the
need to use magic numbers to wildcard each of these, which in turn makes
the code a lot easier to read. as a bonus we get some more space to work in
(80 chars isnt that much somtimes).

note that this code wont probe high luns if lun 0 doesnt exist.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.116 2006/10/07 23:40:07 beck Exp $	*/
d298 76
@


1.116
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.115 2006/10/02 09:06:26 dlg Exp $	*/
a62 1
int	scsi_probe_bus(int, int, int);
d162 1
a162 1
	scsi_probe_bus(sb->sc_dev.dv_unit, -1, -1);
a212 5
/*
 * Probe the requested scsi bus. It must be already set up.
 * -1 requests all set up scsi busses.
 * target and lun optionally narrow the search if not -1
 */
d214 1
a214 1
scsi_probe_busses(int bus, int target, int lun)
d216 5
a220 6
	if (bus == -1) {
		for (bus = 0; bus < scsibus_cd.cd_ndevs; bus++)
			if (scsibus_cd.cd_devs[bus])
				scsi_probe_bus(bus, target, lun);
		return (0);
	}
d222 1
a222 1
	return (scsi_probe_bus(bus, target, lun));
a224 4
/*
 * Probe the requested scsi bus. It must be already set up.
 * target and lun optionally narrow the search if not -1
 */
d226 1
a226 1
scsi_probe_bus(int bus, int target, int lun)
d228 7
a234 5
	struct scsi_report_luns_data *data = NULL;
	struct scsibus_softc *scsi;
	struct scsi_link *sc_link;
	u_int16_t scsi_addr;
	int i, luncount, maxtarget, mintarget, maxlun, minlun;
d236 2
a237 1
	if (bus < 0 || bus >= scsibus_cd.cd_ndevs)
d240 36
a275 14
	scsi = scsibus_cd.cd_devs[bus];
	if (scsi == NULL)
		return ENXIO;

	scsi_addr = scsi->adapter_link->adapter_target;

	if (target == -1) {
		maxtarget = scsi->adapter_link->adapter_buswidth - 1;
		mintarget = 0;
	} else {
		if (target < 0 ||
		    target >= scsi->adapter_link->adapter_buswidth)
			return (EINVAL);
		maxtarget = mintarget = target;
d278 4
a281 11
	if (lun == -1) {
		maxlun = scsi->adapter_link->luns - 1;
		minlun = 0;
	} else {
		if (lun < 0 || lun >= scsi->adapter_link->luns)
			return (EINVAL);
		maxlun = lun;
		if (target == -1 || scsi->sc_link[target][0] == NULL)
			minlun = 0;
		else
			minlun = lun;
d284 2
a285 1
	data = malloc(sizeof *data, M_TEMP, M_NOWAIT);
d287 4
a290 36
	for (target = mintarget; target <= maxtarget; target++) {
		if (target == scsi_addr)
			continue;
		if (scsi_probedev(scsi, target, 0) == EINVAL)
			continue;

		sc_link = scsi->sc_link[target][0];
		if (sc_link != NULL && data != NULL &&
		    (sc_link->flags & (SDEV_UMASS | SDEV_ATAPI)) == 0 &&
		    SCSISPC(sc_link->inqdata.version) > 2) {
			scsi_report_luns(sc_link, REPORT_NORMAL, data,
			    sizeof *data, scsi_autoconf | SCSI_SILENT |
		    	    SCSI_IGNORE_ILLEGAL_REQUEST |
			    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE,
			    10000);
			/*
			 * XXX In theory we should check if data is full, which
			 * would indicate it needs to be enlarged and REPORT
			 * LUNS tried again. Solaris tries up to 3 times with
			 * larger sizes for data.
			 */
			luncount = _4btol(data->length) / RPL_LUNDATA_SIZE;
			for (i = 0; i < luncount; i++) {
				if (data->luns[i].lundata[0] != 0)
					continue;
				lun = data->luns[i].lundata[RPL_LUNDATA_T0LUN];
				if (lun == 0 || lun < minlun || lun > maxlun)
					continue;
				/* Probe the provided LUN. Don't check LUN 0. */
				scsi->sc_link[target][0] = NULL;
				scsi_probedev(scsi, target, lun);
				scsi->sc_link[target][0] = sc_link;
			}
			if (luncount > 0)
				continue; /* Next target. */
		}
d292 4
a295 8
		/* No LUN list available. Scan entire range. */
		for (lun = max(minlun, 1); lun <= maxlun; lun++)
			if (scsi_probedev(scsi, target, lun) == EINVAL)
				break;
	}

	if (data != NULL)
		free(data, M_TEMP);
d297 1
a297 1
	return (0);
@


1.115
log
@get rid of a boolean typedef. this is c, we have ints, deal with it.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.114 2006/10/01 13:00:47 dlg Exp $	*/
d630 1
a630 1
		scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d746 1
a746 1
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
@


1.114
log
@whitespace tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.113 2006/09/22 00:33:41 dlg Exp $	*/
d480 1
a480 1
	boolean				removable;
d768 1
a768 1
	boolean				removable;
@


1.113
log
@implement a kernel thread that can be used by the midlayer or scsi drivers
when they need a process context to do something. the most obvious task
that springs to mind is attaches and detaches of devices on scsibus.

ok krw@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.112 2006/09/21 08:42:11 dlg Exp $	*/
d276 1
a276 1
	
d278 1
a278 1
	
d292 1
a292 1
		            SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE,
d387 1
a387 1
	 "PLEXTOR", "CD-ROM PX-40TS", "1.01"}, SDEV_NOSYNC},
d581 1
a581 1
 * 
@


1.112
log
@when we probe and find devices on the scsibus, we allocate a scsi_link
struct for it and keep it in the midlayer. however, this struct was never
free'd on detach.

since we only do hotplugging of controllers (and the scsibus and devices
get hotplugged as a matter of course), we now walk the list of scsi_link
structs and free them on detach of scsibus.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.110 2006/07/23 14:34:55 krw Exp $	*/
d192 3
@


1.111
log
@The version field of scsi_inquiry_data is not a simple numeric value
that specifies the version of SCSI being supported. Even the ANSI part
that we use is complex. 4 means 2, 5 means 3 and 6 means 4. Translate
and use the value correctly. Fixes SCSI5 and SCSI6 in dmesg. And
properly protects SCSI2 devices from getting SCSI3 commands.

"seems like an elegant solution to me" millert@@ ok dlg@@ marco@@
@
text
@d176 1
a176 1
	int				i, error;
d182 5
a186 1
		if (sb->sc_link[i] != NULL)
d188 1
@


1.110
log
@Use REPORT LUNS to get the list of LUNs to probe. If such a list is
obtained probe the LUNs given without checking for duplicate INQUIRY
data.

For non-USB, non-ATAPI, devices claiming to be SCSI-3 compliant. And
the target must have something attached at LUN 0.

If REPORT LUNS can't be used or isn't supported, the old scan process
is used.

Fixes Fibre Channel and SCSI enclosure devices that provide identical
INQUIRY data for all LUNs and were thus being misprobed as having
only LUN 0.

Tested by Bob Kitella, dlg@@, beck@@. Suggestions from deraadt@@.

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.109 2006/07/22 18:25:42 krw Exp $	*/
d97 11
d280 1
a280 1
		    (sc_link->inqdata.version & SID_ANSII) > 2) {
d564 1
a564 1
	    inqbuf->version & SID_ANSII, type, dtype,
d678 1
a678 1
	if ((inqbuf.version & SID_ANSII) >= 2) {
@


1.109
log
@Allocate enough, and only enough, scsi_link pointers for the number of
LUNs the driver says targets could have. Don't unconditionally
allocate 8. USB and ATAPI devices have fewer. Fibre Channel devices
can have more.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.108 2006/07/22 18:03:07 krw Exp $	*/
d220 1
d222 1
d224 1
a224 1
	int maxtarget, mintarget, maxlun, minlun;
d257 3
a259 1

d263 36
a298 2
			
		for (lun = minlun; lun <= maxlun; lun++) {
a300 1
		}
d302 3
@


1.108
log
@Nuke SCSIFORCELUN* and friends. These were introduced as a safety
valve in case our duplicate LUN checks had to be circumvented. Since
no one has found a need for them, and they were just one more place
trying to shift a bit 255 places to the left could be induced, remove
them.

"i don't think any options like that are worthwhile" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.107 2006/07/14 01:27:40 krw Exp $	*/
d144 1
a144 1
	nbytes = 8 * sizeof(struct scsi_link *);
@


1.107
log
@Don't keep a special copy of the INQUIRY data for LUN 0 anymore. There
is now a copy in the scsi_link structure so just use that one.

'looks reasonable' beck@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.106 2006/07/13 11:46:16 krw Exp $	*/
a92 3
int scsiforcelun_buses = SCSIFORCELUN_BUSES;
int scsiforcelun_targets = SCSIFORCELUN_TARGETS;

a606 3
		;
	else if (((1 << sc_link->scsibus) & scsiforcelun_buses) &&
	    ((1 << target) & scsiforcelun_targets))
@


1.106
log
@Eliminate scsi_link field 'scsi_version' and just use the INQUIRY data
stored in scsi_link. That's where the value came from anyway. Move 'luns'
field to where 'scsi_version' used to be to preserve alignment.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.105 2006/07/11 21:55:46 dlg Exp $	*/
d62 1
a62 2
int	scsi_probedev(struct scsibus_softc *, struct scsi_inquiry_data *,
	    int, int);
d223 3
a225 4
	struct scsi_inquiry_data	inqbuflun0;
	struct scsibus_softc		*scsi;
	u_int16_t			scsi_addr;
	int				maxtarget, mintarget, maxlun, minlun;
d260 6
a265 12
		if (target != scsi_addr) {
			bzero(&inqbuflun0, sizeof(inqbuflun0));
			if (minlun != 0 &&
			    (scsi_inquire(scsi->sc_link[target][0], &inqbuflun0,
			    0) != 0))
				continue;

			for (lun = minlun; lun <= maxlun; lun++) {
				if (scsi_probedev(scsi, &inqbuflun0, target,
				    lun) == EINVAL)
					break;
			}
d529 1
a529 2
scsi_probedev(struct scsibus_softc *scsi, struct scsi_inquiry_data *inqbuflun0,
    int target, int lun)
d531 1
a531 1
	struct scsi_link		*sc_link;
d533 4
a536 4
	const struct scsi_quirk_inquiry_pattern *finger;
	int				priority, rslt = 0;
	struct scsibus_attach_args	sa;
	struct cfdata			*cf;
d609 2
a610 2
	if (lun == 0)
		bcopy(&inqbuf, inqbuflun0, sizeof *inqbuflun0);
d616 2
a617 1
	else if (memcmp(&inqbuf, inqbuflun0, sizeof inqbuf) == 0) {
@


1.105
log
@the scsi_link structure contained a copy of the inquiry flags and the whole
inquiry. this removes the flags member and makes all its users refer to the
whole inquiry now.

ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.104 2006/07/11 09:45:53 dlg Exp $	*/
a653 1
	sc_link->scsi_version = inqbuf.version;
@


1.104
log
@knf and ansi. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.103 2006/07/11 09:28:35 dlg Exp $	*/
a558 1
	sc_link->inquiry_flags = 0;
d657 1
a657 1
	 * Save INQUIRY "flags" (SID_Linked, etc.) for low-level drivers.
a658 1
	sc_link->inquiry_flags = inqbuf.flags;
@


1.103
log
@remove an if 0 chunk thats been with us forever, but never used and never
will be.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.102 2006/05/13 18:31:34 krw Exp $	*/
d62 3
a64 3
int scsi_probedev(struct scsibus_softc *, struct scsi_inquiry_data *, int,
    int);
int scsi_probe_bus(int bus, int target, int lun);
d73 4
a76 7
int scsibusmatch(struct device *, void *, void *);
void scsibusattach(struct device *, struct device *, void *);
int  scsibusactivate(struct device *, enum devact);
int  scsibusdetach(struct device *, int);

int scsibussubmatch(struct device *, void *, void *);

d78 1
d102 1
a102 3
scsiprint(aux, pnp)
	void *aux;
	const char *pnp;
d112 1
a112 3
scsibusmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d114 1
a114 2

	return 1;
d122 5
a126 7
scsibusattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct scsibus_softc *sb = (struct scsibus_softc *)self;
	struct scsi_link *sc_link_proto = aux;
	int nbytes, i;
d145 1
a145 1
	sb->sc_link = (struct scsi_link ***)malloc(nbytes, M_DEVBUF, M_NOWAIT);
d150 1
a150 2
		sb->sc_link[i] = (struct scsi_link **)malloc(nbytes,
		    M_DEVBUF, M_NOWAIT);
a158 1

d160 1
a160 3
scsibusactivate(dev, act)
	struct device *dev;
	enum devact act;
d166 1
a166 3
scsibusdetach(dev, type)
	struct device *dev;
	int type;
d168 2
a169 2
	struct scsibus_softc *sb = (struct scsibus_softc *)dev;
	int i, error;
a183 2


d185 5
a189 7
scsibussubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct scsibus_attach_args *sa = aux;
	struct scsi_link *sc_link = sa->sa_sc_link;
d192 1
a192 1
		return 0;
d194 2
a195 1
		return 0;
d205 1
a205 2
scsi_probe_busses(bus, target, lun)
	int bus, target, lun;
a206 1

d211 1
a211 3
		return 0;
	} else {
		return scsi_probe_bus(bus, target, lun);
d213 2
d222 1
a222 2
scsi_probe_bus(bus, target, lun)
	int bus, target, lun;
d224 4
a227 4
	struct scsi_inquiry_data inqbuflun0;
	struct scsibus_softc *scsi;
	u_int16_t scsi_addr;
	int maxtarget, mintarget, maxlun, minlun;
d230 2
a231 1
		return ENXIO;
d233 1
a233 1
	if (!scsi)
d244 1
a244 1
			return EINVAL;
d253 1
a253 1
			return EINVAL;
d261 1
a261 1
	for (target = mintarget; target <= maxtarget; target++)
d263 1
a263 1
			bzero(&inqbuflun0, sizeof inqbuflun0);
d268 2
a269 1
			for (lun = minlun; lun <= maxlun; lun++)
d273 1
d275 1
d277 1
a277 1
	return 0;
d281 1
a281 3
scsi_strvis(dst, src, len)
	u_char *dst, *src;
	int len;
d283 1
a283 1
	u_char last;
d333 2
a334 2
	struct scsi_inquiry_pattern pattern;
	u_int16_t quirks;
d427 9
a435 11
scsibusprint(aux, pnp)
	void	*aux;
	const char *pnp;
{
	struct scsibus_attach_args *sa = aux;
	struct scsi_inquiry_data *inqbuf;
	u_int8_t type;
	boolean removable;
	char *dtype, *qtype;
	char vendor[33], product[65], revision[17];
	int target, lun;
d537 2
a538 4
scsi_probedev(scsi, inqbuflun0, target, lun)
	struct scsibus_softc *scsi;
	struct scsi_inquiry_data *inqbuflun0;
	int target, lun;
d540 2
a541 2
	struct scsi_link *sc_link;
	static struct scsi_inquiry_data inqbuf;
d543 3
a545 3
	int priority, rslt = 0;
	struct scsibus_attach_args sa;
	struct cfdata *cf;
d548 1
a548 1
	if (scsi->sc_link[target][lun])
d672 2
a673 1
	if ((cf = config_search(scsibussubmatch, (struct device *)scsi, &sa)) == 0) {
d722 6
a727 9
scsi_inqmatch(inqbuf, base, nmatches, matchsize, bestpriority)
	struct scsi_inquiry_data *inqbuf;
	const void *base;
	int nmatches, matchsize;
	int *bestpriority;
{
	u_int8_t type;
	boolean removable;
	const void *bestmatch;
@


1.102
log
@And the fallout from Manuel Pata's USB reader rumbles on ...

Fix the display of the device info for umass devices at lun 0 by
passing the correct inquiry data to config_attach. i.e. not the
inquiry data for lun 1, which we gratuitously probe to prevent USB
card readers from 'helpfully' lying about who is where, but the
inquiry data for lun 0 we have saved in sc_link->inqdata.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.101 2006/05/11 00:45:59 krw Exp $	*/
a57 15

#if 0
#if NCALS > 0
	{ T_PROCESSOR, T_FIXED, 1,
	  0, 0, 0 },
#endif	/* NCALS */
#if NBLL > 0
	{ T_PROCESSOR, T_FIXED, 1,
	  "AEG     ", "READER          ", "V1.0" },
#endif	/* NBLL */
#if NKIL > 0
	{ T_SCANNER, T_FIXED, 0,
	  "KODAK   ", "IL Scanner 900  ", 0 },
#endif	/* NKIL */
#endif
@


1.101
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.100 2006/01/21 12:18:49 miod Exp $	*/
d708 1
a708 1
	sa.sa_inqbuf = &inqbuf;
@


1.100
log
@Invoke disk_detach() and related cleanup work in detach(), rather than
zeroref() - just to be on the safe side, should we mess up our ref count.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.99 2006/01/18 19:54:49 krw Exp $	*/
d193 1
a193 1
int  
d208 1
a208 1
	
d323 1
a323 1
	while (len > 0 && (src[len-1] == ' ' || src[len-1] == '\t' || 
d672 1
a672 1
	    &inqbuf, scsi_quirk_patterns, 
d683 1
a683 1
		if ((inqbuf.flags & SID_Sync) != 0) 
d732 1
a732 1
	/* 
d736 1
a736 1
	 * INQUIRY may leave behind. 
@


1.99
log
@Don't index before the start of the sc_link array if scsi_probe_bus()
is called with a target of -1 and a valid lun. Spotted by Miod.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.98 2005/11/13 03:27:42 krw Exp $	*/
a91 1
void scsibuszeroref(struct device *);
d99 1
a99 1
	scsibusdetach, scsibusactivate, scsibuszeroref
d194 1
a194 1
scsibusdetach (dev, type)
d198 2
a199 2
	return (config_detach_children(dev, type));
}
d201 2
a202 6
void
scsibuszeroref(dev)
	struct device *dev;
{
	struct scsibus_softc *sb = (struct scsibus_softc *)dev;
	int i;
d210 2
@


1.98
log
@Use SCSI_DELAY only once. Document it. Default to no delay.

Fixes two second system 'freeze' when umass device plugged in. Speeds
up boot by not waiting for a minimum of 2 seconds at each scsi bus.

ok jmc@@ pedro@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.97 2005/10/10 20:06:12 krw Exp $	*/
d293 1
a293 1
		if (lun == 0 || scsi->sc_link[target][0] == NULL)
@


1.97
log
@Make some panic messages more useful.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.96 2005/06/03 15:24:05 krw Exp $	*/
a180 9

#if defined(SCSI_DELAY) && SCSI_DELAY > 2
	printf("%s: waiting for scsi devices to settle\n",
		sb->sc_dev.dv_xname);
#else	/* SCSI_DELAY > 2 */
#undef	SCSI_DELAY
#define SCSI_DELAY 2
#endif	/* SCSI_DELAY */
	delay(1000000 * SCSI_DELAY);
@


1.96
log
@Cache a copy of the INQUIRY data obtained during device attachment in
the scsi_link structure. This is a more general solution than the
current inconsistant copying of fields into _softc structures. The
redundant fields in _softc's will be cleaned up later. The device
field will be used immediately to finish up the new mode sense code.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.95 2005/05/07 16:24:46 krw Exp $	*/
d510 2
d513 1
a513 1
		panic("scsibusprint: impossible qualifier");
d559 1
a559 1
			panic("scsibusprint: impossible device type");
@


1.95
log
@Eliminate 'mode sense (n) returned nonsense' and 'could not mode sense
(4/5)' messages in favour of a single SC_DEBUG() message about the mode
sense error. Less useless verbiage.

As this eliminates the only SDEV_NOMODESENSE use in scsi/*, eliminate
all quirks table entries that used only SDEV_NOMODESENSE. Iomega Zip
tested by miod@@ to ensure this did not break something.

Finally, only fake a geometry if scsi_size() can determine a disk size
to fake from.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.94 2005/04/28 00:12:55 krw Exp $	*/
d709 1
@


1.94
log
@Some really braindead usb devices such as x-in-1 card reader/writers
try to help equally braindead os's by presenting any inserted media as
LUN 0 until another LUN is used in a command. Trick them by issuing a
gratuitous/harmless INQUIRY to LUN 1 after issuing the LUN 0 INQUIRY
but before any other command. Only umass scsi devices with >1 lun are
affected.

Fixes dlg's reader/writer for one.

Lots of diagnosis and testing by dlg@@, ok dlg@@, ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.93 2005/04/27 23:54:44 krw Exp $	*/
a386 10
	{{T_OPTICAL, T_REMOV,
	 "FUJITSU", "M2513A",            "0800"}, SDEV_NOMODESENSE},
	{{T_OPTICAL, T_REMOV,
	 "DELTIS  ", "MOS321          ", "3.30"}, SDEV_NOMODESENSE},
 
	{{T_OPTICAL, T_REMOV,
	 "FUJITSU", "M2513A",            "0800"}, SDEV_NOMODESENSE},
	{{T_OPTICAL, T_REMOV,
	 "DELTIS  ", "MOS321          ", "3.30"}, SDEV_NOMODESENSE},

a407 4
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST19171FC",	 ""},	  SDEV_NOMODESENSE},
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST34501FC       ", ""},     SDEV_NOMODESENSE},
d409 1
a409 7
	 "iomega", "jaz 1GB",		 ""},	  SDEV_NOMODESENSE|SDEV_NOTAGS},
	{{T_DIRECT, T_REMOV,
	 "IOMEGA", "ZIP 100",		 ""},	  SDEV_NOMODESENSE},
	{{T_DIRECT, T_REMOV,
	 "IOMEGA", "ZIP 250",		 ""},	  SDEV_NOMODESENSE},
	{{T_DIRECT, T_FIXED,
	 "IBM", "0661467",               "G"},    SDEV_NOMODESENSE},
@


1.93
log
@Add SDEV_UMASS flag, analogous to SDEV_ATAPI, and use it to force a
full LUN scan on UMASS SCSI targets. UMASS provides reliable max lun
information so we shouldn't waste time. Fixes many x-in-1 card
reader/writers that report identical INQUIRY information for every
slot they provide.

Lots of diagnosis and testing by dlg@@, ok dlg@@, 'I can live with this'
marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.92 2004/07/31 11:31:30 krw Exp $	*/
d743 14
@


1.92
log
@Remove scsi_change_def() and related command structure. Its only use
in the tree is #ifdef'd out and is fundamentally wrong anyway - it
tries to force *all* devices to SCSI-2. Also recent SCSI specs seem to
have marked the command as obsolete. Bonus - eliminates another
undocumented option (SCSI_2_DEF).

Found in a list of unused kernel functions posted to tech-kern@@netbsd
by Krister Walfridsson in 2002.

ok marco@@ tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.91 2004/05/09 14:08:11 krw Exp $	*/
d691 3
a693 1
		    ;
@


1.91
log
@Remove some #ifndef __OpenBSD__/#endif sections that were intended to
make sync'ing with NetBSD easier. NetBSD has moved on, most of these
sections have not.

ok marco@@ deraadt@@ grange@@ csapuntz@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.90 2004/05/07 22:56:19 krw Exp $	*/
a656 6

#ifdef SCSI_2_DEF
	/* Some devices need to be told to go to SCSI2. */
	/* However some just explode if you tell them this... leave it out. */
	scsi_change_def(sc_link, scsi_autoconf | SCSI_SILENT);
#endif /* SCSI_2_DEF */
@


1.90
log
@Set value for rslt before trying to display it. 'Bad LUN ...' messsage
will now display correct error value.

Spotted in SCSIDEBUG output from Adrian Close's bizarre USB device.

ok millert@@ deraadt@@ marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.89 2004/05/07 18:13:31 miod Exp $	*/
a123 4
#ifndef __OpenBSD__
	struct scsi_link *l = aux;
#endif

a127 5
#ifndef __OpenBSD__
	/* don't print channel if the controller says there can be only one. */
	if (l->channel != SCSI_CHANNEL_ONLY_ONE)
		printf(" channel %d", l->channel);
#endif
@


1.89
log
@Remove mvme88k workaround for ssh(4) bugs.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.88 2004/04/18 00:49:29 krw Exp $	*/
d674 2
a675 1
	if (scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT) != 0) {
@


1.88
log
@Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok marco@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.87 2004/03/10 01:37:40 krw Exp $	*/
d658 1
a658 1
#if defined(mvme68k) || defined(mvme88k)
@


1.87
log
@Simplify new LUN scanning logic, add diagnostic messages for all
instances of bad LUNs and add SCSIFORCELUN_BUSES and
SCSIFORCELUN_TARGETS options.

ok miod@@ deraadt@@. Tested in the Marco Peereboom torture chamber.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.86 2004/02/21 00:47:42 krw Exp $	*/
a636 1
	sc_link->inquiry_flags2 = 0;
a740 1
	sc_link->inquiry_flags2 = inqbuf.flags2;
@


1.87.2.1
log
@MFC:
Fix by krw@@

Restore siop's (and possibly others) ability to negotiate tags/wide/sync by
reverting to a single (short) INQUIRY command during probe. Compensate in siop
by trying PPR on all targets on SCSI-3 buses and falling back to WDTR/SDTR if
PPR rejected.

Problem found by mickey@@. Tested on a wide variety of devices by Marco.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.87 2004/03/10 01:37:40 krw Exp $	*/
d637 1
d742 1
@


1.86
log
@Eliminate the quirks SDEV_NOSTARTUNIT, UMASS_QUIRK_NO_START_STOP, and
UMASS_QUIRK_FORCE_SHORT_INQUIRY. Fixes a bunch of USB devices. Based
on work by Mycroft in NetBSD.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.85 2004/02/07 22:39:16 krw Exp $	*/
d112 3
d620 1
a620 1
	int priority, rslt;
d675 4
a678 18
	rslt = scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT);

	if (lun == 0 && rslt != 0) {
		/* A bad LUN 0 INQUIRY means no further LUNs possible. */
		SC_DEBUG(sc_link, SDEV_DB2, ("No LUN 0. rslt == %i\n", rslt));
		rslt = EINVAL;
		goto bad;
	} else if (rslt != 0) {
		/* Just a failed LUN INQUIRY, try the next LUN. */
		SC_DEBUG(sc_link, SDEV_DB2, ("Bad LUN. rslt == %i\n", rslt));
		rslt = 0;
		goto bad;
	} else if (lun == 0) {
		bcopy(&inqbuf, inqbuflun0, sizeof *inqbuflun0);
	} else if (memcmp(&inqbuf, inqbuflun0, sizeof inqbuf) == 0) {
		/* The device can't distinguish between LUNs. */
		SC_DEBUG(sc_link, SDEV_DB1, ("IDENTIFY not supported.\n"));
		rslt = EINVAL;
d691 3
a693 1
		if ((inqbuf.device & SID_TYPE) == T_NODEVICE)
d695 1
d700 12
@


1.85
log
@If scsi_probe_bus() is called with a particular lun, ensure that lun 0
information is available to make the new lun validation logic work.
i.e. don't find phantom luns just because the user asks about them.

Also ensure the lun value given does not exceed the maximum valid lun
for a bus, rather than assuming the maximum valid lun is 7.

ok tdeval@@ deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.84 2004/01/30 23:07:36 tdeval Exp $	*/
a408 5
	/* Gives non-media hardware failure in response to start-unit command */
	{{T_DIRECT, T_FIXED,
	 "HITACHI", "DK515C",            "CP15"}, SDEV_NOSTARTUNIT},
	{{T_DIRECT, T_FIXED,
	 "HITACHI", "DK515C",            "CP16"}, SDEV_NOSTARTUNIT},
a435 3
	/* Letting the motor run kills floppy drives and disks quit fast. */
	{{T_DIRECT, T_REMOV,
	 "TEAC", "FC-1",                 ""},     SDEV_NOSTARTUNIT},
a456 4
        {{T_CDROM, T_REMOV,
         "BCD-16X", "", ""},                    SDEV_NOSTARTUNIT},
        {{T_CDROM, T_REMOV,
         "BCD-24X", "", ""},                    SDEV_NOSTARTUNIT},
@


1.84
log
@Backout until we have a better implementation...
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.81 2004/01/25 00:09:20 krw Exp $	*/
d305 1
a305 1
		if (lun < 0 || lun > 7)
d307 5
a311 1
		maxlun = minlun = lun;
d317 4
a683 7
	bzero(&inqbuf, sizeof(inqbuf));

	memset(&inqbuf.vendor, ' ', sizeof inqbuf.vendor);
	memset(&inqbuf.product, ' ', sizeof inqbuf.product);
	memset(&inqbuf.revision, ' ', sizeof inqbuf.revision);
	memset(&inqbuf.extra, ' ', sizeof inqbuf.extra);

@


1.83
log
@"And you definitely don't want to use p_priority. Use PRIBIO"
From art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.82 2004/01/29 12:47:18 tdeval Exp $	*/
d50 1
a53 2
#include <sys/kernel.h>
#include <sys/proc.h>
d195 1
a195 4
	if (cold)
		delay(1000000 * SCSI_DELAY);
	else
		tsleep(sb, PRIBIO, NULL, SCSI_DELAY * hz);
@


1.82
log
@Avoid an annoying freeze during attach of live "scsibus" devices.
looks ok deraadt@@, mickey@@, krw@@ and art@@(but I hate it)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.81 2004/01/25 00:09:20 krw Exp $	*/
d199 1
a199 1
		tsleep(sb, curproc->p_priority, NULL, SCSI_DELAY * hz);
@


1.81
log
@Allow restriction of SCSIDEBUG output to particular scsi buses in
addition to device targets and luns.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.80 2004/01/24 22:01:46 deraadt Exp $	*/
a49 1
#include <sys/types.h>
d53 2
d196 4
a199 1
	delay(1000000 * SCSI_DELAY);
@


1.80
log
@ugly #ifdef to be deleted later
must still do TUR on mvme68k & mvme88k ssh(4) driver
ok miod krw
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.79 2004/01/23 02:44:21 krw Exp $	*/
d107 1
d654 2
a655 1
	if (((1 << target) & scsidebug_targets) &&
@


1.79
log
@Don't probe impossible luns. If lun 0 is non-existant, or if the device shows
it doesn't grok luns then stop probing.

Speeds up the probe of an empty scsi bus by approx. 30 seconds.

From Marco Peereboom.

Tested by Marco Peereboom, millert@@, miod@@, Diana Eichart, and a host of
anonymous snapshot users.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.78 2004/01/17 13:56:56 krw Exp $	*/
d657 9
@


1.78
log
@Use SC_DEBUG() to display debug messages. Makes SCSIDEBUG output better.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.77 2004/01/14 02:00:41 krw Exp $	*/
d77 1
a77 1
void scsi_probedev(struct scsibus_softc *, struct scsi_inquiry_data *, int,
d313 3
a315 1
				scsi_probedev(scsi, &inqbuflun0, target, lun);
d606 4
a609 3
 * given a target and lu, ask the device what
 * it is, and find the correct driver table
 * entry.
d611 1
a611 1
void
d620 1
a620 1
	int priority;
d624 1
a624 1
	/* Skip this slot if it is already attached. */
d626 1
a626 1
		return;
d630 2
a631 1
		return;
d639 2
d642 4
a645 5
	 * Tell drivers that are paying attention to avoid
	 * sync/wide/tags until INQUIRY data and quirks information
	 * are available. Since bits in quirks may have already been
	 * set by some drivers (e.g. NOLUNS for atapiscsi), just add
	 * NOTAGS, NOWIDE and NOSYNC.
d672 11
a682 1
	if (scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT) != 0)
d684 1
a684 8

	if (lun == 0) {
		/*
		 * Save the INQUIRY page of LUN 0 to compare to the remaining
		 * LUN's.  If the INQUIRY data is the same as LUN 0 it *is* LUN
		 * 0 and threfore we can safely ignore it. This is to cover
		 * stupid SCSI devices that don't handle the IDENTIFY message.
		*/
d686 5
a690 10
	} else {
		if (memcmp(&inqbuf, inqbuflun0, sizeof inqbuf) == 0) {
			/*
			 * Stupid SCSI device that does not handle the IDENTIFY
			 * message. Mark this LUN as not there.
			 */
			SC_DEBUG(sc_link, SDEV_DB1,
			    ("IDENTIFY not supported.\n"));
			goto bad;
		}
d758 7
a764 5
	 * Generate another TEST_UNIT_READY command. This gives
	 * drivers waiting for valid quirks data a chance to set
	 * wide/sync/tag options appropriately. Do this now so that
	 * any messages generated by config_attach() do not have
	 * negotiation messages inserted into their midst.
d766 3
a768 2
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
d772 1
a772 1
	return;
d776 1
a776 1
	return;
@


1.77
log
@Nuke SDEV_NOLUNS, SDEV_FORCELUNS, and PQUIRK_FORCELUNS quirks. Also
moreluns field in scsi_link structure.  Instead, treat an INQUIRY
result that duplicates the INQUIRY result of LUN 0 as proof the LUN
does not exist.  Compensate for lack of SDEV_NOLUNS where necessary by
setting sc_link->luns to 1, which has the same effect. From Marco
Peereboom.

Don't issue Test Unit Ready command before INQUIRY command - not
necessary and potentially harmful to devices with ADEV_NOTUR quirk
since quirks have not been set yet. From mycroft@@NetBSD

ok deraadt@@, mvme* changes by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.76 2004/01/07 18:11:16 krw Exp $	*/
d684 2
a685 4
#ifdef SCSIDEBUG
			scsibusprint(&sa, scsi->sc_dev.dv_xname);
			printf(" doesn't support IDENTIFY message.\n");
#endif	/* SCSIDEBUG */
d694 2
a695 4
#ifdef	SCSIDEBUG
		scsibusprint(&sa, scsi->sc_dev.dv_xname);
		printf(" Residue in PERIPHERAL QUALIFIER; invalid LUN.\n");
#endif	/* SCSIDEBUG */
@


1.76
log
@Some code cleanup and fixes inspired by NetBSD changes from mycroft@@
and pointed out by Nate@@. Fixes some <, , > displays for devices that
were not filling the INQUIRY data in correctly. Silences INQUIRY
commands that fail during probe. Treats SID_QUAL_LU_OFFLINE results
the same as SID_QUAL_BAD_LU. Eliminate special treatment for DEC TK30
and DEC TK50 devices.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.75 2003/10/27 03:08:58 mickey Exp $	*/
d77 2
a78 1
void scsi_probedev(struct scsibus_softc *, int, int);
d277 1
d279 1
a280 1
	u_int16_t scsi_addr;
d309 5
a313 11
	for (target = mintarget; target <= maxtarget; target++) {
		if (target == scsi_addr)
			continue;
		for (lun = minlun; lun <= maxlun; lun++) {
			/*
			 * See if there's a device present, and configure it.
			 */
			scsi_probedev(scsi, target, lun);
			if ((scsi->moreluns & (1 << target)) == 0)
				break;
			/* otherwise something says we should look further */
d315 1
a315 1
	}
a379 60
	 "CHINON  ", "CD-ROM CDS-431  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "Chinon  ", "CD-ROM CDS-525  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "CHINON  ", "CD-ROM CDS-535  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "DEC     ", "RRD42   (C) DEC ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "DENON   ", "DRD-25X         ", "V"},    SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "HP      ", "C4324/C4325     ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "IMS     ", "CDD521/10       ", "2.06"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "MATSHITA", "CD-ROM CR-5XX   ", "1.0b"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "MEDAVIS ", "RENO CD-ROMX2A  ", ""},	  SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "MEDIAVIS", "CDR-H93MV       ", "1.3"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:55 ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:83 ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:84 ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:210", "1.0"},  SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:501", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:841", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "PIONEER ", "CD-ROM DR-124X  ", "1.01"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-541  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-55S  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-561  ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-8003A", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-8012 ", ""},     SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "TEAC    ", "CD-ROM          ", "1.06"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "TEAC    ", "CD-ROM CD-56S   ", "1.0B"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "TEXEL   ", "CD-ROM          ", "1.06"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "TEXEL   ", "CD-ROM DM-XX24 K", "1.10"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "TOSHIBA ", "XM-4101TASUNSLCD", "1755"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,  
	 "ShinaKen", "CD-ROM DM-3x1S", "1.04"},   SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "JVC     ", "R2626           ", "1.55"}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
	 "CyberDrv", "", ""}, SDEV_NOLUNS},
	{{T_CDROM, T_REMOV,
a381 2
 	{{T_OPTICAL, T_REMOV,
 	 "EPSON   ", "OMD-5010        ", "3.08"}, SDEV_NOLUNS},
a387 2
	 "EPSON   ", "OMD-5010        ", "3.08"}, SDEV_NOLUNS},
	{{T_OPTICAL, T_REMOV,
d397 1
a397 1
	 "EMULEX  ", "MD21/S2     ESDI", "A00"},  SDEV_FORCELUNS|SDEV_AUTOSAVE},
d410 1
a410 1
	 "IBM     ", "H3171-S2",         ""},	  SDEV_NOLUNS|SDEV_AUTOSAVE},
a416 20
	 "MAXTOR  ", "XT-3280         ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-4380S        ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "MXT-1240S       ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-4170S        ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-8760S",	 ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "LXT-213S        ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "LXT-213S SUN0207", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "LXT-200S        ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "MST     ", "SnapLink        ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "NEC     ", "D3847           ", "0307"}, SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
a418 18
	 "QUANTUM ", "LPS525S         ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "QUANTUM ", "P105S 910-10-94x", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "QUANTUM ", "PD1225S         ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "QUANTUM ", "PD210S   SUN0207", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "RODIME  ", "RO3000S         ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST125N          ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST157N          ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST296           ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST296N          ", ""},     SDEV_NOLUNS},
	{{T_DIRECT, T_FIXED,
a421 2
        {{T_DIRECT, T_FIXED,
	 "TOSHIBA ", "MK538FB         ", "6027"}, SDEV_NOLUNS},
a432 2
	{{T_DIRECT, T_FIXED,
	 "NEC ", "SD120S-200      ",	 "0001"}, SDEV_NOLUNS},
a441 13
	/* XXX: QIC-36 tape behind Emulex adapter.  Very broken. */
	{{T_SEQUENTIAL, T_REMOV,
	 "        ", "                ", "    "}, SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "CALIPER ", "CP150           ", ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "DEC     ", "TZ30            ", ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "DEC     ", "TK50            ", ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "SONY    ", "SDT-2000        ", "2.09"}, SDEV_NOLUNS},
a444 16
	 "SONY    ", "SDT-5200        ", "3."},   SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "TANDBERG", " TDC 3600       ", ""},     SDEV_NOLUNS},
	/* Following entry reported as a Tandberg 3600; ref. PR1933 */
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 150  21247", ""},     SDEV_NOLUNS},
	/* Following entry for a Cipher ST150S */
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 1500 21247", "2.2G"}, SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "Python 28454-XXX", ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5099ES SCSI",      ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI",      ""},     SDEV_NOLUNS},
	{{T_SEQUENTIAL, T_REMOV,
a450 12
	{{T_SCANNER, T_FIXED,
	 "RICOH   ", "IS60            ", "1R08"}, SDEV_NOLUNS},
	{{T_SCANNER, T_FIXED,
	 "UMAX    ", "Astra 1200S     ", "V2.9"}, SDEV_NOLUNS},
	{{T_SCANNER, T_FIXED,
	 "ULTIMA  ", "AT3     1.60    ", ""},     SDEV_NOLUNS},
	{{T_SCANNER, T_FIXED,
	 "UMAX    ", "SuperVista S-12 ", "V1.9"}, SDEV_NOLUNS},

	{{T_ENCLOSURE, T_FIXED,
	 "SUN     ", "SENA", ""},                 SDEV_NOLUNS},

d609 1
a609 1
scsi_probedev(scsi, target, lun)
d611 1
a652 3
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);

d670 22
d696 4
a732 3
	if ((inqbuf.version & SID_ANSII) == 0 &&
	    (sc_link->quirks & SDEV_FORCELUNS) == 0)
		sc_link->quirks |= SDEV_NOLUNS;
a733 3

	if ((sc_link->quirks & SDEV_NOLUNS) == 0)
		scsi->moreluns |= (1 << target);
@


1.75
log
@atlas does indeed support tagging and only the siop was broken
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.74 2003/09/30 02:24:44 mickey Exp $	*/
d767 1
a767 1
	int checkdtype, priority;
d814 13
a826 1
	if (scsi_inquire(sc_link, &inqbuf, scsi_autoconf) != 0)
d829 7
a835 15
	{
		int len = inqbuf.additional_length;
		while (len < 3)
			inqbuf.unused[len++] = '\0';
		while (len < 3 + 28)
			inqbuf.unused[len++] = ' ';
		if (inqbuf.additional_length == 0) {
			if (inqbuf.dev_qual2 == 0xb0) {
				strncpy(inqbuf.unused+3, "DEC", 3);
				strncpy(inqbuf.unused+11, "TZ30", 4);
			} else if (inqbuf.dev_qual2 == 0xd0) {
				strncpy(inqbuf.unused+3, "DEC", 3);
				strncpy(inqbuf.unused+11, "TK50", 4);
			}
		}
a878 39

	/*
	 * Any device qualifier that has the top bit set (qualifier&4 != 0)
	 * is vendor specific and won't match in this switch.
	 * All we do here is throw out bad/negative responses.
	 */
	checkdtype = 0;
	switch (inqbuf.device & SID_QUAL) {
	case SID_QUAL_LU_OK:
	case SID_QUAL_LU_OFFLINE:
		checkdtype = 1;
		break;

	case SID_QUAL_RSVD:
	case SID_QUAL_BAD_LU:
		goto bad;

	default:
		break;
	}
	if (checkdtype) {
		switch (inqbuf.device & SID_TYPE) {
		case T_DIRECT:
		case T_SEQUENTIAL:
		case T_PRINTER:
		case T_PROCESSOR:
		case T_CDROM:
		case T_WORM:
		case T_SCANNER:
		case T_OPTICAL:
		case T_CHANGER:
		case T_COMM:
		case T_RDIRECT:
		default:
			break;
		case T_NODEVICE:
			goto bad;
		}
	}
@


1.74
log
@quantum atlas iv 9 wls lies about tags
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.73 2003/05/18 16:06:35 mickey Exp $	*/
a503 2
	{{T_DIRECT, T_FIXED,
	 "QUANTUM ", "ATLAS IV 9 WLS",   ""},	  SDEV_NOTAGS},
@


1.73
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.72 2003/05/17 06:08:39 nate Exp $	*/
d504 2
@


1.72
log
@dale's camera has a usb quirk now
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.71 2003/05/16 19:54:05 krw Exp $	*/
d382 1
a382 1
struct scsi_quirk_inquiry_pattern scsi_quirk_patterns[] = {
d766 1
a766 1
	struct scsi_quirk_inquiry_pattern *finger;
d834 2
a835 2
	finger = (struct scsi_quirk_inquiry_pattern *)scsi_inqmatch(&inqbuf,
	    (caddr_t)scsi_quirk_patterns, 
d949 1
a949 1
caddr_t
d952 1
a952 1
	caddr_t base;
d958 1
a958 1
	caddr_t bestmatch;
@


1.71
log
@Provide most if not all the support required for the usb changes Nate
is trying to bring in.

1) Change name of SDEV_NOCDB6 to SDEV_ONLYBIG to align it with the
same quirk in NetBSD, and make it more clear what it is trying to do.
i.e. force the use of READ_BIG/WRITE_BIG commands, not suppress all
use of 6 byte CDB's.

2) Check SDEV_ONLYBIG in cd.c as well as sd.c. i.e. both places where
a choice is made to use the 6 or 10 byte versions of READ/WRITE.

3) Actually make use of the ADEV_NOTUR (No TEST UNIT READY) quirk to
suppress the emission of TEST UNIT READY commands.

4) Add some explanatory comments from NetBSD to scsiconf.h so that the
use of the quirks is made clear.

ok miod@@ tdeval@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.70 2002/12/30 21:50:28 grange Exp $	*/
a503 2
	{{T_DIRECT, T_REMOV,
	 "OLYMPUS ", "C-", ""}, SDEV_ONLYBIG|SDEV_NOSYNCCACHE},
@


1.70
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.69 2002/09/04 23:11:10 tdeval Exp $	*/
d505 1
a505 1
	 "OLYMPUS ", "C-", ""}, SDEV_NOCDB6|SDEV_NOSYNCCACHE},
@


1.69
log
@Write sentences.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.68 2002/09/04 23:07:28 tdeval Exp $	*/
d805 1
a805 1
	(void) scsi_test_unit_ready(sc_link,
d935 1
a935 1
	(void) scsi_test_unit_ready(sc_link,
@


1.68
log
@Add support for RBC (simplified direct) devices.
ok costa@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.67 2002/03/14 01:27:13 millert Exp $	*/
d809 2
a810 2
	/* some devices need to be told to go to SCSI2 */
	/* However some just explode if you tell them this.. leave it out */
@


1.67
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.66 2002/03/09 23:37:09 krw Exp $	*/
d733 3
d909 1
@


1.66
log
@Be less parochial and remember that others may need to use quirks!

Just set the SDEV_NOTAGS, SDEV_NOWIDE, SDEV_NOSYNC bits in
quirks. DON'T zero all other bits that may have already been set.

Noted (and fix tested) by lebel@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.65 2002/02/28 00:02:48 krw Exp $	*/
d77 2
a78 2
void scsi_probedev __P((struct scsibus_softc *, int, int));
int scsi_probe_bus __P((int bus, int target, int lun));
d87 5
a91 5
int scsibusmatch __P((struct device *, void *, void *));
void scsibusattach __P((struct device *, struct device *, void *));
int  scsibusactivate __P((struct device *, enum devact));
int  scsibusdetach __P((struct device *, int));
void scsibuszeroref __P((struct device *));
d93 1
a93 1
int scsibussubmatch __P((struct device *, void *, void *));
d112 1
a112 1
int scsibusprint __P((void *, const char *));
@


1.65
log
@Start quirks off with NOWIDE, NOSYNC and NOTAGS and remove the
restrictions as the results of the INQUIRY command and the quirks
table indicate.

This should (for drivers that pay attention) make for more successful
communication with devices having quirks, by using the lowest common
denominator until more information is available.

Issue a second TEST_UNIT_READY command after the INQUIRY command has
been processed to allow drivers waiting for valid quirks data to set
sync/wide/tags asap. Rework a little bit of the logic to ensure that
negotiation messages produced by the TEST_UNIT_READY command do not
get mixed up with attachment messages. This has the side benefit of
putting the negotiation messages before the device description, where
they have usually been displayed in the past.

If a driver is examining and using quirks data before the INQUIRY
command is processed, and not renegotiating after the INQUIRY command,
it may now end up with async 8 bit, non-tagged transfers. Before it
would have ended up with possibly unusable transfer parameters when
talking to a device with quirks.

ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.64 2002/02/16 17:20:27 millert Exp $	*/
d787 3
a789 1
	 * are available.
d791 1
a791 1
	sc_link->quirks = SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;
@


1.64
log
@Disable tagged queueing for HP C3725S and IBM DCAS drives where
is is broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.63 2001/11/02 00:08:16 millert Exp $	*/
d785 7
d838 1
a838 1
	 * at SCSI-2 or better, set some limiting quirks.
d841 6
a846 6
		if ((inqbuf.flags & SID_CmdQue) == 0)
			sc_link->quirks |= SDEV_NOTAGS;
		if ((inqbuf.flags & SID_Sync) == 0) 
			sc_link->quirks |= SDEV_NOSYNC;
		if ((inqbuf.flags & SID_WBus16) == 0)
			sc_link->quirks |= SDEV_NOWIDE;
d914 1
a914 4
	if ((cf = config_search(scsibussubmatch, (struct device *)scsi, &sa)) != 0) {
		scsi->sc_link[target][lun] = sc_link;
		config_attach((struct device *)scsi, cf, &sa, scsibusprint);
	} else {
d919 14
@


1.63
log
@In scsi_strvis(), collapse adjacent whitespace/NUL chars to a single
space to get the most info with the least amount of wasted space.
OK krw@@, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.62 2001/10/08 01:50:48 drahn Exp $	*/
d549 4
@


1.63.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.63 2001/11/02 00:08:16 millert Exp $	*/
d77 2
a78 2
void scsi_probedev(struct scsibus_softc *, int, int);
int scsi_probe_bus(int bus, int target, int lun);
d87 5
a91 5
int scsibusmatch(struct device *, void *, void *);
void scsibusattach(struct device *, struct device *, void *);
int  scsibusactivate(struct device *, enum devact);
int  scsibusdetach(struct device *, int);
void scsibuszeroref(struct device *);
d93 1
a93 1
int scsibussubmatch(struct device *, void *, void *);
d112 1
a112 1
int scsibusprint(void *, const char *);
a548 4
        {{T_DIRECT, T_FIXED,
         "HP", "C3725S",		 ""},     SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "IBM", "DCAS",			 ""},     SDEV_NOTAGS},
a780 9
	 * Tell drivers that are paying attention to avoid
	 * sync/wide/tags until INQUIRY data and quirks information
	 * are available. Since bits in quirks may have already been
	 * set by some drivers (e.g. NOLUNS for atapiscsi), just add
	 * NOTAGS, NOWIDE and NOSYNC.
	 */
	sc_link->quirks |= SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;

	/*
d827 1
a827 1
	 * at SCSI-2 or better, remove some limiting quirks.
d830 6
a835 6
		if ((inqbuf.flags & SID_CmdQue) != 0)
			sc_link->quirks &= ~SDEV_NOTAGS;
		if ((inqbuf.flags & SID_Sync) != 0) 
			sc_link->quirks &= ~SDEV_NOSYNC;
		if ((inqbuf.flags & SID_WBus16) != 0)
			sc_link->quirks &= ~SDEV_NOWIDE;
d903 4
a906 1
	if ((cf = config_search(scsibussubmatch, (struct device *)scsi, &sa)) == 0) {
a910 14

	scsi->sc_link[target][lun] = sc_link;

	/* 
	 * Generate another TEST_UNIT_READY command. This gives
	 * drivers waiting for valid quirks data a chance to set
	 * wide/sync/tag options appropriately. Do this now so that
	 * any messages generated by config_attach() do not have
	 * negotiation messages inserted into their midst.
	 */
	(void) scsi_test_unit_ready(sc_link,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);

	config_attach((struct device *)scsi, cf, &sa, scsibusprint);
@


1.63.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.63.2.1 2002/06/11 03:32:13 art Exp $	*/
a732 3
		case T_RDIRECT:
			dtype = "simplified direct";
			break;
d806 2
a807 2
	/* Some devices need to be told to go to SCSI2. */
	/* However some just explode if you tell them this... leave it out. */
a905 1
		case T_RDIRECT:
@


1.63.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d504 2
d805 1
a805 1
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d935 1
a935 1
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
@


1.62
log
@Add a new quirk type, SDEV_NOCDB6, some USB devices like ATAPI
do not support 6 byte CDBs.
This quirk is used for OLYMPUS USB cameras.
Loosely based on code in FreeBSD.
ok costa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.61 2001/08/26 22:35:03 millert Exp $	*/
d328 1
d330 3
a332 2
	/* Trim leading and trailing blanks and NULs. */
	while (len > 0 && (src[0] == ' ' || src[0] == '\0' || src[0] == 0xff))
d334 2
a335 2
	while (len > 0 && (src[len-1] == ' ' || src[len-1] == '\0' ||
	    src[len-1] == 0xff))
d338 1
d340 12
a351 7
		if (*src < 0x20 || *src >= 0x80) {
			/* non-printable characters */
			*dst++ = '\\';
			*dst++ = ((*src & 0300) >> 6) + '0';
			*dst++ = ((*src & 0070) >> 3) + '0';
			*dst++ = ((*src & 0007) >> 0) + '0';
		} else if (*src == '\\') {
d355 15
a369 3
		} else {
			/* normal characters */
			*dst++ = *src;
@


1.61
log
@Don't restrict MICROP 4421-07 quirk to a specific firmware revision
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.60 2001/08/25 19:29:16 fgsch Exp $	*/
d484 2
@


1.60
log
@Change scsi_[free|get]_xs to use pool(9); art@@ krw@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.59 2001/08/18 02:24:02 krw Exp $	*/
d524 1
a524 1
         "MICROP", "4421-07   0329SJ",   ""},     SDEV_NOTAGS},
@


1.59
log
@Make siop pay attention to quirks table. This not only eliminates the
ugly INQUIRY snooping but avoids adding even uglier #ifdef's to turn
off stuff, e.g. tagged queuing.

Add two disk drives now known to lie about supporting tagged queuing
to quirks table. One from millert@@ (<MICROP, 4421-07 0329SJ, 0329>)
and one from Hakan Olsson (<SEAGATE, ST150176LW, 0002>).

Add field 'inquiry_flags2' to struct scsi_link to hold flags2 field
from struct scsi_inquiry_data. These flags relate to SCSI-3 specific
features.

Clean up some logic, eliminating need for TARF_PPR flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.58 2001/06/24 21:29:04 mickey Exp $	*/
d169 3
@


1.58
log
@cold is in systm now
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.57 2001/06/22 14:35:43 deraadt Exp $	*/
d520 4
d753 1
d829 1
@


1.57
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.56 2001/05/24 04:13:16 angelos Exp $	*/
a155 1
	extern int cold;
@


1.56
log
@Check malloc() return value, from tedu@@heorot.stanford.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.55 2001/01/22 19:11:48 csapuntz Exp $	*/
d137 2
a138 2
        struct device *parent;
        void *match, *aux;
d150 2
a151 2
        struct device *parent, *self;
        void *aux;
d622 1
a622 1
	void       *aux;
d638 2
a639 2
        target = sa->sa_sc_link->target;
        lun = sa->sa_sc_link->lun;
d641 2
a642 2
        type = inqbuf->device & SID_TYPE;
        removable = inqbuf->dev_qual2 & SID_REMOVABLE ? 1 : 0;
d709 8
a716 8
        scsi_strvis(vendor, inqbuf->vendor, 8);
        scsi_strvis(product, inqbuf->product, 16);
        scsi_strvis(revision, inqbuf->revision, 4);

        printf(" targ %d lun %d: <%s, %s, %s> SCSI%d %d/%s %s%s",
            target, lun, vendor, product, revision,
            inqbuf->version & SID_ANSII, type, dtype,
            removable ? "removable" : "fixed", qtype);
@


1.55
log
@

ATAPI CD-ROMs BCD-16X and BCD-24X have troubles starting and stopping their disks
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.54 2000/11/23 08:55:35 deraadt Exp $	*/
d743 2
@


1.54
log
@fix lun support, not as nice as i would like
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.53 2000/11/20 07:34:51 deraadt Exp $	*/
d576 1
a576 1
         "BCD-16X 1997-04-25", "", "VER 2.2"},  SDEV_NOSTARTUNIT},
d578 1
a578 1
         "BCD-24X 1997-06-27", "", "VER 2.0"},  SDEV_NOSTARTUNIT},
@


1.53
log
@limit luns on usb
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.52 2000/04/18 05:53:17 csapuntz Exp $	*/
d166 2
d297 1
a297 1
		maxlun = scsi->adapter_link->maxlun;
a814 1
	sc_link->maxlun = 7;
@


1.52
log
@

sd and scsibus detach

cdlock/cdunlock now through disk_lock/disk_unlock
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.51 2000/04/08 19:19:33 csapuntz Exp $	*/
d295 1
a295 1
		maxlun = 7;
d813 1
@


1.51
log
@

These days, attach can occur outside the tsleep-restricted world of
BSD autoconf.

Don't use POLL & NOSLEEP mode if attaching after autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.50 2000/02/21 08:21:22 mjacob Exp $	*/
d89 4
d95 2
d98 2
a99 1
	sizeof(struct scsibus_softc), scsibusmatch, scsibusattach
d193 34
@


1.50
log
@add T_ENCLOSURE name and NOLUN Photon SENA devices
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.49 1999/12/31 20:24:05 millert Exp $	*/
d103 2
d149 4
d716 1
a716 1
	    SCSI_AUTOCONF | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
d721 1
a721 1
	scsi_change_def(sc_link, SCSI_AUTOCONF | SCSI_SILENT);
d726 1
a726 1
	if (scsi_inquire(sc_link, &inqbuf, SCSI_AUTOCONF) != 0)
@


1.49
log
@Add SDEV_NOLUNS quirk for NEC CD-ROM DRIVE:501
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.48 1999/12/16 05:17:36 mjacob Exp $	*/
d520 3
d648 3
@


1.49.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.50 2000/02/21 08:21:22 mjacob Exp $	*/
a519 3
	{{T_ENCLOSURE, T_FIXED,
	 "SUN     ", "SENA", ""},                 SDEV_NOLUNS},

a644 3
			break;
		case T_ENCLOSURE:
			dtype = "enclosure services";
@


1.49.2.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.55 2001/01/22 19:11:48 csapuntz Exp $	*/
a88 4
int  scsibusactivate __P((struct device *, enum devact));
int  scsibusdetach __P((struct device *, int));
void scsibuszeroref __P((struct device *));

a90 2


d92 1
a92 2
	sizeof(struct scsibus_softc), scsibusmatch, scsibusattach,
	scsibusdetach, scsibusactivate, scsibuszeroref
a102 2
int scsi_autoconf = SCSI_AUTOCONF;

a146 4
	extern int cold;

	if (!cold)
		scsi_autoconf = 0;
a152 2
	if (sb->adapter_link->luns == 0)
		sb->adapter_link->luns = 8;
a180 34

int
scsibusactivate(dev, act)
	struct device *dev;
	enum devact act;
{
	return (config_activate_children(dev, act));
}

int  
scsibusdetach (dev, type)
	struct device *dev;
	int type;
{
	return (config_detach_children(dev, type));
}

void
scsibuszeroref(dev)
	struct device *dev;
{
	struct scsibus_softc *sb = (struct scsibus_softc *)dev;
	int i;

	for (i = 0; i < sb->sc_buswidth; i++) {
		if (sb->sc_link[i] != NULL)
			free(sb->sc_link[i], M_DEVBUF);
	}
	
	free(sb->sc_link, M_DEVBUF);
}



d248 1
a248 1
		maxlun = scsi->adapter_link->luns - 1;
d527 1
a527 1
         "BCD-16X", "", ""},                    SDEV_NOSTARTUNIT},
d529 1
a529 1
         "BCD-24X", "", ""},                    SDEV_NOSTARTUNIT},
d710 1
a710 1
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
d715 1
a715 1
	scsi_change_def(sc_link, scsi_autoconf | SCSI_SILENT);
d720 1
a720 1
	if (scsi_inquire(sc_link, &inqbuf, scsi_autoconf) != 0)
@


1.49.2.3
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.49.2.2 2001/05/14 22:44:59 niklas Exp $	*/
d137 2
a138 2
	struct device *parent;
	void *match, *aux;
d150 2
a151 2
	struct device *parent, *self;
	void *aux;
d156 1
d622 1
a622 1
	void	*aux;
d638 2
a639 2
	target = sa->sa_sc_link->target;
	lun = sa->sa_sc_link->lun;
d641 2
a642 2
	type = inqbuf->device & SID_TYPE;
	removable = inqbuf->dev_qual2 & SID_REMOVABLE ? 1 : 0;
d709 8
a716 8
	scsi_strvis(vendor, inqbuf->vendor, 8);
	scsi_strvis(product, inqbuf->product, 16);
	scsi_strvis(revision, inqbuf->revision, 4);

	printf(" targ %d lun %d: <%s, %s, %s> SCSI%d %d/%s %s%s",
	    target, lun, vendor, product, revision,
	    inqbuf->version & SID_ANSII, type, dtype,
	    removable ? "removable" : "fixed", qtype);
a742 2
	if (sc_link == NULL)
		return;
@


1.49.2.4
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.49.2.3 2001/07/04 11:00:06 niklas Exp $	*/
a169 3
	/* Initialize shared data. */
	scsi_init();

a480 2
	{{T_DIRECT, T_REMOV,
	 "OLYMPUS ", "C-", ""}, SDEV_NOCDB6|SDEV_NOSYNCCACHE},
a519 4
        {{T_DIRECT, T_FIXED,
         "MICROP", "4421-07",		 ""},     SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "SEAGATE", "ST150176LW",        "0002"}, SDEV_NOTAGS},
a748 1
	sc_link->inquiry_flags2 = 0;
a823 1
	sc_link->inquiry_flags2 = inqbuf.flags2;
@


1.49.2.5
log
@merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a327 1
	u_char last;
d329 2
a330 3
	/* Trim leading and trailing whitespace and NULs. */
	while (len > 0 && (src[0] == ' ' || src[0] == '\t' || src[0] == '\n' ||
	    src[0] == '\0' || src[0] == 0xff))
d332 2
a333 2
	while (len > 0 && (src[len-1] == ' ' || src[len-1] == '\t' || 
	    src[len-1] == '\n' || src[len-1] == '\0' || src[len-1] == 0xff))
a335 1
	last = 0xff;
d337 7
a343 12
		switch (*src) {
		case ' ':
		case '\t':
		case '\n':
		case '\0':
		case 0xff:
			/* collapse whitespace and NULs to a single space */
			if (last != ' ')
				*dst++ = ' ';
			last = ' ';
			break;
		case '\\':
d347 3
a349 15
			last = '\\';
			break;
		default:
			if (*src < 0x20 || *src >= 0x80) {
				/* non-printable characters */
				*dst++ = '\\';
				*dst++ = ((*src & 0300) >> 6) + '0';
				*dst++ = ((*src & 0070) >> 3) + '0';
				*dst++ = ((*src & 0007) >> 0) + '0';
			} else {
				/* normal characters */
				*dst++ = *src;
			}
			last = *src;
			break;
@


1.49.2.6
log
@Merge in trunk
@
text
@a548 4
        {{T_DIRECT, T_FIXED,
         "HP", "C3725S",		 ""},     SDEV_NOTAGS},
        {{T_DIRECT, T_FIXED,
         "IBM", "DCAS",			 ""},     SDEV_NOTAGS},
a780 7
	 * Tell drivers that are paying attention to avoid
	 * sync/wide/tags until INQUIRY data and quirks information
	 * are available.
	 */
	sc_link->quirks = SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;

	/*
d827 1
a827 1
	 * at SCSI-2 or better, remove some limiting quirks.
d830 6
a835 6
		if ((inqbuf.flags & SID_CmdQue) != 0)
			sc_link->quirks &= ~SDEV_NOTAGS;
		if ((inqbuf.flags & SID_Sync) != 0) 
			sc_link->quirks &= ~SDEV_NOSYNC;
		if ((inqbuf.flags & SID_WBus16) != 0)
			sc_link->quirks &= ~SDEV_NOWIDE;
d903 4
a906 1
	if ((cf = config_search(scsibussubmatch, (struct device *)scsi, &sa)) == 0) {
a910 14

	scsi->sc_link[target][lun] = sc_link;

	/* 
	 * Generate another TEST_UNIT_READY command. This gives
	 * drivers waiting for valid quirks data a chance to set
	 * wide/sync/tag options appropriately. Do this now so that
	 * any messages generated by config_attach() do not have
	 * negotiation messages inserted into their midst.
	 */
	(void) scsi_test_unit_ready(sc_link,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);

	config_attach((struct device *)scsi, cf, &sa, scsibusprint);
@


1.49.2.7
log
@Merge in -current from roughly a week ago
@
text
@d77 2
a78 2
void scsi_probedev(struct scsibus_softc *, int, int);
int scsi_probe_bus(int bus, int target, int lun);
d87 5
a91 5
int scsibusmatch(struct device *, void *, void *);
void scsibusattach(struct device *, struct device *, void *);
int  scsibusactivate(struct device *, enum devact);
int  scsibusdetach(struct device *, int);
void scsibuszeroref(struct device *);
d93 1
a93 1
int scsibussubmatch(struct device *, void *, void *);
d112 1
a112 1
int scsibusprint(void *, const char *);
d787 1
a787 3
	 * are available. Since bits in quirks may have already been
	 * set by some drivers (e.g. NOLUNS for atapiscsi), just add
	 * NOTAGS, NOWIDE and NOSYNC.
d789 1
a789 1
	sc_link->quirks |= SDEV_NOSYNC | SDEV_NOWIDE | SDEV_NOTAGS;
@


1.49.2.8
log
@Sync the SMP branch with 3.3
@
text
@a732 3
		case T_RDIRECT:
			dtype = "simplified direct";
			break;
d802 1
a802 1
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d806 2
a807 2
	/* Some devices need to be told to go to SCSI2. */
	/* However some just explode if you tell them this... leave it out. */
a905 1
		case T_RDIRECT:
d931 1
a931 1
	(void) scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
@


1.49.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.49.2.8 2003/03/28 00:08:47 niklas Exp $	*/
d382 1
a382 1
const struct scsi_quirk_inquiry_pattern scsi_quirk_patterns[] = {
d504 2
d768 1
a768 1
	const struct scsi_quirk_inquiry_pattern *finger;
d836 2
a837 2
	finger = (const struct scsi_quirk_inquiry_pattern *)scsi_inqmatch(
	    &inqbuf, scsi_quirk_patterns, 
d951 1
a951 1
const void *
d954 1
a954 1
	const void *base;
d960 1
a960 1
	const void *bestmatch;
@


1.49.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 2
int scsi_probedev(struct scsibus_softc *, struct scsi_inquiry_data *, int,
    int);
a105 1
int scsidebug_buses = SCSIDEBUG_BUSES;
a275 1
	struct scsi_inquiry_data inqbuflun0;
d277 1
a278 1
	int maxtarget, mintarget, maxlun, minlun;
d307 11
a317 7
	for (target = mintarget; target <= maxtarget; target++)
		if (target != scsi_addr) {
			bzero(&inqbuflun0, sizeof inqbuflun0);
			for (lun = minlun; lun <= maxlun; lun++)
				if (scsi_probedev(scsi, &inqbuflun0, target,
				    lun) == EINVAL)
					break;
d319 1
a319 1

d384 60
d446 2
d454 2
d465 1
a465 1
	 "EMULEX  ", "MD21/S2     ESDI", "A00"},  SDEV_AUTOSAVE},
d478 1
a478 1
	 "IBM     ", "H3171-S2",         ""},	  SDEV_AUTOSAVE},
d485 20
d507 18
d528 2
d541 2
d552 13
d568 16
d590 12
d755 3
a757 4
 * Given a target and lun, ask the device what it is, and find the correct
 * driver table entry.
 * 
 * Return 0 if further LUNs are possible, EINVAL if not.
d759 2
a760 2
int
scsi_probedev(scsi, inqbuflun0, target, lun)
a761 1
	struct scsi_inquiry_data *inqbuflun0;
d767 1
a767 1
	int priority, rslt;
d771 1
a771 1
	/* Skip this slot if it is already attached and try the next LUN. */
d773 1
a773 1
		return (0);
d777 1
a777 2
		return (EINVAL);

a784 2
	SC_DEBUG(sc_link, SDEV_DB2, ("scsi_link created.\n"));

d786 5
a790 4
	 * Tell drivers that are paying attention to avoid sync/wide/tags until
	 * INQUIRY data has been processed and the quirks information is
	 * complete. Some drivers set bits in quirks before we get here, so
	 * just add NOTAGS, NOWIDE and NOSYNC.
d798 1
a798 2
	if (((1 << sc_link->scsibus) & scsidebug_buses) &&
	    ((1 << target) & scsidebug_targets) &&
d803 2
a804 8
#if defined(mvme68k) || defined(mvme88k)
	if (lun == 0) {
		/* XXX some drivers depend on this */
		scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
		    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
		    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
	}
#endif
d814 1
a814 33

	memset(&inqbuf.vendor, ' ', sizeof inqbuf.vendor);
	memset(&inqbuf.product, ' ', sizeof inqbuf.product);
	memset(&inqbuf.revision, ' ', sizeof inqbuf.revision);
	memset(&inqbuf.extra, ' ', sizeof inqbuf.extra);

	rslt = scsi_inquire(sc_link, &inqbuf, scsi_autoconf | SCSI_SILENT);

	if (lun == 0 && rslt != 0) {
		/* A bad LUN 0 INQUIRY means no further LUNs possible. */
		SC_DEBUG(sc_link, SDEV_DB2, ("No LUN 0. rslt == %i\n", rslt));
		rslt = EINVAL;
		goto bad;
	} else if (rslt != 0) {
		/* Just a failed LUN INQUIRY, try the next LUN. */
		SC_DEBUG(sc_link, SDEV_DB2, ("Bad LUN. rslt == %i\n", rslt));
		rslt = 0;
		goto bad;
	} else if (lun == 0) {
		bcopy(&inqbuf, inqbuflun0, sizeof *inqbuflun0);
	} else if (memcmp(&inqbuf, inqbuflun0, sizeof inqbuf) == 0) {
		/* The device can't distinguish between LUNs. */
		SC_DEBUG(sc_link, SDEV_DB1, ("IDENTIFY not supported.\n"));
		rslt = EINVAL;
		goto bad;
	}

	switch (inqbuf.device & SID_QUAL) {
	case SID_QUAL_RSVD:
	case SID_QUAL_BAD_LU:
	case SID_QUAL_LU_OFFLINE:
		SC_DEBUG(sc_link, SDEV_DB1,
		    ("Bad LUN. SID_QUAL = 0x%02x\n", inqbuf.device & SID_QUAL));
d817 15
a831 7
	case SID_QUAL_LU_OK:
		if ((inqbuf.device & SID_TYPE) == T_NODEVICE)
			goto bad;
		break;

	default:
		break;
d856 3
d861 3
d876 39
d927 5
a931 7
	 * Generate a TEST_UNIT_READY command. This gives drivers waiting for
	 * valid quirks data a chance to set wide/sync/tag options
	 * appropriately. It also clears any outstanding ACA conditions that
	 * INQUIRY may leave behind. 
	 *
	 * Do this now so that any messages generated by config_attach() do not
	 * have negotiation messages inserted into their midst.
d933 2
a934 3
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
	    scsi_autoconf | SCSI_IGNORE_ILLEGAL_REQUEST |
	    SCSI_IGNORE_NOT_READY | SCSI_IGNORE_MEDIA_CHANGE);
d938 1
a938 1
	return (0);
d942 1
a942 1
	return (rslt);
@


1.49.2.11
log
@Merge with the trunk
@
text
@a111 3
int scsiforcelun_buses = SCSIFORCELUN_BUSES;
int scsiforcelun_targets = SCSIFORCELUN_TARGETS;

d121 4
d129 5
d305 1
a305 1
		if (lun < 0 || lun >= scsi->adapter_link->luns)
d307 1
a307 5
		maxlun = lun;
		if (lun == 0 || scsi->sc_link[target][0] == NULL)
			minlun = 0;
		else
			minlun = lun;
a312 4
			if (minlun != 0 &&
			    (scsi_inquire(scsi->sc_link[target][0], &inqbuflun0,
			    0) != 0))
				continue;
d401 5
d433 3
d458 4
d621 1
a621 1
	int priority, rslt = 0;
d638 1
d660 1
a660 1
#if defined(mvme68k)
d676 7
d684 17
a700 4
	if (rslt != 0) {
		SC_DEBUG(sc_link, SDEV_DB2, ("Bad LUN. rslt = %i\n", rslt));
		if (lun == 0)
			rslt = EINVAL;
d713 1
a713 3
		if ((inqbuf.device & SID_TYPE) == T_NODEVICE) {
			SC_DEBUG(sc_link, SDEV_DB1,
		    	    ("Bad LUN. SID_TYPE = T_NODEVICE\n"));
a714 1
		}
a720 12
	if (lun == 0)
		bcopy(&inqbuf, inqbuflun0, sizeof *inqbuflun0);
	else if (((1 << sc_link->scsibus) & scsiforcelun_buses) &&
	    ((1 << target) & scsiforcelun_targets))
		    ;
	else if (memcmp(&inqbuf, inqbuflun0, sizeof inqbuf) == 0) {
		/* The device doesn't distinguish between LUNs. */
		SC_DEBUG(sc_link, SDEV_DB1, ("IDENTIFY not supported.\n"));
		rslt = EINVAL;
		goto bad;
	}

d749 1
@


1.48
log
@Split SDEV_NOSYNCWIDE into SDEV_NOSYNC and SDEV_NOWIDE (as is done
in NetBSD). Look at Inquiry data during probing to further set quirks
based upon device capabilities. Thanks to Todd.Miller@@courtesan.com for
doing the grunt work and encouraging this to get done fully.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.47 1999/12/11 21:04:26 csapuntz Exp $	*/
d340 2
@


1.47
log
@

LS-120's do support mode sense.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.46 1999/11/22 12:55:16 mjacob Exp $	*/
d370 2
d485 1
a485 1
	 "SONY    ", "SDT-5000        ", "3."},   SDEV_NOSYNCWIDE},
d503 1
a503 1
	 "WangDAT ", "Model 1300      ", "02.4"}, SDEV_NOSYNCWIDE},
d505 1
a505 1
	 "WangDAT ", "Model 2600      ", "01.7"}, SDEV_NOSYNCWIDE},
d507 1
a507 1
	 "WangDAT ", "Model 3200      ", "02.2"}, SDEV_NOSYNCWIDE},
d736 16
@


1.46
log
@In order to support Fibre Channel fabric fatten scsi target id's to 16 bits.
Also, to support at least first level SCSI-3 hierarchical luns, fatten luns
to 16 bits too.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.45 1999/07/24 23:56:43 deraadt Exp $	*/
a460 2
	{{T_DIRECT, T_REMOV,
	 "MATSHITA", "LS-120 VER5   00", ""},	  SDEV_NOMODESENSE},
@


1.45
log
@oops, LS-120 entry munged
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.44 1999/07/24 13:16:01 deraadt Exp $	*/
d227 1
a227 1
	u_int8_t scsi_addr;
@


1.44
log
@SDEV_NOMODESENSE on LS-120 VER5   00
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.43 1999/07/20 06:21:59 csapuntz Exp $	*/
d450 1
a450 1
	 "SEAGATE ", "ST19171FC", ""},            SDEV_NOMODESENSE},
d462 1
a462 1
	 "IOMEGA", "LS-120 VER5   00",	 ""},	  SDEV_NOMODESENSE},
d469 1
a469 1
	 "NEC ", "SD120S-200      ", "0001"},     SDEV_NOLUNS},
@


1.43
log
@

Make acd redundant.

Mostly based on NetBSD-current
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.42 1999/02/24 07:36:02 downsj Exp $	*/
d461 2
@


1.42
log
@Zip250 doesn't do modesense, either.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.41 1998/11/28 23:33:30 downsj Exp $	*/
d308 1
a308 1
	u_int8_t quirks;
d515 36
d552 1
@


1.41
log
@Add another Sony CD-ROM, wvdputte@@reptile.rug.ac.be
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.40 1998/11/11 00:03:47 deraadt Exp $	*/
d459 2
@


1.40
log
@some scsi devices use 0xff as string terminator in inquiry strings; soren@@t.dk
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.39 1998/07/19 06:08:28 downsj Exp $	*/
d348 2
@


1.39
log
@Don't bother trying to use luns on any CyberDrv devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.38 1998/06/26 01:28:28 deraadt Exp $	*/
d279 1
a279 1
	while (len > 0 && (src[0] == ' ' || src[0] == '\0'))
d281 2
a282 1
	while (len > 0 && (src[len-1] == ' ' || src[len-1] == '\0'))
@


1.38
log
@no luns on the ricoh scanner
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.37 1998/05/05 19:07:18 deraadt Exp $	*/
d365 2
@


1.37
log
@more lun flakes; rh@@vip.at, simonb@@telstra.com.au
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.36 1998/04/25 00:25:26 deraadt Exp $	*/
d500 2
@


1.36
log
@some exceptions from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.35 1998/03/18 21:56:46 deraadt Exp $	*/
d318 2
d500 2
@


1.35
log
@more SDEV_AUTOSAVE devices
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.34 1998/02/16 21:23:38 deraadt Exp $	*/
d360 3
a362 1
	 "ShinaKen", "CD-ROM DM-3x1S", "1.04"}, SDEV_NOLUNS},  
d443 4
@


1.34
log
@jaz drives do not do SDEV_NOTAGS
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.33 1998/01/12 19:20:35 kstailey Exp $	*/
d394 2
d420 2
@


1.33
log
@Obsure, old NEC SCSI semi-disk.  A big blob of RAM with a SCSI disk interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.32 1997/09/30 02:53:11 millert Exp $	*/
d439 1
a439 1
	 "iomega", "jaz 1GB",		 ""},	  SDEV_NOMODESENSE},
@


1.32
log
@Quirk for Cipher ST150S tape drive, jbernard@@tater.mines.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.31 1997/09/30 02:49:18 millert Exp $	*/
d447 2
@


1.31
log
@Quirks for revs 015 and 016 of the hitachi dk515.  jbernard@@tater.mines.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.30 1997/09/11 08:03:20 deraadt Exp $	*/
d470 3
@


1.30
log
@another bad lun handler; pk@@netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.29 1997/07/25 01:55:47 mickey Exp $	*/
d382 5
@


1.29
log
@more quirks from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.28 1997/04/14 04:09:14 downsj Exp $	*/
d357 2
@


1.28
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.27 1997/04/02 08:01:56 deraadt Exp $	*/
d320 2
d326 2
d360 7
d375 2
d385 7
d463 2
@


1.27
log
@most 1.3X versions of MEDIAVIS CDR-H93MV have problems; koji@@math.human.nagoya-u.ac.jp
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.26 1997/03/13 05:30:02 briggs Exp $	*/
d336 2
d366 5
a370 1
	 "EMULEX  ", "MD21/S2     ESDI", "A00"},  SDEV_FORCELUNS},
d402 2
d417 3
d645 1
@


1.26
log
@UMAX SuperVista S-12 also needs a NOLUNS quirk.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.25 1997/02/27 06:19:21 tholo Exp $	*/
d324 1
a324 1
	 "MEDIAVIS", "CDR-H93MV       ", "1.31"}, SDEV_NOLUNS},
@


1.25
log
@Add quirk for a scanner
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.24 1997/02/24 20:14:40 jkatz Exp $	*/
d445 2
@


1.24
log
@Adds support for DEC SCSI tape drives used in Vaxen that can also be used
in PC's. from port-vax@@netbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.23 1997/01/18 12:24:25 niklas Exp $	*/
d442 3
@


1.23
log
@Boundary error (s/<=/</)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.22 1997/01/16 20:47:32 kstailey Exp $	*/
d416 4
d609 9
@


1.22
log
@prevent scsiconf.c:110: warning: unused variable `l'
also, #ifdef 0 -> #ifndef __OpenBSD__
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.21 1997/01/16 14:23:32 maja Exp $	*/
d161 1
a161 1
	for (i = 0; i <= sb->sc_buswidth; i++) {
@


1.21
log
@Added scsiprint from NetBSD, needed by new driver for VAX. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.20 1997/01/15 05:50:27 deraadt Exp $	*/
d110 1
d112 1
d118 1
a119 1
#ifdef 0
@


1.20
log
@sc_link.adapter_buswidth, set to 16 if wide scsi. if 0 it gets converted
to 8 internally so that drivers do not need to init it for regular scsi :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.19 1996/11/28 13:20:37 niklas Exp $	*/
d104 19
@


1.19
log
@Make SCSI debugging more dynamic, more targets and luns can be
debugged simultaneously and which ones, as well as the verbosity, can be
determined at runtime.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.18 1996/11/25 04:49:23 millert Exp $	*/
d125 1
d129 18
a146 1
	printf("\n");
d217 1
a217 1
		maxtarget = 7;
d220 2
a221 1
		if (target < 0 || target > 7)
@


1.18
log
@Oops, we don't have SDEV_NOSTARTUNIT.  Remove TEAC scsi floppy quirk for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.17 1996/11/25 00:31:14 millert Exp $	*/
d99 4
d540 3
a542 2
	if (target == DEBUGTARGET && lun == DEBUGLUN)
		sc_link->flags |= DEBUGLEVEL;
@


1.17
log
@Add some quirky devices from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.16 1996/11/23 21:47:12 kstailey Exp $	*/
a364 3
	/* Letting the motor run kills floppy drives and disks quit fast. */
	{{T_DIRECT, T_REMOV,
	 "TEAC", "FC-1",                 ""},     SDEV_NOSTARTUNIT},
@


1.16
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.15 1996/10/20 01:07:04 millert Exp $	*/
d278 2
d302 2
a309 1

d365 3
a367 1

@


1.15
log
@Add quirk entries for 2 optical drives, NetBSD PR #2861
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.14 1996/08/30 00:11:26 downsj Exp $	*/
d99 1
a99 1
int scsibusprint __P((void *, char *));
d406 2
a407 2
	void *aux;
	char *pnp;
@


1.14
log
@Add an IBM quirk.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.13 1996/08/15 11:51:54 shawn Exp $	*/
d309 4
@


1.13
log
@for NEC 210 CD-ROM drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.12 1996/07/24 23:16:11 deraadt Exp $	*/
d356 2
@


1.12
log
@for sun-modified maxtor XT-8760S drives; from ivanenko@@ctpa03.mit.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.11 1996/06/10 00:43:59 downsj Exp $	*/
d285 2
@


1.11
log
@Several changes:
	* Implemented NetBSD PR#2529, adding ZIP 100.
	* Added MTIOCTOP support to acd, cd, and sd.
	* Implemented eject on close for acd, cd, and sd.

`mt -f /dev/rcd0d offline' now ejects a mounted {acd|cd|sd} when it is
unmounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.10 1996/05/06 11:33:06 deraadt Exp $	*/
d321 1
a321 1
	 "MAXTOR  ", "XT-8760S        ", ""},     SDEV_NOLUNS},
@


1.10
log
@shinaken cd has lun problem
@
text
@d1 1
a1 1
/*	$OpenBSD: scsiconf.c,v 1.8 1996/04/21 22:31:04 deraadt Exp $	*/
d350 4
@


1.9
log
@no sys/cpu.h, fix bugs in ch
@
text
@d2 1
a2 1
/*	$NetBSD: scsiconf.c,v 1.56 1996/04/22 01:46:09 christos Exp $	*/
d301 3
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: scsiconf.c,v 1.7 1996/04/19 16:10:15 niklas Exp $	*/
/*	$NetBSD: scsiconf.c,v 1.55 1996/03/21 03:29:40 scottr Exp $	*/
a54 1
#include <sys/cpu.h>
@


1.7
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: scsiconf.c,v 1.52 1996/03/05 01:45:42 thorpej Exp $	*/
d92 6
a97 3
struct cfdriver scsibuscd = {
	NULL, "scsibus", scsibusmatch, scsibusattach, DV_DULL,
	sizeof(struct scsibus_softc)
d152 1
a152 1
	return ((*cf->cf_driver->cd_match)(parent, match, aux));
d166 2
a167 2
		for (bus = 0; bus < scsibuscd.cd_ndevs; bus++)
			if (scsibuscd.cd_devs[bus])
d187 1
a187 1
	if (bus < 0 || bus >= scsibuscd.cd_ndevs)
d189 1
a189 1
	scsi = scsibuscd.cd_devs[bus];
d303 3
d329 2
d348 1
@


1.6
log
@Sync. with NetBSD:
- scsi prototypes.
- Add SCSI scanner support by Kenneth Stailey and Joachim Koenig-Baltes,
  hacked a but.  Needs more work.
ss.c:
- Truncate to the window size in ssminphys(), not ssread().
- Missed some prototyping foo.
- Minor tweak; make sure window size is 0 on close.
- Change variable name to avoid GCC warning.
- Handle EOF a little differently.
@
text
@d1 2
a2 1
/*	$NetBSD: scsiconf.c,v 1.49 1996/02/18 20:32:43 mycroft Exp $	*/
d97 2
d301 2
d319 2
d372 108
d492 1
a492 5
	int priority;
	u_int8_t type;
	boolean removable;
	char *dtype, *qtype;
	char vendor[33], product[65], revision[17];
d558 1
a558 4
	type = inqbuf.device & SID_TYPE;
	removable = inqbuf.dev_qual2 & SID_REMOVABLE ? 1 : 0;

	if (removable)
d564 1
d566 1
a566 1
	dtype = 0;
a568 3
		qtype = "";
		break;

d570 1
a570 1
		qtype = " offline";
a577 2
		qtype = "";
		dtype = "vendor-unique";
d580 2
a581 2
	if (dtype == 0) {
		switch (type) {
a582 2
			dtype = "direct";
			break;
a583 2
			dtype = "sequential";
			break;
a584 2
			dtype = "printer";
			break;
a585 2
			dtype = "processor";
			break;
a586 2
			dtype = "cdrom";
			break;
a587 2
			dtype = "worm";
			break;
a588 2
			dtype = "scanner";
			break;
a589 2
			dtype = "optical";
			break;
a590 2
			dtype = "changer";
			break;
d592 1
a592 1
			dtype = "communication";
a595 3
		default:
			dtype = "unknown";
			break;
a598 10
	scsi_strvis(vendor, inqbuf.vendor, 8);
	scsi_strvis(product, inqbuf.product, 16);
	scsi_strvis(revision, inqbuf.revision, 4);

	printf("%s targ %d lun %d: <%s, %s, %s> SCSI%d %d/%s %s%s\n",
	    ((struct device *)sc_link->adapter_softc)->dv_xname,
	    target, lun, vendor, product, revision,
	    inqbuf.version & SID_ANSII, type, dtype,
	    removable ? "removable" : "fixed", qtype);

d604 4
a607 2
		config_attach((struct device *)scsi, cf, &sa, NULL);
	} else
d609 1
@


1.5
log
@no luns on Tandberg 3600 w/ fake Archive Viper emulation roms; from
raeburn@@raeburn.org; netbsd pr#1934
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.c,v 1.47 1996/01/12 11:32:37 pk Exp $	*/
d54 1
d89 1
d262 71
a332 71
	{T_CDROM, T_REMOV,
	 "CHINON  ", "CD-ROM CDS-431  ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "Chinon  ", "CD-ROM CDS-525  ", "",	 SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "CHINON  ", "CD-ROM CDS-535  ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "DENON   ", "DRD-25X         ", "V",    SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "IMS     ", "CDD521/10       ", "2.06", SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "MEDIAVIS", "CDR-H93MV       ", "1.31", SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:55 ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:83 ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:84 ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "NEC     ", "CD-ROM DRIVE:841", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-541  ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-55S  ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-8003A", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "SONY    ", "CD-ROM CDU-8012 ", "",     SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "TEAC    ", "CD-ROM          ", "1.06", SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "TEXEL   ", "CD-ROM          ", "1.06", SDEV_NOLUNS},
	{T_CDROM, T_REMOV,
	 "TEXEL   ", "CD-ROM DM-XX24 K", "1.10", SDEV_NOLUNS},

	{T_DIRECT, T_FIXED,
	 "EMULEX  ", "MD21/S2     ESDI", "A00",  SDEV_FORCELUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-3280         ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-4380S        ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "MXT-1240S       ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-4170S        ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "XT-8760S        ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "LXT-213S        ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MAXTOR  ", "LXT-213S SUN0207", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "MST     ", "SnapLink        ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "QUANTUM ", "LPS525S         ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "QUANTUM ", "P105S 910-10-94x", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "QUANTUM ", "PD1225S         ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "QUANTUM ", "PD210S   SUN0207", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "RODIME  ", "RO3000S         ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST157N          ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST296           ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "SEAGATE ", "ST296N          ", "",     SDEV_NOLUNS},
	{T_DIRECT, T_FIXED,
	 "TOSHIBA ", "MK538FB         ", "6027", SDEV_NOLUNS},
d335 14
a348 14
	{T_SEQUENTIAL, T_REMOV,
	 "        ", "                ", "    ", SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "CALIPER ", "CP150           ", "",     SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", "",     SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "SONY    ", "SDT-2000        ", "2.09", SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "SONY    ", "SDT-5000        ", "3.",   SDEV_NOSYNCWIDE},
	{T_SEQUENTIAL, T_REMOV,
	 "SONY    ", "SDT-5200        ", "3.",   SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "TANDBERG", " TDC 3600       ", "",     SDEV_NOLUNS},
d350 12
a361 12
	{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 150  21247", "",     SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5099ES SCSI",      "",     SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI",      "",     SDEV_NOLUNS},
	{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 1300      ", "02.4", SDEV_NOSYNCWIDE},
	{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 2600      ", "01.7", SDEV_NOSYNCWIDE},
	{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 3200      ", "02.2", SDEV_NOSYNCWIDE},
@


1.4
log
@Save inquiry flags in sc_link so low-level drivers can use it.
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.c,v 1.46 1995/12/31 02:40:53 thorpej Exp $	*/
d347 3
@


1.3
log
@lun problem on Chinon CDS-525; from k125374@@cs.tut.fi; netbsd pr#1686.
@
text
@d389 1
d433 5
@


1.2
log
@from netbsd:
add a bunch of rogues
Trim NULs, in addition to spaces, in scsi_strvis().
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.c,v 1.45 1995/12/11 04:43:01 mycroft Exp $	*/
d262 2
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: scsiconf.c,v 1.43 1995/10/13 20:01:03 gwr Exp $	*/
d227 2
a228 2
	/* Trim leading and trailing blanks. */
	while (len > 0 && src[0] == ' ')
d230 1
a230 1
	while (len > 0 && src[len-1] == ' ')
d318 2
d334 2
d340 3
a342 1
	 "SONY    ", "SDT-5000        ", "3.17", SDEV_NOSYNCWIDE},
d570 1
a570 1
#if 0
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

