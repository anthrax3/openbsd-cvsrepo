head	1.132;
access;
symbols
	OPENBSD_6_1:1.132.0.4
	OPENBSD_6_1_BASE:1.132
	OPENBSD_6_0:1.131.0.2
	OPENBSD_6_0_BASE:1.131
	OPENBSD_5_9:1.129.0.2
	OPENBSD_5_9_BASE:1.129
	OPENBSD_5_8:1.129.0.4
	OPENBSD_5_8_BASE:1.129
	OPENBSD_5_7:1.128.0.2
	OPENBSD_5_7_BASE:1.128
	OPENBSD_5_6:1.126.0.6
	OPENBSD_5_6_BASE:1.126
	OPENBSD_5_5:1.126.0.4
	OPENBSD_5_5_BASE:1.126
	OPENBSD_5_4:1.124.0.2
	OPENBSD_5_4_BASE:1.124
	OPENBSD_5_3:1.121.0.8
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.121.0.6
	OPENBSD_5_2_BASE:1.121
	OPENBSD_5_1_BASE:1.121
	OPENBSD_5_1:1.121.0.4
	OPENBSD_5_0:1.121.0.2
	OPENBSD_5_0_BASE:1.121
	OPENBSD_4_9:1.116.0.2
	OPENBSD_4_9_BASE:1.116
	OPENBSD_4_8:1.106.0.2
	OPENBSD_4_8_BASE:1.106
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.86.0.6
	OPENBSD_4_6_BASE:1.86
	OPENBSD_4_5:1.86.0.2
	OPENBSD_4_5_BASE:1.86
	OPENBSD_4_4:1.83.0.2
	OPENBSD_4_4_BASE:1.83
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.75.0.2
	OPENBSD_4_2_BASE:1.75
	OPENBSD_4_1:1.72.0.2
	OPENBSD_4_1_BASE:1.72
	OPENBSD_4_0:1.63.0.2
	OPENBSD_4_0_BASE:1.63
	OPENBSD_3_9:1.50.0.2
	OPENBSD_3_9_BASE:1.50
	OPENBSD_3_8:1.49.0.2
	OPENBSD_3_8_BASE:1.49
	OPENBSD_3_7:1.43.0.2
	OPENBSD_3_7_BASE:1.43
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.32
	UBC:1.29.0.4
	UBC_BASE:1.29
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.6
	OPENBSD_2_8:1.28.0.4
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	SMP:1.27.0.4
	SMP_BASE:1.27
	kame_19991208:1.27
	OPENBSD_2_6:1.27.0.2
	OPENBSD_2_6_BASE:1.27
	OPENBSD_2_5:1.25.0.4
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.25.0.2
	OPENBSD_2_4_BASE:1.25
	OPENBSD_2_3:1.24.0.2
	OPENBSD_2_3_BASE:1.24
	OPENBSD_2_2:1.21.0.2
	OPENBSD_2_2_BASE:1.21
	OPENBSD_2_1:1.15.0.2
	OPENBSD_2_1_BASE:1.15
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.132
date	2016.09.04.10.51.24;	author naddy;	state Exp;
branches;
next	1.131;
commitid	4OWaAfwqMvhOCLOI;

1.131
date	2016.03.12.15.16.04;	author krw;	state Exp;
branches;
next	1.130;
commitid	zkFngOKA3woPgVlY;

1.130
date	2016.03.11.17.12.17;	author krw;	state Exp;
branches;
next	1.129;
commitid	VQGZKrglhTjRIDYC;

1.129
date	2015.06.07.19.13.27;	author krw;	state Exp;
branches;
next	1.128;
commitid	MxUWuiPFtM1nRYxm;

1.128
date	2014.12.16.18.30.04;	author tedu;	state Exp;
branches;
next	1.127;
commitid	P6Av4XGqOi3rFasL;

1.127
date	2014.09.14.14.17.26;	author jsg;	state Exp;
branches;
next	1.126;
commitid	uzzBR7hz9ncd4O6G;

1.126
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2013.10.03.14.07.42;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2013.07.05.01.22.25;	author krw;	state Exp;
branches;
next	1.123;

1.123
date	2013.06.11.16.42.17;	author deraadt;	state Exp;
branches;
next	1.122;

1.122
date	2013.06.06.14.00.44;	author krw;	state Exp;
branches;
next	1.121;

1.121
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.120;

1.120
date	2011.06.07.15.42.29;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	2011.03.31.18.42.48;	author jasper;	state Exp;
branches;
next	1.118;

1.118
date	2011.03.18.22.59.34;	author matthew;	state Exp;
branches;
next	1.117;

1.117
date	2011.03.17.21.30.24;	author deraadt;	state Exp;
branches;
next	1.116;

1.116
date	2010.12.24.02.45.33;	author krw;	state Exp;
branches;
next	1.115;

1.115
date	2010.10.13.02.14.52;	author krw;	state Exp;
branches;
next	1.114;

1.114
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	2010.09.20.02.51.52;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.14.04.49.42;	author dlg;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.14.04.02.43;	author dlg;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.14.01.43.38;	author krw;	state Exp;
branches;
next	1.109;

1.109
date	2010.09.01.23.24.03;	author krw;	state Exp;
branches;
next	1.108;

1.108
date	2010.09.01.01.38.12;	author dlg;	state Exp;
branches;
next	1.107;

1.107
date	2010.08.30.02.47.56;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	2010.07.22.05.26.34;	author matthew;	state Exp;
branches;
next	1.105;

1.105
date	2010.07.22.00.31.06;	author krw;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.01.05.11.18;	author krw;	state Exp;
branches;
next	1.103;

1.103
date	2010.07.01.03.01.37;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	2010.06.30.02.17.25;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	2010.06.29.07.08.07;	author matthew;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.99;

1.99
date	2010.06.25.04.29.39;	author dlg;	state Exp;
branches;
next	1.98;

1.98
date	2010.06.16.00.20.06;	author krw;	state Exp;
branches;
next	1.97;

1.97
date	2010.06.15.04.11.34;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.11.12.02.44;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2010.06.01.15.27.16;	author thib;	state Exp;
branches;
next	1.94;

1.94
date	2010.04.12.09.51.48;	author dlg;	state Exp;
branches;
next	1.93;

1.93
date	2010.01.15.05.50.31;	author krw;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2010.01.15.05.31.38;	author krw;	state Exp;
branches;
next	1.91;

1.91
date	2010.01.12.23.33.57;	author dlg;	state Exp;
branches;
next	1.90;

1.90
date	2010.01.11.08.56.17;	author krw;	state Exp;
branches;
next	1.89;

1.89
date	2010.01.09.21.12.06;	author dlg;	state Exp;
branches;
next	1.88;

1.88
date	2009.12.26.09.12.55;	author dlg;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.86;

1.86
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2008.09.22.19.44.41;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2008.09.06.15.35.02;	author krw;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.22.16.32.06;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2008.05.12.22.14.46;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2008.05.09.00.25.41;	author krw;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.27.16.22.14;	author martynas;	state Exp;
branches;
next	1.79;

1.79
date	2007.11.22.03.57.07;	author krw;	state Exp;
branches;
next	1.78;

1.78
date	2007.11.22.03.19.50;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2007.11.16.11.28.34;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.09.16.15.54.52;	author krw;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.06.17.15.14;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.01.18.44.48;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.10.17.47.56;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2007.01.20.18.21.51;	author krw;	state Exp;
branches;
next	1.71;

1.71
date	2007.01.05.00.42.47;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2006.12.21.02.05.46;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2006.12.12.02.44.36;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2006.11.28.16.56.50;	author dlg;	state Exp;
branches;
next	1.67;

1.67
date	2006.11.27.23.14.22;	author beck;	state Exp;
branches;
next	1.66;

1.66
date	2006.11.27.18.24.43;	author beck;	state Exp;
branches;
next	1.65;

1.65
date	2006.10.07.23.40.08;	author beck;	state Exp;
branches;
next	1.64;

1.64
date	2006.10.02.09.06.26;	author dlg;	state Exp;
branches;
next	1.63;

1.63
date	2006.06.11.03.59.59;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2006.06.01.05.42.01;	author krw;	state Exp;
branches;
next	1.61;

1.61
date	2006.05.28.23.58.00;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.28.23.34.34;	author beck;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.28.23.26.35;	author krw;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.28.23.19.25;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.28.20.04.52;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.28.19.31.09;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.28.07.18.30;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.28.07.07.09;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2006.05.28.00.47.45;	author krw;	state Exp;
branches;
next	1.52;

1.52
date	2006.05.28.00.27.09;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.11.17.34.27;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2005.08.23.23.38.00;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2005.06.24.20.48.25;	author krw;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.05.21.27.07;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.14.00.20.43;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.06.02.51.13;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.05.12.13.16;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.30.19.28.37;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.16.04.05.39;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2004.08.01.23.01.06;	author marco;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2004.06.22.00.43.25;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.28.23.50.15;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.17.23.57.51;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.17.12.37.13;	author aoyama;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.09.04.01.59;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.18.16.06.35;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.11.01.12.09;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2002.12.30.21.50.29;	author grange;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.09.00.05.57;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.04.00.09.08;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.01.27.13;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2001.06.22.14.35.43;	author deraadt;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2000.04.08.19.19.33;	author csapuntz;	state Exp;
branches;
next	1.27;

1.27
date	99.09.05.20.58.03;	author niklas;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	99.07.25.07.09.20;	author csapuntz;	state Exp;
branches;
next	1.25;

1.25
date	98.07.23.09.11.09;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	98.02.22.00.51.46;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	98.02.16.06.06.38;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	98.01.10.01.37.52;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.09.05.05.56.51;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	97.09.03.17.21.49;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	97.08.22.04.43.27;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	97.08.19.03.50.59;	author dgregor;	state Exp;
branches;
next	1.17;

1.17
date	97.07.11.19.26.00;	author tholo;	state Exp;
branches;
next	1.16;

1.16
date	97.07.11.02.18.40;	author tholo;	state Exp;
branches;
next	1.15;

1.15
date	97.04.14.04.09.17;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.02.24.20.17.35;	author jkatz;	state Exp;
branches;
next	1.13;

1.13
date	96.12.11.19.08.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.11.23.26.07;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.10.12.31.41;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.04.21.22.31.20;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.19.16.10.28;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.02.20.01.22.02;	author briggs;	state Exp;
branches;
next	1.7;

1.7
date	96.02.09.14.45.31;	author briggs;	state Exp;
branches;
next	1.6;

1.6
date	96.01.16.01.20.33;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.14.05.45.18;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.21.03.53.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.20.14.03.29;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.19.13.27.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.53.24;	author deraadt;	state Exp;
branches;
next	;

1.27.4.1
date	2001.05.14.22.45.00;	author niklas;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2001.07.04.11.00.10;	author niklas;	state Exp;
branches;
next	1.27.4.3;

1.27.4.3
date	2002.03.28.14.52.01;	author niklas;	state Exp;
branches;
next	1.27.4.4;

1.27.4.4
date	2003.03.28.00.08.47;	author niklas;	state Exp;
branches;
next	1.27.4.5;

1.27.4.5
date	2003.06.07.11.07.44;	author ho;	state Exp;
branches;
next	1.27.4.6;

1.27.4.6
date	2004.06.05.23.13.09;	author niklas;	state Exp;
branches;
next	;

1.29.4.1
date	2002.06.11.03.32.14;	author art;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2003.05.19.22.28.21;	author tedu;	state Exp;
branches;
next	;

1.41.2.1
date	2004.11.02.01.05.50;	author brad;	state Exp;
branches;
next	;

1.93.2.1
date	2010.07.06.08.48.50;	author stephan;	state Exp;
branches;
next	;


desc
@@


1.132
log
@Remove support for tape block devices. Nobody mount(8)s tapes any longer.
ok deraadt@@ guenther@@
@
text
@/*	$OpenBSD: st.c,v 1.131 2016/03/12 15:16:04 krw Exp $	*/
/*	$NetBSD: st.c,v 1.71 1997/02/21 23:03:49 thorpej Exp $	*/

/*
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 * major changes by Julian Elischer (julian@@jules.dialix.oz.au) May 1993
 */

/*
 * To do:
 * work out some better way of guessing what a good timeout is going
 * to be depending on whether we expect to retension or not.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/fcntl.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <sys/pool.h>
#include <sys/buf.h>
#include <sys/mtio.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/vnode.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_tape.h>
#include <scsi/scsiconf.h>

/* Defines for device specific stuff */
#define DEF_FIXED_BSIZE  512

#define STMODE(z)	( minor(z)	 & 0x03)
#define STUNIT(z)	((minor(z) >> 4)       )

#define STMINOR(unit, mode)	(((unit) << 4) + (mode))
#define MAXSTMODES	16

#define	ST_IO_TIME	(3 * 60 * 1000)		/* 3 minutes */
#define	ST_CTL_TIME	(30 * 1000)		/* 30 seconds */
#define	ST_SPC_TIME	(4 * 60 * 60 * 1000)	/* 4 hours */

/*
 * Maximum density code allowed in SCSI spec (SSC2R08f, Section 8.3).
 */
#define SCSI_MAX_DENSITY_CODE		0xff

/*
 * Define various devices that we know mis-behave in some way,
 * and note how they are bad, so we can correct for them
 */
struct modes {
	u_int quirks;			/* same definitions as in quirkdata */
	int blksize;
	u_int8_t density;
};

struct quirkdata {
	u_int quirks;
#define	ST_Q_FORCE_BLKSIZE	0x0001
#define	ST_Q_SENSE_HELP		0x0002	/* must do READ for good MODE SENSE */
#define	ST_Q_IGNORE_LOADS	0x0004
#define	ST_Q_BLKSIZE		0x0008	/* variable-block media_blksize > 0 */
#define	ST_Q_UNIMODAL		0x0010	/* unimode drive rejects mode select */
	struct modes modes;
};

struct st_quirk_inquiry_pattern {
	struct scsi_inquiry_pattern pattern;
	struct quirkdata quirkdata;
};

const struct st_quirk_inquiry_pattern st_quirk_patterns[] = {
	{{T_SEQUENTIAL, T_REMOV,
	 "        ", "                ", "    "}, {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "TANDBERG", " TDC 3600       ", ""},     {0,
		{0, 0, 0}}},				/* minor 0-3 */
 	{{T_SEQUENTIAL, T_REMOV,
 	 "TANDBERG", " TDC 3800       ", ""},     {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	/*
	 * At least -005 and -007 need this.  I'll assume they all do unless I
	 * hear otherwise.  - mycroft, 31MAR1994
	 */
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 2525 25462", ""},     {0,
		{ST_Q_SENSE_HELP, 0, 0}}},		/* minor 0-3 */
	/*
	 * One user reports that this works for his tape drive.  It probably
	 * needs more work.  - mycroft, 09APR1994
	 */
	{{T_SEQUENTIAL, T_REMOV,
	 "SANKYO  ", "CP525           ", ""},    {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "ANRITSU ", "DMT780          ", ""},     {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 150  21247", ""},     {0,
		{0, 0, 0}}},				/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 150  21531", ""},     {0,
		{ST_Q_SENSE_HELP, 0, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5099ES SCSI", ""},          {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI", ""},          {0,
		{ST_Q_FORCE_BLKSIZE, 512, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5525ES SCSI REV7", ""},     {0,
		{0, 0, 0}}},				/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 1300      ", ""},     {0,
		{0, 0, 0}}},				/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", "263H"}, {0,
		{0, 0, 0}}},				/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "HP      ", "T4000s          ", ""},     {ST_Q_UNIMODAL,
		{0, 0, QIC_3095}}},			/* minor 0-3 */
#if 0
	{{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", ""},     {0,
		{0, 0, 0}}},				/* minor 0-3 */
#endif
	{{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI FA15\0""01 A", "????"}, {0,
		{ST_Q_IGNORE_LOADS, 0, 0}}},		/* minor 0-3 */
	{{T_SEQUENTIAL, T_REMOV,
	 "TEAC    ", "MT-2ST/N50      ", ""},     {ST_Q_IGNORE_LOADS,
		{0, 0, 0}}},				/* minor 0-3 */
};

#define NOEJECT 0
#define EJECT 1

#define NOREWIND 0
#define DOREWIND 1

struct st_softc {
	struct device sc_dev;

	int flags;		/* see below                          */
	u_int quirks;		/* quirks for the open mode           */
	int blksize;		/* blksize we are using               */
	u_int8_t density;	/* present density                    */
	short mt_resid;		/* last (short) resid                 */
	short mt_erreg;		/* last error (sense key) seen        */

	struct scsi_link *sc_link;	/* our link to the adpter etc.        */

	int blkmin;		/* min blk size                       */
	int blkmax;		/* max blk size                       */
	const struct quirkdata *quirkdata;	/* if we have a rogue entry */

	u_int64_t numblks;		/* nominal blocks capacity            */
	u_int32_t media_blksize;	/* 0 if not ST_FIXEDBLOCKS            */
	u_int32_t media_density;	/* this is what it said when asked    */
	int media_fileno;		/* relative to BOT. -1 means unknown. */
	int media_blkno;		/* relative to BOF. -1 means unknown. */
	int media_eom;			/* relative to BOT. -1 means unknown. */

	u_int drive_quirks;	/* quirks of this drive               */

	struct modes modes;	/* plus more for each mode            */
	u_int8_t  modeflags;	/* flags for the modes                */
#define DENSITY_SET_BY_USER	0x01
#define DENSITY_SET_BY_QUIRK	0x02
#define BLKSIZE_SET_BY_USER	0x04
#define BLKSIZE_SET_BY_QUIRK	0x08

	struct bufq sc_bufq;
	struct timeout sc_timeout;
	struct scsi_xshandler sc_xsh;
};


int	stmatch(struct device *, void *, void *);
void	stattach(struct device *, struct device *, void *);
int	stactivate(struct device *, int);
int	stdetach(struct device *, int);

void	stminphys(struct buf *);
void	st_identify_drive(struct st_softc *, struct scsi_inquiry_data *);
void	st_loadquirks(struct st_softc *);
int	st_mount_tape(dev_t, int);
void	st_unmount(struct st_softc *, int, int);
int	st_decide_mode(struct st_softc *, int);
void	ststart(struct scsi_xfer *);
void	st_buf_done(struct scsi_xfer *);
int	st_read(struct st_softc *, char *, int, int);
int	st_read_block_limits(struct st_softc *, int);
int	st_mode_sense(struct st_softc *, int);
int	st_mode_select(struct st_softc *, int);
int	st_space(struct st_softc *, int, u_int, int);
int	st_write_filemarks(struct st_softc *, int, int);
int	st_check_eod(struct st_softc *, int, int *, int);
int	st_load(struct st_softc *, u_int, int);
int	st_rewind(struct st_softc *, u_int, int);
int	st_interpret_sense(struct scsi_xfer *);
int	st_touch_tape(struct st_softc *);
int	st_erase(struct st_softc *, int, int);

struct cfattach st_ca = {
	sizeof(struct st_softc), stmatch, stattach,
	stdetach, stactivate
};

struct cfdriver st_cd = {
	NULL, "st", DV_TAPE
};

#define	ST_INFO_VALID	0x0001
#define	ST_BLOCK_SET	0x0002	/* block size, mode set by ioctl      */
#define	ST_WRITTEN	0x0004	/* data have been written, EOD needed */
#define	ST_FIXEDBLOCKS	0x0008
#define	ST_AT_FILEMARK	0x0010
#define	ST_EIO_PENDING	0x0020	/* we couldn't report it then (had data) */
#define	ST_EOM_PENDING	0x0040	/* we couldn't report it then (had data) */
#define ST_EOD_DETECTED	0x0080
#define	ST_FM_WRITTEN	0x0100	/*
				 * EOF file mark written  -- used with
				 * ~ST_WRITTEN to indicate that multiple file
				 * marks have been written
				 */
#define	ST_BLANK_READ	0x0200	/* BLANK CHECK encountered already */
#define	ST_2FM_AT_EOD	0x0400	/* write 2 file marks at EOD */
#define	ST_MOUNTED	0x0800	/* Device is presently mounted */
#define	ST_DONTBUFFER	0x1000	/* Disable buffering/caching */
#define ST_WAITING	0x2000
#define	ST_DYING	0x4000	/* dying, when deactivated */
#define ST_BOD_DETECTED	0x8000

#define	ST_PER_ACTION	(ST_AT_FILEMARK | ST_EIO_PENDING | ST_EOM_PENDING | \
			 ST_BLANK_READ)

#define stlookup(unit) (struct st_softc *)device_lookup(&st_cd, (unit))

const struct scsi_inquiry_pattern st_patterns[] = {
	{T_SEQUENTIAL, T_REMOV,
	 "",         "",                 ""},
};

int
stmatch(struct device *parent, void *match, void *aux)
{
	struct scsi_attach_args *sa = aux;
	int priority;

	(void)scsi_inqmatch(sa->sa_inqbuf,
	    st_patterns, nitems(st_patterns),
	    sizeof(st_patterns[0]), &priority);
	return (priority);
}

/*
 * The routine called by the low level scsi routine when it discovers
 * A device suitable for this driver
 */
void
stattach(struct device *parent, struct device *self, void *aux)
{
	struct st_softc *st = (void *)self;
	struct scsi_attach_args *sa = aux;
	struct scsi_link *link = sa->sa_sc_link;

	SC_DEBUG(link, SDEV_DB2, ("stattach:\n"));

	/*
	 * Store information needed to contact our base driver
	 */
	st->sc_link = link;
	link->interpret_sense = st_interpret_sense;
	link->device_softc = st;

	/*
	 * Check if the drive is a known criminal and take
	 * Any steps needed to bring it into line
	 */
	st_identify_drive(st, sa->sa_inqbuf);
	printf("\n");

	scsi_xsh_set(&st->sc_xsh, link, ststart);
	timeout_set(&st->sc_timeout, (void (*)(void *))scsi_xsh_set,
	    &st->sc_xsh);

	/* Set up the buf queue for this device. */
	bufq_init(&st->sc_bufq, BUFQ_FIFO);

	/* Start up with media position unknown. */
	st->media_fileno = -1;
	st->media_blkno = -1;
	st->media_eom = -1;

	/*
	 * Reset the media loaded flag, sometimes the data
	 * acquired at boot time is not quite accurate.  This
	 * will be checked again at the first open.
	 */
	link->flags &= ~SDEV_MEDIA_LOADED;
}

int
stactivate(struct device *self, int act)
{
	struct st_softc *st = (struct st_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		st->flags |= ST_DYING;
		scsi_xsh_del(&st->sc_xsh);
		break;
	}

	return (rv);
}

int
stdetach(struct device *self, int flags)
{
	struct st_softc *st = (struct st_softc *)self;
	int cmaj, mn;

	bufq_drain(&st->sc_bufq);

	/* Locate the lowest minor number to be detached. */
	mn = STMINOR(self->dv_unit, 0);

	for (cmaj = 0; cmaj < nchrdev; cmaj++)
		if (cdevsw[cmaj].d_open == stopen)
			vdevgone(cmaj, mn, mn + MAXSTMODES - 1, VCHR);

	bufq_destroy(&st->sc_bufq);

	return (0);
}

/*
 * Use the inquiry routine in 'scsi_base' to get drive info so we can
 * Further tailor our behaviour.
 */
void
st_identify_drive(struct st_softc *st, struct scsi_inquiry_data *inqbuf)
{
	const struct st_quirk_inquiry_pattern *finger;
	int priority;

	finger = (const struct st_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    st_quirk_patterns,
	    nitems(st_quirk_patterns),
	    sizeof(st_quirk_patterns[0]), &priority);
	if (priority != 0) {
		st->quirkdata = &finger->quirkdata;
		st->drive_quirks = finger->quirkdata.quirks;
		st->quirks = finger->quirkdata.quirks;	/* start value */
		st_loadquirks(st);
	}
}

/*
 * initialise the subdevices to the default (QUIRK) state.
 * this will remove any setting made by the system operator or previous
 * operations.
 */
void
st_loadquirks(struct st_softc *st)
{
	const struct	modes *mode;
	struct	modes *mode2;

	mode = &st->quirkdata->modes;
	mode2 = &st->modes;
	bzero(mode2, sizeof(struct modes));
	st->modeflags &= ~(BLKSIZE_SET_BY_QUIRK |
	    DENSITY_SET_BY_QUIRK | BLKSIZE_SET_BY_USER |
	    DENSITY_SET_BY_USER);
	if ((mode->quirks | st->drive_quirks) & ST_Q_FORCE_BLKSIZE) {
		mode2->blksize = mode->blksize;
		st->modeflags |= BLKSIZE_SET_BY_QUIRK;
	}
	if (mode->density) {
		mode2->density = mode->density;
		st->modeflags |= DENSITY_SET_BY_QUIRK;
	}
}

/*
 * open the device.
 */
int
stopen(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct scsi_link *link;
	struct st_softc *st;
	int error = 0;

	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);
	link = st->sc_link;

	if (st->flags & ST_DYING) {
		error = ENXIO;
		goto done;
	}
	if (ISSET(flags, FWRITE) && ISSET(link->flags, SDEV_READONLY)) {
		error = EACCES;
		goto done;
	}

	SC_DEBUG(link, SDEV_DB1, ("open: dev=0x%x (unit %d (of %d))\n", dev,
	    STUNIT(dev), st_cd.cd_ndevs));

	/*
	 * Tape is an exclusive media. Only one open at a time.
	 */
	if (link->flags & SDEV_OPEN) {
		SC_DEBUG(link, SDEV_DB4, ("already open\n"));
		error = EBUSY;
		goto done;
	}

	/* Use st_interpret_sense() now. */
	link->flags |= SDEV_OPEN;

	/*
	 * Check the unit status. This clears any outstanding errors and
	 * will ensure that media is present.
	 */
	error = scsi_test_unit_ready(link, TEST_READY_RETRIES,
	    SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE |
	    SCSI_IGNORE_ILLEGAL_REQUEST);

	/*
	 * Terminate any exising mount session if there is no media.
	 */
	if ((link->flags & SDEV_MEDIA_LOADED) == 0)
		st_unmount(st, NOEJECT, DOREWIND);

	if (error) {
		link->flags &= ~SDEV_OPEN;
		goto done;
	}

	if ((st->flags & ST_MOUNTED) == 0) {
		error = st_mount_tape(dev, flags);
		if (error) {
			link->flags &= ~SDEV_OPEN;
			goto done;
		}
	}

	/*
	 * Make sure that a tape opened in write-only mode will have
	 * file marks written on it when closed, even if not written to.
	 * This is for SUN compatibility
	 */
	if ((flags & O_ACCMODE) == FWRITE)
		st->flags |= ST_WRITTEN;

done:
	SC_DEBUG(link, SDEV_DB2, ("open complete\n"));
	device_unref(&st->sc_dev);
	return (error);
}

/*
 * close the device.. only called if we are the LAST
 * occurrence of an open device
 */
int
stclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct scsi_link *link;
	struct st_softc *st;
	int error = 0;

	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);
	if (st->flags & ST_DYING) {
		error = ENXIO;
		goto done;
	}
	link = st->sc_link;

	SC_DEBUG(link, SDEV_DB1, ("closing\n"));

	if ((st->flags & (ST_WRITTEN | ST_FM_WRITTEN)) == ST_WRITTEN)
		st_write_filemarks(st, 1, 0);

	switch (STMODE(dev)) {
	case 0:		/* normal */
		st_unmount(st, NOEJECT, DOREWIND);
		break;
	case 3:		/* eject, no rewind */
		st_unmount(st, EJECT, NOREWIND);
		break;
	case 1:		/* no rewind */
		/* leave mounted unless media seems to have been removed */
		if (!(link->flags & SDEV_MEDIA_LOADED))
			st_unmount(st, NOEJECT, NOREWIND);
		break;
	case 2:		/* rewind, eject */
		st_unmount(st, EJECT, DOREWIND);
		break;
	}
	link->flags &= ~SDEV_OPEN;
	timeout_del(&st->sc_timeout);
	scsi_xsh_del(&st->sc_xsh);

done:
	device_unref(&st->sc_dev);
	return (error);
}

/*
 * Start a new mount session.
 * Copy in all the default parameters from the selected device mode.
 * and try guess any that seem to be defaulted.
 */
int
st_mount_tape(dev_t dev, int flags)
{
	struct st_softc *st;
	struct scsi_link *link;
	int error = 0;

	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);
	if (st->flags & ST_DYING) {
		error = ENXIO;
		goto done;
	}
	link = st->sc_link;

	SC_DEBUG(link, SDEV_DB1, ("mounting\n"));

	if (st->flags & ST_MOUNTED)
		goto done;

	st->quirks = st->drive_quirks | st->modes.quirks;
	/*
	 * If the media is new, then make sure we give it a chance to
	 * to do a 'load' instruction.  (We assume it is new.)
	 */
	if ((error = st_load(st, LD_LOAD, 0)) != 0)
		goto done;

	/*
	 * Throw another dummy instruction to catch
	 * 'Unit attention' errors. Some drives appear to give
	 * these after doing a Load instruction.
	 * (noteably some DAT drives)
	 */
	/* XXX */
	scsi_test_unit_ready(link, TEST_READY_RETRIES, SCSI_SILENT);

	/*
	 * Some devices can't tell you much until they have been
	 * asked to look at the media. This quirk does this.
	 */
	if (st->quirks & ST_Q_SENSE_HELP)
		if ((error = st_touch_tape(st)) != 0)
			return error;
	/*
	 * Load the physical device parameters
	 * loads: blkmin, blkmax
	 */
	if (!(link->flags & SDEV_ATAPI) &&
	    (error = st_read_block_limits(st, 0)) != 0)
		goto done;

	/*
	 * Load the media dependent parameters
	 * includes: media_blksize,media_density,numblks
	 * As we have a tape in, it should be reflected here.
	 * If not you may need the "quirk" above.
	 */
	if ((error = st_mode_sense(st, 0)) != 0)
		goto done;

	/*
	 * If we have gained a permanent density from somewhere,
	 * then use it in preference to the one supplied by
	 * default by the driver.
	 */
	if (st->modeflags & (DENSITY_SET_BY_QUIRK | DENSITY_SET_BY_USER))
		st->density = st->modes.density;
	else
		st->density = st->media_density;
	/*
	 * If we have gained a permanent blocksize
	 * then use it in preference to the one supplied by
	 * default by the driver.
	 */
	st->flags &= ~ST_FIXEDBLOCKS;
	if (st->modeflags & (BLKSIZE_SET_BY_QUIRK | BLKSIZE_SET_BY_USER)) {
		st->blksize = st->modes.blksize;
		if (st->blksize)
			st->flags |= ST_FIXEDBLOCKS;
	} else {
		if ((error = st_decide_mode(st, 0)) != 0)
			goto done;
	}
	if ((error = st_mode_select(st, 0)) != 0) {
		printf("%s: cannot set selected mode\n", st->sc_dev.dv_xname);
		goto done;
	}
	scsi_prevent(link, PR_PREVENT,
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
	st->flags |= ST_MOUNTED;
	link->flags |= SDEV_MEDIA_LOADED;	/* move earlier? */
	st->media_fileno = 0;
	st->media_blkno = 0;
	st->media_eom = -1;

done:
	device_unref(&st->sc_dev);
	return (error);
}

/*
 * End the present mount session.
 * Rewind, and optionally eject the tape.
 * Reset various flags to indicate that all new
 * operations require another mount operation
 */
void
st_unmount(struct st_softc *st, int eject, int rewind)
{
	struct scsi_link *link = st->sc_link;
	int nmarks;

	st->media_fileno = -1;
	st->media_blkno = -1;

	if (!(st->flags & ST_MOUNTED))
		return;
	SC_DEBUG(link, SDEV_DB1, ("unmounting\n"));
	st_check_eod(st, 0, &nmarks, SCSI_IGNORE_NOT_READY);
	if (rewind)
		st_rewind(st, 0, SCSI_IGNORE_NOT_READY);
	scsi_prevent(link, PR_ALLOW,
	    SCSI_IGNORE_ILLEGAL_REQUEST | SCSI_IGNORE_NOT_READY);
	if (eject)
		st_load(st, LD_UNLOAD, SCSI_IGNORE_NOT_READY);
	st->flags &= ~ST_MOUNTED;
	link->flags &= ~SDEV_MEDIA_LOADED;
}

/*
 * Given all we know about the device, media, mode, 'quirks' and
 * initial operation, make a decision as to how we should be set
 * to run (regarding blocking and EOD marks)
 */
int
st_decide_mode(struct st_softc *st, int first_read)
{
	struct scsi_link *link = st->sc_link;

	SC_DEBUG(link, SDEV_DB2, ("starting block mode decision\n"));

	/* ATAPI tapes are always fixed blocksize. */
	if (link->flags & SDEV_ATAPI) {
		st->flags |= ST_FIXEDBLOCKS;
		if (st->media_blksize > 0)
			st->blksize = st->media_blksize;
		else
			st->blksize = DEF_FIXED_BSIZE;
		goto done;
	}

	/*
	 * If the drive can only handle fixed-length blocks and only at
	 * one size, perhaps we should just do that.
	 */
	if (st->blkmin && (st->blkmin == st->blkmax)) {
		st->flags |= ST_FIXEDBLOCKS;
		st->blksize = st->blkmin;
		SC_DEBUG(link, SDEV_DB3,
		    ("blkmin == blkmax of %d\n", st->blkmin));
		goto done;
	}
	/*
	 * If the tape density mandates (or even suggests) use of fixed
	 * or variable-length blocks, comply.
	 */
	switch (st->density) {
	case HALFINCH_800:
	case HALFINCH_1600:
	case HALFINCH_6250:
	case DDS:
		st->flags &= ~ST_FIXEDBLOCKS;
		st->blksize = 0;
		SC_DEBUG(link, SDEV_DB3, ("density specified variable\n"));
		goto done;
	case QIC_11:
	case QIC_24:
	case QIC_120:
	case QIC_150:
	case QIC_525:
	case QIC_1320:
		st->flags |= ST_FIXEDBLOCKS;
		if (st->media_blksize > 0)
			st->blksize = st->media_blksize;
		else
			st->blksize = DEF_FIXED_BSIZE;
		SC_DEBUG(link, SDEV_DB3, ("density specified fixed\n"));
		goto done;
	}
	/*
	 * If we're about to read the tape, perhaps we should choose
	 * fixed or variable-length blocks and block size according to
	 * what the drive found on the tape.
	 */
	if (first_read &&
	    (!(st->quirks & ST_Q_BLKSIZE) || (st->media_blksize == 0) ||
	    (st->media_blksize == DEF_FIXED_BSIZE) ||
	    (st->media_blksize == 1024))) {
		if (st->media_blksize > 0)
			st->flags |= ST_FIXEDBLOCKS;
		else
			st->flags &= ~ST_FIXEDBLOCKS;
		st->blksize = st->media_blksize;
		SC_DEBUG(link, SDEV_DB3,
		    ("Used media_blksize of %d\n", st->media_blksize));
		goto done;
	}
	/*
	 * We're getting no hints from any direction.  Choose variable-
	 * length blocks arbitrarily.
	 */
	st->flags &= ~ST_FIXEDBLOCKS;
	st->blksize = 0;
	SC_DEBUG(link, SDEV_DB3,
	    ("Give up and default to variable mode\n"));

done:
	/*
	 * Decide whether or not to write two file marks to signify end-
	 * of-data.  Make the decision as a function of density.  If
	 * the decision is not to use a second file mark, the SCSI BLANK
	 * CHECK condition code will be recognized as end-of-data when
	 * first read.
	 * (I think this should be a by-product of fixed/variable..julian)
	 */
	switch (st->density) {
/*      case 8 mm:   What is the SCSI density code for 8 mm, anyway? */
	case QIC_11:
	case QIC_24:
	case QIC_120:
	case QIC_150:
	case QIC_525:
	case QIC_1320:
		st->flags &= ~ST_2FM_AT_EOD;
		break;
	default:
		st->flags |= ST_2FM_AT_EOD;
	}
	return 0;
}

/*
 * Actually translate the requested transfer into
 * one the physical driver can understand
 * The transfer is described by a buf and will include
 * only one physical transfer.
 */
void
ststrategy(struct buf *bp)
{
	struct scsi_link *link;
	struct st_softc *st;
	int s;

	st = stlookup(STUNIT(bp->b_dev));
	if (st == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}
	if (st->flags & ST_DYING) {
		bp->b_error = ENXIO;
		goto bad;
	}

	link = st->sc_link;

	SC_DEBUG(link, SDEV_DB2, ("ststrategy: %ld bytes @@ blk %lld\n",
	    bp->b_bcount, (long long)bp->b_blkno));

	/*
	 * If it's a null transfer, return immediately.
	 */
	if (bp->b_bcount == 0)
		goto done;
	/*
	 * Odd sized request on fixed drives are verboten
	 */
	if (st->flags & ST_FIXEDBLOCKS) {
		if (bp->b_bcount % st->blksize) {
			printf("%s: bad request, must be multiple of %d\n",
			    st->sc_dev.dv_xname, st->blksize);
			bp->b_error = EIO;
			goto bad;
		}
	}
	/*
	 * as are out-of-range requests on variable drives.
	 */
	else if (bp->b_bcount < st->blkmin ||
		 (st->blkmax && bp->b_bcount > st->blkmax)) {
		printf("%s: bad request, must be between %d and %d\n",
		    st->sc_dev.dv_xname, st->blkmin, st->blkmax);
		bp->b_error = EIO;
		goto bad;
	}

	/*
	 * Place it in the queue of activities for this tape
	 * at the end (a bit silly because we only have on user..
	 * (but it could fork()))
	 */
	bufq_queue(&st->sc_bufq, bp);

	/*
	 * Tell the device to get going on the transfer if it's
	 * not doing anything, otherwise just wait for completion
	 * (All a bit silly if we're only allowing 1 open but..)
	 */
	scsi_xsh_add(&st->sc_xsh);

	device_unref(&st->sc_dev);
	return;
bad:
	bp->b_flags |= B_ERROR;
done:
	/* Set b_resid to indicate no xfer was done. */
	bp->b_resid = bp->b_bcount;
	s = splbio();
	biodone(bp);
	splx(s);
	if (st)
		device_unref(&st->sc_dev);
}

void
ststart(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct st_softc *st = link->device_softc;
	struct buf *bp;
	struct scsi_rw_tape *cmd;
	int s;

	SC_DEBUG(link, SDEV_DB2, ("ststart\n"));

	if (st->flags & ST_DYING) {
		scsi_xs_put(xs);
		return;
	}

	/*
	 * if the device has been unmounted by the user
	 * then throw away all requests until done
	 */
	if (!(st->flags & ST_MOUNTED) ||
	    !(link->flags & SDEV_MEDIA_LOADED)) {
		/* make sure that one implies the other.. */
		link->flags &= ~SDEV_MEDIA_LOADED;
		bufq_drain(&st->sc_bufq);
		scsi_xs_put(xs);
		return;
	}

	for (;;) {
		bp = bufq_dequeue(&st->sc_bufq);
		if (bp == NULL) {
			scsi_xs_put(xs);
			return;
		}

		/*
		 * Only FIXEDBLOCK devices have pending I/O or space
		 * operations.
		 */
		if (st->flags & ST_FIXEDBLOCKS) {
			/*
			 * If we are at a filemark but have not reported it yet
			 * then we should report it now
			 */
			if (st->flags & ST_AT_FILEMARK) {
				if ((bp->b_flags & B_READ) == B_WRITE) {
					/*
					 * Handling of ST_AT_FILEMARK in
					 * st_space will fill in the right file
					 * mark count.
					 * Back up over filemark
					 */
					if (st_space(st, 0, SP_FILEMARKS, 0)) {
						bp->b_flags |= B_ERROR;
						bp->b_resid = bp->b_bcount;
						bp->b_error = EIO;
						s = splbio();
						biodone(bp);
						splx(s);
						continue;
					}
				} else {
					bp->b_resid = bp->b_bcount;
					bp->b_error = 0;
					bp->b_flags &= ~B_ERROR;
					st->flags &= ~ST_AT_FILEMARK;
					s = splbio();
					biodone(bp);
					splx(s);
					continue;	/* seek more work */
				}
			}
		}

		/*
		 * If we are at EIO or EOM but have not reported it
		 * yet then we should report it now.
		 */
		if (st->flags & (ST_EOM_PENDING | ST_EIO_PENDING)) {
			bp->b_resid = bp->b_bcount;
			if (st->flags & ST_EIO_PENDING) {
				bp->b_error = EIO;
				bp->b_flags |= B_ERROR;
			}
			st->flags &= ~(ST_EOM_PENDING | ST_EIO_PENDING);
			s = splbio();
			biodone(bp);
			splx(s);
			continue;	/* seek more work */
		}
		break;
	}

	/*
	 *  Fill out the scsi command
	 */
	cmd = (struct scsi_rw_tape *)xs->cmd;
	bzero(cmd, sizeof(*cmd));
	if ((bp->b_flags & B_READ) == B_WRITE) {
		cmd->opcode = WRITE;
		st->flags &= ~ST_FM_WRITTEN;
		st->flags |= ST_WRITTEN;
		xs->flags |= SCSI_DATA_OUT;
	} else {
		cmd->opcode = READ;
		xs->flags |= SCSI_DATA_IN;
	}

	/*
	 * Handle "fixed-block-mode" tape drives by using the
	 * block count instead of the length.
	 */
	if (st->flags & ST_FIXEDBLOCKS) {
		cmd->byte2 |= SRW_FIXED;
		_lto3b(bp->b_bcount / st->blksize, cmd->len);
	} else
		_lto3b(bp->b_bcount, cmd->len);

	if (st->media_blkno != -1) {
		/* Update block count now, errors will set it to -1. */
		if (st->flags & ST_FIXEDBLOCKS)
			st->media_blkno += _3btol(cmd->len);
		else if (_3btol(cmd->len) != 0)
			st->media_blkno++;
	}

	xs->cmdlen = sizeof(*cmd);
	xs->timeout = ST_IO_TIME;
	xs->data = bp->b_data;
	xs->datalen = bp->b_bcount;
	xs->done = st_buf_done;
	xs->cookie = bp;
	xs->bp = bp;

	/*
	 * go ask the adapter to do all this for us
	 */
	scsi_xs_exec(xs);

	/*
	 * should we try do more work now?
	 */
	if (ISSET(st->flags, ST_WAITING))
		CLR(st->flags, ST_WAITING);
	else if (bufq_peek(&st->sc_bufq))
		scsi_xsh_add(&st->sc_xsh);
}

void
st_buf_done(struct scsi_xfer *xs)
{
	struct st_softc *st = xs->sc_link->device_softc;
	struct buf *bp = xs->cookie;
	int error, s;

	switch (xs->error) {
	case XS_NOERROR:
		bp->b_error = 0;
		bp->b_resid = xs->resid;
		break;

	case XS_NO_CCB:
		/* The adapter is busy, requeue the buf and try it later. */
		bufq_requeue(&st->sc_bufq, bp);
		scsi_xs_put(xs);
		SET(st->flags, ST_WAITING); /* dont let ststart xsh_add */
		timeout_add(&st->sc_timeout, 1);
		return;

	case XS_SENSE:
	case XS_SHORTSENSE:
#ifdef SCSIDEBUG
		scsi_sense_print_debug(xs);
#endif
		error = st_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
			xs->retries = 0;
		goto retry;

	case XS_BUSY:
		if (xs->retries) {
			if (scsi_delay(xs, 1) != ERESTART)
				xs->retries = 0;
		}
		goto retry;

	case XS_TIMEOUT:
retry:
		if (xs->retries--) {
			scsi_xs_exec(xs);
			return;
		}
		/* FALLTHROUGH */

	default:
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		bp->b_resid = bp->b_bcount;
		break;
	}

	s = splbio();
	biodone(bp);
	splx(s);
	scsi_xs_put(xs);
}

void
stminphys(struct buf *bp)
{
	struct st_softc *st;

	st = stlookup(STUNIT(bp->b_dev));
	if (st == NULL)
		return;

	(*st->sc_link->adapter->scsi_minphys)(bp, st->sc_link);

	device_unref(&st->sc_dev);
}

int
stread(dev_t dev, struct uio *uio, int iomode)
{
	return (physio(ststrategy, dev, B_READ, stminphys, uio));
}

int
stwrite(dev_t dev, struct uio *uio, int iomode)
{
	return (physio(ststrategy, dev, B_WRITE, stminphys, uio));
}

/*
 * Perform special action on behalf of the user;
 * knows about the internals of this device
 */
int
stioctl(dev_t dev, u_long cmd, caddr_t arg, int flag, struct proc *p)
{
	int error = 0;
	int nmarks;
	int flags = 0;
	struct st_softc *st;
	int hold_blksize;
	u_int8_t hold_density;
	struct mtop *mt = (struct mtop *) arg;
	int number;

	/*
	 * Find the device that the user is talking about
	 */
	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);

	if (st->flags & ST_DYING) {
		error = ENXIO;
		goto done;
	}

	hold_blksize = st->blksize;
	hold_density = st->density;

	switch (cmd) {

	case MTIOCGET: {
		struct mtget *g = (struct mtget *) arg;

		/*
		 * (to get the current state of READONLY)
		 */
		error = st_mode_sense(st, SCSI_SILENT);
		if (error)
			break;

		SC_DEBUG(st->sc_link, SDEV_DB1, ("[ioctl: get status]\n"));
		bzero(g, sizeof(struct mtget));
		g->mt_type = 0x7;	/* Ultrix compat *//*? */
		g->mt_blksiz = st->blksize;
		g->mt_density = st->density;
		g->mt_mblksiz = st->modes.blksize;
		g->mt_mdensity = st->modes.density;
		if (st->sc_link->flags & SDEV_READONLY)
			g->mt_dsreg |= MT_DS_RDONLY;
		if (st->flags & ST_MOUNTED)
			g->mt_dsreg |= MT_DS_MOUNTED;
		g->mt_resid = st->mt_resid;
		g->mt_erreg = st->mt_erreg;
		g->mt_fileno = st->media_fileno;
		g->mt_blkno = st->media_blkno;
		/*
		 * clear latched errors.
		 */
		st->mt_resid = 0;
		st->mt_erreg = 0;
		break;
	}
	case MTIOCTOP: {

		SC_DEBUG(st->sc_link, SDEV_DB1,
		    ("[ioctl: op=0x%x count=0x%x]\n", mt->mt_op, mt->mt_count));

		number = mt->mt_count;
		switch (mt->mt_op) {
		case MTWEOF:	/* write an end-of-file record */
			error = st_write_filemarks(st, number, flags);
			break;
		case MTBSF:	/* backward space file */
			number = -number;
		case MTFSF:	/* forward space file */
			error = st_check_eod(st, 0, &nmarks, flags);
			if (!error)
				error = st_space(st, number - nmarks,
				    SP_FILEMARKS, flags);
			break;
		case MTBSR:	/* backward space record */
			number = -number;
		case MTFSR:	/* forward space record */
			error = st_check_eod(st, 1, &nmarks, flags);
			if (!error)
				error = st_space(st, number, SP_BLKS, flags);
			break;
		case MTREW:	/* rewind */
			error = st_rewind(st, 0, flags);
			break;
		case MTOFFL:	/* rewind and put the drive offline */
			st_unmount(st, EJECT, DOREWIND);
			break;
		case MTNOP:	/* no operation, sets status only */
			break;
		case MTRETEN:	/* retension the tape */
			error = st_load(st, LD_RETENSION, flags);
			if (!error)
				error = st_load(st, LD_LOAD, flags);
			break;
		case MTEOM:	/* forward space to end of media */
			error = st_check_eod(st, 0, &nmarks, flags);
			if (!error)
				error = st_space(st, 1, SP_EOM, flags);
			break;
		case MTCACHE:	/* enable controller cache */
			st->flags &= ~ST_DONTBUFFER;
			goto try_new_value;
		case MTNOCACHE:	/* disable controller cache */
			st->flags |= ST_DONTBUFFER;
			goto try_new_value;
		case MTERASE:	/* erase volume */
			error = st_erase(st, number, flags);
			break;
		case MTSETBSIZ:	/* Set block size for device */
			if (number == 0) {
				st->flags &= ~ST_FIXEDBLOCKS;
			} else {
				if ((st->blkmin || st->blkmax) &&
				    (number < st->blkmin ||
				    number > st->blkmax)) {
					error = EINVAL;
					break;
				}
				st->flags |= ST_FIXEDBLOCKS;
			}
			st->blksize = number;
			st->flags |= ST_BLOCK_SET;	/*XXX */
			goto try_new_value;

		case MTSETDNSTY:	/* Set density for device and mode */
			if (number < 0 || number > SCSI_MAX_DENSITY_CODE) {
				error = EINVAL;
				break;
			} else
				st->density = number;
			goto try_new_value;

		default:
			error = EINVAL;
		}
		break;
	}
	case MTIOCIEOT:
	case MTIOCEEOT:
		break;

#if 0
	case MTIOCRDSPOS:
		error = st_rdpos(st, 0, (u_int32_t *) arg);
		break;

	case MTIOCRDHPOS:
		error = st_rdpos(st, 1, (u_int32_t *) arg);
		break;

	case MTIOCSLOCATE:
		error = st_setpos(st, 0, (u_int32_t *) arg);
		break;

	case MTIOCHLOCATE:
		error = st_setpos(st, 1, (u_int32_t *) arg);
		break;
#endif

	default:
		error = scsi_do_ioctl(st->sc_link, cmd, arg, flag);
		break;
	}
	goto done;

try_new_value:
	/*
	 * Check that the mode being asked for is aggreeable to the
	 * drive. If not, put it back the way it was.
	 */
	if ((error = st_mode_select(st, 0)) != 0) {/* put it back as it was */
		printf("%s: cannot set selected mode\n", st->sc_dev.dv_xname);
		st->density = hold_density;
		st->blksize = hold_blksize;
		if (st->blksize)
			st->flags |= ST_FIXEDBLOCKS;
		else
			st->flags &= ~ST_FIXEDBLOCKS;
		goto done;
	}
	/*
	 * As the drive liked it, if we are setting a new default,
	 * set it into the structures as such.
	 */
	switch (mt->mt_op) {
	case MTSETBSIZ:
		st->modes.blksize = st->blksize;
		st->modeflags |= BLKSIZE_SET_BY_USER;
		break;
	case MTSETDNSTY:
		st->modes.density = st->density;
		st->modeflags |= DENSITY_SET_BY_USER;
		break;
	}

done:
	device_unref(&st->sc_dev);
	return (error);
}

/*
 * Do a synchronous read.
 */
int
st_read(struct st_softc *st, char *buf, int size, int flags)
{
	struct scsi_rw_tape *cmd;
	struct scsi_xfer *xs;
	int error;

	if (size == 0)
		return 0;

	xs = scsi_xs_get(st->sc_link, flags | SCSI_DATA_IN);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->data = buf;
	xs->datalen = size;
	xs->retries = 0;
	xs->timeout = ST_IO_TIME;

	cmd = (struct scsi_rw_tape *)xs->cmd;
	cmd->opcode = READ;
	if (st->flags & ST_FIXEDBLOCKS) {
		cmd->byte2 |= SRW_FIXED;
		_lto3b(size / (st->blksize ? st->blksize : DEF_FIXED_BSIZE),
		    cmd->len);
	} else
		_lto3b(size, cmd->len);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * Ask the drive what its min and max blk sizes are.
 */
int
st_read_block_limits(struct st_softc *st, int flags)
{
	struct scsi_block_limits_data *block_limits = NULL;
	struct scsi_block_limits *cmd;
	struct scsi_link *link = st->sc_link;
	struct scsi_xfer *xs;
	int error = 0;

	if ((link->flags & SDEV_MEDIA_LOADED))
		return (0);

	block_limits = dma_alloc(sizeof(*block_limits), PR_NOWAIT);
	if (block_limits == NULL)
		return (ENOMEM);

	xs = scsi_xs_get(link, flags | SCSI_DATA_IN);
	if (xs == NULL) {
		error = ENOMEM;
		goto done;
	}

	xs->cmdlen = sizeof(*cmd);
	xs->data = (void *)block_limits;
	xs->datalen = sizeof(*block_limits);
	xs->timeout = ST_CTL_TIME;

	cmd = (struct scsi_block_limits *)xs->cmd;
	cmd->opcode = READ_BLOCK_LIMITS;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		st->blkmin = _2btol(block_limits->min_length);
		st->blkmax = _3btol(block_limits->max_length);
		SC_DEBUG(link, SDEV_DB3,
		    ("(%d <= blksize <= %d)\n", st->blkmin, st->blkmax));
	}

done:
	if (block_limits)
		dma_free(block_limits, sizeof(*block_limits));
	return (error);
}

/*
 * Get the scsi driver to send a full inquiry to the
 * device and use the results to fill out the global
 * parameter structure.
 *
 * called from:
 * attach
 * open
 * ioctl (to reset original blksize)
 */
int
st_mode_sense(struct st_softc *st, int flags)
{
	union scsi_mode_sense_buf *data = NULL;
	struct scsi_link *link = st->sc_link;
	u_int64_t block_count;
	u_int32_t density, block_size;
	u_char *page0 = NULL;
	u_int8_t dev_spec;
	int error = 0, big;

	data = dma_alloc(sizeof(*data), PR_NOWAIT);
	if (data == NULL)
		return (ENOMEM);

	/*
	 * Ask for page 0 (vendor specific) mode sense data.
	 */
	error = scsi_do_mode_sense(link, 0, data, (void **)&page0,
	    &density, &block_count, &block_size, 1, flags | SCSI_SILENT, &big);
	if (error != 0)
		goto done;

	/* It is valid for no page0 to be available. */

	if (big)
		dev_spec = data->hdr_big.dev_spec;
	else
		dev_spec = data->hdr.dev_spec;

	if (dev_spec & SMH_DSP_WRITE_PROT)
		SET(link->flags, SDEV_READONLY);
	else
		CLR(link->flags, SDEV_READONLY);

	st->numblks = block_count;
	st->media_blksize = block_size;
	st->media_density = density;

	SC_DEBUG(link, SDEV_DB3,
	    ("density code 0x%x, %d-byte blocks, write-%s, ",
	    st->media_density, st->media_blksize,
	    link->flags & SDEV_READONLY ? "protected" : "enabled"));
	SC_DEBUGN(link, SDEV_DB3,
	    ("%sbuffered\n", dev_spec & SMH_DSP_BUFF_MODE ? "" : "un"));

	link->flags |= SDEV_MEDIA_LOADED;

done:
	if (data)
		dma_free(data, sizeof(*data));
	return (error);
}

/*
 * Send a filled out parameter structure to the drive to
 * set it into the desire modes etc.
 */
int
st_mode_select(struct st_softc *st, int flags)
{
	union scsi_mode_sense_buf *inbuf = NULL, *outbuf = NULL;
	struct scsi_blk_desc general;
	struct scsi_link *link = st->sc_link;
	u_int8_t *page0 = NULL;
	int error = 0, big, page0_size;

	inbuf = dma_alloc(sizeof(*inbuf), PR_NOWAIT);
	if (inbuf == NULL) {
		error = ENOMEM;
		goto done;
	}
	outbuf = dma_alloc(sizeof(*outbuf), PR_NOWAIT | PR_ZERO);
	if (outbuf == NULL) {
		error = ENOMEM;
		goto done;
	}

	/*
	 * This quirk deals with drives that have only one valid mode and think
	 * this gives them license to reject all mode selects, even if the
	 * selected mode is the one that is supported.
	 */
	if (st->quirks & ST_Q_UNIMODAL) {
		SC_DEBUG(link, SDEV_DB3,
		    ("not setting density 0x%x blksize 0x%x\n",
		    st->density, st->blksize));
		error = 0;
		goto done;
	}

	if (link->flags & SDEV_ATAPI) {
		error = 0;
		goto done;
	}

	bzero(&general, sizeof(general));

	general.density = st->density;
	if (st->flags & ST_FIXEDBLOCKS)
		_lto3b(st->blksize, general.blklen);

	/*
	 * Ask for page 0 (vendor specific) mode sense data.
	 */
	error = scsi_do_mode_sense(link, 0, inbuf, (void **)&page0, NULL,
	    NULL, NULL, 1, flags | SCSI_SILENT, &big);
	if (error != 0)
		goto done;

	if (page0 == NULL) {
		page0_size = 0;
	} else if (big == 0) {
		page0_size = inbuf->hdr.data_length +
		    sizeof(inbuf->hdr.data_length) - sizeof(inbuf->hdr) -
		    inbuf->hdr.blk_desc_len;
		memcpy(&outbuf->buf[sizeof(outbuf->hdr)+ sizeof(general)],
		    page0, page0_size);
	} else {
		page0_size = _2btol(inbuf->hdr_big.data_length) +
		    sizeof(inbuf->hdr_big.data_length) -
		    sizeof(inbuf->hdr_big) -
		   _2btol(inbuf->hdr_big.blk_desc_len);
		memcpy(&outbuf->buf[sizeof(outbuf->hdr_big) + sizeof(general)],
		    page0, page0_size);
	}

	/*
	 * Set up for a mode select.
	 */
	if (big == 0) {
		outbuf->hdr.data_length = sizeof(outbuf->hdr) +
		    sizeof(general) + page0_size -
		    sizeof(outbuf->hdr.data_length);
		if ((st->flags & ST_DONTBUFFER) == 0)
			outbuf->hdr.dev_spec = SMH_DSP_BUFF_MODE_ON;
		outbuf->hdr.blk_desc_len = sizeof(general);
		memcpy(&outbuf->buf[sizeof(outbuf->hdr)],
		    &general, sizeof(general));
		error = scsi_mode_select(st->sc_link, 0, &outbuf->hdr,
		    flags, ST_CTL_TIME);
		goto done;
	}

	/* MODE SENSE (10) header was returned, so use MODE SELECT (10). */
	_lto2b((sizeof(outbuf->hdr_big) + sizeof(general) + page0_size -
	    sizeof(outbuf->hdr_big.data_length)), outbuf->hdr_big.data_length);
	if ((st->flags & ST_DONTBUFFER) == 0)
		outbuf->hdr_big.dev_spec = SMH_DSP_BUFF_MODE_ON;
	_lto2b(sizeof(general), outbuf->hdr_big.blk_desc_len);
	memcpy(&outbuf->buf[sizeof(outbuf->hdr_big)], &general,
	    sizeof(general));

	error = scsi_mode_select_big(st->sc_link, 0, &outbuf->hdr_big,
	    flags, ST_CTL_TIME);
done:
	if (inbuf)
		dma_free(inbuf, sizeof(*inbuf));
	if (outbuf)
		dma_free(outbuf, sizeof(*outbuf));
	return (error);
}

/*
 * issue an erase command
 */
int
st_erase(struct st_softc *st, int full, int flags)
{
	struct scsi_erase *cmd;
	struct scsi_xfer *xs;
	int error;

	xs = scsi_xs_get(st->sc_link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);

	/*
	 * Full erase means set LONG bit in erase command, which asks
	 * the drive to erase the entire unit.  Without this bit, we're
	 * asking the drive to write an erase gap.
	 */
	cmd = (struct scsi_erase *)xs->cmd;
	cmd->opcode = ERASE;
	if (full) {
		cmd->byte2 = SE_IMMED|SE_LONG;
		xs->timeout = ST_SPC_TIME;
	} else {
		cmd->byte2 = SE_IMMED;
		xs->timeout = ST_IO_TIME;
	}

	/*
	 * XXX We always do this asynchronously, for now.  How long should
	 * we wait if we want to (eventually) to it synchronously?
	 */
	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 * skip N blocks/filemarks/seq filemarks/eom
 */
int
st_space(struct st_softc *st, int number, u_int what, int flags)
{
	struct scsi_space *cmd;
	struct scsi_xfer *xs;
	int error;

	switch (what) {
	case SP_BLKS:
		if (st->flags & ST_PER_ACTION) {
			if (number > 0) {
				st->flags &= ~ST_PER_ACTION;
				return EIO;
			} else if (number < 0) {
				if (st->flags & ST_AT_FILEMARK) {
					/*
					 * Handling of ST_AT_FILEMARK
					 * in st_space will fill in the
					 * right file mark count.
					 */
					error = st_space(st, 0, SP_FILEMARKS,
						flags);
					if (error)
						return error;
				}
				if (st->flags & ST_BLANK_READ) {
					st->flags &= ~ST_BLANK_READ;
					return EIO;
				}
				st->flags &= ~(ST_EIO_PENDING | ST_EOM_PENDING);
			}
		}
		break;
	case SP_FILEMARKS:
		if (st->flags & ST_EIO_PENDING) {
			if (number > 0) {
				/* pretend we just discovered the error */
				st->flags &= ~ST_EIO_PENDING;
				return EIO;
			} else if (number < 0) {
				/* back away from the error */
				st->flags &= ~ST_EIO_PENDING;
			}
		}
		if (st->flags & ST_AT_FILEMARK) {
			st->flags &= ~ST_AT_FILEMARK;
			number--;
		}
		if ((st->flags & ST_BLANK_READ) && (number < 0)) {
			/* back away from unwritten tape */
			st->flags &= ~ST_BLANK_READ;
			number++;	/* XXX dubious */
		}
		break;
	case SP_EOM:
		if (st->flags & ST_EOM_PENDING) {
			/* We are already there. */
			st->flags &= ~ST_EOM_PENDING;
			return (0);
		}
		if (st->flags & ST_EIO_PENDING) {
			/* pretend we just discovered the error */
			st->flags &= ~ST_EIO_PENDING;
			return EIO;
		}
		if (st->flags & ST_AT_FILEMARK)
			st->flags &= ~ST_AT_FILEMARK;
		break;
	}
	if (number == 0)
		return 0;

	xs = scsi_xs_get(st->sc_link, flags);
	if (xs == NULL)
		return (ENOMEM);

	cmd = (struct scsi_space *)xs->cmd;
	cmd->opcode = SPACE;
	cmd->byte2 = what;
	_lto3b(number, cmd->number);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = ST_SPC_TIME;

	CLR(st->flags, ST_EOD_DETECTED);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0) {
		st->media_fileno = -1;
		st->media_blkno = -1;
	} else {
		switch (what) {
		case SP_BLKS:
			if (st->media_blkno != -1) {
				st->media_blkno += number;
				if (st->media_blkno < 0)
					st->media_blkno = -1;
			}
			break;
		case SP_FILEMARKS:
			if (st->media_fileno != -1) {
				if (!ISSET(st->flags, ST_EOD_DETECTED))
					st->media_fileno += number;
				if (st->media_fileno > st->media_eom)
					st->media_eom = st->media_fileno;
				st->media_blkno = 0;
			}
			break;
		case SP_EOM:
			if (st->media_eom != -1) {
				st->media_fileno = st->media_eom;
				st->media_blkno = 0;
			} else {
				st->media_fileno = -1;
				st->media_blkno = -1;
			}
			break;
		default:
			st->media_fileno = -1;
			st->media_blkno = -1;
			break;
		}
	}

	return (error);
}

/*
 * write N filemarks
 */
int
st_write_filemarks(struct st_softc *st, int number, int flags)
{
	struct scsi_write_filemarks *cmd;
	struct scsi_xfer *xs;
	int error;

	if (number < 0)
		return (EINVAL);

	xs = scsi_xs_get(st->sc_link, flags);
	if (xs == NULL)
		return (ENOMEM);

	xs->cmdlen = sizeof(*cmd);
	xs->timeout = ST_IO_TIME * 4;

	switch (number) {
	case 0:		/* really a command to sync the drive's buffers */
		break;
	case 1:
		if (st->flags & ST_FM_WRITTEN)	/* already have one down */
			st->flags &= ~ST_WRITTEN;
		else
			st->flags |= ST_FM_WRITTEN;
		st->flags &= ~ST_PER_ACTION;
		break;
	default:
		st->flags &= ~(ST_PER_ACTION | ST_WRITTEN);
		break;
	}

	cmd = (struct scsi_write_filemarks *)xs->cmd;
	cmd->opcode = WRITE_FILEMARKS;
	_lto3b(number, cmd->number);

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error != 0) {
		st->media_fileno = -1;
		st->media_blkno = -1;
		st->media_eom = -1;
	} else if (st->media_fileno != -1) {
		st->media_fileno += number;
		st->media_eom = st->media_fileno;
		st->media_blkno = 0;
	}

	return (error);
}

/*
 * Make sure the right number of file marks is on tape if the
 * tape has been written.  If the position argument is true,
 * leave the tape positioned where it was originally.
 *
 * nmarks returns the number of marks to skip (or, if position
 * true, which were skipped) to get back original position.
 */
int
st_check_eod(struct st_softc *st, int position, int *nmarks, int flags)
{
	int error;

	switch (st->flags & (ST_WRITTEN | ST_FM_WRITTEN | ST_2FM_AT_EOD)) {
	default:
		*nmarks = 0;
		return 0;
	case ST_WRITTEN:
	case ST_WRITTEN | ST_FM_WRITTEN | ST_2FM_AT_EOD:
		*nmarks = 1;
		break;
	case ST_WRITTEN | ST_2FM_AT_EOD:
		*nmarks = 2;
	}
	error = st_write_filemarks(st, *nmarks, flags);
	if (position && !error)
		error = st_space(st, -*nmarks, SP_FILEMARKS, flags);
	return error;
}

/*
 * load/unload/retension
 */
int
st_load(struct st_softc *st, u_int type, int flags)
{
	struct scsi_load *cmd;
	struct scsi_xfer *xs;
	int error, nmarks;

	st->media_fileno = -1;
	st->media_blkno = -1;
	st->media_eom = -1;

	if (type != LD_LOAD) {
		error = st_check_eod(st, 0, &nmarks, flags);
		if (error)
			return (error);
	}

	if (st->quirks & ST_Q_IGNORE_LOADS) {
		if (type == LD_LOAD) {
			/*
			 * If we ignore loads, at least we should try a rewind.
			 */
			return (st_rewind(st, 0, flags));
		}
		return (0);
	}


	xs = scsi_xs_get(st->sc_link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = ST_SPC_TIME;

	cmd = (struct scsi_load *)xs->cmd;
	cmd->opcode = LOAD;
	cmd->how = type;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	return (error);
}

/*
 *  Rewind the device
 */
int
st_rewind(struct st_softc *st, u_int immediate, int flags)
{
	struct scsi_rewind *cmd;
	struct scsi_xfer *xs;
	int error, nmarks;

	error = st_check_eod(st, 0, &nmarks, flags);
	if (error)
		return (error);
	st->flags &= ~ST_PER_ACTION;

	xs = scsi_xs_get(st->sc_link, flags);
	if (xs == NULL)
		return (ENOMEM);
	xs->cmdlen = sizeof(*cmd);
	xs->timeout = immediate ? ST_CTL_TIME : ST_SPC_TIME;

	cmd = (struct scsi_rewind *)xs->cmd;
	cmd->opcode = REWIND;
	cmd->byte2 = immediate;

	error = scsi_xs_sync(xs);
	scsi_xs_put(xs);

	if (error == 0) {
		st->media_fileno = 0;
		st->media_blkno = 0;
	}

	return (error);
}

/*
 * Look at the returned sense and act on the error and detirmine
 * The unix error number to pass back... (0 = report no error)
 *                            (-1 = continue processing)
 */
int
st_interpret_sense(struct scsi_xfer *xs)
{
	struct scsi_sense_data *sense = &xs->sense;
	struct scsi_link *link = xs->sc_link;
	struct scsi_space *space;
	struct st_softc *st = link->device_softc;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	u_int8_t skey = sense->flags & SSD_KEY;
	int32_t resid, info, number;
	int datalen;

	if (((link->flags & SDEV_OPEN) == 0) ||
	    (serr != SSD_ERRCODE_CURRENT && serr != SSD_ERRCODE_DEFERRED))
		return (scsi_interpret_sense(xs));

	info = (int32_t)_4btol(sense->info);

	switch (skey) {

	/*
	 * We do custom processing in st for the unit becoming ready case.
	 * in this case we do not allow xs->retries to be decremented
	 * only on the "Unit Becoming Ready" case. This is because tape
	 * drives report "Unit Becoming Ready" when loading media, etc.
	 * and can take a long time.  Rather than having a massive timeout
	 * for all operations (which would cause other problems) we allow
	 * operations to wait (but be interruptable with Ctrl-C) forever
	 * as long as the drive is reporting that it is becoming ready.
	 * all other cases are handled as per the default.
	 */

	case SKEY_NOT_READY:
		if ((xs->flags & SCSI_IGNORE_NOT_READY) != 0)
			return (0);
		switch (ASC_ASCQ(sense)) {
		case SENSE_NOT_READY_BECOMING_READY:
			SC_DEBUG(link, SDEV_DB1, ("not ready: busy (%#x)\n",
			    sense->add_sense_code_qual));
			/* don't count this as a retry */
			xs->retries++;
			return (scsi_delay(xs, 1));
		default:
			return (scsi_interpret_sense(xs));
		}
		break;
	case SKEY_BLANK_CHECK:
		if (sense->error_code & SSD_ERRCODE_VALID &&
		    xs->cmd->opcode == SPACE) {
			switch (ASC_ASCQ(sense)) {
			case SENSE_END_OF_DATA_DETECTED:
				st->flags |= ST_EOD_DETECTED;
				space = (struct scsi_space *)xs->cmd;
				number = _3btol(space->number);
				st->media_fileno = number - info;
				st->media_eom = st->media_fileno;
				return (0);
			case SENSE_BEGINNING_OF_MEDIUM_DETECTED:
				/* Standard says: Position is undefined! */
				st->flags |= ST_BOD_DETECTED;
				st->media_fileno = -1;
				st->media_blkno = -1;
				return (0);
			}
		}
		break;
	case SKEY_NO_SENSE:
	case SKEY_RECOVERED_ERROR:
	case SKEY_MEDIUM_ERROR:
	case SKEY_VOLUME_OVERFLOW:
		break;
	default:
		return (scsi_interpret_sense(xs));
	}

	/*
	 * 'resid' can be in units of st->blksize or bytes. xs->resid and
	 * xs->datalen are always in units of bytes. So we need a variable
	 * to store datalen in the same units as resid and to adjust
	 * xs->resid to be in bytes.
	 */
	if (sense->error_code & SSD_ERRCODE_VALID) {
		if (st->flags & ST_FIXEDBLOCKS)
			resid = info * st->blksize; /* XXXX overflow? */
		else
			resid = info;
	} else {
		resid = xs->datalen;
	}

	if (resid < 0 || resid > xs->datalen)
		xs->resid = xs->datalen;
	else
		xs->resid = resid;

	datalen = xs->datalen;
	if (st->flags & ST_FIXEDBLOCKS) {
		resid /= st->blksize;
		datalen /= st->blksize;
	}

	if (sense->flags & SSD_FILEMARK) {
		if (st->media_fileno != -1) {
			st->media_fileno++;
			if (st->media_fileno > st->media_eom)
				st->media_eom = st->media_fileno;
			st->media_blkno = 0;
		}
		if ((st->flags & ST_FIXEDBLOCKS) == 0)
			return 0;
		st->flags |= ST_AT_FILEMARK;
	}

	if (sense->flags & SSD_EOM) {
		st->flags |= ST_EOM_PENDING;
		xs->resid = 0;
		if (st->flags & ST_FIXEDBLOCKS)
			return (0);
	}

	if (sense->flags & SSD_ILI) {
		if ((st->flags & ST_FIXEDBLOCKS) == 0) {
			if (resid >= 0 && resid <= datalen)
				return (0);
			if ((xs->flags & SCSI_SILENT) == 0)
				printf( "%s: bad residual %d out of "
				    "%d\n", st->sc_dev.dv_xname, resid,
				    datalen);
			return (EIO);
		}

		/* Fixed size blocks. */
		if (sense->error_code & SSD_ERRCODE_VALID)
			if ((xs->flags & SCSI_SILENT) == 0)
				printf("%s: block wrong size, %d blocks "
				    "residual\n", st->sc_dev.dv_xname, resid);
		st->flags |= ST_EIO_PENDING;
		/*
                 * This quirk code helps the drive read the first tape block,
		 * regardless of format.  That is required for these drives to
		 * return proper MODE SENSE information.
		 */
		if ((st->quirks & ST_Q_SENSE_HELP) &&
		    !(link->flags & SDEV_MEDIA_LOADED))
			st->blksize -= 512;
	}

	if ((st->flags & ST_FIXEDBLOCKS) && xs->resid == xs->datalen) {
		if (st->flags & ST_EIO_PENDING)
			return EIO;
		if (st->flags & ST_AT_FILEMARK)
			return 0;
	}

	if (skey == SKEY_BLANK_CHECK) {
		/*
		 * This quirk code helps the drive read the first tape block,
		 * regardless of format.  That is required for these drives to
		 * return proper MODE SENSE information.
		 */
		if ((st->quirks & ST_Q_SENSE_HELP) &&
		    !(link->flags & SDEV_MEDIA_LOADED)) {
			/* still starting */
			st->blksize -= 512;
		} else if (!(st->flags & (ST_2FM_AT_EOD | ST_BLANK_READ))) {
			st->flags |= ST_BLANK_READ;
			st->flags |= ST_EOM_PENDING;
			xs->resid = xs->datalen;
			return (0);
		}
	}

	return (scsi_interpret_sense(xs));
}

/*
 * The quirk here is that the drive returns some value to st_mode_sense
 * incorrectly until the tape has actually passed by the head.
 *
 * The method is to set the drive to large fixed-block state (user-specified
 * density and 1024-byte blocks), then read and rewind to get it to sense the
 * tape.  If that doesn't work, try 512-byte fixed blocks.  If that doesn't
 * work, as a last resort, try variable- length blocks.  The result will be
 * the ability to do an accurate st_mode_sense.
 *
 * We know we can do a rewind because we just did a load, which implies rewind.
 * Rewind seems preferable to space backward if we have a virgin tape.
 *
 * The rest of the code for this quirk is in ILI processing and BLANK CHECK
 * error processing, both part of st_interpret_sense.
 */
int
st_touch_tape(struct st_softc *st)
{
	char *buf = NULL;
	int readsize, maxblksize = 1024;
	int error = 0;

	if ((error = st_mode_sense(st, 0)) != 0)
		goto done;
	buf = dma_alloc(maxblksize, PR_NOWAIT);
	if (!buf) {
		error = ENOMEM;
		goto done;
	}

	st->blksize = 1024;
	do {
		switch (st->blksize) {
		case 512:
		case 1024:
			readsize = st->blksize;
			st->flags |= ST_FIXEDBLOCKS;
			break;
		default:
			readsize = 1;
			st->flags &= ~ST_FIXEDBLOCKS;
		}
		if ((error = st_mode_select(st, 0)) != 0)
			goto done;
		st_read(st, buf, readsize, SCSI_SILENT);	/* XXX */
		if ((error = st_rewind(st, 0, 0)) != 0)
			goto done;
	} while (readsize != 1 && readsize > st->blksize);
done:
	dma_free(buf, maxblksize);
	return (error);
}
@


1.131
log
@Standardize on calling local scsi_link variables 'link' instead of
'sc_link'. 'sc_link' is a field in the various device *_softc
structures, where the sc_ prefix was for 'softc'. Reduces potential
mental confusion. Newer code from down under was already using
'link'.

No functional change.

Prompted by bluhm@@'s adventures in scsi. ok dlg@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.130 2016/03/11 17:12:17 krw Exp $	*/
d372 1
a372 1
	int bmaj, cmaj, mn;
a378 3
	for (bmaj = 0; bmaj < nblkdev; bmaj++)
		if (bdevsw[bmaj].d_open == stopen)
			vdevgone(bmaj, mn, mn + MAXSTMODES - 1, VBLK);
a2175 8
}

int
stdump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{

	/* Not implemented. */
	return ENXIO;
@


1.130
log
@"if (_3btol(cmd->len) != 0)" is more likely to be a useful test than
"if (cmd->len) != 0)", as cmd->len is a 3 byte array.

Broken since media_blkno accounting was introduced in r1.72 (2007!).
Might fix some obscure tape issues around miscounting variable sized blocks.

Spotted by mmcc@@ and his friend clang.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.129 2015/06/07 19:13:27 krw Exp $	*/
d314 1
a314 1
	struct scsi_link *sc_link = sa->sa_sc_link;
d316 1
a316 1
	SC_DEBUG(sc_link, SDEV_DB2, ("stattach:\n"));
d321 3
a323 3
	st->sc_link = sc_link;
	sc_link->interpret_sense = st_interpret_sense;
	sc_link->device_softc = st;
d332 1
a332 1
	scsi_xsh_set(&st->sc_xsh, sc_link, ststart);
d349 1
a349 1
	sc_link->flags &= ~SDEV_MEDIA_LOADED;
d446 1
a446 1
	struct scsi_link *sc_link;
d453 1
a453 1
	sc_link = st->sc_link;
d459 1
a459 1
	if (ISSET(flags, FWRITE) && ISSET(sc_link->flags, SDEV_READONLY)) {
d464 1
a464 1
	SC_DEBUG(sc_link, SDEV_DB1, ("open: dev=0x%x (unit %d (of %d))\n", dev,
d470 2
a471 2
	if (sc_link->flags & SDEV_OPEN) {
		SC_DEBUG(sc_link, SDEV_DB4, ("already open\n"));
d477 1
a477 1
	sc_link->flags |= SDEV_OPEN;
d483 1
a483 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES,
d490 1
a490 1
	if ((sc_link->flags & SDEV_MEDIA_LOADED) == 0)
d494 1
a494 1
		sc_link->flags &= ~SDEV_OPEN;
d501 1
a501 1
			sc_link->flags &= ~SDEV_OPEN;
d515 1
a515 1
	SC_DEBUG(sc_link, SDEV_DB2, ("open complete\n"));
d527 1
a527 1
	struct scsi_link *sc_link;
d538 1
a538 1
	sc_link = st->sc_link;
d540 1
a540 1
	SC_DEBUG(sc_link, SDEV_DB1, ("closing\n"));
d554 1
a554 1
		if (!(sc_link->flags & SDEV_MEDIA_LOADED))
d561 1
a561 1
	sc_link->flags &= ~SDEV_OPEN;
d579 1
a579 1
	struct scsi_link *sc_link;
d589 1
a589 1
	sc_link = st->sc_link;
d591 1
a591 1
	SC_DEBUG(sc_link, SDEV_DB1, ("mounting\n"));
d611 1
a611 1
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES, SCSI_SILENT);
d624 1
a624 1
	if (!(sc_link->flags & SDEV_ATAPI) &&
d664 1
a664 1
	scsi_prevent(sc_link, PR_PREVENT,
d667 1
a667 1
	sc_link->flags |= SDEV_MEDIA_LOADED;	/* move earlier? */
d686 1
a686 1
	struct scsi_link *sc_link = st->sc_link;
d694 1
a694 1
	SC_DEBUG(sc_link, SDEV_DB1, ("unmounting\n"));
d698 1
a698 1
	scsi_prevent(sc_link, PR_ALLOW,
d703 1
a703 1
	sc_link->flags &= ~SDEV_MEDIA_LOADED;
d714 1
a714 1
	struct scsi_link *sc_link = st->sc_link;
d716 1
a716 1
	SC_DEBUG(sc_link, SDEV_DB2, ("starting block mode decision\n"));
d719 1
a719 1
	if (sc_link->flags & SDEV_ATAPI) {
d735 1
a735 1
		SC_DEBUG(sc_link, SDEV_DB3,
d750 1
a750 1
		SC_DEBUG(sc_link, SDEV_DB3, ("density specified variable\n"));
d763 1
a763 1
		SC_DEBUG(sc_link, SDEV_DB3, ("density specified fixed\n"));
d780 1
a780 1
		SC_DEBUG(sc_link, SDEV_DB3,
d790 1
a790 1
	SC_DEBUG(sc_link, SDEV_DB3,
d827 1
a827 1
	struct scsi_link *sc_link;
d841 1
a841 1
	sc_link = st->sc_link;
d843 1
a843 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ststrategy: %ld bytes @@ blk %lld\n",
d904 2
a905 2
	struct scsi_link *sc_link = xs->sc_link;
	struct st_softc *st = sc_link->device_softc;
d910 1
a910 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ststart\n"));
d922 1
a922 1
	    !(sc_link->flags & SDEV_MEDIA_LOADED)) {
d924 1
a924 1
		sc_link->flags &= ~SDEV_MEDIA_LOADED;
d1394 1
a1394 1
	struct scsi_link *sc_link = st->sc_link;
d1398 1
a1398 1
	if ((sc_link->flags & SDEV_MEDIA_LOADED))
d1405 1
a1405 1
	xs = scsi_xs_get(sc_link, flags | SCSI_DATA_IN);
d1425 1
a1425 1
		SC_DEBUG(sc_link, SDEV_DB3,
d1449 1
a1449 1
	struct scsi_link *sc_link = st->sc_link;
d1463 1
a1463 1
	error = scsi_do_mode_sense(sc_link, 0, data, (void **)&page0,
d1476 1
a1476 1
		SET(sc_link->flags, SDEV_READONLY);
d1478 1
a1478 1
		CLR(sc_link->flags, SDEV_READONLY);
d1484 1
a1484 1
	SC_DEBUG(sc_link, SDEV_DB3,
d1487 2
a1488 2
	    sc_link->flags & SDEV_READONLY ? "protected" : "enabled"));
	SC_DEBUGN(sc_link, SDEV_DB3,
d1491 1
a1491 1
	sc_link->flags |= SDEV_MEDIA_LOADED;
d1508 1
a1508 1
	struct scsi_link *sc_link = st->sc_link;
d1529 1
a1529 1
		SC_DEBUG(sc_link, SDEV_DB3,
d1536 1
a1536 1
	if (sc_link->flags & SDEV_ATAPI) {
d1550 1
a1550 1
	error = scsi_do_mode_sense(sc_link, 0, inbuf, (void **)&page0, NULL,
d1956 1
a1956 1
	struct scsi_link *sc_link = xs->sc_link;
d1958 1
a1958 1
	struct st_softc *st = sc_link->device_softc;
d1964 1
a1964 1
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
d1989 1
a1989 1
			SC_DEBUG(sc_link, SDEV_DB1, ("not ready: busy (%#x)\n",
d2095 1
a2095 1
		    !(sc_link->flags & SDEV_MEDIA_LOADED))
d2113 1
a2113 1
		    !(sc_link->flags & SDEV_MEDIA_LOADED)) {
@


1.129
log
@More damned eye searing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.128 2014/12/16 18:30:04 tedu Exp $	*/
d1024 1
a1024 1
		else if (cmd->len != 0)
@


1.128
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.127 2014/09/14 14:17:26 jsg Exp $	*/
d335 1
a335 1
	
d1188 2
a1189 2
 		g->mt_mblksiz = st->modes.blksize;
 		g->mt_mdensity = st->modes.density;
d2035 1
a2035 1
			resid = info * st->blksize; /* XXXX overflow? */ 
@


1.127
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.126 2013/11/01 17:36:19 krw Exp $	*/
d657 1
a657 1
		if ((error = st_decide_mode(st, FALSE)) != 0)
d695 1
a695 1
	st_check_eod(st, FALSE, &nmarks, SCSI_IGNORE_NOT_READY);
d1218 1
a1218 1
			error = st_check_eod(st, FALSE, &nmarks, flags);
d1226 1
a1226 1
			error = st_check_eod(st, TRUE, &nmarks, flags);
d1244 1
a1244 1
			error = st_check_eod(st, FALSE, &nmarks, flags);
d1879 1
a1879 1
		error = st_check_eod(st, FALSE, &nmarks, flags);
d1921 1
a1921 1
	error = st_check_eod(st, FALSE, &nmarks, flags);
@


1.126
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.125 2013/10/03 14:07:42 krw Exp $	*/
a66 1
#include <sys/proc.h>
@


1.125
log
@Print daddr_t variables with %lld, u_int64_t variables with %llu.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.124 2013/07/05 01:22:25 krw Exp $	*/
d845 1
a845 1
	    bp->b_bcount, bp->b_blkno));
@


1.124
log
@Tweak calculations of resid to avoid unsigned vs signed comparison and
make code clearer.

Pointed out by brad@@ and his friend llvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.123 2013/06/11 16:42:17 deraadt Exp $	*/
d844 1
a844 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ststrategy: %ld bytes @@ blk %d\n",
@


1.123
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.122 2013/06/06 14:00:44 krw Exp $	*/
a2033 1
	datalen = xs->datalen;
d2035 4
a2038 7
		xs->resid = resid = info;
		if (st->flags & ST_FIXEDBLOCKS) {
			xs->resid *= st->blksize;
			datalen /= st->blksize;
		}
		if (xs->resid < 0 || xs->resid > xs->datalen)
			xs->resid = xs->datalen;
d2040 12
a2051 5
		xs->resid = resid = xs->datalen;
		if (st->flags & ST_FIXEDBLOCKS) {
			resid /= st->blksize;
			datalen /= st->blksize;
		}
@


1.122
log
@Fix EOM handling. Makes Bacula much happier by allowing the use of
both 'Fast Forward Space File = yes' and 'Hardware End of Medium = yes'.

Mostly taken from FreeBSD.

Constant prodding by robert@@, testing actual backup and restore by
ajacoutot@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.121 2011/07/03 15:47:18 matthew Exp $	*/
d2180 1
a2180 1
stdump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.121
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.120 2011/06/07 15:42:29 matthew Exp $	*/
d211 1
d269 2
a275 1
#define	ST_DYING	0x40	/* dying, when deactivated */
d281 2
d284 2
a285 1
#define	ST_PER_ACTION	(ST_AT_FILEMARK | ST_EIO_PENDING | ST_BLANK_READ)
d343 1
d669 3
d939 2
a940 1
		 * only FIXEDBLOCK devices have pending operations
d975 8
a982 4
			/*
			 * If we are at EIO (e.g. EOM) but have not reported it
			 * yet then we should report it now
			 */
a983 1
				bp->b_resid = bp->b_bcount;
a985 5
				st->flags &= ~ST_EIO_PENDING;
				s = splbio();
				biodone(bp);
				splx(s);
				continue;	/* seek more work */
d987 5
a992 1

a995 1

d1681 1
a1681 1
				st->flags &= ~ST_EIO_PENDING;
d1707 5
d1725 1
a1725 3
	if (xs == NULL) {
		st->media_fileno = -1;
		st->media_blkno = -1;
a1726 1
	}
d1735 2
d1754 4
a1757 1
				st->media_fileno += number;
d1761 9
d1794 1
a1794 3
	if (xs == NULL) {
		st->media_fileno = -1;
		st->media_blkno = -1;
d1796 1
a1796 1
	}
d1825 1
d1828 1
d1877 1
d1958 1
d1962 1
a1962 1
	int32_t resid;
d1969 2
d1997 22
a2018 1
	}
a2022 1
	case SKEY_BLANK_CHECK:
d2036 1
a2036 1
		xs->resid = resid = (int32_t)_4btol(sense->info);
d2054 2
d2064 4
a2067 3
		if ((st->flags & ST_FIXEDBLOCKS) == 0)
			return EIO;
		st->flags |= ST_EIO_PENDING;
d2116 1
@


1.120
log
@Fix a device reference leak in st{read,write}() by making them work
like {cd,sd}{read,write}().

ok krw@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.119 2011/03/31 18:42:48 jasper Exp $	*/
a353 3
	case DVACT_ACTIVATE:
		break;

@


1.119
log
@- use nitems(); no binary change.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.118 2011/03/18 22:59:34 matthew Exp $	*/
d1114 1
a1114 1
		return;  /* can't happen */
a1123 11
	struct st_softc *st;

	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);

	if (st->flags & ST_DYING) {
		device_unref(&st->sc_dev);
		return (ENXIO);
	}

a1129 11
	struct st_softc *st;

	st = stlookup(STUNIT(dev));
	if (st == NULL)
		return (ENXIO);

	if (st->flags & ST_DYING) {
		device_unref(&st->sc_dev);
		return (ENXIO);
	}

@


1.118
log
@Fix stdetach() to call vdevgone() with the right device minor numbers.
Some stylistic tweaks after discussions with krw@@ and deraadt@@.

ok krw@@; "Lovely" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.117 2011/03/17 21:30:24 deraadt Exp $	*/
d296 1
a296 1
	    st_patterns, sizeof(st_patterns)/sizeof(st_patterns[0]),
d401 1
a401 1
	    sizeof(st_quirk_patterns)/sizeof(st_quirk_patterns[0]),
@


1.117
log
@use dma_alloc/dma_free instead of malloc to allocate buffers which need
to be in the right address space.
help from matthew and krw
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.116 2010/12/24 02:45:33 krw Exp $	*/
d83 3
d375 1
a375 1
	mn = STUNIT(self->dv_unit);
d378 2
a379 6
		if (bdevsw[bmaj].d_open == stopen) {
			vdevgone(bmaj, mn, mn + 0, VBLK);
			vdevgone(bmaj, mn, mn + 1, VBLK);
			vdevgone(bmaj, mn, mn + 2, VBLK);
			vdevgone(bmaj, mn, mn + 3, VBLK);
		}
d381 2
a382 6
		if (cdevsw[cmaj].d_open == stopen) {
			vdevgone(cmaj, mn, mn + 0, VCHR);
			vdevgone(cmaj, mn, mn + 1, VCHR);
			vdevgone(cmaj, mn, mn + 2, VCHR);
			vdevgone(cmaj, mn, mn + 3, VCHR);
		}
@


1.116
log
@Have sd(4) devices check for and respect read-only information the
way st(4) does. Have both decline to open read-only devices for
anything but read-only access.

Suggestion to fail opens rather than individual i/o's from deraadt@@.

Problem USB device found and donated by chefren, who also tested
diffs. Thanks!

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.115 2010/10/13 02:14:52 krw Exp $	*/
d65 1
a65 1
#include <sys/malloc.h>
d1412 1
a1412 1
	struct scsi_block_limits_data block_limits;
d1416 1
a1416 1
	int error;
d1421 4
d1426 5
a1430 2
	if (xs == NULL)
		return (ENOMEM);
d1432 2
a1433 2
	xs->data = (void *)&block_limits;
	xs->datalen = sizeof(block_limits);
d1443 2
a1444 2
		st->blkmin = _2btol(block_limits.min_length);
		st->blkmax = _3btol(block_limits.max_length);
d1449 3
d1468 1
a1468 1
	union scsi_mode_sense_buf *data;
d1474 1
a1474 1
	int error, big;
d1476 1
a1476 1
	data = malloc(sizeof(*data), M_TEMP, M_NOWAIT);
d1485 2
a1486 4
	if (error != 0) {
		free(data, M_TEMP);
		return (error);
	}
d1513 4
a1516 2
	free(data, M_TEMP);
	return (0);
d1526 1
a1526 1
	union scsi_mode_sense_buf *inbuf, *outbuf;
d1530 1
a1530 1
	int error, big, page0_size;
d1532 6
a1537 4
	inbuf = malloc(sizeof(*inbuf), M_TEMP, M_NOWAIT);
	if (inbuf == NULL)
		return (ENOMEM);
	outbuf = malloc(sizeof(*outbuf), M_TEMP, M_NOWAIT | M_ZERO);
d1539 2
a1540 2
		free(inbuf, M_TEMP);
		return (ENOMEM);
d1552 2
a1553 3
		free(inbuf, M_TEMP);
		free(outbuf, M_TEMP);
		return (0);
d1557 2
a1558 3
		free(inbuf, M_TEMP);
		free(outbuf, M_TEMP);
		return (0);
d1572 2
a1573 5
	if (error != 0) {
		free(inbuf, M_TEMP);
		free(outbuf, M_TEMP);
		return (error);
	}
d1606 1
a1606 3
		free(inbuf, M_TEMP);
		free(outbuf, M_TEMP);
		return (error);
d1620 5
a1624 2
	free(inbuf, M_TEMP);
	free(outbuf, M_TEMP);
d2119 3
a2121 3
	char *buf;
	int readsize;
	int error;
d2123 7
a2129 3
	buf = malloc(1024, M_TEMP, M_NOWAIT);
	if (!buf)
		return ENOMEM;
a2130 2
	if ((error = st_mode_sense(st, 0)) != 0)
		goto bad;
d2144 1
a2144 1
			goto bad;
d2146 2
a2147 4
		if ((error = st_rewind(st, 0, 0)) != 0) {
bad:			free(buf, M_TEMP);
			return error;
		}
d2149 3
a2151 3

	free(buf, M_TEMP);
	return 0;
@


1.115
log
@No need to check ST_DYING flag twice in succession.

Noticed by Damien McGuckin. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.114 2010/09/22 01:18:57 matthew Exp $	*/
a264 1
#define	ST_READONLY	0x0080	/* st_mode_sense says write protected */
a277 3
#define	ST_PER_MOUNT	(ST_INFO_VALID | ST_BLOCK_SET | ST_WRITTEN | \
			 ST_FIXEDBLOCKS | ST_READONLY | ST_FM_WRITTEN | \
			 ST_2FM_AT_EOD | ST_PER_ACTION)
d456 2
d462 4
a465 1
	sc_link = st->sc_link;
d840 1
d1210 1
a1210 1
		if (st->flags & ST_READONLY)
d1488 1
a1488 1
		st->flags |= ST_READONLY;
d1490 1
a1490 1
		st->flags &= ~ST_READONLY;
d1499 1
a1499 1
	    st->flags & ST_READONLY ? "protected" : "enabled"));
@


1.114
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.113 2010/09/20 02:51:52 deraadt Exp $	*/
a843 4
	if (st->flags & ST_DYING) {
		bp->b_error = ENXIO;
		goto bad;
	}
@


1.113
log
@bufq_drain() does not need to be done in deactivate; we only need
to deactivate transactions we are currently doing.
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.112 2010/09/14 04:49:42 dlg Exp $	*/
d1142 1
a1142 1
	return (physio(ststrategy, NULL, dev, B_READ, stminphys, uio));
d1159 1
a1159 1
	return (physio(ststrategy, NULL, dev, B_WRITE, stminphys, uio));
@


1.112
log
@dont leak an xs in ststart if its called while the device is dying.

pointed out by matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.111 2010/09/14 04:02:43 dlg Exp $	*/
a359 1
		bufq_drain(&st->sc_bufq);
@


1.111
log
@scsi_xsh_del the xs handler on DEACTIVATE.

same change as sd.c r1.212. matthew@@ pointed out that cd(4) and
st(4) would need the same change.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.110 2010/09/14 01:43:38 krw Exp $	*/
d915 2
a916 1
	if (st->flags & ST_DYING)
d918 1
@


1.110
log
@Clean up sense mode handling to make residual value handling clearer
and more plausibly correct.

Tested by jsing@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.109 2010/09/01 23:24:03 krw Exp $	*/
d361 1
@


1.109
log
@Don't give xs->resid an invalid value (xs->datalen * st->blksize)
inside st_interpret_sense() and then exit without making sure it's
set back to <= xs->datalen.

Fixes 'done < 0; strategy broken' panics when un-tar'ing /cvs from
my ahci DAT tape drive.

ok dlg@@ more-or-less-ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.108 2010/09/01 01:38:12 dlg Exp $	*/
d1955 2
a1956 1
	int32_t info;
d2000 11
a2010 10
	 * Get the sense fields and work out what code
	 */
	if (sense->error_code & SSD_ERRCODE_VALID)
		info = _4btol(sense->info);
	else
		info = xs->datalen;	/* bad choice if fixed blocks */
	if (st->flags & ST_FIXEDBLOCKS) {
		xs->resid = info * st->blksize;
		if (sense->flags & SSD_EOM) {
			st->flags |= ST_EIO_PENDING;
d2012 7
a2018 6
		if (sense->flags & SSD_FILEMARK) {
			st->flags |= ST_AT_FILEMARK;
			if (st->media_fileno != -1) {
				st->media_fileno++;
				st->media_blkno = 0;
			}
d2020 1
a2020 6
		if (sense->flags & SSD_ILI) {
			st->flags |= ST_EIO_PENDING;
			if (sense->error_code & SSD_ERRCODE_VALID &&
			    (xs->flags & SCSI_SILENT) == 0)
				printf("%s: block wrong size, %d blocks residual\n",
				    st->sc_dev.dv_xname, info);
d2022 4
a2025 10
			/*
			 * This quirk code helps the drive read
			 * the first tape block, regardless of
			 * format.  That is required for these
			 * drives to return proper MODE SENSE
			 * information.
			 */
			if ((st->quirks & ST_Q_SENSE_HELP) &&
			    !(sc_link->flags & SDEV_MEDIA_LOADED))
				st->blksize -= 512;
d2027 28
d2056 3
a2058 1
		 * If no data was transferred, return immediately
d2060 7
a2066 11
		if (xs->resid >= xs->datalen) {
			xs->resid = xs->datalen;
			if (st->flags & ST_EIO_PENDING)
				return EIO;
			if (st->flags & ST_AT_FILEMARK) {
				return 0;
			}
		}
	} else {		/* must be variable mode */
		xs->resid = xs->datalen;	/* to be sure */
		if (sense->flags & SSD_EOM)
d2068 1
a2068 5
		if (sense->flags & SSD_FILEMARK) {
			if (st->media_fileno != -1) {
				st->media_fileno++;
				st->media_blkno = 0;
			}
a2069 25
		}
		if (sense->flags & SSD_ILI) {
			if (info < 0) {
				/*
				 * the record was bigger than the read
				 */
				if ((xs->flags & SCSI_SILENT) == 0)
					printf("%s: %d-byte record too big\n",
					    st->sc_dev.dv_xname,
					    xs->datalen - info);
				return (EIO);
			} else if (info > xs->datalen) {
				/*
				 * huh? the residual is bigger than the request
				 */
				if ((xs->flags & SCSI_SILENT) == 0)
					printf(
					    "%s: bad residual %d out of %d\n",
					    st->sc_dev.dv_xname, info,
					    xs->datalen);
				return (EIO);
			}
			xs->resid = info;
			return (0);
		}
@


1.108
log
@make struct bufq a member of the softc for devices that use it,
rather than it being a pointer to something that needs to be allocated
at attach. since all these devices need a bufq to operate, it makes
sense to have it allocated as part of the softc and get bufq_init
to just initialise all its fields. it also gets rid of the possibility
that you wont be able to allocate the bufq struct during attach,
which is something you dont want to happen.

secondly, it consistently implements a split between wrapper functions
and the per discipline implementation of the bufq handlers. it
consistently does the locking in the wrappers rather than doing
half in the wrappers and the other half in the implementations.

it also consistently handles the outstanding bufq bq pointer in the
wrappers.

this hides most of the implementation inside kern_bufq.c. the only
stuff left in buf.h is for the bits each implementation needs to
put inside struct buf.

tested by thib@@ krw@@ and me
ok thib@@ matthew@@
no objection from krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.107 2010/08/30 02:47:56 matthew Exp $	*/
d2039 1
@


1.107
log
@Avoid possible aliasing-related compiler issues by always writing to
cmd->opcode through the type casted command pointer rather than
through xs->cmd->opcode.

Requested by deraadt@@; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.106 2010/07/22 05:26:34 matthew Exp $	*/
d218 1
a218 1
	struct bufq *sc_bufq;
d334 1
a334 1
	st->sc_bufq = bufq_init(BUFQ_FIFO);
d360 1
a360 1
		bufq_drain(st->sc_bufq);
d373 1
a373 1
	bufq_drain(st->sc_bufq);
d393 1
a393 1
	bufq_destroy(st->sc_bufq);
d880 1
a880 1
	BUFQ_QUEUE(st->sc_bufq, bp);
d925 1
a925 1
		bufq_drain(st->sc_bufq);
d931 1
a931 1
		bp = BUFQ_DEQUEUE(st->sc_bufq);
d1044 1
a1044 1
	else if (BUFQ_PEEK(st->sc_bufq))
d1063 1
a1063 1
		BUFQ_REQUEUE(st->sc_bufq, bp);
@


1.106
log
@In st_space() and st_write_filemarks(), if scsi_xs_get() returns NULL,
set st->media_fileno and st->media_blkno before returning.  Not sure
if this is needed or even really correct, but it's an unintentional
behavior change due to removing scsi_scsi_cmd().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.105 2010/07/22 00:31:06 krw Exp $	*/
a1384 1
	xs->cmd->opcode = READ;
d1392 1
a1423 1
	xs->cmd->opcode = READ_BLOCK_LIMITS;
d1429 3
a1632 1
	xs->cmd->opcode = ERASE;
d1641 1
a1735 1
	xs->cmd->opcode = SPACE;
d1738 1
a1793 1
	xs->cmd->opcode = WRITE_FILEMARKS;
d1813 1
a1892 1
	xs->cmd->opcode = LOAD;
d1897 1
a1923 1
	xs->cmd->opcode = REWIND;
d1928 1
@


1.105
log
@Eliminate scsi_scsi_cmd() now that ss(4) is gone and with it the
last bastardized sync and buf call through scsi_scsi_cmd(). Flatten
code to call scsi_xs_sync() directly for all commands.

Airplane typos shaken out by various.

ok dlg@@ matthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.104 2010/07/01 05:11:18 krw Exp $	*/
d1729 3
a1731 1
	if (xs == NULL)
d1733 1
d1787 3
a1789 1
	if (xs == NULL)
d1791 1
@


1.104
log
@Die struct scsi_device! Die! Instead, save a pointer to the routine
to interpret sense errors. This is initialized to the basic
interpretation routine, and specific scsi drivers (sd/st/cd) can
replace this with their own. While here kill EJUSTRETURN dance and
make more specialized interpretation routines directly call the
basic routine if desired.

Fixes by matthew@@ to my first diff. Most original work by dlg@@.

ok matthew@@ marco@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.103 2010/07/01 03:01:37 matthew Exp $	*/
d1375 3
a1377 1
	struct scsi_rw_tape cmd;
a1378 3
	/*
	 * If it's a null transfer, return immediately
	 */
d1381 12
a1392 2
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ;
d1394 1
a1394 1
		cmd.byte2 |= SRW_FIXED;
d1396 1
a1396 1
		    cmd.len);
d1398 6
a1403 4
		_lto3b(size, cmd.len);
	return scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) buf, size, 0, ST_IO_TIME, NULL,
	    flags | SCSI_DATA_IN);
a1411 1
	struct scsi_block_limits cmd;
d1413 1
d1415 1
a1417 3
	/*
	 * First check if we have it all loaded
	 */
d1419 1
a1419 1
		return 0;
d1421 8
a1428 5
	/*
	 * do a 'Read Block Limits'
	 */
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = READ_BLOCK_LIMITS;
d1430 2
a1431 8
	/*
	 * do the command, update the global values
	 */
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) &block_limits, sizeof(block_limits),
	    SCSI_RETRIES, ST_CTL_TIME, NULL, flags | SCSI_DATA_IN);
	if (error)
		return error;
d1433 6
a1438 2
	st->blkmin = _2btol(block_limits.min_length);
	st->blkmax = _3btol(block_limits.max_length);
d1440 1
a1440 3
	SC_DEBUG(sc_link, SDEV_DB3,
	    ("(%d <= blksize <= %d)\n", st->blkmin, st->blkmax));
	return 0;
d1624 9
a1632 2
	struct scsi_erase cmd;
	int tmo;
d1639 1
a1639 2
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = ERASE;
d1641 2
a1642 2
		cmd.byte2 = SE_IMMED|SE_LONG;
		tmo = ST_SPC_TIME;
d1644 2
a1645 2
		cmd.byte2 = SE_IMMED;
		tmo = ST_IO_TIME;
d1652 4
a1655 2
	return (scsi_scsi_cmd(st->sc_link, (struct scsi_generic *)&cmd,
	    sizeof(cmd), 0, 0, SCSI_RETRIES, tmo, NULL, flags));
d1664 2
a1665 1
	struct scsi_space cmd;
d1728 10
a1737 4
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = SPACE;
	cmd.byte2 = what;
	_lto3b(number, cmd.number);
d1739 2
a1740 2
	error = scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), 0, 0, 0, ST_SPC_TIME, NULL, flags);
d1776 2
a1777 1
	struct scsi_write_filemarks cmd;
a1779 4
	/*
	 * It's hard to write a negative number of file marks.
	 * Don't try.
	 */
d1781 9
a1789 1
		return EINVAL;
d1802 1
d1805 2
a1806 3
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = WRITE_FILEMARKS;
	_lto3b(number, cmd.number);
d1808 2
a1809 2
	error = scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), 0, 0, 0, ST_IO_TIME * 4, NULL, flags);
d1858 3
a1860 1
	struct scsi_load cmd;
a1865 3
		int error;
		int nmarks;

d1868 1
a1868 1
			return error;
d1870 1
d1876 1
a1876 1
			return st_rewind(st, 0, flags);
d1882 6
a1887 3
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = LOAD;
	cmd.how = type;
d1889 7
a1895 2
	return scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), 0, 0, SCSI_RETRIES, ST_SPC_TIME, NULL, flags);
d1904 3
a1906 3
	struct scsi_rewind cmd;
	int error;
	int nmarks;
d1910 1
a1910 1
		return error;
d1913 12
a1924 7
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = REWIND;
	cmd.byte2 = immediate;

	error = scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), 0, 0, SCSI_RETRIES,
	    immediate ? ST_CTL_TIME: ST_SPC_TIME, NULL, flags);
@


1.103
log
@Restore setting xs->bp; fixes ncr(4) on VAX.

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.102 2010/06/30 02:17:25 matthew Exp $	*/
a258 7
struct scsi_device st_switch = {
	st_interpret_sense,
	NULL,
	NULL,
	NULL,
};

d319 1
a319 1
	sc_link->device = &st_switch;
d1071 4
a1074 1
		error = scsi_interpret_sense(xs);
d1910 1
a1910 1
		return (EJUSTRETURN); /* let the generic code handle it */
d1937 1
a1937 1
			return (EJUSTRETURN);
d1946 1
a1946 1
		return (EJUSTRETURN);
d2050 1
a2050 1
	return (EJUSTRETURN);
@


1.102
log
@Prune some dead assignments in st_interpret_sense(); st(4) already
always explicitly sets bp->b_resid before calling biodone(), so these
are unneeded.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.101 2010/06/29 07:08:07 matthew Exp $	*/
d1039 1
@


1.101
log
@Change st(4) to use the FIFO buf sorting discipline rather than the
default disk-sorting one.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.100 2010/06/26 23:24:45 guenther Exp $	*/
a1906 1
	struct buf *bp = xs->bp;
a1962 2
			if (bp)
				bp->b_resid = xs->resid;
a1969 2
			if (bp)
				bp->b_resid = xs->resid;
a1972 2
			if (bp)
				bp->b_resid = xs->resid;
a1995 2
				if (bp)
					bp->b_resid = xs->resid;
a2007 2
			if (bp)
				bp->b_resid = bp->b_bcount;
a2031 2
			if (bp)
				bp->b_resid = info;
a2048 4
			if (bp) {
				bp->b_resid = xs->resid;
				/* return an EOF */
			}
@


1.100
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.99 2010/06/25 04:29:39 dlg Exp $	*/
d341 1
a341 1
	st->sc_bufq = bufq_init(BUFQ_DEFAULT);
@


1.99
log
@move st over to using xshandlers for scheduling io. based on the
same changes in cd and sd.

tested by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.98 2010/06/16 00:20:06 krw Exp $	*/
a67 1
#include <sys/user.h>
@


1.98
log
@Bring ststrategy() into line with sdstrategy() and cdstrategy(), making
sure buf's are correctly completed.

Feedback from Matthew Dempsky.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.97 2010/06/15 04:11:34 dlg Exp $	*/
d221 1
a221 2
	struct mutex sc_start_mtx;
	u_int sc_start_count;
d236 1
a236 1
void	ststart(void *);
d262 1
a262 1
	ststart,
d337 3
a339 3
	mtx_init(&st->sc_start_mtx, IPL_BIO);

	timeout_set(&st->sc_timeout, ststart, st);
d573 1
d895 1
a895 1
	ststart(st);
a910 14
/*
 * ststart looks to see if there is a buf waiting for the device
 * and that the device is not already busy. If both are true,
 * It dequeues the buf and creates a scsi command to perform the
 * transfer required. The transfer request will call scsi_done
 * on completion, which will in turn call this routine again
 * so that the next queued transfer is performed.
 * The bufs are queued by the strategy routine (ststrategy)
 *
 * This routine is also called after other non-queued requests
 * have been made of the scsi driver, to ensure that the queue
 * continues to be drained.
 * ststart() is called at splbio from ststrategy and scsi_done()
 */
d912 1
a912 1
ststart(void *v)
d914 2
a915 2
	struct st_softc *st = v;
	struct scsi_link *sc_link = st->sc_link;
a917 1
	struct scsi_xfer *xs;
d925 10
a934 4
	mtx_enter(&st->sc_start_mtx);
	st->sc_start_count++;
	if (st->sc_start_count > 1) {
		mtx_leave(&st->sc_start_mtx);
a936 21
	mtx_leave(&st->sc_start_mtx);
	CLR(st->flags, ST_WAITING);
restart:
	while (!ISSET(st->flags, ST_WAITING) &&
	    (bp = BUFQ_DEQUEUE(st->sc_bufq)) != NULL) {
		/*
		 * if the device has been unmounted by the user
		 * then throw away all requests until done
		 */
		if (!(st->flags & ST_MOUNTED) ||
		    !(sc_link->flags & SDEV_MEDIA_LOADED)) {
			/* make sure that one implies the other.. */
			sc_link->flags &= ~SDEV_MEDIA_LOADED;
			bp->b_flags |= B_ERROR;
			bp->b_resid = bp->b_bcount;
			bp->b_error = EIO;
			s = splbio();
			biodone(bp);
			splx(s);
			continue;
		}
d938 5
a942 4
		xs = scsi_xs_get(sc_link, SCSI_NOSLEEP);
		if (xs == NULL) {
			BUFQ_REQUEUE(st->sc_bufq, bp);
			break;
d997 2
a998 14
		/*
		 *  Fill out the scsi command
		 */
		cmd = (struct scsi_rw_tape *)xs->cmd;
		bzero(cmd, sizeof(*cmd));
		if ((bp->b_flags & B_READ) == B_WRITE) {
			cmd->opcode = WRITE;
			st->flags &= ~ST_FM_WRITTEN;
			st->flags |= ST_WRITTEN;
			xs->flags |= SCSI_DATA_OUT;
		} else {
			cmd->opcode = READ;
			xs->flags |= SCSI_DATA_IN;
		}
a999 17
		/*
		 * Handle "fixed-block-mode" tape drives by using the
		 * block count instead of the length.
		 */
		if (st->flags & ST_FIXEDBLOCKS) {
			cmd->byte2 |= SRW_FIXED;
			_lto3b(bp->b_bcount / st->blksize, cmd->len);
		} else
			_lto3b(bp->b_bcount, cmd->len);

		if (st->media_blkno != -1) {
			/* Update block count now, errors will set it to -1. */
			if (st->flags & ST_FIXEDBLOCKS)
				st->media_blkno += _3btol(cmd->len);
			else if (cmd->len != 0)
				st->media_blkno++;
		}
d1001 14
a1014 6
		xs->cmdlen = sizeof(*cmd);
		xs->timeout = ST_IO_TIME;
		xs->data = bp->b_data;
		xs->datalen = bp->b_bcount;
		xs->done = st_buf_done;
		xs->cookie = bp;
d1016 9
a1024 5
		/*
		 * go ask the adapter to do all this for us
		 */
		scsi_xs_exec(xs);
	} /* go back and see if we can cram more work in.. */
d1026 6
a1031 6
	mtx_enter(&st->sc_start_mtx);
	st->sc_start_count--;
	if (st->sc_start_count != 0) {
		st->sc_start_count = 1;
		mtx_leave(&st->sc_start_mtx);
		goto restart;
d1033 20
a1052 1
	mtx_leave(&st->sc_start_mtx);
d1072 1
a1072 1
		SET(st->flags, ST_WAITING); /* break out of cdstart loop */
a1113 1
	ststart(st); /* restart io */
@


1.97
log
@dont pass the dev_t from the scsi device drivers into the midlayer for
ioctl requests, and dont pass the proc pointers around for any ioctl
requests in scsi land at all. neither were used, so trim the fat.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.96 2010/06/11 12:02:44 krw Exp $	*/
d836 1
a836 1
	int error, s;
d839 4
a842 2
	if (st == NULL)
		return;
d844 2
a845 2
		error = ENXIO;
		goto done;
d902 1
a902 4
	device_unref(&st->sc_dev);
	/*
	 * Correctly set the buf to indicate a completed xfer
	 */
d907 2
@


1.96
log
@Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.95 2010/06/01 15:27:16 thib Exp $	*/
d1360 1
a1360 1
		error = scsi_do_ioctl(st->sc_link, dev, cmd, arg, flag, p);
@


1.95
log
@move cd, st & ss over to bufq's again.

Tested by myself and krw.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.94 2010/04/12 09:51:48 dlg Exp $	*/
d1086 1
a1086 1
	int s;
d1104 7
a1110 1
		if (scsi_interpret_sense(xs) != ERESTART)
@


1.94
log
@i snuck fine grained locking into the midlayer as part of all the
other stuff ive been doing in here. everything that needs protection
inside the midlayer and the scsi device drivers (sd, cd, etc) uses
mutexes now.

this pushes splbio out of the midlayer. splbio is only taken before
biodone is called now.

ok beck@@ marco@@ krw@@ deraadt@@. theyre all terrified, but they all
say if we're going to do then now is the right stage of the dev
cycle.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.93 2010/01/15 05:50:31 krw Exp $	*/
d219 1
a219 1
	struct buf sc_buf_queue;	/* the queue of pending IO operations */
a220 1
	struct mutex sc_buf_mtx;
a337 1
	mtx_init(&st->sc_buf_mtx, IPL_BIO);
d342 2
a343 6
	/*
	 * Set up the buf queue for this device
	 */
	st->sc_buf_queue.b_active = 0;
	st->sc_buf_queue.b_actf = 0;
	st->sc_buf_queue.b_actb = &st->sc_buf_queue.b_actf;
d369 1
a369 1
		scsi_buf_killqueue(&st->sc_buf_queue, &st->sc_buf_mtx);
d382 1
a382 1
	scsi_buf_killqueue(&st->sc_buf_queue, &st->sc_buf_mtx);
d402 2
d886 1
a886 1
	scsi_buf_enqueue(&st->sc_buf_queue, bp, &st->sc_buf_mtx);
d949 1
a949 2
	    (bp = scsi_buf_dequeue(&st->sc_buf_queue, &st->sc_buf_mtx)) != NULL) {

d969 1
a969 1
			scsi_buf_requeue(&st->sc_buf_queue, bp, &st->sc_buf_mtx);
d1096 1
a1096 1
		scsi_buf_requeue(&st->sc_buf_queue, bp, &st->sc_buf_mtx);
@


1.93
log
@Abstract and merge the manual buf queue manipulating functions into
one place for easier debugging and maintenance. No intended functional
changes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.92 2010/01/15 05:31:38 krw Exp $	*/
d1091 1
a1091 2

	splassert(IPL_BIO);
d1135 1
d1137 1
@


1.93.2.1
log
@MFC, original commit from krw@@:
----------------------------
Restore an unusual XS_SENSE semantic that inadvertantly got lost
in the great re-write. If the scsi device *_interpret_sense()
function returns 0 that means there was no error.

Fixes restore(8) problems seen on certain tape drives.

Found and fix tested by Percey Piper. Suggestions from Matthew
Dempsky. Thanks!

ok dlg@@
----------------------------

ok krw@@ and dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.93 2010/01/15 05:50:31 krw Exp $	*/
a1090 1
	int error;
d1110 1
a1110 7
		error = scsi_interpret_sense(xs);
		if (error == 0) {
			bp->b_error = 0;
			bp->b_resid = xs->resid;
			break;
		}
		if (error != ERESTART)
@


1.92
log
@Restore XS_BUSY delay behaviour for buf i/o. Same as for sync path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.91 2010/01/12 23:33:57 dlg Exp $	*/
d219 1
a219 1
	struct buf buf_queue;		/* the queue of pending IO operations */
a232 1
void	st_kill_buffers(struct st_softc *);
a238 3
struct buf *st_buf_dequeue(struct st_softc *);
void	st_buf_enqueue(struct st_softc *, struct buf *);
void	st_buf_requeue(struct st_softc *, struct buf *);
d347 3
a349 3
	st->buf_queue.b_active = 0;
	st->buf_queue.b_actf = 0;
	st->buf_queue.b_actb = &st->buf_queue.b_actf;
d375 1
a375 1
		st_kill_buffers(st);
d388 1
a388 1
	st_kill_buffers(st);
d890 1
a890 1
	st_buf_enqueue(st, bp);
a913 42
void
st_buf_enqueue(struct st_softc *st, struct buf *bp)
{
	struct buf *dp;

	mtx_enter(&st->sc_buf_mtx);
	dp = &st->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
	mtx_leave(&st->sc_buf_mtx);
}

struct buf *
st_buf_dequeue(struct st_softc *st)
{
	struct buf *bp;

	mtx_enter(&st->sc_buf_mtx);
	bp = st->buf_queue.b_actf;
	if (bp != NULL)
		st->buf_queue.b_actf = bp->b_actf;
	if (st->buf_queue.b_actf == NULL)
		st->buf_queue.b_actb = &st->buf_queue.b_actf;
	mtx_leave(&st->sc_buf_mtx);

	return (bp);
}

void
st_buf_requeue(struct st_softc *st, struct buf *bp)
{
	mtx_enter(&st->sc_buf_mtx);
	bp->b_actf = st->buf_queue.b_actf;
	st->buf_queue.b_actf = bp;
	if (bp->b_actf == NULL)
		st->buf_queue.b_actb = &bp->b_actf;
	mtx_leave(&st->sc_buf_mtx);
}


d953 1
a953 1
	    (bp = st_buf_dequeue(st)) != NULL) {
d974 1
a974 1
			st_buf_requeue(st, bp);
d1102 1
a1102 1
		st_buf_requeue(st, bp);
a2158 18
}

/*
 * Remove unprocessed buffers from queue.
 */
void
st_kill_buffers(struct st_softc *st)
{
	struct buf *bp;
	int s;

	while ((bp = st_buf_dequeue(st)) != NULL) {
		bp->b_error = ENXIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
	}
@


1.91
log
@bring sd.c r1.180 over to the other drivers now using the antisemaphore,
ie, dont clear the WAITING flag when restarting the xxstart loops.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.90 2010/01/11 08:56:17 krw Exp $	*/
d1158 1
a1159 1
		/* FALLTHROUGH */
d1161 6
d1168 1
d1173 1
a1174 1
		/* FALLTHROUGH */
@


1.90
log
@Bring mutex protections to ststart, cdstart and ssstart, as already
done in sd. Make names consistant across all three.

ok dlg@@ tested (cd) & ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.89 2010/01/09 21:12:06 dlg Exp $	*/
d996 1
a997 1
	CLR(st->flags, ST_WAITING);
@


1.89
log
@dont try to prevent multiple concurrent runs of a devices start routine
by setting flags around the loop. there is a race which can prevent
necessary work being completed by any of the currently running instances
of xxstart.

the caveat with the removal of this code is because multiple xxstarts can
be running at the same time they can cause io reordering, but that is less
of a problem than no io.

found by and fix tested by claudio@@
debugged with krw@@ claudio@@ beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.88 2009/12/26 09:12:55 dlg Exp $	*/
d221 3
a223 2
	struct mutex queue_mtx;
	struct mutex start_mtx;
d343 2
a344 2
	mtx_init(&st->queue_mtx, IPL_BIO);
	mtx_init(&st->start_mtx, IPL_BIO);
d923 1
a923 1
	mtx_enter(&st->queue_mtx);
d929 1
a929 1
	mtx_leave(&st->queue_mtx);
d937 1
a937 1
	mtx_enter(&st->queue_mtx);
d943 1
a943 1
	mtx_leave(&st->queue_mtx);
d951 1
a951 1
	mtx_enter(&st->queue_mtx);
d956 1
a956 1
	mtx_leave(&st->queue_mtx);
d989 8
a996 5
	/*
	 * See if there is a buf to do and we are not already
	 * doing one
	 */

d1121 9
@


1.88
log
@move st over to the new midlayer.

much testing and debugging from krw@@
his diff was a nice christmas present
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.86 2009/02/16 21:19:07 miod Exp $	*/
a289 1
#define ST_STARTING	0x4000
a992 9
	mtx_enter(&st->start_mtx);
	if (ISSET(st->flags, ST_STARTING)) {
		mtx_leave(&st->start_mtx);
		return;
	}

	SET(st->flags, ST_STARTING);
	mtx_leave(&st->start_mtx);

a1116 4

	mtx_enter(&st->start_mtx);
	CLR(st->flags, ST_STARTING);
	mtx_leave(&st->start_mtx);
@


1.87
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d221 2
d239 4
a242 1
void	strestart(void *);
d289 2
d343 2
a344 1
	timeout_set(&st->sc_timeout, strestart, st);
d346 2
a843 1
	struct buf *dp;
a887 1
	s = splbio();
d894 1
a894 5
	dp = &st->buf_queue;
	bp->b_actf = NULL;
	bp->b_actb = dp->b_actb;
	*dp->b_actb = bp;
	dp->b_actb = &bp->b_actf;
a902 1
	splx(s);
d918 42
d972 1
a972 1
 * ststart() is called at splbio from ststrategy, strestart and scsi_done()
d979 4
a982 3
	struct buf *bp, *dp;
	struct scsi_rw_tape cmd;
	int flags, error;
a988 2
	splassert(IPL_BIO);

a992 7
	while (sc_link->openings > 0) {
		/* if a special awaits, let it proceed first */
		if (sc_link->flags & SDEV_WAITING) {
			sc_link->flags &= ~SDEV_WAITING;
			wakeup((caddr_t)sc_link);
			return;
		}
d994 12
a1005 8
		dp = &st->buf_queue;
		if ((bp = dp->b_actf) == NULL)
			return;
		if ((dp = bp->b_actf) != NULL)
			dp->b_actb = bp->b_actb;
		else
			st->buf_queue.b_actb = bp->b_actb;
		*bp->b_actb = dp;
d1018 1
d1020 1
d1023 7
d1050 1
d1052 1
d1060 1
d1062 1
d1075 1
d1077 1
d1085 2
a1086 1
		bzero(&cmd, sizeof(cmd));
d1088 1
a1088 1
			cmd.opcode = WRITE;
d1091 1
a1091 1
			flags = SCSI_DATA_OUT;
d1093 2
a1094 2
			cmd.opcode = READ;
			flags = SCSI_DATA_IN;
d1102 2
a1103 2
			cmd.byte2 |= SRW_FIXED;
			_lto3b(bp->b_bcount / st->blksize, cmd.len);
d1105 1
a1105 1
			_lto3b(bp->b_bcount, cmd.len);
d1110 2
a1111 2
				st->media_blkno += _3btol(cmd.len);
			else if (cmd.len != 0)
d1115 7
d1125 1
a1125 18
		error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
		    sizeof(cmd), (u_char *) bp->b_data, bp->b_bcount, 0,
		    ST_IO_TIME, bp, flags | SCSI_NOSLEEP);
		switch (error) {
		case 0:
			timeout_del(&st->sc_timeout);
			break;
		case EAGAIN:
			/*
			 * The device can't start another i/o. Try again later.
			 */
			dp->b_actf = bp;
			timeout_add(&st->sc_timeout, 1);
			return;
		default:
			printf("%s: not queued\n", st->sc_dev.dv_xname);
			break;
		}
d1127 4
d1134 1
a1134 1
strestart(void *v)
d1136 39
a1174 1
	int s;
d1176 3
a1178 3
	s = splbio();
	ststart(v);
	splx(s);
d2207 1
a2207 1
	struct buf *dp, *bp;
d2210 1
a2210 4
	s = splbio();
	for (dp = &st->buf_queue; (bp = dp->b_actf) != NULL; ) {
		dp->b_actf = bp->b_actf;

d2213 1
d2215 1
a2216 1
	splx(s);
@


1.86
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.85 2008/09/22 19:44:41 miod Exp $	*/
d226 1
a226 1
int	stactivate(struct device *, enum devact);
d358 1
a358 1
stactivate(struct device *self, enum devact act)
@


1.85
log
@Do not return an uninitialized value on success in stclose().

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.84 2008/09/06 15:35:02 krw Exp $	*/
d229 1
d1092 14
d1120 1
a1120 2
	return (physio(ststrategy, NULL, dev, B_READ,
	    st->sc_link->adapter->scsi_minphys, uio));
d1137 1
a1137 2
	return (physio(ststrategy, NULL, dev, B_WRITE,
	    st->sc_link->adapter->scsi_minphys, uio));
@


1.84
log
@Return EIO when the residual is > xs->datalen, even if SCSI_SILENT is
set. SCSI_SILENT mediates printing error messages only.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.83 2008/06/22 16:32:06 krw Exp $	*/
d537 1
a537 1
	int error;
@


1.83
log
@Replace MUSTEK_RETRIES, SCANJET_RETRIES and ST_RETRIES with SCSI_RETRIES,
all defined to 4. Replace some magic number 4's with SCSI_RETRIES. Fix a
few lines that were now too long.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.82 2008/05/12 22:14:46 krw Exp $	*/
d1999 1
a1999 1
				if ((xs->flags & SCSI_SILENT) == 0) {
d2004 1
a2004 2
					return (EIO);
				}
@


1.82
log
@Fix device reference counting. Now that we try to support detachable
tape drives it is nice not to crash if one is detached. Basically use
a consistant mechanism modelled on sd to lookup devices and do the
device reference increments and decrements. Problem reported (PR#5811)
and fix tested by Jozef Hatala. Still some corner cases Jozef is
looking for but we'll fix those as discovered.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.81 2008/05/09 00:25:41 krw Exp $	*/
a79 1
#define	ST_RETRIES	4	/* only on non IO commands */
d1390 1
a1390 1
	    ST_RETRIES, ST_CTL_TIME, NULL, flags | SCSI_DATA_IN);
d1606 1
a1606 1
	    sizeof(cmd), 0, 0, ST_RETRIES, tmo, NULL, flags));
d1826 1
a1826 1
	    sizeof(cmd), 0, 0, ST_RETRIES, ST_SPC_TIME, NULL, flags);
d1849 1
a1849 1
	    sizeof(cmd), 0, 0, ST_RETRIES,
@


1.81
log
@Oops. When detaching tape drives look for devices using 'stopen' not
devices using 'sdopen'. PR#5810 from Jozef Hatala.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.80 2007/11/27 16:22:14 martynas Exp $	*/
d290 2
d462 1
a462 1
	int error = 0, unit;
d464 2
a465 8
	unit = STUNIT(dev);
	if (unit >= st_cd.cd_ndevs)
		return (ENXIO);
	st = st_cd.cd_devs[unit];
	if (!st)
		return (ENXIO);
	if ((st->flags & ST_DYING)) {
		device_unref(&st->sc_dev);
d467 3
a470 1

d474 1
a474 1
	    unit, st_cd.cd_ndevs));
d481 2
a482 1
		return (EBUSY);
d504 1
a504 1
		return (error);
d511 1
a511 1
			return (error);
d523 1
d525 2
a526 1
	return (0);
d536 3
a538 1
	struct st_softc *st = st_cd.cd_devs[STUNIT(dev)];
d540 3
a542 1
	SC_DEBUG(st->sc_link, SDEV_DB1, ("closing\n"));
d544 2
a545 2
		device_unref(&st->sc_dev);
		return (ENXIO);
d547 4
d553 1
d563 1
a563 1
		if (!(st->sc_link->flags & SDEV_MEDIA_LOADED))
d570 1
a570 1
	st->sc_link->flags &= ~SDEV_OPEN;
d573 3
a575 1
	return 0;
a585 2
	int unit;
	u_int mode;
d590 7
a596 3
	unit = STUNIT(dev);
	mode = STMODE(dev);
	st = st_cd.cd_devs[unit];
d599 2
d602 1
a602 1
		return 0;
a603 1
	SC_DEBUG(sc_link, SDEV_DB1, ("mounting\n"));
d610 2
a611 1
		return error;
d633 2
a634 3
	    (error = st_read_block_limits(st, 0)) != 0) {
		return error;
	}
d643 1
a643 1
		return error;
d666 1
a666 1
			return error;
d670 1
a670 1
		return error;
d677 3
a679 1
	return 0;
d832 2
a833 1
	struct st_softc *st = st_cd.cd_devs[STUNIT(bp->b_dev)];
d835 10
a844 1
	int s;
d846 1
a846 1
	SC_DEBUG(st->sc_link, SDEV_DB2, ("ststrategy: %ld bytes @@ blk %d\n",
d900 1
d905 1
d1095 10
a1104 1
	struct st_softc *st = st_cd.cd_devs[STUNIT(dev)];
d1113 10
a1122 1
	struct st_softc *st = st_cd.cd_devs[STUNIT(dev)];
a1135 1
	int unit;
d1137 1
a1137 1
	int flags;
d1147 3
a1149 3
	flags = 0;		/* give error messages, act on errors etc. */
	unit = STUNIT(dev);
	st = st_cd.cd_devs[unit];
d1152 2
a1153 2
		device_unref(&st->sc_dev);
		return (ENXIO);
d1300 2
a1301 1
	return error;
d1315 1
a1315 1
		return error;
d1332 3
a1334 1
	return 0;
@


1.80
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.79 2007/11/22 03:57:07 krw Exp $	*/
d386 1
a386 1
		if (bdevsw[bmaj].d_open == sdopen) {
d393 1
a393 1
		if (cdevsw[cmaj].d_open == sdopen) {
@


1.79
log
@Ansi-fy.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.78 2007/11/22 03:19:50 krw Exp $	*/
d530 1
a530 1
 * occurence of an open device
@


1.78
log
@Ooops. Don't de-reference st until after it has been pointed at the
correct st_softc. Fixes 'mt rewoffl' panics, as reported on misc@@ by
Jeff Ross and reproduced on my tape machine.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.77 2007/11/16 11:28:34 deraadt Exp $	*/
d296 1
a296 3
stmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d312 1
a312 3
stattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d408 1
a408 3
st_identify_drive(st, inqbuf)
	struct st_softc *st;
	struct scsi_inquiry_data *inqbuf;
d431 1
a431 2
st_loadquirks(st)
	struct st_softc *st;
d456 1
a456 5
stopen(dev, flags, fmt, p)
	dev_t dev;
	int flags;
	int fmt;
	struct proc *p;
d533 1
a533 5
stclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d572 1
a572 3
st_mount_tape(dev, flags)
	dev_t dev;
	int flags;
d672 1
a672 3
st_unmount(st, eject, rewind)
	struct st_softc *st;
	int eject, rewind;
d700 1
a700 3
st_decide_mode(st, first_read)
	struct st_softc *st;
	int	first_read;
d813 1
a813 2
ststrategy(bp)
	struct buf *bp;
d901 1
a901 2
ststart(v)
	void *v;
d1054 1
a1054 2
strestart(v)
	void *v;
d1064 1
a1064 4
stread(dev, uio, iomode)
	dev_t dev;
	struct uio *uio;
	int iomode;
d1073 1
a1073 4
stwrite(dev, uio, iomode)
	dev_t dev;
	struct uio *uio;
	int iomode;
d1086 1
a1086 6
stioctl(dev, cmd, arg, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t arg;
	int flag;
	struct proc *p;
d1292 1
a1292 5
st_read(st, buf, size, flags)
	struct st_softc *st;
	int size;
	int flags;
	char *buf;
d1318 1
a1318 3
st_read_block_limits(st, flags)
	struct st_softc *st;
	int flags;
d1365 1
a1365 3
st_mode_sense(st, flags)
	struct st_softc *st;
	int flags;
d1423 1
a1423 3
st_mode_select(st, flags)
	struct st_softc *st;
	int flags;
d1533 1
a1533 3
st_erase(st, full, flags)
	struct st_softc *st;
	int full, flags;
d1565 1
a1565 5
st_space(st, number, what, flags)
	struct st_softc *st;
	u_int what;
	int flags;
	int number;
d1670 1
a1670 4
st_write_filemarks(st, number, flags)
	struct st_softc *st;
	int flags;
	int number;
d1722 1
a1722 5
st_check_eod(st, position, nmarks, flags)
	struct st_softc *st;
	int position;
	int *nmarks;
	int flags;
d1747 1
a1747 4
st_load(st, type, flags)
	struct st_softc *st;
	u_int type;
	int flags;
d1785 1
a1785 4
st_rewind(st, immediate, flags)
	struct st_softc *st;
	u_int immediate;
	int flags;
d1818 1
a1818 2
st_interpret_sense(xs)
	struct scsi_xfer *xs;
d2007 1
a2007 2
st_touch_tape(st)
	struct st_softc *st;
d2045 1
a2045 5
stdump(dev, blkno, va, size)
	dev_t dev;
	daddr64_t blkno;
	caddr_t va;
	size_t size;
@


1.77
log
@convert code over from sd.c, to let tapes discollect.  Lucas Stefanutti
of pr 5635 confirms this works for him.  similar diff authored by krw
who was unaware i wrote this and mailed it to Lucas...
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.76 2007/09/16 15:54:52 krw Exp $	*/
a1132 5
	if (st->flags & ST_DYING) {
		device_unref(&st->sc_dev);
		return (ENXIO);
	}

d1139 6
@


1.76
log
@A couple of obvious bzero() -> M_ZERO changes I missed.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.75 2007/06/06 17:15:14 deraadt Exp $	*/
d72 1
d191 1
a191 1
/*--------------------present operating parameters, flags etc.----------------*/
d198 1
a198 1
/*--------------------device/scsi parameters----------------------------------*/
d200 1
a200 1
/*--------------------parameters reported by the device ----------------------*/
d204 1
a204 1
/*--------------------parameters reported by the device for this media--------*/
d210 1
a210 1
/*--------------------quirks for the whole drive------------------------------*/
d212 1
a212 1
/*--------------------How we should set up when opening each minor device----*/
d219 1
a219 1
/*--------------------storage for sense data returned by the drive------------*/
d227 4
d252 2
a253 1
	sizeof(struct st_softc), stmatch, stattach
d279 1
d359 48
d479 4
d553 4
d843 5
d934 3
d1133 5
a1288 1
/*-----------------------------*/
d1903 1
a1903 1
	 * and can take a long time.  Rather than having a massive timeout 
d2119 20
@


1.75
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.74 2007/06/01 18:44:48 krw Exp $	*/
d1403 1
a1403 1
	outbuf = malloc(sizeof(*outbuf), M_TEMP, M_NOWAIT);
a1428 1
	bzero(outbuf, sizeof(*outbuf));
@


1.74
log
@No need for tape fields to be daddr_t. int will do.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.73 2007/04/10 17:47:56 miod Exp $	*/
d2038 1
a2038 1
	int blkno;
@


1.73
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.72 2007/01/20 18:21:51 krw Exp $	*/
d207 2
a208 2
	daddr_t media_fileno;		/* relative to BOT. -1 means unknown. */
	daddr_t media_blkno;		/* relative to BOF. -1 means unknown. */
d237 2
a238 2
int	st_space(struct st_softc *, daddr_t, u_int, int);
int	st_write_filemarks(struct st_softc *, daddr_t, int);
d244 1
a244 1
int	st_erase(struct st_softc *, daddr_t, int);
d1060 1
a1060 1
	daddr_t number;
d1505 1
a1505 2
	daddr_t full;
	int flags;
d1541 1
a1541 1
	daddr_t number;
d1615 2
a1616 2
		st->media_fileno = (daddr_t) -1;
		st->media_blkno = (daddr_t) -1;
d1649 1
a1649 1
	daddr_t number;
d2038 1
a2038 1
	daddr_t blkno;
@


1.72
log
@Add media_fileno, media_blkno into st_softc and report their values
back via MTIOCGET ioctl, rather than always reporting -1 (unknown).

Simple 'Set to 0 on rewind, increment on file marks and positioning,
and set back to -1 on any ambiguity' logic. No functional impact on
current operation.

Should allow things like Bacula to work much faster by keeping track
of the current media position.

Adapted from FreeBSD code.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.71 2007/01/05 00:42:47 krw Exp $	*/
d1278 1
a1278 1
 * Ask the drive what it's min and max blk sizes are.
@


1.71
log
@As first brought to my attention by Russel Sutherland, our deletion of
the mt_fileno and mt_blkno fields from the mtget struct was too hasty.

Subsequent discussions with Kern Sibbold of the Bacula project
revealed these are widely used by tape backup software on many
unicies. The de facto standard is to return -1 if you can't determine
the value.

So add them back and always return -1 as their value. Should allow
Bacula and similar software to at least compile while we investigate
providing meaningful values.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.70 2006/12/21 02:05:46 krw Exp $	*/
d207 2
d340 4
d633 3
d973 8
d1096 2
a1097 2
		g->mt_fileno = -1;	/* -1 means we don't know */
		g->mt_blkno = -1;	/* -1 means we don't know */
d1612 1
a1612 1
	return scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
d1614 27
d1653 1
d1679 1
a1679 1
	return scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
d1681 10
d1738 3
d1790 1
a1790 1
	return scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &cmd,
d1793 7
d1876 4
d1920 4
@


1.70
log
@Fix some comment typos. 'immediatly' -> 'immediately', 'tranfer' ->
'transfer', 'tranfered' -> 'transferred'.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.69 2006/12/12 02:44:36 krw Exp $	*/
d1079 2
@


1.69
log
@Give the SCSI layer the ability to requeue i/o's rejected by a driver
using the new NO_CCB result. Currently a no-op since no driver produces
that result.

ok dlg@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.68 2006/11/28 16:56:50 dlg Exp $	*/
d1241 1
a1241 1
	 * If it's a null transfer, return immediatly
d1833 1
a1833 1
		 * If no data was tranfered, do it immediatly
@


1.68
log
@rename scsibus_attach_args to scsi_attach_args. this can help avoid
confusing when trying to attach scsibus to a hba, since it is really meant
for attaching scsi devices to scsibus.

ok deraadt@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.67 2006/11/27 23:14:22 beck Exp $	*/
d60 1
d218 1
d230 1
d329 2
d507 1
d843 1
a843 1
 * ststart() is called at splbio
d853 1
a853 1
	int flags;
d967 1
a967 1
		if (scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
d969 13
a981 1
		    ST_IO_TIME, bp, flags | SCSI_NOSLEEP))
d983 2
d986 11
@


1.67
log
@more magic removal
ok miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.66 2006/11/27 18:24:43 beck Exp $	*/
d288 1
a288 1
	struct scsibus_attach_args *sa = aux;
d307 1
a307 1
	struct scsibus_attach_args *sa = aux;
@


1.66
log
@rework asc/ascq handling to get rid of "magic" 0x values in the code, changes
asc/ascq handling to deal with the pair together rather than seperately, since
modern scsi has long since polluted the "categories" of asc enough that you
pretty much need to always look as ascq.

ok krw@@ deraadt@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.65 2006/10/07 23:40:08 beck Exp $	*/
d1722 1
a1722 1
	    (serr != 0x70 && serr != 0x71))
@


1.65
log
@make cd-roms retry forever while the device indicates that it is
"becoming ready" - this is done in the exact same way that it
was done for tape in st.c. This commit adds a cd specific interpret_sense
routine to cd.c that will catch the becoming ready case and handle it.
This also removes the need to use crazy timeouts to catch this case.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.64 2006/10/02 09:06:26 dlg Exp $	*/
d1742 7
a1748 14
		switch (sense->add_sense_code) {
		case 0x04:	/* LUN not ready */
			switch (sense->add_sense_code_qual) {
				case 0x01: /* Becoming Ready */
					SC_DEBUG(sc_link, SDEV_DB1,
		    			    ("not ready: busy (%#x)\n",
					    sense->add_sense_code_qual));
					/* don't count this as a retry */
					xs->retries++;
					return (scsi_delay(xs, 1));
				default:
					return (EJUSTRETURN);
			}
			break;
@


1.64
log
@get rid of a boolean typedef. this is c, we have ints, deal with it.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.63 2006/06/11 03:59:59 krw Exp $	*/
d434 1
a434 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_TAPE,
d545 1
a545 1
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_TAPE, SCSI_SILENT);
@


1.63
log
@Don't spew sense informaton from the test unit ready command issued by
stopen(). This change was misplaced in the st roto-tilling at c2k6.
Noticed by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.62 2006/06/01 05:42:01 krw Exp $	*/
d225 2
a226 2
void	st_unmount(struct st_softc *, boolean, boolean);
int	st_decide_mode(struct st_softc *, boolean);
d234 1
a234 1
int	st_check_eod(struct st_softc *, boolean, int *, int);
d616 1
a616 1
	boolean eject, rewind;
d643 1
a643 1
	boolean	first_read;
d1616 1
a1616 1
	boolean position;
@


1.62
log
@We do not create st devices with different density modes. i.e. with device
minor numbers having bits 2 or 3 set.

Eliminate the quirks, etc. used to store info on these non-existant modes.
Also eliminate a couple of 'unimplemented' fields in the ioctl request
structure.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.61 2006/05/28 23:58:00 krw Exp $	*/
d435 2
a436 1
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_ILLEGAL_REQUEST);
@


1.61
log
@Miscellaneous fixes.

1) Check the return value from st_mount_tape().

2) Always call st_unmount() if the media goes missing.

3) Use the special handling for 'Unit in the process of becoming
ready' for the TEST UNIT READY command in stopen().

4) Don't unmount a tape during stopen() just because it doesn't have
the current default density. Eliminate now unused last_dsty member of
st_softc.

tested & ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.60 2006/05/28 23:34:34 beck Exp $	*/
a80 1
#define STDSTY(z)	((minor(z) >> 2) & 0x03)
d109 1
a109 1
	struct modes modes[4];
d119 2
a120 6
	 "        ", "                ", "    "}, {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{ST_Q_FORCE_BLKSIZE, 512, QIC_24},	/* minor 4-7 */
		{ST_Q_FORCE_BLKSIZE, 0, HALFINCH_1600},	/* minor 8-11 */
		{ST_Q_FORCE_BLKSIZE, 0, HALFINCH_6250}	/* minor 12-15 */
	}}},
d122 2
a123 6
	 "TANDBERG", " TDC 3600       ", ""},     {0, {
		{0, 0, 0},				/* minor 0-3 */
		{ST_Q_FORCE_BLKSIZE, 0, QIC_525},	/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d125 2
a126 6
 	 "TANDBERG", " TDC 3800       ", ""},     {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{0, 0, QIC_525},			/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d132 2
a133 6
	 "ARCHIVE ", "VIPER 2525 25462", ""},     {0, {
		{ST_Q_SENSE_HELP, 0, 0},		/* minor 0-3 */
		{ST_Q_SENSE_HELP, 0, QIC_525},		/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d139 2
a140 6
	 "SANKYO  ", "CP525           ", ""},    {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{ST_Q_FORCE_BLKSIZE, 512, QIC_525},	/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d142 2
a143 6
	 "ANRITSU ", "DMT780          ", ""},     {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{ST_Q_FORCE_BLKSIZE, 512, QIC_525},	/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d145 2
a146 6
	 "ARCHIVE ", "VIPER 150  21247", ""},     {0, {
		{0, 0, 0},				/* minor 0-3 */
		{0, 0, QIC_150},			/* minor 4-7 */
		{0, 0, QIC_120},			/* minor 8-11 */
		{0, 0, QIC_24}				/* minor 12-15 */
	}}},
d148 2
a149 6
	 "ARCHIVE ", "VIPER 150  21531", ""},     {0, {
		{ST_Q_SENSE_HELP, 0, 0},		/* minor 0-3 */
		{0, 0, QIC_150},			/* minor 4-7 */
		{0, 0, QIC_120},			/* minor 8-11 */
		{0, 0, QIC_24}				/* minor 12-15 */
	}}},
d151 2
a152 6
	 "WANGTEK ", "5099ES SCSI", ""},          {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{0, 0, QIC_11},				/* minor 4-7 */
		{0, 0, QIC_24},				/* minor 8-11 */
		{0, 0, QIC_24}				/* minor 12-15 */
	}}},
d154 2
a155 6
	 "WANGTEK ", "5150ES SCSI", ""},          {0, {
		{ST_Q_FORCE_BLKSIZE, 512, 0},		/* minor 0-3 */
		{0, 0, QIC_24},				/* minor 4-7 */
		{0, 0, QIC_120},			/* minor 8-11 */
		{0, 0, QIC_150}				/* minor 12-15 */
	}}},
d157 2
a158 6
	 "WANGTEK ", "5525ES SCSI REV7", ""},     {0, {
		{0, 0, 0},				/* minor 0-3 */
		{ST_Q_BLKSIZE, 0, QIC_525},		/* minor 4-7 */
		{0, 0, QIC_150},			/* minor 8-11 */
		{0, 0, QIC_120}				/* minor 12-15 */
	}}},
d160 2
a161 6
	 "WangDAT ", "Model 1300      ", ""},     {0, {
		{0, 0, 0},				/* minor 0-3 */
		{ST_Q_FORCE_BLKSIZE, 512, DDS},		/* minor 4-7 */
		{ST_Q_FORCE_BLKSIZE, 1024, DDS},	/* minor 8-11 */
		{ST_Q_FORCE_BLKSIZE, 0, DDS}		/* minor 12-15 */
	}}},
d163 2
a164 6
	 "EXABYTE ", "EXB-8200        ", "263H"}, {0, {
		{0, 0, 0},				/* minor 0-3 */
		{0, 0, 0},				/* minor 4-7 */
		{0, 0, 0},				/* minor 8-11 */
		{0, 0, 0}				/* minor 12-15 */
	}}},
d166 2
a167 6
	 "HP      ", "T4000s          ", ""},     {ST_Q_UNIMODAL, {
		{0, 0, QIC_3095},			/* minor 0-3 */
		{0, 0, QIC_3095},			/* minor 4-7 */
		{0, 0, QIC_3095},			/* minor 8-11 */
		{0, 0, QIC_3095},			/* minor 12-15 */
	}}},
d170 2
a171 6
	 "EXABYTE ", "EXB-8200        ", ""},     {0, {
		{0, 0, 0},				/* minor 0-3 */
		{0, 0, 0},				/* minor 4-7 */
		{0, 0, 0},				/* minor 8-11 */
		{0, 0, 0}				/* minor 12-15 */
	}}},
d174 2
a175 6
	 "WANGTEK ", "5150ES SCSI FA15\0""01 A", "????"}, {0, {
		{0, ST_Q_IGNORE_LOADS, 0},		/* minor 0-3 */
		{0, 0, 0},				/* minor 4-7 */
		{0, 0, 0},				/* minor 8-11 */
		{0, 0, 0}				/* minor 12-15 */
	}}},
d177 2
a178 7
	 "TEAC    ", "MT-2ST/N50      ", ""},     {ST_Q_IGNORE_LOADS, {
		{0, 0, 0},				/* minor 0-3 */
		{0, 0, 0},				/* minor 4-7 */
		{0, 0, 0},				/* minor 8-11 */
		{0, 0, 0}				/* minor 12-15 */
	}}},

d209 2
a210 2
	struct modes modes[4];	/* plus more for each mode            */
	u_int8_t  modeflags[4];	/* flags for the modes                */
a373 1
	int i;
d377 13
a389 17
	mode = st->quirkdata->modes;
	mode2 = st->modes;
	for (i = 0; i < 4; i++) {
		bzero(mode2, sizeof(struct modes));
		st->modeflags[i] &= ~(BLKSIZE_SET_BY_QUIRK |
		    DENSITY_SET_BY_QUIRK | BLKSIZE_SET_BY_USER |
		    DENSITY_SET_BY_USER);
		if ((mode->quirks | st->drive_quirks) & ST_Q_FORCE_BLKSIZE) {
			mode2->blksize = mode->blksize;
			st->modeflags[i] |= BLKSIZE_SET_BY_QUIRK;
		}
		if (mode->density) {
			mode2->density = mode->density;
			st->modeflags[i] |= DENSITY_SET_BY_QUIRK;
		}
		mode++;
		mode2++;
d516 1
a516 1
	u_int mode, dsty;
a522 1
	dsty = STDSTY(dev);
d530 1
a530 1
	st->quirks = st->drive_quirks | st->modes[dsty].quirks;
d576 2
a577 2
	if (st->modeflags[dsty] & (DENSITY_SET_BY_QUIRK | DENSITY_SET_BY_USER))
		st->density = st->modes[dsty].density;
d586 2
a587 2
	if (st->modeflags[dsty] & (BLKSIZE_SET_BY_QUIRK | BLKSIZE_SET_BY_USER)) {
		st->blksize = st->modes[dsty].blksize;
d1005 1
a1005 1
	int nmarks, dsty;
a1017 1
	dsty = STDSTY(dev);
d1039 2
a1040 8
		g->mt_mblksiz[0] = st->modes[0].blksize;
		g->mt_mblksiz[1] = st->modes[1].blksize;
		g->mt_mblksiz[2] = st->modes[2].blksize;
		g->mt_mblksiz[3] = st->modes[3].blksize;
		g->mt_mdensity[0] = st->modes[0].density;
		g->mt_mdensity[1] = st->modes[1].density;
		g->mt_mdensity[2] = st->modes[2].density;
		g->mt_mdensity[3] = st->modes[3].density;
d1184 2
a1185 2
		st->modes[dsty].blksize = st->blksize;
		st->modeflags[dsty] |= BLKSIZE_SET_BY_USER;
d1188 2
a1189 2
		st->modes[dsty].density = st->density;
		st->modeflags[dsty] |= DENSITY_SET_BY_USER;
@


1.60
log
@This commit changes the interpret_sense routine for st to catch the
"Unit Becoming Ready" case, and just like ch, allow the driver to
continue waiting, as long as the unit continues to promise us that
the unit is becoming ready. This avoids the case of slow tape drives
taking forever to bring media online requiring a huge retry count
being set for all commands, and like ch, will wait indefinately
only in this case. All other cases are handled as before.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.59 2006/05/28 23:26:35 krw Exp $	*/
a263 1
	u_int last_dsty;	/* last density opened                */
a479 1
	u_int dsty;
d484 1
a484 1
		return ENXIO;
d487 1
a487 1
		return ENXIO;
a488 1
	dsty = STDSTY(dev);
d495 1
a495 1
	 * Only allow one at a time
d499 1
a499 1
		return EBUSY;
d502 3
d506 2
a507 1
	 * Discard any outstanding unit attention errors.
a510 4
	if (error)
		goto bad;

	sc_link->flags |= SDEV_OPEN;	/* unit attn are now errors */
d513 1
a513 3
	 * if it's a different mode, or if the media has been
	 * invalidated, unmount the tape from the previous
	 * session but continue with open processing
d515 1
a515 1
	if (st->last_dsty != dsty || !(sc_link->flags & SDEV_MEDIA_LOADED))
d518 11
a528 3
	if (!(st->flags & ST_MOUNTED)) {
		st_mount_tape(dev, flags);
		st->last_dsty = dsty;
d540 1
a540 6
	return 0;

bad:
	st_unmount(st, NOEJECT, DOREWIND);
	sc_link->flags &= ~SDEV_OPEN;
	return error;
@


1.59
log
@In the absence of a coherent concept of 'RAW' tape devices, pass all
unhandled ioctl requests to scsi_do_ioctl() like ch.c does. Previously
only the mythical 'control devices' with certain minor numbers would
pass the requests along.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.58 2006/05/28 23:19:25 krw Exp $	*/
d1810 33
@


1.58
log
@Whack a 'control device' leftover. Actually save the new density, etc.
that was just accepted by the device, no matter what the minor is.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.57 2006/05/28 20:04:52 krw Exp $	*/
d549 1
a549 1
int 
d1243 1
a1243 1
		error = ENOTTY;
@


1.57
log
@We don't have 'control devices' for st. Nor are we likely to get any
in the foreseeable future. Eliminate half-baked, semi-operational code
that tried to handle such devices. People who had stumbled across the
previous control-like behaviour of erstX devices should not be relying
on these semantics.

Suggested by deraadt@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.56 2006/05/28 19:31:09 krw Exp $	*/
a1265 2
	 *
	 * The means for deciding this are not finalised yet
d1267 9
a1275 13
	if (STMODE(dev) == 0x03) {
		/* special mode */
		/* XXX */
		switch ((short) (mt->mt_op)) {
		case MTSETBSIZ:
			st->modes[dsty].blksize = st->blksize;
			st->modeflags[dsty] |= BLKSIZE_SET_BY_USER;
			break;
		case MTSETDNSTY:
			st->modes[dsty].density = st->density;
			st->modeflags[dsty] |= DENSITY_SET_BY_USER;
			break;
		}
d1277 1
@


1.56
log
@ST_NEW_MOUNT was set/reset in a number of places but only examined inside
a #if notyet/#endif block. It's been 'notyet' since 1995. Eliminate it.

'flense!' beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.55 2006/05/28 07:18:30 krw Exp $	*/
a82 1
#define STCTLMODE(z)	(minor(z) & (1 << 23))
d506 1
a506 1
	 * Catch any unit attention errors.
d509 2
a510 3
	    SCSI_IGNORE_MEDIA_CHANGE | SCSI_IGNORE_ILLEGAL_REQUEST |
	    ((fmt == S_IFCHR) ? SCSI_SILENT : 0));
	if (error && (fmt != S_IFCHR))
a514 6
	/* Allow control mode devices to open successfully without changing
	 * the state of the device.
	 */
	if (STCTLMODE(dev))
		return 0;

a522 4
	/*
	 * If we are not mounted, then we should start a new
	 * mount session.
	 */
d1243 1
a1243 5
		if (STCTLMODE(dev))
			error = scsi_do_ioctl(st->sc_link, dev,
			    cmd, arg, flag, p);
		else
			error = ENOTTY;
@


1.55
log
@Use TEST_READY_RETRIES_TAPE instead of TEST_READY_RETRIES_DEFAULT,
thus allowing tape drives more time to become ready.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.54 2006/05/28 07:07:09 krw Exp $	*/
a333 1
#define	ST_NEW_MOUNT	0x0040	/* still need to decide mode              */
a619 1
	st->flags |= ST_NEW_MOUNT;
a689 1
	st->flags &= ~ST_NEW_MOUNT;
d720 1
a720 1
	st->flags &= ~(ST_MOUNTED | ST_NEW_MOUNT);
a1203 7
#ifdef	NOTYET
			if (!(st->flags & ST_NEW_MOUNT)) {
				uprintf("re-mount tape before changing blocksize");
				error = EINVAL;
				break;
			}
#endif
@


1.54
log
@Use bit 23 of the device minor to indicate a control mode device. A
control mode device can be opened but does not permit any i/o.

Currently no such devices are created by MAKEDEV. However the previous
code used bits 0 and 1 of the minor being set to indicate a control
device. This conflicted with other uses of device minors to indicate
things like rewind and eject. This behaviour would result in an open
of a newly loaded tape drive failing until the tape was successfully
mounted as a side effect of another command like 'mt status'.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.53 2006/05/28 00:47:45 krw Exp $	*/
d510 1
a510 1
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d636 1
a636 1
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT, SCSI_SILENT);
@


1.53
log
@Always allow ioctl's to work, even if there is no media loaded.
Analogous to what sd does for the raw partition.  Eliminates useless
error messages and premature command completion. e.g. 'mt status' will
wait for media to to finish loading.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.52 2006/05/28 00:27:09 krw Exp $	*/
d83 1
a83 1
#define CTLMODE	3
d518 4
a521 2
	/* Allow ioctl's to proceed in all cases, even if we can't mount. */
	if (error && (fmt == S_IFCHR))
d1265 1
a1265 1
		if (STMODE(dev) == CTLMODE)
@


1.52
log
@Don't print tape media information during probe. This is transitory
information that doesn't have anything to do with the device. We don't
say 'cd drive empty or not ready."

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.51 2006/05/11 00:45:59 krw Exp $	*/
d63 1
d475 1
a475 1
stopen(dev, flags, mode, p)
d478 1
a478 1
	int mode;
d481 1
a481 3
	int unit;
	u_int stmode, dsty;
	int error = 0;
d483 2
a484 1
	struct scsi_link *sc_link;
a492 1
	stmode = STMODE(dev);
d511 3
a513 3
	    SCSI_IGNORE_MEDIA_CHANGE |
	    (stmode == CTLMODE ? SCSI_IGNORE_NOT_READY : 0));
	if (error)
d518 2
a519 6
	/*
	 * If the mode is 3 (e.g. minor = 3,7,11,15)
	 * then the device has been opened to set defaults
	 * This mode does NOT ALLOW I/O, only ioctls
	 */
	if (stmode == CTLMODE)
@


1.51
log
@Zap trailing whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.50 2005/09/11 17:34:27 krw Exp $	*/
a395 6

	/*
	 * Use the subdriver to request information regarding
	 * the drive. We cannot use interrupts yet, so the
	 * request must specify this.
	 */
a396 16
	printf("%s: %s", st->sc_dev.dv_xname, st->quirkdata ? "rogue, " : "");
	if (scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_TAPE,
	    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE) ||
	    st_mode_sense(st,
	    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE)) {
		printf("drive empty or not ready\n");
	}
	else {
		printf("density code 0x%x, ", st->media_density);
		if (st->media_blksize > 0)
			printf("%d-byte", st->media_blksize);
		else
			printf("variable");
		printf(" blocks, write-%s\n",
		    (st->flags & ST_READONLY) ? "protected" : "enabled");
	}
@


1.50
log
@Simplify code by changing struct scsi_mode_sense_buf{ union {}
headers; } to just union scsi_mode_sense_buf {}. No functional change.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.49 2005/08/23 23:38:00 krw Exp $	*/
d495 1
a495 1
int 
d956 1
a956 1
void 
d1444 1
a1444 1
	}	
d1447 1
a1447 1
	
d1457 1
a1457 1
	
d1470 1
a1470 1
	
d1497 1
a1497 1
	}		
d1517 1
a1517 1
	}	
d1583 1
a1583 1
	    flags, ST_CTL_TIME); 
@


1.49
log
@Move uses of struct scsi_mode_sense_buf (255 bytes each) from the
stack into malloc'd memory.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.48 2005/06/24 20:48:25 krw Exp $	*/
d1424 1
a1424 1
	struct scsi_mode_sense_buf *data;
d1449 1
a1449 1
		dev_spec = data->headers.hdr_big.dev_spec;
d1451 1
a1451 1
		dev_spec = data->headers.hdr.dev_spec;
d1484 1
a1484 1
	struct scsi_mode_sense_buf *inbuf, *outbuf;
d1540 5
a1544 6
		page0_size = inbuf->headers.hdr.data_length +
		    sizeof(inbuf->headers.hdr.data_length) -
		    sizeof(inbuf->headers.hdr) -
		    inbuf->headers.hdr.blk_desc_len;
		memcpy(&outbuf->headers.buf[sizeof(outbuf->headers.hdr)+
		    sizeof(general)], page0, page0_size);
d1546 6
a1551 6
		page0_size = _2btol(inbuf->headers.hdr_big.data_length) +
		    sizeof(inbuf->headers.hdr_big.data_length) -
		    sizeof(inbuf->headers.hdr_big) -
		    _2btol(inbuf->headers.hdr_big.blk_desc_len);
		memcpy(&outbuf->headers.buf[sizeof(outbuf->headers.hdr_big) + 
		    sizeof(general)], page0, page0_size);
d1558 1
a1558 1
		outbuf->headers.hdr.data_length = sizeof(outbuf->headers.hdr) +
d1560 1
a1560 1
		    sizeof(outbuf->headers.hdr.data_length);
d1562 3
a1564 3
			outbuf->headers.hdr.dev_spec = SMH_DSP_BUFF_MODE_ON;
		outbuf->headers.hdr.blk_desc_len = sizeof(general);
		memcpy(&outbuf->headers.buf[sizeof(outbuf->headers.hdr)],
d1566 1
a1566 1
		error = scsi_mode_select(st->sc_link, 0, &outbuf->headers.hdr,
d1574 2
a1575 3
	_lto2b((sizeof(outbuf->headers.hdr_big) + sizeof(general) + page0_size -
	    sizeof(outbuf->headers.hdr_big.data_length)),
	    outbuf->headers.hdr_big.data_length);
d1577 3
a1579 3
		outbuf->headers.hdr_big.dev_spec = SMH_DSP_BUFF_MODE_ON;
	_lto2b(sizeof(general), outbuf->headers.hdr_big.blk_desc_len);
	memcpy(&outbuf->headers.buf[sizeof(outbuf->headers.hdr_big)], &general,
d1582 1
a1582 1
	error = scsi_mode_select_big(st->sc_link, 0, &outbuf->headers.hdr_big,
@


1.48
log
@Move st.c to new mode sense mechanism. Don't save page0 data (if any), just
ask for it when needed. Eliminate the page_0_size quirk.

Tested on various tape drives by myself, hshoexer@@ and henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.47 2005/06/05 21:27:07 krw Exp $	*/
d1424 1
a1424 1
	struct scsi_mode_sense_buf data;
d1432 4
d1439 1
a1439 1
	error = scsi_do_mode_sense(sc_link, 0, &data, (void **)&page0,
d1441 2
a1442 1
	if (error != 0)
d1444 1
d1449 1
a1449 1
		dev_spec = data.headers.hdr_big.dev_spec;
d1451 1
a1451 1
		dev_spec = data.headers.hdr.dev_spec;
d1470 3
a1472 2

	return 0;
d1484 1
a1484 1
	struct scsi_mode_sense_buf inbuf, outbuf;
d1490 9
d1508 3
a1510 1
		return 0;
d1513 5
a1517 2
	if (sc_link->flags & SDEV_ATAPI)
		return 0;
d1519 1
a1519 1
	bzero(&outbuf, sizeof(outbuf));
d1529 1
a1529 1
	error = scsi_do_mode_sense(sc_link, 0, &inbuf, (void **)&page0, NULL,
d1531 3
a1533 1
	if (error != 0)
d1535 1
d1540 5
a1544 4
		page0_size = inbuf.headers.hdr.data_length +
		    sizeof(inbuf.headers.hdr.data_length) -
		    sizeof(inbuf.headers.hdr) - inbuf.headers.hdr.blk_desc_len;
		memcpy(&outbuf.headers.buf[sizeof(outbuf.headers.hdr)+
d1547 5
a1551 5
		page0_size = _2btol(inbuf.headers.hdr_big.data_length) +
		    sizeof(inbuf.headers.hdr_big.data_length) -
		    sizeof(inbuf.headers.hdr_big) -
		    _2btol(inbuf.headers.hdr_big.blk_desc_len);
		memcpy(&outbuf.headers.buf[sizeof(outbuf.headers.hdr_big) + 
d1559 1
a1559 1
		outbuf.headers.hdr.data_length = sizeof(outbuf.headers.hdr) +
d1561 1
a1561 1
		    sizeof(outbuf.headers.hdr.data_length);
d1563 3
a1565 3
			outbuf.headers.hdr.dev_spec = SMH_DSP_BUFF_MODE_ON;
		outbuf.headers.hdr.blk_desc_len = sizeof(general);
		memcpy(&outbuf.headers.buf[sizeof(outbuf.headers.hdr)],
d1567 5
a1571 2
		return (scsi_mode_select(st->sc_link, 0, &outbuf.headers.hdr,
		    flags, ST_CTL_TIME)); 
d1575 3
a1577 3
	_lto2b((sizeof(outbuf.headers.hdr_big) + sizeof(general) + page0_size -
	    sizeof(outbuf.headers.hdr_big.data_length)),
	    outbuf.headers.hdr_big.data_length);
d1579 3
a1581 3
		outbuf.headers.hdr_big.dev_spec = SMH_DSP_BUFF_MODE_ON;
	_lto2b(sizeof(general), outbuf.headers.hdr_big.blk_desc_len);
	memcpy(&outbuf.headers.buf[sizeof(outbuf.headers.hdr_big)], &general,
d1583 6
a1588 2
	return (scsi_mode_select_big(st->sc_link, 0, &outbuf.headers.hdr_big,
	    flags, ST_CTL_TIME)); 
@


1.47
log
@Fix scsi_mode_select() and scsi_mode_select_big() to send just the
required number of bytes, rather than a full scsi_mode_sense_buf. Some
devices (e.g. my HP SureStore DAT/24) decline to accept such oversized
transfers. Instead, force callers to fill in the data_length field in
the header and use that information to set the size of the transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.46 2005/05/14 00:20:43 krw Exp $	*/
a109 2
	u_int page_0_size;
#define	MAX_PAGE_0_SIZE	64
d120 1
a120 1
	 "        ", "                ", "    "}, {0, 0, {
d127 1
a127 1
	 "TANDBERG", " TDC 3600       ", ""},     {0, 12, {
d134 1
a134 1
 	 "TANDBERG", " TDC 3800       ", ""},     {0, 0, {
d145 1
a145 1
	 "ARCHIVE ", "VIPER 2525 25462", ""},     {0, 0, {
d156 1
a156 1
	 "SANKYO  ", "CP525           ", ""},    {0, 0, {
d163 1
a163 1
	 "ANRITSU ", "DMT780          ", ""},     {0, 0, {
d170 1
a170 1
	 "ARCHIVE ", "VIPER 150  21247", ""},     {0, 12, {
d177 1
a177 1
	 "ARCHIVE ", "VIPER 150  21531", ""},     {0, 12, {
d184 1
a184 1
	 "WANGTEK ", "5099ES SCSI", ""},          {0, 0, {
d191 1
a191 1
	 "WANGTEK ", "5150ES SCSI", ""},          {0, 0, {
d198 1
a198 1
	 "WANGTEK ", "5525ES SCSI REV7", ""},     {0, 0, {
d205 1
a205 1
	 "WangDAT ", "Model 1300      ", ""},     {0, 0, {
d212 1
a212 1
	 "EXABYTE ", "EXB-8200        ", "263H"}, {0, 5, {
d219 1
a219 1
	 "HP      ", "T4000s          ", ""},     {ST_Q_UNIMODAL, 0, {
d227 1
a227 1
	 "EXABYTE ", "EXB-8200        ", ""},     {0, 12, {
d235 1
a235 1
	 "WANGTEK ", "5150ES SCSI FA15\0""01 A", "????"}, {0, 0, {
d242 1
a242 1
	 "TEAC    ", "MT-2ST/N50      ", ""},     {ST_Q_IGNORE_LOADS, 0, {
a263 1
	u_int page_0_size;	/* size of page 0 data		      */
d274 3
a276 3
	u_long numblks;		/* nominal blocks capacity            */
	int media_blksize;	/* 0 if not ST_FIXEDBLOCKS            */
	u_int8_t media_density;	/* this is what it said when asked    */
a286 4
	u_char sense_data[MAX_PAGE_0_SIZE];	/*
						 * additional sense data needed
						 * for mode sense/select.
						 */
a454 1
		st->page_0_size = finger->quirkdata.page_0_size;
d1424 1
a1424 7
	size_t scsi_sense_len;
	int error;
	struct scsi_sense {
		struct scsi_mode_header header;
		struct scsi_blk_desc blk_desc;
		u_char sense_data[MAX_PAGE_0_SIZE];
	} scsi_sense;
d1426 20
d1447 1
a1447 16
	scsi_sense_len = 12 + st->page_0_size;

	/*
	 * Ask for page 0 mode sense data.
	 */
	bzero(&scsi_sense, sizeof(scsi_sense));
	error = scsi_mode_sense(sc_link, 0, 0,
	    (struct scsi_mode_header *)&scsi_sense, scsi_sense_len, flags,
	    ST_CTL_TIME);
	if (error)
		return error;

	st->numblks = _3btol(scsi_sense.blk_desc.nblocks);
	st->media_blksize = _3btol(scsi_sense.blk_desc.blklen);
	st->media_density = scsi_sense.blk_desc.density;
	if (scsi_sense.header.dev_spec & SMH_DSP_WRITE_PROT)
d1451 5
d1461 2
a1462 4
	    ("%sbuffered\n",
	    scsi_sense.header.dev_spec & SMH_DSP_BUFF_MODE ? "" : "un"));
	if (st->page_0_size)
		bcopy(scsi_sense.sense_data, st->sense_data, st->page_0_size);
d1464 1
d1477 2
a1478 5
	struct scsi_select {
		struct scsi_mode_header header;
		struct scsi_blk_desc blk_desc;
		u_char sense_data[MAX_PAGE_0_SIZE];
	} scsi_select;
d1480 2
d1484 3
a1486 3
	 * This quirk deals with drives that have only one valid mode
	 * and think this gives them license to reject all mode selects,
	 * even if the selected mode is the one that is supported.
d1498 7
d1506 1
a1506 2
	 * Set up for a mode select. Remember that data_length is the 
	 * size less the size of the data_length field.
d1508 21
a1528 14
	bzero(&scsi_select, sizeof(scsi_select));
	scsi_select.header.data_length = sizeof(scsi_select.header) +
	    sizeof(scsi_select.blk_desc) + st->page_0_size - 1;
	scsi_select.header.blk_desc_len = sizeof(struct scsi_blk_desc);
	scsi_select.header.dev_spec &= ~SMH_DSP_BUFF_MODE;
	scsi_select.blk_desc.density = st->density;
	if (st->flags & ST_DONTBUFFER)
		scsi_select.header.dev_spec |= SMH_DSP_BUFF_MODE_OFF;
	else
		scsi_select.header.dev_spec |= SMH_DSP_BUFF_MODE_ON;
	if (st->flags & ST_FIXEDBLOCKS)
		_lto3b(st->blksize, scsi_select.blk_desc.blklen);
	if (st->page_0_size)
		bcopy(st->sense_data, scsi_select.sense_data, st->page_0_size);
d1531 26
a1556 4
	 * do the command
	 */
	return (scsi_mode_select(st->sc_link, 0,
	    (struct scsi_mode_header *)&scsi_select, flags, ST_CTL_TIME)); 
@


1.46
log
@Add scsi_mode_[sense|select]_big() and use it instead of
atapi_mode_[sense|select](). This will allow the removal of
atapi_base.c and atapi_all.h files, and sets the stage for better usb
mode sense handling amoung other things.

Remove cd_scsibus_[get|set]_mode() and
sd_scsibus_mode_sense() shims in favour of scsi_mode_[sense|select]().
Add zero'ing of reserved length field in scsi_mode_select(). Change
some uchar * type parameters to scsi_mode_header *.

No functional changes. Mostly from NetBSD.

ok dlg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.45 2005/04/06 02:51:13 krw Exp $	*/
a1481 1
	u_int scsi_select_len;
a1488 2
	scsi_select_len = 12 + st->page_0_size;

d1505 2
a1506 1
	 * Set up for a mode select
d1508 3
a1510 1
	bzero(&scsi_select, scsi_select_len);
d1527 1
a1527 2
	    (struct scsi_mode_header *)&scsi_select, scsi_select_len, flags,
	    ST_CTL_TIME)); 
@


1.45
log
@De-register scsi.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.44 2005/04/05 12:13:16 krw Exp $	*/
d1446 4
a1449 2
	error = scsi_mode_sense(sc_link, 0, 0, (u_char *)&scsi_sense,
	    scsi_sense_len, flags, ST_CTL_TIME);
d1526 3
a1528 2
	return scsi_mode_select(st->sc_link, 0, (u_char *)&scsi_select,
	    scsi_select_len, flags, ST_CTL_TIME); 
@


1.44
log
@Factor out scsi_mode_sense() and scsi_mode_select() like NetBSD does.
Eliminate some duplicate structures and defines along the way. SCSI CD
drives will now pay attention to the 'flags' parameter for MODE SENSE
and MODE SELECT commands. No other functional change.

ok tdeval@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.43 2004/11/30 19:28:37 krw Exp $	*/
d970 1
a970 1
	register struct buf *bp, *dp;
@


1.43
log
@No longer require write permission for read-only SCSI commands
submitted via ioctl. Eliminate scsi_do_safeioctl(), thus permitting
ch, ss and st devices to submit SCSI commands. Return EPERM rather
than EBADF when permissions are inadequate.

Allows more programs to run with fewer permissions. Problem diagnosed
by Nikolay Sturm in mplayer port.

Tested by Nikolay, ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.42 2004/10/16 04:05:39 krw Exp $	*/
d1432 1
a1432 1
	u_int scsi_sense_len;
a1433 1
	struct scsi_mode_sense cmd;
d1444 1
a1444 1
	 * Set up a mode sense
d1446 2
a1447 13
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = MODE_SENSE;
	cmd.length = scsi_sense_len;

	/*
	 * do the command, but we don't need the results
	 * just print them for our interest's sake, if asked,
	 * or if we need it as a template for the mode select
	 * store it away.
	 */
	error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) &scsi_sense, scsi_sense_len,
	    ST_RETRIES, ST_CTL_TIME, NULL, flags | SCSI_DATA_IN);
a1480 1
	struct scsi_mode_select cmd;
a1507 4
	bzero(&cmd, sizeof(cmd));
	cmd.opcode = MODE_SELECT;
	cmd.length = scsi_select_len;

d1524 2
a1525 3
	return scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) &scsi_select, scsi_select_len,
	    ST_RETRIES, ST_CTL_TIME, NULL, flags | SCSI_DATA_OUT);
@


1.42
log
@Fix 'Tape block size (32754) not a multiple of dump block size
(1024).' errors in restore(1).

Check for SDEV_OPEN in sc_link->flags (where it lives) rather than
sense->flags (where it doesn't).

Problem noted by John Danks on misc@@ and reinforced by Otto & Hugh.

ok marco@@ hugh@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.41 2004/08/01 23:01:06 marco Exp $	*/
d1299 1
a1299 1
			error = scsi_do_safeioctl(st->sc_link, dev,
@


1.41
log
@Remove openings = 1 and inherit the value from the HBA instead.  This keeps the tape device stuffed with data and therefore it rewinds less often to reposition.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.40 2004/06/22 00:43:25 marco Exp $	*/
d1818 1
a1818 1
	if (((sense->flags & SDEV_OPEN) == 0) ||
@


1.41.2.1
log
@MFC:
Fix by krw@@

Fix 'Tape block size (32754) not a multiple of dump block size
(1024).' errors in restore(1).

Check for SDEV_OPEN in sc_link->flags (where it lives) rather than
sense->flags (where it doesn't).

Problem noted by John Danks on misc@@ and reinforced by Otto & Hugh.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.41 2004/08/01 23:01:06 marco Exp $	*/
d1818 1
a1818 1
	if (((sc_link->flags & SDEV_OPEN) == 0) ||
@


1.40
log
@Add additional retries in TUR to allow for tape devices to settle after a reset.
More informative failure message and silence "already open" message.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.39 2004/05/28 23:50:15 krw Exp $	*/
a396 1
	sc_link->openings = 1;
@


1.39
log
@Clean up sense error logic and printing a bit, partly inspired by
NetBSD. Try to limit special handling of sense errors in sd and st to
a minimum.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.38 2004/05/17 23:57:51 krw Exp $	*/
d412 1
a412 1
	if (scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d415 3
a417 2
	    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE))
		printf("drive empty\n");
d535 1
a535 1
		printf("%s: already open\n", st->sc_dev.dv_xname);
@


1.38
log
@Elminate SCSIRET_* synonyms for EJUSTRETURN and ERESTART by using
EJUSTRETURN and ERESTART instead. Delete unused SCSIRET_RETRY define.
From NetBSD.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.37 2004/05/17 12:37:13 aoyama Exp $	*/
d1810 1
d1812 1
a1812 1
	struct scsi_sense_data *sense = &xs->sense;
d1814 2
a1815 2
	struct st_softc *st = sc_link->device_softc;
	u_int8_t key;
d1818 15
a1839 2
	if ((sense->error_code & SSD_ERRCODE) != 0x70)
		return EJUSTRETURN; /* let the generic code handle it */
d1918 1
a1918 1
			return 0;
a1920 1
	key = sense->flags & SSD_KEY;
d1922 1
a1922 1
	if (key == 0x8) {
d1924 3
a1926 4
		 * This quirk code helps the drive read the
		 * first tape block, regardless of format.  That
		 * is required for these drives to return proper
		 * MODE SENSE information.
d1939 1
a1939 1
			return 0;
d1942 2
a1943 1
	return EJUSTRETURN;
@


1.37
log
@Add a quirk entry for TEAC compact cassette tape drive, taken from NetBSD.
ok miod@@ tdeval@@ marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.36 2004/05/09 04:01:59 krw Exp $	*/
d1825 1
a1825 1
		return SCSIRET_CONTINUE; /* let the generic code handle it */
d1930 1
a1930 1
	return SCSIRET_CONTINUE;
@


1.36
log
@Add missing <cr>'s to various SC_DEBUG() calls, along with a few other
SC_DEBUG() spacing tweaks.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.35 2003/05/18 16:06:35 mickey Exp $	*/
d243 8
@


1.35
log
@constify the quirck tables and fix the scsi_inqmatch() proto accordingly; krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.34 2003/03/11 01:12:09 krw Exp $	*/
d381 1
a381 1
	SC_DEBUG(sc_link, SDEV_DB2, ("stattach: "));
d645 1
a645 1
	SC_DEBUG(sc_link, SDEV_DB1, ("mounting\n "));
d880 2
a881 2
	SC_DEBUG(st->sc_link, SDEV_DB1,
	    ("ststrategy %ld bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
d883 1
a883 1
	 * If it's a null transfer, return immediatly
d966 1
a966 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ststart "));
d1466 1
a1466 1
	SC_DEBUG(sc_link, SDEV_DB3,
@


1.34
log
@Fix incorrect restriction on valid scsi tape density code values, allowing all
currently valid values (0 - 0xff) to be used in mt(1). Add sanity
check to catch negative values.

Minor cleanup so mt_count values are stored in daddr_t variables and
not ints. Eliminate unnecessary cast of mt_op, since it is already a
shot. Leave possible move of mt_count to int32_t rather than daddr_t
to post-3.3.

Problem found, and original diff by Joseph Bender.

costa@@ henning@@ tdeval@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.33 2002/12/30 21:50:29 grange Exp $	*/
d120 1
a120 1
struct st_quirk_inquiry_pattern st_quirk_patterns[] = {
d267 1
a267 1
	struct quirkdata *quirkdata;	/* if we have a rogue entry           */
d349 1
a349 1
struct scsi_inquiry_pattern st_patterns[] = {
d363 1
a363 1
	    (caddr_t)st_patterns, sizeof(st_patterns)/sizeof(st_patterns[0]),
d443 1
a443 1
	struct st_quirk_inquiry_pattern *finger;
d446 2
a447 2
	finger = (struct st_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    (caddr_t)st_quirk_patterns,
d469 1
a469 1
	struct	modes *mode;
@


1.33
log
@Add new parameter to scsi_test_unit_ready(): retries number.
Use increased retries number and don't ignore SCSI_IGNORE_NOT_READY
when call scsi_test_unit_ready() for cd-rom, this makes system wait
if drive is loading media.
Tested by millert@@ and fgsch@@; some input and ok from krw@@.
Problem reported by The lord of the CD-writers
Igor Grabin <violent@@death.kiev.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.32 2002/06/09 00:05:57 art Exp $	*/
d89 1
a89 1
 * Maximum density code known.
d91 1
a91 1
#define SCSI_2_MAX_DENSITY_CODE		0x45
d302 2
a303 2
int	st_space(struct st_softc *, int, u_int, int);
int	st_write_filemarks(struct st_softc *, int, int);
d309 1
a309 1
int	st_erase(struct st_softc *, int full, int flags);
d1123 1
a1123 1
	int number, nmarks, dsty;
d1129 1
a1183 1
		/* compat: in U*x it is a short */
d1185 1
a1185 1
		switch ((short) (mt->mt_op)) {
d1255 1
a1255 1
			if (number > SCSI_2_MAX_DENSITY_CODE) {
d1544 2
a1545 1
	int full, flags;
d1581 1
a1581 1
	int number;
d1662 1
a1662 1
	int number;
@


1.32
log
@More (the last round?) of splasserts and splbio around biodone.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.31 2002/06/04 00:09:08 deraadt Exp $	*/
d404 1
a404 1
	if (scsi_test_unit_ready(sc_link,
d533 2
a534 1
	error = scsi_test_unit_ready(sc_link, SCSI_IGNORE_MEDIA_CHANGE |
d660 2
a661 1
	scsi_test_unit_ready(sc_link, SCSI_SILENT);	/* XXX */
@


1.31
log
@spelling; raj@@cerias.purdue.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.30 2002/03/14 01:27:13 millert Exp $	*/
d935 1
d937 1
a937 1
	return;
d965 3
@


1.30
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.29 2001/06/22 14:35:43 deraadt Exp $	*/
d428 1
a428 1
	 * aquired at boot time is not quite accurate.  This
@


1.29
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.28 2000/04/08 19:19:33 csapuntz Exp $	*/
d290 20
a309 20
int	stmatch __P((struct device *, void *, void *));
void	stattach __P((struct device *, struct device *, void *));
void	st_identify_drive __P((struct st_softc *, struct scsi_inquiry_data *));
void	st_loadquirks __P((struct st_softc *));
int	st_mount_tape __P((dev_t, int));
void	st_unmount __P((struct st_softc *, boolean, boolean));
int	st_decide_mode __P((struct st_softc *, boolean));
void	ststart __P((void *));
int	st_read __P((struct st_softc *, char *, int, int));
int	st_read_block_limits __P((struct st_softc *, int));
int	st_mode_sense __P((struct st_softc *, int));
int	st_mode_select __P((struct st_softc *, int));
int	st_space __P((struct st_softc *, int, u_int, int));
int	st_write_filemarks __P((struct st_softc *, int, int));
int	st_check_eod __P((struct st_softc *, boolean, int *, int));
int	st_load __P((struct st_softc *, u_int, int));
int	st_rewind __P((struct st_softc *, u_int, int));
int	st_interpret_sense __P((struct scsi_xfer *));
int	st_touch_tape __P((struct st_softc *));
int	st_erase __P((struct st_softc *, int full, int flags));
@


1.29.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.29 2001/06/22 14:35:43 deraadt Exp $	*/
d290 20
a309 20
int	stmatch(struct device *, void *, void *);
void	stattach(struct device *, struct device *, void *);
void	st_identify_drive(struct st_softc *, struct scsi_inquiry_data *);
void	st_loadquirks(struct st_softc *);
int	st_mount_tape(dev_t, int);
void	st_unmount(struct st_softc *, boolean, boolean);
int	st_decide_mode(struct st_softc *, boolean);
void	ststart(void *);
int	st_read(struct st_softc *, char *, int, int);
int	st_read_block_limits(struct st_softc *, int);
int	st_mode_sense(struct st_softc *, int);
int	st_mode_select(struct st_softc *, int);
int	st_space(struct st_softc *, int, u_int, int);
int	st_write_filemarks(struct st_softc *, int, int);
int	st_check_eod(struct st_softc *, boolean, int *, int);
int	st_load(struct st_softc *, u_int, int);
int	st_rewind(struct st_softc *, u_int, int);
int	st_interpret_sense(struct scsi_xfer *);
int	st_touch_tape(struct st_softc *);
int	st_erase(struct st_softc *, int full, int flags);
d428 1
a428 1
	 * acquired at boot time is not quite accurate.  This
a934 1
	s = splbio();
d936 1
a936 1
	splx(s);
a963 3

	splassert(IPL_BIO);

@


1.29.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d89 1
a89 1
 * Maximum density code allowed in SCSI spec (SSC2R08f, Section 8.3).
d91 1
a91 1
#define SCSI_MAX_DENSITY_CODE		0xff
d302 2
a303 2
int	st_space(struct st_softc *, daddr_t, u_int, int);
int	st_write_filemarks(struct st_softc *, daddr_t, int);
d309 1
a309 1
int	st_erase(struct st_softc *, daddr_t, int);
d404 1
a404 1
	if (scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d533 1
a533 2
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
	    SCSI_IGNORE_MEDIA_CHANGE |
d659 1
a659 2
	/* XXX */
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT, SCSI_SILENT);
d1121 1
a1121 1
	int nmarks, dsty;
a1126 1
	daddr_t number;
d1181 1
d1183 1
a1183 1
		switch (mt->mt_op) {
d1253 1
a1253 1
			if (number < 0 || number > SCSI_MAX_DENSITY_CODE) {
d1542 1
a1542 2
	daddr_t full;
	int flags;
d1578 1
a1578 1
	daddr_t number;
d1659 1
a1659 1
	daddr_t number;
@


1.28
log
@

These days, attach can occur outside the tsleep-restricted world of
BSD autoconf.

Don't use POLL & NOSLEEP mode if attaching after autoconf
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.27 1999/09/05 20:58:03 niklas Exp $	*/
d79 1
a79 1
#define STMODE(z)	( minor(z)       & 0x03)
d533 2
a534 4
	error = scsi_test_unit_ready(sc_link,
				     SCSI_IGNORE_MEDIA_CHANGE |
				     (stmode == CTLMODE ?
					SCSI_IGNORE_NOT_READY : 0));
d1088 1
a1088 1
		       st->sc_link->adapter->scsi_minphys, uio));
d1100 1
a1100 1
		       st->sc_link->adapter->scsi_minphys, uio));
@


1.27
log
@ATAPI tapes are always fixed blocksize
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.26 1999/07/25 07:09:20 csapuntz Exp $	*/
d405 1
a405 1
	    SCSI_AUTOCONF | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE) ||
d407 1
a407 1
	    SCSI_AUTOCONF | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE))
@


1.27.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.28 2000/04/08 19:19:33 csapuntz Exp $	*/
d405 1
a405 1
	    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE) ||
d407 1
a407 1
	    scsi_autoconf | SCSI_SILENT | SCSI_IGNORE_MEDIA_CHANGE))
@


1.27.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.27.4.1 2001/05/14 22:45:00 niklas Exp $	*/
d79 1
a79 1
#define STMODE(z)	( minor(z)	 & 0x03)
d533 4
a536 2
	error = scsi_test_unit_ready(sc_link, SCSI_IGNORE_MEDIA_CHANGE |
	    (stmode == CTLMODE ? SCSI_IGNORE_NOT_READY : 0));
d1090 1
a1090 1
	    st->sc_link->adapter->scsi_minphys, uio));
d1102 1
a1102 1
	    st->sc_link->adapter->scsi_minphys, uio));
@


1.27.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d290 20
a309 20
int	stmatch(struct device *, void *, void *);
void	stattach(struct device *, struct device *, void *);
void	st_identify_drive(struct st_softc *, struct scsi_inquiry_data *);
void	st_loadquirks(struct st_softc *);
int	st_mount_tape(dev_t, int);
void	st_unmount(struct st_softc *, boolean, boolean);
int	st_decide_mode(struct st_softc *, boolean);
void	ststart(void *);
int	st_read(struct st_softc *, char *, int, int);
int	st_read_block_limits(struct st_softc *, int);
int	st_mode_sense(struct st_softc *, int);
int	st_mode_select(struct st_softc *, int);
int	st_space(struct st_softc *, int, u_int, int);
int	st_write_filemarks(struct st_softc *, int, int);
int	st_check_eod(struct st_softc *, boolean, int *, int);
int	st_load(struct st_softc *, u_int, int);
int	st_rewind(struct st_softc *, u_int, int);
int	st_interpret_sense(struct scsi_xfer *);
int	st_touch_tape(struct st_softc *);
int	st_erase(struct st_softc *, int full, int flags);
@


1.27.4.4
log
@Sync the SMP branch with 3.3
@
text
@d89 1
a89 1
 * Maximum density code allowed in SCSI spec (SSC2R08f, Section 8.3).
d91 1
a91 1
#define SCSI_MAX_DENSITY_CODE		0xff
d302 2
a303 2
int	st_space(struct st_softc *, daddr_t, u_int, int);
int	st_write_filemarks(struct st_softc *, daddr_t, int);
d309 1
a309 1
int	st_erase(struct st_softc *, daddr_t, int);
d404 1
a404 1
	if (scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
d428 1
a428 1
	 * acquired at boot time is not quite accurate.  This
d533 1
a533 2
	error = scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT,
	    SCSI_IGNORE_MEDIA_CHANGE |
d659 1
a659 2
	/* XXX */
	scsi_test_unit_ready(sc_link, TEST_READY_RETRIES_DEFAULT, SCSI_SILENT);
a934 1
	s = splbio();
d936 1
a936 1
	splx(s);
a963 3

	splassert(IPL_BIO);

d1117 1
a1117 1
	int nmarks, dsty;
a1122 1
	daddr_t number;
d1177 1
d1179 1
a1179 1
		switch (mt->mt_op) {
d1249 1
a1249 1
			if (number < 0 || number > SCSI_MAX_DENSITY_CODE) {
d1538 1
a1538 2
	daddr_t full;
	int flags;
d1574 1
a1574 1
	daddr_t number;
d1655 1
a1655 1
	daddr_t number;
@


1.27.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.27.4.4 2003/03/28 00:08:47 niklas Exp $	*/
d120 1
a120 1
const struct st_quirk_inquiry_pattern st_quirk_patterns[] = {
d267 1
a267 1
	const struct quirkdata *quirkdata;	/* if we have a rogue entry */
d349 1
a349 1
const struct scsi_inquiry_pattern st_patterns[] = {
d363 1
a363 1
	    st_patterns, sizeof(st_patterns)/sizeof(st_patterns[0]),
d443 1
a443 1
	const struct st_quirk_inquiry_pattern *finger;
d446 2
a447 2
	finger = (const struct st_quirk_inquiry_pattern *)scsi_inqmatch(inqbuf,
	    st_quirk_patterns,
d469 1
a469 1
	const struct	modes *mode;
@


1.27.4.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a242 8
	{{T_SEQUENTIAL, T_REMOV,
	 "TEAC    ", "MT-2ST/N50      ", ""},     {ST_Q_IGNORE_LOADS, 0, {
		{0, 0, 0},				/* minor 0-3 */
		{0, 0, 0},				/* minor 4-7 */
		{0, 0, 0},				/* minor 8-11 */
		{0, 0, 0}				/* minor 12-15 */
	}}},

d381 1
a381 1
	SC_DEBUG(sc_link, SDEV_DB2, ("stattach:\n"));
d645 1
a645 1
	SC_DEBUG(sc_link, SDEV_DB1, ("mounting\n"));
d880 2
a881 2
	SC_DEBUG(st->sc_link, SDEV_DB2, ("ststrategy: %ld bytes @@ blk %d\n",
	    bp->b_bcount, bp->b_blkno));
d883 1
a883 1
	 * If it's a null transfer, return immediately.
d966 1
a966 1
	SC_DEBUG(sc_link, SDEV_DB2, ("ststart\n"));
d1466 1
a1466 1
	SC_DEBUGN(sc_link, SDEV_DB3,
d1802 1
d1804 1
a1804 1
	struct scsi_link *sc_link = xs->sc_link;
d1806 1
a1806 3
	struct buf *bp = xs->bp;
	u_int8_t serr = sense->error_code & SSD_ERRCODE;
	u_int8_t skey = sense->flags & SSD_KEY;
a1808 15
	if (((sense->flags & SDEV_OPEN) == 0) ||
	    (serr != 0x70 && serr != 0x71))
		return (EJUSTRETURN); /* let the generic code handle it */

	switch (skey) {
	case SKEY_NO_SENSE:
	case SKEY_RECOVERED_ERROR:
	case SKEY_MEDIUM_ERROR:
	case SKEY_VOLUME_OVERFLOW:
	case SKEY_BLANK_CHECK:
		break;
	default:
		return (EJUSTRETURN);
	}

d1816 2
d1896 1
a1896 1
			return (0);
d1899 1
d1901 1
a1901 1
	if (skey == SKEY_BLANK_CHECK) {
d1903 4
a1906 3
		 * This quirk code helps the drive read the first tape block,
		 * regardless of format.  That is required for these drives to
		 * return proper MODE SENSE information.
d1919 1
a1919 1
			return (0);
d1922 1
a1922 2

	return (EJUSTRETURN);
@


1.26
log
@

Merge sd stuff from NetBSD-current. Helps with LS-120, ZIP

More SCSI logic from NetBSD-current

Some tape fixes. ATAPI tapes do not work yet for most operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.25 1998/07/23 09:11:09 deraadt Exp $	*/
d687 1
a761 1
#ifdef SCSIDEBUG
a762 1
#endif
d765 10
@


1.25
log
@do delays based on command type -- this works a lot better, make "mt status"
show much more information; ross
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.24 1998/02/22 00:51:46 niklas Exp $	*/
d674 2
a675 1
	if ((error = st_read_block_limits(st, 0)) != 0)
d677 2
d1494 3
d1803 1
a1803 1
		return -1;	/* let the generic code handle it */
d1908 1
a1908 1
	return -1;		/* let the default/generic handler handle it */
@


1.24
log
@Detect and report a weird error case (residual > request)
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.23 1998/02/16 06:06:38 deraadt Exp $	*/
d84 4
d256 1
a256 1
	int blksize;		/* blksize we are using                */
d259 3
a261 1
	u_int last_dsty;	/* last density opened               */
d1064 1
a1064 1
		    100000, bp, flags | SCSI_NOSLEEP))
d1129 7
d1149 11
d1254 19
d1347 1
a1347 1
	    sizeof(cmd), (u_char *) buf, size, 0, 100000, NULL,
d1380 2
a1381 3
			      sizeof(cmd), (u_char *) &block_limits,
			      sizeof(block_limits), ST_RETRIES, 5000,
			      NULL, flags | SCSI_DATA_IN);
d1434 2
a1435 3
			      sizeof(cmd), (u_char *) &scsi_sense,
			      scsi_sense_len, ST_RETRIES, 5000, NULL,
			      flags | SCSI_DATA_IN);
d1444 2
d1516 1
a1516 1
	    ST_RETRIES, 5000, NULL, flags | SCSI_DATA_OUT);
d1528 1
d1537 1
a1537 1
	if (full)
d1539 2
a1540 1
	else
d1542 2
d1550 1
a1550 1
	    sizeof(cmd), 0, 0, ST_RETRIES, 5000, NULL, flags));
d1632 1
a1632 1
	    sizeof(cmd), 0, 0, 0, 2000000, NULL, flags);
d1671 1
a1671 1
	    sizeof(cmd), 0, 0, 0, 100000, NULL, flags);
d1727 10
a1736 2
	if (st->quirks & ST_Q_IGNORE_LOADS)
		return 0;
d1743 1
a1743 1
	    sizeof(cmd), 0, 0, ST_RETRIES, 300000, NULL, flags);
d1769 2
a1770 2
	    sizeof(cmd), 0, 0, ST_RETRIES, immediate ? 5000 : 300000, NULL,
	    flags);
@


1.23
log
@Add the "VIPER 150/21531" to quirk list (ST_Q_SENSE_HELP; pk
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.22 1998/01/10 01:37:52 deraadt Exp $	*/
d1805 12
a1816 1
				return EIO;
@


1.22
log
@be silent for ILI errors ; giannici@@neomedia.it
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.21 1997/09/05 05:56:51 millert Exp $	*/
d170 7
@


1.21
log
@Add SCSITERSE option which omits the (large) ASC/ASCQ table.
Old scsi error printing code is now gone.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.20 1997/09/03 17:21:49 deraadt Exp $	*/
a1735 2
	else if ((xs->flags & SCSI_SILENT) == 0)
		scsi_print_sense(xs, 0);	/* tell folks what happened */
d1803 1
@


1.20
log
@be silent for SCSI_SILENT transactions
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.19 1997/08/22 04:43:27 millert Exp $	*/
a1735 1
#if	SCSIVERBOSE
a1737 1
#endif
@


1.19
log
@Add more detailed SCSI error printing by Matthew Jacob.  Enabled by
default.  Use "option SCSIVERBOSE=0" to turn off (only added 8Kb to my kernel).
From the NetBSD commit message:
    Add in more detailed SCSI error printing, based off of final SCSI-2 spec.
    This will also print out things like progress indicator errors, and will
    also dump out additional sense bytes that haven't been decoded.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.18 1997/08/19 03:50:59 dgregor Exp $	*/
d1737 1
a1737 1
	else
@


1.18
log
@Back out part of revision 1.16 where the tape was unmounted in stclose on
a non-rewinding device.  When the tape was re-opened again, st_mount_tape
called st_load, which causes the tape to be rewound.

The best way to fix this problem would be to not call st_load in
st_mount_tape if the tape is already in the drive and has already been
loaded.  But, I haven't figured out a good, safe way to do that yet....
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.17 1997/07/11 19:26:00 tholo Exp $	*/
d1736 4
@


1.17
log
@Rename REWIND to DOREWIND to avoid colliding with the SCSI opcode of the
same name
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.16 1997/07/11 02:18:40 tholo Exp $	*/
d595 3
a597 1
		st_unmount(st, NOEJECT, NOREWIND);
@


1.16
log
@Allow media to be removed on last close even if the device used was the
no-rewind device.  Ensure we re-detect media on first open even if media
was present at boot.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.15 1997/04/14 04:09:17 downsj Exp $	*/
d238 1
a238 1
#define REWIND 1
d543 1
a543 1
		st_unmount(st, NOEJECT, REWIND);
d566 1
a566 1
	st_unmount(st, NOEJECT, REWIND);
d589 1
a589 1
		st_unmount(st, NOEJECT, REWIND);
d598 1
a598 1
		st_unmount(st, EJECT, REWIND);
d1159 1
a1159 1
			st_unmount(st, EJECT, REWIND);
@


1.15
log
@Merge in various pieces of current NetBSD scsi code, including but not limited
to:

* New changer driver.
* Better optical support.
* Different `done' semantics.
* New quirks for SCSI QIC tape driver, SCSI floppy drives.
* Better support for SCSI-I devices.

Everybody needs to test this.
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.14 1997/02/24 20:17:35 jkatz Exp $	*/
d237 3
d282 1
a282 1
void	st_unmount __P((struct st_softc *, boolean));
d412 7
d543 1
a543 1
		st_unmount(st, NOEJECT);
d566 1
a566 1
	st_unmount(st, NOEJECT);
d588 5
a592 3
	case 0:
	case 3:		/* for now */
		st_unmount(st, NOEJECT);
d594 2
a595 4
	case 1:
		/* leave mounted unless media seems to have been removed */
		if (!(st->sc_link->flags & SDEV_MEDIA_LOADED))
			st_unmount(st, NOEJECT);
d597 2
a598 2
	case 2:
		st_unmount(st, EJECT);
d712 1
a712 1
st_unmount(st, eject)
d714 1
a714 1
	boolean eject;
d723 2
a724 1
	st_rewind(st, 0, SCSI_IGNORE_NOT_READY);
d1159 1
a1159 1
			st_unmount(st, EJECT);
@


1.14
log
@This changes the timeout on the st device so that the new tape drives that
are recognized are usable :-) If this break things for other people,
please feel free to change it back. from port-vax@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: st.c,v 1.13 1996/12/11 19:08:20 deraadt Exp $	*/
/*	$NetBSD: st.c,v 1.66 1996/05/05 19:53:01 christos Exp $	*/
d84 5
a88 2
#define SCSI_2_MAX_DENSITY_CODE	0x17	/* maximum density code specified
					 * in SCSI II spec. */
d105 1
d209 7
d1415 12
@


1.13
log
@b_resid cleanups, pointed out by minoura@@kw.netlaputa.or.jp in netbsd pr#3007
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.12 1996/08/11 23:26:07 deraadt Exp $	*/
d1542 1
a1542 1
	    sizeof(cmd), 0, 0, 0, 900000, NULL, flags);
@


1.12
log
@limit ioctl priviledges
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.11 1996/05/10 12:31:41 deraadt Exp $	*/
d939 1
a939 1
		 * if the device has been unmounted byt the user
d947 1
d970 1
@


1.11
log
@SC_DEBUG cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: st.c,v 1.9 1996/04/19 16:10:28 niklas Exp $	*/
d1199 2
a1200 1
			error = scsi_do_ioctl(st->sc_link, dev, cmd, arg, flag, p);
@


1.10
log
@partial sync with netbsd 960418, more to come
@
text
@d2 1
a2 1
/*	$NetBSD: st.c,v 1.65 1996/03/30 21:45:04 christos Exp $	*/
d832 1
a832 1
	    ("ststrategy %d bytes @@ blk %d\n", bp->b_bcount, bp->b_blkno));
@


1.9
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: st.c,v 1.62 1996/03/05 00:15:23 thorpej Exp $	*/
d69 1
a73 1
#include <scsi/scsi_conf.h>
d284 6
a289 2
struct cfdriver stcd = {
	NULL, "st", stmatch, stattach, DV_TAPE, sizeof(struct st_softc)
d475 1
a475 1
	if (unit >= stcd.cd_ndevs)
d477 1
a477 1
	st = stcd.cd_devs[unit];
d486 1
a486 1
	    unit, stcd.cd_ndevs));
d561 1
a561 1
	struct st_softc *st = stcd.cd_devs[STUNIT(dev)];
d604 1
a604 1
	st = stcd.cd_devs[unit];
d827 1
a827 1
	struct st_softc *st = stcd.cd_devs[STUNIT(bp->b_dev)];
d1016 1
a1016 1
			lto3b(bp->b_bcount / st->blksize, cmd.len);
d1018 1
a1018 1
			lto3b(bp->b_bcount, cmd.len);
d1036 1
a1036 1
	struct st_softc *st = stcd.cd_devs[STUNIT(dev)];
d1048 1
a1048 1
	struct st_softc *st = stcd.cd_devs[STUNIT(dev)];
d1081 1
a1081 1
	st = stcd.cd_devs[unit];
d1265 1
a1265 1
		lto3b(size / (st->blksize ? st->blksize : DEF_FIXED_BSIZE),
d1268 1
a1268 1
		lto3b(size, cmd.len);
a1273 6
#ifdef	__STDC__
#define b2tol(a)	(((unsigned)(a##_1) << 8) + (unsigned)a##_0)
#else
#define b2tol(a)	(((unsigned)(a/**/_1) << 8) + (unsigned)a/**/_0)
#endif

d1309 2
a1310 2
	st->blkmin = b2tol(block_limits.min_length);
	st->blkmax = _3btol(&block_limits.max_length_2);
d1418 1
a1418 1
		lto3b(st->blksize, scsi_select.blk_desc.blklen);
d1536 1
a1536 1
	lto3b(number, cmd.number);
d1575 1
a1575 1
	lto3b(number, cmd.number);
d1691 3
a1693 4
	if (sense->error_code & SSD_ERRCODE_VALID) {
		bcopy(sense->extended_info, &info, sizeof info);
		info = ntohl(info);
	} else
d1699 1
a1699 1
		if (sense->extended_flags & SSD_EOM) {
d1704 1
a1704 1
		if (sense->extended_flags & SSD_FILEMARK) {
d1709 1
a1709 1
		if (sense->extended_flags & SSD_ILI) {
d1743 1
a1743 1
		if (sense->extended_flags & SSD_EOM)
d1745 1
a1745 1
		if (sense->extended_flags & SSD_FILEMARK) {
d1750 1
a1750 1
		if (sense->extended_flags & SSD_ILI) {
d1766 1
a1766 1
	key = sense->extended_flags & SSD_KEY;
@


1.8
log
@Several changes from NetBSD:
- scsi prototypes
- remove #ifdef notdef made unnecessary by previous changes (PR#1597)
  put in missing "if (error)" that caused tape IO to always fail.
  (closes PR#2086)
- Minor change.
@
text
@d1 2
a2 1
/*	$NetBSD: st.c,v 1.54 1995/10/13 20:01:08 gwr Exp $	*/
d205 1
d207 2
a208 2
	 "WANGTEK ", "5150ES SCSI FA15\0""01 A", "????"}, {0, 0, {
		{0, ST_Q_IGNORE_LOADS, 0},		/* minor 0-3 */
d213 1
a213 1
#if 0
d215 2
a216 2
	 "EXABYTE ", "EXB-8200        ", ""},     {0, 12, {
		{0, 0, 0},				/* minor 0-3 */
a220 1
#endif
d371 2
a372 1
	printf(": %s", st->quirkdata ? "rogue, " : "");
@


1.7
log
@NetBSD PR 2048.  Prototype st_erase.
@
text
@d72 1
d112 21
a132 21
	{T_SEQUENTIAL, T_REMOV,
	 "        ", "                ", "    ", 0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		ST_Q_FORCE_BLKSIZE, 512, QIC_24,	/* minor 4-7 */
		ST_Q_FORCE_BLKSIZE, 0, HALFINCH_1600,	/* minor 8-11 */
		ST_Q_FORCE_BLKSIZE, 0, HALFINCH_6250	/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "TANDBERG", " TDC 3600       ", "",     0, 12, {
		0, 0, 0,				/* minor 0-3 */
		ST_Q_FORCE_BLKSIZE, 0, QIC_525,		/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "TANDBERG", " TDC 3800       ", "",     0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		0, 0, QIC_525,				/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
d137 7
a143 7
	{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 2525 25462", "",     0, 0, {
		ST_Q_SENSE_HELP, 0, 0,			/* minor 0-3 */
		ST_Q_SENSE_HELP, 0, QIC_525,		/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
d148 63
a210 63
	{T_SEQUENTIAL, T_REMOV,
	 "SANKYO  ", "CP525           ", "",     0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		ST_Q_FORCE_BLKSIZE, 512, QIC_525,	/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "ANRITSU ", "DMT780          ", "",     0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		ST_Q_FORCE_BLKSIZE, 512, QIC_525,	/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "ARCHIVE ", "VIPER 150  21247", "",     0, 12, {
		0, 0, 0,				/* minor 0-3 */
		0, 0, QIC_150,				/* minor 4-7 */
		0, 0, QIC_120,				/* minor 8-11 */
		0, 0, QIC_24				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5099ES SCSI", "",          0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		0, 0, QIC_11,				/* minor 4-7 */
		0, 0, QIC_24,				/* minor 8-11 */
		0, 0, QIC_24,				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI", "",          0, 0, {
		ST_Q_FORCE_BLKSIZE, 512, 0,		/* minor 0-3 */
		0, 0, QIC_24,				/* minor 4-7 */
		0, 0, QIC_120,				/* minor 8-11 */
		0, 0, QIC_150				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5525ES SCSI REV7", "",     0, 0, {
		0, 0, 0,				/* minor 0-3 */
		ST_Q_BLKSIZE, 0, QIC_525,		/* minor 4-7 */
		0, 0, QIC_150,				/* minor 8-11 */
		0, 0, QIC_120				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "WangDAT ", "Model 1300      ", "",     0, 0, {
		0, 0, 0,				/* minor 0-3 */
		ST_Q_FORCE_BLKSIZE, 512, DDS,		/* minor 4-7 */
		ST_Q_FORCE_BLKSIZE, 1024, DDS,		/* minor 8-11 */
		ST_Q_FORCE_BLKSIZE, 0, DDS		/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "WANGTEK ", "5150ES SCSI FA15\0""01 A", "????", 0, 0, {
		0, ST_Q_IGNORE_LOADS, 0,		/* minor 0-3 */
		0, 0, 0,				/* minor 4-7 */
		0, 0, 0,				/* minor 8-11 */
		0, 0, 0,				/* minor 12-15 */
	}},
	{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", "263H", 0, 5, {
		0, 0, 0,				/* minor 0-3 */
		0, 0, 0,				/* minor 4-7 */
		0, 0, 0,				/* minor 8-11 */
		0, 0, 0					/* minor 12-15 */
	}},
d212 7
a218 7
	{T_SEQUENTIAL, T_REMOV,
	 "EXABYTE ", "EXB-8200        ", "",     0, 12, {
		0, 0, 0,				/* minor 0-3 */
		0, 0, 0,				/* minor 4-7 */
		0, 0, 0,				/* minor 8-11 */
		0, 0, 0					/* minor 12-15 */
	}},
d261 21
a281 2
int stmatch __P((struct device *, void *, void *));
void stattach __P((struct device *, struct device *, void *));
a286 19
int	st_space __P((struct st_softc *, int number, u_int what, int flags));
int	st_rewind __P((struct st_softc *, u_int immediate, int flags));
int	st_mode_sense __P((struct st_softc *, int flags));
int	st_decide_mode __P((struct st_softc *, boolean first_read));
int	st_read_block_limits __P((struct st_softc *, int flags));
int	st_touch_tape __P((struct st_softc *));
int	st_write_filemarks __P((struct st_softc *, int number, int flags));
int	st_load __P((struct st_softc *, u_int type, int flags));
int	st_erase __P((struct st_softc *, int full, int flags));
int	st_mode_select __P((struct st_softc *, int flags));
void    ststrategy __P((struct buf *));
int	st_check_eod __P((struct st_softc *, boolean, int *, int));
void    ststart __P((struct st_softc *));
void	st_unmount __P((struct st_softc *, boolean));
int	st_mount_tape __P((dev_t, int));
void	st_loadquirks __P((struct st_softc *));
void	st_identify_drive __P((struct st_softc *, struct scsi_inquiry_data *));
int	st_interpret_sense __P((struct scsi_xfer *));

a326 1
	struct cfdata *cf = match;
d455 2
a456 2
int
stopen(dev, flags)
d459 2
d463 1
a463 1
	u_int mode, dsty;
d475 1
a475 1
	mode = STMODE(dev);
d493 5
a497 2
	if (error = scsi_test_unit_ready(sc_link,
	    SCSI_IGNORE_MEDIA_CHANGE | (mode == CTLMODE ? SCSI_IGNORE_NOT_READY : 0)))
d507 1
a507 1
	if (mode == CTLMODE)
d548 2
a549 2
int
stclose(dev)
d551 3
d611 1
a611 1
	if (error = st_load(st, LD_LOAD, 0))
d626 1
a626 1
		if (error = st_touch_tape(st))
d632 1
a632 1
	if (error = st_read_block_limits(st, 0))
d640 1
a640 1
	if (error = st_mode_sense(st, 0))
d662 1
a662 1
		if (error = st_decide_mode(st, FALSE))
d665 1
a665 1
	if (error = st_mode_select(st, 0)) {
d900 3
a902 3
void
ststart(st)
	struct st_softc *st;
d904 1
d923 4
a926 4
		bp = st->buf_queue.b_actf;
		if (!bp)
			return;	/* no work to bother with */
		if (dp = bp->b_actf)
d1025 1
a1025 1
stread(dev, uio)
d1028 1
d1037 1
a1037 1
stwrite(dev, uio)
d1040 1
d1205 1
a1205 1
	if (error = st_mode_select(st, 0)) {	/* put it back as it was */
d1302 5
a1306 3
	if (error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) &block_limits, sizeof(block_limits),
	    ST_RETRIES, 5000, NULL, flags | SCSI_DATA_IN))
d1357 5
a1361 3
	if (error = scsi_scsi_cmd(sc_link, (struct scsi_generic *) &cmd,
	    sizeof(cmd), (u_char *) &scsi_sense, scsi_sense_len,
	    ST_RETRIES, 5000, NULL, flags | SCSI_DATA_IN))
a1391 1
	int error;
d1821 1
a1821 1
	if (error = st_mode_sense(st, 0))
d1835 1
a1835 1
		if (error = st_mode_select(st, 0))
d1838 1
a1838 1
		if (error = st_rewind(st, 0, 0)) {
@


1.6
log
@from netbsd:
Honor cache request and add the SCSI tape device configuration page.
Fixes PRs 807, 1201, and 1705. From John Kohl <jtk@@kolvir.blrc.ma.us>.
@
text
@d275 1
@


1.5
log
@from netbsd; Add quirk for Exabyte 8200/rev. 263H (from Paul Goyette; PR#1797)
@
text
@d276 8
a283 8
void    ststrategy();
int	st_check_eod();
void    ststart();
void	st_unmount();
int	st_mount_tape();
void	st_loadquirks();
void	st_identify_drive();
int	st_interpret_sense();
d308 1
a1112 3
		case MTERASE:	/* erase */
			error = st_erase(st, FALSE, flags);
			break;
d1132 2
d1135 4
d1164 1
a1164 1
			if (number > SCSI_2_MAX_DENSITY_CODE)
d1166 2
a1167 1
			else
d1396 1
a1396 1
	scsi_select.header.dev_spec |= SMH_DSP_BUFF_MODE_ON;
d1398 4
d1416 30
a1654 35
}

/*
 * Erase the tape
 */ 
int 
st_erase(st, immediate, flags)
	struct st_softc *st;
	u_int immediate;
	int flags;
{
	struct scsi_erase scsi_cmd;
	int error;
	int nmarks;

	error = st_check_eod(st, FALSE, &nmarks, flags);
	if (error)
		return (error);
	/*
	 * Archive Viper 2525 technical manual 5.7 (ERASE 19h):
	 * tape has to be positioned to BOT first before erase command
	 * is issued or command is rejected. So we rewind the tape first
	 * and exit with an error, if the tape can't be rewinded.
	 */
	error = st_rewind(st, FALSE, SCSI_SILENT);
	if (error)
		return (error);
	st->flags &= ~ST_PER_ACTION;
	bzero(&scsi_cmd, sizeof(scsi_cmd));
	scsi_cmd.opcode = ERASE;
	scsi_cmd.byte2 = SE_LONG | (immediate ? SE_IMMED : 0);
	return (scsi_scsi_cmd(st->sc_link, (struct scsi_generic *) &scsi_cmd,
	    sizeof(scsi_cmd), 0, 0, ST_RETRIES,
	    immediate ? 5000 : 300000,		/* 5 sec or 5 min */
	    NULL, flags));
@


1.4
log
@make this work
@
text
@d203 7
@


1.3
log
@add erase support and another wangtek tape drive; from rhialto@@polder.ubc.kun.nl; netbsd pr#1705
@
text
@d1616 1
a1616 1
	struct st_data *st;
d1638 1
a1638 1
	scsi_cmd.op_code = ERASE;
@


1.2
log
@if you read with a smaller buffer than the block on the tape, b_resid and b_count would be incorrect; from jtk@@kolvir.arlington.ma.us; netbsd pr#1597
@
text
@d196 7
d1105 3
d1609 35
@


1.1
log
@Initial revision
@
text
@d857 2
a858 1
	iodone(bp);
d1615 1
a1615 1
	u_int32_t info;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
