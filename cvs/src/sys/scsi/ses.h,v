head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.48
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.46
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.42
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.38
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.40
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.32
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.36
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.34
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.30
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.28
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.26
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.24
	OPENBSD_5_0:1.10.0.22
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.20
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.10.0.18
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.14
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.9.0.4
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.2
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.1.0.26
	OPENBSD_3_7_BASE:1.1
	OPENBSD_3_6:1.1.0.24
	OPENBSD_3_6_BASE:1.1
	SMP_SYNC_A:1.1
	SMP_SYNC_B:1.1
	OPENBSD_3_5:1.1.0.22
	OPENBSD_3_5_BASE:1.1
	OPENBSD_3_4:1.1.0.20
	OPENBSD_3_4_BASE:1.1
	UBC_SYNC_A:1.1
	OPENBSD_3_3:1.1.0.18
	OPENBSD_3_3_BASE:1.1
	OPENBSD_3_2:1.1.0.16
	OPENBSD_3_2_BASE:1.1
	OPENBSD_3_1:1.1.0.14
	OPENBSD_3_1_BASE:1.1
	UBC_SYNC_B:1.1
	UBC:1.1.0.12
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.10
	OPENBSD_3_0_BASE:1.1
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.8
	OPENBSD_2_8:1.1.0.6
	OPENBSD_2_8_BASE:1.1
	OPENBSD_2_7:1.1.0.4
	OPENBSD_2_7_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.10
date	2006.05.11.00.45.59;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.23.23.44.28;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.22.04.23.58;	author david;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.18.21.04.47;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.18.12.26.40;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2005.08.03.15.34.13;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2005.08.02.03.35.14;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.08.01.23.14.31;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.31.06.22.56;	author dlg;	state dead;
branches;
next	1.1;

1.1
date	2000.02.21.08.23.30;	author mjacob;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2000.02.21.22.29.15;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Zap trailing whitespace.
@
text
@/* $OpenBSD: ses.h,v 1.9 2005/08/23 23:44:28 dlg Exp $ */
/*
 * Copyright (c) 2005 Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#ifndef _SCSI_SES_H_
#define _SCSI_SES_H_

/* the scsi command */
struct ses_scsi_diag {
	u_int8_t	opcode; /* SEND_DIAGNOSTIC or RECEIVE_DIAGNOSTIC */
	u_int8_t	flags;
#define SES_DIAG_PCV		(1<<0)	/* page code valid */
#define SES_DIAG_PF		(1<<4)	/* set this bit if page code is valid */
	u_int8_t	pgcode;
#define SES_PAGE_CONFIG		0x01	/* Configuration */
#define SES_PAGE_STATUS		0x02	/* Enclosure Status */
#define SES_PAGE_EDESC		0x07	/* Element Descriptor */
	u_int16_t	length;
	u_int8_t	control;
} __packed;


/* all the different sensor types */
#define SES_T_UNSPEC		0x00
#define SES_T_DEVICE		0x01
#define SES_T_POWERSUPPLY	0x02
#define SES_T_COOLING		0x03
#define SES_T_TEMP		0x04
#define SES_T_DOORLOCK		0x05
#define SES_T_ALARM		0x06
#define SES_T_ENC_SRV_CTRL	0x07
#define SES_T_SCC_CTRL		0x08
#define SES_T_NONVOL_CACHE	0x09
#define SES_T_INV_OP_REASON	0x0a
#define SES_T_UPS		0x0b
#define SES_T_DISPLAY		0x0c
#define SES_T_KEYPAD		0x0d
#define SES_T_ENCLOSURE		0x0e
#define SES_T_SCSI_PORT_TRANS	0x0f
#define SES_T_LANGUAGE		0x10
#define SES_T_COMM_PORT		0x11
#define SES_T_VOLTAGE		0x12
#define SES_T_CURRENT		0x13
#define SES_T_SCSI_TARGET_PORT	0x14
#define SES_T_SCSI_INIT_PORT	0x15
#define SES_T_SIMP_SUBENC	0x16
#define SES_T_ARRAY_DEVICE	0x17

#define SES_NUM_TYPES		256

/* diagnostic page header */
struct ses_config_hdr {
	u_int8_t	pgcode; /* SES_PAGE_CONFIG */
	u_int8_t	n_subenc;
	u_int16_t	length;
	u_int32_t	gencode;
} __packed;
#define SES_CFG_HDRLEN		sizeof(struct ses_config_hdr)

/* enclosure descriptor header */
struct ses_enc_hdr {
	u_int8_t	enc_id;
	u_int8_t	subenc_id;
	u_int8_t	n_types;
	u_int8_t	vendor_len;
} __packed;
#define SES_ENC_HDRLEN		sizeof(struct ses_enc_hdr)

/* enclosure descriptor strings */
struct ses_enc_desc {
	u_int8_t	logical_id[8]; /* this isnt a string */
	u_int8_t	vendor_id[8];
	u_int8_t	prod_id[16];
	u_int8_t	prod_rev[4];
	u_int8_t	vendor[0];
} __packed;

/* type descriptor header */
struct ses_type_desc {
	u_int8_t	type;
	u_int8_t	n_elem;
	u_int8_t	subenc_id;
	u_int8_t	desc_len;
} __packed;
#define SES_TYPE_DESCLEN	sizeof(struct ses_type_desc)

/* status page header */
struct ses_status_hdr {
	u_int8_t	pgcode;		/* SES_PAGE_STATUS */
	u_int8_t	flags;
#define SES_STAT_UNRECOV	(1<<0)	/* unrecoverable error */
#define SES_STAT_CRIT		(1<<1)	/* critical error */
#define SES_STAT_NONCRIT	(1<<2)	/* noncritical error */
#define SES_STAT_INFO		(1<<3)	/* info available */
#define SES_STAT_INVOP		(1<<4)	/* invalid operation */
	u_int16_t	length;
	u_int32_t	gencode;
} __packed;
#define SES_STAT_HDRLEN		sizeof(struct ses_status_hdr)

struct ses_status {
	u_int8_t	com;
#define SES_STAT_CODE_MASK	0x0f
#define SES_STAT_CODE(x)	((x) & SES_STAT_CODE_MASK)
#define SES_STAT_CODE_UNSUP	0x00 /* unsupported */
#define SES_STAT_CODE_OK	0x01 /* installed and ok */
#define SES_STAT_CODE_CRIT	0x02 /* critical */
#define SES_STAT_CODE_NONCRIT	0x03 /* warning */
#define SES_STAT_CODE_UNREC	0x04 /* unrecoverable */
#define SES_STAT_CODE_NOTINST	0x05 /* not installed */
#define SES_STAT_CODE_UNKNOWN	0x06 /* unknown */
#define SES_STAT_CODE_NOTAVAIL	0x07 /* not available */
#define SES_STAT_SWAP		(1<<4)	/* element has been swapped */
#define SES_STAT_DISABLED	(1<<5)	/* disabled */
#define SES_STAT_PRDFAIL	(1<<6)	/* predicted failure */
#define SES_STAT_SELECT		(1<<7)	/* set to modify element */

	u_int8_t	f1;	/* use of these flags depends on the SES_T */
	u_int8_t	f2;
	u_int8_t	f3;
} __packed;
#define SES_STAT_ELEMLEN	sizeof(struct ses_status)

/* device status */
/* f1 is the device address */
/* f2 */
#define SES_S_DEV_REPORT	(1<<0)	/* enc report in progress */
#define SES_S_DEV_IDENT		(1<<1)	/* currently identifying */
#define SES_S_DEV_REMOVE	(1<<2)	/* ready to remove */
#define SES_S_DEV_INSERT	(1<<3)	/* ready to insert */
#define SES_S_DEV_ENCBYPB	(1<<4)	/* port B bypassed by enc */
#define SES_S_DEV_ENCBYPA	(1<<5)	/* port A bypassed by enc */
#define SES_S_DEV_DONOTREM	(1<<6)	/* do not remove */
#define SES_S_DEV_APPCLBYPA	(1<<7)	/* port A bypassed by app */
/* f3 */
#define SES_S_DEV_DEVBYPB	(1<<0)	/* port B bypassed by dev */
#define SES_S_DEV_DEVBYPA	(1<<1)	/* port A bypassed by dev */
#define SES_S_DEV_BYPB		(1<<2)
#define SES_S_DEV_BYPA		(1<<3)
#define SES_S_DEV_OFF		(1<<4)	/* device is off */
#define SES_S_DEV_FAULTRQST	(1<<5)	/* fault indicator rqsted */
#define SES_S_DEV_FAULTSENSE	(1<<6)	/* fault sensed */
#define SES_S_DEV_APPCLBYPB	(1<<7)	/* port B bypassed by app */

/* device configuration */
/* f1 is reserved */
/* f2 */
#define SES_C_DEV_IDENT		(1<<1)	/* ident */
#define SES_C_DEV_REMOVE	(1<<2)	/* remove */
#define SES_C_DEV_INSERT	(1<<3)	/* insert */
#define SES_C_DEV_DONOTREM	(1<<6)	/* do not remove */
#define SES_C_DEV_ACTIVE	(1<<7)	/* active indicator */
#define SES_C_DEV_F2MASK	(SES_C_DEV_IDENT | SES_C_DEV_REMOVE | \
    SES_C_DEV_INSERT | SES_C_DEV_DONOTREM | SES_C_DEV_ACTIVE )
/* f3 */
#define SES_C_DEV_BYPB		(1<<2)	/* port B bypass */
#define SES_C_DEV_BYPA		(1<<3)	/* port A bypass */
#define SES_C_DEV_OFF		(1<<4)	/* off */
#define SES_C_DEV_FAULT		(1<<5)	/* fault indicator */
#define SES_C_DEV_F3MASK	(SES_C_DEV_BYPB | SES_C_DEV_BYPA | \
    SES_C_DEV_OFF | SES_C_DEV_FAULT)

/* power supply element */
#define SES_S_PSU_IDENT(d)	((d)->f1 & (1<<6)) /* identify */
#define SES_S_PSU_DCOC(d)	((d)->f2 & (1<<1)) /* DC over current */
#define SES_S_PSU_DCUV(d)	((d)->f2 & (1<<2)) /* DC under voltage */
#define SES_S_PSU_DCOV(d)	((d)->f2 & (1<<3)) /* DC over voltage */
#define SES_S_PSU_DCFAIL(d)	((d)->f3 & (1<<0)) /* DC fail */
#define SES_S_PSU_ACFAIL(d)	((d)->f3 & (1<<1)) /* AC fail */
#define SES_S_PSU_TEMPWARN(d)	((d)->f3 & (1<<2)) /* Temp warn */
#define SES_S_PSU_OVERTEMP(d)	((d)->f3 & (1<<3)) /* over temp fail */
#define SES_S_PSU_OFF(d)	((d)->f3 & (1<<4)) /* is the unit off */
#define SES_S_PSU_RQSTON(d)	((d)->f3 & (1<<5)) /* manually on */
#define SES_S_PSU_FAIL(d)	((d)->f3 & (1<<6)) /* fail is set on */

/* cooling element */
#define SES_S_COOL_IDENT(d)	((d)->f1 & (1<<6)) /* identify */
#define SES_S_COOL_SPEED_MASK	0x03
#define SES_S_COOL_SPEED(d)	((d)->f2 + \
    ((u_int16_t)((d)->f2 & SES_S_COOL_SPEED_MASK) << 8))
#define SES_S_COOL_FACTOR	10
#define SES_S_COOL_CODE(d)	((d)->f3 & 0x7) /* actual speed code */
#define SES_S_COOL_C_STOPPED	0x0 /* stopped */
#define SES_S_COOL_C_LOW1	0x1 /* lowest speed */
#define SES_S_COOL_C_LOW2	0x2 /* second lowest speed */
#define SES_S_COOL_C_LOW3	0x3 /* third lowest speed */
#define SES_S_COOL_C_INTER	0x4 /* intermediate speed */
#define SES_S_COOL_C_HI3	0x5 /* third highest speed */
#define SES_S_COOL_C_HI2	0x6 /* second highest speed */
#define SES_S_COOL_C_HI1	0x7 /* highest speed */
#define SES_S_COOL_OFF		((d)->f3 & (1<<4)) /* not cooling */
#define SES_S_COOL_RQSTON	((d)->f3 & (1<<5)) /* manually on */
#define SES_S_COOL_FAIL		((d)->f3 & (1<<6)) /* fail indic is on */

/* temperature sensor */
#define SES_S_TEMP_IDENT(d)	((d)->f1 & (1<<7)) /* identify */
#define SES_S_TEMP(d)		((d)->f2)
#define SES_S_TEMP_OFFSET	(-20)
#define SES_S_TEMP_UTWARN	((d)->f3 & (1<<0)) /* under temp warning */
#define SES_S_TEMP_UTFAIL	((d)->f3 & (1<<1)) /* under temp failure */
#define SES_S_TEMP_OTWARN	((d)->f3 & (1<<2)) /* over temp warning */
#define SES_S_TEMP_OTFAIL	((d)->f3 & (1<<3)) /* over temp failure */

/*
 * the length of the status page is the header and a status element for
 * each type plus the number of elements for each type
 */
#define SES_STAT_LEN(t, e)	\
    (SES_STAT_HDRLEN + SES_STAT_ELEMLEN * ((t)+(e)))

#endif /* _SCSI_SES_H_ */
@


1.9
log
@setting the FAULT flag on a device so the alarm led blinks may have
unwanted side effects, eg, disabling both fc ports and powering the disk
down. so remove this knob for now.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.8 2005/08/22 04:23:58 david Exp $ */
d99 1
a99 1
 	u_int8_t	vendor[0];
d204 1
a204 1
    ((u_int16_t)((d)->f2 & SES_S_COOL_SPEED_MASK) << 8)) 
@


1.8
log
@spell: failture->failure
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.7 2005/08/18 21:04:47 marco Exp $ */
d149 19
a167 17
#define SES_S_DEV_ADDR(d)	((d)->f1)
#define SES_S_DEV_REPORT(d)	((d)->f2 & (1<<0)) /* enc report in progress */
#define SES_S_DEV_IDENT(d)	((d)->f2 & (1<<1)) /* currently identifying */
#define SES_S_DEV_REMOVE(d)	((d)->f2 & (1<<2)) /* ready to remove */
#define SES_S_DEV_INSERT(d)	((d)->f2 & (1<<3)) /* ready to insert */
#define SES_S_DEV_ENCBYPB(d)	((d)->f2 & (1<<4)) /* port B bypassed by enc */
#define SES_S_DEV_ENCBYPA(d)	((d)->f2 & (1<<5)) /* port A bypassed by enc */
#define SES_S_DEV_DONOTREM(d)	((d)->f2 & (1<<6)) /* do not remove */
#define SES_S_DEV_APPCLBYPA(d)	((d)->f2 & (1<<7)) /* port A bypassed by app */
#define SES_S_DEV_DEVBYPB(d)	((d)->f3 & (1<<0)) /* port B bypassed by dev */
#define SES_S_DEV_DEVBYPA(d)	((d)->f3 & (1<<1)) /* port A bypassed by dev */
#define SES_S_DEV_BYPB(d)	((d)->f3 & (1<<2))
#define SES_S_DEV_BYPA(d)	((d)->f3 & (1<<3))
#define SES_S_DEV_OFF(d)	((d)->f3 & (1<<4)) /* device is off */
#define SES_S_DEV_FAULTRQST(d)	((d)->f3 & (1<<5)) /* fault indicator rqsted */
#define SES_S_DEV_FAULTSENSE(d)	((d)->f3 & (1<<6)) /* fault sensed */
#define SES_S_DEV_APPCLBYPB(d)	((d)->f3 & (1<<7)) /* port B bypassed by app */
d170 16
a185 9
#define SES_C_DEV_IDENT(d)	((d)->f2 |= (1<<1)) /* ident */
#define SES_C_DEV_REMOVE(d)	((d)->f2 |= (1<<2)) /* remove */
#define SES_C_DEV_INSERT(d)	((d)->f2 |= (1<<3)) /* insert */
#define SES_C_DEV_DONOTREM(d)	((d)->f2 |= (1<<6)) /* do not remove */
#define SES_C_DEV_ACTIVE(d)	((d)->f2 |= (1<<7)) /* active indicator */
#define SES_C_DEV_BYPB(d)	((d)->f3 |= (1<<2)) /* port B bypass */
#define SES_C_DEV_BYPA(d)	((d)->f3 |= (1<<3)) /* port A bypass */
#define SES_C_DEV_OFF(d)	((d)->f3 |= (1<<4)) /* off */
#define SES_C_DEV_FAULT(d)	((d)->f3 |= (1<<5)) /* fault indicator */
@


1.7
log
@Silly dlg did not read my old code careful enough.  Missed 2 bits that are
necessary for the blinkenlight magic.
Also removed some XXX cruft that was misleading.
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.6 2005/08/18 12:26:40 dlg Exp $ */
d215 1
a215 1
#define SES_S_TEMP_UTFAIL	((d)->f3 & (1<<1)) /* under temp failture */
@


1.6
log
@infrastructure to support blinking controlled via /dev/bio ioctls. the
code to do the actual blink is ifdefed out till marco can figure out what
im doing wrong.
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.5 2005/08/03 15:34:13 dlg Exp $ */
d37 1
d140 1
@


1.5
log
@report the state of the power supplies. the value shows if the psu is on
or off, but sysctl doesnt know how to display it (yet).

requested by marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.4 2005/08/02 03:35:14 dlg Exp $ */
d34 1
a34 1
	u_int8_t	opcode; /* RECEIVE_DIAGNOSTIC */
d146 1
a146 1
/* device */
d148 27
a174 3
#define SES_S_DEV_RDYTOINS(d)	((d)->f2 & (1<<3)) /* ready to insert */
#define SES_S_DEV_DONOTREM(d)	((d)->f2 & (1<<6)) /* no not remove */
/* XXX FINISH THIS */
@


1.4
log
@read the rpm of the fans
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.3 2005/08/01 23:14:31 dlg Exp $ */
d151 13
@


1.3
log
@a new scsi enclosure services driver. this and safte replace the old ses
driver. rather than relying on its own set of tools, ses reports the
enclosure status via the hw.sensors sysctl tree. so far only temperature
is reported

ok marco@@ deraadt@@ krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: scsi_ses.h,v 1.3 2005/04/12 20:44:18 marco Exp $ */
d151 19
@


1.2
log
@remove the ses driver. it has never been enabled in GENERIC on any arch
in openbsds lifetime so noone is going to miss it.

if you did enable it, it either didnt work or the data was hard to read
and usually wrong.

ok deraadt@@ marco@@
@
text
@d1 1
a1 2
/* $OpenBSD: ses.h,v 1.1 2000/02/21 08:23:30 mjacob Exp $ */
/* $NetBSD: ses.h,v 1.1 2000/01/20 17:07:41 mjacob Exp $ */
d3 1
a3 1
 * Copyright (C) 2000 National Aeronautics & Space Administration
d11 149
a159 150
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#define	SESIOC			(('s' - 040) << 8)
#define	SESIOC_GETNOBJ		_IO(SESIOC, 1)
#define	SESIOC_GETOBJMAP	_IO(SESIOC, 2)
#define	SESIOC_GETENCSTAT	_IO(SESIOC, 3)
#define	SESIOC_SETENCSTAT	_IO(SESIOC, 4)
#define	SESIOC_GETOBJSTAT	_IO(SESIOC, 5)
#define	SESIOC_SETOBJSTAT	_IO(SESIOC, 6)
#define	SESIOC_GETTEXT		_IO(SESIOC, 7)
#define	SESIOC_INIT		_IO(SESIOC, 8)

/*
 * Platform Independent Definitions for SES devices.
 */
/*
 * SCSI Based Environmental Services Application Defines
 *
 * Based almost entirely on SCSI-3 SES Revision 8A specification,
 * but slightly abstracted as the underlying device may in fact
 * be a SAF-TE or vendor unique device.
 */
/*
 * SES Driver Operations:
 * (The defines themselves are platform and access method specific)
 *
 * SESIOC_GETNOBJ
 * SESIOC_GETOBJMAP
 * SESIOC_GETENCSTAT
 * SESIOC_SETENCSTAT
 * SESIOC_GETOBJSTAT
 * SESIOC_SETOBJSTAT
 * SESIOC_INIT
 *
 *
 * An application finds out how many objects an SES instance
 * is managing by performing a SESIOC_GETNOBJ operation. It then
 * performs a SESIOC_GETOBJMAP to get the map that contains the
 * object identifiers for all objects (see ses_object below).
 * This information is static.
 * 
 * The application may perform SESIOC_GETOBJSTAT operations to retrieve
 * status on an object (see the ses_objstat structure below), SESIOC_SETOBJSTAT
 * operations to set status for an object.
 *
 * Similarly overall enclosure status me be fetched or set via
 * SESIOC_GETENCSTAT or  SESIOC_SETENCSTAT operations (see ses_encstat below).
 *
 * Readers should note that there is nothing that requires either a set
 * or a clear operation to actually latch and do anything in the target.
 *
 * A SESIOC_INIT operation causes the enclosure to be initialized.
 */

typedef struct {
	unsigned int	obj_id;		/* Object Identifier */
	unsigned char	subencid;	/* SubEnclosure ID */
	unsigned char	object_type;	/* Object Type */
} ses_object;

/* Object Types */
#define	SESTYP_UNSPECIFIED	0x00
#define	SESTYP_DEVICE		0x01
#define	SESTYP_POWER		0x02
#define	SESTYP_FAN		0x03
#define	SESTYP_THERM		0x04
#define	SESTYP_DOORLOCK		0x05
#define	SESTYP_ALARM		0x06
#define	SESTYP_ESCC		0x07	/* Enclosure SCC */
#define	SESTYP_SCC		0x08	/* SCC */
#define	SESTYP_NVRAM		0x09
#define	SESTYP_UPS		0x0b
#define	SESTYP_DISPLAY		0x0c
#define	SESTYP_KEYPAD		0x0d
#define	SESTYP_SCSIXVR		0x0f
#define	SESTYP_LANGUAGE		0x10
#define	SESTYP_COMPORT		0x11
#define	SESTYP_VOM		0x12
#define	SESTYP_AMMETER		0x13
#define	SESTYP_SCSI_TGT		0x14
#define	SESTYP_SCSI_INI		0x15
#define	SESTYP_SUBENC		0x16

/*
 * Overall Enclosure Status
 */
typedef unsigned char ses_encstat;
#define	SES_ENCSTAT_UNRECOV		0x1
#define	SES_ENCSTAT_CRITICAL		0x2
#define	SES_ENCSTAT_NONCRITICAL		0x4
#define	SES_ENCSTAT_INFO		0x8

/*
 * Object Status
 */
typedef struct {
	unsigned int	obj_id;
	unsigned char	cstat[4];
} ses_objstat;

/* Summary SES Status Defines, Common Status Codes */
#define	SES_OBJSTAT_UNSUPPORTED		0
#define	SES_OBJSTAT_OK			1
#define	SES_OBJSTAT_CRIT		2
#define	SES_OBJSTAT_NONCRIT		3
#define	SES_OBJSTAT_UNRECOV		4
#define	SES_OBJSTAT_NOTINSTALLED	5
#define	SES_OBJSTAT_UNKNOWN		6
#define	SES_OBJSTAT_NOTAVAIL		7

/*
 * For control pages, cstat[0] is the same for the
 * enclosure and is common across all device types.
 *
 * If SESCTL_CSEL is set, then PRDFAIL, DISABLE and RSTSWAP
 * are checked, otherwise bits that are specific to the device
 * type in the other 3 bytes of cstat or checked.
 */
#define	SESCTL_CSEL		0x80
#define	SESCTL_PRDFAIL		0x40
#define	SESCTL_DISABLE		0x20
#define	SESCTL_RSTSWAP		0x10


/* Control bits, Device Elements, byte 2 */
#define	SESCTL_DRVLCK	0x40	/* "DO NOT REMOVE" */
#define	SESCTL_RQSINS	0x08	/* RQST INSERT */
#define	SESCTL_RQSRMV	0x04	/* RQST REMOVE */
#define	SESCTL_RQSID	0x02	/* RQST IDENT */
/* Control bits, Device Elements, byte 3 */
#define	SESCTL_RQSFLT	0x20	/* RQST FAULT */
#define	SESCTL_DEVOFF	0x10	/* DEVICE OFF */

/* Control bits, Generic, byte 3 */
#define	SESCTL_RQSTFAIL	0x40
#define	SESCTL_RQSTON	0x20
d162 2
a163 6
 * Getting text for an object type is a little
 * trickier because it's string data that can
 * go up to 64 KBytes. Build this union and
 * fill the obj_id with the id of the object who's
 * help text you want, and if text is available,
 * obj_text will be filled in, null terminated.
d165 2
d168 1
a168 4
typedef union {
	unsigned int obj_id;
	char obj_text[1];
} ses_hlptxt;
@


1.1
log
@add SES/SAF-TE SCSI device
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
@


1.1.2.1
log
@sync with -current
@
text
@d1 1
a1 1
/* $OpenBSD: ses.h,v 1.1 2000/02/21 08:23:30 mjacob Exp $ */
@

