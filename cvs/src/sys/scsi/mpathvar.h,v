head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.14
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.12
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.8
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.10
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.6
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.9.0.4
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	OPENBSD_5_3:1.3.0.8
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.6
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.4
	OPENBSD_5_0:1.3.0.2
	OPENBSD_5_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.9
date	2013.08.27.00.53.10;	author dlg;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.26.12.20.12;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2013.08.26.10.13.17;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2013.08.26.07.38.56;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2013.08.26.07.29.45;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2013.06.10.04.16.33;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2011.07.11.01.02.48;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2011.04.28.10.43.36;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2011.04.05.14.25.42;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.9
log
@get rid of the different path scheduler types, which simplifies the
code that picks the next path. we assume roundrobin within a group
of paths now. the asym sym(4) devices work around this by putting
every path in its own group.
@
text
@/*	$OpenBSD: mpathvar.h,v 1.8 2013/08/26 12:20:12 dlg Exp $ */

/*
 * Copyright (c) 2010 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _SYS_SCSI_MPATH_H_
#define _SYS_SCSI_MPATH_H_

struct mpath_group;

struct mpath_ops {
	char	op_name[16];
	int	(*op_checksense)(struct scsi_xfer *);
	void	(*op_status)(struct scsi_link *);
};

#define MPATH_SENSE_DECLINED	0 /* path driver declined to interpret sense */
#define MPATH_SENSE_FAILOVER	1 /* sense says controllers have failed over */

#define MPATH_S_UNKNOWN		-1
#define MPATH_S_ACTIVE		0
#define MPATH_S_PASSIVE		1

struct mpath_path {
	/* the path driver must set these */
	struct scsi_xshandler	 p_xsh;
	struct scsi_link	*p_link;
	int			 p_gid;

	/* the following are private to mpath.c */
	TAILQ_ENTRY(mpath_path)	 p_entry;
	struct mpath_group	*p_group;
	int			 p_state;
};

int			 mpath_path_probe(struct scsi_link *);
int			 mpath_path_attach(struct mpath_path *, u_int,
			    const struct mpath_ops *);
void			 mpath_path_status(struct mpath_path *, int);
int			 mpath_path_detach(struct mpath_path *);

void			 mpath_start(struct mpath_path *, struct scsi_xfer *);

struct device		*mpath_bootdv(struct device *);

#endif /* _SYS_SCSI_MPATH_H_ */
@


1.8
log
@implement handling of group failover.

if a controller sends sense data back, the path driver can tell
mpath that its indicating failover which kicks off an iteration
over all the groups until one says its active. if no groups claim
to be active, a timeout fires the process off again after a second.

you can start controller handover on rdac (well, an md3200i is all
i had to test with, others might need more work) and everything
keeps going. ill try to get to emc and hds working when i can poke
hardware again.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.4 2013/06/10 04:16:33 dlg Exp $ */
a27 1
	int	op_schedule;
a35 4

#define MPATH_ROUNDROBIN	0 /* use all active paths */
#define MPATH_NEXT		MPATH_ROUNDROBIN
#define MPATH_MRU		1 /* use most recently used path */
@


1.7
log
@when i first imagined how paths on mpath worked, i thought the
midlayer would be able to call things on paths to explicitely online
or offline them. turns out thats not how the Real World(tm) works,
instead its better to wait for failure and probe for the status of
paths, and pick the active group of paths from that. there's even
evidence that the mechanisms for forcing controllers into active/passive
roles from the scsi initiator are being deprecated. they expect
hosts to be able to cope with arbitrary controller role changes and
failover
accordingly.

this replaces the online and offline function pointers in the path_ops
structure with a status check function pointer. instead of returning a
state, the checker is expected to call mpath_path_status() when its
finished figuring out what the state is.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.6 2013/08/26 07:38:56 dlg Exp $ */
a21 1
struct mpath_dev;
d50 1
a50 1
	struct mpath_dev	*p_dev;
@


1.6
log
@checksense handlers in path drivers can return MPATH_SENSE_DECLINED
(who can tell ive spent time in web servers) to say they decline
interpreting the sense data, or MPATH_SENSE_FAILOVER to say the
sense data is from the controller saying its failed over.

all path drivers currently decline handling sense data.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.5 2013/08/26 07:29:45 dlg Exp $ */
d28 1
a28 2
	int	(*op_online)(struct scsi_link *);
	int	(*op_offline)(struct scsi_link *);
d35 4
d58 1
a58 1
void			 mpath_path_state(struct mpath_path *, int);
@


1.5
log
@introduce the idea of groups of paths. mpath had stuff to managed
devices and paths. devices are what mpath presents as targets on
its scsibus, and paths are the things attached to hardware controllers
that are available to shove io down to the actual real target. all
paths were considered usable for handling io on behalf of a device.

this adds groups in between devices and paths. only paths on the
first group in the list will now be used to handle io now.

sym devices will only have one group. asym devices will treat each
path as a different group. rdac, emc, and hds will group paths based
on which controller in the array theyre connected to.

in the future we will intercept sense data from passive controllers
and use that to start running checks to pick a new primary group
so we can handle controller failover situations.

the group id in hds(4) is currently busted, everything else should
be correct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.4 2013/06/10 04:16:33 dlg Exp $ */
d32 3
@


1.4
log
@spelling in comment fix (for real, there's no code change here).
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.3 2011/07/11 01:02:48 dlg Exp $ */
d50 1
a50 1
int			 mpath_path_attach(struct mpath_path *,
@


1.3
log
@support "failover" style access to volumes, ie, only use one active
path when talking to an array until it goes away, then you fail
over to the next active path.

im using this to talk to ses(4) in my dell, and allows us to support
arrays that have multiple controllers but have no way of reporting
which one is active. using the MRU semantic means we can talk to
them without them flipping the active role between its controllers
all the time. claudios transtec iscsi box is like this.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.2 2011/04/28 10:43:36 dlg Exp $ */
d43 1
a43 1
	/* the follwoing are private to mpath.c */
@


1.2
log
@clean up the path ops struct a bit. the path drivers init their xsh with
their start routines, they dont have to pass pointers to them in the
ops struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpathvar.h,v 1.1 2011/04/05 14:25:42 dlg Exp $ */
d30 1
d33 4
a40 1
	struct mpath_ops	*p_ops;
d50 2
a51 1
int			 mpath_path_attach(struct mpath_path *);
@


1.1
log
@move forward with scsi multipathing.

the big change is how paths between mpath capable devices and the
kernel are managed.

originally the midlayer would steal the links to the devices and
hide them behind mpath. all the changes an adapter made to a link
(eg activate or detach), the midlayer had to test if it was an mpath
link and then call special mpath code to handle it.

the original code also assumed that all paths behaved the same, but
the reality is that different devices have different command sets
and behaviours. figuring out which behaviour to pick and prioritising
them is basically the same job autoconf does with match and attach.

rather than special casing mpath in the midlayer and reimplimenting
autoconf, this turns paths into actual device drivers with match
and attach routines. after they figure out if the path is active,
they then give it to mpath(4) to use as a backend.

i have written drivers for symmetric access devices (sym(4)) where
all paths to the same logical unit are as good as each other,
lsi/engenio arrays (rdac(4), and emc arrays (emc(4)).

the rdac and emc drivers only detect active paths at attach time,
the do not cope if the controller changes state unless you unplug
the path and plug it in again to retest the active state. they also
do not have support for directing array failover.

operating and hoplugging has been tested with mpii(4), fc and sas
mpi(4), and iscsi via vscsi (claudio did this too).

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a26 1
	void	(*op_start)(struct scsi_xfer *);
@

